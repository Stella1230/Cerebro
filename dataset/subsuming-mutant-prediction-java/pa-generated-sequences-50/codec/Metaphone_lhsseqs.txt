public String metaphone ( final String txt ) { boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) { MST[InlineConstantMutator]MSP[]
code . append ( symb ) ; } break; case 'B' : if ( isPreviousChar ( local , n , 'M' ) && isLastChar ( wdsz , n ) ) { break; } code . append ( symb ) ; MST[rv.UOI2Mutator]MSP[] break; case 'C' :
if ( regionMatch ( local , n , lr_8 ) || MST[rv.ROR3Mutator]MSP[] regionMatch ( local , n , lr_9 ) ) { code . append ( 'X' ) ; break; } if ( regionMatch ( local , n , lr_10 ) ) { break; }
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { MST[NonVoidMethodCallMutator]MSP[] matches = string . charAt ( index + 1 ) == c ;
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && MST[rv.UOI4Mutator]MSP[] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; break; }
final String substring = string . substring ( index , index + test . length () ) ; MST[rv.UOI3Mutator]MSP[] matches = substring . equals ( test ) ; } return matches ; } private boolean isLastChar ( final int wdsz , final int n ) {
code . append ( 'S' ) ; MST[rv.CRCR5Mutator]MSP[] break; default: break; } n ++ ; } if ( code . length () > this . getMaxCodeLen () ) { code . setLength ( this . getMaxCodeLen () ) ; } } return code . toString () ; }
final int wdsz = local . length () ; int n = 0 ; while ( code . length () < this . getMaxCodeLen () && MST[RemoveConditionalMutator_ORDER_IF]MSP[] n < wdsz ) { final char symb = local . charAt ( n ) ;
public String metaphone ( final String txt ) { boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) { MST[rv.UOI2Mutator]MSP[]
local . append ( inwd , 1 , inwd . length - 1 ) ; break; } if ( inwd [ 1 ] == 'H' ) { MST[rv.ROR2Mutator]MSP[] local . append ( inwd , 1 , inwd . length - 1 ) ;
if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.ROR3Mutator]MSP[] isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[InlineConstantMutator]MSP[] } else { local . append ( inwd ) ; } break; case 'W' : if ( inwd [ 1 ] == 'R' ) {
if ( regionMatch ( local , n , lr_8 ) || regionMatch ( local , n , lr_9 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] code . append ( 'X' ) ; break; } if ( regionMatch ( local , n , lr_10 ) ) { break; }
code . append ( symb ) ; } break; case 'B' : if ( isPreviousChar ( local , n , 'M' ) && isLastChar ( wdsz , n ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] break; } code . append ( symb ) ; break; case 'C' :
} if ( isPreviousChar ( local , n , 'G' ) ) { hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) && MST[rv.ROR5Mutator]MSP[]
code . append ( 'H' ) ; MST[rv.CRCR6Mutator]MSP[] } break; case 'F' : case 'J' : case 'L' : case 'M' : case 'N' : case 'R' : code . append ( symb ) ; break; case 'K' : if ( n > 0 ) {
} else { code . append ( 'T' ) ; MST[rv.CRCR6Mutator]MSP[] } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
if ( regionMatch ( local , n , lr_11 ) ) { MST[rv.UOI3Mutator]MSP[] code . append ( '0' ) ; } else { code . append ( 'T' ) ; } break; case 'V' : code . append ( 'F' ) ; break; case 'W' : case 'Y' :
local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break; case 'A' : if ( inwd [ 1 ] == 'E' ) { MST[rv.CRCR4Mutator]MSP[]
local . append ( inwd , 1 , inwd . length - 1 ) ; break; } if ( inwd [ 1 ] == 'H' ) { local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.CRCR3Mutator]MSP[]
if ( ! isPreviousChar ( local , n , 'C' ) ) { code . append ( symb ) ; } } else { code . append ( symb ) ; } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) { MST[rv.ABSMutator]MSP[]
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && MST[rv.ROR4Mutator]MSP[] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
if ( ! isPreviousChar ( local , n , 'C' ) ) { code . append ( symb ) ; } } else { code . append ( symb ) ; } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) { MST[InlineConstantMutator]MSP[]
public String metaphone ( final String txt ) { boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; MST[ReturnValsMutator]MSP[] } if ( txtLength == 1 ) {
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { n ++ ; } else { switch( symb ) { MST[rv.UOI1Mutator]MSP[] case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
if ( isPreviousChar ( local , n , 'S' ) && MST[NegateConditionalsMutator]MSP[] isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 &&
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && MST[rv.AOR2Mutator]MSP[] FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
if ( regionMatch ( local , n , lr_8 ) || MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] regionMatch ( local , n , lr_9 ) ) { code . append ( 'X' ) ; break; } if ( regionMatch ( local , n , lr_10 ) ) { break; }
} if ( isPreviousChar ( local , n , 'G' ) ) { MST[rv.UOI3Mutator]MSP[] hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) &&
code . append ( 'H' ) ; MST[experimental.NakedReceiverMutator]MSP[] } break; case 'F' : case 'J' : case 'L' : case 'M' : case 'N' : case 'R' : code . append ( symb ) ; break; case 'K' : if ( n > 0 ) {
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && MST[RemoveConditionalMutator_EQUAL_IF]MSP[] FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
local . append ( inwd , 1 , inwd . length - 1 ) ; break; } if ( inwd [ 1 ] == 'H' ) { local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.AOR4Mutator]MSP[]
if ( ! isLastChar ( wdsz , n ) && isVowel ( local , n + 1 ) ) { MST[rv.ROR3Mutator]MSP[] code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break; case 'Z' :
code . append ( symb ) ; } break; case 'B' : if ( isPreviousChar ( local , n , 'M' ) && isLastChar ( wdsz , n ) ) { break; } code . append ( symb ) ; MST[rv.ABSMutator]MSP[] break; case 'C' :
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.UOI2Mutator]MSP[] ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
if ( ! isLastChar ( wdsz , n ) && isVowel ( local , n + 1 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break; case 'Z' :
private boolean isVowel ( final StringBuilder string , final int index ) { return VOWELS . indexOf ( string . charAt ( index ) ) >= 0 ; MST[rv.ROR1Mutator]MSP[] } private boolean isPreviousChar ( final StringBuilder string , final int index , final char c ) {
} if ( isPreviousChar ( local , n , 'G' ) ) { hard = true ; } else { hard = false ; MST[rv.CRCR6Mutator]MSP[] } if ( ! isLastChar ( wdsz , n ) &&
code . append ( 'H' ) ; } break; case 'F' : case 'J' : case 'L' : case 'M' : case 'N' : case 'R' : code . append ( symb ) ; MST[rv.UOI4Mutator]MSP[] break; case 'K' : if ( n > 0 ) {
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[experimental.NakedReceiverMutator]MSP[] break; } if ( inwd [ 1 ] == 'H' ) { local . append ( inwd , 1 , inwd . length - 1 ) ;
isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { MST[rv.ROR4Mutator]MSP[] break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 && ! hard ) { code . append ( 'J' ) ; } else { code . append ( 'K' ) ; MST[InlineConstantMutator]MSP[] } break; case 'H' :
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { MST[NonVoidMethodCallMutator]MSP[] code . append ( 'J' ) ; n += 2 ;
regionMatch ( local , n , lr_6 ) || regionMatch ( local , n , lr_7 ) ) { code . append ( 'X' ) ; MST[rv.CRCR1Mutator]MSP[] } else { code . append ( 'S' ) ; } break; case 'T' :
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.CRCR6Mutator]MSP[] } else { local . append ( inwd ) ; } break; case 'A' : if ( inwd [ 1 ] == 'E' ) {
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && index + test . length () - 1 < string . length () ) { MST[rv.CRCR5Mutator]MSP[]
return n + 1 == wdsz ; MST[NegateConditionalsMutator]MSP[] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
if ( ! isLastChar ( wdsz , n + 1 ) && MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
isNextChar ( local , n , 'H' ) && MST[rv.AOD1Mutator]MSP[] ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
public String metaphone ( final String txt ) { boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) { MST[rv.ABSMutator]MSP[]
public String metaphone ( final String txt ) { boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { MST[rv.ROR1Mutator]MSP[] return lr_1 ; } if ( txtLength == 1 ) {
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 && MST[rv.CRCR4Mutator]MSP[]
if ( ! isPreviousChar ( local , n , 'C' ) ) { code . append ( symb ) ; } } else { code . append ( symb ) ; } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) { MST[rv.UOI2Mutator]MSP[]
} if ( isPreviousChar ( local , n , 'G' ) ) { hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) && MST[NegateConditionalsMutator]MSP[]
} else { code . append ( 'T' ) ; MST[experimental.NakedReceiverMutator]MSP[] } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) && MST[InlineConstantMutator]MSP[]
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.ABSMutator]MSP[] ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.ROR5Mutator]MSP[] isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 &&
if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.UOI1Mutator]MSP[] isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { MST[ConditionalsBoundaryMutator]MSP[] matches = string . charAt ( index + 1 ) == c ;
code . append ( 'F' ) ; } else { code . append ( symb ) ; MST[experimental.NakedReceiverMutator]MSP[] } break; case 'Q' : code . append ( 'K' ) ; break; case 'S' : if ( regionMatch ( local , n , lr_5 ) ||
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.UOI4Mutator]MSP[] isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 &&
wdsz >= 3 && isVowel ( local , 2 ) ) { code . append ( 'K' ) ; } else { code . append ( 'X' ) ; MST[rv.CRCR5Mutator]MSP[] } } else { code . append ( 'K' ) ; } break; case 'D' :
if ( ! isPreviousChar ( local , n , 'C' ) ) { MST[rv.CRCR4Mutator]MSP[] code . append ( symb ) ; } } else { code . append ( symb ) ; } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) {
final int wdsz = local . length () ; int n = 0 ; while ( code . length () < this . getMaxCodeLen () && MST[rv.ABSMutator]MSP[] n < wdsz ) { final char symb = local . charAt ( n ) ;
code . append ( 'S' ) ; break; default: break; } n ++ ; } if ( code . length () > this . getMaxCodeLen () ) { code . setLength ( this . getMaxCodeLen () ) ; MST[NonVoidMethodCallMutator]MSP[] } } return code . toString () ; }
code . append ( 'F' ) ; } else { code . append ( symb ) ; } break; case 'Q' : code . append ( 'K' ) ; break; case 'S' : if ( regionMatch ( local , n , lr_5 ) || MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 && MST[rv.ROR4Mutator]MSP[] ! hard ) { code . append ( 'J' ) ; } else { code . append ( 'K' ) ; } break; case 'H' :
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { MST[rv.ABSMutator]MSP[] if ( n == 0 &&
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ; MST[rv.CRCR5Mutator]MSP[]
if ( isPreviousChar ( local , n , 'S' ) && MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
isNextChar ( local , n , 'H' ) && MST[rv.ROR1Mutator]MSP[] ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
public String metaphone ( final String txt ) { boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { MST[NonVoidMethodCallMutator]MSP[] return lr_1 ; } if ( txtLength == 1 ) {
return n + 1 == wdsz ; MST[rv.UOI3Mutator]MSP[] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.ROR4Mutator]MSP[]
local . append ( inwd , 1 , inwd . length - 1 ) ; break; } if ( inwd [ 1 ] == 'H' ) { MST[rv.CRCR5Mutator]MSP[] local . append ( inwd , 1 , inwd . length - 1 ) ;
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { MST[rv.ROR3Mutator]MSP[] break; } if ( regionMatch ( local , n , lr_2 ) ) {
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; } return matches ; MST[rv.UOI3Mutator]MSP[] }
local . setCharAt ( 0 , 'W' ) ; } else { local . append ( inwd ) ; } break; case 'X' : inwd [ 0 ] = 'S' ; local . append ( inwd ) ; MST[NonVoidMethodCallMutator]MSP[] break; default: local . append ( inwd ) ; }
private boolean isVowel ( final StringBuilder string , final int index ) { return VOWELS . indexOf ( string . charAt ( index ) ) >= 0 ; MST[rv.CRCR4Mutator]MSP[] } private boolean isPreviousChar ( final StringBuilder string , final int index , final char c ) {
boolean matches = false ; if( index > 0 && index < string . length () ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] matches = string . charAt ( index - 1 ) == c ; } return matches ; }
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 && MST[rv.CRCR1Mutator]MSP[]
if ( regionMatch ( local , n , lr_11 ) ) { code . append ( '0' ) ; } else { code . append ( 'T' ) ; MST[InlineConstantMutator]MSP[] } break; case 'V' : code . append ( 'F' ) ; break; case 'W' : case 'Y' :
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && index + test . length () - 1 < string . length () ) { MST[rv.AOR1Mutator]MSP[]
isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { MST[rv.ROR2Mutator]MSP[] break;
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.ROR3Mutator]MSP[] ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
if ( regionMatch ( local , n , lr_8 ) || regionMatch ( local , n , lr_9 ) ) { code . append ( 'X' ) ; break; } if ( regionMatch ( local , n , lr_10 ) ) { MST[rv.ROR2Mutator]MSP[] break; }
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ; MST[IncrementsMutator]MSP[]
if ( ! isPreviousChar ( local , n , 'C' ) ) { MST[NegateConditionalsMutator]MSP[] code . append ( symb ) ; } } else { code . append ( symb ) ; } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) {
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && MST[rv.CRCR5Mutator]MSP[] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
final int wdsz = local . length () ; int n = 0 ; while ( code . length () < this . getMaxCodeLen () && n < wdsz ) { final char symb = local . charAt ( n ) ; MST[rv.UOI4Mutator]MSP[]
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; MST[rv.UOI3Mutator]MSP[] } return matches ; }
if ( ! isLastChar ( wdsz , n ) && isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; MST[rv.CRCR6Mutator]MSP[] break; case 'Z' :
final StringBuilder code = new StringBuilder ( 10 ) ; switch( inwd [ 0 ] ) { case 'K' : case 'G' : case 'P' : if ( inwd [ 1 ] == 'N' ) { MST[rv.CRCR1Mutator]MSP[]
local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break; case 'W' : if ( inwd [ 1 ] == 'R' ) { MST[rv.CRCR4Mutator]MSP[]
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; MST[rv.CRCR3Mutator]MSP[] break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 &&
public int getMaxCodeLen () { return this . maxCodeLen ; } MST[ReturnValsMutator]MSP[] public void setMaxCodeLen ( final int maxCodeLen ) { this . maxCodeLen = maxCodeLen ; }
final int wdsz = local . length () ; int n = 0 ; while ( code . length () < this . getMaxCodeLen () && MST[rv.UOI2Mutator]MSP[] n < wdsz ) { final char symb = local . charAt ( n ) ;
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; } return matches ; MST[BooleanTrueReturnValsMutator]MSP[] }
if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.CRCR4Mutator]MSP[] isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
if ( ! isPreviousChar ( local , n , 'C' ) ) { code . append ( symb ) ; MST[experimental.NakedReceiverMutator]MSP[] } } else { code . append ( symb ) ; } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) {
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) { MST[rv.ROR2Mutator]MSP[]
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) { MST[rv.CRCR5Mutator]MSP[]
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && MST[rv.CRCR1Mutator]MSP[] FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
local . setCharAt ( 0 , 'W' ) ; MST[rv.CRCR1Mutator]MSP[] } else { local . append ( inwd ) ; } break; case 'X' : inwd [ 0 ] = 'S' ; local . append ( inwd ) ; break; default: local . append ( inwd ) ; }
isNextChar ( local , n , 'H' ) && MST[rv.CRCR2Mutator]MSP[] ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
code . append ( 'F' ) ; } else { code . append ( symb ) ; } break; case 'Q' : code . append ( 'K' ) ; MST[rv.CRCR5Mutator]MSP[] break; case 'S' : if ( regionMatch ( local , n , lr_5 ) ||
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.ABSMutator]MSP[]
if ( ! isLastChar ( wdsz , n ) && MST[RemoveConditionalMutator_EQUAL_IF]MSP[] isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break; case 'Z' :
code . append ( symb ) ; MST[rv.UOI3Mutator]MSP[] } break; case 'B' : if ( isPreviousChar ( local , n , 'M' ) && isLastChar ( wdsz , n ) ) { break; } code . append ( symb ) ; break; case 'C' :
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) { MST[rv.UOI4Mutator]MSP[]
wdsz >= 3 && isVowel ( local , 2 ) ) { code . append ( 'K' ) ; } else { code . append ( 'X' ) ; } } else { code . append ( 'K' ) ; MST[NonVoidMethodCallMutator]MSP[] } break; case 'D' :
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.UOI3Mutator]MSP[]
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { MST[InlineConstantMutator]MSP[] matches = string . charAt ( index + 1 ) == c ;
if ( regionMatch ( local , n , lr_11 ) ) { code . append ( '0' ) ; } else { code . append ( 'T' ) ; } break; case 'V' : code . append ( 'F' ) ; break; MST[experimental.NakedReceiverMutator]MSP[] case 'W' : case 'Y' :
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[] code . append ( 'J' ) ; n += 2 ;
final String substring = string . substring ( index , index + test . length () ) ; MST[rv.AOD2Mutator]MSP[] matches = substring . equals ( test ) ; } return matches ; } private boolean isLastChar ( final int wdsz , final int n ) {
local . append ( inwd , 1 , inwd . length - 1 ) ; break; } if ( inwd [ 1 ] == 'H' ) { local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.AOD2Mutator]MSP[]
isNextChar ( local , n , 'H' ) && MST[rv.AOR3Mutator]MSP[] ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.CRCR4Mutator]MSP[] isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 &&
if ( ! isLastChar ( wdsz , n ) && isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; MST[rv.CRCR3Mutator]MSP[] break; case 'Z' :
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && index + test . length () - 1 < string . length () ) { MST[rv.AOD1Mutator]MSP[]
if ( ! isLastChar ( wdsz , n ) && isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; MST[rv.CRCR1Mutator]MSP[] code . append ( 'S' ) ; break; case 'Z' :
if ( ! isLastChar ( wdsz , n ) && MST[rv.AOR2Mutator]MSP[] isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break; case 'Z' :
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] matches = string . charAt ( index + 1 ) == c ;
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { MST[rv.UOI2Mutator]MSP[] n ++ ; } else { switch( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
if ( ! isLastChar ( wdsz , n ) && MST[rv.UOI3Mutator]MSP[] isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break; case 'Z' :
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { MST[NonVoidMethodCallMutator]MSP[] code . append ( 'S' ) ; break; }
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; MST[rv.CRCR6Mutator]MSP[] break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 &&
code . append ( 'S' ) ; break; default: break; } n ++ ; } if ( code . length () > this . getMaxCodeLen () ) { MST[rv.ROR1Mutator]MSP[] code . setLength ( this . getMaxCodeLen () ) ; } } return code . toString () ; }
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && index + test . length () - 1 < string . length () ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[]
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.CRCR6Mutator]MSP[] break; } if ( inwd [ 1 ] == 'H' ) { local . append ( inwd , 1 , inwd . length - 1 ) ;
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; MST[rv.CRCR1Mutator]MSP[] } return matches ; }
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; MST[rv.CRCR4Mutator]MSP[] } return matches ; }
local . append ( inwd , 1 , inwd . length - 1 ) ; break; } if ( inwd [ 1 ] == 'H' ) { MST[rv.ROR5Mutator]MSP[] local . append ( inwd , 1 , inwd . length - 1 ) ;
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && MST[MathMutator]MSP[] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && MST[rv.ROR1Mutator]MSP[] index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ;
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 && MST[RemoveConditionalMutator_ORDER_IF]MSP[]
final String substring = string . substring ( index , index + test . length () ) ; matches = substring . equals ( test ) ; } return matches ; MST[rv.UOI4Mutator]MSP[] } private boolean isLastChar ( final int wdsz , final int n ) {
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && MST[rv.AOR2Mutator]MSP[] VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) {
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ; MST[MathMutator]MSP[]
if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.UOI4Mutator]MSP[] isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
final StringBuilder code = new StringBuilder ( 10 ) ; switch( inwd [ 0 ] ) { case 'K' : case 'G' : case 'P' : if ( inwd [ 1 ] == 'N' ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.ABSMutator]MSP[] isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
} if ( isPreviousChar ( local , n , 'G' ) ) { hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) && MST[rv.UOI4Mutator]MSP[]
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && MST[rv.UOI3Mutator]MSP[] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
if ( isPreviousChar ( local , n , 'S' ) && MST[InlineConstantMutator]MSP[] isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 &&
final StringBuilder code = new StringBuilder ( 10 ) ; MST[rv.CRCR6Mutator]MSP[] switch( inwd [ 0 ] ) { case 'K' : case 'G' : case 'P' : if ( inwd [ 1 ] == 'N' ) {
if ( ! isLastChar ( wdsz , n ) && MST[NonVoidMethodCallMutator]MSP[] isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break; case 'Z' :
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && MST[rv.UOI2Mutator]MSP[] index + test . length () - 1 < string . length () ) {
if ( regionMatch ( local , n , lr_8 ) || MST[rv.UOI2Mutator]MSP[] regionMatch ( local , n , lr_9 ) ) { code . append ( 'X' ) ; break; } if ( regionMatch ( local , n , lr_10 ) ) { break; }
local . append ( inwd , 1 , inwd . length - 1 ) ; break; } if ( inwd [ 1 ] == 'H' ) { local . append ( inwd , 1 , inwd . length - 1 ) ; MST[NonVoidMethodCallMutator]MSP[]
isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || MST[NegateConditionalsMutator]MSP[] regionMatch ( local , n , lr_4 ) ) ) { break;
if ( ! isLastChar ( wdsz , n ) && isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; MST[rv.CRCR4Mutator]MSP[] code . append ( 'S' ) ; break; case 'Z' :
local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break; case 'W' : if ( inwd [ 1 ] == 'R' ) { MST[rv.CRCR2Mutator]MSP[]
if ( ! isLastChar ( wdsz , n + 1 ) && MST[InlineConstantMutator]MSP[] isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) { MST[MathMutator]MSP[]
public String metaphone ( final String txt ) { boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { MST[rv.ROR4Mutator]MSP[] return lr_1 ; } if ( txtLength == 1 ) {
public String metaphone ( final String txt ) { MST[rv.ROR2Mutator]MSP[] boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) {
public String metaphone ( final String txt ) { MST[rv.UOI2Mutator]MSP[] boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) {
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 && MST[NegateConditionalsMutator]MSP[]
return n + 1 == wdsz ; MST[rv.UOI4Mutator]MSP[] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
isNextChar ( local , n , 'H' ) && MST[rv.CRCR5Mutator]MSP[] ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
} if ( isPreviousChar ( local , n , 'G' ) ) { hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) && MST[rv.CRCR6Mutator]MSP[]
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) { MST[rv.ROR5Mutator]MSP[]
if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.UOI2Mutator]MSP[] isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { MST[NegateConditionalsMutator]MSP[] matches = string . charAt ( index + 1 ) == c ;
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 && MST[rv.CRCR4Mutator]MSP[]
if ( regionMatch ( local , n , lr_11 ) ) { code . append ( '0' ) ; } else { code . append ( 'T' ) ; } break; case 'V' : code . append ( 'F' ) ; break; MST[rv.CRCR6Mutator]MSP[] case 'W' : case 'Y' :
FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 && ! hard ) { code . append ( 'J' ) ; MST[rv.CRCR3Mutator]MSP[] } else { code . append ( 'K' ) ; } break; case 'H' :
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && MST[rv.ROR3Mutator]MSP[] VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) {
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.UOI2Mutator]MSP[] isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 &&
if ( ! isLastChar ( wdsz , n ) && MST[rv.CRCR4Mutator]MSP[] isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break; case 'Z' :
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) { MST[rv.UOI3Mutator]MSP[]
if ( regionMatch ( local , n , lr_8 ) || regionMatch ( local , n , lr_9 ) ) { code . append ( 'X' ) ; break; } if ( regionMatch ( local , n , lr_10 ) ) { MST[rv.ROR5Mutator]MSP[] break; }
isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { MST[rv.ROR5Mutator]MSP[] break;
code . append ( 'F' ) ; } else { code . append ( symb ) ; } break; case 'Q' : code . append ( 'K' ) ; break; case 'S' : if ( regionMatch ( local , n , lr_5 ) || MST[NonVoidMethodCallMutator]MSP[]
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && index + test . length () - 1 < string . length () ) { MST[rv.AOR4Mutator]MSP[]
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ; MST[rv.UOI3Mutator]MSP[]
public String metaphone ( final String txt ) { boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) { MST[rv.ROR2Mutator]MSP[]
isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && MST[rv.ROR1Mutator]MSP[] ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; MST[rv.ROR1Mutator]MSP[] } return matches ; }
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && index + test . length () - 1 < string . length () ) { MST[rv.CRCR2Mutator]MSP[]
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[InlineConstantMutator]MSP[] } else { local . append ( inwd ) ; } break; case 'A' : if ( inwd [ 1 ] == 'E' ) {
regionMatch ( local , n , lr_6 ) || regionMatch ( local , n , lr_7 ) ) { code . append ( 'X' ) ; MST[rv.CRCR4Mutator]MSP[] } else { code . append ( 'S' ) ; } break; case 'T' :
final StringBuilder code = new StringBuilder ( 10 ) ; switch( inwd [ 0 ] ) { case 'K' : case 'G' : case 'P' : if ( inwd [ 1 ] == 'N' ) { MST[rv.CRCR4Mutator]MSP[]
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && MST[rv.ABSMutator]MSP[] index + test . length () - 1 < string . length () ) {
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; MST[experimental.NakedReceiverMutator]MSP[] break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 &&
if ( isLastChar ( wdsz , n ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) {
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[] code . append ( 'S' ) ; break; }
isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && MST[rv.UOI3Mutator]MSP[] ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
code . append ( 'F' ) ; MST[NonVoidMethodCallMutator]MSP[] } else { code . append ( symb ) ; } break; case 'Q' : code . append ( 'K' ) ; break; case 'S' : if ( regionMatch ( local , n , lr_5 ) ||
if ( ! isPreviousChar ( local , n , 'C' ) ) { MST[InlineConstantMutator]MSP[] code . append ( symb ) ; } } else { code . append ( symb ) ; } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) {
boolean matches = false ; MST[InlineConstantMutator]MSP[] if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; } return matches ; }
final String substring = string . substring ( index , index + test . length () ) ; MST[rv.ABSMutator]MSP[] matches = substring . equals ( test ) ; } return matches ; } private boolean isLastChar ( final int wdsz , final int n ) {
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && MST[NonVoidMethodCallMutator]MSP[] FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { MST[rv.ROR2Mutator]MSP[] code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 &&
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { MST[rv.ROR2Mutator]MSP[] break; } if ( isVowel ( local , n + 1 ) ) {
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; MST[MathMutator]MSP[] } return matches ; }
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[experimental.NakedReceiverMutator]MSP[] } else { local . append ( inwd ) ; } break; case 'W' : if ( inwd [ 1 ] == 'R' ) {
public String metaphone ( final String txt ) { MST[rv.CRCR2Mutator]MSP[] boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) {
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && MST[rv.ABSMutator]MSP[] index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ;
local . append ( inwd , 1 , inwd . length - 1 ) ; break; } if ( inwd [ 1 ] == 'H' ) { local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.CRCR2Mutator]MSP[]
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; MST[rv.UOI3Mutator]MSP[] } return matches ; }
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.CRCR6Mutator]MSP[] } else { local . append ( inwd ) ; } break; case 'W' : if ( inwd [ 1 ] == 'R' ) {
final String substring = string . substring ( index , index + test . length () ) ; MST[rv.AOR4Mutator]MSP[] matches = substring . equals ( test ) ; } return matches ; } private boolean isLastChar ( final int wdsz , final int n ) {
return n + 1 == wdsz ; MST[rv.ROR2Mutator]MSP[] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { MST[rv.CRCR5Mutator]MSP[] n ++ ; } else { switch( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
code . append ( 'X' ) ; MST[rv.CRCR1Mutator]MSP[] break; } if ( ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; break; }
wdsz >= 3 && isVowel ( local , 2 ) ) { code . append ( 'K' ) ; } else { code . append ( 'X' ) ; } } else { code . append ( 'K' ) ; MST[rv.CRCR2Mutator]MSP[] } break; case 'D' :
if ( isLastChar ( wdsz , n ) ) { MST[rv.UOI3Mutator]MSP[] break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) {
local . setCharAt ( 0 , 'W' ) ; } else { local . append ( inwd ) ; } break; case 'X' : inwd [ 0 ] = 'S' ; MST[rv.CRCR6Mutator]MSP[] local . append ( inwd ) ; break; default: local . append ( inwd ) ; }
final int wdsz = local . length () ; int n = 0 ; while ( code . length () < this . getMaxCodeLen () && MST[rv.UOI1Mutator]MSP[] n < wdsz ) { final char symb = local . charAt ( n ) ;
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && MST[rv.UOI4Mutator]MSP[] index + test . length () - 1 < string . length () ) {
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && MST[rv.ABSMutator]MSP[] isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
if ( ! isLastChar ( wdsz , n ) && isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; MST[experimental.NakedReceiverMutator]MSP[] break; case 'Z' :
if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.CRCR6Mutator]MSP[] isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
} return matches ; MST[rv.UOI3Mutator]MSP[] } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && index + test . length () - 1 < string . length () ) {
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && index + test . length () - 1 < string . length () ) { MST[rv.AOD2Mutator]MSP[]
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ; MST[rv.ROR1Mutator]MSP[]
code . append ( symb ) ; MST[NonVoidMethodCallMutator]MSP[] } break; case 'B' : if ( isPreviousChar ( local , n , 'M' ) && isLastChar ( wdsz , n ) ) { break; } code . append ( symb ) ; break; case 'C' :
return n + 1 == wdsz ; } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { MST[rv.ROR1Mutator]MSP[] throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 && MST[InlineConstantMutator]MSP[]
FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 && MST[rv.UOI1Mutator]MSP[] ! hard ) { code . append ( 'J' ) ; } else { code . append ( 'K' ) ; } break; case 'H' :
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && MST[rv.UOI3Mutator]MSP[] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; break; }
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 && MST[rv.UOI2Mutator]MSP[]
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ; MST[rv.CRCR3Mutator]MSP[]
} if ( isPreviousChar ( local , n , 'G' ) ) { hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) && MST[rv.UOI2Mutator]MSP[]
if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.AOR4Mutator]MSP[] isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { MST[rv.ROR4Mutator]MSP[] break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
regionMatch ( local , n , lr_6 ) || regionMatch ( local , n , lr_7 ) ) { MST[rv.ROR4Mutator]MSP[] code . append ( 'X' ) ; } else { code . append ( 'S' ) ; } break; case 'T' :
local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break; case 'W' : if ( inwd [ 1 ] == 'R' ) { MST[InlineConstantMutator]MSP[]
boolean matches = false ; if( index > 0 && MST[rv.ABSMutator]MSP[] index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; } return matches ; }
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.CRCR5Mutator]MSP[] ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { n ++ ; } else { switch( symb ) { MST[rv.UOI4Mutator]MSP[] case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
if ( ! isPreviousChar ( local , n , 'C' ) ) { MST[rv.ROR5Mutator]MSP[] code . append ( symb ) ; } } else { code . append ( symb ) ; } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) {
public String metaphone ( final String txt ) { MST[rv.CRCR1Mutator]MSP[] boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) {
local . append ( inwd , 1 , inwd . length - 1 ) ; break; } if ( inwd [ 1 ] == 'H' ) { local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.AOR1Mutator]MSP[]
code . append ( symb ) ; } break; case 'B' : if ( isPreviousChar ( local , n , 'M' ) && isLastChar ( wdsz , n ) ) { MST[NonVoidMethodCallMutator]MSP[] break; } code . append ( symb ) ; break; case 'C' :
if ( regionMatch ( local , n , lr_8 ) || regionMatch ( local , n , lr_9 ) ) { MST[NonVoidMethodCallMutator]MSP[] code . append ( 'X' ) ; break; } if ( regionMatch ( local , n , lr_10 ) ) { break; }
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && MST[rv.CRCR4Mutator]MSP[] VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) {
code . append ( 'S' ) ; break; default: break; } n ++ ; } if ( code . length () > this . getMaxCodeLen () ) { MST[NonVoidMethodCallMutator]MSP[] code . setLength ( this . getMaxCodeLen () ) ; } } return code . toString () ; }
local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break; case 'W' : if ( inwd [ 1 ] == 'R' ) { MST[rv.CRCR5Mutator]MSP[]
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { MST[rv.ROR1Mutator]MSP[] if ( n == 0 &&
FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 && MST[rv.ROR2Mutator]MSP[] ! hard ) { code . append ( 'J' ) ; } else { code . append ( 'K' ) ; } break; case 'H' :
code . append ( 'S' ) ; break; default: break; } n ++ ; } if ( code . length () > this . getMaxCodeLen () ) { MST[rv.ROR4Mutator]MSP[] code . setLength ( this . getMaxCodeLen () ) ; } } return code . toString () ; }
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && MST[rv.AOR3Mutator]MSP[] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { MST[rv.ROR2Mutator]MSP[] matches = string . charAt ( index + 1 ) == c ;
public String metaphone ( final String txt ) { MST[rv.UOI1Mutator]MSP[] boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) {
public String metaphone ( final String txt ) { MST[rv.CRCR4Mutator]MSP[] boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) {
if ( ! isLastChar ( wdsz , n ) && isVowel ( local , n + 1 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break; case 'Z' :
if ( ! isLastChar ( wdsz , n ) && isVowel ( local , n + 1 ) ) { code . append ( symb ) ; MST[rv.UOI1Mutator]MSP[] } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break; case 'Z' :
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && index + test . length () - 1 < string . length () ) { MST[rv.ROR1Mutator]MSP[]
code . append ( symb ) ; } break; case 'B' : if ( isPreviousChar ( local , n , 'M' ) && isLastChar ( wdsz , n ) ) { MST[rv.ROR3Mutator]MSP[] break; } code . append ( symb ) ; break; case 'C' :
FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 && ! hard ) { code . append ( 'J' ) ; MST[experimental.NakedReceiverMutator]MSP[] } else { code . append ( 'K' ) ; } break; case 'H' :
local . setCharAt ( 0 , 'W' ) ; MST[rv.CRCR3Mutator]MSP[] } else { local . append ( inwd ) ; } break; case 'X' : inwd [ 0 ] = 'S' ; local . append ( inwd ) ; break; default: local . append ( inwd ) ; }
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && MST[rv.ROR3Mutator]MSP[] FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; MST[InlineConstantMutator]MSP[] break; }
if ( regionMatch ( local , n , lr_8 ) || MST[RemoveConditionalMutator_EQUAL_IF]MSP[] regionMatch ( local , n , lr_9 ) ) { code . append ( 'X' ) ; break; } if ( regionMatch ( local , n , lr_10 ) ) { break; }
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && MST[rv.CRCR4Mutator]MSP[] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; break; }
if ( ! isLastChar ( wdsz , n + 1 ) && MST[RemoveConditionalMutator_EQUAL_IF]MSP[] isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { MST[NegateConditionalsMutator]MSP[] break; } if ( isVowel ( local , n + 1 ) ) {
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && MST[rv.ABSMutator]MSP[] VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) {
return n + 1 == wdsz ; MST[rv.CRCR5Mutator]MSP[] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
} if ( isPreviousChar ( local , n , 'G' ) ) { hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) && MST[rv.AOR4Mutator]MSP[]
return n + 1 == wdsz ; } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; MST[NullReturnValsMutator]MSP[] } @Override
if ( regionMatch ( local , n , lr_8 ) || regionMatch ( local , n , lr_9 ) ) { code . append ( 'X' ) ; break; } if ( regionMatch ( local , n , lr_10 ) ) { MST[rv.ABSMutator]MSP[] break; }
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { MST[NegateConditionalsMutator]MSP[] code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 &&
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && MST[rv.CRCR3Mutator]MSP[] isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { MST[rv.UOI3Mutator]MSP[] n ++ ; } else { switch( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
final int wdsz = local . length () ; int n = 0 ; while ( code . length () < this . getMaxCodeLen () && MST[rv.ROR1Mutator]MSP[] n < wdsz ) { final char symb = local . charAt ( n ) ;
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && MST[rv.UOI2Mutator]MSP[] isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
public String metaphone ( final String txt ) { boolean hard = false ; MST[rv.CRCR3Mutator]MSP[] int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) {
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { MST[rv.ROR2Mutator]MSP[] code . append ( 'S' ) ; break; }
if ( regionMatch ( local , n , lr_8 ) || regionMatch ( local , n , lr_9 ) ) { MST[rv.ROR3Mutator]MSP[] code . append ( 'X' ) ; break; } if ( regionMatch ( local , n , lr_10 ) ) { break; }
return txt . toUpperCase ( java . util . Locale . ENGLISH ) ; } final char [] inwd = txt . toUpperCase ( java . util . Locale . ENGLISH ) . toCharArray () ; final StringBuilder local = new StringBuilder ( 40 ) ; MST[rv.CRCR1Mutator]MSP[]
local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break; case 'A' : if ( inwd [ 1 ] == 'E' ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
code . append ( 'X' ) ; MST[rv.CRCR4Mutator]MSP[] break; } if ( ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; break; }
code . append ( 'F' ) ; } else { code . append ( symb ) ; } break; case 'Q' : code . append ( 'K' ) ; break; case 'S' : if ( regionMatch ( local , n , lr_5 ) || MST[rv.UOI2Mutator]MSP[]
regionMatch ( local , n , lr_6 ) || regionMatch ( local , n , lr_7 ) ) { code . append ( 'X' ) ; } else { code . append ( 'S' ) ; MST[rv.CRCR1Mutator]MSP[] } break; case 'T' :
FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 && ! hard ) { code . append ( 'J' ) ; MST[rv.CRCR6Mutator]MSP[] } else { code . append ( 'K' ) ; } break; case 'H' :
code . append ( 'H' ) ; } break; case 'F' : case 'J' : case 'L' : case 'M' : case 'N' : case 'R' : code . append ( symb ) ; MST[experimental.NakedReceiverMutator]MSP[] break; case 'K' : if ( n > 0 ) {
FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 && ! hard ) { code . append ( 'J' ) ; MST[InlineConstantMutator]MSP[] } else { code . append ( 'K' ) ; } break; case 'H' :
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ; MST[rv.CRCR5Mutator]MSP[]
private boolean isVowel ( final StringBuilder string , final int index ) { return VOWELS . indexOf ( string . charAt ( index ) ) >= 0 ; MST[InlineConstantMutator]MSP[] } private boolean isPreviousChar ( final StringBuilder string , final int index , final char c ) {
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; MST[rv.CRCR6Mutator]MSP[] break; }
local . append ( inwd , 1 , inwd . length - 1 ) ; break; } if ( inwd [ 1 ] == 'H' ) { MST[rv.CRCR3Mutator]MSP[] local . append ( inwd , 1 , inwd . length - 1 ) ;
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) { MST[rv.AOR3Mutator]MSP[]
code . append ( 'F' ) ; } else { code . append ( symb ) ; } break; case 'Q' : code . append ( 'K' ) ; break; case 'S' : if ( regionMatch ( local , n , lr_5 ) || MST[rv.ABSMutator]MSP[]
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && MST[ConditionalsBoundaryMutator]MSP[] index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ;
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.UOI3Mutator]MSP[] ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
wdsz >= 3 && isVowel ( local , 2 ) ) { code . append ( 'K' ) ; } else { code . append ( 'X' ) ; } } else { code . append ( 'K' ) ; MST[rv.CRCR5Mutator]MSP[] } break; case 'D' :
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && MST[rv.CRCR1Mutator]MSP[] isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
code . append ( 'F' ) ; } else { code . append ( symb ) ; } break; case 'Q' : code . append ( 'K' ) ; MST[NonVoidMethodCallMutator]MSP[] break; case 'S' : if ( regionMatch ( local , n , lr_5 ) ||
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && MST[rv.ABSMutator]MSP[] isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
final StringBuilder code = new StringBuilder ( 10 ) ; switch( inwd [ 0 ] ) { case 'K' : case 'G' : case 'P' : if ( inwd [ 1 ] == 'N' ) { MST[rv.CRCR2Mutator]MSP[]
return txt . toUpperCase ( java . util . Locale . ENGLISH ) ; MST[experimental.NakedReceiverMutator]MSP[] } final char [] inwd = txt . toUpperCase ( java . util . Locale . ENGLISH ) . toCharArray () ; final StringBuilder local = new StringBuilder ( 40 ) ;
isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && MST[rv.UOI3Mutator]MSP[] ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
final StringBuilder code = new StringBuilder ( 10 ) ; switch( inwd [ 0 ] ) { MST[rv.CRCR1Mutator]MSP[] case 'K' : case 'G' : case 'P' : if ( inwd [ 1 ] == 'N' ) {
isNextChar ( local , n , 'H' ) && MST[rv.ROR4Mutator]MSP[] ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
local . append ( inwd , 1 , inwd . length - 1 ) ; break; } if ( inwd [ 1 ] == 'H' ) { MST[InlineConstantMutator]MSP[] local . append ( inwd , 1 , inwd . length - 1 ) ;
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 && MST[rv.ABSMutator]MSP[]
if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.AOD2Mutator]MSP[] isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
if ( isPreviousChar ( local , n , 'S' ) && MST[RemoveConditionalMutator_EQUAL_IF]MSP[] ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { MST[rv.ROR2Mutator]MSP[] code . append ( 'J' ) ; n += 2 ;
return n + 1 == wdsz ; MST[rv.AOR2Mutator]MSP[] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ; MST[experimental.NakedReceiverMutator]MSP[]
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && MST[InlineConstantMutator]MSP[] isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
public String metaphone ( final String txt ) { boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { MST[NegateConditionalsMutator]MSP[] return lr_1 ; } if ( txtLength == 1 ) {
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ; MST[rv.CRCR2Mutator]MSP[]
} if ( isPreviousChar ( local , n , 'G' ) ) { hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) && MST[rv.UOI1Mutator]MSP[]
if ( ! isPreviousChar ( local , n , 'C' ) ) { code . append ( symb ) ; } } else { code . append ( symb ) ; } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) { MST[rv.ROR1Mutator]MSP[]
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { MST[rv.AOR1Mutator]MSP[] matches = string . charAt ( index + 1 ) == c ;
local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break; case 'A' : if ( inwd [ 1 ] == 'E' ) { MST[rv.CRCR2Mutator]MSP[]
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { MST[rv.ROR5Mutator]MSP[] code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 &&
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { MST[rv.ROR5Mutator]MSP[] break; } if ( isVowel ( local , n + 1 ) ) {
local . append ( inwd , 1 , inwd . length - 1 ) ; break; } if ( inwd [ 1 ] == 'H' ) { local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.CRCR5Mutator]MSP[]
wdsz >= 3 && isVowel ( local , 2 ) ) { code . append ( 'K' ) ; MST[rv.CRCR1Mutator]MSP[] } else { code . append ( 'X' ) ; } } else { code . append ( 'K' ) ; } break; case 'D' :
} if ( isPreviousChar ( local , n , 'G' ) ) { hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) && MST[rv.ABSMutator]MSP[]
public String metaphone ( final String txt ) { MST[NegateConditionalsMutator]MSP[] boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) {
local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break; case 'A' : if ( inwd [ 1 ] == 'E' ) { MST[rv.CRCR5Mutator]MSP[]
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { MST[ConditionalsBoundaryMutator]MSP[] break; } if ( isVowel ( local , n + 1 ) ) {
if ( isLastChar ( wdsz , n ) ) { MST[NonVoidMethodCallMutator]MSP[] break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) {
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; MST[rv.CRCR3Mutator]MSP[] break; }
code . append ( 'F' ) ; } else { code . append ( symb ) ; } break; case 'Q' : code . append ( 'K' ) ; break; case 'S' : if ( regionMatch ( local , n , lr_5 ) || MST[rv.ROR3Mutator]MSP[]
} return matches ; MST[BooleanTrueReturnValsMutator]MSP[] } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && index + test . length () - 1 < string . length () ) {
boolean matches = false ; if( index > 0 && MST[rv.UOI2Mutator]MSP[] index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; } return matches ; }
code . append ( 'F' ) ; } else { code . append ( symb ) ; MST[rv.UOI3Mutator]MSP[] } break; case 'Q' : code . append ( 'K' ) ; break; case 'S' : if ( regionMatch ( local , n , lr_5 ) ||
final int wdsz = local . length () ; int n = 0 ; while ( code . length () < this . getMaxCodeLen () && MST[rv.ROR2Mutator]MSP[] n < wdsz ) { final char symb = local . charAt ( n ) ;
if ( ! isPreviousChar ( local , n , 'C' ) ) { MST[rv.ABSMutator]MSP[] code . append ( symb ) ; } } else { code . append ( symb ) ; } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) {
isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && MST[rv.ROR4Mutator]MSP[] ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
} if ( isPreviousChar ( local , n , 'G' ) ) { MST[rv.CRCR1Mutator]MSP[] hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) &&
if ( regionMatch ( local , n , lr_11 ) ) { code . append ( '0' ) ; MST[InlineConstantMutator]MSP[] } else { code . append ( 'T' ) ; } break; case 'V' : code . append ( 'F' ) ; break; case 'W' : case 'Y' :
public String encode ( final String str ) { return metaphone ( str ) ; } public boolean isMetaphoneEqual ( final String str1 , final String str2 ) { return metaphone ( str1 ) . equals ( metaphone ( str2 ) ) ; MST[NonVoidMethodCallMutator]MSP[] }
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && MST[rv.AOD1Mutator]MSP[] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
final String substring = string . substring ( index , index + test . length () ) ; MST[rv.UOI2Mutator]MSP[] matches = substring . equals ( test ) ; } return matches ; } private boolean isLastChar ( final int wdsz , final int n ) {
if ( regionMatch ( local , n , lr_11 ) ) { code . append ( '0' ) ; MST[rv.CRCR3Mutator]MSP[] } else { code . append ( 'T' ) ; } break; case 'V' : code . append ( 'F' ) ; break; case 'W' : case 'Y' :
} if ( isPreviousChar ( local , n , 'G' ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) &&
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; MST[rv.CRCR2Mutator]MSP[] } return matches ; }
code . append ( 'F' ) ; MST[rv.CRCR2Mutator]MSP[] } else { code . append ( symb ) ; } break; case 'Q' : code . append ( 'K' ) ; break; case 'S' : if ( regionMatch ( local , n , lr_5 ) ||
public String metaphone ( final String txt ) { boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) { MST[NegateConditionalsMutator]MSP[]
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ; MST[rv.ROR5Mutator]MSP[]
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && MST[rv.CRCR4Mutator]MSP[] FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
if ( regionMatch ( local , n , lr_11 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] code . append ( '0' ) ; } else { code . append ( 'T' ) ; } break; case 'V' : code . append ( 'F' ) ; break; case 'W' : case 'Y' :
isNextChar ( local , n , 'H' ) && MST[rv.UOI3Mutator]MSP[] ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
if ( ! isPreviousChar ( local , n , 'C' ) ) { code . append ( symb ) ; MST[rv.UOI3Mutator]MSP[] } } else { code . append ( symb ) ; } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) {
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; MST[rv.CRCR5Mutator]MSP[] } return matches ; }
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { n ++ ; } else { switch( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) { MST[rv.ROR1Mutator]MSP[]
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { MST[NegateConditionalsMutator]MSP[] code . append ( 'J' ) ; n += 2 ;
public String metaphone ( final String txt ) { MST[rv.CRCR6Mutator]MSP[] boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) {
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && index + test . length () - 1 < string . length () ) { MST[MathMutator]MSP[]
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) { MST[rv.AOD1Mutator]MSP[]
} if ( isPreviousChar ( local , n , 'G' ) ) { hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) && MST[rv.AOD2Mutator]MSP[]
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.AOR2Mutator]MSP[] } else { local . append ( inwd ) ; } break; case 'A' : if ( inwd [ 1 ] == 'E' ) {
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { MST[rv.ROR2Mutator]MSP[] n ++ ; } else { switch( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
wdsz >= 3 && isVowel ( local , 2 ) ) { code . append ( 'K' ) ; } else { code . append ( 'X' ) ; MST[NonVoidMethodCallMutator]MSP[] } } else { code . append ( 'K' ) ; } break; case 'D' :
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && MST[rv.CRCR6Mutator]MSP[] isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
if ( regionMatch ( local , n , lr_8 ) || MST[rv.UOI3Mutator]MSP[] regionMatch ( local , n , lr_9 ) ) { code . append ( 'X' ) ; break; } if ( regionMatch ( local , n , lr_10 ) ) { break; }
local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break; case 'W' : if ( inwd [ 1 ] == 'R' ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
if ( ! isPreviousChar ( local , n , 'C' ) ) { code . append ( symb ) ; } } else { code . append ( symb ) ; MST[experimental.NakedReceiverMutator]MSP[] } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) {
code . append ( 'H' ) ; } break; case 'F' : case 'J' : case 'L' : case 'M' : case 'N' : case 'R' : code . append ( symb ) ; break; case 'K' : if ( n > 0 ) { MST[rv.ROR1Mutator]MSP[]
if ( regionMatch ( local , n , lr_11 ) ) { code . append ( '0' ) ; MST[rv.CRCR6Mutator]MSP[] } else { code . append ( 'T' ) ; } break; case 'V' : code . append ( 'F' ) ; break; case 'W' : case 'Y' :
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[experimental.NakedReceiverMutator]MSP[] } else { local . append ( inwd ) ; } break; case 'A' : if ( inwd [ 1 ] == 'E' ) {
boolean matches = false ; if( index > 0 && index < string . length () ) { MST[NegateConditionalsMutator]MSP[] matches = string . charAt ( index - 1 ) == c ; } return matches ; }
public String encode ( final String str ) { return metaphone ( str ) ; MST[EmptyObjectReturnValsMutator]MSP[] } public boolean isMetaphoneEqual ( final String str1 , final String str2 ) { return metaphone ( str1 ) . equals ( metaphone ( str2 ) ) ; }
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ;
if ( ! isLastChar ( wdsz , n ) && MST[rv.ROR3Mutator]MSP[] isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break; case 'Z' :
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] n ++ ; } else { switch( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 && MST[rv.ROR5Mutator]MSP[] ! hard ) { code . append ( 'J' ) ; } else { code . append ( 'K' ) ; } break; case 'H' :
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.CRCR3Mutator]MSP[]
if ( regionMatch ( local , n , lr_8 ) || regionMatch ( local , n , lr_9 ) ) { code . append ( 'X' ) ; MST[InlineConstantMutator]MSP[] break; } if ( regionMatch ( local , n , lr_10 ) ) { break; }
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.AOR2Mutator]MSP[] } else { local . append ( inwd ) ; } break; case 'W' : if ( inwd [ 1 ] == 'R' ) {
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { MST[rv.ROR4Mutator]MSP[] if ( n == 0 &&
code . append ( 'H' ) ; } break; case 'F' : case 'J' : case 'L' : case 'M' : case 'N' : case 'R' : code . append ( symb ) ; break; case 'K' : if ( n > 0 ) { MST[rv.UOI3Mutator]MSP[]
if ( regionMatch ( local , n , lr_8 ) || MST[rv.ABSMutator]MSP[] regionMatch ( local , n , lr_9 ) ) { code . append ( 'X' ) ; break; } if ( regionMatch ( local , n , lr_10 ) ) { break; }
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; MST[rv.CRCR5Mutator]MSP[] } return matches ; }
public String metaphone ( final String txt ) { MST[rv.ABSMutator]MSP[] boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) {
public String metaphone ( final String txt ) { MST[rv.UOI4Mutator]MSP[] boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) {
final StringBuilder code = new StringBuilder ( 10 ) ; MST[rv.CRCR2Mutator]MSP[] switch( inwd [ 0 ] ) { case 'K' : case 'G' : case 'P' : if ( inwd [ 1 ] == 'N' ) {
if ( ! isLastChar ( wdsz , n ) && isVowel ( local , n + 1 ) ) { code . append ( symb ) ; MST[rv.UOI4Mutator]MSP[] } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break; case 'Z' :
local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; MST[experimental.NakedReceiverMutator]MSP[] } break; case 'A' : if ( inwd [ 1 ] == 'E' ) {
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 && MST[rv.ROR1Mutator]MSP[]
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) { MST[NegateConditionalsMutator]MSP[]
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { MST[rv.ROR5Mutator]MSP[] matches = string . charAt ( index + 1 ) == c ;
if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.ABSMutator]MSP[] isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
final int wdsz = local . length () ; int n = 0 ; MST[rv.CRCR5Mutator]MSP[] while ( code . length () < this . getMaxCodeLen () && n < wdsz ) { final char symb = local . charAt ( n ) ;
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { MST[NonVoidMethodCallMutator]MSP[] break; } if ( regionMatch ( local , n , lr_2 ) ) {
FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 && MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] ! hard ) { code . append ( 'J' ) ; } else { code . append ( 'K' ) ; } break; case 'H' :
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { MST[rv.ROR5Mutator]MSP[] n ++ ; } else { switch( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.ABSMutator]MSP[] isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 &&
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && MST[rv.ABSMutator]MSP[] VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) {
return n + 1 == wdsz ; MST[rv.CRCR5Mutator]MSP[] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; MST[NegateConditionalsMutator]MSP[] } return matches ; }
private boolean isVowel ( final StringBuilder string , final int index ) { return VOWELS . indexOf ( string . charAt ( index ) ) >= 0 ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] } private boolean isPreviousChar ( final StringBuilder string , final int index , final char c ) {
local . setCharAt ( 0 , 'W' ) ; } else { local . append ( inwd ) ; } break; case 'X' : inwd [ 0 ] = 'S' ; MST[InlineConstantMutator]MSP[] local . append ( inwd ) ; break; default: local . append ( inwd ) ; }
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[] break; } if ( regionMatch ( local , n , lr_2 ) ) {
code . append ( 'H' ) ; } break; case 'F' : case 'J' : case 'L' : case 'M' : case 'N' : case 'R' : code . append ( symb ) ; break; case 'K' : if ( n > 0 ) { MST[rv.ROR4Mutator]MSP[]
public String metaphone ( final String txt ) { boolean hard = false ; MST[InlineConstantMutator]MSP[] int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) {
isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { MST[NegateConditionalsMutator]MSP[] break;
if ( regionMatch ( local , n , lr_8 ) || regionMatch ( local , n , lr_9 ) ) { code . append ( 'X' ) ; break; } if ( regionMatch ( local , n , lr_10 ) ) { MST[NegateConditionalsMutator]MSP[] break; }
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.CRCR2Mutator]MSP[] break; } if ( inwd [ 1 ] == 'H' ) { local . append ( inwd , 1 , inwd . length - 1 ) ;
FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 && MST[rv.UOI4Mutator]MSP[] ! hard ) { code . append ( 'J' ) ; } else { code . append ( 'K' ) ; } break; case 'H' :
if ( isLastChar ( wdsz , n ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) {
local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break; case 'A' : if ( inwd [ 1 ] == 'E' ) { MST[rv.ROR2Mutator]MSP[]
boolean matches = false ; if( index > 0 && MST[rv.ROR3Mutator]MSP[] index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; } return matches ; }
public int getMaxCodeLen () { return this . maxCodeLen ; } MST[rv.ABSMutator]MSP[] public void setMaxCodeLen ( final int maxCodeLen ) { this . maxCodeLen = maxCodeLen ; }
local . append ( inwd , 1 , inwd . length - 1 ) ; break; } if ( inwd [ 1 ] == 'H' ) { MST[NegateConditionalsMutator]MSP[] local . append ( inwd , 1 , inwd . length - 1 ) ;
code . append ( 'F' ) ; MST[rv.CRCR5Mutator]MSP[] } else { code . append ( symb ) ; } break; case 'Q' : code . append ( 'K' ) ; break; case 'S' : if ( regionMatch ( local , n , lr_5 ) ||
local . setCharAt ( 0 , 'W' ) ; MST[VoidMethodCallMutator]MSP[] } else { local . append ( inwd ) ; } break; case 'X' : inwd [ 0 ] = 'S' ; local . append ( inwd ) ; break; default: local . append ( inwd ) ; }
if ( ! isPreviousChar ( local , n , 'C' ) ) { code . append ( symb ) ; } } else { code . append ( symb ) ; } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) { MST[rv.CRCR3Mutator]MSP[]
public String encode ( final String str ) { return metaphone ( str ) ; MST[NonVoidMethodCallMutator]MSP[] } public boolean isMetaphoneEqual ( final String str1 , final String str2 ) { return metaphone ( str1 ) . equals ( metaphone ( str2 ) ) ; }
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; MST[rv.CRCR1Mutator]MSP[] if( index >= 0 && index + test . length () - 1 < string . length () ) {
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.CRCR1Mutator]MSP[]
regionMatch ( local , n , lr_6 ) || regionMatch ( local , n , lr_7 ) ) { code . append ( 'X' ) ; } else { code . append ( 'S' ) ; MST[rv.CRCR4Mutator]MSP[] } break; case 'T' :
code . append ( 'S' ) ; MST[NonVoidMethodCallMutator]MSP[] break; default: break; } n ++ ; } if ( code . length () > this . getMaxCodeLen () ) { code . setLength ( this . getMaxCodeLen () ) ; } } return code . toString () ; }
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && MST[rv.UOI2Mutator]MSP[] FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.AOR1Mutator]MSP[] isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
} if ( isPreviousChar ( local , n , 'G' ) ) { hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) && MST[rv.CRCR2Mutator]MSP[]
if ( regionMatch ( local , n , lr_11 ) ) { code . append ( '0' ) ; } else { code . append ( 'T' ) ; } break; case 'V' : code . append ( 'F' ) ; break; MST[rv.CRCR2Mutator]MSP[] case 'W' : case 'Y' :
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { MST[NonVoidMethodCallMutator]MSP[] break; } if ( isVowel ( local , n + 1 ) ) {
local . append ( inwd , 1 , inwd . length - 1 ) ; break; } if ( inwd [ 1 ] == 'H' ) { local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.CRCR6Mutator]MSP[]
local . setCharAt ( 0 , 'W' ) ; MST[InlineConstantMutator]MSP[] } else { local . append ( inwd ) ; } break; case 'X' : inwd [ 0 ] = 'S' ; local . append ( inwd ) ; break; default: local . append ( inwd ) ; }
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && MST[rv.UOI2Mutator]MSP[] index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ;
return n + 1 == wdsz ; } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && MST[NegateConditionalsMutator]MSP[] index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ;
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; MST[InlineConstantMutator]MSP[] } return matches ; }
FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 && ! hard ) { code . append ( 'J' ) ; } else { code . append ( 'K' ) ; MST[rv.CRCR3Mutator]MSP[] } break; case 'H' :
if ( isPreviousChar ( local , n , 'S' ) && MST[NonVoidMethodCallMutator]MSP[] ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
private boolean isVowel ( final StringBuilder string , final int index ) { return VOWELS . indexOf ( string . charAt ( index ) ) >= 0 ; MST[ArgumentPropagationMutator]MSP[] } private boolean isPreviousChar ( final StringBuilder string , final int index , final char c ) {
final int wdsz = local . length () ; int n = 0 ; while ( code . length () < this . getMaxCodeLen () && MST[NonVoidMethodCallMutator]MSP[] n < wdsz ) { final char symb = local . charAt ( n ) ;
return n + 1 == wdsz ; MST[rv.ROR5Mutator]MSP[] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
final int wdsz = local . length () ; int n = 0 ; while ( code . length () < this . getMaxCodeLen () && MST[rv.ROR4Mutator]MSP[] n < wdsz ) { final char symb = local . charAt ( n ) ;
final int wdsz = local . length () ; int n = 0 ; while ( code . length () < this . getMaxCodeLen () && MST[rv.ROR5Mutator]MSP[] n < wdsz ) { final char symb = local . charAt ( n ) ;
if ( regionMatch ( local , n , lr_11 ) ) { code . append ( '0' ) ; MST[experimental.NakedReceiverMutator]MSP[] } else { code . append ( 'T' ) ; } break; case 'V' : code . append ( 'F' ) ; break; case 'W' : case 'Y' :
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; } return matches ; MST[ReturnValsMutator]MSP[] }
isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || MST[rv.ROR1Mutator]MSP[] regionMatch ( local , n , lr_4 ) ) ) { break;
public String encode ( final String str ) { return metaphone ( str ) ; } public boolean isMetaphoneEqual ( final String str1 , final String str2 ) { return metaphone ( str1 ) . equals ( metaphone ( str2 ) ) ; MST[ArgumentPropagationMutator]MSP[] }
FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 && MST[ArgumentPropagationMutator]MSP[] ! hard ) { code . append ( 'J' ) ; } else { code . append ( 'K' ) ; } break; case 'H' :
return n + 1 == wdsz ; MST[MathMutator]MSP[] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
final int wdsz = local . length () ; int n = 0 ; while ( code . length () < this . getMaxCodeLen () && MST[rv.UOI4Mutator]MSP[] n < wdsz ) { final char symb = local . charAt ( n ) ;
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && MST[rv.UOI2Mutator]MSP[] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; break; }
public String metaphone ( final String txt ) { boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) { MST[rv.ROR5Mutator]MSP[]
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { MST[rv.ROR5Mutator]MSP[] code . append ( 'J' ) ; n += 2 ;
public String metaphone ( final String txt ) { boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { MST[ConditionalsBoundaryMutator]MSP[] code . append ( 'J' ) ; n += 2 ;
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ; MST[NegateConditionalsMutator]MSP[]
public String metaphone ( final String txt ) { MST[rv.UOI2Mutator]MSP[] boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) {
if ( ! isLastChar ( wdsz , n + 1 ) && MST[NonVoidMethodCallMutator]MSP[] isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
if ( regionMatch ( local , n , lr_11 ) ) { MST[rv.ROR2Mutator]MSP[] code . append ( '0' ) ; } else { code . append ( 'T' ) ; } break; case 'V' : code . append ( 'F' ) ; break; case 'W' : case 'Y' :
local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break; case 'W' : if ( inwd [ 1 ] == 'R' ) { MST[rv.ROR2Mutator]MSP[]
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) { MST[rv.ROR3Mutator]MSP[]
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { MST[rv.ABSMutator]MSP[] n ++ ; } else { switch( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
private boolean isVowel ( final StringBuilder string , final int index ) { return VOWELS . indexOf ( string . charAt ( index ) ) >= 0 ; MST[rv.UOI2Mutator]MSP[] } private boolean isPreviousChar ( final StringBuilder string , final int index , final char c ) {
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.AOR2Mutator]MSP[] break; } if ( inwd [ 1 ] == 'H' ) { local . append ( inwd , 1 , inwd . length - 1 ) ;
public int getMaxCodeLen () { return this . maxCodeLen ; } MST[rv.UOI3Mutator]MSP[] public void setMaxCodeLen ( final int maxCodeLen ) { this . maxCodeLen = maxCodeLen ; }
wdsz >= 3 && isVowel ( local , 2 ) ) { code . append ( 'K' ) ; MST[rv.CRCR4Mutator]MSP[] } else { code . append ( 'X' ) ; } } else { code . append ( 'K' ) ; } break; case 'D' :
if ( regionMatch ( local , n , lr_8 ) || regionMatch ( local , n , lr_9 ) ) { code . append ( 'X' ) ; MST[rv.CRCR3Mutator]MSP[] break; } if ( regionMatch ( local , n , lr_10 ) ) { break; }
public String metaphone ( final String txt ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) {
} if ( isPreviousChar ( local , n , 'G' ) ) { MST[rv.ROR2Mutator]MSP[] hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) &&
local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; MST[experimental.NakedReceiverMutator]MSP[] } break; case 'W' : if ( inwd [ 1 ] == 'R' ) {
public String metaphone ( final String txt ) { boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return lr_1 ; } if ( txtLength == 1 ) {
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[InlineConstantMutator]MSP[] break; } if ( inwd [ 1 ] == 'H' ) { local . append ( inwd , 1 , inwd . length - 1 ) ;
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { MST[InlineConstantMutator]MSP[] if ( n == 0 &&
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && MST[rv.CRCR4Mutator]MSP[] isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && MST[rv.ROR3Mutator]MSP[] index + test . length () - 1 < string . length () ) {
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.CRCR3Mutator]MSP[] break; } if ( inwd [ 1 ] == 'H' ) { local . append ( inwd , 1 , inwd . length - 1 ) ;
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && MST[rv.UOI1Mutator]MSP[] isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
isNextChar ( local , n , 'H' ) && MST[MathMutator]MSP[] ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] break; } if ( isVowel ( local , n + 1 ) ) {
boolean matches = false ; if( index > 0 && index < string . length () ) { MST[rv.ROR5Mutator]MSP[] matches = string . charAt ( index - 1 ) == c ; } return matches ; }
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { MST[rv.CRCR4Mutator]MSP[] matches = string . charAt ( index + 1 ) == c ;
code . append ( 'S' ) ; break; default: break; } n ++ ; MST[IncrementsMutator]MSP[] } if ( code . length () > this . getMaxCodeLen () ) { code . setLength ( this . getMaxCodeLen () ) ; } } return code . toString () ; }
public String metaphone ( final String txt ) { MST[rv.ROR5Mutator]MSP[] boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) {
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; MST[experimental.NakedReceiverMutator]MSP[] break; }
return n + 1 == wdsz ; } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { MST[rv.ROR4Mutator]MSP[] throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
local . setCharAt ( 0 , 'W' ) ; } else { local . append ( inwd ) ; } break; case 'X' : inwd [ 0 ] = 'S' ; MST[rv.CRCR3Mutator]MSP[] local . append ( inwd ) ; break; default: local . append ( inwd ) ; }
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 && MST[rv.ROR2Mutator]MSP[]
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && MST[rv.ROR3Mutator]MSP[] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; break; }
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { MST[rv.CRCR3Mutator]MSP[] if ( n == 0 &&
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.AOR2Mutator]MSP[]
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ; MST[InlineConstantMutator]MSP[]
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ; MST[rv.CRCR6Mutator]MSP[]
boolean matches = false ; MST[rv.CRCR1Mutator]MSP[] if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; } return matches ; }
code . append ( 'F' ) ; } else { code . append ( symb ) ; } break; case 'Q' : code . append ( 'K' ) ; MST[rv.CRCR1Mutator]MSP[] break; case 'S' : if ( regionMatch ( local , n , lr_5 ) ||
public String metaphone ( final String txt ) { boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { MST[rv.ROR5Mutator]MSP[] return lr_1 ; } if ( txtLength == 1 ) {
return n + 1 == wdsz ; MST[rv.CRCR5Mutator]MSP[] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
} if ( isPreviousChar ( local , n , 'G' ) ) { hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) && MST[rv.AOR1Mutator]MSP[]
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.UOI2Mutator]MSP[]
private boolean isVowel ( final StringBuilder string , final int index ) { return VOWELS . indexOf ( string . charAt ( index ) ) >= 0 ; MST[ConditionalsBoundaryMutator]MSP[] } private boolean isPreviousChar ( final StringBuilder string , final int index , final char c ) {
final StringBuilder code = new StringBuilder ( 10 ) ; switch( inwd [ 0 ] ) { case 'K' : case 'G' : case 'P' : if ( inwd [ 1 ] == 'N' ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { n ++ ; } else { switch( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) { MST[rv.UOI3Mutator]MSP[]
if ( ! isLastChar ( wdsz , n ) && isVowel ( local , n + 1 ) ) { MST[NonVoidMethodCallMutator]MSP[] code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break; case 'Z' :
boolean matches = false ; if( index > 0 && index < string . length () ) { MST[ConditionalsBoundaryMutator]MSP[] matches = string . charAt ( index - 1 ) == c ; } return matches ; }
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; MST[rv.CRCR6Mutator]MSP[] if( index >= 0 && index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ;
if ( regionMatch ( local , n , lr_8 ) || MST[NonVoidMethodCallMutator]MSP[] regionMatch ( local , n , lr_9 ) ) { code . append ( 'X' ) ; break; } if ( regionMatch ( local , n , lr_10 ) ) { break; }
local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break; case 'W' : if ( inwd [ 1 ] == 'R' ) { MST[rv.CRCR3Mutator]MSP[]
} if ( isPreviousChar ( local , n , 'G' ) ) { hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) && MST[rv.ROR1Mutator]MSP[]
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) && MST[NonVoidMethodCallMutator]MSP[]
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; MST[rv.CRCR5Mutator]MSP[] } return matches ; }
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 && MST[NegateConditionalsMutator]MSP[]
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 && MST[rv.ROR4Mutator]MSP[]
local . setCharAt ( 0 , 'W' ) ; MST[rv.CRCR1Mutator]MSP[] } else { local . append ( inwd ) ; } break; case 'X' : inwd [ 0 ] = 'S' ; local . append ( inwd ) ; break; default: local . append ( inwd ) ; }
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { MST[rv.ROR4Mutator]MSP[] matches = string . charAt ( index + 1 ) == c ;
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && MST[rv.AOR1Mutator]MSP[] VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) {
final String substring = string . substring ( index , index + test . length () ) ; matches = substring . equals ( test ) ; } return matches ; MST[rv.UOI3Mutator]MSP[] } private boolean isLastChar ( final int wdsz , final int n ) {
FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 && ! hard ) { code . append ( 'J' ) ; } else { code . append ( 'K' ) ; MST[experimental.NakedReceiverMutator]MSP[] } break; case 'H' :
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && MST[rv.CRCR2Mutator]MSP[] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; break; }
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.ABSMutator]MSP[] ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
local . setCharAt ( 0 , 'W' ) ; MST[rv.CRCR5Mutator]MSP[] } else { local . append ( inwd ) ; } break; case 'X' : inwd [ 0 ] = 'S' ; local . append ( inwd ) ; break; default: local . append ( inwd ) ; }
if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.UOI1Mutator]MSP[] isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
if ( regionMatch ( local , n , lr_11 ) ) { MST[NegateConditionalsMutator]MSP[] code . append ( '0' ) ; } else { code . append ( 'T' ) ; } break; case 'V' : code . append ( 'F' ) ; break; case 'W' : case 'Y' :
local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break; case 'W' : if ( inwd [ 1 ] == 'R' ) { MST[NegateConditionalsMutator]MSP[]
if ( ! isLastChar ( wdsz , n ) && MST[rv.CRCR5Mutator]MSP[] isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break; case 'Z' :
if ( isLastChar ( wdsz , n ) ) { MST[rv.ROR2Mutator]MSP[] break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) {
} if ( isPreviousChar ( local , n , 'G' ) ) { MST[NegateConditionalsMutator]MSP[] hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) &&
public String metaphone ( final String txt ) { MST[rv.CRCR2Mutator]MSP[] boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) {
public String metaphone ( final String txt ) { boolean hard = false ; MST[rv.CRCR1Mutator]MSP[] int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) {
regionMatch ( local , n , lr_6 ) || regionMatch ( local , n , lr_7 ) ) { code . append ( 'X' ) ; MST[rv.CRCR5Mutator]MSP[] } else { code . append ( 'S' ) ; } break; case 'T' :
isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { MST[NonVoidMethodCallMutator]MSP[] break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
if ( ! isLastChar ( wdsz , n ) && MST[rv.UOI3Mutator]MSP[] isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break; case 'Z' :
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 && MST[rv.ROR5Mutator]MSP[]
code . append ( 'F' ) ; } else { code . append ( symb ) ; } break; case 'Q' : code . append ( 'K' ) ; break; case 'S' : if ( regionMatch ( local , n , lr_5 ) || MST[rv.UOI3Mutator]MSP[]
if ( regionMatch ( local , n , lr_11 ) ) { code . append ( '0' ) ; MST[rv.CRCR1Mutator]MSP[] } else { code . append ( 'T' ) ; } break; case 'V' : code . append ( 'F' ) ; break; case 'W' : case 'Y' :
local . setCharAt ( 0 , 'W' ) ; } else { local . append ( inwd ) ; } break; case 'X' : inwd [ 0 ] = 'S' ; MST[rv.CRCR1Mutator]MSP[] local . append ( inwd ) ; break; default: local . append ( inwd ) ; }
return n + 1 == wdsz ; MST[rv.UOI3Mutator]MSP[] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[NonVoidMethodCallMutator]MSP[] break; } if ( inwd [ 1 ] == 'H' ) { local . append ( inwd , 1 , inwd . length - 1 ) ;
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 && MST[rv.UOI3Mutator]MSP[]
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ; MST[rv.CRCR2Mutator]MSP[]
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] code . append ( 'S' ) ; break; }
public String encode ( final String str ) { return metaphone ( str ) ; MST[ReturnValsMutator]MSP[] } public boolean isMetaphoneEqual ( final String str1 , final String str2 ) { return metaphone ( str1 ) . equals ( metaphone ( str2 ) ) ; }
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { MST[rv.UOI1Mutator]MSP[] if ( n == 0 &&
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ; MST[rv.CRCR4Mutator]MSP[]
regionMatch ( local , n , lr_6 ) || MST[rv.UOI2Mutator]MSP[] regionMatch ( local , n , lr_7 ) ) { code . append ( 'X' ) ; } else { code . append ( 'S' ) ; } break; case 'T' :
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && MST[rv.UOI1Mutator]MSP[] index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ;
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { MST[rv.AOD2Mutator]MSP[] matches = string . charAt ( index + 1 ) == c ;
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 && MST[rv.CRCR5Mutator]MSP[]
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.AOR4Mutator]MSP[] } else { local . append ( inwd ) ; } break; case 'A' : if ( inwd [ 1 ] == 'E' ) {
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.ROR2Mutator]MSP[] ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && MST[rv.AOD1Mutator]MSP[] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; break; }
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { MST[rv.ABSMutator]MSP[] n ++ ; } else { switch( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && MST[rv.ABSMutator]MSP[] isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
regionMatch ( local , n , lr_6 ) || MST[rv.ABSMutator]MSP[] regionMatch ( local , n , lr_7 ) ) { code . append ( 'X' ) ; } else { code . append ( 'S' ) ; } break; case 'T' :
} if ( isPreviousChar ( local , n , 'G' ) ) { MST[rv.ROR5Mutator]MSP[] hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) &&
} if ( isPreviousChar ( local , n , 'G' ) ) { hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) && MST[rv.UOI4Mutator]MSP[]
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.ROR1Mutator]MSP[] isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 &&
public String metaphone ( final String txt ) { MST[InlineConstantMutator]MSP[] boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) {
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.UOI2Mutator]MSP[] ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && MST[rv.UOI4Mutator]MSP[] isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 && MST[NonVoidMethodCallMutator]MSP[] ! hard ) { code . append ( 'J' ) ; } else { code . append ( 'K' ) ; } break; case 'H' :
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] code . append ( 'J' ) ; n += 2 ;
private boolean isVowel ( final StringBuilder string , final int index ) { return VOWELS . indexOf ( string . charAt ( index ) ) >= 0 ; MST[rv.CRCR5Mutator]MSP[] } private boolean isPreviousChar ( final StringBuilder string , final int index , final char c ) {
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; MST[NonVoidMethodCallMutator]MSP[] break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 &&
return n + 1 == wdsz ; MST[rv.UOI2Mutator]MSP[] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
final int wdsz = local . length () ; MST[NonVoidMethodCallMutator]MSP[] int n = 0 ; while ( code . length () < this . getMaxCodeLen () && n < wdsz ) { final char symb = local . charAt ( n ) ;
return n + 1 == wdsz ; MST[rv.AOR3Mutator]MSP[] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break; case 'W' : if ( inwd [ 1 ] == 'R' ) { MST[rv.ROR5Mutator]MSP[]
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.ABSMutator]MSP[]
if ( ! isPreviousChar ( local , n , 'C' ) ) { code . append ( symb ) ; } } else { code . append ( symb ) ; } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) { MST[rv.ROR4Mutator]MSP[]
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.UOI1Mutator]MSP[]
local . append ( inwd , 1 , inwd . length - 1 ) ; break; } if ( inwd [ 1 ] == 'H' ) { local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.CRCR6Mutator]MSP[]
if ( regionMatch ( local , n , lr_11 ) ) { MST[rv.ROR5Mutator]MSP[] code . append ( '0' ) ; } else { code . append ( 'T' ) ; } break; case 'V' : code . append ( 'F' ) ; break; case 'W' : case 'Y' :
if ( regionMatch ( local , n , lr_8 ) || regionMatch ( local , n , lr_9 ) ) { code . append ( 'X' ) ; MST[rv.CRCR1Mutator]MSP[] break; } if ( regionMatch ( local , n , lr_10 ) ) { break; }
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && MST[rv.ROR3Mutator]MSP[] isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
regionMatch ( local , n , lr_6 ) || MST[rv.ROR3Mutator]MSP[] regionMatch ( local , n , lr_7 ) ) { code . append ( 'X' ) ; } else { code . append ( 'S' ) ; } break; case 'T' :
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { MST[rv.ROR3Mutator]MSP[] n ++ ; } else { switch( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[] matches = string . charAt ( index + 1 ) == c ;
regionMatch ( local , n , lr_6 ) || regionMatch ( local , n , lr_7 ) ) { code . append ( 'X' ) ; } else { code . append ( 'S' ) ; MST[InlineConstantMutator]MSP[] } break; case 'T' :
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && MST[NonVoidMethodCallMutator]MSP[] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
wdsz >= 3 && isVowel ( local , 2 ) ) { code . append ( 'K' ) ; } else { code . append ( 'X' ) ; } } else { code . append ( 'K' ) ; MST[rv.CRCR6Mutator]MSP[] } break; case 'D' :
} return matches ; MST[ReturnValsMutator]MSP[] } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && index + test . length () - 1 < string . length () ) {
isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || MST[rv.ROR4Mutator]MSP[] regionMatch ( local , n , lr_4 ) ) ) { break;
local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break; case 'A' : if ( inwd [ 1 ] == 'E' ) { MST[NegateConditionalsMutator]MSP[]
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && MST[rv.ABSMutator]MSP[] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; break; }
wdsz >= 3 && isVowel ( local , 2 ) ) { MST[rv.ROR3Mutator]MSP[] code . append ( 'K' ) ; } else { code . append ( 'X' ) ; } } else { code . append ( 'K' ) ; } break; case 'D' :
code . append ( 'H' ) ; } break; case 'F' : case 'J' : case 'L' : case 'M' : case 'N' : case 'R' : code . append ( symb ) ; break; case 'K' : if ( n > 0 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[]
isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || MST[rv.UOI3Mutator]MSP[] regionMatch ( local , n , lr_4 ) ) ) { break;
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && MST[rv.CRCR5Mutator]MSP[] VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) {
public String metaphone ( final String txt ) { boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return lr_1 ; } if ( txtLength == 1 ) {
final int wdsz = local . length () ; int n = 0 ; while ( code . length () < this . getMaxCodeLen () && MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] n < wdsz ) { final char symb = local . charAt ( n ) ;
if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.AOR3Mutator]MSP[] isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { n ++ ; } else { switch( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) { MST[rv.ROR4Mutator]MSP[]
if ( ! isPreviousChar ( local , n , 'C' ) ) { code . append ( symb ) ; } } else { code . append ( symb ) ; MST[rv.UOI3Mutator]MSP[] } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) {
if ( regionMatch ( local , n , lr_8 ) || regionMatch ( local , n , lr_9 ) ) { code . append ( 'X' ) ; MST[experimental.NakedReceiverMutator]MSP[] break; } if ( regionMatch ( local , n , lr_10 ) ) { break; }
if ( ! isLastChar ( wdsz , n ) && isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; MST[NonVoidMethodCallMutator]MSP[] break; case 'Z' :
if ( ! isPreviousChar ( local , n , 'C' ) ) { code . append ( symb ) ; } } else { code . append ( symb ) ; } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) { MST[rv.UOI1Mutator]MSP[]
final StringBuilder code = new StringBuilder ( 10 ) ; switch( inwd [ 0 ] ) { case 'K' : case 'G' : case 'P' : if ( inwd [ 1 ] == 'N' ) { MST[rv.ROR2Mutator]MSP[]
public String metaphone ( final String txt ) { MST[rv.ABSMutator]MSP[] boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) {
wdsz >= 3 && isVowel ( local , 2 ) ) { code . append ( 'K' ) ; MST[InlineConstantMutator]MSP[] } else { code . append ( 'X' ) ; } } else { code . append ( 'K' ) ; } break; case 'D' :
local . append ( inwd , 1 , inwd . length - 1 ) ; break; } if ( inwd [ 1 ] == 'H' ) { local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.CRCR4Mutator]MSP[]
local . append ( inwd , 1 , inwd . length - 1 ) ; break; } if ( inwd [ 1 ] == 'H' ) { local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.CRCR3Mutator]MSP[]
boolean matches = false ; if( index > 0 && index < string . length () ) { MST[rv.ROR4Mutator]MSP[] matches = string . charAt ( index - 1 ) == c ; } return matches ; }
final StringBuilder code = new StringBuilder ( 10 ) ; switch( inwd [ 0 ] ) { MST[InlineConstantMutator]MSP[] case 'K' : case 'G' : case 'P' : if ( inwd [ 1 ] == 'N' ) {
local . append ( inwd , 1 , inwd . length - 1 ) ; break; } if ( inwd [ 1 ] == 'H' ) { MST[rv.CRCR1Mutator]MSP[] local . append ( inwd , 1 , inwd . length - 1 ) ;
boolean matches = false ; if( index > 0 && MST[rv.ROR2Mutator]MSP[] index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; } return matches ; }
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[NonVoidMethodCallMutator]MSP[] } else { local . append ( inwd ) ; } break; case 'W' : if ( inwd [ 1 ] == 'R' ) {
if ( ! isPreviousChar ( local , n , 'C' ) ) { MST[rv.ROR1Mutator]MSP[] code . append ( symb ) ; } } else { code . append ( symb ) ; } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) {
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && MST[InlineConstantMutator]MSP[] isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
wdsz >= 3 && isVowel ( local , 2 ) ) { code . append ( 'K' ) ; } else { code . append ( 'X' ) ; } } else { code . append ( 'K' ) ; MST[rv.CRCR3Mutator]MSP[] } break; case 'D' :
code . append ( 'X' ) ; MST[rv.CRCR2Mutator]MSP[] break; } if ( ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; break; }
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 &&
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { n ++ ; } else { switch( symb ) { MST[experimental.RemoveSwitchMutator_4]MSP[] case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { n ++ ; } else { switch( symb ) { MST[experimental.RemoveSwitchMutator_5]MSP[] case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { n ++ ; } else { switch( symb ) { MST[experimental.RemoveSwitchMutator_2]MSP[] case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { n ++ ; } else { switch( symb ) { MST[experimental.RemoveSwitchMutator_3]MSP[] case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
boolean matches = false ; if( index > 0 && index < string . length () ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[] matches = string . charAt ( index - 1 ) == c ; } return matches ; }
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { n ++ ; } else { switch( symb ) { MST[experimental.RemoveSwitchMutator_0]MSP[] case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { n ++ ; } else { switch( symb ) { MST[experimental.RemoveSwitchMutator_1]MSP[] case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { MST[rv.ROR5Mutator]MSP[] code . append ( 'S' ) ; break; }
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && index + test . length () - 1 < string . length () ) { MST[rv.ROR4Mutator]MSP[]
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.AOR4Mutator]MSP[] } else { local . append ( inwd ) ; } break; case 'W' : if ( inwd [ 1 ] == 'R' ) {
final String substring = string . substring ( index , index + test . length () ) ; MST[rv.UOI2Mutator]MSP[] matches = substring . equals ( test ) ; } return matches ; } private boolean isLastChar ( final int wdsz , final int n ) {
if ( regionMatch ( local , n , lr_8 ) || MST[rv.ROR2Mutator]MSP[] regionMatch ( local , n , lr_9 ) ) { code . append ( 'X' ) ; break; } if ( regionMatch ( local , n , lr_10 ) ) { break; }
code . append ( symb ) ; } break; case 'B' : if ( isPreviousChar ( local , n , 'M' ) && isLastChar ( wdsz , n ) ) { break; } code . append ( symb ) ; MST[rv.UOI1Mutator]MSP[] break; case 'C' :
final int wdsz = local . length () ; int n = 0 ; while ( code . length () < this . getMaxCodeLen () && MST[NegateConditionalsMutator]MSP[] n < wdsz ) { final char symb = local . charAt ( n ) ;
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && MST[rv.AOR2Mutator]MSP[] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
public String metaphone ( final String txt ) { MST[rv.CRCR5Mutator]MSP[] boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) {
code . append ( 'S' ) ; MST[rv.CRCR6Mutator]MSP[] break; default: break; } n ++ ; } if ( code . length () > this . getMaxCodeLen () ) { code . setLength ( this . getMaxCodeLen () ) ; } } return code . toString () ; }
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && MST[rv.UOI3Mutator]MSP[] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; break; }
if ( ! isLastChar ( wdsz , n ) && isVowel ( local , n + 1 ) ) { code . append ( symb ) ; MST[experimental.NakedReceiverMutator]MSP[] } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break; case 'Z' :
public String metaphone ( final String txt ) { boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) { MST[rv.UOI1Mutator]MSP[]
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[NonVoidMethodCallMutator]MSP[] } else { local . append ( inwd ) ; } break; case 'A' : if ( inwd [ 1 ] == 'E' ) {
local . append ( inwd , 1 , inwd . length - 1 ) ; break; } if ( inwd [ 1 ] == 'H' ) { MST[rv.ROR1Mutator]MSP[] local . append ( inwd , 1 , inwd . length - 1 ) ;
private boolean isVowel ( final StringBuilder string , final int index ) { return VOWELS . indexOf ( string . charAt ( index ) ) >= 0 ; MST[BooleanTrueReturnValsMutator]MSP[] } private boolean isPreviousChar ( final StringBuilder string , final int index , final char c ) {
if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.ROR2Mutator]MSP[] isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
return txt . toUpperCase ( java . util . Locale . ENGLISH ) ; } final char [] inwd = txt . toUpperCase ( java . util . Locale . ENGLISH ) . toCharArray () ; final StringBuilder local = new StringBuilder ( 40 ) ; MST[InlineConstantMutator]MSP[]
} if ( isPreviousChar ( local , n , 'G' ) ) { hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) && MST[rv.ROR4Mutator]MSP[]
local . append ( inwd , 1 , inwd . length - 1 ) ; break; } if ( inwd [ 1 ] == 'H' ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] local . append ( inwd , 1 , inwd . length - 1 ) ;
local . setCharAt ( 0 , 'W' ) ; MST[rv.CRCR4Mutator]MSP[] } else { local . append ( inwd ) ; } break; case 'X' : inwd [ 0 ] = 'S' ; local . append ( inwd ) ; break; default: local . append ( inwd ) ; }
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && MST[rv.ABSMutator]MSP[] FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
if ( regionMatch ( local , n , lr_11 ) ) { MST[rv.UOI2Mutator]MSP[] code . append ( '0' ) ; } else { code . append ( 'T' ) ; } break; case 'V' : code . append ( 'F' ) ; break; case 'W' : case 'Y' :
if ( ! isPreviousChar ( local , n , 'C' ) ) { code . append ( symb ) ; } } else { code . append ( symb ) ; MST[NonVoidMethodCallMutator]MSP[] } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) {
private boolean isVowel ( final StringBuilder string , final int index ) { return VOWELS . indexOf ( string . charAt ( index ) ) >= 0 ; MST[InlineConstantMutator]MSP[] } private boolean isPreviousChar ( final StringBuilder string , final int index , final char c ) {
local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break; case 'A' : if ( inwd [ 1 ] == 'E' ) { MST[rv.CRCR5Mutator]MSP[]
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && MST[rv.CRCR5Mutator]MSP[] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; break; }
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.CRCR6Mutator]MSP[] ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
local . append ( inwd , 1 , inwd . length - 1 ) ; break; } if ( inwd [ 1 ] == 'H' ) { MST[rv.CRCR4Mutator]MSP[] local . append ( inwd , 1 , inwd . length - 1 ) ;
if ( ! isPreviousChar ( local , n , 'C' ) ) { MST[rv.ROR4Mutator]MSP[] code . append ( symb ) ; } } else { code . append ( symb ) ; } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) {
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) { MST[rv.AOR2Mutator]MSP[]
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && MST[RemoveConditionalMutator_EQUAL_IF]MSP[] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
} if ( isPreviousChar ( local , n , 'G' ) ) { MST[InlineConstantMutator]MSP[] hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) &&
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; MST[rv.CRCR3Mutator]MSP[] if( index >= 0 && index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ;
final StringBuilder code = new StringBuilder ( 10 ) ; switch( inwd [ 0 ] ) { MST[experimental.RemoveSwitchMutator_0]MSP[] case 'K' : case 'G' : case 'P' : if ( inwd [ 1 ] == 'N' ) {
final StringBuilder code = new StringBuilder ( 10 ) ; switch( inwd [ 0 ] ) { MST[experimental.RemoveSwitchMutator_1]MSP[] case 'K' : case 'G' : case 'P' : if ( inwd [ 1 ] == 'N' ) {
boolean matches = false ; if( index > 0 && MST[rv.ROR5Mutator]MSP[] index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; } return matches ; }
final StringBuilder code = new StringBuilder ( 10 ) ; switch( inwd [ 0 ] ) { case 'K' : case 'G' : case 'P' : if ( inwd [ 1 ] == 'N' ) { MST[rv.CRCR3Mutator]MSP[]
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) { MST[rv.ROR1Mutator]MSP[]
final StringBuilder code = new StringBuilder ( 10 ) ; switch( inwd [ 0 ] ) { MST[experimental.RemoveSwitchMutator_2]MSP[] case 'K' : case 'G' : case 'P' : if ( inwd [ 1 ] == 'N' ) {
final StringBuilder code = new StringBuilder ( 10 ) ; switch( inwd [ 0 ] ) { MST[experimental.RemoveSwitchMutator_3]MSP[] case 'K' : case 'G' : case 'P' : if ( inwd [ 1 ] == 'N' ) {
final StringBuilder code = new StringBuilder ( 10 ) ; switch( inwd [ 0 ] ) { MST[experimental.RemoveSwitchMutator_4]MSP[] case 'K' : case 'G' : case 'P' : if ( inwd [ 1 ] == 'N' ) {
final StringBuilder code = new StringBuilder ( 10 ) ; switch( inwd [ 0 ] ) { MST[experimental.RemoveSwitchMutator_5]MSP[] case 'K' : case 'G' : case 'P' : if ( inwd [ 1 ] == 'N' ) {
final int wdsz = local . length () ; int n = 0 ; while ( code . length () < this . getMaxCodeLen () && MST[rv.UOI1Mutator]MSP[] n < wdsz ) { final char symb = local . charAt ( n ) ;
code . append ( 'X' ) ; MST[rv.CRCR5Mutator]MSP[] break; } if ( ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; break; }
FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 && MST[NegateConditionalsMutator]MSP[] ! hard ) { code . append ( 'J' ) ; } else { code . append ( 'K' ) ; } break; case 'H' :
if ( regionMatch ( local , n , lr_11 ) ) { code . append ( '0' ) ; MST[rv.CRCR4Mutator]MSP[] } else { code . append ( 'T' ) ; } break; case 'V' : code . append ( 'F' ) ; break; case 'W' : case 'Y' :
return txt . toUpperCase ( java . util . Locale . ENGLISH ) ; } final char [] inwd = txt . toUpperCase ( java . util . Locale . ENGLISH ) . toCharArray () ; final StringBuilder local = new StringBuilder ( 40 ) ; MST[rv.CRCR2Mutator]MSP[]
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && index + test . length () - 1 < string . length () ) { MST[rv.CRCR6Mutator]MSP[]
final String substring = string . substring ( index , index + test . length () ) ; MST[rv.ABSMutator]MSP[] matches = substring . equals ( test ) ; } return matches ; } private boolean isLastChar ( final int wdsz , final int n ) {
isNextChar ( local , n , 'H' ) && MST[rv.AOD2Mutator]MSP[] ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { MST[rv.UOI4Mutator]MSP[] if ( n == 0 &&
final StringBuilder code = new StringBuilder ( 10 ) ; switch( inwd [ 0 ] ) { case 'K' : case 'G' : case 'P' : if ( inwd [ 1 ] == 'N' ) { MST[rv.ROR5Mutator]MSP[]
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { MST[NonVoidMethodCallMutator]MSP[] break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ; MST[rv.CRCR5Mutator]MSP[]
regionMatch ( local , n , lr_6 ) || regionMatch ( local , n , lr_7 ) ) { MST[rv.ROR3Mutator]MSP[] code . append ( 'X' ) ; } else { code . append ( 'S' ) ; } break; case 'T' :
regionMatch ( local , n , lr_6 ) || regionMatch ( local , n , lr_7 ) ) { MST[NonVoidMethodCallMutator]MSP[] code . append ( 'X' ) ; } else { code . append ( 'S' ) ; } break; case 'T' :
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.AOR4Mutator]MSP[]
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) { MST[rv.UOI3Mutator]MSP[]
isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { MST[rv.ROR1Mutator]MSP[] break;
if ( regionMatch ( local , n , lr_8 ) || regionMatch ( local , n , lr_9 ) ) { code . append ( 'X' ) ; break; } if ( regionMatch ( local , n , lr_10 ) ) { MST[rv.ROR1Mutator]MSP[] break; }
return n + 1 == wdsz ; } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { MST[rv.CRCR6Mutator]MSP[] n ++ ; } else { switch( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
if ( ! isLastChar ( wdsz , n ) && MST[rv.AOD1Mutator]MSP[] isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break; case 'Z' :
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.UOI1Mutator]MSP[] ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
final int wdsz = local . length () ; int n = 0 ; MST[rv.CRCR3Mutator]MSP[] while ( code . length () < this . getMaxCodeLen () && n < wdsz ) { final char symb = local . charAt ( n ) ;
return n + 1 == wdsz ; MST[rv.ROR1Mutator]MSP[] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
} if ( isPreviousChar ( local , n , 'G' ) ) { MST[rv.UOI2Mutator]MSP[] hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) &&
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && MST[rv.ROR3Mutator]MSP[] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
} if ( isPreviousChar ( local , n , 'G' ) ) { hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) && MST[rv.AOR3Mutator]MSP[]
if ( regionMatch ( local , n , lr_11 ) ) { code . append ( '0' ) ; } else { code . append ( 'T' ) ; MST[experimental.NakedReceiverMutator]MSP[] } break; case 'V' : code . append ( 'F' ) ; break; case 'W' : case 'Y' :
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && MST[rv.CRCR4Mutator]MSP[] isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
private boolean isVowel ( final StringBuilder string , final int index ) { return VOWELS . indexOf ( string . charAt ( index ) ) >= 0 ; MST[rv.ROR2Mutator]MSP[] } private boolean isPreviousChar ( final StringBuilder string , final int index , final char c ) {
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
regionMatch ( local , n , lr_6 ) || regionMatch ( local , n , lr_7 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] code . append ( 'X' ) ; } else { code . append ( 'S' ) ; } break; case 'T' :
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && MST[rv.UOI3Mutator]MSP[] index + test . length () - 1 < string . length () ) {
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { MST[NegateConditionalsMutator]MSP[] n ++ ; } else { switch( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
final int wdsz = local . length () ; int n = 0 ; while ( code . length () < this . getMaxCodeLen () && n < wdsz ) { final char symb = local . charAt ( n ) ; MST[rv.UOI3Mutator]MSP[]
} if ( isPreviousChar ( local , n , 'G' ) ) { MST[rv.CRCR2Mutator]MSP[] hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) &&
code . append ( 'H' ) ; } break; case 'F' : case 'J' : case 'L' : case 'M' : case 'N' : case 'R' : code . append ( symb ) ; MST[rv.UOI3Mutator]MSP[] break; case 'K' : if ( n > 0 ) {
public String encode ( final String str ) { return metaphone ( str ) ; } public boolean isMetaphoneEqual ( final String str1 , final String str2 ) { return metaphone ( str1 ) . equals ( metaphone ( str2 ) ) ; MST[NonVoidMethodCallMutator]MSP[] }
FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 && MST[rv.ROR3Mutator]MSP[] ! hard ) { code . append ( 'J' ) ; } else { code . append ( 'K' ) ; } break; case 'H' :
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.ROR3Mutator]MSP[]
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; } return matches ; MST[rv.UOI2Mutator]MSP[] }
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { MST[rv.ROR1Mutator]MSP[] code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 &&
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { MST[rv.ROR2Mutator]MSP[] break; } if ( regionMatch ( local , n , lr_2 ) ) {
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.AOR1Mutator]MSP[] } else { local . append ( inwd ) ; } break; case 'A' : if ( inwd [ 1 ] == 'E' ) {
local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break; case 'A' : if ( inwd [ 1 ] == 'E' ) { MST[rv.CRCR3Mutator]MSP[]
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.AOR4Mutator]MSP[] break; } if ( inwd [ 1 ] == 'H' ) { local . append ( inwd , 1 , inwd . length - 1 ) ;
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { MST[rv.ROR1Mutator]MSP[] break; } if ( isVowel ( local , n + 1 ) ) {
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) && MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
wdsz >= 3 && isVowel ( local , 2 ) ) { code . append ( 'K' ) ; MST[rv.CRCR2Mutator]MSP[] } else { code . append ( 'X' ) ; } } else { code . append ( 'K' ) ; } break; case 'D' :
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.UOI3Mutator]MSP[] isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 &&
final int wdsz = local . length () ; int n = 0 ; while ( code . length () < this . getMaxCodeLen () && n < wdsz ) { final char symb = local . charAt ( n ) ; MST[NonVoidMethodCallMutator]MSP[]
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { MST[rv.UOI1Mutator]MSP[] n ++ ; } else { switch( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && index + test . length () - 1 < string . length () ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[]
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.ROR4Mutator]MSP[] isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 &&
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { MST[rv.CRCR1Mutator]MSP[] if ( n == 0 &&
code . append ( 'H' ) ; } break; case 'F' : case 'J' : case 'L' : case 'M' : case 'N' : case 'R' : code . append ( symb ) ; MST[NonVoidMethodCallMutator]MSP[] break; case 'K' : if ( n > 0 ) {
boolean matches = false ; if( index > 0 && MST[rv.UOI4Mutator]MSP[] index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; } return matches ; }
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && MST[rv.CRCR2Mutator]MSP[] isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { MST[NegateConditionalsMutator]MSP[] code . append ( 'S' ) ; break; }
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) && MST[InlineConstantMutator]MSP[]
final StringBuilder code = new StringBuilder ( 10 ) ; switch( inwd [ 0 ] ) { case 'K' : case 'G' : case 'P' : if ( inwd [ 1 ] == 'N' ) { MST[rv.CRCR5Mutator]MSP[]
if ( ! isLastChar ( wdsz , n ) && MST[rv.ABSMutator]MSP[] isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break; case 'Z' :
isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { MST[rv.ROR3Mutator]MSP[] break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
if ( ! isPreviousChar ( local , n , 'C' ) ) { code . append ( symb ) ; } } else { code . append ( symb ) ; } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) { MST[rv.CRCR1Mutator]MSP[]
code . append ( 'S' ) ; break; default: break; } n ++ ; } if ( code . length () > this . getMaxCodeLen () ) { code . setLength ( this . getMaxCodeLen () ) ; } } return code . toString () ; MST[EmptyObjectReturnValsMutator]MSP[] }
public String metaphone ( final String txt ) { MST[rv.UOI1Mutator]MSP[] boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) {
isNextChar ( local , n , 'H' ) && MST[rv.CRCR6Mutator]MSP[] ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 && MST[RemoveConditionalMutator_ORDER_ELSE]MSP[]
regionMatch ( local , n , lr_6 ) || regionMatch ( local , n , lr_7 ) ) { code . append ( 'X' ) ; } else { code . append ( 'S' ) ; MST[rv.CRCR2Mutator]MSP[] } break; case 'T' :
code . append ( 'F' ) ; MST[rv.CRCR3Mutator]MSP[] } else { code . append ( symb ) ; } break; case 'Q' : code . append ( 'K' ) ; break; case 'S' : if ( regionMatch ( local , n , lr_5 ) ||
return n + 1 == wdsz ; } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; MST[ArgumentPropagationMutator]MSP[] } @Override
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && MST[rv.CRCR5Mutator]MSP[] FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && MST[rv.AOD1Mutator]MSP[] FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
return n + 1 == wdsz ; MST[rv.ABSMutator]MSP[] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
code . append ( symb ) ; MST[rv.UOI2Mutator]MSP[] } break; case 'B' : if ( isPreviousChar ( local , n , 'M' ) && isLastChar ( wdsz , n ) ) { break; } code . append ( symb ) ; break; case 'C' :
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; MST[InlineConstantMutator]MSP[] if( index >= 0 && index + test . length () - 1 < string . length () ) {
if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.UOI1Mutator]MSP[] isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 && ! hard ) { code . append ( 'J' ) ; MST[rv.CRCR4Mutator]MSP[] } else { code . append ( 'K' ) ; } break; case 'H' :
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && MST[rv.UOI4Mutator]MSP[] index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ;
if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.UOI4Mutator]MSP[] isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; MST[rv.CRCR4Mutator]MSP[] break; }
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; MST[rv.UOI2Mutator]MSP[] } return matches ; }
FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 && ! hard ) { code . append ( 'J' ) ; } else { code . append ( 'K' ) ; MST[rv.CRCR1Mutator]MSP[] } break; case 'H' :
if ( isLastChar ( wdsz , n ) ) { MST[rv.ABSMutator]MSP[] break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) {
final String substring = string . substring ( index , index + test . length () ) ; matches = substring . equals ( test ) ; } return matches ; MST[BooleanFalseReturnValsMutator]MSP[] } private boolean isLastChar ( final int wdsz , final int n ) {
if ( ! isLastChar ( wdsz , n ) && isVowel ( local , n + 1 ) ) { MST[rv.ROR2Mutator]MSP[] code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break; case 'Z' :
local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break; case 'A' : if ( inwd [ 1 ] == 'E' ) { MST[rv.ROR5Mutator]MSP[]
if ( regionMatch ( local , n , lr_8 ) || MST[rv.UOI1Mutator]MSP[] regionMatch ( local , n , lr_9 ) ) { code . append ( 'X' ) ; break; } if ( regionMatch ( local , n , lr_10 ) ) { break; }
isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] break;
if ( regionMatch ( local , n , lr_8 ) || regionMatch ( local , n , lr_9 ) ) { code . append ( 'X' ) ; break; } if ( regionMatch ( local , n , lr_10 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] break; }
if ( ! isLastChar ( wdsz , n ) && isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; MST[rv.CRCR5Mutator]MSP[] code . append ( 'S' ) ; break; case 'Z' :
return txt . toUpperCase ( java . util . Locale . ENGLISH ) ; MST[NonVoidMethodCallMutator]MSP[] } final char [] inwd = txt . toUpperCase ( java . util . Locale . ENGLISH ) . toCharArray () ; final StringBuilder local = new StringBuilder ( 40 ) ;
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ; MST[NonVoidMethodCallMutator]MSP[]
public String metaphone ( final String txt ) { boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) { MST[rv.UOI4Mutator]MSP[]
code . append ( symb ) ; } break; case 'B' : if ( isPreviousChar ( local , n , 'M' ) && isLastChar ( wdsz , n ) ) { break; } code . append ( symb ) ; MST[rv.UOI4Mutator]MSP[] break; case 'C' :
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) { MST[NonVoidMethodCallMutator]MSP[]
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.CRCR4Mutator]MSP[]
if ( regionMatch ( local , n , lr_8 ) || MST[rv.ROR5Mutator]MSP[] regionMatch ( local , n , lr_9 ) ) { code . append ( 'X' ) ; break; } if ( regionMatch ( local , n , lr_10 ) ) { break; }
final StringBuilder code = new StringBuilder ( 10 ) ; MST[rv.CRCR3Mutator]MSP[] switch( inwd [ 0 ] ) { case 'K' : case 'G' : case 'P' : if ( inwd [ 1 ] == 'N' ) {
local . append ( inwd , 1 , inwd . length - 1 ) ; break; } if ( inwd [ 1 ] == 'H' ) { MST[rv.ROR4Mutator]MSP[] local . append ( inwd , 1 , inwd . length - 1 ) ;
final int wdsz = local . length () ; int n = 0 ; MST[rv.CRCR6Mutator]MSP[] while ( code . length () < this . getMaxCodeLen () && n < wdsz ) { final char symb = local . charAt ( n ) ;
code . append ( 'S' ) ; break; default: break; } n ++ ; } if ( code . length () > this . getMaxCodeLen () ) { MST[ConditionalsBoundaryMutator]MSP[] code . setLength ( this . getMaxCodeLen () ) ; } } return code . toString () ; }
final String substring = string . substring ( index , index + test . length () ) ; MST[NonVoidMethodCallMutator]MSP[] matches = substring . equals ( test ) ; } return matches ; } private boolean isLastChar ( final int wdsz , final int n ) {
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) { MST[rv.ABSMutator]MSP[]
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && MST[rv.ROR4Mutator]MSP[] index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ;
if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.ROR5Mutator]MSP[] isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
if ( ! isPreviousChar ( local , n , 'C' ) ) { code . append ( symb ) ; } } else { code . append ( symb ) ; } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) { MST[rv.UOI4Mutator]MSP[]
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && MST[rv.UOI3Mutator]MSP[] index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ;
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { n ++ ; } else { switch( symb ) { MST[rv.UOI3Mutator]MSP[] case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && MST[rv.UOI1Mutator]MSP[] VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) {
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && MST[rv.ROR2Mutator]MSP[] VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) {
FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 && ! hard ) { code . append ( 'J' ) ; } else { code . append ( 'K' ) ; MST[rv.CRCR4Mutator]MSP[] } break; case 'H' :
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && MST[rv.ABSMutator]MSP[] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.UOI1Mutator]MSP[] isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 &&
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { MST[NegateConditionalsMutator]MSP[] break; } if ( regionMatch ( local , n , lr_2 ) ) {
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && MST[NonVoidMethodCallMutator]MSP[] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; break; }
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.UOI4Mutator]MSP[] ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
if ( ! isLastChar ( wdsz , n ) && isVowel ( local , n + 1 ) ) { MST[rv.ROR5Mutator]MSP[] code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break; case 'Z' :
if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.CRCR1Mutator]MSP[] isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.CRCR3Mutator]MSP[] isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 &&
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && MST[InlineConstantMutator]MSP[] VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) {
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.AOR1Mutator]MSP[] } else { local . append ( inwd ) ; } break; case 'W' : if ( inwd [ 1 ] == 'R' ) {
} if ( isPreviousChar ( local , n , 'G' ) ) { hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) && MST[MathMutator]MSP[]
final StringBuilder code = new StringBuilder ( 10 ) ; switch( inwd [ 0 ] ) { case 'K' : case 'G' : case 'P' : if ( inwd [ 1 ] == 'N' ) { MST[rv.CRCR6Mutator]MSP[]
public String encode ( final String str ) { return metaphone ( str ) ; } public boolean isMetaphoneEqual ( final String str1 , final String str2 ) { return metaphone ( str1 ) . equals ( metaphone ( str2 ) ) ; MST[BooleanTrueReturnValsMutator]MSP[] }
final String substring = string . substring ( index , index + test . length () ) ; MST[rv.UOI1Mutator]MSP[] matches = substring . equals ( test ) ; } return matches ; } private boolean isLastChar ( final int wdsz , final int n ) {
final int wdsz = local . length () ; int n = 0 ; while ( code . length () < this . getMaxCodeLen () && MST[rv.UOI4Mutator]MSP[] n < wdsz ) { final char symb = local . charAt ( n ) ;
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && MST[rv.CRCR2Mutator]MSP[] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && MST[ConditionalsBoundaryMutator]MSP[] ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.CRCR1Mutator]MSP[] isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 &&
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) { MST[rv.ROR4Mutator]MSP[]
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) { MST[rv.CRCR2Mutator]MSP[]
} if ( isPreviousChar ( local , n , 'G' ) ) { hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) && MST[rv.CRCR3Mutator]MSP[]
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ; MST[rv.ROR4Mutator]MSP[]
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 && MST[rv.UOI1Mutator]MSP[]
if ( regionMatch ( local , n , lr_11 ) ) { code . append ( '0' ) ; } else { code . append ( 'T' ) ; MST[rv.CRCR1Mutator]MSP[] } break; case 'V' : code . append ( 'F' ) ; break; case 'W' : case 'Y' :
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { MST[rv.CRCR5Mutator]MSP[] matches = string . charAt ( index + 1 ) == c ;
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { MST[rv.CRCR4Mutator]MSP[] if ( n == 0 &&
regionMatch ( local , n , lr_6 ) || regionMatch ( local , n , lr_7 ) ) { code . append ( 'X' ) ; } else { code . append ( 'S' ) ; MST[rv.CRCR5Mutator]MSP[] } break; case 'T' :
if ( regionMatch ( local , n , lr_8 ) || MST[NegateConditionalsMutator]MSP[] regionMatch ( local , n , lr_9 ) ) { code . append ( 'X' ) ; break; } if ( regionMatch ( local , n , lr_10 ) ) { break; }
} if ( isPreviousChar ( local , n , 'G' ) ) { hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) && MST[rv.UOI3Mutator]MSP[]
return txt . toUpperCase ( java . util . Locale . ENGLISH ) ; } final char [] inwd = txt . toUpperCase ( java . util . Locale . ENGLISH ) . toCharArray () ; final StringBuilder local = new StringBuilder ( 40 ) ; MST[rv.CRCR5Mutator]MSP[]
} if ( isPreviousChar ( local , n , 'G' ) ) { hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) && MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
} if ( isPreviousChar ( local , n , 'G' ) ) { hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) && MST[rv.UOI1Mutator]MSP[]
local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break; case 'A' : if ( inwd [ 1 ] == 'E' ) { MST[InlineConstantMutator]MSP[]
return n + 1 == wdsz ; MST[rv.CRCR2Mutator]MSP[] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
code . append ( 'F' ) ; } else { code . append ( symb ) ; } break; case 'Q' : code . append ( 'K' ) ; MST[rv.CRCR2Mutator]MSP[] break; case 'S' : if ( regionMatch ( local , n , lr_5 ) ||
if ( regionMatch ( local , n , lr_11 ) ) { code . append ( '0' ) ; } else { code . append ( 'T' ) ; } break; case 'V' : code . append ( 'F' ) ; break; MST[rv.CRCR3Mutator]MSP[] case 'W' : case 'Y' :
return n + 1 == wdsz ; MST[rv.CRCR6Mutator]MSP[] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
wdsz >= 3 && isVowel ( local , 2 ) ) { code . append ( 'K' ) ; MST[rv.CRCR5Mutator]MSP[] } else { code . append ( 'X' ) ; } } else { code . append ( 'K' ) ; } break; case 'D' :
code . append ( 'F' ) ; } else { code . append ( symb ) ; } break; case 'Q' : code . append ( 'K' ) ; break; case 'S' : if ( regionMatch ( local , n , lr_5 ) || MST[rv.ROR2Mutator]MSP[]
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ; MST[rv.AOR3Mutator]MSP[]
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ; MST[rv.UOI3Mutator]MSP[]
public String encode ( final String str ) { return metaphone ( str ) ; } public boolean isMetaphoneEqual ( final String str1 , final String str2 ) { return metaphone ( str1 ) . equals ( metaphone ( str2 ) ) ; MST[NonVoidMethodCallMutator]MSP[] }
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && MST[rv.CRCR5Mutator]MSP[] isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && MST[rv.UOI1Mutator]MSP[] index + test . length () - 1 < string . length () ) {
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { MST[rv.UOI4Mutator]MSP[] n ++ ; } else { switch( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.CRCR4Mutator]MSP[] break; } if ( inwd [ 1 ] == 'H' ) { local . append ( inwd , 1 , inwd . length - 1 ) ;
local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break; case 'W' : if ( inwd [ 1 ] == 'R' ) { MST[rv.CRCR1Mutator]MSP[]
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && MST[rv.ROR2Mutator]MSP[] index + test . length () - 1 < string . length () ) {
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.CRCR3Mutator]MSP[] break; } if ( inwd [ 1 ] == 'H' ) { local . append ( inwd , 1 , inwd . length - 1 ) ;
if ( ! isPreviousChar ( local , n , 'C' ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] code . append ( symb ) ; } } else { code . append ( symb ) ; } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) {
if ( ! isLastChar ( wdsz , n ) && isVowel ( local , n + 1 ) ) { MST[NegateConditionalsMutator]MSP[] code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break; case 'Z' :
private boolean isVowel ( final StringBuilder string , final int index ) { return VOWELS . indexOf ( string . charAt ( index ) ) >= 0 ; MST[NonVoidMethodCallMutator]MSP[] } private boolean isPreviousChar ( final StringBuilder string , final int index , final char c ) {
isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && MST[rv.UOI2Mutator]MSP[] ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
if ( ! isLastChar ( wdsz , n ) && MST[InlineConstantMutator]MSP[] isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break; case 'Z' :
if ( ! isLastChar ( wdsz , n ) && MST[rv.ABSMutator]MSP[] isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break; case 'Z' :
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; MST[rv.AOR3Mutator]MSP[] } return matches ; }
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] n ++ ; } else { switch( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && MST[RemoveConditionalMutator_EQUAL_IF]MSP[] isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && MST[rv.AOR4Mutator]MSP[] isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ; MST[rv.CRCR3Mutator]MSP[]
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { MST[rv.ROR1Mutator]MSP[] code . append ( 'J' ) ; n += 2 ;
code . append ( symb ) ; MST[rv.ABSMutator]MSP[] } break; case 'B' : if ( isPreviousChar ( local , n , 'M' ) && isLastChar ( wdsz , n ) ) { break; } code . append ( symb ) ; break; case 'C' :
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { MST[rv.ROR5Mutator]MSP[] break; } if ( regionMatch ( local , n , lr_2 ) ) {
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { MST[rv.AOR2Mutator]MSP[] matches = string . charAt ( index + 1 ) == c ;
wdsz >= 3 && isVowel ( local , 2 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] code . append ( 'K' ) ; } else { code . append ( 'X' ) ; } } else { code . append ( 'K' ) ; } break; case 'D' :
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.ABSMutator]MSP[]
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && MST[RemoveConditionalMutator_ORDER_IF]MSP[] index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ;
local . setCharAt ( 0 , 'W' ) ; MST[InlineConstantMutator]MSP[] } else { local . append ( inwd ) ; } break; case 'X' : inwd [ 0 ] = 'S' ; local . append ( inwd ) ; break; default: local . append ( inwd ) ; }
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.UOI4Mutator]MSP[]
if ( ! isLastChar ( wdsz , n + 1 ) && MST[NegateConditionalsMutator]MSP[] isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { MST[rv.ROR4Mutator]MSP[] break;
if ( regionMatch ( local , n , lr_8 ) || regionMatch ( local , n , lr_9 ) ) { code . append ( 'X' ) ; break; } if ( regionMatch ( local , n , lr_10 ) ) { MST[rv.ROR4Mutator]MSP[] break; }
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; MST[rv.ROR4Mutator]MSP[] } return matches ; }
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { MST[rv.ROR3Mutator]MSP[] break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
public String metaphone ( final String txt ) { boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) { MST[rv.ROR1Mutator]MSP[]
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.UOI2Mutator]MSP[] ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
if ( ! isPreviousChar ( local , n , 'C' ) ) { MST[rv.UOI1Mutator]MSP[] code . append ( symb ) ; } } else { code . append ( symb ) ; } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) {
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.ROR5Mutator]MSP[] ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
final StringBuilder code = new StringBuilder ( 10 ) ; switch( inwd [ 0 ] ) { case 'K' : case 'G' : case 'P' : if ( inwd [ 1 ] == 'N' ) { MST[InlineConstantMutator]MSP[]
code . append ( 'S' ) ; break; default: break; } n ++ ; } if ( code . length () > this . getMaxCodeLen () ) { code . setLength ( this . getMaxCodeLen () ) ; MST[VoidMethodCallMutator]MSP[] } } return code . toString () ; }
regionMatch ( local , n , lr_6 ) || regionMatch ( local , n , lr_7 ) ) { code . append ( 'X' ) ; MST[InlineConstantMutator]MSP[] } else { code . append ( 'S' ) ; } break; case 'T' :
boolean matches = false ; if( index > 0 && index < string . length () ) { MST[rv.ROR1Mutator]MSP[] matches = string . charAt ( index - 1 ) == c ; } return matches ; }
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && MST[rv.UOI2Mutator]MSP[] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; break; }
public String metaphone ( final String txt ) { MST[rv.ROR1Mutator]MSP[] boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) {
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 && MST[InlineConstantMutator]MSP[]
public String metaphone ( final String txt ) { boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { MST[rv.ROR3Mutator]MSP[] return lr_1 ; } if ( txtLength == 1 ) {
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.CRCR2Mutator]MSP[]
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && MST[rv.AOD1Mutator]MSP[] VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) {
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.AOR1Mutator]MSP[]
if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.UOI3Mutator]MSP[] isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
boolean matches = false ; MST[rv.CRCR5Mutator]MSP[] if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; } return matches ; }
if ( regionMatch ( local , n , lr_8 ) || regionMatch ( local , n , lr_9 ) ) { code . append ( 'X' ) ; MST[rv.CRCR4Mutator]MSP[] break; } if ( regionMatch ( local , n , lr_10 ) ) { break; }
final StringBuilder code = new StringBuilder ( 10 ) ; MST[ConstructorCallMutator]MSP[] switch( inwd [ 0 ] ) { case 'K' : case 'G' : case 'P' : if ( inwd [ 1 ] == 'N' ) {
if ( isLastChar ( wdsz , n ) ) { MST[rv.ROR5Mutator]MSP[] break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) {
boolean matches = false ; if( index > 0 && MST[rv.UOI3Mutator]MSP[] index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; } return matches ; }
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.CRCR6Mutator]MSP[] isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 &&
if ( isLastChar ( wdsz , n ) ) { MST[rv.UOI2Mutator]MSP[] break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) {
if ( isPreviousChar ( local , n , 'S' ) && MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 &&
final int wdsz = local . length () ; int n = 0 ; while ( code . length () < this . getMaxCodeLen () && MST[ConditionalsBoundaryMutator]MSP[] n < wdsz ) { final char symb = local . charAt ( n ) ;
code . append ( 'S' ) ; MST[rv.CRCR2Mutator]MSP[] break; default: break; } n ++ ; } if ( code . length () > this . getMaxCodeLen () ) { code . setLength ( this . getMaxCodeLen () ) ; } } return code . toString () ; }
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { n ++ ; } else { switch( symb ) { MST[experimental.RemoveSwitchMutator_8]MSP[] case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { n ++ ; } else { switch( symb ) { MST[experimental.RemoveSwitchMutator_9]MSP[] case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { n ++ ; } else { switch( symb ) { MST[experimental.RemoveSwitchMutator_6]MSP[] case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
} if ( isPreviousChar ( local , n , 'G' ) ) { hard = true ; } else { hard = false ; MST[rv.CRCR3Mutator]MSP[] } if ( ! isLastChar ( wdsz , n ) &&
if ( ! isLastChar ( wdsz , n ) && isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; MST[experimental.NakedReceiverMutator]MSP[] code . append ( 'S' ) ; break; case 'Z' :
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { n ++ ; } else { switch( symb ) { MST[experimental.RemoveSwitchMutator_7]MSP[] case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
code . append ( 'S' ) ; break; default: break; } n ++ ; } if ( code . length () > this . getMaxCodeLen () ) { MST[rv.ROR3Mutator]MSP[] code . setLength ( this . getMaxCodeLen () ) ; } } return code . toString () ; }
FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 && MST[rv.ROR1Mutator]MSP[] ! hard ) { code . append ( 'J' ) ; } else { code . append ( 'K' ) ; } break; case 'H' :
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { MST[rv.ROR1Mutator]MSP[] matches = string . charAt ( index + 1 ) == c ;
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; MST[rv.CRCR2Mutator]MSP[] } return matches ; }
code . append ( symb ) ; } break; case 'B' : if ( isPreviousChar ( local , n , 'M' ) && isLastChar ( wdsz , n ) ) { MST[rv.ROR2Mutator]MSP[] break; } code . append ( symb ) ; break; case 'C' :
if ( regionMatch ( local , n , lr_8 ) || regionMatch ( local , n , lr_9 ) ) { code . append ( 'X' ) ; break; } if ( regionMatch ( local , n , lr_10 ) ) { MST[rv.UOI1Mutator]MSP[] break; }
final StringBuilder code = new StringBuilder ( 10 ) ; switch( inwd [ 0 ] ) { case 'K' : case 'G' : case 'P' : if ( inwd [ 1 ] == 'N' ) { MST[NegateConditionalsMutator]MSP[]
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.CRCR2Mutator]MSP[] ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.AOD1Mutator]MSP[] } else { local . append ( inwd ) ; } break; case 'A' : if ( inwd [ 1 ] == 'E' ) {
code . append ( 'H' ) ; MST[rv.CRCR3Mutator]MSP[] } break; case 'F' : case 'J' : case 'L' : case 'M' : case 'N' : case 'R' : code . append ( symb ) ; break; case 'K' : if ( n > 0 ) {
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && MST[rv.ROR2Mutator]MSP[] FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[] break; } if ( isVowel ( local , n + 1 ) ) {
local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break; case 'A' : if ( inwd [ 1 ] == 'E' ) { MST[rv.CRCR1Mutator]MSP[]
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 && MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && MST[rv.UOI1Mutator]MSP[] VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) {
} else { code . append ( 'T' ) ; MST[rv.CRCR3Mutator]MSP[] } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
if ( ! isPreviousChar ( local , n , 'C' ) ) { code . append ( symb ) ; MST[NonVoidMethodCallMutator]MSP[] } } else { code . append ( symb ) ; } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) {
if ( regionMatch ( local , n , lr_11 ) ) { MST[rv.ABSMutator]MSP[] code . append ( '0' ) ; } else { code . append ( 'T' ) ; } break; case 'V' : code . append ( 'F' ) ; break; case 'W' : case 'Y' :
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { MST[rv.ROR1Mutator]MSP[] n ++ ; } else { switch( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && index + test . length () - 1 < string . length () ) { MST[rv.AOR3Mutator]MSP[]
} if ( isPreviousChar ( local , n , 'G' ) ) { MST[rv.ABSMutator]MSP[] hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) &&
if ( ! isPreviousChar ( local , n , 'C' ) ) { MST[rv.CRCR1Mutator]MSP[] code . append ( symb ) ; } } else { code . append ( symb ) ; } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) {
if ( ! isPreviousChar ( local , n , 'C' ) ) { code . append ( symb ) ; MST[rv.UOI2Mutator]MSP[] } } else { code . append ( symb ) ; } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) {
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.CRCR4Mutator]MSP[] } else { local . append ( inwd ) ; } break; case 'A' : if ( inwd [ 1 ] == 'E' ) {
if ( regionMatch ( local , n , lr_8 ) || MST[rv.UOI4Mutator]MSP[] regionMatch ( local , n , lr_9 ) ) { code . append ( 'X' ) ; break; } if ( regionMatch ( local , n , lr_10 ) ) { break; }
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && MST[InlineConstantMutator]MSP[] FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.CRCR3Mutator]MSP[] } else { local . append ( inwd ) ; } break; case 'A' : if ( inwd [ 1 ] == 'E' ) {
local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break; case 'W' : if ( inwd [ 1 ] == 'R' ) { MST[rv.CRCR6Mutator]MSP[]
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && index + test . length () - 1 < string . length () ) { MST[ConditionalsBoundaryMutator]MSP[]
if ( regionMatch ( local , n , lr_11 ) ) { code . append ( '0' ) ; } else { code . append ( 'T' ) ; MST[rv.CRCR4Mutator]MSP[] } break; case 'V' : code . append ( 'F' ) ; break; case 'W' : case 'Y' :
return n + 1 == wdsz ; } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { MST[rv.ROR3Mutator]MSP[] throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.CRCR5Mutator]MSP[]
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; MST[rv.CRCR5Mutator]MSP[] if( index >= 0 && index + test . length () - 1 < string . length () ) {
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 && MST[rv.UOI4Mutator]MSP[]
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { MST[rv.CRCR2Mutator]MSP[] n ++ ; } else { switch( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
return n + 1 == wdsz ; MST[rv.CRCR6Mutator]MSP[] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { MST[NonVoidMethodCallMutator]MSP[] break; } if ( regionMatch ( local , n , lr_2 ) ) {
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.AOR1Mutator]MSP[] break; } if ( inwd [ 1 ] == 'H' ) { local . append ( inwd , 1 , inwd . length - 1 ) ;
public int getMaxCodeLen () { return this . maxCodeLen ; } MST[rv.UOI2Mutator]MSP[] public void setMaxCodeLen ( final int maxCodeLen ) { this . maxCodeLen = maxCodeLen ; }
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && MST[NonVoidMethodCallMutator]MSP[] isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
regionMatch ( local , n , lr_6 ) || MST[NonVoidMethodCallMutator]MSP[] regionMatch ( local , n , lr_7 ) ) { code . append ( 'X' ) ; } else { code . append ( 'S' ) ; } break; case 'T' :
return n + 1 == wdsz ; MST[rv.CRCR2Mutator]MSP[] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { MST[rv.UOI2Mutator]MSP[] n ++ ; } else { switch( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && MST[rv.UOI1Mutator]MSP[] isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
code . append ( 'F' ) ; } else { code . append ( symb ) ; } break; case 'Q' : code . append ( 'K' ) ; break; case 'S' : if ( regionMatch ( local , n , lr_5 ) || MST[rv.UOI1Mutator]MSP[]
if ( ! isLastChar ( wdsz , n ) && isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; MST[InlineConstantMutator]MSP[] code . append ( 'S' ) ; break; case 'Z' :
final int wdsz = local . length () ; int n = 0 ; while ( code . length () < this . getMaxCodeLen () && MST[rv.ROR1Mutator]MSP[] n < wdsz ) { final char symb = local . charAt ( n ) ;
regionMatch ( local , n , lr_6 ) || MST[RemoveConditionalMutator_EQUAL_IF]MSP[] regionMatch ( local , n , lr_7 ) ) { code . append ( 'X' ) ; } else { code . append ( 'S' ) ; } break; case 'T' :
regionMatch ( local , n , lr_6 ) || regionMatch ( local , n , lr_7 ) ) { code . append ( 'X' ) ; MST[experimental.NakedReceiverMutator]MSP[] } else { code . append ( 'S' ) ; } break; case 'T' :
wdsz >= 3 && isVowel ( local , 2 ) ) { MST[NonVoidMethodCallMutator]MSP[] code . append ( 'K' ) ; } else { code . append ( 'X' ) ; } } else { code . append ( 'K' ) ; } break; case 'D' :
if ( regionMatch ( local , n , lr_11 ) ) { code . append ( '0' ) ; } else { code . append ( 'T' ) ; } break; case 'V' : code . append ( 'F' ) ; break; MST[NonVoidMethodCallMutator]MSP[] case 'W' : case 'Y' :
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && MST[InlineConstantMutator]MSP[] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; break; }
if ( ! isLastChar ( wdsz , n ) && MST[rv.UOI1Mutator]MSP[] isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break; case 'Z' :
final StringBuilder code = new StringBuilder ( 10 ) ; switch( inwd [ 0 ] ) { MST[rv.CRCR5Mutator]MSP[] case 'K' : case 'G' : case 'P' : if ( inwd [ 1 ] == 'N' ) {
local . setCharAt ( 0 , 'W' ) ; } else { local . append ( inwd ) ; } break; case 'X' : inwd [ 0 ] = 'S' ; MST[rv.CRCR3Mutator]MSP[] local . append ( inwd ) ; break; default: local . append ( inwd ) ; }
final int wdsz = local . length () ; int n = 0 ; while ( code . length () < this . getMaxCodeLen () && MST[rv.UOI3Mutator]MSP[] n < wdsz ) { final char symb = local . charAt ( n ) ;
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ; MST[rv.CRCR6Mutator]MSP[]
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && MST[rv.AOR1Mutator]MSP[] isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
isNextChar ( local , n , 'H' ) && MST[rv.ROR3Mutator]MSP[] ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
if ( ! isPreviousChar ( local , n , 'C' ) ) { MST[rv.UOI4Mutator]MSP[] code . append ( symb ) ; } } else { code . append ( symb ) ; } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) {
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.CRCR3Mutator]MSP[] } else { local . append ( inwd ) ; } break; case 'W' : if ( inwd [ 1 ] == 'R' ) {
final String substring = string . substring ( index , index + test . length () ) ; MST[rv.AOR1Mutator]MSP[] matches = substring . equals ( test ) ; } return matches ; } private boolean isLastChar ( final int wdsz , final int n ) {
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { MST[rv.ROR4Mutator]MSP[] code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 &&
} if ( isPreviousChar ( local , n , 'G' ) ) { MST[rv.ROR1Mutator]MSP[] hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) &&
local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break; case 'W' : if ( inwd [ 1 ] == 'R' ) { MST[rv.ROR1Mutator]MSP[]
private boolean isVowel ( final StringBuilder string , final int index ) { return VOWELS . indexOf ( string . charAt ( index ) ) >= 0 ; MST[rv.CRCR1Mutator]MSP[] } private boolean isPreviousChar ( final StringBuilder string , final int index , final char c ) {
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ; MST[experimental.RemoveIncrementsMutator]MSP[]
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { MST[rv.ROR4Mutator]MSP[] break; } if ( isVowel ( local , n + 1 ) ) {
if ( regionMatch ( local , n , lr_11 ) ) { MST[rv.ROR1Mutator]MSP[] code . append ( '0' ) ; } else { code . append ( 'T' ) ; } break; case 'V' : code . append ( 'F' ) ; break; case 'W' : case 'Y' :
} if ( isPreviousChar ( local , n , 'G' ) ) { hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) && MST[rv.UOI4Mutator]MSP[]
public String metaphone ( final String txt ) { boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) { MST[rv.CRCR4Mutator]MSP[]
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 && MST[rv.CRCR1Mutator]MSP[]
local . append ( inwd , 1 , inwd . length - 1 ) ; break; } if ( inwd [ 1 ] == 'H' ) { MST[rv.CRCR2Mutator]MSP[] local . append ( inwd , 1 , inwd . length - 1 ) ;
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
wdsz >= 3 && isVowel ( local , 2 ) ) { code . append ( 'K' ) ; } else { code . append ( 'X' ) ; MST[rv.CRCR2Mutator]MSP[] } } else { code . append ( 'K' ) ; } break; case 'D' :
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] break; } if ( regionMatch ( local , n , lr_2 ) ) {
return n + 1 == wdsz ; MST[rv.ROR4Mutator]MSP[] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
if ( regionMatch ( local , n , lr_8 ) || MST[rv.UOI2Mutator]MSP[] regionMatch ( local , n , lr_9 ) ) { code . append ( 'X' ) ; break; } if ( regionMatch ( local , n , lr_10 ) ) { break; }
} if ( isPreviousChar ( local , n , 'G' ) ) { MST[rv.CRCR5Mutator]MSP[] hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) &&
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { n ++ ; } else { switch( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
} else { code . append ( 'T' ) ; MST[NonVoidMethodCallMutator]MSP[] } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
code . append ( 'X' ) ; MST[InlineConstantMutator]MSP[] break; } if ( ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; break; }
if ( isLastChar ( wdsz , n ) ) { MST[NegateConditionalsMutator]MSP[] break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) {
if ( ! isLastChar ( wdsz , n ) && MST[rv.ROR2Mutator]MSP[] isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break; case 'Z' :
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && MST[rv.AOD2Mutator]MSP[] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
code . append ( 'H' ) ; MST[NonVoidMethodCallMutator]MSP[] } break; case 'F' : case 'J' : case 'L' : case 'M' : case 'N' : case 'R' : code . append ( symb ) ; break; case 'K' : if ( n > 0 ) {
code . append ( 'H' ) ; } break; case 'F' : case 'J' : case 'L' : case 'M' : case 'N' : case 'R' : code . append ( symb ) ; break; case 'K' : if ( n > 0 ) { MST[ConditionalsBoundaryMutator]MSP[]
code . append ( 'F' ) ; MST[rv.CRCR6Mutator]MSP[] } else { code . append ( symb ) ; } break; case 'Q' : code . append ( 'K' ) ; break; case 'S' : if ( regionMatch ( local , n , lr_5 ) ||
if ( ! isPreviousChar ( local , n , 'C' ) ) { code . append ( symb ) ; } } else { code . append ( symb ) ; } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) { MST[rv.CRCR4Mutator]MSP[]
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; MST[rv.CRCR6Mutator]MSP[] } return matches ; }
public String metaphone ( final String txt ) { MST[rv.UOI4Mutator]MSP[] boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) {
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.CRCR4Mutator]MSP[] } else { local . append ( inwd ) ; } break; case 'W' : if ( inwd [ 1 ] == 'R' ) {
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && MST[rv.UOI1Mutator]MSP[] FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
if ( ! isPreviousChar ( local , n , 'C' ) ) { code . append ( symb ) ; } } else { code . append ( symb ) ; } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.UOI4Mutator]MSP[] isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
public String metaphone ( final String txt ) { MST[rv.CRCR5Mutator]MSP[] boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) {
local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break; case 'A' : if ( inwd [ 1 ] == 'E' ) { MST[rv.CRCR6Mutator]MSP[]
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && MST[RemoveConditionalMutator_EQUAL_IF]MSP[] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; break; }
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) { MST[rv.AOD2Mutator]MSP[]
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.UOI4Mutator]MSP[] isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 &&
if ( ! isLastChar ( wdsz , n + 1 ) && MST[MathMutator]MSP[] isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && MST[rv.AOR2Mutator]MSP[] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; break; }
if ( isLastChar ( wdsz , n ) ) { MST[rv.UOI1Mutator]MSP[] break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) {
boolean matches = false ; if( index > 0 && MST[rv.UOI1Mutator]MSP[] index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; } return matches ; }
isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] regionMatch ( local , n , lr_4 ) ) ) { break;
code . append ( 'F' ) ; } else { code . append ( symb ) ; MST[rv.UOI2Mutator]MSP[] } break; case 'Q' : code . append ( 'K' ) ; break; case 'S' : if ( regionMatch ( local , n , lr_5 ) ||
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { MST[rv.ROR1Mutator]MSP[] code . append ( 'S' ) ; break; }
isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && MST[rv.ROR3Mutator]MSP[] ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.CRCR3Mutator]MSP[] isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
code . append ( 'F' ) ; } else { code . append ( symb ) ; MST[NonVoidMethodCallMutator]MSP[] } break; case 'Q' : code . append ( 'K' ) ; break; case 'S' : if ( regionMatch ( local , n , lr_5 ) ||
if ( isPreviousChar ( local , n , 'S' ) && MST[NegateConditionalsMutator]MSP[] ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
if ( regionMatch ( local , n , lr_8 ) || regionMatch ( local , n , lr_9 ) ) { MST[rv.ROR2Mutator]MSP[] code . append ( 'X' ) ; break; } if ( regionMatch ( local , n , lr_10 ) ) { break; }
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.CRCR2Mutator]MSP[]
local . append ( inwd , 1 , inwd . length - 1 ) ; break; } if ( inwd [ 1 ] == 'H' ) { local . append ( inwd , 1 , inwd . length - 1 ) ; MST[InlineConstantMutator]MSP[]
FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 && MST[rv.ROR4Mutator]MSP[] ! hard ) { code . append ( 'J' ) ; } else { code . append ( 'K' ) ; } break; case 'H' :
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && index + test . length () - 1 < string . length () ) { MST[rv.ROR3Mutator]MSP[]
final StringBuilder code = new StringBuilder ( 10 ) ; MST[rv.CRCR1Mutator]MSP[] switch( inwd [ 0 ] ) { case 'K' : case 'G' : case 'P' : if ( inwd [ 1 ] == 'N' ) {
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.AOR3Mutator]MSP[] } else { local . append ( inwd ) ; } break; case 'W' : if ( inwd [ 1 ] == 'R' ) {
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { MST[rv.ROR3Mutator]MSP[] if ( n == 0 &&
if ( ! isLastChar ( wdsz , n ) && MST[NegateConditionalsMutator]MSP[] isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break; case 'Z' :
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; MST[rv.CRCR6Mutator]MSP[] } return matches ; }
public String metaphone ( final String txt ) { MST[rv.CRCR6Mutator]MSP[] boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) {
if ( ! isLastChar ( wdsz , n ) && isVowel ( local , n + 1 ) ) { code . append ( symb ) ; MST[rv.UOI3Mutator]MSP[] } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break; case 'Z' :
public String metaphone ( final String txt ) { MST[rv.UOI3Mutator]MSP[] boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) {
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && MST[rv.AOR1Mutator]MSP[] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.AOD1Mutator]MSP[]
code . append ( symb ) ; } break; case 'B' : if ( isPreviousChar ( local , n , 'M' ) && isLastChar ( wdsz , n ) ) { MST[rv.ROR5Mutator]MSP[] break; } code . append ( symb ) ; break; case 'C' :
if ( ! isPreviousChar ( local , n , 'C' ) ) { code . append ( symb ) ; } } else { code . append ( symb ) ; } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) { MST[NonVoidMethodCallMutator]MSP[]
if ( regionMatch ( local , n , lr_8 ) || regionMatch ( local , n , lr_9 ) ) { code . append ( 'X' ) ; break; } if ( regionMatch ( local , n , lr_10 ) ) { MST[rv.UOI4Mutator]MSP[] break; }
local . append ( inwd , 1 , inwd . length - 1 ) ; break; } if ( inwd [ 1 ] == 'H' ) { MST[rv.CRCR5Mutator]MSP[] local . append ( inwd , 1 , inwd . length - 1 ) ;
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && MST[rv.ROR5Mutator]MSP[] FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
code . append ( symb ) ; } break; case 'B' : if ( isPreviousChar ( local , n , 'M' ) && isLastChar ( wdsz , n ) ) { break; } code . append ( symb ) ; MST[experimental.NakedReceiverMutator]MSP[] break; case 'C' :
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && MST[rv.CRCR6Mutator]MSP[] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; break; }
public String encode ( final String str ) { return metaphone ( str ) ; MST[ArgumentPropagationMutator]MSP[] } public boolean isMetaphoneEqual ( final String str1 , final String str2 ) { return metaphone ( str1 ) . equals ( metaphone ( str2 ) ) ; }
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) {
return n + 1 == wdsz ; MST[rv.CRCR3Mutator]MSP[] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 && ! hard ) { code . append ( 'J' ) ; } else { code . append ( 'K' ) ; MST[rv.CRCR2Mutator]MSP[] } break; case 'H' :
isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || MST[NonVoidMethodCallMutator]MSP[] regionMatch ( local , n , lr_4 ) ) ) { break;
} if ( isPreviousChar ( local , n , 'G' ) ) { hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) && MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
} if ( isPreviousChar ( local , n , 'G' ) ) { hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) && MST[rv.AOR2Mutator]MSP[]
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && MST[rv.CRCR5Mutator]MSP[] isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
final int wdsz = local . length () ; int n = 0 ; while ( code . length () < this . getMaxCodeLen () && MST[rv.ROR3Mutator]MSP[] n < wdsz ) { final char symb = local . charAt ( n ) ;
public String encode ( final String str ) { return metaphone ( str ) ; } public boolean isMetaphoneEqual ( final String str1 , final String str2 ) { return metaphone ( str1 ) . equals ( metaphone ( str2 ) ) ; MST[ArgumentPropagationMutator]MSP[] }
if ( regionMatch ( local , n , lr_11 ) ) { code . append ( '0' ) ; MST[rv.CRCR5Mutator]MSP[] } else { code . append ( 'T' ) ; } break; case 'V' : code . append ( 'F' ) ; break; case 'W' : case 'Y' :
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && MST[rv.UOI4Mutator]MSP[] isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
public String metaphone ( final String txt ) { boolean hard = false ; MST[rv.CRCR5Mutator]MSP[] int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) {
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && MST[ConditionalsBoundaryMutator]MSP[] VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) {
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { MST[rv.ROR4Mutator]MSP[] code . append ( 'S' ) ; break; }
code . append ( 'H' ) ; } break; case 'F' : case 'J' : case 'L' : case 'M' : case 'N' : case 'R' : code . append ( symb ) ; break; case 'K' : if ( n > 0 ) { MST[rv.ABSMutator]MSP[]
if ( regionMatch ( local , n , lr_8 ) || regionMatch ( local , n , lr_9 ) ) { MST[rv.ROR5Mutator]MSP[] code . append ( 'X' ) ; break; } if ( regionMatch ( local , n , lr_10 ) ) { break; }
if ( ! isPreviousChar ( local , n , 'C' ) ) { code . append ( symb ) ; } } else { code . append ( symb ) ; } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) { MST[rv.CRCR2Mutator]MSP[]
code . append ( symb ) ; } break; case 'B' : if ( isPreviousChar ( local , n , 'M' ) && isLastChar ( wdsz , n ) ) { MST[NegateConditionalsMutator]MSP[] break; } code . append ( symb ) ; break; case 'C' :
if ( ! isPreviousChar ( local , n , 'C' ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] code . append ( symb ) ; } } else { code . append ( symb ) ; } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) {
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; } return matches ; MST[BooleanFalseReturnValsMutator]MSP[] }
if ( regionMatch ( local , n , lr_8 ) || regionMatch ( local , n , lr_9 ) ) { MST[NegateConditionalsMutator]MSP[] code . append ( 'X' ) ; break; } if ( regionMatch ( local , n , lr_10 ) ) { break; }
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; MST[rv.CRCR6Mutator]MSP[] if( index >= 0 && index + test . length () - 1 < string . length () ) {
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 && MST[rv.ROR1Mutator]MSP[]
FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 && MST[rv.UOI3Mutator]MSP[] ! hard ) { code . append ( 'J' ) ; } else { code . append ( 'K' ) ; } break; case 'H' :
return n + 1 == wdsz ; MST[ReturnValsMutator]MSP[] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
local . append ( inwd , 1 , inwd . length - 1 ) ; break; } if ( inwd [ 1 ] == 'H' ) { local . append ( inwd , 1 , inwd . length - 1 ) ; MST[MathMutator]MSP[]
code . append ( 'F' ) ; MST[rv.CRCR4Mutator]MSP[] } else { code . append ( symb ) ; } break; case 'Q' : code . append ( 'K' ) ; break; case 'S' : if ( regionMatch ( local , n , lr_5 ) ||
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { n ++ ; } else { switch( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) { MST[rv.ROR3Mutator]MSP[]
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.CRCR2Mutator]MSP[] } else { local . append ( inwd ) ; } break; case 'W' : if ( inwd [ 1 ] == 'R' ) {
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.AOD1Mutator]MSP[] break; } if ( inwd [ 1 ] == 'H' ) { local . append ( inwd , 1 , inwd . length - 1 ) ;
if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.AOR2Mutator]MSP[] isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { n ++ ; } else { switch( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) { MST[rv.ABSMutator]MSP[]
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ; MST[rv.CRCR6Mutator]MSP[]
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.UOI1Mutator]MSP[]
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] if ( n == 0 &&
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && MST[NegateConditionalsMutator]MSP[] FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] index + test . length () - 1 < string . length () ) {
public String metaphone ( final String txt ) { MST[rv.CRCR4Mutator]MSP[] boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) {
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.AOR3Mutator]MSP[]
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { MST[rv.ROR4Mutator]MSP[] n ++ ; } else { switch( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
private boolean isVowel ( final StringBuilder string , final int index ) { return VOWELS . indexOf ( string . charAt ( index ) ) >= 0 ; MST[rv.UOI3Mutator]MSP[] } private boolean isPreviousChar ( final StringBuilder string , final int index , final char c ) {
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { MST[rv.ROR2Mutator]MSP[] n ++ ; } else { switch( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && MST[rv.ROR2Mutator]MSP[] isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
regionMatch ( local , n , lr_6 ) || MST[rv.ROR2Mutator]MSP[] regionMatch ( local , n , lr_7 ) ) { code . append ( 'X' ) ; } else { code . append ( 'S' ) ; } break; case 'T' :
code . append ( 'S' ) ; break; default: break; } n ++ ; } if ( code . length () > this . getMaxCodeLen () ) { code . setLength ( this . getMaxCodeLen () ) ; } } return code . toString () ; MST[ReturnValsMutator]MSP[] }
code . append ( 'X' ) ; MST[experimental.NakedReceiverMutator]MSP[] break; } if ( ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; break; }
boolean matches = false ; if( index > 0 && index < string . length () ) { MST[NonVoidMethodCallMutator]MSP[] matches = string . charAt ( index - 1 ) == c ; } return matches ; }
FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 && ! hard ) { code . append ( 'J' ) ; } else { code . append ( 'K' ) ; MST[NonVoidMethodCallMutator]MSP[] } break; case 'H' :
code . append ( 'H' ) ; } break; case 'F' : case 'J' : case 'L' : case 'M' : case 'N' : case 'R' : code . append ( symb ) ; break; case 'K' : if ( n > 0 ) { MST[rv.ROR3Mutator]MSP[]
wdsz >= 3 && isVowel ( local , 2 ) ) { MST[rv.ROR2Mutator]MSP[] code . append ( 'K' ) ; } else { code . append ( 'X' ) ; } } else { code . append ( 'K' ) ; } break; case 'D' :
code . append ( 'H' ) ; } break; case 'F' : case 'J' : case 'L' : case 'M' : case 'N' : case 'R' : code . append ( symb ) ; break; case 'K' : if ( n > 0 ) { MST[rv.UOI2Mutator]MSP[]
if ( ! isLastChar ( wdsz , n ) && MST[rv.ROR5Mutator]MSP[] isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break; case 'Z' :
final StringBuilder code = new StringBuilder ( 10 ) ; switch( inwd [ 0 ] ) { MST[rv.CRCR3Mutator]MSP[] case 'K' : case 'G' : case 'P' : if ( inwd [ 1 ] == 'N' ) {
return n + 1 == wdsz ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
isNextChar ( local , n , 'H' ) && MST[rv.ABSMutator]MSP[] ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && MST[rv.UOI1Mutator]MSP[] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; break; }
if ( regionMatch ( local , n , lr_11 ) ) { code . append ( '0' ) ; } else { code . append ( 'T' ) ; MST[NonVoidMethodCallMutator]MSP[] } break; case 'V' : code . append ( 'F' ) ; break; case 'W' : case 'Y' :
if ( regionMatch ( local , n , lr_8 ) || MST[rv.ABSMutator]MSP[] regionMatch ( local , n , lr_9 ) ) { code . append ( 'X' ) ; break; } if ( regionMatch ( local , n , lr_10 ) ) { break; }
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { MST[rv.ROR4Mutator]MSP[] code . append ( 'J' ) ; n += 2 ;
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { MST[ArgumentPropagationMutator]MSP[] break; } if ( regionMatch ( local , n , lr_2 ) ) {
public String metaphone ( final String txt ) { MST[rv.UOI1Mutator]MSP[] boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) {
} if ( isPreviousChar ( local , n , 'G' ) ) { hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) && MST[rv.UOI3Mutator]MSP[]
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && index + test . length () - 1 < string . length () ) { MST[NonVoidMethodCallMutator]MSP[]
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) { MST[rv.ROR2Mutator]MSP[]
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.AOR3Mutator]MSP[] break; } if ( inwd [ 1 ] == 'H' ) { local . append ( inwd , 1 , inwd . length - 1 ) ;
local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break; case 'A' : if ( inwd [ 1 ] == 'E' ) { MST[rv.CRCR4Mutator]MSP[]
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; MST[rv.CRCR5Mutator]MSP[] break; }
final int wdsz = local . length () ; int n = 0 ; while ( code . length () < this . getMaxCodeLen () && MST[rv.ROR4Mutator]MSP[] n < wdsz ) { final char symb = local . charAt ( n ) ;
if ( isPreviousChar ( local , n , 'S' ) && MST[RemoveConditionalMutator_EQUAL_IF]MSP[] isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 &&
code . append ( 'F' ) ; } else { code . append ( symb ) ; } break; case 'Q' : code . append ( 'K' ) ; break; case 'S' : if ( regionMatch ( local , n , lr_5 ) || MST[rv.ROR5Mutator]MSP[]
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && MST[rv.ROR2Mutator]MSP[] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; break; }
isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && MST[rv.ABSMutator]MSP[] ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && MST[rv.CRCR6Mutator]MSP[] isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; MST[rv.AOR1Mutator]MSP[] } return matches ; }
final StringBuilder code = new StringBuilder ( 10 ) ; switch( inwd [ 0 ] ) { MST[rv.CRCR6Mutator]MSP[] case 'K' : case 'G' : case 'P' : if ( inwd [ 1 ] == 'N' ) {
public int getMaxCodeLen () { return this . maxCodeLen ; } MST[rv.UOI1Mutator]MSP[] public void setMaxCodeLen ( final int maxCodeLen ) { this . maxCodeLen = maxCodeLen ; }
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.CRCR1Mutator]MSP[] isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 &&
public String metaphone ( final String txt ) { MST[rv.ROR4Mutator]MSP[] boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) {
code . append ( 'F' ) ; } else { code . append ( symb ) ; } break; case 'Q' : code . append ( 'K' ) ; break; case 'S' : if ( regionMatch ( local , n , lr_5 ) || MST[rv.UOI2Mutator]MSP[]
code . append ( 'F' ) ; } else { code . append ( symb ) ; } break; case 'Q' : code . append ( 'K' ) ; break; case 'S' : if ( regionMatch ( local , n , lr_5 ) || MST[rv.UOI4Mutator]MSP[]
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { MST[rv.CRCR2Mutator]MSP[] if ( n == 0 &&
code . append ( 'F' ) ; } else { code . append ( symb ) ; MST[rv.ABSMutator]MSP[] } break; case 'Q' : code . append ( 'K' ) ; break; case 'S' : if ( regionMatch ( local , n , lr_5 ) ||
regionMatch ( local , n , lr_6 ) || regionMatch ( local , n , lr_7 ) ) { code . append ( 'X' ) ; } else { code . append ( 'S' ) ; MST[rv.CRCR3Mutator]MSP[] } break; case 'T' :
regionMatch ( local , n , lr_6 ) || regionMatch ( local , n , lr_7 ) ) { code . append ( 'X' ) ; } else { code . append ( 'S' ) ; MST[rv.CRCR6Mutator]MSP[] } break; case 'T' :
if ( regionMatch ( local , n , lr_11 ) ) { code . append ( '0' ) ; } else { code . append ( 'T' ) ; } break; case 'V' : code . append ( 'F' ) ; break; MST[rv.CRCR1Mutator]MSP[] case 'W' : case 'Y' :
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) { MST[NegateConditionalsMutator]MSP[]
wdsz >= 3 && isVowel ( local , 2 ) ) { code . append ( 'K' ) ; MST[rv.CRCR6Mutator]MSP[] } else { code . append ( 'X' ) ; } } else { code . append ( 'K' ) ; } break; case 'D' :
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { MST[rv.AOD1Mutator]MSP[] matches = string . charAt ( index + 1 ) == c ;
return n + 1 == wdsz ; MST[rv.AOD2Mutator]MSP[] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ; MST[rv.CRCR3Mutator]MSP[]
return txt . toUpperCase ( java . util . Locale . ENGLISH ) ; } final char [] inwd = txt . toUpperCase ( java . util . Locale . ENGLISH ) . toCharArray () ; MST[experimental.NakedReceiverMutator]MSP[] final StringBuilder local = new StringBuilder ( 40 ) ;
FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 && ! hard ) { code . append ( 'J' ) ; MST[rv.CRCR5Mutator]MSP[] } else { code . append ( 'K' ) ; } break; case 'H' :
wdsz >= 3 && isVowel ( local , 2 ) ) { code . append ( 'K' ) ; MST[rv.CRCR3Mutator]MSP[] } else { code . append ( 'X' ) ; } } else { code . append ( 'K' ) ; } break; case 'D' :
local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break; case 'A' : if ( inwd [ 1 ] == 'E' ) { MST[rv.ROR1Mutator]MSP[]
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) { MST[rv.AOR1Mutator]MSP[]
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && MST[rv.ROR5Mutator]MSP[] VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) {
FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 && MST[RemoveConditionalMutator_ORDER_IF]MSP[] ! hard ) { code . append ( 'J' ) ; } else { code . append ( 'K' ) ; } break; case 'H' :
wdsz >= 3 && isVowel ( local , 2 ) ) { code . append ( 'K' ) ; } else { code . append ( 'X' ) ; } } else { code . append ( 'K' ) ; MST[InlineConstantMutator]MSP[] } break; case 'D' :
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ; MST[rv.AOR1Mutator]MSP[]
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && MST[rv.CRCR3Mutator]MSP[] isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
public String metaphone ( final String txt ) { boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) { MST[rv.ROR4Mutator]MSP[]
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.AOD1Mutator]MSP[] } else { local . append ( inwd ) ; } break; case 'W' : if ( inwd [ 1 ] == 'R' ) {
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.CRCR2Mutator]MSP[] break; } if ( inwd [ 1 ] == 'H' ) { local . append ( inwd , 1 , inwd . length - 1 ) ;
local . setCharAt ( 0 , 'W' ) ; } else { local . append ( inwd ) ; } break; case 'X' : inwd [ 0 ] = 'S' ; local . append ( inwd ) ; break; default: local . append ( inwd ) ; MST[experimental.NakedReceiverMutator]MSP[] }
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && MST[NegateConditionalsMutator]MSP[] index + test . length () - 1 < string . length () ) {
public int getMaxCodeLen () { return this . maxCodeLen ; } MST[rv.UOI4Mutator]MSP[] public void setMaxCodeLen ( final int maxCodeLen ) { this . maxCodeLen = maxCodeLen ; }
} if ( isPreviousChar ( local , n , 'G' ) ) { hard = true ; } else { hard = false ; MST[rv.CRCR1Mutator]MSP[] } if ( ! isLastChar ( wdsz , n ) &&
final StringBuilder code = new StringBuilder ( 10 ) ; MST[rv.CRCR4Mutator]MSP[] switch( inwd [ 0 ] ) { case 'K' : case 'G' : case 'P' : if ( inwd [ 1 ] == 'N' ) {
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; MST[rv.CRCR6Mutator]MSP[] } return matches ; }
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 && MST[rv.ROR3Mutator]MSP[]
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 && MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
if ( ! isLastChar ( wdsz , n ) && MST[rv.CRCR6Mutator]MSP[] isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break; case 'Z' :
if ( isPreviousChar ( local , n , 'S' ) && MST[NonVoidMethodCallMutator]MSP[] isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 &&
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { MST[rv.ROR3Mutator]MSP[] matches = string . charAt ( index + 1 ) == c ;
final String substring = string . substring ( index , index + test . length () ) ; matches = substring . equals ( test ) ; } return matches ; MST[rv.UOI2Mutator]MSP[] } private boolean isLastChar ( final int wdsz , final int n ) {
code . append ( 'H' ) ; MST[rv.CRCR1Mutator]MSP[] } break; case 'F' : case 'J' : case 'L' : case 'M' : case 'N' : case 'R' : code . append ( symb ) ; break; case 'K' : if ( n > 0 ) {
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && MST[rv.ABSMutator]MSP[] index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ;
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && MST[rv.AOD2Mutator]MSP[] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; break; }
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && index + test . length () - 1 < string . length () ) { MST[rv.AOR1Mutator]MSP[]
} else { code . append ( 'T' ) ; MST[rv.CRCR1Mutator]MSP[] } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
boolean matches = false ; if( index > 0 && MST[rv.ROR1Mutator]MSP[] index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; } return matches ; }
if ( ! isPreviousChar ( local , n , 'C' ) ) { code . append ( symb ) ; } } else { code . append ( symb ) ; MST[rv.UOI2Mutator]MSP[] } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) {
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.CRCR2Mutator]MSP[] } else { local . append ( inwd ) ; } break; case 'A' : if ( inwd [ 1 ] == 'E' ) {
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.UOI1Mutator]MSP[] ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.CRCR4Mutator]MSP[] break; } if ( inwd [ 1 ] == 'H' ) { local . append ( inwd , 1 , inwd . length - 1 ) ;
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && MST[rv.UOI4Mutator]MSP[] index + test . length () - 1 < string . length () ) {
local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break; case 'A' : if ( inwd [ 1 ] == 'E' ) { MST[rv.ROR4Mutator]MSP[]
if ( ! isLastChar ( wdsz , n ) && isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; MST[rv.CRCR6Mutator]MSP[] code . append ( 'S' ) ; break; case 'Z' :
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { MST[rv.ABSMutator]MSP[] n ++ ; } else { switch( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
return n + 1 == wdsz ; } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; MST[ConstructorCallMutator]MSP[] } return metaphone ( ( String ) obj ) ; } @Override
public String metaphone ( final String txt ) { MST[InlineConstantMutator]MSP[] boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) {
final StringBuilder code = new StringBuilder ( 10 ) ; switch( inwd [ 0 ] ) { case 'K' : case 'G' : case 'P' : if ( inwd [ 1 ] == 'N' ) { MST[rv.ROR1Mutator]MSP[]
if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.CRCR2Mutator]MSP[] isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.CRCR5Mutator]MSP[] break; } if ( inwd [ 1 ] == 'H' ) { local . append ( inwd , 1 , inwd . length - 1 ) ;
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 && MST[rv.UOI2Mutator]MSP[]
final String substring = string . substring ( index , index + test . length () ) ; MST[rv.UOI4Mutator]MSP[] matches = substring . equals ( test ) ; } return matches ; } private boolean isLastChar ( final int wdsz , final int n ) {
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) { MST[rv.CRCR3Mutator]MSP[]
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && MST[rv.ROR5Mutator]MSP[] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; break; }
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.CRCR2Mutator]MSP[] isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 &&
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; MST[rv.CRCR3Mutator]MSP[] } return matches ; }
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 && MST[rv.ROR4Mutator]MSP[]
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { MST[rv.CRCR2Mutator]MSP[] matches = string . charAt ( index + 1 ) == c ;
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { MST[rv.CRCR5Mutator]MSP[] if ( n == 0 &&
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && MST[rv.CRCR6Mutator]MSP[] FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
local . setCharAt ( 0 , 'W' ) ; } else { local . append ( inwd ) ; MST[experimental.NakedReceiverMutator]MSP[] } break; case 'X' : inwd [ 0 ] = 'S' ; local . append ( inwd ) ; break; default: local . append ( inwd ) ; }
code . append ( 'F' ) ; } else { code . append ( symb ) ; } break; case 'Q' : code . append ( 'K' ) ; MST[rv.CRCR3Mutator]MSP[] break; case 'S' : if ( regionMatch ( local , n , lr_5 ) ||
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ; MST[rv.CRCR6Mutator]MSP[]
final String substring = string . substring ( index , index + test . length () ) ; matches = substring . equals ( test ) ; } return matches ; MST[rv.ABSMutator]MSP[] } private boolean isLastChar ( final int wdsz , final int n ) {
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.UOI4Mutator]MSP[]
regionMatch ( local , n , lr_6 ) || regionMatch ( local , n , lr_7 ) ) { code . append ( 'X' ) ; } else { code . append ( 'S' ) ; MST[experimental.NakedReceiverMutator]MSP[] } break; case 'T' :
local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break; case 'W' : if ( inwd [ 1 ] == 'R' ) { MST[InlineConstantMutator]MSP[]
boolean matches = false ; if( index > 0 && MST[rv.ABSMutator]MSP[] index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; } return matches ; }
return n + 1 == wdsz ; MST[rv.CRCR6Mutator]MSP[] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
return n + 1 == wdsz ; } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; MST[ReturnValsMutator]MSP[] } @Override
if ( ! isLastChar ( wdsz , n ) && isVowel ( local , n + 1 ) ) { code . append ( symb ) ; MST[NonVoidMethodCallMutator]MSP[] } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break; case 'Z' :
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && MST[rv.UOI1Mutator]MSP[] isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
regionMatch ( local , n , lr_6 ) || MST[rv.UOI1Mutator]MSP[] regionMatch ( local , n , lr_7 ) ) { code . append ( 'X' ) ; } else { code . append ( 'S' ) ; } break; case 'T' :
if ( ! isPreviousChar ( local , n , 'C' ) ) { code . append ( symb ) ; MST[rv.ABSMutator]MSP[] } } else { code . append ( symb ) ; } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) {
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && index + test . length () - 1 < string . length () ) { MST[rv.AOD1Mutator]MSP[]
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && MST[rv.AOD1Mutator]MSP[] isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && MST[rv.AOR4Mutator]MSP[] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; break; }
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { MST[rv.UOI1Mutator]MSP[] n ++ ; } else { switch( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
if ( ! isLastChar ( wdsz , n ) && MST[rv.UOI2Mutator]MSP[] isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break; case 'Z' :
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.CRCR4Mutator]MSP[] isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 &&
local . setCharAt ( 0 , 'W' ) ; } else { local . append ( inwd ) ; } break; case 'X' : inwd [ 0 ] = 'S' ; MST[rv.CRCR1Mutator]MSP[] local . append ( inwd ) ; break; default: local . append ( inwd ) ; }
private boolean isVowel ( final StringBuilder string , final int index ) { return VOWELS . indexOf ( string . charAt ( index ) ) >= 0 ; MST[rv.CRCR3Mutator]MSP[] } private boolean isPreviousChar ( final StringBuilder string , final int index , final char c ) {
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && MST[rv.AOR3Mutator]MSP[] isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
final int wdsz = local . length () ; int n = 0 ; MST[InlineConstantMutator]MSP[] while ( code . length () < this . getMaxCodeLen () && n < wdsz ) { final char symb = local . charAt ( n ) ;
} if ( isPreviousChar ( local , n , 'G' ) ) { hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) && MST[NonVoidMethodCallMutator]MSP[]
} return matches ; MST[BooleanFalseReturnValsMutator]MSP[] } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && index + test . length () - 1 < string . length () ) {
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && MST[rv.ABSMutator]MSP[] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; break; }
return n + 1 == wdsz ; MST[InlineConstantMutator]MSP[] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break; case 'W' : if ( inwd [ 1 ] == 'R' ) { MST[rv.ROR4Mutator]MSP[]
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { MST[rv.ROR1Mutator]MSP[] break; } if ( regionMatch ( local , n , lr_2 ) ) {
if ( ! isPreviousChar ( local , n , 'C' ) ) { code . append ( symb ) ; } } else { code . append ( symb ) ; } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) { MST[rv.ROR3Mutator]MSP[]
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) { MST[rv.ROR5Mutator]MSP[]
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
wdsz >= 3 && isVowel ( local , 2 ) ) { code . append ( 'K' ) ; MST[experimental.NakedReceiverMutator]MSP[] } else { code . append ( 'X' ) ; } } else { code . append ( 'K' ) ; } break; case 'D' :
if ( regionMatch ( local , n , lr_11 ) ) { MST[rv.ROR4Mutator]MSP[] code . append ( '0' ) ; } else { code . append ( 'T' ) ; } break; case 'V' : code . append ( 'F' ) ; break; case 'W' : case 'Y' :
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.ROR1Mutator]MSP[] ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
boolean matches = false ; if( index > 0 && index < string . length () ) { MST[rv.ROR3Mutator]MSP[] matches = string . charAt ( index - 1 ) == c ; } return matches ; }
if ( ! isPreviousChar ( local , n , 'C' ) ) { MST[NonVoidMethodCallMutator]MSP[] code . append ( symb ) ; } } else { code . append ( symb ) ; } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) {
public String metaphone ( final String txt ) { boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) { MST[rv.CRCR2Mutator]MSP[]
} if ( isPreviousChar ( local , n , 'G' ) ) { MST[rv.ROR4Mutator]MSP[] hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) &&
if ( isLastChar ( wdsz , n ) ) { MST[rv.ABSMutator]MSP[] break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) {
if ( regionMatch ( local , n , lr_8 ) || regionMatch ( local , n , lr_9 ) ) { code . append ( 'X' ) ; MST[rv.CRCR5Mutator]MSP[] break; } if ( regionMatch ( local , n , lr_10 ) ) { break; }
code . append ( 'F' ) ; MST[InlineConstantMutator]MSP[] } else { code . append ( symb ) ; } break; case 'Q' : code . append ( 'K' ) ; break; case 'S' : if ( regionMatch ( local , n , lr_5 ) ||
if ( ! isPreviousChar ( local , n , 'C' ) ) { code . append ( symb ) ; } } else { code . append ( symb ) ; } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && MST[NegateConditionalsMutator]MSP[] VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) {
return n + 1 == wdsz ; MST[rv.AOR4Mutator]MSP[] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
} if ( isPreviousChar ( local , n , 'G' ) ) { MST[rv.CRCR3Mutator]MSP[] hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) &&
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && MST[rv.ROR5Mutator]MSP[] index + test . length () - 1 < string . length () ) {
local . setCharAt ( 0 , 'W' ) ; } else { local . append ( inwd ) ; } break; case 'X' : inwd [ 0 ] = 'S' ; MST[rv.CRCR5Mutator]MSP[] local . append ( inwd ) ; break; default: local . append ( inwd ) ; }
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && MST[rv.UOI3Mutator]MSP[] isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; MST[rv.ABSMutator]MSP[] } return matches ; }
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; MST[InlineConstantMutator]MSP[] if( index >= 0 && index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ;
isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || MST[RemoveConditionalMutator_EQUAL_IF]MSP[] regionMatch ( local , n , lr_4 ) ) ) { break;
local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break; case 'A' : if ( inwd [ 1 ] == 'E' ) { MST[InlineConstantMutator]MSP[]
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; MST[rv.CRCR3Mutator]MSP[] if( index >= 0 && index + test . length () - 1 < string . length () ) {
isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && MST[rv.ABSMutator]MSP[] ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.CRCR3Mutator]MSP[]
if ( regionMatch ( local , n , lr_11 ) ) { code . append ( '0' ) ; } else { code . append ( 'T' ) ; MST[rv.CRCR2Mutator]MSP[] } break; case 'V' : code . append ( 'F' ) ; break; case 'W' : case 'Y' :
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ; MST[rv.ABSMutator]MSP[]
code . append ( 'X' ) ; MST[rv.CRCR6Mutator]MSP[] break; } if ( ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; break; }
return txt . toUpperCase ( java . util . Locale . ENGLISH ) ; } final char [] inwd = txt . toUpperCase ( java . util . Locale . ENGLISH ) . toCharArray () ; final StringBuilder local = new StringBuilder ( 40 ) ; MST[rv.CRCR3Mutator]MSP[]
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && MST[rv.UOI4Mutator]MSP[] FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
isNextChar ( local , n , 'H' ) && MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
if ( isLastChar ( wdsz , n ) ) { MST[rv.ROR1Mutator]MSP[] break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) {
local . setCharAt ( 0 , 'W' ) ; MST[rv.CRCR5Mutator]MSP[] } else { local . append ( inwd ) ; } break; case 'X' : inwd [ 0 ] = 'S' ; local . append ( inwd ) ; break; default: local . append ( inwd ) ; }
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && MST[ConditionalsBoundaryMutator]MSP[] index + test . length () - 1 < string . length () ) {
isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || MST[rv.ROR3Mutator]MSP[] regionMatch ( local , n , lr_4 ) ) ) { break;
isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || MST[rv.UOI2Mutator]MSP[] regionMatch ( local , n , lr_4 ) ) ) { break;
code . append ( 'F' ) ; } else { code . append ( symb ) ; } break; case 'Q' : code . append ( 'K' ) ; break; case 'S' : if ( regionMatch ( local , n , lr_5 ) || MST[NegateConditionalsMutator]MSP[]
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] } return matches ; }
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && MST[rv.ABSMutator]MSP[] index + test . length () - 1 < string . length () ) {
final StringBuilder code = new StringBuilder ( 10 ) ; switch( inwd [ 0 ] ) { case 'K' : case 'G' : case 'P' : if ( inwd [ 1 ] == 'N' ) { MST[rv.CRCR4Mutator]MSP[]
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.ABSMutator]MSP[] ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { n ++ ; } else { switch( symb ) { MST[experimental.RemoveSwitchMutator_13]MSP[] case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { n ++ ; } else { switch( symb ) { MST[experimental.RemoveSwitchMutator_14]MSP[] case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
isNextChar ( local , n , 'H' ) && MST[NonVoidMethodCallMutator]MSP[] ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { n ++ ; } else { switch( symb ) { MST[experimental.RemoveSwitchMutator_15]MSP[] case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { n ++ ; } else { switch( symb ) { MST[experimental.RemoveSwitchMutator_16]MSP[] case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { n ++ ; } else { switch( symb ) { MST[experimental.RemoveSwitchMutator_17]MSP[] case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
if ( regionMatch ( local , n , lr_8 ) || MST[rv.ROR1Mutator]MSP[] regionMatch ( local , n , lr_9 ) ) { code . append ( 'X' ) ; break; } if ( regionMatch ( local , n , lr_10 ) ) { break; }
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { n ++ ; } else { switch( symb ) { MST[experimental.RemoveSwitchMutator_18]MSP[] case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
final String substring = string . substring ( index , index + test . length () ) ; MST[rv.UOI1Mutator]MSP[] matches = substring . equals ( test ) ; } return matches ; } private boolean isLastChar ( final int wdsz , final int n ) {
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { n ++ ; } else { switch( symb ) { MST[experimental.RemoveSwitchMutator_19]MSP[] case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
code . append ( 'H' ) ; } break; case 'F' : case 'J' : case 'L' : case 'M' : case 'N' : case 'R' : code . append ( symb ) ; MST[rv.ABSMutator]MSP[] break; case 'K' : if ( n > 0 ) {
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { MST[ArgumentPropagationMutator]MSP[] code . append ( 'S' ) ; break; }
} if ( isPreviousChar ( local , n , 'G' ) ) { hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) && MST[rv.ROR3Mutator]MSP[]
local . append ( inwd , 1 , inwd . length - 1 ) ; break; } if ( inwd [ 1 ] == 'H' ) { MST[InlineConstantMutator]MSP[] local . append ( inwd , 1 , inwd . length - 1 ) ;
code . append ( 'S' ) ; MST[rv.CRCR3Mutator]MSP[] break; default: break; } n ++ ; } if ( code . length () > this . getMaxCodeLen () ) { code . setLength ( this . getMaxCodeLen () ) ; } } return code . toString () ; }
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && MST[rv.UOI2Mutator]MSP[] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; break; }
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; MST[rv.CRCR3Mutator]MSP[] } return matches ; }
code . append ( 'H' ) ; MST[rv.CRCR4Mutator]MSP[] } break; case 'F' : case 'J' : case 'L' : case 'M' : case 'N' : case 'R' : code . append ( symb ) ; break; case 'K' : if ( n > 0 ) {
boolean matches = false ; if( index > 0 && MST[ConditionalsBoundaryMutator]MSP[] index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; } return matches ; }
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] if ( n == 0 &&
final String substring = string . substring ( index , index + test . length () ) ; matches = substring . equals ( test ) ; } return matches ; MST[ReturnValsMutator]MSP[] } private boolean isLastChar ( final int wdsz , final int n ) {
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) { MST[rv.ABSMutator]MSP[]
if ( regionMatch ( local , n , lr_11 ) ) { MST[rv.UOI1Mutator]MSP[] code . append ( '0' ) ; } else { code . append ( 'T' ) ; } break; case 'V' : code . append ( 'F' ) ; break; case 'W' : case 'Y' :
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { n ++ ; } else { switch( symb ) { MST[experimental.RemoveSwitchMutator_20]MSP[] case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.ROR1Mutator]MSP[] isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
} else { code . append ( 'T' ) ; MST[rv.CRCR4Mutator]MSP[] } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { n ++ ; } else { switch( symb ) { MST[experimental.RemoveSwitchMutator_21]MSP[] case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { n ++ ; } else { switch( symb ) { MST[experimental.RemoveSwitchMutator_22]MSP[] case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break; case 'A' : if ( inwd [ 1 ] == 'E' ) { MST[rv.CRCR2Mutator]MSP[]
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { n ++ ; } else { switch( symb ) { MST[experimental.RemoveSwitchMutator_23]MSP[] case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
code . append ( 'F' ) ; } else { code . append ( symb ) ; } break; case 'Q' : code . append ( 'K' ) ; MST[experimental.NakedReceiverMutator]MSP[] break; case 'S' : if ( regionMatch ( local , n , lr_5 ) ||
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { n ++ ; } else { switch( symb ) { MST[experimental.RemoveSwitchMutator_24]MSP[] case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; MST[NonVoidMethodCallMutator]MSP[] break; }
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { n ++ ; } else { switch( symb ) { MST[experimental.RemoveSwitchMutator_25]MSP[] case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
boolean matches = false ; MST[rv.CRCR6Mutator]MSP[] if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; } return matches ; }
if ( ! isLastChar ( wdsz , n ) && MST[rv.AOD2Mutator]MSP[] isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break; case 'Z' :
if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.UOI3Mutator]MSP[] isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
public String metaphone ( final String txt ) { boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return lr_1 ; } if ( txtLength == 1 ) {
boolean matches = false ; if( index > 0 && MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; } return matches ; }
public String metaphone ( final String txt ) { MST[experimental.MemberVariableMutator]MSP[] boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) {
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && MST[InlineConstantMutator]MSP[] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && MST[rv.AOR4Mutator]MSP[] FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && MST[rv.ROR2Mutator]MSP[] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
} if ( isPreviousChar ( local , n , 'G' ) ) { MST[rv.UOI1Mutator]MSP[] hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) &&
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) { MST[InlineConstantMutator]MSP[]
final String substring = string . substring ( index , index + test . length () ) ; MST[rv.AOD1Mutator]MSP[] matches = substring . equals ( test ) ; } return matches ; } private boolean isLastChar ( final int wdsz , final int n ) {
if ( isLastChar ( wdsz , n ) ) { MST[rv.ROR4Mutator]MSP[] break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) {
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ; MST[rv.UOI2Mutator]MSP[]
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && MST[rv.UOI4Mutator]MSP[] isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && index + test . length () - 1 < string . length () ) { MST[rv.AOD2Mutator]MSP[]
isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && MST[RemoveConditionalMutator_ORDER_IF]MSP[] ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && index + test . length () - 1 < string . length () ) { MST[rv.CRCR3Mutator]MSP[]
if ( ! isLastChar ( wdsz , n ) && isVowel ( local , n + 1 ) ) { MST[rv.ROR1Mutator]MSP[] code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break; case 'Z' :
private boolean isVowel ( final StringBuilder string , final int index ) { return VOWELS . indexOf ( string . charAt ( index ) ) >= 0 ; MST[rv.ROR3Mutator]MSP[] } private boolean isPreviousChar ( final StringBuilder string , final int index , final char c ) {
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) { MST[rv.CRCR6Mutator]MSP[]
return n + 1 == wdsz ; } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { MST[rv.ROR2Mutator]MSP[] throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
code . append ( 'H' ) ; } break; case 'F' : case 'J' : case 'L' : case 'M' : case 'N' : case 'R' : code . append ( symb ) ; MST[rv.UOI2Mutator]MSP[] break; case 'K' : if ( n > 0 ) {
if ( regionMatch ( local , n , lr_11 ) ) { code . append ( '0' ) ; } else { code . append ( 'T' ) ; MST[rv.CRCR5Mutator]MSP[] } break; case 'V' : code . append ( 'F' ) ; break; case 'W' : case 'Y' :
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && MST[rv.ABSMutator]MSP[] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; break; }
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; MST[NonVoidMethodCallMutator]MSP[] } return matches ; }
code . append ( 'F' ) ; } else { code . append ( symb ) ; } break; case 'Q' : code . append ( 'K' ) ; MST[rv.CRCR6Mutator]MSP[] break; case 'S' : if ( regionMatch ( local , n , lr_5 ) ||
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.UOI1Mutator]MSP[]
final StringBuilder code = new StringBuilder ( 10 ) ; switch( inwd [ 0 ] ) { case 'K' : case 'G' : case 'P' : if ( inwd [ 1 ] == 'N' ) { MST[rv.ROR4Mutator]MSP[]
code . append ( 'F' ) ; } else { code . append ( symb ) ; } break; case 'Q' : code . append ( 'K' ) ; MST[InlineConstantMutator]MSP[] break; case 'S' : if ( regionMatch ( local , n , lr_5 ) ||
regionMatch ( local , n , lr_6 ) || regionMatch ( local , n , lr_7 ) ) { MST[rv.ROR2Mutator]MSP[] code . append ( 'X' ) ; } else { code . append ( 'S' ) ; } break; case 'T' :
code . append ( symb ) ; MST[rv.UOI1Mutator]MSP[] } break; case 'B' : if ( isPreviousChar ( local , n , 'M' ) && isLastChar ( wdsz , n ) ) { break; } code . append ( symb ) ; break; case 'C' :
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) { MST[rv.UOI2Mutator]MSP[]
return n + 1 == wdsz ; MST[rv.CRCR3Mutator]MSP[] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
if ( ! isPreviousChar ( local , n , 'C' ) ) { MST[rv.ROR3Mutator]MSP[] code . append ( symb ) ; } } else { code . append ( symb ) ; } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) {
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.CRCR3Mutator]MSP[] ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { MST[rv.ROR2Mutator]MSP[] break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
code . append ( 'S' ) ; break; default: break; } n ++ ; } if ( code . length () > this . getMaxCodeLen () ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[] code . setLength ( this . getMaxCodeLen () ) ; } } return code . toString () ; }
FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 && ! hard ) { code . append ( 'J' ) ; MST[NonVoidMethodCallMutator]MSP[] } else { code . append ( 'K' ) ; } break; case 'H' :
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && MST[rv.CRCR6Mutator]MSP[] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
if ( ! isLastChar ( wdsz , n ) && MST[rv.AOR4Mutator]MSP[] isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break; case 'Z' :
if ( ! isLastChar ( wdsz , n ) && MST[rv.UOI1Mutator]MSP[] isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break; case 'Z' :
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { n ++ ; } else { switch( symb ) { MST[experimental.RemoveSwitchMutator_10]MSP[] case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { n ++ ; } else { switch( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
if ( ! isLastChar ( wdsz , n ) && isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; MST[rv.CRCR1Mutator]MSP[] break; case 'Z' :
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { n ++ ; } else { switch( symb ) { MST[experimental.RemoveSwitchMutator_11]MSP[] case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && MST[rv.CRCR2Mutator]MSP[] VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) {
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { n ++ ; } else { switch( symb ) { MST[experimental.RemoveSwitchMutator_12]MSP[] case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
} return matches ; MST[rv.UOI2Mutator]MSP[] } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && index + test . length () - 1 < string . length () ) {
local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break; case 'W' : if ( inwd [ 1 ] == 'R' ) { MST[rv.CRCR5Mutator]MSP[]
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
regionMatch ( local , n , lr_6 ) || regionMatch ( local , n , lr_7 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] code . append ( 'X' ) ; } else { code . append ( 'S' ) ; } break; case 'T' :
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ; MST[NonVoidMethodCallMutator]MSP[]
FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 && MST[rv.ROR2Mutator]MSP[] ! hard ) { code . append ( 'J' ) ; } else { code . append ( 'K' ) ; } break; case 'H' :
local . setCharAt ( 0 , 'W' ) ; } else { local . append ( inwd ) ; } break; case 'X' : inwd [ 0 ] = 'S' ; MST[rv.CRCR4Mutator]MSP[] local . append ( inwd ) ; break; default: local . append ( inwd ) ; }
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && MST[rv.UOI4Mutator]MSP[] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; break; }
return n + 1 == wdsz ; MST[InlineConstantMutator]MSP[] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
public String metaphone ( final String txt ) { MST[rv.UOI4Mutator]MSP[] boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) {
if ( regionMatch ( local , n , lr_11 ) ) { code . append ( '0' ) ; MST[NonVoidMethodCallMutator]MSP[] } else { code . append ( 'T' ) ; } break; case 'V' : code . append ( 'F' ) ; break; case 'W' : case 'Y' :
local . append ( inwd , 1 , inwd . length - 1 ) ; break; } if ( inwd [ 1 ] == 'H' ) { MST[rv.CRCR6Mutator]MSP[] local . append ( inwd , 1 , inwd . length - 1 ) ;
return n + 1 == wdsz ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.CRCR4Mutator]MSP[] } else { local . append ( inwd ) ; } break; case 'W' : if ( inwd [ 1 ] == 'R' ) {
final String substring = string . substring ( index , index + test . length () ) ; MST[rv.AOR2Mutator]MSP[] matches = substring . equals ( test ) ; } return matches ; } private boolean isLastChar ( final int wdsz , final int n ) {
public String metaphone ( final String txt ) { MST[rv.CRCR1Mutator]MSP[] boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) {
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.ROR2Mutator]MSP[]
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && MST[MathMutator]MSP[] isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
private boolean isVowel ( final StringBuilder string , final int index ) { return VOWELS . indexOf ( string . charAt ( index ) ) >= 0 ; MST[rv.CRCR3Mutator]MSP[] } private boolean isPreviousChar ( final StringBuilder string , final int index , final char c ) {
wdsz >= 3 && isVowel ( local , 2 ) ) { code . append ( 'K' ) ; } else { code . append ( 'X' ) ; MST[rv.CRCR6Mutator]MSP[] } } else { code . append ( 'K' ) ; } break; case 'D' :
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && MST[rv.ROR5Mutator]MSP[] isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
regionMatch ( local , n , lr_6 ) || MST[rv.ROR5Mutator]MSP[] regionMatch ( local , n , lr_7 ) ) { code . append ( 'X' ) ; } else { code . append ( 'S' ) ; } break; case 'T' :
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && MST[rv.AOR1Mutator]MSP[] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; break; }
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && MST[rv.CRCR3Mutator]MSP[] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && MST[rv.UOI2Mutator]MSP[] index + test . length () - 1 < string . length () ) {
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { MST[rv.ROR5Mutator]MSP[] n ++ ; } else { switch( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
wdsz >= 3 && isVowel ( local , 2 ) ) { MST[rv.ROR5Mutator]MSP[] code . append ( 'K' ) ; } else { code . append ( 'X' ) ; } } else { code . append ( 'K' ) ; } break; case 'D' :
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; MST[rv.CRCR1Mutator]MSP[] break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 &&
} return matches ; MST[rv.ABSMutator]MSP[] } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && index + test . length () - 1 < string . length () ) {
isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || MST[rv.ABSMutator]MSP[] regionMatch ( local , n , lr_4 ) ) ) { break;
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; MST[rv.ABSMutator]MSP[] } return matches ; }
local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break; case 'W' : if ( inwd [ 1 ] == 'R' ) { MST[rv.CRCR2Mutator]MSP[]
if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.CRCR4Mutator]MSP[] isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ; MST[rv.ABSMutator]MSP[]
} if ( isPreviousChar ( local , n , 'G' ) ) { hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) && MST[rv.CRCR4Mutator]MSP[]
FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 && MST[NegateConditionalsMutator]MSP[] ! hard ) { code . append ( 'J' ) ; } else { code . append ( 'K' ) ; } break; case 'H' :
if ( ! isPreviousChar ( local , n , 'C' ) ) { code . append ( symb ) ; } } else { code . append ( symb ) ; } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) { MST[rv.CRCR5Mutator]MSP[]
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; } return matches ; MST[rv.ABSMutator]MSP[] }
isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { MST[rv.ROR2Mutator]MSP[] break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; MST[NonVoidMethodCallMutator]MSP[] } break; case 'W' : if ( inwd [ 1 ] == 'R' ) {
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { MST[rv.UOI3Mutator]MSP[] if ( n == 0 &&
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) { MST[rv.UOI1Mutator]MSP[]
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && index + test . length () - 1 < string . length () ) { MST[InlineConstantMutator]MSP[]
wdsz >= 3 && isVowel ( local , 2 ) ) { code . append ( 'K' ) ; } else { code . append ( 'X' ) ; MST[InlineConstantMutator]MSP[] } } else { code . append ( 'K' ) ; } break; case 'D' :
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 && MST[rv.CRCR2Mutator]MSP[]
regionMatch ( local , n , lr_6 ) || MST[rv.UOI4Mutator]MSP[] regionMatch ( local , n , lr_7 ) ) { code . append ( 'X' ) ; } else { code . append ( 'S' ) ; } break; case 'T' :
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) && MST[NegateConditionalsMutator]MSP[]
if ( regionMatch ( local , n , lr_11 ) ) { code . append ( '0' ) ; } else { code . append ( 'T' ) ; } break; case 'V' : code . append ( 'F' ) ; break; MST[rv.CRCR4Mutator]MSP[] case 'W' : case 'Y' :
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && MST[rv.AOD2Mutator]MSP[] FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && MST[rv.UOI2Mutator]MSP[] index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ;
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; MST[rv.UOI2Mutator]MSP[] } return matches ; }
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.UOI2Mutator]MSP[] isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 &&
FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 && ! hard ) { code . append ( 'J' ) ; } else { code . append ( 'K' ) ; MST[rv.CRCR5Mutator]MSP[] } break; case 'H' :
local . append ( inwd , 1 , inwd . length - 1 ) ; break; } if ( inwd [ 1 ] == 'H' ) { MST[rv.CRCR3Mutator]MSP[] local . append ( inwd , 1 , inwd . length - 1 ) ;
if ( ! isPreviousChar ( local , n , 'C' ) ) { MST[rv.CRCR2Mutator]MSP[] code . append ( symb ) ; } } else { code . append ( symb ) ; } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) {
return n + 1 == wdsz ; MST[rv.ROR3Mutator]MSP[] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
wdsz >= 3 && isVowel ( local , 2 ) ) { code . append ( 'K' ) ; } else { code . append ( 'X' ) ; MST[rv.CRCR3Mutator]MSP[] } } else { code . append ( 'K' ) ; } break; case 'D' :
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.ROR3Mutator]MSP[] isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 &&
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && index + test . length () - 1 < string . length () ) { MST[rv.AOR4Mutator]MSP[]
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.UOI4Mutator]MSP[] ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
final int wdsz = local . length () ; int n = 0 ; while ( code . length () < this . getMaxCodeLen () && n < wdsz ) { final char symb = local . charAt ( n ) ; MST[rv.ABSMutator]MSP[]
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.CRCR5Mutator]MSP[]
code . append ( 'S' ) ; break; default: break; } n ++ ; } if ( code . length () > this . getMaxCodeLen () ) { MST[NonVoidMethodCallMutator]MSP[] code . setLength ( this . getMaxCodeLen () ) ; } } return code . toString () ; }
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && MST[NegateConditionalsMutator]MSP[] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; break; }
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; MST[rv.CRCR3Mutator]MSP[] } return matches ; }
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 && MST[rv.ABSMutator]MSP[]
code . append ( symb ) ; } break; case 'B' : if ( isPreviousChar ( local , n , 'M' ) && isLastChar ( wdsz , n ) ) { break; } code . append ( symb ) ; MST[rv.UOI3Mutator]MSP[] break; case 'C' :
if ( regionMatch ( local , n , lr_8 ) || MST[rv.ROR4Mutator]MSP[] regionMatch ( local , n , lr_9 ) ) { code . append ( 'X' ) ; break; } if ( regionMatch ( local , n , lr_10 ) ) { break; }
public String metaphone ( final String txt ) { boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) { MST[rv.UOI3Mutator]MSP[]
local . append ( inwd , 1 , inwd . length - 1 ) ; break; } if ( inwd [ 1 ] == 'H' ) { MST[rv.ROR3Mutator]MSP[] local . append ( inwd , 1 , inwd . length - 1 ) ;
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { MST[InlineConstantMutator]MSP[] n ++ ; } else { switch( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
} if ( isPreviousChar ( local , n , 'G' ) ) { MST[rv.UOI4Mutator]MSP[] hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) &&
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[MathMutator]MSP[] } else { local . append ( inwd ) ; } break; case 'W' : if ( inwd [ 1 ] == 'R' ) {
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && MST[rv.AOR4Mutator]MSP[] VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) {
if ( regionMatch ( local , n , lr_11 ) ) { MST[rv.UOI4Mutator]MSP[] code . append ( '0' ) ; } else { code . append ( 'T' ) ; } break; case 'V' : code . append ( 'F' ) ; break; case 'W' : case 'Y' :
if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.ROR4Mutator]MSP[] isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && MST[rv.ROR3Mutator]MSP[] index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ;
if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.UOI2Mutator]MSP[] isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
if ( ! isPreviousChar ( local , n , 'C' ) ) { MST[rv.CRCR5Mutator]MSP[] code . append ( symb ) ; } } else { code . append ( symb ) ; } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) {
local . append ( inwd , 1 , inwd . length - 1 ) ; break; } if ( inwd [ 1 ] == 'H' ) { local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.AOD1Mutator]MSP[]
if ( regionMatch ( local , n , lr_8 ) || regionMatch ( local , n , lr_9 ) ) { code . append ( 'X' ) ; MST[NonVoidMethodCallMutator]MSP[] break; } if ( regionMatch ( local , n , lr_10 ) ) { break; }
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && MST[rv.UOI1Mutator]MSP[] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ; MST[rv.AOR4Mutator]MSP[]
boolean matches = false ; if( index > 0 && MST[rv.UOI2Mutator]MSP[] index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; } return matches ; }
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ; MST[rv.UOI2Mutator]MSP[]
if ( ! isLastChar ( wdsz , n ) && isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; MST[rv.CRCR2Mutator]MSP[] code . append ( 'S' ) ; break; case 'Z' :
code . append ( 'S' ) ; MST[experimental.NakedReceiverMutator]MSP[] break; default: break; } n ++ ; } if ( code . length () > this . getMaxCodeLen () ) { code . setLength ( this . getMaxCodeLen () ) ; } } return code . toString () ; }
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; MST[rv.AOD2Mutator]MSP[] } return matches ; }
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; MST[rv.CRCR1Mutator]MSP[] if( index >= 0 && index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ;
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && MST[rv.UOI1Mutator]MSP[] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; break; }
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { MST[rv.ROR5Mutator]MSP[] break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; MST[rv.CRCR4Mutator]MSP[] break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 &&
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ; MST[rv.ROR3Mutator]MSP[]
if ( ! isLastChar ( wdsz , n ) && MST[rv.ABSMutator]MSP[] isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break; case 'Z' :
final int wdsz = local . length () ; int n = 0 ; while ( code . length () < this . getMaxCodeLen () && MST[RemoveConditionalMutator_ORDER_IF]MSP[] n < wdsz ) { final char symb = local . charAt ( n ) ;
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && MST[rv.CRCR2Mutator]MSP[] FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 && MST[rv.CRCR5Mutator]MSP[]
} if ( isPreviousChar ( local , n , 'G' ) ) { hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) && MST[rv.UOI2Mutator]MSP[]
return txt . toUpperCase ( java . util . Locale . ENGLISH ) ; } final char [] inwd = txt . toUpperCase ( java . util . Locale . ENGLISH ) . toCharArray () ; final StringBuilder local = new StringBuilder ( 40 ) ; MST[rv.CRCR6Mutator]MSP[]
if ( isPreviousChar ( local , n , 'S' ) && MST[InlineConstantMutator]MSP[] ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; MST[rv.CRCR1Mutator]MSP[] break; }
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.CRCR5Mutator]MSP[] } else { local . append ( inwd ) ; } break; case 'W' : if ( inwd [ 1 ] == 'R' ) {
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ; MST[rv.CRCR1Mutator]MSP[]
return n + 1 == wdsz ; MST[rv.CRCR3Mutator]MSP[] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
code . append ( symb ) ; MST[rv.UOI4Mutator]MSP[] } break; case 'B' : if ( isPreviousChar ( local , n , 'M' ) && isLastChar ( wdsz , n ) ) { break; } code . append ( symb ) ; break; case 'C' :
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.UOI4Mutator]MSP[]
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && index + test . length () - 1 < string . length () ) { MST[MathMutator]MSP[]
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { n ++ ; } else { switch( symb ) { MST[rv.UOI2Mutator]MSP[] case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.UOI3Mutator]MSP[]
if ( ! isPreviousChar ( local , n , 'C' ) ) { code . append ( symb ) ; } } else { code . append ( symb ) ; } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) { MST[rv.UOI3Mutator]MSP[]
if ( ! isPreviousChar ( local , n , 'C' ) ) { code . append ( symb ) ; } } else { code . append ( symb ) ; MST[rv.ABSMutator]MSP[] } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) {
code . append ( 'S' ) ; MST[InlineConstantMutator]MSP[] break; default: break; } n ++ ; } if ( code . length () > this . getMaxCodeLen () ) { code . setLength ( this . getMaxCodeLen () ) ; } } return code . toString () ; }
public String metaphone ( final String txt ) { boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) { MST[rv.CRCR5Mutator]MSP[]
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) && MST[MathMutator]MSP[]
boolean matches = false ; if( index > 0 && MST[NegateConditionalsMutator]MSP[] index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; } return matches ; }
} if ( isPreviousChar ( local , n , 'G' ) ) { MST[rv.CRCR6Mutator]MSP[] hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) &&
if ( ! isLastChar ( wdsz , n ) && isVowel ( local , n + 1 ) ) { MST[rv.ROR4Mutator]MSP[] code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break; case 'Z' :
local . append ( inwd , 1 , inwd . length - 1 ) ; break; } if ( inwd [ 1 ] == 'H' ) { local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.AOR3Mutator]MSP[]
local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; MST[NonVoidMethodCallMutator]MSP[] } break; case 'A' : if ( inwd [ 1 ] == 'E' ) {
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { MST[ArgumentPropagationMutator]MSP[] code . append ( 'J' ) ; n += 2 ;
isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && MST[rv.UOI1Mutator]MSP[] ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 && MST[rv.ROR5Mutator]MSP[] ! hard ) { code . append ( 'J' ) ; } else { code . append ( 'K' ) ; } break; case 'H' :
wdsz >= 3 && isVowel ( local , 2 ) ) { code . append ( 'K' ) ; } else { code . append ( 'X' ) ; MST[experimental.NakedReceiverMutator]MSP[] } } else { code . append ( 'K' ) ; } break; case 'D' :
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; MST[rv.AOR4Mutator]MSP[] } return matches ; }
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { MST[NonVoidMethodCallMutator]MSP[] if ( n == 0 &&
return n + 1 == wdsz ; MST[rv.UOI1Mutator]MSP[] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
return n + 1 == wdsz ; MST[InlineConstantMutator]MSP[] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
final String substring = string . substring ( index , index + test . length () ) ; MST[MathMutator]MSP[] matches = substring . equals ( test ) ; } return matches ; } private boolean isLastChar ( final int wdsz , final int n ) {
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { MST[rv.AOR3Mutator]MSP[] matches = string . charAt ( index + 1 ) == c ;
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { MST[rv.ROR4Mutator]MSP[] break; } if ( regionMatch ( local , n , lr_2 ) ) {
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ; MST[rv.AOD2Mutator]MSP[]
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.ROR5Mutator]MSP[]
FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 && MST[ConditionalsBoundaryMutator]MSP[] ! hard ) { code . append ( 'J' ) ; } else { code . append ( 'K' ) ; } break; case 'H' :
private boolean isVowel ( final StringBuilder string , final int index ) { return VOWELS . indexOf ( string . charAt ( index ) ) >= 0 ; MST[rv.CRCR5Mutator]MSP[] } private boolean isPreviousChar ( final StringBuilder string , final int index , final char c ) {
isNextChar ( local , n , 'H' ) && MST[rv.AOR2Mutator]MSP[] ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[MathMutator]MSP[] break; } if ( inwd [ 1 ] == 'H' ) { local . append ( inwd , 1 , inwd . length - 1 ) ;
isNextChar ( local , n , 'H' ) && MST[RemoveConditionalMutator_EQUAL_IF]MSP[] ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
code . append ( 'F' ) ; } else { code . append ( symb ) ; } break; case 'Q' : code . append ( 'K' ) ; break; case 'S' : if ( regionMatch ( local , n , lr_5 ) || MST[rv.ROR1Mutator]MSP[]
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.CRCR5Mutator]MSP[] isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 &&
isNextChar ( local , n , 'H' ) && MST[InlineConstantMutator]MSP[] ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
if ( ! isLastChar ( wdsz , n ) && isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; MST[rv.CRCR4Mutator]MSP[] break; case 'Z' :
if ( ! isLastChar ( wdsz , n ) && MST[rv.AOR1Mutator]MSP[] isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break; case 'Z' :
if ( isLastChar ( wdsz , n ) ) { MST[rv.UOI1Mutator]MSP[] break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) {
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { MST[rv.UOI3Mutator]MSP[] n ++ ; } else { switch( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 && MST[NonVoidMethodCallMutator]MSP[] ! hard ) { code . append ( 'J' ) ; } else { code . append ( 'K' ) ; } break; case 'H' :
private boolean isVowel ( final StringBuilder string , final int index ) { return VOWELS . indexOf ( string . charAt ( index ) ) >= 0 ; MST[NonVoidMethodCallMutator]MSP[] } private boolean isPreviousChar ( final StringBuilder string , final int index , final char c ) {
wdsz >= 3 && isVowel ( local , 2 ) ) { MST[NegateConditionalsMutator]MSP[] code . append ( 'K' ) ; } else { code . append ( 'X' ) ; } } else { code . append ( 'K' ) ; } break; case 'D' :
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.CRCR6Mutator]MSP[]
regionMatch ( local , n , lr_6 ) || regionMatch ( local , n , lr_7 ) ) { code . append ( 'X' ) ; MST[rv.CRCR2Mutator]MSP[] } else { code . append ( 'S' ) ; } break; case 'T' :
final int wdsz = local . length () ; int n = 0 ; while ( code . length () < this . getMaxCodeLen () && MST[rv.UOI3Mutator]MSP[] n < wdsz ) { final char symb = local . charAt ( n ) ;
if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.CRCR5Mutator]MSP[] isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
return n + 1 == wdsz ; MST[rv.UOI2Mutator]MSP[] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && MST[rv.AOD2Mutator]MSP[] VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) {
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) { MST[rv.ROR3Mutator]MSP[]
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) && MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ; MST[rv.CRCR3Mutator]MSP[]
isNextChar ( local , n , 'H' ) && MST[rv.CRCR3Mutator]MSP[] ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { MST[rv.CRCR3Mutator]MSP[] n ++ ; } else { switch( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
public String metaphone ( final String txt ) { boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { MST[rv.ROR2Mutator]MSP[] return lr_1 ; } if ( txtLength == 1 ) {
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 && MST[rv.CRCR2Mutator]MSP[]
FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 && ! hard ) { code . append ( 'J' ) ; MST[rv.CRCR1Mutator]MSP[] } else { code . append ( 'K' ) ; } break; case 'H' :
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && MST[rv.AOR1Mutator]MSP[] FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && index + test . length () - 1 < string . length () ) { MST[rv.AOR2Mutator]MSP[]
return txt . toUpperCase ( java . util . Locale . ENGLISH ) ; } final char [] inwd = txt . toUpperCase ( java . util . Locale . ENGLISH ) . toCharArray () ; MST[NonVoidMethodCallMutator]MSP[] final StringBuilder local = new StringBuilder ( 40 ) ;
if ( ! isLastChar ( wdsz , n ) && MST[rv.CRCR2Mutator]MSP[] isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break; case 'Z' :
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.ROR4Mutator]MSP[] ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && MST[rv.ROR1Mutator]MSP[] VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) {
isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { MST[rv.ROR3Mutator]MSP[] break;
if ( regionMatch ( local , n , lr_8 ) || regionMatch ( local , n , lr_9 ) ) { code . append ( 'X' ) ; break; } if ( regionMatch ( local , n , lr_10 ) ) { MST[rv.ROR3Mutator]MSP[] break; }
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; MST[rv.ROR3Mutator]MSP[] } return matches ; }
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { MST[NegateConditionalsMutator]MSP[] n ++ ; } else { switch( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.UOI1Mutator]MSP[] ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && MST[NegateConditionalsMutator]MSP[] isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
code . append ( 'F' ) ; } else { code . append ( symb ) ; } break; case 'Q' : code . append ( 'K' ) ; break; case 'S' : if ( regionMatch ( local , n , lr_5 ) || MST[rv.ABSMutator]MSP[]
regionMatch ( local , n , lr_6 ) || MST[NegateConditionalsMutator]MSP[] regionMatch ( local , n , lr_7 ) ) { code . append ( 'X' ) ; } else { code . append ( 'S' ) ; } break; case 'T' :
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.CRCR5Mutator]MSP[] } else { local . append ( inwd ) ; } break; case 'A' : if ( inwd [ 1 ] == 'E' ) {
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.UOI3Mutator]MSP[] ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.CRCR4Mutator]MSP[] } else { local . append ( inwd ) ; } break; case 'A' : if ( inwd [ 1 ] == 'E' ) {
final StringBuilder code = new StringBuilder ( 10 ) ; switch( inwd [ 0 ] ) { case 'K' : case 'G' : case 'P' : if ( inwd [ 1 ] == 'N' ) { MST[rv.CRCR2Mutator]MSP[]
final int wdsz = local . length () ; int n = 0 ; while ( code . length () < this . getMaxCodeLen () && MST[NonVoidMethodCallMutator]MSP[] n < wdsz ) { final char symb = local . charAt ( n ) ;
code . append ( 'S' ) ; MST[rv.CRCR1Mutator]MSP[] break; default: break; } n ++ ; } if ( code . length () > this . getMaxCodeLen () ) { code . setLength ( this . getMaxCodeLen () ) ; } } return code . toString () ; }
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && MST[rv.ROR1Mutator]MSP[] FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.CRCR5Mutator]MSP[] break; } if ( inwd [ 1 ] == 'H' ) { local . append ( inwd , 1 , inwd . length - 1 ) ;
code . append ( 'S' ) ; break; default: break; } n ++ ; } if ( code . length () > this . getMaxCodeLen () ) { MST[rv.ROR2Mutator]MSP[] code . setLength ( this . getMaxCodeLen () ) ; } } return code . toString () ; }
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { MST[NonVoidMethodCallMutator]MSP[] code . append ( 'J' ) ; n += 2 ;
final StringBuilder code = new StringBuilder ( 10 ) ; MST[rv.CRCR5Mutator]MSP[] switch( inwd [ 0 ] ) { case 'K' : case 'G' : case 'P' : if ( inwd [ 1 ] == 'N' ) {
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ; MST[rv.UOI1Mutator]MSP[]
code . append ( symb ) ; } break; case 'B' : if ( isPreviousChar ( local , n , 'M' ) && isLastChar ( wdsz , n ) ) { MST[rv.ROR1Mutator]MSP[] break; } code . append ( symb ) ; break; case 'C' :
code . append ( 'H' ) ; MST[rv.CRCR2Mutator]MSP[] } break; case 'F' : case 'J' : case 'L' : case 'M' : case 'N' : case 'R' : code . append ( symb ) ; break; case 'K' : if ( n > 0 ) {
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.CRCR1Mutator]MSP[] ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && MST[rv.ROR2Mutator]MSP[] index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ;
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.AOD2Mutator]MSP[] } else { local . append ( inwd ) ; } break; case 'A' : if ( inwd [ 1 ] == 'E' ) {
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && MST[rv.UOI3Mutator]MSP[] VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) {
public String metaphone ( final String txt ) { boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { MST[NegateConditionalsMutator]MSP[] return lr_1 ; } if ( txtLength == 1 ) {
final String substring = string . substring ( index , index + test . length () ) ; matches = substring . equals ( test ) ; } return matches ; MST[BooleanTrueReturnValsMutator]MSP[] } private boolean isLastChar ( final int wdsz , final int n ) {
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && MST[rv.ROR4Mutator]MSP[] VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) {
FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 && ! hard ) { code . append ( 'J' ) ; } else { code . append ( 'K' ) ; MST[rv.CRCR6Mutator]MSP[] } break; case 'H' :
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.UOI3Mutator]MSP[] isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 &&
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ; MST[rv.UOI4Mutator]MSP[]
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[InlineConstantMutator]MSP[] } else { local . append ( inwd ) ; } break; case 'A' : if ( inwd [ 1 ] == 'E' ) {
private boolean isVowel ( final StringBuilder string , final int index ) { return VOWELS . indexOf ( string . charAt ( index ) ) >= 0 ; MST[rv.ROR5Mutator]MSP[] } private boolean isPreviousChar ( final StringBuilder string , final int index , final char c ) {
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.CRCR6Mutator]MSP[]
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.CRCR5Mutator]MSP[] isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 &&
if ( regionMatch ( local , n , lr_8 ) || regionMatch ( local , n , lr_9 ) ) { MST[rv.ROR1Mutator]MSP[] code . append ( 'X' ) ; break; } if ( regionMatch ( local , n , lr_10 ) ) { break; }
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { MST[rv.UOI1Mutator]MSP[] n ++ ; } else { switch( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
public String metaphone ( final String txt ) { MST[rv.ROR3Mutator]MSP[] boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) {
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.CRCR4Mutator]MSP[]
local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break; case 'A' : if ( inwd [ 1 ] == 'E' ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
final int wdsz = local . length () ; int n = 0 ; while ( code . length () < this . getMaxCodeLen () && MST[ConditionalsBoundaryMutator]MSP[] n < wdsz ) { final char symb = local . charAt ( n ) ;
public String metaphone ( final String txt ) { boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { MST[rv.ROR5Mutator]MSP[] return lr_1 ; } if ( txtLength == 1 ) {
if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.CRCR3Mutator]MSP[] isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
public String metaphone ( final String txt ) { MST[rv.UOI3Mutator]MSP[] boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) {
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && MST[rv.UOI4Mutator]MSP[] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; break; }
if ( ! isPreviousChar ( local , n , 'C' ) ) { code . append ( symb ) ; } } else { code . append ( symb ) ; } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) { MST[rv.CRCR6Mutator]MSP[]
if ( regionMatch ( local , n , lr_8 ) || MST[rv.UOI1Mutator]MSP[] regionMatch ( local , n , lr_9 ) ) { code . append ( 'X' ) ; break; } if ( regionMatch ( local , n , lr_10 ) ) { break; }
isNextChar ( local , n , 'H' ) && MST[rv.UOI1Mutator]MSP[] ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; MST[rv.CRCR4Mutator]MSP[] } return matches ; }
public String metaphone ( final String txt ) { MST[NonVoidMethodCallMutator]MSP[] boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) {
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { MST[rv.CRCR1Mutator]MSP[] n ++ ; } else { switch( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.UOI3Mutator]MSP[] isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
} if ( isPreviousChar ( local , n , 'G' ) ) { hard = true ; } else { hard = false ; MST[InlineConstantMutator]MSP[] } if ( ! isLastChar ( wdsz , n ) &&
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && index + test . length () - 1 < string . length () ) { MST[rv.AOR2Mutator]MSP[]
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.CRCR6Mutator]MSP[] } else { local . append ( inwd ) ; } break; case 'W' : if ( inwd [ 1 ] == 'R' ) {
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; MST[rv.UOI4Mutator]MSP[] } return matches ; }
if ( ! isPreviousChar ( local , n , 'C' ) ) { code . append ( symb ) ; MST[rv.UOI1Mutator]MSP[] } } else { code . append ( symb ) ; } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) {
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; MST[InlineConstantMutator]MSP[] } return matches ; }
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.CRCR3Mutator]MSP[] } else { local . append ( inwd ) ; } break; case 'A' : if ( inwd [ 1 ] == 'E' ) {
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[MathMutator]MSP[] } else { local . append ( inwd ) ; } break; case 'A' : if ( inwd [ 1 ] == 'E' ) {
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.CRCR2Mutator]MSP[] } else { local . append ( inwd ) ; } break; case 'A' : if ( inwd [ 1 ] == 'E' ) {
code . append ( symb ) ; } break; case 'B' : if ( isPreviousChar ( local , n , 'M' ) && isLastChar ( wdsz , n ) ) { break; } code . append ( symb ) ; MST[NonVoidMethodCallMutator]MSP[] break; case 'C' :
if ( regionMatch ( local , n , lr_8 ) || MST[rv.UOI3Mutator]MSP[] regionMatch ( local , n , lr_9 ) ) { code . append ( 'X' ) ; break; } if ( regionMatch ( local , n , lr_10 ) ) { break; }
boolean matches = false ; if( index > 0 && MST[rv.UOI1Mutator]MSP[] index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; } return matches ; }
if ( ! isLastChar ( wdsz , n ) && MST[rv.ROR1Mutator]MSP[] isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break; case 'Z' :
FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 && MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] ! hard ) { code . append ( 'J' ) ; } else { code . append ( 'K' ) ; } break; case 'H' :
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) { MST[rv.ROR1Mutator]MSP[]
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && MST[rv.AOR2Mutator]MSP[] isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
isNextChar ( local , n , 'H' ) && MST[rv.ROR2Mutator]MSP[] ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
local . setCharAt ( 0 , 'W' ) ; } else { local . append ( inwd ) ; } break; case 'X' : inwd [ 0 ] = 'S' ; MST[rv.CRCR2Mutator]MSP[] local . append ( inwd ) ; break; default: local . append ( inwd ) ; }
final int wdsz = local . length () ; int n = 0 ; while ( code . length () < this . getMaxCodeLen () && MST[rv.UOI2Mutator]MSP[] n < wdsz ) { final char symb = local . charAt ( n ) ;
if ( ! isPreviousChar ( local , n , 'C' ) ) { MST[rv.UOI3Mutator]MSP[] code . append ( symb ) ; } } else { code . append ( symb ) ; } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) {
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] n ++ ; } else { switch( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
if ( isLastChar ( wdsz , n ) ) { MST[rv.UOI4Mutator]MSP[] break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) {
code . append ( 'F' ) ; } else { code . append ( symb ) ; MST[rv.UOI1Mutator]MSP[] } break; case 'Q' : code . append ( 'K' ) ; break; case 'S' : if ( regionMatch ( local , n , lr_5 ) ||
regionMatch ( local , n , lr_6 ) || regionMatch ( local , n , lr_7 ) ) { code . append ( 'X' ) ; } else { code . append ( 'S' ) ; MST[NonVoidMethodCallMutator]MSP[] } break; case 'T' :
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { MST[rv.AOR4Mutator]MSP[] matches = string . charAt ( index + 1 ) == c ;
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { MST[ArgumentPropagationMutator]MSP[] break; } if ( isVowel ( local , n + 1 ) ) {
wdsz >= 3 && isVowel ( local , 2 ) ) { code . append ( 'K' ) ; } else { code . append ( 'X' ) ; MST[rv.CRCR1Mutator]MSP[] } } else { code . append ( 'K' ) ; } break; case 'D' :
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { MST[rv.ROR3Mutator]MSP[] code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 &&
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.CRCR2Mutator]MSP[] } else { local . append ( inwd ) ; } break; case 'W' : if ( inwd [ 1 ] == 'R' ) {
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.CRCR5Mutator]MSP[] } else { local . append ( inwd ) ; } break; case 'W' : if ( inwd [ 1 ] == 'R' ) {
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { MST[rv.ROR3Mutator]MSP[] break; } if ( isVowel ( local , n + 1 ) ) {
public String metaphone ( final String txt ) { MST[rv.CRCR3Mutator]MSP[] boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) {
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { MST[rv.ROR5Mutator]MSP[] break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
regionMatch ( local , n , lr_6 ) || regionMatch ( local , n , lr_7 ) ) { MST[rv.ROR5Mutator]MSP[] code . append ( 'X' ) ; } else { code . append ( 'S' ) ; } break; case 'T' :
return txt . toUpperCase ( java . util . Locale . ENGLISH ) ; } final char [] inwd = txt . toUpperCase ( java . util . Locale . ENGLISH ) . toCharArray () ; final StringBuilder local = new StringBuilder ( 40 ) ; MST[ConstructorCallMutator]MSP[]
local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break; case 'W' : if ( inwd [ 1 ] == 'R' ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
private boolean isVowel ( final StringBuilder string , final int index ) { return VOWELS . indexOf ( string . charAt ( index ) ) >= 0 ; MST[rv.UOI4Mutator]MSP[] } private boolean isPreviousChar ( final StringBuilder string , final int index , final char c ) {
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { MST[NonVoidMethodCallMutator]MSP[] code . append ( 'S' ) ; break; }
public String metaphone ( final String txt ) { boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) { MST[rv.CRCR6Mutator]MSP[]
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; } return matches ; MST[rv.UOI4Mutator]MSP[] }
local . setCharAt ( 0 , 'W' ) ; } else { local . append ( inwd ) ; MST[NonVoidMethodCallMutator]MSP[] } break; case 'X' : inwd [ 0 ] = 'S' ; local . append ( inwd ) ; break; default: local . append ( inwd ) ; }
wdsz >= 3 && isVowel ( local , 2 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] code . append ( 'K' ) ; } else { code . append ( 'X' ) ; } } else { code . append ( 'K' ) ; } break; case 'D' :
isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && MST[rv.ROR2Mutator]MSP[] ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; MST[rv.ROR2Mutator]MSP[] } return matches ; }
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && MST[rv.AOR3Mutator]MSP[] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; break; }
if ( regionMatch ( local , n , lr_11 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] code . append ( '0' ) ; } else { code . append ( 'T' ) ; } break; case 'V' : code . append ( 'F' ) ; break; case 'W' : case 'Y' :
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
regionMatch ( local , n , lr_6 ) || MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] regionMatch ( local , n , lr_7 ) ) { code . append ( 'X' ) ; } else { code . append ( 'S' ) ; } break; case 'T' :
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; MST[InlineConstantMutator]MSP[] break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 &&
isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && MST[rv.UOI1Mutator]MSP[] ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.CRCR2Mutator]MSP[] isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
} if ( isPreviousChar ( local , n , 'G' ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) &&
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ; MST[rv.ROR2Mutator]MSP[]
if ( regionMatch ( local , n , lr_11 ) ) { code . append ( '0' ) ; } else { code . append ( 'T' ) ; MST[rv.CRCR3Mutator]MSP[] } break; case 'V' : code . append ( 'F' ) ; break; case 'W' : case 'Y' :
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && MST[rv.ROR1Mutator]MSP[] index + test . length () - 1 < string . length () ) {
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 && MST[rv.UOI3Mutator]MSP[]
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { MST[ConditionalsBoundaryMutator]MSP[] code . append ( 'S' ) ; break; }
if ( regionMatch ( local , n , lr_11 ) ) { code . append ( '0' ) ; } else { code . append ( 'T' ) ; MST[rv.CRCR6Mutator]MSP[] } break; case 'V' : code . append ( 'F' ) ; break; case 'W' : case 'Y' :
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { MST[rv.CRCR3Mutator]MSP[] matches = string . charAt ( index + 1 ) == c ;
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.CRCR3Mutator]MSP[] } else { local . append ( inwd ) ; } break; case 'W' : if ( inwd [ 1 ] == 'R' ) {
isNextChar ( local , n , 'H' ) && MST[NegateConditionalsMutator]MSP[] ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
return n + 1 == wdsz ; MST[rv.CRCR1Mutator]MSP[] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
return txt . toUpperCase ( java . util . Locale . ENGLISH ) ; } final char [] inwd = txt . toUpperCase ( java . util . Locale . ENGLISH ) . toCharArray () ; final StringBuilder local = new StringBuilder ( 40 ) ; MST[rv.CRCR4Mutator]MSP[]
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ; MST[InlineConstantMutator]MSP[]
} if ( isPreviousChar ( local , n , 'G' ) ) { hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) && MST[rv.UOI3Mutator]MSP[]
} else { code . append ( 'T' ) ; MST[rv.CRCR2Mutator]MSP[] } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && MST[rv.ROR5Mutator]MSP[] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
public String metaphone ( final String txt ) { boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) { MST[rv.CRCR3Mutator]MSP[]
wdsz >= 3 && isVowel ( local , 2 ) ) { code . append ( 'K' ) ; MST[NonVoidMethodCallMutator]MSP[] } else { code . append ( 'X' ) ; } } else { code . append ( 'K' ) ; } break; case 'D' :
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { MST[NonVoidMethodCallMutator]MSP[] n ++ ; } else { switch( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && MST[rv.UOI4Mutator]MSP[] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
final String substring = string . substring ( index , index + test . length () ) ; matches = substring . equals ( test ) ; MST[NonVoidMethodCallMutator]MSP[] } return matches ; } private boolean isLastChar ( final int wdsz , final int n ) {
return n + 1 == wdsz ; } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; MST[NonVoidMethodCallMutator]MSP[] } @Override
private boolean isVowel ( final StringBuilder string , final int index ) { return VOWELS . indexOf ( string . charAt ( index ) ) >= 0 ; MST[NegateConditionalsMutator]MSP[] } private boolean isPreviousChar ( final StringBuilder string , final int index , final char c ) {
} if ( isPreviousChar ( local , n , 'G' ) ) { MST[rv.CRCR4Mutator]MSP[] hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) &&
if ( ! isLastChar ( wdsz , n ) && isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; MST[InlineConstantMutator]MSP[] break; case 'Z' :
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && MST[rv.ROR4Mutator]MSP[] index + test . length () - 1 < string . length () ) {
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { MST[MathMutator]MSP[] matches = string . charAt ( index + 1 ) == c ;
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && MST[RemoveConditionalMutator_ORDER_IF]MSP[] index + test . length () - 1 < string . length () ) {
} return matches ; MST[rv.UOI4Mutator]MSP[] } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && index + test . length () - 1 < string . length () ) {
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.AOD2Mutator]MSP[]
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { MST[rv.ROR2Mutator]MSP[] if ( n == 0 &&
FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 && MST[rv.ROR3Mutator]MSP[] ! hard ) { code . append ( 'J' ) ; } else { code . append ( 'K' ) ; } break; case 'H' :
} if ( isPreviousChar ( local , n , 'G' ) ) { hard = true ; } else { hard = false ; MST[rv.CRCR5Mutator]MSP[] } if ( ! isLastChar ( wdsz , n ) &&
} if ( isPreviousChar ( local , n , 'G' ) ) { hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) && MST[rv.ABSMutator]MSP[]
isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { MST[NegateConditionalsMutator]MSP[] break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
code . append ( 'S' ) ; MST[rv.CRCR4Mutator]MSP[] break; default: break; } n ++ ; } if ( code . length () > this . getMaxCodeLen () ) { code . setLength ( this . getMaxCodeLen () ) ; } } return code . toString () ; }
if ( ! isLastChar ( wdsz , n ) && isVowel ( local , n + 1 ) ) { code . append ( symb ) ; MST[rv.UOI2Mutator]MSP[] } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break; case 'Z' :
final String substring = string . substring ( index , index + test . length () ) ; MST[rv.UOI4Mutator]MSP[] matches = substring . equals ( test ) ; } return matches ; } private boolean isLastChar ( final int wdsz , final int n ) {
code . append ( symb ) ; } break; case 'B' : if ( isPreviousChar ( local , n , 'M' ) && isLastChar ( wdsz , n ) ) { MST[rv.ROR4Mutator]MSP[] break; } code . append ( symb ) ; break; case 'C' :
if ( regionMatch ( local , n , lr_8 ) || regionMatch ( local , n , lr_9 ) ) { code . append ( 'X' ) ; break; } if ( regionMatch ( local , n , lr_10 ) ) { MST[rv.UOI3Mutator]MSP[] break; }
private boolean isVowel ( final StringBuilder string , final int index ) { return VOWELS . indexOf ( string . charAt ( index ) ) >= 0 ; MST[ReturnValsMutator]MSP[] } private boolean isPreviousChar ( final StringBuilder string , final int index , final char c ) {
FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 && MST[RemoveConditionalMutator_EQUAL_IF]MSP[] ! hard ) { code . append ( 'J' ) ; } else { code . append ( 'K' ) ; } break; case 'H' :
if ( regionMatch ( local , n , lr_11 ) ) { MST[NonVoidMethodCallMutator]MSP[] code . append ( '0' ) ; } else { code . append ( 'T' ) ; } break; case 'V' : code . append ( 'F' ) ; break; case 'W' : case 'Y' :
local . append ( inwd , 1 , inwd . length - 1 ) ; break; } if ( inwd [ 1 ] == 'H' ) { MST[rv.CRCR6Mutator]MSP[] local . append ( inwd , 1 , inwd . length - 1 ) ;
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && MST[rv.ROR4Mutator]MSP[] FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
code . append ( 'H' ) ; MST[rv.CRCR5Mutator]MSP[] } break; case 'F' : case 'J' : case 'L' : case 'M' : case 'N' : case 'R' : code . append ( symb ) ; break; case 'K' : if ( n > 0 ) {
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && MST[rv.ROR5Mutator]MSP[] index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ;
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && MST[rv.UOI3Mutator]MSP[] VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) {
} else { code . append ( 'T' ) ; MST[rv.CRCR5Mutator]MSP[] } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
} if ( isPreviousChar ( local , n , 'G' ) ) { MST[NonVoidMethodCallMutator]MSP[] hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) &&
local . append ( inwd , 1 , inwd . length - 1 ) ; break; } if ( inwd [ 1 ] == 'H' ) { local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.CRCR2Mutator]MSP[]
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && MST[rv.UOI4Mutator]MSP[] index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ;
local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break; case 'A' : if ( inwd [ 1 ] == 'E' ) { MST[rv.CRCR3Mutator]MSP[]
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { MST[rv.ROR3Mutator]MSP[] n ++ ; } else { switch( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
local . setCharAt ( 0 , 'W' ) ; MST[rv.CRCR6Mutator]MSP[] } else { local . append ( inwd ) ; } break; case 'X' : inwd [ 0 ] = 'S' ; local . append ( inwd ) ; break; default: local . append ( inwd ) ; }
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.CRCR4Mutator]MSP[] ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { n ++ ; } else { switch( symb ) { MST[rv.ABSMutator]MSP[] case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
if ( ! isPreviousChar ( local , n , 'C' ) ) { MST[rv.CRCR3Mutator]MSP[] code . append ( symb ) ; } } else { code . append ( symb ) ; } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) {
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && MST[MathMutator]MSP[] VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) {
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ; MST[rv.AOR2Mutator]MSP[]
code . append ( 'H' ) ; } break; case 'F' : case 'J' : case 'L' : case 'M' : case 'N' : case 'R' : code . append ( symb ) ; break; case 'K' : if ( n > 0 ) { MST[rv.ROR2Mutator]MSP[]
boolean matches = false ; if( index > 0 && MST[rv.UOI4Mutator]MSP[] index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; } return matches ; }
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ; MST[rv.UOI4Mutator]MSP[]
code . append ( 'S' ) ; break; default: break; } n ++ ; } if ( code . length () > this . getMaxCodeLen () ) { MST[rv.ROR5Mutator]MSP[] code . setLength ( this . getMaxCodeLen () ) ; } } return code . toString () ; }
return txt . toUpperCase ( java . util . Locale . ENGLISH ) ; MST[EmptyObjectReturnValsMutator]MSP[] } final char [] inwd = txt . toUpperCase ( java . util . Locale . ENGLISH ) . toCharArray () ; final StringBuilder local = new StringBuilder ( 40 ) ;
code . append ( 'H' ) ; } break; case 'F' : case 'J' : case 'L' : case 'M' : case 'N' : case 'R' : code . append ( symb ) ; break; case 'K' : if ( n > 0 ) { MST[rv.UOI1Mutator]MSP[]
final StringBuilder code = new StringBuilder ( 10 ) ; switch( inwd [ 0 ] ) { case 'K' : case 'G' : case 'P' : if ( inwd [ 1 ] == 'N' ) { MST[rv.CRCR5Mutator]MSP[]
local . append ( inwd , 1 , inwd . length - 1 ) ; break; } if ( inwd [ 1 ] == 'H' ) { local . append ( inwd , 1 , inwd . length - 1 ) ; MST[InlineConstantMutator]MSP[]
FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 && MST[rv.UOI2Mutator]MSP[] ! hard ) { code . append ( 'J' ) ; } else { code . append ( 'K' ) ; } break; case 'H' :
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { MST[rv.CRCR6Mutator]MSP[] matches = string . charAt ( index + 1 ) == c ;
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.AOD2Mutator]MSP[] break; } if ( inwd [ 1 ] == 'H' ) { local . append ( inwd , 1 , inwd . length - 1 ) ;
isNextChar ( local , n , 'H' ) && MST[rv.CRCR1Mutator]MSP[] ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.ABSMutator]MSP[] isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { n ++ ; } else { switch( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) { MST[rv.ROR2Mutator]MSP[]
boolean matches = false ; MST[rv.CRCR3Mutator]MSP[] if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; } return matches ; }
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 && MST[ConditionalsBoundaryMutator]MSP[]
local . setCharAt ( 0 , 'W' ) ; } else { local . append ( inwd ) ; } break; case 'X' : inwd [ 0 ] = 'S' ; local . append ( inwd ) ; MST[experimental.NakedReceiverMutator]MSP[] break; default: local . append ( inwd ) ; }
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && MST[rv.AOR3Mutator]MSP[] FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { n ++ ; } else { switch( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) { MST[rv.UOI1Mutator]MSP[]
if ( regionMatch ( local , n , lr_8 ) || regionMatch ( local , n , lr_9 ) ) { code . append ( 'X' ) ; MST[rv.CRCR6Mutator]MSP[] break; } if ( regionMatch ( local , n , lr_10 ) ) { break; }
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; MST[rv.ROR5Mutator]MSP[] } return matches ; }
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && MST[rv.ROR1Mutator]MSP[] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; break; }
local . setCharAt ( 0 , 'W' ) ; } else { local . append ( inwd ) ; } break; case 'X' : inwd [ 0 ] = 'S' ; MST[rv.CRCR6Mutator]MSP[] local . append ( inwd ) ; break; default: local . append ( inwd ) ; }
local . setCharAt ( 0 , 'W' ) ; } else { local . append ( inwd ) ; } break; case 'X' : inwd [ 0 ] = 'S' ; MST[rv.CRCR5Mutator]MSP[] local . append ( inwd ) ; break; default: local . append ( inwd ) ; }
if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.CRCR5Mutator]MSP[] isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && MST[rv.ROR5Mutator]MSP[] ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
public String metaphone ( final String txt ) { boolean hard = false ; MST[rv.CRCR6Mutator]MSP[] int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) {
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { MST[rv.ROR3Mutator]MSP[] code . append ( 'S' ) ; break; }
boolean matches = false ; if( index > 0 && index < string . length () ) { MST[rv.ROR2Mutator]MSP[] matches = string . charAt ( index - 1 ) == c ; } return matches ; }
if ( regionMatch ( local , n , lr_8 ) || regionMatch ( local , n , lr_9 ) ) { MST[rv.ROR4Mutator]MSP[] code . append ( 'X' ) ; break; } if ( regionMatch ( local , n , lr_10 ) ) { break; }
private boolean isVowel ( final StringBuilder string , final int index ) { return VOWELS . indexOf ( string . charAt ( index ) ) >= 0 ; MST[rv.CRCR2Mutator]MSP[] } private boolean isPreviousChar ( final StringBuilder string , final int index , final char c ) {
if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.AOD1Mutator]MSP[] isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
public String metaphone ( final String txt ) { boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
if ( ! isLastChar ( wdsz , n ) && MST[rv.UOI3Mutator]MSP[] isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break; case 'Z' :
isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && MST[rv.UOI4Mutator]MSP[] ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ; MST[rv.CRCR4Mutator]MSP[]
wdsz >= 3 && isVowel ( local , 2 ) ) { code . append ( 'K' ) ; } else { code . append ( 'X' ) ; } } else { code . append ( 'K' ) ; MST[experimental.NakedReceiverMutator]MSP[] } break; case 'D' :
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && MST[RemoveConditionalMutator_ORDER_IF]MSP[] VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) {
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { MST[rv.ROR3Mutator]MSP[] code . append ( 'J' ) ; n += 2 ;
return n + 1 == wdsz ; MST[rv.UOI4Mutator]MSP[] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
isNextChar ( local , n , 'H' ) && MST[rv.ROR5Mutator]MSP[] ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
} if ( isPreviousChar ( local , n , 'G' ) ) { hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) && MST[rv.UOI2Mutator]MSP[]
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; MST[InlineConstantMutator]MSP[] } return matches ; }
final String substring = string . substring ( index , index + test . length () ) ; MST[rv.AOR3Mutator]MSP[] matches = substring . equals ( test ) ; } return matches ; } private boolean isLastChar ( final int wdsz , final int n ) {
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { MST[rv.ROR1Mutator]MSP[] n ++ ; } else { switch( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && MST[rv.ROR1Mutator]MSP[] isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
regionMatch ( local , n , lr_6 ) || MST[rv.ROR1Mutator]MSP[] regionMatch ( local , n , lr_7 ) ) { code . append ( 'X' ) ; } else { code . append ( 'S' ) ; } break; case 'T' :
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.ABSMutator]MSP[] isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 &&
wdsz >= 3 && isVowel ( local , 2 ) ) { code . append ( 'K' ) ; } else { code . append ( 'X' ) ; MST[rv.CRCR4Mutator]MSP[] } } else { code . append ( 'K' ) ; } break; case 'D' :
local . append ( inwd , 1 , inwd . length - 1 ) ; break; } if ( inwd [ 1 ] == 'H' ) { MST[rv.CRCR4Mutator]MSP[] local . append ( inwd , 1 , inwd . length - 1 ) ;
isNextChar ( local , n , 'H' ) && MST[rv.AOR4Mutator]MSP[] ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
public String metaphone ( final String txt ) { boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) { MST[rv.ROR3Mutator]MSP[]
wdsz >= 3 && isVowel ( local , 2 ) ) { MST[rv.ROR1Mutator]MSP[] code . append ( 'K' ) ; } else { code . append ( 'X' ) ; } } else { code . append ( 'K' ) ; } break; case 'D' :
if ( regionMatch ( local , n , lr_8 ) || MST[rv.UOI4Mutator]MSP[] regionMatch ( local , n , lr_9 ) ) { code . append ( 'X' ) ; break; } if ( regionMatch ( local , n , lr_10 ) ) { break; }
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.CRCR3Mutator]MSP[] isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 &&
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.AOD2Mutator]MSP[] } else { local . append ( inwd ) ; } break; case 'W' : if ( inwd [ 1 ] == 'R' ) {
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && MST[NegateConditionalsMutator]MSP[] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
if ( ! isLastChar ( wdsz , n ) && MST[rv.AOR3Mutator]MSP[] isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break; case 'Z' :
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.UOI4Mutator]MSP[] ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
if ( ! isLastChar ( wdsz , n ) && MST[rv.ROR4Mutator]MSP[] isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break; case 'Z' :
if ( ! isLastChar ( wdsz , n ) && isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; MST[rv.CRCR2Mutator]MSP[] break; case 'Z' :
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; MST[rv.CRCR2Mutator]MSP[] break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 &&
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.CRCR6Mutator]MSP[] break; } if ( inwd [ 1 ] == 'H' ) { local . append ( inwd , 1 , inwd . length - 1 ) ;
final String substring = string . substring ( index , index + test . length () ) ; MST[rv.UOI3Mutator]MSP[] matches = substring . equals ( test ) ; } return matches ; } private boolean isLastChar ( final int wdsz , final int n ) {
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ; MST[InlineConstantMutator]MSP[]
} if ( isPreviousChar ( local , n , 'G' ) ) { hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) && MST[rv.CRCR5Mutator]MSP[]
code . append ( 'F' ) ; } else { code . append ( symb ) ; } break; case 'Q' : code . append ( 'K' ) ; break; case 'S' : if ( regionMatch ( local , n , lr_5 ) || MST[rv.UOI3Mutator]MSP[]
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) { MST[rv.CRCR4Mutator]MSP[]
if ( ! isPreviousChar ( local , n , 'C' ) ) { code . append ( symb ) ; MST[rv.UOI4Mutator]MSP[] } } else { code . append ( symb ) ; } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) {
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { MST[rv.CRCR6Mutator]MSP[] if ( n == 0 &&
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 && MST[rv.UOI1Mutator]MSP[]
} if ( isPreviousChar ( local , n , 'G' ) ) { hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) && MST[rv.AOD1Mutator]MSP[]
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 && MST[rv.CRCR3Mutator]MSP[]
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; break; }
code . append ( 'F' ) ; } else { code . append ( symb ) ; } break; case 'Q' : code . append ( 'K' ) ; MST[rv.CRCR4Mutator]MSP[] break; case 'S' : if ( regionMatch ( local , n , lr_5 ) ||
if ( regionMatch ( local , n , lr_11 ) ) { code . append ( '0' ) ; } else { code . append ( 'T' ) ; } break; case 'V' : code . append ( 'F' ) ; break; MST[rv.CRCR5Mutator]MSP[] case 'W' : case 'Y' :
return n + 1 == wdsz ; MST[rv.AOD1Mutator]MSP[] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { MST[NegateConditionalsMutator]MSP[] break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
regionMatch ( local , n , lr_6 ) || regionMatch ( local , n , lr_7 ) ) { MST[NegateConditionalsMutator]MSP[] code . append ( 'X' ) ; } else { code . append ( 'S' ) ; } break; case 'T' :
final int wdsz = local . length () ; int n = 0 ; while ( code . length () < this . getMaxCodeLen () && MST[rv.ROR2Mutator]MSP[] n < wdsz ) { final char symb = local . charAt ( n ) ;
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] n ++ ; } else { switch( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
code . append ( 'F' ) ; } else { code . append ( symb ) ; } break; case 'Q' : code . append ( 'K' ) ; break; case 'S' : if ( regionMatch ( local , n , lr_5 ) || MST[rv.ROR4Mutator]MSP[]
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && MST[rv.UOI3Mutator]MSP[] isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
final int wdsz = local . length () ; int n = 0 ; while ( code . length () < this . getMaxCodeLen () && MST[rv.ROR3Mutator]MSP[] n < wdsz ) { final char symb = local . charAt ( n ) ;
code . append ( 'F' ) ; } else { code . append ( symb ) ; } break; case 'Q' : code . append ( 'K' ) ; break; case 'S' : if ( regionMatch ( local , n , lr_5 ) || MST[rv.UOI1Mutator]MSP[]
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && MST[rv.CRCR4Mutator]MSP[] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; MST[rv.AOR2Mutator]MSP[] } return matches ; }
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && MST[rv.UOI3Mutator]MSP[] index + test . length () - 1 < string . length () ) {
local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break; case 'W' : if ( inwd [ 1 ] == 'R' ) { MST[rv.CRCR3Mutator]MSP[]
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { MST[rv.UOI4Mutator]MSP[] n ++ ; } else { switch( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
code . append ( 'H' ) ; } break; case 'F' : case 'J' : case 'L' : case 'M' : case 'N' : case 'R' : code . append ( symb ) ; break; case 'K' : if ( n > 0 ) { MST[rv.UOI4Mutator]MSP[]
code . append ( 'S' ) ; break; default: break; } n ++ ; } if ( code . length () > this . getMaxCodeLen () ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] code . setLength ( this . getMaxCodeLen () ) ; } } return code . toString () ; }
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { MST[rv.ROR5Mutator]MSP[] if ( n == 0 &&
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && index + test . length () - 1 < string . length () ) { MST[rv.ROR5Mutator]MSP[]
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 && MST[rv.ROR2Mutator]MSP[]
final String substring = string . substring ( index , index + test . length () ) ; matches = substring . equals ( test ) ; } return matches ; MST[rv.UOI1Mutator]MSP[] } private boolean isLastChar ( final int wdsz , final int n ) {
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && MST[rv.AOR3Mutator]MSP[] VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) {
code . append ( symb ) ; } break; case 'B' : if ( isPreviousChar ( local , n , 'M' ) && isLastChar ( wdsz , n ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] break; } code . append ( symb ) ; break; case 'C' :
local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break; case 'A' : if ( inwd [ 1 ] == 'E' ) { MST[rv.CRCR6Mutator]MSP[]
isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { MST[NonVoidMethodCallMutator]MSP[] break;
if ( regionMatch ( local , n , lr_8 ) || regionMatch ( local , n , lr_9 ) ) { code . append ( 'X' ) ; break; } if ( regionMatch ( local , n , lr_10 ) ) { MST[NonVoidMethodCallMutator]MSP[] break; }
if ( ! isLastChar ( wdsz , n ) && MST[rv.CRCR3Mutator]MSP[] isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break; case 'Z' :
if ( regionMatch ( local , n , lr_8 ) || regionMatch ( local , n , lr_9 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] code . append ( 'X' ) ; break; } if ( regionMatch ( local , n , lr_10 ) ) { break; }
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ; MST[InlineConstantMutator]MSP[]
final int wdsz = local . length () ; int n = 0 ; while ( code . length () < this . getMaxCodeLen () && MST[rv.ROR5Mutator]MSP[] n < wdsz ) { final char symb = local . charAt ( n ) ;
local . append ( inwd , 1 , inwd . length - 1 ) ; break; } if ( inwd [ 1 ] == 'H' ) { local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.AOR2Mutator]MSP[]
final StringBuilder code = new StringBuilder ( 10 ) ; switch( inwd [ 0 ] ) { case 'K' : case 'G' : case 'P' : if ( inwd [ 1 ] == 'N' ) { MST[InlineConstantMutator]MSP[]
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && MST[MathMutator]MSP[] FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && MST[rv.AOD2Mutator]MSP[] isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
if ( ! isLastChar ( wdsz , n ) && MST[rv.UOI1Mutator]MSP[] isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break; case 'Z' :
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; MST[rv.CRCR5Mutator]MSP[] break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 &&
boolean matches = false ; if( index > 0 && MST[RemoveConditionalMutator_ORDER_IF]MSP[] index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; } return matches ; }
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { n ++ ; } else { switch( symb ) { MST[experimental.SwitchMutator]MSP[] case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && MST[rv.ROR4Mutator]MSP[] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; break; }
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && index + test . length () - 1 < string . length () ) { MST[NegateConditionalsMutator]MSP[]
isNextChar ( local , n , 'H' ) && MST[rv.CRCR4Mutator]MSP[] ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
final int wdsz = local . length () ; int n = 0 ; while ( code . length () < this . getMaxCodeLen () && MST[NegateConditionalsMutator]MSP[] n < wdsz ) { final char symb = local . charAt ( n ) ;
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && MST[rv.CRCR3Mutator]MSP[] FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { MST[NegateConditionalsMutator]MSP[] if ( n == 0 &&
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; MST[rv.CRCR2Mutator]MSP[] break; }
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && MST[rv.UOI3Mutator]MSP[] FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
local . setCharAt ( 0 , 'W' ) ; MST[rv.CRCR3Mutator]MSP[] } else { local . append ( inwd ) ; } break; case 'X' : inwd [ 0 ] = 'S' ; local . append ( inwd ) ; break; default: local . append ( inwd ) ; }
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ; MST[rv.CRCR1Mutator]MSP[]
FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 && ! hard ) { code . append ( 'J' ) ; MST[rv.CRCR2Mutator]MSP[] } else { code . append ( 'K' ) ; } break; case 'H' :
code . append ( 'F' ) ; MST[experimental.NakedReceiverMutator]MSP[] } else { code . append ( symb ) ; } break; case 'Q' : code . append ( 'K' ) ; break; case 'S' : if ( regionMatch ( local , n , lr_5 ) ||
if ( ! isPreviousChar ( local , n , 'C' ) ) { code . append ( symb ) ; } } else { code . append ( symb ) ; MST[rv.UOI1Mutator]MSP[] } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) {
public String metaphone ( final String txt ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) {
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && MST[rv.CRCR6Mutator]MSP[] VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) {
if ( isLastChar ( wdsz , n ) ) { MST[rv.UOI3Mutator]MSP[] break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) {
boolean matches = false ; if( index > 0 && MST[rv.UOI3Mutator]MSP[] index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; } return matches ; }
code . append ( 'F' ) ; } else { code . append ( symb ) ; MST[rv.UOI4Mutator]MSP[] } break; case 'Q' : code . append ( 'K' ) ; break; case 'S' : if ( regionMatch ( local , n , lr_5 ) ||
public String metaphone ( final String txt ) { boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return lr_1 ; } if ( txtLength == 1 ) {
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; MST[rv.AOD1Mutator]MSP[] } return matches ; }
local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break; case 'A' : if ( inwd [ 1 ] == 'E' ) { MST[rv.ROR3Mutator]MSP[]
if ( ! isLastChar ( wdsz , n ) && isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; MST[rv.CRCR3Mutator]MSP[] code . append ( 'S' ) ; break; case 'Z' :
boolean matches = false ; if( index > 0 && MST[rv.ROR4Mutator]MSP[] index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; } return matches ; }
if ( ! isLastChar ( wdsz , n ) && isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; MST[rv.CRCR5Mutator]MSP[] break; case 'Z' :
isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && MST[rv.UOI4Mutator]MSP[] ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && MST[rv.UOI3Mutator]MSP[] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; break; }
FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 && MST[rv.ROR1Mutator]MSP[] ! hard ) { code . append ( 'J' ) ; } else { code . append ( 'K' ) ; } break; case 'H' :
wdsz >= 3 && isVowel ( local , 2 ) ) { code . append ( 'K' ) ; } else { code . append ( 'X' ) ; } } else { code . append ( 'K' ) ; MST[rv.CRCR1Mutator]MSP[] } break; case 'D' :
public String metaphone ( final String txt ) { MST[rv.UOI3Mutator]MSP[] boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) {
final String substring = string . substring ( index , index + test . length () ) ; MST[NonVoidMethodCallMutator]MSP[] matches = substring . equals ( test ) ; } return matches ; } private boolean isLastChar ( final int wdsz , final int n ) {
regionMatch ( local , n , lr_6 ) || regionMatch ( local , n , lr_7 ) ) { code . append ( 'X' ) ; MST[NonVoidMethodCallMutator]MSP[] } else { code . append ( 'S' ) ; } break; case 'T' :
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ; MST[rv.AOD1Mutator]MSP[]
if ( ! isPreviousChar ( local , n , 'C' ) ) { code . append ( symb ) ; } } else { code . append ( symb ) ; } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) { MST[rv.ROR2Mutator]MSP[]
if ( ! isLastChar ( wdsz , n ) && MST[MathMutator]MSP[] isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break; case 'Z' :
local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break; case 'W' : if ( inwd [ 1 ] == 'R' ) { MST[rv.ROR3Mutator]MSP[]
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; } return matches ; MST[rv.UOI1Mutator]MSP[] }
private boolean isVowel ( final StringBuilder string , final int index ) { return VOWELS . indexOf ( string . charAt ( index ) ) >= 0 ; MST[rv.CRCR6Mutator]MSP[] } private boolean isPreviousChar ( final StringBuilder string , final int index , final char c ) {
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) { MST[rv.ROR4Mutator]MSP[]
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.ROR1Mutator]MSP[]
if ( regionMatch ( local , n , lr_11 ) ) { MST[rv.ROR3Mutator]MSP[] code . append ( '0' ) ; } else { code . append ( 'T' ) ; } break; case 'V' : code . append ( 'F' ) ; break; case 'W' : case 'Y' :
code . append ( symb ) ; MST[experimental.NakedReceiverMutator]MSP[] } break; case 'B' : if ( isPreviousChar ( local , n , 'M' ) && isLastChar ( wdsz , n ) ) { break; } code . append ( symb ) ; break; case 'C' :
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.UOI3Mutator]MSP[]
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { MST[ConditionalsBoundaryMutator]MSP[] break; } if ( regionMatch ( local , n , lr_2 ) ) {
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && MST[rv.UOI3Mutator]MSP[] index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ;
if ( isPreviousChar ( local , n , 'S' ) && MST[InlineConstantMutator]MSP[] isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 &&
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; MST[rv.UOI1Mutator]MSP[] } return matches ; }
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && index + test . length () - 1 < string . length () ) { MST[rv.AOR3Mutator]MSP[]
return n + 1 == wdsz ; MST[rv.ABSMutator]MSP[] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
public String encode ( final String str ) { return metaphone ( str ) ; } public boolean isMetaphoneEqual ( final String str1 , final String str2 ) { return metaphone ( str1 ) . equals ( metaphone ( str2 ) ) ; MST[BooleanFalseReturnValsMutator]MSP[] }
code . append ( 'F' ) ; } else { code . append ( symb ) ; } break; case 'Q' : code . append ( 'K' ) ; break; case 'S' : if ( regionMatch ( local , n , lr_5 ) || MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
return n + 1 == wdsz ; MST[BooleanTrueReturnValsMutator]MSP[] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || MST[rv.UOI1Mutator]MSP[] regionMatch ( local , n , lr_4 ) ) ) { break;
final StringBuilder code = new StringBuilder ( 10 ) ; switch( inwd [ 0 ] ) { case 'K' : case 'G' : case 'P' : if ( inwd [ 1 ] == 'N' ) { MST[rv.CRCR3Mutator]MSP[]
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && MST[rv.CRCR3Mutator]MSP[] VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) {
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 &&
isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || MST[rv.ROR2Mutator]MSP[] regionMatch ( local , n , lr_4 ) ) ) { break;
code . append ( 'H' ) ; } break; case 'F' : case 'J' : case 'L' : case 'M' : case 'N' : case 'R' : code . append ( symb ) ; break; case 'K' : if ( n > 0 ) { MST[NegateConditionalsMutator]MSP[]
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) { MST[NonVoidMethodCallMutator]MSP[]
final StringBuilder code = new StringBuilder ( 10 ) ; switch( inwd [ 0 ] ) { case 'K' : case 'G' : case 'P' : if ( inwd [ 1 ] == 'N' ) { MST[rv.CRCR6Mutator]MSP[]
code . append ( 'H' ) ; } break; case 'F' : case 'J' : case 'L' : case 'M' : case 'N' : case 'R' : code . append ( symb ) ; MST[rv.UOI1Mutator]MSP[] break; case 'K' : if ( n > 0 ) {
local . append ( inwd , 1 , inwd . length - 1 ) ; break; } if ( inwd [ 1 ] == 'H' ) { local . append ( inwd , 1 , inwd . length - 1 ) ; MST[experimental.NakedReceiverMutator]MSP[]
return n + 1 == wdsz ; } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { MST[rv.ROR5Mutator]MSP[] throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
regionMatch ( local , n , lr_6 ) || regionMatch ( local , n , lr_7 ) ) { code . append ( 'X' ) ; MST[rv.CRCR3Mutator]MSP[] } else { code . append ( 'S' ) ; } break; case 'T' :
isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 && MST[rv.ROR3Mutator]MSP[]
return n + 1 == wdsz ; MST[rv.UOI1Mutator]MSP[] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 && MST[rv.CRCR6Mutator]MSP[]
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ; MST[rv.CRCR4Mutator]MSP[]
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ; MST[rv.CRCR2Mutator]MSP[]
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 && MST[rv.CRCR3Mutator]MSP[]
} if ( isPreviousChar ( local , n , 'G' ) ) { hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) && MST[rv.ABSMutator]MSP[]
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) { MST[rv.UOI1Mutator]MSP[]
if ( ! isPreviousChar ( local , n , 'C' ) ) { code . append ( symb ) ; } } else { code . append ( symb ) ; } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) { MST[NegateConditionalsMutator]MSP[]
return n + 1 == wdsz ; MST[rv.CRCR4Mutator]MSP[] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
private boolean isVowel ( final StringBuilder string , final int index ) { return VOWELS . indexOf ( string . charAt ( index ) ) >= 0 ; MST[rv.UOI1Mutator]MSP[] } private boolean isPreviousChar ( final StringBuilder string , final int index , final char c ) {
local . setCharAt ( 0 , 'W' ) ; MST[rv.CRCR6Mutator]MSP[] } else { local . append ( inwd ) ; } break; case 'X' : inwd [ 0 ] = 'S' ; local . append ( inwd ) ; break; default: local . append ( inwd ) ; }
} if ( isPreviousChar ( local , n , 'G' ) ) { MST[rv.ROR3Mutator]MSP[] hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) &&
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { MST[rv.CRCR4Mutator]MSP[] n ++ ; } else { switch( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
if ( ! isLastChar ( wdsz , n ) && MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break; case 'Z' :
private boolean isVowel ( final StringBuilder string , final int index ) { return VOWELS . indexOf ( string . charAt ( index ) ) >= 0 ; MST[RemoveConditionalMutator_ORDER_IF]MSP[] } private boolean isPreviousChar ( final StringBuilder string , final int index , final char c ) {
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { n ++ ; } else { switch( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) { MST[NegateConditionalsMutator]MSP[]
private boolean isVowel ( final StringBuilder string , final int index ) { return VOWELS . indexOf ( string . charAt ( index ) ) >= 0 ; MST[rv.ABSMutator]MSP[] } private boolean isPreviousChar ( final StringBuilder string , final int index , final char c ) {
code . append ( 'S' ) ; break; default: break; } n ++ ; } if ( code . length () > this . getMaxCodeLen () ) { code . setLength ( this . getMaxCodeLen () ) ; } } return code . toString () ; MST[NonVoidMethodCallMutator]MSP[] }
final int wdsz = local . length () ; int n = 0 ; while ( code . length () < this . getMaxCodeLen () && n < wdsz ) { final char symb = local . charAt ( n ) ; MST[rv.UOI1Mutator]MSP[]
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && MST[rv.UOI2Mutator]MSP[] isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
regionMatch ( local , n , lr_6 ) || regionMatch ( local , n , lr_7 ) ) { code . append ( 'X' ) ; MST[rv.CRCR6Mutator]MSP[] } else { code . append ( 'S' ) ; } break; case 'T' :
private boolean isVowel ( final StringBuilder string , final int index ) { return VOWELS . indexOf ( string . charAt ( index ) ) >= 0 ; MST[rv.ROR4Mutator]MSP[] } private boolean isPreviousChar ( final StringBuilder string , final int index , final char c ) {
local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break; case 'W' : if ( inwd [ 1 ] == 'R' ) { MST[rv.CRCR4Mutator]MSP[]
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && MST[rv.UOI1Mutator]MSP[] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; break; }
local . setCharAt ( 0 , 'W' ) ; } else { local . append ( inwd ) ; } break; case 'X' : inwd [ 0 ] = 'S' ; local . append ( inwd ) ; break; default: local . append ( inwd ) ; MST[NonVoidMethodCallMutator]MSP[] }
isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && MST[NegateConditionalsMutator]MSP[] ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
} if ( isPreviousChar ( local , n , 'G' ) ) { hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) && MST[rv.ROR2Mutator]MSP[]
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.CRCR6Mutator]MSP[] } else { local . append ( inwd ) ; } break; case 'A' : if ( inwd [ 1 ] == 'E' ) {
return n + 1 == wdsz ; } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { MST[NegateConditionalsMutator]MSP[] throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
final int wdsz = local . length () ; int n = 0 ; while ( code . length () < this . getMaxCodeLen () && MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] n < wdsz ) { final char symb = local . charAt ( n ) ;
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && MST[rv.AOR4Mutator]MSP[] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && index + test . length () - 1 < string . length () ) { MST[rv.ROR2Mutator]MSP[]
FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 && MST[rv.ABSMutator]MSP[] ! hard ) { code . append ( 'J' ) ; } else { code . append ( 'K' ) ; } break; case 'H' :
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 && MST[rv.ROR5Mutator]MSP[]
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ; MST[rv.UOI1Mutator]MSP[]
local . setCharAt ( 0 , 'W' ) ; MST[rv.CRCR2Mutator]MSP[] } else { local . append ( inwd ) ; } break; case 'X' : inwd [ 0 ] = 'S' ; local . append ( inwd ) ; break; default: local . append ( inwd ) ; }
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { MST[NonVoidMethodCallMutator]MSP[] break; } if ( isVowel ( local , n + 1 ) ) {
local . append ( inwd , 1 , inwd . length - 1 ) ; break; } if ( inwd [ 1 ] == 'H' ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] local . append ( inwd , 1 , inwd . length - 1 ) ;
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { MST[NonVoidMethodCallMutator]MSP[] code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 &&
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && MST[rv.CRCR3Mutator]MSP[] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; break; }
local . append ( inwd , 1 , inwd . length - 1 ) ; break; } if ( inwd [ 1 ] == 'H' ) { MST[rv.CRCR2Mutator]MSP[] local . append ( inwd , 1 , inwd . length - 1 ) ;
return txt . toUpperCase ( java . util . Locale . ENGLISH ) ; } final char [] inwd = txt . toUpperCase ( java . util . Locale . ENGLISH ) . toCharArray () ; MST[NonVoidMethodCallMutator]MSP[] final StringBuilder local = new StringBuilder ( 40 ) ;
if ( ! isPreviousChar ( local , n , 'C' ) ) { MST[rv.ROR2Mutator]MSP[] code . append ( symb ) ; } } else { code . append ( symb ) ; } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) {
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) { MST[rv.AOR4Mutator]MSP[]
} if ( isPreviousChar ( local , n , 'G' ) ) { hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) && MST[InlineConstantMutator]MSP[]
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; MST[rv.CRCR5Mutator]MSP[] if( index >= 0 && index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ;
if ( ! isLastChar ( wdsz , n ) && isVowel ( local , n + 1 ) ) { code . append ( symb ) ; MST[rv.ABSMutator]MSP[] } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break; case 'Z' :
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.CRCR5Mutator]MSP[] } else { local . append ( inwd ) ; } break; case 'A' : if ( inwd [ 1 ] == 'E' ) {
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.UOI3Mutator]MSP[] ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
public int getMaxCodeLen () { return this . maxCodeLen ; } MST[PrimitiveReturnsMutator]MSP[] public void setMaxCodeLen ( final int maxCodeLen ) { this . maxCodeLen = maxCodeLen ; }
} return matches ; MST[rv.UOI1Mutator]MSP[] } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && index + test . length () - 1 < string . length () ) {
code . append ( 'F' ) ; } else { code . append ( symb ) ; } break; case 'Q' : code . append ( 'K' ) ; break; case 'S' : if ( regionMatch ( local , n , lr_5 ) || MST[rv.UOI4Mutator]MSP[]
public String metaphone ( final String txt ) { MST[rv.ABSMutator]MSP[] boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) {
if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.CRCR6Mutator]MSP[] isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { MST[rv.ROR1Mutator]MSP[] break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
code . append ( 'F' ) ; MST[rv.CRCR1Mutator]MSP[] } else { code . append ( symb ) ; } break; case 'Q' : code . append ( 'K' ) ; break; case 'S' : if ( regionMatch ( local , n , lr_5 ) ||
code . append ( 'S' ) ; break; default: break; } n ++ ; } if ( code . length () > this . getMaxCodeLen () ) { MST[NegateConditionalsMutator]MSP[] code . setLength ( this . getMaxCodeLen () ) ; } } return code . toString () ; }
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ; MST[rv.CRCR5Mutator]MSP[]
if ( regionMatch ( local , n , lr_11 ) ) { code . append ( '0' ) ; } else { code . append ( 'T' ) ; } break; case 'V' : code . append ( 'F' ) ; break; MST[InlineConstantMutator]MSP[] case 'W' : case 'Y' :
return txt . toUpperCase ( java . util . Locale . ENGLISH ) ; MST[ReturnValsMutator]MSP[] } final char [] inwd = txt . toUpperCase ( java . util . Locale . ENGLISH ) . toCharArray () ; final StringBuilder local = new StringBuilder ( 40 ) ;
code . append ( 'H' ) ; } break; case 'F' : case 'J' : case 'L' : case 'M' : case 'N' : case 'R' : code . append ( symb ) ; break; case 'K' : if ( n > 0 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[]
if ( ! isLastChar ( wdsz , n ) && isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; MST[NonVoidMethodCallMutator]MSP[] code . append ( 'S' ) ; break; case 'Z' :
if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.UOI2Mutator]MSP[] isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
isNextChar ( local , n , 'H' ) && MST[rv.AOR1Mutator]MSP[] ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
if ( regionMatch ( local , n , lr_8 ) || regionMatch ( local , n , lr_9 ) ) { code . append ( 'X' ) ; MST[rv.CRCR2Mutator]MSP[] break; } if ( regionMatch ( local , n , lr_10 ) ) { break; }
final StringBuilder code = new StringBuilder ( 10 ) ; MST[InlineConstantMutator]MSP[] switch( inwd [ 0 ] ) { case 'K' : case 'G' : case 'P' : if ( inwd [ 1 ] == 'N' ) {
if ( isLastChar ( wdsz , n ) ) { MST[rv.ROR3Mutator]MSP[] break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) {
public String metaphone ( final String txt ) { MST[rv.CRCR3Mutator]MSP[] boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) {
isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || MST[rv.ROR5Mutator]MSP[] regionMatch ( local , n , lr_4 ) ) ) { break;
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.CRCR6Mutator]MSP[] isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 &&
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; MST[rv.UOI4Mutator]MSP[] } return matches ; }
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[InlineConstantMutator]MSP[] break; } if ( inwd [ 1 ] == 'H' ) { local . append ( inwd , 1 , inwd . length - 1 ) ;
} else { code . append ( 'T' ) ; MST[InlineConstantMutator]MSP[] } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || MST[rv.UOI4Mutator]MSP[] regionMatch ( local , n , lr_4 ) ) ) { break;
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && MST[MathMutator]MSP[] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; break; }
code . append ( 'X' ) ; MST[NonVoidMethodCallMutator]MSP[] break; } if ( ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; break; }
return n + 1 == wdsz ; MST[rv.AOR1Mutator]MSP[] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
code . append ( 'H' ) ; MST[InlineConstantMutator]MSP[] } break; case 'F' : case 'J' : case 'L' : case 'M' : case 'N' : case 'R' : code . append ( symb ) ; break; case 'K' : if ( n > 0 ) {
final StringBuilder code = new StringBuilder ( 10 ) ; switch( inwd [ 0 ] ) { MST[experimental.SwitchMutator]MSP[] case 'K' : case 'G' : case 'P' : if ( inwd [ 1 ] == 'N' ) {
if ( ! isPreviousChar ( local , n , 'C' ) ) { code . append ( symb ) ; } } else { code . append ( symb ) ; } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) { MST[rv.ROR5Mutator]MSP[]
private boolean isVowel ( final StringBuilder string , final int index ) { return VOWELS . indexOf ( string . charAt ( index ) ) >= 0 ; MST[rv.CRCR6Mutator]MSP[] } private boolean isPreviousChar ( final StringBuilder string , final int index , final char c ) {
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.UOI2Mutator]MSP[]
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; MST[rv.UOI1Mutator]MSP[] } return matches ; }
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.AOR3Mutator]MSP[] } else { local . append ( inwd ) ; } break; case 'A' : if ( inwd [ 1 ] == 'E' ) {
local . append ( inwd , 1 , inwd . length - 1 ) ; break; } if ( inwd [ 1 ] == 'H' ) { local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.CRCR4Mutator]MSP[]
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.UOI1Mutator]MSP[] isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 &&
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.ROR2Mutator]MSP[] isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 &&
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] } return matches ; }
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { MST[rv.ROR1Mutator]MSP[] break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
final int wdsz = local . length () ; int n = 0 ; while ( code . length () < this . getMaxCodeLen () && MST[rv.ABSMutator]MSP[] n < wdsz ) { final char symb = local . charAt ( n ) ;
wdsz >= 3 && isVowel ( local , 2 ) ) { code . append ( 'K' ) ; } else { code . append ( 'X' ) ; } } else { code . append ( 'K' ) ; MST[rv.CRCR4Mutator]MSP[] } break; case 'D' :
if ( regionMatch ( local , n , lr_8 ) || regionMatch ( local , n , lr_9 ) ) { code . append ( 'X' ) ; break; } if ( regionMatch ( local , n , lr_10 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] break; }
local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break; case 'W' : if ( inwd [ 1 ] == 'R' ) { MST[rv.CRCR6Mutator]MSP[]
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && index + test . length () - 1 < string . length () ) { MST[NonVoidMethodCallMutator]MSP[]
if ( regionMatch ( local , n , lr_11 ) ) { code . append ( '0' ) ; MST[rv.CRCR2Mutator]MSP[] } else { code . append ( 'T' ) ; } break; case 'V' : code . append ( 'F' ) ; break; case 'W' : case 'Y' :
public String encode ( final String str ) { return metaphone ( str ) ; } public boolean isMetaphoneEqual ( final String str1 , final String str2 ) { return metaphone ( str1 ) . equals ( metaphone ( str2 ) ) ; MST[ReturnValsMutator]MSP[] }
isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] break;
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && index + test . length () - 1 < string . length () ) { MST[rv.CRCR4Mutator]MSP[]
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 && MST[rv.UOI4Mutator]MSP[]
code . append ( 'X' ) ; MST[rv.CRCR3Mutator]MSP[] break; } if ( ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; break; }
} if ( isPreviousChar ( local , n , 'G' ) ) { hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) && MST[rv.UOI1Mutator]MSP[]
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { n ++ ; } else { switch( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) { MST[rv.ROR5Mutator]MSP[]
regionMatch ( local , n , lr_6 ) || MST[rv.UOI3Mutator]MSP[] regionMatch ( local , n , lr_7 ) ) { code . append ( 'X' ) ; } else { code . append ( 'S' ) ; } break; case 'T' :
if ( ! isPreviousChar ( local , n , 'C' ) ) { code . append ( symb ) ; } } else { code . append ( symb ) ; MST[rv.UOI4Mutator]MSP[] } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) {
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { MST[rv.UOI2Mutator]MSP[] if ( n == 0 &&
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 && MST[rv.CRCR6Mutator]MSP[]
final StringBuilder code = new StringBuilder ( 10 ) ; switch( inwd [ 0 ] ) { case 'K' : case 'G' : case 'P' : if ( inwd [ 1 ] == 'N' ) { MST[rv.ROR3Mutator]MSP[]
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
regionMatch ( local , n , lr_6 ) || regionMatch ( local , n , lr_7 ) ) { MST[rv.ROR1Mutator]MSP[] code . append ( 'X' ) ; } else { code . append ( 'S' ) ; } break; case 'T' :
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && MST[rv.UOI1Mutator]MSP[] index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ;
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[InlineConstantMutator]MSP[] } else { local . append ( inwd ) ; } break; case 'W' : if ( inwd [ 1 ] == 'R' ) {
local . append ( inwd , 1 , inwd . length - 1 ) ; break; } if ( inwd [ 1 ] == 'H' ) { local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.CRCR5Mutator]MSP[]
local . setCharAt ( 0 , 'W' ) ; } else { local . append ( inwd ) ; } break; case 'X' : inwd [ 0 ] = 'S' ; MST[InlineConstantMutator]MSP[] local . append ( inwd ) ; break; default: local . append ( inwd ) ; }
if ( ! isLastChar ( wdsz , n + 1 ) && MST[InlineConstantMutator]MSP[] isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
return n + 1 == wdsz ; MST[rv.CRCR4Mutator]MSP[] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && MST[rv.ROR1Mutator]MSP[] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
final int wdsz = local . length () ; int n = 0 ; MST[rv.CRCR1Mutator]MSP[] while ( code . length () < this . getMaxCodeLen () && n < wdsz ) { final char symb = local . charAt ( n ) ;
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && MST[rv.ROR4Mutator]MSP[] isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
regionMatch ( local , n , lr_6 ) || MST[rv.ROR4Mutator]MSP[] regionMatch ( local , n , lr_7 ) ) { code . append ( 'X' ) ; } else { code . append ( 'S' ) ; } break; case 'T' :
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && MST[rv.CRCR2Mutator]MSP[] isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && MST[rv.UOI3Mutator]MSP[] isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
code . append ( 'H' ) ; } break; case 'F' : case 'J' : case 'L' : case 'M' : case 'N' : case 'R' : code . append ( symb ) ; break; case 'K' : if ( n > 0 ) { MST[rv.ROR5Mutator]MSP[]
wdsz >= 3 && isVowel ( local , 2 ) ) { MST[rv.ROR4Mutator]MSP[] code . append ( 'K' ) ; } else { code . append ( 'X' ) ; } } else { code . append ( 'K' ) ; } break; case 'D' :
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { MST[rv.UOI3Mutator]MSP[] n ++ ; } else { switch( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && MST[rv.UOI1Mutator]MSP[] index + test . length () - 1 < string . length () ) {
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { MST[rv.ROR4Mutator]MSP[] n ++ ; } else { switch( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
if ( ! isLastChar ( wdsz , n ) && MST[rv.UOI4Mutator]MSP[] isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break; case 'Z' :
