k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ; result ^= k1 ; } result ^= totalLen ; MST[rv.UOI4Mutator]MSP[N] return fmix32 ( result ) ; }
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ; MST[rv.CRCR6Mutator]MSP[N]
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ; result ^= k1 ; MST[rv.UOI2Mutator]MSP[N] } result ^= totalLen ; return fmix32 ( result ) ; }
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; MST[rv.AOD2Mutator]MSP[N] newLength = length - consumed ; } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ;
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; MST[InlineConstantMutator]MSP[N] case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.ABSMutator]MSP[N] } @Override @Deprecated
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , unprocessed [ 2 ] , data [ offset ] ) ; MST[rv.CRCR3Mutator]MSP[N] break; default: throw new IllegalStateException ( lr_1 + unprocessedLength ) ; } hash = mix32 ( k , hash ) ;
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , unprocessed [ 2 ] , data [ offset ] ) ; MST[rv.CRCR6Mutator]MSP[N] break; default: throw new IllegalStateException ( lr_1 + unprocessedLength ) ; } hash = mix32 ( k , hash ) ;
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; MST[rv.UOI3Mutator]MSP[N] k1 *= C2_32 ; result ^= k1 ; } result ^= totalLen ; return fmix32 ( result ) ; }
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; MST[rv.CRCR5Mutator]MSP[S] case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
public final void start ( final int seed ) { unprocessedLength = totalLen = 0 ; this . hash = seed ; } public final void add ( final byte [] data , final int offset , final int length ) { if ( length <= 0 ) { MST[rv.UOI2Mutator]MSP[S] return;
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[rv.CRCR5Mutator]MSP[N] break; case 3 :
final int consumed = BLOCK_SIZE - unprocessedLength ; MST[rv.CRCR1Mutator]MSP[S] newOffset = offset + consumed ; newLength = length - consumed ; } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ;
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.UOI2Mutator]MSP[N] } @Override @Deprecated
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.UOI3Mutator]MSP[N] } @Override @Deprecated
return finalise ( hash , unprocessedLength , unprocessed , totalLen ) ; MST[rv.UOI1Mutator]MSP[N] } int finalise ( final int hash , final int unprocessedLength , final byte [] unprocessed , final int totalLen ) { int result = hash ; int k1 = 0 ; switch ( unprocessedLength ) {
int k = - 1 ; switch ( unprocessedLength ) { MST[rv.UOI4Mutator]MSP[N] case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; break; case 2 :
for ( int i = 0 ; i < nblocks ; i ++ ) { final int index = newOffset + ( i << 2 ) ; MST[rv.CRCR1Mutator]MSP[N] final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; }
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; MST[rv.UOI4Mutator]MSP[N] case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ; MST[rv.CRCR5Mutator]MSP[N] result ^= k1 ; } result ^= totalLen ; return fmix32 ( result ) ; }
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.OBBN1Mutator]MSP[N] } @Override @Deprecated
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; MST[rv.CRCR1Mutator]MSP[N] } } public final int end () {
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; MST[rv.AOR4Mutator]MSP[S] return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; newLength = length - consumed ; } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ; MST[rv.CRCR5Mutator]MSP[N]
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.CRCR6Mutator]MSP[N] break; case 2 :
public final void start ( final int seed ) { unprocessedLength = totalLen = 0 ; this . hash = seed ; } public final void add ( final byte [] data , final int offset , final int length ) { if ( length <= 0 ) { MST[rv.ABSMutator]MSP[S] return;
public final void start ( final int seed ) { unprocessedLength = totalLen = 0 ; this . hash = seed ; } public final void add ( final byte [] data , final int offset , final int length ) { if ( length <= 0 ) { MST[rv.ROR3Mutator]MSP[N] return;
return finalise ( hash , unprocessedLength , unprocessed , totalLen ) ; } int finalise ( final int hash , final int unprocessedLength , final byte [] unprocessed , final int totalLen ) { int result = hash ; int k1 = 0 ; MST[InlineConstantMutator]MSP[S] switch ( unprocessedLength ) {
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.CRCR5Mutator]MSP[N] } @Override @Deprecated
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { MST[rv.ROR4Mutator]MSP[N] System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; } } public final int end () {
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; MST[rv.UOI1Mutator]MSP[N] case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; MST[MathMutator]MSP[N] newLength = length - consumed ; } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ;
for ( int i = 0 ; i < nblocks ; i ++ ) { MST[rv.ROR1Mutator]MSP[N] final int index = newOffset + ( i << 2 ) ; final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; }
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.CRCR2Mutator]MSP[N] } @Override @Deprecated
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[InlineConstantMutator]MSP[N] } @Override @Deprecated
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.UOI1Mutator]MSP[N] break; case 2 :
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; MST[rv.CRCR2Mutator]MSP[S] case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ; result ^= k1 ; MST[rv.ABSMutator]MSP[S] } result ^= totalLen ; return fmix32 ( result ) ; }
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.ABSMutator]MSP[N] } @Override @Deprecated
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[rv.CRCR3Mutator]MSP[N] break; case 3 :
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; newLength = length - consumed ; MST[rv.UOI4Mutator]MSP[S] } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ;
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { MST[rv.UOI3Mutator]MSP[N] System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; } } public final int end () {
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.OBBN1Mutator]MSP[N] } @Override @Deprecated
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; newLength = length - consumed ; MST[rv.AOR1Mutator]MSP[S] } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ;
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.UOI2Mutator]MSP[N] } @Override @Deprecated
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.CRCR4Mutator]MSP[N] break; case 2 :
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[MathMutator]MSP[N] } @Override @Deprecated
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; MST[rv.UOI3Mutator]MSP[S] newLength = length - consumed ; } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ;
for ( int i = 0 ; i < nblocks ; i ++ ) { MST[rv.UOI3Mutator]MSP[N] final int index = newOffset + ( i << 2 ) ; final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; }
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; MST[rv.OBBN3Mutator]MSP[S] case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
final int consumed = ( nblocks << 2 ) ; MST[rv.CRCR4Mutator]MSP[N] unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; } } public final int end () {
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; MST[InlineConstantMutator]MSP[N] case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; MST[rv.CRCR5Mutator]MSP[N] case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[MathMutator]MSP[N] break; case 3 :
} totalLen += length ; MST[rv.AOR2Mutator]MSP[S] if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ; MST[rv.UOI1Mutator]MSP[N]
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ; result ^= k1 ; } result ^= totalLen ; return fmix32 ( result ) ; MST[ReturnValsMutator]MSP[N] }
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; MST[rv.CRCR2Mutator]MSP[N] case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { MST[rv.AOD1Mutator]MSP[N] System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
return finalise ( hash , unprocessedLength , unprocessed , totalLen ) ; } int finalise ( final int hash , final int unprocessedLength , final byte [] unprocessed , final int totalLen ) { int result = hash ; MST[rv.UOI1Mutator]MSP[N] int k1 = 0 ; switch ( unprocessedLength ) {
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; MST[rv.ABSMutator]MSP[N] unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
final int consumed = BLOCK_SIZE - unprocessedLength ; MST[rv.ABSMutator]MSP[N] newOffset = offset + consumed ; newLength = length - consumed ; } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ;
for ( int i = 0 ; i < nblocks ; i ++ ) { final int index = newOffset + ( i << 2 ) ; final int k = getLittleEndianInt ( data , index ) ; MST[NonVoidMethodCallMutator]MSP[S] hash = mix32 ( k , hash ) ; }
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; MST[rv.CRCR5Mutator]MSP[N] case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
return finalise ( hash , unprocessedLength , unprocessed , totalLen ) ; MST[rv.UOI3Mutator]MSP[N] } int finalise ( final int hash , final int unprocessedLength , final byte [] unprocessed , final int totalLen ) { int result = hash ; int k1 = 0 ; switch ( unprocessedLength ) {
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; newLength = length - consumed ; } else { newOffset = offset ; newLength = length ; MST[rv.UOI4Mutator]MSP[N] } final int nblocks = newLength >> 2 ;
return finalise ( hash , unprocessedLength , unprocessed , totalLen ) ; } int finalise ( final int hash , final int unprocessedLength , final byte [] unprocessed , final int totalLen ) { int result = hash ; int k1 = 0 ; switch ( unprocessedLength ) { MST[experimental.SwitchMutator]MSP[S]
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { MST[rv.ROR5Mutator]MSP[N] System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; newLength = length - consumed ; } else { newOffset = offset ; MST[rv.UOI2Mutator]MSP[N] newLength = length ; } final int nblocks = newLength >> 2 ;
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ; result ^= k1 ; } result ^= totalLen ; return fmix32 ( result ) ; MST[rv.ABSMutator]MSP[N] }
for ( int i = 0 ; i < nblocks ; i ++ ) { MST[rv.CRCR6Mutator]MSP[N] final int index = newOffset + ( i << 2 ) ; final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; }
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N]
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; MST[rv.ABSMutator]MSP[N] } } public final int end () {
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { MST[rv.UOI2Mutator]MSP[N] System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[rv.AOD2Mutator]MSP[N] break; case 3 :
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , unprocessed [ 2 ] , data [ offset ] ) ; break; default: throw new IllegalStateException ( lr_1 + unprocessedLength ) ; } hash = mix32 ( k , hash ) ; MST[rv.UOI4Mutator]MSP[N]
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[rv.CRCR6Mutator]MSP[N] break; case 3 :
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; MST[rv.UOI4Mutator]MSP[N] } } public final int end () {
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[rv.ABSMutator]MSP[N] break; case 3 :
return finalise ( hash , unprocessedLength , unprocessed , totalLen ) ; MST[rv.UOI4Mutator]MSP[N] } int finalise ( final int hash , final int unprocessedLength , final byte [] unprocessed , final int totalLen ) { int result = hash ; int k1 = 0 ; switch ( unprocessedLength ) {
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; MST[rv.CRCR2Mutator]MSP[N] case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; MST[rv.UOI1Mutator]MSP[N] unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { MST[rv.CRCR4Mutator]MSP[S] System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; MST[rv.ABSMutator]MSP[N] case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , unprocessed [ 2 ] , data [ offset ] ) ; MST[rv.UOI3Mutator]MSP[N] break; default: throw new IllegalStateException ( lr_1 + unprocessedLength ) ; } hash = mix32 ( k , hash ) ;
for ( int i = 0 ; i < nblocks ; i ++ ) { MST[rv.CRCR3Mutator]MSP[N] final int index = newOffset + ( i << 2 ) ; final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; }
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ; result ^= k1 ; } result ^= totalLen ; MST[MathMutator]MSP[N] return fmix32 ( result ) ; }
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; MST[rv.UOI3Mutator]MSP[N] return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
public final void start ( final int seed ) { unprocessedLength = totalLen = 0 ; this . hash = seed ; MST[rv.UOI2Mutator]MSP[N] } public final void add ( final byte [] data , final int offset , final int length ) { if ( length <= 0 ) { return;
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , unprocessed [ 2 ] , data [ offset ] ) ; MST[rv.CRCR6Mutator]MSP[N] break; default: throw new IllegalStateException ( lr_1 + unprocessedLength ) ; } hash = mix32 ( k , hash ) ;
int k = - 1 ; MST[rv.CRCR4Mutator]MSP[N] switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; break; case 2 :
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.ABSMutator]MSP[N] break; case 2 :
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ; MST[rv.AOD2Mutator]MSP[S]
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , unprocessed [ 2 ] , data [ offset ] ) ; MST[rv.CRCR3Mutator]MSP[N] break; default: throw new IllegalStateException ( lr_1 + unprocessedLength ) ; } hash = mix32 ( k , hash ) ;
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[rv.CRCR2Mutator]MSP[N] break; case 3 :
for ( int i = 0 ; i < nblocks ; i ++ ) { final int index = newOffset + ( i << 2 ) ; MST[rv.AOR1Mutator]MSP[N] final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; }
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.UOI3Mutator]MSP[N] break; case 2 :
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { MST[rv.AOD1Mutator]MSP[S] System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.CRCR2Mutator]MSP[N] break; case 2 :
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; MST[rv.ABSMutator]MSP[S] case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) { MST[rv.UOI3Mutator]MSP[N]
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[NonVoidMethodCallMutator]MSP[N] break; case 2 :
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) { MST[rv.ROR4Mutator]MSP[N]
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; newLength = length - consumed ; } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ; MST[InlineConstantMutator]MSP[N]
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; MST[rv.AOR1Mutator]MSP[N] if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; } } public final int end () {
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[rv.UOI2Mutator]MSP[N] break; case 3 :
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[rv.UOI3Mutator]MSP[N] break; case 3 :
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; MST[rv.ABSMutator]MSP[N] newLength = length - consumed ; } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ;
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ; MST[rv.CRCR1Mutator]MSP[S]
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[rv.UOI4Mutator]MSP[N] break; case 3 :
public final void start ( final int seed ) { unprocessedLength = totalLen = 0 ; this . hash = seed ; } public final void add ( final byte [] data , final int offset , final int length ) { if ( length <= 0 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] return;
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; MST[MathMutator]MSP[S] case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
} totalLen += length ; MST[rv.UOI2Mutator]MSP[S] if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.CRCR6Mutator]MSP[N] } @Override @Deprecated
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , unprocessed [ 2 ] , data [ offset ] ) ; break; default: throw new IllegalStateException ( lr_1 + unprocessedLength ) ; } hash = mix32 ( k , hash ) ; MST[rv.UOI4Mutator]MSP[N]
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { MST[rv.AOR3Mutator]MSP[S] System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { MST[rv.ROR1Mutator]MSP[N] System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; } } public final int end () {
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; MST[rv.CRCR5Mutator]MSP[S] k1 *= C1_32 ;
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; MST[rv.CRCR3Mutator]MSP[N] k1 *= C1_32 ;
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[InlineConstantMutator]MSP[N] break; case 3 :
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; newLength = length - consumed ; } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ; MST[rv.UOI2Mutator]MSP[N]
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.CRCR2Mutator]MSP[N] } @Override @Deprecated
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , unprocessed [ 2 ] , data [ offset ] ) ; MST[NonVoidMethodCallMutator]MSP[N] break; default: throw new IllegalStateException ( lr_1 + unprocessedLength ) ; } hash = mix32 ( k , hash ) ;
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.CRCR4Mutator]MSP[N] } @Override @Deprecated
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.UOI4Mutator]MSP[N] break; case 2 :
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[MathMutator]MSP[N] } @Override @Deprecated
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; MST[rv.UOI2Mutator]MSP[N] if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; } } public final int end () {
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , unprocessed [ 2 ] , data [ offset ] ) ; break; default: throw new IllegalStateException ( lr_1 + unprocessedLength ) ; } hash = mix32 ( k , hash ) ; MST[rv.ABSMutator]MSP[N]
for ( int i = 0 ; i < nblocks ; i ++ ) { final int index = newOffset + ( i << 2 ) ; final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; MST[experimental.MemberVariableMutator]MSP[N] }
return finalise ( hash , unprocessedLength , unprocessed , totalLen ) ; MST[PrimitiveReturnsMutator]MSP[N] } int finalise ( final int hash , final int unprocessedLength , final byte [] unprocessed , final int totalLen ) { int result = hash ; int k1 = 0 ; switch ( unprocessedLength ) {
} totalLen += length ; MST[experimental.MemberVariableMutator]MSP[S] if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; MST[rv.UOI3Mutator]MSP[N] unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[rv.AOR4Mutator]MSP[N] break; case 3 :
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; MST[rv.UOI4Mutator]MSP[N] return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.CRCR3Mutator]MSP[N] break; case 2 :
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; newLength = length - consumed ; } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ; MST[rv.CRCR2Mutator]MSP[N]
final int consumed = ( nblocks << 2 ) ; MST[rv.ABSMutator]MSP[N] unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; } } public final int end () {
return finalise ( hash , unprocessedLength , unprocessed , totalLen ) ; } int finalise ( final int hash , final int unprocessedLength , final byte [] unprocessed , final int totalLen ) { int result = hash ; int k1 = 0 ; switch ( unprocessedLength ) { MST[rv.UOI3Mutator]MSP[N]
final int consumed = ( nblocks << 2 ) ; MST[rv.CRCR1Mutator]MSP[N] unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; } } public final int end () {
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { MST[rv.UOI3Mutator]MSP[N] System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.CRCR5Mutator]MSP[N] } @Override @Deprecated
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; MST[rv.AOD2Mutator]MSP[N] return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.CRCR4Mutator]MSP[N] } @Override @Deprecated
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.AOR1Mutator]MSP[N] break; case 2 :
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; MST[rv.CRCR5Mutator]MSP[N] case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.UOI3Mutator]MSP[N] break; case 2 :
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; MST[rv.UOI2Mutator]MSP[S] } } public final int end () {
} totalLen += length ; MST[rv.UOI1Mutator]MSP[N] if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ; MST[rv.AOR4Mutator]MSP[S] result ^= k1 ; } result ^= totalLen ; return fmix32 ( result ) ; }
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; newLength = length - consumed ; MST[rv.UOI1Mutator]MSP[N] } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ;
return finalise ( hash , unprocessedLength , unprocessed , totalLen ) ; MST[rv.UOI1Mutator]MSP[N] } int finalise ( final int hash , final int unprocessedLength , final byte [] unprocessed , final int totalLen ) { int result = hash ; int k1 = 0 ; switch ( unprocessedLength ) {
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; newLength = length - consumed ; } else { newOffset = offset ; MST[rv.UOI4Mutator]MSP[N] newLength = length ; } final int nblocks = newLength >> 2 ;
public final void start ( final int seed ) { unprocessedLength = totalLen = 0 ; MST[experimental.MemberVariableMutator]MSP[N] this . hash = seed ; } public final void add ( final byte [] data , final int offset , final int length ) { if ( length <= 0 ) { return;
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[rv.UOI3Mutator]MSP[N] break; case 3 :
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.OBBN2Mutator]MSP[N] } @Override @Deprecated
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[rv.UOI2Mutator]MSP[N] break; case 3 :
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.OBBN3Mutator]MSP[N] } @Override @Deprecated
public final void start ( final int seed ) { unprocessedLength = totalLen = 0 ; this . hash = seed ; MST[rv.ABSMutator]MSP[N] } public final void add ( final byte [] data , final int offset , final int length ) { if ( length <= 0 ) { return;
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; MST[rv.AOR4Mutator]MSP[N] newLength = length - consumed ; } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ;
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; MST[rv.CRCR3Mutator]MSP[N] k1 *= C2_32 ; result ^= k1 ; } result ^= totalLen ; return fmix32 ( result ) ; }
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ; MST[rv.ABSMutator]MSP[N] result ^= k1 ; } result ^= totalLen ; return fmix32 ( result ) ; }
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ; result ^= k1 ; MST[rv.UOI1Mutator]MSP[N] } result ^= totalLen ; return fmix32 ( result ) ; }
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ; result ^= k1 ; } result ^= totalLen ; MST[rv.UOI3Mutator]MSP[N] return fmix32 ( result ) ; }
final int consumed = BLOCK_SIZE - unprocessedLength ; MST[rv.AOR2Mutator]MSP[N] newOffset = offset + consumed ; newLength = length - consumed ; } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ;
return finalise ( hash , unprocessedLength , unprocessed , totalLen ) ; MST[NonVoidMethodCallMutator]MSP[N] } int finalise ( final int hash , final int unprocessedLength , final byte [] unprocessed , final int totalLen ) { int result = hash ; int k1 = 0 ; switch ( unprocessedLength ) {
for ( int i = 0 ; i < nblocks ; i ++ ) { final int index = newOffset + ( i << 2 ) ; MST[rv.UOI1Mutator]MSP[S] final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; }
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.CRCR2Mutator]MSP[N] } @Override @Deprecated
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.CRCR6Mutator]MSP[N] } @Override @Deprecated
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; newLength = length - consumed ; } else { newOffset = offset ; MST[rv.ABSMutator]MSP[N] newLength = length ; } final int nblocks = newLength >> 2 ;
final int consumed = BLOCK_SIZE - unprocessedLength ; MST[MathMutator]MSP[N] newOffset = offset + consumed ; newLength = length - consumed ; } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ;
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; MST[rv.UOI4Mutator]MSP[N] case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { MST[rv.AOR3Mutator]MSP[N] System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , unprocessed [ 2 ] , data [ offset ] ) ; MST[rv.UOI1Mutator]MSP[N] break; default: throw new IllegalStateException ( lr_1 + unprocessedLength ) ; } hash = mix32 ( k , hash ) ;
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.CRCR5Mutator]MSP[N] } @Override @Deprecated
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.UOI4Mutator]MSP[N] break; case 2 :
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; MST[rv.CRCR2Mutator]MSP[N] case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; MST[VoidMethodCallMutator]MSP[S] } } public final int end () {
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[MathMutator]MSP[N] } @Override @Deprecated
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; MST[rv.UOI2Mutator]MSP[N] k1 *= C1_32 ;
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; MST[rv.UOI3Mutator]MSP[N] k1 *= C1_32 ;
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[InlineConstantMutator]MSP[N] } @Override @Deprecated
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ; MST[rv.AOD1Mutator]MSP[S] result ^= k1 ; } result ^= totalLen ; return fmix32 ( result ) ; }
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , unprocessed [ 2 ] , data [ offset ] ) ; MST[rv.UOI3Mutator]MSP[N] break; default: throw new IllegalStateException ( lr_1 + unprocessedLength ) ; } hash = mix32 ( k , hash ) ;
public final void start ( final int seed ) { unprocessedLength = totalLen = 0 ; this . hash = seed ; } public final void add ( final byte [] data , final int offset , final int length ) { if ( length <= 0 ) { MST[ConditionalsBoundaryMutator]MSP[N] return;
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; MST[rv.UOI2Mutator]MSP[S] unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; MST[rv.UOI4Mutator]MSP[N] newLength = length - consumed ; } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ;
final int consumed = BLOCK_SIZE - unprocessedLength ; MST[rv.UOI2Mutator]MSP[N] newOffset = offset + consumed ; newLength = length - consumed ; } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ;
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ; MST[rv.CRCR4Mutator]MSP[S]
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ; result ^= k1 ; } result ^= totalLen ; MST[rv.UOI2Mutator]MSP[N] return fmix32 ( result ) ; }
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; MST[experimental.MemberVariableMutator]MSP[S] return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
int k = - 1 ; switch ( unprocessedLength ) { MST[rv.UOI2Mutator]MSP[N] case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; break; case 2 :
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[rv.CRCR3Mutator]MSP[N] break; case 3 :
for ( int i = 0 ; i < nblocks ; i ++ ) { final int index = newOffset + ( i << 2 ) ; MST[rv.AOR4Mutator]MSP[N] final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; }
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.UOI4Mutator]MSP[N] break; case 2 :
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; MST[rv.UOI1Mutator]MSP[N] k1 *= C2_32 ; result ^= k1 ; } result ^= totalLen ; return fmix32 ( result ) ; }
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; MST[rv.CRCR3Mutator]MSP[N] case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; MST[MathMutator]MSP[N] if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; } } public final int end () {
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; MST[rv.UOI3Mutator]MSP[N] if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; } } public final int end () {
return finalise ( hash , unprocessedLength , unprocessed , totalLen ) ; MST[rv.UOI3Mutator]MSP[N] } int finalise ( final int hash , final int unprocessedLength , final byte [] unprocessed , final int totalLen ) { int result = hash ; int k1 = 0 ; switch ( unprocessedLength ) {
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.UOI1Mutator]MSP[N] } @Override @Deprecated
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; MST[rv.AOR3Mutator]MSP[N] } } public final int end () {
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[MathMutator]MSP[N] } @Override @Deprecated
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; newLength = length - consumed ; } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ; MST[MathMutator]MSP[N]
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ; MST[rv.CRCR3Mutator]MSP[N] result ^= k1 ; } result ^= totalLen ; return fmix32 ( result ) ; }
int k = - 1 ; switch ( unprocessedLength ) { MST[experimental.RemoveSwitchMutator_2]MSP[N] case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; break; case 2 :
int k = - 1 ; switch ( unprocessedLength ) { MST[experimental.RemoveSwitchMutator_0]MSP[N] case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; break; case 2 :
for ( int i = 0 ; i < nblocks ; i ++ ) { final int index = newOffset + ( i << 2 ) ; final int k = getLittleEndianInt ( data , index ) ; MST[ArgumentPropagationMutator]MSP[N] hash = mix32 ( k , hash ) ; }
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; MST[rv.UOI2Mutator]MSP[N] case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
int k = - 1 ; switch ( unprocessedLength ) { MST[experimental.RemoveSwitchMutator_1]MSP[N] case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; break; case 2 :
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; MST[rv.AOR2Mutator]MSP[N] return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; newLength = length - consumed ; } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ; MST[rv.CRCR3Mutator]MSP[N]
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; MST[rv.AOD2Mutator]MSP[N] if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; } } public final int end () {
} totalLen += length ; MST[rv.UOI3Mutator]MSP[N] if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ; result ^= k1 ; MST[rv.UOI4Mutator]MSP[N] } result ^= totalLen ; return fmix32 ( result ) ; }
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { MST[rv.AOR1Mutator]MSP[N] System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; MST[rv.ABSMutator]MSP[N] } } public final int end () {
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; MST[rv.CRCR6Mutator]MSP[N] k1 *= C1_32 ;
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ; result ^= k1 ; } result ^= totalLen ; return fmix32 ( result ) ; MST[rv.UOI3Mutator]MSP[N] }
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[InlineConstantMutator]MSP[N] break; case 3 :
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , unprocessed [ 2 ] , data [ offset ] ) ; MST[rv.ABSMutator]MSP[N] break; default: throw new IllegalStateException ( lr_1 + unprocessedLength ) ; } hash = mix32 ( k , hash ) ;
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.CRCR5Mutator]MSP[N] } @Override @Deprecated
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.CRCR1Mutator]MSP[N] } @Override @Deprecated
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; MST[rv.UOI2Mutator]MSP[N] } } public final int end () {
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ; result ^= k1 ; } result ^= totalLen ; MST[rv.ABSMutator]MSP[S] return fmix32 ( result ) ; }
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; newLength = length - consumed ; } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ; MST[rv.UOI3Mutator]MSP[N]
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; MST[MathMutator]MSP[S] case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.ABSMutator]MSP[N] break; case 2 :
for ( int i = 0 ; i < nblocks ; i ++ ) { final int index = newOffset + ( i << 2 ) ; MST[rv.AOD2Mutator]MSP[N] final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; }
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; MST[InlineConstantMutator]MSP[N] case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; MST[rv.UOI1Mutator]MSP[N] return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.AOD1Mutator]MSP[N] break; case 2 :
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.CRCR3Mutator]MSP[N] break; case 2 :
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; MST[rv.ABSMutator]MSP[N] case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , unprocessed [ 2 ] , data [ offset ] ) ; break; default: throw new IllegalStateException ( lr_1 + unprocessedLength ) ; } hash = mix32 ( k , hash ) ; MST[experimental.MemberVariableMutator]MSP[N]
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , unprocessed [ 2 ] , data [ offset ] ) ; MST[InlineConstantMutator]MSP[N] break; default: throw new IllegalStateException ( lr_1 + unprocessedLength ) ; } hash = mix32 ( k , hash ) ;
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[rv.ABSMutator]MSP[N] break; case 3 :
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , unprocessed [ 2 ] , data [ offset ] ) ; MST[rv.UOI1Mutator]MSP[N] break; default: throw new IllegalStateException ( lr_1 + unprocessedLength ) ; } hash = mix32 ( k , hash ) ;
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[InlineConstantMutator]MSP[N] } @Override @Deprecated
for ( int i = 0 ; i < nblocks ; i ++ ) { final int index = newOffset + ( i << 2 ) ; final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; MST[rv.UOI3Mutator]MSP[N] }
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[MathMutator]MSP[N] break; case 2 :
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[rv.UOI4Mutator]MSP[N] break; case 3 :
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; newLength = length - consumed ; MST[rv.ABSMutator]MSP[N] } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ;
public final void start ( final int seed ) { unprocessedLength = totalLen = 0 ; this . hash = seed ; MST[rv.UOI4Mutator]MSP[N] } public final void add ( final byte [] data , final int offset , final int length ) { if ( length <= 0 ) { return;
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[InlineConstantMutator]MSP[N] break; case 2 :
} totalLen += length ; MST[rv.UOI2Mutator]MSP[N] if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; newLength = length - consumed ; MST[rv.AOD2Mutator]MSP[N] } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ;
for ( int i = 0 ; i < nblocks ; i ++ ) { MST[rv.UOI1Mutator]MSP[N] final int index = newOffset + ( i << 2 ) ; final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; }
return finalise ( hash , unprocessedLength , unprocessed , totalLen ) ; } int finalise ( final int hash , final int unprocessedLength , final byte [] unprocessed , final int totalLen ) { int result = hash ; int k1 = 0 ; switch ( unprocessedLength ) { MST[rv.UOI1Mutator]MSP[N]
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; MST[MathMutator]MSP[N] case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
public final void start ( final int seed ) { unprocessedLength = totalLen = 0 ; this . hash = seed ; } public final void add ( final byte [] data , final int offset , final int length ) { if ( length <= 0 ) { MST[NegateConditionalsMutator]MSP[S] return;
final int consumed = ( nblocks << 2 ) ; MST[rv.CRCR2Mutator]MSP[N] unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; } } public final int end () {
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; MST[rv.CRCR3Mutator]MSP[N] case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
return finalise ( hash , unprocessedLength , unprocessed , totalLen ) ; } int finalise ( final int hash , final int unprocessedLength , final byte [] unprocessed , final int totalLen ) { int result = hash ; MST[rv.UOI4Mutator]MSP[N] int k1 = 0 ; switch ( unprocessedLength ) {
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; MST[rv.CRCR6Mutator]MSP[S] case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; MST[rv.UOI3Mutator]MSP[N] } } public final int end () {
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ; MST[rv.UOI3Mutator]MSP[S] result ^= k1 ; } result ^= totalLen ; return fmix32 ( result ) ; }
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.OBBN1Mutator]MSP[N] } @Override @Deprecated
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { MST[rv.ROR3Mutator]MSP[N] System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ; MST[rv.AOR1Mutator]MSP[N]
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.OBBN2Mutator]MSP[N] } @Override @Deprecated
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; MST[rv.UOI3Mutator]MSP[N] unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
final int consumed = BLOCK_SIZE - unprocessedLength ; MST[rv.UOI3Mutator]MSP[N] newOffset = offset + consumed ; newLength = length - consumed ; } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ;
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; MST[rv.ABSMutator]MSP[N] k1 *= C1_32 ;
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; MST[rv.AOR2Mutator]MSP[N] newLength = length - consumed ; } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ;
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; MST[rv.UOI3Mutator]MSP[N] case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; MST[rv.CRCR3Mutator]MSP[N] k1 *= C1_32 ;
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { MST[rv.ROR2Mutator]MSP[N] System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; } } public final int end () {
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; MST[rv.CRCR6Mutator]MSP[N] k1 *= C1_32 ;
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.CRCR5Mutator]MSP[N] } @Override @Deprecated
public final void start ( final int seed ) { unprocessedLength = totalLen = 0 ; this . hash = seed ; } public final void add ( final byte [] data , final int offset , final int length ) { if ( length <= 0 ) { MST[rv.ROR1Mutator]MSP[S] return;
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.AOR3Mutator]MSP[N] break; case 2 :
for ( int i = 0 ; i < nblocks ; i ++ ) { MST[rv.ABSMutator]MSP[S] final int index = newOffset + ( i << 2 ) ; final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; }
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; newLength = length - consumed ; MST[MathMutator]MSP[S] } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ;
public final void start ( final int seed ) { unprocessedLength = totalLen = 0 ; MST[rv.CRCR6Mutator]MSP[N] this . hash = seed ; } public final void add ( final byte [] data , final int offset , final int length ) { if ( length <= 0 ) { return;
return finalise ( hash , unprocessedLength , unprocessed , totalLen ) ; MST[ArgumentPropagationMutator]MSP[N] } int finalise ( final int hash , final int unprocessedLength , final byte [] unprocessed , final int totalLen ) { int result = hash ; int k1 = 0 ; switch ( unprocessedLength ) {
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.AOD2Mutator]MSP[N] break; case 2 :
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; MST[InlineConstantMutator]MSP[S] k1 *= C1_32 ;
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) { MST[rv.UOI4Mutator]MSP[N]
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.CRCR2Mutator]MSP[N] break; case 2 :
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; MST[ArgumentPropagationMutator]MSP[S] k1 *= C2_32 ; result ^= k1 ; } result ^= totalLen ; return fmix32 ( result ) ; }
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ; MST[rv.UOI4Mutator]MSP[S]
for ( int i = 0 ; i < nblocks ; i ++ ) { final int index = newOffset + ( i << 2 ) ; MST[rv.CRCR4Mutator]MSP[N] final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; }
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; MST[rv.AOD1Mutator]MSP[N] } } public final int end () {
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[rv.UOI4Mutator]MSP[N] break; case 3 :
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[rv.UOI3Mutator]MSP[N] break; case 3 :
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[rv.AOR2Mutator]MSP[N] break; case 3 :
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.OBBN3Mutator]MSP[N] } @Override @Deprecated
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.OBBN2Mutator]MSP[N] } @Override @Deprecated
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.UOI3Mutator]MSP[N] break; case 2 :
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.UOI1Mutator]MSP[N] break; case 2 :
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , unprocessed [ 2 ] , data [ offset ] ) ; MST[rv.CRCR5Mutator]MSP[N] break; default: throw new IllegalStateException ( lr_1 + unprocessedLength ) ; } hash = mix32 ( k , hash ) ;
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; newLength = length - consumed ; } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ; MST[rv.ABSMutator]MSP[N]
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ; result ^= k1 ; MST[rv.UOI3Mutator]MSP[S] } result ^= totalLen ; return fmix32 ( result ) ; }
int k = - 1 ; MST[rv.CRCR2Mutator]MSP[N] switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; break; case 2 :
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; MST[InlineConstantMutator]MSP[N] case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , unprocessed [ 2 ] , data [ offset ] ) ; MST[rv.CRCR1Mutator]MSP[N] break; default: throw new IllegalStateException ( lr_1 + unprocessedLength ) ; } hash = mix32 ( k , hash ) ;
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , unprocessed [ 2 ] , data [ offset ] ) ; MST[rv.UOI3Mutator]MSP[N] break; default: throw new IllegalStateException ( lr_1 + unprocessedLength ) ; } hash = mix32 ( k , hash ) ;
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; MST[rv.UOI4Mutator]MSP[N] k1 *= C2_32 ; result ^= k1 ; } result ^= totalLen ; return fmix32 ( result ) ; }
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[rv.CRCR3Mutator]MSP[N] break; case 3 :
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; MST[rv.UOI3Mutator]MSP[N] } } public final int end () {
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; MST[MathMutator]MSP[S] k1 *= C1_32 ;
final int consumed = BLOCK_SIZE - unprocessedLength ; MST[rv.CRCR4Mutator]MSP[N] newOffset = offset + consumed ; newLength = length - consumed ; } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ;
} totalLen += length ; MST[rv.ABSMutator]MSP[S] if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
for ( int i = 0 ; i < nblocks ; i ++ ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] final int index = newOffset + ( i << 2 ) ; final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; }
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; MST[rv.CRCR5Mutator]MSP[N] case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
final int consumed = ( nblocks << 2 ) ; MST[rv.UOI2Mutator]MSP[N] unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; } } public final int end () {
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; MST[rv.UOI4Mutator]MSP[N] if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; } } public final int end () {
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.OBBN1Mutator]MSP[N] } @Override @Deprecated
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.OBBN3Mutator]MSP[N] } @Override @Deprecated
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; MST[rv.CRCR3Mutator]MSP[S] case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
} totalLen += length ; MST[rv.AOD1Mutator]MSP[S] if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[rv.CRCR5Mutator]MSP[N] break; case 3 :
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[NonVoidMethodCallMutator]MSP[N] break; case 3 :
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) { MST[rv.ROR2Mutator]MSP[N]
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) { MST[rv.UOI1Mutator]MSP[N]
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; newLength = length - consumed ; MST[rv.AOR2Mutator]MSP[S] } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ;
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; newLength = length - consumed ; MST[rv.AOR4Mutator]MSP[N] } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ;
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; MST[rv.ABSMutator]MSP[N] if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; } } public final int end () {
return finalise ( hash , unprocessedLength , unprocessed , totalLen ) ; MST[rv.ABSMutator]MSP[N] } int finalise ( final int hash , final int unprocessedLength , final byte [] unprocessed , final int totalLen ) { int result = hash ; int k1 = 0 ; switch ( unprocessedLength ) {
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[rv.UOI1Mutator]MSP[N] break; case 3 :
public final void start ( final int seed ) { unprocessedLength = totalLen = 0 ; this . hash = seed ; MST[rv.UOI1Mutator]MSP[N] } public final void add ( final byte [] data , final int offset , final int length ) { if ( length <= 0 ) { return;
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[rv.UOI2Mutator]MSP[N] break; case 3 :
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.CRCR3Mutator]MSP[N] } @Override @Deprecated
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; MST[rv.CRCR1Mutator]MSP[N] k1 *= C1_32 ;
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.UOI4Mutator]MSP[N] break; case 2 :
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; MST[rv.UOI2Mutator]MSP[N] case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ; result ^= k1 ; } result ^= totalLen ; MST[rv.UOI1Mutator]MSP[N] return fmix32 ( result ) ; }
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; MST[InlineConstantMutator]MSP[S] case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.UOI2Mutator]MSP[N] break; case 2 :
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.AOR1Mutator]MSP[N] break; case 2 :
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[rv.ABSMutator]MSP[N] break; case 3 :
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[InlineConstantMutator]MSP[N] } @Override @Deprecated
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { MST[rv.CRCR2Mutator]MSP[S] System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , unprocessed [ 2 ] , data [ offset ] ) ; MST[InlineConstantMutator]MSP[N] break; default: throw new IllegalStateException ( lr_1 + unprocessedLength ) ; } hash = mix32 ( k , hash ) ;
for ( int i = 0 ; i < nblocks ; i ++ ) { final int index = newOffset + ( i << 2 ) ; MST[rv.CRCR6Mutator]MSP[N] final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; }
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; MST[rv.UOI1Mutator]MSP[S] k1 *= C1_32 ;
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , unprocessed [ 2 ] , data [ offset ] ) ; MST[rv.UOI1Mutator]MSP[N] break; default: throw new IllegalStateException ( lr_1 + unprocessedLength ) ; } hash = mix32 ( k , hash ) ;
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.OBBN3Mutator]MSP[N] } @Override @Deprecated
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , unprocessed [ 2 ] , data [ offset ] ) ; MST[rv.CRCR3Mutator]MSP[N] break; default: throw new IllegalStateException ( lr_1 + unprocessedLength ) ; } hash = mix32 ( k , hash ) ;
for ( int i = 0 ; i < nblocks ; i ++ ) { MST[rv.CRCR1Mutator]MSP[S] final int index = newOffset + ( i << 2 ) ; final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; }
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; MST[rv.CRCR6Mutator]MSP[N] } } public final int end () {
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.UOI3Mutator]MSP[N] break; case 2 :
for ( int i = 0 ; i < nblocks ; i ++ ) { final int index = newOffset + ( i << 2 ) ; MST[rv.UOI3Mutator]MSP[N] final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; }
} totalLen += length ; MST[rv.UOI4Mutator]MSP[S] if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.CRCR2Mutator]MSP[N] } @Override @Deprecated
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.UOI1Mutator]MSP[N] break; case 2 :
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; MST[rv.UOI3Mutator]MSP[N] case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
final int consumed = BLOCK_SIZE - unprocessedLength ; MST[rv.AOD1Mutator]MSP[N] newOffset = offset + consumed ; newLength = length - consumed ; } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ;
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , unprocessed [ 2 ] , data [ offset ] ) ; MST[rv.UOI3Mutator]MSP[S] break; default: throw new IllegalStateException ( lr_1 + unprocessedLength ) ; } hash = mix32 ( k , hash ) ;
} totalLen += length ; MST[rv.AOR3Mutator]MSP[S] if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; newLength = length - consumed ; } else { newOffset = offset ; newLength = length ; MST[rv.UOI2Mutator]MSP[N] } final int nblocks = newLength >> 2 ;
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.ABSMutator]MSP[N] } @Override @Deprecated
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { MST[rv.UOI1Mutator]MSP[N] System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; MST[rv.CRCR3Mutator]MSP[S] case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.AOR4Mutator]MSP[N] break; case 2 :
return finalise ( hash , unprocessedLength , unprocessed , totalLen ) ; } int finalise ( final int hash , final int unprocessedLength , final byte [] unprocessed , final int totalLen ) { int result = hash ; MST[rv.UOI2Mutator]MSP[N] int k1 = 0 ; switch ( unprocessedLength ) {
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ; MST[rv.UOI1Mutator]MSP[N] result ^= k1 ; } result ^= totalLen ; return fmix32 ( result ) ; }
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; MST[rv.CRCR5Mutator]MSP[S] case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; MST[rv.CRCR3Mutator]MSP[N] case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.UOI3Mutator]MSP[N] } @Override @Deprecated
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[MathMutator]MSP[N] } @Override @Deprecated
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ; MST[rv.AOR3Mutator]MSP[S]
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; MST[rv.ABSMutator]MSP[N] unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
return finalise ( hash , unprocessedLength , unprocessed , totalLen ) ; MST[rv.UOI3Mutator]MSP[N] } int finalise ( final int hash , final int unprocessedLength , final byte [] unprocessed , final int totalLen ) { int result = hash ; int k1 = 0 ; switch ( unprocessedLength ) {
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; MST[rv.UOI3Mutator]MSP[S] unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; MST[rv.CRCR1Mutator]MSP[S] k1 *= C2_32 ; result ^= k1 ; } result ^= totalLen ; return fmix32 ( result ) ; }
return finalise ( hash , unprocessedLength , unprocessed , totalLen ) ; MST[rv.ABSMutator]MSP[N] } int finalise ( final int hash , final int unprocessedLength , final byte [] unprocessed , final int totalLen ) { int result = hash ; int k1 = 0 ; switch ( unprocessedLength ) {
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , unprocessed [ 2 ] , data [ offset ] ) ; break; default: throw new IllegalStateException ( lr_1 + unprocessedLength ) ; } hash = mix32 ( k , hash ) ; MST[rv.UOI2Mutator]MSP[N]
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ; MST[MathMutator]MSP[S] result ^= k1 ; } result ^= totalLen ; return fmix32 ( result ) ; }
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[rv.UOI1Mutator]MSP[N] break; case 3 :
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ; MST[InlineConstantMutator]MSP[S] result ^= k1 ; } result ^= totalLen ; return fmix32 ( result ) ; }
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; MST[rv.UOI1Mutator]MSP[N] case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.CRCR5Mutator]MSP[N] } @Override @Deprecated
for ( int i = 0 ; i < nblocks ; i ++ ) { final int index = newOffset + ( i << 2 ) ; MST[rv.UOI4Mutator]MSP[N] final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; }
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; MST[rv.CRCR1Mutator]MSP[S] k1 *= C1_32 ;
for ( int i = 0 ; i < nblocks ; i ++ ) { MST[rv.UOI2Mutator]MSP[N] final int index = newOffset + ( i << 2 ) ; final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; }
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , unprocessed [ 2 ] , data [ offset ] ) ; MST[rv.ABSMutator]MSP[N] break; default: throw new IllegalStateException ( lr_1 + unprocessedLength ) ; } hash = mix32 ( k , hash ) ;
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , unprocessed [ 2 ] , data [ offset ] ) ; break; default: throw new IllegalStateException ( lr_1 + unprocessedLength ) ; } hash = mix32 ( k , hash ) ; MST[rv.UOI2Mutator]MSP[N]
for ( int i = 0 ; i < nblocks ; i ++ ) { final int index = newOffset + ( i << 2 ) ; final int k = getLittleEndianInt ( data , index ) ; MST[rv.UOI1Mutator]MSP[N] hash = mix32 ( k , hash ) ; }
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.CRCR3Mutator]MSP[N] } @Override @Deprecated
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.CRCR2Mutator]MSP[N] } @Override @Deprecated
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; MST[MathMutator]MSP[N] return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
for ( int i = 0 ; i < nblocks ; i ++ ) { final int index = newOffset + ( i << 2 ) ; MST[rv.ABSMutator]MSP[N] final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; }
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; MST[MathMutator]MSP[S] case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { MST[NegateConditionalsMutator]MSP[N] System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
return finalise ( hash , unprocessedLength , unprocessed , totalLen ) ; } int finalise ( final int hash , final int unprocessedLength , final byte [] unprocessed , final int totalLen ) { int result = hash ; int k1 = 0 ; switch ( unprocessedLength ) { MST[experimental.RemoveSwitchMutator_0]MSP[N]
return finalise ( hash , unprocessedLength , unprocessed , totalLen ) ; } int finalise ( final int hash , final int unprocessedLength , final byte [] unprocessed , final int totalLen ) { int result = hash ; int k1 = 0 ; switch ( unprocessedLength ) { MST[experimental.RemoveSwitchMutator_2]MSP[S]
return finalise ( hash , unprocessedLength , unprocessed , totalLen ) ; } int finalise ( final int hash , final int unprocessedLength , final byte [] unprocessed , final int totalLen ) { int result = hash ; int k1 = 0 ; switch ( unprocessedLength ) { MST[experimental.RemoveSwitchMutator_1]MSP[N]
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.ABSMutator]MSP[N] break; case 2 :
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; MST[InlineConstantMutator]MSP[N] case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.UOI2Mutator]MSP[N] break; case 2 :
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; newLength = length - consumed ; MST[rv.UOI3Mutator]MSP[S] } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ;
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[InlineConstantMutator]MSP[N] } @Override @Deprecated
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; } } public final int end () {
for ( int i = 0 ; i < nblocks ; i ++ ) { final int index = newOffset + ( i << 2 ) ; final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; MST[rv.ABSMutator]MSP[S] }
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.CRCR5Mutator]MSP[N] break; case 2 :
return finalise ( hash , unprocessedLength , unprocessed , totalLen ) ; } int finalise ( final int hash , final int unprocessedLength , final byte [] unprocessed , final int totalLen ) { int result = hash ; int k1 = 0 ; MST[rv.CRCR5Mutator]MSP[S] switch ( unprocessedLength ) {
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { MST[rv.UOI1Mutator]MSP[N] System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; } } public final int end () {
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[rv.UOI3Mutator]MSP[N] break; case 3 :
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; MST[rv.AOR4Mutator]MSP[N] if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; } } public final int end () {
for ( int i = 0 ; i < nblocks ; i ++ ) { final int index = newOffset + ( i << 2 ) ; final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; MST[rv.UOI3Mutator]MSP[S] }
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[MathMutator]MSP[N] } @Override @Deprecated
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; MST[rv.CRCR6Mutator]MSP[S] k1 *= C2_32 ; result ^= k1 ; } result ^= totalLen ; return fmix32 ( result ) ; }
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.CRCR1Mutator]MSP[N] break; case 2 :
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; MST[rv.UOI1Mutator]MSP[N] newLength = length - consumed ; } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ;
for ( int i = 0 ; i < nblocks ; i ++ ) { MST[NegateConditionalsMutator]MSP[N] final int index = newOffset + ( i << 2 ) ; final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; }
for ( int i = 0 ; i < nblocks ; i ++ ) { final int index = newOffset + ( i << 2 ) ; final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; MST[ArgumentPropagationMutator]MSP[N] }
for ( int i = 0 ; i < nblocks ; i ++ ) { final int index = newOffset + ( i << 2 ) ; MST[rv.AOR2Mutator]MSP[N] final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; }
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , unprocessed [ 2 ] , data [ offset ] ) ; MST[rv.UOI4Mutator]MSP[N] break; default: throw new IllegalStateException ( lr_1 + unprocessedLength ) ; } hash = mix32 ( k , hash ) ;
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; MST[rv.UOI4Mutator]MSP[S] } } public final int end () {
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { MST[rv.AOD2Mutator]MSP[N] System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.UOI2Mutator]MSP[N] break; case 2 :
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; MST[rv.CRCR1Mutator]MSP[N] case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; MST[rv.OBBN2Mutator]MSP[N] k1 *= C1_32 ;
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.UOI4Mutator]MSP[N] break; case 2 :
final int consumed = BLOCK_SIZE - unprocessedLength ; MST[rv.CRCR5Mutator]MSP[N] newOffset = offset + consumed ; newLength = length - consumed ; } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ;
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; MST[rv.UOI4Mutator]MSP[S] k1 *= C1_32 ;
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; MST[rv.UOI3Mutator]MSP[S] k1 *= C1_32 ;
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; newLength = length - consumed ; MST[rv.UOI4Mutator]MSP[N] } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ;
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[rv.ABSMutator]MSP[N] break; case 3 :
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; MST[rv.AOR1Mutator]MSP[N] } } public final int end () {
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { MST[rv.CRCR3Mutator]MSP[S] System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , unprocessed [ 2 ] , data [ offset ] ) ; MST[rv.UOI2Mutator]MSP[N] break; default: throw new IllegalStateException ( lr_1 + unprocessedLength ) ; } hash = mix32 ( k , hash ) ;
for ( int i = 0 ; i < nblocks ; i ++ ) { final int index = newOffset + ( i << 2 ) ; MST[rv.CRCR5Mutator]MSP[S] final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; }
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) { MST[rv.ABSMutator]MSP[N]
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[rv.UOI4Mutator]MSP[N] break; case 3 :
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ; MST[rv.CRCR1Mutator]MSP[S] result ^= k1 ; } result ^= totalLen ; return fmix32 ( result ) ; }
for ( int i = 0 ; i < nblocks ; i ++ ) { final int index = newOffset + ( i << 2 ) ; final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; MST[rv.UOI4Mutator]MSP[S] }
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , unprocessed [ 2 ] , data [ offset ] ) ; MST[rv.CRCR4Mutator]MSP[N] break; default: throw new IllegalStateException ( lr_1 + unprocessedLength ) ; } hash = mix32 ( k , hash ) ;
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; MST[rv.CRCR5Mutator]MSP[N] } } public final int end () {
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; MST[rv.UOI3Mutator]MSP[N] newLength = length - consumed ; } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ;
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; newLength = length - consumed ; } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ; MST[rv.CRCR1Mutator]MSP[N]
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { MST[MathMutator]MSP[S] System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; MST[rv.CRCR4Mutator]MSP[N] k1 *= C1_32 ;
for ( int i = 0 ; i < nblocks ; i ++ ) { MST[rv.ROR5Mutator]MSP[S] final int index = newOffset + ( i << 2 ) ; final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; }
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.ABSMutator]MSP[N] break; case 2 :
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.CRCR1Mutator]MSP[N] } @Override @Deprecated
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.UOI3Mutator]MSP[N] break; case 2 :
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.CRCR6Mutator]MSP[N] } @Override @Deprecated
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.CRCR3Mutator]MSP[N] } @Override @Deprecated
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.AOR4Mutator]MSP[N] break; case 2 :
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; MST[rv.CRCR6Mutator]MSP[N] case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , unprocessed [ 2 ] , data [ offset ] ) ; MST[InlineConstantMutator]MSP[N] break; default: throw new IllegalStateException ( lr_1 + unprocessedLength ) ; } hash = mix32 ( k , hash ) ;
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.OBBN3Mutator]MSP[N] } @Override @Deprecated
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.OBBN2Mutator]MSP[N] } @Override @Deprecated
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) { MST[rv.UOI2Mutator]MSP[N]
return finalise ( hash , unprocessedLength , unprocessed , totalLen ) ; } int finalise ( final int hash , final int unprocessedLength , final byte [] unprocessed , final int totalLen ) { int result = hash ; int k1 = 0 ; MST[rv.CRCR3Mutator]MSP[N] switch ( unprocessedLength ) {
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ; MST[rv.UOI2Mutator]MSP[N]
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; newLength = length - consumed ; } else { newOffset = offset ; MST[rv.UOI3Mutator]MSP[S] newLength = length ; } final int nblocks = newLength >> 2 ;
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ; result ^= k1 ; } result ^= totalLen ; return fmix32 ( result ) ; MST[PrimitiveReturnsMutator]MSP[N] }
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; MST[rv.UOI4Mutator]MSP[N] unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; MST[rv.AOR2Mutator]MSP[N] if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; } } public final int end () {
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) { MST[rv.ROR3Mutator]MSP[N]
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[InlineConstantMutator]MSP[N] break; case 2 :
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , unprocessed [ 2 ] , data [ offset ] ) ; MST[rv.ABSMutator]MSP[N] break; default: throw new IllegalStateException ( lr_1 + unprocessedLength ) ; } hash = mix32 ( k , hash ) ;
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[rv.UOI1Mutator]MSP[N] break; case 3 :
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[rv.UOI2Mutator]MSP[N] break; case 3 :
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ; MST[rv.CRCR2Mutator]MSP[S]
return finalise ( hash , unprocessedLength , unprocessed , totalLen ) ; } int finalise ( final int hash , final int unprocessedLength , final byte [] unprocessed , final int totalLen ) { int result = hash ; int k1 = 0 ; switch ( unprocessedLength ) { MST[rv.UOI4Mutator]MSP[S]
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { MST[rv.UOI2Mutator]MSP[S] System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.CRCR3Mutator]MSP[N] } @Override @Deprecated
return finalise ( hash , unprocessedLength , unprocessed , totalLen ) ; MST[rv.ABSMutator]MSP[S] } int finalise ( final int hash , final int unprocessedLength , final byte [] unprocessed , final int totalLen ) { int result = hash ; int k1 = 0 ; switch ( unprocessedLength ) {
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; MST[rv.UOI1Mutator]MSP[N] case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.CRCR6Mutator]MSP[N] } @Override @Deprecated
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.AOR2Mutator]MSP[N] break; case 2 :
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; MST[rv.CRCR4Mutator]MSP[N] case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.ABSMutator]MSP[N] break; case 2 :
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; newLength = length - consumed ; } else { newOffset = offset ; newLength = length ; MST[rv.UOI3Mutator]MSP[S] } final int nblocks = newLength >> 2 ;
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[InlineConstantMutator]MSP[N] break; case 3 :
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; MST[rv.UOI1Mutator]MSP[N] } } public final int end () {
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.UOI2Mutator]MSP[N] break; case 2 :
for ( int i = 0 ; i < nblocks ; i ++ ) { MST[rv.UOI4Mutator]MSP[N] final int index = newOffset + ( i << 2 ) ; final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; }
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ; MST[rv.AOR2Mutator]MSP[S] result ^= k1 ; } result ^= totalLen ; return fmix32 ( result ) ; }
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; MST[rv.UOI1Mutator]MSP[N] unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ; MST[InlineConstantMutator]MSP[S]
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { MST[rv.UOI2Mutator]MSP[N] System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; } } public final int end () {
return finalise ( hash , unprocessedLength , unprocessed , totalLen ) ; } int finalise ( final int hash , final int unprocessedLength , final byte [] unprocessed , final int totalLen ) { int result = hash ; int k1 = 0 ; MST[rv.CRCR6Mutator]MSP[S] switch ( unprocessedLength ) {
final int consumed = BLOCK_SIZE - unprocessedLength ; MST[rv.UOI1Mutator]MSP[N] newOffset = offset + consumed ; newLength = length - consumed ; } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ;
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; MST[rv.UOI3Mutator]MSP[N] return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[MathMutator]MSP[N] } @Override @Deprecated
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { MST[MathMutator]MSP[N] System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; MST[rv.UOI2Mutator]MSP[N] newLength = length - consumed ; } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ;
public final void start ( final int seed ) { unprocessedLength = totalLen = 0 ; this . hash = seed ; } public final void add ( final byte [] data , final int offset , final int length ) { if ( length <= 0 ) { MST[rv.ROR4Mutator]MSP[S] return;
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ; result ^= k1 ; } result ^= totalLen ; MST[rv.UOI4Mutator]MSP[N] return fmix32 ( result ) ; }
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ; result ^= k1 ; MST[rv.UOI2Mutator]MSP[N] } result ^= totalLen ; return fmix32 ( result ) ; }
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; MST[rv.OBBN2Mutator]MSP[S] case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.CRCR1Mutator]MSP[N] } @Override @Deprecated
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ; result ^= k1 ; } result ^= totalLen ; return fmix32 ( result ) ; MST[rv.UOI1Mutator]MSP[N] }
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , unprocessed [ 2 ] , data [ offset ] ) ; break; default: throw new IllegalStateException ( lr_1 + unprocessedLength ) ; } hash = mix32 ( k , hash ) ; MST[rv.UOI3Mutator]MSP[N]
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ; MST[rv.ABSMutator]MSP[N]
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.CRCR4Mutator]MSP[N] } @Override @Deprecated
public final void start ( final int seed ) { unprocessedLength = totalLen = 0 ; MST[rv.CRCR1Mutator]MSP[N] this . hash = seed ; } public final void add ( final byte [] data , final int offset , final int length ) { if ( length <= 0 ) { return;
for ( int i = 0 ; i < nblocks ; i ++ ) { MST[rv.UOI3Mutator]MSP[S] final int index = newOffset + ( i << 2 ) ; final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; }
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; MST[rv.CRCR3Mutator]MSP[N] case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.CRCR3Mutator]MSP[N] } @Override @Deprecated
return finalise ( hash , unprocessedLength , unprocessed , totalLen ) ; } int finalise ( final int hash , final int unprocessedLength , final byte [] unprocessed , final int totalLen ) { int result = hash ; MST[rv.ABSMutator]MSP[N] int k1 = 0 ; switch ( unprocessedLength ) {
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.CRCR6Mutator]MSP[N] } @Override @Deprecated
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.UOI3Mutator]MSP[N] break; case 2 :
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.CRCR1Mutator]MSP[N] break; case 2 :
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; MST[rv.ABSMutator]MSP[N] unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
return finalise ( hash , unprocessedLength , unprocessed , totalLen ) ; MST[rv.UOI2Mutator]MSP[N] } int finalise ( final int hash , final int unprocessedLength , final byte [] unprocessed , final int totalLen ) { int result = hash ; int k1 = 0 ; switch ( unprocessedLength ) {
public final void start ( final int seed ) { unprocessedLength = totalLen = 0 ; this . hash = seed ; } public final void add ( final byte [] data , final int offset , final int length ) { if ( length <= 0 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[S] return;
public final void start ( final int seed ) { unprocessedLength = totalLen = 0 ; this . hash = seed ; MST[experimental.MemberVariableMutator]MSP[N] } public final void add ( final byte [] data , final int offset , final int length ) { if ( length <= 0 ) { return;
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ; MST[rv.CRCR4Mutator]MSP[S] result ^= k1 ; } result ^= totalLen ; return fmix32 ( result ) ; }
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ; MST[rv.AOD1Mutator]MSP[S]
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[rv.UOI1Mutator]MSP[N] break; case 3 :
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[rv.UOI2Mutator]MSP[N] break; case 3 :
final int consumed = ( nblocks << 2 ) ; MST[rv.UOI3Mutator]MSP[N] unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; } } public final int end () {
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.OBBN1Mutator]MSP[N] } @Override @Deprecated
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ; result ^= k1 ; } result ^= totalLen ; return fmix32 ( result ) ; MST[ArgumentPropagationMutator]MSP[N] }
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.CRCR5Mutator]MSP[N] break; case 2 :
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[rv.UOI3Mutator]MSP[N] break; case 3 :
for ( int i = 0 ; i < nblocks ; i ++ ) { MST[InlineConstantMutator]MSP[N] final int index = newOffset + ( i << 2 ) ; final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; }
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; MST[MathMutator]MSP[N] case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ; result ^= k1 ; MST[rv.UOI1Mutator]MSP[N] } result ^= totalLen ; return fmix32 ( result ) ; }
int k = - 1 ; MST[rv.CRCR6Mutator]MSP[N] switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; break; case 2 :
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , unprocessed [ 2 ] , data [ offset ] ) ; MST[rv.CRCR4Mutator]MSP[N] break; default: throw new IllegalStateException ( lr_1 + unprocessedLength ) ; } hash = mix32 ( k , hash ) ;
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; MST[rv.AOD1Mutator]MSP[N] newLength = length - consumed ; } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ;
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ; result ^= k1 ; } result ^= totalLen ; MST[rv.UOI3Mutator]MSP[N] return fmix32 ( result ) ; }
final int consumed = BLOCK_SIZE - unprocessedLength ; MST[rv.CRCR2Mutator]MSP[N] newOffset = offset + consumed ; newLength = length - consumed ; } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ;
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N]
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; MST[rv.UOI2Mutator]MSP[N] k1 *= C2_32 ; result ^= k1 ; } result ^= totalLen ; return fmix32 ( result ) ; }
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , unprocessed [ 2 ] , data [ offset ] ) ; MST[rv.UOI1Mutator]MSP[N] break; default: throw new IllegalStateException ( lr_1 + unprocessedLength ) ; } hash = mix32 ( k , hash ) ;
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; MST[rv.ABSMutator]MSP[N] case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; MST[rv.CRCR6Mutator]MSP[S] case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.ABSMutator]MSP[N] } @Override @Deprecated
public final void start ( final int seed ) { unprocessedLength = totalLen = 0 ; this . hash = seed ; } public final void add ( final byte [] data , final int offset , final int length ) { if ( length <= 0 ) { MST[rv.UOI3Mutator]MSP[N] return;
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[rv.CRCR1Mutator]MSP[N] break; case 3 :
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; MST[rv.UOI1Mutator]MSP[N] } } public final int end () {
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; MST[rv.AOR4Mutator]MSP[N] } } public final int end () {
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.UOI1Mutator]MSP[N] break; case 2 :
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) { MST[ConditionalsBoundaryMutator]MSP[N]
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , unprocessed [ 2 ] , data [ offset ] ) ; MST[rv.UOI4Mutator]MSP[N] break; default: throw new IllegalStateException ( lr_1 + unprocessedLength ) ; } hash = mix32 ( k , hash ) ;
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; MST[rv.UOI2Mutator]MSP[N] if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; } } public final int end () {
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; MST[InlineConstantMutator]MSP[S] k1 *= C2_32 ; result ^= k1 ; } result ^= totalLen ; return fmix32 ( result ) ; }
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; } } public final int end () {
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; MST[InlineConstantMutator]MSP[N] } } public final int end () {
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; MST[rv.AOD2Mutator]MSP[N] } } public final int end () {
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ; result ^= k1 ; MST[MathMutator]MSP[S] } result ^= totalLen ; return fmix32 ( result ) ; }
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; MST[rv.UOI4Mutator]MSP[N] return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
public final void start ( final int seed ) { unprocessedLength = totalLen = 0 ; this . hash = seed ; MST[rv.UOI3Mutator]MSP[N] } public final void add ( final byte [] data , final int offset , final int length ) { if ( length <= 0 ) { return;
for ( int i = 0 ; i < nblocks ; i ++ ) { final int index = newOffset + ( i << 2 ) ; MST[InlineConstantMutator]MSP[N] final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; }
final int consumed = BLOCK_SIZE - unprocessedLength ; MST[rv.AOR1Mutator]MSP[N] newOffset = offset + consumed ; newLength = length - consumed ; } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ;
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[rv.AOD1Mutator]MSP[N] break; case 3 :
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , unprocessed [ 2 ] , data [ offset ] ) ; MST[rv.ABSMutator]MSP[N] break; default: throw new IllegalStateException ( lr_1 + unprocessedLength ) ; } hash = mix32 ( k , hash ) ;
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ; result ^= k1 ; } result ^= totalLen ; return fmix32 ( result ) ; MST[rv.UOI4Mutator]MSP[N] }
final int consumed = BLOCK_SIZE - unprocessedLength ; MST[InlineConstantMutator]MSP[N] newOffset = offset + consumed ; newLength = length - consumed ; } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ;
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { MST[rv.AOR4Mutator]MSP[N] System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { MST[rv.ROR5Mutator]MSP[N] System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; } } public final int end () {
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[rv.CRCR4Mutator]MSP[N] break; case 3 :
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , unprocessed [ 2 ] , data [ offset ] ) ; MST[rv.UOI2Mutator]MSP[N] break; default: throw new IllegalStateException ( lr_1 + unprocessedLength ) ; } hash = mix32 ( k , hash ) ;
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; MST[rv.CRCR1Mutator]MSP[N] case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { MST[rv.CRCR6Mutator]MSP[N] System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; MST[InlineConstantMutator]MSP[S] k1 *= C1_32 ;
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; newLength = length - consumed ; MST[rv.UOI1Mutator]MSP[N] } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ;
for ( int i = 0 ; i < nblocks ; i ++ ) { final int index = newOffset + ( i << 2 ) ; MST[rv.CRCR2Mutator]MSP[N] final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; }
public final void start ( final int seed ) { unprocessedLength = totalLen = 0 ; MST[experimental.MemberVariableMutator]MSP[N] this . hash = seed ; } public final void add ( final byte [] data , final int offset , final int length ) { if ( length <= 0 ) { return;
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[rv.UOI1Mutator]MSP[N] break; case 3 :
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[rv.UOI3Mutator]MSP[N] break; case 3 :
for ( int i = 0 ; i < nblocks ; i ++ ) { final int index = newOffset + ( i << 2 ) ; final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; MST[rv.UOI1Mutator]MSP[N] }
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ; MST[rv.CRCR6Mutator]MSP[S] result ^= k1 ; } result ^= totalLen ; return fmix32 ( result ) ; }
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; MST[rv.ABSMutator]MSP[N] return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.OBBN1Mutator]MSP[N] } @Override @Deprecated
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; MST[rv.AOR3Mutator]MSP[N] newLength = length - consumed ; } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ;
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; MST[rv.CRCR4Mutator]MSP[N] k1 *= C2_32 ; result ^= k1 ; } result ^= totalLen ; return fmix32 ( result ) ; }
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; MST[rv.OBBN2Mutator]MSP[S] case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
return finalise ( hash , unprocessedLength , unprocessed , totalLen ) ; } int finalise ( final int hash , final int unprocessedLength , final byte [] unprocessed , final int totalLen ) { int result = hash ; int k1 = 0 ; switch ( unprocessedLength ) { MST[rv.UOI2Mutator]MSP[N]
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; MST[rv.OBBN1Mutator]MSP[N] case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
for ( int i = 0 ; i < nblocks ; i ++ ) { final int index = newOffset + ( i << 2 ) ; MST[rv.UOI1Mutator]MSP[N] final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; }
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; MST[rv.CRCR1Mutator]MSP[N] case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { MST[rv.UOI4Mutator]MSP[S] System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
} totalLen += length ; MST[rv.AOR1Mutator]MSP[S] if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
final int consumed = ( nblocks << 2 ) ; MST[rv.CRCR6Mutator]MSP[N] unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; } } public final int end () {
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , unprocessed [ 2 ] , data [ offset ] ) ; MST[rv.UOI1Mutator]MSP[S] break; default: throw new IllegalStateException ( lr_1 + unprocessedLength ) ; } hash = mix32 ( k , hash ) ;
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; MST[rv.CRCR6Mutator]MSP[S] case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.UOI4Mutator]MSP[N] break; case 2 :
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.UOI1Mutator]MSP[N] break; case 2 :
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ; MST[rv.UOI4Mutator]MSP[S] result ^= k1 ; } result ^= totalLen ; return fmix32 ( result ) ; }
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[rv.ABSMutator]MSP[N] break; case 3 :
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; MST[rv.CRCR1Mutator]MSP[N] case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { MST[rv.UOI4Mutator]MSP[N] System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; } } public final int end () {
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.AOD2Mutator]MSP[N] break; case 2 :
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; MST[rv.UOI1Mutator]MSP[N] unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.UOI1Mutator]MSP[N] } @Override @Deprecated
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { MST[rv.ROR1Mutator]MSP[N] System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; MST[rv.UOI2Mutator]MSP[N] unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[rv.AOR3Mutator]MSP[N] break; case 3 :
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.ABSMutator]MSP[N] break; case 2 :
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; MST[NonVoidMethodCallMutator]MSP[S] k1 *= C2_32 ; result ^= k1 ; } result ^= totalLen ; return fmix32 ( result ) ; }
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.UOI2Mutator]MSP[N] break; case 2 :
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.CRCR3Mutator]MSP[N] } @Override @Deprecated
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { MST[rv.UOI3Mutator]MSP[N] System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
for ( int i = 0 ; i < nblocks ; i ++ ) { final int index = newOffset + ( i << 2 ) ; final int k = getLittleEndianInt ( data , index ) ; MST[rv.UOI4Mutator]MSP[N] hash = mix32 ( k , hash ) ; }
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { MST[rv.AOR4Mutator]MSP[N] System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { MST[rv.ABSMutator]MSP[N] System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; } } public final int end () {
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.CRCR1Mutator]MSP[N] } @Override @Deprecated
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[rv.CRCR5Mutator]MSP[N] break; case 3 :
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { MST[rv.ABSMutator]MSP[N] System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
for ( int i = 0 ; i < nblocks ; i ++ ) { MST[rv.ROR2Mutator]MSP[N] final int index = newOffset + ( i << 2 ) ; final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; }
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; MST[rv.CRCR1Mutator]MSP[N] case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
} totalLen += length ; MST[rv.UOI1Mutator]MSP[N] if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; MST[experimental.MemberVariableMutator]MSP[S] if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; } } public final int end () {
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.UOI4Mutator]MSP[N] } @Override @Deprecated
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.UOI3Mutator]MSP[N] } @Override @Deprecated
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; MST[rv.CRCR6Mutator]MSP[N] case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[ReturnValsMutator]MSP[N] } @Override @Deprecated
for ( int i = 0 ; i < nblocks ; i ++ ) { final int index = newOffset + ( i << 2 ) ; final int k = getLittleEndianInt ( data , index ) ; MST[rv.ABSMutator]MSP[N] hash = mix32 ( k , hash ) ; }
return finalise ( hash , unprocessedLength , unprocessed , totalLen ) ; MST[rv.UOI2Mutator]MSP[N] } int finalise ( final int hash , final int unprocessedLength , final byte [] unprocessed , final int totalLen ) { int result = hash ; int k1 = 0 ; switch ( unprocessedLength ) {
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) { MST[rv.ROR5Mutator]MSP[N]
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; MST[rv.UOI3Mutator]MSP[N] case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
for ( int i = 0 ; i < nblocks ; i ++ ) { final int index = newOffset + ( i << 2 ) ; final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; MST[rv.UOI1Mutator]MSP[N] }
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.CRCR6Mutator]MSP[N] break; case 2 :
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; MST[rv.ABSMutator]MSP[N] newLength = length - consumed ; } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ;
for ( int i = 0 ; i < nblocks ; i ++ ) { final int index = newOffset + ( i << 2 ) ; MST[MathMutator]MSP[N] final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; }
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; MST[rv.UOI4Mutator]MSP[N] case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.UOI2Mutator]MSP[N] break; case 2 :
int k = - 1 ; MST[rv.CRCR5Mutator]MSP[N] switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; break; case 2 :
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , unprocessed [ 2 ] , data [ offset ] ) ; MST[rv.CRCR6Mutator]MSP[N] break; default: throw new IllegalStateException ( lr_1 + unprocessedLength ) ; } hash = mix32 ( k , hash ) ;
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) { MST[rv.ROR1Mutator]MSP[N]
int k = - 1 ; MST[rv.CRCR1Mutator]MSP[N] switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; break; case 2 :
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; MST[rv.ABSMutator]MSP[N] } } public final int end () {
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , unprocessed [ 2 ] , data [ offset ] ) ; MST[rv.UOI2Mutator]MSP[N] break; default: throw new IllegalStateException ( lr_1 + unprocessedLength ) ; } hash = mix32 ( k , hash ) ;
public final void start ( final int seed ) { unprocessedLength = totalLen = 0 ; this . hash = seed ; } public final void add ( final byte [] data , final int offset , final int length ) { if ( length <= 0 ) { MST[rv.UOI4Mutator]MSP[S] return;
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ; MST[rv.AOD2Mutator]MSP[S] result ^= k1 ; } result ^= totalLen ; return fmix32 ( result ) ; }
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ; result ^= k1 ; } result ^= totalLen ; MST[rv.ABSMutator]MSP[N] return fmix32 ( result ) ; }
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; MST[rv.UOI2Mutator]MSP[N] } } public final int end () {
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ; result ^= k1 ; MST[rv.UOI4Mutator]MSP[S] } result ^= totalLen ; return fmix32 ( result ) ; }
final int consumed = BLOCK_SIZE - unprocessedLength ; MST[rv.CRCR3Mutator]MSP[N] newOffset = offset + consumed ; newLength = length - consumed ; } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ;
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { MST[rv.CRCR5Mutator]MSP[N] System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; MST[rv.UOI1Mutator]MSP[N] k1 *= C1_32 ;
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.UOI4Mutator]MSP[N] } @Override @Deprecated
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { MST[rv.CRCR1Mutator]MSP[N] System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; MST[rv.UOI2Mutator]MSP[S] k1 *= C1_32 ;
for ( int i = 0 ; i < nblocks ; i ++ ) { final int index = newOffset + ( i << 2 ) ; MST[rv.CRCR3Mutator]MSP[N] final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; }
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; MST[rv.CRCR3Mutator]MSP[N] } } public final int end () {
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[rv.UOI2Mutator]MSP[N] break; case 3 :
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.OBBN2Mutator]MSP[N] } @Override @Deprecated
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , unprocessed [ 2 ] , data [ offset ] ) ; MST[rv.CRCR2Mutator]MSP[N] break; default: throw new IllegalStateException ( lr_1 + unprocessedLength ) ; } hash = mix32 ( k , hash ) ;
for ( int i = 0 ; i < nblocks ; i ++ ) { final int index = newOffset + ( i << 2 ) ; final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; MST[rv.UOI2Mutator]MSP[N] }
for ( int i = 0 ; i < nblocks ; i ++ ) { final int index = newOffset + ( i << 2 ) ; MST[MathMutator]MSP[N] final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; }
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; MST[rv.UOI1Mutator]MSP[N] newLength = length - consumed ; } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ;
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.OBBN3Mutator]MSP[N] } @Override @Deprecated
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.UOI1Mutator]MSP[N] break; case 2 :
for ( int i = 0 ; i < nblocks ; i ++ ) { MST[rv.UOI1Mutator]MSP[N] final int index = newOffset + ( i << 2 ) ; final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; }
for ( int i = 0 ; i < nblocks ; i ++ ) { final int index = newOffset + ( i << 2 ) ; MST[rv.UOI3Mutator]MSP[S] final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; }
final int consumed = BLOCK_SIZE - unprocessedLength ; MST[rv.AOR4Mutator]MSP[N] newOffset = offset + consumed ; newLength = length - consumed ; } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ;
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { MST[rv.UOI4Mutator]MSP[N] System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { MST[rv.AOR2Mutator]MSP[N] System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ; result ^= k1 ; } result ^= totalLen ; MST[rv.UOI2Mutator]MSP[N] return fmix32 ( result ) ; }
int k = - 1 ; switch ( unprocessedLength ) { MST[rv.ABSMutator]MSP[N] case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; break; case 2 :
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; MST[rv.OBBN1Mutator]MSP[N] case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , unprocessed [ 2 ] , data [ offset ] ) ; MST[rv.UOI3Mutator]MSP[N] break; default: throw new IllegalStateException ( lr_1 + unprocessedLength ) ; } hash = mix32 ( k , hash ) ;
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; MST[rv.CRCR4Mutator]MSP[N] case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
public final void start ( final int seed ) { unprocessedLength = totalLen = 0 ; MST[rv.CRCR3Mutator]MSP[N] this . hash = seed ; } public final void add ( final byte [] data , final int offset , final int length ) { if ( length <= 0 ) { return;
final int consumed = ( nblocks << 2 ) ; MST[rv.UOI1Mutator]MSP[N] unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; } } public final int end () {
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[rv.CRCR6Mutator]MSP[N] break; case 3 :
return finalise ( hash , unprocessedLength , unprocessed , totalLen ) ; MST[rv.UOI4Mutator]MSP[N] } int finalise ( final int hash , final int unprocessedLength , final byte [] unprocessed , final int totalLen ) { int result = hash ; int k1 = 0 ; switch ( unprocessedLength ) {
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { MST[rv.ROR2Mutator]MSP[N] System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , unprocessed [ 2 ] , data [ offset ] ) ; break; default: throw new IllegalStateException ( lr_1 + unprocessedLength ) ; } hash = mix32 ( k , hash ) ; MST[rv.UOI1Mutator]MSP[N]
return finalise ( hash , unprocessedLength , unprocessed , totalLen ) ; MST[ReturnValsMutator]MSP[N] } int finalise ( final int hash , final int unprocessedLength , final byte [] unprocessed , final int totalLen ) { int result = hash ; int k1 = 0 ; switch ( unprocessedLength ) {
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; MST[rv.ABSMutator]MSP[N] k1 *= C1_32 ;
} totalLen += length ; MST[MathMutator]MSP[S] if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[rv.UOI1Mutator]MSP[N] break; case 3 :
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; newLength = length - consumed ; MST[rv.AOD1Mutator]MSP[S] } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ;
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.CRCR1Mutator]MSP[N] } @Override @Deprecated
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.UOI2Mutator]MSP[N] break; case 2 :
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; MST[rv.UOI4Mutator]MSP[N] case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; newLength = length - consumed ; } else { newOffset = offset ; newLength = length ; MST[rv.UOI1Mutator]MSP[N] } final int nblocks = newLength >> 2 ;
final int consumed = ( nblocks << 2 ) ; MST[rv.CRCR5Mutator]MSP[N] unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; } } public final int end () {
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , unprocessed [ 2 ] , data [ offset ] ) ; MST[rv.UOI2Mutator]MSP[N] break; default: throw new IllegalStateException ( lr_1 + unprocessedLength ) ; } hash = mix32 ( k , hash ) ;
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; MST[MathMutator]MSP[N] case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.ABSMutator]MSP[N] break; case 2 :
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; MST[rv.UOI4Mutator]MSP[S] } } public final int end () {
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ; MST[rv.AOR3Mutator]MSP[S] result ^= k1 ; } result ^= totalLen ; return fmix32 ( result ) ; }
for ( int i = 0 ; i < nblocks ; i ++ ) { MST[rv.ABSMutator]MSP[N] final int index = newOffset + ( i << 2 ) ; final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; }
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ; MST[rv.UOI2Mutator]MSP[N] result ^= k1 ; } result ^= totalLen ; return fmix32 ( result ) ; }
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; MST[rv.UOI1Mutator]MSP[N] return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ; MST[MathMutator]MSP[N]
return finalise ( hash , unprocessedLength , unprocessed , totalLen ) ; MST[rv.UOI1Mutator]MSP[N] } int finalise ( final int hash , final int unprocessedLength , final byte [] unprocessed , final int totalLen ) { int result = hash ; int k1 = 0 ; switch ( unprocessedLength ) {
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.CRCR5Mutator]MSP[N] break; case 2 :
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[rv.UOI4Mutator]MSP[N] break; case 3 :
for ( int i = 0 ; i < nblocks ; i ++ ) { final int index = newOffset + ( i << 2 ) ; final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; MST[rv.UOI2Mutator]MSP[N] }
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) { MST[NegateConditionalsMutator]MSP[N]
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; MST[rv.CRCR5Mutator]MSP[S] k1 *= C2_32 ; result ^= k1 ; } result ^= totalLen ; return fmix32 ( result ) ; }
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; MST[rv.ABSMutator]MSP[N] return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
for ( int i = 0 ; i < nblocks ; i ++ ) { final int index = newOffset + ( i << 2 ) ; final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; MST[NonVoidMethodCallMutator]MSP[N] }
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.CRCR6Mutator]MSP[N] } @Override @Deprecated
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.UOI3Mutator]MSP[N] break; case 2 :
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; newLength = length - consumed ; } else { newOffset = offset ; newLength = length ; MST[rv.ABSMutator]MSP[N] } final int nblocks = newLength >> 2 ;
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; MST[rv.CRCR5Mutator]MSP[S] k1 *= C1_32 ;
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { MST[rv.AOR2Mutator]MSP[N] System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.CRCR2Mutator]MSP[N] } @Override @Deprecated
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; MST[rv.UOI3Mutator]MSP[N] case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.CRCR1Mutator]MSP[N] } @Override @Deprecated
return finalise ( hash , unprocessedLength , unprocessed , totalLen ) ; } int finalise ( final int hash , final int unprocessedLength , final byte [] unprocessed , final int totalLen ) { int result = hash ; int k1 = 0 ; switch ( unprocessedLength ) { MST[rv.ABSMutator]MSP[S]
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ; MST[rv.AOR4Mutator]MSP[N]
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; MST[rv.UOI1Mutator]MSP[N] } } public final int end () {
for ( int i = 0 ; i < nblocks ; i ++ ) { MST[rv.ROR3Mutator]MSP[N] final int index = newOffset + ( i << 2 ) ; final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; }
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; MST[rv.UOI3Mutator]MSP[N] if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; } } public final int end () {
return finalise ( hash , unprocessedLength , unprocessed , totalLen ) ; } int finalise ( final int hash , final int unprocessedLength , final byte [] unprocessed , final int totalLen ) { int result = hash ; int k1 = 0 ; MST[rv.CRCR1Mutator]MSP[S] switch ( unprocessedLength ) {
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[MathMutator]MSP[N] } @Override @Deprecated
} totalLen += length ; MST[rv.AOD2Mutator]MSP[N] if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.UOI2Mutator]MSP[N] } @Override @Deprecated
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , unprocessed [ 2 ] , data [ offset ] ) ; break; default: throw new IllegalStateException ( lr_1 + unprocessedLength ) ; } hash = mix32 ( k , hash ) ; MST[rv.ABSMutator]MSP[N]
for ( int i = 0 ; i < nblocks ; i ++ ) { MST[IncrementsMutator]MSP[N] final int index = newOffset + ( i << 2 ) ; final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; }
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; MST[rv.UOI2Mutator]MSP[N] unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , unprocessed [ 2 ] , data [ offset ] ) ; break; default: throw new IllegalStateException ( lr_1 + unprocessedLength ) ; } hash = mix32 ( k , hash ) ; MST[rv.UOI1Mutator]MSP[N]
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.UOI4Mutator]MSP[N] } @Override @Deprecated
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; MST[rv.AOR3Mutator]MSP[N] return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; newLength = length - consumed ; } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ; MST[rv.CRCR4Mutator]MSP[N]
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; MST[rv.CRCR2Mutator]MSP[S] k1 *= C2_32 ; result ^= k1 ; } result ^= totalLen ; return fmix32 ( result ) ; }
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ; MST[rv.CRCR5Mutator]MSP[S]
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , unprocessed [ 2 ] , data [ offset ] ) ; MST[rv.ABSMutator]MSP[N] break; default: throw new IllegalStateException ( lr_1 + unprocessedLength ) ; } hash = mix32 ( k , hash ) ;
public final void start ( final int seed ) { unprocessedLength = totalLen = 0 ; this . hash = seed ; } public final void add ( final byte [] data , final int offset , final int length ) { if ( length <= 0 ) { MST[rv.UOI1Mutator]MSP[N] return;
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , unprocessed [ 2 ] , data [ offset ] ) ; MST[rv.CRCR2Mutator]MSP[N] break; default: throw new IllegalStateException ( lr_1 + unprocessedLength ) ; } hash = mix32 ( k , hash ) ;
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ; result ^= k1 ; } result ^= totalLen ; MST[rv.UOI1Mutator]MSP[N] return fmix32 ( result ) ; }
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; MST[rv.CRCR4Mutator]MSP[S] case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
int k = - 1 ; switch ( unprocessedLength ) { MST[rv.UOI3Mutator]MSP[N] case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; break; case 2 :
for ( int i = 0 ; i < nblocks ; i ++ ) { final int index = newOffset + ( i << 2 ) ; MST[rv.AOR3Mutator]MSP[N] final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; }
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; MST[rv.CRCR2Mutator]MSP[N] case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
for ( int i = 0 ; i < nblocks ; i ++ ) { final int index = newOffset + ( i << 2 ) ; MST[rv.ABSMutator]MSP[N] final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; }
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; MST[rv.OBBN1Mutator]MSP[N] k1 *= C1_32 ;
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[rv.CRCR6Mutator]MSP[N] break; case 3 :
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[rv.CRCR4Mutator]MSP[N] break; case 3 :
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; MST[rv.OBBN3Mutator]MSP[S] k1 *= C1_32 ;
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.AOD1Mutator]MSP[N] break; case 2 :
int k = - 1 ; switch ( unprocessedLength ) { MST[experimental.SwitchMutator]MSP[N] case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; break; case 2 :
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.CRCR4Mutator]MSP[N] break; case 2 :
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.CRCR6Mutator]MSP[N] break; case 2 :
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; MST[MathMutator]MSP[N] } } public final int end () {
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , unprocessed [ 2 ] , data [ offset ] ) ; MST[rv.UOI2Mutator]MSP[N] break; default: throw new IllegalStateException ( lr_1 + unprocessedLength ) ; } hash = mix32 ( k , hash ) ;
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; MST[rv.AOR3Mutator]MSP[N] if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; } } public final int end () {
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[rv.UOI4Mutator]MSP[N] break; case 3 :
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ; MST[rv.CRCR3Mutator]MSP[S]
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[MathMutator]MSP[N] } @Override @Deprecated
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; MST[rv.UOI2Mutator]MSP[N] return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.CRCR6Mutator]MSP[N] } @Override @Deprecated
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ; result ^= k1 ; MST[rv.UOI3Mutator]MSP[S] } result ^= totalLen ; return fmix32 ( result ) ; }
public final void start ( final int seed ) { unprocessedLength = totalLen = 0 ; this . hash = seed ; } public final void add ( final byte [] data , final int offset , final int length ) { if ( length <= 0 ) { MST[rv.ROR2Mutator]MSP[S] return;
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; MST[rv.ABSMutator]MSP[S] k1 *= C2_32 ; result ^= k1 ; } result ^= totalLen ; return fmix32 ( result ) ; }
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.CRCR4Mutator]MSP[N] } @Override @Deprecated
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { MST[InlineConstantMutator]MSP[N] System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
for ( int i = 0 ; i < nblocks ; i ++ ) { MST[ConditionalsBoundaryMutator]MSP[N] final int index = newOffset + ( i << 2 ) ; final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; }
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.CRCR2Mutator]MSP[N] } @Override @Deprecated
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.CRCR1Mutator]MSP[N] } @Override @Deprecated
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { MST[rv.UOI1Mutator]MSP[N] System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; MST[rv.UOI3Mutator]MSP[N] } } public final int end () {
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; MST[MathMutator]MSP[S] k1 *= C1_32 ;
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.UOI2Mutator]MSP[N] } @Override @Deprecated
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; MST[rv.UOI4Mutator]MSP[S] k1 *= C1_32 ;
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.UOI1Mutator]MSP[N] } @Override @Deprecated
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; MST[rv.AOR2Mutator]MSP[N] } } public final int end () {
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; MST[rv.CRCR4Mutator]MSP[N] case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
int k = - 1 ; MST[InlineConstantMutator]MSP[N] switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; break; case 2 :
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ; MST[rv.AOR2Mutator]MSP[S]
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[MathMutator]MSP[N] } @Override @Deprecated
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { MST[NegateConditionalsMutator]MSP[N] System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; } } public final int end () {
return finalise ( hash , unprocessedLength , unprocessed , totalLen ) ; MST[rv.UOI2Mutator]MSP[N] } int finalise ( final int hash , final int unprocessedLength , final byte [] unprocessed , final int totalLen ) { int result = hash ; int k1 = 0 ; switch ( unprocessedLength ) {
return finalise ( hash , unprocessedLength , unprocessed , totalLen ) ; MST[rv.UOI4Mutator]MSP[N] } int finalise ( final int hash , final int unprocessedLength , final byte [] unprocessed , final int totalLen ) { int result = hash ; int k1 = 0 ; switch ( unprocessedLength ) {
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , unprocessed [ 2 ] , data [ offset ] ) ; break; default: throw new IllegalStateException ( lr_1 + unprocessedLength ) ; } hash = mix32 ( k , hash ) ; MST[rv.UOI3Mutator]MSP[N]
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ; MST[rv.CRCR2Mutator]MSP[S] result ^= k1 ; } result ^= totalLen ; return fmix32 ( result ) ; }
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; MST[rv.UOI4Mutator]MSP[N] unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; MST[rv.ABSMutator]MSP[N] if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; } } public final int end () {
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; newLength = length - consumed ; } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ; MST[rv.CRCR6Mutator]MSP[N]
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; MST[rv.UOI1Mutator]MSP[N] case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; MST[rv.AOR1Mutator]MSP[N] return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; MST[rv.UOI2Mutator]MSP[S] case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
} totalLen += length ; MST[rv.UOI3Mutator]MSP[S] if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.UOI4Mutator]MSP[N] break; case 2 :
for ( int i = 0 ; i < nblocks ; i ++ ) { MST[rv.UOI2Mutator]MSP[N] final int index = newOffset + ( i << 2 ) ; final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; }
for ( int i = 0 ; i < nblocks ; i ++ ) { final int index = newOffset + ( i << 2 ) ; MST[rv.UOI4Mutator]MSP[N] final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; }
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; MST[rv.UOI2Mutator]MSP[N] case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
final int consumed = BLOCK_SIZE - unprocessedLength ; MST[rv.AOD2Mutator]MSP[N] newOffset = offset + consumed ; newLength = length - consumed ; } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ;
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; MST[rv.CRCR2Mutator]MSP[N] case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.AOR3Mutator]MSP[N] break; case 2 :
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , unprocessed [ 2 ] , data [ offset ] ) ; MST[rv.UOI4Mutator]MSP[S] break; default: throw new IllegalStateException ( lr_1 + unprocessedLength ) ; } hash = mix32 ( k , hash ) ;
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; MST[rv.CRCR4Mutator]MSP[N] case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
return finalise ( hash , unprocessedLength , unprocessed , totalLen ) ; } int finalise ( final int hash , final int unprocessedLength , final byte [] unprocessed , final int totalLen ) { int result = hash ; MST[rv.UOI3Mutator]MSP[N] int k1 = 0 ; switch ( unprocessedLength ) {
} totalLen += length ; MST[rv.AOR4Mutator]MSP[S] if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ; result ^= k1 ; MST[rv.ABSMutator]MSP[S] } result ^= totalLen ; return fmix32 ( result ) ; }
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ; MST[rv.AOR1Mutator]MSP[S] result ^= k1 ; } result ^= totalLen ; return fmix32 ( result ) ; }
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; newLength = length - consumed ; MST[rv.UOI3Mutator]MSP[N] } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ;
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ; MST[rv.UOI3Mutator]MSP[S]
for ( int i = 0 ; i < nblocks ; i ++ ) { final int index = newOffset + ( i << 2 ) ; final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; MST[rv.UOI4Mutator]MSP[N] }
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[MathMutator]MSP[N] break; case 2 :
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.CRCR3Mutator]MSP[N] break; case 2 :
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[rv.AOR1Mutator]MSP[N] break; case 3 :
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; newLength = length - consumed ; MST[rv.ABSMutator]MSP[S] } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ;
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[InlineConstantMutator]MSP[N] break; case 2 :
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.UOI1Mutator]MSP[N] break; case 2 :
} totalLen += length ; MST[rv.UOI4Mutator]MSP[S] if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; MST[rv.CRCR2Mutator]MSP[N] k1 *= C1_32 ;
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; MST[rv.OBBN3Mutator]MSP[N] case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ; result ^= k1 ; } result ^= totalLen ; return fmix32 ( result ) ; MST[rv.UOI2Mutator]MSP[N] }
public final void start ( final int seed ) { unprocessedLength = totalLen = 0 ; MST[rv.CRCR5Mutator]MSP[N] this . hash = seed ; } public final void add ( final byte [] data , final int offset , final int length ) { if ( length <= 0 ) { return;
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; newLength = length - consumed ; } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ; MST[rv.UOI4Mutator]MSP[S]
final int consumed = ( nblocks << 2 ) ; MST[MathMutator]MSP[N] unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; } } public final int end () {
final int consumed = ( nblocks << 2 ) ; MST[InlineConstantMutator]MSP[N] unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; } } public final int end () {
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[rv.CRCR2Mutator]MSP[N] break; case 3 :
} totalLen += length ; MST[rv.ABSMutator]MSP[N] if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
for ( int i = 0 ; i < nblocks ; i ++ ) { final int index = newOffset + ( i << 2 ) ; MST[rv.AOD1Mutator]MSP[N] final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; }
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.AOR2Mutator]MSP[N] break; case 2 :
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; MST[rv.UOI4Mutator]MSP[N] if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; } } public final int end () {
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.OBBN2Mutator]MSP[N] } @Override @Deprecated
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; MST[rv.CRCR4Mutator]MSP[N] case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { MST[rv.ROR4Mutator]MSP[N] System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.OBBN3Mutator]MSP[N] } @Override @Deprecated
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; newLength = length - consumed ; } else { newOffset = offset ; MST[rv.UOI1Mutator]MSP[N] newLength = length ; } final int nblocks = newLength >> 2 ;
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; newLength = length - consumed ; MST[rv.AOR3Mutator]MSP[S] } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ;
for ( int i = 0 ; i < nblocks ; i ++ ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[S] final int index = newOffset + ( i << 2 ) ; final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; }
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ; result ^= k1 ; } result ^= totalLen ; return fmix32 ( result ) ; MST[NonVoidMethodCallMutator]MSP[N] }
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; MST[rv.AOR1Mutator]MSP[N] newLength = length - consumed ; } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ;
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; MST[rv.AOD1Mutator]MSP[N] if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; } } public final int end () {
