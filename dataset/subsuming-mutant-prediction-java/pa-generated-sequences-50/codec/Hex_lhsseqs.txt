} @Override public Object encode ( final Object object ) throws EncoderException { byte [] byteArray ; if ( object instanceof String ) { byteArray = ( ( String ) object ) . getBytes ( this . getCharset () ) ; } else if ( object instanceof ByteBuffer ) { MST[rv.ROR2Mutator]MSP[]
final int outLen = len >> 1 ; if ( out . length - outOffset < outLen ) { MST[rv.AOR3Mutator]MSP[] throw new DecoderException ( lr_2 ) ; } for ( int i = outOffset , j = 0 ; j < len ; i ++ ) {
public static char [] encodeHex ( final ByteBuffer data , final boolean toLowerCase ) { return encodeHex ( data , toLowerCase ? DIGITS_LOWER : DIGITS_UPPER ) ; MST[NullReturnValsMutator]MSP[] } protected static char [] encodeHex ( final ByteBuffer byteBuffer , final char [] toDigits ) {
byteArray = toByteArray ( ( ByteBuffer ) object ) ; MST[NonVoidMethodCallMutator]MSP[] } else { try { byteArray = ( byte [] ) object ; } catch ( final ClassCastException e ) { throw new EncoderException ( e . getMessage () , e ) ; } }
return encodeHex ( byteArray ) ; } public Charset getCharset () { return this . charset ; } public String getCharsetName () { return this . charset . name () ; MST[NonVoidMethodCallMutator]MSP[] } @Override public String toString () {
public static byte [] decodeHex ( final char [] data ) throws DecoderException { final byte [] out = new byte [ data . length >> 1 ] ; MST[rv.CRCR5Mutator]MSP[] decodeHex ( data , out , 0 ) ; return out ; }
public static char [] encodeHex ( final ByteBuffer data , final boolean toLowerCase ) { return encodeHex ( data , toLowerCase ? DIGITS_LOWER : DIGITS_UPPER ) ; MST[rv.ABSMutator]MSP[] } protected static char [] encodeHex ( final ByteBuffer byteBuffer , final char [] toDigits ) {
return new String ( encodeHex ( data , toLowerCase ) ) ; MST[NonVoidMethodCallMutator]MSP[] } public static String encodeHexString ( final ByteBuffer data ) { return new String ( encodeHex ( data ) ) ; } public static String encodeHexString ( final ByteBuffer data , final boolean toLowerCase ) {
} @Override public Object encode ( final Object object ) throws EncoderException { byte [] byteArray ; if ( object instanceof String ) { MST[rv.ROR2Mutator]MSP[] byteArray = ( ( String ) object ) . getBytes ( this . getCharset () ) ; } else if ( object instanceof ByteBuffer ) {
public static char [] encodeHex ( final byte [] data , final boolean toLowerCase ) { return encodeHex ( data , toLowerCase ? DIGITS_LOWER : DIGITS_UPPER ) ; MST[rv.ROR2Mutator]MSP[] } protected static char [] encodeHex ( final byte [] data , final char [] toDigits ) {
int f = toDigit ( data [ j ] , j ) << 4 ; MST[rv.CRCR2Mutator]MSP[] j ++ ; f = f | toDigit ( data [ j ] , j ) ; j ++ ; out [ i ] = (byte) ( f & 0xFF ) ; }
return super . toString () + lr_5 + this . charset + lr_6 ; MST[ReturnValsMutator]MSP[] }
public static char [] encodeHex ( final ByteBuffer data , final boolean toLowerCase ) { return encodeHex ( data , toLowerCase ? DIGITS_LOWER : DIGITS_UPPER ) ; MST[rv.ROR3Mutator]MSP[] } protected static char [] encodeHex ( final ByteBuffer byteBuffer , final char [] toDigits ) {
final byte [] byteArray = byteBuffer . array () ; if ( remaining == byteArray . length ) { byteBuffer . position ( remaining ) ; MST[rv.UOI2Mutator]MSP[] return byteArray ; } } final byte [] byteArray = new byte [ remaining ] ; byteBuffer . get ( byteArray ) ;
final int l = data . length ; final char [] out = new char [ l << 1 ] ; MST[rv.UOI3Mutator]MSP[] encodeHex ( data , 0 , data . length , toDigits , out , 0 ) ; return out ; }
return new String ( encodeHex ( data , toLowerCase ) ) ; } private static byte [] toByteArray ( final ByteBuffer byteBuffer ) { final int remaining = byteBuffer . remaining () ; if ( byteBuffer . hasArray () ) { MST[rv.ROR3Mutator]MSP[]
final int outLen = len >> 1 ; if ( out . length - outOffset < outLen ) { MST[rv.UOI2Mutator]MSP[] throw new DecoderException ( lr_2 ) ; } for ( int i = outOffset , j = 0 ; j < len ; i ++ ) {
for ( int i = dataOffset , j = outOffset ; i < dataOffset + dataLen ; i ++ ) { out [ j ++ ] = toDigits [ ( 0xF0 & data [ i ] ) >>> 4 ] ; MST[experimental.RemoveIncrementsMutator]MSP[]
return byteArray ; } protected static int toDigit ( final char ch , final int index ) throws DecoderException { final int digit = Character . digit ( ch , 16 ) ; if ( digit == - 1 ) { MST[rv.CRCR6Mutator]MSP[]
return byteArray ; } protected static int toDigit ( final char ch , final int index ) throws DecoderException { final int digit = Character . digit ( ch , 16 ) ; if ( digit == - 1 ) { MST[rv.CRCR2Mutator]MSP[]
return encodeHex ( byteArray ) ; } public Charset getCharset () { return this . charset ; MST[NullReturnValsMutator]MSP[] } public String getCharsetName () { return this . charset . name () ; } @Override public String toString () {
if ( object instanceof String ) { return decode ( ( ( String ) object ) . toCharArray () ) ; MST[ReturnValsMutator]MSP[] } else if ( object instanceof byte [] ) { return decode ( ( byte [] ) object ) ; } else if ( object instanceof ByteBuffer ) {
public static int decodeHex ( final char [] data , final byte [] out , final int outOffset ) throws DecoderException { final int len = data . length ; if ( ( len & 0x01 ) != 0 ) { throw new DecoderException ( lr_1 ) ; MST[ConstructorCallMutator]MSP[] }
throw new DecoderException ( lr_3 + ch + lr_4 + index ) ; MST[NonVoidMethodCallMutator]MSP[] } return digit ; } @Override public byte [] decode ( final byte [] array ) throws DecoderException { return decodeHex ( new String ( array , getCharset () ) . toCharArray () ) ; }
public static char [] encodeHex ( final ByteBuffer data , final boolean toLowerCase ) { return encodeHex ( data , toLowerCase ? DIGITS_LOWER : DIGITS_UPPER ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] } protected static char [] encodeHex ( final ByteBuffer byteBuffer , final char [] toDigits ) {
throw new DecoderException ( lr_3 + ch + lr_4 + index ) ; } return digit ; } @Override public byte [] decode ( final byte [] array ) throws DecoderException { return decodeHex ( new String ( array , getCharset () ) . toCharArray () ) ; MST[NonVoidMethodCallMutator]MSP[] }
return encodeHex ( byteArray ) ; } public Charset getCharset () { return this . charset ; } public String getCharsetName () { return this . charset . name () ; MST[EmptyObjectReturnValsMutator]MSP[] } @Override public String toString () {
final byte [] byteArray = byteBuffer . array () ; if ( remaining == byteArray . length ) { byteBuffer . position ( remaining ) ; MST[NonVoidMethodCallMutator]MSP[] return byteArray ; } } final byte [] byteArray = new byte [ remaining ] ; byteBuffer . get ( byteArray ) ;
final byte [] byteArray = byteBuffer . array () ; if ( remaining == byteArray . length ) { MST[rv.ROR2Mutator]MSP[] byteBuffer . position ( remaining ) ; return byteArray ; } } final byte [] byteArray = new byte [ remaining ] ; byteBuffer . get ( byteArray ) ;
if ( object instanceof String ) { return decode ( ( ( String ) object ) . toCharArray () ) ; MST[ArgumentPropagationMutator]MSP[] } else if ( object instanceof byte [] ) { return decode ( ( byte [] ) object ) ; } else if ( object instanceof ByteBuffer ) {
int f = toDigit ( data [ j ] , j ) << 4 ; j ++ ; f = f | toDigit ( data [ j ] , j ) ; MST[rv.UOI4Mutator]MSP[] j ++ ; out [ i ] = (byte) ( f & 0xFF ) ; }
return super . toString () + lr_5 + this . charset + lr_6 ; MST[NonVoidMethodCallMutator]MSP[] }
return byteArray ; } protected static int toDigit ( final char ch , final int index ) throws DecoderException { final int digit = Character . digit ( ch , 16 ) ; MST[rv.UOI4Mutator]MSP[] if ( digit == - 1 ) {
final byte [] byteArray = byteBuffer . array () ; if ( remaining == byteArray . length ) { byteBuffer . position ( remaining ) ; return byteArray ; } } final byte [] byteArray = new byte [ remaining ] ; byteBuffer . get ( byteArray ) ; MST[NonVoidMethodCallMutator]MSP[]
for ( int i = dataOffset , j = outOffset ; i < dataOffset + dataLen ; i ++ ) { out [ j ++ ] = toDigits [ ( 0xF0 & data [ i ] ) >>> 4 ] ; MST[rv.OBBN2Mutator]MSP[]
int f = toDigit ( data [ j ] , j ) << 4 ; MST[rv.UOI1Mutator]MSP[] j ++ ; f = f | toDigit ( data [ j ] , j ) ; j ++ ; out [ i ] = (byte) ( f & 0xFF ) ; }
if ( object instanceof String ) { MST[rv.ROR4Mutator]MSP[] return decode ( ( ( String ) object ) . toCharArray () ) ; } else if ( object instanceof byte [] ) { return decode ( ( byte [] ) object ) ; } else if ( object instanceof ByteBuffer ) {
out [ j ++ ] = toDigits [ 0x0F & data [ i ] ] ; } } public static char [] encodeHex ( final ByteBuffer data ) { return encodeHex ( data , true ) ; MST[rv.CRCR5Mutator]MSP[] }
public static char [] encodeHex ( final byte [] data , final int dataOffset , final int dataLen , final boolean toLowerCase ) { final char [] out = new char [ dataLen << 1 ] ; MST[rv.CRCR3Mutator]MSP[]
encodeHex ( data , dataOffset , dataLen , toLowerCase ? DIGITS_LOWER : DIGITS_UPPER , out , 0 ) ; return out ; MST[NullReturnValsMutator]MSP[] } public static void encodeHex ( final byte [] data , final int dataOffset , final int dataLen ,
final int outLen = len >> 1 ; if ( out . length - outOffset < outLen ) { throw new DecoderException ( lr_2 ) ; } for ( int i = outOffset , j = 0 ; j < len ; i ++ ) { MST[rv.UOI3Mutator]MSP[]
public static int decodeHex ( final char [] data , final byte [] out , final int outOffset ) throws DecoderException { final int len = data . length ; if ( ( len & 0x01 ) != 0 ) { MST[rv.OBBN3Mutator]MSP[] throw new DecoderException ( lr_1 ) ; }
int f = toDigit ( data [ j ] , j ) << 4 ; j ++ ; MST[experimental.RemoveIncrementsMutator]MSP[] f = f | toDigit ( data [ j ] , j ) ; j ++ ; out [ i ] = (byte) ( f & 0xFF ) ; }
public static char [] encodeHex ( final ByteBuffer data , final boolean toLowerCase ) { return encodeHex ( data , toLowerCase ? DIGITS_LOWER : DIGITS_UPPER ) ; MST[rv.UOI2Mutator]MSP[] } protected static char [] encodeHex ( final ByteBuffer byteBuffer , final char [] toDigits ) {
throw new DecoderException ( lr_3 + ch + lr_4 + index ) ; MST[rv.UOI2Mutator]MSP[] } return digit ; } @Override public byte [] decode ( final byte [] array ) throws DecoderException { return decodeHex ( new String ( array , getCharset () ) . toCharArray () ) ; }
throw new DecoderException ( lr_3 + ch + lr_4 + index ) ; MST[rv.UOI1Mutator]MSP[] } return digit ; } @Override public byte [] decode ( final byte [] array ) throws DecoderException { return decodeHex ( new String ( array , getCharset () ) . toCharArray () ) ; }
} @Override public Object encode ( final Object object ) throws EncoderException { byte [] byteArray ; if ( object instanceof String ) { byteArray = ( ( String ) object ) . getBytes ( this . getCharset () ) ; MST[NonVoidMethodCallMutator]MSP[] } else if ( object instanceof ByteBuffer ) {
public static char [] encodeHex ( final byte [] data , final boolean toLowerCase ) { return encodeHex ( data , toLowerCase ? DIGITS_LOWER : DIGITS_UPPER ) ; MST[rv.UOI1Mutator]MSP[] } protected static char [] encodeHex ( final byte [] data , final char [] toDigits ) {
throw new DecoderException ( lr_3 + ch + lr_4 + index ) ; MST[rv.ABSMutator]MSP[] } return digit ; } @Override public byte [] decode ( final byte [] array ) throws DecoderException { return decodeHex ( new String ( array , getCharset () ) . toCharArray () ) ; }
return new String ( encodeHex ( data , toLowerCase ) ) ; } private static byte [] toByteArray ( final ByteBuffer byteBuffer ) { final int remaining = byteBuffer . remaining () ; if ( byteBuffer . hasArray () ) { MST[NonVoidMethodCallMutator]MSP[]
return outLen ; MST[rv.UOI2Mutator]MSP[] } public static byte [] decodeHex ( final String data ) throws DecoderException { return decodeHex ( data . toCharArray () ) ; } public static char [] encodeHex ( final byte [] data ) { return encodeHex ( data , true ) ; }
public static int decodeHex ( final char [] data , final byte [] out , final int outOffset ) throws DecoderException { final int len = data . length ; if ( ( len & 0x01 ) != 0 ) { MST[rv.CRCR5Mutator]MSP[] throw new DecoderException ( lr_1 ) ; }
if ( object instanceof String ) { return decode ( ( ( String ) object ) . toCharArray () ) ; } else if ( object instanceof byte [] ) { return decode ( ( byte [] ) object ) ; MST[NullReturnValsMutator]MSP[] } else if ( object instanceof ByteBuffer ) {
return new String ( encodeHex ( data , toLowerCase ) ) ; MST[EmptyObjectReturnValsMutator]MSP[] } public static String encodeHexString ( final ByteBuffer data ) { return new String ( encodeHex ( data ) ) ; } public static String encodeHexString ( final ByteBuffer data , final boolean toLowerCase ) {
final byte [] byteArray = byteBuffer . array () ; if ( remaining == byteArray . length ) { MST[rv.UOI4Mutator]MSP[] byteBuffer . position ( remaining ) ; return byteArray ; } } final byte [] byteArray = new byte [ remaining ] ; byteBuffer . get ( byteArray ) ;
encodeHex ( data , dataOffset , dataLen , toLowerCase ? DIGITS_LOWER : DIGITS_UPPER , out , 0 ) ; MST[rv.UOI1Mutator]MSP[] return out ; } public static void encodeHex ( final byte [] data , final int dataOffset , final int dataLen ,
throw new DecoderException ( lr_3 + ch + lr_4 + index ) ; MST[NonVoidMethodCallMutator]MSP[] } return digit ; } @Override public byte [] decode ( final byte [] array ) throws DecoderException { return decodeHex ( new String ( array , getCharset () ) . toCharArray () ) ; }
return byteArray ; } protected static int toDigit ( final char ch , final int index ) throws DecoderException { final int digit = Character . digit ( ch , 16 ) ; if ( digit == - 1 ) { MST[rv.ABSMutator]MSP[]
int f = toDigit ( data [ j ] , j ) << 4 ; j ++ ; f = f | toDigit ( data [ j ] , j ) ; j ++ ; out [ i ] = (byte) ( f & 0xFF ) ; MST[rv.UOI3Mutator]MSP[] }
encodeHex ( data , dataOffset , dataLen , toLowerCase ? DIGITS_LOWER : DIGITS_UPPER , out , 0 ) ; MST[rv.ROR2Mutator]MSP[] return out ; } public static void encodeHex ( final byte [] data , final int dataOffset , final int dataLen ,
out [ j ++ ] = toDigits [ 0x0F & data [ i ] ] ; MST[rv.UOI2Mutator]MSP[] } } public static char [] encodeHex ( final ByteBuffer data ) { return encodeHex ( data , true ) ; }
final int outLen = len >> 1 ; if ( out . length - outOffset < outLen ) { throw new DecoderException ( lr_2 ) ; } for ( int i = outOffset , j = 0 ; j < len ; i ++ ) { MST[InlineConstantMutator]MSP[]
final byte [] byteArray = byteBuffer . array () ; if ( remaining == byteArray . length ) { byteBuffer . position ( remaining ) ; MST[rv.ABSMutator]MSP[] return byteArray ; } } final byte [] byteArray = new byte [ remaining ] ; byteBuffer . get ( byteArray ) ;
throw new DecoderException ( lr_3 + ch + lr_4 + index ) ; } return digit ; } @Override public byte [] decode ( final byte [] array ) throws DecoderException { return decodeHex ( new String ( array , getCharset () ) . toCharArray () ) ; MST[NonVoidMethodCallMutator]MSP[] }
int f = toDigit ( data [ j ] , j ) << 4 ; j ++ ; f = f | toDigit ( data [ j ] , j ) ; MST[rv.UOI1Mutator]MSP[] j ++ ; out [ i ] = (byte) ( f & 0xFF ) ; }
return outLen ; } public static byte [] decodeHex ( final String data ) throws DecoderException { return decodeHex ( data . toCharArray () ) ; MST[NullReturnValsMutator]MSP[] } public static char [] encodeHex ( final byte [] data ) { return encodeHex ( data , true ) ; }
public static int decodeHex ( final char [] data , final byte [] out , final int outOffset ) throws DecoderException { final int len = data . length ; if ( ( len & 0x01 ) != 0 ) { MST[rv.UOI1Mutator]MSP[] throw new DecoderException ( lr_1 ) ; }
public static byte [] decodeHex ( final char [] data ) throws DecoderException { final byte [] out = new byte [ data . length >> 1 ] ; decodeHex ( data , out , 0 ) ; MST[InlineConstantMutator]MSP[] return out ; }
return super . toString () + lr_5 + this . charset + lr_6 ; MST[NonVoidMethodCallMutator]MSP[] }
final int outLen = len >> 1 ; if ( out . length - outOffset < outLen ) { throw new DecoderException ( lr_2 ) ; } for ( int i = outOffset , j = 0 ; j < len ; i ++ ) { MST[rv.UOI3Mutator]MSP[]
final boolean toLowerCase , final char [] out , final int outOffset ) { encodeHex ( data , dataOffset , dataLen , toLowerCase ? DIGITS_LOWER : DIGITS_UPPER , out , outOffset ) ; MST[rv.ABSMutator]MSP[] }
return new String ( encodeHex ( data , toLowerCase ) ) ; MST[ConstructorCallMutator]MSP[] } public static String encodeHexString ( final ByteBuffer data ) { return new String ( encodeHex ( data ) ) ; } public static String encodeHexString ( final ByteBuffer data , final boolean toLowerCase ) {
public static char [] encodeHex ( final byte [] data , final int dataOffset , final int dataLen , final boolean toLowerCase ) { final char [] out = new char [ dataLen << 1 ] ; MST[rv.UOI2Mutator]MSP[]
return encodeHex ( byteArray ) ; MST[NonVoidMethodCallMutator]MSP[] } public Charset getCharset () { return this . charset ; } public String getCharsetName () { return this . charset . name () ; } @Override public String toString () {
int f = toDigit ( data [ j ] , j ) << 4 ; j ++ ; f = f | toDigit ( data [ j ] , j ) ; j ++ ; out [ i ] = (byte) ( f & 0xFF ) ; MST[rv.UOI3Mutator]MSP[] }
for ( int i = dataOffset , j = outOffset ; i < dataOffset + dataLen ; i ++ ) { MST[rv.ROR2Mutator]MSP[] out [ j ++ ] = toDigits [ ( 0xF0 & data [ i ] ) >>> 4 ] ;
final byte [] byteArray = byteBuffer . array () ; if ( remaining == byteArray . length ) { byteBuffer . position ( remaining ) ; return byteArray ; } } final byte [] byteArray = new byte [ remaining ] ; MST[rv.UOI4Mutator]MSP[] byteBuffer . get ( byteArray ) ;
for ( int i = dataOffset , j = outOffset ; i < dataOffset + dataLen ; i ++ ) { out [ j ++ ] = toDigits [ ( 0xF0 & data [ i ] ) >>> 4 ] ; MST[rv.UOI3Mutator]MSP[]
return decode ( ( ByteBuffer ) object ) ; MST[NullReturnValsMutator]MSP[] } else { try { return decodeHex ( ( char [] ) object ) ; } catch ( final ClassCastException e ) { throw new DecoderException ( e . getMessage () , e ) ; } } } @Override
for ( int i = dataOffset , j = outOffset ; i < dataOffset + dataLen ; i ++ ) { out [ j ++ ] = toDigits [ ( 0xF0 & data [ i ] ) >>> 4 ] ; MST[rv.UOI2Mutator]MSP[]
public static int decodeHex ( final char [] data , final byte [] out , final int outOffset ) throws DecoderException { final int len = data . length ; if ( ( len & 0x01 ) != 0 ) { MST[rv.UOI4Mutator]MSP[] throw new DecoderException ( lr_1 ) ; }
int f = toDigit ( data [ j ] , j ) << 4 ; j ++ ; f = f | toDigit ( data [ j ] , j ) ; MST[rv.UOI4Mutator]MSP[] j ++ ; out [ i ] = (byte) ( f & 0xFF ) ; }
return new String ( encodeHex ( data , toLowerCase ) ) ; MST[rv.UOI3Mutator]MSP[] } private static byte [] toByteArray ( final ByteBuffer byteBuffer ) { final int remaining = byteBuffer . remaining () ; if ( byteBuffer . hasArray () ) {
for ( int i = dataOffset , j = outOffset ; i < dataOffset + dataLen ; i ++ ) { MST[rv.UOI2Mutator]MSP[] out [ j ++ ] = toDigits [ ( 0xF0 & data [ i ] ) >>> 4 ] ;
out [ j ++ ] = toDigits [ 0x0F & data [ i ] ] ; } } public static char [] encodeHex ( final ByteBuffer data ) { return encodeHex ( data , true ) ; MST[rv.CRCR6Mutator]MSP[] }
throw new DecoderException ( lr_3 + ch + lr_4 + index ) ; MST[rv.UOI4Mutator]MSP[] } return digit ; } @Override public byte [] decode ( final byte [] array ) throws DecoderException { return decodeHex ( new String ( array , getCharset () ) . toCharArray () ) ; }
final int outLen = len >> 1 ; if ( out . length - outOffset < outLen ) { throw new DecoderException ( lr_2 ) ; } for ( int i = outOffset , j = 0 ; j < len ; i ++ ) { MST[ConditionalsBoundaryMutator]MSP[]
final int outLen = len >> 1 ; if ( out . length - outOffset < outLen ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[] throw new DecoderException ( lr_2 ) ; } for ( int i = outOffset , j = 0 ; j < len ; i ++ ) {
encodeHex ( data , dataOffset , dataLen , toLowerCase ? DIGITS_LOWER : DIGITS_UPPER , out , 0 ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return out ; } public static void encodeHex ( final byte [] data , final int dataOffset , final int dataLen ,
return encodeHex ( toByteArray ( byteBuffer ) , toDigits ) ; MST[ArgumentPropagationMutator]MSP[] } public static String encodeHexString ( final byte [] data ) { return new String ( encodeHex ( data ) ) ; } public static String encodeHexString ( final byte [] data , final boolean toLowerCase ) {
if ( object instanceof String ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return decode ( ( ( String ) object ) . toCharArray () ) ; } else if ( object instanceof byte [] ) { return decode ( ( byte [] ) object ) ; } else if ( object instanceof ByteBuffer ) {
return new String ( encodeHex ( data , toLowerCase ) ) ; } private static byte [] toByteArray ( final ByteBuffer byteBuffer ) { final int remaining = byteBuffer . remaining () ; if ( byteBuffer . hasArray () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
public static char [] encodeHex ( final byte [] data , final boolean toLowerCase ) { return encodeHex ( data , toLowerCase ? DIGITS_LOWER : DIGITS_UPPER ) ; MST[rv.UOI4Mutator]MSP[] } protected static char [] encodeHex ( final byte [] data , final char [] toDigits ) {
final boolean toLowerCase , final char [] out , final int outOffset ) { encodeHex ( data , dataOffset , dataLen , toLowerCase ? DIGITS_LOWER : DIGITS_UPPER , out , outOffset ) ; MST[rv.UOI3Mutator]MSP[] }
final int outLen = len >> 1 ; if ( out . length - outOffset < outLen ) { MST[NegateConditionalsMutator]MSP[] throw new DecoderException ( lr_2 ) ; } for ( int i = outOffset , j = 0 ; j < len ; i ++ ) {
public static byte [] decodeHex ( final char [] data ) throws DecoderException { final byte [] out = new byte [ data . length >> 1 ] ; decodeHex ( data , out , 0 ) ; MST[rv.CRCR3Mutator]MSP[] return out ; }
final int outLen = len >> 1 ; MST[rv.UOI1Mutator]MSP[] if ( out . length - outOffset < outLen ) { throw new DecoderException ( lr_2 ) ; } for ( int i = outOffset , j = 0 ; j < len ; i ++ ) {
final byte [] byteArray = byteBuffer . array () ; if ( remaining == byteArray . length ) { byteBuffer . position ( remaining ) ; return byteArray ; } } final byte [] byteArray = new byte [ remaining ] ; byteBuffer . get ( byteArray ) ; MST[experimental.NakedReceiverMutator]MSP[]
throw new DecoderException ( lr_3 + ch + lr_4 + index ) ; MST[NonVoidMethodCallMutator]MSP[] } return digit ; } @Override public byte [] decode ( final byte [] array ) throws DecoderException { return decodeHex ( new String ( array , getCharset () ) . toCharArray () ) ; }
} @Override public Object encode ( final Object object ) throws EncoderException { byte [] byteArray ; if ( object instanceof String ) { byteArray = ( ( String ) object ) . getBytes ( this . getCharset () ) ; } else if ( object instanceof ByteBuffer ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
int f = toDigit ( data [ j ] , j ) << 4 ; j ++ ; f = f | toDigit ( data [ j ] , j ) ; j ++ ; out [ i ] = (byte) ( f & 0xFF ) ; MST[rv.CRCR4Mutator]MSP[] }
return byteArray ; } protected static int toDigit ( final char ch , final int index ) throws DecoderException { final int digit = Character . digit ( ch , 16 ) ; MST[rv.CRCR5Mutator]MSP[] if ( digit == - 1 ) {
} @Override public Object encode ( final Object object ) throws EncoderException { byte [] byteArray ; if ( object instanceof String ) { MST[rv.ROR3Mutator]MSP[] byteArray = ( ( String ) object ) . getBytes ( this . getCharset () ) ; } else if ( object instanceof ByteBuffer ) {
return byteArray ; } protected static int toDigit ( final char ch , final int index ) throws DecoderException { final int digit = Character . digit ( ch , 16 ) ; if ( digit == - 1 ) { MST[rv.ROR3Mutator]MSP[]
out [ j ++ ] = toDigits [ 0x0F & data [ i ] ] ; MST[rv.UOI3Mutator]MSP[] } } public static char [] encodeHex ( final ByteBuffer data ) { return encodeHex ( data , true ) ; }
return new String ( encodeHex ( data , toLowerCase ) ) ; MST[rv.UOI2Mutator]MSP[] } public static String encodeHexString ( final ByteBuffer data ) { return new String ( encodeHex ( data ) ) ; } public static String encodeHexString ( final ByteBuffer data , final boolean toLowerCase ) {
final byte [] byteArray = byteBuffer . array () ; if ( remaining == byteArray . length ) { byteBuffer . position ( remaining ) ; return byteArray ; } } final byte [] byteArray = new byte [ remaining ] ; MST[rv.UOI1Mutator]MSP[] byteBuffer . get ( byteArray ) ;
throw new DecoderException ( lr_3 + ch + lr_4 + index ) ; MST[experimental.NakedReceiverMutator]MSP[] } return digit ; } @Override public byte [] decode ( final byte [] array ) throws DecoderException { return decodeHex ( new String ( array , getCharset () ) . toCharArray () ) ; }
final byte [] byteArray = byteBuffer . array () ; if ( remaining == byteArray . length ) { MST[rv.ROR1Mutator]MSP[] byteBuffer . position ( remaining ) ; return byteArray ; } } final byte [] byteArray = new byte [ remaining ] ; byteBuffer . get ( byteArray ) ;
throw new DecoderException ( lr_3 + ch + lr_4 + index ) ; } return digit ; } @Override public byte [] decode ( final byte [] array ) throws DecoderException { return decodeHex ( new String ( array , getCharset () ) . toCharArray () ) ; MST[NonVoidMethodCallMutator]MSP[] }
for ( int i = dataOffset , j = outOffset ; i < dataOffset + dataLen ; i ++ ) { MST[rv.AOR2Mutator]MSP[] out [ j ++ ] = toDigits [ ( 0xF0 & data [ i ] ) >>> 4 ] ;
} @Override public Object encode ( final Object object ) throws EncoderException { byte [] byteArray ; if ( object instanceof String ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] byteArray = ( ( String ) object ) . getBytes ( this . getCharset () ) ; } else if ( object instanceof ByteBuffer ) {
int f = toDigit ( data [ j ] , j ) << 4 ; j ++ ; f = f | toDigit ( data [ j ] , j ) ; MST[rv.UOI1Mutator]MSP[] j ++ ; out [ i ] = (byte) ( f & 0xFF ) ; }
if ( object instanceof String ) { return decode ( ( ( String ) object ) . toCharArray () ) ; } else if ( object instanceof byte [] ) { MST[NegateConditionalsMutator]MSP[] return decode ( ( byte [] ) object ) ; } else if ( object instanceof ByteBuffer ) {
} @Override public Object encode ( final Object object ) throws EncoderException { byte [] byteArray ; if ( object instanceof String ) { byteArray = ( ( String ) object ) . getBytes ( this . getCharset () ) ; } else if ( object instanceof ByteBuffer ) { MST[rv.ROR1Mutator]MSP[]
public byte [] encode ( final byte [] array ) { return encodeHexString ( array ) . getBytes ( this . getCharset () ) ; MST[NonVoidMethodCallMutator]MSP[] } public byte [] encode ( final ByteBuffer array ) { return encodeHexString ( array ) . getBytes ( this . getCharset () ) ;
for ( int i = dataOffset , j = outOffset ; i < dataOffset + dataLen ; i ++ ) { MST[rv.UOI4Mutator]MSP[] out [ j ++ ] = toDigits [ ( 0xF0 & data [ i ] ) >>> 4 ] ;
final int outLen = len >> 1 ; if ( out . length - outOffset < outLen ) { MST[rv.AOR2Mutator]MSP[] throw new DecoderException ( lr_2 ) ; } for ( int i = outOffset , j = 0 ; j < len ; i ++ ) {
out [ j ++ ] = toDigits [ 0x0F & data [ i ] ] ; } } public static char [] encodeHex ( final ByteBuffer data ) { return encodeHex ( data , true ) ; MST[NonVoidMethodCallMutator]MSP[] }
return super . toString () + lr_5 + this . charset + lr_6 ; MST[NonVoidMethodCallMutator]MSP[] }
final byte [] byteArray = byteBuffer . array () ; if ( remaining == byteArray . length ) { byteBuffer . position ( remaining ) ; return byteArray ; MST[NullReturnValsMutator]MSP[] } } final byte [] byteArray = new byte [ remaining ] ; byteBuffer . get ( byteArray ) ;
public static char [] encodeHex ( final byte [] data , final boolean toLowerCase ) { return encodeHex ( data , toLowerCase ? DIGITS_LOWER : DIGITS_UPPER ) ; MST[rv.ROR5Mutator]MSP[] } protected static char [] encodeHex ( final byte [] data , final char [] toDigits ) {
public byte [] encode ( final byte [] array ) { return encodeHexString ( array ) . getBytes ( this . getCharset () ) ; } public byte [] encode ( final ByteBuffer array ) { return encodeHexString ( array ) . getBytes ( this . getCharset () ) ; MST[ReturnValsMutator]MSP[]
if ( object instanceof String ) { return decode ( ( ( String ) object ) . toCharArray () ) ; MST[NullReturnValsMutator]MSP[] } else if ( object instanceof byte [] ) { return decode ( ( byte [] ) object ) ; } else if ( object instanceof ByteBuffer ) {
} @Override public Object encode ( final Object object ) throws EncoderException { byte [] byteArray ; if ( object instanceof String ) { MST[rv.ROR1Mutator]MSP[] byteArray = ( ( String ) object ) . getBytes ( this . getCharset () ) ; } else if ( object instanceof ByteBuffer ) {
public static char [] encodeHex ( final byte [] data , final boolean toLowerCase ) { return encodeHex ( data , toLowerCase ? DIGITS_LOWER : DIGITS_UPPER ) ; MST[rv.ABSMutator]MSP[] } protected static char [] encodeHex ( final byte [] data , final char [] toDigits ) {
public static char [] encodeHex ( final byte [] data , final boolean toLowerCase ) { return encodeHex ( data , toLowerCase ? DIGITS_LOWER : DIGITS_UPPER ) ; MST[rv.ROR1Mutator]MSP[] } protected static char [] encodeHex ( final byte [] data , final char [] toDigits ) {
return encodeHex ( toByteArray ( byteBuffer ) , toDigits ) ; MST[NonVoidMethodCallMutator]MSP[] } public static String encodeHexString ( final byte [] data ) { return new String ( encodeHex ( data ) ) ; } public static String encodeHexString ( final byte [] data , final boolean toLowerCase ) {
final byte [] byteArray = byteBuffer . array () ; if ( remaining == byteArray . length ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] byteBuffer . position ( remaining ) ; return byteArray ; } } final byte [] byteArray = new byte [ remaining ] ; byteBuffer . get ( byteArray ) ;
for ( int i = dataOffset , j = outOffset ; i < dataOffset + dataLen ; i ++ ) { out [ j ++ ] = toDigits [ ( 0xF0 & data [ i ] ) >>> 4 ] ; MST[InlineConstantMutator]MSP[]
public static char [] encodeHex ( final ByteBuffer data , final boolean toLowerCase ) { return encodeHex ( data , toLowerCase ? DIGITS_LOWER : DIGITS_UPPER ) ; MST[rv.ROR4Mutator]MSP[] } protected static char [] encodeHex ( final ByteBuffer byteBuffer , final char [] toDigits ) {
final int outLen = len >> 1 ; if ( out . length - outOffset < outLen ) { MST[rv.ROR5Mutator]MSP[] throw new DecoderException ( lr_2 ) ; } for ( int i = outOffset , j = 0 ; j < len ; i ++ ) {
out [ j ++ ] = toDigits [ 0x0F & data [ i ] ] ; } } public static char [] encodeHex ( final ByteBuffer data ) { return encodeHex ( data , true ) ; MST[InlineConstantMutator]MSP[] }
for ( int i = dataOffset , j = outOffset ; i < dataOffset + dataLen ; i ++ ) { MST[rv.AOR3Mutator]MSP[] out [ j ++ ] = toDigits [ ( 0xF0 & data [ i ] ) >>> 4 ] ;
encodeHex ( data , dataOffset , dataLen , toLowerCase ? DIGITS_LOWER : DIGITS_UPPER , out , 0 ) ; MST[rv.UOI2Mutator]MSP[] return out ; } public static void encodeHex ( final byte [] data , final int dataOffset , final int dataLen ,
return byteArray ; } protected static int toDigit ( final char ch , final int index ) throws DecoderException { final int digit = Character . digit ( ch , 16 ) ; if ( digit == - 1 ) { MST[rv.ROR2Mutator]MSP[]
return new String ( encodeHex ( data , toLowerCase ) ) ; MST[rv.UOI1Mutator]MSP[] } public static String encodeHexString ( final ByteBuffer data ) { return new String ( encodeHex ( data ) ) ; } public static String encodeHexString ( final ByteBuffer data , final boolean toLowerCase ) {
public static char [] encodeHex ( final byte [] data , final boolean toLowerCase ) { return encodeHex ( data , toLowerCase ? DIGITS_LOWER : DIGITS_UPPER ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] } protected static char [] encodeHex ( final byte [] data , final char [] toDigits ) {
if ( object instanceof String ) { return decode ( ( ( String ) object ) . toCharArray () ) ; } else if ( object instanceof byte [] ) { return decode ( ( byte [] ) object ) ; } else if ( object instanceof ByteBuffer ) { MST[rv.ROR2Mutator]MSP[]
if ( object instanceof String ) { return decode ( ( ( String ) object ) . toCharArray () ) ; } else if ( object instanceof byte [] ) { return decode ( ( byte [] ) object ) ; } else if ( object instanceof ByteBuffer ) { MST[rv.ROR4Mutator]MSP[]
encodeHex ( data , dataOffset , dataLen , toLowerCase ? DIGITS_LOWER : DIGITS_UPPER , out , 0 ) ; MST[rv.ROR3Mutator]MSP[] return out ; } public static void encodeHex ( final byte [] data , final int dataOffset , final int dataLen ,
int f = toDigit ( data [ j ] , j ) << 4 ; j ++ ; f = f | toDigit ( data [ j ] , j ) ; j ++ ; out [ i ] = (byte) ( f & 0xFF ) ; MST[rv.CRCR1Mutator]MSP[] }
encodeHex ( data , dataOffset , dataLen , toLowerCase ? DIGITS_LOWER : DIGITS_UPPER , out , 0 ) ; MST[rv.ROR5Mutator]MSP[] return out ; } public static void encodeHex ( final byte [] data , final int dataOffset , final int dataLen ,
return outLen ; } public static byte [] decodeHex ( final String data ) throws DecoderException { return decodeHex ( data . toCharArray () ) ; MST[ReturnValsMutator]MSP[] } public static char [] encodeHex ( final byte [] data ) { return encodeHex ( data , true ) ; }
final byte [] byteArray = byteBuffer . array () ; MST[NonVoidMethodCallMutator]MSP[] if ( remaining == byteArray . length ) { byteBuffer . position ( remaining ) ; return byteArray ; } } final byte [] byteArray = new byte [ remaining ] ; byteBuffer . get ( byteArray ) ;
public byte [] decode ( final ByteBuffer buffer ) throws DecoderException { return decodeHex ( new String ( toByteArray ( buffer ) , getCharset () ) . toCharArray () ) ; MST[NullReturnValsMutator]MSP[] } @Override public Object decode ( final Object object ) throws DecoderException {
int f = toDigit ( data [ j ] , j ) << 4 ; MST[NonVoidMethodCallMutator]MSP[] j ++ ; f = f | toDigit ( data [ j ] , j ) ; j ++ ; out [ i ] = (byte) ( f & 0xFF ) ; }
final int outLen = len >> 1 ; if ( out . length - outOffset < outLen ) { throw new DecoderException ( lr_2 ) ; } for ( int i = outOffset , j = 0 ; j < len ; i ++ ) { MST[rv.ROR2Mutator]MSP[]
return outLen ; MST[PrimitiveReturnsMutator]MSP[] } public static byte [] decodeHex ( final String data ) throws DecoderException { return decodeHex ( data . toCharArray () ) ; } public static char [] encodeHex ( final byte [] data ) { return encodeHex ( data , true ) ; }
public byte [] encode ( final byte [] array ) { return encodeHexString ( array ) . getBytes ( this . getCharset () ) ; MST[NullReturnValsMutator]MSP[] } public byte [] encode ( final ByteBuffer array ) { return encodeHexString ( array ) . getBytes ( this . getCharset () ) ;
return new String ( encodeHex ( data , toLowerCase ) ) ; MST[ConstructorCallMutator]MSP[] } private static byte [] toByteArray ( final ByteBuffer byteBuffer ) { final int remaining = byteBuffer . remaining () ; if ( byteBuffer . hasArray () ) {
return byteArray ; } protected static int toDigit ( final char ch , final int index ) throws DecoderException { final int digit = Character . digit ( ch , 16 ) ; MST[rv.UOI3Mutator]MSP[] if ( digit == - 1 ) {
public byte [] encode ( final byte [] array ) { return encodeHexString ( array ) . getBytes ( this . getCharset () ) ; MST[NonVoidMethodCallMutator]MSP[] } public byte [] encode ( final ByteBuffer array ) { return encodeHexString ( array ) . getBytes ( this . getCharset () ) ;
for ( int i = dataOffset , j = outOffset ; i < dataOffset + dataLen ; i ++ ) { MST[rv.UOI4Mutator]MSP[] out [ j ++ ] = toDigits [ ( 0xF0 & data [ i ] ) >>> 4 ] ;
return new String ( encodeHex ( data , toLowerCase ) ) ; } public static String encodeHexString ( final ByteBuffer data ) { return new String ( encodeHex ( data ) ) ; MST[NonVoidMethodCallMutator]MSP[] } public static String encodeHexString ( final ByteBuffer data , final boolean toLowerCase ) {
if ( object instanceof String ) { return decode ( ( ( String ) object ) . toCharArray () ) ; } else if ( object instanceof byte [] ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return decode ( ( byte [] ) object ) ; } else if ( object instanceof ByteBuffer ) {
int f = toDigit ( data [ j ] , j ) << 4 ; MST[rv.UOI2Mutator]MSP[] j ++ ; f = f | toDigit ( data [ j ] , j ) ; j ++ ; out [ i ] = (byte) ( f & 0xFF ) ; }
return new String ( encodeHex ( data , toLowerCase ) ) ; MST[rv.UOI4Mutator]MSP[] } private static byte [] toByteArray ( final ByteBuffer byteBuffer ) { final int remaining = byteBuffer . remaining () ; if ( byteBuffer . hasArray () ) {
if ( object instanceof String ) { MST[rv.ROR5Mutator]MSP[] return decode ( ( ( String ) object ) . toCharArray () ) ; } else if ( object instanceof byte [] ) { return decode ( ( byte [] ) object ) ; } else if ( object instanceof ByteBuffer ) {
int f = toDigit ( data [ j ] , j ) << 4 ; j ++ ; f = f | toDigit ( data [ j ] , j ) ; j ++ ; out [ i ] = (byte) ( f & 0xFF ) ; MST[rv.UOI4Mutator]MSP[] }
public static char [] encodeHex ( final byte [] data , final int dataOffset , final int dataLen , final boolean toLowerCase ) { final char [] out = new char [ dataLen << 1 ] ; MST[rv.CRCR6Mutator]MSP[]
public static char [] encodeHex ( final byte [] data , final boolean toLowerCase ) { return encodeHex ( data , toLowerCase ? DIGITS_LOWER : DIGITS_UPPER ) ; MST[rv.UOI2Mutator]MSP[] } protected static char [] encodeHex ( final byte [] data , final char [] toDigits ) {
encodeHex ( data , dataOffset , dataLen , toLowerCase ? DIGITS_LOWER : DIGITS_UPPER , out , 0 ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return out ; } public static void encodeHex ( final byte [] data , final int dataOffset , final int dataLen ,
return decode ( ( ByteBuffer ) object ) ; MST[NonVoidMethodCallMutator]MSP[] } else { try { return decodeHex ( ( char [] ) object ) ; } catch ( final ClassCastException e ) { throw new DecoderException ( e . getMessage () , e ) ; } } } @Override
public static char [] encodeHex ( final ByteBuffer data , final boolean toLowerCase ) { return encodeHex ( data , toLowerCase ? DIGITS_LOWER : DIGITS_UPPER ) ; MST[rv.UOI1Mutator]MSP[] } protected static char [] encodeHex ( final ByteBuffer byteBuffer , final char [] toDigits ) {
throw new DecoderException ( lr_3 + ch + lr_4 + index ) ; MST[rv.UOI2Mutator]MSP[] } return digit ; } @Override public byte [] decode ( final byte [] array ) throws DecoderException { return decodeHex ( new String ( array , getCharset () ) . toCharArray () ) ; }
return new String ( encodeHex ( data , toLowerCase ) ) ; MST[ReturnValsMutator]MSP[] } private static byte [] toByteArray ( final ByteBuffer byteBuffer ) { final int remaining = byteBuffer . remaining () ; if ( byteBuffer . hasArray () ) {
return byteArray ; } protected static int toDigit ( final char ch , final int index ) throws DecoderException { final int digit = Character . digit ( ch , 16 ) ; if ( digit == - 1 ) { MST[rv.CRCR5Mutator]MSP[]
throw new DecoderException ( lr_3 + ch + lr_4 + index ) ; MST[rv.ABSMutator]MSP[] } return digit ; } @Override public byte [] decode ( final byte [] array ) throws DecoderException { return decodeHex ( new String ( array , getCharset () ) . toCharArray () ) ; }
public static char [] encodeHex ( final ByteBuffer data , final boolean toLowerCase ) { return encodeHex ( data , toLowerCase ? DIGITS_LOWER : DIGITS_UPPER ) ; MST[ArgumentPropagationMutator]MSP[] } protected static char [] encodeHex ( final ByteBuffer byteBuffer , final char [] toDigits ) {
for ( int i = dataOffset , j = outOffset ; i < dataOffset + dataLen ; i ++ ) { MST[rv.AOD1Mutator]MSP[] out [ j ++ ] = toDigits [ ( 0xF0 & data [ i ] ) >>> 4 ] ;
final byte [] byteArray = byteBuffer . array () ; if ( remaining == byteArray . length ) { byteBuffer . position ( remaining ) ; MST[rv.UOI1Mutator]MSP[] return byteArray ; } } final byte [] byteArray = new byte [ remaining ] ; byteBuffer . get ( byteArray ) ;
final int outLen = len >> 1 ; if ( out . length - outOffset < outLen ) { MST[rv.UOI3Mutator]MSP[] throw new DecoderException ( lr_2 ) ; } for ( int i = outOffset , j = 0 ; j < len ; i ++ ) {
throw new DecoderException ( lr_3 + ch + lr_4 + index ) ; MST[NonVoidMethodCallMutator]MSP[] } return digit ; } @Override public byte [] decode ( final byte [] array ) throws DecoderException { return decodeHex ( new String ( array , getCharset () ) . toCharArray () ) ; }
final byte [] byteArray = byteBuffer . array () ; if ( remaining == byteArray . length ) { MST[rv.ROR3Mutator]MSP[] byteBuffer . position ( remaining ) ; return byteArray ; } } final byte [] byteArray = new byte [ remaining ] ; byteBuffer . get ( byteArray ) ;
return outLen ; } public static byte [] decodeHex ( final String data ) throws DecoderException { return decodeHex ( data . toCharArray () ) ; } public static char [] encodeHex ( final byte [] data ) { return encodeHex ( data , true ) ; MST[rv.CRCR6Mutator]MSP[] }
public static char [] encodeHex ( final byte [] data , final int dataOffset , final int dataLen , final boolean toLowerCase ) { final char [] out = new char [ dataLen << 1 ] ; MST[rv.UOI3Mutator]MSP[]
encodeHex ( data , dataOffset , dataLen , toLowerCase ? DIGITS_LOWER : DIGITS_UPPER , out , 0 ) ; MST[rv.UOI2Mutator]MSP[] return out ; } public static void encodeHex ( final byte [] data , final int dataOffset , final int dataLen ,
return super . toString () + lr_5 + this . charset + lr_6 ; MST[ConstructorCallMutator]MSP[] }
return encodeHex ( byteArray ) ; } public Charset getCharset () { return this . charset ; MST[ReturnValsMutator]MSP[] } public String getCharsetName () { return this . charset . name () ; } @Override public String toString () {
return byteArray ; } protected static int toDigit ( final char ch , final int index ) throws DecoderException { final int digit = Character . digit ( ch , 16 ) ; if ( digit == - 1 ) { MST[rv.CRCR1Mutator]MSP[]
if ( object instanceof String ) { return decode ( ( ( String ) object ) . toCharArray () ) ; } else if ( object instanceof byte [] ) { MST[rv.ROR3Mutator]MSP[] return decode ( ( byte [] ) object ) ; } else if ( object instanceof ByteBuffer ) {
return super . toString () + lr_5 + this . charset + lr_6 ; MST[experimental.NakedReceiverMutator]MSP[] }
public static int decodeHex ( final char [] data , final byte [] out , final int outOffset ) throws DecoderException { final int len = data . length ; if ( ( len & 0x01 ) != 0 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] throw new DecoderException ( lr_1 ) ; }
encodeHex ( data , dataOffset , dataLen , toLowerCase ? DIGITS_LOWER : DIGITS_UPPER , out , 0 ) ; MST[rv.CRCR6Mutator]MSP[] return out ; } public static void encodeHex ( final byte [] data , final int dataOffset , final int dataLen ,
final int outLen = len >> 1 ; if ( out . length - outOffset < outLen ) { throw new DecoderException ( lr_2 ) ; } for ( int i = outOffset , j = 0 ; j < len ; i ++ ) { MST[rv.ABSMutator]MSP[]
final int outLen = len >> 1 ; if ( out . length - outOffset < outLen ) { throw new DecoderException ( lr_2 ) ; } for ( int i = outOffset , j = 0 ; j < len ; i ++ ) { MST[rv.CRCR3Mutator]MSP[]
for ( int i = dataOffset , j = outOffset ; i < dataOffset + dataLen ; i ++ ) { MST[rv.UOI3Mutator]MSP[] out [ j ++ ] = toDigits [ ( 0xF0 & data [ i ] ) >>> 4 ] ;
public byte [] decode ( final ByteBuffer buffer ) throws DecoderException { return decodeHex ( new String ( toByteArray ( buffer ) , getCharset () ) . toCharArray () ) ; MST[NonVoidMethodCallMutator]MSP[] } @Override public Object decode ( final Object object ) throws DecoderException {
return new String ( encodeHex ( data , toLowerCase ) ) ; } private static byte [] toByteArray ( final ByteBuffer byteBuffer ) { final int remaining = byteBuffer . remaining () ; if ( byteBuffer . hasArray () ) { MST[NegateConditionalsMutator]MSP[]
encodeHex ( data , dataOffset , dataLen , toLowerCase ? DIGITS_LOWER : DIGITS_UPPER , out , 0 ) ; MST[rv.CRCR1Mutator]MSP[] return out ; } public static void encodeHex ( final byte [] data , final int dataOffset , final int dataLen ,
if ( object instanceof String ) { MST[NegateConditionalsMutator]MSP[] return decode ( ( ( String ) object ) . toCharArray () ) ; } else if ( object instanceof byte [] ) { return decode ( ( byte [] ) object ) ; } else if ( object instanceof ByteBuffer ) {
if ( object instanceof String ) { return decode ( ( ( String ) object ) . toCharArray () ) ; } else if ( object instanceof byte [] ) { return decode ( ( byte [] ) object ) ; MST[ArgumentPropagationMutator]MSP[] } else if ( object instanceof ByteBuffer ) {
return byteArray ; } protected static int toDigit ( final char ch , final int index ) throws DecoderException { final int digit = Character . digit ( ch , 16 ) ; MST[NonVoidMethodCallMutator]MSP[] if ( digit == - 1 ) {
return encodeHex ( toByteArray ( byteBuffer ) , toDigits ) ; MST[NonVoidMethodCallMutator]MSP[] } public static String encodeHexString ( final byte [] data ) { return new String ( encodeHex ( data ) ) ; } public static String encodeHexString ( final byte [] data , final boolean toLowerCase ) {
} @Override public Object encode ( final Object object ) throws EncoderException { byte [] byteArray ; if ( object instanceof String ) { byteArray = ( ( String ) object ) . getBytes ( this . getCharset () ) ; MST[NonVoidMethodCallMutator]MSP[] } else if ( object instanceof ByteBuffer ) {
final int outLen = len >> 1 ; if ( out . length - outOffset < outLen ) { throw new DecoderException ( lr_2 ) ; } for ( int i = outOffset , j = 0 ; j < len ; i ++ ) { MST[rv.UOI2Mutator]MSP[]
throw new DecoderException ( lr_3 + ch + lr_4 + index ) ; MST[ConstructorCallMutator]MSP[] } return digit ; } @Override public byte [] decode ( final byte [] array ) throws DecoderException { return decodeHex ( new String ( array , getCharset () ) . toCharArray () ) ; }
final int outLen = len >> 1 ; MST[rv.CRCR6Mutator]MSP[] if ( out . length - outOffset < outLen ) { throw new DecoderException ( lr_2 ) ; } for ( int i = outOffset , j = 0 ; j < len ; i ++ ) {
return outLen ; } public static byte [] decodeHex ( final String data ) throws DecoderException { return decodeHex ( data . toCharArray () ) ; } public static char [] encodeHex ( final byte [] data ) { return encodeHex ( data , true ) ; MST[rv.CRCR5Mutator]MSP[] }
public static char [] encodeHex ( final byte [] data , final int dataOffset , final int dataLen , final boolean toLowerCase ) { final char [] out = new char [ dataLen << 1 ] ; MST[rv.UOI4Mutator]MSP[]
encodeHex ( data , dataOffset , dataLen , toLowerCase ? DIGITS_LOWER : DIGITS_UPPER , out , 0 ) ; MST[rv.UOI1Mutator]MSP[] return out ; } public static void encodeHex ( final byte [] data , final int dataOffset , final int dataLen ,
return byteArray ; } protected static int toDigit ( final char ch , final int index ) throws DecoderException { final int digit = Character . digit ( ch , 16 ) ; MST[rv.CRCR4Mutator]MSP[] if ( digit == - 1 ) {
if ( object instanceof String ) { return decode ( ( ( String ) object ) . toCharArray () ) ; } else if ( object instanceof byte [] ) { MST[rv.ROR4Mutator]MSP[] return decode ( ( byte [] ) object ) ; } else if ( object instanceof ByteBuffer ) {
if ( object instanceof String ) { return decode ( ( ( String ) object ) . toCharArray () ) ; } else if ( object instanceof byte [] ) { return decode ( ( byte [] ) object ) ; MST[ReturnValsMutator]MSP[] } else if ( object instanceof ByteBuffer ) {
final int outLen = len >> 1 ; if ( out . length - outOffset < outLen ) { throw new DecoderException ( lr_2 ) ; MST[ConstructorCallMutator]MSP[] } for ( int i = outOffset , j = 0 ; j < len ; i ++ ) {
public static int decodeHex ( final char [] data , final byte [] out , final int outOffset ) throws DecoderException { final int len = data . length ; if ( ( len & 0x01 ) != 0 ) { MST[rv.ROR3Mutator]MSP[] throw new DecoderException ( lr_1 ) ; }
final int outLen = len >> 1 ; if ( out . length - outOffset < outLen ) { throw new DecoderException ( lr_2 ) ; } for ( int i = outOffset , j = 0 ; j < len ; i ++ ) { MST[rv.ROR1Mutator]MSP[]
return byteArray ; } protected static int toDigit ( final char ch , final int index ) throws DecoderException { final int digit = Character . digit ( ch , 16 ) ; MST[rv.UOI2Mutator]MSP[] if ( digit == - 1 ) {
if ( object instanceof String ) { return decode ( ( ( String ) object ) . toCharArray () ) ; } else if ( object instanceof byte [] ) { return decode ( ( byte [] ) object ) ; } else if ( object instanceof ByteBuffer ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
public static int decodeHex ( final char [] data , final byte [] out , final int outOffset ) throws DecoderException { final int len = data . length ; if ( ( len & 0x01 ) != 0 ) { MST[rv.OBBN2Mutator]MSP[] throw new DecoderException ( lr_1 ) ; }
int f = toDigit ( data [ j ] , j ) << 4 ; MST[rv.UOI1Mutator]MSP[] j ++ ; f = f | toDigit ( data [ j ] , j ) ; j ++ ; out [ i ] = (byte) ( f & 0xFF ) ; }
for ( int i = dataOffset , j = outOffset ; i < dataOffset + dataLen ; i ++ ) { MST[rv.ABSMutator]MSP[] out [ j ++ ] = toDigits [ ( 0xF0 & data [ i ] ) >>> 4 ] ;
public byte [] encode ( final byte [] array ) { return encodeHexString ( array ) . getBytes ( this . getCharset () ) ; MST[NonVoidMethodCallMutator]MSP[] } public byte [] encode ( final ByteBuffer array ) { return encodeHexString ( array ) . getBytes ( this . getCharset () ) ;
return super . toString () + lr_5 + this . charset + lr_6 ; MST[EmptyObjectReturnValsMutator]MSP[] }
out [ j ++ ] = toDigits [ 0x0F & data [ i ] ] ; } } public static char [] encodeHex ( final ByteBuffer data ) { return encodeHex ( data , true ) ; MST[rv.CRCR2Mutator]MSP[] }
return byteArray ; } protected static int toDigit ( final char ch , final int index ) throws DecoderException { final int digit = Character . digit ( ch , 16 ) ; if ( digit == - 1 ) { MST[rv.UOI4Mutator]MSP[]
public static char [] encodeHex ( final byte [] data , final int dataOffset , final int dataLen , final boolean toLowerCase ) { final char [] out = new char [ dataLen << 1 ] ; MST[rv.CRCR5Mutator]MSP[]
return super . toString () + lr_5 + this . charset + lr_6 ; MST[NonVoidMethodCallMutator]MSP[] }
final int outLen = len >> 1 ; if ( out . length - outOffset < outLen ) { throw new DecoderException ( lr_2 ) ; } for ( int i = outOffset , j = 0 ; j < len ; i ++ ) { MST[rv.UOI4Mutator]MSP[]
public static char [] encodeHex ( final ByteBuffer data , final boolean toLowerCase ) { return encodeHex ( data , toLowerCase ? DIGITS_LOWER : DIGITS_UPPER ) ; MST[ReturnValsMutator]MSP[] } protected static char [] encodeHex ( final ByteBuffer byteBuffer , final char [] toDigits ) {
public static char [] encodeHex ( final ByteBuffer data , final boolean toLowerCase ) { return encodeHex ( data , toLowerCase ? DIGITS_LOWER : DIGITS_UPPER ) ; MST[NegateConditionalsMutator]MSP[] } protected static char [] encodeHex ( final ByteBuffer byteBuffer , final char [] toDigits ) {
public static char [] encodeHex ( final byte [] data , final boolean toLowerCase ) { return encodeHex ( data , toLowerCase ? DIGITS_LOWER : DIGITS_UPPER ) ; MST[rv.UOI3Mutator]MSP[] } protected static char [] encodeHex ( final byte [] data , final char [] toDigits ) {
throw new DecoderException ( lr_3 + ch + lr_4 + index ) ; MST[rv.UOI4Mutator]MSP[] } return digit ; } @Override public byte [] decode ( final byte [] array ) throws DecoderException { return decodeHex ( new String ( array , getCharset () ) . toCharArray () ) ; }
throw new DecoderException ( lr_3 + ch + lr_4 + index ) ; MST[rv.UOI3Mutator]MSP[] } return digit ; } @Override public byte [] decode ( final byte [] array ) throws DecoderException { return decodeHex ( new String ( array , getCharset () ) . toCharArray () ) ; }
final int l = data . length ; final char [] out = new char [ l << 1 ] ; MST[rv.UOI2Mutator]MSP[] encodeHex ( data , 0 , data . length , toDigits , out , 0 ) ; return out ; }
final int outLen = len >> 1 ; if ( out . length - outOffset < outLen ) { MST[rv.UOI3Mutator]MSP[] throw new DecoderException ( lr_2 ) ; } for ( int i = outOffset , j = 0 ; j < len ; i ++ ) {
public static char [] encodeHex ( final byte [] data , final int dataOffset , final int dataLen , final boolean toLowerCase ) { final char [] out = new char [ dataLen << 1 ] ; MST[rv.ABSMutator]MSP[]
throw new DecoderException ( lr_3 + ch + lr_4 + index ) ; MST[NonVoidMethodCallMutator]MSP[] } return digit ; } @Override public byte [] decode ( final byte [] array ) throws DecoderException { return decodeHex ( new String ( array , getCharset () ) . toCharArray () ) ; }
final int outLen = len >> 1 ; if ( out . length - outOffset < outLen ) { MST[ConditionalsBoundaryMutator]MSP[] throw new DecoderException ( lr_2 ) ; } for ( int i = outOffset , j = 0 ; j < len ; i ++ ) {
int f = toDigit ( data [ j ] , j ) << 4 ; j ++ ; f = f | toDigit ( data [ j ] , j ) ; j ++ ; out [ i ] = (byte) ( f & 0xFF ) ; MST[rv.ABSMutator]MSP[] }
out [ j ++ ] = toDigits [ 0x0F & data [ i ] ] ; MST[experimental.RemoveIncrementsMutator]MSP[] } } public static char [] encodeHex ( final ByteBuffer data ) { return encodeHex ( data , true ) ; }
return new String ( encodeHex ( data , toLowerCase ) ) ; } private static byte [] toByteArray ( final ByteBuffer byteBuffer ) { final int remaining = byteBuffer . remaining () ; if ( byteBuffer . hasArray () ) { MST[rv.ROR4Mutator]MSP[]
encodeHex ( data , dataOffset , dataLen , toLowerCase ? DIGITS_LOWER : DIGITS_UPPER , out , 0 ) ; MST[rv.UOI1Mutator]MSP[] return out ; } public static void encodeHex ( final byte [] data , final int dataOffset , final int dataLen ,
encodeHex ( data , dataOffset , dataLen , toLowerCase ? DIGITS_LOWER : DIGITS_UPPER , out , 0 ) ; MST[NegateConditionalsMutator]MSP[] return out ; } public static void encodeHex ( final byte [] data , final int dataOffset , final int dataLen ,
return new String ( encodeHex ( data , toLowerCase ) ) ; } public static String encodeHexString ( final ByteBuffer data ) { return new String ( encodeHex ( data ) ) ; MST[EmptyObjectReturnValsMutator]MSP[] } public static String encodeHexString ( final ByteBuffer data , final boolean toLowerCase ) {
if ( object instanceof String ) { return decode ( ( ( String ) object ) . toCharArray () ) ; } else if ( object instanceof byte [] ) { return decode ( ( byte [] ) object ) ; } else if ( object instanceof ByteBuffer ) { MST[rv.ROR3Mutator]MSP[]
out [ j ++ ] = toDigits [ 0x0F & data [ i ] ] ; MST[rv.CRCR2Mutator]MSP[] } } public static char [] encodeHex ( final ByteBuffer data ) { return encodeHex ( data , true ) ; }
int f = toDigit ( data [ j ] , j ) << 4 ; MST[MathMutator]MSP[] j ++ ; f = f | toDigit ( data [ j ] , j ) ; j ++ ; out [ i ] = (byte) ( f & 0xFF ) ; }
encodeHex ( data , dataOffset , dataLen , toLowerCase ? DIGITS_LOWER : DIGITS_UPPER , out , 0 ) ; MST[rv.ROR4Mutator]MSP[] return out ; } public static void encodeHex ( final byte [] data , final int dataOffset , final int dataLen ,
for ( int i = dataOffset , j = outOffset ; i < dataOffset + dataLen ; i ++ ) { MST[rv.ROR1Mutator]MSP[] out [ j ++ ] = toDigits [ ( 0xF0 & data [ i ] ) >>> 4 ] ;
return super . toString () + lr_5 + this . charset + lr_6 ; MST[experimental.NakedReceiverMutator]MSP[] }
public byte [] decode ( final ByteBuffer buffer ) throws DecoderException { return decodeHex ( new String ( toByteArray ( buffer ) , getCharset () ) . toCharArray () ) ; MST[ReturnValsMutator]MSP[] } @Override public Object decode ( final Object object ) throws DecoderException {
public byte [] decode ( final ByteBuffer buffer ) throws DecoderException { return decodeHex ( new String ( toByteArray ( buffer ) , getCharset () ) . toCharArray () ) ; MST[NonVoidMethodCallMutator]MSP[] } @Override public Object decode ( final Object object ) throws DecoderException {
public static char [] encodeHex ( final ByteBuffer data , final boolean toLowerCase ) { return encodeHex ( data , toLowerCase ? DIGITS_LOWER : DIGITS_UPPER ) ; MST[rv.ROR1Mutator]MSP[] } protected static char [] encodeHex ( final ByteBuffer byteBuffer , final char [] toDigits ) {
} @Override public Object encode ( final Object object ) throws EncoderException { byte [] byteArray ; if ( object instanceof String ) { byteArray = ( ( String ) object ) . getBytes ( this . getCharset () ) ; } else if ( object instanceof ByteBuffer ) { MST[rv.ROR4Mutator]MSP[]
public static byte [] decodeHex ( final char [] data ) throws DecoderException { final byte [] out = new byte [ data . length >> 1 ] ; decodeHex ( data , out , 0 ) ; MST[rv.CRCR5Mutator]MSP[] return out ; }
public static char [] encodeHex ( final byte [] data , final boolean toLowerCase ) { return encodeHex ( data , toLowerCase ? DIGITS_LOWER : DIGITS_UPPER ) ; MST[rv.ROR4Mutator]MSP[] } protected static char [] encodeHex ( final byte [] data , final char [] toDigits ) {
public static char [] encodeHex ( final ByteBuffer data , final boolean toLowerCase ) { return encodeHex ( data , toLowerCase ? DIGITS_LOWER : DIGITS_UPPER ) ; MST[rv.ROR5Mutator]MSP[] } protected static char [] encodeHex ( final ByteBuffer byteBuffer , final char [] toDigits ) {
return new String ( encodeHex ( data , toLowerCase ) ) ; } private static byte [] toByteArray ( final ByteBuffer byteBuffer ) { final int remaining = byteBuffer . remaining () ; if ( byteBuffer . hasArray () ) { MST[rv.ROR1Mutator]MSP[]
final byte [] byteArray = byteBuffer . array () ; if ( remaining == byteArray . length ) { byteBuffer . position ( remaining ) ; MST[rv.UOI4Mutator]MSP[] return byteArray ; } } final byte [] byteArray = new byte [ remaining ] ; byteBuffer . get ( byteArray ) ;
public byte [] encode ( final byte [] array ) { return encodeHexString ( array ) . getBytes ( this . getCharset () ) ; } public byte [] encode ( final ByteBuffer array ) { return encodeHexString ( array ) . getBytes ( this . getCharset () ) ; MST[NullReturnValsMutator]MSP[]
return byteArray ; } protected static int toDigit ( final char ch , final int index ) throws DecoderException { final int digit = Character . digit ( ch , 16 ) ; if ( digit == - 1 ) { MST[rv.CRCR4Mutator]MSP[]
final byte [] byteArray = byteBuffer . array () ; if ( remaining == byteArray . length ) { MST[rv.ROR4Mutator]MSP[] byteBuffer . position ( remaining ) ; return byteArray ; } } final byte [] byteArray = new byte [ remaining ] ; byteBuffer . get ( byteArray ) ;
final int outLen = len >> 1 ; if ( out . length - outOffset < outLen ) { MST[rv.UOI4Mutator]MSP[] throw new DecoderException ( lr_2 ) ; } for ( int i = outOffset , j = 0 ; j < len ; i ++ ) {
return new String ( encodeHex ( data , toLowerCase ) ) ; } private static byte [] toByteArray ( final ByteBuffer byteBuffer ) { final int remaining = byteBuffer . remaining () ; if ( byteBuffer . hasArray () ) { MST[rv.ROR5Mutator]MSP[]
} @Override public Object encode ( final Object object ) throws EncoderException { byte [] byteArray ; if ( object instanceof String ) { MST[rv.ROR4Mutator]MSP[] byteArray = ( ( String ) object ) . getBytes ( this . getCharset () ) ; } else if ( object instanceof ByteBuffer ) {
if ( object instanceof String ) { return decode ( ( ( String ) object ) . toCharArray () ) ; } else if ( object instanceof byte [] ) { return decode ( ( byte [] ) object ) ; MST[NonVoidMethodCallMutator]MSP[] } else if ( object instanceof ByteBuffer ) {
return super . toString () + lr_5 + this . charset + lr_6 ; MST[experimental.NakedReceiverMutator]MSP[] }
return byteArray ; MST[ReturnValsMutator]MSP[] } protected static int toDigit ( final char ch , final int index ) throws DecoderException { final int digit = Character . digit ( ch , 16 ) ; if ( digit == - 1 ) {
final int l = data . length ; final char [] out = new char [ l << 1 ] ; MST[rv.UOI1Mutator]MSP[] encodeHex ( data , 0 , data . length , toDigits , out , 0 ) ; return out ; }
int f = toDigit ( data [ j ] , j ) << 4 ; j ++ ; f = f | toDigit ( data [ j ] , j ) ; MST[rv.UOI2Mutator]MSP[] j ++ ; out [ i ] = (byte) ( f & 0xFF ) ; }
final boolean toLowerCase , final char [] out , final int outOffset ) { encodeHex ( data , dataOffset , dataLen , toLowerCase ? DIGITS_LOWER : DIGITS_UPPER , out , outOffset ) ; MST[rv.UOI4Mutator]MSP[] }
return byteArray ; } protected static int toDigit ( final char ch , final int index ) throws DecoderException { final int digit = Character . digit ( ch , 16 ) ; MST[InlineConstantMutator]MSP[] if ( digit == - 1 ) {
return new String ( encodeHex ( data , toLowerCase ) ) ; MST[ReturnValsMutator]MSP[] } public static String encodeHexString ( final ByteBuffer data ) { return new String ( encodeHex ( data ) ) ; } public static String encodeHexString ( final ByteBuffer data , final boolean toLowerCase ) {
return new String ( encodeHex ( data , toLowerCase ) ) ; MST[rv.UOI1Mutator]MSP[] } private static byte [] toByteArray ( final ByteBuffer byteBuffer ) { final int remaining = byteBuffer . remaining () ; if ( byteBuffer . hasArray () ) {
final int outLen = len >> 1 ; if ( out . length - outOffset < outLen ) { throw new DecoderException ( lr_2 ) ; } for ( int i = outOffset , j = 0 ; j < len ; i ++ ) { MST[rv.ABSMutator]MSP[]
final boolean toLowerCase , final char [] out , final int outOffset ) { encodeHex ( data , dataOffset , dataLen , toLowerCase ? DIGITS_LOWER : DIGITS_UPPER , out , outOffset ) ; MST[rv.UOI2Mutator]MSP[] }
return decode ( ( ByteBuffer ) object ) ; } else { try { return decodeHex ( ( char [] ) object ) ; } catch ( final ClassCastException e ) { throw new DecoderException ( e . getMessage () , e ) ; MST[NonVoidMethodCallMutator]MSP[] } } } @Override
return super . toString () + lr_5 + this . charset + lr_6 ; MST[NonVoidMethodCallMutator]MSP[] }
return new String ( encodeHex ( data , toLowerCase ) ) ; } private static byte [] toByteArray ( final ByteBuffer byteBuffer ) { final int remaining = byteBuffer . remaining () ; if ( byteBuffer . hasArray () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
final byte [] byteArray = byteBuffer . array () ; if ( remaining == byteArray . length ) { byteBuffer . position ( remaining ) ; return byteArray ; MST[ReturnValsMutator]MSP[] } } final byte [] byteArray = new byte [ remaining ] ; byteBuffer . get ( byteArray ) ;
int f = toDigit ( data [ j ] , j ) << 4 ; MST[rv.UOI3Mutator]MSP[] j ++ ; f = f | toDigit ( data [ j ] , j ) ; j ++ ; out [ i ] = (byte) ( f & 0xFF ) ; }
final int outLen = len >> 1 ; if ( out . length - outOffset < outLen ) { throw new DecoderException ( lr_2 ) ; } for ( int i = outOffset , j = 0 ; j < len ; i ++ ) { MST[rv.ROR3Mutator]MSP[]
public static char [] encodeHex ( final ByteBuffer data , final boolean toLowerCase ) { return encodeHex ( data , toLowerCase ? DIGITS_LOWER : DIGITS_UPPER ) ; MST[NonVoidMethodCallMutator]MSP[] } protected static char [] encodeHex ( final ByteBuffer byteBuffer , final char [] toDigits ) {
return byteArray ; } protected static int toDigit ( final char ch , final int index ) throws DecoderException { final int digit = Character . digit ( ch , 16 ) ; if ( digit == - 1 ) { MST[rv.ROR5Mutator]MSP[]
public static byte [] decodeHex ( final char [] data ) throws DecoderException { final byte [] out = new byte [ data . length >> 1 ] ; decodeHex ( data , out , 0 ) ; MST[rv.CRCR1Mutator]MSP[] return out ; }
public static char [] encodeHex ( final ByteBuffer data , final boolean toLowerCase ) { return encodeHex ( data , toLowerCase ? DIGITS_LOWER : DIGITS_UPPER ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] } protected static char [] encodeHex ( final ByteBuffer byteBuffer , final char [] toDigits ) {
public static char [] encodeHex ( final byte [] data , final boolean toLowerCase ) { return encodeHex ( data , toLowerCase ? DIGITS_LOWER : DIGITS_UPPER ) ; MST[ArgumentPropagationMutator]MSP[] } protected static char [] encodeHex ( final byte [] data , final char [] toDigits ) {
return encodeHex ( toByteArray ( byteBuffer ) , toDigits ) ; MST[NullReturnValsMutator]MSP[] } public static String encodeHexString ( final byte [] data ) { return new String ( encodeHex ( data ) ) ; } public static String encodeHexString ( final byte [] data , final boolean toLowerCase ) {
return byteArray ; } protected static int toDigit ( final char ch , final int index ) throws DecoderException { final int digit = Character . digit ( ch , 16 ) ; MST[rv.CRCR3Mutator]MSP[] if ( digit == - 1 ) {
for ( int i = dataOffset , j = outOffset ; i < dataOffset + dataLen ; i ++ ) { MST[rv.AOR4Mutator]MSP[] out [ j ++ ] = toDigits [ ( 0xF0 & data [ i ] ) >>> 4 ] ;
int f = toDigit ( data [ j ] , j ) << 4 ; j ++ ; MST[IncrementsMutator]MSP[] f = f | toDigit ( data [ j ] , j ) ; j ++ ; out [ i ] = (byte) ( f & 0xFF ) ; }
out [ j ++ ] = toDigits [ 0x0F & data [ i ] ] ; MST[rv.UOI1Mutator]MSP[] } } public static char [] encodeHex ( final ByteBuffer data ) { return encodeHex ( data , true ) ; }
return byteArray ; } protected static int toDigit ( final char ch , final int index ) throws DecoderException { final int digit = Character . digit ( ch , 16 ) ; if ( digit == - 1 ) { MST[rv.ROR1Mutator]MSP[]
public byte [] decode ( final ByteBuffer buffer ) throws DecoderException { return decodeHex ( new String ( toByteArray ( buffer ) , getCharset () ) . toCharArray () ) ; MST[ConstructorCallMutator]MSP[] } @Override public Object decode ( final Object object ) throws DecoderException {
return decode ( ( ByteBuffer ) object ) ; } else { try { return decodeHex ( ( char [] ) object ) ; } catch ( final ClassCastException e ) { throw new DecoderException ( e . getMessage () , e ) ; MST[ConstructorCallMutator]MSP[] } } } @Override
return new String ( encodeHex ( data , toLowerCase ) ) ; MST[rv.UOI4Mutator]MSP[] } public static String encodeHexString ( final ByteBuffer data ) { return new String ( encodeHex ( data ) ) ; } public static String encodeHexString ( final ByteBuffer data , final boolean toLowerCase ) {
final int outLen = len >> 1 ; MST[InlineConstantMutator]MSP[] if ( out . length - outOffset < outLen ) { throw new DecoderException ( lr_2 ) ; } for ( int i = outOffset , j = 0 ; j < len ; i ++ ) {
if ( object instanceof String ) { return decode ( ( ( String ) object ) . toCharArray () ) ; } else if ( object instanceof byte [] ) { return decode ( ( byte [] ) object ) ; } else if ( object instanceof ByteBuffer ) { MST[rv.ROR1Mutator]MSP[]
if ( object instanceof String ) { return decode ( ( ( String ) object ) . toCharArray () ) ; } else if ( object instanceof byte [] ) { return decode ( ( byte [] ) object ) ; } else if ( object instanceof ByteBuffer ) { MST[rv.ROR5Mutator]MSP[]
for ( int i = dataOffset , j = outOffset ; i < dataOffset + dataLen ; i ++ ) { MST[MathMutator]MSP[] out [ j ++ ] = toDigits [ ( 0xF0 & data [ i ] ) >>> 4 ] ;
throw new DecoderException ( lr_3 + ch + lr_4 + index ) ; MST[experimental.NakedReceiverMutator]MSP[] } return digit ; } @Override public byte [] decode ( final byte [] array ) throws DecoderException { return decodeHex ( new String ( array , getCharset () ) . toCharArray () ) ; }
if ( object instanceof String ) { return decode ( ( ( String ) object ) . toCharArray () ) ; MST[NonVoidMethodCallMutator]MSP[] } else if ( object instanceof byte [] ) { return decode ( ( byte [] ) object ) ; } else if ( object instanceof ByteBuffer ) {
public static int decodeHex ( final char [] data , final byte [] out , final int outOffset ) throws DecoderException { final int len = data . length ; if ( ( len & 0x01 ) != 0 ) { MST[NegateConditionalsMutator]MSP[] throw new DecoderException ( lr_1 ) ; }
public byte [] encode ( final byte [] array ) { return encodeHexString ( array ) . getBytes ( this . getCharset () ) ; MST[ReturnValsMutator]MSP[] } public byte [] encode ( final ByteBuffer array ) { return encodeHexString ( array ) . getBytes ( this . getCharset () ) ;
encodeHex ( data , dataOffset , dataLen , toLowerCase ? DIGITS_LOWER : DIGITS_UPPER , out , 0 ) ; MST[rv.CRCR5Mutator]MSP[] return out ; } public static void encodeHex ( final byte [] data , final int dataOffset , final int dataLen ,
for ( int i = dataOffset , j = outOffset ; i < dataOffset + dataLen ; i ++ ) { MST[rv.ROR5Mutator]MSP[] out [ j ++ ] = toDigits [ ( 0xF0 & data [ i ] ) >>> 4 ] ;
return new String ( encodeHex ( data , toLowerCase ) ) ; MST[rv.ABSMutator]MSP[] } private static byte [] toByteArray ( final ByteBuffer byteBuffer ) { final int remaining = byteBuffer . remaining () ; if ( byteBuffer . hasArray () ) {
for ( int i = dataOffset , j = outOffset ; i < dataOffset + dataLen ; i ++ ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] out [ j ++ ] = toDigits [ ( 0xF0 & data [ i ] ) >>> 4 ] ;
final int l = data . length ; final char [] out = new char [ l << 1 ] ; MST[rv.CRCR5Mutator]MSP[] encodeHex ( data , 0 , data . length , toDigits , out , 0 ) ; return out ; }
return super . toString () + lr_5 + this . charset + lr_6 ; MST[NonVoidMethodCallMutator]MSP[] }
final int outLen = len >> 1 ; if ( out . length - outOffset < outLen ) { throw new DecoderException ( lr_2 ) ; } for ( int i = outOffset , j = 0 ; j < len ; i ++ ) { MST[rv.CRCR5Mutator]MSP[]
public byte [] decode ( final ByteBuffer buffer ) throws DecoderException { return decodeHex ( new String ( toByteArray ( buffer ) , getCharset () ) . toCharArray () ) ; MST[NonVoidMethodCallMutator]MSP[] } @Override public Object decode ( final Object object ) throws DecoderException {
byteArray = toByteArray ( ( ByteBuffer ) object ) ; } else { try { byteArray = ( byte [] ) object ; } catch ( final ClassCastException e ) { throw new EncoderException ( e . getMessage () , e ) ; MST[ConstructorCallMutator]MSP[] } }
final int outLen = len >> 1 ; if ( out . length - outOffset < outLen ) { throw new DecoderException ( lr_2 ) ; } for ( int i = outOffset , j = 0 ; j < len ; i ++ ) { MST[rv.UOI3Mutator]MSP[]
return outLen ; MST[rv.UOI4Mutator]MSP[] } public static byte [] decodeHex ( final String data ) throws DecoderException { return decodeHex ( data . toCharArray () ) ; } public static char [] encodeHex ( final byte [] data ) { return encodeHex ( data , true ) ; }
if ( object instanceof String ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return decode ( ( ( String ) object ) . toCharArray () ) ; } else if ( object instanceof byte [] ) { return decode ( ( byte [] ) object ) ; } else if ( object instanceof ByteBuffer ) {
return outLen ; MST[rv.UOI1Mutator]MSP[] } public static byte [] decodeHex ( final String data ) throws DecoderException { return decodeHex ( data . toCharArray () ) ; } public static char [] encodeHex ( final byte [] data ) { return encodeHex ( data , true ) ; }
return byteArray ; } protected static int toDigit ( final char ch , final int index ) throws DecoderException { final int digit = Character . digit ( ch , 16 ) ; MST[rv.CRCR2Mutator]MSP[] if ( digit == - 1 ) {
final int l = data . length ; final char [] out = new char [ l << 1 ] ; encodeHex ( data , 0 , data . length , toDigits , out , 0 ) ; MST[VoidMethodCallMutator]MSP[] return out ; }
encodeHex ( data , dataOffset , dataLen , toLowerCase ? DIGITS_LOWER : DIGITS_UPPER , out , 0 ) ; MST[rv.UOI3Mutator]MSP[] return out ; } public static void encodeHex ( final byte [] data , final int dataOffset , final int dataLen ,
byteArray = toByteArray ( ( ByteBuffer ) object ) ; } else { try { byteArray = ( byte [] ) object ; } catch ( final ClassCastException e ) { throw new EncoderException ( e . getMessage () , e ) ; MST[NonVoidMethodCallMutator]MSP[] } }
final int outLen = len >> 1 ; if ( out . length - outOffset < outLen ) { MST[rv.UOI4Mutator]MSP[] throw new DecoderException ( lr_2 ) ; } for ( int i = outOffset , j = 0 ; j < len ; i ++ ) {
final byte [] byteArray = byteBuffer . array () ; if ( remaining == byteArray . length ) { MST[rv.ABSMutator]MSP[] byteBuffer . position ( remaining ) ; return byteArray ; } } final byte [] byteArray = new byte [ remaining ] ; byteBuffer . get ( byteArray ) ;
encodeHex ( data , dataOffset , dataLen , toLowerCase ? DIGITS_LOWER : DIGITS_UPPER , out , 0 ) ; MST[rv.UOI2Mutator]MSP[] return out ; } public static void encodeHex ( final byte [] data , final int dataOffset , final int dataLen ,
return encodeHex ( toByteArray ( byteBuffer ) , toDigits ) ; } public static String encodeHexString ( final byte [] data ) { return new String ( encodeHex ( data ) ) ; MST[ConstructorCallMutator]MSP[] } public static String encodeHexString ( final byte [] data , final boolean toLowerCase ) {
final int outLen = len >> 1 ; MST[rv.CRCR2Mutator]MSP[] if ( out . length - outOffset < outLen ) { throw new DecoderException ( lr_2 ) ; } for ( int i = outOffset , j = 0 ; j < len ; i ++ ) {
public static int decodeHex ( final char [] data , final byte [] out , final int outOffset ) throws DecoderException { final int len = data . length ; if ( ( len & 0x01 ) != 0 ) { MST[rv.ROR5Mutator]MSP[] throw new DecoderException ( lr_1 ) ; }
if ( object instanceof String ) { return decode ( ( ( String ) object ) . toCharArray () ) ; } else if ( object instanceof byte [] ) { return decode ( ( byte [] ) object ) ; } else if ( object instanceof ByteBuffer ) { MST[NegateConditionalsMutator]MSP[]
return new String ( encodeHex ( data , toLowerCase ) ) ; } public static String encodeHexString ( final ByteBuffer data ) { return new String ( encodeHex ( data ) ) ; MST[ReturnValsMutator]MSP[] } public static String encodeHexString ( final ByteBuffer data , final boolean toLowerCase ) {
int f = toDigit ( data [ j ] , j ) << 4 ; j ++ ; f = f | toDigit ( data [ j ] , j ) ; MST[rv.UOI2Mutator]MSP[] j ++ ; out [ i ] = (byte) ( f & 0xFF ) ; }
for ( int i = dataOffset , j = outOffset ; i < dataOffset + dataLen ; i ++ ) { out [ j ++ ] = toDigits [ ( 0xF0 & data [ i ] ) >>> 4 ] ; MST[rv.UOI1Mutator]MSP[]
out [ j ++ ] = toDigits [ 0x0F & data [ i ] ] ; MST[IncrementsMutator]MSP[] } } public static char [] encodeHex ( final ByteBuffer data ) { return encodeHex ( data , true ) ; }
int f = toDigit ( data [ j ] , j ) << 4 ; j ++ ; f = f | toDigit ( data [ j ] , j ) ; j ++ ; MST[IncrementsMutator]MSP[] out [ i ] = (byte) ( f & 0xFF ) ; }
if ( object instanceof String ) { return decode ( ( ( String ) object ) . toCharArray () ) ; } else if ( object instanceof byte [] ) { MST[rv.ROR2Mutator]MSP[] return decode ( ( byte [] ) object ) ; } else if ( object instanceof ByteBuffer ) {
public static int decodeHex ( final char [] data , final byte [] out , final int outOffset ) throws DecoderException { final int len = data . length ; if ( ( len & 0x01 ) != 0 ) { MST[rv.UOI2Mutator]MSP[] throw new DecoderException ( lr_1 ) ; }
out [ j ++ ] = toDigits [ 0x0F & data [ i ] ] ; } } public static char [] encodeHex ( final ByteBuffer data ) { return encodeHex ( data , true ) ; MST[rv.CRCR3Mutator]MSP[] }
return byteArray ; } protected static int toDigit ( final char ch , final int index ) throws DecoderException { final int digit = Character . digit ( ch , 16 ) ; if ( digit == - 1 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
throw new DecoderException ( lr_3 + ch + lr_4 + index ) ; } return digit ; } @Override public byte [] decode ( final byte [] array ) throws DecoderException { return decodeHex ( new String ( array , getCharset () ) . toCharArray () ) ; MST[ConstructorCallMutator]MSP[] }
for ( int i = dataOffset , j = outOffset ; i < dataOffset + dataLen ; i ++ ) { MST[rv.UOI2Mutator]MSP[] out [ j ++ ] = toDigits [ ( 0xF0 & data [ i ] ) >>> 4 ] ;
public static int decodeHex ( final char [] data , final byte [] out , final int outOffset ) throws DecoderException { final int len = data . length ; if ( ( len & 0x01 ) != 0 ) { MST[MathMutator]MSP[] throw new DecoderException ( lr_1 ) ; }
public static int decodeHex ( final char [] data , final byte [] out , final int outOffset ) throws DecoderException { final int len = data . length ; if ( ( len & 0x01 ) != 0 ) { MST[rv.OBBN1Mutator]MSP[] throw new DecoderException ( lr_1 ) ; }
int f = toDigit ( data [ j ] , j ) << 4 ; j ++ ; f = f | toDigit ( data [ j ] , j ) ; MST[rv.OBBN1Mutator]MSP[] j ++ ; out [ i ] = (byte) ( f & 0xFF ) ; }
int f = toDigit ( data [ j ] , j ) << 4 ; MST[rv.UOI2Mutator]MSP[] j ++ ; f = f | toDigit ( data [ j ] , j ) ; j ++ ; out [ i ] = (byte) ( f & 0xFF ) ; }
public static char [] encodeHex ( final byte [] data , final int dataOffset , final int dataLen , final boolean toLowerCase ) { final char [] out = new char [ dataLen << 1 ] ; MST[rv.CRCR4Mutator]MSP[]
if ( object instanceof String ) { MST[rv.ROR3Mutator]MSP[] return decode ( ( ( String ) object ) . toCharArray () ) ; } else if ( object instanceof byte [] ) { return decode ( ( byte [] ) object ) ; } else if ( object instanceof ByteBuffer ) {
return decode ( ( ByteBuffer ) object ) ; } else { try { return decodeHex ( ( char [] ) object ) ; MST[NullReturnValsMutator]MSP[] } catch ( final ClassCastException e ) { throw new DecoderException ( e . getMessage () , e ) ; } } } @Override
final int outLen = len >> 1 ; if ( out . length - outOffset < outLen ) { MST[rv.ROR1Mutator]MSP[] throw new DecoderException ( lr_2 ) ; } for ( int i = outOffset , j = 0 ; j < len ; i ++ ) {
public static char [] encodeHex ( final byte [] data , final boolean toLowerCase ) { return encodeHex ( data , toLowerCase ? DIGITS_LOWER : DIGITS_UPPER ) ; MST[NegateConditionalsMutator]MSP[] } protected static char [] encodeHex ( final byte [] data , final char [] toDigits ) {
public static char [] encodeHex ( final ByteBuffer data , final boolean toLowerCase ) { return encodeHex ( data , toLowerCase ? DIGITS_LOWER : DIGITS_UPPER ) ; MST[rv.UOI3Mutator]MSP[] } protected static char [] encodeHex ( final ByteBuffer byteBuffer , final char [] toDigits ) {
throw new DecoderException ( lr_3 + ch + lr_4 + index ) ; MST[rv.UOI3Mutator]MSP[] } return digit ; } @Override public byte [] decode ( final byte [] array ) throws DecoderException { return decodeHex ( new String ( array , getCharset () ) . toCharArray () ) ; }
final int outLen = len >> 1 ; if ( out . length - outOffset < outLen ) { MST[rv.UOI1Mutator]MSP[] throw new DecoderException ( lr_2 ) ; } for ( int i = outOffset , j = 0 ; j < len ; i ++ ) {
encodeHex ( data , dataOffset , dataLen , toLowerCase ? DIGITS_LOWER : DIGITS_UPPER , out , 0 ) ; MST[rv.UOI3Mutator]MSP[] return out ; } public static void encodeHex ( final byte [] data , final int dataOffset , final int dataLen ,
final byte [] byteArray = byteBuffer . array () ; if ( remaining == byteArray . length ) { byteBuffer . position ( remaining ) ; MST[rv.UOI3Mutator]MSP[] return byteArray ; } } final byte [] byteArray = new byte [ remaining ] ; byteBuffer . get ( byteArray ) ;
for ( int i = dataOffset , j = outOffset ; i < dataOffset + dataLen ; i ++ ) { out [ j ++ ] = toDigits [ ( 0xF0 & data [ i ] ) >>> 4 ] ; MST[rv.CRCR1Mutator]MSP[]
public static int decodeHex ( final char [] data , final byte [] out , final int outOffset ) throws DecoderException { final int len = data . length ; if ( ( len & 0x01 ) != 0 ) { MST[rv.CRCR3Mutator]MSP[] throw new DecoderException ( lr_1 ) ; }
out [ j ++ ] = toDigits [ 0x0F & data [ i ] ] ; MST[rv.CRCR6Mutator]MSP[] } } public static char [] encodeHex ( final ByteBuffer data ) { return encodeHex ( data , true ) ; }
public static byte [] decodeHex ( final char [] data ) throws DecoderException { final byte [] out = new byte [ data . length >> 1 ] ; MST[rv.CRCR3Mutator]MSP[] decodeHex ( data , out , 0 ) ; return out ; }
return outLen ; } public static byte [] decodeHex ( final String data ) throws DecoderException { return decodeHex ( data . toCharArray () ) ; } public static char [] encodeHex ( final byte [] data ) { return encodeHex ( data , true ) ; MST[rv.CRCR4Mutator]MSP[] }
return encodeHex ( toByteArray ( byteBuffer ) , toDigits ) ; } public static String encodeHexString ( final byte [] data ) { return new String ( encodeHex ( data ) ) ; MST[EmptyObjectReturnValsMutator]MSP[] } public static String encodeHexString ( final byte [] data , final boolean toLowerCase ) {
int f = toDigit ( data [ j ] , j ) << 4 ; j ++ ; f = f | toDigit ( data [ j ] , j ) ; MST[rv.ABSMutator]MSP[] j ++ ; out [ i ] = (byte) ( f & 0xFF ) ; }
out [ j ++ ] = toDigits [ 0x0F & data [ i ] ] ; MST[rv.UOI4Mutator]MSP[] } } public static char [] encodeHex ( final ByteBuffer data ) { return encodeHex ( data , true ) ; }
return encodeHex ( byteArray ) ; MST[NullReturnValsMutator]MSP[] } public Charset getCharset () { return this . charset ; } public String getCharsetName () { return this . charset . name () ; } @Override public String toString () {
return byteArray ; } protected static int toDigit ( final char ch , final int index ) throws DecoderException { final int digit = Character . digit ( ch , 16 ) ; MST[rv.ABSMutator]MSP[] if ( digit == - 1 ) {
return decode ( ( ByteBuffer ) object ) ; MST[ReturnValsMutator]MSP[] } else { try { return decodeHex ( ( char [] ) object ) ; } catch ( final ClassCastException e ) { throw new DecoderException ( e . getMessage () , e ) ; } } } @Override
for ( int i = dataOffset , j = outOffset ; i < dataOffset + dataLen ; i ++ ) { out [ j ++ ] = toDigits [ ( 0xF0 & data [ i ] ) >>> 4 ] ; MST[rv.UOI1Mutator]MSP[]
final byte [] byteArray = byteBuffer . array () ; if ( remaining == byteArray . length ) { byteBuffer . position ( remaining ) ; return byteArray ; } } final byte [] byteArray = new byte [ remaining ] ; MST[rv.ABSMutator]MSP[] byteBuffer . get ( byteArray ) ;
if ( object instanceof String ) { return decode ( ( ( String ) object ) . toCharArray () ) ; } else if ( object instanceof byte [] ) { MST[rv.ROR5Mutator]MSP[] return decode ( ( byte [] ) object ) ; } else if ( object instanceof ByteBuffer ) {
return byteArray ; MST[NullReturnValsMutator]MSP[] } protected static int toDigit ( final char ch , final int index ) throws DecoderException { final int digit = Character . digit ( ch , 16 ) ; if ( digit == - 1 ) {
int f = toDigit ( data [ j ] , j ) << 4 ; MST[rv.ABSMutator]MSP[] j ++ ; f = f | toDigit ( data [ j ] , j ) ; j ++ ; out [ i ] = (byte) ( f & 0xFF ) ; }
final int outLen = len >> 1 ; if ( out . length - outOffset < outLen ) { MST[rv.AOR4Mutator]MSP[] throw new DecoderException ( lr_2 ) ; } for ( int i = outOffset , j = 0 ; j < len ; i ++ ) {
for ( int i = dataOffset , j = outOffset ; i < dataOffset + dataLen ; i ++ ) { MST[rv.UOI2Mutator]MSP[] out [ j ++ ] = toDigits [ ( 0xF0 & data [ i ] ) >>> 4 ] ;
final byte [] byteArray = byteBuffer . array () ; if ( remaining == byteArray . length ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] byteBuffer . position ( remaining ) ; return byteArray ; } } final byte [] byteArray = new byte [ remaining ] ; byteBuffer . get ( byteArray ) ;
return decode ( ( ByteBuffer ) object ) ; } else { try { return decodeHex ( ( char [] ) object ) ; MST[ReturnValsMutator]MSP[] } catch ( final ClassCastException e ) { throw new DecoderException ( e . getMessage () , e ) ; } } } @Override
public static byte [] decodeHex ( final char [] data ) throws DecoderException { final byte [] out = new byte [ data . length >> 1 ] ; decodeHex ( data , out , 0 ) ; MST[rv.CRCR6Mutator]MSP[] return out ; }
} @Override public Object encode ( final Object object ) throws EncoderException { byte [] byteArray ; if ( object instanceof String ) { byteArray = ( ( String ) object ) . getBytes ( this . getCharset () ) ; } else if ( object instanceof ByteBuffer ) { MST[rv.ROR5Mutator]MSP[]
} @Override public Object encode ( final Object object ) throws EncoderException { byte [] byteArray ; if ( object instanceof String ) { byteArray = ( ( String ) object ) . getBytes ( this . getCharset () ) ; } else if ( object instanceof ByteBuffer ) { MST[rv.ROR3Mutator]MSP[]
return outLen ; } public static byte [] decodeHex ( final String data ) throws DecoderException { return decodeHex ( data . toCharArray () ) ; MST[NonVoidMethodCallMutator]MSP[] } public static char [] encodeHex ( final byte [] data ) { return encodeHex ( data , true ) ; }
public static char [] encodeHex ( final byte [] data , final boolean toLowerCase ) { return encodeHex ( data , toLowerCase ? DIGITS_LOWER : DIGITS_UPPER ) ; MST[rv.ROR3Mutator]MSP[] } protected static char [] encodeHex ( final byte [] data , final char [] toDigits ) {
encodeHex ( data , dataOffset , dataLen , toLowerCase ? DIGITS_LOWER : DIGITS_UPPER , out , 0 ) ; MST[InlineConstantMutator]MSP[] return out ; } public static void encodeHex ( final byte [] data , final int dataOffset , final int dataLen ,
public static char [] encodeHex ( final ByteBuffer data , final boolean toLowerCase ) { return encodeHex ( data , toLowerCase ? DIGITS_LOWER : DIGITS_UPPER ) ; MST[rv.ROR2Mutator]MSP[] } protected static char [] encodeHex ( final ByteBuffer byteBuffer , final char [] toDigits ) {
encodeHex ( data , dataOffset , dataLen , toLowerCase ? DIGITS_LOWER : DIGITS_UPPER , out , 0 ) ; MST[rv.UOI4Mutator]MSP[] return out ; } public static void encodeHex ( final byte [] data , final int dataOffset , final int dataLen ,
final byte [] byteArray = byteBuffer . array () ; if ( remaining == byteArray . length ) { MST[rv.UOI1Mutator]MSP[] byteBuffer . position ( remaining ) ; return byteArray ; } } final byte [] byteArray = new byte [ remaining ] ; byteBuffer . get ( byteArray ) ;
public static int decodeHex ( final char [] data , final byte [] out , final int outOffset ) throws DecoderException { final int len = data . length ; if ( ( len & 0x01 ) != 0 ) { MST[rv.CRCR4Mutator]MSP[] throw new DecoderException ( lr_1 ) ; }
final int outLen = len >> 1 ; if ( out . length - outOffset < outLen ) { throw new DecoderException ( lr_2 ) ; } for ( int i = outOffset , j = 0 ; j < len ; i ++ ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[]
return new String ( encodeHex ( data , toLowerCase ) ) ; MST[rv.UOI3Mutator]MSP[] } public static String encodeHexString ( final ByteBuffer data ) { return new String ( encodeHex ( data ) ) ; } public static String encodeHexString ( final ByteBuffer data , final boolean toLowerCase ) {
final byte [] byteArray = byteBuffer . array () ; if ( remaining == byteArray . length ) { MST[rv.UOI3Mutator]MSP[] byteBuffer . position ( remaining ) ; return byteArray ; } } final byte [] byteArray = new byte [ remaining ] ; byteBuffer . get ( byteArray ) ;
return encodeHex ( toByteArray ( byteBuffer ) , toDigits ) ; MST[ReturnValsMutator]MSP[] } public static String encodeHexString ( final byte [] data ) { return new String ( encodeHex ( data ) ) ; } public static String encodeHexString ( final byte [] data , final boolean toLowerCase ) {
public static byte [] decodeHex ( final char [] data ) throws DecoderException { final byte [] out = new byte [ data . length >> 1 ] ; MST[rv.CRCR4Mutator]MSP[] decodeHex ( data , out , 0 ) ; return out ; }
encodeHex ( data , dataOffset , dataLen , toLowerCase ? DIGITS_LOWER : DIGITS_UPPER , out , 0 ) ; MST[rv.ABSMutator]MSP[] return out ; } public static void encodeHex ( final byte [] data , final int dataOffset , final int dataLen ,
} @Override public Object encode ( final Object object ) throws EncoderException { byte [] byteArray ; if ( object instanceof String ) { byteArray = ( ( String ) object ) . getBytes ( this . getCharset () ) ; } else if ( object instanceof ByteBuffer ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
final byte [] byteArray = byteBuffer . array () ; if ( remaining == byteArray . length ) { MST[NegateConditionalsMutator]MSP[] byteBuffer . position ( remaining ) ; return byteArray ; } } final byte [] byteArray = new byte [ remaining ] ; byteBuffer . get ( byteArray ) ;
return new String ( encodeHex ( data , toLowerCase ) ) ; MST[NonVoidMethodCallMutator]MSP[] } private static byte [] toByteArray ( final ByteBuffer byteBuffer ) { final int remaining = byteBuffer . remaining () ; if ( byteBuffer . hasArray () ) {
int f = toDigit ( data [ j ] , j ) << 4 ; j ++ ; f = f | toDigit ( data [ j ] , j ) ; j ++ ; out [ i ] = (byte) ( f & 0xFF ) ; MST[rv.CRCR3Mutator]MSP[] }
encodeHex ( data , dataOffset , dataLen , toLowerCase ? DIGITS_LOWER : DIGITS_UPPER , out , 0 ) ; MST[rv.ROR1Mutator]MSP[] return out ; } public static void encodeHex ( final byte [] data , final int dataOffset , final int dataLen ,
for ( int i = dataOffset , j = outOffset ; i < dataOffset + dataLen ; i ++ ) { MST[rv.AOR1Mutator]MSP[] out [ j ++ ] = toDigits [ ( 0xF0 & data [ i ] ) >>> 4 ] ;
} @Override public Object encode ( final Object object ) throws EncoderException { byte [] byteArray ; if ( object instanceof String ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] byteArray = ( ( String ) object ) . getBytes ( this . getCharset () ) ; } else if ( object instanceof ByteBuffer ) {
return encodeHex ( byteArray ) ; MST[ReturnValsMutator]MSP[] } public Charset getCharset () { return this . charset ; } public String getCharsetName () { return this . charset . name () ; } @Override public String toString () {
throw new DecoderException ( lr_3 + ch + lr_4 + index ) ; MST[ConstructorCallMutator]MSP[] } return digit ; } @Override public byte [] decode ( final byte [] array ) throws DecoderException { return decodeHex ( new String ( array , getCharset () ) . toCharArray () ) ; }
if ( object instanceof String ) { MST[rv.ROR1Mutator]MSP[] return decode ( ( ( String ) object ) . toCharArray () ) ; } else if ( object instanceof byte [] ) { return decode ( ( byte [] ) object ) ; } else if ( object instanceof ByteBuffer ) {
final int outLen = len >> 1 ; if ( out . length - outOffset < outLen ) { throw new DecoderException ( lr_2 ) ; } for ( int i = outOffset , j = 0 ; j < len ; i ++ ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[]
out [ j ++ ] = toDigits [ 0x0F & data [ i ] ] ; } } public static char [] encodeHex ( final ByteBuffer data ) { return encodeHex ( data , true ) ; MST[NullReturnValsMutator]MSP[] }
final int outLen = len >> 1 ; if ( out . length - outOffset < outLen ) { MST[rv.AOD2Mutator]MSP[] throw new DecoderException ( lr_2 ) ; } for ( int i = outOffset , j = 0 ; j < len ; i ++ ) {
public static char [] encodeHex ( final byte [] data , final int dataOffset , final int dataLen , final boolean toLowerCase ) { final char [] out = new char [ dataLen << 1 ] ; MST[rv.CRCR2Mutator]MSP[]
final boolean toLowerCase , final char [] out , final int outOffset ) { encodeHex ( data , dataOffset , dataLen , toLowerCase ? DIGITS_LOWER : DIGITS_UPPER , out , outOffset ) ; MST[rv.UOI4Mutator]MSP[] }
int f = toDigit ( data [ j ] , j ) << 4 ; MST[rv.UOI4Mutator]MSP[] j ++ ; f = f | toDigit ( data [ j ] , j ) ; j ++ ; out [ i ] = (byte) ( f & 0xFF ) ; }
return new String ( encodeHex ( data , toLowerCase ) ) ; MST[EmptyObjectReturnValsMutator]MSP[] } private static byte [] toByteArray ( final ByteBuffer byteBuffer ) { final int remaining = byteBuffer . remaining () ; if ( byteBuffer . hasArray () ) {
return byteArray ; } protected static int toDigit ( final char ch , final int index ) throws DecoderException { final int digit = Character . digit ( ch , 16 ) ; if ( digit == - 1 ) { MST[rv.UOI1Mutator]MSP[]
out [ j ++ ] = toDigits [ 0x0F & data [ i ] ] ; } } public static char [] encodeHex ( final ByteBuffer data ) { return encodeHex ( data , true ) ; MST[rv.CRCR4Mutator]MSP[] }
final int outLen = len >> 1 ; if ( out . length - outOffset < outLen ) { throw new DecoderException ( lr_2 ) ; } for ( int i = outOffset , j = 0 ; j < len ; i ++ ) { MST[rv.UOI2Mutator]MSP[]
public byte [] decode ( final ByteBuffer buffer ) throws DecoderException { return decodeHex ( new String ( toByteArray ( buffer ) , getCharset () ) . toCharArray () ) ; MST[NonVoidMethodCallMutator]MSP[] } @Override public Object decode ( final Object object ) throws DecoderException {
return decode ( ( ByteBuffer ) object ) ; } else { try { return decodeHex ( ( char [] ) object ) ; MST[NonVoidMethodCallMutator]MSP[] } catch ( final ClassCastException e ) { throw new DecoderException ( e . getMessage () , e ) ; } } } @Override
final int outLen = len >> 1 ; if ( out . length - outOffset < outLen ) { MST[rv.ROR3Mutator]MSP[] throw new DecoderException ( lr_2 ) ; } for ( int i = outOffset , j = 0 ; j < len ; i ++ ) {
final int outLen = len >> 1 ; MST[MathMutator]MSP[] if ( out . length - outOffset < outLen ) { throw new DecoderException ( lr_2 ) ; } for ( int i = outOffset , j = 0 ; j < len ; i ++ ) {
throw new DecoderException ( lr_3 + ch + lr_4 + index ) ; MST[rv.UOI1Mutator]MSP[] } return digit ; } @Override public byte [] decode ( final byte [] array ) throws DecoderException { return decodeHex ( new String ( array , getCharset () ) . toCharArray () ) ; }
return outLen ; } public static byte [] decodeHex ( final String data ) throws DecoderException { return decodeHex ( data . toCharArray () ) ; } public static char [] encodeHex ( final byte [] data ) { return encodeHex ( data , true ) ; MST[rv.CRCR2Mutator]MSP[] }
encodeHex ( data , dataOffset , dataLen , toLowerCase ? DIGITS_LOWER : DIGITS_UPPER , out , 0 ) ; MST[rv.UOI3Mutator]MSP[] return out ; } public static void encodeHex ( final byte [] data , final int dataOffset , final int dataLen ,
return new String ( encodeHex ( data , toLowerCase ) ) ; } private static byte [] toByteArray ( final ByteBuffer byteBuffer ) { final int remaining = byteBuffer . remaining () ; if ( byteBuffer . hasArray () ) { MST[rv.ROR2Mutator]MSP[]
public static char [] encodeHex ( final byte [] data , final boolean toLowerCase ) { return encodeHex ( data , toLowerCase ? DIGITS_LOWER : DIGITS_UPPER ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] } protected static char [] encodeHex ( final byte [] data , final char [] toDigits ) {
if ( object instanceof String ) { return decode ( ( ( String ) object ) . toCharArray () ) ; } else if ( object instanceof byte [] ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return decode ( ( byte [] ) object ) ; } else if ( object instanceof ByteBuffer ) {
} @Override public Object encode ( final Object object ) throws EncoderException { byte [] byteArray ; if ( object instanceof String ) { MST[rv.ROR5Mutator]MSP[] byteArray = ( ( String ) object ) . getBytes ( this . getCharset () ) ; } else if ( object instanceof ByteBuffer ) {
encodeHex ( data , dataOffset , dataLen , toLowerCase ? DIGITS_LOWER : DIGITS_UPPER , out , 0 ) ; return out ; MST[ReturnValsMutator]MSP[] } public static void encodeHex ( final byte [] data , final int dataOffset , final int dataLen ,
int f = toDigit ( data [ j ] , j ) << 4 ; j ++ ; f = f | toDigit ( data [ j ] , j ) ; j ++ ; MST[experimental.RemoveIncrementsMutator]MSP[] out [ i ] = (byte) ( f & 0xFF ) ; }
public byte [] encode ( final byte [] array ) { return encodeHexString ( array ) . getBytes ( this . getCharset () ) ; } public byte [] encode ( final ByteBuffer array ) { return encodeHexString ( array ) . getBytes ( this . getCharset () ) ; MST[NonVoidMethodCallMutator]MSP[]
final int outLen = len >> 1 ; MST[rv.UOI3Mutator]MSP[] if ( out . length - outOffset < outLen ) { throw new DecoderException ( lr_2 ) ; } for ( int i = outOffset , j = 0 ; j < len ; i ++ ) {
encodeHex ( data , dataOffset , dataLen , toLowerCase ? DIGITS_LOWER : DIGITS_UPPER , out , 0 ) ; MST[rv.ABSMutator]MSP[] return out ; } public static void encodeHex ( final byte [] data , final int dataOffset , final int dataLen ,
final byte [] byteArray = byteBuffer . array () ; if ( remaining == byteArray . length ) { byteBuffer . position ( remaining ) ; return byteArray ; } } final byte [] byteArray = new byte [ remaining ] ; MST[rv.UOI3Mutator]MSP[] byteBuffer . get ( byteArray ) ;
throw new DecoderException ( lr_3 + ch + lr_4 + index ) ; MST[experimental.NakedReceiverMutator]MSP[] } return digit ; } @Override public byte [] decode ( final byte [] array ) throws DecoderException { return decodeHex ( new String ( array , getCharset () ) . toCharArray () ) ; }
int f = toDigit ( data [ j ] , j ) << 4 ; j ++ ; f = f | toDigit ( data [ j ] , j ) ; MST[rv.UOI3Mutator]MSP[] j ++ ; out [ i ] = (byte) ( f & 0xFF ) ; }
final int outLen = len >> 1 ; if ( out . length - outOffset < outLen ) { throw new DecoderException ( lr_2 ) ; } for ( int i = outOffset , j = 0 ; j < len ; i ++ ) { MST[rv.CRCR6Mutator]MSP[]
for ( int i = dataOffset , j = outOffset ; i < dataOffset + dataLen ; i ++ ) { MST[rv.UOI1Mutator]MSP[] out [ j ++ ] = toDigits [ ( 0xF0 & data [ i ] ) >>> 4 ] ;
int f = toDigit ( data [ j ] , j ) << 4 ; j ++ ; f = f | toDigit ( data [ j ] , j ) ; j ++ ; out [ i ] = (byte) ( f & 0xFF ) ; MST[rv.OBBN3Mutator]MSP[] }
final boolean toLowerCase , final char [] out , final int outOffset ) { encodeHex ( data , dataOffset , dataLen , toLowerCase ? DIGITS_LOWER : DIGITS_UPPER , out , outOffset ) ; MST[rv.UOI3Mutator]MSP[] }
final boolean toLowerCase , final char [] out , final int outOffset ) { encodeHex ( data , dataOffset , dataLen , toLowerCase ? DIGITS_LOWER : DIGITS_UPPER , out , outOffset ) ; MST[rv.UOI4Mutator]MSP[] }
return byteArray ; } protected static int toDigit ( final char ch , final int index ) throws DecoderException { final int digit = Character . digit ( ch , 16 ) ; if ( digit == - 1 ) { MST[NegateConditionalsMutator]MSP[]
final int outLen = len >> 1 ; if ( out . length - outOffset < outLen ) { throw new DecoderException ( lr_2 ) ; } for ( int i = outOffset , j = 0 ; j < len ; i ++ ) { MST[rv.UOI1Mutator]MSP[]
final int outLen = len >> 1 ; if ( out . length - outOffset < outLen ) { throw new DecoderException ( lr_2 ) ; } for ( int i = outOffset , j = 0 ; j < len ; i ++ ) { MST[rv.CRCR1Mutator]MSP[]
final boolean toLowerCase , final char [] out , final int outOffset ) { encodeHex ( data , dataOffset , dataLen , toLowerCase ? DIGITS_LOWER : DIGITS_UPPER , out , outOffset ) ; MST[VoidMethodCallMutator]MSP[] }
final int outLen = len >> 1 ; if ( out . length - outOffset < outLen ) { throw new DecoderException ( lr_2 ) ; } for ( int i = outOffset , j = 0 ; j < len ; i ++ ) { MST[rv.UOI4Mutator]MSP[]
out [ j ++ ] = toDigits [ 0x0F & data [ i ] ] ; } } public static char [] encodeHex ( final ByteBuffer data ) { return encodeHex ( data , true ) ; MST[ReturnValsMutator]MSP[] }
encodeHex ( data , dataOffset , dataLen , toLowerCase ? DIGITS_LOWER : DIGITS_UPPER , out , 0 ) ; MST[rv.CRCR3Mutator]MSP[] return out ; } public static void encodeHex ( final byte [] data , final int dataOffset , final int dataLen ,
} @Override public Object encode ( final Object object ) throws EncoderException { byte [] byteArray ; if ( object instanceof String ) { MST[NegateConditionalsMutator]MSP[] byteArray = ( ( String ) object ) . getBytes ( this . getCharset () ) ; } else if ( object instanceof ByteBuffer ) {
encodeHex ( data , dataOffset , dataLen , toLowerCase ? DIGITS_LOWER : DIGITS_UPPER , out , 0 ) ; MST[rv.UOI4Mutator]MSP[] return out ; } public static void encodeHex ( final byte [] data , final int dataOffset , final int dataLen ,
throw new DecoderException ( lr_3 + ch + lr_4 + index ) ; } return digit ; } @Override public byte [] decode ( final byte [] array ) throws DecoderException { return decodeHex ( new String ( array , getCharset () ) . toCharArray () ) ; MST[ReturnValsMutator]MSP[] }
return new String ( encodeHex ( data , toLowerCase ) ) ; MST[rv.ABSMutator]MSP[] } public static String encodeHexString ( final ByteBuffer data ) { return new String ( encodeHex ( data ) ) ; } public static String encodeHexString ( final ByteBuffer data , final boolean toLowerCase ) {
public byte [] encode ( final byte [] array ) { return encodeHexString ( array ) . getBytes ( this . getCharset () ) ; } public byte [] encode ( final ByteBuffer array ) { return encodeHexString ( array ) . getBytes ( this . getCharset () ) ; MST[NonVoidMethodCallMutator]MSP[]
public static char [] encodeHex ( final byte [] data , final int dataOffset , final int dataLen , final boolean toLowerCase ) { final char [] out = new char [ dataLen << 1 ] ; MST[InlineConstantMutator]MSP[]
return new String ( encodeHex ( data , toLowerCase ) ) ; } public static String encodeHexString ( final ByteBuffer data ) { return new String ( encodeHex ( data ) ) ; MST[ConstructorCallMutator]MSP[] } public static String encodeHexString ( final ByteBuffer data , final boolean toLowerCase ) {
return byteArray ; } protected static int toDigit ( final char ch , final int index ) throws DecoderException { final int digit = Character . digit ( ch , 16 ) ; MST[rv.CRCR6Mutator]MSP[] if ( digit == - 1 ) {
return outLen ; } public static byte [] decodeHex ( final String data ) throws DecoderException { return decodeHex ( data . toCharArray () ) ; } public static char [] encodeHex ( final byte [] data ) { return encodeHex ( data , true ) ; MST[rv.CRCR3Mutator]MSP[] }
return new String ( encodeHex ( data , toLowerCase ) ) ; } private static byte [] toByteArray ( final ByteBuffer byteBuffer ) { final int remaining = byteBuffer . remaining () ; MST[NonVoidMethodCallMutator]MSP[] if ( byteBuffer . hasArray () ) {
final int outLen = len >> 1 ; if ( out . length - outOffset < outLen ) { throw new DecoderException ( lr_2 ) ; } for ( int i = outOffset , j = 0 ; j < len ; i ++ ) { MST[IncrementsMutator]MSP[]
return super . toString () + lr_5 + this . charset + lr_6 ; MST[experimental.NakedReceiverMutator]MSP[] }
final byte [] byteArray = byteBuffer . array () ; if ( remaining == byteArray . length ) { byteBuffer . position ( remaining ) ; return byteArray ; } } final byte [] byteArray = new byte [ remaining ] ; MST[rv.UOI2Mutator]MSP[] byteBuffer . get ( byteArray ) ;
public static int decodeHex ( final char [] data , final byte [] out , final int outOffset ) throws DecoderException { final int len = data . length ; if ( ( len & 0x01 ) != 0 ) { MST[rv.ROR1Mutator]MSP[] throw new DecoderException ( lr_1 ) ; }
for ( int i = dataOffset , j = outOffset ; i < dataOffset + dataLen ; i ++ ) { MST[rv.ROR4Mutator]MSP[] out [ j ++ ] = toDigits [ ( 0xF0 & data [ i ] ) >>> 4 ] ;
return encodeHex ( toByteArray ( byteBuffer ) , toDigits ) ; } public static String encodeHexString ( final byte [] data ) { return new String ( encodeHex ( data ) ) ; MST[ReturnValsMutator]MSP[] } public static String encodeHexString ( final byte [] data , final boolean toLowerCase ) {
if ( object instanceof String ) { return decode ( ( ( String ) object ) . toCharArray () ) ; MST[NonVoidMethodCallMutator]MSP[] } else if ( object instanceof byte [] ) { return decode ( ( byte [] ) object ) ; } else if ( object instanceof ByteBuffer ) {
encodeHex ( data , dataOffset , dataLen , toLowerCase ? DIGITS_LOWER : DIGITS_UPPER , out , 0 ) ; MST[VoidMethodCallMutator]MSP[] return out ; } public static void encodeHex ( final byte [] data , final int dataOffset , final int dataLen ,
public static char [] encodeHex ( final byte [] data , final int dataOffset , final int dataLen , final boolean toLowerCase ) { final char [] out = new char [ dataLen << 1 ] ; MST[MathMutator]MSP[]
for ( int i = dataOffset , j = outOffset ; i < dataOffset + dataLen ; i ++ ) { MST[NegateConditionalsMutator]MSP[] out [ j ++ ] = toDigits [ ( 0xF0 & data [ i ] ) >>> 4 ] ;
if ( object instanceof String ) { MST[rv.ROR2Mutator]MSP[] return decode ( ( ( String ) object ) . toCharArray () ) ; } else if ( object instanceof byte [] ) { return decode ( ( byte [] ) object ) ; } else if ( object instanceof ByteBuffer ) {
return outLen ; } public static byte [] decodeHex ( final String data ) throws DecoderException { return decodeHex ( data . toCharArray () ) ; } public static char [] encodeHex ( final byte [] data ) { return encodeHex ( data , true ) ; MST[InlineConstantMutator]MSP[] }
return new String ( encodeHex ( data , toLowerCase ) ) ; MST[rv.UOI2Mutator]MSP[] } private static byte [] toByteArray ( final ByteBuffer byteBuffer ) { final int remaining = byteBuffer . remaining () ; if ( byteBuffer . hasArray () ) {
return byteArray ; } protected static int toDigit ( final char ch , final int index ) throws DecoderException { final int digit = Character . digit ( ch , 16 ) ; if ( digit == - 1 ) { MST[InlineConstantMutator]MSP[]
int f = toDigit ( data [ j ] , j ) << 4 ; MST[rv.UOI4Mutator]MSP[] j ++ ; f = f | toDigit ( data [ j ] , j ) ; j ++ ; out [ i ] = (byte) ( f & 0xFF ) ; }
final boolean toLowerCase , final char [] out , final int outOffset ) { encodeHex ( data , dataOffset , dataLen , toLowerCase ? DIGITS_LOWER : DIGITS_UPPER , out , outOffset ) ; MST[rv.UOI3Mutator]MSP[] }
int f = toDigit ( data [ j ] , j ) << 4 ; MST[rv.UOI3Mutator]MSP[] j ++ ; f = f | toDigit ( data [ j ] , j ) ; j ++ ; out [ i ] = (byte) ( f & 0xFF ) ; }
final boolean toLowerCase , final char [] out , final int outOffset ) { encodeHex ( data , dataOffset , dataLen , toLowerCase ? DIGITS_LOWER : DIGITS_UPPER , out , outOffset ) ; MST[rv.ABSMutator]MSP[] }
} @Override public Object encode ( final Object object ) throws EncoderException { byte [] byteArray ; if ( object instanceof String ) { byteArray = ( ( String ) object ) . getBytes ( this . getCharset () ) ; } else if ( object instanceof ByteBuffer ) { MST[NegateConditionalsMutator]MSP[]
final int outLen = len >> 1 ; if ( out . length - outOffset < outLen ) { throw new DecoderException ( lr_2 ) ; } for ( int i = outOffset , j = 0 ; j < len ; i ++ ) { MST[rv.UOI1Mutator]MSP[]
return outLen ; } public static byte [] decodeHex ( final String data ) throws DecoderException { return decodeHex ( data . toCharArray () ) ; MST[NonVoidMethodCallMutator]MSP[] } public static char [] encodeHex ( final byte [] data ) { return encodeHex ( data , true ) ; }
public static char [] encodeHex ( final ByteBuffer data , final boolean toLowerCase ) { return encodeHex ( data , toLowerCase ? DIGITS_LOWER : DIGITS_UPPER ) ; MST[rv.UOI4Mutator]MSP[] } protected static char [] encodeHex ( final ByteBuffer byteBuffer , final char [] toDigits ) {
throw new DecoderException ( lr_3 + ch + lr_4 + index ) ; } return digit ; } @Override public byte [] decode ( final byte [] array ) throws DecoderException { return decodeHex ( new String ( array , getCharset () ) . toCharArray () ) ; MST[NullReturnValsMutator]MSP[] }
final boolean toLowerCase , final char [] out , final int outOffset ) { encodeHex ( data , dataOffset , dataLen , toLowerCase ? DIGITS_LOWER : DIGITS_UPPER , out , outOffset ) ; MST[rv.UOI2Mutator]MSP[] }
encodeHex ( data , dataOffset , dataLen , toLowerCase ? DIGITS_LOWER : DIGITS_UPPER , out , 0 ) ; MST[rv.UOI4Mutator]MSP[] return out ; } public static void encodeHex ( final byte [] data , final int dataOffset , final int dataLen ,
return byteArray ; } protected static int toDigit ( final char ch , final int index ) throws DecoderException { final int digit = Character . digit ( ch , 16 ) ; MST[rv.CRCR1Mutator]MSP[] if ( digit == - 1 ) {
public byte [] encode ( final byte [] array ) { return encodeHexString ( array ) . getBytes ( this . getCharset () ) ; } public byte [] encode ( final ByteBuffer array ) { return encodeHexString ( array ) . getBytes ( this . getCharset () ) ; MST[NonVoidMethodCallMutator]MSP[]
public static char [] encodeHex ( final byte [] data , final int dataOffset , final int dataLen , final boolean toLowerCase ) { final char [] out = new char [ dataLen << 1 ] ; MST[rv.UOI1Mutator]MSP[]
final byte [] byteArray = byteBuffer . array () ; if ( remaining == byteArray . length ) { MST[rv.ROR5Mutator]MSP[] byteBuffer . position ( remaining ) ; return byteArray ; } } final byte [] byteArray = new byte [ remaining ] ; byteBuffer . get ( byteArray ) ;
final byte [] byteArray = byteBuffer . array () ; if ( remaining == byteArray . length ) { MST[rv.UOI2Mutator]MSP[] byteBuffer . position ( remaining ) ; return byteArray ; } } final byte [] byteArray = new byte [ remaining ] ; byteBuffer . get ( byteArray ) ;
encodeHex ( data , dataOffset , dataLen , toLowerCase ? DIGITS_LOWER : DIGITS_UPPER , out , 0 ) ; MST[rv.ABSMutator]MSP[] return out ; } public static void encodeHex ( final byte [] data , final int dataOffset , final int dataLen ,
int f = toDigit ( data [ j ] , j ) << 4 ; j ++ ; f = f | toDigit ( data [ j ] , j ) ; j ++ ; out [ i ] = (byte) ( f & 0xFF ) ; MST[rv.UOI1Mutator]MSP[] }
return encodeHex ( byteArray ) ; } public Charset getCharset () { return this . charset ; } public String getCharsetName () { return this . charset . name () ; MST[ReturnValsMutator]MSP[] } @Override public String toString () {
public static int decodeHex ( final char [] data , final byte [] out , final int outOffset ) throws DecoderException { final int len = data . length ; if ( ( len & 0x01 ) != 0 ) { MST[rv.UOI3Mutator]MSP[] throw new DecoderException ( lr_1 ) ; }
throw new DecoderException ( lr_3 + ch + lr_4 + index ) ; MST[experimental.NakedReceiverMutator]MSP[] } return digit ; } @Override public byte [] decode ( final byte [] array ) throws DecoderException { return decodeHex ( new String ( array , getCharset () ) . toCharArray () ) ; }
if ( object instanceof String ) { return decode ( ( ( String ) object ) . toCharArray () ) ; } else if ( object instanceof byte [] ) { MST[rv.ROR1Mutator]MSP[] return decode ( ( byte [] ) object ) ; } else if ( object instanceof ByteBuffer ) {
if ( object instanceof String ) { return decode ( ( ( String ) object ) . toCharArray () ) ; } else if ( object instanceof byte [] ) { return decode ( ( byte [] ) object ) ; } else if ( object instanceof ByteBuffer ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
