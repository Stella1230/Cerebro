private PhonemeBuilder applyFinalRules ( final PhonemeBuilder phonemeBuilder , final Map < String , List < Rule > > finalRules ) { Objects . requireNonNull ( finalRules , lr_3 ) ; if ( finalRules . isEmpty () ) { MST[rv.ROR4Mutator]MSP[N] return phonemeBuilder ; }
final Map < String , List < Rule > > finalRules2 = Rule . getInstanceMap ( this . nameType , this . ruleType , languageSet ) ; input = input . toLowerCase ( Locale . ENGLISH ) . replace ( '-' , ' ' ) . trim () ; MST[rv.CRCR4Mutator]MSP[N]
final String lastPart = parts [ parts . length - 1 ] ; MST[rv.CRCR2Mutator]MSP[S] words2 . add ( lastPart ) ; } words2 . removeAll ( NAME_PREFIXES . get ( this . nameType ) ) ; break; case ASHKENAZI : words2 . addAll ( words ) ;
input = join ( words2 , lr_10 ) ; MST[NonVoidMethodCallMutator]MSP[N] } else if ( words2 . size () == 1 ) { input = words . iterator () . next () ; } else { final StringBuilder result = new StringBuilder () ;
for ( int i = 0 ; i < input . length () ; ) { final RulesApplication rulesApplication = MST[rv.UOI3Mutator]MSP[S] new RulesApplication ( rules , input , phonemeBuilder , i , maxPhonemes ) . invoke () ; i = rulesApplication . getI () ;
if ( this . nameType == NameType . GENERIC ) { if ( input . length () >= 2 && input . substring ( 0 , 2 ) . equals ( lr_5 ) ) { MST[NegateConditionalsMutator]MSP[N] final String remainder = input . substring ( 2 ) ;
return this . nameType ; } public RuleType getRuleType () { return this . ruleType ; } public boolean isConcat () { return this . concat ; MST[BooleanFalseReturnValsMutator]MSP[S] } public int getMaxPhonemes () { return this . maxPhonemes ; }
words2 . removeAll ( NAME_PREFIXES . get ( this . nameType ) ) ; break; case GENERIC : words2 . addAll ( words ) ; break; default: throw new IllegalStateException ( lr_13 + this . nameType ) ; } if ( this . concat ) { MST[rv.ROR2Mutator]MSP[N]
new RulesApplication ( finalRules , phonemeText , subBuilder , i , maxPhonemes ) . invoke () ; final boolean found = rulesApplication . isFound () ; subBuilder = rulesApplication . getPhonemeBuilder () ; if ( ! found ) { MST[rv.UOI2Mutator]MSP[N]
final String lastPart = parts [ parts . length - 1 ] ; MST[rv.AOD1Mutator]MSP[S] words2 . add ( lastPart ) ; } words2 . removeAll ( NAME_PREFIXES . get ( this . nameType ) ) ; break; case ASHKENAZI : words2 . addAll ( words ) ;
if ( si . hasNext () ) { sb . append ( si . next () ) ; MST[NonVoidMethodCallMutator]MSP[N] } while ( si . hasNext () ) { sb . append ( sep ) . append ( si . next () ) ; } return sb . toString () ; }
for ( int i = 0 ; i < input . length () ; ) { MST[rv.CRCR3Mutator]MSP[N] final RulesApplication rulesApplication = new RulesApplication ( rules , input , phonemeBuilder , i , maxPhonemes ) . invoke () ; i = rulesApplication . getI () ;
return lr_7 + encode ( remainder ) + lr_8 + encode ( combined ) + lr_9 ; MST[NonVoidMethodCallMutator]MSP[S] } } } final List < String > words = Arrays . asList ( input . split ( lr_11 ) ) ;
phonemeBuilder = rulesApplication . getPhonemeBuilder () ; MST[NonVoidMethodCallMutator]MSP[N] } phonemeBuilder = applyFinalRules ( phonemeBuilder , finalRules1 ) ; phonemeBuilder = applyFinalRules ( phonemeBuilder , finalRules2 ) ; return phonemeBuilder . makeString () ; } public Lang getLang () { return this . lang ; } public NameType getNameType () {
final String combined = lr_6 + remainder ; return lr_7 + encode ( remainder ) + lr_8 + encode ( combined ) + lr_9 ; MST[NonVoidMethodCallMutator]MSP[S] } for ( final String l : NAME_PREFIXES . get ( this . nameType ) ) {
PhonemeBuilder subBuilder = PhonemeBuilder . empty ( phoneme . getLanguages () ) ; final String phonemeText = phoneme . getPhonemeText () . toString () ; for ( int i = 0 ; i < phonemeText . length () ; ) { MST[ConditionalsBoundaryMutator]MSP[N] final RulesApplication rulesApplication =
final String combined = lr_6 + remainder ; return lr_7 + encode ( remainder ) + lr_8 + encode ( combined ) + lr_9 ; MST[EmptyObjectReturnValsMutator]MSP[S] } for ( final String l : NAME_PREFIXES . get ( this . nameType ) ) {
PhonemeBuilder subBuilder = PhonemeBuilder . empty ( phoneme . getLanguages () ) ; final String phonemeText = phoneme . getPhonemeText () . toString () ; for ( int i = 0 ; i < phonemeText . length () ; ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] final RulesApplication rulesApplication =
new RulesApplication ( finalRules , phonemeText , subBuilder , i , maxPhonemes ) . invoke () ; final boolean found = rulesApplication . isFound () ; subBuilder = rulesApplication . getPhonemeBuilder () ; if ( ! found ) { MST[rv.ABSMutator]MSP[N]
PhonemeBuilder subBuilder = PhonemeBuilder . empty ( phoneme . getLanguages () ) ; final String phonemeText = phoneme . getPhonemeText () . toString () ; for ( int i = 0 ; i < phonemeText . length () ; ) { final RulesApplication rulesApplication = MST[rv.UOI1Mutator]MSP[N]
return lr_7 + encode ( remainder ) + lr_8 + encode ( combined ) + lr_9 ; MST[experimental.NakedReceiverMutator]MSP[S] } } } final List < String > words = Arrays . asList ( input . split ( lr_11 ) ) ;
final String combined = lr_6 + remainder ; return lr_7 + encode ( remainder ) + lr_8 + encode ( combined ) + lr_9 ; MST[experimental.NakedReceiverMutator]MSP[S] } for ( final String l : NAME_PREFIXES . get ( this . nameType ) ) {
if ( input . startsWith ( l + lr_10 ) ) { MST[NonVoidMethodCallMutator]MSP[N] final String remainder = input . substring ( l . length () + 1 ) ; final String combined = l + remainder ;
subBuilder . append ( phonemeText . subSequence ( i , i + 1 ) ) ; MST[rv.CRCR4Mutator]MSP[N] } i = rulesApplication . getI () ; } for ( final Rule . Phoneme newPhoneme : subBuilder . getPhonemes () ) { if ( phonemes . containsKey ( newPhoneme ) ) {
return this . nameType ; } public RuleType getRuleType () { return this . ruleType ; } public boolean isConcat () { return this . concat ; } public int getMaxPhonemes () { return this . maxPhonemes ; MST[PrimitiveReturnsMutator]MSP[S] }
final List < String > words2 = new ArrayList <> () ; switch ( this . nameType ) { MST[experimental.SwitchMutator]MSP[N] case SEPHARDIC : for ( final String aWord : words ) { final String [] parts = aWord . split ( lr_12 ) ;
return this . nameType ; } public RuleType getRuleType () { return this . ruleType ; } public boolean isConcat () { return this . concat ; } public int getMaxPhonemes () { return this . maxPhonemes ; MST[rv.ABSMutator]MSP[N] }
PhonemeBuilder subBuilder = PhonemeBuilder . empty ( phoneme . getLanguages () ) ; final String phonemeText = phoneme . getPhonemeText () . toString () ; for ( int i = 0 ; i < phonemeText . length () ; ) { final RulesApplication rulesApplication = MST[rv.ABSMutator]MSP[N]
subBuilder . append ( phonemeText . subSequence ( i , i + 1 ) ) ; } i = rulesApplication . getI () ; } for ( final Rule . Phoneme newPhoneme : subBuilder . getPhonemes () ) { if ( phonemes . containsKey ( newPhoneme ) ) { MST[rv.ROR1Mutator]MSP[N]
final Map < String , List < Rule > > finalRules2 = Rule . getInstanceMap ( this . nameType , this . ruleType , languageSet ) ; input = input . toLowerCase ( Locale . ENGLISH ) . replace ( '-' , ' ' ) . trim () ; MST[rv.CRCR4Mutator]MSP[N]
subBuilder . append ( phonemeText . subSequence ( i , i + 1 ) ) ; MST[rv.AOR1Mutator]MSP[N] } i = rulesApplication . getI () ; } for ( final Rule . Phoneme newPhoneme : subBuilder . getPhonemes () ) { if ( phonemes . containsKey ( newPhoneme ) ) {
if ( this . nameType == NameType . GENERIC ) { if ( input . length () >= 2 && input . substring ( 0 , 2 ) . equals ( lr_5 ) ) { MST[rv.ROR1Mutator]MSP[N] final String remainder = input . substring ( 2 ) ;
if ( this . nameType == NameType . GENERIC ) { if ( input . length () >= 2 && input . substring ( 0 , 2 ) . equals ( lr_5 ) ) { MST[rv.ROR5Mutator]MSP[S] final String remainder = input . substring ( 2 ) ;
} } } return new PhonemeBuilder ( phonemes . keySet () ) ; MST[NullReturnValsMutator]MSP[N] } public String encode ( final String input ) { final Languages . LanguageSet languageSet = this . lang . guessLanguages ( input ) ; return encode ( input , languageSet ) ; }
if ( this . nameType == NameType . GENERIC ) { if ( input . length () >= 2 && input . substring ( 0 , 2 ) . equals ( lr_5 ) ) { MST[rv.CRCR5Mutator]MSP[N] final String remainder = input . substring ( 2 ) ;
final String combined = lr_6 + remainder ; return lr_7 + encode ( remainder ) + lr_8 + encode ( combined ) + lr_9 ; MST[NonVoidMethodCallMutator]MSP[S] } for ( final String l : NAME_PREFIXES . get ( this . nameType ) ) {
words2 . removeAll ( NAME_PREFIXES . get ( this . nameType ) ) ; break; case GENERIC : words2 . addAll ( words ) ; MST[NonVoidMethodCallMutator]MSP[N] break; default: throw new IllegalStateException ( lr_13 + this . nameType ) ; } if ( this . concat ) {
if ( input . startsWith ( l + lr_10 ) ) { MST[experimental.NakedReceiverMutator]MSP[N] final String remainder = input . substring ( l . length () + 1 ) ; final String combined = l + remainder ;
if ( this . nameType == NameType . GENERIC ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] if ( input . length () >= 2 && input . substring ( 0 , 2 ) . equals ( lr_5 ) ) { final String remainder = input . substring ( 2 ) ;
if ( this . nameType == NameType . GENERIC ) { if ( input . length () >= 2 && input . substring ( 0 , 2 ) . equals ( lr_5 ) ) { MST[rv.CRCR1Mutator]MSP[S] final String remainder = input . substring ( 2 ) ;
final String combined = lr_6 + remainder ; return lr_7 + encode ( remainder ) + lr_8 + encode ( combined ) + lr_9 ; } for ( final String l : NAME_PREFIXES . get ( this . nameType ) ) { MST[ArgumentPropagationMutator]MSP[N]
final String combined = lr_6 + remainder ; return lr_7 + encode ( remainder ) + lr_8 + encode ( combined ) + lr_9 ; MST[ConstructorCallMutator]MSP[S] } for ( final String l : NAME_PREFIXES . get ( this . nameType ) ) {
PhonemeBuilder subBuilder = PhonemeBuilder . empty ( phoneme . getLanguages () ) ; final String phonemeText = phoneme . getPhonemeText () . toString () ; for ( int i = 0 ; i < phonemeText . length () ; ) { final RulesApplication rulesApplication = MST[rv.UOI2Mutator]MSP[N]
subBuilder . append ( phonemeText . subSequence ( i , i + 1 ) ) ; } i = rulesApplication . getI () ; } for ( final Rule . Phoneme newPhoneme : subBuilder . getPhonemes () ) { if ( phonemes . containsKey ( newPhoneme ) ) { MST[rv.ROR5Mutator]MSP[N]
for ( int i = 0 ; i < input . length () ; ) { MST[rv.UOI4Mutator]MSP[N] final RulesApplication rulesApplication = new RulesApplication ( rules , input , phonemeBuilder , i , maxPhonemes ) . invoke () ; i = rulesApplication . getI () ;
return this . nameType ; MST[ReturnValsMutator]MSP[N] } public RuleType getRuleType () { return this . ruleType ; } public boolean isConcat () { return this . concat ; } public int getMaxPhonemes () { return this . maxPhonemes ; }
return this . nameType ; } public RuleType getRuleType () { return this . ruleType ; } public boolean isConcat () { return this . concat ; } public int getMaxPhonemes () { return this . maxPhonemes ; MST[rv.UOI2Mutator]MSP[N] }
if ( si . hasNext () ) { MST[rv.ROR2Mutator]MSP[N] sb . append ( si . next () ) ; } while ( si . hasNext () ) { sb . append ( sep ) . append ( si . next () ) ; } return sb . toString () ; }
if ( input . startsWith ( l + lr_10 ) ) { MST[NonVoidMethodCallMutator]MSP[S] final String remainder = input . substring ( l . length () + 1 ) ; final String combined = l + remainder ;
final List < String > words2 = new ArrayList <> () ; switch ( this . nameType ) { MST[rv.UOI3Mutator]MSP[N] case SEPHARDIC : for ( final String aWord : words ) { final String [] parts = aWord . split ( lr_12 ) ;
if ( si . hasNext () ) { sb . append ( si . next () ) ; } while ( si . hasNext () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] sb . append ( sep ) . append ( si . next () ) ; } return sb . toString () ; }
if ( si . hasNext () ) { sb . append ( si . next () ) ; } while ( si . hasNext () ) { sb . append ( sep ) . append ( si . next () ) ; MST[experimental.NakedReceiverMutator]MSP[S] } return sb . toString () ; }
if ( si . hasNext () ) { sb . append ( si . next () ) ; } while ( si . hasNext () ) { sb . append ( sep ) . append ( si . next () ) ; } return sb . toString () ; MST[ReturnValsMutator]MSP[N] }
private PhonemeBuilder applyFinalRules ( final PhonemeBuilder phonemeBuilder , final Map < String , List < Rule > > finalRules ) { Objects . requireNonNull ( finalRules , lr_3 ) ; if ( finalRules . isEmpty () ) { MST[NonVoidMethodCallMutator]MSP[N] return phonemeBuilder ; }
PhonemeBuilder subBuilder = PhonemeBuilder . empty ( phoneme . getLanguages () ) ; final String phonemeText = phoneme . getPhonemeText () . toString () ; for ( int i = 0 ; i < phonemeText . length () ; ) { MST[rv.CRCR5Mutator]MSP[N] final RulesApplication rulesApplication =
subBuilder . append ( phonemeText . subSequence ( i , i + 1 ) ) ; MST[rv.UOI4Mutator]MSP[N] } i = rulesApplication . getI () ; } for ( final Rule . Phoneme newPhoneme : subBuilder . getPhonemes () ) { if ( phonemes . containsKey ( newPhoneme ) ) {
phonemeBuilder = rulesApplication . getPhonemeBuilder () ; } phonemeBuilder = applyFinalRules ( phonemeBuilder , finalRules1 ) ; phonemeBuilder = applyFinalRules ( phonemeBuilder , finalRules2 ) ; MST[NonVoidMethodCallMutator]MSP[N] return phonemeBuilder . makeString () ; } public Lang getLang () { return this . lang ; } public NameType getNameType () {
for ( int i = 0 ; i < input . length () ; ) { MST[InlineConstantMutator]MSP[N] final RulesApplication rulesApplication = new RulesApplication ( rules , input , phonemeBuilder , i , maxPhonemes ) . invoke () ; i = rulesApplication . getI () ;
input = join ( words2 , lr_10 ) ; } else if ( words2 . size () == 1 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] input = words . iterator () . next () ; } else { final StringBuilder result = new StringBuilder () ;
if ( this . nameType == NameType . GENERIC ) { if ( input . length () >= 2 && input . substring ( 0 , 2 ) . equals ( lr_5 ) ) { MST[rv.CRCR5Mutator]MSP[N] final String remainder = input . substring ( 2 ) ;
return lr_7 + encode ( remainder ) + lr_8 + encode ( combined ) + lr_9 ; MST[NonVoidMethodCallMutator]MSP[S] } } } final List < String > words = Arrays . asList ( input . split ( lr_11 ) ) ;
if ( this . nameType == NameType . GENERIC ) { if ( input . length () >= 2 && input . substring ( 0 , 2 ) . equals ( lr_5 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] final String remainder = input . substring ( 2 ) ;
input = join ( words2 , lr_10 ) ; } else if ( words2 . size () == 1 ) { MST[rv.CRCR5Mutator]MSP[N] input = words . iterator () . next () ; } else { final StringBuilder result = new StringBuilder () ;
if ( si . hasNext () ) { sb . append ( si . next () ) ; } while ( si . hasNext () ) { sb . append ( sep ) . append ( si . next () ) ; MST[NonVoidMethodCallMutator]MSP[S] } return sb . toString () ; }
final Rule . Phoneme oldPhoneme = phonemes . remove ( newPhoneme ) ; MST[ArgumentPropagationMutator]MSP[N] final Rule . Phoneme mergedPhoneme = oldPhoneme . mergeWithLanguage ( newPhoneme . getLanguages () ) ; phonemes . put ( mergedPhoneme , mergedPhoneme ) ; } else { phonemes . put ( newPhoneme , newPhoneme ) ;
private PhonemeBuilder applyFinalRules ( final PhonemeBuilder phonemeBuilder , final Map < String , List < Rule > > finalRules ) { Objects . requireNonNull ( finalRules , lr_3 ) ; MST[ArgumentPropagationMutator]MSP[N] if ( finalRules . isEmpty () ) { return phonemeBuilder ; }
if ( input . startsWith ( l + lr_10 ) ) { final String remainder = input . substring ( l . length () + 1 ) ; final String combined = l + remainder ; MST[NonVoidMethodCallMutator]MSP[S]
PhonemeBuilder subBuilder = PhonemeBuilder . empty ( phoneme . getLanguages () ) ; MST[NonVoidMethodCallMutator]MSP[N] final String phonemeText = phoneme . getPhonemeText () . toString () ; for ( int i = 0 ; i < phonemeText . length () ; ) { final RulesApplication rulesApplication =
if ( si . hasNext () ) { sb . append ( si . next () ) ; } while ( si . hasNext () ) { MST[rv.ROR1Mutator]MSP[N] sb . append ( sep ) . append ( si . next () ) ; } return sb . toString () ; }
subBuilder . append ( phonemeText . subSequence ( i , i + 1 ) ) ; } i = rulesApplication . getI () ; } for ( final Rule . Phoneme newPhoneme : subBuilder . getPhonemes () ) { if ( phonemes . containsKey ( newPhoneme ) ) { MST[NegateConditionalsMutator]MSP[N]
PhonemeBuilder subBuilder = PhonemeBuilder . empty ( phoneme . getLanguages () ) ; final String phonemeText = phoneme . getPhonemeText () . toString () ; for ( int i = 0 ; i < phonemeText . length () ; ) { MST[rv.UOI2Mutator]MSP[N] final RulesApplication rulesApplication =
private PhonemeBuilder applyFinalRules ( final PhonemeBuilder phonemeBuilder , final Map < String , List < Rule > > finalRules ) { Objects . requireNonNull ( finalRules , lr_3 ) ; if ( finalRules . isEmpty () ) { return phonemeBuilder ; MST[NullReturnValsMutator]MSP[S] }
if ( this . nameType == NameType . GENERIC ) { if ( input . length () >= 2 && input . substring ( 0 , 2 ) . equals ( lr_5 ) ) { MST[rv.ROR2Mutator]MSP[N] final String remainder = input . substring ( 2 ) ;
final List < String > words2 = new ArrayList <> () ; switch ( this . nameType ) { MST[NonVoidMethodCallMutator]MSP[N] case SEPHARDIC : for ( final String aWord : words ) { final String [] parts = aWord . split ( lr_12 ) ;
final String combined = lr_6 + remainder ; return lr_7 + encode ( remainder ) + lr_8 + encode ( combined ) + lr_9 ; MST[experimental.NakedReceiverMutator]MSP[S] } for ( final String l : NAME_PREFIXES . get ( this . nameType ) ) {
final String lastPart = parts [ parts . length - 1 ] ; words2 . add ( lastPart ) ; } words2 . removeAll ( NAME_PREFIXES . get ( this . nameType ) ) ; MST[NonVoidMethodCallMutator]MSP[S] break; case ASHKENAZI : words2 . addAll ( words ) ;
PhonemeBuilder subBuilder = PhonemeBuilder . empty ( phoneme . getLanguages () ) ; final String phonemeText = phoneme . getPhonemeText () . toString () ; for ( int i = 0 ; i < phonemeText . length () ; ) { final RulesApplication rulesApplication = MST[rv.UOI1Mutator]MSP[N]
if ( this . nameType == NameType . GENERIC ) { if ( input . length () >= 2 && input . substring ( 0 , 2 ) . equals ( lr_5 ) ) { final String remainder = input . substring ( 2 ) ; MST[NonVoidMethodCallMutator]MSP[S]
for ( int i = 0 ; i < input . length () ; ) { final RulesApplication rulesApplication = MST[rv.UOI2Mutator]MSP[N] new RulesApplication ( rules , input , phonemeBuilder , i , maxPhonemes ) . invoke () ; i = rulesApplication . getI () ;
if ( this . nameType == NameType . GENERIC ) { if ( input . length () >= 2 && input . substring ( 0 , 2 ) . equals ( lr_5 ) ) { final String remainder = input . substring ( 2 ) ; MST[InlineConstantMutator]MSP[S]
final Map < String , List < Rule > > finalRules2 = Rule . getInstanceMap ( this . nameType , this . ruleType , languageSet ) ; input = input . toLowerCase ( Locale . ENGLISH ) . replace ( '-' , ' ' ) . trim () ; MST[rv.CRCR5Mutator]MSP[N]
subBuilder . append ( phonemeText . subSequence ( i , i + 1 ) ) ; MST[MathMutator]MSP[N] } i = rulesApplication . getI () ; } for ( final Rule . Phoneme newPhoneme : subBuilder . getPhonemes () ) { if ( phonemes . containsKey ( newPhoneme ) ) {
for ( int i = 0 ; i < input . length () ; ) { MST[NegateConditionalsMutator]MSP[N] final RulesApplication rulesApplication = new RulesApplication ( rules , input , phonemeBuilder , i , maxPhonemes ) . invoke () ; i = rulesApplication . getI () ;
PhonemeBuilder subBuilder = PhonemeBuilder . empty ( phoneme . getLanguages () ) ; final String phonemeText = phoneme . getPhonemeText () . toString () ; for ( int i = 0 ; i < phonemeText . length () ; ) { final RulesApplication rulesApplication = MST[rv.ABSMutator]MSP[N]
subBuilder . append ( phonemeText . subSequence ( i , i + 1 ) ) ; } i = rulesApplication . getI () ; } for ( final Rule . Phoneme newPhoneme : subBuilder . getPhonemes () ) { if ( phonemes . containsKey ( newPhoneme ) ) { MST[rv.ROR2Mutator]MSP[N]
new RulesApplication ( finalRules , phonemeText , subBuilder , i , maxPhonemes ) . invoke () ; MST[NonVoidMethodCallMutator]MSP[N] final boolean found = rulesApplication . isFound () ; subBuilder = rulesApplication . getPhonemeBuilder () ; if ( ! found ) {
subBuilder . append ( phonemeText . subSequence ( i , i + 1 ) ) ; MST[rv.UOI4Mutator]MSP[N] } i = rulesApplication . getI () ; } for ( final Rule . Phoneme newPhoneme : subBuilder . getPhonemes () ) { if ( phonemes . containsKey ( newPhoneme ) ) {
input = join ( words2 , lr_10 ) ; } else if ( words2 . size () == 1 ) { MST[NegateConditionalsMutator]MSP[N] input = words . iterator () . next () ; } else { final StringBuilder result = new StringBuilder () ;
for ( int i = 0 ; i < input . length () ; ) { final RulesApplication rulesApplication = MST[ConstructorCallMutator]MSP[N] new RulesApplication ( rules , input , phonemeBuilder , i , maxPhonemes ) . invoke () ; i = rulesApplication . getI () ;
new RulesApplication ( finalRules , phonemeText , subBuilder , i , maxPhonemes ) . invoke () ; final boolean found = rulesApplication . isFound () ; subBuilder = rulesApplication . getPhonemeBuilder () ; if ( ! found ) { MST[rv.ROR4Mutator]MSP[N]
final Rule . Phoneme oldPhoneme = phonemes . remove ( newPhoneme ) ; final Rule . Phoneme mergedPhoneme = oldPhoneme . mergeWithLanguage ( newPhoneme . getLanguages () ) ; phonemes . put ( mergedPhoneme , mergedPhoneme ) ; MST[ArgumentPropagationMutator]MSP[N] } else { phonemes . put ( newPhoneme , newPhoneme ) ;
return lr_7 + encode ( remainder ) + lr_8 + encode ( combined ) + lr_9 ; MST[ReturnValsMutator]MSP[S] } } } final List < String > words = Arrays . asList ( input . split ( lr_11 ) ) ;
if ( this . nameType == NameType . GENERIC ) { if ( input . length () >= 2 && input . substring ( 0 , 2 ) . equals ( lr_5 ) ) { MST[rv.CRCR4Mutator]MSP[N] final String remainder = input . substring ( 2 ) ;
subBuilder . append ( phonemeText . subSequence ( i , i + 1 ) ) ; MST[rv.AOR4Mutator]MSP[N] } i = rulesApplication . getI () ; } for ( final Rule . Phoneme newPhoneme : subBuilder . getPhonemes () ) { if ( phonemes . containsKey ( newPhoneme ) ) {
if ( input . startsWith ( l + lr_10 ) ) { MST[experimental.NakedReceiverMutator]MSP[N] final String remainder = input . substring ( l . length () + 1 ) ; final String combined = l + remainder ;
if ( input . startsWith ( l + lr_10 ) ) { final String remainder = input . substring ( l . length () + 1 ) ; final String combined = l + remainder ; MST[NonVoidMethodCallMutator]MSP[S]
if ( this . nameType == NameType . GENERIC ) { if ( input . length () >= 2 && input . substring ( 0 , 2 ) . equals ( lr_5 ) ) { MST[ConditionalsBoundaryMutator]MSP[N] final String remainder = input . substring ( 2 ) ;
final String lastPart = parts [ parts . length - 1 ] ; MST[rv.AOR3Mutator]MSP[S] words2 . add ( lastPart ) ; } words2 . removeAll ( NAME_PREFIXES . get ( this . nameType ) ) ; break; case ASHKENAZI : words2 . addAll ( words ) ;
final String combined = lr_6 + remainder ; return lr_7 + encode ( remainder ) + lr_8 + encode ( combined ) + lr_9 ; MST[ArgumentPropagationMutator]MSP[S] } for ( final String l : NAME_PREFIXES . get ( this . nameType ) ) {
if ( this . nameType == NameType . GENERIC ) { if ( input . length () >= 2 && input . substring ( 0 , 2 ) . equals ( lr_5 ) ) { final String remainder = input . substring ( 2 ) ; MST[rv.CRCR3Mutator]MSP[S]
if ( input . startsWith ( l + lr_10 ) ) { final String remainder = input . substring ( l . length () + 1 ) ; MST[rv.CRCR5Mutator]MSP[S] final String combined = l + remainder ;
input = join ( words2 , lr_10 ) ; } else if ( words2 . size () == 1 ) { MST[rv.ROR1Mutator]MSP[N] input = words . iterator () . next () ; } else { final StringBuilder result = new StringBuilder () ;
if ( input . startsWith ( l + lr_10 ) ) { final String remainder = input . substring ( l . length () + 1 ) ; MST[rv.AOR1Mutator]MSP[S] final String combined = l + remainder ;
for ( int i = 0 ; i < input . length () ; ) { MST[rv.ROR1Mutator]MSP[N] final RulesApplication rulesApplication = new RulesApplication ( rules , input , phonemeBuilder , i , maxPhonemes ) . invoke () ; i = rulesApplication . getI () ;
if ( input . startsWith ( l + lr_10 ) ) { MST[rv.ROR4Mutator]MSP[N] final String remainder = input . substring ( l . length () + 1 ) ; final String combined = l + remainder ;
if ( si . hasNext () ) { MST[rv.ROR5Mutator]MSP[N] sb . append ( si . next () ) ; } while ( si . hasNext () ) { sb . append ( sep ) . append ( si . next () ) ; } return sb . toString () ; }
final Map < String , List < Rule > > finalRules2 = Rule . getInstanceMap ( this . nameType , this . ruleType , languageSet ) ; input = input . toLowerCase ( Locale . ENGLISH ) . replace ( '-' , ' ' ) . trim () ; MST[rv.CRCR5Mutator]MSP[N]
final String combined = lr_6 + remainder ; MST[experimental.NakedReceiverMutator]MSP[S] return lr_7 + encode ( remainder ) + lr_8 + encode ( combined ) + lr_9 ; } for ( final String l : NAME_PREFIXES . get ( this . nameType ) ) {
final Rule . Phoneme oldPhoneme = phonemes . remove ( newPhoneme ) ; final Rule . Phoneme mergedPhoneme = oldPhoneme . mergeWithLanguage ( newPhoneme . getLanguages () ) ; phonemes . put ( mergedPhoneme , mergedPhoneme ) ; } else { phonemes . put ( newPhoneme , newPhoneme ) ; MST[ArgumentPropagationMutator]MSP[N]
for ( int i = 0 ; i < input . length () ; ) { final RulesApplication rulesApplication = MST[rv.UOI4Mutator]MSP[N] new RulesApplication ( rules , input , phonemeBuilder , i , maxPhonemes ) . invoke () ; i = rulesApplication . getI () ;
words2 . removeAll ( NAME_PREFIXES . get ( this . nameType ) ) ; break; case GENERIC : words2 . addAll ( words ) ; break; default: throw new IllegalStateException ( lr_13 + this . nameType ) ; } if ( this . concat ) { MST[rv.ROR3Mutator]MSP[N]
PhonemeBuilder subBuilder = PhonemeBuilder . empty ( phoneme . getLanguages () ) ; final String phonemeText = phoneme . getPhonemeText () . toString () ; for ( int i = 0 ; i < phonemeText . length () ; ) { MST[rv.ROR3Mutator]MSP[N] final RulesApplication rulesApplication =
new RulesApplication ( finalRules , phonemeText , subBuilder , i , maxPhonemes ) . invoke () ; final boolean found = rulesApplication . isFound () ; subBuilder = rulesApplication . getPhonemeBuilder () ; if ( ! found ) { MST[rv.UOI1Mutator]MSP[N]
final Rule . Phoneme oldPhoneme = phonemes . remove ( newPhoneme ) ; final Rule . Phoneme mergedPhoneme = oldPhoneme . mergeWithLanguage ( newPhoneme . getLanguages () ) ; MST[NonVoidMethodCallMutator]MSP[N] phonemes . put ( mergedPhoneme , mergedPhoneme ) ; } else { phonemes . put ( newPhoneme , newPhoneme ) ;
private PhonemeBuilder applyFinalRules ( final PhonemeBuilder phonemeBuilder , final Map < String , List < Rule > > finalRules ) { Objects . requireNonNull ( finalRules , lr_3 ) ; if ( finalRules . isEmpty () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return phonemeBuilder ; }
return lr_7 + encode ( remainder ) + lr_8 + encode ( combined ) + lr_9 ; MST[NonVoidMethodCallMutator]MSP[S] } } } final List < String > words = Arrays . asList ( input . split ( lr_11 ) ) ;
final String combined = lr_6 + remainder ; MST[NonVoidMethodCallMutator]MSP[S] return lr_7 + encode ( remainder ) + lr_8 + encode ( combined ) + lr_9 ; } for ( final String l : NAME_PREFIXES . get ( this . nameType ) ) {
if ( si . hasNext () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] sb . append ( si . next () ) ; } while ( si . hasNext () ) { sb . append ( sep ) . append ( si . next () ) ; } return sb . toString () ; }
for ( int i = 0 ; i < input . length () ; ) { final RulesApplication rulesApplication = new RulesApplication ( rules , input , phonemeBuilder , i , maxPhonemes ) . invoke () ; i = rulesApplication . getI () ; MST[NonVoidMethodCallMutator]MSP[N]
if ( input . startsWith ( l + lr_10 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] final String remainder = input . substring ( l . length () + 1 ) ; final String combined = l + remainder ;
new RulesApplication ( finalRules , phonemeText , subBuilder , i , maxPhonemes ) . invoke () ; final boolean found = rulesApplication . isFound () ; subBuilder = rulesApplication . getPhonemeBuilder () ; if ( ! found ) { MST[rv.ROR2Mutator]MSP[N]
if ( this . nameType == NameType . GENERIC ) { if ( input . length () >= 2 && input . substring ( 0 , 2 ) . equals ( lr_5 ) ) { MST[NonVoidMethodCallMutator]MSP[N] final String remainder = input . substring ( 2 ) ;
PhonemeBuilder subBuilder = PhonemeBuilder . empty ( phoneme . getLanguages () ) ; final String phonemeText = phoneme . getPhonemeText () . toString () ; for ( int i = 0 ; i < phonemeText . length () ; ) { MST[rv.ROR5Mutator]MSP[N] final RulesApplication rulesApplication =
if ( input . startsWith ( l + lr_10 ) ) { final String remainder = input . substring ( l . length () + 1 ) ; MST[rv.AOR4Mutator]MSP[S] final String combined = l + remainder ;
return lr_7 + encode ( remainder ) + lr_8 + encode ( combined ) + lr_9 ; MST[experimental.NakedReceiverMutator]MSP[S] } } } final List < String > words = Arrays . asList ( input . split ( lr_11 ) ) ;
final Map < String , List < Rule > > finalRules2 = Rule . getInstanceMap ( this . nameType , this . ruleType , languageSet ) ; input = input . toLowerCase ( Locale . ENGLISH ) . replace ( '-' , ' ' ) . trim () ; MST[rv.CRCR1Mutator]MSP[N]
if ( si . hasNext () ) { MST[rv.ROR1Mutator]MSP[N] sb . append ( si . next () ) ; } while ( si . hasNext () ) { sb . append ( sep ) . append ( si . next () ) ; } return sb . toString () ; }
final String lastPart = parts [ parts . length - 1 ] ; MST[rv.CRCR3Mutator]MSP[S] words2 . add ( lastPart ) ; } words2 . removeAll ( NAME_PREFIXES . get ( this . nameType ) ) ; break; case ASHKENAZI : words2 . addAll ( words ) ;
private PhonemeBuilder applyFinalRules ( final PhonemeBuilder phonemeBuilder , final Map < String , List < Rule > > finalRules ) { Objects . requireNonNull ( finalRules , lr_3 ) ; if ( finalRules . isEmpty () ) { MST[rv.ROR5Mutator]MSP[N] return phonemeBuilder ; }
private PhonemeBuilder applyFinalRules ( final PhonemeBuilder phonemeBuilder , final Map < String , List < Rule > > finalRules ) { Objects . requireNonNull ( finalRules , lr_3 ) ; if ( finalRules . isEmpty () ) { MST[rv.ROR3Mutator]MSP[N] return phonemeBuilder ; }
final List < String > words2 = new ArrayList <> () ; switch ( this . nameType ) { MST[rv.UOI4Mutator]MSP[N] case SEPHARDIC : for ( final String aWord : words ) { final String [] parts = aWord . split ( lr_12 ) ;
if ( si . hasNext () ) { sb . append ( si . next () ) ; } while ( si . hasNext () ) { MST[NegateConditionalsMutator]MSP[N] sb . append ( sep ) . append ( si . next () ) ; } return sb . toString () ; }
subBuilder . append ( phonemeText . subSequence ( i , i + 1 ) ) ; MST[rv.AOR2Mutator]MSP[N] } i = rulesApplication . getI () ; } for ( final Rule . Phoneme newPhoneme : subBuilder . getPhonemes () ) { if ( phonemes . containsKey ( newPhoneme ) ) {
words2 . removeAll ( NAME_PREFIXES . get ( this . nameType ) ) ; MST[ArgumentPropagationMutator]MSP[S] break; case GENERIC : words2 . addAll ( words ) ; break; default: throw new IllegalStateException ( lr_13 + this . nameType ) ; } if ( this . concat ) {
if ( this . nameType == NameType . GENERIC ) { if ( input . length () >= 2 && input . substring ( 0 , 2 ) . equals ( lr_5 ) ) { MST[rv.ROR2Mutator]MSP[N] final String remainder = input . substring ( 2 ) ;
if ( this . nameType == NameType . GENERIC ) { if ( input . length () >= 2 && input . substring ( 0 , 2 ) . equals ( lr_5 ) ) { MST[rv.CRCR6Mutator]MSP[N] final String remainder = input . substring ( 2 ) ;
if ( this . nameType == NameType . GENERIC ) { if ( input . length () >= 2 && input . substring ( 0 , 2 ) . equals ( lr_5 ) ) { MST[rv.CRCR5Mutator]MSP[N] final String remainder = input . substring ( 2 ) ;
phonemeBuilder = rulesApplication . getPhonemeBuilder () ; } phonemeBuilder = applyFinalRules ( phonemeBuilder , finalRules1 ) ; phonemeBuilder = applyFinalRules ( phonemeBuilder , finalRules2 ) ; return phonemeBuilder . makeString () ; MST[ReturnValsMutator]MSP[N] } public Lang getLang () { return this . lang ; } public NameType getNameType () {
words2 . removeAll ( NAME_PREFIXES . get ( this . nameType ) ) ; break; case GENERIC : words2 . addAll ( words ) ; break; default: throw new IllegalStateException ( lr_13 + this . nameType ) ; } if ( this . concat ) { MST[NegateConditionalsMutator]MSP[N]
final Map < Rule . Phoneme , Rule . Phoneme > phonemes = new TreeMap <> ( Rule . Phoneme . COMPARATOR ) ; for ( final Rule . Phoneme phoneme : phonemeBuilder . getPhonemes () ) { MST[NonVoidMethodCallMutator]MSP[N]
public boolean isFound () { return this . found ; } private static String join ( final Iterable < String > strings , final String sep ) { final StringBuilder sb = new StringBuilder () ; MST[ConstructorCallMutator]MSP[N] final Iterator < String > si = strings . iterator () ;
final String combined = lr_6 + remainder ; return lr_7 + encode ( remainder ) + lr_8 + encode ( combined ) + lr_9 ; MST[NonVoidMethodCallMutator]MSP[S] } for ( final String l : NAME_PREFIXES . get ( this . nameType ) ) {
subBuilder . append ( phonemeText . subSequence ( i , i + 1 ) ) ; MST[rv.CRCR5Mutator]MSP[N] } i = rulesApplication . getI () ; } for ( final Rule . Phoneme newPhoneme : subBuilder . getPhonemes () ) { if ( phonemes . containsKey ( newPhoneme ) ) {
return lr_7 + encode ( remainder ) + lr_8 + encode ( combined ) + lr_9 ; MST[ArgumentPropagationMutator]MSP[S] } } } final List < String > words = Arrays . asList ( input . split ( lr_11 ) ) ;
PhonemeBuilder subBuilder = PhonemeBuilder . empty ( phoneme . getLanguages () ) ; MST[NonVoidMethodCallMutator]MSP[N] final String phonemeText = phoneme . getPhonemeText () . toString () ; for ( int i = 0 ; i < phonemeText . length () ; ) { final RulesApplication rulesApplication =
if ( this . nameType == NameType . GENERIC ) { if ( input . length () >= 2 && input . substring ( 0 , 2 ) . equals ( lr_5 ) ) { MST[rv.CRCR1Mutator]MSP[N] final String remainder = input . substring ( 2 ) ;
final String combined = lr_6 + remainder ; MST[NonVoidMethodCallMutator]MSP[S] return lr_7 + encode ( remainder ) + lr_8 + encode ( combined ) + lr_9 ; } for ( final String l : NAME_PREFIXES . get ( this . nameType ) ) {
} } } return new PhonemeBuilder ( phonemes . keySet () ) ; } public String encode ( final String input ) { final Languages . LanguageSet languageSet = this . lang . guessLanguages ( input ) ; MST[NonVoidMethodCallMutator]MSP[N] return encode ( input , languageSet ) ; }
PhonemeBuilder subBuilder = PhonemeBuilder . empty ( phoneme . getLanguages () ) ; final String phonemeText = phoneme . getPhonemeText () . toString () ; for ( int i = 0 ; i < phonemeText . length () ; ) { final RulesApplication rulesApplication = MST[rv.UOI4Mutator]MSP[N]
if ( this . nameType == NameType . GENERIC ) { if ( input . length () >= 2 && input . substring ( 0 , 2 ) . equals ( lr_5 ) ) { MST[rv.ROR3Mutator]MSP[N] final String remainder = input . substring ( 2 ) ;
PhonemeBuilder subBuilder = PhonemeBuilder . empty ( phoneme . getLanguages () ) ; final String phonemeText = phoneme . getPhonemeText () . toString () ; for ( int i = 0 ; i < phonemeText . length () ; ) { MST[NonVoidMethodCallMutator]MSP[N] final RulesApplication rulesApplication =
} } } return new PhonemeBuilder ( phonemes . keySet () ) ; } public String encode ( final String input ) { final Languages . LanguageSet languageSet = this . lang . guessLanguages ( input ) ; return encode ( input , languageSet ) ; MST[EmptyObjectReturnValsMutator]MSP[N] }
if ( input . startsWith ( l + lr_10 ) ) { MST[NonVoidMethodCallMutator]MSP[N] final String remainder = input . substring ( l . length () + 1 ) ; final String combined = l + remainder ;
for ( int i = 0 ; i < input . length () ; ) { final RulesApplication rulesApplication = MST[rv.ABSMutator]MSP[N] new RulesApplication ( rules , input , phonemeBuilder , i , maxPhonemes ) . invoke () ; i = rulesApplication . getI () ;
PhonemeBuilder subBuilder = PhonemeBuilder . empty ( phoneme . getLanguages () ) ; final String phonemeText = phoneme . getPhonemeText () . toString () ; for ( int i = 0 ; i < phonemeText . length () ; ) { MST[rv.CRCR1Mutator]MSP[N] final RulesApplication rulesApplication =
} } } return new PhonemeBuilder ( phonemes . keySet () ) ; MST[ReturnValsMutator]MSP[N] } public String encode ( final String input ) { final Languages . LanguageSet languageSet = this . lang . guessLanguages ( input ) ; return encode ( input , languageSet ) ; }
final String combined = lr_6 + remainder ; MST[experimental.NakedReceiverMutator]MSP[S] return lr_7 + encode ( remainder ) + lr_8 + encode ( combined ) + lr_9 ; } for ( final String l : NAME_PREFIXES . get ( this . nameType ) ) {
for ( int i = 0 ; i < input . length () ; ) { final RulesApplication rulesApplication = MST[rv.UOI3Mutator]MSP[N] new RulesApplication ( rules , input , phonemeBuilder , i , maxPhonemes ) . invoke () ; i = rulesApplication . getI () ;
for ( final String word : words2 ) { result . append ( lr_14 ) . append ( encode ( word ) ) ; } return result . substring ( 1 ) ; } PhonemeBuilder phonemeBuilder = PhonemeBuilder . empty ( languageSet ) ; MST[NonVoidMethodCallMutator]MSP[N]
if ( input . startsWith ( l + lr_10 ) ) { final String remainder = input . substring ( l . length () + 1 ) ; MST[experimental.NakedReceiverMutator]MSP[S] final String combined = l + remainder ;
subBuilder . append ( phonemeText . subSequence ( i , i + 1 ) ) ; MST[rv.UOI3Mutator]MSP[N] } i = rulesApplication . getI () ; } for ( final Rule . Phoneme newPhoneme : subBuilder . getPhonemes () ) { if ( phonemes . containsKey ( newPhoneme ) ) {
if ( this . nameType == NameType . GENERIC ) { if ( input . length () >= 2 && input . substring ( 0 , 2 ) . equals ( lr_5 ) ) { MST[rv.ROR4Mutator]MSP[N] final String remainder = input . substring ( 2 ) ;
subBuilder . append ( phonemeText . subSequence ( i , i + 1 ) ) ; MST[rv.UOI2Mutator]MSP[N] } i = rulesApplication . getI () ; } for ( final Rule . Phoneme newPhoneme : subBuilder . getPhonemes () ) { if ( phonemes . containsKey ( newPhoneme ) ) {
new RulesApplication ( finalRules , phonemeText , subBuilder , i , maxPhonemes ) . invoke () ; final boolean found = rulesApplication . isFound () ; MST[NonVoidMethodCallMutator]MSP[N] subBuilder = rulesApplication . getPhonemeBuilder () ; if ( ! found ) {
PhonemeBuilder subBuilder = PhonemeBuilder . empty ( phoneme . getLanguages () ) ; final String phonemeText = phoneme . getPhonemeText () . toString () ; for ( int i = 0 ; i < phonemeText . length () ; ) { MST[rv.CRCR6Mutator]MSP[N] final RulesApplication rulesApplication =
if ( si . hasNext () ) { MST[NonVoidMethodCallMutator]MSP[N] sb . append ( si . next () ) ; } while ( si . hasNext () ) { sb . append ( sep ) . append ( si . next () ) ; } return sb . toString () ; }
if ( si . hasNext () ) { sb . append ( si . next () ) ; MST[experimental.NakedReceiverMutator]MSP[N] } while ( si . hasNext () ) { sb . append ( sep ) . append ( si . next () ) ; } return sb . toString () ; }
if ( si . hasNext () ) { sb . append ( si . next () ) ; } while ( si . hasNext () ) { MST[rv.ROR4Mutator]MSP[N] sb . append ( sep ) . append ( si . next () ) ; } return sb . toString () ; }
if ( si . hasNext () ) { sb . append ( si . next () ) ; } while ( si . hasNext () ) { MST[rv.ROR5Mutator]MSP[N] sb . append ( sep ) . append ( si . next () ) ; } return sb . toString () ; }
if ( this . nameType == NameType . GENERIC ) { if ( input . length () >= 2 && input . substring ( 0 , 2 ) . equals ( lr_5 ) ) { MST[experimental.NakedReceiverMutator]MSP[N] final String remainder = input . substring ( 2 ) ;
subBuilder . append ( phonemeText . subSequence ( i , i + 1 ) ) ; } i = rulesApplication . getI () ; } for ( final Rule . Phoneme newPhoneme : subBuilder . getPhonemes () ) { if ( phonemes . containsKey ( newPhoneme ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
if ( this . nameType == NameType . GENERIC ) { if ( input . length () >= 2 && input . substring ( 0 , 2 ) . equals ( lr_5 ) ) { MST[rv.CRCR6Mutator]MSP[N] final String remainder = input . substring ( 2 ) ;
return this . nameType ; } public RuleType getRuleType () { return this . ruleType ; MST[NullReturnValsMutator]MSP[N] } public boolean isConcat () { return this . concat ; } public int getMaxPhonemes () { return this . maxPhonemes ; }
final String combined = lr_6 + remainder ; return lr_7 + encode ( remainder ) + lr_8 + encode ( combined ) + lr_9 ; MST[NonVoidMethodCallMutator]MSP[S] } for ( final String l : NAME_PREFIXES . get ( this . nameType ) ) {
if ( this . nameType == NameType . GENERIC ) { if ( input . length () >= 2 && input . substring ( 0 , 2 ) . equals ( lr_5 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] final String remainder = input . substring ( 2 ) ;
input = join ( words2 , lr_10 ) ; } else if ( words2 . size () == 1 ) { MST[rv.CRCR6Mutator]MSP[N] input = words . iterator () . next () ; } else { final StringBuilder result = new StringBuilder () ;
if ( input . startsWith ( l + lr_10 ) ) { final String remainder = input . substring ( l . length () + 1 ) ; MST[rv.CRCR6Mutator]MSP[S] final String combined = l + remainder ;
final String lastPart = parts [ parts . length - 1 ] ; MST[InlineConstantMutator]MSP[S] words2 . add ( lastPart ) ; } words2 . removeAll ( NAME_PREFIXES . get ( this . nameType ) ) ; break; case ASHKENAZI : words2 . addAll ( words ) ;
if ( this . nameType == NameType . GENERIC ) { if ( input . length () >= 2 && input . substring ( 0 , 2 ) . equals ( lr_5 ) ) { MST[rv.CRCR1Mutator]MSP[N] final String remainder = input . substring ( 2 ) ;
if ( this . nameType == NameType . GENERIC ) { if ( input . length () >= 2 && input . substring ( 0 , 2 ) . equals ( lr_5 ) ) { MST[rv.CRCR2Mutator]MSP[N] final String remainder = input . substring ( 2 ) ;
} } } return new PhonemeBuilder ( phonemes . keySet () ) ; } public String encode ( final String input ) { final Languages . LanguageSet languageSet = this . lang . guessLanguages ( input ) ; return encode ( input , languageSet ) ; MST[ReturnValsMutator]MSP[N] }
public String encode ( String input , final Languages . LanguageSet languageSet ) { final Map < String , List < Rule > > rules = Rule . getInstanceMap ( this . nameType , RuleType . RULES , languageSet ) ; MST[NonVoidMethodCallMutator]MSP[N]
final String lastPart = parts [ parts . length - 1 ] ; MST[MathMutator]MSP[S] words2 . add ( lastPart ) ; } words2 . removeAll ( NAME_PREFIXES . get ( this . nameType ) ) ; break; case ASHKENAZI : words2 . addAll ( words ) ;
final String combined = lr_6 + remainder ; return lr_7 + encode ( remainder ) + lr_8 + encode ( combined ) + lr_9 ; MST[experimental.NakedReceiverMutator]MSP[S] } for ( final String l : NAME_PREFIXES . get ( this . nameType ) ) {
final String lastPart = parts [ parts . length - 1 ] ; words2 . add ( lastPart ) ; } words2 . removeAll ( NAME_PREFIXES . get ( this . nameType ) ) ; break; case ASHKENAZI : words2 . addAll ( words ) ; MST[NonVoidMethodCallMutator]MSP[S]
input = join ( words2 , lr_10 ) ; } else if ( words2 . size () == 1 ) { input = words . iterator () . next () ; MST[NonVoidMethodCallMutator]MSP[N] } else { final StringBuilder result = new StringBuilder () ;
} } } return new PhonemeBuilder ( phonemes . keySet () ) ; } public String encode ( final String input ) { final Languages . LanguageSet languageSet = this . lang . guessLanguages ( input ) ; return encode ( input , languageSet ) ; MST[ArgumentPropagationMutator]MSP[N] }
input = join ( words2 , lr_10 ) ; } else if ( words2 . size () == 1 ) { MST[rv.ROR2Mutator]MSP[N] input = words . iterator () . next () ; } else { final StringBuilder result = new StringBuilder () ;
for ( int i = 0 ; i < input . length () ; ) { MST[rv.ROR2Mutator]MSP[N] final RulesApplication rulesApplication = new RulesApplication ( rules , input , phonemeBuilder , i , maxPhonemes ) . invoke () ; i = rulesApplication . getI () ;
if ( input . startsWith ( l + lr_10 ) ) { MST[rv.ROR5Mutator]MSP[N] final String remainder = input . substring ( l . length () + 1 ) ; final String combined = l + remainder ;
if ( si . hasNext () ) { sb . append ( si . next () ) ; } while ( si . hasNext () ) { sb . append ( sep ) . append ( si . next () ) ; MST[experimental.NakedReceiverMutator]MSP[S] } return sb . toString () ; }
if ( this . nameType == NameType . GENERIC ) { if ( input . length () >= 2 && input . substring ( 0 , 2 ) . equals ( lr_5 ) ) { MST[NegateConditionalsMutator]MSP[N] final String remainder = input . substring ( 2 ) ;
new RulesApplication ( finalRules , phonemeText , subBuilder , i , maxPhonemes ) . invoke () ; final boolean found = rulesApplication . isFound () ; subBuilder = rulesApplication . getPhonemeBuilder () ; if ( ! found ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
final Map < String , List < Rule > > finalRules2 = Rule . getInstanceMap ( this . nameType , this . ruleType , languageSet ) ; input = input . toLowerCase ( Locale . ENGLISH ) . replace ( '-' , ' ' ) . trim () ; MST[rv.CRCR6Mutator]MSP[N]
if ( this . nameType == NameType . GENERIC ) { MST[rv.ROR5Mutator]MSP[N] if ( input . length () >= 2 && input . substring ( 0 , 2 ) . equals ( lr_5 ) ) { final String remainder = input . substring ( 2 ) ;
return this . nameType ; MST[NullReturnValsMutator]MSP[N] } public RuleType getRuleType () { return this . ruleType ; } public boolean isConcat () { return this . concat ; } public int getMaxPhonemes () { return this . maxPhonemes ; }
final Map < Rule . Phoneme , Rule . Phoneme > phonemes = MST[ConstructorCallMutator]MSP[N] new TreeMap <> ( Rule . Phoneme . COMPARATOR ) ; for ( final Rule . Phoneme phoneme : phonemeBuilder . getPhonemes () ) {
subBuilder . append ( phonemeText . subSequence ( i , i + 1 ) ) ; MST[rv.UOI3Mutator]MSP[N] } i = rulesApplication . getI () ; } for ( final Rule . Phoneme newPhoneme : subBuilder . getPhonemes () ) { if ( phonemes . containsKey ( newPhoneme ) ) {
return this . nameType ; } public RuleType getRuleType () { return this . ruleType ; } public boolean isConcat () { return this . concat ; } public int getMaxPhonemes () { return this . maxPhonemes ; MST[ReturnValsMutator]MSP[N] }
new RulesApplication ( finalRules , phonemeText , subBuilder , i , maxPhonemes ) . invoke () ; final boolean found = rulesApplication . isFound () ; subBuilder = rulesApplication . getPhonemeBuilder () ; if ( ! found ) { MST[rv.ROR3Mutator]MSP[N]
final Rule . Phoneme oldPhoneme = phonemes . remove ( newPhoneme ) ; final Rule . Phoneme mergedPhoneme = oldPhoneme . mergeWithLanguage ( newPhoneme . getLanguages () ) ; MST[NonVoidMethodCallMutator]MSP[N] phonemes . put ( mergedPhoneme , mergedPhoneme ) ; } else { phonemes . put ( newPhoneme , newPhoneme ) ;
final String combined = lr_6 + remainder ; MST[ConstructorCallMutator]MSP[S] return lr_7 + encode ( remainder ) + lr_8 + encode ( combined ) + lr_9 ; } for ( final String l : NAME_PREFIXES . get ( this . nameType ) ) {
return this . nameType ; } public RuleType getRuleType () { return this . ruleType ; MST[ReturnValsMutator]MSP[N] } public boolean isConcat () { return this . concat ; } public int getMaxPhonemes () { return this . maxPhonemes ; }
final String lastPart = parts [ parts . length - 1 ] ; MST[rv.AOR2Mutator]MSP[S] words2 . add ( lastPart ) ; } words2 . removeAll ( NAME_PREFIXES . get ( this . nameType ) ) ; break; case ASHKENAZI : words2 . addAll ( words ) ;
return lr_7 + encode ( remainder ) + lr_8 + encode ( combined ) + lr_9 ; MST[NonVoidMethodCallMutator]MSP[S] } } } final List < String > words = Arrays . asList ( input . split ( lr_11 ) ) ;
subBuilder . append ( phonemeText . subSequence ( i , i + 1 ) ) ; MST[rv.AOR3Mutator]MSP[N] } i = rulesApplication . getI () ; } for ( final Rule . Phoneme newPhoneme : subBuilder . getPhonemes () ) { if ( phonemes . containsKey ( newPhoneme ) ) {
PhonemeBuilder subBuilder = PhonemeBuilder . empty ( phoneme . getLanguages () ) ; final String phonemeText = phoneme . getPhonemeText () . toString () ; for ( int i = 0 ; i < phonemeText . length () ; ) { final RulesApplication rulesApplication = MST[ConstructorCallMutator]MSP[N]
final Map < String , List < Rule > > finalRules2 = Rule . getInstanceMap ( this . nameType , this . ruleType , languageSet ) ; MST[NonVoidMethodCallMutator]MSP[N] input = input . toLowerCase ( Locale . ENGLISH ) . replace ( '-' , ' ' ) . trim () ;
if ( this . nameType == NameType . GENERIC ) { if ( input . length () >= 2 && input . substring ( 0 , 2 ) . equals ( lr_5 ) ) { final String remainder = input . substring ( 2 ) ; MST[rv.CRCR4Mutator]MSP[S]
final Map < String , List < Rule > > finalRules2 = Rule . getInstanceMap ( this . nameType , this . ruleType , languageSet ) ; input = input . toLowerCase ( Locale . ENGLISH ) . replace ( '-' , ' ' ) . trim () ; MST[experimental.NakedReceiverMutator]MSP[N]
return this . nameType ; } public RuleType getRuleType () { return this . ruleType ; } public boolean isConcat () { return this . concat ; } public int getMaxPhonemes () { return this . maxPhonemes ; MST[rv.UOI4Mutator]MSP[N] }
PhonemeBuilder subBuilder = PhonemeBuilder . empty ( phoneme . getLanguages () ) ; final String phonemeText = phoneme . getPhonemeText () . toString () ; for ( int i = 0 ; i < phonemeText . length () ; ) { MST[NegateConditionalsMutator]MSP[N] final RulesApplication rulesApplication =
PhonemeBuilder subBuilder = PhonemeBuilder . empty ( phoneme . getLanguages () ) ; final String phonemeText = phoneme . getPhonemeText () . toString () ; for ( int i = 0 ; i < phonemeText . length () ; ) { MST[rv.UOI1Mutator]MSP[N] final RulesApplication rulesApplication =
if ( input . startsWith ( l + lr_10 ) ) { final String remainder = input . substring ( l . length () + 1 ) ; MST[rv.AOD2Mutator]MSP[S] final String combined = l + remainder ;
if ( si . hasNext () ) { sb . append ( si . next () ) ; } while ( si . hasNext () ) { sb . append ( sep ) . append ( si . next () ) ; } return sb . toString () ; MST[NonVoidMethodCallMutator]MSP[N] }
PhonemeBuilder subBuilder = PhonemeBuilder . empty ( phoneme . getLanguages () ) ; final String phonemeText = phoneme . getPhonemeText () . toString () ; for ( int i = 0 ; i < phonemeText . length () ; ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] final RulesApplication rulesApplication =
words2 . removeAll ( NAME_PREFIXES . get ( this . nameType ) ) ; break; case GENERIC : words2 . addAll ( words ) ; break; default: throw new IllegalStateException ( lr_13 + this . nameType ) ; } if ( this . concat ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
PhonemeBuilder subBuilder = PhonemeBuilder . empty ( phoneme . getLanguages () ) ; final String phonemeText = phoneme . getPhonemeText () . toString () ; for ( int i = 0 ; i < phonemeText . length () ; ) { MST[rv.ROR4Mutator]MSP[N] final RulesApplication rulesApplication =
final List < String > words2 = new ArrayList <> () ; switch ( this . nameType ) { MST[rv.ABSMutator]MSP[N] case SEPHARDIC : for ( final String aWord : words ) { final String [] parts = aWord . split ( lr_12 ) ;
for ( int i = 0 ; i < input . length () ; ) { final RulesApplication rulesApplication = MST[rv.ABSMutator]MSP[N] new RulesApplication ( rules , input , phonemeBuilder , i , maxPhonemes ) . invoke () ; i = rulesApplication . getI () ;
private PhonemeBuilder applyFinalRules ( final PhonemeBuilder phonemeBuilder , final Map < String , List < Rule > > finalRules ) { Objects . requireNonNull ( finalRules , lr_3 ) ; if ( finalRules . isEmpty () ) { MST[NegateConditionalsMutator]MSP[N] return phonemeBuilder ; }
final Map < String , List < Rule > > finalRules2 = Rule . getInstanceMap ( this . nameType , this . ruleType , languageSet ) ; input = input . toLowerCase ( Locale . ENGLISH ) . replace ( '-' , ' ' ) . trim () ; MST[rv.CRCR1Mutator]MSP[N]
if ( input . startsWith ( l + lr_10 ) ) { MST[NonVoidMethodCallMutator]MSP[N] final String remainder = input . substring ( l . length () + 1 ) ; final String combined = l + remainder ;
new RulesApplication ( finalRules , phonemeText , subBuilder , i , maxPhonemes ) . invoke () ; final boolean found = rulesApplication . isFound () ; subBuilder = rulesApplication . getPhonemeBuilder () ; if ( ! found ) { MST[rv.UOI4Mutator]MSP[N]
if ( input . startsWith ( l + lr_10 ) ) { MST[ConstructorCallMutator]MSP[N] final String remainder = input . substring ( l . length () + 1 ) ; final String combined = l + remainder ;
for ( int i = 0 ; i < input . length () ; ) { MST[rv.ABSMutator]MSP[N] final RulesApplication rulesApplication = new RulesApplication ( rules , input , phonemeBuilder , i , maxPhonemes ) . invoke () ; i = rulesApplication . getI () ;
final Map < String , List < Rule > > finalRules2 = Rule . getInstanceMap ( this . nameType , this . ruleType , languageSet ) ; input = input . toLowerCase ( Locale . ENGLISH ) . replace ( '-' , ' ' ) . trim () ; MST[NonVoidMethodCallMutator]MSP[N]
final Map < String , List < Rule > > finalRules2 = Rule . getInstanceMap ( this . nameType , this . ruleType , languageSet ) ; input = input . toLowerCase ( Locale . ENGLISH ) . replace ( '-' , ' ' ) . trim () ; MST[rv.CRCR6Mutator]MSP[N]
if ( si . hasNext () ) { MST[rv.ROR4Mutator]MSP[N] sb . append ( si . next () ) ; } while ( si . hasNext () ) { sb . append ( sep ) . append ( si . next () ) ; } return sb . toString () ; }
if ( this . nameType == NameType . GENERIC ) { if ( input . length () >= 2 && input . substring ( 0 , 2 ) . equals ( lr_5 ) ) { MST[InlineConstantMutator]MSP[N] final String remainder = input . substring ( 2 ) ;
words2 . removeAll ( NAME_PREFIXES . get ( this . nameType ) ) ; break; case GENERIC : words2 . addAll ( words ) ; break; default: throw new IllegalStateException ( lr_13 + this . nameType ) ; } if ( this . concat ) { MST[rv.ROR4Mutator]MSP[N]
PhonemeBuilder subBuilder = PhonemeBuilder . empty ( phoneme . getLanguages () ) ; final String phonemeText = phoneme . getPhonemeText () . toString () ; for ( int i = 0 ; i < phonemeText . length () ; ) { MST[rv.ROR2Mutator]MSP[N] final RulesApplication rulesApplication =
return lr_7 + encode ( remainder ) + lr_8 + encode ( combined ) + lr_9 ; MST[NonVoidMethodCallMutator]MSP[S] } } } final List < String > words = Arrays . asList ( input . split ( lr_11 ) ) ;
final String combined = lr_6 + remainder ; return lr_7 + encode ( remainder ) + lr_8 + encode ( combined ) + lr_9 ; MST[NonVoidMethodCallMutator]MSP[S] } for ( final String l : NAME_PREFIXES . get ( this . nameType ) ) {
if ( si . hasNext () ) { sb . append ( si . next () ) ; } while ( si . hasNext () ) { sb . append ( sep ) . append ( si . next () ) ; } return sb . toString () ; MST[EmptyObjectReturnValsMutator]MSP[N] }
for ( int i = 0 ; i < input . length () ; ) { MST[rv.CRCR5Mutator]MSP[N] final RulesApplication rulesApplication = new RulesApplication ( rules , input , phonemeBuilder , i , maxPhonemes ) . invoke () ; i = rulesApplication . getI () ;
for ( int i = 0 ; i < input . length () ; ) { MST[rv.CRCR1Mutator]MSP[N] final RulesApplication rulesApplication = new RulesApplication ( rules , input , phonemeBuilder , i , maxPhonemes ) . invoke () ; i = rulesApplication . getI () ;
if ( si . hasNext () ) { sb . append ( si . next () ) ; } while ( si . hasNext () ) { MST[NonVoidMethodCallMutator]MSP[N] sb . append ( sep ) . append ( si . next () ) ; } return sb . toString () ; }
input = join ( words2 , lr_10 ) ; } else if ( words2 . size () == 1 ) { MST[InlineConstantMutator]MSP[N] input = words . iterator () . next () ; } else { final StringBuilder result = new StringBuilder () ;
if ( input . startsWith ( l + lr_10 ) ) { final String remainder = input . substring ( l . length () + 1 ) ; MST[InlineConstantMutator]MSP[S] final String combined = l + remainder ;
final List < String > words2 = new ArrayList <> () ; MST[ConstructorCallMutator]MSP[N] switch ( this . nameType ) { case SEPHARDIC : for ( final String aWord : words ) { final String [] parts = aWord . split ( lr_12 ) ;
final Map < String , List < Rule > > finalRules2 = Rule . getInstanceMap ( this . nameType , this . ruleType , languageSet ) ; input = input . toLowerCase ( Locale . ENGLISH ) . replace ( '-' , ' ' ) . trim () ; MST[experimental.NakedReceiverMutator]MSP[N]
subBuilder . append ( phonemeText . subSequence ( i , i + 1 ) ) ; MST[rv.CRCR6Mutator]MSP[N] } i = rulesApplication . getI () ; } for ( final Rule . Phoneme newPhoneme : subBuilder . getPhonemes () ) { if ( phonemes . containsKey ( newPhoneme ) ) {
return lr_7 + encode ( remainder ) + lr_8 + encode ( combined ) + lr_9 ; MST[experimental.NakedReceiverMutator]MSP[S] } } } final List < String > words = Arrays . asList ( input . split ( lr_11 ) ) ;
return lr_7 + encode ( remainder ) + lr_8 + encode ( combined ) + lr_9 ; MST[EmptyObjectReturnValsMutator]MSP[S] } } } final List < String > words = Arrays . asList ( input . split ( lr_11 ) ) ;
subBuilder . append ( phonemeText . subSequence ( i , i + 1 ) ) ; MST[rv.AOD1Mutator]MSP[N] } i = rulesApplication . getI () ; } for ( final Rule . Phoneme newPhoneme : subBuilder . getPhonemes () ) { if ( phonemes . containsKey ( newPhoneme ) ) {
phonemeBuilder = rulesApplication . getPhonemeBuilder () ; } phonemeBuilder = applyFinalRules ( phonemeBuilder , finalRules1 ) ; phonemeBuilder = applyFinalRules ( phonemeBuilder , finalRules2 ) ; MST[ArgumentPropagationMutator]MSP[N] return phonemeBuilder . makeString () ; } public Lang getLang () { return this . lang ; } public NameType getNameType () {
PhonemeBuilder subBuilder = PhonemeBuilder . empty ( phoneme . getLanguages () ) ; final String phonemeText = phoneme . getPhonemeText () . toString () ; MST[NonVoidMethodCallMutator]MSP[N] for ( int i = 0 ; i < phonemeText . length () ; ) { final RulesApplication rulesApplication =
subBuilder . append ( phonemeText . subSequence ( i , i + 1 ) ) ; } i = rulesApplication . getI () ; } for ( final Rule . Phoneme newPhoneme : subBuilder . getPhonemes () ) { MST[NonVoidMethodCallMutator]MSP[N] if ( phonemes . containsKey ( newPhoneme ) ) {
words2 . removeAll ( NAME_PREFIXES . get ( this . nameType ) ) ; MST[NonVoidMethodCallMutator]MSP[S] break; case GENERIC : words2 . addAll ( words ) ; break; default: throw new IllegalStateException ( lr_13 + this . nameType ) ; } if ( this . concat ) {
for ( int i = 0 ; i < input . length () ; ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] final RulesApplication rulesApplication = new RulesApplication ( rules , input , phonemeBuilder , i , maxPhonemes ) . invoke () ; i = rulesApplication . getI () ;
PhonemeBuilder subBuilder = PhonemeBuilder . empty ( phoneme . getLanguages () ) ; final String phonemeText = phoneme . getPhonemeText () . toString () ; for ( int i = 0 ; i < phonemeText . length () ; ) { final RulesApplication rulesApplication = MST[rv.UOI3Mutator]MSP[N]
final String combined = lr_6 + remainder ; return lr_7 + encode ( remainder ) + lr_8 + encode ( combined ) + lr_9 ; MST[experimental.NakedReceiverMutator]MSP[S] } for ( final String l : NAME_PREFIXES . get ( this . nameType ) ) {
for ( int i = 0 ; i < input . length () ; ) { MST[NonVoidMethodCallMutator]MSP[N] final RulesApplication rulesApplication = new RulesApplication ( rules , input , phonemeBuilder , i , maxPhonemes ) . invoke () ; i = rulesApplication . getI () ;
subBuilder . append ( phonemeText . subSequence ( i , i + 1 ) ) ; MST[rv.CRCR2Mutator]MSP[N] } i = rulesApplication . getI () ; } for ( final Rule . Phoneme newPhoneme : subBuilder . getPhonemes () ) { if ( phonemes . containsKey ( newPhoneme ) ) {
final Map < String , List < Rule > > finalRules2 = Rule . getInstanceMap ( this . nameType , this . ruleType , languageSet ) ; input = input . toLowerCase ( Locale . ENGLISH ) . replace ( '-' , ' ' ) . trim () ; MST[rv.CRCR2Mutator]MSP[N]
subBuilder . append ( phonemeText . subSequence ( i , i + 1 ) ) ; } i = rulesApplication . getI () ; } for ( final Rule . Phoneme newPhoneme : subBuilder . getPhonemes () ) { if ( phonemes . containsKey ( newPhoneme ) ) { MST[NonVoidMethodCallMutator]MSP[N]
final String lastPart = parts [ parts . length - 1 ] ; words2 . add ( lastPart ) ; } words2 . removeAll ( NAME_PREFIXES . get ( this . nameType ) ) ; MST[ArgumentPropagationMutator]MSP[S] break; case ASHKENAZI : words2 . addAll ( words ) ;
final Map < String , List < Rule > > finalRules2 = Rule . getInstanceMap ( this . nameType , this . ruleType , languageSet ) ; input = input . toLowerCase ( Locale . ENGLISH ) . replace ( '-' , ' ' ) . trim () ; MST[NonVoidMethodCallMutator]MSP[N]
final String combined = lr_6 + remainder ; return lr_7 + encode ( remainder ) + lr_8 + encode ( combined ) + lr_9 ; } for ( final String l : NAME_PREFIXES . get ( this . nameType ) ) { MST[NonVoidMethodCallMutator]MSP[N]
for ( int i = 0 ; i < input . length () ; ) { final RulesApplication rulesApplication = new RulesApplication ( rules , input , phonemeBuilder , i , maxPhonemes ) . invoke () ; MST[experimental.NakedReceiverMutator]MSP[N] i = rulesApplication . getI () ;
return lr_7 + encode ( remainder ) + lr_8 + encode ( combined ) + lr_9 ; MST[NonVoidMethodCallMutator]MSP[S] } } } final List < String > words = Arrays . asList ( input . split ( lr_11 ) ) ;
new RulesApplication ( finalRules , phonemeText , subBuilder , i , maxPhonemes ) . invoke () ; final boolean found = rulesApplication . isFound () ; subBuilder = rulesApplication . getPhonemeBuilder () ; if ( ! found ) { MST[rv.ROR5Mutator]MSP[N]
final String lastPart = parts [ parts . length - 1 ] ; MST[rv.AOR1Mutator]MSP[S] words2 . add ( lastPart ) ; } words2 . removeAll ( NAME_PREFIXES . get ( this . nameType ) ) ; break; case ASHKENAZI : words2 . addAll ( words ) ;
if ( this . nameType == NameType . GENERIC ) { if ( input . length () >= 2 && input . substring ( 0 , 2 ) . equals ( lr_5 ) ) { MST[rv.CRCR6Mutator]MSP[N] final String remainder = input . substring ( 2 ) ;
subBuilder . append ( phonemeText . subSequence ( i , i + 1 ) ) ; MST[rv.UOI2Mutator]MSP[N] } i = rulesApplication . getI () ; } for ( final Rule . Phoneme newPhoneme : subBuilder . getPhonemes () ) { if ( phonemes . containsKey ( newPhoneme ) ) {
final Rule . Phoneme oldPhoneme = phonemes . remove ( newPhoneme ) ; final Rule . Phoneme mergedPhoneme = oldPhoneme . mergeWithLanguage ( newPhoneme . getLanguages () ) ; phonemes . put ( mergedPhoneme , mergedPhoneme ) ; } else { phonemes . put ( newPhoneme , newPhoneme ) ; MST[NonVoidMethodCallMutator]MSP[N]
if ( this . nameType == NameType . GENERIC ) { if ( input . length () >= 2 && input . substring ( 0 , 2 ) . equals ( lr_5 ) ) { final String remainder = input . substring ( 2 ) ; MST[rv.CRCR5Mutator]MSP[S]
return lr_7 + encode ( remainder ) + lr_8 + encode ( combined ) + lr_9 ; MST[ConstructorCallMutator]MSP[S] } } } final List < String > words = Arrays . asList ( input . split ( lr_11 ) ) ;
new RulesApplication ( finalRules , phonemeText , subBuilder , i , maxPhonemes ) . invoke () ; final boolean found = rulesApplication . isFound () ; subBuilder = rulesApplication . getPhonemeBuilder () ; if ( ! found ) { MST[rv.ROR1Mutator]MSP[N]
subBuilder . append ( phonemeText . subSequence ( i , i + 1 ) ) ; MST[rv.ABSMutator]MSP[N] } i = rulesApplication . getI () ; } for ( final Rule . Phoneme newPhoneme : subBuilder . getPhonemes () ) { if ( phonemes . containsKey ( newPhoneme ) ) {
} } } return new PhonemeBuilder ( phonemes . keySet () ) ; MST[NonVoidMethodCallMutator]MSP[N] } public String encode ( final String input ) { final Languages . LanguageSet languageSet = this . lang . guessLanguages ( input ) ; return encode ( input , languageSet ) ; }
if ( input . startsWith ( l + lr_10 ) ) { MST[rv.ROR2Mutator]MSP[N] final String remainder = input . substring ( l . length () + 1 ) ; final String combined = l + remainder ;
input = join ( words2 , lr_10 ) ; } else if ( words2 . size () == 1 ) { MST[rv.ROR3Mutator]MSP[N] input = words . iterator () . next () ; } else { final StringBuilder result = new StringBuilder () ;
final String lastPart = parts [ parts . length - 1 ] ; MST[rv.CRCR4Mutator]MSP[S] words2 . add ( lastPart ) ; } words2 . removeAll ( NAME_PREFIXES . get ( this . nameType ) ) ; break; case ASHKENAZI : words2 . addAll ( words ) ;
if ( input . startsWith ( l + lr_10 ) ) { final String remainder = input . substring ( l . length () + 1 ) ; MST[rv.AOR3Mutator]MSP[S] final String combined = l + remainder ;
for ( int i = 0 ; i < input . length () ; ) { MST[rv.ROR3Mutator]MSP[N] final RulesApplication rulesApplication = new RulesApplication ( rules , input , phonemeBuilder , i , maxPhonemes ) . invoke () ; i = rulesApplication . getI () ;
private PhonemeBuilder applyFinalRules ( final PhonemeBuilder phonemeBuilder , final Map < String , List < Rule > > finalRules ) { Objects . requireNonNull ( finalRules , lr_3 ) ; if ( finalRules . isEmpty () ) { MST[rv.ROR2Mutator]MSP[N] return phonemeBuilder ; }
final Map < String , List < Rule > > finalRules2 = Rule . getInstanceMap ( this . nameType , this . ruleType , languageSet ) ; input = input . toLowerCase ( Locale . ENGLISH ) . replace ( '-' , ' ' ) . trim () ; MST[InlineConstantMutator]MSP[N]
for ( int i = 0 ; i < input . length () ; ) { final RulesApplication rulesApplication = MST[rv.UOI4Mutator]MSP[N] new RulesApplication ( rules , input , phonemeBuilder , i , maxPhonemes ) . invoke () ; i = rulesApplication . getI () ;
input = join ( words2 , lr_10 ) ; } else if ( words2 . size () == 1 ) { MST[rv.ROR4Mutator]MSP[N] input = words . iterator () . next () ; } else { final StringBuilder result = new StringBuilder () ;
if ( this . nameType == NameType . GENERIC ) { if ( input . length () >= 2 && input . substring ( 0 , 2 ) . equals ( lr_5 ) ) { MST[rv.ROR5Mutator]MSP[N] final String remainder = input . substring ( 2 ) ;
new RulesApplication ( finalRules , phonemeText , subBuilder , i , maxPhonemes ) . invoke () ; final boolean found = rulesApplication . isFound () ; subBuilder = rulesApplication . getPhonemeBuilder () ; if ( ! found ) { MST[NegateConditionalsMutator]MSP[N]
final String combined = lr_6 + remainder ; return lr_7 + encode ( remainder ) + lr_8 + encode ( combined ) + lr_9 ; MST[NonVoidMethodCallMutator]MSP[S] } for ( final String l : NAME_PREFIXES . get ( this . nameType ) ) {
if ( si . hasNext () ) { sb . append ( si . next () ) ; } while ( si . hasNext () ) { MST[rv.ROR3Mutator]MSP[N] sb . append ( sep ) . append ( si . next () ) ; } return sb . toString () ; }
subBuilder . append ( phonemeText . subSequence ( i , i + 1 ) ) ; MST[rv.UOI1Mutator]MSP[N] } i = rulesApplication . getI () ; } for ( final Rule . Phoneme newPhoneme : subBuilder . getPhonemes () ) { if ( phonemes . containsKey ( newPhoneme ) ) {
if ( this . nameType == NameType . GENERIC ) { if ( input . length () >= 2 && input . substring ( 0 , 2 ) . equals ( lr_5 ) ) { MST[rv.CRCR3Mutator]MSP[N] final String remainder = input . substring ( 2 ) ;
input = join ( words2 , lr_10 ) ; } else if ( words2 . size () == 1 ) { MST[rv.CRCR2Mutator]MSP[N] input = words . iterator () . next () ; } else { final StringBuilder result = new StringBuilder () ;
if ( this . nameType == NameType . GENERIC ) { MST[NegateConditionalsMutator]MSP[N] if ( input . length () >= 2 && input . substring ( 0 , 2 ) . equals ( lr_5 ) ) { final String remainder = input . substring ( 2 ) ;
input = join ( words2 , lr_10 ) ; } else if ( words2 . size () == 1 ) { MST[rv.CRCR3Mutator]MSP[N] input = words . iterator () . next () ; } else { final StringBuilder result = new StringBuilder () ;
final String combined = lr_6 + remainder ; MST[NonVoidMethodCallMutator]MSP[S] return lr_7 + encode ( remainder ) + lr_8 + encode ( combined ) + lr_9 ; } for ( final String l : NAME_PREFIXES . get ( this . nameType ) ) {
return lr_7 + encode ( remainder ) + lr_8 + encode ( combined ) + lr_9 ; MST[experimental.NakedReceiverMutator]MSP[S] } } } final List < String > words = Arrays . asList ( input . split ( lr_11 ) ) ;
if ( input . startsWith ( l + lr_10 ) ) { final String remainder = input . substring ( l . length () + 1 ) ; MST[rv.CRCR2Mutator]MSP[S] final String combined = l + remainder ;
if ( this . nameType == NameType . GENERIC ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] if ( input . length () >= 2 && input . substring ( 0 , 2 ) . equals ( lr_5 ) ) { final String remainder = input . substring ( 2 ) ;
if ( this . nameType == NameType . GENERIC ) { if ( input . length () >= 2 && input . substring ( 0 , 2 ) . equals ( lr_5 ) ) { MST[rv.CRCR2Mutator]MSP[N] final String remainder = input . substring ( 2 ) ;
subBuilder . append ( phonemeText . subSequence ( i , i + 1 ) ) ; MST[rv.ABSMutator]MSP[N] } i = rulesApplication . getI () ; } for ( final Rule . Phoneme newPhoneme : subBuilder . getPhonemes () ) { if ( phonemes . containsKey ( newPhoneme ) ) {
} } } return new PhonemeBuilder ( phonemes . keySet () ) ; MST[ConstructorCallMutator]MSP[N] } public String encode ( final String input ) { final Languages . LanguageSet languageSet = this . lang . guessLanguages ( input ) ; return encode ( input , languageSet ) ; }
if ( input . startsWith ( l + lr_10 ) ) { final String remainder = input . substring ( l . length () + 1 ) ; MST[NonVoidMethodCallMutator]MSP[S] final String combined = l + remainder ;
phonemeBuilder = rulesApplication . getPhonemeBuilder () ; } phonemeBuilder = applyFinalRules ( phonemeBuilder , finalRules1 ) ; phonemeBuilder = applyFinalRules ( phonemeBuilder , finalRules2 ) ; return phonemeBuilder . makeString () ; MST[EmptyObjectReturnValsMutator]MSP[N] } public Lang getLang () { return this . lang ; } public NameType getNameType () {
if ( si . hasNext () ) { sb . append ( si . next () ) ; } while ( si . hasNext () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] sb . append ( sep ) . append ( si . next () ) ; } return sb . toString () ; }
if ( this . nameType == NameType . GENERIC ) { if ( input . length () >= 2 && input . substring ( 0 , 2 ) . equals ( lr_5 ) ) { MST[NonVoidMethodCallMutator]MSP[N] final String remainder = input . substring ( 2 ) ;
subBuilder . append ( phonemeText . subSequence ( i , i + 1 ) ) ; } i = rulesApplication . getI () ; } for ( final Rule . Phoneme newPhoneme : subBuilder . getPhonemes () ) { if ( phonemes . containsKey ( newPhoneme ) ) { MST[rv.ROR4Mutator]MSP[N]
if ( input . startsWith ( l + lr_10 ) ) { final String remainder = input . substring ( l . length () + 1 ) ; MST[rv.AOD1Mutator]MSP[S] final String combined = l + remainder ;
return this . nameType ; } public RuleType getRuleType () { return this . ruleType ; } public boolean isConcat () { return this . concat ; } public int getMaxPhonemes () { return this . maxPhonemes ; MST[rv.UOI3Mutator]MSP[N] }
for ( int i = 0 ; i < input . length () ; ) { MST[rv.ROR4Mutator]MSP[N] final RulesApplication rulesApplication = new RulesApplication ( rules , input , phonemeBuilder , i , maxPhonemes ) . invoke () ; i = rulesApplication . getI () ;
if ( input . startsWith ( l + lr_10 ) ) { MST[rv.ROR1Mutator]MSP[N] final String remainder = input . substring ( l . length () + 1 ) ; final String combined = l + remainder ;
input = join ( words2 , lr_10 ) ; MST[ArgumentPropagationMutator]MSP[N] } else if ( words2 . size () == 1 ) { input = words . iterator () . next () ; } else { final StringBuilder result = new StringBuilder () ;
for ( int i = 0 ; i < input . length () ; ) { MST[rv.UOI1Mutator]MSP[N] final RulesApplication rulesApplication = new RulesApplication ( rules , input , phonemeBuilder , i , maxPhonemes ) . invoke () ; i = rulesApplication . getI () ;
public boolean isFound () { return this . found ; } private static String join ( final Iterable < String > strings , final String sep ) { final StringBuilder sb = new StringBuilder () ; final Iterator < String > si = strings . iterator () ; MST[NonVoidMethodCallMutator]MSP[N]
subBuilder . append ( phonemeText . subSequence ( i , i + 1 ) ) ; MST[InlineConstantMutator]MSP[N] } i = rulesApplication . getI () ; } for ( final Rule . Phoneme newPhoneme : subBuilder . getPhonemes () ) { if ( phonemes . containsKey ( newPhoneme ) ) {
final String combined = lr_6 + remainder ; return lr_7 + encode ( remainder ) + lr_8 + encode ( combined ) + lr_9 ; MST[ReturnValsMutator]MSP[S] } for ( final String l : NAME_PREFIXES . get ( this . nameType ) ) {
if ( this . nameType == NameType . GENERIC ) { if ( input . length () >= 2 && input . substring ( 0 , 2 ) . equals ( lr_5 ) ) { MST[InlineConstantMutator]MSP[N] final String remainder = input . substring ( 2 ) ;
if ( this . nameType == NameType . GENERIC ) { if ( input . length () >= 2 && input . substring ( 0 , 2 ) . equals ( lr_5 ) ) { MST[rv.ROR3Mutator]MSP[N] final String remainder = input . substring ( 2 ) ;
final String combined = lr_6 + remainder ; return lr_7 + encode ( remainder ) + lr_8 + encode ( combined ) + lr_9 ; MST[experimental.NakedReceiverMutator]MSP[S] } for ( final String l : NAME_PREFIXES . get ( this . nameType ) ) {
phonemeBuilder = rulesApplication . getPhonemeBuilder () ; } phonemeBuilder = applyFinalRules ( phonemeBuilder , finalRules1 ) ; MST[NonVoidMethodCallMutator]MSP[N] phonemeBuilder = applyFinalRules ( phonemeBuilder , finalRules2 ) ; return phonemeBuilder . makeString () ; } public Lang getLang () { return this . lang ; } public NameType getNameType () {
return lr_7 + encode ( remainder ) + lr_8 + encode ( combined ) + lr_9 ; MST[ArgumentPropagationMutator]MSP[S] } } } final List < String > words = Arrays . asList ( input . split ( lr_11 ) ) ;
if ( this . nameType == NameType . GENERIC ) { if ( input . length () >= 2 && input . substring ( 0 , 2 ) . equals ( lr_5 ) ) { MST[rv.CRCR3Mutator]MSP[N] final String remainder = input . substring ( 2 ) ;
subBuilder . append ( phonemeText . subSequence ( i , i + 1 ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } i = rulesApplication . getI () ; } for ( final Rule . Phoneme newPhoneme : subBuilder . getPhonemes () ) { if ( phonemes . containsKey ( newPhoneme ) ) {
private PhonemeBuilder applyFinalRules ( final PhonemeBuilder phonemeBuilder , final Map < String , List < Rule > > finalRules ) { Objects . requireNonNull ( finalRules , lr_3 ) ; if ( finalRules . isEmpty () ) { return phonemeBuilder ; MST[ReturnValsMutator]MSP[S] }
PhonemeBuilder subBuilder = PhonemeBuilder . empty ( phoneme . getLanguages () ) ; final String phonemeText = phoneme . getPhonemeText () . toString () ; MST[NonVoidMethodCallMutator]MSP[N] for ( int i = 0 ; i < phonemeText . length () ; ) { final RulesApplication rulesApplication =
PhonemeBuilder subBuilder = PhonemeBuilder . empty ( phoneme . getLanguages () ) ; final String phonemeText = phoneme . getPhonemeText () . toString () ; for ( int i = 0 ; i < phonemeText . length () ; ) { final RulesApplication rulesApplication = MST[rv.UOI4Mutator]MSP[N]
subBuilder . append ( phonemeText . subSequence ( i , i + 1 ) ) ; MST[rv.CRCR3Mutator]MSP[N] } i = rulesApplication . getI () ; } for ( final Rule . Phoneme newPhoneme : subBuilder . getPhonemes () ) { if ( phonemes . containsKey ( newPhoneme ) ) {
final Map < String , List < Rule > > finalRules2 = Rule . getInstanceMap ( this . nameType , this . ruleType , languageSet ) ; input = input . toLowerCase ( Locale . ENGLISH ) . replace ( '-' , ' ' ) . trim () ; MST[rv.CRCR2Mutator]MSP[N]
if ( si . hasNext () ) { MST[NegateConditionalsMutator]MSP[N] sb . append ( si . next () ) ; } while ( si . hasNext () ) { sb . append ( sep ) . append ( si . next () ) ; } return sb . toString () ; }
final Map < String , List < Rule > > finalRules2 = Rule . getInstanceMap ( this . nameType , this . ruleType , languageSet ) ; input = input . toLowerCase ( Locale . ENGLISH ) . replace ( '-' , ' ' ) . trim () ; MST[experimental.NakedReceiverMutator]MSP[N]
words2 . removeAll ( NAME_PREFIXES . get ( this . nameType ) ) ; break; case GENERIC : words2 . addAll ( words ) ; break; default: throw new IllegalStateException ( lr_13 + this . nameType ) ; } if ( this . concat ) { MST[rv.ROR1Mutator]MSP[N]
if ( si . hasNext () ) { MST[rv.ROR3Mutator]MSP[N] sb . append ( si . next () ) ; } while ( si . hasNext () ) { sb . append ( sep ) . append ( si . next () ) ; } return sb . toString () ; }
final Map < String , List < Rule > > finalRules2 = Rule . getInstanceMap ( this . nameType , this . ruleType , languageSet ) ; input = input . toLowerCase ( Locale . ENGLISH ) . replace ( '-' , ' ' ) . trim () ; MST[rv.CRCR3Mutator]MSP[N]
if ( input . startsWith ( l + lr_10 ) ) { MST[NegateConditionalsMutator]MSP[N] final String remainder = input . substring ( l . length () + 1 ) ; final String combined = l + remainder ;
return this . nameType ; } public RuleType getRuleType () { return this . ruleType ; } public boolean isConcat () { return this . concat ; MST[BooleanTrueReturnValsMutator]MSP[N] } public int getMaxPhonemes () { return this . maxPhonemes ; }
if ( input . startsWith ( l + lr_10 ) ) { final String remainder = input . substring ( l . length () + 1 ) ; MST[MathMutator]MSP[S] final String combined = l + remainder ;
PhonemeBuilder subBuilder = PhonemeBuilder . empty ( phoneme . getLanguages () ) ; final String phonemeText = phoneme . getPhonemeText () . toString () ; for ( int i = 0 ; i < phonemeText . length () ; ) { MST[rv.ROR1Mutator]MSP[N] final RulesApplication rulesApplication =
if ( this . nameType == NameType . GENERIC ) { if ( input . length () >= 2 && input . substring ( 0 , 2 ) . equals ( lr_5 ) ) { MST[NonVoidMethodCallMutator]MSP[N] final String remainder = input . substring ( 2 ) ;
words2 . removeAll ( NAME_PREFIXES . get ( this . nameType ) ) ; break; case GENERIC : words2 . addAll ( words ) ; break; default: throw new IllegalStateException ( lr_13 + this . nameType ) ; } if ( this . concat ) { MST[rv.ROR5Mutator]MSP[N]
if ( input . startsWith ( l + lr_10 ) ) { final String remainder = input . substring ( l . length () + 1 ) ; final String combined = l + remainder ; MST[experimental.NakedReceiverMutator]MSP[S]
new RulesApplication ( finalRules , phonemeText , subBuilder , i , maxPhonemes ) . invoke () ; final boolean found = rulesApplication . isFound () ; subBuilder = rulesApplication . getPhonemeBuilder () ; if ( ! found ) { MST[rv.UOI3Mutator]MSP[N]
final String lastPart = parts [ parts . length - 1 ] ; MST[rv.AOD2Mutator]MSP[S] words2 . add ( lastPart ) ; } words2 . removeAll ( NAME_PREFIXES . get ( this . nameType ) ) ; break; case ASHKENAZI : words2 . addAll ( words ) ;
if ( si . hasNext () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] sb . append ( si . next () ) ; } while ( si . hasNext () ) { sb . append ( sep ) . append ( si . next () ) ; } return sb . toString () ; }
if ( this . nameType == NameType . GENERIC ) { if ( input . length () >= 2 && input . substring ( 0 , 2 ) . equals ( lr_5 ) ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] final String remainder = input . substring ( 2 ) ;
return this . nameType ; } public RuleType getRuleType () { return this . ruleType ; } public boolean isConcat () { return this . concat ; MST[ReturnValsMutator]MSP[N] } public int getMaxPhonemes () { return this . maxPhonemes ; }
final Rule . Phoneme oldPhoneme = phonemes . remove ( newPhoneme ) ; final Rule . Phoneme mergedPhoneme = oldPhoneme . mergeWithLanguage ( newPhoneme . getLanguages () ) ; phonemes . put ( mergedPhoneme , mergedPhoneme ) ; MST[NonVoidMethodCallMutator]MSP[N] } else { phonemes . put ( newPhoneme , newPhoneme ) ;
final String combined = lr_6 + remainder ; return lr_7 + encode ( remainder ) + lr_8 + encode ( combined ) + lr_9 ; MST[NonVoidMethodCallMutator]MSP[S] } for ( final String l : NAME_PREFIXES . get ( this . nameType ) ) {
if ( input . startsWith ( l + lr_10 ) ) { final String remainder = input . substring ( l . length () + 1 ) ; final String combined = l + remainder ; MST[NonVoidMethodCallMutator]MSP[S]
for ( int i = 0 ; i < input . length () ; ) { MST[rv.CRCR6Mutator]MSP[N] final RulesApplication rulesApplication = new RulesApplication ( rules , input , phonemeBuilder , i , maxPhonemes ) . invoke () ; i = rulesApplication . getI () ;
private PhonemeBuilder applyFinalRules ( final PhonemeBuilder phonemeBuilder , final Map < String , List < Rule > > finalRules ) { Objects . requireNonNull ( finalRules , lr_3 ) ; if ( finalRules . isEmpty () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return phonemeBuilder ; }
if ( input . startsWith ( l + lr_10 ) ) { final String remainder = input . substring ( l . length () + 1 ) ; final String combined = l + remainder ; MST[ConstructorCallMutator]MSP[S]
final List < String > words2 = new ArrayList <> () ; switch ( this . nameType ) { MST[experimental.RemoveSwitchMutator_2]MSP[N] case SEPHARDIC : for ( final String aWord : words ) { final String [] parts = aWord . split ( lr_12 ) ;
final List < String > words2 = new ArrayList <> () ; switch ( this . nameType ) { MST[experimental.RemoveSwitchMutator_0]MSP[N] case SEPHARDIC : for ( final String aWord : words ) { final String [] parts = aWord . split ( lr_12 ) ;
final List < String > words2 = new ArrayList <> () ; switch ( this . nameType ) { MST[experimental.RemoveSwitchMutator_1]MSP[N] case SEPHARDIC : for ( final String aWord : words ) { final String [] parts = aWord . split ( lr_12 ) ;
} } } return new PhonemeBuilder ( phonemes . keySet () ) ; } public String encode ( final String input ) { final Languages . LanguageSet languageSet = this . lang . guessLanguages ( input ) ; return encode ( input , languageSet ) ; MST[NonVoidMethodCallMutator]MSP[N] }
if ( input . startsWith ( l + lr_10 ) ) { final String remainder = input . substring ( l . length () + 1 ) ; MST[rv.AOR2Mutator]MSP[S] final String combined = l + remainder ;
final String lastPart = parts [ parts . length - 1 ] ; MST[rv.CRCR5Mutator]MSP[S] words2 . add ( lastPart ) ; } words2 . removeAll ( NAME_PREFIXES . get ( this . nameType ) ) ; break; case ASHKENAZI : words2 . addAll ( words ) ;
for ( int i = 0 ; i < input . length () ; ) { MST[rv.UOI3Mutator]MSP[N] final RulesApplication rulesApplication = new RulesApplication ( rules , input , phonemeBuilder , i , maxPhonemes ) . invoke () ; i = rulesApplication . getI () ;
return lr_7 + encode ( remainder ) + lr_8 + encode ( combined ) + lr_9 ; } } } final List < String > words = Arrays . asList ( input . split ( lr_11 ) ) ; MST[NonVoidMethodCallMutator]MSP[N]
for ( int i = 0 ; i < input . length () ; ) { final RulesApplication rulesApplication = MST[rv.UOI2Mutator]MSP[N] new RulesApplication ( rules , input , phonemeBuilder , i , maxPhonemes ) . invoke () ; i = rulesApplication . getI () ;
final String lastPart = parts [ parts . length - 1 ] ; words2 . add ( lastPart ) ; } words2 . removeAll ( NAME_PREFIXES . get ( this . nameType ) ) ; MST[NonVoidMethodCallMutator]MSP[S] break; case ASHKENAZI : words2 . addAll ( words ) ;
private PhonemeBuilder applyFinalRules ( final PhonemeBuilder phonemeBuilder , final Map < String , List < Rule > > finalRules ) { Objects . requireNonNull ( finalRules , lr_3 ) ; if ( finalRules . isEmpty () ) { MST[rv.ROR1Mutator]MSP[N] return phonemeBuilder ; }
final List < String > words2 = new ArrayList <> () ; switch ( this . nameType ) { MST[rv.UOI2Mutator]MSP[N] case SEPHARDIC : for ( final String aWord : words ) { final String [] parts = aWord . split ( lr_12 ) ;
if ( this . nameType == NameType . GENERIC ) { if ( input . length () >= 2 && input . substring ( 0 , 2 ) . equals ( lr_5 ) ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] final String remainder = input . substring ( 2 ) ;
if ( input . startsWith ( l + lr_10 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] final String remainder = input . substring ( l . length () + 1 ) ; final String combined = l + remainder ;
final Map < String , List < Rule > > finalRules2 = Rule . getInstanceMap ( this . nameType , this . ruleType , languageSet ) ; input = input . toLowerCase ( Locale . ENGLISH ) . replace ( '-' , ' ' ) . trim () ; MST[rv.CRCR3Mutator]MSP[N]
final Map < String , List < Rule > > finalRules2 = Rule . getInstanceMap ( this . nameType , this . ruleType , languageSet ) ; input = input . toLowerCase ( Locale . ENGLISH ) . replace ( '-' , ' ' ) . trim () ; MST[NonVoidMethodCallMutator]MSP[N]
return lr_7 + encode ( remainder ) + lr_8 + encode ( combined ) + lr_9 ; MST[NonVoidMethodCallMutator]MSP[S] } } } final List < String > words = Arrays . asList ( input . split ( lr_11 ) ) ;
final String combined = lr_6 + remainder ; return lr_7 + encode ( remainder ) + lr_8 + encode ( combined ) + lr_9 ; MST[ArgumentPropagationMutator]MSP[S] } for ( final String l : NAME_PREFIXES . get ( this . nameType ) ) {
new RulesApplication ( finalRules , phonemeText , subBuilder , i , maxPhonemes ) . invoke () ; final boolean found = rulesApplication . isFound () ; subBuilder = rulesApplication . getPhonemeBuilder () ; MST[NonVoidMethodCallMutator]MSP[N] if ( ! found ) {
subBuilder . append ( phonemeText . subSequence ( i , i + 1 ) ) ; MST[rv.UOI1Mutator]MSP[N] } i = rulesApplication . getI () ; } for ( final Rule . Phoneme newPhoneme : subBuilder . getPhonemes () ) { if ( phonemes . containsKey ( newPhoneme ) ) {
final Rule . Phoneme oldPhoneme = phonemes . remove ( newPhoneme ) ; final Rule . Phoneme mergedPhoneme = oldPhoneme . mergeWithLanguage ( newPhoneme . getLanguages () ) ; MST[experimental.NakedReceiverMutator]MSP[N] phonemes . put ( mergedPhoneme , mergedPhoneme ) ; } else { phonemes . put ( newPhoneme , newPhoneme ) ;
if ( this . nameType == NameType . GENERIC ) { if ( input . length () >= 2 && input . substring ( 0 , 2 ) . equals ( lr_5 ) ) { final String remainder = input . substring ( 2 ) ; MST[rv.CRCR6Mutator]MSP[S]
final String lastPart = parts [ parts . length - 1 ] ; MST[rv.AOR4Mutator]MSP[S] words2 . add ( lastPart ) ; } words2 . removeAll ( NAME_PREFIXES . get ( this . nameType ) ) ; break; case ASHKENAZI : words2 . addAll ( words ) ;
subBuilder . append ( phonemeText . subSequence ( i , i + 1 ) ) ; MST[VoidMethodCallMutator]MSP[N] } i = rulesApplication . getI () ; } for ( final Rule . Phoneme newPhoneme : subBuilder . getPhonemes () ) { if ( phonemes . containsKey ( newPhoneme ) ) {
PhonemeBuilder subBuilder = PhonemeBuilder . empty ( phoneme . getLanguages () ) ; final String phonemeText = phoneme . getPhonemeText () . toString () ; for ( int i = 0 ; i < phonemeText . length () ; ) { MST[InlineConstantMutator]MSP[N] final RulesApplication rulesApplication =
input = join ( words2 , lr_10 ) ; } else if ( words2 . size () == 1 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] input = words . iterator () . next () ; } else { final StringBuilder result = new StringBuilder () ;
if ( input . startsWith ( l + lr_10 ) ) { final String remainder = input . substring ( l . length () + 1 ) ; MST[rv.CRCR3Mutator]MSP[S] final String combined = l + remainder ;
subBuilder . append ( phonemeText . subSequence ( i , i + 1 ) ) ; MST[rv.AOD2Mutator]MSP[N] } i = rulesApplication . getI () ; } for ( final Rule . Phoneme newPhoneme : subBuilder . getPhonemes () ) { if ( phonemes . containsKey ( newPhoneme ) ) {
PhonemeBuilder subBuilder = PhonemeBuilder . empty ( phoneme . getLanguages () ) ; final String phonemeText = phoneme . getPhonemeText () . toString () ; for ( int i = 0 ; i < phonemeText . length () ; ) { MST[rv.UOI3Mutator]MSP[N] final RulesApplication rulesApplication =
return lr_7 + encode ( remainder ) + lr_8 + encode ( combined ) + lr_9 ; } } } final List < String > words = Arrays . asList ( input . split ( lr_11 ) ) ; MST[NonVoidMethodCallMutator]MSP[N]
for ( int i = 0 ; i < input . length () ; ) { final RulesApplication rulesApplication = MST[rv.UOI1Mutator]MSP[N] new RulesApplication ( rules , input , phonemeBuilder , i , maxPhonemes ) . invoke () ; i = rulesApplication . getI () ;
for ( int i = 0 ; i < input . length () ; ) { MST[rv.ROR5Mutator]MSP[N] final RulesApplication rulesApplication = new RulesApplication ( rules , input , phonemeBuilder , i , maxPhonemes ) . invoke () ; i = rulesApplication . getI () ;
input = join ( words2 , lr_10 ) ; } else if ( words2 . size () == 1 ) { MST[rv.ROR5Mutator]MSP[N] input = words . iterator () . next () ; } else { final StringBuilder result = new StringBuilder () ;
for ( int i = 0 ; i < input . length () ; ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] final RulesApplication rulesApplication = new RulesApplication ( rules , input , phonemeBuilder , i , maxPhonemes ) . invoke () ; i = rulesApplication . getI () ;
for ( int i = 0 ; i < input . length () ; ) { MST[ConditionalsBoundaryMutator]MSP[N] final RulesApplication rulesApplication = new RulesApplication ( rules , input , phonemeBuilder , i , maxPhonemes ) . invoke () ; i = rulesApplication . getI () ;
return lr_7 + encode ( remainder ) + lr_8 + encode ( combined ) + lr_9 ; MST[NonVoidMethodCallMutator]MSP[S] } } } final List < String > words = Arrays . asList ( input . split ( lr_11 ) ) ;
PhonemeBuilder subBuilder = PhonemeBuilder . empty ( phoneme . getLanguages () ) ; final String phonemeText = phoneme . getPhonemeText () . toString () ; for ( int i = 0 ; i < phonemeText . length () ; ) { MST[rv.CRCR3Mutator]MSP[N] final RulesApplication rulesApplication =
final String lastPart = parts [ parts . length - 1 ] ; words2 . add ( lastPart ) ; MST[NonVoidMethodCallMutator]MSP[S] } words2 . removeAll ( NAME_PREFIXES . get ( this . nameType ) ) ; break; case ASHKENAZI : words2 . addAll ( words ) ;
if ( input . startsWith ( l + lr_10 ) ) { final String remainder = input . substring ( l . length () + 1 ) ; final String combined = l + remainder ; MST[experimental.NakedReceiverMutator]MSP[S]
PhonemeBuilder subBuilder = PhonemeBuilder . empty ( phoneme . getLanguages () ) ; final String phonemeText = phoneme . getPhonemeText () . toString () ; for ( int i = 0 ; i < phonemeText . length () ; ) { MST[rv.ABSMutator]MSP[N] final RulesApplication rulesApplication =
if ( si . hasNext () ) { sb . append ( si . next () ) ; } while ( si . hasNext () ) { MST[rv.ROR2Mutator]MSP[N] sb . append ( sep ) . append ( si . next () ) ; } return sb . toString () ; }
if ( si . hasNext () ) { sb . append ( si . next () ) ; MST[NonVoidMethodCallMutator]MSP[N] } while ( si . hasNext () ) { sb . append ( sep ) . append ( si . next () ) ; } return sb . toString () ; }
final Map < String , List < Rule > > finalRules1 = Rule . getInstanceMap ( this . nameType , this . ruleType , lr_4 ) ; MST[NonVoidMethodCallMutator]MSP[N]
if ( this . nameType == NameType . GENERIC ) { if ( input . length () >= 2 && input . substring ( 0 , 2 ) . equals ( lr_5 ) ) { final String remainder = input . substring ( 2 ) ; MST[experimental.NakedReceiverMutator]MSP[S]
input = join ( words2 , lr_10 ) ; } else if ( words2 . size () == 1 ) { MST[rv.CRCR4Mutator]MSP[N] input = words . iterator () . next () ; } else { final StringBuilder result = new StringBuilder () ;
if ( this . nameType == NameType . GENERIC ) { if ( input . length () >= 2 && input . substring ( 0 , 2 ) . equals ( lr_5 ) ) { final String remainder = input . substring ( 2 ) ; MST[rv.CRCR2Mutator]MSP[S]
if ( this . nameType == NameType . GENERIC ) { if ( input . length () >= 2 && input . substring ( 0 , 2 ) . equals ( lr_5 ) ) { final String remainder = input . substring ( 2 ) ; MST[rv.CRCR1Mutator]MSP[S]
if ( input . startsWith ( l + lr_10 ) ) { final String remainder = input . substring ( l . length () + 1 ) ; MST[rv.CRCR4Mutator]MSP[S] final String combined = l + remainder ;
if ( si . hasNext () ) { sb . append ( si . next () ) ; } while ( si . hasNext () ) { sb . append ( sep ) . append ( si . next () ) ; MST[NonVoidMethodCallMutator]MSP[S] } return sb . toString () ; }
words2 . removeAll ( NAME_PREFIXES . get ( this . nameType ) ) ; MST[NonVoidMethodCallMutator]MSP[S] break; case GENERIC : words2 . addAll ( words ) ; break; default: throw new IllegalStateException ( lr_13 + this . nameType ) ; } if ( this . concat ) {
PhonemeBuilder subBuilder = PhonemeBuilder . empty ( phoneme . getLanguages () ) ; final String phonemeText = phoneme . getPhonemeText () . toString () ; for ( int i = 0 ; i < phonemeText . length () ; ) { MST[rv.UOI4Mutator]MSP[N] final RulesApplication rulesApplication =
PhonemeBuilder subBuilder = PhonemeBuilder . empty ( phoneme . getLanguages () ) ; final String phonemeText = phoneme . getPhonemeText () . toString () ; for ( int i = 0 ; i < phonemeText . length () ; ) { final RulesApplication rulesApplication = MST[rv.UOI3Mutator]MSP[N]
if ( input . startsWith ( l + lr_10 ) ) { MST[rv.ROR3Mutator]MSP[N] final String remainder = input . substring ( l . length () + 1 ) ; final String combined = l + remainder ;
return this . nameType ; } public RuleType getRuleType () { return this . ruleType ; } public boolean isConcat () { return this . concat ; } public int getMaxPhonemes () { return this . maxPhonemes ; MST[rv.UOI1Mutator]MSP[N] }
final Map < String , List < Rule > > finalRules2 = Rule . getInstanceMap ( this . nameType , this . ruleType , languageSet ) ; input = input . toLowerCase ( Locale . ENGLISH ) . replace ( '-' , ' ' ) . trim () ; MST[InlineConstantMutator]MSP[N]
return lr_7 + encode ( remainder ) + lr_8 + encode ( combined ) + lr_9 ; MST[experimental.NakedReceiverMutator]MSP[S] } } } final List < String > words = Arrays . asList ( input . split ( lr_11 ) ) ;
private PhonemeBuilder applyFinalRules ( final PhonemeBuilder phonemeBuilder , final Map < String , List < Rule > > finalRules ) { Objects . requireNonNull ( finalRules , lr_3 ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( finalRules . isEmpty () ) { return phonemeBuilder ; }
phonemeBuilder = rulesApplication . getPhonemeBuilder () ; } phonemeBuilder = applyFinalRules ( phonemeBuilder , finalRules1 ) ; phonemeBuilder = applyFinalRules ( phonemeBuilder , finalRules2 ) ; return phonemeBuilder . makeString () ; MST[NonVoidMethodCallMutator]MSP[N] } public Lang getLang () { return this . lang ; } public NameType getNameType () {
for ( int i = 0 ; i < input . length () ; ) { MST[rv.UOI2Mutator]MSP[N] final RulesApplication rulesApplication = new RulesApplication ( rules , input , phonemeBuilder , i , maxPhonemes ) . invoke () ; i = rulesApplication . getI () ;
final Rule . Phoneme oldPhoneme = phonemes . remove ( newPhoneme ) ; MST[NonVoidMethodCallMutator]MSP[N] final Rule . Phoneme mergedPhoneme = oldPhoneme . mergeWithLanguage ( newPhoneme . getLanguages () ) ; phonemes . put ( mergedPhoneme , mergedPhoneme ) ; } else { phonemes . put ( newPhoneme , newPhoneme ) ;
if ( this . nameType == NameType . GENERIC ) { if ( input . length () >= 2 && input . substring ( 0 , 2 ) . equals ( lr_5 ) ) { MST[InlineConstantMutator]MSP[N] final String remainder = input . substring ( 2 ) ;
if ( this . nameType == NameType . GENERIC ) { if ( input . length () >= 2 && input . substring ( 0 , 2 ) . equals ( lr_5 ) ) { MST[rv.ROR4Mutator]MSP[N] final String remainder = input . substring ( 2 ) ;
if ( this . nameType == NameType . GENERIC ) { if ( input . length () >= 2 && input . substring ( 0 , 2 ) . equals ( lr_5 ) ) { MST[rv.CRCR3Mutator]MSP[N] final String remainder = input . substring ( 2 ) ;
phonemeBuilder = rulesApplication . getPhonemeBuilder () ; } phonemeBuilder = applyFinalRules ( phonemeBuilder , finalRules1 ) ; MST[ArgumentPropagationMutator]MSP[N] phonemeBuilder = applyFinalRules ( phonemeBuilder , finalRules2 ) ; return phonemeBuilder . makeString () ; } public Lang getLang () { return this . lang ; } public NameType getNameType () {
if ( this . nameType == NameType . GENERIC ) { if ( input . length () >= 2 && input . substring ( 0 , 2 ) . equals ( lr_5 ) ) { MST[rv.CRCR4Mutator]MSP[N] final String remainder = input . substring ( 2 ) ;
final String combined = lr_6 + remainder ; return lr_7 + encode ( remainder ) + lr_8 + encode ( combined ) + lr_9 ; MST[NonVoidMethodCallMutator]MSP[S] } for ( final String l : NAME_PREFIXES . get ( this . nameType ) ) {
words2 . removeAll ( NAME_PREFIXES . get ( this . nameType ) ) ; break; case GENERIC : words2 . addAll ( words ) ; break; default: throw new IllegalStateException ( lr_13 + this . nameType ) ; } if ( this . concat ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
subBuilder . append ( phonemeText . subSequence ( i , i + 1 ) ) ; } i = rulesApplication . getI () ; } for ( final Rule . Phoneme newPhoneme : subBuilder . getPhonemes () ) { if ( phonemes . containsKey ( newPhoneme ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
final List < String > words2 = new ArrayList <> () ; switch ( this . nameType ) { case SEPHARDIC : for ( final String aWord : words ) { final String [] parts = aWord . split ( lr_12 ) ; MST[NonVoidMethodCallMutator]MSP[S]
if ( input . startsWith ( l + lr_10 ) ) { final String remainder = input . substring ( l . length () + 1 ) ; MST[NonVoidMethodCallMutator]MSP[S] final String combined = l + remainder ;
for ( int i = 0 ; i < input . length () ; ) { final RulesApplication rulesApplication = new RulesApplication ( rules , input , phonemeBuilder , i , maxPhonemes ) . invoke () ; MST[NonVoidMethodCallMutator]MSP[N] i = rulesApplication . getI () ;
PhonemeBuilder subBuilder = PhonemeBuilder . empty ( phoneme . getLanguages () ) ; final String phonemeText = phoneme . getPhonemeText () . toString () ; for ( int i = 0 ; i < phonemeText . length () ; ) { final RulesApplication rulesApplication = MST[rv.UOI2Mutator]MSP[N]
if ( this . nameType == NameType . GENERIC ) { if ( input . length () >= 2 && input . substring ( 0 , 2 ) . equals ( lr_5 ) ) { MST[rv.ROR1Mutator]MSP[N] final String remainder = input . substring ( 2 ) ;
subBuilder . append ( phonemeText . subSequence ( i , i + 1 ) ) ; } i = rulesApplication . getI () ; } for ( final Rule . Phoneme newPhoneme : subBuilder . getPhonemes () ) { if ( phonemes . containsKey ( newPhoneme ) ) { MST[rv.ROR3Mutator]MSP[N]
for ( int i = 0 ; i < input . length () ; ) { final RulesApplication rulesApplication = MST[rv.UOI1Mutator]MSP[N] new RulesApplication ( rules , input , phonemeBuilder , i , maxPhonemes ) . invoke () ; i = rulesApplication . getI () ;
final String lastPart = parts [ parts . length - 1 ] ; MST[rv.CRCR6Mutator]MSP[S] words2 . add ( lastPart ) ; } words2 . removeAll ( NAME_PREFIXES . get ( this . nameType ) ) ; break; case ASHKENAZI : words2 . addAll ( words ) ;
input = join ( words2 , lr_10 ) ; } else if ( words2 . size () == 1 ) { MST[NonVoidMethodCallMutator]MSP[N] input = words . iterator () . next () ; } else { final StringBuilder result = new StringBuilder () ;
new RulesApplication ( finalRules , phonemeText , subBuilder , i , maxPhonemes ) . invoke () ; final boolean found = rulesApplication . isFound () ; subBuilder = rulesApplication . getPhonemeBuilder () ; if ( ! found ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
final List < String > words2 = new ArrayList <> () ; switch ( this . nameType ) { MST[rv.UOI1Mutator]MSP[N] case SEPHARDIC : for ( final String aWord : words ) { final String [] parts = aWord . split ( lr_12 ) ;
