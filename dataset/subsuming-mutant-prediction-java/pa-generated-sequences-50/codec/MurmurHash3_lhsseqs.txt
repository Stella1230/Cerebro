k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ; result ^= k1 ; } result ^= totalLen ; MST[rv.UOI4Mutator]MSP[] return fmix32 ( result ) ; }
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ; MST[rv.CRCR6Mutator]MSP[]
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ; result ^= k1 ; MST[rv.UOI2Mutator]MSP[] } result ^= totalLen ; return fmix32 ( result ) ; }
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; MST[rv.AOD2Mutator]MSP[] newLength = length - consumed ; } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ;
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; MST[InlineConstantMutator]MSP[] case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.ABSMutator]MSP[] } @Override @Deprecated
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , unprocessed [ 2 ] , data [ offset ] ) ; MST[rv.CRCR3Mutator]MSP[] break; default: throw new IllegalStateException ( lr_1 + unprocessedLength ) ; } hash = mix32 ( k , hash ) ;
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , unprocessed [ 2 ] , data [ offset ] ) ; MST[rv.CRCR6Mutator]MSP[] break; default: throw new IllegalStateException ( lr_1 + unprocessedLength ) ; } hash = mix32 ( k , hash ) ;
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; MST[rv.UOI3Mutator]MSP[] k1 *= C2_32 ; result ^= k1 ; } result ^= totalLen ; return fmix32 ( result ) ; }
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; MST[rv.CRCR5Mutator]MSP[] case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
public final void start ( final int seed ) { unprocessedLength = totalLen = 0 ; this . hash = seed ; } public final void add ( final byte [] data , final int offset , final int length ) { if ( length <= 0 ) { MST[rv.UOI2Mutator]MSP[] return;
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[rv.CRCR5Mutator]MSP[] break; case 3 :
final int consumed = BLOCK_SIZE - unprocessedLength ; MST[rv.CRCR1Mutator]MSP[] newOffset = offset + consumed ; newLength = length - consumed ; } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ;
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.UOI2Mutator]MSP[] } @Override @Deprecated
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.UOI3Mutator]MSP[] } @Override @Deprecated
return finalise ( hash , unprocessedLength , unprocessed , totalLen ) ; MST[rv.UOI1Mutator]MSP[] } int finalise ( final int hash , final int unprocessedLength , final byte [] unprocessed , final int totalLen ) { int result = hash ; int k1 = 0 ; switch ( unprocessedLength ) {
int k = - 1 ; switch ( unprocessedLength ) { MST[rv.UOI4Mutator]MSP[] case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; break; case 2 :
for ( int i = 0 ; i < nblocks ; i ++ ) { final int index = newOffset + ( i << 2 ) ; MST[rv.CRCR1Mutator]MSP[] final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; }
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; MST[rv.UOI4Mutator]MSP[] case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ; MST[rv.CRCR5Mutator]MSP[] result ^= k1 ; } result ^= totalLen ; return fmix32 ( result ) ; }
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.OBBN1Mutator]MSP[] } @Override @Deprecated
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; MST[rv.CRCR1Mutator]MSP[] } } public final int end () {
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; MST[rv.AOR4Mutator]MSP[] return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; newLength = length - consumed ; } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ; MST[rv.CRCR5Mutator]MSP[]
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.CRCR6Mutator]MSP[] break; case 2 :
public final void start ( final int seed ) { unprocessedLength = totalLen = 0 ; this . hash = seed ; } public final void add ( final byte [] data , final int offset , final int length ) { if ( length <= 0 ) { MST[rv.ABSMutator]MSP[] return;
public final void start ( final int seed ) { unprocessedLength = totalLen = 0 ; this . hash = seed ; } public final void add ( final byte [] data , final int offset , final int length ) { if ( length <= 0 ) { MST[rv.ROR3Mutator]MSP[] return;
return finalise ( hash , unprocessedLength , unprocessed , totalLen ) ; } int finalise ( final int hash , final int unprocessedLength , final byte [] unprocessed , final int totalLen ) { int result = hash ; int k1 = 0 ; MST[InlineConstantMutator]MSP[] switch ( unprocessedLength ) {
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.CRCR5Mutator]MSP[] } @Override @Deprecated
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { MST[rv.ROR4Mutator]MSP[] System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; } } public final int end () {
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; MST[rv.UOI1Mutator]MSP[] case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; MST[MathMutator]MSP[] newLength = length - consumed ; } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ;
for ( int i = 0 ; i < nblocks ; i ++ ) { MST[rv.ROR1Mutator]MSP[] final int index = newOffset + ( i << 2 ) ; final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; }
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.CRCR2Mutator]MSP[] } @Override @Deprecated
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[InlineConstantMutator]MSP[] } @Override @Deprecated
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.UOI1Mutator]MSP[] break; case 2 :
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; MST[rv.CRCR2Mutator]MSP[] case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ; result ^= k1 ; MST[rv.ABSMutator]MSP[] } result ^= totalLen ; return fmix32 ( result ) ; }
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.ABSMutator]MSP[] } @Override @Deprecated
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[rv.CRCR3Mutator]MSP[] break; case 3 :
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; newLength = length - consumed ; MST[rv.UOI4Mutator]MSP[] } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ;
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { MST[rv.UOI3Mutator]MSP[] System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; } } public final int end () {
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.OBBN1Mutator]MSP[] } @Override @Deprecated
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; newLength = length - consumed ; MST[rv.AOR1Mutator]MSP[] } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ;
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.UOI2Mutator]MSP[] } @Override @Deprecated
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.CRCR4Mutator]MSP[] break; case 2 :
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[MathMutator]MSP[] } @Override @Deprecated
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; MST[rv.UOI3Mutator]MSP[] newLength = length - consumed ; } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ;
for ( int i = 0 ; i < nblocks ; i ++ ) { MST[rv.UOI3Mutator]MSP[] final int index = newOffset + ( i << 2 ) ; final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; }
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; MST[rv.OBBN3Mutator]MSP[] case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
final int consumed = ( nblocks << 2 ) ; MST[rv.CRCR4Mutator]MSP[] unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; } } public final int end () {
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; MST[InlineConstantMutator]MSP[] case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; MST[rv.CRCR5Mutator]MSP[] case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[MathMutator]MSP[] break; case 3 :
} totalLen += length ; MST[rv.AOR2Mutator]MSP[] if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ; MST[rv.UOI1Mutator]MSP[]
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ; result ^= k1 ; } result ^= totalLen ; return fmix32 ( result ) ; MST[ReturnValsMutator]MSP[] }
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; MST[rv.CRCR2Mutator]MSP[] case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { MST[rv.AOD1Mutator]MSP[] System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
return finalise ( hash , unprocessedLength , unprocessed , totalLen ) ; } int finalise ( final int hash , final int unprocessedLength , final byte [] unprocessed , final int totalLen ) { int result = hash ; MST[rv.UOI1Mutator]MSP[] int k1 = 0 ; switch ( unprocessedLength ) {
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; MST[rv.ABSMutator]MSP[] unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
final int consumed = BLOCK_SIZE - unprocessedLength ; MST[rv.ABSMutator]MSP[] newOffset = offset + consumed ; newLength = length - consumed ; } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ;
for ( int i = 0 ; i < nblocks ; i ++ ) { final int index = newOffset + ( i << 2 ) ; final int k = getLittleEndianInt ( data , index ) ; MST[NonVoidMethodCallMutator]MSP[] hash = mix32 ( k , hash ) ; }
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; MST[rv.CRCR5Mutator]MSP[] case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
return finalise ( hash , unprocessedLength , unprocessed , totalLen ) ; MST[rv.UOI3Mutator]MSP[] } int finalise ( final int hash , final int unprocessedLength , final byte [] unprocessed , final int totalLen ) { int result = hash ; int k1 = 0 ; switch ( unprocessedLength ) {
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; newLength = length - consumed ; } else { newOffset = offset ; newLength = length ; MST[rv.UOI4Mutator]MSP[] } final int nblocks = newLength >> 2 ;
return finalise ( hash , unprocessedLength , unprocessed , totalLen ) ; } int finalise ( final int hash , final int unprocessedLength , final byte [] unprocessed , final int totalLen ) { int result = hash ; int k1 = 0 ; switch ( unprocessedLength ) { MST[experimental.SwitchMutator]MSP[]
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { MST[rv.ROR5Mutator]MSP[] System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; newLength = length - consumed ; } else { newOffset = offset ; MST[rv.UOI2Mutator]MSP[] newLength = length ; } final int nblocks = newLength >> 2 ;
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ; result ^= k1 ; } result ^= totalLen ; return fmix32 ( result ) ; MST[rv.ABSMutator]MSP[] }
for ( int i = 0 ; i < nblocks ; i ++ ) { MST[rv.CRCR6Mutator]MSP[] final int index = newOffset + ( i << 2 ) ; final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; }
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[]
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; MST[rv.ABSMutator]MSP[] } } public final int end () {
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { MST[rv.UOI2Mutator]MSP[] System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[rv.AOD2Mutator]MSP[] break; case 3 :
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , unprocessed [ 2 ] , data [ offset ] ) ; break; default: throw new IllegalStateException ( lr_1 + unprocessedLength ) ; } hash = mix32 ( k , hash ) ; MST[rv.UOI4Mutator]MSP[]
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[rv.CRCR6Mutator]MSP[] break; case 3 :
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; MST[rv.UOI4Mutator]MSP[] } } public final int end () {
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[rv.ABSMutator]MSP[] break; case 3 :
return finalise ( hash , unprocessedLength , unprocessed , totalLen ) ; MST[rv.UOI4Mutator]MSP[] } int finalise ( final int hash , final int unprocessedLength , final byte [] unprocessed , final int totalLen ) { int result = hash ; int k1 = 0 ; switch ( unprocessedLength ) {
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; MST[rv.CRCR2Mutator]MSP[] case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; MST[rv.UOI1Mutator]MSP[] unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { MST[rv.CRCR4Mutator]MSP[] System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; MST[rv.ABSMutator]MSP[] case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , unprocessed [ 2 ] , data [ offset ] ) ; MST[rv.UOI3Mutator]MSP[] break; default: throw new IllegalStateException ( lr_1 + unprocessedLength ) ; } hash = mix32 ( k , hash ) ;
for ( int i = 0 ; i < nblocks ; i ++ ) { MST[rv.CRCR3Mutator]MSP[] final int index = newOffset + ( i << 2 ) ; final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; }
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ; result ^= k1 ; } result ^= totalLen ; MST[MathMutator]MSP[] return fmix32 ( result ) ; }
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; MST[rv.UOI3Mutator]MSP[] return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
public final void start ( final int seed ) { unprocessedLength = totalLen = 0 ; this . hash = seed ; MST[rv.UOI2Mutator]MSP[] } public final void add ( final byte [] data , final int offset , final int length ) { if ( length <= 0 ) { return;
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , unprocessed [ 2 ] , data [ offset ] ) ; MST[rv.CRCR6Mutator]MSP[] break; default: throw new IllegalStateException ( lr_1 + unprocessedLength ) ; } hash = mix32 ( k , hash ) ;
int k = - 1 ; MST[rv.CRCR4Mutator]MSP[] switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; break; case 2 :
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.ABSMutator]MSP[] break; case 2 :
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ; MST[rv.AOD2Mutator]MSP[]
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , unprocessed [ 2 ] , data [ offset ] ) ; MST[rv.CRCR3Mutator]MSP[] break; default: throw new IllegalStateException ( lr_1 + unprocessedLength ) ; } hash = mix32 ( k , hash ) ;
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[rv.CRCR2Mutator]MSP[] break; case 3 :
for ( int i = 0 ; i < nblocks ; i ++ ) { final int index = newOffset + ( i << 2 ) ; MST[rv.AOR1Mutator]MSP[] final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; }
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.UOI3Mutator]MSP[] break; case 2 :
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { MST[rv.AOD1Mutator]MSP[] System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.CRCR2Mutator]MSP[] break; case 2 :
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; MST[rv.ABSMutator]MSP[] case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) { MST[rv.UOI3Mutator]MSP[]
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[NonVoidMethodCallMutator]MSP[] break; case 2 :
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) { MST[rv.ROR4Mutator]MSP[]
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; newLength = length - consumed ; } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ; MST[InlineConstantMutator]MSP[]
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; MST[rv.AOR1Mutator]MSP[] if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; } } public final int end () {
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[rv.UOI2Mutator]MSP[] break; case 3 :
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[rv.UOI3Mutator]MSP[] break; case 3 :
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; MST[rv.ABSMutator]MSP[] newLength = length - consumed ; } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ;
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ; MST[rv.CRCR1Mutator]MSP[]
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[rv.UOI4Mutator]MSP[] break; case 3 :
public final void start ( final int seed ) { unprocessedLength = totalLen = 0 ; this . hash = seed ; } public final void add ( final byte [] data , final int offset , final int length ) { if ( length <= 0 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] return;
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; MST[MathMutator]MSP[] case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
} totalLen += length ; MST[rv.UOI2Mutator]MSP[] if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.CRCR6Mutator]MSP[] } @Override @Deprecated
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , unprocessed [ 2 ] , data [ offset ] ) ; break; default: throw new IllegalStateException ( lr_1 + unprocessedLength ) ; } hash = mix32 ( k , hash ) ; MST[rv.UOI4Mutator]MSP[]
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { MST[rv.AOR3Mutator]MSP[] System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { MST[rv.ROR1Mutator]MSP[] System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; } } public final int end () {
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; MST[rv.CRCR5Mutator]MSP[] k1 *= C1_32 ;
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; MST[rv.CRCR3Mutator]MSP[] k1 *= C1_32 ;
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[InlineConstantMutator]MSP[] break; case 3 :
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; newLength = length - consumed ; } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ; MST[rv.UOI2Mutator]MSP[]
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.CRCR2Mutator]MSP[] } @Override @Deprecated
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , unprocessed [ 2 ] , data [ offset ] ) ; MST[NonVoidMethodCallMutator]MSP[] break; default: throw new IllegalStateException ( lr_1 + unprocessedLength ) ; } hash = mix32 ( k , hash ) ;
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.CRCR4Mutator]MSP[] } @Override @Deprecated
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.UOI4Mutator]MSP[] break; case 2 :
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[MathMutator]MSP[] } @Override @Deprecated
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; MST[rv.UOI2Mutator]MSP[] if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; } } public final int end () {
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , unprocessed [ 2 ] , data [ offset ] ) ; break; default: throw new IllegalStateException ( lr_1 + unprocessedLength ) ; } hash = mix32 ( k , hash ) ; MST[rv.ABSMutator]MSP[]
for ( int i = 0 ; i < nblocks ; i ++ ) { final int index = newOffset + ( i << 2 ) ; final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; MST[experimental.MemberVariableMutator]MSP[] }
return finalise ( hash , unprocessedLength , unprocessed , totalLen ) ; MST[PrimitiveReturnsMutator]MSP[] } int finalise ( final int hash , final int unprocessedLength , final byte [] unprocessed , final int totalLen ) { int result = hash ; int k1 = 0 ; switch ( unprocessedLength ) {
} totalLen += length ; MST[experimental.MemberVariableMutator]MSP[] if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; MST[rv.UOI3Mutator]MSP[] unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[rv.AOR4Mutator]MSP[] break; case 3 :
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; MST[rv.UOI4Mutator]MSP[] return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.CRCR3Mutator]MSP[] break; case 2 :
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; newLength = length - consumed ; } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ; MST[rv.CRCR2Mutator]MSP[]
final int consumed = ( nblocks << 2 ) ; MST[rv.ABSMutator]MSP[] unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; } } public final int end () {
return finalise ( hash , unprocessedLength , unprocessed , totalLen ) ; } int finalise ( final int hash , final int unprocessedLength , final byte [] unprocessed , final int totalLen ) { int result = hash ; int k1 = 0 ; switch ( unprocessedLength ) { MST[rv.UOI3Mutator]MSP[]
final int consumed = ( nblocks << 2 ) ; MST[rv.CRCR1Mutator]MSP[] unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; } } public final int end () {
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { MST[rv.UOI3Mutator]MSP[] System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.CRCR5Mutator]MSP[] } @Override @Deprecated
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; MST[rv.AOD2Mutator]MSP[] return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.CRCR4Mutator]MSP[] } @Override @Deprecated
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.AOR1Mutator]MSP[] break; case 2 :
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; MST[rv.CRCR5Mutator]MSP[] case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.UOI3Mutator]MSP[] break; case 2 :
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; MST[rv.UOI2Mutator]MSP[] } } public final int end () {
} totalLen += length ; MST[rv.UOI1Mutator]MSP[] if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ; MST[rv.AOR4Mutator]MSP[] result ^= k1 ; } result ^= totalLen ; return fmix32 ( result ) ; }
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; newLength = length - consumed ; MST[rv.UOI1Mutator]MSP[] } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ;
return finalise ( hash , unprocessedLength , unprocessed , totalLen ) ; MST[rv.UOI1Mutator]MSP[] } int finalise ( final int hash , final int unprocessedLength , final byte [] unprocessed , final int totalLen ) { int result = hash ; int k1 = 0 ; switch ( unprocessedLength ) {
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; newLength = length - consumed ; } else { newOffset = offset ; MST[rv.UOI4Mutator]MSP[] newLength = length ; } final int nblocks = newLength >> 2 ;
public final void start ( final int seed ) { unprocessedLength = totalLen = 0 ; MST[experimental.MemberVariableMutator]MSP[] this . hash = seed ; } public final void add ( final byte [] data , final int offset , final int length ) { if ( length <= 0 ) { return;
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[rv.UOI3Mutator]MSP[] break; case 3 :
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.OBBN2Mutator]MSP[] } @Override @Deprecated
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[rv.UOI2Mutator]MSP[] break; case 3 :
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.OBBN3Mutator]MSP[] } @Override @Deprecated
public final void start ( final int seed ) { unprocessedLength = totalLen = 0 ; this . hash = seed ; MST[rv.ABSMutator]MSP[] } public final void add ( final byte [] data , final int offset , final int length ) { if ( length <= 0 ) { return;
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; MST[rv.AOR4Mutator]MSP[] newLength = length - consumed ; } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ;
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; MST[rv.CRCR3Mutator]MSP[] k1 *= C2_32 ; result ^= k1 ; } result ^= totalLen ; return fmix32 ( result ) ; }
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ; MST[rv.ABSMutator]MSP[] result ^= k1 ; } result ^= totalLen ; return fmix32 ( result ) ; }
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ; result ^= k1 ; MST[rv.UOI1Mutator]MSP[] } result ^= totalLen ; return fmix32 ( result ) ; }
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ; result ^= k1 ; } result ^= totalLen ; MST[rv.UOI3Mutator]MSP[] return fmix32 ( result ) ; }
final int consumed = BLOCK_SIZE - unprocessedLength ; MST[rv.AOR2Mutator]MSP[] newOffset = offset + consumed ; newLength = length - consumed ; } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ;
return finalise ( hash , unprocessedLength , unprocessed , totalLen ) ; MST[NonVoidMethodCallMutator]MSP[] } int finalise ( final int hash , final int unprocessedLength , final byte [] unprocessed , final int totalLen ) { int result = hash ; int k1 = 0 ; switch ( unprocessedLength ) {
for ( int i = 0 ; i < nblocks ; i ++ ) { final int index = newOffset + ( i << 2 ) ; MST[rv.UOI1Mutator]MSP[] final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; }
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.CRCR2Mutator]MSP[] } @Override @Deprecated
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.CRCR6Mutator]MSP[] } @Override @Deprecated
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; newLength = length - consumed ; } else { newOffset = offset ; MST[rv.ABSMutator]MSP[] newLength = length ; } final int nblocks = newLength >> 2 ;
final int consumed = BLOCK_SIZE - unprocessedLength ; MST[MathMutator]MSP[] newOffset = offset + consumed ; newLength = length - consumed ; } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ;
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; MST[rv.UOI4Mutator]MSP[] case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { MST[rv.AOR3Mutator]MSP[] System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , unprocessed [ 2 ] , data [ offset ] ) ; MST[rv.UOI1Mutator]MSP[] break; default: throw new IllegalStateException ( lr_1 + unprocessedLength ) ; } hash = mix32 ( k , hash ) ;
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.CRCR5Mutator]MSP[] } @Override @Deprecated
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.UOI4Mutator]MSP[] break; case 2 :
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; MST[rv.CRCR2Mutator]MSP[] case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; MST[VoidMethodCallMutator]MSP[] } } public final int end () {
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[MathMutator]MSP[] } @Override @Deprecated
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; MST[rv.UOI2Mutator]MSP[] k1 *= C1_32 ;
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; MST[rv.UOI3Mutator]MSP[] k1 *= C1_32 ;
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[InlineConstantMutator]MSP[] } @Override @Deprecated
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ; MST[rv.AOD1Mutator]MSP[] result ^= k1 ; } result ^= totalLen ; return fmix32 ( result ) ; }
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , unprocessed [ 2 ] , data [ offset ] ) ; MST[rv.UOI3Mutator]MSP[] break; default: throw new IllegalStateException ( lr_1 + unprocessedLength ) ; } hash = mix32 ( k , hash ) ;
public final void start ( final int seed ) { unprocessedLength = totalLen = 0 ; this . hash = seed ; } public final void add ( final byte [] data , final int offset , final int length ) { if ( length <= 0 ) { MST[ConditionalsBoundaryMutator]MSP[] return;
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; MST[rv.UOI2Mutator]MSP[] unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; MST[rv.UOI4Mutator]MSP[] newLength = length - consumed ; } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ;
final int consumed = BLOCK_SIZE - unprocessedLength ; MST[rv.UOI2Mutator]MSP[] newOffset = offset + consumed ; newLength = length - consumed ; } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ;
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ; MST[rv.CRCR4Mutator]MSP[]
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ; result ^= k1 ; } result ^= totalLen ; MST[rv.UOI2Mutator]MSP[] return fmix32 ( result ) ; }
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; MST[experimental.MemberVariableMutator]MSP[] return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
int k = - 1 ; switch ( unprocessedLength ) { MST[rv.UOI2Mutator]MSP[] case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; break; case 2 :
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[rv.CRCR3Mutator]MSP[] break; case 3 :
for ( int i = 0 ; i < nblocks ; i ++ ) { final int index = newOffset + ( i << 2 ) ; MST[rv.AOR4Mutator]MSP[] final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; }
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.UOI4Mutator]MSP[] break; case 2 :
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; MST[rv.UOI1Mutator]MSP[] k1 *= C2_32 ; result ^= k1 ; } result ^= totalLen ; return fmix32 ( result ) ; }
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; MST[rv.CRCR3Mutator]MSP[] case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; MST[MathMutator]MSP[] if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; } } public final int end () {
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; MST[rv.UOI3Mutator]MSP[] if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; } } public final int end () {
return finalise ( hash , unprocessedLength , unprocessed , totalLen ) ; MST[rv.UOI3Mutator]MSP[] } int finalise ( final int hash , final int unprocessedLength , final byte [] unprocessed , final int totalLen ) { int result = hash ; int k1 = 0 ; switch ( unprocessedLength ) {
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.UOI1Mutator]MSP[] } @Override @Deprecated
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; MST[rv.AOR3Mutator]MSP[] } } public final int end () {
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[MathMutator]MSP[] } @Override @Deprecated
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; newLength = length - consumed ; } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ; MST[MathMutator]MSP[]
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ; MST[rv.CRCR3Mutator]MSP[] result ^= k1 ; } result ^= totalLen ; return fmix32 ( result ) ; }
int k = - 1 ; switch ( unprocessedLength ) { MST[experimental.RemoveSwitchMutator_2]MSP[] case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; break; case 2 :
int k = - 1 ; switch ( unprocessedLength ) { MST[experimental.RemoveSwitchMutator_0]MSP[] case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; break; case 2 :
for ( int i = 0 ; i < nblocks ; i ++ ) { final int index = newOffset + ( i << 2 ) ; final int k = getLittleEndianInt ( data , index ) ; MST[ArgumentPropagationMutator]MSP[] hash = mix32 ( k , hash ) ; }
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; MST[rv.UOI2Mutator]MSP[] case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
int k = - 1 ; switch ( unprocessedLength ) { MST[experimental.RemoveSwitchMutator_1]MSP[] case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; break; case 2 :
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; MST[rv.AOR2Mutator]MSP[] return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; newLength = length - consumed ; } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ; MST[rv.CRCR3Mutator]MSP[]
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; MST[rv.AOD2Mutator]MSP[] if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; } } public final int end () {
} totalLen += length ; MST[rv.UOI3Mutator]MSP[] if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ; result ^= k1 ; MST[rv.UOI4Mutator]MSP[] } result ^= totalLen ; return fmix32 ( result ) ; }
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { MST[rv.AOR1Mutator]MSP[] System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; MST[rv.ABSMutator]MSP[] } } public final int end () {
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; MST[rv.CRCR6Mutator]MSP[] k1 *= C1_32 ;
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ; result ^= k1 ; } result ^= totalLen ; return fmix32 ( result ) ; MST[rv.UOI3Mutator]MSP[] }
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[InlineConstantMutator]MSP[] break; case 3 :
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , unprocessed [ 2 ] , data [ offset ] ) ; MST[rv.ABSMutator]MSP[] break; default: throw new IllegalStateException ( lr_1 + unprocessedLength ) ; } hash = mix32 ( k , hash ) ;
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.CRCR5Mutator]MSP[] } @Override @Deprecated
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.CRCR1Mutator]MSP[] } @Override @Deprecated
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; MST[rv.UOI2Mutator]MSP[] } } public final int end () {
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ; result ^= k1 ; } result ^= totalLen ; MST[rv.ABSMutator]MSP[] return fmix32 ( result ) ; }
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; newLength = length - consumed ; } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ; MST[rv.UOI3Mutator]MSP[]
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; MST[MathMutator]MSP[] case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.ABSMutator]MSP[] break; case 2 :
for ( int i = 0 ; i < nblocks ; i ++ ) { final int index = newOffset + ( i << 2 ) ; MST[rv.AOD2Mutator]MSP[] final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; }
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; MST[InlineConstantMutator]MSP[] case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; MST[rv.UOI1Mutator]MSP[] return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.AOD1Mutator]MSP[] break; case 2 :
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.CRCR3Mutator]MSP[] break; case 2 :
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; MST[rv.ABSMutator]MSP[] case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , unprocessed [ 2 ] , data [ offset ] ) ; break; default: throw new IllegalStateException ( lr_1 + unprocessedLength ) ; } hash = mix32 ( k , hash ) ; MST[experimental.MemberVariableMutator]MSP[]
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , unprocessed [ 2 ] , data [ offset ] ) ; MST[InlineConstantMutator]MSP[] break; default: throw new IllegalStateException ( lr_1 + unprocessedLength ) ; } hash = mix32 ( k , hash ) ;
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[rv.ABSMutator]MSP[] break; case 3 :
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , unprocessed [ 2 ] , data [ offset ] ) ; MST[rv.UOI1Mutator]MSP[] break; default: throw new IllegalStateException ( lr_1 + unprocessedLength ) ; } hash = mix32 ( k , hash ) ;
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[InlineConstantMutator]MSP[] } @Override @Deprecated
for ( int i = 0 ; i < nblocks ; i ++ ) { final int index = newOffset + ( i << 2 ) ; final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; MST[rv.UOI3Mutator]MSP[] }
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[MathMutator]MSP[] break; case 2 :
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[rv.UOI4Mutator]MSP[] break; case 3 :
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; newLength = length - consumed ; MST[rv.ABSMutator]MSP[] } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ;
public final void start ( final int seed ) { unprocessedLength = totalLen = 0 ; this . hash = seed ; MST[rv.UOI4Mutator]MSP[] } public final void add ( final byte [] data , final int offset , final int length ) { if ( length <= 0 ) { return;
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[InlineConstantMutator]MSP[] break; case 2 :
} totalLen += length ; MST[rv.UOI2Mutator]MSP[] if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; newLength = length - consumed ; MST[rv.AOD2Mutator]MSP[] } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ;
for ( int i = 0 ; i < nblocks ; i ++ ) { MST[rv.UOI1Mutator]MSP[] final int index = newOffset + ( i << 2 ) ; final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; }
return finalise ( hash , unprocessedLength , unprocessed , totalLen ) ; } int finalise ( final int hash , final int unprocessedLength , final byte [] unprocessed , final int totalLen ) { int result = hash ; int k1 = 0 ; switch ( unprocessedLength ) { MST[rv.UOI1Mutator]MSP[]
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; MST[MathMutator]MSP[] case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
public final void start ( final int seed ) { unprocessedLength = totalLen = 0 ; this . hash = seed ; } public final void add ( final byte [] data , final int offset , final int length ) { if ( length <= 0 ) { MST[NegateConditionalsMutator]MSP[] return;
final int consumed = ( nblocks << 2 ) ; MST[rv.CRCR2Mutator]MSP[] unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; } } public final int end () {
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; MST[rv.CRCR3Mutator]MSP[] case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
return finalise ( hash , unprocessedLength , unprocessed , totalLen ) ; } int finalise ( final int hash , final int unprocessedLength , final byte [] unprocessed , final int totalLen ) { int result = hash ; MST[rv.UOI4Mutator]MSP[] int k1 = 0 ; switch ( unprocessedLength ) {
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; MST[rv.CRCR6Mutator]MSP[] case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; MST[rv.UOI3Mutator]MSP[] } } public final int end () {
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ; MST[rv.UOI3Mutator]MSP[] result ^= k1 ; } result ^= totalLen ; return fmix32 ( result ) ; }
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.OBBN1Mutator]MSP[] } @Override @Deprecated
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { MST[rv.ROR3Mutator]MSP[] System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ; MST[rv.AOR1Mutator]MSP[]
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.OBBN2Mutator]MSP[] } @Override @Deprecated
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; MST[rv.UOI3Mutator]MSP[] unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
final int consumed = BLOCK_SIZE - unprocessedLength ; MST[rv.UOI3Mutator]MSP[] newOffset = offset + consumed ; newLength = length - consumed ; } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ;
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; MST[rv.ABSMutator]MSP[] k1 *= C1_32 ;
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; MST[rv.AOR2Mutator]MSP[] newLength = length - consumed ; } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ;
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; MST[rv.UOI3Mutator]MSP[] case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; MST[rv.CRCR3Mutator]MSP[] k1 *= C1_32 ;
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { MST[rv.ROR2Mutator]MSP[] System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; } } public final int end () {
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; MST[rv.CRCR6Mutator]MSP[] k1 *= C1_32 ;
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.CRCR5Mutator]MSP[] } @Override @Deprecated
public final void start ( final int seed ) { unprocessedLength = totalLen = 0 ; this . hash = seed ; } public final void add ( final byte [] data , final int offset , final int length ) { if ( length <= 0 ) { MST[rv.ROR1Mutator]MSP[] return;
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.AOR3Mutator]MSP[] break; case 2 :
for ( int i = 0 ; i < nblocks ; i ++ ) { MST[rv.ABSMutator]MSP[] final int index = newOffset + ( i << 2 ) ; final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; }
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; newLength = length - consumed ; MST[MathMutator]MSP[] } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ;
public final void start ( final int seed ) { unprocessedLength = totalLen = 0 ; MST[rv.CRCR6Mutator]MSP[] this . hash = seed ; } public final void add ( final byte [] data , final int offset , final int length ) { if ( length <= 0 ) { return;
return finalise ( hash , unprocessedLength , unprocessed , totalLen ) ; MST[ArgumentPropagationMutator]MSP[] } int finalise ( final int hash , final int unprocessedLength , final byte [] unprocessed , final int totalLen ) { int result = hash ; int k1 = 0 ; switch ( unprocessedLength ) {
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.AOD2Mutator]MSP[] break; case 2 :
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; MST[InlineConstantMutator]MSP[] k1 *= C1_32 ;
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) { MST[rv.UOI4Mutator]MSP[]
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.CRCR2Mutator]MSP[] break; case 2 :
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; MST[ArgumentPropagationMutator]MSP[] k1 *= C2_32 ; result ^= k1 ; } result ^= totalLen ; return fmix32 ( result ) ; }
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ; MST[rv.UOI4Mutator]MSP[]
for ( int i = 0 ; i < nblocks ; i ++ ) { final int index = newOffset + ( i << 2 ) ; MST[rv.CRCR4Mutator]MSP[] final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; }
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; MST[rv.AOD1Mutator]MSP[] } } public final int end () {
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[rv.UOI4Mutator]MSP[] break; case 3 :
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[rv.UOI3Mutator]MSP[] break; case 3 :
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[rv.AOR2Mutator]MSP[] break; case 3 :
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.OBBN3Mutator]MSP[] } @Override @Deprecated
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.OBBN2Mutator]MSP[] } @Override @Deprecated
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.UOI3Mutator]MSP[] break; case 2 :
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.UOI1Mutator]MSP[] break; case 2 :
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , unprocessed [ 2 ] , data [ offset ] ) ; MST[rv.CRCR5Mutator]MSP[] break; default: throw new IllegalStateException ( lr_1 + unprocessedLength ) ; } hash = mix32 ( k , hash ) ;
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; newLength = length - consumed ; } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ; MST[rv.ABSMutator]MSP[]
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ; result ^= k1 ; MST[rv.UOI3Mutator]MSP[] } result ^= totalLen ; return fmix32 ( result ) ; }
int k = - 1 ; MST[rv.CRCR2Mutator]MSP[] switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; break; case 2 :
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; MST[InlineConstantMutator]MSP[] case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , unprocessed [ 2 ] , data [ offset ] ) ; MST[rv.CRCR1Mutator]MSP[] break; default: throw new IllegalStateException ( lr_1 + unprocessedLength ) ; } hash = mix32 ( k , hash ) ;
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , unprocessed [ 2 ] , data [ offset ] ) ; MST[rv.UOI3Mutator]MSP[] break; default: throw new IllegalStateException ( lr_1 + unprocessedLength ) ; } hash = mix32 ( k , hash ) ;
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; MST[rv.UOI4Mutator]MSP[] k1 *= C2_32 ; result ^= k1 ; } result ^= totalLen ; return fmix32 ( result ) ; }
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[rv.CRCR3Mutator]MSP[] break; case 3 :
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; MST[rv.UOI3Mutator]MSP[] } } public final int end () {
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; MST[MathMutator]MSP[] k1 *= C1_32 ;
final int consumed = BLOCK_SIZE - unprocessedLength ; MST[rv.CRCR4Mutator]MSP[] newOffset = offset + consumed ; newLength = length - consumed ; } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ;
} totalLen += length ; MST[rv.ABSMutator]MSP[] if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
for ( int i = 0 ; i < nblocks ; i ++ ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[] final int index = newOffset + ( i << 2 ) ; final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; }
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; MST[rv.CRCR5Mutator]MSP[] case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
final int consumed = ( nblocks << 2 ) ; MST[rv.UOI2Mutator]MSP[] unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; } } public final int end () {
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; MST[rv.UOI4Mutator]MSP[] if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; } } public final int end () {
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.OBBN1Mutator]MSP[] } @Override @Deprecated
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.OBBN3Mutator]MSP[] } @Override @Deprecated
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; MST[rv.CRCR3Mutator]MSP[] case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
} totalLen += length ; MST[rv.AOD1Mutator]MSP[] if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[rv.CRCR5Mutator]MSP[] break; case 3 :
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[NonVoidMethodCallMutator]MSP[] break; case 3 :
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) { MST[rv.ROR2Mutator]MSP[]
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) { MST[rv.UOI1Mutator]MSP[]
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; newLength = length - consumed ; MST[rv.AOR2Mutator]MSP[] } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ;
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; newLength = length - consumed ; MST[rv.AOR4Mutator]MSP[] } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ;
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; MST[rv.ABSMutator]MSP[] if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; } } public final int end () {
return finalise ( hash , unprocessedLength , unprocessed , totalLen ) ; MST[rv.ABSMutator]MSP[] } int finalise ( final int hash , final int unprocessedLength , final byte [] unprocessed , final int totalLen ) { int result = hash ; int k1 = 0 ; switch ( unprocessedLength ) {
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[rv.UOI1Mutator]MSP[] break; case 3 :
public final void start ( final int seed ) { unprocessedLength = totalLen = 0 ; this . hash = seed ; MST[rv.UOI1Mutator]MSP[] } public final void add ( final byte [] data , final int offset , final int length ) { if ( length <= 0 ) { return;
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[rv.UOI2Mutator]MSP[] break; case 3 :
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.CRCR3Mutator]MSP[] } @Override @Deprecated
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; MST[rv.CRCR1Mutator]MSP[] k1 *= C1_32 ;
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.UOI4Mutator]MSP[] break; case 2 :
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; MST[rv.UOI2Mutator]MSP[] case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ; result ^= k1 ; } result ^= totalLen ; MST[rv.UOI1Mutator]MSP[] return fmix32 ( result ) ; }
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; MST[InlineConstantMutator]MSP[] case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.UOI2Mutator]MSP[] break; case 2 :
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.AOR1Mutator]MSP[] break; case 2 :
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[rv.ABSMutator]MSP[] break; case 3 :
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[InlineConstantMutator]MSP[] } @Override @Deprecated
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { MST[rv.CRCR2Mutator]MSP[] System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , unprocessed [ 2 ] , data [ offset ] ) ; MST[InlineConstantMutator]MSP[] break; default: throw new IllegalStateException ( lr_1 + unprocessedLength ) ; } hash = mix32 ( k , hash ) ;
for ( int i = 0 ; i < nblocks ; i ++ ) { final int index = newOffset + ( i << 2 ) ; MST[rv.CRCR6Mutator]MSP[] final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; }
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; MST[rv.UOI1Mutator]MSP[] k1 *= C1_32 ;
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , unprocessed [ 2 ] , data [ offset ] ) ; MST[rv.UOI1Mutator]MSP[] break; default: throw new IllegalStateException ( lr_1 + unprocessedLength ) ; } hash = mix32 ( k , hash ) ;
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.OBBN3Mutator]MSP[] } @Override @Deprecated
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , unprocessed [ 2 ] , data [ offset ] ) ; MST[rv.CRCR3Mutator]MSP[] break; default: throw new IllegalStateException ( lr_1 + unprocessedLength ) ; } hash = mix32 ( k , hash ) ;
for ( int i = 0 ; i < nblocks ; i ++ ) { MST[rv.CRCR1Mutator]MSP[] final int index = newOffset + ( i << 2 ) ; final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; }
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; MST[rv.CRCR6Mutator]MSP[] } } public final int end () {
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.UOI3Mutator]MSP[] break; case 2 :
for ( int i = 0 ; i < nblocks ; i ++ ) { final int index = newOffset + ( i << 2 ) ; MST[rv.UOI3Mutator]MSP[] final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; }
} totalLen += length ; MST[rv.UOI4Mutator]MSP[] if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.CRCR2Mutator]MSP[] } @Override @Deprecated
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.UOI1Mutator]MSP[] break; case 2 :
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; MST[rv.UOI3Mutator]MSP[] case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
final int consumed = BLOCK_SIZE - unprocessedLength ; MST[rv.AOD1Mutator]MSP[] newOffset = offset + consumed ; newLength = length - consumed ; } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ;
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , unprocessed [ 2 ] , data [ offset ] ) ; MST[rv.UOI3Mutator]MSP[] break; default: throw new IllegalStateException ( lr_1 + unprocessedLength ) ; } hash = mix32 ( k , hash ) ;
} totalLen += length ; MST[rv.AOR3Mutator]MSP[] if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; newLength = length - consumed ; } else { newOffset = offset ; newLength = length ; MST[rv.UOI2Mutator]MSP[] } final int nblocks = newLength >> 2 ;
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.ABSMutator]MSP[] } @Override @Deprecated
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { MST[rv.UOI1Mutator]MSP[] System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; MST[rv.CRCR3Mutator]MSP[] case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.AOR4Mutator]MSP[] break; case 2 :
return finalise ( hash , unprocessedLength , unprocessed , totalLen ) ; } int finalise ( final int hash , final int unprocessedLength , final byte [] unprocessed , final int totalLen ) { int result = hash ; MST[rv.UOI2Mutator]MSP[] int k1 = 0 ; switch ( unprocessedLength ) {
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ; MST[rv.UOI1Mutator]MSP[] result ^= k1 ; } result ^= totalLen ; return fmix32 ( result ) ; }
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; MST[rv.CRCR5Mutator]MSP[] case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; MST[rv.CRCR3Mutator]MSP[] case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.UOI3Mutator]MSP[] } @Override @Deprecated
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[MathMutator]MSP[] } @Override @Deprecated
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ; MST[rv.AOR3Mutator]MSP[]
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; MST[rv.ABSMutator]MSP[] unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
return finalise ( hash , unprocessedLength , unprocessed , totalLen ) ; MST[rv.UOI3Mutator]MSP[] } int finalise ( final int hash , final int unprocessedLength , final byte [] unprocessed , final int totalLen ) { int result = hash ; int k1 = 0 ; switch ( unprocessedLength ) {
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; MST[rv.UOI3Mutator]MSP[] unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; MST[rv.CRCR1Mutator]MSP[] k1 *= C2_32 ; result ^= k1 ; } result ^= totalLen ; return fmix32 ( result ) ; }
return finalise ( hash , unprocessedLength , unprocessed , totalLen ) ; MST[rv.ABSMutator]MSP[] } int finalise ( final int hash , final int unprocessedLength , final byte [] unprocessed , final int totalLen ) { int result = hash ; int k1 = 0 ; switch ( unprocessedLength ) {
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , unprocessed [ 2 ] , data [ offset ] ) ; break; default: throw new IllegalStateException ( lr_1 + unprocessedLength ) ; } hash = mix32 ( k , hash ) ; MST[rv.UOI2Mutator]MSP[]
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ; MST[MathMutator]MSP[] result ^= k1 ; } result ^= totalLen ; return fmix32 ( result ) ; }
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[rv.UOI1Mutator]MSP[] break; case 3 :
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ; MST[InlineConstantMutator]MSP[] result ^= k1 ; } result ^= totalLen ; return fmix32 ( result ) ; }
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; MST[rv.UOI1Mutator]MSP[] case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.CRCR5Mutator]MSP[] } @Override @Deprecated
for ( int i = 0 ; i < nblocks ; i ++ ) { final int index = newOffset + ( i << 2 ) ; MST[rv.UOI4Mutator]MSP[] final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; }
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; MST[rv.CRCR1Mutator]MSP[] k1 *= C1_32 ;
for ( int i = 0 ; i < nblocks ; i ++ ) { MST[rv.UOI2Mutator]MSP[] final int index = newOffset + ( i << 2 ) ; final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; }
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , unprocessed [ 2 ] , data [ offset ] ) ; MST[rv.ABSMutator]MSP[] break; default: throw new IllegalStateException ( lr_1 + unprocessedLength ) ; } hash = mix32 ( k , hash ) ;
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , unprocessed [ 2 ] , data [ offset ] ) ; break; default: throw new IllegalStateException ( lr_1 + unprocessedLength ) ; } hash = mix32 ( k , hash ) ; MST[rv.UOI2Mutator]MSP[]
for ( int i = 0 ; i < nblocks ; i ++ ) { final int index = newOffset + ( i << 2 ) ; final int k = getLittleEndianInt ( data , index ) ; MST[rv.UOI1Mutator]MSP[] hash = mix32 ( k , hash ) ; }
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.CRCR3Mutator]MSP[] } @Override @Deprecated
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.CRCR2Mutator]MSP[] } @Override @Deprecated
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; MST[MathMutator]MSP[] return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
for ( int i = 0 ; i < nblocks ; i ++ ) { final int index = newOffset + ( i << 2 ) ; MST[rv.ABSMutator]MSP[] final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; }
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; MST[MathMutator]MSP[] case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { MST[NegateConditionalsMutator]MSP[] System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
return finalise ( hash , unprocessedLength , unprocessed , totalLen ) ; } int finalise ( final int hash , final int unprocessedLength , final byte [] unprocessed , final int totalLen ) { int result = hash ; int k1 = 0 ; switch ( unprocessedLength ) { MST[experimental.RemoveSwitchMutator_0]MSP[]
return finalise ( hash , unprocessedLength , unprocessed , totalLen ) ; } int finalise ( final int hash , final int unprocessedLength , final byte [] unprocessed , final int totalLen ) { int result = hash ; int k1 = 0 ; switch ( unprocessedLength ) { MST[experimental.RemoveSwitchMutator_2]MSP[]
return finalise ( hash , unprocessedLength , unprocessed , totalLen ) ; } int finalise ( final int hash , final int unprocessedLength , final byte [] unprocessed , final int totalLen ) { int result = hash ; int k1 = 0 ; switch ( unprocessedLength ) { MST[experimental.RemoveSwitchMutator_1]MSP[]
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.ABSMutator]MSP[] break; case 2 :
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; MST[InlineConstantMutator]MSP[] case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.UOI2Mutator]MSP[] break; case 2 :
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; newLength = length - consumed ; MST[rv.UOI3Mutator]MSP[] } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ;
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[InlineConstantMutator]MSP[] } @Override @Deprecated
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; } } public final int end () {
for ( int i = 0 ; i < nblocks ; i ++ ) { final int index = newOffset + ( i << 2 ) ; final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; MST[rv.ABSMutator]MSP[] }
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.CRCR5Mutator]MSP[] break; case 2 :
return finalise ( hash , unprocessedLength , unprocessed , totalLen ) ; } int finalise ( final int hash , final int unprocessedLength , final byte [] unprocessed , final int totalLen ) { int result = hash ; int k1 = 0 ; MST[rv.CRCR5Mutator]MSP[] switch ( unprocessedLength ) {
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { MST[rv.UOI1Mutator]MSP[] System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; } } public final int end () {
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[rv.UOI3Mutator]MSP[] break; case 3 :
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; MST[rv.AOR4Mutator]MSP[] if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; } } public final int end () {
for ( int i = 0 ; i < nblocks ; i ++ ) { final int index = newOffset + ( i << 2 ) ; final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; MST[rv.UOI3Mutator]MSP[] }
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[MathMutator]MSP[] } @Override @Deprecated
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; MST[rv.CRCR6Mutator]MSP[] k1 *= C2_32 ; result ^= k1 ; } result ^= totalLen ; return fmix32 ( result ) ; }
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.CRCR1Mutator]MSP[] break; case 2 :
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; MST[rv.UOI1Mutator]MSP[] newLength = length - consumed ; } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ;
for ( int i = 0 ; i < nblocks ; i ++ ) { MST[NegateConditionalsMutator]MSP[] final int index = newOffset + ( i << 2 ) ; final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; }
for ( int i = 0 ; i < nblocks ; i ++ ) { final int index = newOffset + ( i << 2 ) ; final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; MST[ArgumentPropagationMutator]MSP[] }
for ( int i = 0 ; i < nblocks ; i ++ ) { final int index = newOffset + ( i << 2 ) ; MST[rv.AOR2Mutator]MSP[] final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; }
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , unprocessed [ 2 ] , data [ offset ] ) ; MST[rv.UOI4Mutator]MSP[] break; default: throw new IllegalStateException ( lr_1 + unprocessedLength ) ; } hash = mix32 ( k , hash ) ;
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; MST[rv.UOI4Mutator]MSP[] } } public final int end () {
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { MST[rv.AOD2Mutator]MSP[] System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.UOI2Mutator]MSP[] break; case 2 :
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; MST[rv.CRCR1Mutator]MSP[] case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; MST[rv.OBBN2Mutator]MSP[] k1 *= C1_32 ;
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.UOI4Mutator]MSP[] break; case 2 :
final int consumed = BLOCK_SIZE - unprocessedLength ; MST[rv.CRCR5Mutator]MSP[] newOffset = offset + consumed ; newLength = length - consumed ; } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ;
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; MST[rv.UOI4Mutator]MSP[] k1 *= C1_32 ;
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; MST[rv.UOI3Mutator]MSP[] k1 *= C1_32 ;
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; newLength = length - consumed ; MST[rv.UOI4Mutator]MSP[] } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ;
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[rv.ABSMutator]MSP[] break; case 3 :
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; MST[rv.AOR1Mutator]MSP[] } } public final int end () {
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { MST[rv.CRCR3Mutator]MSP[] System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , unprocessed [ 2 ] , data [ offset ] ) ; MST[rv.UOI2Mutator]MSP[] break; default: throw new IllegalStateException ( lr_1 + unprocessedLength ) ; } hash = mix32 ( k , hash ) ;
for ( int i = 0 ; i < nblocks ; i ++ ) { final int index = newOffset + ( i << 2 ) ; MST[rv.CRCR5Mutator]MSP[] final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; }
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) { MST[rv.ABSMutator]MSP[]
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[rv.UOI4Mutator]MSP[] break; case 3 :
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ; MST[rv.CRCR1Mutator]MSP[] result ^= k1 ; } result ^= totalLen ; return fmix32 ( result ) ; }
for ( int i = 0 ; i < nblocks ; i ++ ) { final int index = newOffset + ( i << 2 ) ; final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; MST[rv.UOI4Mutator]MSP[] }
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , unprocessed [ 2 ] , data [ offset ] ) ; MST[rv.CRCR4Mutator]MSP[] break; default: throw new IllegalStateException ( lr_1 + unprocessedLength ) ; } hash = mix32 ( k , hash ) ;
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; MST[rv.CRCR5Mutator]MSP[] } } public final int end () {
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; MST[rv.UOI3Mutator]MSP[] newLength = length - consumed ; } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ;
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; newLength = length - consumed ; } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ; MST[rv.CRCR1Mutator]MSP[]
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { MST[MathMutator]MSP[] System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; MST[rv.CRCR4Mutator]MSP[] k1 *= C1_32 ;
for ( int i = 0 ; i < nblocks ; i ++ ) { MST[rv.ROR5Mutator]MSP[] final int index = newOffset + ( i << 2 ) ; final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; }
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.ABSMutator]MSP[] break; case 2 :
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.CRCR1Mutator]MSP[] } @Override @Deprecated
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.UOI3Mutator]MSP[] break; case 2 :
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.CRCR6Mutator]MSP[] } @Override @Deprecated
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.CRCR3Mutator]MSP[] } @Override @Deprecated
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.AOR4Mutator]MSP[] break; case 2 :
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; MST[rv.CRCR6Mutator]MSP[] case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , unprocessed [ 2 ] , data [ offset ] ) ; MST[InlineConstantMutator]MSP[] break; default: throw new IllegalStateException ( lr_1 + unprocessedLength ) ; } hash = mix32 ( k , hash ) ;
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.OBBN3Mutator]MSP[] } @Override @Deprecated
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.OBBN2Mutator]MSP[] } @Override @Deprecated
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) { MST[rv.UOI2Mutator]MSP[]
return finalise ( hash , unprocessedLength , unprocessed , totalLen ) ; } int finalise ( final int hash , final int unprocessedLength , final byte [] unprocessed , final int totalLen ) { int result = hash ; int k1 = 0 ; MST[rv.CRCR3Mutator]MSP[] switch ( unprocessedLength ) {
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ; MST[rv.UOI2Mutator]MSP[]
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; newLength = length - consumed ; } else { newOffset = offset ; MST[rv.UOI3Mutator]MSP[] newLength = length ; } final int nblocks = newLength >> 2 ;
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ; result ^= k1 ; } result ^= totalLen ; return fmix32 ( result ) ; MST[PrimitiveReturnsMutator]MSP[] }
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; MST[rv.UOI4Mutator]MSP[] unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; MST[rv.AOR2Mutator]MSP[] if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; } } public final int end () {
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) { MST[rv.ROR3Mutator]MSP[]
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[InlineConstantMutator]MSP[] break; case 2 :
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , unprocessed [ 2 ] , data [ offset ] ) ; MST[rv.ABSMutator]MSP[] break; default: throw new IllegalStateException ( lr_1 + unprocessedLength ) ; } hash = mix32 ( k , hash ) ;
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[rv.UOI1Mutator]MSP[] break; case 3 :
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[rv.UOI2Mutator]MSP[] break; case 3 :
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ; MST[rv.CRCR2Mutator]MSP[]
return finalise ( hash , unprocessedLength , unprocessed , totalLen ) ; } int finalise ( final int hash , final int unprocessedLength , final byte [] unprocessed , final int totalLen ) { int result = hash ; int k1 = 0 ; switch ( unprocessedLength ) { MST[rv.UOI4Mutator]MSP[]
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { MST[rv.UOI2Mutator]MSP[] System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.CRCR3Mutator]MSP[] } @Override @Deprecated
return finalise ( hash , unprocessedLength , unprocessed , totalLen ) ; MST[rv.ABSMutator]MSP[] } int finalise ( final int hash , final int unprocessedLength , final byte [] unprocessed , final int totalLen ) { int result = hash ; int k1 = 0 ; switch ( unprocessedLength ) {
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; MST[rv.UOI1Mutator]MSP[] case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.CRCR6Mutator]MSP[] } @Override @Deprecated
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.AOR2Mutator]MSP[] break; case 2 :
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; MST[rv.CRCR4Mutator]MSP[] case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.ABSMutator]MSP[] break; case 2 :
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; newLength = length - consumed ; } else { newOffset = offset ; newLength = length ; MST[rv.UOI3Mutator]MSP[] } final int nblocks = newLength >> 2 ;
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[InlineConstantMutator]MSP[] break; case 3 :
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; MST[rv.UOI1Mutator]MSP[] } } public final int end () {
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.UOI2Mutator]MSP[] break; case 2 :
for ( int i = 0 ; i < nblocks ; i ++ ) { MST[rv.UOI4Mutator]MSP[] final int index = newOffset + ( i << 2 ) ; final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; }
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ; MST[rv.AOR2Mutator]MSP[] result ^= k1 ; } result ^= totalLen ; return fmix32 ( result ) ; }
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; MST[rv.UOI1Mutator]MSP[] unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ; MST[InlineConstantMutator]MSP[]
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { MST[rv.UOI2Mutator]MSP[] System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; } } public final int end () {
return finalise ( hash , unprocessedLength , unprocessed , totalLen ) ; } int finalise ( final int hash , final int unprocessedLength , final byte [] unprocessed , final int totalLen ) { int result = hash ; int k1 = 0 ; MST[rv.CRCR6Mutator]MSP[] switch ( unprocessedLength ) {
final int consumed = BLOCK_SIZE - unprocessedLength ; MST[rv.UOI1Mutator]MSP[] newOffset = offset + consumed ; newLength = length - consumed ; } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ;
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; MST[rv.UOI3Mutator]MSP[] return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[MathMutator]MSP[] } @Override @Deprecated
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { MST[MathMutator]MSP[] System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; MST[rv.UOI2Mutator]MSP[] newLength = length - consumed ; } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ;
public final void start ( final int seed ) { unprocessedLength = totalLen = 0 ; this . hash = seed ; } public final void add ( final byte [] data , final int offset , final int length ) { if ( length <= 0 ) { MST[rv.ROR4Mutator]MSP[] return;
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ; result ^= k1 ; } result ^= totalLen ; MST[rv.UOI4Mutator]MSP[] return fmix32 ( result ) ; }
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ; result ^= k1 ; MST[rv.UOI2Mutator]MSP[] } result ^= totalLen ; return fmix32 ( result ) ; }
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; MST[rv.OBBN2Mutator]MSP[] case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.CRCR1Mutator]MSP[] } @Override @Deprecated
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ; result ^= k1 ; } result ^= totalLen ; return fmix32 ( result ) ; MST[rv.UOI1Mutator]MSP[] }
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , unprocessed [ 2 ] , data [ offset ] ) ; break; default: throw new IllegalStateException ( lr_1 + unprocessedLength ) ; } hash = mix32 ( k , hash ) ; MST[rv.UOI3Mutator]MSP[]
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ; MST[rv.ABSMutator]MSP[]
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.CRCR4Mutator]MSP[] } @Override @Deprecated
public final void start ( final int seed ) { unprocessedLength = totalLen = 0 ; MST[rv.CRCR1Mutator]MSP[] this . hash = seed ; } public final void add ( final byte [] data , final int offset , final int length ) { if ( length <= 0 ) { return;
for ( int i = 0 ; i < nblocks ; i ++ ) { MST[rv.UOI3Mutator]MSP[] final int index = newOffset + ( i << 2 ) ; final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; }
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; MST[rv.CRCR3Mutator]MSP[] case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.CRCR3Mutator]MSP[] } @Override @Deprecated
return finalise ( hash , unprocessedLength , unprocessed , totalLen ) ; } int finalise ( final int hash , final int unprocessedLength , final byte [] unprocessed , final int totalLen ) { int result = hash ; MST[rv.ABSMutator]MSP[] int k1 = 0 ; switch ( unprocessedLength ) {
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.CRCR6Mutator]MSP[] } @Override @Deprecated
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.UOI3Mutator]MSP[] break; case 2 :
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.CRCR1Mutator]MSP[] break; case 2 :
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; MST[rv.ABSMutator]MSP[] unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
return finalise ( hash , unprocessedLength , unprocessed , totalLen ) ; MST[rv.UOI2Mutator]MSP[] } int finalise ( final int hash , final int unprocessedLength , final byte [] unprocessed , final int totalLen ) { int result = hash ; int k1 = 0 ; switch ( unprocessedLength ) {
public final void start ( final int seed ) { unprocessedLength = totalLen = 0 ; this . hash = seed ; } public final void add ( final byte [] data , final int offset , final int length ) { if ( length <= 0 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[] return;
public final void start ( final int seed ) { unprocessedLength = totalLen = 0 ; this . hash = seed ; MST[experimental.MemberVariableMutator]MSP[] } public final void add ( final byte [] data , final int offset , final int length ) { if ( length <= 0 ) { return;
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ; MST[rv.CRCR4Mutator]MSP[] result ^= k1 ; } result ^= totalLen ; return fmix32 ( result ) ; }
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ; MST[rv.AOD1Mutator]MSP[]
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[rv.UOI1Mutator]MSP[] break; case 3 :
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[rv.UOI2Mutator]MSP[] break; case 3 :
final int consumed = ( nblocks << 2 ) ; MST[rv.UOI3Mutator]MSP[] unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; } } public final int end () {
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.OBBN1Mutator]MSP[] } @Override @Deprecated
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ; result ^= k1 ; } result ^= totalLen ; return fmix32 ( result ) ; MST[ArgumentPropagationMutator]MSP[] }
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.CRCR5Mutator]MSP[] break; case 2 :
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[rv.UOI3Mutator]MSP[] break; case 3 :
for ( int i = 0 ; i < nblocks ; i ++ ) { MST[InlineConstantMutator]MSP[] final int index = newOffset + ( i << 2 ) ; final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; }
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; MST[MathMutator]MSP[] case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ; result ^= k1 ; MST[rv.UOI1Mutator]MSP[] } result ^= totalLen ; return fmix32 ( result ) ; }
int k = - 1 ; MST[rv.CRCR6Mutator]MSP[] switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; break; case 2 :
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , unprocessed [ 2 ] , data [ offset ] ) ; MST[rv.CRCR4Mutator]MSP[] break; default: throw new IllegalStateException ( lr_1 + unprocessedLength ) ; } hash = mix32 ( k , hash ) ;
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; MST[rv.AOD1Mutator]MSP[] newLength = length - consumed ; } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ;
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ; result ^= k1 ; } result ^= totalLen ; MST[rv.UOI3Mutator]MSP[] return fmix32 ( result ) ; }
final int consumed = BLOCK_SIZE - unprocessedLength ; MST[rv.CRCR2Mutator]MSP[] newOffset = offset + consumed ; newLength = length - consumed ; } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ;
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[]
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; MST[rv.UOI2Mutator]MSP[] k1 *= C2_32 ; result ^= k1 ; } result ^= totalLen ; return fmix32 ( result ) ; }
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , unprocessed [ 2 ] , data [ offset ] ) ; MST[rv.UOI1Mutator]MSP[] break; default: throw new IllegalStateException ( lr_1 + unprocessedLength ) ; } hash = mix32 ( k , hash ) ;
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; MST[rv.ABSMutator]MSP[] case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; MST[rv.CRCR6Mutator]MSP[] case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.ABSMutator]MSP[] } @Override @Deprecated
public final void start ( final int seed ) { unprocessedLength = totalLen = 0 ; this . hash = seed ; } public final void add ( final byte [] data , final int offset , final int length ) { if ( length <= 0 ) { MST[rv.UOI3Mutator]MSP[] return;
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[rv.CRCR1Mutator]MSP[] break; case 3 :
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; MST[rv.UOI1Mutator]MSP[] } } public final int end () {
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; MST[rv.AOR4Mutator]MSP[] } } public final int end () {
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.UOI1Mutator]MSP[] break; case 2 :
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) { MST[ConditionalsBoundaryMutator]MSP[]
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , unprocessed [ 2 ] , data [ offset ] ) ; MST[rv.UOI4Mutator]MSP[] break; default: throw new IllegalStateException ( lr_1 + unprocessedLength ) ; } hash = mix32 ( k , hash ) ;
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; MST[rv.UOI2Mutator]MSP[] if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; } } public final int end () {
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; MST[InlineConstantMutator]MSP[] k1 *= C2_32 ; result ^= k1 ; } result ^= totalLen ; return fmix32 ( result ) ; }
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; } } public final int end () {
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; MST[InlineConstantMutator]MSP[] } } public final int end () {
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; MST[rv.AOD2Mutator]MSP[] } } public final int end () {
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ; result ^= k1 ; MST[MathMutator]MSP[] } result ^= totalLen ; return fmix32 ( result ) ; }
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; MST[rv.UOI4Mutator]MSP[] return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
public final void start ( final int seed ) { unprocessedLength = totalLen = 0 ; this . hash = seed ; MST[rv.UOI3Mutator]MSP[] } public final void add ( final byte [] data , final int offset , final int length ) { if ( length <= 0 ) { return;
for ( int i = 0 ; i < nblocks ; i ++ ) { final int index = newOffset + ( i << 2 ) ; MST[InlineConstantMutator]MSP[] final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; }
final int consumed = BLOCK_SIZE - unprocessedLength ; MST[rv.AOR1Mutator]MSP[] newOffset = offset + consumed ; newLength = length - consumed ; } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ;
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[rv.AOD1Mutator]MSP[] break; case 3 :
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , unprocessed [ 2 ] , data [ offset ] ) ; MST[rv.ABSMutator]MSP[] break; default: throw new IllegalStateException ( lr_1 + unprocessedLength ) ; } hash = mix32 ( k , hash ) ;
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ; result ^= k1 ; } result ^= totalLen ; return fmix32 ( result ) ; MST[rv.UOI4Mutator]MSP[] }
final int consumed = BLOCK_SIZE - unprocessedLength ; MST[InlineConstantMutator]MSP[] newOffset = offset + consumed ; newLength = length - consumed ; } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ;
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { MST[rv.AOR4Mutator]MSP[] System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { MST[rv.ROR5Mutator]MSP[] System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; } } public final int end () {
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[rv.CRCR4Mutator]MSP[] break; case 3 :
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , unprocessed [ 2 ] , data [ offset ] ) ; MST[rv.UOI2Mutator]MSP[] break; default: throw new IllegalStateException ( lr_1 + unprocessedLength ) ; } hash = mix32 ( k , hash ) ;
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; MST[rv.CRCR1Mutator]MSP[] case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { MST[rv.CRCR6Mutator]MSP[] System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; MST[InlineConstantMutator]MSP[] k1 *= C1_32 ;
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; newLength = length - consumed ; MST[rv.UOI1Mutator]MSP[] } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ;
for ( int i = 0 ; i < nblocks ; i ++ ) { final int index = newOffset + ( i << 2 ) ; MST[rv.CRCR2Mutator]MSP[] final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; }
public final void start ( final int seed ) { unprocessedLength = totalLen = 0 ; MST[experimental.MemberVariableMutator]MSP[] this . hash = seed ; } public final void add ( final byte [] data , final int offset , final int length ) { if ( length <= 0 ) { return;
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[rv.UOI1Mutator]MSP[] break; case 3 :
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[rv.UOI3Mutator]MSP[] break; case 3 :
for ( int i = 0 ; i < nblocks ; i ++ ) { final int index = newOffset + ( i << 2 ) ; final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; MST[rv.UOI1Mutator]MSP[] }
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ; MST[rv.CRCR6Mutator]MSP[] result ^= k1 ; } result ^= totalLen ; return fmix32 ( result ) ; }
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; MST[rv.ABSMutator]MSP[] return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.OBBN1Mutator]MSP[] } @Override @Deprecated
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; MST[rv.AOR3Mutator]MSP[] newLength = length - consumed ; } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ;
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; MST[rv.CRCR4Mutator]MSP[] k1 *= C2_32 ; result ^= k1 ; } result ^= totalLen ; return fmix32 ( result ) ; }
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; MST[rv.OBBN2Mutator]MSP[] case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
return finalise ( hash , unprocessedLength , unprocessed , totalLen ) ; } int finalise ( final int hash , final int unprocessedLength , final byte [] unprocessed , final int totalLen ) { int result = hash ; int k1 = 0 ; switch ( unprocessedLength ) { MST[rv.UOI2Mutator]MSP[]
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; MST[rv.OBBN1Mutator]MSP[] case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
for ( int i = 0 ; i < nblocks ; i ++ ) { final int index = newOffset + ( i << 2 ) ; MST[rv.UOI1Mutator]MSP[] final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; }
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; MST[rv.CRCR1Mutator]MSP[] case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { MST[rv.UOI4Mutator]MSP[] System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
} totalLen += length ; MST[rv.AOR1Mutator]MSP[] if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
final int consumed = ( nblocks << 2 ) ; MST[rv.CRCR6Mutator]MSP[] unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; } } public final int end () {
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , unprocessed [ 2 ] , data [ offset ] ) ; MST[rv.UOI1Mutator]MSP[] break; default: throw new IllegalStateException ( lr_1 + unprocessedLength ) ; } hash = mix32 ( k , hash ) ;
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; MST[rv.CRCR6Mutator]MSP[] case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.UOI4Mutator]MSP[] break; case 2 :
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.UOI1Mutator]MSP[] break; case 2 :
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ; MST[rv.UOI4Mutator]MSP[] result ^= k1 ; } result ^= totalLen ; return fmix32 ( result ) ; }
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[rv.ABSMutator]MSP[] break; case 3 :
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; MST[rv.CRCR1Mutator]MSP[] case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { MST[rv.UOI4Mutator]MSP[] System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; } } public final int end () {
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.AOD2Mutator]MSP[] break; case 2 :
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; MST[rv.UOI1Mutator]MSP[] unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.UOI1Mutator]MSP[] } @Override @Deprecated
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { MST[rv.ROR1Mutator]MSP[] System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; MST[rv.UOI2Mutator]MSP[] unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[rv.AOR3Mutator]MSP[] break; case 3 :
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.ABSMutator]MSP[] break; case 2 :
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; MST[NonVoidMethodCallMutator]MSP[] k1 *= C2_32 ; result ^= k1 ; } result ^= totalLen ; return fmix32 ( result ) ; }
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.UOI2Mutator]MSP[] break; case 2 :
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.CRCR3Mutator]MSP[] } @Override @Deprecated
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { MST[rv.UOI3Mutator]MSP[] System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
for ( int i = 0 ; i < nblocks ; i ++ ) { final int index = newOffset + ( i << 2 ) ; final int k = getLittleEndianInt ( data , index ) ; MST[rv.UOI4Mutator]MSP[] hash = mix32 ( k , hash ) ; }
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { MST[rv.AOR4Mutator]MSP[] System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { MST[rv.ABSMutator]MSP[] System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; } } public final int end () {
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.CRCR1Mutator]MSP[] } @Override @Deprecated
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[rv.CRCR5Mutator]MSP[] break; case 3 :
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { MST[rv.ABSMutator]MSP[] System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
for ( int i = 0 ; i < nblocks ; i ++ ) { MST[rv.ROR2Mutator]MSP[] final int index = newOffset + ( i << 2 ) ; final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; }
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; MST[rv.CRCR1Mutator]MSP[] case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
} totalLen += length ; MST[rv.UOI1Mutator]MSP[] if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; MST[experimental.MemberVariableMutator]MSP[] if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; } } public final int end () {
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.UOI4Mutator]MSP[] } @Override @Deprecated
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.UOI3Mutator]MSP[] } @Override @Deprecated
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; MST[rv.CRCR6Mutator]MSP[] case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[ReturnValsMutator]MSP[] } @Override @Deprecated
for ( int i = 0 ; i < nblocks ; i ++ ) { final int index = newOffset + ( i << 2 ) ; final int k = getLittleEndianInt ( data , index ) ; MST[rv.ABSMutator]MSP[] hash = mix32 ( k , hash ) ; }
return finalise ( hash , unprocessedLength , unprocessed , totalLen ) ; MST[rv.UOI2Mutator]MSP[] } int finalise ( final int hash , final int unprocessedLength , final byte [] unprocessed , final int totalLen ) { int result = hash ; int k1 = 0 ; switch ( unprocessedLength ) {
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) { MST[rv.ROR5Mutator]MSP[]
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; MST[rv.UOI3Mutator]MSP[] case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
for ( int i = 0 ; i < nblocks ; i ++ ) { final int index = newOffset + ( i << 2 ) ; final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; MST[rv.UOI1Mutator]MSP[] }
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.CRCR6Mutator]MSP[] break; case 2 :
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; MST[rv.ABSMutator]MSP[] newLength = length - consumed ; } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ;
for ( int i = 0 ; i < nblocks ; i ++ ) { final int index = newOffset + ( i << 2 ) ; MST[MathMutator]MSP[] final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; }
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; MST[rv.UOI4Mutator]MSP[] case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.UOI2Mutator]MSP[] break; case 2 :
int k = - 1 ; MST[rv.CRCR5Mutator]MSP[] switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; break; case 2 :
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , unprocessed [ 2 ] , data [ offset ] ) ; MST[rv.CRCR6Mutator]MSP[] break; default: throw new IllegalStateException ( lr_1 + unprocessedLength ) ; } hash = mix32 ( k , hash ) ;
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) { MST[rv.ROR1Mutator]MSP[]
int k = - 1 ; MST[rv.CRCR1Mutator]MSP[] switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; break; case 2 :
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; MST[rv.ABSMutator]MSP[] } } public final int end () {
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , unprocessed [ 2 ] , data [ offset ] ) ; MST[rv.UOI2Mutator]MSP[] break; default: throw new IllegalStateException ( lr_1 + unprocessedLength ) ; } hash = mix32 ( k , hash ) ;
public final void start ( final int seed ) { unprocessedLength = totalLen = 0 ; this . hash = seed ; } public final void add ( final byte [] data , final int offset , final int length ) { if ( length <= 0 ) { MST[rv.UOI4Mutator]MSP[] return;
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ; MST[rv.AOD2Mutator]MSP[] result ^= k1 ; } result ^= totalLen ; return fmix32 ( result ) ; }
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ; result ^= k1 ; } result ^= totalLen ; MST[rv.ABSMutator]MSP[] return fmix32 ( result ) ; }
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; MST[rv.UOI2Mutator]MSP[] } } public final int end () {
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ; result ^= k1 ; MST[rv.UOI4Mutator]MSP[] } result ^= totalLen ; return fmix32 ( result ) ; }
final int consumed = BLOCK_SIZE - unprocessedLength ; MST[rv.CRCR3Mutator]MSP[] newOffset = offset + consumed ; newLength = length - consumed ; } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ;
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { MST[rv.CRCR5Mutator]MSP[] System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; MST[rv.UOI1Mutator]MSP[] k1 *= C1_32 ;
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.UOI4Mutator]MSP[] } @Override @Deprecated
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { MST[rv.CRCR1Mutator]MSP[] System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; MST[rv.UOI2Mutator]MSP[] k1 *= C1_32 ;
for ( int i = 0 ; i < nblocks ; i ++ ) { final int index = newOffset + ( i << 2 ) ; MST[rv.CRCR3Mutator]MSP[] final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; }
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; MST[rv.CRCR3Mutator]MSP[] } } public final int end () {
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[rv.UOI2Mutator]MSP[] break; case 3 :
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.OBBN2Mutator]MSP[] } @Override @Deprecated
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , unprocessed [ 2 ] , data [ offset ] ) ; MST[rv.CRCR2Mutator]MSP[] break; default: throw new IllegalStateException ( lr_1 + unprocessedLength ) ; } hash = mix32 ( k , hash ) ;
for ( int i = 0 ; i < nblocks ; i ++ ) { final int index = newOffset + ( i << 2 ) ; final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; MST[rv.UOI2Mutator]MSP[] }
for ( int i = 0 ; i < nblocks ; i ++ ) { final int index = newOffset + ( i << 2 ) ; MST[MathMutator]MSP[] final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; }
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; MST[rv.UOI1Mutator]MSP[] newLength = length - consumed ; } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ;
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.OBBN3Mutator]MSP[] } @Override @Deprecated
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.UOI1Mutator]MSP[] break; case 2 :
for ( int i = 0 ; i < nblocks ; i ++ ) { MST[rv.UOI1Mutator]MSP[] final int index = newOffset + ( i << 2 ) ; final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; }
for ( int i = 0 ; i < nblocks ; i ++ ) { final int index = newOffset + ( i << 2 ) ; MST[rv.UOI3Mutator]MSP[] final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; }
final int consumed = BLOCK_SIZE - unprocessedLength ; MST[rv.AOR4Mutator]MSP[] newOffset = offset + consumed ; newLength = length - consumed ; } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ;
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { MST[rv.UOI4Mutator]MSP[] System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { MST[rv.AOR2Mutator]MSP[] System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ; result ^= k1 ; } result ^= totalLen ; MST[rv.UOI2Mutator]MSP[] return fmix32 ( result ) ; }
int k = - 1 ; switch ( unprocessedLength ) { MST[rv.ABSMutator]MSP[] case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; break; case 2 :
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; MST[rv.OBBN1Mutator]MSP[] case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , unprocessed [ 2 ] , data [ offset ] ) ; MST[rv.UOI3Mutator]MSP[] break; default: throw new IllegalStateException ( lr_1 + unprocessedLength ) ; } hash = mix32 ( k , hash ) ;
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; MST[rv.CRCR4Mutator]MSP[] case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
public final void start ( final int seed ) { unprocessedLength = totalLen = 0 ; MST[rv.CRCR3Mutator]MSP[] this . hash = seed ; } public final void add ( final byte [] data , final int offset , final int length ) { if ( length <= 0 ) { return;
final int consumed = ( nblocks << 2 ) ; MST[rv.UOI1Mutator]MSP[] unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; } } public final int end () {
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[rv.CRCR6Mutator]MSP[] break; case 3 :
return finalise ( hash , unprocessedLength , unprocessed , totalLen ) ; MST[rv.UOI4Mutator]MSP[] } int finalise ( final int hash , final int unprocessedLength , final byte [] unprocessed , final int totalLen ) { int result = hash ; int k1 = 0 ; switch ( unprocessedLength ) {
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { MST[rv.ROR2Mutator]MSP[] System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , unprocessed [ 2 ] , data [ offset ] ) ; break; default: throw new IllegalStateException ( lr_1 + unprocessedLength ) ; } hash = mix32 ( k , hash ) ; MST[rv.UOI1Mutator]MSP[]
return finalise ( hash , unprocessedLength , unprocessed , totalLen ) ; MST[ReturnValsMutator]MSP[] } int finalise ( final int hash , final int unprocessedLength , final byte [] unprocessed , final int totalLen ) { int result = hash ; int k1 = 0 ; switch ( unprocessedLength ) {
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; MST[rv.ABSMutator]MSP[] k1 *= C1_32 ;
} totalLen += length ; MST[MathMutator]MSP[] if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[rv.UOI1Mutator]MSP[] break; case 3 :
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; newLength = length - consumed ; MST[rv.AOD1Mutator]MSP[] } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ;
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.CRCR1Mutator]MSP[] } @Override @Deprecated
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.UOI2Mutator]MSP[] break; case 2 :
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; MST[rv.UOI4Mutator]MSP[] case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; newLength = length - consumed ; } else { newOffset = offset ; newLength = length ; MST[rv.UOI1Mutator]MSP[] } final int nblocks = newLength >> 2 ;
final int consumed = ( nblocks << 2 ) ; MST[rv.CRCR5Mutator]MSP[] unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; } } public final int end () {
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , unprocessed [ 2 ] , data [ offset ] ) ; MST[rv.UOI2Mutator]MSP[] break; default: throw new IllegalStateException ( lr_1 + unprocessedLength ) ; } hash = mix32 ( k , hash ) ;
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; MST[MathMutator]MSP[] case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.ABSMutator]MSP[] break; case 2 :
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; MST[rv.UOI4Mutator]MSP[] } } public final int end () {
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ; MST[rv.AOR3Mutator]MSP[] result ^= k1 ; } result ^= totalLen ; return fmix32 ( result ) ; }
for ( int i = 0 ; i < nblocks ; i ++ ) { MST[rv.ABSMutator]MSP[] final int index = newOffset + ( i << 2 ) ; final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; }
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ; MST[rv.UOI2Mutator]MSP[] result ^= k1 ; } result ^= totalLen ; return fmix32 ( result ) ; }
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; MST[rv.UOI1Mutator]MSP[] return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ; MST[MathMutator]MSP[]
return finalise ( hash , unprocessedLength , unprocessed , totalLen ) ; MST[rv.UOI1Mutator]MSP[] } int finalise ( final int hash , final int unprocessedLength , final byte [] unprocessed , final int totalLen ) { int result = hash ; int k1 = 0 ; switch ( unprocessedLength ) {
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.CRCR5Mutator]MSP[] break; case 2 :
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[rv.UOI4Mutator]MSP[] break; case 3 :
for ( int i = 0 ; i < nblocks ; i ++ ) { final int index = newOffset + ( i << 2 ) ; final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; MST[rv.UOI2Mutator]MSP[] }
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) { MST[NegateConditionalsMutator]MSP[]
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; MST[rv.CRCR5Mutator]MSP[] k1 *= C2_32 ; result ^= k1 ; } result ^= totalLen ; return fmix32 ( result ) ; }
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; MST[rv.ABSMutator]MSP[] return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
for ( int i = 0 ; i < nblocks ; i ++ ) { final int index = newOffset + ( i << 2 ) ; final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; MST[NonVoidMethodCallMutator]MSP[] }
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.CRCR6Mutator]MSP[] } @Override @Deprecated
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.UOI3Mutator]MSP[] break; case 2 :
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; newLength = length - consumed ; } else { newOffset = offset ; newLength = length ; MST[rv.ABSMutator]MSP[] } final int nblocks = newLength >> 2 ;
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; MST[rv.CRCR5Mutator]MSP[] k1 *= C1_32 ;
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { MST[rv.AOR2Mutator]MSP[] System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.CRCR2Mutator]MSP[] } @Override @Deprecated
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; MST[rv.UOI3Mutator]MSP[] case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.CRCR1Mutator]MSP[] } @Override @Deprecated
return finalise ( hash , unprocessedLength , unprocessed , totalLen ) ; } int finalise ( final int hash , final int unprocessedLength , final byte [] unprocessed , final int totalLen ) { int result = hash ; int k1 = 0 ; switch ( unprocessedLength ) { MST[rv.ABSMutator]MSP[]
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ; MST[rv.AOR4Mutator]MSP[]
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; MST[rv.UOI1Mutator]MSP[] } } public final int end () {
for ( int i = 0 ; i < nblocks ; i ++ ) { MST[rv.ROR3Mutator]MSP[] final int index = newOffset + ( i << 2 ) ; final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; }
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; MST[rv.UOI3Mutator]MSP[] if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; } } public final int end () {
return finalise ( hash , unprocessedLength , unprocessed , totalLen ) ; } int finalise ( final int hash , final int unprocessedLength , final byte [] unprocessed , final int totalLen ) { int result = hash ; int k1 = 0 ; MST[rv.CRCR1Mutator]MSP[] switch ( unprocessedLength ) {
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[MathMutator]MSP[] } @Override @Deprecated
} totalLen += length ; MST[rv.AOD2Mutator]MSP[] if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.UOI2Mutator]MSP[] } @Override @Deprecated
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , unprocessed [ 2 ] , data [ offset ] ) ; break; default: throw new IllegalStateException ( lr_1 + unprocessedLength ) ; } hash = mix32 ( k , hash ) ; MST[rv.ABSMutator]MSP[]
for ( int i = 0 ; i < nblocks ; i ++ ) { MST[IncrementsMutator]MSP[] final int index = newOffset + ( i << 2 ) ; final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; }
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; MST[rv.UOI2Mutator]MSP[] unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , unprocessed [ 2 ] , data [ offset ] ) ; break; default: throw new IllegalStateException ( lr_1 + unprocessedLength ) ; } hash = mix32 ( k , hash ) ; MST[rv.UOI1Mutator]MSP[]
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.UOI4Mutator]MSP[] } @Override @Deprecated
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; MST[rv.AOR3Mutator]MSP[] return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; newLength = length - consumed ; } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ; MST[rv.CRCR4Mutator]MSP[]
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; MST[rv.CRCR2Mutator]MSP[] k1 *= C2_32 ; result ^= k1 ; } result ^= totalLen ; return fmix32 ( result ) ; }
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ; MST[rv.CRCR5Mutator]MSP[]
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , unprocessed [ 2 ] , data [ offset ] ) ; MST[rv.ABSMutator]MSP[] break; default: throw new IllegalStateException ( lr_1 + unprocessedLength ) ; } hash = mix32 ( k , hash ) ;
public final void start ( final int seed ) { unprocessedLength = totalLen = 0 ; this . hash = seed ; } public final void add ( final byte [] data , final int offset , final int length ) { if ( length <= 0 ) { MST[rv.UOI1Mutator]MSP[] return;
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , unprocessed [ 2 ] , data [ offset ] ) ; MST[rv.CRCR2Mutator]MSP[] break; default: throw new IllegalStateException ( lr_1 + unprocessedLength ) ; } hash = mix32 ( k , hash ) ;
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ; result ^= k1 ; } result ^= totalLen ; MST[rv.UOI1Mutator]MSP[] return fmix32 ( result ) ; }
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; MST[rv.CRCR4Mutator]MSP[] case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
int k = - 1 ; switch ( unprocessedLength ) { MST[rv.UOI3Mutator]MSP[] case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; break; case 2 :
for ( int i = 0 ; i < nblocks ; i ++ ) { final int index = newOffset + ( i << 2 ) ; MST[rv.AOR3Mutator]MSP[] final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; }
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; MST[rv.CRCR2Mutator]MSP[] case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
for ( int i = 0 ; i < nblocks ; i ++ ) { final int index = newOffset + ( i << 2 ) ; MST[rv.ABSMutator]MSP[] final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; }
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; MST[rv.OBBN1Mutator]MSP[] k1 *= C1_32 ;
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[rv.CRCR6Mutator]MSP[] break; case 3 :
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[rv.CRCR4Mutator]MSP[] break; case 3 :
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; MST[rv.OBBN3Mutator]MSP[] k1 *= C1_32 ;
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.AOD1Mutator]MSP[] break; case 2 :
int k = - 1 ; switch ( unprocessedLength ) { MST[experimental.SwitchMutator]MSP[] case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; break; case 2 :
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.CRCR4Mutator]MSP[] break; case 2 :
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.CRCR6Mutator]MSP[] break; case 2 :
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; MST[MathMutator]MSP[] } } public final int end () {
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , unprocessed [ 2 ] , data [ offset ] ) ; MST[rv.UOI2Mutator]MSP[] break; default: throw new IllegalStateException ( lr_1 + unprocessedLength ) ; } hash = mix32 ( k , hash ) ;
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; MST[rv.AOR3Mutator]MSP[] if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; } } public final int end () {
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[rv.UOI4Mutator]MSP[] break; case 3 :
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ; MST[rv.CRCR3Mutator]MSP[]
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[MathMutator]MSP[] } @Override @Deprecated
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; MST[rv.UOI2Mutator]MSP[] return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.CRCR6Mutator]MSP[] } @Override @Deprecated
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ; result ^= k1 ; MST[rv.UOI3Mutator]MSP[] } result ^= totalLen ; return fmix32 ( result ) ; }
public final void start ( final int seed ) { unprocessedLength = totalLen = 0 ; this . hash = seed ; } public final void add ( final byte [] data , final int offset , final int length ) { if ( length <= 0 ) { MST[rv.ROR2Mutator]MSP[] return;
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; MST[rv.ABSMutator]MSP[] k1 *= C2_32 ; result ^= k1 ; } result ^= totalLen ; return fmix32 ( result ) ; }
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.CRCR4Mutator]MSP[] } @Override @Deprecated
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { MST[InlineConstantMutator]MSP[] System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
for ( int i = 0 ; i < nblocks ; i ++ ) { MST[ConditionalsBoundaryMutator]MSP[] final int index = newOffset + ( i << 2 ) ; final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; }
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.CRCR2Mutator]MSP[] } @Override @Deprecated
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.CRCR1Mutator]MSP[] } @Override @Deprecated
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { MST[rv.UOI1Mutator]MSP[] System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; MST[rv.UOI3Mutator]MSP[] } } public final int end () {
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; MST[MathMutator]MSP[] k1 *= C1_32 ;
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.UOI2Mutator]MSP[] } @Override @Deprecated
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; MST[rv.UOI4Mutator]MSP[] k1 *= C1_32 ;
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.UOI1Mutator]MSP[] } @Override @Deprecated
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; MST[rv.AOR2Mutator]MSP[] } } public final int end () {
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; MST[rv.CRCR4Mutator]MSP[] case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
int k = - 1 ; MST[InlineConstantMutator]MSP[] switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; break; case 2 :
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ; MST[rv.AOR2Mutator]MSP[]
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[MathMutator]MSP[] } @Override @Deprecated
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { MST[NegateConditionalsMutator]MSP[] System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; } } public final int end () {
return finalise ( hash , unprocessedLength , unprocessed , totalLen ) ; MST[rv.UOI2Mutator]MSP[] } int finalise ( final int hash , final int unprocessedLength , final byte [] unprocessed , final int totalLen ) { int result = hash ; int k1 = 0 ; switch ( unprocessedLength ) {
return finalise ( hash , unprocessedLength , unprocessed , totalLen ) ; MST[rv.UOI4Mutator]MSP[] } int finalise ( final int hash , final int unprocessedLength , final byte [] unprocessed , final int totalLen ) { int result = hash ; int k1 = 0 ; switch ( unprocessedLength ) {
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , unprocessed [ 2 ] , data [ offset ] ) ; break; default: throw new IllegalStateException ( lr_1 + unprocessedLength ) ; } hash = mix32 ( k , hash ) ; MST[rv.UOI3Mutator]MSP[]
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ; MST[rv.CRCR2Mutator]MSP[] result ^= k1 ; } result ^= totalLen ; return fmix32 ( result ) ; }
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; MST[rv.UOI4Mutator]MSP[] unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; MST[rv.ABSMutator]MSP[] if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; } } public final int end () {
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; newLength = length - consumed ; } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ; MST[rv.CRCR6Mutator]MSP[]
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; MST[rv.UOI1Mutator]MSP[] case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; MST[rv.AOR1Mutator]MSP[] return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; MST[rv.UOI2Mutator]MSP[] case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
} totalLen += length ; MST[rv.UOI3Mutator]MSP[] if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.UOI4Mutator]MSP[] break; case 2 :
for ( int i = 0 ; i < nblocks ; i ++ ) { MST[rv.UOI2Mutator]MSP[] final int index = newOffset + ( i << 2 ) ; final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; }
for ( int i = 0 ; i < nblocks ; i ++ ) { final int index = newOffset + ( i << 2 ) ; MST[rv.UOI4Mutator]MSP[] final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; }
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; MST[rv.UOI2Mutator]MSP[] case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
final int consumed = BLOCK_SIZE - unprocessedLength ; MST[rv.AOD2Mutator]MSP[] newOffset = offset + consumed ; newLength = length - consumed ; } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ;
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; MST[rv.CRCR2Mutator]MSP[] case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.AOR3Mutator]MSP[] break; case 2 :
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , unprocessed [ 2 ] , data [ offset ] ) ; MST[rv.UOI4Mutator]MSP[] break; default: throw new IllegalStateException ( lr_1 + unprocessedLength ) ; } hash = mix32 ( k , hash ) ;
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; MST[rv.CRCR4Mutator]MSP[] case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
return finalise ( hash , unprocessedLength , unprocessed , totalLen ) ; } int finalise ( final int hash , final int unprocessedLength , final byte [] unprocessed , final int totalLen ) { int result = hash ; MST[rv.UOI3Mutator]MSP[] int k1 = 0 ; switch ( unprocessedLength ) {
} totalLen += length ; MST[rv.AOR4Mutator]MSP[] if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ; result ^= k1 ; MST[rv.ABSMutator]MSP[] } result ^= totalLen ; return fmix32 ( result ) ; }
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ; MST[rv.AOR1Mutator]MSP[] result ^= k1 ; } result ^= totalLen ; return fmix32 ( result ) ; }
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; newLength = length - consumed ; MST[rv.UOI3Mutator]MSP[] } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ;
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ; MST[rv.UOI3Mutator]MSP[]
for ( int i = 0 ; i < nblocks ; i ++ ) { final int index = newOffset + ( i << 2 ) ; final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; MST[rv.UOI4Mutator]MSP[] }
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[MathMutator]MSP[] break; case 2 :
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.CRCR3Mutator]MSP[] break; case 2 :
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[rv.AOR1Mutator]MSP[] break; case 3 :
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; newLength = length - consumed ; MST[rv.ABSMutator]MSP[] } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ;
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[InlineConstantMutator]MSP[] break; case 2 :
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[] System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.UOI1Mutator]MSP[] break; case 2 :
} totalLen += length ; MST[rv.UOI4Mutator]MSP[] if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; MST[rv.CRCR2Mutator]MSP[] k1 *= C1_32 ;
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; MST[rv.OBBN3Mutator]MSP[] case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ; result ^= k1 ; } result ^= totalLen ; return fmix32 ( result ) ; MST[rv.UOI2Mutator]MSP[] }
public final void start ( final int seed ) { unprocessedLength = totalLen = 0 ; MST[rv.CRCR5Mutator]MSP[] this . hash = seed ; } public final void add ( final byte [] data , final int offset , final int length ) { if ( length <= 0 ) { return;
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; newLength = length - consumed ; } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ; MST[rv.UOI4Mutator]MSP[]
final int consumed = ( nblocks << 2 ) ; MST[MathMutator]MSP[] unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; } } public final int end () {
final int consumed = ( nblocks << 2 ) ; MST[InlineConstantMutator]MSP[] unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; } } public final int end () {
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[rv.CRCR2Mutator]MSP[] break; case 3 :
} totalLen += length ; MST[rv.ABSMutator]MSP[] if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
for ( int i = 0 ; i < nblocks ; i ++ ) { final int index = newOffset + ( i << 2 ) ; MST[rv.AOD1Mutator]MSP[] final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; }
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.AOR2Mutator]MSP[] break; case 2 :
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; MST[rv.UOI4Mutator]MSP[] if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; } } public final int end () {
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.OBBN2Mutator]MSP[] } @Override @Deprecated
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; MST[rv.CRCR4Mutator]MSP[] case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { MST[rv.ROR4Mutator]MSP[] System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.OBBN3Mutator]MSP[] } @Override @Deprecated
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; newLength = length - consumed ; } else { newOffset = offset ; MST[rv.UOI1Mutator]MSP[] newLength = length ; } final int nblocks = newLength >> 2 ;
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; newLength = length - consumed ; MST[rv.AOR3Mutator]MSP[] } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ;
for ( int i = 0 ; i < nblocks ; i ++ ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] final int index = newOffset + ( i << 2 ) ; final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; }
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ; result ^= k1 ; } result ^= totalLen ; return fmix32 ( result ) ; MST[NonVoidMethodCallMutator]MSP[] }
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; MST[rv.AOR1Mutator]MSP[] newLength = length - consumed ; } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ;
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; MST[rv.AOD1Mutator]MSP[] if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; } } public final int end () {
