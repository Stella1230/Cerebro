for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ; MST[rv.UOI4Mutator]MSP[N]
this . alwaysEncodeChars . set ( b ) ; if ( b < alwaysEncodeCharsMin ) { alwaysEncodeCharsMin = b ; } if ( b > alwaysEncodeCharsMax ) { MST[rv.UOI3Mutator]MSP[N] alwaysEncodeCharsMax = b ; } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { MST[rv.UOI3Mutator]MSP[N] byteCount += canEncode ( b ) ? 3 : 1 ; } return byteCount ; }
final int l = Utils . digit16 ( bytes [ ++ i ] ) ; buffer . put ( (byte) ( ( u << 4 ) + l ) ) ; MST[rv.AOR1Mutator]MSP[N] } catch ( final ArrayIndexOutOfBoundsException e ) { throw new DecoderException ( lr_1 , e ) ; }
for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { MST[rv.UOI2Mutator]MSP[N] try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[rv.CRCR2Mutator]MSP[N] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ; MST[rv.CRCR5Mutator]MSP[N]
return buffer . array () ; MST[ReturnValsMutator]MSP[N] } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; } return byteCount ; }
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; MST[rv.AOR4Mutator]MSP[N] }
buffer . put ( ( byte ) hex2 ) ; } else { if ( plusForSpace && b == ' ' ) { buffer . put ( ( byte ) '+' ) ; } else { buffer . put ( b ) ; MST[experimental.NakedReceiverMutator]MSP[N] } } }
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { MST[rv.UOI4Mutator]MSP[N] if ( b == ' ' ) { return true ; } } return false ; } private boolean canEncode ( final byte c ) {
if ( bytes == null ) { return null ; MST[ReturnValsMutator]MSP[N] } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) {
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { if ( b == ' ' ) { return true ; } } return false ; MST[rv.CRCR6Mutator]MSP[S] } private boolean canEncode ( final byte c ) {
} else { if ( plusForSpace && b == '+' ) { MST[rv.ROR4Mutator]MSP[N] buffer . put ( ( byte ) ' ' ) ; } else { buffer . put ( b ) ; } } } return buffer . array () ; }
this . alwaysEncodeChars . set ( b ) ; if ( b < alwaysEncodeCharsMin ) { MST[rv.UOI4Mutator]MSP[N] alwaysEncodeCharsMin = b ; } if ( b > alwaysEncodeCharsMax ) { alwaysEncodeCharsMax = b ; } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
} else if ( obj instanceof byte [] ) { return decode ( ( byte [] ) obj ) ; } else { throw new DecoderException ( lr_2 + obj . getClass () . getName () + lr_4 ) ; MST[ConstructorCallMutator]MSP[S] } }
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) { MST[rv.ROR5Mutator]MSP[N]
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; MST[rv.CRCR4Mutator]MSP[N] } private boolean isAsciiChar ( final byte c ) {
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { final byte b = bytes [ i ] ; MST[rv.UOI2Mutator]MSP[N] i += b == ESCAPE_CHAR ? 3 : 1 ;
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; MST[rv.CRCR1Mutator]MSP[N] } private boolean isAsciiChar ( final byte c ) {
for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { MST[InlineConstantMutator]MSP[N] try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
for ( final byte b : bytes ) { MST[rv.UOI2Mutator]MSP[N] if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { byte bb = b ; MST[rv.UOI1Mutator]MSP[N] if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
} else if ( obj instanceof byte [] ) { return decode ( ( byte [] ) obj ) ; MST[ReturnValsMutator]MSP[S] } else { throw new DecoderException ( lr_2 + obj . getClass () . getName () + lr_4 ) ; } }
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) { MST[rv.ROR2Mutator]MSP[N]
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { final byte b = bytes [ i ] ; MST[rv.ABSMutator]MSP[N] i += b == ESCAPE_CHAR ? 3 : 1 ;
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ; MST[NegateConditionalsMutator]MSP[N]
buffer . put ( ( byte ) hex2 ) ; } else { if ( plusForSpace && b == ' ' ) { buffer . put ( ( byte ) '+' ) ; } else { buffer . put ( b ) ; MST[rv.ABSMutator]MSP[N] } } }
for ( int i = 0 ; i < bytes . length ; i ++ ) { MST[InlineConstantMutator]MSP[N] final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
byteCount ++ ; } return byteCount ; } @Override public Object encode ( final Object obj ) throws EncoderException { if ( obj == null ) { return null ; } else if ( obj instanceof byte [] ) { MST[rv.ROR2Mutator]MSP[N] return encode ( ( byte [] ) obj ) ;
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; MST[InlineConstantMutator]MSP[S] } private void insertAlwaysEncodeChar ( final byte b ) {
for ( int i = 0 ; i < bytes . length ; i ++ ) { MST[rv.UOI3Mutator]MSP[N] final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { MST[rv.CRCR6Mutator]MSP[N] if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; MST[rv.CRCR5Mutator]MSP[N] if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) {
} else { throw new EncoderException ( lr_2 + obj . getClass () . getName () + lr_3 ) ; MST[experimental.NakedReceiverMutator]MSP[N] } } @Override public Object decode ( final Object obj ) throws DecoderException { if ( obj == null ) { return null ;
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[rv.ROR4Mutator]MSP[N] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
if ( bytes == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) {
for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { MST[rv.ABSMutator]MSP[N] try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { MST[rv.UOI4Mutator]MSP[N] byteCount += canEncode ( b ) ? 3 : 1 ; } return byteCount ; }
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } return byteCount ; }
final char hex1 = Utils . hexDigit ( bb >> 4 ) ; final char hex2 = Utils . hexDigit ( bb ) ; buffer . put ( ESCAPE_CHAR ) ; buffer . put ( ( byte ) hex1 ) ; MST[NonVoidMethodCallMutator]MSP[N]
} else { if ( plusForSpace && b == '+' ) { MST[rv.ROR3Mutator]MSP[N] buffer . put ( ( byte ) ' ' ) ; } else { buffer . put ( b ) ; } } } return buffer . array () ; }
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; MST[rv.UOI3Mutator]MSP[N] } private boolean isAsciiChar ( final byte c ) {
for ( int i = 0 ; i < bytes . length ; i ++ ) { MST[rv.ROR1Mutator]MSP[N] final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { if ( b == ' ' ) { MST[InlineConstantMutator]MSP[N] return true ; } } return false ; } private boolean canEncode ( final byte c ) {
} else { throw new EncoderException ( lr_2 + obj . getClass () . getName () + lr_3 ) ; MST[NonVoidMethodCallMutator]MSP[N] } } @Override public Object decode ( final Object obj ) throws DecoderException { if ( obj == null ) { return null ;
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; MST[rv.UOI1Mutator]MSP[N] } return byteCount ; }
return doEncode ( bytes , expectedEncodingBytes , willEncode ) ; MST[rv.UOI3Mutator]MSP[N] } return bytes ; } private byte [] doEncode ( final byte [] bytes , final int expectedLength , final boolean willEncode ) { final ByteBuffer buffer = ByteBuffer . allocate ( expectedLength ) ;
for ( final byte b : bytes ) { MST[rv.ABSMutator]MSP[N] if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { MST[rv.ABSMutator]MSP[S] insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
this . alwaysEncodeChars . set ( b ) ; if ( b < alwaysEncodeCharsMin ) { alwaysEncodeCharsMin = b ; } if ( b > alwaysEncodeCharsMax ) { MST[rv.ROR4Mutator]MSP[N] alwaysEncodeCharsMax = b ; } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; MST[rv.CRCR2Mutator]MSP[S] } private void insertAlwaysEncodeChar ( final byte b ) {
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; MST[rv.AOD2Mutator]MSP[N] }
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ; MST[rv.UOI3Mutator]MSP[N]
final char hex1 = Utils . hexDigit ( bb >> 4 ) ; MST[rv.CRCR5Mutator]MSP[N] final char hex2 = Utils . hexDigit ( bb ) ; buffer . put ( ESCAPE_CHAR ) ; buffer . put ( ( byte ) hex1 ) ;
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; MST[rv.ROR3Mutator]MSP[N] } return byteCount ; }
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { insertAlwaysEncodeChar ( b ) ; MST[rv.UOI4Mutator]MSP[N] } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { if ( b == ' ' ) { MST[rv.ROR4Mutator]MSP[N] return true ; } } return false ; } private boolean canEncode ( final byte c ) {
final int l = Utils . digit16 ( bytes [ ++ i ] ) ; MST[NonVoidMethodCallMutator]MSP[N] buffer . put ( (byte) ( ( u << 4 ) + l ) ) ; } catch ( final ArrayIndexOutOfBoundsException e ) { throw new DecoderException ( lr_1 , e ) ; }
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; MST[RemoveConditionalMutator_ORDER_IF]MSP[N] } private boolean isAsciiChar ( final byte c ) {
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[rv.ROR2Mutator]MSP[N] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
buffer . put ( ( byte ) hex2 ) ; } else { if ( plusForSpace && b == ' ' ) { buffer . put ( ( byte ) '+' ) ; } else { buffer . put ( b ) ; MST[rv.UOI2Mutator]MSP[N] } } }
this . alwaysEncodeChars . set ( b ) ; if ( b < alwaysEncodeCharsMin ) { MST[rv.UOI4Mutator]MSP[N] alwaysEncodeCharsMin = b ; } if ( b > alwaysEncodeCharsMax ) { alwaysEncodeCharsMax = b ; } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
return c >= 0 ; MST[rv.CRCR3Mutator]MSP[N] } @Override public byte [] decode ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { return null ; } final ByteBuffer buffer = ByteBuffer . allocate ( expectedDecodingBytes ( bytes ) ) ;
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { MST[rv.UOI1Mutator]MSP[S] if ( b == ' ' ) { return true ; } } return false ; } private boolean canEncode ( final byte c ) {
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) {
} else { if ( plusForSpace && b == '+' ) { buffer . put ( ( byte ) ' ' ) ; } else { buffer . put ( b ) ; MST[NonVoidMethodCallMutator]MSP[N] } } } return buffer . array () ; }
final char hex1 = Utils . hexDigit ( bb >> 4 ) ; final char hex2 = Utils . hexDigit ( bb ) ; MST[rv.UOI3Mutator]MSP[N] buffer . put ( ESCAPE_CHAR ) ; buffer . put ( ( byte ) hex1 ) ;
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { if ( alwaysEncodeCharsArray != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] for ( final byte b : alwaysEncodeCharsArray ) { insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
buffer . put ( ( byte ) hex2 ) ; } else { if ( plusForSpace && b == ' ' ) { MST[rv.CRCR3Mutator]MSP[N] buffer . put ( ( byte ) '+' ) ; } else { buffer . put ( b ) ; } } }
return c >= 0 ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] } @Override public byte [] decode ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { return null ; } final ByteBuffer buffer = ByteBuffer . allocate ( expectedDecodingBytes ( bytes ) ) ;
return c >= 0 ; } @Override public byte [] decode ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return null ; } final ByteBuffer buffer = ByteBuffer . allocate ( expectedDecodingBytes ( bytes ) ) ;
final int l = Utils . digit16 ( bytes [ ++ i ] ) ; buffer . put ( (byte) ( ( u << 4 ) + l ) ) ; MST[MathMutator]MSP[N] } catch ( final ArrayIndexOutOfBoundsException e ) { throw new DecoderException ( lr_1 , e ) ; }
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { MST[rv.CRCR4Mutator]MSP[N] if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
final char hex1 = Utils . hexDigit ( bb >> 4 ) ; final char hex2 = Utils . hexDigit ( bb ) ; buffer . put ( ESCAPE_CHAR ) ; buffer . put ( ( byte ) hex1 ) ; MST[rv.UOI2Mutator]MSP[N]
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; MST[rv.ROR4Mutator]MSP[N] } private boolean isAsciiChar ( final byte c ) {
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; MST[rv.ROR1Mutator]MSP[N] } private boolean isAsciiChar ( final byte c ) {
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { if ( b == ' ' ) { MST[rv.CRCR2Mutator]MSP[N] return true ; } } return false ; } private boolean canEncode ( final byte c ) {
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { if ( b == ' ' ) { return true ; MST[rv.CRCR4Mutator]MSP[N] } } return false ; } private boolean canEncode ( final byte c ) {
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { MST[experimental.MemberVariableMutator]MSP[N] if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { MST[NegateConditionalsMutator]MSP[N] byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { MST[rv.CRCR2Mutator]MSP[N] try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
buffer . put ( ( byte ) hex2 ) ; } else { if ( plusForSpace && b == ' ' ) { MST[rv.UOI3Mutator]MSP[N] buffer . put ( ( byte ) '+' ) ; } else { buffer . put ( b ) ; } } }
} else { if ( plusForSpace && b == '+' ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] buffer . put ( ( byte ) ' ' ) ; } else { buffer . put ( b ) ; } } } return buffer . array () ; }
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ; MST[rv.ROR5Mutator]MSP[N]
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { MST[rv.UOI1Mutator]MSP[S] insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
return c >= 0 ; MST[ReturnValsMutator]MSP[N] } @Override public byte [] decode ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { return null ; } final ByteBuffer buffer = ByteBuffer . allocate ( expectedDecodingBytes ( bytes ) ) ;
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; MST[rv.ROR5Mutator]MSP[N] if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) {
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[InlineConstantMutator]MSP[N] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { if ( b == ' ' ) { MST[rv.ABSMutator]MSP[N] return true ; } } return false ; } private boolean canEncode ( final byte c ) {
} else { throw new EncoderException ( lr_2 + obj . getClass () . getName () + lr_3 ) ; MST[experimental.NakedReceiverMutator]MSP[N] } } @Override public Object decode ( final Object obj ) throws DecoderException { if ( obj == null ) { return null ;
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; MST[InlineConstantMutator]MSP[N] }
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { if ( b == ' ' ) { return true ; MST[BooleanFalseReturnValsMutator]MSP[N] } } return false ; } private boolean canEncode ( final byte c ) {
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; MST[InlineConstantMutator]MSP[N] if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) {
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; MST[rv.CRCR3Mutator]MSP[N] } return byteCount ; }
this . alwaysEncodeChars . set ( b ) ; if ( b < alwaysEncodeCharsMin ) { MST[NegateConditionalsMutator]MSP[N] alwaysEncodeCharsMin = b ; } if ( b > alwaysEncodeCharsMax ) { alwaysEncodeCharsMax = b ; } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
final int l = Utils . digit16 ( bytes [ ++ i ] ) ; MST[rv.UOI2Mutator]MSP[N] buffer . put ( (byte) ( ( u << 4 ) + l ) ) ; } catch ( final ArrayIndexOutOfBoundsException e ) { throw new DecoderException ( lr_1 , e ) ; }
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { MST[rv.CRCR5Mutator]MSP[N] if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; MST[MathMutator]MSP[N] } return byteCount ; }
for ( final byte b : bytes ) { MST[rv.UOI4Mutator]MSP[N] if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
this . alwaysEncodeChars . set ( b ) ; if ( b < alwaysEncodeCharsMin ) { alwaysEncodeCharsMin = b ; } if ( b > alwaysEncodeCharsMax ) { alwaysEncodeCharsMax = b ; MST[rv.UOI4Mutator]MSP[N] } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
return doEncode ( bytes , expectedEncodingBytes , willEncode ) ; MST[rv.ABSMutator]MSP[N] } return bytes ; } private byte [] doEncode ( final byte [] bytes , final int expectedLength , final boolean willEncode ) { final ByteBuffer buffer = ByteBuffer . allocate ( expectedLength ) ;
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; MST[rv.AOR1Mutator]MSP[N] } return byteCount ; }
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; MST[rv.AOR4Mutator]MSP[N] } return byteCount ; }
for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ; MST[rv.UOI1Mutator]MSP[N] if ( b == ESCAPE_CHAR ) { try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
final char hex1 = Utils . hexDigit ( bb >> 4 ) ; final char hex2 = Utils . hexDigit ( bb ) ; buffer . put ( ESCAPE_CHAR ) ; MST[rv.CRCR4Mutator]MSP[N] buffer . put ( ( byte ) hex1 ) ;
} else { if ( plusForSpace && b == '+' ) { MST[rv.ABSMutator]MSP[N] buffer . put ( ( byte ) ' ' ) ; } else { buffer . put ( b ) ; } } } return buffer . array () ; }
for ( final byte b : bytes ) { MST[rv.UOI1Mutator]MSP[N] if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { MST[InlineConstantMutator]MSP[N] final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ;
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) { MST[rv.ROR4Mutator]MSP[N]
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; MST[rv.UOI3Mutator]MSP[N] } private boolean isAsciiChar ( final byte c ) {
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; MST[rv.UOI1Mutator]MSP[N] } return byteCount ; }
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) { MST[rv.ROR1Mutator]MSP[N]
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { MST[rv.ROR5Mutator]MSP[N] byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { MST[rv.ROR1Mutator]MSP[N] final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ;
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; MST[rv.CRCR6Mutator]MSP[N] } return byteCount ; }
buffer . put ( ( byte ) hex2 ) ; } else { if ( plusForSpace && b == ' ' ) { buffer . put ( ( byte ) '+' ) ; MST[rv.CRCR4Mutator]MSP[N] } else { buffer . put ( b ) ; } } }
} else if ( obj instanceof byte [] ) { MST[rv.ROR5Mutator]MSP[N] return decode ( ( byte [] ) obj ) ; } else { throw new DecoderException ( lr_2 + obj . getClass () . getName () + lr_4 ) ; } }
byteCount ++ ; } return byteCount ; } @Override public Object encode ( final Object obj ) throws EncoderException { if ( obj == null ) { return null ; } else if ( obj instanceof byte [] ) { MST[rv.ROR5Mutator]MSP[N] return encode ( ( byte [] ) obj ) ;
this . alwaysEncodeChars . set ( b ) ; MST[rv.UOI2Mutator]MSP[N] if ( b < alwaysEncodeCharsMin ) { alwaysEncodeCharsMin = b ; } if ( b > alwaysEncodeCharsMax ) { alwaysEncodeCharsMax = b ; } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { MST[rv.UOI2Mutator]MSP[N] if ( b == ' ' ) { return true ; } } return false ; } private boolean canEncode ( final byte c ) {
if ( bytes == null ) { MST[rv.ROR5Mutator]MSP[N] return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) {
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; MST[MathMutator]MSP[N] }
return doEncode ( bytes , expectedEncodingBytes , willEncode ) ; } return bytes ; } private byte [] doEncode ( final byte [] bytes , final int expectedLength , final boolean willEncode ) { final ByteBuffer buffer = ByteBuffer . allocate ( expectedLength ) ; MST[rv.UOI2Mutator]MSP[N]
return c >= 0 ; MST[rv.UOI2Mutator]MSP[N] } @Override public byte [] decode ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { return null ; } final ByteBuffer buffer = ByteBuffer . allocate ( expectedDecodingBytes ( bytes ) ) ;
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[rv.ABSMutator]MSP[N] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
} else { if ( plusForSpace && b == '+' ) { buffer . put ( ( byte ) ' ' ) ; } else { buffer . put ( b ) ; MST[rv.UOI1Mutator]MSP[N] } } } return buffer . array () ; }
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { MST[rv.UOI3Mutator]MSP[N] byteCount += canEncode ( b ) ? 3 : 1 ; } return byteCount ; }
} else { if ( plusForSpace && b == '+' ) { MST[rv.CRCR4Mutator]MSP[N] buffer . put ( ( byte ) ' ' ) ; } else { buffer . put ( b ) ; } } } return buffer . array () ; }
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; MST[rv.CRCR4Mutator]MSP[N] }
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { if ( b == ' ' ) { return true ; } } return false ; MST[rv.CRCR3Mutator]MSP[S] } private boolean canEncode ( final byte c ) {
final int l = Utils . digit16 ( bytes [ ++ i ] ) ; buffer . put ( (byte) ( ( u << 4 ) + l ) ) ; MST[rv.AOR4Mutator]MSP[N] } catch ( final ArrayIndexOutOfBoundsException e ) { throw new DecoderException ( lr_1 , e ) ; }
return c >= 0 ; MST[rv.CRCR6Mutator]MSP[N] } @Override public byte [] decode ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { return null ; } final ByteBuffer buffer = ByteBuffer . allocate ( expectedDecodingBytes ( bytes ) ) ;
this . alwaysEncodeChars . set ( b ) ; if ( b < alwaysEncodeCharsMin ) { MST[rv.UOI1Mutator]MSP[N] alwaysEncodeCharsMin = b ; } if ( b > alwaysEncodeCharsMax ) { alwaysEncodeCharsMax = b ; } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
buffer . put ( ( byte ) hex2 ) ; } else { if ( plusForSpace && b == ' ' ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] buffer . put ( ( byte ) '+' ) ; } else { buffer . put ( b ) ; } } }
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { MST[rv.UOI4Mutator]MSP[N] byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ; MST[rv.UOI2Mutator]MSP[N]
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) { MST[rv.ROR2Mutator]MSP[N]
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { MST[rv.UOI2Mutator]MSP[N] byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
buffer . put ( ( byte ) hex2 ) ; } else { if ( plusForSpace && b == ' ' ) { MST[rv.ROR5Mutator]MSP[N] buffer . put ( ( byte ) '+' ) ; } else { buffer . put ( b ) ; } } }
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[rv.ROR5Mutator]MSP[N] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { MST[rv.ROR2Mutator]MSP[N] byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { MST[rv.ROR4Mutator]MSP[N] bb = (byte) ( 256 + bb ) ; }
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S]
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { MST[rv.UOI1Mutator]MSP[N] bb = (byte) ( 256 + bb ) ; }
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[rv.ROR4Mutator]MSP[N] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[rv.ABSMutator]MSP[N] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
final int l = Utils . digit16 ( bytes [ ++ i ] ) ; buffer . put ( (byte) ( ( u << 4 ) + l ) ) ; MST[rv.CRCR5Mutator]MSP[N] } catch ( final ArrayIndexOutOfBoundsException e ) { throw new DecoderException ( lr_1 , e ) ; }
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; MST[rv.UOI2Mutator]MSP[N] }
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; MST[rv.UOI4Mutator]MSP[N] }
buffer . put ( ( byte ) hex2 ) ; } else { if ( plusForSpace && b == ' ' ) { buffer . put ( ( byte ) '+' ) ; MST[rv.CRCR1Mutator]MSP[N] } else { buffer . put ( b ) ; } } }
for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ; MST[rv.UOI4Mutator]MSP[N] if ( b == ESCAPE_CHAR ) { try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[rv.CRCR5Mutator]MSP[N] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
final int l = Utils . digit16 ( bytes [ ++ i ] ) ; MST[rv.UOI1Mutator]MSP[N] buffer . put ( (byte) ( ( u << 4 ) + l ) ) ; } catch ( final ArrayIndexOutOfBoundsException e ) { throw new DecoderException ( lr_1 , e ) ; }
this . alwaysEncodeChars . set ( b ) ; MST[rv.ABSMutator]MSP[N] if ( b < alwaysEncodeCharsMin ) { alwaysEncodeCharsMin = b ; } if ( b > alwaysEncodeCharsMax ) { alwaysEncodeCharsMax = b ; } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
} else { throw new EncoderException ( lr_2 + obj . getClass () . getName () + lr_3 ) ; MST[experimental.NakedReceiverMutator]MSP[N] } } @Override public Object decode ( final Object obj ) throws DecoderException { if ( obj == null ) { return null ;
for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ; MST[rv.UOI3Mutator]MSP[N]
final char hex1 = Utils . hexDigit ( bb >> 4 ) ; MST[rv.CRCR2Mutator]MSP[N] final char hex2 = Utils . hexDigit ( bb ) ; buffer . put ( ESCAPE_CHAR ) ; buffer . put ( ( byte ) hex1 ) ;
byteCount ++ ; } return byteCount ; } @Override public Object encode ( final Object obj ) throws EncoderException { if ( obj == null ) { MST[NegateConditionalsMutator]MSP[N] return null ; } else if ( obj instanceof byte [] ) { return encode ( ( byte [] ) obj ) ;
return buffer . array () ; MST[NullReturnValsMutator]MSP[N] } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; } return byteCount ; }
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { MST[rv.CRCR2Mutator]MSP[N] if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
return doEncode ( bytes , expectedEncodingBytes , willEncode ) ; MST[NonVoidMethodCallMutator]MSP[N] } return bytes ; } private byte [] doEncode ( final byte [] bytes , final int expectedLength , final boolean willEncode ) { final ByteBuffer buffer = ByteBuffer . allocate ( expectedLength ) ;
this . alwaysEncodeChars . set ( b ) ; if ( b < alwaysEncodeCharsMin ) { alwaysEncodeCharsMin = b ; MST[rv.UOI2Mutator]MSP[N] } if ( b > alwaysEncodeCharsMax ) { alwaysEncodeCharsMax = b ; } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
} else { throw new EncoderException ( lr_2 + obj . getClass () . getName () + lr_3 ) ; MST[NonVoidMethodCallMutator]MSP[N] } } @Override public Object decode ( final Object obj ) throws DecoderException { if ( obj == null ) { return null ;
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { MST[rv.CRCR3Mutator]MSP[N] if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
final char hex1 = Utils . hexDigit ( bb >> 4 ) ; final char hex2 = Utils . hexDigit ( bb ) ; buffer . put ( ESCAPE_CHAR ) ; MST[rv.CRCR1Mutator]MSP[N] buffer . put ( ( byte ) hex1 ) ;
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; MST[rv.UOI3Mutator]MSP[N] } private boolean isAsciiChar ( final byte c ) {
} else if ( obj instanceof byte [] ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] return decode ( ( byte [] ) obj ) ; } else { throw new DecoderException ( lr_2 + obj . getClass () . getName () + lr_4 ) ; } }
buffer . put ( ( byte ) hex2 ) ; } else { if ( plusForSpace && b == ' ' ) { MST[NegateConditionalsMutator]MSP[N] buffer . put ( ( byte ) '+' ) ; } else { buffer . put ( b ) ; } } }
this . alwaysEncodeChars . set ( b ) ; if ( b < alwaysEncodeCharsMin ) { alwaysEncodeCharsMin = b ; } if ( b > alwaysEncodeCharsMax ) { alwaysEncodeCharsMax = b ; MST[rv.UOI1Mutator]MSP[N] } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; MST[rv.UOI4Mutator]MSP[N] } return byteCount ; }
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { MST[rv.ABSMutator]MSP[N] byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
} else if ( obj instanceof byte [] ) { return decode ( ( byte [] ) obj ) ; MST[NullReturnValsMutator]MSP[S] } else { throw new DecoderException ( lr_2 + obj . getClass () . getName () + lr_4 ) ; } }
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { MST[rv.UOI3Mutator]MSP[N] byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { MST[rv.UOI2Mutator]MSP[S] insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; MST[rv.ROR2Mutator]MSP[N] if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) {
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { final byte b = bytes [ i ] ; MST[rv.UOI1Mutator]MSP[N] i += b == ESCAPE_CHAR ? 3 : 1 ;
} else if ( obj instanceof byte [] ) { MST[rv.ROR3Mutator]MSP[N] return decode ( ( byte [] ) obj ) ; } else { throw new DecoderException ( lr_2 + obj . getClass () . getName () + lr_4 ) ; } }
this . alwaysEncodeChars . set ( b ) ; MST[rv.UOI4Mutator]MSP[N] if ( b < alwaysEncodeCharsMin ) { alwaysEncodeCharsMin = b ; } if ( b > alwaysEncodeCharsMax ) { alwaysEncodeCharsMax = b ; } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; MST[rv.ABSMutator]MSP[N] }
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[rv.UOI2Mutator]MSP[N] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { MST[rv.ROR3Mutator]MSP[N] final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ;
} else { if ( plusForSpace && b == '+' ) { MST[InlineConstantMutator]MSP[N] buffer . put ( ( byte ) ' ' ) ; } else { buffer . put ( b ) ; } } } return buffer . array () ; }
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ; MST[rv.CRCR5Mutator]MSP[N]
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { MST[rv.CRCR3Mutator]MSP[N] if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
for ( int i = 0 ; i < bytes . length ; i ++ ) { MST[IncrementsMutator]MSP[N] final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; MST[rv.ROR1Mutator]MSP[N] } private boolean isAsciiChar ( final byte c ) {
return c >= 0 ; MST[rv.ABSMutator]MSP[N] } @Override public byte [] decode ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { return null ; } final ByteBuffer buffer = ByteBuffer . allocate ( expectedDecodingBytes ( bytes ) ) ;
this . alwaysEncodeChars . set ( b ) ; if ( b < alwaysEncodeCharsMin ) { alwaysEncodeCharsMin = b ; } if ( b > alwaysEncodeCharsMax ) { MST[rv.UOI3Mutator]MSP[N] alwaysEncodeCharsMax = b ; } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
return c >= 0 ; MST[rv.ROR5Mutator]MSP[N] } @Override public byte [] decode ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { return null ; } final ByteBuffer buffer = ByteBuffer . allocate ( expectedDecodingBytes ( bytes ) ) ;
final char hex1 = Utils . hexDigit ( bb >> 4 ) ; final char hex2 = Utils . hexDigit ( bb ) ; MST[NonVoidMethodCallMutator]MSP[N] buffer . put ( ESCAPE_CHAR ) ; buffer . put ( ( byte ) hex1 ) ;
byteCount ++ ; } return byteCount ; } @Override public Object encode ( final Object obj ) throws EncoderException { if ( obj == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return null ; } else if ( obj instanceof byte [] ) { return encode ( ( byte [] ) obj ) ;
final int l = Utils . digit16 ( bytes [ ++ i ] ) ; buffer . put ( (byte) ( ( u << 4 ) + l ) ) ; MST[rv.UOI3Mutator]MSP[N] } catch ( final ArrayIndexOutOfBoundsException e ) { throw new DecoderException ( lr_1 , e ) ; }
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] bb = (byte) ( 256 + bb ) ; }
} else { if ( plusForSpace && b == '+' ) { MST[NegateConditionalsMutator]MSP[N] buffer . put ( ( byte ) ' ' ) ; } else { buffer . put ( b ) ; } } } return buffer . array () ; }
return doEncode ( bytes , expectedEncodingBytes , willEncode ) ; MST[rv.UOI2Mutator]MSP[N] } return bytes ; } private byte [] doEncode ( final byte [] bytes , final int expectedLength , final boolean willEncode ) { final ByteBuffer buffer = ByteBuffer . allocate ( expectedLength ) ;
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { if ( b == ' ' ) { MST[rv.CRCR4Mutator]MSP[N] return true ; } } return false ; } private boolean canEncode ( final byte c ) {
final int l = Utils . digit16 ( bytes [ ++ i ] ) ; MST[experimental.RemoveIncrementsMutator]MSP[N] buffer . put ( (byte) ( ( u << 4 ) + l ) ) ; } catch ( final ArrayIndexOutOfBoundsException e ) { throw new DecoderException ( lr_1 , e ) ; }
} else if ( obj instanceof byte [] ) { MST[NegateConditionalsMutator]MSP[N] return decode ( ( byte [] ) obj ) ; } else { throw new DecoderException ( lr_2 + obj . getClass () . getName () + lr_4 ) ; } }
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[rv.UOI3Mutator]MSP[N] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; } return byteCount ; MST[rv.UOI1Mutator]MSP[N] }
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; MST[rv.CRCR3Mutator]MSP[N] } return byteCount ; }
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; MST[rv.UOI4Mutator]MSP[N] if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) {
return c >= 0 ; MST[ConditionalsBoundaryMutator]MSP[N] } @Override public byte [] decode ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { return null ; } final ByteBuffer buffer = ByteBuffer . allocate ( expectedDecodingBytes ( bytes ) ) ;
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; MST[InlineConstantMutator]MSP[N] for ( int i = 0 ; i < bytes . length ; ) { final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ;
} else if ( obj instanceof byte [] ) { return decode ( ( byte [] ) obj ) ; } else { throw new DecoderException ( lr_2 + obj . getClass () . getName () + lr_4 ) ; MST[NonVoidMethodCallMutator]MSP[S] } }
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { MST[rv.UOI2Mutator]MSP[N] byteCount += canEncode ( b ) ? 3 : 1 ; } return byteCount ; }
buffer . put ( ( byte ) hex2 ) ; MST[rv.UOI3Mutator]MSP[N] } else { if ( plusForSpace && b == ' ' ) { buffer . put ( ( byte ) '+' ) ; } else { buffer . put ( b ) ; } } }
} else { throw new EncoderException ( lr_2 + obj . getClass () . getName () + lr_3 ) ; } } @Override public Object decode ( final Object obj ) throws DecoderException { if ( obj == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] return null ;
this . alwaysEncodeChars . set ( b ) ; if ( b < alwaysEncodeCharsMin ) { MST[rv.ROR2Mutator]MSP[N] alwaysEncodeCharsMin = b ; } if ( b > alwaysEncodeCharsMax ) { alwaysEncodeCharsMax = b ; } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
this . alwaysEncodeChars . set ( b ) ; if ( b < alwaysEncodeCharsMin ) { alwaysEncodeCharsMin = b ; } if ( b > alwaysEncodeCharsMax ) { MST[rv.ROR1Mutator]MSP[N] alwaysEncodeCharsMax = b ; } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
final int l = Utils . digit16 ( bytes [ ++ i ] ) ; buffer . put ( (byte) ( ( u << 4 ) + l ) ) ; MST[rv.UOI4Mutator]MSP[N] } catch ( final ArrayIndexOutOfBoundsException e ) { throw new DecoderException ( lr_1 , e ) ; }
buffer . put ( ( byte ) hex2 ) ; } else { if ( plusForSpace && b == ' ' ) { MST[rv.ROR4Mutator]MSP[N] buffer . put ( ( byte ) '+' ) ; } else { buffer . put ( b ) ; } } }
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ; MST[rv.AOR1Mutator]MSP[N]
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { if ( alwaysEncodeCharsArray != null ) { MST[rv.ROR5Mutator]MSP[N] for ( final byte b : alwaysEncodeCharsArray ) { insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; MST[rv.UOI3Mutator]MSP[N] } private boolean isAsciiChar ( final byte c ) {
for ( final byte b : bytes ) { MST[rv.UOI1Mutator]MSP[N] if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
} else { if ( plusForSpace && b == '+' ) { buffer . put ( ( byte ) ' ' ) ; MST[rv.CRCR5Mutator]MSP[N] } else { buffer . put ( b ) ; } } } return buffer . array () ; }
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; MST[rv.CRCR4Mutator]MSP[N] } private void insertAlwaysEncodeChar ( final byte b ) {
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { MST[rv.ROR5Mutator]MSP[N] byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { MST[rv.UOI3Mutator]MSP[N] insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; MST[rv.ABSMutator]MSP[S] if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) {
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) { MST[rv.UOI3Mutator]MSP[N]
return c >= 0 ; } @Override public byte [] decode ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { MST[NegateConditionalsMutator]MSP[N] return null ; } final ByteBuffer buffer = ByteBuffer . allocate ( expectedDecodingBytes ( bytes ) ) ;
} else { if ( plusForSpace && b == '+' ) { MST[rv.UOI2Mutator]MSP[N] buffer . put ( ( byte ) ' ' ) ; } else { buffer . put ( b ) ; } } } return buffer . array () ; }
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; MST[NonVoidMethodCallMutator]MSP[N] final boolean willEncode = expectedEncodingBytes != bytes . length ; if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) {
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ; MST[rv.CRCR5Mutator]MSP[N]
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { if ( b == ' ' ) { MST[rv.UOI2Mutator]MSP[N] return true ; } } return false ; } private boolean canEncode ( final byte c ) {
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[rv.UOI1Mutator]MSP[N] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
final int l = Utils . digit16 ( bytes [ ++ i ] ) ; buffer . put ( (byte) ( ( u << 4 ) + l ) ) ; MST[rv.AOD1Mutator]MSP[N] } catch ( final ArrayIndexOutOfBoundsException e ) { throw new DecoderException ( lr_1 , e ) ; }
for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { MST[rv.ROR4Mutator]MSP[N] try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[rv.CRCR1Mutator]MSP[N] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
final int l = Utils . digit16 ( bytes [ ++ i ] ) ; buffer . put ( (byte) ( ( u << 4 ) + l ) ) ; MST[rv.AOR3Mutator]MSP[N] } catch ( final ArrayIndexOutOfBoundsException e ) { throw new DecoderException ( lr_1 , e ) ; }
this . alwaysEncodeChars . set ( b ) ; if ( b < alwaysEncodeCharsMin ) { alwaysEncodeCharsMin = b ; } if ( b > alwaysEncodeCharsMax ) { MST[rv.UOI1Mutator]MSP[N] alwaysEncodeCharsMax = b ; } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
for ( final byte b : bytes ) { MST[rv.UOI4Mutator]MSP[N] if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { MST[rv.UOI1Mutator]MSP[N] byteCount += canEncode ( b ) ? 3 : 1 ; } return byteCount ; }
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; MST[rv.CRCR1Mutator]MSP[N] }
final char hex1 = Utils . hexDigit ( bb >> 4 ) ; final char hex2 = Utils . hexDigit ( bb ) ; buffer . put ( ESCAPE_CHAR ) ; MST[NonVoidMethodCallMutator]MSP[N] buffer . put ( ( byte ) hex1 ) ;
return c >= 0 ; MST[rv.CRCR5Mutator]MSP[N] } @Override public byte [] decode ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { return null ; } final ByteBuffer buffer = ByteBuffer . allocate ( expectedDecodingBytes ( bytes ) ) ;
this . alwaysEncodeChars . set ( b ) ; if ( b < alwaysEncodeCharsMin ) { MST[rv.UOI2Mutator]MSP[N] alwaysEncodeCharsMin = b ; } if ( b > alwaysEncodeCharsMax ) { alwaysEncodeCharsMax = b ; } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { MST[rv.UOI1Mutator]MSP[N] byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { MST[experimental.MemberVariableMutator]MSP[N] if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
} else { if ( plusForSpace && b == '+' ) { MST[rv.CRCR1Mutator]MSP[N] buffer . put ( ( byte ) ' ' ) ; } else { buffer . put ( b ) ; } } } return buffer . array () ; }
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { byte bb = b ; MST[rv.UOI3Mutator]MSP[N] if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { final byte b = bytes [ i ] ; MST[rv.UOI4Mutator]MSP[N] i += b == ESCAPE_CHAR ? 3 : 1 ;
final char hex1 = Utils . hexDigit ( bb >> 4 ) ; final char hex2 = Utils . hexDigit ( bb ) ; buffer . put ( ESCAPE_CHAR ) ; MST[experimental.NakedReceiverMutator]MSP[N] buffer . put ( ( byte ) hex1 ) ;
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; MST[rv.AOD1Mutator]MSP[N] } return byteCount ; }
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; MST[rv.CRCR3Mutator]MSP[N] } private boolean isAsciiChar ( final byte c ) {
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) { MST[rv.ROR4Mutator]MSP[N]
buffer . put ( ( byte ) hex2 ) ; } else { if ( plusForSpace && b == ' ' ) { MST[rv.ROR2Mutator]MSP[N] buffer . put ( ( byte ) '+' ) ; } else { buffer . put ( b ) ; } } }
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ; MST[rv.UOI1Mutator]MSP[N]
return doEncode ( bytes , expectedEncodingBytes , willEncode ) ; MST[ArgumentPropagationMutator]MSP[N] } return bytes ; } private byte [] doEncode ( final byte [] bytes , final int expectedLength , final boolean willEncode ) { final ByteBuffer buffer = ByteBuffer . allocate ( expectedLength ) ;
} else if ( obj instanceof byte [] ) { MST[rv.ROR2Mutator]MSP[N] return decode ( ( byte [] ) obj ) ; } else { throw new DecoderException ( lr_2 + obj . getClass () . getName () + lr_4 ) ; } }
byteCount ++ ; } return byteCount ; } @Override public Object encode ( final Object obj ) throws EncoderException { if ( obj == null ) { return null ; } else if ( obj instanceof byte [] ) { MST[rv.ROR4Mutator]MSP[S] return encode ( ( byte [] ) obj ) ;
byteCount ++ ; } return byteCount ; } @Override public Object encode ( final Object obj ) throws EncoderException { if ( obj == null ) { return null ; } else if ( obj instanceof byte [] ) { return encode ( ( byte [] ) obj ) ; MST[ReturnValsMutator]MSP[S]
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { if ( alwaysEncodeCharsArray != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] for ( final byte b : alwaysEncodeCharsArray ) { insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ; MST[rv.ABSMutator]MSP[N]
this . alwaysEncodeChars . set ( b ) ; if ( b < alwaysEncodeCharsMin ) { MST[rv.ROR3Mutator]MSP[N] alwaysEncodeCharsMin = b ; } if ( b > alwaysEncodeCharsMax ) { alwaysEncodeCharsMax = b ; } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
for ( final byte b : bytes ) { MST[rv.UOI3Mutator]MSP[N] if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
final char hex1 = Utils . hexDigit ( bb >> 4 ) ; final char hex2 = Utils . hexDigit ( bb ) ; buffer . put ( ESCAPE_CHAR ) ; MST[rv.CRCR6Mutator]MSP[N] buffer . put ( ( byte ) hex1 ) ;
} else if ( obj instanceof byte [] ) { return decode ( ( byte [] ) obj ) ; } else { throw new DecoderException ( lr_2 + obj . getClass () . getName () + lr_4 ) ; MST[NonVoidMethodCallMutator]MSP[S] } }
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; MST[rv.AOR3Mutator]MSP[N] } return byteCount ; }
final int l = Utils . digit16 ( bytes [ ++ i ] ) ; MST[rv.UOI4Mutator]MSP[N] buffer . put ( (byte) ( ( u << 4 ) + l ) ) ; } catch ( final ArrayIndexOutOfBoundsException e ) { throw new DecoderException ( lr_1 , e ) ; }
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } return byteCount ; }
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { MST[rv.UOI2Mutator]MSP[N] byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
} else { if ( plusForSpace && b == '+' ) { buffer . put ( ( byte ) ' ' ) ; MST[rv.CRCR2Mutator]MSP[N] } else { buffer . put ( b ) ; } } } return buffer . array () ; }
} else if ( obj instanceof byte [] ) { return decode ( ( byte [] ) obj ) ; } else { throw new DecoderException ( lr_2 + obj . getClass () . getName () + lr_4 ) ; MST[experimental.NakedReceiverMutator]MSP[N] } }
this . alwaysEncodeChars . set ( b ) ; if ( b < alwaysEncodeCharsMin ) { alwaysEncodeCharsMin = b ; } if ( b > alwaysEncodeCharsMax ) { alwaysEncodeCharsMax = b ; MST[rv.UOI2Mutator]MSP[N] } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { MST[rv.ROR2Mutator]MSP[N] byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; MST[rv.UOI1Mutator]MSP[N] }
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[rv.ROR3Mutator]MSP[N] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; MST[VoidMethodCallMutator]MSP[S] } private void insertAlwaysEncodeChar ( final byte b ) {
buffer . put ( ( byte ) hex2 ) ; } else { if ( plusForSpace && b == ' ' ) { buffer . put ( ( byte ) '+' ) ; MST[rv.CRCR6Mutator]MSP[N] } else { buffer . put ( b ) ; } } }
} else { if ( plusForSpace && b == '+' ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] buffer . put ( ( byte ) ' ' ) ; } else { buffer . put ( b ) ; } } } return buffer . array () ; }
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { MST[rv.ABSMutator]MSP[N] if ( b == ' ' ) { return true ; } } return false ; } private boolean canEncode ( final byte c ) {
buffer . put ( ( byte ) hex2 ) ; } else { if ( plusForSpace && b == ' ' ) { buffer . put ( ( byte ) '+' ) ; MST[NonVoidMethodCallMutator]MSP[N] } else { buffer . put ( b ) ; } } }
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; } return byteCount ; MST[rv.UOI4Mutator]MSP[N] }
final int l = Utils . digit16 ( bytes [ ++ i ] ) ; buffer . put ( (byte) ( ( u << 4 ) + l ) ) ; MST[rv.ABSMutator]MSP[N] } catch ( final ArrayIndexOutOfBoundsException e ) { throw new DecoderException ( lr_1 , e ) ; }
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { MST[rv.CRCR1Mutator]MSP[N] final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ;
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { if ( b == ' ' ) { MST[rv.UOI4Mutator]MSP[N] return true ; } } return false ; } private boolean canEncode ( final byte c ) {
return c >= 0 ; } @Override public byte [] decode ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return null ; } final ByteBuffer buffer = ByteBuffer . allocate ( expectedDecodingBytes ( bytes ) ) ;
for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ; MST[rv.UOI3Mutator]MSP[N] if ( b == ESCAPE_CHAR ) { try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
byteCount ++ ; } return byteCount ; } @Override public Object encode ( final Object obj ) throws EncoderException { if ( obj == null ) { MST[rv.ROR5Mutator]MSP[N] return null ; } else if ( obj instanceof byte [] ) { return encode ( ( byte [] ) obj ) ;
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; MST[rv.ROR3Mutator]MSP[N] } private boolean isAsciiChar ( final byte c ) {
return c >= 0 ; MST[rv.ROR1Mutator]MSP[N] } @Override public byte [] decode ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { return null ; } final ByteBuffer buffer = ByteBuffer . allocate ( expectedDecodingBytes ( bytes ) ) ;
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[ReturnValsMutator]MSP[N] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; MST[rv.ROR5Mutator]MSP[N] } private boolean isAsciiChar ( final byte c ) {
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { MST[rv.CRCR2Mutator]MSP[N] if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { MST[rv.ABSMutator]MSP[N] byteCount += canEncode ( b ) ? 3 : 1 ; } return byteCount ; }
return c >= 0 ; MST[InlineConstantMutator]MSP[N] } @Override public byte [] decode ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { return null ; } final ByteBuffer buffer = ByteBuffer . allocate ( expectedDecodingBytes ( bytes ) ) ;
return doEncode ( bytes , expectedEncodingBytes , willEncode ) ; MST[rv.UOI4Mutator]MSP[N] } return bytes ; } private byte [] doEncode ( final byte [] bytes , final int expectedLength , final boolean willEncode ) { final ByteBuffer buffer = ByteBuffer . allocate ( expectedLength ) ;
} else { if ( plusForSpace && b == '+' ) { MST[rv.UOI1Mutator]MSP[N] buffer . put ( ( byte ) ' ' ) ; } else { buffer . put ( b ) ; } } } return buffer . array () ; }
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; MST[InlineConstantMutator]MSP[N] } private boolean isAsciiChar ( final byte c ) {
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { if ( b == ' ' ) { return true ; MST[rv.CRCR6Mutator]MSP[N] } } return false ; } private boolean canEncode ( final byte c ) {
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { MST[rv.UOI3Mutator]MSP[S] insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
return doEncode ( bytes , expectedEncodingBytes , willEncode ) ; MST[rv.UOI1Mutator]MSP[N] } return bytes ; } private byte [] doEncode ( final byte [] bytes , final int expectedLength , final boolean willEncode ) { final ByteBuffer buffer = ByteBuffer . allocate ( expectedLength ) ;
this . alwaysEncodeChars . set ( b ) ; if ( b < alwaysEncodeCharsMin ) { alwaysEncodeCharsMin = b ; } if ( b > alwaysEncodeCharsMax ) { MST[rv.UOI4Mutator]MSP[N] alwaysEncodeCharsMax = b ; } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ; MST[rv.ROR2Mutator]MSP[N]
for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { MST[rv.CRCR4Mutator]MSP[N] try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { MST[rv.CRCR1Mutator]MSP[N] try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { MST[NonVoidMethodCallMutator]MSP[N] byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
return c >= 0 ; } @Override public byte [] decode ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { MST[rv.ROR5Mutator]MSP[N] return null ; } final ByteBuffer buffer = ByteBuffer . allocate ( expectedDecodingBytes ( bytes ) ) ;
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { if ( b == ' ' ) { MST[rv.ROR1Mutator]MSP[N] return true ; } } return false ; } private boolean canEncode ( final byte c ) {
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { insertAlwaysEncodeChar ( b ) ; MST[rv.UOI1Mutator]MSP[N] } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; MST[rv.CRCR1Mutator]MSP[N] } return byteCount ; }
final int l = Utils . digit16 ( bytes [ ++ i ] ) ; buffer . put ( (byte) ( ( u << 4 ) + l ) ) ; MST[rv.AOD2Mutator]MSP[N] } catch ( final ArrayIndexOutOfBoundsException e ) { throw new DecoderException ( lr_1 , e ) ; }
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[rv.UOI2Mutator]MSP[N] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
} else if ( obj instanceof byte [] ) { return decode ( ( byte [] ) obj ) ; MST[NonVoidMethodCallMutator]MSP[S] } else { throw new DecoderException ( lr_2 + obj . getClass () . getName () + lr_4 ) ; } }
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[rv.UOI4Mutator]MSP[N] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ; MST[rv.UOI2Mutator]MSP[N]
this . alwaysEncodeChars . set ( b ) ; if ( b < alwaysEncodeCharsMin ) { alwaysEncodeCharsMin = b ; MST[rv.UOI3Mutator]MSP[N] } if ( b > alwaysEncodeCharsMax ) { alwaysEncodeCharsMax = b ; } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; MST[rv.CRCR2Mutator]MSP[N] if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) {
} else if ( obj instanceof byte [] ) { return decode ( ( byte [] ) obj ) ; } else { throw new DecoderException ( lr_2 + obj . getClass () . getName () + lr_4 ) ; MST[NonVoidMethodCallMutator]MSP[S] } }
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { MST[rv.CRCR1Mutator]MSP[N] if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
buffer . put ( ( byte ) hex2 ) ; MST[rv.UOI2Mutator]MSP[N] } else { if ( plusForSpace && b == ' ' ) { buffer . put ( ( byte ) '+' ) ; } else { buffer . put ( b ) ; } } }
for ( int i = 0 ; i < bytes . length ; i ++ ) { MST[rv.CRCR1Mutator]MSP[N] final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { MST[rv.CRCR6Mutator]MSP[N] if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
this . alwaysEncodeChars . set ( b ) ; if ( b < alwaysEncodeCharsMin ) { alwaysEncodeCharsMin = b ; } if ( b > alwaysEncodeCharsMax ) { MST[rv.ROR2Mutator]MSP[N] alwaysEncodeCharsMax = b ; } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
final int l = Utils . digit16 ( bytes [ ++ i ] ) ; buffer . put ( (byte) ( ( u << 4 ) + l ) ) ; MST[rv.UOI3Mutator]MSP[N] } catch ( final ArrayIndexOutOfBoundsException e ) { throw new DecoderException ( lr_1 , e ) ; }
} else { if ( plusForSpace && b == '+' ) { MST[rv.ROR5Mutator]MSP[N] buffer . put ( ( byte ) ' ' ) ; } else { buffer . put ( b ) ; } } } return buffer . array () ; }
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { final byte b = bytes [ i ] ; MST[rv.UOI3Mutator]MSP[N] i += b == ESCAPE_CHAR ? 3 : 1 ;
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { insertAlwaysEncodeChar ( b ) ; MST[rv.ABSMutator]MSP[N] } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
} else if ( obj instanceof byte [] ) { return decode ( ( byte [] ) obj ) ; } else { throw new DecoderException ( lr_2 + obj . getClass () . getName () + lr_4 ) ; MST[experimental.NakedReceiverMutator]MSP[N] } }
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { MST[rv.UOI2Mutator]MSP[N] byteCount += canEncode ( b ) ? 3 : 1 ; } return byteCount ; }
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { MST[rv.UOI4Mutator]MSP[S] insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ; MST[rv.UOI2Mutator]MSP[N]
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; MST[rv.UOI4Mutator]MSP[N] } return byteCount ; }
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; MST[rv.ROR1Mutator]MSP[N] } return byteCount ; }
buffer . put ( ( byte ) hex2 ) ; } else { if ( plusForSpace && b == ' ' ) { MST[rv.CRCR5Mutator]MSP[N] buffer . put ( ( byte ) '+' ) ; } else { buffer . put ( b ) ; } } }
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[rv.ROR1Mutator]MSP[N] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
} else { throw new EncoderException ( lr_2 + obj . getClass () . getName () + lr_3 ) ; MST[ConstructorCallMutator]MSP[S] } } @Override public Object decode ( final Object obj ) throws DecoderException { if ( obj == null ) { return null ;
this . alwaysEncodeChars . set ( b ) ; MST[VoidMethodCallMutator]MSP[N] if ( b < alwaysEncodeCharsMin ) { alwaysEncodeCharsMin = b ; } if ( b > alwaysEncodeCharsMax ) { alwaysEncodeCharsMax = b ; } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[rv.ROR4Mutator]MSP[N] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
final int l = Utils . digit16 ( bytes [ ++ i ] ) ; buffer . put ( (byte) ( ( u << 4 ) + l ) ) ; MST[rv.UOI2Mutator]MSP[N] } catch ( final ArrayIndexOutOfBoundsException e ) { throw new DecoderException ( lr_1 , e ) ; }
return c >= 0 ; MST[rv.CRCR5Mutator]MSP[N] } @Override public byte [] decode ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { return null ; } final ByteBuffer buffer = ByteBuffer . allocate ( expectedDecodingBytes ( bytes ) ) ;
for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ; MST[rv.UOI4Mutator]MSP[N] if ( b == ESCAPE_CHAR ) { try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[rv.CRCR4Mutator]MSP[N] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
buffer . put ( ( byte ) hex2 ) ; } else { if ( plusForSpace && b == ' ' ) { buffer . put ( ( byte ) '+' ) ; MST[experimental.NakedReceiverMutator]MSP[N] } else { buffer . put ( b ) ; } } }
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { MST[rv.UOI4Mutator]MSP[N] byteCount += canEncode ( b ) ? 3 : 1 ; } return byteCount ; }
for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ; MST[rv.ABSMutator]MSP[N] if ( b == ESCAPE_CHAR ) { try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
for ( final byte b : bytes ) { MST[rv.UOI4Mutator]MSP[N] if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
} else { if ( plusForSpace && b == '+' ) { MST[rv.CRCR6Mutator]MSP[N] buffer . put ( ( byte ) ' ' ) ; } else { buffer . put ( b ) ; } } } return buffer . array () ; }
buffer . put ( ( byte ) hex2 ) ; } else { if ( plusForSpace && b == ' ' ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] buffer . put ( ( byte ) '+' ) ; } else { buffer . put ( b ) ; } } }
for ( final byte b : bytes ) { MST[rv.UOI2Mutator]MSP[N] if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
byteCount ++ ; } return byteCount ; } @Override public Object encode ( final Object obj ) throws EncoderException { if ( obj == null ) { return null ; } else if ( obj instanceof byte [] ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] return encode ( ( byte [] ) obj ) ;
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { MST[rv.UOI3Mutator]MSP[S] if ( b == ' ' ) { return true ; } } return false ; } private boolean canEncode ( final byte c ) {
for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ; MST[rv.UOI2Mutator]MSP[N] if ( b == ESCAPE_CHAR ) { try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
final int l = Utils . digit16 ( bytes [ ++ i ] ) ; MST[rv.UOI3Mutator]MSP[N] buffer . put ( (byte) ( ( u << 4 ) + l ) ) ; } catch ( final ArrayIndexOutOfBoundsException e ) { throw new DecoderException ( lr_1 , e ) ; }
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; MST[rv.AOR1Mutator]MSP[N] }
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { MST[rv.UOI1Mutator]MSP[S] if ( b == ' ' ) { return true ; } } return false ; } private boolean canEncode ( final byte c ) {
for ( final byte b : bytes ) { MST[rv.ABSMutator]MSP[N] if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
} else { if ( plusForSpace && b == '+' ) { MST[rv.ROR1Mutator]MSP[N] buffer . put ( ( byte ) ' ' ) ; } else { buffer . put ( b ) ; } } } return buffer . array () ; }
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { if ( b == ' ' ) { return true ; } } return false ; MST[rv.CRCR5Mutator]MSP[S] } private boolean canEncode ( final byte c ) {
} else { if ( plusForSpace && b == '+' ) { MST[rv.ROR3Mutator]MSP[N] buffer . put ( ( byte ) ' ' ) ; } else { buffer . put ( b ) ; } } } return buffer . array () ; }
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; MST[rv.CRCR6Mutator]MSP[N] }
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; MST[rv.CRCR3Mutator]MSP[N] } private boolean isAsciiChar ( final byte c ) {
} else { throw new EncoderException ( lr_2 + obj . getClass () . getName () + lr_3 ) ; MST[NonVoidMethodCallMutator]MSP[S] } } @Override public Object decode ( final Object obj ) throws DecoderException { if ( obj == null ) { return null ;
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) { MST[rv.ROR4Mutator]MSP[N]
} else { throw new EncoderException ( lr_2 + obj . getClass () . getName () + lr_3 ) ; } } @Override public Object decode ( final Object obj ) throws DecoderException { if ( obj == null ) { MST[NegateConditionalsMutator]MSP[N] return null ;
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; MST[rv.CRCR5Mutator]MSP[N] } private boolean isAsciiChar ( final byte c ) {
return doEncode ( bytes , expectedEncodingBytes , willEncode ) ; MST[NullReturnValsMutator]MSP[N] } return bytes ; } private byte [] doEncode ( final byte [] bytes , final int expectedLength , final boolean willEncode ) { final ByteBuffer buffer = ByteBuffer . allocate ( expectedLength ) ;
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { MST[rv.UOI1Mutator]MSP[N] byteCount += canEncode ( b ) ? 3 : 1 ; } return byteCount ; }
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { byte bb = b ; MST[rv.ABSMutator]MSP[N] if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { MST[rv.UOI1Mutator]MSP[N] insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { MST[rv.UOI3Mutator]MSP[N] bb = (byte) ( 256 + bb ) ; }
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { MST[rv.CRCR6Mutator]MSP[N] final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ;
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { MST[NegateConditionalsMutator]MSP[N] final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ;
buffer . put ( ( byte ) hex2 ) ; } else { if ( plusForSpace && b == ' ' ) { buffer . put ( ( byte ) '+' ) ; MST[rv.CRCR3Mutator]MSP[N] } else { buffer . put ( b ) ; } } }
buffer . put ( ( byte ) hex2 ) ; } else { if ( plusForSpace && b == ' ' ) { MST[rv.CRCR2Mutator]MSP[N] buffer . put ( ( byte ) '+' ) ; } else { buffer . put ( b ) ; } } }
return c >= 0 ; MST[NegateConditionalsMutator]MSP[N] } @Override public byte [] decode ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { return null ; } final ByteBuffer buffer = ByteBuffer . allocate ( expectedDecodingBytes ( bytes ) ) ;
} else { if ( plusForSpace && b == '+' ) { buffer . put ( ( byte ) ' ' ) ; } else { buffer . put ( b ) ; MST[rv.UOI3Mutator]MSP[N] } } } return buffer . array () ; }
for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ; MST[rv.UOI1Mutator]MSP[N]
this . alwaysEncodeChars . set ( b ) ; if ( b < alwaysEncodeCharsMin ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] alwaysEncodeCharsMin = b ; } if ( b > alwaysEncodeCharsMax ) { alwaysEncodeCharsMax = b ; } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
for ( final byte b : bytes ) { MST[rv.UOI3Mutator]MSP[N] if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
return c >= 0 ; } @Override public byte [] decode ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { return null ; } final ByteBuffer buffer = ByteBuffer . allocate ( expectedDecodingBytes ( bytes ) ) ; MST[NonVoidMethodCallMutator]MSP[N]
} else if ( obj instanceof byte [] ) { return decode ( ( byte [] ) obj ) ; } else { throw new DecoderException ( lr_2 + obj . getClass () . getName () + lr_4 ) ; MST[NonVoidMethodCallMutator]MSP[S] } }
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; } return byteCount ; MST[PrimitiveReturnsMutator]MSP[N] }
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; MST[rv.CRCR4Mutator]MSP[N] if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) {
} else { if ( plusForSpace && b == '+' ) { MST[rv.ROR2Mutator]MSP[N] buffer . put ( ( byte ) ' ' ) ; } else { buffer . put ( b ) ; } } } return buffer . array () ; }
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; MST[rv.UOI2Mutator]MSP[N] } private boolean isAsciiChar ( final byte c ) {
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; MST[NegateConditionalsMutator]MSP[N] } private boolean isAsciiChar ( final byte c ) {
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) { MST[rv.ROR3Mutator]MSP[N]
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { if ( b == ' ' ) { return true ; MST[InlineConstantMutator]MSP[N] } } return false ; } private boolean canEncode ( final byte c ) {
} else if ( obj instanceof byte [] ) { return decode ( ( byte [] ) obj ) ; } else { throw new DecoderException ( lr_2 + obj . getClass () . getName () + lr_4 ) ; MST[experimental.NakedReceiverMutator]MSP[N] } }
} else if ( obj instanceof byte [] ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] return decode ( ( byte [] ) obj ) ; } else { throw new DecoderException ( lr_2 + obj . getClass () . getName () + lr_4 ) ; } }
final int l = Utils . digit16 ( bytes [ ++ i ] ) ; MST[IncrementsMutator]MSP[N] buffer . put ( (byte) ( ( u << 4 ) + l ) ) ; } catch ( final ArrayIndexOutOfBoundsException e ) { throw new DecoderException ( lr_1 , e ) ; }
final char hex1 = Utils . hexDigit ( bb >> 4 ) ; MST[rv.UOI2Mutator]MSP[N] final char hex2 = Utils . hexDigit ( bb ) ; buffer . put ( ESCAPE_CHAR ) ; buffer . put ( ( byte ) hex1 ) ;
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { MST[rv.ABSMutator]MSP[N] if ( b == ' ' ) { return true ; } } return false ; } private boolean canEncode ( final byte c ) {
} else { if ( plusForSpace && b == '+' ) { MST[rv.UOI4Mutator]MSP[N] buffer . put ( ( byte ) ' ' ) ; } else { buffer . put ( b ) ; } } } return buffer . array () ; }
return c >= 0 ; MST[rv.CRCR3Mutator]MSP[N] } @Override public byte [] decode ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { return null ; } final ByteBuffer buffer = ByteBuffer . allocate ( expectedDecodingBytes ( bytes ) ) ;
final int l = Utils . digit16 ( bytes [ ++ i ] ) ; buffer . put ( (byte) ( ( u << 4 ) + l ) ) ; MST[rv.UOI1Mutator]MSP[N] } catch ( final ArrayIndexOutOfBoundsException e ) { throw new DecoderException ( lr_1 , e ) ; }
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; MST[rv.CRCR1Mutator]MSP[N] for ( int i = 0 ; i < bytes . length ; ) { final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ;
byteCount ++ ; } return byteCount ; MST[PrimitiveReturnsMutator]MSP[N] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( obj == null ) { return null ; } else if ( obj instanceof byte [] ) { return encode ( ( byte [] ) obj ) ;
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { MST[rv.UOI4Mutator]MSP[N] if ( b == ' ' ) { return true ; } } return false ; } private boolean canEncode ( final byte c ) {
return doEncode ( bytes , expectedEncodingBytes , willEncode ) ; } return bytes ; } private byte [] doEncode ( final byte [] bytes , final int expectedLength , final boolean willEncode ) { final ByteBuffer buffer = ByteBuffer . allocate ( expectedLength ) ; MST[rv.UOI4Mutator]MSP[N]
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; MST[rv.CRCR4Mutator]MSP[N] } return byteCount ; }
this . alwaysEncodeChars . set ( b ) ; if ( b < alwaysEncodeCharsMin ) { alwaysEncodeCharsMin = b ; } if ( b > alwaysEncodeCharsMax ) { MST[rv.UOI1Mutator]MSP[N] alwaysEncodeCharsMax = b ; } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
return c >= 0 ; MST[rv.ROR3Mutator]MSP[N] } @Override public byte [] decode ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { return null ; } final ByteBuffer buffer = ByteBuffer . allocate ( expectedDecodingBytes ( bytes ) ) ;
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) { MST[NonVoidMethodCallMutator]MSP[N]
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[BooleanTrueReturnValsMutator]MSP[N] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
this . alwaysEncodeChars . set ( b ) ; if ( b < alwaysEncodeCharsMin ) { MST[rv.UOI2Mutator]MSP[N] alwaysEncodeCharsMin = b ; } if ( b > alwaysEncodeCharsMax ) { alwaysEncodeCharsMax = b ; } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
this . alwaysEncodeChars . set ( b ) ; if ( b < alwaysEncodeCharsMin ) { alwaysEncodeCharsMin = b ; MST[rv.ABSMutator]MSP[N] } if ( b > alwaysEncodeCharsMax ) { alwaysEncodeCharsMax = b ; } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] } private boolean isAsciiChar ( final byte c ) {
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; MST[rv.ROR3Mutator]MSP[N] } private boolean isAsciiChar ( final byte c ) {
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; MST[rv.ROR5Mutator]MSP[N] } private boolean isAsciiChar ( final byte c ) {
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; MST[ConditionalsBoundaryMutator]MSP[N] } private boolean isAsciiChar ( final byte c ) {
for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { MST[rv.CRCR6Mutator]MSP[N] try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
} else { throw new EncoderException ( lr_2 + obj . getClass () . getName () + lr_3 ) ; MST[NonVoidMethodCallMutator]MSP[S] } } @Override public Object decode ( final Object obj ) throws DecoderException { if ( obj == null ) { return null ;
return c >= 0 ; MST[InlineConstantMutator]MSP[N] } @Override public byte [] decode ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { return null ; } final ByteBuffer buffer = ByteBuffer . allocate ( expectedDecodingBytes ( bytes ) ) ;
this . alwaysEncodeChars . set ( b ) ; if ( b < alwaysEncodeCharsMin ) { alwaysEncodeCharsMin = b ; } if ( b > alwaysEncodeCharsMax ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] alwaysEncodeCharsMax = b ; } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { if ( b == ' ' ) { MST[rv.CRCR6Mutator]MSP[N] return true ; } } return false ; } private boolean canEncode ( final byte c ) {
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ; MST[rv.ROR4Mutator]MSP[N]
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { if ( b == ' ' ) { MST[rv.CRCR1Mutator]MSP[N] return true ; } } return false ; } private boolean canEncode ( final byte c ) {
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; MST[NonVoidMethodCallMutator]MSP[N] } return byteCount ; }
for ( int i = 0 ; i < bytes . length ; i ++ ) { MST[experimental.RemoveIncrementsMutator]MSP[N] final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ;
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[rv.UOI2Mutator]MSP[N] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[rv.UOI4Mutator]MSP[N] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
byteCount ++ ; } return byteCount ; MST[rv.UOI2Mutator]MSP[N] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( obj == null ) { return null ; } else if ( obj instanceof byte [] ) { return encode ( ( byte [] ) obj ) ;
this . alwaysEncodeChars . set ( b ) ; if ( b < alwaysEncodeCharsMin ) { MST[ConditionalsBoundaryMutator]MSP[N] alwaysEncodeCharsMin = b ; } if ( b > alwaysEncodeCharsMax ) { alwaysEncodeCharsMax = b ; } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
buffer . put ( ( byte ) hex2 ) ; } else { if ( plusForSpace && b == ' ' ) { buffer . put ( ( byte ) '+' ) ; MST[InlineConstantMutator]MSP[N] } else { buffer . put ( b ) ; } } }
for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { MST[rv.ROR1Mutator]MSP[N] try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
final char hex1 = Utils . hexDigit ( bb >> 4 ) ; final char hex2 = Utils . hexDigit ( bb ) ; buffer . put ( ESCAPE_CHAR ) ; buffer . put ( ( byte ) hex1 ) ; MST[rv.UOI4Mutator]MSP[N]
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ; MST[rv.CRCR2Mutator]MSP[N]
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { MST[ConditionalsBoundaryMutator]MSP[N] final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ;
return buffer . array () ; MST[NonVoidMethodCallMutator]MSP[N] } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; } return byteCount ; }
for ( int i = 0 ; i < bytes . length ; i ++ ) { MST[rv.ROR3Mutator]MSP[N] final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
this . alwaysEncodeChars . set ( b ) ; if ( b < alwaysEncodeCharsMin ) { MST[rv.ROR5Mutator]MSP[N] alwaysEncodeCharsMin = b ; } if ( b > alwaysEncodeCharsMax ) { alwaysEncodeCharsMax = b ; } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { MST[rv.UOI2Mutator]MSP[N] if ( b == ' ' ) { return true ; } } return false ; } private boolean canEncode ( final byte c ) {
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; MST[rv.UOI2Mutator]MSP[N] } private boolean isAsciiChar ( final byte c ) {
final char hex1 = Utils . hexDigit ( bb >> 4 ) ; final char hex2 = Utils . hexDigit ( bb ) ; buffer . put ( ESCAPE_CHAR ) ; MST[InlineConstantMutator]MSP[N] buffer . put ( ( byte ) hex1 ) ;
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; MST[rv.UOI2Mutator]MSP[N] } return byteCount ; }
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; MST[rv.CRCR1Mutator]MSP[S] } private void insertAlwaysEncodeChar ( final byte b ) {
final char hex1 = Utils . hexDigit ( bb >> 4 ) ; final char hex2 = Utils . hexDigit ( bb ) ; buffer . put ( ESCAPE_CHAR ) ; MST[rv.CRCR3Mutator]MSP[N] buffer . put ( ( byte ) hex1 ) ;
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { MST[rv.ROR4Mutator]MSP[N] byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
buffer . put ( ( byte ) hex2 ) ; } else { if ( plusForSpace && b == ' ' ) { MST[rv.ROR1Mutator]MSP[S] buffer . put ( ( byte ) '+' ) ; } else { buffer . put ( b ) ; } } }
final char hex1 = Utils . hexDigit ( bb >> 4 ) ; MST[rv.CRCR4Mutator]MSP[N] final char hex2 = Utils . hexDigit ( bb ) ; buffer . put ( ESCAPE_CHAR ) ; buffer . put ( ( byte ) hex1 ) ;
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { MST[rv.UOI4Mutator]MSP[S] insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; MST[rv.UOI1Mutator]MSP[N] if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) {
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[rv.ROR1Mutator]MSP[N] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { MST[rv.ROR1Mutator]MSP[N] bb = (byte) ( 256 + bb ) ; }
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { MST[rv.ROR5Mutator]MSP[N] final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ;
byteCount ++ ; } return byteCount ; } @Override public Object encode ( final Object obj ) throws EncoderException { if ( obj == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] return null ; } else if ( obj instanceof byte [] ) { return encode ( ( byte [] ) obj ) ;
buffer . put ( ( byte ) hex2 ) ; } else { if ( plusForSpace && b == ' ' ) { buffer . put ( ( byte ) '+' ) ; } else { buffer . put ( b ) ; MST[rv.UOI4Mutator]MSP[N] } } }
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; MST[rv.CRCR6Mutator]MSP[N] } return byteCount ; }
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; MST[rv.ROR4Mutator]MSP[N] if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) {
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { MST[rv.UOI2Mutator]MSP[N] final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ;
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { MST[rv.CRCR5Mutator]MSP[N] if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { MST[rv.UOI3Mutator]MSP[S] if ( b == ' ' ) { return true ; } } return false ; } private boolean canEncode ( final byte c ) {
final int l = Utils . digit16 ( bytes [ ++ i ] ) ; buffer . put ( (byte) ( ( u << 4 ) + l ) ) ; MST[rv.CRCR2Mutator]MSP[N] } catch ( final ArrayIndexOutOfBoundsException e ) { throw new DecoderException ( lr_1 , e ) ; }
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { MST[rv.CRCR4Mutator]MSP[N] if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { MST[rv.UOI4Mutator]MSP[N] try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { MST[rv.UOI4Mutator]MSP[N] byteCount += canEncode ( b ) ? 3 : 1 ; } return byteCount ; }
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[rv.CRCR3Mutator]MSP[N] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { MST[rv.CRCR2Mutator]MSP[N] if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
} else { if ( plusForSpace && b == '+' ) { MST[rv.CRCR3Mutator]MSP[N] buffer . put ( ( byte ) ' ' ) ; } else { buffer . put ( b ) ; } } } return buffer . array () ; }
for ( final byte b : bytes ) { MST[rv.UOI1Mutator]MSP[N] if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ; MST[rv.UOI1Mutator]MSP[N] if ( b == ESCAPE_CHAR ) { try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; MST[rv.CRCR3Mutator]MSP[N] }
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
} else { throw new EncoderException ( lr_2 + obj . getClass () . getName () + lr_3 ) ; MST[NonVoidMethodCallMutator]MSP[S] } } @Override public Object decode ( final Object obj ) throws DecoderException { if ( obj == null ) { return null ;
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { MST[rv.UOI4Mutator]MSP[N] final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ;
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; MST[rv.CRCR5Mutator]MSP[N] } private boolean isAsciiChar ( final byte c ) {
} else { if ( plusForSpace && b == '+' ) { buffer . put ( ( byte ) ' ' ) ; } else { buffer . put ( b ) ; MST[experimental.NakedReceiverMutator]MSP[N] } } } return buffer . array () ; }
for ( final byte b : bytes ) { MST[rv.ABSMutator]MSP[N] if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
for ( int i = 0 ; i < bytes . length ; i ++ ) { MST[NegateConditionalsMutator]MSP[N] final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; MST[rv.ABSMutator]MSP[N] } return byteCount ; }
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; MST[rv.ABSMutator]MSP[N] } private boolean isAsciiChar ( final byte c ) {
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ; MST[rv.UOI3Mutator]MSP[N]
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) { MST[rv.ROR1Mutator]MSP[N]
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { MST[rv.UOI3Mutator]MSP[N] byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
buffer . put ( ( byte ) hex2 ) ; } else { if ( plusForSpace && b == ' ' ) { MST[rv.ROR4Mutator]MSP[N] buffer . put ( ( byte ) '+' ) ; } else { buffer . put ( b ) ; } } }
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { MST[rv.ABSMutator]MSP[N] bb = (byte) ( 256 + bb ) ; }
final char hex1 = Utils . hexDigit ( bb >> 4 ) ; MST[rv.UOI1Mutator]MSP[N] final char hex2 = Utils . hexDigit ( bb ) ; buffer . put ( ESCAPE_CHAR ) ; buffer . put ( ( byte ) hex1 ) ;
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; MST[rv.CRCR6Mutator]MSP[N] for ( int i = 0 ; i < bytes . length ; ) { final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ;
} else if ( obj instanceof byte [] ) { MST[rv.ROR4Mutator]MSP[S] return decode ( ( byte [] ) obj ) ; } else { throw new DecoderException ( lr_2 + obj . getClass () . getName () + lr_4 ) ; } }
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { MST[rv.UOI1Mutator]MSP[N] if ( b == ' ' ) { return true ; } } return false ; } private boolean canEncode ( final byte c ) {
final int l = Utils . digit16 ( bytes [ ++ i ] ) ; MST[rv.ABSMutator]MSP[N] buffer . put ( (byte) ( ( u << 4 ) + l ) ) ; } catch ( final ArrayIndexOutOfBoundsException e ) { throw new DecoderException ( lr_1 , e ) ; }
this . alwaysEncodeChars . set ( b ) ; if ( b < alwaysEncodeCharsMin ) { alwaysEncodeCharsMin = b ; } if ( b > alwaysEncodeCharsMax ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] alwaysEncodeCharsMax = b ; } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
} else { if ( plusForSpace && b == '+' ) { buffer . put ( ( byte ) ' ' ) ; } else { buffer . put ( b ) ; } } } return buffer . array () ; MST[ReturnValsMutator]MSP[N] }
return c >= 0 ; MST[RemoveConditionalMutator_ORDER_IF]MSP[N] } @Override public byte [] decode ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { return null ; } final ByteBuffer buffer = ByteBuffer . allocate ( expectedDecodingBytes ( bytes ) ) ;
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ; MST[rv.CRCR4Mutator]MSP[N]
} else if ( obj instanceof byte [] ) { return decode ( ( byte [] ) obj ) ; MST[ArgumentPropagationMutator]MSP[N] } else { throw new DecoderException ( lr_2 + obj . getClass () . getName () + lr_4 ) ; } }
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; MST[InlineConstantMutator]MSP[N] } return byteCount ; }
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[NegateConditionalsMutator]MSP[N] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ; MST[rv.UOI4Mutator]MSP[N]
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; MST[rv.CRCR6Mutator]MSP[S] } private void insertAlwaysEncodeChar ( final byte b ) {
this . alwaysEncodeChars . set ( b ) ; if ( b < alwaysEncodeCharsMin ) { alwaysEncodeCharsMin = b ; MST[rv.UOI1Mutator]MSP[N] } if ( b > alwaysEncodeCharsMax ) { alwaysEncodeCharsMax = b ; } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
this . alwaysEncodeChars . set ( b ) ; if ( b < alwaysEncodeCharsMin ) { alwaysEncodeCharsMin = b ; } if ( b > alwaysEncodeCharsMax ) { MST[ConditionalsBoundaryMutator]MSP[N] alwaysEncodeCharsMax = b ; } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { MST[rv.CRCR1Mutator]MSP[N] if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
} else { if ( plusForSpace && b == '+' ) { buffer . put ( ( byte ) ' ' ) ; } else { buffer . put ( b ) ; MST[rv.ABSMutator]MSP[N] } } } return buffer . array () ; }
for ( int i = 0 ; i < bytes . length ; i ++ ) { MST[rv.ROR5Mutator]MSP[N] final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { MST[rv.UOI4Mutator]MSP[S] if ( b == ' ' ) { return true ; } } return false ; } private boolean canEncode ( final byte c ) {
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { MST[rv.CRCR4Mutator]MSP[N] if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
for ( int i = 0 ; i < bytes . length ; i ++ ) { MST[rv.CRCR6Mutator]MSP[N] final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; MST[rv.UOI2Mutator]MSP[N] } private boolean isAsciiChar ( final byte c ) {
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; MST[rv.UOI2Mutator]MSP[N] } return byteCount ; }
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; MST[NegateConditionalsMutator]MSP[N] } private boolean isAsciiChar ( final byte c ) {
this . alwaysEncodeChars . set ( b ) ; if ( b < alwaysEncodeCharsMin ) { alwaysEncodeCharsMin = b ; MST[experimental.MemberVariableMutator]MSP[N] } if ( b > alwaysEncodeCharsMax ) { alwaysEncodeCharsMax = b ; } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { MST[experimental.MemberVariableMutator]MSP[N] if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
for ( final byte b : bytes ) { MST[rv.UOI2Mutator]MSP[N] if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
final char hex1 = Utils . hexDigit ( bb >> 4 ) ; MST[rv.CRCR1Mutator]MSP[N] final char hex2 = Utils . hexDigit ( bb ) ; buffer . put ( ESCAPE_CHAR ) ; buffer . put ( ( byte ) hex1 ) ;
buffer . put ( ( byte ) hex2 ) ; } else { if ( plusForSpace && b == ' ' ) { MST[rv.ROR3Mutator]MSP[N] buffer . put ( ( byte ) '+' ) ; } else { buffer . put ( b ) ; } } }
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { MST[rv.UOI1Mutator]MSP[N] insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { final byte b = bytes [ i ] ; MST[rv.ABSMutator]MSP[N] i += b == ESCAPE_CHAR ? 3 : 1 ;
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; MST[ReturnValsMutator]MSP[N] } private boolean isAsciiChar ( final byte c ) {
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { MST[rv.ROR3Mutator]MSP[N] bb = (byte) ( 256 + bb ) ; }
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { MST[rv.UOI2Mutator]MSP[N] bb = (byte) ( 256 + bb ) ; }
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { MST[InlineConstantMutator]MSP[N] if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
} else { throw new EncoderException ( lr_2 + obj . getClass () . getName () + lr_3 ) ; MST[ConstructorCallMutator]MSP[S] } } @Override public Object decode ( final Object obj ) throws DecoderException { if ( obj == null ) { return null ;
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; MST[rv.CRCR4Mutator]MSP[N] } return byteCount ; }
buffer . put ( ( byte ) hex2 ) ; } else { if ( plusForSpace && b == ' ' ) { buffer . put ( ( byte ) '+' ) ; } else { buffer . put ( b ) ; MST[NonVoidMethodCallMutator]MSP[N] } } }
final int l = Utils . digit16 ( bytes [ ++ i ] ) ; MST[rv.UOI2Mutator]MSP[N] buffer . put ( (byte) ( ( u << 4 ) + l ) ) ; } catch ( final ArrayIndexOutOfBoundsException e ) { throw new DecoderException ( lr_1 , e ) ; }
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[rv.UOI3Mutator]MSP[N] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[rv.CRCR6Mutator]MSP[N] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
final int l = Utils . digit16 ( bytes [ ++ i ] ) ; buffer . put ( (byte) ( ( u << 4 ) + l ) ) ; MST[rv.CRCR4Mutator]MSP[N] } catch ( final ArrayIndexOutOfBoundsException e ) { throw new DecoderException ( lr_1 , e ) ; }
buffer . put ( ( byte ) hex2 ) ; } else { if ( plusForSpace && b == ' ' ) { MST[InlineConstantMutator]MSP[N] buffer . put ( ( byte ) '+' ) ; } else { buffer . put ( b ) ; } } }
} else { if ( plusForSpace && b == '+' ) { buffer . put ( ( byte ) ' ' ) ; } else { buffer . put ( b ) ; MST[rv.UOI2Mutator]MSP[N] } } } return buffer . array () ; }
return c >= 0 ; MST[rv.ROR4Mutator]MSP[N] } @Override public byte [] decode ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { return null ; } final ByteBuffer buffer = ByteBuffer . allocate ( expectedDecodingBytes ( bytes ) ) ;
this . alwaysEncodeChars . set ( b ) ; if ( b < alwaysEncodeCharsMin ) { alwaysEncodeCharsMin = b ; } if ( b > alwaysEncodeCharsMax ) { MST[rv.UOI2Mutator]MSP[N] alwaysEncodeCharsMax = b ; } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] } private boolean isAsciiChar ( final byte c ) {
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { MST[rv.CRCR5Mutator]MSP[N] if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
final int l = Utils . digit16 ( bytes [ ++ i ] ) ; buffer . put ( (byte) ( ( u << 4 ) + l ) ) ; MST[rv.UOI4Mutator]MSP[N] } catch ( final ArrayIndexOutOfBoundsException e ) { throw new DecoderException ( lr_1 , e ) ; }
} else { throw new EncoderException ( lr_2 + obj . getClass () . getName () + lr_3 ) ; MST[NonVoidMethodCallMutator]MSP[S] } } @Override public Object decode ( final Object obj ) throws DecoderException { if ( obj == null ) { return null ;
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { if ( b == ' ' ) { return true ; MST[rv.CRCR3Mutator]MSP[N] } } return false ; } private boolean canEncode ( final byte c ) {
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; MST[ConditionalsBoundaryMutator]MSP[N] } private boolean isAsciiChar ( final byte c ) {
return doEncode ( bytes , expectedEncodingBytes , willEncode ) ; MST[rv.UOI3Mutator]MSP[N] } return bytes ; } private byte [] doEncode ( final byte [] bytes , final int expectedLength , final boolean willEncode ) { final ByteBuffer buffer = ByteBuffer . allocate ( expectedLength ) ;
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; MST[rv.ABSMutator]MSP[N] } return byteCount ; }
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { MST[rv.ABSMutator]MSP[N] insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
byteCount ++ ; } return byteCount ; MST[ReturnValsMutator]MSP[N] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( obj == null ) { return null ; } else if ( obj instanceof byte [] ) { return encode ( ( byte [] ) obj ) ;
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { MST[rv.UOI2Mutator]MSP[N] insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { insertAlwaysEncodeChar ( b ) ; MST[rv.UOI3Mutator]MSP[N] } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { if ( b == ' ' ) { MST[rv.ROR3Mutator]MSP[N] return true ; } } return false ; } private boolean canEncode ( final byte c ) {
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[rv.UOI1Mutator]MSP[N] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
byteCount ++ ; } return byteCount ; MST[rv.UOI4Mutator]MSP[N] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( obj == null ) { return null ; } else if ( obj instanceof byte [] ) { return encode ( ( byte [] ) obj ) ;
} else { if ( plusForSpace && b == '+' ) { MST[rv.UOI3Mutator]MSP[N] buffer . put ( ( byte ) ' ' ) ; } else { buffer . put ( b ) ; } } } return buffer . array () ; }
this . alwaysEncodeChars . set ( b ) ; if ( b < alwaysEncodeCharsMin ) { MST[rv.UOI3Mutator]MSP[N] alwaysEncodeCharsMin = b ; } if ( b > alwaysEncodeCharsMax ) { alwaysEncodeCharsMax = b ; } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; MST[rv.UOI4Mutator]MSP[N] } private boolean isAsciiChar ( final byte c ) {
buffer . put ( ( byte ) hex2 ) ; } else { if ( plusForSpace && b == ' ' ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] buffer . put ( ( byte ) '+' ) ; } else { buffer . put ( b ) ; } } }
for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { MST[rv.ROR3Mutator]MSP[N] try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ; MST[rv.CRCR4Mutator]MSP[N]
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { MST[rv.UOI3Mutator]MSP[N] byteCount += canEncode ( b ) ? 3 : 1 ; } return byteCount ; }
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; MST[rv.CRCR1Mutator]MSP[N] if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) {
return doEncode ( bytes , expectedEncodingBytes , willEncode ) ; } return bytes ; } private byte [] doEncode ( final byte [] bytes , final int expectedLength , final boolean willEncode ) { final ByteBuffer buffer = ByteBuffer . allocate ( expectedLength ) ; MST[NonVoidMethodCallMutator]MSP[N]
for ( int i = 0 ; i < bytes . length ; i ++ ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
this . alwaysEncodeChars . set ( b ) ; if ( b < alwaysEncodeCharsMin ) { MST[rv.ROR1Mutator]MSP[N] alwaysEncodeCharsMin = b ; } if ( b > alwaysEncodeCharsMax ) { alwaysEncodeCharsMax = b ; } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { MST[rv.UOI1Mutator]MSP[N] if ( b == ' ' ) { return true ; } } return false ; } private boolean canEncode ( final byte c ) {
byteCount ++ ; } return byteCount ; MST[rv.UOI1Mutator]MSP[N] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( obj == null ) { return null ; } else if ( obj instanceof byte [] ) { return encode ( ( byte [] ) obj ) ;
final char hex1 = Utils . hexDigit ( bb >> 4 ) ; final char hex2 = Utils . hexDigit ( bb ) ; buffer . put ( ESCAPE_CHAR ) ; buffer . put ( ( byte ) hex1 ) ; MST[experimental.NakedReceiverMutator]MSP[N]
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; MST[rv.UOI2Mutator]MSP[N] } private boolean isAsciiChar ( final byte c ) {
buffer . put ( ( byte ) hex2 ) ; } else { if ( plusForSpace && b == ' ' ) { MST[rv.ABSMutator]MSP[N] buffer . put ( ( byte ) '+' ) ; } else { buffer . put ( b ) ; } } }
} else { if ( plusForSpace && b == '+' ) { buffer . put ( ( byte ) ' ' ) ; MST[rv.CRCR4Mutator]MSP[N] } else { buffer . put ( b ) ; } } } return buffer . array () ; }
} else { if ( plusForSpace && b == '+' ) { buffer . put ( ( byte ) ' ' ) ; MST[rv.CRCR1Mutator]MSP[N] } else { buffer . put ( b ) ; } } } return buffer . array () ; }
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { MST[ConditionalsBoundaryMutator]MSP[N] bb = (byte) ( 256 + bb ) ; }
this . alwaysEncodeChars . set ( b ) ; if ( b < alwaysEncodeCharsMin ) { alwaysEncodeCharsMin = b ; } if ( b > alwaysEncodeCharsMax ) { MST[rv.ROR5Mutator]MSP[N] alwaysEncodeCharsMax = b ; } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { MST[rv.ROR1Mutator]MSP[N] byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
byteCount ++ ; } return byteCount ; } @Override public Object encode ( final Object obj ) throws EncoderException { if ( obj == null ) { return null ; } else if ( obj instanceof byte [] ) { return encode ( ( byte [] ) obj ) ; MST[NonVoidMethodCallMutator]MSP[S]
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { MST[rv.ROR4Mutator]MSP[N] byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; MST[rv.ROR4Mutator]MSP[N] } return byteCount ; }
final char hex1 = Utils . hexDigit ( bb >> 4 ) ; MST[rv.UOI4Mutator]MSP[N] final char hex2 = Utils . hexDigit ( bb ) ; buffer . put ( ESCAPE_CHAR ) ; buffer . put ( ( byte ) hex1 ) ;
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[rv.ROR5Mutator]MSP[N] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) { MST[NegateConditionalsMutator]MSP[N]
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[rv.UOI4Mutator]MSP[N] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { MST[rv.CRCR3Mutator]MSP[N] final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ;
for ( int i = 0 ; i < bytes . length ; i ++ ) { MST[rv.UOI4Mutator]MSP[N] final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; } return byteCount ; MST[rv.UOI2Mutator]MSP[N] }
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; MST[rv.CRCR6Mutator]MSP[N] if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) {
final char hex1 = Utils . hexDigit ( bb >> 4 ) ; final char hex2 = Utils . hexDigit ( bb ) ; MST[rv.ABSMutator]MSP[N] buffer . put ( ESCAPE_CHAR ) ; buffer . put ( ( byte ) hex1 ) ;
final char hex1 = Utils . hexDigit ( bb >> 4 ) ; MST[NonVoidMethodCallMutator]MSP[N] final char hex2 = Utils . hexDigit ( bb ) ; buffer . put ( ESCAPE_CHAR ) ; buffer . put ( ( byte ) hex1 ) ;
for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ; MST[rv.UOI3Mutator]MSP[N]
return doEncode ( bytes , expectedEncodingBytes , willEncode ) ; MST[rv.ABSMutator]MSP[N] } return bytes ; } private byte [] doEncode ( final byte [] bytes , final int expectedLength , final boolean willEncode ) { final ByteBuffer buffer = ByteBuffer . allocate ( expectedLength ) ;
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ; MST[rv.CRCR1Mutator]MSP[N]
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; MST[rv.ABSMutator]MSP[N] } private boolean isAsciiChar ( final byte c ) {
for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { MST[rv.UOI1Mutator]MSP[N] try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; MST[rv.AOR3Mutator]MSP[N] }
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { MST[rv.UOI2Mutator]MSP[N] byteCount += canEncode ( b ) ? 3 : 1 ; } return byteCount ; }
} else { if ( plusForSpace && b == '+' ) { MST[rv.ROR5Mutator]MSP[N] buffer . put ( ( byte ) ' ' ) ; } else { buffer . put ( b ) ; } } } return buffer . array () ; }
for ( int i = 0 ; i < bytes . length ; i ++ ) { MST[rv.UOI2Mutator]MSP[N] final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; MST[rv.CRCR5Mutator]MSP[N] for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; } return byteCount ; }
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; MST[rv.CRCR3Mutator]MSP[N] for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; } return byteCount ; }
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { final byte b = bytes [ i ] ; MST[rv.UOI3Mutator]MSP[N] i += b == ESCAPE_CHAR ? 3 : 1 ;
for ( final byte b : bytes ) { MST[rv.UOI1Mutator]MSP[N] if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
this . alwaysEncodeChars . set ( b ) ; if ( b < alwaysEncodeCharsMin ) { alwaysEncodeCharsMin = b ; } if ( b > alwaysEncodeCharsMax ) { MST[rv.UOI4Mutator]MSP[N] alwaysEncodeCharsMax = b ; } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) { MST[rv.ROR1Mutator]MSP[S]
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) { MST[rv.ROR3Mutator]MSP[N]
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { MST[rv.UOI3Mutator]MSP[N] insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
buffer . put ( ( byte ) hex2 ) ; } else { if ( plusForSpace && b == ' ' ) { MST[rv.CRCR4Mutator]MSP[N] buffer . put ( ( byte ) '+' ) ; } else { buffer . put ( b ) ; } } }
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) { MST[rv.UOI4Mutator]MSP[N]
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) { MST[rv.UOI2Mutator]MSP[N]
buffer . put ( ( byte ) hex2 ) ; } else { if ( plusForSpace && b == ' ' ) { buffer . put ( ( byte ) '+' ) ; MST[rv.CRCR5Mutator]MSP[N] } else { buffer . put ( b ) ; } } }
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { final byte b = bytes [ i ] ; MST[rv.UOI1Mutator]MSP[N] i += b == ESCAPE_CHAR ? 3 : 1 ;
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[rv.ROR1Mutator]MSP[N] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
buffer . put ( ( byte ) hex2 ) ; } else { if ( plusForSpace && b == ' ' ) { buffer . put ( ( byte ) '+' ) ; } else { buffer . put ( b ) ; MST[rv.UOI1Mutator]MSP[N] } } }
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; MST[rv.UOI4Mutator]MSP[N] } private boolean isAsciiChar ( final byte c ) {
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { if ( b == ' ' ) { MST[rv.UOI3Mutator]MSP[N] return true ; } } return false ; } private boolean canEncode ( final byte c ) {
return c >= 0 ; MST[rv.CRCR4Mutator]MSP[N] } @Override public byte [] decode ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { return null ; } final ByteBuffer buffer = ByteBuffer . allocate ( expectedDecodingBytes ( bytes ) ) ;
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; MST[InlineConstantMutator]MSP[N] } return byteCount ; }
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { if ( b == ' ' ) { MST[rv.UOI1Mutator]MSP[N] return true ; } } return false ; } private boolean canEncode ( final byte c ) {
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; MST[rv.AOR2Mutator]MSP[N] } return byteCount ; }
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; MST[rv.CRCR3Mutator]MSP[N] if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) {
this . alwaysEncodeChars . set ( b ) ; if ( b < alwaysEncodeCharsMin ) { alwaysEncodeCharsMin = b ; } if ( b > alwaysEncodeCharsMax ) { MST[rv.ABSMutator]MSP[S] alwaysEncodeCharsMax = b ; } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
final char hex1 = Utils . hexDigit ( bb >> 4 ) ; final char hex2 = Utils . hexDigit ( bb ) ; buffer . put ( ESCAPE_CHAR ) ; MST[rv.CRCR5Mutator]MSP[N] buffer . put ( ( byte ) hex1 ) ;
for ( int i = 0 ; i < bytes . length ; i ++ ) { MST[rv.ABSMutator]MSP[N] final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { if ( b == ' ' ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return true ; } } return false ; } private boolean canEncode ( final byte c ) {
buffer . put ( ( byte ) hex2 ) ; MST[rv.UOI4Mutator]MSP[N] } else { if ( plusForSpace && b == ' ' ) { buffer . put ( ( byte ) '+' ) ; } else { buffer . put ( b ) ; } } }
for ( int i = 0 ; i < bytes . length ; i ++ ) { MST[rv.CRCR3Mutator]MSP[N] final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
for ( int i = 0 ; i < bytes . length ; i ++ ) { MST[ConditionalsBoundaryMutator]MSP[N] final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) { MST[rv.ABSMutator]MSP[N]
return doEncode ( bytes , expectedEncodingBytes , willEncode ) ; MST[rv.UOI2Mutator]MSP[N] } return bytes ; } private byte [] doEncode ( final byte [] bytes , final int expectedLength , final boolean willEncode ) { final ByteBuffer buffer = ByteBuffer . allocate ( expectedLength ) ;
} else { if ( plusForSpace && b == '+' ) { MST[NegateConditionalsMutator]MSP[N] buffer . put ( ( byte ) ' ' ) ; } else { buffer . put ( b ) ; } } } return buffer . array () ; }
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; MST[rv.CRCR3Mutator]MSP[N] } private void insertAlwaysEncodeChar ( final byte b ) {
final char hex1 = Utils . hexDigit ( bb >> 4 ) ; MST[rv.CRCR6Mutator]MSP[N] final char hex2 = Utils . hexDigit ( bb ) ; buffer . put ( ESCAPE_CHAR ) ; buffer . put ( ( byte ) hex1 ) ;
} else { throw new EncoderException ( lr_2 + obj . getClass () . getName () + lr_3 ) ; } } @Override public Object decode ( final Object obj ) throws DecoderException { if ( obj == null ) { MST[rv.ROR5Mutator]MSP[N] return null ;
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ; MST[rv.UOI4Mutator]MSP[N]
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; MST[rv.ROR2Mutator]MSP[N] } return byteCount ; }
} else { if ( plusForSpace && b == '+' ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] buffer . put ( ( byte ) ' ' ) ; } else { buffer . put ( b ) ; } } } return buffer . array () ; }
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[rv.ROR3Mutator]MSP[N] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] bb = (byte) ( 256 + bb ) ; }
} else { if ( plusForSpace && b == '+' ) { buffer . put ( ( byte ) ' ' ) ; } else { buffer . put ( b ) ; } } } return buffer . array () ; MST[NullReturnValsMutator]MSP[N] }
for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ; MST[IncrementsMutator]MSP[N]
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; MST[rv.UOI3Mutator]MSP[N] if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) {
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { if ( b == ' ' ) { MST[NegateConditionalsMutator]MSP[S] return true ; } } return false ; } private boolean canEncode ( final byte c ) {
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { MST[rv.CRCR6Mutator]MSP[N] if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
final int l = Utils . digit16 ( bytes [ ++ i ] ) ; buffer . put ( (byte) ( ( u << 4 ) + l ) ) ; MST[experimental.NakedReceiverMutator]MSP[N] } catch ( final ArrayIndexOutOfBoundsException e ) { throw new DecoderException ( lr_1 , e ) ; }
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[rv.CRCR6Mutator]MSP[N] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
byteCount ++ ; } return byteCount ; } @Override public Object encode ( final Object obj ) throws EncoderException { if ( obj == null ) { return null ; } else if ( obj instanceof byte [] ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] return encode ( ( byte [] ) obj ) ;
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; MST[rv.ROR2Mutator]MSP[N] } private boolean isAsciiChar ( final byte c ) {
final char hex1 = Utils . hexDigit ( bb >> 4 ) ; final char hex2 = Utils . hexDigit ( bb ) ; buffer . put ( ESCAPE_CHAR ) ; buffer . put ( ( byte ) hex1 ) ; MST[rv.UOI1Mutator]MSP[N]
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; MST[rv.ABSMutator]MSP[N] } private boolean isAsciiChar ( final byte c ) {
} else { throw new EncoderException ( lr_2 + obj . getClass () . getName () + lr_3 ) ; } } @Override public Object decode ( final Object obj ) throws DecoderException { if ( obj == null ) { return null ; MST[ReturnValsMutator]MSP[S]
buffer . put ( ( byte ) hex2 ) ; MST[rv.ABSMutator]MSP[N] } else { if ( plusForSpace && b == ' ' ) { buffer . put ( ( byte ) '+' ) ; } else { buffer . put ( b ) ; } } }
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { MST[rv.CRCR3Mutator]MSP[N] if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
buffer . put ( ( byte ) hex2 ) ; } else { if ( plusForSpace && b == ' ' ) { MST[NegateConditionalsMutator]MSP[N] buffer . put ( ( byte ) '+' ) ; } else { buffer . put ( b ) ; } } }
} else if ( obj instanceof byte [] ) { return decode ( ( byte [] ) obj ) ; } else { throw new DecoderException ( lr_2 + obj . getClass () . getName () + lr_4 ) ; MST[ConstructorCallMutator]MSP[S] } }
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { if ( b == ' ' ) { return true ; MST[ReturnValsMutator]MSP[N] } } return false ; } private boolean canEncode ( final byte c ) {
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { MST[rv.ABSMutator]MSP[N] byteCount += canEncode ( b ) ? 3 : 1 ; } return byteCount ; }
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { if ( b == ' ' ) { return true ; MST[rv.CRCR5Mutator]MSP[N] } } return false ; } private boolean canEncode ( final byte c ) {
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; MST[InlineConstantMutator]MSP[N] } private boolean isAsciiChar ( final byte c ) {
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { MST[rv.ABSMutator]MSP[N] insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { MST[NegateConditionalsMutator]MSP[N] bb = (byte) ( 256 + bb ) ; }
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { MST[rv.UOI2Mutator]MSP[N] insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ; MST[rv.ROR1Mutator]MSP[N]
buffer . put ( ( byte ) hex2 ) ; } else { if ( plusForSpace && b == ' ' ) { MST[rv.UOI2Mutator]MSP[N] buffer . put ( ( byte ) '+' ) ; } else { buffer . put ( b ) ; } } }
return doEncode ( bytes , expectedEncodingBytes , willEncode ) ; } return bytes ; MST[ReturnValsMutator]MSP[N] } private byte [] doEncode ( final byte [] bytes , final int expectedLength , final boolean willEncode ) { final ByteBuffer buffer = ByteBuffer . allocate ( expectedLength ) ;
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { if ( b == ' ' ) { MST[rv.CRCR3Mutator]MSP[N] return true ; } } return false ; } private boolean canEncode ( final byte c ) {
for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { MST[rv.CRCR3Mutator]MSP[N] try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { if ( b == ' ' ) { return true ; } } return false ; MST[InlineConstantMutator]MSP[S] } private boolean canEncode ( final byte c ) {
final int l = Utils . digit16 ( bytes [ ++ i ] ) ; buffer . put ( (byte) ( ( u << 4 ) + l ) ) ; MST[rv.ABSMutator]MSP[N] } catch ( final ArrayIndexOutOfBoundsException e ) { throw new DecoderException ( lr_1 , e ) ; }
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; MST[rv.ROR1Mutator]MSP[N] if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) {
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; MST[rv.UOI4Mutator]MSP[N] } private boolean isAsciiChar ( final byte c ) {
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { MST[rv.ROR2Mutator]MSP[N] final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ;
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
return c >= 0 ; MST[rv.UOI3Mutator]MSP[S] } @Override public byte [] decode ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { return null ; } final ByteBuffer buffer = ByteBuffer . allocate ( expectedDecodingBytes ( bytes ) ) ;
this . alwaysEncodeChars . set ( b ) ; MST[rv.UOI3Mutator]MSP[N] if ( b < alwaysEncodeCharsMin ) { alwaysEncodeCharsMin = b ; } if ( b > alwaysEncodeCharsMax ) { alwaysEncodeCharsMax = b ; } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
return doEncode ( bytes , expectedEncodingBytes , willEncode ) ; } return bytes ; } private byte [] doEncode ( final byte [] bytes , final int expectedLength , final boolean willEncode ) { final ByteBuffer buffer = ByteBuffer . allocate ( expectedLength ) ; MST[rv.UOI1Mutator]MSP[N]
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { if ( b == ' ' ) { MST[rv.ROR5Mutator]MSP[S] return true ; } } return false ; } private boolean canEncode ( final byte c ) {
final char hex1 = Utils . hexDigit ( bb >> 4 ) ; final char hex2 = Utils . hexDigit ( bb ) ; MST[rv.UOI2Mutator]MSP[N] buffer . put ( ESCAPE_CHAR ) ; buffer . put ( ( byte ) hex1 ) ;
for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { MST[NegateConditionalsMutator]MSP[N] try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { MST[rv.UOI3Mutator]MSP[N] byteCount += canEncode ( b ) ? 3 : 1 ; } return byteCount ; }
} else { if ( plusForSpace && b == '+' ) { MST[rv.ROR4Mutator]MSP[N] buffer . put ( ( byte ) ' ' ) ; } else { buffer . put ( b ) ; } } } return buffer . array () ; }
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { MST[rv.CRCR2Mutator]MSP[N] if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
return doEncode ( bytes , expectedEncodingBytes , willEncode ) ; } return bytes ; MST[NullReturnValsMutator]MSP[N] } private byte [] doEncode ( final byte [] bytes , final int expectedLength , final boolean willEncode ) { final ByteBuffer buffer = ByteBuffer . allocate ( expectedLength ) ;
this . alwaysEncodeChars . set ( b ) ; if ( b < alwaysEncodeCharsMin ) { alwaysEncodeCharsMin = b ; } if ( b > alwaysEncodeCharsMax ) { MST[rv.ABSMutator]MSP[N] alwaysEncodeCharsMax = b ; } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) { MST[rv.ROR5Mutator]MSP[N]
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { MST[rv.UOI4Mutator]MSP[N] byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { MST[experimental.MemberVariableMutator]MSP[N] if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { MST[rv.ROR1Mutator]MSP[N] byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; MST[rv.CRCR3Mutator]MSP[N] for ( int i = 0 ; i < bytes . length ; ) { final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ;
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ; MST[rv.ABSMutator]MSP[N]
return c >= 0 ; MST[rv.CRCR1Mutator]MSP[N] } @Override public byte [] decode ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { return null ; } final ByteBuffer buffer = ByteBuffer . allocate ( expectedDecodingBytes ( bytes ) ) ;
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { MST[InlineConstantMutator]MSP[N] if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; MST[rv.UOI3Mutator]MSP[N] }
byteCount ++ ; } return byteCount ; } @Override public Object encode ( final Object obj ) throws EncoderException { if ( obj == null ) { return null ; } else if ( obj instanceof byte [] ) { MST[rv.ROR1Mutator]MSP[S] return encode ( ( byte [] ) obj ) ;
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; MST[rv.CRCR6Mutator]MSP[N] if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) {
final int l = Utils . digit16 ( bytes [ ++ i ] ) ; MST[rv.UOI1Mutator]MSP[N] buffer . put ( (byte) ( ( u << 4 ) + l ) ) ; } catch ( final ArrayIndexOutOfBoundsException e ) { throw new DecoderException ( lr_1 , e ) ; }
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; MST[rv.CRCR2Mutator]MSP[N] } return byteCount ; }
for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ; MST[rv.ABSMutator]MSP[N]
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ;
} else { if ( plusForSpace && b == '+' ) { MST[rv.CRCR5Mutator]MSP[N] buffer . put ( ( byte ) ' ' ) ; } else { buffer . put ( b ) ; } } } return buffer . array () ; }
} else if ( obj instanceof byte [] ) { return decode ( ( byte [] ) obj ) ; } else { throw new DecoderException ( lr_2 + obj . getClass () . getName () + lr_4 ) ; MST[NonVoidMethodCallMutator]MSP[N] } }
for ( final byte b : bytes ) { MST[rv.UOI3Mutator]MSP[N] if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
final int l = Utils . digit16 ( bytes [ ++ i ] ) ; MST[rv.UOI4Mutator]MSP[N] buffer . put ( (byte) ( ( u << 4 ) + l ) ) ; } catch ( final ArrayIndexOutOfBoundsException e ) { throw new DecoderException ( lr_1 , e ) ; }
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; MST[rv.CRCR6Mutator]MSP[N] for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; } return byteCount ; }
} else { if ( plusForSpace && b == '+' ) { MST[rv.ROR2Mutator]MSP[N] buffer . put ( ( byte ) ' ' ) ; } else { buffer . put ( b ) ; } } } return buffer . array () ; }
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; MST[rv.AOR2Mutator]MSP[N] }
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { MST[rv.UOI2Mutator]MSP[N] if ( b == ' ' ) { return true ; } } return false ; } private boolean canEncode ( final byte c ) {
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; MST[rv.CRCR5Mutator]MSP[N] }
for ( int i = 0 ; i < bytes . length ; i ++ ) { MST[rv.UOI1Mutator]MSP[N] final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { MST[rv.UOI4Mutator]MSP[N] bb = (byte) ( 256 + bb ) ; }
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; MST[rv.CRCR2Mutator]MSP[N] } private boolean isAsciiChar ( final byte c ) {
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) { MST[rv.UOI1Mutator]MSP[N]
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; MST[rv.CRCR6Mutator]MSP[N] } private boolean isAsciiChar ( final byte c ) {
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { MST[rv.ABSMutator]MSP[N] byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) { MST[rv.ROR3Mutator]MSP[N]
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[rv.ROR2Mutator]MSP[N] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
final char hex1 = Utils . hexDigit ( bb >> 4 ) ; MST[rv.UOI3Mutator]MSP[N] final char hex2 = Utils . hexDigit ( bb ) ; buffer . put ( ESCAPE_CHAR ) ; buffer . put ( ( byte ) hex1 ) ;
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { MST[rv.ABSMutator]MSP[N] final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ;
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; MST[rv.UOI4Mutator]MSP[N] } private boolean isAsciiChar ( final byte c ) {
final int l = Utils . digit16 ( bytes [ ++ i ] ) ; buffer . put ( (byte) ( ( u << 4 ) + l ) ) ; MST[rv.UOI2Mutator]MSP[N] } catch ( final ArrayIndexOutOfBoundsException e ) { throw new DecoderException ( lr_1 , e ) ; }
return c >= 0 ; MST[rv.CRCR6Mutator]MSP[N] } @Override public byte [] decode ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { return null ; } final ByteBuffer buffer = ByteBuffer . allocate ( expectedDecodingBytes ( bytes ) ) ;
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ; MST[rv.CRCR6Mutator]MSP[N]
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { MST[rv.UOI3Mutator]MSP[N] if ( b == ' ' ) { return true ; } } return false ; } private boolean canEncode ( final byte c ) {
for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ; MST[rv.UOI3Mutator]MSP[N] if ( b == ESCAPE_CHAR ) { try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[rv.CRCR5Mutator]MSP[N] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { MST[rv.CRCR4Mutator]MSP[N] if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
buffer . put ( ( byte ) hex2 ) ; } else { if ( plusForSpace && b == ' ' ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] buffer . put ( ( byte ) '+' ) ; } else { buffer . put ( b ) ; } } }
this . alwaysEncodeChars . set ( b ) ; if ( b < alwaysEncodeCharsMin ) { MST[rv.ABSMutator]MSP[N] alwaysEncodeCharsMin = b ; } if ( b > alwaysEncodeCharsMax ) { alwaysEncodeCharsMax = b ; } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; MST[rv.CRCR3Mutator]MSP[N] if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) {
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { MST[rv.UOI1Mutator]MSP[N] byteCount += canEncode ( b ) ? 3 : 1 ; } return byteCount ; }
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; MST[rv.UOI1Mutator]MSP[N] } private boolean isAsciiChar ( final byte c ) {
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
buffer . put ( ( byte ) hex2 ) ; MST[rv.UOI1Mutator]MSP[N] } else { if ( plusForSpace && b == ' ' ) { buffer . put ( ( byte ) '+' ) ; } else { buffer . put ( b ) ; } } }
if ( bytes == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) {
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { MST[rv.ABSMutator]MSP[N] byteCount += canEncode ( b ) ? 3 : 1 ; } return byteCount ; }
} else { if ( plusForSpace && b == '+' ) { buffer . put ( ( byte ) ' ' ) ; MST[InlineConstantMutator]MSP[N] } else { buffer . put ( b ) ; } } } return buffer . array () ; }
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) { MST[rv.ROR2Mutator]MSP[N]
final char hex1 = Utils . hexDigit ( bb >> 4 ) ; final char hex2 = Utils . hexDigit ( bb ) ; buffer . put ( ESCAPE_CHAR ) ; MST[rv.CRCR2Mutator]MSP[N] buffer . put ( ( byte ) hex1 ) ;
} else { if ( plusForSpace && b == '+' ) { buffer . put ( ( byte ) ' ' ) ; MST[rv.CRCR6Mutator]MSP[N] } else { buffer . put ( b ) ; } } } return buffer . array () ; }
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { MST[rv.ROR3Mutator]MSP[N] byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { MST[rv.CRCR5Mutator]MSP[N] final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ;
final int l = Utils . digit16 ( bytes [ ++ i ] ) ; buffer . put ( (byte) ( ( u << 4 ) + l ) ) ; } catch ( final ArrayIndexOutOfBoundsException e ) { throw new DecoderException ( lr_1 , e ) ; MST[ConstructorCallMutator]MSP[S] }
for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ; MST[NonVoidMethodCallMutator]MSP[N]
return c >= 0 ; MST[rv.UOI4Mutator]MSP[N] } @Override public byte [] decode ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { return null ; } final ByteBuffer buffer = ByteBuffer . allocate ( expectedDecodingBytes ( bytes ) ) ;
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
buffer . put ( ( byte ) hex2 ) ; } else { if ( plusForSpace && b == ' ' ) { buffer . put ( ( byte ) '+' ) ; MST[rv.CRCR2Mutator]MSP[N] } else { buffer . put ( b ) ; } } }
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ; MST[MathMutator]MSP[N]
for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ; MST[rv.UOI2Mutator]MSP[N]
} else { if ( plusForSpace && b == '+' ) { buffer . put ( ( byte ) ' ' ) ; MST[NonVoidMethodCallMutator]MSP[N] } else { buffer . put ( b ) ; } } } return buffer . array () ; }
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; MST[rv.ABSMutator]MSP[N] } private boolean isAsciiChar ( final byte c ) {
for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { MST[rv.ROR5Mutator]MSP[N] try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
return c >= 0 ; MST[rv.ROR2Mutator]MSP[N] } @Override public byte [] decode ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { return null ; } final ByteBuffer buffer = ByteBuffer . allocate ( expectedDecodingBytes ( bytes ) ) ;
byteCount ++ ; } return byteCount ; MST[rv.ABSMutator]MSP[N] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( obj == null ) { return null ; } else if ( obj instanceof byte [] ) { return encode ( ( byte [] ) obj ) ;
buffer . put ( ( byte ) hex2 ) ; MST[experimental.NakedReceiverMutator]MSP[N] } else { if ( plusForSpace && b == ' ' ) { buffer . put ( ( byte ) '+' ) ; } else { buffer . put ( b ) ; } } }
this . alwaysEncodeChars . set ( b ) ; if ( b < alwaysEncodeCharsMin ) { MST[rv.UOI1Mutator]MSP[N] alwaysEncodeCharsMin = b ; } if ( b > alwaysEncodeCharsMax ) { alwaysEncodeCharsMax = b ; } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; MST[rv.ROR2Mutator]MSP[N] } private boolean isAsciiChar ( final byte c ) {
final int l = Utils . digit16 ( bytes [ ++ i ] ) ; buffer . put ( (byte) ( ( u << 4 ) + l ) ) ; MST[InlineConstantMutator]MSP[N] } catch ( final ArrayIndexOutOfBoundsException e ) { throw new DecoderException ( lr_1 , e ) ; }
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; MST[NegateConditionalsMutator]MSP[N] } return byteCount ; }
this . alwaysEncodeChars . set ( b ) ; if ( b < alwaysEncodeCharsMin ) { alwaysEncodeCharsMin = b ; } if ( b > alwaysEncodeCharsMax ) { alwaysEncodeCharsMax = b ; MST[rv.ABSMutator]MSP[N] } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
buffer . put ( ( byte ) hex2 ) ; MST[NonVoidMethodCallMutator]MSP[N] } else { if ( plusForSpace && b == ' ' ) { buffer . put ( ( byte ) '+' ) ; } else { buffer . put ( b ) ; } } }
for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; MST[InlineConstantMutator]MSP[N] for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; } return byteCount ; }
buffer . put ( ( byte ) hex2 ) ; } else { if ( plusForSpace && b == ' ' ) { MST[rv.UOI4Mutator]MSP[N] buffer . put ( ( byte ) '+' ) ; } else { buffer . put ( b ) ; } } }
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; } return byteCount ; MST[ReturnValsMutator]MSP[N] }
buffer . put ( ( byte ) hex2 ) ; } else { if ( plusForSpace && b == ' ' ) { MST[rv.UOI1Mutator]MSP[N] buffer . put ( ( byte ) '+' ) ; } else { buffer . put ( b ) ; } } }
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { if ( b == ' ' ) { MST[rv.CRCR5Mutator]MSP[N] return true ; } } return false ; } private boolean canEncode ( final byte c ) {
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { MST[rv.UOI4Mutator]MSP[N] insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { MST[InlineConstantMutator]MSP[N] if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; MST[rv.UOI2Mutator]MSP[N] if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) {
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { MST[rv.ROR4Mutator]MSP[N] final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ;
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; MST[rv.ROR3Mutator]MSP[N] if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) {
this . alwaysEncodeChars . set ( b ) ; if ( b < alwaysEncodeCharsMin ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] alwaysEncodeCharsMin = b ; } if ( b > alwaysEncodeCharsMax ) { alwaysEncodeCharsMax = b ; } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; MST[rv.CRCR5Mutator]MSP[N] } return byteCount ; }
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { MST[rv.ABSMutator]MSP[N] if ( b == ' ' ) { return true ; } } return false ; } private boolean canEncode ( final byte c ) {
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ; MST[rv.CRCR6Mutator]MSP[N]
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { if ( alwaysEncodeCharsArray != null ) { MST[NegateConditionalsMutator]MSP[N] for ( final byte b : alwaysEncodeCharsArray ) { insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { MST[rv.CRCR3Mutator]MSP[N] if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
final char hex1 = Utils . hexDigit ( bb >> 4 ) ; final char hex2 = Utils . hexDigit ( bb ) ; MST[rv.UOI4Mutator]MSP[N] buffer . put ( ESCAPE_CHAR ) ; buffer . put ( ( byte ) hex1 ) ;
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) {
final char hex1 = Utils . hexDigit ( bb >> 4 ) ; MST[rv.CRCR3Mutator]MSP[N] final char hex2 = Utils . hexDigit ( bb ) ; buffer . put ( ESCAPE_CHAR ) ; buffer . put ( ( byte ) hex1 ) ;
byteCount ++ ; MST[IncrementsMutator]MSP[N] } return byteCount ; } @Override public Object encode ( final Object obj ) throws EncoderException { if ( obj == null ) { return null ; } else if ( obj instanceof byte [] ) { return encode ( ( byte [] ) obj ) ;
this . alwaysEncodeChars . set ( b ) ; if ( b < alwaysEncodeCharsMin ) { MST[rv.ABSMutator]MSP[N] alwaysEncodeCharsMin = b ; } if ( b > alwaysEncodeCharsMax ) { alwaysEncodeCharsMax = b ; } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; MST[rv.CRCR5Mutator]MSP[S] } private void insertAlwaysEncodeChar ( final byte b ) {
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; MST[rv.UOI1Mutator]MSP[N] } private boolean isAsciiChar ( final byte c ) {
return c >= 0 ; } @Override public byte [] decode ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { return null ; MST[ReturnValsMutator]MSP[N] } final ByteBuffer buffer = ByteBuffer . allocate ( expectedDecodingBytes ( bytes ) ) ;
for ( int i = 0 ; i < bytes . length ; i ++ ) { MST[rv.ROR2Mutator]MSP[N] final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
buffer . put ( ( byte ) hex2 ) ; } else { if ( plusForSpace && b == ' ' ) { MST[rv.ROR5Mutator]MSP[N] buffer . put ( ( byte ) '+' ) ; } else { buffer . put ( b ) ; } } }
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { if ( b == ' ' ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return true ; } } return false ; } private boolean canEncode ( final byte c ) {
return doEncode ( bytes , expectedEncodingBytes , willEncode ) ; MST[rv.UOI4Mutator]MSP[N] } return bytes ; } private byte [] doEncode ( final byte [] bytes , final int expectedLength , final boolean willEncode ) { final ByteBuffer buffer = ByteBuffer . allocate ( expectedLength ) ;
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { MST[rv.UOI3Mutator]MSP[N] insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
return doEncode ( bytes , expectedEncodingBytes , willEncode ) ; MST[rv.UOI1Mutator]MSP[N] } return bytes ; } private byte [] doEncode ( final byte [] bytes , final int expectedLength , final boolean willEncode ) { final ByteBuffer buffer = ByteBuffer . allocate ( expectedLength ) ;
return doEncode ( bytes , expectedEncodingBytes , willEncode ) ; MST[ReturnValsMutator]MSP[N] } return bytes ; } private byte [] doEncode ( final byte [] bytes , final int expectedLength , final boolean willEncode ) { final ByteBuffer buffer = ByteBuffer . allocate ( expectedLength ) ;
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; MST[rv.UOI3Mutator]MSP[N] } return byteCount ; }
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; MST[rv.AOD1Mutator]MSP[N] }
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { MST[rv.ROR5Mutator]MSP[N] bb = (byte) ( 256 + bb ) ; }
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[NegateConditionalsMutator]MSP[N] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
final char hex1 = Utils . hexDigit ( bb >> 4 ) ; MST[InlineConstantMutator]MSP[N] final char hex2 = Utils . hexDigit ( bb ) ; buffer . put ( ESCAPE_CHAR ) ; buffer . put ( ( byte ) hex1 ) ;
final int l = Utils . digit16 ( bytes [ ++ i ] ) ; buffer . put ( (byte) ( ( u << 4 ) + l ) ) ; MST[rv.CRCR6Mutator]MSP[N] } catch ( final ArrayIndexOutOfBoundsException e ) { throw new DecoderException ( lr_1 , e ) ; }
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; MST[BooleanTrueReturnValsMutator]MSP[N] } private boolean isAsciiChar ( final byte c ) {
} else { if ( plusForSpace && b == '+' ) { buffer . put ( ( byte ) ' ' ) ; MST[experimental.NakedReceiverMutator]MSP[N] } else { buffer . put ( b ) ; } } } return buffer . array () ; }
final char hex1 = Utils . hexDigit ( bb >> 4 ) ; MST[MathMutator]MSP[N] final char hex2 = Utils . hexDigit ( bb ) ; buffer . put ( ESCAPE_CHAR ) ; buffer . put ( ( byte ) hex1 ) ;
final char hex1 = Utils . hexDigit ( bb >> 4 ) ; final char hex2 = Utils . hexDigit ( bb ) ; MST[rv.UOI1Mutator]MSP[N] buffer . put ( ESCAPE_CHAR ) ; buffer . put ( ( byte ) hex1 ) ;
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; MST[rv.CRCR2Mutator]MSP[N] } return byteCount ; }
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[rv.UOI1Mutator]MSP[N] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ; MST[rv.CRCR1Mutator]MSP[N]
this . alwaysEncodeChars . set ( b ) ; if ( b < alwaysEncodeCharsMin ) { alwaysEncodeCharsMin = b ; } if ( b > alwaysEncodeCharsMax ) { MST[rv.UOI2Mutator]MSP[N] alwaysEncodeCharsMax = b ; } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { if ( b == ' ' ) { return true ; } } return false ; MST[rv.CRCR1Mutator]MSP[S] } private boolean canEncode ( final byte c ) {
final int l = Utils . digit16 ( bytes [ ++ i ] ) ; buffer . put ( (byte) ( ( u << 4 ) + l ) ) ; MST[rv.AOR2Mutator]MSP[N] } catch ( final ArrayIndexOutOfBoundsException e ) { throw new DecoderException ( lr_1 , e ) ; }
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { if ( b == ' ' ) { return true ; } } return false ; MST[ReturnValsMutator]MSP[S] } private boolean canEncode ( final byte c ) {
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { MST[rv.CRCR1Mutator]MSP[N] if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { if ( b == ' ' ) { return true ; } } return false ; MST[BooleanTrueReturnValsMutator]MSP[S] } private boolean canEncode ( final byte c ) {
final int l = Utils . digit16 ( bytes [ ++ i ] ) ; buffer . put ( (byte) ( ( u << 4 ) + l ) ) ; MST[MathMutator]MSP[N] } catch ( final ArrayIndexOutOfBoundsException e ) { throw new DecoderException ( lr_1 , e ) ; }
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[rv.CRCR3Mutator]MSP[N] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
} else if ( obj instanceof byte [] ) { return decode ( ( byte [] ) obj ) ; } else { throw new DecoderException ( lr_2 + obj . getClass () . getName () + lr_4 ) ; MST[NonVoidMethodCallMutator]MSP[N] } }
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { MST[rv.UOI4Mutator]MSP[N] if ( b == ' ' ) { return true ; } } return false ; } private boolean canEncode ( final byte c ) {
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; MST[rv.CRCR2Mutator]MSP[N] }
} else { if ( plusForSpace && b == '+' ) { MST[rv.CRCR2Mutator]MSP[N] buffer . put ( ( byte ) ' ' ) ; } else { buffer . put ( b ) ; } } } return buffer . array () ; }
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { MST[rv.UOI3Mutator]MSP[N] final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ;
this . alwaysEncodeChars . set ( b ) ; if ( b < alwaysEncodeCharsMin ) { MST[rv.UOI3Mutator]MSP[N] alwaysEncodeCharsMin = b ; } if ( b > alwaysEncodeCharsMax ) { alwaysEncodeCharsMax = b ; } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { byte bb = b ; MST[rv.UOI4Mutator]MSP[N] if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; MST[rv.AOD2Mutator]MSP[N] } return byteCount ; }
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { byte bb = b ; MST[rv.UOI2Mutator]MSP[N] if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
for ( final byte b : bytes ) { MST[rv.UOI3Mutator]MSP[N] if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
buffer . put ( ( byte ) hex2 ) ; } else { if ( plusForSpace && b == ' ' ) { MST[rv.ROR1Mutator]MSP[N] buffer . put ( ( byte ) '+' ) ; } else { buffer . put ( b ) ; } } }
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; MST[rv.CRCR6Mutator]MSP[N] } private boolean isAsciiChar ( final byte c ) {
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) { MST[rv.ROR5Mutator]MSP[N]
buffer . put ( ( byte ) hex2 ) ; } else { if ( plusForSpace && b == ' ' ) { MST[rv.ROR3Mutator]MSP[N] buffer . put ( ( byte ) '+' ) ; } else { buffer . put ( b ) ; } } }
buffer . put ( ( byte ) hex2 ) ; } else { if ( plusForSpace && b == ' ' ) { MST[rv.CRCR6Mutator]MSP[N] buffer . put ( ( byte ) '+' ) ; } else { buffer . put ( b ) ; } } }
for ( int i = 0 ; i < bytes . length ; i ++ ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[rv.ROR2Mutator]MSP[N] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
} else { if ( plusForSpace && b == '+' ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] buffer . put ( ( byte ) ' ' ) ; } else { buffer . put ( b ) ; } } } return buffer . array () ; }
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { MST[InlineConstantMutator]MSP[N] if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { MST[rv.ROR2Mutator]MSP[N] bb = (byte) ( 256 + bb ) ; }
buffer . put ( ( byte ) hex2 ) ; } else { if ( plusForSpace && b == ' ' ) { buffer . put ( ( byte ) '+' ) ; } else { buffer . put ( b ) ; MST[rv.UOI3Mutator]MSP[N] } } }
return c >= 0 ; MST[rv.CRCR2Mutator]MSP[N] } @Override public byte [] decode ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { return null ; } final ByteBuffer buffer = ByteBuffer . allocate ( expectedDecodingBytes ( bytes ) ) ;
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[rv.ROR3Mutator]MSP[N] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
final int l = Utils . digit16 ( bytes [ ++ i ] ) ; buffer . put ( (byte) ( ( u << 4 ) + l ) ) ; MST[rv.CRCR1Mutator]MSP[N] } catch ( final ArrayIndexOutOfBoundsException e ) { throw new DecoderException ( lr_1 , e ) ; }
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { MST[rv.UOI1Mutator]MSP[N] final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ;
final char hex1 = Utils . hexDigit ( bb >> 4 ) ; MST[rv.ABSMutator]MSP[N] final char hex2 = Utils . hexDigit ( bb ) ; buffer . put ( ESCAPE_CHAR ) ; buffer . put ( ( byte ) hex1 ) ;
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[NegateConditionalsMutator]MSP[N] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
final int l = Utils . digit16 ( bytes [ ++ i ] ) ; buffer . put ( (byte) ( ( u << 4 ) + l ) ) ; MST[rv.CRCR3Mutator]MSP[N] } catch ( final ArrayIndexOutOfBoundsException e ) { throw new DecoderException ( lr_1 , e ) ; }
byteCount ++ ; } return byteCount ; } @Override public Object encode ( final Object obj ) throws EncoderException { if ( obj == null ) { return null ; } else if ( obj instanceof byte [] ) { MST[NegateConditionalsMutator]MSP[N] return encode ( ( byte [] ) obj ) ;
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; MST[rv.CRCR5Mutator]MSP[N] if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) {
for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { MST[rv.UOI3Mutator]MSP[N] try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ; MST[rv.ABSMutator]MSP[N] if ( b == ESCAPE_CHAR ) { try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { MST[rv.UOI4Mutator]MSP[N] byteCount += canEncode ( b ) ? 3 : 1 ; } return byteCount ; }
for ( final byte b : bytes ) { MST[rv.UOI2Mutator]MSP[N] if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
return c >= 0 ; MST[rv.UOI1Mutator]MSP[N] } @Override public byte [] decode ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { return null ; } final ByteBuffer buffer = ByteBuffer . allocate ( expectedDecodingBytes ( bytes ) ) ;
final int l = Utils . digit16 ( bytes [ ++ i ] ) ; MST[rv.UOI3Mutator]MSP[N] buffer . put ( (byte) ( ( u << 4 ) + l ) ) ; } catch ( final ArrayIndexOutOfBoundsException e ) { throw new DecoderException ( lr_1 , e ) ; }
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { MST[rv.UOI3Mutator]MSP[N] if ( b == ' ' ) { return true ; } } return false ; } private boolean canEncode ( final byte c ) {
for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ; MST[rv.UOI2Mutator]MSP[N] if ( b == ESCAPE_CHAR ) { try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
this . alwaysEncodeChars . set ( b ) ; if ( b < alwaysEncodeCharsMin ) { MST[rv.ROR4Mutator]MSP[N] alwaysEncodeCharsMin = b ; } if ( b > alwaysEncodeCharsMax ) { alwaysEncodeCharsMax = b ; } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { MST[rv.ABSMutator]MSP[N] byteCount += canEncode ( b ) ? 3 : 1 ; } return byteCount ; }
for ( int i = 0 ; i < bytes . length ; i ++ ) { MST[rv.ROR4Mutator]MSP[N] final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; MST[rv.UOI1Mutator]MSP[N] } private boolean isAsciiChar ( final byte c ) {
for ( final byte b : bytes ) { MST[rv.ABSMutator]MSP[N] if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
} else { if ( plusForSpace && b == '+' ) { buffer . put ( ( byte ) ' ' ) ; MST[rv.CRCR3Mutator]MSP[N] } else { buffer . put ( b ) ; } } } return buffer . array () ; }
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) { MST[NegateConditionalsMutator]MSP[N]
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { MST[rv.UOI1Mutator]MSP[N] byteCount += canEncode ( b ) ? 3 : 1 ; } return byteCount ; }
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { MST[rv.ROR3Mutator]MSP[N] byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ; MST[experimental.RemoveIncrementsMutator]MSP[N]
buffer . put ( ( byte ) hex2 ) ; } else { if ( plusForSpace && b == ' ' ) { MST[rv.ROR2Mutator]MSP[N] buffer . put ( ( byte ) '+' ) ; } else { buffer . put ( b ) ; } } }
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { MST[rv.ABSMutator]MSP[S] insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
this . alwaysEncodeChars . set ( b ) ; if ( b < alwaysEncodeCharsMin ) { alwaysEncodeCharsMin = b ; } if ( b > alwaysEncodeCharsMax ) { MST[rv.ROR3Mutator]MSP[N] alwaysEncodeCharsMax = b ; } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; MST[rv.UOI3Mutator]MSP[N] } return byteCount ; }
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { MST[rv.UOI1Mutator]MSP[N] insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
byteCount ++ ; } return byteCount ; } @Override public Object encode ( final Object obj ) throws EncoderException { if ( obj == null ) { return null ; } else if ( obj instanceof byte [] ) { MST[rv.ROR3Mutator]MSP[N] return encode ( ( byte [] ) obj ) ;
this . alwaysEncodeChars . set ( b ) ; if ( b < alwaysEncodeCharsMin ) { alwaysEncodeCharsMin = b ; } if ( b > alwaysEncodeCharsMax ) { alwaysEncodeCharsMax = b ; MST[experimental.MemberVariableMutator]MSP[N] } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; MST[RemoveConditionalMutator_ORDER_IF]MSP[N] } private boolean isAsciiChar ( final byte c ) {
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; MST[rv.CRCR5Mutator]MSP[N] for ( int i = 0 ; i < bytes . length ; ) { final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ;
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
byteCount ++ ; } return byteCount ; MST[rv.UOI3Mutator]MSP[N] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( obj == null ) { return null ; } else if ( obj instanceof byte [] ) { return encode ( ( byte [] ) obj ) ;
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[rv.UOI3Mutator]MSP[N] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
final char hex1 = Utils . hexDigit ( bb >> 4 ) ; final char hex2 = Utils . hexDigit ( bb ) ; buffer . put ( ESCAPE_CHAR ) ; buffer . put ( ( byte ) hex1 ) ; MST[rv.UOI3Mutator]MSP[N]
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ; MST[InlineConstantMutator]MSP[N]
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ; MST[rv.CRCR3Mutator]MSP[N]
for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { MST[rv.ROR2Mutator]MSP[N] try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
byteCount ++ ; } return byteCount ; } @Override public Object encode ( final Object obj ) throws EncoderException { if ( obj == null ) { return null ; } else if ( obj instanceof byte [] ) { return encode ( ( byte [] ) obj ) ; MST[NullReturnValsMutator]MSP[S]
return doEncode ( bytes , expectedEncodingBytes , willEncode ) ; } return bytes ; } private byte [] doEncode ( final byte [] bytes , final int expectedLength , final boolean willEncode ) { final ByteBuffer buffer = ByteBuffer . allocate ( expectedLength ) ; MST[rv.ABSMutator]MSP[N]
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { MST[rv.CRCR1Mutator]MSP[N] if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
this . alwaysEncodeChars . set ( b ) ; if ( b < alwaysEncodeCharsMin ) { alwaysEncodeCharsMin = b ; } if ( b > alwaysEncodeCharsMax ) { MST[NegateConditionalsMutator]MSP[N] alwaysEncodeCharsMax = b ; } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; MST[rv.ROR4Mutator]MSP[N] } private boolean isAsciiChar ( final byte c ) {
return c >= 0 ; } @Override public byte [] decode ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { return null ; } final ByteBuffer buffer = ByteBuffer . allocate ( expectedDecodingBytes ( bytes ) ) ; MST[NonVoidMethodCallMutator]MSP[N]
if ( bytes == null ) { MST[NegateConditionalsMutator]MSP[N] return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) {
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { MST[rv.CRCR6Mutator]MSP[N] if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { MST[NegateConditionalsMutator]MSP[N] byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { if ( b == ' ' ) { return true ; MST[rv.CRCR2Mutator]MSP[N] } } return false ; } private boolean canEncode ( final byte c ) {
return c >= 0 ; MST[BooleanTrueReturnValsMutator]MSP[N] } @Override public byte [] decode ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { return null ; } final ByteBuffer buffer = ByteBuffer . allocate ( expectedDecodingBytes ( bytes ) ) ;
final int l = Utils . digit16 ( bytes [ ++ i ] ) ; buffer . put ( (byte) ( ( u << 4 ) + l ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } catch ( final ArrayIndexOutOfBoundsException e ) { throw new DecoderException ( lr_1 , e ) ; }
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { MST[rv.UOI4Mutator]MSP[N] insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ; MST[rv.ROR3Mutator]MSP[S]
for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { MST[rv.CRCR5Mutator]MSP[N] try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; } return byteCount ; MST[rv.UOI3Mutator]MSP[N] }
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; MST[rv.CRCR5Mutator]MSP[N] } return byteCount ; }
} else { if ( plusForSpace && b == '+' ) { buffer . put ( ( byte ) ' ' ) ; } else { buffer . put ( b ) ; } } } return buffer . array () ; MST[NonVoidMethodCallMutator]MSP[N] }
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; MST[InlineConstantMutator]MSP[N] if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) {
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { MST[rv.ABSMutator]MSP[N] if ( b == ' ' ) { return true ; } } return false ; } private boolean canEncode ( final byte c ) {
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) { MST[NegateConditionalsMutator]MSP[N]
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; } return byteCount ; MST[rv.ABSMutator]MSP[N] }
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[InlineConstantMutator]MSP[N] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
final int l = Utils . digit16 ( bytes [ ++ i ] ) ; buffer . put ( (byte) ( ( u << 4 ) + l ) ) ; MST[rv.UOI1Mutator]MSP[N] } catch ( final ArrayIndexOutOfBoundsException e ) { throw new DecoderException ( lr_1 , e ) ; }
this . alwaysEncodeChars . set ( b ) ; MST[rv.UOI1Mutator]MSP[N] if ( b < alwaysEncodeCharsMin ) { alwaysEncodeCharsMin = b ; } if ( b > alwaysEncodeCharsMax ) { alwaysEncodeCharsMax = b ; } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
return doEncode ( bytes , expectedEncodingBytes , willEncode ) ; } return bytes ; } private byte [] doEncode ( final byte [] bytes , final int expectedLength , final boolean willEncode ) { final ByteBuffer buffer = ByteBuffer . allocate ( expectedLength ) ; MST[rv.UOI3Mutator]MSP[N]
byteCount ++ ; } return byteCount ; } @Override public Object encode ( final Object obj ) throws EncoderException { if ( obj == null ) { return null ; MST[ReturnValsMutator]MSP[S] } else if ( obj instanceof byte [] ) { return encode ( ( byte [] ) obj ) ;
final char hex1 = Utils . hexDigit ( bb >> 4 ) ; final char hex2 = Utils . hexDigit ( bb ) ; buffer . put ( ESCAPE_CHAR ) ; buffer . put ( ( byte ) hex1 ) ; MST[rv.ABSMutator]MSP[N]
for ( final byte b : bytes ) { MST[rv.UOI4Mutator]MSP[N] if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
} else { if ( plusForSpace && b == '+' ) { MST[rv.ROR1Mutator]MSP[N] buffer . put ( ( byte ) ' ' ) ; } else { buffer . put ( b ) ; } } } return buffer . array () ; }
} else { throw new EncoderException ( lr_2 + obj . getClass () . getName () + lr_3 ) ; } } @Override public Object decode ( final Object obj ) throws DecoderException { if ( obj == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return null ;
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { MST[rv.CRCR5Mutator]MSP[N] if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
for ( int i = 0 ; i < bytes . length ; i ++ ) { MST[rv.CRCR5Mutator]MSP[N] final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
byteCount ++ ; MST[experimental.RemoveIncrementsMutator]MSP[N] } return byteCount ; } @Override public Object encode ( final Object obj ) throws EncoderException { if ( obj == null ) { return null ; } else if ( obj instanceof byte [] ) { return encode ( ( byte [] ) obj ) ;
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { final byte b = bytes [ i ] ; MST[rv.UOI4Mutator]MSP[N] i += b == ESCAPE_CHAR ? 3 : 1 ;
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; MST[rv.UOI1Mutator]MSP[N] } private boolean isAsciiChar ( final byte c ) {
this . alwaysEncodeChars . set ( b ) ; if ( b < alwaysEncodeCharsMin ) { alwaysEncodeCharsMin = b ; MST[rv.UOI4Mutator]MSP[N] } if ( b > alwaysEncodeCharsMax ) { alwaysEncodeCharsMax = b ; } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
this . alwaysEncodeChars . set ( b ) ; if ( b < alwaysEncodeCharsMin ) { alwaysEncodeCharsMin = b ; } if ( b > alwaysEncodeCharsMax ) { alwaysEncodeCharsMax = b ; MST[rv.UOI3Mutator]MSP[N] } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
byteCount ++ ; } return byteCount ; } @Override public Object encode ( final Object obj ) throws EncoderException { if ( obj == null ) { return null ; } else if ( obj instanceof byte [] ) { return encode ( ( byte [] ) obj ) ; MST[ArgumentPropagationMutator]MSP[N]
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { MST[rv.UOI1Mutator]MSP[N] byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; MST[rv.ROR5Mutator]MSP[N] } return byteCount ; }
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[rv.ABSMutator]MSP[N] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ; MST[rv.UOI1Mutator]MSP[N]
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { if ( b == ' ' ) { MST[rv.ROR2Mutator]MSP[S] return true ; } } return false ; } private boolean canEncode ( final byte c ) {
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { insertAlwaysEncodeChar ( b ) ; MST[rv.UOI2Mutator]MSP[N] } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; MST[NegateConditionalsMutator]MSP[N] if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) {
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; MST[rv.CRCR1Mutator]MSP[N] for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; } return byteCount ; }
} else if ( obj instanceof byte [] ) { MST[rv.ROR1Mutator]MSP[S] return decode ( ( byte [] ) obj ) ; } else { throw new DecoderException ( lr_2 + obj . getClass () . getName () + lr_4 ) ; } }
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { insertAlwaysEncodeChar ( b ) ; MST[VoidMethodCallMutator]MSP[N] } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
final int l = Utils . digit16 ( bytes [ ++ i ] ) ; MST[rv.ABSMutator]MSP[N] buffer . put ( (byte) ( ( u << 4 ) + l ) ) ; } catch ( final ArrayIndexOutOfBoundsException e ) { throw new DecoderException ( lr_1 , e ) ; }
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[rv.ROR5Mutator]MSP[N] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
buffer . put ( ( byte ) hex2 ) ; } else { if ( plusForSpace && b == ' ' ) { MST[rv.CRCR1Mutator]MSP[N] buffer . put ( ( byte ) '+' ) ; } else { buffer . put ( b ) ; } } }
} else { if ( plusForSpace && b == '+' ) { buffer . put ( ( byte ) ' ' ) ; } else { buffer . put ( b ) ; MST[rv.UOI4Mutator]MSP[N] } } } return buffer . array () ; }
for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ; MST[rv.UOI1Mutator]MSP[N]
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ; MST[InlineConstantMutator]MSP[N]
