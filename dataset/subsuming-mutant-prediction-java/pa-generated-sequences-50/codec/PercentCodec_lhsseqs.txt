for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ; MST[rv.UOI4Mutator]MSP[]
this . alwaysEncodeChars . set ( b ) ; if ( b < alwaysEncodeCharsMin ) { alwaysEncodeCharsMin = b ; } if ( b > alwaysEncodeCharsMax ) { MST[rv.UOI3Mutator]MSP[] alwaysEncodeCharsMax = b ; } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { MST[rv.UOI3Mutator]MSP[] byteCount += canEncode ( b ) ? 3 : 1 ; } return byteCount ; }
final int l = Utils . digit16 ( bytes [ ++ i ] ) ; buffer . put ( (byte) ( ( u << 4 ) + l ) ) ; MST[rv.AOR1Mutator]MSP[] } catch ( final ArrayIndexOutOfBoundsException e ) { throw new DecoderException ( lr_1 , e ) ; }
for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { MST[rv.UOI2Mutator]MSP[] try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[rv.CRCR2Mutator]MSP[] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ; MST[rv.CRCR5Mutator]MSP[]
return buffer . array () ; MST[ReturnValsMutator]MSP[] } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; } return byteCount ; }
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; MST[rv.AOR4Mutator]MSP[] }
buffer . put ( ( byte ) hex2 ) ; } else { if ( plusForSpace && b == ' ' ) { buffer . put ( ( byte ) '+' ) ; } else { buffer . put ( b ) ; MST[experimental.NakedReceiverMutator]MSP[] } } }
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { MST[rv.UOI4Mutator]MSP[] if ( b == ' ' ) { return true ; } } return false ; } private boolean canEncode ( final byte c ) {
if ( bytes == null ) { return null ; MST[ReturnValsMutator]MSP[] } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) {
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { if ( b == ' ' ) { return true ; } } return false ; MST[rv.CRCR6Mutator]MSP[] } private boolean canEncode ( final byte c ) {
} else { if ( plusForSpace && b == '+' ) { MST[rv.ROR4Mutator]MSP[] buffer . put ( ( byte ) ' ' ) ; } else { buffer . put ( b ) ; } } } return buffer . array () ; }
this . alwaysEncodeChars . set ( b ) ; if ( b < alwaysEncodeCharsMin ) { MST[rv.UOI4Mutator]MSP[] alwaysEncodeCharsMin = b ; } if ( b > alwaysEncodeCharsMax ) { alwaysEncodeCharsMax = b ; } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
} else if ( obj instanceof byte [] ) { return decode ( ( byte [] ) obj ) ; } else { throw new DecoderException ( lr_2 + obj . getClass () . getName () + lr_4 ) ; MST[ConstructorCallMutator]MSP[] } }
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) { MST[rv.ROR5Mutator]MSP[]
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; MST[rv.CRCR4Mutator]MSP[] } private boolean isAsciiChar ( final byte c ) {
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { final byte b = bytes [ i ] ; MST[rv.UOI2Mutator]MSP[] i += b == ESCAPE_CHAR ? 3 : 1 ;
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; MST[rv.CRCR1Mutator]MSP[] } private boolean isAsciiChar ( final byte c ) {
for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { MST[InlineConstantMutator]MSP[] try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
for ( final byte b : bytes ) { MST[rv.UOI2Mutator]MSP[] if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { byte bb = b ; MST[rv.UOI1Mutator]MSP[] if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
} else if ( obj instanceof byte [] ) { return decode ( ( byte [] ) obj ) ; MST[ReturnValsMutator]MSP[] } else { throw new DecoderException ( lr_2 + obj . getClass () . getName () + lr_4 ) ; } }
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) { MST[rv.ROR2Mutator]MSP[]
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { final byte b = bytes [ i ] ; MST[rv.ABSMutator]MSP[] i += b == ESCAPE_CHAR ? 3 : 1 ;
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ; MST[NegateConditionalsMutator]MSP[]
buffer . put ( ( byte ) hex2 ) ; } else { if ( plusForSpace && b == ' ' ) { buffer . put ( ( byte ) '+' ) ; } else { buffer . put ( b ) ; MST[rv.ABSMutator]MSP[] } } }
for ( int i = 0 ; i < bytes . length ; i ++ ) { MST[InlineConstantMutator]MSP[] final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
byteCount ++ ; } return byteCount ; } @Override public Object encode ( final Object obj ) throws EncoderException { if ( obj == null ) { return null ; } else if ( obj instanceof byte [] ) { MST[rv.ROR2Mutator]MSP[] return encode ( ( byte [] ) obj ) ;
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; MST[InlineConstantMutator]MSP[] } private void insertAlwaysEncodeChar ( final byte b ) {
for ( int i = 0 ; i < bytes . length ; i ++ ) { MST[rv.UOI3Mutator]MSP[] final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { MST[rv.CRCR6Mutator]MSP[] if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; MST[rv.CRCR5Mutator]MSP[] if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) {
} else { throw new EncoderException ( lr_2 + obj . getClass () . getName () + lr_3 ) ; MST[experimental.NakedReceiverMutator]MSP[] } } @Override public Object decode ( final Object obj ) throws DecoderException { if ( obj == null ) { return null ;
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[rv.ROR4Mutator]MSP[] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
if ( bytes == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) {
for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { MST[rv.ABSMutator]MSP[] try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { MST[rv.UOI4Mutator]MSP[] byteCount += canEncode ( b ) ? 3 : 1 ; } return byteCount ; }
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] } return byteCount ; }
final char hex1 = Utils . hexDigit ( bb >> 4 ) ; final char hex2 = Utils . hexDigit ( bb ) ; buffer . put ( ESCAPE_CHAR ) ; buffer . put ( ( byte ) hex1 ) ; MST[NonVoidMethodCallMutator]MSP[]
} else { if ( plusForSpace && b == '+' ) { MST[rv.ROR3Mutator]MSP[] buffer . put ( ( byte ) ' ' ) ; } else { buffer . put ( b ) ; } } } return buffer . array () ; }
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; MST[rv.UOI3Mutator]MSP[] } private boolean isAsciiChar ( final byte c ) {
for ( int i = 0 ; i < bytes . length ; i ++ ) { MST[rv.ROR1Mutator]MSP[] final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { if ( b == ' ' ) { MST[InlineConstantMutator]MSP[] return true ; } } return false ; } private boolean canEncode ( final byte c ) {
} else { throw new EncoderException ( lr_2 + obj . getClass () . getName () + lr_3 ) ; MST[NonVoidMethodCallMutator]MSP[] } } @Override public Object decode ( final Object obj ) throws DecoderException { if ( obj == null ) { return null ;
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; MST[rv.UOI1Mutator]MSP[] } return byteCount ; }
return doEncode ( bytes , expectedEncodingBytes , willEncode ) ; MST[rv.UOI3Mutator]MSP[] } return bytes ; } private byte [] doEncode ( final byte [] bytes , final int expectedLength , final boolean willEncode ) { final ByteBuffer buffer = ByteBuffer . allocate ( expectedLength ) ;
for ( final byte b : bytes ) { MST[rv.ABSMutator]MSP[] if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { MST[rv.ABSMutator]MSP[] insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
this . alwaysEncodeChars . set ( b ) ; if ( b < alwaysEncodeCharsMin ) { alwaysEncodeCharsMin = b ; } if ( b > alwaysEncodeCharsMax ) { MST[rv.ROR4Mutator]MSP[] alwaysEncodeCharsMax = b ; } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; MST[rv.CRCR2Mutator]MSP[] } private void insertAlwaysEncodeChar ( final byte b ) {
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; MST[rv.AOD2Mutator]MSP[] }
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ; MST[rv.UOI3Mutator]MSP[]
final char hex1 = Utils . hexDigit ( bb >> 4 ) ; MST[rv.CRCR5Mutator]MSP[] final char hex2 = Utils . hexDigit ( bb ) ; buffer . put ( ESCAPE_CHAR ) ; buffer . put ( ( byte ) hex1 ) ;
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; MST[rv.ROR3Mutator]MSP[] } return byteCount ; }
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { insertAlwaysEncodeChar ( b ) ; MST[rv.UOI4Mutator]MSP[] } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { if ( b == ' ' ) { MST[rv.ROR4Mutator]MSP[] return true ; } } return false ; } private boolean canEncode ( final byte c ) {
final int l = Utils . digit16 ( bytes [ ++ i ] ) ; MST[NonVoidMethodCallMutator]MSP[] buffer . put ( (byte) ( ( u << 4 ) + l ) ) ; } catch ( final ArrayIndexOutOfBoundsException e ) { throw new DecoderException ( lr_1 , e ) ; }
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; MST[RemoveConditionalMutator_ORDER_IF]MSP[] } private boolean isAsciiChar ( final byte c ) {
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[rv.ROR2Mutator]MSP[] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
buffer . put ( ( byte ) hex2 ) ; } else { if ( plusForSpace && b == ' ' ) { buffer . put ( ( byte ) '+' ) ; } else { buffer . put ( b ) ; MST[rv.UOI2Mutator]MSP[] } } }
this . alwaysEncodeChars . set ( b ) ; if ( b < alwaysEncodeCharsMin ) { MST[rv.UOI4Mutator]MSP[] alwaysEncodeCharsMin = b ; } if ( b > alwaysEncodeCharsMax ) { alwaysEncodeCharsMax = b ; } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
return c >= 0 ; MST[rv.CRCR3Mutator]MSP[] } @Override public byte [] decode ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { return null ; } final ByteBuffer buffer = ByteBuffer . allocate ( expectedDecodingBytes ( bytes ) ) ;
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { MST[rv.UOI1Mutator]MSP[] if ( b == ' ' ) { return true ; } } return false ; } private boolean canEncode ( final byte c ) {
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) {
} else { if ( plusForSpace && b == '+' ) { buffer . put ( ( byte ) ' ' ) ; } else { buffer . put ( b ) ; MST[NonVoidMethodCallMutator]MSP[] } } } return buffer . array () ; }
final char hex1 = Utils . hexDigit ( bb >> 4 ) ; final char hex2 = Utils . hexDigit ( bb ) ; MST[rv.UOI3Mutator]MSP[] buffer . put ( ESCAPE_CHAR ) ; buffer . put ( ( byte ) hex1 ) ;
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { if ( alwaysEncodeCharsArray != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] for ( final byte b : alwaysEncodeCharsArray ) { insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
buffer . put ( ( byte ) hex2 ) ; } else { if ( plusForSpace && b == ' ' ) { MST[rv.CRCR3Mutator]MSP[] buffer . put ( ( byte ) '+' ) ; } else { buffer . put ( b ) ; } } }
return c >= 0 ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] } @Override public byte [] decode ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { return null ; } final ByteBuffer buffer = ByteBuffer . allocate ( expectedDecodingBytes ( bytes ) ) ;
return c >= 0 ; } @Override public byte [] decode ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return null ; } final ByteBuffer buffer = ByteBuffer . allocate ( expectedDecodingBytes ( bytes ) ) ;
final int l = Utils . digit16 ( bytes [ ++ i ] ) ; buffer . put ( (byte) ( ( u << 4 ) + l ) ) ; MST[MathMutator]MSP[] } catch ( final ArrayIndexOutOfBoundsException e ) { throw new DecoderException ( lr_1 , e ) ; }
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { MST[rv.CRCR4Mutator]MSP[] if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
final char hex1 = Utils . hexDigit ( bb >> 4 ) ; final char hex2 = Utils . hexDigit ( bb ) ; buffer . put ( ESCAPE_CHAR ) ; buffer . put ( ( byte ) hex1 ) ; MST[rv.UOI2Mutator]MSP[]
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; MST[rv.ROR4Mutator]MSP[] } private boolean isAsciiChar ( final byte c ) {
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; MST[rv.ROR1Mutator]MSP[] } private boolean isAsciiChar ( final byte c ) {
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { if ( b == ' ' ) { MST[rv.CRCR2Mutator]MSP[] return true ; } } return false ; } private boolean canEncode ( final byte c ) {
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { if ( b == ' ' ) { return true ; MST[rv.CRCR4Mutator]MSP[] } } return false ; } private boolean canEncode ( final byte c ) {
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { MST[experimental.MemberVariableMutator]MSP[] if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { MST[NegateConditionalsMutator]MSP[] byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { MST[rv.CRCR2Mutator]MSP[] try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
buffer . put ( ( byte ) hex2 ) ; } else { if ( plusForSpace && b == ' ' ) { MST[rv.UOI3Mutator]MSP[] buffer . put ( ( byte ) '+' ) ; } else { buffer . put ( b ) ; } } }
} else { if ( plusForSpace && b == '+' ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] buffer . put ( ( byte ) ' ' ) ; } else { buffer . put ( b ) ; } } } return buffer . array () ; }
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ; MST[rv.ROR5Mutator]MSP[]
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { MST[rv.UOI1Mutator]MSP[] insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
return c >= 0 ; MST[ReturnValsMutator]MSP[] } @Override public byte [] decode ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { return null ; } final ByteBuffer buffer = ByteBuffer . allocate ( expectedDecodingBytes ( bytes ) ) ;
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; MST[rv.ROR5Mutator]MSP[] if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) {
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[InlineConstantMutator]MSP[] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { if ( b == ' ' ) { MST[rv.ABSMutator]MSP[] return true ; } } return false ; } private boolean canEncode ( final byte c ) {
} else { throw new EncoderException ( lr_2 + obj . getClass () . getName () + lr_3 ) ; MST[experimental.NakedReceiverMutator]MSP[] } } @Override public Object decode ( final Object obj ) throws DecoderException { if ( obj == null ) { return null ;
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; MST[InlineConstantMutator]MSP[] }
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { if ( b == ' ' ) { return true ; MST[BooleanFalseReturnValsMutator]MSP[] } } return false ; } private boolean canEncode ( final byte c ) {
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; MST[InlineConstantMutator]MSP[] if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) {
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; MST[rv.CRCR3Mutator]MSP[] } return byteCount ; }
this . alwaysEncodeChars . set ( b ) ; if ( b < alwaysEncodeCharsMin ) { MST[NegateConditionalsMutator]MSP[] alwaysEncodeCharsMin = b ; } if ( b > alwaysEncodeCharsMax ) { alwaysEncodeCharsMax = b ; } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
final int l = Utils . digit16 ( bytes [ ++ i ] ) ; MST[rv.UOI2Mutator]MSP[] buffer . put ( (byte) ( ( u << 4 ) + l ) ) ; } catch ( final ArrayIndexOutOfBoundsException e ) { throw new DecoderException ( lr_1 , e ) ; }
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { MST[rv.CRCR5Mutator]MSP[] if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; MST[MathMutator]MSP[] } return byteCount ; }
for ( final byte b : bytes ) { MST[rv.UOI4Mutator]MSP[] if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
this . alwaysEncodeChars . set ( b ) ; if ( b < alwaysEncodeCharsMin ) { alwaysEncodeCharsMin = b ; } if ( b > alwaysEncodeCharsMax ) { alwaysEncodeCharsMax = b ; MST[rv.UOI4Mutator]MSP[] } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
return doEncode ( bytes , expectedEncodingBytes , willEncode ) ; MST[rv.ABSMutator]MSP[] } return bytes ; } private byte [] doEncode ( final byte [] bytes , final int expectedLength , final boolean willEncode ) { final ByteBuffer buffer = ByteBuffer . allocate ( expectedLength ) ;
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; MST[rv.AOR1Mutator]MSP[] } return byteCount ; }
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; MST[rv.AOR4Mutator]MSP[] } return byteCount ; }
for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ; MST[rv.UOI1Mutator]MSP[] if ( b == ESCAPE_CHAR ) { try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
final char hex1 = Utils . hexDigit ( bb >> 4 ) ; final char hex2 = Utils . hexDigit ( bb ) ; buffer . put ( ESCAPE_CHAR ) ; MST[rv.CRCR4Mutator]MSP[] buffer . put ( ( byte ) hex1 ) ;
} else { if ( plusForSpace && b == '+' ) { MST[rv.ABSMutator]MSP[] buffer . put ( ( byte ) ' ' ) ; } else { buffer . put ( b ) ; } } } return buffer . array () ; }
for ( final byte b : bytes ) { MST[rv.UOI1Mutator]MSP[] if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { MST[InlineConstantMutator]MSP[] final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ;
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) { MST[rv.ROR4Mutator]MSP[]
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; MST[rv.UOI3Mutator]MSP[] } private boolean isAsciiChar ( final byte c ) {
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; MST[rv.UOI1Mutator]MSP[] } return byteCount ; }
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) { MST[rv.ROR1Mutator]MSP[]
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { MST[rv.ROR5Mutator]MSP[] byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { MST[rv.ROR1Mutator]MSP[] final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ;
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; MST[rv.CRCR6Mutator]MSP[] } return byteCount ; }
buffer . put ( ( byte ) hex2 ) ; } else { if ( plusForSpace && b == ' ' ) { buffer . put ( ( byte ) '+' ) ; MST[rv.CRCR4Mutator]MSP[] } else { buffer . put ( b ) ; } } }
} else if ( obj instanceof byte [] ) { MST[rv.ROR5Mutator]MSP[] return decode ( ( byte [] ) obj ) ; } else { throw new DecoderException ( lr_2 + obj . getClass () . getName () + lr_4 ) ; } }
byteCount ++ ; } return byteCount ; } @Override public Object encode ( final Object obj ) throws EncoderException { if ( obj == null ) { return null ; } else if ( obj instanceof byte [] ) { MST[rv.ROR5Mutator]MSP[] return encode ( ( byte [] ) obj ) ;
this . alwaysEncodeChars . set ( b ) ; MST[rv.UOI2Mutator]MSP[] if ( b < alwaysEncodeCharsMin ) { alwaysEncodeCharsMin = b ; } if ( b > alwaysEncodeCharsMax ) { alwaysEncodeCharsMax = b ; } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { MST[rv.UOI2Mutator]MSP[] if ( b == ' ' ) { return true ; } } return false ; } private boolean canEncode ( final byte c ) {
if ( bytes == null ) { MST[rv.ROR5Mutator]MSP[] return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) {
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; MST[MathMutator]MSP[] }
return doEncode ( bytes , expectedEncodingBytes , willEncode ) ; } return bytes ; } private byte [] doEncode ( final byte [] bytes , final int expectedLength , final boolean willEncode ) { final ByteBuffer buffer = ByteBuffer . allocate ( expectedLength ) ; MST[rv.UOI2Mutator]MSP[]
return c >= 0 ; MST[rv.UOI2Mutator]MSP[] } @Override public byte [] decode ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { return null ; } final ByteBuffer buffer = ByteBuffer . allocate ( expectedDecodingBytes ( bytes ) ) ;
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[rv.ABSMutator]MSP[] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
} else { if ( plusForSpace && b == '+' ) { buffer . put ( ( byte ) ' ' ) ; } else { buffer . put ( b ) ; MST[rv.UOI1Mutator]MSP[] } } } return buffer . array () ; }
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { MST[rv.UOI3Mutator]MSP[] byteCount += canEncode ( b ) ? 3 : 1 ; } return byteCount ; }
} else { if ( plusForSpace && b == '+' ) { MST[rv.CRCR4Mutator]MSP[] buffer . put ( ( byte ) ' ' ) ; } else { buffer . put ( b ) ; } } } return buffer . array () ; }
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; MST[rv.CRCR4Mutator]MSP[] }
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { if ( b == ' ' ) { return true ; } } return false ; MST[rv.CRCR3Mutator]MSP[] } private boolean canEncode ( final byte c ) {
final int l = Utils . digit16 ( bytes [ ++ i ] ) ; buffer . put ( (byte) ( ( u << 4 ) + l ) ) ; MST[rv.AOR4Mutator]MSP[] } catch ( final ArrayIndexOutOfBoundsException e ) { throw new DecoderException ( lr_1 , e ) ; }
return c >= 0 ; MST[rv.CRCR6Mutator]MSP[] } @Override public byte [] decode ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { return null ; } final ByteBuffer buffer = ByteBuffer . allocate ( expectedDecodingBytes ( bytes ) ) ;
this . alwaysEncodeChars . set ( b ) ; if ( b < alwaysEncodeCharsMin ) { MST[rv.UOI1Mutator]MSP[] alwaysEncodeCharsMin = b ; } if ( b > alwaysEncodeCharsMax ) { alwaysEncodeCharsMax = b ; } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
buffer . put ( ( byte ) hex2 ) ; } else { if ( plusForSpace && b == ' ' ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] buffer . put ( ( byte ) '+' ) ; } else { buffer . put ( b ) ; } } }
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { MST[rv.UOI4Mutator]MSP[] byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ; MST[rv.UOI2Mutator]MSP[]
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) { MST[rv.ROR2Mutator]MSP[]
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { MST[rv.UOI2Mutator]MSP[] byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
buffer . put ( ( byte ) hex2 ) ; } else { if ( plusForSpace && b == ' ' ) { MST[rv.ROR5Mutator]MSP[] buffer . put ( ( byte ) '+' ) ; } else { buffer . put ( b ) ; } } }
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[rv.ROR5Mutator]MSP[] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { MST[rv.ROR2Mutator]MSP[] byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { MST[rv.ROR4Mutator]MSP[] bb = (byte) ( 256 + bb ) ; }
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { MST[rv.UOI1Mutator]MSP[] bb = (byte) ( 256 + bb ) ; }
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[rv.ROR4Mutator]MSP[] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[rv.ABSMutator]MSP[] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
final int l = Utils . digit16 ( bytes [ ++ i ] ) ; buffer . put ( (byte) ( ( u << 4 ) + l ) ) ; MST[rv.CRCR5Mutator]MSP[] } catch ( final ArrayIndexOutOfBoundsException e ) { throw new DecoderException ( lr_1 , e ) ; }
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; MST[rv.UOI2Mutator]MSP[] }
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; MST[rv.UOI4Mutator]MSP[] }
buffer . put ( ( byte ) hex2 ) ; } else { if ( plusForSpace && b == ' ' ) { buffer . put ( ( byte ) '+' ) ; MST[rv.CRCR1Mutator]MSP[] } else { buffer . put ( b ) ; } } }
for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ; MST[rv.UOI4Mutator]MSP[] if ( b == ESCAPE_CHAR ) { try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[rv.CRCR5Mutator]MSP[] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
final int l = Utils . digit16 ( bytes [ ++ i ] ) ; MST[rv.UOI1Mutator]MSP[] buffer . put ( (byte) ( ( u << 4 ) + l ) ) ; } catch ( final ArrayIndexOutOfBoundsException e ) { throw new DecoderException ( lr_1 , e ) ; }
this . alwaysEncodeChars . set ( b ) ; MST[rv.ABSMutator]MSP[] if ( b < alwaysEncodeCharsMin ) { alwaysEncodeCharsMin = b ; } if ( b > alwaysEncodeCharsMax ) { alwaysEncodeCharsMax = b ; } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
} else { throw new EncoderException ( lr_2 + obj . getClass () . getName () + lr_3 ) ; MST[experimental.NakedReceiverMutator]MSP[] } } @Override public Object decode ( final Object obj ) throws DecoderException { if ( obj == null ) { return null ;
for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ; MST[rv.UOI3Mutator]MSP[]
final char hex1 = Utils . hexDigit ( bb >> 4 ) ; MST[rv.CRCR2Mutator]MSP[] final char hex2 = Utils . hexDigit ( bb ) ; buffer . put ( ESCAPE_CHAR ) ; buffer . put ( ( byte ) hex1 ) ;
byteCount ++ ; } return byteCount ; } @Override public Object encode ( final Object obj ) throws EncoderException { if ( obj == null ) { MST[NegateConditionalsMutator]MSP[] return null ; } else if ( obj instanceof byte [] ) { return encode ( ( byte [] ) obj ) ;
return buffer . array () ; MST[NullReturnValsMutator]MSP[] } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; } return byteCount ; }
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { MST[rv.CRCR2Mutator]MSP[] if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
return doEncode ( bytes , expectedEncodingBytes , willEncode ) ; MST[NonVoidMethodCallMutator]MSP[] } return bytes ; } private byte [] doEncode ( final byte [] bytes , final int expectedLength , final boolean willEncode ) { final ByteBuffer buffer = ByteBuffer . allocate ( expectedLength ) ;
this . alwaysEncodeChars . set ( b ) ; if ( b < alwaysEncodeCharsMin ) { alwaysEncodeCharsMin = b ; MST[rv.UOI2Mutator]MSP[] } if ( b > alwaysEncodeCharsMax ) { alwaysEncodeCharsMax = b ; } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
} else { throw new EncoderException ( lr_2 + obj . getClass () . getName () + lr_3 ) ; MST[NonVoidMethodCallMutator]MSP[] } } @Override public Object decode ( final Object obj ) throws DecoderException { if ( obj == null ) { return null ;
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { MST[rv.CRCR3Mutator]MSP[] if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
final char hex1 = Utils . hexDigit ( bb >> 4 ) ; final char hex2 = Utils . hexDigit ( bb ) ; buffer . put ( ESCAPE_CHAR ) ; MST[rv.CRCR1Mutator]MSP[] buffer . put ( ( byte ) hex1 ) ;
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; MST[rv.UOI3Mutator]MSP[] } private boolean isAsciiChar ( final byte c ) {
} else if ( obj instanceof byte [] ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return decode ( ( byte [] ) obj ) ; } else { throw new DecoderException ( lr_2 + obj . getClass () . getName () + lr_4 ) ; } }
buffer . put ( ( byte ) hex2 ) ; } else { if ( plusForSpace && b == ' ' ) { MST[NegateConditionalsMutator]MSP[] buffer . put ( ( byte ) '+' ) ; } else { buffer . put ( b ) ; } } }
this . alwaysEncodeChars . set ( b ) ; if ( b < alwaysEncodeCharsMin ) { alwaysEncodeCharsMin = b ; } if ( b > alwaysEncodeCharsMax ) { alwaysEncodeCharsMax = b ; MST[rv.UOI1Mutator]MSP[] } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; MST[rv.UOI4Mutator]MSP[] } return byteCount ; }
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { MST[rv.ABSMutator]MSP[] byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
} else if ( obj instanceof byte [] ) { return decode ( ( byte [] ) obj ) ; MST[NullReturnValsMutator]MSP[] } else { throw new DecoderException ( lr_2 + obj . getClass () . getName () + lr_4 ) ; } }
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { MST[rv.UOI3Mutator]MSP[] byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { MST[rv.UOI2Mutator]MSP[] insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; MST[rv.ROR2Mutator]MSP[] if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) {
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { final byte b = bytes [ i ] ; MST[rv.UOI1Mutator]MSP[] i += b == ESCAPE_CHAR ? 3 : 1 ;
} else if ( obj instanceof byte [] ) { MST[rv.ROR3Mutator]MSP[] return decode ( ( byte [] ) obj ) ; } else { throw new DecoderException ( lr_2 + obj . getClass () . getName () + lr_4 ) ; } }
this . alwaysEncodeChars . set ( b ) ; MST[rv.UOI4Mutator]MSP[] if ( b < alwaysEncodeCharsMin ) { alwaysEncodeCharsMin = b ; } if ( b > alwaysEncodeCharsMax ) { alwaysEncodeCharsMax = b ; } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; MST[rv.ABSMutator]MSP[] }
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[rv.UOI2Mutator]MSP[] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { MST[rv.ROR3Mutator]MSP[] final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ;
} else { if ( plusForSpace && b == '+' ) { MST[InlineConstantMutator]MSP[] buffer . put ( ( byte ) ' ' ) ; } else { buffer . put ( b ) ; } } } return buffer . array () ; }
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ; MST[rv.CRCR5Mutator]MSP[]
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { MST[rv.CRCR3Mutator]MSP[] if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
for ( int i = 0 ; i < bytes . length ; i ++ ) { MST[IncrementsMutator]MSP[] final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; MST[rv.ROR1Mutator]MSP[] } private boolean isAsciiChar ( final byte c ) {
return c >= 0 ; MST[rv.ABSMutator]MSP[] } @Override public byte [] decode ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { return null ; } final ByteBuffer buffer = ByteBuffer . allocate ( expectedDecodingBytes ( bytes ) ) ;
this . alwaysEncodeChars . set ( b ) ; if ( b < alwaysEncodeCharsMin ) { alwaysEncodeCharsMin = b ; } if ( b > alwaysEncodeCharsMax ) { MST[rv.UOI3Mutator]MSP[] alwaysEncodeCharsMax = b ; } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
return c >= 0 ; MST[rv.ROR5Mutator]MSP[] } @Override public byte [] decode ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { return null ; } final ByteBuffer buffer = ByteBuffer . allocate ( expectedDecodingBytes ( bytes ) ) ;
final char hex1 = Utils . hexDigit ( bb >> 4 ) ; final char hex2 = Utils . hexDigit ( bb ) ; MST[NonVoidMethodCallMutator]MSP[] buffer . put ( ESCAPE_CHAR ) ; buffer . put ( ( byte ) hex1 ) ;
byteCount ++ ; } return byteCount ; } @Override public Object encode ( final Object obj ) throws EncoderException { if ( obj == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return null ; } else if ( obj instanceof byte [] ) { return encode ( ( byte [] ) obj ) ;
final int l = Utils . digit16 ( bytes [ ++ i ] ) ; buffer . put ( (byte) ( ( u << 4 ) + l ) ) ; MST[rv.UOI3Mutator]MSP[] } catch ( final ArrayIndexOutOfBoundsException e ) { throw new DecoderException ( lr_1 , e ) ; }
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[] bb = (byte) ( 256 + bb ) ; }
} else { if ( plusForSpace && b == '+' ) { MST[NegateConditionalsMutator]MSP[] buffer . put ( ( byte ) ' ' ) ; } else { buffer . put ( b ) ; } } } return buffer . array () ; }
return doEncode ( bytes , expectedEncodingBytes , willEncode ) ; MST[rv.UOI2Mutator]MSP[] } return bytes ; } private byte [] doEncode ( final byte [] bytes , final int expectedLength , final boolean willEncode ) { final ByteBuffer buffer = ByteBuffer . allocate ( expectedLength ) ;
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { if ( b == ' ' ) { MST[rv.CRCR4Mutator]MSP[] return true ; } } return false ; } private boolean canEncode ( final byte c ) {
final int l = Utils . digit16 ( bytes [ ++ i ] ) ; MST[experimental.RemoveIncrementsMutator]MSP[] buffer . put ( (byte) ( ( u << 4 ) + l ) ) ; } catch ( final ArrayIndexOutOfBoundsException e ) { throw new DecoderException ( lr_1 , e ) ; }
} else if ( obj instanceof byte [] ) { MST[NegateConditionalsMutator]MSP[] return decode ( ( byte [] ) obj ) ; } else { throw new DecoderException ( lr_2 + obj . getClass () . getName () + lr_4 ) ; } }
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[rv.UOI3Mutator]MSP[] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; } return byteCount ; MST[rv.UOI1Mutator]MSP[] }
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; MST[rv.CRCR3Mutator]MSP[] } return byteCount ; }
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; MST[rv.UOI4Mutator]MSP[] if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) {
return c >= 0 ; MST[ConditionalsBoundaryMutator]MSP[] } @Override public byte [] decode ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { return null ; } final ByteBuffer buffer = ByteBuffer . allocate ( expectedDecodingBytes ( bytes ) ) ;
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; MST[InlineConstantMutator]MSP[] for ( int i = 0 ; i < bytes . length ; ) { final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ;
} else if ( obj instanceof byte [] ) { return decode ( ( byte [] ) obj ) ; } else { throw new DecoderException ( lr_2 + obj . getClass () . getName () + lr_4 ) ; MST[NonVoidMethodCallMutator]MSP[] } }
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { MST[rv.UOI2Mutator]MSP[] byteCount += canEncode ( b ) ? 3 : 1 ; } return byteCount ; }
buffer . put ( ( byte ) hex2 ) ; MST[rv.UOI3Mutator]MSP[] } else { if ( plusForSpace && b == ' ' ) { buffer . put ( ( byte ) '+' ) ; } else { buffer . put ( b ) ; } } }
} else { throw new EncoderException ( lr_2 + obj . getClass () . getName () + lr_3 ) ; } } @Override public Object decode ( final Object obj ) throws DecoderException { if ( obj == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return null ;
this . alwaysEncodeChars . set ( b ) ; if ( b < alwaysEncodeCharsMin ) { MST[rv.ROR2Mutator]MSP[] alwaysEncodeCharsMin = b ; } if ( b > alwaysEncodeCharsMax ) { alwaysEncodeCharsMax = b ; } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
this . alwaysEncodeChars . set ( b ) ; if ( b < alwaysEncodeCharsMin ) { alwaysEncodeCharsMin = b ; } if ( b > alwaysEncodeCharsMax ) { MST[rv.ROR1Mutator]MSP[] alwaysEncodeCharsMax = b ; } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
final int l = Utils . digit16 ( bytes [ ++ i ] ) ; buffer . put ( (byte) ( ( u << 4 ) + l ) ) ; MST[rv.UOI4Mutator]MSP[] } catch ( final ArrayIndexOutOfBoundsException e ) { throw new DecoderException ( lr_1 , e ) ; }
buffer . put ( ( byte ) hex2 ) ; } else { if ( plusForSpace && b == ' ' ) { MST[rv.ROR4Mutator]MSP[] buffer . put ( ( byte ) '+' ) ; } else { buffer . put ( b ) ; } } }
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ; MST[rv.AOR1Mutator]MSP[]
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { if ( alwaysEncodeCharsArray != null ) { MST[rv.ROR5Mutator]MSP[] for ( final byte b : alwaysEncodeCharsArray ) { insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; MST[rv.UOI3Mutator]MSP[] } private boolean isAsciiChar ( final byte c ) {
for ( final byte b : bytes ) { MST[rv.UOI1Mutator]MSP[] if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
} else { if ( plusForSpace && b == '+' ) { buffer . put ( ( byte ) ' ' ) ; MST[rv.CRCR5Mutator]MSP[] } else { buffer . put ( b ) ; } } } return buffer . array () ; }
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; MST[rv.CRCR4Mutator]MSP[] } private void insertAlwaysEncodeChar ( final byte b ) {
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { MST[rv.ROR5Mutator]MSP[] byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { MST[rv.UOI3Mutator]MSP[] insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; MST[rv.ABSMutator]MSP[] if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) {
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) { MST[rv.UOI3Mutator]MSP[]
return c >= 0 ; } @Override public byte [] decode ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { MST[NegateConditionalsMutator]MSP[] return null ; } final ByteBuffer buffer = ByteBuffer . allocate ( expectedDecodingBytes ( bytes ) ) ;
} else { if ( plusForSpace && b == '+' ) { MST[rv.UOI2Mutator]MSP[] buffer . put ( ( byte ) ' ' ) ; } else { buffer . put ( b ) ; } } } return buffer . array () ; }
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; MST[NonVoidMethodCallMutator]MSP[] final boolean willEncode = expectedEncodingBytes != bytes . length ; if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) {
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ; MST[rv.CRCR5Mutator]MSP[]
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { if ( b == ' ' ) { MST[rv.UOI2Mutator]MSP[] return true ; } } return false ; } private boolean canEncode ( final byte c ) {
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[rv.UOI1Mutator]MSP[] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
final int l = Utils . digit16 ( bytes [ ++ i ] ) ; buffer . put ( (byte) ( ( u << 4 ) + l ) ) ; MST[rv.AOD1Mutator]MSP[] } catch ( final ArrayIndexOutOfBoundsException e ) { throw new DecoderException ( lr_1 , e ) ; }
for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { MST[rv.ROR4Mutator]MSP[] try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[rv.CRCR1Mutator]MSP[] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
final int l = Utils . digit16 ( bytes [ ++ i ] ) ; buffer . put ( (byte) ( ( u << 4 ) + l ) ) ; MST[rv.AOR3Mutator]MSP[] } catch ( final ArrayIndexOutOfBoundsException e ) { throw new DecoderException ( lr_1 , e ) ; }
this . alwaysEncodeChars . set ( b ) ; if ( b < alwaysEncodeCharsMin ) { alwaysEncodeCharsMin = b ; } if ( b > alwaysEncodeCharsMax ) { MST[rv.UOI1Mutator]MSP[] alwaysEncodeCharsMax = b ; } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
for ( final byte b : bytes ) { MST[rv.UOI4Mutator]MSP[] if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { MST[rv.UOI1Mutator]MSP[] byteCount += canEncode ( b ) ? 3 : 1 ; } return byteCount ; }
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; MST[rv.CRCR1Mutator]MSP[] }
final char hex1 = Utils . hexDigit ( bb >> 4 ) ; final char hex2 = Utils . hexDigit ( bb ) ; buffer . put ( ESCAPE_CHAR ) ; MST[NonVoidMethodCallMutator]MSP[] buffer . put ( ( byte ) hex1 ) ;
return c >= 0 ; MST[rv.CRCR5Mutator]MSP[] } @Override public byte [] decode ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { return null ; } final ByteBuffer buffer = ByteBuffer . allocate ( expectedDecodingBytes ( bytes ) ) ;
this . alwaysEncodeChars . set ( b ) ; if ( b < alwaysEncodeCharsMin ) { MST[rv.UOI2Mutator]MSP[] alwaysEncodeCharsMin = b ; } if ( b > alwaysEncodeCharsMax ) { alwaysEncodeCharsMax = b ; } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { MST[rv.UOI1Mutator]MSP[] byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { MST[experimental.MemberVariableMutator]MSP[] if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
} else { if ( plusForSpace && b == '+' ) { MST[rv.CRCR1Mutator]MSP[] buffer . put ( ( byte ) ' ' ) ; } else { buffer . put ( b ) ; } } } return buffer . array () ; }
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { byte bb = b ; MST[rv.UOI3Mutator]MSP[] if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { final byte b = bytes [ i ] ; MST[rv.UOI4Mutator]MSP[] i += b == ESCAPE_CHAR ? 3 : 1 ;
final char hex1 = Utils . hexDigit ( bb >> 4 ) ; final char hex2 = Utils . hexDigit ( bb ) ; buffer . put ( ESCAPE_CHAR ) ; MST[experimental.NakedReceiverMutator]MSP[] buffer . put ( ( byte ) hex1 ) ;
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; MST[rv.AOD1Mutator]MSP[] } return byteCount ; }
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; MST[rv.CRCR3Mutator]MSP[] } private boolean isAsciiChar ( final byte c ) {
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) { MST[rv.ROR4Mutator]MSP[]
buffer . put ( ( byte ) hex2 ) ; } else { if ( plusForSpace && b == ' ' ) { MST[rv.ROR2Mutator]MSP[] buffer . put ( ( byte ) '+' ) ; } else { buffer . put ( b ) ; } } }
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ; MST[rv.UOI1Mutator]MSP[]
return doEncode ( bytes , expectedEncodingBytes , willEncode ) ; MST[ArgumentPropagationMutator]MSP[] } return bytes ; } private byte [] doEncode ( final byte [] bytes , final int expectedLength , final boolean willEncode ) { final ByteBuffer buffer = ByteBuffer . allocate ( expectedLength ) ;
} else if ( obj instanceof byte [] ) { MST[rv.ROR2Mutator]MSP[] return decode ( ( byte [] ) obj ) ; } else { throw new DecoderException ( lr_2 + obj . getClass () . getName () + lr_4 ) ; } }
byteCount ++ ; } return byteCount ; } @Override public Object encode ( final Object obj ) throws EncoderException { if ( obj == null ) { return null ; } else if ( obj instanceof byte [] ) { MST[rv.ROR4Mutator]MSP[] return encode ( ( byte [] ) obj ) ;
byteCount ++ ; } return byteCount ; } @Override public Object encode ( final Object obj ) throws EncoderException { if ( obj == null ) { return null ; } else if ( obj instanceof byte [] ) { return encode ( ( byte [] ) obj ) ; MST[ReturnValsMutator]MSP[]
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { if ( alwaysEncodeCharsArray != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] for ( final byte b : alwaysEncodeCharsArray ) { insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ; MST[rv.ABSMutator]MSP[]
this . alwaysEncodeChars . set ( b ) ; if ( b < alwaysEncodeCharsMin ) { MST[rv.ROR3Mutator]MSP[] alwaysEncodeCharsMin = b ; } if ( b > alwaysEncodeCharsMax ) { alwaysEncodeCharsMax = b ; } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
for ( final byte b : bytes ) { MST[rv.UOI3Mutator]MSP[] if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
final char hex1 = Utils . hexDigit ( bb >> 4 ) ; final char hex2 = Utils . hexDigit ( bb ) ; buffer . put ( ESCAPE_CHAR ) ; MST[rv.CRCR6Mutator]MSP[] buffer . put ( ( byte ) hex1 ) ;
} else if ( obj instanceof byte [] ) { return decode ( ( byte [] ) obj ) ; } else { throw new DecoderException ( lr_2 + obj . getClass () . getName () + lr_4 ) ; MST[NonVoidMethodCallMutator]MSP[] } }
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; MST[rv.AOR3Mutator]MSP[] } return byteCount ; }
final int l = Utils . digit16 ( bytes [ ++ i ] ) ; MST[rv.UOI4Mutator]MSP[] buffer . put ( (byte) ( ( u << 4 ) + l ) ) ; } catch ( final ArrayIndexOutOfBoundsException e ) { throw new DecoderException ( lr_1 , e ) ; }
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] } return byteCount ; }
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { MST[rv.UOI2Mutator]MSP[] byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
} else { if ( plusForSpace && b == '+' ) { buffer . put ( ( byte ) ' ' ) ; MST[rv.CRCR2Mutator]MSP[] } else { buffer . put ( b ) ; } } } return buffer . array () ; }
} else if ( obj instanceof byte [] ) { return decode ( ( byte [] ) obj ) ; } else { throw new DecoderException ( lr_2 + obj . getClass () . getName () + lr_4 ) ; MST[experimental.NakedReceiverMutator]MSP[] } }
this . alwaysEncodeChars . set ( b ) ; if ( b < alwaysEncodeCharsMin ) { alwaysEncodeCharsMin = b ; } if ( b > alwaysEncodeCharsMax ) { alwaysEncodeCharsMax = b ; MST[rv.UOI2Mutator]MSP[] } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { MST[rv.ROR2Mutator]MSP[] byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; MST[rv.UOI1Mutator]MSP[] }
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[rv.ROR3Mutator]MSP[] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; MST[VoidMethodCallMutator]MSP[] } private void insertAlwaysEncodeChar ( final byte b ) {
buffer . put ( ( byte ) hex2 ) ; } else { if ( plusForSpace && b == ' ' ) { buffer . put ( ( byte ) '+' ) ; MST[rv.CRCR6Mutator]MSP[] } else { buffer . put ( b ) ; } } }
} else { if ( plusForSpace && b == '+' ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] buffer . put ( ( byte ) ' ' ) ; } else { buffer . put ( b ) ; } } } return buffer . array () ; }
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { MST[rv.ABSMutator]MSP[] if ( b == ' ' ) { return true ; } } return false ; } private boolean canEncode ( final byte c ) {
buffer . put ( ( byte ) hex2 ) ; } else { if ( plusForSpace && b == ' ' ) { buffer . put ( ( byte ) '+' ) ; MST[NonVoidMethodCallMutator]MSP[] } else { buffer . put ( b ) ; } } }
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; } return byteCount ; MST[rv.UOI4Mutator]MSP[] }
final int l = Utils . digit16 ( bytes [ ++ i ] ) ; buffer . put ( (byte) ( ( u << 4 ) + l ) ) ; MST[rv.ABSMutator]MSP[] } catch ( final ArrayIndexOutOfBoundsException e ) { throw new DecoderException ( lr_1 , e ) ; }
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { MST[rv.CRCR1Mutator]MSP[] final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ;
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { if ( b == ' ' ) { MST[rv.UOI4Mutator]MSP[] return true ; } } return false ; } private boolean canEncode ( final byte c ) {
return c >= 0 ; } @Override public byte [] decode ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return null ; } final ByteBuffer buffer = ByteBuffer . allocate ( expectedDecodingBytes ( bytes ) ) ;
for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ; MST[rv.UOI3Mutator]MSP[] if ( b == ESCAPE_CHAR ) { try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
byteCount ++ ; } return byteCount ; } @Override public Object encode ( final Object obj ) throws EncoderException { if ( obj == null ) { MST[rv.ROR5Mutator]MSP[] return null ; } else if ( obj instanceof byte [] ) { return encode ( ( byte [] ) obj ) ;
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; MST[rv.ROR3Mutator]MSP[] } private boolean isAsciiChar ( final byte c ) {
return c >= 0 ; MST[rv.ROR1Mutator]MSP[] } @Override public byte [] decode ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { return null ; } final ByteBuffer buffer = ByteBuffer . allocate ( expectedDecodingBytes ( bytes ) ) ;
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[ReturnValsMutator]MSP[] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; MST[rv.ROR5Mutator]MSP[] } private boolean isAsciiChar ( final byte c ) {
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { MST[rv.CRCR2Mutator]MSP[] if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { MST[rv.ABSMutator]MSP[] byteCount += canEncode ( b ) ? 3 : 1 ; } return byteCount ; }
return c >= 0 ; MST[InlineConstantMutator]MSP[] } @Override public byte [] decode ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { return null ; } final ByteBuffer buffer = ByteBuffer . allocate ( expectedDecodingBytes ( bytes ) ) ;
return doEncode ( bytes , expectedEncodingBytes , willEncode ) ; MST[rv.UOI4Mutator]MSP[] } return bytes ; } private byte [] doEncode ( final byte [] bytes , final int expectedLength , final boolean willEncode ) { final ByteBuffer buffer = ByteBuffer . allocate ( expectedLength ) ;
} else { if ( plusForSpace && b == '+' ) { MST[rv.UOI1Mutator]MSP[] buffer . put ( ( byte ) ' ' ) ; } else { buffer . put ( b ) ; } } } return buffer . array () ; }
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; MST[InlineConstantMutator]MSP[] } private boolean isAsciiChar ( final byte c ) {
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { if ( b == ' ' ) { return true ; MST[rv.CRCR6Mutator]MSP[] } } return false ; } private boolean canEncode ( final byte c ) {
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { MST[rv.UOI3Mutator]MSP[] insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
return doEncode ( bytes , expectedEncodingBytes , willEncode ) ; MST[rv.UOI1Mutator]MSP[] } return bytes ; } private byte [] doEncode ( final byte [] bytes , final int expectedLength , final boolean willEncode ) { final ByteBuffer buffer = ByteBuffer . allocate ( expectedLength ) ;
this . alwaysEncodeChars . set ( b ) ; if ( b < alwaysEncodeCharsMin ) { alwaysEncodeCharsMin = b ; } if ( b > alwaysEncodeCharsMax ) { MST[rv.UOI4Mutator]MSP[] alwaysEncodeCharsMax = b ; } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ; MST[rv.ROR2Mutator]MSP[]
for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { MST[rv.CRCR4Mutator]MSP[] try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { MST[rv.CRCR1Mutator]MSP[] try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { MST[NonVoidMethodCallMutator]MSP[] byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
return c >= 0 ; } @Override public byte [] decode ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { MST[rv.ROR5Mutator]MSP[] return null ; } final ByteBuffer buffer = ByteBuffer . allocate ( expectedDecodingBytes ( bytes ) ) ;
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { if ( b == ' ' ) { MST[rv.ROR1Mutator]MSP[] return true ; } } return false ; } private boolean canEncode ( final byte c ) {
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { insertAlwaysEncodeChar ( b ) ; MST[rv.UOI1Mutator]MSP[] } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[NonVoidMethodCallMutator]MSP[] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; MST[rv.CRCR1Mutator]MSP[] } return byteCount ; }
final int l = Utils . digit16 ( bytes [ ++ i ] ) ; buffer . put ( (byte) ( ( u << 4 ) + l ) ) ; MST[rv.AOD2Mutator]MSP[] } catch ( final ArrayIndexOutOfBoundsException e ) { throw new DecoderException ( lr_1 , e ) ; }
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[rv.UOI2Mutator]MSP[] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
} else if ( obj instanceof byte [] ) { return decode ( ( byte [] ) obj ) ; MST[NonVoidMethodCallMutator]MSP[] } else { throw new DecoderException ( lr_2 + obj . getClass () . getName () + lr_4 ) ; } }
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[rv.UOI4Mutator]MSP[] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ; MST[rv.UOI2Mutator]MSP[]
this . alwaysEncodeChars . set ( b ) ; if ( b < alwaysEncodeCharsMin ) { alwaysEncodeCharsMin = b ; MST[rv.UOI3Mutator]MSP[] } if ( b > alwaysEncodeCharsMax ) { alwaysEncodeCharsMax = b ; } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; MST[rv.CRCR2Mutator]MSP[] if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) {
} else if ( obj instanceof byte [] ) { return decode ( ( byte [] ) obj ) ; } else { throw new DecoderException ( lr_2 + obj . getClass () . getName () + lr_4 ) ; MST[NonVoidMethodCallMutator]MSP[] } }
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { MST[rv.CRCR1Mutator]MSP[] if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
buffer . put ( ( byte ) hex2 ) ; MST[rv.UOI2Mutator]MSP[] } else { if ( plusForSpace && b == ' ' ) { buffer . put ( ( byte ) '+' ) ; } else { buffer . put ( b ) ; } } }
for ( int i = 0 ; i < bytes . length ; i ++ ) { MST[rv.CRCR1Mutator]MSP[] final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { MST[rv.CRCR6Mutator]MSP[] if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
this . alwaysEncodeChars . set ( b ) ; if ( b < alwaysEncodeCharsMin ) { alwaysEncodeCharsMin = b ; } if ( b > alwaysEncodeCharsMax ) { MST[rv.ROR2Mutator]MSP[] alwaysEncodeCharsMax = b ; } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
final int l = Utils . digit16 ( bytes [ ++ i ] ) ; buffer . put ( (byte) ( ( u << 4 ) + l ) ) ; MST[rv.UOI3Mutator]MSP[] } catch ( final ArrayIndexOutOfBoundsException e ) { throw new DecoderException ( lr_1 , e ) ; }
} else { if ( plusForSpace && b == '+' ) { MST[rv.ROR5Mutator]MSP[] buffer . put ( ( byte ) ' ' ) ; } else { buffer . put ( b ) ; } } } return buffer . array () ; }
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { final byte b = bytes [ i ] ; MST[rv.UOI3Mutator]MSP[] i += b == ESCAPE_CHAR ? 3 : 1 ;
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { insertAlwaysEncodeChar ( b ) ; MST[rv.ABSMutator]MSP[] } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
} else if ( obj instanceof byte [] ) { return decode ( ( byte [] ) obj ) ; } else { throw new DecoderException ( lr_2 + obj . getClass () . getName () + lr_4 ) ; MST[experimental.NakedReceiverMutator]MSP[] } }
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { MST[rv.UOI2Mutator]MSP[] byteCount += canEncode ( b ) ? 3 : 1 ; } return byteCount ; }
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { MST[rv.UOI4Mutator]MSP[] insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ; MST[rv.UOI2Mutator]MSP[]
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; MST[rv.UOI4Mutator]MSP[] } return byteCount ; }
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; MST[rv.ROR1Mutator]MSP[] } return byteCount ; }
buffer . put ( ( byte ) hex2 ) ; } else { if ( plusForSpace && b == ' ' ) { MST[rv.CRCR5Mutator]MSP[] buffer . put ( ( byte ) '+' ) ; } else { buffer . put ( b ) ; } } }
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[rv.ROR1Mutator]MSP[] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
} else { throw new EncoderException ( lr_2 + obj . getClass () . getName () + lr_3 ) ; MST[ConstructorCallMutator]MSP[] } } @Override public Object decode ( final Object obj ) throws DecoderException { if ( obj == null ) { return null ;
this . alwaysEncodeChars . set ( b ) ; MST[VoidMethodCallMutator]MSP[] if ( b < alwaysEncodeCharsMin ) { alwaysEncodeCharsMin = b ; } if ( b > alwaysEncodeCharsMax ) { alwaysEncodeCharsMax = b ; } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[rv.ROR4Mutator]MSP[] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
final int l = Utils . digit16 ( bytes [ ++ i ] ) ; buffer . put ( (byte) ( ( u << 4 ) + l ) ) ; MST[rv.UOI2Mutator]MSP[] } catch ( final ArrayIndexOutOfBoundsException e ) { throw new DecoderException ( lr_1 , e ) ; }
return c >= 0 ; MST[rv.CRCR5Mutator]MSP[] } @Override public byte [] decode ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { return null ; } final ByteBuffer buffer = ByteBuffer . allocate ( expectedDecodingBytes ( bytes ) ) ;
for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ; MST[rv.UOI4Mutator]MSP[] if ( b == ESCAPE_CHAR ) { try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[rv.CRCR4Mutator]MSP[] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
buffer . put ( ( byte ) hex2 ) ; } else { if ( plusForSpace && b == ' ' ) { buffer . put ( ( byte ) '+' ) ; MST[experimental.NakedReceiverMutator]MSP[] } else { buffer . put ( b ) ; } } }
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { MST[rv.UOI4Mutator]MSP[] byteCount += canEncode ( b ) ? 3 : 1 ; } return byteCount ; }
for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ; MST[rv.ABSMutator]MSP[] if ( b == ESCAPE_CHAR ) { try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
for ( final byte b : bytes ) { MST[rv.UOI4Mutator]MSP[] if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
} else { if ( plusForSpace && b == '+' ) { MST[rv.CRCR6Mutator]MSP[] buffer . put ( ( byte ) ' ' ) ; } else { buffer . put ( b ) ; } } } return buffer . array () ; }
buffer . put ( ( byte ) hex2 ) ; } else { if ( plusForSpace && b == ' ' ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] buffer . put ( ( byte ) '+' ) ; } else { buffer . put ( b ) ; } } }
for ( final byte b : bytes ) { MST[rv.UOI2Mutator]MSP[] if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
byteCount ++ ; } return byteCount ; } @Override public Object encode ( final Object obj ) throws EncoderException { if ( obj == null ) { return null ; } else if ( obj instanceof byte [] ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return encode ( ( byte [] ) obj ) ;
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { MST[rv.UOI3Mutator]MSP[] if ( b == ' ' ) { return true ; } } return false ; } private boolean canEncode ( final byte c ) {
for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ; MST[rv.UOI2Mutator]MSP[] if ( b == ESCAPE_CHAR ) { try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
final int l = Utils . digit16 ( bytes [ ++ i ] ) ; MST[rv.UOI3Mutator]MSP[] buffer . put ( (byte) ( ( u << 4 ) + l ) ) ; } catch ( final ArrayIndexOutOfBoundsException e ) { throw new DecoderException ( lr_1 , e ) ; }
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; MST[rv.AOR1Mutator]MSP[] }
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { MST[rv.UOI1Mutator]MSP[] if ( b == ' ' ) { return true ; } } return false ; } private boolean canEncode ( final byte c ) {
for ( final byte b : bytes ) { MST[rv.ABSMutator]MSP[] if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
} else { if ( plusForSpace && b == '+' ) { MST[rv.ROR1Mutator]MSP[] buffer . put ( ( byte ) ' ' ) ; } else { buffer . put ( b ) ; } } } return buffer . array () ; }
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { if ( b == ' ' ) { return true ; } } return false ; MST[rv.CRCR5Mutator]MSP[] } private boolean canEncode ( final byte c ) {
} else { if ( plusForSpace && b == '+' ) { MST[rv.ROR3Mutator]MSP[] buffer . put ( ( byte ) ' ' ) ; } else { buffer . put ( b ) ; } } } return buffer . array () ; }
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; MST[rv.CRCR6Mutator]MSP[] }
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; MST[rv.CRCR3Mutator]MSP[] } private boolean isAsciiChar ( final byte c ) {
} else { throw new EncoderException ( lr_2 + obj . getClass () . getName () + lr_3 ) ; MST[NonVoidMethodCallMutator]MSP[] } } @Override public Object decode ( final Object obj ) throws DecoderException { if ( obj == null ) { return null ;
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) { MST[rv.ROR4Mutator]MSP[]
} else { throw new EncoderException ( lr_2 + obj . getClass () . getName () + lr_3 ) ; } } @Override public Object decode ( final Object obj ) throws DecoderException { if ( obj == null ) { MST[NegateConditionalsMutator]MSP[] return null ;
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; MST[rv.CRCR5Mutator]MSP[] } private boolean isAsciiChar ( final byte c ) {
return doEncode ( bytes , expectedEncodingBytes , willEncode ) ; MST[NullReturnValsMutator]MSP[] } return bytes ; } private byte [] doEncode ( final byte [] bytes , final int expectedLength , final boolean willEncode ) { final ByteBuffer buffer = ByteBuffer . allocate ( expectedLength ) ;
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { MST[rv.UOI1Mutator]MSP[] byteCount += canEncode ( b ) ? 3 : 1 ; } return byteCount ; }
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { byte bb = b ; MST[rv.ABSMutator]MSP[] if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { MST[rv.UOI1Mutator]MSP[] insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { MST[rv.UOI3Mutator]MSP[] bb = (byte) ( 256 + bb ) ; }
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { MST[rv.CRCR6Mutator]MSP[] final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ;
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { MST[NegateConditionalsMutator]MSP[] final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ;
buffer . put ( ( byte ) hex2 ) ; } else { if ( plusForSpace && b == ' ' ) { buffer . put ( ( byte ) '+' ) ; MST[rv.CRCR3Mutator]MSP[] } else { buffer . put ( b ) ; } } }
buffer . put ( ( byte ) hex2 ) ; } else { if ( plusForSpace && b == ' ' ) { MST[rv.CRCR2Mutator]MSP[] buffer . put ( ( byte ) '+' ) ; } else { buffer . put ( b ) ; } } }
return c >= 0 ; MST[NegateConditionalsMutator]MSP[] } @Override public byte [] decode ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { return null ; } final ByteBuffer buffer = ByteBuffer . allocate ( expectedDecodingBytes ( bytes ) ) ;
} else { if ( plusForSpace && b == '+' ) { buffer . put ( ( byte ) ' ' ) ; } else { buffer . put ( b ) ; MST[rv.UOI3Mutator]MSP[] } } } return buffer . array () ; }
for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ; MST[rv.UOI1Mutator]MSP[]
this . alwaysEncodeChars . set ( b ) ; if ( b < alwaysEncodeCharsMin ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] alwaysEncodeCharsMin = b ; } if ( b > alwaysEncodeCharsMax ) { alwaysEncodeCharsMax = b ; } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
for ( final byte b : bytes ) { MST[rv.UOI3Mutator]MSP[] if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
return c >= 0 ; } @Override public byte [] decode ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { return null ; } final ByteBuffer buffer = ByteBuffer . allocate ( expectedDecodingBytes ( bytes ) ) ; MST[NonVoidMethodCallMutator]MSP[]
} else if ( obj instanceof byte [] ) { return decode ( ( byte [] ) obj ) ; } else { throw new DecoderException ( lr_2 + obj . getClass () . getName () + lr_4 ) ; MST[NonVoidMethodCallMutator]MSP[] } }
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; } return byteCount ; MST[PrimitiveReturnsMutator]MSP[] }
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; MST[rv.CRCR4Mutator]MSP[] if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) {
} else { if ( plusForSpace && b == '+' ) { MST[rv.ROR2Mutator]MSP[] buffer . put ( ( byte ) ' ' ) ; } else { buffer . put ( b ) ; } } } return buffer . array () ; }
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; MST[rv.UOI2Mutator]MSP[] } private boolean isAsciiChar ( final byte c ) {
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; MST[NegateConditionalsMutator]MSP[] } private boolean isAsciiChar ( final byte c ) {
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) { MST[rv.ROR3Mutator]MSP[]
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { if ( b == ' ' ) { return true ; MST[InlineConstantMutator]MSP[] } } return false ; } private boolean canEncode ( final byte c ) {
} else if ( obj instanceof byte [] ) { return decode ( ( byte [] ) obj ) ; } else { throw new DecoderException ( lr_2 + obj . getClass () . getName () + lr_4 ) ; MST[experimental.NakedReceiverMutator]MSP[] } }
} else if ( obj instanceof byte [] ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return decode ( ( byte [] ) obj ) ; } else { throw new DecoderException ( lr_2 + obj . getClass () . getName () + lr_4 ) ; } }
final int l = Utils . digit16 ( bytes [ ++ i ] ) ; MST[IncrementsMutator]MSP[] buffer . put ( (byte) ( ( u << 4 ) + l ) ) ; } catch ( final ArrayIndexOutOfBoundsException e ) { throw new DecoderException ( lr_1 , e ) ; }
final char hex1 = Utils . hexDigit ( bb >> 4 ) ; MST[rv.UOI2Mutator]MSP[] final char hex2 = Utils . hexDigit ( bb ) ; buffer . put ( ESCAPE_CHAR ) ; buffer . put ( ( byte ) hex1 ) ;
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { MST[rv.ABSMutator]MSP[] if ( b == ' ' ) { return true ; } } return false ; } private boolean canEncode ( final byte c ) {
} else { if ( plusForSpace && b == '+' ) { MST[rv.UOI4Mutator]MSP[] buffer . put ( ( byte ) ' ' ) ; } else { buffer . put ( b ) ; } } } return buffer . array () ; }
return c >= 0 ; MST[rv.CRCR3Mutator]MSP[] } @Override public byte [] decode ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { return null ; } final ByteBuffer buffer = ByteBuffer . allocate ( expectedDecodingBytes ( bytes ) ) ;
final int l = Utils . digit16 ( bytes [ ++ i ] ) ; buffer . put ( (byte) ( ( u << 4 ) + l ) ) ; MST[rv.UOI1Mutator]MSP[] } catch ( final ArrayIndexOutOfBoundsException e ) { throw new DecoderException ( lr_1 , e ) ; }
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; MST[rv.CRCR1Mutator]MSP[] for ( int i = 0 ; i < bytes . length ; ) { final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ;
byteCount ++ ; } return byteCount ; MST[PrimitiveReturnsMutator]MSP[] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( obj == null ) { return null ; } else if ( obj instanceof byte [] ) { return encode ( ( byte [] ) obj ) ;
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { MST[rv.UOI4Mutator]MSP[] if ( b == ' ' ) { return true ; } } return false ; } private boolean canEncode ( final byte c ) {
return doEncode ( bytes , expectedEncodingBytes , willEncode ) ; } return bytes ; } private byte [] doEncode ( final byte [] bytes , final int expectedLength , final boolean willEncode ) { final ByteBuffer buffer = ByteBuffer . allocate ( expectedLength ) ; MST[rv.UOI4Mutator]MSP[]
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; MST[rv.CRCR4Mutator]MSP[] } return byteCount ; }
this . alwaysEncodeChars . set ( b ) ; if ( b < alwaysEncodeCharsMin ) { alwaysEncodeCharsMin = b ; } if ( b > alwaysEncodeCharsMax ) { MST[rv.UOI1Mutator]MSP[] alwaysEncodeCharsMax = b ; } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
return c >= 0 ; MST[rv.ROR3Mutator]MSP[] } @Override public byte [] decode ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { return null ; } final ByteBuffer buffer = ByteBuffer . allocate ( expectedDecodingBytes ( bytes ) ) ;
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) { MST[NonVoidMethodCallMutator]MSP[]
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[BooleanTrueReturnValsMutator]MSP[] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
this . alwaysEncodeChars . set ( b ) ; if ( b < alwaysEncodeCharsMin ) { MST[rv.UOI2Mutator]MSP[] alwaysEncodeCharsMin = b ; } if ( b > alwaysEncodeCharsMax ) { alwaysEncodeCharsMax = b ; } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
this . alwaysEncodeChars . set ( b ) ; if ( b < alwaysEncodeCharsMin ) { alwaysEncodeCharsMin = b ; MST[rv.ABSMutator]MSP[] } if ( b > alwaysEncodeCharsMax ) { alwaysEncodeCharsMax = b ; } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] } private boolean isAsciiChar ( final byte c ) {
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; MST[rv.ROR3Mutator]MSP[] } private boolean isAsciiChar ( final byte c ) {
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; MST[rv.ROR5Mutator]MSP[] } private boolean isAsciiChar ( final byte c ) {
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; MST[ConditionalsBoundaryMutator]MSP[] } private boolean isAsciiChar ( final byte c ) {
for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { MST[rv.CRCR6Mutator]MSP[] try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
} else { throw new EncoderException ( lr_2 + obj . getClass () . getName () + lr_3 ) ; MST[NonVoidMethodCallMutator]MSP[] } } @Override public Object decode ( final Object obj ) throws DecoderException { if ( obj == null ) { return null ;
return c >= 0 ; MST[InlineConstantMutator]MSP[] } @Override public byte [] decode ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { return null ; } final ByteBuffer buffer = ByteBuffer . allocate ( expectedDecodingBytes ( bytes ) ) ;
this . alwaysEncodeChars . set ( b ) ; if ( b < alwaysEncodeCharsMin ) { alwaysEncodeCharsMin = b ; } if ( b > alwaysEncodeCharsMax ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[] alwaysEncodeCharsMax = b ; } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { if ( b == ' ' ) { MST[rv.CRCR6Mutator]MSP[] return true ; } } return false ; } private boolean canEncode ( final byte c ) {
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ; MST[rv.ROR4Mutator]MSP[]
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { if ( b == ' ' ) { MST[rv.CRCR1Mutator]MSP[] return true ; } } return false ; } private boolean canEncode ( final byte c ) {
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[NonVoidMethodCallMutator]MSP[] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; MST[NonVoidMethodCallMutator]MSP[] } return byteCount ; }
for ( int i = 0 ; i < bytes . length ; i ++ ) { MST[experimental.RemoveIncrementsMutator]MSP[] final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ;
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[rv.UOI2Mutator]MSP[] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[rv.UOI4Mutator]MSP[] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
byteCount ++ ; } return byteCount ; MST[rv.UOI2Mutator]MSP[] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( obj == null ) { return null ; } else if ( obj instanceof byte [] ) { return encode ( ( byte [] ) obj ) ;
this . alwaysEncodeChars . set ( b ) ; if ( b < alwaysEncodeCharsMin ) { MST[ConditionalsBoundaryMutator]MSP[] alwaysEncodeCharsMin = b ; } if ( b > alwaysEncodeCharsMax ) { alwaysEncodeCharsMax = b ; } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
buffer . put ( ( byte ) hex2 ) ; } else { if ( plusForSpace && b == ' ' ) { buffer . put ( ( byte ) '+' ) ; MST[InlineConstantMutator]MSP[] } else { buffer . put ( b ) ; } } }
for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { MST[rv.ROR1Mutator]MSP[] try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
final char hex1 = Utils . hexDigit ( bb >> 4 ) ; final char hex2 = Utils . hexDigit ( bb ) ; buffer . put ( ESCAPE_CHAR ) ; buffer . put ( ( byte ) hex1 ) ; MST[rv.UOI4Mutator]MSP[]
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ; MST[rv.CRCR2Mutator]MSP[]
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { MST[ConditionalsBoundaryMutator]MSP[] final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ;
return buffer . array () ; MST[NonVoidMethodCallMutator]MSP[] } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; } return byteCount ; }
for ( int i = 0 ; i < bytes . length ; i ++ ) { MST[rv.ROR3Mutator]MSP[] final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
this . alwaysEncodeChars . set ( b ) ; if ( b < alwaysEncodeCharsMin ) { MST[rv.ROR5Mutator]MSP[] alwaysEncodeCharsMin = b ; } if ( b > alwaysEncodeCharsMax ) { alwaysEncodeCharsMax = b ; } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { MST[rv.UOI2Mutator]MSP[] if ( b == ' ' ) { return true ; } } return false ; } private boolean canEncode ( final byte c ) {
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; MST[rv.UOI2Mutator]MSP[] } private boolean isAsciiChar ( final byte c ) {
final char hex1 = Utils . hexDigit ( bb >> 4 ) ; final char hex2 = Utils . hexDigit ( bb ) ; buffer . put ( ESCAPE_CHAR ) ; MST[InlineConstantMutator]MSP[] buffer . put ( ( byte ) hex1 ) ;
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; MST[rv.UOI2Mutator]MSP[] } return byteCount ; }
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; MST[rv.CRCR1Mutator]MSP[] } private void insertAlwaysEncodeChar ( final byte b ) {
final char hex1 = Utils . hexDigit ( bb >> 4 ) ; final char hex2 = Utils . hexDigit ( bb ) ; buffer . put ( ESCAPE_CHAR ) ; MST[rv.CRCR3Mutator]MSP[] buffer . put ( ( byte ) hex1 ) ;
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { MST[rv.ROR4Mutator]MSP[] byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
buffer . put ( ( byte ) hex2 ) ; } else { if ( plusForSpace && b == ' ' ) { MST[rv.ROR1Mutator]MSP[] buffer . put ( ( byte ) '+' ) ; } else { buffer . put ( b ) ; } } }
final char hex1 = Utils . hexDigit ( bb >> 4 ) ; MST[rv.CRCR4Mutator]MSP[] final char hex2 = Utils . hexDigit ( bb ) ; buffer . put ( ESCAPE_CHAR ) ; buffer . put ( ( byte ) hex1 ) ;
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { MST[rv.UOI4Mutator]MSP[] insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; MST[rv.UOI1Mutator]MSP[] if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) {
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[rv.ROR1Mutator]MSP[] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { MST[rv.ROR1Mutator]MSP[] bb = (byte) ( 256 + bb ) ; }
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { MST[rv.ROR5Mutator]MSP[] final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ;
byteCount ++ ; } return byteCount ; } @Override public Object encode ( final Object obj ) throws EncoderException { if ( obj == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return null ; } else if ( obj instanceof byte [] ) { return encode ( ( byte [] ) obj ) ;
buffer . put ( ( byte ) hex2 ) ; } else { if ( plusForSpace && b == ' ' ) { buffer . put ( ( byte ) '+' ) ; } else { buffer . put ( b ) ; MST[rv.UOI4Mutator]MSP[] } } }
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; MST[rv.CRCR6Mutator]MSP[] } return byteCount ; }
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; MST[rv.ROR4Mutator]MSP[] if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) {
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { MST[rv.UOI2Mutator]MSP[] final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ;
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { MST[rv.CRCR5Mutator]MSP[] if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { MST[rv.UOI3Mutator]MSP[] if ( b == ' ' ) { return true ; } } return false ; } private boolean canEncode ( final byte c ) {
final int l = Utils . digit16 ( bytes [ ++ i ] ) ; buffer . put ( (byte) ( ( u << 4 ) + l ) ) ; MST[rv.CRCR2Mutator]MSP[] } catch ( final ArrayIndexOutOfBoundsException e ) { throw new DecoderException ( lr_1 , e ) ; }
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { MST[rv.CRCR4Mutator]MSP[] if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { MST[rv.UOI4Mutator]MSP[] try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { MST[rv.UOI4Mutator]MSP[] byteCount += canEncode ( b ) ? 3 : 1 ; } return byteCount ; }
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[rv.CRCR3Mutator]MSP[] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { MST[rv.CRCR2Mutator]MSP[] if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
} else { if ( plusForSpace && b == '+' ) { MST[rv.CRCR3Mutator]MSP[] buffer . put ( ( byte ) ' ' ) ; } else { buffer . put ( b ) ; } } } return buffer . array () ; }
for ( final byte b : bytes ) { MST[rv.UOI1Mutator]MSP[] if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ; MST[rv.UOI1Mutator]MSP[] if ( b == ESCAPE_CHAR ) { try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; MST[rv.CRCR3Mutator]MSP[] }
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
} else { throw new EncoderException ( lr_2 + obj . getClass () . getName () + lr_3 ) ; MST[NonVoidMethodCallMutator]MSP[] } } @Override public Object decode ( final Object obj ) throws DecoderException { if ( obj == null ) { return null ;
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { MST[rv.UOI4Mutator]MSP[] final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ;
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; MST[rv.CRCR5Mutator]MSP[] } private boolean isAsciiChar ( final byte c ) {
} else { if ( plusForSpace && b == '+' ) { buffer . put ( ( byte ) ' ' ) ; } else { buffer . put ( b ) ; MST[experimental.NakedReceiverMutator]MSP[] } } } return buffer . array () ; }
for ( final byte b : bytes ) { MST[rv.ABSMutator]MSP[] if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
for ( int i = 0 ; i < bytes . length ; i ++ ) { MST[NegateConditionalsMutator]MSP[] final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; MST[rv.ABSMutator]MSP[] } return byteCount ; }
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; MST[rv.ABSMutator]MSP[] } private boolean isAsciiChar ( final byte c ) {
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ; MST[rv.UOI3Mutator]MSP[]
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) { MST[rv.ROR1Mutator]MSP[]
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { MST[rv.UOI3Mutator]MSP[] byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
buffer . put ( ( byte ) hex2 ) ; } else { if ( plusForSpace && b == ' ' ) { MST[rv.ROR4Mutator]MSP[] buffer . put ( ( byte ) '+' ) ; } else { buffer . put ( b ) ; } } }
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { MST[rv.ABSMutator]MSP[] bb = (byte) ( 256 + bb ) ; }
final char hex1 = Utils . hexDigit ( bb >> 4 ) ; MST[rv.UOI1Mutator]MSP[] final char hex2 = Utils . hexDigit ( bb ) ; buffer . put ( ESCAPE_CHAR ) ; buffer . put ( ( byte ) hex1 ) ;
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; MST[rv.CRCR6Mutator]MSP[] for ( int i = 0 ; i < bytes . length ; ) { final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ;
} else if ( obj instanceof byte [] ) { MST[rv.ROR4Mutator]MSP[] return decode ( ( byte [] ) obj ) ; } else { throw new DecoderException ( lr_2 + obj . getClass () . getName () + lr_4 ) ; } }
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { MST[rv.UOI1Mutator]MSP[] if ( b == ' ' ) { return true ; } } return false ; } private boolean canEncode ( final byte c ) {
final int l = Utils . digit16 ( bytes [ ++ i ] ) ; MST[rv.ABSMutator]MSP[] buffer . put ( (byte) ( ( u << 4 ) + l ) ) ; } catch ( final ArrayIndexOutOfBoundsException e ) { throw new DecoderException ( lr_1 , e ) ; }
this . alwaysEncodeChars . set ( b ) ; if ( b < alwaysEncodeCharsMin ) { alwaysEncodeCharsMin = b ; } if ( b > alwaysEncodeCharsMax ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] alwaysEncodeCharsMax = b ; } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
} else { if ( plusForSpace && b == '+' ) { buffer . put ( ( byte ) ' ' ) ; } else { buffer . put ( b ) ; } } } return buffer . array () ; MST[ReturnValsMutator]MSP[] }
return c >= 0 ; MST[RemoveConditionalMutator_ORDER_IF]MSP[] } @Override public byte [] decode ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { return null ; } final ByteBuffer buffer = ByteBuffer . allocate ( expectedDecodingBytes ( bytes ) ) ;
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ; MST[rv.CRCR4Mutator]MSP[]
} else if ( obj instanceof byte [] ) { return decode ( ( byte [] ) obj ) ; MST[ArgumentPropagationMutator]MSP[] } else { throw new DecoderException ( lr_2 + obj . getClass () . getName () + lr_4 ) ; } }
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; MST[InlineConstantMutator]MSP[] } return byteCount ; }
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[NegateConditionalsMutator]MSP[] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ; MST[rv.UOI4Mutator]MSP[]
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; MST[rv.CRCR6Mutator]MSP[] } private void insertAlwaysEncodeChar ( final byte b ) {
this . alwaysEncodeChars . set ( b ) ; if ( b < alwaysEncodeCharsMin ) { alwaysEncodeCharsMin = b ; MST[rv.UOI1Mutator]MSP[] } if ( b > alwaysEncodeCharsMax ) { alwaysEncodeCharsMax = b ; } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
this . alwaysEncodeChars . set ( b ) ; if ( b < alwaysEncodeCharsMin ) { alwaysEncodeCharsMin = b ; } if ( b > alwaysEncodeCharsMax ) { MST[ConditionalsBoundaryMutator]MSP[] alwaysEncodeCharsMax = b ; } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { MST[rv.CRCR1Mutator]MSP[] if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
} else { if ( plusForSpace && b == '+' ) { buffer . put ( ( byte ) ' ' ) ; } else { buffer . put ( b ) ; MST[rv.ABSMutator]MSP[] } } } return buffer . array () ; }
for ( int i = 0 ; i < bytes . length ; i ++ ) { MST[rv.ROR5Mutator]MSP[] final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { MST[rv.UOI4Mutator]MSP[] if ( b == ' ' ) { return true ; } } return false ; } private boolean canEncode ( final byte c ) {
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { MST[rv.CRCR4Mutator]MSP[] if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
for ( int i = 0 ; i < bytes . length ; i ++ ) { MST[rv.CRCR6Mutator]MSP[] final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; MST[rv.UOI2Mutator]MSP[] } private boolean isAsciiChar ( final byte c ) {
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; MST[rv.UOI2Mutator]MSP[] } return byteCount ; }
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; MST[NegateConditionalsMutator]MSP[] } private boolean isAsciiChar ( final byte c ) {
this . alwaysEncodeChars . set ( b ) ; if ( b < alwaysEncodeCharsMin ) { alwaysEncodeCharsMin = b ; MST[experimental.MemberVariableMutator]MSP[] } if ( b > alwaysEncodeCharsMax ) { alwaysEncodeCharsMax = b ; } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { MST[experimental.MemberVariableMutator]MSP[] if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
for ( final byte b : bytes ) { MST[rv.UOI2Mutator]MSP[] if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
final char hex1 = Utils . hexDigit ( bb >> 4 ) ; MST[rv.CRCR1Mutator]MSP[] final char hex2 = Utils . hexDigit ( bb ) ; buffer . put ( ESCAPE_CHAR ) ; buffer . put ( ( byte ) hex1 ) ;
buffer . put ( ( byte ) hex2 ) ; } else { if ( plusForSpace && b == ' ' ) { MST[rv.ROR3Mutator]MSP[] buffer . put ( ( byte ) '+' ) ; } else { buffer . put ( b ) ; } } }
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { MST[rv.UOI1Mutator]MSP[] insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { final byte b = bytes [ i ] ; MST[rv.ABSMutator]MSP[] i += b == ESCAPE_CHAR ? 3 : 1 ;
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; MST[ReturnValsMutator]MSP[] } private boolean isAsciiChar ( final byte c ) {
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { MST[rv.ROR3Mutator]MSP[] bb = (byte) ( 256 + bb ) ; }
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { MST[rv.UOI2Mutator]MSP[] bb = (byte) ( 256 + bb ) ; }
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { MST[InlineConstantMutator]MSP[] if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
} else { throw new EncoderException ( lr_2 + obj . getClass () . getName () + lr_3 ) ; MST[ConstructorCallMutator]MSP[] } } @Override public Object decode ( final Object obj ) throws DecoderException { if ( obj == null ) { return null ;
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; MST[rv.CRCR4Mutator]MSP[] } return byteCount ; }
buffer . put ( ( byte ) hex2 ) ; } else { if ( plusForSpace && b == ' ' ) { buffer . put ( ( byte ) '+' ) ; } else { buffer . put ( b ) ; MST[NonVoidMethodCallMutator]MSP[] } } }
final int l = Utils . digit16 ( bytes [ ++ i ] ) ; MST[rv.UOI2Mutator]MSP[] buffer . put ( (byte) ( ( u << 4 ) + l ) ) ; } catch ( final ArrayIndexOutOfBoundsException e ) { throw new DecoderException ( lr_1 , e ) ; }
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[rv.UOI3Mutator]MSP[] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[rv.CRCR6Mutator]MSP[] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
final int l = Utils . digit16 ( bytes [ ++ i ] ) ; buffer . put ( (byte) ( ( u << 4 ) + l ) ) ; MST[rv.CRCR4Mutator]MSP[] } catch ( final ArrayIndexOutOfBoundsException e ) { throw new DecoderException ( lr_1 , e ) ; }
buffer . put ( ( byte ) hex2 ) ; } else { if ( plusForSpace && b == ' ' ) { MST[InlineConstantMutator]MSP[] buffer . put ( ( byte ) '+' ) ; } else { buffer . put ( b ) ; } } }
} else { if ( plusForSpace && b == '+' ) { buffer . put ( ( byte ) ' ' ) ; } else { buffer . put ( b ) ; MST[rv.UOI2Mutator]MSP[] } } } return buffer . array () ; }
return c >= 0 ; MST[rv.ROR4Mutator]MSP[] } @Override public byte [] decode ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { return null ; } final ByteBuffer buffer = ByteBuffer . allocate ( expectedDecodingBytes ( bytes ) ) ;
this . alwaysEncodeChars . set ( b ) ; if ( b < alwaysEncodeCharsMin ) { alwaysEncodeCharsMin = b ; } if ( b > alwaysEncodeCharsMax ) { MST[rv.UOI2Mutator]MSP[] alwaysEncodeCharsMax = b ; } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] } private boolean isAsciiChar ( final byte c ) {
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { MST[rv.CRCR5Mutator]MSP[] if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
final int l = Utils . digit16 ( bytes [ ++ i ] ) ; buffer . put ( (byte) ( ( u << 4 ) + l ) ) ; MST[rv.UOI4Mutator]MSP[] } catch ( final ArrayIndexOutOfBoundsException e ) { throw new DecoderException ( lr_1 , e ) ; }
} else { throw new EncoderException ( lr_2 + obj . getClass () . getName () + lr_3 ) ; MST[NonVoidMethodCallMutator]MSP[] } } @Override public Object decode ( final Object obj ) throws DecoderException { if ( obj == null ) { return null ;
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { if ( b == ' ' ) { return true ; MST[rv.CRCR3Mutator]MSP[] } } return false ; } private boolean canEncode ( final byte c ) {
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; MST[ConditionalsBoundaryMutator]MSP[] } private boolean isAsciiChar ( final byte c ) {
return doEncode ( bytes , expectedEncodingBytes , willEncode ) ; MST[rv.UOI3Mutator]MSP[] } return bytes ; } private byte [] doEncode ( final byte [] bytes , final int expectedLength , final boolean willEncode ) { final ByteBuffer buffer = ByteBuffer . allocate ( expectedLength ) ;
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; MST[rv.ABSMutator]MSP[] } return byteCount ; }
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { MST[rv.ABSMutator]MSP[] insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
byteCount ++ ; } return byteCount ; MST[ReturnValsMutator]MSP[] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( obj == null ) { return null ; } else if ( obj instanceof byte [] ) { return encode ( ( byte [] ) obj ) ;
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { MST[rv.UOI2Mutator]MSP[] insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { insertAlwaysEncodeChar ( b ) ; MST[rv.UOI3Mutator]MSP[] } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { if ( b == ' ' ) { MST[rv.ROR3Mutator]MSP[] return true ; } } return false ; } private boolean canEncode ( final byte c ) {
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[rv.UOI1Mutator]MSP[] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
byteCount ++ ; } return byteCount ; MST[rv.UOI4Mutator]MSP[] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( obj == null ) { return null ; } else if ( obj instanceof byte [] ) { return encode ( ( byte [] ) obj ) ;
} else { if ( plusForSpace && b == '+' ) { MST[rv.UOI3Mutator]MSP[] buffer . put ( ( byte ) ' ' ) ; } else { buffer . put ( b ) ; } } } return buffer . array () ; }
this . alwaysEncodeChars . set ( b ) ; if ( b < alwaysEncodeCharsMin ) { MST[rv.UOI3Mutator]MSP[] alwaysEncodeCharsMin = b ; } if ( b > alwaysEncodeCharsMax ) { alwaysEncodeCharsMax = b ; } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; MST[rv.UOI4Mutator]MSP[] } private boolean isAsciiChar ( final byte c ) {
buffer . put ( ( byte ) hex2 ) ; } else { if ( plusForSpace && b == ' ' ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] buffer . put ( ( byte ) '+' ) ; } else { buffer . put ( b ) ; } } }
for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { MST[rv.ROR3Mutator]MSP[] try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ; MST[rv.CRCR4Mutator]MSP[]
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { MST[rv.UOI3Mutator]MSP[] byteCount += canEncode ( b ) ? 3 : 1 ; } return byteCount ; }
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; MST[rv.CRCR1Mutator]MSP[] if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) {
return doEncode ( bytes , expectedEncodingBytes , willEncode ) ; } return bytes ; } private byte [] doEncode ( final byte [] bytes , final int expectedLength , final boolean willEncode ) { final ByteBuffer buffer = ByteBuffer . allocate ( expectedLength ) ; MST[NonVoidMethodCallMutator]MSP[]
for ( int i = 0 ; i < bytes . length ; i ++ ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
this . alwaysEncodeChars . set ( b ) ; if ( b < alwaysEncodeCharsMin ) { MST[rv.ROR1Mutator]MSP[] alwaysEncodeCharsMin = b ; } if ( b > alwaysEncodeCharsMax ) { alwaysEncodeCharsMax = b ; } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { MST[rv.UOI1Mutator]MSP[] if ( b == ' ' ) { return true ; } } return false ; } private boolean canEncode ( final byte c ) {
byteCount ++ ; } return byteCount ; MST[rv.UOI1Mutator]MSP[] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( obj == null ) { return null ; } else if ( obj instanceof byte [] ) { return encode ( ( byte [] ) obj ) ;
final char hex1 = Utils . hexDigit ( bb >> 4 ) ; final char hex2 = Utils . hexDigit ( bb ) ; buffer . put ( ESCAPE_CHAR ) ; buffer . put ( ( byte ) hex1 ) ; MST[experimental.NakedReceiverMutator]MSP[]
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; MST[rv.UOI2Mutator]MSP[] } private boolean isAsciiChar ( final byte c ) {
buffer . put ( ( byte ) hex2 ) ; } else { if ( plusForSpace && b == ' ' ) { MST[rv.ABSMutator]MSP[] buffer . put ( ( byte ) '+' ) ; } else { buffer . put ( b ) ; } } }
} else { if ( plusForSpace && b == '+' ) { buffer . put ( ( byte ) ' ' ) ; MST[rv.CRCR4Mutator]MSP[] } else { buffer . put ( b ) ; } } } return buffer . array () ; }
} else { if ( plusForSpace && b == '+' ) { buffer . put ( ( byte ) ' ' ) ; MST[rv.CRCR1Mutator]MSP[] } else { buffer . put ( b ) ; } } } return buffer . array () ; }
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { MST[ConditionalsBoundaryMutator]MSP[] bb = (byte) ( 256 + bb ) ; }
this . alwaysEncodeChars . set ( b ) ; if ( b < alwaysEncodeCharsMin ) { alwaysEncodeCharsMin = b ; } if ( b > alwaysEncodeCharsMax ) { MST[rv.ROR5Mutator]MSP[] alwaysEncodeCharsMax = b ; } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { MST[rv.ROR1Mutator]MSP[] byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
byteCount ++ ; } return byteCount ; } @Override public Object encode ( final Object obj ) throws EncoderException { if ( obj == null ) { return null ; } else if ( obj instanceof byte [] ) { return encode ( ( byte [] ) obj ) ; MST[NonVoidMethodCallMutator]MSP[]
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { MST[rv.ROR4Mutator]MSP[] byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; MST[rv.ROR4Mutator]MSP[] } return byteCount ; }
final char hex1 = Utils . hexDigit ( bb >> 4 ) ; MST[rv.UOI4Mutator]MSP[] final char hex2 = Utils . hexDigit ( bb ) ; buffer . put ( ESCAPE_CHAR ) ; buffer . put ( ( byte ) hex1 ) ;
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[rv.ROR5Mutator]MSP[] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) { MST[NegateConditionalsMutator]MSP[]
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[rv.UOI4Mutator]MSP[] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { MST[rv.CRCR3Mutator]MSP[] final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ;
for ( int i = 0 ; i < bytes . length ; i ++ ) { MST[rv.UOI4Mutator]MSP[] final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; } return byteCount ; MST[rv.UOI2Mutator]MSP[] }
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; MST[rv.CRCR6Mutator]MSP[] if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) {
final char hex1 = Utils . hexDigit ( bb >> 4 ) ; final char hex2 = Utils . hexDigit ( bb ) ; MST[rv.ABSMutator]MSP[] buffer . put ( ESCAPE_CHAR ) ; buffer . put ( ( byte ) hex1 ) ;
final char hex1 = Utils . hexDigit ( bb >> 4 ) ; MST[NonVoidMethodCallMutator]MSP[] final char hex2 = Utils . hexDigit ( bb ) ; buffer . put ( ESCAPE_CHAR ) ; buffer . put ( ( byte ) hex1 ) ;
for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ; MST[rv.UOI3Mutator]MSP[]
return doEncode ( bytes , expectedEncodingBytes , willEncode ) ; MST[rv.ABSMutator]MSP[] } return bytes ; } private byte [] doEncode ( final byte [] bytes , final int expectedLength , final boolean willEncode ) { final ByteBuffer buffer = ByteBuffer . allocate ( expectedLength ) ;
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ; MST[rv.CRCR1Mutator]MSP[]
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; MST[rv.ABSMutator]MSP[] } private boolean isAsciiChar ( final byte c ) {
for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { MST[rv.UOI1Mutator]MSP[] try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; MST[rv.AOR3Mutator]MSP[] }
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { MST[rv.UOI2Mutator]MSP[] byteCount += canEncode ( b ) ? 3 : 1 ; } return byteCount ; }
} else { if ( plusForSpace && b == '+' ) { MST[rv.ROR5Mutator]MSP[] buffer . put ( ( byte ) ' ' ) ; } else { buffer . put ( b ) ; } } } return buffer . array () ; }
for ( int i = 0 ; i < bytes . length ; i ++ ) { MST[rv.UOI2Mutator]MSP[] final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; MST[rv.CRCR5Mutator]MSP[] for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; } return byteCount ; }
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; MST[rv.CRCR3Mutator]MSP[] for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; } return byteCount ; }
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { final byte b = bytes [ i ] ; MST[rv.UOI3Mutator]MSP[] i += b == ESCAPE_CHAR ? 3 : 1 ;
for ( final byte b : bytes ) { MST[rv.UOI1Mutator]MSP[] if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
this . alwaysEncodeChars . set ( b ) ; if ( b < alwaysEncodeCharsMin ) { alwaysEncodeCharsMin = b ; } if ( b > alwaysEncodeCharsMax ) { MST[rv.UOI4Mutator]MSP[] alwaysEncodeCharsMax = b ; } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) { MST[rv.ROR1Mutator]MSP[]
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) { MST[rv.ROR3Mutator]MSP[]
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { MST[rv.UOI3Mutator]MSP[] insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
buffer . put ( ( byte ) hex2 ) ; } else { if ( plusForSpace && b == ' ' ) { MST[rv.CRCR4Mutator]MSP[] buffer . put ( ( byte ) '+' ) ; } else { buffer . put ( b ) ; } } }
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) { MST[rv.UOI4Mutator]MSP[]
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) { MST[rv.UOI2Mutator]MSP[]
buffer . put ( ( byte ) hex2 ) ; } else { if ( plusForSpace && b == ' ' ) { buffer . put ( ( byte ) '+' ) ; MST[rv.CRCR5Mutator]MSP[] } else { buffer . put ( b ) ; } } }
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { final byte b = bytes [ i ] ; MST[rv.UOI1Mutator]MSP[] i += b == ESCAPE_CHAR ? 3 : 1 ;
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[rv.ROR1Mutator]MSP[] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
buffer . put ( ( byte ) hex2 ) ; } else { if ( plusForSpace && b == ' ' ) { buffer . put ( ( byte ) '+' ) ; } else { buffer . put ( b ) ; MST[rv.UOI1Mutator]MSP[] } } }
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; MST[rv.UOI4Mutator]MSP[] } private boolean isAsciiChar ( final byte c ) {
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { if ( b == ' ' ) { MST[rv.UOI3Mutator]MSP[] return true ; } } return false ; } private boolean canEncode ( final byte c ) {
return c >= 0 ; MST[rv.CRCR4Mutator]MSP[] } @Override public byte [] decode ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { return null ; } final ByteBuffer buffer = ByteBuffer . allocate ( expectedDecodingBytes ( bytes ) ) ;
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; MST[InlineConstantMutator]MSP[] } return byteCount ; }
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { if ( b == ' ' ) { MST[rv.UOI1Mutator]MSP[] return true ; } } return false ; } private boolean canEncode ( final byte c ) {
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; MST[rv.AOR2Mutator]MSP[] } return byteCount ; }
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; MST[rv.CRCR3Mutator]MSP[] if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) {
this . alwaysEncodeChars . set ( b ) ; if ( b < alwaysEncodeCharsMin ) { alwaysEncodeCharsMin = b ; } if ( b > alwaysEncodeCharsMax ) { MST[rv.ABSMutator]MSP[] alwaysEncodeCharsMax = b ; } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
final char hex1 = Utils . hexDigit ( bb >> 4 ) ; final char hex2 = Utils . hexDigit ( bb ) ; buffer . put ( ESCAPE_CHAR ) ; MST[rv.CRCR5Mutator]MSP[] buffer . put ( ( byte ) hex1 ) ;
for ( int i = 0 ; i < bytes . length ; i ++ ) { MST[rv.ABSMutator]MSP[] final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { if ( b == ' ' ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return true ; } } return false ; } private boolean canEncode ( final byte c ) {
buffer . put ( ( byte ) hex2 ) ; MST[rv.UOI4Mutator]MSP[] } else { if ( plusForSpace && b == ' ' ) { buffer . put ( ( byte ) '+' ) ; } else { buffer . put ( b ) ; } } }
for ( int i = 0 ; i < bytes . length ; i ++ ) { MST[rv.CRCR3Mutator]MSP[] final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
for ( int i = 0 ; i < bytes . length ; i ++ ) { MST[ConditionalsBoundaryMutator]MSP[] final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) { MST[rv.ABSMutator]MSP[]
return doEncode ( bytes , expectedEncodingBytes , willEncode ) ; MST[rv.UOI2Mutator]MSP[] } return bytes ; } private byte [] doEncode ( final byte [] bytes , final int expectedLength , final boolean willEncode ) { final ByteBuffer buffer = ByteBuffer . allocate ( expectedLength ) ;
} else { if ( plusForSpace && b == '+' ) { MST[NegateConditionalsMutator]MSP[] buffer . put ( ( byte ) ' ' ) ; } else { buffer . put ( b ) ; } } } return buffer . array () ; }
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; MST[rv.CRCR3Mutator]MSP[] } private void insertAlwaysEncodeChar ( final byte b ) {
final char hex1 = Utils . hexDigit ( bb >> 4 ) ; MST[rv.CRCR6Mutator]MSP[] final char hex2 = Utils . hexDigit ( bb ) ; buffer . put ( ESCAPE_CHAR ) ; buffer . put ( ( byte ) hex1 ) ;
} else { throw new EncoderException ( lr_2 + obj . getClass () . getName () + lr_3 ) ; } } @Override public Object decode ( final Object obj ) throws DecoderException { if ( obj == null ) { MST[rv.ROR5Mutator]MSP[] return null ;
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ; MST[rv.UOI4Mutator]MSP[]
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; MST[rv.ROR2Mutator]MSP[] } return byteCount ; }
} else { if ( plusForSpace && b == '+' ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] buffer . put ( ( byte ) ' ' ) ; } else { buffer . put ( b ) ; } } } return buffer . array () ; }
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[rv.ROR3Mutator]MSP[] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] bb = (byte) ( 256 + bb ) ; }
} else { if ( plusForSpace && b == '+' ) { buffer . put ( ( byte ) ' ' ) ; } else { buffer . put ( b ) ; } } } return buffer . array () ; MST[NullReturnValsMutator]MSP[] }
for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ; MST[IncrementsMutator]MSP[]
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; MST[rv.UOI3Mutator]MSP[] if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) {
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { if ( b == ' ' ) { MST[NegateConditionalsMutator]MSP[] return true ; } } return false ; } private boolean canEncode ( final byte c ) {
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { MST[rv.CRCR6Mutator]MSP[] if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
final int l = Utils . digit16 ( bytes [ ++ i ] ) ; buffer . put ( (byte) ( ( u << 4 ) + l ) ) ; MST[experimental.NakedReceiverMutator]MSP[] } catch ( final ArrayIndexOutOfBoundsException e ) { throw new DecoderException ( lr_1 , e ) ; }
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[rv.CRCR6Mutator]MSP[] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
byteCount ++ ; } return byteCount ; } @Override public Object encode ( final Object obj ) throws EncoderException { if ( obj == null ) { return null ; } else if ( obj instanceof byte [] ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return encode ( ( byte [] ) obj ) ;
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; MST[rv.ROR2Mutator]MSP[] } private boolean isAsciiChar ( final byte c ) {
final char hex1 = Utils . hexDigit ( bb >> 4 ) ; final char hex2 = Utils . hexDigit ( bb ) ; buffer . put ( ESCAPE_CHAR ) ; buffer . put ( ( byte ) hex1 ) ; MST[rv.UOI1Mutator]MSP[]
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; MST[rv.ABSMutator]MSP[] } private boolean isAsciiChar ( final byte c ) {
} else { throw new EncoderException ( lr_2 + obj . getClass () . getName () + lr_3 ) ; } } @Override public Object decode ( final Object obj ) throws DecoderException { if ( obj == null ) { return null ; MST[ReturnValsMutator]MSP[]
buffer . put ( ( byte ) hex2 ) ; MST[rv.ABSMutator]MSP[] } else { if ( plusForSpace && b == ' ' ) { buffer . put ( ( byte ) '+' ) ; } else { buffer . put ( b ) ; } } }
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { MST[rv.CRCR3Mutator]MSP[] if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
buffer . put ( ( byte ) hex2 ) ; } else { if ( plusForSpace && b == ' ' ) { MST[NegateConditionalsMutator]MSP[] buffer . put ( ( byte ) '+' ) ; } else { buffer . put ( b ) ; } } }
} else if ( obj instanceof byte [] ) { return decode ( ( byte [] ) obj ) ; } else { throw new DecoderException ( lr_2 + obj . getClass () . getName () + lr_4 ) ; MST[ConstructorCallMutator]MSP[] } }
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { if ( b == ' ' ) { return true ; MST[ReturnValsMutator]MSP[] } } return false ; } private boolean canEncode ( final byte c ) {
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { MST[rv.ABSMutator]MSP[] byteCount += canEncode ( b ) ? 3 : 1 ; } return byteCount ; }
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { if ( b == ' ' ) { return true ; MST[rv.CRCR5Mutator]MSP[] } } return false ; } private boolean canEncode ( final byte c ) {
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[NonVoidMethodCallMutator]MSP[] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; MST[InlineConstantMutator]MSP[] } private boolean isAsciiChar ( final byte c ) {
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { MST[rv.ABSMutator]MSP[] insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { MST[NegateConditionalsMutator]MSP[] bb = (byte) ( 256 + bb ) ; }
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { MST[rv.UOI2Mutator]MSP[] insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ; MST[rv.ROR1Mutator]MSP[]
buffer . put ( ( byte ) hex2 ) ; } else { if ( plusForSpace && b == ' ' ) { MST[rv.UOI2Mutator]MSP[] buffer . put ( ( byte ) '+' ) ; } else { buffer . put ( b ) ; } } }
return doEncode ( bytes , expectedEncodingBytes , willEncode ) ; } return bytes ; MST[ReturnValsMutator]MSP[] } private byte [] doEncode ( final byte [] bytes , final int expectedLength , final boolean willEncode ) { final ByteBuffer buffer = ByteBuffer . allocate ( expectedLength ) ;
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { if ( b == ' ' ) { MST[rv.CRCR3Mutator]MSP[] return true ; } } return false ; } private boolean canEncode ( final byte c ) {
for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { MST[rv.CRCR3Mutator]MSP[] try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { if ( b == ' ' ) { return true ; } } return false ; MST[InlineConstantMutator]MSP[] } private boolean canEncode ( final byte c ) {
final int l = Utils . digit16 ( bytes [ ++ i ] ) ; buffer . put ( (byte) ( ( u << 4 ) + l ) ) ; MST[rv.ABSMutator]MSP[] } catch ( final ArrayIndexOutOfBoundsException e ) { throw new DecoderException ( lr_1 , e ) ; }
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; MST[rv.ROR1Mutator]MSP[] if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) {
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; MST[rv.UOI4Mutator]MSP[] } private boolean isAsciiChar ( final byte c ) {
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { MST[rv.ROR2Mutator]MSP[] final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ;
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
return c >= 0 ; MST[rv.UOI3Mutator]MSP[] } @Override public byte [] decode ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { return null ; } final ByteBuffer buffer = ByteBuffer . allocate ( expectedDecodingBytes ( bytes ) ) ;
this . alwaysEncodeChars . set ( b ) ; MST[rv.UOI3Mutator]MSP[] if ( b < alwaysEncodeCharsMin ) { alwaysEncodeCharsMin = b ; } if ( b > alwaysEncodeCharsMax ) { alwaysEncodeCharsMax = b ; } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
return doEncode ( bytes , expectedEncodingBytes , willEncode ) ; } return bytes ; } private byte [] doEncode ( final byte [] bytes , final int expectedLength , final boolean willEncode ) { final ByteBuffer buffer = ByteBuffer . allocate ( expectedLength ) ; MST[rv.UOI1Mutator]MSP[]
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { if ( b == ' ' ) { MST[rv.ROR5Mutator]MSP[] return true ; } } return false ; } private boolean canEncode ( final byte c ) {
final char hex1 = Utils . hexDigit ( bb >> 4 ) ; final char hex2 = Utils . hexDigit ( bb ) ; MST[rv.UOI2Mutator]MSP[] buffer . put ( ESCAPE_CHAR ) ; buffer . put ( ( byte ) hex1 ) ;
for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { MST[NegateConditionalsMutator]MSP[] try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { MST[rv.UOI3Mutator]MSP[] byteCount += canEncode ( b ) ? 3 : 1 ; } return byteCount ; }
} else { if ( plusForSpace && b == '+' ) { MST[rv.ROR4Mutator]MSP[] buffer . put ( ( byte ) ' ' ) ; } else { buffer . put ( b ) ; } } } return buffer . array () ; }
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { MST[rv.CRCR2Mutator]MSP[] if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
return doEncode ( bytes , expectedEncodingBytes , willEncode ) ; } return bytes ; MST[NullReturnValsMutator]MSP[] } private byte [] doEncode ( final byte [] bytes , final int expectedLength , final boolean willEncode ) { final ByteBuffer buffer = ByteBuffer . allocate ( expectedLength ) ;
this . alwaysEncodeChars . set ( b ) ; if ( b < alwaysEncodeCharsMin ) { alwaysEncodeCharsMin = b ; } if ( b > alwaysEncodeCharsMax ) { MST[rv.ABSMutator]MSP[] alwaysEncodeCharsMax = b ; } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) { MST[rv.ROR5Mutator]MSP[]
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { MST[rv.UOI4Mutator]MSP[] byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { MST[experimental.MemberVariableMutator]MSP[] if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { MST[rv.ROR1Mutator]MSP[] byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; MST[rv.CRCR3Mutator]MSP[] for ( int i = 0 ; i < bytes . length ; ) { final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ;
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ; MST[rv.ABSMutator]MSP[]
return c >= 0 ; MST[rv.CRCR1Mutator]MSP[] } @Override public byte [] decode ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { return null ; } final ByteBuffer buffer = ByteBuffer . allocate ( expectedDecodingBytes ( bytes ) ) ;
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { MST[InlineConstantMutator]MSP[] if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; MST[rv.UOI3Mutator]MSP[] }
byteCount ++ ; } return byteCount ; } @Override public Object encode ( final Object obj ) throws EncoderException { if ( obj == null ) { return null ; } else if ( obj instanceof byte [] ) { MST[rv.ROR1Mutator]MSP[] return encode ( ( byte [] ) obj ) ;
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; MST[rv.CRCR6Mutator]MSP[] if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) {
final int l = Utils . digit16 ( bytes [ ++ i ] ) ; MST[rv.UOI1Mutator]MSP[] buffer . put ( (byte) ( ( u << 4 ) + l ) ) ; } catch ( final ArrayIndexOutOfBoundsException e ) { throw new DecoderException ( lr_1 , e ) ; }
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; MST[rv.CRCR2Mutator]MSP[] } return byteCount ; }
for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ; MST[rv.ABSMutator]MSP[]
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[] final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ;
} else { if ( plusForSpace && b == '+' ) { MST[rv.CRCR5Mutator]MSP[] buffer . put ( ( byte ) ' ' ) ; } else { buffer . put ( b ) ; } } } return buffer . array () ; }
} else if ( obj instanceof byte [] ) { return decode ( ( byte [] ) obj ) ; } else { throw new DecoderException ( lr_2 + obj . getClass () . getName () + lr_4 ) ; MST[NonVoidMethodCallMutator]MSP[] } }
for ( final byte b : bytes ) { MST[rv.UOI3Mutator]MSP[] if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
final int l = Utils . digit16 ( bytes [ ++ i ] ) ; MST[rv.UOI4Mutator]MSP[] buffer . put ( (byte) ( ( u << 4 ) + l ) ) ; } catch ( final ArrayIndexOutOfBoundsException e ) { throw new DecoderException ( lr_1 , e ) ; }
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; MST[rv.CRCR6Mutator]MSP[] for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; } return byteCount ; }
} else { if ( plusForSpace && b == '+' ) { MST[rv.ROR2Mutator]MSP[] buffer . put ( ( byte ) ' ' ) ; } else { buffer . put ( b ) ; } } } return buffer . array () ; }
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; MST[rv.AOR2Mutator]MSP[] }
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { MST[rv.UOI2Mutator]MSP[] if ( b == ' ' ) { return true ; } } return false ; } private boolean canEncode ( final byte c ) {
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; MST[rv.CRCR5Mutator]MSP[] }
for ( int i = 0 ; i < bytes . length ; i ++ ) { MST[rv.UOI1Mutator]MSP[] final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { MST[rv.UOI4Mutator]MSP[] bb = (byte) ( 256 + bb ) ; }
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; MST[rv.CRCR2Mutator]MSP[] } private boolean isAsciiChar ( final byte c ) {
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) { MST[rv.UOI1Mutator]MSP[]
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; MST[rv.CRCR6Mutator]MSP[] } private boolean isAsciiChar ( final byte c ) {
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { MST[rv.ABSMutator]MSP[] byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) { MST[rv.ROR3Mutator]MSP[]
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[rv.ROR2Mutator]MSP[] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
final char hex1 = Utils . hexDigit ( bb >> 4 ) ; MST[rv.UOI3Mutator]MSP[] final char hex2 = Utils . hexDigit ( bb ) ; buffer . put ( ESCAPE_CHAR ) ; buffer . put ( ( byte ) hex1 ) ;
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { MST[rv.ABSMutator]MSP[] final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ;
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; MST[rv.UOI4Mutator]MSP[] } private boolean isAsciiChar ( final byte c ) {
final int l = Utils . digit16 ( bytes [ ++ i ] ) ; buffer . put ( (byte) ( ( u << 4 ) + l ) ) ; MST[rv.UOI2Mutator]MSP[] } catch ( final ArrayIndexOutOfBoundsException e ) { throw new DecoderException ( lr_1 , e ) ; }
return c >= 0 ; MST[rv.CRCR6Mutator]MSP[] } @Override public byte [] decode ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { return null ; } final ByteBuffer buffer = ByteBuffer . allocate ( expectedDecodingBytes ( bytes ) ) ;
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ; MST[rv.CRCR6Mutator]MSP[]
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { MST[rv.UOI3Mutator]MSP[] if ( b == ' ' ) { return true ; } } return false ; } private boolean canEncode ( final byte c ) {
for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ; MST[rv.UOI3Mutator]MSP[] if ( b == ESCAPE_CHAR ) { try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[rv.CRCR5Mutator]MSP[] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { MST[rv.CRCR4Mutator]MSP[] if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
buffer . put ( ( byte ) hex2 ) ; } else { if ( plusForSpace && b == ' ' ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] buffer . put ( ( byte ) '+' ) ; } else { buffer . put ( b ) ; } } }
this . alwaysEncodeChars . set ( b ) ; if ( b < alwaysEncodeCharsMin ) { MST[rv.ABSMutator]MSP[] alwaysEncodeCharsMin = b ; } if ( b > alwaysEncodeCharsMax ) { alwaysEncodeCharsMax = b ; } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; MST[rv.CRCR3Mutator]MSP[] if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) {
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { MST[rv.UOI1Mutator]MSP[] byteCount += canEncode ( b ) ? 3 : 1 ; } return byteCount ; }
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; MST[rv.UOI1Mutator]MSP[] } private boolean isAsciiChar ( final byte c ) {
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
buffer . put ( ( byte ) hex2 ) ; MST[rv.UOI1Mutator]MSP[] } else { if ( plusForSpace && b == ' ' ) { buffer . put ( ( byte ) '+' ) ; } else { buffer . put ( b ) ; } } }
if ( bytes == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) {
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { MST[rv.ABSMutator]MSP[] byteCount += canEncode ( b ) ? 3 : 1 ; } return byteCount ; }
} else { if ( plusForSpace && b == '+' ) { buffer . put ( ( byte ) ' ' ) ; MST[InlineConstantMutator]MSP[] } else { buffer . put ( b ) ; } } } return buffer . array () ; }
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) { MST[rv.ROR2Mutator]MSP[]
final char hex1 = Utils . hexDigit ( bb >> 4 ) ; final char hex2 = Utils . hexDigit ( bb ) ; buffer . put ( ESCAPE_CHAR ) ; MST[rv.CRCR2Mutator]MSP[] buffer . put ( ( byte ) hex1 ) ;
} else { if ( plusForSpace && b == '+' ) { buffer . put ( ( byte ) ' ' ) ; MST[rv.CRCR6Mutator]MSP[] } else { buffer . put ( b ) ; } } } return buffer . array () ; }
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { MST[rv.ROR3Mutator]MSP[] byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { MST[rv.CRCR5Mutator]MSP[] final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ;
final int l = Utils . digit16 ( bytes [ ++ i ] ) ; buffer . put ( (byte) ( ( u << 4 ) + l ) ) ; } catch ( final ArrayIndexOutOfBoundsException e ) { throw new DecoderException ( lr_1 , e ) ; MST[ConstructorCallMutator]MSP[] }
for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ; MST[NonVoidMethodCallMutator]MSP[]
return c >= 0 ; MST[rv.UOI4Mutator]MSP[] } @Override public byte [] decode ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { return null ; } final ByteBuffer buffer = ByteBuffer . allocate ( expectedDecodingBytes ( bytes ) ) ;
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
buffer . put ( ( byte ) hex2 ) ; } else { if ( plusForSpace && b == ' ' ) { buffer . put ( ( byte ) '+' ) ; MST[rv.CRCR2Mutator]MSP[] } else { buffer . put ( b ) ; } } }
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ; MST[MathMutator]MSP[]
for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ; MST[rv.UOI2Mutator]MSP[]
} else { if ( plusForSpace && b == '+' ) { buffer . put ( ( byte ) ' ' ) ; MST[NonVoidMethodCallMutator]MSP[] } else { buffer . put ( b ) ; } } } return buffer . array () ; }
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; MST[rv.ABSMutator]MSP[] } private boolean isAsciiChar ( final byte c ) {
for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { MST[rv.ROR5Mutator]MSP[] try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
return c >= 0 ; MST[rv.ROR2Mutator]MSP[] } @Override public byte [] decode ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { return null ; } final ByteBuffer buffer = ByteBuffer . allocate ( expectedDecodingBytes ( bytes ) ) ;
byteCount ++ ; } return byteCount ; MST[rv.ABSMutator]MSP[] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( obj == null ) { return null ; } else if ( obj instanceof byte [] ) { return encode ( ( byte [] ) obj ) ;
buffer . put ( ( byte ) hex2 ) ; MST[experimental.NakedReceiverMutator]MSP[] } else { if ( plusForSpace && b == ' ' ) { buffer . put ( ( byte ) '+' ) ; } else { buffer . put ( b ) ; } } }
this . alwaysEncodeChars . set ( b ) ; if ( b < alwaysEncodeCharsMin ) { MST[rv.UOI1Mutator]MSP[] alwaysEncodeCharsMin = b ; } if ( b > alwaysEncodeCharsMax ) { alwaysEncodeCharsMax = b ; } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; MST[rv.ROR2Mutator]MSP[] } private boolean isAsciiChar ( final byte c ) {
final int l = Utils . digit16 ( bytes [ ++ i ] ) ; buffer . put ( (byte) ( ( u << 4 ) + l ) ) ; MST[InlineConstantMutator]MSP[] } catch ( final ArrayIndexOutOfBoundsException e ) { throw new DecoderException ( lr_1 , e ) ; }
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; MST[NegateConditionalsMutator]MSP[] } return byteCount ; }
this . alwaysEncodeChars . set ( b ) ; if ( b < alwaysEncodeCharsMin ) { alwaysEncodeCharsMin = b ; } if ( b > alwaysEncodeCharsMax ) { alwaysEncodeCharsMax = b ; MST[rv.ABSMutator]MSP[] } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
buffer . put ( ( byte ) hex2 ) ; MST[NonVoidMethodCallMutator]MSP[] } else { if ( plusForSpace && b == ' ' ) { buffer . put ( ( byte ) '+' ) ; } else { buffer . put ( b ) ; } } }
for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; MST[InlineConstantMutator]MSP[] for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; } return byteCount ; }
buffer . put ( ( byte ) hex2 ) ; } else { if ( plusForSpace && b == ' ' ) { MST[rv.UOI4Mutator]MSP[] buffer . put ( ( byte ) '+' ) ; } else { buffer . put ( b ) ; } } }
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; } return byteCount ; MST[ReturnValsMutator]MSP[] }
buffer . put ( ( byte ) hex2 ) ; } else { if ( plusForSpace && b == ' ' ) { MST[rv.UOI1Mutator]MSP[] buffer . put ( ( byte ) '+' ) ; } else { buffer . put ( b ) ; } } }
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { if ( b == ' ' ) { MST[rv.CRCR5Mutator]MSP[] return true ; } } return false ; } private boolean canEncode ( final byte c ) {
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { MST[rv.UOI4Mutator]MSP[] insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { MST[InlineConstantMutator]MSP[] if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; MST[rv.UOI2Mutator]MSP[] if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) {
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { MST[rv.ROR4Mutator]MSP[] final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ;
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; MST[rv.ROR3Mutator]MSP[] if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) {
this . alwaysEncodeChars . set ( b ) ; if ( b < alwaysEncodeCharsMin ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[] alwaysEncodeCharsMin = b ; } if ( b > alwaysEncodeCharsMax ) { alwaysEncodeCharsMax = b ; } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; MST[rv.CRCR5Mutator]MSP[] } return byteCount ; }
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { MST[rv.ABSMutator]MSP[] if ( b == ' ' ) { return true ; } } return false ; } private boolean canEncode ( final byte c ) {
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ; MST[rv.CRCR6Mutator]MSP[]
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { if ( alwaysEncodeCharsArray != null ) { MST[NegateConditionalsMutator]MSP[] for ( final byte b : alwaysEncodeCharsArray ) { insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { MST[rv.CRCR3Mutator]MSP[] if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
final char hex1 = Utils . hexDigit ( bb >> 4 ) ; final char hex2 = Utils . hexDigit ( bb ) ; MST[rv.UOI4Mutator]MSP[] buffer . put ( ESCAPE_CHAR ) ; buffer . put ( ( byte ) hex1 ) ;
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) {
final char hex1 = Utils . hexDigit ( bb >> 4 ) ; MST[rv.CRCR3Mutator]MSP[] final char hex2 = Utils . hexDigit ( bb ) ; buffer . put ( ESCAPE_CHAR ) ; buffer . put ( ( byte ) hex1 ) ;
byteCount ++ ; MST[IncrementsMutator]MSP[] } return byteCount ; } @Override public Object encode ( final Object obj ) throws EncoderException { if ( obj == null ) { return null ; } else if ( obj instanceof byte [] ) { return encode ( ( byte [] ) obj ) ;
this . alwaysEncodeChars . set ( b ) ; if ( b < alwaysEncodeCharsMin ) { MST[rv.ABSMutator]MSP[] alwaysEncodeCharsMin = b ; } if ( b > alwaysEncodeCharsMax ) { alwaysEncodeCharsMax = b ; } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; MST[rv.CRCR5Mutator]MSP[] } private void insertAlwaysEncodeChar ( final byte b ) {
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; MST[rv.UOI1Mutator]MSP[] } private boolean isAsciiChar ( final byte c ) {
return c >= 0 ; } @Override public byte [] decode ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { return null ; MST[ReturnValsMutator]MSP[] } final ByteBuffer buffer = ByteBuffer . allocate ( expectedDecodingBytes ( bytes ) ) ;
for ( int i = 0 ; i < bytes . length ; i ++ ) { MST[rv.ROR2Mutator]MSP[] final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
buffer . put ( ( byte ) hex2 ) ; } else { if ( plusForSpace && b == ' ' ) { MST[rv.ROR5Mutator]MSP[] buffer . put ( ( byte ) '+' ) ; } else { buffer . put ( b ) ; } } }
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { if ( b == ' ' ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return true ; } } return false ; } private boolean canEncode ( final byte c ) {
return doEncode ( bytes , expectedEncodingBytes , willEncode ) ; MST[rv.UOI4Mutator]MSP[] } return bytes ; } private byte [] doEncode ( final byte [] bytes , final int expectedLength , final boolean willEncode ) { final ByteBuffer buffer = ByteBuffer . allocate ( expectedLength ) ;
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { MST[rv.UOI3Mutator]MSP[] insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
return doEncode ( bytes , expectedEncodingBytes , willEncode ) ; MST[rv.UOI1Mutator]MSP[] } return bytes ; } private byte [] doEncode ( final byte [] bytes , final int expectedLength , final boolean willEncode ) { final ByteBuffer buffer = ByteBuffer . allocate ( expectedLength ) ;
return doEncode ( bytes , expectedEncodingBytes , willEncode ) ; MST[ReturnValsMutator]MSP[] } return bytes ; } private byte [] doEncode ( final byte [] bytes , final int expectedLength , final boolean willEncode ) { final ByteBuffer buffer = ByteBuffer . allocate ( expectedLength ) ;
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; MST[rv.UOI3Mutator]MSP[] } return byteCount ; }
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; MST[rv.AOD1Mutator]MSP[] }
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { MST[rv.ROR5Mutator]MSP[] bb = (byte) ( 256 + bb ) ; }
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[NegateConditionalsMutator]MSP[] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
final char hex1 = Utils . hexDigit ( bb >> 4 ) ; MST[InlineConstantMutator]MSP[] final char hex2 = Utils . hexDigit ( bb ) ; buffer . put ( ESCAPE_CHAR ) ; buffer . put ( ( byte ) hex1 ) ;
final int l = Utils . digit16 ( bytes [ ++ i ] ) ; buffer . put ( (byte) ( ( u << 4 ) + l ) ) ; MST[rv.CRCR6Mutator]MSP[] } catch ( final ArrayIndexOutOfBoundsException e ) { throw new DecoderException ( lr_1 , e ) ; }
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; MST[BooleanTrueReturnValsMutator]MSP[] } private boolean isAsciiChar ( final byte c ) {
} else { if ( plusForSpace && b == '+' ) { buffer . put ( ( byte ) ' ' ) ; MST[experimental.NakedReceiverMutator]MSP[] } else { buffer . put ( b ) ; } } } return buffer . array () ; }
final char hex1 = Utils . hexDigit ( bb >> 4 ) ; MST[MathMutator]MSP[] final char hex2 = Utils . hexDigit ( bb ) ; buffer . put ( ESCAPE_CHAR ) ; buffer . put ( ( byte ) hex1 ) ;
final char hex1 = Utils . hexDigit ( bb >> 4 ) ; final char hex2 = Utils . hexDigit ( bb ) ; MST[rv.UOI1Mutator]MSP[] buffer . put ( ESCAPE_CHAR ) ; buffer . put ( ( byte ) hex1 ) ;
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; MST[rv.CRCR2Mutator]MSP[] } return byteCount ; }
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[rv.UOI1Mutator]MSP[] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ; MST[rv.CRCR1Mutator]MSP[]
this . alwaysEncodeChars . set ( b ) ; if ( b < alwaysEncodeCharsMin ) { alwaysEncodeCharsMin = b ; } if ( b > alwaysEncodeCharsMax ) { MST[rv.UOI2Mutator]MSP[] alwaysEncodeCharsMax = b ; } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { if ( b == ' ' ) { return true ; } } return false ; MST[rv.CRCR1Mutator]MSP[] } private boolean canEncode ( final byte c ) {
final int l = Utils . digit16 ( bytes [ ++ i ] ) ; buffer . put ( (byte) ( ( u << 4 ) + l ) ) ; MST[rv.AOR2Mutator]MSP[] } catch ( final ArrayIndexOutOfBoundsException e ) { throw new DecoderException ( lr_1 , e ) ; }
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { if ( b == ' ' ) { return true ; } } return false ; MST[ReturnValsMutator]MSP[] } private boolean canEncode ( final byte c ) {
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { MST[rv.CRCR1Mutator]MSP[] if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { if ( b == ' ' ) { return true ; } } return false ; MST[BooleanTrueReturnValsMutator]MSP[] } private boolean canEncode ( final byte c ) {
final int l = Utils . digit16 ( bytes [ ++ i ] ) ; buffer . put ( (byte) ( ( u << 4 ) + l ) ) ; MST[MathMutator]MSP[] } catch ( final ArrayIndexOutOfBoundsException e ) { throw new DecoderException ( lr_1 , e ) ; }
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[rv.CRCR3Mutator]MSP[] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
} else if ( obj instanceof byte [] ) { return decode ( ( byte [] ) obj ) ; } else { throw new DecoderException ( lr_2 + obj . getClass () . getName () + lr_4 ) ; MST[NonVoidMethodCallMutator]MSP[] } }
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { MST[rv.UOI4Mutator]MSP[] if ( b == ' ' ) { return true ; } } return false ; } private boolean canEncode ( final byte c ) {
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; MST[rv.CRCR2Mutator]MSP[] }
} else { if ( plusForSpace && b == '+' ) { MST[rv.CRCR2Mutator]MSP[] buffer . put ( ( byte ) ' ' ) ; } else { buffer . put ( b ) ; } } } return buffer . array () ; }
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { MST[rv.UOI3Mutator]MSP[] final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ;
this . alwaysEncodeChars . set ( b ) ; if ( b < alwaysEncodeCharsMin ) { MST[rv.UOI3Mutator]MSP[] alwaysEncodeCharsMin = b ; } if ( b > alwaysEncodeCharsMax ) { alwaysEncodeCharsMax = b ; } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { byte bb = b ; MST[rv.UOI4Mutator]MSP[] if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; MST[rv.AOD2Mutator]MSP[] } return byteCount ; }
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { byte bb = b ; MST[rv.UOI2Mutator]MSP[] if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
for ( final byte b : bytes ) { MST[rv.UOI3Mutator]MSP[] if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
buffer . put ( ( byte ) hex2 ) ; } else { if ( plusForSpace && b == ' ' ) { MST[rv.ROR1Mutator]MSP[] buffer . put ( ( byte ) '+' ) ; } else { buffer . put ( b ) ; } } }
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; MST[rv.CRCR6Mutator]MSP[] } private boolean isAsciiChar ( final byte c ) {
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) { MST[rv.ROR5Mutator]MSP[]
buffer . put ( ( byte ) hex2 ) ; } else { if ( plusForSpace && b == ' ' ) { MST[rv.ROR3Mutator]MSP[] buffer . put ( ( byte ) '+' ) ; } else { buffer . put ( b ) ; } } }
buffer . put ( ( byte ) hex2 ) ; } else { if ( plusForSpace && b == ' ' ) { MST[rv.CRCR6Mutator]MSP[] buffer . put ( ( byte ) '+' ) ; } else { buffer . put ( b ) ; } } }
for ( int i = 0 ; i < bytes . length ; i ++ ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[] final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[rv.ROR2Mutator]MSP[] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
} else { if ( plusForSpace && b == '+' ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] buffer . put ( ( byte ) ' ' ) ; } else { buffer . put ( b ) ; } } } return buffer . array () ; }
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { MST[InlineConstantMutator]MSP[] if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { MST[rv.ROR2Mutator]MSP[] bb = (byte) ( 256 + bb ) ; }
buffer . put ( ( byte ) hex2 ) ; } else { if ( plusForSpace && b == ' ' ) { buffer . put ( ( byte ) '+' ) ; } else { buffer . put ( b ) ; MST[rv.UOI3Mutator]MSP[] } } }
return c >= 0 ; MST[rv.CRCR2Mutator]MSP[] } @Override public byte [] decode ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { return null ; } final ByteBuffer buffer = ByteBuffer . allocate ( expectedDecodingBytes ( bytes ) ) ;
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[rv.ROR3Mutator]MSP[] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
final int l = Utils . digit16 ( bytes [ ++ i ] ) ; buffer . put ( (byte) ( ( u << 4 ) + l ) ) ; MST[rv.CRCR1Mutator]MSP[] } catch ( final ArrayIndexOutOfBoundsException e ) { throw new DecoderException ( lr_1 , e ) ; }
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { MST[rv.UOI1Mutator]MSP[] final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ;
final char hex1 = Utils . hexDigit ( bb >> 4 ) ; MST[rv.ABSMutator]MSP[] final char hex2 = Utils . hexDigit ( bb ) ; buffer . put ( ESCAPE_CHAR ) ; buffer . put ( ( byte ) hex1 ) ;
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[NegateConditionalsMutator]MSP[] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
final int l = Utils . digit16 ( bytes [ ++ i ] ) ; buffer . put ( (byte) ( ( u << 4 ) + l ) ) ; MST[rv.CRCR3Mutator]MSP[] } catch ( final ArrayIndexOutOfBoundsException e ) { throw new DecoderException ( lr_1 , e ) ; }
byteCount ++ ; } return byteCount ; } @Override public Object encode ( final Object obj ) throws EncoderException { if ( obj == null ) { return null ; } else if ( obj instanceof byte [] ) { MST[NegateConditionalsMutator]MSP[] return encode ( ( byte [] ) obj ) ;
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; MST[rv.CRCR5Mutator]MSP[] if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) {
for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { MST[rv.UOI3Mutator]MSP[] try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ; MST[rv.ABSMutator]MSP[] if ( b == ESCAPE_CHAR ) { try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { MST[rv.UOI4Mutator]MSP[] byteCount += canEncode ( b ) ? 3 : 1 ; } return byteCount ; }
for ( final byte b : bytes ) { MST[rv.UOI2Mutator]MSP[] if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
return c >= 0 ; MST[rv.UOI1Mutator]MSP[] } @Override public byte [] decode ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { return null ; } final ByteBuffer buffer = ByteBuffer . allocate ( expectedDecodingBytes ( bytes ) ) ;
final int l = Utils . digit16 ( bytes [ ++ i ] ) ; MST[rv.UOI3Mutator]MSP[] buffer . put ( (byte) ( ( u << 4 ) + l ) ) ; } catch ( final ArrayIndexOutOfBoundsException e ) { throw new DecoderException ( lr_1 , e ) ; }
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { MST[rv.UOI3Mutator]MSP[] if ( b == ' ' ) { return true ; } } return false ; } private boolean canEncode ( final byte c ) {
for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ; MST[rv.UOI2Mutator]MSP[] if ( b == ESCAPE_CHAR ) { try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
this . alwaysEncodeChars . set ( b ) ; if ( b < alwaysEncodeCharsMin ) { MST[rv.ROR4Mutator]MSP[] alwaysEncodeCharsMin = b ; } if ( b > alwaysEncodeCharsMax ) { alwaysEncodeCharsMax = b ; } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { MST[rv.ABSMutator]MSP[] byteCount += canEncode ( b ) ? 3 : 1 ; } return byteCount ; }
for ( int i = 0 ; i < bytes . length ; i ++ ) { MST[rv.ROR4Mutator]MSP[] final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; MST[rv.UOI1Mutator]MSP[] } private boolean isAsciiChar ( final byte c ) {
for ( final byte b : bytes ) { MST[rv.ABSMutator]MSP[] if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
} else { if ( plusForSpace && b == '+' ) { buffer . put ( ( byte ) ' ' ) ; MST[rv.CRCR3Mutator]MSP[] } else { buffer . put ( b ) ; } } } return buffer . array () ; }
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) { MST[NegateConditionalsMutator]MSP[]
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { MST[rv.UOI1Mutator]MSP[] byteCount += canEncode ( b ) ? 3 : 1 ; } return byteCount ; }
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { MST[rv.ROR3Mutator]MSP[] byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ; MST[experimental.RemoveIncrementsMutator]MSP[]
buffer . put ( ( byte ) hex2 ) ; } else { if ( plusForSpace && b == ' ' ) { MST[rv.ROR2Mutator]MSP[] buffer . put ( ( byte ) '+' ) ; } else { buffer . put ( b ) ; } } }
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { MST[rv.ABSMutator]MSP[] insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
this . alwaysEncodeChars . set ( b ) ; if ( b < alwaysEncodeCharsMin ) { alwaysEncodeCharsMin = b ; } if ( b > alwaysEncodeCharsMax ) { MST[rv.ROR3Mutator]MSP[] alwaysEncodeCharsMax = b ; } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; MST[rv.UOI3Mutator]MSP[] } return byteCount ; }
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { MST[rv.UOI1Mutator]MSP[] insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
byteCount ++ ; } return byteCount ; } @Override public Object encode ( final Object obj ) throws EncoderException { if ( obj == null ) { return null ; } else if ( obj instanceof byte [] ) { MST[rv.ROR3Mutator]MSP[] return encode ( ( byte [] ) obj ) ;
this . alwaysEncodeChars . set ( b ) ; if ( b < alwaysEncodeCharsMin ) { alwaysEncodeCharsMin = b ; } if ( b > alwaysEncodeCharsMax ) { alwaysEncodeCharsMax = b ; MST[experimental.MemberVariableMutator]MSP[] } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; MST[RemoveConditionalMutator_ORDER_IF]MSP[] } private boolean isAsciiChar ( final byte c ) {
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; MST[rv.CRCR5Mutator]MSP[] for ( int i = 0 ; i < bytes . length ; ) { final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ;
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
byteCount ++ ; } return byteCount ; MST[rv.UOI3Mutator]MSP[] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( obj == null ) { return null ; } else if ( obj instanceof byte [] ) { return encode ( ( byte [] ) obj ) ;
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[rv.UOI3Mutator]MSP[] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
final char hex1 = Utils . hexDigit ( bb >> 4 ) ; final char hex2 = Utils . hexDigit ( bb ) ; buffer . put ( ESCAPE_CHAR ) ; buffer . put ( ( byte ) hex1 ) ; MST[rv.UOI3Mutator]MSP[]
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ; MST[InlineConstantMutator]MSP[]
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ; MST[rv.CRCR3Mutator]MSP[]
for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { MST[rv.ROR2Mutator]MSP[] try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
byteCount ++ ; } return byteCount ; } @Override public Object encode ( final Object obj ) throws EncoderException { if ( obj == null ) { return null ; } else if ( obj instanceof byte [] ) { return encode ( ( byte [] ) obj ) ; MST[NullReturnValsMutator]MSP[]
return doEncode ( bytes , expectedEncodingBytes , willEncode ) ; } return bytes ; } private byte [] doEncode ( final byte [] bytes , final int expectedLength , final boolean willEncode ) { final ByteBuffer buffer = ByteBuffer . allocate ( expectedLength ) ; MST[rv.ABSMutator]MSP[]
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { MST[rv.CRCR1Mutator]MSP[] if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
this . alwaysEncodeChars . set ( b ) ; if ( b < alwaysEncodeCharsMin ) { alwaysEncodeCharsMin = b ; } if ( b > alwaysEncodeCharsMax ) { MST[NegateConditionalsMutator]MSP[] alwaysEncodeCharsMax = b ; } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; MST[rv.ROR4Mutator]MSP[] } private boolean isAsciiChar ( final byte c ) {
return c >= 0 ; } @Override public byte [] decode ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { return null ; } final ByteBuffer buffer = ByteBuffer . allocate ( expectedDecodingBytes ( bytes ) ) ; MST[NonVoidMethodCallMutator]MSP[]
if ( bytes == null ) { MST[NegateConditionalsMutator]MSP[] return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) {
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { MST[rv.CRCR6Mutator]MSP[] if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { MST[NegateConditionalsMutator]MSP[] byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { if ( b == ' ' ) { return true ; MST[rv.CRCR2Mutator]MSP[] } } return false ; } private boolean canEncode ( final byte c ) {
return c >= 0 ; MST[BooleanTrueReturnValsMutator]MSP[] } @Override public byte [] decode ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { return null ; } final ByteBuffer buffer = ByteBuffer . allocate ( expectedDecodingBytes ( bytes ) ) ;
final int l = Utils . digit16 ( bytes [ ++ i ] ) ; buffer . put ( (byte) ( ( u << 4 ) + l ) ) ; MST[NonVoidMethodCallMutator]MSP[] } catch ( final ArrayIndexOutOfBoundsException e ) { throw new DecoderException ( lr_1 , e ) ; }
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { MST[rv.UOI4Mutator]MSP[] insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ; MST[rv.ROR3Mutator]MSP[]
for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { MST[rv.CRCR5Mutator]MSP[] try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; } return byteCount ; MST[rv.UOI3Mutator]MSP[] }
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; MST[rv.CRCR5Mutator]MSP[] } return byteCount ; }
} else { if ( plusForSpace && b == '+' ) { buffer . put ( ( byte ) ' ' ) ; } else { buffer . put ( b ) ; } } } return buffer . array () ; MST[NonVoidMethodCallMutator]MSP[] }
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; MST[InlineConstantMutator]MSP[] if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) {
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { MST[rv.ABSMutator]MSP[] if ( b == ' ' ) { return true ; } } return false ; } private boolean canEncode ( final byte c ) {
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) { MST[NegateConditionalsMutator]MSP[]
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; } return byteCount ; MST[rv.ABSMutator]MSP[] }
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[InlineConstantMutator]MSP[] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
final int l = Utils . digit16 ( bytes [ ++ i ] ) ; buffer . put ( (byte) ( ( u << 4 ) + l ) ) ; MST[rv.UOI1Mutator]MSP[] } catch ( final ArrayIndexOutOfBoundsException e ) { throw new DecoderException ( lr_1 , e ) ; }
this . alwaysEncodeChars . set ( b ) ; MST[rv.UOI1Mutator]MSP[] if ( b < alwaysEncodeCharsMin ) { alwaysEncodeCharsMin = b ; } if ( b > alwaysEncodeCharsMax ) { alwaysEncodeCharsMax = b ; } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
return doEncode ( bytes , expectedEncodingBytes , willEncode ) ; } return bytes ; } private byte [] doEncode ( final byte [] bytes , final int expectedLength , final boolean willEncode ) { final ByteBuffer buffer = ByteBuffer . allocate ( expectedLength ) ; MST[rv.UOI3Mutator]MSP[]
byteCount ++ ; } return byteCount ; } @Override public Object encode ( final Object obj ) throws EncoderException { if ( obj == null ) { return null ; MST[ReturnValsMutator]MSP[] } else if ( obj instanceof byte [] ) { return encode ( ( byte [] ) obj ) ;
final char hex1 = Utils . hexDigit ( bb >> 4 ) ; final char hex2 = Utils . hexDigit ( bb ) ; buffer . put ( ESCAPE_CHAR ) ; buffer . put ( ( byte ) hex1 ) ; MST[rv.ABSMutator]MSP[]
for ( final byte b : bytes ) { MST[rv.UOI4Mutator]MSP[] if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
} else { if ( plusForSpace && b == '+' ) { MST[rv.ROR1Mutator]MSP[] buffer . put ( ( byte ) ' ' ) ; } else { buffer . put ( b ) ; } } } return buffer . array () ; }
} else { throw new EncoderException ( lr_2 + obj . getClass () . getName () + lr_3 ) ; } } @Override public Object decode ( final Object obj ) throws DecoderException { if ( obj == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return null ;
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { MST[rv.CRCR5Mutator]MSP[] if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
for ( int i = 0 ; i < bytes . length ; i ++ ) { MST[rv.CRCR5Mutator]MSP[] final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
byteCount ++ ; MST[experimental.RemoveIncrementsMutator]MSP[] } return byteCount ; } @Override public Object encode ( final Object obj ) throws EncoderException { if ( obj == null ) { return null ; } else if ( obj instanceof byte [] ) { return encode ( ( byte [] ) obj ) ;
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { final byte b = bytes [ i ] ; MST[rv.UOI4Mutator]MSP[] i += b == ESCAPE_CHAR ? 3 : 1 ;
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; MST[rv.UOI1Mutator]MSP[] } private boolean isAsciiChar ( final byte c ) {
this . alwaysEncodeChars . set ( b ) ; if ( b < alwaysEncodeCharsMin ) { alwaysEncodeCharsMin = b ; MST[rv.UOI4Mutator]MSP[] } if ( b > alwaysEncodeCharsMax ) { alwaysEncodeCharsMax = b ; } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
this . alwaysEncodeChars . set ( b ) ; if ( b < alwaysEncodeCharsMin ) { alwaysEncodeCharsMin = b ; } if ( b > alwaysEncodeCharsMax ) { alwaysEncodeCharsMax = b ; MST[rv.UOI3Mutator]MSP[] } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
byteCount ++ ; } return byteCount ; } @Override public Object encode ( final Object obj ) throws EncoderException { if ( obj == null ) { return null ; } else if ( obj instanceof byte [] ) { return encode ( ( byte [] ) obj ) ; MST[ArgumentPropagationMutator]MSP[]
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { MST[rv.UOI1Mutator]MSP[] byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; MST[rv.ROR5Mutator]MSP[] } return byteCount ; }
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[rv.ABSMutator]MSP[] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ; MST[rv.UOI1Mutator]MSP[]
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { if ( b == ' ' ) { MST[rv.ROR2Mutator]MSP[] return true ; } } return false ; } private boolean canEncode ( final byte c ) {
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { insertAlwaysEncodeChar ( b ) ; MST[rv.UOI2Mutator]MSP[] } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; MST[NegateConditionalsMutator]MSP[] if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) {
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; MST[rv.CRCR1Mutator]MSP[] for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; } return byteCount ; }
} else if ( obj instanceof byte [] ) { MST[rv.ROR1Mutator]MSP[] return decode ( ( byte [] ) obj ) ; } else { throw new DecoderException ( lr_2 + obj . getClass () . getName () + lr_4 ) ; } }
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { insertAlwaysEncodeChar ( b ) ; MST[VoidMethodCallMutator]MSP[] } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
final int l = Utils . digit16 ( bytes [ ++ i ] ) ; MST[rv.ABSMutator]MSP[] buffer . put ( (byte) ( ( u << 4 ) + l ) ) ; } catch ( final ArrayIndexOutOfBoundsException e ) { throw new DecoderException ( lr_1 , e ) ; }
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[rv.ROR5Mutator]MSP[] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
buffer . put ( ( byte ) hex2 ) ; } else { if ( plusForSpace && b == ' ' ) { MST[rv.CRCR1Mutator]MSP[] buffer . put ( ( byte ) '+' ) ; } else { buffer . put ( b ) ; } } }
} else { if ( plusForSpace && b == '+' ) { buffer . put ( ( byte ) ' ' ) ; } else { buffer . put ( b ) ; MST[rv.UOI4Mutator]MSP[] } } } return buffer . array () ; }
for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ; MST[rv.UOI1Mutator]MSP[]
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ; MST[InlineConstantMutator]MSP[]
