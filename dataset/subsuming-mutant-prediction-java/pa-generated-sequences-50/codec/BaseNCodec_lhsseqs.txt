final int oldCapacity = context . buffer . length ; int newCapacity = oldCapacity * DEFAULT_BUFFER_RESIZE_FACTOR ; if ( compareUnsigned ( newCapacity , minCapacity ) < 0 ) { newCapacity = minCapacity ; } if ( compareUnsigned ( newCapacity , MAX_BUFFER_SIZE ) > 0 ) { MST[rv.ROR4Mutator]MSP[]
private static int compareUnsigned ( final int x , final int y ) { return Integer . compare ( x + Integer . MIN_VALUE , y + Integer . MIN_VALUE ) ; MST[NonVoidMethodCallMutator]MSP[] } private static int createPositiveCapacity ( final int minCapacity ) { if ( minCapacity < 0 ) {
private static int compareUnsigned ( final int x , final int y ) { return Integer . compare ( x + Integer . MIN_VALUE , y + Integer . MIN_VALUE ) ; MST[rv.CRCR6Mutator]MSP[] } private static int createPositiveCapacity ( final int minCapacity ) { if ( minCapacity < 0 ) {
return decode ( ( byte [] ) obj ) ; MST[ArgumentPropagationMutator]MSP[] } else if ( obj instanceof String ) { return decode ( ( String ) obj ) ; } else { throw new DecoderException ( lr_5 ) ; } } public byte [] decode ( final String pArray ) {
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; MST[rv.AOD2Mutator]MSP[] if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; } return len ; }
throw new OutOfMemoryError ( lr_4 + ( minCapacity & 0xffffffffL ) ) ; MST[rv.CRCR5Mutator]MSP[] } return ( minCapacity > MAX_BUFFER_SIZE ) ? minCapacity : MAX_BUFFER_SIZE ; } public static byte [] getChunkSeparator () { return CHUNK_SEPARATOR . clone () ; } protected static boolean isWhiteSpace ( final byte byteToCheck ) {
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; MST[rv.AOR3Mutator]MSP[] if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; } return len ; }
final Context context = new Context () ; encode ( pArray , offset , length , context ) ; MST[rv.UOI3Mutator]MSP[] encode ( pArray , offset , EOF , context ) ; final byte [] buf = new byte [ context . pos - context . readPos ] ;
context . buffer = new byte [ Math . max ( size , getDefaultBufferSize () ) ] ; context . pos = 0 ; context . readPos = 0 ; MST[rv.CRCR3Mutator]MSP[] } else if ( context . pos + size - context . buffer . length > 0 ) {
readResults ( buf , 0 , buf . length , context ) ; MST[rv.CRCR1Mutator]MSP[] return buf ; } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof byte [] ) ) { throw new EncoderException ( lr_6 ) ; }
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; MST[rv.CRCR2Mutator]MSP[] if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; } return len ; }
boolean hasData ( final Context context ) { return context . buffer != null ; } public boolean isInAlphabet ( final byte [] arrayOctet , final boolean allowWSPad ) { for ( final byte octet : arrayOctet ) { if ( ! isInAlphabet ( octet ) && MST[rv.ROR2Mutator]MSP[]
for ( final byte element : arrayOctet ) { MST[rv.UOI1Mutator]MSP[] if ( pad == element || isInAlphabet ( element ) ) { return true ; } } return false ; } @Override public byte [] decode ( final byte [] pArray ) {
( ! allowWSPad || ( octet != pad ) && ! isWhiteSpace ( octet ) ) ) { MST[rv.ROR5Mutator]MSP[] return false ; } } return true ; } public boolean isInAlphabet ( final String basen ) { return isInAlphabet ( StringUtils . getBytesUtf8 ( basen ) , true ) ; }
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; MST[rv.ABSMutator]MSP[] } return len ; }
boolean hasData ( final Context context ) { return context . buffer != null ; } public boolean isInAlphabet ( final byte [] arrayOctet , final boolean allowWSPad ) { for ( final byte octet : arrayOctet ) { if ( ! isInAlphabet ( octet ) && MST[rv.UOI3Mutator]MSP[]
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; MST[rv.AOR3Mutator]MSP[] } return len ; }
switch ( byteToCheck ) { MST[experimental.SwitchMutator]MSP[] case ' ' : case '\n' : case '\r' : case '\t' : return true ; default : return false ; } } private static byte [] resizeBuffer ( final Context context , final int minCapacity ) {
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { MST[rv.ABSMutator]MSP[] len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; } return len ; }
for ( final byte element : arrayOctet ) { if ( pad == element || isInAlphabet ( element ) ) { return true ; MST[rv.CRCR2Mutator]MSP[] } } return false ; } @Override public byte [] decode ( final byte [] pArray ) {
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; MST[rv.UOI3Mutator]MSP[] } return len ; }
throw new OutOfMemoryError ( lr_4 + ( minCapacity & 0xffffffffL ) ) ; MST[rv.OBBN3Mutator]MSP[] } return ( minCapacity > MAX_BUFFER_SIZE ) ? minCapacity : MAX_BUFFER_SIZE ; } public static byte [] getChunkSeparator () { return CHUNK_SEPARATOR . clone () ; } protected static boolean isWhiteSpace ( final byte byteToCheck ) {
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; MST[rv.AOD1Mutator]MSP[] if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; } return len ; }
( ! allowWSPad || ( octet != pad ) && ! isWhiteSpace ( octet ) ) ) { return false ; } } return true ; } public boolean isInAlphabet ( final String basen ) { return isInAlphabet ( StringUtils . getBytesUtf8 ( basen ) , true ) ; MST[rv.CRCR3Mutator]MSP[] }
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; MST[rv.UOI4Mutator]MSP[] if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; } return len ; }
int available ( final Context context ) { return context . buffer != null ? context . pos - context . readPos : 0 ; } protected boolean containsAlphabetOrPad ( final byte [] arrayOctet ) { if ( arrayOctet == null ) { return false ; MST[ReturnValsMutator]MSP[] }
return StringUtils . newStringUtf8 ( encode ( pArray ) ) ; MST[ArgumentPropagationMutator]MSP[] } protected byte [] ensureBufferSize ( final int size , final Context context ) { if ( context . buffer == null ) {
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; MST[rv.AOR4Mutator]MSP[] if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; } return len ; }
final int oldCapacity = context . buffer . length ; int newCapacity = oldCapacity * DEFAULT_BUFFER_RESIZE_FACTOR ; if ( compareUnsigned ( newCapacity , minCapacity ) < 0 ) { MST[rv.UOI4Mutator]MSP[] newCapacity = minCapacity ; } if ( compareUnsigned ( newCapacity , MAX_BUFFER_SIZE ) > 0 ) {
context . buffer = new byte [ Math . max ( size , getDefaultBufferSize () ) ] ; context . pos = 0 ; MST[experimental.MemberVariableMutator]MSP[] context . readPos = 0 ; } else if ( context . pos + size - context . buffer . length > 0 ) {
for ( final byte element : arrayOctet ) { MST[rv.ABSMutator]MSP[] if ( pad == element || isInAlphabet ( element ) ) { return true ; } } return false ; } @Override public byte [] decode ( final byte [] pArray ) {
throw new OutOfMemoryError ( lr_4 + ( minCapacity & 0xffffffffL ) ) ; } return ( minCapacity > MAX_BUFFER_SIZE ) ? MST[rv.CRCR1Mutator]MSP[] minCapacity : MAX_BUFFER_SIZE ; } public static byte [] getChunkSeparator () { return CHUNK_SEPARATOR . clone () ; } protected static boolean isWhiteSpace ( final byte byteToCheck ) {
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; MST[rv.AOD1Mutator]MSP[] } return len ; }
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; } return len ; MST[rv.UOI4Mutator]MSP[] }
( ! allowWSPad || ( octet != pad ) && ! isWhiteSpace ( octet ) ) ) { return false ; } } return true ; } public boolean isInAlphabet ( final String basen ) { return isInAlphabet ( StringUtils . getBytesUtf8 ( basen ) , true ) ; MST[BooleanTrueReturnValsMutator]MSP[] }
final int len = Math . min ( available ( context ) , bAvail ) ; System . arraycopy ( context . buffer , context . readPos , b , bPos , len ) ; MST[rv.UOI3Mutator]MSP[] context . readPos += len ;
switch ( byteToCheck ) { case ' ' : case '\n' : case '\r' : case '\t' : return true ; MST[rv.CRCR5Mutator]MSP[] default : return false ; } } private static byte [] resizeBuffer ( final Context context , final int minCapacity ) {
final int len = Math . min ( available ( context ) , bAvail ) ; System . arraycopy ( context . buffer , context . readPos , b , bPos , len ) ; context . readPos += len ; MST[rv.AOR1Mutator]MSP[]
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; MST[InlineConstantMutator]MSP[] if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; } return len ; }
( ! allowWSPad || ( octet != pad ) && ! isWhiteSpace ( octet ) ) ) { MST[NegateConditionalsMutator]MSP[] return false ; } } return true ; } public boolean isInAlphabet ( final String basen ) { return isInAlphabet ( StringUtils . getBytesUtf8 ( basen ) , true ) ; }
throw new OutOfMemoryError ( lr_4 + ( minCapacity & 0xffffffffL ) ) ; } return ( minCapacity > MAX_BUFFER_SIZE ) ? MST[rv.ROR1Mutator]MSP[] minCapacity : MAX_BUFFER_SIZE ; } public static byte [] getChunkSeparator () { return CHUNK_SEPARATOR . clone () ; } protected static boolean isWhiteSpace ( final byte byteToCheck ) {
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; MST[rv.UOI2Mutator]MSP[] } return len ; }
return decode ( StringUtils . getBytesUtf8 ( pArray ) ) ; } @Override public byte [] encode ( final byte [] pArray ) { if ( pArray == null || pArray . length == 0 ) { MST[NegateConditionalsMutator]MSP[] return pArray ; }
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; MST[rv.UOI1Mutator]MSP[] if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; } return len ; }
final byte [] result = new byte [ context . pos ] ; MST[rv.UOI2Mutator]MSP[] readResults ( result , 0 , result . length , context ) ; return result ; } @Override public Object decode ( final Object obj ) throws DecoderException { if ( obj instanceof byte [] ) {
final int oldCapacity = context . buffer . length ; int newCapacity = oldCapacity * DEFAULT_BUFFER_RESIZE_FACTOR ; MST[rv.CRCR3Mutator]MSP[] if ( compareUnsigned ( newCapacity , minCapacity ) < 0 ) { newCapacity = minCapacity ; } if ( compareUnsigned ( newCapacity , MAX_BUFFER_SIZE ) > 0 ) {
return decode ( StringUtils . getBytesUtf8 ( pArray ) ) ; MST[NullReturnValsMutator]MSP[] } @Override public byte [] encode ( final byte [] pArray ) { if ( pArray == null || pArray . length == 0 ) { return pArray ; }
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; MST[rv.AOR3Mutator]MSP[] if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; } return len ; }
final int oldCapacity = context . buffer . length ; int newCapacity = oldCapacity * DEFAULT_BUFFER_RESIZE_FACTOR ; if ( compareUnsigned ( newCapacity , minCapacity ) < 0 ) { newCapacity = minCapacity ; } if ( compareUnsigned ( newCapacity , MAX_BUFFER_SIZE ) > 0 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[]
for ( final byte element : arrayOctet ) { if ( pad == element || isInAlphabet ( element ) ) { return true ; MST[InlineConstantMutator]MSP[] } } return false ; } @Override public byte [] decode ( final byte [] pArray ) {
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; MST[rv.AOD2Mutator]MSP[] } return len ; }
private static int compareUnsigned ( final int x , final int y ) { return Integer . compare ( x + Integer . MIN_VALUE , y + Integer . MIN_VALUE ) ; MST[rv.AOR2Mutator]MSP[] } private static int createPositiveCapacity ( final int minCapacity ) { if ( minCapacity < 0 ) {
if ( pArray == null || pArray . length == 0 ) { return pArray ; } final Context context = new Context () ; decode ( pArray , 0 , pArray . length , context ) ; MST[InlineConstantMutator]MSP[] decode ( pArray , 0 , EOF , context ) ;
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; MST[MathMutator]MSP[] if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; } return len ; }
boolean hasData ( final Context context ) { return context . buffer != null ; } public boolean isInAlphabet ( final byte [] arrayOctet , final boolean allowWSPad ) { for ( final byte octet : arrayOctet ) { if ( ! isInAlphabet ( octet ) && MST[rv.UOI1Mutator]MSP[]
for ( final byte element : arrayOctet ) { if ( pad == element || isInAlphabet ( element ) ) { MST[rv.ROR4Mutator]MSP[] return true ; } } return false ; } @Override public byte [] decode ( final byte [] pArray ) {
public boolean isStrictDecoding () { return decodingPolicy == CodecPolicy . STRICT ; MST[rv.CRCR4Mutator]MSP[] } int readResults ( final byte [] b , final int bPos , final int bAvail , final Context context ) { if ( context . buffer != null ) {
boolean hasData ( final Context context ) { return context . buffer != null ; } public boolean isInAlphabet ( final byte [] arrayOctet , final boolean allowWSPad ) { for ( final byte octet : arrayOctet ) { if ( ! isInAlphabet ( octet ) && MST[rv.ROR4Mutator]MSP[]
private static int compareUnsigned ( final int x , final int y ) { return Integer . compare ( x + Integer . MIN_VALUE , y + Integer . MIN_VALUE ) ; MST[rv.CRCR5Mutator]MSP[] } private static int createPositiveCapacity ( final int minCapacity ) { if ( minCapacity < 0 ) {
private static int compareUnsigned ( final int x , final int y ) { return Integer . compare ( x + Integer . MIN_VALUE , y + Integer . MIN_VALUE ) ; } private static int createPositiveCapacity ( final int minCapacity ) { if ( minCapacity < 0 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[]
switch ( byteToCheck ) { case ' ' : case '\n' : case '\r' : case '\t' : return true ; MST[ReturnValsMutator]MSP[] default : return false ; } } private static byte [] resizeBuffer ( final Context context , final int minCapacity ) {
final int oldCapacity = context . buffer . length ; int newCapacity = oldCapacity * DEFAULT_BUFFER_RESIZE_FACTOR ; if ( compareUnsigned ( newCapacity , minCapacity ) < 0 ) { newCapacity = minCapacity ; } if ( compareUnsigned ( newCapacity , MAX_BUFFER_SIZE ) > 0 ) { MST[rv.CRCR3Mutator]MSP[]
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; MST[rv.AOR1Mutator]MSP[] } return len ; }
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; MST[rv.UOI3Mutator]MSP[] } return len ; }
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { MST[rv.ROR3Mutator]MSP[] len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; } return len ; }
return encode ( ( byte [] ) obj ) ; } public String encodeAsString ( final byte [] pArray ) { return StringUtils . newStringUtf8 ( encode ( pArray ) ) ; MST[NonVoidMethodCallMutator]MSP[] } public String encodeToString ( final byte [] pArray ) {
newCapacity = createPositiveCapacity ( minCapacity ) ; MST[rv.UOI3Mutator]MSP[] } final byte [] b = new byte [ newCapacity ] ; System . arraycopy ( context . buffer , 0 , b , 0 , context . buffer . length ) ; context . buffer = b ; return b ; }
final int oldCapacity = context . buffer . length ; int newCapacity = oldCapacity * DEFAULT_BUFFER_RESIZE_FACTOR ; if ( compareUnsigned ( newCapacity , minCapacity ) < 0 ) { MST[ArgumentPropagationMutator]MSP[] newCapacity = minCapacity ; } if ( compareUnsigned ( newCapacity , MAX_BUFFER_SIZE ) > 0 ) {
private static int compareUnsigned ( final int x , final int y ) { return Integer . compare ( x + Integer . MIN_VALUE , y + Integer . MIN_VALUE ) ; MST[PrimitiveReturnsMutator]MSP[] } private static int createPositiveCapacity ( final int minCapacity ) { if ( minCapacity < 0 ) {
return StringUtils . newStringUtf8 ( encode ( pArray ) ) ; } protected byte [] ensureBufferSize ( final int size , final Context context ) { if ( context . buffer == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
if ( pArray == null || pArray . length == 0 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return pArray ; } final Context context = new Context () ; decode ( pArray , 0 , pArray . length , context ) ; decode ( pArray , 0 , EOF , context ) ;
return decode ( StringUtils . getBytesUtf8 ( pArray ) ) ; MST[ReturnValsMutator]MSP[] } @Override public byte [] encode ( final byte [] pArray ) { if ( pArray == null || pArray . length == 0 ) { return pArray ; }
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; MST[rv.UOI2Mutator]MSP[] if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; } return len ; }
final int oldCapacity = context . buffer . length ; int newCapacity = oldCapacity * DEFAULT_BUFFER_RESIZE_FACTOR ; if ( compareUnsigned ( newCapacity , minCapacity ) < 0 ) { MST[rv.UOI3Mutator]MSP[] newCapacity = minCapacity ; } if ( compareUnsigned ( newCapacity , MAX_BUFFER_SIZE ) > 0 ) {
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; MST[rv.CRCR5Mutator]MSP[] } return len ; }
return resizeBuffer ( context , context . pos + size ) ; MST[rv.UOI3Mutator]MSP[] } return context . buffer ; } public CodecPolicy getCodecPolicy () { return decodingPolicy ; } protected int getDefaultBufferSize () { return DEFAULT_BUFFER_SIZE ; } public long getEncodedLength ( final byte [] pArray ) {
readResults ( buf , 0 , buf . length , context ) ; MST[rv.CRCR6Mutator]MSP[] return buf ; } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof byte [] ) ) { throw new EncoderException ( lr_6 ) ; }
boolean hasData ( final Context context ) { return context . buffer != null ; } public boolean isInAlphabet ( final byte [] arrayOctet , final boolean allowWSPad ) { for ( final byte octet : arrayOctet ) { MST[rv.UOI3Mutator]MSP[] if ( ! isInAlphabet ( octet ) &&
boolean hasData ( final Context context ) { return context . buffer != null ; } public boolean isInAlphabet ( final byte [] arrayOctet , final boolean allowWSPad ) { for ( final byte octet : arrayOctet ) { MST[rv.UOI2Mutator]MSP[] if ( ! isInAlphabet ( octet ) &&
( ! allowWSPad || ( octet != pad ) && ! isWhiteSpace ( octet ) ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return false ; } } return true ; } public boolean isInAlphabet ( final String basen ) { return isInAlphabet ( StringUtils . getBytesUtf8 ( basen ) , true ) ; }
( ! allowWSPad || ( octet != pad ) && ! isWhiteSpace ( octet ) ) ) { return false ; MST[rv.CRCR1Mutator]MSP[] } } return true ; } public boolean isInAlphabet ( final String basen ) { return isInAlphabet ( StringUtils . getBytesUtf8 ( basen ) , true ) ; }
int available ( final Context context ) { return context . buffer != null ? context . pos - context . readPos : 0 ; } protected boolean containsAlphabetOrPad ( final byte [] arrayOctet ) { if ( arrayOctet == null ) { return false ; MST[rv.CRCR5Mutator]MSP[] }
if ( context . readPos >= context . pos ) { context . buffer = null ; } return len ; } return context . eof ? EOF : 0 ; MST[rv.CRCR5Mutator]MSP[] }
if ( pArray == null || pArray . length == 0 ) { return pArray ; } final Context context = new Context () ; decode ( pArray , 0 , pArray . length , context ) ; decode ( pArray , 0 , EOF , context ) ; MST[rv.CRCR4Mutator]MSP[]
for ( final byte element : arrayOctet ) { if ( pad == element || isInAlphabet ( element ) ) { return true ; MST[ReturnValsMutator]MSP[] } } return false ; } @Override public byte [] decode ( final byte [] pArray ) {
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; MST[rv.ABSMutator]MSP[] if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; } return len ; }
final int oldCapacity = context . buffer . length ; int newCapacity = oldCapacity * DEFAULT_BUFFER_RESIZE_FACTOR ; if ( compareUnsigned ( newCapacity , minCapacity ) < 0 ) { newCapacity = minCapacity ; } if ( compareUnsigned ( newCapacity , MAX_BUFFER_SIZE ) > 0 ) { MST[rv.ROR1Mutator]MSP[]
throw new OutOfMemoryError ( lr_4 + ( minCapacity & 0xffffffffL ) ) ; } return ( minCapacity > MAX_BUFFER_SIZE ) ? MST[rv.CRCR6Mutator]MSP[] minCapacity : MAX_BUFFER_SIZE ; } public static byte [] getChunkSeparator () { return CHUNK_SEPARATOR . clone () ; } protected static boolean isWhiteSpace ( final byte byteToCheck ) {
( ! allowWSPad || ( octet != pad ) && ! isWhiteSpace ( octet ) ) ) { return false ; MST[rv.CRCR6Mutator]MSP[] } } return true ; } public boolean isInAlphabet ( final String basen ) { return isInAlphabet ( StringUtils . getBytesUtf8 ( basen ) , true ) ; }
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; MST[MathMutator]MSP[] } return len ; }
if ( pArray == null || pArray . length == 0 ) { MST[NegateConditionalsMutator]MSP[] return pArray ; } final Context context = new Context () ; decode ( pArray , 0 , pArray . length , context ) ; decode ( pArray , 0 , EOF , context ) ;
private static int compareUnsigned ( final int x , final int y ) { return Integer . compare ( x + Integer . MIN_VALUE , y + Integer . MIN_VALUE ) ; MST[rv.AOR3Mutator]MSP[] } private static int createPositiveCapacity ( final int minCapacity ) { if ( minCapacity < 0 ) {
private static int compareUnsigned ( final int x , final int y ) { return Integer . compare ( x + Integer . MIN_VALUE , y + Integer . MIN_VALUE ) ; MST[rv.AOR1Mutator]MSP[] } private static int createPositiveCapacity ( final int minCapacity ) { if ( minCapacity < 0 ) {
readResults ( buf , 0 , buf . length , context ) ; return buf ; } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof byte [] ) ) { MST[rv.ROR3Mutator]MSP[] throw new EncoderException ( lr_6 ) ; }
return encode ( pArray , 0 , pArray . length ) ; MST[rv.CRCR5Mutator]MSP[] } public byte [] encode ( final byte [] pArray , final int offset , final int length ) { if ( pArray == null || pArray . length == 0 ) { return pArray ; }
final int oldCapacity = context . buffer . length ; int newCapacity = oldCapacity * DEFAULT_BUFFER_RESIZE_FACTOR ; if ( compareUnsigned ( newCapacity , minCapacity ) < 0 ) { newCapacity = minCapacity ; MST[rv.UOI2Mutator]MSP[] } if ( compareUnsigned ( newCapacity , MAX_BUFFER_SIZE ) > 0 ) {
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; MST[rv.AOD2Mutator]MSP[] } return len ; }
throw new OutOfMemoryError ( lr_4 + ( minCapacity & 0xffffffffL ) ) ; } return ( minCapacity > MAX_BUFFER_SIZE ) ? MST[rv.UOI3Mutator]MSP[] minCapacity : MAX_BUFFER_SIZE ; } public static byte [] getChunkSeparator () { return CHUNK_SEPARATOR . clone () ; } protected static boolean isWhiteSpace ( final byte byteToCheck ) {
int available ( final Context context ) { return context . buffer != null ? context . pos - context . readPos : 0 ; MST[rv.UOI2Mutator]MSP[] } protected boolean containsAlphabetOrPad ( final byte [] arrayOctet ) { if ( arrayOctet == null ) { return false ; }
switch ( byteToCheck ) { case ' ' : case '\n' : case '\r' : case '\t' : return true ; MST[rv.CRCR2Mutator]MSP[] default : return false ; } } private static byte [] resizeBuffer ( final Context context , final int minCapacity ) {
throw new OutOfMemoryError ( lr_4 + ( minCapacity & 0xffffffffL ) ) ; } return ( minCapacity > MAX_BUFFER_SIZE ) ? MST[rv.UOI2Mutator]MSP[] minCapacity : MAX_BUFFER_SIZE ; } public static byte [] getChunkSeparator () { return CHUNK_SEPARATOR . clone () ; } protected static boolean isWhiteSpace ( final byte byteToCheck ) {
for ( final byte element : arrayOctet ) { MST[rv.UOI1Mutator]MSP[] if ( pad == element || isInAlphabet ( element ) ) { return true ; } } return false ; } @Override public byte [] decode ( final byte [] pArray ) {
final byte [] result = new byte [ context . pos ] ; readResults ( result , 0 , result . length , context ) ; return result ; } @Override public Object decode ( final Object obj ) throws DecoderException { if ( obj instanceof byte [] ) { MST[rv.ROR1Mutator]MSP[]
switch ( byteToCheck ) { case ' ' : case '\n' : case '\r' : case '\t' : return true ; default : return false ; MST[rv.CRCR3Mutator]MSP[] } } private static byte [] resizeBuffer ( final Context context , final int minCapacity ) {
boolean hasData ( final Context context ) { return context . buffer != null ; } public boolean isInAlphabet ( final byte [] arrayOctet , final boolean allowWSPad ) { for ( final byte octet : arrayOctet ) { if ( ! isInAlphabet ( octet ) && MST[rv.UOI1Mutator]MSP[]
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; MST[rv.AOR2Mutator]MSP[] } return len ; }
return decode ( ( byte [] ) obj ) ; } else if ( obj instanceof String ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return decode ( ( String ) obj ) ; } else { throw new DecoderException ( lr_5 ) ; } } public byte [] decode ( final String pArray ) {
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; } return len ; MST[ReturnValsMutator]MSP[] }
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; } return len ; }
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; MST[rv.ABSMutator]MSP[] } return len ; }
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; MST[rv.UOI4Mutator]MSP[] if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; } return len ; }
throw new OutOfMemoryError ( lr_4 + ( minCapacity & 0xffffffffL ) ) ; MST[experimental.NakedReceiverMutator]MSP[] } return ( minCapacity > MAX_BUFFER_SIZE ) ? minCapacity : MAX_BUFFER_SIZE ; } public static byte [] getChunkSeparator () { return CHUNK_SEPARATOR . clone () ; } protected static boolean isWhiteSpace ( final byte byteToCheck ) {
return StringUtils . newStringUtf8 ( encode ( pArray ) ) ; MST[NonVoidMethodCallMutator]MSP[] } protected byte [] ensureBufferSize ( final int size , final Context context ) { if ( context . buffer == null ) {
newCapacity = createPositiveCapacity ( minCapacity ) ; } final byte [] b = new byte [ newCapacity ] ; MST[rv.UOI2Mutator]MSP[] System . arraycopy ( context . buffer , 0 , b , 0 , context . buffer . length ) ; context . buffer = b ; return b ; }
( ! allowWSPad || ( octet != pad ) && ! isWhiteSpace ( octet ) ) ) { return false ; } } return true ; } public boolean isInAlphabet ( final String basen ) { return isInAlphabet ( StringUtils . getBytesUtf8 ( basen ) , true ) ; MST[rv.CRCR6Mutator]MSP[] }
private static int compareUnsigned ( final int x , final int y ) { return Integer . compare ( x + Integer . MIN_VALUE , y + Integer . MIN_VALUE ) ; } private static int createPositiveCapacity ( final int minCapacity ) { if ( minCapacity < 0 ) { MST[rv.ROR2Mutator]MSP[]
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; MST[rv.AOR1Mutator]MSP[] if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; } return len ; }
boolean hasData ( final Context context ) { return context . buffer != null ; } public boolean isInAlphabet ( final byte [] arrayOctet , final boolean allowWSPad ) { for ( final byte octet : arrayOctet ) { if ( ! isInAlphabet ( octet ) && MST[rv.UOI4Mutator]MSP[]
for ( final byte element : arrayOctet ) { MST[rv.ABSMutator]MSP[] if ( pad == element || isInAlphabet ( element ) ) { return true ; } } return false ; } @Override public byte [] decode ( final byte [] pArray ) {
return resizeBuffer ( context , context . pos + size ) ; MST[rv.UOI2Mutator]MSP[] } return context . buffer ; } public CodecPolicy getCodecPolicy () { return decodingPolicy ; } protected int getDefaultBufferSize () { return DEFAULT_BUFFER_SIZE ; } public long getEncodedLength ( final byte [] pArray ) {
private static int compareUnsigned ( final int x , final int y ) { return Integer . compare ( x + Integer . MIN_VALUE , y + Integer . MIN_VALUE ) ; } private static int createPositiveCapacity ( final int minCapacity ) { if ( minCapacity < 0 ) { MST[rv.UOI1Mutator]MSP[]
throw new OutOfMemoryError ( lr_4 + ( minCapacity & 0xffffffffL ) ) ; } return ( minCapacity > MAX_BUFFER_SIZE ) ? MST[InlineConstantMutator]MSP[] minCapacity : MAX_BUFFER_SIZE ; } public static byte [] getChunkSeparator () { return CHUNK_SEPARATOR . clone () ; } protected static boolean isWhiteSpace ( final byte byteToCheck ) {
return encode ( pArray , 0 , pArray . length ) ; MST[NullReturnValsMutator]MSP[] } public byte [] encode ( final byte [] pArray , final int offset , final int length ) { if ( pArray == null || pArray . length == 0 ) { return pArray ; }
if ( pArray == null || pArray . length == 0 ) { MST[rv.ROR5Mutator]MSP[] return pArray ; } final Context context = new Context () ; decode ( pArray , 0 , pArray . length , context ) ; decode ( pArray , 0 , EOF , context ) ;
return decode ( ( byte [] ) obj ) ; MST[NonVoidMethodCallMutator]MSP[] } else if ( obj instanceof String ) { return decode ( ( String ) obj ) ; } else { throw new DecoderException ( lr_5 ) ; } } public byte [] decode ( final String pArray ) {
context . buffer = new byte [ Math . max ( size , getDefaultBufferSize () ) ] ; context . pos = 0 ; context . readPos = 0 ; MST[rv.CRCR6Mutator]MSP[] } else if ( context . pos + size - context . buffer . length > 0 ) {
boolean hasData ( final Context context ) { return context . buffer != null ; } public boolean isInAlphabet ( final byte [] arrayOctet , final boolean allowWSPad ) { for ( final byte octet : arrayOctet ) { MST[rv.UOI1Mutator]MSP[] if ( ! isInAlphabet ( octet ) &&
if ( pArray == null || pArray . length == 0 ) { return pArray ; } final Context context = new Context () ; decode ( pArray , 0 , pArray . length , context ) ; decode ( pArray , 0 , EOF , context ) ; MST[rv.CRCR3Mutator]MSP[]
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; MST[rv.AOR4Mutator]MSP[] } return len ; }
private static int compareUnsigned ( final int x , final int y ) { return Integer . compare ( x + Integer . MIN_VALUE , y + Integer . MIN_VALUE ) ; MST[InlineConstantMutator]MSP[] } private static int createPositiveCapacity ( final int minCapacity ) { if ( minCapacity < 0 ) {
return decode ( StringUtils . getBytesUtf8 ( pArray ) ) ; } @Override public byte [] encode ( final byte [] pArray ) { if ( pArray == null || pArray . length == 0 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return pArray ; }
public boolean isStrictDecoding () { return decodingPolicy == CodecPolicy . STRICT ; MST[InlineConstantMutator]MSP[] } int readResults ( final byte [] b , final int bPos , final int bAvail , final Context context ) { if ( context . buffer != null ) {
if ( context . readPos >= context . pos ) { context . buffer = null ; } return len ; } return context . eof ? EOF : 0 ; MST[rv.CRCR3Mutator]MSP[] }
final int oldCapacity = context . buffer . length ; int newCapacity = oldCapacity * DEFAULT_BUFFER_RESIZE_FACTOR ; MST[rv.UOI3Mutator]MSP[] if ( compareUnsigned ( newCapacity , minCapacity ) < 0 ) { newCapacity = minCapacity ; } if ( compareUnsigned ( newCapacity , MAX_BUFFER_SIZE ) > 0 ) {
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { MST[rv.UOI2Mutator]MSP[] len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; } return len ; }
if ( pArray == null || pArray . length == 0 ) { return pArray ; MST[ReturnValsMutator]MSP[] } final Context context = new Context () ; decode ( pArray , 0 , pArray . length , context ) ; decode ( pArray , 0 , EOF , context ) ;
if ( pArray == null || pArray . length == 0 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return pArray ; } final Context context = new Context () ; decode ( pArray , 0 , pArray . length , context ) ; decode ( pArray , 0 , EOF , context ) ;
private static int compareUnsigned ( final int x , final int y ) { return Integer . compare ( x + Integer . MIN_VALUE , y + Integer . MIN_VALUE ) ; MST[rv.UOI3Mutator]MSP[] } private static int createPositiveCapacity ( final int minCapacity ) { if ( minCapacity < 0 ) {
return encode ( ( byte [] ) obj ) ; } public String encodeAsString ( final byte [] pArray ) { return StringUtils . newStringUtf8 ( encode ( pArray ) ) ; MST[ReturnValsMutator]MSP[] } public String encodeToString ( final byte [] pArray ) {
final int oldCapacity = context . buffer . length ; int newCapacity = oldCapacity * DEFAULT_BUFFER_RESIZE_FACTOR ; if ( compareUnsigned ( newCapacity , minCapacity ) < 0 ) { newCapacity = minCapacity ; } if ( compareUnsigned ( newCapacity , MAX_BUFFER_SIZE ) > 0 ) { MST[rv.UOI3Mutator]MSP[]
public boolean isStrictDecoding () { return decodingPolicy == CodecPolicy . STRICT ; MST[rv.CRCR2Mutator]MSP[] } int readResults ( final byte [] b , final int bPos , final int bAvail , final Context context ) { if ( context . buffer != null ) {
boolean hasData ( final Context context ) { return context . buffer != null ; } public boolean isInAlphabet ( final byte [] arrayOctet , final boolean allowWSPad ) { for ( final byte octet : arrayOctet ) { if ( ! isInAlphabet ( octet ) && MST[rv.UOI1Mutator]MSP[]
boolean hasData ( final Context context ) { return context . buffer != null ; } public boolean isInAlphabet ( final byte [] arrayOctet , final boolean allowWSPad ) { for ( final byte octet : arrayOctet ) { if ( ! isInAlphabet ( octet ) && MST[rv.ROR2Mutator]MSP[]
throw new OutOfMemoryError ( lr_4 + ( minCapacity & 0xffffffffL ) ) ; } return ( minCapacity > MAX_BUFFER_SIZE ) ? minCapacity : MAX_BUFFER_SIZE ; } public static byte [] getChunkSeparator () { return CHUNK_SEPARATOR . clone () ; MST[NonVoidMethodCallMutator]MSP[] } protected static boolean isWhiteSpace ( final byte byteToCheck ) {
( ! allowWSPad || ( octet != pad ) && ! isWhiteSpace ( octet ) ) ) { MST[NonVoidMethodCallMutator]MSP[] return false ; } } return true ; } public boolean isInAlphabet ( final String basen ) { return isInAlphabet ( StringUtils . getBytesUtf8 ( basen ) , true ) ; }
final byte [] result = new byte [ context . pos ] ; MST[rv.ABSMutator]MSP[] readResults ( result , 0 , result . length , context ) ; return result ; } @Override public Object decode ( final Object obj ) throws DecoderException { if ( obj instanceof byte [] ) {
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; MST[rv.AOR1Mutator]MSP[] } return len ; }
if ( pArray == null || pArray . length == 0 ) { return pArray ; } final Context context = new Context () ; decode ( pArray , 0 , pArray . length , context ) ; MST[rv.CRCR5Mutator]MSP[] decode ( pArray , 0 , EOF , context ) ;
throw new OutOfMemoryError ( lr_4 + ( minCapacity & 0xffffffffL ) ) ; MST[rv.OBBN1Mutator]MSP[] } return ( minCapacity > MAX_BUFFER_SIZE ) ? minCapacity : MAX_BUFFER_SIZE ; } public static byte [] getChunkSeparator () { return CHUNK_SEPARATOR . clone () ; } protected static boolean isWhiteSpace ( final byte byteToCheck ) {
for ( final byte element : arrayOctet ) { if ( pad == element || isInAlphabet ( element ) ) { return true ; } } return false ; MST[BooleanTrueReturnValsMutator]MSP[] } @Override public byte [] decode ( final byte [] pArray ) {
return resizeBuffer ( context , context . pos + size ) ; MST[rv.UOI1Mutator]MSP[] } return context . buffer ; } public CodecPolicy getCodecPolicy () { return decodingPolicy ; } protected int getDefaultBufferSize () { return DEFAULT_BUFFER_SIZE ; } public long getEncodedLength ( final byte [] pArray ) {
final Context context = new Context () ; encode ( pArray , offset , length , context ) ; encode ( pArray , offset , EOF , context ) ; final byte [] buf = new byte [ context . pos - context . readPos ] ; MST[rv.AOR3Mutator]MSP[]
private static int compareUnsigned ( final int x , final int y ) { return Integer . compare ( x + Integer . MIN_VALUE , y + Integer . MIN_VALUE ) ; MST[rv.UOI2Mutator]MSP[] } private static int createPositiveCapacity ( final int minCapacity ) { if ( minCapacity < 0 ) {
boolean hasData ( final Context context ) { return context . buffer != null ; } public boolean isInAlphabet ( final byte [] arrayOctet , final boolean allowWSPad ) { for ( final byte octet : arrayOctet ) { MST[rv.UOI2Mutator]MSP[] if ( ! isInAlphabet ( octet ) &&
return encode ( ( byte [] ) obj ) ; } public String encodeAsString ( final byte [] pArray ) { return StringUtils . newStringUtf8 ( encode ( pArray ) ) ; MST[ArgumentPropagationMutator]MSP[] } public String encodeToString ( final byte [] pArray ) {
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; MST[rv.UOI2Mutator]MSP[] } return len ; }
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; MST[rv.AOR4Mutator]MSP[] } return len ; }
boolean hasData ( final Context context ) { return context . buffer != null ; } public boolean isInAlphabet ( final byte [] arrayOctet , final boolean allowWSPad ) { for ( final byte octet : arrayOctet ) { if ( ! isInAlphabet ( octet ) && MST[rv.ABSMutator]MSP[]
for ( final byte element : arrayOctet ) { if ( pad == element || isInAlphabet ( element ) ) { MST[rv.ROR1Mutator]MSP[] return true ; } } return false ; } @Override public byte [] decode ( final byte [] pArray ) {
( ! allowWSPad || ( octet != pad ) && ! isWhiteSpace ( octet ) ) ) { return false ; } } return true ; MST[rv.CRCR3Mutator]MSP[] } public boolean isInAlphabet ( final String basen ) { return isInAlphabet ( StringUtils . getBytesUtf8 ( basen ) , true ) ; }
throw new OutOfMemoryError ( lr_4 + ( minCapacity & 0xffffffffL ) ) ; MST[rv.UOI4Mutator]MSP[] } return ( minCapacity > MAX_BUFFER_SIZE ) ? minCapacity : MAX_BUFFER_SIZE ; } public static byte [] getChunkSeparator () { return CHUNK_SEPARATOR . clone () ; } protected static boolean isWhiteSpace ( final byte byteToCheck ) {
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; MST[rv.ABSMutator]MSP[] if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; } return len ; }
if ( pArray == null || pArray . length == 0 ) { return pArray ; } final Context context = new Context () ; decode ( pArray , 0 , pArray . length , context ) ; decode ( pArray , 0 , EOF , context ) ; MST[rv.CRCR6Mutator]MSP[]
( ! allowWSPad || ( octet != pad ) && ! isWhiteSpace ( octet ) ) ) { return false ; MST[rv.CRCR3Mutator]MSP[] } } return true ; } public boolean isInAlphabet ( final String basen ) { return isInAlphabet ( StringUtils . getBytesUtf8 ( basen ) , true ) ; }
private static int compareUnsigned ( final int x , final int y ) { return Integer . compare ( x + Integer . MIN_VALUE , y + Integer . MIN_VALUE ) ; MST[rv.AOR4Mutator]MSP[] } private static int createPositiveCapacity ( final int minCapacity ) { if ( minCapacity < 0 ) {
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; MST[rv.CRCR2Mutator]MSP[] } return len ; }
readResults ( buf , 0 , buf . length , context ) ; MST[rv.CRCR3Mutator]MSP[] return buf ; } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof byte [] ) ) { throw new EncoderException ( lr_6 ) ; }
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; } return len ; MST[rv.ABSMutator]MSP[] }
newCapacity = createPositiveCapacity ( minCapacity ) ; } final byte [] b = new byte [ newCapacity ] ; System . arraycopy ( context . buffer , 0 , b , 0 , context . buffer . length ) ; MST[rv.CRCR1Mutator]MSP[] context . buffer = b ; return b ; }
context . buffer = new byte [ Math . max ( size , getDefaultBufferSize () ) ] ; context . pos = 0 ; context . readPos = 0 ; MST[rv.CRCR5Mutator]MSP[] } else if ( context . pos + size - context . buffer . length > 0 ) {
private static int compareUnsigned ( final int x , final int y ) { return Integer . compare ( x + Integer . MIN_VALUE , y + Integer . MIN_VALUE ) ; } private static int createPositiveCapacity ( final int minCapacity ) { if ( minCapacity < 0 ) { MST[rv.ROR1Mutator]MSP[]
if ( pArray == null || pArray . length == 0 ) { return pArray ; } final Context context = new Context () ; decode ( pArray , 0 , pArray . length , context ) ; decode ( pArray , 0 , EOF , context ) ; MST[InlineConstantMutator]MSP[]
if ( context . readPos >= context . pos ) { context . buffer = null ; } return len ; } return context . eof ? EOF : 0 ; MST[rv.CRCR6Mutator]MSP[] }
boolean hasData ( final Context context ) { return context . buffer != null ; } public boolean isInAlphabet ( final byte [] arrayOctet , final boolean allowWSPad ) { for ( final byte octet : arrayOctet ) { if ( ! isInAlphabet ( octet ) && MST[rv.ROR4Mutator]MSP[]
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; MST[rv.AOR3Mutator]MSP[] } return len ; }
for ( final byte element : arrayOctet ) { if ( pad == element || isInAlphabet ( element ) ) { return true ; } } return false ; MST[InlineConstantMutator]MSP[] } @Override public byte [] decode ( final byte [] pArray ) {
for ( final byte element : arrayOctet ) { MST[rv.UOI3Mutator]MSP[] if ( pad == element || isInAlphabet ( element ) ) { return true ; } } return false ; } @Override public byte [] decode ( final byte [] pArray ) {
throw new OutOfMemoryError ( lr_4 + ( minCapacity & 0xffffffffL ) ) ; } return ( minCapacity > MAX_BUFFER_SIZE ) ? MST[rv.ABSMutator]MSP[] minCapacity : MAX_BUFFER_SIZE ; } public static byte [] getChunkSeparator () { return CHUNK_SEPARATOR . clone () ; } protected static boolean isWhiteSpace ( final byte byteToCheck ) {
( ! allowWSPad || ( octet != pad ) && ! isWhiteSpace ( octet ) ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return false ; } } return true ; } public boolean isInAlphabet ( final String basen ) { return isInAlphabet ( StringUtils . getBytesUtf8 ( basen ) , true ) ; }
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; MST[rv.CRCR4Mutator]MSP[] if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; } return len ; }
final int oldCapacity = context . buffer . length ; int newCapacity = oldCapacity * DEFAULT_BUFFER_RESIZE_FACTOR ; if ( compareUnsigned ( newCapacity , minCapacity ) < 0 ) { newCapacity = minCapacity ; } if ( compareUnsigned ( newCapacity , MAX_BUFFER_SIZE ) > 0 ) { MST[rv.CRCR5Mutator]MSP[]
return StringUtils . newStringUtf8 ( encode ( pArray ) ) ; } protected byte [] ensureBufferSize ( final int size , final Context context ) { if ( context . buffer == null ) { MST[rv.ROR5Mutator]MSP[]
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { MST[rv.ROR5Mutator]MSP[] len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; } return len ; }
return encode ( pArray , 0 , pArray . length ) ; MST[ReturnValsMutator]MSP[] } public byte [] encode ( final byte [] pArray , final int offset , final int length ) { if ( pArray == null || pArray . length == 0 ) { return pArray ; }
return resizeBuffer ( context , context . pos + size ) ; MST[rv.ABSMutator]MSP[] } return context . buffer ; } public CodecPolicy getCodecPolicy () { return decodingPolicy ; } protected int getDefaultBufferSize () { return DEFAULT_BUFFER_SIZE ; } public long getEncodedLength ( final byte [] pArray ) {
newCapacity = createPositiveCapacity ( minCapacity ) ; } final byte [] b = new byte [ newCapacity ] ; System . arraycopy ( context . buffer , 0 , b , 0 , context . buffer . length ) ; context . buffer = b ; return b ; MST[NullReturnValsMutator]MSP[] }
private static int compareUnsigned ( final int x , final int y ) { return Integer . compare ( x + Integer . MIN_VALUE , y + Integer . MIN_VALUE ) ; MST[rv.UOI3Mutator]MSP[] } private static int createPositiveCapacity ( final int minCapacity ) { if ( minCapacity < 0 ) {
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; MST[rv.AOD1Mutator]MSP[] } return len ; }
context . buffer = new byte [ Math . max ( size , getDefaultBufferSize () ) ] ; context . pos = 0 ; context . readPos = 0 ; } else if ( context . pos + size - context . buffer . length > 0 ) { MST[rv.UOI2Mutator]MSP[]
newCapacity = createPositiveCapacity ( minCapacity ) ; } final byte [] b = new byte [ newCapacity ] ; System . arraycopy ( context . buffer , 0 , b , 0 , context . buffer . length ) ; MST[rv.CRCR6Mutator]MSP[] context . buffer = b ; return b ; }
boolean hasData ( final Context context ) { return context . buffer != null ; } public boolean isInAlphabet ( final byte [] arrayOctet , final boolean allowWSPad ) { for ( final byte octet : arrayOctet ) { MST[rv.UOI4Mutator]MSP[] if ( ! isInAlphabet ( octet ) &&
( ! allowWSPad || ( octet != pad ) && ! isWhiteSpace ( octet ) ) ) { return false ; } } return true ; MST[rv.CRCR5Mutator]MSP[] } public boolean isInAlphabet ( final String basen ) { return isInAlphabet ( StringUtils . getBytesUtf8 ( basen ) , true ) ; }
final byte [] result = new byte [ context . pos ] ; readResults ( result , 0 , result . length , context ) ; MST[rv.CRCR5Mutator]MSP[] return result ; } @Override public Object decode ( final Object obj ) throws DecoderException { if ( obj instanceof byte [] ) {
if ( pArray == null || pArray . length == 0 ) { return pArray ; } final Context context = new Context () ; decode ( pArray , 0 , pArray . length , context ) ; decode ( pArray , 0 , EOF , context ) ; MST[rv.CRCR2Mutator]MSP[]
return decode ( StringUtils . getBytesUtf8 ( pArray ) ) ; MST[NonVoidMethodCallMutator]MSP[] } @Override public byte [] encode ( final byte [] pArray ) { if ( pArray == null || pArray . length == 0 ) { return pArray ; }
for ( final byte element : arrayOctet ) { if ( pad == element || isInAlphabet ( element ) ) { MST[rv.ROR3Mutator]MSP[] return true ; } } return false ; } @Override public byte [] decode ( final byte [] pArray ) {
if ( context . readPos >= context . pos ) { context . buffer = null ; } return len ; } return context . eof ? EOF : 0 ; MST[InlineConstantMutator]MSP[] }
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; MST[rv.UOI4Mutator]MSP[] } return len ; }
boolean hasData ( final Context context ) { return context . buffer != null ; } public boolean isInAlphabet ( final byte [] arrayOctet , final boolean allowWSPad ) { for ( final byte octet : arrayOctet ) { if ( ! isInAlphabet ( octet ) && MST[rv.ROR1Mutator]MSP[]
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; MST[rv.UOI4Mutator]MSP[] } return len ; }
return resizeBuffer ( context , context . pos + size ) ; MST[rv.AOR3Mutator]MSP[] } return context . buffer ; } public CodecPolicy getCodecPolicy () { return decodingPolicy ; } protected int getDefaultBufferSize () { return DEFAULT_BUFFER_SIZE ; } public long getEncodedLength ( final byte [] pArray ) {
final int len = Math . min ( available ( context ) , bAvail ) ; System . arraycopy ( context . buffer , context . readPos , b , bPos , len ) ; context . readPos += len ; MST[MathMutator]MSP[]
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; MST[rv.UOI3Mutator]MSP[] if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; } return len ; }
private static int compareUnsigned ( final int x , final int y ) { return Integer . compare ( x + Integer . MIN_VALUE , y + Integer . MIN_VALUE ) ; MST[rv.UOI4Mutator]MSP[] } private static int createPositiveCapacity ( final int minCapacity ) { if ( minCapacity < 0 ) {
final int oldCapacity = context . buffer . length ; int newCapacity = oldCapacity * DEFAULT_BUFFER_RESIZE_FACTOR ; MST[rv.CRCR5Mutator]MSP[] if ( compareUnsigned ( newCapacity , minCapacity ) < 0 ) { newCapacity = minCapacity ; } if ( compareUnsigned ( newCapacity , MAX_BUFFER_SIZE ) > 0 ) {
newCapacity = createPositiveCapacity ( minCapacity ) ; } final byte [] b = new byte [ newCapacity ] ; System . arraycopy ( context . buffer , 0 , b , 0 , context . buffer . length ) ; MST[rv.CRCR1Mutator]MSP[] context . buffer = b ; return b ; }
boolean hasData ( final Context context ) { return context . buffer != null ; } public boolean isInAlphabet ( final byte [] arrayOctet , final boolean allowWSPad ) { for ( final byte octet : arrayOctet ) { MST[rv.UOI1Mutator]MSP[] if ( ! isInAlphabet ( octet ) &&
throw new OutOfMemoryError ( lr_4 + ( minCapacity & 0xffffffffL ) ) ; MST[rv.UOI3Mutator]MSP[] } return ( minCapacity > MAX_BUFFER_SIZE ) ? minCapacity : MAX_BUFFER_SIZE ; } public static byte [] getChunkSeparator () { return CHUNK_SEPARATOR . clone () ; } protected static boolean isWhiteSpace ( final byte byteToCheck ) {
private static int compareUnsigned ( final int x , final int y ) { return Integer . compare ( x + Integer . MIN_VALUE , y + Integer . MIN_VALUE ) ; MST[MathMutator]MSP[] } private static int createPositiveCapacity ( final int minCapacity ) { if ( minCapacity < 0 ) {
return encode ( ( byte [] ) obj ) ; MST[NonVoidMethodCallMutator]MSP[] } public String encodeAsString ( final byte [] pArray ) { return StringUtils . newStringUtf8 ( encode ( pArray ) ) ; } public String encodeToString ( final byte [] pArray ) {
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; } return len ; MST[rv.UOI1Mutator]MSP[] }
boolean hasData ( final Context context ) { return context . buffer != null ; } public boolean isInAlphabet ( final byte [] arrayOctet , final boolean allowWSPad ) { for ( final byte octet : arrayOctet ) { if ( ! isInAlphabet ( octet ) && MST[rv.UOI2Mutator]MSP[]
boolean hasData ( final Context context ) { return context . buffer != null ; } public boolean isInAlphabet ( final byte [] arrayOctet , final boolean allowWSPad ) { for ( final byte octet : arrayOctet ) { if ( ! isInAlphabet ( octet ) && MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; MST[rv.AOR3Mutator]MSP[] } return len ; }
for ( final byte element : arrayOctet ) { MST[rv.UOI4Mutator]MSP[] if ( pad == element || isInAlphabet ( element ) ) { return true ; } } return false ; } @Override public byte [] decode ( final byte [] pArray ) {
public boolean isStrictDecoding () { return decodingPolicy == CodecPolicy . STRICT ; MST[rv.CRCR6Mutator]MSP[] } int readResults ( final byte [] b , final int bPos , final int bAvail , final Context context ) { if ( context . buffer != null ) {
final int oldCapacity = context . buffer . length ; int newCapacity = oldCapacity * DEFAULT_BUFFER_RESIZE_FACTOR ; if ( compareUnsigned ( newCapacity , minCapacity ) < 0 ) { MST[rv.ROR3Mutator]MSP[] newCapacity = minCapacity ; } if ( compareUnsigned ( newCapacity , MAX_BUFFER_SIZE ) > 0 ) {
( ! allowWSPad || ( octet != pad ) && ! isWhiteSpace ( octet ) ) ) { return false ; } } return true ; MST[rv.CRCR2Mutator]MSP[] } public boolean isInAlphabet ( final String basen ) { return isInAlphabet ( StringUtils . getBytesUtf8 ( basen ) , true ) ; }
boolean hasData ( final Context context ) { return context . buffer != null ; } public boolean isInAlphabet ( final byte [] arrayOctet , final boolean allowWSPad ) { for ( final byte octet : arrayOctet ) { if ( ! isInAlphabet ( octet ) && MST[NonVoidMethodCallMutator]MSP[]
boolean hasData ( final Context context ) { return context . buffer != null ; } public boolean isInAlphabet ( final byte [] arrayOctet , final boolean allowWSPad ) { for ( final byte octet : arrayOctet ) { if ( ! isInAlphabet ( octet ) && MST[rv.UOI3Mutator]MSP[]
readResults ( buf , 0 , buf . length , context ) ; MST[InlineConstantMutator]MSP[] return buf ; } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof byte [] ) ) { throw new EncoderException ( lr_6 ) ; }
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { MST[ConditionalsBoundaryMutator]MSP[] len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; } return len ; }
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; MST[rv.UOI1Mutator]MSP[] if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; } return len ; }
final byte [] result = new byte [ context . pos ] ; readResults ( result , 0 , result . length , context ) ; return result ; } @Override public Object decode ( final Object obj ) throws DecoderException { if ( obj instanceof byte [] ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
int available ( final Context context ) { return context . buffer != null ? context . pos - context . readPos : 0 ; MST[rv.AOR3Mutator]MSP[] } protected boolean containsAlphabetOrPad ( final byte [] arrayOctet ) { if ( arrayOctet == null ) { return false ; }
readResults ( buf , 0 , buf . length , context ) ; return buf ; MST[NullReturnValsMutator]MSP[] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof byte [] ) ) { throw new EncoderException ( lr_6 ) ; }
( ! allowWSPad || ( octet != pad ) && ! isWhiteSpace ( octet ) ) ) { return false ; } } return true ; } public boolean isInAlphabet ( final String basen ) { return isInAlphabet ( StringUtils . getBytesUtf8 ( basen ) , true ) ; MST[rv.CRCR5Mutator]MSP[] }
int available ( final Context context ) { return context . buffer != null ? context . pos - context . readPos : 0 ; } protected boolean containsAlphabetOrPad ( final byte [] arrayOctet ) { if ( arrayOctet == null ) { return false ; MST[BooleanTrueReturnValsMutator]MSP[] }
private static int compareUnsigned ( final int x , final int y ) { return Integer . compare ( x + Integer . MIN_VALUE , y + Integer . MIN_VALUE ) ; } private static int createPositiveCapacity ( final int minCapacity ) { if ( minCapacity < 0 ) { MST[rv.ROR4Mutator]MSP[]
final byte [] result = new byte [ context . pos ] ; readResults ( result , 0 , result . length , context ) ; return result ; MST[NullReturnValsMutator]MSP[] } @Override public Object decode ( final Object obj ) throws DecoderException { if ( obj instanceof byte [] ) {
( ! allowWSPad || ( octet != pad ) && ! isWhiteSpace ( octet ) ) ) { return false ; } } return true ; } public boolean isInAlphabet ( final String basen ) { return isInAlphabet ( StringUtils . getBytesUtf8 ( basen ) , true ) ; MST[ReturnValsMutator]MSP[] }
if ( pArray == null || pArray . length == 0 ) { MST[rv.ROR4Mutator]MSP[] return pArray ; } final Context context = new Context () ; decode ( pArray , 0 , pArray . length , context ) ; decode ( pArray , 0 , EOF , context ) ;
return decode ( ( byte [] ) obj ) ; } else if ( obj instanceof String ) { MST[rv.ROR2Mutator]MSP[] return decode ( ( String ) obj ) ; } else { throw new DecoderException ( lr_5 ) ; } } public byte [] decode ( final String pArray ) {
throw new OutOfMemoryError ( lr_4 + ( minCapacity & 0xffffffffL ) ) ; } return ( minCapacity > MAX_BUFFER_SIZE ) ? MST[rv.UOI2Mutator]MSP[] minCapacity : MAX_BUFFER_SIZE ; } public static byte [] getChunkSeparator () { return CHUNK_SEPARATOR . clone () ; } protected static boolean isWhiteSpace ( final byte byteToCheck ) {
newCapacity = createPositiveCapacity ( minCapacity ) ; } final byte [] b = new byte [ newCapacity ] ; System . arraycopy ( context . buffer , 0 , b , 0 , context . buffer . length ) ; MST[rv.CRCR6Mutator]MSP[] context . buffer = b ; return b ; }
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; MST[rv.UOI2Mutator]MSP[] } return len ; }
if ( pArray == null || pArray . length == 0 ) { return pArray ; } final Context context = new Context () ; decode ( pArray , 0 , pArray . length , context ) ; decode ( pArray , 0 , EOF , context ) ; MST[rv.CRCR1Mutator]MSP[]
throw new OutOfMemoryError ( lr_4 + ( minCapacity & 0xffffffffL ) ) ; } return ( minCapacity > MAX_BUFFER_SIZE ) ? MST[rv.UOI1Mutator]MSP[] minCapacity : MAX_BUFFER_SIZE ; } public static byte [] getChunkSeparator () { return CHUNK_SEPARATOR . clone () ; } protected static boolean isWhiteSpace ( final byte byteToCheck ) {
for ( final byte element : arrayOctet ) { if ( pad == element || isInAlphabet ( element ) ) { return true ; } } return false ; MST[rv.CRCR6Mutator]MSP[] } @Override public byte [] decode ( final byte [] pArray ) {
final byte [] result = new byte [ context . pos ] ; readResults ( result , 0 , result . length , context ) ; MST[InlineConstantMutator]MSP[] return result ; } @Override public Object decode ( final Object obj ) throws DecoderException { if ( obj instanceof byte [] ) {
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; MST[rv.AOR1Mutator]MSP[] } return len ; }
throw new OutOfMemoryError ( lr_4 + ( minCapacity & 0xffffffffL ) ) ; MST[rv.CRCR2Mutator]MSP[] } return ( minCapacity > MAX_BUFFER_SIZE ) ? minCapacity : MAX_BUFFER_SIZE ; } public static byte [] getChunkSeparator () { return CHUNK_SEPARATOR . clone () ; } protected static boolean isWhiteSpace ( final byte byteToCheck ) {
final Context context = new Context () ; encode ( pArray , offset , length , context ) ; encode ( pArray , offset , EOF , context ) ; final byte [] buf = new byte [ context . pos - context . readPos ] ; MST[rv.UOI2Mutator]MSP[]
return StringUtils . newStringUtf8 ( encode ( pArray ) ) ; MST[EmptyObjectReturnValsMutator]MSP[] } protected byte [] ensureBufferSize ( final int size , final Context context ) { if ( context . buffer == null ) {
private static int compareUnsigned ( final int x , final int y ) { return Integer . compare ( x + Integer . MIN_VALUE , y + Integer . MIN_VALUE ) ; MST[rv.ABSMutator]MSP[] } private static int createPositiveCapacity ( final int minCapacity ) { if ( minCapacity < 0 ) {
throw new OutOfMemoryError ( lr_4 + ( minCapacity & 0xffffffffL ) ) ; MST[rv.CRCR4Mutator]MSP[] } return ( minCapacity > MAX_BUFFER_SIZE ) ? minCapacity : MAX_BUFFER_SIZE ; } public static byte [] getChunkSeparator () { return CHUNK_SEPARATOR . clone () ; } protected static boolean isWhiteSpace ( final byte byteToCheck ) {
final int oldCapacity = context . buffer . length ; int newCapacity = oldCapacity * DEFAULT_BUFFER_RESIZE_FACTOR ; if ( compareUnsigned ( newCapacity , minCapacity ) < 0 ) { MST[rv.UOI3Mutator]MSP[] newCapacity = minCapacity ; } if ( compareUnsigned ( newCapacity , MAX_BUFFER_SIZE ) > 0 ) {
switch ( byteToCheck ) { case ' ' : case '\n' : case '\r' : case '\t' : return true ; MST[BooleanFalseReturnValsMutator]MSP[] default : return false ; } } private static byte [] resizeBuffer ( final Context context , final int minCapacity ) {
final int oldCapacity = context . buffer . length ; int newCapacity = oldCapacity * DEFAULT_BUFFER_RESIZE_FACTOR ; if ( compareUnsigned ( newCapacity , minCapacity ) < 0 ) { newCapacity = minCapacity ; MST[rv.UOI4Mutator]MSP[] } if ( compareUnsigned ( newCapacity , MAX_BUFFER_SIZE ) > 0 ) {
boolean hasData ( final Context context ) { return context . buffer != null ; } public boolean isInAlphabet ( final byte [] arrayOctet , final boolean allowWSPad ) { for ( final byte octet : arrayOctet ) { if ( ! isInAlphabet ( octet ) && MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
final int oldCapacity = context . buffer . length ; int newCapacity = oldCapacity * DEFAULT_BUFFER_RESIZE_FACTOR ; if ( compareUnsigned ( newCapacity , minCapacity ) < 0 ) { MST[rv.UOI1Mutator]MSP[] newCapacity = minCapacity ; } if ( compareUnsigned ( newCapacity , MAX_BUFFER_SIZE ) > 0 ) {
throw new OutOfMemoryError ( lr_4 + ( minCapacity & 0xffffffffL ) ) ; } return ( minCapacity > MAX_BUFFER_SIZE ) ? MST[rv.UOI4Mutator]MSP[] minCapacity : MAX_BUFFER_SIZE ; } public static byte [] getChunkSeparator () { return CHUNK_SEPARATOR . clone () ; } protected static boolean isWhiteSpace ( final byte byteToCheck ) {
return decode ( ( byte [] ) obj ) ; MST[NullReturnValsMutator]MSP[] } else if ( obj instanceof String ) { return decode ( ( String ) obj ) ; } else { throw new DecoderException ( lr_5 ) ; } } public byte [] decode ( final String pArray ) {
readResults ( buf , 0 , buf . length , context ) ; return buf ; } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof byte [] ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] throw new EncoderException ( lr_6 ) ; }
switch ( byteToCheck ) { case ' ' : case '\n' : case '\r' : case '\t' : return true ; default : return false ; MST[rv.CRCR5Mutator]MSP[] } } private static byte [] resizeBuffer ( final Context context , final int minCapacity ) {
final byte [] result = new byte [ context . pos ] ; readResults ( result , 0 , result . length , context ) ; return result ; } @Override public Object decode ( final Object obj ) throws DecoderException { if ( obj instanceof byte [] ) { MST[rv.ROR5Mutator]MSP[]
for ( final byte element : arrayOctet ) { if ( pad == element || isInAlphabet ( element ) ) { return true ; } } return false ; MST[rv.CRCR1Mutator]MSP[] } @Override public byte [] decode ( final byte [] pArray ) {
final int len = Math . min ( available ( context ) , bAvail ) ; System . arraycopy ( context . buffer , context . readPos , b , bPos , len ) ; MST[rv.UOI3Mutator]MSP[] context . readPos += len ;
throw new OutOfMemoryError ( lr_4 + ( minCapacity & 0xffffffffL ) ) ; MST[NonVoidMethodCallMutator]MSP[] } return ( minCapacity > MAX_BUFFER_SIZE ) ? minCapacity : MAX_BUFFER_SIZE ; } public static byte [] getChunkSeparator () { return CHUNK_SEPARATOR . clone () ; } protected static boolean isWhiteSpace ( final byte byteToCheck ) {
private static int compareUnsigned ( final int x , final int y ) { return Integer . compare ( x + Integer . MIN_VALUE , y + Integer . MIN_VALUE ) ; MST[rv.CRCR2Mutator]MSP[] } private static int createPositiveCapacity ( final int minCapacity ) { if ( minCapacity < 0 ) {
return encode ( pArray , 0 , pArray . length ) ; MST[rv.CRCR3Mutator]MSP[] } public byte [] encode ( final byte [] pArray , final int offset , final int length ) { if ( pArray == null || pArray . length == 0 ) { return pArray ; }
for ( final byte element : arrayOctet ) { MST[rv.UOI3Mutator]MSP[] if ( pad == element || isInAlphabet ( element ) ) { return true ; } } return false ; } @Override public byte [] decode ( final byte [] pArray ) {
final byte [] result = new byte [ context . pos ] ; readResults ( result , 0 , result . length , context ) ; return result ; } @Override public Object decode ( final Object obj ) throws DecoderException { if ( obj instanceof byte [] ) { MST[rv.ROR3Mutator]MSP[]
newCapacity = createPositiveCapacity ( minCapacity ) ; } final byte [] b = new byte [ newCapacity ] ; System . arraycopy ( context . buffer , 0 , b , 0 , context . buffer . length ) ; MST[InlineConstantMutator]MSP[] context . buffer = b ; return b ; }
for ( final byte element : arrayOctet ) { if ( pad == element || isInAlphabet ( element ) ) { return true ; } } return false ; MST[rv.CRCR3Mutator]MSP[] } @Override public byte [] decode ( final byte [] pArray ) {
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; MST[rv.AOR3Mutator]MSP[] } return len ; }
return decode ( ( byte [] ) obj ) ; } else if ( obj instanceof String ) { return decode ( ( String ) obj ) ; } else { throw new DecoderException ( lr_5 ) ; MST[ConstructorCallMutator]MSP[] } } public byte [] decode ( final String pArray ) {
switch ( byteToCheck ) { case ' ' : case '\n' : case '\r' : case '\t' : return true ; MST[rv.CRCR4Mutator]MSP[] default : return false ; } } private static byte [] resizeBuffer ( final Context context , final int minCapacity ) {
for ( final byte element : arrayOctet ) { if ( pad == element || isInAlphabet ( element ) ) { MST[NegateConditionalsMutator]MSP[] return true ; } } return false ; } @Override public byte [] decode ( final byte [] pArray ) {
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; MST[rv.AOR4Mutator]MSP[] } return len ; }
boolean hasData ( final Context context ) { return context . buffer != null ; } public boolean isInAlphabet ( final byte [] arrayOctet , final boolean allowWSPad ) { for ( final byte octet : arrayOctet ) { if ( ! isInAlphabet ( octet ) && MST[rv.ABSMutator]MSP[]
boolean hasData ( final Context context ) { return context . buffer != null ; } public boolean isInAlphabet ( final byte [] arrayOctet , final boolean allowWSPad ) { for ( final byte octet : arrayOctet ) { if ( ! isInAlphabet ( octet ) && MST[rv.UOI3Mutator]MSP[]
if ( pArray == null || pArray . length == 0 ) { return pArray ; } final Context context = new Context () ; decode ( pArray , 0 , pArray . length , context ) ; MST[rv.CRCR3Mutator]MSP[] decode ( pArray , 0 , EOF , context ) ;
newCapacity = createPositiveCapacity ( minCapacity ) ; } final byte [] b = new byte [ newCapacity ] ; System . arraycopy ( context . buffer , 0 , b , 0 , context . buffer . length ) ; MST[InlineConstantMutator]MSP[] context . buffer = b ; return b ; }
if ( pArray == null || pArray . length == 0 ) { return pArray ; } final Context context = new Context () ; decode ( pArray , 0 , pArray . length , context ) ; decode ( pArray , 0 , EOF , context ) ; MST[rv.CRCR5Mutator]MSP[]
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; MST[rv.AOR1Mutator]MSP[] } return len ; }
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; MST[rv.UOI2Mutator]MSP[] } return len ; }
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { MST[rv.ROR2Mutator]MSP[] len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; } return len ; }
return resizeBuffer ( context , context . pos + size ) ; MST[ReturnValsMutator]MSP[] } return context . buffer ; } public CodecPolicy getCodecPolicy () { return decodingPolicy ; } protected int getDefaultBufferSize () { return DEFAULT_BUFFER_SIZE ; } public long getEncodedLength ( final byte [] pArray ) {
final byte [] result = new byte [ context . pos ] ; readResults ( result , 0 , result . length , context ) ; MST[ArgumentPropagationMutator]MSP[] return result ; } @Override public Object decode ( final Object obj ) throws DecoderException { if ( obj instanceof byte [] ) {
( ! allowWSPad || ( octet != pad ) && ! isWhiteSpace ( octet ) ) ) { return false ; } } return true ; } public boolean isInAlphabet ( final String basen ) { return isInAlphabet ( StringUtils . getBytesUtf8 ( basen ) , true ) ; MST[InlineConstantMutator]MSP[] }
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; MST[rv.UOI3Mutator]MSP[] if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; } return len ; }
final int oldCapacity = context . buffer . length ; int newCapacity = oldCapacity * DEFAULT_BUFFER_RESIZE_FACTOR ; if ( compareUnsigned ( newCapacity , minCapacity ) < 0 ) { MST[ConditionalsBoundaryMutator]MSP[] newCapacity = minCapacity ; } if ( compareUnsigned ( newCapacity , MAX_BUFFER_SIZE ) > 0 ) {
boolean hasData ( final Context context ) { return context . buffer != null ; } public boolean isInAlphabet ( final byte [] arrayOctet , final boolean allowWSPad ) { for ( final byte octet : arrayOctet ) { MST[rv.UOI4Mutator]MSP[] if ( ! isInAlphabet ( octet ) &&
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; MST[rv.AOD1Mutator]MSP[] } return len ; }
boolean hasData ( final Context context ) { return context . buffer != null ; } public boolean isInAlphabet ( final byte [] arrayOctet , final boolean allowWSPad ) { for ( final byte octet : arrayOctet ) { MST[rv.ABSMutator]MSP[] if ( ! isInAlphabet ( octet ) &&
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; MST[MathMutator]MSP[] if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; } return len ; }
final int oldCapacity = context . buffer . length ; int newCapacity = oldCapacity * DEFAULT_BUFFER_RESIZE_FACTOR ; if ( compareUnsigned ( newCapacity , minCapacity ) < 0 ) { newCapacity = minCapacity ; } if ( compareUnsigned ( newCapacity , MAX_BUFFER_SIZE ) > 0 ) { MST[rv.CRCR2Mutator]MSP[]
for ( final byte element : arrayOctet ) { if ( pad == element || isInAlphabet ( element ) ) { MST[rv.ROR3Mutator]MSP[] return true ; } } return false ; } @Override public byte [] decode ( final byte [] pArray ) {
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; MST[rv.UOI4Mutator]MSP[] } return len ; }
boolean hasData ( final Context context ) { return context . buffer != null ; } public boolean isInAlphabet ( final byte [] arrayOctet , final boolean allowWSPad ) { for ( final byte octet : arrayOctet ) { if ( ! isInAlphabet ( octet ) && MST[rv.ROR1Mutator]MSP[]
( ! allowWSPad || ( octet != pad ) && ! isWhiteSpace ( octet ) ) ) { return false ; } } return true ; } public boolean isInAlphabet ( final String basen ) { return isInAlphabet ( StringUtils . getBytesUtf8 ( basen ) , true ) ; MST[NonVoidMethodCallMutator]MSP[] }
return StringUtils . newStringUtf8 ( encode ( pArray ) ) ; } protected byte [] ensureBufferSize ( final int size , final Context context ) { if ( context . buffer == null ) { MST[NegateConditionalsMutator]MSP[]
return StringUtils . newStringUtf8 ( encode ( pArray ) ) ; MST[ReturnValsMutator]MSP[] } protected byte [] ensureBufferSize ( final int size , final Context context ) { if ( context . buffer == null ) {
final byte [] result = new byte [ context . pos ] ; MST[rv.UOI1Mutator]MSP[] readResults ( result , 0 , result . length , context ) ; return result ; } @Override public Object decode ( final Object obj ) throws DecoderException { if ( obj instanceof byte [] ) {
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { MST[rv.UOI4Mutator]MSP[] len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; } return len ; }
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; MST[rv.UOI1Mutator]MSP[] } return len ; }
throw new OutOfMemoryError ( lr_4 + ( minCapacity & 0xffffffffL ) ) ; } return ( minCapacity > MAX_BUFFER_SIZE ) ? MST[rv.CRCR6Mutator]MSP[] minCapacity : MAX_BUFFER_SIZE ; } public static byte [] getChunkSeparator () { return CHUNK_SEPARATOR . clone () ; } protected static boolean isWhiteSpace ( final byte byteToCheck ) {
( ! allowWSPad || ( octet != pad ) && ! isWhiteSpace ( octet ) ) ) { return false ; MST[InlineConstantMutator]MSP[] } } return true ; } public boolean isInAlphabet ( final String basen ) { return isInAlphabet ( StringUtils . getBytesUtf8 ( basen ) , true ) ; }
private static int compareUnsigned ( final int x , final int y ) { return Integer . compare ( x + Integer . MIN_VALUE , y + Integer . MIN_VALUE ) ; MST[rv.UOI1Mutator]MSP[] } private static int createPositiveCapacity ( final int minCapacity ) { if ( minCapacity < 0 ) {
int available ( final Context context ) { return context . buffer != null ? context . pos - context . readPos : 0 ; MST[rv.ABSMutator]MSP[] } protected boolean containsAlphabetOrPad ( final byte [] arrayOctet ) { if ( arrayOctet == null ) { return false ; }
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; MST[rv.AOR1Mutator]MSP[] if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; } return len ; }
if ( pArray == null || pArray . length == 0 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return pArray ; } final Context context = new Context () ; decode ( pArray , 0 , pArray . length , context ) ; decode ( pArray , 0 , EOF , context ) ;
throw new OutOfMemoryError ( lr_4 + ( minCapacity & 0xffffffffL ) ) ; MST[rv.UOI1Mutator]MSP[] } return ( minCapacity > MAX_BUFFER_SIZE ) ? minCapacity : MAX_BUFFER_SIZE ; } public static byte [] getChunkSeparator () { return CHUNK_SEPARATOR . clone () ; } protected static boolean isWhiteSpace ( final byte byteToCheck ) {
final int oldCapacity = context . buffer . length ; int newCapacity = oldCapacity * DEFAULT_BUFFER_RESIZE_FACTOR ; if ( compareUnsigned ( newCapacity , minCapacity ) < 0 ) { MST[rv.UOI2Mutator]MSP[] newCapacity = minCapacity ; } if ( compareUnsigned ( newCapacity , MAX_BUFFER_SIZE ) > 0 ) {
throw new OutOfMemoryError ( lr_4 + ( minCapacity & 0xffffffffL ) ) ; } return ( minCapacity > MAX_BUFFER_SIZE ) ? MST[PrimitiveReturnsMutator]MSP[] minCapacity : MAX_BUFFER_SIZE ; } public static byte [] getChunkSeparator () { return CHUNK_SEPARATOR . clone () ; } protected static boolean isWhiteSpace ( final byte byteToCheck ) {
newCapacity = createPositiveCapacity ( minCapacity ) ; } final byte [] b = new byte [ newCapacity ] ; System . arraycopy ( context . buffer , 0 , b , 0 , context . buffer . length ) ; MST[rv.CRCR3Mutator]MSP[] context . buffer = b ; return b ; }
boolean hasData ( final Context context ) { return context . buffer != null ; } public boolean isInAlphabet ( final byte [] arrayOctet , final boolean allowWSPad ) { for ( final byte octet : arrayOctet ) { if ( ! isInAlphabet ( octet ) && MST[rv.ROR4Mutator]MSP[]
final int len = Math . min ( available ( context ) , bAvail ) ; System . arraycopy ( context . buffer , context . readPos , b , bPos , len ) ; MST[rv.UOI3Mutator]MSP[] context . readPos += len ;
final int oldCapacity = context . buffer . length ; int newCapacity = oldCapacity * DEFAULT_BUFFER_RESIZE_FACTOR ; if ( compareUnsigned ( newCapacity , minCapacity ) < 0 ) { MST[rv.ROR5Mutator]MSP[] newCapacity = minCapacity ; } if ( compareUnsigned ( newCapacity , MAX_BUFFER_SIZE ) > 0 ) {
for ( final byte element : arrayOctet ) { MST[rv.UOI2Mutator]MSP[] if ( pad == element || isInAlphabet ( element ) ) { return true ; } } return false ; } @Override public byte [] decode ( final byte [] pArray ) {
boolean hasData ( final Context context ) { return context . buffer != null ; } public boolean isInAlphabet ( final byte [] arrayOctet , final boolean allowWSPad ) { for ( final byte octet : arrayOctet ) { if ( ! isInAlphabet ( octet ) && MST[rv.UOI3Mutator]MSP[]
( ! allowWSPad || ( octet != pad ) && ! isWhiteSpace ( octet ) ) ) { return false ; } } return true ; } public boolean isInAlphabet ( final String basen ) { return isInAlphabet ( StringUtils . getBytesUtf8 ( basen ) , true ) ; MST[BooleanFalseReturnValsMutator]MSP[] }
return encode ( pArray , 0 , pArray . length ) ; MST[InlineConstantMutator]MSP[] } public byte [] encode ( final byte [] pArray , final int offset , final int length ) { if ( pArray == null || pArray . length == 0 ) { return pArray ; }
boolean hasData ( final Context context ) { return context . buffer != null ; } public boolean isInAlphabet ( final byte [] arrayOctet , final boolean allowWSPad ) { for ( final byte octet : arrayOctet ) { if ( ! isInAlphabet ( octet ) && MST[rv.ABSMutator]MSP[]
for ( final byte element : arrayOctet ) { if ( pad == element || isInAlphabet ( element ) ) { return true ; MST[rv.CRCR4Mutator]MSP[] } } return false ; } @Override public byte [] decode ( final byte [] pArray ) {
return decode ( StringUtils . getBytesUtf8 ( pArray ) ) ; } @Override public byte [] encode ( final byte [] pArray ) { if ( pArray == null || pArray . length == 0 ) { MST[NegateConditionalsMutator]MSP[] return pArray ; }
( ! allowWSPad || ( octet != pad ) && ! isWhiteSpace ( octet ) ) ) { MST[rv.ROR2Mutator]MSP[] return false ; } } return true ; } public boolean isInAlphabet ( final String basen ) { return isInAlphabet ( StringUtils . getBytesUtf8 ( basen ) , true ) ; }
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; MST[rv.CRCR6Mutator]MSP[] if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; } return len ; }
return resizeBuffer ( context , context . pos + size ) ; MST[rv.AOD1Mutator]MSP[] } return context . buffer ; } public CodecPolicy getCodecPolicy () { return decodingPolicy ; } protected int getDefaultBufferSize () { return DEFAULT_BUFFER_SIZE ; } public long getEncodedLength ( final byte [] pArray ) {
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; MST[rv.AOD1Mutator]MSP[] if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; } return len ; }
final int oldCapacity = context . buffer . length ; int newCapacity = oldCapacity * DEFAULT_BUFFER_RESIZE_FACTOR ; if ( compareUnsigned ( newCapacity , minCapacity ) < 0 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] newCapacity = minCapacity ; } if ( compareUnsigned ( newCapacity , MAX_BUFFER_SIZE ) > 0 ) {
newCapacity = createPositiveCapacity ( minCapacity ) ; MST[rv.UOI2Mutator]MSP[] } final byte [] b = new byte [ newCapacity ] ; System . arraycopy ( context . buffer , 0 , b , 0 , context . buffer . length ) ; context . buffer = b ; return b ; }
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; MST[rv.UOI1Mutator]MSP[] if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; } return len ; }
for ( final byte element : arrayOctet ) { if ( pad == element || isInAlphabet ( element ) ) { return true ; MST[BooleanFalseReturnValsMutator]MSP[] } } return false ; } @Override public byte [] decode ( final byte [] pArray ) {
newCapacity = createPositiveCapacity ( minCapacity ) ; } final byte [] b = new byte [ newCapacity ] ; MST[rv.UOI4Mutator]MSP[] System . arraycopy ( context . buffer , 0 , b , 0 , context . buffer . length ) ; context . buffer = b ; return b ; }
return encode ( ( byte [] ) obj ) ; MST[ReturnValsMutator]MSP[] } public String encodeAsString ( final byte [] pArray ) { return StringUtils . newStringUtf8 ( encode ( pArray ) ) ; } public String encodeToString ( final byte [] pArray ) {
newCapacity = createPositiveCapacity ( minCapacity ) ; MST[NonVoidMethodCallMutator]MSP[] } final byte [] b = new byte [ newCapacity ] ; System . arraycopy ( context . buffer , 0 , b , 0 , context . buffer . length ) ; context . buffer = b ; return b ; }
return decode ( StringUtils . getBytesUtf8 ( pArray ) ) ; } @Override public byte [] encode ( final byte [] pArray ) { if ( pArray == null || pArray . length == 0 ) { return pArray ; MST[NullReturnValsMutator]MSP[] }
return resizeBuffer ( context , context . pos + size ) ; MST[rv.UOI4Mutator]MSP[] } return context . buffer ; } public CodecPolicy getCodecPolicy () { return decodingPolicy ; } protected int getDefaultBufferSize () { return DEFAULT_BUFFER_SIZE ; } public long getEncodedLength ( final byte [] pArray ) {
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; MST[rv.AOR2Mutator]MSP[] if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; } return len ; }
return encode ( pArray , 0 , pArray . length ) ; MST[NonVoidMethodCallMutator]MSP[] } public byte [] encode ( final byte [] pArray , final int offset , final int length ) { if ( pArray == null || pArray . length == 0 ) { return pArray ; }
private static int compareUnsigned ( final int x , final int y ) { return Integer . compare ( x + Integer . MIN_VALUE , y + Integer . MIN_VALUE ) ; } private static int createPositiveCapacity ( final int minCapacity ) { if ( minCapacity < 0 ) { MST[rv.UOI3Mutator]MSP[]
throw new OutOfMemoryError ( lr_4 + ( minCapacity & 0xffffffffL ) ) ; } return ( minCapacity > MAX_BUFFER_SIZE ) ? MST[InlineConstantMutator]MSP[] minCapacity : MAX_BUFFER_SIZE ; } public static byte [] getChunkSeparator () { return CHUNK_SEPARATOR . clone () ; } protected static boolean isWhiteSpace ( final byte byteToCheck ) {
boolean hasData ( final Context context ) { return context . buffer != null ; } public boolean isInAlphabet ( final byte [] arrayOctet , final boolean allowWSPad ) { for ( final byte octet : arrayOctet ) { MST[rv.UOI3Mutator]MSP[] if ( ! isInAlphabet ( octet ) &&
return decode ( ( byte [] ) obj ) ; } else if ( obj instanceof String ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return decode ( ( String ) obj ) ; } else { throw new DecoderException ( lr_5 ) ; } } public byte [] decode ( final String pArray ) {
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; MST[rv.AOD2Mutator]MSP[] } return len ; }
final byte [] result = new byte [ context . pos ] ; readResults ( result , 0 , result . length , context ) ; return result ; } @Override public Object decode ( final Object obj ) throws DecoderException { if ( obj instanceof byte [] ) { MST[NegateConditionalsMutator]MSP[]
throw new OutOfMemoryError ( lr_4 + ( minCapacity & 0xffffffffL ) ) ; } return ( minCapacity > MAX_BUFFER_SIZE ) ? MST[rv.CRCR3Mutator]MSP[] minCapacity : MAX_BUFFER_SIZE ; } public static byte [] getChunkSeparator () { return CHUNK_SEPARATOR . clone () ; } protected static boolean isWhiteSpace ( final byte byteToCheck ) {
( ! allowWSPad || ( octet != pad ) && ! isWhiteSpace ( octet ) ) ) { return false ; } } return true ; } public boolean isInAlphabet ( final String basen ) { return isInAlphabet ( StringUtils . getBytesUtf8 ( basen ) , true ) ; MST[NonVoidMethodCallMutator]MSP[] }
if ( context . readPos >= context . pos ) { context . buffer = null ; } return len ; } return context . eof ? EOF : 0 ; MST[rv.CRCR1Mutator]MSP[] }
throw new OutOfMemoryError ( lr_4 + ( minCapacity & 0xffffffffL ) ) ; MST[rv.CRCR1Mutator]MSP[] } return ( minCapacity > MAX_BUFFER_SIZE ) ? minCapacity : MAX_BUFFER_SIZE ; } public static byte [] getChunkSeparator () { return CHUNK_SEPARATOR . clone () ; } protected static boolean isWhiteSpace ( final byte byteToCheck ) {
return resizeBuffer ( context , context . pos + size ) ; MST[NullReturnValsMutator]MSP[] } return context . buffer ; } public CodecPolicy getCodecPolicy () { return decodingPolicy ; } protected int getDefaultBufferSize () { return DEFAULT_BUFFER_SIZE ; } public long getEncodedLength ( final byte [] pArray ) {
final int oldCapacity = context . buffer . length ; int newCapacity = oldCapacity * DEFAULT_BUFFER_RESIZE_FACTOR ; if ( compareUnsigned ( newCapacity , minCapacity ) < 0 ) { newCapacity = minCapacity ; } if ( compareUnsigned ( newCapacity , MAX_BUFFER_SIZE ) > 0 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[]
throw new OutOfMemoryError ( lr_4 + ( minCapacity & 0xffffffffL ) ) ; } return ( minCapacity > MAX_BUFFER_SIZE ) ? MST[rv.CRCR5Mutator]MSP[] minCapacity : MAX_BUFFER_SIZE ; } public static byte [] getChunkSeparator () { return CHUNK_SEPARATOR . clone () ; } protected static boolean isWhiteSpace ( final byte byteToCheck ) {
( ! allowWSPad || ( octet != pad ) && ! isWhiteSpace ( octet ) ) ) { return false ; MST[rv.CRCR5Mutator]MSP[] } } return true ; } public boolean isInAlphabet ( final String basen ) { return isInAlphabet ( StringUtils . getBytesUtf8 ( basen ) , true ) ; }
return decode ( ( byte [] ) obj ) ; MST[ReturnValsMutator]MSP[] } else if ( obj instanceof String ) { return decode ( ( String ) obj ) ; } else { throw new DecoderException ( lr_5 ) ; } } public byte [] decode ( final String pArray ) {
return encode ( ( byte [] ) obj ) ; } public String encodeAsString ( final byte [] pArray ) { return StringUtils . newStringUtf8 ( encode ( pArray ) ) ; MST[NonVoidMethodCallMutator]MSP[] } public String encodeToString ( final byte [] pArray ) {
readResults ( buf , 0 , buf . length , context ) ; return buf ; } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof byte [] ) ) { MST[rv.ROR2Mutator]MSP[] throw new EncoderException ( lr_6 ) ; }
private static int compareUnsigned ( final int x , final int y ) { return Integer . compare ( x + Integer . MIN_VALUE , y + Integer . MIN_VALUE ) ; MST[rv.AOR2Mutator]MSP[] } private static int createPositiveCapacity ( final int minCapacity ) { if ( minCapacity < 0 ) {
private static int compareUnsigned ( final int x , final int y ) { return Integer . compare ( x + Integer . MIN_VALUE , y + Integer . MIN_VALUE ) ; } private static int createPositiveCapacity ( final int minCapacity ) { if ( minCapacity < 0 ) { MST[rv.ROR3Mutator]MSP[]
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; MST[rv.CRCR4Mutator]MSP[] } return len ; }
for ( final byte element : arrayOctet ) { if ( pad == element || isInAlphabet ( element ) ) { MST[NegateConditionalsMutator]MSP[] return true ; } } return false ; } @Override public byte [] decode ( final byte [] pArray ) {
newCapacity = createPositiveCapacity ( minCapacity ) ; } final byte [] b = new byte [ newCapacity ] ; System . arraycopy ( context . buffer , 0 , b , 0 , context . buffer . length ) ; MST[rv.CRCR3Mutator]MSP[] context . buffer = b ; return b ; }
readResults ( buf , 0 , buf . length , context ) ; MST[rv.CRCR5Mutator]MSP[] return buf ; } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof byte [] ) ) { throw new EncoderException ( lr_6 ) ; }
boolean hasData ( final Context context ) { return context . buffer != null ; } public boolean isInAlphabet ( final byte [] arrayOctet , final boolean allowWSPad ) { for ( final byte octet : arrayOctet ) { MST[rv.UOI2Mutator]MSP[] if ( ! isInAlphabet ( octet ) &&
if ( context . readPos >= context . pos ) { context . buffer = null ; } return len ; MST[ReturnValsMutator]MSP[] } return context . eof ? EOF : 0 ; }
boolean hasData ( final Context context ) { return context . buffer != null ; } public boolean isInAlphabet ( final byte [] arrayOctet , final boolean allowWSPad ) { for ( final byte octet : arrayOctet ) { if ( ! isInAlphabet ( octet ) && MST[rv.ABSMutator]MSP[]
throw new OutOfMemoryError ( lr_4 + ( minCapacity & 0xffffffffL ) ) ; } return ( minCapacity > MAX_BUFFER_SIZE ) ? minCapacity : MAX_BUFFER_SIZE ; } public static byte [] getChunkSeparator () { return CHUNK_SEPARATOR . clone () ; MST[NullReturnValsMutator]MSP[] } protected static boolean isWhiteSpace ( final byte byteToCheck ) {
return encode ( ( byte [] ) obj ) ; MST[ArgumentPropagationMutator]MSP[] } public String encodeAsString ( final byte [] pArray ) { return StringUtils . newStringUtf8 ( encode ( pArray ) ) ; } public String encodeToString ( final byte [] pArray ) {
( ! allowWSPad || ( octet != pad ) && ! isWhiteSpace ( octet ) ) ) { return false ; MST[ReturnValsMutator]MSP[] } } return true ; } public boolean isInAlphabet ( final String basen ) { return isInAlphabet ( StringUtils . getBytesUtf8 ( basen ) , true ) ; }
final int oldCapacity = context . buffer . length ; int newCapacity = oldCapacity * DEFAULT_BUFFER_RESIZE_FACTOR ; MST[rv.UOI2Mutator]MSP[] if ( compareUnsigned ( newCapacity , minCapacity ) < 0 ) { newCapacity = minCapacity ; } if ( compareUnsigned ( newCapacity , MAX_BUFFER_SIZE ) > 0 ) {
final int oldCapacity = context . buffer . length ; int newCapacity = oldCapacity * DEFAULT_BUFFER_RESIZE_FACTOR ; if ( compareUnsigned ( newCapacity , minCapacity ) < 0 ) { newCapacity = minCapacity ; } if ( compareUnsigned ( newCapacity , MAX_BUFFER_SIZE ) > 0 ) { MST[ConditionalsBoundaryMutator]MSP[]
return resizeBuffer ( context , context . pos + size ) ; } return context . buffer ; } public CodecPolicy getCodecPolicy () { return decodingPolicy ; MST[ReturnValsMutator]MSP[] } protected int getDefaultBufferSize () { return DEFAULT_BUFFER_SIZE ; } public long getEncodedLength ( final byte [] pArray ) {
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; MST[rv.ABSMutator]MSP[] if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; } return len ; }
( ! allowWSPad || ( octet != pad ) && ! isWhiteSpace ( octet ) ) ) { MST[rv.ROR1Mutator]MSP[] return false ; } } return true ; } public boolean isInAlphabet ( final String basen ) { return isInAlphabet ( StringUtils . getBytesUtf8 ( basen ) , true ) ; }
for ( final byte element : arrayOctet ) { if ( pad == element || isInAlphabet ( element ) ) { return true ; MST[rv.CRCR6Mutator]MSP[] } } return false ; } @Override public byte [] decode ( final byte [] pArray ) {
return encode ( ( byte [] ) obj ) ; } public String encodeAsString ( final byte [] pArray ) { return StringUtils . newStringUtf8 ( encode ( pArray ) ) ; MST[EmptyObjectReturnValsMutator]MSP[] } public String encodeToString ( final byte [] pArray ) {
newCapacity = createPositiveCapacity ( minCapacity ) ; MST[rv.UOI4Mutator]MSP[] } final byte [] b = new byte [ newCapacity ] ; System . arraycopy ( context . buffer , 0 , b , 0 , context . buffer . length ) ; context . buffer = b ; return b ; }
final Context context = new Context () ; encode ( pArray , offset , length , context ) ; encode ( pArray , offset , EOF , context ) ; final byte [] buf = new byte [ context . pos - context . readPos ] ; MST[rv.AOR4Mutator]MSP[]
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; MST[rv.UOI3Mutator]MSP[] if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; } return len ; }
final int oldCapacity = context . buffer . length ; int newCapacity = oldCapacity * DEFAULT_BUFFER_RESIZE_FACTOR ; MST[InlineConstantMutator]MSP[] if ( compareUnsigned ( newCapacity , minCapacity ) < 0 ) { newCapacity = minCapacity ; } if ( compareUnsigned ( newCapacity , MAX_BUFFER_SIZE ) > 0 ) {
return decode ( ( byte [] ) obj ) ; } else if ( obj instanceof String ) { MST[rv.ROR4Mutator]MSP[] return decode ( ( String ) obj ) ; } else { throw new DecoderException ( lr_5 ) ; } } public byte [] decode ( final String pArray ) {
boolean hasData ( final Context context ) { return context . buffer != null ; } public boolean isInAlphabet ( final byte [] arrayOctet , final boolean allowWSPad ) { for ( final byte octet : arrayOctet ) { MST[rv.ABSMutator]MSP[] if ( ! isInAlphabet ( octet ) &&
return encode ( pArray , 0 , pArray . length ) ; MST[rv.CRCR6Mutator]MSP[] } public byte [] encode ( final byte [] pArray , final int offset , final int length ) { if ( pArray == null || pArray . length == 0 ) { return pArray ; }
if ( pArray == null || pArray . length == 0 ) { MST[rv.ROR2Mutator]MSP[] return pArray ; } final Context context = new Context () ; decode ( pArray , 0 , pArray . length , context ) ; decode ( pArray , 0 , EOF , context ) ;
throw new OutOfMemoryError ( lr_4 + ( minCapacity & 0xffffffffL ) ) ; } return ( minCapacity > MAX_BUFFER_SIZE ) ? MST[rv.UOI3Mutator]MSP[] minCapacity : MAX_BUFFER_SIZE ; } public static byte [] getChunkSeparator () { return CHUNK_SEPARATOR . clone () ; } protected static boolean isWhiteSpace ( final byte byteToCheck ) {
throw new OutOfMemoryError ( lr_4 + ( minCapacity & 0xffffffffL ) ) ; } return ( minCapacity > MAX_BUFFER_SIZE ) ? MST[rv.UOI4Mutator]MSP[] minCapacity : MAX_BUFFER_SIZE ; } public static byte [] getChunkSeparator () { return CHUNK_SEPARATOR . clone () ; } protected static boolean isWhiteSpace ( final byte byteToCheck ) {
final Context context = new Context () ; encode ( pArray , offset , length , context ) ; MST[rv.UOI3Mutator]MSP[] encode ( pArray , offset , EOF , context ) ; final byte [] buf = new byte [ context . pos - context . readPos ] ;
private static int compareUnsigned ( final int x , final int y ) { return Integer . compare ( x + Integer . MIN_VALUE , y + Integer . MIN_VALUE ) ; } private static int createPositiveCapacity ( final int minCapacity ) { if ( minCapacity < 0 ) { MST[rv.ABSMutator]MSP[]
final int oldCapacity = context . buffer . length ; int newCapacity = oldCapacity * DEFAULT_BUFFER_RESIZE_FACTOR ; if ( compareUnsigned ( newCapacity , minCapacity ) < 0 ) { newCapacity = minCapacity ; } if ( compareUnsigned ( newCapacity , MAX_BUFFER_SIZE ) > 0 ) { MST[rv.UOI2Mutator]MSP[]
return decode ( StringUtils . getBytesUtf8 ( pArray ) ) ; MST[ArgumentPropagationMutator]MSP[] } @Override public byte [] encode ( final byte [] pArray ) { if ( pArray == null || pArray . length == 0 ) { return pArray ; }
boolean hasData ( final Context context ) { return context . buffer != null ; } public boolean isInAlphabet ( final byte [] arrayOctet , final boolean allowWSPad ) { for ( final byte octet : arrayOctet ) { if ( ! isInAlphabet ( octet ) && MST[rv.UOI2Mutator]MSP[]
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; MST[rv.AOR3Mutator]MSP[] } return len ; }
final int oldCapacity = context . buffer . length ; int newCapacity = oldCapacity * DEFAULT_BUFFER_RESIZE_FACTOR ; if ( compareUnsigned ( newCapacity , minCapacity ) < 0 ) { newCapacity = minCapacity ; } if ( compareUnsigned ( newCapacity , MAX_BUFFER_SIZE ) > 0 ) { MST[NonVoidMethodCallMutator]MSP[]
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { MST[rv.UOI1Mutator]MSP[] len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; } return len ; }
readResults ( buf , 0 , buf . length , context ) ; return buf ; } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof byte [] ) ) { throw new EncoderException ( lr_6 ) ; MST[ConstructorCallMutator]MSP[] }
boolean hasData ( final Context context ) { return context . buffer != null ; MST[rv.CRCR5Mutator]MSP[] } public boolean isInAlphabet ( final byte [] arrayOctet , final boolean allowWSPad ) { for ( final byte octet : arrayOctet ) { if ( ! isInAlphabet ( octet ) &&
final int oldCapacity = context . buffer . length ; int newCapacity = oldCapacity * DEFAULT_BUFFER_RESIZE_FACTOR ; if ( compareUnsigned ( newCapacity , minCapacity ) < 0 ) { newCapacity = minCapacity ; } if ( compareUnsigned ( newCapacity , MAX_BUFFER_SIZE ) > 0 ) { MST[rv.ABSMutator]MSP[]
private static int compareUnsigned ( final int x , final int y ) { return Integer . compare ( x + Integer . MIN_VALUE , y + Integer . MIN_VALUE ) ; MST[rv.UOI2Mutator]MSP[] } private static int createPositiveCapacity ( final int minCapacity ) { if ( minCapacity < 0 ) {
( ! allowWSPad || ( octet != pad ) && ! isWhiteSpace ( octet ) ) ) { return false ; } } return true ; MST[BooleanFalseReturnValsMutator]MSP[] } public boolean isInAlphabet ( final String basen ) { return isInAlphabet ( StringUtils . getBytesUtf8 ( basen ) , true ) ; }
context . buffer = new byte [ Math . max ( size , getDefaultBufferSize () ) ] ; context . pos = 0 ; MST[rv.CRCR6Mutator]MSP[] context . readPos = 0 ; } else if ( context . pos + size - context . buffer . length > 0 ) {
boolean hasData ( final Context context ) { return context . buffer != null ; } public boolean isInAlphabet ( final byte [] arrayOctet , final boolean allowWSPad ) { for ( final byte octet : arrayOctet ) { MST[rv.UOI3Mutator]MSP[] if ( ! isInAlphabet ( octet ) &&
return resizeBuffer ( context , context . pos + size ) ; MST[rv.UOI3Mutator]MSP[] } return context . buffer ; } public CodecPolicy getCodecPolicy () { return decodingPolicy ; } protected int getDefaultBufferSize () { return DEFAULT_BUFFER_SIZE ; } public long getEncodedLength ( final byte [] pArray ) {
private static int compareUnsigned ( final int x , final int y ) { return Integer . compare ( x + Integer . MIN_VALUE , y + Integer . MIN_VALUE ) ; } private static int createPositiveCapacity ( final int minCapacity ) { if ( minCapacity < 0 ) { MST[rv.UOI2Mutator]MSP[]
final int oldCapacity = context . buffer . length ; int newCapacity = oldCapacity * DEFAULT_BUFFER_RESIZE_FACTOR ; if ( compareUnsigned ( newCapacity , minCapacity ) < 0 ) { newCapacity = minCapacity ; } if ( compareUnsigned ( newCapacity , MAX_BUFFER_SIZE ) > 0 ) { MST[InlineConstantMutator]MSP[]
boolean hasData ( final Context context ) { return context . buffer != null ; } public boolean isInAlphabet ( final byte [] arrayOctet , final boolean allowWSPad ) { for ( final byte octet : arrayOctet ) { if ( ! isInAlphabet ( octet ) && MST[rv.ABSMutator]MSP[]
final int oldCapacity = context . buffer . length ; int newCapacity = oldCapacity * DEFAULT_BUFFER_RESIZE_FACTOR ; if ( compareUnsigned ( newCapacity , minCapacity ) < 0 ) { newCapacity = minCapacity ; } if ( compareUnsigned ( newCapacity , MAX_BUFFER_SIZE ) > 0 ) { MST[NegateConditionalsMutator]MSP[]
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; MST[rv.AOD1Mutator]MSP[] } return len ; }
private static int compareUnsigned ( final int x , final int y ) { return Integer . compare ( x + Integer . MIN_VALUE , y + Integer . MIN_VALUE ) ; MST[InlineConstantMutator]MSP[] } private static int createPositiveCapacity ( final int minCapacity ) { if ( minCapacity < 0 ) {
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; } return len ; MST[rv.UOI3Mutator]MSP[] }
throw new OutOfMemoryError ( lr_4 + ( minCapacity & 0xffffffffL ) ) ; } return ( minCapacity > MAX_BUFFER_SIZE ) ? MST[ReturnValsMutator]MSP[] minCapacity : MAX_BUFFER_SIZE ; } public static byte [] getChunkSeparator () { return CHUNK_SEPARATOR . clone () ; } protected static boolean isWhiteSpace ( final byte byteToCheck ) {
( ! allowWSPad || ( octet != pad ) && ! isWhiteSpace ( octet ) ) ) { return false ; } } return true ; MST[rv.CRCR4Mutator]MSP[] } public boolean isInAlphabet ( final String basen ) { return isInAlphabet ( StringUtils . getBytesUtf8 ( basen ) , true ) ; }
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; MST[rv.UOI1Mutator]MSP[] } return len ; }
return decode ( ( byte [] ) obj ) ; } else if ( obj instanceof String ) { return decode ( ( String ) obj ) ; MST[ReturnValsMutator]MSP[] } else { throw new DecoderException ( lr_5 ) ; } } public byte [] decode ( final String pArray ) {
if ( pArray == null || pArray . length == 0 ) { return pArray ; } final Context context = new Context () ; decode ( pArray , 0 , pArray . length , context ) ; MST[rv.CRCR1Mutator]MSP[] decode ( pArray , 0 , EOF , context ) ;
if ( pArray == null || pArray . length == 0 ) { return pArray ; } final Context context = new Context () ; decode ( pArray , 0 , pArray . length , context ) ; MST[rv.CRCR6Mutator]MSP[] decode ( pArray , 0 , EOF , context ) ;
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; MST[rv.UOI2Mutator]MSP[] } return len ; }
return resizeBuffer ( context , context . pos + size ) ; MST[rv.AOD2Mutator]MSP[] } return context . buffer ; } public CodecPolicy getCodecPolicy () { return decodingPolicy ; } protected int getDefaultBufferSize () { return DEFAULT_BUFFER_SIZE ; } public long getEncodedLength ( final byte [] pArray ) {
boolean hasData ( final Context context ) { return context . buffer != null ; } public boolean isInAlphabet ( final byte [] arrayOctet , final boolean allowWSPad ) { for ( final byte octet : arrayOctet ) { if ( ! isInAlphabet ( octet ) && MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
private static int compareUnsigned ( final int x , final int y ) { return Integer . compare ( x + Integer . MIN_VALUE , y + Integer . MIN_VALUE ) ; MST[rv.UOI1Mutator]MSP[] } private static int createPositiveCapacity ( final int minCapacity ) { if ( minCapacity < 0 ) {
throw new OutOfMemoryError ( lr_4 + ( minCapacity & 0xffffffffL ) ) ; MST[rv.OBBN2Mutator]MSP[] } return ( minCapacity > MAX_BUFFER_SIZE ) ? minCapacity : MAX_BUFFER_SIZE ; } public static byte [] getChunkSeparator () { return CHUNK_SEPARATOR . clone () ; } protected static boolean isWhiteSpace ( final byte byteToCheck ) {
final byte [] result = new byte [ context . pos ] ; readResults ( result , 0 , result . length , context ) ; return result ; MST[ReturnValsMutator]MSP[] } @Override public Object decode ( final Object obj ) throws DecoderException { if ( obj instanceof byte [] ) {
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; MST[rv.AOR1Mutator]MSP[] if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; } return len ; }
context . buffer = new byte [ Math . max ( size , getDefaultBufferSize () ) ] ; context . pos = 0 ; context . readPos = 0 ; } else if ( context . pos + size - context . buffer . length > 0 ) { MST[rv.UOI4Mutator]MSP[]
boolean hasData ( final Context context ) { return context . buffer != null ; } public boolean isInAlphabet ( final byte [] arrayOctet , final boolean allowWSPad ) { for ( final byte octet : arrayOctet ) { if ( ! isInAlphabet ( octet ) && MST[rv.ROR3Mutator]MSP[]
throw new OutOfMemoryError ( lr_4 + ( minCapacity & 0xffffffffL ) ) ; } return ( minCapacity > MAX_BUFFER_SIZE ) ? minCapacity : MAX_BUFFER_SIZE ; } public static byte [] getChunkSeparator () { return CHUNK_SEPARATOR . clone () ; MST[ReturnValsMutator]MSP[] } protected static boolean isWhiteSpace ( final byte byteToCheck ) {
for ( final byte element : arrayOctet ) { if ( pad == element || isInAlphabet ( element ) ) { MST[rv.ROR5Mutator]MSP[] return true ; } } return false ; } @Override public byte [] decode ( final byte [] pArray ) {
final byte [] result = new byte [ context . pos ] ; readResults ( result , 0 , result . length , context ) ; MST[rv.CRCR3Mutator]MSP[] return result ; } @Override public Object decode ( final Object obj ) throws DecoderException { if ( obj instanceof byte [] ) {
final int oldCapacity = context . buffer . length ; int newCapacity = oldCapacity * DEFAULT_BUFFER_RESIZE_FACTOR ; MST[rv.ABSMutator]MSP[] if ( compareUnsigned ( newCapacity , minCapacity ) < 0 ) { newCapacity = minCapacity ; } if ( compareUnsigned ( newCapacity , MAX_BUFFER_SIZE ) > 0 ) {
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; MST[rv.AOR2Mutator]MSP[] } return len ; }
boolean hasData ( final Context context ) { return context . buffer != null ; } public boolean isInAlphabet ( final byte [] arrayOctet , final boolean allowWSPad ) { for ( final byte octet : arrayOctet ) { if ( ! isInAlphabet ( octet ) && MST[rv.UOI2Mutator]MSP[]
return decode ( ( byte [] ) obj ) ; } else if ( obj instanceof String ) { return decode ( ( String ) obj ) ; MST[NullReturnValsMutator]MSP[] } else { throw new DecoderException ( lr_5 ) ; } } public byte [] decode ( final String pArray ) {
readResults ( buf , 0 , buf . length , context ) ; return buf ; } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof byte [] ) ) { MST[rv.ROR5Mutator]MSP[] throw new EncoderException ( lr_6 ) ; }
private static int compareUnsigned ( final int x , final int y ) { return Integer . compare ( x + Integer . MIN_VALUE , y + Integer . MIN_VALUE ) ; MST[rv.CRCR5Mutator]MSP[] } private static int createPositiveCapacity ( final int minCapacity ) { if ( minCapacity < 0 ) {
( ! allowWSPad || ( octet != pad ) && ! isWhiteSpace ( octet ) ) ) { return false ; } } return true ; MST[InlineConstantMutator]MSP[] } public boolean isInAlphabet ( final String basen ) { return isInAlphabet ( StringUtils . getBytesUtf8 ( basen ) , true ) ; }
final int oldCapacity = context . buffer . length ; int newCapacity = oldCapacity * DEFAULT_BUFFER_RESIZE_FACTOR ; if ( compareUnsigned ( newCapacity , minCapacity ) < 0 ) { newCapacity = minCapacity ; } if ( compareUnsigned ( newCapacity , MAX_BUFFER_SIZE ) > 0 ) { MST[rv.ROR5Mutator]MSP[]
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; MST[rv.ABSMutator]MSP[] } return len ; }
throw new OutOfMemoryError ( lr_4 + ( minCapacity & 0xffffffffL ) ) ; MST[rv.CRCR6Mutator]MSP[] } return ( minCapacity > MAX_BUFFER_SIZE ) ? minCapacity : MAX_BUFFER_SIZE ; } public static byte [] getChunkSeparator () { return CHUNK_SEPARATOR . clone () ; } protected static boolean isWhiteSpace ( final byte byteToCheck ) {
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; MST[rv.AOD1Mutator]MSP[] if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; } return len ; }
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[] len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; } return len ; }
final Context context = new Context () ; encode ( pArray , offset , length , context ) ; encode ( pArray , offset , EOF , context ) ; final byte [] buf = new byte [ context . pos - context . readPos ] ; MST[rv.UOI4Mutator]MSP[]
return StringUtils . newStringUtf8 ( encode ( pArray ) ) ; MST[NonVoidMethodCallMutator]MSP[] } protected byte [] ensureBufferSize ( final int size , final Context context ) { if ( context . buffer == null ) {
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; MST[rv.AOR2Mutator]MSP[] if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; } return len ; }
for ( final byte element : arrayOctet ) { MST[rv.ABSMutator]MSP[] if ( pad == element || isInAlphabet ( element ) ) { return true ; } } return false ; } @Override public byte [] decode ( final byte [] pArray ) {
return encode ( pArray , 0 , pArray . length ) ; MST[rv.CRCR1Mutator]MSP[] } public byte [] encode ( final byte [] pArray , final int offset , final int length ) { if ( pArray == null || pArray . length == 0 ) { return pArray ; }
switch ( byteToCheck ) { case ' ' : case '\n' : case '\r' : case '\t' : return true ; MST[rv.CRCR6Mutator]MSP[] default : return false ; } } private static byte [] resizeBuffer ( final Context context , final int minCapacity ) {
final int len = Math . min ( available ( context ) , bAvail ) ; System . arraycopy ( context . buffer , context . readPos , b , bPos , len ) ; context . readPos += len ; MST[rv.ABSMutator]MSP[]
for ( final byte element : arrayOctet ) { if ( pad == element || isInAlphabet ( element ) ) { return true ; } } return false ; MST[rv.CRCR5Mutator]MSP[] } @Override public byte [] decode ( final byte [] pArray ) {
boolean hasData ( final Context context ) { return context . buffer != null ; } public boolean isInAlphabet ( final byte [] arrayOctet , final boolean allowWSPad ) { for ( final byte octet : arrayOctet ) { if ( ! isInAlphabet ( octet ) && MST[NegateConditionalsMutator]MSP[]
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; MST[rv.UOI4Mutator]MSP[] } return len ; }
private static int compareUnsigned ( final int x , final int y ) { return Integer . compare ( x + Integer . MIN_VALUE , y + Integer . MIN_VALUE ) ; MST[rv.CRCR4Mutator]MSP[] } private static int createPositiveCapacity ( final int minCapacity ) { if ( minCapacity < 0 ) {
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; MST[MathMutator]MSP[] } return len ; }
boolean hasData ( final Context context ) { return context . buffer != null ; } public boolean isInAlphabet ( final byte [] arrayOctet , final boolean allowWSPad ) { for ( final byte octet : arrayOctet ) { if ( ! isInAlphabet ( octet ) && MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
throw new OutOfMemoryError ( lr_4 + ( minCapacity & 0xffffffffL ) ) ; MST[ConstructorCallMutator]MSP[] } return ( minCapacity > MAX_BUFFER_SIZE ) ? minCapacity : MAX_BUFFER_SIZE ; } public static byte [] getChunkSeparator () { return CHUNK_SEPARATOR . clone () ; } protected static boolean isWhiteSpace ( final byte byteToCheck ) {
( ! allowWSPad || ( octet != pad ) && ! isWhiteSpace ( octet ) ) ) { return false ; } } return true ; } public boolean isInAlphabet ( final String basen ) { return isInAlphabet ( StringUtils . getBytesUtf8 ( basen ) , true ) ; MST[rv.CRCR2Mutator]MSP[] }
final Context context = new Context () ; encode ( pArray , offset , length , context ) ; encode ( pArray , offset , EOF , context ) ; final byte [] buf = new byte [ context . pos - context . readPos ] ; MST[rv.ABSMutator]MSP[]
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; MST[rv.AOR4Mutator]MSP[] if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; } return len ; }
final Context context = new Context () ; encode ( pArray , offset , length , context ) ; MST[rv.UOI4Mutator]MSP[] encode ( pArray , offset , EOF , context ) ; final byte [] buf = new byte [ context . pos - context . readPos ] ;
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; MST[MathMutator]MSP[] if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; } return len ; }
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; MST[rv.CRCR3Mutator]MSP[] if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; } return len ; }
for ( final byte element : arrayOctet ) { if ( pad == element || isInAlphabet ( element ) ) { return true ; } } return false ; MST[ReturnValsMutator]MSP[] } @Override public byte [] decode ( final byte [] pArray ) {
readResults ( buf , 0 , buf . length , context ) ; return buf ; } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof byte [] ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] throw new EncoderException ( lr_6 ) ; }
( ! allowWSPad || ( octet != pad ) && ! isWhiteSpace ( octet ) ) ) { MST[rv.ROR4Mutator]MSP[] return false ; } } return true ; } public boolean isInAlphabet ( final String basen ) { return isInAlphabet ( StringUtils . getBytesUtf8 ( basen ) , true ) ; }
public boolean isStrictDecoding () { return decodingPolicy == CodecPolicy . STRICT ; MST[rv.CRCR3Mutator]MSP[] } int readResults ( final byte [] b , final int bPos , final int bAvail , final Context context ) { if ( context . buffer != null ) {
boolean hasData ( final Context context ) { return context . buffer != null ; } public boolean isInAlphabet ( final byte [] arrayOctet , final boolean allowWSPad ) { for ( final byte octet : arrayOctet ) { if ( ! isInAlphabet ( octet ) && MST[rv.UOI2Mutator]MSP[]
return encode ( pArray , 0 , pArray . length ) ; } public byte [] encode ( final byte [] pArray , final int offset , final int length ) { if ( pArray == null || pArray . length == 0 ) { return pArray ; MST[NullReturnValsMutator]MSP[] }
return resizeBuffer ( context , context . pos + size ) ; } return context . buffer ; MST[NullReturnValsMutator]MSP[] } public CodecPolicy getCodecPolicy () { return decodingPolicy ; } protected int getDefaultBufferSize () { return DEFAULT_BUFFER_SIZE ; } public long getEncodedLength ( final byte [] pArray ) {
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; MST[rv.UOI3Mutator]MSP[] } return len ; }
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; MST[rv.UOI2Mutator]MSP[] if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; } return len ; }
return resizeBuffer ( context , context . pos + size ) ; MST[rv.AOR1Mutator]MSP[] } return context . buffer ; } public CodecPolicy getCodecPolicy () { return decodingPolicy ; } protected int getDefaultBufferSize () { return DEFAULT_BUFFER_SIZE ; } public long getEncodedLength ( final byte [] pArray ) {
private static int compareUnsigned ( final int x , final int y ) { return Integer . compare ( x + Integer . MIN_VALUE , y + Integer . MIN_VALUE ) ; MST[ReturnValsMutator]MSP[] } private static int createPositiveCapacity ( final int minCapacity ) { if ( minCapacity < 0 ) {
throw new OutOfMemoryError ( lr_4 + ( minCapacity & 0xffffffffL ) ) ; } return ( minCapacity > MAX_BUFFER_SIZE ) ? MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] minCapacity : MAX_BUFFER_SIZE ; } public static byte [] getChunkSeparator () { return CHUNK_SEPARATOR . clone () ; } protected static boolean isWhiteSpace ( final byte byteToCheck ) {
final int oldCapacity = context . buffer . length ; int newCapacity = oldCapacity * DEFAULT_BUFFER_RESIZE_FACTOR ; MST[rv.CRCR4Mutator]MSP[] if ( compareUnsigned ( newCapacity , minCapacity ) < 0 ) { newCapacity = minCapacity ; } if ( compareUnsigned ( newCapacity , MAX_BUFFER_SIZE ) > 0 ) {
final byte [] result = new byte [ context . pos ] ; MST[rv.UOI3Mutator]MSP[] readResults ( result , 0 , result . length , context ) ; return result ; } @Override public Object decode ( final Object obj ) throws DecoderException { if ( obj instanceof byte [] ) {
final byte [] result = new byte [ context . pos ] ; MST[rv.UOI4Mutator]MSP[] readResults ( result , 0 , result . length , context ) ; return result ; } @Override public Object decode ( final Object obj ) throws DecoderException { if ( obj instanceof byte [] ) {
return resizeBuffer ( context , context . pos + size ) ; MST[rv.UOI1Mutator]MSP[] } return context . buffer ; } public CodecPolicy getCodecPolicy () { return decodingPolicy ; } protected int getDefaultBufferSize () { return DEFAULT_BUFFER_SIZE ; } public long getEncodedLength ( final byte [] pArray ) {
return resizeBuffer ( context , context . pos + size ) ; MST[rv.UOI2Mutator]MSP[] } return context . buffer ; } public CodecPolicy getCodecPolicy () { return decodingPolicy ; } protected int getDefaultBufferSize () { return DEFAULT_BUFFER_SIZE ; } public long getEncodedLength ( final byte [] pArray ) {
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; MST[rv.AOR2Mutator]MSP[] if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; } return len ; }
boolean hasData ( final Context context ) { return context . buffer != null ; } public boolean isInAlphabet ( final byte [] arrayOctet , final boolean allowWSPad ) { for ( final byte octet : arrayOctet ) { if ( ! isInAlphabet ( octet ) && MST[rv.UOI4Mutator]MSP[]
final int oldCapacity = context . buffer . length ; int newCapacity = oldCapacity * DEFAULT_BUFFER_RESIZE_FACTOR ; if ( compareUnsigned ( newCapacity , minCapacity ) < 0 ) { MST[rv.UOI4Mutator]MSP[] newCapacity = minCapacity ; } if ( compareUnsigned ( newCapacity , MAX_BUFFER_SIZE ) > 0 ) {
boolean hasData ( final Context context ) { return context . buffer != null ; } public boolean isInAlphabet ( final byte [] arrayOctet , final boolean allowWSPad ) { for ( final byte octet : arrayOctet ) { if ( ! isInAlphabet ( octet ) && MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
if ( pArray == null || pArray . length == 0 ) { MST[rv.ROR5Mutator]MSP[] return pArray ; } final Context context = new Context () ; decode ( pArray , 0 , pArray . length , context ) ; decode ( pArray , 0 , EOF , context ) ;
throw new OutOfMemoryError ( lr_4 + ( minCapacity & 0xffffffffL ) ) ; } return ( minCapacity > MAX_BUFFER_SIZE ) ? MST[ConditionalsBoundaryMutator]MSP[] minCapacity : MAX_BUFFER_SIZE ; } public static byte [] getChunkSeparator () { return CHUNK_SEPARATOR . clone () ; } protected static boolean isWhiteSpace ( final byte byteToCheck ) {
return decode ( ( byte [] ) obj ) ; } else if ( obj instanceof String ) { MST[rv.ROR1Mutator]MSP[] return decode ( ( String ) obj ) ; } else { throw new DecoderException ( lr_5 ) ; } } public byte [] decode ( final String pArray ) {
newCapacity = createPositiveCapacity ( minCapacity ) ; } final byte [] b = new byte [ newCapacity ] ; System . arraycopy ( context . buffer , 0 , b , 0 , context . buffer . length ) ; MST[rv.CRCR5Mutator]MSP[] context . buffer = b ; return b ; }
boolean hasData ( final Context context ) { return context . buffer != null ; } public boolean isInAlphabet ( final byte [] arrayOctet , final boolean allowWSPad ) { for ( final byte octet : arrayOctet ) { MST[rv.UOI1Mutator]MSP[] if ( ! isInAlphabet ( octet ) &&
int available ( final Context context ) { return context . buffer != null ? context . pos - context . readPos : 0 ; } protected boolean containsAlphabetOrPad ( final byte [] arrayOctet ) { if ( arrayOctet == null ) { return false ; MST[rv.CRCR6Mutator]MSP[] }
context . buffer = new byte [ Math . max ( size , getDefaultBufferSize () ) ] ; MST[experimental.MemberVariableMutator]MSP[] context . pos = 0 ; context . readPos = 0 ; } else if ( context . pos + size - context . buffer . length > 0 ) {
return resizeBuffer ( context , context . pos + size ) ; MST[MathMutator]MSP[] } return context . buffer ; } public CodecPolicy getCodecPolicy () { return decodingPolicy ; } protected int getDefaultBufferSize () { return DEFAULT_BUFFER_SIZE ; } public long getEncodedLength ( final byte [] pArray ) {
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; MST[rv.ABSMutator]MSP[] } return len ; }
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; MST[rv.UOI1Mutator]MSP[] } return len ; }
for ( final byte element : arrayOctet ) { MST[rv.UOI4Mutator]MSP[] if ( pad == element || isInAlphabet ( element ) ) { return true ; } } return false ; } @Override public byte [] decode ( final byte [] pArray ) {
throw new OutOfMemoryError ( lr_4 + ( minCapacity & 0xffffffffL ) ) ; MST[rv.ABSMutator]MSP[] } return ( minCapacity > MAX_BUFFER_SIZE ) ? minCapacity : MAX_BUFFER_SIZE ; } public static byte [] getChunkSeparator () { return CHUNK_SEPARATOR . clone () ; } protected static boolean isWhiteSpace ( final byte byteToCheck ) {
switch ( byteToCheck ) { case ' ' : case '\n' : case '\r' : case '\t' : return true ; default : return false ; MST[InlineConstantMutator]MSP[] } } private static byte [] resizeBuffer ( final Context context , final int minCapacity ) {
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; MST[rv.UOI4Mutator]MSP[] } return len ; }
return encode ( pArray , 0 , pArray . length ) ; } public byte [] encode ( final byte [] pArray , final int offset , final int length ) { if ( pArray == null || pArray . length == 0 ) { return pArray ; MST[ReturnValsMutator]MSP[] }
readResults ( buf , 0 , buf . length , context ) ; return buf ; } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof byte [] ) ) { MST[NegateConditionalsMutator]MSP[] throw new EncoderException ( lr_6 ) ; }
final int oldCapacity = context . buffer . length ; int newCapacity = oldCapacity * DEFAULT_BUFFER_RESIZE_FACTOR ; if ( compareUnsigned ( newCapacity , minCapacity ) < 0 ) { newCapacity = minCapacity ; } if ( compareUnsigned ( newCapacity , MAX_BUFFER_SIZE ) > 0 ) { MST[rv.CRCR4Mutator]MSP[]
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { MST[rv.ROR4Mutator]MSP[] len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; } return len ; }
return resizeBuffer ( context , context . pos + size ) ; } return context . buffer ; MST[ReturnValsMutator]MSP[] } public CodecPolicy getCodecPolicy () { return decodingPolicy ; } protected int getDefaultBufferSize () { return DEFAULT_BUFFER_SIZE ; } public long getEncodedLength ( final byte [] pArray ) {
if ( pArray == null || pArray . length == 0 ) { return pArray ; MST[NullReturnValsMutator]MSP[] } final Context context = new Context () ; decode ( pArray , 0 , pArray . length , context ) ; decode ( pArray , 0 , EOF , context ) ;
return resizeBuffer ( context , context . pos + size ) ; MST[NonVoidMethodCallMutator]MSP[] } return context . buffer ; } public CodecPolicy getCodecPolicy () { return decodingPolicy ; } protected int getDefaultBufferSize () { return DEFAULT_BUFFER_SIZE ; } public long getEncodedLength ( final byte [] pArray ) {
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; MST[rv.AOD2Mutator]MSP[] if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; } return len ; }
newCapacity = createPositiveCapacity ( minCapacity ) ; } final byte [] b = new byte [ newCapacity ] ; MST[rv.UOI1Mutator]MSP[] System . arraycopy ( context . buffer , 0 , b , 0 , context . buffer . length ) ; context . buffer = b ; return b ; }
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; MST[rv.CRCR6Mutator]MSP[] } return len ; }
if ( pArray == null || pArray . length == 0 ) { return pArray ; } final Context context = new Context () ; decode ( pArray , 0 , pArray . length , context ) ; decode ( pArray , 0 , EOF , context ) ; MST[VoidMethodCallMutator]MSP[]
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; MST[rv.AOR3Mutator]MSP[] if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; } return len ; }
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; MST[rv.AOD1Mutator]MSP[] } return len ; }
final int oldCapacity = context . buffer . length ; int newCapacity = oldCapacity * DEFAULT_BUFFER_RESIZE_FACTOR ; if ( compareUnsigned ( newCapacity , minCapacity ) < 0 ) { newCapacity = minCapacity ; MST[rv.UOI1Mutator]MSP[] } if ( compareUnsigned ( newCapacity , MAX_BUFFER_SIZE ) > 0 ) {
int available ( final Context context ) { return context . buffer != null ? context . pos - context . readPos : 0 ; } protected boolean containsAlphabetOrPad ( final byte [] arrayOctet ) { if ( arrayOctet == null ) { return false ; MST[rv.CRCR1Mutator]MSP[] }
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; MST[MathMutator]MSP[] if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; } return len ; }
throw new OutOfMemoryError ( lr_4 + ( minCapacity & 0xffffffffL ) ) ; } return ( minCapacity > MAX_BUFFER_SIZE ) ? MST[rv.ROR5Mutator]MSP[] minCapacity : MAX_BUFFER_SIZE ; } public static byte [] getChunkSeparator () { return CHUNK_SEPARATOR . clone () ; } protected static boolean isWhiteSpace ( final byte byteToCheck ) {
boolean hasData ( final Context context ) { return context . buffer != null ; } public boolean isInAlphabet ( final byte [] arrayOctet , final boolean allowWSPad ) { for ( final byte octet : arrayOctet ) { if ( ! isInAlphabet ( octet ) && MST[rv.ROR1Mutator]MSP[]
for ( final byte element : arrayOctet ) { if ( pad == element || isInAlphabet ( element ) ) { MST[rv.ROR5Mutator]MSP[] return true ; } } return false ; } @Override public byte [] decode ( final byte [] pArray ) {
boolean hasData ( final Context context ) { return context . buffer != null ; } public boolean isInAlphabet ( final byte [] arrayOctet , final boolean allowWSPad ) { for ( final byte octet : arrayOctet ) { if ( ! isInAlphabet ( octet ) && MST[rv.ROR3Mutator]MSP[]
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; MST[rv.AOR2Mutator]MSP[] } return len ; }
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { MST[NegateConditionalsMutator]MSP[] len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; } return len ; }
throw new OutOfMemoryError ( lr_4 + ( minCapacity & 0xffffffffL ) ) ; MST[rv.CRCR3Mutator]MSP[] } return ( minCapacity > MAX_BUFFER_SIZE ) ? minCapacity : MAX_BUFFER_SIZE ; } public static byte [] getChunkSeparator () { return CHUNK_SEPARATOR . clone () ; } protected static boolean isWhiteSpace ( final byte byteToCheck ) {
private static int compareUnsigned ( final int x , final int y ) { return Integer . compare ( x + Integer . MIN_VALUE , y + Integer . MIN_VALUE ) ; MST[rv.CRCR4Mutator]MSP[] } private static int createPositiveCapacity ( final int minCapacity ) { if ( minCapacity < 0 ) {
newCapacity = createPositiveCapacity ( minCapacity ) ; MST[rv.ABSMutator]MSP[] } final byte [] b = new byte [ newCapacity ] ; System . arraycopy ( context . buffer , 0 , b , 0 , context . buffer . length ) ; context . buffer = b ; return b ; }
for ( final byte element : arrayOctet ) { if ( pad == element || isInAlphabet ( element ) ) { MST[NonVoidMethodCallMutator]MSP[] return true ; } } return false ; } @Override public byte [] decode ( final byte [] pArray ) {
readResults ( buf , 0 , buf . length , context ) ; return buf ; MST[ReturnValsMutator]MSP[] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof byte [] ) ) { throw new EncoderException ( lr_6 ) ; }
final byte [] result = new byte [ context . pos ] ; readResults ( result , 0 , result . length , context ) ; MST[NonVoidMethodCallMutator]MSP[] return result ; } @Override public Object decode ( final Object obj ) throws DecoderException { if ( obj instanceof byte [] ) {
( ! allowWSPad || ( octet != pad ) && ! isWhiteSpace ( octet ) ) ) { return false ; MST[BooleanTrueReturnValsMutator]MSP[] } } return true ; } public boolean isInAlphabet ( final String basen ) { return isInAlphabet ( StringUtils . getBytesUtf8 ( basen ) , true ) ; }
throw new OutOfMemoryError ( lr_4 + ( minCapacity & 0xffffffffL ) ) ; MST[experimental.NakedReceiverMutator]MSP[] } return ( minCapacity > MAX_BUFFER_SIZE ) ? minCapacity : MAX_BUFFER_SIZE ; } public static byte [] getChunkSeparator () { return CHUNK_SEPARATOR . clone () ; } protected static boolean isWhiteSpace ( final byte byteToCheck ) {
readResults ( buf , 0 , buf . length , context ) ; return buf ; } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof byte [] ) ) { MST[rv.ROR4Mutator]MSP[] throw new EncoderException ( lr_6 ) ; }
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; MST[rv.AOR3Mutator]MSP[] if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; } return len ; }
boolean hasData ( final Context context ) { return context . buffer != null ; } public boolean isInAlphabet ( final byte [] arrayOctet , final boolean allowWSPad ) { for ( final byte octet : arrayOctet ) { if ( ! isInAlphabet ( octet ) && MST[NegateConditionalsMutator]MSP[]
private static int compareUnsigned ( final int x , final int y ) { return Integer . compare ( x + Integer . MIN_VALUE , y + Integer . MIN_VALUE ) ; } private static int createPositiveCapacity ( final int minCapacity ) { if ( minCapacity < 0 ) { MST[rv.ROR5Mutator]MSP[]
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; MST[rv.AOD2Mutator]MSP[] } return len ; }
boolean hasData ( final Context context ) { return context . buffer != null ; } public boolean isInAlphabet ( final byte [] arrayOctet , final boolean allowWSPad ) { for ( final byte octet : arrayOctet ) { MST[rv.UOI4Mutator]MSP[] if ( ! isInAlphabet ( octet ) &&
boolean hasData ( final Context context ) { return context . buffer != null ; } public boolean isInAlphabet ( final byte [] arrayOctet , final boolean allowWSPad ) { for ( final byte octet : arrayOctet ) { if ( ! isInAlphabet ( octet ) && MST[rv.UOI1Mutator]MSP[]
newCapacity = createPositiveCapacity ( minCapacity ) ; } final byte [] b = new byte [ newCapacity ] ; System . arraycopy ( context . buffer , 0 , b , 0 , context . buffer . length ) ; MST[rv.CRCR5Mutator]MSP[] context . buffer = b ; return b ; }
return decode ( StringUtils . getBytesUtf8 ( pArray ) ) ; MST[NonVoidMethodCallMutator]MSP[] } @Override public byte [] encode ( final byte [] pArray ) { if ( pArray == null || pArray . length == 0 ) { return pArray ; }
final int oldCapacity = context . buffer . length ; int newCapacity = oldCapacity * DEFAULT_BUFFER_RESIZE_FACTOR ; MST[rv.UOI4Mutator]MSP[] if ( compareUnsigned ( newCapacity , minCapacity ) < 0 ) { newCapacity = minCapacity ; } if ( compareUnsigned ( newCapacity , MAX_BUFFER_SIZE ) > 0 ) {
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; } return len ; MST[PrimitiveReturnsMutator]MSP[] }
return encode ( pArray , 0 , pArray . length ) ; } public byte [] encode ( final byte [] pArray , final int offset , final int length ) { if ( pArray == null || pArray . length == 0 ) { MST[rv.ROR5Mutator]MSP[] return pArray ; }
if ( context . readPos >= context . pos ) { context . buffer = null ; } return len ; } return context . eof ? EOF : 0 ; MST[rv.ROR2Mutator]MSP[] }
if ( pArray == null || pArray . length == 0 ) { return pArray ; } final Context context = new Context () ; decode ( pArray , 0 , pArray . length , context ) ; decode ( pArray , 0 , EOF , context ) ; MST[rv.CRCR6Mutator]MSP[]
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; MST[InlineConstantMutator]MSP[] } return len ; }
private static int compareUnsigned ( final int x , final int y ) { return Integer . compare ( x + Integer . MIN_VALUE , y + Integer . MIN_VALUE ) ; MST[rv.CRCR3Mutator]MSP[] } private static int createPositiveCapacity ( final int minCapacity ) { if ( minCapacity < 0 ) {
for ( final byte element : arrayOctet ) { if ( pad == element || isInAlphabet ( element ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return true ; } } return false ; } @Override public byte [] decode ( final byte [] pArray ) {
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; MST[rv.UOI1Mutator]MSP[] } return len ; }
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; MST[MathMutator]MSP[] } return len ; }
return decode ( ( byte [] ) obj ) ; } else if ( obj instanceof String ) { return decode ( ( String ) obj ) ; MST[NonVoidMethodCallMutator]MSP[] } else { throw new DecoderException ( lr_5 ) ; } } public byte [] decode ( final String pArray ) {
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { MST[rv.ROR1Mutator]MSP[] len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; } return len ; }
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; MST[rv.AOD1Mutator]MSP[] if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; } return len ; }
newCapacity = createPositiveCapacity ( minCapacity ) ; } final byte [] b = new byte [ newCapacity ] ; MST[rv.UOI3Mutator]MSP[] System . arraycopy ( context . buffer , 0 , b , 0 , context . buffer . length ) ; context . buffer = b ; return b ; }
throw new OutOfMemoryError ( lr_4 + ( minCapacity & 0xffffffffL ) ) ; MST[rv.UOI2Mutator]MSP[] } return ( minCapacity > MAX_BUFFER_SIZE ) ? minCapacity : MAX_BUFFER_SIZE ; } public static byte [] getChunkSeparator () { return CHUNK_SEPARATOR . clone () ; } protected static boolean isWhiteSpace ( final byte byteToCheck ) {
private static int compareUnsigned ( final int x , final int y ) { return Integer . compare ( x + Integer . MIN_VALUE , y + Integer . MIN_VALUE ) ; MST[rv.AOR1Mutator]MSP[] } private static int createPositiveCapacity ( final int minCapacity ) { if ( minCapacity < 0 ) {
boolean hasData ( final Context context ) { return context . buffer != null ; } public boolean isInAlphabet ( final byte [] arrayOctet , final boolean allowWSPad ) { for ( final byte octet : arrayOctet ) { if ( ! isInAlphabet ( octet ) && MST[rv.UOI3Mutator]MSP[]
boolean hasData ( final Context context ) { return context . buffer != null ; } public boolean isInAlphabet ( final byte [] arrayOctet , final boolean allowWSPad ) { for ( final byte octet : arrayOctet ) { MST[rv.UOI1Mutator]MSP[] if ( ! isInAlphabet ( octet ) &&
final byte [] result = new byte [ context . pos ] ; readResults ( result , 0 , result . length , context ) ; MST[rv.CRCR1Mutator]MSP[] return result ; } @Override public Object decode ( final Object obj ) throws DecoderException { if ( obj instanceof byte [] ) {
private static int compareUnsigned ( final int x , final int y ) { return Integer . compare ( x + Integer . MIN_VALUE , y + Integer . MIN_VALUE ) ; MST[MathMutator]MSP[] } private static int createPositiveCapacity ( final int minCapacity ) { if ( minCapacity < 0 ) {
final int oldCapacity = context . buffer . length ; int newCapacity = oldCapacity * DEFAULT_BUFFER_RESIZE_FACTOR ; if ( compareUnsigned ( newCapacity , minCapacity ) < 0 ) { newCapacity = minCapacity ; MST[rv.UOI3Mutator]MSP[] } if ( compareUnsigned ( newCapacity , MAX_BUFFER_SIZE ) > 0 ) {
if ( pArray == null || pArray . length == 0 ) { return pArray ; } final Context context = new Context () ; decode ( pArray , 0 , pArray . length , context ) ; decode ( pArray , 0 , EOF , context ) ; MST[InlineConstantMutator]MSP[]
int available ( final Context context ) { return context . buffer != null ? context . pos - context . readPos : 0 ; } protected boolean containsAlphabetOrPad ( final byte [] arrayOctet ) { if ( arrayOctet == null ) { return false ; MST[rv.CRCR3Mutator]MSP[] }
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; MST[rv.AOR2Mutator]MSP[] } return len ; }
final byte [] result = new byte [ context . pos ] ; readResults ( result , 0 , result . length , context ) ; return result ; } @Override public Object decode ( final Object obj ) throws DecoderException { if ( obj instanceof byte [] ) { MST[rv.ROR2Mutator]MSP[]
( ! allowWSPad || ( octet != pad ) && ! isWhiteSpace ( octet ) ) ) { return false ; } } return true ; } public boolean isInAlphabet ( final String basen ) { return isInAlphabet ( StringUtils . getBytesUtf8 ( basen ) , true ) ; MST[ArgumentPropagationMutator]MSP[] }
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; MST[rv.AOR4Mutator]MSP[] } return len ; }
final int oldCapacity = context . buffer . length ; int newCapacity = oldCapacity * DEFAULT_BUFFER_RESIZE_FACTOR ; if ( compareUnsigned ( newCapacity , minCapacity ) < 0 ) { MST[rv.ABSMutator]MSP[] newCapacity = minCapacity ; } if ( compareUnsigned ( newCapacity , MAX_BUFFER_SIZE ) > 0 ) {
boolean hasData ( final Context context ) { return context . buffer != null ; } public boolean isInAlphabet ( final byte [] arrayOctet , final boolean allowWSPad ) { for ( final byte octet : arrayOctet ) { if ( ! isInAlphabet ( octet ) && MST[rv.ROR5Mutator]MSP[]
boolean hasData ( final Context context ) { return context . buffer != null ; } public boolean isInAlphabet ( final byte [] arrayOctet , final boolean allowWSPad ) { for ( final byte octet : arrayOctet ) { if ( ! isInAlphabet ( octet ) && MST[rv.UOI4Mutator]MSP[]
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { MST[rv.UOI3Mutator]MSP[] len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; } return len ; }
throw new OutOfMemoryError ( lr_4 + ( minCapacity & 0xffffffffL ) ) ; } return ( minCapacity > MAX_BUFFER_SIZE ) ? MST[rv.CRCR5Mutator]MSP[] minCapacity : MAX_BUFFER_SIZE ; } public static byte [] getChunkSeparator () { return CHUNK_SEPARATOR . clone () ; } protected static boolean isWhiteSpace ( final byte byteToCheck ) {
newCapacity = createPositiveCapacity ( minCapacity ) ; } final byte [] b = new byte [ newCapacity ] ; System . arraycopy ( context . buffer , 0 , b , 0 , context . buffer . length ) ; context . buffer = b ; return b ; MST[ReturnValsMutator]MSP[] }
return resizeBuffer ( context , context . pos + size ) ; MST[rv.AOR2Mutator]MSP[] } return context . buffer ; } public CodecPolicy getCodecPolicy () { return decodingPolicy ; } protected int getDefaultBufferSize () { return DEFAULT_BUFFER_SIZE ; } public long getEncodedLength ( final byte [] pArray ) {
final int len = Math . min ( available ( context ) , bAvail ) ; MST[rv.ABSMutator]MSP[] System . arraycopy ( context . buffer , context . readPos , b , bPos , len ) ; context . readPos += len ;
for ( final byte element : arrayOctet ) { if ( pad == element || isInAlphabet ( element ) ) { MST[rv.UOI1Mutator]MSP[] return true ; } } return false ; } @Override public byte [] decode ( final byte [] pArray ) {
return decode ( ( byte [] ) obj ) ; } else if ( obj instanceof String ) { MST[rv.ROR5Mutator]MSP[] return decode ( ( String ) obj ) ; } else { throw new DecoderException ( lr_5 ) ; } } public byte [] decode ( final String pArray ) {
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; MST[rv.AOR2Mutator]MSP[] if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; } return len ; }
if ( pArray == null || pArray . length == 0 ) { MST[rv.ROR1Mutator]MSP[] return pArray ; } final Context context = new Context () ; decode ( pArray , 0 , pArray . length , context ) ; decode ( pArray , 0 , EOF , context ) ;
boolean hasData ( final Context context ) { return context . buffer != null ; } public boolean isInAlphabet ( final byte [] arrayOctet , final boolean allowWSPad ) { for ( final byte octet : arrayOctet ) { MST[rv.ABSMutator]MSP[] if ( ! isInAlphabet ( octet ) &&
final Context context = new Context () ; MST[ConstructorCallMutator]MSP[] encode ( pArray , offset , length , context ) ; encode ( pArray , offset , EOF , context ) ; final byte [] buf = new byte [ context . pos - context . readPos ] ;
final int oldCapacity = context . buffer . length ; int newCapacity = oldCapacity * DEFAULT_BUFFER_RESIZE_FACTOR ; if ( compareUnsigned ( newCapacity , minCapacity ) < 0 ) { newCapacity = minCapacity ; } if ( compareUnsigned ( newCapacity , MAX_BUFFER_SIZE ) > 0 ) { MST[rv.UOI1Mutator]MSP[]
private static int compareUnsigned ( final int x , final int y ) { return Integer . compare ( x + Integer . MIN_VALUE , y + Integer . MIN_VALUE ) ; } private static int createPositiveCapacity ( final int minCapacity ) { if ( minCapacity < 0 ) { MST[rv.UOI4Mutator]MSP[]
final byte [] result = new byte [ context . pos ] ; readResults ( result , 0 , result . length , context ) ; MST[rv.CRCR6Mutator]MSP[] return result ; } @Override public Object decode ( final Object obj ) throws DecoderException { if ( obj instanceof byte [] ) {
boolean hasData ( final Context context ) { return context . buffer != null ; } public boolean isInAlphabet ( final byte [] arrayOctet , final boolean allowWSPad ) { for ( final byte octet : arrayOctet ) { if ( ! isInAlphabet ( octet ) && MST[rv.ROR2Mutator]MSP[]
switch ( byteToCheck ) { MST[experimental.RemoveSwitchMutator_0]MSP[] case ' ' : case '\n' : case '\r' : case '\t' : return true ; default : return false ; } } private static byte [] resizeBuffer ( final Context context , final int minCapacity ) {
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; MST[rv.UOI3Mutator]MSP[] } return len ; }
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; MST[rv.AOR1Mutator]MSP[] } return len ; }
for ( final byte element : arrayOctet ) { if ( pad == element || isInAlphabet ( element ) ) { return true ; MST[rv.CRCR3Mutator]MSP[] } } return false ; } @Override public byte [] decode ( final byte [] pArray ) {
( ! allowWSPad || ( octet != pad ) && ! isWhiteSpace ( octet ) ) ) { MST[rv.ROR3Mutator]MSP[] return false ; } } return true ; } public boolean isInAlphabet ( final String basen ) { return isInAlphabet ( StringUtils . getBytesUtf8 ( basen ) , true ) ; }
if ( pArray == null || pArray . length == 0 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return pArray ; } final Context context = new Context () ; decode ( pArray , 0 , pArray . length , context ) ; decode ( pArray , 0 , EOF , context ) ;
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; MST[rv.AOR1Mutator]MSP[] if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; } return len ; }
if ( pArray == null || pArray . length == 0 ) { return pArray ; } final Context context = new Context () ; MST[ConstructorCallMutator]MSP[] decode ( pArray , 0 , pArray . length , context ) ; decode ( pArray , 0 , EOF , context ) ;
final int oldCapacity = context . buffer . length ; int newCapacity = oldCapacity * DEFAULT_BUFFER_RESIZE_FACTOR ; if ( compareUnsigned ( newCapacity , minCapacity ) < 0 ) { newCapacity = minCapacity ; } if ( compareUnsigned ( newCapacity , MAX_BUFFER_SIZE ) > 0 ) { MST[rv.UOI4Mutator]MSP[]
private static int compareUnsigned ( final int x , final int y ) { return Integer . compare ( x + Integer . MIN_VALUE , y + Integer . MIN_VALUE ) ; } private static int createPositiveCapacity ( final int minCapacity ) { if ( minCapacity < 0 ) { MST[NegateConditionalsMutator]MSP[]
if ( pArray == null || pArray . length == 0 ) { MST[NegateConditionalsMutator]MSP[] return pArray ; } final Context context = new Context () ; decode ( pArray , 0 , pArray . length , context ) ; decode ( pArray , 0 , EOF , context ) ;
throw new OutOfMemoryError ( lr_4 + ( minCapacity & 0xffffffffL ) ) ; MST[NonVoidMethodCallMutator]MSP[] } return ( minCapacity > MAX_BUFFER_SIZE ) ? minCapacity : MAX_BUFFER_SIZE ; } public static byte [] getChunkSeparator () { return CHUNK_SEPARATOR . clone () ; } protected static boolean isWhiteSpace ( final byte byteToCheck ) {
switch ( byteToCheck ) { case ' ' : case '\n' : case '\r' : case '\t' : return true ; MST[rv.CRCR3Mutator]MSP[] default : return false ; } } private static byte [] resizeBuffer ( final Context context , final int minCapacity ) {
final int len = Math . min ( available ( context ) , bAvail ) ; System . arraycopy ( context . buffer , context . readPos , b , bPos , len ) ; MST[rv.UOI4Mutator]MSP[] context . readPos += len ;
throw new OutOfMemoryError ( lr_4 + ( minCapacity & 0xffffffffL ) ) ; } return ( minCapacity > MAX_BUFFER_SIZE ) ? MST[rv.ABSMutator]MSP[] minCapacity : MAX_BUFFER_SIZE ; } public static byte [] getChunkSeparator () { return CHUNK_SEPARATOR . clone () ; } protected static boolean isWhiteSpace ( final byte byteToCheck ) {
switch ( byteToCheck ) { case ' ' : case '\n' : case '\r' : case '\t' : return true ; MST[InlineConstantMutator]MSP[] default : return false ; } } private static byte [] resizeBuffer ( final Context context , final int minCapacity ) {
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; MST[rv.CRCR5Mutator]MSP[] if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; } return len ; }
boolean hasData ( final Context context ) { return context . buffer != null ; } public boolean isInAlphabet ( final byte [] arrayOctet , final boolean allowWSPad ) { for ( final byte octet : arrayOctet ) { if ( ! isInAlphabet ( octet ) && MST[rv.ROR5Mutator]MSP[]
boolean hasData ( final Context context ) { return context . buffer != null ; } public boolean isInAlphabet ( final byte [] arrayOctet , final boolean allowWSPad ) { for ( final byte octet : arrayOctet ) { if ( ! isInAlphabet ( octet ) && MST[rv.UOI4Mutator]MSP[]
final int oldCapacity = context . buffer . length ; int newCapacity = oldCapacity * DEFAULT_BUFFER_RESIZE_FACTOR ; MST[rv.UOI1Mutator]MSP[] if ( compareUnsigned ( newCapacity , minCapacity ) < 0 ) { newCapacity = minCapacity ; } if ( compareUnsigned ( newCapacity , MAX_BUFFER_SIZE ) > 0 ) {
int available ( final Context context ) { return context . buffer != null ? context . pos - context . readPos : 0 ; } protected boolean containsAlphabetOrPad ( final byte [] arrayOctet ) { if ( arrayOctet == null ) { return false ; MST[InlineConstantMutator]MSP[] }
if ( pArray == null || pArray . length == 0 ) { return pArray ; } final Context context = new Context () ; decode ( pArray , 0 , pArray . length , context ) ; decode ( pArray , 0 , EOF , context ) ; MST[rv.CRCR5Mutator]MSP[]
throw new OutOfMemoryError ( lr_4 + ( minCapacity & 0xffffffffL ) ) ; } return ( minCapacity > MAX_BUFFER_SIZE ) ? MST[rv.CRCR4Mutator]MSP[] minCapacity : MAX_BUFFER_SIZE ; } public static byte [] getChunkSeparator () { return CHUNK_SEPARATOR . clone () ; } protected static boolean isWhiteSpace ( final byte byteToCheck ) {
switch ( byteToCheck ) { case ' ' : case '\n' : case '\r' : case '\t' : return true ; default : return false ; MST[ReturnValsMutator]MSP[] } } private static byte [] resizeBuffer ( final Context context , final int minCapacity ) {
switch ( byteToCheck ) { case ' ' : case '\n' : case '\r' : case '\t' : return true ; default : return false ; MST[BooleanTrueReturnValsMutator]MSP[] } } private static byte [] resizeBuffer ( final Context context , final int minCapacity ) {
private static int compareUnsigned ( final int x , final int y ) { return Integer . compare ( x + Integer . MIN_VALUE , y + Integer . MIN_VALUE ) ; MST[rv.AOD2Mutator]MSP[] } private static int createPositiveCapacity ( final int minCapacity ) { if ( minCapacity < 0 ) {
readResults ( buf , 0 , buf . length , context ) ; return buf ; } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof byte [] ) ) { MST[rv.ROR1Mutator]MSP[] throw new EncoderException ( lr_6 ) ; }
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; MST[rv.CRCR3Mutator]MSP[] } return len ; }
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; MST[rv.AOR4Mutator]MSP[] if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; } return len ; }
private static int compareUnsigned ( final int x , final int y ) { return Integer . compare ( x + Integer . MIN_VALUE , y + Integer . MIN_VALUE ) ; } private static int createPositiveCapacity ( final int minCapacity ) { if ( minCapacity < 0 ) { MST[ConditionalsBoundaryMutator]MSP[]
boolean hasData ( final Context context ) { return context . buffer != null ; } public boolean isInAlphabet ( final byte [] arrayOctet , final boolean allowWSPad ) { for ( final byte octet : arrayOctet ) { MST[rv.UOI4Mutator]MSP[] if ( ! isInAlphabet ( octet ) &&
private static int compareUnsigned ( final int x , final int y ) { return Integer . compare ( x + Integer . MIN_VALUE , y + Integer . MIN_VALUE ) ; } private static int createPositiveCapacity ( final int minCapacity ) { if ( minCapacity < 0 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[]
int available ( final Context context ) { return context . buffer != null ? context . pos - context . readPos : 0 ; MST[rv.UOI4Mutator]MSP[] } protected boolean containsAlphabetOrPad ( final byte [] arrayOctet ) { if ( arrayOctet == null ) { return false ; }
throw new OutOfMemoryError ( lr_4 + ( minCapacity & 0xffffffffL ) ) ; } return ( minCapacity > MAX_BUFFER_SIZE ) ? MST[rv.UOI1Mutator]MSP[] minCapacity : MAX_BUFFER_SIZE ; } public static byte [] getChunkSeparator () { return CHUNK_SEPARATOR . clone () ; } protected static boolean isWhiteSpace ( final byte byteToCheck ) {
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; MST[rv.AOD2Mutator]MSP[] } return len ; }
throw new OutOfMemoryError ( lr_4 + ( minCapacity & 0xffffffffL ) ) ; } return ( minCapacity > MAX_BUFFER_SIZE ) ? MST[rv.CRCR2Mutator]MSP[] minCapacity : MAX_BUFFER_SIZE ; } public static byte [] getChunkSeparator () { return CHUNK_SEPARATOR . clone () ; } protected static boolean isWhiteSpace ( final byte byteToCheck ) {
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; MST[rv.ABSMutator]MSP[] } return len ; }
if ( pArray == null || pArray . length == 0 ) { return pArray ; } final Context context = new Context () ; decode ( pArray , 0 , pArray . length , context ) ; decode ( pArray , 0 , EOF , context ) ; MST[rv.CRCR1Mutator]MSP[]
switch ( byteToCheck ) { case ' ' : case '\n' : case '\r' : case '\t' : return true ; default : return false ; MST[rv.CRCR1Mutator]MSP[] } } private static byte [] resizeBuffer ( final Context context , final int minCapacity ) {
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; MST[MathMutator]MSP[] } return len ; }
final byte [] result = new byte [ context . pos ] ; readResults ( result , 0 , result . length , context ) ; return result ; } @Override public Object decode ( final Object obj ) throws DecoderException { if ( obj instanceof byte [] ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
final int oldCapacity = context . buffer . length ; int newCapacity = oldCapacity * DEFAULT_BUFFER_RESIZE_FACTOR ; if ( compareUnsigned ( newCapacity , minCapacity ) < 0 ) { newCapacity = minCapacity ; } if ( compareUnsigned ( newCapacity , MAX_BUFFER_SIZE ) > 0 ) { MST[rv.CRCR6Mutator]MSP[]
throw new OutOfMemoryError ( lr_4 + ( minCapacity & 0xffffffffL ) ) ; MST[NonVoidMethodCallMutator]MSP[] } return ( minCapacity > MAX_BUFFER_SIZE ) ? minCapacity : MAX_BUFFER_SIZE ; } public static byte [] getChunkSeparator () { return CHUNK_SEPARATOR . clone () ; } protected static boolean isWhiteSpace ( final byte byteToCheck ) {
for ( final byte element : arrayOctet ) { if ( pad == element || isInAlphabet ( element ) ) { return true ; MST[rv.CRCR5Mutator]MSP[] } } return false ; } @Override public byte [] decode ( final byte [] pArray ) {
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; MST[rv.AOD2Mutator]MSP[] if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; } return len ; }
private static int compareUnsigned ( final int x , final int y ) { return Integer . compare ( x + Integer . MIN_VALUE , y + Integer . MIN_VALUE ) ; MST[rv.AOD1Mutator]MSP[] } private static int createPositiveCapacity ( final int minCapacity ) { if ( minCapacity < 0 ) {
newCapacity = createPositiveCapacity ( minCapacity ) ; MST[rv.UOI1Mutator]MSP[] } final byte [] b = new byte [ newCapacity ] ; System . arraycopy ( context . buffer , 0 , b , 0 , context . buffer . length ) ; context . buffer = b ; return b ; }
private static int compareUnsigned ( final int x , final int y ) { return Integer . compare ( x + Integer . MIN_VALUE , y + Integer . MIN_VALUE ) ; MST[rv.UOI4Mutator]MSP[] } private static int createPositiveCapacity ( final int minCapacity ) { if ( minCapacity < 0 ) {
final int oldCapacity = context . buffer . length ; int newCapacity = oldCapacity * DEFAULT_BUFFER_RESIZE_FACTOR ; if ( compareUnsigned ( newCapacity , minCapacity ) < 0 ) { MST[rv.UOI1Mutator]MSP[] newCapacity = minCapacity ; } if ( compareUnsigned ( newCapacity , MAX_BUFFER_SIZE ) > 0 ) {
context . buffer = new byte [ Math . max ( size , getDefaultBufferSize () ) ] ; context . pos = 0 ; MST[rv.CRCR3Mutator]MSP[] context . readPos = 0 ; } else if ( context . pos + size - context . buffer . length > 0 ) {
boolean hasData ( final Context context ) { return context . buffer != null ; } public boolean isInAlphabet ( final byte [] arrayOctet , final boolean allowWSPad ) { for ( final byte octet : arrayOctet ) { if ( ! isInAlphabet ( octet ) && MST[rv.ROR5Mutator]MSP[]
final int len = Math . min ( available ( context ) , bAvail ) ; System . arraycopy ( context . buffer , context . readPos , b , bPos , len ) ; MST[rv.UOI4Mutator]MSP[] context . readPos += len ;
boolean hasData ( final Context context ) { return context . buffer != null ; } public boolean isInAlphabet ( final byte [] arrayOctet , final boolean allowWSPad ) { for ( final byte octet : arrayOctet ) { if ( ! isInAlphabet ( octet ) && MST[rv.ROR3Mutator]MSP[]
return decode ( ( byte [] ) obj ) ; } else if ( obj instanceof String ) { MST[NegateConditionalsMutator]MSP[] return decode ( ( String ) obj ) ; } else { throw new DecoderException ( lr_5 ) ; } } public byte [] decode ( final String pArray ) {
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; MST[rv.AOR4Mutator]MSP[] } return len ; }
newCapacity = createPositiveCapacity ( minCapacity ) ; } final byte [] b = new byte [ newCapacity ] ; MST[rv.ABSMutator]MSP[] System . arraycopy ( context . buffer , 0 , b , 0 , context . buffer . length ) ; context . buffer = b ; return b ; }
switch ( byteToCheck ) { MST[rv.UOI1Mutator]MSP[] case ' ' : case '\n' : case '\r' : case '\t' : return true ; default : return false ; } } private static byte [] resizeBuffer ( final Context context , final int minCapacity ) {
newCapacity = createPositiveCapacity ( minCapacity ) ; } final byte [] b = new byte [ newCapacity ] ; System . arraycopy ( context . buffer , 0 , b , 0 , context . buffer . length ) ; MST[VoidMethodCallMutator]MSP[] context . buffer = b ; return b ; }
return resizeBuffer ( context , context . pos + size ) ; MST[rv.AOR4Mutator]MSP[] } return context . buffer ; } public CodecPolicy getCodecPolicy () { return decodingPolicy ; } protected int getDefaultBufferSize () { return DEFAULT_BUFFER_SIZE ; } public long getEncodedLength ( final byte [] pArray ) {
return resizeBuffer ( context , context . pos + size ) ; MST[rv.ABSMutator]MSP[] } return context . buffer ; } public CodecPolicy getCodecPolicy () { return decodingPolicy ; } protected int getDefaultBufferSize () { return DEFAULT_BUFFER_SIZE ; } public long getEncodedLength ( final byte [] pArray ) {
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; MST[rv.AOR4Mutator]MSP[] if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; } return len ; }
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; MST[rv.UOI4Mutator]MSP[] if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; } return len ; }
throw new OutOfMemoryError ( lr_4 + ( minCapacity & 0xffffffffL ) ) ; MST[ConstructorCallMutator]MSP[] } return ( minCapacity > MAX_BUFFER_SIZE ) ? minCapacity : MAX_BUFFER_SIZE ; } public static byte [] getChunkSeparator () { return CHUNK_SEPARATOR . clone () ; } protected static boolean isWhiteSpace ( final byte byteToCheck ) {
( ! allowWSPad || ( octet != pad ) && ! isWhiteSpace ( octet ) ) ) { return false ; } } return true ; MST[ReturnValsMutator]MSP[] } public boolean isInAlphabet ( final String basen ) { return isInAlphabet ( StringUtils . getBytesUtf8 ( basen ) , true ) ; }
if ( pArray == null || pArray . length == 0 ) { MST[rv.ROR3Mutator]MSP[] return pArray ; } final Context context = new Context () ; decode ( pArray , 0 , pArray . length , context ) ; decode ( pArray , 0 , EOF , context ) ;
return encode ( ( byte [] ) obj ) ; MST[NullReturnValsMutator]MSP[] } public String encodeAsString ( final byte [] pArray ) { return StringUtils . newStringUtf8 ( encode ( pArray ) ) ; } public String encodeToString ( final byte [] pArray ) {
return resizeBuffer ( context , context . pos + size ) ; MST[rv.UOI4Mutator]MSP[] } return context . buffer ; } public CodecPolicy getCodecPolicy () { return decodingPolicy ; } protected int getDefaultBufferSize () { return DEFAULT_BUFFER_SIZE ; } public long getEncodedLength ( final byte [] pArray ) {
return decode ( ( byte [] ) obj ) ; } else if ( obj instanceof String ) { MST[rv.ROR3Mutator]MSP[] return decode ( ( String ) obj ) ; } else { throw new DecoderException ( lr_5 ) ; } } public byte [] decode ( final String pArray ) {
boolean hasData ( final Context context ) { return context . buffer != null ; } public boolean isInAlphabet ( final byte [] arrayOctet , final boolean allowWSPad ) { for ( final byte octet : arrayOctet ) { MST[rv.UOI3Mutator]MSP[] if ( ! isInAlphabet ( octet ) &&
for ( final byte element : arrayOctet ) { if ( pad == element || isInAlphabet ( element ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return true ; } } return false ; } @Override public byte [] decode ( final byte [] pArray ) {
throw new OutOfMemoryError ( lr_4 + ( minCapacity & 0xffffffffL ) ) ; MST[MathMutator]MSP[] } return ( minCapacity > MAX_BUFFER_SIZE ) ? minCapacity : MAX_BUFFER_SIZE ; } public static byte [] getChunkSeparator () { return CHUNK_SEPARATOR . clone () ; } protected static boolean isWhiteSpace ( final byte byteToCheck ) {
boolean hasData ( final Context context ) { return context . buffer != null ; } public boolean isInAlphabet ( final byte [] arrayOctet , final boolean allowWSPad ) { for ( final byte octet : arrayOctet ) { if ( ! isInAlphabet ( octet ) && MST[NegateConditionalsMutator]MSP[]
return decode ( StringUtils . getBytesUtf8 ( pArray ) ) ; } @Override public byte [] encode ( final byte [] pArray ) { if ( pArray == null || pArray . length == 0 ) { return pArray ; MST[ReturnValsMutator]MSP[] }
boolean hasData ( final Context context ) { return context . buffer != null ; } public boolean isInAlphabet ( final byte [] arrayOctet , final boolean allowWSPad ) { for ( final byte octet : arrayOctet ) { MST[rv.ABSMutator]MSP[] if ( ! isInAlphabet ( octet ) &&
int available ( final Context context ) { return context . buffer != null ? context . pos - context . readPos : 0 ; MST[rv.UOI4Mutator]MSP[] } protected boolean containsAlphabetOrPad ( final byte [] arrayOctet ) { if ( arrayOctet == null ) { return false ; }
( ! allowWSPad || ( octet != pad ) && ! isWhiteSpace ( octet ) ) ) { return false ; } } return true ; MST[rv.CRCR6Mutator]MSP[] } public boolean isInAlphabet ( final String basen ) { return isInAlphabet ( StringUtils . getBytesUtf8 ( basen ) , true ) ; }
final int oldCapacity = context . buffer . length ; int newCapacity = oldCapacity * DEFAULT_BUFFER_RESIZE_FACTOR ; if ( compareUnsigned ( newCapacity , minCapacity ) < 0 ) { newCapacity = minCapacity ; } if ( compareUnsigned ( newCapacity , MAX_BUFFER_SIZE ) > 0 ) { MST[rv.CRCR1Mutator]MSP[]
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; MST[rv.UOI3Mutator]MSP[] } return len ; }
private static int compareUnsigned ( final int x , final int y ) { return Integer . compare ( x + Integer . MIN_VALUE , y + Integer . MIN_VALUE ) ; MST[rv.CRCR6Mutator]MSP[] } private static int createPositiveCapacity ( final int minCapacity ) { if ( minCapacity < 0 ) {
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; MST[MathMutator]MSP[] } return len ; }
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; MST[rv.UOI1Mutator]MSP[] } return len ; }
final int oldCapacity = context . buffer . length ; int newCapacity = oldCapacity * DEFAULT_BUFFER_RESIZE_FACTOR ; if ( compareUnsigned ( newCapacity , minCapacity ) < 0 ) { MST[NonVoidMethodCallMutator]MSP[] newCapacity = minCapacity ; } if ( compareUnsigned ( newCapacity , MAX_BUFFER_SIZE ) > 0 ) {
int available ( final Context context ) { return context . buffer != null ? context . pos - context . readPos : 0 ; MST[rv.AOR4Mutator]MSP[] } protected boolean containsAlphabetOrPad ( final byte [] arrayOctet ) { if ( arrayOctet == null ) { return false ; }
( ! allowWSPad || ( octet != pad ) && ! isWhiteSpace ( octet ) ) ) { return false ; } } return true ; } public boolean isInAlphabet ( final String basen ) { return isInAlphabet ( StringUtils . getBytesUtf8 ( basen ) , true ) ; MST[rv.CRCR4Mutator]MSP[] }
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; MST[rv.AOD2Mutator]MSP[] if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; } return len ; }
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; MST[rv.UOI2Mutator]MSP[] if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; } return len ; }
throw new OutOfMemoryError ( lr_4 + ( minCapacity & 0xffffffffL ) ) ; MST[InlineConstantMutator]MSP[] } return ( minCapacity > MAX_BUFFER_SIZE ) ? minCapacity : MAX_BUFFER_SIZE ; } public static byte [] getChunkSeparator () { return CHUNK_SEPARATOR . clone () ; } protected static boolean isWhiteSpace ( final byte byteToCheck ) {
final int len = Math . min ( available ( context ) , bAvail ) ; System . arraycopy ( context . buffer , context . readPos , b , bPos , len ) ; MST[rv.ABSMutator]MSP[] context . readPos += len ;
return resizeBuffer ( context , context . pos + size ) ; } return context . buffer ; } public CodecPolicy getCodecPolicy () { return decodingPolicy ; MST[NullReturnValsMutator]MSP[] } protected int getDefaultBufferSize () { return DEFAULT_BUFFER_SIZE ; } public long getEncodedLength ( final byte [] pArray ) {
final int oldCapacity = context . buffer . length ; int newCapacity = oldCapacity * DEFAULT_BUFFER_RESIZE_FACTOR ; if ( compareUnsigned ( newCapacity , minCapacity ) < 0 ) { MST[rv.UOI2Mutator]MSP[] newCapacity = minCapacity ; } if ( compareUnsigned ( newCapacity , MAX_BUFFER_SIZE ) > 0 ) {
boolean hasData ( final Context context ) { return context . buffer != null ; } public boolean isInAlphabet ( final byte [] arrayOctet , final boolean allowWSPad ) { for ( final byte octet : arrayOctet ) { if ( ! isInAlphabet ( octet ) && MST[rv.UOI1Mutator]MSP[]
if ( pArray == null || pArray . length == 0 ) { return pArray ; } final Context context = new Context () ; decode ( pArray , 0 , pArray . length , context ) ; MST[VoidMethodCallMutator]MSP[] decode ( pArray , 0 , EOF , context ) ;
switch ( byteToCheck ) { case ' ' : case '\n' : case '\r' : case '\t' : return true ; default : return false ; MST[rv.CRCR6Mutator]MSP[] } } private static byte [] resizeBuffer ( final Context context , final int minCapacity ) {
boolean hasData ( final Context context ) { return context . buffer != null ; } public boolean isInAlphabet ( final byte [] arrayOctet , final boolean allowWSPad ) { for ( final byte octet : arrayOctet ) { if ( ! isInAlphabet ( octet ) && MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
private static int compareUnsigned ( final int x , final int y ) { return Integer . compare ( x + Integer . MIN_VALUE , y + Integer . MIN_VALUE ) ; MST[rv.CRCR1Mutator]MSP[] } private static int createPositiveCapacity ( final int minCapacity ) { if ( minCapacity < 0 ) {
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; MST[rv.AOR2Mutator]MSP[] } return len ; }
final int oldCapacity = context . buffer . length ; int newCapacity = oldCapacity * DEFAULT_BUFFER_RESIZE_FACTOR ; if ( compareUnsigned ( newCapacity , minCapacity ) < 0 ) { newCapacity = minCapacity ; MST[rv.ABSMutator]MSP[] } if ( compareUnsigned ( newCapacity , MAX_BUFFER_SIZE ) > 0 ) {
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; } return len ; MST[rv.UOI2Mutator]MSP[] }
boolean hasData ( final Context context ) { return context . buffer != null ; } public boolean isInAlphabet ( final byte [] arrayOctet , final boolean allowWSPad ) { for ( final byte octet : arrayOctet ) { if ( ! isInAlphabet ( octet ) && MST[rv.UOI4Mutator]MSP[]
boolean hasData ( final Context context ) { return context . buffer != null ; } public boolean isInAlphabet ( final byte [] arrayOctet , final boolean allowWSPad ) { for ( final byte octet : arrayOctet ) { if ( ! isInAlphabet ( octet ) && MST[rv.UOI2Mutator]MSP[]
public boolean isStrictDecoding () { return decodingPolicy == CodecPolicy . STRICT ; MST[rv.CRCR5Mutator]MSP[] } int readResults ( final byte [] b , final int bPos , final int bAvail , final Context context ) { if ( context . buffer != null ) {
final byte [] result = new byte [ context . pos ] ; readResults ( result , 0 , result . length , context ) ; return result ; } @Override public Object decode ( final Object obj ) throws DecoderException { if ( obj instanceof byte [] ) { MST[rv.ROR4Mutator]MSP[]
