value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; MST[MathMutator]MSP[] value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; return value ; }
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; a = a ^ t ^ t >>> 16 - n ; MST[rv.CRCR3Mutator]MSP[] return a ; }
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { MST[MathMutator]MSP[] c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) {
SPTRANS [ 4 ] [ u >>> 16 & 0x3f ] | SPTRANS [ 6 ] [ u >>> 24 & 0x3f ] ; return el ; MST[ReturnValsMutator]MSP[] } private static int [] desSetKey ( final byte key [] ) {
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { MST[rv.OBBN1Mutator]MSP[] c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) {
private static int [] body ( final int schedule [] , final int eSwap0 , final int eSwap1 ) { int left = 0 ; int right = 0 ; int t = 0 ; for ( int j = 0 ; j < 25 ; j ++ ) { MST[rv.ROR3Mutator]MSP[]
final int schedule [] = new int [ 32 ] ; int c = fourBytesToInt ( key , 0 ) ; int d = fourBytesToInt ( key , 4 ) ; MST[rv.CRCR4Mutator]MSP[] final int results [] = new int [ 2 ] ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR6Mutator]MSP[]
int c = 0 ; for (; j < 6 ; j ++ ) { MST[IncrementsMutator]MSP[] c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) {
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { MST[rv.UOI3Mutator]MSP[] c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) {
u = u ^ u << 16 ^ r ^ sArr [ s ] ; MST[rv.CRCR4Mutator]MSP[] int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; t = t >>> 4 | t << 28 ;
for ( int i = 0 ; i < 16 ; i ++ ) { MST[rv.CRCR6Mutator]MSP[] if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; d = d >>> 2 | d << 26 ; } else {
} else if ( ! salt . matches ( lr_2 + B64 . B64T_STRING + lr_3 ) ) { throw new IllegalArgumentException ( lr_4 + salt ) ; MST[ConstructorCallMutator]MSP[] } final StringBuilder buffer = new StringBuilder ( lr_5 ) ; final char charZero = salt . charAt ( 0 ) ;
right = results [ 0 ] ; MST[rv.CRCR1Mutator]MSP[] left = results [ 1 ] ; final int out [] = new int [ 2 ] ; out [ 0 ] = left ; out [ 1 ] = right ; return out ; }
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR1Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
intToFourBytes ( out [ 1 ] , b , 4 ) ; b [ 8 ] = 0 ; MST[rv.CRCR4Mutator]MSP[] int i = 2 ; int y = 0 ; int u = 128 ; for (; i < 13 ; i ++ ) { int j = 0 ;
c = c >>> 1 | c << 27 ; d = d >>> 1 | d << 27 ; } c &= 0xfffffff ; d &= 0xfffffff ; MST[rv.CRCR2Mutator]MSP[]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.UOI4Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
for ( int i = 0 ; i < 32 ; i += 4 ) { left = dEncrypt ( left , right , i , eSwap0 , eSwap1 , schedule ) ; MST[rv.UOI2Mutator]MSP[]
SKB [ 7 ] [ d >>> 21 & 0xf | d >>> 22 & 0x30 ] ; schedule [ j ++ ] = ( t << 16 | s & 0xffff ) ; s = s >>> 16 | t & 0xffff0000 ; MST[rv.CRCR4Mutator]MSP[]
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR5Mutator]MSP[]
private static int dEncrypt ( int el , final int r , final int s , final int e0 , final int e1 , final int sArr [] ) { int v = r ^ r >>> 16 ; MST[rv.CRCR3Mutator]MSP[] int u = v & e0 ; v &= e1 ;
final byte key [] = new byte [ 8 ] ; for ( int i = 0 ; i < key . length ; i ++ ) { key [ i ] = 0 ; MST[rv.CRCR1Mutator]MSP[] }
left = t >>> 1 | t << 31 ; MST[rv.UOI4Mutator]MSP[] final int results [] = new int [ 2 ] ; permOp ( right , left , 1 , 0x55555555 , results ) ; right = results [ 0 ] ; left = results [ 1 ] ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.UOI4Mutator]MSP[]
intToFourBytes ( out [ 1 ] , b , 4 ) ; b [ 8 ] = 0 ; int i = 2 ; int y = 0 ; MST[InlineConstantMutator]MSP[] int u = 128 ; for (; i < 13 ; i ++ ) { int j = 0 ;
private static int byteToUnsigned ( final byte b ) { final int value = b ; return value < 0 ? value + 256 : value ; MST[rv.UOI2Mutator]MSP[] }
SKB [ 7 ] [ d >>> 21 & 0xf | d >>> 22 & 0x30 ] ; schedule [ j ++ ] = ( t << 16 | s & 0xffff ) ; MST[rv.UOI4Mutator]MSP[] s = s >>> 16 | t & 0xffff0000 ;
private static void permOp ( int a , int b , final int n , final int m , final int results [] ) { final int t = ( a >>> n ^ b ) & m ; MST[rv.UOI1Mutator]MSP[] a ^= t << n ; b ^= t ;
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.OBBN3Mutator]MSP[] c &= 0xfffffff ; int j = 0 ;
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[InlineConstantMutator]MSP[] c &= 0xfffffff ; int j = 0 ;
d = hPermOp ( d , - 2 , 0xcccc0000 ) ; permOp ( d , c , 1 , 0x55555555 , results ) ; MST[rv.UOI3Mutator]MSP[] d = results [ 0 ] ; c = results [ 1 ] ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.OBBN2Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
for ( int i = 0 ; i < key . length && i < original . length ; i ++ ) { final int iChar = original [ i ] ; MST[rv.UOI3Mutator]MSP[] key [ i ] = (byte) ( iChar << 1 ) ; }
b [ offset ++ ] = (byte) ( iValue >>> 16 & 0xff ) ; b [ offset ++ ] = (byte) ( iValue >>> 24 & 0xff ) ; MST[rv.CRCR3Mutator]MSP[] }
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR2Mutator]MSP[]
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; MST[rv.UOI3Mutator]MSP[] a = a ^ t ^ t >>> 16 - n ; return a ; }
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.UOI2Mutator]MSP[]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.UOI3Mutator]MSP[]
c = c >>> 1 | c << 27 ; MST[rv.CRCR4Mutator]MSP[] d = d >>> 1 | d << 27 ; } c &= 0xfffffff ; d &= 0xfffffff ;
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.CRCR2Mutator]MSP[] c &= 0xfffffff ; int j = 0 ;
y ++ ; MST[IncrementsMutator]MSP[] u = 128 ; } buffer . setCharAt ( i , ( char ) COV2CHAR [ c ] ) ; } } return buffer . toString () ; } public static String crypt ( final String original ) {
right = results [ 0 ] ; left = results [ 1 ] ; final int out [] = new int [ 2 ] ; out [ 0 ] = left ; MST[rv.CRCR1Mutator]MSP[] out [ 1 ] = right ; return out ; }
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; t = t >>> 4 | t << 28 ; MST[MathMutator]MSP[]
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; } t = left ; left = right ; right = t ; } t = right ; right = left >>> 1 | left << 31 ; MST[rv.ABSMutator]MSP[]
c = c >>> 1 | c << 27 ; d = d >>> 1 | d << 27 ; MST[rv.CRCR2Mutator]MSP[] } c &= 0xfffffff ; d &= 0xfffffff ;
final int schedule [] = new int [ 32 ] ; int c = fourBytesToInt ( key , 0 ) ; MST[NonVoidMethodCallMutator]MSP[] int d = fourBytesToInt ( key , 4 ) ; final int results [] = new int [ 2 ] ;
final char charOne = salt . charAt ( 1 ) ; buffer . setCharAt ( 0 , charZero ) ; buffer . setCharAt ( 1 , charOne ) ; final int eSwap0 = CON_SALT [ charZero ] ; MST[rv.ABSMutator]MSP[] final int eSwap1 = CON_SALT [ charOne ] << 4 ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR5Mutator]MSP[]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.OBBN2Mutator]MSP[]
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; } t = left ; left = right ; right = t ; } t = right ; right = left >>> 1 | left << 31 ; MST[rv.UOI1Mutator]MSP[]
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; MST[rv.UOI3Mutator]MSP[] value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; return value ; }
for ( int i = 0 ; i < 16 ; i ++ ) { MST[rv.ROR4Mutator]MSP[] if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; d = d >>> 2 | d << 26 ; } else {
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.UOI1Mutator]MSP[]
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; MST[rv.CRCR2Mutator]MSP[] return value ; }
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.CRCR2Mutator]MSP[] c &= 0xfffffff ; int j = 0 ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR2Mutator]MSP[]
private static void intToFourBytes ( final int iValue , final byte b [] , int offset ) { b [ offset ++ ] = (byte) ( iValue & 0xff ) ; MST[rv.CRCR3Mutator]MSP[] b [ offset ++ ] = (byte) ( iValue >>> 8 & 0xff ) ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[MathMutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.OBBN1Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[InlineConstantMutator]MSP[]
private static void intToFourBytes ( final int iValue , final byte b [] , int offset ) { b [ offset ++ ] = (byte) ( iValue & 0xff ) ; b [ offset ++ ] = (byte) ( iValue >>> 8 & 0xff ) ; MST[rv.CRCR5Mutator]MSP[]
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; MST[rv.CRCR4Mutator]MSP[] } t = left ; left = right ; right = t ; } t = right ; right = left >>> 1 | left << 31 ;
left = results [ 1 ] ; MST[rv.UOI1Mutator]MSP[] permOp ( left , right , 16 , 65535 , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 4 , 0xf0f0f0f , results ) ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR6Mutator]MSP[]
left = results [ 1 ] ; permOp ( left , right , 16 , 65535 , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 4 , 0xf0f0f0f , results ) ; MST[rv.CRCR3Mutator]MSP[]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.UOI3Mutator]MSP[]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR5Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.UOI2Mutator]MSP[]
permOp ( c , d , 8 , 0xff00ff , results ) ; MST[rv.UOI4Mutator]MSP[] c = results [ 0 ] ; d = results [ 1 ] ; permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ;
final int schedule [] = desSetKey ( key ) ; final int out [] = body ( schedule , eSwap0 , eSwap1 ) ; final byte b [] = new byte [ 9 ] ; intToFourBytes ( out [ 0 ] , b , 0 ) ; MST[rv.CRCR1Mutator]MSP[]
left = t >>> 1 | t << 31 ; MST[rv.UOI3Mutator]MSP[] final int results [] = new int [ 2 ] ; permOp ( right , left , 1 , 0x55555555 , results ) ; right = results [ 0 ] ; left = results [ 1 ] ;
final char charOne = salt . charAt ( 1 ) ; buffer . setCharAt ( 0 , charZero ) ; buffer . setCharAt ( 1 , charOne ) ; final int eSwap0 = CON_SALT [ charZero ] ; final int eSwap1 = CON_SALT [ charOne ] << 4 ; MST[rv.UOI3Mutator]MSP[]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR2Mutator]MSP[]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR1Mutator]MSP[]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.OBBN1Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
final byte key [] = new byte [ 8 ] ; MST[rv.CRCR1Mutator]MSP[] for ( int i = 0 ; i < key . length ; i ++ ) { key [ i ] = 0 ; }
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.OBBN3Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
private static void permOp ( int a , int b , final int n , final int m , final int results [] ) { final int t = ( a >>> n ^ b ) & m ; MST[rv.ABSMutator]MSP[] a ^= t << n ; b ^= t ;
left = results [ 1 ] ; permOp ( left , right , 16 , 65535 , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; MST[rv.ABSMutator]MSP[] permOp ( right , left , 4 , 0xf0f0f0f , results ) ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR6Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR4Mutator]MSP[]
private static int dEncrypt ( int el , final int r , final int s , final int e0 , final int e1 , final int sArr [] ) { int v = r ^ r >>> 16 ; MST[rv.UOI2Mutator]MSP[] int u = v & e0 ; v &= e1 ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.UOI2Mutator]MSP[]
private static int byteToUnsigned ( final byte b ) { final int value = b ; return value < 0 ? value + 256 : value ; MST[rv.ABSMutator]MSP[] }
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR3Mutator]MSP[]
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; } t = left ; left = right ; right = t ; } t = right ; MST[rv.UOI4Mutator]MSP[] right = left >>> 1 | left << 31 ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.OBBN1Mutator]MSP[]
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; d = d >>> 2 | d << 26 ; MST[rv.UOI4Mutator]MSP[] } else {
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; MST[rv.UOI2Mutator]MSP[] value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; return value ; }
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; } t = left ; left = right ; MST[rv.UOI1Mutator]MSP[] right = t ; } t = right ; right = left >>> 1 | left << 31 ;
for ( int i = 0 ; i < 32 ; i += 4 ) { MST[rv.CRCR4Mutator]MSP[] left = dEncrypt ( left , right , i , eSwap0 , eSwap1 , schedule ) ;
intToFourBytes ( out [ 1 ] , b , 4 ) ; b [ 8 ] = 0 ; int i = 2 ; int y = 0 ; int u = 128 ; for (; i < 13 ; i ++ ) { int j = 0 ; MST[rv.CRCR6Mutator]MSP[]
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; MST[rv.CRCR3Mutator]MSP[] t = t >>> 4 | t << 28 ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.UOI4Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
y ++ ; u = 128 ; MST[rv.CRCR2Mutator]MSP[] } buffer . setCharAt ( i , ( char ) COV2CHAR [ c ] ) ; } } return buffer . toString () ; } public static String crypt ( final String original ) {
right = results [ 0 ] ; left = results [ 1 ] ; MST[rv.CRCR6Mutator]MSP[] final int out [] = new int [ 2 ] ; out [ 0 ] = left ; out [ 1 ] = right ; return out ; }
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.UOI3Mutator]MSP[]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.UOI1Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR5Mutator]MSP[]
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; } t = left ; left = right ; right = t ; } t = right ; right = left >>> 1 | left << 31 ; MST[rv.UOI2Mutator]MSP[]
y ++ ; u = 128 ; MST[rv.CRCR5Mutator]MSP[] } buffer . setCharAt ( i , ( char ) COV2CHAR [ c ] ) ; } } return buffer . toString () ; } public static String crypt ( final String original ) {
permOp ( c , d , 8 , 0xff00ff , results ) ; MST[rv.CRCR5Mutator]MSP[] c = results [ 0 ] ; d = results [ 1 ] ; permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ;
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; MST[rv.UOI4Mutator]MSP[] } t = left ; left = right ; right = t ; } t = right ; right = left >>> 1 | left << 31 ;
private static void intToFourBytes ( final int iValue , final byte b [] , int offset ) { b [ offset ++ ] = (byte) ( iValue & 0xff ) ; b [ offset ++ ] = (byte) ( iValue >>> 8 & 0xff ) ; MST[rv.OBBN3Mutator]MSP[]
final char charOne = salt . charAt ( 1 ) ; buffer . setCharAt ( 0 , charZero ) ; buffer . setCharAt ( 1 , charOne ) ; final int eSwap0 = CON_SALT [ charZero ] ; MST[rv.UOI2Mutator]MSP[] final int eSwap1 = CON_SALT [ charOne ] << 4 ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.OBBN3Mutator]MSP[]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.UOI2Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; MST[rv.OBBN3Mutator]MSP[] a = a ^ t ^ t >>> 16 - n ; return a ; }
left = results [ 1 ] ; permOp ( left , right , 16 , 65535 , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; MST[rv.CRCR2Mutator]MSP[] permOp ( right , left , 4 , 0xf0f0f0f , results ) ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR4Mutator]MSP[]
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.ABSMutator]MSP[]
left = results [ 1 ] ; permOp ( left , right , 16 , 65535 , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; MST[rv.CRCR5Mutator]MSP[] permOp ( right , left , 4 , 0xf0f0f0f , results ) ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR3Mutator]MSP[]
permOp ( c , d , 8 , 0xff00ff , results ) ; c = results [ 0 ] ; d = results [ 1 ] ; permOp ( d , c , 1 , 0x55555555 , results ) ; MST[rv.CRCR6Mutator]MSP[] d = results [ 0 ] ;
private static int byteToUnsigned ( final byte b ) { final int value = b ; return value < 0 ? value + 256 : value ; MST[rv.UOI4Mutator]MSP[] }
private static int dEncrypt ( int el , final int r , final int s , final int e0 , final int e1 , final int sArr [] ) { int v = r ^ r >>> 16 ; MST[rv.ABSMutator]MSP[] int u = v & e0 ; v &= e1 ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[InlineConstantMutator]MSP[]
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR6Mutator]MSP[]
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; MST[rv.CRCR1Mutator]MSP[] value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; return value ; }
} else if ( ! salt . matches ( lr_2 + B64 . B64T_STRING + lr_3 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] throw new IllegalArgumentException ( lr_4 + salt ) ; } final StringBuilder buffer = new StringBuilder ( lr_5 ) ; final char charZero = salt . charAt ( 0 ) ;
u = u ^ u << 16 ^ r ^ sArr [ s ] ; MST[rv.UOI3Mutator]MSP[] int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; t = t >>> 4 | t << 28 ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR4Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; MST[rv.UOI4Mutator]MSP[] a = a ^ t ^ t >>> 16 - n ; return a ; }
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.ABSMutator]MSP[]
final byte key [] = new byte [ 8 ] ; for ( int i = 0 ; i < key . length ; i ++ ) { MST[rv.ROR4Mutator]MSP[] key [ i ] = 0 ; }
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR1Mutator]MSP[]
final char charOne = salt . charAt ( 1 ) ; buffer . setCharAt ( 0 , charZero ) ; buffer . setCharAt ( 1 , charOne ) ; final int eSwap0 = CON_SALT [ charZero ] ; final int eSwap1 = CON_SALT [ charOne ] << 4 ; MST[MathMutator]MSP[]
permOp ( left , right , 8 , 0xff00ff , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; MST[rv.CRCR3Mutator]MSP[] permOp ( right , left , 2 , 0x33333333 , results ) ; right = results [ 0 ] ;
b [ offset ++ ] = (byte) ( iValue >>> 16 & 0xff ) ; MST[rv.CRCR1Mutator]MSP[] b [ offset ++ ] = (byte) ( iValue >>> 24 & 0xff ) ; }
d = hPermOp ( d , - 2 , 0xcccc0000 ) ; permOp ( d , c , 1 , 0x55555555 , results ) ; MST[rv.CRCR4Mutator]MSP[] d = results [ 0 ] ; c = results [ 1 ] ;
private static void permOp ( int a , int b , final int n , final int m , final int results [] ) { final int t = ( a >>> n ^ b ) & m ; MST[rv.UOI2Mutator]MSP[] a ^= t << n ; b ^= t ;
permOp ( left , right , 8 , 0xff00ff , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 2 , 0x33333333 , results ) ; MST[InlineConstantMutator]MSP[] right = results [ 0 ] ;
left = results [ 1 ] ; permOp ( left , right , 16 , 65535 , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; MST[rv.UOI2Mutator]MSP[] permOp ( right , left , 4 , 0xf0f0f0f , results ) ;
c = c >>> 1 | c << 27 ; MST[rv.CRCR3Mutator]MSP[] d = d >>> 1 | d << 27 ; } c &= 0xfffffff ; d &= 0xfffffff ;
final int numSaltChars = SALT_CHARS . length ; salt = lr_1 + SALT_CHARS [ randomGenerator . nextInt ( numSaltChars ) ] + SALT_CHARS [ randomGenerator . nextInt ( numSaltChars ) ] ; MST[experimental.NakedReceiverMutator]MSP[]
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; MST[IncrementsMutator]MSP[] return value ; }
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; MST[rv.UOI1Mutator]MSP[] return value ; }
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; } t = left ; MST[rv.UOI4Mutator]MSP[] left = right ; right = t ; } t = right ; right = left >>> 1 | left << 31 ;
left = t >>> 1 | t << 31 ; final int results [] = new int [ 2 ] ; permOp ( right , left , 1 , 0x55555555 , results ) ; MST[VoidMethodCallMutator]MSP[] right = results [ 0 ] ; left = results [ 1 ] ;
final byte key [] = new byte [ 8 ] ; for ( int i = 0 ; i < key . length ; i ++ ) { MST[InlineConstantMutator]MSP[] key [ i ] = 0 ; }
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.UOI4Mutator]MSP[]
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.UOI1Mutator]MSP[]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR1Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
right = results [ 0 ] ; left = results [ 1 ] ; final int out [] = new int [ 2 ] ; out [ 0 ] = left ; MST[rv.UOI1Mutator]MSP[] out [ 1 ] = right ; return out ; }
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; MST[rv.UOI2Mutator]MSP[] t = t >>> 4 | t << 28 ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.UOI3Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
permOp ( d , c , 4 , 0xf0f0f0f , results ) ; MST[InlineConstantMutator]MSP[] d = results [ 0 ] ; c = results [ 1 ] ; c = hPermOp ( c , - 2 , 0xcccc0000 ) ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[InlineConstantMutator]MSP[]
final char charOne = salt . charAt ( 1 ) ; MST[rv.CRCR2Mutator]MSP[] buffer . setCharAt ( 0 , charZero ) ; buffer . setCharAt ( 1 , charOne ) ; final int eSwap0 = CON_SALT [ charZero ] ; final int eSwap1 = CON_SALT [ charOne ] << 4 ;
left = t >>> 1 | t << 31 ; MST[MathMutator]MSP[] final int results [] = new int [ 2 ] ; permOp ( right , left , 1 , 0x55555555 , results ) ; right = results [ 0 ] ; left = results [ 1 ] ;
final char charOne = salt . charAt ( 1 ) ; MST[rv.CRCR5Mutator]MSP[] buffer . setCharAt ( 0 , charZero ) ; buffer . setCharAt ( 1 , charOne ) ; final int eSwap0 = CON_SALT [ charZero ] ; final int eSwap1 = CON_SALT [ charOne ] << 4 ;
left = t >>> 1 | t << 31 ; final int results [] = new int [ 2 ] ; permOp ( right , left , 1 , 0x55555555 , results ) ; MST[rv.UOI4Mutator]MSP[] right = results [ 0 ] ; left = results [ 1 ] ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[MathMutator]MSP[]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.OBBN1Mutator]MSP[]
d = hPermOp ( d , - 2 , 0xcccc0000 ) ; MST[rv.CRCR1Mutator]MSP[] permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ; c = results [ 1 ] ;
private static int byteToUnsigned ( final byte b ) { final int value = b ; return value < 0 ? value + 256 : value ; MST[ReturnValsMutator]MSP[] }
for ( int i = 0 ; i < 32 ; i += 4 ) { left = dEncrypt ( left , right , i , eSwap0 , eSwap1 , schedule ) ; MST[rv.ABSMutator]MSP[]
intToFourBytes ( out [ 1 ] , b , 4 ) ; MST[InlineConstantMutator]MSP[] b [ 8 ] = 0 ; int i = 2 ; int y = 0 ; int u = 128 ; for (; i < 13 ; i ++ ) { int j = 0 ;
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.OBBN1Mutator]MSP[] c &= 0xfffffff ; int j = 0 ;
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[MathMutator]MSP[] c &= 0xfffffff ; int j = 0 ;
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; MST[rv.CRCR1Mutator]MSP[] } t = left ; left = right ; right = t ; } t = right ; right = left >>> 1 | left << 31 ;
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; MST[rv.AOR2Mutator]MSP[] t = t >>> 4 | t << 28 ;
} else if ( ! salt . matches ( lr_2 + B64 . B64T_STRING + lr_3 ) ) { throw new IllegalArgumentException ( lr_4 + salt ) ; } final StringBuilder buffer = new StringBuilder ( lr_5 ) ; final char charZero = salt . charAt ( 0 ) ; MST[rv.CRCR3Mutator]MSP[]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR5Mutator]MSP[]
} else if ( ! salt . matches ( lr_2 + B64 . B64T_STRING + lr_3 ) ) { MST[rv.ROR3Mutator]MSP[] throw new IllegalArgumentException ( lr_4 + salt ) ; } final StringBuilder buffer = new StringBuilder ( lr_5 ) ; final char charZero = salt . charAt ( 0 ) ;
private static void intToFourBytes ( final int iValue , final byte b [] , int offset ) { b [ offset ++ ] = (byte) ( iValue & 0xff ) ; MST[rv.CRCR6Mutator]MSP[] b [ offset ++ ] = (byte) ( iValue >>> 8 & 0xff ) ;
for ( int i = 0 ; i < 32 ; i += 4 ) { left = dEncrypt ( left , right , i , eSwap0 , eSwap1 , schedule ) ; MST[rv.UOI1Mutator]MSP[]
y ++ ; u = 128 ; } buffer . setCharAt ( i , ( char ) COV2CHAR [ c ] ) ; MST[VoidMethodCallMutator]MSP[] } } return buffer . toString () ; } public static String crypt ( final String original ) {
right = results [ 0 ] ; left = results [ 1 ] ; final int out [] = new int [ 2 ] ; out [ 0 ] = left ; out [ 1 ] = right ; MST[rv.UOI3Mutator]MSP[] return out ; }
SKB [ 7 ] [ d >>> 21 & 0xf | d >>> 22 & 0x30 ] ; schedule [ j ++ ] = ( t << 16 | s & 0xffff ) ; s = s >>> 16 | t & 0xffff0000 ; MST[rv.CRCR3Mutator]MSP[]
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; a = a ^ t ^ t >>> 16 - n ; return a ; MST[rv.UOI1Mutator]MSP[] }
s = s << 4 | s >>> 28 ; schedule [ j ++ ] = s ; } return schedule ; } private static int fourBytesToInt ( final byte b [] , int offset ) { int value = byteToUnsigned ( b [ offset ++ ] ) ; MST[rv.ABSMutator]MSP[]
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; a = a ^ t ^ t >>> 16 - n ; return a ; MST[rv.UOI4Mutator]MSP[] }
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.ABSMutator]MSP[]
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.UOI3Mutator]MSP[] c &= 0xfffffff ; int j = 0 ;
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; a = a ^ t ^ t >>> 16 - n ; MST[rv.UOI3Mutator]MSP[] return a ; }
left = results [ 1 ] ; MST[rv.CRCR4Mutator]MSP[] permOp ( left , right , 16 , 65535 , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 4 , 0xf0f0f0f , results ) ;
private static int byteToUnsigned ( final byte b ) { final int value = b ; return value < 0 ? value + 256 : value ; MST[InlineConstantMutator]MSP[] }
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; MST[rv.CRCR4Mutator]MSP[] value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; return value ; }
results [ 0 ] = a ; MST[rv.UOI4Mutator]MSP[] results [ 1 ] = b ; }
final byte key [] = new byte [ 8 ] ; for ( int i = 0 ; i < key . length ; i ++ ) { MST[rv.ROR1Mutator]MSP[] key [ i ] = 0 ; }
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; a = a ^ t ^ t >>> 16 - n ; MST[MathMutator]MSP[] return a ; }
right = results [ 0 ] ; left = results [ 1 ] ; MST[rv.UOI3Mutator]MSP[] final int out [] = new int [ 2 ] ; out [ 0 ] = left ; out [ 1 ] = right ; return out ; }
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; MST[rv.UOI1Mutator]MSP[] a = a ^ t ^ t >>> 16 - n ; return a ; }
b [ offset ++ ] = (byte) ( iValue >>> 16 & 0xff ) ; MST[rv.UOI4Mutator]MSP[] b [ offset ++ ] = (byte) ( iValue >>> 24 & 0xff ) ; }
final int numSaltChars = SALT_CHARS . length ; salt = lr_1 + SALT_CHARS [ randomGenerator . nextInt ( numSaltChars ) ] + MST[ConstructorCallMutator]MSP[] SALT_CHARS [ randomGenerator . nextInt ( numSaltChars ) ] ;
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; } t = left ; left = right ; right = t ; } t = right ; right = left >>> 1 | left << 31 ; MST[InlineConstantMutator]MSP[]
right = results [ 0 ] ; MST[rv.UOI1Mutator]MSP[] left = results [ 1 ] ; final int out [] = new int [ 2 ] ; out [ 0 ] = left ; out [ 1 ] = right ; return out ; }
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR2Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[InlineConstantMutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
for ( int i = 0 ; i < key . length && i < original . length ; i ++ ) { MST[rv.ABSMutator]MSP[] final int iChar = original [ i ] ; key [ i ] = (byte) ( iChar << 1 ) ; }
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR6Mutator]MSP[]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR3Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[InlineConstantMutator]MSP[]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR3Mutator]MSP[]
c = c >>> 1 | c << 27 ; MST[rv.CRCR1Mutator]MSP[] d = d >>> 1 | d << 27 ; } c &= 0xfffffff ; d &= 0xfffffff ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR4Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; MST[rv.ABSMutator]MSP[] t = t >>> 4 | t << 28 ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[MathMutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
left = results [ 1 ] ; permOp ( left , right , 16 , 65535 , results ) ; MST[VoidMethodCallMutator]MSP[] left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 4 , 0xf0f0f0f , results ) ;
u = u ^ u << 16 ^ r ^ sArr [ s ] ; MST[rv.CRCR1Mutator]MSP[] int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; t = t >>> 4 | t << 28 ;
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; c &= 0xfffffff ; int j = 0 ; MST[rv.CRCR6Mutator]MSP[]
for ( int i = 0 ; i < 16 ; i ++ ) { MST[rv.CRCR3Mutator]MSP[] if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; d = d >>> 2 | d << 26 ; } else {
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR1Mutator]MSP[]
for ( int i = 0 ; i < key . length && i < original . length ; i ++ ) { MST[InlineConstantMutator]MSP[] final int iChar = original [ i ] ; key [ i ] = (byte) ( iChar << 1 ) ; }
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.OBBN1Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; MST[MathMutator]MSP[] a = a ^ t ^ t >>> 16 - n ; return a ; }
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; d = d >>> 2 | d << 26 ; MST[rv.OBBN2Mutator]MSP[] } else {
SKB [ 7 ] [ d >>> 21 & 0xf | d >>> 22 & 0x30 ] ; schedule [ j ++ ] = ( t << 16 | s & 0xffff ) ; s = s >>> 16 | t & 0xffff0000 ; MST[rv.CRCR1Mutator]MSP[]
c = c >>> 1 | c << 27 ; d = d >>> 1 | d << 27 ; MST[rv.UOI1Mutator]MSP[] } c &= 0xfffffff ; d &= 0xfffffff ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR5Mutator]MSP[]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR2Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR3Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.UOI2Mutator]MSP[] c &= 0xfffffff ; int j = 0 ;
right = results [ 0 ] ; MST[rv.UOI4Mutator]MSP[] left = results [ 1 ] ; final int out [] = new int [ 2 ] ; out [ 0 ] = left ; out [ 1 ] = right ; return out ; }
for ( int i = 0 ; i < key . length && i < original . length ; i ++ ) { final int iChar = original [ i ] ; MST[rv.UOI2Mutator]MSP[] key [ i ] = (byte) ( iChar << 1 ) ; }
results [ 0 ] = a ; MST[InlineConstantMutator]MSP[] results [ 1 ] = b ; }
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR6Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
intToFourBytes ( out [ 1 ] , b , 4 ) ; b [ 8 ] = 0 ; int i = 2 ; int y = 0 ; int u = 128 ; MST[InlineConstantMutator]MSP[] for (; i < 13 ; i ++ ) { int j = 0 ;
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[MathMutator]MSP[] c &= 0xfffffff ; int j = 0 ;
b [ offset ++ ] = (byte) ( iValue >>> 16 & 0xff ) ; MST[rv.UOI1Mutator]MSP[] b [ offset ++ ] = (byte) ( iValue >>> 24 & 0xff ) ; }
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.UOI2Mutator]MSP[]
final int schedule [] = new int [ 32 ] ; int c = fourBytesToInt ( key , 0 ) ; int d = fourBytesToInt ( key , 4 ) ; final int results [] = new int [ 2 ] ; MST[InlineConstantMutator]MSP[]
private static void intToFourBytes ( final int iValue , final byte b [] , int offset ) { b [ offset ++ ] = (byte) ( iValue & 0xff ) ; MST[rv.UOI3Mutator]MSP[] b [ offset ++ ] = (byte) ( iValue >>> 8 & 0xff ) ;
int c = 0 ; for (; j < 6 ; j ++ ) { MST[rv.CRCR5Mutator]MSP[] c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) {
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.UOI2Mutator]MSP[]
for ( int i = 0 ; i < key . length && i < original . length ; i ++ ) { MST[rv.ROR1Mutator]MSP[] final int iChar = original [ i ] ; key [ i ] = (byte) ( iChar << 1 ) ; }
private static int dEncrypt ( int el , final int r , final int s , final int e0 , final int e1 , final int sArr [] ) { int v = r ^ r >>> 16 ; int u = v & e0 ; v &= e1 ; MST[rv.UOI1Mutator]MSP[]
d = hPermOp ( d , - 2 , 0xcccc0000 ) ; permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ; MST[rv.CRCR6Mutator]MSP[] c = results [ 1 ] ;
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; a = a ^ t ^ t >>> 16 - n ; MST[rv.CRCR6Mutator]MSP[] return a ; }
s = s << 4 | s >>> 28 ; MST[rv.UOI1Mutator]MSP[] schedule [ j ++ ] = s ; } return schedule ; } private static int fourBytesToInt ( final byte b [] , int offset ) { int value = byteToUnsigned ( b [ offset ++ ] ) ;
for ( int i = 0 ; i < key . length && i < original . length ; i ++ ) { final int iChar = original [ i ] ; key [ i ] = (byte) ( iChar << 1 ) ; MST[rv.CRCR6Mutator]MSP[] }
intToFourBytes ( out [ 1 ] , b , 4 ) ; b [ 8 ] = 0 ; int i = 2 ; int y = 0 ; int u = 128 ; MST[rv.CRCR4Mutator]MSP[] for (; i < 13 ; i ++ ) { int j = 0 ;
permOp ( left , right , 8 , 0xff00ff , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 2 , 0x33333333 , results ) ; right = results [ 0 ] ; MST[rv.UOI2Mutator]MSP[]
b [ offset ++ ] = (byte) ( iValue >>> 16 & 0xff ) ; MST[IncrementsMutator]MSP[] b [ offset ++ ] = (byte) ( iValue >>> 24 & 0xff ) ; }
left = results [ 1 ] ; MST[rv.UOI4Mutator]MSP[] permOp ( left , right , 16 , 65535 , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 4 , 0xf0f0f0f , results ) ;
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; MST[MathMutator]MSP[] d = d >>> 2 | d << 26 ; } else {
results [ 0 ] = a ; results [ 1 ] = b ; MST[rv.CRCR6Mutator]MSP[] }
private static void intToFourBytes ( final int iValue , final byte b [] , int offset ) { b [ offset ++ ] = (byte) ( iValue & 0xff ) ; b [ offset ++ ] = (byte) ( iValue >>> 8 & 0xff ) ; MST[rv.CRCR2Mutator]MSP[]
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { MST[rv.UOI2Mutator]MSP[] c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) {
permOp ( left , right , 8 , 0xff00ff , results ) ; MST[rv.CRCR6Mutator]MSP[] left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 2 , 0x33333333 , results ) ; right = results [ 0 ] ;
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; } u >>>= 1 ; MST[MathMutator]MSP[] if ( u == 0 ) {
private static int [] body ( final int schedule [] , final int eSwap0 , final int eSwap1 ) { int left = 0 ; MST[rv.CRCR1Mutator]MSP[] int right = 0 ; int t = 0 ; for ( int j = 0 ; j < 25 ; j ++ ) {
for ( int i = 0 ; i < 16 ; i ++ ) { MST[rv.UOI4Mutator]MSP[] if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; d = d >>> 2 | d << 26 ; } else {
SKB [ 7 ] [ d >>> 21 & 0xf | d >>> 22 & 0x30 ] ; schedule [ j ++ ] = ( t << 16 | s & 0xffff ) ; MST[experimental.RemoveIncrementsMutator]MSP[] s = s >>> 16 | t & 0xffff0000 ;
private static int [] body ( final int schedule [] , final int eSwap0 , final int eSwap1 ) { int left = 0 ; int right = 0 ; int t = 0 ; MST[rv.CRCR5Mutator]MSP[] for ( int j = 0 ; j < 25 ; j ++ ) {
for ( int i = 0 ; i < 16 ; i ++ ) { MST[rv.ROR1Mutator]MSP[] if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; d = d >>> 2 | d << 26 ; } else {
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; MST[rv.UOI3Mutator]MSP[] value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; return value ; }
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; } t = left ; left = right ; right = t ; } t = right ; right = left >>> 1 | left << 31 ; MST[rv.UOI4Mutator]MSP[]
left = results [ 1 ] ; permOp ( left , right , 16 , 65535 , results ) ; MST[rv.UOI1Mutator]MSP[] left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 4 , 0xf0f0f0f , results ) ;
permOp ( d , c , 4 , 0xf0f0f0f , results ) ; MST[rv.CRCR4Mutator]MSP[] d = results [ 0 ] ; c = results [ 1 ] ; c = hPermOp ( c , - 2 , 0xcccc0000 ) ;
final char charOne = salt . charAt ( 1 ) ; buffer . setCharAt ( 0 , charZero ) ; buffer . setCharAt ( 1 , charOne ) ; final int eSwap0 = CON_SALT [ charZero ] ; MST[rv.UOI1Mutator]MSP[] final int eSwap1 = CON_SALT [ charOne ] << 4 ;
d = hPermOp ( d , - 2 , 0xcccc0000 ) ; MST[InlineConstantMutator]MSP[] permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ; c = results [ 1 ] ;
left = t >>> 1 | t << 31 ; final int results [] = new int [ 2 ] ; permOp ( right , left , 1 , 0x55555555 , results ) ; right = results [ 0 ] ; left = results [ 1 ] ; MST[rv.CRCR2Mutator]MSP[]
permOp ( d , c , 4 , 0xf0f0f0f , results ) ; d = results [ 0 ] ; MST[rv.CRCR6Mutator]MSP[] c = results [ 1 ] ; c = hPermOp ( c , - 2 , 0xcccc0000 ) ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.ABSMutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR4Mutator]MSP[]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR5Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR3Mutator]MSP[]
public static String crypt ( final byte [] original ) { return crypt ( original , null ) ; } public static String crypt ( final byte [] original , String salt ) { if ( salt == null ) { MST[rv.ROR5Mutator]MSP[] final ThreadLocalRandom randomGenerator = ThreadLocalRandom . current () ;
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[InlineConstantMutator]MSP[] c &= 0xfffffff ; int j = 0 ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR2Mutator]MSP[]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR6Mutator]MSP[]
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[MathMutator]MSP[]
left = t >>> 1 | t << 31 ; final int results [] = new int [ 2 ] ; MST[rv.CRCR1Mutator]MSP[] permOp ( right , left , 1 , 0x55555555 , results ) ; right = results [ 0 ] ; left = results [ 1 ] ;
left = t >>> 1 | t << 31 ; final int results [] = new int [ 2 ] ; permOp ( right , left , 1 , 0x55555555 , results ) ; MST[rv.CRCR5Mutator]MSP[] right = results [ 0 ] ; left = results [ 1 ] ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR6Mutator]MSP[]
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR4Mutator]MSP[]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.UOI2Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[InlineConstantMutator]MSP[]
left = results [ 1 ] ; permOp ( left , right , 16 , 65535 , results ) ; left = results [ 0 ] ; MST[rv.UOI3Mutator]MSP[] right = results [ 1 ] ; permOp ( right , left , 4 , 0xf0f0f0f , results ) ;
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; MST[rv.UOI4Mutator]MSP[] return value ; }
private static void permOp ( int a , int b , final int n , final int m , final int results [] ) { final int t = ( a >>> n ^ b ) & m ; MST[rv.UOI4Mutator]MSP[] a ^= t << n ; b ^= t ;
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; } t = left ; left = right ; right = t ; MST[rv.UOI1Mutator]MSP[] } t = right ; right = left >>> 1 | left << 31 ;
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { MST[rv.ROR3Mutator]MSP[] c = c >>> 2 | c << 26 ; d = d >>> 2 | d << 26 ; } else {
final int schedule [] = desSetKey ( key ) ; final int out [] = body ( schedule , eSwap0 , eSwap1 ) ; final byte b [] = new byte [ 9 ] ; intToFourBytes ( out [ 0 ] , b , 0 ) ; MST[rv.UOI3Mutator]MSP[]
final int schedule [] = new int [ 32 ] ; int c = fourBytesToInt ( key , 0 ) ; int d = fourBytesToInt ( key , 4 ) ; MST[rv.CRCR1Mutator]MSP[] final int results [] = new int [ 2 ] ;
left = t >>> 1 | t << 31 ; MST[rv.OBBN1Mutator]MSP[] final int results [] = new int [ 2 ] ; permOp ( right , left , 1 , 0x55555555 , results ) ; right = results [ 0 ] ; left = results [ 1 ] ;
private static int [] body ( final int schedule [] , final int eSwap0 , final int eSwap1 ) { int left = 0 ; int right = 0 ; int t = 0 ; for ( int j = 0 ; j < 25 ; j ++ ) { MST[rv.CRCR1Mutator]MSP[]
private static int byteToUnsigned ( final byte b ) { final int value = b ; return value < 0 ? value + 256 : value ; MST[ConditionalsBoundaryMutator]MSP[] }
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; MST[rv.UOI2Mutator]MSP[] d = d >>> 2 | d << 26 ; } else {
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.CRCR5Mutator]MSP[] c &= 0xfffffff ; int j = 0 ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.OBBN3Mutator]MSP[]
b [ offset ++ ] = (byte) ( iValue >>> 16 & 0xff ) ; b [ offset ++ ] = (byte) ( iValue >>> 24 & 0xff ) ; MST[rv.CRCR6Mutator]MSP[] }
intToFourBytes ( out [ 1 ] , b , 4 ) ; b [ 8 ] = 0 ; int i = 2 ; int y = 0 ; int u = 128 ; for (; i < 13 ; i ++ ) { MST[rv.CRCR6Mutator]MSP[] int j = 0 ;
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; MST[rv.UOI3Mutator]MSP[] d = d >>> 2 | d << 26 ; } else {
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR1Mutator]MSP[]
c = c >>> 1 | c << 27 ; d = d >>> 1 | d << 27 ; MST[rv.CRCR3Mutator]MSP[] } c &= 0xfffffff ; d &= 0xfffffff ;
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; t = t >>> 4 | t << 28 ; MST[rv.UOI4Mutator]MSP[]
permOp ( d , c , 4 , 0xf0f0f0f , results ) ; MST[rv.UOI3Mutator]MSP[] d = results [ 0 ] ; c = results [ 1 ] ; c = hPermOp ( c , - 2 , 0xcccc0000 ) ;
for ( int i = 0 ; i < key . length && i < original . length ; i ++ ) { final int iChar = original [ i ] ; key [ i ] = (byte) ( iChar << 1 ) ; MST[rv.ABSMutator]MSP[] }
right = results [ 0 ] ; left = results [ 1 ] ; MST[rv.CRCR3Mutator]MSP[] final int out [] = new int [ 2 ] ; out [ 0 ] = left ; out [ 1 ] = right ; return out ; }
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.UOI3Mutator]MSP[]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR6Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.OBBN1Mutator]MSP[]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR4Mutator]MSP[]
SKB [ 7 ] [ d >>> 21 & 0xf | d >>> 22 & 0x30 ] ; schedule [ j ++ ] = ( t << 16 | s & 0xffff ) ; MST[rv.CRCR2Mutator]MSP[] s = s >>> 16 | t & 0xffff0000 ;
for ( int i = 0 ; i < key . length && i < original . length ; i ++ ) { final int iChar = original [ i ] ; key [ i ] = (byte) ( iChar << 1 ) ; MST[rv.UOI4Mutator]MSP[] }
final int numSaltChars = SALT_CHARS . length ; salt = lr_1 + SALT_CHARS [ randomGenerator . nextInt ( numSaltChars ) ] + SALT_CHARS [ randomGenerator . nextInt ( numSaltChars ) ] ; MST[NonVoidMethodCallMutator]MSP[]
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; MST[InlineConstantMutator]MSP[] d = d >>> 2 | d << 26 ; } else {
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; } t = left ; left = right ; MST[rv.UOI4Mutator]MSP[] right = t ; } t = right ; right = left >>> 1 | left << 31 ;
final char charOne = salt . charAt ( 1 ) ; buffer . setCharAt ( 0 , charZero ) ; MST[InlineConstantMutator]MSP[] buffer . setCharAt ( 1 , charOne ) ; final int eSwap0 = CON_SALT [ charZero ] ; final int eSwap1 = CON_SALT [ charOne ] << 4 ;
s = s << 4 | s >>> 28 ; MST[rv.CRCR3Mutator]MSP[] schedule [ j ++ ] = s ; } return schedule ; } private static int fourBytesToInt ( final byte b [] , int offset ) { int value = byteToUnsigned ( b [ offset ++ ] ) ;
private static void intToFourBytes ( final int iValue , final byte b [] , int offset ) { b [ offset ++ ] = (byte) ( iValue & 0xff ) ; b [ offset ++ ] = (byte) ( iValue >>> 8 & 0xff ) ; MST[InlineConstantMutator]MSP[]
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.UOI4Mutator]MSP[]
s = s << 4 | s >>> 28 ; MST[rv.CRCR2Mutator]MSP[] schedule [ j ++ ] = s ; } return schedule ; } private static int fourBytesToInt ( final byte b [] , int offset ) { int value = byteToUnsigned ( b [ offset ++ ] ) ;
left = results [ 1 ] ; permOp ( left , right , 16 , 65535 , results ) ; MST[rv.CRCR2Mutator]MSP[] left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 4 , 0xf0f0f0f , results ) ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[MathMutator]MSP[]
public static String crypt ( final byte [] original ) { return crypt ( original , null ) ; } public static String crypt ( final byte [] original , String salt ) { if ( salt == null ) { MST[NegateConditionalsMutator]MSP[] final ThreadLocalRandom randomGenerator = ThreadLocalRandom . current () ;
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; MST[rv.ABSMutator]MSP[] } u >>>= 1 ; if ( u == 0 ) {
y ++ ; u = 128 ; } buffer . setCharAt ( i , ( char ) COV2CHAR [ c ] ) ; MST[rv.UOI3Mutator]MSP[] } } return buffer . toString () ; } public static String crypt ( final String original ) {
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[MathMutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.OBBN2Mutator]MSP[] c &= 0xfffffff ; int j = 0 ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[InlineConstantMutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
int c = 0 ; MST[rv.CRCR3Mutator]MSP[] for (; j < 6 ; j ++ ) { c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) {
permOp ( left , right , 8 , 0xff00ff , results ) ; left = results [ 0 ] ; MST[rv.UOI1Mutator]MSP[] right = results [ 1 ] ; permOp ( right , left , 2 , 0x33333333 , results ) ; right = results [ 0 ] ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR5Mutator]MSP[]
private static int [] body ( final int schedule [] , final int eSwap0 , final int eSwap1 ) { int left = 0 ; int right = 0 ; int t = 0 ; for ( int j = 0 ; j < 25 ; j ++ ) { MST[rv.CRCR5Mutator]MSP[]
d = hPermOp ( d , - 2 , 0xcccc0000 ) ; permOp ( d , c , 1 , 0x55555555 , results ) ; MST[rv.CRCR5Mutator]MSP[] d = results [ 0 ] ; c = results [ 1 ] ;
SKB [ 7 ] [ d >>> 21 & 0xf | d >>> 22 & 0x30 ] ; schedule [ j ++ ] = ( t << 16 | s & 0xffff ) ; MST[MathMutator]MSP[] s = s >>> 16 | t & 0xffff0000 ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.UOI1Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; MST[rv.UOI1Mutator]MSP[] return value ; }
right = results [ 0 ] ; left = results [ 1 ] ; final int out [] = new int [ 2 ] ; out [ 0 ] = left ; out [ 1 ] = right ; MST[rv.CRCR3Mutator]MSP[] return out ; }
left = results [ 1 ] ; permOp ( left , right , 16 , 65535 , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 4 , 0xf0f0f0f , results ) ; MST[rv.UOI2Mutator]MSP[]
private static int byteToUnsigned ( final byte b ) { final int value = b ; return value < 0 ? value + 256 : value ; MST[rv.CRCR4Mutator]MSP[] }
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[InlineConstantMutator]MSP[]
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR5Mutator]MSP[]
private static void permOp ( int a , int b , final int n , final int m , final int results [] ) { final int t = ( a >>> n ^ b ) & m ; a ^= t << n ; MST[rv.UOI3Mutator]MSP[] b ^= t ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR2Mutator]MSP[]
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; t = t >>> 4 | t << 28 ; MST[rv.OBBN1Mutator]MSP[]
permOp ( c , d , 8 , 0xff00ff , results ) ; MST[rv.CRCR6Mutator]MSP[] c = results [ 0 ] ; d = results [ 1 ] ; permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[MathMutator]MSP[]
intToFourBytes ( out [ 1 ] , b , 4 ) ; b [ 8 ] = 0 ; int i = 2 ; int y = 0 ; int u = 128 ; for (; i < 13 ; i ++ ) { MST[rv.ROR1Mutator]MSP[] int j = 0 ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[InlineConstantMutator]MSP[]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR3Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; t = t >>> 4 | t << 28 ; MST[rv.UOI3Mutator]MSP[]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.OBBN1Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR4Mutator]MSP[]
permOp ( left , right , 8 , 0xff00ff , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; MST[rv.UOI3Mutator]MSP[] permOp ( right , left , 2 , 0x33333333 , results ) ; right = results [ 0 ] ;
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; MST[rv.UOI3Mutator]MSP[] } t = left ; left = right ; right = t ; } t = right ; right = left >>> 1 | left << 31 ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR3Mutator]MSP[]
SKB [ 7 ] [ d >>> 21 & 0xf | d >>> 22 & 0x30 ] ; schedule [ j ++ ] = ( t << 16 | s & 0xffff ) ; MST[rv.CRCR1Mutator]MSP[] s = s >>> 16 | t & 0xffff0000 ;
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.OBBN1Mutator]MSP[] c &= 0xfffffff ; int j = 0 ;
b [ offset ++ ] = (byte) ( iValue >>> 16 & 0xff ) ; b [ offset ++ ] = (byte) ( iValue >>> 24 & 0xff ) ; MST[rv.UOI3Mutator]MSP[] }
intToFourBytes ( out [ 1 ] , b , 4 ) ; b [ 8 ] = 0 ; int i = 2 ; int y = 0 ; int u = 128 ; for (; i < 13 ; i ++ ) { MST[rv.UOI4Mutator]MSP[] int j = 0 ;
int c = 0 ; for (; j < 6 ; j ++ ) { MST[rv.UOI3Mutator]MSP[] c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) {
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; MST[MathMutator]MSP[] return value ; }
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.OBBN1Mutator]MSP[]
left = t >>> 1 | t << 31 ; final int results [] = new int [ 2 ] ; permOp ( right , left , 1 , 0x55555555 , results ) ; right = results [ 0 ] ; left = results [ 1 ] ; MST[rv.UOI2Mutator]MSP[]
private static int byteToUnsigned ( final byte b ) { final int value = b ; return value < 0 ? value + 256 : value ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] }
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; d = d >>> 2 | d << 26 ; MST[rv.CRCR6Mutator]MSP[] } else {
b [ offset ++ ] = (byte) ( iValue >>> 16 & 0xff ) ; b [ offset ++ ] = (byte) ( iValue >>> 24 & 0xff ) ; MST[rv.OBBN1Mutator]MSP[] }
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.UOI3Mutator]MSP[] c &= 0xfffffff ; int j = 0 ;
permOp ( c , d , 8 , 0xff00ff , results ) ; c = results [ 0 ] ; MST[InlineConstantMutator]MSP[] d = results [ 1 ] ; permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.OBBN3Mutator]MSP[]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.UOI4Mutator]MSP[]
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.UOI1Mutator]MSP[]
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; } t = left ; left = right ; right = t ; } t = right ; right = left >>> 1 | left << 31 ; MST[rv.CRCR6Mutator]MSP[]
permOp ( left , right , 8 , 0xff00ff , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 2 , 0x33333333 , results ) ; MST[rv.CRCR1Mutator]MSP[] right = results [ 0 ] ;
permOp ( left , right , 8 , 0xff00ff , results ) ; MST[rv.ABSMutator]MSP[] left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 2 , 0x33333333 , results ) ; right = results [ 0 ] ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR5Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
for ( int i = 0 ; i < key . length && i < original . length ; i ++ ) { MST[rv.ABSMutator]MSP[] final int iChar = original [ i ] ; key [ i ] = (byte) ( iChar << 1 ) ; }
d = hPermOp ( d , - 2 , 0xcccc0000 ) ; permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ; MST[rv.CRCR3Mutator]MSP[] c = results [ 1 ] ;
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.CRCR2Mutator]MSP[] c &= 0xfffffff ; int j = 0 ;
final int schedule [] = desSetKey ( key ) ; final int out [] = body ( schedule , eSwap0 , eSwap1 ) ; MST[rv.UOI3Mutator]MSP[] final byte b [] = new byte [ 9 ] ; intToFourBytes ( out [ 0 ] , b , 0 ) ;
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
left = results [ 1 ] ; permOp ( left , right , 16 , 65535 , results ) ; MST[rv.UOI4Mutator]MSP[] left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 4 , 0xf0f0f0f , results ) ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR1Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
permOp ( c , d , 8 , 0xff00ff , results ) ; c = results [ 0 ] ; MST[rv.UOI4Mutator]MSP[] d = results [ 1 ] ; permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ;
final byte key [] = new byte [ 8 ] ; for ( int i = 0 ; i < key . length ; i ++ ) { MST[rv.UOI1Mutator]MSP[] key [ i ] = 0 ; }
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; MST[InlineConstantMutator]MSP[] } t = left ; left = right ; right = t ; } t = right ; right = left >>> 1 | left << 31 ;
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; c &= 0xfffffff ; int j = 0 ; MST[rv.CRCR3Mutator]MSP[]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR5Mutator]MSP[]
permOp ( d , c , 4 , 0xf0f0f0f , results ) ; MST[rv.CRCR5Mutator]MSP[] d = results [ 0 ] ; c = results [ 1 ] ; c = hPermOp ( c , - 2 , 0xcccc0000 ) ;
permOp ( left , right , 8 , 0xff00ff , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 2 , 0x33333333 , results ) ; MST[rv.UOI3Mutator]MSP[] right = results [ 0 ] ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.UOI4Mutator]MSP[]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.OBBN2Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
c = c >>> 1 | c << 27 ; d = d >>> 1 | d << 27 ; } c &= 0xfffffff ; MST[rv.UOI2Mutator]MSP[] d &= 0xfffffff ;
intToFourBytes ( out [ 1 ] , b , 4 ) ; b [ 8 ] = 0 ; MST[InlineConstantMutator]MSP[] int i = 2 ; int y = 0 ; int u = 128 ; for (; i < 13 ; i ++ ) { int j = 0 ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR2Mutator]MSP[]
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; MST[rv.UOI2Mutator]MSP[] t = t >>> 4 | t << 28 ;
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; t = t >>> 4 | t << 28 ; MST[rv.CRCR5Mutator]MSP[]
SPTRANS [ 4 ] [ u >>> 16 & 0x3f ] | SPTRANS [ 6 ] [ u >>> 24 & 0x3f ] ; return el ; MST[rv.UOI3Mutator]MSP[] } private static int [] desSetKey ( final byte key [] ) {
permOp ( c , d , 8 , 0xff00ff , results ) ; c = results [ 0 ] ; d = results [ 1 ] ; permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ; MST[rv.CRCR5Mutator]MSP[]
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; t = t >>> 4 | t << 28 ; MST[rv.CRCR6Mutator]MSP[]
private static int dEncrypt ( int el , final int r , final int s , final int e0 , final int e1 , final int sArr [] ) { int v = r ^ r >>> 16 ; int u = v & e0 ; v &= e1 ; MST[rv.UOI4Mutator]MSP[]
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.ABSMutator]MSP[]
private static int byteToUnsigned ( final byte b ) { final int value = b ; return value < 0 ? value + 256 : value ; MST[rv.ROR1Mutator]MSP[] }
y ++ ; u = 128 ; } buffer . setCharAt ( i , ( char ) COV2CHAR [ c ] ) ; MST[rv.UOI1Mutator]MSP[] } } return buffer . toString () ; } public static String crypt ( final String original ) {
permOp ( d , c , 4 , 0xf0f0f0f , results ) ; MST[rv.CRCR1Mutator]MSP[] d = results [ 0 ] ; c = results [ 1 ] ; c = hPermOp ( c , - 2 , 0xcccc0000 ) ;
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; MST[rv.UOI3Mutator]MSP[] } t = left ; left = right ; right = t ; } t = right ; right = left >>> 1 | left << 31 ;
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; } t = left ; left = right ; right = t ; } t = right ; right = left >>> 1 | left << 31 ; MST[rv.CRCR3Mutator]MSP[]
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; } t = left ; left = right ; right = t ; } t = right ; right = left >>> 1 | left << 31 ; MST[rv.CRCR4Mutator]MSP[]
for ( int i = 0 ; i < key . length && i < original . length ; i ++ ) { MST[rv.ROR1Mutator]MSP[] final int iChar = original [ i ] ; key [ i ] = (byte) ( iChar << 1 ) ; }
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR3Mutator]MSP[]
private static void permOp ( int a , int b , final int n , final int m , final int results [] ) { final int t = ( a >>> n ^ b ) & m ; MST[rv.UOI4Mutator]MSP[] a ^= t << n ; b ^= t ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR3Mutator]MSP[]
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; MST[MathMutator]MSP[] t = t >>> 4 | t << 28 ;
d = hPermOp ( d , - 2 , 0xcccc0000 ) ; MST[rv.UOI3Mutator]MSP[] permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ; c = results [ 1 ] ;
private static void permOp ( int a , int b , final int n , final int m , final int results [] ) { final int t = ( a >>> n ^ b ) & m ; a ^= t << n ; MST[rv.ABSMutator]MSP[] b ^= t ;
permOp ( left , right , 8 , 0xff00ff , results ) ; MST[rv.UOI2Mutator]MSP[] left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 2 , 0x33333333 , results ) ; right = results [ 0 ] ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR6Mutator]MSP[]
for ( int i = 0 ; i < 32 ; i += 4 ) { MST[InlineConstantMutator]MSP[] left = dEncrypt ( left , right , i , eSwap0 , eSwap1 , schedule ) ;
left = results [ 1 ] ; MST[InlineConstantMutator]MSP[] permOp ( left , right , 16 , 65535 , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 4 , 0xf0f0f0f , results ) ;
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; MST[rv.UOI1Mutator]MSP[] value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; return value ; }
right = results [ 0 ] ; left = results [ 1 ] ; final int out [] = new int [ 2 ] ; MST[rv.CRCR6Mutator]MSP[] out [ 0 ] = left ; out [ 1 ] = right ; return out ; }
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; MST[rv.AOR2Mutator]MSP[] a = a ^ t ^ t >>> 16 - n ; return a ; }
permOp ( c , d , 8 , 0xff00ff , results ) ; c = results [ 0 ] ; d = results [ 1 ] ; MST[rv.ABSMutator]MSP[] permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ;
SKB [ 7 ] [ d >>> 21 & 0xf | d >>> 22 & 0x30 ] ; schedule [ j ++ ] = ( t << 16 | s & 0xffff ) ; s = s >>> 16 | t & 0xffff0000 ; MST[rv.ABSMutator]MSP[]
private static void intToFourBytes ( final int iValue , final byte b [] , int offset ) { b [ offset ++ ] = (byte) ( iValue & 0xff ) ; b [ offset ++ ] = (byte) ( iValue >>> 8 & 0xff ) ; MST[rv.CRCR4Mutator]MSP[]
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; MST[rv.CRCR1Mutator]MSP[] a = a ^ t ^ t >>> 16 - n ; return a ; }
intToFourBytes ( out [ 1 ] , b , 4 ) ; b [ 8 ] = 0 ; int i = 2 ; MST[rv.CRCR3Mutator]MSP[] int y = 0 ; int u = 128 ; for (; i < 13 ; i ++ ) { int j = 0 ;
private static int [] body ( final int schedule [] , final int eSwap0 , final int eSwap1 ) { int left = 0 ; int right = 0 ; MST[rv.CRCR5Mutator]MSP[] int t = 0 ; for ( int j = 0 ; j < 25 ; j ++ ) {
for ( int i = 0 ; i < 16 ; i ++ ) { MST[rv.UOI1Mutator]MSP[] if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; d = d >>> 2 | d << 26 ; } else {
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR1Mutator]MSP[]
final char charOne = salt . charAt ( 1 ) ; buffer . setCharAt ( 0 , charZero ) ; buffer . setCharAt ( 1 , charOne ) ; final int eSwap0 = CON_SALT [ charZero ] ; MST[rv.UOI4Mutator]MSP[] final int eSwap1 = CON_SALT [ charOne ] << 4 ;
final char charOne = salt . charAt ( 1 ) ; buffer . setCharAt ( 0 , charZero ) ; buffer . setCharAt ( 1 , charOne ) ; MST[rv.UOI2Mutator]MSP[] final int eSwap0 = CON_SALT [ charZero ] ; final int eSwap1 = CON_SALT [ charOne ] << 4 ;
y ++ ; u = 128 ; } buffer . setCharAt ( i , ( char ) COV2CHAR [ c ] ) ; MST[rv.ABSMutator]MSP[] } } return buffer . toString () ; } public static String crypt ( final String original ) {
intToFourBytes ( out [ 1 ] , b , 4 ) ; MST[rv.CRCR1Mutator]MSP[] b [ 8 ] = 0 ; int i = 2 ; int y = 0 ; int u = 128 ; for (; i < 13 ; i ++ ) { int j = 0 ;
private static int byteToUnsigned ( final byte b ) { final int value = b ; return value < 0 ? value + 256 : value ; MST[rv.AOR1Mutator]MSP[] }
left = t >>> 1 | t << 31 ; final int results [] = new int [ 2 ] ; permOp ( right , left , 1 , 0x55555555 , results ) ; MST[rv.CRCR2Mutator]MSP[] right = results [ 0 ] ; left = results [ 1 ] ;
final int numSaltChars = SALT_CHARS . length ; salt = lr_1 + SALT_CHARS [ randomGenerator . nextInt ( numSaltChars ) ] + MST[rv.UOI3Mutator]MSP[] SALT_CHARS [ randomGenerator . nextInt ( numSaltChars ) ] ;
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) {
} else if ( ! salt . matches ( lr_2 + B64 . B64T_STRING + lr_3 ) ) { throw new IllegalArgumentException ( lr_4 + salt ) ; } final StringBuilder buffer = new StringBuilder ( lr_5 ) ; final char charZero = salt . charAt ( 0 ) ; MST[rv.CRCR6Mutator]MSP[]
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR1Mutator]MSP[]
s = s << 4 | s >>> 28 ; MST[rv.OBBN2Mutator]MSP[] schedule [ j ++ ] = s ; } return schedule ; } private static int fourBytesToInt ( final byte b [] , int offset ) { int value = byteToUnsigned ( b [ offset ++ ] ) ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.UOI3Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[InlineConstantMutator]MSP[]
left = t >>> 1 | t << 31 ; MST[rv.CRCR2Mutator]MSP[] final int results [] = new int [ 2 ] ; permOp ( right , left , 1 , 0x55555555 , results ) ; right = results [ 0 ] ; left = results [ 1 ] ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.UOI3Mutator]MSP[]
left = t >>> 1 | t << 31 ; final int results [] = new int [ 2 ] ; permOp ( right , left , 1 , 0x55555555 , results ) ; MST[rv.CRCR6Mutator]MSP[] right = results [ 0 ] ; left = results [ 1 ] ;
permOp ( d , c , 4 , 0xf0f0f0f , results ) ; d = results [ 0 ] ; c = results [ 1 ] ; c = hPermOp ( c , - 2 , 0xcccc0000 ) ; MST[rv.CRCR6Mutator]MSP[]
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; MST[rv.ABSMutator]MSP[] a = a ^ t ^ t >>> 16 - n ; return a ; }
d = hPermOp ( d , - 2 , 0xcccc0000 ) ; permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ; MST[rv.UOI3Mutator]MSP[] c = results [ 1 ] ;
c = c >>> 1 | c << 27 ; MST[rv.ABSMutator]MSP[] d = d >>> 1 | d << 27 ; } c &= 0xfffffff ; d &= 0xfffffff ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.OBBN1Mutator]MSP[]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.ABSMutator]MSP[]
private static int byteToUnsigned ( final byte b ) { final int value = b ; MST[rv.UOI3Mutator]MSP[] return value < 0 ? value + 256 : value ; }
private static int byteToUnsigned ( final byte b ) { final int value = b ; return value < 0 ? value + 256 : value ; MST[NegateConditionalsMutator]MSP[] }
d = hPermOp ( d , - 2 , 0xcccc0000 ) ; permOp ( d , c , 1 , 0x55555555 , results ) ; MST[rv.UOI1Mutator]MSP[] d = results [ 0 ] ; c = results [ 1 ] ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR4Mutator]MSP[]
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.CRCR4Mutator]MSP[] c &= 0xfffffff ; int j = 0 ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.UOI1Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
u = u ^ u << 16 ^ r ^ sArr [ s ] ; MST[rv.ABSMutator]MSP[] int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; t = t >>> 4 | t << 28 ;
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.CRCR5Mutator]MSP[] c &= 0xfffffff ; int j = 0 ;
SKB [ 7 ] [ d >>> 21 & 0xf | d >>> 22 & 0x30 ] ; schedule [ j ++ ] = ( t << 16 | s & 0xffff ) ; MST[rv.OBBN1Mutator]MSP[] s = s >>> 16 | t & 0xffff0000 ;
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; MST[rv.UOI4Mutator]MSP[] return value ; }
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR1Mutator]MSP[]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR2Mutator]MSP[]
for ( int i = 0 ; i < 32 ; i += 4 ) { MST[rv.CRCR5Mutator]MSP[] left = dEncrypt ( left , right , i , eSwap0 , eSwap1 , schedule ) ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR6Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[InlineConstantMutator]MSP[]
d = hPermOp ( d , - 2 , 0xcccc0000 ) ; permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ; c = results [ 1 ] ; MST[rv.CRCR5Mutator]MSP[]
for ( int i = 0 ; i < 32 ; i += 4 ) { left = dEncrypt ( left , right , i , eSwap0 , eSwap1 , schedule ) ; MST[rv.UOI4Mutator]MSP[]
d = hPermOp ( d , - 2 , 0xcccc0000 ) ; permOp ( d , c , 1 , 0x55555555 , results ) ; MST[rv.CRCR1Mutator]MSP[] d = results [ 0 ] ; c = results [ 1 ] ;
SKB [ 7 ] [ d >>> 21 & 0xf | d >>> 22 & 0x30 ] ; schedule [ j ++ ] = ( t << 16 | s & 0xffff ) ; MST[rv.ABSMutator]MSP[] s = s >>> 16 | t & 0xffff0000 ;
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { MST[rv.UOI2Mutator]MSP[] c = c >>> 2 | c << 26 ; d = d >>> 2 | d << 26 ; } else {
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { MST[rv.ABSMutator]MSP[] c = c >>> 2 | c << 26 ; d = d >>> 2 | d << 26 ; } else {
private static void permOp ( int a , int b , final int n , final int m , final int results [] ) { final int t = ( a >>> n ^ b ) & m ; MST[MathMutator]MSP[] a ^= t << n ; b ^= t ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.UOI3Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
u = u ^ u << 16 ^ r ^ sArr [ s ] ; MST[rv.UOI3Mutator]MSP[] int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; t = t >>> 4 | t << 28 ;
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; MST[rv.UOI1Mutator]MSP[] } t = left ; left = right ; right = t ; } t = right ; right = left >>> 1 | left << 31 ;
private static int dEncrypt ( int el , final int r , final int s , final int e0 , final int e1 , final int sArr [] ) { int v = r ^ r >>> 16 ; int u = v & e0 ; MST[rv.OBBN1Mutator]MSP[] v &= e1 ;
private static int dEncrypt ( int el , final int r , final int s , final int e0 , final int e1 , final int sArr [] ) { int v = r ^ r >>> 16 ; int u = v & e0 ; MST[MathMutator]MSP[] v &= e1 ;
y ++ ; u = 128 ; } buffer . setCharAt ( i , ( char ) COV2CHAR [ c ] ) ; MST[rv.UOI2Mutator]MSP[] } } return buffer . toString () ; } public static String crypt ( final String original ) {
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR3Mutator]MSP[]
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; } u >>>= 1 ; MST[rv.CRCR4Mutator]MSP[] if ( u == 0 ) {
permOp ( c , d , 8 , 0xff00ff , results ) ; c = results [ 0 ] ; d = results [ 1 ] ; MST[rv.CRCR6Mutator]MSP[] permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ;
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.OBBN2Mutator]MSP[] c &= 0xfffffff ; int j = 0 ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR1Mutator]MSP[]
} else if ( ! salt . matches ( lr_2 + B64 . B64T_STRING + lr_3 ) ) { throw new IllegalArgumentException ( lr_4 + salt ) ; } final StringBuilder buffer = new StringBuilder ( lr_5 ) ; final char charZero = salt . charAt ( 0 ) ; MST[InlineConstantMutator]MSP[]
permOp ( c , d , 8 , 0xff00ff , results ) ; c = results [ 0 ] ; d = results [ 1 ] ; permOp ( d , c , 1 , 0x55555555 , results ) ; MST[rv.CRCR3Mutator]MSP[] d = results [ 0 ] ;
b [ offset ++ ] = (byte) ( iValue >>> 16 & 0xff ) ; MST[MathMutator]MSP[] b [ offset ++ ] = (byte) ( iValue >>> 24 & 0xff ) ; }
final int schedule [] = desSetKey ( key ) ; final int out [] = body ( schedule , eSwap0 , eSwap1 ) ; final byte b [] = new byte [ 9 ] ; MST[rv.CRCR1Mutator]MSP[] intToFourBytes ( out [ 0 ] , b , 0 ) ;
permOp ( d , c , 4 , 0xf0f0f0f , results ) ; d = results [ 0 ] ; MST[rv.CRCR3Mutator]MSP[] c = results [ 1 ] ; c = hPermOp ( c , - 2 , 0xcccc0000 ) ;
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; a = a ^ t ^ t >>> 16 - n ; MST[rv.UOI4Mutator]MSP[] return a ; }
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR5Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
b [ offset ++ ] = (byte) ( iValue >>> 16 & 0xff ) ; MST[InlineConstantMutator]MSP[] b [ offset ++ ] = (byte) ( iValue >>> 24 & 0xff ) ; }
d = hPermOp ( d , - 2 , 0xcccc0000 ) ; permOp ( d , c , 1 , 0x55555555 , results ) ; MST[rv.UOI4Mutator]MSP[] d = results [ 0 ] ; c = results [ 1 ] ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR1Mutator]MSP[]
d = hPermOp ( d , - 2 , 0xcccc0000 ) ; MST[rv.CRCR4Mutator]MSP[] permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ; c = results [ 1 ] ;
SKB [ 7 ] [ d >>> 21 & 0xf | d >>> 22 & 0x30 ] ; schedule [ j ++ ] = ( t << 16 | s & 0xffff ) ; MST[InlineConstantMutator]MSP[] s = s >>> 16 | t & 0xffff0000 ;
results [ 0 ] = a ; MST[rv.UOI1Mutator]MSP[] results [ 1 ] = b ; }
permOp ( c , d , 8 , 0xff00ff , results ) ; MST[rv.CRCR2Mutator]MSP[] c = results [ 0 ] ; d = results [ 1 ] ; permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR2Mutator]MSP[]
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.UOI1Mutator]MSP[]
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; d = d >>> 2 | d << 26 ; MST[rv.UOI2Mutator]MSP[] } else {
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR4Mutator]MSP[]
left = t >>> 1 | t << 31 ; MST[rv.CRCR6Mutator]MSP[] final int results [] = new int [ 2 ] ; permOp ( right , left , 1 , 0x55555555 , results ) ; right = results [ 0 ] ; left = results [ 1 ] ;
b [ offset ++ ] = (byte) ( iValue >>> 16 & 0xff ) ; MST[rv.ABSMutator]MSP[] b [ offset ++ ] = (byte) ( iValue >>> 24 & 0xff ) ; }
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.OBBN2Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
left = t >>> 1 | t << 31 ; MST[rv.CRCR5Mutator]MSP[] final int results [] = new int [ 2 ] ; permOp ( right , left , 1 , 0x55555555 , results ) ; right = results [ 0 ] ; left = results [ 1 ] ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.OBBN1Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
SKB [ 7 ] [ d >>> 21 & 0xf | d >>> 22 & 0x30 ] ; schedule [ j ++ ] = ( t << 16 | s & 0xffff ) ; MST[MathMutator]MSP[] s = s >>> 16 | t & 0xffff0000 ;
private static int dEncrypt ( int el , final int r , final int s , final int e0 , final int e1 , final int sArr [] ) { int v = r ^ r >>> 16 ; int u = v & e0 ; MST[rv.ABSMutator]MSP[] v &= e1 ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.UOI4Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.CRCR4Mutator]MSP[] c &= 0xfffffff ; int j = 0 ;
private static int dEncrypt ( int el , final int r , final int s , final int e0 , final int e1 , final int sArr [] ) { int v = r ^ r >>> 16 ; int u = v & e0 ; MST[rv.UOI2Mutator]MSP[] v &= e1 ;
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; MST[InlineConstantMutator]MSP[] t = t >>> 4 | t << 28 ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR6Mutator]MSP[]
permOp ( d , c , 4 , 0xf0f0f0f , results ) ; MST[rv.UOI1Mutator]MSP[] d = results [ 0 ] ; c = results [ 1 ] ; c = hPermOp ( c , - 2 , 0xcccc0000 ) ;
b [ offset ++ ] = (byte) ( iValue >>> 16 & 0xff ) ; MST[rv.CRCR3Mutator]MSP[] b [ offset ++ ] = (byte) ( iValue >>> 24 & 0xff ) ; }
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR2Mutator]MSP[]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.OBBN1Mutator]MSP[]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[MathMutator]MSP[]
s = s << 4 | s >>> 28 ; schedule [ j ++ ] = s ; } return schedule ; MST[ReturnValsMutator]MSP[] } private static int fourBytesToInt ( final byte b [] , int offset ) { int value = byteToUnsigned ( b [ offset ++ ] ) ;
permOp ( c , d , 8 , 0xff00ff , results ) ; c = results [ 0 ] ; d = results [ 1 ] ; permOp ( d , c , 1 , 0x55555555 , results ) ; MST[rv.UOI2Mutator]MSP[] d = results [ 0 ] ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR4Mutator]MSP[]
final int schedule [] = desSetKey ( key ) ; final int out [] = body ( schedule , eSwap0 , eSwap1 ) ; final byte b [] = new byte [ 9 ] ; intToFourBytes ( out [ 0 ] , b , 0 ) ; MST[InlineConstantMutator]MSP[]
permOp ( d , c , 4 , 0xf0f0f0f , results ) ; MST[rv.UOI4Mutator]MSP[] d = results [ 0 ] ; c = results [ 1 ] ; c = hPermOp ( c , - 2 , 0xcccc0000 ) ;
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; MST[rv.OBBN3Mutator]MSP[] value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; return value ; }
} else if ( ! salt . matches ( lr_2 + B64 . B64T_STRING + lr_3 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] throw new IllegalArgumentException ( lr_4 + salt ) ; } final StringBuilder buffer = new StringBuilder ( lr_5 ) ; final char charZero = salt . charAt ( 0 ) ;
for ( int i = 0 ; i < 16 ; i ++ ) { MST[rv.CRCR6Mutator]MSP[] if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; d = d >>> 2 | d << 26 ; } else {
results [ 0 ] = a ; results [ 1 ] = b ; MST[rv.UOI3Mutator]MSP[] }
intToFourBytes ( out [ 1 ] , b , 4 ) ; b [ 8 ] = 0 ; MST[rv.CRCR6Mutator]MSP[] int i = 2 ; int y = 0 ; int u = 128 ; for (; i < 13 ; i ++ ) { int j = 0 ;
left = t >>> 1 | t << 31 ; final int results [] = new int [ 2 ] ; permOp ( right , left , 1 , 0x55555555 , results ) ; MST[rv.UOI1Mutator]MSP[] right = results [ 0 ] ; left = results [ 1 ] ;
intToFourBytes ( out [ 1 ] , b , 4 ) ; MST[rv.CRCR4Mutator]MSP[] b [ 8 ] = 0 ; int i = 2 ; int y = 0 ; int u = 128 ; for (; i < 13 ; i ++ ) { int j = 0 ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.OBBN2Mutator]MSP[]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR2Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; MST[rv.CRCR5Mutator]MSP[] d = d >>> 2 | d << 26 ; } else {
private static void permOp ( int a , int b , final int n , final int m , final int results [] ) { final int t = ( a >>> n ^ b ) & m ; a ^= t << n ; b ^= t ; MST[rv.UOI4Mutator]MSP[]
b [ offset ++ ] = (byte) ( iValue >>> 16 & 0xff ) ; MST[rv.OBBN1Mutator]MSP[] b [ offset ++ ] = (byte) ( iValue >>> 24 & 0xff ) ; }
} else if ( ! salt . matches ( lr_2 + B64 . B64T_STRING + lr_3 ) ) { throw new IllegalArgumentException ( lr_4 + salt ) ; MST[NonVoidMethodCallMutator]MSP[] } final StringBuilder buffer = new StringBuilder ( lr_5 ) ; final char charZero = salt . charAt ( 0 ) ;
final int schedule [] = desSetKey ( key ) ; final int out [] = body ( schedule , eSwap0 , eSwap1 ) ; final byte b [] = new byte [ 9 ] ; intToFourBytes ( out [ 0 ] , b , 0 ) ; MST[rv.CRCR6Mutator]MSP[]
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; MST[rv.CRCR4Mutator]MSP[] d = d >>> 2 | d << 26 ; } else {
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR1Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
final int schedule [] = desSetKey ( key ) ; final int out [] = body ( schedule , eSwap0 , eSwap1 ) ; final byte b [] = new byte [ 9 ] ; MST[rv.CRCR4Mutator]MSP[] intToFourBytes ( out [ 0 ] , b , 0 ) ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.ABSMutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
for ( int i = 0 ; i < key . length && i < original . length ; i ++ ) { MST[rv.ROR4Mutator]MSP[] final int iChar = original [ i ] ; key [ i ] = (byte) ( iChar << 1 ) ; }
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; MST[rv.UOI3Mutator]MSP[] a = a ^ t ^ t >>> 16 - n ; return a ; }
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR1Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { MST[rv.ABSMutator]MSP[] c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) {
for ( int i = 0 ; i < key . length && i < original . length ; i ++ ) { final int iChar = original [ i ] ; MST[rv.ABSMutator]MSP[] key [ i ] = (byte) ( iChar << 1 ) ; }
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR4Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[InlineConstantMutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.UOI2Mutator]MSP[]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR3Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
left = t >>> 1 | t << 31 ; final int results [] = new int [ 2 ] ; permOp ( right , left , 1 , 0x55555555 , results ) ; right = results [ 0 ] ; MST[rv.UOI4Mutator]MSP[] left = results [ 1 ] ;
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; MST[rv.UOI2Mutator]MSP[] a = a ^ t ^ t >>> 16 - n ; return a ; }
c = c >>> 1 | c << 27 ; d = d >>> 1 | d << 27 ; } c &= 0xfffffff ; d &= 0xfffffff ; MST[rv.OBBN2Mutator]MSP[]
private static int dEncrypt ( int el , final int r , final int s , final int e0 , final int e1 , final int sArr [] ) { int v = r ^ r >>> 16 ; int u = v & e0 ; v &= e1 ; MST[rv.UOI1Mutator]MSP[]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[MathMutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.UOI4Mutator]MSP[]
private static void intToFourBytes ( final int iValue , final byte b [] , int offset ) { b [ offset ++ ] = (byte) ( iValue & 0xff ) ; b [ offset ++ ] = (byte) ( iValue >>> 8 & 0xff ) ; MST[rv.UOI2Mutator]MSP[]
b [ offset ++ ] = (byte) ( iValue >>> 16 & 0xff ) ; b [ offset ++ ] = (byte) ( iValue >>> 24 & 0xff ) ; MST[rv.CRCR2Mutator]MSP[] }
private static void permOp ( int a , int b , final int n , final int m , final int results [] ) { final int t = ( a >>> n ^ b ) & m ; a ^= t << n ; MST[rv.UOI2Mutator]MSP[] b ^= t ;
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; MST[rv.UOI2Mutator]MSP[] if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) {
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.OBBN1Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; MST[rv.UOI2Mutator]MSP[] t = t >>> 4 | t << 28 ;
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.CRCR2Mutator]MSP[] c &= 0xfffffff ; int j = 0 ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[InlineConstantMutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
permOp ( d , c , 4 , 0xf0f0f0f , results ) ; d = results [ 0 ] ; MST[rv.ABSMutator]MSP[] c = results [ 1 ] ; c = hPermOp ( c , - 2 , 0xcccc0000 ) ;
final char charOne = salt . charAt ( 1 ) ; MST[NonVoidMethodCallMutator]MSP[] buffer . setCharAt ( 0 , charZero ) ; buffer . setCharAt ( 1 , charOne ) ; final int eSwap0 = CON_SALT [ charZero ] ; final int eSwap1 = CON_SALT [ charOne ] << 4 ;
final byte key [] = new byte [ 8 ] ; for ( int i = 0 ; i < key . length ; i ++ ) { MST[rv.UOI4Mutator]MSP[] key [ i ] = 0 ; }
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; MST[rv.AOR2Mutator]MSP[] } t = left ; left = right ; right = t ; } t = right ; right = left >>> 1 | left << 31 ;
c = c >>> 1 | c << 27 ; MST[rv.OBBN3Mutator]MSP[] d = d >>> 1 | d << 27 ; } c &= 0xfffffff ; d &= 0xfffffff ;
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; a = a ^ t ^ t >>> 16 - n ; MST[MathMutator]MSP[] return a ; }
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.UOI1Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[InlineConstantMutator]MSP[]
for ( int i = 0 ; i < 32 ; i += 4 ) { left = dEncrypt ( left , right , i , eSwap0 , eSwap1 , schedule ) ; MST[rv.UOI2Mutator]MSP[]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR2Mutator]MSP[]
final int schedule [] = desSetKey ( key ) ; final int out [] = body ( schedule , eSwap0 , eSwap1 ) ; final byte b [] = new byte [ 9 ] ; intToFourBytes ( out [ 0 ] , b , 0 ) ; MST[rv.CRCR3Mutator]MSP[]
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; MST[rv.ABSMutator]MSP[] t = t >>> 4 | t << 28 ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.OBBN2Mutator]MSP[]
left = t >>> 1 | t << 31 ; MST[rv.UOI1Mutator]MSP[] final int results [] = new int [ 2 ] ; permOp ( right , left , 1 , 0x55555555 , results ) ; right = results [ 0 ] ; left = results [ 1 ] ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.UOI1Mutator]MSP[]
c = c >>> 1 | c << 27 ; d = d >>> 1 | d << 27 ; } c &= 0xfffffff ; MST[rv.OBBN3Mutator]MSP[] d &= 0xfffffff ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR6Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
d = hPermOp ( d , - 2 , 0xcccc0000 ) ; MST[rv.ABSMutator]MSP[] permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ; c = results [ 1 ] ;
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; a = a ^ t ^ t >>> 16 - n ; MST[rv.UOI1Mutator]MSP[] return a ; }
for ( int i = 0 ; i < 32 ; i += 4 ) { MST[rv.CRCR1Mutator]MSP[] left = dEncrypt ( left , right , i , eSwap0 , eSwap1 , schedule ) ;
intToFourBytes ( out [ 1 ] , b , 4 ) ; b [ 8 ] = 0 ; int i = 2 ; MST[InlineConstantMutator]MSP[] int y = 0 ; int u = 128 ; for (; i < 13 ; i ++ ) { int j = 0 ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.OBBN1Mutator]MSP[]
left = t >>> 1 | t << 31 ; final int results [] = new int [ 2 ] ; permOp ( right , left , 1 , 0x55555555 , results ) ; MST[rv.ABSMutator]MSP[] right = results [ 0 ] ; left = results [ 1 ] ;
final byte key [] = new byte [ 8 ] ; MST[rv.CRCR4Mutator]MSP[] for ( int i = 0 ; i < key . length ; i ++ ) { key [ i ] = 0 ; }
int c = 0 ; for (; j < 6 ; j ++ ) { MST[rv.CRCR1Mutator]MSP[] c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) {
permOp ( d , c , 4 , 0xf0f0f0f , results ) ; MST[rv.CRCR2Mutator]MSP[] d = results [ 0 ] ; c = results [ 1 ] ; c = hPermOp ( c , - 2 , 0xcccc0000 ) ;
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; d = d >>> 2 | d << 26 ; MST[rv.CRCR4Mutator]MSP[] } else {
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR1Mutator]MSP[]
final int numSaltChars = SALT_CHARS . length ; salt = lr_1 + SALT_CHARS [ randomGenerator . nextInt ( numSaltChars ) ] + MST[rv.UOI1Mutator]MSP[] SALT_CHARS [ randomGenerator . nextInt ( numSaltChars ) ] ;
final int schedule [] = desSetKey ( key ) ; final int out [] = body ( schedule , eSwap0 , eSwap1 ) ; MST[NonVoidMethodCallMutator]MSP[] final byte b [] = new byte [ 9 ] ; intToFourBytes ( out [ 0 ] , b , 0 ) ;
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; MST[MathMutator]MSP[] t = t >>> 4 | t << 28 ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.UOI3Mutator]MSP[]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR1Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; d = d >>> 2 | d << 26 ; MST[rv.UOI1Mutator]MSP[] } else {
right = results [ 0 ] ; left = results [ 1 ] ; final int out [] = new int [ 2 ] ; out [ 0 ] = left ; MST[InlineConstantMutator]MSP[] out [ 1 ] = right ; return out ; }
left = results [ 1 ] ; permOp ( left , right , 16 , 65535 , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 4 , 0xf0f0f0f , results ) ; MST[rv.ABSMutator]MSP[]
final int schedule [] = new int [ 32 ] ; MST[rv.CRCR4Mutator]MSP[] int c = fourBytesToInt ( key , 0 ) ; int d = fourBytesToInt ( key , 4 ) ; final int results [] = new int [ 2 ] ;
SPTRANS [ 4 ] [ u >>> 16 & 0x3f ] | SPTRANS [ 6 ] [ u >>> 24 & 0x3f ] ; return el ; MST[rv.ABSMutator]MSP[] } private static int [] desSetKey ( final byte key [] ) {
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR4Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
for ( int i = 0 ; i < key . length && i < original . length ; i ++ ) { final int iChar = original [ i ] ; key [ i ] = (byte) ( iChar << 1 ) ; MST[rv.CRCR2Mutator]MSP[] }
permOp ( d , c , 4 , 0xf0f0f0f , results ) ; d = results [ 0 ] ; c = results [ 1 ] ; c = hPermOp ( c , - 2 , 0xcccc0000 ) ; MST[rv.UOI2Mutator]MSP[]
final int schedule [] = desSetKey ( key ) ; final int out [] = body ( schedule , eSwap0 , eSwap1 ) ; MST[rv.UOI2Mutator]MSP[] final byte b [] = new byte [ 9 ] ; intToFourBytes ( out [ 0 ] , b , 0 ) ;
b [ offset ++ ] = (byte) ( iValue >>> 16 & 0xff ) ; MST[rv.CRCR5Mutator]MSP[] b [ offset ++ ] = (byte) ( iValue >>> 24 & 0xff ) ; }
private static int [] body ( final int schedule [] , final int eSwap0 , final int eSwap1 ) { int left = 0 ; MST[rv.CRCR5Mutator]MSP[] int right = 0 ; int t = 0 ; for ( int j = 0 ; j < 25 ; j ++ ) {
s = s << 4 | s >>> 28 ; MST[rv.UOI4Mutator]MSP[] schedule [ j ++ ] = s ; } return schedule ; } private static int fourBytesToInt ( final byte b [] , int offset ) { int value = byteToUnsigned ( b [ offset ++ ] ) ;
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; MST[rv.UOI3Mutator]MSP[] value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; return value ; }
d = hPermOp ( d , - 2 , 0xcccc0000 ) ; MST[ArgumentPropagationMutator]MSP[] permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ; c = results [ 1 ] ;
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { MST[rv.UOI3Mutator]MSP[] c = c >>> 2 | c << 26 ; d = d >>> 2 | d << 26 ; } else {
intToFourBytes ( out [ 1 ] , b , 4 ) ; b [ 8 ] = 0 ; MST[rv.CRCR3Mutator]MSP[] int i = 2 ; int y = 0 ; int u = 128 ; for (; i < 13 ; i ++ ) { int j = 0 ;
u = u ^ u << 16 ^ r ^ sArr [ s ] ; MST[rv.ABSMutator]MSP[] int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; t = t >>> 4 | t << 28 ;
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; } t = left ; left = right ; right = t ; } t = right ; MST[rv.UOI1Mutator]MSP[] right = left >>> 1 | left << 31 ;
final int schedule [] = new int [ 32 ] ; int c = fourBytesToInt ( key , 0 ) ; int d = fourBytesToInt ( key , 4 ) ; final int results [] = new int [ 2 ] ; MST[rv.CRCR4Mutator]MSP[]
permOp ( c , d , 8 , 0xff00ff , results ) ; c = results [ 0 ] ; d = results [ 1 ] ; permOp ( d , c , 1 , 0x55555555 , results ) ; MST[rv.ABSMutator]MSP[] d = results [ 0 ] ;
SKB [ 7 ] [ d >>> 21 & 0xf | d >>> 22 & 0x30 ] ; schedule [ j ++ ] = ( t << 16 | s & 0xffff ) ; MST[rv.UOI3Mutator]MSP[] s = s >>> 16 | t & 0xffff0000 ;
left = t >>> 1 | t << 31 ; final int results [] = new int [ 2 ] ; permOp ( right , left , 1 , 0x55555555 , results ) ; right = results [ 0 ] ; left = results [ 1 ] ; MST[rv.CRCR6Mutator]MSP[]
SKB [ 7 ] [ d >>> 21 & 0xf | d >>> 22 & 0x30 ] ; schedule [ j ++ ] = ( t << 16 | s & 0xffff ) ; s = s >>> 16 | t & 0xffff0000 ; MST[rv.OBBN3Mutator]MSP[]
permOp ( c , d , 8 , 0xff00ff , results ) ; MST[rv.UOI1Mutator]MSP[] c = results [ 0 ] ; d = results [ 1 ] ; permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ;
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; c &= 0xfffffff ; MST[rv.UOI2Mutator]MSP[] int j = 0 ;
SKB [ 7 ] [ d >>> 21 & 0xf | d >>> 22 & 0x30 ] ; schedule [ j ++ ] = ( t << 16 | s & 0xffff ) ; MST[rv.UOI1Mutator]MSP[] s = s >>> 16 | t & 0xffff0000 ;
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] c = c >>> 2 | c << 26 ; d = d >>> 2 | d << 26 ; } else {
b [ offset ++ ] = (byte) ( iValue >>> 16 & 0xff ) ; b [ offset ++ ] = (byte) ( iValue >>> 24 & 0xff ) ; MST[rv.UOI2Mutator]MSP[] }
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[InlineConstantMutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[InlineConstantMutator]MSP[]
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; MST[rv.CRCR1Mutator]MSP[] d = d >>> 2 | d << 26 ; } else {
permOp ( c , d , 8 , 0xff00ff , results ) ; c = results [ 0 ] ; d = results [ 1 ] ; permOp ( d , c , 1 , 0x55555555 , results ) ; MST[rv.CRCR4Mutator]MSP[] d = results [ 0 ] ;
permOp ( d , c , 4 , 0xf0f0f0f , results ) ; d = results [ 0 ] ; c = results [ 1 ] ; MST[rv.CRCR5Mutator]MSP[] c = hPermOp ( c , - 2 , 0xcccc0000 ) ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.UOI4Mutator]MSP[]
left = t >>> 1 | t << 31 ; final int results [] = new int [ 2 ] ; MST[rv.CRCR5Mutator]MSP[] permOp ( right , left , 1 , 0x55555555 , results ) ; right = results [ 0 ] ; left = results [ 1 ] ;
permOp ( c , d , 8 , 0xff00ff , results ) ; MST[VoidMethodCallMutator]MSP[] c = results [ 0 ] ; d = results [ 1 ] ; permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.UOI1Mutator]MSP[]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.OBBN2Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
y ++ ; u = 128 ; } buffer . setCharAt ( i , ( char ) COV2CHAR [ c ] ) ; MST[rv.UOI4Mutator]MSP[] } } return buffer . toString () ; } public static String crypt ( final String original ) {
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR6Mutator]MSP[]
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) { MST[rv.UOI1Mutator]MSP[]
left = t >>> 1 | t << 31 ; MST[rv.CRCR3Mutator]MSP[] final int results [] = new int [ 2 ] ; permOp ( right , left , 1 , 0x55555555 , results ) ; right = results [ 0 ] ; left = results [ 1 ] ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR5Mutator]MSP[]
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) { MST[rv.ROR2Mutator]MSP[]
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[MathMutator]MSP[]
d = hPermOp ( d , - 2 , 0xcccc0000 ) ; permOp ( d , c , 1 , 0x55555555 , results ) ; MST[InlineConstantMutator]MSP[] d = results [ 0 ] ; c = results [ 1 ] ;
permOp ( c , d , 8 , 0xff00ff , results ) ; c = results [ 0 ] ; MST[rv.CRCR1Mutator]MSP[] d = results [ 1 ] ; permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ;
SKB [ 7 ] [ d >>> 21 & 0xf | d >>> 22 & 0x30 ] ; schedule [ j ++ ] = ( t << 16 | s & 0xffff ) ; MST[rv.UOI4Mutator]MSP[] s = s >>> 16 | t & 0xffff0000 ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.UOI3Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
private static int [] body ( final int schedule [] , final int eSwap0 , final int eSwap1 ) { int left = 0 ; int right = 0 ; int t = 0 ; for ( int j = 0 ; j < 25 ; j ++ ) { MST[rv.CRCR5Mutator]MSP[]
permOp ( left , right , 8 , 0xff00ff , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 2 , 0x33333333 , results ) ; MST[InlineConstantMutator]MSP[] right = results [ 0 ] ;
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; MST[rv.UOI2Mutator]MSP[] return value ; }
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.OBBN3Mutator]MSP[]
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; MST[rv.UOI4Mutator]MSP[] a = a ^ t ^ t >>> 16 - n ; return a ; }
int c = 0 ; MST[rv.CRCR6Mutator]MSP[] for (; j < 6 ; j ++ ) { c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) {
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; MST[MathMutator]MSP[] } t = left ; left = right ; right = t ; } t = right ; right = left >>> 1 | left << 31 ;
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; } t = left ; MST[rv.UOI1Mutator]MSP[] left = right ; right = t ; } t = right ; right = left >>> 1 | left << 31 ;
intToFourBytes ( out [ 1 ] , b , 4 ) ; MST[rv.UOI3Mutator]MSP[] b [ 8 ] = 0 ; int i = 2 ; int y = 0 ; int u = 128 ; for (; i < 13 ; i ++ ) { int j = 0 ;
intToFourBytes ( out [ 1 ] , b , 4 ) ; b [ 8 ] = 0 ; int i = 2 ; int y = 0 ; int u = 128 ; for (; i < 13 ; i ++ ) { MST[rv.CRCR2Mutator]MSP[] int j = 0 ;
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; MST[rv.UOI4Mutator]MSP[] t = t >>> 4 | t << 28 ;
permOp ( c , d , 8 , 0xff00ff , results ) ; c = results [ 0 ] ; d = results [ 1 ] ; permOp ( d , c , 1 , 0x55555555 , results ) ; MST[rv.UOI3Mutator]MSP[] d = results [ 0 ] ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.OBBN3Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
for ( int i = 0 ; i < 32 ; i += 4 ) { left = dEncrypt ( left , right , i , eSwap0 , eSwap1 , schedule ) ; MST[ArgumentPropagationMutator]MSP[]
private static int [] body ( final int schedule [] , final int eSwap0 , final int eSwap1 ) { int left = 0 ; int right = 0 ; int t = 0 ; for ( int j = 0 ; j < 25 ; j ++ ) { MST[rv.UOI3Mutator]MSP[]
private static int byteToUnsigned ( final byte b ) { final int value = b ; return value < 0 ? value + 256 : value ; MST[rv.AOD2Mutator]MSP[] }
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR3Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
private static void intToFourBytes ( final int iValue , final byte b [] , int offset ) { b [ offset ++ ] = (byte) ( iValue & 0xff ) ; MST[rv.OBBN3Mutator]MSP[] b [ offset ++ ] = (byte) ( iValue >>> 8 & 0xff ) ;
c = c >>> 1 | c << 27 ; d = d >>> 1 | d << 27 ; } c &= 0xfffffff ; d &= 0xfffffff ; MST[rv.UOI4Mutator]MSP[]
for ( int i = 0 ; i < 32 ; i += 4 ) { MST[IncrementsMutator]MSP[] left = dEncrypt ( left , right , i , eSwap0 , eSwap1 , schedule ) ;
c = c >>> 1 | c << 27 ; d = d >>> 1 | d << 27 ; } c &= 0xfffffff ; MST[rv.CRCR4Mutator]MSP[] d &= 0xfffffff ;
SKB [ 7 ] [ d >>> 21 & 0xf | d >>> 22 & 0x30 ] ; schedule [ j ++ ] = ( t << 16 | s & 0xffff ) ; s = s >>> 16 | t & 0xffff0000 ; MST[MathMutator]MSP[]
permOp ( c , d , 8 , 0xff00ff , results ) ; MST[rv.UOI2Mutator]MSP[] c = results [ 0 ] ; d = results [ 1 ] ; permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ;
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; t = t >>> 4 | t << 28 ; MST[rv.UOI1Mutator]MSP[]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[MathMutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.ABSMutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
for ( int i = 0 ; i < key . length && i < original . length ; i ++ ) { MST[IncrementsMutator]MSP[] final int iChar = original [ i ] ; key [ i ] = (byte) ( iChar << 1 ) ; }
left = results [ 1 ] ; permOp ( left , right , 16 , 65535 , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 4 , 0xf0f0f0f , results ) ; MST[rv.CRCR6Mutator]MSP[]
s = s << 4 | s >>> 28 ; schedule [ j ++ ] = s ; } return schedule ; } private static int fourBytesToInt ( final byte b [] , int offset ) { int value = byteToUnsigned ( b [ offset ++ ] ) ; MST[rv.UOI3Mutator]MSP[]
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; MST[InlineConstantMutator]MSP[] } u >>>= 1 ; if ( u == 0 ) {
SKB [ 7 ] [ d >>> 21 & 0xf | d >>> 22 & 0x30 ] ; schedule [ j ++ ] = ( t << 16 | s & 0xffff ) ; s = s >>> 16 | t & 0xffff0000 ; MST[InlineConstantMutator]MSP[]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR1Mutator]MSP[]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[MathMutator]MSP[]
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; return value ; MST[rv.UOI1Mutator]MSP[] }
left = results [ 1 ] ; permOp ( left , right , 16 , 65535 , results ) ; MST[rv.CRCR5Mutator]MSP[] left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 4 , 0xf0f0f0f , results ) ;
permOp ( d , c , 4 , 0xf0f0f0f , results ) ; d = results [ 0 ] ; c = results [ 1 ] ; c = hPermOp ( c , - 2 , 0xcccc0000 ) ; MST[NonVoidMethodCallMutator]MSP[]
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; a = a ^ t ^ t >>> 16 - n ; MST[rv.UOI2Mutator]MSP[] return a ; }
c = c >>> 1 | c << 27 ; d = d >>> 1 | d << 27 ; MST[rv.OBBN2Mutator]MSP[] } c &= 0xfffffff ; d &= 0xfffffff ;
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; MST[rv.CRCR4Mutator]MSP[] if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) {
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { MST[rv.ROR2Mutator]MSP[] c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) {
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.UOI2Mutator]MSP[]
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; d = d >>> 2 | d << 26 ; MST[rv.CRCR3Mutator]MSP[] } else {
d = hPermOp ( d , - 2 , 0xcccc0000 ) ; MST[rv.CRCR5Mutator]MSP[] permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ; c = results [ 1 ] ;
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; MST[rv.UOI1Mutator]MSP[] } u >>>= 1 ; if ( u == 0 ) {
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; MST[rv.ABSMutator]MSP[] value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; return value ; }
results [ 0 ] = a ; results [ 1 ] = b ; MST[rv.CRCR3Mutator]MSP[] }
permOp ( left , right , 8 , 0xff00ff , results ) ; left = results [ 0 ] ; MST[rv.ABSMutator]MSP[] right = results [ 1 ] ; permOp ( right , left , 2 , 0x33333333 , results ) ; right = results [ 0 ] ;
final char charOne = salt . charAt ( 1 ) ; buffer . setCharAt ( 0 , charZero ) ; buffer . setCharAt ( 1 , charOne ) ; final int eSwap0 = CON_SALT [ charZero ] ; final int eSwap1 = CON_SALT [ charOne ] << 4 ; MST[rv.CRCR1Mutator]MSP[]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR5Mutator]MSP[]
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.CRCR4Mutator]MSP[] c &= 0xfffffff ; int j = 0 ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR2Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
final int schedule [] = new int [ 32 ] ; int c = fourBytesToInt ( key , 0 ) ; MST[rv.CRCR6Mutator]MSP[] int d = fourBytesToInt ( key , 4 ) ; final int results [] = new int [ 2 ] ;
private static int dEncrypt ( int el , final int r , final int s , final int e0 , final int e1 , final int sArr [] ) { int v = r ^ r >>> 16 ; int u = v & e0 ; MST[rv.UOI3Mutator]MSP[] v &= e1 ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.UOI1Mutator]MSP[]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.OBBN2Mutator]MSP[]
permOp ( left , right , 8 , 0xff00ff , results ) ; MST[rv.CRCR3Mutator]MSP[] left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 2 , 0x33333333 , results ) ; right = results [ 0 ] ;
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; MST[rv.UOI3Mutator]MSP[] t = t >>> 4 | t << 28 ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.UOI4Mutator]MSP[]
permOp ( d , c , 4 , 0xf0f0f0f , results ) ; d = results [ 0 ] ; MST[rv.UOI3Mutator]MSP[] c = results [ 1 ] ; c = hPermOp ( c , - 2 , 0xcccc0000 ) ;
private static void intToFourBytes ( final int iValue , final byte b [] , int offset ) { b [ offset ++ ] = (byte) ( iValue & 0xff ) ; b [ offset ++ ] = (byte) ( iValue >>> 8 & 0xff ) ; MST[rv.CRCR1Mutator]MSP[]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[MathMutator]MSP[]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR5Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
int c = 0 ; for (; j < 6 ; j ++ ) { MST[rv.ROR3Mutator]MSP[] c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) {
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR4Mutator]MSP[]
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.OBBN1Mutator]MSP[]
d = hPermOp ( d , - 2 , 0xcccc0000 ) ; permOp ( d , c , 1 , 0x55555555 , results ) ; MST[rv.CRCR2Mutator]MSP[] d = results [ 0 ] ; c = results [ 1 ] ;
permOp ( c , d , 8 , 0xff00ff , results ) ; MST[rv.CRCR3Mutator]MSP[] c = results [ 0 ] ; d = results [ 1 ] ; permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ;
results [ 0 ] = a ; MST[rv.CRCR1Mutator]MSP[] results [ 1 ] = b ; }
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.OBBN3Mutator]MSP[]
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.CRCR1Mutator]MSP[] c &= 0xfffffff ; int j = 0 ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[InlineConstantMutator]MSP[]
permOp ( left , right , 8 , 0xff00ff , results ) ; left = results [ 0 ] ; MST[rv.CRCR5Mutator]MSP[] right = results [ 1 ] ; permOp ( right , left , 2 , 0x33333333 , results ) ; right = results [ 0 ] ;
} else if ( ! salt . matches ( lr_2 + B64 . B64T_STRING + lr_3 ) ) { MST[NonVoidMethodCallMutator]MSP[] throw new IllegalArgumentException ( lr_4 + salt ) ; } final StringBuilder buffer = new StringBuilder ( lr_5 ) ; final char charZero = salt . charAt ( 0 ) ;
for ( int i = 0 ; i < key . length && i < original . length ; i ++ ) { final int iChar = original [ i ] ; key [ i ] = (byte) ( iChar << 1 ) ; MST[rv.UOI1Mutator]MSP[] }
d = hPermOp ( d , - 2 , 0xcccc0000 ) ; permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ; MST[rv.ABSMutator]MSP[] c = results [ 1 ] ;
u = u ^ u << 16 ^ r ^ sArr [ s ] ; MST[rv.UOI4Mutator]MSP[] int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; t = t >>> 4 | t << 28 ;
c = c >>> 1 | c << 27 ; MST[MathMutator]MSP[] d = d >>> 1 | d << 27 ; } c &= 0xfffffff ; d &= 0xfffffff ;
private static void intToFourBytes ( final int iValue , final byte b [] , int offset ) { b [ offset ++ ] = (byte) ( iValue & 0xff ) ; b [ offset ++ ] = (byte) ( iValue >>> 8 & 0xff ) ; MST[rv.CRCR6Mutator]MSP[]
permOp ( d , c , 4 , 0xf0f0f0f , results ) ; d = results [ 0 ] ; c = results [ 1 ] ; c = hPermOp ( c , - 2 , 0xcccc0000 ) ; MST[rv.CRCR3Mutator]MSP[]
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; MST[rv.CRCR3Mutator]MSP[] } u >>>= 1 ; if ( u == 0 ) {
intToFourBytes ( out [ 1 ] , b , 4 ) ; b [ 8 ] = 0 ; int i = 2 ; int y = 0 ; int u = 128 ; for (; i < 13 ; i ++ ) { MST[rv.ROR4Mutator]MSP[] int j = 0 ;
for ( int i = 0 ; i < 32 ; i += 4 ) { left = dEncrypt ( left , right , i , eSwap0 , eSwap1 , schedule ) ; MST[rv.UOI3Mutator]MSP[]
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; MST[rv.CRCR1Mutator]MSP[] value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; return value ; }
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.OBBN3Mutator]MSP[]
for ( int i = 0 ; i < 32 ; i += 4 ) { MST[rv.ROR3Mutator]MSP[] left = dEncrypt ( left , right , i , eSwap0 , eSwap1 , schedule ) ;
u = u ^ u << 16 ^ r ^ sArr [ s ] ; MST[MathMutator]MSP[] int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; t = t >>> 4 | t << 28 ;
c = c >>> 1 | c << 27 ; d = d >>> 1 | d << 27 ; MST[rv.UOI4Mutator]MSP[] } c &= 0xfffffff ; d &= 0xfffffff ;
for ( int i = 0 ; i < key . length && i < original . length ; i ++ ) { MST[rv.UOI1Mutator]MSP[] final int iChar = original [ i ] ; key [ i ] = (byte) ( iChar << 1 ) ; }
c = c >>> 1 | c << 27 ; MST[InlineConstantMutator]MSP[] d = d >>> 1 | d << 27 ; } c &= 0xfffffff ; d &= 0xfffffff ;
private static void permOp ( int a , int b , final int n , final int m , final int results [] ) { final int t = ( a >>> n ^ b ) & m ; a ^= t << n ; b ^= t ; MST[rv.UOI3Mutator]MSP[]
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; c &= 0xfffffff ; MST[rv.OBBN3Mutator]MSP[] int j = 0 ;
right = results [ 0 ] ; MST[InlineConstantMutator]MSP[] left = results [ 1 ] ; final int out [] = new int [ 2 ] ; out [ 0 ] = left ; out [ 1 ] = right ; return out ; }
for ( int i = 0 ; i < key . length && i < original . length ; i ++ ) { MST[rv.ROR4Mutator]MSP[] final int iChar = original [ i ] ; key [ i ] = (byte) ( iChar << 1 ) ; }
u = u ^ u << 16 ^ r ^ sArr [ s ] ; MST[InlineConstantMutator]MSP[] int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; t = t >>> 4 | t << 28 ;
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; t = t >>> 4 | t << 28 ; MST[rv.CRCR3Mutator]MSP[]
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.OBBN1Mutator]MSP[] c &= 0xfffffff ; int j = 0 ;
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; MST[rv.CRCR4Mutator]MSP[] a = a ^ t ^ t >>> 16 - n ; return a ; }
u = u ^ u << 16 ^ r ^ sArr [ s ] ; MST[rv.UOI3Mutator]MSP[] int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; t = t >>> 4 | t << 28 ;
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; t = t >>> 4 | t << 28 ; MST[rv.CRCR2Mutator]MSP[]
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; MST[rv.CRCR5Mutator]MSP[] return value ; }
s = s << 4 | s >>> 28 ; schedule [ j ++ ] = s ; MST[rv.UOI2Mutator]MSP[] } return schedule ; } private static int fourBytesToInt ( final byte b [] , int offset ) { int value = byteToUnsigned ( b [ offset ++ ] ) ;
permOp ( left , right , 8 , 0xff00ff , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 2 , 0x33333333 , results ) ; MST[rv.CRCR4Mutator]MSP[] right = results [ 0 ] ;
permOp ( left , right , 8 , 0xff00ff , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 2 , 0x33333333 , results ) ; right = results [ 0 ] ; MST[rv.CRCR6Mutator]MSP[]
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.UOI4Mutator]MSP[] c &= 0xfffffff ; int j = 0 ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR6Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
final char charOne = salt . charAt ( 1 ) ; buffer . setCharAt ( 0 , charZero ) ; buffer . setCharAt ( 1 , charOne ) ; MST[rv.CRCR2Mutator]MSP[] final int eSwap0 = CON_SALT [ charZero ] ; final int eSwap1 = CON_SALT [ charOne ] << 4 ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR2Mutator]MSP[]
private static void intToFourBytes ( final int iValue , final byte b [] , int offset ) { b [ offset ++ ] = (byte) ( iValue & 0xff ) ; b [ offset ++ ] = (byte) ( iValue >>> 8 & 0xff ) ; MST[rv.UOI4Mutator]MSP[]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.ABSMutator]MSP[]
final int schedule [] = new int [ 32 ] ; int c = fourBytesToInt ( key , 0 ) ; int d = fourBytesToInt ( key , 4 ) ; MST[InlineConstantMutator]MSP[] final int results [] = new int [ 2 ] ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR3Mutator]MSP[]
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.OBBN1Mutator]MSP[]
final int schedule [] = new int [ 32 ] ; MST[rv.CRCR1Mutator]MSP[] int c = fourBytesToInt ( key , 0 ) ; int d = fourBytesToInt ( key , 4 ) ; final int results [] = new int [ 2 ] ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR1Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
final char charOne = salt . charAt ( 1 ) ; buffer . setCharAt ( 0 , charZero ) ; buffer . setCharAt ( 1 , charOne ) ; final int eSwap0 = CON_SALT [ charZero ] ; MST[rv.ABSMutator]MSP[] final int eSwap1 = CON_SALT [ charOne ] << 4 ;
s = s << 4 | s >>> 28 ; MST[InlineConstantMutator]MSP[] schedule [ j ++ ] = s ; } return schedule ; } private static int fourBytesToInt ( final byte b [] , int offset ) { int value = byteToUnsigned ( b [ offset ++ ] ) ;
final int schedule [] = desSetKey ( key ) ; final int out [] = body ( schedule , eSwap0 , eSwap1 ) ; MST[rv.UOI1Mutator]MSP[] final byte b [] = new byte [ 9 ] ; intToFourBytes ( out [ 0 ] , b , 0 ) ;
final byte key [] = new byte [ 8 ] ; for ( int i = 0 ; i < key . length ; i ++ ) { MST[NegateConditionalsMutator]MSP[] key [ i ] = 0 ; }
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR5Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
s = s << 4 | s >>> 28 ; schedule [ j ++ ] = s ; MST[rv.UOI4Mutator]MSP[] } return schedule ; } private static int fourBytesToInt ( final byte b [] , int offset ) { int value = byteToUnsigned ( b [ offset ++ ] ) ;
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; MST[rv.AOR1Mutator]MSP[] } t = left ; left = right ; right = t ; } t = right ; right = left >>> 1 | left << 31 ;
private static int dEncrypt ( int el , final int r , final int s , final int e0 , final int e1 , final int sArr [] ) { int v = r ^ r >>> 16 ; MST[MathMutator]MSP[] int u = v & e0 ; v &= e1 ;
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; d = d >>> 2 | d << 26 ; MST[rv.CRCR1Mutator]MSP[] } else {
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.OBBN1Mutator]MSP[] c &= 0xfffffff ; int j = 0 ;
c = c >>> 1 | c << 27 ; d = d >>> 1 | d << 27 ; } c &= 0xfffffff ; MST[rv.UOI4Mutator]MSP[] d &= 0xfffffff ;
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; a = a ^ t ^ t >>> 16 - n ; MST[rv.AOR4Mutator]MSP[] return a ; }
left = results [ 1 ] ; permOp ( left , right , 16 , 65535 , results ) ; MST[rv.ABSMutator]MSP[] left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 4 , 0xf0f0f0f , results ) ;
d = hPermOp ( d , - 2 , 0xcccc0000 ) ; permOp ( d , c , 1 , 0x55555555 , results ) ; MST[VoidMethodCallMutator]MSP[] d = results [ 0 ] ; c = results [ 1 ] ;
c = c >>> 1 | c << 27 ; d = d >>> 1 | d << 27 ; } c &= 0xfffffff ; d &= 0xfffffff ; MST[rv.CRCR6Mutator]MSP[]
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.UOI1Mutator]MSP[] c &= 0xfffffff ; int j = 0 ;
intToFourBytes ( out [ 1 ] , b , 4 ) ; MST[rv.CRCR6Mutator]MSP[] b [ 8 ] = 0 ; int i = 2 ; int y = 0 ; int u = 128 ; for (; i < 13 ; i ++ ) { int j = 0 ;
permOp ( d , c , 4 , 0xf0f0f0f , results ) ; d = results [ 0 ] ; c = results [ 1 ] ; MST[rv.CRCR2Mutator]MSP[] c = hPermOp ( c , - 2 , 0xcccc0000 ) ;
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; d = d >>> 2 | d << 26 ; MST[rv.OBBN3Mutator]MSP[] } else {
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; MST[rv.UOI4Mutator]MSP[] t = t >>> 4 | t << 28 ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[MathMutator]MSP[]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.OBBN2Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
private static void intToFourBytes ( final int iValue , final byte b [] , int offset ) { b [ offset ++ ] = (byte) ( iValue & 0xff ) ; b [ offset ++ ] = (byte) ( iValue >>> 8 & 0xff ) ; MST[rv.UOI1Mutator]MSP[]
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; MST[rv.ABSMutator]MSP[] return value ; }
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; a = a ^ t ^ t >>> 16 - n ; MST[rv.UOI2Mutator]MSP[] return a ; }
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR2Mutator]MSP[]
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; MST[rv.CRCR5Mutator]MSP[] t = t >>> 4 | t << 28 ;
left = t >>> 1 | t << 31 ; final int results [] = new int [ 2 ] ; permOp ( right , left , 1 , 0x55555555 , results ) ; MST[rv.CRCR4Mutator]MSP[] right = results [ 0 ] ; left = results [ 1 ] ;
permOp ( left , right , 8 , 0xff00ff , results ) ; left = results [ 0 ] ; MST[InlineConstantMutator]MSP[] right = results [ 1 ] ; permOp ( right , left , 2 , 0x33333333 , results ) ; right = results [ 0 ] ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR3Mutator]MSP[]
private static void intToFourBytes ( final int iValue , final byte b [] , int offset ) { b [ offset ++ ] = (byte) ( iValue & 0xff ) ; MST[rv.ABSMutator]MSP[] b [ offset ++ ] = (byte) ( iValue >>> 8 & 0xff ) ;
left = results [ 1 ] ; permOp ( left , right , 16 , 65535 , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 4 , 0xf0f0f0f , results ) ; MST[VoidMethodCallMutator]MSP[]
private static int dEncrypt ( int el , final int r , final int s , final int e0 , final int e1 , final int sArr [] ) { int v = r ^ r >>> 16 ; int u = v & e0 ; v &= e1 ; MST[rv.ABSMutator]MSP[]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.OBBN2Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
left = results [ 1 ] ; permOp ( left , right , 16 , 65535 , results ) ; left = results [ 0 ] ; MST[rv.UOI4Mutator]MSP[] right = results [ 1 ] ; permOp ( right , left , 4 , 0xf0f0f0f , results ) ;
final int schedule [] = new int [ 32 ] ; int c = fourBytesToInt ( key , 0 ) ; int d = fourBytesToInt ( key , 4 ) ; final int results [] = new int [ 2 ] ; MST[rv.CRCR1Mutator]MSP[]
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; } t = left ; left = right ; right = t ; } t = right ; right = left >>> 1 | left << 31 ; MST[rv.CRCR5Mutator]MSP[]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.UOI1Mutator]MSP[]
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR6Mutator]MSP[]
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.CRCR6Mutator]MSP[] c &= 0xfffffff ; int j = 0 ;
left = t >>> 1 | t << 31 ; final int results [] = new int [ 2 ] ; permOp ( right , left , 1 , 0x55555555 , results ) ; right = results [ 0 ] ; left = results [ 1 ] ; MST[rv.UOI3Mutator]MSP[]
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; } t = left ; left = right ; right = t ; } t = right ; right = left >>> 1 | left << 31 ; MST[rv.CRCR6Mutator]MSP[]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[InlineConstantMutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
s = s << 4 | s >>> 28 ; MST[rv.ABSMutator]MSP[] schedule [ j ++ ] = s ; } return schedule ; } private static int fourBytesToInt ( final byte b [] , int offset ) { int value = byteToUnsigned ( b [ offset ++ ] ) ;
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; MST[rv.UOI2Mutator]MSP[] d = d >>> 2 | d << 26 ; } else {
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.OBBN1Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
intToFourBytes ( out [ 1 ] , b , 4 ) ; b [ 8 ] = 0 ; int i = 2 ; int y = 0 ; int u = 128 ; for (; i < 13 ; i ++ ) { MST[rv.ROR2Mutator]MSP[] int j = 0 ;
permOp ( left , right , 8 , 0xff00ff , results ) ; MST[rv.CRCR5Mutator]MSP[] left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 2 , 0x33333333 , results ) ; right = results [ 0 ] ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR2Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
intToFourBytes ( out [ 1 ] , b , 4 ) ; b [ 8 ] = 0 ; int i = 2 ; int y = 0 ; int u = 128 ; MST[rv.CRCR3Mutator]MSP[] for (; i < 13 ; i ++ ) { int j = 0 ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR1Mutator]MSP[]
permOp ( c , d , 8 , 0xff00ff , results ) ; c = results [ 0 ] ; d = results [ 1 ] ; permOp ( d , c , 1 , 0x55555555 , results ) ; MST[rv.UOI1Mutator]MSP[] d = results [ 0 ] ;
private static void intToFourBytes ( final int iValue , final byte b [] , int offset ) { b [ offset ++ ] = (byte) ( iValue & 0xff ) ; b [ offset ++ ] = (byte) ( iValue >>> 8 & 0xff ) ; MST[rv.CRCR1Mutator]MSP[]
permOp ( left , right , 8 , 0xff00ff , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 2 , 0x33333333 , results ) ; MST[rv.UOI1Mutator]MSP[] right = results [ 0 ] ;
left = results [ 1 ] ; permOp ( left , right , 16 , 65535 , results ) ; MST[InlineConstantMutator]MSP[] left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 4 , 0xf0f0f0f , results ) ;
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { MST[rv.UOI3Mutator]MSP[] c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) {
results [ 0 ] = a ; MST[rv.CRCR3Mutator]MSP[] results [ 1 ] = b ; }
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; MST[rv.UOI4Mutator]MSP[] } t = left ; left = right ; right = t ; } t = right ; right = left >>> 1 | left << 31 ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR3Mutator]MSP[]
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; MST[rv.UOI4Mutator]MSP[] value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; return value ; }
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[InlineConstantMutator]MSP[]
for ( int i = 0 ; i < key . length && i < original . length ; i ++ ) { MST[rv.CRCR3Mutator]MSP[] final int iChar = original [ i ] ; key [ i ] = (byte) ( iChar << 1 ) ; }
int c = 0 ; for (; j < 6 ; j ++ ) { MST[rv.UOI4Mutator]MSP[] c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) {
int c = 0 ; for (; j < 6 ; j ++ ) { MST[rv.ROR1Mutator]MSP[] c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) {
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR6Mutator]MSP[]
permOp ( left , right , 8 , 0xff00ff , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 2 , 0x33333333 , results ) ; right = results [ 0 ] ; MST[rv.UOI3Mutator]MSP[]
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) {
for ( int i = 0 ; i < 16 ; i ++ ) { MST[ConditionalsBoundaryMutator]MSP[] if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; d = d >>> 2 | d << 26 ; } else {
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.OBBN1Mutator]MSP[]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[MathMutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR6Mutator]MSP[]
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; MST[rv.UOI1Mutator]MSP[] } t = left ; left = right ; right = t ; } t = right ; right = left >>> 1 | left << 31 ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR5Mutator]MSP[]
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.CRCR6Mutator]MSP[] c &= 0xfffffff ; int j = 0 ;
c = results [ 1 ] ; MST[rv.CRCR4Mutator]MSP[] d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; c &= 0xfffffff ; int j = 0 ;
int c = 0 ; for (; j < 6 ; j ++ ) { MST[rv.CRCR4Mutator]MSP[] c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) {
for ( int i = 0 ; i < key . length && i < original . length ; i ++ ) { final int iChar = original [ i ] ; MST[rv.UOI3Mutator]MSP[] key [ i ] = (byte) ( iChar << 1 ) ; }
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
permOp ( left , right , 8 , 0xff00ff , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; MST[rv.UOI4Mutator]MSP[] permOp ( right , left , 2 , 0x33333333 , results ) ; right = results [ 0 ] ;
b [ offset ++ ] = (byte) ( iValue >>> 16 & 0xff ) ; b [ offset ++ ] = (byte) ( iValue >>> 24 & 0xff ) ; MST[rv.CRCR4Mutator]MSP[] }
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR2Mutator]MSP[]
permOp ( left , right , 8 , 0xff00ff , results ) ; left = results [ 0 ] ; MST[rv.UOI2Mutator]MSP[] right = results [ 1 ] ; permOp ( right , left , 2 , 0x33333333 , results ) ; right = results [ 0 ] ;
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; d = d >>> 2 | d << 26 ; MST[rv.UOI1Mutator]MSP[] } else {
for ( int i = 0 ; i < key . length && i < original . length ; i ++ ) { MST[rv.ROR2Mutator]MSP[] final int iChar = original [ i ] ; key [ i ] = (byte) ( iChar << 1 ) ; }
c = c >>> 1 | c << 27 ; d = d >>> 1 | d << 27 ; MST[rv.CRCR6Mutator]MSP[] } c &= 0xfffffff ; d &= 0xfffffff ;
for ( int i = 0 ; i < key . length && i < original . length ; i ++ ) { final int iChar = original [ i ] ; key [ i ] = (byte) ( iChar << 1 ) ; MST[rv.CRCR5Mutator]MSP[] }
permOp ( left , right , 8 , 0xff00ff , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 2 , 0x33333333 , results ) ; MST[rv.CRCR6Mutator]MSP[] right = results [ 0 ] ;
b [ offset ++ ] = (byte) ( iValue >>> 16 & 0xff ) ; b [ offset ++ ] = (byte) ( iValue >>> 24 & 0xff ) ; MST[experimental.RemoveIncrementsMutator]MSP[] }
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; } t = left ; left = right ; right = t ; MST[rv.ABSMutator]MSP[] } t = right ; right = left >>> 1 | left << 31 ;
c = c >>> 1 | c << 27 ; d = d >>> 1 | d << 27 ; MST[InlineConstantMutator]MSP[] } c &= 0xfffffff ; d &= 0xfffffff ;
private static int dEncrypt ( int el , final int r , final int s , final int e0 , final int e1 , final int sArr [] ) { int v = r ^ r >>> 16 ; int u = v & e0 ; MST[rv.UOI1Mutator]MSP[] v &= e1 ;
right = results [ 0 ] ; left = results [ 1 ] ; final int out [] = new int [ 2 ] ; out [ 0 ] = left ; MST[rv.ABSMutator]MSP[] out [ 1 ] = right ; return out ; }
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[MathMutator]MSP[]
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { MST[rv.UOI1Mutator]MSP[] c = c >>> 2 | c << 26 ; d = d >>> 2 | d << 26 ; } else {
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { MST[rv.UOI4Mutator]MSP[] c = c >>> 2 | c << 26 ; d = d >>> 2 | d << 26 ; } else {
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; MST[rv.OBBN1Mutator]MSP[] d = d >>> 2 | d << 26 ; } else {
left = t >>> 1 | t << 31 ; final int results [] = new int [ 2 ] ; MST[InlineConstantMutator]MSP[] permOp ( right , left , 1 , 0x55555555 , results ) ; right = results [ 0 ] ; left = results [ 1 ] ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.UOI2Mutator]MSP[]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR3Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
private static int [] body ( final int schedule [] , final int eSwap0 , final int eSwap1 ) { int left = 0 ; int right = 0 ; int t = 0 ; for ( int j = 0 ; j < 25 ; j ++ ) { MST[InlineConstantMutator]MSP[]
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; t = t >>> 4 | t << 28 ; MST[rv.UOI3Mutator]MSP[]
permOp ( d , c , 4 , 0xf0f0f0f , results ) ; MST[rv.UOI2Mutator]MSP[] d = results [ 0 ] ; c = results [ 1 ] ; c = hPermOp ( c , - 2 , 0xcccc0000 ) ;
d = hPermOp ( d , - 2 , 0xcccc0000 ) ; MST[rv.CRCR1Mutator]MSP[] permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ; c = results [ 1 ] ;
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; MST[rv.OBBN2Mutator]MSP[] } u >>>= 1 ; if ( u == 0 ) {
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.OBBN3Mutator]MSP[] c &= 0xfffffff ; int j = 0 ;
permOp ( c , d , 8 , 0xff00ff , results ) ; c = results [ 0 ] ; d = results [ 1 ] ; MST[rv.CRCR3Mutator]MSP[] permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ;
SKB [ 7 ] [ d >>> 21 & 0xf | d >>> 22 & 0x30 ] ; schedule [ j ++ ] = ( t << 16 | s & 0xffff ) ; MST[rv.CRCR6Mutator]MSP[] s = s >>> 16 | t & 0xffff0000 ;
} else if ( ! salt . matches ( lr_2 + B64 . B64T_STRING + lr_3 ) ) { throw new IllegalArgumentException ( lr_4 + salt ) ; } final StringBuilder buffer = new StringBuilder ( lr_5 ) ; MST[ConstructorCallMutator]MSP[] final char charZero = salt . charAt ( 0 ) ;
for ( int i = 0 ; i < 32 ; i += 4 ) { left = dEncrypt ( left , right , i , eSwap0 , eSwap1 , schedule ) ; MST[rv.UOI1Mutator]MSP[]
for ( int i = 0 ; i < 32 ; i += 4 ) { left = dEncrypt ( left , right , i , eSwap0 , eSwap1 , schedule ) ; MST[rv.ABSMutator]MSP[]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.OBBN2Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR4Mutator]MSP[]
left = t >>> 1 | t << 31 ; final int results [] = new int [ 2 ] ; permOp ( right , left , 1 , 0x55555555 , results ) ; right = results [ 0 ] ; MST[rv.UOI1Mutator]MSP[] left = results [ 1 ] ;
permOp ( d , c , 4 , 0xf0f0f0f , results ) ; d = results [ 0 ] ; c = results [ 1 ] ; c = hPermOp ( c , - 2 , 0xcccc0000 ) ; MST[rv.CRCR4Mutator]MSP[]
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; MST[rv.CRCR2Mutator]MSP[] d = d >>> 2 | d << 26 ; } else {
c = c >>> 1 | c << 27 ; d = d >>> 1 | d << 27 ; MST[MathMutator]MSP[] } c &= 0xfffffff ; d &= 0xfffffff ;
s = s << 4 | s >>> 28 ; MST[rv.CRCR6Mutator]MSP[] schedule [ j ++ ] = s ; } return schedule ; } private static int fourBytesToInt ( final byte b [] , int offset ) { int value = byteToUnsigned ( b [ offset ++ ] ) ;
permOp ( d , c , 4 , 0xf0f0f0f , results ) ; MST[VoidMethodCallMutator]MSP[] d = results [ 0 ] ; c = results [ 1 ] ; c = hPermOp ( c , - 2 , 0xcccc0000 ) ;
b [ offset ++ ] = (byte) ( iValue >>> 16 & 0xff ) ; MST[rv.UOI3Mutator]MSP[] b [ offset ++ ] = (byte) ( iValue >>> 24 & 0xff ) ; }
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.ABSMutator]MSP[]
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; a = a ^ t ^ t >>> 16 - n ; MST[MathMutator]MSP[] return a ; }
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.UOI2Mutator]MSP[] c &= 0xfffffff ; int j = 0 ;
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; d = d >>> 2 | d << 26 ; MST[rv.UOI4Mutator]MSP[] } else {
intToFourBytes ( out [ 1 ] , b , 4 ) ; b [ 8 ] = 0 ; int i = 2 ; int y = 0 ; int u = 128 ; for (; i < 13 ; i ++ ) { int j = 0 ; MST[InlineConstantMutator]MSP[]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.OBBN2Mutator]MSP[]
private static int [] body ( final int schedule [] , final int eSwap0 , final int eSwap1 ) { int left = 0 ; int right = 0 ; int t = 0 ; for ( int j = 0 ; j < 25 ; j ++ ) { MST[rv.CRCR1Mutator]MSP[]
s = s << 4 | s >>> 28 ; schedule [ j ++ ] = s ; MST[IncrementsMutator]MSP[] } return schedule ; } private static int fourBytesToInt ( final byte b [] , int offset ) { int value = byteToUnsigned ( b [ offset ++ ] ) ;
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; } t = left ; left = right ; right = t ; MST[rv.UOI2Mutator]MSP[] } t = right ; right = left >>> 1 | left << 31 ;
private static void permOp ( int a , int b , final int n , final int m , final int results [] ) { final int t = ( a >>> n ^ b ) & m ; a ^= t << n ; b ^= t ; MST[rv.UOI1Mutator]MSP[]
d = hPermOp ( d , - 2 , 0xcccc0000 ) ; permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ; c = results [ 1 ] ; MST[rv.CRCR2Mutator]MSP[]
intToFourBytes ( out [ 1 ] , b , 4 ) ; b [ 8 ] = 0 ; int i = 2 ; int y = 0 ; int u = 128 ; for (; i < 13 ; i ++ ) { int j = 0 ; MST[rv.CRCR5Mutator]MSP[]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[MathMutator]MSP[]
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; MST[rv.CRCR4Mutator]MSP[] t = t >>> 4 | t << 28 ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.UOI3Mutator]MSP[]
private static int dEncrypt ( int el , final int r , final int s , final int e0 , final int e1 , final int sArr [] ) { int v = r ^ r >>> 16 ; int u = v & e0 ; MST[rv.UOI4Mutator]MSP[] v &= e1 ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[MathMutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; MST[MathMutator]MSP[] value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; return value ; }
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; t = t >>> 4 | t << 28 ; MST[rv.OBBN2Mutator]MSP[]
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; MST[rv.UOI3Mutator]MSP[] value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; return value ; }
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.OBBN3Mutator]MSP[]
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR1Mutator]MSP[]
SKB [ 7 ] [ d >>> 21 & 0xf | d >>> 22 & 0x30 ] ; schedule [ j ++ ] = ( t << 16 | s & 0xffff ) ; MST[rv.CRCR5Mutator]MSP[] s = s >>> 16 | t & 0xffff0000 ;
intToFourBytes ( out [ 1 ] , b , 4 ) ; b [ 8 ] = 0 ; int i = 2 ; int y = 0 ; MST[rv.CRCR6Mutator]MSP[] int u = 128 ; for (; i < 13 ; i ++ ) { int j = 0 ;
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; t = t >>> 4 | t << 28 ; MST[rv.UOI2Mutator]MSP[]
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; c &= 0xfffffff ; MST[rv.CRCR4Mutator]MSP[] int j = 0 ;
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.OBBN2Mutator]MSP[] c &= 0xfffffff ; int j = 0 ;
c = c >>> 1 | c << 27 ; d = d >>> 1 | d << 27 ; MST[rv.ABSMutator]MSP[] } c &= 0xfffffff ; d &= 0xfffffff ;
SKB [ 7 ] [ d >>> 21 & 0xf | d >>> 22 & 0x30 ] ; schedule [ j ++ ] = ( t << 16 | s & 0xffff ) ; MST[rv.UOI3Mutator]MSP[] s = s >>> 16 | t & 0xffff0000 ;
private static void permOp ( int a , int b , final int n , final int m , final int results [] ) { final int t = ( a >>> n ^ b ) & m ; a ^= t << n ; MST[MathMutator]MSP[] b ^= t ;
permOp ( c , d , 8 , 0xff00ff , results ) ; MST[rv.UOI3Mutator]MSP[] c = results [ 0 ] ; d = results [ 1 ] ; permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ;
intToFourBytes ( out [ 1 ] , b , 4 ) ; b [ 8 ] = 0 ; int i = 2 ; int y = 0 ; int u = 128 ; for (; i < 13 ; i ++ ) { MST[rv.ROR5Mutator]MSP[] int j = 0 ;
final int numSaltChars = SALT_CHARS . length ; salt = lr_1 + SALT_CHARS [ randomGenerator . nextInt ( numSaltChars ) ] + MST[rv.UOI1Mutator]MSP[] SALT_CHARS [ randomGenerator . nextInt ( numSaltChars ) ] ;
final char charOne = salt . charAt ( 1 ) ; buffer . setCharAt ( 0 , charZero ) ; buffer . setCharAt ( 1 , charOne ) ; final int eSwap0 = CON_SALT [ charZero ] ; MST[rv.UOI2Mutator]MSP[] final int eSwap1 = CON_SALT [ charOne ] << 4 ;
left = results [ 1 ] ; permOp ( left , right , 16 , 65535 , results ) ; MST[rv.UOI2Mutator]MSP[] left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 4 , 0xf0f0f0f , results ) ;
private static int dEncrypt ( int el , final int r , final int s , final int e0 , final int e1 , final int sArr [] ) { int v = r ^ r >>> 16 ; MST[InlineConstantMutator]MSP[] int u = v & e0 ; v &= e1 ;
for ( int i = 0 ; i < 16 ; i ++ ) { MST[rv.CRCR3Mutator]MSP[] if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; d = d >>> 2 | d << 26 ; } else {
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR6Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
SKB [ 7 ] [ d >>> 21 & 0xf | d >>> 22 & 0x30 ] ; schedule [ j ++ ] = ( t << 16 | s & 0xffff ) ; s = s >>> 16 | t & 0xffff0000 ; MST[InlineConstantMutator]MSP[]
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; MST[MathMutator]MSP[] a = a ^ t ^ t >>> 16 - n ; return a ; }
private static int [] body ( final int schedule [] , final int eSwap0 , final int eSwap1 ) { int left = 0 ; MST[InlineConstantMutator]MSP[] int right = 0 ; int t = 0 ; for ( int j = 0 ; j < 25 ; j ++ ) {
final char charOne = salt . charAt ( 1 ) ; buffer . setCharAt ( 0 , charZero ) ; buffer . setCharAt ( 1 , charOne ) ; final int eSwap0 = CON_SALT [ charZero ] ; final int eSwap1 = CON_SALT [ charOne ] << 4 ; MST[rv.UOI4Mutator]MSP[]
final int numSaltChars = SALT_CHARS . length ; salt = lr_1 + SALT_CHARS [ randomGenerator . nextInt ( numSaltChars ) ] + SALT_CHARS [ randomGenerator . nextInt ( numSaltChars ) ] ; MST[NonVoidMethodCallMutator]MSP[]
left = t >>> 1 | t << 31 ; MST[rv.UOI4Mutator]MSP[] final int results [] = new int [ 2 ] ; permOp ( right , left , 1 , 0x55555555 , results ) ; right = results [ 0 ] ; left = results [ 1 ] ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.OBBN2Mutator]MSP[]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.ABSMutator]MSP[]
y ++ ; u = 128 ; } buffer . setCharAt ( i , ( char ) COV2CHAR [ c ] ) ; MST[rv.UOI4Mutator]MSP[] } } return buffer . toString () ; } public static String crypt ( final String original ) {
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.UOI3Mutator]MSP[]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR2Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[InlineConstantMutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
final byte key [] = new byte [ 8 ] ; for ( int i = 0 ; i < key . length ; i ++ ) { MST[rv.CRCR6Mutator]MSP[] key [ i ] = 0 ; }
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR3Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
private static void permOp ( int a , int b , final int n , final int m , final int results [] ) { final int t = ( a >>> n ^ b ) & m ; MST[rv.UOI1Mutator]MSP[] a ^= t << n ; b ^= t ;
d = hPermOp ( d , - 2 , 0xcccc0000 ) ; permOp ( d , c , 1 , 0x55555555 , results ) ; MST[rv.UOI2Mutator]MSP[] d = results [ 0 ] ; c = results [ 1 ] ;
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; a = a ^ t ^ t >>> 16 - n ; MST[rv.ABSMutator]MSP[] return a ; }
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.OBBN2Mutator]MSP[]
right = results [ 0 ] ; MST[rv.ABSMutator]MSP[] left = results [ 1 ] ; final int out [] = new int [ 2 ] ; out [ 0 ] = left ; out [ 1 ] = right ; return out ; }
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR1Mutator]MSP[]
private static void intToFourBytes ( final int iValue , final byte b [] , int offset ) { b [ offset ++ ] = (byte) ( iValue & 0xff ) ; MST[rv.UOI2Mutator]MSP[] b [ offset ++ ] = (byte) ( iValue >>> 8 & 0xff ) ;
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; } t = left ; left = right ; right = t ; } t = right ; right = left >>> 1 | left << 31 ; MST[rv.CRCR2Mutator]MSP[]
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; MST[rv.OBBN2Mutator]MSP[] value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; return value ; }
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; MST[rv.UOI2Mutator]MSP[] return value ; }
permOp ( d , c , 4 , 0xf0f0f0f , results ) ; d = results [ 0 ] ; c = results [ 1 ] ; MST[rv.ABSMutator]MSP[] c = hPermOp ( c , - 2 , 0xcccc0000 ) ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR6Mutator]MSP[]
private static void permOp ( int a , int b , final int n , final int m , final int results [] ) { final int t = ( a >>> n ^ b ) & m ; a ^= t << n ; MST[rv.UOI4Mutator]MSP[] b ^= t ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.UOI2Mutator]MSP[]
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR5Mutator]MSP[]
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.CRCR1Mutator]MSP[] c &= 0xfffffff ; int j = 0 ;
left = results [ 1 ] ; permOp ( left , right , 16 , 65535 , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 4 , 0xf0f0f0f , results ) ; MST[rv.UOI3Mutator]MSP[]
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; a = a ^ t ^ t >>> 16 - n ; MST[rv.CRCR2Mutator]MSP[] return a ; }
permOp ( c , d , 8 , 0xff00ff , results ) ; c = results [ 0 ] ; d = results [ 1 ] ; permOp ( d , c , 1 , 0x55555555 , results ) ; MST[InlineConstantMutator]MSP[] d = results [ 0 ] ;
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.CRCR3Mutator]MSP[] c &= 0xfffffff ; int j = 0 ;
u = u ^ u << 16 ^ r ^ sArr [ s ] ; MST[rv.CRCR5Mutator]MSP[] int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; t = t >>> 4 | t << 28 ;
final int schedule [] = desSetKey ( key ) ; final int out [] = body ( schedule , eSwap0 , eSwap1 ) ; MST[rv.UOI4Mutator]MSP[] final byte b [] = new byte [ 9 ] ; intToFourBytes ( out [ 0 ] , b , 0 ) ;
private static int [] body ( final int schedule [] , final int eSwap0 , final int eSwap1 ) { int left = 0 ; int right = 0 ; int t = 0 ; for ( int j = 0 ; j < 25 ; j ++ ) { MST[rv.ROR4Mutator]MSP[]
final int schedule [] = new int [ 32 ] ; int c = fourBytesToInt ( key , 0 ) ; int d = fourBytesToInt ( key , 4 ) ; MST[rv.CRCR5Mutator]MSP[] final int results [] = new int [ 2 ] ;
y ++ ; u = 128 ; } buffer . setCharAt ( i , ( char ) COV2CHAR [ c ] ) ; } } return buffer . toString () ; MST[EmptyObjectReturnValsMutator]MSP[] } public static String crypt ( final String original ) {
permOp ( c , d , 8 , 0xff00ff , results ) ; c = results [ 0 ] ; MST[rv.UOI3Mutator]MSP[] d = results [ 1 ] ; permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ;
SKB [ 7 ] [ d >>> 21 & 0xf | d >>> 22 & 0x30 ] ; schedule [ j ++ ] = ( t << 16 | s & 0xffff ) ; s = s >>> 16 | t & 0xffff0000 ; MST[rv.ABSMutator]MSP[]
final byte key [] = new byte [ 8 ] ; for ( int i = 0 ; i < key . length ; i ++ ) { MST[rv.UOI2Mutator]MSP[] key [ i ] = 0 ; }
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; MST[rv.AOR4Mutator]MSP[] } t = left ; left = right ; right = t ; } t = right ; right = left >>> 1 | left << 31 ;
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; } t = left ; left = right ; right = t ; } t = right ; right = left >>> 1 | left << 31 ; MST[rv.ABSMutator]MSP[]
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; MST[rv.UOI3Mutator]MSP[] } t = left ; left = right ; right = t ; } t = right ; right = left >>> 1 | left << 31 ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR2Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
left = results [ 1 ] ; MST[rv.ABSMutator]MSP[] permOp ( left , right , 16 , 65535 , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 4 , 0xf0f0f0f , results ) ;
c = c >>> 1 | c << 27 ; d = d >>> 1 | d << 27 ; } c &= 0xfffffff ; d &= 0xfffffff ; MST[rv.CRCR3Mutator]MSP[]
left = t >>> 1 | t << 31 ; final int results [] = new int [ 2 ] ; permOp ( right , left , 1 , 0x55555555 , results ) ; MST[rv.UOI2Mutator]MSP[] right = results [ 0 ] ; left = results [ 1 ] ;
intToFourBytes ( out [ 1 ] , b , 4 ) ; MST[rv.CRCR3Mutator]MSP[] b [ 8 ] = 0 ; int i = 2 ; int y = 0 ; int u = 128 ; for (; i < 13 ; i ++ ) { int j = 0 ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.UOI3Mutator]MSP[]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.OBBN2Mutator]MSP[]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[MathMutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
left = results [ 1 ] ; permOp ( left , right , 16 , 65535 , results ) ; MST[rv.UOI1Mutator]MSP[] left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 4 , 0xf0f0f0f , results ) ;
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; a = a ^ t ^ t >>> 16 - n ; MST[rv.AOR1Mutator]MSP[] return a ; }
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; MST[rv.UOI4Mutator]MSP[] t = t >>> 4 | t << 28 ;
private static int dEncrypt ( int el , final int r , final int s , final int e0 , final int e1 , final int sArr [] ) { int v = r ^ r >>> 16 ; int u = v & e0 ; v &= e1 ; MST[rv.OBBN3Mutator]MSP[]
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR6Mutator]MSP[]
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; a = a ^ t ^ t >>> 16 - n ; return a ; MST[rv.ABSMutator]MSP[] }
SKB [ 7 ] [ d >>> 21 & 0xf | d >>> 22 & 0x30 ] ; schedule [ j ++ ] = ( t << 16 | s & 0xffff ) ; s = s >>> 16 | t & 0xffff0000 ; MST[rv.CRCR5Mutator]MSP[]
private static int dEncrypt ( int el , final int r , final int s , final int e0 , final int e1 , final int sArr [] ) { int v = r ^ r >>> 16 ; MST[rv.CRCR4Mutator]MSP[] int u = v & e0 ; v &= e1 ;
permOp ( left , right , 8 , 0xff00ff , results ) ; MST[rv.UOI3Mutator]MSP[] left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 2 , 0x33333333 , results ) ; right = results [ 0 ] ;
final int schedule [] = new int [ 32 ] ; int c = fourBytesToInt ( key , 0 ) ; int d = fourBytesToInt ( key , 4 ) ; MST[ArgumentPropagationMutator]MSP[] final int results [] = new int [ 2 ] ;
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; a = a ^ t ^ t >>> 16 - n ; MST[rv.UOI3Mutator]MSP[] return a ; }
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.UOI2Mutator]MSP[]
public static String crypt ( final byte [] original ) { return crypt ( original , null ) ; MST[NonVoidMethodCallMutator]MSP[] } public static String crypt ( final byte [] original , String salt ) { if ( salt == null ) { final ThreadLocalRandom randomGenerator = ThreadLocalRandom . current () ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR5Mutator]MSP[]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR2Mutator]MSP[]
d = hPermOp ( d , - 2 , 0xcccc0000 ) ; permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ; MST[rv.UOI2Mutator]MSP[] c = results [ 1 ] ;
final byte key [] = new byte [ 8 ] ; for ( int i = 0 ; i < key . length ; i ++ ) { MST[rv.CRCR3Mutator]MSP[] key [ i ] = 0 ; }
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.OBBN1Mutator]MSP[]
c = c >>> 1 | c << 27 ; MST[rv.ABSMutator]MSP[] d = d >>> 1 | d << 27 ; } c &= 0xfffffff ; d &= 0xfffffff ;
private static void permOp ( int a , int b , final int n , final int m , final int results [] ) { final int t = ( a >>> n ^ b ) & m ; MST[rv.ABSMutator]MSP[] a ^= t << n ; b ^= t ;
private static void permOp ( int a , int b , final int n , final int m , final int results [] ) { final int t = ( a >>> n ^ b ) & m ; MST[rv.UOI4Mutator]MSP[] a ^= t << n ; b ^= t ;
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.CRCR3Mutator]MSP[] c &= 0xfffffff ; int j = 0 ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[InlineConstantMutator]MSP[]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR4Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
SKB [ 7 ] [ d >>> 21 & 0xf | d >>> 22 & 0x30 ] ; schedule [ j ++ ] = ( t << 16 | s & 0xffff ) ; s = s >>> 16 | t & 0xffff0000 ; MST[rv.UOI4Mutator]MSP[]
permOp ( c , d , 8 , 0xff00ff , results ) ; c = results [ 0 ] ; d = results [ 1 ] ; permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ; MST[rv.ABSMutator]MSP[]
permOp ( d , c , 4 , 0xf0f0f0f , results ) ; d = results [ 0 ] ; c = results [ 1 ] ; c = hPermOp ( c , - 2 , 0xcccc0000 ) ; MST[rv.UOI4Mutator]MSP[]
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; MST[rv.ABSMutator]MSP[] return value ; }
intToFourBytes ( out [ 1 ] , b , 4 ) ; b [ 8 ] = 0 ; int i = 2 ; int y = 0 ; MST[rv.CRCR3Mutator]MSP[] int u = 128 ; for (; i < 13 ; i ++ ) { int j = 0 ;
s = s << 4 | s >>> 28 ; MST[MathMutator]MSP[] schedule [ j ++ ] = s ; } return schedule ; } private static int fourBytesToInt ( final byte b [] , int offset ) { int value = byteToUnsigned ( b [ offset ++ ] ) ;
for ( int i = 0 ; i < 32 ; i += 4 ) { MST[ConditionalsBoundaryMutator]MSP[] left = dEncrypt ( left , right , i , eSwap0 , eSwap1 , schedule ) ;
c = c >>> 1 | c << 27 ; d = d >>> 1 | d << 27 ; MST[rv.CRCR3Mutator]MSP[] } c &= 0xfffffff ; d &= 0xfffffff ;
right = results [ 0 ] ; left = results [ 1 ] ; final int out [] = new int [ 2 ] ; MST[rv.CRCR5Mutator]MSP[] out [ 0 ] = left ; out [ 1 ] = right ; return out ; }
private static void intToFourBytes ( final int iValue , final byte b [] , int offset ) { b [ offset ++ ] = (byte) ( iValue & 0xff ) ; b [ offset ++ ] = (byte) ( iValue >>> 8 & 0xff ) ; MST[rv.CRCR3Mutator]MSP[]
for ( int i = 0 ; i < key . length && i < original . length ; i ++ ) { final int iChar = original [ i ] ; key [ i ] = (byte) ( iChar << 1 ) ; MST[rv.ABSMutator]MSP[] }
permOp ( d , c , 4 , 0xf0f0f0f , results ) ; MST[rv.UOI3Mutator]MSP[] d = results [ 0 ] ; c = results [ 1 ] ; c = hPermOp ( c , - 2 , 0xcccc0000 ) ;
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; MST[rv.UOI2Mutator]MSP[] value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; return value ; }
private static int byteToUnsigned ( final byte b ) { final int value = b ; return value < 0 ? value + 256 : value ; MST[RemoveConditionalMutator_ORDER_IF]MSP[] }
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; a = a ^ t ^ t >>> 16 - n ; return a ; MST[PrimitiveReturnsMutator]MSP[] }
permOp ( left , right , 8 , 0xff00ff , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 2 , 0x33333333 , results ) ; MST[rv.UOI4Mutator]MSP[] right = results [ 0 ] ;
SKB [ 7 ] [ d >>> 21 & 0xf | d >>> 22 & 0x30 ] ; schedule [ j ++ ] = ( t << 16 | s & 0xffff ) ; MST[rv.CRCR2Mutator]MSP[] s = s >>> 16 | t & 0xffff0000 ;
d = hPermOp ( d , - 2 , 0xcccc0000 ) ; permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ; c = results [ 1 ] ; MST[rv.ABSMutator]MSP[]
private static int byteToUnsigned ( final byte b ) { final int value = b ; return value < 0 ? value + 256 : value ; MST[rv.AOR2Mutator]MSP[] }
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] c = c >>> 2 | c << 26 ; d = d >>> 2 | d << 26 ; } else {
SKB [ 7 ] [ d >>> 21 & 0xf | d >>> 22 & 0x30 ] ; schedule [ j ++ ] = ( t << 16 | s & 0xffff ) ; s = s >>> 16 | t & 0xffff0000 ; MST[rv.CRCR4Mutator]MSP[]
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; MST[rv.CRCR6Mutator]MSP[] } u >>>= 1 ; if ( u == 0 ) {
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.UOI2Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[InlineConstantMutator]MSP[]
s = s << 4 | s >>> 28 ; MST[rv.CRCR3Mutator]MSP[] schedule [ j ++ ] = s ; } return schedule ; } private static int fourBytesToInt ( final byte b [] , int offset ) { int value = byteToUnsigned ( b [ offset ++ ] ) ;
private static int dEncrypt ( int el , final int r , final int s , final int e0 , final int e1 , final int sArr [] ) { int v = r ^ r >>> 16 ; MST[rv.ABSMutator]MSP[] int u = v & e0 ; v &= e1 ;
private static int byteToUnsigned ( final byte b ) { final int value = b ; return value < 0 ? value + 256 : value ; MST[rv.ROR4Mutator]MSP[] }
private static int dEncrypt ( int el , final int r , final int s , final int e0 , final int e1 , final int sArr [] ) { int v = r ^ r >>> 16 ; int u = v & e0 ; v &= e1 ; MST[rv.UOI3Mutator]MSP[]
b [ offset ++ ] = (byte) ( iValue >>> 16 & 0xff ) ; MST[rv.OBBN3Mutator]MSP[] b [ offset ++ ] = (byte) ( iValue >>> 24 & 0xff ) ; }
SKB [ 7 ] [ d >>> 21 & 0xf | d >>> 22 & 0x30 ] ; schedule [ j ++ ] = ( t << 16 | s & 0xffff ) ; MST[rv.OBBN2Mutator]MSP[] s = s >>> 16 | t & 0xffff0000 ;
private static int byteToUnsigned ( final byte b ) { final int value = b ; return value < 0 ? value + 256 : value ; MST[rv.UOI3Mutator]MSP[] }
c = c >>> 1 | c << 27 ; MST[rv.UOI4Mutator]MSP[] d = d >>> 1 | d << 27 ; } c &= 0xfffffff ; d &= 0xfffffff ;
s = s << 4 | s >>> 28 ; schedule [ j ++ ] = s ; MST[experimental.RemoveIncrementsMutator]MSP[] } return schedule ; } private static int fourBytesToInt ( final byte b [] , int offset ) { int value = byteToUnsigned ( b [ offset ++ ] ) ;
final byte key [] = new byte [ 8 ] ; for ( int i = 0 ; i < key . length ; i ++ ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] key [ i ] = 0 ; }
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.OBBN3Mutator]MSP[]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.ABSMutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; } t = left ; left = right ; MST[rv.ABSMutator]MSP[] right = t ; } t = right ; right = left >>> 1 | left << 31 ;
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; MST[rv.AOD2Mutator]MSP[] a = a ^ t ^ t >>> 16 - n ; return a ; }
for ( int i = 0 ; i < key . length && i < original . length ; i ++ ) { MST[rv.ROR2Mutator]MSP[] final int iChar = original [ i ] ; key [ i ] = (byte) ( iChar << 1 ) ; }
c = c >>> 1 | c << 27 ; MST[rv.CRCR4Mutator]MSP[] d = d >>> 1 | d << 27 ; } c &= 0xfffffff ; d &= 0xfffffff ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.OBBN3Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
permOp ( c , d , 8 , 0xff00ff , results ) ; c = results [ 0 ] ; d = results [ 1 ] ; permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ; MST[rv.UOI4Mutator]MSP[]
right = results [ 0 ] ; left = results [ 1 ] ; final int out [] = new int [ 2 ] ; out [ 0 ] = left ; out [ 1 ] = right ; MST[rv.CRCR2Mutator]MSP[] return out ; }
final int schedule [] = new int [ 32 ] ; int c = fourBytesToInt ( key , 0 ) ; MST[rv.CRCR3Mutator]MSP[] int d = fourBytesToInt ( key , 4 ) ; final int results [] = new int [ 2 ] ;
c = c >>> 1 | c << 27 ; MST[rv.CRCR5Mutator]MSP[] d = d >>> 1 | d << 27 ; } c &= 0xfffffff ; d &= 0xfffffff ;
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.CRCR1Mutator]MSP[] c &= 0xfffffff ; int j = 0 ;
y ++ ; u = 128 ; MST[rv.CRCR1Mutator]MSP[] } buffer . setCharAt ( i , ( char ) COV2CHAR [ c ] ) ; } } return buffer . toString () ; } public static String crypt ( final String original ) {
b [ offset ++ ] = (byte) ( iValue >>> 16 & 0xff ) ; b [ offset ++ ] = (byte) ( iValue >>> 24 & 0xff ) ; MST[rv.ABSMutator]MSP[] }
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR6Mutator]MSP[]
c = c >>> 1 | c << 27 ; d = d >>> 1 | d << 27 ; MST[rv.CRCR4Mutator]MSP[] } c &= 0xfffffff ; d &= 0xfffffff ;
right = results [ 0 ] ; left = results [ 1 ] ; MST[rv.CRCR2Mutator]MSP[] final int out [] = new int [ 2 ] ; out [ 0 ] = left ; out [ 1 ] = right ; return out ; }
intToFourBytes ( out [ 1 ] , b , 4 ) ; b [ 8 ] = 0 ; int i = 2 ; int y = 0 ; int u = 128 ; for (; i < 13 ; i ++ ) { MST[rv.ABSMutator]MSP[] int j = 0 ;
u = u ^ u << 16 ^ r ^ sArr [ s ] ; MST[rv.UOI2Mutator]MSP[] int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; t = t >>> 4 | t << 28 ;
permOp ( c , d , 8 , 0xff00ff , results ) ; MST[rv.CRCR6Mutator]MSP[] c = results [ 0 ] ; d = results [ 1 ] ; permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ;
for ( int i = 0 ; i < 16 ; i ++ ) { MST[InlineConstantMutator]MSP[] if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; d = d >>> 2 | d << 26 ; } else {
SKB [ 7 ] [ d >>> 21 & 0xf | d >>> 22 & 0x30 ] ; schedule [ j ++ ] = ( t << 16 | s & 0xffff ) ; s = s >>> 16 | t & 0xffff0000 ; MST[rv.OBBN1Mutator]MSP[]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.UOI2Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR4Mutator]MSP[]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[InlineConstantMutator]MSP[]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR5Mutator]MSP[]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.OBBN1Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR5Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
private static void intToFourBytes ( final int iValue , final byte b [] , int offset ) { b [ offset ++ ] = (byte) ( iValue & 0xff ) ; b [ offset ++ ] = (byte) ( iValue >>> 8 & 0xff ) ; MST[MathMutator]MSP[]
s = s << 4 | s >>> 28 ; schedule [ j ++ ] = s ; } return schedule ; } private static int fourBytesToInt ( final byte b [] , int offset ) { int value = byteToUnsigned ( b [ offset ++ ] ) ; MST[rv.UOI1Mutator]MSP[]
permOp ( c , d , 8 , 0xff00ff , results ) ; MST[rv.UOI4Mutator]MSP[] c = results [ 0 ] ; d = results [ 1 ] ; permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ;
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[MathMutator]MSP[] c &= 0xfffffff ; int j = 0 ;
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; c &= 0xfffffff ; MST[rv.ABSMutator]MSP[] int j = 0 ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[InlineConstantMutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR3Mutator]MSP[]
u = u ^ u << 16 ^ r ^ sArr [ s ] ; MST[MathMutator]MSP[] int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; t = t >>> 4 | t << 28 ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.UOI4Mutator]MSP[]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.UOI1Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; MST[rv.UOI1Mutator]MSP[] a = a ^ t ^ t >>> 16 - n ; return a ; }
c = c >>> 1 | c << 27 ; d = d >>> 1 | d << 27 ; MST[MathMutator]MSP[] } c &= 0xfffffff ; d &= 0xfffffff ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR5Mutator]MSP[]
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; MST[rv.UOI4Mutator]MSP[] } t = left ; left = right ; right = t ; } t = right ; right = left >>> 1 | left << 31 ;
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { MST[rv.ROR2Mutator]MSP[] c = c >>> 2 | c << 26 ; d = d >>> 2 | d << 26 ; } else {
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.OBBN3Mutator]MSP[]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR3Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[MathMutator]MSP[]
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; MST[rv.UOI1Mutator]MSP[] d = d >>> 2 | d << 26 ; } else {
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.UOI3Mutator]MSP[]
results [ 0 ] = a ; results [ 1 ] = b ; MST[rv.CRCR5Mutator]MSP[] }
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[MathMutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
b [ offset ++ ] = (byte) ( iValue >>> 16 & 0xff ) ; b [ offset ++ ] = (byte) ( iValue >>> 24 & 0xff ) ; MST[rv.CRCR1Mutator]MSP[] }
int c = 0 ; MST[InlineConstantMutator]MSP[] for (; j < 6 ; j ++ ) { c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) {
intToFourBytes ( out [ 1 ] , b , 4 ) ; b [ 8 ] = 0 ; int i = 2 ; int y = 0 ; int u = 128 ; for (; i < 13 ; i ++ ) { MST[rv.CRCR5Mutator]MSP[] int j = 0 ;
final char charOne = salt . charAt ( 1 ) ; buffer . setCharAt ( 0 , charZero ) ; MST[rv.CRCR3Mutator]MSP[] buffer . setCharAt ( 1 , charOne ) ; final int eSwap0 = CON_SALT [ charZero ] ; final int eSwap1 = CON_SALT [ charOne ] << 4 ;
final char charOne = salt . charAt ( 1 ) ; buffer . setCharAt ( 0 , charZero ) ; buffer . setCharAt ( 1 , charOne ) ; MST[rv.CRCR5Mutator]MSP[] final int eSwap0 = CON_SALT [ charZero ] ; final int eSwap1 = CON_SALT [ charOne ] << 4 ;
for ( int i = 0 ; i < 32 ; i += 4 ) { MST[rv.UOI3Mutator]MSP[] left = dEncrypt ( left , right , i , eSwap0 , eSwap1 , schedule ) ;
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; MST[rv.ABSMutator]MSP[] t = t >>> 4 | t << 28 ;
final int schedule [] = desSetKey ( key ) ; final int out [] = body ( schedule , eSwap0 , eSwap1 ) ; final byte b [] = new byte [ 9 ] ; intToFourBytes ( out [ 0 ] , b , 0 ) ; MST[rv.UOI4Mutator]MSP[]
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; MST[rv.UOI1Mutator]MSP[] value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; return value ; }
for ( int i = 0 ; i < 16 ; i ++ ) { MST[rv.UOI3Mutator]MSP[] if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; d = d >>> 2 | d << 26 ; } else {
intToFourBytes ( out [ 1 ] , b , 4 ) ; b [ 8 ] = 0 ; int i = 2 ; MST[rv.CRCR6Mutator]MSP[] int y = 0 ; int u = 128 ; for (; i < 13 ; i ++ ) { int j = 0 ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR3Mutator]MSP[]
d = hPermOp ( d , - 2 , 0xcccc0000 ) ; MST[rv.CRCR2Mutator]MSP[] permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ; c = results [ 1 ] ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR6Mutator]MSP[]
private static int [] body ( final int schedule [] , final int eSwap0 , final int eSwap1 ) { int left = 0 ; int right = 0 ; MST[InlineConstantMutator]MSP[] int t = 0 ; for ( int j = 0 ; j < 25 ; j ++ ) {
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[MathMutator]MSP[]
left = t >>> 1 | t << 31 ; final int results [] = new int [ 2 ] ; permOp ( right , left , 1 , 0x55555555 , results ) ; right = results [ 0 ] ; MST[rv.CRCR6Mutator]MSP[] left = results [ 1 ] ;
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; c &= 0xfffffff ; MST[rv.UOI4Mutator]MSP[] int j = 0 ;
left = t >>> 1 | t << 31 ; MST[rv.ABSMutator]MSP[] final int results [] = new int [ 2 ] ; permOp ( right , left , 1 , 0x55555555 , results ) ; right = results [ 0 ] ; left = results [ 1 ] ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR6Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; MST[rv.CRCR4Mutator]MSP[] value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; return value ; }
final int numSaltChars = SALT_CHARS . length ; salt = lr_1 + SALT_CHARS [ randomGenerator . nextInt ( numSaltChars ) ] + MST[ArgumentPropagationMutator]MSP[] SALT_CHARS [ randomGenerator . nextInt ( numSaltChars ) ] ;
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; MST[rv.OBBN3Mutator]MSP[] return value ; }
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; MST[rv.CRCR2Mutator]MSP[] t = t >>> 4 | t << 28 ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[InlineConstantMutator]MSP[]
private static void permOp ( int a , int b , final int n , final int m , final int results [] ) { final int t = ( a >>> n ^ b ) & m ; MST[rv.UOI1Mutator]MSP[] a ^= t << n ; b ^= t ;
left = t >>> 1 | t << 31 ; MST[rv.CRCR5Mutator]MSP[] final int results [] = new int [ 2 ] ; permOp ( right , left , 1 , 0x55555555 , results ) ; right = results [ 0 ] ; left = results [ 1 ] ;
y ++ ; u = 128 ; } buffer . setCharAt ( i , ( char ) COV2CHAR [ c ] ) ; MST[rv.UOI3Mutator]MSP[] } } return buffer . toString () ; } public static String crypt ( final String original ) {
d = hPermOp ( d , - 2 , 0xcccc0000 ) ; permOp ( d , c , 1 , 0x55555555 , results ) ; MST[rv.UOI3Mutator]MSP[] d = results [ 0 ] ; c = results [ 1 ] ;
y ++ ; u = 128 ; } buffer . setCharAt ( i , ( char ) COV2CHAR [ c ] ) ; MST[rv.UOI2Mutator]MSP[] } } return buffer . toString () ; } public static String crypt ( final String original ) {
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.UOI1Mutator]MSP[]
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; a = a ^ t ^ t >>> 16 - n ; MST[rv.UOI4Mutator]MSP[] return a ; }
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR5Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
final char charOne = salt . charAt ( 1 ) ; buffer . setCharAt ( 0 , charZero ) ; MST[VoidMethodCallMutator]MSP[] buffer . setCharAt ( 1 , charOne ) ; final int eSwap0 = CON_SALT [ charZero ] ; final int eSwap1 = CON_SALT [ charOne ] << 4 ;
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[MathMutator]MSP[] c &= 0xfffffff ; int j = 0 ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.UOI1Mutator]MSP[]
final byte key [] = new byte [ 8 ] ; for ( int i = 0 ; i < key . length ; i ++ ) { MST[rv.ROR5Mutator]MSP[] key [ i ] = 0 ; }
c = c >>> 1 | c << 27 ; d = d >>> 1 | d << 27 ; } c &= 0xfffffff ; MST[rv.CRCR1Mutator]MSP[] d &= 0xfffffff ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR3Mutator]MSP[]
final char charOne = salt . charAt ( 1 ) ; buffer . setCharAt ( 0 , charZero ) ; buffer . setCharAt ( 1 , charOne ) ; final int eSwap0 = CON_SALT [ charZero ] ; final int eSwap1 = CON_SALT [ charOne ] << 4 ; MST[rv.CRCR4Mutator]MSP[]
d = hPermOp ( d , - 2 , 0xcccc0000 ) ; permOp ( d , c , 1 , 0x55555555 , results ) ; MST[rv.CRCR5Mutator]MSP[] d = results [ 0 ] ; c = results [ 1 ] ;
left = t >>> 1 | t << 31 ; MST[rv.CRCR4Mutator]MSP[] final int results [] = new int [ 2 ] ; permOp ( right , left , 1 , 0x55555555 , results ) ; right = results [ 0 ] ; left = results [ 1 ] ;
for ( int i = 0 ; i < 32 ; i += 4 ) { MST[InlineConstantMutator]MSP[] left = dEncrypt ( left , right , i , eSwap0 , eSwap1 , schedule ) ;
permOp ( d , c , 4 , 0xf0f0f0f , results ) ; d = results [ 0 ] ; c = results [ 1 ] ; c = hPermOp ( c , - 2 , 0xcccc0000 ) ; MST[rv.ABSMutator]MSP[]
c = c >>> 1 | c << 27 ; d = d >>> 1 | d << 27 ; } c &= 0xfffffff ; d &= 0xfffffff ; MST[MathMutator]MSP[]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.UOI3Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
private static void permOp ( int a , int b , final int n , final int m , final int results [] ) { final int t = ( a >>> n ^ b ) & m ; a ^= t << n ; MST[rv.UOI3Mutator]MSP[] b ^= t ;
intToFourBytes ( out [ 1 ] , b , 4 ) ; MST[rv.UOI1Mutator]MSP[] b [ 8 ] = 0 ; int i = 2 ; int y = 0 ; int u = 128 ; for (; i < 13 ; i ++ ) { int j = 0 ;
left = results [ 1 ] ; permOp ( left , right , 16 , 65535 , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 4 , 0xf0f0f0f , results ) ; MST[rv.UOI2Mutator]MSP[]
return crypt ( original . getBytes ( StandardCharsets . UTF_8 ) ) ; } public static String crypt ( final String original , final String salt ) { return crypt ( original . getBytes ( StandardCharsets . UTF_8 ) , salt ) ; MST[NonVoidMethodCallMutator]MSP[] }
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR4Mutator]MSP[]
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; MST[rv.UOI3Mutator]MSP[] if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) {
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR5Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
s = s << 4 | s >>> 28 ; MST[rv.UOI4Mutator]MSP[] schedule [ j ++ ] = s ; } return schedule ; } private static int fourBytesToInt ( final byte b [] , int offset ) { int value = byteToUnsigned ( b [ offset ++ ] ) ;
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; MST[rv.UOI1Mutator]MSP[] t = t >>> 4 | t << 28 ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.OBBN2Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { MST[rv.OBBN3Mutator]MSP[] c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) {
private static int [] body ( final int schedule [] , final int eSwap0 , final int eSwap1 ) { int left = 0 ; int right = 0 ; int t = 0 ; for ( int j = 0 ; j < 25 ; j ++ ) { MST[rv.ROR1Mutator]MSP[]
private static void permOp ( int a , int b , final int n , final int m , final int results [] ) { final int t = ( a >>> n ^ b ) & m ; MST[rv.OBBN2Mutator]MSP[] a ^= t << n ; b ^= t ;
u = u ^ u << 16 ^ r ^ sArr [ s ] ; MST[rv.CRCR2Mutator]MSP[] int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; t = t >>> 4 | t << 28 ;
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; } t = left ; left = right ; right = t ; } t = right ; MST[rv.ABSMutator]MSP[] right = left >>> 1 | left << 31 ;
final int numSaltChars = SALT_CHARS . length ; salt = lr_1 + SALT_CHARS [ randomGenerator . nextInt ( numSaltChars ) ] + MST[rv.ABSMutator]MSP[] SALT_CHARS [ randomGenerator . nextInt ( numSaltChars ) ] ;
SKB [ 7 ] [ d >>> 21 & 0xf | d >>> 22 & 0x30 ] ; schedule [ j ++ ] = ( t << 16 | s & 0xffff ) ; MST[rv.UOI3Mutator]MSP[] s = s >>> 16 | t & 0xffff0000 ;
intToFourBytes ( out [ 1 ] , b , 4 ) ; b [ 8 ] = 0 ; MST[rv.CRCR6Mutator]MSP[] int i = 2 ; int y = 0 ; int u = 128 ; for (; i < 13 ; i ++ ) { int j = 0 ;
c = results [ 1 ] ; MST[InlineConstantMutator]MSP[] d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; c &= 0xfffffff ; int j = 0 ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR2Mutator]MSP[]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[MathMutator]MSP[]
private static int dEncrypt ( int el , final int r , final int s , final int e0 , final int e1 , final int sArr [] ) { int v = r ^ r >>> 16 ; MST[rv.CRCR1Mutator]MSP[] int u = v & e0 ; v &= e1 ;
final byte key [] = new byte [ 8 ] ; for ( int i = 0 ; i < key . length ; i ++ ) { key [ i ] = 0 ; MST[rv.CRCR3Mutator]MSP[] }
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.OBBN3Mutator]MSP[]
for ( int i = 0 ; i < 32 ; i += 4 ) { left = dEncrypt ( left , right , i , eSwap0 , eSwap1 , schedule ) ; MST[rv.UOI3Mutator]MSP[]
c = c >>> 1 | c << 27 ; d = d >>> 1 | d << 27 ; MST[rv.UOI4Mutator]MSP[] } c &= 0xfffffff ; d &= 0xfffffff ;
SKB [ 7 ] [ d >>> 21 & 0xf | d >>> 22 & 0x30 ] ; schedule [ j ++ ] = ( t << 16 | s & 0xffff ) ; s = s >>> 16 | t & 0xffff0000 ; MST[rv.CRCR2Mutator]MSP[]
final char charOne = salt . charAt ( 1 ) ; buffer . setCharAt ( 0 , charZero ) ; buffer . setCharAt ( 1 , charOne ) ; final int eSwap0 = CON_SALT [ charZero ] ; final int eSwap1 = CON_SALT [ charOne ] << 4 ; MST[rv.UOI1Mutator]MSP[]
left = t >>> 1 | t << 31 ; MST[rv.UOI2Mutator]MSP[] final int results [] = new int [ 2 ] ; permOp ( right , left , 1 , 0x55555555 , results ) ; right = results [ 0 ] ; left = results [ 1 ] ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR6Mutator]MSP[]
left = t >>> 1 | t << 31 ; final int results [] = new int [ 2 ] ; MST[rv.CRCR4Mutator]MSP[] permOp ( right , left , 1 , 0x55555555 , results ) ; right = results [ 0 ] ; left = results [ 1 ] ;
c = c >>> 1 | c << 27 ; MST[rv.UOI1Mutator]MSP[] d = d >>> 1 | d << 27 ; } c &= 0xfffffff ; d &= 0xfffffff ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR3Mutator]MSP[]
for ( int i = 0 ; i < key . length && i < original . length ; i ++ ) { MST[rv.UOI2Mutator]MSP[] final int iChar = original [ i ] ; key [ i ] = (byte) ( iChar << 1 ) ; }
s = s << 4 | s >>> 28 ; schedule [ j ++ ] = s ; MST[rv.ABSMutator]MSP[] } return schedule ; } private static int fourBytesToInt ( final byte b [] , int offset ) { int value = byteToUnsigned ( b [ offset ++ ] ) ;
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) { MST[rv.ROR3Mutator]MSP[]
final char charOne = salt . charAt ( 1 ) ; buffer . setCharAt ( 0 , charZero ) ; buffer . setCharAt ( 1 , charOne ) ; MST[InlineConstantMutator]MSP[] final int eSwap0 = CON_SALT [ charZero ] ; final int eSwap1 = CON_SALT [ charOne ] << 4 ;
private static int byteToUnsigned ( final byte b ) { final int value = b ; return value < 0 ? value + 256 : value ; MST[rv.UOI4Mutator]MSP[] }
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[MathMutator]MSP[]
final char charOne = salt . charAt ( 1 ) ; buffer . setCharAt ( 0 , charZero ) ; MST[rv.UOI1Mutator]MSP[] buffer . setCharAt ( 1 , charOne ) ; final int eSwap0 = CON_SALT [ charZero ] ; final int eSwap1 = CON_SALT [ charOne ] << 4 ;
for ( int i = 0 ; i < key . length && i < original . length ; i ++ ) { MST[rv.ROR5Mutator]MSP[] final int iChar = original [ i ] ; key [ i ] = (byte) ( iChar << 1 ) ; }
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.OBBN2Mutator]MSP[] c &= 0xfffffff ; int j = 0 ;
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; return value ; MST[rv.ABSMutator]MSP[] }
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; MST[rv.UOI2Mutator]MSP[] a = a ^ t ^ t >>> 16 - n ; return a ; }
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; } t = left ; left = right ; right = t ; } t = right ; right = left >>> 1 | left << 31 ; MST[rv.OBBN2Mutator]MSP[]
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.OBBN1Mutator]MSP[] c &= 0xfffffff ; int j = 0 ;
intToFourBytes ( out [ 1 ] , b , 4 ) ; MST[rv.UOI4Mutator]MSP[] b [ 8 ] = 0 ; int i = 2 ; int y = 0 ; int u = 128 ; for (; i < 13 ; i ++ ) { int j = 0 ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.UOI2Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; MST[rv.UOI3Mutator]MSP[] return value ; }
private static int [] body ( final int schedule [] , final int eSwap0 , final int eSwap1 ) { int left = 0 ; int right = 0 ; int t = 0 ; for ( int j = 0 ; j < 25 ; j ++ ) { MST[rv.CRCR4Mutator]MSP[]
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.CRCR6Mutator]MSP[] c &= 0xfffffff ; int j = 0 ;
permOp ( left , right , 8 , 0xff00ff , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 2 , 0x33333333 , results ) ; right = results [ 0 ] ; MST[rv.CRCR5Mutator]MSP[]
final int schedule [] = new int [ 32 ] ; int c = fourBytesToInt ( key , 0 ) ; int d = fourBytesToInt ( key , 4 ) ; MST[rv.CRCR2Mutator]MSP[] final int results [] = new int [ 2 ] ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.UOI4Mutator]MSP[]
permOp ( d , c , 4 , 0xf0f0f0f , results ) ; d = results [ 0 ] ; c = results [ 1 ] ; MST[rv.UOI4Mutator]MSP[] c = hPermOp ( c , - 2 , 0xcccc0000 ) ;
c = c >>> 1 | c << 27 ; MST[rv.CRCR2Mutator]MSP[] d = d >>> 1 | d << 27 ; } c &= 0xfffffff ; d &= 0xfffffff ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.OBBN3Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
permOp ( c , d , 8 , 0xff00ff , results ) ; c = results [ 0 ] ; d = results [ 1 ] ; permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ; MST[rv.UOI1Mutator]MSP[]
right = results [ 0 ] ; left = results [ 1 ] ; final int out [] = new int [ 2 ] ; out [ 0 ] = left ; out [ 1 ] = right ; MST[rv.UOI1Mutator]MSP[] return out ; }
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.UOI3Mutator]MSP[]
final int schedule [] = desSetKey ( key ) ; final int out [] = body ( schedule , eSwap0 , eSwap1 ) ; MST[rv.UOI3Mutator]MSP[] final byte b [] = new byte [ 9 ] ; intToFourBytes ( out [ 0 ] , b , 0 ) ;
b [ offset ++ ] = (byte) ( iValue >>> 16 & 0xff ) ; MST[rv.CRCR6Mutator]MSP[] b [ offset ++ ] = (byte) ( iValue >>> 24 & 0xff ) ; }
permOp ( left , right , 8 , 0xff00ff , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; MST[rv.CRCR6Mutator]MSP[] permOp ( right , left , 2 , 0x33333333 , results ) ; right = results [ 0 ] ;
for ( int i = 0 ; i < 32 ; i += 4 ) { left = dEncrypt ( left , right , i , eSwap0 , eSwap1 , schedule ) ; MST[rv.UOI4Mutator]MSP[]
SKB [ 7 ] [ d >>> 21 & 0xf | d >>> 22 & 0x30 ] ; schedule [ j ++ ] = ( t << 16 | s & 0xffff ) ; s = s >>> 16 | t & 0xffff0000 ; MST[rv.UOI1Mutator]MSP[]
s = s << 4 | s >>> 28 ; MST[MathMutator]MSP[] schedule [ j ++ ] = s ; } return schedule ; } private static int fourBytesToInt ( final byte b [] , int offset ) { int value = byteToUnsigned ( b [ offset ++ ] ) ;
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; MST[rv.UOI4Mutator]MSP[] value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; return value ; }
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { MST[rv.UOI2Mutator]MSP[] c = c >>> 2 | c << 26 ; d = d >>> 2 | d << 26 ; } else {
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR4Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
intToFourBytes ( out [ 1 ] , b , 4 ) ; b [ 8 ] = 0 ; int i = 2 ; int y = 0 ; int u = 128 ; for (; i < 13 ; i ++ ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] int j = 0 ;
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { MST[rv.UOI1Mutator]MSP[] c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) {
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.ABSMutator]MSP[]
b [ offset ++ ] = (byte) ( iValue >>> 16 & 0xff ) ; MST[rv.CRCR2Mutator]MSP[] b [ offset ++ ] = (byte) ( iValue >>> 24 & 0xff ) ; }
private static int [] body ( final int schedule [] , final int eSwap0 , final int eSwap1 ) { int left = 0 ; int right = 0 ; MST[rv.CRCR1Mutator]MSP[] int t = 0 ; for ( int j = 0 ; j < 25 ; j ++ ) {
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR5Mutator]MSP[]
b [ offset ++ ] = (byte) ( iValue >>> 16 & 0xff ) ; b [ offset ++ ] = (byte) ( iValue >>> 24 & 0xff ) ; MST[IncrementsMutator]MSP[] }
permOp ( d , c , 4 , 0xf0f0f0f , results ) ; MST[rv.CRCR5Mutator]MSP[] d = results [ 0 ] ; c = results [ 1 ] ; c = hPermOp ( c , - 2 , 0xcccc0000 ) ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR5Mutator]MSP[]
SKB [ 7 ] [ d >>> 21 & 0xf | d >>> 22 & 0x30 ] ; schedule [ j ++ ] = ( t << 16 | s & 0xffff ) ; MST[rv.UOI2Mutator]MSP[] s = s >>> 16 | t & 0xffff0000 ;
left = t >>> 1 | t << 31 ; final int results [] = new int [ 2 ] ; permOp ( right , left , 1 , 0x55555555 , results ) ; right = results [ 0 ] ; MST[rv.CRCR3Mutator]MSP[] left = results [ 1 ] ;
u = u ^ u << 16 ^ r ^ sArr [ s ] ; MST[rv.UOI3Mutator]MSP[] int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; t = t >>> 4 | t << 28 ;
b [ offset ++ ] = (byte) ( iValue >>> 16 & 0xff ) ; b [ offset ++ ] = (byte) ( iValue >>> 24 & 0xff ) ; MST[rv.UOI4Mutator]MSP[] }
permOp ( c , d , 8 , 0xff00ff , results ) ; MST[rv.ABSMutator]MSP[] c = results [ 0 ] ; d = results [ 1 ] ; permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ;
for ( int i = 0 ; i < key . length && i < original . length ; i ++ ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] final int iChar = original [ i ] ; key [ i ] = (byte) ( iChar << 1 ) ; }
c = c >>> 1 | c << 27 ; d = d >>> 1 | d << 27 ; MST[rv.UOI3Mutator]MSP[] } c &= 0xfffffff ; d &= 0xfffffff ;
left = t >>> 1 | t << 31 ; final int results [] = new int [ 2 ] ; permOp ( right , left , 1 , 0x55555555 , results ) ; right = results [ 0 ] ; left = results [ 1 ] ; MST[rv.CRCR5Mutator]MSP[]
SKB [ 7 ] [ d >>> 21 & 0xf | d >>> 22 & 0x30 ] ; schedule [ j ++ ] = ( t << 16 | s & 0xffff ) ; s = s >>> 16 | t & 0xffff0000 ; MST[rv.CRCR1Mutator]MSP[]
private static int dEncrypt ( int el , final int r , final int s , final int e0 , final int e1 , final int sArr [] ) { int v = r ^ r >>> 16 ; int u = v & e0 ; MST[rv.UOI2Mutator]MSP[] v &= e1 ;
private static int dEncrypt ( int el , final int r , final int s , final int e0 , final int e1 , final int sArr [] ) { int v = r ^ r >>> 16 ; int u = v & e0 ; v &= e1 ; MST[rv.UOI4Mutator]MSP[]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.UOI1Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
s = s << 4 | s >>> 28 ; MST[rv.CRCR4Mutator]MSP[] schedule [ j ++ ] = s ; } return schedule ; } private static int fourBytesToInt ( final byte b [] , int offset ) { int value = byteToUnsigned ( b [ offset ++ ] ) ;
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[InlineConstantMutator]MSP[] c &= 0xfffffff ; int j = 0 ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.OBBN1Mutator]MSP[]
private static int dEncrypt ( int el , final int r , final int s , final int e0 , final int e1 , final int sArr [] ) { int v = r ^ r >>> 16 ; MST[rv.UOI1Mutator]MSP[] int u = v & e0 ; v &= e1 ;
b [ offset ++ ] = (byte) ( iValue >>> 16 & 0xff ) ; MST[rv.UOI2Mutator]MSP[] b [ offset ++ ] = (byte) ( iValue >>> 24 & 0xff ) ; }
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; MST[rv.CRCR3Mutator]MSP[] if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) {
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR6Mutator]MSP[]
right = results [ 0 ] ; left = results [ 1 ] ; MST[rv.UOI1Mutator]MSP[] final int out [] = new int [ 2 ] ; out [ 0 ] = left ; out [ 1 ] = right ; return out ; }
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR5Mutator]MSP[]
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { MST[rv.ROR3Mutator]MSP[] c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) {
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; MST[rv.UOI2Mutator]MSP[] } u >>>= 1 ; if ( u == 0 ) {
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; } t = left ; MST[rv.ABSMutator]MSP[] left = right ; right = t ; } t = right ; right = left >>> 1 | left << 31 ;
c = c >>> 1 | c << 27 ; d = d >>> 1 | d << 27 ; } c &= 0xfffffff ; MST[InlineConstantMutator]MSP[] d &= 0xfffffff ;
right = results [ 0 ] ; left = results [ 1 ] ; final int out [] = new int [ 2 ] ; MST[rv.CRCR2Mutator]MSP[] out [ 0 ] = left ; out [ 1 ] = right ; return out ; }
SKB [ 7 ] [ d >>> 21 & 0xf | d >>> 22 & 0x30 ] ; schedule [ j ++ ] = ( t << 16 | s & 0xffff ) ; MST[MathMutator]MSP[] s = s >>> 16 | t & 0xffff0000 ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR1Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.OBBN2Mutator]MSP[]
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; MST[MathMutator]MSP[] if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) {
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) { MST[rv.ABSMutator]MSP[]
for ( int i = 0 ; i < 32 ; i += 4 ) { MST[rv.CRCR1Mutator]MSP[] left = dEncrypt ( left , right , i , eSwap0 , eSwap1 , schedule ) ;
private static int byteToUnsigned ( final byte b ) { final int value = b ; return value < 0 ? value + 256 : value ; MST[rv.CRCR1Mutator]MSP[] }
s = s << 4 | s >>> 28 ; MST[rv.UOI3Mutator]MSP[] schedule [ j ++ ] = s ; } return schedule ; } private static int fourBytesToInt ( final byte b [] , int offset ) { int value = byteToUnsigned ( b [ offset ++ ] ) ;
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; MST[rv.UOI3Mutator]MSP[] t = t >>> 4 | t << 28 ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR2Mutator]MSP[]
left = results [ 1 ] ; permOp ( left , right , 16 , 65535 , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 4 , 0xf0f0f0f , results ) ; MST[rv.CRCR2Mutator]MSP[]
permOp ( c , d , 8 , 0xff00ff , results ) ; c = results [ 0 ] ; d = results [ 1 ] ; permOp ( d , c , 1 , 0x55555555 , results ) ; MST[rv.UOI2Mutator]MSP[] d = results [ 0 ] ;
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; MST[rv.ABSMutator]MSP[] value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; return value ; }
permOp ( left , right , 8 , 0xff00ff , results ) ; MST[rv.CRCR6Mutator]MSP[] left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 2 , 0x33333333 , results ) ; right = results [ 0 ] ;
results [ 0 ] = a ; MST[rv.ABSMutator]MSP[] results [ 1 ] = b ; }
final int schedule [] = desSetKey ( key ) ; MST[NonVoidMethodCallMutator]MSP[] final int out [] = body ( schedule , eSwap0 , eSwap1 ) ; final byte b [] = new byte [ 9 ] ; intToFourBytes ( out [ 0 ] , b , 0 ) ;
c = c >>> 1 | c << 27 ; d = d >>> 1 | d << 27 ; } c &= 0xfffffff ; d &= 0xfffffff ; MST[rv.UOI3Mutator]MSP[]
left = t >>> 1 | t << 31 ; final int results [] = new int [ 2 ] ; permOp ( right , left , 1 , 0x55555555 , results ) ; MST[InlineConstantMutator]MSP[] right = results [ 0 ] ; left = results [ 1 ] ;
u = u ^ u << 16 ^ r ^ sArr [ s ] ; MST[rv.UOI2Mutator]MSP[] int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; t = t >>> 4 | t << 28 ;
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; MST[rv.UOI2Mutator]MSP[] } t = left ; left = right ; right = t ; } t = right ; right = left >>> 1 | left << 31 ;
SKB [ 7 ] [ d >>> 21 & 0xf | d >>> 22 & 0x30 ] ; schedule [ j ++ ] = ( t << 16 | s & 0xffff ) ; MST[rv.CRCR3Mutator]MSP[] s = s >>> 16 | t & 0xffff0000 ;
s = s << 4 | s >>> 28 ; schedule [ j ++ ] = s ; } return schedule ; } private static int fourBytesToInt ( final byte b [] , int offset ) { int value = byteToUnsigned ( b [ offset ++ ] ) ; MST[rv.UOI4Mutator]MSP[]
int c = 0 ; for (; j < 6 ; j ++ ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[] c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) {
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; } t = left ; left = right ; right = t ; } t = right ; right = left >>> 1 | left << 31 ; MST[MathMutator]MSP[]
left = t >>> 1 | t << 31 ; final int results [] = new int [ 2 ] ; permOp ( right , left , 1 , 0x55555555 , results ) ; MST[rv.CRCR2Mutator]MSP[] right = results [ 0 ] ; left = results [ 1 ] ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.OBBN1Mutator]MSP[]
permOp ( d , c , 4 , 0xf0f0f0f , results ) ; d = results [ 0 ] ; c = results [ 1 ] ; c = hPermOp ( c , - 2 , 0xcccc0000 ) ; MST[rv.CRCR1Mutator]MSP[]
for ( int i = 0 ; i < 32 ; i += 4 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[] left = dEncrypt ( left , right , i , eSwap0 , eSwap1 , schedule ) ;
} else if ( ! salt . matches ( lr_2 + B64 . B64T_STRING + lr_3 ) ) { throw new IllegalArgumentException ( lr_4 + salt ) ; MST[ConstructorCallMutator]MSP[] } final StringBuilder buffer = new StringBuilder ( lr_5 ) ; final char charZero = salt . charAt ( 0 ) ;
left = results [ 1 ] ; permOp ( left , right , 16 , 65535 , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 4 , 0xf0f0f0f , results ) ; MST[rv.CRCR5Mutator]MSP[]
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; MST[rv.CRCR6Mutator]MSP[] value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; return value ; }
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[InlineConstantMutator]MSP[]
d = hPermOp ( d , - 2 , 0xcccc0000 ) ; permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ; c = results [ 1 ] ; MST[rv.UOI1Mutator]MSP[]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR5Mutator]MSP[]
d = hPermOp ( d , - 2 , 0xcccc0000 ) ; permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ; c = results [ 1 ] ; MST[rv.UOI4Mutator]MSP[]
permOp ( c , d , 8 , 0xff00ff , results ) ; c = results [ 0 ] ; d = results [ 1 ] ; permOp ( d , c , 1 , 0x55555555 , results ) ; MST[rv.CRCR4Mutator]MSP[] d = results [ 0 ] ;
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; } t = left ; MST[rv.UOI2Mutator]MSP[] left = right ; right = t ; } t = right ; right = left >>> 1 | left << 31 ;
private static void permOp ( int a , int b , final int n , final int m , final int results [] ) { final int t = ( a >>> n ^ b ) & m ; a ^= t << n ; MST[rv.UOI1Mutator]MSP[] b ^= t ;
final int numSaltChars = SALT_CHARS . length ; salt = lr_1 + SALT_CHARS [ randomGenerator . nextInt ( numSaltChars ) ] + MST[experimental.NakedReceiverMutator]MSP[] SALT_CHARS [ randomGenerator . nextInt ( numSaltChars ) ] ;
u = u ^ u << 16 ^ r ^ sArr [ s ] ; MST[MathMutator]MSP[] int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; t = t >>> 4 | t << 28 ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.UOI1Mutator]MSP[]
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) { MST[rv.UOI2Mutator]MSP[]
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; MST[rv.ABSMutator]MSP[] } t = left ; left = right ; right = t ; } t = right ; right = left >>> 1 | left << 31 ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR4Mutator]MSP[]
SKB [ 7 ] [ d >>> 21 & 0xf | d >>> 22 & 0x30 ] ; schedule [ j ++ ] = ( t << 16 | s & 0xffff ) ; MST[rv.OBBN2Mutator]MSP[] s = s >>> 16 | t & 0xffff0000 ;
private static void permOp ( int a , int b , final int n , final int m , final int results [] ) { final int t = ( a >>> n ^ b ) & m ; a ^= t << n ; b ^= t ; MST[rv.UOI4Mutator]MSP[]
left = t >>> 1 | t << 31 ; final int results [] = new int [ 2 ] ; permOp ( right , left , 1 , 0x55555555 , results ) ; MST[rv.CRCR5Mutator]MSP[] right = results [ 0 ] ; left = results [ 1 ] ;
private static void intToFourBytes ( final int iValue , final byte b [] , int offset ) { b [ offset ++ ] = (byte) ( iValue & 0xff ) ; MST[IncrementsMutator]MSP[] b [ offset ++ ] = (byte) ( iValue >>> 8 & 0xff ) ;
final char charOne = salt . charAt ( 1 ) ; buffer . setCharAt ( 0 , charZero ) ; buffer . setCharAt ( 1 , charOne ) ; MST[rv.UOI3Mutator]MSP[] final int eSwap0 = CON_SALT [ charZero ] ; final int eSwap1 = CON_SALT [ charOne ] << 4 ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.OBBN2Mutator]MSP[]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.UOI4Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
left = results [ 1 ] ; permOp ( left , right , 16 , 65535 , results ) ; MST[rv.CRCR1Mutator]MSP[] left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 4 , 0xf0f0f0f , results ) ;
private static int byteToUnsigned ( final byte b ) { final int value = b ; MST[rv.UOI2Mutator]MSP[] return value < 0 ? value + 256 : value ; }
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; MST[rv.CRCR4Mutator]MSP[] return value ; }
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR6Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.CRCR5Mutator]MSP[] c &= 0xfffffff ; int j = 0 ;
b [ offset ++ ] = (byte) ( iValue >>> 16 & 0xff ) ; b [ offset ++ ] = (byte) ( iValue >>> 24 & 0xff ) ; MST[rv.CRCR5Mutator]MSP[] }
public static String crypt ( final byte [] original ) { return crypt ( original , null ) ; } public static String crypt ( final byte [] original , String salt ) { if ( salt == null ) { final ThreadLocalRandom randomGenerator = ThreadLocalRandom . current () ; MST[NonVoidMethodCallMutator]MSP[]
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.UOI3Mutator]MSP[] c &= 0xfffffff ; int j = 0 ;
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { MST[rv.ABSMutator]MSP[] c = c >>> 2 | c << 26 ; d = d >>> 2 | d << 26 ; } else {
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; MST[rv.UOI1Mutator]MSP[] value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; return value ; }
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; c &= 0xfffffff ; MST[rv.CRCR1Mutator]MSP[] int j = 0 ;
s = s << 4 | s >>> 28 ; schedule [ j ++ ] = s ; } return schedule ; MST[NullReturnValsMutator]MSP[] } private static int fourBytesToInt ( final byte b [] , int offset ) { int value = byteToUnsigned ( b [ offset ++ ] ) ;
private static int dEncrypt ( int el , final int r , final int s , final int e0 , final int e1 , final int sArr [] ) { int v = r ^ r >>> 16 ; MST[rv.UOI4Mutator]MSP[] int u = v & e0 ; v &= e1 ;
return crypt ( original . getBytes ( StandardCharsets . UTF_8 ) ) ; MST[NonVoidMethodCallMutator]MSP[] } public static String crypt ( final String original , final String salt ) { return crypt ( original . getBytes ( StandardCharsets . UTF_8 ) , salt ) ; }
left = t >>> 1 | t << 31 ; MST[InlineConstantMutator]MSP[] final int results [] = new int [ 2 ] ; permOp ( right , left , 1 , 0x55555555 , results ) ; right = results [ 0 ] ; left = results [ 1 ] ;
permOp ( left , right , 8 , 0xff00ff , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 2 , 0x33333333 , results ) ; MST[rv.CRCR3Mutator]MSP[] right = results [ 0 ] ;
permOp ( c , d , 8 , 0xff00ff , results ) ; c = results [ 0 ] ; d = results [ 1 ] ; permOp ( d , c , 1 , 0x55555555 , results ) ; MST[InlineConstantMutator]MSP[] d = results [ 0 ] ;
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; MST[rv.UOI2Mutator]MSP[] t = t >>> 4 | t << 28 ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR3Mutator]MSP[]
left = t >>> 1 | t << 31 ; MST[rv.UOI1Mutator]MSP[] final int results [] = new int [ 2 ] ; permOp ( right , left , 1 , 0x55555555 , results ) ; right = results [ 0 ] ; left = results [ 1 ] ;
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; a = a ^ t ^ t >>> 16 - n ; MST[rv.AOD1Mutator]MSP[] return a ; }
final int numSaltChars = SALT_CHARS . length ; salt = lr_1 + SALT_CHARS [ randomGenerator . nextInt ( numSaltChars ) ] + MST[NonVoidMethodCallMutator]MSP[] SALT_CHARS [ randomGenerator . nextInt ( numSaltChars ) ] ;
permOp ( d , c , 4 , 0xf0f0f0f , results ) ; d = results [ 0 ] ; MST[rv.UOI2Mutator]MSP[] c = results [ 1 ] ; c = hPermOp ( c , - 2 , 0xcccc0000 ) ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.OBBN2Mutator]MSP[]
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; } t = left ; left = right ; right = t ; } t = right ; MST[rv.UOI2Mutator]MSP[] right = left >>> 1 | left << 31 ;
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; MST[rv.CRCR1Mutator]MSP[] return value ; }
permOp ( left , right , 8 , 0xff00ff , results ) ; left = results [ 0 ] ; MST[rv.CRCR1Mutator]MSP[] right = results [ 1 ] ; permOp ( right , left , 2 , 0x33333333 , results ) ; right = results [ 0 ] ;
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; d = d >>> 2 | d << 26 ; MST[InlineConstantMutator]MSP[] } else {
final byte key [] = new byte [ 8 ] ; for ( int i = 0 ; i < key . length ; i ++ ) { MST[rv.ABSMutator]MSP[] key [ i ] = 0 ; }
private static int [] body ( final int schedule [] , final int eSwap0 , final int eSwap1 ) { int left = 0 ; int right = 0 ; int t = 0 ; MST[InlineConstantMutator]MSP[] for ( int j = 0 ; j < 25 ; j ++ ) {
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR4Mutator]MSP[]
final int numSaltChars = SALT_CHARS . length ; salt = lr_1 + SALT_CHARS [ randomGenerator . nextInt ( numSaltChars ) ] + MST[rv.UOI4Mutator]MSP[] SALT_CHARS [ randomGenerator . nextInt ( numSaltChars ) ] ;
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; MST[rv.ABSMutator]MSP[] t = t >>> 4 | t << 28 ;
c = c >>> 1 | c << 27 ; d = d >>> 1 | d << 27 ; } c &= 0xfffffff ; MST[rv.ABSMutator]MSP[] d &= 0xfffffff ;
s = s << 4 | s >>> 28 ; MST[rv.OBBN3Mutator]MSP[] schedule [ j ++ ] = s ; } return schedule ; } private static int fourBytesToInt ( final byte b [] , int offset ) { int value = byteToUnsigned ( b [ offset ++ ] ) ;
final int schedule [] = new int [ 32 ] ; MST[InlineConstantMutator]MSP[] int c = fourBytesToInt ( key , 0 ) ; int d = fourBytesToInt ( key , 4 ) ; final int results [] = new int [ 2 ] ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[InlineConstantMutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR4Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
for ( int i = 0 ; i < key . length && i < original . length ; i ++ ) { MST[NegateConditionalsMutator]MSP[] final int iChar = original [ i ] ; key [ i ] = (byte) ( iChar << 1 ) ; }
SPTRANS [ 4 ] [ u >>> 16 & 0x3f ] | SPTRANS [ 6 ] [ u >>> 24 & 0x3f ] ; return el ; MST[rv.UOI2Mutator]MSP[] } private static int [] desSetKey ( final byte key [] ) {
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR3Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
y ++ ; u = 128 ; } buffer . setCharAt ( i , ( char ) COV2CHAR [ c ] ) ; } } return buffer . toString () ; MST[ReturnValsMutator]MSP[] } public static String crypt ( final String original ) {
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; a = a ^ t ^ t >>> 16 - n ; MST[rv.UOI1Mutator]MSP[] return a ; }
left = results [ 1 ] ; permOp ( left , right , 16 , 65535 , results ) ; left = results [ 0 ] ; MST[rv.CRCR6Mutator]MSP[] right = results [ 1 ] ; permOp ( right , left , 4 , 0xf0f0f0f , results ) ;
c = c >>> 1 | c << 27 ; d = d >>> 1 | d << 27 ; MST[rv.OBBN3Mutator]MSP[] } c &= 0xfffffff ; d &= 0xfffffff ;
left = t >>> 1 | t << 31 ; final int results [] = new int [ 2 ] ; permOp ( right , left , 1 , 0x55555555 , results ) ; MST[rv.ABSMutator]MSP[] right = results [ 0 ] ; left = results [ 1 ] ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR1Mutator]MSP[]
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.UOI4Mutator]MSP[]
left = results [ 1 ] ; permOp ( left , right , 16 , 65535 , results ) ; MST[rv.CRCR4Mutator]MSP[] left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 4 , 0xf0f0f0f , results ) ;
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; t = t >>> 4 | t << 28 ; MST[rv.CRCR6Mutator]MSP[]
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; return value ; MST[rv.UOI2Mutator]MSP[] }
final int numSaltChars = SALT_CHARS . length ; salt = lr_1 + SALT_CHARS [ randomGenerator . nextInt ( numSaltChars ) ] + MST[rv.UOI2Mutator]MSP[] SALT_CHARS [ randomGenerator . nextInt ( numSaltChars ) ] ;
d = hPermOp ( d , - 2 , 0xcccc0000 ) ; permOp ( d , c , 1 , 0x55555555 , results ) ; MST[rv.CRCR6Mutator]MSP[] d = results [ 0 ] ; c = results [ 1 ] ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR6Mutator]MSP[]
final byte key [] = new byte [ 8 ] ; for ( int i = 0 ; i < key . length ; i ++ ) { key [ i ] = 0 ; MST[rv.UOI3Mutator]MSP[] }
d = hPermOp ( d , - 2 , 0xcccc0000 ) ; MST[rv.UOI2Mutator]MSP[] permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ; c = results [ 1 ] ;
private static void intToFourBytes ( final int iValue , final byte b [] , int offset ) { b [ offset ++ ] = (byte) ( iValue & 0xff ) ; MST[rv.UOI4Mutator]MSP[] b [ offset ++ ] = (byte) ( iValue >>> 8 & 0xff ) ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.UOI1Mutator]MSP[]
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; a = a ^ t ^ t >>> 16 - n ; MST[rv.CRCR5Mutator]MSP[] return a ; }
permOp ( d , c , 4 , 0xf0f0f0f , results ) ; d = results [ 0 ] ; c = results [ 1 ] ; MST[rv.UOI1Mutator]MSP[] c = hPermOp ( c , - 2 , 0xcccc0000 ) ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.OBBN1Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; } t = left ; left = right ; right = t ; } t = right ; right = left >>> 1 | left << 31 ; MST[rv.CRCR3Mutator]MSP[]
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; MST[rv.CRCR1Mutator]MSP[] t = t >>> 4 | t << 28 ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.OBBN3Mutator]MSP[]
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; MST[rv.UOI1Mutator]MSP[] t = t >>> 4 | t << 28 ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR2Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[InlineConstantMutator]MSP[]
intToFourBytes ( out [ 1 ] , b , 4 ) ; b [ 8 ] = 0 ; MST[rv.CRCR3Mutator]MSP[] int i = 2 ; int y = 0 ; int u = 128 ; for (; i < 13 ; i ++ ) { int j = 0 ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR1Mutator]MSP[]
permOp ( c , d , 8 , 0xff00ff , results ) ; c = results [ 0 ] ; MST[rv.CRCR5Mutator]MSP[] d = results [ 1 ] ; permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ;
y ++ ; u = 128 ; } buffer . setCharAt ( i , ( char ) COV2CHAR [ c ] ) ; MST[rv.ABSMutator]MSP[] } } return buffer . toString () ; } public static String crypt ( final String original ) {
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.OBBN3Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
intToFourBytes ( out [ 1 ] , b , 4 ) ; b [ 8 ] = 0 ; int i = 2 ; int y = 0 ; int u = 128 ; for (; i < 13 ; i ++ ) { MST[NegateConditionalsMutator]MSP[] int j = 0 ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[MathMutator]MSP[]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR6Mutator]MSP[]
permOp ( d , c , 4 , 0xf0f0f0f , results ) ; MST[rv.CRCR6Mutator]MSP[] d = results [ 0 ] ; c = results [ 1 ] ; c = hPermOp ( c , - 2 , 0xcccc0000 ) ;
s = s << 4 | s >>> 28 ; schedule [ j ++ ] = s ; } return schedule ; } private static int fourBytesToInt ( final byte b [] , int offset ) { int value = byteToUnsigned ( b [ offset ++ ] ) ; MST[rv.UOI2Mutator]MSP[]
left = results [ 1 ] ; permOp ( left , right , 16 , 65535 , results ) ; left = results [ 0 ] ; MST[rv.CRCR3Mutator]MSP[] right = results [ 1 ] ; permOp ( right , left , 4 , 0xf0f0f0f , results ) ;
private static void permOp ( int a , int b , final int n , final int m , final int results [] ) { final int t = ( a >>> n ^ b ) & m ; a ^= t << n ; MST[MathMutator]MSP[] b ^= t ;
c = c >>> 1 | c << 27 ; d = d >>> 1 | d << 27 ; } c &= 0xfffffff ; MST[rv.UOI1Mutator]MSP[] d &= 0xfffffff ;
for ( int i = 0 ; i < 32 ; i += 4 ) { left = dEncrypt ( left , right , i , eSwap0 , eSwap1 , schedule ) ; MST[rv.UOI3Mutator]MSP[]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[MathMutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
final char charOne = salt . charAt ( 1 ) ; buffer . setCharAt ( 0 , charZero ) ; buffer . setCharAt ( 1 , charOne ) ; final int eSwap0 = CON_SALT [ charZero ] ; final int eSwap1 = CON_SALT [ charOne ] << 4 ; MST[rv.UOI4Mutator]MSP[]
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR3Mutator]MSP[]
for ( int i = 0 ; i < key . length && i < original . length ; i ++ ) { MST[rv.UOI2Mutator]MSP[] final int iChar = original [ i ] ; key [ i ] = (byte) ( iChar << 1 ) ; }
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; MST[rv.CRCR5Mutator]MSP[] d = d >>> 2 | d << 26 ; } else {
for ( int i = 0 ; i < key . length && i < original . length ; i ++ ) { MST[rv.ROR5Mutator]MSP[] final int iChar = original [ i ] ; key [ i ] = (byte) ( iChar << 1 ) ; }
right = results [ 0 ] ; MST[rv.UOI2Mutator]MSP[] left = results [ 1 ] ; final int out [] = new int [ 2 ] ; out [ 0 ] = left ; out [ 1 ] = right ; return out ; }
c = c >>> 1 | c << 27 ; MST[InlineConstantMutator]MSP[] d = d >>> 1 | d << 27 ; } c &= 0xfffffff ; d &= 0xfffffff ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR5Mutator]MSP[]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.ABSMutator]MSP[]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR4Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
s = s << 4 | s >>> 28 ; schedule [ j ++ ] = s ; MST[rv.UOI1Mutator]MSP[] } return schedule ; } private static int fourBytesToInt ( final byte b [] , int offset ) { int value = byteToUnsigned ( b [ offset ++ ] ) ;
private static void intToFourBytes ( final int iValue , final byte b [] , int offset ) { b [ offset ++ ] = (byte) ( iValue & 0xff ) ; MST[rv.UOI1Mutator]MSP[] b [ offset ++ ] = (byte) ( iValue >>> 8 & 0xff ) ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR5Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; MST[MathMutator]MSP[] value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; return value ; }
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.CRCR6Mutator]MSP[] c &= 0xfffffff ; int j = 0 ;
private static void intToFourBytes ( final int iValue , final byte b [] , int offset ) { b [ offset ++ ] = (byte) ( iValue & 0xff ) ; b [ offset ++ ] = (byte) ( iValue >>> 8 & 0xff ) ; MST[rv.ABSMutator]MSP[]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.UOI3Mutator]MSP[]
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.UOI4Mutator]MSP[]
permOp ( left , right , 8 , 0xff00ff , results ) ; MST[rv.CRCR2Mutator]MSP[] left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 2 , 0x33333333 , results ) ; right = results [ 0 ] ;
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { MST[rv.UOI4Mutator]MSP[] c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) {
int c = 0 ; for (; j < 6 ; j ++ ) { MST[rv.ROR4Mutator]MSP[] c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) {
b [ offset ++ ] = (byte) ( iValue >>> 16 & 0xff ) ; MST[rv.CRCR4Mutator]MSP[] b [ offset ++ ] = (byte) ( iValue >>> 24 & 0xff ) ; }
final char charOne = salt . charAt ( 1 ) ; MST[rv.CRCR4Mutator]MSP[] buffer . setCharAt ( 0 , charZero ) ; buffer . setCharAt ( 1 , charOne ) ; final int eSwap0 = CON_SALT [ charZero ] ; final int eSwap1 = CON_SALT [ charOne ] << 4 ;
final char charOne = salt . charAt ( 1 ) ; buffer . setCharAt ( 0 , charZero ) ; MST[rv.CRCR6Mutator]MSP[] buffer . setCharAt ( 1 , charOne ) ; final int eSwap0 = CON_SALT [ charZero ] ; final int eSwap1 = CON_SALT [ charOne ] << 4 ;
permOp ( left , right , 8 , 0xff00ff , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; MST[rv.UOI1Mutator]MSP[] permOp ( right , left , 2 , 0x33333333 , results ) ; right = results [ 0 ] ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.OBBN1Mutator]MSP[]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR2Mutator]MSP[]
left = t >>> 1 | t << 31 ; final int results [] = new int [ 2 ] ; permOp ( right , left , 1 , 0x55555555 , results ) ; MST[rv.CRCR1Mutator]MSP[] right = results [ 0 ] ; left = results [ 1 ] ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.UOI4Mutator]MSP[]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.OBBN2Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
left = results [ 1 ] ; permOp ( left , right , 16 , 65535 , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; MST[InlineConstantMutator]MSP[] permOp ( right , left , 4 , 0xf0f0f0f , results ) ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.OBBN1Mutator]MSP[]
for ( int i = 0 ; i < key . length && i < original . length ; i ++ ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] final int iChar = original [ i ] ; key [ i ] = (byte) ( iChar << 1 ) ; }
b [ offset ++ ] = (byte) ( iValue >>> 16 & 0xff ) ; b [ offset ++ ] = (byte) ( iValue >>> 24 & 0xff ) ; MST[rv.UOI1Mutator]MSP[] }
for ( int i = 0 ; i < 32 ; i += 4 ) { left = dEncrypt ( left , right , i , eSwap0 , eSwap1 , schedule ) ; MST[rv.UOI2Mutator]MSP[]
right = results [ 0 ] ; left = results [ 1 ] ; final int out [] = new int [ 2 ] ; out [ 0 ] = left ; MST[rv.UOI2Mutator]MSP[] out [ 1 ] = right ; return out ; }
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR3Mutator]MSP[]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR1Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; MST[rv.CRCR2Mutator]MSP[] } u >>>= 1 ; if ( u == 0 ) {
permOp ( d , c , 4 , 0xf0f0f0f , results ) ; d = results [ 0 ] ; c = results [ 1 ] ; c = hPermOp ( c , - 2 , 0xcccc0000 ) ; MST[InlineConstantMutator]MSP[]
for ( int i = 0 ; i < 32 ; i += 4 ) { MST[rv.ROR4Mutator]MSP[] left = dEncrypt ( left , right , i , eSwap0 , eSwap1 , schedule ) ;
right = results [ 0 ] ; left = results [ 1 ] ; final int out [] = new int [ 2 ] ; out [ 0 ] = left ; out [ 1 ] = right ; MST[rv.UOI4Mutator]MSP[] return out ; }
private static int byteToUnsigned ( final byte b ) { final int value = b ; return value < 0 ? value + 256 : value ; MST[rv.UOI3Mutator]MSP[] }
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; a = a ^ t ^ t >>> 16 - n ; MST[InlineConstantMutator]MSP[] return a ; }
private static int byteToUnsigned ( final byte b ) { final int value = b ; return value < 0 ? value + 256 : value ; MST[rv.UOI1Mutator]MSP[] }
permOp ( c , d , 8 , 0xff00ff , results ) ; c = results [ 0 ] ; d = results [ 1 ] ; permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ; MST[rv.CRCR6Mutator]MSP[]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.UOI3Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; d = d >>> 2 | d << 26 ; MST[rv.ABSMutator]MSP[] } else {
for ( int i = 0 ; i < 16 ; i ++ ) { MST[rv.CRCR1Mutator]MSP[] if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; d = d >>> 2 | d << 26 ; } else {
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; MST[rv.UOI1Mutator]MSP[] } t = left ; left = right ; right = t ; } t = right ; right = left >>> 1 | left << 31 ;
final char charOne = salt . charAt ( 1 ) ; buffer . setCharAt ( 0 , charZero ) ; MST[rv.UOI4Mutator]MSP[] buffer . setCharAt ( 1 , charOne ) ; final int eSwap0 = CON_SALT [ charZero ] ; final int eSwap1 = CON_SALT [ charOne ] << 4 ;
right = results [ 0 ] ; left = results [ 1 ] ; final int out [] = new int [ 2 ] ; out [ 0 ] = left ; out [ 1 ] = right ; MST[rv.CRCR6Mutator]MSP[] return out ; }
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.UOI1Mutator]MSP[]
permOp ( c , d , 8 , 0xff00ff , results ) ; c = results [ 0 ] ; d = results [ 1 ] ; permOp ( d , c , 1 , 0x55555555 , results ) ; MST[rv.ABSMutator]MSP[] d = results [ 0 ] ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR3Mutator]MSP[]
results [ 0 ] = a ; results [ 1 ] = b ; MST[rv.CRCR2Mutator]MSP[] }
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR3Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
private static int dEncrypt ( int el , final int r , final int s , final int e0 , final int e1 , final int sArr [] ) { int v = r ^ r >>> 16 ; int u = v & e0 ; MST[rv.ABSMutator]MSP[] v &= e1 ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR4Mutator]MSP[]
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; MST[rv.UOI4Mutator]MSP[] value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; return value ; }
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; MST[InlineConstantMutator]MSP[] t = t >>> 4 | t << 28 ;
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; } u >>>= 1 ; MST[rv.UOI3Mutator]MSP[] if ( u == 0 ) {
SKB [ 7 ] [ d >>> 21 & 0xf | d >>> 22 & 0x30 ] ; schedule [ j ++ ] = ( t << 16 | s & 0xffff ) ; s = s >>> 16 | t & 0xffff0000 ; MST[rv.UOI2Mutator]MSP[]
permOp ( c , d , 8 , 0xff00ff , results ) ; c = results [ 0 ] ; d = results [ 1 ] ; MST[rv.UOI2Mutator]MSP[] permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ;
d = hPermOp ( d , - 2 , 0xcccc0000 ) ; permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ; c = results [ 1 ] ; MST[rv.CRCR6Mutator]MSP[]
permOp ( left , right , 8 , 0xff00ff , results ) ; MST[rv.CRCR3Mutator]MSP[] left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 2 , 0x33333333 , results ) ; right = results [ 0 ] ;
d = hPermOp ( d , - 2 , 0xcccc0000 ) ; permOp ( d , c , 1 , 0x55555555 , results ) ; MST[rv.CRCR2Mutator]MSP[] d = results [ 0 ] ; c = results [ 1 ] ;
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; } t = left ; left = right ; right = t ; } t = right ; right = left >>> 1 | left << 31 ; MST[rv.UOI3Mutator]MSP[]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR4Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
y ++ ; u = 128 ; MST[rv.CRCR4Mutator]MSP[] } buffer . setCharAt ( i , ( char ) COV2CHAR [ c ] ) ; } } return buffer . toString () ; } public static String crypt ( final String original ) {
permOp ( c , d , 8 , 0xff00ff , results ) ; MST[rv.CRCR3Mutator]MSP[] c = results [ 0 ] ; d = results [ 1 ] ; permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[MathMutator]MSP[]
private static void intToFourBytes ( final int iValue , final byte b [] , int offset ) { b [ offset ++ ] = (byte) ( iValue & 0xff ) ; MST[rv.OBBN2Mutator]MSP[] b [ offset ++ ] = (byte) ( iValue >>> 8 & 0xff ) ;
for ( int i = 0 ; i < key . length && i < original . length ; i ++ ) { final int iChar = original [ i ] ; key [ i ] = (byte) ( iChar << 1 ) ; MST[rv.UOI1Mutator]MSP[] }
permOp ( c , d , 8 , 0xff00ff , results ) ; MST[rv.UOI1Mutator]MSP[] c = results [ 0 ] ; d = results [ 1 ] ; permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ;
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; MST[rv.OBBN1Mutator]MSP[] a = a ^ t ^ t >>> 16 - n ; return a ; }
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR2Mutator]MSP[]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR4Mutator]MSP[]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR1Mutator]MSP[]
left = t >>> 1 | t << 31 ; MST[rv.CRCR2Mutator]MSP[] final int results [] = new int [ 2 ] ; permOp ( right , left , 1 , 0x55555555 , results ) ; right = results [ 0 ] ; left = results [ 1 ] ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.ABSMutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
c = c >>> 1 | c << 27 ; MST[rv.UOI2Mutator]MSP[] d = d >>> 1 | d << 27 ; } c &= 0xfffffff ; d &= 0xfffffff ;
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; MST[rv.ABSMutator]MSP[] a = a ^ t ^ t >>> 16 - n ; return a ; }
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[MathMutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; MST[rv.CRCR6Mutator]MSP[] d = d >>> 2 | d << 26 ; } else {
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; MST[rv.CRCR3Mutator]MSP[] value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; return value ; }
s = s << 4 | s >>> 28 ; MST[rv.CRCR1Mutator]MSP[] schedule [ j ++ ] = s ; } return schedule ; } private static int fourBytesToInt ( final byte b [] , int offset ) { int value = byteToUnsigned ( b [ offset ++ ] ) ;
right = results [ 0 ] ; left = results [ 1 ] ; MST[rv.UOI4Mutator]MSP[] final int out [] = new int [ 2 ] ; out [ 0 ] = left ; out [ 1 ] = right ; return out ; }
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR2Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
permOp ( left , right , 8 , 0xff00ff , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 2 , 0x33333333 , results ) ; MST[rv.CRCR4Mutator]MSP[] right = results [ 0 ] ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[MathMutator]MSP[]
c = results [ 1 ] ; MST[rv.UOI3Mutator]MSP[] d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; c &= 0xfffffff ; int j = 0 ;
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; MST[rv.ABSMutator]MSP[] d = d >>> 2 | d << 26 ; } else {
s = s << 4 | s >>> 28 ; schedule [ j ++ ] = s ; MST[rv.UOI3Mutator]MSP[] } return schedule ; } private static int fourBytesToInt ( final byte b [] , int offset ) { int value = byteToUnsigned ( b [ offset ++ ] ) ;
private static int [] body ( final int schedule [] , final int eSwap0 , final int eSwap1 ) { int left = 0 ; int right = 0 ; int t = 0 ; MST[rv.CRCR1Mutator]MSP[] for ( int j = 0 ; j < 25 ; j ++ ) {
u = u ^ u << 16 ^ r ^ sArr [ s ] ; MST[rv.UOI2Mutator]MSP[] int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; t = t >>> 4 | t << 28 ;
intToFourBytes ( out [ 1 ] , b , 4 ) ; b [ 8 ] = 0 ; int i = 2 ; int y = 0 ; int u = 128 ; for (; i < 13 ; i ++ ) { MST[InlineConstantMutator]MSP[] int j = 0 ;
int c = 0 ; MST[rv.CRCR5Mutator]MSP[] for (; j < 6 ; j ++ ) { c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) {
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR3Mutator]MSP[]
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; c &= 0xfffffff ; MST[InlineConstantMutator]MSP[] int j = 0 ;
b [ offset ++ ] = (byte) ( iValue >>> 16 & 0xff ) ; b [ offset ++ ] = (byte) ( iValue >>> 24 & 0xff ) ; MST[InlineConstantMutator]MSP[] }
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; } t = left ; left = right ; MST[rv.UOI2Mutator]MSP[] right = t ; } t = right ; right = left >>> 1 | left << 31 ;
private static void intToFourBytes ( final int iValue , final byte b [] , int offset ) { b [ offset ++ ] = (byte) ( iValue & 0xff ) ; b [ offset ++ ] = (byte) ( iValue >>> 8 & 0xff ) ; MST[rv.UOI3Mutator]MSP[]
} else if ( ! salt . matches ( lr_2 + B64 . B64T_STRING + lr_3 ) ) { throw new IllegalArgumentException ( lr_4 + salt ) ; MST[experimental.NakedReceiverMutator]MSP[] } final StringBuilder buffer = new StringBuilder ( lr_5 ) ; final char charZero = salt . charAt ( 0 ) ;
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; MST[rv.AOR3Mutator]MSP[] a = a ^ t ^ t >>> 16 - n ; return a ; }
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; t = t >>> 4 | t << 28 ; MST[MathMutator]MSP[]
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; MST[rv.OBBN2Mutator]MSP[] value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; return value ; }
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR5Mutator]MSP[]
intToFourBytes ( out [ 1 ] , b , 4 ) ; b [ 8 ] = 0 ; int i = 2 ; int y = 0 ; int u = 128 ; MST[rv.CRCR6Mutator]MSP[] for (; i < 13 ; i ++ ) { int j = 0 ;
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; } t = left ; left = right ; right = t ; } t = right ; right = left >>> 1 | left << 31 ; MST[rv.UOI2Mutator]MSP[]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[MathMutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.OBBN2Mutator]MSP[]
private static int [] body ( final int schedule [] , final int eSwap0 , final int eSwap1 ) { int left = 0 ; int right = 0 ; int t = 0 ; for ( int j = 0 ; j < 25 ; j ++ ) { MST[InlineConstantMutator]MSP[]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.UOI2Mutator]MSP[]
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; c &= 0xfffffff ; MST[rv.UOI1Mutator]MSP[] int j = 0 ;
left = results [ 1 ] ; permOp ( left , right , 16 , 65535 , results ) ; MST[rv.ABSMutator]MSP[] left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 4 , 0xf0f0f0f , results ) ;
left = results [ 1 ] ; permOp ( left , right , 16 , 65535 , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 4 , 0xf0f0f0f , results ) ; MST[rv.CRCR6Mutator]MSP[]
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.OBBN2Mutator]MSP[] c &= 0xfffffff ; int j = 0 ;
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[MathMutator]MSP[] c &= 0xfffffff ; int j = 0 ;
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.ABSMutator]MSP[] c &= 0xfffffff ; int j = 0 ;
for ( int i = 0 ; i < key . length && i < original . length ; i ++ ) { MST[rv.CRCR6Mutator]MSP[] final int iChar = original [ i ] ; key [ i ] = (byte) ( iChar << 1 ) ; }
intToFourBytes ( out [ 1 ] , b , 4 ) ; b [ 8 ] = 0 ; int i = 2 ; int y = 0 ; int u = 128 ; for (; i < 13 ; i ++ ) { MST[rv.UOI1Mutator]MSP[] int j = 0 ;
final int schedule [] = desSetKey ( key ) ; final int out [] = body ( schedule , eSwap0 , eSwap1 ) ; final byte b [] = new byte [ 9 ] ; intToFourBytes ( out [ 0 ] , b , 0 ) ; MST[rv.CRCR3Mutator]MSP[]
left = results [ 1 ] ; MST[rv.UOI2Mutator]MSP[] permOp ( left , right , 16 , 65535 , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 4 , 0xf0f0f0f , results ) ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR2Mutator]MSP[]
private static void intToFourBytes ( final int iValue , final byte b [] , int offset ) { b [ offset ++ ] = (byte) ( iValue & 0xff ) ; MST[experimental.RemoveIncrementsMutator]MSP[] b [ offset ++ ] = (byte) ( iValue >>> 8 & 0xff ) ;
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; MST[rv.AOR3Mutator]MSP[] t = t >>> 4 | t << 28 ;
permOp ( d , c , 4 , 0xf0f0f0f , results ) ; d = results [ 0 ] ; c = results [ 1 ] ; MST[rv.CRCR6Mutator]MSP[] c = hPermOp ( c , - 2 , 0xcccc0000 ) ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[MathMutator]MSP[]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR3Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.UOI3Mutator]MSP[]
left = results [ 1 ] ; permOp ( left , right , 16 , 65535 , results ) ; MST[rv.CRCR5Mutator]MSP[] left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 4 , 0xf0f0f0f , results ) ;
private static void permOp ( int a , int b , final int n , final int m , final int results [] ) { final int t = ( a >>> n ^ b ) & m ; MST[rv.ABSMutator]MSP[] a ^= t << n ; b ^= t ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.ABSMutator]MSP[]
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; a = a ^ t ^ t >>> 16 - n ; MST[rv.UOI3Mutator]MSP[] return a ; }
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR6Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
final byte key [] = new byte [ 8 ] ; MST[rv.CRCR3Mutator]MSP[] for ( int i = 0 ; i < key . length ; i ++ ) { key [ i ] = 0 ; }
permOp ( d , c , 4 , 0xf0f0f0f , results ) ; MST[rv.CRCR2Mutator]MSP[] d = results [ 0 ] ; c = results [ 1 ] ; c = hPermOp ( c , - 2 , 0xcccc0000 ) ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR2Mutator]MSP[]
left = results [ 1 ] ; permOp ( left , right , 16 , 65535 , results ) ; left = results [ 0 ] ; MST[rv.UOI1Mutator]MSP[] right = results [ 1 ] ; permOp ( right , left , 4 , 0xf0f0f0f , results ) ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR4Mutator]MSP[]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.ABSMutator]MSP[]
d = hPermOp ( d , - 2 , 0xcccc0000 ) ; MST[rv.CRCR5Mutator]MSP[] permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ; c = results [ 1 ] ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.UOI2Mutator]MSP[]
private static void permOp ( int a , int b , final int n , final int m , final int results [] ) { final int t = ( a >>> n ^ b ) & m ; MST[rv.UOI2Mutator]MSP[] a ^= t << n ; b ^= t ;
permOp ( left , right , 8 , 0xff00ff , results ) ; MST[VoidMethodCallMutator]MSP[] left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 2 , 0x33333333 , results ) ; right = results [ 0 ] ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR5Mutator]MSP[]
private static void permOp ( int a , int b , final int n , final int m , final int results [] ) { final int t = ( a >>> n ^ b ) & m ; MST[rv.UOI3Mutator]MSP[] a ^= t << n ; b ^= t ;
for ( int i = 0 ; i < 16 ; i ++ ) { MST[IncrementsMutator]MSP[] if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; d = d >>> 2 | d << 26 ; } else {
for ( int i = 0 ; i < key . length && i < original . length ; i ++ ) { final int iChar = original [ i ] ; key [ i ] = (byte) ( iChar << 1 ) ; MST[InlineConstantMutator]MSP[] }
c = c >>> 1 | c << 27 ; d = d >>> 1 | d << 27 ; MST[rv.CRCR1Mutator]MSP[] } c &= 0xfffffff ; d &= 0xfffffff ;
left = results [ 1 ] ; permOp ( left , right , 16 , 65535 , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; MST[rv.UOI3Mutator]MSP[] permOp ( right , left , 4 , 0xf0f0f0f , results ) ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.OBBN1Mutator]MSP[]
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.CRCR3Mutator]MSP[] c &= 0xfffffff ; int j = 0 ;
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.CRCR5Mutator]MSP[] c &= 0xfffffff ; int j = 0 ;
for ( int i = 0 ; i < key . length && i < original . length ; i ++ ) { MST[NegateConditionalsMutator]MSP[] final int iChar = original [ i ] ; key [ i ] = (byte) ( iChar << 1 ) ; }
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.UOI4Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
permOp ( d , c , 4 , 0xf0f0f0f , results ) ; d = results [ 0 ] ; c = results [ 1 ] ; c = hPermOp ( c , - 2 , 0xcccc0000 ) ; MST[rv.UOI1Mutator]MSP[]
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; MST[rv.UOI1Mutator]MSP[] if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) {
d = hPermOp ( d , - 2 , 0xcccc0000 ) ; permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ; MST[rv.CRCR1Mutator]MSP[] c = results [ 1 ] ;
permOp ( c , d , 8 , 0xff00ff , results ) ; c = results [ 0 ] ; MST[rv.UOI2Mutator]MSP[] d = results [ 1 ] ; permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ;
permOp ( left , right , 8 , 0xff00ff , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 2 , 0x33333333 , results ) ; MST[rv.UOI1Mutator]MSP[] right = results [ 0 ] ;
left = results [ 1 ] ; permOp ( left , right , 16 , 65535 , results ) ; MST[InlineConstantMutator]MSP[] left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 4 , 0xf0f0f0f , results ) ;
left = t >>> 1 | t << 31 ; final int results [] = new int [ 2 ] ; permOp ( right , left , 1 , 0x55555555 , results ) ; MST[rv.UOI3Mutator]MSP[] right = results [ 0 ] ; left = results [ 1 ] ;
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; MST[rv.UOI4Mutator]MSP[] } t = left ; left = right ; right = t ; } t = right ; right = left >>> 1 | left << 31 ;
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; a = a ^ t ^ t >>> 16 - n ; return a ; MST[ReturnValsMutator]MSP[] }
final byte key [] = new byte [ 8 ] ; for ( int i = 0 ; i < key . length ; i ++ ) { MST[rv.UOI3Mutator]MSP[] key [ i ] = 0 ; }
c = c >>> 1 | c << 27 ; MST[MathMutator]MSP[] d = d >>> 1 | d << 27 ; } c &= 0xfffffff ; d &= 0xfffffff ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.OBBN3Mutator]MSP[]
intToFourBytes ( out [ 1 ] , b , 4 ) ; MST[rv.CRCR2Mutator]MSP[] b [ 8 ] = 0 ; int i = 2 ; int y = 0 ; int u = 128 ; for (; i < 13 ; i ++ ) { int j = 0 ;
left = results [ 1 ] ; permOp ( left , right , 16 , 65535 , results ) ; MST[rv.UOI2Mutator]MSP[] left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 4 , 0xf0f0f0f , results ) ;
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; MST[InlineConstantMutator]MSP[] return value ; }
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.UOI2Mutator]MSP[]
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; MST[rv.UOI3Mutator]MSP[] t = t >>> 4 | t << 28 ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR3Mutator]MSP[]
SPTRANS [ 4 ] [ u >>> 16 & 0x3f ] | SPTRANS [ 6 ] [ u >>> 24 & 0x3f ] ; return el ; MST[rv.UOI1Mutator]MSP[] } private static int [] desSetKey ( final byte key [] ) {
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR6Mutator]MSP[]
SKB [ 7 ] [ d >>> 21 & 0xf | d >>> 22 & 0x30 ] ; schedule [ j ++ ] = ( t << 16 | s & 0xffff ) ; MST[rv.OBBN3Mutator]MSP[] s = s >>> 16 | t & 0xffff0000 ;
private static int byteToUnsigned ( final byte b ) { final int value = b ; return value < 0 ? value + 256 : value ; MST[rv.ROR3Mutator]MSP[] }
permOp ( c , d , 8 , 0xff00ff , results ) ; c = results [ 0 ] ; d = results [ 1 ] ; permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ; MST[rv.CRCR3Mutator]MSP[]
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; MST[rv.UOI1Mutator]MSP[] } t = left ; left = right ; right = t ; } t = right ; right = left >>> 1 | left << 31 ;
c = c >>> 1 | c << 27 ; MST[rv.UOI3Mutator]MSP[] d = d >>> 1 | d << 27 ; } c &= 0xfffffff ; d &= 0xfffffff ;
y ++ ; u = 128 ; } buffer . setCharAt ( i , ( char ) COV2CHAR [ c ] ) ; MST[rv.UOI3Mutator]MSP[] } } return buffer . toString () ; } public static String crypt ( final String original ) {
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; t = t >>> 4 | t << 28 ; MST[rv.CRCR4Mutator]MSP[]
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; t = t >>> 4 | t << 28 ; MST[rv.CRCR3Mutator]MSP[]
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; MST[rv.UOI4Mutator]MSP[] a = a ^ t ^ t >>> 16 - n ; return a ; }
for ( int i = 0 ; i < 32 ; i += 4 ) { left = dEncrypt ( left , right , i , eSwap0 , eSwap1 , schedule ) ; MST[NonVoidMethodCallMutator]MSP[]
left = t >>> 1 | t << 31 ; final int results [] = new int [ 2 ] ; MST[rv.CRCR6Mutator]MSP[] permOp ( right , left , 1 , 0x55555555 , results ) ; right = results [ 0 ] ; left = results [ 1 ] ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[InlineConstantMutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
b [ offset ++ ] = (byte) ( iValue >>> 16 & 0xff ) ; b [ offset ++ ] = (byte) ( iValue >>> 24 & 0xff ) ; MST[MathMutator]MSP[] }
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; a = a ^ t ^ t >>> 16 - n ; MST[rv.ABSMutator]MSP[] return a ; }
SKB [ 7 ] [ d >>> 21 & 0xf | d >>> 22 & 0x30 ] ; schedule [ j ++ ] = ( t << 16 | s & 0xffff ) ; s = s >>> 16 | t & 0xffff0000 ; MST[MathMutator]MSP[]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR1Mutator]MSP[]
for ( int i = 0 ; i < key . length && i < original . length ; i ++ ) { MST[rv.ROR3Mutator]MSP[] final int iChar = original [ i ] ; key [ i ] = (byte) ( iChar << 1 ) ; }
private static int [] body ( final int schedule [] , final int eSwap0 , final int eSwap1 ) { int left = 0 ; int right = 0 ; int t = 0 ; for ( int j = 0 ; j < 25 ; j ++ ) { MST[rv.CRCR6Mutator]MSP[]
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR1Mutator]MSP[]
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; MST[rv.ABSMutator]MSP[] value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; return value ; }
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.UOI4Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
d = hPermOp ( d , - 2 , 0xcccc0000 ) ; MST[rv.UOI1Mutator]MSP[] permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ; c = results [ 1 ] ;
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) { MST[rv.ROR1Mutator]MSP[]
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR4Mutator]MSP[]
private static void permOp ( int a , int b , final int n , final int m , final int results [] ) { final int t = ( a >>> n ^ b ) & m ; MST[rv.UOI2Mutator]MSP[] a ^= t << n ; b ^= t ;
private static int dEncrypt ( int el , final int r , final int s , final int e0 , final int e1 , final int sArr [] ) { int v = r ^ r >>> 16 ; int u = v & e0 ; v &= e1 ; MST[rv.UOI2Mutator]MSP[]
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; } t = left ; left = right ; right = t ; } t = right ; right = left >>> 1 | left << 31 ; MST[rv.CRCR2Mutator]MSP[]
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; MST[rv.UOI1Mutator]MSP[] return value ; }
intToFourBytes ( out [ 1 ] , b , 4 ) ; MST[rv.UOI2Mutator]MSP[] b [ 8 ] = 0 ; int i = 2 ; int y = 0 ; int u = 128 ; for (; i < 13 ; i ++ ) { int j = 0 ;
left = results [ 1 ] ; permOp ( left , right , 16 , 65535 , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 4 , 0xf0f0f0f , results ) ; MST[rv.UOI3Mutator]MSP[]
permOp ( c , d , 8 , 0xff00ff , results ) ; c = results [ 0 ] ; d = results [ 1 ] ; permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ; MST[rv.UOI3Mutator]MSP[]
c = c >>> 1 | c << 27 ; d = d >>> 1 | d << 27 ; } c &= 0xfffffff ; d &= 0xfffffff ; MST[rv.ABSMutator]MSP[]
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.OBBN1Mutator]MSP[]
s = s << 4 | s >>> 28 ; schedule [ j ++ ] = s ; } return schedule ; } private static int fourBytesToInt ( final byte b [] , int offset ) { int value = byteToUnsigned ( b [ offset ++ ] ) ; MST[rv.ABSMutator]MSP[]
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[MathMutator]MSP[]
private static int [] body ( final int schedule [] , final int eSwap0 , final int eSwap1 ) { int left = 0 ; MST[rv.CRCR6Mutator]MSP[] int right = 0 ; int t = 0 ; for ( int j = 0 ; j < 25 ; j ++ ) {
final char charOne = salt . charAt ( 1 ) ; buffer . setCharAt ( 0 , charZero ) ; buffer . setCharAt ( 1 , charOne ) ; MST[rv.CRCR4Mutator]MSP[] final int eSwap0 = CON_SALT [ charZero ] ; final int eSwap1 = CON_SALT [ charOne ] << 4 ;
permOp ( left , right , 8 , 0xff00ff , results ) ; MST[rv.CRCR1Mutator]MSP[] left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 2 , 0x33333333 , results ) ; right = results [ 0 ] ;
permOp ( d , c , 4 , 0xf0f0f0f , results ) ; d = results [ 0 ] ; MST[rv.UOI1Mutator]MSP[] c = results [ 1 ] ; c = hPermOp ( c , - 2 , 0xcccc0000 ) ;
int c = 0 ; for (; j < 6 ; j ++ ) { MST[rv.ROR5Mutator]MSP[] c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) {
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR6Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR2Mutator]MSP[]
permOp ( c , d , 8 , 0xff00ff , results ) ; MST[rv.CRCR4Mutator]MSP[] c = results [ 0 ] ; d = results [ 1 ] ; permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ;
d = hPermOp ( d , - 2 , 0xcccc0000 ) ; permOp ( d , c , 1 , 0x55555555 , results ) ; MST[rv.CRCR3Mutator]MSP[] d = results [ 0 ] ; c = results [ 1 ] ;
final int schedule [] = new int [ 32 ] ; int c = fourBytesToInt ( key , 0 ) ; int d = fourBytesToInt ( key , 4 ) ; final int results [] = new int [ 2 ] ; MST[rv.CRCR5Mutator]MSP[]
permOp ( d , c , 4 , 0xf0f0f0f , results ) ; MST[rv.UOI2Mutator]MSP[] d = results [ 0 ] ; c = results [ 1 ] ; c = hPermOp ( c , - 2 , 0xcccc0000 ) ;
results [ 0 ] = a ; results [ 1 ] = b ; MST[rv.UOI1Mutator]MSP[] }
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.UOI4Mutator]MSP[]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[MathMutator]MSP[]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.OBBN1Mutator]MSP[]
b [ offset ++ ] = (byte) ( iValue >>> 16 & 0xff ) ; b [ offset ++ ] = (byte) ( iValue >>> 24 & 0xff ) ; MST[rv.UOI3Mutator]MSP[] }
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR5Mutator]MSP[]
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; MST[rv.CRCR3Mutator]MSP[] value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; return value ; }
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; c &= 0xfffffff ; MST[rv.UOI3Mutator]MSP[] int j = 0 ;
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; MST[rv.CRCR5Mutator]MSP[] } u >>>= 1 ; if ( u == 0 ) {
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; MST[rv.UOI1Mutator]MSP[] t = t >>> 4 | t << 28 ;
for ( int i = 0 ; i < 32 ; i += 4 ) { MST[rv.UOI4Mutator]MSP[] left = dEncrypt ( left , right , i , eSwap0 , eSwap1 , schedule ) ;
for ( int i = 0 ; i < 32 ; i += 4 ) { MST[rv.ROR1Mutator]MSP[] left = dEncrypt ( left , right , i , eSwap0 , eSwap1 , schedule ) ;
for ( int i = 0 ; i < 32 ; i += 4 ) { left = dEncrypt ( left , right , i , eSwap0 , eSwap1 , schedule ) ; MST[rv.ABSMutator]MSP[]
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; MST[rv.ABSMutator]MSP[] t = t >>> 4 | t << 28 ;
permOp ( c , d , 8 , 0xff00ff , results ) ; c = results [ 0 ] ; d = results [ 1 ] ; permOp ( d , c , 1 , 0x55555555 , results ) ; MST[rv.CRCR5Mutator]MSP[] d = results [ 0 ] ;
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; a = a ^ t ^ t >>> 16 - n ; MST[rv.UOI2Mutator]MSP[] return a ; }
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; c &= 0xfffffff ; MST[rv.OBBN1Mutator]MSP[] int j = 0 ;
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; a = a ^ t ^ t >>> 16 - n ; MST[rv.UOI3Mutator]MSP[] return a ; }
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; MST[rv.CRCR2Mutator]MSP[] d = d >>> 2 | d << 26 ; } else {
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; MST[rv.CRCR3Mutator]MSP[] d = d >>> 2 | d << 26 ; } else {
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; d = d >>> 2 | d << 26 ; MST[rv.CRCR4Mutator]MSP[] } else {
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.OBBN2Mutator]MSP[]
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; c &= 0xfffffff ; int j = 0 ; MST[rv.CRCR1Mutator]MSP[]
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; d = d >>> 2 | d << 26 ; MST[rv.CRCR5Mutator]MSP[] } else {
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; MST[MathMutator]MSP[] t = t >>> 4 | t << 28 ;
final byte key [] = new byte [ 8 ] ; for ( int i = 0 ; i < key . length ; i ++ ) { key [ i ] = 0 ; MST[rv.UOI1Mutator]MSP[] }
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR1Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.UOI4Mutator]MSP[]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR2Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR6Mutator]MSP[]
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.UOI2Mutator]MSP[]
final int schedule [] = new int [ 32 ] ; MST[rv.CRCR5Mutator]MSP[] int c = fourBytesToInt ( key , 0 ) ; int d = fourBytesToInt ( key , 4 ) ; final int results [] = new int [ 2 ] ;
final int schedule [] = new int [ 32 ] ; int c = fourBytesToInt ( key , 0 ) ; MST[InlineConstantMutator]MSP[] int d = fourBytesToInt ( key , 4 ) ; final int results [] = new int [ 2 ] ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR5Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
permOp ( left , right , 8 , 0xff00ff , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 2 , 0x33333333 , results ) ; MST[rv.CRCR2Mutator]MSP[] right = results [ 0 ] ;
permOp ( left , right , 8 , 0xff00ff , results ) ; MST[rv.UOI4Mutator]MSP[] left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 2 , 0x33333333 , results ) ; right = results [ 0 ] ;
permOp ( d , c , 4 , 0xf0f0f0f , results ) ; d = results [ 0 ] ; c = results [ 1 ] ; c = hPermOp ( c , - 2 , 0xcccc0000 ) ; MST[rv.UOI3Mutator]MSP[]
private static int byteToUnsigned ( final byte b ) { final int value = b ; return value < 0 ? value + 256 : value ; MST[rv.AOD1Mutator]MSP[] }
permOp ( c , d , 8 , 0xff00ff , results ) ; c = results [ 0 ] ; d = results [ 1 ] ; permOp ( d , c , 1 , 0x55555555 , results ) ; MST[rv.UOI1Mutator]MSP[] d = results [ 0 ] ;
permOp ( c , d , 8 , 0xff00ff , results ) ; c = results [ 0 ] ; d = results [ 1 ] ; permOp ( d , c , 1 , 0x55555555 , results ) ; MST[rv.UOI4Mutator]MSP[] d = results [ 0 ] ;
permOp ( d , c , 4 , 0xf0f0f0f , results ) ; MST[rv.ABSMutator]MSP[] d = results [ 0 ] ; c = results [ 1 ] ; c = hPermOp ( c , - 2 , 0xcccc0000 ) ;
private static void intToFourBytes ( final int iValue , final byte b [] , int offset ) { b [ offset ++ ] = (byte) ( iValue & 0xff ) ; MST[rv.OBBN1Mutator]MSP[] b [ offset ++ ] = (byte) ( iValue >>> 8 & 0xff ) ;
private static void intToFourBytes ( final int iValue , final byte b [] , int offset ) { b [ offset ++ ] = (byte) ( iValue & 0xff ) ; MST[MathMutator]MSP[] b [ offset ++ ] = (byte) ( iValue >>> 8 & 0xff ) ;
final int numSaltChars = SALT_CHARS . length ; salt = lr_1 + SALT_CHARS [ randomGenerator . nextInt ( numSaltChars ) ] + MST[rv.ABSMutator]MSP[] SALT_CHARS [ randomGenerator . nextInt ( numSaltChars ) ] ;
private static int [] body ( final int schedule [] , final int eSwap0 , final int eSwap1 ) { int left = 0 ; int right = 0 ; int t = 0 ; for ( int j = 0 ; j < 25 ; j ++ ) { MST[rv.UOI1Mutator]MSP[]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR4Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
u = u ^ u << 16 ^ r ^ sArr [ s ] ; MST[rv.UOI1Mutator]MSP[] int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; t = t >>> 4 | t << 28 ;
c = c >>> 1 | c << 27 ; d = d >>> 1 | d << 27 ; } c &= 0xfffffff ; MST[rv.CRCR5Mutator]MSP[] d &= 0xfffffff ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.OBBN2Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
SKB [ 7 ] [ d >>> 21 & 0xf | d >>> 22 & 0x30 ] ; schedule [ j ++ ] = ( t << 16 | s & 0xffff ) ; s = s >>> 16 | t & 0xffff0000 ; MST[rv.OBBN2Mutator]MSP[]
for ( int i = 0 ; i < 16 ; i ++ ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[] if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; d = d >>> 2 | d << 26 ; } else {
s = s << 4 | s >>> 28 ; schedule [ j ++ ] = s ; } return schedule ; } private static int fourBytesToInt ( final byte b [] , int offset ) { int value = byteToUnsigned ( b [ offset ++ ] ) ; MST[rv.UOI2Mutator]MSP[]
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; } u >>>= 1 ; MST[rv.CRCR6Mutator]MSP[] if ( u == 0 ) {
permOp ( c , d , 8 , 0xff00ff , results ) ; c = results [ 0 ] ; d = results [ 1 ] ; MST[rv.CRCR4Mutator]MSP[] permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ;
for ( int i = 0 ; i < 32 ; i += 4 ) { left = dEncrypt ( left , right , i , eSwap0 , eSwap1 , schedule ) ; MST[rv.UOI2Mutator]MSP[]
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[InlineConstantMutator]MSP[]
int c = 0 ; for (; j < 6 ; j ++ ) { MST[NegateConditionalsMutator]MSP[] c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) {
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR2Mutator]MSP[]
permOp ( c , d , 8 , 0xff00ff , results ) ; MST[rv.UOI3Mutator]MSP[] c = results [ 0 ] ; d = results [ 1 ] ; permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ;
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; MST[MathMutator]MSP[] a = a ^ t ^ t >>> 16 - n ; return a ; }
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; MST[experimental.RemoveIncrementsMutator]MSP[] value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; return value ; }
left = t >>> 1 | t << 31 ; final int results [] = new int [ 2 ] ; permOp ( right , left , 1 , 0x55555555 , results ) ; right = results [ 0 ] ; MST[rv.ABSMutator]MSP[] left = results [ 1 ] ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.OBBN2Mutator]MSP[]
y ++ ; u = 128 ; } buffer . setCharAt ( i , ( char ) COV2CHAR [ c ] ) ; MST[rv.UOI4Mutator]MSP[] } } return buffer . toString () ; } public static String crypt ( final String original ) {
left = t >>> 1 | t << 31 ; MST[rv.CRCR4Mutator]MSP[] final int results [] = new int [ 2 ] ; permOp ( right , left , 1 , 0x55555555 , results ) ; right = results [ 0 ] ; left = results [ 1 ] ;
permOp ( left , right , 8 , 0xff00ff , results ) ; left = results [ 0 ] ; MST[rv.UOI3Mutator]MSP[] right = results [ 1 ] ; permOp ( right , left , 2 , 0x33333333 , results ) ; right = results [ 0 ] ;
c = results [ 1 ] ; MST[rv.CRCR5Mutator]MSP[] d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; c &= 0xfffffff ; int j = 0 ;
u = u ^ u << 16 ^ r ^ sArr [ s ] ; MST[rv.UOI4Mutator]MSP[] int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; t = t >>> 4 | t << 28 ;
d = hPermOp ( d , - 2 , 0xcccc0000 ) ; permOp ( d , c , 1 , 0x55555555 , results ) ; MST[rv.UOI2Mutator]MSP[] d = results [ 0 ] ; c = results [ 1 ] ;
SKB [ 7 ] [ d >>> 21 & 0xf | d >>> 22 & 0x30 ] ; schedule [ j ++ ] = ( t << 16 | s & 0xffff ) ; MST[rv.UOI4Mutator]MSP[] s = s >>> 16 | t & 0xffff0000 ;
private static void permOp ( int a , int b , final int n , final int m , final int results [] ) { final int t = ( a >>> n ^ b ) & m ; a ^= t << n ; b ^= t ; MST[rv.ABSMutator]MSP[]
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { MST[rv.ROR4Mutator]MSP[] c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) {
final char charOne = salt . charAt ( 1 ) ; buffer . setCharAt ( 0 , charZero ) ; buffer . setCharAt ( 1 , charOne ) ; final int eSwap0 = CON_SALT [ charZero ] ; final int eSwap1 = CON_SALT [ charOne ] << 4 ; MST[rv.CRCR3Mutator]MSP[]
final int schedule [] = desSetKey ( key ) ; final int out [] = body ( schedule , eSwap0 , eSwap1 ) ; MST[ArgumentPropagationMutator]MSP[] final byte b [] = new byte [ 9 ] ; intToFourBytes ( out [ 0 ] , b , 0 ) ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR3Mutator]MSP[]
left = t >>> 1 | t << 31 ; MST[rv.CRCR3Mutator]MSP[] final int results [] = new int [ 2 ] ; permOp ( right , left , 1 , 0x55555555 , results ) ; right = results [ 0 ] ; left = results [ 1 ] ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.UOI2Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
intToFourBytes ( out [ 1 ] , b , 4 ) ; b [ 8 ] = 0 ; int i = 2 ; int y = 0 ; int u = 128 ; for (; i < 13 ; i ++ ) { MST[rv.CRCR1Mutator]MSP[] int j = 0 ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.ABSMutator]MSP[]
permOp ( left , right , 8 , 0xff00ff , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 2 , 0x33333333 , results ) ; MST[rv.CRCR5Mutator]MSP[] right = results [ 0 ] ;
private static int dEncrypt ( int el , final int r , final int s , final int e0 , final int e1 , final int sArr [] ) { int v = r ^ r >>> 16 ; int u = v & e0 ; MST[rv.UOI1Mutator]MSP[] v &= e1 ;
private static void permOp ( int a , int b , final int n , final int m , final int results [] ) { final int t = ( a >>> n ^ b ) & m ; a ^= t << n ; MST[rv.UOI4Mutator]MSP[] b ^= t ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.ABSMutator]MSP[]
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { MST[rv.UOI4Mutator]MSP[] c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) {
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { MST[rv.UOI1Mutator]MSP[] c = c >>> 2 | c << 26 ; d = d >>> 2 | d << 26 ; } else {
final int schedule [] = desSetKey ( key ) ; final int out [] = body ( schedule , eSwap0 , eSwap1 ) ; MST[rv.UOI1Mutator]MSP[] final byte b [] = new byte [ 9 ] ; intToFourBytes ( out [ 0 ] , b , 0 ) ;
permOp ( left , right , 8 , 0xff00ff , results ) ; MST[rv.CRCR4Mutator]MSP[] left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 2 , 0x33333333 , results ) ; right = results [ 0 ] ;
private static void intToFourBytes ( final int iValue , final byte b [] , int offset ) { b [ offset ++ ] = (byte) ( iValue & 0xff ) ; b [ offset ++ ] = (byte) ( iValue >>> 8 & 0xff ) ; MST[rv.CRCR2Mutator]MSP[]
permOp ( c , d , 8 , 0xff00ff , results ) ; c = results [ 0 ] ; MST[rv.ABSMutator]MSP[] d = results [ 1 ] ; permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ;
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; MST[rv.UOI2Mutator]MSP[] value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; return value ; }
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { MST[rv.UOI4Mutator]MSP[] c = c >>> 2 | c << 26 ; d = d >>> 2 | d << 26 ; } else {
for ( int i = 0 ; i < 16 ; i ++ ) { MST[InlineConstantMutator]MSP[] if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; d = d >>> 2 | d << 26 ; } else {
private static void intToFourBytes ( final int iValue , final byte b [] , int offset ) { b [ offset ++ ] = (byte) ( iValue & 0xff ) ; b [ offset ++ ] = (byte) ( iValue >>> 8 & 0xff ) ; MST[rv.CRCR5Mutator]MSP[]
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.CRCR2Mutator]MSP[] c &= 0xfffffff ; int j = 0 ;
intToFourBytes ( out [ 1 ] , b , 4 ) ; b [ 8 ] = 0 ; int i = 2 ; MST[rv.CRCR2Mutator]MSP[] int y = 0 ; int u = 128 ; for (; i < 13 ; i ++ ) { int j = 0 ;
SKB [ 7 ] [ d >>> 21 & 0xf | d >>> 22 & 0x30 ] ; schedule [ j ++ ] = ( t << 16 | s & 0xffff ) ; MST[rv.UOI1Mutator]MSP[] s = s >>> 16 | t & 0xffff0000 ;
private static int [] body ( final int schedule [] , final int eSwap0 , final int eSwap1 ) { int left = 0 ; int right = 0 ; int t = 0 ; MST[rv.CRCR3Mutator]MSP[] for ( int j = 0 ; j < 25 ; j ++ ) {
private static int dEncrypt ( int el , final int r , final int s , final int e0 , final int e1 , final int sArr [] ) { int v = r ^ r >>> 16 ; MST[MathMutator]MSP[] int u = v & e0 ; v &= e1 ;
for ( int i = 0 ; i < 16 ; i ++ ) { MST[rv.UOI2Mutator]MSP[] if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; d = d >>> 2 | d << 26 ; } else {
intToFourBytes ( out [ 1 ] , b , 4 ) ; b [ 8 ] = 0 ; int i = 2 ; MST[rv.CRCR5Mutator]MSP[] int y = 0 ; int u = 128 ; for (; i < 13 ; i ++ ) { int j = 0 ;
permOp ( left , right , 8 , 0xff00ff , results ) ; left = results [ 0 ] ; MST[rv.CRCR6Mutator]MSP[] right = results [ 1 ] ; permOp ( right , left , 2 , 0x33333333 , results ) ; right = results [ 0 ] ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[MathMutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; MST[rv.CRCR3Mutator]MSP[] a = a ^ t ^ t >>> 16 - n ; return a ; }
left = t >>> 1 | t << 31 ; final int results [] = new int [ 2 ] ; permOp ( right , left , 1 , 0x55555555 , results ) ; right = results [ 0 ] ; MST[rv.CRCR5Mutator]MSP[] left = results [ 1 ] ;
left = t >>> 1 | t << 31 ; final int results [] = new int [ 2 ] ; permOp ( right , left , 1 , 0x55555555 , results ) ; MST[rv.CRCR3Mutator]MSP[] right = results [ 0 ] ; left = results [ 1 ] ;
public static String crypt ( final byte [] original ) { return crypt ( original , null ) ; } public static String crypt ( final byte [] original , String salt ) { if ( salt == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] final ThreadLocalRandom randomGenerator = ThreadLocalRandom . current () ;
int c = 0 ; for (; j < 6 ; j ++ ) { MST[rv.ROR2Mutator]MSP[] c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) {
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[InlineConstantMutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
final int schedule [] = desSetKey ( key ) ; final int out [] = body ( schedule , eSwap0 , eSwap1 ) ; MST[rv.ABSMutator]MSP[] final byte b [] = new byte [ 9 ] ; intToFourBytes ( out [ 0 ] , b , 0 ) ;
permOp ( left , right , 8 , 0xff00ff , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 2 , 0x33333333 , results ) ; right = results [ 0 ] ; MST[rv.UOI4Mutator]MSP[]
permOp ( c , d , 8 , 0xff00ff , results ) ; c = results [ 0 ] ; d = results [ 1 ] ; permOp ( d , c , 1 , 0x55555555 , results ) ; MST[rv.CRCR1Mutator]MSP[] d = results [ 0 ] ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR1Mutator]MSP[]
left = t >>> 1 | t << 31 ; MST[rv.CRCR1Mutator]MSP[] final int results [] = new int [ 2 ] ; permOp ( right , left , 1 , 0x55555555 , results ) ; right = results [ 0 ] ; left = results [ 1 ] ;
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) { MST[rv.ROR4Mutator]MSP[]
permOp ( d , c , 4 , 0xf0f0f0f , results ) ; d = results [ 0 ] ; c = results [ 1 ] ; c = hPermOp ( c , - 2 , 0xcccc0000 ) ; MST[rv.CRCR4Mutator]MSP[]
d = hPermOp ( d , - 2 , 0xcccc0000 ) ; MST[rv.CRCR6Mutator]MSP[] permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ; c = results [ 1 ] ;
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; MST[NonVoidMethodCallMutator]MSP[] return value ; }
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { MST[rv.ROR1Mutator]MSP[] c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) {
permOp ( d , c , 4 , 0xf0f0f0f , results ) ; MST[rv.CRCR3Mutator]MSP[] d = results [ 0 ] ; c = results [ 1 ] ; c = hPermOp ( c , - 2 , 0xcccc0000 ) ;
private static int byteToUnsigned ( final byte b ) { final int value = b ; return value < 0 ? value + 256 : value ; MST[rv.ABSMutator]MSP[] }
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.UOI3Mutator]MSP[]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR2Mutator]MSP[]
private static void permOp ( int a , int b , final int n , final int m , final int results [] ) { final int t = ( a >>> n ^ b ) & m ; MST[rv.ABSMutator]MSP[] a ^= t << n ; b ^= t ;
private static int dEncrypt ( int el , final int r , final int s , final int e0 , final int e1 , final int sArr [] ) { int v = r ^ r >>> 16 ; int u = v & e0 ; v &= e1 ; MST[rv.ABSMutator]MSP[]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.UOI1Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; MST[rv.CRCR6Mutator]MSP[] t = t >>> 4 | t << 28 ;
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.CRCR3Mutator]MSP[] c &= 0xfffffff ; int j = 0 ;
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { MST[rv.ROR1Mutator]MSP[] c = c >>> 2 | c << 26 ; d = d >>> 2 | d << 26 ; } else {
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.CRCR5Mutator]MSP[] c &= 0xfffffff ; int j = 0 ;
results [ 0 ] = a ; results [ 1 ] = b ; MST[rv.CRCR4Mutator]MSP[] }
private static int dEncrypt ( int el , final int r , final int s , final int e0 , final int e1 , final int sArr [] ) { int v = r ^ r >>> 16 ; int u = v & e0 ; MST[rv.UOI4Mutator]MSP[] v &= e1 ;
intToFourBytes ( out [ 1 ] , b , 4 ) ; b [ 8 ] = 0 ; int i = 2 ; int y = 0 ; int u = 128 ; for (; i < 13 ; i ++ ) { MST[rv.CRCR4Mutator]MSP[] int j = 0 ;
final int schedule [] = new int [ 32 ] ; MST[rv.CRCR2Mutator]MSP[] int c = fourBytesToInt ( key , 0 ) ; int d = fourBytesToInt ( key , 4 ) ; final int results [] = new int [ 2 ] ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR2Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
permOp ( left , right , 8 , 0xff00ff , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 2 , 0x33333333 , results ) ; MST[rv.ABSMutator]MSP[] right = results [ 0 ] ;
s = s << 4 | s >>> 28 ; MST[MathMutator]MSP[] schedule [ j ++ ] = s ; } return schedule ; } private static int fourBytesToInt ( final byte b [] , int offset ) { int value = byteToUnsigned ( b [ offset ++ ] ) ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.OBBN3Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
right = results [ 0 ] ; MST[rv.CRCR6Mutator]MSP[] left = results [ 1 ] ; final int out [] = new int [ 2 ] ; out [ 0 ] = left ; out [ 1 ] = right ; return out ; }
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; MST[rv.UOI4Mutator]MSP[] if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) {
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR6Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
final byte key [] = new byte [ 8 ] ; for ( int i = 0 ; i < key . length ; i ++ ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[] key [ i ] = 0 ; }
for ( int i = 0 ; i < 16 ; i ++ ) { MST[rv.ABSMutator]MSP[] if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; d = d >>> 2 | d << 26 ; } else {
private static void permOp ( int a , int b , final int n , final int m , final int results [] ) { final int t = ( a >>> n ^ b ) & m ; MST[MathMutator]MSP[] a ^= t << n ; b ^= t ;
SKB [ 7 ] [ d >>> 21 & 0xf | d >>> 22 & 0x30 ] ; schedule [ j ++ ] = ( t << 16 | s & 0xffff ) ; MST[rv.UOI2Mutator]MSP[] s = s >>> 16 | t & 0xffff0000 ;
SKB [ 7 ] [ d >>> 21 & 0xf | d >>> 22 & 0x30 ] ; schedule [ j ++ ] = ( t << 16 | s & 0xffff ) ; MST[InlineConstantMutator]MSP[] s = s >>> 16 | t & 0xffff0000 ;
permOp ( left , right , 8 , 0xff00ff , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 2 , 0x33333333 , results ) ; MST[rv.UOI4Mutator]MSP[] right = results [ 0 ] ;
final char charOne = salt . charAt ( 1 ) ; buffer . setCharAt ( 0 , charZero ) ; buffer . setCharAt ( 1 , charOne ) ; final int eSwap0 = CON_SALT [ charZero ] ; final int eSwap1 = CON_SALT [ charOne ] << 4 ; MST[rv.UOI2Mutator]MSP[]
left = results [ 1 ] ; permOp ( left , right , 16 , 65535 , results ) ; left = results [ 0 ] ; MST[rv.CRCR5Mutator]MSP[] right = results [ 1 ] ; permOp ( right , left , 4 , 0xf0f0f0f , results ) ;
private static int dEncrypt ( int el , final int r , final int s , final int e0 , final int e1 , final int sArr [] ) { int v = r ^ r >>> 16 ; int u = v & e0 ; v &= e1 ; MST[MathMutator]MSP[]
private static void intToFourBytes ( final int iValue , final byte b [] , int offset ) { b [ offset ++ ] = (byte) ( iValue & 0xff ) ; b [ offset ++ ] = (byte) ( iValue >>> 8 & 0xff ) ; MST[InlineConstantMutator]MSP[]
final byte key [] = new byte [ 8 ] ; for ( int i = 0 ; i < key . length ; i ++ ) { key [ i ] = 0 ; MST[rv.CRCR6Mutator]MSP[] }
permOp ( d , c , 4 , 0xf0f0f0f , results ) ; d = results [ 0 ] ; c = results [ 1 ] ; MST[rv.CRCR3Mutator]MSP[] c = hPermOp ( c , - 2 , 0xcccc0000 ) ;
c = c >>> 1 | c << 27 ; d = d >>> 1 | d << 27 ; MST[rv.UOI3Mutator]MSP[] } c &= 0xfffffff ; d &= 0xfffffff ;
final int schedule [] = desSetKey ( key ) ; final int out [] = body ( schedule , eSwap0 , eSwap1 ) ; final byte b [] = new byte [ 9 ] ; intToFourBytes ( out [ 0 ] , b , 0 ) ; MST[rv.CRCR5Mutator]MSP[]
private static int dEncrypt ( int el , final int r , final int s , final int e0 , final int e1 , final int sArr [] ) { int v = r ^ r >>> 16 ; int u = v & e0 ; v &= e1 ; MST[rv.UOI3Mutator]MSP[]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[MathMutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR4Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
} else if ( ! salt . matches ( lr_2 + B64 . B64T_STRING + lr_3 ) ) { throw new IllegalArgumentException ( lr_4 + salt ) ; MST[NonVoidMethodCallMutator]MSP[] } final StringBuilder buffer = new StringBuilder ( lr_5 ) ; final char charZero = salt . charAt ( 0 ) ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[MathMutator]MSP[]
final int numSaltChars = SALT_CHARS . length ; salt = lr_1 + SALT_CHARS [ randomGenerator . nextInt ( numSaltChars ) ] + MST[rv.UOI3Mutator]MSP[] SALT_CHARS [ randomGenerator . nextInt ( numSaltChars ) ] ;
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; d = d >>> 2 | d << 26 ; MST[rv.CRCR2Mutator]MSP[] } else {
permOp ( c , d , 8 , 0xff00ff , results ) ; MST[rv.CRCR1Mutator]MSP[] c = results [ 0 ] ; d = results [ 1 ] ; permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ;
final byte key [] = new byte [ 8 ] ; MST[rv.CRCR6Mutator]MSP[] for ( int i = 0 ; i < key . length ; i ++ ) { key [ i ] = 0 ; }
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR6Mutator]MSP[]
s = s << 4 | s >>> 28 ; MST[rv.UOI3Mutator]MSP[] schedule [ j ++ ] = s ; } return schedule ; } private static int fourBytesToInt ( final byte b [] , int offset ) { int value = byteToUnsigned ( b [ offset ++ ] ) ;
c = c >>> 1 | c << 27 ; d = d >>> 1 | d << 27 ; } c &= 0xfffffff ; MST[rv.OBBN1Mutator]MSP[] d &= 0xfffffff ;
permOp ( left , right , 8 , 0xff00ff , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 2 , 0x33333333 , results ) ; right = results [ 0 ] ; MST[InlineConstantMutator]MSP[]
s = s << 4 | s >>> 28 ; MST[rv.UOI2Mutator]MSP[] schedule [ j ++ ] = s ; } return schedule ; } private static int fourBytesToInt ( final byte b [] , int offset ) { int value = byteToUnsigned ( b [ offset ++ ] ) ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[InlineConstantMutator]MSP[]
private static void permOp ( int a , int b , final int n , final int m , final int results [] ) { final int t = ( a >>> n ^ b ) & m ; a ^= t << n ; MST[rv.UOI3Mutator]MSP[] b ^= t ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[InlineConstantMutator]MSP[]
b [ offset ++ ] = (byte) ( iValue >>> 16 & 0xff ) ; MST[experimental.RemoveIncrementsMutator]MSP[] b [ offset ++ ] = (byte) ( iValue >>> 24 & 0xff ) ; }
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR3Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR4Mutator]MSP[]
s = s << 4 | s >>> 28 ; MST[InlineConstantMutator]MSP[] schedule [ j ++ ] = s ; } return schedule ; } private static int fourBytesToInt ( final byte b [] , int offset ) { int value = byteToUnsigned ( b [ offset ++ ] ) ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.UOI2Mutator]MSP[]
permOp ( left , right , 8 , 0xff00ff , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; MST[rv.CRCR5Mutator]MSP[] permOp ( right , left , 2 , 0x33333333 , results ) ; right = results [ 0 ] ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR2Mutator]MSP[]
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.OBBN3Mutator]MSP[]
int c = 0 ; for (; j < 6 ; j ++ ) { MST[ConditionalsBoundaryMutator]MSP[] c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) {
SKB [ 7 ] [ d >>> 21 & 0xf | d >>> 22 & 0x30 ] ; schedule [ j ++ ] = ( t << 16 | s & 0xffff ) ; MST[rv.CRCR6Mutator]MSP[] s = s >>> 16 | t & 0xffff0000 ;
b [ offset ++ ] = (byte) ( iValue >>> 16 & 0xff ) ; MST[rv.CRCR1Mutator]MSP[] b [ offset ++ ] = (byte) ( iValue >>> 24 & 0xff ) ; }
left = t >>> 1 | t << 31 ; final int results [] = new int [ 2 ] ; permOp ( right , left , 1 , 0x55555555 , results ) ; MST[InlineConstantMutator]MSP[] right = results [ 0 ] ; left = results [ 1 ] ;
u = u ^ u << 16 ^ r ^ sArr [ s ] ; MST[rv.UOI2Mutator]MSP[] int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; t = t >>> 4 | t << 28 ;
permOp ( left , right , 8 , 0xff00ff , results ) ; left = results [ 0 ] ; MST[rv.CRCR3Mutator]MSP[] right = results [ 1 ] ; permOp ( right , left , 2 , 0x33333333 , results ) ; right = results [ 0 ] ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[MathMutator]MSP[]
} else if ( ! salt . matches ( lr_2 + B64 . B64T_STRING + lr_3 ) ) { throw new IllegalArgumentException ( lr_4 + salt ) ; } final StringBuilder buffer = new StringBuilder ( lr_5 ) ; final char charZero = salt . charAt ( 0 ) ; MST[rv.CRCR5Mutator]MSP[]
} else if ( ! salt . matches ( lr_2 + B64 . B64T_STRING + lr_3 ) ) { MST[rv.ROR1Mutator]MSP[] throw new IllegalArgumentException ( lr_4 + salt ) ; } final StringBuilder buffer = new StringBuilder ( lr_5 ) ; final char charZero = salt . charAt ( 0 ) ;
left = t >>> 1 | t << 31 ; final int results [] = new int [ 2 ] ; permOp ( right , left , 1 , 0x55555555 , results ) ; MST[rv.UOI2Mutator]MSP[] right = results [ 0 ] ; left = results [ 1 ] ;
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; } t = left ; left = right ; right = t ; } t = right ; right = left >>> 1 | left << 31 ; MST[MathMutator]MSP[]
results [ 0 ] = a ; results [ 1 ] = b ; MST[rv.UOI4Mutator]MSP[] }
for ( int i = 0 ; i < 32 ; i += 4 ) { left = dEncrypt ( left , right , i , eSwap0 , eSwap1 , schedule ) ; MST[rv.UOI1Mutator]MSP[]
for ( int i = 0 ; i < 16 ; i ++ ) { MST[rv.CRCR4Mutator]MSP[] if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; d = d >>> 2 | d << 26 ; } else {
for ( int i = 0 ; i < key . length && i < original . length ; i ++ ) { final int iChar = original [ i ] ; key [ i ] = (byte) ( iChar << 1 ) ; MST[rv.UOI3Mutator]MSP[] }
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; MST[rv.UOI4Mutator]MSP[] t = t >>> 4 | t << 28 ;
permOp ( d , c , 4 , 0xf0f0f0f , results ) ; d = results [ 0 ] ; c = results [ 1 ] ; c = hPermOp ( c , - 2 , 0xcccc0000 ) ; MST[rv.CRCR1Mutator]MSP[]
SKB [ 7 ] [ d >>> 21 & 0xf | d >>> 22 & 0x30 ] ; schedule [ j ++ ] = ( t << 16 | s & 0xffff ) ; MST[IncrementsMutator]MSP[] s = s >>> 16 | t & 0xffff0000 ;
c = c >>> 1 | c << 27 ; d = d >>> 1 | d << 27 ; MST[rv.UOI2Mutator]MSP[] } c &= 0xfffffff ; d &= 0xfffffff ;
left = results [ 1 ] ; permOp ( left , right , 16 , 65535 , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 4 , 0xf0f0f0f , results ) ; MST[InlineConstantMutator]MSP[]
final int schedule [] = desSetKey ( key ) ; final int out [] = body ( schedule , eSwap0 , eSwap1 ) ; final byte b [] = new byte [ 9 ] ; intToFourBytes ( out [ 0 ] , b , 0 ) ; MST[rv.CRCR6Mutator]MSP[]
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; MST[rv.ABSMutator]MSP[] } t = left ; left = right ; right = t ; } t = right ; right = left >>> 1 | left << 31 ;
permOp ( left , right , 8 , 0xff00ff , results ) ; MST[rv.UOI3Mutator]MSP[] left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 2 , 0x33333333 , results ) ; right = results [ 0 ] ;
b [ offset ++ ] = (byte) ( iValue >>> 16 & 0xff ) ; MST[rv.UOI4Mutator]MSP[] b [ offset ++ ] = (byte) ( iValue >>> 24 & 0xff ) ; }
d = hPermOp ( d , - 2 , 0xcccc0000 ) ; permOp ( d , c , 1 , 0x55555555 , results ) ; MST[rv.ABSMutator]MSP[] d = results [ 0 ] ; c = results [ 1 ] ;
c = c >>> 1 | c << 27 ; d = d >>> 1 | d << 27 ; MST[MathMutator]MSP[] } c &= 0xfffffff ; d &= 0xfffffff ;
left = results [ 1 ] ; MST[rv.CRCR6Mutator]MSP[] permOp ( left , right , 16 , 65535 , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 4 , 0xf0f0f0f , results ) ;
d = hPermOp ( d , - 2 , 0xcccc0000 ) ; MST[NonVoidMethodCallMutator]MSP[] permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ; c = results [ 1 ] ;
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; MST[rv.CRCR6Mutator]MSP[] a = a ^ t ^ t >>> 16 - n ; return a ; }
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.UOI2Mutator]MSP[] c &= 0xfffffff ; int j = 0 ;
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; t = t >>> 4 | t << 28 ; MST[rv.CRCR1Mutator]MSP[]
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; MST[rv.UOI1Mutator]MSP[] a = a ^ t ^ t >>> 16 - n ; return a ; }
results [ 0 ] = a ; MST[rv.UOI2Mutator]MSP[] results [ 1 ] = b ; }
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; MST[rv.UOI4Mutator]MSP[] } t = left ; left = right ; right = t ; } t = right ; right = left >>> 1 | left << 31 ;
intToFourBytes ( out [ 1 ] , b , 4 ) ; b [ 8 ] = 0 ; int i = 2 ; int y = 0 ; int u = 128 ; for (; i < 13 ; i ++ ) { MST[experimental.RemoveIncrementsMutator]MSP[] int j = 0 ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.UOI3Mutator]MSP[]
private static void permOp ( int a , int b , final int n , final int m , final int results [] ) { final int t = ( a >>> n ^ b ) & m ; a ^= t << n ; b ^= t ; MST[rv.UOI1Mutator]MSP[]
for ( int i = 0 ; i < key . length && i < original . length ; i ++ ) { MST[rv.UOI3Mutator]MSP[] final int iChar = original [ i ] ; key [ i ] = (byte) ( iChar << 1 ) ; }
permOp ( d , c , 4 , 0xf0f0f0f , results ) ; d = results [ 0 ] ; c = results [ 1 ] ; MST[rv.UOI3Mutator]MSP[] c = hPermOp ( c , - 2 , 0xcccc0000 ) ;
d = hPermOp ( d , - 2 , 0xcccc0000 ) ; permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ; c = results [ 1 ] ; MST[rv.CRCR3Mutator]MSP[]
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR1Mutator]MSP[]
private static void intToFourBytes ( final int iValue , final byte b [] , int offset ) { b [ offset ++ ] = (byte) ( iValue & 0xff ) ; b [ offset ++ ] = (byte) ( iValue >>> 8 & 0xff ) ; MST[rv.UOI2Mutator]MSP[]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.ABSMutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.OBBN1Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
public static String crypt ( final byte [] original ) { return crypt ( original , null ) ; MST[ArgumentPropagationMutator]MSP[] } public static String crypt ( final byte [] original , String salt ) { if ( salt == null ) { final ThreadLocalRandom randomGenerator = ThreadLocalRandom . current () ;
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; MST[rv.UOI2Mutator]MSP[] t = t >>> 4 | t << 28 ;
permOp ( left , right , 8 , 0xff00ff , results ) ; MST[rv.CRCR5Mutator]MSP[] left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 2 , 0x33333333 , results ) ; right = results [ 0 ] ;
c = c >>> 1 | c << 27 ; d = d >>> 1 | d << 27 ; } c &= 0xfffffff ; d &= 0xfffffff ; MST[rv.UOI2Mutator]MSP[]
permOp ( c , d , 8 , 0xff00ff , results ) ; c = results [ 0 ] ; d = results [ 1 ] ; MST[rv.UOI4Mutator]MSP[] permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ;
u = u ^ u << 16 ^ r ^ sArr [ s ] ; MST[rv.UOI1Mutator]MSP[] int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; t = t >>> 4 | t << 28 ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[MathMutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
d = hPermOp ( d , - 2 , 0xcccc0000 ) ; MST[rv.CRCR2Mutator]MSP[] permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ; c = results [ 1 ] ;
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; MST[rv.OBBN1Mutator]MSP[] } u >>>= 1 ; if ( u == 0 ) {
c = c >>> 1 | c << 27 ; d = d >>> 1 | d << 27 ; } c &= 0xfffffff ; d &= 0xfffffff ; MST[InlineConstantMutator]MSP[]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.UOI1Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR1Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
private static int dEncrypt ( int el , final int r , final int s , final int e0 , final int e1 , final int sArr [] ) { int v = r ^ r >>> 16 ; int u = v & e0 ; MST[rv.OBBN2Mutator]MSP[] v &= e1 ;
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; MST[MathMutator]MSP[] a = a ^ t ^ t >>> 16 - n ; return a ; }
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[InlineConstantMutator]MSP[] c &= 0xfffffff ; int j = 0 ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR1Mutator]MSP[]
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; } u >>>= 1 ; MST[rv.CRCR3Mutator]MSP[] if ( u == 0 ) {
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[InlineConstantMutator]MSP[]
left = results [ 1 ] ; permOp ( left , right , 16 , 65535 , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 4 , 0xf0f0f0f , results ) ; MST[rv.CRCR4Mutator]MSP[]
d = hPermOp ( d , - 2 , 0xcccc0000 ) ; permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ; c = results [ 1 ] ; MST[rv.UOI3Mutator]MSP[]
left = t >>> 1 | t << 31 ; final int results [] = new int [ 2 ] ; permOp ( right , left , 1 , 0x55555555 , results ) ; right = results [ 0 ] ; left = results [ 1 ] ; MST[InlineConstantMutator]MSP[]
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.OBBN3Mutator]MSP[] c &= 0xfffffff ; int j = 0 ;
permOp ( d , c , 4 , 0xf0f0f0f , results ) ; d = results [ 0 ] ; MST[rv.CRCR1Mutator]MSP[] c = results [ 1 ] ; c = hPermOp ( c , - 2 , 0xcccc0000 ) ;
final int schedule [] = desSetKey ( key ) ; final int out [] = body ( schedule , eSwap0 , eSwap1 ) ; final byte b [] = new byte [ 9 ] ; MST[rv.CRCR3Mutator]MSP[] intToFourBytes ( out [ 0 ] , b , 0 ) ;
c = c >>> 1 | c << 27 ; MST[rv.UOI4Mutator]MSP[] d = d >>> 1 | d << 27 ; } c &= 0xfffffff ; d &= 0xfffffff ;
b [ offset ++ ] = (byte) ( iValue >>> 16 & 0xff ) ; MST[rv.OBBN2Mutator]MSP[] b [ offset ++ ] = (byte) ( iValue >>> 24 & 0xff ) ; }
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR3Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
u = u ^ u << 16 ^ r ^ sArr [ s ] ; MST[rv.UOI4Mutator]MSP[] int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; t = t >>> 4 | t << 28 ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.UOI3Mutator]MSP[]
left = results [ 1 ] ; permOp ( left , right , 16 , 65535 , results ) ; MST[rv.CRCR3Mutator]MSP[] left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 4 , 0xf0f0f0f , results ) ;
private static int byteToUnsigned ( final byte b ) { final int value = b ; return value < 0 ? value + 256 : value ; MST[rv.UOI2Mutator]MSP[] }
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; MST[rv.CRCR6Mutator]MSP[] if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) {
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; return value ; MST[rv.UOI3Mutator]MSP[] }
intToFourBytes ( out [ 1 ] , b , 4 ) ; b [ 8 ] = 0 ; int i = 2 ; int y = 0 ; int u = 128 ; for (; i < 13 ; i ++ ) { int j = 0 ; MST[rv.CRCR1Mutator]MSP[]
c = c >>> 1 | c << 27 ; MST[rv.CRCR5Mutator]MSP[] d = d >>> 1 | d << 27 ; } c &= 0xfffffff ; d &= 0xfffffff ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR3Mutator]MSP[]
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; MST[rv.OBBN1Mutator]MSP[] value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; return value ; }
final byte key [] = new byte [ 8 ] ; for ( int i = 0 ; i < key . length ; i ++ ) { key [ i ] = 0 ; MST[rv.UOI4Mutator]MSP[] }
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR2Mutator]MSP[]
private static void intToFourBytes ( final int iValue , final byte b [] , int offset ) { b [ offset ++ ] = (byte) ( iValue & 0xff ) ; MST[rv.UOI3Mutator]MSP[] b [ offset ++ ] = (byte) ( iValue >>> 8 & 0xff ) ;
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; MST[MathMutator]MSP[] t = t >>> 4 | t << 28 ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.ABSMutator]MSP[]
c = c >>> 1 | c << 27 ; d = d >>> 1 | d << 27 ; } c &= 0xfffffff ; d &= 0xfffffff ; MST[rv.OBBN3Mutator]MSP[]
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR6Mutator]MSP[]
permOp ( left , right , 8 , 0xff00ff , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 2 , 0x33333333 , results ) ; MST[rv.CRCR6Mutator]MSP[] right = results [ 0 ] ;
c = c >>> 1 | c << 27 ; d = d >>> 1 | d << 27 ; MST[InlineConstantMutator]MSP[] } c &= 0xfffffff ; d &= 0xfffffff ;
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.CRCR2Mutator]MSP[] c &= 0xfffffff ; int j = 0 ;
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; c &= 0xfffffff ; MST[rv.CRCR5Mutator]MSP[] int j = 0 ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.OBBN2Mutator]MSP[]
private static int byteToUnsigned ( final byte b ) { final int value = b ; return value < 0 ? value + 256 : value ; MST[rv.AOR3Mutator]MSP[] }
SKB [ 7 ] [ d >>> 21 & 0xf | d >>> 22 & 0x30 ] ; schedule [ j ++ ] = ( t << 16 | s & 0xffff ) ; s = s >>> 16 | t & 0xffff0000 ; MST[rv.UOI3Mutator]MSP[]
final int numSaltChars = SALT_CHARS . length ; salt = lr_1 + SALT_CHARS [ randomGenerator . nextInt ( numSaltChars ) ] + MST[NonVoidMethodCallMutator]MSP[] SALT_CHARS [ randomGenerator . nextInt ( numSaltChars ) ] ;
private static int [] body ( final int schedule [] , final int eSwap0 , final int eSwap1 ) { int left = 0 ; int right = 0 ; MST[rv.CRCR3Mutator]MSP[] int t = 0 ; for ( int j = 0 ; j < 25 ; j ++ ) {
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { MST[rv.UOI2Mutator]MSP[] c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) {
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; MST[rv.UOI3Mutator]MSP[] value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; return value ; }
SKB [ 7 ] [ d >>> 21 & 0xf | d >>> 22 & 0x30 ] ; schedule [ j ++ ] = ( t << 16 | s & 0xffff ) ; s = s >>> 16 | t & 0xffff0000 ; MST[rv.OBBN1Mutator]MSP[]
intToFourBytes ( out [ 1 ] , b , 4 ) ; MST[rv.CRCR3Mutator]MSP[] b [ 8 ] = 0 ; int i = 2 ; int y = 0 ; int u = 128 ; for (; i < 13 ; i ++ ) { int j = 0 ;
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; d = d >>> 2 | d << 26 ; MST[rv.CRCR1Mutator]MSP[] } else {
intToFourBytes ( out [ 1 ] , b , 4 ) ; b [ 8 ] = 0 ; MST[rv.CRCR5Mutator]MSP[] int i = 2 ; int y = 0 ; int u = 128 ; for (; i < 13 ; i ++ ) { int j = 0 ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.UOI1Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
permOp ( c , d , 8 , 0xff00ff , results ) ; c = results [ 0 ] ; d = results [ 1 ] ; permOp ( d , c , 1 , 0x55555555 , results ) ; MST[rv.CRCR2Mutator]MSP[] d = results [ 0 ] ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR5Mutator]MSP[]
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR4Mutator]MSP[]
permOp ( d , c , 4 , 0xf0f0f0f , results ) ; d = results [ 0 ] ; c = results [ 1 ] ; c = hPermOp ( c , - 2 , 0xcccc0000 ) ; MST[rv.CRCR5Mutator]MSP[]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.OBBN3Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR6Mutator]MSP[]
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR3Mutator]MSP[]
d = hPermOp ( d , - 2 , 0xcccc0000 ) ; permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ; MST[rv.UOI1Mutator]MSP[] c = results [ 1 ] ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[MathMutator]MSP[]
final char charOne = salt . charAt ( 1 ) ; buffer . setCharAt ( 0 , charZero ) ; buffer . setCharAt ( 1 , charOne ) ; MST[rv.UOI4Mutator]MSP[] final int eSwap0 = CON_SALT [ charZero ] ; final int eSwap1 = CON_SALT [ charOne ] << 4 ;
left = t >>> 1 | t << 31 ; final int results [] = new int [ 2 ] ; permOp ( right , left , 1 , 0x55555555 , results ) ; MST[rv.CRCR4Mutator]MSP[] right = results [ 0 ] ; left = results [ 1 ] ;
final char charOne = salt . charAt ( 1 ) ; buffer . setCharAt ( 0 , charZero ) ; MST[rv.UOI2Mutator]MSP[] buffer . setCharAt ( 1 , charOne ) ; final int eSwap0 = CON_SALT [ charZero ] ; final int eSwap1 = CON_SALT [ charOne ] << 4 ;
final int schedule [] = desSetKey ( key ) ; final int out [] = body ( schedule , eSwap0 , eSwap1 ) ; final byte b [] = new byte [ 9 ] ; intToFourBytes ( out [ 0 ] , b , 0 ) ; MST[rv.ABSMutator]MSP[]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.UOI3Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
c = c >>> 1 | c << 27 ; MST[rv.OBBN1Mutator]MSP[] d = d >>> 1 | d << 27 ; } c &= 0xfffffff ; d &= 0xfffffff ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[InlineConstantMutator]MSP[]
left = results [ 1 ] ; permOp ( left , right , 16 , 65535 , results ) ; left = results [ 0 ] ; MST[rv.ABSMutator]MSP[] right = results [ 1 ] ; permOp ( right , left , 4 , 0xf0f0f0f , results ) ;
final int schedule [] = new int [ 32 ] ; int c = fourBytesToInt ( key , 0 ) ; int d = fourBytesToInt ( key , 4 ) ; final int results [] = new int [ 2 ] ; MST[rv.CRCR2Mutator]MSP[]
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; MST[rv.CRCR5Mutator]MSP[] t = t >>> 4 | t << 28 ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.OBBN1Mutator]MSP[]
s = s << 4 | s >>> 28 ; schedule [ j ++ ] = s ; } return schedule ; } private static int fourBytesToInt ( final byte b [] , int offset ) { int value = byteToUnsigned ( b [ offset ++ ] ) ; MST[experimental.RemoveIncrementsMutator]MSP[]
right = results [ 0 ] ; left = results [ 1 ] ; final int out [] = new int [ 2 ] ; MST[rv.CRCR4Mutator]MSP[] out [ 0 ] = left ; out [ 1 ] = right ; return out ; }
private static int dEncrypt ( int el , final int r , final int s , final int e0 , final int e1 , final int sArr [] ) { int v = r ^ r >>> 16 ; MST[rv.UOI3Mutator]MSP[] int u = v & e0 ; v &= e1 ;
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) { MST[rv.UOI3Mutator]MSP[]
for ( int i = 0 ; i < 32 ; i += 4 ) { MST[rv.CRCR3Mutator]MSP[] left = dEncrypt ( left , right , i , eSwap0 , eSwap1 , schedule ) ;
SKB [ 7 ] [ d >>> 21 & 0xf | d >>> 22 & 0x30 ] ; schedule [ j ++ ] = ( t << 16 | s & 0xffff ) ; s = s >>> 16 | t & 0xffff0000 ; MST[rv.UOI4Mutator]MSP[]
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; MST[rv.UOI2Mutator]MSP[] value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; return value ; }
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.UOI1Mutator]MSP[]
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[InlineConstantMutator]MSP[] c &= 0xfffffff ; int j = 0 ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.OBBN2Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
b [ offset ++ ] = (byte) ( iValue >>> 16 & 0xff ) ; b [ offset ++ ] = (byte) ( iValue >>> 24 & 0xff ) ; MST[rv.CRCR6Mutator]MSP[] }
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; } u >>>= 1 ; MST[rv.UOI1Mutator]MSP[] if ( u == 0 ) {
right = results [ 0 ] ; left = results [ 1 ] ; final int out [] = new int [ 2 ] ; out [ 0 ] = left ; MST[rv.CRCR6Mutator]MSP[] out [ 1 ] = right ; return out ; }
private static int [] body ( final int schedule [] , final int eSwap0 , final int eSwap1 ) { int left = 0 ; int right = 0 ; int t = 0 ; for ( int j = 0 ; j < 25 ; j ++ ) { MST[rv.ROR5Mutator]MSP[]
right = results [ 0 ] ; MST[rv.CRCR3Mutator]MSP[] left = results [ 1 ] ; final int out [] = new int [ 2 ] ; out [ 0 ] = left ; out [ 1 ] = right ; return out ; }
left = t >>> 1 | t << 31 ; MST[InlineConstantMutator]MSP[] final int results [] = new int [ 2 ] ; permOp ( right , left , 1 , 0x55555555 , results ) ; right = results [ 0 ] ; left = results [ 1 ] ;
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; a = a ^ t ^ t >>> 16 - n ; MST[rv.CRCR1Mutator]MSP[] return a ; }
u = u ^ u << 16 ^ r ^ sArr [ s ] ; MST[rv.CRCR6Mutator]MSP[] int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; t = t >>> 4 | t << 28 ;
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.CRCR4Mutator]MSP[] c &= 0xfffffff ; int j = 0 ;
for ( int i = 0 ; i < 32 ; i += 4 ) { left = dEncrypt ( left , right , i , eSwap0 , eSwap1 , schedule ) ; MST[rv.UOI4Mutator]MSP[]
final int schedule [] = new int [ 32 ] ; int c = fourBytesToInt ( key , 0 ) ; int d = fourBytesToInt ( key , 4 ) ; MST[rv.CRCR6Mutator]MSP[] final int results [] = new int [ 2 ] ;
SKB [ 7 ] [ d >>> 21 & 0xf | d >>> 22 & 0x30 ] ; schedule [ j ++ ] = ( t << 16 | s & 0xffff ) ; MST[rv.ABSMutator]MSP[] s = s >>> 16 | t & 0xffff0000 ;
private static void permOp ( int a , int b , final int n , final int m , final int results [] ) { final int t = ( a >>> n ^ b ) & m ; MST[MathMutator]MSP[] a ^= t << n ; b ^= t ;
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { MST[rv.UOI1Mutator]MSP[] c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) {
intToFourBytes ( out [ 1 ] , b , 4 ) ; b [ 8 ] = 0 ; MST[rv.CRCR2Mutator]MSP[] int i = 2 ; int y = 0 ; int u = 128 ; for (; i < 13 ; i ++ ) { int j = 0 ;
permOp ( left , right , 8 , 0xff00ff , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; MST[rv.ABSMutator]MSP[] permOp ( right , left , 2 , 0x33333333 , results ) ; right = results [ 0 ] ;
private static int dEncrypt ( int el , final int r , final int s , final int e0 , final int e1 , final int sArr [] ) { int v = r ^ r >>> 16 ; MST[rv.CRCR5Mutator]MSP[] int u = v & e0 ; v &= e1 ;
c = c >>> 1 | c << 27 ; d = d >>> 1 | d << 27 ; } c &= 0xfffffff ; d &= 0xfffffff ; MST[rv.CRCR4Mutator]MSP[]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR3Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
s = s << 4 | s >>> 28 ; schedule [ j ++ ] = s ; } return schedule ; } private static int fourBytesToInt ( final byte b [] , int offset ) { int value = byteToUnsigned ( b [ offset ++ ] ) ; MST[rv.UOI3Mutator]MSP[]
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; d = d >>> 2 | d << 26 ; MST[InlineConstantMutator]MSP[] } else {
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; a = a ^ t ^ t >>> 16 - n ; MST[rv.AOR2Mutator]MSP[] return a ; }
permOp ( left , right , 8 , 0xff00ff , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 2 , 0x33333333 , results ) ; MST[VoidMethodCallMutator]MSP[] right = results [ 0 ] ;
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; d = d >>> 2 | d << 26 ; MST[MathMutator]MSP[] } else {
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; d = d >>> 2 | d << 26 ; MST[rv.OBBN1Mutator]MSP[] } else {
SKB [ 7 ] [ d >>> 21 & 0xf | d >>> 22 & 0x30 ] ; schedule [ j ++ ] = ( t << 16 | s & 0xffff ) ; s = s >>> 16 | t & 0xffff0000 ; MST[rv.CRCR6Mutator]MSP[]
permOp ( c , d , 8 , 0xff00ff , results ) ; MST[rv.ABSMutator]MSP[] c = results [ 0 ] ; d = results [ 1 ] ; permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ;
left = t >>> 1 | t << 31 ; final int results [] = new int [ 2 ] ; permOp ( right , left , 1 , 0x55555555 , results ) ; right = results [ 0 ] ; left = results [ 1 ] ; MST[rv.UOI1Mutator]MSP[]
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; MST[rv.AOD2Mutator]MSP[] t = t >>> 4 | t << 28 ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.UOI2Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
permOp ( left , right , 8 , 0xff00ff , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 2 , 0x33333333 , results ) ; right = results [ 0 ] ; MST[rv.CRCR1Mutator]MSP[]
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; MST[rv.CRCR3Mutator]MSP[] t = t >>> 4 | t << 28 ;
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; a = a ^ t ^ t >>> 16 - n ; MST[rv.UOI4Mutator]MSP[] return a ; }
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[MathMutator]MSP[]
for ( int i = 0 ; i < 16 ; i ++ ) { MST[rv.CRCR1Mutator]MSP[] if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; d = d >>> 2 | d << 26 ; } else {
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR1Mutator]MSP[]
b [ offset ++ ] = (byte) ( iValue >>> 16 & 0xff ) ; MST[InlineConstantMutator]MSP[] b [ offset ++ ] = (byte) ( iValue >>> 24 & 0xff ) ; }
for ( int i = 0 ; i < key . length && i < original . length ; i ++ ) { final int iChar = original [ i ] ; MST[rv.UOI1Mutator]MSP[] key [ i ] = (byte) ( iChar << 1 ) ; }
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; } u >>>= 1 ; MST[rv.UOI4Mutator]MSP[] if ( u == 0 ) {
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR4Mutator]MSP[]
right = results [ 0 ] ; left = results [ 1 ] ; final int out [] = new int [ 2 ] ; out [ 0 ] = left ; MST[rv.CRCR3Mutator]MSP[] out [ 1 ] = right ; return out ; }
left = results [ 1 ] ; permOp ( left , right , 16 , 65535 , results ) ; left = results [ 0 ] ; MST[rv.UOI2Mutator]MSP[] right = results [ 1 ] ; permOp ( right , left , 4 , 0xf0f0f0f , results ) ;
private static void permOp ( int a , int b , final int n , final int m , final int results [] ) { final int t = ( a >>> n ^ b ) & m ; MST[rv.UOI3Mutator]MSP[] a ^= t << n ; b ^= t ;
permOp ( c , d , 8 , 0xff00ff , results ) ; MST[InlineConstantMutator]MSP[] c = results [ 0 ] ; d = results [ 1 ] ; permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ;
b [ offset ++ ] = (byte) ( iValue >>> 16 & 0xff ) ; MST[rv.ABSMutator]MSP[] b [ offset ++ ] = (byte) ( iValue >>> 24 & 0xff ) ; }
int c = 0 ; for (; j < 6 ; j ++ ) { MST[InlineConstantMutator]MSP[] c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) {
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.UOI4Mutator]MSP[]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.OBBN2Mutator]MSP[]
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; d = d >>> 2 | d << 26 ; MST[rv.ABSMutator]MSP[] } else {
c = c >>> 1 | c << 27 ; MST[rv.CRCR6Mutator]MSP[] d = d >>> 1 | d << 27 ; } c &= 0xfffffff ; d &= 0xfffffff ;
permOp ( d , c , 4 , 0xf0f0f0f , results ) ; d = results [ 0 ] ; MST[InlineConstantMutator]MSP[] c = results [ 1 ] ; c = hPermOp ( c , - 2 , 0xcccc0000 ) ;
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; MST[rv.UOI1Mutator]MSP[] t = t >>> 4 | t << 28 ;
b [ offset ++ ] = (byte) ( iValue >>> 16 & 0xff ) ; MST[rv.CRCR3Mutator]MSP[] b [ offset ++ ] = (byte) ( iValue >>> 24 & 0xff ) ; }
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.OBBN2Mutator]MSP[]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.OBBN3Mutator]MSP[]
final char charOne = salt . charAt ( 1 ) ; MST[rv.CRCR3Mutator]MSP[] buffer . setCharAt ( 0 , charZero ) ; buffer . setCharAt ( 1 , charOne ) ; final int eSwap0 = CON_SALT [ charZero ] ; final int eSwap1 = CON_SALT [ charOne ] << 4 ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[MathMutator]MSP[]
final char charOne = salt . charAt ( 1 ) ; buffer . setCharAt ( 0 , charZero ) ; MST[rv.CRCR5Mutator]MSP[] buffer . setCharAt ( 1 , charOne ) ; final int eSwap0 = CON_SALT [ charZero ] ; final int eSwap1 = CON_SALT [ charOne ] << 4 ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[InlineConstantMutator]MSP[]
d = hPermOp ( d , - 2 , 0xcccc0000 ) ; MST[rv.CRCR3Mutator]MSP[] permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ; c = results [ 1 ] ;
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; MST[rv.AOD1Mutator]MSP[] } t = left ; left = right ; right = t ; } t = right ; right = left >>> 1 | left << 31 ;
SKB [ 7 ] [ d >>> 21 & 0xf | d >>> 22 & 0x30 ] ; schedule [ j ++ ] = ( t << 16 | s & 0xffff ) ; MST[rv.CRCR3Mutator]MSP[] s = s >>> 16 | t & 0xffff0000 ;
private static void intToFourBytes ( final int iValue , final byte b [] , int offset ) { b [ offset ++ ] = (byte) ( iValue & 0xff ) ; b [ offset ++ ] = (byte) ( iValue >>> 8 & 0xff ) ; MST[experimental.RemoveIncrementsMutator]MSP[]
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.OBBN2Mutator]MSP[]
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; } t = left ; left = right ; right = t ; } t = right ; right = left >>> 1 | left << 31 ; MST[MathMutator]MSP[]
right = results [ 0 ] ; left = results [ 1 ] ; final int out [] = new int [ 2 ] ; out [ 0 ] = left ; MST[rv.UOI3Mutator]MSP[] out [ 1 ] = right ; return out ; }
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; t = t >>> 4 | t << 28 ; MST[rv.ABSMutator]MSP[]
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.OBBN3Mutator]MSP[] c &= 0xfffffff ; int j = 0 ;
intToFourBytes ( out [ 1 ] , b , 4 ) ; b [ 8 ] = 0 ; int i = 2 ; int y = 0 ; int u = 128 ; for (; i < 13 ; i ++ ) { MST[rv.UOI2Mutator]MSP[] int j = 0 ;
} else if ( ! salt . matches ( lr_2 + B64 . B64T_STRING + lr_3 ) ) { MST[rv.ROR4Mutator]MSP[] throw new IllegalArgumentException ( lr_4 + salt ) ; } final StringBuilder buffer = new StringBuilder ( lr_5 ) ; final char charZero = salt . charAt ( 0 ) ;
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; MST[rv.AOR4Mutator]MSP[] t = t >>> 4 | t << 28 ;
for ( int i = 0 ; i < 32 ; i += 4 ) { left = dEncrypt ( left , right , i , eSwap0 , eSwap1 , schedule ) ; MST[rv.UOI3Mutator]MSP[]
SKB [ 7 ] [ d >>> 21 & 0xf | d >>> 22 & 0x30 ] ; schedule [ j ++ ] = ( t << 16 | s & 0xffff ) ; s = s >>> 16 | t & 0xffff0000 ; MST[rv.CRCR5Mutator]MSP[]
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; a = a ^ t ^ t >>> 16 - n ; return a ; MST[rv.UOI3Mutator]MSP[] }
left = results [ 1 ] ; permOp ( left , right , 16 , 65535 , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 4 , 0xf0f0f0f , results ) ; MST[rv.UOI1Mutator]MSP[]
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; MST[rv.CRCR2Mutator]MSP[] value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; return value ; }
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; MST[rv.ABSMutator]MSP[] } t = left ; left = right ; right = t ; } t = right ; right = left >>> 1 | left << 31 ;
for ( int i = 0 ; i < key . length && i < original . length ; i ++ ) { MST[rv.UOI3Mutator]MSP[] final int iChar = original [ i ] ; key [ i ] = (byte) ( iChar << 1 ) ; }
right = results [ 0 ] ; MST[rv.UOI3Mutator]MSP[] left = results [ 1 ] ; final int out [] = new int [ 2 ] ; out [ 0 ] = left ; out [ 1 ] = right ; return out ; }
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.ABSMutator]MSP[]
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; MST[rv.UOI3Mutator]MSP[] a = a ^ t ^ t >>> 16 - n ; return a ; }
b [ offset ++ ] = (byte) ( iValue >>> 16 & 0xff ) ; b [ offset ++ ] = (byte) ( iValue >>> 24 & 0xff ) ; MST[rv.OBBN3Mutator]MSP[] }
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR1Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
s = s << 4 | s >>> 28 ; schedule [ j ++ ] = s ; MST[rv.UOI2Mutator]MSP[] } return schedule ; } private static int fourBytesToInt ( final byte b [] , int offset ) { int value = byteToUnsigned ( b [ offset ++ ] ) ;
permOp ( left , right , 8 , 0xff00ff , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 2 , 0x33333333 , results ) ; MST[rv.CRCR3Mutator]MSP[] right = results [ 0 ] ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR5Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[InlineConstantMutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
permOp ( left , right , 8 , 0xff00ff , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; MST[rv.CRCR2Mutator]MSP[] permOp ( right , left , 2 , 0x33333333 , results ) ; right = results [ 0 ] ;
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; c &= 0xfffffff ; MST[rv.CRCR2Mutator]MSP[] int j = 0 ;
c = results [ 1 ] ; MST[rv.UOI2Mutator]MSP[] d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; c &= 0xfffffff ; int j = 0 ;
final char charOne = salt . charAt ( 1 ) ; buffer . setCharAt ( 0 , charZero ) ; buffer . setCharAt ( 1 , charOne ) ; final int eSwap0 = CON_SALT [ charZero ] ; final int eSwap1 = CON_SALT [ charOne ] << 4 ; MST[rv.CRCR6Mutator]MSP[]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR4Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR3Mutator]MSP[]
private static int byteToUnsigned ( final byte b ) { final int value = b ; return value < 0 ? value + 256 : value ; MST[rv.CRCR5Mutator]MSP[] }
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.UOI3Mutator]MSP[]
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.CRCR2Mutator]MSP[] c &= 0xfffffff ; int j = 0 ;
c = c >>> 1 | c << 27 ; d = d >>> 1 | d << 27 ; MST[rv.CRCR5Mutator]MSP[] } c &= 0xfffffff ; d &= 0xfffffff ;
y ++ ; u = 128 ; MST[rv.CRCR3Mutator]MSP[] } buffer . setCharAt ( i , ( char ) COV2CHAR [ c ] ) ; } } return buffer . toString () ; } public static String crypt ( final String original ) {
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR1Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
c = c >>> 1 | c << 27 ; d = d >>> 1 | d << 27 ; } c &= 0xfffffff ; MST[rv.CRCR2Mutator]MSP[] d &= 0xfffffff ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[InlineConstantMutator]MSP[]
private static void intToFourBytes ( final int iValue , final byte b [] , int offset ) { b [ offset ++ ] = (byte) ( iValue & 0xff ) ; b [ offset ++ ] = (byte) ( iValue >>> 8 & 0xff ) ; MST[rv.OBBN2Mutator]MSP[]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR6Mutator]MSP[]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR6Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.UOI1Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; } t = left ; left = right ; right = t ; } t = right ; right = left >>> 1 | left << 31 ; MST[rv.UOI4Mutator]MSP[]
SKB [ 7 ] [ d >>> 21 & 0xf | d >>> 22 & 0x30 ] ; schedule [ j ++ ] = ( t << 16 | s & 0xffff ) ; MST[rv.CRCR4Mutator]MSP[] s = s >>> 16 | t & 0xffff0000 ;
left = t >>> 1 | t << 31 ; MST[rv.ABSMutator]MSP[] final int results [] = new int [ 2 ] ; permOp ( right , left , 1 , 0x55555555 , results ) ; right = results [ 0 ] ; left = results [ 1 ] ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.UOI4Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR5Mutator]MSP[]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR6Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
s = s << 4 | s >>> 28 ; MST[rv.CRCR5Mutator]MSP[] schedule [ j ++ ] = s ; } return schedule ; } private static int fourBytesToInt ( final byte b [] , int offset ) { int value = byteToUnsigned ( b [ offset ++ ] ) ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.UOI4Mutator]MSP[]
private static int dEncrypt ( int el , final int r , final int s , final int e0 , final int e1 , final int sArr [] ) { int v = r ^ r >>> 16 ; MST[rv.UOI1Mutator]MSP[] int u = v & e0 ; v &= e1 ;
final int schedule [] = new int [ 32 ] ; int c = fourBytesToInt ( key , 0 ) ; MST[ArgumentPropagationMutator]MSP[] int d = fourBytesToInt ( key , 4 ) ; final int results [] = new int [ 2 ] ;
s = s << 4 | s >>> 28 ; MST[rv.CRCR4Mutator]MSP[] schedule [ j ++ ] = s ; } return schedule ; } private static int fourBytesToInt ( final byte b [] , int offset ) { int value = byteToUnsigned ( b [ offset ++ ] ) ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.OBBN2Mutator]MSP[]
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; MST[rv.CRCR6Mutator]MSP[] } t = left ; left = right ; right = t ; } t = right ; right = left >>> 1 | left << 31 ;
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[MathMutator]MSP[] c &= 0xfffffff ; int j = 0 ;
b [ offset ++ ] = (byte) ( iValue >>> 16 & 0xff ) ; MST[rv.UOI1Mutator]MSP[] b [ offset ++ ] = (byte) ( iValue >>> 24 & 0xff ) ; }
left = results [ 1 ] ; permOp ( left , right , 16 , 65535 , results ) ; MST[rv.CRCR4Mutator]MSP[] left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 4 , 0xf0f0f0f , results ) ;
right = results [ 0 ] ; left = results [ 1 ] ; final int out [] = new int [ 2 ] ; MST[InlineConstantMutator]MSP[] out [ 0 ] = left ; out [ 1 ] = right ; return out ; }
} else if ( ! salt . matches ( lr_2 + B64 . B64T_STRING + lr_3 ) ) { throw new IllegalArgumentException ( lr_4 + salt ) ; } final StringBuilder buffer = new StringBuilder ( lr_5 ) ; final char charZero = salt . charAt ( 0 ) ; MST[NonVoidMethodCallMutator]MSP[]
int c = 0 ; MST[rv.CRCR1Mutator]MSP[] for (; j < 6 ; j ++ ) { c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) {
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.ABSMutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; MST[rv.UOI3Mutator]MSP[] } u >>>= 1 ; if ( u == 0 ) {
left = results [ 1 ] ; permOp ( left , right , 16 , 65535 , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; MST[rv.UOI4Mutator]MSP[] permOp ( right , left , 4 , 0xf0f0f0f , results ) ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.UOI1Mutator]MSP[]
private static void permOp ( int a , int b , final int n , final int m , final int results [] ) { final int t = ( a >>> n ^ b ) & m ; MST[rv.UOI4Mutator]MSP[] a ^= t << n ; b ^= t ;
d = hPermOp ( d , - 2 , 0xcccc0000 ) ; permOp ( d , c , 1 , 0x55555555 , results ) ; MST[rv.CRCR6Mutator]MSP[] d = results [ 0 ] ; c = results [ 1 ] ;
private static void permOp ( int a , int b , final int n , final int m , final int results [] ) { final int t = ( a >>> n ^ b ) & m ; a ^= t << n ; MST[rv.ABSMutator]MSP[] b ^= t ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.UOI3Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
final char charOne = salt . charAt ( 1 ) ; buffer . setCharAt ( 0 , charZero ) ; buffer . setCharAt ( 1 , charOne ) ; final int eSwap0 = CON_SALT [ charZero ] ; final int eSwap1 = CON_SALT [ charOne ] << 4 ; MST[InlineConstantMutator]MSP[]
c = c >>> 1 | c << 27 ; d = d >>> 1 | d << 27 ; MST[rv.CRCR4Mutator]MSP[] } c &= 0xfffffff ; d &= 0xfffffff ;
final char charOne = salt . charAt ( 1 ) ; buffer . setCharAt ( 0 , charZero ) ; buffer . setCharAt ( 1 , charOne ) ; final int eSwap0 = CON_SALT [ charZero ] ; final int eSwap1 = CON_SALT [ charOne ] << 4 ; MST[rv.ABSMutator]MSP[]
final int schedule [] = desSetKey ( key ) ; final int out [] = body ( schedule , eSwap0 , eSwap1 ) ; MST[rv.UOI4Mutator]MSP[] final byte b [] = new byte [ 9 ] ; intToFourBytes ( out [ 0 ] , b , 0 ) ;
intToFourBytes ( out [ 1 ] , b , 4 ) ; b [ 8 ] = 0 ; int i = 2 ; int y = 0 ; int u = 128 ; MST[rv.CRCR2Mutator]MSP[] for (; i < 13 ; i ++ ) { int j = 0 ;
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; MST[rv.UOI1Mutator]MSP[] value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; return value ; }
intToFourBytes ( out [ 1 ] , b , 4 ) ; b [ 8 ] = 0 ; int i = 2 ; int y = 0 ; int u = 128 ; MST[rv.CRCR5Mutator]MSP[] for (; i < 13 ; i ++ ) { int j = 0 ;
private static int [] body ( final int schedule [] , final int eSwap0 , final int eSwap1 ) { int left = 0 ; MST[rv.CRCR3Mutator]MSP[] int right = 0 ; int t = 0 ; for ( int j = 0 ; j < 25 ; j ++ ) {
left = results [ 1 ] ; MST[rv.UOI3Mutator]MSP[] permOp ( left , right , 16 , 65535 , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 4 , 0xf0f0f0f , results ) ;
left = results [ 1 ] ; permOp ( left , right , 16 , 65535 , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 4 , 0xf0f0f0f , results ) ; MST[rv.CRCR2Mutator]MSP[]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.ABSMutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR1Mutator]MSP[]
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; } t = left ; left = right ; right = t ; } t = right ; right = left >>> 1 | left << 31 ; MST[rv.UOI3Mutator]MSP[]
private static int [] body ( final int schedule [] , final int eSwap0 , final int eSwap1 ) { int left = 0 ; int right = 0 ; int t = 0 ; for ( int j = 0 ; j < 25 ; j ++ ) { MST[NegateConditionalsMutator]MSP[]
permOp ( left , right , 8 , 0xff00ff , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; MST[rv.UOI2Mutator]MSP[] permOp ( right , left , 2 , 0x33333333 , results ) ; right = results [ 0 ] ;
permOp ( d , c , 4 , 0xf0f0f0f , results ) ; MST[rv.CRCR6Mutator]MSP[] d = results [ 0 ] ; c = results [ 1 ] ; c = hPermOp ( c , - 2 , 0xcccc0000 ) ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[InlineConstantMutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR6Mutator]MSP[]
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; MST[rv.UOI2Mutator]MSP[] } t = left ; left = right ; right = t ; } t = right ; right = left >>> 1 | left << 31 ;
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; } t = left ; left = right ; right = t ; } t = right ; right = left >>> 1 | left << 31 ; MST[rv.OBBN1Mutator]MSP[]
c = results [ 1 ] ; MST[rv.CRCR2Mutator]MSP[] d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; c &= 0xfffffff ; int j = 0 ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.UOI1Mutator]MSP[]
y ++ ; u = 128 ; } buffer . setCharAt ( i , ( char ) COV2CHAR [ c ] ) ; MST[rv.UOI1Mutator]MSP[] } } return buffer . toString () ; } public static String crypt ( final String original ) {
left = results [ 1 ] ; permOp ( left , right , 16 , 65535 , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 4 , 0xf0f0f0f , results ) ; MST[rv.CRCR5Mutator]MSP[]
for ( int i = 0 ; i < key . length && i < original . length ; i ++ ) { MST[rv.CRCR5Mutator]MSP[] final int iChar = original [ i ] ; key [ i ] = (byte) ( iChar << 1 ) ; }
private static void intToFourBytes ( final int iValue , final byte b [] , int offset ) { b [ offset ++ ] = (byte) ( iValue & 0xff ) ; b [ offset ++ ] = (byte) ( iValue >>> 8 & 0xff ) ; MST[rv.CRCR4Mutator]MSP[]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.ABSMutator]MSP[]
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.UOI2Mutator]MSP[]
left = t >>> 1 | t << 31 ; final int results [] = new int [ 2 ] ; permOp ( right , left , 1 , 0x55555555 , results ) ; right = results [ 0 ] ; left = results [ 1 ] ; MST[rv.CRCR4Mutator]MSP[]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR4Mutator]MSP[]
permOp ( left , right , 8 , 0xff00ff , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 2 , 0x33333333 , results ) ; right = results [ 0 ] ; MST[rv.UOI1Mutator]MSP[]
final char charOne = salt . charAt ( 1 ) ; buffer . setCharAt ( 0 , charZero ) ; buffer . setCharAt ( 1 , charOne ) ; final int eSwap0 = CON_SALT [ charZero ] ; final int eSwap1 = CON_SALT [ charOne ] << 4 ; MST[rv.UOI1Mutator]MSP[]
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; MST[rv.OBBN2Mutator]MSP[] return value ; }
d = hPermOp ( d , - 2 , 0xcccc0000 ) ; permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ; MST[InlineConstantMutator]MSP[] c = results [ 1 ] ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR6Mutator]MSP[]
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; MST[rv.ABSMutator]MSP[] a = a ^ t ^ t >>> 16 - n ; return a ; }
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.UOI4Mutator]MSP[]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR3Mutator]MSP[]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.UOI1Mutator]MSP[]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR4Mutator]MSP[]
left = t >>> 1 | t << 31 ; final int results [] = new int [ 2 ] ; MST[rv.CRCR3Mutator]MSP[] permOp ( right , left , 1 , 0x55555555 , results ) ; right = results [ 0 ] ; left = results [ 1 ] ;
left = results [ 1 ] ; permOp ( left , right , 16 , 65535 , results ) ; MST[rv.CRCR1Mutator]MSP[] left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 4 , 0xf0f0f0f , results ) ;
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; MST[rv.UOI4Mutator]MSP[] a = a ^ t ^ t >>> 16 - n ; return a ; }
int c = 0 ; for (; j < 6 ; j ++ ) { MST[rv.CRCR6Mutator]MSP[] c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) {
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.CRCR4Mutator]MSP[] c &= 0xfffffff ; int j = 0 ;
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; c &= 0xfffffff ; int j = 0 ; MST[InlineConstantMutator]MSP[]
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; MST[rv.UOI4Mutator]MSP[] return value ; }
private static int [] body ( final int schedule [] , final int eSwap0 , final int eSwap1 ) { int left = 0 ; int right = 0 ; int t = 0 ; for ( int j = 0 ; j < 25 ; j ++ ) { MST[rv.CRCR3Mutator]MSP[]
for ( int i = 0 ; i < 32 ; i += 4 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] left = dEncrypt ( left , right , i , eSwap0 , eSwap1 , schedule ) ;
private static int dEncrypt ( int el , final int r , final int s , final int e0 , final int e1 , final int sArr [] ) { int v = r ^ r >>> 16 ; MST[rv.UOI4Mutator]MSP[] int u = v & e0 ; v &= e1 ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.ABSMutator]MSP[]
for ( int i = 0 ; i < 32 ; i += 4 ) { MST[rv.CRCR6Mutator]MSP[] left = dEncrypt ( left , right , i , eSwap0 , eSwap1 , schedule ) ;
int c = 0 ; for (; j < 6 ; j ++ ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) {
return crypt ( original . getBytes ( StandardCharsets . UTF_8 ) ) ; MST[NonVoidMethodCallMutator]MSP[] } public static String crypt ( final String original , final String salt ) { return crypt ( original . getBytes ( StandardCharsets . UTF_8 ) , salt ) ; }
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; } t = left ; left = right ; MST[rv.UOI3Mutator]MSP[] right = t ; } t = right ; right = left >>> 1 | left << 31 ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.OBBN3Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.OBBN2Mutator]MSP[]
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { MST[rv.UOI4Mutator]MSP[] c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) {
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR6Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
u = u ^ u << 16 ^ r ^ sArr [ s ] ; MST[rv.CRCR3Mutator]MSP[] int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; t = t >>> 4 | t << 28 ;
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { MST[rv.OBBN2Mutator]MSP[] c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) {
left = t >>> 1 | t << 31 ; MST[MathMutator]MSP[] final int results [] = new int [ 2 ] ; permOp ( right , left , 1 , 0x55555555 , results ) ; right = results [ 0 ] ; left = results [ 1 ] ;
permOp ( c , d , 8 , 0xff00ff , results ) ; c = results [ 0 ] ; d = results [ 1 ] ; MST[InlineConstantMutator]MSP[] permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ;
private static int [] body ( final int schedule [] , final int eSwap0 , final int eSwap1 ) { int left = 0 ; int right = 0 ; int t = 0 ; for ( int j = 0 ; j < 25 ; j ++ ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR5Mutator]MSP[]
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { MST[NegateConditionalsMutator]MSP[] c = c >>> 2 | c << 26 ; d = d >>> 2 | d << 26 ; } else {
private static void permOp ( int a , int b , final int n , final int m , final int results [] ) { final int t = ( a >>> n ^ b ) & m ; MST[rv.OBBN1Mutator]MSP[] a ^= t << n ; b ^= t ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.ABSMutator]MSP[]
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { MST[rv.ABSMutator]MSP[] c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) {
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.UOI3Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
for ( int i = 0 ; i < 16 ; i ++ ) { MST[rv.CRCR5Mutator]MSP[] if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; d = d >>> 2 | d << 26 ; } else {
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.OBBN2Mutator]MSP[] c &= 0xfffffff ; int j = 0 ;
SKB [ 7 ] [ d >>> 21 & 0xf | d >>> 22 & 0x30 ] ; schedule [ j ++ ] = ( t << 16 | s & 0xffff ) ; s = s >>> 16 | t & 0xffff0000 ; MST[rv.CRCR3Mutator]MSP[]
final int schedule [] = desSetKey ( key ) ; final int out [] = body ( schedule , eSwap0 , eSwap1 ) ; final byte b [] = new byte [ 9 ] ; intToFourBytes ( out [ 0 ] , b , 0 ) ; MST[rv.CRCR1Mutator]MSP[]
private static int dEncrypt ( int el , final int r , final int s , final int e0 , final int e1 , final int sArr [] ) { int v = r ^ r >>> 16 ; int u = v & e0 ; v &= e1 ; MST[rv.OBBN1Mutator]MSP[]
intToFourBytes ( out [ 1 ] , b , 4 ) ; MST[rv.CRCR5Mutator]MSP[] b [ 8 ] = 0 ; int i = 2 ; int y = 0 ; int u = 128 ; for (; i < 13 ; i ++ ) { int j = 0 ;
right = results [ 0 ] ; left = results [ 1 ] ; final int out [] = new int [ 2 ] ; out [ 0 ] = left ; out [ 1 ] = right ; MST[rv.ABSMutator]MSP[] return out ; }
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR4Mutator]MSP[]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.UOI3Mutator]MSP[]
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; d = d >>> 2 | d << 26 ; MST[MathMutator]MSP[] } else {
private static int dEncrypt ( int el , final int r , final int s , final int e0 , final int e1 , final int sArr [] ) { int v = r ^ r >>> 16 ; MST[rv.CRCR2Mutator]MSP[] int u = v & e0 ; v &= e1 ;
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.UOI4Mutator]MSP[] c &= 0xfffffff ; int j = 0 ;
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; a = a ^ t ^ t >>> 16 - n ; MST[rv.UOI4Mutator]MSP[] return a ; }
b [ offset ++ ] = (byte) ( iValue >>> 16 & 0xff ) ; MST[MathMutator]MSP[] b [ offset ++ ] = (byte) ( iValue >>> 24 & 0xff ) ; }
final char charOne = salt . charAt ( 1 ) ; MST[InlineConstantMutator]MSP[] buffer . setCharAt ( 0 , charZero ) ; buffer . setCharAt ( 1 , charOne ) ; final int eSwap0 = CON_SALT [ charZero ] ; final int eSwap1 = CON_SALT [ charOne ] << 4 ;
for ( int i = 0 ; i < 32 ; i += 4 ) { MST[rv.CRCR3Mutator]MSP[] left = dEncrypt ( left , right , i , eSwap0 , eSwap1 , schedule ) ;
final int numSaltChars = SALT_CHARS . length ; salt = lr_1 + SALT_CHARS [ randomGenerator . nextInt ( numSaltChars ) ] + SALT_CHARS [ randomGenerator . nextInt ( numSaltChars ) ] ; MST[ArgumentPropagationMutator]MSP[]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR5Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; a = a ^ t ^ t >>> 16 - n ; MST[rv.UOI2Mutator]MSP[] return a ; }
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR3Mutator]MSP[]
final byte key [] = new byte [ 8 ] ; for ( int i = 0 ; i < key . length ; i ++ ) { MST[rv.CRCR5Mutator]MSP[] key [ i ] = 0 ; }
b [ offset ++ ] = (byte) ( iValue >>> 16 & 0xff ) ; MST[rv.UOI3Mutator]MSP[] b [ offset ++ ] = (byte) ( iValue >>> 24 & 0xff ) ; }
final byte key [] = new byte [ 8 ] ; MST[rv.CRCR2Mutator]MSP[] for ( int i = 0 ; i < key . length ; i ++ ) { key [ i ] = 0 ; }
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[InlineConstantMutator]MSP[]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[MathMutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
int c = 0 ; for (; j < 6 ; j ++ ) { MST[rv.CRCR3Mutator]MSP[] c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) {
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; MST[rv.UOI1Mutator]MSP[] } t = left ; left = right ; right = t ; } t = right ; right = left >>> 1 | left << 31 ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.UOI4Mutator]MSP[]
final char charOne = salt . charAt ( 1 ) ; buffer . setCharAt ( 0 , charZero ) ; MST[rv.ABSMutator]MSP[] buffer . setCharAt ( 1 , charOne ) ; final int eSwap0 = CON_SALT [ charZero ] ; final int eSwap1 = CON_SALT [ charOne ] << 4 ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.UOI1Mutator]MSP[]
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; } t = left ; left = right ; right = t ; } t = right ; right = left >>> 1 | left << 31 ; MST[InlineConstantMutator]MSP[]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.UOI4Mutator]MSP[]
private static void permOp ( int a , int b , final int n , final int m , final int results [] ) { final int t = ( a >>> n ^ b ) & m ; MST[rv.UOI2Mutator]MSP[] a ^= t << n ; b ^= t ;
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; d = d >>> 2 | d << 26 ; MST[rv.UOI3Mutator]MSP[] } else {
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; MST[rv.ABSMutator]MSP[] value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; return value ; }
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR2Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; MST[NonVoidMethodCallMutator]MSP[] } t = left ; left = right ; right = t ; } t = right ; right = left >>> 1 | left << 31 ;
private static int [] body ( final int schedule [] , final int eSwap0 , final int eSwap1 ) { int left = 0 ; int right = 0 ; int t = 0 ; for ( int j = 0 ; j < 25 ; j ++ ) { MST[ConditionalsBoundaryMutator]MSP[]
permOp ( left , right , 8 , 0xff00ff , results ) ; MST[rv.UOI1Mutator]MSP[] left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 2 , 0x33333333 , results ) ; right = results [ 0 ] ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR6Mutator]MSP[]
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; a = a ^ t ^ t >>> 16 - n ; MST[rv.CRCR4Mutator]MSP[] return a ; }
for ( int i = 0 ; i < key . length && i < original . length ; i ++ ) { final int iChar = original [ i ] ; key [ i ] = (byte) ( iChar << 1 ) ; MST[rv.CRCR4Mutator]MSP[] }
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; t = t >>> 4 | t << 28 ; MST[rv.OBBN3Mutator]MSP[]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.OBBN2Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.UOI3Mutator]MSP[]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[MathMutator]MSP[]
int c = 0 ; for (; j < 6 ; j ++ ) { MST[rv.UOI1Mutator]MSP[] c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) {
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR4Mutator]MSP[]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR5Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
permOp ( c , d , 8 , 0xff00ff , results ) ; c = results [ 0 ] ; d = results [ 1 ] ; permOp ( d , c , 1 , 0x55555555 , results ) ; MST[rv.UOI4Mutator]MSP[] d = results [ 0 ] ;
right = results [ 0 ] ; left = results [ 1 ] ; MST[rv.ABSMutator]MSP[] final int out [] = new int [ 2 ] ; out [ 0 ] = left ; out [ 1 ] = right ; return out ; }
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; MST[rv.UOI4Mutator]MSP[] value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; return value ; }
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR6Mutator]MSP[]
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.CRCR1Mutator]MSP[] c &= 0xfffffff ; int j = 0 ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.UOI1Mutator]MSP[]
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.OBBN3Mutator]MSP[] c &= 0xfffffff ; int j = 0 ;
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; MST[rv.CRCR3Mutator]MSP[] } t = left ; left = right ; right = t ; } t = right ; right = left >>> 1 | left << 31 ;
intToFourBytes ( out [ 1 ] , b , 4 ) ; MST[rv.CRCR6Mutator]MSP[] b [ 8 ] = 0 ; int i = 2 ; int y = 0 ; int u = 128 ; for (; i < 13 ; i ++ ) { int j = 0 ;
private static void intToFourBytes ( final int iValue , final byte b [] , int offset ) { b [ offset ++ ] = (byte) ( iValue & 0xff ) ; b [ offset ++ ] = (byte) ( iValue >>> 8 & 0xff ) ; MST[rv.CRCR6Mutator]MSP[]
} else if ( ! salt . matches ( lr_2 + B64 . B64T_STRING + lr_3 ) ) { throw new IllegalArgumentException ( lr_4 + salt ) ; } final StringBuilder buffer = new StringBuilder ( lr_5 ) ; final char charZero = salt . charAt ( 0 ) ; MST[rv.CRCR1Mutator]MSP[]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR5Mutator]MSP[]
for ( int i = 0 ; i < 32 ; i += 4 ) { MST[rv.UOI1Mutator]MSP[] left = dEncrypt ( left , right , i , eSwap0 , eSwap1 , schedule ) ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.UOI2Mutator]MSP[]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR4Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR1Mutator]MSP[]
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.OBBN3Mutator]MSP[]
private static void permOp ( int a , int b , final int n , final int m , final int results [] ) { final int t = ( a >>> n ^ b ) & m ; a ^= t << n ; MST[rv.UOI1Mutator]MSP[] b ^= t ;
c = c >>> 1 | c << 27 ; MST[rv.UOI1Mutator]MSP[] d = d >>> 1 | d << 27 ; } c &= 0xfffffff ; d &= 0xfffffff ;
private static void permOp ( int a , int b , final int n , final int m , final int results [] ) { final int t = ( a >>> n ^ b ) & m ; a ^= t << n ; b ^= t ; MST[rv.UOI2Mutator]MSP[]
final char charOne = salt . charAt ( 1 ) ; buffer . setCharAt ( 0 , charZero ) ; buffer . setCharAt ( 1 , charOne ) ; MST[VoidMethodCallMutator]MSP[] final int eSwap0 = CON_SALT [ charZero ] ; final int eSwap1 = CON_SALT [ charOne ] << 4 ;
left = t >>> 1 | t << 31 ; final int results [] = new int [ 2 ] ; permOp ( right , left , 1 , 0x55555555 , results ) ; right = results [ 0 ] ; MST[rv.UOI2Mutator]MSP[] left = results [ 1 ] ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR3Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
final int schedule [] = desSetKey ( key ) ; final int out [] = body ( schedule , eSwap0 , eSwap1 ) ; final byte b [] = new byte [ 9 ] ; MST[rv.CRCR6Mutator]MSP[] intToFourBytes ( out [ 0 ] , b , 0 ) ;
c = c >>> 1 | c << 27 ; d = d >>> 1 | d << 27 ; } c &= 0xfffffff ; d &= 0xfffffff ; MST[rv.CRCR1Mutator]MSP[]
y ++ ; u = 128 ; MST[InlineConstantMutator]MSP[] } buffer . setCharAt ( i , ( char ) COV2CHAR [ c ] ) ; } } return buffer . toString () ; } public static String crypt ( final String original ) {
for ( int i = 0 ; i < key . length && i < original . length ; i ++ ) { final int iChar = original [ i ] ; MST[rv.UOI4Mutator]MSP[] key [ i ] = (byte) ( iChar << 1 ) ; }
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.OBBN3Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.UOI4Mutator]MSP[]
u = u ^ u << 16 ^ r ^ sArr [ s ] ; MST[rv.UOI1Mutator]MSP[] int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; t = t >>> 4 | t << 28 ;
u = u ^ u << 16 ^ r ^ sArr [ s ] ; MST[rv.UOI2Mutator]MSP[] int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; t = t >>> 4 | t << 28 ;
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; MST[rv.UOI2Mutator]MSP[] a = a ^ t ^ t >>> 16 - n ; return a ; }
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[InlineConstantMutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR1Mutator]MSP[]
left = t >>> 1 | t << 31 ; final int results [] = new int [ 2 ] ; permOp ( right , left , 1 , 0x55555555 , results ) ; right = results [ 0 ] ; left = results [ 1 ] ; MST[rv.UOI4Mutator]MSP[]
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.CRCR1Mutator]MSP[] c &= 0xfffffff ; int j = 0 ;
b [ offset ++ ] = (byte) ( iValue >>> 16 & 0xff ) ; b [ offset ++ ] = (byte) ( iValue >>> 24 & 0xff ) ; MST[rv.CRCR2Mutator]MSP[] }
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[MathMutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
permOp ( left , right , 8 , 0xff00ff , results ) ; MST[rv.CRCR2Mutator]MSP[] left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 2 , 0x33333333 , results ) ; right = results [ 0 ] ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.UOI3Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; t = t >>> 4 | t << 28 ; MST[MathMutator]MSP[]
permOp ( c , d , 8 , 0xff00ff , results ) ; c = results [ 0 ] ; d = results [ 1 ] ; MST[rv.UOI1Mutator]MSP[] permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ;
SKB [ 7 ] [ d >>> 21 & 0xf | d >>> 22 & 0x30 ] ; schedule [ j ++ ] = ( t << 16 | s & 0xffff ) ; s = s >>> 16 | t & 0xffff0000 ; MST[rv.UOI1Mutator]MSP[]
right = results [ 0 ] ; left = results [ 1 ] ; MST[rv.CRCR5Mutator]MSP[] final int out [] = new int [ 2 ] ; out [ 0 ] = left ; out [ 1 ] = right ; return out ; }
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; MST[rv.UOI4Mutator]MSP[] d = d >>> 2 | d << 26 ; } else {
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; MST[rv.OBBN2Mutator]MSP[] d = d >>> 2 | d << 26 ; } else {
left = results [ 1 ] ; permOp ( left , right , 16 , 65535 , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 4 , 0xf0f0f0f , results ) ; MST[rv.CRCR1Mutator]MSP[]
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.UOI2Mutator]MSP[]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR4Mutator]MSP[]
d = hPermOp ( d , - 2 , 0xcccc0000 ) ; permOp ( d , c , 1 , 0x55555555 , results ) ; MST[rv.CRCR3Mutator]MSP[] d = results [ 0 ] ; c = results [ 1 ] ;
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; t = t >>> 4 | t << 28 ; MST[InlineConstantMutator]MSP[]
permOp ( c , d , 8 , 0xff00ff , results ) ; MST[rv.CRCR4Mutator]MSP[] c = results [ 0 ] ; d = results [ 1 ] ; permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ;
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; MST[MathMutator]MSP[] } u >>>= 1 ; if ( u == 0 ) {
left = results [ 1 ] ; permOp ( left , right , 16 , 65535 , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; MST[rv.CRCR4Mutator]MSP[] permOp ( right , left , 4 , 0xf0f0f0f , results ) ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[MathMutator]MSP[]
final char charOne = salt . charAt ( 1 ) ; buffer . setCharAt ( 0 , charZero ) ; buffer . setCharAt ( 1 , charOne ) ; final int eSwap0 = CON_SALT [ charZero ] ; MST[rv.UOI3Mutator]MSP[] final int eSwap1 = CON_SALT [ charOne ] << 4 ;
for ( int i = 0 ; i < key . length && i < original . length ; i ++ ) { final int iChar = original [ i ] ; key [ i ] = (byte) ( iChar << 1 ) ; MST[rv.UOI2Mutator]MSP[] }
permOp ( d , c , 4 , 0xf0f0f0f , results ) ; d = results [ 0 ] ; c = results [ 1 ] ; c = hPermOp ( c , - 2 , 0xcccc0000 ) ; MST[rv.CRCR2Mutator]MSP[]
private static int byteToUnsigned ( final byte b ) { final int value = b ; return value < 0 ? value + 256 : value ; MST[PrimitiveReturnsMutator]MSP[] }
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR3Mutator]MSP[]
permOp ( d , c , 4 , 0xf0f0f0f , results ) ; d = results [ 0 ] ; c = results [ 1 ] ; c = hPermOp ( c , - 2 , 0xcccc0000 ) ; MST[InlineConstantMutator]MSP[]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR6Mutator]MSP[]
permOp ( c , d , 8 , 0xff00ff , results ) ; c = results [ 0 ] ; d = results [ 1 ] ; permOp ( d , c , 1 , 0x55555555 , results ) ; MST[rv.CRCR5Mutator]MSP[] d = results [ 0 ] ;
left = results [ 1 ] ; MST[rv.CRCR3Mutator]MSP[] permOp ( left , right , 16 , 65535 , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 4 , 0xf0f0f0f , results ) ;
private static int byteToUnsigned ( final byte b ) { final int value = b ; return value < 0 ? value + 256 : value ; MST[rv.UOI2Mutator]MSP[] }
permOp ( left , right , 8 , 0xff00ff , results ) ; MST[InlineConstantMutator]MSP[] left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 2 , 0x33333333 , results ) ; right = results [ 0 ] ;
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.UOI2Mutator]MSP[] c &= 0xfffffff ; int j = 0 ;
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; MST[rv.CRCR6Mutator]MSP[] value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; return value ; }
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.OBBN1Mutator]MSP[]
final byte key [] = new byte [ 8 ] ; for ( int i = 0 ; i < key . length ; i ++ ) { MST[rv.ROR2Mutator]MSP[] key [ i ] = 0 ; }
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR2Mutator]MSP[]
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; MST[experimental.RemoveIncrementsMutator]MSP[] value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; return value ; }
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; MST[rv.UOI2Mutator]MSP[] } t = left ; left = right ; right = t ; } t = right ; right = left >>> 1 | left << 31 ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.OBBN3Mutator]MSP[]
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; MST[MathMutator]MSP[] t = t >>> 4 | t << 28 ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.ABSMutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
right = results [ 0 ] ; left = results [ 1 ] ; final int out [] = new int [ 2 ] ; out [ 0 ] = left ; out [ 1 ] = right ; MST[rv.CRCR5Mutator]MSP[] return out ; }
results [ 0 ] = a ; results [ 1 ] = b ; MST[InlineConstantMutator]MSP[] }
right = results [ 0 ] ; left = results [ 1 ] ; final int out [] = new int [ 2 ] ; MST[rv.CRCR1Mutator]MSP[] out [ 0 ] = left ; out [ 1 ] = right ; return out ; }
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR1Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; MST[rv.CRCR2Mutator]MSP[] t = t >>> 4 | t << 28 ;
left = results [ 1 ] ; permOp ( left , right , 16 , 65535 , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 4 , 0xf0f0f0f , results ) ; MST[rv.UOI4Mutator]MSP[]
private static int byteToUnsigned ( final byte b ) { final int value = b ; return value < 0 ? value + 256 : value ; MST[rv.CRCR2Mutator]MSP[] }
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; MST[rv.UOI1Mutator]MSP[] value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; return value ; }
final int schedule [] = new int [ 32 ] ; int c = fourBytesToInt ( key , 0 ) ; int d = fourBytesToInt ( key , 4 ) ; MST[NonVoidMethodCallMutator]MSP[] final int results [] = new int [ 2 ] ;
results [ 0 ] = a ; MST[rv.CRCR6Mutator]MSP[] results [ 1 ] = b ; }
b [ offset ++ ] = (byte) ( iValue >>> 16 & 0xff ) ; MST[rv.CRCR5Mutator]MSP[] b [ offset ++ ] = (byte) ( iValue >>> 24 & 0xff ) ; }
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.UOI2Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
intToFourBytes ( out [ 1 ] , b , 4 ) ; b [ 8 ] = 0 ; int i = 2 ; int y = 0 ; MST[rv.CRCR5Mutator]MSP[] int u = 128 ; for (; i < 13 ; i ++ ) { int j = 0 ;
left = results [ 1 ] ; permOp ( left , right , 16 , 65535 , results ) ; MST[rv.UOI3Mutator]MSP[] left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 4 , 0xf0f0f0f , results ) ;
permOp ( left , right , 8 , 0xff00ff , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 2 , 0x33333333 , results ) ; MST[rv.UOI2Mutator]MSP[] right = results [ 0 ] ;
for ( int i = 0 ; i < 16 ; i ++ ) { MST[rv.ROR3Mutator]MSP[] if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; d = d >>> 2 | d << 26 ; } else {
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.OBBN3Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.UOI3Mutator]MSP[]
private static void intToFourBytes ( final int iValue , final byte b [] , int offset ) { b [ offset ++ ] = (byte) ( iValue & 0xff ) ; MST[rv.CRCR2Mutator]MSP[] b [ offset ++ ] = (byte) ( iValue >>> 8 & 0xff ) ;
SKB [ 7 ] [ d >>> 21 & 0xf | d >>> 22 & 0x30 ] ; schedule [ j ++ ] = ( t << 16 | s & 0xffff ) ; s = s >>> 16 | t & 0xffff0000 ; MST[rv.CRCR2Mutator]MSP[]
private static int byteToUnsigned ( final byte b ) { final int value = b ; MST[rv.ABSMutator]MSP[] return value < 0 ? value + 256 : value ; }
intToFourBytes ( out [ 1 ] , b , 4 ) ; MST[rv.ABSMutator]MSP[] b [ 8 ] = 0 ; int i = 2 ; int y = 0 ; int u = 128 ; for (; i < 13 ; i ++ ) { int j = 0 ;
intToFourBytes ( out [ 1 ] , b , 4 ) ; b [ 8 ] = 0 ; int i = 2 ; int y = 0 ; int u = 128 ; for (; i < 13 ; i ++ ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[] int j = 0 ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.OBBN1Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[InlineConstantMutator]MSP[]
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR5Mutator]MSP[]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.OBBN1Mutator]MSP[]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.OBBN3Mutator]MSP[]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR6Mutator]MSP[]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.UOI4Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[MathMutator]MSP[]
for ( int i = 0 ; i < key . length && i < original . length ; i ++ ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[] final int iChar = original [ i ] ; key [ i ] = (byte) ( iChar << 1 ) ; }
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; MST[rv.UOI2Mutator]MSP[] return value ; }
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.ABSMutator]MSP[]
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.CRCR6Mutator]MSP[] c &= 0xfffffff ; int j = 0 ;
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; MST[MathMutator]MSP[] value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; return value ; }
final int schedule [] = desSetKey ( key ) ; final int out [] = body ( schedule , eSwap0 , eSwap1 ) ; final byte b [] = new byte [ 9 ] ; intToFourBytes ( out [ 0 ] , b , 0 ) ; MST[rv.UOI1Mutator]MSP[]
left = t >>> 1 | t << 31 ; MST[rv.OBBN3Mutator]MSP[] final int results [] = new int [ 2 ] ; permOp ( right , left , 1 , 0x55555555 , results ) ; right = results [ 0 ] ; left = results [ 1 ] ;
final int schedule [] = new int [ 32 ] ; int c = fourBytesToInt ( key , 0 ) ; int d = fourBytesToInt ( key , 4 ) ; MST[rv.CRCR3Mutator]MSP[] final int results [] = new int [ 2 ] ;
final int schedule [] = new int [ 32 ] ; int c = fourBytesToInt ( key , 0 ) ; MST[rv.CRCR1Mutator]MSP[] int d = fourBytesToInt ( key , 4 ) ; final int results [] = new int [ 2 ] ;
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; } t = left ; left = right ; right = t ; MST[rv.UOI3Mutator]MSP[] } t = right ; right = left >>> 1 | left << 31 ;
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { MST[rv.ROR5Mutator]MSP[] c = c >>> 2 | c << 26 ; d = d >>> 2 | d << 26 ; } else {
c = c >>> 1 | c << 27 ; MST[rv.CRCR2Mutator]MSP[] d = d >>> 1 | d << 27 ; } c &= 0xfffffff ; d &= 0xfffffff ;
c = c >>> 1 | c << 27 ; MST[rv.CRCR3Mutator]MSP[] d = d >>> 1 | d << 27 ; } c &= 0xfffffff ; d &= 0xfffffff ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.OBBN3Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.UOI2Mutator]MSP[]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR2Mutator]MSP[]
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[MathMutator]MSP[]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR3Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
right = results [ 0 ] ; MST[rv.CRCR5Mutator]MSP[] left = results [ 1 ] ; final int out [] = new int [ 2 ] ; out [ 0 ] = left ; out [ 1 ] = right ; return out ; }
permOp ( c , d , 8 , 0xff00ff , results ) ; c = results [ 0 ] ; MST[rv.CRCR6Mutator]MSP[] d = results [ 1 ] ; permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ;
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { MST[NegateConditionalsMutator]MSP[] c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) {
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; c &= 0xfffffff ; int j = 0 ; MST[rv.CRCR5Mutator]MSP[]
SKB [ 7 ] [ d >>> 21 & 0xf | d >>> 22 & 0x30 ] ; schedule [ j ++ ] = ( t << 16 | s & 0xffff ) ; MST[rv.UOI1Mutator]MSP[] s = s >>> 16 | t & 0xffff0000 ;
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[MathMutator]MSP[] c &= 0xfffffff ; int j = 0 ;
c = c >>> 1 | c << 27 ; MST[rv.OBBN2Mutator]MSP[] d = d >>> 1 | d << 27 ; } c &= 0xfffffff ; d &= 0xfffffff ;
for ( int i = 0 ; i < 32 ; i += 4 ) { left = dEncrypt ( left , right , i , eSwap0 , eSwap1 , schedule ) ; MST[rv.UOI1Mutator]MSP[]
return crypt ( original . getBytes ( StandardCharsets . UTF_8 ) ) ; MST[ReturnValsMutator]MSP[] } public static String crypt ( final String original , final String salt ) { return crypt ( original . getBytes ( StandardCharsets . UTF_8 ) , salt ) ; }
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; MST[rv.CRCR6Mutator]MSP[] d = d >>> 2 | d << 26 ; } else {
s = s << 4 | s >>> 28 ; schedule [ j ++ ] = s ; } return schedule ; } private static int fourBytesToInt ( final byte b [] , int offset ) { int value = byteToUnsigned ( b [ offset ++ ] ) ; MST[rv.UOI1Mutator]MSP[]
final byte key [] = new byte [ 8 ] ; for ( int i = 0 ; i < key . length ; i ++ ) { key [ i ] = 0 ; MST[rv.CRCR5Mutator]MSP[] }
for ( int i = 0 ; i < 32 ; i += 4 ) { left = dEncrypt ( left , right , i , eSwap0 , eSwap1 , schedule ) ; MST[rv.ABSMutator]MSP[]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[InlineConstantMutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.OBBN1Mutator]MSP[]
final char charOne = salt . charAt ( 1 ) ; buffer . setCharAt ( 0 , charZero ) ; buffer . setCharAt ( 1 , charOne ) ; final int eSwap0 = CON_SALT [ charZero ] ; final int eSwap1 = CON_SALT [ charOne ] << 4 ; MST[rv.UOI3Mutator]MSP[]
c = c >>> 1 | c << 27 ; d = d >>> 1 | d << 27 ; MST[rv.UOI2Mutator]MSP[] } c &= 0xfffffff ; d &= 0xfffffff ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR4Mutator]MSP[]
permOp ( left , right , 8 , 0xff00ff , results ) ; MST[rv.UOI4Mutator]MSP[] left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 2 , 0x33333333 , results ) ; right = results [ 0 ] ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR1Mutator]MSP[]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.OBBN1Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.UOI4Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) { MST[rv.ROR5Mutator]MSP[]
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; a = a ^ t ^ t >>> 16 - n ; MST[MathMutator]MSP[] return a ; }
left = t >>> 1 | t << 31 ; final int results [] = new int [ 2 ] ; MST[rv.CRCR2Mutator]MSP[] permOp ( right , left , 1 , 0x55555555 , results ) ; right = results [ 0 ] ; left = results [ 1 ] ;
permOp ( d , c , 4 , 0xf0f0f0f , results ) ; MST[rv.CRCR3Mutator]MSP[] d = results [ 0 ] ; c = results [ 1 ] ; c = hPermOp ( c , - 2 , 0xcccc0000 ) ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR5Mutator]MSP[]
final char charOne = salt . charAt ( 1 ) ; buffer . setCharAt ( 0 , charZero ) ; MST[rv.UOI3Mutator]MSP[] buffer . setCharAt ( 1 , charOne ) ; final int eSwap0 = CON_SALT [ charZero ] ; final int eSwap1 = CON_SALT [ charOne ] << 4 ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.OBBN2Mutator]MSP[]
private static void intToFourBytes ( final int iValue , final byte b [] , int offset ) { b [ offset ++ ] = (byte) ( iValue & 0xff ) ; b [ offset ++ ] = (byte) ( iValue >>> 8 & 0xff ) ; MST[IncrementsMutator]MSP[]
for ( int i = 0 ; i < key . length && i < original . length ; i ++ ) { MST[rv.UOI4Mutator]MSP[] final int iChar = original [ i ] ; key [ i ] = (byte) ( iChar << 1 ) ; }
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR5Mutator]MSP[]
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.CRCR4Mutator]MSP[] c &= 0xfffffff ; int j = 0 ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.UOI2Mutator]MSP[]
private static int [] body ( final int schedule [] , final int eSwap0 , final int eSwap1 ) { int left = 0 ; int right = 0 ; int t = 0 ; for ( int j = 0 ; j < 25 ; j ++ ) { MST[rv.CRCR2Mutator]MSP[]
permOp ( left , right , 8 , 0xff00ff , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 2 , 0x33333333 , results ) ; right = results [ 0 ] ; MST[rv.CRCR3Mutator]MSP[]
permOp ( d , c , 4 , 0xf0f0f0f , results ) ; d = results [ 0 ] ; c = results [ 1 ] ; MST[rv.UOI2Mutator]MSP[] c = hPermOp ( c , - 2 , 0xcccc0000 ) ;
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; } u >>>= 1 ; MST[rv.UOI2Mutator]MSP[] if ( u == 0 ) {
right = results [ 0 ] ; left = results [ 1 ] ; final int out [] = new int [ 2 ] ; out [ 0 ] = left ; MST[rv.CRCR5Mutator]MSP[] out [ 1 ] = right ; return out ; }
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.ABSMutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; MST[rv.OBBN1Mutator]MSP[] value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; return value ; }
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.OBBN3Mutator]MSP[]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[MathMutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR1Mutator]MSP[]
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR6Mutator]MSP[]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.UOI4Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
left = t >>> 1 | t << 31 ; final int results [] = new int [ 2 ] ; permOp ( right , left , 1 , 0x55555555 , results ) ; MST[rv.UOI3Mutator]MSP[] right = results [ 0 ] ; left = results [ 1 ] ;
u = u ^ u << 16 ^ r ^ sArr [ s ] ; MST[rv.ABSMutator]MSP[] int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; t = t >>> 4 | t << 28 ;
final int schedule [] = desSetKey ( key ) ; final int out [] = body ( schedule , eSwap0 , eSwap1 ) ; final byte b [] = new byte [ 9 ] ; MST[InlineConstantMutator]MSP[] intToFourBytes ( out [ 0 ] , b , 0 ) ;
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; } u >>>= 1 ; MST[InlineConstantMutator]MSP[] if ( u == 0 ) {
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR2Mutator]MSP[]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR4Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR4Mutator]MSP[]
final int numSaltChars = SALT_CHARS . length ; salt = lr_1 + SALT_CHARS [ randomGenerator . nextInt ( numSaltChars ) ] + SALT_CHARS [ randomGenerator . nextInt ( numSaltChars ) ] ; MST[NonVoidMethodCallMutator]MSP[]
final int schedule [] = desSetKey ( key ) ; final int out [] = body ( schedule , eSwap0 , eSwap1 ) ; final byte b [] = new byte [ 9 ] ; intToFourBytes ( out [ 0 ] , b , 0 ) ; MST[rv.CRCR5Mutator]MSP[]
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; MST[InlineConstantMutator]MSP[] d = d >>> 2 | d << 26 ; } else {
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.UOI1Mutator]MSP[]
for ( int i = 0 ; i < 32 ; i += 4 ) { MST[rv.ROR5Mutator]MSP[] left = dEncrypt ( left , right , i , eSwap0 , eSwap1 , schedule ) ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR2Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
right = results [ 0 ] ; left = results [ 1 ] ; MST[InlineConstantMutator]MSP[] final int out [] = new int [ 2 ] ; out [ 0 ] = left ; out [ 1 ] = right ; return out ; }
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR5Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.UOI2Mutator]MSP[]
final byte key [] = new byte [ 8 ] ; MST[rv.CRCR5Mutator]MSP[] for ( int i = 0 ; i < key . length ; i ++ ) { key [ i ] = 0 ; }
final int numSaltChars = SALT_CHARS . length ; salt = lr_1 + SALT_CHARS [ randomGenerator . nextInt ( numSaltChars ) ] + MST[rv.UOI4Mutator]MSP[] SALT_CHARS [ randomGenerator . nextInt ( numSaltChars ) ] ;
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; a = a ^ t ^ t >>> 16 - n ; MST[rv.ABSMutator]MSP[] return a ; }
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; return value ; MST[rv.UOI4Mutator]MSP[] }
private static void intToFourBytes ( final int iValue , final byte b [] , int offset ) { b [ offset ++ ] = (byte) ( iValue & 0xff ) ; MST[rv.UOI2Mutator]MSP[] b [ offset ++ ] = (byte) ( iValue >>> 8 & 0xff ) ;
private static void permOp ( int a , int b , final int n , final int m , final int results [] ) { final int t = ( a >>> n ^ b ) & m ; a ^= t << n ; b ^= t ; MST[rv.ABSMutator]MSP[]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR6Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
d = hPermOp ( d , - 2 , 0xcccc0000 ) ; permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ; MST[rv.CRCR5Mutator]MSP[] c = results [ 1 ] ;
d = hPermOp ( d , - 2 , 0xcccc0000 ) ; permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ; c = results [ 1 ] ; MST[InlineConstantMutator]MSP[]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.UOI4Mutator]MSP[]
c = c >>> 1 | c << 27 ; d = d >>> 1 | d << 27 ; } c &= 0xfffffff ; MST[rv.OBBN2Mutator]MSP[] d &= 0xfffffff ;
private static void permOp ( int a , int b , final int n , final int m , final int results [] ) { final int t = ( a >>> n ^ b ) & m ; a ^= t << n ; MST[rv.UOI4Mutator]MSP[] b ^= t ;
private static void intToFourBytes ( final int iValue , final byte b [] , int offset ) { b [ offset ++ ] = (byte) ( iValue & 0xff ) ; b [ offset ++ ] = (byte) ( iValue >>> 8 & 0xff ) ; MST[rv.UOI4Mutator]MSP[]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.OBBN2Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; MST[MathMutator]MSP[] d = d >>> 2 | d << 26 ; } else {
for ( int i = 0 ; i < 16 ; i ++ ) { MST[NegateConditionalsMutator]MSP[] if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; d = d >>> 2 | d << 26 ; } else {
permOp ( left , right , 8 , 0xff00ff , results ) ; MST[rv.CRCR4Mutator]MSP[] left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 2 , 0x33333333 , results ) ; right = results [ 0 ] ;
SKB [ 7 ] [ d >>> 21 & 0xf | d >>> 22 & 0x30 ] ; schedule [ j ++ ] = ( t << 16 | s & 0xffff ) ; s = s >>> 16 | t & 0xffff0000 ; MST[rv.UOI3Mutator]MSP[]
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; } t = left ; left = right ; right = t ; } t = right ; right = left >>> 1 | left << 31 ; MST[rv.UOI1Mutator]MSP[]
permOp ( left , right , 8 , 0xff00ff , results ) ; MST[rv.CRCR1Mutator]MSP[] left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 2 , 0x33333333 , results ) ; right = results [ 0 ] ;
left = results [ 1 ] ; permOp ( left , right , 16 , 65535 , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 4 , 0xf0f0f0f , results ) ; MST[rv.CRCR3Mutator]MSP[]
c = c >>> 1 | c << 27 ; d = d >>> 1 | d << 27 ; MST[rv.CRCR2Mutator]MSP[] } c &= 0xfffffff ; d &= 0xfffffff ;
for ( int i = 0 ; i < 32 ; i += 4 ) { MST[NegateConditionalsMutator]MSP[] left = dEncrypt ( left , right , i , eSwap0 , eSwap1 , schedule ) ;
permOp ( d , c , 4 , 0xf0f0f0f , results ) ; MST[InlineConstantMutator]MSP[] d = results [ 0 ] ; c = results [ 1 ] ; c = hPermOp ( c , - 2 , 0xcccc0000 ) ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR5Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
permOp ( c , d , 8 , 0xff00ff , results ) ; c = results [ 0 ] ; d = results [ 1 ] ; MST[rv.UOI3Mutator]MSP[] permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ;
s = s << 4 | s >>> 28 ; schedule [ j ++ ] = s ; MST[rv.UOI4Mutator]MSP[] } return schedule ; } private static int fourBytesToInt ( final byte b [] , int offset ) { int value = byteToUnsigned ( b [ offset ++ ] ) ;
s = s << 4 | s >>> 28 ; schedule [ j ++ ] = s ; } return schedule ; } private static int fourBytesToInt ( final byte b [] , int offset ) { int value = byteToUnsigned ( b [ offset ++ ] ) ; MST[NonVoidMethodCallMutator]MSP[]
private static int dEncrypt ( int el , final int r , final int s , final int e0 , final int e1 , final int sArr [] ) { int v = r ^ r >>> 16 ; int u = v & e0 ; MST[rv.OBBN3Mutator]MSP[] v &= e1 ;
final char charOne = salt . charAt ( 1 ) ; buffer . setCharAt ( 0 , charZero ) ; buffer . setCharAt ( 1 , charOne ) ; final int eSwap0 = CON_SALT [ charZero ] ; MST[rv.UOI1Mutator]MSP[] final int eSwap1 = CON_SALT [ charOne ] << 4 ;
SKB [ 7 ] [ d >>> 21 & 0xf | d >>> 22 & 0x30 ] ; schedule [ j ++ ] = ( t << 16 | s & 0xffff ) ; MST[rv.CRCR1Mutator]MSP[] s = s >>> 16 | t & 0xffff0000 ;
final int schedule [] = desSetKey ( key ) ; final int out [] = body ( schedule , eSwap0 , eSwap1 ) ; MST[rv.ABSMutator]MSP[] final byte b [] = new byte [ 9 ] ; intToFourBytes ( out [ 0 ] , b , 0 ) ;
private static void intToFourBytes ( final int iValue , final byte b [] , int offset ) { b [ offset ++ ] = (byte) ( iValue & 0xff ) ; MST[InlineConstantMutator]MSP[] b [ offset ++ ] = (byte) ( iValue >>> 8 & 0xff ) ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR3Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
s = s << 4 | s >>> 28 ; schedule [ j ++ ] = s ; } return schedule ; } private static int fourBytesToInt ( final byte b [] , int offset ) { int value = byteToUnsigned ( b [ offset ++ ] ) ; MST[IncrementsMutator]MSP[]
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; MST[rv.OBBN2Mutator]MSP[] a = a ^ t ^ t >>> 16 - n ; return a ; }
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR2Mutator]MSP[]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[MathMutator]MSP[]
d = hPermOp ( d , - 2 , 0xcccc0000 ) ; permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ; c = results [ 1 ] ; MST[rv.UOI2Mutator]MSP[]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR3Mutator]MSP[]
permOp ( c , d , 8 , 0xff00ff , results ) ; c = results [ 0 ] ; d = results [ 1 ] ; permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ; MST[InlineConstantMutator]MSP[]
left = results [ 1 ] ; permOp ( left , right , 16 , 65535 , results ) ; MST[rv.CRCR6Mutator]MSP[] left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 4 , 0xf0f0f0f , results ) ;
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; c &= 0xfffffff ; MST[rv.OBBN2Mutator]MSP[] int j = 0 ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.OBBN3Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR1Mutator]MSP[]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR5Mutator]MSP[]
private static void permOp ( int a , int b , final int n , final int m , final int results [] ) { final int t = ( a >>> n ^ b ) & m ; a ^= t << n ; b ^= t ; MST[rv.UOI2Mutator]MSP[]
private static int dEncrypt ( int el , final int r , final int s , final int e0 , final int e1 , final int sArr [] ) { int v = r ^ r >>> 16 ; MST[rv.UOI2Mutator]MSP[] int u = v & e0 ; v &= e1 ;
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; d = d >>> 2 | d << 26 ; MST[rv.CRCR5Mutator]MSP[] } else {
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR3Mutator]MSP[]
b [ offset ++ ] = (byte) ( iValue >>> 16 & 0xff ) ; b [ offset ++ ] = (byte) ( iValue >>> 24 & 0xff ) ; MST[rv.OBBN2Mutator]MSP[] }
left = t >>> 1 | t << 31 ; final int results [] = new int [ 2 ] ; permOp ( right , left , 1 , 0x55555555 , results ) ; MST[rv.CRCR3Mutator]MSP[] right = results [ 0 ] ; left = results [ 1 ] ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.UOI2Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
s = s << 4 | s >>> 28 ; schedule [ j ++ ] = s ; MST[rv.UOI1Mutator]MSP[] } return schedule ; } private static int fourBytesToInt ( final byte b [] , int offset ) { int value = byteToUnsigned ( b [ offset ++ ] ) ;
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; MST[rv.CRCR2Mutator]MSP[] if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) {
d = hPermOp ( d , - 2 , 0xcccc0000 ) ; MST[rv.CRCR6Mutator]MSP[] permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ; c = results [ 1 ] ;
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; MST[rv.CRCR6Mutator]MSP[] return value ; }
private static int byteToUnsigned ( final byte b ) { final int value = b ; return value < 0 ? value + 256 : value ; MST[rv.CRCR6Mutator]MSP[] }
c = results [ 1 ] ; MST[rv.UOI1Mutator]MSP[] d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; c &= 0xfffffff ; int j = 0 ;
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) { MST[rv.UOI4Mutator]MSP[]
left = t >>> 1 | t << 31 ; MST[rv.OBBN2Mutator]MSP[] final int results [] = new int [ 2 ] ; permOp ( right , left , 1 , 0x55555555 , results ) ; right = results [ 0 ] ; left = results [ 1 ] ;
right = results [ 0 ] ; left = results [ 1 ] ; final int out [] = new int [ 2 ] ; MST[rv.CRCR3Mutator]MSP[] out [ 0 ] = left ; out [ 1 ] = right ; return out ; }
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR6Mutator]MSP[]
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; MST[rv.UOI3Mutator]MSP[] value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; return value ; }
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; MST[ArgumentPropagationMutator]MSP[] } t = left ; left = right ; right = t ; } t = right ; right = left >>> 1 | left << 31 ;
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.CRCR6Mutator]MSP[] c &= 0xfffffff ; int j = 0 ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR4Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
permOp ( left , right , 8 , 0xff00ff , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 2 , 0x33333333 , results ) ; MST[rv.CRCR2Mutator]MSP[] right = results [ 0 ] ;
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; MST[rv.ABSMutator]MSP[] return value ; }
permOp ( left , right , 8 , 0xff00ff , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 2 , 0x33333333 , results ) ; MST[rv.ABSMutator]MSP[] right = results [ 0 ] ;
SKB [ 7 ] [ d >>> 21 & 0xf | d >>> 22 & 0x30 ] ; schedule [ j ++ ] = ( t << 16 | s & 0xffff ) ; s = s >>> 16 | t & 0xffff0000 ; MST[rv.UOI2Mutator]MSP[]
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; MST[rv.AOR4Mutator]MSP[] a = a ^ t ^ t >>> 16 - n ; return a ; }
private static int byteToUnsigned ( final byte b ) { final int value = b ; return value < 0 ? value + 256 : value ; MST[rv.AOR4Mutator]MSP[] }
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR2Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
final int schedule [] = new int [ 32 ] ; int c = fourBytesToInt ( key , 0 ) ; int d = fourBytesToInt ( key , 4 ) ; final int results [] = new int [ 2 ] ; MST[rv.CRCR6Mutator]MSP[]
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; MST[rv.UOI4Mutator]MSP[] value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; return value ; }
intToFourBytes ( out [ 1 ] , b , 4 ) ; b [ 8 ] = 0 ; MST[rv.CRCR1Mutator]MSP[] int i = 2 ; int y = 0 ; int u = 128 ; for (; i < 13 ; i ++ ) { int j = 0 ;
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; t = t >>> 4 | t << 28 ; MST[InlineConstantMutator]MSP[]
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { MST[rv.UOI3Mutator]MSP[] c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) {
for ( int i = 0 ; i < 16 ; i ++ ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; d = d >>> 2 | d << 26 ; } else {
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.UOI3Mutator]MSP[]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR3Mutator]MSP[]
for ( int i = 0 ; i < 32 ; i += 4 ) { MST[rv.ROR2Mutator]MSP[] left = dEncrypt ( left , right , i , eSwap0 , eSwap1 , schedule ) ;
SKB [ 7 ] [ d >>> 21 & 0xf | d >>> 22 & 0x30 ] ; schedule [ j ++ ] = ( t << 16 | s & 0xffff ) ; s = s >>> 16 | t & 0xffff0000 ; MST[rv.OBBN2Mutator]MSP[]
private static int byteToUnsigned ( final byte b ) { final int value = b ; return value < 0 ? value + 256 : value ; MST[MathMutator]MSP[] }
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; MST[rv.ABSMutator]MSP[] if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) {
b [ offset ++ ] = (byte) ( iValue >>> 16 & 0xff ) ; b [ offset ++ ] = (byte) ( iValue >>> 24 & 0xff ) ; MST[rv.UOI2Mutator]MSP[] }
permOp ( d , c , 4 , 0xf0f0f0f , results ) ; d = results [ 0 ] ; MST[rv.CRCR5Mutator]MSP[] c = results [ 1 ] ; c = hPermOp ( c , - 2 , 0xcccc0000 ) ;
permOp ( c , d , 8 , 0xff00ff , results ) ; c = results [ 0 ] ; d = results [ 1 ] ; permOp ( d , c , 1 , 0x55555555 , results ) ; MST[rv.CRCR6Mutator]MSP[] d = results [ 0 ] ;
for ( int i = 0 ; i < 32 ; i += 4 ) { left = dEncrypt ( left , right , i , eSwap0 , eSwap1 , schedule ) ; MST[rv.UOI2Mutator]MSP[]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[InlineConstantMutator]MSP[]
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR3Mutator]MSP[]
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; MST[rv.CRCR4Mutator]MSP[] } u >>>= 1 ; if ( u == 0 ) {
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[MathMutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
private static int byteToUnsigned ( final byte b ) { final int value = b ; return value < 0 ? value + 256 : value ; MST[rv.UOI1Mutator]MSP[] }
c = c >>> 1 | c << 27 ; MST[rv.UOI3Mutator]MSP[] d = d >>> 1 | d << 27 ; } c &= 0xfffffff ; d &= 0xfffffff ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.UOI1Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
for ( int i = 0 ; i < key . length && i < original . length ; i ++ ) { MST[rv.UOI1Mutator]MSP[] final int iChar = original [ i ] ; key [ i ] = (byte) ( iChar << 1 ) ; }
s = s << 4 | s >>> 28 ; MST[rv.CRCR1Mutator]MSP[] schedule [ j ++ ] = s ; } return schedule ; } private static int fourBytesToInt ( final byte b [] , int offset ) { int value = byteToUnsigned ( b [ offset ++ ] ) ;
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[InlineConstantMutator]MSP[] c &= 0xfffffff ; int j = 0 ;
right = results [ 0 ] ; left = results [ 1 ] ; final int out [] = new int [ 2 ] ; out [ 0 ] = left ; out [ 1 ] = right ; return out ; MST[NullReturnValsMutator]MSP[] }
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; MST[rv.CRCR5Mutator]MSP[] if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) {
u = u ^ u << 16 ^ r ^ sArr [ s ] ; MST[rv.UOI3Mutator]MSP[] int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; t = t >>> 4 | t << 28 ;
s = s << 4 | s >>> 28 ; MST[rv.CRCR2Mutator]MSP[] schedule [ j ++ ] = s ; } return schedule ; } private static int fourBytesToInt ( final byte b [] , int offset ) { int value = byteToUnsigned ( b [ offset ++ ] ) ;
c = c >>> 1 | c << 27 ; MST[rv.UOI2Mutator]MSP[] d = d >>> 1 | d << 27 ; } c &= 0xfffffff ; d &= 0xfffffff ;
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; MST[rv.ABSMutator]MSP[] d = d >>> 2 | d << 26 ; } else {
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR4Mutator]MSP[]
for ( int i = 0 ; i < key . length && i < original . length ; i ++ ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[] final int iChar = original [ i ] ; key [ i ] = (byte) ( iChar << 1 ) ; }
c = results [ 1 ] ; MST[rv.UOI4Mutator]MSP[] d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; c &= 0xfffffff ; int j = 0 ;
private static int byteToUnsigned ( final byte b ) { final int value = b ; return value < 0 ? value + 256 : value ; MST[rv.CRCR3Mutator]MSP[] }
return crypt ( original . getBytes ( StandardCharsets . UTF_8 ) ) ; } public static String crypt ( final String original , final String salt ) { return crypt ( original . getBytes ( StandardCharsets . UTF_8 ) , salt ) ; MST[ArgumentPropagationMutator]MSP[] }
permOp ( c , d , 8 , 0xff00ff , results ) ; c = results [ 0 ] ; d = results [ 1 ] ; permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ; MST[rv.UOI2Mutator]MSP[]
permOp ( left , right , 8 , 0xff00ff , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 2 , 0x33333333 , results ) ; MST[rv.CRCR5Mutator]MSP[] right = results [ 0 ] ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR3Mutator]MSP[]
b [ offset ++ ] = (byte) ( iValue >>> 16 & 0xff ) ; b [ offset ++ ] = (byte) ( iValue >>> 24 & 0xff ) ; MST[rv.CRCR4Mutator]MSP[] }
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) { MST[NegateConditionalsMutator]MSP[]
left = t >>> 1 | t << 31 ; MST[rv.UOI3Mutator]MSP[] final int results [] = new int [ 2 ] ; permOp ( right , left , 1 , 0x55555555 , results ) ; right = results [ 0 ] ; left = results [ 1 ] ;
b [ offset ++ ] = (byte) ( iValue >>> 16 & 0xff ) ; b [ offset ++ ] = (byte) ( iValue >>> 24 & 0xff ) ; MST[rv.ABSMutator]MSP[] }
for ( int i = 0 ; i < 32 ; i += 4 ) { left = dEncrypt ( left , right , i , eSwap0 , eSwap1 , schedule ) ; MST[rv.UOI4Mutator]MSP[]
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.CRCR1Mutator]MSP[] c &= 0xfffffff ; int j = 0 ;
intToFourBytes ( out [ 1 ] , b , 4 ) ; MST[VoidMethodCallMutator]MSP[] b [ 8 ] = 0 ; int i = 2 ; int y = 0 ; int u = 128 ; for (; i < 13 ; i ++ ) { int j = 0 ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.UOI1Mutator]MSP[]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.OBBN3Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
private static int [] body ( final int schedule [] , final int eSwap0 , final int eSwap1 ) { int left = 0 ; int right = 0 ; int t = 0 ; for ( int j = 0 ; j < 25 ; j ++ ) { MST[rv.ROR2Mutator]MSP[]
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { MST[rv.UOI2Mutator]MSP[] c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) {
permOp ( c , d , 8 , 0xff00ff , results ) ; c = results [ 0 ] ; MST[rv.UOI1Mutator]MSP[] d = results [ 1 ] ; permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ;
results [ 0 ] = a ; results [ 1 ] = b ; MST[rv.ABSMutator]MSP[] }
private static void permOp ( int a , int b , final int n , final int m , final int results [] ) { final int t = ( a >>> n ^ b ) & m ; MST[rv.OBBN3Mutator]MSP[] a ^= t << n ; b ^= t ;
permOp ( d , c , 4 , 0xf0f0f0f , results ) ; d = results [ 0 ] ; c = results [ 1 ] ; c = hPermOp ( c , - 2 , 0xcccc0000 ) ; MST[ArgumentPropagationMutator]MSP[]
permOp ( c , d , 8 , 0xff00ff , results ) ; c = results [ 0 ] ; MST[rv.CRCR3Mutator]MSP[] d = results [ 1 ] ; permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR4Mutator]MSP[]
intToFourBytes ( out [ 1 ] , b , 4 ) ; b [ 8 ] = 0 ; MST[rv.CRCR5Mutator]MSP[] int i = 2 ; int y = 0 ; int u = 128 ; for (; i < 13 ; i ++ ) { int j = 0 ;
permOp ( d , c , 4 , 0xf0f0f0f , results ) ; MST[rv.CRCR4Mutator]MSP[] d = results [ 0 ] ; c = results [ 1 ] ; c = hPermOp ( c , - 2 , 0xcccc0000 ) ;
s = s << 4 | s >>> 28 ; schedule [ j ++ ] = s ; } return schedule ; } private static int fourBytesToInt ( final byte b [] , int offset ) { int value = byteToUnsigned ( b [ offset ++ ] ) ; MST[rv.UOI4Mutator]MSP[]
for ( int i = 0 ; i < 32 ; i += 4 ) { left = dEncrypt ( left , right , i , eSwap0 , eSwap1 , schedule ) ; MST[rv.UOI1Mutator]MSP[]
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; t = t >>> 4 | t << 28 ; MST[rv.ABSMutator]MSP[]
d = hPermOp ( d , - 2 , 0xcccc0000 ) ; MST[InlineConstantMutator]MSP[] permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ; c = results [ 1 ] ;
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; MST[InlineConstantMutator]MSP[] value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; return value ; }
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[MathMutator]MSP[] c &= 0xfffffff ; int j = 0 ;
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; MST[MathMutator]MSP[] return value ; }
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR1Mutator]MSP[]
left = results [ 1 ] ; permOp ( left , right , 16 , 65535 , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 4 , 0xf0f0f0f , results ) ; MST[InlineConstantMutator]MSP[]
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; MST[rv.ABSMutator]MSP[] } t = left ; left = right ; right = t ; } t = right ; right = left >>> 1 | left << 31 ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR3Mutator]MSP[]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR1Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; MST[rv.CRCR3Mutator]MSP[] d = d >>> 2 | d << 26 ; } else {
for ( int i = 0 ; i < key . length && i < original . length ; i ++ ) { MST[rv.UOI4Mutator]MSP[] final int iChar = original [ i ] ; key [ i ] = (byte) ( iChar << 1 ) ; }
right = results [ 0 ] ; left = results [ 1 ] ; final int out [] = new int [ 2 ] ; out [ 0 ] = left ; out [ 1 ] = right ; return out ; MST[ReturnValsMutator]MSP[] }
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.ABSMutator]MSP[]
permOp ( d , c , 4 , 0xf0f0f0f , results ) ; d = results [ 0 ] ; c = results [ 1 ] ; c = hPermOp ( c , - 2 , 0xcccc0000 ) ; MST[rv.CRCR5Mutator]MSP[]
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; d = d >>> 2 | d << 26 ; MST[rv.CRCR6Mutator]MSP[] } else {
d = hPermOp ( d , - 2 , 0xcccc0000 ) ; permOp ( d , c , 1 , 0x55555555 , results ) ; MST[rv.ABSMutator]MSP[] d = results [ 0 ] ; c = results [ 1 ] ;
final byte key [] = new byte [ 8 ] ; for ( int i = 0 ; i < key . length ; i ++ ) { MST[rv.CRCR1Mutator]MSP[] key [ i ] = 0 ; }
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; } t = left ; left = right ; right = t ; } t = right ; MST[rv.UOI3Mutator]MSP[] right = left >>> 1 | left << 31 ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR2Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR3Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.CRCR4Mutator]MSP[] c &= 0xfffffff ; int j = 0 ;
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; MST[rv.UOI1Mutator]MSP[] value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; return value ; }
for ( int i = 0 ; i < 32 ; i += 4 ) { MST[rv.CRCR5Mutator]MSP[] left = dEncrypt ( left , right , i , eSwap0 , eSwap1 , schedule ) ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.OBBN3Mutator]MSP[]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[MathMutator]MSP[]
final int schedule [] = new int [ 32 ] ; MST[rv.CRCR6Mutator]MSP[] int c = fourBytesToInt ( key , 0 ) ; int d = fourBytesToInt ( key , 4 ) ; final int results [] = new int [ 2 ] ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.OBBN2Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR6Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.UOI2Mutator]MSP[]
left = t >>> 1 | t << 31 ; MST[rv.UOI2Mutator]MSP[] final int results [] = new int [ 2 ] ; permOp ( right , left , 1 , 0x55555555 , results ) ; right = results [ 0 ] ; left = results [ 1 ] ;
for ( int i = 0 ; i < 16 ; i ++ ) { MST[rv.ROR5Mutator]MSP[] if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; d = d >>> 2 | d << 26 ; } else {
permOp ( d , c , 4 , 0xf0f0f0f , results ) ; MST[rv.ABSMutator]MSP[] d = results [ 0 ] ; c = results [ 1 ] ; c = hPermOp ( c , - 2 , 0xcccc0000 ) ;
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; MST[rv.AOR1Mutator]MSP[] a = a ^ t ^ t >>> 16 - n ; return a ; }
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; t = t >>> 4 | t << 28 ; MST[rv.UOI4Mutator]MSP[]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.OBBN1Mutator]MSP[]
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR3Mutator]MSP[]
private static int [] body ( final int schedule [] , final int eSwap0 , final int eSwap1 ) { int left = 0 ; int right = 0 ; int t = 0 ; for ( int j = 0 ; j < 25 ; j ++ ) { MST[rv.CRCR6Mutator]MSP[]
permOp ( c , d , 8 , 0xff00ff , results ) ; MST[rv.CRCR5Mutator]MSP[] c = results [ 0 ] ; d = results [ 1 ] ; permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[MathMutator]MSP[]
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; MST[rv.CRCR3Mutator]MSP[] return value ; }
y ++ ; u = 128 ; } buffer . setCharAt ( i , ( char ) COV2CHAR [ c ] ) ; } } return buffer . toString () ; MST[NonVoidMethodCallMutator]MSP[] } public static String crypt ( final String original ) {
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; MST[rv.AOR1Mutator]MSP[] t = t >>> 4 | t << 28 ;
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; MST[rv.CRCR2Mutator]MSP[] a = a ^ t ^ t >>> 16 - n ; return a ; }
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR6Mutator]MSP[]
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; MST[IncrementsMutator]MSP[] value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; return value ; }
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[MathMutator]MSP[]
intToFourBytes ( out [ 1 ] , b , 4 ) ; MST[rv.CRCR2Mutator]MSP[] b [ 8 ] = 0 ; int i = 2 ; int y = 0 ; int u = 128 ; for (; i < 13 ; i ++ ) { int j = 0 ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.ABSMutator]MSP[]
intToFourBytes ( out [ 1 ] , b , 4 ) ; b [ 8 ] = 0 ; int i = 2 ; int y = 0 ; int u = 128 ; for (; i < 13 ; i ++ ) { MST[rv.UOI3Mutator]MSP[] int j = 0 ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.OBBN3Mutator]MSP[]
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.UOI3Mutator]MSP[]
left = results [ 1 ] ; permOp ( left , right , 16 , 65535 , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 4 , 0xf0f0f0f , results ) ; MST[rv.CRCR4Mutator]MSP[]
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; a = a ^ t ^ t >>> 16 - n ; return a ; MST[rv.UOI2Mutator]MSP[] }
private static void intToFourBytes ( final int iValue , final byte b [] , int offset ) { b [ offset ++ ] = (byte) ( iValue & 0xff ) ; MST[rv.CRCR4Mutator]MSP[] b [ offset ++ ] = (byte) ( iValue >>> 8 & 0xff ) ;
final char charOne = salt . charAt ( 1 ) ; buffer . setCharAt ( 0 , charZero ) ; buffer . setCharAt ( 1 , charOne ) ; final int eSwap0 = CON_SALT [ charZero ] ; final int eSwap1 = CON_SALT [ charOne ] << 4 ; MST[rv.UOI2Mutator]MSP[]
final int schedule [] = desSetKey ( key ) ; final int out [] = body ( schedule , eSwap0 , eSwap1 ) ; final byte b [] = new byte [ 9 ] ; MST[rv.CRCR2Mutator]MSP[] intToFourBytes ( out [ 0 ] , b , 0 ) ;
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; t = t >>> 4 | t << 28 ; MST[rv.CRCR5Mutator]MSP[]
left = results [ 1 ] ; permOp ( left , right , 16 , 65535 , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; MST[rv.UOI1Mutator]MSP[] permOp ( right , left , 4 , 0xf0f0f0f , results ) ;
final byte key [] = new byte [ 8 ] ; for ( int i = 0 ; i < key . length ; i ++ ) { key [ i ] = 0 ; MST[rv.ABSMutator]MSP[] }
private static void permOp ( int a , int b , final int n , final int m , final int results [] ) { final int t = ( a >>> n ^ b ) & m ; MST[rv.UOI1Mutator]MSP[] a ^= t << n ; b ^= t ;
y ++ ; u = 128 ; } buffer . setCharAt ( i , ( char ) COV2CHAR [ c ] ) ; MST[rv.UOI2Mutator]MSP[] } } return buffer . toString () ; } public static String crypt ( final String original ) {
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; } t = left ; left = right ; right = t ; } t = right ; right = left >>> 1 | left << 31 ; MST[rv.OBBN3Mutator]MSP[]
left = results [ 1 ] ; permOp ( left , right , 16 , 65535 , results ) ; MST[rv.CRCR2Mutator]MSP[] left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 4 , 0xf0f0f0f , results ) ;
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.OBBN1Mutator]MSP[] c &= 0xfffffff ; int j = 0 ;
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.OBBN3Mutator]MSP[] c &= 0xfffffff ; int j = 0 ;
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.ABSMutator]MSP[] c &= 0xfffffff ; int j = 0 ;
left = results [ 1 ] ; permOp ( left , right , 16 , 65535 , results ) ; MST[rv.CRCR3Mutator]MSP[] left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 4 , 0xf0f0f0f , results ) ;
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; t = t >>> 4 | t << 28 ; MST[rv.CRCR4Mutator]MSP[]
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.OBBN2Mutator]MSP[] c &= 0xfffffff ; int j = 0 ;
d = hPermOp ( d , - 2 , 0xcccc0000 ) ; permOp ( d , c , 1 , 0x55555555 , results ) ; MST[rv.UOI4Mutator]MSP[] d = results [ 0 ] ; c = results [ 1 ] ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR3Mutator]MSP[]
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR2Mutator]MSP[]
d = hPermOp ( d , - 2 , 0xcccc0000 ) ; permOp ( d , c , 1 , 0x55555555 , results ) ; MST[rv.CRCR4Mutator]MSP[] d = results [ 0 ] ; c = results [ 1 ] ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.UOI3Mutator]MSP[]
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; } t = left ; left = right ; right = t ; } t = right ; right = left >>> 1 | left << 31 ; MST[rv.CRCR1Mutator]MSP[]
return crypt ( original . getBytes ( StandardCharsets . UTF_8 ) ) ; } public static String crypt ( final String original , final String salt ) { return crypt ( original . getBytes ( StandardCharsets . UTF_8 ) , salt ) ; MST[NonVoidMethodCallMutator]MSP[] }
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.UOI4Mutator]MSP[]
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR4Mutator]MSP[]
private static void permOp ( int a , int b , final int n , final int m , final int results [] ) { final int t = ( a >>> n ^ b ) & m ; a ^= t << n ; MST[rv.UOI2Mutator]MSP[] b ^= t ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.UOI2Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR5Mutator]MSP[]
d = hPermOp ( d , - 2 , 0xcccc0000 ) ; permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ; c = results [ 1 ] ; MST[rv.CRCR4Mutator]MSP[]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.ABSMutator]MSP[]
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.UOI4Mutator]MSP[]
c = c >>> 1 | c << 27 ; d = d >>> 1 | d << 27 ; } c &= 0xfffffff ; d &= 0xfffffff ; MST[rv.UOI1Mutator]MSP[]
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; MST[MathMutator]MSP[] d = d >>> 2 | d << 26 ; } else {
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR5Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
final char charOne = salt . charAt ( 1 ) ; buffer . setCharAt ( 0 , charZero ) ; buffer . setCharAt ( 1 , charOne ) ; MST[rv.ABSMutator]MSP[] final int eSwap0 = CON_SALT [ charZero ] ; final int eSwap1 = CON_SALT [ charOne ] << 4 ;
c = c >>> 1 | c << 27 ; d = d >>> 1 | d << 27 ; } c &= 0xfffffff ; MST[rv.CRCR6Mutator]MSP[] d &= 0xfffffff ;
d = hPermOp ( d , - 2 , 0xcccc0000 ) ; MST[rv.CRCR3Mutator]MSP[] permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ; c = results [ 1 ] ;
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; MST[rv.UOI3Mutator]MSP[] } t = left ; left = right ; right = t ; } t = right ; right = left >>> 1 | left << 31 ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.OBBN2Mutator]MSP[]
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; MST[rv.CRCR5Mutator]MSP[] value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; return value ; }
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; } u >>>= 1 ; MST[rv.CRCR2Mutator]MSP[] if ( u == 0 ) {
permOp ( c , d , 8 , 0xff00ff , results ) ; c = results [ 0 ] ; d = results [ 1 ] ; MST[rv.CRCR5Mutator]MSP[] permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[MathMutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; MST[rv.UOI1Mutator]MSP[] t = t >>> 4 | t << 28 ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.UOI3Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
left = results [ 1 ] ; permOp ( left , right , 16 , 65535 , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; MST[rv.CRCR6Mutator]MSP[] permOp ( right , left , 4 , 0xf0f0f0f , results ) ;
intToFourBytes ( out [ 1 ] , b , 4 ) ; MST[InlineConstantMutator]MSP[] b [ 8 ] = 0 ; int i = 2 ; int y = 0 ; int u = 128 ; for (; i < 13 ; i ++ ) { int j = 0 ;
private static void intToFourBytes ( final int iValue , final byte b [] , int offset ) { b [ offset ++ ] = (byte) ( iValue & 0xff ) ; MST[rv.ABSMutator]MSP[] b [ offset ++ ] = (byte) ( iValue >>> 8 & 0xff ) ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.UOI3Mutator]MSP[]
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; MST[rv.CRCR4Mutator]MSP[] d = d >>> 2 | d << 26 ; } else {
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[MathMutator]MSP[]
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR2Mutator]MSP[]
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.UOI1Mutator]MSP[] c &= 0xfffffff ; int j = 0 ;
left = results [ 1 ] ; MST[rv.CRCR5Mutator]MSP[] permOp ( left , right , 16 , 65535 , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 4 , 0xf0f0f0f , results ) ;
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.UOI4Mutator]MSP[] c &= 0xfffffff ; int j = 0 ;
right = results [ 0 ] ; left = results [ 1 ] ; MST[rv.UOI2Mutator]MSP[] final int out [] = new int [ 2 ] ; out [ 0 ] = left ; out [ 1 ] = right ; return out ; }
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; MST[rv.UOI2Mutator]MSP[] a = a ^ t ^ t >>> 16 - n ; return a ; }
results [ 0 ] = a ; MST[rv.UOI3Mutator]MSP[] results [ 1 ] = b ; }
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[InlineConstantMutator]MSP[]
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.CRCR3Mutator]MSP[] c &= 0xfffffff ; int j = 0 ;
y ++ ; u = 128 ; MST[rv.CRCR6Mutator]MSP[] } buffer . setCharAt ( i , ( char ) COV2CHAR [ c ] ) ; } } return buffer . toString () ; } public static String crypt ( final String original ) {
private static int dEncrypt ( int el , final int r , final int s , final int e0 , final int e1 , final int sArr [] ) { int v = r ^ r >>> 16 ; MST[rv.UOI3Mutator]MSP[] int u = v & e0 ; v &= e1 ;
u = u ^ u << 16 ^ r ^ sArr [ s ] ; MST[rv.ABSMutator]MSP[] int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; t = t >>> 4 | t << 28 ;
permOp ( left , right , 8 , 0xff00ff , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 2 , 0x33333333 , results ) ; MST[rv.CRCR1Mutator]MSP[] right = results [ 0 ] ;
right = results [ 0 ] ; left = results [ 1 ] ; final int out [] = new int [ 2 ] ; out [ 0 ] = left ; out [ 1 ] = right ; MST[InlineConstantMutator]MSP[] return out ; }
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.CRCR6Mutator]MSP[] c &= 0xfffffff ; int j = 0 ;
private static void intToFourBytes ( final int iValue , final byte b [] , int offset ) { b [ offset ++ ] = (byte) ( iValue & 0xff ) ; b [ offset ++ ] = (byte) ( iValue >>> 8 & 0xff ) ; MST[rv.UOI1Mutator]MSP[]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[InlineConstantMutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR5Mutator]MSP[]
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; a = a ^ t ^ t >>> 16 - n ; MST[rv.AOD2Mutator]MSP[] return a ; }
permOp ( d , c , 4 , 0xf0f0f0f , results ) ; d = results [ 0 ] ; c = results [ 1 ] ; MST[InlineConstantMutator]MSP[] c = hPermOp ( c , - 2 , 0xcccc0000 ) ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR1Mutator]MSP[]
private static void intToFourBytes ( final int iValue , final byte b [] , int offset ) { b [ offset ++ ] = (byte) ( iValue & 0xff ) ; b [ offset ++ ] = (byte) ( iValue >>> 8 & 0xff ) ; MST[rv.CRCR3Mutator]MSP[]
b [ offset ++ ] = (byte) ( iValue >>> 16 & 0xff ) ; MST[rv.CRCR2Mutator]MSP[] b [ offset ++ ] = (byte) ( iValue >>> 24 & 0xff ) ; }
permOp ( left , right , 8 , 0xff00ff , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; MST[rv.CRCR4Mutator]MSP[] permOp ( right , left , 2 , 0x33333333 , results ) ; right = results [ 0 ] ;
u = u ^ u << 16 ^ r ^ sArr [ s ] ; MST[rv.UOI1Mutator]MSP[] int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; t = t >>> 4 | t << 28 ;
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; MST[rv.UOI2Mutator]MSP[] value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; return value ; }
final char charOne = salt . charAt ( 1 ) ; MST[rv.CRCR6Mutator]MSP[] buffer . setCharAt ( 0 , charZero ) ; buffer . setCharAt ( 1 , charOne ) ; final int eSwap0 = CON_SALT [ charZero ] ; final int eSwap1 = CON_SALT [ charOne ] << 4 ;
intToFourBytes ( out [ 1 ] , b , 4 ) ; b [ 8 ] = 0 ; int i = 2 ; MST[rv.CRCR1Mutator]MSP[] int y = 0 ; int u = 128 ; for (; i < 13 ; i ++ ) { int j = 0 ;
b [ offset ++ ] = (byte) ( iValue >>> 16 & 0xff ) ; b [ offset ++ ] = (byte) ( iValue >>> 24 & 0xff ) ; MST[rv.UOI4Mutator]MSP[] }
} else if ( ! salt . matches ( lr_2 + B64 . B64T_STRING + lr_3 ) ) { MST[rv.ROR2Mutator]MSP[] throw new IllegalArgumentException ( lr_4 + salt ) ; } final StringBuilder buffer = new StringBuilder ( lr_5 ) ; final char charZero = salt . charAt ( 0 ) ;
c = c >>> 1 | c << 27 ; d = d >>> 1 | d << 27 ; MST[rv.UOI1Mutator]MSP[] } c &= 0xfffffff ; d &= 0xfffffff ;
left = t >>> 1 | t << 31 ; final int results [] = new int [ 2 ] ; permOp ( right , left , 1 , 0x55555555 , results ) ; right = results [ 0 ] ; left = results [ 1 ] ; MST[rv.CRCR3Mutator]MSP[]
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; MST[rv.UOI3Mutator]MSP[] t = t >>> 4 | t << 28 ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.UOI4Mutator]MSP[]
left = t >>> 1 | t << 31 ; final int results [] = new int [ 2 ] ; permOp ( right , left , 1 , 0x55555555 , results ) ; right = results [ 0 ] ; MST[rv.CRCR1Mutator]MSP[] left = results [ 1 ] ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.UOI1Mutator]MSP[]
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[InlineConstantMutator]MSP[]
right = results [ 0 ] ; left = results [ 1 ] ; final int out [] = new int [ 2 ] ; out [ 0 ] = left ; out [ 1 ] = right ; MST[rv.UOI2Mutator]MSP[] return out ; }
private static void intToFourBytes ( final int iValue , final byte b [] , int offset ) { b [ offset ++ ] = (byte) ( iValue & 0xff ) ; MST[rv.CRCR5Mutator]MSP[] b [ offset ++ ] = (byte) ( iValue >>> 8 & 0xff ) ;
final byte key [] = new byte [ 8 ] ; for ( int i = 0 ; i < key . length ; i ++ ) { MST[ConditionalsBoundaryMutator]MSP[] key [ i ] = 0 ; }
permOp ( c , d , 8 , 0xff00ff , results ) ; c = results [ 0 ] ; d = results [ 1 ] ; permOp ( d , c , 1 , 0x55555555 , results ) ; MST[rv.CRCR2Mutator]MSP[] d = results [ 0 ] ;
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; } t = left ; MST[rv.UOI3Mutator]MSP[] left = right ; right = t ; } t = right ; right = left >>> 1 | left << 31 ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.OBBN3Mutator]MSP[]
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; MST[NonVoidMethodCallMutator]MSP[] value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; return value ; }
private static int byteToUnsigned ( final byte b ) { final int value = b ; return value < 0 ? value + 256 : value ; MST[rv.UOI3Mutator]MSP[] }
SKB [ 7 ] [ d >>> 21 & 0xf | d >>> 22 & 0x30 ] ; schedule [ j ++ ] = ( t << 16 | s & 0xffff ) ; MST[rv.OBBN3Mutator]MSP[] s = s >>> 16 | t & 0xffff0000 ;
for ( int i = 0 ; i < key . length && i < original . length ; i ++ ) { final int iChar = original [ i ] ; key [ i ] = (byte) ( iChar << 1 ) ; MST[rv.UOI4Mutator]MSP[] }
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; MST[rv.CRCR5Mutator]MSP[] } t = left ; left = right ; right = t ; } t = right ; right = left >>> 1 | left << 31 ;
u = u ^ u << 16 ^ r ^ sArr [ s ] ; MST[rv.UOI4Mutator]MSP[] int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; t = t >>> 4 | t << 28 ;
c = results [ 1 ] ; MST[rv.CRCR6Mutator]MSP[] d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; c &= 0xfffffff ; int j = 0 ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.OBBN1Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; MST[experimental.RemoveIncrementsMutator]MSP[] return value ; }
for ( int i = 0 ; i < key . length && i < original . length ; i ++ ) { final int iChar = original [ i ] ; MST[rv.UOI2Mutator]MSP[] key [ i ] = (byte) ( iChar << 1 ) ; }
private static int byteToUnsigned ( final byte b ) { final int value = b ; MST[rv.UOI1Mutator]MSP[] return value < 0 ? value + 256 : value ; }
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { MST[rv.ROR5Mutator]MSP[] c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) {
permOp ( c , d , 8 , 0xff00ff , results ) ; MST[rv.CRCR1Mutator]MSP[] c = results [ 0 ] ; d = results [ 1 ] ; permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR2Mutator]MSP[]
public static String crypt ( final byte [] original ) { return crypt ( original , null ) ; MST[EmptyObjectReturnValsMutator]MSP[] } public static String crypt ( final byte [] original , String salt ) { if ( salt == null ) { final ThreadLocalRandom randomGenerator = ThreadLocalRandom . current () ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR1Mutator]MSP[]
s = s << 4 | s >>> 28 ; MST[rv.UOI2Mutator]MSP[] schedule [ j ++ ] = s ; } return schedule ; } private static int fourBytesToInt ( final byte b [] , int offset ) { int value = byteToUnsigned ( b [ offset ++ ] ) ;
s = s << 4 | s >>> 28 ; MST[rv.UOI1Mutator]MSP[] schedule [ j ++ ] = s ; } return schedule ; } private static int fourBytesToInt ( final byte b [] , int offset ) { int value = byteToUnsigned ( b [ offset ++ ] ) ;
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; MST[rv.UOI4Mutator]MSP[] } u >>>= 1 ; if ( u == 0 ) {
private static int dEncrypt ( int el , final int r , final int s , final int e0 , final int e1 , final int sArr [] ) { int v = r ^ r >>> 16 ; int u = v & e0 ; v &= e1 ; MST[rv.UOI2Mutator]MSP[]
final int schedule [] = new int [ 32 ] ; MST[rv.CRCR3Mutator]MSP[] int c = fourBytesToInt ( key , 0 ) ; int d = fourBytesToInt ( key , 4 ) ; final int results [] = new int [ 2 ] ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR3Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; return value ; MST[PrimitiveReturnsMutator]MSP[] }
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.CRCR1Mutator]MSP[] c &= 0xfffffff ; int j = 0 ;
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; MST[rv.ABSMutator]MSP[] value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; return value ; }
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.ABSMutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; MST[InlineConstantMutator]MSP[] value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; return value ; }
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; MST[rv.AOR3Mutator]MSP[] } t = left ; left = right ; right = t ; } t = right ; right = left >>> 1 | left << 31 ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.UOI2Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
left = t >>> 1 | t << 31 ; final int results [] = new int [ 2 ] ; permOp ( right , left , 1 , 0x55555555 , results ) ; MST[rv.UOI1Mutator]MSP[] right = results [ 0 ] ; left = results [ 1 ] ;
for ( int i = 0 ; i < 32 ; i += 4 ) { MST[rv.ABSMutator]MSP[] left = dEncrypt ( left , right , i , eSwap0 , eSwap1 , schedule ) ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.OBBN1Mutator]MSP[]
private static void intToFourBytes ( final int iValue , final byte b [] , int offset ) { b [ offset ++ ] = (byte) ( iValue & 0xff ) ; b [ offset ++ ] = (byte) ( iValue >>> 8 & 0xff ) ; MST[MathMutator]MSP[]
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.OBBN3Mutator]MSP[] c &= 0xfffffff ; int j = 0 ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR1Mutator]MSP[]
intToFourBytes ( out [ 1 ] , b , 4 ) ; MST[rv.CRCR4Mutator]MSP[] b [ 8 ] = 0 ; int i = 2 ; int y = 0 ; int u = 128 ; for (; i < 13 ; i ++ ) { int j = 0 ;
private static int dEncrypt ( int el , final int r , final int s , final int e0 , final int e1 , final int sArr [] ) { int v = r ^ r >>> 16 ; int u = v & e0 ; v &= e1 ; MST[rv.OBBN2Mutator]MSP[]
int c = 0 ; for (; j < 6 ; j ++ ) { MST[rv.ABSMutator]MSP[] c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) {
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.OBBN3Mutator]MSP[]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.UOI2Mutator]MSP[]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[InlineConstantMutator]MSP[]
left = results [ 1 ] ; permOp ( left , right , 16 , 65535 , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 4 , 0xf0f0f0f , results ) ; MST[rv.UOI1Mutator]MSP[]
permOp ( d , c , 4 , 0xf0f0f0f , results ) ; d = results [ 0 ] ; c = results [ 1 ] ; MST[rv.CRCR4Mutator]MSP[] c = hPermOp ( c , - 2 , 0xcccc0000 ) ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR4Mutator]MSP[]
private static int byteToUnsigned ( final byte b ) { final int value = b ; return value < 0 ? value + 256 : value ; MST[rv.ROR5Mutator]MSP[] }
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR5Mutator]MSP[]
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; MST[rv.ABSMutator]MSP[] } t = left ; left = right ; right = t ; } t = right ; right = left >>> 1 | left << 31 ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.UOI1Mutator]MSP[]
left = t >>> 1 | t << 31 ; final int results [] = new int [ 2 ] ; permOp ( right , left , 1 , 0x55555555 , results ) ; MST[rv.CRCR6Mutator]MSP[] right = results [ 0 ] ; left = results [ 1 ] ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.OBBN2Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.OBBN2Mutator]MSP[]
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; t = t >>> 4 | t << 28 ; MST[rv.CRCR2Mutator]MSP[]
d = hPermOp ( d , - 2 , 0xcccc0000 ) ; permOp ( d , c , 1 , 0x55555555 , results ) ; MST[rv.UOI1Mutator]MSP[] d = results [ 0 ] ; c = results [ 1 ] ;
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; t = t >>> 4 | t << 28 ; MST[rv.CRCR1Mutator]MSP[]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.UOI3Mutator]MSP[]
final int schedule [] = new int [ 32 ] ; int c = fourBytesToInt ( key , 0 ) ; int d = fourBytesToInt ( key , 4 ) ; final int results [] = new int [ 2 ] ; MST[rv.CRCR3Mutator]MSP[]
final int schedule [] = desSetKey ( key ) ; final int out [] = body ( schedule , eSwap0 , eSwap1 ) ; final byte b [] = new byte [ 9 ] ; intToFourBytes ( out [ 0 ] , b , 0 ) ; MST[rv.UOI2Mutator]MSP[]
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; MST[rv.UOI1Mutator]MSP[] a = a ^ t ^ t >>> 16 - n ; return a ; }
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.ABSMutator]MSP[]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[MathMutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
SKB [ 7 ] [ d >>> 21 & 0xf | d >>> 22 & 0x30 ] ; schedule [ j ++ ] = ( t << 16 | s & 0xffff ) ; MST[rv.OBBN1Mutator]MSP[] s = s >>> 16 | t & 0xffff0000 ;
int c = 0 ; for (; j < 6 ; j ++ ) { MST[experimental.RemoveIncrementsMutator]MSP[] c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) {
permOp ( left , right , 8 , 0xff00ff , results ) ; MST[rv.ABSMutator]MSP[] left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 2 , 0x33333333 , results ) ; right = results [ 0 ] ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR2Mutator]MSP[]
b [ offset ++ ] = (byte) ( iValue >>> 16 & 0xff ) ; b [ offset ++ ] = (byte) ( iValue >>> 24 & 0xff ) ; MST[rv.CRCR5Mutator]MSP[] }
b [ offset ++ ] = (byte) ( iValue >>> 16 & 0xff ) ; b [ offset ++ ] = (byte) ( iValue >>> 24 & 0xff ) ; MST[rv.CRCR1Mutator]MSP[] }
private static void intToFourBytes ( final int iValue , final byte b [] , int offset ) { b [ offset ++ ] = (byte) ( iValue & 0xff ) ; b [ offset ++ ] = (byte) ( iValue >>> 8 & 0xff ) ; MST[rv.UOI3Mutator]MSP[]
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; MST[rv.UOI4Mutator]MSP[] d = d >>> 2 | d << 26 ; } else {
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; c &= 0xfffffff ; MST[rv.CRCR6Mutator]MSP[] int j = 0 ;
final int numSaltChars = SALT_CHARS . length ; salt = lr_1 + SALT_CHARS [ randomGenerator . nextInt ( numSaltChars ) ] + MST[NonVoidMethodCallMutator]MSP[] SALT_CHARS [ randomGenerator . nextInt ( numSaltChars ) ] ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.UOI2Mutator]MSP[]
left = results [ 1 ] ; permOp ( left , right , 16 , 65535 , results ) ; MST[rv.UOI4Mutator]MSP[] left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 4 , 0xf0f0f0f , results ) ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.ABSMutator]MSP[]
final char charOne = salt . charAt ( 1 ) ; buffer . setCharAt ( 0 , charZero ) ; MST[rv.CRCR1Mutator]MSP[] buffer . setCharAt ( 1 , charOne ) ; final int eSwap0 = CON_SALT [ charZero ] ; final int eSwap1 = CON_SALT [ charOne ] << 4 ;
private static int [] body ( final int schedule [] , final int eSwap0 , final int eSwap1 ) { int left = 0 ; int right = 0 ; int t = 0 ; MST[rv.CRCR6Mutator]MSP[] for ( int j = 0 ; j < 25 ; j ++ ) {
intToFourBytes ( out [ 1 ] , b , 4 ) ; MST[rv.CRCR5Mutator]MSP[] b [ 8 ] = 0 ; int i = 2 ; int y = 0 ; int u = 128 ; for (; i < 13 ; i ++ ) { int j = 0 ;
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; t = t >>> 4 | t << 28 ; MST[rv.UOI1Mutator]MSP[]
for ( int i = 0 ; i < 16 ; i ++ ) { MST[rv.CRCR5Mutator]MSP[] if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; d = d >>> 2 | d << 26 ; } else {
permOp ( d , c , 4 , 0xf0f0f0f , results ) ; d = results [ 0 ] ; c = results [ 1 ] ; c = hPermOp ( c , - 2 , 0xcccc0000 ) ; MST[rv.CRCR2Mutator]MSP[]
permOp ( c , d , 8 , 0xff00ff , results ) ; c = results [ 0 ] ; d = results [ 1 ] ; permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ; MST[rv.CRCR1Mutator]MSP[]
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[MathMutator]MSP[]
permOp ( left , right , 8 , 0xff00ff , results ) ; MST[InlineConstantMutator]MSP[] left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 2 , 0x33333333 , results ) ; right = results [ 0 ] ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR5Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.UOI3Mutator]MSP[] c &= 0xfffffff ; int j = 0 ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR4Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; a = a ^ t ^ t >>> 16 - n ; MST[rv.UOI1Mutator]MSP[] return a ; }
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.ABSMutator]MSP[] c &= 0xfffffff ; int j = 0 ;
permOp ( d , c , 4 , 0xf0f0f0f , results ) ; MST[rv.CRCR1Mutator]MSP[] d = results [ 0 ] ; c = results [ 1 ] ; c = hPermOp ( c , - 2 , 0xcccc0000 ) ;
final byte key [] = new byte [ 8 ] ; for ( int i = 0 ; i < key . length ; i ++ ) { MST[rv.ROR3Mutator]MSP[] key [ i ] = 0 ; }
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[InlineConstantMutator]MSP[]
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[MathMutator]MSP[] c &= 0xfffffff ; int j = 0 ;
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.UOI1Mutator]MSP[] c &= 0xfffffff ; int j = 0 ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.UOI3Mutator]MSP[]
private static void permOp ( int a , int b , final int n , final int m , final int results [] ) { final int t = ( a >>> n ^ b ) & m ; MST[rv.UOI3Mutator]MSP[] a ^= t << n ; b ^= t ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.UOI3Mutator]MSP[]
left = t >>> 1 | t << 31 ; MST[rv.CRCR6Mutator]MSP[] final int results [] = new int [ 2 ] ; permOp ( right , left , 1 , 0x55555555 , results ) ; right = results [ 0 ] ; left = results [ 1 ] ;
permOp ( c , d , 8 , 0xff00ff , results ) ; MST[InlineConstantMutator]MSP[] c = results [ 0 ] ; d = results [ 1 ] ; permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ;
final char charOne = salt . charAt ( 1 ) ; buffer . setCharAt ( 0 , charZero ) ; buffer . setCharAt ( 1 , charOne ) ; final int eSwap0 = CON_SALT [ charZero ] ; final int eSwap1 = CON_SALT [ charOne ] << 4 ; MST[rv.CRCR2Mutator]MSP[]
return crypt ( original . getBytes ( StandardCharsets . UTF_8 ) ) ; MST[EmptyObjectReturnValsMutator]MSP[] } public static String crypt ( final String original , final String salt ) { return crypt ( original . getBytes ( StandardCharsets . UTF_8 ) , salt ) ; }
private static void intToFourBytes ( final int iValue , final byte b [] , int offset ) { b [ offset ++ ] = (byte) ( iValue & 0xff ) ; MST[rv.UOI4Mutator]MSP[] b [ offset ++ ] = (byte) ( iValue >>> 8 & 0xff ) ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.OBBN1Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
private static void permOp ( int a , int b , final int n , final int m , final int results [] ) { final int t = ( a >>> n ^ b ) & m ; a ^= t << n ; MST[rv.ABSMutator]MSP[] b ^= t ;
permOp ( c , d , 8 , 0xff00ff , results ) ; c = results [ 0 ] ; d = results [ 1 ] ; permOp ( d , c , 1 , 0x55555555 , results ) ; MST[VoidMethodCallMutator]MSP[] d = results [ 0 ] ;
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.CRCR3Mutator]MSP[] c &= 0xfffffff ; int j = 0 ;
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.CRCR3Mutator]MSP[] c &= 0xfffffff ; int j = 0 ;
final int schedule [] = new int [ 32 ] ; int c = fourBytesToInt ( key , 0 ) ; MST[rv.CRCR5Mutator]MSP[] int d = fourBytesToInt ( key , 4 ) ; final int results [] = new int [ 2 ] ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[InlineConstantMutator]MSP[]
final char charOne = salt . charAt ( 1 ) ; buffer . setCharAt ( 0 , charZero ) ; buffer . setCharAt ( 1 , charOne ) ; final int eSwap0 = CON_SALT [ charZero ] ; final int eSwap1 = CON_SALT [ charOne ] << 4 ; MST[rv.ABSMutator]MSP[]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.UOI2Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
permOp ( d , c , 4 , 0xf0f0f0f , results ) ; MST[rv.UOI1Mutator]MSP[] d = results [ 0 ] ; c = results [ 1 ] ; c = hPermOp ( c , - 2 , 0xcccc0000 ) ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.UOI4Mutator]MSP[]
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; MST[rv.OBBN3Mutator]MSP[] d = d >>> 2 | d << 26 ; } else {
permOp ( d , c , 4 , 0xf0f0f0f , results ) ; MST[rv.UOI4Mutator]MSP[] d = results [ 0 ] ; c = results [ 1 ] ; c = hPermOp ( c , - 2 , 0xcccc0000 ) ;
right = results [ 0 ] ; left = results [ 1 ] ; MST[rv.CRCR4Mutator]MSP[] final int out [] = new int [ 2 ] ; out [ 0 ] = left ; out [ 1 ] = right ; return out ; }
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR2Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
y ++ ; u = 128 ; } buffer . setCharAt ( i , ( char ) COV2CHAR [ c ] ) ; MST[rv.ABSMutator]MSP[] } } return buffer . toString () ; } public static String crypt ( final String original ) {
for ( int i = 0 ; i < key . length && i < original . length ; i ++ ) { final int iChar = original [ i ] ; key [ i ] = (byte) ( iChar << 1 ) ; MST[rv.UOI3Mutator]MSP[] }
y ++ ; u = 128 ; } buffer . setCharAt ( i , ( char ) COV2CHAR [ c ] ) ; MST[rv.UOI1Mutator]MSP[] } } return buffer . toString () ; } public static String crypt ( final String original ) {
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR2Mutator]MSP[]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[MathMutator]MSP[]
final char charOne = salt . charAt ( 1 ) ; buffer . setCharAt ( 0 , charZero ) ; buffer . setCharAt ( 1 , charOne ) ; final int eSwap0 = CON_SALT [ charZero ] ; MST[rv.UOI4Mutator]MSP[] final int eSwap1 = CON_SALT [ charOne ] << 4 ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.UOI1Mutator]MSP[]
permOp ( left , right , 8 , 0xff00ff , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 2 , 0x33333333 , results ) ; right = results [ 0 ] ; MST[rv.ABSMutator]MSP[]
private static void permOp ( int a , int b , final int n , final int m , final int results [] ) { final int t = ( a >>> n ^ b ) & m ; a ^= t << n ; b ^= t ; MST[MathMutator]MSP[]
private static int byteToUnsigned ( final byte b ) { final int value = b ; return value < 0 ? value + 256 : value ; MST[rv.UOI1Mutator]MSP[] }
public static String crypt ( final byte [] original ) { return crypt ( original , null ) ; MST[ReturnValsMutator]MSP[] } public static String crypt ( final byte [] original , String salt ) { if ( salt == null ) { final ThreadLocalRandom randomGenerator = ThreadLocalRandom . current () ;
left = results [ 1 ] ; permOp ( left , right , 16 , 65535 , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; MST[rv.CRCR3Mutator]MSP[] permOp ( right , left , 4 , 0xf0f0f0f , results ) ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR6Mutator]MSP[]
} else if ( ! salt . matches ( lr_2 + B64 . B64T_STRING + lr_3 ) ) { throw new IllegalArgumentException ( lr_4 + salt ) ; MST[NonVoidMethodCallMutator]MSP[] } final StringBuilder buffer = new StringBuilder ( lr_5 ) ; final char charZero = salt . charAt ( 0 ) ;
s = s << 4 | s >>> 28 ; schedule [ j ++ ] = s ; MST[rv.ABSMutator]MSP[] } return schedule ; } private static int fourBytesToInt ( final byte b [] , int offset ) { int value = byteToUnsigned ( b [ offset ++ ] ) ;
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; } t = left ; left = right ; right = t ; MST[rv.UOI4Mutator]MSP[] } t = right ; right = left >>> 1 | left << 31 ;
permOp ( d , c , 4 , 0xf0f0f0f , results ) ; d = results [ 0 ] ; c = results [ 1 ] ; c = hPermOp ( c , - 2 , 0xcccc0000 ) ; MST[rv.CRCR6Mutator]MSP[]
private static int byteToUnsigned ( final byte b ) { final int value = b ; return value < 0 ? value + 256 : value ; MST[rv.UOI4Mutator]MSP[] }
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.UOI3Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; MST[rv.CRCR5Mutator]MSP[] a = a ^ t ^ t >>> 16 - n ; return a ; }
permOp ( left , right , 8 , 0xff00ff , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; MST[InlineConstantMutator]MSP[] permOp ( right , left , 2 , 0x33333333 , results ) ; right = results [ 0 ] ;
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.UOI4Mutator]MSP[] c &= 0xfffffff ; int j = 0 ;
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; MST[rv.UOI3Mutator]MSP[] return value ; }
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; MST[rv.CRCR6Mutator]MSP[] t = t >>> 4 | t << 28 ;
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { MST[rv.ROR4Mutator]MSP[] c = c >>> 2 | c << 26 ; d = d >>> 2 | d << 26 ; } else {
final char charOne = salt . charAt ( 1 ) ; buffer . setCharAt ( 0 , charZero ) ; buffer . setCharAt ( 1 , charOne ) ; final int eSwap0 = CON_SALT [ charZero ] ; final int eSwap1 = CON_SALT [ charOne ] << 4 ; MST[rv.CRCR5Mutator]MSP[]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR5Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR1Mutator]MSP[]
intToFourBytes ( out [ 1 ] , b , 4 ) ; b [ 8 ] = 0 ; int i = 2 ; int y = 0 ; int u = 128 ; for (; i < 13 ; i ++ ) { int j = 0 ; MST[rv.CRCR3Mutator]MSP[]
c = results [ 1 ] ; MST[rv.ABSMutator]MSP[] d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; c &= 0xfffffff ; int j = 0 ;
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; MST[rv.UOI3Mutator]MSP[] d = d >>> 2 | d << 26 ; } else {
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; MST[rv.AOD1Mutator]MSP[] a = a ^ t ^ t >>> 16 - n ; return a ; }
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR1Mutator]MSP[]
private static void permOp ( int a , int b , final int n , final int m , final int results [] ) { final int t = ( a >>> n ^ b ) & m ; a ^= t << n ; MST[rv.UOI2Mutator]MSP[] b ^= t ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[InlineConstantMutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; return value ; MST[ReturnValsMutator]MSP[] }
b [ offset ++ ] = (byte) ( iValue >>> 16 & 0xff ) ; MST[rv.CRCR6Mutator]MSP[] b [ offset ++ ] = (byte) ( iValue >>> 24 & 0xff ) ; }
public static String crypt ( final byte [] original ) { return crypt ( original , null ) ; } public static String crypt ( final byte [] original , String salt ) { if ( salt == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] final ThreadLocalRandom randomGenerator = ThreadLocalRandom . current () ;
final char charOne = salt . charAt ( 1 ) ; buffer . setCharAt ( 0 , charZero ) ; buffer . setCharAt ( 1 , charOne ) ; MST[rv.CRCR6Mutator]MSP[] final int eSwap0 = CON_SALT [ charZero ] ; final int eSwap1 = CON_SALT [ charOne ] << 4 ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR4Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
intToFourBytes ( out [ 1 ] , b , 4 ) ; b [ 8 ] = 0 ; int i = 2 ; int y = 0 ; MST[rv.CRCR1Mutator]MSP[] int u = 128 ; for (; i < 13 ; i ++ ) { int j = 0 ;
for ( int i = 0 ; i < 32 ; i += 4 ) { MST[rv.UOI2Mutator]MSP[] left = dEncrypt ( left , right , i , eSwap0 , eSwap1 , schedule ) ;
for ( int i = 0 ; i < 32 ; i += 4 ) { left = dEncrypt ( left , right , i , eSwap0 , eSwap1 , schedule ) ; MST[rv.UOI4Mutator]MSP[]
results [ 0 ] = a ; MST[rv.CRCR5Mutator]MSP[] results [ 1 ] = b ; }
int c = 0 ; for (; j < 6 ; j ++ ) { MST[rv.UOI2Mutator]MSP[] c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) {
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR3Mutator]MSP[]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.OBBN3Mutator]MSP[]
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.OBBN3Mutator]MSP[]
for ( int i = 0 ; i < 16 ; i ++ ) { MST[rv.ROR2Mutator]MSP[] if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; d = d >>> 2 | d << 26 ; } else {
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { MST[rv.UOI1Mutator]MSP[] c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) {
y ++ ; MST[experimental.RemoveIncrementsMutator]MSP[] u = 128 ; } buffer . setCharAt ( i , ( char ) COV2CHAR [ c ] ) ; } } return buffer . toString () ; } public static String crypt ( final String original ) {
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; MST[rv.UOI2Mutator]MSP[] value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; return value ; }
SKB [ 7 ] [ d >>> 21 & 0xf | d >>> 22 & 0x30 ] ; schedule [ j ++ ] = ( t << 16 | s & 0xffff ) ; s = s >>> 16 | t & 0xffff0000 ; MST[rv.CRCR6Mutator]MSP[]
left = results [ 1 ] ; permOp ( left , right , 16 , 65535 , results ) ; left = results [ 0 ] ; MST[InlineConstantMutator]MSP[] right = results [ 1 ] ; permOp ( right , left , 4 , 0xf0f0f0f , results ) ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.UOI2Mutator]MSP[]
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; MST[rv.AOD2Mutator]MSP[] } t = left ; left = right ; right = t ; } t = right ; right = left >>> 1 | left << 31 ;
permOp ( left , right , 8 , 0xff00ff , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 2 , 0x33333333 , results ) ; MST[rv.UOI3Mutator]MSP[] right = results [ 0 ] ;
right = results [ 0 ] ; left = results [ 1 ] ; final int out [] = new int [ 2 ] ; out [ 0 ] = left ; MST[rv.UOI4Mutator]MSP[] out [ 1 ] = right ; return out ; }
private static int byteToUnsigned ( final byte b ) { final int value = b ; return value < 0 ? value + 256 : value ; MST[rv.ABSMutator]MSP[] }
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.ABSMutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
intToFourBytes ( out [ 1 ] , b , 4 ) ; b [ 8 ] = 0 ; MST[InlineConstantMutator]MSP[] int i = 2 ; int y = 0 ; int u = 128 ; for (; i < 13 ; i ++ ) { int j = 0 ;
private static void intToFourBytes ( final int iValue , final byte b [] , int offset ) { b [ offset ++ ] = (byte) ( iValue & 0xff ) ; MST[rv.CRCR1Mutator]MSP[] b [ offset ++ ] = (byte) ( iValue >>> 8 & 0xff ) ;
permOp ( c , d , 8 , 0xff00ff , results ) ; c = results [ 0 ] ; d = results [ 1 ] ; permOp ( d , c , 1 , 0x55555555 , results ) ; MST[rv.CRCR3Mutator]MSP[] d = results [ 0 ] ;
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; d = d >>> 2 | d << 26 ; MST[MathMutator]MSP[] } else {
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; MST[rv.CRCR5Mutator]MSP[] value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; return value ; }
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.OBBN2Mutator]MSP[]
for ( int i = 0 ; i < key . length && i < original . length ; i ++ ) { MST[ConditionalsBoundaryMutator]MSP[] final int iChar = original [ i ] ; key [ i ] = (byte) ( iChar << 1 ) ; }
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; MST[rv.UOI3Mutator]MSP[] } t = left ; left = right ; right = t ; } t = right ; right = left >>> 1 | left << 31 ;
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; d = d >>> 2 | d << 26 ; MST[rv.CRCR2Mutator]MSP[] } else {
for ( int i = 0 ; i < key . length && i < original . length ; i ++ ) { final int iChar = original [ i ] ; MST[rv.UOI1Mutator]MSP[] key [ i ] = (byte) ( iChar << 1 ) ; }
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; MST[rv.UOI2Mutator]MSP[] } t = left ; left = right ; right = t ; } t = right ; right = left >>> 1 | left << 31 ;
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; d = d >>> 2 | d << 26 ; MST[rv.CRCR3Mutator]MSP[] } else {
c = c >>> 1 | c << 27 ; MST[rv.CRCR6Mutator]MSP[] d = d >>> 1 | d << 27 ; } c &= 0xfffffff ; d &= 0xfffffff ;
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; MST[NonVoidMethodCallMutator]MSP[] value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; return value ; }
permOp ( c , d , 8 , 0xff00ff , results ) ; MST[rv.CRCR2Mutator]MSP[] c = results [ 0 ] ; d = results [ 1 ] ; permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ;
intToFourBytes ( out [ 1 ] , b , 4 ) ; b [ 8 ] = 0 ; int i = 2 ; int y = 0 ; int u = 128 ; for (; i < 13 ; i ++ ) { MST[ConditionalsBoundaryMutator]MSP[] int j = 0 ;
right = results [ 0 ] ; left = results [ 1 ] ; final int out [] = new int [ 2 ] ; out [ 0 ] = left ; out [ 1 ] = right ; MST[rv.CRCR4Mutator]MSP[] return out ; }
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR4Mutator]MSP[]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR1Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
permOp ( left , right , 8 , 0xff00ff , results ) ; MST[rv.UOI2Mutator]MSP[] left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 2 , 0x33333333 , results ) ; right = results [ 0 ] ;
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; MST[rv.UOI1Mutator]MSP[] d = d >>> 2 | d << 26 ; } else {
final int schedule [] = desSetKey ( key ) ; final int out [] = body ( schedule , eSwap0 , eSwap1 ) ; MST[rv.UOI2Mutator]MSP[] final byte b [] = new byte [ 9 ] ; intToFourBytes ( out [ 0 ] , b , 0 ) ;
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.CRCR5Mutator]MSP[] c &= 0xfffffff ; int j = 0 ;
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; MST[rv.ABSMutator]MSP[] value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; return value ; }
left = results [ 1 ] ; permOp ( left , right , 16 , 65535 , results ) ; MST[rv.UOI3Mutator]MSP[] left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 4 , 0xf0f0f0f , results ) ;
permOp ( left , right , 8 , 0xff00ff , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 2 , 0x33333333 , results ) ; MST[rv.UOI2Mutator]MSP[] right = results [ 0 ] ;
left = t >>> 1 | t << 31 ; final int results [] = new int [ 2 ] ; permOp ( right , left , 1 , 0x55555555 , results ) ; MST[rv.UOI4Mutator]MSP[] right = results [ 0 ] ; left = results [ 1 ] ;
intToFourBytes ( out [ 1 ] , b , 4 ) ; b [ 8 ] = 0 ; MST[rv.CRCR1Mutator]MSP[] int i = 2 ; int y = 0 ; int u = 128 ; for (; i < 13 ; i ++ ) { int j = 0 ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR4Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; MST[InlineConstantMutator]MSP[] if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) {
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.ABSMutator]MSP[]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.OBBN1Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
left = t >>> 1 | t << 31 ; final int results [] = new int [ 2 ] ; permOp ( right , left , 1 , 0x55555555 , results ) ; right = results [ 0 ] ; MST[InlineConstantMutator]MSP[] left = results [ 1 ] ;
c = c >>> 1 | c << 27 ; d = d >>> 1 | d << 27 ; } c &= 0xfffffff ; d &= 0xfffffff ; MST[rv.CRCR5Mutator]MSP[]
c = c >>> 1 | c << 27 ; d = d >>> 1 | d << 27 ; } c &= 0xfffffff ; MST[rv.UOI3Mutator]MSP[] d &= 0xfffffff ;
left = results [ 1 ] ; permOp ( left , right , 16 , 65535 , results ) ; left = results [ 0 ] ; MST[rv.CRCR1Mutator]MSP[] right = results [ 1 ] ; permOp ( right , left , 4 , 0xf0f0f0f , results ) ;
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; MST[InlineConstantMutator]MSP[] a = a ^ t ^ t >>> 16 - n ; return a ; }
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; a = a ^ t ^ t >>> 16 - n ; MST[rv.AOR3Mutator]MSP[] return a ; }
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; MST[rv.UOI3Mutator]MSP[] t = t >>> 4 | t << 28 ;
private static int dEncrypt ( int el , final int r , final int s , final int e0 , final int e1 , final int sArr [] ) { int v = r ^ r >>> 16 ; MST[rv.CRCR6Mutator]MSP[] int u = v & e0 ; v &= e1 ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.UOI1Mutator]MSP[]
d = hPermOp ( d , - 2 , 0xcccc0000 ) ; permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ; MST[rv.UOI4Mutator]MSP[] c = results [ 1 ] ;
u = u ^ u << 16 ^ r ^ sArr [ s ] ; MST[MathMutator]MSP[] int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; t = t >>> 4 | t << 28 ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.UOI4Mutator]MSP[]
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; MST[rv.ABSMutator]MSP[] a = a ^ t ^ t >>> 16 - n ; return a ; }
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[InlineConstantMutator]MSP[]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR2Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR4Mutator]MSP[]
final int numSaltChars = SALT_CHARS . length ; salt = lr_1 + SALT_CHARS [ randomGenerator . nextInt ( numSaltChars ) ] + MST[experimental.NakedReceiverMutator]MSP[] SALT_CHARS [ randomGenerator . nextInt ( numSaltChars ) ] ;
c = c >>> 1 | c << 27 ; MST[MathMutator]MSP[] d = d >>> 1 | d << 27 ; } c &= 0xfffffff ; d &= 0xfffffff ;
for ( int i = 0 ; i < key . length && i < original . length ; i ++ ) { final int iChar = original [ i ] ; MST[rv.UOI4Mutator]MSP[] key [ i ] = (byte) ( iChar << 1 ) ; }
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.CRCR5Mutator]MSP[] c &= 0xfffffff ; int j = 0 ;
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { MST[rv.ABSMutator]MSP[] c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) {
d = hPermOp ( d , - 2 , 0xcccc0000 ) ; permOp ( d , c , 1 , 0x55555555 , results ) ; MST[InlineConstantMutator]MSP[] d = results [ 0 ] ; c = results [ 1 ] ;
for ( int i = 0 ; i < key . length && i < original . length ; i ++ ) { final int iChar = original [ i ] ; MST[rv.ABSMutator]MSP[] key [ i ] = (byte) ( iChar << 1 ) ; }
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.OBBN3Mutator]MSP[]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[MathMutator]MSP[]
s = s << 4 | s >>> 28 ; schedule [ j ++ ] = s ; MST[rv.UOI3Mutator]MSP[] } return schedule ; } private static int fourBytesToInt ( final byte b [] , int offset ) { int value = byteToUnsigned ( b [ offset ++ ] ) ;
b [ offset ++ ] = (byte) ( iValue >>> 16 & 0xff ) ; b [ offset ++ ] = (byte) ( iValue >>> 24 & 0xff ) ; MST[InlineConstantMutator]MSP[] }
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR6Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
for ( int i = 0 ; i < key . length && i < original . length ; i ++ ) { MST[rv.ROR3Mutator]MSP[] final int iChar = original [ i ] ; key [ i ] = (byte) ( iChar << 1 ) ; }
left = t >>> 1 | t << 31 ; final int results [] = new int [ 2 ] ; permOp ( right , left , 1 , 0x55555555 , results ) ; right = results [ 0 ] ; left = results [ 1 ] ; MST[rv.ABSMutator]MSP[]
final int schedule [] = desSetKey ( key ) ; final int out [] = body ( schedule , eSwap0 , eSwap1 ) ; final byte b [] = new byte [ 9 ] ; intToFourBytes ( out [ 0 ] , b , 0 ) ; MST[VoidMethodCallMutator]MSP[]
for ( int i = 0 ; i < 32 ; i += 4 ) { MST[rv.CRCR6Mutator]MSP[] left = dEncrypt ( left , right , i , eSwap0 , eSwap1 , schedule ) ;
SPTRANS [ 4 ] [ u >>> 16 & 0x3f ] | SPTRANS [ 6 ] [ u >>> 24 & 0x3f ] ; return el ; MST[PrimitiveReturnsMutator]MSP[] } private static int [] desSetKey ( final byte key [] ) {
private static void permOp ( int a , int b , final int n , final int m , final int results [] ) { final int t = ( a >>> n ^ b ) & m ; a ^= t << n ; MST[rv.UOI1Mutator]MSP[] b ^= t ;
private static int [] body ( final int schedule [] , final int eSwap0 , final int eSwap1 ) { int left = 0 ; int right = 0 ; MST[rv.CRCR6Mutator]MSP[] int t = 0 ; for ( int j = 0 ; j < 25 ; j ++ ) {
permOp ( d , c , 4 , 0xf0f0f0f , results ) ; d = results [ 0 ] ; MST[rv.UOI4Mutator]MSP[] c = results [ 1 ] ; c = hPermOp ( c , - 2 , 0xcccc0000 ) ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.OBBN2Mutator]MSP[]
s = s << 4 | s >>> 28 ; MST[rv.OBBN1Mutator]MSP[] schedule [ j ++ ] = s ; } return schedule ; } private static int fourBytesToInt ( final byte b [] , int offset ) { int value = byteToUnsigned ( b [ offset ++ ] ) ;
} else if ( ! salt . matches ( lr_2 + B64 . B64T_STRING + lr_3 ) ) { MST[rv.ROR5Mutator]MSP[] throw new IllegalArgumentException ( lr_4 + salt ) ; } final StringBuilder buffer = new StringBuilder ( lr_5 ) ; final char charZero = salt . charAt ( 0 ) ;
final char charOne = salt . charAt ( 1 ) ; buffer . setCharAt ( 0 , charZero ) ; buffer . setCharAt ( 1 , charOne ) ; MST[rv.CRCR3Mutator]MSP[] final int eSwap0 = CON_SALT [ charZero ] ; final int eSwap1 = CON_SALT [ charOne ] << 4 ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.UOI1Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
intToFourBytes ( out [ 1 ] , b , 4 ) ; b [ 8 ] = 0 ; int i = 2 ; MST[rv.CRCR4Mutator]MSP[] int y = 0 ; int u = 128 ; for (; i < 13 ; i ++ ) { int j = 0 ;
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; c &= 0xfffffff ; MST[rv.CRCR3Mutator]MSP[] int j = 0 ;
} else if ( ! salt . matches ( lr_2 + B64 . B64T_STRING + lr_3 ) ) { throw new IllegalArgumentException ( lr_4 + salt ) ; MST[experimental.NakedReceiverMutator]MSP[] } final StringBuilder buffer = new StringBuilder ( lr_5 ) ; final char charZero = salt . charAt ( 0 ) ;
final int numSaltChars = SALT_CHARS . length ; salt = lr_1 + SALT_CHARS [ randomGenerator . nextInt ( numSaltChars ) ] + MST[rv.UOI2Mutator]MSP[] SALT_CHARS [ randomGenerator . nextInt ( numSaltChars ) ] ;
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; a = a ^ t ^ t >>> 16 - n ; MST[rv.ABSMutator]MSP[] return a ; }
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.OBBN2Mutator]MSP[]
intToFourBytes ( out [ 1 ] , b , 4 ) ; b [ 8 ] = 0 ; int i = 2 ; int y = 0 ; int u = 128 ; for (; i < 13 ; i ++ ) { MST[IncrementsMutator]MSP[] int j = 0 ;
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; MST[rv.CRCR2Mutator]MSP[] value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; return value ; }
intToFourBytes ( out [ 1 ] , b , 4 ) ; b [ 8 ] = 0 ; int i = 2 ; int y = 0 ; int u = 128 ; for (; i < 13 ; i ++ ) { MST[rv.ROR3Mutator]MSP[] int j = 0 ;
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; MST[rv.UOI4Mutator]MSP[] t = t >>> 4 | t << 28 ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR5Mutator]MSP[]
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; MST[rv.OBBN1Mutator]MSP[] return value ; }
left = results [ 1 ] ; permOp ( left , right , 16 , 65535 , results ) ; MST[rv.CRCR6Mutator]MSP[] left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 4 , 0xf0f0f0f , results ) ;
left = results [ 1 ] ; MST[rv.CRCR2Mutator]MSP[] permOp ( left , right , 16 , 65535 , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 4 , 0xf0f0f0f , results ) ;
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; MST[rv.AOD1Mutator]MSP[] t = t >>> 4 | t << 28 ;
SPTRANS [ 4 ] [ u >>> 16 & 0x3f ] | SPTRANS [ 6 ] [ u >>> 24 & 0x3f ] ; return el ; MST[rv.UOI4Mutator]MSP[] } private static int [] desSetKey ( final byte key [] ) {
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.UOI1Mutator]MSP[] c &= 0xfffffff ; int j = 0 ;
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; a = a ^ t ^ t >>> 16 - n ; MST[rv.UOI1Mutator]MSP[] return a ; }
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; MST[rv.CRCR4Mutator]MSP[] t = t >>> 4 | t << 28 ;
c = c >>> 1 | c << 27 ; d = d >>> 1 | d << 27 ; MST[rv.OBBN1Mutator]MSP[] } c &= 0xfffffff ; d &= 0xfffffff ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[InlineConstantMutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR1Mutator]MSP[]
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[MathMutator]MSP[] c &= 0xfffffff ; int j = 0 ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR2Mutator]MSP[]
d = hPermOp ( d , - 2 , 0xcccc0000 ) ; MST[rv.CRCR4Mutator]MSP[] permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ; c = results [ 1 ] ;
d = hPermOp ( d , - 2 , 0xcccc0000 ) ; MST[rv.UOI4Mutator]MSP[] permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ; c = results [ 1 ] ;
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; } t = left ; left = right ; right = t ; } t = right ; right = left >>> 1 | left << 31 ; MST[rv.CRCR5Mutator]MSP[]
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; } t = left ; left = right ; right = t ; } t = right ; right = left >>> 1 | left << 31 ; MST[rv.CRCR4Mutator]MSP[]
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR5Mutator]MSP[]
private static void permOp ( int a , int b , final int n , final int m , final int results [] ) { final int t = ( a >>> n ^ b ) & m ; MST[rv.UOI3Mutator]MSP[] a ^= t << n ; b ^= t ;
left = results [ 1 ] ; permOp ( left , right , 16 , 65535 , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 4 , 0xf0f0f0f , results ) ; MST[rv.ABSMutator]MSP[]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.UOI2Mutator]MSP[]
c = c >>> 1 | c << 27 ; d = d >>> 1 | d << 27 ; } c &= 0xfffffff ; MST[MathMutator]MSP[] d &= 0xfffffff ;
left = results [ 1 ] ; permOp ( left , right , 16 , 65535 , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 4 , 0xf0f0f0f , results ) ; MST[rv.UOI4Mutator]MSP[]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.OBBN1Mutator]MSP[]
} else if ( ! salt . matches ( lr_2 + B64 . B64T_STRING + lr_3 ) ) { MST[NegateConditionalsMutator]MSP[] throw new IllegalArgumentException ( lr_4 + salt ) ; } final StringBuilder buffer = new StringBuilder ( lr_5 ) ; final char charZero = salt . charAt ( 0 ) ;
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { MST[rv.UOI3Mutator]MSP[] c = c >>> 2 | c << 26 ; d = d >>> 2 | d << 26 ; } else {
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[MathMutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[InlineConstantMutator]MSP[]
final byte key [] = new byte [ 8 ] ; MST[InlineConstantMutator]MSP[] for ( int i = 0 ; i < key . length ; i ++ ) { key [ i ] = 0 ; }
c = c >>> 1 | c << 27 ; d = d >>> 1 | d << 27 ; MST[rv.CRCR6Mutator]MSP[] } c &= 0xfffffff ; d &= 0xfffffff ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.UOI1Mutator]MSP[]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR2Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; t = t >>> 4 | t << 28 ; MST[rv.UOI2Mutator]MSP[]
c = c >>> 1 | c << 27 ; d = d >>> 1 | d << 27 ; } c &= 0xfffffff ; MST[rv.CRCR3Mutator]MSP[] d &= 0xfffffff ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.OBBN3Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.UOI4Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; MST[rv.OBBN3Mutator]MSP[] } u >>>= 1 ; if ( u == 0 ) {
u = u ^ u << 16 ^ r ^ sArr [ s ] ; MST[rv.ABSMutator]MSP[] int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; t = t >>> 4 | t << 28 ;
u = u ^ u << 16 ^ r ^ sArr [ s ] ; MST[rv.UOI4Mutator]MSP[] int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; t = t >>> 4 | t << 28 ;
c = c >>> 1 | c << 27 ; d = d >>> 1 | d << 27 ; MST[rv.ABSMutator]MSP[] } c &= 0xfffffff ; d &= 0xfffffff ;
private static void intToFourBytes ( final int iValue , final byte b [] , int offset ) { b [ offset ++ ] = (byte) ( iValue & 0xff ) ; b [ offset ++ ] = (byte) ( iValue >>> 8 & 0xff ) ; MST[rv.OBBN1Mutator]MSP[]
final int schedule [] = desSetKey ( key ) ; final int out [] = body ( schedule , eSwap0 , eSwap1 ) ; final byte b [] = new byte [ 9 ] ; intToFourBytes ( out [ 0 ] , b , 0 ) ; MST[InlineConstantMutator]MSP[]
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; } u >>>= 1 ; MST[rv.CRCR5Mutator]MSP[] if ( u == 0 ) {
SKB [ 7 ] [ d >>> 21 & 0xf | d >>> 22 & 0x30 ] ; schedule [ j ++ ] = ( t << 16 | s & 0xffff ) ; MST[rv.CRCR5Mutator]MSP[] s = s >>> 16 | t & 0xffff0000 ;
permOp ( d , c , 4 , 0xf0f0f0f , results ) ; d = results [ 0 ] ; c = results [ 1 ] ; c = hPermOp ( c , - 2 , 0xcccc0000 ) ; MST[rv.CRCR3Mutator]MSP[]
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; MST[rv.CRCR1Mutator]MSP[] d = d >>> 2 | d << 26 ; } else {
for ( int i = 0 ; i < 32 ; i += 4 ) { left = dEncrypt ( left , right , i , eSwap0 , eSwap1 , schedule ) ; MST[rv.UOI3Mutator]MSP[]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.OBBN3Mutator]MSP[]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.ABSMutator]MSP[]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR6Mutator]MSP[]
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.OBBN1Mutator]MSP[] c &= 0xfffffff ; int j = 0 ;
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.ABSMutator]MSP[] c &= 0xfffffff ; int j = 0 ;
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; MST[IncrementsMutator]MSP[] value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; return value ; }
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.UOI2Mutator]MSP[]
final int schedule [] = desSetKey ( key ) ; final int out [] = body ( schedule , eSwap0 , eSwap1 ) ; final byte b [] = new byte [ 9 ] ; MST[rv.CRCR5Mutator]MSP[] intToFourBytes ( out [ 0 ] , b , 0 ) ;
private static void permOp ( int a , int b , final int n , final int m , final int results [] ) { final int t = ( a >>> n ^ b ) & m ; a ^= t << n ; b ^= t ; MST[rv.UOI3Mutator]MSP[]
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; c &= 0xfffffff ; MST[MathMutator]MSP[] int j = 0 ;
permOp ( c , d , 8 , 0xff00ff , results ) ; c = results [ 0 ] ; d = results [ 1 ] ; MST[rv.CRCR2Mutator]MSP[] permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR5Mutator]MSP[]
c = results [ 1 ] ; MST[rv.CRCR3Mutator]MSP[] d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; c &= 0xfffffff ; int j = 0 ;
b [ offset ++ ] = (byte) ( iValue >>> 16 & 0xff ) ; b [ offset ++ ] = (byte) ( iValue >>> 24 & 0xff ) ; MST[MathMutator]MSP[] }
private static int byteToUnsigned ( final byte b ) { final int value = b ; MST[rv.UOI4Mutator]MSP[] return value < 0 ? value + 256 : value ; }
SKB [ 7 ] [ d >>> 21 & 0xf | d >>> 22 & 0x30 ] ; schedule [ j ++ ] = ( t << 16 | s & 0xffff ) ; s = s >>> 16 | t & 0xffff0000 ; MST[rv.OBBN3Mutator]MSP[]
private static int [] body ( final int schedule [] , final int eSwap0 , final int eSwap1 ) { int left = 0 ; int right = 0 ; int t = 0 ; for ( int j = 0 ; j < 25 ; j ++ ) { MST[rv.CRCR3Mutator]MSP[]
u = u ^ u << 16 ^ r ^ sArr [ s ] ; MST[rv.UOI1Mutator]MSP[] int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; t = t >>> 4 | t << 28 ;
b [ offset ++ ] = (byte) ( iValue >>> 16 & 0xff ) ; b [ offset ++ ] = (byte) ( iValue >>> 24 & 0xff ) ; MST[rv.CRCR3Mutator]MSP[] }
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; MST[rv.UOI3Mutator]MSP[] return value ; }
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; MST[rv.UOI3Mutator]MSP[] a = a ^ t ^ t >>> 16 - n ; return a ; }
left = t >>> 1 | t << 31 ; final int results [] = new int [ 2 ] ; permOp ( right , left , 1 , 0x55555555 , results ) ; right = results [ 0 ] ; MST[rv.UOI3Mutator]MSP[] left = results [ 1 ] ;
private static void intToFourBytes ( final int iValue , final byte b [] , int offset ) { b [ offset ++ ] = (byte) ( iValue & 0xff ) ; MST[rv.UOI1Mutator]MSP[] b [ offset ++ ] = (byte) ( iValue >>> 8 & 0xff ) ;
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; MST[rv.OBBN3Mutator]MSP[] value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; return value ; }
intToFourBytes ( out [ 1 ] , b , 4 ) ; b [ 8 ] = 0 ; int i = 2 ; int y = 0 ; int u = 128 ; for (; i < 13 ; i ++ ) { MST[rv.CRCR3Mutator]MSP[] int j = 0 ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[InlineConstantMutator]MSP[]
c = c >>> 1 | c << 27 ; d = d >>> 1 | d << 27 ; } c &= 0xfffffff ; d &= 0xfffffff ; MST[rv.OBBN1Mutator]MSP[]
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR4Mutator]MSP[]
private static void intToFourBytes ( final int iValue , final byte b [] , int offset ) { b [ offset ++ ] = (byte) ( iValue & 0xff ) ; b [ offset ++ ] = (byte) ( iValue >>> 8 & 0xff ) ; MST[rv.ABSMutator]MSP[]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.UOI1Mutator]MSP[]
SKB [ 7 ] [ d >>> 21 & 0xf | d >>> 22 & 0x30 ] ; schedule [ j ++ ] = ( t << 16 | s & 0xffff ) ; MST[rv.ABSMutator]MSP[] s = s >>> 16 | t & 0xffff0000 ;
b [ offset ++ ] = (byte) ( iValue >>> 16 & 0xff ) ; MST[rv.CRCR4Mutator]MSP[] b [ offset ++ ] = (byte) ( iValue >>> 24 & 0xff ) ; }
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.OBBN3Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
c = c >>> 1 | c << 27 ; d = d >>> 1 | d << 27 ; MST[rv.CRCR5Mutator]MSP[] } c &= 0xfffffff ; d &= 0xfffffff ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR6Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[InlineConstantMutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; MST[rv.UOI4Mutator]MSP[] value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; return value ; }
left = results [ 1 ] ; permOp ( left , right , 16 , 65535 , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 4 , 0xf0f0f0f , results ) ; MST[rv.CRCR1Mutator]MSP[]
intToFourBytes ( out [ 1 ] , b , 4 ) ; b [ 8 ] = 0 ; int i = 2 ; int y = 0 ; int u = 128 ; MST[rv.CRCR1Mutator]MSP[] for (; i < 13 ; i ++ ) { int j = 0 ;
permOp ( c , d , 8 , 0xff00ff , results ) ; c = results [ 0 ] ; d = results [ 1 ] ; permOp ( d , c , 1 , 0x55555555 , results ) ; MST[rv.UOI3Mutator]MSP[] d = results [ 0 ] ;
left = t >>> 1 | t << 31 ; MST[MathMutator]MSP[] final int results [] = new int [ 2 ] ; permOp ( right , left , 1 , 0x55555555 , results ) ; right = results [ 0 ] ; left = results [ 1 ] ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR2Mutator]MSP[]
SKB [ 7 ] [ d >>> 21 & 0xf | d >>> 22 & 0x30 ] ; schedule [ j ++ ] = ( t << 16 | s & 0xffff ) ; MST[rv.CRCR4Mutator]MSP[] s = s >>> 16 | t & 0xffff0000 ;
SKB [ 7 ] [ d >>> 21 & 0xf | d >>> 22 & 0x30 ] ; schedule [ j ++ ] = ( t << 16 | s & 0xffff ) ; s = s >>> 16 | t & 0xffff0000 ; MST[MathMutator]MSP[]
final char charOne = salt . charAt ( 1 ) ; buffer . setCharAt ( 0 , charZero ) ; buffer . setCharAt ( 1 , charOne ) ; final int eSwap0 = CON_SALT [ charZero ] ; MST[rv.UOI3Mutator]MSP[] final int eSwap1 = CON_SALT [ charOne ] << 4 ;
permOp ( c , d , 8 , 0xff00ff , results ) ; MST[rv.UOI2Mutator]MSP[] c = results [ 0 ] ; d = results [ 1 ] ; permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ;
SKB [ 7 ] [ d >>> 21 & 0xf | d >>> 22 & 0x30 ] ; schedule [ j ++ ] = ( t << 16 | s & 0xffff ) ; MST[rv.UOI2Mutator]MSP[] s = s >>> 16 | t & 0xffff0000 ;
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; MST[rv.CRCR2Mutator]MSP[] } t = left ; left = right ; right = t ; } t = right ; right = left >>> 1 | left << 31 ;
final char charOne = salt . charAt ( 1 ) ; buffer . setCharAt ( 0 , charZero ) ; buffer . setCharAt ( 1 , charOne ) ; MST[rv.UOI1Mutator]MSP[] final int eSwap0 = CON_SALT [ charZero ] ; final int eSwap1 = CON_SALT [ charOne ] << 4 ;
results [ 0 ] = a ; results [ 1 ] = b ; MST[rv.UOI2Mutator]MSP[] }
for ( int i = 0 ; i < key . length && i < original . length ; i ++ ) { MST[rv.CRCR1Mutator]MSP[] final int iChar = original [ i ] ; key [ i ] = (byte) ( iChar << 1 ) ; }
final byte key [] = new byte [ 8 ] ; for ( int i = 0 ; i < key . length ; i ++ ) { key [ i ] = 0 ; MST[InlineConstantMutator]MSP[] }
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.OBBN1Mutator]MSP[]
for ( int i = 0 ; i < 16 ; i ++ ) { MST[rv.CRCR2Mutator]MSP[] if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; d = d >>> 2 | d << 26 ; } else {
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR1Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
b [ offset ++ ] = (byte) ( iValue >>> 16 & 0xff ) ; b [ offset ++ ] = (byte) ( iValue >>> 24 & 0xff ) ; MST[rv.UOI1Mutator]MSP[] }
for ( int i = 0 ; i < 32 ; i += 4 ) { left = dEncrypt ( left , right , i , eSwap0 , eSwap1 , schedule ) ; MST[rv.ABSMutator]MSP[]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.UOI4Mutator]MSP[] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
for ( int i = 0 ; i < key . length && i < original . length ; i ++ ) { final int iChar = original [ i ] ; key [ i ] = (byte) ( iChar << 1 ) ; MST[MathMutator]MSP[] }
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; } u >>>= 1 ; MST[rv.ABSMutator]MSP[] if ( u == 0 ) {
for ( int i = 0 ; i < 32 ; i += 4 ) { MST[rv.CRCR2Mutator]MSP[] left = dEncrypt ( left , right , i , eSwap0 , eSwap1 , schedule ) ;
s = s << 4 | s >>> 28 ; MST[rv.CRCR6Mutator]MSP[] schedule [ j ++ ] = s ; } return schedule ; } private static int fourBytesToInt ( final byte b [] , int offset ) { int value = byteToUnsigned ( b [ offset ++ ] ) ;
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[InlineConstantMutator]MSP[] c &= 0xfffffff ; int j = 0 ;
s = s << 4 | s >>> 28 ; MST[rv.CRCR5Mutator]MSP[] schedule [ j ++ ] = s ; } return schedule ; } private static int fourBytesToInt ( final byte b [] , int offset ) { int value = byteToUnsigned ( b [ offset ++ ] ) ;
for ( int i = 0 ; i < key . length && i < original . length ; i ++ ) { MST[ConditionalsBoundaryMutator]MSP[] final int iChar = original [ i ] ; key [ i ] = (byte) ( iChar << 1 ) ; }
int c = 0 ; for (; j < 6 ; j ++ ) { MST[rv.CRCR2Mutator]MSP[] c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) {
permOp ( left , right , 8 , 0xff00ff , results ) ; left = results [ 0 ] ; MST[rv.UOI4Mutator]MSP[] right = results [ 1 ] ; permOp ( right , left , 2 , 0x33333333 , results ) ; right = results [ 0 ] ;
private static int byteToUnsigned ( final byte b ) { final int value = b ; return value < 0 ? value + 256 : value ; MST[rv.ROR2Mutator]MSP[] }
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; MST[rv.UOI2Mutator]MSP[] } t = left ; left = right ; right = t ; } t = right ; right = left >>> 1 | left << 31 ;
b [ offset ++ ] = (byte) ( iValue >>> 16 & 0xff ) ; MST[rv.UOI2Mutator]MSP[] b [ offset ++ ] = (byte) ( iValue >>> 24 & 0xff ) ; }
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; d = d >>> 2 | d << 26 ; MST[rv.UOI2Mutator]MSP[] } else {
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; d = d >>> 2 | d << 26 ; MST[rv.UOI3Mutator]MSP[] } else {
s = s << 4 | s >>> 28 ; MST[rv.ABSMutator]MSP[] schedule [ j ++ ] = s ; } return schedule ; } private static int fourBytesToInt ( final byte b [] , int offset ) { int value = byteToUnsigned ( b [ offset ++ ] ) ;
for ( int i = 0 ; i < key . length && i < original . length ; i ++ ) { final int iChar = original [ i ] ; key [ i ] = (byte) ( iChar << 1 ) ; MST[rv.CRCR3Mutator]MSP[] }
permOp ( left , right , 8 , 0xff00ff , results ) ; MST[rv.UOI1Mutator]MSP[] left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 2 , 0x33333333 , results ) ; right = results [ 0 ] ;
private static int dEncrypt ( int el , final int r , final int s , final int e0 , final int e1 , final int sArr [] ) { int v = r ^ r >>> 16 ; int u = v & e0 ; MST[rv.UOI3Mutator]MSP[] v &= e1 ;
