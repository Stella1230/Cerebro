public static String encodeBase64URLSafeString ( final byte [] binaryData ) { return StringUtils . newStringUsAscii ( encodeBase64 ( binaryData , false , true ) ) ; MST[rv.CRCR3Mutator]MSP[] } public static byte [] encodeInteger ( final BigInteger bigInteger ) { Objects . requireNonNull ( bigInteger , lr_3 ) ;
for ( int i = 0 ; i < arrayOctet . length ; i ++ ) { if ( ! isBase64 ( arrayOctet [ i ] ) && ! isWhiteSpace ( arrayOctet [ i ] ) ) { MST[NonVoidMethodCallMutator]MSP[] return false ; } } return true ; }
} public static String encodeBase64String ( final byte [] binaryData ) { return StringUtils . newStringUsAscii ( encodeBase64 ( binaryData , false ) ) ; MST[rv.CRCR1Mutator]MSP[] } public static byte [] encodeBase64URLSafe ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false , true ) ; }
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; MST[rv.AOD2Mutator]MSP[] System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; } @Override
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; MST[rv.CRCR3Mutator]MSP[] System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; } @Override
throw new IllegalStateException ( lr_4 + context . modulus ) ; MST[rv.UOI3Mutator]MSP[] } context . currentLinePos += context . pos - savedPos ; if ( lineLength > 0 && context . currentLinePos > 0 ) {
buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea >> 8 ) & MASK_8BITS ) ; buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea ) & MASK_8BITS ) ; MST[rv.CRCR1Mutator]MSP[] break; default:
public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked ) { return encodeBase64 ( binaryData , isChunked , false ) ; MST[rv.UOI4Mutator]MSP[] } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe ) {
for ( int i = 0 ; i < arrayOctet . length ; i ++ ) { MST[rv.UOI3Mutator]MSP[] if ( ! isBase64 ( arrayOctet [ i ] ) && ! isWhiteSpace ( arrayOctet [ i ] ) ) { return false ; } } return true ; }
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.AOR1Mutator]MSP[] return bigBytes ; } int startSrc = 0 ;
System . arraycopy ( lineSeparator , 0 , buffer , context . pos , lineSeparator . length ) ; context . pos += lineSeparator . length ; } } else { for ( int i = 0 ; i < inAvail ; i ++ ) { MST[IncrementsMutator]MSP[]
throw new IllegalStateException ( lr_4 + context . modulus ) ; } context . currentLinePos += context . pos - savedPos ; MST[rv.AOR3Mutator]MSP[] if ( lineLength > 0 && context . currentLinePos > 0 ) {
return octet >= 0 && octet < decodeTable . length && decodeTable [ octet ] != - 1 ; MST[rv.CRCR5Mutator]MSP[] } public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } private void validateCharacter ( final int emptyBitsMask , final Context context ) {
context . ibitWorkArea = ( context . ibitWorkArea << 8 ) + b ; if ( 0 == context . modulus ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 18 ) & MASK_6BITS ] ;
int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; MST[rv.CRCR3Mutator]MSP[] len -- ; } final int startDst = bitlen / 8 - len ;
context . ibitWorkArea = ( context . ibitWorkArea << 8 ) + b ; if ( 0 == context . modulus ) { buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 18 ) & MASK_6BITS ] ; MST[rv.CRCR4Mutator]MSP[]
break; } if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { context . modulus = ( context . modulus + 1 ) % BYTES_PER_ENCODED_BLOCK ; MST[rv.AOD2Mutator]MSP[]
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ context . pos ++ ] = pad ; buffer [ context . pos ++ ] = pad ; MST[rv.ABSMutator]MSP[] } break;
if ( inAvail < 0 ) { context . eof = true ; if ( 0 == context . modulus && lineLength == 0 ) { return; } final byte [] buffer = ensureBufferSize ( encodeSize , context ) ; MST[NonVoidMethodCallMutator]MSP[] final int savedPos = context . pos ;
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] } public static boolean isBase64 ( final byte [] arrayOctet ) {
if ( context . eof && context . modulus != 0 ) { final byte [] buffer = ensureBufferSize ( decodeSize , context ) ; switch ( context . modulus ) { MST[experimental.SwitchMutator]MSP[] case 1 : validateTrailingCharacter () ; break; case 2 : validateCharacter ( MASK_4BITS , context ) ;
System . arraycopy ( lineSeparator , 0 , buffer , context . pos , lineSeparator . length ) ; MST[rv.CRCR6Mutator]MSP[] context . pos += lineSeparator . length ; } } else { for ( int i = 0 ; i < inAvail ; i ++ ) {
bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ; MST[rv.UOI2Mutator]MSP[] final byte [] bigBytes = bigInt . toByteArray () ;
int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ; MST[rv.UOI1Mutator]MSP[]
System . arraycopy ( lineSeparator , 0 , buffer , context . pos , lineSeparator . length ) ; context . pos += lineSeparator . length ; } } else { for ( int i = 0 ; i < inAvail ; i ++ ) { MST[rv.UOI1Mutator]MSP[]
bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ; MST[rv.ABSMutator]MSP[] final byte [] bigBytes = bigInt . toByteArray () ;
buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea >> 8 ) & MASK_8BITS ) ; buffer [ context . pos ++ ] = (byte) ( context . ibitWorkArea & MASK_8BITS ) ; MST[InlineConstantMutator]MSP[] } } } }
break; } if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { context . modulus = ( context . modulus + 1 ) % BYTES_PER_ENCODED_BLOCK ; MST[MathMutator]MSP[]
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 12 ) & MASK_6BITS ] ; MST[rv.OBBN1Mutator]MSP[] buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 6 ) & MASK_6BITS ] ;
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ context . pos ++ ] = pad ; MST[rv.ABSMutator]MSP[] } break; default:
} public static String encodeBase64String ( final byte [] binaryData ) { return StringUtils . newStringUsAscii ( encodeBase64 ( binaryData , false ) ) ; } public static byte [] encodeBase64URLSafe ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false , true ) ; MST[InlineConstantMutator]MSP[] }
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[rv.UOI1Mutator]MSP[] } public static boolean isBase64 ( final byte [] arrayOctet ) {
throw new IllegalStateException ( lr_4 + context . modulus ) ; } } } @Override void encode ( final byte [] in , int inPos , final int inAvail , final Context context ) { if ( context . eof ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return; }
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ context . pos ++ ] = pad ; MST[rv.UOI4Mutator]MSP[] buffer [ context . pos ++ ] = pad ; } break;
buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea >> 8 ) & MASK_8BITS ) ; buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea ) & MASK_8BITS ) ; MST[MathMutator]MSP[] break; default:
break; } if ( b >= 0 && b < DECODE_TABLE . length ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { context . modulus = ( context . modulus + 1 ) % BYTES_PER_ENCODED_BLOCK ;
return encodeBase64 ( toIntegerBytes ( bigInteger ) , false ) ; } @Deprecated public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { return isBase64 ( arrayOctet ) ; MST[NonVoidMethodCallMutator]MSP[] } public static boolean isBase64 ( final byte octet ) {
switch ( context . modulus ) { case 0 : break; case 1 : buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 2 ) & MASK_6BITS ] ; MST[rv.UOI2Mutator]MSP[]
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ context . pos ++ ] = pad ; MST[rv.CRCR3Mutator]MSP[] buffer [ context . pos ++ ] = pad ; } break;
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[rv.CRCR6Mutator]MSP[] } public static boolean isBase64 ( final byte [] arrayOctet ) {
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.ROR5Mutator]MSP[] buffer [ context . pos ++ ] = pad ; } break; default:
context . ibitWorkArea = ( context . ibitWorkArea << 8 ) + b ; if ( 0 == context . modulus ) { MST[rv.UOI2Mutator]MSP[] buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 18 ) & MASK_6BITS ] ;
for ( int i = 0 ; i < inAvail ; i ++ ) { final byte [] buffer = ensureBufferSize ( decodeSize , context ) ; final byte b = in [ inPos ++ ] ; if ( b == pad ) { MST[rv.ABSMutator]MSP[] context . eof = true ;
System . arraycopy ( lineSeparator , 0 , buffer , context . pos , lineSeparator . length ) ; context . pos += lineSeparator . length ; MST[rv.AOR2Mutator]MSP[] } } else { for ( int i = 0 ; i < inAvail ; i ++ ) {
if ( context . eof && context . modulus != 0 ) { final byte [] buffer = ensureBufferSize ( decodeSize , context ) ; MST[NonVoidMethodCallMutator]MSP[] switch ( context . modulus ) { case 1 : validateTrailingCharacter () ; break; case 2 : validateCharacter ( MASK_4BITS , context ) ;
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[rv.CRCR3Mutator]MSP[] } public static boolean isBase64 ( final byte [] arrayOctet ) {
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 12 ) & MASK_6BITS ] ; buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 6 ) & MASK_6BITS ] ; MST[rv.OBBN2Mutator]MSP[]
context . ibitWorkArea = ( context . ibitWorkArea << 8 ) + b ; if ( 0 == context . modulus ) { buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 18 ) & MASK_6BITS ] ; MST[rv.UOI3Mutator]MSP[]
if ( binaryData == null || binaryData . length == 0 ) { return binaryData ; } final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; MST[rv.CRCR1Mutator]MSP[] final long len = b64 . getEncodedLength ( binaryData ) ;
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ context . pos ++ ] = pad ; MST[rv.AOD2Mutator]MSP[] buffer [ context . pos ++ ] = pad ; } break;
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea << 4 ) & MASK_6BITS ] ; MST[rv.UOI3Mutator]MSP[] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ context . pos ++ ] = pad ; buffer [ context . pos ++ ] = pad ; } break;
break; } if ( b >= 0 && b < DECODE_TABLE . length ) { MST[NegateConditionalsMutator]MSP[] final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { context . modulus = ( context . modulus + 1 ) % BYTES_PER_ENCODED_BLOCK ;
int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ; MST[rv.ABSMutator]MSP[]
switch ( context . modulus ) { case 0 : break; case 1 : buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 2 ) & MASK_6BITS ] ; MST[rv.CRCR2Mutator]MSP[]
buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea >> 8 ) & MASK_8BITS ) ; MST[rv.CRCR5Mutator]MSP[] buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea ) & MASK_8BITS ) ; break; default:
if ( isStrictDecoding () && ( context . ibitWorkArea & emptyBitsMask ) != 0 ) { MST[NonVoidMethodCallMutator]MSP[] throw new IllegalArgumentException ( lr_5 + lr_6 + lr_7 ) ; } } private void validateTrailingCharacter () { if ( isStrictDecoding () ) { throw new IllegalArgumentException ( lr_5 + lr_6 +
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 12 ) & MASK_6BITS ] ; MST[MathMutator]MSP[] buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 6 ) & MASK_6BITS ] ;
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[rv.ROR5Mutator]MSP[] } public static boolean isBase64 ( final byte [] arrayOctet ) {
switch ( context . modulus ) { MST[rv.UOI4Mutator]MSP[] case 0 : break; case 1 : buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 2 ) & MASK_6BITS ] ;
public static boolean isBase64 ( final String base64 ) { return isBase64 ( StringUtils . getBytesUtf8 ( base64 ) ) ; MST[NonVoidMethodCallMutator]MSP[] } static byte [] toIntegerBytes ( final BigInteger bigInt ) { int bitlen = bigInt . bitLength () ;
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ context . pos ++ ] = pad ; MST[rv.UOI1Mutator]MSP[] buffer [ context . pos ++ ] = pad ; } break;
buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea >> 8 ) & MASK_8BITS ) ; MST[rv.OBBN2Mutator]MSP[] buffer [ context . pos ++ ] = (byte) ( context . ibitWorkArea & MASK_8BITS ) ; } } } }
final byte [] buffer = ensureBufferSize ( encodeSize , context ) ; context . modulus = ( context . modulus + 1 ) % BYTES_PER_UNENCODED_BLOCK ; int b = in [ inPos ++ ] ; if ( b < 0 ) { MST[rv.UOI4Mutator]MSP[] b += 256 ; }
public static boolean isBase64 ( final String base64 ) { return isBase64 ( StringUtils . getBytesUtf8 ( base64 ) ) ; MST[BooleanFalseReturnValsMutator]MSP[] } static byte [] toIntegerBytes ( final BigInteger bigInt ) { int bitlen = bigInt . bitLength () ;
context . ibitWorkArea = ( context . ibitWorkArea << BITS_PER_ENCODED_BYTE ) + result ; if ( context . modulus == 0 ) { buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea >> 16 ) & MASK_8BITS ) ; MST[rv.CRCR3Mutator]MSP[]
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea << 4 ) & MASK_6BITS ] ; MST[rv.AOR1Mutator]MSP[] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ context . pos ++ ] = pad ; buffer [ context . pos ++ ] = pad ; } break;
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 12 ) & MASK_6BITS ] ; buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 6 ) & MASK_6BITS ] ; MST[rv.CRCR6Mutator]MSP[]
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 12 ) & MASK_6BITS ] ; MST[rv.CRCR5Mutator]MSP[] buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 6 ) & MASK_6BITS ] ;
context . ibitWorkArea = ( context . ibitWorkArea << BITS_PER_ENCODED_BYTE ) + result ; if ( context . modulus == 0 ) { buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea >> 16 ) & MASK_8BITS ) ; MST[MathMutator]MSP[]
for ( int i = 0 ; i < inAvail ; i ++ ) { final byte [] buffer = ensureBufferSize ( decodeSize , context ) ; final byte b = in [ inPos ++ ] ; MST[rv.UOI2Mutator]MSP[] if ( b == pad ) { context . eof = true ;
break; } if ( b >= 0 && b < DECODE_TABLE . length ) { MST[ConditionalsBoundaryMutator]MSP[] final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { context . modulus = ( context . modulus + 1 ) % BYTES_PER_ENCODED_BLOCK ;
if ( isStrictDecoding () && ( context . ibitWorkArea & emptyBitsMask ) != 0 ) { throw new IllegalArgumentException ( lr_5 + lr_6 + lr_7 ) ; } } private void validateTrailingCharacter () { if ( isStrictDecoding () ) { MST[NegateConditionalsMutator]MSP[] throw new IllegalArgumentException ( lr_5 + lr_6 +
buffer [ context . pos ++ ] = encodeTable [ context . ibitWorkArea & MASK_6BITS ] ; context . currentLinePos += BYTES_PER_ENCODED_BLOCK ; MST[rv.UOI3Mutator]MSP[] if ( lineLength > 0 && lineLength <= context . currentLinePos ) {
final byte [] buffer = ensureBufferSize ( encodeSize , context ) ; context . modulus = ( context . modulus + 1 ) % BYTES_PER_UNENCODED_BLOCK ; MST[rv.CRCR6Mutator]MSP[] int b = in [ inPos ++ ] ; if ( b < 0 ) { b += 256 ; }
public static BigInteger decodeInteger ( final byte [] pArray ) { return new BigInteger ( 1 , decodeBase64 ( pArray ) ) ; } public static byte [] encodeBase64 ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false ) ; MST[ArgumentPropagationMutator]MSP[] }
buffer [ context . pos ++ ] = encodeTable [ context . ibitWorkArea & MASK_6BITS ] ; MST[rv.UOI1Mutator]MSP[] context . currentLinePos += BYTES_PER_ENCODED_BLOCK ; if ( lineLength > 0 && lineLength <= context . currentLinePos ) {
break; } if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { context . modulus = ( context . modulus + 1 ) % BYTES_PER_ENCODED_BLOCK ; MST[rv.CRCR3Mutator]MSP[]
buffer [ context . pos ++ ] = encodeTable [ context . ibitWorkArea & MASK_6BITS ] ; MST[rv.UOI4Mutator]MSP[] context . currentLinePos += BYTES_PER_ENCODED_BLOCK ; if ( lineLength > 0 && lineLength <= context . currentLinePos ) {
break; } if ( b >= 0 && b < DECODE_TABLE . length ) { MST[rv.ABSMutator]MSP[] final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { context . modulus = ( context . modulus + 1 ) % BYTES_PER_ENCODED_BLOCK ;
void decode ( final byte [] in , int inPos , final int inAvail , final Context context ) { if ( context . eof ) { return; } if ( inAvail < 0 ) { context . eof = true ; MST[InlineConstantMutator]MSP[] }
public static byte [] decodeBase64 ( final byte [] base64Data ) { return new Base64 () . decode ( base64Data ) ; MST[NonVoidMethodCallMutator]MSP[] } public static byte [] decodeBase64 ( final String base64String ) { return new Base64 () . decode ( base64String ) ; }
buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea >> 8 ) & MASK_8BITS ) ; buffer [ context . pos ++ ] = (byte) ( context . ibitWorkArea & MASK_8BITS ) ; MST[rv.UOI3Mutator]MSP[] } } } }
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[ConditionalsBoundaryMutator]MSP[] } public static boolean isBase64 ( final byte [] arrayOctet ) {
if ( isStrictDecoding () && ( context . ibitWorkArea & emptyBitsMask ) != 0 ) { MST[rv.UOI3Mutator]MSP[] throw new IllegalArgumentException ( lr_5 + lr_6 + lr_7 ) ; } } private void validateTrailingCharacter () { if ( isStrictDecoding () ) { throw new IllegalArgumentException ( lr_5 + lr_6 +
throw new IllegalStateException ( lr_4 + context . modulus ) ; } context . currentLinePos += context . pos - savedPos ; MST[rv.UOI2Mutator]MSP[] if ( lineLength > 0 && context . currentLinePos > 0 ) {
throw new IllegalStateException ( lr_4 + context . modulus ) ; } context . currentLinePos += context . pos - savedPos ; MST[rv.UOI3Mutator]MSP[] if ( lineLength > 0 && context . currentLinePos > 0 ) {
buffer [ context . pos ++ ] = encodeTable [ context . ibitWorkArea & MASK_6BITS ] ; context . currentLinePos += BYTES_PER_ENCODED_BLOCK ; if ( lineLength > 0 && lineLength <= context . currentLinePos ) { MST[rv.ROR5Mutator]MSP[]
switch ( context . modulus ) { MST[rv.UOI1Mutator]MSP[] case 0 : break; case 1 : buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 2 ) & MASK_6BITS ] ;
throw new IllegalStateException ( lr_4 + context . modulus ) ; } context . currentLinePos += context . pos - savedPos ; if ( lineLength > 0 && context . currentLinePos > 0 ) { MST[rv.ROR5Mutator]MSP[]
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[NegateConditionalsMutator]MSP[] } public static boolean isBase64 ( final byte [] arrayOctet ) {
break; } if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { context . modulus = ( context . modulus + 1 ) % BYTES_PER_ENCODED_BLOCK ; MST[rv.AOR4Mutator]MSP[]
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea << 4 ) & MASK_6BITS ] ; MST[rv.CRCR3Mutator]MSP[] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ context . pos ++ ] = pad ; buffer [ context . pos ++ ] = pad ; } break;
buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea >> 8 ) & MASK_8BITS ) ; MST[rv.OBBN3Mutator]MSP[] buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea ) & MASK_8BITS ) ; break; default:
if ( context . eof && context . modulus != 0 ) { MST[NegateConditionalsMutator]MSP[] final byte [] buffer = ensureBufferSize ( decodeSize , context ) ; switch ( context . modulus ) { case 1 : validateTrailingCharacter () ; break; case 2 : validateCharacter ( MASK_4BITS , context ) ;
final byte [] buffer = ensureBufferSize ( encodeSize , context ) ; context . modulus = ( context . modulus + 1 ) % BYTES_PER_UNENCODED_BLOCK ; int b = in [ inPos ++ ] ; if ( b < 0 ) { MST[rv.UOI1Mutator]MSP[] b += 256 ; }
context . ibitWorkArea = ( context . ibitWorkArea << 8 ) + b ; MST[rv.AOD2Mutator]MSP[] if ( 0 == context . modulus ) { buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 18 ) & MASK_6BITS ] ;
bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ; MST[InlineConstantMutator]MSP[] final byte [] bigBytes = bigInt . toByteArray () ;
if ( isStrictDecoding () && ( context . ibitWorkArea & emptyBitsMask ) != 0 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] throw new IllegalArgumentException ( lr_5 + lr_6 + lr_7 ) ; } } private void validateTrailingCharacter () { if ( isStrictDecoding () ) { throw new IllegalArgumentException ( lr_5 + lr_6 +
buffer [ context . pos ++ ] = encodeTable [ context . ibitWorkArea & MASK_6BITS ] ; MST[rv.OBBN1Mutator]MSP[] context . currentLinePos += BYTES_PER_ENCODED_BLOCK ; if ( lineLength > 0 && lineLength <= context . currentLinePos ) {
if ( binaryData == null || binaryData . length == 0 ) { MST[NegateConditionalsMutator]MSP[] return binaryData ; } final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; final long len = b64 . getEncodedLength ( binaryData ) ;
return octet >= 0 && octet < decodeTable . length && decodeTable [ octet ] != - 1 ; MST[rv.ROR3Mutator]MSP[] } public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } private void validateCharacter ( final int emptyBitsMask , final Context context ) {
buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea >> 8 ) & MASK_8BITS ) ; MST[rv.AOR2Mutator]MSP[] buffer [ context . pos ++ ] = (byte) ( context . ibitWorkArea & MASK_8BITS ) ; } } } }
buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea >> 8 ) & MASK_8BITS ) ; MST[MathMutator]MSP[] buffer [ context . pos ++ ] = (byte) ( context . ibitWorkArea & MASK_8BITS ) ; } } } }
throw new IllegalStateException ( lr_4 + context . modulus ) ; } context . currentLinePos += context . pos - savedPos ; if ( lineLength > 0 && context . currentLinePos > 0 ) { MST[rv.ROR2Mutator]MSP[]
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 12 ) & MASK_6BITS ] ; buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 6 ) & MASK_6BITS ] ; MST[rv.UOI2Mutator]MSP[]
throw new IllegalStateException ( lr_4 + context . modulus ) ; } context . currentLinePos += context . pos - savedPos ; MST[experimental.MemberVariableMutator]MSP[] if ( lineLength > 0 && context . currentLinePos > 0 ) {
for ( int i = 0 ; i < inAvail ; i ++ ) { final byte [] buffer = ensureBufferSize ( decodeSize , context ) ; final byte b = in [ inPos ++ ] ; if ( b == pad ) { MST[rv.ROR5Mutator]MSP[] context . eof = true ;
case 2 : buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 10 ) & MASK_6BITS ] ; MST[rv.AOR2Mutator]MSP[] buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 4 ) & MASK_6BITS ] ;
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ context . pos ++ ] = pad ; MST[rv.ABSMutator]MSP[] buffer [ context . pos ++ ] = pad ; } break;
public static String encodeBase64URLSafeString ( final byte [] binaryData ) { return StringUtils . newStringUsAscii ( encodeBase64 ( binaryData , false , true ) ) ; MST[NonVoidMethodCallMutator]MSP[] } public static byte [] encodeInteger ( final BigInteger bigInteger ) { Objects . requireNonNull ( bigInteger , lr_3 ) ;
buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea >> 8 ) & MASK_8BITS ) ; MST[rv.AOR3Mutator]MSP[] buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea ) & MASK_8BITS ) ; break; default:
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] } public static boolean isBase64 ( final byte [] arrayOctet ) {
throw new IllegalStateException ( lr_4 + context . modulus ) ; } context . currentLinePos += context . pos - savedPos ; if ( lineLength > 0 && context . currentLinePos > 0 ) { MST[ConditionalsBoundaryMutator]MSP[]
case 2 : buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 10 ) & MASK_6BITS ] ; MST[experimental.MemberVariableMutator]MSP[] buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 4 ) & MASK_6BITS ] ;
case 2 : buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 10 ) & MASK_6BITS ] ; MST[MathMutator]MSP[] buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 4 ) & MASK_6BITS ] ;
case 2 : buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 10 ) & MASK_6BITS ] ; buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 4 ) & MASK_6BITS ] ; MST[rv.AOR3Mutator]MSP[]
final byte [] buffer = ensureBufferSize ( encodeSize , context ) ; MST[rv.ABSMutator]MSP[] context . modulus = ( context . modulus + 1 ) % BYTES_PER_UNENCODED_BLOCK ; int b = in [ inPos ++ ] ; if ( b < 0 ) { b += 256 ; }
buffer [ context . pos ++ ] = encodeTable [ context . ibitWorkArea & MASK_6BITS ] ; MST[rv.UOI3Mutator]MSP[] context . currentLinePos += BYTES_PER_ENCODED_BLOCK ; if ( lineLength > 0 && lineLength <= context . currentLinePos ) {
public static String encodeBase64URLSafeString ( final byte [] binaryData ) { return StringUtils . newStringUsAscii ( encodeBase64 ( binaryData , false , true ) ) ; MST[EmptyObjectReturnValsMutator]MSP[] } public static byte [] encodeInteger ( final BigInteger bigInteger ) { Objects . requireNonNull ( bigInteger , lr_3 ) ;
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[rv.UOI4Mutator]MSP[] } public static boolean isBase64 ( final byte [] arrayOctet ) {
throw new IllegalStateException ( lr_4 + context . modulus ) ; } context . currentLinePos += context . pos - savedPos ; MST[MathMutator]MSP[] if ( lineLength > 0 && context . currentLinePos > 0 ) {
case 2 : buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 10 ) & MASK_6BITS ] ; buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 4 ) & MASK_6BITS ] ; MST[rv.UOI1Mutator]MSP[]
context . ibitWorkArea = context . ibitWorkArea >> 4 ; buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea ) & MASK_8BITS ) ; MST[rv.OBBN1Mutator]MSP[] break; case 3 : validateCharacter ( MASK_2BITS , context ) ; context . ibitWorkArea = context . ibitWorkArea >> 2 ;
for ( int i = 0 ; i < arrayOctet . length ; i ++ ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[] if ( ! isBase64 ( arrayOctet [ i ] ) && ! isWhiteSpace ( arrayOctet [ i ] ) ) { return false ; } } return true ; }
throw new IllegalStateException ( lr_4 + context . modulus ) ; } context . currentLinePos += context . pos - savedPos ; MST[rv.AOR2Mutator]MSP[] if ( lineLength > 0 && context . currentLinePos > 0 ) {
buffer [ context . pos ++ ] = encodeTable [ context . ibitWorkArea & MASK_6BITS ] ; context . currentLinePos += BYTES_PER_ENCODED_BLOCK ; if ( lineLength > 0 && lineLength <= context . currentLinePos ) { MST[rv.ROR2Mutator]MSP[]
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; MST[rv.CRCR6Mutator]MSP[] System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; } @Override
for ( int i = 0 ; i < inAvail ; i ++ ) { final byte [] buffer = ensureBufferSize ( decodeSize , context ) ; MST[rv.UOI2Mutator]MSP[] final byte b = in [ inPos ++ ] ; if ( b == pad ) { context . eof = true ;
return octet >= 0 && octet < decodeTable . length && decodeTable [ octet ] != - 1 ; MST[rv.CRCR5Mutator]MSP[] } public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } private void validateCharacter ( final int emptyBitsMask , final Context context ) {
final byte [] buffer = ensureBufferSize ( encodeSize , context ) ; context . modulus = ( context . modulus + 1 ) % BYTES_PER_UNENCODED_BLOCK ; int b = in [ inPos ++ ] ; MST[rv.UOI2Mutator]MSP[] if ( b < 0 ) { b += 256 ; }
if ( len > maxResultSize ) { MST[rv.UOI3Mutator]MSP[] throw new IllegalArgumentException ( lr_1 + len + lr_2 + maxResultSize ) ; } return b64 . encode ( binaryData ) ; } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { return encodeBase64 ( binaryData , true ) ;
buffer [ context . pos ++ ] = encodeTable [ context . ibitWorkArea & MASK_6BITS ] ; context . currentLinePos += BYTES_PER_ENCODED_BLOCK ; MST[experimental.MemberVariableMutator]MSP[] if ( lineLength > 0 && lineLength <= context . currentLinePos ) {
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[ReturnValsMutator]MSP[] } public static boolean isBase64 ( final byte [] arrayOctet ) {
context . ibitWorkArea = context . ibitWorkArea >> 4 ; buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea ) & MASK_8BITS ) ; MST[rv.UOI3Mutator]MSP[] break; case 3 : validateCharacter ( MASK_2BITS , context ) ; context . ibitWorkArea = context . ibitWorkArea >> 2 ;
throw new IllegalStateException ( lr_4 + context . modulus ) ; } context . currentLinePos += context . pos - savedPos ; if ( lineLength > 0 && context . currentLinePos > 0 ) { MST[rv.ROR3Mutator]MSP[]
buffer [ context . pos ++ ] = encodeTable [ context . ibitWorkArea & MASK_6BITS ] ; context . currentLinePos += BYTES_PER_ENCODED_BLOCK ; MST[MathMutator]MSP[] if ( lineLength > 0 && lineLength <= context . currentLinePos ) {
} public static String encodeBase64String ( final byte [] binaryData ) { return StringUtils . newStringUsAscii ( encodeBase64 ( binaryData , false ) ) ; } public static byte [] encodeBase64URLSafe ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false , true ) ; MST[rv.CRCR1Mutator]MSP[] }
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea << 2 ) & MASK_6BITS ] ; MST[rv.ABSMutator]MSP[] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ context . pos ++ ] = pad ; } break; default:
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 12 ) & MASK_6BITS ] ; MST[rv.AOD1Mutator]MSP[] buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 6 ) & MASK_6BITS ] ;
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 12 ) & MASK_6BITS ] ; buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 6 ) & MASK_6BITS ] ; MST[rv.ABSMutator]MSP[]
context . ibitWorkArea = context . ibitWorkArea >> 4 ; buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea ) & MASK_8BITS ) ; MST[rv.CRCR5Mutator]MSP[] break; case 3 : validateCharacter ( MASK_2BITS , context ) ; context . ibitWorkArea = context . ibitWorkArea >> 2 ;
final byte [] buffer = ensureBufferSize ( encodeSize , context ) ; context . modulus = ( context . modulus + 1 ) % BYTES_PER_UNENCODED_BLOCK ; MST[rv.CRCR3Mutator]MSP[] int b = in [ inPos ++ ] ; if ( b < 0 ) { b += 256 ; }
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea << 2 ) & MASK_6BITS ] ; MST[rv.AOD2Mutator]MSP[] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ context . pos ++ ] = pad ; } break; default:
final byte [] buffer = ensureBufferSize ( encodeSize , context ) ; context . modulus = ( context . modulus + 1 ) % BYTES_PER_UNENCODED_BLOCK ; int b = in [ inPos ++ ] ; MST[rv.ABSMutator]MSP[] if ( b < 0 ) { b += 256 ; }
int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { MST[InlineConstantMutator]MSP[] startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
for ( int i = 0 ; i < inAvail ; i ++ ) { final byte [] buffer = ensureBufferSize ( decodeSize , context ) ; final byte b = in [ inPos ++ ] ; if ( b == pad ) { MST[NegateConditionalsMutator]MSP[] context . eof = true ;
buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea >> 8 ) & MASK_8BITS ) ; buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea ) & MASK_8BITS ) ; MST[rv.UOI4Mutator]MSP[] break; default:
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 12 ) & MASK_6BITS ] ; buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 6 ) & MASK_6BITS ] ; MST[rv.CRCR3Mutator]MSP[]
buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea >> 8 ) & MASK_8BITS ) ; buffer [ context . pos ++ ] = (byte) ( context . ibitWorkArea & MASK_8BITS ) ; MST[rv.CRCR4Mutator]MSP[] } } } }
if ( binaryData == null || binaryData . length == 0 ) { MST[rv.ROR5Mutator]MSP[] return binaryData ; } final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; final long len = b64 . getEncodedLength ( binaryData ) ;
int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; MST[rv.CRCR6Mutator]MSP[] len -- ; } final int startDst = bitlen / 8 - len ;
buffer [ context . pos ++ ] = encodeTable [ context . ibitWorkArea & MASK_6BITS ] ; MST[rv.CRCR4Mutator]MSP[] context . currentLinePos += BYTES_PER_ENCODED_BLOCK ; if ( lineLength > 0 && lineLength <= context . currentLinePos ) {
throw new IllegalStateException ( lr_4 + context . modulus ) ; MST[experimental.NakedReceiverMutator]MSP[] } } } @Override void encode ( final byte [] in , int inPos , final int inAvail , final Context context ) { if ( context . eof ) { return; }
buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea >> 8 ) & MASK_8BITS ) ; MST[rv.ABSMutator]MSP[] buffer [ context . pos ++ ] = (byte) ( context . ibitWorkArea & MASK_8BITS ) ; } } } }
buffer [ context . pos ++ ] = encodeTable [ context . ibitWorkArea & MASK_6BITS ] ; MST[rv.CRCR5Mutator]MSP[] context . currentLinePos += BYTES_PER_ENCODED_BLOCK ; if ( lineLength > 0 && lineLength <= context . currentLinePos ) {
final byte [] buffer = ensureBufferSize ( encodeSize , context ) ; MST[rv.UOI2Mutator]MSP[] context . modulus = ( context . modulus + 1 ) % BYTES_PER_UNENCODED_BLOCK ; int b = in [ inPos ++ ] ; if ( b < 0 ) { b += 256 ; }
if ( inAvail < 0 ) { context . eof = true ; if ( 0 == context . modulus && lineLength == 0 ) { MST[NegateConditionalsMutator]MSP[] return; } final byte [] buffer = ensureBufferSize ( encodeSize , context ) ; final int savedPos = context . pos ;
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 12 ) & MASK_6BITS ] ; MST[rv.UOI1Mutator]MSP[] buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 6 ) & MASK_6BITS ] ;
return encodeBase64 ( binaryData , isChunked , urlSafe , Integer . MAX_VALUE ) ; MST[rv.CRCR4Mutator]MSP[] } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe , final int maxResultSize ) {
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; MST[rv.UOI2Mutator]MSP[] return resizedBytes ; } @Override
throw new IllegalStateException ( lr_4 + context . modulus ) ; MST[NonVoidMethodCallMutator]MSP[] } context . currentLinePos += context . pos - savedPos ; if ( lineLength > 0 && context . currentLinePos > 0 ) {
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ context . pos ++ ] = pad ; MST[rv.UOI2Mutator]MSP[] buffer [ context . pos ++ ] = pad ; } break;
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.AOR2Mutator]MSP[] return bigBytes ; } int startSrc = 0 ;
if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_1 + len + lr_2 + maxResultSize ) ; } return b64 . encode ( binaryData ) ; } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { return encodeBase64 ( binaryData , true ) ; MST[rv.CRCR5Mutator]MSP[]
context . ibitWorkArea = ( context . ibitWorkArea << BITS_PER_ENCODED_BYTE ) + result ; MST[rv.UOI1Mutator]MSP[] if ( context . modulus == 0 ) { buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea >> 16 ) & MASK_8BITS ) ;
context . ibitWorkArea = context . ibitWorkArea >> 4 ; buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea ) & MASK_8BITS ) ; MST[rv.AOR3Mutator]MSP[] break; case 3 : validateCharacter ( MASK_2BITS , context ) ; context . ibitWorkArea = context . ibitWorkArea >> 2 ;
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea << 4 ) & MASK_6BITS ] ; MST[MathMutator]MSP[] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ context . pos ++ ] = pad ; buffer [ context . pos ++ ] = pad ; } break;
context . ibitWorkArea = ( context . ibitWorkArea << BITS_PER_ENCODED_BYTE ) + result ; if ( context . modulus == 0 ) { MST[rv.UOI3Mutator]MSP[] buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea >> 16 ) & MASK_8BITS ) ;
context . ibitWorkArea = ( context . ibitWorkArea << 8 ) + b ; if ( 0 == context . modulus ) { MST[rv.CRCR6Mutator]MSP[] buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 18 ) & MASK_6BITS ] ;
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[rv.ROR2Mutator]MSP[] } public static boolean isBase64 ( final byte [] arrayOctet ) {
break; } if ( b >= 0 && b < DECODE_TABLE . length ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { context . modulus = ( context . modulus + 1 ) % BYTES_PER_ENCODED_BLOCK ;
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 12 ) & MASK_6BITS ] ; MST[rv.UOI4Mutator]MSP[] buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 6 ) & MASK_6BITS ] ;
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea << 2 ) & MASK_6BITS ] ; MST[rv.UOI2Mutator]MSP[] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ context . pos ++ ] = pad ; } break; default:
return octet >= 0 && octet < decodeTable . length && decodeTable [ octet ] != - 1 ; MST[NegateConditionalsMutator]MSP[] } public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } private void validateCharacter ( final int emptyBitsMask , final Context context ) {
for ( int i = 0 ; i < inAvail ; i ++ ) { final byte [] buffer = ensureBufferSize ( decodeSize , context ) ; MST[rv.ABSMutator]MSP[] final byte b = in [ inPos ++ ] ; if ( b == pad ) { context . eof = true ;
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[rv.UOI2Mutator]MSP[] } public static boolean isBase64 ( final byte [] arrayOctet ) {
case 2 : buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 10 ) & MASK_6BITS ] ; buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 4 ) & MASK_6BITS ] ; MST[rv.CRCR2Mutator]MSP[]
public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked ) { return encodeBase64 ( binaryData , isChunked , false ) ; MST[ReturnValsMutator]MSP[] } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe ) {
for ( int i = 0 ; i < arrayOctet . length ; i ++ ) { if ( ! isBase64 ( arrayOctet [ i ] ) && ! isWhiteSpace ( arrayOctet [ i ] ) ) { MST[rv.ROR3Mutator]MSP[] return false ; } } return true ; }
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ context . pos ++ ] = pad ; MST[rv.UOI4Mutator]MSP[] } break; default:
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[rv.CRCR6Mutator]MSP[] } public static boolean isBase64 ( final byte [] arrayOctet ) {
final byte [] buffer = ensureBufferSize ( encodeSize , context ) ; context . modulus = ( context . modulus + 1 ) % BYTES_PER_UNENCODED_BLOCK ; int b = in [ inPos ++ ] ; MST[IncrementsMutator]MSP[] if ( b < 0 ) { b += 256 ; }
public static BigInteger decodeInteger ( final byte [] pArray ) { return new BigInteger ( 1 , decodeBase64 ( pArray ) ) ; MST[InlineConstantMutator]MSP[] } public static byte [] encodeBase64 ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false ) ; }
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; MST[ReturnValsMutator]MSP[] } @Override
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea << 2 ) & MASK_6BITS ] ; MST[rv.CRCR3Mutator]MSP[] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ context . pos ++ ] = pad ; } break; default:
if ( isStrictDecoding () && ( context . ibitWorkArea & emptyBitsMask ) != 0 ) { MST[rv.OBBN1Mutator]MSP[] throw new IllegalArgumentException ( lr_5 + lr_6 + lr_7 ) ; } } private void validateTrailingCharacter () { if ( isStrictDecoding () ) { throw new IllegalArgumentException ( lr_5 + lr_6 +
for ( int i = 0 ; i < arrayOctet . length ; i ++ ) { if ( ! isBase64 ( arrayOctet [ i ] ) && ! isWhiteSpace ( arrayOctet [ i ] ) ) { MST[rv.UOI4Mutator]MSP[] return false ; } } return true ; }
int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ; MST[rv.UOI2Mutator]MSP[]
if ( inAvail < 0 ) { context . eof = true ; if ( 0 == context . modulus && lineLength == 0 ) { MST[rv.ROR5Mutator]MSP[] return; } final byte [] buffer = ensureBufferSize ( encodeSize , context ) ; final int savedPos = context . pos ;
public static String encodeBase64URLSafeString ( final byte [] binaryData ) { return StringUtils . newStringUsAscii ( encodeBase64 ( binaryData , false , true ) ) ; MST[InlineConstantMutator]MSP[] } public static byte [] encodeInteger ( final BigInteger bigInteger ) { Objects . requireNonNull ( bigInteger , lr_3 ) ;
return octet >= 0 && octet < decodeTable . length && decodeTable [ octet ] != - 1 ; } public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; MST[rv.CRCR4Mutator]MSP[] } private void validateCharacter ( final int emptyBitsMask , final Context context ) {
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[rv.UOI3Mutator]MSP[] } public static boolean isBase64 ( final byte [] arrayOctet ) {
for ( int i = 0 ; i < arrayOctet . length ; i ++ ) { if ( ! isBase64 ( arrayOctet [ i ] ) && ! isWhiteSpace ( arrayOctet [ i ] ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return false ; } } return true ; }
context . ibitWorkArea = ( context . ibitWorkArea << 8 ) + b ; MST[rv.AOR4Mutator]MSP[] if ( 0 == context . modulus ) { buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 18 ) & MASK_6BITS ] ;
if ( isStrictDecoding () && ( context . ibitWorkArea & emptyBitsMask ) != 0 ) { throw new IllegalArgumentException ( lr_5 + lr_6 + lr_7 ) ; } } private void validateTrailingCharacter () { if ( isStrictDecoding () ) { MST[rv.ROR2Mutator]MSP[] throw new IllegalArgumentException ( lr_5 + lr_6 +
throw new IllegalStateException ( lr_4 + context . modulus ) ; MST[rv.UOI1Mutator]MSP[] } } } @Override void encode ( final byte [] in , int inPos , final int inAvail , final Context context ) { if ( context . eof ) { return; }
context . ibitWorkArea = ( context . ibitWorkArea << 8 ) + b ; if ( 0 == context . modulus ) { buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 18 ) & MASK_6BITS ] ; MST[InlineConstantMutator]MSP[]
public static String encodeBase64URLSafeString ( final byte [] binaryData ) { return StringUtils . newStringUsAscii ( encodeBase64 ( binaryData , false , true ) ) ; } public static byte [] encodeInteger ( final BigInteger bigInteger ) { Objects . requireNonNull ( bigInteger , lr_3 ) ; MST[ArgumentPropagationMutator]MSP[]
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ context . pos ++ ] = pad ; buffer [ context . pos ++ ] = pad ; MST[rv.UOI4Mutator]MSP[] } break;
System . arraycopy ( lineSeparator , 0 , buffer , context . pos , lineSeparator . length ) ; MST[rv.UOI3Mutator]MSP[] context . pos += lineSeparator . length ; context . currentLinePos = 0 ; } } } } } @Override protected boolean isInAlphabet ( final byte octet ) {
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.ROR4Mutator]MSP[] return bigBytes ; } int startSrc = 0 ;
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; MST[rv.AOR4Mutator]MSP[] System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; } @Override
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea << 2 ) & MASK_6BITS ] ; MST[rv.ABSMutator]MSP[] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ context . pos ++ ] = pad ; } break; default:
System . arraycopy ( lineSeparator , 0 , buffer , context . pos , lineSeparator . length ) ; MST[rv.CRCR3Mutator]MSP[] context . pos += lineSeparator . length ; } } else { for ( int i = 0 ; i < inAvail ; i ++ ) {
int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ; MST[rv.AOR2Mutator]MSP[]
break; } if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { context . modulus = ( context . modulus + 1 ) % BYTES_PER_ENCODED_BLOCK ; MST[rv.CRCR5Mutator]MSP[]
if ( binaryData == null || binaryData . length == 0 ) { return binaryData ; MST[NullReturnValsMutator]MSP[] } final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; final long len = b64 . getEncodedLength ( binaryData ) ;
int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { MST[NonVoidMethodCallMutator]MSP[] startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
buffer [ context . pos ++ ] = encodeTable [ context . ibitWorkArea & MASK_6BITS ] ; context . currentLinePos += BYTES_PER_ENCODED_BLOCK ; if ( lineLength > 0 && lineLength <= context . currentLinePos ) { MST[rv.UOI4Mutator]MSP[]
context . ibitWorkArea = ( context . ibitWorkArea << 8 ) + b ; if ( 0 == context . modulus ) { buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 18 ) & MASK_6BITS ] ; MST[rv.CRCR2Mutator]MSP[]
int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ; MST[rv.CRCR3Mutator]MSP[]
throw new IllegalStateException ( lr_4 + context . modulus ) ; } context . currentLinePos += context . pos - savedPos ; if ( lineLength > 0 && context . currentLinePos > 0 ) { MST[rv.UOI4Mutator]MSP[]
bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ; MST[rv.CRCR5Mutator]MSP[] final byte [] bigBytes = bigInt . toByteArray () ;
if ( len > maxResultSize ) { MST[rv.ROR2Mutator]MSP[] throw new IllegalArgumentException ( lr_1 + len + lr_2 + maxResultSize ) ; } return b64 . encode ( binaryData ) ; } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { return encodeBase64 ( binaryData , true ) ;
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 12 ) & MASK_6BITS ] ; MST[rv.CRCR5Mutator]MSP[] buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 6 ) & MASK_6BITS ] ;
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.CRCR4Mutator]MSP[] return bigBytes ; } int startSrc = 0 ;
if ( context . eof && context . modulus != 0 ) { MST[rv.ROR3Mutator]MSP[] final byte [] buffer = ensureBufferSize ( decodeSize , context ) ; switch ( context . modulus ) { case 1 : validateTrailingCharacter () ; break; case 2 : validateCharacter ( MASK_4BITS , context ) ;
bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ; MST[rv.CRCR1Mutator]MSP[] final byte [] bigBytes = bigInt . toByteArray () ;
return encodeBase64 ( binaryData , isChunked , urlSafe , Integer . MAX_VALUE ) ; MST[rv.UOI3Mutator]MSP[] } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe , final int maxResultSize ) {
int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ; MST[rv.AOD2Mutator]MSP[]
public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked ) { return encodeBase64 ( binaryData , isChunked , false ) ; MST[NonVoidMethodCallMutator]MSP[] } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe ) {
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { return bigBytes ; } int startSrc = 0 ; MST[rv.CRCR5Mutator]MSP[]
System . arraycopy ( lineSeparator , 0 , buffer , context . pos , lineSeparator . length ) ; context . pos += lineSeparator . length ; } } else { for ( int i = 0 ; i < inAvail ; i ++ ) { MST[NegateConditionalsMutator]MSP[]
if ( binaryData == null || binaryData . length == 0 ) { return binaryData ; } final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; MST[rv.ROR5Mutator]MSP[] final long len = b64 . getEncodedLength ( binaryData ) ;
switch ( context . modulus ) { case 0 : break; case 1 : buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 2 ) & MASK_6BITS ] ; MST[rv.OBBN2Mutator]MSP[]
break; } if ( b >= 0 && b < DECODE_TABLE . length ) { MST[rv.UOI4Mutator]MSP[] final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { context . modulus = ( context . modulus + 1 ) % BYTES_PER_ENCODED_BLOCK ;
break; } if ( b >= 0 && b < DECODE_TABLE . length ) { MST[rv.ROR2Mutator]MSP[] final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { context . modulus = ( context . modulus + 1 ) % BYTES_PER_ENCODED_BLOCK ;
if ( isStrictDecoding () && ( context . ibitWorkArea & emptyBitsMask ) != 0 ) { throw new IllegalArgumentException ( lr_5 + lr_6 + lr_7 ) ; } } private void validateTrailingCharacter () { if ( isStrictDecoding () ) { throw new IllegalArgumentException ( MST[ConstructorCallMutator]MSP[] lr_5 + lr_6 +
context . ibitWorkArea = ( context . ibitWorkArea << 8 ) + b ; if ( 0 == context . modulus ) { MST[rv.CRCR3Mutator]MSP[] buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 18 ) & MASK_6BITS ] ;
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.AOR2Mutator]MSP[] return bigBytes ; } int startSrc = 0 ;
if ( isStrictDecoding () && ( context . ibitWorkArea & emptyBitsMask ) != 0 ) { MST[rv.ROR3Mutator]MSP[] throw new IllegalArgumentException ( lr_5 + lr_6 + lr_7 ) ; } } private void validateTrailingCharacter () { if ( isStrictDecoding () ) { throw new IllegalArgumentException ( lr_5 + lr_6 +
if ( isStrictDecoding () && ( context . ibitWorkArea & emptyBitsMask ) != 0 ) { MST[rv.ABSMutator]MSP[] throw new IllegalArgumentException ( lr_5 + lr_6 + lr_7 ) ; } } private void validateTrailingCharacter () { if ( isStrictDecoding () ) { throw new IllegalArgumentException ( lr_5 + lr_6 +
public static byte [] decodeBase64 ( final byte [] base64Data ) { return new Base64 () . decode ( base64Data ) ; } public static byte [] decodeBase64 ( final String base64String ) { return new Base64 () . decode ( base64String ) ; MST[ConstructorCallMutator]MSP[] }
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 12 ) & MASK_6BITS ] ; buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 6 ) & MASK_6BITS ] ; MST[rv.CRCR6Mutator]MSP[]
case 2 : buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 10 ) & MASK_6BITS ] ; MST[InlineConstantMutator]MSP[] buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 4 ) & MASK_6BITS ] ;
} public static String encodeBase64String ( final byte [] binaryData ) { return StringUtils . newStringUsAscii ( encodeBase64 ( binaryData , false ) ) ; } public static byte [] encodeBase64URLSafe ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false , true ) ; MST[NullReturnValsMutator]MSP[] }
if ( isStrictDecoding () && ( context . ibitWorkArea & emptyBitsMask ) != 0 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] throw new IllegalArgumentException ( lr_5 + lr_6 + lr_7 ) ; } } private void validateTrailingCharacter () { if ( isStrictDecoding () ) { throw new IllegalArgumentException ( lr_5 + lr_6 +
} public static String encodeBase64String ( final byte [] binaryData ) { return StringUtils . newStringUsAscii ( encodeBase64 ( binaryData , false ) ) ; } public static byte [] encodeBase64URLSafe ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false , true ) ; MST[rv.CRCR4Mutator]MSP[] }
return octet >= 0 && octet < decodeTable . length && decodeTable [ octet ] != - 1 ; MST[rv.ABSMutator]MSP[] } public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } private void validateCharacter ( final int emptyBitsMask , final Context context ) {
context . ibitWorkArea = context . ibitWorkArea >> 4 ; buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea ) & MASK_8BITS ) ; MST[rv.CRCR2Mutator]MSP[] break; case 3 : validateCharacter ( MASK_2BITS , context ) ; context . ibitWorkArea = context . ibitWorkArea >> 2 ;
if ( binaryData == null || binaryData . length == 0 ) { return binaryData ; } final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; MST[NegateConditionalsMutator]MSP[] final long len = b64 . getEncodedLength ( binaryData ) ;
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.CRCR1Mutator]MSP[] return bigBytes ; } int startSrc = 0 ;
if ( binaryData == null || binaryData . length == 0 ) { return binaryData ; } final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; MST[rv.UOI4Mutator]MSP[] final long len = b64 . getEncodedLength ( binaryData ) ;
for ( int i = 0 ; i < arrayOctet . length ; i ++ ) { if ( ! isBase64 ( arrayOctet [ i ] ) && ! isWhiteSpace ( arrayOctet [ i ] ) ) { MST[rv.UOI3Mutator]MSP[] return false ; } } return true ; }
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 12 ) & MASK_6BITS ] ; buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 6 ) & MASK_6BITS ] ; MST[rv.AOR4Mutator]MSP[]
for ( int i = 0 ; i < arrayOctet . length ; i ++ ) { if ( ! isBase64 ( arrayOctet [ i ] ) && ! isWhiteSpace ( arrayOctet [ i ] ) ) { return false ; MST[rv.CRCR1Mutator]MSP[] } } return true ; }
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; MST[rv.UOI3Mutator]MSP[] return resizedBytes ; } @Override
context . ibitWorkArea = ( context . ibitWorkArea << 8 ) + b ; MST[rv.CRCR5Mutator]MSP[] if ( 0 == context . modulus ) { buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 18 ) & MASK_6BITS ] ;
context . ibitWorkArea = ( context . ibitWorkArea << 8 ) + b ; if ( 0 == context . modulus ) { buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 18 ) & MASK_6BITS ] ; MST[experimental.MemberVariableMutator]MSP[]
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.ROR5Mutator]MSP[] return bigBytes ; } int startSrc = 0 ;
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[rv.ROR2Mutator]MSP[] } public static boolean isBase64 ( final byte [] arrayOctet ) {
for ( int i = 0 ; i < inAvail ; i ++ ) { MST[NegateConditionalsMutator]MSP[] final byte [] buffer = ensureBufferSize ( decodeSize , context ) ; final byte b = in [ inPos ++ ] ; if ( b == pad ) { context . eof = true ;
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[rv.UOI1Mutator]MSP[] } public static boolean isBase64 ( final byte [] arrayOctet ) {
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[rv.ROR5Mutator]MSP[] } public static boolean isBase64 ( final byte [] arrayOctet ) {
if ( len > maxResultSize ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[] throw new IllegalArgumentException ( lr_1 + len + lr_2 + maxResultSize ) ; } return b64 . encode ( binaryData ) ; } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { return encodeBase64 ( binaryData , true ) ;
if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_1 + MST[rv.UOI3Mutator]MSP[] len + lr_2 + maxResultSize ) ; } return b64 . encode ( binaryData ) ; } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { return encodeBase64 ( binaryData , true ) ;
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { return bigBytes ; MST[NullReturnValsMutator]MSP[] } int startSrc = 0 ;
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[NegateConditionalsMutator]MSP[] return bigBytes ; } int startSrc = 0 ;
if ( inAvail < 0 ) { context . eof = true ; if ( 0 == context . modulus && lineLength == 0 ) { MST[rv.UOI1Mutator]MSP[] return; } final byte [] buffer = ensureBufferSize ( encodeSize , context ) ; final int savedPos = context . pos ;
context . ibitWorkArea = ( context . ibitWorkArea << 8 ) + b ; if ( 0 == context . modulus ) { buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 18 ) & MASK_6BITS ] ; MST[rv.AOR2Mutator]MSP[]
if ( inAvail < 0 ) { context . eof = true ; if ( 0 == context . modulus && lineLength == 0 ) { MST[rv.UOI4Mutator]MSP[] return; } final byte [] buffer = ensureBufferSize ( encodeSize , context ) ; final int savedPos = context . pos ;
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.CRCR6Mutator]MSP[] return bigBytes ; } int startSrc = 0 ;
switch ( context . modulus ) { MST[experimental.SwitchMutator]MSP[] case 0 : break; case 1 : buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 2 ) & MASK_6BITS ] ;
if ( binaryData == null || binaryData . length == 0 ) { return binaryData ; } final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; MST[rv.UOI1Mutator]MSP[] final long len = b64 . getEncodedLength ( binaryData ) ;
break; } if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; MST[rv.UOI3Mutator]MSP[] if ( result >= 0 ) { context . modulus = ( context . modulus + 1 ) % BYTES_PER_ENCODED_BLOCK ;
buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea >> 8 ) & MASK_8BITS ) ; buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea ) & MASK_8BITS ) ; MST[InlineConstantMutator]MSP[] break; default:
break; } if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { MST[rv.ROR4Mutator]MSP[] context . modulus = ( context . modulus + 1 ) % BYTES_PER_ENCODED_BLOCK ;
buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea >> 8 ) & MASK_8BITS ) ; MST[rv.AOD1Mutator]MSP[] buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea ) & MASK_8BITS ) ; break; default:
buffer [ context . pos ++ ] = encodeTable [ context . ibitWorkArea & MASK_6BITS ] ; context . currentLinePos += BYTES_PER_ENCODED_BLOCK ; MST[rv.CRCR5Mutator]MSP[] if ( lineLength > 0 && lineLength <= context . currentLinePos ) {
buffer [ context . pos ++ ] = encodeTable [ context . ibitWorkArea & MASK_6BITS ] ; context . currentLinePos += BYTES_PER_ENCODED_BLOCK ; if ( lineLength > 0 && lineLength <= context . currentLinePos ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[]
case 2 : buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 10 ) & MASK_6BITS ] ; buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 4 ) & MASK_6BITS ] ; MST[rv.CRCR6Mutator]MSP[]
buffer [ context . pos ++ ] = encodeTable [ context . ibitWorkArea & MASK_6BITS ] ; MST[rv.CRCR2Mutator]MSP[] context . currentLinePos += BYTES_PER_ENCODED_BLOCK ; if ( lineLength > 0 && lineLength <= context . currentLinePos ) {
buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea >> 8 ) & MASK_8BITS ) ; buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea ) & MASK_8BITS ) ; MST[MathMutator]MSP[] break; default:
buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea >> 8 ) & MASK_8BITS ) ; MST[rv.CRCR6Mutator]MSP[] buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea ) & MASK_8BITS ) ; break; default:
public static BigInteger decodeInteger ( final byte [] pArray ) { return new BigInteger ( 1 , decodeBase64 ( pArray ) ) ; MST[ReturnValsMutator]MSP[] } public static byte [] encodeBase64 ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false ) ; }
final byte [] buffer = ensureBufferSize ( encodeSize , context ) ; context . modulus = ( context . modulus + 1 ) % BYTES_PER_UNENCODED_BLOCK ; MST[rv.AOD2Mutator]MSP[] int b = in [ inPos ++ ] ; if ( b < 0 ) { b += 256 ; }
for ( int i = 0 ; i < inAvail ; i ++ ) { final byte [] buffer = ensureBufferSize ( decodeSize , context ) ; final byte b = in [ inPos ++ ] ; if ( b == pad ) { MST[rv.UOI4Mutator]MSP[] context . eof = true ;
for ( int i = 0 ; i < inAvail ; i ++ ) { final byte [] buffer = ensureBufferSize ( decodeSize , context ) ; final byte b = in [ inPos ++ ] ; if ( b == pad ) { MST[rv.UOI1Mutator]MSP[] context . eof = true ;
public static String encodeBase64URLSafeString ( final byte [] binaryData ) { return StringUtils . newStringUsAscii ( encodeBase64 ( binaryData , false , true ) ) ; MST[rv.CRCR1Mutator]MSP[] } public static byte [] encodeInteger ( final BigInteger bigInteger ) { Objects . requireNonNull ( bigInteger , lr_3 ) ;
public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked ) { return encodeBase64 ( binaryData , isChunked , false ) ; MST[rv.CRCR3Mutator]MSP[] } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe ) {
public static BigInteger decodeInteger ( final byte [] pArray ) { return new BigInteger ( 1 , decodeBase64 ( pArray ) ) ; MST[ArgumentPropagationMutator]MSP[] } public static byte [] encodeBase64 ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false ) ; }
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.CRCR5Mutator]MSP[] return bigBytes ; } int startSrc = 0 ;
if ( inAvail < 0 ) { context . eof = true ; if ( 0 == context . modulus && lineLength == 0 ) { MST[rv.UOI2Mutator]MSP[] return; } final byte [] buffer = ensureBufferSize ( encodeSize , context ) ; final int savedPos = context . pos ;
System . arraycopy ( lineSeparator , 0 , buffer , context . pos , lineSeparator . length ) ; MST[rv.CRCR5Mutator]MSP[] context . pos += lineSeparator . length ; context . currentLinePos = 0 ; } } } } } @Override protected boolean isInAlphabet ( final byte octet ) {
System . arraycopy ( lineSeparator , 0 , buffer , context . pos , lineSeparator . length ) ; context . pos += lineSeparator . length ; } } else { for ( int i = 0 ; i < inAvail ; i ++ ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[]
} public static String encodeBase64String ( final byte [] binaryData ) { return StringUtils . newStringUsAscii ( encodeBase64 ( binaryData , false ) ) ; MST[InlineConstantMutator]MSP[] } public static byte [] encodeBase64URLSafe ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false , true ) ; }
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[RemoveConditionalMutator_ORDER_IF]MSP[] } public static boolean isBase64 ( final byte [] arrayOctet ) {
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea << 4 ) & MASK_6BITS ] ; MST[rv.ABSMutator]MSP[] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ context . pos ++ ] = pad ; buffer [ context . pos ++ ] = pad ; } break;
if ( inAvail < 0 ) { context . eof = true ; if ( 0 == context . modulus && lineLength == 0 ) { return; } final byte [] buffer = ensureBufferSize ( encodeSize , context ) ; final int savedPos = context . pos ; MST[rv.UOI2Mutator]MSP[]
int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { MST[rv.ROR4Mutator]MSP[] startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea << 4 ) & MASK_6BITS ] ; MST[rv.CRCR5Mutator]MSP[] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ context . pos ++ ] = pad ; buffer [ context . pos ++ ] = pad ; } break;
context . ibitWorkArea = ( context . ibitWorkArea << 8 ) + b ; if ( 0 == context . modulus ) { buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 18 ) & MASK_6BITS ] ; MST[rv.CRCR4Mutator]MSP[]
for ( int i = 0 ; i < arrayOctet . length ; i ++ ) { MST[rv.CRCR5Mutator]MSP[] if ( ! isBase64 ( arrayOctet [ i ] ) && ! isWhiteSpace ( arrayOctet [ i ] ) ) { return false ; } } return true ; }
public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked ) { return encodeBase64 ( binaryData , isChunked , false ) ; MST[rv.CRCR6Mutator]MSP[] } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe ) {
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.UOI2Mutator]MSP[] return bigBytes ; } int startSrc = 0 ;
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[rv.ABSMutator]MSP[] } public static boolean isBase64 ( final byte [] arrayOctet ) {
if ( len > maxResultSize ) { MST[rv.UOI3Mutator]MSP[] throw new IllegalArgumentException ( lr_1 + len + lr_2 + maxResultSize ) ; } return b64 . encode ( binaryData ) ; } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { return encodeBase64 ( binaryData , true ) ;
final byte [] buffer = ensureBufferSize ( encodeSize , context ) ; context . modulus = ( context . modulus + 1 ) % BYTES_PER_UNENCODED_BLOCK ; MST[MathMutator]MSP[] int b = in [ inPos ++ ] ; if ( b < 0 ) { b += 256 ; }
throw new IllegalStateException ( lr_4 + context . modulus ) ; MST[ConstructorCallMutator]MSP[] } } } @Override void encode ( final byte [] in , int inPos , final int inAvail , final Context context ) { if ( context . eof ) { return; }
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea << 2 ) & MASK_6BITS ] ; MST[rv.CRCR5Mutator]MSP[] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ context . pos ++ ] = pad ; } break; default:
for ( int i = 0 ; i < arrayOctet . length ; i ++ ) { if ( ! isBase64 ( arrayOctet [ i ] ) && ! isWhiteSpace ( arrayOctet [ i ] ) ) { return false ; } } return true ; MST[rv.CRCR3Mutator]MSP[] }
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] } public static boolean isBase64 ( final byte [] arrayOctet ) {
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[BooleanTrueReturnValsMutator]MSP[] } public static boolean isBase64 ( final byte [] arrayOctet ) {
buffer [ context . pos ++ ] = encodeTable [ context . ibitWorkArea & MASK_6BITS ] ; context . currentLinePos += BYTES_PER_ENCODED_BLOCK ; if ( lineLength > 0 && lineLength <= context . currentLinePos ) { MST[rv.UOI1Mutator]MSP[]
switch ( context . modulus ) { case 0 : break; case 1 : buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 2 ) & MASK_6BITS ] ; MST[rv.CRCR3Mutator]MSP[]
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[InlineConstantMutator]MSP[] return bigBytes ; } int startSrc = 0 ;
throw new IllegalStateException ( lr_4 + context . modulus ) ; } context . currentLinePos += context . pos - savedPos ; if ( lineLength > 0 && context . currentLinePos > 0 ) { MST[rv.UOI1Mutator]MSP[]
break; } if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { context . modulus = ( context . modulus + 1 ) % BYTES_PER_ENCODED_BLOCK ; MST[rv.AOR1Mutator]MSP[]
} public static String encodeBase64String ( final byte [] binaryData ) { return StringUtils . newStringUsAscii ( encodeBase64 ( binaryData , false ) ) ; } public static byte [] encodeBase64URLSafe ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false , true ) ; MST[rv.CRCR5Mutator]MSP[] }
for ( int i = 0 ; i < inAvail ; i ++ ) { final byte [] buffer = ensureBufferSize ( decodeSize , context ) ; final byte b = in [ inPos ++ ] ; if ( b == pad ) { context . eof = true ; MST[rv.CRCR3Mutator]MSP[]
} public static String encodeBase64String ( final byte [] binaryData ) { return StringUtils . newStringUsAscii ( encodeBase64 ( binaryData , false ) ) ; } public static byte [] encodeBase64URLSafe ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false , true ) ; MST[ArgumentPropagationMutator]MSP[] }
return encodeBase64 ( binaryData , isChunked , urlSafe , Integer . MAX_VALUE ) ; MST[rv.ABSMutator]MSP[] } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe , final int maxResultSize ) {
case 2 : buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 10 ) & MASK_6BITS ] ; MST[MathMutator]MSP[] buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 4 ) & MASK_6BITS ] ;
public static byte [] decodeBase64 ( final byte [] base64Data ) { return new Base64 () . decode ( base64Data ) ; } public static byte [] decodeBase64 ( final String base64String ) { return new Base64 () . decode ( base64String ) ; MST[NullReturnValsMutator]MSP[] }
if ( binaryData == null || binaryData . length == 0 ) { return binaryData ; } final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; MST[rv.UOI4Mutator]MSP[] final long len = b64 . getEncodedLength ( binaryData ) ;
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; MST[rv.AOR1Mutator]MSP[] System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; } @Override
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.CRCR3Mutator]MSP[] return bigBytes ; } int startSrc = 0 ;
for ( int i = 0 ; i < arrayOctet . length ; i ++ ) { if ( ! isBase64 ( arrayOctet [ i ] ) && ! isWhiteSpace ( arrayOctet [ i ] ) ) { MST[rv.UOI3Mutator]MSP[] return false ; } } return true ; }
for ( int i = 0 ; i < arrayOctet . length ; i ++ ) { if ( ! isBase64 ( arrayOctet [ i ] ) && ! isWhiteSpace ( arrayOctet [ i ] ) ) { MST[rv.ROR3Mutator]MSP[] return false ; } } return true ; }
public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked ) { return encodeBase64 ( binaryData , isChunked , false ) ; MST[rv.UOI1Mutator]MSP[] } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe ) {
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; MST[rv.UOI2Mutator]MSP[] System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; } @Override
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 12 ) & MASK_6BITS ] ; buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 6 ) & MASK_6BITS ] ; MST[rv.CRCR3Mutator]MSP[]
return octet >= 0 && octet < decodeTable . length && decodeTable [ octet ] != - 1 ; MST[rv.CRCR2Mutator]MSP[] } public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } private void validateCharacter ( final int emptyBitsMask , final Context context ) {
int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { MST[rv.ROR2Mutator]MSP[] startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; MST[rv.UOI4Mutator]MSP[] return resizedBytes ; } @Override
bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ; MST[MathMutator]MSP[] final byte [] bigBytes = bigInt . toByteArray () ;
System . arraycopy ( lineSeparator , 0 , buffer , context . pos , lineSeparator . length ) ; context . pos += lineSeparator . length ; } } else { for ( int i = 0 ; i < inAvail ; i ++ ) { MST[ConditionalsBoundaryMutator]MSP[]
bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ; MST[rv.CRCR1Mutator]MSP[] final byte [] bigBytes = bigInt . toByteArray () ;
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[rv.UOI3Mutator]MSP[] } public static boolean isBase64 ( final byte [] arrayOctet ) {
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[NonVoidMethodCallMutator]MSP[] return bigBytes ; } int startSrc = 0 ;
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[rv.ROR2Mutator]MSP[] } public static boolean isBase64 ( final byte [] arrayOctet ) {
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ context . pos ++ ] = pad ; buffer [ context . pos ++ ] = pad ; MST[rv.UOI1Mutator]MSP[] } break;
for ( int i = 0 ; i < arrayOctet . length ; i ++ ) { if ( ! isBase64 ( arrayOctet [ i ] ) && ! isWhiteSpace ( arrayOctet [ i ] ) ) { return false ; } } return true ; MST[InlineConstantMutator]MSP[] }
throw new IllegalStateException ( lr_4 + context . modulus ) ; MST[NonVoidMethodCallMutator]MSP[] } } } @Override void encode ( final byte [] in , int inPos , final int inAvail , final Context context ) { if ( context . eof ) { return; }
final byte [] buffer = ensureBufferSize ( encodeSize , context ) ; context . modulus = ( context . modulus + 1 ) % BYTES_PER_UNENCODED_BLOCK ; MST[rv.AOR4Mutator]MSP[] int b = in [ inPos ++ ] ; if ( b < 0 ) { b += 256 ; }
context . ibitWorkArea = ( context . ibitWorkArea << 8 ) + b ; if ( 0 == context . modulus ) { buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 18 ) & MASK_6BITS ] ; MST[MathMutator]MSP[]
if ( binaryData == null || binaryData . length == 0 ) { MST[rv.ROR3Mutator]MSP[] return binaryData ; } final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; final long len = b64 . getEncodedLength ( binaryData ) ;
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ context . pos ++ ] = pad ; MST[rv.UOI1Mutator]MSP[] } break; default:
buffer [ context . pos ++ ] = encodeTable [ context . ibitWorkArea & MASK_6BITS ] ; context . currentLinePos += BYTES_PER_ENCODED_BLOCK ; if ( lineLength > 0 && lineLength <= context . currentLinePos ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[]
for ( int i = 0 ; i < arrayOctet . length ; i ++ ) { MST[rv.ROR2Mutator]MSP[] if ( ! isBase64 ( arrayOctet [ i ] ) && ! isWhiteSpace ( arrayOctet [ i ] ) ) { return false ; } } return true ; }
for ( int i = 0 ; i < arrayOctet . length ; i ++ ) { if ( ! isBase64 ( arrayOctet [ i ] ) && ! isWhiteSpace ( arrayOctet [ i ] ) ) { return false ; MST[ReturnValsMutator]MSP[] } } return true ; }
buffer [ context . pos ++ ] = encodeTable [ context . ibitWorkArea & MASK_6BITS ] ; context . currentLinePos += BYTES_PER_ENCODED_BLOCK ; if ( lineLength > 0 && lineLength <= context . currentLinePos ) { MST[rv.UOI2Mutator]MSP[]
throw new IllegalStateException ( lr_4 + context . modulus ) ; } context . currentLinePos += context . pos - savedPos ; if ( lineLength > 0 && context . currentLinePos > 0 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[]
int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { MST[rv.CRCR6Mutator]MSP[] startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 12 ) & MASK_6BITS ] ; MST[rv.UOI1Mutator]MSP[] buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 6 ) & MASK_6BITS ] ;
throw new IllegalStateException ( lr_4 + context . modulus ) ; } context . currentLinePos += context . pos - savedPos ; if ( lineLength > 0 && context . currentLinePos > 0 ) { MST[rv.UOI2Mutator]MSP[]
final byte [] buffer = ensureBufferSize ( encodeSize , context ) ; context . modulus = ( context . modulus + 1 ) % BYTES_PER_UNENCODED_BLOCK ; int b = in [ inPos ++ ] ; if ( b < 0 ) { b += 256 ; MST[IncrementsMutator]MSP[] }
if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_1 + len + lr_2 + maxResultSize ) ; } return b64 . encode ( binaryData ) ; } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { return encodeBase64 ( binaryData , true ) ; MST[rv.CRCR2Mutator]MSP[]
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[rv.CRCR2Mutator]MSP[] } public static boolean isBase64 ( final byte [] arrayOctet ) {
case 2 : buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 10 ) & MASK_6BITS ] ; MST[rv.UOI4Mutator]MSP[] buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 4 ) & MASK_6BITS ] ;
System . arraycopy ( lineSeparator , 0 , buffer , context . pos , lineSeparator . length ) ; context . pos += lineSeparator . length ; MST[rv.ABSMutator]MSP[] context . currentLinePos = 0 ; } } } } } @Override protected boolean isInAlphabet ( final byte octet ) {
return encodeBase64 ( binaryData , isChunked , urlSafe , Integer . MAX_VALUE ) ; MST[rv.UOI4Mutator]MSP[] } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe , final int maxResultSize ) {
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.ROR3Mutator]MSP[] return bigBytes ; } int startSrc = 0 ;
buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea >> 8 ) & MASK_8BITS ) ; buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea ) & MASK_8BITS ) ; MST[rv.CRCR2Mutator]MSP[] break; default:
buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea >> 8 ) & MASK_8BITS ) ; MST[rv.UOI4Mutator]MSP[] buffer [ context . pos ++ ] = (byte) ( context . ibitWorkArea & MASK_8BITS ) ; } } } }
int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ; MST[rv.AOR4Mutator]MSP[]
break; } if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { context . modulus = ( context . modulus + 1 ) % BYTES_PER_ENCODED_BLOCK ; MST[rv.CRCR2Mutator]MSP[]
if ( binaryData == null || binaryData . length == 0 ) { return binaryData ; } final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; MST[InlineConstantMutator]MSP[] final long len = b64 . getEncodedLength ( binaryData ) ;
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[RemoveConditionalMutator_ORDER_IF]MSP[] } public static boolean isBase64 ( final byte [] arrayOctet ) {
int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { MST[rv.CRCR1Mutator]MSP[] startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
throw new IllegalStateException ( lr_4 + context . modulus ) ; MST[experimental.NakedReceiverMutator]MSP[] } context . currentLinePos += context . pos - savedPos ; if ( lineLength > 0 && context . currentLinePos > 0 ) {
bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ; MST[InlineConstantMutator]MSP[] final byte [] bigBytes = bigInt . toByteArray () ;
public static BigInteger decodeInteger ( final byte [] pArray ) { return new BigInteger ( 1 , decodeBase64 ( pArray ) ) ; MST[rv.CRCR6Mutator]MSP[] } public static byte [] encodeBase64 ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false ) ; }
bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ; MST[rv.CRCR3Mutator]MSP[] final byte [] bigBytes = bigInt . toByteArray () ;
buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea >> 8 ) & MASK_8BITS ) ; MST[MathMutator]MSP[] buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea ) & MASK_8BITS ) ; break; default:
} public static String encodeBase64String ( final byte [] binaryData ) { return StringUtils . newStringUsAscii ( encodeBase64 ( binaryData , false ) ) ; MST[rv.CRCR5Mutator]MSP[] } public static byte [] encodeBase64URLSafe ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false , true ) ; }
if ( context . eof && context . modulus != 0 ) { MST[rv.ROR5Mutator]MSP[] final byte [] buffer = ensureBufferSize ( decodeSize , context ) ; switch ( context . modulus ) { case 1 : validateTrailingCharacter () ; break; case 2 : validateCharacter ( MASK_4BITS , context ) ;
for ( int i = 0 ; i < arrayOctet . length ; i ++ ) { if ( ! isBase64 ( arrayOctet [ i ] ) && ! isWhiteSpace ( arrayOctet [ i ] ) ) { MST[rv.UOI2Mutator]MSP[] return false ; } } return true ; }
for ( int i = 0 ; i < inAvail ; i ++ ) { final byte [] buffer = ensureBufferSize ( decodeSize , context ) ; final byte b = in [ inPos ++ ] ; if ( b == pad ) { MST[rv.ROR4Mutator]MSP[] context . eof = true ;
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.AOD1Mutator]MSP[] return bigBytes ; } int startSrc = 0 ;
if ( isStrictDecoding () && ( context . ibitWorkArea & emptyBitsMask ) != 0 ) { MST[rv.ROR5Mutator]MSP[] throw new IllegalArgumentException ( lr_5 + lr_6 + lr_7 ) ; } } private void validateTrailingCharacter () { if ( isStrictDecoding () ) { throw new IllegalArgumentException ( lr_5 + lr_6 +
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; MST[rv.UOI1Mutator]MSP[] return resizedBytes ; } @Override
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.AOR4Mutator]MSP[] return bigBytes ; } int startSrc = 0 ;
for ( int i = 0 ; i < arrayOctet . length ; i ++ ) { MST[NegateConditionalsMutator]MSP[] if ( ! isBase64 ( arrayOctet [ i ] ) && ! isWhiteSpace ( arrayOctet [ i ] ) ) { return false ; } } return true ; }
buffer [ context . pos ++ ] = encodeTable [ context . ibitWorkArea & MASK_6BITS ] ; context . currentLinePos += BYTES_PER_ENCODED_BLOCK ; MST[InlineConstantMutator]MSP[] if ( lineLength > 0 && lineLength <= context . currentLinePos ) {
for ( int i = 0 ; i < arrayOctet . length ; i ++ ) { MST[rv.CRCR6Mutator]MSP[] if ( ! isBase64 ( arrayOctet [ i ] ) && ! isWhiteSpace ( arrayOctet [ i ] ) ) { return false ; } } return true ; }
if ( context . eof && context . modulus != 0 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] final byte [] buffer = ensureBufferSize ( decodeSize , context ) ; switch ( context . modulus ) { case 1 : validateTrailingCharacter () ; break; case 2 : validateCharacter ( MASK_4BITS , context ) ;
} public static String encodeBase64String ( final byte [] binaryData ) { return StringUtils . newStringUsAscii ( encodeBase64 ( binaryData , false ) ) ; } public static byte [] encodeBase64URLSafe ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false , true ) ; MST[rv.CRCR6Mutator]MSP[] }
for ( int i = 0 ; i < inAvail ; i ++ ) { final byte [] buffer = ensureBufferSize ( decodeSize , context ) ; final byte b = in [ inPos ++ ] ; if ( b == pad ) { MST[rv.UOI3Mutator]MSP[] context . eof = true ;
public static String encodeBase64URLSafeString ( final byte [] binaryData ) { return StringUtils . newStringUsAscii ( encodeBase64 ( binaryData , false , true ) ) ; MST[rv.CRCR3Mutator]MSP[] } public static byte [] encodeInteger ( final BigInteger bigInteger ) { Objects . requireNonNull ( bigInteger , lr_3 ) ;
return encodeBase64 ( binaryData , isChunked , urlSafe , Integer . MAX_VALUE ) ; MST[rv.UOI1Mutator]MSP[] } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe , final int maxResultSize ) {
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.ROR2Mutator]MSP[] return bigBytes ; } int startSrc = 0 ;
if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_1 + MST[ConstructorCallMutator]MSP[] len + lr_2 + maxResultSize ) ; } return b64 . encode ( binaryData ) ; } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { return encodeBase64 ( binaryData , true ) ;
buffer [ context . pos ++ ] = encodeTable [ context . ibitWorkArea & MASK_6BITS ] ; MST[rv.ABSMutator]MSP[] context . currentLinePos += BYTES_PER_ENCODED_BLOCK ; if ( lineLength > 0 && lineLength <= context . currentLinePos ) {
if ( binaryData == null || binaryData . length == 0 ) { return binaryData ; } final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; MST[rv.UOI3Mutator]MSP[] final long len = b64 . getEncodedLength ( binaryData ) ;
case 2 : buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 10 ) & MASK_6BITS ] ; buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 4 ) & MASK_6BITS ] ; MST[rv.AOD2Mutator]MSP[]
for ( int i = 0 ; i < arrayOctet . length ; i ++ ) { if ( ! isBase64 ( arrayOctet [ i ] ) && ! isWhiteSpace ( arrayOctet [ i ] ) ) { MST[rv.ABSMutator]MSP[] return false ; } } return true ; }
System . arraycopy ( lineSeparator , 0 , buffer , context . pos , lineSeparator . length ) ; MST[InlineConstantMutator]MSP[] context . pos += lineSeparator . length ; context . currentLinePos = 0 ; } } } } } @Override protected boolean isInAlphabet ( final byte octet ) {
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[InlineConstantMutator]MSP[] } public static boolean isBase64 ( final byte [] arrayOctet ) {
for ( int i = 0 ; i < arrayOctet . length ; i ++ ) { if ( ! isBase64 ( arrayOctet [ i ] ) && ! isWhiteSpace ( arrayOctet [ i ] ) ) { return false ; MST[BooleanTrueReturnValsMutator]MSP[] } } return true ; }
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[rv.ROR4Mutator]MSP[] } public static boolean isBase64 ( final byte [] arrayOctet ) {
if ( binaryData == null || binaryData . length == 0 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return binaryData ; } final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; final long len = b64 . getEncodedLength ( binaryData ) ;
int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ; MST[rv.AOD1Mutator]MSP[]
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 12 ) & MASK_6BITS ] ; buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 6 ) & MASK_6BITS ] ; MST[rv.OBBN1Mutator]MSP[]
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; MST[rv.ABSMutator]MSP[] return resizedBytes ; } @Override
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[rv.CRCR2Mutator]MSP[] } public static boolean isBase64 ( final byte [] arrayOctet ) {
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea << 2 ) & MASK_6BITS ] ; MST[rv.CRCR2Mutator]MSP[] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ context . pos ++ ] = pad ; } break; default:
if ( isStrictDecoding () && ( context . ibitWorkArea & emptyBitsMask ) != 0 ) { MST[rv.OBBN2Mutator]MSP[] throw new IllegalArgumentException ( lr_5 + lr_6 + lr_7 ) ; } } private void validateTrailingCharacter () { if ( isStrictDecoding () ) { throw new IllegalArgumentException ( lr_5 + lr_6 +
for ( int i = 0 ; i < arrayOctet . length ; i ++ ) { MST[rv.ROR5Mutator]MSP[] if ( ! isBase64 ( arrayOctet [ i ] ) && ! isWhiteSpace ( arrayOctet [ i ] ) ) { return false ; } } return true ; }
System . arraycopy ( lineSeparator , 0 , buffer , context . pos , lineSeparator . length ) ; context . pos += lineSeparator . length ; } } else { for ( int i = 0 ; i < inAvail ; i ++ ) { MST[rv.ROR2Mutator]MSP[]
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.CRCR4Mutator]MSP[] return bigBytes ; } int startSrc = 0 ;
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[MathMutator]MSP[] return bigBytes ; } int startSrc = 0 ;
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 12 ) & MASK_6BITS ] ; MST[InlineConstantMutator]MSP[] buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 6 ) & MASK_6BITS ] ;
return octet >= 0 && octet < decodeTable . length && decodeTable [ octet ] != - 1 ; } public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; MST[rv.CRCR2Mutator]MSP[] } private void validateCharacter ( final int emptyBitsMask , final Context context ) {
} public static String encodeBase64String ( final byte [] binaryData ) { return StringUtils . newStringUsAscii ( encodeBase64 ( binaryData , false ) ) ; } public static byte [] encodeBase64URLSafe ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false , true ) ; MST[InlineConstantMutator]MSP[] }
return encodeBase64 ( binaryData , isChunked , urlSafe , Integer . MAX_VALUE ) ; MST[rv.CRCR5Mutator]MSP[] } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe , final int maxResultSize ) {
bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ; MST[rv.CRCR6Mutator]MSP[] final byte [] bigBytes = bigInt . toByteArray () ;
context . ibitWorkArea = ( context . ibitWorkArea << 8 ) + b ; if ( 0 == context . modulus ) { buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 18 ) & MASK_6BITS ] ; MST[rv.CRCR1Mutator]MSP[]
buffer [ context . pos ++ ] = encodeTable [ context . ibitWorkArea & MASK_6BITS ] ; MST[rv.CRCR4Mutator]MSP[] context . currentLinePos += BYTES_PER_ENCODED_BLOCK ; if ( lineLength > 0 && lineLength <= context . currentLinePos ) {
if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_1 + len + lr_2 + maxResultSize ) ; } return b64 . encode ( binaryData ) ; } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { return encodeBase64 ( binaryData , true ) ; MST[NullReturnValsMutator]MSP[]
if ( binaryData == null || binaryData . length == 0 ) { MST[NegateConditionalsMutator]MSP[] return binaryData ; } final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; final long len = b64 . getEncodedLength ( binaryData ) ;
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; MST[rv.AOR3Mutator]MSP[] System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; } @Override
System . arraycopy ( lineSeparator , 0 , buffer , context . pos , lineSeparator . length ) ; context . pos += lineSeparator . length ; } } else { for ( int i = 0 ; i < inAvail ; i ++ ) { MST[rv.UOI2Mutator]MSP[]
buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea >> 8 ) & MASK_8BITS ) ; MST[rv.CRCR3Mutator]MSP[] buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea ) & MASK_8BITS ) ; break; default:
if ( isStrictDecoding () && ( context . ibitWorkArea & emptyBitsMask ) != 0 ) { throw new IllegalArgumentException ( lr_5 + lr_6 + lr_7 ) ; } } private void validateTrailingCharacter () { if ( isStrictDecoding () ) { MST[rv.ROR1Mutator]MSP[] throw new IllegalArgumentException ( lr_5 + lr_6 +
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[InlineConstantMutator]MSP[] return bigBytes ; } int startSrc = 0 ;
public static boolean isBase64 ( final String base64 ) { return isBase64 ( StringUtils . getBytesUtf8 ( base64 ) ) ; MST[NonVoidMethodCallMutator]MSP[] } static byte [] toIntegerBytes ( final BigInteger bigInt ) { int bitlen = bigInt . bitLength () ;
bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ; MST[rv.CRCR3Mutator]MSP[] final byte [] bigBytes = bigInt . toByteArray () ;
if ( isStrictDecoding () && ( context . ibitWorkArea & emptyBitsMask ) != 0 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] throw new IllegalArgumentException ( lr_5 + lr_6 + lr_7 ) ; } } private void validateTrailingCharacter () { if ( isStrictDecoding () ) { throw new IllegalArgumentException ( lr_5 + lr_6 +
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.CRCR5Mutator]MSP[] return bigBytes ; } int startSrc = 0 ;
public static String encodeBase64URLSafeString ( final byte [] binaryData ) { return StringUtils . newStringUsAscii ( encodeBase64 ( binaryData , false , true ) ) ; MST[rv.CRCR2Mutator]MSP[] } public static byte [] encodeInteger ( final BigInteger bigInteger ) { Objects . requireNonNull ( bigInteger , lr_3 ) ;
if ( len > maxResultSize ) { MST[rv.ROR1Mutator]MSP[] throw new IllegalArgumentException ( lr_1 + len + lr_2 + maxResultSize ) ; } return b64 . encode ( binaryData ) ; } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { return encodeBase64 ( binaryData , true ) ;
return encodeBase64 ( binaryData , isChunked , urlSafe , Integer . MAX_VALUE ) ; MST[InlineConstantMutator]MSP[] } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe , final int maxResultSize ) {
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { return bigBytes ; } int startSrc = 0 ; MST[rv.CRCR6Mutator]MSP[]
return octet >= 0 && octet < decodeTable . length && decodeTable [ octet ] != - 1 ; } public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; MST[rv.ROR5Mutator]MSP[] } private void validateCharacter ( final int emptyBitsMask , final Context context ) {
throw new IllegalStateException ( lr_4 + context . modulus ) ; MST[rv.UOI4Mutator]MSP[] } context . currentLinePos += context . pos - savedPos ; if ( lineLength > 0 && context . currentLinePos > 0 ) {
public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked ) { return encodeBase64 ( binaryData , isChunked , false ) ; MST[rv.UOI3Mutator]MSP[] } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe ) {
throw new IllegalStateException ( lr_4 + context . modulus ) ; MST[rv.ABSMutator]MSP[] } context . currentLinePos += context . pos - savedPos ; if ( lineLength > 0 && context . currentLinePos > 0 ) {
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 12 ) & MASK_6BITS ] ; MST[rv.CRCR4Mutator]MSP[] buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 6 ) & MASK_6BITS ] ;
return octet >= 0 && octet < decodeTable . length && decodeTable [ octet ] != - 1 ; MST[rv.CRCR1Mutator]MSP[] } public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } private void validateCharacter ( final int emptyBitsMask , final Context context ) {
switch ( context . modulus ) { case 0 : break; case 1 : buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 2 ) & MASK_6BITS ] ; MST[rv.AOD2Mutator]MSP[]
if ( binaryData == null || binaryData . length == 0 ) { return binaryData ; } final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; MST[rv.ROR4Mutator]MSP[] final long len = b64 . getEncodedLength ( binaryData ) ;
return encodeBase64 ( toIntegerBytes ( bigInteger ) , false ) ; } @Deprecated public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { return isBase64 ( arrayOctet ) ; MST[ReturnValsMutator]MSP[] } public static boolean isBase64 ( final byte octet ) {
final byte [] buffer = ensureBufferSize ( encodeSize , context ) ; context . modulus = ( context . modulus + 1 ) % BYTES_PER_UNENCODED_BLOCK ; MST[rv.AOR1Mutator]MSP[] int b = in [ inPos ++ ] ; if ( b < 0 ) { b += 256 ; }
public static BigInteger decodeInteger ( final byte [] pArray ) { return new BigInteger ( 1 , decodeBase64 ( pArray ) ) ; MST[rv.CRCR3Mutator]MSP[] } public static byte [] encodeBase64 ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false ) ; }
context . ibitWorkArea = ( context . ibitWorkArea << 8 ) + b ; if ( 0 == context . modulus ) { buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 18 ) & MASK_6BITS ] ; MST[rv.CRCR3Mutator]MSP[]
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[rv.UOI2Mutator]MSP[] } public static boolean isBase64 ( final byte [] arrayOctet ) {
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea << 4 ) & MASK_6BITS ] ; MST[rv.CRCR4Mutator]MSP[] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ context . pos ++ ] = pad ; buffer [ context . pos ++ ] = pad ; } break;
int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ; MST[rv.CRCR2Mutator]MSP[]
throw new IllegalStateException ( lr_4 + context . modulus ) ; } } } @Override void encode ( final byte [] in , int inPos , final int inAvail , final Context context ) { if ( context . eof ) { MST[rv.ROR4Mutator]MSP[] return; }
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[rv.ROR1Mutator]MSP[] } public static boolean isBase64 ( final byte [] arrayOctet ) {
context . ibitWorkArea = ( context . ibitWorkArea << 8 ) + b ; MST[rv.UOI4Mutator]MSP[] if ( 0 == context . modulus ) { buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 18 ) & MASK_6BITS ] ;
case 2 : buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 10 ) & MASK_6BITS ] ; MST[rv.CRCR5Mutator]MSP[] buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 4 ) & MASK_6BITS ] ;
final byte [] buffer = ensureBufferSize ( encodeSize , context ) ; context . modulus = ( context . modulus + 1 ) % BYTES_PER_UNENCODED_BLOCK ; int b = in [ inPos ++ ] ; if ( b < 0 ) { MST[rv.ROR3Mutator]MSP[] b += 256 ; }
for ( int i = 0 ; i < inAvail ; i ++ ) { final byte [] buffer = ensureBufferSize ( decodeSize , context ) ; final byte b = in [ inPos ++ ] ; if ( b == pad ) { MST[rv.UOI1Mutator]MSP[] context . eof = true ;
context . ibitWorkArea = ( context . ibitWorkArea << 8 ) + b ; MST[rv.ABSMutator]MSP[] if ( 0 == context . modulus ) { buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 18 ) & MASK_6BITS ] ;
context . ibitWorkArea = ( context . ibitWorkArea << BITS_PER_ENCODED_BYTE ) + result ; if ( context . modulus == 0 ) { buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea >> 16 ) & MASK_8BITS ) ; MST[rv.UOI2Mutator]MSP[]
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[NonVoidMethodCallMutator]MSP[] return bigBytes ; } int startSrc = 0 ;
context . ibitWorkArea = ( context . ibitWorkArea << BITS_PER_ENCODED_BYTE ) + result ; MST[rv.CRCR3Mutator]MSP[] if ( context . modulus == 0 ) { buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea >> 16 ) & MASK_8BITS ) ;
if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_1 + MST[rv.ABSMutator]MSP[] len + lr_2 + maxResultSize ) ; } return b64 . encode ( binaryData ) ; } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { return encodeBase64 ( binaryData , true ) ;
buffer [ context . pos ++ ] = encodeTable [ context . ibitWorkArea & MASK_6BITS ] ; MST[MathMutator]MSP[] context . currentLinePos += BYTES_PER_ENCODED_BLOCK ; if ( lineLength > 0 && lineLength <= context . currentLinePos ) {
if ( inAvail < 0 ) { MST[rv.UOI3Mutator]MSP[] context . eof = true ; if ( 0 == context . modulus && lineLength == 0 ) { return; } final byte [] buffer = ensureBufferSize ( encodeSize , context ) ; final int savedPos = context . pos ;
switch ( context . modulus ) { case 0 : break; case 1 : buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 2 ) & MASK_6BITS ] ; MST[rv.UOI2Mutator]MSP[]
context . ibitWorkArea = ( context . ibitWorkArea << 8 ) + b ; if ( 0 == context . modulus ) { MST[rv.ROR4Mutator]MSP[] buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 18 ) & MASK_6BITS ] ;
switch ( context . modulus ) { case 0 : break; case 1 : buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 2 ) & MASK_6BITS ] ; MST[rv.CRCR5Mutator]MSP[]
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return bigBytes ; } int startSrc = 0 ;
if ( context . eof && context . modulus != 0 ) { final byte [] buffer = ensureBufferSize ( decodeSize , context ) ; switch ( context . modulus ) { MST[rv.ABSMutator]MSP[] case 1 : validateTrailingCharacter () ; break; case 2 : validateCharacter ( MASK_4BITS , context ) ;
case 2 : buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 10 ) & MASK_6BITS ] ; buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 4 ) & MASK_6BITS ] ; MST[rv.UOI2Mutator]MSP[]
context . ibitWorkArea = ( context . ibitWorkArea << 8 ) + b ; if ( 0 == context . modulus ) { buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 18 ) & MASK_6BITS ] ; MST[rv.UOI4Mutator]MSP[]
int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ; MST[rv.UOI2Mutator]MSP[]
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea << 4 ) & MASK_6BITS ] ; MST[rv.UOI3Mutator]MSP[] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ context . pos ++ ] = pad ; buffer [ context . pos ++ ] = pad ; } break;
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[rv.CRCR4Mutator]MSP[] } public static boolean isBase64 ( final byte [] arrayOctet ) {
for ( int i = 0 ; i < inAvail ; i ++ ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[] final byte [] buffer = ensureBufferSize ( decodeSize , context ) ; final byte b = in [ inPos ++ ] ; if ( b == pad ) { context . eof = true ;
switch ( context . modulus ) { case 0 : break; case 1 : buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 2 ) & MASK_6BITS ] ; MST[rv.CRCR3Mutator]MSP[]
if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_1 + len + lr_2 + maxResultSize ) ; } return b64 . encode ( binaryData ) ; } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { return encodeBase64 ( binaryData , true ) ; MST[ReturnValsMutator]MSP[]
int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { MST[rv.CRCR3Mutator]MSP[] startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
for ( int i = 0 ; i < arrayOctet . length ; i ++ ) { MST[rv.UOI2Mutator]MSP[] if ( ! isBase64 ( arrayOctet [ i ] ) && ! isWhiteSpace ( arrayOctet [ i ] ) ) { return false ; } } return true ; }
if ( context . eof && context . modulus != 0 ) { final byte [] buffer = ensureBufferSize ( decodeSize , context ) ; switch ( context . modulus ) { case 1 : validateTrailingCharacter () ; break; case 2 : validateCharacter ( MASK_4BITS , context ) ; MST[rv.CRCR4Mutator]MSP[]
throw new IllegalStateException ( lr_4 + context . modulus ) ; } context . currentLinePos += context . pos - savedPos ; MST[rv.AOR2Mutator]MSP[] if ( lineLength > 0 && context . currentLinePos > 0 ) {
buffer [ context . pos ++ ] = encodeTable [ context . ibitWorkArea & MASK_6BITS ] ; context . currentLinePos += BYTES_PER_ENCODED_BLOCK ; MST[rv.CRCR4Mutator]MSP[] if ( lineLength > 0 && lineLength <= context . currentLinePos ) {
buffer [ context . pos ++ ] = encodeTable [ context . ibitWorkArea & MASK_6BITS ] ; MST[rv.CRCR1Mutator]MSP[] context . currentLinePos += BYTES_PER_ENCODED_BLOCK ; if ( lineLength > 0 && lineLength <= context . currentLinePos ) {
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea << 2 ) & MASK_6BITS ] ; MST[rv.UOI3Mutator]MSP[] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ context . pos ++ ] = pad ; } break; default:
context . ibitWorkArea = ( context . ibitWorkArea << BITS_PER_ENCODED_BYTE ) + result ; if ( context . modulus == 0 ) { buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea >> 16 ) & MASK_8BITS ) ; MST[rv.CRCR3Mutator]MSP[]
System . arraycopy ( lineSeparator , 0 , buffer , context . pos , lineSeparator . length ) ; MST[rv.UOI4Mutator]MSP[] context . pos += lineSeparator . length ; context . currentLinePos = 0 ; } } } } } @Override protected boolean isInAlphabet ( final byte octet ) {
System . arraycopy ( lineSeparator , 0 , buffer , context . pos , lineSeparator . length ) ; MST[rv.UOI2Mutator]MSP[] context . pos += lineSeparator . length ; } } else { for ( int i = 0 ; i < inAvail ; i ++ ) {
context . ibitWorkArea = ( context . ibitWorkArea << BITS_PER_ENCODED_BYTE ) + result ; MST[rv.AOR2Mutator]MSP[] if ( context . modulus == 0 ) { buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea >> 16 ) & MASK_8BITS ) ;
for ( int i = 0 ; i < inAvail ; i ++ ) { MST[rv.ROR4Mutator]MSP[] final byte [] buffer = ensureBufferSize ( decodeSize , context ) ; final byte b = in [ inPos ++ ] ; if ( b == pad ) { context . eof = true ;
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea << 4 ) & MASK_6BITS ] ; MST[rv.CRCR6Mutator]MSP[] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ context . pos ++ ] = pad ; buffer [ context . pos ++ ] = pad ; } break;
if ( len > maxResultSize ) { MST[rv.ABSMutator]MSP[] throw new IllegalArgumentException ( lr_1 + len + lr_2 + maxResultSize ) ; } return b64 . encode ( binaryData ) ; } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { return encodeBase64 ( binaryData , true ) ;
} public static String encodeBase64String ( final byte [] binaryData ) { return StringUtils . newStringUsAscii ( encodeBase64 ( binaryData , false ) ) ; } public static byte [] encodeBase64URLSafe ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false , true ) ; MST[rv.CRCR3Mutator]MSP[] }
buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea >> 8 ) & MASK_8BITS ) ; buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea ) & MASK_8BITS ) ; MST[rv.AOR3Mutator]MSP[] break; default:
break; } if ( b >= 0 && b < DECODE_TABLE . length ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[] final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { context . modulus = ( context . modulus + 1 ) % BYTES_PER_ENCODED_BLOCK ;
} public static String encodeBase64String ( final byte [] binaryData ) { return StringUtils . newStringUsAscii ( encodeBase64 ( binaryData , false ) ) ; MST[ReturnValsMutator]MSP[] } public static byte [] encodeBase64URLSafe ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false , true ) ; }
context . ibitWorkArea = context . ibitWorkArea >> 4 ; MST[rv.CRCR1Mutator]MSP[] buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea ) & MASK_8BITS ) ; break; case 3 : validateCharacter ( MASK_2BITS , context ) ; context . ibitWorkArea = context . ibitWorkArea >> 2 ;
System . arraycopy ( lineSeparator , 0 , buffer , context . pos , lineSeparator . length ) ; context . pos += lineSeparator . length ; MST[rv.AOR1Mutator]MSP[] } } else { for ( int i = 0 ; i < inAvail ; i ++ ) {
if ( inAvail < 0 ) { context . eof = true ; if ( 0 == context . modulus && lineLength == 0 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return; } final byte [] buffer = ensureBufferSize ( encodeSize , context ) ; final int savedPos = context . pos ;
if ( binaryData == null || binaryData . length == 0 ) { return binaryData ; } final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; MST[rv.CRCR5Mutator]MSP[] final long len = b64 . getEncodedLength ( binaryData ) ;
context . ibitWorkArea = ( context . ibitWorkArea << BITS_PER_ENCODED_BYTE ) + result ; if ( context . modulus == 0 ) { buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea >> 16 ) & MASK_8BITS ) ; MST[experimental.MemberVariableMutator]MSP[]
context . ibitWorkArea = ( context . ibitWorkArea << 8 ) + b ; if ( 0 == context . modulus ) { buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 18 ) & MASK_6BITS ] ; MST[rv.ABSMutator]MSP[]
context . ibitWorkArea = ( context . ibitWorkArea << BITS_PER_ENCODED_BYTE ) + result ; if ( context . modulus == 0 ) { buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea >> 16 ) & MASK_8BITS ) ; MST[MathMutator]MSP[]
for ( int i = 0 ; i < arrayOctet . length ; i ++ ) { if ( ! isBase64 ( arrayOctet [ i ] ) && ! isWhiteSpace ( arrayOctet [ i ] ) ) { MST[rv.UOI3Mutator]MSP[] return false ; } } return true ; }
if ( binaryData == null || binaryData . length == 0 ) { MST[rv.ROR5Mutator]MSP[] return binaryData ; } final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; final long len = b64 . getEncodedLength ( binaryData ) ;
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return bigBytes ; } int startSrc = 0 ;
int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ; MST[rv.UOI3Mutator]MSP[]
for ( int i = 0 ; i < inAvail ; i ++ ) { MST[rv.CRCR1Mutator]MSP[] final byte [] buffer = ensureBufferSize ( decodeSize , context ) ; final byte b = in [ inPos ++ ] ; if ( b == pad ) { context . eof = true ;
System . arraycopy ( lineSeparator , 0 , buffer , context . pos , lineSeparator . length ) ; context . pos += lineSeparator . length ; } } else { for ( int i = 0 ; i < inAvail ; i ++ ) { MST[rv.UOI1Mutator]MSP[]
int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { MST[rv.CRCR4Mutator]MSP[] startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
throw new IllegalStateException ( lr_4 + context . modulus ) ; MST[experimental.NakedReceiverMutator]MSP[] } } } @Override void encode ( final byte [] in , int inPos , final int inAvail , final Context context ) { if ( context . eof ) { return; }
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; MST[VoidMethodCallMutator]MSP[] return resizedBytes ; } @Override
break; } if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { context . modulus = ( context . modulus + 1 ) % BYTES_PER_ENCODED_BLOCK ; MST[rv.AOR3Mutator]MSP[]
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[rv.ABSMutator]MSP[] } public static boolean isBase64 ( final byte [] arrayOctet ) {
for ( int i = 0 ; i < arrayOctet . length ; i ++ ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] if ( ! isBase64 ( arrayOctet [ i ] ) && ! isWhiteSpace ( arrayOctet [ i ] ) ) { return false ; } } return true ; }
public static BigInteger decodeInteger ( final byte [] pArray ) { return new BigInteger ( 1 , decodeBase64 ( pArray ) ) ; } public static byte [] encodeBase64 ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false ) ; MST[rv.CRCR6Mutator]MSP[] }
context . ibitWorkArea = ( context . ibitWorkArea << 8 ) + b ; if ( 0 == context . modulus ) { buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 18 ) & MASK_6BITS ] ; MST[MathMutator]MSP[]
System . arraycopy ( lineSeparator , 0 , buffer , context . pos , lineSeparator . length ) ; MST[rv.ABSMutator]MSP[] context . pos += lineSeparator . length ; context . currentLinePos = 0 ; } } } } } @Override protected boolean isInAlphabet ( final byte octet ) {
if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_1 + len + lr_2 + maxResultSize ) ; } return b64 . encode ( binaryData ) ; } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { return encodeBase64 ( binaryData , true ) ; MST[rv.CRCR4Mutator]MSP[]
System . arraycopy ( lineSeparator , 0 , buffer , context . pos , lineSeparator . length ) ; context . pos += lineSeparator . length ; } } else { for ( int i = 0 ; i < inAvail ; i ++ ) { MST[rv.CRCR6Mutator]MSP[]
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[rv.ROR3Mutator]MSP[] } public static boolean isBase64 ( final byte [] arrayOctet ) {
switch ( context . modulus ) { MST[experimental.RemoveSwitchMutator_1]MSP[] case 0 : break; case 1 : buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 2 ) & MASK_6BITS ] ;
switch ( context . modulus ) { MST[experimental.RemoveSwitchMutator_2]MSP[] case 0 : break; case 1 : buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 2 ) & MASK_6BITS ] ;
final byte [] buffer = ensureBufferSize ( encodeSize , context ) ; context . modulus = ( context . modulus + 1 ) % BYTES_PER_UNENCODED_BLOCK ; MST[rv.CRCR2Mutator]MSP[] int b = in [ inPos ++ ] ; if ( b < 0 ) { b += 256 ; }
public static String encodeBase64URLSafeString ( final byte [] binaryData ) { return StringUtils . newStringUsAscii ( encodeBase64 ( binaryData , false , true ) ) ; MST[NonVoidMethodCallMutator]MSP[] } public static byte [] encodeInteger ( final BigInteger bigInteger ) { Objects . requireNonNull ( bigInteger , lr_3 ) ;
int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ; MST[MathMutator]MSP[]
} public static String encodeBase64String ( final byte [] binaryData ) { return StringUtils . newStringUsAscii ( encodeBase64 ( binaryData , false ) ) ; MST[ArgumentPropagationMutator]MSP[] } public static byte [] encodeBase64URLSafe ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false , true ) ; }
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.AOD2Mutator]MSP[] return bigBytes ; } int startSrc = 0 ;
return octet >= 0 && octet < decodeTable . length && decodeTable [ octet ] != - 1 ; } public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; MST[ReturnValsMutator]MSP[] } private void validateCharacter ( final int emptyBitsMask , final Context context ) {
if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_1 + len + lr_2 + maxResultSize ) ; } return b64 . encode ( binaryData ) ; MST[NonVoidMethodCallMutator]MSP[] } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { return encodeBase64 ( binaryData , true ) ;
return octet >= 0 && octet < decodeTable . length && decodeTable [ octet ] != - 1 ; } public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; MST[NegateConditionalsMutator]MSP[] } private void validateCharacter ( final int emptyBitsMask , final Context context ) {
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[rv.CRCR5Mutator]MSP[] } public static boolean isBase64 ( final byte [] arrayOctet ) {
break; } if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { context . modulus = ( context . modulus + 1 ) % BYTES_PER_ENCODED_BLOCK ; MST[rv.CRCR4Mutator]MSP[]
bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ; MST[rv.UOI3Mutator]MSP[] final byte [] bigBytes = bigInt . toByteArray () ;
buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea >> 8 ) & MASK_8BITS ) ; MST[rv.CRCR6Mutator]MSP[] buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea ) & MASK_8BITS ) ; break; default:
if ( isStrictDecoding () && ( context . ibitWorkArea & emptyBitsMask ) != 0 ) { MST[rv.ROR2Mutator]MSP[] throw new IllegalArgumentException ( lr_5 + lr_6 + lr_7 ) ; } } private void validateTrailingCharacter () { if ( isStrictDecoding () ) { throw new IllegalArgumentException ( lr_5 + lr_6 +
return octet >= 0 && octet < decodeTable . length && decodeTable [ octet ] != - 1 ; MST[rv.CRCR4Mutator]MSP[] } public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } private void validateCharacter ( final int emptyBitsMask , final Context context ) {
for ( int i = 0 ; i < arrayOctet . length ; i ++ ) { if ( ! isBase64 ( arrayOctet [ i ] ) && ! isWhiteSpace ( arrayOctet [ i ] ) ) { return false ; MST[InlineConstantMutator]MSP[] } } return true ; }
if ( context . eof && context . modulus != 0 ) { MST[rv.UOI4Mutator]MSP[] final byte [] buffer = ensureBufferSize ( decodeSize , context ) ; switch ( context . modulus ) { case 1 : validateTrailingCharacter () ; break; case 2 : validateCharacter ( MASK_4BITS , context ) ;
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 12 ) & MASK_6BITS ] ; buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 6 ) & MASK_6BITS ] ; MST[rv.CRCR5Mutator]MSP[]
final byte [] buffer = ensureBufferSize ( encodeSize , context ) ; context . modulus = ( context . modulus + 1 ) % BYTES_PER_UNENCODED_BLOCK ; int b = in [ inPos ++ ] ; MST[rv.UOI3Mutator]MSP[] if ( b < 0 ) { b += 256 ; }
return encodeBase64 ( toIntegerBytes ( bigInteger ) , false ) ; } @Deprecated public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { return isBase64 ( arrayOctet ) ; MST[BooleanFalseReturnValsMutator]MSP[] } public static boolean isBase64 ( final byte octet ) {
return octet >= 0 && octet < decodeTable . length && decodeTable [ octet ] != - 1 ; MST[rv.UOI2Mutator]MSP[] } public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } private void validateCharacter ( final int emptyBitsMask , final Context context ) {
bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ; final byte [] bigBytes = bigInt . toByteArray () ; MST[NonVoidMethodCallMutator]MSP[]
case 2 : buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 10 ) & MASK_6BITS ] ; buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 4 ) & MASK_6BITS ] ; MST[rv.CRCR3Mutator]MSP[]
if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_1 + len + lr_2 + maxResultSize ) ; } return b64 . encode ( binaryData ) ; MST[ArgumentPropagationMutator]MSP[] } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { return encodeBase64 ( binaryData , true ) ;
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea << 2 ) & MASK_6BITS ] ; MST[rv.CRCR4Mutator]MSP[] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ context . pos ++ ] = pad ; } break; default:
for ( int i = 0 ; i < arrayOctet . length ; i ++ ) { if ( ! isBase64 ( arrayOctet [ i ] ) && ! isWhiteSpace ( arrayOctet [ i ] ) ) { return false ; } } return true ; MST[rv.CRCR4Mutator]MSP[] }
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 12 ) & MASK_6BITS ] ; MST[rv.CRCR1Mutator]MSP[] buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 6 ) & MASK_6BITS ] ;
if ( len > maxResultSize ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] throw new IllegalArgumentException ( lr_1 + len + lr_2 + maxResultSize ) ; } return b64 . encode ( binaryData ) ; } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { return encodeBase64 ( binaryData , true ) ;
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 12 ) & MASK_6BITS ] ; MST[rv.UOI2Mutator]MSP[] buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 6 ) & MASK_6BITS ] ;
for ( int i = 0 ; i < inAvail ; i ++ ) { MST[InlineConstantMutator]MSP[] final byte [] buffer = ensureBufferSize ( decodeSize , context ) ; final byte b = in [ inPos ++ ] ; if ( b == pad ) { context . eof = true ;
throw new IllegalStateException ( lr_4 + context . modulus ) ; MST[rv.UOI1Mutator]MSP[] } context . currentLinePos += context . pos - savedPos ; if ( lineLength > 0 && context . currentLinePos > 0 ) {
break; } if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { context . modulus = ( context . modulus + 1 ) % BYTES_PER_ENCODED_BLOCK ; MST[rv.UOI1Mutator]MSP[]
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea << 2 ) & MASK_6BITS ] ; MST[rv.OBBN2Mutator]MSP[] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ context . pos ++ ] = pad ; } break; default:
buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea >> 8 ) & MASK_8BITS ) ; buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea ) & MASK_8BITS ) ; MST[rv.CRCR6Mutator]MSP[] break; default:
public static String encodeBase64URLSafeString ( final byte [] binaryData ) { return StringUtils . newStringUsAscii ( encodeBase64 ( binaryData , false , true ) ) ; MST[ArgumentPropagationMutator]MSP[] } public static byte [] encodeInteger ( final BigInteger bigInteger ) { Objects . requireNonNull ( bigInteger , lr_3 ) ;
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 12 ) & MASK_6BITS ] ; buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 6 ) & MASK_6BITS ] ; MST[rv.CRCR2Mutator]MSP[]
throw new IllegalStateException ( lr_4 + context . modulus ) ; } context . currentLinePos += context . pos - savedPos ; MST[rv.UOI4Mutator]MSP[] if ( lineLength > 0 && context . currentLinePos > 0 ) {
context . ibitWorkArea = context . ibitWorkArea >> 4 ; MST[InlineConstantMutator]MSP[] buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea ) & MASK_8BITS ) ; break; case 3 : validateCharacter ( MASK_2BITS , context ) ; context . ibitWorkArea = context . ibitWorkArea >> 2 ;
bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ; MST[rv.CRCR4Mutator]MSP[] final byte [] bigBytes = bigInt . toByteArray () ;
if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_1 + MST[experimental.NakedReceiverMutator]MSP[] len + lr_2 + maxResultSize ) ; } return b64 . encode ( binaryData ) ; } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { return encodeBase64 ( binaryData , true ) ;
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[rv.UOI3Mutator]MSP[] } public static boolean isBase64 ( final byte [] arrayOctet ) {
for ( int i = 0 ; i < arrayOctet . length ; i ++ ) { if ( ! isBase64 ( arrayOctet [ i ] ) && ! isWhiteSpace ( arrayOctet [ i ] ) ) { return false ; } } return true ; MST[BooleanFalseReturnValsMutator]MSP[] }
for ( int i = 0 ; i < inAvail ; i ++ ) { MST[rv.ROR1Mutator]MSP[] final byte [] buffer = ensureBufferSize ( decodeSize , context ) ; final byte b = in [ inPos ++ ] ; if ( b == pad ) { context . eof = true ;
if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_1 + MST[rv.ABSMutator]MSP[] len + lr_2 + maxResultSize ) ; } return b64 . encode ( binaryData ) ; } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { return encodeBase64 ( binaryData , true ) ;
buffer [ context . pos ++ ] = encodeTable [ context . ibitWorkArea & MASK_6BITS ] ; MST[rv.AOR1Mutator]MSP[] context . currentLinePos += BYTES_PER_ENCODED_BLOCK ; if ( lineLength > 0 && lineLength <= context . currentLinePos ) {
bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ; MST[rv.AOR1Mutator]MSP[] final byte [] bigBytes = bigInt . toByteArray () ;
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.CRCR2Mutator]MSP[] return bigBytes ; } int startSrc = 0 ;
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.CRCR6Mutator]MSP[] return bigBytes ; } int startSrc = 0 ;
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[rv.UOI4Mutator]MSP[] } public static boolean isBase64 ( final byte [] arrayOctet ) {
buffer [ context . pos ++ ] = encodeTable [ context . ibitWorkArea & MASK_6BITS ] ; context . currentLinePos += BYTES_PER_ENCODED_BLOCK ; if ( lineLength > 0 && lineLength <= context . currentLinePos ) { MST[rv.UOI3Mutator]MSP[]
context . ibitWorkArea = context . ibitWorkArea >> 4 ; buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea ) & MASK_8BITS ) ; MST[rv.UOI4Mutator]MSP[] break; case 3 : validateCharacter ( MASK_2BITS , context ) ; context . ibitWorkArea = context . ibitWorkArea >> 2 ;
if ( binaryData == null || binaryData . length == 0 ) { return binaryData ; } final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; MST[rv.ROR1Mutator]MSP[] final long len = b64 . getEncodedLength ( binaryData ) ;
if ( binaryData == null || binaryData . length == 0 ) { return binaryData ; } final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; MST[rv.UOI3Mutator]MSP[] final long len = b64 . getEncodedLength ( binaryData ) ;
return octet >= 0 && octet < decodeTable . length && decodeTable [ octet ] != - 1 ; } public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; MST[rv.CRCR3Mutator]MSP[] } private void validateCharacter ( final int emptyBitsMask , final Context context ) {
buffer [ context . pos ++ ] = encodeTable [ context . ibitWorkArea & MASK_6BITS ] ; context . currentLinePos += BYTES_PER_ENCODED_BLOCK ; if ( lineLength > 0 && lineLength <= context . currentLinePos ) { MST[rv.UOI2Mutator]MSP[]
public static BigInteger decodeInteger ( final byte [] pArray ) { return new BigInteger ( 1 , decodeBase64 ( pArray ) ) ; MST[NullReturnValsMutator]MSP[] } public static byte [] encodeBase64 ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false ) ; }
throw new IllegalStateException ( lr_4 + context . modulus ) ; } context . currentLinePos += context . pos - savedPos ; if ( lineLength > 0 && context . currentLinePos > 0 ) { MST[rv.UOI2Mutator]MSP[]
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ context . pos ++ ] = pad ; buffer [ context . pos ++ ] = pad ; MST[rv.UOI2Mutator]MSP[] } break;
for ( int i = 0 ; i < arrayOctet . length ; i ++ ) { if ( ! isBase64 ( arrayOctet [ i ] ) && ! isWhiteSpace ( arrayOctet [ i ] ) ) { MST[rv.ROR2Mutator]MSP[] return false ; } } return true ; }
return octet >= 0 && octet < decodeTable . length && decodeTable [ octet ] != - 1 ; MST[rv.ROR3Mutator]MSP[] } public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } private void validateCharacter ( final int emptyBitsMask , final Context context ) {
return octet >= 0 && octet < decodeTable . length && decodeTable [ octet ] != - 1 ; MST[InlineConstantMutator]MSP[] } public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } private void validateCharacter ( final int emptyBitsMask , final Context context ) {
if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_1 + MST[rv.UOI2Mutator]MSP[] len + lr_2 + maxResultSize ) ; } return b64 . encode ( binaryData ) ; } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { return encodeBase64 ( binaryData , true ) ;
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ context . pos ++ ] = pad ; MST[rv.UOI2Mutator]MSP[] } break; default:
public static String encodeBase64URLSafeString ( final byte [] binaryData ) { return StringUtils . newStringUsAscii ( encodeBase64 ( binaryData , false , true ) ) ; MST[ReturnValsMutator]MSP[] } public static byte [] encodeInteger ( final BigInteger bigInteger ) { Objects . requireNonNull ( bigInteger , lr_3 ) ;
if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_1 + MST[NonVoidMethodCallMutator]MSP[] len + lr_2 + maxResultSize ) ; } return b64 . encode ( binaryData ) ; } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { return encodeBase64 ( binaryData , true ) ;
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.CRCR3Mutator]MSP[] return bigBytes ; } int startSrc = 0 ;
case 2 : buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 10 ) & MASK_6BITS ] ; MST[rv.CRCR4Mutator]MSP[] buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 4 ) & MASK_6BITS ] ;
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; MST[rv.UOI3Mutator]MSP[] return resizedBytes ; } @Override
context . ibitWorkArea = ( context . ibitWorkArea << 8 ) + b ; if ( 0 == context . modulus ) { buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 18 ) & MASK_6BITS ] ; MST[rv.UOI1Mutator]MSP[]
context . ibitWorkArea = context . ibitWorkArea >> 4 ; buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea ) & MASK_8BITS ) ; MST[rv.UOI1Mutator]MSP[] break; case 3 : validateCharacter ( MASK_2BITS , context ) ; context . ibitWorkArea = context . ibitWorkArea >> 2 ;
int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { MST[rv.AOR4Mutator]MSP[] startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; MST[rv.UOI4Mutator]MSP[] return resizedBytes ; } @Override
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[rv.ROR3Mutator]MSP[] } public static boolean isBase64 ( final byte [] arrayOctet ) {
int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ; MST[rv.AOR3Mutator]MSP[]
buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea >> 8 ) & MASK_8BITS ) ; MST[rv.UOI4Mutator]MSP[] buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea ) & MASK_8BITS ) ; break; default:
buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea >> 8 ) & MASK_8BITS ) ; MST[rv.UOI1Mutator]MSP[] buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea ) & MASK_8BITS ) ; break; default:
if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_1 + len + lr_2 + maxResultSize ) ; } return b64 . encode ( binaryData ) ; } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { return encodeBase64 ( binaryData , true ) ; MST[InlineConstantMutator]MSP[]
int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { MST[rv.AOR1Mutator]MSP[] startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
for ( int i = 0 ; i < arrayOctet . length ; i ++ ) { if ( ! isBase64 ( arrayOctet [ i ] ) && ! isWhiteSpace ( arrayOctet [ i ] ) ) { MST[NegateConditionalsMutator]MSP[] return false ; } } return true ; }
buffer [ context . pos ++ ] = encodeTable [ context . ibitWorkArea & MASK_6BITS ] ; context . currentLinePos += BYTES_PER_ENCODED_BLOCK ; if ( lineLength > 0 && lineLength <= context . currentLinePos ) { MST[ConditionalsBoundaryMutator]MSP[]
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[rv.CRCR1Mutator]MSP[] } public static boolean isBase64 ( final byte [] arrayOctet ) {
bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ; MST[rv.AOR4Mutator]MSP[] final byte [] bigBytes = bigInt . toByteArray () ;
throw new IllegalStateException ( lr_4 + context . modulus ) ; MST[ConstructorCallMutator]MSP[] } context . currentLinePos += context . pos - savedPos ; if ( lineLength > 0 && context . currentLinePos > 0 ) {
break; } if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; MST[rv.UOI3Mutator]MSP[] if ( result >= 0 ) { context . modulus = ( context . modulus + 1 ) % BYTES_PER_ENCODED_BLOCK ;
case 2 : buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 10 ) & MASK_6BITS ] ; buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 4 ) & MASK_6BITS ] ; MST[rv.OBBN1Mutator]MSP[]
return encodeBase64 ( toIntegerBytes ( bigInteger ) , false ) ; MST[NonVoidMethodCallMutator]MSP[] } @Deprecated public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { return isBase64 ( arrayOctet ) ; } public static boolean isBase64 ( final byte octet ) {
return encodeBase64 ( binaryData , isChunked , urlSafe , Integer . MAX_VALUE ) ; MST[rv.ABSMutator]MSP[] } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe , final int maxResultSize ) {
context . ibitWorkArea = ( context . ibitWorkArea << 8 ) + b ; MST[InlineConstantMutator]MSP[] if ( 0 == context . modulus ) { buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 18 ) & MASK_6BITS ] ;
return encodeBase64 ( binaryData , isChunked , urlSafe , Integer . MAX_VALUE ) ; MST[rv.UOI4Mutator]MSP[] } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe , final int maxResultSize ) {
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.CRCR1Mutator]MSP[] return bigBytes ; } int startSrc = 0 ;
public static String encodeBase64URLSafeString ( final byte [] binaryData ) { return StringUtils . newStringUsAscii ( encodeBase64 ( binaryData , false , true ) ) ; MST[rv.CRCR6Mutator]MSP[] } public static byte [] encodeInteger ( final BigInteger bigInteger ) { Objects . requireNonNull ( bigInteger , lr_3 ) ;
buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea >> 8 ) & MASK_8BITS ) ; MST[rv.AOR1Mutator]MSP[] buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea ) & MASK_8BITS ) ; break; default:
switch ( context . modulus ) { case 0 : break; case 1 : buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 2 ) & MASK_6BITS ] ; MST[rv.OBBN1Mutator]MSP[]
for ( int i = 0 ; i < arrayOctet . length ; i ++ ) { MST[rv.ABSMutator]MSP[] if ( ! isBase64 ( arrayOctet [ i ] ) && ! isWhiteSpace ( arrayOctet [ i ] ) ) { return false ; } } return true ; }
if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_1 + MST[experimental.NakedReceiverMutator]MSP[] len + lr_2 + maxResultSize ) ; } return b64 . encode ( binaryData ) ; } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { return encodeBase64 ( binaryData , true ) ;
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.UOI3Mutator]MSP[] return bigBytes ; } int startSrc = 0 ;
if ( len > maxResultSize ) { MST[rv.ROR5Mutator]MSP[] throw new IllegalArgumentException ( lr_1 + len + lr_2 + maxResultSize ) ; } return b64 . encode ( binaryData ) ; } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { return encodeBase64 ( binaryData , true ) ;
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[rv.UOI2Mutator]MSP[] } public static boolean isBase64 ( final byte [] arrayOctet ) {
int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ; MST[rv.CRCR6Mutator]MSP[]
for ( int i = 0 ; i < arrayOctet . length ; i ++ ) { if ( ! isBase64 ( arrayOctet [ i ] ) && ! isWhiteSpace ( arrayOctet [ i ] ) ) { MST[NonVoidMethodCallMutator]MSP[] return false ; } } return true ; }
context . ibitWorkArea = ( context . ibitWorkArea << BITS_PER_ENCODED_BYTE ) + result ; if ( context . modulus == 0 ) { buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea >> 16 ) & MASK_8BITS ) ; MST[rv.UOI4Mutator]MSP[]
case 2 : buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 10 ) & MASK_6BITS ] ; buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 4 ) & MASK_6BITS ] ; MST[rv.CRCR2Mutator]MSP[]
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.ROR4Mutator]MSP[] return bigBytes ; } int startSrc = 0 ;
buffer [ context . pos ++ ] = encodeTable [ context . ibitWorkArea & MASK_6BITS ] ; MST[rv.AOR4Mutator]MSP[] context . currentLinePos += BYTES_PER_ENCODED_BLOCK ; if ( lineLength > 0 && lineLength <= context . currentLinePos ) {
return octet >= 0 && octet < decodeTable . length && decodeTable [ octet ] != - 1 ; } public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; MST[rv.CRCR3Mutator]MSP[] } private void validateCharacter ( final int emptyBitsMask , final Context context ) {
if ( binaryData == null || binaryData . length == 0 ) { return binaryData ; } final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; MST[rv.UOI3Mutator]MSP[] final long len = b64 . getEncodedLength ( binaryData ) ;
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.CRCR4Mutator]MSP[] return bigBytes ; } int startSrc = 0 ;
for ( int i = 0 ; i < arrayOctet . length ; i ++ ) { if ( ! isBase64 ( arrayOctet [ i ] ) && ! isWhiteSpace ( arrayOctet [ i ] ) ) { MST[rv.UOI2Mutator]MSP[] return false ; } } return true ; }
switch ( context . modulus ) { case 0 : break; case 1 : buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 2 ) & MASK_6BITS ] ; MST[rv.CRCR5Mutator]MSP[]
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.AOR1Mutator]MSP[] return bigBytes ; } int startSrc = 0 ;
case 2 : buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 10 ) & MASK_6BITS ] ; MST[rv.ABSMutator]MSP[] buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 4 ) & MASK_6BITS ] ;
for ( int i = 0 ; i < arrayOctet . length ; i ++ ) { if ( ! isBase64 ( arrayOctet [ i ] ) && ! isWhiteSpace ( arrayOctet [ i ] ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return false ; } } return true ; }
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.AOR4Mutator]MSP[] return bigBytes ; } int startSrc = 0 ;
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.AOR3Mutator]MSP[] return bigBytes ; } int startSrc = 0 ;
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[NegateConditionalsMutator]MSP[] } public static boolean isBase64 ( final byte [] arrayOctet ) {
for ( int i = 0 ; i < inAvail ; i ++ ) { MST[rv.UOI4Mutator]MSP[] final byte [] buffer = ensureBufferSize ( decodeSize , context ) ; final byte b = in [ inPos ++ ] ; if ( b == pad ) { context . eof = true ;
throw new IllegalStateException ( lr_4 + context . modulus ) ; MST[rv.UOI4Mutator]MSP[] } } } @Override void encode ( final byte [] in , int inPos , final int inAvail , final Context context ) { if ( context . eof ) { return; }
case 2 : buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 10 ) & MASK_6BITS ] ; MST[rv.CRCR4Mutator]MSP[] buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 4 ) & MASK_6BITS ] ;
return encodeBase64 ( binaryData , isChunked , urlSafe , Integer . MAX_VALUE ) ; MST[NullReturnValsMutator]MSP[] } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe , final int maxResultSize ) {
if ( len > maxResultSize ) { MST[NegateConditionalsMutator]MSP[] throw new IllegalArgumentException ( lr_1 + len + lr_2 + maxResultSize ) ; } return b64 . encode ( binaryData ) ; } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { return encodeBase64 ( binaryData , true ) ;
for ( int i = 0 ; i < inAvail ; i ++ ) { MST[rv.UOI3Mutator]MSP[] final byte [] buffer = ensureBufferSize ( decodeSize , context ) ; final byte b = in [ inPos ++ ] ; if ( b == pad ) { context . eof = true ;
context . ibitWorkArea = ( context . ibitWorkArea << 8 ) + b ; if ( 0 == context . modulus ) { MST[rv.UOI3Mutator]MSP[] buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 18 ) & MASK_6BITS ] ;
context . ibitWorkArea = ( context . ibitWorkArea << 8 ) + b ; if ( 0 == context . modulus ) { buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 18 ) & MASK_6BITS ] ; MST[rv.AOR1Mutator]MSP[]
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[rv.CRCR6Mutator]MSP[] } public static boolean isBase64 ( final byte [] arrayOctet ) {
for ( int i = 0 ; i < inAvail ; i ++ ) { final byte [] buffer = ensureBufferSize ( decodeSize , context ) ; final byte b = in [ inPos ++ ] ; MST[rv.ABSMutator]MSP[] if ( b == pad ) { context . eof = true ;
case 2 : buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 10 ) & MASK_6BITS ] ; buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 4 ) & MASK_6BITS ] ; MST[rv.CRCR5Mutator]MSP[]
if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_1 + MST[rv.UOI2Mutator]MSP[] len + lr_2 + maxResultSize ) ; } return b64 . encode ( binaryData ) ; } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { return encodeBase64 ( binaryData , true ) ;
for ( int i = 0 ; i < arrayOctet . length ; i ++ ) { if ( ! isBase64 ( arrayOctet [ i ] ) && ! isWhiteSpace ( arrayOctet [ i ] ) ) { return false ; MST[rv.CRCR5Mutator]MSP[] } } return true ; }
return octet >= 0 && octet < decodeTable . length && decodeTable [ octet ] != - 1 ; MST[InlineConstantMutator]MSP[] } public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } private void validateCharacter ( final int emptyBitsMask , final Context context ) {
return octet >= 0 && octet < decodeTable . length && decodeTable [ octet ] != - 1 ; MST[rv.CRCR6Mutator]MSP[] } public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } private void validateCharacter ( final int emptyBitsMask , final Context context ) {
if ( isStrictDecoding () && ( context . ibitWorkArea & emptyBitsMask ) != 0 ) { MST[MathMutator]MSP[] throw new IllegalArgumentException ( lr_5 + lr_6 + lr_7 ) ; } } private void validateTrailingCharacter () { if ( isStrictDecoding () ) { throw new IllegalArgumentException ( lr_5 + lr_6 +
for ( int i = 0 ; i < arrayOctet . length ; i ++ ) { MST[rv.ROR1Mutator]MSP[] if ( ! isBase64 ( arrayOctet [ i ] ) && ! isWhiteSpace ( arrayOctet [ i ] ) ) { return false ; } } return true ; }
for ( int i = 0 ; i < arrayOctet . length ; i ++ ) { if ( ! isBase64 ( arrayOctet [ i ] ) && ! isWhiteSpace ( arrayOctet [ i ] ) ) { MST[rv.ROR5Mutator]MSP[] return false ; } } return true ; }
public static BigInteger decodeInteger ( final byte [] pArray ) { return new BigInteger ( 1 , decodeBase64 ( pArray ) ) ; } public static byte [] encodeBase64 ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false ) ; MST[NonVoidMethodCallMutator]MSP[] }
if ( context . eof && context . modulus != 0 ) { final byte [] buffer = ensureBufferSize ( decodeSize , context ) ; switch ( context . modulus ) { case 1 : validateTrailingCharacter () ; MST[VoidMethodCallMutator]MSP[] break; case 2 : validateCharacter ( MASK_4BITS , context ) ;
public static byte [] decodeBase64 ( final byte [] base64Data ) { return new Base64 () . decode ( base64Data ) ; } public static byte [] decodeBase64 ( final String base64String ) { return new Base64 () . decode ( base64String ) ; MST[ReturnValsMutator]MSP[] }
if ( binaryData == null || binaryData . length == 0 ) { MST[rv.ROR2Mutator]MSP[] return binaryData ; } final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; final long len = b64 . getEncodedLength ( binaryData ) ;
if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_1 + MST[NonVoidMethodCallMutator]MSP[] len + lr_2 + maxResultSize ) ; } return b64 . encode ( binaryData ) ; } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { return encodeBase64 ( binaryData , true ) ;
return encodeBase64 ( binaryData , isChunked , urlSafe , Integer . MAX_VALUE ) ; MST[rv.CRCR1Mutator]MSP[] } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe , final int maxResultSize ) {
return octet >= 0 && octet < decodeTable . length && decodeTable [ octet ] != - 1 ; } public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; MST[rv.CRCR6Mutator]MSP[] } private void validateCharacter ( final int emptyBitsMask , final Context context ) {
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[rv.UOI1Mutator]MSP[] } public static boolean isBase64 ( final byte [] arrayOctet ) {
final byte [] buffer = ensureBufferSize ( encodeSize , context ) ; context . modulus = ( context . modulus + 1 ) % BYTES_PER_UNENCODED_BLOCK ; MST[rv.AOR3Mutator]MSP[] int b = in [ inPos ++ ] ; if ( b < 0 ) { b += 256 ; }
bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ; MST[rv.CRCR2Mutator]MSP[] final byte [] bigBytes = bigInt . toByteArray () ;
if ( len > maxResultSize ) { MST[rv.UOI2Mutator]MSP[] throw new IllegalArgumentException ( lr_1 + len + lr_2 + maxResultSize ) ; } return b64 . encode ( binaryData ) ; } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { return encodeBase64 ( binaryData , true ) ;
final byte [] buffer = ensureBufferSize ( encodeSize , context ) ; context . modulus = ( context . modulus + 1 ) % BYTES_PER_UNENCODED_BLOCK ; MST[rv.CRCR4Mutator]MSP[] int b = in [ inPos ++ ] ; if ( b < 0 ) { b += 256 ; }
if ( context . eof && context . modulus != 0 ) { MST[rv.UOI1Mutator]MSP[] final byte [] buffer = ensureBufferSize ( decodeSize , context ) ; switch ( context . modulus ) { case 1 : validateTrailingCharacter () ; break; case 2 : validateCharacter ( MASK_4BITS , context ) ;
System . arraycopy ( lineSeparator , 0 , buffer , context . pos , lineSeparator . length ) ; MST[rv.CRCR1Mutator]MSP[] context . pos += lineSeparator . length ; context . currentLinePos = 0 ; } } } } } @Override protected boolean isInAlphabet ( final byte octet ) {
System . arraycopy ( lineSeparator , 0 , buffer , context . pos , lineSeparator . length ) ; context . pos += lineSeparator . length ; } } else { for ( int i = 0 ; i < inAvail ; i ++ ) { MST[rv.ABSMutator]MSP[]
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[ConditionalsBoundaryMutator]MSP[] } public static boolean isBase64 ( final byte [] arrayOctet ) {
break; } if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; MST[rv.UOI2Mutator]MSP[] if ( result >= 0 ) { context . modulus = ( context . modulus + 1 ) % BYTES_PER_ENCODED_BLOCK ;
context . ibitWorkArea = context . ibitWorkArea >> 4 ; buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea ) & MASK_8BITS ) ; MST[MathMutator]MSP[] break; case 3 : validateCharacter ( MASK_2BITS , context ) ; context . ibitWorkArea = context . ibitWorkArea >> 2 ;
if ( isStrictDecoding () && ( context . ibitWorkArea & emptyBitsMask ) != 0 ) { throw new IllegalArgumentException ( lr_5 + lr_6 + lr_7 ) ; } } private void validateTrailingCharacter () { if ( isStrictDecoding () ) { MST[rv.ROR5Mutator]MSP[] throw new IllegalArgumentException ( lr_5 + lr_6 +
if ( isStrictDecoding () && ( context . ibitWorkArea & emptyBitsMask ) != 0 ) { MST[rv.UOI2Mutator]MSP[] throw new IllegalArgumentException ( lr_5 + lr_6 + lr_7 ) ; } } private void validateTrailingCharacter () { if ( isStrictDecoding () ) { throw new IllegalArgumentException ( lr_5 + lr_6 +
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[rv.CRCR3Mutator]MSP[] } public static boolean isBase64 ( final byte [] arrayOctet ) {
if ( isStrictDecoding () && ( context . ibitWorkArea & emptyBitsMask ) != 0 ) { MST[rv.ROR3Mutator]MSP[] throw new IllegalArgumentException ( lr_5 + lr_6 + lr_7 ) ; } } private void validateTrailingCharacter () { if ( isStrictDecoding () ) { throw new IllegalArgumentException ( lr_5 + lr_6 +
context . ibitWorkArea = context . ibitWorkArea >> 4 ; buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea ) & MASK_8BITS ) ; break; case 3 : validateCharacter ( MASK_2BITS , context ) ; MST[rv.CRCR1Mutator]MSP[] context . ibitWorkArea = context . ibitWorkArea >> 2 ;
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ context . pos ++ ] = pad ; MST[rv.UOI2Mutator]MSP[] buffer [ context . pos ++ ] = pad ; } break;
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; MST[MathMutator]MSP[] System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; } @Override
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 12 ) & MASK_6BITS ] ; buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 6 ) & MASK_6BITS ] ; MST[rv.UOI3Mutator]MSP[]
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea << 4 ) & MASK_6BITS ] ; MST[rv.OBBN2Mutator]MSP[] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ context . pos ++ ] = pad ; buffer [ context . pos ++ ] = pad ; } break;
public static BigInteger decodeInteger ( final byte [] pArray ) { return new BigInteger ( 1 , decodeBase64 ( pArray ) ) ; } public static byte [] encodeBase64 ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false ) ; MST[rv.CRCR3Mutator]MSP[] }
System . arraycopy ( lineSeparator , 0 , buffer , context . pos , lineSeparator . length ) ; context . pos += lineSeparator . length ; } } else { for ( int i = 0 ; i < inAvail ; i ++ ) { MST[rv.CRCR3Mutator]MSP[]
if ( inAvail < 0 ) { context . eof = true ; MST[rv.CRCR4Mutator]MSP[] if ( 0 == context . modulus && lineLength == 0 ) { return; } final byte [] buffer = ensureBufferSize ( encodeSize , context ) ; final int savedPos = context . pos ;
buffer [ context . pos ++ ] = encodeTable [ context . ibitWorkArea & MASK_6BITS ] ; MST[InlineConstantMutator]MSP[] context . currentLinePos += BYTES_PER_ENCODED_BLOCK ; if ( lineLength > 0 && lineLength <= context . currentLinePos ) {
return encodeBase64 ( binaryData , isChunked , urlSafe , Integer . MAX_VALUE ) ; MST[rv.UOI1Mutator]MSP[] } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe , final int maxResultSize ) {
if ( context . eof && context . modulus != 0 ) { final byte [] buffer = ensureBufferSize ( decodeSize , context ) ; switch ( context . modulus ) { MST[rv.UOI3Mutator]MSP[] case 1 : validateTrailingCharacter () ; break; case 2 : validateCharacter ( MASK_4BITS , context ) ;
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.CRCR6Mutator]MSP[] return bigBytes ; } int startSrc = 0 ;
bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ; MST[rv.AOD1Mutator]MSP[] final byte [] bigBytes = bigInt . toByteArray () ;
if ( context . eof && context . modulus != 0 ) { MST[rv.ROR1Mutator]MSP[] final byte [] buffer = ensureBufferSize ( decodeSize , context ) ; switch ( context . modulus ) { case 1 : validateTrailingCharacter () ; break; case 2 : validateCharacter ( MASK_4BITS , context ) ;
switch ( context . modulus ) { case 0 : break; case 1 : buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 2 ) & MASK_6BITS ] ; MST[InlineConstantMutator]MSP[]
if ( binaryData == null || binaryData . length == 0 ) { return binaryData ; } final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] final long len = b64 . getEncodedLength ( binaryData ) ;
for ( int i = 0 ; i < arrayOctet . length ; i ++ ) { if ( ! isBase64 ( arrayOctet [ i ] ) && ! isWhiteSpace ( arrayOctet [ i ] ) ) { MST[rv.ABSMutator]MSP[] return false ; } } return true ; }
if ( binaryData == null || binaryData . length == 0 ) { return binaryData ; } final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; MST[rv.ABSMutator]MSP[] final long len = b64 . getEncodedLength ( binaryData ) ;
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 12 ) & MASK_6BITS ] ; MST[rv.CRCR3Mutator]MSP[] buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 6 ) & MASK_6BITS ] ;
buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea >> 8 ) & MASK_8BITS ) ; MST[rv.ABSMutator]MSP[] buffer [ context . pos ++ ] = (byte) ( context . ibitWorkArea & MASK_8BITS ) ; } } } }
return octet >= 0 && octet < decodeTable . length && decodeTable [ octet ] != - 1 ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] } public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } private void validateCharacter ( final int emptyBitsMask , final Context context ) {
for ( int i = 0 ; i < arrayOctet . length ; i ++ ) { if ( ! isBase64 ( arrayOctet [ i ] ) && ! isWhiteSpace ( arrayOctet [ i ] ) ) { return false ; } } return true ; MST[rv.CRCR2Mutator]MSP[] }
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 12 ) & MASK_6BITS ] ; buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 6 ) & MASK_6BITS ] ; MST[rv.CRCR4Mutator]MSP[]
int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { MST[rv.ROR3Mutator]MSP[] startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
if ( isStrictDecoding () && ( context . ibitWorkArea & emptyBitsMask ) != 0 ) { MST[rv.ROR1Mutator]MSP[] throw new IllegalArgumentException ( lr_5 + lr_6 + lr_7 ) ; } } private void validateTrailingCharacter () { if ( isStrictDecoding () ) { throw new IllegalArgumentException ( lr_5 + lr_6 +
int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
case 2 : buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 10 ) & MASK_6BITS ] ; MST[rv.ABSMutator]MSP[] buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 4 ) & MASK_6BITS ] ;
throw new IllegalStateException ( lr_4 + context . modulus ) ; MST[experimental.NakedReceiverMutator]MSP[] } context . currentLinePos += context . pos - savedPos ; if ( lineLength > 0 && context . currentLinePos > 0 ) {
public static String encodeBase64URLSafeString ( final byte [] binaryData ) { return StringUtils . newStringUsAscii ( encodeBase64 ( binaryData , false , true ) ) ; } public static byte [] encodeInteger ( final BigInteger bigInteger ) { Objects . requireNonNull ( bigInteger , lr_3 ) ; MST[NonVoidMethodCallMutator]MSP[]
bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ; MST[rv.CRCR2Mutator]MSP[] final byte [] bigBytes = bigInt . toByteArray () ;
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea << 4 ) & MASK_6BITS ] ; MST[rv.OBBN1Mutator]MSP[] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ context . pos ++ ] = pad ; buffer [ context . pos ++ ] = pad ; } break;
context . ibitWorkArea = ( context . ibitWorkArea << BITS_PER_ENCODED_BYTE ) + result ; MST[rv.AOR3Mutator]MSP[] if ( context . modulus == 0 ) { buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea >> 16 ) & MASK_8BITS ) ;
} public static String encodeBase64String ( final byte [] binaryData ) { return StringUtils . newStringUsAscii ( encodeBase64 ( binaryData , false ) ) ; } public static byte [] encodeBase64URLSafe ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false , true ) ; MST[rv.CRCR2Mutator]MSP[] }
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[rv.CRCR3Mutator]MSP[] } public static boolean isBase64 ( final byte [] arrayOctet ) {
case 2 : buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 10 ) & MASK_6BITS ] ; MST[rv.OBBN2Mutator]MSP[] buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 4 ) & MASK_6BITS ] ;
int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ; MST[rv.AOR2Mutator]MSP[]
public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked ) { return encodeBase64 ( binaryData , isChunked , false ) ; MST[NullReturnValsMutator]MSP[] } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe ) {
} public static String encodeBase64String ( final byte [] binaryData ) { return StringUtils . newStringUsAscii ( encodeBase64 ( binaryData , false ) ) ; } public static byte [] encodeBase64URLSafe ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false , true ) ; MST[NonVoidMethodCallMutator]MSP[] }
for ( int i = 0 ; i < arrayOctet . length ; i ++ ) { if ( ! isBase64 ( arrayOctet [ i ] ) && ! isWhiteSpace ( arrayOctet [ i ] ) ) { MST[rv.ROR2Mutator]MSP[] return false ; } } return true ; }
System . arraycopy ( lineSeparator , 0 , buffer , context . pos , lineSeparator . length ) ; MST[rv.CRCR3Mutator]MSP[] context . pos += lineSeparator . length ; context . currentLinePos = 0 ; } } } } } @Override protected boolean isInAlphabet ( final byte octet ) {
if ( isStrictDecoding () && ( context . ibitWorkArea & emptyBitsMask ) != 0 ) { MST[rv.UOI4Mutator]MSP[] throw new IllegalArgumentException ( lr_5 + lr_6 + lr_7 ) ; } } private void validateTrailingCharacter () { if ( isStrictDecoding () ) { throw new IllegalArgumentException ( lr_5 + lr_6 +
for ( int i = 0 ; i < arrayOctet . length ; i ++ ) { MST[InlineConstantMutator]MSP[] if ( ! isBase64 ( arrayOctet [ i ] ) && ! isWhiteSpace ( arrayOctet [ i ] ) ) { return false ; } } return true ; }
break; } if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; MST[rv.UOI4Mutator]MSP[] if ( result >= 0 ) { context . modulus = ( context . modulus + 1 ) % BYTES_PER_ENCODED_BLOCK ;
public static BigInteger decodeInteger ( final byte [] pArray ) { return new BigInteger ( 1 , decodeBase64 ( pArray ) ) ; MST[rv.CRCR2Mutator]MSP[] } public static byte [] encodeBase64 ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false ) ; }
throw new IllegalStateException ( lr_4 + context . modulus ) ; } context . currentLinePos += context . pos - savedPos ; MST[rv.UOI2Mutator]MSP[] if ( lineLength > 0 && context . currentLinePos > 0 ) {
context . ibitWorkArea = ( context . ibitWorkArea << 8 ) + b ; if ( 0 == context . modulus ) { buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 18 ) & MASK_6BITS ] ; MST[rv.CRCR2Mutator]MSP[]
break; } if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { context . modulus = ( context . modulus + 1 ) % BYTES_PER_ENCODED_BLOCK ; MST[rv.AOR4Mutator]MSP[]
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea << 4 ) & MASK_6BITS ] ; MST[rv.CRCR3Mutator]MSP[] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ context . pos ++ ] = pad ; buffer [ context . pos ++ ] = pad ; } break;
bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ; MST[InlineConstantMutator]MSP[] final byte [] bigBytes = bigInt . toByteArray () ;
final byte [] buffer = ensureBufferSize ( encodeSize , context ) ; context . modulus = ( context . modulus + 1 ) % BYTES_PER_UNENCODED_BLOCK ; MST[experimental.MemberVariableMutator]MSP[] int b = in [ inPos ++ ] ; if ( b < 0 ) { b += 256 ; }
int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ; MST[rv.CRCR1Mutator]MSP[]
case 2 : buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 10 ) & MASK_6BITS ] ; buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 4 ) & MASK_6BITS ] ; MST[rv.OBBN3Mutator]MSP[]
if ( inAvail < 0 ) { context . eof = true ; if ( 0 == context . modulus && lineLength == 0 ) { MST[rv.CRCR6Mutator]MSP[] return; } final byte [] buffer = ensureBufferSize ( encodeSize , context ) ; final int savedPos = context . pos ;
if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_1 + MST[rv.UOI1Mutator]MSP[] len + lr_2 + maxResultSize ) ; } return b64 . encode ( binaryData ) ; } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { return encodeBase64 ( binaryData , true ) ;
if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_1 + MST[rv.UOI4Mutator]MSP[] len + lr_2 + maxResultSize ) ; } return b64 . encode ( binaryData ) ; } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { return encodeBase64 ( binaryData , true ) ;
return octet >= 0 && octet < decodeTable . length && decodeTable [ octet ] != - 1 ; MST[rv.CRCR5Mutator]MSP[] } public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } private void validateCharacter ( final int emptyBitsMask , final Context context ) {
if ( isStrictDecoding () && ( context . ibitWorkArea & emptyBitsMask ) != 0 ) { throw new IllegalArgumentException ( lr_5 + lr_6 + lr_7 ) ; } } private void validateTrailingCharacter () { if ( isStrictDecoding () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] throw new IllegalArgumentException ( lr_5 + lr_6 +
return octet >= 0 && octet < decodeTable . length && decodeTable [ octet ] != - 1 ; MST[BooleanTrueReturnValsMutator]MSP[] } public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } private void validateCharacter ( final int emptyBitsMask , final Context context ) {
if ( binaryData == null || binaryData . length == 0 ) { MST[rv.ROR1Mutator]MSP[] return binaryData ; } final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; final long len = b64 . getEncodedLength ( binaryData ) ;
if ( binaryData == null || binaryData . length == 0 ) { MST[rv.ROR4Mutator]MSP[] return binaryData ; } final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; final long len = b64 . getEncodedLength ( binaryData ) ;
for ( int i = 0 ; i < inAvail ; i ++ ) { MST[rv.CRCR5Mutator]MSP[] final byte [] buffer = ensureBufferSize ( decodeSize , context ) ; final byte b = in [ inPos ++ ] ; if ( b == pad ) { context . eof = true ;
throw new IllegalStateException ( lr_4 + context . modulus ) ; MST[ConstructorCallMutator]MSP[] } context . currentLinePos += context . pos - savedPos ; if ( lineLength > 0 && context . currentLinePos > 0 ) {
int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { MST[rv.CRCR2Mutator]MSP[] startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
return octet >= 0 && octet < decodeTable . length && decodeTable [ octet ] != - 1 ; } public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; MST[rv.CRCR6Mutator]MSP[] } private void validateCharacter ( final int emptyBitsMask , final Context context ) {
break; } if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; MST[rv.UOI1Mutator]MSP[] if ( result >= 0 ) { context . modulus = ( context . modulus + 1 ) % BYTES_PER_ENCODED_BLOCK ;
buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea >> 8 ) & MASK_8BITS ) ; buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea ) & MASK_8BITS ) ; MST[rv.UOI4Mutator]MSP[] break; default:
break; } if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { MST[rv.ROR2Mutator]MSP[] context . modulus = ( context . modulus + 1 ) % BYTES_PER_ENCODED_BLOCK ;
context . ibitWorkArea = context . ibitWorkArea >> 4 ; buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea ) & MASK_8BITS ) ; break; case 3 : validateCharacter ( MASK_2BITS , context ) ; MST[VoidMethodCallMutator]MSP[] context . ibitWorkArea = context . ibitWorkArea >> 2 ;
buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea >> 8 ) & MASK_8BITS ) ; buffer [ context . pos ++ ] = (byte) ( context . ibitWorkArea & MASK_8BITS ) ; MST[rv.AOR3Mutator]MSP[] } } } }
int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { MST[rv.AOD1Mutator]MSP[] startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[rv.UOI4Mutator]MSP[] } public static boolean isBase64 ( final byte [] arrayOctet ) {
return encodeBase64 ( binaryData , isChunked , urlSafe , Integer . MAX_VALUE ) ; MST[ReturnValsMutator]MSP[] } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe , final int maxResultSize ) {
for ( int i = 0 ; i < inAvail ; i ++ ) { MST[rv.UOI2Mutator]MSP[] final byte [] buffer = ensureBufferSize ( decodeSize , context ) ; final byte b = in [ inPos ++ ] ; if ( b == pad ) { context . eof = true ;
if ( inAvail < 0 ) { context . eof = true ; if ( 0 == context . modulus && lineLength == 0 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return; } final byte [] buffer = ensureBufferSize ( encodeSize , context ) ; final int savedPos = context . pos ;
throw new IllegalStateException ( lr_4 + context . modulus ) ; } context . currentLinePos += context . pos - savedPos ; if ( lineLength > 0 && context . currentLinePos > 0 ) { MST[rv.ROR1Mutator]MSP[]
break; } if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { context . modulus = ( context . modulus + 1 ) % BYTES_PER_ENCODED_BLOCK ; MST[rv.AOD2Mutator]MSP[]
buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea >> 8 ) & MASK_8BITS ) ; buffer [ context . pos ++ ] = (byte) ( context . ibitWorkArea & MASK_8BITS ) ; MST[rv.CRCR2Mutator]MSP[] } } } }
final byte [] buffer = ensureBufferSize ( encodeSize , context ) ; context . modulus = ( context . modulus + 1 ) % BYTES_PER_UNENCODED_BLOCK ; MST[rv.CRCR1Mutator]MSP[] int b = in [ inPos ++ ] ; if ( b < 0 ) { b += 256 ; }
context . ibitWorkArea = ( context . ibitWorkArea << BITS_PER_ENCODED_BYTE ) + result ; if ( context . modulus == 0 ) { buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea >> 16 ) & MASK_8BITS ) ; MST[rv.OBBN1Mutator]MSP[]
if ( context . eof && context . modulus != 0 ) { final byte [] buffer = ensureBufferSize ( decodeSize , context ) ; MST[rv.UOI2Mutator]MSP[] switch ( context . modulus ) { case 1 : validateTrailingCharacter () ; break; case 2 : validateCharacter ( MASK_4BITS , context ) ;
throw new IllegalStateException ( lr_4 + context . modulus ) ; MST[NonVoidMethodCallMutator]MSP[] } } } @Override void encode ( final byte [] in , int inPos , final int inAvail , final Context context ) { if ( context . eof ) { return; }
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; MST[rv.ABSMutator]MSP[] return resizedBytes ; } @Override
buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea >> 8 ) & MASK_8BITS ) ; buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea ) & MASK_8BITS ) ; MST[rv.AOD2Mutator]MSP[] break; default:
if ( binaryData == null || binaryData . length == 0 ) { return binaryData ; } final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; MST[rv.UOI2Mutator]MSP[] final long len = b64 . getEncodedLength ( binaryData ) ;
buffer [ context . pos ++ ] = encodeTable [ context . ibitWorkArea & MASK_6BITS ] ; MST[rv.AOR3Mutator]MSP[] context . currentLinePos += BYTES_PER_ENCODED_BLOCK ; if ( lineLength > 0 && lineLength <= context . currentLinePos ) {
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[rv.CRCR6Mutator]MSP[] } public static boolean isBase64 ( final byte [] arrayOctet ) {
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; MST[rv.UOI3Mutator]MSP[] System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; } @Override
if ( inAvail < 0 ) { context . eof = true ; if ( 0 == context . modulus && lineLength == 0 ) { MST[rv.ROR4Mutator]MSP[] return; } final byte [] buffer = ensureBufferSize ( encodeSize , context ) ; final int savedPos = context . pos ;
void decode ( final byte [] in , int inPos , final int inAvail , final Context context ) { if ( context . eof ) { return; } if ( inAvail < 0 ) { MST[ConditionalsBoundaryMutator]MSP[] context . eof = true ; }
context . ibitWorkArea = ( context . ibitWorkArea << 8 ) + b ; if ( 0 == context . modulus ) { buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 18 ) & MASK_6BITS ] ; MST[rv.UOI2Mutator]MSP[]
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 12 ) & MASK_6BITS ] ; buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 6 ) & MASK_6BITS ] ; MST[rv.AOR2Mutator]MSP[]
int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { MST[rv.CRCR5Mutator]MSP[] startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 12 ) & MASK_6BITS ] ; MST[rv.UOI3Mutator]MSP[] buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 6 ) & MASK_6BITS ] ;
if ( inAvail < 0 ) { context . eof = true ; if ( 0 == context . modulus && lineLength == 0 ) { MST[rv.ABSMutator]MSP[] return; } final byte [] buffer = ensureBufferSize ( encodeSize , context ) ; final int savedPos = context . pos ;
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] } public static boolean isBase64 ( final byte [] arrayOctet ) {
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.AOR3Mutator]MSP[] return bigBytes ; } int startSrc = 0 ;
switch ( context . modulus ) { case 0 : break; case 1 : buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 2 ) & MASK_6BITS ] ; MST[rv.CRCR4Mutator]MSP[]
if ( binaryData == null || binaryData . length == 0 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return binaryData ; } final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; final long len = b64 . getEncodedLength ( binaryData ) ;
break; } if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { context . modulus = ( context . modulus + 1 ) % BYTES_PER_ENCODED_BLOCK ; MST[MathMutator]MSP[]
buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea >> 8 ) & MASK_8BITS ) ; buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea ) & MASK_8BITS ) ; MST[rv.UOI1Mutator]MSP[] break; default:
if ( binaryData == null || binaryData . length == 0 ) { return binaryData ; } final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; MST[rv.ABSMutator]MSP[] final long len = b64 . getEncodedLength ( binaryData ) ;
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; MST[rv.UOI1Mutator]MSP[] return resizedBytes ; } @Override
return octet >= 0 && octet < decodeTable . length && decodeTable [ octet ] != - 1 ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] } public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } private void validateCharacter ( final int emptyBitsMask , final Context context ) {
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea << 4 ) & MASK_6BITS ] ; MST[MathMutator]MSP[] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ context . pos ++ ] = pad ; buffer [ context . pos ++ ] = pad ; } break;
if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_1 + len + lr_2 + maxResultSize ) ; } return b64 . encode ( binaryData ) ; } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { return encodeBase64 ( binaryData , true ) ; MST[rv.CRCR3Mutator]MSP[]
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[rv.ROR3Mutator]MSP[] } public static boolean isBase64 ( final byte [] arrayOctet ) {
} public static String encodeBase64String ( final byte [] binaryData ) { return StringUtils . newStringUsAscii ( encodeBase64 ( binaryData , false ) ) ; } public static byte [] encodeBase64URLSafe ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false , true ) ; MST[rv.CRCR6Mutator]MSP[] }
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.CRCR3Mutator]MSP[] return bigBytes ; } int startSrc = 0 ;
for ( int i = 0 ; i < arrayOctet . length ; i ++ ) { if ( ! isBase64 ( arrayOctet [ i ] ) && ! isWhiteSpace ( arrayOctet [ i ] ) ) { MST[rv.UOI1Mutator]MSP[] return false ; } } return true ; }
for ( int i = 0 ; i < arrayOctet . length ; i ++ ) { if ( ! isBase64 ( arrayOctet [ i ] ) && ! isWhiteSpace ( arrayOctet [ i ] ) ) { MST[rv.ABSMutator]MSP[] return false ; } } return true ; }
for ( int i = 0 ; i < arrayOctet . length ; i ++ ) { if ( ! isBase64 ( arrayOctet [ i ] ) && ! isWhiteSpace ( arrayOctet [ i ] ) ) { return false ; } } return true ; MST[rv.CRCR5Mutator]MSP[] }
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea << 2 ) & MASK_6BITS ] ; MST[MathMutator]MSP[] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ context . pos ++ ] = pad ; } break; default:
case 2 : buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 10 ) & MASK_6BITS ] ; buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 4 ) & MASK_6BITS ] ; MST[InlineConstantMutator]MSP[]
return encodeBase64 ( toIntegerBytes ( bigInteger ) , false ) ; MST[rv.CRCR3Mutator]MSP[] } @Deprecated public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { return isBase64 ( arrayOctet ) ; } public static boolean isBase64 ( final byte octet ) {
final byte [] buffer = ensureBufferSize ( encodeSize , context ) ; context . modulus = ( context . modulus + 1 ) % BYTES_PER_UNENCODED_BLOCK ; int b = in [ inPos ++ ] ; MST[rv.UOI4Mutator]MSP[] if ( b < 0 ) { b += 256 ; }
final byte [] buffer = ensureBufferSize ( encodeSize , context ) ; MST[NonVoidMethodCallMutator]MSP[] context . modulus = ( context . modulus + 1 ) % BYTES_PER_UNENCODED_BLOCK ; int b = in [ inPos ++ ] ; if ( b < 0 ) { b += 256 ; }
int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ; MST[rv.CRCR4Mutator]MSP[]
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[rv.ROR5Mutator]MSP[] } public static boolean isBase64 ( final byte [] arrayOctet ) {
return octet >= 0 && octet < decodeTable . length && decodeTable [ octet ] != - 1 ; MST[rv.UOI3Mutator]MSP[] } public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } private void validateCharacter ( final int emptyBitsMask , final Context context ) {
if ( binaryData == null || binaryData . length == 0 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return binaryData ; } final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; final long len = b64 . getEncodedLength ( binaryData ) ;
} public static String encodeBase64String ( final byte [] binaryData ) { return StringUtils . newStringUsAscii ( encodeBase64 ( binaryData , false ) ) ; } public static byte [] encodeBase64URLSafe ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false , true ) ; MST[rv.CRCR3Mutator]MSP[] }
for ( int i = 0 ; i < inAvail ; i ++ ) { final byte [] buffer = ensureBufferSize ( decodeSize , context ) ; final byte b = in [ inPos ++ ] ; if ( b == pad ) { MST[rv.UOI2Mutator]MSP[] context . eof = true ;
return encodeBase64 ( binaryData , isChunked , urlSafe , Integer . MAX_VALUE ) ; MST[rv.UOI2Mutator]MSP[] } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe , final int maxResultSize ) {
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.ROR3Mutator]MSP[] return bigBytes ; } int startSrc = 0 ;
if ( context . eof && context . modulus != 0 ) { MST[rv.UOI3Mutator]MSP[] final byte [] buffer = ensureBufferSize ( decodeSize , context ) ; switch ( context . modulus ) { case 1 : validateTrailingCharacter () ; break; case 2 : validateCharacter ( MASK_4BITS , context ) ;
int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { MST[rv.AOR3Mutator]MSP[] startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.AOD1Mutator]MSP[] return bigBytes ; } int startSrc = 0 ;
throw new IllegalStateException ( lr_4 + context . modulus ) ; MST[ConstructorCallMutator]MSP[] } } } @Override void encode ( final byte [] in , int inPos , final int inAvail , final Context context ) { if ( context . eof ) { return; }
for ( int i = 0 ; i < arrayOctet . length ; i ++ ) { if ( ! isBase64 ( arrayOctet [ i ] ) && ! isWhiteSpace ( arrayOctet [ i ] ) ) { return false ; } } return true ; MST[ReturnValsMutator]MSP[] }
if ( isStrictDecoding () && ( context . ibitWorkArea & emptyBitsMask ) != 0 ) { throw new IllegalArgumentException ( lr_5 + lr_6 + lr_7 ) ; } } private void validateTrailingCharacter () { if ( isStrictDecoding () ) { MST[rv.ROR3Mutator]MSP[] throw new IllegalArgumentException ( lr_5 + lr_6 +
} public static String encodeBase64String ( final byte [] binaryData ) { return StringUtils . newStringUsAscii ( encodeBase64 ( binaryData , false ) ) ; MST[EmptyObjectReturnValsMutator]MSP[] } public static byte [] encodeBase64URLSafe ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false , true ) ; }
buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea >> 8 ) & MASK_8BITS ) ; buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea ) & MASK_8BITS ) ; MST[rv.ABSMutator]MSP[] break; default:
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[MathMutator]MSP[] return bigBytes ; } int startSrc = 0 ;
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[rv.ABSMutator]MSP[] } public static boolean isBase64 ( final byte [] arrayOctet ) {
bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ; MST[rv.CRCR5Mutator]MSP[] final byte [] bigBytes = bigInt . toByteArray () ;
public static BigInteger decodeInteger ( final byte [] pArray ) { return new BigInteger ( 1 , decodeBase64 ( pArray ) ) ; } public static byte [] encodeBase64 ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false ) ; MST[rv.CRCR5Mutator]MSP[] }
switch ( context . modulus ) { case 0 : break; case 1 : buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 2 ) & MASK_6BITS ] ; MST[rv.UOI3Mutator]MSP[]
return octet >= 0 && octet < decodeTable . length && decodeTable [ octet ] != - 1 ; MST[ReturnValsMutator]MSP[] } public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } private void validateCharacter ( final int emptyBitsMask , final Context context ) {
if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_1 + MST[rv.UOI4Mutator]MSP[] len + lr_2 + maxResultSize ) ; } return b64 . encode ( binaryData ) ; } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { return encodeBase64 ( binaryData , true ) ;
for ( int i = 0 ; i < arrayOctet . length ; i ++ ) { if ( ! isBase64 ( arrayOctet [ i ] ) && ! isWhiteSpace ( arrayOctet [ i ] ) ) { return false ; MST[rv.CRCR3Mutator]MSP[] } } return true ; }
public static byte [] decodeBase64 ( final byte [] base64Data ) { return new Base64 () . decode ( base64Data ) ; MST[ConstructorCallMutator]MSP[] } public static byte [] decodeBase64 ( final String base64String ) { return new Base64 () . decode ( base64String ) ; }
if ( binaryData == null || binaryData . length == 0 ) { return binaryData ; MST[ReturnValsMutator]MSP[] } final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; final long len = b64 . getEncodedLength ( binaryData ) ;
if ( binaryData == null || binaryData . length == 0 ) { return binaryData ; } final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; MST[rv.CRCR6Mutator]MSP[] final long len = b64 . getEncodedLength ( binaryData ) ;
for ( int i = 0 ; i < arrayOctet . length ; i ++ ) { MST[rv.ROR4Mutator]MSP[] if ( ! isBase64 ( arrayOctet [ i ] ) && ! isWhiteSpace ( arrayOctet [ i ] ) ) { return false ; } } return true ; }
if ( inAvail < 0 ) { context . eof = true ; if ( 0 == context . modulus && lineLength == 0 ) { MST[rv.UOI2Mutator]MSP[] return; } final byte [] buffer = ensureBufferSize ( encodeSize , context ) ; final int savedPos = context . pos ;
context . ibitWorkArea = ( context . ibitWorkArea << 8 ) + b ; if ( 0 == context . modulus ) { buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 18 ) & MASK_6BITS ] ; MST[rv.AOR3Mutator]MSP[]
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.CRCR2Mutator]MSP[] return bigBytes ; } int startSrc = 0 ;
return encodeBase64 ( binaryData , isChunked , urlSafe , Integer . MAX_VALUE ) ; MST[rv.CRCR3Mutator]MSP[] } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe , final int maxResultSize ) {
case 2 : buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 10 ) & MASK_6BITS ] ; buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 4 ) & MASK_6BITS ] ; MST[rv.CRCR4Mutator]MSP[]
if ( len > maxResultSize ) { MST[rv.UOI4Mutator]MSP[] throw new IllegalArgumentException ( lr_1 + len + lr_2 + maxResultSize ) ; } return b64 . encode ( binaryData ) ; } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { return encodeBase64 ( binaryData , true ) ;
buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea >> 8 ) & MASK_8BITS ) ; MST[rv.CRCR4Mutator]MSP[] buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea ) & MASK_8BITS ) ; break; default:
if ( len > maxResultSize ) { MST[rv.ABSMutator]MSP[] throw new IllegalArgumentException ( lr_1 + len + lr_2 + maxResultSize ) ; } return b64 . encode ( binaryData ) ; } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { return encodeBase64 ( binaryData , true ) ;
if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_1 + MST[ConstructorCallMutator]MSP[] len + lr_2 + maxResultSize ) ; } return b64 . encode ( binaryData ) ; } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { return encodeBase64 ( binaryData , true ) ;
if ( binaryData == null || binaryData . length == 0 ) { return binaryData ; } final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; MST[rv.UOI2Mutator]MSP[] final long len = b64 . getEncodedLength ( binaryData ) ;
if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_1 + len + lr_2 + maxResultSize ) ; } return b64 . encode ( binaryData ) ; } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { return encodeBase64 ( binaryData , true ) ; MST[ArgumentPropagationMutator]MSP[]
bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ; MST[rv.AOR3Mutator]MSP[] final byte [] bigBytes = bigInt . toByteArray () ;
if ( inAvail < 0 ) { context . eof = true ; if ( 0 == context . modulus && lineLength == 0 ) { MST[rv.UOI3Mutator]MSP[] return; } final byte [] buffer = ensureBufferSize ( encodeSize , context ) ; final int savedPos = context . pos ;
case 2 : buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 10 ) & MASK_6BITS ] ; MST[rv.CRCR3Mutator]MSP[] buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 4 ) & MASK_6BITS ] ;
System . arraycopy ( lineSeparator , 0 , buffer , context . pos , lineSeparator . length ) ; context . pos += lineSeparator . length ; } } else { for ( int i = 0 ; i < inAvail ; i ++ ) { MST[rv.ROR3Mutator]MSP[]
if ( binaryData == null || binaryData . length == 0 ) { return binaryData ; } final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; MST[rv.ROR3Mutator]MSP[] final long len = b64 . getEncodedLength ( binaryData ) ;
context . ibitWorkArea = ( context . ibitWorkArea << BITS_PER_ENCODED_BYTE ) + result ; if ( context . modulus == 0 ) { buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea >> 16 ) & MASK_8BITS ) ; MST[rv.AOR1Mutator]MSP[]
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; MST[rv.UOI2Mutator]MSP[] return resizedBytes ; } @Override
return octet >= 0 && octet < decodeTable . length && decodeTable [ octet ] != - 1 ; MST[rv.UOI4Mutator]MSP[] } public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } private void validateCharacter ( final int emptyBitsMask , final Context context ) {
int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
public static String encodeBase64URLSafeString ( final byte [] binaryData ) { return StringUtils . newStringUsAscii ( encodeBase64 ( binaryData , false , true ) ) ; MST[rv.CRCR5Mutator]MSP[] } public static byte [] encodeInteger ( final BigInteger bigInteger ) { Objects . requireNonNull ( bigInteger , lr_3 ) ;
} public static String encodeBase64String ( final byte [] binaryData ) { return StringUtils . newStringUsAscii ( encodeBase64 ( binaryData , false ) ) ; MST[rv.CRCR3Mutator]MSP[] } public static byte [] encodeBase64URLSafe ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false , true ) ; }
case 2 : buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 10 ) & MASK_6BITS ] ; MST[rv.AOR1Mutator]MSP[] buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 4 ) & MASK_6BITS ] ;
for ( int i = 0 ; i < arrayOctet . length ; i ++ ) { if ( ! isBase64 ( arrayOctet [ i ] ) && ! isWhiteSpace ( arrayOctet [ i ] ) ) { MST[rv.UOI4Mutator]MSP[] return false ; } } return true ; }
context . ibitWorkArea = ( context . ibitWorkArea << BITS_PER_ENCODED_BYTE ) + result ; if ( context . modulus == 0 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea >> 16 ) & MASK_8BITS ) ;
for ( int i = 0 ; i < arrayOctet . length ; i ++ ) { MST[rv.UOI1Mutator]MSP[] if ( ! isBase64 ( arrayOctet [ i ] ) && ! isWhiteSpace ( arrayOctet [ i ] ) ) { return false ; } } return true ; }
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.AOR3Mutator]MSP[] return bigBytes ; } int startSrc = 0 ;
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { return bigBytes ; } int startSrc = 0 ; MST[rv.CRCR1Mutator]MSP[]
if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_1 + len + lr_2 + maxResultSize ) ; } return b64 . encode ( binaryData ) ; MST[ReturnValsMutator]MSP[] } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { return encodeBase64 ( binaryData , true ) ;
context . ibitWorkArea = ( context . ibitWorkArea << BITS_PER_ENCODED_BYTE ) + result ; if ( context . modulus == 0 ) { buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea >> 16 ) & MASK_8BITS ) ; MST[rv.CRCR4Mutator]MSP[]
public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked ) { return encodeBase64 ( binaryData , isChunked , false ) ; MST[InlineConstantMutator]MSP[] } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe ) {
final byte [] buffer = ensureBufferSize ( encodeSize , context ) ; context . modulus = ( context . modulus + 1 ) % BYTES_PER_UNENCODED_BLOCK ; MST[rv.AOD2Mutator]MSP[] int b = in [ inPos ++ ] ; if ( b < 0 ) { b += 256 ; }
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.CRCR5Mutator]MSP[] return bigBytes ; } int startSrc = 0 ;
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.ROR1Mutator]MSP[] return bigBytes ; } int startSrc = 0 ;
int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { MST[MathMutator]MSP[] startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
public static byte [] decodeBase64 ( final byte [] base64Data ) { return new Base64 () . decode ( base64Data ) ; MST[NullReturnValsMutator]MSP[] } public static byte [] decodeBase64 ( final String base64String ) { return new Base64 () . decode ( base64String ) ; }
int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ; MST[rv.AOR4Mutator]MSP[]
public static boolean isBase64 ( final String base64 ) { return isBase64 ( StringUtils . getBytesUtf8 ( base64 ) ) ; MST[ReturnValsMutator]MSP[] } static byte [] toIntegerBytes ( final BigInteger bigInt ) { int bitlen = bigInt . bitLength () ;
context . ibitWorkArea = ( context . ibitWorkArea << 8 ) + b ; MST[rv.AOR3Mutator]MSP[] if ( 0 == context . modulus ) { buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 18 ) & MASK_6BITS ] ;
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 12 ) & MASK_6BITS ] ; MST[rv.ABSMutator]MSP[] buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 6 ) & MASK_6BITS ] ;
switch ( context . modulus ) { MST[rv.UOI3Mutator]MSP[] case 0 : break; case 1 : buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 2 ) & MASK_6BITS ] ;
if ( len > maxResultSize ) { MST[rv.ROR4Mutator]MSP[] throw new IllegalArgumentException ( lr_1 + len + lr_2 + maxResultSize ) ; } return b64 . encode ( binaryData ) ; } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { return encodeBase64 ( binaryData , true ) ;
bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ; MST[rv.CRCR5Mutator]MSP[] final byte [] bigBytes = bigInt . toByteArray () ;
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea << 4 ) & MASK_6BITS ] ; MST[rv.CRCR5Mutator]MSP[] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ context . pos ++ ] = pad ; buffer [ context . pos ++ ] = pad ; } break;
final byte [] buffer = ensureBufferSize ( encodeSize , context ) ; context . modulus = ( context . modulus + 1 ) % BYTES_PER_UNENCODED_BLOCK ; int b = in [ inPos ++ ] ; MST[rv.UOI1Mutator]MSP[] if ( b < 0 ) { b += 256 ; }
final byte [] buffer = ensureBufferSize ( encodeSize , context ) ; context . modulus = ( context . modulus + 1 ) % BYTES_PER_UNENCODED_BLOCK ; MST[MathMutator]MSP[] int b = in [ inPos ++ ] ; if ( b < 0 ) { b += 256 ; }
if ( len > maxResultSize ) { MST[rv.UOI2Mutator]MSP[] throw new IllegalArgumentException ( lr_1 + len + lr_2 + maxResultSize ) ; } return b64 . encode ( binaryData ) ; } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { return encodeBase64 ( binaryData , true ) ;
for ( int i = 0 ; i < arrayOctet . length ; i ++ ) { if ( ! isBase64 ( arrayOctet [ i ] ) && ! isWhiteSpace ( arrayOctet [ i ] ) ) { MST[rv.ROR1Mutator]MSP[] return false ; } } return true ; }
bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ; MST[rv.CRCR1Mutator]MSP[] final byte [] bigBytes = bigInt . toByteArray () ;
break; } if ( b >= 0 && b < DECODE_TABLE . length ) { MST[rv.UOI1Mutator]MSP[] final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { context . modulus = ( context . modulus + 1 ) % BYTES_PER_ENCODED_BLOCK ;
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea << 2 ) & MASK_6BITS ] ; MST[rv.CRCR5Mutator]MSP[] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ context . pos ++ ] = pad ; } break; default:
int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ; MST[rv.UOI4Mutator]MSP[]
switch ( context . modulus ) { case 0 : break; case 1 : buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 2 ) & MASK_6BITS ] ; MST[rv.CRCR4Mutator]MSP[]
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] } public static boolean isBase64 ( final byte [] arrayOctet ) {
if ( isStrictDecoding () && ( context . ibitWorkArea & emptyBitsMask ) != 0 ) { MST[rv.UOI1Mutator]MSP[] throw new IllegalArgumentException ( lr_5 + lr_6 + lr_7 ) ; } } private void validateTrailingCharacter () { if ( isStrictDecoding () ) { throw new IllegalArgumentException ( lr_5 + lr_6 +
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.AOR1Mutator]MSP[] return bigBytes ; } int startSrc = 0 ;
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ context . pos ++ ] = pad ; MST[rv.UOI3Mutator]MSP[] buffer [ context . pos ++ ] = pad ; } break;
context . ibitWorkArea = ( context . ibitWorkArea << 8 ) + b ; if ( 0 == context . modulus ) { buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 18 ) & MASK_6BITS ] ; MST[rv.OBBN2Mutator]MSP[]
final byte [] buffer = ensureBufferSize ( encodeSize , context ) ; context . modulus = ( context . modulus + 1 ) % BYTES_PER_UNENCODED_BLOCK ; MST[rv.CRCR3Mutator]MSP[] int b = in [ inPos ++ ] ; if ( b < 0 ) { b += 256 ; }
switch ( context . modulus ) { MST[rv.ABSMutator]MSP[] case 0 : break; case 1 : buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 2 ) & MASK_6BITS ] ;
for ( int i = 0 ; i < inAvail ; i ++ ) { final byte [] buffer = ensureBufferSize ( decodeSize , context ) ; MST[NonVoidMethodCallMutator]MSP[] final byte b = in [ inPos ++ ] ; if ( b == pad ) { context . eof = true ;
} public static String encodeBase64String ( final byte [] binaryData ) { return StringUtils . newStringUsAscii ( encodeBase64 ( binaryData , false ) ) ; MST[NonVoidMethodCallMutator]MSP[] } public static byte [] encodeBase64URLSafe ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false , true ) ; }
int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ; MST[rv.UOI3Mutator]MSP[]
bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ; MST[rv.UOI4Mutator]MSP[] final byte [] bigBytes = bigInt . toByteArray () ;
for ( int i = 0 ; i < arrayOctet . length ; i ++ ) { if ( ! isBase64 ( arrayOctet [ i ] ) && ! isWhiteSpace ( arrayOctet [ i ] ) ) { MST[rv.ROR5Mutator]MSP[] return false ; } } return true ; }
int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ; MST[rv.AOR1Mutator]MSP[]
int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; MST[rv.CRCR4Mutator]MSP[] len -- ; } final int startDst = bitlen / 8 - len ;
return encodeBase64 ( toIntegerBytes ( bigInteger ) , false ) ; MST[rv.CRCR6Mutator]MSP[] } @Deprecated public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { return isBase64 ( arrayOctet ) ; } public static boolean isBase64 ( final byte octet ) {
return octet >= 0 && octet < decodeTable . length && decodeTable [ octet ] != - 1 ; MST[rv.CRCR2Mutator]MSP[] } public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } private void validateCharacter ( final int emptyBitsMask , final Context context ) {
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.AOR4Mutator]MSP[] return bigBytes ; } int startSrc = 0 ;
bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ; MST[MathMutator]MSP[] final byte [] bigBytes = bigInt . toByteArray () ;
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[rv.ROR2Mutator]MSP[] } public static boolean isBase64 ( final byte [] arrayOctet ) {
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[rv.UOI1Mutator]MSP[] } public static boolean isBase64 ( final byte [] arrayOctet ) {
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[rv.ROR4Mutator]MSP[] } public static boolean isBase64 ( final byte [] arrayOctet ) {
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[rv.UOI3Mutator]MSP[] } public static boolean isBase64 ( final byte [] arrayOctet ) {
buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea >> 8 ) & MASK_8BITS ) ; MST[InlineConstantMutator]MSP[] buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea ) & MASK_8BITS ) ; break; default:
buffer [ context . pos ++ ] = encodeTable [ context . ibitWorkArea & MASK_6BITS ] ; MST[rv.OBBN3Mutator]MSP[] context . currentLinePos += BYTES_PER_ENCODED_BLOCK ; if ( lineLength > 0 && lineLength <= context . currentLinePos ) {
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; MST[rv.CRCR2Mutator]MSP[] System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; } @Override
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; MST[rv.CRCR4Mutator]MSP[] System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; } @Override
public static BigInteger decodeInteger ( final byte [] pArray ) { return new BigInteger ( 1 , decodeBase64 ( pArray ) ) ; MST[rv.CRCR5Mutator]MSP[] } public static byte [] encodeBase64 ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false ) ; }
context . ibitWorkArea = context . ibitWorkArea >> 4 ; buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea ) & MASK_8BITS ) ; break; case 3 : validateCharacter ( MASK_2BITS , context ) ; MST[rv.CRCR2Mutator]MSP[] context . ibitWorkArea = context . ibitWorkArea >> 2 ;
} public static String encodeBase64String ( final byte [] binaryData ) { return StringUtils . newStringUsAscii ( encodeBase64 ( binaryData , false ) ) ; MST[rv.CRCR6Mutator]MSP[] } public static byte [] encodeBase64URLSafe ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false , true ) ; }
case 2 : buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 10 ) & MASK_6BITS ] ; MST[rv.UOI2Mutator]MSP[] buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 4 ) & MASK_6BITS ] ;
return octet >= 0 && octet < decodeTable . length && decodeTable [ octet ] != - 1 ; } public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] } private void validateCharacter ( final int emptyBitsMask , final Context context ) {
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea << 2 ) & MASK_6BITS ] ; MST[rv.OBBN1Mutator]MSP[] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ context . pos ++ ] = pad ; } break; default:
buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea >> 8 ) & MASK_8BITS ) ; MST[rv.AOR4Mutator]MSP[] buffer [ context . pos ++ ] = (byte) ( context . ibitWorkArea & MASK_8BITS ) ; } } } }
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.AOD2Mutator]MSP[] return bigBytes ; } int startSrc = 0 ;
buffer [ context . pos ++ ] = encodeTable [ context . ibitWorkArea & MASK_6BITS ] ; MST[rv.ABSMutator]MSP[] context . currentLinePos += BYTES_PER_ENCODED_BLOCK ; if ( lineLength > 0 && lineLength <= context . currentLinePos ) {
return octet >= 0 && octet < decodeTable . length && decodeTable [ octet ] != - 1 ; MST[RemoveConditionalMutator_ORDER_IF]MSP[] } public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } private void validateCharacter ( final int emptyBitsMask , final Context context ) {
buffer [ context . pos ++ ] = encodeTable [ context . ibitWorkArea & MASK_6BITS ] ; context . currentLinePos += BYTES_PER_ENCODED_BLOCK ; if ( lineLength > 0 && lineLength <= context . currentLinePos ) { MST[rv.UOI2Mutator]MSP[]
if ( binaryData == null || binaryData . length == 0 ) { return binaryData ; } final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; MST[rv.UOI2Mutator]MSP[] final long len = b64 . getEncodedLength ( binaryData ) ;
if ( isStrictDecoding () && ( context . ibitWorkArea & emptyBitsMask ) != 0 ) { throw new IllegalArgumentException ( lr_5 + lr_6 + lr_7 ) ; } } private void validateTrailingCharacter () { if ( isStrictDecoding () ) { MST[NonVoidMethodCallMutator]MSP[] throw new IllegalArgumentException ( lr_5 + lr_6 +
int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; MST[IncrementsMutator]MSP[] } final int startDst = bitlen / 8 - len ;
context . ibitWorkArea = context . ibitWorkArea >> 4 ; buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea ) & MASK_8BITS ) ; MST[rv.OBBN3Mutator]MSP[] break; case 3 : validateCharacter ( MASK_2BITS , context ) ; context . ibitWorkArea = context . ibitWorkArea >> 2 ;
void decode ( final byte [] in , int inPos , final int inAvail , final Context context ) { if ( context . eof ) { return; } if ( inAvail < 0 ) { MST[rv.ROR2Mutator]MSP[] context . eof = true ; }
case 2 : buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 10 ) & MASK_6BITS ] ; buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 4 ) & MASK_6BITS ] ; MST[rv.UOI3Mutator]MSP[]
case 2 : buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 10 ) & MASK_6BITS ] ; MST[rv.AOR4Mutator]MSP[] buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 4 ) & MASK_6BITS ] ;
buffer [ context . pos ++ ] = encodeTable [ context . ibitWorkArea & MASK_6BITS ] ; context . currentLinePos += BYTES_PER_ENCODED_BLOCK ; if ( lineLength > 0 && lineLength <= context . currentLinePos ) { MST[rv.ROR4Mutator]MSP[]
throw new IllegalStateException ( lr_4 + context . modulus ) ; } context . currentLinePos += context . pos - savedPos ; MST[rv.AOR4Mutator]MSP[] if ( lineLength > 0 && context . currentLinePos > 0 ) {
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 12 ) & MASK_6BITS ] ; buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 6 ) & MASK_6BITS ] ; MST[rv.UOI4Mutator]MSP[]
throw new IllegalStateException ( lr_4 + context . modulus ) ; } } } @Override void encode ( final byte [] in , int inPos , final int inAvail , final Context context ) { if ( context . eof ) { MST[rv.ROR2Mutator]MSP[] return; }
throw new IllegalStateException ( lr_4 + context . modulus ) ; } context . currentLinePos += context . pos - savedPos ; if ( lineLength > 0 && context . currentLinePos > 0 ) { MST[rv.ROR5Mutator]MSP[]
throw new IllegalStateException ( lr_4 + context . modulus ) ; } context . currentLinePos += context . pos - savedPos ; if ( lineLength > 0 && context . currentLinePos > 0 ) { MST[rv.ROR4Mutator]MSP[]
if ( inAvail < 0 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[] context . eof = true ; if ( 0 == context . modulus && lineLength == 0 ) { return; } final byte [] buffer = ensureBufferSize ( encodeSize , context ) ; final int savedPos = context . pos ;
public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked ) { return encodeBase64 ( binaryData , isChunked , false ) ; MST[rv.CRCR1Mutator]MSP[] } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe ) {
public static String encodeBase64URLSafeString ( final byte [] binaryData ) { return StringUtils . newStringUsAscii ( encodeBase64 ( binaryData , false , true ) ) ; MST[rv.CRCR6Mutator]MSP[] } public static byte [] encodeInteger ( final BigInteger bigInteger ) { Objects . requireNonNull ( bigInteger , lr_3 ) ;
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[InlineConstantMutator]MSP[] return bigBytes ; } int startSrc = 0 ;
System . arraycopy ( lineSeparator , 0 , buffer , context . pos , lineSeparator . length ) ; MST[rv.CRCR5Mutator]MSP[] context . pos += lineSeparator . length ; } } else { for ( int i = 0 ; i < inAvail ; i ++ ) {
bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ; MST[rv.UOI1Mutator]MSP[] final byte [] bigBytes = bigInt . toByteArray () ;
int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ; MST[rv.ABSMutator]MSP[]
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return bigBytes ; } int startSrc = 0 ;
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[rv.ABSMutator]MSP[] } public static boolean isBase64 ( final byte [] arrayOctet ) {
for ( int i = 0 ; i < arrayOctet . length ; i ++ ) { MST[rv.CRCR3Mutator]MSP[] if ( ! isBase64 ( arrayOctet [ i ] ) && ! isWhiteSpace ( arrayOctet [ i ] ) ) { return false ; } } return true ; }
int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; MST[rv.CRCR2Mutator]MSP[] len -- ; } final int startDst = bitlen / 8 - len ;
context . ibitWorkArea = ( context . ibitWorkArea << 8 ) + b ; if ( 0 == context . modulus ) { buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 18 ) & MASK_6BITS ] ; MST[rv.CRCR3Mutator]MSP[]
if ( len > maxResultSize ) { MST[rv.UOI1Mutator]MSP[] throw new IllegalArgumentException ( lr_1 + len + lr_2 + maxResultSize ) ; } return b64 . encode ( binaryData ) ; } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { return encodeBase64 ( binaryData , true ) ;
for ( int i = 0 ; i < arrayOctet . length ; i ++ ) { if ( ! isBase64 ( arrayOctet [ i ] ) && ! isWhiteSpace ( arrayOctet [ i ] ) ) { return false ; MST[rv.CRCR6Mutator]MSP[] } } return true ; }
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 12 ) & MASK_6BITS ] ; buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 6 ) & MASK_6BITS ] ; MST[InlineConstantMutator]MSP[]
int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ; MST[rv.AOD2Mutator]MSP[]
case 2 : buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 10 ) & MASK_6BITS ] ; buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 4 ) & MASK_6BITS ] ; MST[rv.CRCR4Mutator]MSP[]
if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_1 + MST[rv.UOI1Mutator]MSP[] len + lr_2 + maxResultSize ) ; } return b64 . encode ( binaryData ) ; } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { return encodeBase64 ( binaryData , true ) ;
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[rv.CRCR2Mutator]MSP[] } public static boolean isBase64 ( final byte [] arrayOctet ) {
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.AOD1Mutator]MSP[] return bigBytes ; } int startSrc = 0 ;
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 12 ) & MASK_6BITS ] ; buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 6 ) & MASK_6BITS ] ; MST[MathMutator]MSP[]
if ( binaryData == null || binaryData . length == 0 ) { return binaryData ; } final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; MST[rv.CRCR3Mutator]MSP[] final long len = b64 . getEncodedLength ( binaryData ) ;
for ( int i = 0 ; i < arrayOctet . length ; i ++ ) { if ( ! isBase64 ( arrayOctet [ i ] ) && ! isWhiteSpace ( arrayOctet [ i ] ) ) { MST[NegateConditionalsMutator]MSP[] return false ; } } return true ; }
if ( isStrictDecoding () && ( context . ibitWorkArea & emptyBitsMask ) != 0 ) { MST[rv.OBBN3Mutator]MSP[] throw new IllegalArgumentException ( lr_5 + lr_6 + lr_7 ) ; } } private void validateTrailingCharacter () { if ( isStrictDecoding () ) { throw new IllegalArgumentException ( lr_5 + lr_6 +
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { return bigBytes ; } int startSrc = 0 ; MST[InlineConstantMutator]MSP[]
buffer [ context . pos ++ ] = encodeTable [ context . ibitWorkArea & MASK_6BITS ] ; context . currentLinePos += BYTES_PER_ENCODED_BLOCK ; MST[rv.AOD2Mutator]MSP[] if ( lineLength > 0 && lineLength <= context . currentLinePos ) {
System . arraycopy ( lineSeparator , 0 , buffer , context . pos , lineSeparator . length ) ; context . pos += lineSeparator . length ; } } else { for ( int i = 0 ; i < inAvail ; i ++ ) { MST[rv.ABSMutator]MSP[]
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.AOR2Mutator]MSP[] return bigBytes ; } int startSrc = 0 ;
if ( isStrictDecoding () && ( context . ibitWorkArea & emptyBitsMask ) != 0 ) { MST[rv.UOI2Mutator]MSP[] throw new IllegalArgumentException ( lr_5 + lr_6 + lr_7 ) ; } } private void validateTrailingCharacter () { if ( isStrictDecoding () ) { throw new IllegalArgumentException ( lr_5 + lr_6 +
break; } if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { context . modulus = ( context . modulus + 1 ) % BYTES_PER_ENCODED_BLOCK ; MST[rv.AOR1Mutator]MSP[]
throw new IllegalStateException ( lr_4 + context . modulus ) ; MST[rv.UOI3Mutator]MSP[] } } } @Override void encode ( final byte [] in , int inPos , final int inAvail , final Context context ) { if ( context . eof ) { return; }
if ( context . eof && context . modulus != 0 ) { MST[NegateConditionalsMutator]MSP[] final byte [] buffer = ensureBufferSize ( decodeSize , context ) ; switch ( context . modulus ) { case 1 : validateTrailingCharacter () ; break; case 2 : validateCharacter ( MASK_4BITS , context ) ;
for ( int i = 0 ; i < inAvail ; i ++ ) { MST[rv.ABSMutator]MSP[] final byte [] buffer = ensureBufferSize ( decodeSize , context ) ; final byte b = in [ inPos ++ ] ; if ( b == pad ) { context . eof = true ;
throw new IllegalStateException ( lr_4 + context . modulus ) ; MST[rv.ABSMutator]MSP[] } } } @Override void encode ( final byte [] in , int inPos , final int inAvail , final Context context ) { if ( context . eof ) { return; }
for ( int i = 0 ; i < inAvail ; i ++ ) { MST[rv.UOI3Mutator]MSP[] final byte [] buffer = ensureBufferSize ( decodeSize , context ) ; final byte b = in [ inPos ++ ] ; if ( b == pad ) { context . eof = true ;
case 2 : buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 10 ) & MASK_6BITS ] ; MST[rv.CRCR3Mutator]MSP[] buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 4 ) & MASK_6BITS ] ;
final byte [] buffer = ensureBufferSize ( encodeSize , context ) ; context . modulus = ( context . modulus + 1 ) % BYTES_PER_UNENCODED_BLOCK ; MST[rv.CRCR5Mutator]MSP[] int b = in [ inPos ++ ] ; if ( b < 0 ) { b += 256 ; }
if ( inAvail < 0 ) { MST[rv.UOI1Mutator]MSP[] context . eof = true ; if ( 0 == context . modulus && lineLength == 0 ) { return; } final byte [] buffer = ensureBufferSize ( encodeSize , context ) ; final int savedPos = context . pos ;
switch ( context . modulus ) { case 0 : break; case 1 : buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 2 ) & MASK_6BITS ] ; MST[MathMutator]MSP[]
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.CRCR3Mutator]MSP[] return bigBytes ; } int startSrc = 0 ;
for ( int i = 0 ; i < arrayOctet . length ; i ++ ) { if ( ! isBase64 ( arrayOctet [ i ] ) && ! isWhiteSpace ( arrayOctet [ i ] ) ) { MST[rv.UOI1Mutator]MSP[] return false ; } } return true ; }
if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_1 + MST[NonVoidMethodCallMutator]MSP[] len + lr_2 + maxResultSize ) ; } return b64 . encode ( binaryData ) ; } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { return encodeBase64 ( binaryData , true ) ;
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; MST[rv.UOI4Mutator]MSP[] return resizedBytes ; } @Override
for ( int i = 0 ; i < arrayOctet . length ; i ++ ) { MST[rv.UOI4Mutator]MSP[] if ( ! isBase64 ( arrayOctet [ i ] ) && ! isWhiteSpace ( arrayOctet [ i ] ) ) { return false ; } } return true ; }
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[rv.ROR4Mutator]MSP[] } public static boolean isBase64 ( final byte [] arrayOctet ) {
return octet >= 0 && octet < decodeTable . length && decodeTable [ octet ] != - 1 ; MST[ConditionalsBoundaryMutator]MSP[] } public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } private void validateCharacter ( final int emptyBitsMask , final Context context ) {
bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ; MST[MathMutator]MSP[] final byte [] bigBytes = bigInt . toByteArray () ;
public static boolean isBase64 ( final String base64 ) { return isBase64 ( StringUtils . getBytesUtf8 ( base64 ) ) ; MST[BooleanTrueReturnValsMutator]MSP[] } static byte [] toIntegerBytes ( final BigInteger bigInt ) { int bitlen = bigInt . bitLength () ;
public static byte [] decodeBase64 ( final byte [] base64Data ) { return new Base64 () . decode ( base64Data ) ; MST[ArgumentPropagationMutator]MSP[] } public static byte [] decodeBase64 ( final String base64String ) { return new Base64 () . decode ( base64String ) ; }
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[rv.UOI4Mutator]MSP[] } public static boolean isBase64 ( final byte [] arrayOctet ) {
return encodeBase64 ( toIntegerBytes ( bigInteger ) , false ) ; MST[ArgumentPropagationMutator]MSP[] } @Deprecated public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { return isBase64 ( arrayOctet ) ; } public static boolean isBase64 ( final byte octet ) {
buffer [ context . pos ++ ] = encodeTable [ context . ibitWorkArea & MASK_6BITS ] ; MST[rv.OBBN2Mutator]MSP[] context . currentLinePos += BYTES_PER_ENCODED_BLOCK ; if ( lineLength > 0 && lineLength <= context . currentLinePos ) {
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.CRCR2Mutator]MSP[] return bigBytes ; } int startSrc = 0 ;
throw new IllegalStateException ( lr_4 + context . modulus ) ; } context . currentLinePos += context . pos - savedPos ; if ( lineLength > 0 && context . currentLinePos > 0 ) { MST[rv.ROR1Mutator]MSP[]
public static BigInteger decodeInteger ( final byte [] pArray ) { return new BigInteger ( 1 , decodeBase64 ( pArray ) ) ; MST[NonVoidMethodCallMutator]MSP[] } public static byte [] encodeBase64 ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false ) ; }
return octet >= 0 && octet < decodeTable . length && decodeTable [ octet ] != - 1 ; } public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; MST[InlineConstantMutator]MSP[] } private void validateCharacter ( final int emptyBitsMask , final Context context ) {
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[InlineConstantMutator]MSP[] } public static boolean isBase64 ( final byte [] arrayOctet ) {
for ( int i = 0 ; i < arrayOctet . length ; i ++ ) { if ( ! isBase64 ( arrayOctet [ i ] ) && ! isWhiteSpace ( arrayOctet [ i ] ) ) { return false ; } } return true ; MST[rv.CRCR6Mutator]MSP[] }
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea << 2 ) & MASK_6BITS ] ; MST[InlineConstantMutator]MSP[] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ context . pos ++ ] = pad ; } break; default:
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[MathMutator]MSP[] return bigBytes ; } int startSrc = 0 ;
return encodeBase64 ( toIntegerBytes ( bigInteger ) , false ) ; MST[NullReturnValsMutator]MSP[] } @Deprecated public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { return isBase64 ( arrayOctet ) ; } public static boolean isBase64 ( final byte octet ) {
if ( binaryData == null || binaryData . length == 0 ) { return binaryData ; } final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; MST[ConstructorCallMutator]MSP[] final long len = b64 . getEncodedLength ( binaryData ) ;
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { return bigBytes ; } int startSrc = 0 ; MST[rv.CRCR3Mutator]MSP[]
throw new IllegalStateException ( lr_4 + context . modulus ) ; MST[NonVoidMethodCallMutator]MSP[] } context . currentLinePos += context . pos - savedPos ; if ( lineLength > 0 && context . currentLinePos > 0 ) {
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[rv.UOI1Mutator]MSP[] } public static boolean isBase64 ( final byte [] arrayOctet ) {
for ( int i = 0 ; i < inAvail ; i ++ ) { final byte [] buffer = ensureBufferSize ( decodeSize , context ) ; final byte b = in [ inPos ++ ] ; MST[IncrementsMutator]MSP[] if ( b == pad ) { context . eof = true ;
switch ( context . modulus ) { case 0 : break; case 1 : buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 2 ) & MASK_6BITS ] ; MST[rv.AOR1Mutator]MSP[]
bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ; MST[rv.CRCR6Mutator]MSP[] final byte [] bigBytes = bigInt . toByteArray () ;
final byte [] buffer = ensureBufferSize ( encodeSize , context ) ; context . modulus = ( context . modulus + 1 ) % BYTES_PER_UNENCODED_BLOCK ; MST[rv.AOD1Mutator]MSP[] int b = in [ inPos ++ ] ; if ( b < 0 ) { b += 256 ; }
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.AOD2Mutator]MSP[] return bigBytes ; } int startSrc = 0 ;
if ( isStrictDecoding () && ( context . ibitWorkArea & emptyBitsMask ) != 0 ) { MST[NegateConditionalsMutator]MSP[] throw new IllegalArgumentException ( lr_5 + lr_6 + lr_7 ) ; } } private void validateTrailingCharacter () { if ( isStrictDecoding () ) { throw new IllegalArgumentException ( lr_5 + lr_6 +
buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea >> 8 ) & MASK_8BITS ) ; buffer [ context . pos ++ ] = (byte) ( context . ibitWorkArea & MASK_8BITS ) ; MST[rv.ABSMutator]MSP[] } } } }
return octet >= 0 && octet < decodeTable . length && decodeTable [ octet ] != - 1 ; MST[rv.CRCR4Mutator]MSP[] } public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } private void validateCharacter ( final int emptyBitsMask , final Context context ) {
return octet >= 0 && octet < decodeTable . length && decodeTable [ octet ] != - 1 ; MST[rv.UOI4Mutator]MSP[] } public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } private void validateCharacter ( final int emptyBitsMask , final Context context ) {
return octet >= 0 && octet < decodeTable . length && decodeTable [ octet ] != - 1 ; } public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; MST[BooleanTrueReturnValsMutator]MSP[] } private void validateCharacter ( final int emptyBitsMask , final Context context ) {
return octet >= 0 && octet < decodeTable . length && decodeTable [ octet ] != - 1 ; MST[rv.CRCR6Mutator]MSP[] } public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } private void validateCharacter ( final int emptyBitsMask , final Context context ) {
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.UOI4Mutator]MSP[] return bigBytes ; } int startSrc = 0 ;
bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ; MST[rv.CRCR3Mutator]MSP[] final byte [] bigBytes = bigInt . toByteArray () ;
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 12 ) & MASK_6BITS ] ; buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 6 ) & MASK_6BITS ] ; MST[rv.AOD1Mutator]MSP[]
context . ibitWorkArea = ( context . ibitWorkArea << BITS_PER_ENCODED_BYTE ) + result ; if ( context . modulus == 0 ) { MST[NegateConditionalsMutator]MSP[] buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea >> 16 ) & MASK_8BITS ) ;
int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ; MST[rv.CRCR5Mutator]MSP[]
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 12 ) & MASK_6BITS ] ; buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 6 ) & MASK_6BITS ] ; MST[rv.UOI1Mutator]MSP[]
throw new IllegalStateException ( lr_4 + context . modulus ) ; MST[NonVoidMethodCallMutator]MSP[] } } } @Override void encode ( final byte [] in , int inPos , final int inAvail , final Context context ) { if ( context . eof ) { return; }
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[rv.CRCR5Mutator]MSP[] } public static boolean isBase64 ( final byte [] arrayOctet ) {
return octet >= 0 && octet < decodeTable . length && decodeTable [ octet ] != - 1 ; MST[rv.ROR1Mutator]MSP[] } public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } private void validateCharacter ( final int emptyBitsMask , final Context context ) {
return encodeBase64 ( binaryData , isChunked , urlSafe , Integer . MAX_VALUE ) ; MST[ArgumentPropagationMutator]MSP[] } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe , final int maxResultSize ) {
for ( int i = 0 ; i < arrayOctet . length ; i ++ ) { if ( ! isBase64 ( arrayOctet [ i ] ) && ! isWhiteSpace ( arrayOctet [ i ] ) ) { MST[rv.ROR4Mutator]MSP[] return false ; } } return true ; }
if ( inAvail < 0 ) { context . eof = true ; if ( 0 == context . modulus && lineLength == 0 ) { MST[rv.UOI3Mutator]MSP[] return; } final byte [] buffer = ensureBufferSize ( encodeSize , context ) ; final int savedPos = context . pos ;
int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ; MST[rv.UOI1Mutator]MSP[]
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.CRCR1Mutator]MSP[] return bigBytes ; } int startSrc = 0 ;
for ( int i = 0 ; i < arrayOctet . length ; i ++ ) { MST[ConditionalsBoundaryMutator]MSP[] if ( ! isBase64 ( arrayOctet [ i ] ) && ! isWhiteSpace ( arrayOctet [ i ] ) ) { return false ; } } return true ; }
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.AOR4Mutator]MSP[] return bigBytes ; } int startSrc = 0 ;
if ( isStrictDecoding () && ( context . ibitWorkArea & emptyBitsMask ) != 0 ) { MST[rv.UOI3Mutator]MSP[] throw new IllegalArgumentException ( lr_5 + lr_6 + lr_7 ) ; } } private void validateTrailingCharacter () { if ( isStrictDecoding () ) { throw new IllegalArgumentException ( lr_5 + lr_6 +
for ( int i = 0 ; i < arrayOctet . length ; i ++ ) { if ( ! isBase64 ( arrayOctet [ i ] ) && ! isWhiteSpace ( arrayOctet [ i ] ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return false ; } } return true ; }
buffer [ context . pos ++ ] = encodeTable [ context . ibitWorkArea & MASK_6BITS ] ; context . currentLinePos += BYTES_PER_ENCODED_BLOCK ; if ( lineLength > 0 && lineLength <= context . currentLinePos ) { MST[rv.UOI4Mutator]MSP[]
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { return bigBytes ; MST[ReturnValsMutator]MSP[] } int startSrc = 0 ;
if ( isStrictDecoding () && ( context . ibitWorkArea & emptyBitsMask ) != 0 ) { throw new IllegalArgumentException ( lr_5 + lr_6 + lr_7 ) ; } } private void validateTrailingCharacter () { if ( isStrictDecoding () ) { MST[rv.ROR4Mutator]MSP[] throw new IllegalArgumentException ( lr_5 + lr_6 +
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[rv.ROR1Mutator]MSP[] } public static boolean isBase64 ( final byte [] arrayOctet ) {
case 2 : buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 10 ) & MASK_6BITS ] ; MST[rv.CRCR5Mutator]MSP[] buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 4 ) & MASK_6BITS ] ;
for ( int i = 0 ; i < inAvail ; i ++ ) { final byte [] buffer = ensureBufferSize ( decodeSize , context ) ; final byte b = in [ inPos ++ ] ; if ( b == pad ) { MST[rv.UOI3Mutator]MSP[] context . eof = true ;
for ( int i = 0 ; i < inAvail ; i ++ ) { final byte [] buffer = ensureBufferSize ( decodeSize , context ) ; final byte b = in [ inPos ++ ] ; MST[rv.UOI4Mutator]MSP[] if ( b == pad ) { context . eof = true ;
for ( int i = 0 ; i < arrayOctet . length ; i ++ ) { if ( ! isBase64 ( arrayOctet [ i ] ) && ! isWhiteSpace ( arrayOctet [ i ] ) ) { MST[rv.UOI1Mutator]MSP[] return false ; } } return true ; }
case 2 : buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 10 ) & MASK_6BITS ] ; buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 4 ) & MASK_6BITS ] ; MST[rv.ABSMutator]MSP[]
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.AOR2Mutator]MSP[] return bigBytes ; } int startSrc = 0 ;
if ( binaryData == null || binaryData . length == 0 ) { return binaryData ; } final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; MST[rv.UOI1Mutator]MSP[] final long len = b64 . getEncodedLength ( binaryData ) ;
return octet >= 0 && octet < decodeTable . length && decodeTable [ octet ] != - 1 ; } public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; MST[rv.CRCR5Mutator]MSP[] } private void validateCharacter ( final int emptyBitsMask , final Context context ) {
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[rv.UOI2Mutator]MSP[] } public static boolean isBase64 ( final byte [] arrayOctet ) {
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[rv.UOI3Mutator]MSP[] } public static boolean isBase64 ( final byte [] arrayOctet ) {
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.AOR1Mutator]MSP[] return bigBytes ; } int startSrc = 0 ;
public static byte [] decodeBase64 ( final byte [] base64Data ) { return new Base64 () . decode ( base64Data ) ; } public static byte [] decodeBase64 ( final String base64String ) { return new Base64 () . decode ( base64String ) ; MST[NonVoidMethodCallMutator]MSP[] }
return encodeBase64 ( binaryData , isChunked , urlSafe , Integer . MAX_VALUE ) ; MST[rv.CRCR2Mutator]MSP[] } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe , final int maxResultSize ) {
buffer [ context . pos ++ ] = encodeTable [ context . ibitWorkArea & MASK_6BITS ] ; context . currentLinePos += BYTES_PER_ENCODED_BLOCK ; if ( lineLength > 0 && lineLength <= context . currentLinePos ) { MST[rv.UOI1Mutator]MSP[]
throw new IllegalStateException ( lr_4 + context . modulus ) ; MST[rv.UOI2Mutator]MSP[] } } } @Override void encode ( final byte [] in , int inPos , final int inAvail , final Context context ) { if ( context . eof ) { return; }
case 2 : buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 10 ) & MASK_6BITS ] ; buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 4 ) & MASK_6BITS ] ; MST[rv.CRCR3Mutator]MSP[]
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea << 4 ) & MASK_6BITS ] ; MST[InlineConstantMutator]MSP[] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ context . pos ++ ] = pad ; buffer [ context . pos ++ ] = pad ; } break;
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.ROR5Mutator]MSP[] return bigBytes ; } int startSrc = 0 ;
for ( int i = 0 ; i < inAvail ; i ++ ) { MST[rv.UOI2Mutator]MSP[] final byte [] buffer = ensureBufferSize ( decodeSize , context ) ; final byte b = in [ inPos ++ ] ; if ( b == pad ) { context . eof = true ;
for ( int i = 0 ; i < inAvail ; i ++ ) { MST[rv.ROR2Mutator]MSP[] final byte [] buffer = ensureBufferSize ( decodeSize , context ) ; final byte b = in [ inPos ++ ] ; if ( b == pad ) { context . eof = true ;
return octet >= 0 && octet < decodeTable . length && decodeTable [ octet ] != - 1 ; } public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] } private void validateCharacter ( final int emptyBitsMask , final Context context ) {
return encodeBase64 ( binaryData , isChunked , urlSafe , Integer . MAX_VALUE ) ; MST[rv.UOI2Mutator]MSP[] } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe , final int maxResultSize ) {
public static String encodeBase64URLSafeString ( final byte [] binaryData ) { return StringUtils . newStringUsAscii ( encodeBase64 ( binaryData , false , true ) ) ; MST[rv.CRCR4Mutator]MSP[] } public static byte [] encodeInteger ( final BigInteger bigInteger ) { Objects . requireNonNull ( bigInteger , lr_3 ) ;
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; MST[rv.AOD1Mutator]MSP[] System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; } @Override
if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_1 + MST[NonVoidMethodCallMutator]MSP[] len + lr_2 + maxResultSize ) ; } return b64 . encode ( binaryData ) ; } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { return encodeBase64 ( binaryData , true ) ;
for ( int i = 0 ; i < arrayOctet . length ; i ++ ) { MST[rv.CRCR1Mutator]MSP[] if ( ! isBase64 ( arrayOctet [ i ] ) && ! isWhiteSpace ( arrayOctet [ i ] ) ) { return false ; } } return true ; }
return octet >= 0 && octet < decodeTable . length && decodeTable [ octet ] != - 1 ; MST[rv.UOI1Mutator]MSP[] } public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } private void validateCharacter ( final int emptyBitsMask , final Context context ) {
return octet >= 0 && octet < decodeTable . length && decodeTable [ octet ] != - 1 ; } public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; MST[InlineConstantMutator]MSP[] } private void validateCharacter ( final int emptyBitsMask , final Context context ) {
context . ibitWorkArea = ( context . ibitWorkArea << BITS_PER_ENCODED_BYTE ) + result ; if ( context . modulus == 0 ) { buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea >> 16 ) & MASK_8BITS ) ; MST[rv.ABSMutator]MSP[]
return encodeBase64 ( toIntegerBytes ( bigInteger ) , false ) ; } @Deprecated public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { return isBase64 ( arrayOctet ) ; MST[BooleanTrueReturnValsMutator]MSP[] } public static boolean isBase64 ( final byte octet ) {
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ context . pos ++ ] = pad ; MST[rv.UOI1Mutator]MSP[] } break; default:
break; } if ( b >= 0 && b < DECODE_TABLE . length ) { MST[rv.UOI1Mutator]MSP[] final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { context . modulus = ( context . modulus + 1 ) % BYTES_PER_ENCODED_BLOCK ;
return encodeBase64 ( toIntegerBytes ( bigInteger ) , false ) ; MST[rv.CRCR1Mutator]MSP[] } @Deprecated public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { return isBase64 ( arrayOctet ) ; } public static boolean isBase64 ( final byte octet ) {
throw new IllegalStateException ( lr_4 + context . modulus ) ; MST[rv.UOI2Mutator]MSP[] } context . currentLinePos += context . pos - savedPos ; if ( lineLength > 0 && context . currentLinePos > 0 ) {
System . arraycopy ( lineSeparator , 0 , buffer , context . pos , lineSeparator . length ) ; context . pos += lineSeparator . length ; } } else { for ( int i = 0 ; i < inAvail ; i ++ ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[]
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[InlineConstantMutator]MSP[] } public static boolean isBase64 ( final byte [] arrayOctet ) {
switch ( context . modulus ) { case 0 : break; case 1 : buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 2 ) & MASK_6BITS ] ; MST[MathMutator]MSP[]
if ( binaryData == null || binaryData . length == 0 ) { return binaryData ; } final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; MST[rv.ROR2Mutator]MSP[] final long len = b64 . getEncodedLength ( binaryData ) ;
if ( binaryData == null || binaryData . length == 0 ) { return binaryData ; } final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; MST[rv.UOI4Mutator]MSP[] final long len = b64 . getEncodedLength ( binaryData ) ;
void decode ( final byte [] in , int inPos , final int inAvail , final Context context ) { if ( context . eof ) { return; } if ( inAvail < 0 ) { MST[rv.ROR4Mutator]MSP[] context . eof = true ; }
return octet >= 0 && octet < decodeTable . length && decodeTable [ octet ] != - 1 ; MST[ConditionalsBoundaryMutator]MSP[] } public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } private void validateCharacter ( final int emptyBitsMask , final Context context ) {
buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea >> 8 ) & MASK_8BITS ) ; MST[rv.CRCR5Mutator]MSP[] buffer [ context . pos ++ ] = (byte) ( context . ibitWorkArea & MASK_8BITS ) ; } } } }
buffer [ context . pos ++ ] = encodeTable [ context . ibitWorkArea & MASK_6BITS ] ; context . currentLinePos += BYTES_PER_ENCODED_BLOCK ; if ( lineLength > 0 && lineLength <= context . currentLinePos ) { MST[rv.UOI3Mutator]MSP[]
throw new IllegalStateException ( lr_4 + context . modulus ) ; MST[NonVoidMethodCallMutator]MSP[] } context . currentLinePos += context . pos - savedPos ; if ( lineLength > 0 && context . currentLinePos > 0 ) {
bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ; MST[rv.CRCR6Mutator]MSP[] final byte [] bigBytes = bigInt . toByteArray () ;
switch ( context . modulus ) { case 0 : break; case 1 : buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 2 ) & MASK_6BITS ] ; MST[rv.ABSMutator]MSP[]
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.UOI1Mutator]MSP[] return bigBytes ; } int startSrc = 0 ;
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[NegateConditionalsMutator]MSP[] return bigBytes ; } int startSrc = 0 ;
throw new IllegalStateException ( lr_4 + context . modulus ) ; } context . currentLinePos += context . pos - savedPos ; if ( lineLength > 0 && context . currentLinePos > 0 ) { MST[rv.UOI3Mutator]MSP[]
if ( binaryData == null || binaryData . length == 0 ) { return binaryData ; } final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; final long len = b64 . getEncodedLength ( binaryData ) ; MST[NonVoidMethodCallMutator]MSP[]
context . ibitWorkArea = context . ibitWorkArea >> 4 ; buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea ) & MASK_8BITS ) ; break; case 3 : validateCharacter ( MASK_2BITS , context ) ; context . ibitWorkArea = context . ibitWorkArea >> 2 ; MST[rv.CRCR6Mutator]MSP[]
break; } if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { context . modulus = ( context . modulus + 1 ) % BYTES_PER_ENCODED_BLOCK ; MST[rv.AOR3Mutator]MSP[]
if ( len > maxResultSize ) { MST[rv.ROR3Mutator]MSP[] throw new IllegalArgumentException ( lr_1 + len + lr_2 + maxResultSize ) ; } return b64 . encode ( binaryData ) ; } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { return encodeBase64 ( binaryData , true ) ;
for ( int i = 0 ; i < inAvail ; i ++ ) { final byte [] buffer = ensureBufferSize ( decodeSize , context ) ; final byte b = in [ inPos ++ ] ; if ( b == pad ) { context . eof = true ; MST[rv.CRCR5Mutator]MSP[]
case 2 : buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 10 ) & MASK_6BITS ] ; buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 4 ) & MASK_6BITS ] ; MST[rv.OBBN2Mutator]MSP[]
System . arraycopy ( lineSeparator , 0 , buffer , context . pos , lineSeparator . length ) ; MST[rv.ABSMutator]MSP[] context . pos += lineSeparator . length ; } } else { for ( int i = 0 ; i < inAvail ; i ++ ) {
final byte [] buffer = ensureBufferSize ( encodeSize , context ) ; context . modulus = ( context . modulus + 1 ) % BYTES_PER_UNENCODED_BLOCK ; MST[rv.CRCR2Mutator]MSP[] int b = in [ inPos ++ ] ; if ( b < 0 ) { b += 256 ; }
buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea >> 8 ) & MASK_8BITS ) ; MST[rv.UOI2Mutator]MSP[] buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea ) & MASK_8BITS ) ; break; default:
context . ibitWorkArea = ( context . ibitWorkArea << 8 ) + b ; MST[rv.UOI3Mutator]MSP[] if ( 0 == context . modulus ) { buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 18 ) & MASK_6BITS ] ;
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ context . pos ++ ] = pad ; buffer [ context . pos ++ ] = pad ; MST[rv.CRCR4Mutator]MSP[] } break;
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 12 ) & MASK_6BITS ] ; buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 6 ) & MASK_6BITS ] ; MST[InlineConstantMutator]MSP[]
case 2 : buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 10 ) & MASK_6BITS ] ; MST[rv.UOI3Mutator]MSP[] buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 4 ) & MASK_6BITS ] ;
context . ibitWorkArea = context . ibitWorkArea >> 4 ; buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea ) & MASK_8BITS ) ; MST[rv.CRCR1Mutator]MSP[] break; case 3 : validateCharacter ( MASK_2BITS , context ) ; context . ibitWorkArea = context . ibitWorkArea >> 2 ;
if ( inAvail < 0 ) { context . eof = true ; if ( 0 == context . modulus && lineLength == 0 ) { MST[rv.ABSMutator]MSP[] return; } final byte [] buffer = ensureBufferSize ( encodeSize , context ) ; final int savedPos = context . pos ;
int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ; MST[rv.AOR1Mutator]MSP[]
System . arraycopy ( lineSeparator , 0 , buffer , context . pos , lineSeparator . length ) ; context . pos += lineSeparator . length ; } } else { for ( int i = 0 ; i < inAvail ; i ++ ) { MST[rv.ROR4Mutator]MSP[]
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; MST[rv.ABSMutator]MSP[] System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; } @Override
if ( inAvail < 0 ) { context . eof = true ; if ( 0 == context . modulus && lineLength == 0 ) { MST[rv.ROR5Mutator]MSP[] return; } final byte [] buffer = ensureBufferSize ( encodeSize , context ) ; final int savedPos = context . pos ;
bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ; MST[rv.AOR2Mutator]MSP[] final byte [] bigBytes = bigInt . toByteArray () ;
int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ; MST[rv.AOR3Mutator]MSP[]
if ( inAvail < 0 ) { context . eof = true ; if ( 0 == context . modulus && lineLength == 0 ) { MST[rv.UOI4Mutator]MSP[] return; } final byte [] buffer = ensureBufferSize ( encodeSize , context ) ; final int savedPos = context . pos ;
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ context . pos ++ ] = pad ; MST[rv.CRCR4Mutator]MSP[] } break; default:
final byte [] buffer = ensureBufferSize ( encodeSize , context ) ; context . modulus = ( context . modulus + 1 ) % BYTES_PER_UNENCODED_BLOCK ; MST[InlineConstantMutator]MSP[] int b = in [ inPos ++ ] ; if ( b < 0 ) { b += 256 ; }
buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea >> 8 ) & MASK_8BITS ) ; MST[rv.CRCR6Mutator]MSP[] buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea ) & MASK_8BITS ) ; break; default:
break; } if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { context . modulus = ( context . modulus + 1 ) % BYTES_PER_ENCODED_BLOCK ; MST[rv.UOI2Mutator]MSP[]
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea << 2 ) & MASK_6BITS ] ; MST[rv.OBBN3Mutator]MSP[] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ context . pos ++ ] = pad ; } break; default:
public static BigInteger decodeInteger ( final byte [] pArray ) { return new BigInteger ( 1 , decodeBase64 ( pArray ) ) ; } public static byte [] encodeBase64 ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false ) ; MST[rv.CRCR1Mutator]MSP[] }
if ( inAvail < 0 ) { context . eof = true ; if ( 0 == context . modulus && lineLength == 0 ) { return; } final byte [] buffer = ensureBufferSize ( encodeSize , context ) ; final int savedPos = context . pos ; MST[rv.UOI4Mutator]MSP[]
if ( isStrictDecoding () && ( context . ibitWorkArea & emptyBitsMask ) != 0 ) { MST[rv.ROR1Mutator]MSP[] throw new IllegalArgumentException ( lr_5 + lr_6 + lr_7 ) ; } } private void validateTrailingCharacter () { if ( isStrictDecoding () ) { throw new IllegalArgumentException ( lr_5 + lr_6 +
buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea >> 8 ) & MASK_8BITS ) ; buffer [ context . pos ++ ] = (byte) ( context . ibitWorkArea & MASK_8BITS ) ; MST[MathMutator]MSP[] } } } }
buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea >> 8 ) & MASK_8BITS ) ; buffer [ context . pos ++ ] = (byte) ( context . ibitWorkArea & MASK_8BITS ) ; MST[experimental.MemberVariableMutator]MSP[] } } } }
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ context . pos ++ ] = pad ; buffer [ context . pos ++ ] = pad ; MST[rv.UOI3Mutator]MSP[] } break;
public static BigInteger decodeInteger ( final byte [] pArray ) { return new BigInteger ( 1 , decodeBase64 ( pArray ) ) ; } public static byte [] encodeBase64 ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false ) ; MST[ReturnValsMutator]MSP[] }
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[rv.CRCR5Mutator]MSP[] } public static boolean isBase64 ( final byte [] arrayOctet ) {
context . ibitWorkArea = ( context . ibitWorkArea << 8 ) + b ; if ( 0 == context . modulus ) { MST[rv.UOI1Mutator]MSP[] buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 18 ) & MASK_6BITS ] ;
if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_1 + MST[rv.UOI3Mutator]MSP[] len + lr_2 + maxResultSize ) ; } return b64 . encode ( binaryData ) ; } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { return encodeBase64 ( binaryData , true ) ;
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[rv.CRCR4Mutator]MSP[] } public static boolean isBase64 ( final byte [] arrayOctet ) {
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ context . pos ++ ] = pad ; MST[rv.UOI3Mutator]MSP[] } break; default:
buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea >> 8 ) & MASK_8BITS ) ; MST[rv.CRCR1Mutator]MSP[] buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea ) & MASK_8BITS ) ; break; default:
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; MST[rv.UOI1Mutator]MSP[] return resizedBytes ; } @Override
final byte [] buffer = ensureBufferSize ( encodeSize , context ) ; context . modulus = ( context . modulus + 1 ) % BYTES_PER_UNENCODED_BLOCK ; MST[rv.AOR1Mutator]MSP[] int b = in [ inPos ++ ] ; if ( b < 0 ) { b += 256 ; }
if ( binaryData == null || binaryData . length == 0 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return binaryData ; } final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; final long len = b64 . getEncodedLength ( binaryData ) ;
if ( isStrictDecoding () && ( context . ibitWorkArea & emptyBitsMask ) != 0 ) { MST[rv.UOI4Mutator]MSP[] throw new IllegalArgumentException ( lr_5 + lr_6 + lr_7 ) ; } } private void validateTrailingCharacter () { if ( isStrictDecoding () ) { throw new IllegalArgumentException ( lr_5 + lr_6 +
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.AOR3Mutator]MSP[] return bigBytes ; } int startSrc = 0 ;
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; MST[rv.UOI2Mutator]MSP[] return resizedBytes ; } @Override
public static BigInteger decodeInteger ( final byte [] pArray ) { return new BigInteger ( 1 , decodeBase64 ( pArray ) ) ; } public static byte [] encodeBase64 ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false ) ; MST[NullReturnValsMutator]MSP[] }
public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked ) { return encodeBase64 ( binaryData , isChunked , false ) ; MST[rv.CRCR5Mutator]MSP[] } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe ) {
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea << 4 ) & MASK_6BITS ] ; MST[rv.CRCR4Mutator]MSP[] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ context . pos ++ ] = pad ; buffer [ context . pos ++ ] = pad ; } break;
switch ( context . modulus ) { case 0 : break; case 1 : buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 2 ) & MASK_6BITS ] ; MST[rv.UOI4Mutator]MSP[]
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[rv.ROR1Mutator]MSP[] } public static boolean isBase64 ( final byte [] arrayOctet ) {
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[rv.ROR4Mutator]MSP[] } public static boolean isBase64 ( final byte [] arrayOctet ) {
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.CRCR6Mutator]MSP[] return bigBytes ; } int startSrc = 0 ;
int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { MST[rv.AOR2Mutator]MSP[] startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
case 2 : buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 10 ) & MASK_6BITS ] ; MST[rv.OBBN1Mutator]MSP[] buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 4 ) & MASK_6BITS ] ;
for ( int i = 0 ; i < arrayOctet . length ; i ++ ) { if ( ! isBase64 ( arrayOctet [ i ] ) && ! isWhiteSpace ( arrayOctet [ i ] ) ) { MST[rv.ABSMutator]MSP[] return false ; } } return true ; }
return encodeBase64 ( binaryData , isChunked , urlSafe , Integer . MAX_VALUE ) ; MST[NonVoidMethodCallMutator]MSP[] } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe , final int maxResultSize ) {
if ( binaryData == null || binaryData . length == 0 ) { return binaryData ; } final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; MST[rv.UOI1Mutator]MSP[] final long len = b64 . getEncodedLength ( binaryData ) ;
buffer [ context . pos ++ ] = encodeTable [ context . ibitWorkArea & MASK_6BITS ] ; context . currentLinePos += BYTES_PER_ENCODED_BLOCK ; MST[rv.UOI2Mutator]MSP[] if ( lineLength > 0 && lineLength <= context . currentLinePos ) {
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; MST[rv.UOI4Mutator]MSP[] System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; } @Override
System . arraycopy ( lineSeparator , 0 , buffer , context . pos , lineSeparator . length ) ; MST[InlineConstantMutator]MSP[] context . pos += lineSeparator . length ; } } else { for ( int i = 0 ; i < inAvail ; i ++ ) {
for ( int i = 0 ; i < arrayOctet . length ; i ++ ) { if ( ! isBase64 ( arrayOctet [ i ] ) && ! isWhiteSpace ( arrayOctet [ i ] ) ) { MST[rv.UOI4Mutator]MSP[] return false ; } } return true ; }
for ( int i = 0 ; i < arrayOctet . length ; i ++ ) { if ( ! isBase64 ( arrayOctet [ i ] ) && ! isWhiteSpace ( arrayOctet [ i ] ) ) { MST[rv.ROR1Mutator]MSP[] return false ; } } return true ; }
public static String encodeBase64URLSafeString ( final byte [] binaryData ) { return StringUtils . newStringUsAscii ( encodeBase64 ( binaryData , false , true ) ) ; MST[InlineConstantMutator]MSP[] } public static byte [] encodeInteger ( final BigInteger bigInteger ) { Objects . requireNonNull ( bigInteger , lr_3 ) ;
if ( binaryData == null || binaryData . length == 0 ) { return binaryData ; } final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; MST[ConstructorCallMutator]MSP[] final long len = b64 . getEncodedLength ( binaryData ) ;
switch ( context . modulus ) { case 0 : break; case 1 : buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 2 ) & MASK_6BITS ] ; MST[rv.CRCR3Mutator]MSP[]
return octet >= 0 && octet < decodeTable . length && decodeTable [ octet ] != - 1 ; } public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; MST[rv.CRCR5Mutator]MSP[] } private void validateCharacter ( final int emptyBitsMask , final Context context ) {
buffer [ context . pos ++ ] = encodeTable [ context . ibitWorkArea & MASK_6BITS ] ; context . currentLinePos += BYTES_PER_ENCODED_BLOCK ; if ( lineLength > 0 && lineLength <= context . currentLinePos ) { MST[rv.ROR1Mutator]MSP[]
public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked ) { return encodeBase64 ( binaryData , isChunked , false ) ; MST[ArgumentPropagationMutator]MSP[] } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe ) {
int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ; MST[InlineConstantMutator]MSP[]
int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; MST[experimental.RemoveIncrementsMutator]MSP[] } final int startDst = bitlen / 8 - len ;
if ( len > maxResultSize ) { MST[rv.UOI4Mutator]MSP[] throw new IllegalArgumentException ( lr_1 + len + lr_2 + maxResultSize ) ; } return b64 . encode ( binaryData ) ; } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { return encodeBase64 ( binaryData , true ) ;
switch ( context . modulus ) { case 0 : break; case 1 : buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 2 ) & MASK_6BITS ] ; MST[rv.ABSMutator]MSP[]
for ( int i = 0 ; i < inAvail ; i ++ ) { MST[rv.UOI1Mutator]MSP[] final byte [] buffer = ensureBufferSize ( decodeSize , context ) ; final byte b = in [ inPos ++ ] ; if ( b == pad ) { context . eof = true ;
return octet >= 0 && octet < decodeTable . length && decodeTable [ octet ] != - 1 ; MST[rv.ABSMutator]MSP[] } public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } private void validateCharacter ( final int emptyBitsMask , final Context context ) {
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; MST[rv.CRCR1Mutator]MSP[] System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; } @Override
if ( binaryData == null || binaryData . length == 0 ) { return binaryData ; } final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] final long len = b64 . getEncodedLength ( binaryData ) ;
public static BigInteger decodeInteger ( final byte [] pArray ) { return new BigInteger ( 1 , decodeBase64 ( pArray ) ) ; MST[rv.CRCR4Mutator]MSP[] } public static byte [] encodeBase64 ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false ) ; }
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[InlineConstantMutator]MSP[] return bigBytes ; } int startSrc = 0 ;
int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { MST[rv.ROR5Mutator]MSP[] startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
return octet >= 0 && octet < decodeTable . length && decodeTable [ octet ] != - 1 ; MST[InlineConstantMutator]MSP[] } public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } private void validateCharacter ( final int emptyBitsMask , final Context context ) {
public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked ) { return encodeBase64 ( binaryData , isChunked , false ) ; MST[rv.ABSMutator]MSP[] } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe ) {
buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea >> 8 ) & MASK_8BITS ) ; buffer [ context . pos ++ ] = (byte) ( context . ibitWorkArea & MASK_8BITS ) ; MST[rv.CRCR6Mutator]MSP[] } } } }
if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_1 + MST[NonVoidMethodCallMutator]MSP[] len + lr_2 + maxResultSize ) ; } return b64 . encode ( binaryData ) ; } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { return encodeBase64 ( binaryData , true ) ;
public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked ) { return encodeBase64 ( binaryData , isChunked , false ) ; MST[rv.UOI2Mutator]MSP[] } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe ) {
int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; MST[rv.CRCR5Mutator]MSP[] len -- ; } final int startDst = bitlen / 8 - len ;
int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { MST[rv.ROR1Mutator]MSP[] startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; MST[rv.UOI3Mutator]MSP[] return resizedBytes ; } @Override
return octet >= 0 && octet < decodeTable . length && decodeTable [ octet ] != - 1 ; MST[rv.CRCR3Mutator]MSP[] } public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } private void validateCharacter ( final int emptyBitsMask , final Context context ) {
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[NegateConditionalsMutator]MSP[] } public static boolean isBase64 ( final byte [] arrayOctet ) {
case 2 : buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 10 ) & MASK_6BITS ] ; buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 4 ) & MASK_6BITS ] ; MST[MathMutator]MSP[]
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; MST[NullReturnValsMutator]MSP[] } @Override
final byte [] buffer = ensureBufferSize ( encodeSize , context ) ; context . modulus = ( context . modulus + 1 ) % BYTES_PER_UNENCODED_BLOCK ; MST[rv.CRCR4Mutator]MSP[] int b = in [ inPos ++ ] ; if ( b < 0 ) { b += 256 ; }
int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ; MST[MathMutator]MSP[]
break; } if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { context . modulus = ( context . modulus + 1 ) % BYTES_PER_ENCODED_BLOCK ; MST[rv.AOD1Mutator]MSP[]
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; MST[rv.AOR2Mutator]MSP[] System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; } @Override
public static boolean isBase64 ( final String base64 ) { return isBase64 ( StringUtils . getBytesUtf8 ( base64 ) ) ; } static byte [] toIntegerBytes ( final BigInteger bigInt ) { int bitlen = bigInt . bitLength () ; MST[NonVoidMethodCallMutator]MSP[]
if ( inAvail < 0 ) { context . eof = true ; if ( 0 == context . modulus && lineLength == 0 ) { MST[rv.UOI1Mutator]MSP[] return; } final byte [] buffer = ensureBufferSize ( encodeSize , context ) ; final int savedPos = context . pos ;
break; } if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; MST[rv.ABSMutator]MSP[] if ( result >= 0 ) { context . modulus = ( context . modulus + 1 ) % BYTES_PER_ENCODED_BLOCK ;
if ( len > maxResultSize ) { MST[ConditionalsBoundaryMutator]MSP[] throw new IllegalArgumentException ( lr_1 + len + lr_2 + maxResultSize ) ; } return b64 . encode ( binaryData ) ; } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { return encodeBase64 ( binaryData , true ) ;
if ( isStrictDecoding () && ( context . ibitWorkArea & emptyBitsMask ) != 0 ) { MST[rv.ABSMutator]MSP[] throw new IllegalArgumentException ( lr_5 + lr_6 + lr_7 ) ; } } private void validateTrailingCharacter () { if ( isStrictDecoding () ) { throw new IllegalArgumentException ( lr_5 + lr_6 +
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[rv.CRCR1Mutator]MSP[] } public static boolean isBase64 ( final byte [] arrayOctet ) {
if ( isStrictDecoding () && ( context . ibitWorkArea & emptyBitsMask ) != 0 ) { MST[rv.UOI1Mutator]MSP[] throw new IllegalArgumentException ( lr_5 + lr_6 + lr_7 ) ; } } private void validateTrailingCharacter () { if ( isStrictDecoding () ) { throw new IllegalArgumentException ( lr_5 + lr_6 +
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; MST[rv.CRCR5Mutator]MSP[] System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; } @Override
case 2 : buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 10 ) & MASK_6BITS ] ; buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 4 ) & MASK_6BITS ] ; MST[rv.CRCR3Mutator]MSP[]
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[rv.CRCR4Mutator]MSP[] } public static boolean isBase64 ( final byte [] arrayOctet ) {
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[rv.CRCR5Mutator]MSP[] } public static boolean isBase64 ( final byte [] arrayOctet ) {
for ( int i = 0 ; i < arrayOctet . length ; i ++ ) { MST[rv.ROR3Mutator]MSP[] if ( ! isBase64 ( arrayOctet [ i ] ) && ! isWhiteSpace ( arrayOctet [ i ] ) ) { return false ; } } return true ; }
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.AOD2Mutator]MSP[] return bigBytes ; } int startSrc = 0 ;
if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_1 + len + lr_2 + maxResultSize ) ; } return b64 . encode ( binaryData ) ; } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { return encodeBase64 ( binaryData , true ) ; MST[NonVoidMethodCallMutator]MSP[]
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea << 2 ) & MASK_6BITS ] ; MST[rv.CRCR4Mutator]MSP[] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ context . pos ++ ] = pad ; } break; default:
if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_1 + MST[experimental.NakedReceiverMutator]MSP[] len + lr_2 + maxResultSize ) ; } return b64 . encode ( binaryData ) ; } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { return encodeBase64 ( binaryData , true ) ;
buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea >> 8 ) & MASK_8BITS ) ; buffer [ context . pos ++ ] = (byte) ( context . ibitWorkArea & MASK_8BITS ) ; MST[rv.AOR1Mutator]MSP[] } } } }
if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_1 + len + lr_2 + maxResultSize ) ; } return b64 . encode ( binaryData ) ; } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { return encodeBase64 ( binaryData , true ) ; MST[rv.CRCR6Mutator]MSP[]
bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ; MST[rv.CRCR4Mutator]MSP[] final byte [] bigBytes = bigInt . toByteArray () ;
if ( isStrictDecoding () && ( context . ibitWorkArea & emptyBitsMask ) != 0 ) { throw new IllegalArgumentException ( MST[ConstructorCallMutator]MSP[] lr_5 + lr_6 + lr_7 ) ; } } private void validateTrailingCharacter () { if ( isStrictDecoding () ) { throw new IllegalArgumentException ( lr_5 + lr_6 +
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.ROR2Mutator]MSP[] return bigBytes ; } int startSrc = 0 ;
int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { MST[NegateConditionalsMutator]MSP[] startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
return encodeBase64 ( toIntegerBytes ( bigInteger ) , false ) ; MST[InlineConstantMutator]MSP[] } @Deprecated public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { return isBase64 ( arrayOctet ) ; } public static boolean isBase64 ( final byte octet ) {
return encodeBase64 ( binaryData , isChunked , urlSafe , Integer . MAX_VALUE ) ; MST[rv.UOI3Mutator]MSP[] } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe , final int maxResultSize ) {
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.AOD1Mutator]MSP[] return bigBytes ; } int startSrc = 0 ;
return octet >= 0 && octet < decodeTable . length && decodeTable [ octet ] != - 1 ; } public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; MST[rv.CRCR1Mutator]MSP[] } private void validateCharacter ( final int emptyBitsMask , final Context context ) {
for ( int i = 0 ; i < arrayOctet . length ; i ++ ) { if ( ! isBase64 ( arrayOctet [ i ] ) && ! isWhiteSpace ( arrayOctet [ i ] ) ) { MST[rv.UOI4Mutator]MSP[] return false ; } } return true ; }
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.CRCR2Mutator]MSP[] return bigBytes ; } int startSrc = 0 ;
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[MathMutator]MSP[] return bigBytes ; } int startSrc = 0 ;
buffer [ context . pos ++ ] = encodeTable [ context . ibitWorkArea & MASK_6BITS ] ; context . currentLinePos += BYTES_PER_ENCODED_BLOCK ; if ( lineLength > 0 && lineLength <= context . currentLinePos ) { MST[rv.ROR4Mutator]MSP[]
buffer [ context . pos ++ ] = encodeTable [ context . ibitWorkArea & MASK_6BITS ] ; MST[MathMutator]MSP[] context . currentLinePos += BYTES_PER_ENCODED_BLOCK ; if ( lineLength > 0 && lineLength <= context . currentLinePos ) {
for ( int i = 0 ; i < inAvail ; i ++ ) { final byte [] buffer = ensureBufferSize ( decodeSize , context ) ; final byte b = in [ inPos ++ ] ; MST[rv.ABSMutator]MSP[] if ( b == pad ) { context . eof = true ;
bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ; MST[rv.CRCR2Mutator]MSP[] final byte [] bigBytes = bigInt . toByteArray () ;
bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ; MST[rv.AOD2Mutator]MSP[] final byte [] bigBytes = bigInt . toByteArray () ;
int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ; MST[rv.AOD1Mutator]MSP[]
} public static String encodeBase64String ( final byte [] binaryData ) { return StringUtils . newStringUsAscii ( encodeBase64 ( binaryData , false ) ) ; MST[NonVoidMethodCallMutator]MSP[] } public static byte [] encodeBase64URLSafe ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false , true ) ; }
public static byte [] decodeBase64 ( final byte [] base64Data ) { return new Base64 () . decode ( base64Data ) ; MST[ReturnValsMutator]MSP[] } public static byte [] decodeBase64 ( final String base64String ) { return new Base64 () . decode ( base64String ) ; }
for ( int i = 0 ; i < arrayOctet . length ; i ++ ) { if ( ! isBase64 ( arrayOctet [ i ] ) && ! isWhiteSpace ( arrayOctet [ i ] ) ) { MST[rv.UOI3Mutator]MSP[] return false ; } } return true ; }
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[InlineConstantMutator]MSP[] } public static boolean isBase64 ( final byte [] arrayOctet ) {
return encodeBase64 ( toIntegerBytes ( bigInteger ) , false ) ; MST[rv.CRCR5Mutator]MSP[] } @Deprecated public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { return isBase64 ( arrayOctet ) ; } public static boolean isBase64 ( final byte octet ) {
if ( binaryData == null || binaryData . length == 0 ) { return binaryData ; } final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; MST[rv.ABSMutator]MSP[] final long len = b64 . getEncodedLength ( binaryData ) ;
if ( context . eof && context . modulus != 0 ) { final byte [] buffer = ensureBufferSize ( decodeSize , context ) ; switch ( context . modulus ) { MST[experimental.RemoveSwitchMutator_2]MSP[] case 1 : validateTrailingCharacter () ; break; case 2 : validateCharacter ( MASK_4BITS , context ) ;
if ( context . eof && context . modulus != 0 ) { final byte [] buffer = ensureBufferSize ( decodeSize , context ) ; switch ( context . modulus ) { MST[experimental.RemoveSwitchMutator_1]MSP[] case 1 : validateTrailingCharacter () ; break; case 2 : validateCharacter ( MASK_4BITS , context ) ;
return octet >= 0 && octet < decodeTable . length && decodeTable [ octet ] != - 1 ; MST[rv.CRCR3Mutator]MSP[] } public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } private void validateCharacter ( final int emptyBitsMask , final Context context ) {
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[rv.ROR3Mutator]MSP[] } public static boolean isBase64 ( final byte [] arrayOctet ) {
context . ibitWorkArea = ( context . ibitWorkArea << 8 ) + b ; if ( 0 == context . modulus ) { buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 18 ) & MASK_6BITS ] ; MST[rv.CRCR5Mutator]MSP[]
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[rv.ABSMutator]MSP[] } public static boolean isBase64 ( final byte [] arrayOctet ) {
if ( len > maxResultSize ) { MST[rv.UOI1Mutator]MSP[] throw new IllegalArgumentException ( lr_1 + len + lr_2 + maxResultSize ) ; } return b64 . encode ( binaryData ) ; } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { return encodeBase64 ( binaryData , true ) ;
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[rv.UOI4Mutator]MSP[] } public static boolean isBase64 ( final byte [] arrayOctet ) {
if ( context . eof && context . modulus != 0 ) { MST[rv.ROR3Mutator]MSP[] final byte [] buffer = ensureBufferSize ( decodeSize , context ) ; switch ( context . modulus ) { case 1 : validateTrailingCharacter () ; break; case 2 : validateCharacter ( MASK_4BITS , context ) ;
return encodeBase64 ( toIntegerBytes ( bigInteger ) , false ) ; MST[ReturnValsMutator]MSP[] } @Deprecated public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { return isBase64 ( arrayOctet ) ; } public static boolean isBase64 ( final byte octet ) {
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] } public static boolean isBase64 ( final byte [] arrayOctet ) {
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; MST[rv.ABSMutator]MSP[] return resizedBytes ; } @Override
System . arraycopy ( lineSeparator , 0 , buffer , context . pos , lineSeparator . length ) ; MST[rv.CRCR1Mutator]MSP[] context . pos += lineSeparator . length ; } } else { for ( int i = 0 ; i < inAvail ; i ++ ) {
buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea >> 8 ) & MASK_8BITS ) ; MST[rv.UOI1Mutator]MSP[] buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea ) & MASK_8BITS ) ; break; default:
System . arraycopy ( lineSeparator , 0 , buffer , context . pos , lineSeparator . length ) ; context . pos += lineSeparator . length ; } } else { for ( int i = 0 ; i < inAvail ; i ++ ) { MST[rv.UOI4Mutator]MSP[]
break; } if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { context . modulus = ( context . modulus + 1 ) % BYTES_PER_ENCODED_BLOCK ; MST[InlineConstantMutator]MSP[]
if ( isStrictDecoding () && ( context . ibitWorkArea & emptyBitsMask ) != 0 ) { MST[rv.ROR4Mutator]MSP[] throw new IllegalArgumentException ( lr_5 + lr_6 + lr_7 ) ; } } private void validateTrailingCharacter () { if ( isStrictDecoding () ) { throw new IllegalArgumentException ( lr_5 + lr_6 +
if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_1 + len + lr_2 + maxResultSize ) ; } return b64 . encode ( binaryData ) ; MST[NullReturnValsMutator]MSP[] } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { return encodeBase64 ( binaryData , true ) ;
return octet >= 0 && octet < decodeTable . length && decodeTable [ octet ] != - 1 ; MST[rv.CRCR6Mutator]MSP[] } public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } private void validateCharacter ( final int emptyBitsMask , final Context context ) {
context . ibitWorkArea = ( context . ibitWorkArea << 8 ) + b ; if ( 0 == context . modulus ) { buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 18 ) & MASK_6BITS ] ; MST[rv.OBBN1Mutator]MSP[]
return encodeBase64 ( toIntegerBytes ( bigInteger ) , false ) ; MST[NonVoidMethodCallMutator]MSP[] } @Deprecated public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { return isBase64 ( arrayOctet ) ; } public static boolean isBase64 ( final byte octet ) {
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 12 ) & MASK_6BITS ] ; buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 6 ) & MASK_6BITS ] ; MST[rv.ABSMutator]MSP[]
public static BigInteger decodeInteger ( final byte [] pArray ) { return new BigInteger ( 1 , decodeBase64 ( pArray ) ) ; MST[ConstructorCallMutator]MSP[] } public static byte [] encodeBase64 ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false ) ; }
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[rv.ROR1Mutator]MSP[] } public static boolean isBase64 ( final byte [] arrayOctet ) {
int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; MST[InlineConstantMutator]MSP[] len -- ; } final int startDst = bitlen / 8 - len ;
context . ibitWorkArea = ( context . ibitWorkArea << BITS_PER_ENCODED_BYTE ) + result ; if ( context . modulus == 0 ) { MST[rv.UOI1Mutator]MSP[] buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea >> 16 ) & MASK_8BITS ) ;
context . ibitWorkArea = context . ibitWorkArea >> 4 ; MST[rv.CRCR3Mutator]MSP[] buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea ) & MASK_8BITS ) ; break; case 3 : validateCharacter ( MASK_2BITS , context ) ; context . ibitWorkArea = context . ibitWorkArea >> 2 ;
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[rv.CRCR1Mutator]MSP[] } public static boolean isBase64 ( final byte [] arrayOctet ) {
for ( int i = 0 ; i < arrayOctet . length ; i ++ ) { if ( ! isBase64 ( arrayOctet [ i ] ) && ! isWhiteSpace ( arrayOctet [ i ] ) ) { MST[rv.UOI1Mutator]MSP[] return false ; } } return true ; }
if ( isStrictDecoding () && ( context . ibitWorkArea & emptyBitsMask ) != 0 ) { throw new IllegalArgumentException ( lr_5 + lr_6 + lr_7 ) ; } } private void validateTrailingCharacter () { if ( isStrictDecoding () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] throw new IllegalArgumentException ( lr_5 + lr_6 +
System . arraycopy ( lineSeparator , 0 , buffer , context . pos , lineSeparator . length ) ; context . pos += lineSeparator . length ; } } else { for ( int i = 0 ; i < inAvail ; i ++ ) { MST[rv.UOI3Mutator]MSP[]
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.CRCR5Mutator]MSP[] return bigBytes ; } int startSrc = 0 ;
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; MST[rv.UOI1Mutator]MSP[] System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; } @Override
buffer [ context . pos ++ ] = encodeTable [ context . ibitWorkArea & MASK_6BITS ] ; context . currentLinePos += BYTES_PER_ENCODED_BLOCK ; if ( lineLength > 0 && lineLength <= context . currentLinePos ) { MST[NegateConditionalsMutator]MSP[]
return octet >= 0 && octet < decodeTable . length && decodeTable [ octet ] != - 1 ; MST[rv.CRCR1Mutator]MSP[] } public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } private void validateCharacter ( final int emptyBitsMask , final Context context ) {
if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_1 + MST[experimental.NakedReceiverMutator]MSP[] len + lr_2 + maxResultSize ) ; } return b64 . encode ( binaryData ) ; } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { return encodeBase64 ( binaryData , true ) ;
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 12 ) & MASK_6BITS ] ; MST[rv.OBBN2Mutator]MSP[] buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 6 ) & MASK_6BITS ] ;
throw new IllegalStateException ( lr_4 + context . modulus ) ; } context . currentLinePos += context . pos - savedPos ; if ( lineLength > 0 && context . currentLinePos > 0 ) { MST[NegateConditionalsMutator]MSP[]
context . ibitWorkArea = ( context . ibitWorkArea << BITS_PER_ENCODED_BYTE ) + result ; MST[rv.ABSMutator]MSP[] if ( context . modulus == 0 ) { buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea >> 16 ) & MASK_8BITS ) ;
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[rv.UOI2Mutator]MSP[] } public static boolean isBase64 ( final byte [] arrayOctet ) {
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[rv.ROR5Mutator]MSP[] } public static boolean isBase64 ( final byte [] arrayOctet ) {
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.ROR1Mutator]MSP[] return bigBytes ; } int startSrc = 0 ;
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.ABSMutator]MSP[] return bigBytes ; } int startSrc = 0 ;
public static String encodeBase64URLSafeString ( final byte [] binaryData ) { return StringUtils . newStringUsAscii ( encodeBase64 ( binaryData , false , true ) ) ; MST[rv.CRCR5Mutator]MSP[] } public static byte [] encodeInteger ( final BigInteger bigInteger ) { Objects . requireNonNull ( bigInteger , lr_3 ) ;
for ( int i = 0 ; i < inAvail ; i ++ ) { MST[IncrementsMutator]MSP[] final byte [] buffer = ensureBufferSize ( decodeSize , context ) ; final byte b = in [ inPos ++ ] ; if ( b == pad ) { context . eof = true ;
} public static String encodeBase64String ( final byte [] binaryData ) { return StringUtils . newStringUsAscii ( encodeBase64 ( binaryData , false ) ) ; } public static byte [] encodeBase64URLSafe ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false , true ) ; MST[ReturnValsMutator]MSP[] }
public static BigInteger decodeInteger ( final byte [] pArray ) { return new BigInteger ( 1 , decodeBase64 ( pArray ) ) ; } public static byte [] encodeBase64 ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false ) ; MST[InlineConstantMutator]MSP[] }
int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ; MST[rv.UOI4Mutator]MSP[]
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.CRCR4Mutator]MSP[] return bigBytes ; } int startSrc = 0 ;
for ( int i = 0 ; i < arrayOctet . length ; i ++ ) { if ( ! isBase64 ( arrayOctet [ i ] ) && ! isWhiteSpace ( arrayOctet [ i ] ) ) { MST[rv.ROR4Mutator]MSP[] return false ; } } return true ; }
System . arraycopy ( lineSeparator , 0 , buffer , context . pos , lineSeparator . length ) ; MST[rv.CRCR6Mutator]MSP[] context . pos += lineSeparator . length ; context . currentLinePos = 0 ; } } } } } @Override protected boolean isInAlphabet ( final byte octet ) {
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return bigBytes ; } int startSrc = 0 ;
for ( int i = 0 ; i < arrayOctet . length ; i ++ ) { if ( ! isBase64 ( arrayOctet [ i ] ) && ! isWhiteSpace ( arrayOctet [ i ] ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return false ; } } return true ; }
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[NegateConditionalsMutator]MSP[] } public static boolean isBase64 ( final byte [] arrayOctet ) {
throw new IllegalStateException ( lr_4 + context . modulus ) ; } context . currentLinePos += context . pos - savedPos ; MST[rv.AOR4Mutator]MSP[] if ( lineLength > 0 && context . currentLinePos > 0 ) {
return encodeBase64 ( binaryData , isChunked , urlSafe , Integer . MAX_VALUE ) ; MST[rv.CRCR6Mutator]MSP[] } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe , final int maxResultSize ) {
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; MST[InlineConstantMutator]MSP[] System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; } @Override
buffer [ context . pos ++ ] = encodeTable [ context . ibitWorkArea & MASK_6BITS ] ; MST[rv.CRCR3Mutator]MSP[] context . currentLinePos += BYTES_PER_ENCODED_BLOCK ; if ( lineLength > 0 && lineLength <= context . currentLinePos ) {
context . ibitWorkArea = ( context . ibitWorkArea << BITS_PER_ENCODED_BYTE ) + result ; MST[rv.AOR4Mutator]MSP[] if ( context . modulus == 0 ) { buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea >> 16 ) & MASK_8BITS ) ;
int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { MST[rv.AOD2Mutator]MSP[] startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
} public static String encodeBase64String ( final byte [] binaryData ) { return StringUtils . newStringUsAscii ( encodeBase64 ( binaryData , false ) ) ; } public static byte [] encodeBase64URLSafe ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false , true ) ; MST[rv.CRCR5Mutator]MSP[] }
