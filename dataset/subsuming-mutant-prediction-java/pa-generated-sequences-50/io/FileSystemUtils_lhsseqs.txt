String normPath = FilenameUtils . normalize ( path , false ) ; if ( normPath == null ) { throw new IllegalArgumentException ( path ) ; } if ( normPath . length () > 0 && normPath . charAt ( 0 ) != '"' ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
} throw new IOException ( lr_9 + lr_10 + normPath + lr_11 ) ; } long parseDir ( final String line , final String path ) throws IOException { int bytesStart = 0 ; MST[rv.CRCR6Mutator]MSP[] int bytesEnd = 0 ; int j = line . length () - 1 ;
final char c = line . charAt ( j ) ; if ( ! Character . isDigit ( c ) && c != ',' && c != '.' ) { bytesStart = j + 1 ; break innerLoop2; } j -- ; } if ( j < 0 ) { MST[rv.UOI3Mutator]MSP[]
flags += lr_15 ; } if ( posix ) { flags += lr_16 ; MST[NonVoidMethodCallMutator]MSP[] } final String [] cmdAttribs = flags . length () > 1 ? new String [] { DF , flags , path } : new String [] { DF , path } ;
final long bytes = Long . parseLong ( freeSpace ) ; if ( bytes < 0 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[] throw new IOException ( lr_17 + DF + lr_23 + lr_10 + path + lr_22 ) ; } return bytes ; } catch ( final NumberFormatException ex ) {
if ( buf . charAt ( k ) == ',' || buf . charAt ( k ) == '.' ) { MST[rv.ROR3Mutator]MSP[] buf . deleteCharAt ( k -- ) ; } } return parseBytes ( buf . toString () , path ) ; }
if ( buf . charAt ( k ) == ',' || buf . charAt ( k ) == '.' ) { MST[rv.CRCR6Mutator]MSP[] buf . deleteCharAt ( k -- ) ; } } return parseBytes ( buf . toString () , path ) ; }
normPath = lr_5 + normPath + lr_5 ; MST[experimental.NakedReceiverMutator]MSP[] } final String [] cmdAttribs = new String [] { lr_6 , lr_7 , lr_8 + normPath } ; final List < String > lines = performCommand ( cmdAttribs , Integer . MAX_VALUE , timeout ) ;
long freeSpaceOS ( final String path , final int os , final boolean kb , final long timeout ) throws IOException { if ( path == null ) { throw new IllegalArgumentException ( lr_2 ) ; MST[ConstructorCallMutator]MSP[] } switch ( os ) { case WINDOWS :
final long bytes = Long . parseLong ( freeSpace ) ; if ( bytes < 0 ) { throw new IOException ( MST[NonVoidMethodCallMutator]MSP[] lr_17 + DF + lr_23 + lr_10 + path + lr_22 ) ; } return bytes ; } catch ( final NumberFormatException ex ) {
return kb ? freeSpaceWindows ( path , timeout ) / FileUtils . ONE_KB : freeSpaceWindows ( path , timeout ) ; MST[ArgumentPropagationMutator]MSP[] case UNIX : return freeSpaceUnix ( path , kb , false , timeout ) ; case POSIX_UNIX :
normPath = lr_5 + normPath + lr_5 ; } final String [] cmdAttribs = new String [] { lr_6 , lr_7 , lr_8 + normPath } ; MST[rv.CRCR5Mutator]MSP[] final List < String > lines = performCommand ( cmdAttribs , Integer . MAX_VALUE , timeout ) ;
return freeSpaceUnix ( path , kb , true , timeout ) ; MST[rv.CRCR2Mutator]MSP[] case OTHER : throw new IllegalStateException ( lr_3 ) ; default: throw new IllegalStateException ( lr_4 ) ; } } long freeSpaceWindows ( final String path , final long timeout ) throws IOException {
String normPath = FilenameUtils . normalize ( path , false ) ; if ( normPath == null ) { throw new IllegalArgumentException ( path ) ; } if ( normPath . length () > 0 && normPath . charAt ( 0 ) != '"' ) { MST[rv.ROR5Mutator]MSP[]
final long bytes = Long . parseLong ( freeSpace ) ; if ( bytes < 0 ) { throw new IOException ( lr_17 + DF + lr_23 + lr_10 + path + lr_22 ) ; } return bytes ; MST[ReturnValsMutator]MSP[] } catch ( final NumberFormatException ex ) {
@Deprecated public static long freeSpace ( final String path ) throws IOException { return INSTANCE . freeSpaceOS ( path , OS , false , - 1 ) ; MST[rv.CRCR1Mutator]MSP[] } @Deprecated public static long freeSpaceKb ( final String path ) throws IOException {
String normPath = FilenameUtils . normalize ( path , false ) ; if ( normPath == null ) { throw new IllegalArgumentException ( path ) ; } if ( normPath . length () > 0 && normPath . charAt ( 0 ) != '"' ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[]
flags += lr_15 ; } if ( posix ) { flags += lr_16 ; } final String [] cmdAttribs = flags . length () > 1 ? new String [] { DF , flags , path } : new String [] { DF , path } ; MST[rv.ROR2Mutator]MSP[]
final String line2 = lines . get ( 1 ) ; StringTokenizer tok = new StringTokenizer ( line2 , lr_20 ) ; if ( tok . countTokens () < 4 ) { if ( tok . countTokens () == 1 && lines . size () >= 3 ) { MST[rv.CRCR5Mutator]MSP[]
normPath = lr_5 + normPath + lr_5 ; } final String [] cmdAttribs = new String [] { lr_6 , lr_7 , lr_8 + normPath } ; MST[rv.CRCR2Mutator]MSP[] final List < String > lines = performCommand ( cmdAttribs , Integer . MAX_VALUE , timeout ) ;
throw new IOException ( lr_12 + lr_10 + path + lr_11 ) ; } final StringBuilder buf = new StringBuilder ( line . substring ( bytesStart , bytesEnd ) ) ; MST[rv.UOI1Mutator]MSP[] for ( int k = 0 ; k < buf . length () ; k ++ ) {
final List < String > lines = performCommand ( cmdAttribs , 3 , timeout ) ; MST[rv.UOI2Mutator]MSP[] if ( lines . size () < 2 ) { throw new IOException ( lr_17 + DF + lr_18 + lr_10 + path + lr_19 + lines ) ; }
long freeSpaceUnix ( final String path , final boolean kb , final boolean posix , final long timeout ) throws IOException { if ( path . isEmpty () ) { throw new IllegalArgumentException ( lr_13 ) ; } String flags = lr_14 ; if ( kb ) { MST[rv.ROR5Mutator]MSP[]
final char c = line . charAt ( j ) ; if ( ! Character . isDigit ( c ) && c != ',' && c != '.' ) { bytesStart = j + 1 ; MST[rv.AOR4Mutator]MSP[] break innerLoop2; } j -- ; } if ( j < 0 ) {
final String line2 = lines . get ( 1 ) ; StringTokenizer tok = new StringTokenizer ( line2 , lr_20 ) ; if ( tok . countTokens () < 4 ) { if ( tok . countTokens () == 1 && lines . size () >= 3 ) { MST[rv.ROR5Mutator]MSP[]
return kb ? freeSpaceWindows ( path , timeout ) / FileUtils . ONE_KB : freeSpaceWindows ( path , timeout ) ; case UNIX : return freeSpaceUnix ( path , kb , false , timeout ) ; MST[rv.UOI3Mutator]MSP[] case POSIX_UNIX :
} throw new IOException ( lr_9 + lr_10 + normPath + lr_11 ) ; } long parseDir ( final String line , final String path ) throws IOException { int bytesStart = 0 ; int bytesEnd = 0 ; int j = line . length () - 1 ; MST[rv.AOR1Mutator]MSP[]
long freeSpaceUnix ( final String path , final boolean kb , final boolean posix , final long timeout ) throws IOException { if ( path . isEmpty () ) { throw new IllegalArgumentException ( lr_13 ) ; } String flags = lr_14 ; if ( kb ) { MST[rv.UOI4Mutator]MSP[]
throw new IOException ( MST[NonVoidMethodCallMutator]MSP[] lr_12 + lr_10 + path + lr_11 ) ; } final StringBuilder buf = new StringBuilder ( line . substring ( bytesStart , bytesEnd ) ) ; for ( int k = 0 ; k < buf . length () ; k ++ ) {
throw new IOException ( MST[ConstructorCallMutator]MSP[] lr_12 + lr_10 + path + lr_11 ) ; } final StringBuilder buf = new StringBuilder ( line . substring ( bytesStart , bytesEnd ) ) ; for ( int k = 0 ; k < buf . length () ; k ++ ) {
final Thread monitor = ThreadMonitor . start ( timeout ) ; MST[rv.ABSMutator]MSP[] proc = openProcess ( cmdAttribs ) ; in = proc . getInputStream () ; out = proc . getOutputStream () ; err = proc . getErrorStream () ;
final char c = line . charAt ( j ) ; if ( ! Character . isDigit ( c ) && c != ',' && c != '.' ) { bytesStart = j + 1 ; break innerLoop2; } j -- ; } if ( j < 0 ) { MST[rv.ROR4Mutator]MSP[]
final char c = line . charAt ( j ) ; if ( ! Character . isDigit ( c ) && c != ',' && c != '.' ) { MST[rv.CRCR1Mutator]MSP[] bytesStart = j + 1 ; break innerLoop2; } j -- ; } if ( j < 0 ) {
final char c = line . charAt ( j ) ; if ( ! Character . isDigit ( c ) && c != ',' && c != '.' ) { MST[rv.CRCR2Mutator]MSP[] bytesStart = j + 1 ; break innerLoop2; } j -- ; } if ( j < 0 ) {
} throw new IOException ( MST[NonVoidMethodCallMutator]MSP[] lr_9 + lr_10 + normPath + lr_11 ) ; } long parseDir ( final String line , final String path ) throws IOException { int bytesStart = 0 ; int bytesEnd = 0 ; int j = line . length () - 1 ;
final char c = line . charAt ( j ) ; if ( ! Character . isDigit ( c ) && c != ',' && c != '.' ) { bytesStart = j + 1 ; MST[MathMutator]MSP[] break innerLoop2; } j -- ; } if ( j < 0 ) {
flags += lr_15 ; } if ( posix ) { flags += lr_16 ; } final String [] cmdAttribs = flags . length () > 1 ? new String [] { DF , flags , path } : new String [] { DF , path } ; MST[rv.CRCR6Mutator]MSP[]
flags += lr_15 ; } if ( posix ) { MST[rv.ROR1Mutator]MSP[] flags += lr_16 ; } final String [] cmdAttribs = flags . length () > 1 ? new String [] { DF , flags , path } : new String [] { DF , path } ;
flags += lr_15 ; } if ( posix ) { flags += lr_16 ; } final String [] cmdAttribs = flags . length () > 1 ? new String [] { DF , flags , path } : new String [] { DF , path } ; MST[rv.CRCR5Mutator]MSP[]
throw new IOException ( lr_12 + lr_10 + path + lr_11 ) ; } final StringBuilder buf = new StringBuilder ( line . substring ( bytesStart , bytesEnd ) ) ; for ( int k = 0 ; k < buf . length () ; k ++ ) { MST[rv.CRCR3Mutator]MSP[]
if ( proc . exitValue () != 0 ) { MST[rv.ROR3Mutator]MSP[] throw new IOException ( lr_25 + proc . exitValue () + lr_26 + Arrays . asList ( cmdAttribs ) ) ; } if ( lines . isEmpty () ) { throw new IOException ( lr_27 +
final List < String > lines = performCommand ( cmdAttribs , 3 , timeout ) ; if ( lines . size () < 2 ) { MST[rv.CRCR4Mutator]MSP[] throw new IOException ( lr_17 + DF + lr_18 + lr_10 + path + lr_19 + lines ) ; }
if ( buf . charAt ( k ) == ',' || buf . charAt ( k ) == '.' ) { MST[rv.ROR4Mutator]MSP[] buf . deleteCharAt ( k -- ) ; } } return parseBytes ( buf . toString () , path ) ; }
@Deprecated public static long freeSpace ( final String path ) throws IOException { return INSTANCE . freeSpaceOS ( path , OS , false , - 1 ) ; MST[rv.CRCR5Mutator]MSP[] } @Deprecated public static long freeSpaceKb ( final String path ) throws IOException {
return freeSpaceUnix ( path , kb , true , timeout ) ; MST[rv.ABSMutator]MSP[] case OTHER : throw new IllegalStateException ( lr_3 ) ; default: throw new IllegalStateException ( lr_4 ) ; } } long freeSpaceWindows ( final String path , final long timeout ) throws IOException {
normPath = lr_5 + normPath + lr_5 ; } final String [] cmdAttribs = new String [] { lr_6 , lr_7 , lr_8 + normPath } ; MST[rv.CRCR4Mutator]MSP[] final List < String > lines = performCommand ( cmdAttribs , Integer . MAX_VALUE , timeout ) ;
throw new IOException ( lr_12 + lr_10 + path + lr_11 ) ; } final StringBuilder buf = new StringBuilder ( line . substring ( bytesStart , bytesEnd ) ) ; for ( int k = 0 ; k < buf . length () ; k ++ ) { MST[rv.ROR5Mutator]MSP[]
final char c = line . charAt ( j ) ; if ( ! Character . isDigit ( c ) && c != ',' && c != '.' ) { bytesStart = j + 1 ; MST[rv.AOD2Mutator]MSP[] break innerLoop2; } j -- ; } if ( j < 0 ) {
if ( err != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] err . close () ; err = null ; } return lines ; } catch ( final InterruptedException ex ) { throw new IOException ( lr_29 + lr_28 + Arrays . asList ( cmdAttribs ) + lr_30 + timeout , ex ) ;
flags += lr_15 ; } if ( posix ) { flags += lr_16 ; } final String [] cmdAttribs = flags . length () > 1 ? new String [] { DF , flags , path } : new String [] { DF , path } ; MST[rv.CRCR3Mutator]MSP[]
return kb ? freeSpaceWindows ( path , timeout ) / FileUtils . ONE_KB : freeSpaceWindows ( path , timeout ) ; MST[PrimitiveReturnsMutator]MSP[] case UNIX : return freeSpaceUnix ( path , kb , false , timeout ) ; case POSIX_UNIX :
final String line3 = lines . get ( 2 ) ; MST[rv.CRCR6Mutator]MSP[] tok = new StringTokenizer ( line3 , lr_20 ) ; } else { throw new IOException ( lr_17 + DF + lr_21 + lr_10 + path + lr_22 ) ; } } else { tok . nextToken () ;
flags += lr_15 ; MST[experimental.NakedReceiverMutator]MSP[] } if ( posix ) { flags += lr_16 ; } final String [] cmdAttribs = flags . length () > 1 ? new String [] { DF , flags , path } : new String [] { DF , path } ;
return kb ? freeSpaceWindows ( path , timeout ) / FileUtils . ONE_KB : freeSpaceWindows ( path , timeout ) ; MST[NonVoidMethodCallMutator]MSP[] case UNIX : return freeSpaceUnix ( path , kb , false , timeout ) ; case POSIX_UNIX :
final char c = line . charAt ( j ) ; if ( ! Character . isDigit ( c ) && c != ',' && c != '.' ) { MST[rv.ABSMutator]MSP[] bytesStart = j + 1 ; break innerLoop2; } j -- ; } if ( j < 0 ) {
final char c = line . charAt ( j ) ; if ( ! Character . isDigit ( c ) && c != ',' && c != '.' ) { MST[rv.UOI1Mutator]MSP[] bytesStart = j + 1 ; break innerLoop2; } j -- ; } if ( j < 0 ) {
String normPath = FilenameUtils . normalize ( path , false ) ; if ( normPath == null ) { throw new IllegalArgumentException ( path ) ; } if ( normPath . length () > 0 && normPath . charAt ( 0 ) != '"' ) { MST[rv.CRCR3Mutator]MSP[]
flags += lr_15 ; } if ( posix ) { flags += lr_16 ; } final String [] cmdAttribs = flags . length () > 1 ? new String [] { DF , flags , path } : new String [] { DF , path } ; MST[rv.CRCR3Mutator]MSP[]
innerLoop1: while ( j >= 0 ) { final char c = line . charAt ( j ) ; if ( Character . isDigit ( c ) ) { bytesEnd = j + 1 ; MST[rv.CRCR6Mutator]MSP[] break innerLoop1; } j -- ; } innerLoop2: while ( j >= 0 ) {
final Thread monitor = ThreadMonitor . start ( timeout ) ; MST[rv.UOI2Mutator]MSP[] proc = openProcess ( cmdAttribs ) ; in = proc . getInputStream () ; out = proc . getOutputStream () ; err = proc . getErrorStream () ;
if ( proc . exitValue () != 0 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] throw new IOException ( lr_25 + proc . exitValue () + lr_26 + Arrays . asList ( cmdAttribs ) ) ; } if ( lines . isEmpty () ) { throw new IOException ( lr_27 +
long freeSpaceUnix ( final String path , final boolean kb , final boolean posix , final long timeout ) throws IOException { if ( path . isEmpty () ) { throw new IllegalArgumentException ( lr_13 ) ; } String flags = lr_14 ; if ( kb ) { MST[NegateConditionalsMutator]MSP[]
flags += lr_15 ; } if ( posix ) { flags += lr_16 ; } final String [] cmdAttribs = flags . length () > 1 ? new String [] { DF , flags , path } : new String [] { DF , path } ; MST[rv.CRCR6Mutator]MSP[]
final String line2 = lines . get ( 1 ) ; StringTokenizer tok = new StringTokenizer ( line2 , lr_20 ) ; if ( tok . countTokens () < 4 ) { if ( tok . countTokens () == 1 && lines . size () >= 3 ) { MST[NegateConditionalsMutator]MSP[]
@Deprecated public static long freeSpace ( final String path ) throws IOException { return INSTANCE . freeSpaceOS ( path , OS , false , - 1 ) ; MST[ReturnValsMutator]MSP[] } @Deprecated public static long freeSpaceKb ( final String path ) throws IOException {
return freeSpaceUnix ( path , kb , true , timeout ) ; MST[rv.UOI2Mutator]MSP[] case OTHER : throw new IllegalStateException ( lr_3 ) ; default: throw new IllegalStateException ( lr_4 ) ; } } long freeSpaceWindows ( final String path , final long timeout ) throws IOException {
return freeSpaceKb ( path , - 1 ) ; } @Deprecated public static long freeSpaceKb ( final String path , final long timeout ) throws IOException { return INSTANCE . freeSpaceOS ( path , OS , true , timeout ) ; MST[rv.CRCR4Mutator]MSP[] } @Deprecated
final List < String > lines = performCommand ( cmdAttribs , 3 , timeout ) ; if ( lines . size () < 2 ) { MST[rv.ROR1Mutator]MSP[] throw new IOException ( lr_17 + DF + lr_18 + lr_10 + path + lr_19 + lines ) ; }
if ( proc . exitValue () != 0 ) { throw new IOException ( MST[ConstructorCallMutator]MSP[] lr_25 + proc . exitValue () + lr_26 + Arrays . asList ( cmdAttribs ) ) ; } if ( lines . isEmpty () ) { throw new IOException ( lr_27 +
flags += lr_15 ; } if ( posix ) { flags += lr_16 ; MST[NonVoidMethodCallMutator]MSP[] } final String [] cmdAttribs = flags . length () > 1 ? new String [] { DF , flags , path } : new String [] { DF , path } ;
final char c = line . charAt ( j ) ; if ( ! Character . isDigit ( c ) && c != ',' && c != '.' ) { bytesStart = j + 1 ; break innerLoop2; } j -- ; } if ( j < 0 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[]
if ( buf . charAt ( k ) == ',' || buf . charAt ( k ) == '.' ) { MST[NonVoidMethodCallMutator]MSP[] buf . deleteCharAt ( k -- ) ; } } return parseBytes ( buf . toString () , path ) ; }
return kb ? freeSpaceWindows ( path , timeout ) / FileUtils . ONE_KB : freeSpaceWindows ( path , timeout ) ; case UNIX : return freeSpaceUnix ( path , kb , false , timeout ) ; MST[rv.CRCR3Mutator]MSP[] case POSIX_UNIX :
normPath = lr_5 + normPath + lr_5 ; MST[experimental.NakedReceiverMutator]MSP[] } final String [] cmdAttribs = new String [] { lr_6 , lr_7 , lr_8 + normPath } ; final List < String > lines = performCommand ( cmdAttribs , Integer . MAX_VALUE , timeout ) ;
} throw new IOException ( lr_9 + lr_10 + normPath + lr_11 ) ; } long parseDir ( final String line , final String path ) throws IOException { int bytesStart = 0 ; int bytesEnd = 0 ; int j = line . length () - 1 ; MST[rv.CRCR5Mutator]MSP[]
final long bytes = Long . parseLong ( freeSpace ) ; if ( bytes < 0 ) { throw new IOException ( MST[NonVoidMethodCallMutator]MSP[] lr_17 + DF + lr_23 + lr_10 + path + lr_22 ) ; } return bytes ; } catch ( final NumberFormatException ex ) {
return kb ? freeSpaceWindows ( path , timeout ) / FileUtils . ONE_KB : freeSpaceWindows ( path , timeout ) ; MST[rv.UOI1Mutator]MSP[] case UNIX : return freeSpaceUnix ( path , kb , false , timeout ) ; case POSIX_UNIX :
final Thread monitor = ThreadMonitor . start ( timeout ) ; proc = openProcess ( cmdAttribs ) ; in = proc . getInputStream () ; out = proc . getOutputStream () ; MST[NonVoidMethodCallMutator]MSP[] err = proc . getErrorStream () ;
lr_28 + Arrays . asList ( cmdAttribs ) ) ; } inr . close () ; inr = null ; in . close () ; in = null ; if ( out != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] out . close () ; out = null ; }
final String line2 = lines . get ( 1 ) ; MST[rv.CRCR2Mutator]MSP[] StringTokenizer tok = new StringTokenizer ( line2 , lr_20 ) ; if ( tok . countTokens () < 4 ) { if ( tok . countTokens () == 1 && lines . size () >= 3 ) {
final String line2 = lines . get ( 1 ) ; StringTokenizer tok = new StringTokenizer ( line2 , lr_20 ) ; if ( tok . countTokens () < 4 ) { MST[rv.ROR3Mutator]MSP[] if ( tok . countTokens () == 1 && lines . size () >= 3 ) {
return kb ? freeSpaceWindows ( path , timeout ) / FileUtils . ONE_KB : freeSpaceWindows ( path , timeout ) ; MST[rv.ROR2Mutator]MSP[] case UNIX : return freeSpaceUnix ( path , kb , false , timeout ) ; case POSIX_UNIX :
final List < String > lines = performCommand ( cmdAttribs , 3 , timeout ) ; MST[InlineConstantMutator]MSP[] if ( lines . size () < 2 ) { throw new IOException ( lr_17 + DF + lr_18 + lr_10 + path + lr_19 + lines ) ; }
final char c = line . charAt ( j ) ; if ( ! Character . isDigit ( c ) && c != ',' && c != '.' ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] bytesStart = j + 1 ; break innerLoop2; } j -- ; } if ( j < 0 ) {
final long bytes = Long . parseLong ( freeSpace ) ; if ( bytes < 0 ) { MST[rv.ROR4Mutator]MSP[] throw new IOException ( lr_17 + DF + lr_23 + lr_10 + path + lr_22 ) ; } return bytes ; } catch ( final NumberFormatException ex ) {
if ( proc . exitValue () != 0 ) { throw new IOException ( lr_25 + proc . exitValue () + MST[NonVoidMethodCallMutator]MSP[] lr_26 + Arrays . asList ( cmdAttribs ) ) ; } if ( lines . isEmpty () ) { throw new IOException ( lr_27 +
return kb ? freeSpaceWindows ( path , timeout ) / FileUtils . ONE_KB : freeSpaceWindows ( path , timeout ) ; case UNIX : return freeSpaceUnix ( path , kb , false , timeout ) ; MST[rv.UOI3Mutator]MSP[] case POSIX_UNIX :
final List < String > lines = new ArrayList <> ( 20 ) ; MST[rv.CRCR4Mutator]MSP[] Process proc = null ; InputStream in = null ; OutputStream out = null ; InputStream err = null ; BufferedReader inr = null ; try {
if ( buf . charAt ( k ) == ',' || buf . charAt ( k ) == '.' ) { buf . deleteCharAt ( k -- ) ; } } return parseBytes ( buf . toString () , path ) ; MST[ReturnValsMutator]MSP[] }
final String line3 = lines . get ( 2 ) ; tok = new StringTokenizer ( line3 , lr_20 ) ; } else { throw new IOException ( MST[ConstructorCallMutator]MSP[] lr_17 + DF + lr_21 + lr_10 + path + lr_22 ) ; } } else { tok . nextToken () ;
final long bytes = Long . parseLong ( freeSpace ) ; if ( bytes < 0 ) { throw new IOException ( MST[ConstructorCallMutator]MSP[] lr_17 + DF + lr_23 + lr_10 + path + lr_22 ) ; } return bytes ; } catch ( final NumberFormatException ex ) {
flags += lr_15 ; } if ( posix ) { flags += lr_16 ; } final String [] cmdAttribs = flags . length () > 1 ? new String [] { DF , flags , path } : new String [] { DF , path } ; MST[rv.CRCR5Mutator]MSP[]
return freeSpaceUnix ( path , kb , true , timeout ) ; MST[rv.ABSMutator]MSP[] case OTHER : throw new IllegalStateException ( lr_3 ) ; default: throw new IllegalStateException ( lr_4 ) ; } } long freeSpaceWindows ( final String path , final long timeout ) throws IOException {
final char c = line . charAt ( j ) ; if ( ! Character . isDigit ( c ) && c != ',' && c != '.' ) { MST[rv.CRCR6Mutator]MSP[] bytesStart = j + 1 ; break innerLoop2; } j -- ; } if ( j < 0 ) {
String normPath = FilenameUtils . normalize ( path , false ) ; MST[rv.CRCR6Mutator]MSP[] if ( normPath == null ) { throw new IllegalArgumentException ( path ) ; } if ( normPath . length () > 0 && normPath . charAt ( 0 ) != '"' ) {
final char c = line . charAt ( j ) ; if ( ! Character . isDigit ( c ) && c != ',' && c != '.' ) { bytesStart = j + 1 ; MST[rv.CRCR3Mutator]MSP[] break innerLoop2; } j -- ; } if ( j < 0 ) {
final String line2 = lines . get ( 1 ) ; StringTokenizer tok = new StringTokenizer ( line2 , lr_20 ) ; if ( tok . countTokens () < 4 ) { MST[ConditionalsBoundaryMutator]MSP[] if ( tok . countTokens () == 1 && lines . size () >= 3 ) {
final List < String > lines = new ArrayList <> ( 20 ) ; MST[ConstructorCallMutator]MSP[] Process proc = null ; InputStream in = null ; OutputStream out = null ; InputStream err = null ; BufferedReader inr = null ; try {
final String line3 = lines . get ( 2 ) ; tok = new StringTokenizer ( line3 , lr_20 ) ; } else { throw new IOException ( MST[NonVoidMethodCallMutator]MSP[] lr_17 + DF + lr_21 + lr_10 + path + lr_22 ) ; } } else { tok . nextToken () ;
return freeSpaceKb ( path , - 1 ) ; MST[ArgumentPropagationMutator]MSP[] } @Deprecated public static long freeSpaceKb ( final String path , final long timeout ) throws IOException { return INSTANCE . freeSpaceOS ( path , OS , true , timeout ) ; } @Deprecated
for ( int i = lines . size () - 1 ; i >= 0 ; i -- ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[] final String line = lines . get ( i ) ; if ( line . length () > 0 ) { return parseDir ( line , normPath ) ; }
public static long freeSpaceKb () throws IOException { return freeSpaceKb ( - 1 ) ; } @Deprecated public static long freeSpaceKb ( final long timeout ) throws IOException { return freeSpaceKb ( new File ( lr_1 ) . getAbsolutePath () , timeout ) ; MST[rv.ABSMutator]MSP[] }
normPath = lr_5 + normPath + lr_5 ; } final String [] cmdAttribs = new String [] { lr_6 , lr_7 , lr_8 + normPath } ; MST[rv.CRCR1Mutator]MSP[] final List < String > lines = performCommand ( cmdAttribs , Integer . MAX_VALUE , timeout ) ;
flags += lr_15 ; MST[experimental.NakedReceiverMutator]MSP[] } if ( posix ) { flags += lr_16 ; } final String [] cmdAttribs = flags . length () > 1 ? new String [] { DF , flags , path } : new String [] { DF , path } ;
String normPath = FilenameUtils . normalize ( path , false ) ; if ( normPath == null ) { throw new IllegalArgumentException ( path ) ; } if ( normPath . length () > 0 && normPath . charAt ( 0 ) != '"' ) { MST[NegateConditionalsMutator]MSP[]
normPath = lr_5 + normPath + lr_5 ; } final String [] cmdAttribs = new String [] { lr_6 , lr_7 , lr_8 + normPath } ; MST[InlineConstantMutator]MSP[] final List < String > lines = performCommand ( cmdAttribs , Integer . MAX_VALUE , timeout ) ;
return kb ? freeSpaceWindows ( path , timeout ) / FileUtils . ONE_KB : freeSpaceWindows ( path , timeout ) ; MST[rv.UOI4Mutator]MSP[] case UNIX : return freeSpaceUnix ( path , kb , false , timeout ) ; case POSIX_UNIX :
if ( proc . exitValue () != 0 ) { MST[NonVoidMethodCallMutator]MSP[] throw new IOException ( lr_25 + proc . exitValue () + lr_26 + Arrays . asList ( cmdAttribs ) ) ; } if ( lines . isEmpty () ) { throw new IOException ( lr_27 +
String normPath = FilenameUtils . normalize ( path , false ) ; if ( normPath == null ) { throw new IllegalArgumentException ( path ) ; } if ( normPath . length () > 0 && normPath . charAt ( 0 ) != '"' ) { MST[rv.CRCR3Mutator]MSP[]
final char c = line . charAt ( j ) ; MST[rv.UOI2Mutator]MSP[] if ( ! Character . isDigit ( c ) && c != ',' && c != '.' ) { bytesStart = j + 1 ; break innerLoop2; } j -- ; } if ( j < 0 ) {
if ( buf . charAt ( k ) == ',' || buf . charAt ( k ) == '.' ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] buf . deleteCharAt ( k -- ) ; } } return parseBytes ( buf . toString () , path ) ; }
final String line2 = lines . get ( 1 ) ; StringTokenizer tok = new StringTokenizer ( line2 , lr_20 ) ; if ( tok . countTokens () < 4 ) { if ( tok . countTokens () == 1 && lines . size () >= 3 ) { MST[rv.ROR2Mutator]MSP[]
long freeSpaceUnix ( final String path , final boolean kb , final boolean posix , final long timeout ) throws IOException { if ( path . isEmpty () ) { throw new IllegalArgumentException ( lr_13 ) ; } String flags = lr_14 ; if ( kb ) { MST[rv.ROR2Mutator]MSP[]
for ( int i = lines . size () - 1 ; i >= 0 ; i -- ) { MST[rv.CRCR4Mutator]MSP[] final String line = lines . get ( i ) ; if ( line . length () > 0 ) { return parseDir ( line , normPath ) ; }
} throw new IOException ( lr_9 + lr_10 + normPath + lr_11 ) ; } long parseDir ( final String line , final String path ) throws IOException { int bytesStart = 0 ; int bytesEnd = 0 ; MST[rv.CRCR3Mutator]MSP[] int j = line . length () - 1 ;
flags += lr_15 ; } if ( posix ) { flags += lr_16 ; } final String [] cmdAttribs = flags . length () > 1 ? new String [] { DF , flags , path } : new String [] { DF , path } ; MST[InlineConstantMutator]MSP[]
return kb ? freeSpaceWindows ( path , timeout ) / FileUtils . ONE_KB : freeSpaceWindows ( path , timeout ) ; MST[InlineConstantMutator]MSP[] case UNIX : return freeSpaceUnix ( path , kb , false , timeout ) ; case POSIX_UNIX :
inr = new BufferedReader ( new InputStreamReader ( in , Charset . defaultCharset () ) ) ; String line = inr . readLine () ; while ( line != null && lines . size () < max ) { MST[rv.UOI2Mutator]MSP[]
@Deprecated public static long freeSpace ( final String path ) throws IOException { return INSTANCE . freeSpaceOS ( path , OS , false , - 1 ) ; MST[rv.CRCR6Mutator]MSP[] } @Deprecated public static long freeSpaceKb ( final String path ) throws IOException {
for ( int i = lines . size () - 1 ; i >= 0 ; i -- ) { final String line = lines . get ( i ) ; MST[rv.UOI4Mutator]MSP[] if ( line . length () > 0 ) { return parseDir ( line , normPath ) ; }
normPath = lr_5 + normPath + lr_5 ; } final String [] cmdAttribs = new String [] { lr_6 , lr_7 , lr_8 + normPath } ; final List < String > lines = performCommand ( cmdAttribs , Integer . MAX_VALUE , timeout ) ; MST[rv.ABSMutator]MSP[]
flags += lr_15 ; } if ( posix ) { flags += lr_16 ; } final String [] cmdAttribs = flags . length () > 1 ? new String [] { DF , flags , path } : new String [] { DF , path } ; MST[InlineConstantMutator]MSP[]
flags += lr_15 ; } if ( posix ) { flags += lr_16 ; } final String [] cmdAttribs = flags . length () > 1 ? new String [] { DF , flags , path } : new String [] { DF , path } ; MST[rv.ROR5Mutator]MSP[]
innerLoop1: while ( j >= 0 ) { final char c = line . charAt ( j ) ; MST[rv.UOI4Mutator]MSP[] if ( Character . isDigit ( c ) ) { bytesEnd = j + 1 ; break innerLoop1; } j -- ; } innerLoop2: while ( j >= 0 ) {
Process openProcess ( final String [] cmdAttribs ) throws IOException { return Runtime . getRuntime () . exec ( cmdAttribs ) ; MST[NullReturnValsMutator]MSP[] }
return kb ? freeSpaceWindows ( path , timeout ) / FileUtils . ONE_KB : freeSpaceWindows ( path , timeout ) ; MST[rv.AOD1Mutator]MSP[] case UNIX : return freeSpaceUnix ( path , kb , false , timeout ) ; case POSIX_UNIX :
if ( buf . charAt ( k ) == ',' || buf . charAt ( k ) == '.' ) { MST[rv.CRCR3Mutator]MSP[] buf . deleteCharAt ( k -- ) ; } } return parseBytes ( buf . toString () , path ) ; }
innerLoop1: while ( j >= 0 ) { MST[rv.ROR4Mutator]MSP[] final char c = line . charAt ( j ) ; if ( Character . isDigit ( c ) ) { bytesEnd = j + 1 ; break innerLoop1; } j -- ; } innerLoop2: while ( j >= 0 ) {
final long bytes = Long . parseLong ( freeSpace ) ; if ( bytes < 0 ) { MST[rv.UOI3Mutator]MSP[] throw new IOException ( lr_17 + DF + lr_23 + lr_10 + path + lr_22 ) ; } return bytes ; } catch ( final NumberFormatException ex ) {
return kb ? freeSpaceWindows ( path , timeout ) / FileUtils . ONE_KB : freeSpaceWindows ( path , timeout ) ; case UNIX : return freeSpaceUnix ( path , kb , false , timeout ) ; MST[ReturnValsMutator]MSP[] case POSIX_UNIX :
final char c = line . charAt ( j ) ; MST[rv.ABSMutator]MSP[] if ( ! Character . isDigit ( c ) && c != ',' && c != '.' ) { bytesStart = j + 1 ; break innerLoop2; } j -- ; } if ( j < 0 ) {
for ( int i = lines . size () - 1 ; i >= 0 ; i -- ) { final String line = lines . get ( i ) ; if ( line . length () > 0 ) { MST[rv.ROR3Mutator]MSP[] return parseDir ( line , normPath ) ; }
final char c = line . charAt ( j ) ; if ( ! Character . isDigit ( c ) && c != ',' && c != '.' ) { MST[rv.ROR4Mutator]MSP[] bytesStart = j + 1 ; break innerLoop2; } j -- ; } if ( j < 0 ) {
String normPath = FilenameUtils . normalize ( path , false ) ; if ( normPath == null ) { throw new IllegalArgumentException ( path ) ; } if ( normPath . length () > 0 && normPath . charAt ( 0 ) != '"' ) { MST[rv.ROR2Mutator]MSP[]
final String line2 = lines . get ( 1 ) ; StringTokenizer tok = new StringTokenizer ( line2 , lr_20 ) ; if ( tok . countTokens () < 4 ) { if ( tok . countTokens () == 1 && lines . size () >= 3 ) { MST[rv.CRCR3Mutator]MSP[]
final long bytes = Long . parseLong ( freeSpace ) ; if ( bytes < 0 ) { throw new IOException ( MST[NonVoidMethodCallMutator]MSP[] lr_17 + DF + lr_23 + lr_10 + path + lr_22 ) ; } return bytes ; } catch ( final NumberFormatException ex ) {
normPath = lr_5 + normPath + lr_5 ; } final String [] cmdAttribs = new String [] { lr_6 , lr_7 , lr_8 + normPath } ; MST[rv.CRCR5Mutator]MSP[] final List < String > lines = performCommand ( cmdAttribs , Integer . MAX_VALUE , timeout ) ;
return freeSpaceKb ( path , - 1 ) ; } @Deprecated public static long freeSpaceKb ( final String path , final long timeout ) throws IOException { return INSTANCE . freeSpaceOS ( path , OS , true , timeout ) ; MST[ArgumentPropagationMutator]MSP[] } @Deprecated
throw new IOException ( MST[NonVoidMethodCallMutator]MSP[] lr_12 + lr_10 + path + lr_11 ) ; } final StringBuilder buf = new StringBuilder ( line . substring ( bytesStart , bytesEnd ) ) ; for ( int k = 0 ; k < buf . length () ; k ++ ) {
throw new IOException ( lr_12 + lr_10 + path + lr_11 ) ; } final StringBuilder buf = new StringBuilder ( line . substring ( bytesStart , bytesEnd ) ) ; MST[rv.UOI2Mutator]MSP[] for ( int k = 0 ; k < buf . length () ; k ++ ) {
flags += lr_15 ; } if ( posix ) { flags += lr_16 ; } final String [] cmdAttribs = flags . length () > 1 ? new String [] { DF , flags , path } : new String [] { DF , path } ; MST[rv.CRCR6Mutator]MSP[]
if ( proc . exitValue () != 0 ) { throw new IOException ( lr_25 + proc . exitValue () + lr_26 + Arrays . asList ( cmdAttribs ) ) ; } if ( lines . isEmpty () ) { MST[rv.ROR1Mutator]MSP[] throw new IOException ( lr_27 +
if ( proc . exitValue () != 0 ) { throw new IOException ( lr_25 + proc . exitValue () + MST[NonVoidMethodCallMutator]MSP[] lr_26 + Arrays . asList ( cmdAttribs ) ) ; } if ( lines . isEmpty () ) { throw new IOException ( lr_27 +
final long bytes = Long . parseLong ( freeSpace ) ; if ( bytes < 0 ) { MST[rv.UOI1Mutator]MSP[] throw new IOException ( lr_17 + DF + lr_23 + lr_10 + path + lr_22 ) ; } return bytes ; } catch ( final NumberFormatException ex ) {
final List < String > lines = performCommand ( cmdAttribs , 3 , timeout ) ; if ( lines . size () < 2 ) { MST[rv.ROR4Mutator]MSP[] throw new IOException ( lr_17 + DF + lr_18 + lr_10 + path + lr_19 + lines ) ; }
innerLoop1: while ( j >= 0 ) { final char c = line . charAt ( j ) ; MST[rv.ABSMutator]MSP[] if ( Character . isDigit ( c ) ) { bytesEnd = j + 1 ; break innerLoop1; } j -- ; } innerLoop2: while ( j >= 0 ) {
public static long freeSpaceKb () throws IOException { return freeSpaceKb ( - 1 ) ; MST[rv.CRCR6Mutator]MSP[] } @Deprecated public static long freeSpaceKb ( final long timeout ) throws IOException { return freeSpaceKb ( new File ( lr_1 ) . getAbsolutePath () , timeout ) ; }
final String line2 = lines . get ( 1 ) ; StringTokenizer tok = new StringTokenizer ( line2 , lr_20 ) ; if ( tok . countTokens () < 4 ) { if ( tok . countTokens () == 1 && lines . size () >= 3 ) { MST[rv.ROR5Mutator]MSP[]
final List < String > lines = performCommand ( cmdAttribs , 3 , timeout ) ; if ( lines . size () < 2 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[] throw new IOException ( lr_17 + DF + lr_18 + lr_10 + path + lr_19 + lines ) ; }
return kb ? freeSpaceWindows ( path , timeout ) / FileUtils . ONE_KB : freeSpaceWindows ( path , timeout ) ; MST[rv.CRCR4Mutator]MSP[] case UNIX : return freeSpaceUnix ( path , kb , false , timeout ) ; case POSIX_UNIX :
innerLoop1: while ( j >= 0 ) { MST[rv.UOI1Mutator]MSP[] final char c = line . charAt ( j ) ; if ( Character . isDigit ( c ) ) { bytesEnd = j + 1 ; break innerLoop1; } j -- ; } innerLoop2: while ( j >= 0 ) {
innerLoop1: while ( j >= 0 ) { final char c = line . charAt ( j ) ; if ( Character . isDigit ( c ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] bytesEnd = j + 1 ; break innerLoop1; } j -- ; } innerLoop2: while ( j >= 0 ) {
final List < String > lines = new ArrayList <> ( 20 ) ; MST[InlineConstantMutator]MSP[] Process proc = null ; InputStream in = null ; OutputStream out = null ; InputStream err = null ; BufferedReader inr = null ; try {
final List < String > lines = performCommand ( cmdAttribs , 3 , timeout ) ; if ( lines . size () < 2 ) { MST[rv.CRCR1Mutator]MSP[] throw new IOException ( lr_17 + DF + lr_18 + lr_10 + path + lr_19 + lines ) ; }
if ( buf . charAt ( k ) == ',' || buf . charAt ( k ) == '.' ) { MST[rv.ROR1Mutator]MSP[] buf . deleteCharAt ( k -- ) ; } } return parseBytes ( buf . toString () , path ) ; }
} tok . nextToken () ; tok . nextToken () ; final String freeSpace = tok . nextToken () ; return parseBytes ( freeSpace , path ) ; MST[ReturnValsMutator]MSP[] } long parseBytes ( final String freeSpace , final String path ) throws IOException { try {
if ( buf . charAt ( k ) == ',' || buf . charAt ( k ) == '.' ) { MST[rv.CRCR4Mutator]MSP[] buf . deleteCharAt ( k -- ) ; } } return parseBytes ( buf . toString () , path ) ; }
flags += lr_15 ; } if ( posix ) { flags += lr_16 ; } final String [] cmdAttribs = flags . length () > 1 ? new String [] { DF , flags , path } : new String [] { DF , path } ; MST[NegateConditionalsMutator]MSP[]
return freeSpaceKb ( path , - 1 ) ; } @Deprecated public static long freeSpaceKb ( final String path , final long timeout ) throws IOException { return INSTANCE . freeSpaceOS ( path , OS , true , timeout ) ; MST[rv.UOI4Mutator]MSP[] } @Deprecated
if ( buf . charAt ( k ) == ',' || buf . charAt ( k ) == '.' ) { MST[rv.UOI2Mutator]MSP[] buf . deleteCharAt ( k -- ) ; } } return parseBytes ( buf . toString () , path ) ; }
long freeSpaceUnix ( final String path , final boolean kb , final boolean posix , final long timeout ) throws IOException { if ( path . isEmpty () ) { MST[rv.ROR4Mutator]MSP[] throw new IllegalArgumentException ( lr_13 ) ; } String flags = lr_14 ; if ( kb ) {
} throw new IOException ( MST[ConstructorCallMutator]MSP[] lr_9 + lr_10 + normPath + lr_11 ) ; } long parseDir ( final String line , final String path ) throws IOException { int bytesStart = 0 ; int bytesEnd = 0 ; int j = line . length () - 1 ;
final String line3 = lines . get ( 2 ) ; tok = new StringTokenizer ( line3 , lr_20 ) ; } else { throw new IOException ( MST[NonVoidMethodCallMutator]MSP[] lr_17 + DF + lr_21 + lr_10 + path + lr_22 ) ; } } else { tok . nextToken () ;
flags += lr_15 ; } if ( posix ) { flags += lr_16 ; } final String [] cmdAttribs = flags . length () > 1 ? new String [] { DF , flags , path } : new String [] { DF , path } ; MST[rv.CRCR6Mutator]MSP[]
final List < String > lines = performCommand ( cmdAttribs , 3 , timeout ) ; MST[rv.CRCR5Mutator]MSP[] if ( lines . size () < 2 ) { throw new IOException ( lr_17 + DF + lr_18 + lr_10 + path + lr_19 + lines ) ; }
final String line2 = lines . get ( 1 ) ; StringTokenizer tok = new StringTokenizer ( line2 , lr_20 ) ; if ( tok . countTokens () < 4 ) { if ( tok . countTokens () == 1 && lines . size () >= 3 ) { MST[InlineConstantMutator]MSP[]
final char c = line . charAt ( j ) ; MST[rv.UOI4Mutator]MSP[] if ( ! Character . isDigit ( c ) && c != ',' && c != '.' ) { bytesStart = j + 1 ; break innerLoop2; } j -- ; } if ( j < 0 ) {
} throw new IOException ( lr_9 + lr_10 + normPath + lr_11 ) ; } long parseDir ( final String line , final String path ) throws IOException { int bytesStart = 0 ; int bytesEnd = 0 ; int j = line . length () - 1 ; MST[rv.AOR4Mutator]MSP[]
innerLoop1: while ( j >= 0 ) { final char c = line . charAt ( j ) ; if ( Character . isDigit ( c ) ) { bytesEnd = j + 1 ; break innerLoop1; } j -- ; } innerLoop2: while ( j >= 0 ) { MST[rv.UOI1Mutator]MSP[]
final String line2 = lines . get ( 1 ) ; StringTokenizer tok = new StringTokenizer ( line2 , lr_20 ) ; if ( tok . countTokens () < 4 ) { if ( tok . countTokens () == 1 && lines . size () >= 3 ) { MST[NegateConditionalsMutator]MSP[]
flags += lr_15 ; } if ( posix ) { flags += lr_16 ; } final String [] cmdAttribs = flags . length () > 1 ? new String [] { DF , flags , path } : new String [] { DF , path } ; MST[rv.CRCR3Mutator]MSP[]
return freeSpaceKb ( path , - 1 ) ; MST[PrimitiveReturnsMutator]MSP[] } @Deprecated public static long freeSpaceKb ( final String path , final long timeout ) throws IOException { return INSTANCE . freeSpaceOS ( path , OS , true , timeout ) ; } @Deprecated
inr = new BufferedReader ( new InputStreamReader ( in , Charset . defaultCharset () ) ) ; String line = inr . readLine () ; while ( line != null && lines . size () < max ) { MST[rv.ROR1Mutator]MSP[]
for ( int i = lines . size () - 1 ; i >= 0 ; i -- ) { MST[rv.AOR2Mutator]MSP[] final String line = lines . get ( i ) ; if ( line . length () > 0 ) { return parseDir ( line , normPath ) ; }
flags += lr_15 ; } if ( posix ) { flags += lr_16 ; } final String [] cmdAttribs = flags . length () > 1 ? new String [] { DF , flags , path } : new String [] { DF , path } ; MST[rv.CRCR5Mutator]MSP[]
normPath = lr_5 + normPath + lr_5 ; } final String [] cmdAttribs = new String [] { lr_6 , lr_7 , lr_8 + normPath } ; final List < String > lines = performCommand ( cmdAttribs , Integer . MAX_VALUE , timeout ) ; MST[rv.UOI4Mutator]MSP[]
innerLoop1: while ( j >= 0 ) { final char c = line . charAt ( j ) ; if ( Character . isDigit ( c ) ) { bytesEnd = j + 1 ; break innerLoop1; } j -- ; MST[IncrementsMutator]MSP[] } innerLoop2: while ( j >= 0 ) {
throw new IOException ( MST[NonVoidMethodCallMutator]MSP[] lr_17 + DF + lr_24 + lr_10 + path + lr_22 , ex ) ; } } List < String > performCommand ( final String [] cmdAttribs , final int max , final long timeout ) throws IOException {
flags += lr_15 ; } if ( posix ) { MST[rv.ROR4Mutator]MSP[] flags += lr_16 ; } final String [] cmdAttribs = flags . length () > 1 ? new String [] { DF , flags , path } : new String [] { DF , path } ;
final char c = line . charAt ( j ) ; if ( ! Character . isDigit ( c ) && c != ',' && c != '.' ) { bytesStart = j + 1 ; break innerLoop2; } j -- ; } if ( j < 0 ) { MST[rv.ROR1Mutator]MSP[]
throw new IOException ( lr_12 + lr_10 + path + lr_11 ) ; } final StringBuilder buf = new StringBuilder ( line . substring ( bytesStart , bytesEnd ) ) ; MST[experimental.NakedReceiverMutator]MSP[] for ( int k = 0 ; k < buf . length () ; k ++ ) {
innerLoop1: while ( j >= 0 ) { final char c = line . charAt ( j ) ; if ( Character . isDigit ( c ) ) { bytesEnd = j + 1 ; MST[rv.AOR2Mutator]MSP[] break innerLoop1; } j -- ; } innerLoop2: while ( j >= 0 ) {
if ( proc . exitValue () != 0 ) { throw new IOException ( lr_25 + proc . exitValue () + lr_26 + Arrays . asList ( cmdAttribs ) ) ; } if ( lines . isEmpty () ) { MST[NonVoidMethodCallMutator]MSP[] throw new IOException ( lr_27 +
return kb ? freeSpaceWindows ( path , timeout ) / FileUtils . ONE_KB : freeSpaceWindows ( path , timeout ) ; case UNIX : return freeSpaceUnix ( path , kb , false , timeout ) ; MST[rv.CRCR5Mutator]MSP[] case POSIX_UNIX :
flags += lr_15 ; } if ( posix ) { flags += lr_16 ; } final String [] cmdAttribs = flags . length () > 1 ? new String [] { DF , flags , path } : new String [] { DF , path } ; MST[InlineConstantMutator]MSP[]
innerLoop1: while ( j >= 0 ) { final char c = line . charAt ( j ) ; if ( Character . isDigit ( c ) ) { bytesEnd = j + 1 ; MST[MathMutator]MSP[] break innerLoop1; } j -- ; } innerLoop2: while ( j >= 0 ) {
long freeSpaceOS ( final String path , final int os , final boolean kb , final long timeout ) throws IOException { if ( path == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] throw new IllegalArgumentException ( lr_2 ) ; } switch ( os ) { case WINDOWS :
return freeSpaceKb ( path , - 1 ) ; } @Deprecated public static long freeSpaceKb ( final String path , final long timeout ) throws IOException { return INSTANCE . freeSpaceOS ( path , OS , true , timeout ) ; MST[rv.ABSMutator]MSP[] } @Deprecated
normPath = lr_5 + normPath + lr_5 ; } final String [] cmdAttribs = new String [] { lr_6 , lr_7 , lr_8 + normPath } ; MST[NonVoidMethodCallMutator]MSP[] final List < String > lines = performCommand ( cmdAttribs , Integer . MAX_VALUE , timeout ) ;
inr = new BufferedReader ( new InputStreamReader ( in , Charset . defaultCharset () ) ) ; String line = inr . readLine () ; while ( line != null && lines . size () < max ) { MST[ConditionalsBoundaryMutator]MSP[]
return freeSpaceUnix ( path , kb , true , timeout ) ; MST[InlineConstantMutator]MSP[] case OTHER : throw new IllegalStateException ( lr_3 ) ; default: throw new IllegalStateException ( lr_4 ) ; } } long freeSpaceWindows ( final String path , final long timeout ) throws IOException {
if ( buf . charAt ( k ) == ',' || buf . charAt ( k ) == '.' ) { MST[rv.UOI3Mutator]MSP[] buf . deleteCharAt ( k -- ) ; } } return parseBytes ( buf . toString () , path ) ; }
final long bytes = Long . parseLong ( freeSpace ) ; if ( bytes < 0 ) { throw new IOException ( MST[NonVoidMethodCallMutator]MSP[] lr_17 + DF + lr_23 + lr_10 + path + lr_22 ) ; } return bytes ; } catch ( final NumberFormatException ex ) {
final char c = line . charAt ( j ) ; if ( ! Character . isDigit ( c ) && c != ',' && c != '.' ) { MST[rv.UOI2Mutator]MSP[] bytesStart = j + 1 ; break innerLoop2; } j -- ; } if ( j < 0 ) {
return kb ? freeSpaceWindows ( path , timeout ) / FileUtils . ONE_KB : freeSpaceWindows ( path , timeout ) ; MST[rv.UOI3Mutator]MSP[] case UNIX : return freeSpaceUnix ( path , kb , false , timeout ) ; case POSIX_UNIX :
normPath = lr_5 + normPath + lr_5 ; } final String [] cmdAttribs = new String [] { lr_6 , lr_7 , lr_8 + normPath } ; MST[ConstructorCallMutator]MSP[] final List < String > lines = performCommand ( cmdAttribs , Integer . MAX_VALUE , timeout ) ;
final char c = line . charAt ( j ) ; if ( ! Character . isDigit ( c ) && c != ',' && c != '.' ) { MST[rv.ROR2Mutator]MSP[] bytesStart = j + 1 ; break innerLoop2; } j -- ; } if ( j < 0 ) {
} finally { IOUtils . closeQuietly ( in ) ; IOUtils . closeQuietly ( out ) ; IOUtils . closeQuietly ( err ) ; IOUtils . closeQuietly ( inr ) ; if ( proc != null ) { proc . destroy () ; MST[VoidMethodCallMutator]MSP[] } } }
for ( int i = lines . size () - 1 ; i >= 0 ; i -- ) { final String line = lines . get ( i ) ; if ( line . length () > 0 ) { return parseDir ( line , normPath ) ; MST[ReturnValsMutator]MSP[] }
throw new IOException ( lr_12 + lr_10 + path + lr_11 ) ; } final StringBuilder buf = new StringBuilder ( line . substring ( bytesStart , bytesEnd ) ) ; for ( int k = 0 ; k < buf . length () ; k ++ ) { MST[rv.UOI4Mutator]MSP[]
} throw new IOException ( lr_9 + lr_10 + normPath + lr_11 ) ; } long parseDir ( final String line , final String path ) throws IOException { int bytesStart = 0 ; int bytesEnd = 0 ; int j = line . length () - 1 ; MST[rv.AOD2Mutator]MSP[]
long freeSpaceOS ( final String path , final int os , final boolean kb , final long timeout ) throws IOException { if ( path == null ) { throw new IllegalArgumentException ( lr_2 ) ; } switch ( os ) { MST[experimental.RemoveSwitchMutator_0]MSP[] case WINDOWS :
return kb ? freeSpaceWindows ( path , timeout ) / FileUtils . ONE_KB : freeSpaceWindows ( path , timeout ) ; MST[rv.ROR4Mutator]MSP[] case UNIX : return freeSpaceUnix ( path , kb , false , timeout ) ; case POSIX_UNIX :
lr_28 + Arrays . asList ( cmdAttribs ) ) ; } inr . close () ; inr = null ; in . close () ; MST[VoidMethodCallMutator]MSP[] in = null ; if ( out != null ) { out . close () ; out = null ; }
final String line2 = lines . get ( 1 ) ; StringTokenizer tok = new StringTokenizer ( line2 , lr_20 ) ; if ( tok . countTokens () < 4 ) { MST[rv.CRCR6Mutator]MSP[] if ( tok . countTokens () == 1 && lines . size () >= 3 ) {
final long bytes = Long . parseLong ( freeSpace ) ; if ( bytes < 0 ) { MST[rv.CRCR3Mutator]MSP[] throw new IOException ( lr_17 + DF + lr_23 + lr_10 + path + lr_22 ) ; } return bytes ; } catch ( final NumberFormatException ex ) {
final List < String > lines = new ArrayList <> ( 20 ) ; MST[rv.CRCR2Mutator]MSP[] Process proc = null ; InputStream in = null ; OutputStream out = null ; InputStream err = null ; BufferedReader inr = null ; try {
return kb ? freeSpaceWindows ( path , timeout ) / FileUtils . ONE_KB : freeSpaceWindows ( path , timeout ) ; MST[rv.UOI1Mutator]MSP[] case UNIX : return freeSpaceUnix ( path , kb , false , timeout ) ; case POSIX_UNIX :
inr = new BufferedReader ( new InputStreamReader ( in , Charset . defaultCharset () ) ) ; String line = inr . readLine () ; while ( line != null && lines . size () < max ) { MST[rv.ABSMutator]MSP[]
throw new IOException ( MST[NonVoidMethodCallMutator]MSP[] lr_12 + lr_10 + path + lr_11 ) ; } final StringBuilder buf = new StringBuilder ( line . substring ( bytesStart , bytesEnd ) ) ; for ( int k = 0 ; k < buf . length () ; k ++ ) {
innerLoop1: while ( j >= 0 ) { final char c = line . charAt ( j ) ; if ( Character . isDigit ( c ) ) { bytesEnd = j + 1 ; MST[rv.UOI1Mutator]MSP[] break innerLoop1; } j -- ; } innerLoop2: while ( j >= 0 ) {
final String line2 = lines . get ( 1 ) ; StringTokenizer tok = new StringTokenizer ( line2 , lr_20 ) ; if ( tok . countTokens () < 4 ) { if ( tok . countTokens () == 1 && lines . size () >= 3 ) { MST[NonVoidMethodCallMutator]MSP[]
} finally { IOUtils . closeQuietly ( in ) ; IOUtils . closeQuietly ( out ) ; IOUtils . closeQuietly ( err ) ; IOUtils . closeQuietly ( inr ) ; if ( proc != null ) { MST[rv.ROR5Mutator]MSP[] proc . destroy () ; } } }
String normPath = FilenameUtils . normalize ( path , false ) ; if ( normPath == null ) { throw new IllegalArgumentException ( path ) ; } if ( normPath . length () > 0 && normPath . charAt ( 0 ) != '"' ) { MST[rv.CRCR6Mutator]MSP[]
innerLoop1: while ( j >= 0 ) { final char c = line . charAt ( j ) ; if ( Character . isDigit ( c ) ) { MST[rv.ROR2Mutator]MSP[] bytesEnd = j + 1 ; break innerLoop1; } j -- ; } innerLoop2: while ( j >= 0 ) {
long freeSpaceOS ( final String path , final int os , final boolean kb , final long timeout ) throws IOException { if ( path == null ) { throw new IllegalArgumentException ( lr_2 ) ; } switch ( os ) { MST[experimental.RemoveSwitchMutator_2]MSP[] case WINDOWS :
long freeSpaceOS ( final String path , final int os , final boolean kb , final long timeout ) throws IOException { if ( path == null ) { throw new IllegalArgumentException ( lr_2 ) ; } switch ( os ) { MST[experimental.RemoveSwitchMutator_1]MSP[] case WINDOWS :
return kb ? freeSpaceWindows ( path , timeout ) / FileUtils . ONE_KB : freeSpaceWindows ( path , timeout ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] case UNIX : return freeSpaceUnix ( path , kb , false , timeout ) ; case POSIX_UNIX :
long freeSpaceOS ( final String path , final int os , final boolean kb , final long timeout ) throws IOException { if ( path == null ) { throw new IllegalArgumentException ( lr_2 ) ; } switch ( os ) { MST[experimental.RemoveSwitchMutator_3]MSP[] case WINDOWS :
for ( int i = lines . size () - 1 ; i >= 0 ; i -- ) { MST[rv.UOI3Mutator]MSP[] final String line = lines . get ( i ) ; if ( line . length () > 0 ) { return parseDir ( line , normPath ) ; }
return kb ? freeSpaceWindows ( path , timeout ) / FileUtils . ONE_KB : freeSpaceWindows ( path , timeout ) ; MST[rv.AOR3Mutator]MSP[] case UNIX : return freeSpaceUnix ( path , kb , false , timeout ) ; case POSIX_UNIX :
if ( proc . exitValue () != 0 ) { MST[rv.ROR1Mutator]MSP[] throw new IOException ( lr_25 + proc . exitValue () + lr_26 + Arrays . asList ( cmdAttribs ) ) ; } if ( lines . isEmpty () ) { throw new IOException ( lr_27 +
final List < String > lines = performCommand ( cmdAttribs , 3 , timeout ) ; if ( lines . size () < 2 ) { MST[rv.CRCR2Mutator]MSP[] throw new IOException ( lr_17 + DF + lr_18 + lr_10 + path + lr_19 + lines ) ; }
if ( proc . exitValue () != 0 ) { throw new IOException ( lr_25 + proc . exitValue () + lr_26 + Arrays . asList ( cmdAttribs ) ) ; } if ( lines . isEmpty () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] throw new IOException ( lr_27 +
return freeSpaceKb ( path , - 1 ) ; } @Deprecated public static long freeSpaceKb ( final String path , final long timeout ) throws IOException { return INSTANCE . freeSpaceOS ( path , OS , true , timeout ) ; MST[rv.UOI4Mutator]MSP[] } @Deprecated
innerLoop1: while ( j >= 0 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[] final char c = line . charAt ( j ) ; if ( Character . isDigit ( c ) ) { bytesEnd = j + 1 ; break innerLoop1; } j -- ; } innerLoop2: while ( j >= 0 ) {
lr_28 + Arrays . asList ( cmdAttribs ) ) ; MST[NonVoidMethodCallMutator]MSP[] } inr . close () ; inr = null ; in . close () ; in = null ; if ( out != null ) { out . close () ; out = null ; }
if ( proc . exitValue () != 0 ) { throw new IOException ( lr_25 + proc . exitValue () + lr_26 + Arrays . asList ( cmdAttribs ) ) ; MST[experimental.NakedReceiverMutator]MSP[] } if ( lines . isEmpty () ) { throw new IOException ( lr_27 +
final String line3 = lines . get ( 2 ) ; tok = new StringTokenizer ( line3 , lr_20 ) ; } else { throw new IOException ( MST[NonVoidMethodCallMutator]MSP[] lr_17 + DF + lr_21 + lr_10 + path + lr_22 ) ; } } else { tok . nextToken () ;
String normPath = FilenameUtils . normalize ( path , false ) ; if ( normPath == null ) { throw new IllegalArgumentException ( path ) ; } if ( normPath . length () > 0 && normPath . charAt ( 0 ) != '"' ) { MST[rv.ROR1Mutator]MSP[]
line = line . toLowerCase ( Locale . ENGLISH ) . trim () ; MST[experimental.NakedReceiverMutator]MSP[] lines . add ( line ) ; line = inr . readLine () ; } proc . waitFor () ; ThreadMonitor . stop ( monitor ) ;
long freeSpaceUnix ( final String path , final boolean kb , final boolean posix , final long timeout ) throws IOException { if ( path . isEmpty () ) { throw new IllegalArgumentException ( lr_13 ) ; } String flags = lr_14 ; if ( kb ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
innerLoop1: while ( j >= 0 ) { final char c = line . charAt ( j ) ; if ( Character . isDigit ( c ) ) { bytesEnd = j + 1 ; MST[rv.CRCR3Mutator]MSP[] break innerLoop1; } j -- ; } innerLoop2: while ( j >= 0 ) {
final char c = line . charAt ( j ) ; if ( ! Character . isDigit ( c ) && c != ',' && c != '.' ) { bytesStart = j + 1 ; MST[rv.UOI3Mutator]MSP[] break innerLoop2; } j -- ; } if ( j < 0 ) {
normPath = lr_5 + normPath + lr_5 ; } final String [] cmdAttribs = new String [] { lr_6 , lr_7 , lr_8 + normPath } ; MST[InlineConstantMutator]MSP[] final List < String > lines = performCommand ( cmdAttribs , Integer . MAX_VALUE , timeout ) ;
final char c = line . charAt ( j ) ; if ( ! Character . isDigit ( c ) && c != ',' && c != '.' ) { MST[rv.ROR3Mutator]MSP[] bytesStart = j + 1 ; break innerLoop2; } j -- ; } if ( j < 0 ) {
public static long freeSpaceKb () throws IOException { return freeSpaceKb ( - 1 ) ; } @Deprecated public static long freeSpaceKb ( final long timeout ) throws IOException { return freeSpaceKb ( new File ( lr_1 ) . getAbsolutePath () , timeout ) ; MST[rv.UOI2Mutator]MSP[] }
final String line2 = lines . get ( 1 ) ; StringTokenizer tok = new StringTokenizer ( line2 , lr_20 ) ; if ( tok . countTokens () < 4 ) { if ( tok . countTokens () == 1 && lines . size () >= 3 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
throw new IOException ( lr_12 + lr_10 + path + lr_11 ) ; } final StringBuilder buf = new StringBuilder ( line . substring ( bytesStart , bytesEnd ) ) ; for ( int k = 0 ; k < buf . length () ; k ++ ) { MST[rv.ROR2Mutator]MSP[]
if ( buf . charAt ( k ) == ',' || buf . charAt ( k ) == '.' ) { MST[NegateConditionalsMutator]MSP[] buf . deleteCharAt ( k -- ) ; } } return parseBytes ( buf . toString () , path ) ; }
if ( proc . exitValue () != 0 ) { throw new IOException ( lr_25 + proc . exitValue () + lr_26 + Arrays . asList ( cmdAttribs ) ) ; } if ( lines . isEmpty () ) { throw new IOException ( MST[ConstructorCallMutator]MSP[] lr_27 +
innerLoop1: while ( j >= 0 ) { final char c = line . charAt ( j ) ; if ( Character . isDigit ( c ) ) { bytesEnd = j + 1 ; break innerLoop1; } j -- ; } innerLoop2: while ( j >= 0 ) { MST[rv.ROR4Mutator]MSP[]
long freeSpaceUnix ( final String path , final boolean kb , final boolean posix , final long timeout ) throws IOException { if ( path . isEmpty () ) { throw new IllegalArgumentException ( lr_13 ) ; } String flags = lr_14 ; if ( kb ) { MST[rv.UOI1Mutator]MSP[]
innerLoop1: while ( j >= 0 ) { final char c = line . charAt ( j ) ; if ( Character . isDigit ( c ) ) { bytesEnd = j + 1 ; break innerLoop1; } j -- ; } innerLoop2: while ( j >= 0 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[]
throw new IOException ( MST[NonVoidMethodCallMutator]MSP[] lr_17 + DF + lr_24 + lr_10 + path + lr_22 , ex ) ; } } List < String > performCommand ( final String [] cmdAttribs , final int max , final long timeout ) throws IOException {
line = line . toLowerCase ( Locale . ENGLISH ) . trim () ; lines . add ( line ) ; MST[NonVoidMethodCallMutator]MSP[] line = inr . readLine () ; } proc . waitFor () ; ThreadMonitor . stop ( monitor ) ;
final char c = line . charAt ( j ) ; if ( ! Character . isDigit ( c ) && c != ',' && c != '.' ) { MST[InlineConstantMutator]MSP[] bytesStart = j + 1 ; break innerLoop2; } j -- ; } if ( j < 0 ) {
final List < String > lines = performCommand ( cmdAttribs , 3 , timeout ) ; MST[rv.ABSMutator]MSP[] if ( lines . size () < 2 ) { throw new IOException ( lr_17 + DF + lr_18 + lr_10 + path + lr_19 + lines ) ; }
return freeSpaceUnix ( path , kb , true , timeout ) ; MST[rv.UOI2Mutator]MSP[] case OTHER : throw new IllegalStateException ( lr_3 ) ; default: throw new IllegalStateException ( lr_4 ) ; } } long freeSpaceWindows ( final String path , final long timeout ) throws IOException {
} throw new IOException ( lr_9 + lr_10 + normPath + lr_11 ) ; } long parseDir ( final String line , final String path ) throws IOException { int bytesStart = 0 ; MST[rv.CRCR3Mutator]MSP[] int bytesEnd = 0 ; int j = line . length () - 1 ;
String normPath = FilenameUtils . normalize ( path , false ) ; if ( normPath == null ) { throw new IllegalArgumentException ( path ) ; MST[ConstructorCallMutator]MSP[] } if ( normPath . length () > 0 && normPath . charAt ( 0 ) != '"' ) {
if ( buf . charAt ( k ) == ',' || buf . charAt ( k ) == '.' ) { MST[rv.ROR1Mutator]MSP[] buf . deleteCharAt ( k -- ) ; } } return parseBytes ( buf . toString () , path ) ; }
if ( buf . charAt ( k ) == ',' || buf . charAt ( k ) == '.' ) { MST[rv.CRCR4Mutator]MSP[] buf . deleteCharAt ( k -- ) ; } } return parseBytes ( buf . toString () , path ) ; }
} throw new IOException ( lr_9 + lr_10 + normPath + lr_11 ) ; } long parseDir ( final String line , final String path ) throws IOException { int bytesStart = 0 ; int bytesEnd = 0 ; int j = line . length () - 1 ; MST[InlineConstantMutator]MSP[]
innerLoop1: while ( j >= 0 ) { MST[rv.ROR5Mutator]MSP[] final char c = line . charAt ( j ) ; if ( Character . isDigit ( c ) ) { bytesEnd = j + 1 ; break innerLoop1; } j -- ; } innerLoop2: while ( j >= 0 ) {
flags += lr_15 ; } if ( posix ) { flags += lr_16 ; } final String [] cmdAttribs = flags . length () > 1 ? new String [] { DF , flags , path } : new String [] { DF , path } ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[]
final long bytes = Long . parseLong ( freeSpace ) ; if ( bytes < 0 ) { MST[rv.UOI4Mutator]MSP[] throw new IOException ( lr_17 + DF + lr_23 + lr_10 + path + lr_22 ) ; } return bytes ; } catch ( final NumberFormatException ex ) {
String normPath = FilenameUtils . normalize ( path , false ) ; if ( normPath == null ) { throw new IllegalArgumentException ( path ) ; } if ( normPath . length () > 0 && normPath . charAt ( 0 ) != '"' ) { MST[rv.ROR3Mutator]MSP[]
final String line2 = lines . get ( 1 ) ; StringTokenizer tok = new StringTokenizer ( line2 , lr_20 ) ; if ( tok . countTokens () < 4 ) { if ( tok . countTokens () == 1 && lines . size () >= 3 ) { MST[rv.CRCR6Mutator]MSP[]
return freeSpaceKb ( path , - 1 ) ; MST[NonVoidMethodCallMutator]MSP[] } @Deprecated public static long freeSpaceKb ( final String path , final long timeout ) throws IOException { return INSTANCE . freeSpaceOS ( path , OS , true , timeout ) ; } @Deprecated
String normPath = FilenameUtils . normalize ( path , false ) ; if ( normPath == null ) { throw new IllegalArgumentException ( path ) ; } if ( normPath . length () > 0 && normPath . charAt ( 0 ) != '"' ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
return kb ? freeSpaceWindows ( path , timeout ) / FileUtils . ONE_KB : freeSpaceWindows ( path , timeout ) ; case UNIX : return freeSpaceUnix ( path , kb , false , timeout ) ; MST[rv.UOI1Mutator]MSP[] case POSIX_UNIX :
throw new IOException ( MST[experimental.NakedReceiverMutator]MSP[] lr_17 + DF + lr_24 + lr_10 + path + lr_22 , ex ) ; } } List < String > performCommand ( final String [] cmdAttribs , final int max , final long timeout ) throws IOException {
final String line2 = lines . get ( 1 ) ; StringTokenizer tok = new StringTokenizer ( line2 , lr_20 ) ; if ( tok . countTokens () < 4 ) { if ( tok . countTokens () == 1 && lines . size () >= 3 ) { MST[rv.CRCR3Mutator]MSP[]
normPath = lr_5 + normPath + lr_5 ; } final String [] cmdAttribs = new String [] { lr_6 , lr_7 , lr_8 + normPath } ; MST[rv.CRCR4Mutator]MSP[] final List < String > lines = performCommand ( cmdAttribs , Integer . MAX_VALUE , timeout ) ;
final char c = line . charAt ( j ) ; if ( ! Character . isDigit ( c ) && c != ',' && c != '.' ) { MST[rv.ROR5Mutator]MSP[] bytesStart = j + 1 ; break innerLoop2; } j -- ; } if ( j < 0 ) {
final char c = line . charAt ( j ) ; if ( ! Character . isDigit ( c ) && c != ',' && c != '.' ) { bytesStart = j + 1 ; MST[rv.AOR2Mutator]MSP[] break innerLoop2; } j -- ; } if ( j < 0 ) {
flags += lr_15 ; } if ( posix ) { flags += lr_16 ; } final String [] cmdAttribs = flags . length () > 1 ? new String [] { DF , flags , path } : new String [] { DF , path } ; MST[rv.CRCR6Mutator]MSP[]
final List < String > lines = performCommand ( cmdAttribs , 3 , timeout ) ; MST[rv.UOI4Mutator]MSP[] if ( lines . size () < 2 ) { throw new IOException ( lr_17 + DF + lr_18 + lr_10 + path + lr_19 + lines ) ; }
normPath = lr_5 + normPath + lr_5 ; } final String [] cmdAttribs = new String [] { lr_6 , lr_7 , lr_8 + normPath } ; MST[experimental.NakedReceiverMutator]MSP[] final List < String > lines = performCommand ( cmdAttribs , Integer . MAX_VALUE , timeout ) ;
final String line2 = lines . get ( 1 ) ; StringTokenizer tok = new StringTokenizer ( line2 , lr_20 ) ; if ( tok . countTokens () < 4 ) { if ( tok . countTokens () == 1 && lines . size () >= 3 ) { MST[rv.ROR3Mutator]MSP[]
final char c = line . charAt ( j ) ; if ( ! Character . isDigit ( c ) && c != ',' && c != '.' ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] bytesStart = j + 1 ; break innerLoop2; } j -- ; } if ( j < 0 ) {
final String line2 = lines . get ( 1 ) ; StringTokenizer tok = new StringTokenizer ( line2 , lr_20 ) ; if ( tok . countTokens () < 4 ) { if ( tok . countTokens () == 1 && lines . size () >= 3 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[]
lr_28 + Arrays . asList ( cmdAttribs ) ) ; MST[ConstructorCallMutator]MSP[] } inr . close () ; inr = null ; in . close () ; in = null ; if ( out != null ) { out . close () ; out = null ; }
innerLoop1: while ( j >= 0 ) { final char c = line . charAt ( j ) ; if ( Character . isDigit ( c ) ) { bytesEnd = j + 1 ; break innerLoop1; } j -- ; } innerLoop2: while ( j >= 0 ) { MST[rv.ROR5Mutator]MSP[]
long freeSpaceUnix ( final String path , final boolean kb , final boolean posix , final long timeout ) throws IOException { if ( path . isEmpty () ) { throw new IllegalArgumentException ( lr_13 ) ; } String flags = lr_14 ; if ( kb ) { MST[rv.ROR3Mutator]MSP[]
return kb ? freeSpaceWindows ( path , timeout ) / FileUtils . ONE_KB : freeSpaceWindows ( path , timeout ) ; MST[NegateConditionalsMutator]MSP[] case UNIX : return freeSpaceUnix ( path , kb , false , timeout ) ; case POSIX_UNIX :
final String line2 = lines . get ( 1 ) ; StringTokenizer tok = new StringTokenizer ( line2 , lr_20 ) ; MST[ConstructorCallMutator]MSP[] if ( tok . countTokens () < 4 ) { if ( tok . countTokens () == 1 && lines . size () >= 3 ) {
normPath = lr_5 + normPath + lr_5 ; MST[ConstructorCallMutator]MSP[] } final String [] cmdAttribs = new String [] { lr_6 , lr_7 , lr_8 + normPath } ; final List < String > lines = performCommand ( cmdAttribs , Integer . MAX_VALUE , timeout ) ;
inr = new BufferedReader ( new InputStreamReader ( in , Charset . defaultCharset () ) ) ; String line = inr . readLine () ; while ( line != null && lines . size () < max ) { MST[rv.UOI3Mutator]MSP[]
final char c = line . charAt ( j ) ; if ( ! Character . isDigit ( c ) && c != ',' && c != '.' ) { bytesStart = j + 1 ; break innerLoop2; } j -- ; } if ( j < 0 ) { MST[rv.ROR2Mutator]MSP[]
flags += lr_15 ; } if ( posix ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] flags += lr_16 ; } final String [] cmdAttribs = flags . length () > 1 ? new String [] { DF , flags , path } : new String [] { DF , path } ;
flags += lr_15 ; } if ( posix ) { flags += lr_16 ; } final String [] cmdAttribs = flags . length () > 1 ? new String [] { DF , flags , path } : new String [] { DF , path } ; MST[rv.CRCR3Mutator]MSP[]
final char c = line . charAt ( j ) ; if ( ! Character . isDigit ( c ) && c != ',' && c != '.' ) { bytesStart = j + 1 ; break innerLoop2; } j -- ; } if ( j < 0 ) { MST[rv.UOI1Mutator]MSP[]
flags += lr_15 ; } if ( posix ) { MST[rv.UOI2Mutator]MSP[] flags += lr_16 ; } final String [] cmdAttribs = flags . length () > 1 ? new String [] { DF , flags , path } : new String [] { DF , path } ;
if ( proc . exitValue () != 0 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] throw new IOException ( lr_25 + proc . exitValue () + lr_26 + Arrays . asList ( cmdAttribs ) ) ; } if ( lines . isEmpty () ) { throw new IOException ( lr_27 +
return freeSpaceKb ( path , - 1 ) ; MST[rv.CRCR2Mutator]MSP[] } @Deprecated public static long freeSpaceKb ( final String path , final long timeout ) throws IOException { return INSTANCE . freeSpaceOS ( path , OS , true , timeout ) ; } @Deprecated
return freeSpaceKb ( path , - 1 ) ; } @Deprecated public static long freeSpaceKb ( final String path , final long timeout ) throws IOException { return INSTANCE . freeSpaceOS ( path , OS , true , timeout ) ; MST[rv.UOI2Mutator]MSP[] } @Deprecated
long freeSpaceOS ( final String path , final int os , final boolean kb , final long timeout ) throws IOException { if ( path == null ) { MST[NegateConditionalsMutator]MSP[] throw new IllegalArgumentException ( lr_2 ) ; } switch ( os ) { case WINDOWS :
innerLoop1: while ( j >= 0 ) { MST[rv.UOI4Mutator]MSP[] final char c = line . charAt ( j ) ; if ( Character . isDigit ( c ) ) { bytesEnd = j + 1 ; break innerLoop1; } j -- ; } innerLoop2: while ( j >= 0 ) {
if ( buf . charAt ( k ) == ',' || buf . charAt ( k ) == '.' ) { MST[rv.CRCR5Mutator]MSP[] buf . deleteCharAt ( k -- ) ; } } return parseBytes ( buf . toString () , path ) ; }
if ( proc . exitValue () != 0 ) { throw new IOException ( MST[NonVoidMethodCallMutator]MSP[] lr_25 + proc . exitValue () + lr_26 + Arrays . asList ( cmdAttribs ) ) ; } if ( lines . isEmpty () ) { throw new IOException ( lr_27 +
String normPath = FilenameUtils . normalize ( path , false ) ; if ( normPath == null ) { throw new IllegalArgumentException ( path ) ; } if ( normPath . length () > 0 && normPath . charAt ( 0 ) != '"' ) { MST[rv.ROR2Mutator]MSP[]
return freeSpaceKb ( path , - 1 ) ; } @Deprecated public static long freeSpaceKb ( final String path , final long timeout ) throws IOException { return INSTANCE . freeSpaceOS ( path , OS , true , timeout ) ; MST[NonVoidMethodCallMutator]MSP[] } @Deprecated
long freeSpaceUnix ( final String path , final boolean kb , final boolean posix , final long timeout ) throws IOException { if ( path . isEmpty () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] throw new IllegalArgumentException ( lr_13 ) ; } String flags = lr_14 ; if ( kb ) {
if ( buf . charAt ( k ) == ',' || buf . charAt ( k ) == '.' ) { MST[rv.UOI3Mutator]MSP[] buf . deleteCharAt ( k -- ) ; } } return parseBytes ( buf . toString () , path ) ; }
return kb ? freeSpaceWindows ( path , timeout ) / FileUtils . ONE_KB : freeSpaceWindows ( path , timeout ) ; case UNIX : return freeSpaceUnix ( path , kb , false , timeout ) ; MST[rv.ABSMutator]MSP[] case POSIX_UNIX :
final char c = line . charAt ( j ) ; if ( ! Character . isDigit ( c ) && c != ',' && c != '.' ) { bytesStart = j + 1 ; MST[rv.UOI1Mutator]MSP[] break innerLoop2; } j -- ; } if ( j < 0 ) {
final char c = line . charAt ( j ) ; if ( ! Character . isDigit ( c ) && c != ',' && c != '.' ) { MST[rv.ROR4Mutator]MSP[] bytesStart = j + 1 ; break innerLoop2; } j -- ; } if ( j < 0 ) {
for ( int i = lines . size () - 1 ; i >= 0 ; i -- ) { MST[rv.UOI4Mutator]MSP[] final String line = lines . get ( i ) ; if ( line . length () > 0 ) { return parseDir ( line , normPath ) ; }
public static long freeSpaceKb () throws IOException { return freeSpaceKb ( - 1 ) ; } @Deprecated public static long freeSpaceKb ( final long timeout ) throws IOException { return freeSpaceKb ( new File ( lr_1 ) . getAbsolutePath () , timeout ) ; MST[rv.UOI4Mutator]MSP[] }
final String line2 = lines . get ( 1 ) ; MST[rv.CRCR5Mutator]MSP[] StringTokenizer tok = new StringTokenizer ( line2 , lr_20 ) ; if ( tok . countTokens () < 4 ) { if ( tok . countTokens () == 1 && lines . size () >= 3 ) {
} finally { IOUtils . closeQuietly ( in ) ; IOUtils . closeQuietly ( out ) ; IOUtils . closeQuietly ( err ) ; IOUtils . closeQuietly ( inr ) ; if ( proc != null ) { MST[NegateConditionalsMutator]MSP[] proc . destroy () ; } } }
for ( int i = lines . size () - 1 ; i >= 0 ; i -- ) { final String line = lines . get ( i ) ; if ( line . length () > 0 ) { MST[NonVoidMethodCallMutator]MSP[] return parseDir ( line , normPath ) ; }
throw new IOException ( lr_12 + lr_10 + path + lr_11 ) ; } final StringBuilder buf = new StringBuilder ( line . substring ( bytesStart , bytesEnd ) ) ; MST[rv.UOI3Mutator]MSP[] for ( int k = 0 ; k < buf . length () ; k ++ ) {
final String line2 = lines . get ( 1 ) ; StringTokenizer tok = new StringTokenizer ( line2 , lr_20 ) ; if ( tok . countTokens () < 4 ) { MST[rv.ROR2Mutator]MSP[] if ( tok . countTokens () == 1 && lines . size () >= 3 ) {
final String line3 = lines . get ( 2 ) ; tok = new StringTokenizer ( line3 , lr_20 ) ; } else { throw new IOException ( MST[experimental.NakedReceiverMutator]MSP[] lr_17 + DF + lr_21 + lr_10 + path + lr_22 ) ; } } else { tok . nextToken () ;
} throw new IOException ( lr_9 + lr_10 + normPath + lr_11 ) ; } long parseDir ( final String line , final String path ) throws IOException { int bytesStart = 0 ; int bytesEnd = 0 ; MST[rv.CRCR1Mutator]MSP[] int j = line . length () - 1 ;
public static long freeSpaceKb () throws IOException { return freeSpaceKb ( - 1 ) ; MST[rv.CRCR1Mutator]MSP[] } @Deprecated public static long freeSpaceKb ( final long timeout ) throws IOException { return freeSpaceKb ( new File ( lr_1 ) . getAbsolutePath () , timeout ) ; }
public static long freeSpaceKb () throws IOException { return freeSpaceKb ( - 1 ) ; MST[rv.CRCR5Mutator]MSP[] } @Deprecated public static long freeSpaceKb ( final long timeout ) throws IOException { return freeSpaceKb ( new File ( lr_1 ) . getAbsolutePath () , timeout ) ; }
throw new IOException ( MST[NonVoidMethodCallMutator]MSP[] lr_17 + DF + lr_24 + lr_10 + path + lr_22 , ex ) ; } } List < String > performCommand ( final String [] cmdAttribs , final int max , final long timeout ) throws IOException {
@Deprecated public static long freeSpace ( final String path ) throws IOException { return INSTANCE . freeSpaceOS ( path , OS , false , - 1 ) ; MST[rv.UOI2Mutator]MSP[] } @Deprecated public static long freeSpaceKb ( final String path ) throws IOException {
return kb ? freeSpaceWindows ( path , timeout ) / FileUtils . ONE_KB : freeSpaceWindows ( path , timeout ) ; MST[rv.CRCR5Mutator]MSP[] case UNIX : return freeSpaceUnix ( path , kb , false , timeout ) ; case POSIX_UNIX :
return kb ? freeSpaceWindows ( path , timeout ) / FileUtils . ONE_KB : freeSpaceWindows ( path , timeout ) ; case UNIX : return freeSpaceUnix ( path , kb , false , timeout ) ; MST[rv.CRCR6Mutator]MSP[] case POSIX_UNIX :
inr = new BufferedReader ( new InputStreamReader ( in , Charset . defaultCharset () ) ) ; MST[ConstructorCallMutator]MSP[] String line = inr . readLine () ; while ( line != null && lines . size () < max ) {
return kb ? freeSpaceWindows ( path , timeout ) / FileUtils . ONE_KB : freeSpaceWindows ( path , timeout ) ; case UNIX : return freeSpaceUnix ( path , kb , false , timeout ) ; MST[rv.CRCR1Mutator]MSP[] case POSIX_UNIX :
if ( buf . charAt ( k ) == ',' || buf . charAt ( k ) == '.' ) { MST[rv.UOI4Mutator]MSP[] buf . deleteCharAt ( k -- ) ; } } return parseBytes ( buf . toString () , path ) ; }
return kb ? freeSpaceWindows ( path , timeout ) / FileUtils . ONE_KB : freeSpaceWindows ( path , timeout ) ; MST[NonVoidMethodCallMutator]MSP[] case UNIX : return freeSpaceUnix ( path , kb , false , timeout ) ; case POSIX_UNIX :
final char c = line . charAt ( j ) ; if ( ! Character . isDigit ( c ) && c != ',' && c != '.' ) { MST[rv.UOI3Mutator]MSP[] bytesStart = j + 1 ; break innerLoop2; } j -- ; } if ( j < 0 ) {
final String line2 = lines . get ( 1 ) ; StringTokenizer tok = new StringTokenizer ( line2 , lr_20 ) ; if ( tok . countTokens () < 4 ) { MST[rv.CRCR4Mutator]MSP[] if ( tok . countTokens () == 1 && lines . size () >= 3 ) {
if ( buf . charAt ( k ) == ',' || buf . charAt ( k ) == '.' ) { MST[rv.UOI1Mutator]MSP[] buf . deleteCharAt ( k -- ) ; } } return parseBytes ( buf . toString () , path ) ; }
return kb ? freeSpaceWindows ( path , timeout ) / FileUtils . ONE_KB : freeSpaceWindows ( path , timeout ) ; MST[rv.UOI4Mutator]MSP[] case UNIX : return freeSpaceUnix ( path , kb , false , timeout ) ; case POSIX_UNIX :
inr = new BufferedReader ( new InputStreamReader ( in , Charset . defaultCharset () ) ) ; String line = inr . readLine () ; while ( line != null && lines . size () < max ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
@Deprecated public static long freeSpace ( final String path ) throws IOException { return INSTANCE . freeSpaceOS ( path , OS , false , - 1 ) ; MST[InlineConstantMutator]MSP[] } @Deprecated public static long freeSpaceKb ( final String path ) throws IOException {
final char c = line . charAt ( j ) ; if ( ! Character . isDigit ( c ) && c != ',' && c != '.' ) { MST[rv.ROR3Mutator]MSP[] bytesStart = j + 1 ; break innerLoop2; } j -- ; } if ( j < 0 ) {
final long bytes = Long . parseLong ( freeSpace ) ; if ( bytes < 0 ) { throw new IOException ( MST[NonVoidMethodCallMutator]MSP[] lr_17 + DF + lr_23 + lr_10 + path + lr_22 ) ; } return bytes ; } catch ( final NumberFormatException ex ) {
return kb ? freeSpaceWindows ( path , timeout ) / FileUtils . ONE_KB : freeSpaceWindows ( path , timeout ) ; MST[rv.UOI2Mutator]MSP[] case UNIX : return freeSpaceUnix ( path , kb , false , timeout ) ; case POSIX_UNIX :
for ( int i = lines . size () - 1 ; i >= 0 ; i -- ) { MST[rv.AOR3Mutator]MSP[] final String line = lines . get ( i ) ; if ( line . length () > 0 ) { return parseDir ( line , normPath ) ; }
inr = new BufferedReader ( new InputStreamReader ( in , Charset . defaultCharset () ) ) ; String line = inr . readLine () ; while ( line != null && lines . size () < max ) { MST[rv.ROR4Mutator]MSP[]
final Thread monitor = ThreadMonitor . start ( timeout ) ; MST[rv.UOI3Mutator]MSP[] proc = openProcess ( cmdAttribs ) ; in = proc . getInputStream () ; out = proc . getOutputStream () ; err = proc . getErrorStream () ;
return kb ? freeSpaceWindows ( path , timeout ) / FileUtils . ONE_KB : freeSpaceWindows ( path , timeout ) ; MST[rv.UOI1Mutator]MSP[] case UNIX : return freeSpaceUnix ( path , kb , false , timeout ) ; case POSIX_UNIX :
normPath = lr_5 + normPath + lr_5 ; } final String [] cmdAttribs = new String [] { lr_6 , lr_7 , lr_8 + normPath } ; MST[experimental.NakedReceiverMutator]MSP[] final List < String > lines = performCommand ( cmdAttribs , Integer . MAX_VALUE , timeout ) ;
return freeSpaceUnix ( path , kb , true , timeout ) ; MST[rv.UOI3Mutator]MSP[] case OTHER : throw new IllegalStateException ( lr_3 ) ; default: throw new IllegalStateException ( lr_4 ) ; } } long freeSpaceWindows ( final String path , final long timeout ) throws IOException {
long freeSpaceOS ( final String path , final int os , final boolean kb , final long timeout ) throws IOException { if ( path == null ) { MST[rv.ROR5Mutator]MSP[] throw new IllegalArgumentException ( lr_2 ) ; } switch ( os ) { case WINDOWS :
flags += lr_15 ; } if ( posix ) { flags += lr_16 ; } final String [] cmdAttribs = flags . length () > 1 ? new String [] { DF , flags , path } : new String [] { DF , path } ; MST[rv.CRCR3Mutator]MSP[]
@Deprecated public static long freeSpace ( final String path ) throws IOException { return INSTANCE . freeSpaceOS ( path , OS , false , - 1 ) ; MST[NonVoidMethodCallMutator]MSP[] } @Deprecated public static long freeSpaceKb ( final String path ) throws IOException {
if ( buf . charAt ( k ) == ',' || buf . charAt ( k ) == '.' ) { MST[rv.ROR2Mutator]MSP[] buf . deleteCharAt ( k -- ) ; } } return parseBytes ( buf . toString () , path ) ; }
final String line3 = lines . get ( 2 ) ; MST[rv.CRCR4Mutator]MSP[] tok = new StringTokenizer ( line3 , lr_20 ) ; } else { throw new IOException ( lr_17 + DF + lr_21 + lr_10 + path + lr_22 ) ; } } else { tok . nextToken () ;
normPath = lr_5 + normPath + lr_5 ; } final String [] cmdAttribs = new String [] { lr_6 , lr_7 , lr_8 + normPath } ; final List < String > lines = performCommand ( cmdAttribs , Integer . MAX_VALUE , timeout ) ; MST[rv.CRCR4Mutator]MSP[]
String normPath = FilenameUtils . normalize ( path , false ) ; MST[rv.CRCR1Mutator]MSP[] if ( normPath == null ) { throw new IllegalArgumentException ( path ) ; } if ( normPath . length () > 0 && normPath . charAt ( 0 ) != '"' ) {
return freeSpaceKb ( path , - 1 ) ; } @Deprecated public static long freeSpaceKb ( final String path , final long timeout ) throws IOException { return INSTANCE . freeSpaceOS ( path , OS , true , timeout ) ; MST[rv.UOI2Mutator]MSP[] } @Deprecated
final char c = line . charAt ( j ) ; if ( ! Character . isDigit ( c ) && c != ',' && c != '.' ) { bytesStart = j + 1 ; MST[rv.CRCR6Mutator]MSP[] break innerLoop2; } j -- ; } if ( j < 0 ) {
normPath = lr_5 + normPath + lr_5 ; } final String [] cmdAttribs = new String [] { lr_6 , lr_7 , lr_8 + normPath } ; MST[rv.CRCR6Mutator]MSP[] final List < String > lines = performCommand ( cmdAttribs , Integer . MAX_VALUE , timeout ) ;
final char c = line . charAt ( j ) ; if ( ! Character . isDigit ( c ) && c != ',' && c != '.' ) { MST[rv.ABSMutator]MSP[] bytesStart = j + 1 ; break innerLoop2; } j -- ; } if ( j < 0 ) {
return kb ? freeSpaceWindows ( path , timeout ) / FileUtils . ONE_KB : freeSpaceWindows ( path , timeout ) ; case UNIX : return freeSpaceUnix ( path , kb , false , timeout ) ; MST[PrimitiveReturnsMutator]MSP[] case POSIX_UNIX :
final List < String > lines = performCommand ( cmdAttribs , 3 , timeout ) ; if ( lines . size () < 2 ) { MST[InlineConstantMutator]MSP[] throw new IOException ( lr_17 + DF + lr_18 + lr_10 + path + lr_19 + lines ) ; }
final char c = line . charAt ( j ) ; if ( ! Character . isDigit ( c ) && c != ',' && c != '.' ) { MST[rv.UOI2Mutator]MSP[] bytesStart = j + 1 ; break innerLoop2; } j -- ; } if ( j < 0 ) {
final List < String > lines = performCommand ( cmdAttribs , 3 , timeout ) ; MST[rv.CRCR3Mutator]MSP[] if ( lines . size () < 2 ) { throw new IOException ( lr_17 + DF + lr_18 + lr_10 + path + lr_19 + lines ) ; }
throw new IOException ( lr_12 + lr_10 + path + lr_11 ) ; } final StringBuilder buf = new StringBuilder ( line . substring ( bytesStart , bytesEnd ) ) ; for ( int k = 0 ; k < buf . length () ; k ++ ) { MST[rv.ROR3Mutator]MSP[]
public static long freeSpaceKb () throws IOException { return freeSpaceKb ( - 1 ) ; } @Deprecated public static long freeSpaceKb ( final long timeout ) throws IOException { return freeSpaceKb ( new File ( lr_1 ) . getAbsolutePath () , timeout ) ; MST[ConstructorCallMutator]MSP[] }
String normPath = FilenameUtils . normalize ( path , false ) ; if ( normPath == null ) { throw new IllegalArgumentException ( path ) ; } if ( normPath . length () > 0 && normPath . charAt ( 0 ) != '"' ) { MST[rv.CRCR5Mutator]MSP[]
if ( proc . exitValue () != 0 ) { throw new IOException ( lr_25 + proc . exitValue () + lr_26 + Arrays . asList ( cmdAttribs ) ) ; } if ( lines . isEmpty () ) { MST[rv.ROR4Mutator]MSP[] throw new IOException ( lr_27 +
long freeSpaceOS ( final String path , final int os , final boolean kb , final long timeout ) throws IOException { if ( path == null ) { throw new IllegalArgumentException ( lr_2 ) ; } switch ( os ) { MST[rv.ABSMutator]MSP[] case WINDOWS :
innerLoop1: while ( j >= 0 ) { final char c = line . charAt ( j ) ; if ( Character . isDigit ( c ) ) { bytesEnd = j + 1 ; MST[rv.CRCR4Mutator]MSP[] break innerLoop1; } j -- ; } innerLoop2: while ( j >= 0 ) {
return kb ? freeSpaceWindows ( path , timeout ) / FileUtils . ONE_KB : freeSpaceWindows ( path , timeout ) ; MST[rv.ROR5Mutator]MSP[] case UNIX : return freeSpaceUnix ( path , kb , false , timeout ) ; case POSIX_UNIX :
final String line3 = lines . get ( 2 ) ; tok = new StringTokenizer ( line3 , lr_20 ) ; } else { throw new IOException ( lr_17 + DF + lr_21 + lr_10 + path + lr_22 ) ; } } else { tok . nextToken () ; MST[NonVoidMethodCallMutator]MSP[]
throw new IOException ( lr_12 + lr_10 + path + lr_11 ) ; } final StringBuilder buf = new StringBuilder ( line . substring ( bytesStart , bytesEnd ) ) ; MST[rv.UOI2Mutator]MSP[] for ( int k = 0 ; k < buf . length () ; k ++ ) {
flags += lr_15 ; } if ( posix ) { flags += lr_16 ; } final String [] cmdAttribs = flags . length () > 1 ? new String [] { DF , flags , path } : new String [] { DF , path } ; MST[rv.CRCR3Mutator]MSP[]
final String line3 = lines . get ( 2 ) ; tok = new StringTokenizer ( line3 , lr_20 ) ; } else { throw new IOException ( MST[experimental.NakedReceiverMutator]MSP[] lr_17 + DF + lr_21 + lr_10 + path + lr_22 ) ; } } else { tok . nextToken () ;
innerLoop1: while ( j >= 0 ) { final char c = line . charAt ( j ) ; if ( Character . isDigit ( c ) ) { MST[rv.ABSMutator]MSP[] bytesEnd = j + 1 ; break innerLoop1; } j -- ; } innerLoop2: while ( j >= 0 ) {
if ( proc . exitValue () != 0 ) { throw new IOException ( lr_25 + proc . exitValue () + lr_26 + Arrays . asList ( cmdAttribs ) ) ; } if ( lines . isEmpty () ) { throw new IOException ( MST[NonVoidMethodCallMutator]MSP[] lr_27 +
lr_28 + Arrays . asList ( cmdAttribs ) ) ; } inr . close () ; inr = null ; in . close () ; in = null ; if ( out != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] out . close () ; out = null ; }
return freeSpaceUnix ( path , kb , true , timeout ) ; MST[ArgumentPropagationMutator]MSP[] case OTHER : throw new IllegalStateException ( lr_3 ) ; default: throw new IllegalStateException ( lr_4 ) ; } } long freeSpaceWindows ( final String path , final long timeout ) throws IOException {
innerLoop1: while ( j >= 0 ) { final char c = line . charAt ( j ) ; if ( Character . isDigit ( c ) ) { bytesEnd = j + 1 ; break innerLoop1; } j -- ; } innerLoop2: while ( j >= 0 ) { MST[ConditionalsBoundaryMutator]MSP[]
throw new IOException ( MST[NonVoidMethodCallMutator]MSP[] lr_17 + DF + lr_24 + lr_10 + path + lr_22 , ex ) ; } } List < String > performCommand ( final String [] cmdAttribs , final int max , final long timeout ) throws IOException {
String normPath = FilenameUtils . normalize ( path , false ) ; if ( normPath == null ) { throw new IllegalArgumentException ( path ) ; } if ( normPath . length () > 0 && normPath . charAt ( 0 ) != '"' ) { MST[InlineConstantMutator]MSP[]
normPath = lr_5 + normPath + lr_5 ; } final String [] cmdAttribs = new String [] { lr_6 , lr_7 , lr_8 + normPath } ; MST[rv.CRCR2Mutator]MSP[] final List < String > lines = performCommand ( cmdAttribs , Integer . MAX_VALUE , timeout ) ;
final char c = line . charAt ( j ) ; if ( ! Character . isDigit ( c ) && c != ',' && c != '.' ) { MST[rv.ROR2Mutator]MSP[] bytesStart = j + 1 ; break innerLoop2; } j -- ; } if ( j < 0 ) {
normPath = lr_5 + normPath + lr_5 ; } final String [] cmdAttribs = new String [] { lr_6 , lr_7 , lr_8 + normPath } ; MST[rv.CRCR4Mutator]MSP[] final List < String > lines = performCommand ( cmdAttribs , Integer . MAX_VALUE , timeout ) ;
innerLoop1: while ( j >= 0 ) { final char c = line . charAt ( j ) ; MST[rv.UOI2Mutator]MSP[] if ( Character . isDigit ( c ) ) { bytesEnd = j + 1 ; break innerLoop1; } j -- ; } innerLoop2: while ( j >= 0 ) {
line = line . toLowerCase ( Locale . ENGLISH ) . trim () ; lines . add ( line ) ; line = inr . readLine () ; } proc . waitFor () ; MST[NonVoidMethodCallMutator]MSP[] ThreadMonitor . stop ( monitor ) ;
} throw new IOException ( lr_9 + lr_10 + normPath + lr_11 ) ; } long parseDir ( final String line , final String path ) throws IOException { int bytesStart = 0 ; int bytesEnd = 0 ; MST[rv.CRCR6Mutator]MSP[] int j = line . length () - 1 ;
if ( proc . exitValue () != 0 ) { throw new IOException ( lr_25 + proc . exitValue () + MST[experimental.NakedReceiverMutator]MSP[] lr_26 + Arrays . asList ( cmdAttribs ) ) ; } if ( lines . isEmpty () ) { throw new IOException ( lr_27 +
final char c = line . charAt ( j ) ; if ( ! Character . isDigit ( c ) && c != ',' && c != '.' ) { MST[rv.CRCR5Mutator]MSP[] bytesStart = j + 1 ; break innerLoop2; } j -- ; } if ( j < 0 ) {
final List < String > lines = performCommand ( cmdAttribs , 3 , timeout ) ; if ( lines . size () < 2 ) { MST[NonVoidMethodCallMutator]MSP[] throw new IOException ( lr_17 + DF + lr_18 + lr_10 + path + lr_19 + lines ) ; }
long freeSpaceOS ( final String path , final int os , final boolean kb , final long timeout ) throws IOException { if ( path == null ) { throw new IllegalArgumentException ( lr_2 ) ; } switch ( os ) { MST[experimental.SwitchMutator]MSP[] case WINDOWS :
flags += lr_15 ; } if ( posix ) { flags += lr_16 ; } final String [] cmdAttribs = flags . length () > 1 ? new String [] { DF , flags , path } : new String [] { DF , path } ; MST[rv.ROR3Mutator]MSP[]
flags += lr_15 ; } if ( posix ) { flags += lr_16 ; } final String [] cmdAttribs = flags . length () > 1 ? new String [] { DF , flags , path } : new String [] { DF , path } ; MST[rv.ROR1Mutator]MSP[]
for ( int i = lines . size () - 1 ; i >= 0 ; i -- ) { MST[rv.ROR4Mutator]MSP[] final String line = lines . get ( i ) ; if ( line . length () > 0 ) { return parseDir ( line , normPath ) ; }
final char c = line . charAt ( j ) ; if ( ! Character . isDigit ( c ) && c != ',' && c != '.' ) { MST[rv.UOI3Mutator]MSP[] bytesStart = j + 1 ; break innerLoop2; } j -- ; } if ( j < 0 ) {
return freeSpaceUnix ( path , kb , true , timeout ) ; MST[rv.CRCR5Mutator]MSP[] case OTHER : throw new IllegalStateException ( lr_3 ) ; default: throw new IllegalStateException ( lr_4 ) ; } } long freeSpaceWindows ( final String path , final long timeout ) throws IOException {
for ( int i = lines . size () - 1 ; i >= 0 ; i -- ) { MST[rv.ROR2Mutator]MSP[] final String line = lines . get ( i ) ; if ( line . length () > 0 ) { return parseDir ( line , normPath ) ; }
for ( int i = lines . size () - 1 ; i >= 0 ; i -- ) { final String line = lines . get ( i ) ; MST[rv.UOI2Mutator]MSP[] if ( line . length () > 0 ) { return parseDir ( line , normPath ) ; }
final char c = line . charAt ( j ) ; if ( ! Character . isDigit ( c ) && c != ',' && c != '.' ) { MST[rv.UOI1Mutator]MSP[] bytesStart = j + 1 ; break innerLoop2; } j -- ; } if ( j < 0 ) {
final String line2 = lines . get ( 1 ) ; StringTokenizer tok = new StringTokenizer ( line2 , lr_20 ) ; if ( tok . countTokens () < 4 ) { if ( tok . countTokens () == 1 && lines . size () >= 3 ) { MST[rv.CRCR6Mutator]MSP[]
for ( int i = lines . size () - 1 ; i >= 0 ; i -- ) { final String line = lines . get ( i ) ; if ( line . length () > 0 ) { MST[rv.ROR1Mutator]MSP[] return parseDir ( line , normPath ) ; }
flags += lr_15 ; } if ( posix ) { flags += lr_16 ; } final String [] cmdAttribs = flags . length () > 1 ? new String [] { DF , flags , path } : new String [] { DF , path } ; MST[rv.CRCR4Mutator]MSP[]
if ( proc . exitValue () != 0 ) { throw new IOException ( lr_25 + proc . exitValue () + lr_26 + Arrays . asList ( cmdAttribs ) ) ; MST[NonVoidMethodCallMutator]MSP[] } if ( lines . isEmpty () ) { throw new IOException ( lr_27 +
String normPath = FilenameUtils . normalize ( path , false ) ; if ( normPath == null ) { throw new IllegalArgumentException ( path ) ; } if ( normPath . length () > 0 && normPath . charAt ( 0 ) != '"' ) { MST[NonVoidMethodCallMutator]MSP[]
final List < String > lines = performCommand ( cmdAttribs , 3 , timeout ) ; if ( lines . size () < 2 ) { MST[ConditionalsBoundaryMutator]MSP[] throw new IOException ( lr_17 + DF + lr_18 + lr_10 + path + lr_19 + lines ) ; }
if ( buf . charAt ( k ) == ',' || buf . charAt ( k ) == '.' ) { buf . deleteCharAt ( k -- ) ; } } return parseBytes ( buf . toString () , path ) ; MST[PrimitiveReturnsMutator]MSP[] }
final char c = line . charAt ( j ) ; if ( ! Character . isDigit ( c ) && c != ',' && c != '.' ) { bytesStart = j + 1 ; MST[InlineConstantMutator]MSP[] break innerLoop2; } j -- ; } if ( j < 0 ) {
final String line2 = lines . get ( 1 ) ; StringTokenizer tok = new StringTokenizer ( line2 , lr_20 ) ; if ( tok . countTokens () < 4 ) { if ( tok . countTokens () == 1 && lines . size () >= 3 ) { MST[rv.ROR1Mutator]MSP[]
innerLoop1: while ( j >= 0 ) { final char c = line . charAt ( j ) ; if ( Character . isDigit ( c ) ) { MST[NegateConditionalsMutator]MSP[] bytesEnd = j + 1 ; break innerLoop1; } j -- ; } innerLoop2: while ( j >= 0 ) {
final String line2 = lines . get ( 1 ) ; StringTokenizer tok = new StringTokenizer ( line2 , lr_20 ) ; if ( tok . countTokens () < 4 ) { if ( tok . countTokens () == 1 && lines . size () >= 3 ) { MST[rv.ROR3Mutator]MSP[]
return kb ? freeSpaceWindows ( path , timeout ) / FileUtils . ONE_KB : freeSpaceWindows ( path , timeout ) ; MST[rv.CRCR2Mutator]MSP[] case UNIX : return freeSpaceUnix ( path , kb , false , timeout ) ; case POSIX_UNIX :
final List < String > lines = performCommand ( cmdAttribs , 3 , timeout ) ; MST[rv.CRCR1Mutator]MSP[] if ( lines . size () < 2 ) { throw new IOException ( lr_17 + DF + lr_18 + lr_10 + path + lr_19 + lines ) ; }
final List < String > lines = performCommand ( cmdAttribs , 3 , timeout ) ; if ( lines . size () < 2 ) { MST[rv.CRCR5Mutator]MSP[] throw new IOException ( lr_17 + DF + lr_18 + lr_10 + path + lr_19 + lines ) ; }
for ( int i = lines . size () - 1 ; i >= 0 ; i -- ) { MST[rv.UOI1Mutator]MSP[] final String line = lines . get ( i ) ; if ( line . length () > 0 ) { return parseDir ( line , normPath ) ; }
if ( proc . exitValue () != 0 ) { MST[rv.ROR4Mutator]MSP[] throw new IOException ( lr_25 + proc . exitValue () + lr_26 + Arrays . asList ( cmdAttribs ) ) ; } if ( lines . isEmpty () ) { throw new IOException ( lr_27 +
final char c = line . charAt ( j ) ; if ( ! Character . isDigit ( c ) && c != ',' && c != '.' ) { MST[rv.CRCR4Mutator]MSP[] bytesStart = j + 1 ; break innerLoop2; } j -- ; } if ( j < 0 ) {
} throw new IOException ( MST[NonVoidMethodCallMutator]MSP[] lr_9 + lr_10 + normPath + lr_11 ) ; } long parseDir ( final String line , final String path ) throws IOException { int bytesStart = 0 ; int bytesEnd = 0 ; int j = line . length () - 1 ;
long freeSpaceOS ( final String path , final int os , final boolean kb , final long timeout ) throws IOException { if ( path == null ) { throw new IllegalArgumentException ( lr_2 ) ; } switch ( os ) { MST[rv.UOI3Mutator]MSP[] case WINDOWS :
if ( buf . charAt ( k ) == ',' || buf . charAt ( k ) == '.' ) { buf . deleteCharAt ( k -- ) ; MST[rv.ABSMutator]MSP[] } } return parseBytes ( buf . toString () , path ) ; }
String normPath = FilenameUtils . normalize ( path , false ) ; MST[rv.CRCR3Mutator]MSP[] if ( normPath == null ) { throw new IllegalArgumentException ( path ) ; } if ( normPath . length () > 0 && normPath . charAt ( 0 ) != '"' ) {
inr = new BufferedReader ( new InputStreamReader ( in , Charset . defaultCharset () ) ) ; String line = inr . readLine () ; while ( line != null && lines . size () < max ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[]
innerLoop1: while ( j >= 0 ) { final char c = line . charAt ( j ) ; if ( Character . isDigit ( c ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] bytesEnd = j + 1 ; break innerLoop1; } j -- ; } innerLoop2: while ( j >= 0 ) {
final long bytes = Long . parseLong ( freeSpace ) ; if ( bytes < 0 ) { throw new IOException ( lr_17 + DF + lr_23 + lr_10 + path + lr_22 ) ; } return bytes ; MST[rv.ABSMutator]MSP[] } catch ( final NumberFormatException ex ) {
innerLoop1: while ( j >= 0 ) { final char c = line . charAt ( j ) ; if ( Character . isDigit ( c ) ) { bytesEnd = j + 1 ; break innerLoop1; } j -- ; } innerLoop2: while ( j >= 0 ) { MST[rv.ROR2Mutator]MSP[]
if ( err != null ) { err . close () ; err = null ; } return lines ; MST[EmptyObjectReturnValsMutator]MSP[] } catch ( final InterruptedException ex ) { throw new IOException ( lr_29 + lr_28 + Arrays . asList ( cmdAttribs ) + lr_30 + timeout , ex ) ;
final char c = line . charAt ( j ) ; if ( ! Character . isDigit ( c ) && c != ',' && c != '.' ) { MST[NegateConditionalsMutator]MSP[] bytesStart = j + 1 ; break innerLoop2; } j -- ; } if ( j < 0 ) {
return kb ? freeSpaceWindows ( path , timeout ) / FileUtils . ONE_KB : freeSpaceWindows ( path , timeout ) ; MST[rv.AOR1Mutator]MSP[] case UNIX : return freeSpaceUnix ( path , kb , false , timeout ) ; case POSIX_UNIX :
final char c = line . charAt ( j ) ; if ( ! Character . isDigit ( c ) && c != ',' && c != '.' ) { MST[rv.UOI4Mutator]MSP[] bytesStart = j + 1 ; break innerLoop2; } j -- ; } if ( j < 0 ) {
final char c = line . charAt ( j ) ; if ( ! Character . isDigit ( c ) && c != ',' && c != '.' ) { MST[rv.ROR1Mutator]MSP[] bytesStart = j + 1 ; break innerLoop2; } j -- ; } if ( j < 0 ) {
if ( proc . exitValue () != 0 ) { throw new IOException ( lr_25 + proc . exitValue () + lr_26 + Arrays . asList ( cmdAttribs ) ) ; } if ( lines . isEmpty () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] throw new IOException ( lr_27 +
return freeSpaceKb ( path , - 1 ) ; MST[ReturnValsMutator]MSP[] } @Deprecated public static long freeSpaceKb ( final String path , final long timeout ) throws IOException { return INSTANCE . freeSpaceOS ( path , OS , true , timeout ) ; } @Deprecated
String normPath = FilenameUtils . normalize ( path , false ) ; if ( normPath == null ) { throw new IllegalArgumentException ( path ) ; } if ( normPath . length () > 0 && normPath . charAt ( 0 ) != '"' ) { MST[rv.CRCR5Mutator]MSP[]
inr = new BufferedReader ( new InputStreamReader ( in , Charset . defaultCharset () ) ) ; String line = inr . readLine () ; MST[NonVoidMethodCallMutator]MSP[] while ( line != null && lines . size () < max ) {
throw new IOException ( lr_12 + lr_10 + path + lr_11 ) ; } final StringBuilder buf = new StringBuilder ( line . substring ( bytesStart , bytesEnd ) ) ; MST[rv.UOI4Mutator]MSP[] for ( int k = 0 ; k < buf . length () ; k ++ ) {
long freeSpaceUnix ( final String path , final boolean kb , final boolean posix , final long timeout ) throws IOException { if ( path . isEmpty () ) { throw new IllegalArgumentException ( lr_13 ) ; } String flags = lr_14 ; if ( kb ) { MST[rv.UOI3Mutator]MSP[]
throw new IOException ( lr_12 + lr_10 + path + lr_11 ) ; } final StringBuilder buf = new StringBuilder ( line . substring ( bytesStart , bytesEnd ) ) ; for ( int k = 0 ; k < buf . length () ; k ++ ) { MST[ConditionalsBoundaryMutator]MSP[]
return kb ? freeSpaceWindows ( path , timeout ) / FileUtils . ONE_KB : freeSpaceWindows ( path , timeout ) ; case UNIX : return freeSpaceUnix ( path , kb , false , timeout ) ; MST[InlineConstantMutator]MSP[] case POSIX_UNIX :
} throw new IOException ( lr_9 + lr_10 + normPath + lr_11 ) ; } long parseDir ( final String line , final String path ) throws IOException { int bytesStart = 0 ; int bytesEnd = 0 ; int j = line . length () - 1 ; MST[rv.CRCR3Mutator]MSP[]
final char c = line . charAt ( j ) ; if ( ! Character . isDigit ( c ) && c != ',' && c != '.' ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] bytesStart = j + 1 ; break innerLoop2; } j -- ; } if ( j < 0 ) {
flags += lr_15 ; } if ( posix ) { flags += lr_16 ; } final String [] cmdAttribs = flags . length () > 1 ? new String [] { DF , flags , path } : new String [] { DF , path } ; MST[rv.CRCR1Mutator]MSP[]
normPath = lr_5 + normPath + lr_5 ; } final String [] cmdAttribs = new String [] { lr_6 , lr_7 , lr_8 + normPath } ; final List < String > lines = performCommand ( cmdAttribs , Integer . MAX_VALUE , timeout ) ; MST[rv.CRCR2Mutator]MSP[]
innerLoop1: while ( j >= 0 ) { MST[rv.ROR2Mutator]MSP[] final char c = line . charAt ( j ) ; if ( Character . isDigit ( c ) ) { bytesEnd = j + 1 ; break innerLoop1; } j -- ; } innerLoop2: while ( j >= 0 ) {
if ( buf . charAt ( k ) == ',' || buf . charAt ( k ) == '.' ) { MST[rv.CRCR1Mutator]MSP[] buf . deleteCharAt ( k -- ) ; } } return parseBytes ( buf . toString () , path ) ; }
} throw new IOException ( lr_9 + lr_10 + normPath + lr_11 ) ; } long parseDir ( final String line , final String path ) throws IOException { int bytesStart = 0 ; MST[rv.CRCR1Mutator]MSP[] int bytesEnd = 0 ; int j = line . length () - 1 ;
innerLoop1: while ( j >= 0 ) { final char c = line . charAt ( j ) ; if ( Character . isDigit ( c ) ) { MST[rv.UOI3Mutator]MSP[] bytesEnd = j + 1 ; break innerLoop1; } j -- ; } innerLoop2: while ( j >= 0 ) {
for ( int i = lines . size () - 1 ; i >= 0 ; i -- ) { MST[rv.CRCR6Mutator]MSP[] final String line = lines . get ( i ) ; if ( line . length () > 0 ) { return parseDir ( line , normPath ) ; }
final String line3 = lines . get ( 2 ) ; tok = new StringTokenizer ( line3 , lr_20 ) ; } else { throw new IOException ( MST[experimental.NakedReceiverMutator]MSP[] lr_17 + DF + lr_21 + lr_10 + path + lr_22 ) ; } } else { tok . nextToken () ;
} throw new IOException ( lr_9 + lr_10 + normPath + lr_11 ) ; } long parseDir ( final String line , final String path ) throws IOException { int bytesStart = 0 ; int bytesEnd = 0 ; int j = line . length () - 1 ; MST[MathMutator]MSP[]
return freeSpaceKb ( path , - 1 ) ; MST[rv.CRCR5Mutator]MSP[] } @Deprecated public static long freeSpaceKb ( final String path , final long timeout ) throws IOException { return INSTANCE . freeSpaceOS ( path , OS , true , timeout ) ; } @Deprecated
String normPath = FilenameUtils . normalize ( path , false ) ; if ( normPath == null ) { throw new IllegalArgumentException ( path ) ; } if ( normPath . length () > 0 && normPath . charAt ( 0 ) != '"' ) { MST[InlineConstantMutator]MSP[]
throw new IOException ( lr_12 + lr_10 + path + lr_11 ) ; } final StringBuilder buf = new StringBuilder ( line . substring ( bytesStart , bytesEnd ) ) ; for ( int k = 0 ; k < buf . length () ; k ++ ) { MST[rv.CRCR6Mutator]MSP[]
flags += lr_15 ; } if ( posix ) { flags += lr_16 ; } final String [] cmdAttribs = flags . length () > 1 ? new String [] { DF , flags , path } : new String [] { DF , path } ; MST[rv.CRCR6Mutator]MSP[]
normPath = lr_5 + normPath + lr_5 ; MST[experimental.NakedReceiverMutator]MSP[] } final String [] cmdAttribs = new String [] { lr_6 , lr_7 , lr_8 + normPath } ; final List < String > lines = performCommand ( cmdAttribs , Integer . MAX_VALUE , timeout ) ;
if ( buf . charAt ( k ) == ',' || buf . charAt ( k ) == '.' ) { buf . deleteCharAt ( k -- ) ; MST[rv.UOI3Mutator]MSP[] } } return parseBytes ( buf . toString () , path ) ; }
return kb ? freeSpaceWindows ( path , timeout ) / FileUtils . ONE_KB : freeSpaceWindows ( path , timeout ) ; MST[ReturnValsMutator]MSP[] case UNIX : return freeSpaceUnix ( path , kb , false , timeout ) ; case POSIX_UNIX :
return kb ? freeSpaceWindows ( path , timeout ) / FileUtils . ONE_KB : freeSpaceWindows ( path , timeout ) ; MST[rv.UOI4Mutator]MSP[] case UNIX : return freeSpaceUnix ( path , kb , false , timeout ) ; case POSIX_UNIX :
return kb ? freeSpaceWindows ( path , timeout ) / FileUtils . ONE_KB : freeSpaceWindows ( path , timeout ) ; case UNIX : return freeSpaceUnix ( path , kb , false , timeout ) ; MST[rv.UOI1Mutator]MSP[] case POSIX_UNIX :
final char c = line . charAt ( j ) ; if ( ! Character . isDigit ( c ) && c != ',' && c != '.' ) { bytesStart = j + 1 ; break innerLoop2; } j -- ; MST[IncrementsMutator]MSP[] } if ( j < 0 ) {
throw new IOException ( lr_12 + lr_10 + path + lr_11 ) ; } final StringBuilder buf = new StringBuilder ( line . substring ( bytesStart , bytesEnd ) ) ; for ( int k = 0 ; k < buf . length () ; k ++ ) { MST[NegateConditionalsMutator]MSP[]
lr_28 + Arrays . asList ( cmdAttribs ) ) ; MST[experimental.NakedReceiverMutator]MSP[] } inr . close () ; inr = null ; in . close () ; in = null ; if ( out != null ) { out . close () ; out = null ; }
throw new IOException ( lr_12 + lr_10 + path + lr_11 ) ; } final StringBuilder buf = new StringBuilder ( line . substring ( bytesStart , bytesEnd ) ) ; for ( int k = 0 ; k < buf . length () ; k ++ ) { MST[rv.UOI2Mutator]MSP[]
if ( buf . charAt ( k ) == ',' || buf . charAt ( k ) == '.' ) { MST[rv.ABSMutator]MSP[] buf . deleteCharAt ( k -- ) ; } } return parseBytes ( buf . toString () , path ) ; }
final char c = line . charAt ( j ) ; if ( ! Character . isDigit ( c ) && c != ',' && c != '.' ) { MST[rv.ROR5Mutator]MSP[] bytesStart = j + 1 ; break innerLoop2; } j -- ; } if ( j < 0 ) {
} finally { IOUtils . closeQuietly ( in ) ; MST[VoidMethodCallMutator]MSP[] IOUtils . closeQuietly ( out ) ; IOUtils . closeQuietly ( err ) ; IOUtils . closeQuietly ( inr ) ; if ( proc != null ) { proc . destroy () ; } } }
if ( proc . exitValue () != 0 ) { throw new IOException ( lr_25 + proc . exitValue () + lr_26 + Arrays . asList ( cmdAttribs ) ) ; MST[NonVoidMethodCallMutator]MSP[] } if ( lines . isEmpty () ) { throw new IOException ( lr_27 +
final long bytes = Long . parseLong ( freeSpace ) ; if ( bytes < 0 ) { throw new IOException ( lr_17 + DF + lr_23 + lr_10 + path + lr_22 ) ; } return bytes ; MST[rv.UOI3Mutator]MSP[] } catch ( final NumberFormatException ex ) {
final String line2 = lines . get ( 1 ) ; MST[NonVoidMethodCallMutator]MSP[] StringTokenizer tok = new StringTokenizer ( line2 , lr_20 ) ; if ( tok . countTokens () < 4 ) { if ( tok . countTokens () == 1 && lines . size () >= 3 ) {
flags += lr_15 ; } if ( posix ) { flags += lr_16 ; MST[experimental.NakedReceiverMutator]MSP[] } final String [] cmdAttribs = flags . length () > 1 ? new String [] { DF , flags , path } : new String [] { DF , path } ;
long freeSpaceOS ( final String path , final int os , final boolean kb , final long timeout ) throws IOException { if ( path == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] throw new IllegalArgumentException ( lr_2 ) ; } switch ( os ) { case WINDOWS :
innerLoop1: while ( j >= 0 ) { final char c = line . charAt ( j ) ; if ( Character . isDigit ( c ) ) { bytesEnd = j + 1 ; break innerLoop1; } j -- ; } innerLoop2: while ( j >= 0 ) { MST[rv.UOI4Mutator]MSP[]
final long bytes = Long . parseLong ( freeSpace ) ; if ( bytes < 0 ) { MST[rv.ROR2Mutator]MSP[] throw new IOException ( lr_17 + DF + lr_23 + lr_10 + path + lr_22 ) ; } return bytes ; } catch ( final NumberFormatException ex ) {
final long bytes = Long . parseLong ( freeSpace ) ; if ( bytes < 0 ) { MST[rv.CRCR1Mutator]MSP[] throw new IOException ( lr_17 + DF + lr_23 + lr_10 + path + lr_22 ) ; } return bytes ; } catch ( final NumberFormatException ex ) {
lr_28 + Arrays . asList ( cmdAttribs ) ) ; } inr . close () ; MST[VoidMethodCallMutator]MSP[] inr = null ; in . close () ; in = null ; if ( out != null ) { out . close () ; out = null ; }
flags += lr_15 ; MST[NonVoidMethodCallMutator]MSP[] } if ( posix ) { flags += lr_16 ; } final String [] cmdAttribs = flags . length () > 1 ? new String [] { DF , flags , path } : new String [] { DF , path } ;
final Thread monitor = ThreadMonitor . start ( timeout ) ; MST[rv.UOI1Mutator]MSP[] proc = openProcess ( cmdAttribs ) ; in = proc . getInputStream () ; out = proc . getOutputStream () ; err = proc . getErrorStream () ;
} tok . nextToken () ; tok . nextToken () ; MST[NonVoidMethodCallMutator]MSP[] final String freeSpace = tok . nextToken () ; return parseBytes ( freeSpace , path ) ; } long parseBytes ( final String freeSpace , final String path ) throws IOException { try {
line = line . toLowerCase ( Locale . ENGLISH ) . trim () ; MST[NonVoidMethodCallMutator]MSP[] lines . add ( line ) ; line = inr . readLine () ; } proc . waitFor () ; ThreadMonitor . stop ( monitor ) ;
throw new IOException ( lr_12 + lr_10 + path + lr_11 ) ; } final StringBuilder buf = new StringBuilder ( line . substring ( bytesStart , bytesEnd ) ) ; for ( int k = 0 ; k < buf . length () ; k ++ ) { MST[rv.CRCR1Mutator]MSP[]
flags += lr_15 ; } if ( posix ) { flags += lr_16 ; } final String [] cmdAttribs = flags . length () > 1 ? new String [] { DF , flags , path } : new String [] { DF , path } ; MST[rv.CRCR1Mutator]MSP[]
if ( err != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] err . close () ; err = null ; } return lines ; } catch ( final InterruptedException ex ) { throw new IOException ( lr_29 + lr_28 + Arrays . asList ( cmdAttribs ) + lr_30 + timeout , ex ) ;
normPath = lr_5 + normPath + lr_5 ; } final String [] cmdAttribs = new String [] { lr_6 , lr_7 , lr_8 + normPath } ; final List < String > lines = performCommand ( cmdAttribs , Integer . MAX_VALUE , timeout ) ; MST[NonVoidMethodCallMutator]MSP[]
} throw new IOException ( lr_9 + lr_10 + normPath + lr_11 ) ; } long parseDir ( final String line , final String path ) throws IOException { int bytesStart = 0 ; int bytesEnd = 0 ; int j = line . length () - 1 ; MST[NonVoidMethodCallMutator]MSP[]
flags += lr_15 ; } if ( posix ) { flags += lr_16 ; MST[ConstructorCallMutator]MSP[] } final String [] cmdAttribs = flags . length () > 1 ? new String [] { DF , flags , path } : new String [] { DF , path } ;
normPath = lr_5 + normPath + lr_5 ; } final String [] cmdAttribs = new String [] { lr_6 , lr_7 , lr_8 + normPath } ; final List < String > lines = performCommand ( cmdAttribs , Integer . MAX_VALUE , timeout ) ; MST[rv.UOI2Mutator]MSP[]
if ( buf . charAt ( k ) == ',' || buf . charAt ( k ) == '.' ) { MST[rv.CRCR2Mutator]MSP[] buf . deleteCharAt ( k -- ) ; } } return parseBytes ( buf . toString () , path ) ; }
final long bytes = Long . parseLong ( freeSpace ) ; if ( bytes < 0 ) { throw new IOException ( lr_17 + DF + lr_23 + lr_10 + path + lr_22 ) ; } return bytes ; MST[PrimitiveReturnsMutator]MSP[] } catch ( final NumberFormatException ex ) {
if ( buf . charAt ( k ) == ',' || buf . charAt ( k ) == '.' ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] buf . deleteCharAt ( k -- ) ; } } return parseBytes ( buf . toString () , path ) ; }
flags += lr_15 ; } if ( posix ) { flags += lr_16 ; } final String [] cmdAttribs = flags . length () > 1 ? new String [] { DF , flags , path } : new String [] { DF , path } ; MST[rv.CRCR4Mutator]MSP[]
public static long freeSpaceKb () throws IOException { return freeSpaceKb ( - 1 ) ; MST[NonVoidMethodCallMutator]MSP[] } @Deprecated public static long freeSpaceKb ( final long timeout ) throws IOException { return freeSpaceKb ( new File ( lr_1 ) . getAbsolutePath () , timeout ) ; }
String normPath = FilenameUtils . normalize ( path , false ) ; if ( normPath == null ) { throw new IllegalArgumentException ( path ) ; } if ( normPath . length () > 0 && normPath . charAt ( 0 ) != '"' ) { MST[rv.ROR4Mutator]MSP[]
final String line2 = lines . get ( 1 ) ; MST[rv.CRCR3Mutator]MSP[] StringTokenizer tok = new StringTokenizer ( line2 , lr_20 ) ; if ( tok . countTokens () < 4 ) { if ( tok . countTokens () == 1 && lines . size () >= 3 ) {
final long bytes = Long . parseLong ( freeSpace ) ; if ( bytes < 0 ) { MST[rv.CRCR6Mutator]MSP[] throw new IOException ( lr_17 + DF + lr_23 + lr_10 + path + lr_22 ) ; } return bytes ; } catch ( final NumberFormatException ex ) {
final List < String > lines = new ArrayList <> ( 20 ) ; MST[rv.CRCR5Mutator]MSP[] Process proc = null ; InputStream in = null ; OutputStream out = null ; InputStream err = null ; BufferedReader inr = null ; try {
return freeSpaceKb ( path , - 1 ) ; } @Deprecated public static long freeSpaceKb ( final String path , final long timeout ) throws IOException { return INSTANCE . freeSpaceOS ( path , OS , true , timeout ) ; MST[rv.CRCR2Mutator]MSP[] } @Deprecated
for ( int i = lines . size () - 1 ; i >= 0 ; i -- ) { MST[rv.AOD1Mutator]MSP[] final String line = lines . get ( i ) ; if ( line . length () > 0 ) { return parseDir ( line , normPath ) ; }
for ( int i = lines . size () - 1 ; i >= 0 ; i -- ) { final String line = lines . get ( i ) ; MST[NonVoidMethodCallMutator]MSP[] if ( line . length () > 0 ) { return parseDir ( line , normPath ) ; }
} throw new IOException ( lr_9 + lr_10 + normPath + lr_11 ) ; } long parseDir ( final String line , final String path ) throws IOException { int bytesStart = 0 ; int bytesEnd = 0 ; int j = line . length () - 1 ; MST[rv.AOR2Mutator]MSP[]
long freeSpaceUnix ( final String path , final boolean kb , final boolean posix , final long timeout ) throws IOException { if ( path . isEmpty () ) { throw new IllegalArgumentException ( lr_13 ) ; } String flags = lr_14 ; if ( kb ) { MST[rv.ABSMutator]MSP[]
final String line2 = lines . get ( 1 ) ; StringTokenizer tok = new StringTokenizer ( line2 , lr_20 ) ; if ( tok . countTokens () < 4 ) { MST[rv.ROR4Mutator]MSP[] if ( tok . countTokens () == 1 && lines . size () >= 3 ) {
throw new IOException ( lr_12 + lr_10 + path + lr_11 ) ; } final StringBuilder buf = new StringBuilder ( line . substring ( bytesStart , bytesEnd ) ) ; MST[rv.ABSMutator]MSP[] for ( int k = 0 ; k < buf . length () ; k ++ ) {
flags += lr_15 ; } if ( posix ) { flags += lr_16 ; } final String [] cmdAttribs = flags . length () > 1 ? new String [] { DF , flags , path } : new String [] { DF , path } ; MST[rv.CRCR6Mutator]MSP[]
if ( err != null ) { err . close () ; err = null ; } return lines ; MST[ReturnValsMutator]MSP[] } catch ( final InterruptedException ex ) { throw new IOException ( lr_29 + lr_28 + Arrays . asList ( cmdAttribs ) + lr_30 + timeout , ex ) ;
public static long freeSpaceKb () throws IOException { return freeSpaceKb ( - 1 ) ; MST[InlineConstantMutator]MSP[] } @Deprecated public static long freeSpaceKb ( final long timeout ) throws IOException { return freeSpaceKb ( new File ( lr_1 ) . getAbsolutePath () , timeout ) ; }
throw new IOException ( lr_12 + lr_10 + path + lr_11 ) ; } final StringBuilder buf = new StringBuilder ( line . substring ( bytesStart , bytesEnd ) ) ; for ( int k = 0 ; k < buf . length () ; k ++ ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[]
innerLoop1: while ( j >= 0 ) { final char c = line . charAt ( j ) ; if ( Character . isDigit ( c ) ) { bytesEnd = j + 1 ; MST[rv.AOD1Mutator]MSP[] break innerLoop1; } j -- ; } innerLoop2: while ( j >= 0 ) {
throw new IOException ( MST[NonVoidMethodCallMutator]MSP[] lr_17 + DF + lr_24 + lr_10 + path + lr_22 , ex ) ; } } List < String > performCommand ( final String [] cmdAttribs , final int max , final long timeout ) throws IOException {
final List < String > lines = performCommand ( cmdAttribs , 3 , timeout ) ; MST[rv.UOI1Mutator]MSP[] if ( lines . size () < 2 ) { throw new IOException ( lr_17 + DF + lr_18 + lr_10 + path + lr_19 + lines ) ; }
innerLoop1: while ( j >= 0 ) { final char c = line . charAt ( j ) ; if ( Character . isDigit ( c ) ) { bytesEnd = j + 1 ; MST[rv.UOI4Mutator]MSP[] break innerLoop1; } j -- ; } innerLoop2: while ( j >= 0 ) {
innerLoop1: while ( j >= 0 ) { final char c = line . charAt ( j ) ; if ( Character . isDigit ( c ) ) { MST[rv.ROR5Mutator]MSP[] bytesEnd = j + 1 ; break innerLoop1; } j -- ; } innerLoop2: while ( j >= 0 ) {
final String line2 = lines . get ( 1 ) ; MST[InlineConstantMutator]MSP[] StringTokenizer tok = new StringTokenizer ( line2 , lr_20 ) ; if ( tok . countTokens () < 4 ) { if ( tok . countTokens () == 1 && lines . size () >= 3 ) {
final String line3 = lines . get ( 2 ) ; tok = new StringTokenizer ( line3 , lr_20 ) ; } else { throw new IOException ( MST[experimental.NakedReceiverMutator]MSP[] lr_17 + DF + lr_21 + lr_10 + path + lr_22 ) ; } } else { tok . nextToken () ;
String normPath = FilenameUtils . normalize ( path , false ) ; MST[NonVoidMethodCallMutator]MSP[] if ( normPath == null ) { throw new IllegalArgumentException ( path ) ; } if ( normPath . length () > 0 && normPath . charAt ( 0 ) != '"' ) {
final char c = line . charAt ( j ) ; if ( ! Character . isDigit ( c ) && c != ',' && c != '.' ) { MST[rv.CRCR6Mutator]MSP[] bytesStart = j + 1 ; break innerLoop2; } j -- ; } if ( j < 0 ) {
normPath = lr_5 + normPath + lr_5 ; } final String [] cmdAttribs = new String [] { lr_6 , lr_7 , lr_8 + normPath } ; MST[rv.CRCR3Mutator]MSP[] final List < String > lines = performCommand ( cmdAttribs , Integer . MAX_VALUE , timeout ) ;
final char c = line . charAt ( j ) ; if ( ! Character . isDigit ( c ) && c != ',' && c != '.' ) { MST[rv.ROR3Mutator]MSP[] bytesStart = j + 1 ; break innerLoop2; } j -- ; } if ( j < 0 ) {
@Deprecated public static long freeSpace ( final String path ) throws IOException { return INSTANCE . freeSpaceOS ( path , OS , false , - 1 ) ; MST[rv.CRCR5Mutator]MSP[] } @Deprecated public static long freeSpaceKb ( final String path ) throws IOException {
throw new IOException ( MST[ConstructorCallMutator]MSP[] lr_17 + DF + lr_24 + lr_10 + path + lr_22 , ex ) ; } } List < String > performCommand ( final String [] cmdAttribs , final int max , final long timeout ) throws IOException {
innerLoop1: while ( j >= 0 ) { final char c = line . charAt ( j ) ; MST[rv.UOI3Mutator]MSP[] if ( Character . isDigit ( c ) ) { bytesEnd = j + 1 ; break innerLoop1; } j -- ; } innerLoop2: while ( j >= 0 ) {
return kb ? freeSpaceWindows ( path , timeout ) / FileUtils . ONE_KB : freeSpaceWindows ( path , timeout ) ; MST[rv.AOD2Mutator]MSP[] case UNIX : return freeSpaceUnix ( path , kb , false , timeout ) ; case POSIX_UNIX :
final long bytes = Long . parseLong ( freeSpace ) ; if ( bytes < 0 ) { MST[InlineConstantMutator]MSP[] throw new IOException ( lr_17 + DF + lr_23 + lr_10 + path + lr_22 ) ; } return bytes ; } catch ( final NumberFormatException ex ) {
innerLoop1: while ( j >= 0 ) { MST[rv.ROR3Mutator]MSP[] final char c = line . charAt ( j ) ; if ( Character . isDigit ( c ) ) { bytesEnd = j + 1 ; break innerLoop1; } j -- ; } innerLoop2: while ( j >= 0 ) {
final String line2 = lines . get ( 1 ) ; StringTokenizer tok = new StringTokenizer ( line2 , lr_20 ) ; if ( tok . countTokens () < 4 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[] if ( tok . countTokens () == 1 && lines . size () >= 3 ) {
innerLoop1: while ( j >= 0 ) { MST[rv.ABSMutator]MSP[] final char c = line . charAt ( j ) ; if ( Character . isDigit ( c ) ) { bytesEnd = j + 1 ; break innerLoop1; } j -- ; } innerLoop2: while ( j >= 0 ) {
final String line2 = lines . get ( 1 ) ; StringTokenizer tok = new StringTokenizer ( line2 , lr_20 ) ; if ( tok . countTokens () < 4 ) { if ( tok . countTokens () == 1 && lines . size () >= 3 ) { MST[rv.CRCR4Mutator]MSP[]
if ( buf . charAt ( k ) == ',' || buf . charAt ( k ) == '.' ) { buf . deleteCharAt ( k -- ) ; MST[IncrementsMutator]MSP[] } } return parseBytes ( buf . toString () , path ) ; }
final String line3 = lines . get ( 2 ) ; tok = new StringTokenizer ( line3 , lr_20 ) ; } else { throw new IOException ( MST[NonVoidMethodCallMutator]MSP[] lr_17 + DF + lr_21 + lr_10 + path + lr_22 ) ; } } else { tok . nextToken () ;
for ( int i = lines . size () - 1 ; i >= 0 ; i -- ) { MST[rv.ABSMutator]MSP[] final String line = lines . get ( i ) ; if ( line . length () > 0 ) { return parseDir ( line , normPath ) ; }
String normPath = FilenameUtils . normalize ( path , false ) ; if ( normPath == null ) { throw new IllegalArgumentException ( path ) ; } if ( normPath . length () > 0 && normPath . charAt ( 0 ) != '"' ) { MST[rv.ROR1Mutator]MSP[]
normPath = lr_5 + normPath + lr_5 ; } final String [] cmdAttribs = new String [] { lr_6 , lr_7 , lr_8 + normPath } ; MST[rv.CRCR1Mutator]MSP[] final List < String > lines = performCommand ( cmdAttribs , Integer . MAX_VALUE , timeout ) ;
for ( int i = lines . size () - 1 ; i >= 0 ; i -- ) { MST[rv.ROR3Mutator]MSP[] final String line = lines . get ( i ) ; if ( line . length () > 0 ) { return parseDir ( line , normPath ) ; }
return freeSpaceUnix ( path , kb , true , timeout ) ; MST[rv.CRCR6Mutator]MSP[] case OTHER : throw new IllegalStateException ( lr_3 ) ; default: throw new IllegalStateException ( lr_4 ) ; } } long freeSpaceWindows ( final String path , final long timeout ) throws IOException {
normPath = lr_5 + normPath + lr_5 ; } final String [] cmdAttribs = new String [] { lr_6 , lr_7 , lr_8 + normPath } ; MST[rv.CRCR6Mutator]MSP[] final List < String > lines = performCommand ( cmdAttribs , Integer . MAX_VALUE , timeout ) ;
final char c = line . charAt ( j ) ; if ( ! Character . isDigit ( c ) && c != ',' && c != '.' ) { MST[rv.UOI4Mutator]MSP[] bytesStart = j + 1 ; break innerLoop2; } j -- ; } if ( j < 0 ) {
for ( int i = lines . size () - 1 ; i >= 0 ; i -- ) { final String line = lines . get ( i ) ; MST[rv.UOI3Mutator]MSP[] if ( line . length () > 0 ) { return parseDir ( line , normPath ) ; }
final String line2 = lines . get ( 1 ) ; StringTokenizer tok = new StringTokenizer ( line2 , lr_20 ) ; if ( tok . countTokens () < 4 ) { if ( tok . countTokens () == 1 && lines . size () >= 3 ) { MST[rv.CRCR1Mutator]MSP[]
final String line3 = lines . get ( 2 ) ; MST[InlineConstantMutator]MSP[] tok = new StringTokenizer ( line3 , lr_20 ) ; } else { throw new IOException ( lr_17 + DF + lr_21 + lr_10 + path + lr_22 ) ; } } else { tok . nextToken () ;
throw new IOException ( MST[experimental.NakedReceiverMutator]MSP[] lr_17 + DF + lr_24 + lr_10 + path + lr_22 , ex ) ; } } List < String > performCommand ( final String [] cmdAttribs , final int max , final long timeout ) throws IOException {
flags += lr_15 ; } if ( posix ) { flags += lr_16 ; } final String [] cmdAttribs = flags . length () > 1 ? new String [] { DF , flags , path } : new String [] { DF , path } ; MST[rv.CRCR4Mutator]MSP[]
final String line2 = lines . get ( 1 ) ; StringTokenizer tok = new StringTokenizer ( line2 , lr_20 ) ; if ( tok . countTokens () < 4 ) { MST[NonVoidMethodCallMutator]MSP[] if ( tok . countTokens () == 1 && lines . size () >= 3 ) {
final char c = line . charAt ( j ) ; MST[rv.UOI3Mutator]MSP[] if ( ! Character . isDigit ( c ) && c != ',' && c != '.' ) { bytesStart = j + 1 ; break innerLoop2; } j -- ; } if ( j < 0 ) {
String normPath = FilenameUtils . normalize ( path , false ) ; if ( normPath == null ) { throw new IllegalArgumentException ( path ) ; } if ( normPath . length () > 0 && normPath . charAt ( 0 ) != '"' ) { MST[rv.CRCR4Mutator]MSP[]
for ( int i = lines . size () - 1 ; i >= 0 ; i -- ) { final String line = lines . get ( i ) ; if ( line . length () > 0 ) { return parseDir ( line , normPath ) ; MST[NonVoidMethodCallMutator]MSP[] }
flags += lr_15 ; } if ( posix ) { flags += lr_16 ; MST[experimental.NakedReceiverMutator]MSP[] } final String [] cmdAttribs = flags . length () > 1 ? new String [] { DF , flags , path } : new String [] { DF , path } ;
long freeSpaceUnix ( final String path , final boolean kb , final boolean posix , final long timeout ) throws IOException { if ( path . isEmpty () ) { throw new IllegalArgumentException ( lr_13 ) ; } String flags = lr_14 ; if ( kb ) { MST[rv.ROR1Mutator]MSP[]
inr = new BufferedReader ( new InputStreamReader ( in , Charset . defaultCharset () ) ) ; String line = inr . readLine () ; while ( line != null && lines . size () < max ) { MST[rv.UOI1Mutator]MSP[]
innerLoop1: while ( j >= 0 ) { final char c = line . charAt ( j ) ; if ( Character . isDigit ( c ) ) { bytesEnd = j + 1 ; break innerLoop1; } j -- ; } innerLoop2: while ( j >= 0 ) { MST[rv.ROR3Mutator]MSP[]
flags += lr_15 ; } if ( posix ) { flags += lr_16 ; } final String [] cmdAttribs = flags . length () > 1 ? new String [] { DF , flags , path } : new String [] { DF , path } ; MST[InlineConstantMutator]MSP[]
if ( buf . charAt ( k ) == ',' || buf . charAt ( k ) == '.' ) { MST[rv.CRCR2Mutator]MSP[] buf . deleteCharAt ( k -- ) ; } } return parseBytes ( buf . toString () , path ) ; }
flags += lr_15 ; } if ( posix ) { MST[rv.ROR5Mutator]MSP[] flags += lr_16 ; } final String [] cmdAttribs = flags . length () > 1 ? new String [] { DF , flags , path } : new String [] { DF , path } ;
final List < String > lines = performCommand ( cmdAttribs , 3 , timeout ) ; MST[NonVoidMethodCallMutator]MSP[] if ( lines . size () < 2 ) { throw new IOException ( lr_17 + DF + lr_18 + lr_10 + path + lr_19 + lines ) ; }
String normPath = FilenameUtils . normalize ( path , false ) ; if ( normPath == null ) { MST[NegateConditionalsMutator]MSP[] throw new IllegalArgumentException ( path ) ; } if ( normPath . length () > 0 && normPath . charAt ( 0 ) != '"' ) {
final String line2 = lines . get ( 1 ) ; StringTokenizer tok = new StringTokenizer ( line2 , lr_20 ) ; if ( tok . countTokens () < 4 ) { if ( tok . countTokens () == 1 && lines . size () >= 3 ) { MST[rv.ROR1Mutator]MSP[]
final long bytes = Long . parseLong ( freeSpace ) ; if ( bytes < 0 ) { MST[rv.ABSMutator]MSP[] throw new IOException ( lr_17 + DF + lr_23 + lr_10 + path + lr_22 ) ; } return bytes ; } catch ( final NumberFormatException ex ) {
throw new IOException ( MST[NonVoidMethodCallMutator]MSP[] lr_17 + DF + lr_24 + lr_10 + path + lr_22 , ex ) ; } } List < String > performCommand ( final String [] cmdAttribs , final int max , final long timeout ) throws IOException {
innerLoop1: while ( j >= 0 ) { final char c = line . charAt ( j ) ; if ( Character . isDigit ( c ) ) { MST[rv.UOI4Mutator]MSP[] bytesEnd = j + 1 ; break innerLoop1; } j -- ; } innerLoop2: while ( j >= 0 ) {
flags += lr_15 ; } if ( posix ) { MST[rv.UOI4Mutator]MSP[] flags += lr_16 ; } final String [] cmdAttribs = flags . length () > 1 ? new String [] { DF , flags , path } : new String [] { DF , path } ;
final List < String > lines = performCommand ( cmdAttribs , 3 , timeout ) ; if ( lines . size () < 2 ) { MST[NegateConditionalsMutator]MSP[] throw new IOException ( lr_17 + DF + lr_18 + lr_10 + path + lr_19 + lines ) ; }
} tok . nextToken () ; tok . nextToken () ; final String freeSpace = tok . nextToken () ; return parseBytes ( freeSpace , path ) ; MST[PrimitiveReturnsMutator]MSP[] } long parseBytes ( final String freeSpace , final String path ) throws IOException { try {
return freeSpaceKb ( path , - 1 ) ; MST[rv.CRCR4Mutator]MSP[] } @Deprecated public static long freeSpaceKb ( final String path , final long timeout ) throws IOException { return INSTANCE . freeSpaceOS ( path , OS , true , timeout ) ; } @Deprecated
final String line3 = lines . get ( 2 ) ; MST[rv.CRCR2Mutator]MSP[] tok = new StringTokenizer ( line3 , lr_20 ) ; } else { throw new IOException ( lr_17 + DF + lr_21 + lr_10 + path + lr_22 ) ; } } else { tok . nextToken () ;
flags += lr_15 ; } if ( posix ) { flags += lr_16 ; } final String [] cmdAttribs = flags . length () > 1 ? new String [] { DF , flags , path } : new String [] { DF , path } ; MST[InlineConstantMutator]MSP[]
return kb ? freeSpaceWindows ( path , timeout ) / FileUtils . ONE_KB : freeSpaceWindows ( path , timeout ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] case UNIX : return freeSpaceUnix ( path , kb , false , timeout ) ; case POSIX_UNIX :
flags += lr_15 ; } if ( posix ) { flags += lr_16 ; MST[NonVoidMethodCallMutator]MSP[] } final String [] cmdAttribs = flags . length () > 1 ? new String [] { DF , flags , path } : new String [] { DF , path } ;
final char c = line . charAt ( j ) ; if ( ! Character . isDigit ( c ) && c != ',' && c != '.' ) { MST[rv.CRCR5Mutator]MSP[] bytesStart = j + 1 ; break innerLoop2; } j -- ; } if ( j < 0 ) {
final char c = line . charAt ( j ) ; if ( ! Character . isDigit ( c ) && c != ',' && c != '.' ) { bytesStart = j + 1 ; break innerLoop2; } j -- ; } if ( j < 0 ) { MST[ConditionalsBoundaryMutator]MSP[]
throw new IOException ( MST[experimental.NakedReceiverMutator]MSP[] lr_12 + lr_10 + path + lr_11 ) ; } final StringBuilder buf = new StringBuilder ( line . substring ( bytesStart , bytesEnd ) ) ; for ( int k = 0 ; k < buf . length () ; k ++ ) {
long freeSpaceOS ( final String path , final int os , final boolean kb , final long timeout ) throws IOException { if ( path == null ) { throw new IllegalArgumentException ( lr_2 ) ; } switch ( os ) { MST[rv.UOI4Mutator]MSP[] case WINDOWS :
} finally { IOUtils . closeQuietly ( in ) ; IOUtils . closeQuietly ( out ) ; IOUtils . closeQuietly ( err ) ; IOUtils . closeQuietly ( inr ) ; if ( proc != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] proc . destroy () ; } } }
String normPath = FilenameUtils . normalize ( path , false ) ; MST[InlineConstantMutator]MSP[] if ( normPath == null ) { throw new IllegalArgumentException ( path ) ; } if ( normPath . length () > 0 && normPath . charAt ( 0 ) != '"' ) {
innerLoop1: while ( j >= 0 ) { final char c = line . charAt ( j ) ; if ( Character . isDigit ( c ) ) { bytesEnd = j + 1 ; MST[rv.CRCR2Mutator]MSP[] break innerLoop1; } j -- ; } innerLoop2: while ( j >= 0 ) {
String normPath = FilenameUtils . normalize ( path , false ) ; if ( normPath == null ) { throw new IllegalArgumentException ( path ) ; } if ( normPath . length () > 0 && normPath . charAt ( 0 ) != '"' ) { MST[NonVoidMethodCallMutator]MSP[]
@Deprecated public static long freeSpace ( final String path ) throws IOException { return INSTANCE . freeSpaceOS ( path , OS , false , - 1 ) ; MST[rv.CRCR1Mutator]MSP[] } @Deprecated public static long freeSpaceKb ( final String path ) throws IOException {
} throw new IOException ( MST[experimental.NakedReceiverMutator]MSP[] lr_9 + lr_10 + normPath + lr_11 ) ; } long parseDir ( final String line , final String path ) throws IOException { int bytesStart = 0 ; int bytesEnd = 0 ; int j = line . length () - 1 ;
throw new IOException ( lr_12 + lr_10 + path + lr_11 ) ; } final StringBuilder buf = new StringBuilder ( line . substring ( bytesStart , bytesEnd ) ) ; for ( int k = 0 ; k < buf . length () ; k ++ ) { MST[rv.ROR1Mutator]MSP[]
if ( proc . exitValue () != 0 ) { throw new IOException ( lr_25 + proc . exitValue () + lr_26 + Arrays . asList ( cmdAttribs ) ) ; } if ( lines . isEmpty () ) { MST[rv.ROR2Mutator]MSP[] throw new IOException ( lr_27 +
return kb ? freeSpaceWindows ( path , timeout ) / FileUtils . ONE_KB : freeSpaceWindows ( path , timeout ) ; MST[rv.ROR3Mutator]MSP[] case UNIX : return freeSpaceUnix ( path , kb , false , timeout ) ; case POSIX_UNIX :
normPath = lr_5 + normPath + lr_5 ; MST[NonVoidMethodCallMutator]MSP[] } final String [] cmdAttribs = new String [] { lr_6 , lr_7 , lr_8 + normPath } ; final List < String > lines = performCommand ( cmdAttribs , Integer . MAX_VALUE , timeout ) ;
return kb ? freeSpaceWindows ( path , timeout ) / FileUtils . ONE_KB : freeSpaceWindows ( path , timeout ) ; MST[rv.UOI2Mutator]MSP[] case UNIX : return freeSpaceUnix ( path , kb , false , timeout ) ; case POSIX_UNIX :
for ( int i = lines . size () - 1 ; i >= 0 ; i -- ) { final String line = lines . get ( i ) ; if ( line . length () > 0 ) { MST[rv.ROR2Mutator]MSP[] return parseDir ( line , normPath ) ; }
inr = new BufferedReader ( new InputStreamReader ( in , Charset . defaultCharset () ) ) ; String line = inr . readLine () ; while ( line != null && lines . size () < max ) { MST[rv.ROR5Mutator]MSP[]
throw new IOException ( MST[NonVoidMethodCallMutator]MSP[] lr_12 + lr_10 + path + lr_11 ) ; } final StringBuilder buf = new StringBuilder ( line . substring ( bytesStart , bytesEnd ) ) ; for ( int k = 0 ; k < buf . length () ; k ++ ) {
innerLoop1: while ( j >= 0 ) { final char c = line . charAt ( j ) ; if ( Character . isDigit ( c ) ) { bytesEnd = j + 1 ; break innerLoop1; } j -- ; } innerLoop2: while ( j >= 0 ) { MST[rv.ABSMutator]MSP[]
final List < String > lines = performCommand ( cmdAttribs , 3 , timeout ) ; if ( lines . size () < 2 ) { MST[rv.ROR5Mutator]MSP[] throw new IOException ( lr_17 + DF + lr_18 + lr_10 + path + lr_19 + lines ) ; }
String normPath = FilenameUtils . normalize ( path , false ) ; if ( normPath == null ) { throw new IllegalArgumentException ( path ) ; } if ( normPath . length () > 0 && normPath . charAt ( 0 ) != '"' ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[]
flags += lr_15 ; MST[NonVoidMethodCallMutator]MSP[] } if ( posix ) { flags += lr_16 ; } final String [] cmdAttribs = flags . length () > 1 ? new String [] { DF , flags , path } : new String [] { DF , path } ;
final String line3 = lines . get ( 2 ) ; MST[NonVoidMethodCallMutator]MSP[] tok = new StringTokenizer ( line3 , lr_20 ) ; } else { throw new IOException ( lr_17 + DF + lr_21 + lr_10 + path + lr_22 ) ; } } else { tok . nextToken () ;
final String line3 = lines . get ( 2 ) ; tok = new StringTokenizer ( line3 , lr_20 ) ; } else { throw new IOException ( MST[experimental.NakedReceiverMutator]MSP[] lr_17 + DF + lr_21 + lr_10 + path + lr_22 ) ; } } else { tok . nextToken () ;
flags += lr_15 ; } if ( posix ) { MST[NegateConditionalsMutator]MSP[] flags += lr_16 ; } final String [] cmdAttribs = flags . length () > 1 ? new String [] { DF , flags , path } : new String [] { DF , path } ;
final long bytes = Long . parseLong ( freeSpace ) ; if ( bytes < 0 ) { throw new IOException ( MST[experimental.NakedReceiverMutator]MSP[] lr_17 + DF + lr_23 + lr_10 + path + lr_22 ) ; } return bytes ; } catch ( final NumberFormatException ex ) {
if ( buf . charAt ( k ) == ',' || buf . charAt ( k ) == '.' ) { buf . deleteCharAt ( k -- ) ; MST[rv.UOI4Mutator]MSP[] } } return parseBytes ( buf . toString () , path ) ; }
final char c = line . charAt ( j ) ; if ( ! Character . isDigit ( c ) && c != ',' && c != '.' ) { bytesStart = j + 1 ; break innerLoop2; } j -- ; } if ( j < 0 ) { MST[NegateConditionalsMutator]MSP[]
if ( proc . exitValue () != 0 ) { throw new IOException ( lr_25 + proc . exitValue () + MST[experimental.NakedReceiverMutator]MSP[] lr_26 + Arrays . asList ( cmdAttribs ) ) ; } if ( lines . isEmpty () ) { throw new IOException ( lr_27 +
if ( buf . charAt ( k ) == ',' || buf . charAt ( k ) == '.' ) { buf . deleteCharAt ( k -- ) ; MST[rv.UOI1Mutator]MSP[] } } return parseBytes ( buf . toString () , path ) ; }
final Thread monitor = ThreadMonitor . start ( timeout ) ; MST[NonVoidMethodCallMutator]MSP[] proc = openProcess ( cmdAttribs ) ; in = proc . getInputStream () ; out = proc . getOutputStream () ; err = proc . getErrorStream () ;
final String line2 = lines . get ( 1 ) ; StringTokenizer tok = new StringTokenizer ( line2 , lr_20 ) ; if ( tok . countTokens () < 4 ) { MST[rv.CRCR2Mutator]MSP[] if ( tok . countTokens () == 1 && lines . size () >= 3 ) {
throw new IOException ( MST[experimental.NakedReceiverMutator]MSP[] lr_17 + DF + lr_24 + lr_10 + path + lr_22 , ex ) ; } } List < String > performCommand ( final String [] cmdAttribs , final int max , final long timeout ) throws IOException {
if ( proc . exitValue () != 0 ) { throw new IOException ( lr_25 + proc . exitValue () + lr_26 + Arrays . asList ( cmdAttribs ) ) ; MST[ConstructorCallMutator]MSP[] } if ( lines . isEmpty () ) { throw new IOException ( lr_27 +
final long bytes = Long . parseLong ( freeSpace ) ; if ( bytes < 0 ) { throw new IOException ( lr_17 + DF + lr_23 + lr_10 + path + lr_22 ) ; } return bytes ; MST[rv.UOI1Mutator]MSP[] } catch ( final NumberFormatException ex ) {
if ( buf . charAt ( k ) == ',' || buf . charAt ( k ) == '.' ) { MST[NegateConditionalsMutator]MSP[] buf . deleteCharAt ( k -- ) ; } } return parseBytes ( buf . toString () , path ) ; }
lr_28 + Arrays . asList ( cmdAttribs ) ) ; } inr . close () ; inr = null ; in . close () ; in = null ; if ( out != null ) { out . close () ; MST[VoidMethodCallMutator]MSP[] out = null ; }
inr = new BufferedReader ( new InputStreamReader ( in , Charset . defaultCharset () ) ) ; String line = inr . readLine () ; while ( line != null && lines . size () < max ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
throw new IOException ( lr_12 + lr_10 + path + lr_11 ) ; } final StringBuilder buf = new StringBuilder ( line . substring ( bytesStart , bytesEnd ) ) ; for ( int k = 0 ; k < buf . length () ; k ++ ) { MST[rv.UOI3Mutator]MSP[]
final char c = line . charAt ( j ) ; if ( ! Character . isDigit ( c ) && c != ',' && c != '.' ) { MST[rv.ROR1Mutator]MSP[] bytesStart = j + 1 ; break innerLoop2; } j -- ; } if ( j < 0 ) {
public static long freeSpaceKb () throws IOException { return freeSpaceKb ( - 1 ) ; } @Deprecated public static long freeSpaceKb ( final long timeout ) throws IOException { return freeSpaceKb ( new File ( lr_1 ) . getAbsolutePath () , timeout ) ; MST[rv.UOI1Mutator]MSP[] }
throw new IOException ( lr_12 + lr_10 + path + lr_11 ) ; } final StringBuilder buf = new StringBuilder ( line . substring ( bytesStart , bytesEnd ) ) ; for ( int k = 0 ; k < buf . length () ; k ++ ) { MST[InlineConstantMutator]MSP[]
inr = new BufferedReader ( new InputStreamReader ( in , Charset . defaultCharset () ) ) ; String line = inr . readLine () ; while ( line != null && lines . size () < max ) { MST[rv.ROR2Mutator]MSP[]
return kb ? freeSpaceWindows ( path , timeout ) / FileUtils . ONE_KB : freeSpaceWindows ( path , timeout ) ; MST[rv.ABSMutator]MSP[] case UNIX : return freeSpaceUnix ( path , kb , false , timeout ) ; case POSIX_UNIX :
return freeSpaceKb ( path , - 1 ) ; } @Deprecated public static long freeSpaceKb ( final String path , final long timeout ) throws IOException { return INSTANCE . freeSpaceOS ( path , OS , true , timeout ) ; MST[rv.CRCR3Mutator]MSP[] } @Deprecated
flags += lr_15 ; } if ( posix ) { flags += lr_16 ; } final String [] cmdAttribs = flags . length () > 1 ? new String [] { DF , flags , path } : new String [] { DF , path } ; MST[rv.CRCR6Mutator]MSP[]
String normPath = FilenameUtils . normalize ( path , false ) ; if ( normPath == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] throw new IllegalArgumentException ( path ) ; } if ( normPath . length () > 0 && normPath . charAt ( 0 ) != '"' ) {
} tok . nextToken () ; tok . nextToken () ; final String freeSpace = tok . nextToken () ; return parseBytes ( freeSpace , path ) ; MST[NonVoidMethodCallMutator]MSP[] } long parseBytes ( final String freeSpace , final String path ) throws IOException { try {
innerLoop1: while ( j >= 0 ) { final char c = line . charAt ( j ) ; if ( Character . isDigit ( c ) ) { bytesEnd = j + 1 ; MST[rv.AOR3Mutator]MSP[] break innerLoop1; } j -- ; } innerLoop2: while ( j >= 0 ) {
@Deprecated public static long freeSpace ( final String path ) throws IOException { return INSTANCE . freeSpaceOS ( path , OS , false , - 1 ) ; MST[rv.UOI1Mutator]MSP[] } @Deprecated public static long freeSpaceKb ( final String path ) throws IOException {
return kb ? freeSpaceWindows ( path , timeout ) / FileUtils . ONE_KB : freeSpaceWindows ( path , timeout ) ; MST[rv.AOR4Mutator]MSP[] case UNIX : return freeSpaceUnix ( path , kb , false , timeout ) ; case POSIX_UNIX :
String normPath = FilenameUtils . normalize ( path , false ) ; if ( normPath == null ) { throw new IllegalArgumentException ( path ) ; } if ( normPath . length () > 0 && normPath . charAt ( 0 ) != '"' ) { MST[ConditionalsBoundaryMutator]MSP[]
for ( int i = lines . size () - 1 ; i >= 0 ; i -- ) { MST[rv.UOI2Mutator]MSP[] final String line = lines . get ( i ) ; if ( line . length () > 0 ) { return parseDir ( line , normPath ) ; }
final List < String > lines = performCommand ( cmdAttribs , 3 , timeout ) ; if ( lines . size () < 2 ) { MST[rv.CRCR3Mutator]MSP[] throw new IOException ( lr_17 + DF + lr_18 + lr_10 + path + lr_19 + lines ) ; }
if ( proc . exitValue () != 0 ) { MST[rv.ROR2Mutator]MSP[] throw new IOException ( lr_25 + proc . exitValue () + lr_26 + Arrays . asList ( cmdAttribs ) ) ; } if ( lines . isEmpty () ) { throw new IOException ( lr_27 +
throw new IOException ( MST[experimental.NakedReceiverMutator]MSP[] lr_12 + lr_10 + path + lr_11 ) ; } final StringBuilder buf = new StringBuilder ( line . substring ( bytesStart , bytesEnd ) ) ; for ( int k = 0 ; k < buf . length () ; k ++ ) {
for ( int i = lines . size () - 1 ; i >= 0 ; i -- ) { final String line = lines . get ( i ) ; if ( line . length () > 0 ) { return parseDir ( line , normPath ) ; MST[PrimitiveReturnsMutator]MSP[] }
return kb ? freeSpaceWindows ( path , timeout ) / FileUtils . ONE_KB : freeSpaceWindows ( path , timeout ) ; MST[MathMutator]MSP[] case UNIX : return freeSpaceUnix ( path , kb , false , timeout ) ; case POSIX_UNIX :
line = line . toLowerCase ( Locale . ENGLISH ) . trim () ; lines . add ( line ) ; line = inr . readLine () ; MST[NonVoidMethodCallMutator]MSP[] } proc . waitFor () ; ThreadMonitor . stop ( monitor ) ;
normPath = lr_5 + normPath + lr_5 ; } final String [] cmdAttribs = new String [] { lr_6 , lr_7 , lr_8 + normPath } ; final List < String > lines = performCommand ( cmdAttribs , Integer . MAX_VALUE , timeout ) ; MST[rv.UOI3Mutator]MSP[]
final char c = line . charAt ( j ) ; if ( ! Character . isDigit ( c ) && c != ',' && c != '.' ) { bytesStart = j + 1 ; break innerLoop2; } j -- ; } if ( j < 0 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[]
if ( buf . charAt ( k ) == ',' || buf . charAt ( k ) == '.' ) { MST[rv.CRCR3Mutator]MSP[] buf . deleteCharAt ( k -- ) ; } } return parseBytes ( buf . toString () , path ) ; }
long freeSpaceUnix ( final String path , final boolean kb , final boolean posix , final long timeout ) throws IOException { if ( path . isEmpty () ) { MST[rv.ROR5Mutator]MSP[] throw new IllegalArgumentException ( lr_13 ) ; } String flags = lr_14 ; if ( kb ) {
final char c = line . charAt ( j ) ; if ( ! Character . isDigit ( c ) && c != ',' && c != '.' ) { bytesStart = j + 1 ; MST[rv.UOI2Mutator]MSP[] break innerLoop2; } j -- ; } if ( j < 0 ) {
final long bytes = Long . parseLong ( freeSpace ) ; if ( bytes < 0 ) { throw new IOException ( MST[NonVoidMethodCallMutator]MSP[] lr_17 + DF + lr_23 + lr_10 + path + lr_22 ) ; } return bytes ; } catch ( final NumberFormatException ex ) {
} throw new IOException ( MST[experimental.NakedReceiverMutator]MSP[] lr_9 + lr_10 + normPath + lr_11 ) ; } long parseDir ( final String line , final String path ) throws IOException { int bytesStart = 0 ; int bytesEnd = 0 ; int j = line . length () - 1 ;
long freeSpaceUnix ( final String path , final boolean kb , final boolean posix , final long timeout ) throws IOException { if ( path . isEmpty () ) { MST[rv.ROR2Mutator]MSP[] throw new IllegalArgumentException ( lr_13 ) ; } String flags = lr_14 ; if ( kb ) {
final char c = line . charAt ( j ) ; MST[NonVoidMethodCallMutator]MSP[] if ( ! Character . isDigit ( c ) && c != ',' && c != '.' ) { bytesStart = j + 1 ; break innerLoop2; } j -- ; } if ( j < 0 ) {
throw new IOException ( MST[ConstructorCallMutator]MSP[] lr_17 + DF + lr_24 + lr_10 + path + lr_22 , ex ) ; } } List < String > performCommand ( final String [] cmdAttribs , final int max , final long timeout ) throws IOException {
final char c = line . charAt ( j ) ; if ( ! Character . isDigit ( c ) && c != ',' && c != '.' ) { MST[rv.ROR2Mutator]MSP[] bytesStart = j + 1 ; break innerLoop2; } j -- ; } if ( j < 0 ) {
final List < String > lines = performCommand ( cmdAttribs , 3 , timeout ) ; MST[rv.CRCR6Mutator]MSP[] if ( lines . size () < 2 ) { throw new IOException ( lr_17 + DF + lr_18 + lr_10 + path + lr_19 + lines ) ; }
final List < String > lines = performCommand ( cmdAttribs , 3 , timeout ) ; if ( lines . size () < 2 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] throw new IOException ( lr_17 + DF + lr_18 + lr_10 + path + lr_19 + lines ) ; }
normPath = lr_5 + normPath + lr_5 ; MST[NonVoidMethodCallMutator]MSP[] } final String [] cmdAttribs = new String [] { lr_6 , lr_7 , lr_8 + normPath } ; final List < String > lines = performCommand ( cmdAttribs , Integer . MAX_VALUE , timeout ) ;
final long bytes = Long . parseLong ( freeSpace ) ; if ( bytes < 0 ) { throw new IOException ( lr_17 + DF + lr_23 + lr_10 + path + lr_22 ) ; } return bytes ; MST[rv.UOI4Mutator]MSP[] } catch ( final NumberFormatException ex ) {
final char c = line . charAt ( j ) ; if ( ! Character . isDigit ( c ) && c != ',' && c != '.' ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] bytesStart = j + 1 ; break innerLoop2; } j -- ; } if ( j < 0 ) {
flags += lr_15 ; } if ( posix ) { flags += lr_16 ; } final String [] cmdAttribs = flags . length () > 1 ? new String [] { DF , flags , path } : new String [] { DF , path } ; MST[rv.CRCR1Mutator]MSP[]
} throw new IOException ( lr_9 + lr_10 + normPath + lr_11 ) ; } long parseDir ( final String line , final String path ) throws IOException { int bytesStart = 0 ; int bytesEnd = 0 ; MST[InlineConstantMutator]MSP[] int j = line . length () - 1 ;
long freeSpaceOS ( final String path , final int os , final boolean kb , final long timeout ) throws IOException { if ( path == null ) { throw new IllegalArgumentException ( lr_2 ) ; } switch ( os ) { MST[rv.UOI1Mutator]MSP[] case WINDOWS :
final long bytes = Long . parseLong ( freeSpace ) ; if ( bytes < 0 ) { throw new IOException ( MST[experimental.NakedReceiverMutator]MSP[] lr_17 + DF + lr_23 + lr_10 + path + lr_22 ) ; } return bytes ; } catch ( final NumberFormatException ex ) {
flags += lr_15 ; MST[NonVoidMethodCallMutator]MSP[] } if ( posix ) { flags += lr_16 ; } final String [] cmdAttribs = flags . length () > 1 ? new String [] { DF , flags , path } : new String [] { DF , path } ;
innerLoop1: while ( j >= 0 ) { final char c = line . charAt ( j ) ; MST[NonVoidMethodCallMutator]MSP[] if ( Character . isDigit ( c ) ) { bytesEnd = j + 1 ; break innerLoop1; } j -- ; } innerLoop2: while ( j >= 0 ) {
flags += lr_15 ; } if ( posix ) { MST[rv.ROR2Mutator]MSP[] flags += lr_16 ; } final String [] cmdAttribs = flags . length () > 1 ? new String [] { DF , flags , path } : new String [] { DF , path } ;
return kb ? freeSpaceWindows ( path , timeout ) / FileUtils . ONE_KB : freeSpaceWindows ( path , timeout ) ; MST[rv.CRCR3Mutator]MSP[] case UNIX : return freeSpaceUnix ( path , kb , false , timeout ) ; case POSIX_UNIX :
innerLoop1: while ( j >= 0 ) { final char c = line . charAt ( j ) ; if ( Character . isDigit ( c ) ) { MST[rv.UOI1Mutator]MSP[] bytesEnd = j + 1 ; break innerLoop1; } j -- ; } innerLoop2: while ( j >= 0 ) {
innerLoop1: while ( j >= 0 ) { final char c = line . charAt ( j ) ; if ( Character . isDigit ( c ) ) { MST[rv.ROR1Mutator]MSP[] bytesEnd = j + 1 ; break innerLoop1; } j -- ; } innerLoop2: while ( j >= 0 ) {
@Deprecated public static long freeSpace ( final String path ) throws IOException { return INSTANCE . freeSpaceOS ( path , OS , false , - 1 ) ; MST[rv.UOI4Mutator]MSP[] } @Deprecated public static long freeSpaceKb ( final String path ) throws IOException {
final char c = line . charAt ( j ) ; if ( ! Character . isDigit ( c ) && c != ',' && c != '.' ) { bytesStart = j + 1 ; break innerLoop2; } j -- ; } if ( j < 0 ) { MST[rv.UOI4Mutator]MSP[]
final char c = line . charAt ( j ) ; if ( ! Character . isDigit ( c ) && c != ',' && c != '.' ) { bytesStart = j + 1 ; MST[rv.ABSMutator]MSP[] break innerLoop2; } j -- ; } if ( j < 0 ) {
for ( int i = lines . size () - 1 ; i >= 0 ; i -- ) { MST[ConditionalsBoundaryMutator]MSP[] final String line = lines . get ( i ) ; if ( line . length () > 0 ) { return parseDir ( line , normPath ) ; }
if ( buf . charAt ( k ) == ',' || buf . charAt ( k ) == '.' ) { MST[rv.ROR4Mutator]MSP[] buf . deleteCharAt ( k -- ) ; } } return parseBytes ( buf . toString () , path ) ; }
return freeSpaceUnix ( path , kb , true , timeout ) ; MST[rv.UOI1Mutator]MSP[] case OTHER : throw new IllegalStateException ( lr_3 ) ; default: throw new IllegalStateException ( lr_4 ) ; } } long freeSpaceWindows ( final String path , final long timeout ) throws IOException {
final char c = line . charAt ( j ) ; if ( ! Character . isDigit ( c ) && c != ',' && c != '.' ) { MST[rv.CRCR3Mutator]MSP[] bytesStart = j + 1 ; break innerLoop2; } j -- ; } if ( j < 0 ) {
public static long freeSpaceKb () throws IOException { return freeSpaceKb ( - 1 ) ; } @Deprecated public static long freeSpaceKb ( final long timeout ) throws IOException { return freeSpaceKb ( new File ( lr_1 ) . getAbsolutePath () , timeout ) ; MST[ArgumentPropagationMutator]MSP[] }
innerLoop1: while ( j >= 0 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] final char c = line . charAt ( j ) ; if ( Character . isDigit ( c ) ) { bytesEnd = j + 1 ; break innerLoop1; } j -- ; } innerLoop2: while ( j >= 0 ) {
String normPath = FilenameUtils . normalize ( path , false ) ; if ( normPath == null ) { throw new IllegalArgumentException ( path ) ; } if ( normPath . length () > 0 && normPath . charAt ( 0 ) != '"' ) { MST[rv.ROR4Mutator]MSP[]
throw new IOException ( lr_12 + lr_10 + path + lr_11 ) ; } final StringBuilder buf = new StringBuilder ( line . substring ( bytesStart , bytesEnd ) ) ; MST[NonVoidMethodCallMutator]MSP[] for ( int k = 0 ; k < buf . length () ; k ++ ) {
for ( int i = lines . size () - 1 ; i >= 0 ; i -- ) { final String line = lines . get ( i ) ; if ( line . length () > 0 ) { MST[rv.ROR5Mutator]MSP[] return parseDir ( line , normPath ) ; }
return freeSpaceUnix ( path , kb , true , timeout ) ; MST[rv.CRCR3Mutator]MSP[] case OTHER : throw new IllegalStateException ( lr_3 ) ; default: throw new IllegalStateException ( lr_4 ) ; } } long freeSpaceWindows ( final String path , final long timeout ) throws IOException {
throw new IOException ( MST[experimental.NakedReceiverMutator]MSP[] lr_17 + DF + lr_24 + lr_10 + path + lr_22 , ex ) ; } } List < String > performCommand ( final String [] cmdAttribs , final int max , final long timeout ) throws IOException {
public static long freeSpaceKb () throws IOException { return freeSpaceKb ( - 1 ) ; } @Deprecated public static long freeSpaceKb ( final long timeout ) throws IOException { return freeSpaceKb ( new File ( lr_1 ) . getAbsolutePath () , timeout ) ; MST[NonVoidMethodCallMutator]MSP[] }
@Deprecated public static long freeSpace ( final String path ) throws IOException { return INSTANCE . freeSpaceOS ( path , OS , false , - 1 ) ; MST[rv.CRCR2Mutator]MSP[] } @Deprecated public static long freeSpaceKb ( final String path ) throws IOException {
normPath = lr_5 + normPath + lr_5 ; } final String [] cmdAttribs = new String [] { lr_6 , lr_7 , lr_8 + normPath } ; MST[rv.CRCR6Mutator]MSP[] final List < String > lines = performCommand ( cmdAttribs , Integer . MAX_VALUE , timeout ) ;
innerLoop1: while ( j >= 0 ) { MST[ConditionalsBoundaryMutator]MSP[] final char c = line . charAt ( j ) ; if ( Character . isDigit ( c ) ) { bytesEnd = j + 1 ; break innerLoop1; } j -- ; } innerLoop2: while ( j >= 0 ) {
final String line2 = lines . get ( 1 ) ; StringTokenizer tok = new StringTokenizer ( line2 , lr_20 ) ; if ( tok . countTokens () < 4 ) { if ( tok . countTokens () == 1 && lines . size () >= 3 ) { MST[rv.CRCR4Mutator]MSP[]
flags += lr_15 ; } if ( posix ) { flags += lr_16 ; } final String [] cmdAttribs = flags . length () > 1 ? new String [] { DF , flags , path } : new String [] { DF , path } ; MST[rv.CRCR2Mutator]MSP[]
if ( proc . exitValue () != 0 ) { throw new IOException ( lr_25 + proc . exitValue () + lr_26 + Arrays . asList ( cmdAttribs ) ) ; } if ( lines . isEmpty () ) { MST[rv.ROR5Mutator]MSP[] throw new IOException ( lr_27 +
inr = new BufferedReader ( new InputStreamReader ( in , Charset . defaultCharset () ) ) ; MST[NonVoidMethodCallMutator]MSP[] String line = inr . readLine () ; while ( line != null && lines . size () < max ) {
final long bytes = Long . parseLong ( freeSpace ) ; if ( bytes < 0 ) { MST[NegateConditionalsMutator]MSP[] throw new IOException ( lr_17 + DF + lr_23 + lr_10 + path + lr_22 ) ; } return bytes ; } catch ( final NumberFormatException ex ) {
final char c = line . charAt ( j ) ; if ( ! Character . isDigit ( c ) && c != ',' && c != '.' ) { bytesStart = j + 1 ; break innerLoop2; } j -- ; } if ( j < 0 ) { MST[rv.ABSMutator]MSP[]
return freeSpaceUnix ( path , kb , true , timeout ) ; MST[rv.UOI3Mutator]MSP[] case OTHER : throw new IllegalStateException ( lr_3 ) ; default: throw new IllegalStateException ( lr_4 ) ; } } long freeSpaceWindows ( final String path , final long timeout ) throws IOException {
for ( int i = lines . size () - 1 ; i >= 0 ; i -- ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] final String line = lines . get ( i ) ; if ( line . length () > 0 ) { return parseDir ( line , normPath ) ; }
final char c = line . charAt ( j ) ; if ( ! Character . isDigit ( c ) && c != ',' && c != '.' ) { MST[InlineConstantMutator]MSP[] bytesStart = j + 1 ; break innerLoop2; } j -- ; } if ( j < 0 ) {
final List < String > lines = performCommand ( cmdAttribs , 3 , timeout ) ; if ( lines . size () < 2 ) { MST[rv.ROR2Mutator]MSP[] throw new IOException ( lr_17 + DF + lr_18 + lr_10 + path + lr_19 + lines ) ; }
if ( buf . charAt ( k ) == ',' || buf . charAt ( k ) == '.' ) { MST[NonVoidMethodCallMutator]MSP[] buf . deleteCharAt ( k -- ) ; } } return parseBytes ( buf . toString () , path ) ; }
return freeSpaceUnix ( path , kb , true , timeout ) ; case OTHER : throw new IllegalStateException ( lr_3 ) ; MST[ConstructorCallMutator]MSP[] default: throw new IllegalStateException ( lr_4 ) ; } } long freeSpaceWindows ( final String path , final long timeout ) throws IOException {
throw new IOException ( MST[experimental.NakedReceiverMutator]MSP[] lr_12 + lr_10 + path + lr_11 ) ; } final StringBuilder buf = new StringBuilder ( line . substring ( bytesStart , bytesEnd ) ) ; for ( int k = 0 ; k < buf . length () ; k ++ ) {
if ( buf . charAt ( k ) == ',' || buf . charAt ( k ) == '.' ) { MST[rv.ABSMutator]MSP[] buf . deleteCharAt ( k -- ) ; } } return parseBytes ( buf . toString () , path ) ; }
@Deprecated public static long freeSpace ( final String path ) throws IOException { return INSTANCE . freeSpaceOS ( path , OS , false , - 1 ) ; MST[rv.CRCR6Mutator]MSP[] } @Deprecated public static long freeSpaceKb ( final String path ) throws IOException {
normPath = lr_5 + normPath + lr_5 ; } final String [] cmdAttribs = new String [] { lr_6 , lr_7 , lr_8 + normPath } ; final List < String > lines = performCommand ( cmdAttribs , Integer . MAX_VALUE , timeout ) ; MST[rv.CRCR6Mutator]MSP[]
if ( buf . charAt ( k ) == ',' || buf . charAt ( k ) == '.' ) { MST[rv.ROR5Mutator]MSP[] buf . deleteCharAt ( k -- ) ; } } return parseBytes ( buf . toString () , path ) ; }
return freeSpaceKb ( path , - 1 ) ; } @Deprecated public static long freeSpaceKb ( final String path , final long timeout ) throws IOException { return INSTANCE . freeSpaceOS ( path , OS , true , timeout ) ; MST[rv.UOI3Mutator]MSP[] } @Deprecated
final char c = line . charAt ( j ) ; if ( ! Character . isDigit ( c ) && c != ',' && c != '.' ) { bytesStart = j + 1 ; MST[rv.CRCR4Mutator]MSP[] break innerLoop2; } j -- ; } if ( j < 0 ) {
final char c = line . charAt ( j ) ; if ( ! Character . isDigit ( c ) && c != ',' && c != '.' ) { bytesStart = j + 1 ; MST[rv.UOI4Mutator]MSP[] break innerLoop2; } j -- ; } if ( j < 0 ) {
inr = new BufferedReader ( new InputStreamReader ( in , Charset . defaultCharset () ) ) ; String line = inr . readLine () ; while ( line != null && lines . size () < max ) { MST[NegateConditionalsMutator]MSP[]
if ( proc . exitValue () != 0 ) { throw new IOException ( lr_25 + proc . exitValue () + lr_26 + Arrays . asList ( cmdAttribs ) ) ; } if ( lines . isEmpty () ) { throw new IOException ( MST[experimental.NakedReceiverMutator]MSP[] lr_27 +
normPath = lr_5 + normPath + lr_5 ; } final String [] cmdAttribs = new String [] { lr_6 , lr_7 , lr_8 + normPath } ; MST[rv.CRCR3Mutator]MSP[] final List < String > lines = performCommand ( cmdAttribs , Integer . MAX_VALUE , timeout ) ;
flags += lr_15 ; } if ( posix ) { flags += lr_16 ; } final String [] cmdAttribs = flags . length () > 1 ? new String [] { DF , flags , path } : new String [] { DF , path } ; MST[rv.CRCR2Mutator]MSP[]
} throw new IOException ( MST[experimental.NakedReceiverMutator]MSP[] lr_9 + lr_10 + normPath + lr_11 ) ; } long parseDir ( final String line , final String path ) throws IOException { int bytesStart = 0 ; int bytesEnd = 0 ; int j = line . length () - 1 ;
public static long freeSpaceKb () throws IOException { return freeSpaceKb ( - 1 ) ; } @Deprecated public static long freeSpaceKb ( final long timeout ) throws IOException { return freeSpaceKb ( new File ( lr_1 ) . getAbsolutePath () , timeout ) ; MST[rv.UOI3Mutator]MSP[] }
final char c = line . charAt ( j ) ; if ( ! Character . isDigit ( c ) && c != ',' && c != '.' ) { bytesStart = j + 1 ; MST[rv.AOD1Mutator]MSP[] break innerLoop2; } j -- ; } if ( j < 0 ) {
normPath = lr_5 + normPath + lr_5 ; MST[NonVoidMethodCallMutator]MSP[] } final String [] cmdAttribs = new String [] { lr_6 , lr_7 , lr_8 + normPath } ; final List < String > lines = performCommand ( cmdAttribs , Integer . MAX_VALUE , timeout ) ;
final List < String > lines = performCommand ( cmdAttribs , 3 , timeout ) ; MST[rv.UOI3Mutator]MSP[] if ( lines . size () < 2 ) { throw new IOException ( lr_17 + DF + lr_18 + lr_10 + path + lr_19 + lines ) ; }
long freeSpaceUnix ( final String path , final boolean kb , final boolean posix , final long timeout ) throws IOException { if ( path . isEmpty () ) { throw new IllegalArgumentException ( lr_13 ) ; } String flags = lr_14 ; if ( kb ) { MST[rv.ROR4Mutator]MSP[]
return kb ? freeSpaceWindows ( path , timeout ) / FileUtils . ONE_KB : freeSpaceWindows ( path , timeout ) ; case UNIX : return freeSpaceUnix ( path , kb , false , timeout ) ; MST[ArgumentPropagationMutator]MSP[] case POSIX_UNIX :
} tok . nextToken () ; MST[NonVoidMethodCallMutator]MSP[] tok . nextToken () ; final String freeSpace = tok . nextToken () ; return parseBytes ( freeSpace , path ) ; } long parseBytes ( final String freeSpace , final String path ) throws IOException { try {
inr = new BufferedReader ( new InputStreamReader ( in , Charset . defaultCharset () ) ) ; String line = inr . readLine () ; while ( line != null && lines . size () < max ) { MST[rv.ROR5Mutator]MSP[]
String normPath = FilenameUtils . normalize ( path , false ) ; if ( normPath == null ) { throw new IllegalArgumentException ( path ) ; } if ( normPath . length () > 0 && normPath . charAt ( 0 ) != '"' ) { MST[rv.CRCR1Mutator]MSP[]
final String line2 = lines . get ( 1 ) ; StringTokenizer tok = new StringTokenizer ( line2 , lr_20 ) ; if ( tok . countTokens () < 4 ) { if ( tok . countTokens () == 1 && lines . size () >= 3 ) { MST[rv.ROR4Mutator]MSP[]
return kb ? freeSpaceWindows ( path , timeout ) / FileUtils . ONE_KB : freeSpaceWindows ( path , timeout ) ; case UNIX : return freeSpaceUnix ( path , kb , false , timeout ) ; MST[rv.UOI4Mutator]MSP[] case POSIX_UNIX :
final List < String > lines = new ArrayList <> ( 20 ) ; MST[rv.CRCR3Mutator]MSP[] Process proc = null ; InputStream in = null ; OutputStream out = null ; InputStream err = null ; BufferedReader inr = null ; try {
return kb ? freeSpaceWindows ( path , timeout ) / FileUtils . ONE_KB : freeSpaceWindows ( path , timeout ) ; MST[rv.UOI2Mutator]MSP[] case UNIX : return freeSpaceUnix ( path , kb , false , timeout ) ; case POSIX_UNIX :
if ( proc . exitValue () != 0 ) { throw new IOException ( lr_25 + proc . exitValue () + MST[NonVoidMethodCallMutator]MSP[] lr_26 + Arrays . asList ( cmdAttribs ) ) ; } if ( lines . isEmpty () ) { throw new IOException ( lr_27 +
innerLoop1: while ( j >= 0 ) { final char c = line . charAt ( j ) ; if ( Character . isDigit ( c ) ) { bytesEnd = j + 1 ; break innerLoop1; } j -- ; } innerLoop2: while ( j >= 0 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[]
final long bytes = Long . parseLong ( freeSpace ) ; if ( bytes < 0 ) { throw new IOException ( MST[experimental.NakedReceiverMutator]MSP[] lr_17 + DF + lr_23 + lr_10 + path + lr_22 ) ; } return bytes ; } catch ( final NumberFormatException ex ) {
innerLoop1: while ( j >= 0 ) { final char c = line . charAt ( j ) ; if ( Character . isDigit ( c ) ) { bytesEnd = j + 1 ; MST[rv.UOI2Mutator]MSP[] break innerLoop1; } j -- ; } innerLoop2: while ( j >= 0 ) {
inr = new BufferedReader ( new InputStreamReader ( in , Charset . defaultCharset () ) ) ; String line = inr . readLine () ; while ( line != null && lines . size () < max ) { MST[rv.UOI4Mutator]MSP[]
final char c = line . charAt ( j ) ; if ( ! Character . isDigit ( c ) && c != ',' && c != '.' ) { bytesStart = j + 1 ; break innerLoop2; } j -- ; } if ( j < 0 ) { MST[rv.ROR5Mutator]MSP[]
for ( int i = lines . size () - 1 ; i >= 0 ; i -- ) { MST[rv.CRCR2Mutator]MSP[] final String line = lines . get ( i ) ; if ( line . length () > 0 ) { return parseDir ( line , normPath ) ; }
flags += lr_15 ; } if ( posix ) { flags += lr_16 ; } final String [] cmdAttribs = flags . length () > 1 ? new String [] { DF , flags , path } : new String [] { DF , path } ; MST[rv.CRCR4Mutator]MSP[]
inr = new BufferedReader ( new InputStreamReader ( in , Charset . defaultCharset () ) ) ; String line = inr . readLine () ; while ( line != null && lines . size () < max ) { MST[NonVoidMethodCallMutator]MSP[]
innerLoop1: while ( j >= 0 ) { final char c = line . charAt ( j ) ; if ( Character . isDigit ( c ) ) { MST[rv.ROR3Mutator]MSP[] bytesEnd = j + 1 ; break innerLoop1; } j -- ; } innerLoop2: while ( j >= 0 ) {
innerLoop1: while ( j >= 0 ) { final char c = line . charAt ( j ) ; if ( Character . isDigit ( c ) ) { bytesEnd = j + 1 ; MST[rv.AOR1Mutator]MSP[] break innerLoop1; } j -- ; } innerLoop2: while ( j >= 0 ) {
final String line3 = lines . get ( 2 ) ; tok = new StringTokenizer ( line3 , lr_20 ) ; } else { throw new IOException ( MST[ConstructorCallMutator]MSP[] lr_17 + DF + lr_21 + lr_10 + path + lr_22 ) ; } } else { tok . nextToken () ;
return freeSpaceUnix ( path , kb , true , timeout ) ; MST[rv.UOI1Mutator]MSP[] case OTHER : throw new IllegalStateException ( lr_3 ) ; default: throw new IllegalStateException ( lr_4 ) ; } } long freeSpaceWindows ( final String path , final long timeout ) throws IOException {
lr_28 + Arrays . asList ( cmdAttribs ) ) ; MST[NonVoidMethodCallMutator]MSP[] } inr . close () ; inr = null ; in . close () ; in = null ; if ( out != null ) { out . close () ; out = null ; }
public static long freeSpaceKb () throws IOException { return freeSpaceKb ( - 1 ) ; } @Deprecated public static long freeSpaceKb ( final long timeout ) throws IOException { return freeSpaceKb ( new File ( lr_1 ) . getAbsolutePath () , timeout ) ; MST[NonVoidMethodCallMutator]MSP[] }
} throw new IOException ( lr_9 + lr_10 + normPath + lr_11 ) ; } long parseDir ( final String line , final String path ) throws IOException { int bytesStart = 0 ; int bytesEnd = 0 ; int j = line . length () - 1 ; MST[rv.CRCR6Mutator]MSP[]
final char c = line . charAt ( j ) ; if ( ! Character . isDigit ( c ) && c != ',' && c != '.' ) { MST[rv.UOI1Mutator]MSP[] bytesStart = j + 1 ; break innerLoop2; } j -- ; } if ( j < 0 ) {
line = line . toLowerCase ( Locale . ENGLISH ) . trim () ; MST[experimental.NakedReceiverMutator]MSP[] lines . add ( line ) ; line = inr . readLine () ; } proc . waitFor () ; ThreadMonitor . stop ( monitor ) ;
throw new IOException ( MST[experimental.NakedReceiverMutator]MSP[] lr_17 + DF + lr_24 + lr_10 + path + lr_22 , ex ) ; } } List < String > performCommand ( final String [] cmdAttribs , final int max , final long timeout ) throws IOException {
final String line2 = lines . get ( 1 ) ; StringTokenizer tok = new StringTokenizer ( line2 , lr_20 ) ; if ( tok . countTokens () < 4 ) { MST[rv.CRCR5Mutator]MSP[] if ( tok . countTokens () == 1 && lines . size () >= 3 ) {
long freeSpaceUnix ( final String path , final boolean kb , final boolean posix , final long timeout ) throws IOException { if ( path . isEmpty () ) { MST[NegateConditionalsMutator]MSP[] throw new IllegalArgumentException ( lr_13 ) ; } String flags = lr_14 ; if ( kb ) {
innerLoop1: while ( j >= 0 ) { final char c = line . charAt ( j ) ; if ( Character . isDigit ( c ) ) { bytesEnd = j + 1 ; MST[InlineConstantMutator]MSP[] break innerLoop1; } j -- ; } innerLoop2: while ( j >= 0 ) {
String normPath = FilenameUtils . normalize ( path , false ) ; MST[ArgumentPropagationMutator]MSP[] if ( normPath == null ) { throw new IllegalArgumentException ( path ) ; } if ( normPath . length () > 0 && normPath . charAt ( 0 ) != '"' ) {
innerLoop1: while ( j >= 0 ) { final char c = line . charAt ( j ) ; if ( Character . isDigit ( c ) ) { bytesEnd = j + 1 ; break innerLoop1; } j -- ; } innerLoop2: while ( j >= 0 ) { MST[rv.UOI2Mutator]MSP[]
if ( buf . charAt ( k ) == ',' || buf . charAt ( k ) == '.' ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] buf . deleteCharAt ( k -- ) ; } } return parseBytes ( buf . toString () , path ) ; }
final long bytes = Long . parseLong ( freeSpace ) ; if ( bytes < 0 ) { throw new IOException ( MST[ConstructorCallMutator]MSP[] lr_17 + DF + lr_23 + lr_10 + path + lr_22 ) ; } return bytes ; } catch ( final NumberFormatException ex ) {
line = line . toLowerCase ( Locale . ENGLISH ) . trim () ; lines . add ( line ) ; line = inr . readLine () ; } proc . waitFor () ; ThreadMonitor . stop ( monitor ) ; MST[VoidMethodCallMutator]MSP[]
for ( int i = lines . size () - 1 ; i >= 0 ; i -- ) { MST[rv.AOR1Mutator]MSP[] final String line = lines . get ( i ) ; if ( line . length () > 0 ) { return parseDir ( line , normPath ) ; }
flags += lr_15 ; } if ( posix ) { flags += lr_16 ; } final String [] cmdAttribs = flags . length () > 1 ? new String [] { DF , flags , path } : new String [] { DF , path } ; MST[rv.CRCR4Mutator]MSP[]
final long bytes = Long . parseLong ( freeSpace ) ; if ( bytes < 0 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] throw new IOException ( lr_17 + DF + lr_23 + lr_10 + path + lr_22 ) ; } return bytes ; } catch ( final NumberFormatException ex ) {
flags += lr_15 ; } if ( posix ) { flags += lr_16 ; } final String [] cmdAttribs = flags . length () > 1 ? new String [] { DF , flags , path } : new String [] { DF , path } ; MST[rv.CRCR5Mutator]MSP[]
final String line2 = lines . get ( 1 ) ; StringTokenizer tok = new StringTokenizer ( line2 , lr_20 ) ; if ( tok . countTokens () < 4 ) { MST[rv.ROR1Mutator]MSP[] if ( tok . countTokens () == 1 && lines . size () >= 3 ) {
return freeSpaceKb ( path , - 1 ) ; } @Deprecated public static long freeSpaceKb ( final String path , final long timeout ) throws IOException { return INSTANCE . freeSpaceOS ( path , OS , true , timeout ) ; MST[rv.CRCR5Mutator]MSP[] } @Deprecated
final long bytes = Long . parseLong ( freeSpace ) ; if ( bytes < 0 ) { MST[ConditionalsBoundaryMutator]MSP[] throw new IOException ( lr_17 + DF + lr_23 + lr_10 + path + lr_22 ) ; } return bytes ; } catch ( final NumberFormatException ex ) {
for ( int i = lines . size () - 1 ; i >= 0 ; i -- ) { MST[InlineConstantMutator]MSP[] final String line = lines . get ( i ) ; if ( line . length () > 0 ) { return parseDir ( line , normPath ) ; }
final String line2 = lines . get ( 1 ) ; MST[rv.CRCR6Mutator]MSP[] StringTokenizer tok = new StringTokenizer ( line2 , lr_20 ) ; if ( tok . countTokens () < 4 ) { if ( tok . countTokens () == 1 && lines . size () >= 3 ) {
for ( int i = lines . size () - 1 ; i >= 0 ; i -- ) { MST[rv.CRCR3Mutator]MSP[] final String line = lines . get ( i ) ; if ( line . length () > 0 ) { return parseDir ( line , normPath ) ; }
innerLoop1: while ( j >= 0 ) { MST[rv.UOI2Mutator]MSP[] final char c = line . charAt ( j ) ; if ( Character . isDigit ( c ) ) { bytesEnd = j + 1 ; break innerLoop1; } j -- ; } innerLoop2: while ( j >= 0 ) {
for ( int i = lines . size () - 1 ; i >= 0 ; i -- ) { final String line = lines . get ( i ) ; if ( line . length () > 0 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[] return parseDir ( line , normPath ) ; }
long freeSpaceUnix ( final String path , final boolean kb , final boolean posix , final long timeout ) throws IOException { if ( path . isEmpty () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] throw new IllegalArgumentException ( lr_13 ) ; } String flags = lr_14 ; if ( kb ) {
final Thread monitor = ThreadMonitor . start ( timeout ) ; proc = openProcess ( cmdAttribs ) ; in = proc . getInputStream () ; MST[NonVoidMethodCallMutator]MSP[] out = proc . getOutputStream () ; err = proc . getErrorStream () ;
innerLoop1: while ( j >= 0 ) { MST[NegateConditionalsMutator]MSP[] final char c = line . charAt ( j ) ; if ( Character . isDigit ( c ) ) { bytesEnd = j + 1 ; break innerLoop1; } j -- ; } innerLoop2: while ( j >= 0 ) {
String normPath = FilenameUtils . normalize ( path , false ) ; MST[rv.CRCR5Mutator]MSP[] if ( normPath == null ) { throw new IllegalArgumentException ( path ) ; } if ( normPath . length () > 0 && normPath . charAt ( 0 ) != '"' ) {
return freeSpaceKb ( path , - 1 ) ; } @Deprecated public static long freeSpaceKb ( final String path , final long timeout ) throws IOException { return INSTANCE . freeSpaceOS ( path , OS , true , timeout ) ; MST[rv.UOI3Mutator]MSP[] } @Deprecated
final char c = line . charAt ( j ) ; if ( ! Character . isDigit ( c ) && c != ',' && c != '.' ) { MST[NegateConditionalsMutator]MSP[] bytesStart = j + 1 ; break innerLoop2; } j -- ; } if ( j < 0 ) {
for ( int i = lines . size () - 1 ; i >= 0 ; i -- ) { MST[MathMutator]MSP[] final String line = lines . get ( i ) ; if ( line . length () > 0 ) { return parseDir ( line , normPath ) ; }
if ( buf . charAt ( k ) == ',' || buf . charAt ( k ) == '.' ) { MST[rv.UOI1Mutator]MSP[] buf . deleteCharAt ( k -- ) ; } } return parseBytes ( buf . toString () , path ) ; }
return kb ? freeSpaceWindows ( path , timeout ) / FileUtils . ONE_KB : freeSpaceWindows ( path , timeout ) ; case UNIX : return freeSpaceUnix ( path , kb , false , timeout ) ; MST[rv.ABSMutator]MSP[] case POSIX_UNIX :
normPath = lr_5 + normPath + lr_5 ; } final String [] cmdAttribs = new String [] { lr_6 , lr_7 , lr_8 + normPath } ; MST[rv.CRCR2Mutator]MSP[] final List < String > lines = performCommand ( cmdAttribs , Integer . MAX_VALUE , timeout ) ;
final String line3 = lines . get ( 2 ) ; MST[rv.CRCR5Mutator]MSP[] tok = new StringTokenizer ( line3 , lr_20 ) ; } else { throw new IOException ( lr_17 + DF + lr_21 + lr_10 + path + lr_22 ) ; } } else { tok . nextToken () ;
for ( int i = lines . size () - 1 ; i >= 0 ; i -- ) { final String line = lines . get ( i ) ; if ( line . length () > 0 ) { MST[NegateConditionalsMutator]MSP[] return parseDir ( line , normPath ) ; }
innerLoop1: while ( j >= 0 ) { final char c = line . charAt ( j ) ; if ( Character . isDigit ( c ) ) { bytesEnd = j + 1 ; break innerLoop1; } j -- ; } innerLoop2: while ( j >= 0 ) { MST[NegateConditionalsMutator]MSP[]
throw new IOException ( lr_12 + lr_10 + path + lr_11 ) ; } final StringBuilder buf = new StringBuilder ( line . substring ( bytesStart , bytesEnd ) ) ; MST[rv.UOI1Mutator]MSP[] for ( int k = 0 ; k < buf . length () ; k ++ ) {
final char c = line . charAt ( j ) ; if ( ! Character . isDigit ( c ) && c != ',' && c != '.' ) { bytesStart = j + 1 ; MST[rv.AOR3Mutator]MSP[] break innerLoop2; } j -- ; } if ( j < 0 ) {
flags += lr_15 ; } if ( posix ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] flags += lr_16 ; } final String [] cmdAttribs = flags . length () > 1 ? new String [] { DF , flags , path } : new String [] { DF , path } ;
final Thread monitor = ThreadMonitor . start ( timeout ) ; MST[rv.UOI4Mutator]MSP[] proc = openProcess ( cmdAttribs ) ; in = proc . getInputStream () ; out = proc . getOutputStream () ; err = proc . getErrorStream () ;
return freeSpaceKb ( path , - 1 ) ; } @Deprecated public static long freeSpaceKb ( final String path , final long timeout ) throws IOException { return INSTANCE . freeSpaceOS ( path , OS , true , timeout ) ; MST[ReturnValsMutator]MSP[] } @Deprecated
String normPath = FilenameUtils . normalize ( path , false ) ; if ( normPath == null ) { throw new IllegalArgumentException ( path ) ; } if ( normPath . length () > 0 && normPath . charAt ( 0 ) != '"' ) { MST[rv.CRCR1Mutator]MSP[]
return kb ? freeSpaceWindows ( path , timeout ) / FileUtils . ONE_KB : freeSpaceWindows ( path , timeout ) ; case UNIX : return freeSpaceUnix ( path , kb , false , timeout ) ; MST[rv.UOI4Mutator]MSP[] case POSIX_UNIX :
final char c = line . charAt ( j ) ; if ( ! Character . isDigit ( c ) && c != ',' && c != '.' ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] bytesStart = j + 1 ; break innerLoop2; } j -- ; } if ( j < 0 ) {
final long bytes = Long . parseLong ( freeSpace ) ; if ( bytes < 0 ) { MST[rv.ROR5Mutator]MSP[] throw new IOException ( lr_17 + DF + lr_23 + lr_10 + path + lr_22 ) ; } return bytes ; } catch ( final NumberFormatException ex ) {
lr_28 + Arrays . asList ( cmdAttribs ) ) ; MST[NonVoidMethodCallMutator]MSP[] } inr . close () ; inr = null ; in . close () ; in = null ; if ( out != null ) { out . close () ; out = null ; }
final long bytes = Long . parseLong ( freeSpace ) ; if ( bytes < 0 ) { MST[rv.UOI2Mutator]MSP[] throw new IOException ( lr_17 + DF + lr_23 + lr_10 + path + lr_22 ) ; } return bytes ; } catch ( final NumberFormatException ex ) {
if ( buf . charAt ( k ) == ',' || buf . charAt ( k ) == '.' ) { MST[InlineConstantMutator]MSP[] buf . deleteCharAt ( k -- ) ; } } return parseBytes ( buf . toString () , path ) ; }
final List < String > lines = performCommand ( cmdAttribs , 3 , timeout ) ; if ( lines . size () < 2 ) { MST[rv.ROR3Mutator]MSP[] throw new IOException ( lr_17 + DF + lr_18 + lr_10 + path + lr_19 + lines ) ; }
final char c = line . charAt ( j ) ; if ( ! Character . isDigit ( c ) && c != ',' && c != '.' ) { MST[rv.CRCR2Mutator]MSP[] bytesStart = j + 1 ; break innerLoop2; } j -- ; } if ( j < 0 ) {
final long bytes = Long . parseLong ( freeSpace ) ; if ( bytes < 0 ) { throw new IOException ( MST[experimental.NakedReceiverMutator]MSP[] lr_17 + DF + lr_23 + lr_10 + path + lr_22 ) ; } return bytes ; } catch ( final NumberFormatException ex ) {
return freeSpaceUnix ( path , kb , true , timeout ) ; MST[NonVoidMethodCallMutator]MSP[] case OTHER : throw new IllegalStateException ( lr_3 ) ; default: throw new IllegalStateException ( lr_4 ) ; } } long freeSpaceWindows ( final String path , final long timeout ) throws IOException {
flags += lr_15 ; } if ( posix ) { flags += lr_16 ; } final String [] cmdAttribs = flags . length () > 1 ? new String [] { DF , flags , path } : new String [] { DF , path } ; MST[rv.CRCR5Mutator]MSP[]
return freeSpaceKb ( path , - 1 ) ; MST[InlineConstantMutator]MSP[] } @Deprecated public static long freeSpaceKb ( final String path , final long timeout ) throws IOException { return INSTANCE . freeSpaceOS ( path , OS , true , timeout ) ; } @Deprecated
} throw new IOException ( lr_9 + lr_10 + normPath + lr_11 ) ; } long parseDir ( final String line , final String path ) throws IOException { int bytesStart = 0 ; MST[InlineConstantMutator]MSP[] int bytesEnd = 0 ; int j = line . length () - 1 ;
flags += lr_15 ; } if ( posix ) { MST[rv.UOI1Mutator]MSP[] flags += lr_16 ; } final String [] cmdAttribs = flags . length () > 1 ? new String [] { DF , flags , path } : new String [] { DF , path } ;
flags += lr_15 ; } if ( posix ) { flags += lr_16 ; } final String [] cmdAttribs = flags . length () > 1 ? new String [] { DF , flags , path } : new String [] { DF , path } ; MST[rv.CRCR4Mutator]MSP[]
final char c = line . charAt ( j ) ; if ( ! Character . isDigit ( c ) && c != ',' && c != '.' ) { MST[rv.ROR1Mutator]MSP[] bytesStart = j + 1 ; break innerLoop2; } j -- ; } if ( j < 0 ) {
normPath = lr_5 + normPath + lr_5 ; } final String [] cmdAttribs = new String [] { lr_6 , lr_7 , lr_8 + normPath } ; MST[rv.CRCR1Mutator]MSP[] final List < String > lines = performCommand ( cmdAttribs , Integer . MAX_VALUE , timeout ) ;
final char c = line . charAt ( j ) ; if ( ! Character . isDigit ( c ) && c != ',' && c != '.' ) { MST[NonVoidMethodCallMutator]MSP[] bytesStart = j + 1 ; break innerLoop2; } j -- ; } if ( j < 0 ) {
flags += lr_15 ; } if ( posix ) { flags += lr_16 ; } final String [] cmdAttribs = flags . length () > 1 ? new String [] { DF , flags , path } : new String [] { DF , path } ; MST[rv.ROR4Mutator]MSP[]
final char c = line . charAt ( j ) ; if ( ! Character . isDigit ( c ) && c != ',' && c != '.' ) { MST[rv.CRCR4Mutator]MSP[] bytesStart = j + 1 ; break innerLoop2; } j -- ; } if ( j < 0 ) {
return freeSpaceKb ( path , - 1 ) ; } @Deprecated public static long freeSpaceKb ( final String path , final long timeout ) throws IOException { return INSTANCE . freeSpaceOS ( path , OS , true , timeout ) ; MST[rv.ABSMutator]MSP[] } @Deprecated
for ( int i = lines . size () - 1 ; i >= 0 ; i -- ) { final String line = lines . get ( i ) ; if ( line . length () > 0 ) { MST[ConditionalsBoundaryMutator]MSP[] return parseDir ( line , normPath ) ; }
} throw new IOException ( lr_9 + lr_10 + normPath + lr_11 ) ; } long parseDir ( final String line , final String path ) throws IOException { int bytesStart = 0 ; int bytesEnd = 0 ; MST[rv.CRCR5Mutator]MSP[] int j = line . length () - 1 ;
if ( proc . exitValue () != 0 ) { MST[NegateConditionalsMutator]MSP[] throw new IOException ( lr_25 + proc . exitValue () + lr_26 + Arrays . asList ( cmdAttribs ) ) ; } if ( lines . isEmpty () ) { throw new IOException ( lr_27 +
for ( int i = lines . size () - 1 ; i >= 0 ; i -- ) { MST[rv.ROR1Mutator]MSP[] final String line = lines . get ( i ) ; if ( line . length () > 0 ) { return parseDir ( line , normPath ) ; }
return freeSpaceUnix ( path , kb , true , timeout ) ; MST[rv.CRCR4Mutator]MSP[] case OTHER : throw new IllegalStateException ( lr_3 ) ; default: throw new IllegalStateException ( lr_4 ) ; } } long freeSpaceWindows ( final String path , final long timeout ) throws IOException {
normPath = lr_5 + normPath + lr_5 ; } final String [] cmdAttribs = new String [] { lr_6 , lr_7 , lr_8 + normPath } ; MST[InlineConstantMutator]MSP[] final List < String > lines = performCommand ( cmdAttribs , Integer . MAX_VALUE , timeout ) ;
for ( int i = lines . size () - 1 ; i >= 0 ; i -- ) { final String line = lines . get ( i ) ; if ( line . length () > 0 ) { MST[rv.ROR4Mutator]MSP[] return parseDir ( line , normPath ) ; }
if ( buf . charAt ( k ) == ',' || buf . charAt ( k ) == '.' ) { buf . deleteCharAt ( k -- ) ; MST[experimental.RemoveIncrementsMutator]MSP[] } } return parseBytes ( buf . toString () , path ) ; }
throw new IOException ( MST[ConstructorCallMutator]MSP[] lr_12 + lr_10 + path + lr_11 ) ; } final StringBuilder buf = new StringBuilder ( line . substring ( bytesStart , bytesEnd ) ) ; for ( int k = 0 ; k < buf . length () ; k ++ ) {
if ( buf . charAt ( k ) == ',' || buf . charAt ( k ) == '.' ) { MST[rv.ROR5Mutator]MSP[] buf . deleteCharAt ( k -- ) ; } } return parseBytes ( buf . toString () , path ) ; }
normPath = lr_5 + normPath + lr_5 ; } final String [] cmdAttribs = new String [] { lr_6 , lr_7 , lr_8 + normPath } ; MST[rv.CRCR5Mutator]MSP[] final List < String > lines = performCommand ( cmdAttribs , Integer . MAX_VALUE , timeout ) ;
for ( int i = lines . size () - 1 ; i >= 0 ; i -- ) { MST[rv.ROR5Mutator]MSP[] final String line = lines . get ( i ) ; if ( line . length () > 0 ) { return parseDir ( line , normPath ) ; }
final char c = line . charAt ( j ) ; if ( ! Character . isDigit ( c ) && c != ',' && c != '.' ) { MST[rv.UOI2Mutator]MSP[] bytesStart = j + 1 ; break innerLoop2; } j -- ; } if ( j < 0 ) {
final String line2 = lines . get ( 1 ) ; StringTokenizer tok = new StringTokenizer ( line2 , lr_20 ) ; if ( tok . countTokens () < 4 ) { if ( tok . countTokens () == 1 && lines . size () >= 3 ) { MST[rv.CRCR2Mutator]MSP[]
if ( err != null ) { MST[NegateConditionalsMutator]MSP[] err . close () ; err = null ; } return lines ; } catch ( final InterruptedException ex ) { throw new IOException ( lr_29 + lr_28 + Arrays . asList ( cmdAttribs ) + lr_30 + timeout , ex ) ;
normPath = lr_5 + normPath + lr_5 ; } final String [] cmdAttribs = new String [] { lr_6 , lr_7 , lr_8 + normPath } ; MST[rv.CRCR3Mutator]MSP[] final List < String > lines = performCommand ( cmdAttribs , Integer . MAX_VALUE , timeout ) ;
for ( int i = lines . size () - 1 ; i >= 0 ; i -- ) { MST[NonVoidMethodCallMutator]MSP[] final String line = lines . get ( i ) ; if ( line . length () > 0 ) { return parseDir ( line , normPath ) ; }
innerLoop1: while ( j >= 0 ) { final char c = line . charAt ( j ) ; if ( Character . isDigit ( c ) ) { MST[NonVoidMethodCallMutator]MSP[] bytesEnd = j + 1 ; break innerLoop1; } j -- ; } innerLoop2: while ( j >= 0 ) {
if ( buf . charAt ( k ) == ',' || buf . charAt ( k ) == '.' ) { buf . deleteCharAt ( k -- ) ; } } return parseBytes ( buf . toString () , path ) ; MST[NonVoidMethodCallMutator]MSP[] }
String normPath = FilenameUtils . normalize ( path , false ) ; if ( normPath == null ) { throw new IllegalArgumentException ( path ) ; } if ( normPath . length () > 0 && normPath . charAt ( 0 ) != '"' ) { MST[rv.CRCR6Mutator]MSP[]
String normPath = FilenameUtils . normalize ( path , false ) ; if ( normPath == null ) { throw new IllegalArgumentException ( path ) ; } if ( normPath . length () > 0 && normPath . charAt ( 0 ) != '"' ) { MST[rv.CRCR2Mutator]MSP[]
if ( buf . charAt ( k ) == ',' || buf . charAt ( k ) == '.' ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] buf . deleteCharAt ( k -- ) ; } } return parseBytes ( buf . toString () , path ) ; }
flags += lr_15 ; } if ( posix ) { flags += lr_16 ; } final String [] cmdAttribs = flags . length () > 1 ? new String [] { DF , flags , path } : new String [] { DF , path } ; MST[rv.CRCR2Mutator]MSP[]
long freeSpaceUnix ( final String path , final boolean kb , final boolean posix , final long timeout ) throws IOException { if ( path . isEmpty () ) { throw new IllegalArgumentException ( lr_13 ) ; } String flags = lr_14 ; if ( kb ) { MST[rv.UOI2Mutator]MSP[]
} throw new IOException ( lr_9 + lr_10 + normPath + lr_11 ) ; } long parseDir ( final String line , final String path ) throws IOException { int bytesStart = 0 ; int bytesEnd = 0 ; int j = line . length () - 1 ; MST[rv.AOR3Mutator]MSP[]
if ( buf . charAt ( k ) == ',' || buf . charAt ( k ) == '.' ) { MST[rv.CRCR1Mutator]MSP[] buf . deleteCharAt ( k -- ) ; } } return parseBytes ( buf . toString () , path ) ; }
throw new IOException ( lr_12 + lr_10 + path + lr_11 ) ; } final StringBuilder buf = new StringBuilder ( line . substring ( bytesStart , bytesEnd ) ) ; MST[rv.UOI3Mutator]MSP[] for ( int k = 0 ; k < buf . length () ; k ++ ) {
innerLoop1: while ( j >= 0 ) { MST[rv.ROR1Mutator]MSP[] final char c = line . charAt ( j ) ; if ( Character . isDigit ( c ) ) { bytesEnd = j + 1 ; break innerLoop1; } j -- ; } innerLoop2: while ( j >= 0 ) {
long freeSpaceOS ( final String path , final int os , final boolean kb , final long timeout ) throws IOException { if ( path == null ) { throw new IllegalArgumentException ( lr_2 ) ; } switch ( os ) { MST[rv.UOI2Mutator]MSP[] case WINDOWS :
for ( int i = lines . size () - 1 ; i >= 0 ; i -- ) { final String line = lines . get ( i ) ; if ( line . length () > 0 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] return parseDir ( line , normPath ) ; }
innerLoop1: while ( j >= 0 ) { final char c = line . charAt ( j ) ; if ( Character . isDigit ( c ) ) { MST[rv.UOI2Mutator]MSP[] bytesEnd = j + 1 ; break innerLoop1; } j -- ; } innerLoop2: while ( j >= 0 ) {
flags += lr_15 ; } if ( posix ) { MST[rv.ROR3Mutator]MSP[] flags += lr_16 ; } final String [] cmdAttribs = flags . length () > 1 ? new String [] { DF , flags , path } : new String [] { DF , path } ;
return freeSpaceKb ( path , - 1 ) ; MST[rv.CRCR6Mutator]MSP[] } @Deprecated public static long freeSpaceKb ( final String path , final long timeout ) throws IOException { return INSTANCE . freeSpaceOS ( path , OS , true , timeout ) ; } @Deprecated
throw new IOException ( lr_12 + lr_10 + path + lr_11 ) ; } final StringBuilder buf = new StringBuilder ( line . substring ( bytesStart , bytesEnd ) ) ; for ( int k = 0 ; k < buf . length () ; k ++ ) { MST[rv.CRCR5Mutator]MSP[]
long freeSpaceUnix ( final String path , final boolean kb , final boolean posix , final long timeout ) throws IOException { if ( path . isEmpty () ) { throw new IllegalArgumentException ( lr_13 ) ; } String flags = lr_14 ; if ( kb ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
return kb ? freeSpaceWindows ( path , timeout ) / FileUtils . ONE_KB : freeSpaceWindows ( path , timeout ) ; MST[rv.AOR2Mutator]MSP[] case UNIX : return freeSpaceUnix ( path , kb , false , timeout ) ; case POSIX_UNIX :
final String line2 = lines . get ( 1 ) ; StringTokenizer tok = new StringTokenizer ( line2 , lr_20 ) ; if ( tok . countTokens () < 4 ) { if ( tok . countTokens () == 1 && lines . size () >= 3 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
normPath = lr_5 + normPath + lr_5 ; } final String [] cmdAttribs = new String [] { lr_6 , lr_7 , lr_8 + normPath } ; final List < String > lines = performCommand ( cmdAttribs , Integer . MAX_VALUE , timeout ) ; MST[rv.CRCR5Mutator]MSP[]
return freeSpaceKb ( path , - 1 ) ; } @Deprecated public static long freeSpaceKb ( final String path , final long timeout ) throws IOException { return INSTANCE . freeSpaceOS ( path , OS , true , timeout ) ; MST[rv.UOI1Mutator]MSP[] } @Deprecated
normPath = lr_5 + normPath + lr_5 ; } final String [] cmdAttribs = new String [] { lr_6 , lr_7 , lr_8 + normPath } ; MST[NonVoidMethodCallMutator]MSP[] final List < String > lines = performCommand ( cmdAttribs , Integer . MAX_VALUE , timeout ) ;
normPath = lr_5 + normPath + lr_5 ; } final String [] cmdAttribs = new String [] { lr_6 , lr_7 , lr_8 + normPath } ; final List < String > lines = performCommand ( cmdAttribs , Integer . MAX_VALUE , timeout ) ; MST[rv.UOI1Mutator]MSP[]
final char c = line . charAt ( j ) ; if ( ! Character . isDigit ( c ) && c != ',' && c != '.' ) { bytesStart = j + 1 ; MST[rv.CRCR5Mutator]MSP[] break innerLoop2; } j -- ; } if ( j < 0 ) {
flags += lr_15 ; } if ( posix ) { flags += lr_16 ; } final String [] cmdAttribs = flags . length () > 1 ? new String [] { DF , flags , path } : new String [] { DF , path } ; MST[RemoveConditionalMutator_ORDER_IF]MSP[]
throw new IOException ( lr_12 + lr_10 + path + lr_11 ) ; } final StringBuilder buf = new StringBuilder ( line . substring ( bytesStart , bytesEnd ) ) ; for ( int k = 0 ; k < buf . length () ; k ++ ) { MST[rv.ABSMutator]MSP[]
final String line3 = lines . get ( 2 ) ; tok = new StringTokenizer ( line3 , lr_20 ) ; } else { throw new IOException ( MST[NonVoidMethodCallMutator]MSP[] lr_17 + DF + lr_21 + lr_10 + path + lr_22 ) ; } } else { tok . nextToken () ;
final String line2 = lines . get ( 1 ) ; StringTokenizer tok = new StringTokenizer ( line2 , lr_20 ) ; if ( tok . countTokens () < 4 ) { if ( tok . countTokens () == 1 && lines . size () >= 3 ) { MST[InlineConstantMutator]MSP[]
return kb ? freeSpaceWindows ( path , timeout ) / FileUtils . ONE_KB : freeSpaceWindows ( path , timeout ) ; MST[ArgumentPropagationMutator]MSP[] case UNIX : return freeSpaceUnix ( path , kb , false , timeout ) ; case POSIX_UNIX :
final List < String > lines = performCommand ( cmdAttribs , 3 , timeout ) ; MST[rv.CRCR4Mutator]MSP[] if ( lines . size () < 2 ) { throw new IOException ( lr_17 + DF + lr_18 + lr_10 + path + lr_19 + lines ) ; }
long freeSpaceUnix ( final String path , final boolean kb , final boolean posix , final long timeout ) throws IOException { if ( path . isEmpty () ) { MST[rv.ROR3Mutator]MSP[] throw new IllegalArgumentException ( lr_13 ) ; } String flags = lr_14 ; if ( kb ) {
flags += lr_15 ; } if ( posix ) { flags += lr_16 ; } final String [] cmdAttribs = flags . length () > 1 ? new String [] { DF , flags , path } : new String [] { DF , path } ; MST[NonVoidMethodCallMutator]MSP[]
throw new IOException ( lr_12 + lr_10 + path + lr_11 ) ; } final StringBuilder buf = new StringBuilder ( line . substring ( bytesStart , bytesEnd ) ) ; for ( int k = 0 ; k < buf . length () ; k ++ ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[]
final String line2 = lines . get ( 1 ) ; StringTokenizer tok = new StringTokenizer ( line2 , lr_20 ) ; if ( tok . countTokens () < 4 ) { if ( tok . countTokens () == 1 && lines . size () >= 3 ) { MST[ConditionalsBoundaryMutator]MSP[]
return kb ? freeSpaceWindows ( path , timeout ) / FileUtils . ONE_KB : freeSpaceWindows ( path , timeout ) ; case UNIX : return freeSpaceUnix ( path , kb , false , timeout ) ; MST[rv.UOI2Mutator]MSP[] case POSIX_UNIX :
final String line2 = lines . get ( 1 ) ; StringTokenizer tok = new StringTokenizer ( line2 , lr_20 ) ; if ( tok . countTokens () < 4 ) { if ( tok . countTokens () == 1 && lines . size () >= 3 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[]
return freeSpaceUnix ( path , kb , true , timeout ) ; MST[rv.UOI4Mutator]MSP[] case OTHER : throw new IllegalStateException ( lr_3 ) ; default: throw new IllegalStateException ( lr_4 ) ; } } long freeSpaceWindows ( final String path , final long timeout ) throws IOException {
return kb ? freeSpaceWindows ( path , timeout ) / FileUtils . ONE_KB : freeSpaceWindows ( path , timeout ) ; MST[rv.CRCR1Mutator]MSP[] case UNIX : return freeSpaceUnix ( path , kb , false , timeout ) ; case POSIX_UNIX :
flags += lr_15 ; } if ( posix ) { flags += lr_16 ; } final String [] cmdAttribs = flags . length () > 1 ? new String [] { DF , flags , path } : new String [] { DF , path } ; MST[InlineConstantMutator]MSP[]
flags += lr_15 ; } if ( posix ) { flags += lr_16 ; } final String [] cmdAttribs = flags . length () > 1 ? new String [] { DF , flags , path } : new String [] { DF , path } ; MST[ConditionalsBoundaryMutator]MSP[]
final String line2 = lines . get ( 1 ) ; StringTokenizer tok = new StringTokenizer ( line2 , lr_20 ) ; if ( tok . countTokens () < 4 ) { if ( tok . countTokens () == 1 && lines . size () >= 3 ) { MST[rv.ROR4Mutator]MSP[]
String normPath = FilenameUtils . normalize ( path , false ) ; if ( normPath == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] throw new IllegalArgumentException ( path ) ; } if ( normPath . length () > 0 && normPath . charAt ( 0 ) != '"' ) {
if ( buf . charAt ( k ) == ',' || buf . charAt ( k ) == '.' ) { buf . deleteCharAt ( k -- ) ; MST[rv.UOI2Mutator]MSP[] } } return parseBytes ( buf . toString () , path ) ; }
final String line3 = lines . get ( 2 ) ; tok = new StringTokenizer ( line3 , lr_20 ) ; MST[ConstructorCallMutator]MSP[] } else { throw new IOException ( lr_17 + DF + lr_21 + lr_10 + path + lr_22 ) ; } } else { tok . nextToken () ;
return kb ? freeSpaceWindows ( path , timeout ) / FileUtils . ONE_KB : freeSpaceWindows ( path , timeout ) ; MST[rv.UOI3Mutator]MSP[] case UNIX : return freeSpaceUnix ( path , kb , false , timeout ) ; case POSIX_UNIX :
final char c = line . charAt ( j ) ; if ( ! Character . isDigit ( c ) && c != ',' && c != '.' ) { MST[NegateConditionalsMutator]MSP[] bytesStart = j + 1 ; break innerLoop2; } j -- ; } if ( j < 0 ) {
final String line2 = lines . get ( 1 ) ; StringTokenizer tok = new StringTokenizer ( line2 , lr_20 ) ; if ( tok . countTokens () < 4 ) { MST[rv.CRCR1Mutator]MSP[] if ( tok . countTokens () == 1 && lines . size () >= 3 ) {
final long bytes = Long . parseLong ( freeSpace ) ; if ( bytes < 0 ) { throw new IOException ( lr_17 + DF + lr_23 + lr_10 + path + lr_22 ) ; } return bytes ; MST[rv.UOI2Mutator]MSP[] } catch ( final NumberFormatException ex ) {
} finally { IOUtils . closeQuietly ( in ) ; IOUtils . closeQuietly ( out ) ; IOUtils . closeQuietly ( err ) ; IOUtils . closeQuietly ( inr ) ; MST[VoidMethodCallMutator]MSP[] if ( proc != null ) { proc . destroy () ; } } }
} throw new IOException ( lr_9 + lr_10 + normPath + lr_11 ) ; } long parseDir ( final String line , final String path ) throws IOException { int bytesStart = 0 ; int bytesEnd = 0 ; int j = line . length () - 1 ; MST[rv.AOD1Mutator]MSP[]
final char c = line . charAt ( j ) ; if ( ! Character . isDigit ( c ) && c != ',' && c != '.' ) { MST[rv.ROR4Mutator]MSP[] bytesStart = j + 1 ; break innerLoop2; } j -- ; } if ( j < 0 ) {
final List < String > lines = new ArrayList <> ( 20 ) ; MST[rv.CRCR6Mutator]MSP[] Process proc = null ; InputStream in = null ; OutputStream out = null ; InputStream err = null ; BufferedReader inr = null ; try {
final String line2 = lines . get ( 1 ) ; MST[rv.CRCR4Mutator]MSP[] StringTokenizer tok = new StringTokenizer ( line2 , lr_20 ) ; if ( tok . countTokens () < 4 ) { if ( tok . countTokens () == 1 && lines . size () >= 3 ) {
for ( int i = lines . size () - 1 ; i >= 0 ; i -- ) { MST[rv.AOD2Mutator]MSP[] final String line = lines . get ( i ) ; if ( line . length () > 0 ) { return parseDir ( line , normPath ) ; }
} throw new IOException ( lr_9 + lr_10 + normPath + lr_11 ) ; } long parseDir ( final String line , final String path ) throws IOException { int bytesStart = 0 ; int bytesEnd = 0 ; int j = line . length () - 1 ; MST[rv.CRCR2Mutator]MSP[]
final long bytes = Long . parseLong ( freeSpace ) ; if ( bytes < 0 ) { MST[rv.CRCR5Mutator]MSP[] throw new IOException ( lr_17 + DF + lr_23 + lr_10 + path + lr_22 ) ; } return bytes ; } catch ( final NumberFormatException ex ) {
inr = new BufferedReader ( new InputStreamReader ( in , Charset . defaultCharset () ) ) ; String line = inr . readLine () ; while ( line != null && lines . size () < max ) { MST[NegateConditionalsMutator]MSP[]
final String line2 = lines . get ( 1 ) ; StringTokenizer tok = new StringTokenizer ( line2 , lr_20 ) ; if ( tok . countTokens () < 4 ) { MST[rv.ROR5Mutator]MSP[] if ( tok . countTokens () == 1 && lines . size () >= 3 ) {
final long bytes = Long . parseLong ( freeSpace ) ; MST[NonVoidMethodCallMutator]MSP[] if ( bytes < 0 ) { throw new IOException ( lr_17 + DF + lr_23 + lr_10 + path + lr_22 ) ; } return bytes ; } catch ( final NumberFormatException ex ) {
normPath = lr_5 + normPath + lr_5 ; } final String [] cmdAttribs = new String [] { lr_6 , lr_7 , lr_8 + normPath } ; final List < String > lines = performCommand ( cmdAttribs , Integer . MAX_VALUE , timeout ) ; MST[rv.CRCR1Mutator]MSP[]
@Deprecated public static long freeSpace ( final String path ) throws IOException { return INSTANCE . freeSpaceOS ( path , OS , false , - 1 ) ; MST[rv.ABSMutator]MSP[] } @Deprecated public static long freeSpaceKb ( final String path ) throws IOException {
innerLoop1: while ( j >= 0 ) { final char c = line . charAt ( j ) ; if ( Character . isDigit ( c ) ) { MST[rv.ROR4Mutator]MSP[] bytesEnd = j + 1 ; break innerLoop1; } j -- ; } innerLoop2: while ( j >= 0 ) {
innerLoop1: while ( j >= 0 ) { final char c = line . charAt ( j ) ; if ( Character . isDigit ( c ) ) { bytesEnd = j + 1 ; MST[rv.UOI3Mutator]MSP[] break innerLoop1; } j -- ; } innerLoop2: while ( j >= 0 ) {
final String line2 = lines . get ( 1 ) ; StringTokenizer tok = new StringTokenizer ( line2 , lr_20 ) ; if ( tok . countTokens () < 4 ) { if ( tok . countTokens () == 1 && lines . size () >= 3 ) { MST[NonVoidMethodCallMutator]MSP[]
for ( int i = lines . size () - 1 ; i >= 0 ; i -- ) { MST[NegateConditionalsMutator]MSP[] final String line = lines . get ( i ) ; if ( line . length () > 0 ) { return parseDir ( line , normPath ) ; }
final String line3 = lines . get ( 2 ) ; MST[rv.CRCR1Mutator]MSP[] tok = new StringTokenizer ( line3 , lr_20 ) ; } else { throw new IOException ( lr_17 + DF + lr_21 + lr_10 + path + lr_22 ) ; } } else { tok . nextToken () ;
innerLoop1: while ( j >= 0 ) { MST[rv.UOI3Mutator]MSP[] final char c = line . charAt ( j ) ; if ( Character . isDigit ( c ) ) { bytesEnd = j + 1 ; break innerLoop1; } j -- ; } innerLoop2: while ( j >= 0 ) {
final List < String > lines = performCommand ( cmdAttribs , 3 , timeout ) ; if ( lines . size () < 2 ) { MST[rv.CRCR6Mutator]MSP[] throw new IOException ( lr_17 + DF + lr_18 + lr_10 + path + lr_19 + lines ) ; }
if ( proc . exitValue () != 0 ) { MST[rv.ROR5Mutator]MSP[] throw new IOException ( lr_25 + proc . exitValue () + lr_26 + Arrays . asList ( cmdAttribs ) ) ; } if ( lines . isEmpty () ) { throw new IOException ( lr_27 +
@Deprecated public static long freeSpace ( final String path ) throws IOException { return INSTANCE . freeSpaceOS ( path , OS , false , - 1 ) ; MST[rv.CRCR3Mutator]MSP[] } @Deprecated public static long freeSpaceKb ( final String path ) throws IOException {
final char c = line . charAt ( j ) ; if ( ! Character . isDigit ( c ) && c != ',' && c != '.' ) { MST[rv.CRCR3Mutator]MSP[] bytesStart = j + 1 ; break innerLoop2; } j -- ; } if ( j < 0 ) {
normPath = lr_5 + normPath + lr_5 ; } final String [] cmdAttribs = new String [] { lr_6 , lr_7 , lr_8 + normPath } ; MST[NonVoidMethodCallMutator]MSP[] final List < String > lines = performCommand ( cmdAttribs , Integer . MAX_VALUE , timeout ) ;
if ( buf . charAt ( k ) == ',' || buf . charAt ( k ) == '.' ) { MST[rv.CRCR6Mutator]MSP[] buf . deleteCharAt ( k -- ) ; } } return parseBytes ( buf . toString () , path ) ; }
inr = new BufferedReader ( new InputStreamReader ( in , Charset . defaultCharset () ) ) ; MST[ConstructorCallMutator]MSP[] String line = inr . readLine () ; while ( line != null && lines . size () < max ) {
if ( err != null ) { MST[rv.ROR5Mutator]MSP[] err . close () ; err = null ; } return lines ; } catch ( final InterruptedException ex ) { throw new IOException ( lr_29 + lr_28 + Arrays . asList ( cmdAttribs ) + lr_30 + timeout , ex ) ;
Process openProcess ( final String [] cmdAttribs ) throws IOException { return Runtime . getRuntime () . exec ( cmdAttribs ) ; MST[ReturnValsMutator]MSP[] }
flags += lr_15 ; } if ( posix ) { flags += lr_16 ; } final String [] cmdAttribs = flags . length () > 1 ? new String [] { DF , flags , path } : new String [] { DF , path } ; MST[rv.CRCR1Mutator]MSP[]
flags += lr_15 ; } if ( posix ) { flags += lr_16 ; } final String [] cmdAttribs = flags . length () > 1 ? new String [] { DF , flags , path } : new String [] { DF , path } ; MST[rv.CRCR5Mutator]MSP[]
@Deprecated public static long freeSpace ( final String path ) throws IOException { return INSTANCE . freeSpaceOS ( path , OS , false , - 1 ) ; MST[InlineConstantMutator]MSP[] } @Deprecated public static long freeSpaceKb ( final String path ) throws IOException {
String normPath = FilenameUtils . normalize ( path , false ) ; if ( normPath == null ) { throw new IllegalArgumentException ( path ) ; } if ( normPath . length () > 0 && normPath . charAt ( 0 ) != '"' ) { MST[rv.ROR5Mutator]MSP[]
final String line3 = lines . get ( 2 ) ; tok = new StringTokenizer ( line3 , lr_20 ) ; } else { throw new IOException ( MST[NonVoidMethodCallMutator]MSP[] lr_17 + DF + lr_21 + lr_10 + path + lr_22 ) ; } } else { tok . nextToken () ;
for ( int i = lines . size () - 1 ; i >= 0 ; i -- ) { final String line = lines . get ( i ) ; MST[rv.ABSMutator]MSP[] if ( line . length () > 0 ) { return parseDir ( line , normPath ) ; }
public static long freeSpaceKb () throws IOException { return freeSpaceKb ( - 1 ) ; MST[ArgumentPropagationMutator]MSP[] } @Deprecated public static long freeSpaceKb ( final long timeout ) throws IOException { return freeSpaceKb ( new File ( lr_1 ) . getAbsolutePath () , timeout ) ; }
flags += lr_15 ; } if ( posix ) { flags += lr_16 ; } final String [] cmdAttribs = flags . length () > 1 ? new String [] { DF , flags , path } : new String [] { DF , path } ; MST[rv.CRCR1Mutator]MSP[]
final long bytes = Long . parseLong ( freeSpace ) ; if ( bytes < 0 ) { MST[rv.ROR1Mutator]MSP[] throw new IOException ( lr_17 + DF + lr_23 + lr_10 + path + lr_22 ) ; } return bytes ; } catch ( final NumberFormatException ex ) {
innerLoop1: while ( j >= 0 ) { final char c = line . charAt ( j ) ; if ( Character . isDigit ( c ) ) { bytesEnd = j + 1 ; break innerLoop1; } j -- ; } innerLoop2: while ( j >= 0 ) { MST[rv.UOI3Mutator]MSP[]
} finally { IOUtils . closeQuietly ( in ) ; IOUtils . closeQuietly ( out ) ; IOUtils . closeQuietly ( err ) ; IOUtils . closeQuietly ( inr ) ; if ( proc != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] proc . destroy () ; } } }
throw new IOException ( lr_12 + lr_10 + path + lr_11 ) ; } final StringBuilder buf = new StringBuilder ( line . substring ( bytesStart , bytesEnd ) ) ; MST[ConstructorCallMutator]MSP[] for ( int k = 0 ; k < buf . length () ; k ++ ) {
flags += lr_15 ; } if ( posix ) { flags += lr_16 ; } final String [] cmdAttribs = flags . length () > 1 ? new String [] { DF , flags , path } : new String [] { DF , path } ; MST[rv.CRCR5Mutator]MSP[]
return kb ? freeSpaceWindows ( path , timeout ) / FileUtils . ONE_KB : freeSpaceWindows ( path , timeout ) ; case UNIX : return freeSpaceUnix ( path , kb , false , timeout ) ; MST[rv.UOI2Mutator]MSP[] case POSIX_UNIX :
long freeSpaceUnix ( final String path , final boolean kb , final boolean posix , final long timeout ) throws IOException { if ( path . isEmpty () ) { MST[NonVoidMethodCallMutator]MSP[] throw new IllegalArgumentException ( lr_13 ) ; } String flags = lr_14 ; if ( kb ) {
return freeSpaceKb ( path , - 1 ) ; } @Deprecated public static long freeSpaceKb ( final String path , final long timeout ) throws IOException { return INSTANCE . freeSpaceOS ( path , OS , true , timeout ) ; MST[PrimitiveReturnsMutator]MSP[] } @Deprecated
final List < String > lines = new ArrayList <> ( 20 ) ; MST[rv.CRCR1Mutator]MSP[] Process proc = null ; InputStream in = null ; OutputStream out = null ; InputStream err = null ; BufferedReader inr = null ; try {
inr = new BufferedReader ( new InputStreamReader ( in , Charset . defaultCharset () ) ) ; String line = inr . readLine () ; while ( line != null && lines . size () < max ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[]
if ( proc . exitValue () != 0 ) { throw new IOException ( lr_25 + proc . exitValue () + lr_26 + Arrays . asList ( cmdAttribs ) ) ; } if ( lines . isEmpty () ) { MST[NegateConditionalsMutator]MSP[] throw new IOException ( lr_27 +
if ( proc . exitValue () != 0 ) { throw new IOException ( MST[experimental.NakedReceiverMutator]MSP[] lr_25 + proc . exitValue () + lr_26 + Arrays . asList ( cmdAttribs ) ) ; } if ( lines . isEmpty () ) { throw new IOException ( lr_27 +
return freeSpaceKb ( path , - 1 ) ; } @Deprecated public static long freeSpaceKb ( final String path , final long timeout ) throws IOException { return INSTANCE . freeSpaceOS ( path , OS , true , timeout ) ; MST[rv.CRCR6Mutator]MSP[] } @Deprecated
flags += lr_15 ; } if ( posix ) { flags += lr_16 ; } final String [] cmdAttribs = flags . length () > 1 ? new String [] { DF , flags , path } : new String [] { DF , path } ; MST[rv.CRCR2Mutator]MSP[]
} tok . nextToken () ; tok . nextToken () ; final String freeSpace = tok . nextToken () ; MST[NonVoidMethodCallMutator]MSP[] return parseBytes ( freeSpace , path ) ; } long parseBytes ( final String freeSpace , final String path ) throws IOException { try {
final char c = line . charAt ( j ) ; if ( ! Character . isDigit ( c ) && c != ',' && c != '.' ) { bytesStart = j + 1 ; break innerLoop2; } j -- ; } if ( j < 0 ) { MST[rv.UOI2Mutator]MSP[]
final Thread monitor = ThreadMonitor . start ( timeout ) ; proc = openProcess ( cmdAttribs ) ; MST[NonVoidMethodCallMutator]MSP[] in = proc . getInputStream () ; out = proc . getOutputStream () ; err = proc . getErrorStream () ;
String normPath = FilenameUtils . normalize ( path , false ) ; if ( normPath == null ) { throw new IllegalArgumentException ( path ) ; } if ( normPath . length () > 0 && normPath . charAt ( 0 ) != '"' ) { MST[NegateConditionalsMutator]MSP[]
} throw new IOException ( lr_9 + lr_10 + normPath + lr_11 ) ; } long parseDir ( final String line , final String path ) throws IOException { int bytesStart = 0 ; MST[rv.CRCR5Mutator]MSP[] int bytesEnd = 0 ; int j = line . length () - 1 ;
if ( buf . charAt ( k ) == ',' || buf . charAt ( k ) == '.' ) { MST[rv.ROR2Mutator]MSP[] buf . deleteCharAt ( k -- ) ; } } return parseBytes ( buf . toString () , path ) ; }
@Deprecated public static long freeSpace ( final String path ) throws IOException { return INSTANCE . freeSpaceOS ( path , OS , false , - 1 ) ; MST[rv.CRCR4Mutator]MSP[] } @Deprecated public static long freeSpaceKb ( final String path ) throws IOException {
} throw new IOException ( MST[NonVoidMethodCallMutator]MSP[] lr_9 + lr_10 + normPath + lr_11 ) ; } long parseDir ( final String line , final String path ) throws IOException { int bytesStart = 0 ; int bytesEnd = 0 ; int j = line . length () - 1 ;
if ( buf . charAt ( k ) == ',' || buf . charAt ( k ) == '.' ) { MST[rv.CRCR5Mutator]MSP[] buf . deleteCharAt ( k -- ) ; } } return parseBytes ( buf . toString () , path ) ; }
final String line2 = lines . get ( 1 ) ; StringTokenizer tok = new StringTokenizer ( line2 , lr_20 ) ; if ( tok . countTokens () < 4 ) { if ( tok . countTokens () == 1 && lines . size () >= 3 ) { MST[rv.CRCR5Mutator]MSP[]
normPath = lr_5 + normPath + lr_5 ; } final String [] cmdAttribs = new String [] { lr_6 , lr_7 , lr_8 + normPath } ; MST[rv.CRCR6Mutator]MSP[] final List < String > lines = performCommand ( cmdAttribs , Integer . MAX_VALUE , timeout ) ;
final String line2 = lines . get ( 1 ) ; StringTokenizer tok = new StringTokenizer ( line2 , lr_20 ) ; if ( tok . countTokens () < 4 ) { MST[NegateConditionalsMutator]MSP[] if ( tok . countTokens () == 1 && lines . size () >= 3 ) {
normPath = lr_5 + normPath + lr_5 ; } final String [] cmdAttribs = new String [] { lr_6 , lr_7 , lr_8 + normPath } ; MST[rv.CRCR3Mutator]MSP[] final List < String > lines = performCommand ( cmdAttribs , Integer . MAX_VALUE , timeout ) ;
final char c = line . charAt ( j ) ; if ( ! Character . isDigit ( c ) && c != ',' && c != '.' ) { MST[rv.ABSMutator]MSP[] bytesStart = j + 1 ; break innerLoop2; } j -- ; } if ( j < 0 ) {
final String line2 = lines . get ( 1 ) ; StringTokenizer tok = new StringTokenizer ( line2 , lr_20 ) ; if ( tok . countTokens () < 4 ) { if ( tok . countTokens () == 1 && lines . size () >= 3 ) { MST[rv.CRCR2Mutator]MSP[]
} finally { IOUtils . closeQuietly ( in ) ; IOUtils . closeQuietly ( out ) ; IOUtils . closeQuietly ( err ) ; MST[VoidMethodCallMutator]MSP[] IOUtils . closeQuietly ( inr ) ; if ( proc != null ) { proc . destroy () ; } } }
innerLoop1: while ( j >= 0 ) { final char c = line . charAt ( j ) ; if ( Character . isDigit ( c ) ) { bytesEnd = j + 1 ; MST[rv.CRCR5Mutator]MSP[] break innerLoop1; } j -- ; } innerLoop2: while ( j >= 0 ) {
if ( proc . exitValue () != 0 ) { throw new IOException ( lr_25 + proc . exitValue () + lr_26 + Arrays . asList ( cmdAttribs ) ) ; } if ( lines . isEmpty () ) { MST[rv.ROR3Mutator]MSP[] throw new IOException ( lr_27 +
throw new IOException ( lr_12 + lr_10 + path + lr_11 ) ; } final StringBuilder buf = new StringBuilder ( line . substring ( bytesStart , bytesEnd ) ) ; MST[rv.UOI4Mutator]MSP[] for ( int k = 0 ; k < buf . length () ; k ++ ) {
flags += lr_15 ; } if ( posix ) { flags += lr_16 ; } final String [] cmdAttribs = flags . length () > 1 ? new String [] { DF , flags , path } : new String [] { DF , path } ; MST[InlineConstantMutator]MSP[]
throw new IOException ( lr_12 + lr_10 + path + lr_11 ) ; } final StringBuilder buf = new StringBuilder ( line . substring ( bytesStart , bytesEnd ) ) ; MST[rv.ABSMutator]MSP[] for ( int k = 0 ; k < buf . length () ; k ++ ) {
if ( buf . charAt ( k ) == ',' || buf . charAt ( k ) == '.' ) { MST[InlineConstantMutator]MSP[] buf . deleteCharAt ( k -- ) ; } } return parseBytes ( buf . toString () , path ) ; }
innerLoop1: while ( j >= 0 ) { final char c = line . charAt ( j ) ; if ( Character . isDigit ( c ) ) { bytesEnd = j + 1 ; MST[rv.AOD2Mutator]MSP[] break innerLoop1; } j -- ; } innerLoop2: while ( j >= 0 ) {
public static long freeSpaceKb () throws IOException { return freeSpaceKb ( - 1 ) ; MST[rv.CRCR4Mutator]MSP[] } @Deprecated public static long freeSpaceKb ( final long timeout ) throws IOException { return freeSpaceKb ( new File ( lr_1 ) . getAbsolutePath () , timeout ) ; }
public static long freeSpaceKb () throws IOException { return freeSpaceKb ( - 1 ) ; MST[rv.CRCR2Mutator]MSP[] } @Deprecated public static long freeSpaceKb ( final long timeout ) throws IOException { return freeSpaceKb ( new File ( lr_1 ) . getAbsolutePath () , timeout ) ; }
return kb ? freeSpaceWindows ( path , timeout ) / FileUtils . ONE_KB : freeSpaceWindows ( path , timeout ) ; MST[rv.CRCR6Mutator]MSP[] case UNIX : return freeSpaceUnix ( path , kb , false , timeout ) ; case POSIX_UNIX :
Process openProcess ( final String [] cmdAttribs ) throws IOException { return Runtime . getRuntime () . exec ( cmdAttribs ) ; MST[NonVoidMethodCallMutator]MSP[] }
final String line3 = lines . get ( 2 ) ; MST[rv.CRCR3Mutator]MSP[] tok = new StringTokenizer ( line3 , lr_20 ) ; } else { throw new IOException ( lr_17 + DF + lr_21 + lr_10 + path + lr_22 ) ; } } else { tok . nextToken () ;
lr_28 + Arrays . asList ( cmdAttribs ) ) ; } inr . close () ; inr = null ; in . close () ; in = null ; if ( out != null ) { MST[NegateConditionalsMutator]MSP[] out . close () ; out = null ; }
if ( err != null ) { err . close () ; MST[VoidMethodCallMutator]MSP[] err = null ; } return lines ; } catch ( final InterruptedException ex ) { throw new IOException ( lr_29 + lr_28 + Arrays . asList ( cmdAttribs ) + lr_30 + timeout , ex ) ;
return freeSpaceUnix ( path , kb , true , timeout ) ; case OTHER : throw new IllegalStateException ( lr_3 ) ; default: throw new IllegalStateException ( MST[ConstructorCallMutator]MSP[] lr_4 ) ; } } long freeSpaceWindows ( final String path , final long timeout ) throws IOException {
return freeSpaceKb ( path , - 1 ) ; } @Deprecated public static long freeSpaceKb ( final String path , final long timeout ) throws IOException { return INSTANCE . freeSpaceOS ( path , OS , true , timeout ) ; MST[InlineConstantMutator]MSP[] } @Deprecated
for ( int i = lines . size () - 1 ; i >= 0 ; i -- ) { MST[IncrementsMutator]MSP[] final String line = lines . get ( i ) ; if ( line . length () > 0 ) { return parseDir ( line , normPath ) ; }
flags += lr_15 ; } if ( posix ) { flags += lr_16 ; } final String [] cmdAttribs = flags . length () > 1 ? new String [] { DF , flags , path } : new String [] { DF , path } ; MST[rv.CRCR3Mutator]MSP[]
final Thread monitor = ThreadMonitor . start ( timeout ) ; proc = openProcess ( cmdAttribs ) ; in = proc . getInputStream () ; out = proc . getOutputStream () ; err = proc . getErrorStream () ; MST[NonVoidMethodCallMutator]MSP[]
return kb ? freeSpaceWindows ( path , timeout ) / FileUtils . ONE_KB : freeSpaceWindows ( path , timeout ) ; MST[rv.ABSMutator]MSP[] case UNIX : return freeSpaceUnix ( path , kb , false , timeout ) ; case POSIX_UNIX :
} throw new IOException ( MST[ConstructorCallMutator]MSP[] lr_9 + lr_10 + normPath + lr_11 ) ; } long parseDir ( final String line , final String path ) throws IOException { int bytesStart = 0 ; int bytesEnd = 0 ; int j = line . length () - 1 ;
final char c = line . charAt ( j ) ; if ( ! Character . isDigit ( c ) && c != ',' && c != '.' ) { MST[rv.ROR5Mutator]MSP[] bytesStart = j + 1 ; break innerLoop2; } j -- ; } if ( j < 0 ) {
String normPath = FilenameUtils . normalize ( path , false ) ; if ( normPath == null ) { throw new IllegalArgumentException ( path ) ; } if ( normPath . length () > 0 && normPath . charAt ( 0 ) != '"' ) { MST[rv.ROR3Mutator]MSP[]
throw new IOException ( lr_12 + lr_10 + path + lr_11 ) ; } final StringBuilder buf = new StringBuilder ( line . substring ( bytesStart , bytesEnd ) ) ; for ( int k = 0 ; k < buf . length () ; k ++ ) { MST[rv.ROR4Mutator]MSP[]
final char c = line . charAt ( j ) ; if ( ! Character . isDigit ( c ) && c != ',' && c != '.' ) { bytesStart = j + 1 ; MST[rv.AOR1Mutator]MSP[] break innerLoop2; } j -- ; } if ( j < 0 ) {
if ( proc . exitValue () != 0 ) { throw new IOException ( lr_25 + proc . exitValue () + lr_26 + Arrays . asList ( cmdAttribs ) ) ; MST[NonVoidMethodCallMutator]MSP[] } if ( lines . isEmpty () ) { throw new IOException ( lr_27 +
final long bytes = Long . parseLong ( freeSpace ) ; if ( bytes < 0 ) { MST[rv.ROR3Mutator]MSP[] throw new IOException ( lr_17 + DF + lr_23 + lr_10 + path + lr_22 ) ; } return bytes ; } catch ( final NumberFormatException ex ) {
long freeSpaceUnix ( final String path , final boolean kb , final boolean posix , final long timeout ) throws IOException { if ( path . isEmpty () ) { throw new IllegalArgumentException ( lr_13 ) ; MST[ConstructorCallMutator]MSP[] } String flags = lr_14 ; if ( kb ) {
final char c = line . charAt ( j ) ; if ( ! Character . isDigit ( c ) && c != ',' && c != '.' ) { MST[rv.CRCR1Mutator]MSP[] bytesStart = j + 1 ; break innerLoop2; } j -- ; } if ( j < 0 ) {
line = line . toLowerCase ( Locale . ENGLISH ) . trim () ; MST[NonVoidMethodCallMutator]MSP[] lines . add ( line ) ; line = inr . readLine () ; } proc . waitFor () ; ThreadMonitor . stop ( monitor ) ;
flags += lr_15 ; } if ( posix ) { MST[rv.UOI3Mutator]MSP[] flags += lr_16 ; } final String [] cmdAttribs = flags . length () > 1 ? new String [] { DF , flags , path } : new String [] { DF , path } ;
return freeSpaceKb ( path , - 1 ) ; MST[rv.CRCR1Mutator]MSP[] } @Deprecated public static long freeSpaceKb ( final String path , final long timeout ) throws IOException { return INSTANCE . freeSpaceOS ( path , OS , true , timeout ) ; } @Deprecated
flags += lr_15 ; } if ( posix ) { flags += lr_16 ; } final String [] cmdAttribs = flags . length () > 1 ? new String [] { DF , flags , path } : new String [] { DF , path } ; MST[rv.CRCR2Mutator]MSP[]
@Deprecated public static long freeSpace ( final String path ) throws IOException { return INSTANCE . freeSpaceOS ( path , OS , false , - 1 ) ; MST[PrimitiveReturnsMutator]MSP[] } @Deprecated public static long freeSpaceKb ( final String path ) throws IOException {
flags += lr_15 ; } if ( posix ) { flags += lr_16 ; } final String [] cmdAttribs = flags . length () > 1 ? new String [] { DF , flags , path } : new String [] { DF , path } ; MST[rv.CRCR3Mutator]MSP[]
flags += lr_15 ; } if ( posix ) { flags += lr_16 ; } final String [] cmdAttribs = flags . length () > 1 ? new String [] { DF , flags , path } : new String [] { DF , path } ; MST[InlineConstantMutator]MSP[]
lr_28 + Arrays . asList ( cmdAttribs ) ) ; } inr . close () ; inr = null ; in . close () ; in = null ; if ( out != null ) { MST[rv.ROR5Mutator]MSP[] out . close () ; out = null ; }
return kb ? freeSpaceWindows ( path , timeout ) / FileUtils . ONE_KB : freeSpaceWindows ( path , timeout ) ; case UNIX : return freeSpaceUnix ( path , kb , false , timeout ) ; MST[NonVoidMethodCallMutator]MSP[] case POSIX_UNIX :
String normPath = FilenameUtils . normalize ( path , false ) ; if ( normPath == null ) { MST[rv.ROR5Mutator]MSP[] throw new IllegalArgumentException ( path ) ; } if ( normPath . length () > 0 && normPath . charAt ( 0 ) != '"' ) {
} finally { IOUtils . closeQuietly ( in ) ; IOUtils . closeQuietly ( out ) ; MST[VoidMethodCallMutator]MSP[] IOUtils . closeQuietly ( err ) ; IOUtils . closeQuietly ( inr ) ; if ( proc != null ) { proc . destroy () ; } } }
} throw new IOException ( lr_9 + lr_10 + normPath + lr_11 ) ; } long parseDir ( final String line , final String path ) throws IOException { int bytesStart = 0 ; int bytesEnd = 0 ; int j = line . length () - 1 ; MST[rv.CRCR4Mutator]MSP[]
final String line2 = lines . get ( 1 ) ; StringTokenizer tok = new StringTokenizer ( line2 , lr_20 ) ; if ( tok . countTokens () < 4 ) { MST[rv.CRCR3Mutator]MSP[] if ( tok . countTokens () == 1 && lines . size () >= 3 ) {
throw new IOException ( lr_12 + lr_10 + path + lr_11 ) ; } final StringBuilder buf = new StringBuilder ( line . substring ( bytesStart , bytesEnd ) ) ; for ( int k = 0 ; k < buf . length () ; k ++ ) { MST[rv.UOI1Mutator]MSP[]
final char c = line . charAt ( j ) ; if ( ! Character . isDigit ( c ) && c != ',' && c != '.' ) { MST[rv.UOI4Mutator]MSP[] bytesStart = j + 1 ; break innerLoop2; } j -- ; } if ( j < 0 ) {
final String line2 = lines . get ( 1 ) ; StringTokenizer tok = new StringTokenizer ( line2 , lr_20 ) ; if ( tok . countTokens () < 4 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] if ( tok . countTokens () == 1 && lines . size () >= 3 ) {
if ( buf . charAt ( k ) == ',' || buf . charAt ( k ) == '.' ) { buf . deleteCharAt ( k -- ) ; } } return parseBytes ( buf . toString () , path ) ; MST[NonVoidMethodCallMutator]MSP[] }
normPath = lr_5 + normPath + lr_5 ; MST[NonVoidMethodCallMutator]MSP[] } final String [] cmdAttribs = new String [] { lr_6 , lr_7 , lr_8 + normPath } ; final List < String > lines = performCommand ( cmdAttribs , Integer . MAX_VALUE , timeout ) ;
final char c = line . charAt ( j ) ; if ( ! Character . isDigit ( c ) && c != ',' && c != '.' ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] bytesStart = j + 1 ; break innerLoop2; } j -- ; } if ( j < 0 ) {
normPath = lr_5 + normPath + lr_5 ; } final String [] cmdAttribs = new String [] { lr_6 , lr_7 , lr_8 + normPath } ; final List < String > lines = performCommand ( cmdAttribs , Integer . MAX_VALUE , timeout ) ; MST[InlineConstantMutator]MSP[]
return kb ? freeSpaceWindows ( path , timeout ) / FileUtils . ONE_KB : freeSpaceWindows ( path , timeout ) ; MST[rv.ABSMutator]MSP[] case UNIX : return freeSpaceUnix ( path , kb , false , timeout ) ; case POSIX_UNIX :
flags += lr_15 ; } if ( posix ) { flags += lr_16 ; } final String [] cmdAttribs = flags . length () > 1 ? new String [] { DF , flags , path } : new String [] { DF , path } ; MST[rv.CRCR2Mutator]MSP[]
for ( int i = lines . size () - 1 ; i >= 0 ; i -- ) { MST[rv.CRCR5Mutator]MSP[] final String line = lines . get ( i ) ; if ( line . length () > 0 ) { return parseDir ( line , normPath ) ; }
normPath = lr_5 + normPath + lr_5 ; } final String [] cmdAttribs = new String [] { lr_6 , lr_7 , lr_8 + normPath } ; final List < String > lines = performCommand ( cmdAttribs , Integer . MAX_VALUE , timeout ) ; MST[rv.CRCR3Mutator]MSP[]
} throw new IOException ( MST[NonVoidMethodCallMutator]MSP[] lr_9 + lr_10 + normPath + lr_11 ) ; } long parseDir ( final String line , final String path ) throws IOException { int bytesStart = 0 ; int bytesEnd = 0 ; int j = line . length () - 1 ;
innerLoop1: while ( j >= 0 ) { final char c = line . charAt ( j ) ; if ( Character . isDigit ( c ) ) { bytesEnd = j + 1 ; MST[rv.ABSMutator]MSP[] break innerLoop1; } j -- ; } innerLoop2: while ( j >= 0 ) {
@Deprecated public static long freeSpace ( final String path ) throws IOException { return INSTANCE . freeSpaceOS ( path , OS , false , - 1 ) ; MST[rv.UOI3Mutator]MSP[] } @Deprecated public static long freeSpaceKb ( final String path ) throws IOException {
if ( buf . charAt ( k ) == ',' || buf . charAt ( k ) == '.' ) { MST[rv.ROR3Mutator]MSP[] buf . deleteCharAt ( k -- ) ; } } return parseBytes ( buf . toString () , path ) ; }
return freeSpaceKb ( path , - 1 ) ; } @Deprecated public static long freeSpaceKb ( final String path , final long timeout ) throws IOException { return INSTANCE . freeSpaceOS ( path , OS , true , timeout ) ; MST[rv.UOI1Mutator]MSP[] } @Deprecated
throw new IOException ( lr_12 + lr_10 + path + lr_11 ) ; } final StringBuilder buf = new StringBuilder ( line . substring ( bytesStart , bytesEnd ) ) ; for ( int k = 0 ; k < buf . length () ; k ++ ) { MST[NonVoidMethodCallMutator]MSP[]
final String line2 = lines . get ( 1 ) ; StringTokenizer tok = new StringTokenizer ( line2 , lr_20 ) ; if ( tok . countTokens () < 4 ) { MST[InlineConstantMutator]MSP[] if ( tok . countTokens () == 1 && lines . size () >= 3 ) {
normPath = lr_5 + normPath + lr_5 ; } final String [] cmdAttribs = new String [] { lr_6 , lr_7 , lr_8 + normPath } ; MST[rv.CRCR5Mutator]MSP[] final List < String > lines = performCommand ( cmdAttribs , Integer . MAX_VALUE , timeout ) ;
innerLoop1: while ( j >= 0 ) { final char c = line . charAt ( j ) ; if ( Character . isDigit ( c ) ) { bytesEnd = j + 1 ; break innerLoop1; } j -- ; } innerLoop2: while ( j >= 0 ) { MST[rv.ROR1Mutator]MSP[]
if ( buf . charAt ( k ) == ',' || buf . charAt ( k ) == '.' ) { MST[rv.UOI4Mutator]MSP[] buf . deleteCharAt ( k -- ) ; } } return parseBytes ( buf . toString () , path ) ; }
long freeSpaceUnix ( final String path , final boolean kb , final boolean posix , final long timeout ) throws IOException { if ( path . isEmpty () ) { MST[rv.ROR1Mutator]MSP[] throw new IllegalArgumentException ( lr_13 ) ; } String flags = lr_14 ; if ( kb ) {
flags += lr_15 ; MST[ConstructorCallMutator]MSP[] } if ( posix ) { flags += lr_16 ; } final String [] cmdAttribs = flags . length () > 1 ? new String [] { DF , flags , path } : new String [] { DF , path } ;
final List < String > lines = performCommand ( cmdAttribs , 3 , timeout ) ; MST[rv.CRCR2Mutator]MSP[] if ( lines . size () < 2 ) { throw new IOException ( lr_17 + DF + lr_18 + lr_10 + path + lr_19 + lines ) ; }
return kb ? freeSpaceWindows ( path , timeout ) / FileUtils . ONE_KB : freeSpaceWindows ( path , timeout ) ; MST[rv.UOI3Mutator]MSP[] case UNIX : return freeSpaceUnix ( path , kb , false , timeout ) ; case POSIX_UNIX :
final char c = line . charAt ( j ) ; if ( ! Character . isDigit ( c ) && c != ',' && c != '.' ) { MST[rv.UOI3Mutator]MSP[] bytesStart = j + 1 ; break innerLoop2; } j -- ; } if ( j < 0 ) {
normPath = lr_5 + normPath + lr_5 ; } final String [] cmdAttribs = new String [] { lr_6 , lr_7 , lr_8 + normPath } ; MST[InlineConstantMutator]MSP[] final List < String > lines = performCommand ( cmdAttribs , Integer . MAX_VALUE , timeout ) ;
flags += lr_15 ; } if ( posix ) { flags += lr_16 ; } final String [] cmdAttribs = flags . length () > 1 ? new String [] { DF , flags , path } : new String [] { DF , path } ; MST[rv.CRCR5Mutator]MSP[]
return kb ? freeSpaceWindows ( path , timeout ) / FileUtils . ONE_KB : freeSpaceWindows ( path , timeout ) ; MST[rv.ROR1Mutator]MSP[] case UNIX : return freeSpaceUnix ( path , kb , false , timeout ) ; case POSIX_UNIX :
for ( int i = lines . size () - 1 ; i >= 0 ; i -- ) { MST[rv.AOR4Mutator]MSP[] final String line = lines . get ( i ) ; if ( line . length () > 0 ) { return parseDir ( line , normPath ) ; }
inr = new BufferedReader ( new InputStreamReader ( in , Charset . defaultCharset () ) ) ; String line = inr . readLine () ; while ( line != null && lines . size () < max ) { MST[rv.ROR3Mutator]MSP[]
@Deprecated public static long freeSpace ( final String path ) throws IOException { return INSTANCE . freeSpaceOS ( path , OS , false , - 1 ) ; MST[ArgumentPropagationMutator]MSP[] } @Deprecated public static long freeSpaceKb ( final String path ) throws IOException {
final char c = line . charAt ( j ) ; if ( ! Character . isDigit ( c ) && c != ',' && c != '.' ) { bytesStart = j + 1 ; MST[rv.CRCR2Mutator]MSP[] break innerLoop2; } j -- ; } if ( j < 0 ) {
return freeSpaceUnix ( path , kb , true , timeout ) ; MST[rv.UOI4Mutator]MSP[] case OTHER : throw new IllegalStateException ( lr_3 ) ; default: throw new IllegalStateException ( lr_4 ) ; } } long freeSpaceWindows ( final String path , final long timeout ) throws IOException {
final char c = line . charAt ( j ) ; if ( ! Character . isDigit ( c ) && c != ',' && c != '.' ) { bytesStart = j + 1 ; break innerLoop2; } j -- ; } if ( j < 0 ) { MST[rv.ROR3Mutator]MSP[]
final String line2 = lines . get ( 1 ) ; StringTokenizer tok = new StringTokenizer ( line2 , lr_20 ) ; if ( tok . countTokens () < 4 ) { if ( tok . countTokens () == 1 && lines . size () >= 3 ) { MST[rv.ROR2Mutator]MSP[]
innerLoop1: while ( j >= 0 ) { final char c = line . charAt ( j ) ; if ( Character . isDigit ( c ) ) { bytesEnd = j + 1 ; MST[rv.AOR4Mutator]MSP[] break innerLoop1; } j -- ; } innerLoop2: while ( j >= 0 ) {
flags += lr_15 ; } if ( posix ) { MST[rv.ABSMutator]MSP[] flags += lr_16 ; } final String [] cmdAttribs = flags . length () > 1 ? new String [] { DF , flags , path } : new String [] { DF , path } ;
final long bytes = Long . parseLong ( freeSpace ) ; if ( bytes < 0 ) { throw new IOException ( MST[experimental.NakedReceiverMutator]MSP[] lr_17 + DF + lr_23 + lr_10 + path + lr_22 ) ; } return bytes ; } catch ( final NumberFormatException ex ) {
Process openProcess ( final String [] cmdAttribs ) throws IOException { return Runtime . getRuntime () . exec ( cmdAttribs ) ; MST[NonVoidMethodCallMutator]MSP[] }
