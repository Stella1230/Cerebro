if ( len < 0 || ( off + len ) > b . length ) { throw new IndexOutOfBoundsException ( lr_2 + b . length + MST[rv.ABSMutator]MSP[] lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { return 0 ; }
for (; ; ) { if ( this . bbuf . hasRemaining () ) { return this . bbuf . get () & 0xFF ; } fillBuffer () ; if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) { MST[rv.ROR1Mutator]MSP[]
final int chunk = Math . min ( this . bbuf . remaining () , len ) ; this . bbuf . get ( b , off , chunk ) ; off += chunk ; MST[rv.ABSMutator]MSP[] len -= chunk ; bytesRead += chunk ; } else { fillBuffer () ;
public boolean markSupported () { return true ; MST[InlineConstantMutator]MSP[] }
final int chunk = Math . min ( this . bbuf . remaining () , len ) ; this . bbuf . get ( b , off , chunk ) ; off += chunk ; len -= chunk ; MST[rv.UOI3Mutator]MSP[] bytesRead += chunk ; } else { fillBuffer () ;
private void fillBuffer () throws CharacterCodingException { this . bbuf . compact () ; final CoderResult result = this . encoder . encode ( this . cbuf , this . bbuf , true ) ; if ( result . isError () ) { MST[rv.ROR3Mutator]MSP[] result . throwException () ; }
final int chunk = Math . min ( this . bbuf . remaining () , len ) ; this . bbuf . get ( b , off , chunk ) ; MST[rv.UOI4Mutator]MSP[] off += chunk ; len -= chunk ; bytesRead += chunk ; } else { fillBuffer () ;
if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) { break; } } } return bytesRead == 0 && ! this . cbuf . hasRemaining () ? EOF : bytesRead ; MST[rv.ABSMutator]MSP[] } @Override public int read () throws IOException {
while( this . cbuf . position () < this . mark_cbuf ) { MST[rv.ROR4Mutator]MSP[] this . bbuf . rewind () ; this . bbuf . limit ( 0 ) ; fillBuffer () ; } } if ( this . cbuf . position () != this . mark_cbuf ) {
while( this . cbuf . position () < this . mark_cbuf ) { this . bbuf . rewind () ; this . bbuf . limit ( 0 ) ; MST[rv.CRCR6Mutator]MSP[] fillBuffer () ; } } if ( this . cbuf . position () != this . mark_cbuf ) {
while ( n > 0 && available () > 0 ) { MST[ConditionalsBoundaryMutator]MSP[] this . read () ; n -- ; skipped ++ ; } return skipped ; } @Override public int available () throws IOException {
if ( len < 0 || ( off + len ) > b . length ) { throw new IndexOutOfBoundsException ( lr_2 + b . length + lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { return 0 ; MST[rv.CRCR5Mutator]MSP[] }
final int chunk = Math . min ( this . bbuf . remaining () , len ) ; MST[rv.UOI2Mutator]MSP[] this . bbuf . get ( b , off , chunk ) ; off += chunk ; len -= chunk ; bytesRead += chunk ; } else { fillBuffer () ;
this . mark_bbuf = this . bbuf . position () ; this . cbuf . mark () ; this . bbuf . mark () ; } @Override public synchronized void reset () throws IOException { if ( this . mark_cbuf != NO_MARK ) { MST[rv.CRCR1Mutator]MSP[]
return EOF ; } } } @Override public int read ( final byte [] b ) throws IOException { return read ( b , 0 , b . length ) ; MST[rv.CRCR3Mutator]MSP[] } @Override public long skip ( long n ) throws IOException { long skipped = 0 ;
final int chunk = Math . min ( this . bbuf . remaining () , len ) ; this . bbuf . get ( b , off , chunk ) ; off += chunk ; MST[rv.AOD1Mutator]MSP[] len -= chunk ; bytesRead += chunk ; } else { fillBuffer () ;
if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) { MST[NonVoidMethodCallMutator]MSP[] return EOF ; } int bytesRead = 0 ; while ( len > 0 ) { if ( this . bbuf . hasRemaining () ) {
if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) { break; } } } return bytesRead == 0 && ! this . cbuf . hasRemaining () ? EOF : bytesRead ; MST[NegateConditionalsMutator]MSP[] } @Override public int read () throws IOException {
while ( n > 0 && available () > 0 ) { MST[rv.ROR3Mutator]MSP[] this . read () ; n -- ; skipped ++ ; } return skipped ; } @Override public int available () throws IOException {
while ( n > 0 && available () > 0 ) { MST[rv.ROR4Mutator]MSP[] this . read () ; n -- ; skipped ++ ; } return skipped ; } @Override public int available () throws IOException {
if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) { return EOF ; } int bytesRead = 0 ; while ( len > 0 ) { MST[rv.ROR4Mutator]MSP[] if ( this . bbuf . hasRemaining () ) {
for (; ; ) { if ( this . bbuf . hasRemaining () ) { return this . bbuf . get () & 0xFF ; } fillBuffer () ; if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) { return EOF ; } int bytesRead = 0 ; while ( len > 0 ) { MST[rv.UOI3Mutator]MSP[] if ( this . bbuf . hasRemaining () ) {
if ( len < 0 || ( off + len ) > b . length ) { throw new IndexOutOfBoundsException ( lr_2 + b . length + MST[experimental.NakedReceiverMutator]MSP[] lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { return 0 ; }
while( this . cbuf . position () < this . mark_cbuf ) { this . bbuf . rewind () ; this . bbuf . limit ( 0 ) ; fillBuffer () ; } } if ( this . cbuf . position () != this . mark_cbuf ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) { MST[NegateConditionalsMutator]MSP[] return EOF ; } int bytesRead = 0 ; while ( len > 0 ) { if ( this . bbuf . hasRemaining () ) {
if ( len < 0 || ( off + len ) > b . length ) { throw new IndexOutOfBoundsException ( lr_2 + b . length + MST[ConstructorCallMutator]MSP[] lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { return 0 ; }
while ( n > 0 && available () > 0 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[] this . read () ; n -- ; skipped ++ ; } return skipped ; } @Override public int available () throws IOException {
while ( n > 0 && available () > 0 ) { this . read () ; n -- ; MST[rv.AOR2Mutator]MSP[] skipped ++ ; } return skipped ; } @Override public int available () throws IOException {
private void fillBuffer () throws CharacterCodingException { this . bbuf . compact () ; final CoderResult result = this . encoder . encode ( this . cbuf , this . bbuf , true ) ; if ( result . isError () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] result . throwException () ; }
for (; ; ) { if ( this . bbuf . hasRemaining () ) { return this . bbuf . get () & 0xFF ; MST[ReturnValsMutator]MSP[] } fillBuffer () ; if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) {
throw new IllegalStateException ( lr_5 + cbuf . position () + lr_6 + lr_7 + this . mark_cbuf ) ; } this . bbuf . position ( this . mark_bbuf ) ; this . mark_cbuf = NO_MARK ; MST[rv.CRCR6Mutator]MSP[] this . mark_bbuf = NO_MARK ; } } @Override
if ( len < 0 || ( off + len ) > b . length ) { throw new IndexOutOfBoundsException ( lr_2 + b . length + MST[rv.UOI2Mutator]MSP[] lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { return 0 ; }
throw new IllegalStateException ( lr_5 + cbuf . position () + lr_6 + lr_7 + this . mark_cbuf ) ; } this . bbuf . position ( this . mark_bbuf ) ; this . mark_cbuf = NO_MARK ; MST[rv.CRCR2Mutator]MSP[] this . mark_bbuf = NO_MARK ; } } @Override
final int chunk = Math . min ( this . bbuf . remaining () , len ) ; this . bbuf . get ( b , off , chunk ) ; off += chunk ; MST[rv.UOI2Mutator]MSP[] len -= chunk ; bytesRead += chunk ; } else { fillBuffer () ;
for (; ; ) { if ( this . bbuf . hasRemaining () ) { return this . bbuf . get () & 0xFF ; MST[rv.OBBN3Mutator]MSP[] } fillBuffer () ; if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) {
final int chunk = Math . min ( this . bbuf . remaining () , len ) ; MST[rv.ABSMutator]MSP[] this . bbuf . get ( b , off , chunk ) ; off += chunk ; len -= chunk ; bytesRead += chunk ; } else { fillBuffer () ;
if ( len < 0 || ( off + len ) > b . length ) { throw new IndexOutOfBoundsException ( lr_2 + b . length + lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { return 0 ; MST[ReturnValsMutator]MSP[] }
this . mark_bbuf = this . bbuf . position () ; this . cbuf . mark () ; this . bbuf . mark () ; } @Override public synchronized void reset () throws IOException { if ( this . mark_cbuf != NO_MARK ) { MST[rv.CRCR5Mutator]MSP[]
if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) { break; } } } return bytesRead == 0 && ! this . cbuf . hasRemaining () ? EOF : bytesRead ; MST[rv.UOI2Mutator]MSP[] } @Override public int read () throws IOException {
if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) { MST[rv.ROR1Mutator]MSP[] return EOF ; } int bytesRead = 0 ; while ( len > 0 ) { if ( this . bbuf . hasRemaining () ) {
if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) { break; } } } return bytesRead == 0 && ! this . cbuf . hasRemaining () ? EOF : bytesRead ; MST[rv.ROR5Mutator]MSP[] } @Override public int read () throws IOException {
if ( len < 0 || ( off + len ) > b . length ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] throw new IndexOutOfBoundsException ( lr_2 + b . length + lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { return 0 ; }
while ( n > 0 && available () > 0 ) { MST[rv.UOI1Mutator]MSP[] this . read () ; n -- ; skipped ++ ; } return skipped ; } @Override public int available () throws IOException {
for (; ; ) { if ( this . bbuf . hasRemaining () ) { MST[NegateConditionalsMutator]MSP[] return this . bbuf . get () & 0xFF ; } fillBuffer () ; if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) {
while ( n > 0 && available () > 0 ) { MST[rv.ABSMutator]MSP[] this . read () ; n -- ; skipped ++ ; } return skipped ; } @Override public int available () throws IOException {
if ( len < 0 || ( off + len ) > b . length ) { throw new IndexOutOfBoundsException ( lr_2 + b . length + MST[NonVoidMethodCallMutator]MSP[] lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { return 0 ; }
this . mark_bbuf = this . bbuf . position () ; this . cbuf . mark () ; this . bbuf . mark () ; } @Override public synchronized void reset () throws IOException { if ( this . mark_cbuf != NO_MARK ) { MST[rv.ROR2Mutator]MSP[]
if ( this . cbuf . position () != 0 ) { MST[rv.ROR4Mutator]MSP[] this . encoder . reset () ; this . cbuf . rewind () ; this . bbuf . rewind () ; this . bbuf . limit ( 0 ) ;
if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) { MST[rv.ROR5Mutator]MSP[] return EOF ; } int bytesRead = 0 ; while ( len > 0 ) { if ( this . bbuf . hasRemaining () ) {
while( this . cbuf . position () < this . mark_cbuf ) { this . bbuf . rewind () ; this . bbuf . limit ( 0 ) ; MST[NonVoidMethodCallMutator]MSP[] fillBuffer () ; } } if ( this . cbuf . position () != this . mark_cbuf ) {
while ( n > 0 && available () > 0 ) { this . read () ; n -- ; skipped ++ ; MST[rv.AOD2Mutator]MSP[] } return skipped ; } @Override public int available () throws IOException {
while( this . cbuf . position () < this . mark_cbuf ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] this . bbuf . rewind () ; this . bbuf . limit ( 0 ) ; fillBuffer () ; } } if ( this . cbuf . position () != this . mark_cbuf ) {
for (; ; ) { if ( this . bbuf . hasRemaining () ) { return this . bbuf . get () & 0xFF ; MST[rv.CRCR5Mutator]MSP[] } fillBuffer () ; if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) {
for (; ; ) { if ( this . bbuf . hasRemaining () ) { return this . bbuf . get () & 0xFF ; MST[rv.CRCR1Mutator]MSP[] } fillBuffer () ; if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) {
final int chunk = Math . min ( this . bbuf . remaining () , len ) ; this . bbuf . get ( b , off , chunk ) ; off += chunk ; MST[rv.UOI1Mutator]MSP[] len -= chunk ; bytesRead += chunk ; } else { fillBuffer () ;
private void fillBuffer () throws CharacterCodingException { this . bbuf . compact () ; final CoderResult result = this . encoder . encode ( this . cbuf , this . bbuf , true ) ; MST[rv.CRCR4Mutator]MSP[] if ( result . isError () ) { result . throwException () ; }
if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) { return EOF ; MST[rv.CRCR1Mutator]MSP[] } int bytesRead = 0 ; while ( len > 0 ) { if ( this . bbuf . hasRemaining () ) {
if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) { return EOF ; } int bytesRead = 0 ; while ( len > 0 ) { if ( this . bbuf . hasRemaining () ) { MST[rv.ROR2Mutator]MSP[]
private void fillBuffer () throws CharacterCodingException { this . bbuf . compact () ; final CoderResult result = this . encoder . encode ( this . cbuf , this . bbuf , true ) ; if ( result . isError () ) { MST[NonVoidMethodCallMutator]MSP[] result . throwException () ; }
throw new IllegalStateException ( lr_5 + cbuf . position () + lr_6 + lr_7 + this . mark_cbuf ) ; } this . bbuf . position ( this . mark_bbuf ) ; MST[rv.UOI1Mutator]MSP[] this . mark_cbuf = NO_MARK ; this . mark_bbuf = NO_MARK ; } } @Override
if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) { break; } } } return bytesRead == 0 && ! this . cbuf . hasRemaining () ? EOF : bytesRead ; MST[rv.UOI3Mutator]MSP[] } @Override public int read () throws IOException {
for (; ; ) { if ( this . bbuf . hasRemaining () ) { MST[rv.ROR5Mutator]MSP[] return this . bbuf . get () & 0xFF ; } fillBuffer () ; if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) {
final int chunk = Math . min ( this . bbuf . remaining () , len ) ; this . bbuf . get ( b , off , chunk ) ; off += chunk ; len -= chunk ; MST[rv.AOD2Mutator]MSP[] bytesRead += chunk ; } else { fillBuffer () ;
while ( n > 0 && available () > 0 ) { MST[rv.UOI2Mutator]MSP[] this . read () ; n -- ; skipped ++ ; } return skipped ; } @Override public int available () throws IOException {
public boolean markSupported () { return true ; MST[rv.CRCR2Mutator]MSP[] }
final int chunk = Math . min ( this . bbuf . remaining () , len ) ; this . bbuf . get ( b , off , chunk ) ; off += chunk ; MST[rv.AOR3Mutator]MSP[] len -= chunk ; bytesRead += chunk ; } else { fillBuffer () ;
while ( n > 0 && available () > 0 ) { MST[InlineConstantMutator]MSP[] this . read () ; n -- ; skipped ++ ; } return skipped ; } @Override public int available () throws IOException {
if ( len < 0 || ( off + len ) > b . length ) { MST[rv.UOI4Mutator]MSP[] throw new IndexOutOfBoundsException ( lr_2 + b . length + lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { return 0 ; }
if ( len < 0 || ( off + len ) > b . length ) { MST[rv.ROR5Mutator]MSP[] throw new IndexOutOfBoundsException ( lr_2 + b . length + lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { return 0 ; }
if ( len < 0 || ( off + len ) > b . length ) { throw new IndexOutOfBoundsException ( lr_2 + b . length + MST[experimental.NakedReceiverMutator]MSP[] lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { return 0 ; }
if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) { break; } } } return bytesRead == 0 && ! this . cbuf . hasRemaining () ? EOF : bytesRead ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] } @Override public int read () throws IOException {
if ( this . cbuf . position () != 0 ) { this . encoder . reset () ; this . cbuf . rewind () ; this . bbuf . rewind () ; this . bbuf . limit ( 0 ) ; MST[rv.CRCR5Mutator]MSP[]
if ( this . cbuf . position () != 0 ) { MST[rv.ROR3Mutator]MSP[] this . encoder . reset () ; this . cbuf . rewind () ; this . bbuf . rewind () ; this . bbuf . limit ( 0 ) ;
if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) { MST[rv.ROR4Mutator]MSP[] return EOF ; } int bytesRead = 0 ; while ( len > 0 ) { if ( this . bbuf . hasRemaining () ) {
while( this . cbuf . position () < this . mark_cbuf ) { this . bbuf . rewind () ; this . bbuf . limit ( 0 ) ; fillBuffer () ; } } if ( this . cbuf . position () != this . mark_cbuf ) { MST[rv.UOI2Mutator]MSP[]
final int chunk = Math . min ( this . bbuf . remaining () , len ) ; this . bbuf . get ( b , off , chunk ) ; off += chunk ; len -= chunk ; MST[rv.UOI3Mutator]MSP[] bytesRead += chunk ; } else { fillBuffer () ;
if ( len < 0 || ( off + len ) > b . length ) { throw new IndexOutOfBoundsException ( lr_2 + b . length + lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { MST[rv.UOI4Mutator]MSP[] return 0 ; }
final int chunk = Math . min ( this . bbuf . remaining () , len ) ; this . bbuf . get ( b , off , chunk ) ; off += chunk ; MST[rv.UOI1Mutator]MSP[] len -= chunk ; bytesRead += chunk ; } else { fillBuffer () ;
this . mark_bbuf = this . bbuf . position () ; this . cbuf . mark () ; this . bbuf . mark () ; } @Override public synchronized void reset () throws IOException { if ( this . mark_cbuf != NO_MARK ) { MST[rv.UOI4Mutator]MSP[]
final int chunk = Math . min ( this . bbuf . remaining () , len ) ; this . bbuf . get ( b , off , chunk ) ; off += chunk ; MST[rv.ABSMutator]MSP[] len -= chunk ; bytesRead += chunk ; } else { fillBuffer () ;
while ( n > 0 && available () > 0 ) { this . read () ; n -- ; MST[rv.CRCR5Mutator]MSP[] skipped ++ ; } return skipped ; } @Override public int available () throws IOException {
if ( len < 0 || ( off + len ) > b . length ) { throw new IndexOutOfBoundsException ( lr_2 + b . length + MST[rv.UOI1Mutator]MSP[] lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { return 0 ; }
while ( n > 0 && available () > 0 ) { this . read () ; n -- ; MST[rv.AOD1Mutator]MSP[] skipped ++ ; } return skipped ; } @Override public int available () throws IOException {
while ( n > 0 && available () > 0 ) { this . read () ; n -- ; skipped ++ ; MST[rv.CRCR2Mutator]MSP[] } return skipped ; } @Override public int available () throws IOException {
if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return EOF ; } int bytesRead = 0 ; while ( len > 0 ) { if ( this . bbuf . hasRemaining () ) {
return this . bbuf . remaining () + this . cbuf . remaining () ; MST[rv.AOR2Mutator]MSP[] } @Override public void close () throws IOException { } @Override public synchronized void mark ( final int readlimit ) { this . mark_cbuf = this . cbuf . position () ;
return EOF ; } } } @Override public int read ( final byte [] b ) throws IOException { return read ( b , 0 , b . length ) ; } @Override public long skip ( long n ) throws IOException { long skipped = 0 ; MST[rv.CRCR1Mutator]MSP[]
while ( n > 0 && available () > 0 ) { MST[rv.CRCR6Mutator]MSP[] this . read () ; n -- ; skipped ++ ; } return skipped ; } @Override public int available () throws IOException {
if ( len < 0 || ( off + len ) > b . length ) { MST[rv.ROR2Mutator]MSP[] throw new IndexOutOfBoundsException ( lr_2 + b . length + lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { return 0 ; }
if ( len < 0 || ( off + len ) > b . length ) { throw new IndexOutOfBoundsException ( lr_2 + b . length + lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { return 0 ; MST[rv.CRCR1Mutator]MSP[] }
if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) { break; } } } return bytesRead == 0 && ! this . cbuf . hasRemaining () ? EOF : bytesRead ; MST[rv.UOI1Mutator]MSP[] } @Override public int read () throws IOException {
if ( len < 0 || ( off + len ) > b . length ) { MST[rv.UOI4Mutator]MSP[] throw new IndexOutOfBoundsException ( lr_2 + b . length + lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { return 0 ; }
throw new IllegalStateException ( lr_5 + cbuf . position () + lr_6 + lr_7 + this . mark_cbuf ) ; } this . bbuf . position ( this . mark_bbuf ) ; MST[rv.UOI4Mutator]MSP[] this . mark_cbuf = NO_MARK ; this . mark_bbuf = NO_MARK ; } } @Override
this . mark_bbuf = this . bbuf . position () ; this . cbuf . mark () ; MST[NonVoidMethodCallMutator]MSP[] this . bbuf . mark () ; } @Override public synchronized void reset () throws IOException { if ( this . mark_cbuf != NO_MARK ) {
if ( this . cbuf . position () != 0 ) { this . encoder . reset () ; this . cbuf . rewind () ; MST[NonVoidMethodCallMutator]MSP[] this . bbuf . rewind () ; this . bbuf . limit ( 0 ) ;
if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) { MST[rv.ROR3Mutator]MSP[] break; } } } return bytesRead == 0 && ! this . cbuf . hasRemaining () ? EOF : bytesRead ; } @Override public int read () throws IOException {
if ( len < 0 || ( off + len ) > b . length ) { MST[rv.AOR1Mutator]MSP[] throw new IndexOutOfBoundsException ( lr_2 + b . length + lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { return 0 ; }
if ( len < 0 || ( off + len ) > b . length ) { MST[rv.UOI3Mutator]MSP[] throw new IndexOutOfBoundsException ( lr_2 + b . length + lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { return 0 ; }
while ( n > 0 && available () > 0 ) { this . read () ; n -- ; MST[rv.ABSMutator]MSP[] skipped ++ ; } return skipped ; } @Override public int available () throws IOException {
while ( n > 0 && available () > 0 ) { this . read () ; n -- ; skipped ++ ; MST[rv.AOR3Mutator]MSP[] } return skipped ; } @Override public int available () throws IOException {
return this . bbuf . remaining () + this . cbuf . remaining () ; MST[PrimitiveReturnsMutator]MSP[] } @Override public void close () throws IOException { } @Override public synchronized void mark ( final int readlimit ) { this . mark_cbuf = this . cbuf . position () ;
final int chunk = Math . min ( this . bbuf . remaining () , len ) ; this . bbuf . get ( b , off , chunk ) ; off += chunk ; len -= chunk ; bytesRead += chunk ; MST[rv.AOR2Mutator]MSP[] } else { fillBuffer () ;
while ( n > 0 && available () > 0 ) { this . read () ; n -- ; skipped ++ ; MST[rv.UOI3Mutator]MSP[] } return skipped ; } @Override public int available () throws IOException {
while ( n > 0 && available () > 0 ) { MST[rv.ROR3Mutator]MSP[] this . read () ; n -- ; skipped ++ ; } return skipped ; } @Override public int available () throws IOException {
while ( n > 0 && available () > 0 ) { this . read () ; n -- ; MST[rv.UOI1Mutator]MSP[] skipped ++ ; } return skipped ; } @Override public int available () throws IOException {
this . bbuf . flip () ; } @Override public int read ( final byte [] b , int off , int len ) throws IOException { if ( b == null ) { MST[NegateConditionalsMutator]MSP[] throw new NullPointerException ( lr_1 ) ; }
if ( len < 0 || ( off + len ) > b . length ) { MST[ConditionalsBoundaryMutator]MSP[] throw new IndexOutOfBoundsException ( lr_2 + b . length + lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { return 0 ; }
while( this . cbuf . position () < this . mark_cbuf ) { this . bbuf . rewind () ; this . bbuf . limit ( 0 ) ; fillBuffer () ; } } if ( this . cbuf . position () != this . mark_cbuf ) { MST[rv.ROR2Mutator]MSP[]
while ( n > 0 && available () > 0 ) { this . read () ; n -- ; MST[rv.AOR1Mutator]MSP[] skipped ++ ; } return skipped ; } @Override public int available () throws IOException {
if ( len < 0 || ( off + len ) > b . length ) { MST[rv.AOD2Mutator]MSP[] throw new IndexOutOfBoundsException ( lr_2 + b . length + lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { return 0 ; }
for (; ; ) { if ( this . bbuf . hasRemaining () ) { return this . bbuf . get () & 0xFF ; } fillBuffer () ; if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) { MST[rv.ROR3Mutator]MSP[]
final int chunk = Math . min ( this . bbuf . remaining () , len ) ; this . bbuf . get ( b , off , chunk ) ; off += chunk ; len -= chunk ; MST[rv.UOI4Mutator]MSP[] bytesRead += chunk ; } else { fillBuffer () ;
while( this . cbuf . position () < this . mark_cbuf ) { this . bbuf . rewind () ; this . bbuf . limit ( 0 ) ; MST[rv.CRCR1Mutator]MSP[] fillBuffer () ; } } if ( this . cbuf . position () != this . mark_cbuf ) {
while( this . cbuf . position () < this . mark_cbuf ) { this . bbuf . rewind () ; this . bbuf . limit ( 0 ) ; MST[rv.CRCR5Mutator]MSP[] fillBuffer () ; } } if ( this . cbuf . position () != this . mark_cbuf ) {
final int chunk = Math . min ( this . bbuf . remaining () , len ) ; MST[rv.UOI3Mutator]MSP[] this . bbuf . get ( b , off , chunk ) ; off += chunk ; len -= chunk ; bytesRead += chunk ; } else { fillBuffer () ;
final int chunk = Math . min ( this . bbuf . remaining () , len ) ; this . bbuf . get ( b , off , chunk ) ; MST[rv.UOI1Mutator]MSP[] off += chunk ; len -= chunk ; bytesRead += chunk ; } else { fillBuffer () ;
return EOF ; } } } @Override public int read ( final byte [] b ) throws IOException { return read ( b , 0 , b . length ) ; MST[rv.CRCR6Mutator]MSP[] } @Override public long skip ( long n ) throws IOException { long skipped = 0 ;
while ( n > 0 && available () > 0 ) { this . read () ; n -- ; MST[rv.UOI4Mutator]MSP[] skipped ++ ; } return skipped ; } @Override public int available () throws IOException {
if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) { MST[NonVoidMethodCallMutator]MSP[] break; } } } return bytesRead == 0 && ! this . cbuf . hasRemaining () ? EOF : bytesRead ; } @Override public int read () throws IOException {
for (; ; ) { if ( this . bbuf . hasRemaining () ) { return this . bbuf . get () & 0xFF ; } fillBuffer () ; if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
if ( len < 0 || ( off + len ) > b . length ) { MST[rv.UOI4Mutator]MSP[] throw new IndexOutOfBoundsException ( lr_2 + b . length + lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { return 0 ; }
if ( len < 0 || ( off + len ) > b . length ) { MST[rv.UOI1Mutator]MSP[] throw new IndexOutOfBoundsException ( lr_2 + b . length + lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { return 0 ; }
final int chunk = Math . min ( this . bbuf . remaining () , len ) ; this . bbuf . get ( b , off , chunk ) ; off += chunk ; len -= chunk ; MST[rv.AOR3Mutator]MSP[] bytesRead += chunk ; } else { fillBuffer () ;
while ( n > 0 && available () > 0 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] this . read () ; n -- ; skipped ++ ; } return skipped ; } @Override public int available () throws IOException {
while ( n > 0 && available () > 0 ) { MST[NegateConditionalsMutator]MSP[] this . read () ; n -- ; skipped ++ ; } return skipped ; } @Override public int available () throws IOException {
if ( len < 0 || ( off + len ) > b . length ) { throw new IndexOutOfBoundsException ( lr_2 + b . length + MST[experimental.NakedReceiverMutator]MSP[] lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { return 0 ; }
throw new IllegalStateException ( lr_5 + cbuf . position () + lr_6 + lr_7 + this . mark_cbuf ) ; } this . bbuf . position ( this . mark_bbuf ) ; this . mark_cbuf = NO_MARK ; this . mark_bbuf = NO_MARK ; MST[InlineConstantMutator]MSP[] } } @Override
this . mark_bbuf = this . bbuf . position () ; this . cbuf . mark () ; this . bbuf . mark () ; } @Override public synchronized void reset () throws IOException { if ( this . mark_cbuf != NO_MARK ) { MST[rv.ABSMutator]MSP[]
this . mark_bbuf = this . bbuf . position () ; this . cbuf . mark () ; this . bbuf . mark () ; } @Override public synchronized void reset () throws IOException { if ( this . mark_cbuf != NO_MARK ) { MST[rv.ROR1Mutator]MSP[]
this . mark_bbuf = this . bbuf . position () ; this . cbuf . mark () ; this . bbuf . mark () ; } @Override public synchronized void reset () throws IOException { if ( this . mark_cbuf != NO_MARK ) { MST[rv.ROR5Mutator]MSP[]
for (; ; ) { if ( this . bbuf . hasRemaining () ) { return this . bbuf . get () & 0xFF ; MST[rv.CRCR6Mutator]MSP[] } fillBuffer () ; if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) {
for (; ; ) { if ( this . bbuf . hasRemaining () ) { return this . bbuf . get () & 0xFF ; MST[rv.CRCR2Mutator]MSP[] } fillBuffer () ; if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) {
throw new IllegalStateException ( lr_5 + cbuf . position () + lr_6 + lr_7 + this . mark_cbuf ) ; } this . bbuf . position ( this . mark_bbuf ) ; this . mark_cbuf = NO_MARK ; MST[rv.CRCR5Mutator]MSP[] this . mark_bbuf = NO_MARK ; } } @Override
this . mark_bbuf = this . bbuf . position () ; this . cbuf . mark () ; this . bbuf . mark () ; } @Override public synchronized void reset () throws IOException { if ( this . mark_cbuf != NO_MARK ) { MST[rv.UOI2Mutator]MSP[]
while ( n > 0 && available () > 0 ) { this . read () ; n -- ; MST[rv.CRCR6Mutator]MSP[] skipped ++ ; } return skipped ; } @Override public int available () throws IOException {
final int chunk = Math . min ( this . bbuf . remaining () , len ) ; this . bbuf . get ( b , off , chunk ) ; off += chunk ; len -= chunk ; bytesRead += chunk ; MST[rv.UOI2Mutator]MSP[] } else { fillBuffer () ;
while ( n > 0 && available () > 0 ) { this . read () ; n -- ; MST[rv.CRCR2Mutator]MSP[] skipped ++ ; } return skipped ; } @Override public int available () throws IOException {
if ( len < 0 || ( off + len ) > b . length ) { throw new IndexOutOfBoundsException ( lr_2 + b . length + MST[rv.UOI3Mutator]MSP[] lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { return 0 ; }
final int chunk = Math . min ( this . bbuf . remaining () , len ) ; this . bbuf . get ( b , off , chunk ) ; off += chunk ; len -= chunk ; MST[rv.ABSMutator]MSP[] bytesRead += chunk ; } else { fillBuffer () ;
throw new IllegalStateException ( lr_5 + cbuf . position () + lr_6 + lr_7 + this . mark_cbuf ) ; } this . bbuf . position ( this . mark_bbuf ) ; this . mark_cbuf = NO_MARK ; MST[rv.CRCR1Mutator]MSP[] this . mark_bbuf = NO_MARK ; } } @Override
final int chunk = Math . min ( this . bbuf . remaining () , len ) ; this . bbuf . get ( b , off , chunk ) ; off += chunk ; MST[rv.UOI3Mutator]MSP[] len -= chunk ; bytesRead += chunk ; } else { fillBuffer () ;
if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) { return EOF ; } int bytesRead = 0 ; MST[rv.CRCR3Mutator]MSP[] while ( len > 0 ) { if ( this . bbuf . hasRemaining () ) {
while ( n > 0 && available () > 0 ) { this . read () ; n -- ; skipped ++ ; MST[rv.CRCR4Mutator]MSP[] } return skipped ; } @Override public int available () throws IOException {
if ( len < 0 || ( off + len ) > b . length ) { MST[rv.AOR4Mutator]MSP[] throw new IndexOutOfBoundsException ( lr_2 + b . length + lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { return 0 ; }
final int chunk = Math . min ( this . bbuf . remaining () , len ) ; this . bbuf . get ( b , off , chunk ) ; off += chunk ; len -= chunk ; MST[rv.UOI4Mutator]MSP[] bytesRead += chunk ; } else { fillBuffer () ;
if ( len < 0 || ( off + len ) > b . length ) { throw new IndexOutOfBoundsException ( lr_2 + b . length + MST[NonVoidMethodCallMutator]MSP[] lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { return 0 ; }
if ( len < 0 || ( off + len ) > b . length ) { throw new IndexOutOfBoundsException ( lr_2 + b . length + MST[rv.UOI2Mutator]MSP[] lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { return 0 ; }
final int chunk = Math . min ( this . bbuf . remaining () , len ) ; this . bbuf . get ( b , off , chunk ) ; MST[rv.UOI1Mutator]MSP[] off += chunk ; len -= chunk ; bytesRead += chunk ; } else { fillBuffer () ;
if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) { break; } } } return bytesRead == 0 && ! this . cbuf . hasRemaining () ? EOF : bytesRead ; MST[rv.UOI3Mutator]MSP[] } @Override public int read () throws IOException {
while ( n > 0 && available () > 0 ) { MST[rv.CRCR1Mutator]MSP[] this . read () ; n -- ; skipped ++ ; } return skipped ; } @Override public int available () throws IOException {
this . mark_bbuf = this . bbuf . position () ; MST[NonVoidMethodCallMutator]MSP[] this . cbuf . mark () ; this . bbuf . mark () ; } @Override public synchronized void reset () throws IOException { if ( this . mark_cbuf != NO_MARK ) {
if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) { break; } } } return bytesRead == 0 && ! this . cbuf . hasRemaining () ? EOF : bytesRead ; MST[rv.UOI4Mutator]MSP[] } @Override public int read () throws IOException {
final int chunk = Math . min ( this . bbuf . remaining () , len ) ; MST[ArgumentPropagationMutator]MSP[] this . bbuf . get ( b , off , chunk ) ; off += chunk ; len -= chunk ; bytesRead += chunk ; } else { fillBuffer () ;
while ( n > 0 && available () > 0 ) { MST[rv.ROR5Mutator]MSP[] this . read () ; n -- ; skipped ++ ; } return skipped ; } @Override public int available () throws IOException {
while ( n > 0 && available () > 0 ) { MST[rv.ROR4Mutator]MSP[] this . read () ; n -- ; skipped ++ ; } return skipped ; } @Override public int available () throws IOException {
if ( len < 0 || ( off + len ) > b . length ) { MST[NegateConditionalsMutator]MSP[] throw new IndexOutOfBoundsException ( lr_2 + b . length + lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { return 0 ; }
public boolean markSupported () { return true ; MST[rv.CRCR3Mutator]MSP[] }
if ( len < 0 || ( off + len ) > b . length ) { MST[rv.ABSMutator]MSP[] throw new IndexOutOfBoundsException ( lr_2 + b . length + lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { return 0 ; }
while ( n > 0 && available () > 0 ) { this . read () ; n -- ; skipped ++ ; MST[rv.UOI1Mutator]MSP[] } return skipped ; } @Override public int available () throws IOException {
while( this . cbuf . position () < this . mark_cbuf ) { this . bbuf . rewind () ; this . bbuf . limit ( 0 ) ; fillBuffer () ; } } if ( this . cbuf . position () != this . mark_cbuf ) { MST[NonVoidMethodCallMutator]MSP[]
if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) { MST[rv.ROR5Mutator]MSP[] return EOF ; } int bytesRead = 0 ; while ( len > 0 ) { if ( this . bbuf . hasRemaining () ) {
if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) { MST[rv.ROR1Mutator]MSP[] return EOF ; } int bytesRead = 0 ; while ( len > 0 ) { if ( this . bbuf . hasRemaining () ) {
final int chunk = Math . min ( this . bbuf . remaining () , len ) ; this . bbuf . get ( b , off , chunk ) ; off += chunk ; MST[MathMutator]MSP[] len -= chunk ; bytesRead += chunk ; } else { fillBuffer () ;
while ( n > 0 && available () > 0 ) { this . read () ; n -- ; skipped ++ ; } return skipped ; MST[rv.ABSMutator]MSP[] } @Override public int available () throws IOException {
final int chunk = Math . min ( this . bbuf . remaining () , len ) ; this . bbuf . get ( b , off , chunk ) ; off += chunk ; len -= chunk ; bytesRead += chunk ; MST[rv.UOI1Mutator]MSP[] } else { fillBuffer () ;
final int chunk = Math . min ( this . bbuf . remaining () , len ) ; this . bbuf . get ( b , off , chunk ) ; off += chunk ; MST[rv.UOI2Mutator]MSP[] len -= chunk ; bytesRead += chunk ; } else { fillBuffer () ;
this . bbuf . flip () ; } @Override public int read ( final byte [] b , int off , int len ) throws IOException { if ( b == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] throw new NullPointerException ( lr_1 ) ; }
while ( n > 0 && available () > 0 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[] this . read () ; n -- ; skipped ++ ; } return skipped ; } @Override public int available () throws IOException {
private void fillBuffer () throws CharacterCodingException { this . bbuf . compact () ; final CoderResult result = this . encoder . encode ( this . cbuf , this . bbuf , true ) ; MST[rv.CRCR3Mutator]MSP[] if ( result . isError () ) { result . throwException () ; }
throw new IllegalStateException ( lr_5 + cbuf . position () + lr_6 + lr_7 + this . mark_cbuf ) ; } this . bbuf . position ( this . mark_bbuf ) ; this . mark_cbuf = NO_MARK ; this . mark_bbuf = NO_MARK ; MST[rv.CRCR2Mutator]MSP[] } } @Override
if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) { break; } } } return bytesRead == 0 && ! this . cbuf . hasRemaining () ? EOF : bytesRead ; MST[rv.ROR2Mutator]MSP[] } @Override public int read () throws IOException {
if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) { break; } } } return bytesRead == 0 && ! this . cbuf . hasRemaining () ? EOF : bytesRead ; MST[rv.ROR1Mutator]MSP[] } @Override public int read () throws IOException {
this . mark_bbuf = this . bbuf . position () ; MST[experimental.MemberVariableMutator]MSP[] this . cbuf . mark () ; this . bbuf . mark () ; } @Override public synchronized void reset () throws IOException { if ( this . mark_cbuf != NO_MARK ) {
throw new IllegalStateException ( lr_5 + cbuf . position () + lr_6 + lr_7 + this . mark_cbuf ) ; } this . bbuf . position ( this . mark_bbuf ) ; MST[NonVoidMethodCallMutator]MSP[] this . mark_cbuf = NO_MARK ; this . mark_bbuf = NO_MARK ; } } @Override
throw new IllegalStateException ( lr_5 + cbuf . position () + lr_6 + lr_7 + this . mark_cbuf ) ; } this . bbuf . position ( this . mark_bbuf ) ; MST[rv.UOI2Mutator]MSP[] this . mark_cbuf = NO_MARK ; this . mark_bbuf = NO_MARK ; } } @Override
while ( n > 0 && available () > 0 ) { this . read () ; n -- ; skipped ++ ; MST[MathMutator]MSP[] } return skipped ; } @Override public int available () throws IOException {
if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) { MST[rv.ROR2Mutator]MSP[] return EOF ; } int bytesRead = 0 ; while ( len > 0 ) { if ( this . bbuf . hasRemaining () ) {
throw new IllegalStateException ( lr_5 + cbuf . position () + lr_6 + lr_7 + this . mark_cbuf ) ; } this . bbuf . position ( this . mark_bbuf ) ; MST[rv.UOI3Mutator]MSP[] this . mark_cbuf = NO_MARK ; this . mark_bbuf = NO_MARK ; } } @Override
return EOF ; } } } @Override public int read ( final byte [] b ) throws IOException { return read ( b , 0 , b . length ) ; } @Override public long skip ( long n ) throws IOException { long skipped = 0 ; MST[rv.CRCR5Mutator]MSP[]
while ( n > 0 && available () > 0 ) { this . read () ; n -- ; skipped ++ ; MST[rv.AOR2Mutator]MSP[] } return skipped ; } @Override public int available () throws IOException {
if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) { return EOF ; } int bytesRead = 0 ; MST[InlineConstantMutator]MSP[] while ( len > 0 ) { if ( this . bbuf . hasRemaining () ) {
for (; ; ) { if ( this . bbuf . hasRemaining () ) { MST[rv.ROR1Mutator]MSP[] return this . bbuf . get () & 0xFF ; } fillBuffer () ; if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) {
public boolean markSupported () { return true ; MST[rv.CRCR4Mutator]MSP[] }
this . mark_bbuf = this . bbuf . position () ; this . cbuf . mark () ; this . bbuf . mark () ; } @Override public synchronized void reset () throws IOException { if ( this . mark_cbuf != NO_MARK ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
while ( n > 0 && available () > 0 ) { this . read () ; n -- ; skipped ++ ; } return skipped ; MST[rv.UOI4Mutator]MSP[] } @Override public int available () throws IOException {
if ( len < 0 || ( off + len ) > b . length ) { MST[rv.ROR1Mutator]MSP[] throw new IndexOutOfBoundsException ( lr_2 + b . length + lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { return 0 ; }
if ( len < 0 || ( off + len ) > b . length ) { throw new IndexOutOfBoundsException ( lr_2 + b . length + MST[NonVoidMethodCallMutator]MSP[] lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { return 0 ; }
if ( len < 0 || ( off + len ) > b . length ) { throw new IndexOutOfBoundsException ( lr_2 + b . length + MST[experimental.NakedReceiverMutator]MSP[] lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { return 0 ; }
final int chunk = Math . min ( this . bbuf . remaining () , len ) ; this . bbuf . get ( b , off , chunk ) ; MST[experimental.NakedReceiverMutator]MSP[] off += chunk ; len -= chunk ; bytesRead += chunk ; } else { fillBuffer () ;
final int chunk = Math . min ( this . bbuf . remaining () , len ) ; this . bbuf . get ( b , off , chunk ) ; off += chunk ; len -= chunk ; bytesRead += chunk ; MST[rv.AOR1Mutator]MSP[] } else { fillBuffer () ;
while ( n > 0 && available () > 0 ) { this . read () ; n -- ; skipped ++ ; MST[rv.UOI2Mutator]MSP[] } return skipped ; } @Override public int available () throws IOException {
if ( this . cbuf . position () != 0 ) { this . encoder . reset () ; this . cbuf . rewind () ; this . bbuf . rewind () ; this . bbuf . limit ( 0 ) ; MST[rv.CRCR3Mutator]MSP[]
while ( n > 0 && available () > 0 ) { MST[NonVoidMethodCallMutator]MSP[] this . read () ; n -- ; skipped ++ ; } return skipped ; } @Override public int available () throws IOException {
while( this . cbuf . position () < this . mark_cbuf ) { this . bbuf . rewind () ; this . bbuf . limit ( 0 ) ; fillBuffer () ; } } if ( this . cbuf . position () != this . mark_cbuf ) { MST[rv.UOI4Mutator]MSP[]
while( this . cbuf . position () < this . mark_cbuf ) { this . bbuf . rewind () ; this . bbuf . limit ( 0 ) ; fillBuffer () ; } } if ( this . cbuf . position () != this . mark_cbuf ) { MST[rv.ROR1Mutator]MSP[]
while ( n > 0 && available () > 0 ) { this . read () ; n -- ; MST[rv.AOD2Mutator]MSP[] skipped ++ ; } return skipped ; } @Override public int available () throws IOException {
return this . bbuf . remaining () + this . cbuf . remaining () ; MST[rv.AOR1Mutator]MSP[] } @Override public void close () throws IOException { } @Override public synchronized void mark ( final int readlimit ) { this . mark_cbuf = this . cbuf . position () ;
if ( len < 0 || ( off + len ) > b . length ) { throw new IndexOutOfBoundsException ( lr_2 + b . length + MST[NonVoidMethodCallMutator]MSP[] lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { return 0 ; }
if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] break; } } } return bytesRead == 0 && ! this . cbuf . hasRemaining () ? EOF : bytesRead ; } @Override public int read () throws IOException {
if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return EOF ; } int bytesRead = 0 ; while ( len > 0 ) { if ( this . bbuf . hasRemaining () ) {
while ( n > 0 && available () > 0 ) { this . read () ; n -- ; skipped ++ ; MST[rv.CRCR3Mutator]MSP[] } return skipped ; } @Override public int available () throws IOException {
for (; ; ) { if ( this . bbuf . hasRemaining () ) { return this . bbuf . get () & 0xFF ; MST[rv.OBBN2Mutator]MSP[] } fillBuffer () ; if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) {
if ( len < 0 || ( off + len ) > b . length ) { MST[rv.ROR3Mutator]MSP[] throw new IndexOutOfBoundsException ( lr_2 + b . length + lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { return 0 ; }
if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) { break; } } } return bytesRead == 0 && ! this . cbuf . hasRemaining () ? EOF : bytesRead ; MST[PrimitiveReturnsMutator]MSP[] } @Override public int read () throws IOException {
if ( this . cbuf . position () != 0 ) { this . encoder . reset () ; this . cbuf . rewind () ; this . bbuf . rewind () ; this . bbuf . limit ( 0 ) ; MST[NonVoidMethodCallMutator]MSP[]
if ( len < 0 || ( off + len ) > b . length ) { throw new IndexOutOfBoundsException ( lr_2 + b . length + MST[rv.UOI1Mutator]MSP[] lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { return 0 ; }
this . mark_bbuf = this . bbuf . position () ; this . cbuf . mark () ; this . bbuf . mark () ; } @Override public synchronized void reset () throws IOException { if ( this . mark_cbuf != NO_MARK ) { MST[rv.CRCR4Mutator]MSP[]
final int chunk = Math . min ( this . bbuf . remaining () , len ) ; this . bbuf . get ( b , off , chunk ) ; off += chunk ; len -= chunk ; MST[rv.AOD1Mutator]MSP[] bytesRead += chunk ; } else { fillBuffer () ;
public boolean markSupported () { return true ; MST[BooleanFalseReturnValsMutator]MSP[] }
if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) { MST[rv.ROR3Mutator]MSP[] break; } } } return bytesRead == 0 && ! this . cbuf . hasRemaining () ? EOF : bytesRead ; } @Override public int read () throws IOException {
while ( n > 0 && available () > 0 ) { this . read () ; n -- ; skipped ++ ; MST[InlineConstantMutator]MSP[] } return skipped ; } @Override public int available () throws IOException {
final int chunk = Math . min ( this . bbuf . remaining () , len ) ; this . bbuf . get ( b , off , chunk ) ; off += chunk ; len -= chunk ; MST[rv.AOR4Mutator]MSP[] bytesRead += chunk ; } else { fillBuffer () ;
while ( n > 0 && available () > 0 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] this . read () ; n -- ; skipped ++ ; } return skipped ; } @Override public int available () throws IOException {
final int chunk = Math . min ( this . bbuf . remaining () , len ) ; this . bbuf . get ( b , off , chunk ) ; off += chunk ; MST[rv.AOR2Mutator]MSP[] len -= chunk ; bytesRead += chunk ; } else { fillBuffer () ;
if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) { return EOF ; } int bytesRead = 0 ; while ( len > 0 ) { MST[rv.UOI4Mutator]MSP[] if ( this . bbuf . hasRemaining () ) {
while( this . cbuf . position () < this . mark_cbuf ) { this . bbuf . rewind () ; this . bbuf . limit ( 0 ) ; fillBuffer () ; } } if ( this . cbuf . position () != this . mark_cbuf ) { MST[rv.ABSMutator]MSP[]
final int chunk = Math . min ( this . bbuf . remaining () , len ) ; this . bbuf . get ( b , off , chunk ) ; off += chunk ; len -= chunk ; bytesRead += chunk ; MST[rv.UOI1Mutator]MSP[] } else { fillBuffer () ;
if ( this . cbuf . position () != 0 ) { MST[rv.ROR2Mutator]MSP[] this . encoder . reset () ; this . cbuf . rewind () ; this . bbuf . rewind () ; this . bbuf . limit ( 0 ) ;
while ( n > 0 && available () > 0 ) { this . read () ; n -- ; skipped ++ ; } return skipped ; MST[ReturnValsMutator]MSP[] } @Override public int available () throws IOException {
if ( len < 0 || ( off + len ) > b . length ) { MST[rv.AOD1Mutator]MSP[] throw new IndexOutOfBoundsException ( lr_2 + b . length + lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { return 0 ; }
while( this . cbuf . position () < this . mark_cbuf ) { this . bbuf . rewind () ; MST[NonVoidMethodCallMutator]MSP[] this . bbuf . limit ( 0 ) ; fillBuffer () ; } } if ( this . cbuf . position () != this . mark_cbuf ) {
if ( len < 0 || ( off + len ) > b . length ) { throw new IndexOutOfBoundsException ( lr_2 + b . length + lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { MST[rv.ABSMutator]MSP[] return 0 ; }
private void fillBuffer () throws CharacterCodingException { this . bbuf . compact () ; final CoderResult result = this . encoder . encode ( this . cbuf , this . bbuf , true ) ; if ( result . isError () ) { MST[rv.ROR1Mutator]MSP[] result . throwException () ; }
final int chunk = Math . min ( this . bbuf . remaining () , len ) ; this . bbuf . get ( b , off , chunk ) ; off += chunk ; len -= chunk ; MST[rv.UOI1Mutator]MSP[] bytesRead += chunk ; } else { fillBuffer () ;
private void fillBuffer () throws CharacterCodingException { this . bbuf . compact () ; final CoderResult result = this . encoder . encode ( this . cbuf , this . bbuf , true ) ; if ( result . isError () ) { MST[rv.ROR5Mutator]MSP[] result . throwException () ; }
private void fillBuffer () throws CharacterCodingException { this . bbuf . compact () ; final CoderResult result = this . encoder . encode ( this . cbuf , this . bbuf , true ) ; MST[InlineConstantMutator]MSP[] if ( result . isError () ) { result . throwException () ; }
final int chunk = Math . min ( this . bbuf . remaining () , len ) ; this . bbuf . get ( b , off , chunk ) ; MST[rv.UOI2Mutator]MSP[] off += chunk ; len -= chunk ; bytesRead += chunk ; } else { fillBuffer () ;
for (; ; ) { if ( this . bbuf . hasRemaining () ) { return this . bbuf . get () & 0xFF ; } fillBuffer () ; if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) { MST[rv.ROR3Mutator]MSP[]
final int chunk = Math . min ( this . bbuf . remaining () , len ) ; MST[rv.UOI4Mutator]MSP[] this . bbuf . get ( b , off , chunk ) ; off += chunk ; len -= chunk ; bytesRead += chunk ; } else { fillBuffer () ;
while( this . cbuf . position () < this . mark_cbuf ) { MST[rv.ROR2Mutator]MSP[] this . bbuf . rewind () ; this . bbuf . limit ( 0 ) ; fillBuffer () ; } } if ( this . cbuf . position () != this . mark_cbuf ) {
if ( len < 0 || ( off + len ) > b . length ) { throw new IndexOutOfBoundsException ( lr_2 + b . length + lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return 0 ; }
return EOF ; } } } @Override public int read ( final byte [] b ) throws IOException { return read ( b , 0 , b . length ) ; MST[rv.CRCR1Mutator]MSP[] } @Override public long skip ( long n ) throws IOException { long skipped = 0 ;
return EOF ; } } } @Override public int read ( final byte [] b ) throws IOException { return read ( b , 0 , b . length ) ; MST[rv.CRCR5Mutator]MSP[] } @Override public long skip ( long n ) throws IOException { long skipped = 0 ;
while ( n > 0 && available () > 0 ) { MST[rv.ROR5Mutator]MSP[] this . read () ; n -- ; skipped ++ ; } return skipped ; } @Override public int available () throws IOException {
if ( this . cbuf . position () != 0 ) { this . encoder . reset () ; this . cbuf . rewind () ; this . bbuf . rewind () ; this . bbuf . limit ( 0 ) ; MST[InlineConstantMutator]MSP[]
final int chunk = Math . min ( this . bbuf . remaining () , len ) ; this . bbuf . get ( b , off , chunk ) ; off += chunk ; len -= chunk ; bytesRead += chunk ; MST[rv.AOD2Mutator]MSP[] } else { fillBuffer () ;
while ( n > 0 && available () > 0 ) { this . read () ; n -- ; MST[MathMutator]MSP[] skipped ++ ; } return skipped ; } @Override public int available () throws IOException {
while ( n > 0 && available () > 0 ) { MST[rv.ROR1Mutator]MSP[] this . read () ; n -- ; skipped ++ ; } return skipped ; } @Override public int available () throws IOException {
if ( len < 0 || ( off + len ) > b . length ) { MST[rv.ABSMutator]MSP[] throw new IndexOutOfBoundsException ( lr_2 + b . length + lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { return 0 ; }
if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) { return EOF ; } int bytesRead = 0 ; while ( len > 0 ) { MST[rv.UOI1Mutator]MSP[] if ( this . bbuf . hasRemaining () ) {
if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) { MST[NonVoidMethodCallMutator]MSP[] break; } } } return bytesRead == 0 && ! this . cbuf . hasRemaining () ? EOF : bytesRead ; } @Override public int read () throws IOException {
return this . bbuf . remaining () + this . cbuf . remaining () ; MST[rv.AOR4Mutator]MSP[] } @Override public void close () throws IOException { } @Override public synchronized void mark ( final int readlimit ) { this . mark_cbuf = this . cbuf . position () ;
return EOF ; } } } @Override public int read ( final byte [] b ) throws IOException { return read ( b , 0 , b . length ) ; } @Override public long skip ( long n ) throws IOException { long skipped = 0 ; MST[InlineConstantMutator]MSP[]
if ( len < 0 || ( off + len ) > b . length ) { throw new IndexOutOfBoundsException ( lr_2 + b . length + lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { MST[rv.ROR3Mutator]MSP[] return 0 ; }
while ( n > 0 && available () > 0 ) { this . read () ; n -- ; MST[rv.AOR4Mutator]MSP[] skipped ++ ; } return skipped ; } @Override public int available () throws IOException {
while ( n > 0 && available () > 0 ) { MST[rv.ROR2Mutator]MSP[] this . read () ; n -- ; skipped ++ ; } return skipped ; } @Override public int available () throws IOException {
if ( len < 0 || ( off + len ) > b . length ) { throw new IndexOutOfBoundsException ( lr_2 + b . length + MST[experimental.NakedReceiverMutator]MSP[] lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { return 0 ; }
return EOF ; } } } @Override public int read ( final byte [] b ) throws IOException { return read ( b , 0 , b . length ) ; MST[PrimitiveReturnsMutator]MSP[] } @Override public long skip ( long n ) throws IOException { long skipped = 0 ;
while ( n > 0 && available () > 0 ) { this . read () ; n -- ; MST[rv.CRCR3Mutator]MSP[] skipped ++ ; } return skipped ; } @Override public int available () throws IOException {
private void fillBuffer () throws CharacterCodingException { this . bbuf . compact () ; final CoderResult result = this . encoder . encode ( this . cbuf , this . bbuf , true ) ; if ( result . isError () ) { MST[NegateConditionalsMutator]MSP[] result . throwException () ; }
final int chunk = Math . min ( this . bbuf . remaining () , len ) ; this . bbuf . get ( b , off , chunk ) ; off += chunk ; len -= chunk ; bytesRead += chunk ; MST[rv.UOI3Mutator]MSP[] } else { fillBuffer () ;
private void fillBuffer () throws CharacterCodingException { this . bbuf . compact () ; final CoderResult result = this . encoder . encode ( this . cbuf , this . bbuf , true ) ; MST[NonVoidMethodCallMutator]MSP[] if ( result . isError () ) { result . throwException () ; }
if ( len < 0 || ( off + len ) > b . length ) { throw new IndexOutOfBoundsException ( lr_2 + b . length + MST[NonVoidMethodCallMutator]MSP[] lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { return 0 ; }
if ( len < 0 || ( off + len ) > b . length ) { MST[rv.AOR3Mutator]MSP[] throw new IndexOutOfBoundsException ( lr_2 + b . length + lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { return 0 ; }
if ( len < 0 || ( off + len ) > b . length ) { throw new IndexOutOfBoundsException ( lr_2 + b . length + lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { MST[rv.UOI2Mutator]MSP[] return 0 ; }
final int chunk = Math . min ( this . bbuf . remaining () , len ) ; this . bbuf . get ( b , off , chunk ) ; off += chunk ; len -= chunk ; MST[rv.UOI1Mutator]MSP[] bytesRead += chunk ; } else { fillBuffer () ;
while ( n > 0 && available () > 0 ) { this . read () ; n -- ; skipped ++ ; MST[rv.CRCR5Mutator]MSP[] } return skipped ; } @Override public int available () throws IOException {
while ( n > 0 && available () > 0 ) { this . read () ; n -- ; skipped ++ ; } return skipped ; MST[rv.UOI2Mutator]MSP[] } @Override public int available () throws IOException {
if ( len < 0 || ( off + len ) > b . length ) { MST[rv.ROR4Mutator]MSP[] throw new IndexOutOfBoundsException ( lr_2 + b . length + lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { return 0 ; }
if ( len < 0 || ( off + len ) > b . length ) { throw new IndexOutOfBoundsException ( lr_2 + b . length + MST[rv.UOI3Mutator]MSP[] lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { return 0 ; }
return this . bbuf . remaining () + this . cbuf . remaining () ; MST[MathMutator]MSP[] } @Override public void close () throws IOException { } @Override public synchronized void mark ( final int readlimit ) { this . mark_cbuf = this . cbuf . position () ;
final int chunk = Math . min ( this . bbuf . remaining () , len ) ; this . bbuf . get ( b , off , chunk ) ; MST[rv.ABSMutator]MSP[] off += chunk ; len -= chunk ; bytesRead += chunk ; } else { fillBuffer () ;
if ( this . cbuf . position () != 0 ) { this . encoder . reset () ; MST[NonVoidMethodCallMutator]MSP[] this . cbuf . rewind () ; this . bbuf . rewind () ; this . bbuf . limit ( 0 ) ;
if ( len < 0 || ( off + len ) > b . length ) { MST[ConditionalsBoundaryMutator]MSP[] throw new IndexOutOfBoundsException ( lr_2 + b . length + lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { return 0 ; }
if ( len < 0 || ( off + len ) > b . length ) { throw new IndexOutOfBoundsException ( lr_2 + b . length + lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { return 0 ; MST[rv.CRCR3Mutator]MSP[] }
this . mark_bbuf = this . bbuf . position () ; this . cbuf . mark () ; this . bbuf . mark () ; MST[NonVoidMethodCallMutator]MSP[] } @Override public synchronized void reset () throws IOException { if ( this . mark_cbuf != NO_MARK ) {
while ( n > 0 && available () > 0 ) { this . read () ; n -- ; skipped ++ ; MST[rv.AOR1Mutator]MSP[] } return skipped ; } @Override public int available () throws IOException {
return EOF ; } } } @Override public int read ( final byte [] b ) throws IOException { return read ( b , 0 , b . length ) ; } @Override public long skip ( long n ) throws IOException { long skipped = 0 ; MST[rv.CRCR6Mutator]MSP[]
return this . bbuf . remaining () + this . cbuf . remaining () ; MST[NonVoidMethodCallMutator]MSP[] } @Override public void close () throws IOException { } @Override public synchronized void mark ( final int readlimit ) { this . mark_cbuf = this . cbuf . position () ;
if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) { MST[rv.ROR1Mutator]MSP[] break; } } } return bytesRead == 0 && ! this . cbuf . hasRemaining () ? EOF : bytesRead ; } @Override public int read () throws IOException {
if ( len < 0 || ( off + len ) > b . length ) { MST[rv.UOI2Mutator]MSP[] throw new IndexOutOfBoundsException ( lr_2 + b . length + lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { return 0 ; }
final int chunk = Math . min ( this . bbuf . remaining () , len ) ; this . bbuf . get ( b , off , chunk ) ; off += chunk ; len -= chunk ; MST[rv.AOR2Mutator]MSP[] bytesRead += chunk ; } else { fillBuffer () ;
if ( len < 0 || ( off + len ) > b . length ) { MST[rv.UOI1Mutator]MSP[] throw new IndexOutOfBoundsException ( lr_2 + b . length + lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { return 0 ; }
while ( n > 0 && available () > 0 ) { MST[NegateConditionalsMutator]MSP[] this . read () ; n -- ; skipped ++ ; } return skipped ; } @Override public int available () throws IOException {
if ( len < 0 || ( off + len ) > b . length ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[] throw new IndexOutOfBoundsException ( lr_2 + b . length + lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { return 0 ; }
if ( len < 0 || ( off + len ) > b . length ) { MST[rv.ROR2Mutator]MSP[] throw new IndexOutOfBoundsException ( lr_2 + b . length + lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { return 0 ; }
final int chunk = Math . min ( this . bbuf . remaining () , len ) ; this . bbuf . get ( b , off , chunk ) ; off += chunk ; len -= chunk ; bytesRead += chunk ; MST[rv.AOR4Mutator]MSP[] } else { fillBuffer () ;
while( this . cbuf . position () < this . mark_cbuf ) { this . bbuf . rewind () ; this . bbuf . limit ( 0 ) ; fillBuffer () ; } } if ( this . cbuf . position () != this . mark_cbuf ) { MST[NegateConditionalsMutator]MSP[]
while( this . cbuf . position () < this . mark_cbuf ) { this . bbuf . rewind () ; this . bbuf . limit ( 0 ) ; fillBuffer () ; } } if ( this . cbuf . position () != this . mark_cbuf ) { MST[rv.UOI3Mutator]MSP[]
while ( n > 0 && available () > 0 ) { this . read () ; n -- ; MST[rv.UOI3Mutator]MSP[] skipped ++ ; } return skipped ; } @Override public int available () throws IOException {
for (; ; ) { if ( this . bbuf . hasRemaining () ) { return this . bbuf . get () & 0xFF ; } fillBuffer () ; if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) { MST[NonVoidMethodCallMutator]MSP[]
if ( len < 0 || ( off + len ) > b . length ) { throw new IndexOutOfBoundsException ( lr_2 + b . length + lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { return 0 ; MST[InlineConstantMutator]MSP[] }
this . mark_bbuf = this . bbuf . position () ; this . cbuf . mark () ; this . bbuf . mark () ; } @Override public synchronized void reset () throws IOException { if ( this . mark_cbuf != NO_MARK ) { MST[NegateConditionalsMutator]MSP[]
final int chunk = Math . min ( this . bbuf . remaining () , len ) ; this . bbuf . get ( b , off , chunk ) ; off += chunk ; len -= chunk ; bytesRead += chunk ; MST[rv.UOI2Mutator]MSP[] } else { fillBuffer () ;
final int chunk = Math . min ( this . bbuf . remaining () , len ) ; this . bbuf . get ( b , off , chunk ) ; off += chunk ; MST[rv.UOI3Mutator]MSP[] len -= chunk ; bytesRead += chunk ; } else { fillBuffer () ;
final int chunk = Math . min ( this . bbuf . remaining () , len ) ; this . bbuf . get ( b , off , chunk ) ; off += chunk ; MST[rv.UOI4Mutator]MSP[] len -= chunk ; bytesRead += chunk ; } else { fillBuffer () ;
final int chunk = Math . min ( this . bbuf . remaining () , len ) ; this . bbuf . get ( b , off , chunk ) ; off += chunk ; len -= chunk ; bytesRead += chunk ; MST[MathMutator]MSP[] } else { fillBuffer () ;
throw new IllegalStateException ( lr_5 + cbuf . position () + lr_6 + lr_7 + this . mark_cbuf ) ; } this . bbuf . position ( this . mark_bbuf ) ; this . mark_cbuf = NO_MARK ; this . mark_bbuf = NO_MARK ; MST[rv.CRCR1Mutator]MSP[] } } @Override
final int chunk = Math . min ( this . bbuf . remaining () , len ) ; this . bbuf . get ( b , off , chunk ) ; off += chunk ; len -= chunk ; MST[rv.ABSMutator]MSP[] bytesRead += chunk ; } else { fillBuffer () ;
throw new IllegalStateException ( lr_5 + cbuf . position () + lr_6 + lr_7 + this . mark_cbuf ) ; } this . bbuf . position ( this . mark_bbuf ) ; this . mark_cbuf = NO_MARK ; this . mark_bbuf = NO_MARK ; MST[rv.CRCR6Mutator]MSP[] } } @Override
if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) { break; } } } return bytesRead == 0 && ! this . cbuf . hasRemaining () ? EOF : bytesRead ; MST[ReturnValsMutator]MSP[] } @Override public int read () throws IOException {
private void fillBuffer () throws CharacterCodingException { this . bbuf . compact () ; final CoderResult result = this . encoder . encode ( this . cbuf , this . bbuf , true ) ; MST[rv.CRCR2Mutator]MSP[] if ( result . isError () ) { result . throwException () ; }
if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) { break; } } } return bytesRead == 0 && ! this . cbuf . hasRemaining () ? EOF : bytesRead ; MST[rv.ROR3Mutator]MSP[] } @Override public int read () throws IOException {
return this . bbuf . remaining () + this . cbuf . remaining () ; MST[NonVoidMethodCallMutator]MSP[] } @Override public void close () throws IOException { } @Override public synchronized void mark ( final int readlimit ) { this . mark_cbuf = this . cbuf . position () ;
final int chunk = Math . min ( this . bbuf . remaining () , len ) ; this . bbuf . get ( b , off , chunk ) ; off += chunk ; MST[rv.AOR1Mutator]MSP[] len -= chunk ; bytesRead += chunk ; } else { fillBuffer () ;
if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) { break; } } } return bytesRead == 0 && ! this . cbuf . hasRemaining () ? EOF : bytesRead ; MST[rv.UOI1Mutator]MSP[] } @Override public int read () throws IOException {
for (; ; ) { if ( this . bbuf . hasRemaining () ) { return this . bbuf . get () & 0xFF ; MST[rv.OBBN1Mutator]MSP[] } fillBuffer () ; if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) {
if ( len < 0 || ( off + len ) > b . length ) { MST[rv.ROR3Mutator]MSP[] throw new IndexOutOfBoundsException ( lr_2 + b . length + lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { return 0 ; }
if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) { break; } } } return bytesRead == 0 && ! this . cbuf . hasRemaining () ? EOF : bytesRead ; MST[rv.ABSMutator]MSP[] } @Override public int read () throws IOException {
if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] break; } } } return bytesRead == 0 && ! this . cbuf . hasRemaining () ? EOF : bytesRead ; } @Override public int read () throws IOException {
public boolean markSupported () { return true ; MST[ReturnValsMutator]MSP[] }
while ( n > 0 && available () > 0 ) { MST[rv.UOI4Mutator]MSP[] this . read () ; n -- ; skipped ++ ; } return skipped ; } @Override public int available () throws IOException {
return EOF ; } } } @Override public int read ( final byte [] b ) throws IOException { return read ( b , 0 , b . length ) ; MST[NonVoidMethodCallMutator]MSP[] } @Override public long skip ( long n ) throws IOException { long skipped = 0 ;
if ( this . cbuf . position () != 0 ) { MST[rv.ROR1Mutator]MSP[] this . encoder . reset () ; this . cbuf . rewind () ; this . bbuf . rewind () ; this . bbuf . limit ( 0 ) ;
if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) { MST[rv.ROR2Mutator]MSP[] return EOF ; } int bytesRead = 0 ; while ( len > 0 ) { if ( this . bbuf . hasRemaining () ) {
while( this . cbuf . position () < this . mark_cbuf ) { this . bbuf . rewind () ; this . bbuf . limit ( 0 ) ; fillBuffer () ; } } if ( this . cbuf . position () != this . mark_cbuf ) { MST[rv.ROR5Mutator]MSP[]
this . mark_bbuf = this . bbuf . position () ; this . cbuf . mark () ; this . bbuf . mark () ; } @Override public synchronized void reset () throws IOException { if ( this . mark_cbuf != NO_MARK ) { MST[InlineConstantMutator]MSP[]
throw new IllegalStateException ( lr_5 + cbuf . position () + lr_6 + lr_7 + this . mark_cbuf ) ; } this . bbuf . position ( this . mark_bbuf ) ; this . mark_cbuf = NO_MARK ; MST[rv.CRCR4Mutator]MSP[] this . mark_bbuf = NO_MARK ; } } @Override
if ( this . cbuf . position () != 0 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] this . encoder . reset () ; this . cbuf . rewind () ; this . bbuf . rewind () ; this . bbuf . limit ( 0 ) ;
throw new IllegalStateException ( lr_5 + cbuf . position () + lr_6 + lr_7 + this . mark_cbuf ) ; } this . bbuf . position ( this . mark_bbuf ) ; this . mark_cbuf = NO_MARK ; this . mark_bbuf = NO_MARK ; MST[experimental.MemberVariableMutator]MSP[] } } @Override
if ( this . cbuf . position () != 0 ) { this . encoder . reset () ; MST[experimental.NakedReceiverMutator]MSP[] this . cbuf . rewind () ; this . bbuf . rewind () ; this . bbuf . limit ( 0 ) ;
if ( len < 0 || ( off + len ) > b . length ) { throw new IndexOutOfBoundsException ( lr_2 + b . length + MST[rv.UOI4Mutator]MSP[] lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { return 0 ; }
if ( len < 0 || ( off + len ) > b . length ) { throw new IndexOutOfBoundsException ( lr_2 + b . length + MST[NonVoidMethodCallMutator]MSP[] lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { return 0 ; }
if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return EOF ; } int bytesRead = 0 ; while ( len > 0 ) { if ( this . bbuf . hasRemaining () ) {
final int chunk = Math . min ( this . bbuf . remaining () , len ) ; this . bbuf . get ( b , off , chunk ) ; off += chunk ; MST[rv.UOI4Mutator]MSP[] len -= chunk ; bytesRead += chunk ; } else { fillBuffer () ;
if ( len < 0 || ( off + len ) > b . length ) { throw new IndexOutOfBoundsException ( lr_2 + b . length + lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { MST[rv.UOI1Mutator]MSP[] return 0 ; }
final int chunk = Math . min ( this . bbuf . remaining () , len ) ; this . bbuf . get ( b , off , chunk ) ; MST[NonVoidMethodCallMutator]MSP[] off += chunk ; len -= chunk ; bytesRead += chunk ; } else { fillBuffer () ;
while ( n > 0 && available () > 0 ) { this . read () ; n -- ; skipped ++ ; } return skipped ; MST[rv.UOI3Mutator]MSP[] } @Override public int available () throws IOException {
final int chunk = Math . min ( this . bbuf . remaining () , len ) ; this . bbuf . get ( b , off , chunk ) ; MST[rv.UOI2Mutator]MSP[] off += chunk ; len -= chunk ; bytesRead += chunk ; } else { fillBuffer () ;
while ( n > 0 && available () > 0 ) { MST[rv.CRCR3Mutator]MSP[] this . read () ; n -- ; skipped ++ ; } return skipped ; } @Override public int available () throws IOException {
throw new IllegalStateException ( lr_5 + cbuf . position () + lr_6 + lr_7 + this . mark_cbuf ) ; } this . bbuf . position ( this . mark_bbuf ) ; MST[rv.ABSMutator]MSP[] this . mark_cbuf = NO_MARK ; this . mark_bbuf = NO_MARK ; } } @Override
if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) { break; } } } return bytesRead == 0 && ! this . cbuf . hasRemaining () ? EOF : bytesRead ; MST[rv.UOI4Mutator]MSP[] } @Override public int read () throws IOException {
while( this . cbuf . position () < this . mark_cbuf ) { MST[rv.UOI4Mutator]MSP[] this . bbuf . rewind () ; this . bbuf . limit ( 0 ) ; fillBuffer () ; } } if ( this . cbuf . position () != this . mark_cbuf ) {
public boolean markSupported () { return true ; MST[rv.CRCR5Mutator]MSP[] }
for (; ; ) { if ( this . bbuf . hasRemaining () ) { return this . bbuf . get () & 0xFF ; MST[InlineConstantMutator]MSP[] } fillBuffer () ; if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) {
while ( n > 0 && available () > 0 ) { this . read () ; n -- ; skipped ++ ; } return skipped ; MST[PrimitiveReturnsMutator]MSP[] } @Override public int available () throws IOException {
while ( n > 0 && available () > 0 ) { MST[rv.ROR2Mutator]MSP[] this . read () ; n -- ; skipped ++ ; } return skipped ; } @Override public int available () throws IOException {
for (; ; ) { if ( this . bbuf . hasRemaining () ) { MST[rv.ROR2Mutator]MSP[] return this . bbuf . get () & 0xFF ; } fillBuffer () ; if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) {
if ( len < 0 || ( off + len ) > b . length ) { MST[rv.ABSMutator]MSP[] throw new IndexOutOfBoundsException ( lr_2 + b . length + lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { return 0 ; }
if ( len < 0 || ( off + len ) > b . length ) { MST[rv.UOI1Mutator]MSP[] throw new IndexOutOfBoundsException ( lr_2 + b . length + lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { return 0 ; }
for (; ; ) { if ( this . bbuf . hasRemaining () ) { return this . bbuf . get () & 0xFF ; MST[MathMutator]MSP[] } fillBuffer () ; if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) {
if ( len < 0 || ( off + len ) > b . length ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] throw new IndexOutOfBoundsException ( lr_2 + b . length + lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { return 0 ; }
while ( n > 0 && available () > 0 ) { this . read () ; MST[NonVoidMethodCallMutator]MSP[] n -- ; skipped ++ ; } return skipped ; } @Override public int available () throws IOException {
if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) { break; } } } return bytesRead == 0 && ! this . cbuf . hasRemaining () ? EOF : bytesRead ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] } @Override public int read () throws IOException {
return this . bbuf . remaining () + this . cbuf . remaining () ; MST[rv.AOD2Mutator]MSP[] } @Override public void close () throws IOException { } @Override public synchronized void mark ( final int readlimit ) { this . mark_cbuf = this . cbuf . position () ;
if ( len < 0 || ( off + len ) > b . length ) { throw new IndexOutOfBoundsException ( lr_2 + b . length + MST[experimental.NakedReceiverMutator]MSP[] lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { return 0 ; }
if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) { MST[rv.ROR3Mutator]MSP[] return EOF ; } int bytesRead = 0 ; while ( len > 0 ) { if ( this . bbuf . hasRemaining () ) {
this . mark_bbuf = this . bbuf . position () ; this . cbuf . mark () ; this . bbuf . mark () ; } @Override public synchronized void reset () throws IOException { if ( this . mark_cbuf != NO_MARK ) { MST[rv.ROR4Mutator]MSP[]
for (; ; ) { if ( this . bbuf . hasRemaining () ) { return this . bbuf . get () & 0xFF ; MST[rv.CRCR3Mutator]MSP[] } fillBuffer () ; if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) {
final int chunk = Math . min ( this . bbuf . remaining () , len ) ; this . bbuf . get ( b , off , chunk ) ; off += chunk ; len -= chunk ; MST[rv.UOI2Mutator]MSP[] bytesRead += chunk ; } else { fillBuffer () ;
if ( len < 0 || ( off + len ) > b . length ) { throw new IndexOutOfBoundsException ( lr_2 + b . length + MST[rv.ABSMutator]MSP[] lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { return 0 ; }
for (; ; ) { if ( this . bbuf . hasRemaining () ) { return this . bbuf . get () & 0xFF ; } fillBuffer () ; if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) { MST[rv.ROR1Mutator]MSP[]
if ( len < 0 || ( off + len ) > b . length ) { throw new IndexOutOfBoundsException ( lr_2 + b . length + MST[NonVoidMethodCallMutator]MSP[] lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { return 0 ; }
private void fillBuffer () throws CharacterCodingException { this . bbuf . compact () ; final CoderResult result = this . encoder . encode ( this . cbuf , this . bbuf , true ) ; if ( result . isError () ) { MST[rv.ROR2Mutator]MSP[] result . throwException () ; }
if ( len < 0 || ( off + len ) > b . length ) { throw new IndexOutOfBoundsException ( lr_2 + b . length + lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { MST[rv.ROR4Mutator]MSP[] return 0 ; }
private void fillBuffer () throws CharacterCodingException { this . bbuf . compact () ; final CoderResult result = this . encoder . encode ( this . cbuf , this . bbuf , true ) ; if ( result . isError () ) { MST[rv.ROR4Mutator]MSP[] result . throwException () ; }
return this . bbuf . remaining () + this . cbuf . remaining () ; } @Override public void close () throws IOException { } @Override public synchronized void mark ( final int readlimit ) { this . mark_cbuf = this . cbuf . position () ; MST[NonVoidMethodCallMutator]MSP[]
final int chunk = Math . min ( this . bbuf . remaining () , len ) ; MST[rv.UOI1Mutator]MSP[] this . bbuf . get ( b , off , chunk ) ; off += chunk ; len -= chunk ; bytesRead += chunk ; } else { fillBuffer () ;
final int chunk = Math . min ( this . bbuf . remaining () , len ) ; this . bbuf . get ( b , off , chunk ) ; MST[rv.UOI3Mutator]MSP[] off += chunk ; len -= chunk ; bytesRead += chunk ; } else { fillBuffer () ;
while( this . cbuf . position () < this . mark_cbuf ) { MST[rv.ROR5Mutator]MSP[] this . bbuf . rewind () ; this . bbuf . limit ( 0 ) ; fillBuffer () ; } } if ( this . cbuf . position () != this . mark_cbuf ) {
while( this . cbuf . position () < this . mark_cbuf ) { this . bbuf . rewind () ; this . bbuf . limit ( 0 ) ; MST[rv.CRCR3Mutator]MSP[] fillBuffer () ; } } if ( this . cbuf . position () != this . mark_cbuf ) {
if ( len < 0 || ( off + len ) > b . length ) { throw new IndexOutOfBoundsException ( lr_2 + b . length + lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { return 0 ; MST[rv.CRCR6Mutator]MSP[] }
while( this . cbuf . position () < this . mark_cbuf ) { MST[rv.ABSMutator]MSP[] this . bbuf . rewind () ; this . bbuf . limit ( 0 ) ; fillBuffer () ; } } if ( this . cbuf . position () != this . mark_cbuf ) {
final int chunk = Math . min ( this . bbuf . remaining () , len ) ; this . bbuf . get ( b , off , chunk ) ; off += chunk ; MST[rv.AOD2Mutator]MSP[] len -= chunk ; bytesRead += chunk ; } else { fillBuffer () ;
this . bbuf . flip () ; } @Override public int read ( final byte [] b , int off , int len ) throws IOException { if ( b == null ) { throw new NullPointerException ( lr_1 ) ; MST[ConstructorCallMutator]MSP[] }
if ( len < 0 || ( off + len ) > b . length ) { MST[rv.UOI2Mutator]MSP[] throw new IndexOutOfBoundsException ( lr_2 + b . length + lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { return 0 ; }
if ( len < 0 || ( off + len ) > b . length ) { MST[rv.UOI3Mutator]MSP[] throw new IndexOutOfBoundsException ( lr_2 + b . length + lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { return 0 ; }
if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) { MST[NonVoidMethodCallMutator]MSP[] return EOF ; } int bytesRead = 0 ; while ( len > 0 ) { if ( this . bbuf . hasRemaining () ) {
if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) { return EOF ; } int bytesRead = 0 ; MST[rv.CRCR5Mutator]MSP[] while ( len > 0 ) { if ( this . bbuf . hasRemaining () ) {
final int chunk = Math . min ( this . bbuf . remaining () , len ) ; this . bbuf . get ( b , off , chunk ) ; off += chunk ; len -= chunk ; MST[rv.AOR1Mutator]MSP[] bytesRead += chunk ; } else { fillBuffer () ;
this . mark_bbuf = this . bbuf . position () ; this . cbuf . mark () ; this . bbuf . mark () ; } @Override public synchronized void reset () throws IOException { if ( this . mark_cbuf != NO_MARK ) { MST[rv.ROR3Mutator]MSP[]
if ( this . cbuf . position () != 0 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] this . encoder . reset () ; this . cbuf . rewind () ; this . bbuf . rewind () ; this . bbuf . limit ( 0 ) ;
if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) { MST[NegateConditionalsMutator]MSP[] return EOF ; } int bytesRead = 0 ; while ( len > 0 ) { if ( this . bbuf . hasRemaining () ) {
while ( n > 0 && available () > 0 ) { this . read () ; n -- ; MST[rv.UOI2Mutator]MSP[] skipped ++ ; } return skipped ; } @Override public int available () throws IOException {
for (; ; ) { if ( this . bbuf . hasRemaining () ) { return this . bbuf . get () & 0xFF ; MST[rv.CRCR4Mutator]MSP[] } fillBuffer () ; if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) {
return this . bbuf . remaining () + this . cbuf . remaining () ; MST[rv.AOD1Mutator]MSP[] } @Override public void close () throws IOException { } @Override public synchronized void mark ( final int readlimit ) { this . mark_cbuf = this . cbuf . position () ;
if ( len < 0 || ( off + len ) > b . length ) { throw new IndexOutOfBoundsException ( lr_2 + b . length + lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { MST[rv.UOI3Mutator]MSP[] return 0 ; }
this . mark_bbuf = this . bbuf . position () ; this . cbuf . mark () ; this . bbuf . mark () ; } @Override public synchronized void reset () throws IOException { if ( this . mark_cbuf != NO_MARK ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
if ( len < 0 || ( off + len ) > b . length ) { MST[rv.ROR1Mutator]MSP[] throw new IndexOutOfBoundsException ( lr_2 + b . length + lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { return 0 ; }
return EOF ; } } } @Override public int read ( final byte [] b ) throws IOException { return read ( b , 0 , b . length ) ; MST[ReturnValsMutator]MSP[] } @Override public long skip ( long n ) throws IOException { long skipped = 0 ;
while ( n > 0 && available () > 0 ) { this . read () ; n -- ; skipped ++ ; } return skipped ; MST[rv.UOI1Mutator]MSP[] } @Override public int available () throws IOException {
while ( n > 0 && available () > 0 ) { MST[rv.CRCR5Mutator]MSP[] this . read () ; n -- ; skipped ++ ; } return skipped ; } @Override public int available () throws IOException {
return EOF ; } } } @Override public int read ( final byte [] b ) throws IOException { return read ( b , 0 , b . length ) ; } @Override public long skip ( long n ) throws IOException { long skipped = 0 ; MST[rv.CRCR3Mutator]MSP[]
while( this . cbuf . position () < this . mark_cbuf ) { MST[rv.UOI2Mutator]MSP[] this . bbuf . rewind () ; this . bbuf . limit ( 0 ) ; fillBuffer () ; } } if ( this . cbuf . position () != this . mark_cbuf ) {
if ( len < 0 || ( off + len ) > b . length ) { MST[rv.ROR5Mutator]MSP[] throw new IndexOutOfBoundsException ( lr_2 + b . length + lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { return 0 ; }
this . mark_bbuf = this . bbuf . position () ; this . cbuf . mark () ; this . bbuf . mark () ; } @Override public synchronized void reset () throws IOException { if ( this . mark_cbuf != NO_MARK ) { MST[rv.CRCR6Mutator]MSP[]
if ( len < 0 || ( off + len ) > b . length ) { MST[MathMutator]MSP[] throw new IndexOutOfBoundsException ( lr_2 + b . length + lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { return 0 ; }
while ( n > 0 && available () > 0 ) { MST[ConditionalsBoundaryMutator]MSP[] this . read () ; n -- ; skipped ++ ; } return skipped ; } @Override public int available () throws IOException {
if ( len < 0 || ( off + len ) > b . length ) { MST[rv.UOI3Mutator]MSP[] throw new IndexOutOfBoundsException ( lr_2 + b . length + lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { return 0 ; }
this . mark_bbuf = this . bbuf . position () ; this . cbuf . mark () ; this . bbuf . mark () ; } @Override public synchronized void reset () throws IOException { if ( this . mark_cbuf != NO_MARK ) { MST[rv.CRCR2Mutator]MSP[]
while ( n > 0 && available () > 0 ) { this . read () ; n -- ; MST[InlineConstantMutator]MSP[] skipped ++ ; } return skipped ; } @Override public int available () throws IOException {
final int chunk = Math . min ( this . bbuf . remaining () , len ) ; this . bbuf . get ( b , off , chunk ) ; off += chunk ; MST[rv.AOR4Mutator]MSP[] len -= chunk ; bytesRead += chunk ; } else { fillBuffer () ;
return EOF ; } } } @Override public int read ( final byte [] b ) throws IOException { return read ( b , 0 , b . length ) ; MST[InlineConstantMutator]MSP[] } @Override public long skip ( long n ) throws IOException { long skipped = 0 ;
if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) { MST[rv.ROR1Mutator]MSP[] break; } } } return bytesRead == 0 && ! this . cbuf . hasRemaining () ? EOF : bytesRead ; } @Override public int read () throws IOException {
final int chunk = Math . min ( this . bbuf . remaining () , len ) ; this . bbuf . get ( b , off , chunk ) ; off += chunk ; len -= chunk ; bytesRead += chunk ; MST[rv.AOD1Mutator]MSP[] } else { fillBuffer () ;
if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) { return EOF ; } int bytesRead = 0 ; while ( len > 0 ) { MST[rv.UOI2Mutator]MSP[] if ( this . bbuf . hasRemaining () ) {
while ( n > 0 && available () > 0 ) { this . read () ; n -- ; MST[rv.AOR3Mutator]MSP[] skipped ++ ; } return skipped ; } @Override public int available () throws IOException {
while( this . cbuf . position () < this . mark_cbuf ) { this . bbuf . rewind () ; this . bbuf . limit ( 0 ) ; fillBuffer () ; } } if ( this . cbuf . position () != this . mark_cbuf ) { MST[rv.ROR4Mutator]MSP[]
return this . bbuf . remaining () + this . cbuf . remaining () ; MST[rv.AOR3Mutator]MSP[] } @Override public void close () throws IOException { } @Override public synchronized void mark ( final int readlimit ) { this . mark_cbuf = this . cbuf . position () ;
while ( n > 0 && available () > 0 ) { MST[rv.ROR1Mutator]MSP[] this . read () ; n -- ; skipped ++ ; } return skipped ; } @Override public int available () throws IOException {
while ( n > 0 && available () > 0 ) { this . read () ; n -- ; skipped ++ ; MST[rv.ABSMutator]MSP[] } return skipped ; } @Override public int available () throws IOException {
if ( this . cbuf . position () != 0 ) { MST[NegateConditionalsMutator]MSP[] this . encoder . reset () ; this . cbuf . rewind () ; this . bbuf . rewind () ; this . bbuf . limit ( 0 ) ;
if ( this . cbuf . position () != 0 ) { this . encoder . reset () ; this . cbuf . rewind () ; this . bbuf . rewind () ; this . bbuf . limit ( 0 ) ; MST[rv.CRCR1Mutator]MSP[]
final int chunk = Math . min ( this . bbuf . remaining () , len ) ; this . bbuf . get ( b , off , chunk ) ; MST[rv.ABSMutator]MSP[] off += chunk ; len -= chunk ; bytesRead += chunk ; } else { fillBuffer () ;
if ( len < 0 || ( off + len ) > b . length ) { throw new IndexOutOfBoundsException ( lr_2 + b . length + MST[ConstructorCallMutator]MSP[] lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { return 0 ; }
this . bbuf . flip () ; } @Override public int read ( final byte [] b , int off , int len ) throws IOException { if ( b == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] throw new NullPointerException ( lr_1 ) ; }
final int chunk = Math . min ( this . bbuf . remaining () , len ) ; this . bbuf . get ( b , off , chunk ) ; off += chunk ; len -= chunk ; bytesRead += chunk ; MST[rv.UOI3Mutator]MSP[] } else { fillBuffer () ;
for (; ; ) { if ( this . bbuf . hasRemaining () ) { return this . bbuf . get () & 0xFF ; MST[PrimitiveReturnsMutator]MSP[] } fillBuffer () ; if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) {
throw new IllegalStateException ( lr_5 + cbuf . position () + lr_6 + lr_7 + this . mark_cbuf ) ; } this . bbuf . position ( this . mark_bbuf ) ; this . mark_cbuf = NO_MARK ; MST[experimental.MemberVariableMutator]MSP[] this . mark_bbuf = NO_MARK ; } } @Override
final int chunk = Math . min ( this . bbuf . remaining () , len ) ; this . bbuf . get ( b , off , chunk ) ; off += chunk ; len -= chunk ; bytesRead += chunk ; MST[rv.UOI4Mutator]MSP[] } else { fillBuffer () ;
private void fillBuffer () throws CharacterCodingException { this . bbuf . compact () ; final CoderResult result = this . encoder . encode ( this . cbuf , this . bbuf , true ) ; MST[rv.CRCR6Mutator]MSP[] if ( result . isError () ) { result . throwException () ; }
for (; ; ) { if ( this . bbuf . hasRemaining () ) { return this . bbuf . get () & 0xFF ; } fillBuffer () ; if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) { MST[NonVoidMethodCallMutator]MSP[]
while( this . cbuf . position () < this . mark_cbuf ) { this . bbuf . rewind () ; this . bbuf . limit ( 0 ) ; MST[InlineConstantMutator]MSP[] fillBuffer () ; } } if ( this . cbuf . position () != this . mark_cbuf ) {
private void fillBuffer () throws CharacterCodingException { this . bbuf . compact () ; final CoderResult result = this . encoder . encode ( this . cbuf , this . bbuf , true ) ; MST[rv.CRCR5Mutator]MSP[] if ( result . isError () ) { result . throwException () ; }
throw new IllegalStateException ( lr_5 + cbuf . position () + lr_6 + lr_7 + this . mark_cbuf ) ; } this . bbuf . position ( this . mark_bbuf ) ; this . mark_cbuf = NO_MARK ; this . mark_bbuf = NO_MARK ; MST[rv.CRCR4Mutator]MSP[] } } @Override
throw new IllegalStateException ( lr_5 + cbuf . position () + lr_6 + lr_7 + this . mark_cbuf ) ; } this . bbuf . position ( this . mark_bbuf ) ; this . mark_cbuf = NO_MARK ; this . mark_bbuf = NO_MARK ; MST[rv.CRCR5Mutator]MSP[] } } @Override
if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) { return EOF ; MST[rv.CRCR4Mutator]MSP[] } int bytesRead = 0 ; while ( len > 0 ) { if ( this . bbuf . hasRemaining () ) {
if ( this . cbuf . position () != 0 ) { this . encoder . reset () ; this . cbuf . rewind () ; this . bbuf . rewind () ; MST[NonVoidMethodCallMutator]MSP[] this . bbuf . limit ( 0 ) ;
public boolean markSupported () { return true ; MST[rv.CRCR6Mutator]MSP[] }
for (; ; ) { if ( this . bbuf . hasRemaining () ) { MST[rv.ROR3Mutator]MSP[] return this . bbuf . get () & 0xFF ; } fillBuffer () ; if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) {
while ( n > 0 && available () > 0 ) { this . read () ; n -- ; skipped ++ ; MST[rv.UOI4Mutator]MSP[] } return skipped ; } @Override public int available () throws IOException {
if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) { break; } } } return bytesRead == 0 && ! this . cbuf . hasRemaining () ? EOF : bytesRead ; MST[rv.ROR4Mutator]MSP[] } @Override public int read () throws IOException {
if ( len < 0 || ( off + len ) > b . length ) { MST[rv.UOI2Mutator]MSP[] throw new IndexOutOfBoundsException ( lr_2 + b . length + lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { return 0 ; }
while( this . cbuf . position () < this . mark_cbuf ) { this . bbuf . rewind () ; this . bbuf . limit ( 0 ) ; fillBuffer () ; } } if ( this . cbuf . position () != this . mark_cbuf ) { MST[rv.ROR3Mutator]MSP[]
return EOF ; } } } @Override public int read ( final byte [] b ) throws IOException { return read ( b , 0 , b . length ) ; MST[ArgumentPropagationMutator]MSP[] } @Override public long skip ( long n ) throws IOException { long skipped = 0 ;
final int chunk = Math . min ( this . bbuf . remaining () , len ) ; this . bbuf . get ( b , off , chunk ) ; off += chunk ; len -= chunk ; bytesRead += chunk ; MST[rv.ABSMutator]MSP[] } else { fillBuffer () ;
if ( this . cbuf . position () != 0 ) { MST[rv.ROR5Mutator]MSP[] this . encoder . reset () ; this . cbuf . rewind () ; this . bbuf . rewind () ; this . bbuf . limit ( 0 ) ;
while ( n > 0 && available () > 0 ) { this . read () ; n -- ; skipped ++ ; MST[rv.AOR4Mutator]MSP[] } return skipped ; } @Override public int available () throws IOException {
final int chunk = Math . min ( this . bbuf . remaining () , len ) ; this . bbuf . get ( b , off , chunk ) ; off += chunk ; len -= chunk ; bytesRead += chunk ; MST[rv.AOR3Mutator]MSP[] } else { fillBuffer () ;
if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) { MST[rv.ROR4Mutator]MSP[] return EOF ; } int bytesRead = 0 ; while ( len > 0 ) { if ( this . bbuf . hasRemaining () ) {
this . bbuf . flip () ; } @Override public int read ( final byte [] b , int off , int len ) throws IOException { if ( b == null ) { MST[rv.ROR5Mutator]MSP[] throw new NullPointerException ( lr_1 ) ; }
while ( n > 0 && available () > 0 ) { this . read () ; n -- ; skipped ++ ; MST[rv.AOD1Mutator]MSP[] } return skipped ; } @Override public int available () throws IOException {
while ( n > 0 && available () > 0 ) { this . read () ; n -- ; skipped ++ ; MST[rv.CRCR6Mutator]MSP[] } return skipped ; } @Override public int available () throws IOException {
final int chunk = Math . min ( this . bbuf . remaining () , len ) ; this . bbuf . get ( b , off , chunk ) ; off += chunk ; len -= chunk ; MST[rv.UOI2Mutator]MSP[] bytesRead += chunk ; } else { fillBuffer () ;
while( this . cbuf . position () < this . mark_cbuf ) { this . bbuf . rewind () ; this . bbuf . limit ( 0 ) ; fillBuffer () ; } } if ( this . cbuf . position () != this . mark_cbuf ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
final int chunk = Math . min ( this . bbuf . remaining () , len ) ; this . bbuf . get ( b , off , chunk ) ; off += chunk ; len -= chunk ; bytesRead += chunk ; MST[rv.UOI4Mutator]MSP[] } else { fillBuffer () ;
while ( n > 0 && available () > 0 ) { this . read () ; n -- ; MST[rv.CRCR4Mutator]MSP[] skipped ++ ; } return skipped ; } @Override public int available () throws IOException {
if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return EOF ; } int bytesRead = 0 ; while ( len > 0 ) { if ( this . bbuf . hasRemaining () ) {
if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) { return EOF ; } int bytesRead = 0 ; MST[rv.CRCR1Mutator]MSP[] while ( len > 0 ) { if ( this . bbuf . hasRemaining () ) {
return this . bbuf . remaining () + this . cbuf . remaining () ; } @Override public void close () throws IOException { } @Override public synchronized void mark ( final int readlimit ) { this . mark_cbuf = this . cbuf . position () ; MST[experimental.MemberVariableMutator]MSP[]
if ( len < 0 || ( off + len ) > b . length ) { MST[rv.AOR2Mutator]MSP[] throw new IndexOutOfBoundsException ( lr_2 + b . length + lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { return 0 ; }
if ( len < 0 || ( off + len ) > b . length ) { throw new IndexOutOfBoundsException ( lr_2 + b . length + MST[rv.UOI4Mutator]MSP[] lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { return 0 ; }
final int chunk = Math . min ( this . bbuf . remaining () , len ) ; this . bbuf . get ( b , off , chunk ) ; MST[rv.UOI3Mutator]MSP[] off += chunk ; len -= chunk ; bytesRead += chunk ; } else { fillBuffer () ;
if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) { break; } } } return bytesRead == 0 && ! this . cbuf . hasRemaining () ? EOF : bytesRead ; MST[rv.UOI2Mutator]MSP[] } @Override public int read () throws IOException {
if ( len < 0 || ( off + len ) > b . length ) { MST[NegateConditionalsMutator]MSP[] throw new IndexOutOfBoundsException ( lr_2 + b . length + lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { return 0 ; }
while ( n > 0 && available () > 0 ) { MST[rv.UOI3Mutator]MSP[] this . read () ; n -- ; skipped ++ ; } return skipped ; } @Override public int available () throws IOException {
if ( this . cbuf . position () != 0 ) { MST[NonVoidMethodCallMutator]MSP[] this . encoder . reset () ; this . cbuf . rewind () ; this . bbuf . rewind () ; this . bbuf . limit ( 0 ) ;
if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) { return EOF ; } int bytesRead = 0 ; MST[rv.CRCR6Mutator]MSP[] while ( len > 0 ) { if ( this . bbuf . hasRemaining () ) {
if ( len < 0 || ( off + len ) > b . length ) { MST[rv.ROR4Mutator]MSP[] throw new IndexOutOfBoundsException ( lr_2 + b . length + lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { return 0 ; }
final int chunk = Math . min ( this . bbuf . remaining () , len ) ; this . bbuf . get ( b , off , chunk ) ; off += chunk ; len -= chunk ; bytesRead += chunk ; MST[rv.ABSMutator]MSP[] } else { fillBuffer () ;
for (; ; ) { if ( this . bbuf . hasRemaining () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return this . bbuf . get () & 0xFF ; } fillBuffer () ; if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) {
final int chunk = Math . min ( this . bbuf . remaining () , len ) ; this . bbuf . get ( b , off , chunk ) ; off += chunk ; len -= chunk ; MST[MathMutator]MSP[] bytesRead += chunk ; } else { fillBuffer () ;
if ( len < 0 || ( off + len ) > b . length ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[] throw new IndexOutOfBoundsException ( lr_2 + b . length + lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { return 0 ; }
private void fillBuffer () throws CharacterCodingException { this . bbuf . compact () ; final CoderResult result = this . encoder . encode ( this . cbuf , this . bbuf , true ) ; if ( result . isError () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] result . throwException () ; }
if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) { MST[rv.ROR3Mutator]MSP[] return EOF ; } int bytesRead = 0 ; while ( len > 0 ) { if ( this . bbuf . hasRemaining () ) {
throw new IllegalStateException ( lr_5 + cbuf . position () + lr_6 + lr_7 + this . mark_cbuf ) ; } this . bbuf . position ( this . mark_bbuf ) ; this . mark_cbuf = NO_MARK ; MST[InlineConstantMutator]MSP[] this . mark_bbuf = NO_MARK ; } } @Override
return this . bbuf . remaining () + this . cbuf . remaining () ; MST[ReturnValsMutator]MSP[] } @Override public void close () throws IOException { } @Override public synchronized void mark ( final int readlimit ) { this . mark_cbuf = this . cbuf . position () ;
if ( this . cbuf . position () != 0 ) { this . encoder . reset () ; this . cbuf . rewind () ; this . bbuf . rewind () ; this . bbuf . limit ( 0 ) ; MST[rv.CRCR6Mutator]MSP[]
while( this . cbuf . position () < this . mark_cbuf ) { this . bbuf . rewind () ; this . bbuf . limit ( 0 ) ; fillBuffer () ; } } if ( this . cbuf . position () != this . mark_cbuf ) { MST[rv.UOI1Mutator]MSP[]
