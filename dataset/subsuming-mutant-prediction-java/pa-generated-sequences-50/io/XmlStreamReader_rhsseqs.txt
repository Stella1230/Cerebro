if ( appXml ) { return calculateRawEncoding ( bomEnc , xmlGuessEnc , xmlEnc ) ; MST[ArgumentPropagationMutator]MSP[N] } return defaultEncoding == null ? US_ASCII : defaultEncoding ; } if ( cTEnc . equals ( UTF_16BE ) || cTEnc . equals ( UTF_16LE ) ) { if ( bomEnc != null ) {
String calculateHttpEncoding ( final String httpContentType , final String bomEnc , final String xmlGuessEnc , final String xmlEnc , final boolean lenient ) throws IOException { if ( lenient && xmlEnc != null ) { MST[rv.UOI3Mutator]MSP[N] return xmlEnc ; } final String cTMime = getContentTypeMime ( httpContentType ) ;
mime . equals ( lr_9 ) || MST[NegateConditionalsMutator]MSP[N] mime . equals ( lr_10 ) || mime . startsWith ( lr_11 ) && mime . endsWith ( lr_12 ) ) ; } static boolean isTextXml ( final String mime ) { return mime != null &&
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { offset += c ; MST[rv.ABSMutator]MSP[N] max -= c ; c = is . read ( bytes , offset , max ) ;
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR6Mutator]MSP[N] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
final String postMime = httpContentType . substring ( i + 1 ) ; final Matcher m = CHARSET_PATTERN . matcher ( postMime ) ; encoding = m . find () ? m . group ( 1 ) : null ; MST[rv.ROR2Mutator]MSP[S]
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { offset += c ; max -= c ; MST[rv.AOR4Mutator]MSP[N] c = is . read ( bytes , offset , max ) ;
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } if ( bomEnc . equals ( UTF_16BE ) || bomEnc . equals ( UTF_16LE ) ) { if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( bomEnc ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR3Mutator]MSP[N] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( xmlEnc != null && ! xmlEnc . equals ( UTF_8 ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[InlineConstantMutator]MSP[N]
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_32 ) && ! xmlEnc . equals ( bomEnc ) ) { MST[rv.ROR5Mutator]MSP[N] final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
final String postMime = httpContentType . substring ( i + 1 ) ; MST[experimental.NakedReceiverMutator]MSP[N] final Matcher m = CHARSET_PATTERN . matcher ( postMime ) ; encoding = m . find () ? m . group ( 1 ) : null ;
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } if ( bomEnc . equals ( UTF_16BE ) || bomEnc . equals ( UTF_16LE ) ) { MST[NonVoidMethodCallMutator]MSP[N] if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( bomEnc ) ) {
encoding = encoding . substring ( 1 , encoding . length () - 1 ) ; MST[MathMutator]MSP[N] } } } return encoding ; } static boolean isAppXml ( final String mime ) { return mime != null && ( mime . equals ( lr_8 ) ||
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( xmlEnc != null && ! xmlEnc . equals ( UTF_8 ) ) { MST[NegateConditionalsMutator]MSP[N] final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } if ( bomEnc . equals ( UTF_16BE ) || bomEnc . equals ( UTF_16LE ) ) { if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( bomEnc ) ) { MST[rv.ROR3Mutator]MSP[S]
final int i = httpContentType . indexOf ( lr_3 ) ; if ( i >= 0 ) { mime = httpContentType . substring ( 0 , i ) ; MST[NonVoidMethodCallMutator]MSP[N] } else { mime = httpContentType ; } mime = mime . trim () ; } return mime ; }
throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[ConstructorCallMutator]MSP[N] } return cTEnc ; } static String getContentTypeMime ( final String httpContentType ) { String mime = null ; if ( httpContentType != null ) {
xmlProlog = new String ( bytes , 0 , offset , guessedEnc ) ; firstGT = xmlProlog . indexOf ( '>' ) ; } if ( firstGT == - 1 ) { MST[rv.UOI3Mutator]MSP[N] if ( c == - 1 ) { throw new IOException ( lr_5 ) ; }
throw new IOException ( lr_6 + offset + lr_7 ) ; } final int bytesRead = offset ; if ( bytesRead > 0 ) { is . reset () ; final BufferedReader bReader = new BufferedReader ( new StringReader ( MST[rv.AOR1Mutator]MSP[N]
final int i = httpContentType . indexOf ( lr_3 ) ; if ( i >= 0 ) { mime = httpContentType . substring ( 0 , i ) ; } else { mime = httpContentType ; } mime = mime . trim () ; } return mime ; MST[EmptyObjectReturnValsMutator]MSP[N] }
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { MST[rv.CRCR4Mutator]MSP[N] offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ;
} return xmlEnc ; } if ( bomEnc . equals ( UTF_8 ) ) { if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( UTF_8 ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[InlineConstantMutator]MSP[S]
encoding = encoding . substring ( 1 , encoding . length () - 1 ) ; } } } return encoding ; } static boolean isAppXml ( final String mime ) { return mime != null && ( mime . equals ( lr_8 ) || MST[NonVoidMethodCallMutator]MSP[N]
final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR2Mutator]MSP[S] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
final String msg = MessageFormat . format ( HTTP_EX_3 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR4Mutator]MSP[N] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( cTEnc == null ) {
String calculateHttpEncoding ( final String httpContentType , final String bomEnc , final String xmlGuessEnc , final String xmlEnc , final boolean lenient ) throws IOException { if ( lenient && xmlEnc != null ) { MST[rv.ROR4Mutator]MSP[N] return xmlEnc ; } final String cTMime = getContentTypeMime ( httpContentType ) ;
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } if ( bomEnc . equals ( UTF_16BE ) || bomEnc . equals ( UTF_16LE ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( bomEnc ) ) {
throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( cTEnc . equals ( UTF_32BE ) || cTEnc . equals ( UTF_32LE ) ) { MST[rv.ROR1Mutator]MSP[N] if ( bomEnc != null ) {
if ( cTEnc . equals ( UTF_16 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_16 ) ) { MST[rv.ROR4Mutator]MSP[N] return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ;
if ( cTEnc . equals ( UTF_32 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_32 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR6Mutator]MSP[N]
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( xmlEnc != null && ! xmlEnc . equals ( UTF_8 ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR6Mutator]MSP[N]
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR6Mutator]MSP[N] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR5Mutator]MSP[S] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } final String msg = MessageFormat . format ( RAW_EX_2 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR2Mutator]MSP[S] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
if ( xmlGuessEnc == null || xmlEnc == null ) { return defaultEncoding == null ? UTF_8 : defaultEncoding ; } if ( xmlEnc . equals ( UTF_16 ) && ( xmlGuessEnc . equals ( UTF_16BE ) || xmlGuessEnc . equals ( UTF_16LE ) ) ) { MST[rv.ROR1Mutator]MSP[S] return xmlGuessEnc ;
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } final String msg = MessageFormat . format ( RAW_EX_2 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR3Mutator]MSP[S] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
final int i = httpContentType . indexOf ( lr_3 ) ; if ( i >= 0 ) { mime = httpContentType . substring ( 0 , i ) ; MST[rv.CRCR6Mutator]MSP[N] } else { mime = httpContentType ; } mime = mime . trim () ; } return mime ; }
if ( guessedEnc != null ) { final byte [] bytes = new byte [ BUFFER_SIZE ] ; is . mark ( BUFFER_SIZE ) ; int offset = 0 ; int max = BUFFER_SIZE ; int c = is . read ( bytes , offset , max ) ; MST[rv.UOI3Mutator]MSP[N]
if ( appXml ) { MST[rv.ROR4Mutator]MSP[N] return calculateRawEncoding ( bomEnc , xmlGuessEnc , xmlEnc ) ; } return defaultEncoding == null ? US_ASCII : defaultEncoding ; } if ( cTEnc . equals ( UTF_16BE ) || cTEnc . equals ( UTF_16LE ) ) { if ( bomEnc != null ) {
( mime . equals ( lr_2 ) || mime . equals ( lr_13 ) || MST[rv.ROR4Mutator]MSP[N] mime . startsWith ( lr_14 ) && mime . endsWith ( lr_12 ) ) ; }
if ( appXml ) { MST[rv.UOI3Mutator]MSP[N] return calculateRawEncoding ( bomEnc , xmlGuessEnc , xmlEnc ) ; } return defaultEncoding == null ? US_ASCII : defaultEncoding ; } if ( cTEnc . equals ( UTF_16BE ) || cTEnc . equals ( UTF_16LE ) ) { if ( bomEnc != null ) {
( mime . equals ( lr_2 ) || MST[rv.ROR2Mutator]MSP[N] mime . equals ( lr_13 ) || mime . startsWith ( lr_14 ) && mime . endsWith ( lr_12 ) ) ; }
final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR3Mutator]MSP[S] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } if ( bomEnc . equals ( UTF_32BE ) || bomEnc . equals ( UTF_32LE ) ) { MST[NegateConditionalsMutator]MSP[N] if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( bomEnc ) ) {
final String msg = MessageFormat . format ( HTTP_EX_3 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[InlineConstantMutator]MSP[S] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( cTEnc == null ) {
if ( guessedEnc != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] final byte [] bytes = new byte [ BUFFER_SIZE ] ; is . mark ( BUFFER_SIZE ) ; int offset = 0 ; int max = BUFFER_SIZE ; int c = is . read ( bytes , offset , max ) ;
if ( appXml ) { return calculateRawEncoding ( bomEnc , xmlGuessEnc , xmlEnc ) ; } return defaultEncoding == null ? US_ASCII : defaultEncoding ; } if ( cTEnc . equals ( UTF_16BE ) || cTEnc . equals ( UTF_16LE ) ) { MST[rv.ROR1Mutator]MSP[N] if ( bomEnc != null ) {
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( xmlEnc != null && ! xmlEnc . equals ( UTF_8 ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR4Mutator]MSP[N]
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( xmlEnc != null && ! xmlEnc . equals ( UTF_8 ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR1Mutator]MSP[N]
final String bomEnc = bom . getBOMCharsetName () ; final String xmlGuessEnc = pis . getBOMCharsetName () ; final String xmlEnc = getXmlProlog ( pis , xmlGuessEnc ) ; try { return calculateHttpEncoding ( httpContentType , bomEnc , MST[EmptyObjectReturnValsMutator]MSP[N] xmlGuessEnc , xmlEnc , lenient ) ;
if ( appXml ) { return calculateRawEncoding ( bomEnc , xmlGuessEnc , xmlEnc ) ; } return defaultEncoding == null ? US_ASCII : defaultEncoding ; } if ( cTEnc . equals ( UTF_16BE ) || cTEnc . equals ( UTF_16LE ) ) { MST[rv.ROR4Mutator]MSP[S] if ( bomEnc != null ) {
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_32 ) && ! xmlEnc . equals ( bomEnc ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[InlineConstantMutator]MSP[S]
mime . equals ( lr_9 ) || mime . equals ( lr_10 ) || mime . startsWith ( lr_11 ) && mime . endsWith ( lr_12 ) ) ; MST[rv.CRCR4Mutator]MSP[S] } static boolean isTextXml ( final String mime ) { return mime != null &&
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } final String msg = MessageFormat . format ( RAW_EX_2 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR5Mutator]MSP[S] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
final String postMime = httpContentType . substring ( i + 1 ) ; MST[InlineConstantMutator]MSP[S] final Matcher m = CHARSET_PATTERN . matcher ( postMime ) ; encoding = m . find () ? m . group ( 1 ) : null ;
if ( encoding == null ) { encoding = defaultEncoding == null ? UTF_8 : defaultEncoding ; } return encoding ; MST[EmptyObjectReturnValsMutator]MSP[N] } String calculateRawEncoding ( final String bomEnc , final String xmlGuessEnc , final String xmlEnc ) throws IOException { if ( bomEnc == null ) {
final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[NonVoidMethodCallMutator]MSP[S] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
final String cTEnc = getContentTypeEncoding ( httpContentType ) ; final boolean appXml = isAppXml ( cTMime ) ; final boolean textXml = isTextXml ( cTMime ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( ! appXml && ! textXml ) {
if ( cTEnc . equals ( UTF_16 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_16 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR6Mutator]MSP[N]
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } final String msg = MessageFormat . format ( RAW_EX_2 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR6Mutator]MSP[S] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
final String cTEnc = getContentTypeEncoding ( httpContentType ) ; final boolean appXml = isAppXml ( cTMime ) ; final boolean textXml = isTextXml ( cTMime ) ; if ( ! appXml && ! textXml ) { MST[NegateConditionalsMutator]MSP[N]
return reader . read ( buf , offset , len ) ; MST[rv.UOI3Mutator]MSP[N] } @Override public void close () throws IOException { reader . close () ; } private String doRawStream ( final BOMInputStream bom , final BOMInputStream pis , final boolean lenient ) throws IOException {
int firstGT = - 1 ; MST[rv.CRCR1Mutator]MSP[N] String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ;
final String bomEnc = bom . getBOMCharsetName () ; final String xmlGuessEnc = pis . getBOMCharsetName () ; final String xmlEnc = getXmlProlog ( pis , xmlGuessEnc ) ; try { return calculateRawEncoding ( bomEnc , xmlGuessEnc , xmlEnc ) ; MST[EmptyObjectReturnValsMutator]MSP[N] } catch ( final XmlStreamReaderException ex ) {
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ; MST[ArgumentPropagationMutator]MSP[N]
if ( xmlGuessEnc == null || xmlEnc == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return defaultEncoding == null ? UTF_8 : defaultEncoding ; } if ( xmlEnc . equals ( UTF_16 ) && ( xmlGuessEnc . equals ( UTF_16BE ) || xmlGuessEnc . equals ( UTF_16LE ) ) ) { return xmlGuessEnc ;
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( xmlEnc != null && ! xmlEnc . equals ( UTF_8 ) ) { MST[rv.ROR2Mutator]MSP[N] final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
( mime . equals ( lr_2 ) || mime . equals ( lr_13 ) || mime . startsWith ( lr_14 ) && mime . endsWith ( lr_12 ) ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] }
if ( guessedEnc != null ) { final byte [] bytes = new byte [ BUFFER_SIZE ] ; is . mark ( BUFFER_SIZE ) ; MST[rv.CRCR3Mutator]MSP[N] int offset = 0 ; int max = BUFFER_SIZE ; int c = is . read ( bytes , offset , max ) ;
if ( cTEnc . equals ( UTF_16 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_16 ) ) { MST[rv.ROR1Mutator]MSP[S] return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ;
String calculateHttpEncoding ( final String httpContentType , final String bomEnc , final String xmlGuessEnc , final String xmlEnc , final boolean lenient ) throws IOException { if ( lenient && xmlEnc != null ) { MST[rv.ROR1Mutator]MSP[N] return xmlEnc ; } final String cTMime = getContentTypeMime ( httpContentType ) ;
mime . equals ( lr_9 ) || mime . equals ( lr_10 ) || mime . startsWith ( lr_11 ) && mime . endsWith ( lr_12 ) ) ; } static boolean isTextXml ( final String mime ) { return mime != null && MST[BooleanTrueReturnValsMutator]MSP[N]
int firstGT = - 1 ; MST[rv.CRCR4Mutator]MSP[N] String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ;
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { offset += c ; max -= c ; MST[rv.UOI4Mutator]MSP[N] c = is . read ( bytes , offset , max ) ;
final String postMime = httpContentType . substring ( i + 1 ) ; MST[rv.UOI2Mutator]MSP[S] final Matcher m = CHARSET_PATTERN . matcher ( postMime ) ; encoding = m . find () ? m . group ( 1 ) : null ;
mime . equals ( lr_9 ) || mime . equals ( lr_10 ) || mime . startsWith ( lr_11 ) && mime . endsWith ( lr_12 ) ) ; } static boolean isTextXml ( final String mime ) { return mime != null && MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( cTEnc . equals ( UTF_32BE ) || cTEnc . equals ( UTF_32LE ) ) { MST[rv.ROR4Mutator]MSP[N] if ( bomEnc != null ) {
if ( cTEnc . equals ( UTF_32 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_32 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR3Mutator]MSP[N]
if ( guessedEnc != null ) { final byte [] bytes = new byte [ BUFFER_SIZE ] ; is . mark ( BUFFER_SIZE ) ; int offset = 0 ; int max = BUFFER_SIZE ; MST[InlineConstantMutator]MSP[N] int c = is . read ( bytes , offset , max ) ;
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { offset += c ; MST[rv.UOI2Mutator]MSP[N] max -= c ; c = is . read ( bytes , offset , max ) ;
if ( httpContentType != null && httpContentType . startsWith ( lr_1 ) ) { httpContentType = httpContentType . substring ( lr_1 . length () ) ; httpContentType = lr_2 + httpContentType ; try { return calculateHttpEncoding ( httpContentType , ex . getBomEncoding () , MST[EmptyObjectReturnValsMutator]MSP[S]
final int i = httpContentType . indexOf ( lr_3 ) ; if ( i >= 0 ) { MST[rv.UOI1Mutator]MSP[N] mime = httpContentType . substring ( 0 , i ) ; } else { mime = httpContentType ; } mime = mime . trim () ; } return mime ; }
final int i = httpContentType . indexOf ( lr_3 ) ; if ( i >= 0 ) { MST[rv.UOI4Mutator]MSP[N] mime = httpContentType . substring ( 0 , i ) ; } else { mime = httpContentType ; } mime = mime . trim () ; } return mime ; }
xmlProlog = new String ( bytes , 0 , offset , guessedEnc ) ; MST[rv.UOI4Mutator]MSP[N] firstGT = xmlProlog . indexOf ( '>' ) ; } if ( firstGT == - 1 ) { if ( c == - 1 ) { throw new IOException ( lr_5 ) ; }
} final Matcher m = ENCODING_PATTERN . matcher ( prolog ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( m . find () ) { encoding = m . group ( 1 ) . toUpperCase ( Locale . ROOT ) ;
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ; MST[rv.UOI1Mutator]MSP[N]
final int i = httpContentType . indexOf ( lr_3 ) ; if ( i >= 0 ) { mime = httpContentType . substring ( 0 , i ) ; MST[rv.UOI3Mutator]MSP[N] } else { mime = httpContentType ; } mime = mime . trim () ; } return mime ; }
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( xmlEnc != null && ! xmlEnc . equals ( UTF_8 ) ) { MST[rv.ROR5Mutator]MSP[N] final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
xmlProlog = new String ( bytes , 0 , offset , guessedEnc ) ; firstGT = xmlProlog . indexOf ( '>' ) ; } if ( firstGT == - 1 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] if ( c == - 1 ) { throw new IOException ( lr_5 ) ; }
final String cTEnc = getContentTypeEncoding ( httpContentType ) ; final boolean appXml = isAppXml ( cTMime ) ; final boolean textXml = isTextXml ( cTMime ) ; if ( ! appXml && ! textXml ) { MST[rv.UOI4Mutator]MSP[N]
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_32 ) && ! xmlEnc . equals ( bomEnc ) ) { MST[NegateConditionalsMutator]MSP[N] final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
final String cTEnc = getContentTypeEncoding ( httpContentType ) ; final boolean appXml = isAppXml ( cTMime ) ; final boolean textXml = isTextXml ( cTMime ) ; if ( ! appXml && ! textXml ) { MST[rv.ROR3Mutator]MSP[S]
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_16 ) && ! xmlEnc . equals ( bomEnc ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
final String msg = MessageFormat . format ( HTTP_EX_3 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR1Mutator]MSP[S] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( cTEnc == null ) {
throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; } static String getContentTypeMime ( final String httpContentType ) { String mime = null ; if ( httpContentType != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR6Mutator]MSP[N] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
public String getDefaultEncoding () { return defaultEncoding ; MST[ReturnValsMutator]MSP[N] } public String getEncoding () { return encoding ; } @Override public int read ( final char [] buf , final int offset , final int len ) throws IOException {
if ( xmlGuessEnc == null || xmlEnc == null ) { return defaultEncoding == null ? UTF_8 : defaultEncoding ; MST[NegateConditionalsMutator]MSP[N] } if ( xmlEnc . equals ( UTF_16 ) && ( xmlGuessEnc . equals ( UTF_16BE ) || xmlGuessEnc . equals ( UTF_16LE ) ) ) { return xmlGuessEnc ;
final int i = httpContentType . indexOf ( lr_3 ) ; if ( i >= 0 ) { mime = httpContentType . substring ( 0 , i ) ; MST[rv.CRCR3Mutator]MSP[N] } else { mime = httpContentType ; } mime = mime . trim () ; } return mime ; }
final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR4Mutator]MSP[S] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR3Mutator]MSP[N] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_32 ) && ! xmlEnc . equals ( bomEnc ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR6Mutator]MSP[N]
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR1Mutator]MSP[N] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } if ( bomEnc . equals ( UTF_16BE ) || bomEnc . equals ( UTF_16LE ) ) { if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( bomEnc ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( xmlEnc != null && ! xmlEnc . equals ( UTF_8 ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[InlineConstantMutator]MSP[N]
final int i = httpContentType . indexOf ( lr_3 ) ; if ( i >= 0 ) { mime = httpContentType . substring ( 0 , i ) ; } else { mime = httpContentType ; } mime = mime . trim () ; MST[experimental.NakedReceiverMutator]MSP[S] } return mime ; }
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_32 ) && ! xmlEnc . equals ( bomEnc ) ) { MST[rv.ROR5Mutator]MSP[N] final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[ConstructorCallMutator]MSP[N] } return cTEnc ; }
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } if ( bomEnc . equals ( UTF_16BE ) || bomEnc . equals ( UTF_16LE ) ) { MST[NonVoidMethodCallMutator]MSP[N] if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( bomEnc ) ) {
if ( httpContentType != null && httpContentType . startsWith ( lr_1 ) ) { httpContentType = httpContentType . substring ( lr_1 . length () ) ; httpContentType = lr_2 + httpContentType ; MST[NonVoidMethodCallMutator]MSP[S] try { return calculateHttpEncoding ( httpContentType , ex . getBomEncoding () ,
static String getContentTypeEncoding ( final String httpContentType ) { String encoding = null ; if ( httpContentType != null ) { final int i = httpContentType . indexOf ( lr_3 ) ; if ( i > - 1 ) { MST[rv.UOI3Mutator]MSP[N]
final String cTEnc = getContentTypeEncoding ( httpContentType ) ; final boolean appXml = isAppXml ( cTMime ) ; final boolean textXml = isTextXml ( cTMime ) ; if ( ! appXml && ! textXml ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
} final Matcher m = ENCODING_PATTERN . matcher ( prolog ) ; if ( m . find () ) { encoding = m . group ( 1 ) . toUpperCase ( Locale . ROOT ) ; MST[NonVoidMethodCallMutator]MSP[N]
} return xmlEnc ; } if ( bomEnc . equals ( UTF_8 ) ) { MST[rv.ROR1Mutator]MSP[N] if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( UTF_8 ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
} return xmlEnc ; } if ( bomEnc . equals ( UTF_8 ) ) { if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( UTF_8 ) ) { MST[rv.ROR5Mutator]MSP[N] final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
xmlProlog = new String ( bytes , 0 , offset , guessedEnc ) ; firstGT = xmlProlog . indexOf ( '>' ) ; MST[rv.CRCR4Mutator]MSP[N] } if ( firstGT == - 1 ) { if ( c == - 1 ) { throw new IOException ( lr_5 ) ; }
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } if ( bomEnc . equals ( UTF_16BE ) || bomEnc . equals ( UTF_16LE ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( bomEnc ) ) {
if ( cTEnc . equals ( UTF_32 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_32 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR6Mutator]MSP[N]
final String msg = MessageFormat . format ( HTTP_EX_3 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR4Mutator]MSP[N] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( cTEnc == null ) {
static String getContentTypeEncoding ( final String httpContentType ) { String encoding = null ; if ( httpContentType != null ) { final int i = httpContentType . indexOf ( lr_3 ) ; if ( i > - 1 ) { MST[rv.CRCR5Mutator]MSP[S]
throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( cTEnc . equals ( UTF_32BE ) || cTEnc . equals ( UTF_32LE ) ) { MST[rv.ROR1Mutator]MSP[N] if ( bomEnc != null ) {
final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR5Mutator]MSP[S] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
if ( cTEnc . equals ( UTF_16 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_16 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR1Mutator]MSP[N]
xmlProlog = new String ( bytes , 0 , offset , guessedEnc ) ; MST[ConstructorCallMutator]MSP[N] firstGT = xmlProlog . indexOf ( '>' ) ; } if ( firstGT == - 1 ) { if ( c == - 1 ) { throw new IOException ( lr_5 ) ; }
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR6Mutator]MSP[N] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } if ( bomEnc . equals ( UTF_16BE ) || bomEnc . equals ( UTF_16LE ) ) { MST[rv.ROR3Mutator]MSP[S] if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( bomEnc ) ) {
throw new IOException ( lr_6 + offset + lr_7 ) ; } final int bytesRead = offset ; if ( bytesRead > 0 ) { is . reset () ; final BufferedReader bReader = new BufferedReader ( new StringReader ( MST[rv.CRCR3Mutator]MSP[N]
} return xmlEnc ; } if ( bomEnc . equals ( UTF_8 ) ) { if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( UTF_8 ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR4Mutator]MSP[S]
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } final String msg = MessageFormat . format ( RAW_EX_2 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR3Mutator]MSP[S] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
if ( cTEnc . equals ( UTF_16 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_16 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR3Mutator]MSP[N]
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { MST[rv.CRCR1Mutator]MSP[N] offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ;
throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[ConstructorCallMutator]MSP[N] } if ( cTEnc . equals ( UTF_32BE ) || cTEnc . equals ( UTF_32LE ) ) { if ( bomEnc != null ) {
} return xmlEnc ; } if ( bomEnc . equals ( UTF_8 ) ) { if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( UTF_8 ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[NonVoidMethodCallMutator]MSP[N]
if ( xmlGuessEnc == null || xmlEnc == null ) { return defaultEncoding == null ? UTF_8 : defaultEncoding ; } if ( xmlEnc . equals ( UTF_16 ) && ( xmlGuessEnc . equals ( UTF_16BE ) || xmlGuessEnc . equals ( UTF_16LE ) ) ) { MST[rv.ROR1Mutator]MSP[S] return xmlGuessEnc ;
if ( appXml ) { return calculateRawEncoding ( bomEnc , xmlGuessEnc , xmlEnc ) ; } return defaultEncoding == null ? US_ASCII : defaultEncoding ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] } if ( cTEnc . equals ( UTF_16BE ) || cTEnc . equals ( UTF_16LE ) ) { if ( bomEnc != null ) {
} return xmlEnc ; } if ( bomEnc . equals ( UTF_8 ) ) { if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( UTF_8 ) ) { MST[NegateConditionalsMutator]MSP[N] final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR2Mutator]MSP[S] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
} return xmlEnc ; MST[EmptyObjectReturnValsMutator]MSP[N] } if ( bomEnc . equals ( UTF_8 ) ) { if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( UTF_8 ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } if ( bomEnc . equals ( UTF_32BE ) || bomEnc . equals ( UTF_32LE ) ) { MST[NegateConditionalsMutator]MSP[N] if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( bomEnc ) ) {
final String msg = MessageFormat . format ( HTTP_EX_3 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[InlineConstantMutator]MSP[S] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( cTEnc == null ) {
final String msg = MessageFormat . format ( HTTP_EX_3 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR6Mutator]MSP[N] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( cTEnc == null ) {
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { MST[rv.CRCR2Mutator]MSP[N] offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ;
ex . getXmlGuessEncoding () , ex . getXmlEncoding () , true ) ; MST[rv.CRCR4Mutator]MSP[N] } catch ( final XmlStreamReaderException ex2 ) { ex = ex2 ; } } String encoding = ex . getXmlEncoding () ; if ( encoding == null ) { encoding = ex . getContentTypeEncoding () ; }
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; MST[ReturnValsMutator]MSP[N] } if ( bomEnc . equals ( UTF_32BE ) || bomEnc . equals ( UTF_32LE ) ) { if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( bomEnc ) ) {
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( xmlEnc != null && ! xmlEnc . equals ( UTF_8 ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR4Mutator]MSP[N]
final String bomEnc = bom . getBOMCharsetName () ; final String xmlGuessEnc = pis . getBOMCharsetName () ; final String xmlEnc = getXmlProlog ( pis , xmlGuessEnc ) ; try { return calculateHttpEncoding ( httpContentType , bomEnc , MST[rv.UOI4Mutator]MSP[N] xmlGuessEnc , xmlEnc , lenient ) ;
} return xmlEnc ; } if ( bomEnc . equals ( UTF_8 ) ) { if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( UTF_8 ) ) { MST[NegateConditionalsMutator]MSP[N] final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
if ( appXml ) { return calculateRawEncoding ( bomEnc , xmlGuessEnc , xmlEnc ) ; } return defaultEncoding == null ? US_ASCII : defaultEncoding ; } if ( cTEnc . equals ( UTF_16BE ) || cTEnc . equals ( UTF_16LE ) ) { MST[rv.ROR4Mutator]MSP[N] if ( bomEnc != null ) {
mime . equals ( lr_9 ) || mime . equals ( lr_10 ) || mime . startsWith ( lr_11 ) && mime . endsWith ( lr_12 ) ) ; MST[rv.CRCR1Mutator]MSP[N] } static boolean isTextXml ( final String mime ) { return mime != null &&
if ( cTEnc . equals ( UTF_16 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_16 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR6Mutator]MSP[N]
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { offset += c ; MST[rv.UOI3Mutator]MSP[N] max -= c ; c = is . read ( bytes , offset , max ) ;
if ( cTEnc . equals ( UTF_32 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_32 ) ) { MST[rv.ROR1Mutator]MSP[S] return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ;
if ( httpContentType != null && httpContentType . startsWith ( lr_1 ) ) { MST[rv.ROR1Mutator]MSP[N] httpContentType = httpContentType . substring ( lr_1 . length () ) ; httpContentType = lr_2 + httpContentType ; try { return calculateHttpEncoding ( httpContentType , ex . getBomEncoding () ,
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_32 ) && ! xmlEnc . equals ( bomEnc ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[InlineConstantMutator]MSP[S]
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR3Mutator]MSP[N] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
final String postMime = httpContentType . substring ( i + 1 ) ; MST[rv.AOR1Mutator]MSP[S] final Matcher m = CHARSET_PATTERN . matcher ( postMime ) ; encoding = m . find () ? m . group ( 1 ) : null ;
final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[InlineConstantMutator]MSP[S] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } if ( bomEnc . equals ( UTF_32BE ) || bomEnc . equals ( UTF_32LE ) ) { MST[rv.ROR5Mutator]MSP[N] if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( bomEnc ) ) {
encoding = encoding . substring ( 1 , encoding . length () - 1 ) ; } } } return encoding ; } static boolean isAppXml ( final String mime ) { return mime != null && ( mime . equals ( lr_8 ) || MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
} return xmlEnc ; } if ( bomEnc . equals ( UTF_8 ) ) { if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( UTF_8 ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[InlineConstantMutator]MSP[S]
( mime . equals ( lr_2 ) || mime . equals ( lr_13 ) || mime . startsWith ( lr_14 ) && mime . endsWith ( lr_12 ) ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] }
if ( guessedEnc != null ) { final byte [] bytes = new byte [ BUFFER_SIZE ] ; is . mark ( BUFFER_SIZE ) ; int offset = 0 ; MST[rv.CRCR3Mutator]MSP[N] int max = BUFFER_SIZE ; int c = is . read ( bytes , offset , max ) ;
xmlProlog = new String ( bytes , 0 , offset , guessedEnc ) ; MST[rv.CRCR1Mutator]MSP[N] firstGT = xmlProlog . indexOf ( '>' ) ; } if ( firstGT == - 1 ) { if ( c == - 1 ) { throw new IOException ( lr_5 ) ; }
mime . equals ( lr_9 ) || MST[rv.ROR5Mutator]MSP[N] mime . equals ( lr_10 ) || mime . startsWith ( lr_11 ) && mime . endsWith ( lr_12 ) ) ; } static boolean isTextXml ( final String mime ) { return mime != null &&
encoding = encoding . substring ( 1 , encoding . length () - 1 ) ; } } } return encoding ; } static boolean isAppXml ( final String mime ) { return mime != null && ( mime . equals ( lr_8 ) || MST[rv.ROR3Mutator]MSP[S]
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_32 ) && ! xmlEnc . equals ( bomEnc ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR4Mutator]MSP[N]
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { MST[rv.ROR2Mutator]MSP[N] offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ;
} final Matcher m = ENCODING_PATTERN . matcher ( prolog ) ; if ( m . find () ) { encoding = m . group ( 1 ) . toUpperCase ( Locale . ROOT ) ; MST[rv.CRCR3Mutator]MSP[N]
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { offset += c ; max -= c ; MST[rv.AOD2Mutator]MSP[N] c = is . read ( bytes , offset , max ) ;
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_16 ) && ! xmlEnc . equals ( bomEnc ) ) { MST[NonVoidMethodCallMutator]MSP[N] final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
if ( cTEnc . equals ( UTF_32 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_32 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR3Mutator]MSP[N]
final int i = httpContentType . indexOf ( lr_3 ) ; if ( i >= 0 ) { MST[rv.ROR2Mutator]MSP[N] mime = httpContentType . substring ( 0 , i ) ; } else { mime = httpContentType ; } mime = mime . trim () ; } return mime ; }
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_16 ) && ! xmlEnc . equals ( bomEnc ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR1Mutator]MSP[N]
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( xmlEnc != null && ! xmlEnc . equals ( UTF_8 ) ) { MST[rv.ROR5Mutator]MSP[N] final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
final String cTEnc = getContentTypeEncoding ( httpContentType ) ; final boolean appXml = isAppXml ( cTMime ) ; final boolean textXml = isTextXml ( cTMime ) ; if ( ! appXml && ! textXml ) { MST[rv.ROR5Mutator]MSP[N]
if ( cTEnc . equals ( UTF_32 ) ) { MST[rv.ROR4Mutator]MSP[N] if ( bomEnc != null && bomEnc . startsWith ( UTF_32 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ;
if ( guessedEnc != null ) { final byte [] bytes = new byte [ BUFFER_SIZE ] ; is . mark ( BUFFER_SIZE ) ; int offset = 0 ; MST[InlineConstantMutator]MSP[N] int max = BUFFER_SIZE ; int c = is . read ( bytes , offset , max ) ;
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_32 ) && ! xmlEnc . equals ( bomEnc ) ) { MST[NegateConditionalsMutator]MSP[N] final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ; MST[rv.UOI2Mutator]MSP[N]
} final Matcher m = ENCODING_PATTERN . matcher ( prolog ) ; if ( m . find () ) { encoding = m . group ( 1 ) . toUpperCase ( Locale . ROOT ) ; MST[InlineConstantMutator]MSP[N]
final String cTEnc = getContentTypeEncoding ( httpContentType ) ; final boolean appXml = isAppXml ( cTMime ) ; final boolean textXml = isTextXml ( cTMime ) ; if ( ! appXml && ! textXml ) { MST[rv.UOI2Mutator]MSP[N]
final String msg = MessageFormat . format ( HTTP_EX_3 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR1Mutator]MSP[S] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( cTEnc == null ) {
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_16 ) && ! xmlEnc . equals ( bomEnc ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { MST[rv.CRCR6Mutator]MSP[N] offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ;
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_32 ) && ! xmlEnc . equals ( bomEnc ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[NonVoidMethodCallMutator]MSP[N]
String calculateHttpEncoding ( final String httpContentType , final String bomEnc , final String xmlGuessEnc , final String xmlEnc , final boolean lenient ) throws IOException { if ( lenient && xmlEnc != null ) { return xmlEnc ; MST[EmptyObjectReturnValsMutator]MSP[N] } final String cTMime = getContentTypeMime ( httpContentType ) ;
xmlProlog . substring ( 0 , firstGT + 1 ) ) ) ; final StringBuffer prolog = new StringBuffer () ; String line = bReader . readLine () ; while ( line != null ) { MST[NegateConditionalsMutator]MSP[N] prolog . append ( line ) ; line = bReader . readLine () ;
final String bomEnc = bom . getBOMCharsetName () ; final String xmlGuessEnc = pis . getBOMCharsetName () ; final String xmlEnc = getXmlProlog ( pis , xmlGuessEnc ) ; try { return calculateRawEncoding ( bomEnc , xmlGuessEnc , xmlEnc ) ; MST[ReturnValsMutator]MSP[N] } catch ( final XmlStreamReaderException ex ) {
if ( cTEnc . equals ( UTF_32 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_32 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR1Mutator]MSP[N]
} catch ( final XmlStreamReaderException ex ) { if ( lenient ) { MST[rv.UOI3Mutator]MSP[N] return doLenientDetection ( httpContentType , ex ) ; } throw ex ; } } private String doLenientDetection ( String httpContentType , XmlStreamReaderException ex ) throws IOException {
if ( httpContentType != null && httpContentType . startsWith ( lr_1 ) ) { MST[NegateConditionalsMutator]MSP[N] httpContentType = httpContentType . substring ( lr_1 . length () ) ; httpContentType = lr_2 + httpContentType ; try { return calculateHttpEncoding ( httpContentType , ex . getBomEncoding () ,
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR6Mutator]MSP[N] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; MST[EmptyObjectReturnValsMutator]MSP[S] } static String getContentTypeMime ( final String httpContentType ) { String mime = null ; if ( httpContentType != null ) {
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR4Mutator]MSP[N] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( xmlEnc != null && ! xmlEnc . equals ( UTF_8 ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[InlineConstantMutator]MSP[N]
final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR1Mutator]MSP[S] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_32 ) && ! xmlEnc . equals ( bomEnc ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR3Mutator]MSP[N]
xmlProlog . substring ( 0 , firstGT + 1 ) ) ) ; final StringBuffer prolog = new StringBuffer () ; String line = bReader . readLine () ; while ( line != null ) { prolog . append ( line ) ; line = bReader . readLine () ; MST[NonVoidMethodCallMutator]MSP[S]
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { offset += c ; max -= c ; MST[rv.UOI1Mutator]MSP[N] c = is . read ( bytes , offset , max ) ;
mime . equals ( lr_9 ) || mime . equals ( lr_10 ) || mime . startsWith ( lr_11 ) && mime . endsWith ( lr_12 ) ) ; } static boolean isTextXml ( final String mime ) { return mime != null && MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
String calculateHttpEncoding ( final String httpContentType , final String bomEnc , final String xmlGuessEnc , final String xmlEnc , final boolean lenient ) throws IOException { if ( lenient && xmlEnc != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return xmlEnc ; } final String cTMime = getContentTypeMime ( httpContentType ) ;
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_32 ) && ! xmlEnc . equals ( bomEnc ) ) { MST[rv.ROR5Mutator]MSP[N] final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
( mime . equals ( lr_2 ) || mime . equals ( lr_13 ) || mime . startsWith ( lr_14 ) && mime . endsWith ( lr_12 ) ) ; MST[rv.ROR3Mutator]MSP[S] }
if ( cTEnc . equals ( UTF_32 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_32 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[NonVoidMethodCallMutator]MSP[N]
throw new IOException ( lr_6 + offset + lr_7 ) ; } final int bytesRead = offset ; if ( bytesRead > 0 ) { is . reset () ; final BufferedReader bReader = new BufferedReader ( new StringReader ( MST[rv.ABSMutator]MSP[N]
encoding = encoding . substring ( 1 , encoding . length () - 1 ) ; MST[rv.AOR2Mutator]MSP[N] } } } return encoding ; } static boolean isAppXml ( final String mime ) { return mime != null && ( mime . equals ( lr_8 ) ||
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } if ( bomEnc . equals ( UTF_32BE ) || bomEnc . equals ( UTF_32LE ) ) { if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( bomEnc ) ) { MST[NegateConditionalsMutator]MSP[N]
} return xmlEnc ; } if ( bomEnc . equals ( UTF_8 ) ) { if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( UTF_8 ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR1Mutator]MSP[S]
( mime . equals ( lr_2 ) || mime . equals ( lr_13 ) || mime . startsWith ( lr_14 ) && mime . endsWith ( lr_12 ) ) ; MST[rv.CRCR5Mutator]MSP[N] }
static String getContentTypeEncoding ( final String httpContentType ) { String encoding = null ; if ( httpContentType != null ) { MST[NegateConditionalsMutator]MSP[N] final int i = httpContentType . indexOf ( lr_3 ) ; if ( i > - 1 ) {
if ( encoding == null ) { MST[NegateConditionalsMutator]MSP[N] encoding = defaultEncoding == null ? UTF_8 : defaultEncoding ; } return encoding ; } String calculateRawEncoding ( final String bomEnc , final String xmlGuessEnc , final String xmlEnc ) throws IOException { if ( bomEnc == null ) {
} return xmlEnc ; } if ( bomEnc . equals ( UTF_8 ) ) { if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( UTF_8 ) ) { MST[rv.ROR5Mutator]MSP[N] final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[ConstructorCallMutator]MSP[S] }
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { MST[rv.UOI1Mutator]MSP[N] offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ;
if ( cTEnc . equals ( UTF_32 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_32 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR6Mutator]MSP[N]
static String getContentTypeEncoding ( final String httpContentType ) { String encoding = null ; if ( httpContentType != null ) { final int i = httpContentType . indexOf ( lr_3 ) ; if ( i > - 1 ) { MST[rv.ROR3Mutator]MSP[N]
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } if ( bomEnc . equals ( UTF_16BE ) || bomEnc . equals ( UTF_16LE ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( bomEnc ) ) {
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR5Mutator]MSP[N] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
mime . equals ( lr_9 ) || mime . equals ( lr_10 ) || mime . startsWith ( lr_11 ) && mime . endsWith ( lr_12 ) ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } static boolean isTextXml ( final String mime ) { return mime != null &&
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR2Mutator]MSP[N] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
final int i = httpContentType . indexOf ( lr_3 ) ; if ( i >= 0 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] mime = httpContentType . substring ( 0 , i ) ; } else { mime = httpContentType ; } mime = mime . trim () ; } return mime ; }
throw new IOException ( lr_6 + offset + lr_7 ) ; } final int bytesRead = offset ; if ( bytesRead > 0 ) { is . reset () ; final BufferedReader bReader = new BufferedReader ( new StringReader ( MST[InlineConstantMutator]MSP[N]
final String bomEnc = bom . getBOMCharsetName () ; final String xmlGuessEnc = pis . getBOMCharsetName () ; final String xmlEnc = getXmlProlog ( pis , xmlGuessEnc ) ; try { return calculateHttpEncoding ( httpContentType , bomEnc , MST[ReturnValsMutator]MSP[N] xmlGuessEnc , xmlEnc , lenient ) ;
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_32 ) && ! xmlEnc . equals ( bomEnc ) ) { MST[rv.ROR2Mutator]MSP[N] final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
static String getContentTypeEncoding ( final String httpContentType ) { String encoding = null ; if ( httpContentType != null ) { MST[rv.ROR5Mutator]MSP[N] final int i = httpContentType . indexOf ( lr_3 ) ; if ( i > - 1 ) {
throw new IOException ( lr_6 + offset + lr_7 ) ; } final int bytesRead = offset ; if ( bytesRead > 0 ) { MST[rv.UOI2Mutator]MSP[N] is . reset () ; final BufferedReader bReader = new BufferedReader ( new StringReader (
final String postMime = httpContentType . substring ( i + 1 ) ; final Matcher m = CHARSET_PATTERN . matcher ( postMime ) ; encoding = m . find () ? m . group ( 1 ) : null ; MST[rv.CRCR4Mutator]MSP[N]
} return xmlEnc ; } if ( bomEnc . equals ( UTF_8 ) ) { MST[NegateConditionalsMutator]MSP[N] if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( UTF_8 ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
final String bomEnc = bom . getBOMCharsetName () ; final String xmlGuessEnc = pis . getBOMCharsetName () ; final String xmlEnc = getXmlProlog ( pis , xmlGuessEnc ) ; try { return calculateHttpEncoding ( httpContentType , bomEnc , MST[ArgumentPropagationMutator]MSP[N] xmlGuessEnc , xmlEnc , lenient ) ;
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[NonVoidMethodCallMutator]MSP[N] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
} return xmlEnc ; } if ( bomEnc . equals ( UTF_8 ) ) { if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( UTF_8 ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR4Mutator]MSP[S]
final String msg = MessageFormat . format ( HTTP_EX_3 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR3Mutator]MSP[N] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( cTEnc == null ) {
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; MST[EmptyObjectReturnValsMutator]MSP[N] } if ( bomEnc . equals ( UTF_32BE ) || bomEnc . equals ( UTF_32LE ) ) { if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( bomEnc ) ) {
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { offset += c ; MST[MathMutator]MSP[N] max -= c ; c = is . read ( bytes , offset , max ) ;
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { MST[rv.UOI2Mutator]MSP[N] offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ;
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( xmlEnc != null && ! xmlEnc . equals ( UTF_8 ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR1Mutator]MSP[N]
if ( cTEnc . equals ( UTF_16 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_16 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR5Mutator]MSP[N]
throw new IOException ( lr_6 + offset + lr_7 ) ; } final int bytesRead = offset ; MST[rv.UOI2Mutator]MSP[N] if ( bytesRead > 0 ) { is . reset () ; final BufferedReader bReader = new BufferedReader ( new StringReader (
final String postMime = httpContentType . substring ( i + 1 ) ; MST[rv.AOR4Mutator]MSP[N] final Matcher m = CHARSET_PATTERN . matcher ( postMime ) ; encoding = m . find () ? m . group ( 1 ) : null ;
encoding = encoding . substring ( 1 , encoding . length () - 1 ) ; MST[rv.CRCR5Mutator]MSP[N] } } } return encoding ; } static boolean isAppXml ( final String mime ) { return mime != null && ( mime . equals ( lr_8 ) ||
if ( cTEnc . equals ( UTF_16 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_16 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR2Mutator]MSP[N]
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[InlineConstantMutator]MSP[N] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_16 ) && ! xmlEnc . equals ( bomEnc ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
public String getDefaultEncoding () { return defaultEncoding ; MST[EmptyObjectReturnValsMutator]MSP[N] } public String getEncoding () { return encoding ; } @Override public int read ( final char [] buf , final int offset , final int len ) throws IOException {
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_32 ) && ! xmlEnc . equals ( bomEnc ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[InlineConstantMutator]MSP[N]
xmlProlog = new String ( bytes , 0 , offset , guessedEnc ) ; firstGT = xmlProlog . indexOf ( '>' ) ; } if ( firstGT == - 1 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] if ( c == - 1 ) { throw new IOException ( lr_5 ) ; }
if ( httpContentType != null && httpContentType . startsWith ( lr_1 ) ) { MST[rv.ROR5Mutator]MSP[N] httpContentType = httpContentType . substring ( lr_1 . length () ) ; httpContentType = lr_2 + httpContentType ; try { return calculateHttpEncoding ( httpContentType , ex . getBomEncoding () ,
} return xmlEnc ; } if ( bomEnc . equals ( UTF_8 ) ) { if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( UTF_8 ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR6Mutator]MSP[S]
final String postMime = httpContentType . substring ( i + 1 ) ; MST[rv.CRCR3Mutator]MSP[S] final Matcher m = CHARSET_PATTERN . matcher ( postMime ) ; encoding = m . find () ? m . group ( 1 ) : null ;
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } if ( bomEnc . equals ( UTF_32BE ) || bomEnc . equals ( UTF_32LE ) ) { MST[rv.ROR5Mutator]MSP[N] if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( bomEnc ) ) {
throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; } static String getContentTypeMime ( final String httpContentType ) { String mime = null ; if ( httpContentType != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
throw new IOException ( lr_6 + offset + lr_7 ) ; } final int bytesRead = offset ; if ( bytesRead > 0 ) { is . reset () ; final BufferedReader bReader = new BufferedReader ( new StringReader ( MST[rv.AOD2Mutator]MSP[N]
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_32 ) && ! xmlEnc . equals ( bomEnc ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR4Mutator]MSP[N]
xmlProlog = new String ( bytes , 0 , offset , guessedEnc ) ; firstGT = xmlProlog . indexOf ( '>' ) ; } if ( firstGT == - 1 ) { MST[rv.ROR3Mutator]MSP[N] if ( c == - 1 ) { throw new IOException ( lr_5 ) ; }
final String postMime = httpContentType . substring ( i + 1 ) ; final Matcher m = CHARSET_PATTERN . matcher ( postMime ) ; MST[NonVoidMethodCallMutator]MSP[N] encoding = m . find () ? m . group ( 1 ) : null ;
if ( encoding == null ) { encoding = defaultEncoding == null ? UTF_8 : defaultEncoding ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] } return encoding ; } String calculateRawEncoding ( final String bomEnc , final String xmlGuessEnc , final String xmlEnc ) throws IOException { if ( bomEnc == null ) {
xmlProlog = new String ( bytes , 0 , offset , guessedEnc ) ; firstGT = xmlProlog . indexOf ( '>' ) ; } if ( firstGT == - 1 ) { MST[rv.CRCR5Mutator]MSP[N] if ( c == - 1 ) { throw new IOException ( lr_5 ) ; }
if ( guessedEnc != null ) { final byte [] bytes = new byte [ BUFFER_SIZE ] ; MST[rv.CRCR1Mutator]MSP[N] is . mark ( BUFFER_SIZE ) ; int offset = 0 ; int max = BUFFER_SIZE ; int c = is . read ( bytes , offset , max ) ;
final String cTEnc = getContentTypeEncoding ( httpContentType ) ; MST[ArgumentPropagationMutator]MSP[N] final boolean appXml = isAppXml ( cTMime ) ; final boolean textXml = isTextXml ( cTMime ) ; if ( ! appXml && ! textXml ) {
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; MST[EmptyObjectReturnValsMutator]MSP[N] }
mime . equals ( lr_9 ) || mime . equals ( lr_10 ) || mime . startsWith ( lr_11 ) && mime . endsWith ( lr_12 ) ) ; MST[rv.ROR2Mutator]MSP[S] } static boolean isTextXml ( final String mime ) { return mime != null &&
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_32 ) && ! xmlEnc . equals ( bomEnc ) ) { MST[NegateConditionalsMutator]MSP[N] final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
if ( cTEnc . equals ( UTF_32 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_32 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[InlineConstantMutator]MSP[N]
mime . equals ( lr_9 ) || mime . equals ( lr_10 ) || mime . startsWith ( lr_11 ) && mime . endsWith ( lr_12 ) ) ; MST[rv.ROR5Mutator]MSP[N] } static boolean isTextXml ( final String mime ) { return mime != null &&
encoding = encoding . substring ( 1 , encoding . length () - 1 ) ; MST[rv.CRCR4Mutator]MSP[N] } } } return encoding ; } static boolean isAppXml ( final String mime ) { return mime != null && ( mime . equals ( lr_8 ) ||
if ( xmlGuessEnc == null || xmlEnc == null ) { return defaultEncoding == null ? UTF_8 : defaultEncoding ; MST[rv.ROR5Mutator]MSP[N] } if ( xmlEnc . equals ( UTF_16 ) && ( xmlGuessEnc . equals ( UTF_16BE ) || xmlGuessEnc . equals ( UTF_16LE ) ) ) { return xmlGuessEnc ;
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( xmlEnc != null && ! xmlEnc . equals ( UTF_8 ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR3Mutator]MSP[N]
if ( appXml ) { return calculateRawEncoding ( bomEnc , xmlGuessEnc , xmlEnc ) ; } return defaultEncoding == null ? US_ASCII : defaultEncoding ; MST[EmptyObjectReturnValsMutator]MSP[N] } if ( cTEnc . equals ( UTF_16BE ) || cTEnc . equals ( UTF_16LE ) ) { if ( bomEnc != null ) {
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_16 ) && ! xmlEnc . equals ( bomEnc ) ) { MST[NonVoidMethodCallMutator]MSP[N] final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { offset += c ; max -= c ; MST[rv.ABSMutator]MSP[N] c = is . read ( bytes , offset , max ) ;
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_16 ) && ! xmlEnc . equals ( bomEnc ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR6Mutator]MSP[S]
if ( guessedEnc != null ) { final byte [] bytes = new byte [ BUFFER_SIZE ] ; is . mark ( BUFFER_SIZE ) ; MST[InlineConstantMutator]MSP[N] int offset = 0 ; int max = BUFFER_SIZE ; int c = is . read ( bytes , offset , max ) ;
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } if ( bomEnc . equals ( UTF_32BE ) || bomEnc . equals ( UTF_32LE ) ) { MST[rv.ROR2Mutator]MSP[N] if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( bomEnc ) ) {
if ( xmlGuessEnc == null || xmlEnc == null ) { MST[NegateConditionalsMutator]MSP[N] return defaultEncoding == null ? UTF_8 : defaultEncoding ; } if ( xmlEnc . equals ( UTF_16 ) && ( xmlGuessEnc . equals ( UTF_16BE ) || xmlGuessEnc . equals ( UTF_16LE ) ) ) { return xmlGuessEnc ;
final String postMime = httpContentType . substring ( i + 1 ) ; final Matcher m = CHARSET_PATTERN . matcher ( postMime ) ; encoding = m . find () ? m . group ( 1 ) : null ; MST[rv.ROR5Mutator]MSP[N]
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_16 ) && ! xmlEnc . equals ( bomEnc ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[InlineConstantMutator]MSP[S]
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR2Mutator]MSP[N] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR3Mutator]MSP[N] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR6Mutator]MSP[N] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
if ( lenient ) { MST[rv.UOI2Mutator]MSP[N] return doLenientDetection ( null , ex ) ; } throw ex ; } } private String doHttpStream ( final BOMInputStream bom , final BOMInputStream pis , final String httpContentType , final boolean lenient ) throws IOException {
final String cTEnc = getContentTypeEncoding ( httpContentType ) ; final boolean appXml = isAppXml ( cTMime ) ; final boolean textXml = isTextXml ( cTMime ) ; if ( ! appXml && ! textXml ) { MST[rv.ABSMutator]MSP[S]
final String msg = MessageFormat . format ( HTTP_EX_3 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[ArgumentPropagationMutator]MSP[S] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( cTEnc == null ) {
if ( httpContentType != null && httpContentType . startsWith ( lr_1 ) ) { httpContentType = httpContentType . substring ( lr_1 . length () ) ; MST[NonVoidMethodCallMutator]MSP[N] httpContentType = lr_2 + httpContentType ; try { return calculateHttpEncoding ( httpContentType , ex . getBomEncoding () ,
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ; MST[rv.ABSMutator]MSP[N]
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_16 ) && ! xmlEnc . equals ( bomEnc ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR3Mutator]MSP[N]
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ; MST[rv.UOI4Mutator]MSP[N]
( mime . equals ( lr_2 ) || mime . equals ( lr_13 ) || mime . startsWith ( lr_14 ) && mime . endsWith ( lr_12 ) ) ; MST[rv.ROR3Mutator]MSP[N] }
} final Matcher m = ENCODING_PATTERN . matcher ( prolog ) ; if ( m . find () ) { MST[NonVoidMethodCallMutator]MSP[N] encoding = m . group ( 1 ) . toUpperCase ( Locale . ROOT ) ;
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } if ( bomEnc . equals ( UTF_32BE ) || bomEnc . equals ( UTF_32LE ) ) { if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( bomEnc ) ) { MST[NegateConditionalsMutator]MSP[N]
ex . getXmlGuessEncoding () , ex . getXmlEncoding () , true ) ; MST[InlineConstantMutator]MSP[N] } catch ( final XmlStreamReaderException ex2 ) { ex = ex2 ; } } String encoding = ex . getXmlEncoding () ; if ( encoding == null ) { encoding = ex . getContentTypeEncoding () ; }
( mime . equals ( lr_2 ) || mime . equals ( lr_13 ) || mime . startsWith ( lr_14 ) && mime . endsWith ( lr_12 ) ) ; MST[rv.CRCR5Mutator]MSP[N] }
final int i = httpContentType . indexOf ( lr_3 ) ; if ( i >= 0 ) { mime = httpContentType . substring ( 0 , i ) ; } else { mime = httpContentType ; } mime = mime . trim () ; MST[NonVoidMethodCallMutator]MSP[N] } return mime ; }
if ( lenient ) { MST[rv.ROR3Mutator]MSP[S] return doLenientDetection ( null , ex ) ; } throw ex ; } } private String doHttpStream ( final BOMInputStream bom , final BOMInputStream pis , final String httpContentType , final boolean lenient ) throws IOException {
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_16 ) && ! xmlEnc . equals ( bomEnc ) ) { MST[rv.ROR4Mutator]MSP[N] final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { MST[rv.UOI3Mutator]MSP[N] offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ;
if ( xmlGuessEnc == null || xmlEnc == null ) { return defaultEncoding == null ? UTF_8 : defaultEncoding ; } if ( xmlEnc . equals ( UTF_16 ) && ( xmlGuessEnc . equals ( UTF_16BE ) || xmlGuessEnc . equals ( UTF_16LE ) ) ) { return xmlGuessEnc ; MST[ReturnValsMutator]MSP[N]
} return xmlEnc ; } if ( bomEnc . equals ( UTF_8 ) ) { MST[rv.ROR5Mutator]MSP[N] if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( UTF_8 ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { MST[rv.ROR5Mutator]MSP[N] offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ;
if ( guessedEnc != null ) { final byte [] bytes = new byte [ BUFFER_SIZE ] ; is . mark ( BUFFER_SIZE ) ; int offset = 0 ; int max = BUFFER_SIZE ; int c = is . read ( bytes , offset , max ) ; MST[NonVoidMethodCallMutator]MSP[N]
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { MST[InlineConstantMutator]MSP[N] offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ;
final String msg = MessageFormat . format ( HTTP_EX_3 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR4Mutator]MSP[N] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( cTEnc == null ) {
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_32 ) && ! xmlEnc . equals ( bomEnc ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR1Mutator]MSP[S]
mime . equals ( lr_9 ) || mime . equals ( lr_10 ) || mime . startsWith ( lr_11 ) && mime . endsWith ( lr_12 ) ) ; } static boolean isTextXml ( final String mime ) { return mime != null && MST[ReturnValsMutator]MSP[N]
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } if ( bomEnc . equals ( UTF_16BE ) || bomEnc . equals ( UTF_16LE ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( bomEnc ) ) {
if ( cTEnc . equals ( UTF_32 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_32 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR2Mutator]MSP[N]
final String postMime = httpContentType . substring ( i + 1 ) ; final Matcher m = CHARSET_PATTERN . matcher ( postMime ) ; encoding = m . find () ? m . group ( 1 ) : null ; MST[NegateConditionalsMutator]MSP[N]
throw new IOException ( lr_6 + offset + lr_7 ) ; } final int bytesRead = offset ; if ( bytesRead > 0 ) { is . reset () ; final BufferedReader bReader = new BufferedReader ( new StringReader ( MST[rv.CRCR5Mutator]MSP[N]
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR2Mutator]MSP[N] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
if ( cTEnc . equals ( UTF_32 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_32 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR6Mutator]MSP[N]
final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR2Mutator]MSP[S] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
final String msg = MessageFormat . format ( HTTP_EX_3 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[InlineConstantMutator]MSP[S] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( cTEnc == null ) {
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR6Mutator]MSP[N] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
if ( xmlGuessEnc == null || xmlEnc == null ) { return defaultEncoding == null ? UTF_8 : defaultEncoding ; } if ( xmlEnc . equals ( UTF_16 ) && ( xmlGuessEnc . equals ( UTF_16BE ) || xmlGuessEnc . equals ( UTF_16LE ) ) ) { MST[rv.ROR5Mutator]MSP[S] return xmlGuessEnc ;
} catch ( final XmlStreamReaderException ex ) { if ( lenient ) { MST[rv.ROR1Mutator]MSP[N] return doLenientDetection ( httpContentType , ex ) ; } throw ex ; } } private String doLenientDetection ( String httpContentType , XmlStreamReaderException ex ) throws IOException {
mime . equals ( lr_9 ) || mime . equals ( lr_10 ) || mime . startsWith ( lr_11 ) && mime . endsWith ( lr_12 ) ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } static boolean isTextXml ( final String mime ) { return mime != null &&
if ( guessedEnc != null ) { final byte [] bytes = new byte [ BUFFER_SIZE ] ; is . mark ( BUFFER_SIZE ) ; int offset = 0 ; int max = BUFFER_SIZE ; int c = is . read ( bytes , offset , max ) ; MST[rv.UOI2Mutator]MSP[N]
throw new IOException ( lr_6 + offset + lr_7 ) ; } final int bytesRead = offset ; if ( bytesRead > 0 ) { is . reset () ; final BufferedReader bReader = new BufferedReader ( new StringReader ( MST[rv.AOR4Mutator]MSP[N]
} return xmlEnc ; } if ( bomEnc . equals ( UTF_8 ) ) { if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( UTF_8 ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR3Mutator]MSP[S]
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_32 ) && ! xmlEnc . equals ( bomEnc ) ) { MST[rv.ROR2Mutator]MSP[N] final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR6Mutator]MSP[S] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
final String msg = MessageFormat . format ( HTTP_EX_3 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR2Mutator]MSP[N] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( cTEnc == null ) {
final String bomEnc = bom . getBOMCharsetName () ; final String xmlGuessEnc = pis . getBOMCharsetName () ; MST[NonVoidMethodCallMutator]MSP[N] final String xmlEnc = getXmlProlog ( pis , xmlGuessEnc ) ; try { return calculateHttpEncoding ( httpContentType , bomEnc , xmlGuessEnc , xmlEnc , lenient ) ;
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { MST[NegateConditionalsMutator]MSP[N] offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ;
final String bomEnc = bom . getBOMCharsetName () ; final String xmlGuessEnc = pis . getBOMCharsetName () ; final String xmlEnc = getXmlProlog ( pis , xmlGuessEnc ) ; try { return calculateHttpEncoding ( httpContentType , bomEnc , MST[rv.UOI1Mutator]MSP[N] xmlGuessEnc , xmlEnc , lenient ) ;
final String postMime = httpContentType . substring ( i + 1 ) ; MST[rv.ABSMutator]MSP[N] final Matcher m = CHARSET_PATTERN . matcher ( postMime ) ; encoding = m . find () ? m . group ( 1 ) : null ;
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } if ( bomEnc . equals ( UTF_32BE ) || bomEnc . equals ( UTF_32LE ) ) { if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( bomEnc ) ) { MST[rv.ROR5Mutator]MSP[N]
xmlProlog . substring ( 0 , firstGT + 1 ) ) ) ; MST[ConstructorCallMutator]MSP[N] final StringBuffer prolog = new StringBuffer () ; String line = bReader . readLine () ; while ( line != null ) { prolog . append ( line ) ; line = bReader . readLine () ;
if ( cTEnc . equals ( UTF_16 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_16 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR5Mutator]MSP[N]
if ( cTEnc . equals ( UTF_16 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_16 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR2Mutator]MSP[N]
if ( cTEnc . equals ( UTF_32 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_32 ) ) { MST[rv.ROR4Mutator]MSP[N] return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ;
final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[ArgumentPropagationMutator]MSP[S] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
if ( xmlGuessEnc == null || xmlEnc == null ) { return defaultEncoding == null ? UTF_8 : defaultEncoding ; } if ( xmlEnc . equals ( UTF_16 ) && ( xmlGuessEnc . equals ( UTF_16BE ) || xmlGuessEnc . equals ( UTF_16LE ) ) ) { MST[NegateConditionalsMutator]MSP[S] return xmlGuessEnc ;
( mime . equals ( lr_2 ) || mime . equals ( lr_13 ) || MST[rv.ROR1Mutator]MSP[S] mime . startsWith ( lr_14 ) && mime . endsWith ( lr_12 ) ) ; }
final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR4Mutator]MSP[S] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { MST[rv.CRCR5Mutator]MSP[N] offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ;
final String bomEnc = bom . getBOMCharsetName () ; final String xmlGuessEnc = pis . getBOMCharsetName () ; final String xmlEnc = getXmlProlog ( pis , xmlGuessEnc ) ; try { return calculateRawEncoding ( bomEnc , xmlGuessEnc , xmlEnc ) ; MST[ArgumentPropagationMutator]MSP[N] } catch ( final XmlStreamReaderException ex ) {
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_16 ) && ! xmlEnc . equals ( bomEnc ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
if ( xmlGuessEnc == null || xmlEnc == null ) { return defaultEncoding == null ? UTF_8 : defaultEncoding ; } if ( xmlEnc . equals ( UTF_16 ) && ( xmlGuessEnc . equals ( UTF_16BE ) || xmlGuessEnc . equals ( UTF_16LE ) ) ) { return xmlGuessEnc ; MST[EmptyObjectReturnValsMutator]MSP[N]
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( xmlEnc != null && ! xmlEnc . equals ( UTF_8 ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[NonVoidMethodCallMutator]MSP[N]
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR1Mutator]MSP[N] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
} return xmlEnc ; } if ( bomEnc . equals ( UTF_8 ) ) { if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( UTF_8 ) ) { MST[rv.ROR2Mutator]MSP[N] final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
if ( cTEnc . equals ( UTF_16 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_16 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR4Mutator]MSP[N]
mime . equals ( lr_9 ) || mime . equals ( lr_10 ) || mime . startsWith ( lr_11 ) && mime . endsWith ( lr_12 ) ) ; MST[rv.ROR2Mutator]MSP[S] } static boolean isTextXml ( final String mime ) { return mime != null &&
xmlProlog = new String ( bytes , 0 , offset , guessedEnc ) ; firstGT = xmlProlog . indexOf ( '>' ) ; MST[rv.CRCR1Mutator]MSP[N] } if ( firstGT == - 1 ) { if ( c == - 1 ) { throw new IOException ( lr_5 ) ; }
throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( cTEnc . equals ( UTF_32BE ) || cTEnc . equals ( UTF_32LE ) ) { MST[rv.ROR4Mutator]MSP[S] if ( bomEnc != null ) {
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_16 ) && ! xmlEnc . equals ( bomEnc ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR6Mutator]MSP[S]
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } if ( bomEnc . equals ( UTF_32BE ) || bomEnc . equals ( UTF_32LE ) ) { MST[rv.ROR2Mutator]MSP[S] if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( bomEnc ) ) {
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_16 ) && ! xmlEnc . equals ( bomEnc ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } final String msg = MessageFormat . format ( RAW_EX_2 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[InlineConstantMutator]MSP[S] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
if ( cTEnc . equals ( UTF_16 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_16 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[InlineConstantMutator]MSP[N]
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR5Mutator]MSP[N] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
xmlProlog . substring ( 0 , firstGT + 1 ) ) ) ; final StringBuffer prolog = new StringBuffer () ; MST[ConstructorCallMutator]MSP[N] String line = bReader . readLine () ; while ( line != null ) { prolog . append ( line ) ; line = bReader . readLine () ;
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR2Mutator]MSP[N] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { MST[rv.ROR5Mutator]MSP[N] offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ;
} final Matcher m = ENCODING_PATTERN . matcher ( prolog ) ; if ( m . find () ) { MST[NegateConditionalsMutator]MSP[N] encoding = m . group ( 1 ) . toUpperCase ( Locale . ROOT ) ;
mime . equals ( lr_9 ) || mime . equals ( lr_10 ) || mime . startsWith ( lr_11 ) && mime . endsWith ( lr_12 ) ) ; MST[NegateConditionalsMutator]MSP[N] } static boolean isTextXml ( final String mime ) { return mime != null &&
} return xmlEnc ; } if ( bomEnc . equals ( UTF_8 ) ) { if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( UTF_8 ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR1Mutator]MSP[S]
final String cTEnc = getContentTypeEncoding ( httpContentType ) ; final boolean appXml = isAppXml ( cTMime ) ; final boolean textXml = isTextXml ( cTMime ) ; if ( ! appXml && ! textXml ) { MST[rv.ROR4Mutator]MSP[N]
throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( cTEnc . equals ( UTF_32BE ) || cTEnc . equals ( UTF_32LE ) ) { MST[NegateConditionalsMutator]MSP[N] if ( bomEnc != null ) {
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_16 ) && ! xmlEnc . equals ( bomEnc ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR3Mutator]MSP[N]
final int i = httpContentType . indexOf ( lr_3 ) ; if ( i >= 0 ) { mime = httpContentType . substring ( 0 , i ) ; MST[rv.UOI2Mutator]MSP[S] } else { mime = httpContentType ; } mime = mime . trim () ; } return mime ; }
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ; MST[rv.UOI1Mutator]MSP[N]
if ( xmlGuessEnc == null || xmlEnc == null ) { return defaultEncoding == null ? UTF_8 : defaultEncoding ; } if ( xmlEnc . equals ( UTF_16 ) && MST[NonVoidMethodCallMutator]MSP[S] ( xmlGuessEnc . equals ( UTF_16BE ) || xmlGuessEnc . equals ( UTF_16LE ) ) ) { return xmlGuessEnc ;
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_32 ) && ! xmlEnc . equals ( bomEnc ) ) { MST[rv.ROR1Mutator]MSP[N] final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
if ( guessedEnc != null ) { final byte [] bytes = new byte [ BUFFER_SIZE ] ; is . mark ( BUFFER_SIZE ) ; MST[VoidMethodCallMutator]MSP[N] int offset = 0 ; int max = BUFFER_SIZE ; int c = is . read ( bytes , offset , max ) ;
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[ConstructorCallMutator]MSP[N] } return bomEnc ; } final String msg = MessageFormat . format ( RAW_EX_2 , bomEnc , xmlGuessEnc , xmlEnc ) ; throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ;
final String postMime = httpContentType . substring ( i + 1 ) ; MST[NonVoidMethodCallMutator]MSP[N] final Matcher m = CHARSET_PATTERN . matcher ( postMime ) ; encoding = m . find () ? m . group ( 1 ) : null ;
final String msg = MessageFormat . format ( HTTP_EX_3 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR3Mutator]MSP[N] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( cTEnc == null ) {
final String bomEnc = bom . getBOMCharsetName () ; final String xmlGuessEnc = pis . getBOMCharsetName () ; final String xmlEnc = getXmlProlog ( pis , xmlGuessEnc ) ; MST[ArgumentPropagationMutator]MSP[N] try { return calculateRawEncoding ( bomEnc , xmlGuessEnc , xmlEnc ) ; } catch ( final XmlStreamReaderException ex ) {
if ( cTEnc . equals ( UTF_32 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_32 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR5Mutator]MSP[N]
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_16 ) && ! xmlEnc . equals ( bomEnc ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[ArgumentPropagationMutator]MSP[S]
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { MST[rv.ROR4Mutator]MSP[N] offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ;
} final Matcher m = ENCODING_PATTERN . matcher ( prolog ) ; if ( m . find () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] encoding = m . group ( 1 ) . toUpperCase ( Locale . ROOT ) ;
int firstGT = - 1 ; MST[rv.CRCR5Mutator]MSP[N] String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ;
encoding = encoding . substring ( 1 , encoding . length () - 1 ) ; } } } return encoding ; MST[ReturnValsMutator]MSP[N] } static boolean isAppXml ( final String mime ) { return mime != null && ( mime . equals ( lr_8 ) ||
} return xmlEnc ; } if ( bomEnc . equals ( UTF_8 ) ) { if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( UTF_8 ) ) { MST[rv.ROR4Mutator]MSP[N] final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
if ( cTEnc . equals ( UTF_32 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_32 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR2Mutator]MSP[N]
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { offset += c ; max -= c ; MST[rv.UOI3Mutator]MSP[N] c = is . read ( bytes , offset , max ) ;
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { offset += c ; MST[rv.ABSMutator]MSP[N] max -= c ; c = is . read ( bytes , offset , max ) ;
final String postMime = httpContentType . substring ( i + 1 ) ; MST[rv.UOI1Mutator]MSP[S] final Matcher m = CHARSET_PATTERN . matcher ( postMime ) ; encoding = m . find () ? m . group ( 1 ) : null ;
final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR6Mutator]MSP[S] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
String calculateHttpEncoding ( final String httpContentType , final String bomEnc , final String xmlGuessEnc , final String xmlEnc , final boolean lenient ) throws IOException { if ( lenient && xmlEnc != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return xmlEnc ; } final String cTMime = getContentTypeMime ( httpContentType ) ;
if ( guessedEnc != null ) { final byte [] bytes = new byte [ BUFFER_SIZE ] ; is . mark ( BUFFER_SIZE ) ; int offset = 0 ; MST[rv.CRCR1Mutator]MSP[N] int max = BUFFER_SIZE ; int c = is . read ( bytes , offset , max ) ;
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR5Mutator]MSP[N] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( cTEnc . equals ( UTF_32BE ) || cTEnc . equals ( UTF_32LE ) ) { MST[rv.ROR2Mutator]MSP[N] if ( bomEnc != null ) {
throw new IOException ( lr_6 + offset + lr_7 ) ; } final int bytesRead = offset ; if ( bytesRead > 0 ) { is . reset () ; final BufferedReader bReader = new BufferedReader ( new StringReader ( MST[rv.CRCR4Mutator]MSP[N]
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR2Mutator]MSP[N] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
throw new IOException ( lr_6 + offset + lr_7 ) ; } final int bytesRead = offset ; if ( bytesRead > 0 ) { is . reset () ; final BufferedReader bReader = new BufferedReader ( new StringReader ( MST[rv.UOI4Mutator]MSP[N]
public String getDefaultEncoding () { return defaultEncoding ; } public String getEncoding () { return encoding ; MST[ReturnValsMutator]MSP[N] } @Override public int read ( final char [] buf , final int offset , final int len ) throws IOException {
throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( cTEnc . equals ( UTF_32BE ) || cTEnc . equals ( UTF_32LE ) ) { MST[rv.ROR5Mutator]MSP[N] if ( bomEnc != null ) {
if ( guessedEnc != null ) { final byte [] bytes = new byte [ BUFFER_SIZE ] ; MST[InlineConstantMutator]MSP[N] is . mark ( BUFFER_SIZE ) ; int offset = 0 ; int max = BUFFER_SIZE ; int c = is . read ( bytes , offset , max ) ;
return reader . read ( buf , offset , len ) ; MST[rv.UOI4Mutator]MSP[N] } @Override public void close () throws IOException { reader . close () ; } private String doRawStream ( final BOMInputStream bom , final BOMInputStream pis , final boolean lenient ) throws IOException {
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } if ( bomEnc . equals ( UTF_32BE ) || bomEnc . equals ( UTF_32LE ) ) { MST[rv.ROR4Mutator]MSP[N] if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( bomEnc ) ) {
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } final String msg = MessageFormat . format ( RAW_EX_2 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR6Mutator]MSP[S] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
if ( appXml ) { return calculateRawEncoding ( bomEnc , xmlGuessEnc , xmlEnc ) ; MST[ReturnValsMutator]MSP[N] } return defaultEncoding == null ? US_ASCII : defaultEncoding ; } if ( cTEnc . equals ( UTF_16BE ) || cTEnc . equals ( UTF_16LE ) ) { if ( bomEnc != null ) {
String calculateHttpEncoding ( final String httpContentType , final String bomEnc , final String xmlGuessEnc , final String xmlEnc , final boolean lenient ) throws IOException { if ( lenient && xmlEnc != null ) { MST[NegateConditionalsMutator]MSP[N] return xmlEnc ; } final String cTMime = getContentTypeMime ( httpContentType ) ;
final String bomEnc = bom . getBOMCharsetName () ; final String xmlGuessEnc = pis . getBOMCharsetName () ; final String xmlEnc = getXmlProlog ( pis , xmlGuessEnc ) ; try { return calculateHttpEncoding ( httpContentType , bomEnc , MST[rv.UOI3Mutator]MSP[N] xmlGuessEnc , xmlEnc , lenient ) ;
if ( cTEnc . equals ( UTF_32 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_32 ) ) { return bomEnc ; MST[ReturnValsMutator]MSP[S] } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ;
if ( cTEnc . equals ( UTF_16 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] if ( bomEnc != null && bomEnc . startsWith ( UTF_16 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ;
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[InlineConstantMutator]MSP[N] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
if ( cTEnc . equals ( UTF_16 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_16 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR5Mutator]MSP[N]
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { offset += c ; MST[rv.UOI2Mutator]MSP[N] max -= c ; c = is . read ( bytes , offset , max ) ;
if ( cTEnc . equals ( UTF_32 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_32 ) ) { MST[rv.ROR5Mutator]MSP[N] return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ;
if ( cTEnc . equals ( UTF_16 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_16 ) ) { MST[NegateConditionalsMutator]MSP[N] return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ;
if ( cTEnc . equals ( UTF_32 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_32 ) ) { MST[rv.ROR2Mutator]MSP[N] return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ;
if ( cTEnc . equals ( UTF_16 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_16 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR2Mutator]MSP[N]
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_16 ) && ! xmlEnc . equals ( bomEnc ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR2Mutator]MSP[N]
xmlProlog = new String ( bytes , 0 , offset , guessedEnc ) ; firstGT = xmlProlog . indexOf ( '>' ) ; MST[ArgumentPropagationMutator]MSP[S] } if ( firstGT == - 1 ) { if ( c == - 1 ) { throw new IOException ( lr_5 ) ; }
( mime . equals ( lr_2 ) || MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] mime . equals ( lr_13 ) || mime . startsWith ( lr_14 ) && mime . endsWith ( lr_12 ) ) ; }
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } final String msg = MessageFormat . format ( RAW_EX_2 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR4Mutator]MSP[S] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
final String cTEnc = getContentTypeEncoding ( httpContentType ) ; final boolean appXml = isAppXml ( cTMime ) ; final boolean textXml = isTextXml ( cTMime ) ; if ( ! appXml && ! textXml ) { MST[rv.UOI3Mutator]MSP[N]
ex . getXmlGuessEncoding () , ex . getXmlEncoding () , true ) ; } catch ( final XmlStreamReaderException ex2 ) { ex = ex2 ; } } String encoding = ex . getXmlEncoding () ; MST[NonVoidMethodCallMutator]MSP[S] if ( encoding == null ) { encoding = ex . getContentTypeEncoding () ; }
final String postMime = httpContentType . substring ( i + 1 ) ; final Matcher m = CHARSET_PATTERN . matcher ( postMime ) ; encoding = m . find () ? m . group ( 1 ) : null ; MST[InlineConstantMutator]MSP[N]
( mime . equals ( lr_2 ) || mime . equals ( lr_13 ) || mime . startsWith ( lr_14 ) && mime . endsWith ( lr_12 ) ) ; MST[InlineConstantMutator]MSP[N] }
final String bomEnc = bom . getBOMCharsetName () ; final String xmlGuessEnc = pis . getBOMCharsetName () ; final String xmlEnc = getXmlProlog ( pis , xmlGuessEnc ) ; try { return calculateRawEncoding ( bomEnc , xmlGuessEnc , xmlEnc ) ; MST[NonVoidMethodCallMutator]MSP[N] } catch ( final XmlStreamReaderException ex ) {
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } if ( bomEnc . equals ( UTF_32BE ) || bomEnc . equals ( UTF_32LE ) ) { MST[rv.ROR1Mutator]MSP[N] if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( bomEnc ) ) {
final String msg = MessageFormat . format ( HTTP_EX_3 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR6Mutator]MSP[S] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( cTEnc == null ) {
final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR4Mutator]MSP[S] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[InlineConstantMutator]MSP[N] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
xmlProlog = new String ( bytes , 0 , offset , guessedEnc ) ; firstGT = xmlProlog . indexOf ( '>' ) ; MST[rv.CRCR5Mutator]MSP[N] } if ( firstGT == - 1 ) { if ( c == - 1 ) { throw new IOException ( lr_5 ) ; }
mime . equals ( lr_9 ) || MST[rv.ROR1Mutator]MSP[N] mime . equals ( lr_10 ) || mime . startsWith ( lr_11 ) && mime . endsWith ( lr_12 ) ) ; } static boolean isTextXml ( final String mime ) { return mime != null &&
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { MST[NegateConditionalsMutator]MSP[N] offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ;
if ( cTEnc . equals ( UTF_32 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_32 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[InlineConstantMutator]MSP[N]
} catch ( final XmlStreamReaderException ex ) { if ( lenient ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return doLenientDetection ( httpContentType , ex ) ; } throw ex ; } } private String doLenientDetection ( String httpContentType , XmlStreamReaderException ex ) throws IOException {
} final Matcher m = ENCODING_PATTERN . matcher ( prolog ) ; if ( m . find () ) { encoding = m . group ( 1 ) . toUpperCase ( Locale . ROOT ) ; MST[rv.CRCR4Mutator]MSP[N]
if ( appXml ) { return calculateRawEncoding ( bomEnc , xmlGuessEnc , xmlEnc ) ; } return defaultEncoding == null ? US_ASCII : defaultEncoding ; } if ( cTEnc . equals ( UTF_16BE ) || cTEnc . equals ( UTF_16LE ) ) { MST[NegateConditionalsMutator]MSP[N] if ( bomEnc != null ) {
xmlProlog = new String ( bytes , 0 , offset , guessedEnc ) ; firstGT = xmlProlog . indexOf ( '>' ) ; MST[rv.CRCR2Mutator]MSP[N] } if ( firstGT == - 1 ) { if ( c == - 1 ) { throw new IOException ( lr_5 ) ; }
mime . equals ( lr_9 ) || mime . equals ( lr_10 ) || MST[rv.ROR3Mutator]MSP[S] mime . startsWith ( lr_11 ) && mime . endsWith ( lr_12 ) ) ; } static boolean isTextXml ( final String mime ) { return mime != null &&
if ( httpContentType != null && httpContentType . startsWith ( lr_1 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] httpContentType = httpContentType . substring ( lr_1 . length () ) ; httpContentType = lr_2 + httpContentType ; try { return calculateHttpEncoding ( httpContentType , ex . getBomEncoding () ,
final int i = httpContentType . indexOf ( lr_3 ) ; if ( i >= 0 ) { MST[rv.ROR1Mutator]MSP[N] mime = httpContentType . substring ( 0 , i ) ; } else { mime = httpContentType ; } mime = mime . trim () ; } return mime ; }
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( xmlEnc != null && ! xmlEnc . equals ( UTF_8 ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[InlineConstantMutator]MSP[N]
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_32 ) && ! xmlEnc . equals ( bomEnc ) ) { MST[rv.ROR4Mutator]MSP[N] final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
if ( cTEnc . equals ( UTF_32 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_32 ) ) { MST[NegateConditionalsMutator]MSP[N] return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ;
mime . equals ( lr_9 ) || mime . equals ( lr_10 ) || mime . startsWith ( lr_11 ) && mime . endsWith ( lr_12 ) ) ; MST[rv.CRCR5Mutator]MSP[N] } static boolean isTextXml ( final String mime ) { return mime != null &&
final String postMime = httpContentType . substring ( i + 1 ) ; MST[rv.AOR2Mutator]MSP[S] final Matcher m = CHARSET_PATTERN . matcher ( postMime ) ; encoding = m . find () ? m . group ( 1 ) : null ;
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } final String msg = MessageFormat . format ( RAW_EX_2 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR1Mutator]MSP[S] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
( mime . equals ( lr_2 ) || mime . equals ( lr_13 ) || MST[NonVoidMethodCallMutator]MSP[S] mime . startsWith ( lr_14 ) && mime . endsWith ( lr_12 ) ) ; }
} catch ( final XmlStreamReaderException ex ) { if ( lenient ) { MST[rv.ROR3Mutator]MSP[N] return doLenientDetection ( httpContentType , ex ) ; } throw ex ; } } private String doLenientDetection ( String httpContentType , XmlStreamReaderException ex ) throws IOException {
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_16 ) && ! xmlEnc . equals ( bomEnc ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR6Mutator]MSP[N]
if ( httpContentType != null && httpContentType . startsWith ( lr_1 ) ) { MST[rv.ROR2Mutator]MSP[S] httpContentType = httpContentType . substring ( lr_1 . length () ) ; httpContentType = lr_2 + httpContentType ; try { return calculateHttpEncoding ( httpContentType , ex . getBomEncoding () ,
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_16 ) && ! xmlEnc . equals ( bomEnc ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR5Mutator]MSP[S]
if ( encoding == null ) { encoding = defaultEncoding == null ? UTF_8 : defaultEncoding ; } return encoding ; MST[ReturnValsMutator]MSP[N] } String calculateRawEncoding ( final String bomEnc , final String xmlGuessEnc , final String xmlEnc ) throws IOException { if ( bomEnc == null ) {
mime . equals ( lr_9 ) || mime . equals ( lr_10 ) || mime . startsWith ( lr_11 ) && mime . endsWith ( lr_12 ) ) ; MST[NegateConditionalsMutator]MSP[N] } static boolean isTextXml ( final String mime ) { return mime != null &&
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } final String msg = MessageFormat . format ( RAW_EX_2 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[InlineConstantMutator]MSP[S] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
encoding = encoding != null ? encoding . toUpperCase ( Locale . ROOT ) : null ; MST[experimental.NakedReceiverMutator]MSP[N] } } return encoding ; } private static String getXmlProlog ( final InputStream is , final String guessedEnc ) throws IOException { String encoding = null ;
if ( httpContentType != null && httpContentType . startsWith ( lr_1 ) ) { MST[NegateConditionalsMutator]MSP[N] httpContentType = httpContentType . substring ( lr_1 . length () ) ; httpContentType = lr_2 + httpContentType ; try { return calculateHttpEncoding ( httpContentType , ex . getBomEncoding () ,
encoding = encoding != null ? encoding . toUpperCase ( Locale . ROOT ) : null ; } } return encoding ; MST[ReturnValsMutator]MSP[N] } private static String getXmlProlog ( final InputStream is , final String guessedEnc ) throws IOException { String encoding = null ;
} catch ( final XmlStreamReaderException ex ) { if ( lenient ) { MST[rv.UOI2Mutator]MSP[S] return doLenientDetection ( httpContentType , ex ) ; } throw ex ; } } private String doLenientDetection ( String httpContentType , XmlStreamReaderException ex ) throws IOException {
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR5Mutator]MSP[N] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
if ( cTEnc . equals ( UTF_32 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_32 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR4Mutator]MSP[N]
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { MST[rv.ROR2Mutator]MSP[N] offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ;
final String postMime = httpContentType . substring ( i + 1 ) ; final Matcher m = CHARSET_PATTERN . matcher ( postMime ) ; encoding = m . find () ? m . group ( 1 ) : null ; MST[rv.ROR1Mutator]MSP[S]
if ( xmlGuessEnc == null || xmlEnc == null ) { return defaultEncoding == null ? UTF_8 : defaultEncoding ; } if ( xmlEnc . equals ( UTF_16 ) && MST[NegateConditionalsMutator]MSP[S] ( xmlGuessEnc . equals ( UTF_16BE ) || xmlGuessEnc . equals ( UTF_16LE ) ) ) { return xmlGuessEnc ;
if ( appXml ) { return calculateRawEncoding ( bomEnc , xmlGuessEnc , xmlEnc ) ; } return defaultEncoding == null ? US_ASCII : defaultEncoding ; } if ( cTEnc . equals ( UTF_16BE ) || cTEnc . equals ( UTF_16LE ) ) { if ( bomEnc != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { offset += c ; max -= c ; MST[rv.UOI4Mutator]MSP[N] c = is . read ( bytes , offset , max ) ;
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR2Mutator]MSP[N] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_16 ) && ! xmlEnc . equals ( bomEnc ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR3Mutator]MSP[N]
throw new IOException ( lr_6 + offset + lr_7 ) ; } final int bytesRead = offset ; if ( bytesRead > 0 ) { is . reset () ; final BufferedReader bReader = new BufferedReader ( new StringReader ( MST[rv.UOI1Mutator]MSP[N]
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[ConstructorCallMutator]MSP[S] } if ( xmlEnc != null && ! xmlEnc . equals ( UTF_8 ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[NonVoidMethodCallMutator]MSP[N] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
if ( appXml ) { MST[rv.ROR5Mutator]MSP[N] return calculateRawEncoding ( bomEnc , xmlGuessEnc , xmlEnc ) ; } return defaultEncoding == null ? US_ASCII : defaultEncoding ; } if ( cTEnc . equals ( UTF_16BE ) || cTEnc . equals ( UTF_16LE ) ) { if ( bomEnc != null ) {
xmlProlog = new String ( bytes , 0 , offset , guessedEnc ) ; firstGT = xmlProlog . indexOf ( '>' ) ; } if ( firstGT == - 1 ) { MST[rv.ABSMutator]MSP[N] if ( c == - 1 ) { throw new IOException ( lr_5 ) ; }
final String msg = MessageFormat . format ( HTTP_EX_3 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR3Mutator]MSP[N] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( cTEnc == null ) {
if ( guessedEnc != null ) { final byte [] bytes = new byte [ BUFFER_SIZE ] ; is . mark ( BUFFER_SIZE ) ; MST[rv.CRCR1Mutator]MSP[N] int offset = 0 ; int max = BUFFER_SIZE ; int c = is . read ( bytes , offset , max ) ;
if ( cTEnc . equals ( UTF_32 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_32 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR5Mutator]MSP[N]
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_32 ) && ! xmlEnc . equals ( bomEnc ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR1Mutator]MSP[S]
mime . equals ( lr_9 ) || MST[rv.ROR4Mutator]MSP[N] mime . equals ( lr_10 ) || mime . startsWith ( lr_11 ) && mime . endsWith ( lr_12 ) ) ; } static boolean isTextXml ( final String mime ) { return mime != null &&
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { MST[rv.UOI4Mutator]MSP[N] offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ;
encoding = encoding . substring ( 1 , encoding . length () - 1 ) ; } } } return encoding ; } static boolean isAppXml ( final String mime ) { return mime != null && ( mime . equals ( lr_8 ) || MST[rv.ROR2Mutator]MSP[N]
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR4Mutator]MSP[N] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_32 ) && ! xmlEnc . equals ( bomEnc ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR5Mutator]MSP[N]
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { MST[rv.ROR1Mutator]MSP[N] offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ;
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { offset += c ; max -= c ; MST[rv.AOD1Mutator]MSP[N] c = is . read ( bytes , offset , max ) ;
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR5Mutator]MSP[N] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
if ( cTEnc . equals ( UTF_16 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_16 ) ) { return bomEnc ; MST[ReturnValsMutator]MSP[S] } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ;
if ( xmlGuessEnc == null || xmlEnc == null ) { return defaultEncoding == null ? UTF_8 : defaultEncoding ; } if ( xmlEnc . equals ( UTF_16 ) && MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] ( xmlGuessEnc . equals ( UTF_16BE ) || xmlGuessEnc . equals ( UTF_16LE ) ) ) { return xmlGuessEnc ;
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { MST[rv.ROR3Mutator]MSP[N] offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ;
xmlProlog = new String ( bytes , 0 , offset , guessedEnc ) ; firstGT = xmlProlog . indexOf ( '>' ) ; MST[InlineConstantMutator]MSP[N] } if ( firstGT == - 1 ) { if ( c == - 1 ) { throw new IOException ( lr_5 ) ; }
if ( cTEnc . equals ( UTF_32 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_32 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR2Mutator]MSP[N]
final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR6Mutator]MSP[S] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } if ( bomEnc . equals ( UTF_16BE ) || bomEnc . equals ( UTF_16LE ) ) { if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( bomEnc ) ) { MST[rv.ROR2Mutator]MSP[N]
throw new IOException ( lr_6 + offset + lr_7 ) ; } final int bytesRead = offset ; if ( bytesRead > 0 ) { MST[rv.ROR3Mutator]MSP[N] is . reset () ; final BufferedReader bReader = new BufferedReader ( new StringReader (
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR2Mutator]MSP[N] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
if ( httpContentType != null && httpContentType . startsWith ( lr_1 ) ) { httpContentType = httpContentType . substring ( lr_1 . length () ) ; httpContentType = lr_2 + httpContentType ; try { return calculateHttpEncoding ( httpContentType , ex . getBomEncoding () , MST[ArgumentPropagationMutator]MSP[S]
int firstGT = - 1 ; MST[rv.CRCR2Mutator]MSP[N] String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ;
return reader . read ( buf , offset , len ) ; MST[rv.UOI3Mutator]MSP[N] } @Override public void close () throws IOException { reader . close () ; } private String doRawStream ( final BOMInputStream bom , final BOMInputStream pis , final boolean lenient ) throws IOException {
if ( httpContentType != null && httpContentType . startsWith ( lr_1 ) ) { httpContentType = httpContentType . substring ( lr_1 . length () ) ; httpContentType = lr_2 + httpContentType ; try { return calculateHttpEncoding ( httpContentType , ex . getBomEncoding () , MST[ReturnValsMutator]MSP[S]
encoding = encoding != null ? encoding . toUpperCase ( Locale . ROOT ) : null ; } } return encoding ; MST[EmptyObjectReturnValsMutator]MSP[N] } private static String getXmlProlog ( final InputStream is , final String guessedEnc ) throws IOException { String encoding = null ;
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } if ( bomEnc . equals ( UTF_32BE ) || bomEnc . equals ( UTF_32LE ) ) { MST[rv.ROR4Mutator]MSP[N] if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( bomEnc ) ) {
if ( encoding == null ) { MST[rv.ROR5Mutator]MSP[N] encoding = defaultEncoding == null ? UTF_8 : defaultEncoding ; } return encoding ; } String calculateRawEncoding ( final String bomEnc , final String xmlGuessEnc , final String xmlEnc ) throws IOException { if ( bomEnc == null ) {
final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[InlineConstantMutator]MSP[N] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
if ( lenient ) { MST[rv.ABSMutator]MSP[N] return doLenientDetection ( null , ex ) ; } throw ex ; } } private String doHttpStream ( final BOMInputStream bom , final BOMInputStream pis , final String httpContentType , final boolean lenient ) throws IOException {
if ( appXml ) { MST[NegateConditionalsMutator]MSP[N] return calculateRawEncoding ( bomEnc , xmlGuessEnc , xmlEnc ) ; } return defaultEncoding == null ? US_ASCII : defaultEncoding ; } if ( cTEnc . equals ( UTF_16BE ) || cTEnc . equals ( UTF_16LE ) ) { if ( bomEnc != null ) {
( mime . equals ( lr_2 ) || mime . equals ( lr_13 ) || MST[NegateConditionalsMutator]MSP[N] mime . startsWith ( lr_14 ) && mime . endsWith ( lr_12 ) ) ; }
final String msg = MessageFormat . format ( HTTP_EX_3 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( cTEnc == null ) { MST[NegateConditionalsMutator]MSP[N]
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( xmlEnc != null && ! xmlEnc . equals ( UTF_8 ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR5Mutator]MSP[N]
static String getContentTypeEncoding ( final String httpContentType ) { String encoding = null ; if ( httpContentType != null ) { final int i = httpContentType . indexOf ( lr_3 ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( i > - 1 ) {
if ( appXml ) { return calculateRawEncoding ( bomEnc , xmlGuessEnc , xmlEnc ) ; } return defaultEncoding == null ? US_ASCII : defaultEncoding ; } if ( cTEnc . equals ( UTF_16BE ) || cTEnc . equals ( UTF_16LE ) ) { MST[rv.ROR5Mutator]MSP[N] if ( bomEnc != null ) {
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[InlineConstantMutator]MSP[N] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
if ( cTEnc . equals ( UTF_16 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_16 ) ) { MST[NegateConditionalsMutator]MSP[N] return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ;
if ( cTEnc . equals ( UTF_16 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_16 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR5Mutator]MSP[N]
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { offset += c ; MST[rv.AOR3Mutator]MSP[N] max -= c ; c = is . read ( bytes , offset , max ) ;
if ( guessedEnc != null ) { MST[rv.ROR5Mutator]MSP[N] final byte [] bytes = new byte [ BUFFER_SIZE ] ; is . mark ( BUFFER_SIZE ) ; int offset = 0 ; int max = BUFFER_SIZE ; int c = is . read ( bytes , offset , max ) ;
} final Matcher m = ENCODING_PATTERN . matcher ( prolog ) ; if ( m . find () ) { MST[rv.ROR2Mutator]MSP[N] encoding = m . group ( 1 ) . toUpperCase ( Locale . ROOT ) ;
if ( cTEnc . equals ( UTF_32 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_32 ) ) { MST[rv.ROR5Mutator]MSP[N] return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ;
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_16 ) && ! xmlEnc . equals ( bomEnc ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
if ( cTEnc . equals ( UTF_16 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_16 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR2Mutator]MSP[N]
if ( cTEnc . equals ( UTF_16 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_16 ) ) { return bomEnc ; MST[EmptyObjectReturnValsMutator]MSP[S] } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ;
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } final String msg = MessageFormat . format ( RAW_EX_2 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR4Mutator]MSP[S] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR3Mutator]MSP[S] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
( mime . equals ( lr_2 ) || mime . equals ( lr_13 ) || mime . startsWith ( lr_14 ) && mime . endsWith ( lr_12 ) ) ; MST[InlineConstantMutator]MSP[N] }
if ( httpContentType != null && httpContentType . startsWith ( lr_1 ) ) { MST[rv.ROR5Mutator]MSP[N] httpContentType = httpContentType . substring ( lr_1 . length () ) ; httpContentType = lr_2 + httpContentType ; try { return calculateHttpEncoding ( httpContentType , ex . getBomEncoding () ,
final int i = httpContentType . indexOf ( lr_3 ) ; if ( i >= 0 ) { mime = httpContentType . substring ( 0 , i ) ; MST[InlineConstantMutator]MSP[N] } else { mime = httpContentType ; } mime = mime . trim () ; } return mime ; }
final String msg = MessageFormat . format ( HTTP_EX_3 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR5Mutator]MSP[S] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( cTEnc == null ) {
final String msg = MessageFormat . format ( HTTP_EX_3 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR6Mutator]MSP[N] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( cTEnc == null ) {
String calculateHttpEncoding ( final String httpContentType , final String bomEnc , final String xmlGuessEnc , final String xmlEnc , final boolean lenient ) throws IOException { if ( lenient && xmlEnc != null ) { MST[rv.ROR5Mutator]MSP[N] return xmlEnc ; } final String cTMime = getContentTypeMime ( httpContentType ) ;
( mime . equals ( lr_2 ) || mime . equals ( lr_13 ) || MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] mime . startsWith ( lr_14 ) && mime . endsWith ( lr_12 ) ) ; }
} catch ( final XmlStreamReaderException ex ) { if ( lenient ) { return doLenientDetection ( httpContentType , ex ) ; MST[ReturnValsMutator]MSP[N] } throw ex ; } } private String doLenientDetection ( String httpContentType , XmlStreamReaderException ex ) throws IOException {
if ( guessedEnc != null ) { final byte [] bytes = new byte [ BUFFER_SIZE ] ; MST[rv.CRCR5Mutator]MSP[N] is . mark ( BUFFER_SIZE ) ; int offset = 0 ; int max = BUFFER_SIZE ; int c = is . read ( bytes , offset , max ) ;
if ( cTEnc . equals ( UTF_32 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_32 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[InlineConstantMutator]MSP[N]
mime . equals ( lr_9 ) || mime . equals ( lr_10 ) || mime . startsWith ( lr_11 ) && mime . endsWith ( lr_12 ) ) ; MST[rv.ROR5Mutator]MSP[N] } static boolean isTextXml ( final String mime ) { return mime != null &&
if ( xmlGuessEnc == null || xmlEnc == null ) { return defaultEncoding == null ? UTF_8 : defaultEncoding ; MST[ReturnValsMutator]MSP[N] } if ( xmlEnc . equals ( UTF_16 ) && ( xmlGuessEnc . equals ( UTF_16BE ) || xmlGuessEnc . equals ( UTF_16LE ) ) ) { return xmlGuessEnc ;
if ( cTEnc . equals ( UTF_16 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_16 ) ) { MST[rv.ROR5Mutator]MSP[N] return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ;
int firstGT = - 1 ; MST[InlineConstantMutator]MSP[N] String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ;
if ( appXml ) { return calculateRawEncoding ( bomEnc , xmlGuessEnc , xmlEnc ) ; } return defaultEncoding == null ? US_ASCII : defaultEncoding ; } if ( cTEnc . equals ( UTF_16BE ) || cTEnc . equals ( UTF_16LE ) ) { MST[NegateConditionalsMutator]MSP[N] if ( bomEnc != null ) {
encoding = encoding . substring ( 1 , encoding . length () - 1 ) ; MST[experimental.NakedReceiverMutator]MSP[N] } } } return encoding ; } static boolean isAppXml ( final String mime ) { return mime != null && ( mime . equals ( lr_8 ) ||
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[InlineConstantMutator]MSP[N] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
if ( guessedEnc != null ) { final byte [] bytes = new byte [ BUFFER_SIZE ] ; is . mark ( BUFFER_SIZE ) ; int offset = 0 ; int max = BUFFER_SIZE ; MST[rv.CRCR4Mutator]MSP[N] int c = is . read ( bytes , offset , max ) ;
ex . getXmlGuessEncoding () , ex . getXmlEncoding () , true ) ; MST[NonVoidMethodCallMutator]MSP[N] } catch ( final XmlStreamReaderException ex2 ) { ex = ex2 ; } } String encoding = ex . getXmlEncoding () ; if ( encoding == null ) { encoding = ex . getContentTypeEncoding () ; }
final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR1Mutator]MSP[N] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_32 ) && ! xmlEnc . equals ( bomEnc ) ) { MST[rv.ROR4Mutator]MSP[N] final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
mime . equals ( lr_9 ) || mime . equals ( lr_10 ) || mime . startsWith ( lr_11 ) && mime . endsWith ( lr_12 ) ) ; MST[rv.CRCR5Mutator]MSP[N] } static boolean isTextXml ( final String mime ) { return mime != null &&
if ( cTEnc . equals ( UTF_32 ) ) { MST[NegateConditionalsMutator]MSP[N] if ( bomEnc != null && bomEnc . startsWith ( UTF_32 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ;
final String postMime = httpContentType . substring ( i + 1 ) ; final Matcher m = CHARSET_PATTERN . matcher ( postMime ) ; encoding = m . find () ? m . group ( 1 ) : null ; MST[rv.CRCR2Mutator]MSP[N]
if ( cTEnc . equals ( UTF_16 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_16 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[NonVoidMethodCallMutator]MSP[N]
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( xmlEnc != null && ! xmlEnc . equals ( UTF_8 ) ) { MST[rv.ROR1Mutator]MSP[N] final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
final String postMime = httpContentType . substring ( i + 1 ) ; final Matcher m = CHARSET_PATTERN . matcher ( postMime ) ; encoding = m . find () ? m . group ( 1 ) : null ; MST[rv.ROR4Mutator]MSP[N]
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } final String msg = MessageFormat . format ( RAW_EX_2 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[InlineConstantMutator]MSP[S] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR5Mutator]MSP[N] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR5Mutator]MSP[S] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } if ( bomEnc . equals ( UTF_16BE ) || bomEnc . equals ( UTF_16LE ) ) { if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( bomEnc ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR2Mutator]MSP[N] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
if ( cTEnc . equals ( UTF_16 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_16 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[InlineConstantMutator]MSP[N]
final int i = httpContentType . indexOf ( lr_3 ) ; if ( i >= 0 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] mime = httpContentType . substring ( 0 , i ) ; } else { mime = httpContentType ; } mime = mime . trim () ; } return mime ; }
} return xmlEnc ; } if ( bomEnc . equals ( UTF_8 ) ) { if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( UTF_8 ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR5Mutator]MSP[S]
final String msg = MessageFormat . format ( HTTP_EX_3 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[InlineConstantMutator]MSP[S] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( cTEnc == null ) {
final String cTEnc = getContentTypeEncoding ( httpContentType ) ; final boolean appXml = isAppXml ( cTMime ) ; final boolean textXml = isTextXml ( cTMime ) ; if ( ! appXml && ! textXml ) { MST[rv.UOI1Mutator]MSP[S]
} catch ( final XmlStreamReaderException ex ) { if ( lenient ) { MST[rv.ROR4Mutator]MSP[N] return doLenientDetection ( httpContentType , ex ) ; } throw ex ; } } private String doLenientDetection ( String httpContentType , XmlStreamReaderException ex ) throws IOException {
if ( xmlGuessEnc == null || xmlEnc == null ) { return defaultEncoding == null ? UTF_8 : defaultEncoding ; } if ( xmlEnc . equals ( UTF_16 ) && ( xmlGuessEnc . equals ( UTF_16BE ) || xmlGuessEnc . equals ( UTF_16LE ) ) ) { MST[rv.ROR4Mutator]MSP[S] return xmlGuessEnc ;
( mime . equals ( lr_2 ) || mime . equals ( lr_13 ) || mime . startsWith ( lr_14 ) && mime . endsWith ( lr_12 ) ) ; MST[rv.CRCR1Mutator]MSP[N] }
if ( encoding == null ) { encoding = defaultEncoding == null ? UTF_8 : defaultEncoding ; } return encoding ; } String calculateRawEncoding ( final String bomEnc , final String xmlGuessEnc , final String xmlEnc ) throws IOException { if ( bomEnc == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_32 ) && ! xmlEnc . equals ( bomEnc ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR5Mutator]MSP[S]
} catch ( final XmlStreamReaderException ex ) { if ( lenient ) { return doLenientDetection ( httpContentType , ex ) ; MST[ArgumentPropagationMutator]MSP[N] } throw ex ; } } private String doLenientDetection ( String httpContentType , XmlStreamReaderException ex ) throws IOException {
} return xmlEnc ; } if ( bomEnc . equals ( UTF_8 ) ) { MST[rv.ROR4Mutator]MSP[N] if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( UTF_8 ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
static String getContentTypeEncoding ( final String httpContentType ) { String encoding = null ; if ( httpContentType != null ) { final int i = httpContentType . indexOf ( lr_3 ) ; if ( i > - 1 ) { MST[rv.CRCR2Mutator]MSP[S]
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { MST[rv.UOI2Mutator]MSP[N] offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ;
encoding = encoding . substring ( 1 , encoding . length () - 1 ) ; } } } return encoding ; } static boolean isAppXml ( final String mime ) { return mime != null && ( mime . equals ( lr_8 ) || MST[rv.ROR5Mutator]MSP[N]
mime . equals ( lr_9 ) || mime . equals ( lr_10 ) || mime . startsWith ( lr_11 ) && mime . endsWith ( lr_12 ) ) ; MST[InlineConstantMutator]MSP[N] } static boolean isTextXml ( final String mime ) { return mime != null &&
final String msg = MessageFormat . format ( HTTP_EX_3 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR3Mutator]MSP[N] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( cTEnc == null ) {
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { MST[rv.ABSMutator]MSP[N] offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ;
throw new IOException ( lr_6 + offset + lr_7 ) ; } final int bytesRead = offset ; if ( bytesRead > 0 ) { is . reset () ; final BufferedReader bReader = new BufferedReader ( new StringReader ( MST[rv.AOD1Mutator]MSP[N]
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_32 ) && ! xmlEnc . equals ( bomEnc ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR2Mutator]MSP[S]
final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR6Mutator]MSP[S] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR1Mutator]MSP[N] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
if ( cTEnc . equals ( UTF_32 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_32 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR2Mutator]MSP[N]
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { offset += c ; MST[rv.UOI4Mutator]MSP[N] max -= c ; c = is . read ( bytes , offset , max ) ;
throw new IOException ( lr_6 + offset + lr_7 ) ; } final int bytesRead = offset ; if ( bytesRead > 0 ) { is . reset () ; final BufferedReader bReader = new BufferedReader ( new StringReader ( MST[rv.CRCR6Mutator]MSP[N]
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } if ( bomEnc . equals ( UTF_16BE ) || bomEnc . equals ( UTF_16LE ) ) { MST[rv.ROR3Mutator]MSP[N] if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( bomEnc ) ) {
encoding = encoding . substring ( 1 , encoding . length () - 1 ) ; MST[rv.CRCR5Mutator]MSP[N] } } } return encoding ; } static boolean isAppXml ( final String mime ) { return mime != null && ( mime . equals ( lr_8 ) ||
throw new IOException ( lr_6 + offset + lr_7 ) ; } final int bytesRead = offset ; MST[rv.ABSMutator]MSP[N] if ( bytesRead > 0 ) { is . reset () ; final BufferedReader bReader = new BufferedReader ( new StringReader (
if ( cTEnc . equals ( UTF_32 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_32 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR5Mutator]MSP[N]
if ( cTEnc . equals ( UTF_16 ) ) { MST[rv.ROR4Mutator]MSP[N] if ( bomEnc != null && bomEnc . startsWith ( UTF_16 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ;
mime . equals ( lr_9 ) || MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] mime . equals ( lr_10 ) || mime . startsWith ( lr_11 ) && mime . endsWith ( lr_12 ) ) ; } static boolean isTextXml ( final String mime ) { return mime != null &&
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ; MST[rv.UOI3Mutator]MSP[N]
static String getContentTypeEncoding ( final String httpContentType ) { String encoding = null ; if ( httpContentType != null ) { final int i = httpContentType . indexOf ( lr_3 ) ; if ( i > - 1 ) { MST[rv.UOI2Mutator]MSP[S]
ex . getXmlGuessEncoding () , ex . getXmlEncoding () , true ) ; } catch ( final XmlStreamReaderException ex2 ) { ex = ex2 ; } } String encoding = ex . getXmlEncoding () ; if ( encoding == null ) { encoding = ex . getContentTypeEncoding () ; MST[NonVoidMethodCallMutator]MSP[S] }
final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[InlineConstantMutator]MSP[N] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
final String postMime = httpContentType . substring ( i + 1 ) ; MST[rv.CRCR4Mutator]MSP[S] final Matcher m = CHARSET_PATTERN . matcher ( postMime ) ; encoding = m . find () ? m . group ( 1 ) : null ;
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( xmlEnc != null && ! xmlEnc . equals ( UTF_8 ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR5Mutator]MSP[N]
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { MST[InlineConstantMutator]MSP[N] offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ;
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( xmlEnc != null && ! xmlEnc . equals ( UTF_8 ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR2Mutator]MSP[N]
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { MST[rv.UOI1Mutator]MSP[N] offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ;
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } if ( bomEnc . equals ( UTF_32BE ) || bomEnc . equals ( UTF_32LE ) ) { if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( bomEnc ) ) { MST[rv.ROR1Mutator]MSP[N]
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } if ( bomEnc . equals ( UTF_32BE ) || bomEnc . equals ( UTF_32LE ) ) { if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( bomEnc ) ) { MST[rv.ROR4Mutator]MSP[N]
encoding = encoding != null ? encoding . toUpperCase ( Locale . ROOT ) : null ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } } return encoding ; } private static String getXmlProlog ( final InputStream is , final String guessedEnc ) throws IOException { String encoding = null ;
if ( guessedEnc != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] final byte [] bytes = new byte [ BUFFER_SIZE ] ; is . mark ( BUFFER_SIZE ) ; int offset = 0 ; int max = BUFFER_SIZE ; int c = is . read ( bytes , offset , max ) ;
throw new IOException ( lr_6 + offset + lr_7 ) ; } final int bytesRead = offset ; MST[rv.UOI1Mutator]MSP[N] if ( bytesRead > 0 ) { is . reset () ; final BufferedReader bReader = new BufferedReader ( new StringReader (
if ( cTEnc . equals ( UTF_16 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_16 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR1Mutator]MSP[N]
encoding = encoding . substring ( 1 , encoding . length () - 1 ) ; MST[rv.CRCR2Mutator]MSP[N] } } } return encoding ; } static boolean isAppXml ( final String mime ) { return mime != null && ( mime . equals ( lr_8 ) ||
return reader . read ( buf , offset , len ) ; MST[rv.UOI1Mutator]MSP[S] } @Override public void close () throws IOException { reader . close () ; } private String doRawStream ( final BOMInputStream bom , final BOMInputStream pis , final boolean lenient ) throws IOException {
final String bomEnc = bom . getBOMCharsetName () ; final String xmlGuessEnc = pis . getBOMCharsetName () ; final String xmlEnc = getXmlProlog ( pis , xmlGuessEnc ) ; MST[NonVoidMethodCallMutator]MSP[N] try { return calculateRawEncoding ( bomEnc , xmlGuessEnc , xmlEnc ) ; } catch ( final XmlStreamReaderException ex ) {
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } final String msg = MessageFormat . format ( RAW_EX_2 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR3Mutator]MSP[S] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[InlineConstantMutator]MSP[N] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
if ( xmlGuessEnc == null || xmlEnc == null ) { return defaultEncoding == null ? UTF_8 : defaultEncoding ; } if ( xmlEnc . equals ( UTF_16 ) && MST[rv.ROR2Mutator]MSP[S] ( xmlGuessEnc . equals ( UTF_16BE ) || xmlGuessEnc . equals ( UTF_16LE ) ) ) { return xmlGuessEnc ;
encoding = encoding . substring ( 1 , encoding . length () - 1 ) ; } } } return encoding ; } static boolean isAppXml ( final String mime ) { return mime != null && ( mime . equals ( lr_8 ) || MST[NegateConditionalsMutator]MSP[N]
mime . equals ( lr_9 ) || mime . equals ( lr_10 ) || MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] mime . startsWith ( lr_11 ) && mime . endsWith ( lr_12 ) ) ; } static boolean isTextXml ( final String mime ) { return mime != null &&
if ( guessedEnc != null ) { final byte [] bytes = new byte [ BUFFER_SIZE ] ; is . mark ( BUFFER_SIZE ) ; int offset = 0 ; int max = BUFFER_SIZE ; int c = is . read ( bytes , offset , max ) ; MST[rv.UOI1Mutator]MSP[N]
public String getDefaultEncoding () { return defaultEncoding ; } public String getEncoding () { return encoding ; MST[EmptyObjectReturnValsMutator]MSP[N] } @Override public int read ( final char [] buf , final int offset , final int len ) throws IOException {
return reader . read ( buf , offset , len ) ; } @Override public void close () throws IOException { reader . close () ; MST[VoidMethodCallMutator]MSP[S] } private String doRawStream ( final BOMInputStream bom , final BOMInputStream pis , final boolean lenient ) throws IOException {
if ( guessedEnc != null ) { final byte [] bytes = new byte [ BUFFER_SIZE ] ; is . mark ( BUFFER_SIZE ) ; int offset = 0 ; int max = BUFFER_SIZE ; int c = is . read ( bytes , offset , max ) ; MST[rv.ABSMutator]MSP[N]
final String msg = MessageFormat . format ( HTTP_EX_3 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR6Mutator]MSP[S] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( cTEnc == null ) {
final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR3Mutator]MSP[S] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_16 ) && ! xmlEnc . equals ( bomEnc ) ) { MST[rv.ROR3Mutator]MSP[S] final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[InlineConstantMutator]MSP[N] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
if ( xmlGuessEnc == null || xmlEnc == null ) { return defaultEncoding == null ? UTF_8 : defaultEncoding ; MST[EmptyObjectReturnValsMutator]MSP[N] } if ( xmlEnc . equals ( UTF_16 ) && ( xmlGuessEnc . equals ( UTF_16BE ) || xmlGuessEnc . equals ( UTF_16LE ) ) ) { return xmlGuessEnc ;
xmlProlog = new String ( bytes , 0 , offset , guessedEnc ) ; firstGT = xmlProlog . indexOf ( '>' ) ; } if ( firstGT == - 1 ) { MST[rv.CRCR2Mutator]MSP[N] if ( c == - 1 ) { throw new IOException ( lr_5 ) ; }
if ( cTEnc . equals ( UTF_16 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_16 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR3Mutator]MSP[N]
xmlProlog = new String ( bytes , 0 , offset , guessedEnc ) ; MST[rv.CRCR5Mutator]MSP[N] firstGT = xmlProlog . indexOf ( '>' ) ; } if ( firstGT == - 1 ) { if ( c == - 1 ) { throw new IOException ( lr_5 ) ; }
if ( httpContentType != null && httpContentType . startsWith ( lr_1 ) ) { httpContentType = httpContentType . substring ( lr_1 . length () ) ; httpContentType = lr_2 + httpContentType ; try { return calculateHttpEncoding ( httpContentType , ex . getBomEncoding () , MST[NonVoidMethodCallMutator]MSP[N]
if ( cTEnc . equals ( UTF_16 ) ) { MST[rv.ROR1Mutator]MSP[N] if ( bomEnc != null && bomEnc . startsWith ( UTF_16 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ;
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } final String msg = MessageFormat . format ( RAW_EX_2 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR1Mutator]MSP[S] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
} return xmlEnc ; } if ( bomEnc . equals ( UTF_8 ) ) { if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( UTF_8 ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR2Mutator]MSP[S]
if ( cTEnc . equals ( UTF_32 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_32 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[InlineConstantMutator]MSP[N]
if ( xmlGuessEnc == null || xmlEnc == null ) { return defaultEncoding == null ? UTF_8 : defaultEncoding ; } if ( xmlEnc . equals ( UTF_16 ) && MST[rv.ROR5Mutator]MSP[S] ( xmlGuessEnc . equals ( UTF_16BE ) || xmlGuessEnc . equals ( UTF_16LE ) ) ) { return xmlGuessEnc ;
( mime . equals ( lr_2 ) || mime . equals ( lr_13 ) || mime . startsWith ( lr_14 ) && mime . endsWith ( lr_12 ) ) ; MST[rv.ROR4Mutator]MSP[S] }
( mime . equals ( lr_2 ) || mime . equals ( lr_13 ) || MST[rv.ROR2Mutator]MSP[N] mime . startsWith ( lr_14 ) && mime . endsWith ( lr_12 ) ) ; }
if ( xmlGuessEnc == null || xmlEnc == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return defaultEncoding == null ? UTF_8 : defaultEncoding ; } if ( xmlEnc . equals ( UTF_16 ) && ( xmlGuessEnc . equals ( UTF_16BE ) || xmlGuessEnc . equals ( UTF_16LE ) ) ) { return xmlGuessEnc ;
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { offset += c ; max -= c ; MST[rv.AOR1Mutator]MSP[N] c = is . read ( bytes , offset , max ) ;
final String cTEnc = getContentTypeEncoding ( httpContentType ) ; final boolean appXml = isAppXml ( cTMime ) ; final boolean textXml = isTextXml ( cTMime ) ; if ( ! appXml && ! textXml ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
final int i = httpContentType . indexOf ( lr_3 ) ; if ( i >= 0 ) { mime = httpContentType . substring ( 0 , i ) ; MST[rv.CRCR1Mutator]MSP[N] } else { mime = httpContentType ; } mime = mime . trim () ; } return mime ; }
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } if ( bomEnc . equals ( UTF_16BE ) || bomEnc . equals ( UTF_16LE ) ) { if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( bomEnc ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S]
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR1Mutator]MSP[N] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
if ( httpContentType != null && httpContentType . startsWith ( lr_1 ) ) { httpContentType = httpContentType . substring ( lr_1 . length () ) ; httpContentType = lr_2 + httpContentType ; MST[experimental.NakedReceiverMutator]MSP[N] try { return calculateHttpEncoding ( httpContentType , ex . getBomEncoding () ,
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ; MST[rv.UOI4Mutator]MSP[N]
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR5Mutator]MSP[N] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_32 ) && ! xmlEnc . equals ( bomEnc ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR4Mutator]MSP[N]
ex . getXmlGuessEncoding () , ex . getXmlEncoding () , true ) ; } catch ( final XmlStreamReaderException ex2 ) { ex = ex2 ; } } String encoding = ex . getXmlEncoding () ; if ( encoding == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] encoding = ex . getContentTypeEncoding () ; }
final int i = httpContentType . indexOf ( lr_3 ) ; if ( i >= 0 ) { MST[rv.ROR5Mutator]MSP[N] mime = httpContentType . substring ( 0 , i ) ; } else { mime = httpContentType ; } mime = mime . trim () ; } return mime ; }
if ( cTEnc . equals ( UTF_16 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_16 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[InlineConstantMutator]MSP[N]
throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( cTEnc . equals ( UTF_32BE ) || cTEnc . equals ( UTF_32LE ) ) { MST[NegateConditionalsMutator]MSP[N] if ( bomEnc != null ) {
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_32 ) && ! xmlEnc . equals ( bomEnc ) ) { MST[rv.ROR1Mutator]MSP[N] final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
if ( xmlGuessEnc == null || xmlEnc == null ) { return defaultEncoding == null ? UTF_8 : defaultEncoding ; } if ( xmlEnc . equals ( UTF_16 ) && ( xmlGuessEnc . equals ( UTF_16BE ) || xmlGuessEnc . equals ( UTF_16LE ) ) ) { MST[rv.ROR4Mutator]MSP[S] return xmlGuessEnc ;
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( xmlEnc != null && ! xmlEnc . equals ( UTF_8 ) ) { MST[NegateConditionalsMutator]MSP[N] final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
if ( guessedEnc != null ) { final byte [] bytes = new byte [ BUFFER_SIZE ] ; is . mark ( BUFFER_SIZE ) ; int offset = 0 ; int max = BUFFER_SIZE ; int c = is . read ( bytes , offset , max ) ; MST[rv.UOI2Mutator]MSP[N]
} return xmlEnc ; } if ( bomEnc . equals ( UTF_8 ) ) { if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( UTF_8 ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR5Mutator]MSP[S]
if ( appXml ) { MST[rv.ROR1Mutator]MSP[N] return calculateRawEncoding ( bomEnc , xmlGuessEnc , xmlEnc ) ; } return defaultEncoding == null ? US_ASCII : defaultEncoding ; } if ( cTEnc . equals ( UTF_16BE ) || cTEnc . equals ( UTF_16LE ) ) { if ( bomEnc != null ) {
( mime . equals ( lr_2 ) || MST[rv.ROR3Mutator]MSP[S] mime . equals ( lr_13 ) || mime . startsWith ( lr_14 ) && mime . endsWith ( lr_12 ) ) ; }
if ( appXml ) { return calculateRawEncoding ( bomEnc , xmlGuessEnc , xmlEnc ) ; } return defaultEncoding == null ? US_ASCII : defaultEncoding ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } if ( cTEnc . equals ( UTF_16BE ) || cTEnc . equals ( UTF_16LE ) ) { if ( bomEnc != null ) {
} return xmlEnc ; } if ( bomEnc . equals ( UTF_8 ) ) { if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( UTF_8 ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[InlineConstantMutator]MSP[S]
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_32 ) && ! xmlEnc . equals ( bomEnc ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR5Mutator]MSP[S]
} return xmlEnc ; } if ( bomEnc . equals ( UTF_8 ) ) { if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( UTF_8 ) ) { MST[rv.ROR1Mutator]MSP[N] final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
final String msg = MessageFormat . format ( HTTP_EX_3 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR3Mutator]MSP[N] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( cTEnc == null ) {
( mime . equals ( lr_2 ) || mime . equals ( lr_13 ) || MST[rv.ROR5Mutator]MSP[N] mime . startsWith ( lr_14 ) && mime . endsWith ( lr_12 ) ) ; }
if ( cTEnc . equals ( UTF_32 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_32 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR1Mutator]MSP[N]
mime . equals ( lr_9 ) || mime . equals ( lr_10 ) || mime . startsWith ( lr_11 ) && mime . endsWith ( lr_12 ) ) ; MST[InlineConstantMutator]MSP[N] } static boolean isTextXml ( final String mime ) { return mime != null &&
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { offset += c ; MST[rv.UOI1Mutator]MSP[N] max -= c ; c = is . read ( bytes , offset , max ) ;
mime . equals ( lr_9 ) || mime . equals ( lr_10 ) || MST[NonVoidMethodCallMutator]MSP[N] mime . startsWith ( lr_11 ) && mime . endsWith ( lr_12 ) ) ; } static boolean isTextXml ( final String mime ) { return mime != null &&
if ( lenient ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] return doLenientDetection ( null , ex ) ; } throw ex ; } } private String doHttpStream ( final BOMInputStream bom , final BOMInputStream pis , final String httpContentType , final boolean lenient ) throws IOException {
final int i = httpContentType . indexOf ( lr_3 ) ; if ( i >= 0 ) { MST[NegateConditionalsMutator]MSP[N] mime = httpContentType . substring ( 0 , i ) ; } else { mime = httpContentType ; } mime = mime . trim () ; } return mime ; }
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR5Mutator]MSP[N] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
if ( cTEnc . equals ( UTF_32 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_32 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR5Mutator]MSP[N]
throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( cTEnc . equals ( UTF_32BE ) || cTEnc . equals ( UTF_32LE ) ) { MST[rv.ROR5Mutator]MSP[N] if ( bomEnc != null ) {
xmlProlog = new String ( bytes , 0 , offset , guessedEnc ) ; MST[InlineConstantMutator]MSP[N] firstGT = xmlProlog . indexOf ( '>' ) ; } if ( firstGT == - 1 ) { if ( c == - 1 ) { throw new IOException ( lr_5 ) ; }
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } if ( bomEnc . equals ( UTF_16BE ) || bomEnc . equals ( UTF_16LE ) ) { if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( bomEnc ) ) { MST[NonVoidMethodCallMutator]MSP[N]
final String postMime = httpContentType . substring ( i + 1 ) ; MST[rv.UOI4Mutator]MSP[S] final Matcher m = CHARSET_PATTERN . matcher ( postMime ) ; encoding = m . find () ? m . group ( 1 ) : null ;
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { offset += c ; MST[rv.AOD2Mutator]MSP[N] max -= c ; c = is . read ( bytes , offset , max ) ;
if ( guessedEnc != null ) { final byte [] bytes = new byte [ BUFFER_SIZE ] ; is . mark ( BUFFER_SIZE ) ; int offset = 0 ; int max = BUFFER_SIZE ; int c = is . read ( bytes , offset , max ) ; MST[ArgumentPropagationMutator]MSP[N]
if ( encoding == null ) { encoding = defaultEncoding == null ? UTF_8 : defaultEncoding ; MST[NegateConditionalsMutator]MSP[N] } return encoding ; } String calculateRawEncoding ( final String bomEnc , final String xmlGuessEnc , final String xmlEnc ) throws IOException { if ( bomEnc == null ) {
encoding = encoding . substring ( 1 , encoding . length () - 1 ) ; MST[rv.AOR3Mutator]MSP[N] } } } return encoding ; } static boolean isAppXml ( final String mime ) { return mime != null && ( mime . equals ( lr_8 ) ||
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { MST[rv.CRCR4Mutator]MSP[N] offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ;
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { MST[rv.CRCR5Mutator]MSP[N] offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ;
final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[InlineConstantMutator]MSP[S] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { MST[rv.CRCR6Mutator]MSP[N] offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ;
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[ConstructorCallMutator]MSP[N] } return bomEnc ; } if ( bomEnc . equals ( UTF_16BE ) || bomEnc . equals ( UTF_16LE ) ) { if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( bomEnc ) ) {
if ( encoding == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] encoding = defaultEncoding == null ? UTF_8 : defaultEncoding ; } return encoding ; } String calculateRawEncoding ( final String bomEnc , final String xmlGuessEnc , final String xmlEnc ) throws IOException { if ( bomEnc == null ) {
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( xmlEnc != null && ! xmlEnc . equals ( UTF_8 ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR5Mutator]MSP[N]
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( xmlEnc != null && ! xmlEnc . equals ( UTF_8 ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR2Mutator]MSP[N]
if ( appXml ) { return calculateRawEncoding ( bomEnc , xmlGuessEnc , xmlEnc ) ; } return defaultEncoding == null ? US_ASCII : defaultEncoding ; } if ( cTEnc . equals ( UTF_16BE ) || cTEnc . equals ( UTF_16LE ) ) { MST[rv.ROR1Mutator]MSP[N] if ( bomEnc != null ) {
xmlProlog = new String ( bytes , 0 , offset , guessedEnc ) ; MST[rv.UOI3Mutator]MSP[N] firstGT = xmlProlog . indexOf ( '>' ) ; } if ( firstGT == - 1 ) { if ( c == - 1 ) { throw new IOException ( lr_5 ) ; }
throw new IOException ( lr_6 + offset + lr_7 ) ; } final int bytesRead = offset ; if ( bytesRead > 0 ) { MST[rv.ABSMutator]MSP[N] is . reset () ; final BufferedReader bReader = new BufferedReader ( new StringReader (
if ( httpContentType != null && httpContentType . startsWith ( lr_1 ) ) { httpContentType = httpContentType . substring ( lr_1 . length () ) ; httpContentType = lr_2 + httpContentType ; MST[ConstructorCallMutator]MSP[S] try { return calculateHttpEncoding ( httpContentType , ex . getBomEncoding () ,
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } final String msg = MessageFormat . format ( RAW_EX_2 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[NonVoidMethodCallMutator]MSP[N] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR5Mutator]MSP[N] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
if ( cTEnc . equals ( UTF_32 ) ) { MST[rv.ROR1Mutator]MSP[N] if ( bomEnc != null && bomEnc . startsWith ( UTF_32 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ;
final String cTEnc = getContentTypeEncoding ( httpContentType ) ; final boolean appXml = isAppXml ( cTMime ) ; final boolean textXml = isTextXml ( cTMime ) ; if ( ! appXml && ! textXml ) { MST[rv.ROR2Mutator]MSP[N]
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[InlineConstantMutator]MSP[N] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
final String postMime = httpContentType . substring ( i + 1 ) ; final Matcher m = CHARSET_PATTERN . matcher ( postMime ) ; encoding = m . find () ? m . group ( 1 ) : null ; MST[rv.CRCR5Mutator]MSP[N]
encoding = encoding . substring ( 1 , encoding . length () - 1 ) ; } } } return encoding ; } static boolean isAppXml ( final String mime ) { return mime != null && MST[BooleanTrueReturnValsMutator]MSP[N] ( mime . equals ( lr_8 ) ||
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } if ( bomEnc . equals ( UTF_32BE ) || bomEnc . equals ( UTF_32LE ) ) { MST[rv.ROR1Mutator]MSP[N] if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( bomEnc ) ) {
if ( encoding == null ) { encoding = defaultEncoding == null ? UTF_8 : defaultEncoding ; MST[rv.ROR5Mutator]MSP[N] } return encoding ; } String calculateRawEncoding ( final String bomEnc , final String xmlGuessEnc , final String xmlEnc ) throws IOException { if ( bomEnc == null ) {
if ( httpContentType != null && httpContentType . startsWith ( lr_1 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] httpContentType = httpContentType . substring ( lr_1 . length () ) ; httpContentType = lr_2 + httpContentType ; try { return calculateHttpEncoding ( httpContentType , ex . getBomEncoding () ,
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[InlineConstantMutator]MSP[N] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
if ( guessedEnc != null ) { final byte [] bytes = new byte [ BUFFER_SIZE ] ; is . mark ( BUFFER_SIZE ) ; MST[rv.CRCR4Mutator]MSP[N] int offset = 0 ; int max = BUFFER_SIZE ; int c = is . read ( bytes , offset , max ) ;
final String msg = MessageFormat . format ( HTTP_EX_3 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR6Mutator]MSP[S] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( cTEnc == null ) {
if ( guessedEnc != null ) { final byte [] bytes = new byte [ BUFFER_SIZE ] ; MST[rv.CRCR2Mutator]MSP[N] is . mark ( BUFFER_SIZE ) ; int offset = 0 ; int max = BUFFER_SIZE ; int c = is . read ( bytes , offset , max ) ;
mime . equals ( lr_9 ) || mime . equals ( lr_10 ) || mime . startsWith ( lr_11 ) && mime . endsWith ( lr_12 ) ) ; MST[rv.ROR1Mutator]MSP[S] } static boolean isTextXml ( final String mime ) { return mime != null &&
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_16 ) && ! xmlEnc . equals ( bomEnc ) ) { MST[rv.ROR3Mutator]MSP[S] final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( xmlEnc != null && ! xmlEnc . equals ( UTF_8 ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR4Mutator]MSP[N]
xmlProlog . substring ( 0 , firstGT + 1 ) ) ) ; final StringBuffer prolog = new StringBuffer () ; String line = bReader . readLine () ; while ( line != null ) { prolog . append ( line ) ; MST[NonVoidMethodCallMutator]MSP[N] line = bReader . readLine () ;
final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR3Mutator]MSP[S] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
if ( cTEnc . equals ( UTF_32 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_32 ) ) { MST[NegateConditionalsMutator]MSP[N] return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ;
final String bomEnc = bom . getBOMCharsetName () ; final String xmlGuessEnc = pis . getBOMCharsetName () ; final String xmlEnc = getXmlProlog ( pis , xmlGuessEnc ) ; MST[ArgumentPropagationMutator]MSP[N] try { return calculateHttpEncoding ( httpContentType , bomEnc , xmlGuessEnc , xmlEnc , lenient ) ;
if ( cTEnc . equals ( UTF_16 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_16 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR5Mutator]MSP[N]
encoding = encoding . substring ( 1 , encoding . length () - 1 ) ; MST[InlineConstantMutator]MSP[N] } } } return encoding ; } static boolean isAppXml ( final String mime ) { return mime != null && ( mime . equals ( lr_8 ) ||
} final Matcher m = ENCODING_PATTERN . matcher ( prolog ) ; if ( m . find () ) { MST[rv.ROR5Mutator]MSP[N] encoding = m . group ( 1 ) . toUpperCase ( Locale . ROOT ) ;
( mime . equals ( lr_2 ) || mime . equals ( lr_13 ) || mime . startsWith ( lr_14 ) && mime . endsWith ( lr_12 ) ) ; MST[rv.ROR4Mutator]MSP[S] }
if ( cTEnc . equals ( UTF_32 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_32 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[InlineConstantMutator]MSP[N]
xmlProlog = new String ( bytes , 0 , offset , guessedEnc ) ; firstGT = xmlProlog . indexOf ( '>' ) ; } if ( firstGT == - 1 ) { MST[rv.UOI2Mutator]MSP[N] if ( c == - 1 ) { throw new IOException ( lr_5 ) ; }
String calculateHttpEncoding ( final String httpContentType , final String bomEnc , final String xmlGuessEnc , final String xmlEnc , final boolean lenient ) throws IOException { if ( lenient && xmlEnc != null ) { return xmlEnc ; } final String cTMime = getContentTypeMime ( httpContentType ) ; MST[ArgumentPropagationMutator]MSP[N]
final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR1Mutator]MSP[N] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
( mime . equals ( lr_2 ) || mime . equals ( lr_13 ) || mime . startsWith ( lr_14 ) && mime . endsWith ( lr_12 ) ) ; MST[rv.CRCR4Mutator]MSP[S] }
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } final String msg = MessageFormat . format ( RAW_EX_2 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[ArgumentPropagationMutator]MSP[S] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_32 ) && ! xmlEnc . equals ( bomEnc ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR1Mutator]MSP[N]
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { offset += c ; max -= c ; MST[MathMutator]MSP[N] c = is . read ( bytes , offset , max ) ;
} catch ( final XmlStreamReaderException ex ) { if ( lenient ) { MST[rv.UOI1Mutator]MSP[S] return doLenientDetection ( httpContentType , ex ) ; } throw ex ; } } private String doLenientDetection ( String httpContentType , XmlStreamReaderException ex ) throws IOException {
mime . equals ( lr_9 ) || mime . equals ( lr_10 ) || mime . startsWith ( lr_11 ) && mime . endsWith ( lr_12 ) ) ; } static boolean isTextXml ( final String mime ) { return mime != null && MST[NegateConditionalsMutator]MSP[N]
final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[NonVoidMethodCallMutator]MSP[N] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR6Mutator]MSP[N] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
if ( cTEnc . equals ( UTF_32 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_32 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR3Mutator]MSP[N]
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { offset += c ; max -= c ; MST[rv.UOI3Mutator]MSP[N] c = is . read ( bytes , offset , max ) ;
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_32 ) && ! xmlEnc . equals ( bomEnc ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
if ( cTEnc . equals ( UTF_16 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_16 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[InlineConstantMutator]MSP[N]
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { MST[rv.ROR1Mutator]MSP[N] offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ;
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_32 ) && ! xmlEnc . equals ( bomEnc ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } if ( bomEnc . equals ( UTF_16BE ) || bomEnc . equals ( UTF_16LE ) ) { MST[NegateConditionalsMutator]MSP[N] if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( bomEnc ) ) {
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; MST[ReturnValsMutator]MSP[N] } if ( bomEnc . equals ( UTF_16BE ) || bomEnc . equals ( UTF_16LE ) ) { if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( bomEnc ) ) {
return reader . read ( buf , offset , len ) ; MST[rv.UOI4Mutator]MSP[S] } @Override public void close () throws IOException { reader . close () ; } private String doRawStream ( final BOMInputStream bom , final BOMInputStream pis , final boolean lenient ) throws IOException {
( mime . equals ( lr_2 ) || mime . equals ( lr_13 ) || mime . startsWith ( lr_14 ) && mime . endsWith ( lr_12 ) ) ; MST[rv.ROR1Mutator]MSP[S] }
( mime . equals ( lr_2 ) || mime . equals ( lr_13 ) || mime . startsWith ( lr_14 ) && mime . endsWith ( lr_12 ) ) ; MST[rv.CRCR3Mutator]MSP[N] }
} catch ( final XmlStreamReaderException ex ) { if ( lenient ) { MST[rv.ROR2Mutator]MSP[S] return doLenientDetection ( httpContentType , ex ) ; } throw ex ; } } private String doLenientDetection ( String httpContentType , XmlStreamReaderException ex ) throws IOException {
encoding = encoding . substring ( 1 , encoding . length () - 1 ) ; MST[rv.AOR4Mutator]MSP[N] } } } return encoding ; } static boolean isAppXml ( final String mime ) { return mime != null && ( mime . equals ( lr_8 ) ||
} catch ( final XmlStreamReaderException ex ) { if ( lenient ) { return doLenientDetection ( httpContentType , ex ) ; MST[EmptyObjectReturnValsMutator]MSP[N] } throw ex ; } } private String doLenientDetection ( String httpContentType , XmlStreamReaderException ex ) throws IOException {
xmlProlog . substring ( 0 , firstGT + 1 ) ) ) ; final StringBuffer prolog = new StringBuffer () ; String line = bReader . readLine () ; while ( line != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] prolog . append ( line ) ; line = bReader . readLine () ;
mime . equals ( lr_9 ) || MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] mime . equals ( lr_10 ) || mime . startsWith ( lr_11 ) && mime . endsWith ( lr_12 ) ) ; } static boolean isTextXml ( final String mime ) { return mime != null &&
} return xmlEnc ; } if ( bomEnc . equals ( UTF_8 ) ) { if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( UTF_8 ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR5Mutator]MSP[S]
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_16 ) && ! xmlEnc . equals ( bomEnc ) ) { MST[rv.ROR5Mutator]MSP[N] final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
if ( cTEnc . equals ( UTF_16 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_16 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR6Mutator]MSP[N]
final String postMime = httpContentType . substring ( i + 1 ) ; MST[rv.AOD1Mutator]MSP[S] final Matcher m = CHARSET_PATTERN . matcher ( postMime ) ; encoding = m . find () ? m . group ( 1 ) : null ;
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR3Mutator]MSP[N] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( xmlEnc != null && ! xmlEnc . equals ( UTF_8 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
} final Matcher m = ENCODING_PATTERN . matcher ( prolog ) ; if ( m . find () ) { encoding = m . group ( 1 ) . toUpperCase ( Locale . ROOT ) ; MST[rv.CRCR5Mutator]MSP[N]
if ( httpContentType != null && httpContentType . startsWith ( lr_1 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] httpContentType = httpContentType . substring ( lr_1 . length () ) ; httpContentType = lr_2 + httpContentType ; try { return calculateHttpEncoding ( httpContentType , ex . getBomEncoding () ,
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { MST[rv.ROR2Mutator]MSP[N] offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ;
mime . equals ( lr_9 ) || mime . equals ( lr_10 ) || MST[rv.ROR2Mutator]MSP[N] mime . startsWith ( lr_11 ) && mime . endsWith ( lr_12 ) ) ; } static boolean isTextXml ( final String mime ) { return mime != null &&
mime . equals ( lr_9 ) || mime . equals ( lr_10 ) || mime . startsWith ( lr_11 ) && mime . endsWith ( lr_12 ) ) ; MST[rv.ROR4Mutator]MSP[N] } static boolean isTextXml ( final String mime ) { return mime != null &&
if ( guessedEnc != null ) { final byte [] bytes = new byte [ BUFFER_SIZE ] ; is . mark ( BUFFER_SIZE ) ; int offset = 0 ; MST[rv.CRCR5Mutator]MSP[N] int max = BUFFER_SIZE ; int c = is . read ( bytes , offset , max ) ;
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR1Mutator]MSP[N] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
if ( lenient ) { MST[rv.UOI1Mutator]MSP[N] return doLenientDetection ( null , ex ) ; } throw ex ; } } private String doHttpStream ( final BOMInputStream bom , final BOMInputStream pis , final String httpContentType , final boolean lenient ) throws IOException {
} catch ( final XmlStreamReaderException ex ) { if ( lenient ) { return doLenientDetection ( httpContentType , ex ) ; MST[NonVoidMethodCallMutator]MSP[N] } throw ex ; } } private String doLenientDetection ( String httpContentType , XmlStreamReaderException ex ) throws IOException {
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_16 ) && ! xmlEnc . equals ( bomEnc ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR4Mutator]MSP[N]
xmlProlog = new String ( bytes , 0 , offset , guessedEnc ) ; firstGT = xmlProlog . indexOf ( '>' ) ; } if ( firstGT == - 1 ) { MST[NegateConditionalsMutator]MSP[N] if ( c == - 1 ) { throw new IOException ( lr_5 ) ; }
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[ArgumentPropagationMutator]MSP[N] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_32 ) && ! xmlEnc . equals ( bomEnc ) ) { MST[NonVoidMethodCallMutator]MSP[N] final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
if ( lenient ) { MST[rv.ROR2Mutator]MSP[N] return doLenientDetection ( null , ex ) ; } throw ex ; } } private String doHttpStream ( final BOMInputStream bom , final BOMInputStream pis , final String httpContentType , final boolean lenient ) throws IOException {
( mime . equals ( lr_2 ) || mime . equals ( lr_13 ) || mime . startsWith ( lr_14 ) && mime . endsWith ( lr_12 ) ) ; MST[rv.CRCR6Mutator]MSP[N] }
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } if ( bomEnc . equals ( UTF_32BE ) || bomEnc . equals ( UTF_32LE ) ) { if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( bomEnc ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
final String msg = MessageFormat . format ( HTTP_EX_3 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR1Mutator]MSP[N] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( cTEnc == null ) {
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { MST[rv.UOI4Mutator]MSP[N] offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ;
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_16 ) && ! xmlEnc . equals ( bomEnc ) ) { MST[NegateConditionalsMutator]MSP[N] final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } if ( bomEnc . equals ( UTF_32BE ) || bomEnc . equals ( UTF_32LE ) ) { if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( bomEnc ) ) { MST[rv.ROR3Mutator]MSP[S]
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { offset += c ; MST[rv.UOI1Mutator]MSP[N] max -= c ; c = is . read ( bytes , offset , max ) ;
throw new IOException ( lr_6 + offset + lr_7 ) ; } final int bytesRead = offset ; MST[rv.UOI4Mutator]MSP[N] if ( bytesRead > 0 ) { is . reset () ; final BufferedReader bReader = new BufferedReader ( new StringReader (
if ( cTEnc . equals ( UTF_16 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_16 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR4Mutator]MSP[N]
encoding = encoding . substring ( 1 , encoding . length () - 1 ) ; MST[rv.CRCR3Mutator]MSP[N] } } } return encoding ; } static boolean isAppXml ( final String mime ) { return mime != null && ( mime . equals ( lr_8 ) ||
if ( cTEnc . equals ( UTF_16 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_16 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR1Mutator]MSP[N]
final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR2Mutator]MSP[N] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
throw new IOException ( lr_6 + offset + lr_7 ) ; } final int bytesRead = offset ; if ( bytesRead > 0 ) { MST[rv.ROR2Mutator]MSP[N] is . reset () ; final BufferedReader bReader = new BufferedReader ( new StringReader (
} final Matcher m = ENCODING_PATTERN . matcher ( prolog ) ; if ( m . find () ) { MST[rv.ROR4Mutator]MSP[N] encoding = m . group ( 1 ) . toUpperCase ( Locale . ROOT ) ;
static String getContentTypeEncoding ( final String httpContentType ) { String encoding = null ; if ( httpContentType != null ) { final int i = httpContentType . indexOf ( lr_3 ) ; if ( i > - 1 ) { MST[rv.ROR5Mutator]MSP[N]
final String cTEnc = getContentTypeEncoding ( httpContentType ) ; final boolean appXml = isAppXml ( cTMime ) ; final boolean textXml = isTextXml ( cTMime ) ; if ( ! appXml && ! textXml ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
} return xmlEnc ; } if ( bomEnc . equals ( UTF_8 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( UTF_8 ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
} return xmlEnc ; } if ( bomEnc . equals ( UTF_8 ) ) { if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( UTF_8 ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR4Mutator]MSP[S]
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_16 ) && ! xmlEnc . equals ( bomEnc ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[InlineConstantMutator]MSP[S]
} return xmlEnc ; } if ( bomEnc . equals ( UTF_8 ) ) { MST[rv.ROR3Mutator]MSP[N] if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( UTF_8 ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
if ( cTEnc . equals ( UTF_32 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_32 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR4Mutator]MSP[N]
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } if ( bomEnc . equals ( UTF_32BE ) || bomEnc . equals ( UTF_32LE ) ) { MST[NonVoidMethodCallMutator]MSP[N] if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( bomEnc ) ) {
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { MST[rv.UOI3Mutator]MSP[N] offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ;
if ( httpContentType != null && httpContentType . startsWith ( lr_1 ) ) { httpContentType = httpContentType . substring ( lr_1 . length () ) ; httpContentType = lr_2 + httpContentType ; MST[NonVoidMethodCallMutator]MSP[S] try { return calculateHttpEncoding ( httpContentType , ex . getBomEncoding () ,
if ( guessedEnc != null ) { final byte [] bytes = new byte [ BUFFER_SIZE ] ; MST[rv.CRCR6Mutator]MSP[N] is . mark ( BUFFER_SIZE ) ; int offset = 0 ; int max = BUFFER_SIZE ; int c = is . read ( bytes , offset , max ) ;
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { MST[rv.ROR5Mutator]MSP[N] offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ;
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_16 ) && ! xmlEnc . equals ( bomEnc ) ) { MST[rv.ROR2Mutator]MSP[N] final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
if ( xmlGuessEnc == null || xmlEnc == null ) { return defaultEncoding == null ? UTF_8 : defaultEncoding ; } if ( xmlEnc . equals ( UTF_16 ) && ( xmlGuessEnc . equals ( UTF_16BE ) || xmlGuessEnc . equals ( UTF_16LE ) ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] return xmlGuessEnc ;
mime . equals ( lr_9 ) || mime . equals ( lr_10 ) || mime . startsWith ( lr_11 ) && mime . endsWith ( lr_12 ) ) ; MST[rv.ROR1Mutator]MSP[S] } static boolean isTextXml ( final String mime ) { return mime != null &&
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR4Mutator]MSP[N] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR3Mutator]MSP[S] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
throw new IOException ( lr_6 + offset + lr_7 ) ; } final int bytesRead = offset ; if ( bytesRead > 0 ) { is . reset () ; final BufferedReader bReader = new BufferedReader ( new StringReader ( MST[rv.CRCR3Mutator]MSP[N]
final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[InlineConstantMutator]MSP[S] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
throw new IOException ( lr_6 + offset + lr_7 ) ; } final int bytesRead = offset ; if ( bytesRead > 0 ) { MST[rv.ROR5Mutator]MSP[N] is . reset () ; final BufferedReader bReader = new BufferedReader ( new StringReader (
} return xmlEnc ; } if ( bomEnc . equals ( UTF_8 ) ) { if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( UTF_8 ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR1Mutator]MSP[S]
} final Matcher m = ENCODING_PATTERN . matcher ( prolog ) ; if ( m . find () ) { MST[rv.ROR1Mutator]MSP[N] encoding = m . group ( 1 ) . toUpperCase ( Locale . ROOT ) ;
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } if ( bomEnc . equals ( UTF_32BE ) || bomEnc . equals ( UTF_32LE ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( bomEnc ) ) {
} return xmlEnc ; } if ( bomEnc . equals ( UTF_8 ) ) { if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( UTF_8 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
final String postMime = httpContentType . substring ( i + 1 ) ; final Matcher m = CHARSET_PATTERN . matcher ( postMime ) ; encoding = m . find () ? m . group ( 1 ) : null ; MST[rv.CRCR6Mutator]MSP[N]
if ( guessedEnc != null ) { final byte [] bytes = new byte [ BUFFER_SIZE ] ; is . mark ( BUFFER_SIZE ) ; int offset = 0 ; int max = BUFFER_SIZE ; int c = is . read ( bytes , offset , max ) ; MST[rv.UOI4Mutator]MSP[N]
if ( xmlGuessEnc == null || xmlEnc == null ) { return defaultEncoding == null ? UTF_8 : defaultEncoding ; } if ( xmlEnc . equals ( UTF_16 ) && ( xmlGuessEnc . equals ( UTF_16BE ) || xmlGuessEnc . equals ( UTF_16LE ) ) ) { MST[rv.ROR3Mutator]MSP[S] return xmlGuessEnc ;
encoding = encoding . substring ( 1 , encoding . length () - 1 ) ; MST[rv.AOR1Mutator]MSP[N] } } } return encoding ; } static boolean isAppXml ( final String mime ) { return mime != null && ( mime . equals ( lr_8 ) ||
final String msg = MessageFormat . format ( HTTP_EX_3 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR5Mutator]MSP[S] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( cTEnc == null ) {
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ;
final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR5Mutator]MSP[S] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
String calculateHttpEncoding ( final String httpContentType , final String bomEnc , final String xmlGuessEnc , final String xmlEnc , final boolean lenient ) throws IOException { if ( lenient && xmlEnc != null ) { return xmlEnc ; } final String cTMime = getContentTypeMime ( httpContentType ) ; MST[NonVoidMethodCallMutator]MSP[N]
final String msg = MessageFormat . format ( HTTP_EX_3 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR4Mutator]MSP[N] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( cTEnc == null ) {
if ( httpContentType != null && httpContentType . startsWith ( lr_1 ) ) { MST[NonVoidMethodCallMutator]MSP[S] httpContentType = httpContentType . substring ( lr_1 . length () ) ; httpContentType = lr_2 + httpContentType ; try { return calculateHttpEncoding ( httpContentType , ex . getBomEncoding () ,
ex . getXmlGuessEncoding () , ex . getXmlEncoding () , true ) ; MST[rv.CRCR6Mutator]MSP[N] } catch ( final XmlStreamReaderException ex2 ) { ex = ex2 ; } } String encoding = ex . getXmlEncoding () ; if ( encoding == null ) { encoding = ex . getContentTypeEncoding () ; }
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { MST[NegateConditionalsMutator]MSP[N] offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ;
throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( cTEnc . equals ( UTF_32BE ) || cTEnc . equals ( UTF_32LE ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] if ( bomEnc != null ) {
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR3Mutator]MSP[N] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR2Mutator]MSP[S] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR1Mutator]MSP[N] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { MST[rv.ROR4Mutator]MSP[N] offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ;
if ( cTEnc . equals ( UTF_16 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_16 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[InlineConstantMutator]MSP[N]
if ( httpContentType != null && httpContentType . startsWith ( lr_1 ) ) { httpContentType = httpContentType . substring ( lr_1 . length () ) ; MST[experimental.NakedReceiverMutator]MSP[N] httpContentType = lr_2 + httpContentType ; try { return calculateHttpEncoding ( httpContentType , ex . getBomEncoding () ,
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } if ( bomEnc . equals ( UTF_16BE ) || bomEnc . equals ( UTF_16LE ) ) { MST[NegateConditionalsMutator]MSP[N] if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( bomEnc ) ) {
throw new IOException ( lr_6 + offset + lr_7 ) ; } final int bytesRead = offset ; if ( bytesRead > 0 ) { MST[NegateConditionalsMutator]MSP[N] is . reset () ; final BufferedReader bReader = new BufferedReader ( new StringReader (
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR5Mutator]MSP[N] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_32 ) && ! xmlEnc . equals ( bomEnc ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
( mime . equals ( lr_2 ) || mime . equals ( lr_13 ) || mime . startsWith ( lr_14 ) && mime . endsWith ( lr_12 ) ) ; MST[rv.ROR1Mutator]MSP[N] }
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_32 ) && ! xmlEnc . equals ( bomEnc ) ) { MST[rv.ROR3Mutator]MSP[S] final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
final String cTEnc = getContentTypeEncoding ( httpContentType ) ; final boolean appXml = isAppXml ( cTMime ) ; final boolean textXml = isTextXml ( cTMime ) ; if ( ! appXml && ! textXml ) { MST[NegateConditionalsMutator]MSP[N]
final String bomEnc = bom . getBOMCharsetName () ; final String xmlGuessEnc = pis . getBOMCharsetName () ; MST[NonVoidMethodCallMutator]MSP[N] final String xmlEnc = getXmlProlog ( pis , xmlGuessEnc ) ; try { return calculateRawEncoding ( bomEnc , xmlGuessEnc , xmlEnc ) ; } catch ( final XmlStreamReaderException ex ) {
final String postMime = httpContentType . substring ( i + 1 ) ; final Matcher m = CHARSET_PATTERN . matcher ( postMime ) ; encoding = m . find () ? m . group ( 1 ) : null ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[S]
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ; MST[NonVoidMethodCallMutator]MSP[N]
if ( xmlGuessEnc == null || xmlEnc == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return defaultEncoding == null ? UTF_8 : defaultEncoding ; } if ( xmlEnc . equals ( UTF_16 ) && ( xmlGuessEnc . equals ( UTF_16BE ) || xmlGuessEnc . equals ( UTF_16LE ) ) ) { return xmlGuessEnc ;
if ( lenient ) { MST[rv.UOI4Mutator]MSP[S] return doLenientDetection ( null , ex ) ; } throw ex ; } } private String doHttpStream ( final BOMInputStream bom , final BOMInputStream pis , final String httpContentType , final boolean lenient ) throws IOException {
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_16 ) && ! xmlEnc . equals ( bomEnc ) ) { MST[rv.ROR5Mutator]MSP[N] final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( xmlEnc != null && ! xmlEnc . equals ( UTF_8 ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR1Mutator]MSP[N]
if ( guessedEnc != null ) { final byte [] bytes = new byte [ BUFFER_SIZE ] ; is . mark ( BUFFER_SIZE ) ; int offset = 0 ; int max = BUFFER_SIZE ; MST[rv.CRCR5Mutator]MSP[N] int c = is . read ( bytes , offset , max ) ;
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_32 ) && ! xmlEnc . equals ( bomEnc ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR2Mutator]MSP[S]
if ( xmlGuessEnc == null || xmlEnc == null ) { return defaultEncoding == null ? UTF_8 : defaultEncoding ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } if ( xmlEnc . equals ( UTF_16 ) && ( xmlGuessEnc . equals ( UTF_16BE ) || xmlGuessEnc . equals ( UTF_16LE ) ) ) { return xmlGuessEnc ;
if ( cTEnc . equals ( UTF_32 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_32 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ;
} final Matcher m = ENCODING_PATTERN . matcher ( prolog ) ; if ( m . find () ) { encoding = m . group ( 1 ) . toUpperCase ( Locale . ROOT ) ; MST[rv.CRCR2Mutator]MSP[N]
static String getContentTypeEncoding ( final String httpContentType ) { String encoding = null ; if ( httpContentType != null ) { final int i = httpContentType . indexOf ( lr_3 ) ; if ( i > - 1 ) { MST[rv.ROR2Mutator]MSP[N]
if ( httpContentType != null && httpContentType . startsWith ( lr_1 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] httpContentType = httpContentType . substring ( lr_1 . length () ) ; httpContentType = lr_2 + httpContentType ; try { return calculateHttpEncoding ( httpContentType , ex . getBomEncoding () ,
if ( cTEnc . equals ( UTF_32 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_32 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR5Mutator]MSP[N]
if ( cTEnc . equals ( UTF_32 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_32 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR1Mutator]MSP[N]
mime . equals ( lr_9 ) || mime . equals ( lr_10 ) || mime . startsWith ( lr_11 ) && mime . endsWith ( lr_12 ) ) ; MST[rv.ROR4Mutator]MSP[N] } static boolean isTextXml ( final String mime ) { return mime != null &&
final String bomEnc = bom . getBOMCharsetName () ; final String xmlGuessEnc = pis . getBOMCharsetName () ; final String xmlEnc = getXmlProlog ( pis , xmlGuessEnc ) ; try { return calculateHttpEncoding ( httpContentType , bomEnc , MST[rv.ABSMutator]MSP[S] xmlGuessEnc , xmlEnc , lenient ) ;
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_16 ) && ! xmlEnc . equals ( bomEnc ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR4Mutator]MSP[N]
final int i = httpContentType . indexOf ( lr_3 ) ; if ( i >= 0 ) { mime = httpContentType . substring ( 0 , i ) ; MST[rv.UOI1Mutator]MSP[S] } else { mime = httpContentType ; } mime = mime . trim () ; } return mime ; }
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; MST[ReturnValsMutator]MSP[N] } final String msg = MessageFormat . format ( RAW_EX_2 , bomEnc , xmlGuessEnc , xmlEnc ) ; throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
final String cTEnc = getContentTypeEncoding ( httpContentType ) ; final boolean appXml = isAppXml ( cTMime ) ; final boolean textXml = isTextXml ( cTMime ) ; if ( ! appXml && ! textXml ) { MST[rv.ROR5Mutator]MSP[N]
throw new IOException ( lr_6 + offset + lr_7 ) ; } final int bytesRead = offset ; if ( bytesRead > 0 ) { is . reset () ; final BufferedReader bReader = new BufferedReader ( new StringReader ( MST[MathMutator]MSP[N]
final String cTEnc = getContentTypeEncoding ( httpContentType ) ; final boolean appXml = isAppXml ( cTMime ) ; final boolean textXml = isTextXml ( cTMime ) ; if ( ! appXml && ! textXml ) { MST[rv.UOI2Mutator]MSP[S]
encoding = encoding . substring ( 1 , encoding . length () - 1 ) ; } } } return encoding ; } static boolean isAppXml ( final String mime ) { return mime != null && MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] ( mime . equals ( lr_8 ) ||
} catch ( final XmlStreamReaderException ex ) { if ( lenient ) { MST[rv.ROR5Mutator]MSP[N] return doLenientDetection ( httpContentType , ex ) ; } throw ex ; } } private String doLenientDetection ( String httpContentType , XmlStreamReaderException ex ) throws IOException {
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_16 ) && ! xmlEnc . equals ( bomEnc ) ) { MST[NegateConditionalsMutator]MSP[N] final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } if ( bomEnc . equals ( UTF_32BE ) || bomEnc . equals ( UTF_32LE ) ) { if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( bomEnc ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_32 ) && ! xmlEnc . equals ( bomEnc ) ) { MST[NonVoidMethodCallMutator]MSP[N] final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
encoding = encoding . substring ( 1 , encoding . length () - 1 ) ; MST[rv.AOD2Mutator]MSP[N] } } } return encoding ; } static boolean isAppXml ( final String mime ) { return mime != null && ( mime . equals ( lr_8 ) ||
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_16 ) && ! xmlEnc . equals ( bomEnc ) ) { MST[NegateConditionalsMutator]MSP[N] final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
} catch ( final XmlStreamReaderException ex ) { if ( lenient ) { MST[NegateConditionalsMutator]MSP[N] return doLenientDetection ( httpContentType , ex ) ; } throw ex ; } } private String doLenientDetection ( String httpContentType , XmlStreamReaderException ex ) throws IOException {
if ( encoding == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] encoding = defaultEncoding == null ? UTF_8 : defaultEncoding ; } return encoding ; } String calculateRawEncoding ( final String bomEnc , final String xmlGuessEnc , final String xmlEnc ) throws IOException { if ( bomEnc == null ) {
if ( cTEnc . equals ( UTF_16 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_16 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR4Mutator]MSP[N]
encoding = encoding . substring ( 1 , encoding . length () - 1 ) ; MST[rv.CRCR6Mutator]MSP[N] } } } return encoding ; } static boolean isAppXml ( final String mime ) { return mime != null && ( mime . equals ( lr_8 ) ||
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; MST[EmptyObjectReturnValsMutator]MSP[N] } final String msg = MessageFormat . format ( RAW_EX_2 , bomEnc , xmlGuessEnc , xmlEnc ) ; throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { MST[rv.CRCR3Mutator]MSP[N] offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ;
if ( xmlGuessEnc == null || xmlEnc == null ) { return defaultEncoding == null ? UTF_8 : defaultEncoding ; } if ( xmlEnc . equals ( UTF_16 ) && MST[rv.ROR4Mutator]MSP[S] ( xmlGuessEnc . equals ( UTF_16BE ) || xmlGuessEnc . equals ( UTF_16LE ) ) ) { return xmlGuessEnc ;
mime . equals ( lr_9 ) || mime . equals ( lr_10 ) || mime . startsWith ( lr_11 ) && mime . endsWith ( lr_12 ) ) ; MST[rv.CRCR6Mutator]MSP[N] } static boolean isTextXml ( final String mime ) { return mime != null &&
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR1Mutator]MSP[N] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
throw new IOException ( lr_6 + offset + lr_7 ) ; } final int bytesRead = offset ; if ( bytesRead > 0 ) { MST[rv.UOI1Mutator]MSP[N] is . reset () ; final BufferedReader bReader = new BufferedReader ( new StringReader (
static String getContentTypeEncoding ( final String httpContentType ) { String encoding = null ; if ( httpContentType != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] final int i = httpContentType . indexOf ( lr_3 ) ; if ( i > - 1 ) {
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } if ( bomEnc . equals ( UTF_32BE ) || bomEnc . equals ( UTF_32LE ) ) { MST[rv.ROR3Mutator]MSP[S] if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( bomEnc ) ) {
if ( cTEnc . equals ( UTF_32 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_32 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[ArgumentPropagationMutator]MSP[N]
final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[InlineConstantMutator]MSP[N] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
} final Matcher m = ENCODING_PATTERN . matcher ( prolog ) ; if ( m . find () ) { encoding = m . group ( 1 ) . toUpperCase ( Locale . ROOT ) ; MST[NonVoidMethodCallMutator]MSP[N]
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_16 ) && ! xmlEnc . equals ( bomEnc ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[InlineConstantMutator]MSP[S]
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_16 ) && ! xmlEnc . equals ( bomEnc ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR6Mutator]MSP[N]
mime . equals ( lr_9 ) || mime . equals ( lr_10 ) || mime . startsWith ( lr_11 ) && mime . endsWith ( lr_12 ) ) ; } static boolean isTextXml ( final String mime ) { return mime != null && MST[rv.ROR5Mutator]MSP[N]
xmlProlog = new String ( bytes , 0 , offset , guessedEnc ) ; firstGT = xmlProlog . indexOf ( '>' ) ; } if ( firstGT == - 1 ) { MST[rv.ROR2Mutator]MSP[N] if ( c == - 1 ) { throw new IOException ( lr_5 ) ; }
final String msg = MessageFormat . format ( HTTP_EX_3 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR2Mutator]MSP[S] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( cTEnc == null ) {
xmlProlog = new String ( bytes , 0 , offset , guessedEnc ) ; firstGT = xmlProlog . indexOf ( '>' ) ; } if ( firstGT == - 1 ) { MST[rv.CRCR6Mutator]MSP[N] if ( c == - 1 ) { throw new IOException ( lr_5 ) ; }
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { MST[InlineConstantMutator]MSP[N] offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ;
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[InlineConstantMutator]MSP[N] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } if ( bomEnc . equals ( UTF_32BE ) || bomEnc . equals ( UTF_32LE ) ) { MST[NonVoidMethodCallMutator]MSP[N] if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( bomEnc ) ) {
final String msg = MessageFormat . format ( HTTP_EX_3 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR6Mutator]MSP[S] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( cTEnc == null ) {
throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; } static String getContentTypeMime ( final String httpContentType ) { String mime = null ; if ( httpContentType != null ) { MST[NegateConditionalsMutator]MSP[N]
if ( cTEnc . equals ( UTF_16 ) ) { MST[rv.ROR2Mutator]MSP[N] if ( bomEnc != null && bomEnc . startsWith ( UTF_16 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ;
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } if ( bomEnc . equals ( UTF_16BE ) || bomEnc . equals ( UTF_16LE ) ) { MST[rv.ROR5Mutator]MSP[N] if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( bomEnc ) ) {
} return xmlEnc ; } if ( bomEnc . equals ( UTF_8 ) ) { if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( UTF_8 ) ) { MST[NonVoidMethodCallMutator]MSP[N] final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
if ( xmlGuessEnc == null || xmlEnc == null ) { return defaultEncoding == null ? UTF_8 : defaultEncoding ; } if ( xmlEnc . equals ( UTF_16 ) && ( xmlGuessEnc . equals ( UTF_16BE ) || xmlGuessEnc . equals ( UTF_16LE ) ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] return xmlGuessEnc ;
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR4Mutator]MSP[N] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
throw new IOException ( lr_6 + offset + lr_7 ) ; } final int bytesRead = offset ; if ( bytesRead > 0 ) { is . reset () ; final BufferedReader bReader = new BufferedReader ( new StringReader ( MST[rv.CRCR2Mutator]MSP[N]
mime . equals ( lr_9 ) || MST[NonVoidMethodCallMutator]MSP[N] mime . equals ( lr_10 ) || mime . startsWith ( lr_11 ) && mime . endsWith ( lr_12 ) ) ; } static boolean isTextXml ( final String mime ) { return mime != null &&
} return xmlEnc ; } if ( bomEnc . equals ( UTF_8 ) ) { if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( UTF_8 ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR2Mutator]MSP[S]
if ( cTEnc . equals ( UTF_16 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_16 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR1Mutator]MSP[N]
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } if ( bomEnc . equals ( UTF_32BE ) || bomEnc . equals ( UTF_32LE ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( bomEnc ) ) {
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } final String msg = MessageFormat . format ( RAW_EX_2 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR5Mutator]MSP[S] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
if ( appXml ) { return calculateRawEncoding ( bomEnc , xmlGuessEnc , xmlEnc ) ; } return defaultEncoding == null ? US_ASCII : defaultEncoding ; MST[NegateConditionalsMutator]MSP[N] } if ( cTEnc . equals ( UTF_16BE ) || cTEnc . equals ( UTF_16LE ) ) { if ( bomEnc != null ) {
} return xmlEnc ; } if ( bomEnc . equals ( UTF_8 ) ) { if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( UTF_8 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
final String postMime = httpContentType . substring ( i + 1 ) ; MST[rv.CRCR2Mutator]MSP[S] final Matcher m = CHARSET_PATTERN . matcher ( postMime ) ; encoding = m . find () ? m . group ( 1 ) : null ;
final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR5Mutator]MSP[N] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { offset += c ; max -= c ; MST[rv.AOR2Mutator]MSP[N] c = is . read ( bytes , offset , max ) ;
final String bomEnc = bom . getBOMCharsetName () ; final String xmlGuessEnc = pis . getBOMCharsetName () ; final String xmlEnc = getXmlProlog ( pis , xmlGuessEnc ) ; MST[NonVoidMethodCallMutator]MSP[N] try { return calculateHttpEncoding ( httpContentType , bomEnc , xmlGuessEnc , xmlEnc , lenient ) ;
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_32 ) && ! xmlEnc . equals ( bomEnc ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
} return xmlEnc ; } if ( bomEnc . equals ( UTF_8 ) ) { if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( UTF_8 ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[InlineConstantMutator]MSP[S]
if ( cTEnc . equals ( UTF_16 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_16 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[ArgumentPropagationMutator]MSP[N]
throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( cTEnc . equals ( UTF_32BE ) || cTEnc . equals ( UTF_32LE ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] if ( bomEnc != null ) {
String calculateHttpEncoding ( final String httpContentType , final String bomEnc , final String xmlGuessEnc , final String xmlEnc , final boolean lenient ) throws IOException { if ( lenient && xmlEnc != null ) { MST[rv.UOI1Mutator]MSP[S] return xmlEnc ; } final String cTMime = getContentTypeMime ( httpContentType ) ;
throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( cTEnc . equals ( UTF_32BE ) || cTEnc . equals ( UTF_32LE ) ) { if ( bomEnc != null ) { MST[rv.ROR5Mutator]MSP[N]
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR4Mutator]MSP[N] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
if ( cTEnc . equals ( UTF_32 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_32 ) ) { MST[NonVoidMethodCallMutator]MSP[N] return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ;
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR1Mutator]MSP[N] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { MST[rv.CRCR2Mutator]MSP[N] offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ;
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { MST[rv.CRCR1Mutator]MSP[N] offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ;
return reader . read ( buf , offset , len ) ; MST[rv.ABSMutator]MSP[S] } @Override public void close () throws IOException { reader . close () ; } private String doRawStream ( final BOMInputStream bom , final BOMInputStream pis , final boolean lenient ) throws IOException {
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ; MST[rv.UOI3Mutator]MSP[N]
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } if ( bomEnc . equals ( UTF_16BE ) || bomEnc . equals ( UTF_16LE ) ) { if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( bomEnc ) ) { MST[rv.ROR5Mutator]MSP[N]
static String getContentTypeEncoding ( final String httpContentType ) { String encoding = null ; if ( httpContentType != null ) { final int i = httpContentType . indexOf ( lr_3 ) ; if ( i > - 1 ) { MST[InlineConstantMutator]MSP[S]
static String getContentTypeEncoding ( final String httpContentType ) { String encoding = null ; if ( httpContentType != null ) { final int i = httpContentType . indexOf ( lr_3 ) ; if ( i > - 1 ) { MST[rv.ABSMutator]MSP[N]
xmlProlog = new String ( bytes , 0 , offset , guessedEnc ) ; firstGT = xmlProlog . indexOf ( '>' ) ; } if ( firstGT == - 1 ) { MST[rv.UOI1Mutator]MSP[N] if ( c == - 1 ) { throw new IOException ( lr_5 ) ; }
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { MST[rv.CRCR5Mutator]MSP[N] offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ;
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { MST[rv.CRCR6Mutator]MSP[N] offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ;
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( xmlEnc != null && ! xmlEnc . equals ( UTF_8 ) ) { MST[NonVoidMethodCallMutator]MSP[N] final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
final String msg = MessageFormat . format ( HTTP_EX_3 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( cTEnc == null ) { MST[rv.ROR5Mutator]MSP[N]
encoding = encoding . substring ( 1 , encoding . length () - 1 ) ; } } } return encoding ; } static boolean isAppXml ( final String mime ) { return mime != null && ( mime . equals ( lr_8 ) || MST[rv.ROR1Mutator]MSP[N]
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( xmlEnc != null && ! xmlEnc . equals ( UTF_8 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
static String getContentTypeEncoding ( final String httpContentType ) { String encoding = null ; if ( httpContentType != null ) { final int i = httpContentType . indexOf ( lr_3 ) ; if ( i > - 1 ) { MST[rv.CRCR6Mutator]MSP[S]
mime . equals ( lr_9 ) || MST[rv.ROR3Mutator]MSP[S] mime . equals ( lr_10 ) || mime . startsWith ( lr_11 ) && mime . endsWith ( lr_12 ) ) ; } static boolean isTextXml ( final String mime ) { return mime != null &&
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_16 ) && ! xmlEnc . equals ( bomEnc ) ) { MST[rv.ROR5Mutator]MSP[N] final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
if ( cTEnc . equals ( UTF_32 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_32 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ;
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_32 ) && ! xmlEnc . equals ( bomEnc ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR6Mutator]MSP[S]
if ( appXml ) { return calculateRawEncoding ( bomEnc , xmlGuessEnc , xmlEnc ) ; } return defaultEncoding == null ? US_ASCII : defaultEncoding ; } if ( cTEnc . equals ( UTF_16BE ) || cTEnc . equals ( UTF_16LE ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] if ( bomEnc != null ) {
throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( cTEnc . equals ( UTF_32BE ) || cTEnc . equals ( UTF_32LE ) ) { MST[NonVoidMethodCallMutator]MSP[S] if ( bomEnc != null ) {
if ( cTEnc . equals ( UTF_32 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_32 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR1Mutator]MSP[N]
throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( cTEnc . equals ( UTF_32BE ) || cTEnc . equals ( UTF_32LE ) ) { if ( bomEnc != null ) { MST[NegateConditionalsMutator]MSP[N]
if ( guessedEnc != null ) { MST[NegateConditionalsMutator]MSP[N] final byte [] bytes = new byte [ BUFFER_SIZE ] ; is . mark ( BUFFER_SIZE ) ; int offset = 0 ; int max = BUFFER_SIZE ; int c = is . read ( bytes , offset , max ) ;
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } if ( bomEnc . equals ( UTF_16BE ) || bomEnc . equals ( UTF_16LE ) ) { MST[rv.ROR2Mutator]MSP[N] if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( bomEnc ) ) {
xmlProlog = new String ( bytes , 0 , offset , guessedEnc ) ; firstGT = xmlProlog . indexOf ( '>' ) ; MST[rv.CRCR3Mutator]MSP[N] } if ( firstGT == - 1 ) { if ( c == - 1 ) { throw new IOException ( lr_5 ) ; }
final String msg = MessageFormat . format ( HTTP_EX_3 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[ConstructorCallMutator]MSP[N] } if ( cTEnc == null ) {
final int i = httpContentType . indexOf ( lr_3 ) ; if ( i >= 0 ) { MST[rv.UOI3Mutator]MSP[N] mime = httpContentType . substring ( 0 , i ) ; } else { mime = httpContentType ; } mime = mime . trim () ; } return mime ; }
final int i = httpContentType . indexOf ( lr_3 ) ; if ( i >= 0 ) { MST[rv.ROR4Mutator]MSP[N] mime = httpContentType . substring ( 0 , i ) ; } else { mime = httpContentType ; } mime = mime . trim () ; } return mime ; }
throw new IOException ( lr_6 + offset + lr_7 ) ; } final int bytesRead = offset ; if ( bytesRead > 0 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] is . reset () ; final BufferedReader bReader = new BufferedReader ( new StringReader (
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_16 ) && ! xmlEnc . equals ( bomEnc ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[NonVoidMethodCallMutator]MSP[N]
if ( cTEnc . equals ( UTF_32 ) ) { MST[rv.ROR2Mutator]MSP[N] if ( bomEnc != null && bomEnc . startsWith ( UTF_32 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ;
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ;
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_16 ) && ! xmlEnc . equals ( bomEnc ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR3Mutator]MSP[N]
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( xmlEnc != null && ! xmlEnc . equals ( UTF_8 ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR6Mutator]MSP[N]
if ( appXml ) { return calculateRawEncoding ( bomEnc , xmlGuessEnc , xmlEnc ) ; MST[EmptyObjectReturnValsMutator]MSP[N] } return defaultEncoding == null ? US_ASCII : defaultEncoding ; } if ( cTEnc . equals ( UTF_16BE ) || cTEnc . equals ( UTF_16LE ) ) { if ( bomEnc != null ) {
if ( appXml ) { return calculateRawEncoding ( bomEnc , xmlGuessEnc , xmlEnc ) ; } return defaultEncoding == null ? US_ASCII : defaultEncoding ; } if ( cTEnc . equals ( UTF_16BE ) || cTEnc . equals ( UTF_16LE ) ) { MST[rv.ROR5Mutator]MSP[N] if ( bomEnc != null ) {
throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; } static String getContentTypeMime ( final String httpContentType ) { String mime = null ; if ( httpContentType != null ) { MST[rv.ROR5Mutator]MSP[N]
if ( cTEnc . equals ( UTF_16 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_16 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ;
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { offset += c ; MST[rv.UOI4Mutator]MSP[N] max -= c ; c = is . read ( bytes , offset , max ) ;
if ( appXml ) { return calculateRawEncoding ( bomEnc , xmlGuessEnc , xmlEnc ) ; } return defaultEncoding == null ? US_ASCII : defaultEncoding ; } if ( cTEnc . equals ( UTF_16BE ) || cTEnc . equals ( UTF_16LE ) ) { MST[rv.ROR2Mutator]MSP[N] if ( bomEnc != null ) {
} return xmlEnc ; } if ( bomEnc . equals ( UTF_8 ) ) { if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( UTF_8 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
if ( cTEnc . equals ( UTF_16 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_16 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR4Mutator]MSP[N]
String calculateHttpEncoding ( final String httpContentType , final String bomEnc , final String xmlGuessEnc , final String xmlEnc , final boolean lenient ) throws IOException { if ( lenient && xmlEnc != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return xmlEnc ; } final String cTMime = getContentTypeMime ( httpContentType ) ;
final String postMime = httpContentType . substring ( i + 1 ) ; MST[MathMutator]MSP[S] final Matcher m = CHARSET_PATTERN . matcher ( postMime ) ; encoding = m . find () ? m . group ( 1 ) : null ;
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR1Mutator]MSP[N] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
if ( cTEnc . equals ( UTF_32 ) ) { MST[rv.ROR5Mutator]MSP[N] if ( bomEnc != null && bomEnc . startsWith ( UTF_32 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ;
if ( cTEnc . equals ( UTF_16 ) ) { MST[NegateConditionalsMutator]MSP[N] if ( bomEnc != null && bomEnc . startsWith ( UTF_16 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ;
final String cTEnc = getContentTypeEncoding ( httpContentType ) ; final boolean appXml = isAppXml ( cTMime ) ; final boolean textXml = isTextXml ( cTMime ) ; if ( ! appXml && ! textXml ) { MST[rv.ABSMutator]MSP[S]
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } final String msg = MessageFormat . format ( RAW_EX_2 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR2Mutator]MSP[S] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
if ( appXml ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return calculateRawEncoding ( bomEnc , xmlGuessEnc , xmlEnc ) ; } return defaultEncoding == null ? US_ASCII : defaultEncoding ; } if ( cTEnc . equals ( UTF_16BE ) || cTEnc . equals ( UTF_16LE ) ) { if ( bomEnc != null ) {
final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR1Mutator]MSP[S] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } if ( bomEnc . equals ( UTF_32BE ) || bomEnc . equals ( UTF_32LE ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( bomEnc ) ) {
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ;
encoding = encoding . substring ( 1 , encoding . length () - 1 ) ; } } } return encoding ; MST[EmptyObjectReturnValsMutator]MSP[N] } static boolean isAppXml ( final String mime ) { return mime != null && ( mime . equals ( lr_8 ) ||
ex . getXmlGuessEncoding () , ex . getXmlEncoding () , true ) ; MST[rv.CRCR3Mutator]MSP[N] } catch ( final XmlStreamReaderException ex2 ) { ex = ex2 ; } } String encoding = ex . getXmlEncoding () ; if ( encoding == null ) { encoding = ex . getContentTypeEncoding () ; }
final String msg = MessageFormat . format ( HTTP_EX_3 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR5Mutator]MSP[S] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( cTEnc == null ) {
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { MST[ConditionalsBoundaryMutator]MSP[N] offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ;
final String msg = MessageFormat . format ( HTTP_EX_3 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR2Mutator]MSP[S] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( cTEnc == null ) {
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_16 ) && ! xmlEnc . equals ( bomEnc ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[InlineConstantMutator]MSP[N]
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[ArgumentPropagationMutator]MSP[N] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { MST[rv.ROR3Mutator]MSP[N] offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ;
if ( cTEnc . equals ( UTF_32 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_32 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR4Mutator]MSP[N]
if ( cTEnc . equals ( UTF_16 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_16 ) ) { MST[rv.ROR5Mutator]MSP[N] return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ;
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } if ( bomEnc . equals ( UTF_16BE ) || bomEnc . equals ( UTF_16LE ) ) { if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( bomEnc ) ) { MST[NegateConditionalsMutator]MSP[N]
( mime . equals ( lr_2 ) || mime . equals ( lr_13 ) || mime . startsWith ( lr_14 ) && mime . endsWith ( lr_12 ) ) ; MST[rv.ROR5Mutator]MSP[N] }
throw new IOException ( lr_6 + offset + lr_7 ) ; } final int bytesRead = offset ; if ( bytesRead > 0 ) { MST[ConditionalsBoundaryMutator]MSP[N] is . reset () ; final BufferedReader bReader = new BufferedReader ( new StringReader (
final int i = httpContentType . indexOf ( lr_3 ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( i >= 0 ) { mime = httpContentType . substring ( 0 , i ) ; } else { mime = httpContentType ; } mime = mime . trim () ; } return mime ; }
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; MST[EmptyObjectReturnValsMutator]MSP[N] } if ( bomEnc . equals ( UTF_16BE ) || bomEnc . equals ( UTF_16LE ) ) { if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( bomEnc ) ) {
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } if ( bomEnc . equals ( UTF_16BE ) || bomEnc . equals ( UTF_16LE ) ) { MST[rv.ROR5Mutator]MSP[N] if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( bomEnc ) ) {
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR4Mutator]MSP[N] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
if ( cTEnc . equals ( UTF_16 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_16 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR1Mutator]MSP[N]
throw new IOException ( lr_6 + offset + lr_7 ) ; } final int bytesRead = offset ; if ( bytesRead > 0 ) { is . reset () ; final BufferedReader bReader = new BufferedReader ( new StringReader ( MST[InlineConstantMutator]MSP[N]
final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[ConstructorCallMutator]MSP[S] }
return reader . read ( buf , offset , len ) ; MST[rv.UOI1Mutator]MSP[S] } @Override public void close () throws IOException { reader . close () ; } private String doRawStream ( final BOMInputStream bom , final BOMInputStream pis , final boolean lenient ) throws IOException {
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } final String msg = MessageFormat . format ( RAW_EX_2 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR5Mutator]MSP[S] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR5Mutator]MSP[N] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR4Mutator]MSP[S] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
throw new IOException ( lr_6 + offset + lr_7 ) ; } final int bytesRead = offset ; if ( bytesRead > 0 ) { is . reset () ; final BufferedReader bReader = new BufferedReader ( new StringReader ( MST[rv.AOR2Mutator]MSP[N]
if ( appXml ) { MST[rv.UOI1Mutator]MSP[S] return calculateRawEncoding ( bomEnc , xmlGuessEnc , xmlEnc ) ; } return defaultEncoding == null ? US_ASCII : defaultEncoding ; } if ( cTEnc . equals ( UTF_16BE ) || cTEnc . equals ( UTF_16LE ) ) { if ( bomEnc != null ) {
if ( guessedEnc != null ) { final byte [] bytes = new byte [ BUFFER_SIZE ] ; is . mark ( BUFFER_SIZE ) ; int offset = 0 ; int max = BUFFER_SIZE ; int c = is . read ( bytes , offset , max ) ; MST[rv.ABSMutator]MSP[N]
if ( guessedEnc != null ) { final byte [] bytes = new byte [ BUFFER_SIZE ] ; is . mark ( BUFFER_SIZE ) ; int offset = 0 ; int max = BUFFER_SIZE ; int c = is . read ( bytes , offset , max ) ; MST[rv.UOI1Mutator]MSP[N]
static String getContentTypeEncoding ( final String httpContentType ) { String encoding = null ; if ( httpContentType != null ) { final int i = httpContentType . indexOf ( lr_3 ) ; if ( i > - 1 ) { MST[ConditionalsBoundaryMutator]MSP[S]
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_32 ) && ! xmlEnc . equals ( bomEnc ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR4Mutator]MSP[N] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[ArgumentPropagationMutator]MSP[N] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
String calculateHttpEncoding ( final String httpContentType , final String bomEnc , final String xmlGuessEnc , final String xmlEnc , final boolean lenient ) throws IOException { if ( lenient && xmlEnc != null ) { MST[rv.UOI4Mutator]MSP[N] return xmlEnc ; } final String cTMime = getContentTypeMime ( httpContentType ) ;
if ( cTEnc . equals ( UTF_32 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_32 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR6Mutator]MSP[N]
if ( appXml ) { return calculateRawEncoding ( bomEnc , xmlGuessEnc , xmlEnc ) ; } return defaultEncoding == null ? US_ASCII : defaultEncoding ; } if ( cTEnc . equals ( UTF_16BE ) || cTEnc . equals ( UTF_16LE ) ) { if ( bomEnc != null ) { MST[NegateConditionalsMutator]MSP[N]
final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR6Mutator]MSP[S] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR1Mutator]MSP[N] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
xmlProlog . substring ( 0 , firstGT + 1 ) ) ) ; MST[experimental.NakedReceiverMutator]MSP[S] final StringBuffer prolog = new StringBuffer () ; String line = bReader . readLine () ; while ( line != null ) { prolog . append ( line ) ; line = bReader . readLine () ;
encoding = encoding . substring ( 1 , encoding . length () - 1 ) ; } } } return encoding ; } static boolean isAppXml ( final String mime ) { return mime != null && MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] ( mime . equals ( lr_8 ) ||
final int i = httpContentType . indexOf ( lr_3 ) ; if ( i >= 0 ) { MST[rv.ABSMutator]MSP[N] mime = httpContentType . substring ( 0 , i ) ; } else { mime = httpContentType ; } mime = mime . trim () ; } return mime ; }
throw new IOException ( lr_6 + offset + lr_7 ) ; } final int bytesRead = offset ; if ( bytesRead > 0 ) { is . reset () ; final BufferedReader bReader = new BufferedReader ( new StringReader ( MST[rv.UOI3Mutator]MSP[N]
encoding = encoding . substring ( 1 , encoding . length () - 1 ) ; MST[InlineConstantMutator]MSP[N] } } } return encoding ; } static boolean isAppXml ( final String mime ) { return mime != null && ( mime . equals ( lr_8 ) ||
throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( cTEnc . equals ( UTF_32BE ) || cTEnc . equals ( UTF_32LE ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] if ( bomEnc != null ) {
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } if ( bomEnc . equals ( UTF_16BE ) || bomEnc . equals ( UTF_16LE ) ) { if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( bomEnc ) ) { MST[rv.ROR5Mutator]MSP[S]
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_16 ) && ! xmlEnc . equals ( bomEnc ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR1Mutator]MSP[S]
static String getContentTypeEncoding ( final String httpContentType ) { String encoding = null ; if ( httpContentType != null ) { final int i = httpContentType . indexOf ( lr_3 ) ; if ( i > - 1 ) { MST[rv.UOI1Mutator]MSP[N]
if ( xmlGuessEnc == null || xmlEnc == null ) { return defaultEncoding == null ? UTF_8 : defaultEncoding ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } if ( xmlEnc . equals ( UTF_16 ) && ( xmlGuessEnc . equals ( UTF_16BE ) || xmlGuessEnc . equals ( UTF_16LE ) ) ) { return xmlGuessEnc ;
final int i = httpContentType . indexOf ( lr_3 ) ; if ( i >= 0 ) { mime = httpContentType . substring ( 0 , i ) ; MST[rv.CRCR5Mutator]MSP[N] } else { mime = httpContentType ; } mime = mime . trim () ; } return mime ; }
if ( appXml ) { MST[rv.UOI4Mutator]MSP[N] return calculateRawEncoding ( bomEnc , xmlGuessEnc , xmlEnc ) ; } return defaultEncoding == null ? US_ASCII : defaultEncoding ; } if ( cTEnc . equals ( UTF_16BE ) || cTEnc . equals ( UTF_16LE ) ) { if ( bomEnc != null ) {
( mime . equals ( lr_2 ) || mime . equals ( lr_13 ) || mime . startsWith ( lr_14 ) && mime . endsWith ( lr_12 ) ) ; MST[rv.CRCR3Mutator]MSP[S] }
if ( lenient ) { MST[rv.ROR5Mutator]MSP[S] return doLenientDetection ( null , ex ) ; } throw ex ; } } private String doHttpStream ( final BOMInputStream bom , final BOMInputStream pis , final String httpContentType , final boolean lenient ) throws IOException {
if ( cTEnc . equals ( UTF_32 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] if ( bomEnc != null && bomEnc . startsWith ( UTF_32 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ;
if ( xmlGuessEnc == null || xmlEnc == null ) { MST[rv.ROR5Mutator]MSP[N] return defaultEncoding == null ? UTF_8 : defaultEncoding ; } if ( xmlEnc . equals ( UTF_16 ) && ( xmlGuessEnc . equals ( UTF_16BE ) || xmlGuessEnc . equals ( UTF_16LE ) ) ) { return xmlGuessEnc ;
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_32 ) && ! xmlEnc . equals ( bomEnc ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR6Mutator]MSP[S]
if ( appXml ) { return calculateRawEncoding ( bomEnc , xmlGuessEnc , xmlEnc ) ; } return defaultEncoding == null ? US_ASCII : defaultEncoding ; } if ( cTEnc . equals ( UTF_16BE ) || cTEnc . equals ( UTF_16LE ) ) { if ( bomEnc != null ) { MST[rv.ROR5Mutator]MSP[N]
if ( guessedEnc != null ) { final byte [] bytes = new byte [ BUFFER_SIZE ] ; MST[rv.CRCR3Mutator]MSP[N] is . mark ( BUFFER_SIZE ) ; int offset = 0 ; int max = BUFFER_SIZE ; int c = is . read ( bytes , offset , max ) ;
( mime . equals ( lr_2 ) || MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] mime . equals ( lr_13 ) || mime . startsWith ( lr_14 ) && mime . endsWith ( lr_12 ) ) ; }
int firstGT = - 1 ; MST[rv.CRCR6Mutator]MSP[N] String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ;
if ( appXml ) { return calculateRawEncoding ( bomEnc , xmlGuessEnc , xmlEnc ) ; } return defaultEncoding == null ? US_ASCII : defaultEncoding ; } if ( cTEnc . equals ( UTF_16BE ) || cTEnc . equals ( UTF_16LE ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] if ( bomEnc != null ) {
static String getContentTypeEncoding ( final String httpContentType ) { String encoding = null ; if ( httpContentType != null ) { final int i = httpContentType . indexOf ( lr_3 ) ; if ( i > - 1 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N]
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { offset += c ; max -= c ; MST[rv.UOI2Mutator]MSP[N] c = is . read ( bytes , offset , max ) ;
xmlProlog = new String ( bytes , 0 , offset , guessedEnc ) ; firstGT = xmlProlog . indexOf ( '>' ) ; } if ( firstGT == - 1 ) { MST[InlineConstantMutator]MSP[N] if ( c == - 1 ) { throw new IOException ( lr_5 ) ; }
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } if ( bomEnc . equals ( UTF_16BE ) || bomEnc . equals ( UTF_16LE ) ) { MST[rv.ROR2Mutator]MSP[S] if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( bomEnc ) ) {
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( xmlEnc != null && ! xmlEnc . equals ( UTF_8 ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR5Mutator]MSP[N]
if ( guessedEnc != null ) { final byte [] bytes = new byte [ BUFFER_SIZE ] ; is . mark ( BUFFER_SIZE ) ; MST[rv.CRCR5Mutator]MSP[N] int offset = 0 ; int max = BUFFER_SIZE ; int c = is . read ( bytes , offset , max ) ;
throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( cTEnc . equals ( UTF_32BE ) || cTEnc . equals ( UTF_32LE ) ) { MST[rv.ROR2Mutator]MSP[N] if ( bomEnc != null ) {
encoding = encoding . substring ( 1 , encoding . length () - 1 ) ; MST[rv.CRCR2Mutator]MSP[N] } } } return encoding ; } static boolean isAppXml ( final String mime ) { return mime != null && ( mime . equals ( lr_8 ) ||
if ( cTEnc . equals ( UTF_32 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_32 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR1Mutator]MSP[N]
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( xmlEnc != null && ! xmlEnc . equals ( UTF_8 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
mime . equals ( lr_9 ) || mime . equals ( lr_10 ) || MST[rv.ROR5Mutator]MSP[N] mime . startsWith ( lr_11 ) && mime . endsWith ( lr_12 ) ) ; } static boolean isTextXml ( final String mime ) { return mime != null &&
if ( cTEnc . equals ( UTF_32 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_32 ) ) { return bomEnc ; MST[EmptyObjectReturnValsMutator]MSP[S] } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ;
final String postMime = httpContentType . substring ( i + 1 ) ; final Matcher m = CHARSET_PATTERN . matcher ( postMime ) ; encoding = m . find () ? m . group ( 1 ) : null ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
xmlProlog = new String ( bytes , 0 , offset , guessedEnc ) ; MST[rv.UOI2Mutator]MSP[N] firstGT = xmlProlog . indexOf ( '>' ) ; } if ( firstGT == - 1 ) { if ( c == - 1 ) { throw new IOException ( lr_5 ) ; }
final String cTEnc = getContentTypeEncoding ( httpContentType ) ; final boolean appXml = isAppXml ( cTMime ) ; final boolean textXml = isTextXml ( cTMime ) ; if ( ! appXml && ! textXml ) { MST[rv.ROR1Mutator]MSP[N]
if ( cTEnc . equals ( UTF_32 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_32 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ;
final String cTEnc = getContentTypeEncoding ( httpContentType ) ; final boolean appXml = isAppXml ( cTMime ) ; final boolean textXml = isTextXml ( cTMime ) ; if ( ! appXml && ! textXml ) { MST[rv.ROR3Mutator]MSP[S]
( mime . equals ( lr_2 ) || MST[NonVoidMethodCallMutator]MSP[N] mime . equals ( lr_13 ) || mime . startsWith ( lr_14 ) && mime . endsWith ( lr_12 ) ) ; }
encoding = encoding != null ? encoding . toUpperCase ( Locale . ROOT ) : null ; MST[NonVoidMethodCallMutator]MSP[N] } } return encoding ; } private static String getXmlProlog ( final InputStream is , final String guessedEnc ) throws IOException { String encoding = null ;
mime . equals ( lr_9 ) || mime . equals ( lr_10 ) || MST[NegateConditionalsMutator]MSP[N] mime . startsWith ( lr_11 ) && mime . endsWith ( lr_12 ) ) ; } static boolean isTextXml ( final String mime ) { return mime != null &&
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( xmlEnc != null && ! xmlEnc . equals ( UTF_8 ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR6Mutator]MSP[N]
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( xmlEnc != null && ! xmlEnc . equals ( UTF_8 ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR3Mutator]MSP[N]
if ( xmlGuessEnc == null || xmlEnc == null ) { MST[NegateConditionalsMutator]MSP[N] return defaultEncoding == null ? UTF_8 : defaultEncoding ; } if ( xmlEnc . equals ( UTF_16 ) && ( xmlGuessEnc . equals ( UTF_16BE ) || xmlGuessEnc . equals ( UTF_16LE ) ) ) { return xmlGuessEnc ;
throw new IOException ( lr_6 + offset + lr_7 ) ; } final int bytesRead = offset ; if ( bytesRead > 0 ) { MST[rv.UOI4Mutator]MSP[N] is . reset () ; final BufferedReader bReader = new BufferedReader ( new StringReader (
if ( cTEnc . equals ( UTF_16 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_16 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ;
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { MST[rv.ABSMutator]MSP[N] offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ;
if ( appXml ) { return calculateRawEncoding ( bomEnc , xmlGuessEnc , xmlEnc ) ; } return defaultEncoding == null ? US_ASCII : defaultEncoding ; } if ( cTEnc . equals ( UTF_16BE ) || cTEnc . equals ( UTF_16LE ) ) { MST[rv.ROR2Mutator]MSP[N] if ( bomEnc != null ) {
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } final String msg = MessageFormat . format ( RAW_EX_2 , bomEnc , xmlGuessEnc , xmlEnc ) ; throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[ConstructorCallMutator]MSP[S] }
if ( cTEnc . equals ( UTF_16 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_16 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR4Mutator]MSP[N]
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( xmlEnc != null && ! xmlEnc . equals ( UTF_8 ) ) { MST[rv.ROR4Mutator]MSP[N] final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
final String postMime = httpContentType . substring ( i + 1 ) ; MST[rv.UOI3Mutator]MSP[N] final Matcher m = CHARSET_PATTERN . matcher ( postMime ) ; encoding = m . find () ? m . group ( 1 ) : null ;
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } final String msg = MessageFormat . format ( RAW_EX_2 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR2Mutator]MSP[S] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
mime . equals ( lr_9 ) || mime . equals ( lr_10 ) || mime . startsWith ( lr_11 ) && mime . endsWith ( lr_12 ) ) ; MST[rv.CRCR2Mutator]MSP[N] } static boolean isTextXml ( final String mime ) { return mime != null &&
final String msg = MessageFormat . format ( HTTP_EX_3 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( cTEnc == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } if ( bomEnc . equals ( UTF_32BE ) || bomEnc . equals ( UTF_32LE ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( bomEnc ) ) {
xmlProlog = new String ( bytes , 0 , offset , guessedEnc ) ; firstGT = xmlProlog . indexOf ( '>' ) ; } if ( firstGT == - 1 ) { MST[rv.ROR5Mutator]MSP[N] if ( c == - 1 ) { throw new IOException ( lr_5 ) ; }
if ( httpContentType != null && httpContentType . startsWith ( lr_1 ) ) { MST[rv.ROR3Mutator]MSP[N] httpContentType = httpContentType . substring ( lr_1 . length () ) ; httpContentType = lr_2 + httpContentType ; try { return calculateHttpEncoding ( httpContentType , ex . getBomEncoding () ,
} return xmlEnc ; } if ( bomEnc . equals ( UTF_8 ) ) { if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( UTF_8 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR2Mutator]MSP[N] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
final String postMime = httpContentType . substring ( i + 1 ) ; MST[rv.CRCR5Mutator]MSP[N] final Matcher m = CHARSET_PATTERN . matcher ( postMime ) ; encoding = m . find () ? m . group ( 1 ) : null ;
final String msg = MessageFormat . format ( HTTP_EX_3 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR5Mutator]MSP[S] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( cTEnc == null ) {
static String getContentTypeEncoding ( final String httpContentType ) { String encoding = null ; if ( httpContentType != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] final int i = httpContentType . indexOf ( lr_3 ) ; if ( i > - 1 ) {
String calculateHttpEncoding ( final String httpContentType , final String bomEnc , final String xmlGuessEnc , final String xmlEnc , final boolean lenient ) throws IOException { if ( lenient && xmlEnc != null ) { MST[rv.ROR2Mutator]MSP[S] return xmlEnc ; } final String cTMime = getContentTypeMime ( httpContentType ) ;
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_16 ) && ! xmlEnc . equals ( bomEnc ) ) { MST[rv.ROR2Mutator]MSP[N] final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
final String msg = MessageFormat . format ( HTTP_EX_3 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR2Mutator]MSP[S] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( cTEnc == null ) {
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR6Mutator]MSP[N] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } if ( bomEnc . equals ( UTF_16BE ) || bomEnc . equals ( UTF_16LE ) ) { if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( bomEnc ) ) { MST[NegateConditionalsMutator]MSP[S]
throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( cTEnc . equals ( UTF_32BE ) || cTEnc . equals ( UTF_32LE ) ) { if ( bomEnc != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
if ( cTEnc . equals ( UTF_32 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_32 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR4Mutator]MSP[N]
if ( cTEnc . equals ( UTF_16 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_16 ) ) { MST[rv.ROR2Mutator]MSP[N] return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ;
final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR4Mutator]MSP[S] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_32 ) && ! xmlEnc . equals ( bomEnc ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[InlineConstantMutator]MSP[S]
xmlProlog = new String ( bytes , 0 , offset , guessedEnc ) ; firstGT = xmlProlog . indexOf ( '>' ) ; MST[rv.CRCR6Mutator]MSP[N] } if ( firstGT == - 1 ) { if ( c == - 1 ) { throw new IOException ( lr_5 ) ; }
if ( cTEnc . equals ( UTF_16 ) ) { MST[rv.ROR5Mutator]MSP[N] if ( bomEnc != null && bomEnc . startsWith ( UTF_16 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ;
throw new IOException ( lr_6 + offset + lr_7 ) ; } final int bytesRead = offset ; if ( bytesRead > 0 ) { is . reset () ; final BufferedReader bReader = new BufferedReader ( new StringReader ( MST[rv.CRCR5Mutator]MSP[N]
if ( appXml ) { return calculateRawEncoding ( bomEnc , xmlGuessEnc , xmlEnc ) ; MST[NonVoidMethodCallMutator]MSP[N] } return defaultEncoding == null ? US_ASCII : defaultEncoding ; } if ( cTEnc . equals ( UTF_16BE ) || cTEnc . equals ( UTF_16LE ) ) { if ( bomEnc != null ) {
} return xmlEnc ; } if ( bomEnc . equals ( UTF_8 ) ) { if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( UTF_8 ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR6Mutator]MSP[S]
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR4Mutator]MSP[N] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
if ( lenient ) { MST[NegateConditionalsMutator]MSP[S] return doLenientDetection ( null , ex ) ; } throw ex ; } } private String doHttpStream ( final BOMInputStream bom , final BOMInputStream pis , final String httpContentType , final boolean lenient ) throws IOException {
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } final String msg = MessageFormat . format ( RAW_EX_2 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR4Mutator]MSP[S] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
if ( xmlGuessEnc == null || xmlEnc == null ) { return defaultEncoding == null ? UTF_8 : defaultEncoding ; } if ( xmlEnc . equals ( UTF_16 ) && MST[rv.ROR1Mutator]MSP[S] ( xmlGuessEnc . equals ( UTF_16BE ) || xmlGuessEnc . equals ( UTF_16LE ) ) ) { return xmlGuessEnc ;
static String getContentTypeEncoding ( final String httpContentType ) { String encoding = null ; if ( httpContentType != null ) { final int i = httpContentType . indexOf ( lr_3 ) ; if ( i > - 1 ) { MST[NegateConditionalsMutator]MSP[N]
if ( xmlGuessEnc == null || xmlEnc == null ) { return defaultEncoding == null ? UTF_8 : defaultEncoding ; } if ( xmlEnc . equals ( UTF_16 ) && ( xmlGuessEnc . equals ( UTF_16BE ) || xmlGuessEnc . equals ( UTF_16LE ) ) ) { MST[rv.ROR3Mutator]MSP[S] return xmlGuessEnc ;
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } final String msg = MessageFormat . format ( RAW_EX_2 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR5Mutator]MSP[S] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
( mime . equals ( lr_2 ) || mime . equals ( lr_13 ) || mime . startsWith ( lr_14 ) && mime . endsWith ( lr_12 ) ) ; MST[NegateConditionalsMutator]MSP[N] }
if ( appXml ) { MST[rv.ROR2Mutator]MSP[S] return calculateRawEncoding ( bomEnc , xmlGuessEnc , xmlEnc ) ; } return defaultEncoding == null ? US_ASCII : defaultEncoding ; } if ( cTEnc . equals ( UTF_16BE ) || cTEnc . equals ( UTF_16LE ) ) { if ( bomEnc != null ) {
( mime . equals ( lr_2 ) || MST[rv.ROR4Mutator]MSP[N] mime . equals ( lr_13 ) || mime . startsWith ( lr_14 ) && mime . endsWith ( lr_12 ) ) ; }
encoding = encoding . substring ( 1 , encoding . length () - 1 ) ; MST[NonVoidMethodCallMutator]MSP[N] } } } return encoding ; } static boolean isAppXml ( final String mime ) { return mime != null && ( mime . equals ( lr_8 ) ||
String calculateHttpEncoding ( final String httpContentType , final String bomEnc , final String xmlGuessEnc , final String xmlEnc , final boolean lenient ) throws IOException { if ( lenient && xmlEnc != null ) { MST[NegateConditionalsMutator]MSP[N] return xmlEnc ; } final String cTMime = getContentTypeMime ( httpContentType ) ;
if ( encoding == null ) { encoding = defaultEncoding == null ? UTF_8 : defaultEncoding ; } return encoding ; } String calculateRawEncoding ( final String bomEnc , final String xmlGuessEnc , final String xmlEnc ) throws IOException { if ( bomEnc == null ) { MST[NegateConditionalsMutator]MSP[N]
if ( appXml ) { return calculateRawEncoding ( bomEnc , xmlGuessEnc , xmlEnc ) ; } return defaultEncoding == null ? US_ASCII : defaultEncoding ; } if ( cTEnc . equals ( UTF_16BE ) || cTEnc . equals ( UTF_16LE ) ) { MST[NonVoidMethodCallMutator]MSP[N] if ( bomEnc != null ) {
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR2Mutator]MSP[N] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR3Mutator]MSP[S] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_32 ) && ! xmlEnc . equals ( bomEnc ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR5Mutator]MSP[S]
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR4Mutator]MSP[N] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
if ( cTEnc . equals ( UTF_32 ) ) { MST[NonVoidMethodCallMutator]MSP[N] if ( bomEnc != null && bomEnc . startsWith ( UTF_32 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ;
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[ConstructorCallMutator]MSP[N] } return bomEnc ; } if ( bomEnc . equals ( UTF_32BE ) || bomEnc . equals ( UTF_32LE ) ) { if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( bomEnc ) ) {
} return xmlEnc ; } if ( bomEnc . equals ( UTF_8 ) ) { if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( UTF_8 ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR3Mutator]MSP[S]
final String cTEnc = getContentTypeEncoding ( httpContentType ) ; final boolean appXml = isAppXml ( cTMime ) ; final boolean textXml = isTextXml ( cTMime ) ; if ( ! appXml && ! textXml ) { MST[rv.UOI3Mutator]MSP[N]
throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( cTEnc . equals ( UTF_32BE ) || cTEnc . equals ( UTF_32LE ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] if ( bomEnc != null ) {
if ( xmlGuessEnc == null || xmlEnc == null ) { return defaultEncoding == null ? UTF_8 : defaultEncoding ; } if ( xmlEnc . equals ( UTF_16 ) && ( xmlGuessEnc . equals ( UTF_16BE ) || xmlGuessEnc . equals ( UTF_16LE ) ) ) { MST[rv.ROR2Mutator]MSP[S] return xmlGuessEnc ;
final int i = httpContentType . indexOf ( lr_3 ) ; if ( i >= 0 ) { mime = httpContentType . substring ( 0 , i ) ; MST[experimental.NakedReceiverMutator]MSP[N] } else { mime = httpContentType ; } mime = mime . trim () ; } return mime ; }
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; MST[ReturnValsMutator]MSP[N] }
if ( httpContentType != null && httpContentType . startsWith ( lr_1 ) ) { httpContentType = httpContentType . substring ( lr_1 . length () ) ; httpContentType = lr_2 + httpContentType ; try { return calculateHttpEncoding ( httpContentType , ex . getBomEncoding () , MST[NonVoidMethodCallMutator]MSP[S]
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( xmlEnc != null && ! xmlEnc . equals ( UTF_8 ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR2Mutator]MSP[N]
( mime . equals ( lr_2 ) || mime . equals ( lr_13 ) || mime . startsWith ( lr_14 ) && mime . endsWith ( lr_12 ) ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] }
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_16 ) && ! xmlEnc . equals ( bomEnc ) ) { MST[rv.ROR4Mutator]MSP[N] final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
if ( guessedEnc != null ) { final byte [] bytes = new byte [ BUFFER_SIZE ] ; is . mark ( BUFFER_SIZE ) ; int offset = 0 ; int max = BUFFER_SIZE ; MST[rv.CRCR6Mutator]MSP[N] int c = is . read ( bytes , offset , max ) ;
String calculateHttpEncoding ( final String httpContentType , final String bomEnc , final String xmlGuessEnc , final String xmlEnc , final boolean lenient ) throws IOException { if ( lenient && xmlEnc != null ) { MST[rv.ROR5Mutator]MSP[N] return xmlEnc ; } final String cTMime = getContentTypeMime ( httpContentType ) ;
xmlProlog = new String ( bytes , 0 , offset , guessedEnc ) ; MST[rv.CRCR3Mutator]MSP[N] firstGT = xmlProlog . indexOf ( '>' ) ; } if ( firstGT == - 1 ) { if ( c == - 1 ) { throw new IOException ( lr_5 ) ; }
if ( cTEnc . equals ( UTF_16 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_16 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR2Mutator]MSP[N]
final String bomEnc = bom . getBOMCharsetName () ; MST[NonVoidMethodCallMutator]MSP[N] final String xmlGuessEnc = pis . getBOMCharsetName () ; final String xmlEnc = getXmlProlog ( pis , xmlGuessEnc ) ; try { return calculateRawEncoding ( bomEnc , xmlGuessEnc , xmlEnc ) ; } catch ( final XmlStreamReaderException ex ) {
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_16 ) && ! xmlEnc . equals ( bomEnc ) ) { MST[rv.ROR1Mutator]MSP[N] final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_32 ) && ! xmlEnc . equals ( bomEnc ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR6Mutator]MSP[N]
final int i = httpContentType . indexOf ( lr_3 ) ; if ( i >= 0 ) { mime = httpContentType . substring ( 0 , i ) ; MST[rv.ABSMutator]MSP[N] } else { mime = httpContentType ; } mime = mime . trim () ; } return mime ; }
if ( xmlGuessEnc == null || xmlEnc == null ) { return defaultEncoding == null ? UTF_8 : defaultEncoding ; } if ( xmlEnc . equals ( UTF_16 ) && ( xmlGuessEnc . equals ( UTF_16BE ) || xmlGuessEnc . equals ( UTF_16LE ) ) ) { MST[rv.ROR5Mutator]MSP[S] return xmlGuessEnc ;
( mime . equals ( lr_2 ) || mime . equals ( lr_13 ) || mime . startsWith ( lr_14 ) && mime . endsWith ( lr_12 ) ) ; MST[rv.ROR2Mutator]MSP[S] }
if ( appXml ) { return calculateRawEncoding ( bomEnc , xmlGuessEnc , xmlEnc ) ; } return defaultEncoding == null ? US_ASCII : defaultEncoding ; } if ( cTEnc . equals ( UTF_16BE ) || cTEnc . equals ( UTF_16LE ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] if ( bomEnc != null ) {
final String bomEnc = bom . getBOMCharsetName () ; final String xmlGuessEnc = pis . getBOMCharsetName () ; final String xmlEnc = getXmlProlog ( pis , xmlGuessEnc ) ; try { return calculateHttpEncoding ( httpContentType , bomEnc , MST[NonVoidMethodCallMutator]MSP[N] xmlGuessEnc , xmlEnc , lenient ) ;
if ( encoding == null ) { encoding = defaultEncoding == null ? UTF_8 : defaultEncoding ; } return encoding ; } String calculateRawEncoding ( final String bomEnc , final String xmlGuessEnc , final String xmlEnc ) throws IOException { if ( bomEnc == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
( mime . equals ( lr_2 ) || mime . equals ( lr_13 ) || mime . startsWith ( lr_14 ) && mime . endsWith ( lr_12 ) ) ; MST[rv.CRCR2Mutator]MSP[N] }
if ( cTEnc . equals ( UTF_32 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_32 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ;
xmlProlog = new String ( bytes , 0 , offset , guessedEnc ) ; firstGT = xmlProlog . indexOf ( '>' ) ; } if ( firstGT == - 1 ) { MST[rv.ROR4Mutator]MSP[N] if ( c == - 1 ) { throw new IOException ( lr_5 ) ; }
encoding = encoding != null ? encoding . toUpperCase ( Locale . ROOT ) : null ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] } } return encoding ; } private static String getXmlProlog ( final InputStream is , final String guessedEnc ) throws IOException { String encoding = null ;
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( xmlEnc != null && ! xmlEnc . equals ( UTF_8 ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR3Mutator]MSP[N]
final String msg = MessageFormat . format ( HTTP_EX_3 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[NonVoidMethodCallMutator]MSP[N] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( cTEnc == null ) {
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } if ( bomEnc . equals ( UTF_32BE ) || bomEnc . equals ( UTF_32LE ) ) { if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( bomEnc ) ) { MST[rv.ROR5Mutator]MSP[N]
final String postMime = httpContentType . substring ( i + 1 ) ; final Matcher m = CHARSET_PATTERN . matcher ( postMime ) ; encoding = m . find () ? m . group ( 1 ) : null ; MST[NonVoidMethodCallMutator]MSP[N]
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[InlineConstantMutator]MSP[N] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
if ( httpContentType != null && httpContentType . startsWith ( lr_1 ) ) { httpContentType = httpContentType . substring ( lr_1 . length () ) ; httpContentType = lr_2 + httpContentType ; MST[NonVoidMethodCallMutator]MSP[N] try { return calculateHttpEncoding ( httpContentType , ex . getBomEncoding () ,
if ( appXml ) { return calculateRawEncoding ( bomEnc , xmlGuessEnc , xmlEnc ) ; } return defaultEncoding == null ? US_ASCII : defaultEncoding ; } if ( cTEnc . equals ( UTF_16BE ) || cTEnc . equals ( UTF_16LE ) ) { MST[rv.ROR3Mutator]MSP[N] if ( bomEnc != null ) {
if ( httpContentType != null && httpContentType . startsWith ( lr_1 ) ) { httpContentType = httpContentType . substring ( lr_1 . length () ) ; httpContentType = lr_2 + httpContentType ; MST[experimental.NakedReceiverMutator]MSP[N] try { return calculateHttpEncoding ( httpContentType , ex . getBomEncoding () ,
if ( cTEnc . equals ( UTF_16 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_16 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR6Mutator]MSP[N]
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( xmlEnc != null && ! xmlEnc . equals ( UTF_8 ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR6Mutator]MSP[N]
if ( cTEnc . equals ( UTF_16 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_16 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR3Mutator]MSP[N]
if ( xmlGuessEnc == null || xmlEnc == null ) { return defaultEncoding == null ? UTF_8 : defaultEncoding ; } if ( xmlEnc . equals ( UTF_16 ) && ( xmlGuessEnc . equals ( UTF_16BE ) || xmlGuessEnc . equals ( UTF_16LE ) ) ) { MST[NegateConditionalsMutator]MSP[S] return xmlGuessEnc ;
final String cTEnc = getContentTypeEncoding ( httpContentType ) ; final boolean appXml = isAppXml ( cTMime ) ; final boolean textXml = isTextXml ( cTMime ) ; if ( ! appXml && ! textXml ) { MST[rv.ROR4Mutator]MSP[N]
if ( cTEnc . equals ( UTF_32 ) ) { MST[rv.ROR3Mutator]MSP[N] if ( bomEnc != null && bomEnc . startsWith ( UTF_32 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ;
if ( cTEnc . equals ( UTF_16 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_16 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ;
encoding = encoding != null ? encoding . toUpperCase ( Locale . ROOT ) : null ; MST[rv.ROR5Mutator]MSP[N] } } return encoding ; } private static String getXmlProlog ( final InputStream is , final String guessedEnc ) throws IOException { String encoding = null ;
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { MST[rv.CRCR1Mutator]MSP[N] offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ;
ex . getXmlGuessEncoding () , ex . getXmlEncoding () , true ) ; } catch ( final XmlStreamReaderException ex2 ) { ex = ex2 ; } } String encoding = ex . getXmlEncoding () ; if ( encoding == null ) { MST[NegateConditionalsMutator]MSP[S] encoding = ex . getContentTypeEncoding () ; }
if ( appXml ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return calculateRawEncoding ( bomEnc , xmlGuessEnc , xmlEnc ) ; } return defaultEncoding == null ? US_ASCII : defaultEncoding ; } if ( cTEnc . equals ( UTF_16BE ) || cTEnc . equals ( UTF_16LE ) ) { if ( bomEnc != null ) {
final String postMime = httpContentType . substring ( i + 1 ) ; MST[rv.CRCR6Mutator]MSP[S] final Matcher m = CHARSET_PATTERN . matcher ( postMime ) ; encoding = m . find () ? m . group ( 1 ) : null ;
if ( xmlGuessEnc == null || xmlEnc == null ) { MST[rv.ROR5Mutator]MSP[N] return defaultEncoding == null ? UTF_8 : defaultEncoding ; } if ( xmlEnc . equals ( UTF_16 ) && ( xmlGuessEnc . equals ( UTF_16BE ) || xmlGuessEnc . equals ( UTF_16LE ) ) ) { return xmlGuessEnc ;
static String getContentTypeEncoding ( final String httpContentType ) { String encoding = null ; if ( httpContentType != null ) { final int i = httpContentType . indexOf ( lr_3 ) ; if ( i > - 1 ) { MST[rv.CRCR4Mutator]MSP[S]
final String msg = MessageFormat . format ( HTTP_EX_3 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR5Mutator]MSP[N] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( cTEnc == null ) {
encoding = encoding . substring ( 1 , encoding . length () - 1 ) ; } } } return encoding ; } static boolean isAppXml ( final String mime ) { return mime != null && ( mime . equals ( lr_8 ) || MST[rv.ROR4Mutator]MSP[N]
if ( cTEnc . equals ( UTF_32 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_32 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR3Mutator]MSP[N]
mime . equals ( lr_9 ) || mime . equals ( lr_10 ) || mime . startsWith ( lr_11 ) && mime . endsWith ( lr_12 ) ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] } static boolean isTextXml ( final String mime ) { return mime != null &&
final String msg = MessageFormat . format ( HTTP_EX_3 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR2Mutator]MSP[S] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( cTEnc == null ) {
if ( lenient ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return doLenientDetection ( null , ex ) ; } throw ex ; } } private String doHttpStream ( final BOMInputStream bom , final BOMInputStream pis , final String httpContentType , final boolean lenient ) throws IOException {
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_32 ) && ! xmlEnc . equals ( bomEnc ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR3Mutator]MSP[N]
} catch ( final XmlStreamReaderException ex ) { if ( lenient ) { MST[rv.ABSMutator]MSP[S] return doLenientDetection ( httpContentType , ex ) ; } throw ex ; } } private String doLenientDetection ( String httpContentType , XmlStreamReaderException ex ) throws IOException {
if ( cTEnc . equals ( UTF_16 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_16 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[InlineConstantMutator]MSP[N]
String calculateHttpEncoding ( final String httpContentType , final String bomEnc , final String xmlGuessEnc , final String xmlEnc , final boolean lenient ) throws IOException { if ( lenient && xmlEnc != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return xmlEnc ; } final String cTMime = getContentTypeMime ( httpContentType ) ;
mime . equals ( lr_9 ) || mime . equals ( lr_10 ) || mime . startsWith ( lr_11 ) && mime . endsWith ( lr_12 ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } static boolean isTextXml ( final String mime ) { return mime != null &&
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } if ( bomEnc . equals ( UTF_16BE ) || bomEnc . equals ( UTF_16LE ) ) { MST[rv.ROR4Mutator]MSP[N] if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( bomEnc ) ) {
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } if ( bomEnc . equals ( UTF_16BE ) || bomEnc . equals ( UTF_16LE ) ) { MST[rv.ROR1Mutator]MSP[N] if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( bomEnc ) ) {
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR3Mutator]MSP[N] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR4Mutator]MSP[S] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( xmlEnc != null && ! xmlEnc . equals ( UTF_8 ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[ArgumentPropagationMutator]MSP[N]
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ; MST[rv.ABSMutator]MSP[N]
final String cTEnc = getContentTypeEncoding ( httpContentType ) ; final boolean appXml = isAppXml ( cTMime ) ; final boolean textXml = isTextXml ( cTMime ) ; if ( ! appXml && ! textXml ) { MST[rv.ROR1Mutator]MSP[N]
mime . equals ( lr_9 ) || mime . equals ( lr_10 ) || MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] mime . startsWith ( lr_11 ) && mime . endsWith ( lr_12 ) ) ; } static boolean isTextXml ( final String mime ) { return mime != null &&
encoding = encoding . substring ( 1 , encoding . length () - 1 ) ; } } } return encoding ; } static boolean isAppXml ( final String mime ) { return mime != null && MST[rv.ROR5Mutator]MSP[N] ( mime . equals ( lr_8 ) ||
( mime . equals ( lr_2 ) || mime . equals ( lr_13 ) || mime . startsWith ( lr_14 ) && mime . endsWith ( lr_12 ) ) ; MST[NegateConditionalsMutator]MSP[S] }
} return xmlEnc ; } if ( bomEnc . equals ( UTF_8 ) ) { if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( UTF_8 ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR6Mutator]MSP[S]
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { MST[rv.CRCR4Mutator]MSP[N] offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ;
final String postMime = httpContentType . substring ( i + 1 ) ; final Matcher m = CHARSET_PATTERN . matcher ( postMime ) ; encoding = m . find () ? m . group ( 1 ) : null ; MST[rv.ROR3Mutator]MSP[N]
xmlProlog = new String ( bytes , 0 , offset , guessedEnc ) ; firstGT = xmlProlog . indexOf ( '>' ) ; MST[NonVoidMethodCallMutator]MSP[N] } if ( firstGT == - 1 ) { if ( c == - 1 ) { throw new IOException ( lr_5 ) ; }
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { MST[rv.ABSMutator]MSP[N] offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ;
if ( appXml ) { return calculateRawEncoding ( bomEnc , xmlGuessEnc , xmlEnc ) ; } return defaultEncoding == null ? US_ASCII : defaultEncoding ; } if ( cTEnc . equals ( UTF_16BE ) || cTEnc . equals ( UTF_16LE ) ) { MST[NonVoidMethodCallMutator]MSP[S] if ( bomEnc != null ) {
String calculateHttpEncoding ( final String httpContentType , final String bomEnc , final String xmlGuessEnc , final String xmlEnc , final boolean lenient ) throws IOException { if ( lenient && xmlEnc != null ) { MST[rv.UOI2Mutator]MSP[S] return xmlEnc ; } final String cTMime = getContentTypeMime ( httpContentType ) ;
if ( cTEnc . equals ( UTF_32 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_32 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR2Mutator]MSP[N]
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR4Mutator]MSP[N] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
ex . getXmlGuessEncoding () , ex . getXmlEncoding () , true ) ; } catch ( final XmlStreamReaderException ex2 ) { ex = ex2 ; } } String encoding = ex . getXmlEncoding () ; if ( encoding == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] encoding = ex . getContentTypeEncoding () ; }
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; MST[EmptyObjectReturnValsMutator]MSP[N] }
} return xmlEnc ; } if ( bomEnc . equals ( UTF_8 ) ) { if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( UTF_8 ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR3Mutator]MSP[S]
final String cTEnc = getContentTypeEncoding ( httpContentType ) ; MST[NonVoidMethodCallMutator]MSP[N] final boolean appXml = isAppXml ( cTMime ) ; final boolean textXml = isTextXml ( cTMime ) ; if ( ! appXml && ! textXml ) {
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_16 ) && ! xmlEnc . equals ( bomEnc ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR1Mutator]MSP[S]
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ; MST[rv.UOI2Mutator]MSP[N]
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_16 ) && ! xmlEnc . equals ( bomEnc ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR5Mutator]MSP[N]
( mime . equals ( lr_2 ) || MST[rv.ROR1Mutator]MSP[N] mime . equals ( lr_13 ) || mime . startsWith ( lr_14 ) && mime . endsWith ( lr_12 ) ) ; }
xmlProlog . substring ( 0 , firstGT + 1 ) ) ) ; final StringBuffer prolog = new StringBuffer () ; String line = bReader . readLine () ; while ( line != null ) { prolog . append ( line ) ; MST[experimental.NakedReceiverMutator]MSP[N] line = bReader . readLine () ;
if ( appXml ) { MST[rv.UOI2Mutator]MSP[S] return calculateRawEncoding ( bomEnc , xmlGuessEnc , xmlEnc ) ; } return defaultEncoding == null ? US_ASCII : defaultEncoding ; } if ( cTEnc . equals ( UTF_16BE ) || cTEnc . equals ( UTF_16LE ) ) { if ( bomEnc != null ) {
if ( guessedEnc != null ) { final byte [] bytes = new byte [ BUFFER_SIZE ] ; is . mark ( BUFFER_SIZE ) ; int offset = 0 ; int max = BUFFER_SIZE ; int c = is . read ( bytes , offset , max ) ; MST[rv.UOI4Mutator]MSP[N]
if ( lenient ) { MST[rv.ROR1Mutator]MSP[S] return doLenientDetection ( null , ex ) ; } throw ex ; } } private String doHttpStream ( final BOMInputStream bom , final BOMInputStream pis , final String httpContentType , final boolean lenient ) throws IOException {
xmlProlog = new String ( bytes , 0 , offset , guessedEnc ) ; firstGT = xmlProlog . indexOf ( '>' ) ; } if ( firstGT == - 1 ) { MST[rv.ROR1Mutator]MSP[N] if ( c == - 1 ) { throw new IOException ( lr_5 ) ; }
throw new IOException ( lr_6 + offset + lr_7 ) ; } final int bytesRead = offset ; if ( bytesRead > 0 ) { is . reset () ; final BufferedReader bReader = new BufferedReader ( new StringReader ( MST[rv.CRCR1Mutator]MSP[N]
final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR1Mutator]MSP[S] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
static String getContentTypeEncoding ( final String httpContentType ) { String encoding = null ; if ( httpContentType != null ) { final int i = httpContentType . indexOf ( lr_3 ) ; if ( i > - 1 ) { MST[rv.CRCR1Mutator]MSP[S]
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( xmlEnc != null && ! xmlEnc . equals ( UTF_8 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
final String postMime = httpContentType . substring ( i + 1 ) ; MST[rv.AOD2Mutator]MSP[S] final Matcher m = CHARSET_PATTERN . matcher ( postMime ) ; encoding = m . find () ? m . group ( 1 ) : null ;
} return xmlEnc ; } if ( bomEnc . equals ( UTF_8 ) ) { if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( UTF_8 ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[ArgumentPropagationMutator]MSP[S]
throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( cTEnc . equals ( UTF_32BE ) || cTEnc . equals ( UTF_32LE ) ) { MST[NonVoidMethodCallMutator]MSP[N] if ( bomEnc != null ) {
encoding = encoding . substring ( 1 , encoding . length () - 1 ) ; MST[rv.CRCR6Mutator]MSP[N] } } } return encoding ; } static boolean isAppXml ( final String mime ) { return mime != null && ( mime . equals ( lr_8 ) ||
mime . equals ( lr_9 ) || mime . equals ( lr_10 ) || mime . startsWith ( lr_11 ) && mime . endsWith ( lr_12 ) ) ; MST[rv.ROR3Mutator]MSP[N] } static boolean isTextXml ( final String mime ) { return mime != null &&
final String bomEnc = bom . getBOMCharsetName () ; MST[NonVoidMethodCallMutator]MSP[N] final String xmlGuessEnc = pis . getBOMCharsetName () ; final String xmlEnc = getXmlProlog ( pis , xmlGuessEnc ) ; try { return calculateHttpEncoding ( httpContentType , bomEnc , xmlGuessEnc , xmlEnc , lenient ) ;
ex . getXmlGuessEncoding () , ex . getXmlEncoding () , true ) ; MST[NonVoidMethodCallMutator]MSP[N] } catch ( final XmlStreamReaderException ex2 ) { ex = ex2 ; } } String encoding = ex . getXmlEncoding () ; if ( encoding == null ) { encoding = ex . getContentTypeEncoding () ; }
mime . equals ( lr_9 ) || mime . equals ( lr_10 ) || MST[rv.ROR1Mutator]MSP[N] mime . startsWith ( lr_11 ) && mime . endsWith ( lr_12 ) ) ; } static boolean isTextXml ( final String mime ) { return mime != null &&
if ( cTEnc . equals ( UTF_16 ) ) { MST[rv.ROR3Mutator]MSP[N] if ( bomEnc != null && bomEnc . startsWith ( UTF_16 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ;
final int i = httpContentType . indexOf ( lr_3 ) ; if ( i >= 0 ) { MST[rv.ROR3Mutator]MSP[N] mime = httpContentType . substring ( 0 , i ) ; } else { mime = httpContentType ; } mime = mime . trim () ; } return mime ; }
if ( xmlGuessEnc == null || xmlEnc == null ) { return defaultEncoding == null ? UTF_8 : defaultEncoding ; } if ( xmlEnc . equals ( UTF_16 ) && MST[rv.ROR3Mutator]MSP[S] ( xmlGuessEnc . equals ( UTF_16BE ) || xmlGuessEnc . equals ( UTF_16LE ) ) ) { return xmlGuessEnc ;
if ( appXml ) { return calculateRawEncoding ( bomEnc , xmlGuessEnc , xmlEnc ) ; } return defaultEncoding == null ? US_ASCII : defaultEncoding ; } if ( cTEnc . equals ( UTF_16BE ) || cTEnc . equals ( UTF_16LE ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] if ( bomEnc != null ) {
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[InlineConstantMutator]MSP[N] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
if ( cTEnc . equals ( UTF_32 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] if ( bomEnc != null && bomEnc . startsWith ( UTF_32 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ;
xmlProlog = new String ( bytes , 0 , offset , guessedEnc ) ; firstGT = xmlProlog . indexOf ( '>' ) ; } if ( firstGT == - 1 ) { MST[rv.UOI4Mutator]MSP[N] if ( c == - 1 ) { throw new IOException ( lr_5 ) ; }
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( xmlEnc != null && ! xmlEnc . equals ( UTF_8 ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR3Mutator]MSP[N]
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } if ( bomEnc . equals ( UTF_32BE ) || bomEnc . equals ( UTF_32LE ) ) { if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( bomEnc ) ) { MST[rv.ROR2Mutator]MSP[N]
if ( cTEnc . equals ( UTF_16 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_16 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR3Mutator]MSP[N]
if ( cTEnc . equals ( UTF_16 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_16 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ;
throw new IOException ( lr_6 + offset + lr_7 ) ; } final int bytesRead = offset ; if ( bytesRead > 0 ) { MST[rv.ROR4Mutator]MSP[N] is . reset () ; final BufferedReader bReader = new BufferedReader ( new StringReader (
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_32 ) && ! xmlEnc . equals ( bomEnc ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[ArgumentPropagationMutator]MSP[S]
if ( cTEnc . equals ( UTF_32 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_32 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[InlineConstantMutator]MSP[N]
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } final String msg = MessageFormat . format ( RAW_EX_2 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR1Mutator]MSP[S] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
( mime . equals ( lr_2 ) || mime . equals ( lr_13 ) || MST[rv.ROR3Mutator]MSP[S] mime . startsWith ( lr_14 ) && mime . endsWith ( lr_12 ) ) ; }
final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR6Mutator]MSP[N] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
ex . getXmlGuessEncoding () , ex . getXmlEncoding () , true ) ; MST[rv.CRCR5Mutator]MSP[N] } catch ( final XmlStreamReaderException ex2 ) { ex = ex2 ; } } String encoding = ex . getXmlEncoding () ; if ( encoding == null ) { encoding = ex . getContentTypeEncoding () ; }
if ( encoding == null ) { encoding = defaultEncoding == null ? UTF_8 : defaultEncoding ; } return encoding ; } String calculateRawEncoding ( final String bomEnc , final String xmlGuessEnc , final String xmlEnc ) throws IOException { if ( bomEnc == null ) { MST[rv.ROR5Mutator]MSP[N]
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_32 ) && ! xmlEnc . equals ( bomEnc ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR3Mutator]MSP[N]
if ( appXml ) { return calculateRawEncoding ( bomEnc , xmlGuessEnc , xmlEnc ) ; } return defaultEncoding == null ? US_ASCII : defaultEncoding ; MST[ReturnValsMutator]MSP[N] } if ( cTEnc . equals ( UTF_16BE ) || cTEnc . equals ( UTF_16LE ) ) { if ( bomEnc != null ) {
final String msg = MessageFormat . format ( HTTP_EX_3 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( cTEnc == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
} return xmlEnc ; } if ( bomEnc . equals ( UTF_8 ) ) { MST[rv.ROR2Mutator]MSP[S] if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( UTF_8 ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
xmlProlog . substring ( 0 , firstGT + 1 ) ) ) ; MST[NonVoidMethodCallMutator]MSP[N] final StringBuffer prolog = new StringBuffer () ; String line = bReader . readLine () ; while ( line != null ) { prolog . append ( line ) ; line = bReader . readLine () ;
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { MST[rv.UOI1Mutator]MSP[N] offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ;
mime . equals ( lr_9 ) || mime . equals ( lr_10 ) || mime . startsWith ( lr_11 ) && mime . endsWith ( lr_12 ) ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] } static boolean isTextXml ( final String mime ) { return mime != null &&
final String msg = MessageFormat . format ( HTTP_EX_3 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR5Mutator]MSP[S] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( cTEnc == null ) {
static String getContentTypeEncoding ( final String httpContentType ) { String encoding = null ; if ( httpContentType != null ) { final int i = httpContentType . indexOf ( lr_3 ) ; if ( i > - 1 ) { MST[rv.ROR1Mutator]MSP[S]
xmlProlog . substring ( 0 , firstGT + 1 ) ) ) ; final StringBuffer prolog = new StringBuffer () ; String line = bReader . readLine () ; while ( line != null ) { MST[rv.ROR5Mutator]MSP[N] prolog . append ( line ) ; line = bReader . readLine () ;
if ( cTEnc . equals ( UTF_16 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_16 ) ) { MST[NonVoidMethodCallMutator]MSP[N] return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ;
( mime . equals ( lr_2 ) || mime . equals ( lr_13 ) || mime . startsWith ( lr_14 ) && mime . endsWith ( lr_12 ) ) ; MST[rv.ROR5Mutator]MSP[S] }
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } if ( bomEnc . equals ( UTF_16BE ) || bomEnc . equals ( UTF_16LE ) ) { MST[rv.ROR4Mutator]MSP[N] if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( bomEnc ) ) {
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { MST[rv.ROR4Mutator]MSP[N] offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ;
xmlProlog = new String ( bytes , 0 , offset , guessedEnc ) ; firstGT = xmlProlog . indexOf ( '>' ) ; } if ( firstGT == - 1 ) { MST[rv.CRCR1Mutator]MSP[N] if ( c == - 1 ) { throw new IOException ( lr_5 ) ; }
xmlProlog = new String ( bytes , 0 , offset , guessedEnc ) ; MST[rv.CRCR6Mutator]MSP[N] firstGT = xmlProlog . indexOf ( '>' ) ; } if ( firstGT == - 1 ) { if ( c == - 1 ) { throw new IOException ( lr_5 ) ; }
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR3Mutator]MSP[N] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { offset += c ; MST[rv.UOI3Mutator]MSP[N] max -= c ; c = is . read ( bytes , offset , max ) ;
if ( cTEnc . equals ( UTF_32 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_32 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR4Mutator]MSP[N]
return reader . read ( buf , offset , len ) ; MST[rv.UOI2Mutator]MSP[S] } @Override public void close () throws IOException { reader . close () ; } private String doRawStream ( final BOMInputStream bom , final BOMInputStream pis , final boolean lenient ) throws IOException {
String calculateHttpEncoding ( final String httpContentType , final String bomEnc , final String xmlGuessEnc , final String xmlEnc , final boolean lenient ) throws IOException { if ( lenient && xmlEnc != null ) { return xmlEnc ; MST[ReturnValsMutator]MSP[N] } final String cTMime = getContentTypeMime ( httpContentType ) ;
throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( cTEnc . equals ( UTF_32BE ) || cTEnc . equals ( UTF_32LE ) ) { if ( bomEnc != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S]
mime . equals ( lr_9 ) || mime . equals ( lr_10 ) || mime . startsWith ( lr_11 ) && mime . endsWith ( lr_12 ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } static boolean isTextXml ( final String mime ) { return mime != null &&
static String getContentTypeEncoding ( final String httpContentType ) { String encoding = null ; if ( httpContentType != null ) { final int i = httpContentType . indexOf ( lr_3 ) ; if ( i > - 1 ) { MST[rv.UOI4Mutator]MSP[S]
throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; MST[ReturnValsMutator]MSP[S] } static String getContentTypeMime ( final String httpContentType ) { String mime = null ; if ( httpContentType != null ) {
} return xmlEnc ; } if ( bomEnc . equals ( UTF_8 ) ) { if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( UTF_8 ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR5Mutator]MSP[S]
} return xmlEnc ; } if ( bomEnc . equals ( UTF_8 ) ) { if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( UTF_8 ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR6Mutator]MSP[S]
final String msg = MessageFormat . format ( HTTP_EX_3 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR1Mutator]MSP[S] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( cTEnc == null ) {
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR6Mutator]MSP[N] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ;
xmlProlog . substring ( 0 , firstGT + 1 ) ) ) ; final StringBuffer prolog = new StringBuffer () ; String line = bReader . readLine () ; MST[NonVoidMethodCallMutator]MSP[N] while ( line != null ) { prolog . append ( line ) ; line = bReader . readLine () ;
if ( cTEnc . equals ( UTF_32 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_32 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR5Mutator]MSP[N]
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { MST[rv.ROR3Mutator]MSP[N] offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ;
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR3Mutator]MSP[N] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
throw new IOException ( lr_6 + offset + lr_7 ) ; } final int bytesRead = offset ; if ( bytesRead > 0 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] is . reset () ; final BufferedReader bReader = new BufferedReader ( new StringReader (
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_32 ) && ! xmlEnc . equals ( bomEnc ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
return reader . read ( buf , offset , len ) ; MST[rv.UOI2Mutator]MSP[S] } @Override public void close () throws IOException { reader . close () ; } private String doRawStream ( final BOMInputStream bom , final BOMInputStream pis , final boolean lenient ) throws IOException {
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_16 ) && ! xmlEnc . equals ( bomEnc ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR5Mutator]MSP[S]
final int i = httpContentType . indexOf ( lr_3 ) ; if ( i >= 0 ) { MST[ConditionalsBoundaryMutator]MSP[N] mime = httpContentType . substring ( 0 , i ) ; } else { mime = httpContentType ; } mime = mime . trim () ; } return mime ; }
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } if ( bomEnc . equals ( UTF_16BE ) || bomEnc . equals ( UTF_16LE ) ) { if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( bomEnc ) ) { MST[rv.ROR1Mutator]MSP[N]
final String cTEnc = getContentTypeEncoding ( httpContentType ) ; final boolean appXml = isAppXml ( cTMime ) ; final boolean textXml = isTextXml ( cTMime ) ; if ( ! appXml && ! textXml ) { MST[rv.ROR2Mutator]MSP[N]
throw new IOException ( lr_6 + offset + lr_7 ) ; } final int bytesRead = offset ; if ( bytesRead > 0 ) { is . reset () ; final BufferedReader bReader = new BufferedReader ( new StringReader ( MST[rv.AOR3Mutator]MSP[N]
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_32 ) && ! xmlEnc . equals ( bomEnc ) ) { MST[rv.ROR3Mutator]MSP[S] final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
} return xmlEnc ; } if ( bomEnc . equals ( UTF_8 ) ) { if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( UTF_8 ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR3Mutator]MSP[S]
if ( cTEnc . equals ( UTF_32 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_32 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR6Mutator]MSP[N]
if ( guessedEnc != null ) { final byte [] bytes = new byte [ BUFFER_SIZE ] ; is . mark ( BUFFER_SIZE ) ; MST[rv.CRCR2Mutator]MSP[N] int offset = 0 ; int max = BUFFER_SIZE ; int c = is . read ( bytes , offset , max ) ;
final String msg = MessageFormat . format ( HTTP_EX_3 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR4Mutator]MSP[N] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( cTEnc == null ) {
} final Matcher m = ENCODING_PATTERN . matcher ( prolog ) ; if ( m . find () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] encoding = m . group ( 1 ) . toUpperCase ( Locale . ROOT ) ;
throw new IOException ( lr_6 + offset + lr_7 ) ; } final int bytesRead = offset ; if ( bytesRead > 0 ) { is . reset () ; MST[VoidMethodCallMutator]MSP[N] final BufferedReader bReader = new BufferedReader ( new StringReader (
if ( guessedEnc != null ) { final byte [] bytes = new byte [ BUFFER_SIZE ] ; MST[rv.CRCR4Mutator]MSP[N] is . mark ( BUFFER_SIZE ) ; int offset = 0 ; int max = BUFFER_SIZE ; int c = is . read ( bytes , offset , max ) ;
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR6Mutator]MSP[N] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
mime . equals ( lr_9 ) || mime . equals ( lr_10 ) || mime . startsWith ( lr_11 ) && mime . endsWith ( lr_12 ) ) ; MST[rv.ROR3Mutator]MSP[N] } static boolean isTextXml ( final String mime ) { return mime != null &&
final int i = httpContentType . indexOf ( lr_3 ) ; if ( i >= 0 ) { mime = httpContentType . substring ( 0 , i ) ; } else { mime = httpContentType ; } mime = mime . trim () ; } return mime ; MST[ReturnValsMutator]MSP[N] }
final int i = httpContentType . indexOf ( lr_3 ) ; if ( i >= 0 ) { mime = httpContentType . substring ( 0 , i ) ; MST[rv.UOI4Mutator]MSP[N] } else { mime = httpContentType ; } mime = mime . trim () ; } return mime ; }
if ( guessedEnc != null ) { final byte [] bytes = new byte [ BUFFER_SIZE ] ; is . mark ( BUFFER_SIZE ) ; MST[rv.CRCR6Mutator]MSP[N] int offset = 0 ; int max = BUFFER_SIZE ; int c = is . read ( bytes , offset , max ) ;
final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR3Mutator]MSP[S] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
if ( cTEnc . equals ( UTF_16 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_16 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR3Mutator]MSP[N]
} final Matcher m = ENCODING_PATTERN . matcher ( prolog ) ; if ( m . find () ) { MST[rv.ROR3Mutator]MSP[N] encoding = m . group ( 1 ) . toUpperCase ( Locale . ROOT ) ;
( mime . equals ( lr_2 ) || mime . equals ( lr_13 ) || mime . startsWith ( lr_14 ) && mime . endsWith ( lr_12 ) ) ; MST[NonVoidMethodCallMutator]MSP[S] }
mime . equals ( lr_9 ) || mime . equals ( lr_10 ) || mime . startsWith ( lr_11 ) && mime . endsWith ( lr_12 ) ) ; MST[rv.CRCR3Mutator]MSP[S] } static boolean isTextXml ( final String mime ) { return mime != null &&
final String cTEnc = getContentTypeEncoding ( httpContentType ) ; final boolean appXml = isAppXml ( cTMime ) ; MST[NonVoidMethodCallMutator]MSP[N] final boolean textXml = isTextXml ( cTMime ) ; if ( ! appXml && ! textXml ) {
final String msg = MessageFormat . format ( HTTP_EX_3 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[InlineConstantMutator]MSP[S] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( cTEnc == null ) {
final String cTEnc = getContentTypeEncoding ( httpContentType ) ; final boolean appXml = isAppXml ( cTMime ) ; final boolean textXml = isTextXml ( cTMime ) ; if ( ! appXml && ! textXml ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
encoding = encoding . substring ( 1 , encoding . length () - 1 ) ; MST[rv.AOD1Mutator]MSP[N] } } } return encoding ; } static boolean isAppXml ( final String mime ) { return mime != null && ( mime . equals ( lr_8 ) ||
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; MST[ReturnValsMutator]MSP[N] }
} return xmlEnc ; MST[ReturnValsMutator]MSP[N] } if ( bomEnc . equals ( UTF_8 ) ) { if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( UTF_8 ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
throw new IOException ( lr_6 + offset + lr_7 ) ; } final int bytesRead = offset ; if ( bytesRead > 0 ) { MST[rv.UOI3Mutator]MSP[N] is . reset () ; final BufferedReader bReader = new BufferedReader ( new StringReader (
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { offset += c ; MST[rv.AOR1Mutator]MSP[N] max -= c ; c = is . read ( bytes , offset , max ) ;
if ( cTEnc . equals ( UTF_16 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_16 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR6Mutator]MSP[N]
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { offset += c ; MST[rv.AOR4Mutator]MSP[N] max -= c ; c = is . read ( bytes , offset , max ) ;
if ( cTEnc . equals ( UTF_32 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_32 ) ) { MST[rv.ROR3Mutator]MSP[N] return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ;
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { offset += c ; max -= c ; MST[rv.ABSMutator]MSP[N] c = is . read ( bytes , offset , max ) ;
if ( appXml ) { return calculateRawEncoding ( bomEnc , xmlGuessEnc , xmlEnc ) ; } return defaultEncoding == null ? US_ASCII : defaultEncoding ; MST[rv.ROR5Mutator]MSP[N] } if ( cTEnc . equals ( UTF_16BE ) || cTEnc . equals ( UTF_16LE ) ) { if ( bomEnc != null ) {
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR3Mutator]MSP[N] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } final String msg = MessageFormat . format ( RAW_EX_2 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR6Mutator]MSP[S] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
xmlProlog = new String ( bytes , 0 , offset , guessedEnc ) ; MST[rv.UOI1Mutator]MSP[N] firstGT = xmlProlog . indexOf ( '>' ) ; } if ( firstGT == - 1 ) { if ( c == - 1 ) { throw new IOException ( lr_5 ) ; }
if ( cTEnc . equals ( UTF_16 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] if ( bomEnc != null && bomEnc . startsWith ( UTF_16 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ;
xmlProlog = new String ( bytes , 0 , offset , guessedEnc ) ; MST[rv.ABSMutator]MSP[N] firstGT = xmlProlog . indexOf ( '>' ) ; } if ( firstGT == - 1 ) { if ( c == - 1 ) { throw new IOException ( lr_5 ) ; }
final String postMime = httpContentType . substring ( i + 1 ) ; final Matcher m = CHARSET_PATTERN . matcher ( postMime ) ; encoding = m . find () ? m . group ( 1 ) : null ; MST[rv.CRCR3Mutator]MSP[N]
mime . equals ( lr_9 ) || mime . equals ( lr_10 ) || mime . startsWith ( lr_11 ) && mime . endsWith ( lr_12 ) ) ; MST[rv.CRCR6Mutator]MSP[N] } static boolean isTextXml ( final String mime ) { return mime != null &&
final String cTEnc = getContentTypeEncoding ( httpContentType ) ; final boolean appXml = isAppXml ( cTMime ) ; final boolean textXml = isTextXml ( cTMime ) ; if ( ! appXml && ! textXml ) { MST[rv.UOI1Mutator]MSP[N]
final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR6Mutator]MSP[N] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
if ( xmlGuessEnc == null || xmlEnc == null ) { return defaultEncoding == null ? UTF_8 : defaultEncoding ; } if ( xmlEnc . equals ( UTF_16 ) && ( xmlGuessEnc . equals ( UTF_16BE ) || xmlGuessEnc . equals ( UTF_16LE ) ) ) { MST[NonVoidMethodCallMutator]MSP[S] return xmlGuessEnc ;
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } if ( bomEnc . equals ( UTF_32BE ) || bomEnc . equals ( UTF_32LE ) ) { MST[rv.ROR3Mutator]MSP[N] if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( bomEnc ) ) {
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } if ( bomEnc . equals ( UTF_32BE ) || bomEnc . equals ( UTF_32LE ) ) { if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( bomEnc ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
encoding = encoding . substring ( 1 , encoding . length () - 1 ) ; MST[NonVoidMethodCallMutator]MSP[N] } } } return encoding ; } static boolean isAppXml ( final String mime ) { return mime != null && ( mime . equals ( lr_8 ) ||
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR5Mutator]MSP[N] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
} catch ( final XmlStreamReaderException ex ) { if ( lenient ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return doLenientDetection ( httpContentType , ex ) ; } throw ex ; } } private String doLenientDetection ( String httpContentType , XmlStreamReaderException ex ) throws IOException {
( mime . equals ( lr_2 ) || MST[rv.ROR5Mutator]MSP[N] mime . equals ( lr_13 ) || mime . startsWith ( lr_14 ) && mime . endsWith ( lr_12 ) ) ; }
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_32 ) && ! xmlEnc . equals ( bomEnc ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR3Mutator]MSP[N]
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR2Mutator]MSP[N] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
} return xmlEnc ; } if ( bomEnc . equals ( UTF_8 ) ) { if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( UTF_8 ) ) { MST[rv.ROR3Mutator]MSP[S] final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
String calculateHttpEncoding ( final String httpContentType , final String bomEnc , final String xmlGuessEnc , final String xmlEnc , final boolean lenient ) throws IOException { if ( lenient && xmlEnc != null ) { MST[rv.ABSMutator]MSP[S] return xmlEnc ; } final String cTMime = getContentTypeMime ( httpContentType ) ;
if ( cTEnc . equals ( UTF_32 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_32 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR3Mutator]MSP[N]
if ( xmlGuessEnc == null || xmlEnc == null ) { return defaultEncoding == null ? UTF_8 : defaultEncoding ; } if ( xmlEnc . equals ( UTF_16 ) && ( xmlGuessEnc . equals ( UTF_16BE ) || xmlGuessEnc . equals ( UTF_16LE ) ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] return xmlGuessEnc ;
throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( cTEnc . equals ( UTF_32BE ) || cTEnc . equals ( UTF_32LE ) ) { MST[rv.ROR3Mutator]MSP[N] if ( bomEnc != null ) {
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { offset += c ; max -= c ; MST[rv.UOI1Mutator]MSP[N] c = is . read ( bytes , offset , max ) ;
if ( guessedEnc != null ) { final byte [] bytes = new byte [ BUFFER_SIZE ] ; is . mark ( BUFFER_SIZE ) ; int offset = 0 ; int max = BUFFER_SIZE ; MST[rv.CRCR3Mutator]MSP[N] int c = is . read ( bytes , offset , max ) ;
throw new IOException ( lr_6 + offset + lr_7 ) ; } final int bytesRead = offset ; if ( bytesRead > 0 ) { is . reset () ; final BufferedReader bReader = new BufferedReader ( new StringReader ( MST[rv.CRCR6Mutator]MSP[N]
throw new IOException ( lr_6 + offset + lr_7 ) ; } final int bytesRead = offset ; if ( bytesRead > 0 ) { is . reset () ; final BufferedReader bReader = new BufferedReader ( new StringReader ( MST[rv.UOI2Mutator]MSP[N]
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_16 ) && ! xmlEnc . equals ( bomEnc ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR2Mutator]MSP[S]
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { MST[rv.CRCR2Mutator]MSP[N] offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ;
} return xmlEnc ; } if ( bomEnc . equals ( UTF_8 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( UTF_8 ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[InlineConstantMutator]MSP[S] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
return reader . read ( buf , offset , len ) ; MST[rv.ABSMutator]MSP[N] } @Override public void close () throws IOException { reader . close () ; } private String doRawStream ( final BOMInputStream bom , final BOMInputStream pis , final boolean lenient ) throws IOException {
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } if ( bomEnc . equals ( UTF_16BE ) || bomEnc . equals ( UTF_16LE ) ) { if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( bomEnc ) ) { MST[rv.ROR4Mutator]MSP[N]
if ( lenient ) { MST[rv.UOI3Mutator]MSP[S] return doLenientDetection ( null , ex ) ; } throw ex ; } } private String doHttpStream ( final BOMInputStream bom , final BOMInputStream pis , final String httpContentType , final boolean lenient ) throws IOException {
if ( appXml ) { MST[rv.ABSMutator]MSP[S] return calculateRawEncoding ( bomEnc , xmlGuessEnc , xmlEnc ) ; } return defaultEncoding == null ? US_ASCII : defaultEncoding ; } if ( cTEnc . equals ( UTF_16BE ) || cTEnc . equals ( UTF_16LE ) ) { if ( bomEnc != null ) {
} catch ( final XmlStreamReaderException ex ) { if ( lenient ) { MST[rv.UOI4Mutator]MSP[N] return doLenientDetection ( httpContentType , ex ) ; } throw ex ; } } private String doLenientDetection ( String httpContentType , XmlStreamReaderException ex ) throws IOException {
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_32 ) && ! xmlEnc . equals ( bomEnc ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR2Mutator]MSP[N]
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } if ( bomEnc . equals ( UTF_32BE ) || bomEnc . equals ( UTF_32LE ) ) { if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( bomEnc ) ) { MST[NonVoidMethodCallMutator]MSP[N]
ex . getXmlGuessEncoding () , ex . getXmlEncoding () , true ) ; } catch ( final XmlStreamReaderException ex2 ) { ex = ex2 ; } } String encoding = ex . getXmlEncoding () ; if ( encoding == null ) { MST[rv.ROR5Mutator]MSP[S] encoding = ex . getContentTypeEncoding () ; }
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR3Mutator]MSP[N] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { offset += c ; max -= c ; MST[rv.UOI2Mutator]MSP[N] c = is . read ( bytes , offset , max ) ;
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR5Mutator]MSP[N] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { offset += c ; max -= c ; MST[rv.AOR3Mutator]MSP[N] c = is . read ( bytes , offset , max ) ;
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_16 ) && ! xmlEnc . equals ( bomEnc ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR5Mutator]MSP[S]
if ( appXml ) { return calculateRawEncoding ( bomEnc , xmlGuessEnc , xmlEnc ) ; } return defaultEncoding == null ? US_ASCII : defaultEncoding ; } if ( cTEnc . equals ( UTF_16BE ) || cTEnc . equals ( UTF_16LE ) ) { if ( bomEnc != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S]
if ( xmlGuessEnc == null || xmlEnc == null ) { return defaultEncoding == null ? UTF_8 : defaultEncoding ; } if ( xmlEnc . equals ( UTF_16 ) && ( xmlGuessEnc . equals ( UTF_16BE ) || xmlGuessEnc . equals ( UTF_16LE ) ) ) { MST[rv.ROR2Mutator]MSP[S] return xmlGuessEnc ;
} final Matcher m = ENCODING_PATTERN . matcher ( prolog ) ; if ( m . find () ) { encoding = m . group ( 1 ) . toUpperCase ( Locale . ROOT ) ; MST[rv.CRCR6Mutator]MSP[N]
( mime . equals ( lr_2 ) || mime . equals ( lr_13 ) || MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] mime . startsWith ( lr_14 ) && mime . endsWith ( lr_12 ) ) ; }
encoding = encoding . substring ( 1 , encoding . length () - 1 ) ; } } } return encoding ; } static boolean isAppXml ( final String mime ) { return mime != null && MST[NegateConditionalsMutator]MSP[N] ( mime . equals ( lr_8 ) ||
if ( appXml ) { MST[rv.ROR3Mutator]MSP[N] return calculateRawEncoding ( bomEnc , xmlGuessEnc , xmlEnc ) ; } return defaultEncoding == null ? US_ASCII : defaultEncoding ; } if ( cTEnc . equals ( UTF_16BE ) || cTEnc . equals ( UTF_16LE ) ) { if ( bomEnc != null ) {
if ( xmlGuessEnc == null || xmlEnc == null ) { return defaultEncoding == null ? UTF_8 : defaultEncoding ; } if ( xmlEnc . equals ( UTF_16 ) && MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] ( xmlGuessEnc . equals ( UTF_16BE ) || xmlGuessEnc . equals ( UTF_16LE ) ) ) { return xmlGuessEnc ;
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } final String msg = MessageFormat . format ( RAW_EX_2 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[InlineConstantMutator]MSP[S] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
if ( encoding == null ) { encoding = defaultEncoding == null ? UTF_8 : defaultEncoding ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } return encoding ; } String calculateRawEncoding ( final String bomEnc , final String xmlGuessEnc , final String xmlEnc ) throws IOException { if ( bomEnc == null ) {
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_16 ) && ! xmlEnc . equals ( bomEnc ) ) { MST[rv.ROR1Mutator]MSP[N] final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
xmlProlog = new String ( bytes , 0 , offset , guessedEnc ) ; firstGT = xmlProlog . indexOf ( '>' ) ; } if ( firstGT == - 1 ) { MST[rv.CRCR4Mutator]MSP[N] if ( c == - 1 ) { throw new IOException ( lr_5 ) ; }
String calculateHttpEncoding ( final String httpContentType , final String bomEnc , final String xmlGuessEnc , final String xmlEnc , final boolean lenient ) throws IOException { if ( lenient && xmlEnc != null ) { MST[rv.ROR3Mutator]MSP[N] return xmlEnc ; } final String cTMime = getContentTypeMime ( httpContentType ) ;
} final Matcher m = ENCODING_PATTERN . matcher ( prolog ) ; if ( m . find () ) { encoding = m . group ( 1 ) . toUpperCase ( Locale . ROOT ) ; MST[experimental.NakedReceiverMutator]MSP[N]
encoding = encoding . substring ( 1 , encoding . length () - 1 ) ; } } } return encoding ; } static boolean isAppXml ( final String mime ) { return mime != null && MST[ReturnValsMutator]MSP[N] ( mime . equals ( lr_8 ) ||
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR6Mutator]MSP[N] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
if ( cTEnc . equals ( UTF_16 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_16 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR5Mutator]MSP[N]
if ( cTEnc . equals ( UTF_16 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_16 ) ) { MST[rv.ROR3Mutator]MSP[N] return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ;
final int i = httpContentType . indexOf ( lr_3 ) ; if ( i >= 0 ) { MST[rv.UOI2Mutator]MSP[N] mime = httpContentType . substring ( 0 , i ) ; } else { mime = httpContentType ; } mime = mime . trim () ; } return mime ; }
final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR1Mutator]MSP[S] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR5Mutator]MSP[S] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
if ( guessedEnc != null ) { final byte [] bytes = new byte [ BUFFER_SIZE ] ; is . mark ( BUFFER_SIZE ) ; int offset = 0 ; MST[rv.CRCR6Mutator]MSP[N] int max = BUFFER_SIZE ; int c = is . read ( bytes , offset , max ) ;
( mime . equals ( lr_2 ) || mime . equals ( lr_13 ) || mime . startsWith ( lr_14 ) && mime . endsWith ( lr_12 ) ) ; MST[NonVoidMethodCallMutator]MSP[S] }
if ( httpContentType != null && httpContentType . startsWith ( lr_1 ) ) { httpContentType = httpContentType . substring ( lr_1 . length () ) ; MST[NonVoidMethodCallMutator]MSP[N] httpContentType = lr_2 + httpContentType ; try { return calculateHttpEncoding ( httpContentType , ex . getBomEncoding () ,
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } final String msg = MessageFormat . format ( RAW_EX_2 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR3Mutator]MSP[S] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
mime . equals ( lr_9 ) || mime . equals ( lr_10 ) || mime . startsWith ( lr_11 ) && mime . endsWith ( lr_12 ) ) ; MST[rv.CRCR3Mutator]MSP[N] } static boolean isTextXml ( final String mime ) { return mime != null &&
final String cTEnc = getContentTypeEncoding ( httpContentType ) ; final boolean appXml = isAppXml ( cTMime ) ; final boolean textXml = isTextXml ( cTMime ) ; if ( ! appXml && ! textXml ) { MST[rv.UOI4Mutator]MSP[N]
( mime . equals ( lr_2 ) || mime . equals ( lr_13 ) || mime . startsWith ( lr_14 ) && mime . endsWith ( lr_12 ) ) ; MST[rv.ROR2Mutator]MSP[S] }
final String msg = MessageFormat . format ( HTTP_EX_3 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[InlineConstantMutator]MSP[N] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( cTEnc == null ) {
if ( httpContentType != null && httpContentType . startsWith ( lr_1 ) ) { MST[rv.ROR4Mutator]MSP[S] httpContentType = httpContentType . substring ( lr_1 . length () ) ; httpContentType = lr_2 + httpContentType ; try { return calculateHttpEncoding ( httpContentType , ex . getBomEncoding () ,
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( xmlEnc != null && ! xmlEnc . equals ( UTF_8 ) ) { MST[rv.ROR3Mutator]MSP[N] final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR3Mutator]MSP[S] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
( mime . equals ( lr_2 ) || mime . equals ( lr_13 ) || mime . startsWith ( lr_14 ) && mime . endsWith ( lr_12 ) ) ; MST[rv.CRCR6Mutator]MSP[N] }
( mime . equals ( lr_2 ) || mime . equals ( lr_13 ) || mime . startsWith ( lr_14 ) && mime . endsWith ( lr_12 ) ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] }
if ( xmlGuessEnc == null || xmlEnc == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] return defaultEncoding == null ? UTF_8 : defaultEncoding ; } if ( xmlEnc . equals ( UTF_16 ) && ( xmlGuessEnc . equals ( UTF_16BE ) || xmlGuessEnc . equals ( UTF_16LE ) ) ) { return xmlGuessEnc ;
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { MST[rv.UOI3Mutator]MSP[N] offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ;
( mime . equals ( lr_2 ) || MST[NegateConditionalsMutator]MSP[N] mime . equals ( lr_13 ) || mime . startsWith ( lr_14 ) && mime . endsWith ( lr_12 ) ) ; }
final String bomEnc = bom . getBOMCharsetName () ; final String xmlGuessEnc = pis . getBOMCharsetName () ; final String xmlEnc = getXmlProlog ( pis , xmlGuessEnc ) ; try { return calculateHttpEncoding ( httpContentType , bomEnc , MST[rv.UOI2Mutator]MSP[N] xmlGuessEnc , xmlEnc , lenient ) ;
final String postMime = httpContentType . substring ( i + 1 ) ; final Matcher m = CHARSET_PATTERN . matcher ( postMime ) ; encoding = m . find () ? m . group ( 1 ) : null ; MST[NonVoidMethodCallMutator]MSP[N]
throw new IOException ( lr_6 + offset + lr_7 ) ; } final int bytesRead = offset ; MST[rv.UOI3Mutator]MSP[N] if ( bytesRead > 0 ) { is . reset () ; final BufferedReader bReader = new BufferedReader ( new StringReader (
if ( cTEnc . equals ( UTF_16 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_16 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR6Mutator]MSP[N]
if ( appXml ) { return calculateRawEncoding ( bomEnc , xmlGuessEnc , xmlEnc ) ; } return defaultEncoding == null ? US_ASCII : defaultEncoding ; } if ( cTEnc . equals ( UTF_16BE ) || cTEnc . equals ( UTF_16LE ) ) { MST[rv.ROR3Mutator]MSP[N] if ( bomEnc != null ) {
final String postMime = httpContentType . substring ( i + 1 ) ; MST[rv.AOR3Mutator]MSP[S] final Matcher m = CHARSET_PATTERN . matcher ( postMime ) ; encoding = m . find () ? m . group ( 1 ) : null ;
if ( cTEnc . equals ( UTF_16 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_16 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR3Mutator]MSP[N]
encoding = encoding . substring ( 1 , encoding . length () - 1 ) ; MST[rv.CRCR4Mutator]MSP[N] } } } return encoding ; } static boolean isAppXml ( final String mime ) { return mime != null && ( mime . equals ( lr_8 ) ||
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } if ( bomEnc . equals ( UTF_32BE ) || bomEnc . equals ( UTF_32LE ) ) { if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( bomEnc ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } final String msg = MessageFormat . format ( RAW_EX_2 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR6Mutator]MSP[S] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
if ( guessedEnc != null ) { final byte [] bytes = new byte [ BUFFER_SIZE ] ; is . mark ( BUFFER_SIZE ) ; int offset = 0 ; int max = BUFFER_SIZE ; int c = is . read ( bytes , offset , max ) ; MST[rv.UOI3Mutator]MSP[N]
final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR5Mutator]MSP[N] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
final String msg = MessageFormat . format ( HTTP_EX_3 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR3Mutator]MSP[N] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( cTEnc == null ) {
} return xmlEnc ; } if ( bomEnc . equals ( UTF_8 ) ) { if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( UTF_8 ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR2Mutator]MSP[S]
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_16 ) && ! xmlEnc . equals ( bomEnc ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR4Mutator]MSP[N]
final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR6Mutator]MSP[S] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
if ( xmlGuessEnc == null || xmlEnc == null ) { return defaultEncoding == null ? UTF_8 : defaultEncoding ; } if ( xmlEnc . equals ( UTF_16 ) && ( xmlGuessEnc . equals ( UTF_16BE ) || xmlGuessEnc . equals ( UTF_16LE ) ) ) { MST[NonVoidMethodCallMutator]MSP[S] return xmlGuessEnc ;
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { MST[rv.UOI2Mutator]MSP[N] offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ;
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { MST[rv.UOI4Mutator]MSP[N] offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ;
mime . equals ( lr_9 ) || MST[rv.ROR2Mutator]MSP[N] mime . equals ( lr_10 ) || mime . startsWith ( lr_11 ) && mime . endsWith ( lr_12 ) ) ; } static boolean isTextXml ( final String mime ) { return mime != null &&
encoding = encoding != null ? encoding . toUpperCase ( Locale . ROOT ) : null ; MST[NegateConditionalsMutator]MSP[N] } } return encoding ; } private static String getXmlProlog ( final InputStream is , final String guessedEnc ) throws IOException { String encoding = null ;
} return xmlEnc ; } if ( bomEnc . equals ( UTF_8 ) ) { MST[NonVoidMethodCallMutator]MSP[N] if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( UTF_8 ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
static String getContentTypeEncoding ( final String httpContentType ) { String encoding = null ; if ( httpContentType != null ) { final int i = httpContentType . indexOf ( lr_3 ) ; if ( i > - 1 ) { MST[rv.ROR4Mutator]MSP[S]
xmlProlog . substring ( 0 , firstGT + 1 ) ) ) ; MST[ConstructorCallMutator]MSP[N] final StringBuffer prolog = new StringBuffer () ; String line = bReader . readLine () ; while ( line != null ) { prolog . append ( line ) ; line = bReader . readLine () ;
if ( cTEnc . equals ( UTF_16 ) ) { MST[NonVoidMethodCallMutator]MSP[N] if ( bomEnc != null && bomEnc . startsWith ( UTF_16 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ;
if ( cTEnc . equals ( UTF_32 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_32 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR3Mutator]MSP[N]
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { MST[rv.ROR1Mutator]MSP[N] offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ;
throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( cTEnc . equals ( UTF_32BE ) || cTEnc . equals ( UTF_32LE ) ) { MST[rv.ROR3Mutator]MSP[N] if ( bomEnc != null ) {
encoding = encoding . substring ( 1 , encoding . length () - 1 ) ; MST[rv.CRCR3Mutator]MSP[N] } } } return encoding ; } static boolean isAppXml ( final String mime ) { return mime != null && ( mime . equals ( lr_8 ) ||
if ( xmlGuessEnc == null || xmlEnc == null ) { return defaultEncoding == null ? UTF_8 : defaultEncoding ; } if ( xmlEnc . equals ( UTF_16 ) && ( xmlGuessEnc . equals ( UTF_16BE ) || xmlGuessEnc . equals ( UTF_16LE ) ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] return xmlGuessEnc ;
mime . equals ( lr_9 ) || mime . equals ( lr_10 ) || MST[rv.ROR4Mutator]MSP[N] mime . startsWith ( lr_11 ) && mime . endsWith ( lr_12 ) ) ; } static boolean isTextXml ( final String mime ) { return mime != null &&
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } if ( bomEnc . equals ( UTF_16BE ) || bomEnc . equals ( UTF_16LE ) ) { MST[rv.ROR1Mutator]MSP[N] if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( bomEnc ) ) {
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR3Mutator]MSP[N] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[InlineConstantMutator]MSP[S] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_16 ) && ! xmlEnc . equals ( bomEnc ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR2Mutator]MSP[S]
throw new IOException ( lr_6 + offset + lr_7 ) ; } final int bytesRead = offset ; if ( bytesRead > 0 ) { MST[rv.ROR1Mutator]MSP[N] is . reset () ; final BufferedReader bReader = new BufferedReader ( new StringReader (
static String getContentTypeEncoding ( final String httpContentType ) { String encoding = null ; if ( httpContentType != null ) { final int i = httpContentType . indexOf ( lr_3 ) ; if ( i > - 1 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[S]
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[ConstructorCallMutator]MSP[N] } return cTEnc ; }
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ;
final String msg = MessageFormat . format ( HTTP_EX_3 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR1Mutator]MSP[S] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( cTEnc == null ) {
if ( lenient ) { MST[rv.ROR4Mutator]MSP[N] return doLenientDetection ( null , ex ) ; } throw ex ; } } private String doHttpStream ( final BOMInputStream bom , final BOMInputStream pis , final String httpContentType , final boolean lenient ) throws IOException {
encoding = encoding . substring ( 1 , encoding . length () - 1 ) ; } } } return encoding ; } static boolean isAppXml ( final String mime ) { return mime != null && ( mime . equals ( lr_8 ) || MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
ex . getXmlGuessEncoding () , ex . getXmlEncoding () , true ) ; MST[rv.CRCR2Mutator]MSP[N] } catch ( final XmlStreamReaderException ex2 ) { ex = ex2 ; } } String encoding = ex . getXmlEncoding () ; if ( encoding == null ) { encoding = ex . getContentTypeEncoding () ; }
