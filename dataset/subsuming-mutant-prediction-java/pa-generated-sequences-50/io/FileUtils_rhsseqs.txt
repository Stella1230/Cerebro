: new InputStreamReader ( new FileInputStream ( file2 ) , charsetName ) ) { return IOUtils . contentEqualsIgnoreEOL ( input1 , input2 ) ; MST[ReturnValsMutator]MSP[S] } } public static File toFile ( final URL url ) {
if ( ! srcDir . isDirectory () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] throw new IOException ( lr_29 + srcDir + lr_39 ) ; } if ( srcDir . getCanonicalPath () . equals ( destDir . getCanonicalPath () ) ) {
if ( ! directory . isDirectory () ) { throw new IllegalArgumentException ( lr_46 + directory ) ; } if ( child == null ) { MST[rv.ROR5Mutator]MSP[N] return false ; } if ( ! directory . exists () || ! child . exists () ) { return false ; }
writeLines ( file , null , lines , lineEnding , append ) ; MST[rv.UOI3Mutator]MSP[S] } public static void forceDelete ( final File file ) throws IOException { if ( file . isDirectory () ) { deleteDirectory ( file ) ; } else {
return lineIterator ( file , null ) ; MST[ReturnValsMutator]MSP[S] } public static void writeStringToFile ( final File file , final String data , final Charset encoding ) throws IOException { writeStringToFile ( file , data , encoding , false ) ; }
final boolean success = file . setLastModified ( System . currentTimeMillis () ) ; if ( ! success ) { MST[NegateConditionalsMutator]MSP[N] throw new IOException ( lr_19 + file ) ; } } public static File [] convertFileCollectionToFileArray ( final Collection < File > files ) {
if ( destDir . isDirectory () == false ) { throw new IOException ( lr_27 + destDir + lr_39 ) ; MST[experimental.NakedReceiverMutator]MSP[N] } } else { if ( ! destDir . mkdirs () && ! destDir . isDirectory () ) {
throw new NullPointerException ( lr_38 ) ; } if ( src . isFile () ) { copyFileToDirectory ( src , destDir ) ; } else if ( src . isDirectory () ) { MST[rv.ROR1Mutator]MSP[N] copyDirectoryToDirectory ( src , destDir ) ; } else {
} public static void copyFile ( final File srcFile , final File destFile , final boolean preserveFileDate ) throws IOException { checkFileRequirements ( srcFile , destFile ) ; if ( srcFile . isDirectory () ) { MST[NegateConditionalsMutator]MSP[N] throw new IOException ( lr_29 + srcFile + lr_6 ) ; }
public static void moveDirectoryToDirectory ( final File src , final File destDir , final boolean createDestDir ) throws IOException { validateMoveParameters ( src , destDir ) ; if ( ! destDir . exists () && createDestDir ) { MST[rv.UOI4Mutator]MSP[S] destDir . mkdirs () ; }
doCopyDirectory ( srcFile , dstFile , filter , preserveFileDate , exclusionList ) ; } else { doCopyFile ( srcFile , dstFile , preserveFileDate ) ; } } } if ( preserveFileDate ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] destDir . setLastModified ( srcDir . lastModified () ) ; } }
final File [] files = verifiedListFiles ( directory ) ; IOException exception = null ; for ( final File file : files ) { MST[rv.UOI3Mutator]MSP[N] try { forceDeleteOnExit ( file ) ; } catch ( final IOException ioe ) { exception = ioe ; } }
if ( ! directory . isDirectory () ) { final String message = directory + lr_47 ; throw new IllegalArgumentException ( message ) ; MST[ConstructorCallMutator]MSP[S] } final File [] files = directory . listFiles () ; if ( files == null ) {
if ( srcLen != dstLen ) { throw new IOException ( lr_34 + srcFile + lr_35 + destFile MST[rv.UOI3Mutator]MSP[N] + lr_36 + srcLen + lr_37 + dstLen ) ; } } public static void copyDirectoryToDirectory ( final File srcDir , final File destDir ) throws IOException {
final File dstFile = new File ( destDir , srcFile . getName () ) ; if ( exclusionList == null || ! exclusionList . contains ( srcFile . getCanonicalPath () ) ) { MST[rv.ROR5Mutator]MSP[S] if ( srcFile . isDirectory () ) {
public static void write ( final File file , final CharSequence data , final Charset encoding , final boolean append ) throws IOException { final String str = data == null ? null : data . toString () ; MST[NegateConditionalsMutator]MSP[N] writeStringToFile ( file , str , encoding , append ) ;
throw new IOException ( lr_40 + directory ) ; } return files ; } public static boolean waitFor ( final File file , final int seconds ) { final long finishAt = System . currentTimeMillis () + ( seconds * 1000L ) ; MST[rv.AOR4Mutator]MSP[N] boolean wasInterrupted = false ; try {
return false ; } return file . lastModified () > timeMillis ; } public static boolean isFileOlder ( final File file , final File reference ) { if ( reference == null ) { MST[rv.ROR5Mutator]MSP[S] throw new IllegalArgumentException ( lr_54 ) ; }
throw new IOException ( lr_27 + destFile + lr_69 ) ; } final boolean rename = srcFile . renameTo ( destFile ) ; if ( ! rename ) { copyFile ( srcFile , destFile ) ; if ( ! srcFile . delete () ) { MST[NegateConditionalsMutator]MSP[N]
while ( ! file . exists () ) { final long remaining = finishAt - System . currentTimeMillis () ; if ( remaining < 0 ) { return false ; MST[ReturnValsMutator]MSP[N] } try { Thread . sleep ( Math . min ( 100 , remaining ) ) ;
} while ( i < n && url . charAt ( i ) == '%' ); continue; } catch ( final RuntimeException e ) { } finally { if ( bytes . position () > 0 ) { MST[rv.ROR3Mutator]MSP[N] bytes . flip () ;
if ( url == null || ! lr_24 . equalsIgnoreCase ( url . getProtocol () ) ) { return null ; MST[ReturnValsMutator]MSP[S] } String filename = url . getFile () . replace ( '/' , File . separatorChar ) ; filename = decodeUrl ( filename ) ;
if ( ! srcDir . isDirectory () ) { throw new IOException ( lr_29 + srcDir + lr_39 ) ; } if ( srcDir . getCanonicalPath () . equals ( destDir . getCanonicalPath () ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
while ( ! file . exists () ) { MST[rv.ROR3Mutator]MSP[N] final long remaining = finishAt - System . currentTimeMillis () ; if ( remaining < 0 ) { return false ; } try { Thread . sleep ( Math . min ( 100 , remaining ) ) ;
if ( url == null || ! lr_24 . equalsIgnoreCase ( url . getProtocol () ) ) { return null ; } String filename = url . getFile () . replace ( '/' , File . separatorChar ) ; MST[rv.CRCR3Mutator]MSP[N] filename = decodeUrl ( filename ) ;
final File [] found = directory . listFiles ( ( FileFilter ) filter ) ; if ( found != null ) { for ( final File file : found ) { if ( file . isDirectory () ) { if ( includeSubDirectories ) { MST[rv.ROR3Mutator]MSP[N]
final File [] found = directory . listFiles ( ( FileFilter ) filter ) ; if ( found != null ) { for ( final File file : found ) { if ( file . isDirectory () ) { if ( includeSubDirectories ) { MST[rv.ABSMutator]MSP[N]
for ( int i = 0 ; i < urls . length ; i ++ ) { MST[rv.ROR5Mutator]MSP[N] final URL url = urls [ i ] ; if ( url != null ) { if ( url . getProtocol () . equals ( lr_24 ) == false ) {
} public static void copyFile ( final File srcFile , final File destFile , final boolean preserveFileDate ) throws IOException { checkFileRequirements ( srcFile , destFile ) ; if ( srcFile . isDirectory () ) { MST[rv.ROR5Mutator]MSP[N] throw new IOException ( lr_29 + srcFile + lr_6 ) ; }
} } return size ; } private static BigInteger sizeOfBig0 ( final File fileOrDir ) { if ( fileOrDir . isDirectory () ) { return sizeOfDirectoryBig0 ( fileOrDir ) ; MST[NullReturnValsMutator]MSP[S] } return BigInteger . valueOf ( fileOrDir . length () ) ; }
throw new IOException ( lr_27 + destDir + lr_32 ) ; } } if ( destDir . canWrite () == false ) { throw new IOException ( lr_27 + destDir + lr_9 ) ; } for ( final File srcFile : srcFiles ) { MST[rv.UOI2Mutator]MSP[N]
checksum ( file , crc ) ; MST[ArgumentPropagationMutator]MSP[S] return crc . getValue () ; } public static Checksum checksum ( final File file , final Checksum checksum ) throws IOException { if ( file . isDirectory () ) { throw new IllegalArgumentException ( lr_59 ) ; }
} while ( i < n && url . charAt ( i ) == '%' ); MST[rv.UOI4Mutator]MSP[N] continue; } catch ( final RuntimeException e ) { } finally { if ( bytes . position () > 0 ) { bytes . flip () ;
throws IOException { final boolean file1Exists = file1 . exists () ; if ( file1Exists != file2 . exists () ) { return false ; } if ( ! file1Exists ) { return true ; } if ( file1 . isDirectory () || file2 . isDirectory () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S]
displaySize = String . valueOf ( size . divide ( ONE_GB_BI ) ) + lr_15 ; } else if ( size . divide ( ONE_MB_BI ) . compareTo ( BigInteger . ZERO ) > 0 ) { MST[rv.ROR4Mutator]MSP[N]
public static void moveDirectoryToDirectory ( final File src , final File destDir , final boolean createDestDir ) throws IOException { validateMoveParameters ( src , destDir ) ; if ( ! destDir . exists () && createDestDir ) { MST[rv.ROR5Mutator]MSP[S] destDir . mkdirs () ; }
final File destFile = new File ( destDir , srcFile . getName () ) ; copyFile ( srcFile , destFile , preserveFileDate ) ; } public static void copyFile ( final File srcFile , final File destFile ) throws IOException { copyFile ( srcFile , destFile , true ) ; MST[rv.CRCR6Mutator]MSP[N]
validateMoveParameters ( srcDir , destDir ) ; if ( ! srcDir . isDirectory () ) { throw new IOException ( lr_29 + srcDir + lr_28 ) ; } if ( destDir . exists () ) { MST[NonVoidMethodCallMutator]MSP[S] throw new FileExistsException ( lr_27 + destDir + lr_60 ) ; }
throw new IOException ( lr_40 + directory ) ; } return files ; } public static boolean waitFor ( final File file , final int seconds ) { final long finishAt = System . currentTimeMillis () + ( seconds * 1000L ) ; MST[rv.AOD2Mutator]MSP[N] boolean wasInterrupted = false ; try {
displaySize = String . valueOf ( size . divide ( ONE_MB_BI ) ) + lr_16 ; MST[NonVoidMethodCallMutator]MSP[N] } else if ( size . divide ( ONE_KB_BI ) . compareTo ( BigInteger . ZERO ) > 0 ) {
throw new IOException ( lr_29 + srcDir + lr_30 + destDir + lr_31 ) ; } List < String > exclusionList = null ; if ( destDir . getCanonicalPath () . startsWith ( srcDir . getCanonicalPath () ) ) { MST[rv.ROR1Mutator]MSP[N]
public static void write ( final File file , final CharSequence data , final Charset encoding , final boolean append ) throws IOException { final String str = data == null ? null : data . toString () ; MST[rv.ROR5Mutator]MSP[N] writeStringToFile ( file , str , encoding , append ) ;
final URL [] urls = new URL [ files . length ] ; for ( int i = 0 ; i < urls . length ; i ++ ) { urls [ i ] = files [ i ] . toURI () . toURL () ; MST[NonVoidMethodCallMutator]MSP[S] } return urls ;
final File dstFile = new File ( destDir , srcFile . getName () ) ; if ( exclusionList == null || ! exclusionList . contains ( srcFile . getCanonicalPath () ) ) { MST[NegateConditionalsMutator]MSP[S] if ( srcFile . isDirectory () ) {
return false ; } return file . lastModified () > timeMillis ; } public static boolean isFileOlder ( final File file , final File reference ) { if ( reference == null ) { MST[NegateConditionalsMutator]MSP[S] throw new IllegalArgumentException ( lr_54 ) ; }
final File [] found = directory . listFiles ( ( FileFilter ) filter ) ; if ( found != null ) { for ( final File file : found ) { MST[rv.UOI3Mutator]MSP[N] if ( file . isDirectory () ) { if ( includeSubDirectories ) {
public static void moveDirectoryToDirectory ( final File src , final File destDir , final boolean createDestDir ) throws IOException { validateMoveParameters ( src , destDir ) ; if ( ! destDir . exists () && createDestDir ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] destDir . mkdirs () ; }
final boolean filePresent = file . exists () ; if ( ! file . delete () ) { if ( ! filePresent ) { throw new FileNotFoundException ( lr_48 + file ) ; } final String message = MST[NonVoidMethodCallMutator]MSP[S] lr_49 + file ; throw new IOException ( message ) ; }
return readFileToString ( file , Charset . defaultCharset () ) ; } public static byte [] readFileToByteArray ( final File file ) throws IOException { try ( InputStream in = openInputStream ( file ) ) { final long fileLength = file . length () ; MST[NonVoidMethodCallMutator]MSP[N]
final byte octet = ( byte ) Integer . parseInt ( url . substring ( i + 1 , i + 3 ) , 16 ) ; MST[MathMutator]MSP[N] bytes . put ( octet ) ; i += 3 ;
buffer . append ( StandardCharsets . UTF_8 . decode ( bytes ) . toString () ) ; MST[NonVoidMethodCallMutator]MSP[N] bytes . clear () ; } } } buffer . append ( url . charAt ( i ++ ) ) ; } decoded = buffer . toString () ; } return decoded ;
if ( null != exception ) { throw exception ; } } public static void forceMkdir ( final File directory ) throws IOException { if ( directory . exists () ) { if ( ! directory . isDirectory () ) { MST[NegateConditionalsMutator]MSP[N] final String message = lr_50 + directory + lr_51
throw new IOException ( lr_29 + srcFile + lr_69 ) ; MST[experimental.NakedReceiverMutator]MSP[N] } if ( destFile . exists () ) { throw new FileExistsException ( lr_27 + destFile + lr_60 ) ; } if ( destFile . isDirectory () ) {
for ( int i = 0 ; i < urls . length ; i ++ ) { final URL url = urls [ i ] ; if ( url != null ) { if ( url . getProtocol () . equals ( lr_24 ) == false ) { MST[rv.ROR5Mutator]MSP[N]
return false ; } return file . lastModified () > timeMillis ; MST[rv.CRCR3Mutator]MSP[N] } public static boolean isFileOlder ( final File file , final File reference ) { if ( reference == null ) { throw new IllegalArgumentException ( lr_54 ) ; }
displaySize = String . valueOf ( size . divide ( ONE_MB_BI ) ) + lr_16 ; MST[experimental.NakedReceiverMutator]MSP[N] } else if ( size . divide ( ONE_KB_BI ) . compareTo ( BigInteger . ZERO ) > 0 ) {
if ( ! destDir . exists () ) { throw new FileNotFoundException ( lr_66 + destDir + MST[experimental.NakedReceiverMutator]MSP[N] lr_67 + createDestDir + lr_68 ) ; } if ( ! destDir . isDirectory () ) { throw new IOException ( lr_27 + destDir + lr_28 ) ; }
} while ( i < n && url . charAt ( i ) == '%' ); MST[rv.ROR5Mutator]MSP[N] continue; } catch ( final RuntimeException e ) { } finally { if ( bytes . position () > 0 ) { bytes . flip () ;
throw new IOException ( lr_27 + destDir + lr_32 ) ; } } if ( destDir . canWrite () == false ) { throw new IOException ( lr_27 + destDir + lr_9 ) ; } for ( final File srcFile : srcFiles ) { MST[rv.ABSMutator]MSP[N]
if ( ! directory . isDirectory () ) { throw new IllegalArgumentException ( lr_46 + directory ) ; } if ( child == null ) { return false ; } if ( ! directory . exists () || ! child . exists () ) { MST[rv.ROR4Mutator]MSP[S] return false ; }
try ( OutputStream out = openOutputStream ( file , append ) ) { MST[NonVoidMethodCallMutator]MSP[N] out . write ( data , off , len ) ; } } public static void writeLines ( final File file , final String encoding , final Collection < ? > lines ) throws IOException {
throw new IOException ( lr_27 + destDir + lr_32 ) ; } } if ( destDir . canWrite () == false ) { MST[NonVoidMethodCallMutator]MSP[N] throw new IOException ( lr_27 + destDir + lr_9 ) ; } for ( final File srcFile : srcFiles ) {
throw new IllegalArgumentException ( lr_58 ) ; } if ( ! file . exists () ) { return false ; } return file . lastModified () < timeMillis ; MST[rv.UOI1Mutator]MSP[N] } public static long checksumCRC32 ( final File file ) throws IOException { final CRC32 crc = new CRC32 () ;
final File [] files = directory . listFiles () ; if ( files == null ) { return 0L ; } long size = 0 ; for ( final File file : files ) { MST[rv.ABSMutator]MSP[N] if ( ! isSymlink ( file ) ) {
final byte octet = ( byte ) Integer . parseInt ( url . substring ( i + 1 , i + 3 ) , 16 ) ; MST[InlineConstantMutator]MSP[N] bytes . put ( octet ) ; i += 3 ;
writeLines ( file , encoding , lines , null , false ) ; MST[rv.CRCR3Mutator]MSP[N] } public static void writeLines ( final File file , final String encoding , final Collection < ? > lines , final boolean append ) throws IOException {
if ( null != exception ) { throw exception ; } } public static void forceMkdir ( final File directory ) throws IOException { if ( directory . exists () ) { if ( ! directory . isDirectory () ) { MST[rv.ROR5Mutator]MSP[N] final String message = lr_50 + directory + lr_51
return FileFilterUtils . and ( fileFilter , FileFilterUtils . notFileFilter ( DirectoryFileFilter . INSTANCE ) ) ; } private static IOFileFilter setUpEffectiveDirFilter ( final IOFileFilter dirFilter ) { return dirFilter == null ? FalseFileFilter . INSTANCE : FileFilterUtils . and ( dirFilter , MST[rv.CRCR1Mutator]MSP[N] DirectoryFileFilter . INSTANCE ) ; }
} else { final File parent = file . getParentFile () ; if ( parent != null ) { if ( ! parent . mkdirs () && ! parent . isDirectory () ) { MST[rv.ROR3Mutator]MSP[N] throw new IOException ( lr_10 + parent + lr_11 ) ; } } }
public static String getTempDirectoryPath () { return System . getProperty ( lr_3 ) ; } public static File getTempDirectory () { return new File ( getTempDirectoryPath () ) ; MST[NullReturnValsMutator]MSP[S] } public static String getUserDirectoryPath () { return System . getProperty ( lr_4 ) ; }
copyDirectory ( srcDir , new File ( destDir , srcDir . getName () ) , true ) ; } public static void copyDirectory ( final File srcDir , final File destDir ) throws IOException { copyDirectory ( srcDir , destDir , true ) ; MST[rv.CRCR2Mutator]MSP[N] }
return new FileInputStream ( file ) ; } public static FileOutputStream openOutputStream ( final File file ) throws IOException { return openOutputStream ( file , false ) ; MST[rv.CRCR3Mutator]MSP[N] } public static FileOutputStream openOutputStream ( final File file , final boolean append ) throws IOException {
try { if ( in != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] in . close () ; } } catch ( final IOException e ) { ex . addSuppressed ( e ) ; } throw ex ; } } public static LineIterator lineIterator ( final File file ) throws IOException {
return isFileNewer ( file , date . getTime () ) ; MST[BooleanTrueReturnValsMutator]MSP[N] } public static boolean isFileNewer ( final File file , final long timeMillis ) { if ( file == null ) { throw new IllegalArgumentException ( lr_58 ) ; } if ( ! file . exists () ) {
final String [] suffixes = toSuffixes ( extensions ) ; filter = new SuffixFileFilter ( suffixes ) ; } return listFiles ( directory , filter , MST[rv.ROR4Mutator]MSP[N] recursive ? TrueFileFilter . INSTANCE : FalseFileFilter . INSTANCE ) ; } public static Iterator < File > iterateFiles (
final boolean file1Exists = file1 . exists () ; if ( file1Exists != file2 . exists () ) { return false ; } if ( ! file1Exists ) { return true ; MST[rv.CRCR4Mutator]MSP[N] } if ( file1 . isDirectory () || file2 . isDirectory () ) {
if ( ! directory . isDirectory () ) { throw new IllegalArgumentException ( lr_46 + directory ) ; } if ( child == null ) { MST[NegateConditionalsMutator]MSP[N] return false ; } if ( ! directory . exists () || ! child . exists () ) { return false ; }
for ( final String name : names ) { MST[rv.UOI1Mutator]MSP[S] file = new File ( file , name ) ; } return file ; } public static File getFile ( final String ... names ) { if ( names == null ) { throw new NullPointerException ( lr_2 ) ; }
checkEqualSizes ( srcFile , destFile , srcFile . length () , destFile . length () ) ; destFile . setLastModified ( newLastModifed ) ; MST[rv.UOI3Mutator]MSP[N] } private static void checkEqualSizes ( final File srcFile , final File destFile , final long srcLen , final long dstLen ) throws IOException {
if ( destDir == null ) { throw new NullPointerException ( lr_26 ) ; } if ( destDir . exists () && destDir . isDirectory () == false ) { MST[rv.ROR2Mutator]MSP[N] throw new IllegalArgumentException ( lr_27 + destDir + lr_28 ) ; }
if ( file . exists () ) { if ( file . isDirectory () ) { throw new IOException ( lr_5 + file + lr_6 ) ; } if ( file . canWrite () == false ) { MST[rv.ROR3Mutator]MSP[N] throw new IOException ( lr_5 + file + lr_9 ) ; }
writeLines ( file , encoding , lines , null , append ) ; } public static void writeLines ( final File file , final Collection < ? > lines ) throws IOException { writeLines ( file , null , lines , null , false ) ; MST[VoidMethodCallMutator]MSP[S] }
if ( file == null ) { return false ; } try { if ( file . isDirectory () ) { cleanDirectory ( file ) ; MST[VoidMethodCallMutator]MSP[S] } } catch ( final Exception ignored ) { } try { return file . delete () ;
? new InputStreamReader ( new FileInputStream ( file1 ) , Charset . defaultCharset () ) : new InputStreamReader ( new FileInputStream ( file1 ) , charsetName ) ; Reader input2 = charsetName == null MST[rv.ROR5Mutator]MSP[S] ? new InputStreamReader ( new FileInputStream ( file2 ) , Charset . defaultCharset () )
final URL [] urls = new URL [ files . length ] ; for ( int i = 0 ; i < urls . length ; i ++ ) { urls [ i ] = files [ i ] . toURI () . toURL () ; MST[rv.UOI1Mutator]MSP[S] } return urls ;
while ( ! file . exists () ) { final long remaining = finishAt - System . currentTimeMillis () ; if ( remaining < 0 ) { MST[rv.UOI1Mutator]MSP[N] return false ; } try { Thread . sleep ( Math . min ( 100 , remaining ) ) ;
throw new IOException ( lr_23 ) ; } if ( file1 . length () != file2 . length () ) { return false ; } if ( file1 . getCanonicalFile () . equals ( file2 . getCanonicalFile () ) ) { MST[NonVoidMethodCallMutator]MSP[N] return true ; }
if ( ! file . exists () ) { MST[NegateConditionalsMutator]MSP[N] final String message = file + lr_42 ; throw new IllegalArgumentException ( message ) ; } if ( file . isDirectory () ) { return sizeOfDirectory0 ( file ) ; } return file . length () ; }
final byte octet = ( byte ) Integer . parseInt ( url . substring ( i + 1 , i + 3 ) , 16 ) ; MST[rv.ABSMutator]MSP[N] bytes . put ( octet ) ; i += 3 ;
final URL [] urls = new URL [ files . length ] ; for ( int i = 0 ; i < urls . length ; i ++ ) { MST[rv.ROR1Mutator]MSP[N] urls [ i ] = files [ i ] . toURI () . toURL () ; } return urls ;
if ( files == null ) { return BigInteger . ZERO ; } BigInteger size = BigInteger . ZERO ; for ( final File file : files ) { MST[rv.UOI3Mutator]MSP[N] if ( ! isSymlink ( file ) ) { size = size . add ( sizeOfBig0 ( file ) ) ;
displaySize = String . valueOf ( size . divide ( ONE_PB_BI ) ) + lr_13 ; } else if ( size . divide ( ONE_TB_BI ) . compareTo ( BigInteger . ZERO ) > 0 ) { MST[rv.ROR3Mutator]MSP[N]
} catch ( final InterruptedException ignore ) { wasInterrupted = true ; } catch ( final Exception ex ) { break; } } } finally { if ( wasInterrupted ) { Thread . currentThread () . interrupt () ; MST[VoidMethodCallMutator]MSP[S] } } return true ; }
final String [] suffixes = new String [ extensions . length ] ; for ( int i = 0 ; i < extensions . length ; i ++ ) { suffixes [ i ] = lr_22 + extensions [ i ] ; MST[rv.UOI3Mutator]MSP[N] } return suffixes ; }
return FileFilterUtils . and ( fileFilter , FileFilterUtils . notFileFilter ( DirectoryFileFilter . INSTANCE ) ) ; MST[InlineConstantMutator]MSP[N] } private static IOFileFilter setUpEffectiveDirFilter ( final IOFileFilter dirFilter ) { return dirFilter == null ? FalseFileFilter . INSTANCE : FileFilterUtils . and ( dirFilter , DirectoryFileFilter . INSTANCE ) ; }
displaySize = String . valueOf ( size . divide ( ONE_TB_BI ) ) + lr_14 ; MST[NonVoidMethodCallMutator]MSP[N] } else if ( size . divide ( ONE_GB_BI ) . compareTo ( BigInteger . ZERO ) > 0 ) {
final boolean success = file . setLastModified ( System . currentTimeMillis () ) ; if ( ! success ) { MST[rv.ROR5Mutator]MSP[N] throw new IOException ( lr_19 + file ) ; } } public static File [] convertFileCollectionToFileArray ( final Collection < File > files ) {
throw new IllegalArgumentException ( lr_58 ) ; } if ( ! file . exists () ) { return false ; } return file . lastModified () < timeMillis ; MST[rv.ROR1Mutator]MSP[S] } public static long checksumCRC32 ( final File file ) throws IOException { final CRC32 crc = new CRC32 () ;
files . add ( file ) ; } innerListFiles ( files , file , filter , includeSubDirectories ) ; MST[rv.UOI4Mutator]MSP[N] } else { files . add ( file ) ; } } } } public static Collection < File > listFiles (
public static void writeByteArrayToFile ( final File file , final byte [] data ) throws IOException { writeByteArrayToFile ( file , data , false ) ; MST[InlineConstantMutator]MSP[N] } public static void writeByteArrayToFile ( final File file , final byte [] data , final boolean append ) throws IOException {
if ( null != exception ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] throw exception ; } } public static void forceMkdir ( final File directory ) throws IOException { if ( directory . exists () ) { if ( ! directory . isDirectory () ) { final String message = lr_50 + directory + lr_51
throw new IllegalArgumentException ( lr_58 ) ; } if ( ! file . exists () ) { MST[rv.ROR4Mutator]MSP[S] return false ; } return file . lastModified () < timeMillis ; } public static long checksumCRC32 ( final File file ) throws IOException { final CRC32 crc = new CRC32 () ;
throw new IOException ( lr_23 ) ; } if ( file1 . length () != file2 . length () ) { return false ; } if ( file1 . getCanonicalFile () . equals ( file2 . getCanonicalFile () ) ) { return true ; MST[InlineConstantMutator]MSP[N] }
? new InputStreamReader ( new FileInputStream ( file1 ) , Charset . defaultCharset () ) : new InputStreamReader ( new FileInputStream ( file1 ) , charsetName ) ; Reader input2 = charsetName == null MST[NegateConditionalsMutator]MSP[S] ? new InputStreamReader ( new FileInputStream ( file2 ) , Charset . defaultCharset () )
if ( url == null || ! lr_24 . equalsIgnoreCase ( url . getProtocol () ) ) { return null ; } String filename = url . getFile () . replace ( '/' , File . separatorChar ) ; MST[NonVoidMethodCallMutator]MSP[N] filename = decodeUrl ( filename ) ;
if ( ! reference . exists () ) { throw new IllegalArgumentException ( lr_55 MST[experimental.NakedReceiverMutator]MSP[N] + reference + lr_56 ) ; } return isFileOlder ( file , reference . lastModified () ) ; } public static boolean isFileOlder ( final File file , final Date date ) {
if ( file . exists () ) { if ( file . isDirectory () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] throw new IOException ( lr_5 + file + lr_6 ) ; } if ( file . canWrite () == false ) { throw new IOException ( lr_5 + file + lr_9 ) ; }
} copyDirectory ( srcDir , destDir ) ; deleteDirectory ( srcDir ) ; if ( srcDir . exists () ) { MST[rv.ROR1Mutator]MSP[S] throw new IOException ( lr_63 + srcDir + lr_64 + destDir + lr_65 ) ; } } }
final byte octet = ( byte ) Integer . parseInt ( url . substring ( i + 1 , i + 3 ) , 16 ) ; MST[rv.CRCR4Mutator]MSP[N] bytes . put ( octet ) ; i += 3 ;
throws IOException { final boolean file1Exists = file1 . exists () ; if ( file1Exists != file2 . exists () ) { return false ; } if ( ! file1Exists ) { return true ; } if ( file1 . isDirectory () || file2 . isDirectory () ) { MST[NonVoidMethodCallMutator]MSP[N]
displaySize = String . valueOf ( size . divide ( ONE_KB_BI ) ) + lr_17 ; MST[ConstructorCallMutator]MSP[N] } else { displaySize = String . valueOf ( size ) + lr_18 ; } return displaySize ; } public static String byteCountToDisplaySize ( final long size ) {
throw new NullPointerException ( lr_26 ) ; } if ( destDir . exists () && destDir . isDirectory () == false ) { MST[rv.ROR3Mutator]MSP[N] throw new IllegalArgumentException ( lr_27 + destDir + lr_28 ) ; }
if ( ! file . exists () ) { final String message = file + lr_42 ; throw new IllegalArgumentException ( message ) ; } if ( file . isDirectory () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return sizeOfDirectory0 ( file ) ; } return file . length () ; }
final File [] found = directory . listFiles ( ( FileFilter ) filter ) ; if ( found != null ) { for ( final File file : found ) { if ( file . isDirectory () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] if ( includeSubDirectories ) {
try ( InputStream input1 = new FileInputStream ( file1 ) ; InputStream input2 = new FileInputStream ( file2 ) ) { return IOUtils . contentEquals ( input1 , input2 ) ; MST[rv.UOI1Mutator]MSP[N] } } public static boolean contentEqualsIgnoreEOL ( final File file1 , final File file2 , final String charsetName )
return readLines ( file , Charsets . toCharset ( encoding ) ) ; MST[EmptyObjectReturnValsMutator]MSP[S] } @Deprecated public static List < String > readLines ( final File file ) throws IOException { return readLines ( file , Charset . defaultCharset () ) ; }
throw new IOException ( lr_27 + destDir + lr_32 ) ; } } if ( destDir . canWrite () == false ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] throw new IOException ( lr_27 + destDir + lr_9 ) ; } for ( final File srcFile : srcFiles ) {
if ( file == null ) { return false ; MST[ReturnValsMutator]MSP[N] } try { if ( file . isDirectory () ) { cleanDirectory ( file ) ; } } catch ( final Exception ignored ) { } try { return file . delete () ;
if ( ! directory . isDirectory () ) { final String message = directory + lr_47 ; MST[NonVoidMethodCallMutator]MSP[S] throw new IllegalArgumentException ( message ) ; } final File [] files = directory . listFiles () ; if ( files == null ) {
for ( final String name : names ) { MST[rv.UOI4Mutator]MSP[S] file = new File ( file , name ) ; } return file ; } public static File getFile ( final String ... names ) { if ( names == null ) { throw new NullPointerException ( lr_2 ) ; }
final String [] suffixes = new String [ extensions . length ] ; for ( int i = 0 ; i < extensions . length ; i ++ ) { MST[rv.ABSMutator]MSP[N] suffixes [ i ] = lr_22 + extensions [ i ] ; } return suffixes ; }
} public static void forceMkdirParent ( final File file ) throws IOException { final File parent = file . getParentFile () ; if ( parent == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] return; } forceMkdir ( parent ) ; } public static long sizeOf ( final File file ) {
if ( ! parentFile . mkdirs () && ! parentFile . isDirectory () ) { throw new IOException ( lr_27 + parentFile + lr_32 ) ; } } if ( destFile . exists () && destFile . canWrite () == false ) { MST[rv.ROR5Mutator]MSP[N]
if ( srcDir == null ) { throw new NullPointerException ( lr_38 ) ; } if ( srcDir . exists () && srcDir . isDirectory () == false ) { MST[rv.ROR1Mutator]MSP[N] throw new IllegalArgumentException ( lr_29 + destDir + lr_28 ) ; } if ( destDir == null ) {
FileUtils . deleteQuietly ( destFile ) ; throw new IOException ( lr_70 + srcFile + MST[NonVoidMethodCallMutator]MSP[S] lr_64 + destFile + lr_65 ) ; } } } public static void moveFileToDirectory ( final File srcFile , final File destDir , final boolean createDestDir ) throws IOException {
FileUtils . deleteQuietly ( destFile ) ; throw new IOException ( lr_70 + srcFile + MST[experimental.NakedReceiverMutator]MSP[N] lr_64 + destFile + lr_65 ) ; } } } public static void moveFileToDirectory ( final File srcFile , final File destDir , final boolean createDestDir ) throws IOException {
writeByteArrayToFile ( file , data , off , len , false ) ; MST[rv.UOI1Mutator]MSP[N] } public static void writeByteArrayToFile ( final File file , final byte [] data , final int off , final int len , final boolean append ) throws IOException {
throws IOException { final boolean file1Exists = file1 . exists () ; if ( file1Exists != file2 . exists () ) { return false ; } if ( ! file1Exists ) { MST[rv.ROR1Mutator]MSP[S] return true ; } if ( file1 . isDirectory () || file2 . isDirectory () ) {
final File dstFile = new File ( destDir , srcFile . getName () ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( exclusionList == null || ! exclusionList . contains ( srcFile . getCanonicalPath () ) ) { if ( srcFile . isDirectory () ) {
} else { final File parent = file . getParentFile () ; if ( parent != null ) { if ( ! parent . mkdirs () && ! parent . isDirectory () ) { throw new IOException ( lr_10 + parent + lr_11 ) ; MST[experimental.NakedReceiverMutator]MSP[N] } } }
public static File getFile ( final File directory , final String ... names ) { if ( directory == null ) { throw new NullPointerException ( lr_1 ) ; } if ( names == null ) { MST[NegateConditionalsMutator]MSP[S] throw new NullPointerException ( lr_2 ) ; } File file = directory ;
return fileLength > 0 ? IOUtils . toByteArray ( in , fileLength ) : IOUtils . toByteArray ( in ) ; MST[rv.ABSMutator]MSP[N] } } public static List < String > readLines ( final File file , final Charset encoding ) throws IOException {
public static void write ( final File file , final CharSequence data , final Charset encoding , final boolean append ) throws IOException { final String str = data == null ? null : data . toString () ; MST[NonVoidMethodCallMutator]MSP[N] writeStringToFile ( file , str , encoding , append ) ;
displaySize = String . valueOf ( size . divide ( ONE_KB_BI ) ) + lr_17 ; } else { displaySize = String . valueOf ( size ) + lr_18 ; MST[ConstructorCallMutator]MSP[N] } return displaySize ; } public static String byteCountToDisplaySize ( final long size ) {
writeByteArrayToFile ( file , data , 0 , data . length , append ) ; MST[InlineConstantMutator]MSP[N] } public static void writeByteArrayToFile ( final File file , final byte [] data , final int off , final int len ) throws IOException {
return new File ( filename ) ; } static String decodeUrl ( final String url ) { String decoded = url ; if ( url != null && url . indexOf ( '%' ) >= 0 ) { MST[rv.CRCR2Mutator]MSP[N] final int n = url . length () ;
throw new IOException ( lr_23 ) ; } if ( file1 . getCanonicalFile () . equals ( file2 . getCanonicalFile () ) ) { MST[NonVoidMethodCallMutator]MSP[S] return true ; } try ( Reader input1 = charsetName == null
buffer . append ( StandardCharsets . UTF_8 . decode ( bytes ) . toString () ) ; bytes . clear () ; } } } buffer . append ( url . charAt ( i ++ ) ) ; } decoded = buffer . toString () ; MST[NonVoidMethodCallMutator]MSP[N] } return decoded ;
if ( ! srcDir . isDirectory () ) { MST[NonVoidMethodCallMutator]MSP[N] throw new IOException ( lr_29 + srcDir + lr_39 ) ; } if ( srcDir . getCanonicalPath () . equals ( destDir . getCanonicalPath () ) ) {
return new FileOutputStream ( file , append ) ; } public static String byteCountToDisplaySize ( final BigInteger size ) { String displaySize ; if ( size . divide ( ONE_EB_BI ) . compareTo ( BigInteger . ZERO ) > 0 ) { MST[rv.ROR2Mutator]MSP[N]
moveDirectory ( src , new File ( destDir , src . getName () ) ) ; } public static void moveFile ( final File srcFile , final File destFile ) throws IOException { validateMoveParameters ( srcFile , destFile ) ; MST[VoidMethodCallMutator]MSP[S] if ( srcFile . isDirectory () ) {
return FileFilterUtils . and ( fileFilter , FileFilterUtils . notFileFilter ( DirectoryFileFilter . INSTANCE ) ) ; } private static IOFileFilter setUpEffectiveDirFilter ( final IOFileFilter dirFilter ) { return dirFilter == null ? FalseFileFilter . INSTANCE : FileFilterUtils . and ( dirFilter , MST[InlineConstantMutator]MSP[N] DirectoryFileFilter . INSTANCE ) ; }
if ( ! directory . isDirectory () ) { throw new IllegalArgumentException ( lr_46 + directory ) ; } if ( child == null ) { return false ; MST[InlineConstantMutator]MSP[S] } if ( ! directory . exists () || ! child . exists () ) { return false ; }
final int connectionTimeout , final int readTimeout ) throws IOException { final URLConnection connection = source . openConnection () ; connection . setConnectTimeout ( connectionTimeout ) ; connection . setReadTimeout ( readTimeout ) ; copyInputStreamToFile ( connection . getInputStream () , destination ) ; MST[VoidMethodCallMutator]MSP[S] }
for ( int i = 0 ; i < urls . length ; i ++ ) { MST[NegateConditionalsMutator]MSP[N] final URL url = urls [ i ] ; if ( url != null ) { if ( url . getProtocol () . equals ( lr_24 ) == false ) {
if ( ! file . exists () ) { final String message = file + lr_42 ; throw new IllegalArgumentException ( message ) ; } if ( file . isDirectory () ) { MST[NonVoidMethodCallMutator]MSP[N] return sizeOfDirectory0 ( file ) ; } return file . length () ; }
final String [] suffixes = new String [ extensions . length ] ; for ( int i = 0 ; i < extensions . length ; i ++ ) { suffixes [ i ] = lr_22 + extensions [ i ] ; MST[rv.UOI4Mutator]MSP[N] } return suffixes ; }
final boolean file1Exists = file1 . exists () ; if ( file1Exists != file2 . exists () ) { return false ; } if ( ! file1Exists ) { return true ; } if ( file1 . isDirectory () || file2 . isDirectory () ) { MST[NegateConditionalsMutator]MSP[N]
throw new IOException ( lr_27 + destFile + lr_69 ) ; } final boolean rename = srcFile . renameTo ( destFile ) ; if ( ! rename ) { copyFile ( srcFile , destFile ) ; if ( ! srcFile . delete () ) { MST[rv.ROR5Mutator]MSP[N]
final byte octet = ( byte ) Integer . parseInt ( url . substring ( i + 1 , i + 3 ) , 16 ) ; MST[rv.CRCR6Mutator]MSP[N] bytes . put ( octet ) ; i += 3 ;
final Collection < File > files = new java . util . LinkedList <> () ; if ( includeSubDirectories ) { files . add ( directory ) ; } innerListFiles ( files , directory , MST[rv.CRCR5Mutator]MSP[N] FileFilterUtils . or ( effFileFilter , effDirFilter ) , includeSubDirectories ) ; return files ;
throw new IllegalArgumentException ( lr_25 + url ) ; } files [ i ] = toFile ( url ) ; MST[rv.ABSMutator]MSP[S] } } return files ; } public static URL [] toURLs ( final File [] files ) throws IOException {
if ( ! destDir . exists () ) { throw new FileNotFoundException ( lr_66 + destDir + lr_67 + createDestDir + lr_68 ) ; } if ( ! destDir . isDirectory () ) { MST[rv.ROR3Mutator]MSP[N] throw new IOException ( lr_27 + destDir + lr_28 ) ; }
if ( null != exception ) { throw exception ; } } public static void forceMkdir ( final File directory ) throws IOException { if ( directory . exists () ) { MST[rv.ROR2Mutator]MSP[S] if ( ! directory . isDirectory () ) { final String message = lr_50 + directory + lr_51
if ( files == null ) { return BigInteger . ZERO ; } BigInteger size = BigInteger . ZERO ; for ( final File file : files ) { if ( ! isSymlink ( file ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] size = size . add ( sizeOfBig0 ( file ) ) ;
displaySize = String . valueOf ( size . divide ( ONE_EB_BI ) ) + lr_12 ; } else if ( size . divide ( ONE_PB_BI ) . compareTo ( BigInteger . ZERO ) > 0 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N]
displaySize = String . valueOf ( size . divide ( ONE_PB_BI ) ) + lr_13 ; MST[experimental.NakedReceiverMutator]MSP[N] } else if ( size . divide ( ONE_TB_BI ) . compareTo ( BigInteger . ZERO ) > 0 ) {
} public static void copyFileToDirectory ( final File srcFile , final File destDir ) throws IOException { copyFileToDirectory ( srcFile , destDir , true ) ; MST[rv.CRCR4Mutator]MSP[N] } public static void copyFileToDirectory ( final File srcFile , final File destDir , final boolean preserveFileDate ) throws IOException {
return FileFilterUtils . and ( fileFilter , FileFilterUtils . notFileFilter ( DirectoryFileFilter . INSTANCE ) ) ; } private static IOFileFilter setUpEffectiveDirFilter ( final IOFileFilter dirFilter ) { return dirFilter == null ? FalseFileFilter . INSTANCE : FileFilterUtils . and ( dirFilter , MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] DirectoryFileFilter . INSTANCE ) ; }
for ( int i = 0 ; i < urls . length ; i ++ ) { final URL url = urls [ i ] ; if ( url != null ) { if ( url . getProtocol () . equals ( lr_24 ) == false ) { MST[NegateConditionalsMutator]MSP[N]
size += sizeOf0 ( file ) ; if ( size < 0 ) { break; } } } return size ; } private static long sizeOf0 ( final File file ) { if ( file . isDirectory () ) { return sizeOfDirectory0 ( file ) ; MST[ReturnValsMutator]MSP[S] }
validateMoveParameters ( srcDir , destDir ) ; if ( ! srcDir . isDirectory () ) { throw new IOException ( lr_29 + srcDir + lr_28 ) ; } if ( destDir . exists () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] throw new FileExistsException ( lr_27 + destDir + lr_60 ) ; }
return false ; } return file . lastModified () > timeMillis ; MST[rv.ROR3Mutator]MSP[N] } public static boolean isFileOlder ( final File file , final File reference ) { if ( reference == null ) { throw new IllegalArgumentException ( lr_54 ) ; }
} public static File [] toFiles ( final URL [] urls ) { if ( urls == null || urls . length == 0 ) { MST[rv.ROR2Mutator]MSP[N] return EMPTY_FILE_ARRAY ; } final File [] files = new File [ urls . length ] ;
throw new IOException ( lr_23 ) ; } if ( file1 . length () != file2 . length () ) { return false ; } if ( file1 . getCanonicalFile () . equals ( file2 . getCanonicalFile () ) ) { return true ; MST[rv.CRCR4Mutator]MSP[N] }
} @Deprecated public static void write ( final File file , final CharSequence data ) throws IOException { write ( file , data , Charset . defaultCharset () , false ) ; MST[rv.CRCR6Mutator]MSP[N] } @Deprecated
validateMoveParameters ( srcFile , destDir ) ; if ( ! destDir . exists () && createDestDir ) { destDir . mkdirs () ; } if ( ! destDir . exists () ) { throw new FileNotFoundException ( lr_66 + destDir + MST[NonVoidMethodCallMutator]MSP[S] lr_67 + createDestDir + lr_68 ) ; }
File file = null ; for ( final String name : names ) { if ( file == null ) { file = new File ( name ) ; } else { file = new File ( file , name ) ; } } return file ; MST[NullReturnValsMutator]MSP[S] }
if ( ! directory . exists () ) { return; } directory . deleteOnExit () ; if ( ! isSymlink ( directory ) ) { MST[rv.ROR1Mutator]MSP[N] cleanDirectoryOnExit ( directory ) ; } } private static void cleanDirectoryOnExit ( final File directory ) throws IOException {
final File [] files = directory . listFiles () ; if ( files == null ) { return 0L ; } long size = 0 ; for ( final File file : files ) { MST[rv.UOI2Mutator]MSP[N] if ( ! isSymlink ( file ) ) {
final boolean rename = srcDir . renameTo ( destDir ) ; if ( ! rename ) { MST[rv.UOI4Mutator]MSP[N] if ( destDir . getCanonicalPath () . startsWith ( srcDir . getCanonicalPath () + File . separator ) ) { throw new IOException ( lr_61 + srcDir + lr_62 + destDir ) ;
public static Iterator < File > iterateFilesAndDirs ( final File directory , final IOFileFilter fileFilter , final IOFileFilter dirFilter ) { return listFilesAndDirs ( directory , fileFilter , dirFilter ) . iterator () ; MST[NullReturnValsMutator]MSP[S] } private static String [] toSuffixes ( final String [] extensions ) {
if ( ! srcDir . isDirectory () ) { throw new IOException ( lr_29 + srcDir + lr_39 ) ; MST[ConstructorCallMutator]MSP[S] } if ( srcDir . getCanonicalPath () . equals ( destDir . getCanonicalPath () ) ) {
final String canonicalParent = directory . getCanonicalPath () ; MST[NonVoidMethodCallMutator]MSP[N] final String canonicalChild = child . getCanonicalPath () ; return FilenameUtils . directoryContains ( canonicalParent , canonicalChild ) ; } public static void cleanDirectory ( final File directory ) throws IOException {
public static File getUserDirectory () { return new File ( getUserDirectoryPath () ) ; } public static FileInputStream openInputStream ( final File file ) throws IOException { if ( file . exists () ) { if ( file . isDirectory () ) { MST[rv.ROR5Mutator]MSP[N]
if ( srcLen != dstLen ) { throw new IOException ( lr_34 + srcFile + lr_35 + destFile MST[NonVoidMethodCallMutator]MSP[S] + lr_36 + srcLen + lr_37 + dstLen ) ; } } public static void copyDirectoryToDirectory ( final File srcDir , final File destDir ) throws IOException {
public static String readFileToString ( final File file , final Charset encoding ) throws IOException { try ( InputStream in = openInputStream ( file ) ) { return IOUtils . toString ( in , Charsets . toCharset ( encoding ) ) ; MST[ArgumentPropagationMutator]MSP[N] } }
private static void checkDirectory ( final File directory ) { if ( ! directory . exists () ) { MST[rv.ROR3Mutator]MSP[N] throw new IllegalArgumentException ( directory + lr_42 ) ; } if ( ! directory . isDirectory () ) { throw new IllegalArgumentException ( directory + lr_47 ) ; } }
validateMoveParameters ( srcFile , destDir ) ; if ( ! destDir . exists () && createDestDir ) { MST[rv.ROR1Mutator]MSP[S] destDir . mkdirs () ; } if ( ! destDir . exists () ) { throw new FileNotFoundException ( lr_66 + destDir + lr_67 + createDestDir + lr_68 ) ; }
if ( files == null ) { return BigInteger . ZERO ; } BigInteger size = BigInteger . ZERO ; for ( final File file : files ) { if ( ! isSymlink ( file ) ) { size = size . add ( sizeOfBig0 ( file ) ) ; MST[experimental.NakedReceiverMutator]MSP[N]
throw new IOException ( lr_29 + srcDir + lr_30 + destDir + lr_31 ) ; MST[experimental.NakedReceiverMutator]MSP[N] } List < String > exclusionList = null ; if ( destDir . getCanonicalPath () . startsWith ( srcDir . getCanonicalPath () ) ) {
if ( ! src . exists () ) { throw new FileNotFoundException ( lr_29 + src + lr_8 ) ; MST[experimental.NakedReceiverMutator]MSP[N] } } private static void doCopyDirectory ( final File srcDir , final File destDir , final FileFilter filter , final boolean preserveFileDate , final List < String > exclusionList )
File file = null ; for ( final String name : names ) { MST[rv.ABSMutator]MSP[S] if ( file == null ) { file = new File ( name ) ; } else { file = new File ( file , name ) ; } } return file ; }
if ( srcDir == null ) { throw new NullPointerException ( lr_38 ) ; } if ( srcDir . exists () && srcDir . isDirectory () == false ) { MST[rv.ROR5Mutator]MSP[N] throw new IllegalArgumentException ( lr_29 + destDir + lr_28 ) ; } if ( destDir == null ) {
if ( ! destDir . isDirectory () ) { throw new IOException ( lr_27 + destDir + lr_28 ) ; MST[ConstructorCallMutator]MSP[S] } moveFile ( srcFile , new File ( destDir , srcFile . getName () ) ) ; }
final boolean filePresent = file . exists () ; if ( ! file . delete () ) { if ( ! filePresent ) { MST[rv.ROR4Mutator]MSP[S] throw new FileNotFoundException ( lr_48 + file ) ; } final String message = lr_49 + file ; throw new IOException ( message ) ; }
final FileFilter filter ) throws IOException { copyDirectory ( srcDir , destDir , filter , true ) ; MST[rv.CRCR3Mutator]MSP[N] } public static void copyDirectory ( final File srcDir , final File destDir , final FileFilter filter , final boolean preserveFileDate ) throws IOException { checkFileRequirements ( srcDir , destDir ) ;
writeByteArrayToFile ( file , data , off , len , false ) ; MST[rv.UOI2Mutator]MSP[N] } public static void writeByteArrayToFile ( final File file , final byte [] data , final int off , final int len , final boolean append ) throws IOException {
if ( ! srcDir . isDirectory () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] throw new IOException ( lr_29 + srcDir + lr_39 ) ; } if ( srcDir . getCanonicalPath () . equals ( destDir . getCanonicalPath () ) ) {
throw new IOException ( lr_29 + srcFile + lr_69 ) ; } if ( destFile . exists () ) { MST[rv.ROR4Mutator]MSP[S] throw new FileExistsException ( lr_27 + destFile + lr_60 ) ; } if ( destFile . isDirectory () ) {
doCopyDirectory ( srcFile , dstFile , filter , preserveFileDate , exclusionList ) ; } else { doCopyFile ( srcFile , dstFile , preserveFileDate ) ; } } } if ( preserveFileDate ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] destDir . setLastModified ( srcDir . lastModified () ) ; } }
final boolean file1Exists = file1 . exists () ; if ( file1Exists != file2 . exists () ) { return false ; } if ( ! file1Exists ) { return true ; } if ( file1 . isDirectory () || file2 . isDirectory () ) { MST[rv.ROR2Mutator]MSP[N]
} public static File [] toFiles ( final URL [] urls ) { if ( urls == null || urls . length == 0 ) { MST[rv.ROR5Mutator]MSP[N] return EMPTY_FILE_ARRAY ; } final File [] files = new File [ urls . length ] ;
throw new NullPointerException ( lr_38 ) ; } if ( src . isFile () ) { MST[rv.ROR4Mutator]MSP[N] copyFileToDirectory ( src , destDir ) ; } else if ( src . isDirectory () ) { copyDirectoryToDirectory ( src , destDir ) ; } else {
private static void checkDirectory ( final File directory ) { if ( ! directory . exists () ) { throw new IllegalArgumentException ( directory + lr_42 ) ; MST[NonVoidMethodCallMutator]MSP[N] } if ( ! directory . isDirectory () ) { throw new IllegalArgumentException ( directory + lr_47 ) ; } }
public static File getUserDirectory () { return new File ( getUserDirectoryPath () ) ; } public static FileInputStream openInputStream ( final File file ) throws IOException { if ( file . exists () ) { MST[rv.ROR3Mutator]MSP[N] if ( file . isDirectory () ) {
writeStringToFile ( file , data , Charset . defaultCharset () , false ) ; } @Deprecated public static void writeStringToFile ( final File file , final String data , final boolean append ) throws IOException { writeStringToFile ( file , data , Charset . defaultCharset () , append ) ; MST[rv.UOI1Mutator]MSP[N]
if ( srcLen != dstLen ) { throw new IOException ( lr_34 + srcFile + lr_35 + destFile MST[experimental.NakedReceiverMutator]MSP[N] + lr_36 + srcLen + lr_37 + dstLen ) ; } } public static void copyDirectoryToDirectory ( final File srcDir , final File destDir ) throws IOException {
public static void moveDirectoryToDirectory ( final File src , final File destDir , final boolean createDestDir ) throws IOException { validateMoveParameters ( src , destDir ) ; if ( ! destDir . exists () && createDestDir ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] destDir . mkdirs () ; }
displaySize = String . valueOf ( size . divide ( ONE_MB_BI ) ) + lr_16 ; } else if ( size . divide ( ONE_KB_BI ) . compareTo ( BigInteger . ZERO ) > 0 ) { MST[ConditionalsBoundaryMutator]MSP[N]
throw new NullPointerException ( lr_26 ) ; } if ( ! src . exists () ) { MST[NegateConditionalsMutator]MSP[N] throw new FileNotFoundException ( lr_29 + src + lr_8 ) ; } } public static boolean isSymlink ( final File file ) { if ( file == null ) {
final byte octet = ( byte ) Integer . parseInt ( url . substring ( i + 1 , i + 3 ) , 16 ) ; bytes . put ( octet ) ; MST[rv.UOI4Mutator]MSP[N] i += 3 ;
for ( final String name : names ) { file = new File ( file , name ) ; } return file ; MST[NullReturnValsMutator]MSP[S] } public static File getFile ( final String ... names ) { if ( names == null ) { throw new NullPointerException ( lr_2 ) ; }
displaySize = String . valueOf ( size . divide ( ONE_MB_BI ) ) + lr_16 ; } else if ( size . divide ( ONE_KB_BI ) . compareTo ( BigInteger . ZERO ) > 0 ) { MST[rv.ROR4Mutator]MSP[N]
validateMoveParameters ( srcDir , destDir ) ; if ( ! srcDir . isDirectory () ) { MST[rv.ROR4Mutator]MSP[N] throw new IOException ( lr_29 + srcDir + lr_28 ) ; } if ( destDir . exists () ) { throw new FileExistsException ( lr_27 + destDir + lr_60 ) ; }
final File [] found = directory . listFiles ( ( FileFilter ) filter ) ; if ( found != null ) { for ( final File file : found ) { if ( file . isDirectory () ) { MST[NonVoidMethodCallMutator]MSP[N] if ( includeSubDirectories ) {
public static boolean isFileNewer ( final File file , final File reference ) { if ( reference == null ) { throw new IllegalArgumentException ( lr_54 ) ; } if ( ! reference . exists () ) { MST[rv.ROR3Mutator]MSP[N] throw new IllegalArgumentException ( lr_55 + reference + lr_56 ) ; }
displaySize = String . valueOf ( size . divide ( ONE_KB_BI ) ) + lr_17 ; MST[NonVoidMethodCallMutator]MSP[N] } else { displaySize = String . valueOf ( size ) + lr_18 ; } return displaySize ; } public static String byteCountToDisplaySize ( final long size ) {
} while ( i < n && url . charAt ( i ) == '%' ); MST[rv.ROR1Mutator]MSP[S] continue; } catch ( final RuntimeException e ) { } finally { if ( bytes . position () > 0 ) { bytes . flip () ;
if ( srcFile . getCanonicalPath () . equals ( destFile . getCanonicalPath () ) ) { MST[NegateConditionalsMutator]MSP[N] throw new IOException ( lr_29 + srcFile + lr_30 + destFile + lr_31 ) ; } final File parentFile = destFile . getParentFile () ; if ( parentFile != null ) {
for ( final File srcFile : srcFiles ) { final File copiedFile = new File ( destDir , srcFile . getName () ) ; exclusionList . add ( copiedFile . getCanonicalPath () ) ; } } } doCopyDirectory ( srcDir , destDir , filter , preserveFileDate , exclusionList ) ; MST[rv.UOI1Mutator]MSP[N]
final URL [] urls = new URL [ files . length ] ; for ( int i = 0 ; i < urls . length ; i ++ ) { MST[rv.CRCR1Mutator]MSP[S] urls [ i ] = files [ i ] . toURI () . toURL () ; } return urls ;
throw new NullPointerException ( lr_26 ) ; } if ( destDir . exists () && destDir . isDirectory () == false ) { MST[rv.ROR5Mutator]MSP[S] throw new IllegalArgumentException ( lr_27 + destDir + lr_28 ) ; }
validateMoveParameters ( srcFile , destDir ) ; if ( ! destDir . exists () && createDestDir ) { destDir . mkdirs () ; } if ( ! destDir . exists () ) { throw new FileNotFoundException ( lr_66 + destDir + MST[ConstructorCallMutator]MSP[S] lr_67 + createDestDir + lr_68 ) ; }
final boolean file1Exists = file1 . exists () ; if ( file1Exists != file2 . exists () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return false ; } if ( ! file1Exists ) { return true ; } if ( file1 . isDirectory () || file2 . isDirectory () ) {
if ( ! directory . isDirectory () ) { throw new IllegalArgumentException ( lr_46 + directory ) ; } if ( child == null ) { return false ; } if ( ! directory . exists () || ! child . exists () ) { MST[rv.ROR2Mutator]MSP[N] return false ; }
} private static void checkFileRequirements ( final File src , final File dest ) throws FileNotFoundException { if ( src == null ) { throw new NullPointerException ( lr_38 ) ; } if ( dest == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] throw new NullPointerException ( lr_26 ) ; }
if ( srcFile . getCanonicalPath () . equals ( destFile . getCanonicalPath () ) ) { MST[rv.ROR5Mutator]MSP[N] throw new IOException ( lr_29 + srcFile + lr_30 + destFile + lr_31 ) ; } final File parentFile = destFile . getParentFile () ; if ( parentFile != null ) {
final boolean filePresent = file . exists () ; if ( ! file . delete () ) { if ( ! filePresent ) { MST[rv.UOI3Mutator]MSP[S] throw new FileNotFoundException ( lr_48 + file ) ; } final String message = lr_49 + file ; throw new IOException ( message ) ; }
throw new IllegalArgumentException ( lr_58 ) ; } if ( ! file . exists () ) { return false ; MST[ReturnValsMutator]MSP[S] } return file . lastModified () < timeMillis ; } public static long checksumCRC32 ( final File file ) throws IOException { final CRC32 crc = new CRC32 () ;
while ( ! file . exists () ) { final long remaining = finishAt - System . currentTimeMillis () ; if ( remaining < 0 ) { return false ; } try { Thread . sleep ( Math . min ( 100 , remaining ) ) ; MST[rv.CRCR4Mutator]MSP[N]
final File dstFile = new File ( destDir , srcFile . getName () ) ; if ( exclusionList == null || ! exclusionList . contains ( srcFile . getCanonicalPath () ) ) { if ( srcFile . isDirectory () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
try ( OutputStream out = openOutputStream ( destination ) ) { IOUtils . copy ( source , out ) ; } } public static void copyToDirectory ( final File src , final File destDir ) throws IOException { if ( src == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
} public static void copyFileToDirectory ( final File srcFile , final File destDir ) throws IOException { copyFileToDirectory ( srcFile , destDir , true ) ; MST[InlineConstantMutator]MSP[N] } public static void copyFileToDirectory ( final File srcFile , final File destDir , final boolean preserveFileDate ) throws IOException {
final Collection < File > files = new java . util . LinkedList <> () ; if ( includeSubDirectories ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] files . add ( directory ) ; } innerListFiles ( files , directory , FileFilterUtils . or ( effFileFilter , effDirFilter ) , includeSubDirectories ) ; return files ;
throw new IOException ( lr_23 ) ; } if ( file1 . getCanonicalFile () . equals ( file2 . getCanonicalFile () ) ) { return true ; MST[rv.CRCR2Mutator]MSP[S] } try ( Reader input1 = charsetName == null
if ( ! srcDir . isDirectory () ) { throw new IOException ( lr_29 + srcDir + lr_39 ) ; } if ( srcDir . getCanonicalPath () . equals ( destDir . getCanonicalPath () ) ) { MST[NonVoidMethodCallMutator]MSP[S]
if ( destDir . isDirectory () == false ) { MST[rv.ROR3Mutator]MSP[N] throw new IOException ( lr_27 + destDir + lr_39 ) ; } } else { if ( ! destDir . mkdirs () && ! destDir . isDirectory () ) {
if ( date == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] throw new IllegalArgumentException ( lr_57 ) ; } return isFileOlder ( file , date . getTime () ) ; } public static boolean isFileOlder ( final File file , final long timeMillis ) { if ( file == null ) {
final boolean rename = srcDir . renameTo ( destDir ) ; if ( ! rename ) { if ( destDir . getCanonicalPath () . startsWith ( srcDir . getCanonicalPath () + File . separator ) ) { MST[NonVoidMethodCallMutator]MSP[S] throw new IOException ( lr_61 + srcDir + lr_62 + destDir ) ;
final FileFilter filter ) throws IOException { copyDirectory ( srcDir , destDir , filter , true ) ; MST[InlineConstantMutator]MSP[N] } public static void copyDirectory ( final File srcDir , final File destDir , final FileFilter filter , final boolean preserveFileDate ) throws IOException { checkFileRequirements ( srcDir , destDir ) ;
final String [] suffixes = new String [ extensions . length ] ; for ( int i = 0 ; i < extensions . length ; i ++ ) { suffixes [ i ] = lr_22 + extensions [ i ] ; MST[NonVoidMethodCallMutator]MSP[N] } return suffixes ; }
size += sizeOf0 ( file ) ; if ( size < 0 ) { MST[rv.CRCR1Mutator]MSP[N] break; } } } return size ; } private static long sizeOf0 ( final File file ) { if ( file . isDirectory () ) { return sizeOfDirectory0 ( file ) ; }
final File destFile = new File ( destDir , srcFile . getName () ) ; copyFile ( srcFile , destFile , preserveFileDate ) ; MST[rv.UOI2Mutator]MSP[N] } public static void copyFile ( final File srcFile , final File destFile ) throws IOException { copyFile ( srcFile , destFile , true ) ;
throw new IOException ( lr_29 + srcFile + lr_69 ) ; } if ( destFile . exists () ) { throw new FileExistsException ( lr_27 + destFile + lr_60 ) ; } if ( destFile . isDirectory () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
return lineIterator ( file , null ) ; MST[NonVoidMethodCallMutator]MSP[S] } public static void writeStringToFile ( final File file , final String data , final Charset encoding ) throws IOException { writeStringToFile ( file , data , encoding , false ) ; }
if ( destDir . isDirectory () == false ) { throw new IOException ( lr_27 + destDir + lr_39 ) ; } } else { if ( ! destDir . mkdirs () && ! destDir . isDirectory () ) { MST[NonVoidMethodCallMutator]MSP[N]
if ( ! destDir . isDirectory () ) { throw new IOException ( lr_27 + destDir + lr_28 ) ; MST[experimental.NakedReceiverMutator]MSP[N] } moveFile ( srcFile , new File ( destDir , srcFile . getName () ) ) ; }
final StringBuilder buffer = new StringBuilder () ; final ByteBuffer bytes = ByteBuffer . allocate ( n ) ; for ( int i = 0 ; i < n ; ) { if ( url . charAt ( i ) == '%' ) { MST[rv.ROR1Mutator]MSP[N] try { do {
throw new NullPointerException ( lr_26 ) ; } if ( destDir . exists () && destDir . isDirectory () == false ) { MST[NegateConditionalsMutator]MSP[S] throw new IllegalArgumentException ( lr_27 + destDir + lr_28 ) ; }
displaySize = String . valueOf ( size . divide ( ONE_KB_BI ) ) + lr_17 ; MST[experimental.NakedReceiverMutator]MSP[N] } else { displaySize = String . valueOf ( size ) + lr_18 ; } return displaySize ; } public static String byteCountToDisplaySize ( final long size ) {
try ( InputStream in = new CheckedInputStream ( new FileInputStream ( file ) , checksum ) ) { IOUtils . copy ( in , new NullOutputStream () ) ; } return checksum ; MST[ReturnValsMutator]MSP[S] } public static void moveDirectory ( final File srcDir , final File destDir ) throws IOException {
return FileFilterUtils . and ( fileFilter , FileFilterUtils . notFileFilter ( DirectoryFileFilter . INSTANCE ) ) ; } private static IOFileFilter setUpEffectiveDirFilter ( final IOFileFilter dirFilter ) { return dirFilter == null ? FalseFileFilter . INSTANCE : FileFilterUtils . and ( dirFilter , MST[rv.CRCR5Mutator]MSP[N] DirectoryFileFilter . INSTANCE ) ; }
private static void checkDirectory ( final File directory ) { if ( ! directory . exists () ) { throw new IllegalArgumentException ( directory + lr_42 ) ; } if ( ! directory . isDirectory () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] throw new IllegalArgumentException ( directory + lr_47 ) ; } }
throw new NullPointerException ( lr_26 ) ; } if ( ! src . exists () ) { throw new FileNotFoundException ( lr_29 + src + lr_8 ) ; MST[NonVoidMethodCallMutator]MSP[N] } } public static boolean isSymlink ( final File file ) { if ( file == null ) {
displaySize = String . valueOf ( size . divide ( ONE_TB_BI ) ) + lr_14 ; } else if ( size . divide ( ONE_GB_BI ) . compareTo ( BigInteger . ZERO ) > 0 ) { MST[rv.ROR3Mutator]MSP[N]
} while ( i < n && url . charAt ( i ) == '%' ); MST[ConditionalsBoundaryMutator]MSP[N] continue; } catch ( final RuntimeException e ) { } finally { if ( bytes . position () > 0 ) { bytes . flip () ;
final URL [] urls = new URL [ files . length ] ; for ( int i = 0 ; i < urls . length ; i ++ ) { MST[rv.ABSMutator]MSP[S] urls [ i ] = files [ i ] . toURI () . toURL () ; } return urls ;
throws IOException { final File [] srcFiles = filter == null ? srcDir . listFiles () : srcDir . listFiles ( filter ) ; if ( srcFiles == null ) { throw new IOException ( lr_40 + srcDir ) ; } if ( destDir . exists () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
throw new IOException ( lr_23 ) ; } if ( file1 . getCanonicalFile () . equals ( file2 . getCanonicalFile () ) ) { return true ; MST[ReturnValsMutator]MSP[S] } try ( Reader input1 = charsetName == null
final byte octet = ( byte ) Integer . parseInt ( url . substring ( i + 1 , i + 3 ) , 16 ) ; MST[rv.CRCR1Mutator]MSP[N] bytes . put ( octet ) ; i += 3 ;
public static String getTempDirectoryPath () { return System . getProperty ( lr_3 ) ; } public static File getTempDirectory () { return new File ( getTempDirectoryPath () ) ; } public static String getUserDirectoryPath () { return System . getProperty ( lr_4 ) ; MST[ArgumentPropagationMutator]MSP[N] }
size += sizeOf0 ( file ) ; MST[rv.AOR3Mutator]MSP[N] if ( size < 0 ) { break; } } } return size ; } private static long sizeOf0 ( final File file ) { if ( file . isDirectory () ) { return sizeOfDirectory0 ( file ) ; }
if ( ! parentFile . mkdirs () && ! parentFile . isDirectory () ) { MST[rv.ROR2Mutator]MSP[N] throw new IOException ( lr_27 + parentFile + lr_32 ) ; } } if ( destFile . exists () && destFile . canWrite () == false ) {
File file = null ; for ( final String name : names ) { MST[rv.UOI2Mutator]MSP[S] if ( file == null ) { file = new File ( name ) ; } else { file = new File ( file , name ) ; } } return file ; }
for ( int i = 0 ; i < urls . length ; i ++ ) { MST[rv.CRCR5Mutator]MSP[N] final URL url = urls [ i ] ; if ( url != null ) { if ( url . getProtocol () . equals ( lr_24 ) == false ) {
if ( srcDir == null ) { throw new NullPointerException ( lr_38 ) ; } if ( srcDir . exists () && srcDir . isDirectory () == false ) { MST[NegateConditionalsMutator]MSP[N] throw new IllegalArgumentException ( lr_29 + destDir + lr_28 ) ; } if ( destDir == null ) {
return fileLength > 0 ? IOUtils . toByteArray ( in , fileLength ) : IOUtils . toByteArray ( in ) ; MST[InlineConstantMutator]MSP[N] } } public static List < String > readLines ( final File file , final Charset encoding ) throws IOException {
validateMoveParameters ( srcFile , destDir ) ; if ( ! destDir . exists () && createDestDir ) { MST[rv.ROR2Mutator]MSP[N] destDir . mkdirs () ; } if ( ! destDir . exists () ) { throw new FileNotFoundException ( lr_66 + destDir + lr_67 + createDestDir + lr_68 ) ; }
final File directory , final IOFileFilter fileFilter , final IOFileFilter dirFilter , final boolean includeSubDirectories ) { validateListFilesParameters ( directory , fileFilter ) ; final IOFileFilter effFileFilter = setUpEffectiveFileFilter ( fileFilter ) ; final IOFileFilter effDirFilter = setUpEffectiveDirFilter ( dirFilter ) ; MST[ArgumentPropagationMutator]MSP[N]
for ( int i = 0 ; i < urls . length ; i ++ ) { MST[ConditionalsBoundaryMutator]MSP[N] final URL url = urls [ i ] ; if ( url != null ) { if ( url . getProtocol () . equals ( lr_24 ) == false ) {
final URL [] urls = new URL [ files . length ] ; for ( int i = 0 ; i < urls . length ; i ++ ) { urls [ i ] = files [ i ] . toURI () . toURL () ; MST[rv.UOI3Mutator]MSP[S] } return urls ;
final boolean rename = srcDir . renameTo ( destDir ) ; if ( ! rename ) { if ( destDir . getCanonicalPath () . startsWith ( srcDir . getCanonicalPath () + File . separator ) ) { throw new IOException ( lr_61 + srcDir + lr_62 + destDir ) ; MST[NonVoidMethodCallMutator]MSP[N]
return false ; MST[InlineConstantMutator]MSP[N] } return file . lastModified () > timeMillis ; } public static boolean isFileOlder ( final File file , final File reference ) { if ( reference == null ) { throw new IllegalArgumentException ( lr_54 ) ; }
public static BigInteger sizeOfAsBigInteger ( final File file ) { if ( ! file . exists () ) { MST[rv.ROR2Mutator]MSP[N] final String message = file + lr_42 ; throw new IllegalArgumentException ( message ) ; } if ( file . isDirectory () ) { return sizeOfDirectoryBig0 ( file ) ; }
while ( ! file . exists () ) { final long remaining = finishAt - System . currentTimeMillis () ; if ( remaining < 0 ) { return false ; } try { Thread . sleep ( Math . min ( 100 , remaining ) ) ; MST[rv.UOI1Mutator]MSP[N]
displaySize = String . valueOf ( size . divide ( ONE_GB_BI ) ) + lr_15 ; MST[NonVoidMethodCallMutator]MSP[N] } else if ( size . divide ( ONE_MB_BI ) . compareTo ( BigInteger . ZERO ) > 0 ) {
final StringBuilder buffer = new StringBuilder () ; final ByteBuffer bytes = ByteBuffer . allocate ( n ) ; for ( int i = 0 ; i < n ; ) { if ( url . charAt ( i ) == '%' ) { MST[rv.ABSMutator]MSP[N] try { do {
throws IOException { final boolean file1Exists = file1 . exists () ; if ( file1Exists != file2 . exists () ) { return false ; } if ( ! file1Exists ) { return true ; MST[rv.CRCR6Mutator]MSP[S] } if ( file1 . isDirectory () || file2 . isDirectory () ) {
throw new NullPointerException ( lr_38 ) ; } if ( src . isFile () ) { copyFileToDirectory ( src , destDir ) ; MST[VoidMethodCallMutator]MSP[N] } else if ( src . isDirectory () ) { copyDirectoryToDirectory ( src , destDir ) ; } else {
if ( ! src . exists () ) { throw new FileNotFoundException ( lr_29 + src + lr_8 ) ; MST[NonVoidMethodCallMutator]MSP[N] } } private static void doCopyDirectory ( final File srcDir , final File destDir , final FileFilter filter , final boolean preserveFileDate , final List < String > exclusionList )
buffer . append ( StandardCharsets . UTF_8 . decode ( bytes ) . toString () ) ; bytes . clear () ; } } } buffer . append ( url . charAt ( i ++ ) ) ; } decoded = buffer . toString () ; } return decoded ; MST[EmptyObjectReturnValsMutator]MSP[N]
throw new NullPointerException ( lr_26 ) ; } if ( ! src . exists () ) { MST[rv.ROR5Mutator]MSP[N] throw new FileNotFoundException ( lr_29 + src + lr_8 ) ; } } public static boolean isSymlink ( final File file ) { if ( file == null ) {
final Collection < File > files = new java . util . LinkedList <> () ; if ( includeSubDirectories ) { MST[rv.ROR1Mutator]MSP[N] files . add ( directory ) ; } innerListFiles ( files , directory , FileFilterUtils . or ( effFileFilter , effDirFilter ) , includeSubDirectories ) ; return files ;
if ( ! destDir . isDirectory () ) { MST[NegateConditionalsMutator]MSP[N] throw new IOException ( lr_27 + destDir + lr_28 ) ; } moveFile ( srcFile , new File ( destDir , srcFile . getName () ) ) ; }
return fileLength > 0 ? IOUtils . toByteArray ( in , fileLength ) : IOUtils . toByteArray ( in ) ; MST[rv.ROR2Mutator]MSP[N] } } public static List < String > readLines ( final File file , final Charset encoding ) throws IOException {
files . add ( file ) ; } innerListFiles ( files , file , filter , includeSubDirectories ) ; MST[VoidMethodCallMutator]MSP[N] } else { files . add ( file ) ; } } } } public static Collection < File > listFiles (
return FileFilterUtils . and ( fileFilter , FileFilterUtils . notFileFilter ( DirectoryFileFilter . INSTANCE ) ) ; MST[rv.CRCR3Mutator]MSP[N] } private static IOFileFilter setUpEffectiveDirFilter ( final IOFileFilter dirFilter ) { return dirFilter == null ? FalseFileFilter . INSTANCE : FileFilterUtils . and ( dirFilter , DirectoryFileFilter . INSTANCE ) ; }
size += sizeOf0 ( file ) ; if ( size < 0 ) { break; } } } return size ; } private static long sizeOf0 ( final File file ) { if ( file . isDirectory () ) { MST[rv.ROR4Mutator]MSP[N] return sizeOfDirectory0 ( file ) ; }
final byte octet = ( byte ) Integer . parseInt ( url . substring ( i + 1 , i + 3 ) , 16 ) ; MST[rv.AOR1Mutator]MSP[N] bytes . put ( octet ) ; i += 3 ;
public static void moveToDirectory ( final File src , final File destDir , final boolean createDestDir ) throws IOException { validateMoveParameters ( src , destDir ) ; if ( src . isDirectory () ) { MST[rv.ROR3Mutator]MSP[S] moveDirectoryToDirectory ( src , destDir , createDestDir ) ; } else {
throw new IOException ( lr_23 ) ; } if ( file1 . length () != file2 . length () ) { return false ; } if ( file1 . getCanonicalFile () . equals ( file2 . getCanonicalFile () ) ) { MST[rv.ROR5Mutator]MSP[S] return true ; }
throw new IOException ( lr_5 + file + lr_6 ) ; } if ( file . canRead () == false ) { throw new IOException ( lr_5 + file + lr_7 ) ; } } else { throw new FileNotFoundException ( lr_5 + file + lr_8 ) ; MST[experimental.NakedReceiverMutator]MSP[N] }
if ( ! parentFile . mkdirs () && ! parentFile . isDirectory () ) { throw new IOException ( lr_27 + parentFile + lr_32 ) ; } } if ( destFile . exists () && destFile . canWrite () == false ) { MST[NegateConditionalsMutator]MSP[N]
cleanDirectory ( directory ) ; } if ( ! directory . delete () ) { MST[rv.ROR4Mutator]MSP[N] final String message = lr_44 + directory + lr_22 ; throw new IOException ( message ) ; } } public static boolean deleteQuietly ( final File file ) {
if ( ! destDir . exists () ) { MST[rv.ROR3Mutator]MSP[N] throw new FileNotFoundException ( lr_66 + destDir + lr_67 + createDestDir + lr_68 ) ; } if ( ! destDir . isDirectory () ) { throw new IOException ( lr_27 + destDir + lr_28 ) ; }
+ lr_52 ; throw new IOException ( message ) ; } } else { if ( ! directory . mkdirs () ) { MST[rv.ROR4Mutator]MSP[S] if ( ! directory . isDirectory () ) { final String message = lr_53 + directory ; throw new IOException ( message ) ; } } }
displaySize = String . valueOf ( size . divide ( ONE_MB_BI ) ) + lr_16 ; MST[ConstructorCallMutator]MSP[N] } else if ( size . divide ( ONE_KB_BI ) . compareTo ( BigInteger . ZERO ) > 0 ) {
final boolean file1Exists = file1 . exists () ; if ( file1Exists != file2 . exists () ) { MST[NonVoidMethodCallMutator]MSP[N] return false ; } if ( ! file1Exists ) { return true ; } if ( file1 . isDirectory () || file2 . isDirectory () ) {
throws IOException { final boolean file1Exists = file1 . exists () ; if ( file1Exists != file2 . exists () ) { MST[rv.ROR1Mutator]MSP[S] return false ; } if ( ! file1Exists ) { return true ; } if ( file1 . isDirectory () || file2 . isDirectory () ) {
size += sizeOf0 ( file ) ; MST[rv.AOD1Mutator]MSP[N] if ( size < 0 ) { break; } } } return size ; } private static long sizeOf0 ( final File file ) { if ( file . isDirectory () ) { return sizeOfDirectory0 ( file ) ; }
} } return size ; } private static BigInteger sizeOfBig0 ( final File fileOrDir ) { if ( fileOrDir . isDirectory () ) { MST[NegateConditionalsMutator]MSP[N] return sizeOfDirectoryBig0 ( fileOrDir ) ; } return BigInteger . valueOf ( fileOrDir . length () ) ; }
throws IOException { final boolean file1Exists = file1 . exists () ; MST[NonVoidMethodCallMutator]MSP[S] if ( file1Exists != file2 . exists () ) { return false ; } if ( ! file1Exists ) { return true ; } if ( file1 . isDirectory () || file2 . isDirectory () ) {
return new File ( filename ) ; } static String decodeUrl ( final String url ) { String decoded = url ; if ( url != null && url . indexOf ( '%' ) >= 0 ) { MST[NonVoidMethodCallMutator]MSP[N] final int n = url . length () ;
return new FileOutputStream ( file , append ) ; } public static String byteCountToDisplaySize ( final BigInteger size ) { String displaySize ; if ( size . divide ( ONE_EB_BI ) . compareTo ( BigInteger . ZERO ) > 0 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N]
if ( srcFile . getCanonicalPath () . equals ( destFile . getCanonicalPath () ) ) { throw new IOException ( lr_29 + srcFile + lr_30 + destFile + lr_31 ) ; MST[experimental.NakedReceiverMutator]MSP[N] } final File parentFile = destFile . getParentFile () ; if ( parentFile != null ) {
if ( ! file . exists () ) { MST[rv.ROR5Mutator]MSP[N] final String message = file + lr_42 ; throw new IllegalArgumentException ( message ) ; } if ( file . isDirectory () ) { return sizeOfDirectory0 ( file ) ; } return file . length () ; }
} while ( i < n && url . charAt ( i ) == '%' ); MST[NegateConditionalsMutator]MSP[N] continue; } catch ( final RuntimeException e ) { } finally { if ( bytes . position () > 0 ) { bytes . flip () ;
final File [] srcFiles = filter == null ? srcDir . listFiles () : srcDir . listFiles ( filter ) ; if ( srcFiles != null && srcFiles . length > 0 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] exclusionList = new ArrayList <> ( srcFiles . length ) ;
if ( destDir == null ) { throw new NullPointerException ( lr_26 ) ; } if ( destDir . exists () && destDir . isDirectory () == false ) { MST[rv.ROR4Mutator]MSP[N] throw new IllegalArgumentException ( lr_27 + destDir + lr_28 ) ; }
if ( url == null || ! lr_24 . equalsIgnoreCase ( url . getProtocol () ) ) { return null ; } String filename = url . getFile () . replace ( '/' , File . separatorChar ) ; MST[experimental.NakedReceiverMutator]MSP[N] filename = decodeUrl ( filename ) ;
writeStringToFile ( file , data , Charset . defaultCharset () , false ) ; MST[InlineConstantMutator]MSP[N] } @Deprecated public static void writeStringToFile ( final File file , final String data , final boolean append ) throws IOException { writeStringToFile ( file , data , Charset . defaultCharset () , append ) ;
if ( null != exception ) { throw exception ; } } private static File [] verifiedListFiles ( final File directory ) throws IOException { if ( ! directory . exists () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] final String message = directory + lr_42 ; throw new IllegalArgumentException ( message ) ; }
try ( OutputStream out = openOutputStream ( file , append ) ) { out . write ( data , off , len ) ; MST[rv.UOI4Mutator]MSP[N] } } public static void writeLines ( final File file , final String encoding , final Collection < ? > lines ) throws IOException {
return fileLength > 0 ? IOUtils . toByteArray ( in , fileLength ) : IOUtils . toByteArray ( in ) ; MST[RemoveConditionalMutator_ORDER_IF]MSP[N] } } public static List < String > readLines ( final File file , final Charset encoding ) throws IOException {
displaySize = String . valueOf ( size . divide ( ONE_EB_BI ) ) + lr_12 ; } else if ( size . divide ( ONE_PB_BI ) . compareTo ( BigInteger . ZERO ) > 0 ) { MST[rv.ROR2Mutator]MSP[N]
while ( ! file . exists () ) { final long remaining = finishAt - System . currentTimeMillis () ; if ( remaining < 0 ) { return false ; MST[rv.CRCR5Mutator]MSP[N] } try { Thread . sleep ( Math . min ( 100 , remaining ) ) ;
} } public static void forceDeleteOnExit ( final File file ) throws IOException { if ( file . isDirectory () ) { deleteDirectoryOnExit ( file ) ; MST[VoidMethodCallMutator]MSP[S] } else { file . deleteOnExit () ; } } private static void deleteDirectoryOnExit ( final File directory ) throws IOException {
} while ( i < n && url . charAt ( i ) == '%' ); MST[rv.ABSMutator]MSP[N] continue; } catch ( final RuntimeException e ) { } finally { if ( bytes . position () > 0 ) { bytes . flip () ;
throw new IOException ( lr_27 + destFile + lr_6 ) ; } final Path srcPath = srcFile . toPath () ; final Path destPath = destFile . toPath () ; final long newLastModifed = preserveFileDate ? srcFile . lastModified () : destFile . lastModified () ; MST[NonVoidMethodCallMutator]MSP[N]
final File [] files = verifiedListFiles ( directory ) ; IOException exception = null ; for ( final File file : files ) { MST[rv.UOI2Mutator]MSP[S] try { forceDeleteOnExit ( file ) ; } catch ( final IOException ioe ) { exception = ioe ; } }
public static boolean isFileNewer ( final File file , final File reference ) { if ( reference == null ) { throw new IllegalArgumentException ( lr_54 ) ; } if ( ! reference . exists () ) { throw new IllegalArgumentException ( lr_55 MST[experimental.NakedReceiverMutator]MSP[S] + reference + lr_56 ) ; }
if ( ! directory . exists () ) { MST[rv.ROR5Mutator]MSP[S] return; } directory . deleteOnExit () ; if ( ! isSymlink ( directory ) ) { cleanDirectoryOnExit ( directory ) ; } } private static void cleanDirectoryOnExit ( final File directory ) throws IOException {
public static Collection < File > listFilesAndDirs ( final File directory , final IOFileFilter fileFilter , final IOFileFilter dirFilter ) { return innerListFilesOrDirectories ( directory , fileFilter , dirFilter , true ) ; MST[rv.CRCR6Mutator]MSP[N] } private static Collection < File > innerListFilesOrDirectories (
final String [] suffixes = new String [ extensions . length ] ; for ( int i = 0 ; i < extensions . length ; i ++ ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] suffixes [ i ] = lr_22 + extensions [ i ] ; } return suffixes ; }
if ( srcFile . getCanonicalPath () . equals ( destFile . getCanonicalPath () ) ) { throw new IOException ( lr_29 + srcFile + lr_30 + destFile + lr_31 ) ; MST[ConstructorCallMutator]MSP[S] } final File parentFile = destFile . getParentFile () ; if ( parentFile != null ) {
if ( ! directory . isDirectory () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] throw new IllegalArgumentException ( lr_46 + directory ) ; } if ( child == null ) { return false ; } if ( ! directory . exists () || ! child . exists () ) { return false ; }
checksum ( file , crc ) ; return crc . getValue () ; MST[PrimitiveReturnsMutator]MSP[S] } public static Checksum checksum ( final File file , final Checksum checksum ) throws IOException { if ( file . isDirectory () ) { throw new IllegalArgumentException ( lr_59 ) ; }
public static File getFile ( final File directory , final String ... names ) { if ( directory == null ) { throw new NullPointerException ( lr_1 ) ; } if ( names == null ) { MST[rv.ROR5Mutator]MSP[S] throw new NullPointerException ( lr_2 ) ; } File file = directory ;
final Collection < File > files = new java . util . LinkedList <> () ; if ( includeSubDirectories ) { files . add ( directory ) ; } innerListFiles ( files , directory , MST[rv.CRCR3Mutator]MSP[N] FileFilterUtils . or ( effFileFilter , effDirFilter ) , includeSubDirectories ) ; return files ;
checksum ( file , crc ) ; return crc . getValue () ; } public static Checksum checksum ( final File file , final Checksum checksum ) throws IOException { if ( file . isDirectory () ) { MST[rv.ROR2Mutator]MSP[N] throw new IllegalArgumentException ( lr_59 ) ; }
final StringBuilder buffer = new StringBuilder () ; final ByteBuffer bytes = ByteBuffer . allocate ( n ) ; for ( int i = 0 ; i < n ; ) { MST[rv.CRCR5Mutator]MSP[N] if ( url . charAt ( i ) == '%' ) { try { do {
if ( srcFile . getCanonicalPath () . equals ( destFile . getCanonicalPath () ) ) { MST[NonVoidMethodCallMutator]MSP[S] throw new IOException ( lr_29 + srcFile + lr_30 + destFile + lr_31 ) ; } final File parentFile = destFile . getParentFile () ; if ( parentFile != null ) {
final String [] suffixes = new String [ extensions . length ] ; for ( int i = 0 ; i < extensions . length ; i ++ ) { MST[rv.CRCR1Mutator]MSP[N] suffixes [ i ] = lr_22 + extensions [ i ] ; } return suffixes ; }
throws IOException { final boolean file1Exists = file1 . exists () ; if ( file1Exists != file2 . exists () ) { return false ; } if ( ! file1Exists ) { return true ; } if ( file1 . isDirectory () || file2 . isDirectory () ) { MST[rv.ROR4Mutator]MSP[N]
if ( files == null ) { MST[NegateConditionalsMutator]MSP[N] return BigInteger . ZERO ; } BigInteger size = BigInteger . ZERO ; for ( final File file : files ) { if ( ! isSymlink ( file ) ) { size = size . add ( sizeOfBig0 ( file ) ) ;
size += sizeOf0 ( file ) ; if ( size < 0 ) { break; } } } return size ; MST[rv.UOI1Mutator]MSP[N] } private static long sizeOf0 ( final File file ) { if ( file . isDirectory () ) { return sizeOfDirectory0 ( file ) ; }
FileUtils . deleteQuietly ( destFile ) ; throw new IOException ( lr_70 + srcFile + MST[NonVoidMethodCallMutator]MSP[N] lr_64 + destFile + lr_65 ) ; } } } public static void moveFileToDirectory ( final File srcFile , final File destDir , final boolean createDestDir ) throws IOException {
if ( ! file . exists () ) { final String message = file + lr_42 ; MST[ConstructorCallMutator]MSP[S] throw new IllegalArgumentException ( message ) ; } if ( file . isDirectory () ) { return sizeOfDirectory0 ( file ) ; } return file . length () ; }
return byteCountToDisplaySize ( BigInteger . valueOf ( size ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } public static void touch ( final File file ) throws IOException { if ( ! file . exists () ) { openOutputStream ( file ) . close () ; }
final File [] found = directory . listFiles ( ( FileFilter ) filter ) ; if ( found != null ) { for ( final File file : found ) { if ( file . isDirectory () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] if ( includeSubDirectories ) {
if ( ! directory . isDirectory () ) { throw new IllegalArgumentException ( lr_46 + directory ) ; } if ( child == null ) { return false ; } if ( ! directory . exists () || ! child . exists () ) { return false ; MST[rv.CRCR5Mutator]MSP[N] }
if ( ! directory . isDirectory () ) { MST[NonVoidMethodCallMutator]MSP[N] throw new IllegalArgumentException ( lr_46 + directory ) ; } if ( child == null ) { return false ; } if ( ! directory . exists () || ! child . exists () ) { return false ; }
buffer . append ( StandardCharsets . UTF_8 . decode ( bytes ) . toString () ) ; bytes . clear () ; } } } buffer . append ( url . charAt ( i ++ ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } decoded = buffer . toString () ; } return decoded ;
throw new NullPointerException ( lr_26 ) ; } if ( destDir . exists () && destDir . isDirectory () == false ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] throw new IllegalArgumentException ( lr_27 + destDir + lr_28 ) ; }
throw new IOException ( lr_27 + destDir + lr_32 ) ; } } if ( destDir . canWrite () == false ) { throw new IOException ( lr_27 + destDir + lr_9 ) ; } for ( final File srcFile : srcFiles ) { MST[rv.UOI1Mutator]MSP[N]
throws IOException { final boolean file1Exists = file1 . exists () ; if ( file1Exists != file2 . exists () ) { MST[rv.ABSMutator]MSP[S] return false ; } if ( ! file1Exists ) { return true ; } if ( file1 . isDirectory () || file2 . isDirectory () ) {
throw new IllegalArgumentException ( lr_58 ) ; } if ( ! file . exists () ) { return false ; } return file . lastModified () < timeMillis ; MST[rv.CRCR5Mutator]MSP[S] } public static long checksumCRC32 ( final File file ) throws IOException { final CRC32 crc = new CRC32 () ;
if ( ! directory . exists () ) { MST[NegateConditionalsMutator]MSP[S] return; } directory . deleteOnExit () ; if ( ! isSymlink ( directory ) ) { cleanDirectoryOnExit ( directory ) ; } } private static void cleanDirectoryOnExit ( final File directory ) throws IOException {
public static void moveDirectoryToDirectory ( final File src , final File destDir , final boolean createDestDir ) throws IOException { validateMoveParameters ( src , destDir ) ; if ( ! destDir . exists () && createDestDir ) { MST[NegateConditionalsMutator]MSP[S] destDir . mkdirs () ; }
public static String getTempDirectoryPath () { return System . getProperty ( lr_3 ) ; MST[ArgumentPropagationMutator]MSP[N] } public static File getTempDirectory () { return new File ( getTempDirectoryPath () ) ; } public static String getUserDirectoryPath () { return System . getProperty ( lr_4 ) ; }
if ( file == null ) { return false ; } try { if ( file . isDirectory () ) { MST[rv.ROR2Mutator]MSP[S] cleanDirectory ( file ) ; } } catch ( final Exception ignored ) { } try { return file . delete () ;
throw new IOException ( lr_27 + destFile + lr_6 ) ; } final Path srcPath = srcFile . toPath () ; MST[NonVoidMethodCallMutator]MSP[N] final Path destPath = destFile . toPath () ; final long newLastModifed = preserveFileDate ? srcFile . lastModified () : destFile . lastModified () ;
try ( InputStream in = new CheckedInputStream ( new FileInputStream ( file ) , checksum ) ) { MST[ConstructorCallMutator]MSP[N] IOUtils . copy ( in , new NullOutputStream () ) ; } return checksum ; } public static void moveDirectory ( final File srcDir , final File destDir ) throws IOException {
final File dstFile = new File ( destDir , srcFile . getName () ) ; if ( exclusionList == null || ! exclusionList . contains ( srcFile . getCanonicalPath () ) ) { MST[NonVoidMethodCallMutator]MSP[S] if ( srcFile . isDirectory () ) {
final int connectionTimeout , final int readTimeout ) throws IOException { final URLConnection connection = source . openConnection () ; connection . setConnectTimeout ( connectionTimeout ) ; connection . setReadTimeout ( readTimeout ) ; MST[rv.UOI3Mutator]MSP[N] copyInputStreamToFile ( connection . getInputStream () , destination ) ; }
if ( file . exists () ) { if ( file . isDirectory () ) { MST[NonVoidMethodCallMutator]MSP[N] throw new IOException ( lr_5 + file + lr_6 ) ; } if ( file . canWrite () == false ) { throw new IOException ( lr_5 + file + lr_9 ) ; }
if ( srcFile . getCanonicalPath () . equals ( destFile . getCanonicalPath () ) ) { throw new IOException ( lr_29 + srcFile + lr_30 + destFile + lr_31 ) ; MST[NonVoidMethodCallMutator]MSP[S] } final File parentFile = destFile . getParentFile () ; if ( parentFile != null ) {
validateMoveParameters ( srcDir , destDir ) ; if ( ! srcDir . isDirectory () ) { throw new IOException ( lr_29 + srcDir + lr_28 ) ; } if ( destDir . exists () ) { throw new FileExistsException ( lr_27 + destDir + lr_60 ) ; MST[ConstructorCallMutator]MSP[S] }
public static void write ( final File file , final CharSequence data , final String encoding ) throws IOException { write ( file , data , encoding , false ) ; MST[rv.CRCR5Mutator]MSP[N] }
throw new IllegalArgumentException ( lr_20 + directory ) ; } if ( fileFilter == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] throw new NullPointerException ( lr_21 ) ; } } private static IOFileFilter setUpEffectiveFileFilter ( final IOFileFilter fileFilter ) {
throw new IOException ( lr_23 ) ; } if ( file1 . getCanonicalFile () . equals ( file2 . getCanonicalFile () ) ) { MST[rv.ROR4Mutator]MSP[N] return true ; } try ( Reader input1 = charsetName == null
throw new IllegalArgumentException ( lr_58 ) ; } if ( ! file . exists () ) { return false ; } return file . lastModified () < timeMillis ; } public static long checksumCRC32 ( final File file ) throws IOException { final CRC32 crc = new CRC32 () ; MST[ConstructorCallMutator]MSP[S]
final String [] suffixes = new String [ extensions . length ] ; for ( int i = 0 ; i < extensions . length ; i ++ ) { suffixes [ i ] = lr_22 + extensions [ i ] ; MST[experimental.NakedReceiverMutator]MSP[N] } return suffixes ; }
throw new IOException ( lr_29 + srcFile + lr_69 ) ; } if ( destFile . exists () ) { throw new FileExistsException ( lr_27 + destFile + lr_60 ) ; MST[NonVoidMethodCallMutator]MSP[N] } if ( destFile . isDirectory () ) {
final File directory , final IOFileFilter fileFilter , final IOFileFilter dirFilter ) { return innerListFilesOrDirectories ( directory , fileFilter , dirFilter , false ) ; MST[InlineConstantMutator]MSP[N] } private static void validateListFilesParameters ( final File directory , final IOFileFilter fileFilter ) { if ( ! directory . isDirectory () ) {
if ( ! destDir . isDirectory () ) { MST[rv.ROR5Mutator]MSP[N] throw new IOException ( lr_27 + destDir + lr_28 ) ; } moveFile ( srcFile , new File ( destDir , srcFile . getName () ) ) ; }
if ( srcLen != dstLen ) { throw new IOException ( lr_34 + srcFile + lr_35 + destFile MST[NonVoidMethodCallMutator]MSP[S] + lr_36 + srcLen + lr_37 + dstLen ) ; } } public static void copyDirectoryToDirectory ( final File srcDir , final File destDir ) throws IOException {
throw new NullPointerException ( lr_26 ) ; } if ( ! src . exists () ) { throw new FileNotFoundException ( lr_29 + src + lr_8 ) ; MST[experimental.NakedReceiverMutator]MSP[N] } } public static boolean isSymlink ( final File file ) { if ( file == null ) {
displaySize = String . valueOf ( size . divide ( ONE_TB_BI ) ) + lr_14 ; MST[experimental.NakedReceiverMutator]MSP[N] } else if ( size . divide ( ONE_GB_BI ) . compareTo ( BigInteger . ZERO ) > 0 ) {
} public static File [] toFiles ( final URL [] urls ) { if ( urls == null || urls . length == 0 ) { MST[NegateConditionalsMutator]MSP[N] return EMPTY_FILE_ARRAY ; } final File [] files = new File [ urls . length ] ;
return isFileNewer ( file , reference . lastModified () ) ; MST[BooleanTrueReturnValsMutator]MSP[N] } public static boolean isFileNewer ( final File file , final Date date ) { if ( date == null ) { throw new IllegalArgumentException ( lr_57 ) ; }
public static void copyDirectory ( final File srcDir , final File destDir , final boolean preserveFileDate ) throws IOException { copyDirectory ( srcDir , destDir , null , preserveFileDate ) ; MST[rv.UOI2Mutator]MSP[N] } public static void copyDirectory ( final File srcDir , final File destDir ,
public static void moveToDirectory ( final File src , final File destDir , final boolean createDestDir ) throws IOException { validateMoveParameters ( src , destDir ) ; if ( src . isDirectory () ) { moveDirectoryToDirectory ( src , destDir , createDestDir ) ; MST[rv.UOI4Mutator]MSP[N] } else {
return FileFilterUtils . and ( fileFilter , FileFilterUtils . notFileFilter ( DirectoryFileFilter . INSTANCE ) ) ; } private static IOFileFilter setUpEffectiveDirFilter ( final IOFileFilter dirFilter ) { return dirFilter == null ? FalseFileFilter . INSTANCE : FileFilterUtils . and ( dirFilter , MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] DirectoryFileFilter . INSTANCE ) ; }
throw new IOException ( lr_23 ) ; } if ( file1 . length () != file2 . length () ) { MST[rv.ROR2Mutator]MSP[N] return false ; } if ( file1 . getCanonicalFile () . equals ( file2 . getCanonicalFile () ) ) { return true ; }
private static void checkDirectory ( final File directory ) { if ( ! directory . exists () ) { throw new IllegalArgumentException ( directory + lr_42 ) ; } if ( ! directory . isDirectory () ) { throw new IllegalArgumentException ( directory + lr_47 ) ; MST[NonVoidMethodCallMutator]MSP[N] } }
final boolean rename = srcDir . renameTo ( destDir ) ; if ( ! rename ) { if ( destDir . getCanonicalPath () . startsWith ( srcDir . getCanonicalPath () + File . separator ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] throw new IOException ( lr_61 + srcDir + lr_62 + destDir ) ;
if ( url == null || ! lr_24 . equalsIgnoreCase ( url . getProtocol () ) ) { MST[NegateConditionalsMutator]MSP[N] return null ; } String filename = url . getFile () . replace ( '/' , File . separatorChar ) ; filename = decodeUrl ( filename ) ;
if ( ! destDir . isDirectory () ) { throw new IOException ( lr_27 + destDir + lr_28 ) ; MST[ConstructorCallMutator]MSP[S] } moveFile ( srcFile , new File ( destDir , srcFile . getName () ) ) ; }
return false ; } return file . lastModified () > timeMillis ; MST[rv.UOI3Mutator]MSP[N] } public static boolean isFileOlder ( final File file , final File reference ) { if ( reference == null ) { throw new IllegalArgumentException ( lr_54 ) ; }
final String [] suffixes = new String [ extensions . length ] ; for ( int i = 0 ; i < extensions . length ; i ++ ) { MST[rv.UOI2Mutator]MSP[N] suffixes [ i ] = lr_22 + extensions [ i ] ; } return suffixes ; }
public static BigInteger sizeOfAsBigInteger ( final File file ) { if ( ! file . exists () ) { final String message = file + lr_42 ; throw new IllegalArgumentException ( message ) ; } if ( file . isDirectory () ) { return sizeOfDirectoryBig0 ( file ) ; MST[NonVoidMethodCallMutator]MSP[N] }
validateMoveParameters ( srcDir , destDir ) ; if ( ! srcDir . isDirectory () ) { throw new IOException ( lr_29 + srcDir + lr_28 ) ; } if ( destDir . exists () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] throw new FileExistsException ( lr_27 + destDir + lr_60 ) ; }
final File directory , final IOFileFilter fileFilter , final IOFileFilter dirFilter ) { return innerListFilesOrDirectories ( directory , fileFilter , dirFilter , false ) ; } private static void validateListFilesParameters ( final File directory , final IOFileFilter fileFilter ) { if ( ! directory . isDirectory () ) { MST[rv.ROR2Mutator]MSP[N]
public static BigInteger sizeOfAsBigInteger ( final File file ) { if ( ! file . exists () ) { final String message = file + lr_42 ; throw new IllegalArgumentException ( message ) ; } if ( file . isDirectory () ) { MST[rv.ROR3Mutator]MSP[N] return sizeOfDirectoryBig0 ( file ) ; }
throw new IllegalArgumentException ( lr_58 ) ; } if ( ! file . exists () ) { return false ; } return file . lastModified () < timeMillis ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[S] } public static long checksumCRC32 ( final File file ) throws IOException { final CRC32 crc = new CRC32 () ;
} copyDirectory ( srcDir , destDir ) ; deleteDirectory ( srcDir ) ; MST[VoidMethodCallMutator]MSP[S] if ( srcDir . exists () ) { throw new IOException ( lr_63 + srcDir + lr_64 + destDir + lr_65 ) ; } } }
} else { final File parent = file . getParentFile () ; if ( parent != null ) { if ( ! parent . mkdirs () && ! parent . isDirectory () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] throw new IOException ( lr_10 + parent + lr_11 ) ; } } }
if ( ! srcDir . isDirectory () ) { throw new IOException ( lr_29 + srcDir + lr_39 ) ; } if ( srcDir . getCanonicalPath () . equals ( destDir . getCanonicalPath () ) ) { MST[rv.ROR1Mutator]MSP[N]
return false ; } return file . lastModified () > timeMillis ; MST[rv.ABSMutator]MSP[N] } public static boolean isFileOlder ( final File file , final File reference ) { if ( reference == null ) { throw new IllegalArgumentException ( lr_54 ) ; }
if ( url == null || ! lr_24 . equalsIgnoreCase ( url . getProtocol () ) ) { MST[rv.ROR5Mutator]MSP[N] return null ; } String filename = url . getFile () . replace ( '/' , File . separatorChar ) ; filename = decodeUrl ( filename ) ;
doCopyDirectory ( srcFile , dstFile , filter , preserveFileDate , exclusionList ) ; } else { doCopyFile ( srcFile , dstFile , preserveFileDate ) ; } } } if ( preserveFileDate ) { MST[rv.ROR1Mutator]MSP[S] destDir . setLastModified ( srcDir . lastModified () ) ; } }
} while ( i < n && url . charAt ( i ) == '%' ); MST[rv.UOI1Mutator]MSP[N] continue; } catch ( final RuntimeException e ) { } finally { if ( bytes . position () > 0 ) { bytes . flip () ;
if ( ! destDir . exists () ) { MST[rv.ROR4Mutator]MSP[N] throw new FileNotFoundException ( lr_66 + destDir + lr_67 + createDestDir + lr_68 ) ; } if ( ! destDir . isDirectory () ) { throw new IOException ( lr_27 + destDir + lr_28 ) ; }
throw new IllegalArgumentException ( lr_58 ) ; } if ( ! file . exists () ) { MST[rv.ROR3Mutator]MSP[N] return false ; } return file . lastModified () < timeMillis ; } public static long checksumCRC32 ( final File file ) throws IOException { final CRC32 crc = new CRC32 () ;
final boolean append ) throws IOException { writeStringToFile ( file , data , Charsets . toCharset ( encoding ) , append ) ; MST[rv.UOI1Mutator]MSP[N] } @Deprecated public static void writeStringToFile ( final File file , final String data ) throws IOException {
throw new IOException ( lr_29 + srcFile + lr_69 ) ; MST[NonVoidMethodCallMutator]MSP[S] } if ( destFile . exists () ) { throw new FileExistsException ( lr_27 + destFile + lr_60 ) ; } if ( destFile . isDirectory () ) {
throws IOException { final boolean file1Exists = file1 . exists () ; if ( file1Exists != file2 . exists () ) { MST[rv.ROR2Mutator]MSP[N] return false ; } if ( ! file1Exists ) { return true ; } if ( file1 . isDirectory () || file2 . isDirectory () ) {
size += sizeOf0 ( file ) ; if ( size < 0 ) { MST[ConditionalsBoundaryMutator]MSP[N] break; } } } return size ; } private static long sizeOf0 ( final File file ) { if ( file . isDirectory () ) { return sizeOfDirectory0 ( file ) ; }
writeByteArrayToFile ( file , data , 0 , data . length , append ) ; MST[VoidMethodCallMutator]MSP[N] } public static void writeByteArrayToFile ( final File file , final byte [] data , final int off , final int len ) throws IOException {
final boolean rename = srcDir . renameTo ( destDir ) ; if ( ! rename ) { if ( destDir . getCanonicalPath () . startsWith ( srcDir . getCanonicalPath () + File . separator ) ) { MST[ConstructorCallMutator]MSP[N] throw new IOException ( lr_61 + srcDir + lr_62 + destDir ) ;
final boolean file1Exists = file1 . exists () ; if ( file1Exists != file2 . exists () ) { return false ; } if ( ! file1Exists ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return true ; } if ( file1 . isDirectory () || file2 . isDirectory () ) {
return fileLength > 0 ? IOUtils . toByteArray ( in , fileLength ) : IOUtils . toByteArray ( in ) ; MST[rv.ROR1Mutator]MSP[N] } } public static List < String > readLines ( final File file , final Charset encoding ) throws IOException {
throw new IllegalArgumentException ( lr_25 + url ) ; } files [ i ] = toFile ( url ) ; MST[rv.UOI1Mutator]MSP[N] } } return files ; } public static URL [] toURLs ( final File [] files ) throws IOException {
throw new IOException ( lr_40 + directory ) ; } return files ; } public static boolean waitFor ( final File file , final int seconds ) { final long finishAt = System . currentTimeMillis () + ( seconds * 1000L ) ; MST[rv.AOD2Mutator]MSP[N] boolean wasInterrupted = false ; try {
throw new IOException ( lr_23 ) ; } if ( file1 . length () != file2 . length () ) { return false ; } if ( file1 . getCanonicalFile () . equals ( file2 . getCanonicalFile () ) ) { MST[NonVoidMethodCallMutator]MSP[N] return true ; }
throws IOException { final File [] srcFiles = filter == null ? srcDir . listFiles () : srcDir . listFiles ( filter ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( srcFiles == null ) { throw new IOException ( lr_40 + srcDir ) ; } if ( destDir . exists () ) {
final File [] files = directory . listFiles () ; if ( files == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return 0L ; } long size = 0 ; for ( final File file : files ) { if ( ! isSymlink ( file ) ) {
} while ( i < n && url . charAt ( i ) == '%' ); MST[rv.UOI4Mutator]MSP[N] continue; } catch ( final RuntimeException e ) { } finally { if ( bytes . position () > 0 ) { bytes . flip () ;
final String [] suffixes = new String [ extensions . length ] ; for ( int i = 0 ; i < extensions . length ; i ++ ) { MST[rv.UOI1Mutator]MSP[N] suffixes [ i ] = lr_22 + extensions [ i ] ; } return suffixes ; }
return new FileOutputStream ( file , append ) ; } public static String byteCountToDisplaySize ( final BigInteger size ) { String displaySize ; if ( size . divide ( ONE_EB_BI ) . compareTo ( BigInteger . ZERO ) > 0 ) { MST[rv.ROR3Mutator]MSP[N]
writeStringToFile ( file , data , Charset . defaultCharset () , false ) ; MST[rv.CRCR5Mutator]MSP[N] } @Deprecated public static void writeStringToFile ( final File file , final String data , final boolean append ) throws IOException { writeStringToFile ( file , data , Charset . defaultCharset () , append ) ;
size += sizeOf0 ( file ) ; if ( size < 0 ) { break; } } } return size ; MST[rv.UOI2Mutator]MSP[N] } private static long sizeOf0 ( final File file ) { if ( file . isDirectory () ) { return sizeOfDirectory0 ( file ) ; }
throw new NullPointerException ( lr_26 ) ; } if ( destDir . exists () && destDir . isDirectory () == false ) { MST[NonVoidMethodCallMutator]MSP[N] throw new IllegalArgumentException ( lr_27 + destDir + lr_28 ) ; }
} catch ( final Exception ignored ) { return false ; MST[InlineConstantMutator]MSP[S] } } public static boolean directoryContains ( final File directory , final File child ) throws IOException { if ( directory == null ) { throw new IllegalArgumentException ( lr_45 ) ; }
throw new IOException ( lr_5 + file + lr_6 ) ; MST[ConstructorCallMutator]MSP[S] } if ( file . canRead () == false ) { throw new IOException ( lr_5 + file + lr_7 ) ; } } else { throw new FileNotFoundException ( lr_5 + file + lr_8 ) ; }
try ( OutputStream out = openOutputStream ( destination ) ) { IOUtils . copy ( source , out ) ; } } public static void copyToDirectory ( final File src , final File destDir ) throws IOException { if ( src == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
while ( ! file . exists () ) { final long remaining = finishAt - System . currentTimeMillis () ; if ( remaining < 0 ) { return false ; } try { Thread . sleep ( Math . min ( 100 , remaining ) ) ; MST[InlineConstantMutator]MSP[N]
throw new IllegalArgumentException ( lr_58 ) ; } if ( ! file . exists () ) { return false ; MST[rv.CRCR3Mutator]MSP[S] } return file . lastModified () < timeMillis ; } public static long checksumCRC32 ( final File file ) throws IOException { final CRC32 crc = new CRC32 () ;
displaySize = String . valueOf ( size . divide ( ONE_PB_BI ) ) + lr_13 ; } else if ( size . divide ( ONE_TB_BI ) . compareTo ( BigInteger . ZERO ) > 0 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N]
size += sizeOf0 ( file ) ; if ( size < 0 ) { break; } } } return size ; } private static long sizeOf0 ( final File file ) { if ( file . isDirectory () ) { return sizeOfDirectory0 ( file ) ; MST[NonVoidMethodCallMutator]MSP[N] }
moveFileToDirectory ( src , destDir , createDestDir ) ; } } private static void validateMoveParameters ( final File src , final File dest ) throws FileNotFoundException { if ( src == null ) { MST[NegateConditionalsMutator]MSP[N] throw new NullPointerException ( lr_38 ) ; } if ( dest == null ) {
if ( files == null ) { return BigInteger . ZERO ; } BigInteger size = BigInteger . ZERO ; for ( final File file : files ) { if ( ! isSymlink ( file ) ) { size = size . add ( sizeOfBig0 ( file ) ) ; MST[experimental.BigIntegerMutator]MSP[N]
return false ; } return file . lastModified () > timeMillis ; MST[rv.UOI2Mutator]MSP[N] } public static boolean isFileOlder ( final File file , final File reference ) { if ( reference == null ) { throw new IllegalArgumentException ( lr_54 ) ; }
displaySize = String . valueOf ( size . divide ( ONE_GB_BI ) ) + lr_15 ; } else if ( size . divide ( ONE_MB_BI ) . compareTo ( BigInteger . ZERO ) > 0 ) { MST[ConditionalsBoundaryMutator]MSP[N]
return false ; } return file . lastModified () > timeMillis ; MST[InlineConstantMutator]MSP[N] } public static boolean isFileOlder ( final File file , final File reference ) { if ( reference == null ) { throw new IllegalArgumentException ( lr_54 ) ; }
if ( srcDir == null ) { throw new NullPointerException ( lr_38 ) ; } if ( srcDir . exists () && srcDir . isDirectory () == false ) { MST[rv.ROR2Mutator]MSP[N] throw new IllegalArgumentException ( lr_29 + destDir + lr_28 ) ; } if ( destDir == null ) {
throw new IOException ( lr_23 ) ; } if ( file1 . length () != file2 . length () ) { return false ; } if ( file1 . getCanonicalFile () . equals ( file2 . getCanonicalFile () ) ) { return true ; MST[rv.CRCR3Mutator]MSP[N] }
displaySize = String . valueOf ( size . divide ( ONE_GB_BI ) ) + lr_15 ; } else if ( size . divide ( ONE_MB_BI ) . compareTo ( BigInteger . ZERO ) > 0 ) { MST[NonVoidMethodCallMutator]MSP[N]
validateMoveParameters ( srcFile , destDir ) ; if ( ! destDir . exists () && createDestDir ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] destDir . mkdirs () ; } if ( ! destDir . exists () ) { throw new FileNotFoundException ( lr_66 + destDir + lr_67 + createDestDir + lr_68 ) ; }
doCopyDirectory ( srcFile , dstFile , filter , preserveFileDate , exclusionList ) ; } else { doCopyFile ( srcFile , dstFile , preserveFileDate ) ; MST[rv.UOI1Mutator]MSP[S] } } } if ( preserveFileDate ) { destDir . setLastModified ( srcDir . lastModified () ) ; } }
throw new IOException ( lr_23 ) ; } if ( file1 . length () != file2 . length () ) { return false ; } if ( file1 . getCanonicalFile () . equals ( file2 . getCanonicalFile () ) ) { MST[experimental.NakedReceiverMutator]MSP[N] return true ; }
} else { final File parent = file . getParentFile () ; if ( parent != null ) { if ( ! parent . mkdirs () && ! parent . isDirectory () ) { MST[rv.ROR4Mutator]MSP[N] throw new IOException ( lr_10 + parent + lr_11 ) ; } } }
public static void writeLines ( final File file , final String encoding , final Collection < ? > lines , final String lineEnding ) throws IOException { writeLines ( file , encoding , lines , lineEnding , false ) ; MST[InlineConstantMutator]MSP[N] }
try ( InputStream input1 = new FileInputStream ( file1 ) ; InputStream input2 = new FileInputStream ( file2 ) ) { return IOUtils . contentEquals ( input1 , input2 ) ; MST[rv.UOI2Mutator]MSP[N] } } public static boolean contentEqualsIgnoreEOL ( final File file1 , final File file2 , final String charsetName )
return fileLength > 0 ? IOUtils . toByteArray ( in , fileLength ) : IOUtils . toByteArray ( in ) ; MST[rv.UOI4Mutator]MSP[S] } } public static List < String > readLines ( final File file , final Charset encoding ) throws IOException {
while ( ! file . exists () ) { final long remaining = finishAt - System . currentTimeMillis () ; if ( remaining < 0 ) { return false ; MST[rv.CRCR6Mutator]MSP[N] } try { Thread . sleep ( Math . min ( 100 , remaining ) ) ;
size += sizeOf0 ( file ) ; if ( size < 0 ) { break; } } } return size ; MST[rv.ABSMutator]MSP[N] } private static long sizeOf0 ( final File file ) { if ( file . isDirectory () ) { return sizeOfDirectory0 ( file ) ; }
copyDirectory ( srcDir , new File ( destDir , srcDir . getName () ) , true ) ; MST[rv.CRCR2Mutator]MSP[N] } public static void copyDirectory ( final File srcDir , final File destDir ) throws IOException { copyDirectory ( srcDir , destDir , true ) ; }
copyDirectory ( srcDir , new File ( destDir , srcDir . getName () ) , true ) ; } public static void copyDirectory ( final File srcDir , final File destDir ) throws IOException { copyDirectory ( srcDir , destDir , true ) ; MST[rv.CRCR3Mutator]MSP[N] }
throw new IOException ( lr_40 + directory ) ; MST[ConstructorCallMutator]MSP[S] } return files ; } public static boolean waitFor ( final File file , final int seconds ) { final long finishAt = System . currentTimeMillis () + ( seconds * 1000L ) ; boolean wasInterrupted = false ; try {
moveFileToDirectory ( src , destDir , createDestDir ) ; } } private static void validateMoveParameters ( final File src , final File dest ) throws FileNotFoundException { if ( src == null ) { MST[rv.ROR5Mutator]MSP[N] throw new NullPointerException ( lr_38 ) ; } if ( dest == null ) {
for ( final File srcFile : srcFiles ) { MST[rv.UOI4Mutator]MSP[N] final File copiedFile = new File ( destDir , srcFile . getName () ) ; exclusionList . add ( copiedFile . getCanonicalPath () ) ; } } } doCopyDirectory ( srcDir , destDir , filter , preserveFileDate , exclusionList ) ;
public static void writeLines ( final File file , final String encoding , final Collection < ? > lines , final String lineEnding , final boolean append ) throws IOException { try ( OutputStream out = new BufferedOutputStream ( openOutputStream ( file , append ) ) ) { MST[rv.UOI4Mutator]MSP[N]
throw new IOException ( lr_27 + destDir + lr_32 ) ; } } if ( destDir . canWrite () == false ) { throw new IOException ( lr_27 + destDir + lr_9 ) ; } for ( final File srcFile : srcFiles ) { MST[rv.UOI2Mutator]MSP[N]
if ( files == null ) { return BigInteger . ZERO ; } BigInteger size = BigInteger . ZERO ; for ( final File file : files ) { if ( ! isSymlink ( file ) ) { size = size . add ( sizeOfBig0 ( file ) ) ; MST[NonVoidMethodCallMutator]MSP[N]
throw new IOException ( lr_23 ) ; } if ( file1 . length () != file2 . length () ) { return false ; } if ( file1 . getCanonicalFile () . equals ( file2 . getCanonicalFile () ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return true ; }
if ( ! reference . exists () ) { throw new IllegalArgumentException ( lr_55 MST[NonVoidMethodCallMutator]MSP[S] + reference + lr_56 ) ; } return isFileOlder ( file , reference . lastModified () ) ; } public static boolean isFileOlder ( final File file , final Date date ) {
validateMoveParameters ( srcFile , destDir ) ; if ( ! destDir . exists () && createDestDir ) { destDir . mkdirs () ; } if ( ! destDir . exists () ) { throw new FileNotFoundException ( lr_66 + destDir + MST[experimental.NakedReceiverMutator]MSP[N] lr_67 + createDestDir + lr_68 ) ; }
if ( srcLen != dstLen ) { throw new IOException ( lr_34 + srcFile + lr_35 + destFile MST[experimental.NakedReceiverMutator]MSP[N] + lr_36 + srcLen + lr_37 + dstLen ) ; } } public static void copyDirectoryToDirectory ( final File srcDir , final File destDir ) throws IOException {
if ( srcFile . getCanonicalPath () . equals ( destFile . getCanonicalPath () ) ) { throw new IOException ( lr_29 + srcFile + lr_30 + destFile + lr_31 ) ; MST[experimental.NakedReceiverMutator]MSP[N] } final File parentFile = destFile . getParentFile () ; if ( parentFile != null ) {
return isFileNewer ( file , date . getTime () ) ; } public static boolean isFileNewer ( final File file , final long timeMillis ) { if ( file == null ) { throw new IllegalArgumentException ( lr_58 ) ; } if ( ! file . exists () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
buffer . append ( StandardCharsets . UTF_8 . decode ( bytes ) . toString () ) ; MST[NonVoidMethodCallMutator]MSP[N] bytes . clear () ; } } } buffer . append ( url . charAt ( i ++ ) ) ; } decoded = buffer . toString () ; } return decoded ;
} } public static void forceDeleteOnExit ( final File file ) throws IOException { if ( file . isDirectory () ) { MST[rv.ROR1Mutator]MSP[S] deleteDirectoryOnExit ( file ) ; } else { file . deleteOnExit () ; } } private static void deleteDirectoryOnExit ( final File directory ) throws IOException {
return new FileOutputStream ( file , append ) ; MST[rv.UOI4Mutator]MSP[N] } public static String byteCountToDisplaySize ( final BigInteger size ) { String displaySize ; if ( size . divide ( ONE_EB_BI ) . compareTo ( BigInteger . ZERO ) > 0 ) {
copyDirectory ( srcDir , new File ( destDir , srcDir . getName () ) , true ) ; MST[InlineConstantMutator]MSP[N] } public static void copyDirectory ( final File srcDir , final File destDir ) throws IOException { copyDirectory ( srcDir , destDir , true ) ; }
displaySize = String . valueOf ( size . divide ( ONE_TB_BI ) ) + lr_14 ; MST[NonVoidMethodCallMutator]MSP[N] } else if ( size . divide ( ONE_GB_BI ) . compareTo ( BigInteger . ZERO ) > 0 ) {
return isFileNewer ( file , reference . lastModified () ) ; MST[NonVoidMethodCallMutator]MSP[N] } public static boolean isFileNewer ( final File file , final Date date ) { if ( date == null ) { throw new IllegalArgumentException ( lr_57 ) ; }
if ( destDir . isDirectory () == false ) { throw new IOException ( lr_27 + destDir + lr_39 ) ; MST[NonVoidMethodCallMutator]MSP[S] } } else { if ( ! destDir . mkdirs () && ! destDir . isDirectory () ) {
final File directory , final IOFileFilter fileFilter , final IOFileFilter dirFilter ) { return innerListFilesOrDirectories ( directory , fileFilter , dirFilter , false ) ; } private static void validateListFilesParameters ( final File directory , final IOFileFilter fileFilter ) { if ( ! directory . isDirectory () ) { MST[rv.ROR1Mutator]MSP[N]
if ( files == null ) { MST[rv.ROR5Mutator]MSP[N] return BigInteger . ZERO ; } BigInteger size = BigInteger . ZERO ; for ( final File file : files ) { if ( ! isSymlink ( file ) ) { size = size . add ( sizeOfBig0 ( file ) ) ;
final boolean success = file . setLastModified ( System . currentTimeMillis () ) ; if ( ! success ) { MST[rv.UOI3Mutator]MSP[N] throw new IOException ( lr_19 + file ) ; } } public static File [] convertFileCollectionToFileArray ( final Collection < File > files ) {
throws IOException { final boolean file1Exists = file1 . exists () ; if ( file1Exists != file2 . exists () ) { return false ; } if ( ! file1Exists ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] return true ; } if ( file1 . isDirectory () || file2 . isDirectory () ) {
if ( file == null ) { return false ; } try { if ( file . isDirectory () ) { cleanDirectory ( file ) ; } } catch ( final Exception ignored ) { } try { return file . delete () ; MST[ReturnValsMutator]MSP[S]
public static boolean isFileNewer ( final File file , final File reference ) { if ( reference == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] throw new IllegalArgumentException ( lr_54 ) ; } if ( ! reference . exists () ) { throw new IllegalArgumentException ( lr_55 + reference + lr_56 ) ; }
if ( ! destDir . exists () ) { throw new FileNotFoundException ( lr_66 + destDir + MST[ConstructorCallMutator]MSP[S] lr_67 + createDestDir + lr_68 ) ; } if ( ! destDir . isDirectory () ) { throw new IOException ( lr_27 + destDir + lr_28 ) ; }
if ( ! directory . exists () ) { return; } directory . deleteOnExit () ; if ( ! isSymlink ( directory ) ) { MST[rv.ROR2Mutator]MSP[S] cleanDirectoryOnExit ( directory ) ; } } private static void cleanDirectoryOnExit ( final File directory ) throws IOException {
Files . copy ( srcPath , destPath , StandardCopyOption . REPLACE_EXISTING ) ; MST[ArgumentPropagationMutator]MSP[N] checkEqualSizes ( srcFile , destFile , Files . size ( srcPath ) , Files . size ( destPath ) ) ;
final boolean file1Exists = file1 . exists () ; if ( file1Exists != file2 . exists () ) { MST[rv.UOI1Mutator]MSP[S] return false ; } if ( ! file1Exists ) { return true ; } if ( file1 . isDirectory () || file2 . isDirectory () ) {
if ( srcLen != dstLen ) { throw new IOException ( lr_34 + srcFile + lr_35 + destFile MST[rv.UOI2Mutator]MSP[N] + lr_36 + srcLen + lr_37 + dstLen ) ; } } public static void copyDirectoryToDirectory ( final File srcDir , final File destDir ) throws IOException {
throw new IOException ( lr_41 + src + lr_42 ) ; } } public static void copyToDirectory ( final Iterable < File > srcs , final File destDir ) throws IOException { if ( srcs == null ) { throw new NullPointerException ( lr_43 ) ; MST[ConstructorCallMutator]MSP[N] }
if ( null != exception ) { throw exception ; } } public static void forceMkdir ( final File directory ) throws IOException { if ( directory . exists () ) { MST[rv.ROR3Mutator]MSP[N] if ( ! directory . isDirectory () ) { final String message = lr_50 + directory + lr_51
public static File getUserDirectory () { return new File ( getUserDirectoryPath () ) ; } public static FileInputStream openInputStream ( final File file ) throws IOException { if ( file . exists () ) { MST[rv.ROR2Mutator]MSP[N] if ( file . isDirectory () ) {
final StringBuilder buffer = new StringBuilder () ; final ByteBuffer bytes = ByteBuffer . allocate ( n ) ; for ( int i = 0 ; i < n ; ) { if ( url . charAt ( i ) == '%' ) { MST[rv.UOI1Mutator]MSP[N] try { do {
if ( ! file . exists () ) { MST[rv.ROR4Mutator]MSP[S] final String message = file + lr_42 ; throw new IllegalArgumentException ( message ) ; } if ( file . isDirectory () ) { return sizeOfDirectory0 ( file ) ; } return file . length () ; }
public static File getFile ( final File directory , final String ... names ) { if ( directory == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] throw new NullPointerException ( lr_1 ) ; } if ( names == null ) { throw new NullPointerException ( lr_2 ) ; } File file = directory ;
} while ( i < n && url . charAt ( i ) == '%' ); continue; } catch ( final RuntimeException e ) { } finally { if ( bytes . position () > 0 ) { MST[rv.ROR2Mutator]MSP[N] bytes . flip () ;
} public static void copyFileToDirectory ( final File srcFile , final File destDir ) throws IOException { copyFileToDirectory ( srcFile , destDir , true ) ; MST[rv.CRCR5Mutator]MSP[N] } public static void copyFileToDirectory ( final File srcFile , final File destDir , final boolean preserveFileDate ) throws IOException {
if ( file . exists () ) { if ( file . isDirectory () ) { MST[rv.ROR1Mutator]MSP[N] throw new IOException ( lr_5 + file + lr_6 ) ; } if ( file . canWrite () == false ) { throw new IOException ( lr_5 + file + lr_9 ) ; }
return FileFilterUtils . and ( fileFilter , FileFilterUtils . notFileFilter ( DirectoryFileFilter . INSTANCE ) ) ; MST[NullReturnValsMutator]MSP[N] } private static IOFileFilter setUpEffectiveDirFilter ( final IOFileFilter dirFilter ) { return dirFilter == null ? FalseFileFilter . INSTANCE : FileFilterUtils . and ( dirFilter , DirectoryFileFilter . INSTANCE ) ; }
final int connectionTimeout , final int readTimeout ) throws IOException { final URLConnection connection = source . openConnection () ; connection . setConnectTimeout ( connectionTimeout ) ; connection . setReadTimeout ( readTimeout ) ; MST[rv.UOI4Mutator]MSP[N] copyInputStreamToFile ( connection . getInputStream () , destination ) ; }
for ( final String name : names ) { MST[rv.ABSMutator]MSP[S] file = new File ( file , name ) ; } return file ; } public static File getFile ( final String ... names ) { if ( names == null ) { throw new NullPointerException ( lr_2 ) ; }
public static void writeStringToFile ( final File file , final String data , final String encoding ) throws IOException { writeStringToFile ( file , data , encoding , false ) ; MST[rv.CRCR3Mutator]MSP[N] } public static void writeStringToFile ( final File file , final String data , final Charset encoding ,
} else { final File parent = file . getParentFile () ; if ( parent != null ) { if ( ! parent . mkdirs () && ! parent . isDirectory () ) { throw new IOException ( lr_10 + parent + lr_11 ) ; MST[NonVoidMethodCallMutator]MSP[S] } } }
if ( ! directory . isDirectory () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] final String message = directory + lr_47 ; throw new IllegalArgumentException ( message ) ; } final File [] files = directory . listFiles () ; if ( files == null ) {
writeLines ( file , null , lines , lineEnding , append ) ; MST[rv.UOI2Mutator]MSP[N] } public static void forceDelete ( final File file ) throws IOException { if ( file . isDirectory () ) { deleteDirectory ( file ) ; } else {
Files . copy ( srcPath , destPath , StandardCopyOption . REPLACE_EXISTING ) ; MST[rv.CRCR5Mutator]MSP[N] checkEqualSizes ( srcFile , destFile , Files . size ( srcPath ) , Files . size ( destPath ) ) ;
if ( null != exception ) { throw exception ; } } public static void forceMkdir ( final File directory ) throws IOException { if ( directory . exists () ) { if ( ! directory . isDirectory () ) { final String message = MST[NonVoidMethodCallMutator]MSP[S] lr_50 + directory + lr_51
if ( ! file . exists () ) { final String message = file + lr_42 ; throw new IllegalArgumentException ( message ) ; } if ( file . isDirectory () ) { MST[rv.ROR5Mutator]MSP[N] return sizeOfDirectory0 ( file ) ; } return file . length () ; }
if ( date == null ) { throw new IllegalArgumentException ( lr_57 ) ; } return isFileOlder ( file , date . getTime () ) ; } public static boolean isFileOlder ( final File file , final long timeMillis ) { if ( file == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S]
throw new IOException ( lr_27 + destDir + lr_32 ) ; } } if ( destDir . canWrite () == false ) { MST[rv.ROR1Mutator]MSP[N] throw new IOException ( lr_27 + destDir + lr_9 ) ; } for ( final File srcFile : srcFiles ) {
final boolean filePresent = file . exists () ; if ( ! file . delete () ) { if ( ! filePresent ) { MST[rv.ROR5Mutator]MSP[N] throw new FileNotFoundException ( lr_48 + file ) ; } final String message = lr_49 + file ; throw new IOException ( message ) ; }
private static void checkDirectory ( final File directory ) { if ( ! directory . exists () ) { throw new IllegalArgumentException ( directory + lr_42 ) ; } if ( ! directory . isDirectory () ) { throw new IllegalArgumentException ( directory + lr_47 ) ; MST[ConstructorCallMutator]MSP[N] } }
validateMoveParameters ( srcFile , destDir ) ; if ( ! destDir . exists () && createDestDir ) { destDir . mkdirs () ; } if ( ! destDir . exists () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] throw new FileNotFoundException ( lr_66 + destDir + lr_67 + createDestDir + lr_68 ) ; }
public static String readFileToString ( final File file , final String encoding ) throws IOException { return readFileToString ( file , Charsets . toCharset ( encoding ) ) ; MST[EmptyObjectReturnValsMutator]MSP[N] } @Deprecated public static String readFileToString ( final File file ) throws IOException {
final File [] found = directory . listFiles ( ( FileFilter ) filter ) ; if ( found != null ) { for ( final File file : found ) { if ( file . isDirectory () ) { MST[NegateConditionalsMutator]MSP[N] if ( includeSubDirectories ) {
final FileFilter filter ) throws IOException { copyDirectory ( srcDir , destDir , filter , true ) ; MST[rv.CRCR4Mutator]MSP[N] } public static void copyDirectory ( final File srcDir , final File destDir , final FileFilter filter , final boolean preserveFileDate ) throws IOException { checkFileRequirements ( srcDir , destDir ) ;
final boolean rename = srcDir . renameTo ( destDir ) ; if ( ! rename ) { if ( destDir . getCanonicalPath () . startsWith ( srcDir . getCanonicalPath () + File . separator ) ) { throw new IOException ( lr_61 + srcDir + lr_62 + destDir ) ; MST[NonVoidMethodCallMutator]MSP[S]
if ( file == null ) { return false ; MST[rv.CRCR1Mutator]MSP[N] } try { if ( file . isDirectory () ) { cleanDirectory ( file ) ; } } catch ( final Exception ignored ) { } try { return file . delete () ;
throw new IOException ( lr_29 + srcDir + lr_30 + destDir + lr_31 ) ; } List < String > exclusionList = null ; if ( destDir . getCanonicalPath () . startsWith ( srcDir . getCanonicalPath () ) ) { MST[rv.ROR2Mutator]MSP[N]
final boolean rename = srcDir . renameTo ( destDir ) ; if ( ! rename ) { if ( destDir . getCanonicalPath () . startsWith ( srcDir . getCanonicalPath () + File . separator ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] throw new IOException ( lr_61 + srcDir + lr_62 + destDir ) ;
throw new IOException ( lr_40 + directory ) ; } return files ; } public static boolean waitFor ( final File file , final int seconds ) { final long finishAt = System . currentTimeMillis () + ( seconds * 1000L ) ; MST[rv.AOD1Mutator]MSP[N] boolean wasInterrupted = false ; try {
displaySize = String . valueOf ( size . divide ( ONE_MB_BI ) ) + lr_16 ; } else if ( size . divide ( ONE_KB_BI ) . compareTo ( BigInteger . ZERO ) > 0 ) { MST[NegateConditionalsMutator]MSP[N]
final int connectionTimeout , final int readTimeout ) throws IOException { final URLConnection connection = source . openConnection () ; MST[NonVoidMethodCallMutator]MSP[S] connection . setConnectTimeout ( connectionTimeout ) ; connection . setReadTimeout ( readTimeout ) ; copyInputStreamToFile ( connection . getInputStream () , destination ) ; }
return byteCountToDisplaySize ( BigInteger . valueOf ( size ) ) ; } public static void touch ( final File file ) throws IOException { if ( ! file . exists () ) { openOutputStream ( file ) . close () ; MST[VoidMethodCallMutator]MSP[N] }
final boolean filePresent = file . exists () ; if ( ! file . delete () ) { if ( ! filePresent ) { MST[rv.UOI4Mutator]MSP[N] throw new FileNotFoundException ( lr_48 + file ) ; } final String message = lr_49 + file ; throw new IOException ( message ) ; }
throw new IOException ( lr_5 + file + lr_6 ) ; } if ( file . canRead () == false ) { throw new IOException ( lr_5 + file + lr_7 ) ; } } else { throw new FileNotFoundException ( lr_5 + file + lr_8 ) ; MST[NonVoidMethodCallMutator]MSP[N] }
} } return size ; } private static BigInteger sizeOfBig0 ( final File fileOrDir ) { if ( fileOrDir . isDirectory () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] return sizeOfDirectoryBig0 ( fileOrDir ) ; } return BigInteger . valueOf ( fileOrDir . length () ) ; }
validateMoveParameters ( srcFile , destDir ) ; if ( ! destDir . exists () && createDestDir ) { MST[rv.ROR2Mutator]MSP[N] destDir . mkdirs () ; } if ( ! destDir . exists () ) { throw new FileNotFoundException ( lr_66 + destDir + lr_67 + createDestDir + lr_68 ) ; }
final File [] srcFiles = filter == null ? srcDir . listFiles () : srcDir . listFiles ( filter ) ; if ( srcFiles != null && srcFiles . length > 0 ) { MST[rv.ROR5Mutator]MSP[S] exclusionList = new ArrayList <> ( srcFiles . length ) ;
throw new IllegalArgumentException ( MST[ConstructorCallMutator]MSP[S] lr_25 + url ) ; } files [ i ] = toFile ( url ) ; } } return files ; } public static URL [] toURLs ( final File [] files ) throws IOException {
throw new IOException ( lr_27 + destFile + lr_33 ) ; } doCopyFile ( srcFile , destFile , preserveFileDate ) ; MST[VoidMethodCallMutator]MSP[N] } public static long copyFile ( final File input , final OutputStream output ) throws IOException { try ( FileInputStream fis = new FileInputStream ( input ) ) {
throws IOException { final boolean file1Exists = file1 . exists () ; if ( file1Exists != file2 . exists () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] return false ; } if ( ! file1Exists ) { return true ; } if ( file1 . isDirectory () || file2 . isDirectory () ) {
throw new IOException ( lr_5 + file + lr_6 ) ; } if ( file . canRead () == false ) { MST[rv.ROR1Mutator]MSP[N] throw new IOException ( lr_5 + file + lr_7 ) ; } } else { throw new FileNotFoundException ( lr_5 + file + lr_8 ) ; }
writeLines ( file , encoding , lines , null , false ) ; MST[InlineConstantMutator]MSP[N] } public static void writeLines ( final File file , final String encoding , final Collection < ? > lines , final boolean append ) throws IOException {
final File [] found = directory . listFiles ( ( FileFilter ) filter ) ; if ( found != null ) { for ( final File file : found ) { if ( file . isDirectory () ) { if ( includeSubDirectories ) { MST[rv.ROR2Mutator]MSP[N]
return isFileNewer ( file , date . getTime () ) ; } public static boolean isFileNewer ( final File file , final long timeMillis ) { if ( file == null ) { throw new IllegalArgumentException ( lr_58 ) ; } if ( ! file . exists () ) { MST[NonVoidMethodCallMutator]MSP[N]
return false ; MST[rv.CRCR5Mutator]MSP[N] } return file . lastModified () > timeMillis ; } public static boolean isFileOlder ( final File file , final File reference ) { if ( reference == null ) { throw new IllegalArgumentException ( lr_54 ) ; }
displaySize = String . valueOf ( size . divide ( ONE_EB_BI ) ) + lr_12 ; MST[NonVoidMethodCallMutator]MSP[N] } else if ( size . divide ( ONE_PB_BI ) . compareTo ( BigInteger . ZERO ) > 0 ) {
if ( ! parentFile . mkdirs () && ! parentFile . isDirectory () ) { MST[rv.ROR3Mutator]MSP[N] throw new IOException ( lr_27 + parentFile + lr_32 ) ; } } if ( destFile . exists () && destFile . canWrite () == false ) {
if ( ! directory . isDirectory () ) { MST[rv.ROR1Mutator]MSP[N] throw new IllegalArgumentException ( lr_46 + directory ) ; } if ( child == null ) { return false ; } if ( ! directory . exists () || ! child . exists () ) { return false ; }
return false ; } return file . lastModified () > timeMillis ; MST[rv.ROR2Mutator]MSP[N] } public static boolean isFileOlder ( final File file , final File reference ) { if ( reference == null ) { throw new IllegalArgumentException ( lr_54 ) ; }
if ( srcLen != dstLen ) { MST[NegateConditionalsMutator]MSP[N] throw new IOException ( lr_34 + srcFile + lr_35 + destFile + lr_36 + srcLen + lr_37 + dstLen ) ; } } public static void copyDirectoryToDirectory ( final File srcDir , final File destDir ) throws IOException {
if ( srcLen != dstLen ) { throw new IOException ( lr_34 + srcFile + lr_35 + destFile MST[ConstructorCallMutator]MSP[S] + lr_36 + srcLen + lr_37 + dstLen ) ; } } public static void copyDirectoryToDirectory ( final File srcDir , final File destDir ) throws IOException {
return false ; } return file . lastModified () > timeMillis ; MST[BooleanTrueReturnValsMutator]MSP[N] } public static boolean isFileOlder ( final File file , final File reference ) { if ( reference == null ) { throw new IllegalArgumentException ( lr_54 ) ; }
} } return size ; MST[ReturnValsMutator]MSP[N] } private static BigInteger sizeOfBig0 ( final File fileOrDir ) { if ( fileOrDir . isDirectory () ) { return sizeOfDirectoryBig0 ( fileOrDir ) ; } return BigInteger . valueOf ( fileOrDir . length () ) ; }
return IOUtils . copyLarge ( fis , output ) ; } } private static void doCopyFile ( final File srcFile , final File destFile , final boolean preserveFileDate ) throws IOException { if ( destFile . exists () && destFile . isDirectory () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
final URL [] urls = new URL [ files . length ] ; for ( int i = 0 ; i < urls . length ; i ++ ) { urls [ i ] = files [ i ] . toURI () . toURL () ; MST[rv.ABSMutator]MSP[S] } return urls ;
: new InputStreamReader ( new FileInputStream ( file2 ) , charsetName ) ) { return IOUtils . contentEqualsIgnoreEOL ( input1 , input2 ) ; MST[BooleanFalseReturnValsMutator]MSP[S] } } public static File toFile ( final URL url ) {
throw new IOException ( lr_27 + destDir + lr_32 ) ; } } if ( destDir . canWrite () == false ) { throw new IOException ( lr_27 + destDir + lr_9 ) ; } for ( final File srcFile : srcFiles ) { MST[rv.ABSMutator]MSP[N]
return isFileNewer ( file , date . getTime () ) ; } public static boolean isFileNewer ( final File file , final long timeMillis ) { if ( file == null ) { throw new IllegalArgumentException ( lr_58 ) ; } if ( ! file . exists () ) { MST[rv.ROR5Mutator]MSP[N]
if ( ! directory . isDirectory () ) { final String message = directory + lr_47 ; MST[NonVoidMethodCallMutator]MSP[N] throw new IllegalArgumentException ( message ) ; } final File [] files = directory . listFiles () ; if ( files == null ) {
throw new IllegalArgumentException ( lr_58 ) ; } if ( ! file . exists () ) { return false ; } return file . lastModified () < timeMillis ; MST[rv.CRCR2Mutator]MSP[S] } public static long checksumCRC32 ( final File file ) throws IOException { final CRC32 crc = new CRC32 () ;
displaySize = String . valueOf ( size . divide ( ONE_GB_BI ) ) + lr_15 ; MST[experimental.NakedReceiverMutator]MSP[N] } else if ( size . divide ( ONE_MB_BI ) . compareTo ( BigInteger . ZERO ) > 0 ) {
public static void write ( final File file , final CharSequence data , final Charset encoding , final boolean append ) throws IOException { final String str = data == null ? null : data . toString () ; writeStringToFile ( file , str , encoding , append ) ; MST[rv.UOI4Mutator]MSP[N]
public static boolean isFileNewer ( final File file , final File reference ) { if ( reference == null ) { throw new IllegalArgumentException ( lr_54 ) ; } if ( ! reference . exists () ) { throw new IllegalArgumentException ( lr_55 MST[NonVoidMethodCallMutator]MSP[S] + reference + lr_56 ) ; }
: new InputStreamReader ( new FileInputStream ( file2 ) , charsetName ) ) { return IOUtils . contentEqualsIgnoreEOL ( input1 , input2 ) ; MST[NonVoidMethodCallMutator]MSP[S] } } public static File toFile ( final URL url ) {
FileUtils . deleteQuietly ( destFile ) ; throw new IOException ( lr_70 + srcFile + MST[ConstructorCallMutator]MSP[S] lr_64 + destFile + lr_65 ) ; } } } public static void moveFileToDirectory ( final File srcFile , final File destDir , final boolean createDestDir ) throws IOException {
throw new IOException ( lr_27 + destFile + lr_33 ) ; } doCopyFile ( srcFile , destFile , preserveFileDate ) ; } public static long copyFile ( final File input , final OutputStream output ) throws IOException { try ( FileInputStream fis = new FileInputStream ( input ) ) { MST[ConstructorCallMutator]MSP[S]
File file = null ; for ( final String name : names ) { MST[rv.UOI3Mutator]MSP[S] if ( file == null ) { file = new File ( name ) ; } else { file = new File ( file , name ) ; } } return file ; }
throw new IOException ( lr_5 + file + lr_6 ) ; MST[NonVoidMethodCallMutator]MSP[N] } if ( file . canRead () == false ) { throw new IOException ( lr_5 + file + lr_7 ) ; } } else { throw new FileNotFoundException ( lr_5 + file + lr_8 ) ; }
throw new IOException ( lr_27 + destFile + lr_6 ) ; } final Path srcPath = srcFile . toPath () ; final Path destPath = destFile . toPath () ; final long newLastModifed = preserveFileDate ? srcFile . lastModified () : destFile . lastModified () ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S]
throw new NullPointerException ( lr_26 ) ; } if ( destDir . exists () && destDir . isDirectory () == false ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] throw new IllegalArgumentException ( lr_27 + destDir + lr_28 ) ; }
if ( ! directory . isDirectory () ) { throw new IllegalArgumentException ( lr_46 + directory ) ; } if ( child == null ) { return false ; } if ( ! directory . exists () || ! child . exists () ) { MST[rv.ROR5Mutator]MSP[S] return false ; }
throw new IOException ( lr_23 ) ; } if ( file1 . length () != file2 . length () ) { return false ; } if ( file1 . getCanonicalFile () . equals ( file2 . getCanonicalFile () ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] return true ; }
if ( file . exists () ) { if ( file . isDirectory () ) { throw new IOException ( lr_5 + file + lr_6 ) ; MST[ConstructorCallMutator]MSP[S] } if ( file . canWrite () == false ) { throw new IOException ( lr_5 + file + lr_9 ) ; }
return IOUtils . copyLarge ( fis , output ) ; } } private static void doCopyFile ( final File srcFile , final File destFile , final boolean preserveFileDate ) throws IOException { if ( destFile . exists () && destFile . isDirectory () ) { MST[NonVoidMethodCallMutator]MSP[N]
public static void write ( final File file , final CharSequence data , final Charset encoding ) throws IOException { write ( file , data , encoding , false ) ; MST[rv.CRCR3Mutator]MSP[N] }
} private static void checkFileRequirements ( final File src , final File dest ) throws FileNotFoundException { if ( src == null ) { throw new NullPointerException ( lr_38 ) ; } if ( dest == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] throw new NullPointerException ( lr_26 ) ; }
return fileLength > 0 ? IOUtils . toByteArray ( in , fileLength ) : IOUtils . toByteArray ( in ) ; MST[rv.CRCR5Mutator]MSP[N] } } public static List < String > readLines ( final File file , final Charset encoding ) throws IOException {
if ( ! directory . isDirectory () ) { final String message = directory + lr_47 ; MST[experimental.NakedReceiverMutator]MSP[N] throw new IllegalArgumentException ( message ) ; } final File [] files = directory . listFiles () ; if ( files == null ) {
} catch ( final InterruptedException ignore ) { wasInterrupted = true ; MST[rv.CRCR2Mutator]MSP[S] } catch ( final Exception ex ) { break; } } } finally { if ( wasInterrupted ) { Thread . currentThread () . interrupt () ; } } return true ; }
final boolean success = file . setLastModified ( System . currentTimeMillis () ) ; if ( ! success ) { MST[rv.ROR4Mutator]MSP[N] throw new IOException ( lr_19 + file ) ; } } public static File [] convertFileCollectionToFileArray ( final Collection < File > files ) {
final String [] suffixes = new String [ extensions . length ] ; for ( int i = 0 ; i < extensions . length ; i ++ ) { suffixes [ i ] = lr_22 + extensions [ i ] ; MST[rv.UOI2Mutator]MSP[N] } return suffixes ; }
final byte octet = ( byte ) Integer . parseInt ( url . substring ( i + 1 , i + 3 ) , 16 ) ; MST[rv.AOR2Mutator]MSP[N] bytes . put ( octet ) ; i += 3 ;
if ( srcLen != dstLen ) { MST[rv.ROR5Mutator]MSP[N] throw new IOException ( lr_34 + srcFile + lr_35 + destFile + lr_36 + srcLen + lr_37 + dstLen ) ; } } public static void copyDirectoryToDirectory ( final File srcDir , final File destDir ) throws IOException {
return isFileNewer ( file , date . getTime () ) ; } public static boolean isFileNewer ( final File file , final long timeMillis ) { if ( file == null ) { throw new IllegalArgumentException ( lr_58 ) ; } if ( ! file . exists () ) { MST[NegateConditionalsMutator]MSP[N]
for ( int i = 0 ; i < urls . length ; i ++ ) { final URL url = urls [ i ] ; if ( url != null ) { if ( url . getProtocol () . equals ( lr_24 ) == false ) { MST[rv.ROR4Mutator]MSP[S]
writeByteArrayToFile ( file , data , off , len , false ) ; MST[rv.CRCR3Mutator]MSP[N] } public static void writeByteArrayToFile ( final File file , final byte [] data , final int off , final int len , final boolean append ) throws IOException {
public static String getTempDirectoryPath () { return System . getProperty ( lr_3 ) ; } public static File getTempDirectory () { return new File ( getTempDirectoryPath () ) ; } public static String getUserDirectoryPath () { return System . getProperty ( lr_4 ) ; MST[NonVoidMethodCallMutator]MSP[N] }
buffer . append ( StandardCharsets . UTF_8 . decode ( bytes ) . toString () ) ; MST[experimental.NakedReceiverMutator]MSP[N] bytes . clear () ; } } } buffer . append ( url . charAt ( i ++ ) ) ; } decoded = buffer . toString () ; } return decoded ;
public static void moveDirectoryToDirectory ( final File src , final File destDir , final boolean createDestDir ) throws IOException { validateMoveParameters ( src , destDir ) ; if ( ! destDir . exists () && createDestDir ) { MST[rv.ROR1Mutator]MSP[N] destDir . mkdirs () ; }
if ( file . exists () ) { if ( file . isDirectory () ) { throw new IOException ( lr_5 + file + lr_6 ) ; } if ( file . canWrite () == false ) { MST[rv.ROR4Mutator]MSP[N] throw new IOException ( lr_5 + file + lr_9 ) ; }
throw new IOException ( lr_27 + destDir + lr_32 ) ; } } if ( destDir . canWrite () == false ) { throw new IOException ( lr_27 + destDir + lr_9 ) ; } for ( final File srcFile : srcFiles ) { MST[rv.UOI3Mutator]MSP[N]
for ( int i = 0 ; i < urls . length ; i ++ ) { MST[rv.ROR4Mutator]MSP[N] final URL url = urls [ i ] ; if ( url != null ) { if ( url . getProtocol () . equals ( lr_24 ) == false ) {
public static void writeLines ( final File file , final Collection < ? > lines , final boolean append ) throws IOException { writeLines ( file , null , lines , null , append ) ; MST[rv.UOI4Mutator]MSP[N] }
writeByteArrayToFile ( file , data , off , len , false ) ; MST[rv.UOI2Mutator]MSP[N] } public static void writeByteArrayToFile ( final File file , final byte [] data , final int off , final int len , final boolean append ) throws IOException {
throws IOException { final boolean file1Exists = file1 . exists () ; if ( file1Exists != file2 . exists () ) { return false ; } if ( ! file1Exists ) { MST[rv.ROR2Mutator]MSP[S] return true ; } if ( file1 . isDirectory () || file2 . isDirectory () ) {
public static BigInteger sizeOfAsBigInteger ( final File file ) { if ( ! file . exists () ) { MST[rv.ROR3Mutator]MSP[N] final String message = file + lr_42 ; throw new IllegalArgumentException ( message ) ; } if ( file . isDirectory () ) { return sizeOfDirectoryBig0 ( file ) ; }
final File [] found = directory . listFiles ( ( FileFilter ) filter ) ; if ( found != null ) { for ( final File file : found ) { if ( file . isDirectory () ) { MST[rv.ROR5Mutator]MSP[N] if ( includeSubDirectories ) {
throw new IOException ( lr_29 + srcDir + lr_30 + destDir + lr_31 ) ; } List < String > exclusionList = null ; if ( destDir . getCanonicalPath () . startsWith ( srcDir . getCanonicalPath () ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
final String [] suffixes = toSuffixes ( extensions ) ; filter = new SuffixFileFilter ( suffixes ) ; } return listFiles ( directory , filter , MST[rv.ROR3Mutator]MSP[N] recursive ? TrueFileFilter . INSTANCE : FalseFileFilter . INSTANCE ) ; } public static Iterator < File > iterateFiles (
throw new NullPointerException ( lr_26 ) ; } if ( destDir . exists () && destDir . isDirectory () == false ) { MST[rv.ROR4Mutator]MSP[N] throw new IllegalArgumentException ( lr_27 + destDir + lr_28 ) ; }
if ( ! destDir . exists () ) { throw new FileNotFoundException ( lr_66 + destDir + MST[NonVoidMethodCallMutator]MSP[S] lr_67 + createDestDir + lr_68 ) ; } if ( ! destDir . isDirectory () ) { throw new IOException ( lr_27 + destDir + lr_28 ) ; }
validateMoveParameters ( srcFile , destDir ) ; if ( ! destDir . exists () && createDestDir ) { destDir . mkdirs () ; } if ( ! destDir . exists () ) { MST[NonVoidMethodCallMutator]MSP[N] throw new FileNotFoundException ( lr_66 + destDir + lr_67 + createDestDir + lr_68 ) ; }
final boolean file1Exists = file1 . exists () ; if ( file1Exists != file2 . exists () ) { return false ; } if ( ! file1Exists ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] return true ; } if ( file1 . isDirectory () || file2 . isDirectory () ) {
} while ( i < n && url . charAt ( i ) == '%' ); continue; } catch ( final RuntimeException e ) { } finally { if ( bytes . position () > 0 ) { bytes . flip () ; MST[NonVoidMethodCallMutator]MSP[N]
throw new IllegalArgumentException ( lr_20 + directory ) ; } if ( fileFilter == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] throw new NullPointerException ( lr_21 ) ; } } private static IOFileFilter setUpEffectiveFileFilter ( final IOFileFilter fileFilter ) {
for ( final String name : names ) { MST[rv.UOI4Mutator]MSP[S] file = new File ( file , name ) ; } return file ; } public static File getFile ( final String ... names ) { if ( names == null ) { throw new NullPointerException ( lr_2 ) ; }
final boolean filePresent = file . exists () ; if ( ! file . delete () ) { if ( ! filePresent ) { throw new FileNotFoundException ( lr_48 + file ) ; } final String message = MST[experimental.NakedReceiverMutator]MSP[S] lr_49 + file ; throw new IOException ( message ) ; }
final File [] srcFiles = filter == null ? srcDir . listFiles () : srcDir . listFiles ( filter ) ; if ( srcFiles != null && srcFiles . length > 0 ) { MST[NegateConditionalsMutator]MSP[S] exclusionList = new ArrayList <> ( srcFiles . length ) ;
displaySize = String . valueOf ( size . divide ( ONE_MB_BI ) ) + lr_16 ; } else if ( size . divide ( ONE_KB_BI ) . compareTo ( BigInteger . ZERO ) > 0 ) { MST[rv.ROR5Mutator]MSP[N]
return file . length () ; } public static BigInteger sizeOfDirectoryAsBigInteger ( final File directory ) { checkDirectory ( directory ) ; return sizeOfDirectoryBig0 ( directory ) ; } private static BigInteger sizeOfDirectoryBig0 ( final File directory ) { final File [] files = directory . listFiles () ; MST[NonVoidMethodCallMutator]MSP[N]
if ( destDir == null ) { throw new NullPointerException ( lr_26 ) ; } if ( destDir . exists () && destDir . isDirectory () == false ) { MST[rv.ROR3Mutator]MSP[N] throw new IllegalArgumentException ( lr_27 + destDir + lr_28 ) ; }
if ( srcFile . getCanonicalPath () . equals ( destFile . getCanonicalPath () ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] throw new IOException ( lr_29 + srcFile + lr_30 + destFile + lr_31 ) ; } final File parentFile = destFile . getParentFile () ; if ( parentFile != null ) {
+ lr_52 ; throw new IOException ( message ) ; } } else { if ( ! directory . mkdirs () ) { MST[rv.ROR5Mutator]MSP[S] if ( ! directory . isDirectory () ) { final String message = lr_53 + directory ; throw new IOException ( message ) ; } } }
files . add ( file ) ; } innerListFiles ( files , file , filter , includeSubDirectories ) ; MST[rv.UOI3Mutator]MSP[N] } else { files . add ( file ) ; } } } } public static Collection < File > listFiles (
throw new NullPointerException ( lr_26 ) ; } if ( ! src . exists () ) { throw new FileNotFoundException ( lr_29 + src + lr_8 ) ; } } public static boolean isSymlink ( final File file ) { if ( file == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
size += sizeOf0 ( file ) ; MST[rv.AOD2Mutator]MSP[N] if ( size < 0 ) { break; } } } return size ; } private static long sizeOf0 ( final File file ) { if ( file . isDirectory () ) { return sizeOfDirectory0 ( file ) ; }
return readFileToString ( file , Charset . defaultCharset () ) ; } public static byte [] readFileToByteArray ( final File file ) throws IOException { try ( InputStream in = openInputStream ( file ) ) { MST[NonVoidMethodCallMutator]MSP[N] final long fileLength = file . length () ;
doCopyDirectory ( srcFile , dstFile , filter , preserveFileDate , exclusionList ) ; MST[rv.UOI1Mutator]MSP[S] } else { doCopyFile ( srcFile , dstFile , preserveFileDate ) ; } } } if ( preserveFileDate ) { destDir . setLastModified ( srcDir . lastModified () ) ; } }
if ( ! directory . isDirectory () ) { throw new IllegalArgumentException ( lr_46 + directory ) ; MST[ConstructorCallMutator]MSP[S] } if ( child == null ) { return false ; } if ( ! directory . exists () || ! child . exists () ) { return false ; }
if ( srcLen != dstLen ) { throw new IOException ( lr_34 + srcFile + lr_35 + destFile MST[NonVoidMethodCallMutator]MSP[S] + lr_36 + srcLen + lr_37 + dstLen ) ; } } public static void copyDirectoryToDirectory ( final File srcDir , final File destDir ) throws IOException {
final File [] files = directory . listFiles () ; if ( files == null ) { return 0L ; } long size = 0 ; for ( final File file : files ) { MST[rv.UOI3Mutator]MSP[N] if ( ! isSymlink ( file ) ) {
if ( ! srcDir . isDirectory () ) { MST[rv.ROR5Mutator]MSP[N] throw new IOException ( lr_29 + srcDir + lr_39 ) ; } if ( srcDir . getCanonicalPath () . equals ( destDir . getCanonicalPath () ) ) {
throw new IOException ( lr_23 ) ; } if ( file1 . length () != file2 . length () ) { return false ; MST[rv.CRCR6Mutator]MSP[N] } if ( file1 . getCanonicalFile () . equals ( file2 . getCanonicalFile () ) ) { return true ; }
checksum ( file , crc ) ; return crc . getValue () ; } public static Checksum checksum ( final File file , final Checksum checksum ) throws IOException { if ( file . isDirectory () ) { MST[rv.ROR3Mutator]MSP[N] throw new IllegalArgumentException ( lr_59 ) ; }
throw new IOException ( lr_41 + src + lr_42 ) ; MST[NonVoidMethodCallMutator]MSP[S] } } public static void copyToDirectory ( final Iterable < File > srcs , final File destDir ) throws IOException { if ( srcs == null ) { throw new NullPointerException ( lr_43 ) ; }
if ( ! destDir . exists () ) { throw new FileNotFoundException ( lr_66 + destDir + lr_67 + createDestDir + lr_68 ) ; } if ( ! destDir . isDirectory () ) { throw new IOException ( lr_27 + destDir + lr_28 ) ; MST[experimental.NakedReceiverMutator]MSP[N] }
public static void copyDirectory ( final File srcDir , final File destDir , final boolean preserveFileDate ) throws IOException { copyDirectory ( srcDir , destDir , null , preserveFileDate ) ; MST[rv.ABSMutator]MSP[N] } public static void copyDirectory ( final File srcDir , final File destDir ,
final boolean filePresent = file . exists () ; if ( ! file . delete () ) { if ( ! filePresent ) { throw new FileNotFoundException ( lr_48 + file ) ; } final String message = lr_49 + file ; throw new IOException ( message ) ; MST[ConstructorCallMutator]MSP[S] }
if ( srcDir == null ) { MST[rv.ROR5Mutator]MSP[N] throw new NullPointerException ( lr_38 ) ; } if ( srcDir . exists () && srcDir . isDirectory () == false ) { throw new IllegalArgumentException ( lr_29 + destDir + lr_28 ) ; } if ( destDir == null ) {
throw new IOException ( lr_5 + file + lr_6 ) ; MST[ConstructorCallMutator]MSP[S] } if ( file . canRead () == false ) { throw new IOException ( lr_5 + file + lr_7 ) ; } } else { throw new FileNotFoundException ( lr_5 + file + lr_8 ) ; }
public static BigInteger sizeOfAsBigInteger ( final File file ) { if ( ! file . exists () ) { final String message = file + lr_42 ; throw new IllegalArgumentException ( message ) ; } if ( file . isDirectory () ) { MST[rv.ROR4Mutator]MSP[N] return sizeOfDirectoryBig0 ( file ) ; }
displaySize = String . valueOf ( size . divide ( ONE_MB_BI ) ) + lr_16 ; } else if ( size . divide ( ONE_KB_BI ) . compareTo ( BigInteger . ZERO ) > 0 ) { MST[NonVoidMethodCallMutator]MSP[N]
if ( ! srcDir . isDirectory () ) { MST[rv.ROR1Mutator]MSP[N] throw new IOException ( lr_29 + srcDir + lr_39 ) ; } if ( srcDir . getCanonicalPath () . equals ( destDir . getCanonicalPath () ) ) {
if ( ! reference . exists () ) { MST[rv.ROR2Mutator]MSP[S] throw new IllegalArgumentException ( lr_55 + reference + lr_56 ) ; } return isFileOlder ( file , reference . lastModified () ) ; } public static boolean isFileOlder ( final File file , final Date date ) {
return byteCountToDisplaySize ( BigInteger . valueOf ( size ) ) ; } public static void touch ( final File file ) throws IOException { if ( ! file . exists () ) { MST[rv.ROR3Mutator]MSP[N] openOutputStream ( file ) . close () ; }
throws IOException { final boolean file1Exists = file1 . exists () ; if ( file1Exists != file2 . exists () ) { MST[rv.UOI2Mutator]MSP[S] return false ; } if ( ! file1Exists ) { return true ; } if ( file1 . isDirectory () || file2 . isDirectory () ) {
validateMoveParameters ( srcDir , destDir ) ; if ( ! srcDir . isDirectory () ) { throw new IOException ( lr_29 + srcDir + lr_28 ) ; MST[experimental.NakedReceiverMutator]MSP[N] } if ( destDir . exists () ) { throw new FileExistsException ( lr_27 + destDir + lr_60 ) ; }
throw new IOException ( lr_29 + srcFile + lr_69 ) ; } if ( destFile . exists () ) { throw new FileExistsException ( lr_27 + destFile + lr_60 ) ; MST[ConstructorCallMutator]MSP[S] } if ( destFile . isDirectory () ) {
final boolean success = file . setLastModified ( System . currentTimeMillis () ) ; if ( ! success ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] throw new IOException ( lr_19 + file ) ; } } public static File [] convertFileCollectionToFileArray ( final Collection < File > files ) {
validateMoveParameters ( srcDir , destDir ) ; if ( ! srcDir . isDirectory () ) { throw new IOException ( lr_29 + srcDir + lr_28 ) ; MST[NonVoidMethodCallMutator]MSP[S] } if ( destDir . exists () ) { throw new FileExistsException ( lr_27 + destDir + lr_60 ) ; }
throws IOException { final File [] srcFiles = filter == null ? srcDir . listFiles () : srcDir . listFiles ( filter ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] if ( srcFiles == null ) { throw new IOException ( lr_40 + srcDir ) ; } if ( destDir . exists () ) {
private static void checkDirectory ( final File directory ) { if ( ! directory . exists () ) { throw new IllegalArgumentException ( directory + lr_42 ) ; } if ( ! directory . isDirectory () ) { MST[rv.ROR1Mutator]MSP[N] throw new IllegalArgumentException ( directory + lr_47 ) ; } }
for ( final File srcFile : srcFiles ) { MST[rv.ABSMutator]MSP[N] final File copiedFile = new File ( destDir , srcFile . getName () ) ; exclusionList . add ( copiedFile . getCanonicalPath () ) ; } } } doCopyDirectory ( srcDir , destDir , filter , preserveFileDate , exclusionList ) ;
if ( ! destDir . exists () ) { throw new FileNotFoundException ( lr_66 + destDir + lr_67 + createDestDir + lr_68 ) ; } if ( ! destDir . isDirectory () ) { throw new IOException ( lr_27 + destDir + lr_28 ) ; MST[NonVoidMethodCallMutator]MSP[S] }
throw new IOException ( lr_40 + directory ) ; } return files ; } public static boolean waitFor ( final File file , final int seconds ) { final long finishAt = System . currentTimeMillis () + ( seconds * 1000L ) ; MST[rv.CRCR1Mutator]MSP[N] boolean wasInterrupted = false ; try {
throw new IllegalArgumentException ( lr_58 ) ; } if ( ! file . exists () ) { return false ; } return file . lastModified () < timeMillis ; MST[RemoveConditionalMutator_ORDER_IF]MSP[S] } public static long checksumCRC32 ( final File file ) throws IOException { final CRC32 crc = new CRC32 () ;
displaySize = String . valueOf ( size . divide ( ONE_TB_BI ) ) + lr_14 ; } else if ( size . divide ( ONE_GB_BI ) . compareTo ( BigInteger . ZERO ) > 0 ) { MST[ConditionalsBoundaryMutator]MSP[N]
throw new IllegalArgumentException ( lr_58 ) ; } if ( ! file . exists () ) { return false ; } return file . lastModified () < timeMillis ; MST[ReturnValsMutator]MSP[S] } public static long checksumCRC32 ( final File file ) throws IOException { final CRC32 crc = new CRC32 () ;
displaySize = String . valueOf ( size . divide ( ONE_TB_BI ) ) + lr_14 ; } else if ( size . divide ( ONE_GB_BI ) . compareTo ( BigInteger . ZERO ) > 0 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N]
if ( ! directory . isDirectory () ) { throw new IllegalArgumentException ( lr_46 + directory ) ; } if ( child == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] return false ; } if ( ! directory . exists () || ! child . exists () ) { return false ; }
return FileFilterUtils . and ( fileFilter , FileFilterUtils . notFileFilter ( DirectoryFileFilter . INSTANCE ) ) ; } private static IOFileFilter setUpEffectiveDirFilter ( final IOFileFilter dirFilter ) { return dirFilter == null ? FalseFileFilter . INSTANCE : FileFilterUtils . and ( dirFilter , MST[rv.CRCR3Mutator]MSP[N] DirectoryFileFilter . INSTANCE ) ; }
if ( ! parentFile . mkdirs () && ! parentFile . isDirectory () ) { throw new IOException ( lr_27 + parentFile + lr_32 ) ; } } if ( destFile . exists () && destFile . canWrite () == false ) { MST[NonVoidMethodCallMutator]MSP[N]
displaySize = String . valueOf ( size . divide ( ONE_EB_BI ) ) + lr_12 ; MST[experimental.NakedReceiverMutator]MSP[N] } else if ( size . divide ( ONE_PB_BI ) . compareTo ( BigInteger . ZERO ) > 0 ) {
if ( ! directory . isDirectory () ) { throw new IllegalArgumentException ( lr_46 + directory ) ; } if ( child == null ) { return false ; MST[rv.CRCR3Mutator]MSP[S] } if ( ! directory . exists () || ! child . exists () ) { return false ; }
displaySize = String . valueOf ( size . divide ( ONE_TB_BI ) ) + lr_14 ; } else if ( size . divide ( ONE_GB_BI ) . compareTo ( BigInteger . ZERO ) > 0 ) { MST[rv.ROR4Mutator]MSP[N]
final Collection < File > files = new java . util . LinkedList <> () ; if ( includeSubDirectories ) { files . add ( directory ) ; } innerListFiles ( files , directory , FileFilterUtils . or ( effFileFilter , effDirFilter ) , includeSubDirectories ) ; MST[NonVoidMethodCallMutator]MSP[N] return files ;
if ( srcDir == null ) { throw new NullPointerException ( lr_38 ) ; } if ( srcDir . exists () && srcDir . isDirectory () == false ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] throw new IllegalArgumentException ( lr_29 + destDir + lr_28 ) ; } if ( destDir == null ) {
final File destFile = new File ( destDir , srcFile . getName () ) ; copyFile ( srcFile , destFile , preserveFileDate ) ; } public static void copyFile ( final File srcFile , final File destFile ) throws IOException { copyFile ( srcFile , destFile , true ) ; MST[VoidMethodCallMutator]MSP[N]
public static void write ( final File file , final CharSequence data , final boolean append ) throws IOException { write ( file , data , Charset . defaultCharset () , append ) ; MST[VoidMethodCallMutator]MSP[N] }
moveFileToDirectory ( src , destDir , createDestDir ) ; } } private static void validateMoveParameters ( final File src , final File dest ) throws FileNotFoundException { if ( src == null ) { throw new NullPointerException ( lr_38 ) ; } if ( dest == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
public static String getTempDirectoryPath () { return System . getProperty ( lr_3 ) ; MST[ReturnValsMutator]MSP[N] } public static File getTempDirectory () { return new File ( getTempDirectoryPath () ) ; } public static String getUserDirectoryPath () { return System . getProperty ( lr_4 ) ; }
final File [] files = verifiedListFiles ( directory ) ; IOException exception = null ; for ( final File file : files ) { MST[rv.ABSMutator]MSP[N] try { forceDeleteOnExit ( file ) ; } catch ( final IOException ioe ) { exception = ioe ; } }
final URL [] urls = new URL [ files . length ] ; for ( int i = 0 ; i < urls . length ; i ++ ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] urls [ i ] = files [ i ] . toURI () . toURL () ; } return urls ;
while ( ! file . exists () ) { final long remaining = finishAt - System . currentTimeMillis () ; if ( remaining < 0 ) { MST[rv.CRCR3Mutator]MSP[N] return false ; } try { Thread . sleep ( Math . min ( 100 , remaining ) ) ;
final URL [] urls = new URL [ files . length ] ; for ( int i = 0 ; i < urls . length ; i ++ ) { MST[rv.UOI1Mutator]MSP[S] urls [ i ] = files [ i ] . toURI () . toURL () ; } return urls ;
throw new IOException ( lr_29 + srcDir + lr_30 + destDir + lr_31 ) ; MST[NonVoidMethodCallMutator]MSP[S] } List < String > exclusionList = null ; if ( destDir . getCanonicalPath () . startsWith ( srcDir . getCanonicalPath () ) ) {
displaySize = String . valueOf ( size . divide ( ONE_GB_BI ) ) + lr_15 ; MST[NonVoidMethodCallMutator]MSP[N] } else if ( size . divide ( ONE_MB_BI ) . compareTo ( BigInteger . ZERO ) > 0 ) {
if ( srcLen != dstLen ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] throw new IOException ( lr_34 + srcFile + lr_35 + destFile + lr_36 + srcLen + lr_37 + dstLen ) ; } } public static void copyDirectoryToDirectory ( final File srcDir , final File destDir ) throws IOException {
moveDirectory ( src , new File ( destDir , src . getName () ) ) ; } public static void moveFile ( final File srcFile , final File destFile ) throws IOException { validateMoveParameters ( srcFile , destFile ) ; if ( srcFile . isDirectory () ) { MST[rv.ROR2Mutator]MSP[N]
return BigInteger . valueOf ( file . length () ) ; } public static long sizeOfDirectory ( final File directory ) { checkDirectory ( directory ) ; return sizeOfDirectory0 ( directory ) ; MST[NonVoidMethodCallMutator]MSP[N] } private static long sizeOfDirectory0 ( final File directory ) {
for ( int i = 0 ; i < urls . length ; i ++ ) { final URL url = urls [ i ] ; if ( url != null ) { if ( url . getProtocol () . equals ( lr_24 ) == false ) { MST[NonVoidMethodCallMutator]MSP[N]
final File [] files = directory . listFiles () ; if ( files == null ) { return 0L ; } long size = 0 ; for ( final File file : files ) { if ( ! isSymlink ( file ) ) { MST[rv.ROR3Mutator]MSP[N]
} catch ( final InterruptedException ignore ) { wasInterrupted = true ; } catch ( final Exception ex ) { break; } } } finally { if ( wasInterrupted ) { MST[rv.ROR5Mutator]MSP[S] Thread . currentThread () . interrupt () ; } } return true ; }
public static void copyDirectory ( final File srcDir , final File destDir , final boolean preserveFileDate ) throws IOException { copyDirectory ( srcDir , destDir , null , preserveFileDate ) ; MST[rv.UOI1Mutator]MSP[N] } public static void copyDirectory ( final File srcDir , final File destDir ,
throws IOException { final boolean file1Exists = file1 . exists () ; if ( file1Exists != file2 . exists () ) { return false ; } if ( ! file1Exists ) { return true ; } if ( file1 . isDirectory () || file2 . isDirectory () ) { MST[rv.ROR5Mutator]MSP[S]
public static File getUserDirectory () { return new File ( getUserDirectoryPath () ) ; } public static FileInputStream openInputStream ( final File file ) throws IOException { if ( file . exists () ) { if ( file . isDirectory () ) { MST[NegateConditionalsMutator]MSP[N]
public static void write ( final File file , final CharSequence data , final boolean append ) throws IOException { write ( file , data , Charset . defaultCharset () , append ) ; MST[NonVoidMethodCallMutator]MSP[N] }
public static void writeByteArrayToFile ( final File file , final byte [] data ) throws IOException { writeByteArrayToFile ( file , data , false ) ; MST[rv.CRCR3Mutator]MSP[N] } public static void writeByteArrayToFile ( final File file , final byte [] data , final boolean append ) throws IOException {
return false ; } return file . lastModified () > timeMillis ; MST[rv.CRCR4Mutator]MSP[N] } public static boolean isFileOlder ( final File file , final File reference ) { if ( reference == null ) { throw new IllegalArgumentException ( lr_54 ) ; }
} while ( i < n && url . charAt ( i ) == '%' ); MST[rv.CRCR3Mutator]MSP[S] continue; } catch ( final RuntimeException e ) { } finally { if ( bytes . position () > 0 ) { bytes . flip () ;
public static void moveToDirectory ( final File src , final File destDir , final boolean createDestDir ) throws IOException { validateMoveParameters ( src , destDir ) ; MST[VoidMethodCallMutator]MSP[N] if ( src . isDirectory () ) { moveDirectoryToDirectory ( src , destDir , createDestDir ) ; } else {
throw new IOException ( lr_29 + srcDir + lr_30 + destDir + lr_31 ) ; } List < String > exclusionList = null ; if ( destDir . getCanonicalPath () . startsWith ( srcDir . getCanonicalPath () ) ) { MST[NonVoidMethodCallMutator]MSP[S]
if ( ! directory . isDirectory () ) { throw new IllegalArgumentException ( lr_46 + directory ) ; } if ( child == null ) { return false ; } if ( ! directory . exists () || ! child . exists () ) { return false ; MST[rv.CRCR6Mutator]MSP[N] }
while ( ! file . exists () ) { final long remaining = finishAt - System . currentTimeMillis () ; MST[rv.UOI4Mutator]MSP[N] if ( remaining < 0 ) { return false ; } try { Thread . sleep ( Math . min ( 100 , remaining ) ) ;
public static boolean isFileNewer ( final File file , final File reference ) { if ( reference == null ) { throw new IllegalArgumentException ( lr_54 ) ; } if ( ! reference . exists () ) { throw new IllegalArgumentException ( lr_55 MST[NonVoidMethodCallMutator]MSP[S] + reference + lr_56 ) ; }
displaySize = String . valueOf ( size . divide ( ONE_EB_BI ) ) + lr_12 ; } else if ( size . divide ( ONE_PB_BI ) . compareTo ( BigInteger . ZERO ) > 0 ) { MST[rv.ROR3Mutator]MSP[N]
if ( ! src . exists () ) { MST[rv.ROR3Mutator]MSP[N] throw new FileNotFoundException ( lr_29 + src + lr_8 ) ; } } private static void doCopyDirectory ( final File srcDir , final File destDir , final FileFilter filter , final boolean preserveFileDate , final List < String > exclusionList )
FileUtils . deleteQuietly ( destFile ) ; throw new IOException ( lr_70 + srcFile + MST[NonVoidMethodCallMutator]MSP[S] lr_64 + destFile + lr_65 ) ; } } } public static void moveFileToDirectory ( final File srcFile , final File destDir , final boolean createDestDir ) throws IOException {
throw new IOException ( lr_41 + src + lr_42 ) ; } } public static void copyToDirectory ( final Iterable < File > srcs , final File destDir ) throws IOException { if ( srcs == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] throw new NullPointerException ( lr_43 ) ; }
return new File ( filename ) ; } static String decodeUrl ( final String url ) { String decoded = url ; if ( url != null && url . indexOf ( '%' ) >= 0 ) { MST[NegateConditionalsMutator]MSP[N] final int n = url . length () ;
} while ( i < n && url . charAt ( i ) == '%' ); MST[rv.UOI3Mutator]MSP[N] continue; } catch ( final RuntimeException e ) { } finally { if ( bytes . position () > 0 ) { bytes . flip () ;
return fileLength > 0 ? IOUtils . toByteArray ( in , fileLength ) : IOUtils . toByteArray ( in ) ; MST[rv.UOI2Mutator]MSP[S] } } public static List < String > readLines ( final File file , final Charset encoding ) throws IOException {
if ( ! directory . exists () ) { return; } directory . deleteOnExit () ; if ( ! isSymlink ( directory ) ) { MST[NonVoidMethodCallMutator]MSP[S] cleanDirectoryOnExit ( directory ) ; } } private static void cleanDirectoryOnExit ( final File directory ) throws IOException {
final File [] files = verifiedListFiles ( directory ) ; IOException exception = null ; for ( final File file : files ) { MST[rv.UOI1Mutator]MSP[S] try { forceDeleteOnExit ( file ) ; } catch ( final IOException ioe ) { exception = ioe ; } }
final StringBuilder buffer = new StringBuilder () ; final ByteBuffer bytes = ByteBuffer . allocate ( n ) ; for ( int i = 0 ; i < n ; ) { if ( url . charAt ( i ) == '%' ) { MST[rv.CRCR3Mutator]MSP[N] try { do {
throws IOException { final File [] srcFiles = filter == null ? srcDir . listFiles () : srcDir . listFiles ( filter ) ; if ( srcFiles == null ) { throw new IOException ( lr_40 + srcDir ) ; } if ( destDir . exists () ) { MST[rv.ROR1Mutator]MSP[N]
final boolean file1Exists = file1 . exists () ; if ( file1Exists != file2 . exists () ) { return false ; } if ( ! file1Exists ) { return true ; } if ( file1 . isDirectory () || file2 . isDirectory () ) { MST[rv.ROR5Mutator]MSP[N]
public static String getTempDirectoryPath () { return System . getProperty ( lr_3 ) ; } public static File getTempDirectory () { return new File ( getTempDirectoryPath () ) ; MST[ReturnValsMutator]MSP[S] } public static String getUserDirectoryPath () { return System . getProperty ( lr_4 ) ; }
final String [] suffixes = new String [ extensions . length ] ; for ( int i = 0 ; i < extensions . length ; i ++ ) { MST[rv.ROR1Mutator]MSP[N] suffixes [ i ] = lr_22 + extensions [ i ] ; } return suffixes ; }
throw new IOException ( lr_5 + file + lr_6 ) ; MST[experimental.NakedReceiverMutator]MSP[N] } if ( file . canRead () == false ) { throw new IOException ( lr_5 + file + lr_7 ) ; } } else { throw new FileNotFoundException ( lr_5 + file + lr_8 ) ; }
if ( file == null ) { return false ; } try { if ( file . isDirectory () ) { MST[rv.ROR3Mutator]MSP[N] cleanDirectory ( file ) ; } } catch ( final Exception ignored ) { } try { return file . delete () ;
final byte octet = ( byte ) Integer . parseInt ( url . substring ( i + 1 , i + 3 ) , 16 ) ; MST[rv.UOI1Mutator]MSP[N] bytes . put ( octet ) ; i += 3 ;
private static void checkDirectory ( final File directory ) { if ( ! directory . exists () ) { throw new IllegalArgumentException ( directory + lr_42 ) ; MST[experimental.NakedReceiverMutator]MSP[N] } if ( ! directory . isDirectory () ) { throw new IllegalArgumentException ( directory + lr_47 ) ; } }
final File [] found = directory . listFiles ( ( FileFilter ) filter ) ; if ( found != null ) { for ( final File file : found ) { MST[rv.UOI1Mutator]MSP[N] if ( file . isDirectory () ) { if ( includeSubDirectories ) {
if ( ! srcDir . isDirectory () ) { MST[NegateConditionalsMutator]MSP[N] throw new IOException ( lr_29 + srcDir + lr_39 ) ; } if ( srcDir . getCanonicalPath () . equals ( destDir . getCanonicalPath () ) ) {
for ( final File src : srcs ) { copyFileToDirectory ( src , destDir ) ; } } public static void deleteDirectory ( final File directory ) throws IOException { if ( ! directory . exists () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return; } if ( ! isSymlink ( directory ) ) {
final File [] found = directory . listFiles ( ( FileFilter ) filter ) ; if ( found != null ) { for ( final File file : found ) { MST[rv.UOI4Mutator]MSP[N] if ( file . isDirectory () ) { if ( includeSubDirectories ) {
throw new IOException ( lr_29 + srcFile + lr_69 ) ; } if ( destFile . exists () ) { throw new FileExistsException ( lr_27 + destFile + lr_60 ) ; MST[experimental.NakedReceiverMutator]MSP[N] } if ( destFile . isDirectory () ) {
final boolean rename = srcDir . renameTo ( destDir ) ; if ( ! rename ) { MST[rv.ROR5Mutator]MSP[N] if ( destDir . getCanonicalPath () . startsWith ( srcDir . getCanonicalPath () + File . separator ) ) { throw new IOException ( lr_61 + srcDir + lr_62 + destDir ) ;
if ( ! parentFile . mkdirs () && ! parentFile . isDirectory () ) { MST[NegateConditionalsMutator]MSP[N] throw new IOException ( lr_27 + parentFile + lr_32 ) ; } } if ( destFile . exists () && destFile . canWrite () == false ) {
final boolean rename = srcDir . renameTo ( destDir ) ; if ( ! rename ) { if ( destDir . getCanonicalPath () . startsWith ( srcDir . getCanonicalPath () + File . separator ) ) { throw new IOException ( lr_61 + srcDir + lr_62 + destDir ) ; MST[ConstructorCallMutator]MSP[S]
displaySize = String . valueOf ( size . divide ( ONE_GB_BI ) ) + lr_15 ; MST[ConstructorCallMutator]MSP[N] } else if ( size . divide ( ONE_MB_BI ) . compareTo ( BigInteger . ZERO ) > 0 ) {
if ( srcDir == null ) { MST[NegateConditionalsMutator]MSP[N] throw new NullPointerException ( lr_38 ) ; } if ( srcDir . exists () && srcDir . isDirectory () == false ) { throw new IllegalArgumentException ( lr_29 + destDir + lr_28 ) ; } if ( destDir == null ) {
if ( ! destDir . exists () ) { throw new FileNotFoundException ( lr_66 + destDir + MST[rv.UOI4Mutator]MSP[N] lr_67 + createDestDir + lr_68 ) ; } if ( ! destDir . isDirectory () ) { throw new IOException ( lr_27 + destDir + lr_28 ) ; }
throw new IOException ( lr_23 ) ; } if ( file1 . getCanonicalFile () . equals ( file2 . getCanonicalFile () ) ) { MST[rv.ROR5Mutator]MSP[S] return true ; } try ( Reader input1 = charsetName == null
return new FileOutputStream ( file , append ) ; MST[rv.ABSMutator]MSP[N] } public static String byteCountToDisplaySize ( final BigInteger size ) { String displaySize ; if ( size . divide ( ONE_EB_BI ) . compareTo ( BigInteger . ZERO ) > 0 ) {
final String [] suffixes = new String [ extensions . length ] ; for ( int i = 0 ; i < extensions . length ; i ++ ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] suffixes [ i ] = lr_22 + extensions [ i ] ; } return suffixes ; }
final boolean file1Exists = file1 . exists () ; if ( file1Exists != file2 . exists () ) { return false ; } if ( ! file1Exists ) { return true ; } if ( file1 . isDirectory () || file2 . isDirectory () ) { MST[rv.ROR3Mutator]MSP[N]
final byte octet = ( byte ) Integer . parseInt ( url . substring ( i + 1 , i + 3 ) , 16 ) ; MST[rv.AOD1Mutator]MSP[N] bytes . put ( octet ) ; i += 3 ;
try ( InputStream in = new CheckedInputStream ( new FileInputStream ( file ) , checksum ) ) { IOUtils . copy ( in , new NullOutputStream () ) ; MST[NonVoidMethodCallMutator]MSP[N] } return checksum ; } public static void moveDirectory ( final File srcDir , final File destDir ) throws IOException {
if ( destDir . isDirectory () == false ) { throw new IOException ( lr_27 + destDir + lr_39 ) ; } } else { if ( ! destDir . mkdirs () && ! destDir . isDirectory () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
final File [] files = verifiedListFiles ( directory ) ; IOException exception = null ; for ( final File file : files ) { MST[rv.UOI2Mutator]MSP[S] try { forceDeleteOnExit ( file ) ; } catch ( final IOException ioe ) { exception = ioe ; } }
if ( destDir == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] throw new NullPointerException ( lr_26 ) ; } if ( destDir . exists () && destDir . isDirectory () == false ) { throw new IllegalArgumentException ( lr_27 + destDir + lr_28 ) ; }
writeLines ( file , encoding , lines , null , append ) ; } public static void writeLines ( final File file , final Collection < ? > lines ) throws IOException { writeLines ( file , null , lines , null , false ) ; MST[rv.CRCR6Mutator]MSP[N] }
throw new IOException ( lr_29 + srcFile + lr_69 ) ; } if ( destFile . exists () ) { MST[rv.ROR5Mutator]MSP[N] throw new FileExistsException ( lr_27 + destFile + lr_60 ) ; } if ( destFile . isDirectory () ) {
if ( null != exception ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] throw exception ; } } public static void forceMkdir ( final File directory ) throws IOException { if ( directory . exists () ) { if ( ! directory . isDirectory () ) { final String message = lr_50 + directory + lr_51
throw new NullPointerException ( lr_38 ) ; } if ( src . isFile () ) { MST[rv.ROR3Mutator]MSP[N] copyFileToDirectory ( src , destDir ) ; } else if ( src . isDirectory () ) { copyDirectoryToDirectory ( src , destDir ) ; } else {
writeByteArrayToFile ( file , data , off , len , false ) ; MST[rv.UOI3Mutator]MSP[S] } public static void writeByteArrayToFile ( final File file , final byte [] data , final int off , final int len , final boolean append ) throws IOException {
throws IOException { final boolean file1Exists = file1 . exists () ; if ( file1Exists != file2 . exists () ) { return false ; } if ( ! file1Exists ) { return true ; MST[rv.CRCR5Mutator]MSP[S] } if ( file1 . isDirectory () || file2 . isDirectory () ) {
if ( ! reference . exists () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] throw new IllegalArgumentException ( lr_55 + reference + lr_56 ) ; } return isFileOlder ( file , reference . lastModified () ) ; } public static boolean isFileOlder ( final File file , final Date date ) {
if ( file . exists () ) { if ( file . isDirectory () ) { throw new IOException ( lr_5 + file + lr_6 ) ; MST[experimental.NakedReceiverMutator]MSP[N] } if ( file . canWrite () == false ) { throw new IOException ( lr_5 + file + lr_9 ) ; }
throw new IOException ( lr_23 ) ; } if ( file1 . getCanonicalFile () . equals ( file2 . getCanonicalFile () ) ) { MST[NegateConditionalsMutator]MSP[S] return true ; } try ( Reader input1 = charsetName == null
if ( ! srcDir . isDirectory () ) { throw new IOException ( lr_29 + srcDir + lr_39 ) ; MST[experimental.NakedReceiverMutator]MSP[N] } if ( srcDir . getCanonicalPath () . equals ( destDir . getCanonicalPath () ) ) {
return fileLength > 0 ? IOUtils . toByteArray ( in , fileLength ) : IOUtils . toByteArray ( in ) ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] } } public static List < String > readLines ( final File file , final Charset encoding ) throws IOException {
throw new IOException ( lr_27 + destFile + lr_33 ) ; } doCopyFile ( srcFile , destFile , preserveFileDate ) ; MST[rv.UOI4Mutator]MSP[N] } public static long copyFile ( final File input , final OutputStream output ) throws IOException { try ( FileInputStream fis = new FileInputStream ( input ) ) {
displaySize = String . valueOf ( size . divide ( ONE_PB_BI ) ) + lr_13 ; MST[NonVoidMethodCallMutator]MSP[N] } else if ( size . divide ( ONE_TB_BI ) . compareTo ( BigInteger . ZERO ) > 0 ) {
throw new IOException ( lr_23 ) ; } if ( file1 . length () != file2 . length () ) { MST[rv.ROR3Mutator]MSP[N] return false ; } if ( file1 . getCanonicalFile () . equals ( file2 . getCanonicalFile () ) ) { return true ; }
return BigInteger . valueOf ( file . length () ) ; MST[ReturnValsMutator]MSP[S] } public static long sizeOfDirectory ( final File directory ) { checkDirectory ( directory ) ; return sizeOfDirectory0 ( directory ) ; } private static long sizeOfDirectory0 ( final File directory ) {
FileUtils . deleteQuietly ( destFile ) ; throw new IOException ( lr_70 + srcFile + MST[experimental.NakedReceiverMutator]MSP[N] lr_64 + destFile + lr_65 ) ; } } } public static void moveFileToDirectory ( final File srcFile , final File destDir , final boolean createDestDir ) throws IOException {
while ( ! file . exists () ) { final long remaining = finishAt - System . currentTimeMillis () ; if ( remaining < 0 ) { return false ; } try { Thread . sleep ( Math . min ( 100 , remaining ) ) ; MST[rv.CRCR5Mutator]MSP[N]
final File [] files = directory . listFiles () ; if ( files == null ) { return 0L ; } long size = 0 ; MST[rv.CRCR1Mutator]MSP[N] for ( final File file : files ) { if ( ! isSymlink ( file ) ) {
throw new IOException ( lr_29 + srcDir + lr_30 + destDir + lr_31 ) ; MST[ConstructorCallMutator]MSP[S] } List < String > exclusionList = null ; if ( destDir . getCanonicalPath () . startsWith ( srcDir . getCanonicalPath () ) ) {
validateMoveParameters ( srcDir , destDir ) ; if ( ! srcDir . isDirectory () ) { MST[rv.ROR3Mutator]MSP[N] throw new IOException ( lr_29 + srcDir + lr_28 ) ; } if ( destDir . exists () ) { throw new FileExistsException ( lr_27 + destDir + lr_60 ) ; }
if ( ! parentFile . mkdirs () && ! parentFile . isDirectory () ) { throw new IOException ( lr_27 + parentFile + lr_32 ) ; } } if ( destFile . exists () && destFile . canWrite () == false ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
if ( ! srcDir . isDirectory () ) { throw new IOException ( lr_29 + srcDir + lr_39 ) ; } if ( srcDir . getCanonicalPath () . equals ( destDir . getCanonicalPath () ) ) { MST[NonVoidMethodCallMutator]MSP[S]
if ( files == null ) { return BigInteger . ZERO ; } BigInteger size = BigInteger . ZERO ; for ( final File file : files ) { if ( ! isSymlink ( file ) ) { size = size . add ( sizeOfBig0 ( file ) ) ; MST[NonVoidMethodCallMutator]MSP[N]
final Collection < File > files = new java . util . LinkedList <> () ; if ( includeSubDirectories ) { files . add ( directory ) ; } innerListFiles ( files , directory , MST[rv.CRCR6Mutator]MSP[N] FileFilterUtils . or ( effFileFilter , effDirFilter ) , includeSubDirectories ) ; return files ;
throw new IOException ( lr_29 + srcFile + lr_69 ) ; } if ( destFile . exists () ) { MST[NegateConditionalsMutator]MSP[N] throw new FileExistsException ( lr_27 + destFile + lr_60 ) ; } if ( destFile . isDirectory () ) {
displaySize = String . valueOf ( size . divide ( ONE_EB_BI ) ) + lr_12 ; MST[ArgumentPropagationMutator]MSP[N] } else if ( size . divide ( ONE_PB_BI ) . compareTo ( BigInteger . ZERO ) > 0 ) {
throws IOException { final boolean file1Exists = file1 . exists () ; if ( file1Exists != file2 . exists () ) { return false ; } if ( ! file1Exists ) { return true ; } if ( file1 . isDirectory () || file2 . isDirectory () ) { MST[NegateConditionalsMutator]MSP[S]
if ( ! directory . isDirectory () ) { throw new IllegalArgumentException ( lr_46 + directory ) ; } if ( child == null ) { return false ; } if ( ! directory . exists () || ! child . exists () ) { MST[rv.ROR3Mutator]MSP[N] return false ; }
final URL [] urls = new URL [ files . length ] ; for ( int i = 0 ; i < urls . length ; i ++ ) { urls [ i ] = files [ i ] . toURI () . toURL () ; MST[rv.UOI2Mutator]MSP[S] } return urls ;
public static boolean isFileNewer ( final File file , final File reference ) { if ( reference == null ) { throw new IllegalArgumentException ( lr_54 ) ; } if ( ! reference . exists () ) { MST[rv.ROR4Mutator]MSP[S] throw new IllegalArgumentException ( lr_55 + reference + lr_56 ) ; }
writeLines ( file , null , lines , lineEnding , append ) ; MST[rv.ABSMutator]MSP[N] } public static void forceDelete ( final File file ) throws IOException { if ( file . isDirectory () ) { deleteDirectory ( file ) ; } else {
} public static void forceMkdirParent ( final File file ) throws IOException { final File parent = file . getParentFile () ; if ( parent == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] return; } forceMkdir ( parent ) ; } public static long sizeOf ( final File file ) {
if ( ! destDir . isDirectory () ) { MST[NonVoidMethodCallMutator]MSP[N] throw new IOException ( lr_27 + destDir + lr_28 ) ; } moveFile ( srcFile , new File ( destDir , srcFile . getName () ) ) ; }
throw new IOException ( lr_40 + directory ) ; } return files ; } public static boolean waitFor ( final File file , final int seconds ) { final long finishAt = System . currentTimeMillis () + ( seconds * 1000L ) ; boolean wasInterrupted = false ; MST[rv.CRCR3Mutator]MSP[N] try {
throw new IOException ( lr_23 ) ; } if ( file1 . getCanonicalFile () . equals ( file2 . getCanonicalFile () ) ) { return true ; MST[InlineConstantMutator]MSP[S] } try ( Reader input1 = charsetName == null
if ( files == null ) { return BigInteger . ZERO ; } BigInteger size = BigInteger . ZERO ; for ( final File file : files ) { if ( ! isSymlink ( file ) ) { size = size . add ( sizeOfBig0 ( file ) ) ; MST[ArgumentPropagationMutator]MSP[S]
final StringBuilder buffer = new StringBuilder () ; final ByteBuffer bytes = ByteBuffer . allocate ( n ) ; MST[NonVoidMethodCallMutator]MSP[N] for ( int i = 0 ; i < n ; ) { if ( url . charAt ( i ) == '%' ) { try { do {
if ( ! directory . isDirectory () ) { throw new IllegalArgumentException ( lr_46 + directory ) ; } if ( child == null ) { return false ; } if ( ! directory . exists () || ! child . exists () ) { return false ; MST[BooleanTrueReturnValsMutator]MSP[N] }
return FileFilterUtils . and ( fileFilter , FileFilterUtils . notFileFilter ( DirectoryFileFilter . INSTANCE ) ) ; } private static IOFileFilter setUpEffectiveDirFilter ( final IOFileFilter dirFilter ) { return dirFilter == null ? FalseFileFilter . INSTANCE : FileFilterUtils . and ( dirFilter , MST[rv.CRCR4Mutator]MSP[N] DirectoryFileFilter . INSTANCE ) ; }
if ( ! file . exists () ) { final String message = file + lr_42 ; throw new IllegalArgumentException ( message ) ; } if ( file . isDirectory () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return sizeOfDirectory0 ( file ) ; } return file . length () ; }
final boolean filePresent = file . exists () ; if ( ! file . delete () ) { if ( ! filePresent ) { MST[NegateConditionalsMutator]MSP[N] throw new FileNotFoundException ( lr_48 + file ) ; } final String message = lr_49 + file ; throw new IOException ( message ) ; }
public static void write ( final File file , final CharSequence data , final String encoding ) throws IOException { write ( file , data , encoding , false ) ; MST[rv.CRCR6Mutator]MSP[N] }
while ( ! file . exists () ) { MST[rv.ROR2Mutator]MSP[N] final long remaining = finishAt - System . currentTimeMillis () ; if ( remaining < 0 ) { return false ; } try { Thread . sleep ( Math . min ( 100 , remaining ) ) ;
throw new IOException ( lr_27 + destFile + lr_69 ) ; } final boolean rename = srcFile . renameTo ( destFile ) ; if ( ! rename ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] copyFile ( srcFile , destFile ) ; if ( ! srcFile . delete () ) {
return new File ( filename ) ; } static String decodeUrl ( final String url ) { String decoded = url ; if ( url != null && url . indexOf ( '%' ) >= 0 ) { MST[rv.ROR5Mutator]MSP[N] final int n = url . length () ;
final StringBuilder buffer = new StringBuilder () ; final ByteBuffer bytes = ByteBuffer . allocate ( n ) ; for ( int i = 0 ; i < n ; ) { if ( url . charAt ( i ) == '%' ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] try { do {
public static void writeLines ( final File file , final String encoding , final Collection < ? > lines , final String lineEnding ) throws IOException { writeLines ( file , encoding , lines , lineEnding , false ) ; MST[rv.CRCR5Mutator]MSP[N] }
if ( destDir . isDirectory () == false ) { MST[rv.ROR4Mutator]MSP[N] throw new IOException ( lr_27 + destDir + lr_39 ) ; } } else { if ( ! destDir . mkdirs () && ! destDir . isDirectory () ) {
final boolean rename = srcDir . renameTo ( destDir ) ; if ( ! rename ) { if ( destDir . getCanonicalPath () . startsWith ( srcDir . getCanonicalPath () + File . separator ) ) { throw new IOException ( lr_61 + srcDir + lr_62 + destDir ) ; MST[experimental.NakedReceiverMutator]MSP[N]
} while ( i < n && url . charAt ( i ) == '%' ); MST[rv.ROR4Mutator]MSP[N] continue; } catch ( final RuntimeException e ) { } finally { if ( bytes . position () > 0 ) { bytes . flip () ;
public static void writeLines ( final File file , final Collection < ? > lines , final boolean append ) throws IOException { writeLines ( file , null , lines , null , append ) ; MST[VoidMethodCallMutator]MSP[N] }
final File dstFile = new File ( destDir , srcFile . getName () ) ; if ( exclusionList == null || ! exclusionList . contains ( srcFile . getCanonicalPath () ) ) { if ( srcFile . isDirectory () ) { MST[rv.ROR1Mutator]MSP[N]
if ( ! parentFile . mkdirs () && ! parentFile . isDirectory () ) { MST[rv.ROR5Mutator]MSP[N] throw new IOException ( lr_27 + parentFile + lr_32 ) ; } } if ( destFile . exists () && destFile . canWrite () == false ) {
if ( srcDir == null ) { throw new NullPointerException ( lr_38 ) ; } if ( srcDir . exists () && srcDir . isDirectory () == false ) { MST[NonVoidMethodCallMutator]MSP[N] throw new IllegalArgumentException ( lr_29 + destDir + lr_28 ) ; } if ( destDir == null ) {
if ( file . exists () ) { if ( file . isDirectory () ) { throw new IOException ( lr_5 + file + lr_6 ) ; MST[ConstructorCallMutator]MSP[S] } if ( file . canWrite () == false ) { throw new IOException ( lr_5 + file + lr_9 ) ; }
throw new IOException ( lr_23 ) ; } if ( file1 . getCanonicalFile () . equals ( file2 . getCanonicalFile () ) ) { MST[experimental.NakedReceiverMutator]MSP[N] return true ; } try ( Reader input1 = charsetName == null
final StringBuilder buffer = new StringBuilder () ; final ByteBuffer bytes = ByteBuffer . allocate ( n ) ; for ( int i = 0 ; i < n ; ) { MST[rv.CRCR6Mutator]MSP[N] if ( url . charAt ( i ) == '%' ) { try { do {
final File destFile = new File ( destDir , srcFile . getName () ) ; copyFile ( srcFile , destFile , preserveFileDate ) ; MST[rv.ABSMutator]MSP[N] } public static void copyFile ( final File srcFile , final File destFile ) throws IOException { copyFile ( srcFile , destFile , true ) ;
final File [] found = directory . listFiles ( ( FileFilter ) filter ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( found != null ) { for ( final File file : found ) { if ( file . isDirectory () ) { if ( includeSubDirectories ) {
if ( srcFile . getCanonicalPath () . equals ( destFile . getCanonicalPath () ) ) { MST[NonVoidMethodCallMutator]MSP[S] throw new IOException ( lr_29 + srcFile + lr_30 + destFile + lr_31 ) ; } final File parentFile = destFile . getParentFile () ; if ( parentFile != null ) {
if ( files == null ) { return BigInteger . ZERO ; } BigInteger size = BigInteger . ZERO ; for ( final File file : files ) { MST[rv.UOI4Mutator]MSP[N] if ( ! isSymlink ( file ) ) { size = size . add ( sizeOfBig0 ( file ) ) ;
final boolean rename = srcDir . renameTo ( destDir ) ; if ( ! rename ) { MST[NegateConditionalsMutator]MSP[N] if ( destDir . getCanonicalPath () . startsWith ( srcDir . getCanonicalPath () + File . separator ) ) { throw new IOException ( lr_61 + srcDir + lr_62 + destDir ) ;
try ( InputStream input1 = new FileInputStream ( file1 ) ; InputStream input2 = new FileInputStream ( file2 ) ) { return IOUtils . contentEquals ( input1 , input2 ) ; MST[rv.ABSMutator]MSP[N] } } public static boolean contentEqualsIgnoreEOL ( final File file1 , final File file2 , final String charsetName )
throw new IOException ( lr_29 + srcFile + lr_69 ) ; } if ( destFile . exists () ) { throw new FileExistsException ( lr_27 + destFile + lr_60 ) ; } if ( destFile . isDirectory () ) { MST[rv.ROR1Mutator]MSP[N]
size += sizeOf0 ( file ) ; if ( size < 0 ) { break; } } } return size ; } private static long sizeOf0 ( final File file ) { if ( file . isDirectory () ) { MST[rv.ROR3Mutator]MSP[N] return sizeOfDirectory0 ( file ) ; }
if ( ! directory . exists () ) { return; } directory . deleteOnExit () ; if ( ! isSymlink ( directory ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] cleanDirectoryOnExit ( directory ) ; } } private static void cleanDirectoryOnExit ( final File directory ) throws IOException {
return readFileToString ( file , Charset . defaultCharset () ) ; MST[ReturnValsMutator]MSP[N] } public static byte [] readFileToByteArray ( final File file ) throws IOException { try ( InputStream in = openInputStream ( file ) ) { final long fileLength = file . length () ;
public static void moveToDirectory ( final File src , final File destDir , final boolean createDestDir ) throws IOException { validateMoveParameters ( src , destDir ) ; if ( src . isDirectory () ) { MST[rv.ROR4Mutator]MSP[S] moveDirectoryToDirectory ( src , destDir , createDestDir ) ; } else {
final boolean file1Exists = file1 . exists () ; if ( file1Exists != file2 . exists () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return false ; } if ( ! file1Exists ) { return true ; } if ( file1 . isDirectory () || file2 . isDirectory () ) {
if ( destDir == null ) { throw new NullPointerException ( lr_26 ) ; } if ( destDir . exists () && destDir . isDirectory () == false ) { MST[rv.ROR1Mutator]MSP[N] throw new IllegalArgumentException ( lr_27 + destDir + lr_28 ) ; }
final String canonicalParent = directory . getCanonicalPath () ; final String canonicalChild = child . getCanonicalPath () ; return FilenameUtils . directoryContains ( canonicalParent , canonicalChild ) ; MST[BooleanTrueReturnValsMutator]MSP[S] } public static void cleanDirectory ( final File directory ) throws IOException {
for ( final File srcFile : srcFiles ) { final File copiedFile = new File ( destDir , srcFile . getName () ) ; exclusionList . add ( copiedFile . getCanonicalPath () ) ; } } } doCopyDirectory ( srcDir , destDir , filter , preserveFileDate , exclusionList ) ; MST[rv.UOI2Mutator]MSP[N]
final String [] suffixes = toSuffixes ( extensions ) ; filter = new SuffixFileFilter ( suffixes ) ; } return listFiles ( directory , filter , MST[rv.ABSMutator]MSP[N] recursive ? TrueFileFilter . INSTANCE : FalseFileFilter . INSTANCE ) ; } public static Iterator < File > iterateFiles (
final byte octet = ( byte ) Integer . parseInt ( url . substring ( i + 1 , i + 3 ) , 16 ) ; MST[rv.CRCR2Mutator]MSP[N] bytes . put ( octet ) ; i += 3 ;
+ lr_52 ; throw new IOException ( message ) ; } } else { if ( ! directory . mkdirs () ) { MST[NegateConditionalsMutator]MSP[S] if ( ! directory . isDirectory () ) { final String message = lr_53 + directory ; throw new IOException ( message ) ; } } }
moveDirectory ( src , new File ( destDir , src . getName () ) ) ; } public static void moveFile ( final File srcFile , final File destFile ) throws IOException { validateMoveParameters ( srcFile , destFile ) ; if ( srcFile . isDirectory () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
validateMoveParameters ( srcFile , destDir ) ; if ( ! destDir . exists () && createDestDir ) { MST[rv.ROR3Mutator]MSP[N] destDir . mkdirs () ; } if ( ! destDir . exists () ) { throw new FileNotFoundException ( lr_66 + destDir + lr_67 + createDestDir + lr_68 ) ; }
final File [] found = directory . listFiles ( ( FileFilter ) filter ) ; if ( found != null ) { for ( final File file : found ) { MST[rv.ABSMutator]MSP[N] if ( file . isDirectory () ) { if ( includeSubDirectories ) {
final Collection < File > files = new java . util . LinkedList <> () ; if ( includeSubDirectories ) { files . add ( directory ) ; } innerListFiles ( files , directory , MST[InlineConstantMutator]MSP[N] FileFilterUtils . or ( effFileFilter , effDirFilter ) , includeSubDirectories ) ; return files ;
return lineIterator ( file , null ) ; } public static void writeStringToFile ( final File file , final String data , final Charset encoding ) throws IOException { writeStringToFile ( file , data , encoding , false ) ; MST[rv.CRCR6Mutator]MSP[N] }
public static void write ( final File file , final CharSequence data , final boolean append ) throws IOException { write ( file , data , Charset . defaultCharset () , append ) ; MST[rv.UOI4Mutator]MSP[N] }
final File destFile = new File ( destDir , srcFile . getName () ) ; copyFile ( srcFile , destFile , preserveFileDate ) ; } public static void copyFile ( final File srcFile , final File destFile ) throws IOException { copyFile ( srcFile , destFile , true ) ; MST[rv.CRCR5Mutator]MSP[N]
throw new IOException ( lr_41 + src + lr_42 ) ; MST[experimental.NakedReceiverMutator]MSP[N] } } public static void copyToDirectory ( final Iterable < File > srcs , final File destDir ) throws IOException { if ( srcs == null ) { throw new NullPointerException ( lr_43 ) ; }
return FileFilterUtils . and ( fileFilter , FileFilterUtils . notFileFilter ( DirectoryFileFilter . INSTANCE ) ) ; MST[rv.CRCR6Mutator]MSP[N] } private static IOFileFilter setUpEffectiveDirFilter ( final IOFileFilter dirFilter ) { return dirFilter == null ? FalseFileFilter . INSTANCE : FileFilterUtils . and ( dirFilter , DirectoryFileFilter . INSTANCE ) ; }
} catch ( final Exception ignored ) { return false ; } } public static boolean directoryContains ( final File directory , final File child ) throws IOException { if ( directory == null ) { MST[rv.ROR5Mutator]MSP[N] throw new IllegalArgumentException ( lr_45 ) ; }
} catch ( final InterruptedException ignore ) { wasInterrupted = true ; } catch ( final Exception ex ) { break; } } } finally { if ( wasInterrupted ) { MST[NegateConditionalsMutator]MSP[S] Thread . currentThread () . interrupt () ; } } return true ; }
return false ; } return file . lastModified () > timeMillis ; MST[rv.CRCR1Mutator]MSP[N] } public static boolean isFileOlder ( final File file , final File reference ) { if ( reference == null ) { throw new IllegalArgumentException ( lr_54 ) ; }
if ( ! directory . isDirectory () ) { MST[NegateConditionalsMutator]MSP[N] throw new IllegalArgumentException ( lr_46 + directory ) ; } if ( child == null ) { return false ; } if ( ! directory . exists () || ! child . exists () ) { return false ; }
if ( ! srcDir . isDirectory () ) { throw new IOException ( lr_29 + srcDir + lr_39 ) ; MST[ConstructorCallMutator]MSP[S] } if ( srcDir . getCanonicalPath () . equals ( destDir . getCanonicalPath () ) ) {
final int connectionTimeout , final int readTimeout ) throws IOException { final URLConnection connection = source . openConnection () ; connection . setConnectTimeout ( connectionTimeout ) ; MST[rv.UOI1Mutator]MSP[N] connection . setReadTimeout ( readTimeout ) ; copyInputStreamToFile ( connection . getInputStream () , destination ) ; }
public static void write ( final File file , final CharSequence data , final Charset encoding , final boolean append ) throws IOException { final String str = data == null ? null : data . toString () ; writeStringToFile ( file , str , encoding , append ) ; MST[VoidMethodCallMutator]MSP[N]
final boolean file1Exists = file1 . exists () ; if ( file1Exists != file2 . exists () ) { return false ; } if ( ! file1Exists ) { return true ; MST[rv.CRCR3Mutator]MSP[N] } if ( file1 . isDirectory () || file2 . isDirectory () ) {
return IOUtils . copyLarge ( fis , output ) ; } } private static void doCopyFile ( final File srcFile , final File destFile , final boolean preserveFileDate ) throws IOException { if ( destFile . exists () && destFile . isDirectory () ) { MST[rv.ROR4Mutator]MSP[N]
if ( ! destDir . exists () ) { throw new FileNotFoundException ( lr_66 + destDir + MST[experimental.NakedReceiverMutator]MSP[N] lr_67 + createDestDir + lr_68 ) ; } if ( ! destDir . isDirectory () ) { throw new IOException ( lr_27 + destDir + lr_28 ) ; }
doCopyDirectory ( srcFile , dstFile , filter , preserveFileDate , exclusionList ) ; } else { doCopyFile ( srcFile , dstFile , preserveFileDate ) ; } } } if ( preserveFileDate ) { MST[rv.ROR5Mutator]MSP[S] destDir . setLastModified ( srcDir . lastModified () ) ; } }
final boolean rename = srcDir . renameTo ( destDir ) ; if ( ! rename ) { if ( destDir . getCanonicalPath () . startsWith ( srcDir . getCanonicalPath () + File . separator ) ) { MST[rv.ROR2Mutator]MSP[N] throw new IOException ( lr_61 + srcDir + lr_62 + destDir ) ;
throw new IllegalArgumentException ( lr_25 + url ) ; } files [ i ] = toFile ( url ) ; } } return files ; MST[NullReturnValsMutator]MSP[N] } public static URL [] toURLs ( final File [] files ) throws IOException {
if ( date == null ) { throw new IllegalArgumentException ( lr_57 ) ; } return isFileOlder ( file , date . getTime () ) ; MST[ReturnValsMutator]MSP[S] } public static boolean isFileOlder ( final File file , final long timeMillis ) { if ( file == null ) {
if ( ! srcDir . isDirectory () ) { throw new IOException ( lr_29 + srcDir + lr_39 ) ; } if ( srcDir . getCanonicalPath () . equals ( destDir . getCanonicalPath () ) ) { MST[rv.ROR5Mutator]MSP[N]
} private static void checkFileRequirements ( final File src , final File dest ) throws FileNotFoundException { if ( src == null ) { throw new NullPointerException ( lr_38 ) ; } if ( dest == null ) { throw new NullPointerException ( lr_26 ) ; MST[ConstructorCallMutator]MSP[N] }
if ( ! directory . isDirectory () ) { throw new IllegalArgumentException ( lr_46 + directory ) ; } if ( child == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] return false ; } if ( ! directory . exists () || ! child . exists () ) { return false ; }
cleanDirectory ( directory ) ; } if ( ! directory . delete () ) { MST[rv.ROR5Mutator]MSP[N] final String message = lr_44 + directory + lr_22 ; throw new IOException ( message ) ; } } public static boolean deleteQuietly ( final File file ) {
public static void moveDirectoryToDirectory ( final File src , final File destDir , final boolean createDestDir ) throws IOException { validateMoveParameters ( src , destDir ) ; if ( ! destDir . exists () && createDestDir ) { MST[NegateConditionalsMutator]MSP[S] destDir . mkdirs () ; }
final FileFilter filter ) throws IOException { copyDirectory ( srcDir , destDir , filter , true ) ; MST[rv.CRCR5Mutator]MSP[N] } public static void copyDirectory ( final File srcDir , final File destDir , final FileFilter filter , final boolean preserveFileDate ) throws IOException { checkFileRequirements ( srcDir , destDir ) ;
if ( date == null ) { throw new IllegalArgumentException ( lr_57 ) ; MST[ConstructorCallMutator]MSP[S] } return isFileOlder ( file , date . getTime () ) ; } public static boolean isFileOlder ( final File file , final long timeMillis ) { if ( file == null ) {
public static void writeStringToFile ( final File file , final String data , final String encoding ) throws IOException { writeStringToFile ( file , data , encoding , false ) ; MST[VoidMethodCallMutator]MSP[N] } public static void writeStringToFile ( final File file , final String data , final Charset encoding ,
final File [] files = directory . listFiles () ; if ( files == null ) { return 0L ; } long size = 0 ; for ( final File file : files ) { MST[rv.UOI1Mutator]MSP[N] if ( ! isSymlink ( file ) ) {
+ lr_52 ; throw new IOException ( message ) ; } } else { if ( ! directory . mkdirs () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] if ( ! directory . isDirectory () ) { final String message = lr_53 + directory ; throw new IOException ( message ) ; } } }
displaySize = String . valueOf ( size . divide ( ONE_GB_BI ) ) + lr_15 ; } else if ( size . divide ( ONE_MB_BI ) . compareTo ( BigInteger . ZERO ) > 0 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N]
} public static void write ( final File file , final CharSequence data , final String encoding , final boolean append ) throws IOException { write ( file , data , Charsets . toCharset ( encoding ) , append ) ; MST[NonVoidMethodCallMutator]MSP[N] }
validateMoveParameters ( srcDir , destDir ) ; MST[VoidMethodCallMutator]MSP[S] if ( ! srcDir . isDirectory () ) { throw new IOException ( lr_29 + srcDir + lr_28 ) ; } if ( destDir . exists () ) { throw new FileExistsException ( lr_27 + destDir + lr_60 ) ; }
size += sizeOf0 ( file ) ; if ( size < 0 ) { MST[rv.ROR4Mutator]MSP[N] break; } } } return size ; } private static long sizeOf0 ( final File file ) { if ( file . isDirectory () ) { return sizeOfDirectory0 ( file ) ; }
} while ( i < n && url . charAt ( i ) == '%' ); MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] continue; } catch ( final RuntimeException e ) { } finally { if ( bytes . position () > 0 ) { bytes . flip () ;
validateMoveParameters ( srcDir , destDir ) ; if ( ! srcDir . isDirectory () ) { throw new IOException ( lr_29 + srcDir + lr_28 ) ; } if ( destDir . exists () ) { throw new FileExistsException ( lr_27 + destDir + lr_60 ) ; MST[NonVoidMethodCallMutator]MSP[N] }
public static LineIterator lineIterator ( final File file , final String encoding ) throws IOException { InputStream in = null ; try { in = openInputStream ( file ) ; MST[NonVoidMethodCallMutator]MSP[N] return IOUtils . lineIterator ( in , encoding ) ; } catch ( final IOException | RuntimeException ex ) {
if ( file . exists () ) { if ( file . isDirectory () ) { MST[rv.ROR2Mutator]MSP[N] throw new IOException ( lr_5 + file + lr_6 ) ; } if ( file . canWrite () == false ) { throw new IOException ( lr_5 + file + lr_9 ) ; }
throw new IOException ( lr_23 ) ; } if ( file1 . length () != file2 . length () ) { MST[NonVoidMethodCallMutator]MSP[N] return false ; } if ( file1 . getCanonicalFile () . equals ( file2 . getCanonicalFile () ) ) { return true ; }
if ( ! destDir . isDirectory () ) { throw new IOException ( lr_27 + destDir + lr_28 ) ; } moveFile ( srcFile , new File ( destDir , srcFile . getName () ) ) ; MST[VoidMethodCallMutator]MSP[N] }
} else { final File parent = file . getParentFile () ; if ( parent != null ) { if ( ! parent . mkdirs () && ! parent . isDirectory () ) { throw new IOException ( lr_10 + parent + lr_11 ) ; MST[NonVoidMethodCallMutator]MSP[N] } } }
final boolean success = file . setLastModified ( System . currentTimeMillis () ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( ! success ) { throw new IOException ( lr_19 + file ) ; } } public static File [] convertFileCollectionToFileArray ( final Collection < File > files ) {
if ( ! directory . isDirectory () ) { throw new IllegalArgumentException ( lr_46 + directory ) ; } if ( child == null ) { return false ; MST[ReturnValsMutator]MSP[S] } if ( ! directory . exists () || ! child . exists () ) { return false ; }
} public static void copyFile ( final File srcFile , final File destFile , final boolean preserveFileDate ) throws IOException { checkFileRequirements ( srcFile , destFile ) ; if ( srcFile . isDirectory () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] throw new IOException ( lr_29 + srcFile + lr_6 ) ; }
final boolean success = file . setLastModified ( System . currentTimeMillis () ) ; if ( ! success ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] throw new IOException ( lr_19 + file ) ; } } public static File [] convertFileCollectionToFileArray ( final Collection < File > files ) {
throw new NullPointerException ( lr_26 ) ; } if ( ! src . exists () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] throw new FileNotFoundException ( lr_29 + src + lr_8 ) ; } } public static boolean isSymlink ( final File file ) { if ( file == null ) {
final boolean file1Exists = file1 . exists () ; if ( file1Exists != file2 . exists () ) { return false ; } if ( ! file1Exists ) { MST[rv.ROR1Mutator]MSP[N] return true ; } if ( file1 . isDirectory () || file2 . isDirectory () ) {
} public static File [] toFiles ( final URL [] urls ) { if ( urls == null || urls . length == 0 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return EMPTY_FILE_ARRAY ; } final File [] files = new File [ urls . length ] ;
if ( ! parentFile . mkdirs () && ! parentFile . isDirectory () ) { MST[rv.ROR4Mutator]MSP[N] throw new IOException ( lr_27 + parentFile + lr_32 ) ; } } if ( destFile . exists () && destFile . canWrite () == false ) {
return lineIterator ( file , null ) ; } public static void writeStringToFile ( final File file , final String data , final Charset encoding ) throws IOException { writeStringToFile ( file , data , encoding , false ) ; MST[rv.CRCR1Mutator]MSP[N] }
} @Deprecated public static void write ( final File file , final CharSequence data ) throws IOException { write ( file , data , Charset . defaultCharset () , false ) ; MST[rv.CRCR1Mutator]MSP[N] } @Deprecated
} } public static void forceDeleteOnExit ( final File file ) throws IOException { if ( file . isDirectory () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] deleteDirectoryOnExit ( file ) ; } else { file . deleteOnExit () ; } } private static void deleteDirectoryOnExit ( final File directory ) throws IOException {
return IOUtils . copyLarge ( fis , output ) ; MST[PrimitiveReturnsMutator]MSP[N] } } private static void doCopyFile ( final File srcFile , final File destFile , final boolean preserveFileDate ) throws IOException { if ( destFile . exists () && destFile . isDirectory () ) {
doCopyDirectory ( srcFile , dstFile , filter , preserveFileDate , exclusionList ) ; } else { doCopyFile ( srcFile , dstFile , preserveFileDate ) ; } } } if ( preserveFileDate ) { MST[rv.UOI4Mutator]MSP[S] destDir . setLastModified ( srcDir . lastModified () ) ; } }
final URL [] urls = new URL [ files . length ] ; for ( int i = 0 ; i < urls . length ; i ++ ) { urls [ i ] = files [ i ] . toURI () . toURL () ; MST[rv.UOI1Mutator]MSP[S] } return urls ;
public static BigInteger sizeOfAsBigInteger ( final File file ) { if ( ! file . exists () ) { MST[rv.ROR4Mutator]MSP[S] final String message = file + lr_42 ; throw new IllegalArgumentException ( message ) ; } if ( file . isDirectory () ) { return sizeOfDirectoryBig0 ( file ) ; }
for ( int i = 0 ; i < urls . length ; i ++ ) { MST[rv.CRCR3Mutator]MSP[N] final URL url = urls [ i ] ; if ( url != null ) { if ( url . getProtocol () . equals ( lr_24 ) == false ) {
moveFileToDirectory ( src , destDir , createDestDir ) ; MST[rv.UOI3Mutator]MSP[N] } } private static void validateMoveParameters ( final File src , final File dest ) throws FileNotFoundException { if ( src == null ) { throw new NullPointerException ( lr_38 ) ; } if ( dest == null ) {
doCopyDirectory ( srcFile , dstFile , filter , preserveFileDate , exclusionList ) ; MST[VoidMethodCallMutator]MSP[N] } else { doCopyFile ( srcFile , dstFile , preserveFileDate ) ; } } } if ( preserveFileDate ) { destDir . setLastModified ( srcDir . lastModified () ) ; } }
return new File ( filename ) ; } static String decodeUrl ( final String url ) { String decoded = url ; if ( url != null && url . indexOf ( '%' ) >= 0 ) { MST[ArgumentPropagationMutator]MSP[N] final int n = url . length () ;
if ( file == null ) { return false ; MST[InlineConstantMutator]MSP[N] } try { if ( file . isDirectory () ) { cleanDirectory ( file ) ; } } catch ( final Exception ignored ) { } try { return file . delete () ;
throws IOException { final boolean file1Exists = file1 . exists () ; if ( file1Exists != file2 . exists () ) { return false ; } if ( ! file1Exists ) { return true ; MST[rv.CRCR4Mutator]MSP[N] } if ( file1 . isDirectory () || file2 . isDirectory () ) {
public static void moveToDirectory ( final File src , final File destDir , final boolean createDestDir ) throws IOException { validateMoveParameters ( src , destDir ) ; if ( src . isDirectory () ) { MST[rv.ROR5Mutator]MSP[S] moveDirectoryToDirectory ( src , destDir , createDestDir ) ; } else {
final StringBuilder buffer = new StringBuilder () ; final ByteBuffer bytes = ByteBuffer . allocate ( n ) ; for ( int i = 0 ; i < n ; ) { MST[rv.ROR5Mutator]MSP[N] if ( url . charAt ( i ) == '%' ) { try { do {
public static void copyDirectory ( final File srcDir , final File destDir , final boolean preserveFileDate ) throws IOException { copyDirectory ( srcDir , destDir , null , preserveFileDate ) ; MST[rv.UOI4Mutator]MSP[S] } public static void copyDirectory ( final File srcDir , final File destDir ,
final boolean file1Exists = file1 . exists () ; if ( file1Exists != file2 . exists () ) { return false ; } if ( ! file1Exists ) { return true ; } if ( file1 . isDirectory () || file2 . isDirectory () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
checksum ( file , crc ) ; return crc . getValue () ; } public static Checksum checksum ( final File file , final Checksum checksum ) throws IOException { if ( file . isDirectory () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] throw new IllegalArgumentException ( lr_59 ) ; }
validateMoveParameters ( srcDir , destDir ) ; if ( ! srcDir . isDirectory () ) { throw new IOException ( lr_29 + srcDir + lr_28 ) ; } if ( destDir . exists () ) { throw new FileExistsException ( lr_27 + destDir + lr_60 ) ; MST[experimental.NakedReceiverMutator]MSP[N] }
validateMoveParameters ( srcFile , destDir ) ; if ( ! destDir . exists () && createDestDir ) { destDir . mkdirs () ; } if ( ! destDir . exists () ) { MST[rv.ROR4Mutator]MSP[N] throw new FileNotFoundException ( lr_66 + destDir + lr_67 + createDestDir + lr_68 ) ; }
final boolean rename = srcDir . renameTo ( destDir ) ; if ( ! rename ) { if ( destDir . getCanonicalPath () . startsWith ( srcDir . getCanonicalPath () + File . separator ) ) { MST[NonVoidMethodCallMutator]MSP[N] throw new IOException ( lr_61 + srcDir + lr_62 + destDir ) ;
for ( final File src : srcs ) { copyFileToDirectory ( src , destDir ) ; } } public static void deleteDirectory ( final File directory ) throws IOException { if ( ! directory . exists () ) { return; } if ( ! isSymlink ( directory ) ) { MST[rv.ROR3Mutator]MSP[S]
public static BigInteger sizeOfAsBigInteger ( final File file ) { if ( ! file . exists () ) { final String message = file + lr_42 ; throw new IllegalArgumentException ( message ) ; MST[ConstructorCallMutator]MSP[S] } if ( file . isDirectory () ) { return sizeOfDirectoryBig0 ( file ) ; }
public static void writeLines ( final File file , final String encoding , final Collection < ? > lines , final String lineEnding ) throws IOException { writeLines ( file , encoding , lines , lineEnding , false ) ; MST[rv.CRCR6Mutator]MSP[N] }
final byte octet = ( byte ) Integer . parseInt ( url . substring ( i + 1 , i + 3 ) , 16 ) ; MST[rv.CRCR4Mutator]MSP[N] bytes . put ( octet ) ; i += 3 ;
File file = null ; for ( final String name : names ) { MST[rv.UOI1Mutator]MSP[S] if ( file == null ) { file = new File ( name ) ; } else { file = new File ( file , name ) ; } } return file ; }
if ( destDir . isDirectory () == false ) { throw new IOException ( lr_27 + destDir + lr_39 ) ; MST[experimental.NakedReceiverMutator]MSP[N] } } else { if ( ! destDir . mkdirs () && ! destDir . isDirectory () ) {
FileUtils . deleteQuietly ( destFile ) ; throw new IOException ( lr_70 + srcFile + MST[ConstructorCallMutator]MSP[S] lr_64 + destFile + lr_65 ) ; } } } public static void moveFileToDirectory ( final File srcFile , final File destDir , final boolean createDestDir ) throws IOException {
if ( url == null || ! lr_24 . equalsIgnoreCase ( url . getProtocol () ) ) { return null ; } String filename = url . getFile () . replace ( '/' , File . separatorChar ) ; filename = decodeUrl ( filename ) ; MST[ArgumentPropagationMutator]MSP[N]
} public static Iterator < File > iterateFiles ( final File directory , final IOFileFilter fileFilter , final IOFileFilter dirFilter ) { return listFiles ( directory , fileFilter , dirFilter ) . iterator () ; MST[NullReturnValsMutator]MSP[S] }
final File dstFile = new File ( destDir , srcFile . getName () ) ; if ( exclusionList == null || ! exclusionList . contains ( srcFile . getCanonicalPath () ) ) { if ( srcFile . isDirectory () ) { MST[rv.ROR2Mutator]MSP[N]
public static void writeLines ( final File file , final String encoding , final Collection < ? > lines , final String lineEnding ) throws IOException { writeLines ( file , encoding , lines , lineEnding , false ) ; MST[rv.CRCR3Mutator]MSP[N] }
size += sizeOf0 ( file ) ; if ( size < 0 ) { MST[rv.CRCR3Mutator]MSP[N] break; } } } return size ; } private static long sizeOf0 ( final File file ) { if ( file . isDirectory () ) { return sizeOfDirectory0 ( file ) ; }
} catch ( final Exception ignored ) { return false ; } } public static boolean directoryContains ( final File directory , final File child ) throws IOException { if ( directory == null ) { MST[NegateConditionalsMutator]MSP[N] throw new IllegalArgumentException ( lr_45 ) ; }
size += sizeOf0 ( file ) ; if ( size < 0 ) { MST[rv.CRCR6Mutator]MSP[N] break; } } } return size ; } private static long sizeOf0 ( final File file ) { if ( file . isDirectory () ) { return sizeOfDirectory0 ( file ) ; }
displaySize = String . valueOf ( size . divide ( ONE_PB_BI ) ) + lr_13 ; } else if ( size . divide ( ONE_TB_BI ) . compareTo ( BigInteger . ZERO ) > 0 ) { MST[ConditionalsBoundaryMutator]MSP[N]
displaySize = String . valueOf ( size . divide ( ONE_PB_BI ) ) + lr_13 ; } else if ( size . divide ( ONE_TB_BI ) . compareTo ( BigInteger . ZERO ) > 0 ) { MST[NonVoidMethodCallMutator]MSP[N]
public static void write ( final File file , final CharSequence data , final String encoding ) throws IOException { write ( file , data , encoding , false ) ; MST[rv.CRCR1Mutator]MSP[N] }
final File [] files = directory . listFiles () ; if ( files == null ) { return 0L ; } long size = 0 ; MST[InlineConstantMutator]MSP[N] for ( final File file : files ) { if ( ! isSymlink ( file ) ) {
public static boolean isFileNewer ( final File file , final File reference ) { if ( reference == null ) { throw new IllegalArgumentException ( lr_54 ) ; MST[ConstructorCallMutator]MSP[N] } if ( ! reference . exists () ) { throw new IllegalArgumentException ( lr_55 + reference + lr_56 ) ; }
final int connectionTimeout , final int readTimeout ) throws IOException { final URLConnection connection = source . openConnection () ; connection . setConnectTimeout ( connectionTimeout ) ; MST[rv.UOI2Mutator]MSP[N] connection . setReadTimeout ( readTimeout ) ; copyInputStreamToFile ( connection . getInputStream () , destination ) ; }
+ lr_52 ; throw new IOException ( message ) ; } } else { if ( ! directory . mkdirs () ) { MST[NonVoidMethodCallMutator]MSP[N] if ( ! directory . isDirectory () ) { final String message = lr_53 + directory ; throw new IOException ( message ) ; } } }
if ( ! directory . exists () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] return; } directory . deleteOnExit () ; if ( ! isSymlink ( directory ) ) { cleanDirectoryOnExit ( directory ) ; } } private static void cleanDirectoryOnExit ( final File directory ) throws IOException {
throw new IOException ( lr_27 + destFile + lr_6 ) ; } final Path srcPath = srcFile . toPath () ; final Path destPath = destFile . toPath () ; final long newLastModifed = preserveFileDate ? srcFile . lastModified () : destFile . lastModified () ; MST[rv.ROR1Mutator]MSP[S]
public static void write ( final File file , final CharSequence data , final Charset encoding , final boolean append ) throws IOException { final String str = data == null ? null : data . toString () ; writeStringToFile ( file , str , encoding , append ) ; MST[rv.UOI3Mutator]MSP[N]
return FileFilterUtils . and ( fileFilter , FileFilterUtils . notFileFilter ( DirectoryFileFilter . INSTANCE ) ) ; } private static IOFileFilter setUpEffectiveDirFilter ( final IOFileFilter dirFilter ) { return dirFilter == null ? FalseFileFilter . INSTANCE : FileFilterUtils . and ( dirFilter , MST[NegateConditionalsMutator]MSP[N] DirectoryFileFilter . INSTANCE ) ; }
final File [] found = directory . listFiles ( ( FileFilter ) filter ) ; if ( found != null ) { for ( final File file : found ) { if ( file . isDirectory () ) { MST[rv.ROR1Mutator]MSP[N] if ( includeSubDirectories ) {
final File [] srcFiles = filter == null ? srcDir . listFiles () : srcDir . listFiles ( filter ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] if ( srcFiles != null && srcFiles . length > 0 ) { exclusionList = new ArrayList <> ( srcFiles . length ) ;
Files . copy ( srcPath , destPath , StandardCopyOption . REPLACE_EXISTING ) ; MST[rv.CRCR3Mutator]MSP[N] checkEqualSizes ( srcFile , destFile , Files . size ( srcPath ) , Files . size ( destPath ) ) ;
for ( int i = 0 ; i < urls . length ; i ++ ) { final URL url = urls [ i ] ; MST[rv.UOI2Mutator]MSP[N] if ( url != null ) { if ( url . getProtocol () . equals ( lr_24 ) == false ) {
final boolean file1Exists = file1 . exists () ; if ( file1Exists != file2 . exists () ) { return false ; } if ( ! file1Exists ) { return true ; } if ( file1 . isDirectory () || file2 . isDirectory () ) { MST[NonVoidMethodCallMutator]MSP[N]
files . add ( file ) ; MST[NonVoidMethodCallMutator]MSP[N] } innerListFiles ( files , file , filter , includeSubDirectories ) ; } else { files . add ( file ) ; } } } } public static Collection < File > listFiles (
throw new IOException ( lr_5 + file + lr_6 ) ; } if ( file . canRead () == false ) { MST[rv.ROR3Mutator]MSP[N] throw new IOException ( lr_5 + file + lr_7 ) ; } } else { throw new FileNotFoundException ( lr_5 + file + lr_8 ) ; }
final File directory , final IOFileFilter fileFilter , final IOFileFilter dirFilter ) { return innerListFilesOrDirectories ( directory , fileFilter , dirFilter , false ) ; } private static void validateListFilesParameters ( final File directory , final IOFileFilter fileFilter ) { if ( ! directory . isDirectory () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
throw new IllegalArgumentException ( lr_20 + directory ) ; } if ( fileFilter == null ) { MST[NegateConditionalsMutator]MSP[N] throw new NullPointerException ( lr_21 ) ; } } private static IOFileFilter setUpEffectiveFileFilter ( final IOFileFilter fileFilter ) {
throws IOException { final File [] srcFiles = filter == null ? srcDir . listFiles () : srcDir . listFiles ( filter ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] if ( srcFiles == null ) { throw new IOException ( lr_40 + srcDir ) ; } if ( destDir . exists () ) {
final boolean file1Exists = file1 . exists () ; if ( file1Exists != file2 . exists () ) { return false ; } if ( ! file1Exists ) { MST[rv.ROR4Mutator]MSP[S] return true ; } if ( file1 . isDirectory () || file2 . isDirectory () ) {
public static Collection < File > listFilesAndDirs ( final File directory , final IOFileFilter fileFilter , final IOFileFilter dirFilter ) { return innerListFilesOrDirectories ( directory , fileFilter , dirFilter , true ) ; MST[rv.CRCR4Mutator]MSP[N] } private static Collection < File > innerListFilesOrDirectories (
final File directory , final String [] extensions , final boolean recursive ) { return listFiles ( directory , extensions , recursive ) . iterator () ; MST[NonVoidMethodCallMutator]MSP[S] } public static boolean contentEquals ( final File file1 , final File file2 ) throws IOException {
displaySize = String . valueOf ( size . divide ( ONE_TB_BI ) ) + lr_14 ; MST[ConstructorCallMutator]MSP[N] } else if ( size . divide ( ONE_GB_BI ) . compareTo ( BigInteger . ZERO ) > 0 ) {
return FileFilterUtils . and ( fileFilter , FileFilterUtils . notFileFilter ( DirectoryFileFilter . INSTANCE ) ) ; } private static IOFileFilter setUpEffectiveDirFilter ( final IOFileFilter dirFilter ) { return dirFilter == null ? FalseFileFilter . INSTANCE : FileFilterUtils . and ( dirFilter , MST[rv.CRCR6Mutator]MSP[N] DirectoryFileFilter . INSTANCE ) ; }
return FileFilterUtils . and ( fileFilter , FileFilterUtils . notFileFilter ( DirectoryFileFilter . INSTANCE ) ) ; } private static IOFileFilter setUpEffectiveDirFilter ( final IOFileFilter dirFilter ) { return dirFilter == null ? FalseFileFilter . INSTANCE : FileFilterUtils . and ( dirFilter , MST[rv.CRCR5Mutator]MSP[N] DirectoryFileFilter . INSTANCE ) ; }
final StringBuilder buffer = new StringBuilder () ; final ByteBuffer bytes = ByteBuffer . allocate ( n ) ; for ( int i = 0 ; i < n ; ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] if ( url . charAt ( i ) == '%' ) { try { do {
public static void moveDirectoryToDirectory ( final File src , final File destDir , final boolean createDestDir ) throws IOException { validateMoveParameters ( src , destDir ) ; if ( ! destDir . exists () && createDestDir ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] destDir . mkdirs () ; }
public static boolean isFileNewer ( final File file , final File reference ) { if ( reference == null ) { throw new IllegalArgumentException ( lr_54 ) ; } if ( ! reference . exists () ) { throw new IllegalArgumentException ( lr_55 MST[experimental.NakedReceiverMutator]MSP[N] + reference + lr_56 ) ; }
return readFileToString ( file , Charset . defaultCharset () ) ; MST[NonVoidMethodCallMutator]MSP[N] } public static byte [] readFileToByteArray ( final File file ) throws IOException { try ( InputStream in = openInputStream ( file ) ) { final long fileLength = file . length () ;
displaySize = String . valueOf ( size . divide ( ONE_GB_BI ) ) + lr_15 ; } else if ( size . divide ( ONE_MB_BI ) . compareTo ( BigInteger . ZERO ) > 0 ) { MST[experimental.NakedReceiverMutator]MSP[N]
throw new IOException ( lr_23 ) ; } if ( file1 . getCanonicalFile () . equals ( file2 . getCanonicalFile () ) ) { MST[NonVoidMethodCallMutator]MSP[N] return true ; } try ( Reader input1 = charsetName == null
size += sizeOf0 ( file ) ; if ( size < 0 ) { break; } } } return size ; MST[ReturnValsMutator]MSP[N] } private static long sizeOf0 ( final File file ) { if ( file . isDirectory () ) { return sizeOfDirectory0 ( file ) ; }
final boolean file1Exists = file1 . exists () ; if ( file1Exists != file2 . exists () ) { MST[rv.ABSMutator]MSP[N] return false ; } if ( ! file1Exists ) { return true ; } if ( file1 . isDirectory () || file2 . isDirectory () ) {
final File destFile = new File ( destDir , srcFile . getName () ) ; MST[ConstructorCallMutator]MSP[N] copyFile ( srcFile , destFile , preserveFileDate ) ; } public static void copyFile ( final File srcFile , final File destFile ) throws IOException { copyFile ( srcFile , destFile , true ) ;
throw new IOException ( lr_27 + destFile + lr_6 ) ; } final Path srcPath = srcFile . toPath () ; final Path destPath = destFile . toPath () ; final long newLastModifed = preserveFileDate ? srcFile . lastModified () : destFile . lastModified () ; MST[rv.ROR4Mutator]MSP[S]
if ( srcDir == null ) { throw new NullPointerException ( lr_38 ) ; } if ( srcDir . exists () && srcDir . isDirectory () == false ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] throw new IllegalArgumentException ( lr_29 + destDir + lr_28 ) ; } if ( destDir == null ) {
if ( ! src . exists () ) { MST[NegateConditionalsMutator]MSP[N] throw new FileNotFoundException ( lr_29 + src + lr_8 ) ; } } private static void doCopyDirectory ( final File srcDir , final File destDir , final FileFilter filter , final boolean preserveFileDate , final List < String > exclusionList )
final boolean rename = srcDir . renameTo ( destDir ) ; if ( ! rename ) { if ( destDir . getCanonicalPath () . startsWith ( srcDir . getCanonicalPath () + File . separator ) ) { MST[rv.ROR5Mutator]MSP[N] throw new IOException ( lr_61 + srcDir + lr_62 + destDir ) ;
displaySize = String . valueOf ( size . divide ( ONE_EB_BI ) ) + lr_12 ; MST[NonVoidMethodCallMutator]MSP[N] } else if ( size . divide ( ONE_PB_BI ) . compareTo ( BigInteger . ZERO ) > 0 ) {
if ( ! file . exists () ) { final String message = file + lr_42 ; throw new IllegalArgumentException ( message ) ; } if ( file . isDirectory () ) { MST[rv.ROR1Mutator]MSP[N] return sizeOfDirectory0 ( file ) ; } return file . length () ; }
doCopyDirectory ( srcFile , dstFile , filter , preserveFileDate , exclusionList ) ; } else { doCopyFile ( srcFile , dstFile , preserveFileDate ) ; } } } if ( preserveFileDate ) { MST[rv.ROR2Mutator]MSP[N] destDir . setLastModified ( srcDir . lastModified () ) ; } }
if ( ! destDir . exists () ) { MST[rv.ROR5Mutator]MSP[N] throw new FileNotFoundException ( lr_66 + destDir + lr_67 + createDestDir + lr_68 ) ; } if ( ! destDir . isDirectory () ) { throw new IOException ( lr_27 + destDir + lr_28 ) ; }
if ( ! srcDir . isDirectory () ) { throw new IOException ( lr_29 + srcDir + lr_39 ) ; MST[NonVoidMethodCallMutator]MSP[N] } if ( srcDir . getCanonicalPath () . equals ( destDir . getCanonicalPath () ) ) {
for ( final File src : srcs ) { copyFileToDirectory ( src , destDir ) ; } } public static void deleteDirectory ( final File directory ) throws IOException { if ( ! directory . exists () ) { return; } if ( ! isSymlink ( directory ) ) { MST[NonVoidMethodCallMutator]MSP[N]
public static Collection < File > listFilesAndDirs ( final File directory , final IOFileFilter fileFilter , final IOFileFilter dirFilter ) { return innerListFilesOrDirectories ( directory , fileFilter , dirFilter , true ) ; MST[InlineConstantMutator]MSP[N] } private static Collection < File > innerListFilesOrDirectories (
throw new IOException ( lr_27 + destDir + lr_32 ) ; } } if ( destDir . canWrite () == false ) { MST[rv.ROR5Mutator]MSP[N] throw new IOException ( lr_27 + destDir + lr_9 ) ; } for ( final File srcFile : srcFiles ) {
throws IOException { final boolean file1Exists = file1 . exists () ; if ( file1Exists != file2 . exists () ) { MST[rv.ROR3Mutator]MSP[S] return false ; } if ( ! file1Exists ) { return true ; } if ( file1 . isDirectory () || file2 . isDirectory () ) {
throw new IOException ( lr_29 + srcFile + lr_69 ) ; } if ( destFile . exists () ) { MST[rv.ROR3Mutator]MSP[N] throw new FileExistsException ( lr_27 + destFile + lr_60 ) ; } if ( destFile . isDirectory () ) {
} while ( i < n && url . charAt ( i ) == '%' ); continue; } catch ( final RuntimeException e ) { } finally { if ( bytes . position () > 0 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] bytes . flip () ;
throw new IOException ( lr_27 + destFile + lr_33 ) ; } doCopyFile ( srcFile , destFile , preserveFileDate ) ; MST[rv.UOI2Mutator]MSP[N] } public static long copyFile ( final File input , final OutputStream output ) throws IOException { try ( FileInputStream fis = new FileInputStream ( input ) ) {
if ( ! file . exists () ) { final String message = file + lr_42 ; throw new IllegalArgumentException ( message ) ; } if ( file . isDirectory () ) { return sizeOfDirectory0 ( file ) ; MST[ReturnValsMutator]MSP[N] } return file . length () ; }
writeStringToFile ( file , data , Charset . defaultCharset () , false ) ; } @Deprecated public static void writeStringToFile ( final File file , final String data , final boolean append ) throws IOException { writeStringToFile ( file , data , Charset . defaultCharset () , append ) ; MST[rv.ABSMutator]MSP[N]
final File [] srcFiles = filter == null ? srcDir . listFiles () : srcDir . listFiles ( filter ) ; if ( srcFiles != null && srcFiles . length > 0 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] exclusionList = new ArrayList <> ( srcFiles . length ) ;
moveDirectory ( src , new File ( destDir , src . getName () ) ) ; } public static void moveFile ( final File srcFile , final File destFile ) throws IOException { validateMoveParameters ( srcFile , destFile ) ; if ( srcFile . isDirectory () ) { MST[NonVoidMethodCallMutator]MSP[N]
if ( ! destDir . isDirectory () ) { throw new IOException ( lr_27 + destDir + lr_28 ) ; } moveFile ( srcFile , new File ( destDir , srcFile . getName () ) ) ; MST[NonVoidMethodCallMutator]MSP[N] }
throw new IOException ( lr_23 ) ; } if ( file1 . getCanonicalFile () . equals ( file2 . getCanonicalFile () ) ) { return true ; } try ( Reader input1 = charsetName == null MST[rv.ROR5Mutator]MSP[S]
moveDirectory ( src , new File ( destDir , src . getName () ) ) ; MST[ConstructorCallMutator]MSP[N] } public static void moveFile ( final File srcFile , final File destFile ) throws IOException { validateMoveParameters ( srcFile , destFile ) ; if ( srcFile . isDirectory () ) {
displaySize = String . valueOf ( size . divide ( ONE_PB_BI ) ) + lr_13 ; MST[experimental.NakedReceiverMutator]MSP[N] } else if ( size . divide ( ONE_TB_BI ) . compareTo ( BigInteger . ZERO ) > 0 ) {
final boolean filePresent = file . exists () ; if ( ! file . delete () ) { if ( ! filePresent ) { throw new FileNotFoundException ( lr_48 + file ) ; } final String message = MST[ConstructorCallMutator]MSP[S] lr_49 + file ; throw new IOException ( message ) ; }
final Collection < File > files = new java . util . LinkedList <> () ; if ( includeSubDirectories ) { files . add ( directory ) ; } innerListFiles ( files , directory , FileFilterUtils . or ( effFileFilter , effDirFilter ) , includeSubDirectories ) ; return files ; MST[ReturnValsMutator]MSP[N]
while ( ! file . exists () ) { final long remaining = finishAt - System . currentTimeMillis () ; if ( remaining < 0 ) { return false ; } try { Thread . sleep ( Math . min ( 100 , remaining ) ) ; MST[rv.CRCR3Mutator]MSP[N]
final boolean append ) throws IOException { try ( OutputStream out = openOutputStream ( file , append ) ) { MST[rv.UOI3Mutator]MSP[N] IOUtils . write ( data , out , encoding ) ; } } public static void writeStringToFile ( final File file , final String data , final String encoding ,
} public static void write ( final File file , final CharSequence data , final String encoding , final boolean append ) throws IOException { write ( file , data , Charsets . toCharset ( encoding ) , append ) ; MST[VoidMethodCallMutator]MSP[N] }
} copyDirectory ( srcDir , destDir ) ; deleteDirectory ( srcDir ) ; if ( srcDir . exists () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] throw new IOException ( lr_63 + srcDir + lr_64 + destDir + lr_65 ) ; } } }
? new InputStreamReader ( new FileInputStream ( file1 ) , Charset . defaultCharset () ) : new InputStreamReader ( new FileInputStream ( file1 ) , charsetName ) ; Reader input2 = charsetName == null MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] ? new InputStreamReader ( new FileInputStream ( file2 ) , Charset . defaultCharset () )
for ( final String name : names ) { MST[rv.ABSMutator]MSP[S] file = new File ( file , name ) ; } return file ; } public static File getFile ( final String ... names ) { if ( names == null ) { throw new NullPointerException ( lr_2 ) ; }
File file = null ; for ( final String name : names ) { MST[rv.UOI3Mutator]MSP[S] if ( file == null ) { file = new File ( name ) ; } else { file = new File ( file , name ) ; } } return file ; }
checkEqualSizes ( srcFile , destFile , srcFile . length () , destFile . length () ) ; destFile . setLastModified ( newLastModifed ) ; MST[rv.UOI1Mutator]MSP[N] } private static void checkEqualSizes ( final File srcFile , final File destFile , final long srcLen , final long dstLen ) throws IOException {
return fileLength > 0 ? IOUtils . toByteArray ( in , fileLength ) : IOUtils . toByteArray ( in ) ; MST[rv.UOI4Mutator]MSP[S] } } public static List < String > readLines ( final File file , final Charset encoding ) throws IOException {
if ( ! reference . exists () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] throw new IllegalArgumentException ( lr_55 + reference + lr_56 ) ; } return isFileOlder ( file , reference . lastModified () ) ; } public static boolean isFileOlder ( final File file , final Date date ) {
final StringBuilder buffer = new StringBuilder () ; final ByteBuffer bytes = ByteBuffer . allocate ( n ) ; for ( int i = 0 ; i < n ; ) { MST[ConditionalsBoundaryMutator]MSP[N] if ( url . charAt ( i ) == '%' ) { try { do {
validateMoveParameters ( srcFile , destDir ) ; if ( ! destDir . exists () && createDestDir ) { destDir . mkdirs () ; } if ( ! destDir . exists () ) { throw new FileNotFoundException ( lr_66 + destDir + MST[NonVoidMethodCallMutator]MSP[S] lr_67 + createDestDir + lr_68 ) ; }
public static void moveDirectoryToDirectory ( final File src , final File destDir , final boolean createDestDir ) throws IOException { validateMoveParameters ( src , destDir ) ; MST[VoidMethodCallMutator]MSP[N] if ( ! destDir . exists () && createDestDir ) { destDir . mkdirs () ; }
if ( srcLen != dstLen ) { throw new IOException ( lr_34 + srcFile + lr_35 + destFile MST[NonVoidMethodCallMutator]MSP[S] + lr_36 + srcLen + lr_37 + dstLen ) ; } } public static void copyDirectoryToDirectory ( final File srcDir , final File destDir ) throws IOException {
if ( files == null ) { return BigInteger . ZERO ; } BigInteger size = BigInteger . ZERO ; for ( final File file : files ) { MST[rv.UOI1Mutator]MSP[N] if ( ! isSymlink ( file ) ) { size = size . add ( sizeOfBig0 ( file ) ) ;
return BigInteger . valueOf ( file . length () ) ; MST[NonVoidMethodCallMutator]MSP[N] } public static long sizeOfDirectory ( final File directory ) { checkDirectory ( directory ) ; return sizeOfDirectory0 ( directory ) ; } private static long sizeOfDirectory0 ( final File directory ) {
doCopyDirectory ( srcFile , dstFile , filter , preserveFileDate , exclusionList ) ; } else { doCopyFile ( srcFile , dstFile , preserveFileDate ) ; } } } if ( preserveFileDate ) { destDir . setLastModified ( srcDir . lastModified () ) ; MST[NonVoidMethodCallMutator]MSP[S] } }
if ( srcLen != dstLen ) { MST[rv.UOI1Mutator]MSP[N] throw new IOException ( lr_34 + srcFile + lr_35 + destFile + lr_36 + srcLen + lr_37 + dstLen ) ; } } public static void copyDirectoryToDirectory ( final File srcDir , final File destDir ) throws IOException {
writeStringToFile ( file , data , Charset . defaultCharset () , false ) ; MST[rv.CRCR6Mutator]MSP[N] } @Deprecated public static void writeStringToFile ( final File file , final String data , final boolean append ) throws IOException { writeStringToFile ( file , data , Charset . defaultCharset () , append ) ;
final boolean success = file . setLastModified ( System . currentTimeMillis () ) ; if ( ! success ) { MST[rv.UOI2Mutator]MSP[N] throw new IOException ( lr_19 + file ) ; } } public static File [] convertFileCollectionToFileArray ( final Collection < File > files ) {
size += sizeOf0 ( file ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( size < 0 ) { break; } } } return size ; } private static long sizeOf0 ( final File file ) { if ( file . isDirectory () ) { return sizeOfDirectory0 ( file ) ; }
if ( ! parentFile . mkdirs () && ! parentFile . isDirectory () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] throw new IOException ( lr_27 + parentFile + lr_32 ) ; } } if ( destFile . exists () && destFile . canWrite () == false ) {
if ( ! destDir . isDirectory () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] throw new IOException ( lr_27 + destDir + lr_28 ) ; } moveFile ( srcFile , new File ( destDir , srcFile . getName () ) ) ; }
if ( url == null || ! lr_24 . equalsIgnoreCase ( url . getProtocol () ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return null ; } String filename = url . getFile () . replace ( '/' , File . separatorChar ) ; filename = decodeUrl ( filename ) ;
throw new IOException ( lr_29 + srcDir + lr_30 + destDir + lr_31 ) ; MST[experimental.NakedReceiverMutator]MSP[N] } List < String > exclusionList = null ; if ( destDir . getCanonicalPath () . startsWith ( srcDir . getCanonicalPath () ) ) {
if ( ! src . exists () ) { throw new FileNotFoundException ( lr_29 + src + lr_8 ) ; MST[experimental.NakedReceiverMutator]MSP[N] } } private static void doCopyDirectory ( final File srcDir , final File destDir , final FileFilter filter , final boolean preserveFileDate , final List < String > exclusionList )
if ( ! directory . isDirectory () ) { throw new IllegalArgumentException ( lr_46 + directory ) ; } if ( child == null ) { return false ; } if ( ! directory . exists () || ! child . exists () ) { return false ; MST[rv.CRCR1Mutator]MSP[N] }
final byte octet = ( byte ) Integer . parseInt ( url . substring ( i + 1 , i + 3 ) , 16 ) ; MST[rv.CRCR1Mutator]MSP[N] bytes . put ( octet ) ; i += 3 ;
throw new IOException ( lr_27 + destDir + lr_32 ) ; } } if ( destDir . canWrite () == false ) { throw new IOException ( lr_27 + destDir + lr_9 ) ; } for ( final File srcFile : srcFiles ) { MST[rv.UOI3Mutator]MSP[N]
throw new IllegalArgumentException ( lr_58 ) ; } if ( ! file . exists () ) { return false ; } return file . lastModified () < timeMillis ; MST[rv.CRCR6Mutator]MSP[S] } public static long checksumCRC32 ( final File file ) throws IOException { final CRC32 crc = new CRC32 () ;
for ( int i = 0 ; i < urls . length ; i ++ ) { final URL url = urls [ i ] ; MST[rv.ABSMutator]MSP[N] if ( url != null ) { if ( url . getProtocol () . equals ( lr_24 ) == false ) {
while ( ! file . exists () ) { final long remaining = finishAt - System . currentTimeMillis () ; if ( remaining < 0 ) { MST[rv.CRCR1Mutator]MSP[N] return false ; } try { Thread . sleep ( Math . min ( 100 , remaining ) ) ;
if ( ! parentFile . mkdirs () && ! parentFile . isDirectory () ) { MST[rv.ROR3Mutator]MSP[N] throw new IOException ( lr_27 + parentFile + lr_32 ) ; } } if ( destFile . exists () && destFile . canWrite () == false ) {
final StringBuilder buffer = new StringBuilder () ; final ByteBuffer bytes = ByteBuffer . allocate ( n ) ; for ( int i = 0 ; i < n ; ) { MST[rv.UOI4Mutator]MSP[N] if ( url . charAt ( i ) == '%' ) { try { do {
File file = null ; for ( final String name : names ) { MST[rv.UOI4Mutator]MSP[S] if ( file == null ) { file = new File ( name ) ; } else { file = new File ( file , name ) ; } } return file ; }
displaySize = String . valueOf ( size . divide ( ONE_TB_BI ) ) + lr_14 ; } else if ( size . divide ( ONE_GB_BI ) . compareTo ( BigInteger . ZERO ) > 0 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N]
final File directory , final IOFileFilter fileFilter , final IOFileFilter dirFilter , final boolean includeSubDirectories ) { validateListFilesParameters ( directory , fileFilter ) ; final IOFileFilter effFileFilter = setUpEffectiveFileFilter ( fileFilter ) ; final IOFileFilter effDirFilter = setUpEffectiveDirFilter ( dirFilter ) ; MST[NonVoidMethodCallMutator]MSP[N]
displaySize = String . valueOf ( size . divide ( ONE_KB_BI ) ) + lr_17 ; } else { displaySize = String . valueOf ( size ) + lr_18 ; } return displaySize ; MST[EmptyObjectReturnValsMutator]MSP[N] } public static String byteCountToDisplaySize ( final long size ) {
final boolean filePresent = file . exists () ; if ( ! file . delete () ) { if ( ! filePresent ) { throw new FileNotFoundException ( lr_48 + file ) ; MST[NonVoidMethodCallMutator]MSP[N] } final String message = lr_49 + file ; throw new IOException ( message ) ; }
public static Collection < File > listFiles ( final File directory , final String [] extensions , final boolean recursive ) { IOFileFilter filter ; if ( extensions == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] filter = TrueFileFilter . INSTANCE ; } else {
if ( ! destDir . exists () ) { throw new FileNotFoundException ( lr_66 + destDir + lr_67 + createDestDir + lr_68 ) ; } if ( ! destDir . isDirectory () ) { throw new IOException ( lr_27 + destDir + lr_28 ) ; MST[experimental.NakedReceiverMutator]MSP[N] }
final boolean file1Exists = file1 . exists () ; if ( file1Exists != file2 . exists () ) { return false ; } if ( ! file1Exists ) { MST[rv.UOI3Mutator]MSP[S] return true ; } if ( file1 . isDirectory () || file2 . isDirectory () ) {
displaySize = String . valueOf ( size . divide ( ONE_TB_BI ) ) + lr_14 ; } else if ( size . divide ( ONE_GB_BI ) . compareTo ( BigInteger . ZERO ) > 0 ) { MST[rv.ROR5Mutator]MSP[N]
size += sizeOf0 ( file ) ; if ( size < 0 ) { break; } } } return size ; } private static long sizeOf0 ( final File file ) { if ( file . isDirectory () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return sizeOfDirectory0 ( file ) ; }
} private static void checkFileRequirements ( final File src , final File dest ) throws FileNotFoundException { if ( src == null ) { throw new NullPointerException ( lr_38 ) ; } if ( dest == null ) { MST[rv.ROR5Mutator]MSP[N] throw new NullPointerException ( lr_26 ) ; }
displaySize = String . valueOf ( size . divide ( ONE_MB_BI ) ) + lr_16 ; } else if ( size . divide ( ONE_KB_BI ) . compareTo ( BigInteger . ZERO ) > 0 ) { MST[NonVoidMethodCallMutator]MSP[N]
public static void moveToDirectory ( final File src , final File destDir , final boolean createDestDir ) throws IOException { validateMoveParameters ( src , destDir ) ; if ( src . isDirectory () ) { MST[rv.ROR2Mutator]MSP[N] moveDirectoryToDirectory ( src , destDir , createDestDir ) ; } else {
if ( file . exists () ) { if ( file . isDirectory () ) { throw new IOException ( lr_5 + file + lr_6 ) ; } if ( file . canWrite () == false ) { MST[NegateConditionalsMutator]MSP[N] throw new IOException ( lr_5 + file + lr_9 ) ; }
final File directory , final IOFileFilter fileFilter , final IOFileFilter dirFilter ) { return innerListFilesOrDirectories ( directory , fileFilter , dirFilter , false ) ; MST[ReturnValsMutator]MSP[N] } private static void validateListFilesParameters ( final File directory , final IOFileFilter fileFilter ) { if ( ! directory . isDirectory () ) {
if ( ! reference . exists () ) { MST[NonVoidMethodCallMutator]MSP[S] throw new IllegalArgumentException ( lr_55 + reference + lr_56 ) ; } return isFileOlder ( file , reference . lastModified () ) ; } public static boolean isFileOlder ( final File file , final Date date ) {
throw new IOException ( lr_23 ) ; } if ( file1 . length () != file2 . length () ) { return false ; } if ( file1 . getCanonicalFile () . equals ( file2 . getCanonicalFile () ) ) { MST[rv.ROR4Mutator]MSP[N] return true ; }
moveDirectory ( src , new File ( destDir , src . getName () ) ) ; } public static void moveFile ( final File srcFile , final File destFile ) throws IOException { validateMoveParameters ( srcFile , destFile ) ; if ( srcFile . isDirectory () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
? new InputStreamReader ( new FileInputStream ( file1 ) , Charset . defaultCharset () ) MST[ConstructorCallMutator]MSP[S] : new InputStreamReader ( new FileInputStream ( file1 ) , charsetName ) ; Reader input2 = charsetName == null ? new InputStreamReader ( new FileInputStream ( file2 ) , Charset . defaultCharset () )
for ( int i = 0 ; i < urls . length ; i ++ ) { MST[rv.CRCR6Mutator]MSP[N] final URL url = urls [ i ] ; if ( url != null ) { if ( url . getProtocol () . equals ( lr_24 ) == false ) {
throw new IOException ( lr_27 + destDir + lr_32 ) ; } } if ( destDir . canWrite () == false ) { throw new IOException ( lr_27 + destDir + lr_9 ) ; } for ( final File srcFile : srcFiles ) { MST[rv.UOI4Mutator]MSP[N]
displaySize = String . valueOf ( size . divide ( ONE_GB_BI ) ) + lr_15 ; } else if ( size . divide ( ONE_MB_BI ) . compareTo ( BigInteger . ZERO ) > 0 ) { MST[rv.ROR2Mutator]MSP[N]
if ( file == null ) { return false ; } try { if ( file . isDirectory () ) { cleanDirectory ( file ) ; } } catch ( final Exception ignored ) { } try { return file . delete () ; MST[BooleanFalseReturnValsMutator]MSP[S]
final URL [] urls = new URL [ files . length ] ; for ( int i = 0 ; i < urls . length ; i ++ ) { urls [ i ] = files [ i ] . toURI () . toURL () ; MST[rv.UOI4Mutator]MSP[S] } return urls ;
throw new IOException ( lr_40 + directory ) ; } return files ; } public static boolean waitFor ( final File file , final int seconds ) { final long finishAt = System . currentTimeMillis () + ( seconds * 1000L ) ; boolean wasInterrupted = false ; MST[rv.CRCR1Mutator]MSP[N] try {
throw new NullPointerException ( lr_38 ) ; } if ( src . isFile () ) { copyFileToDirectory ( src , destDir ) ; } else if ( src . isDirectory () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] copyDirectoryToDirectory ( src , destDir ) ; } else {
throw new IOException ( lr_29 + srcDir + lr_30 + destDir + lr_31 ) ; } List < String > exclusionList = null ; if ( destDir . getCanonicalPath () . startsWith ( srcDir . getCanonicalPath () ) ) { MST[rv.ROR3Mutator]MSP[S]
throw new IOException ( lr_23 ) ; } if ( file1 . length () != file2 . length () ) { return false ; MST[BooleanTrueReturnValsMutator]MSP[N] } if ( file1 . getCanonicalFile () . equals ( file2 . getCanonicalFile () ) ) { return true ; }
} else { final File parent = file . getParentFile () ; if ( parent != null ) { if ( ! parent . mkdirs () && ! parent . isDirectory () ) { throw new IOException ( lr_10 + parent + lr_11 ) ; MST[experimental.NakedReceiverMutator]MSP[N] } } }
throw new NullPointerException ( lr_26 ) ; } if ( destDir . exists () && destDir . isDirectory () == false ) { MST[NegateConditionalsMutator]MSP[N] throw new IllegalArgumentException ( lr_27 + destDir + lr_28 ) ; }
return isFileNewer ( file , date . getTime () ) ; MST[NonVoidMethodCallMutator]MSP[N] } public static boolean isFileNewer ( final File file , final long timeMillis ) { if ( file == null ) { throw new IllegalArgumentException ( lr_58 ) ; } if ( ! file . exists () ) {
try { if ( in != null ) { MST[NegateConditionalsMutator]MSP[S] in . close () ; } } catch ( final IOException e ) { ex . addSuppressed ( e ) ; } throw ex ; } } public static LineIterator lineIterator ( final File file ) throws IOException {
size += sizeOf0 ( file ) ; if ( size < 0 ) { MST[rv.ROR1Mutator]MSP[N] break; } } } return size ; } private static long sizeOf0 ( final File file ) { if ( file . isDirectory () ) { return sizeOfDirectory0 ( file ) ; }
final boolean filePresent = file . exists () ; if ( ! file . delete () ) { if ( ! filePresent ) { MST[rv.ABSMutator]MSP[N] throw new FileNotFoundException ( lr_48 + file ) ; } final String message = lr_49 + file ; throw new IOException ( message ) ; }
} public static void forceMkdirParent ( final File file ) throws IOException { final File parent = file . getParentFile () ; if ( parent == null ) { MST[rv.ROR5Mutator]MSP[N] return; } forceMkdir ( parent ) ; } public static long sizeOf ( final File file ) {
final StringBuilder buffer = new StringBuilder () ; final ByteBuffer bytes = ByteBuffer . allocate ( n ) ; for ( int i = 0 ; i < n ; ) { MST[InlineConstantMutator]MSP[N] if ( url . charAt ( i ) == '%' ) { try { do {
throw new IOException ( lr_27 + destFile + lr_6 ) ; } final Path srcPath = srcFile . toPath () ; final Path destPath = destFile . toPath () ; final long newLastModifed = preserveFileDate ? srcFile . lastModified () : destFile . lastModified () ; MST[rv.UOI3Mutator]MSP[S]
final int connectionTimeout , final int readTimeout ) throws IOException { final URLConnection connection = source . openConnection () ; connection . setConnectTimeout ( connectionTimeout ) ; MST[rv.ABSMutator]MSP[S] connection . setReadTimeout ( readTimeout ) ; copyInputStreamToFile ( connection . getInputStream () , destination ) ; }
try ( OutputStream out = openOutputStream ( file , append ) ) { out . write ( data , off , len ) ; MST[rv.UOI3Mutator]MSP[N] } } public static void writeLines ( final File file , final String encoding , final Collection < ? > lines ) throws IOException {
final boolean rename = srcDir . renameTo ( destDir ) ; if ( ! rename ) { if ( destDir . getCanonicalPath () . startsWith ( srcDir . getCanonicalPath () + File . separator ) ) { MST[NonVoidMethodCallMutator]MSP[N] throw new IOException ( lr_61 + srcDir + lr_62 + destDir ) ;
throw new IOException ( lr_40 + directory ) ; MST[ConstructorCallMutator]MSP[S] } return files ; } public static boolean waitFor ( final File file , final int seconds ) { final long finishAt = System . currentTimeMillis () + ( seconds * 1000L ) ; boolean wasInterrupted = false ; try {
if ( srcLen != dstLen ) { MST[rv.UOI4Mutator]MSP[N] throw new IOException ( lr_34 + srcFile + lr_35 + destFile + lr_36 + srcLen + lr_37 + dstLen ) ; } } public static void copyDirectoryToDirectory ( final File srcDir , final File destDir ) throws IOException {
} while ( i < n && url . charAt ( i ) == '%' ); MST[rv.UOI3Mutator]MSP[N] continue; } catch ( final RuntimeException e ) { } finally { if ( bytes . position () > 0 ) { bytes . flip () ;
if ( url == null || ! lr_24 . equalsIgnoreCase ( url . getProtocol () ) ) { MST[rv.ROR3Mutator]MSP[N] return null ; } String filename = url . getFile () . replace ( '/' , File . separatorChar ) ; filename = decodeUrl ( filename ) ;
displaySize = String . valueOf ( size . divide ( ONE_EB_BI ) ) + lr_12 ; MST[experimental.BigIntegerMutator]MSP[N] } else if ( size . divide ( ONE_PB_BI ) . compareTo ( BigInteger . ZERO ) > 0 ) {
throws IOException { final boolean file1Exists = file1 . exists () ; if ( file1Exists != file2 . exists () ) { return false ; } if ( ! file1Exists ) { return true ; } if ( file1 . isDirectory () || file2 . isDirectory () ) { MST[NegateConditionalsMutator]MSP[S]
writeLines ( file , encoding , lines , null , append ) ; } public static void writeLines ( final File file , final Collection < ? > lines ) throws IOException { writeLines ( file , null , lines , null , false ) ; MST[rv.CRCR5Mutator]MSP[N] }
final boolean rename = srcDir . renameTo ( destDir ) ; if ( ! rename ) { if ( destDir . getCanonicalPath () . startsWith ( srcDir . getCanonicalPath () + File . separator ) ) { MST[experimental.NakedReceiverMutator]MSP[N] throw new IOException ( lr_61 + srcDir + lr_62 + destDir ) ;
if ( ! reference . exists () ) { throw new IllegalArgumentException ( lr_55 + reference + lr_56 ) ; } return isFileOlder ( file , reference . lastModified () ) ; MST[BooleanTrueReturnValsMutator]MSP[S] } public static boolean isFileOlder ( final File file , final Date date ) {
displaySize = String . valueOf ( size . divide ( ONE_MB_BI ) ) + lr_16 ; } else if ( size . divide ( ONE_KB_BI ) . compareTo ( BigInteger . ZERO ) > 0 ) { MST[experimental.NakedReceiverMutator]MSP[N]
final byte octet = ( byte ) Integer . parseInt ( url . substring ( i + 1 , i + 3 ) , 16 ) ; MST[rv.CRCR5Mutator]MSP[N] bytes . put ( octet ) ; i += 3 ;
writeStringToFile ( file , data , Charset . defaultCharset () , false ) ; MST[rv.CRCR3Mutator]MSP[N] } @Deprecated public static void writeStringToFile ( final File file , final String data , final boolean append ) throws IOException { writeStringToFile ( file , data , Charset . defaultCharset () , append ) ;
final String [] suffixes = new String [ extensions . length ] ; for ( int i = 0 ; i < extensions . length ; i ++ ) { MST[rv.CRCR6Mutator]MSP[N] suffixes [ i ] = lr_22 + extensions [ i ] ; } return suffixes ; }
final File dstFile = new File ( destDir , srcFile . getName () ) ; if ( exclusionList == null || ! exclusionList . contains ( srcFile . getCanonicalPath () ) ) { MST[rv.ROR3Mutator]MSP[N] if ( srcFile . isDirectory () ) {
return isFileNewer ( file , reference . lastModified () ) ; MST[BooleanFalseReturnValsMutator]MSP[S] } public static boolean isFileNewer ( final File file , final Date date ) { if ( date == null ) { throw new IllegalArgumentException ( lr_57 ) ; }
throw new NullPointerException ( lr_26 ) ; } if ( ! src . exists () ) { throw new FileNotFoundException ( lr_29 + src + lr_8 ) ; MST[NonVoidMethodCallMutator]MSP[N] } } public static boolean isSymlink ( final File file ) { if ( file == null ) {
final boolean rename = srcDir . renameTo ( destDir ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( ! rename ) { if ( destDir . getCanonicalPath () . startsWith ( srcDir . getCanonicalPath () + File . separator ) ) { throw new IOException ( lr_61 + srcDir + lr_62 + destDir ) ;
displaySize = String . valueOf ( size . divide ( ONE_MB_BI ) ) + lr_16 ; } else if ( size . divide ( ONE_KB_BI ) . compareTo ( BigInteger . ZERO ) > 0 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N]
return new File ( filename ) ; } static String decodeUrl ( final String url ) { String decoded = url ; if ( url != null && url . indexOf ( '%' ) >= 0 ) { MST[rv.CRCR3Mutator]MSP[N] final int n = url . length () ;
final boolean filePresent = file . exists () ; if ( ! file . delete () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] if ( ! filePresent ) { throw new FileNotFoundException ( lr_48 + file ) ; } final String message = lr_49 + file ; throw new IOException ( message ) ; }
while ( ! file . exists () ) { final long remaining = finishAt - System . currentTimeMillis () ; if ( remaining < 0 ) { MST[rv.UOI2Mutator]MSP[N] return false ; } try { Thread . sleep ( Math . min ( 100 , remaining ) ) ;
final File [] srcFiles = filter == null ? srcDir . listFiles () : srcDir . listFiles ( filter ) ; if ( srcFiles != null && srcFiles . length > 0 ) { MST[NegateConditionalsMutator]MSP[S] exclusionList = new ArrayList <> ( srcFiles . length ) ;
File file = null ; for ( final String name : names ) { if ( file == null ) { MST[NegateConditionalsMutator]MSP[S] file = new File ( name ) ; } else { file = new File ( file , name ) ; } } return file ; }
checkEqualSizes ( srcFile , destFile , srcFile . length () , destFile . length () ) ; destFile . setLastModified ( newLastModifed ) ; MST[rv.UOI4Mutator]MSP[N] } private static void checkEqualSizes ( final File srcFile , final File destFile , final long srcLen , final long dstLen ) throws IOException {
private static void checkDirectory ( final File directory ) { if ( ! directory . exists () ) { throw new IllegalArgumentException ( directory + lr_42 ) ; } if ( ! directory . isDirectory () ) { throw new IllegalArgumentException ( directory + lr_47 ) ; MST[experimental.NakedReceiverMutator]MSP[N] } }
checksum ( file , crc ) ; return crc . getValue () ; } public static Checksum checksum ( final File file , final Checksum checksum ) throws IOException { if ( file . isDirectory () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] throw new IllegalArgumentException ( lr_59 ) ; }
validateMoveParameters ( srcFile , destDir ) ; if ( ! destDir . exists () && createDestDir ) { MST[rv.ABSMutator]MSP[N] destDir . mkdirs () ; } if ( ! destDir . exists () ) { throw new FileNotFoundException ( lr_66 + destDir + lr_67 + createDestDir + lr_68 ) ; }
return fileLength > 0 ? IOUtils . toByteArray ( in , fileLength ) : IOUtils . toByteArray ( in ) ; MST[rv.UOI1Mutator]MSP[S] } } public static List < String > readLines ( final File file , final Charset encoding ) throws IOException {
final StringBuilder buffer = new StringBuilder () ; final ByteBuffer bytes = ByteBuffer . allocate ( n ) ; for ( int i = 0 ; i < n ; ) { MST[rv.UOI1Mutator]MSP[N] if ( url . charAt ( i ) == '%' ) { try { do {
public static void write ( final File file , final CharSequence data , final boolean append ) throws IOException { write ( file , data , Charset . defaultCharset () , append ) ; MST[rv.UOI3Mutator]MSP[S] }
writeLines ( file , encoding , lines , null , append ) ; MST[rv.ABSMutator]MSP[N] } public static void writeLines ( final File file , final Collection < ? > lines ) throws IOException { writeLines ( file , null , lines , null , false ) ; }
if ( ! directory . exists () ) { return; } directory . deleteOnExit () ; if ( ! isSymlink ( directory ) ) { MST[rv.ROR3Mutator]MSP[N] cleanDirectoryOnExit ( directory ) ; } } private static void cleanDirectoryOnExit ( final File directory ) throws IOException {
if ( srcDir == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] throw new NullPointerException ( lr_38 ) ; } if ( srcDir . exists () && srcDir . isDirectory () == false ) { throw new IllegalArgumentException ( lr_29 + destDir + lr_28 ) ; } if ( destDir == null ) {
throw new IOException ( lr_40 + directory ) ; } return files ; } public static boolean waitFor ( final File file , final int seconds ) { final long finishAt = System . currentTimeMillis () + ( seconds * 1000L ) ; MST[rv.CRCR5Mutator]MSP[N] boolean wasInterrupted = false ; try {
final URL [] urls = new URL [ files . length ] ; for ( int i = 0 ; i < urls . length ; i ++ ) { MST[rv.ROR3Mutator]MSP[N] urls [ i ] = files [ i ] . toURI () . toURL () ; } return urls ;
size += sizeOf0 ( file ) ; if ( size < 0 ) { break; } } } return size ; } private static long sizeOf0 ( final File file ) { if ( file . isDirectory () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return sizeOfDirectory0 ( file ) ; }
if ( files == null ) { return BigInteger . ZERO ; } BigInteger size = BigInteger . ZERO ; for ( final File file : files ) { MST[rv.UOI4Mutator]MSP[S] if ( ! isSymlink ( file ) ) { size = size . add ( sizeOfBig0 ( file ) ) ;
final StringBuilder buffer = new StringBuilder () ; final ByteBuffer bytes = ByteBuffer . allocate ( n ) ; for ( int i = 0 ; i < n ; ) { if ( url . charAt ( i ) == '%' ) { MST[rv.UOI3Mutator]MSP[N] try { do {
final boolean success = file . setLastModified ( System . currentTimeMillis () ) ; if ( ! success ) { MST[rv.ROR3Mutator]MSP[N] throw new IOException ( lr_19 + file ) ; } } public static File [] convertFileCollectionToFileArray ( final Collection < File > files ) {
return file . length () ; } public static BigInteger sizeOfDirectoryAsBigInteger ( final File directory ) { checkDirectory ( directory ) ; MST[VoidMethodCallMutator]MSP[S] return sizeOfDirectoryBig0 ( directory ) ; } private static BigInteger sizeOfDirectoryBig0 ( final File directory ) { final File [] files = directory . listFiles () ;
return FileFilterUtils . and ( fileFilter , FileFilterUtils . notFileFilter ( DirectoryFileFilter . INSTANCE ) ) ; MST[rv.CRCR5Mutator]MSP[N] } private static IOFileFilter setUpEffectiveDirFilter ( final IOFileFilter dirFilter ) { return dirFilter == null ? FalseFileFilter . INSTANCE : FileFilterUtils . and ( dirFilter , DirectoryFileFilter . INSTANCE ) ; }
displaySize = String . valueOf ( size . divide ( ONE_PB_BI ) ) + lr_13 ; MST[ConstructorCallMutator]MSP[N] } else if ( size . divide ( ONE_TB_BI ) . compareTo ( BigInteger . ZERO ) > 0 ) {
} while ( i < n && url . charAt ( i ) == '%' ); MST[rv.ROR3Mutator]MSP[N] continue; } catch ( final RuntimeException e ) { } finally { if ( bytes . position () > 0 ) { bytes . flip () ;
public static BigInteger sizeOfAsBigInteger ( final File file ) { if ( ! file . exists () ) { final String message = file + lr_42 ; throw new IllegalArgumentException ( message ) ; } if ( file . isDirectory () ) { MST[NegateConditionalsMutator]MSP[N] return sizeOfDirectoryBig0 ( file ) ; }
throw new IOException ( lr_29 + srcFile + lr_69 ) ; } if ( destFile . exists () ) { throw new FileExistsException ( lr_27 + destFile + lr_60 ) ; } if ( destFile . isDirectory () ) { MST[rv.ROR5Mutator]MSP[N]
displaySize = String . valueOf ( size . divide ( ONE_TB_BI ) ) + lr_14 ; } else if ( size . divide ( ONE_GB_BI ) . compareTo ( BigInteger . ZERO ) > 0 ) { MST[NonVoidMethodCallMutator]MSP[N]
final File directory , final String [] extensions , final boolean recursive ) { return listFiles ( directory , extensions , recursive ) . iterator () ; MST[rv.UOI4Mutator]MSP[S] } public static boolean contentEquals ( final File file1 , final File file2 ) throws IOException {
throw new IOException ( lr_40 + directory ) ; MST[NonVoidMethodCallMutator]MSP[S] } return files ; } public static boolean waitFor ( final File file , final int seconds ) { final long finishAt = System . currentTimeMillis () + ( seconds * 1000L ) ; boolean wasInterrupted = false ; try {
} catch ( final InterruptedException ignore ) { wasInterrupted = true ; } catch ( final Exception ex ) { break; } } } finally { if ( wasInterrupted ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] Thread . currentThread () . interrupt () ; } } return true ; }
writeByteArrayToFile ( file , data , off , len , false ) ; MST[rv.ABSMutator]MSP[S] } public static void writeByteArrayToFile ( final File file , final byte [] data , final int off , final int len , final boolean append ) throws IOException {
final Collection < File > files = new java . util . LinkedList <> () ; if ( includeSubDirectories ) { files . add ( directory ) ; } innerListFiles ( files , directory , MST[rv.CRCR4Mutator]MSP[N] FileFilterUtils . or ( effFileFilter , effDirFilter ) , includeSubDirectories ) ; return files ;
throw new IllegalArgumentException ( lr_58 ) ; } if ( ! file . exists () ) { return false ; } return file . lastModified () < timeMillis ; MST[rv.UOI3Mutator]MSP[N] } public static long checksumCRC32 ( final File file ) throws IOException { final CRC32 crc = new CRC32 () ;
if ( ! destDir . exists () ) { throw new FileNotFoundException ( lr_66 + destDir + lr_67 + createDestDir + lr_68 ) ; } if ( ! destDir . isDirectory () ) { throw new IOException ( lr_27 + destDir + lr_28 ) ; MST[NonVoidMethodCallMutator]MSP[N] }
return FileFilterUtils . and ( fileFilter , FileFilterUtils . notFileFilter ( DirectoryFileFilter . INSTANCE ) ) ; } private static IOFileFilter setUpEffectiveDirFilter ( final IOFileFilter dirFilter ) { return dirFilter == null ? FalseFileFilter . INSTANCE : FileFilterUtils . and ( dirFilter , MST[rv.CRCR3Mutator]MSP[N] DirectoryFileFilter . INSTANCE ) ; }
public static File getUserDirectory () { return new File ( getUserDirectoryPath () ) ; } public static FileInputStream openInputStream ( final File file ) throws IOException { if ( file . exists () ) { if ( file . isDirectory () ) { MST[rv.ROR4Mutator]MSP[N]
writeLines ( file , encoding , lines , null , false ) ; MST[rv.CRCR5Mutator]MSP[N] } public static void writeLines ( final File file , final String encoding , final Collection < ? > lines , final boolean append ) throws IOException {
validateMoveParameters ( srcDir , destDir ) ; if ( ! srcDir . isDirectory () ) { throw new IOException ( lr_29 + srcDir + lr_28 ) ; } if ( destDir . exists () ) { MST[rv.ROR2Mutator]MSP[N] throw new FileExistsException ( lr_27 + destDir + lr_60 ) ; }
final File dstFile = new File ( destDir , srcFile . getName () ) ; if ( exclusionList == null || ! exclusionList . contains ( srcFile . getCanonicalPath () ) ) { if ( srcFile . isDirectory () ) { MST[rv.ROR5Mutator]MSP[N]
public static void moveDirectoryToDirectory ( final File src , final File destDir , final boolean createDestDir ) throws IOException { validateMoveParameters ( src , destDir ) ; if ( ! destDir . exists () && createDestDir ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] destDir . mkdirs () ; }
return file . length () ; MST[PrimitiveReturnsMutator]MSP[N] } public static BigInteger sizeOfDirectoryAsBigInteger ( final File directory ) { checkDirectory ( directory ) ; return sizeOfDirectoryBig0 ( directory ) ; } private static BigInteger sizeOfDirectoryBig0 ( final File directory ) { final File [] files = directory . listFiles () ;
final File [] found = directory . listFiles ( ( FileFilter ) filter ) ; if ( found != null ) { for ( final File file : found ) { MST[rv.UOI1Mutator]MSP[N] if ( file . isDirectory () ) { if ( includeSubDirectories ) {
if ( srcLen != dstLen ) { throw new IOException ( lr_34 + srcFile + lr_35 + destFile MST[experimental.NakedReceiverMutator]MSP[N] + lr_36 + srcLen + lr_37 + dstLen ) ; } } public static void copyDirectoryToDirectory ( final File srcDir , final File destDir ) throws IOException {
throw new IOException ( lr_23 ) ; } if ( file1 . getCanonicalFile () . equals ( file2 . getCanonicalFile () ) ) { MST[rv.ROR2Mutator]MSP[N] return true ; } try ( Reader input1 = charsetName == null
final boolean file1Exists = file1 . exists () ; if ( file1Exists != file2 . exists () ) { MST[rv.ROR1Mutator]MSP[N] return false ; } if ( ! file1Exists ) { return true ; } if ( file1 . isDirectory () || file2 . isDirectory () ) {
final int connectionTimeout , final int readTimeout ) throws IOException { final URLConnection connection = source . openConnection () ; connection . setConnectTimeout ( connectionTimeout ) ; connection . setReadTimeout ( readTimeout ) ; MST[rv.UOI1Mutator]MSP[N] copyInputStreamToFile ( connection . getInputStream () , destination ) ; }
displaySize = String . valueOf ( size . divide ( ONE_EB_BI ) ) + lr_12 ; } else if ( size . divide ( ONE_PB_BI ) . compareTo ( BigInteger . ZERO ) > 0 ) { MST[ConditionalsBoundaryMutator]MSP[N]
throw new IllegalArgumentException ( lr_58 ) ; } if ( ! file . exists () ) { return false ; } return file . lastModified () < timeMillis ; MST[rv.CRCR3Mutator]MSP[N] } public static long checksumCRC32 ( final File file ) throws IOException { final CRC32 crc = new CRC32 () ;
final boolean file1Exists = file1 . exists () ; if ( file1Exists != file2 . exists () ) { return false ; } if ( ! file1Exists ) { return true ; MST[rv.CRCR2Mutator]MSP[S] } if ( file1 . isDirectory () || file2 . isDirectory () ) {
return false ; } return file . lastModified () > timeMillis ; MST[NegateConditionalsMutator]MSP[N] } public static boolean isFileOlder ( final File file , final File reference ) { if ( reference == null ) { throw new IllegalArgumentException ( lr_54 ) ; }
final String [] suffixes = toSuffixes ( extensions ) ; MST[NonVoidMethodCallMutator]MSP[N] filter = new SuffixFileFilter ( suffixes ) ; } return listFiles ( directory , filter , recursive ? TrueFileFilter . INSTANCE : FalseFileFilter . INSTANCE ) ; } public static Iterator < File > iterateFiles (
if ( url == null || ! lr_24 . equalsIgnoreCase ( url . getProtocol () ) ) { MST[NonVoidMethodCallMutator]MSP[N] return null ; } String filename = url . getFile () . replace ( '/' , File . separatorChar ) ; filename = decodeUrl ( filename ) ;
if ( ! destDir . isDirectory () ) { throw new IOException ( lr_27 + destDir + lr_28 ) ; MST[NonVoidMethodCallMutator]MSP[S] } moveFile ( srcFile , new File ( destDir , srcFile . getName () ) ) ; }
public static void write ( final File file , final CharSequence data , final Charset encoding , final boolean append ) throws IOException { final String str = data == null ? null : data . toString () ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] writeStringToFile ( file , str , encoding , append ) ;
} public static void copyFile ( final File srcFile , final File destFile , final boolean preserveFileDate ) throws IOException { checkFileRequirements ( srcFile , destFile ) ; if ( srcFile . isDirectory () ) { MST[rv.ROR3Mutator]MSP[N] throw new IOException ( lr_29 + srcFile + lr_6 ) ; }
final int connectionTimeout , final int readTimeout ) throws IOException { final URLConnection connection = source . openConnection () ; connection . setConnectTimeout ( connectionTimeout ) ; MST[VoidMethodCallMutator]MSP[N] connection . setReadTimeout ( readTimeout ) ; copyInputStreamToFile ( connection . getInputStream () , destination ) ; }
if ( ! directory . isDirectory () ) { throw new IllegalArgumentException ( lr_46 + directory ) ; } if ( child == null ) { return false ; } if ( ! directory . exists () || ! child . exists () ) { MST[NegateConditionalsMutator]MSP[S] return false ; }
final File [] files = verifiedListFiles ( directory ) ; IOException exception = null ; for ( final File file : files ) { MST[rv.ABSMutator]MSP[S] try { forceDeleteOnExit ( file ) ; } catch ( final IOException ioe ) { exception = ioe ; } }
public static void writeLines ( final File file , final Collection < ? > lines , final boolean append ) throws IOException { writeLines ( file , null , lines , null , append ) ; MST[rv.UOI3Mutator]MSP[S] }
throws IOException { final boolean file1Exists = file1 . exists () ; if ( file1Exists != file2 . exists () ) { return false ; } if ( ! file1Exists ) { MST[rv.ABSMutator]MSP[N] return true ; } if ( file1 . isDirectory () || file2 . isDirectory () ) {
} catch ( final Exception ignored ) { return false ; MST[ReturnValsMutator]MSP[S] } } public static boolean directoryContains ( final File directory , final File child ) throws IOException { if ( directory == null ) { throw new IllegalArgumentException ( lr_45 ) ; }
final File [] srcFiles = filter == null ? srcDir . listFiles () : srcDir . listFiles ( filter ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] if ( srcFiles != null && srcFiles . length > 0 ) { exclusionList = new ArrayList <> ( srcFiles . length ) ;
throw new IOException ( lr_23 ) ; } if ( file1 . length () != file2 . length () ) { return false ; } if ( file1 . getCanonicalFile () . equals ( file2 . getCanonicalFile () ) ) { return true ; MST[rv.CRCR5Mutator]MSP[N] }
final File [] found = directory . listFiles ( ( FileFilter ) filter ) ; if ( found != null ) { for ( final File file : found ) { if ( file . isDirectory () ) { MST[rv.ROR4Mutator]MSP[N] if ( includeSubDirectories ) {
final File destFile = new File ( destDir , srcFile . getName () ) ; copyFile ( srcFile , destFile , preserveFileDate ) ; } public static void copyFile ( final File srcFile , final File destFile ) throws IOException { copyFile ( srcFile , destFile , true ) ; MST[rv.CRCR4Mutator]MSP[N]
final byte octet = ( byte ) Integer . parseInt ( url . substring ( i + 1 , i + 3 ) , 16 ) ; MST[rv.CRCR6Mutator]MSP[N] bytes . put ( octet ) ; i += 3 ;
writeByteArrayToFile ( file , data , off , len , false ) ; MST[rv.UOI3Mutator]MSP[N] } public static void writeByteArrayToFile ( final File file , final byte [] data , final int off , final int len , final boolean append ) throws IOException {
final Collection < File > files = new java . util . LinkedList <> () ; if ( includeSubDirectories ) { files . add ( directory ) ; } innerListFiles ( files , directory , MST[rv.CRCR5Mutator]MSP[N] FileFilterUtils . or ( effFileFilter , effDirFilter ) , includeSubDirectories ) ; return files ;
if ( ! file . exists () ) { final String message = file + lr_42 ; throw new IllegalArgumentException ( message ) ; } if ( file . isDirectory () ) { MST[NegateConditionalsMutator]MSP[N] return sizeOfDirectory0 ( file ) ; } return file . length () ; }
throws IOException { final boolean file1Exists = file1 . exists () ; if ( file1Exists != file2 . exists () ) { return false ; } if ( ! file1Exists ) { return true ; } if ( file1 . isDirectory () || file2 . isDirectory () ) { MST[rv.ROR2Mutator]MSP[N]
throws IOException { final boolean file1Exists = file1 . exists () ; if ( file1Exists != file2 . exists () ) { return false ; } if ( ! file1Exists ) { return true ; } if ( file1 . isDirectory () || file2 . isDirectory () ) { MST[rv.ROR1Mutator]MSP[N]
for ( final String name : names ) { file = new File ( file , name ) ; } return file ; } public static File getFile ( final String ... names ) { if ( names == null ) { MST[NegateConditionalsMutator]MSP[S] throw new NullPointerException ( lr_2 ) ; }
return fileLength > 0 ? IOUtils . toByteArray ( in , fileLength ) : IOUtils . toByteArray ( in ) ; MST[rv.CRCR6Mutator]MSP[N] } } public static List < String > readLines ( final File file , final Charset encoding ) throws IOException {
final String [] suffixes = new String [ extensions . length ] ; for ( int i = 0 ; i < extensions . length ; i ++ ) { MST[rv.CRCR3Mutator]MSP[N] suffixes [ i ] = lr_22 + extensions [ i ] ; } return suffixes ; }
if ( srcFile . getCanonicalPath () . equals ( destFile . getCanonicalPath () ) ) { MST[NonVoidMethodCallMutator]MSP[N] throw new IOException ( lr_29 + srcFile + lr_30 + destFile + lr_31 ) ; } final File parentFile = destFile . getParentFile () ; if ( parentFile != null ) {
final boolean file1Exists = file1 . exists () ; if ( file1Exists != file2 . exists () ) { MST[rv.ROR4Mutator]MSP[N] return false ; } if ( ! file1Exists ) { return true ; } if ( file1 . isDirectory () || file2 . isDirectory () ) {
throw new IllegalArgumentException ( lr_58 ) ; MST[ConstructorCallMutator]MSP[S] } if ( ! file . exists () ) { return false ; } return file . lastModified () < timeMillis ; } public static long checksumCRC32 ( final File file ) throws IOException { final CRC32 crc = new CRC32 () ;
final boolean file1Exists = file1 . exists () ; MST[NonVoidMethodCallMutator]MSP[N] if ( file1Exists != file2 . exists () ) { return false ; } if ( ! file1Exists ) { return true ; } if ( file1 . isDirectory () || file2 . isDirectory () ) {
displaySize = String . valueOf ( size . divide ( ONE_PB_BI ) ) + lr_13 ; MST[NonVoidMethodCallMutator]MSP[N] } else if ( size . divide ( ONE_TB_BI ) . compareTo ( BigInteger . ZERO ) > 0 ) {
if ( file == null ) { MST[rv.ROR5Mutator]MSP[N] return false ; } try { if ( file . isDirectory () ) { cleanDirectory ( file ) ; } } catch ( final Exception ignored ) { } try { return file . delete () ;
for ( int i = 0 ; i < urls . length ; i ++ ) { final URL url = urls [ i ] ; if ( url != null ) { if ( url . getProtocol () . equals ( lr_24 ) == false ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S]
if ( ! file . exists () ) { final String message = file + lr_42 ; throw new IllegalArgumentException ( message ) ; } if ( file . isDirectory () ) { return sizeOfDirectory0 ( file ) ; } return file . length () ; MST[NonVoidMethodCallMutator]MSP[N] }
if ( ! directory . isDirectory () ) { throw new IllegalArgumentException ( lr_46 + directory ) ; } if ( child == null ) { return false ; } if ( ! directory . exists () || ! child . exists () ) { return false ; MST[InlineConstantMutator]MSP[N] }
while ( ! file . exists () ) { final long remaining = finishAt - System . currentTimeMillis () ; if ( remaining < 0 ) { MST[NegateConditionalsMutator]MSP[N] return false ; } try { Thread . sleep ( Math . min ( 100 , remaining ) ) ;
final File [] files = directory . listFiles () ; if ( files == null ) { return 0L ; } long size = 0 ; for ( final File file : files ) { MST[rv.UOI4Mutator]MSP[N] if ( ! isSymlink ( file ) ) {
for ( final String name : names ) { MST[rv.UOI2Mutator]MSP[S] file = new File ( file , name ) ; } return file ; } public static File getFile ( final String ... names ) { if ( names == null ) { throw new NullPointerException ( lr_2 ) ; }
validateMoveParameters ( srcFile , destDir ) ; if ( ! destDir . exists () && createDestDir ) { destDir . mkdirs () ; } if ( ! destDir . exists () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] throw new FileNotFoundException ( lr_66 + destDir + lr_67 + createDestDir + lr_68 ) ; }
final File directory , final IOFileFilter fileFilter , final IOFileFilter dirFilter ) { return innerListFilesOrDirectories ( directory , fileFilter , dirFilter , false ) ; MST[NonVoidMethodCallMutator]MSP[N] } private static void validateListFilesParameters ( final File directory , final IOFileFilter fileFilter ) { if ( ! directory . isDirectory () ) {
final File dstFile = new File ( destDir , srcFile . getName () ) ; if ( exclusionList == null || ! exclusionList . contains ( srcFile . getCanonicalPath () ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] if ( srcFile . isDirectory () ) {
} else { final File parent = file . getParentFile () ; if ( parent != null ) { MST[NegateConditionalsMutator]MSP[N] if ( ! parent . mkdirs () && ! parent . isDirectory () ) { throw new IOException ( lr_10 + parent + lr_11 ) ; } } }
public static boolean isFileNewer ( final File file , final File reference ) { if ( reference == null ) { MST[rv.ROR5Mutator]MSP[N] throw new IllegalArgumentException ( lr_54 ) ; } if ( ! reference . exists () ) { throw new IllegalArgumentException ( lr_55 + reference + lr_56 ) ; }
} @Deprecated public static void write ( final File file , final CharSequence data ) throws IOException { write ( file , data , Charset . defaultCharset () , false ) ; MST[InlineConstantMutator]MSP[N] } @Deprecated
final byte octet = ( byte ) Integer . parseInt ( url . substring ( i + 1 , i + 3 ) , 16 ) ; MST[rv.CRCR2Mutator]MSP[N] bytes . put ( octet ) ; i += 3 ;
if ( null != exception ) { throw exception ; } } public static void forceMkdir ( final File directory ) throws IOException { if ( directory . exists () ) { if ( ! directory . isDirectory () ) { MST[NonVoidMethodCallMutator]MSP[N] final String message = lr_50 + directory + lr_51
if ( destDir == null ) { throw new NullPointerException ( lr_26 ) ; } if ( destDir . exists () && destDir . isDirectory () == false ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] throw new IllegalArgumentException ( lr_27 + destDir + lr_28 ) ; }
throw new IOException ( lr_40 + directory ) ; } return files ; } public static boolean waitFor ( final File file , final int seconds ) { final long finishAt = System . currentTimeMillis () + ( seconds * 1000L ) ; MST[rv.CRCR2Mutator]MSP[N] boolean wasInterrupted = false ; try {
if ( url == null || ! lr_24 . equalsIgnoreCase ( url . getProtocol () ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] return null ; } String filename = url . getFile () . replace ( '/' , File . separatorChar ) ; filename = decodeUrl ( filename ) ;
return FileFilterUtils . and ( fileFilter , FileFilterUtils . notFileFilter ( DirectoryFileFilter . INSTANCE ) ) ; } private static IOFileFilter setUpEffectiveDirFilter ( final IOFileFilter dirFilter ) { return dirFilter == null ? FalseFileFilter . INSTANCE : FileFilterUtils . and ( dirFilter , MST[rv.CRCR2Mutator]MSP[N] DirectoryFileFilter . INSTANCE ) ; }
try ( InputStream in = openInputStream ( file ) ) { return IOUtils . readLines ( in , Charsets . toCharset ( encoding ) ) ; MST[ArgumentPropagationMutator]MSP[N] } } public static List < String > readLines ( final File file , final String encoding ) throws IOException {
final File [] found = directory . listFiles ( ( FileFilter ) filter ) ; if ( found != null ) { for ( final File file : found ) { MST[rv.UOI4Mutator]MSP[N] if ( file . isDirectory () ) { if ( includeSubDirectories ) {
public static BigInteger sizeOfAsBigInteger ( final File file ) { if ( ! file . exists () ) { final String message = file + lr_42 ; MST[experimental.NakedReceiverMutator]MSP[N] throw new IllegalArgumentException ( message ) ; } if ( file . isDirectory () ) { return sizeOfDirectoryBig0 ( file ) ; }
return IOUtils . copyLarge ( fis , output ) ; } } private static void doCopyFile ( final File srcFile , final File destFile , final boolean preserveFileDate ) throws IOException { if ( destFile . exists () && destFile . isDirectory () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
if ( null != exception ) { MST[rv.ROR5Mutator]MSP[S] throw exception ; } } public static void forceMkdir ( final File directory ) throws IOException { if ( directory . exists () ) { if ( ! directory . isDirectory () ) { final String message = lr_50 + directory + lr_51
throw new NullPointerException ( lr_26 ) ; } if ( destDir . exists () && destDir . isDirectory () == false ) { MST[rv.ROR1Mutator]MSP[N] throw new IllegalArgumentException ( lr_27 + destDir + lr_28 ) ; }
if ( srcFile . getCanonicalPath () . equals ( destFile . getCanonicalPath () ) ) { throw new IOException ( lr_29 + srcFile + lr_30 + destFile + lr_31 ) ; MST[NonVoidMethodCallMutator]MSP[S] } final File parentFile = destFile . getParentFile () ; if ( parentFile != null ) {
if ( ! file . exists () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] final String message = file + lr_42 ; throw new IllegalArgumentException ( message ) ; } if ( file . isDirectory () ) { return sizeOfDirectory0 ( file ) ; } return file . length () ; }
for ( final String name : names ) { MST[rv.UOI3Mutator]MSP[S] file = new File ( file , name ) ; } return file ; } public static File getFile ( final String ... names ) { if ( names == null ) { throw new NullPointerException ( lr_2 ) ; }
Files . copy ( srcPath , destPath , StandardCopyOption . REPLACE_EXISTING ) ; MST[rv.CRCR6Mutator]MSP[N] checkEqualSizes ( srcFile , destFile , Files . size ( srcPath ) , Files . size ( destPath ) ) ;
if ( ! destDir . isDirectory () ) { throw new IOException ( lr_27 + destDir + lr_28 ) ; } moveFile ( srcFile , new File ( destDir , srcFile . getName () ) ) ; MST[ConstructorCallMutator]MSP[N] }
displaySize = String . valueOf ( size . divide ( ONE_MB_BI ) ) + lr_16 ; } else if ( size . divide ( ONE_KB_BI ) . compareTo ( BigInteger . ZERO ) > 0 ) { MST[ArgumentPropagationMutator]MSP[N]
public static BigInteger sizeOfAsBigInteger ( final File file ) { if ( ! file . exists () ) { final String message = file + lr_42 ; MST[NonVoidMethodCallMutator]MSP[S] throw new IllegalArgumentException ( message ) ; } if ( file . isDirectory () ) { return sizeOfDirectoryBig0 ( file ) ; }
if ( srcDir == null ) { throw new NullPointerException ( lr_38 ) ; } if ( srcDir . exists () && srcDir . isDirectory () == false ) { MST[NonVoidMethodCallMutator]MSP[N] throw new IllegalArgumentException ( lr_29 + destDir + lr_28 ) ; } if ( destDir == null ) {
if ( files == null ) { return BigInteger . ZERO ; } BigInteger size = BigInteger . ZERO ; for ( final File file : files ) { MST[rv.ABSMutator]MSP[N] if ( ! isSymlink ( file ) ) { size = size . add ( sizeOfBig0 ( file ) ) ;
displaySize = String . valueOf ( size . divide ( ONE_TB_BI ) ) + lr_14 ; MST[experimental.NakedReceiverMutator]MSP[N] } else if ( size . divide ( ONE_GB_BI ) . compareTo ( BigInteger . ZERO ) > 0 ) {
public static Collection < File > listFiles ( final File directory , final String [] extensions , final boolean recursive ) { IOFileFilter filter ; if ( extensions == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] filter = TrueFileFilter . INSTANCE ; } else {
throw new IOException ( lr_23 ) ; } if ( file1 . length () != file2 . length () ) { return false ; } if ( file1 . getCanonicalFile () . equals ( file2 . getCanonicalFile () ) ) { return true ; MST[rv.CRCR2Mutator]MSP[N] }
validateMoveParameters ( srcDir , destDir ) ; if ( ! srcDir . isDirectory () ) { throw new IOException ( lr_29 + srcDir + lr_28 ) ; } if ( destDir . exists () ) { MST[rv.ROR5Mutator]MSP[N] throw new FileExistsException ( lr_27 + destDir + lr_60 ) ; }
throw new IOException ( lr_5 + file + lr_6 ) ; MST[NonVoidMethodCallMutator]MSP[S] } if ( file . canRead () == false ) { throw new IOException ( lr_5 + file + lr_7 ) ; } } else { throw new FileNotFoundException ( lr_5 + file + lr_8 ) ; }
if ( srcLen != dstLen ) { throw new IOException ( lr_34 + srcFile + lr_35 + destFile MST[NonVoidMethodCallMutator]MSP[S] + lr_36 + srcLen + lr_37 + dstLen ) ; } } public static void copyDirectoryToDirectory ( final File srcDir , final File destDir ) throws IOException {
final File dstFile = new File ( destDir , srcFile . getName () ) ; MST[ConstructorCallMutator]MSP[N] if ( exclusionList == null || ! exclusionList . contains ( srcFile . getCanonicalPath () ) ) { if ( srcFile . isDirectory () ) {
? new InputStreamReader ( new FileInputStream ( file1 ) , Charset . defaultCharset () ) : new InputStreamReader ( new FileInputStream ( file1 ) , charsetName ) ; Reader input2 = charsetName == null MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] ? new InputStreamReader ( new FileInputStream ( file2 ) , Charset . defaultCharset () )
final byte octet = ( byte ) Integer . parseInt ( url . substring ( i + 1 , i + 3 ) , 16 ) ; MST[rv.CRCR3Mutator]MSP[N] bytes . put ( octet ) ; i += 3 ;
if ( ! directory . isDirectory () ) { throw new IllegalArgumentException ( lr_46 + directory ) ; } if ( child == null ) { return false ; } if ( ! directory . exists () || ! child . exists () ) { MST[NonVoidMethodCallMutator]MSP[S] return false ; }
final File [] found = directory . listFiles ( ( FileFilter ) filter ) ; if ( found != null ) { MST[rv.ROR5Mutator]MSP[N] for ( final File file : found ) { if ( file . isDirectory () ) { if ( includeSubDirectories ) {
final boolean rename = srcDir . renameTo ( destDir ) ; if ( ! rename ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] if ( destDir . getCanonicalPath () . startsWith ( srcDir . getCanonicalPath () + File . separator ) ) { throw new IOException ( lr_61 + srcDir + lr_62 + destDir ) ;
throw new IOException ( lr_29 + srcDir + lr_30 + destDir + lr_31 ) ; } List < String > exclusionList = null ; if ( destDir . getCanonicalPath () . startsWith ( srcDir . getCanonicalPath () ) ) { MST[NonVoidMethodCallMutator]MSP[N]
final String [] suffixes = new String [ extensions . length ] ; for ( int i = 0 ; i < extensions . length ; i ++ ) { suffixes [ i ] = lr_22 + extensions [ i ] ; MST[rv.ABSMutator]MSP[N] } return suffixes ; }
if ( ! src . exists () ) { throw new FileNotFoundException ( lr_29 + src + lr_8 ) ; MST[NonVoidMethodCallMutator]MSP[N] } } private static void doCopyDirectory ( final File srcDir , final File destDir , final FileFilter filter , final boolean preserveFileDate , final List < String > exclusionList )
if ( file == null ) { return false ; MST[rv.CRCR3Mutator]MSP[N] } try { if ( file . isDirectory () ) { cleanDirectory ( file ) ; } } catch ( final Exception ignored ) { } try { return file . delete () ;
return isFileNewer ( file , reference . lastModified () ) ; MST[ReturnValsMutator]MSP[N] } public static boolean isFileNewer ( final File file , final Date date ) { if ( date == null ) { throw new IllegalArgumentException ( lr_57 ) ; }
private static void checkDirectory ( final File directory ) { if ( ! directory . exists () ) { throw new IllegalArgumentException ( directory + lr_42 ) ; } if ( ! directory . isDirectory () ) { throw new IllegalArgumentException ( directory + lr_47 ) ; MST[NonVoidMethodCallMutator]MSP[N] } }
validateMoveParameters ( srcFile , destDir ) ; if ( ! destDir . exists () && createDestDir ) { destDir . mkdirs () ; } if ( ! destDir . exists () ) { throw new FileNotFoundException ( lr_66 + destDir + MST[NonVoidMethodCallMutator]MSP[S] lr_67 + createDestDir + lr_68 ) ; }
size += sizeOf0 ( file ) ; MST[rv.UOI3Mutator]MSP[N] if ( size < 0 ) { break; } } } return size ; } private static long sizeOf0 ( final File file ) { if ( file . isDirectory () ) { return sizeOfDirectory0 ( file ) ; }
throw new IOException ( lr_29 + srcFile + lr_69 ) ; } if ( destFile . exists () ) { throw new FileExistsException ( lr_27 + destFile + lr_60 ) ; } if ( destFile . isDirectory () ) { MST[rv.ROR2Mutator]MSP[N]
} public static void forceMkdirParent ( final File file ) throws IOException { final File parent = file . getParentFile () ; if ( parent == null ) { return; } forceMkdir ( parent ) ; MST[VoidMethodCallMutator]MSP[S] } public static long sizeOf ( final File file ) {
throw new IOException ( lr_5 + file + lr_6 ) ; } if ( file . canRead () == false ) { throw new IOException ( lr_5 + file + lr_7 ) ; } } else { throw new FileNotFoundException ( lr_5 + file + lr_8 ) ; MST[experimental.NakedReceiverMutator]MSP[N] }
throw new IOException ( lr_23 ) ; } if ( file1 . getCanonicalFile () . equals ( file2 . getCanonicalFile () ) ) { return true ; MST[BooleanFalseReturnValsMutator]MSP[S] } try ( Reader input1 = charsetName == null
throw new IOException ( lr_27 + destFile + lr_6 ) ; } final Path srcPath = srcFile . toPath () ; final Path destPath = destFile . toPath () ; final long newLastModifed = preserveFileDate ? srcFile . lastModified () : destFile . lastModified () ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[S]
throw new IOException ( lr_27 + destFile + lr_69 ) ; } final boolean rename = srcFile . renameTo ( destFile ) ; if ( ! rename ) { copyFile ( srcFile , destFile ) ; if ( ! srcFile . delete () ) { MST[rv.ROR3Mutator]MSP[N]
if ( srcFile . getCanonicalPath () . equals ( destFile . getCanonicalPath () ) ) { throw new IOException ( lr_29 + srcFile + lr_30 + destFile + lr_31 ) ; MST[experimental.NakedReceiverMutator]MSP[N] } final File parentFile = destFile . getParentFile () ; if ( parentFile != null ) {
displaySize = String . valueOf ( size . divide ( ONE_KB_BI ) ) + lr_17 ; } else { displaySize = String . valueOf ( size ) + lr_18 ; MST[NonVoidMethodCallMutator]MSP[N] } return displaySize ; } public static String byteCountToDisplaySize ( final long size ) {
public static boolean isFileNewer ( final File file , final File reference ) { if ( reference == null ) { throw new IllegalArgumentException ( lr_54 ) ; } if ( ! reference . exists () ) { MST[NegateConditionalsMutator]MSP[N] throw new IllegalArgumentException ( lr_55 + reference + lr_56 ) ; }
for ( final File srcFile : srcFiles ) { MST[rv.UOI2Mutator]MSP[N] final File copiedFile = new File ( destDir , srcFile . getName () ) ; exclusionList . add ( copiedFile . getCanonicalPath () ) ; } } } doCopyDirectory ( srcDir , destDir , filter , preserveFileDate , exclusionList ) ;
final byte octet = ( byte ) Integer . parseInt ( url . substring ( i + 1 , i + 3 ) , 16 ) ; MST[rv.UOI1Mutator]MSP[N] bytes . put ( octet ) ; i += 3 ;
throw new IllegalArgumentException ( MST[NonVoidMethodCallMutator]MSP[S] lr_25 + url ) ; } files [ i ] = toFile ( url ) ; } } return files ; } public static URL [] toURLs ( final File [] files ) throws IOException {
if ( ! file . exists () ) { final String message = file + lr_42 ; MST[experimental.NakedReceiverMutator]MSP[N] throw new IllegalArgumentException ( message ) ; } if ( file . isDirectory () ) { return sizeOfDirectory0 ( file ) ; } return file . length () ; }
final String [] suffixes = new String [ extensions . length ] ; for ( int i = 0 ; i < extensions . length ; i ++ ) { suffixes [ i ] = lr_22 + extensions [ i ] ; MST[ConstructorCallMutator]MSP[N] } return suffixes ; }
throws IOException { final File [] srcFiles = filter == null ? srcDir . listFiles () : srcDir . listFiles ( filter ) ; MST[NonVoidMethodCallMutator]MSP[S] if ( srcFiles == null ) { throw new IOException ( lr_40 + srcDir ) ; } if ( destDir . exists () ) {
final File [] found = directory . listFiles ( ( FileFilter ) filter ) ; if ( found != null ) { for ( final File file : found ) { MST[rv.UOI3Mutator]MSP[N] if ( file . isDirectory () ) { if ( includeSubDirectories ) {
final boolean success = file . setLastModified ( System . currentTimeMillis () ) ; if ( ! success ) { MST[rv.ABSMutator]MSP[N] throw new IOException ( lr_19 + file ) ; } } public static File [] convertFileCollectionToFileArray ( final Collection < File > files ) {
} public static void copyFileToDirectory ( final File srcFile , final File destDir ) throws IOException { copyFileToDirectory ( srcFile , destDir , true ) ; MST[rv.CRCR6Mutator]MSP[N] } public static void copyFileToDirectory ( final File srcFile , final File destDir , final boolean preserveFileDate ) throws IOException {
return new FileOutputStream ( file , append ) ; MST[rv.UOI2Mutator]MSP[N] } public static String byteCountToDisplaySize ( final BigInteger size ) { String displaySize ; if ( size . divide ( ONE_EB_BI ) . compareTo ( BigInteger . ZERO ) > 0 ) {
} } public static void forceDeleteOnExit ( final File file ) throws IOException { if ( file . isDirectory () ) { MST[rv.ROR3Mutator]MSP[N] deleteDirectoryOnExit ( file ) ; } else { file . deleteOnExit () ; } } private static void deleteDirectoryOnExit ( final File directory ) throws IOException {
if ( ! destDir . isDirectory () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] throw new IOException ( lr_27 + destDir + lr_28 ) ; } moveFile ( srcFile , new File ( destDir , srcFile . getName () ) ) ; }
displaySize = String . valueOf ( size . divide ( ONE_GB_BI ) ) + lr_15 ; } else if ( size . divide ( ONE_MB_BI ) . compareTo ( BigInteger . ZERO ) > 0 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N]
? new InputStreamReader ( new FileInputStream ( file1 ) , Charset . defaultCharset () ) : new InputStreamReader ( new FileInputStream ( file1 ) , charsetName ) ; Reader input2 = charsetName == null ? new InputStreamReader ( new FileInputStream ( file2 ) , Charset . defaultCharset () ) MST[NonVoidMethodCallMutator]MSP[S]
throw new NullPointerException ( lr_38 ) ; MST[ConstructorCallMutator]MSP[N] } if ( src . isFile () ) { copyFileToDirectory ( src , destDir ) ; } else if ( src . isDirectory () ) { copyDirectoryToDirectory ( src , destDir ) ; } else {
while ( ! file . exists () ) { final long remaining = finishAt - System . currentTimeMillis () ; if ( remaining < 0 ) { return false ; } try { Thread . sleep ( Math . min ( 100 , remaining ) ) ; MST[rv.CRCR6Mutator]MSP[N]
FileUtils . deleteQuietly ( destFile ) ; MST[NonVoidMethodCallMutator]MSP[S] throw new IOException ( lr_70 + srcFile + lr_64 + destFile + lr_65 ) ; } } } public static void moveFileToDirectory ( final File srcFile , final File destDir , final boolean createDestDir ) throws IOException {
displaySize = String . valueOf ( size . divide ( ONE_GB_BI ) ) + lr_15 ; } else if ( size . divide ( ONE_MB_BI ) . compareTo ( BigInteger . ZERO ) > 0 ) { MST[rv.ROR5Mutator]MSP[N]
return new FileInputStream ( file ) ; MST[ReturnValsMutator]MSP[N] } public static FileOutputStream openOutputStream ( final File file ) throws IOException { return openOutputStream ( file , false ) ; } public static FileOutputStream openOutputStream ( final File file , final boolean append ) throws IOException {
final String [] suffixes = toSuffixes ( extensions ) ; filter = new SuffixFileFilter ( suffixes ) ; } return listFiles ( directory , filter , MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] recursive ? TrueFileFilter . INSTANCE : FalseFileFilter . INSTANCE ) ; } public static Iterator < File > iterateFiles (
} while ( i < n && url . charAt ( i ) == '%' ); MST[rv.UOI2Mutator]MSP[N] continue; } catch ( final RuntimeException e ) { } finally { if ( bytes . position () > 0 ) { bytes . flip () ;
if ( ! parentFile . mkdirs () && ! parentFile . isDirectory () ) { throw new IOException ( lr_27 + parentFile + lr_32 ) ; } } if ( destFile . exists () && destFile . canWrite () == false ) { MST[rv.ROR3Mutator]MSP[N]
throws IOException { final File [] srcFiles = filter == null ? srcDir . listFiles () : srcDir . listFiles ( filter ) ; if ( srcFiles == null ) { throw new IOException ( lr_40 + srcDir ) ; } if ( destDir . exists () ) { MST[rv.ROR2Mutator]MSP[N]
if ( destDir . isDirectory () == false ) { MST[NegateConditionalsMutator]MSP[N] throw new IOException ( lr_27 + destDir + lr_39 ) ; } } else { if ( ! destDir . mkdirs () && ! destDir . isDirectory () ) {
final boolean filePresent = file . exists () ; if ( ! file . delete () ) { if ( ! filePresent ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] throw new FileNotFoundException ( lr_48 + file ) ; } final String message = lr_49 + file ; throw new IOException ( message ) ; }
return BigInteger . valueOf ( file . length () ) ; MST[NullReturnValsMutator]MSP[S] } public static long sizeOfDirectory ( final File directory ) { checkDirectory ( directory ) ; return sizeOfDirectory0 ( directory ) ; } private static long sizeOfDirectory0 ( final File directory ) {
} private static void checkFileRequirements ( final File src , final File dest ) throws FileNotFoundException { if ( src == null ) { MST[NegateConditionalsMutator]MSP[N] throw new NullPointerException ( lr_38 ) ; } if ( dest == null ) { throw new NullPointerException ( lr_26 ) ; }
validateMoveParameters ( srcDir , destDir ) ; if ( ! srcDir . isDirectory () ) { throw new IOException ( lr_29 + srcDir + lr_28 ) ; } if ( destDir . exists () ) { throw new FileExistsException ( lr_27 + destDir + lr_60 ) ; MST[NonVoidMethodCallMutator]MSP[S] }
copyDirectory ( srcDir , new File ( destDir , srcDir . getName () ) , true ) ; MST[rv.CRCR4Mutator]MSP[N] } public static void copyDirectory ( final File srcDir , final File destDir ) throws IOException { copyDirectory ( srcDir , destDir , true ) ; }
return false ; } return file . lastModified () > timeMillis ; MST[rv.CRCR5Mutator]MSP[N] } public static boolean isFileOlder ( final File file , final File reference ) { if ( reference == null ) { throw new IllegalArgumentException ( lr_54 ) ; }
for ( final File srcFile : srcFiles ) { final File copiedFile = new File ( destDir , srcFile . getName () ) ; exclusionList . add ( copiedFile . getCanonicalPath () ) ; } } } doCopyDirectory ( srcDir , destDir , filter , preserveFileDate , exclusionList ) ; MST[VoidMethodCallMutator]MSP[N]
throw new IOException ( lr_27 + destFile + lr_33 ) ; } doCopyFile ( srcFile , destFile , preserveFileDate ) ; MST[rv.ABSMutator]MSP[N] } public static long copyFile ( final File input , final OutputStream output ) throws IOException { try ( FileInputStream fis = new FileInputStream ( input ) ) {
return fileLength > 0 ? IOUtils . toByteArray ( in , fileLength ) : IOUtils . toByteArray ( in ) ; MST[NonVoidMethodCallMutator]MSP[S] } } public static List < String > readLines ( final File file , final Charset encoding ) throws IOException {
throw new NullPointerException ( lr_38 ) ; } if ( src . isFile () ) { copyFileToDirectory ( src , destDir ) ; } else if ( src . isDirectory () ) { MST[rv.ROR5Mutator]MSP[S] copyDirectoryToDirectory ( src , destDir ) ; } else {
final File [] files = verifiedListFiles ( directory ) ; IOException exception = null ; for ( final File file : files ) { MST[rv.UOI4Mutator]MSP[S] try { forceDeleteOnExit ( file ) ; } catch ( final IOException ioe ) { exception = ioe ; } }
throw new IOException ( lr_23 ) ; } if ( file1 . getCanonicalFile () . equals ( file2 . getCanonicalFile () ) ) { MST[experimental.NakedReceiverMutator]MSP[N] return true ; } try ( Reader input1 = charsetName == null
public static String getTempDirectoryPath () { return System . getProperty ( lr_3 ) ; MST[NonVoidMethodCallMutator]MSP[N] } public static File getTempDirectory () { return new File ( getTempDirectoryPath () ) ; } public static String getUserDirectoryPath () { return System . getProperty ( lr_4 ) ; }
try ( InputStream in = new CheckedInputStream ( new FileInputStream ( file ) , checksum ) ) { IOUtils . copy ( in , new NullOutputStream () ) ; MST[ConstructorCallMutator]MSP[N] } return checksum ; } public static void moveDirectory ( final File srcDir , final File destDir ) throws IOException {
final StringBuilder buffer = new StringBuilder () ; final ByteBuffer bytes = ByteBuffer . allocate ( n ) ; MST[rv.UOI1Mutator]MSP[N] for ( int i = 0 ; i < n ; ) { if ( url . charAt ( i ) == '%' ) { try { do {
throw new IllegalArgumentException ( lr_58 ) ; } if ( ! file . exists () ) { return false ; } return file . lastModified () < timeMillis ; MST[rv.ROR2Mutator]MSP[S] } public static long checksumCRC32 ( final File file ) throws IOException { final CRC32 crc = new CRC32 () ;
checksum ( file , crc ) ; return crc . getValue () ; } public static Checksum checksum ( final File file , final Checksum checksum ) throws IOException { if ( file . isDirectory () ) { MST[rv.ROR1Mutator]MSP[N] throw new IllegalArgumentException ( lr_59 ) ; }
throw new IOException ( lr_27 + destFile + lr_69 ) ; } final boolean rename = srcFile . renameTo ( destFile ) ; if ( ! rename ) { MST[rv.UOI1Mutator]MSP[N] copyFile ( srcFile , destFile ) ; if ( ! srcFile . delete () ) {
return FileFilterUtils . and ( fileFilter , FileFilterUtils . notFileFilter ( DirectoryFileFilter . INSTANCE ) ) ; MST[rv.CRCR5Mutator]MSP[N] } private static IOFileFilter setUpEffectiveDirFilter ( final IOFileFilter dirFilter ) { return dirFilter == null ? FalseFileFilter . INSTANCE : FileFilterUtils . and ( dirFilter , DirectoryFileFilter . INSTANCE ) ; }
doCopyDirectory ( srcFile , dstFile , filter , preserveFileDate , exclusionList ) ; MST[rv.UOI3Mutator]MSP[S] } else { doCopyFile ( srcFile , dstFile , preserveFileDate ) ; } } } if ( preserveFileDate ) { destDir . setLastModified ( srcDir . lastModified () ) ; } }
if ( file == null ) { return false ; MST[rv.CRCR6Mutator]MSP[N] } try { if ( file . isDirectory () ) { cleanDirectory ( file ) ; } } catch ( final Exception ignored ) { } try { return file . delete () ;
writeStringToFile ( file , data , Charset . defaultCharset () , false ) ; } @Deprecated public static void writeStringToFile ( final File file , final String data , final boolean append ) throws IOException { writeStringToFile ( file , data , Charset . defaultCharset () , append ) ; MST[rv.UOI3Mutator]MSP[S]
final boolean file1Exists = file1 . exists () ; if ( file1Exists != file2 . exists () ) { return false ; } if ( ! file1Exists ) { MST[NegateConditionalsMutator]MSP[N] return true ; } if ( file1 . isDirectory () || file2 . isDirectory () ) {
throw new IOException ( lr_27 + destFile + lr_69 ) ; } final boolean rename = srcFile . renameTo ( destFile ) ; if ( ! rename ) { MST[rv.ROR2Mutator]MSP[N] copyFile ( srcFile , destFile ) ; if ( ! srcFile . delete () ) {
if ( destDir == null ) { throw new NullPointerException ( lr_26 ) ; } if ( destDir . exists () && destDir . isDirectory () == false ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] throw new IllegalArgumentException ( lr_27 + destDir + lr_28 ) ; }
return readFileToString ( file , Charset . defaultCharset () ) ; MST[NonVoidMethodCallMutator]MSP[N] } public static byte [] readFileToByteArray ( final File file ) throws IOException { try ( InputStream in = openInputStream ( file ) ) { final long fileLength = file . length () ;
return isFileNewer ( file , date . getTime () ) ; MST[NonVoidMethodCallMutator]MSP[S] } public static boolean isFileNewer ( final File file , final long timeMillis ) { if ( file == null ) { throw new IllegalArgumentException ( lr_58 ) ; } if ( ! file . exists () ) {
final String [] suffixes = toSuffixes ( extensions ) ; filter = new SuffixFileFilter ( suffixes ) ; } return listFiles ( directory , filter , MST[NegateConditionalsMutator]MSP[N] recursive ? TrueFileFilter . INSTANCE : FalseFileFilter . INSTANCE ) ; } public static Iterator < File > iterateFiles (
if ( ! reference . exists () ) { MST[rv.ROR4Mutator]MSP[S] throw new IllegalArgumentException ( lr_55 + reference + lr_56 ) ; } return isFileOlder ( file , reference . lastModified () ) ; } public static boolean isFileOlder ( final File file , final Date date ) {
throw new IOException ( lr_23 ) ; } if ( file1 . getCanonicalFile () . equals ( file2 . getCanonicalFile () ) ) { MST[NonVoidMethodCallMutator]MSP[N] return true ; } try ( Reader input1 = charsetName == null
final byte octet = ( byte ) Integer . parseInt ( url . substring ( i + 1 , i + 3 ) , 16 ) ; bytes . put ( octet ) ; MST[rv.UOI2Mutator]MSP[N] i += 3 ;
throw new IllegalArgumentException ( lr_58 ) ; } if ( ! file . exists () ) { return false ; } return file . lastModified () < timeMillis ; MST[InlineConstantMutator]MSP[S] } public static long checksumCRC32 ( final File file ) throws IOException { final CRC32 crc = new CRC32 () ;
return FileFilterUtils . and ( fileFilter , FileFilterUtils . notFileFilter ( DirectoryFileFilter . INSTANCE ) ) ; MST[rv.CRCR6Mutator]MSP[N] } private static IOFileFilter setUpEffectiveDirFilter ( final IOFileFilter dirFilter ) { return dirFilter == null ? FalseFileFilter . INSTANCE : FileFilterUtils . and ( dirFilter , DirectoryFileFilter . INSTANCE ) ; }
if ( destDir . isDirectory () == false ) { throw new IOException ( lr_27 + destDir + lr_39 ) ; MST[NonVoidMethodCallMutator]MSP[S] } } else { if ( ! destDir . mkdirs () && ! destDir . isDirectory () ) {
if ( destDir . isDirectory () == false ) { throw new IOException ( lr_27 + destDir + lr_39 ) ; } } else { if ( ! destDir . mkdirs () && ! destDir . isDirectory () ) { MST[rv.ROR2Mutator]MSP[N]
try ( InputStream in = openInputStream ( file ) ) { return IOUtils . readLines ( in , Charsets . toCharset ( encoding ) ) ; MST[EmptyObjectReturnValsMutator]MSP[S] } } public static List < String > readLines ( final File file , final String encoding ) throws IOException {
} public static void forceMkdirParent ( final File file ) throws IOException { final File parent = file . getParentFile () ; MST[experimental.NakedReceiverMutator]MSP[N] if ( parent == null ) { return; } forceMkdir ( parent ) ; } public static long sizeOf ( final File file ) {
public static void moveDirectoryToDirectory ( final File src , final File destDir , final boolean createDestDir ) throws IOException { validateMoveParameters ( src , destDir ) ; if ( ! destDir . exists () && createDestDir ) { MST[rv.ROR1Mutator]MSP[N] destDir . mkdirs () ; }
displaySize = String . valueOf ( size . divide ( ONE_EB_BI ) ) + lr_12 ; } else if ( size . divide ( ONE_PB_BI ) . compareTo ( BigInteger . ZERO ) > 0 ) { MST[rv.ROR5Mutator]MSP[N]
final Collection < File > files = new java . util . LinkedList <> () ; if ( includeSubDirectories ) { MST[rv.UOI2Mutator]MSP[N] files . add ( directory ) ; } innerListFiles ( files , directory , FileFilterUtils . or ( effFileFilter , effDirFilter ) , includeSubDirectories ) ; return files ;
validateMoveParameters ( srcFile , destDir ) ; if ( ! destDir . exists () && createDestDir ) { MST[rv.ROR5Mutator]MSP[N] destDir . mkdirs () ; } if ( ! destDir . exists () ) { throw new FileNotFoundException ( lr_66 + destDir + lr_67 + createDestDir + lr_68 ) ; }
final boolean rename = srcDir . renameTo ( destDir ) ; if ( ! rename ) { if ( destDir . getCanonicalPath () . startsWith ( srcDir . getCanonicalPath () + File . separator ) ) { throw new IOException ( lr_61 + srcDir + lr_62 + destDir ) ; MST[ConstructorCallMutator]MSP[S]
final File directory , final IOFileFilter fileFilter , final IOFileFilter dirFilter ) { return innerListFilesOrDirectories ( directory , fileFilter , dirFilter , false ) ; MST[rv.CRCR5Mutator]MSP[N] } private static void validateListFilesParameters ( final File directory , final IOFileFilter fileFilter ) { if ( ! directory . isDirectory () ) {
final File [] files = verifiedListFiles ( directory ) ; IOException exception = null ; for ( final File file : files ) { MST[rv.UOI3Mutator]MSP[S] try { forceDeleteOnExit ( file ) ; } catch ( final IOException ioe ) { exception = ioe ; } }
final File [] files = directory . listFiles () ; if ( files == null ) { return 0L ; } long size = 0 ; for ( final File file : files ) { MST[rv.ABSMutator]MSP[N] if ( ! isSymlink ( file ) ) {
final StringBuilder buffer = new StringBuilder () ; final ByteBuffer bytes = ByteBuffer . allocate ( n ) ; for ( int i = 0 ; i < n ; ) { if ( url . charAt ( i ) == '%' ) { MST[rv.CRCR5Mutator]MSP[N] try { do {
size += sizeOf0 ( file ) ; if ( size < 0 ) { MST[InlineConstantMutator]MSP[N] break; } } } return size ; } private static long sizeOf0 ( final File file ) { if ( file . isDirectory () ) { return sizeOfDirectory0 ( file ) ; }
if ( files == null ) { return BigInteger . ZERO ; } BigInteger size = BigInteger . ZERO ; for ( final File file : files ) { if ( ! isSymlink ( file ) ) { MST[rv.ROR5Mutator]MSP[N] size = size . add ( sizeOfBig0 ( file ) ) ;
while ( ! file . exists () ) { final long remaining = finishAt - System . currentTimeMillis () ; if ( remaining < 0 ) { return false ; } try { Thread . sleep ( Math . min ( 100 , remaining ) ) ; MST[rv.UOI2Mutator]MSP[N]
public static void write ( final File file , final CharSequence data , final Charset encoding ) throws IOException { write ( file , data , encoding , false ) ; MST[rv.CRCR5Mutator]MSP[N] }
if ( file == null ) { return false ; } try { if ( file . isDirectory () ) { MST[rv.ROR5Mutator]MSP[N] cleanDirectory ( file ) ; } } catch ( final Exception ignored ) { } try { return file . delete () ;
if ( ! destDir . exists () ) { throw new FileNotFoundException ( lr_66 + destDir + MST[NonVoidMethodCallMutator]MSP[S] lr_67 + createDestDir + lr_68 ) ; } if ( ! destDir . isDirectory () ) { throw new IOException ( lr_27 + destDir + lr_28 ) ; }
final byte octet = ( byte ) Integer . parseInt ( url . substring ( i + 1 , i + 3 ) , 16 ) ; MST[rv.UOI3Mutator]MSP[N] bytes . put ( octet ) ; i += 3 ;
final StringBuilder buffer = new StringBuilder () ; final ByteBuffer bytes = ByteBuffer . allocate ( n ) ; for ( int i = 0 ; i < n ; ) { if ( url . charAt ( i ) == '%' ) { MST[rv.ROR2Mutator]MSP[N] try { do {
throw new IOException ( lr_29 + srcDir + lr_30 + destDir + lr_31 ) ; } List < String > exclusionList = null ; if ( destDir . getCanonicalPath () . startsWith ( srcDir . getCanonicalPath () ) ) { MST[rv.ROR5Mutator]MSP[S]
displaySize = String . valueOf ( size . divide ( ONE_EB_BI ) ) + lr_12 ; MST[ConstructorCallMutator]MSP[N] } else if ( size . divide ( ONE_PB_BI ) . compareTo ( BigInteger . ZERO ) > 0 ) {
throws IOException { final File [] srcFiles = filter == null ? srcDir . listFiles () : srcDir . listFiles ( filter ) ; if ( srcFiles == null ) { throw new IOException ( lr_40 + srcDir ) ; } if ( destDir . exists () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
if ( srcLen != dstLen ) { throw new IOException ( lr_34 + srcFile + lr_35 + destFile MST[rv.UOI4Mutator]MSP[N] + lr_36 + srcLen + lr_37 + dstLen ) ; } } public static void copyDirectoryToDirectory ( final File srcDir , final File destDir ) throws IOException {
public static String getTempDirectoryPath () { return System . getProperty ( lr_3 ) ; } public static File getTempDirectory () { return new File ( getTempDirectoryPath () ) ; } public static String getUserDirectoryPath () { return System . getProperty ( lr_4 ) ; MST[EmptyObjectReturnValsMutator]MSP[N] }
if ( ! file . exists () ) { final String message = file + lr_42 ; throw new IllegalArgumentException ( message ) ; MST[ConstructorCallMutator]MSP[S] } if ( file . isDirectory () ) { return sizeOfDirectory0 ( file ) ; } return file . length () ; }
throw new IOException ( lr_29 + srcFile + lr_69 ) ; } if ( destFile . exists () ) { throw new FileExistsException ( lr_27 + destFile + lr_60 ) ; } if ( destFile . isDirectory () ) { MST[NonVoidMethodCallMutator]MSP[N]
} else { final File parent = file . getParentFile () ; if ( parent != null ) { if ( ! parent . mkdirs () && ! parent . isDirectory () ) { throw new IOException ( lr_10 + parent + lr_11 ) ; MST[NonVoidMethodCallMutator]MSP[S] } } }
final byte octet = ( byte ) Integer . parseInt ( url . substring ( i + 1 , i + 3 ) , 16 ) ; bytes . put ( octet ) ; MST[rv.ABSMutator]MSP[N] i += 3 ;
moveDirectory ( src , new File ( destDir , src . getName () ) ) ; } public static void moveFile ( final File srcFile , final File destFile ) throws IOException { validateMoveParameters ( srcFile , destFile ) ; if ( srcFile . isDirectory () ) { MST[rv.ROR1Mutator]MSP[N]
final File [] files = directory . listFiles () ; if ( files == null ) { return 0L ; } long size = 0 ; MST[rv.CRCR6Mutator]MSP[N] for ( final File file : files ) { if ( ! isSymlink ( file ) ) {
writeByteArrayToFile ( file , data , 0 , data . length , append ) ; MST[rv.CRCR3Mutator]MSP[N] } public static void writeByteArrayToFile ( final File file , final byte [] data , final int off , final int len ) throws IOException {
final boolean file1Exists = file1 . exists () ; if ( file1Exists != file2 . exists () ) { return false ; } if ( ! file1Exists ) { return true ; MST[rv.CRCR5Mutator]MSP[S] } if ( file1 . isDirectory () || file2 . isDirectory () ) {
displaySize = String . valueOf ( size . divide ( ONE_PB_BI ) ) + lr_13 ; } else if ( size . divide ( ONE_TB_BI ) . compareTo ( BigInteger . ZERO ) > 0 ) { MST[experimental.NakedReceiverMutator]MSP[N]
try { if ( in != null ) { in . close () ; MST[VoidMethodCallMutator]MSP[N] } } catch ( final IOException e ) { ex . addSuppressed ( e ) ; } throw ex ; } } public static LineIterator lineIterator ( final File file ) throws IOException {
throw new IOException ( lr_23 ) ; } if ( file1 . getCanonicalFile () . equals ( file2 . getCanonicalFile () ) ) { return true ; MST[rv.CRCR3Mutator]MSP[N] } try ( Reader input1 = charsetName == null
final File directory , final String [] extensions , final boolean recursive ) { return listFiles ( directory , extensions , recursive ) . iterator () ; MST[rv.UOI1Mutator]MSP[N] } public static boolean contentEquals ( final File file1 , final File file2 ) throws IOException {
if ( null != exception ) { throw exception ; } } public static void forceMkdir ( final File directory ) throws IOException { if ( directory . exists () ) { if ( ! directory . isDirectory () ) { final String message = MST[NonVoidMethodCallMutator]MSP[S] lr_50 + directory + lr_51
public static File getUserDirectory () { return new File ( getUserDirectoryPath () ) ; } public static FileInputStream openInputStream ( final File file ) throws IOException { if ( file . exists () ) { if ( file . isDirectory () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
if ( ! directory . isDirectory () ) { throw new IllegalArgumentException ( lr_46 + directory ) ; MST[ConstructorCallMutator]MSP[S] } if ( child == null ) { return false ; } if ( ! directory . exists () || ! child . exists () ) { return false ; }
final URL [] urls = new URL [ files . length ] ; for ( int i = 0 ; i < urls . length ; i ++ ) { MST[NegateConditionalsMutator]MSP[N] urls [ i ] = files [ i ] . toURI () . toURL () ; } return urls ;
try ( OutputStream out = openOutputStream ( file , append ) ) { MST[rv.UOI2Mutator]MSP[N] out . write ( data , off , len ) ; } } public static void writeLines ( final File file , final String encoding , final Collection < ? > lines ) throws IOException {
final Collection < File > files = new java . util . LinkedList <> () ; if ( includeSubDirectories ) { MST[rv.ABSMutator]MSP[N] files . add ( directory ) ; } innerListFiles ( files , directory , FileFilterUtils . or ( effFileFilter , effDirFilter ) , includeSubDirectories ) ; return files ;
public static File getUserDirectory () { return new File ( getUserDirectoryPath () ) ; MST[NonVoidMethodCallMutator]MSP[S] } public static FileInputStream openInputStream ( final File file ) throws IOException { if ( file . exists () ) { if ( file . isDirectory () ) {
final URL [] urls = new URL [ files . length ] ; for ( int i = 0 ; i < urls . length ; i ++ ) { urls [ i ] = files [ i ] . toURI () . toURL () ; } return urls ; MST[NullReturnValsMutator]MSP[N]
final File directory , final String [] extensions , final boolean recursive ) { return listFiles ( directory , extensions , recursive ) . iterator () ; MST[NonVoidMethodCallMutator]MSP[S] } public static boolean contentEquals ( final File file1 , final File file2 ) throws IOException {
throw new IOException ( lr_29 + srcFile + lr_69 ) ; MST[NonVoidMethodCallMutator]MSP[S] } if ( destFile . exists () ) { throw new FileExistsException ( lr_27 + destFile + lr_60 ) ; } if ( destFile . isDirectory () ) {
if ( null != exception ) { throw exception ; } } public static void forceMkdir ( final File directory ) throws IOException { if ( directory . exists () ) { if ( ! directory . isDirectory () ) { MST[rv.ROR4Mutator]MSP[N] final String message = lr_50 + directory + lr_51
public static BigInteger sizeOfAsBigInteger ( final File file ) { if ( ! file . exists () ) { MST[NegateConditionalsMutator]MSP[N] final String message = file + lr_42 ; throw new IllegalArgumentException ( message ) ; } if ( file . isDirectory () ) { return sizeOfDirectoryBig0 ( file ) ; }
return IOUtils . copyLarge ( fis , output ) ; MST[ReturnValsMutator]MSP[N] } } private static void doCopyFile ( final File srcFile , final File destFile , final boolean preserveFileDate ) throws IOException { if ( destFile . exists () && destFile . isDirectory () ) {
while ( ! file . exists () ) { final long remaining = finishAt - System . currentTimeMillis () ; if ( remaining < 0 ) { return false ; } try { Thread . sleep ( Math . min ( 100 , remaining ) ) ; MST[rv.ABSMutator]MSP[N]
throw new IOException ( lr_29 + srcFile + lr_69 ) ; } if ( destFile . exists () ) { throw new FileExistsException ( lr_27 + destFile + lr_60 ) ; } if ( destFile . isDirectory () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
moveDirectory ( src , new File ( destDir , src . getName () ) ) ; } public static void moveFile ( final File srcFile , final File destFile ) throws IOException { validateMoveParameters ( srcFile , destFile ) ; if ( srcFile . isDirectory () ) { MST[rv.ROR4Mutator]MSP[N]
throw new IOException ( lr_5 + file + lr_6 ) ; } if ( file . canRead () == false ) { throw new IOException ( lr_5 + file + lr_7 ) ; } } else { throw new FileNotFoundException ( lr_5 + file + lr_8 ) ; MST[NonVoidMethodCallMutator]MSP[N] }
validateMoveParameters ( srcFile , destDir ) ; if ( ! destDir . exists () && createDestDir ) { destDir . mkdirs () ; } if ( ! destDir . exists () ) { throw new FileNotFoundException ( lr_66 + destDir + MST[rv.ABSMutator]MSP[N] lr_67 + createDestDir + lr_68 ) ; }
} else { final File parent = file . getParentFile () ; if ( parent != null ) { if ( ! parent . mkdirs () && ! parent . isDirectory () ) { MST[NonVoidMethodCallMutator]MSP[S] throw new IOException ( lr_10 + parent + lr_11 ) ; } } }
} catch ( final InterruptedException ignore ) { wasInterrupted = true ; } catch ( final Exception ex ) { break; } } } finally { if ( wasInterrupted ) { MST[rv.ROR3Mutator]MSP[S] Thread . currentThread () . interrupt () ; } } return true ; }
return fileLength > 0 ? IOUtils . toByteArray ( in , fileLength ) : IOUtils . toByteArray ( in ) ; MST[rv.CRCR3Mutator]MSP[N] } } public static List < String > readLines ( final File file , final Charset encoding ) throws IOException {
final String canonicalParent = directory . getCanonicalPath () ; final String canonicalChild = child . getCanonicalPath () ; MST[NonVoidMethodCallMutator]MSP[S] return FilenameUtils . directoryContains ( canonicalParent , canonicalChild ) ; } public static void cleanDirectory ( final File directory ) throws IOException {
public static BigInteger sizeOfAsBigInteger ( final File file ) { if ( ! file . exists () ) { final String message = file + lr_42 ; MST[experimental.NakedReceiverMutator]MSP[N] throw new IllegalArgumentException ( message ) ; } if ( file . isDirectory () ) { return sizeOfDirectoryBig0 ( file ) ; }
private static void checkDirectory ( final File directory ) { if ( ! directory . exists () ) { MST[rv.ROR2Mutator]MSP[N] throw new IllegalArgumentException ( directory + lr_42 ) ; } if ( ! directory . isDirectory () ) { throw new IllegalArgumentException ( directory + lr_47 ) ; } }
if ( destDir == null ) { throw new NullPointerException ( lr_26 ) ; } if ( destDir . exists () && destDir . isDirectory () == false ) { MST[NegateConditionalsMutator]MSP[N] throw new IllegalArgumentException ( lr_27 + destDir + lr_28 ) ; }
return false ; } return file . lastModified () > timeMillis ; MST[RemoveConditionalMutator_ORDER_IF]MSP[N] } public static boolean isFileOlder ( final File file , final File reference ) { if ( reference == null ) { throw new IllegalArgumentException ( lr_54 ) ; }
if ( srcLen != dstLen ) { MST[rv.ROR3Mutator]MSP[N] throw new IOException ( lr_34 + srcFile + lr_35 + destFile + lr_36 + srcLen + lr_37 + dstLen ) ; } } public static void copyDirectoryToDirectory ( final File srcDir , final File destDir ) throws IOException {
if ( url == null || ! lr_24 . equalsIgnoreCase ( url . getProtocol () ) ) { return null ; } String filename = url . getFile () . replace ( '/' , File . separatorChar ) ; MST[InlineConstantMutator]MSP[N] filename = decodeUrl ( filename ) ;
final byte octet = ( byte ) Integer . parseInt ( url . substring ( i + 1 , i + 3 ) , 16 ) ; MST[rv.AOR4Mutator]MSP[N] bytes . put ( octet ) ; i += 3 ;
files . add ( file ) ; } innerListFiles ( files , file , filter , includeSubDirectories ) ; } else { files . add ( file ) ; MST[NonVoidMethodCallMutator]MSP[N] } } } } public static Collection < File > listFiles (
final File dstFile = new File ( destDir , srcFile . getName () ) ; if ( exclusionList == null || ! exclusionList . contains ( srcFile . getCanonicalPath () ) ) { if ( srcFile . isDirectory () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
return false ; } return file . lastModified () > timeMillis ; MST[rv.ROR4Mutator]MSP[N] } public static boolean isFileOlder ( final File file , final File reference ) { if ( reference == null ) { throw new IllegalArgumentException ( lr_54 ) ; }
if ( files == null ) { return BigInteger . ZERO ; } BigInteger size = BigInteger . ZERO ; for ( final File file : files ) { if ( ! isSymlink ( file ) ) { MST[rv.ROR2Mutator]MSP[N] size = size . add ( sizeOfBig0 ( file ) ) ;
return FileFilterUtils . and ( fileFilter , FileFilterUtils . notFileFilter ( DirectoryFileFilter . INSTANCE ) ) ; } private static IOFileFilter setUpEffectiveDirFilter ( final IOFileFilter dirFilter ) { return dirFilter == null ? FalseFileFilter . INSTANCE : FileFilterUtils . and ( dirFilter , MST[InlineConstantMutator]MSP[N] DirectoryFileFilter . INSTANCE ) ; }
throw new IOException ( lr_41 + src + lr_42 ) ; } } public static void copyToDirectory ( final Iterable < File > srcs , final File destDir ) throws IOException { if ( srcs == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] throw new NullPointerException ( lr_43 ) ; }
} } return size ; } private static BigInteger sizeOfBig0 ( final File fileOrDir ) { if ( fileOrDir . isDirectory () ) { MST[NonVoidMethodCallMutator]MSP[S] return sizeOfDirectoryBig0 ( fileOrDir ) ; } return BigInteger . valueOf ( fileOrDir . length () ) ; }
} while ( i < n && url . charAt ( i ) == '%' ); MST[rv.ROR2Mutator]MSP[N] continue; } catch ( final RuntimeException e ) { } finally { if ( bytes . position () > 0 ) { bytes . flip () ;
} else { final File parent = file . getParentFile () ; if ( parent != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] if ( ! parent . mkdirs () && ! parent . isDirectory () ) { throw new IOException ( lr_10 + parent + lr_11 ) ; } } }
try ( InputStream in = new CheckedInputStream ( new FileInputStream ( file ) , checksum ) ) { IOUtils . copy ( in , new NullOutputStream () ) ; } return checksum ; MST[NullReturnValsMutator]MSP[S] } public static void moveDirectory ( final File srcDir , final File destDir ) throws IOException {
final File [] files = directory . listFiles () ; MST[NonVoidMethodCallMutator]MSP[N] if ( files == null ) { return 0L ; } long size = 0 ; for ( final File file : files ) { if ( ! isSymlink ( file ) ) {
final Collection < File > files = new java . util . LinkedList <> () ; if ( includeSubDirectories ) { files . add ( directory ) ; } innerListFiles ( files , directory , MST[rv.CRCR4Mutator]MSP[N] FileFilterUtils . or ( effFileFilter , effDirFilter ) , includeSubDirectories ) ; return files ;
displaySize = String . valueOf ( size . divide ( ONE_PB_BI ) ) + lr_13 ; MST[experimental.BigIntegerMutator]MSP[N] } else if ( size . divide ( ONE_TB_BI ) . compareTo ( BigInteger . ZERO ) > 0 ) {
final File [] files = directory . listFiles () ; if ( files == null ) { return 0L ; } long size = 0 ; for ( final File file : files ) { MST[rv.UOI1Mutator]MSP[N] if ( ! isSymlink ( file ) ) {
private static void checkDirectory ( final File directory ) { if ( ! directory . exists () ) { throw new IllegalArgumentException ( directory + lr_42 ) ; } if ( ! directory . isDirectory () ) { MST[rv.ROR3Mutator]MSP[N] throw new IllegalArgumentException ( directory + lr_47 ) ; } }
} while ( i < n && url . charAt ( i ) == '%' ); continue; } catch ( final RuntimeException e ) { } finally { if ( bytes . position () > 0 ) { MST[NonVoidMethodCallMutator]MSP[N] bytes . flip () ;
final File destFile = new File ( destDir , srcFile . getName () ) ; MST[NonVoidMethodCallMutator]MSP[N] copyFile ( srcFile , destFile , preserveFileDate ) ; } public static void copyFile ( final File srcFile , final File destFile ) throws IOException { copyFile ( srcFile , destFile , true ) ;
throws IOException { final boolean file1Exists = file1 . exists () ; if ( file1Exists != file2 . exists () ) { return false ; } if ( ! file1Exists ) { return true ; } if ( file1 . isDirectory () || file2 . isDirectory () ) { MST[NonVoidMethodCallMutator]MSP[N]
} copyDirectory ( srcDir , destDir ) ; deleteDirectory ( srcDir ) ; if ( srcDir . exists () ) { MST[rv.ROR2Mutator]MSP[N] throw new IOException ( lr_63 + srcDir + lr_64 + destDir + lr_65 ) ; } } }
if ( ! destDir . exists () ) { throw new FileNotFoundException ( lr_66 + destDir + lr_67 + createDestDir + lr_68 ) ; } if ( ! destDir . isDirectory () ) { MST[rv.ROR2Mutator]MSP[N] throw new IOException ( lr_27 + destDir + lr_28 ) ; }
throw new IOException ( lr_27 + destFile + lr_6 ) ; } final Path srcPath = srcFile . toPath () ; final Path destPath = destFile . toPath () ; final long newLastModifed = preserveFileDate ? srcFile . lastModified () : destFile . lastModified () ; MST[NegateConditionalsMutator]MSP[S]
size += sizeOf0 ( file ) ; if ( size < 0 ) { MST[rv.UOI2Mutator]MSP[N] break; } } } return size ; } private static long sizeOf0 ( final File file ) { if ( file . isDirectory () ) { return sizeOfDirectory0 ( file ) ; }
return FileFilterUtils . and ( fileFilter , FileFilterUtils . notFileFilter ( DirectoryFileFilter . INSTANCE ) ) ; } private static IOFileFilter setUpEffectiveDirFilter ( final IOFileFilter dirFilter ) { return dirFilter == null ? FalseFileFilter . INSTANCE : FileFilterUtils . and ( dirFilter , MST[rv.CRCR2Mutator]MSP[N] DirectoryFileFilter . INSTANCE ) ; }
throw new IOException ( lr_27 + destFile + lr_69 ) ; } final boolean rename = srcFile . renameTo ( destFile ) ; if ( ! rename ) { MST[rv.UOI4Mutator]MSP[N] copyFile ( srcFile , destFile ) ; if ( ! srcFile . delete () ) {
return new FileOutputStream ( file , append ) ; } public static String byteCountToDisplaySize ( final BigInteger size ) { String displaySize ; if ( size . divide ( ONE_EB_BI ) . compareTo ( BigInteger . ZERO ) > 0 ) { MST[ConditionalsBoundaryMutator]MSP[N]
final URL [] urls = new URL [ files . length ] ; for ( int i = 0 ; i < urls . length ; i ++ ) { urls [ i ] = files [ i ] . toURI () . toURL () ; MST[rv.ABSMutator]MSP[S] } return urls ;
buffer . append ( StandardCharsets . UTF_8 . decode ( bytes ) . toString () ) ; bytes . clear () ; } } } buffer . append ( url . charAt ( i ++ ) ) ; MST[rv.UOI1Mutator]MSP[N] } decoded = buffer . toString () ; } return decoded ;
throw new IOException ( lr_40 + directory ) ; } return files ; } public static boolean waitFor ( final File file , final int seconds ) { final long finishAt = System . currentTimeMillis () + ( seconds * 1000L ) ; MST[rv.AOR4Mutator]MSP[N] boolean wasInterrupted = false ; try {
return new FileOutputStream ( file , append ) ; } public static String byteCountToDisplaySize ( final BigInteger size ) { String displaySize ; if ( size . divide ( ONE_EB_BI ) . compareTo ( BigInteger . ZERO ) > 0 ) { MST[NonVoidMethodCallMutator]MSP[N]
if ( ! reference . exists () ) { MST[rv.ROR1Mutator]MSP[S] throw new IllegalArgumentException ( lr_55 + reference + lr_56 ) ; } return isFileOlder ( file , reference . lastModified () ) ; } public static boolean isFileOlder ( final File file , final Date date ) {
validateMoveParameters ( srcFile , destDir ) ; if ( ! destDir . exists () && createDestDir ) { destDir . mkdirs () ; } if ( ! destDir . exists () ) { throw new FileNotFoundException ( lr_66 + destDir + MST[NonVoidMethodCallMutator]MSP[N] lr_67 + createDestDir + lr_68 ) ; }
if ( srcLen != dstLen ) { throw new IOException ( lr_34 + srcFile + lr_35 + destFile MST[experimental.NakedReceiverMutator]MSP[N] + lr_36 + srcLen + lr_37 + dstLen ) ; } } public static void copyDirectoryToDirectory ( final File srcDir , final File destDir ) throws IOException {
final File dstFile = new File ( destDir , srcFile . getName () ) ; if ( exclusionList == null || ! exclusionList . contains ( srcFile . getCanonicalPath () ) ) { if ( srcFile . isDirectory () ) { MST[NonVoidMethodCallMutator]MSP[N]
validateMoveParameters ( srcFile , destDir ) ; if ( ! destDir . exists () && createDestDir ) { destDir . mkdirs () ; } if ( ! destDir . exists () ) { throw new FileNotFoundException ( lr_66 + destDir + MST[experimental.NakedReceiverMutator]MSP[N] lr_67 + createDestDir + lr_68 ) ; }
throw new NullPointerException ( lr_38 ) ; } if ( src . isFile () ) { MST[rv.ROR1Mutator]MSP[S] copyFileToDirectory ( src , destDir ) ; } else if ( src . isDirectory () ) { copyDirectoryToDirectory ( src , destDir ) ; } else {
final Collection < File > files = new java . util . LinkedList <> () ; if ( includeSubDirectories ) { files . add ( directory ) ; } innerListFiles ( files , directory , MST[InlineConstantMutator]MSP[N] FileFilterUtils . or ( effFileFilter , effDirFilter ) , includeSubDirectories ) ; return files ;
final File [] files = verifiedListFiles ( directory ) ; IOException exception = null ; for ( final File file : files ) { MST[rv.UOI1Mutator]MSP[N] try { forceDeleteOnExit ( file ) ; } catch ( final IOException ioe ) { exception = ioe ; } }
final boolean file1Exists = file1 . exists () ; if ( file1Exists != file2 . exists () ) { return false ; } if ( ! file1Exists ) { return true ; } if ( file1 . isDirectory () || file2 . isDirectory () ) { MST[rv.ROR5Mutator]MSP[N]
return byteCountToDisplaySize ( BigInteger . valueOf ( size ) ) ; MST[EmptyObjectReturnValsMutator]MSP[N] } public static void touch ( final File file ) throws IOException { if ( ! file . exists () ) { openOutputStream ( file ) . close () ; }
} copyDirectory ( srcDir , destDir ) ; deleteDirectory ( srcDir ) ; if ( srcDir . exists () ) { MST[rv.ROR5Mutator]MSP[S] throw new IOException ( lr_63 + srcDir + lr_64 + destDir + lr_65 ) ; } } }
if ( date == null ) { throw new IllegalArgumentException ( lr_57 ) ; } return isFileOlder ( file , date . getTime () ) ; MST[BooleanFalseReturnValsMutator]MSP[S] } public static boolean isFileOlder ( final File file , final long timeMillis ) { if ( file == null ) {
Files . copy ( srcPath , destPath , StandardCopyOption . REPLACE_EXISTING ) ; MST[InlineConstantMutator]MSP[N] checkEqualSizes ( srcFile , destFile , Files . size ( srcPath ) , Files . size ( destPath ) ) ;
if ( files == null ) { return BigInteger . ZERO ; } BigInteger size = BigInteger . ZERO ; for ( final File file : files ) { MST[rv.UOI1Mutator]MSP[N] if ( ! isSymlink ( file ) ) { size = size . add ( sizeOfBig0 ( file ) ) ;
final String [] suffixes = toSuffixes ( extensions ) ; filter = new SuffixFileFilter ( suffixes ) ; } return listFiles ( directory , filter , MST[EmptyObjectReturnValsMutator]MSP[N] recursive ? TrueFileFilter . INSTANCE : FalseFileFilter . INSTANCE ) ; } public static Iterator < File > iterateFiles (
throw new IOException ( lr_41 + src + lr_42 ) ; } } public static void copyToDirectory ( final Iterable < File > srcs , final File destDir ) throws IOException { if ( srcs == null ) { MST[NegateConditionalsMutator]MSP[S] throw new NullPointerException ( lr_43 ) ; }
public static String readFileToString ( final File file , final String encoding ) throws IOException { return readFileToString ( file , Charsets . toCharset ( encoding ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } @Deprecated public static String readFileToString ( final File file ) throws IOException {
final File [] files = directory . listFiles () ; if ( files == null ) { return 0L ; } long size = 0 ; MST[rv.CRCR3Mutator]MSP[N] for ( final File file : files ) { if ( ! isSymlink ( file ) ) {
throw new IOException ( lr_23 ) ; } if ( file1 . length () != file2 . length () ) { MST[rv.ROR5Mutator]MSP[N] return false ; } if ( file1 . getCanonicalFile () . equals ( file2 . getCanonicalFile () ) ) { return true ; }
if ( srcLen != dstLen ) { throw new IOException ( lr_34 + srcFile + lr_35 + destFile MST[rv.ABSMutator]MSP[N] + lr_36 + srcLen + lr_37 + dstLen ) ; } } public static void copyDirectoryToDirectory ( final File srcDir , final File destDir ) throws IOException {
final Collection < File > files = new java . util . LinkedList <> () ; if ( includeSubDirectories ) { files . add ( directory ) ; } innerListFiles ( files , directory , FileFilterUtils . or ( effFileFilter , effDirFilter ) , includeSubDirectories ) ; MST[rv.ABSMutator]MSP[N] return files ;
if ( file . exists () ) { if ( file . isDirectory () ) { throw new IOException ( lr_5 + file + lr_6 ) ; MST[NonVoidMethodCallMutator]MSP[S] } if ( file . canWrite () == false ) { throw new IOException ( lr_5 + file + lr_9 ) ; }
return IOUtils . copyLarge ( fis , output ) ; } } private static void doCopyFile ( final File srcFile , final File destFile , final boolean preserveFileDate ) throws IOException { if ( destFile . exists () && destFile . isDirectory () ) { MST[NegateConditionalsMutator]MSP[N]
throw new IOException ( lr_23 ) ; } if ( file1 . getCanonicalFile () . equals ( file2 . getCanonicalFile () ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return true ; } try ( Reader input1 = charsetName == null
size += sizeOf0 ( file ) ; MST[rv.AOR1Mutator]MSP[N] if ( size < 0 ) { break; } } } return size ; } private static long sizeOf0 ( final File file ) { if ( file . isDirectory () ) { return sizeOfDirectory0 ( file ) ; }
final boolean rename = srcDir . renameTo ( destDir ) ; if ( ! rename ) { MST[rv.ABSMutator]MSP[N] if ( destDir . getCanonicalPath () . startsWith ( srcDir . getCanonicalPath () + File . separator ) ) { throw new IOException ( lr_61 + srcDir + lr_62 + destDir ) ;
return isFileNewer ( file , reference . lastModified () ) ; } public static boolean isFileNewer ( final File file , final Date date ) { if ( date == null ) { MST[rv.ROR5Mutator]MSP[N] throw new IllegalArgumentException ( lr_57 ) ; }
final StringBuilder buffer = new StringBuilder () ; final ByteBuffer bytes = ByteBuffer . allocate ( n ) ; for ( int i = 0 ; i < n ; ) { MST[rv.UOI4Mutator]MSP[N] if ( url . charAt ( i ) == '%' ) { try { do {
final StringBuilder buffer = new StringBuilder () ; final ByteBuffer bytes = ByteBuffer . allocate ( n ) ; for ( int i = 0 ; i < n ; ) { if ( url . charAt ( i ) == '%' ) { MST[rv.CRCR2Mutator]MSP[N] try { do {
final boolean file1Exists = file1 . exists () ; if ( file1Exists != file2 . exists () ) { return false ; } if ( ! file1Exists ) { return true ; } if ( file1 . isDirectory () || file2 . isDirectory () ) { MST[rv.ROR4Mutator]MSP[N]
writeByteArrayToFile ( file , data , 0 , data . length , append ) ; MST[rv.UOI3Mutator]MSP[S] } public static void writeByteArrayToFile ( final File file , final byte [] data , final int off , final int len ) throws IOException {
} public static File [] toFiles ( final URL [] urls ) { if ( urls == null || urls . length == 0 ) { MST[rv.ROR3Mutator]MSP[N] return EMPTY_FILE_ARRAY ; } final File [] files = new File [ urls . length ] ;
} } return size ; } private static BigInteger sizeOfBig0 ( final File fileOrDir ) { if ( fileOrDir . isDirectory () ) { MST[rv.ROR5Mutator]MSP[N] return sizeOfDirectoryBig0 ( fileOrDir ) ; } return BigInteger . valueOf ( fileOrDir . length () ) ; }
if ( date == null ) { throw new IllegalArgumentException ( lr_57 ) ; } return isFileOlder ( file , date . getTime () ) ; } public static boolean isFileOlder ( final File file , final long timeMillis ) { if ( file == null ) { MST[rv.ROR5Mutator]MSP[S]
public static BigInteger sizeOfAsBigInteger ( final File file ) { if ( ! file . exists () ) { final String message = file + lr_42 ; throw new IllegalArgumentException ( message ) ; } if ( file . isDirectory () ) { return sizeOfDirectoryBig0 ( file ) ; MST[ReturnValsMutator]MSP[N] }
final File [] srcFiles = filter == null ? srcDir . listFiles () : srcDir . listFiles ( filter ) ; if ( srcFiles != null && srcFiles . length > 0 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] exclusionList = new ArrayList <> ( srcFiles . length ) ;
if ( srcFile . getCanonicalPath () . equals ( destFile . getCanonicalPath () ) ) { throw new IOException ( lr_29 + srcFile + lr_30 + destFile + lr_31 ) ; } final File parentFile = destFile . getParentFile () ; if ( parentFile != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
validateMoveParameters ( srcFile , destDir ) ; if ( ! destDir . exists () && createDestDir ) { destDir . mkdirs () ; } if ( ! destDir . exists () ) { MST[NegateConditionalsMutator]MSP[N] throw new FileNotFoundException ( lr_66 + destDir + lr_67 + createDestDir + lr_68 ) ; }
} public static void copyFileToDirectory ( final File srcFile , final File destDir ) throws IOException { copyFileToDirectory ( srcFile , destDir , true ) ; MST[rv.CRCR3Mutator]MSP[N] } public static void copyFileToDirectory ( final File srcFile , final File destDir , final boolean preserveFileDate ) throws IOException {
public static void writeStringToFile ( final File file , final String data , final String encoding ) throws IOException { writeStringToFile ( file , data , encoding , false ) ; MST[rv.CRCR5Mutator]MSP[N] } public static void writeStringToFile ( final File file , final String data , final Charset encoding ,
final File [] srcFiles = filter == null ? srcDir . listFiles () : srcDir . listFiles ( filter ) ; MST[NonVoidMethodCallMutator]MSP[S] if ( srcFiles != null && srcFiles . length > 0 ) { exclusionList = new ArrayList <> ( srcFiles . length ) ;
final File directory , final String [] extensions , final boolean recursive ) { return listFiles ( directory , extensions , recursive ) . iterator () ; MST[ReturnValsMutator]MSP[S] } public static boolean contentEquals ( final File file1 , final File file2 ) throws IOException {
throw new IOException ( lr_23 ) ; } if ( file1 . getCanonicalFile () . equals ( file2 . getCanonicalFile () ) ) { return true ; MST[rv.CRCR6Mutator]MSP[S] } try ( Reader input1 = charsetName == null
final URL [] urls = new URL [ files . length ] ; for ( int i = 0 ; i < urls . length ; i ++ ) { MST[rv.UOI2Mutator]MSP[S] urls [ i ] = files [ i ] . toURI () . toURL () ; } return urls ;
final Collection < File > files = new java . util . LinkedList <> () ; if ( includeSubDirectories ) { MST[rv.ROR3Mutator]MSP[N] files . add ( directory ) ; } innerListFiles ( files , directory , FileFilterUtils . or ( effFileFilter , effDirFilter ) , includeSubDirectories ) ; return files ;
return IOUtils . copyLarge ( fis , output ) ; MST[NonVoidMethodCallMutator]MSP[N] } } private static void doCopyFile ( final File srcFile , final File destFile , final boolean preserveFileDate ) throws IOException { if ( destFile . exists () && destFile . isDirectory () ) {
if ( srcDir == null ) { throw new NullPointerException ( lr_38 ) ; } if ( srcDir . exists () && srcDir . isDirectory () == false ) { throw new IllegalArgumentException ( lr_29 + destDir + lr_28 ) ; } if ( destDir == null ) { MST[NegateConditionalsMutator]MSP[N]
throws IOException { final boolean file1Exists = file1 . exists () ; if ( file1Exists != file2 . exists () ) { return false ; } if ( ! file1Exists ) { return true ; } if ( file1 . isDirectory () || file2 . isDirectory () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
if ( ! file . exists () ) { final String message = file + lr_42 ; MST[NonVoidMethodCallMutator]MSP[S] throw new IllegalArgumentException ( message ) ; } if ( file . isDirectory () ) { return sizeOfDirectory0 ( file ) ; } return file . length () ; }
throws IOException { final File [] srcFiles = filter == null ? srcDir . listFiles () : srcDir . listFiles ( filter ) ; if ( srcFiles == null ) { MST[NegateConditionalsMutator]MSP[N] throw new IOException ( lr_40 + srcDir ) ; } if ( destDir . exists () ) {
validateMoveParameters ( srcDir , destDir ) ; if ( ! srcDir . isDirectory () ) { throw new IOException ( lr_29 + srcDir + lr_28 ) ; } if ( destDir . exists () ) { throw new FileExistsException ( lr_27 + destDir + lr_60 ) ; MST[ConstructorCallMutator]MSP[S] }
size += sizeOf0 ( file ) ; if ( size < 0 ) { MST[rv.ABSMutator]MSP[N] break; } } } return size ; } private static long sizeOf0 ( final File file ) { if ( file . isDirectory () ) { return sizeOfDirectory0 ( file ) ; }
displaySize = String . valueOf ( size . divide ( ONE_MB_BI ) ) + lr_16 ; MST[NonVoidMethodCallMutator]MSP[N] } else if ( size . divide ( ONE_KB_BI ) . compareTo ( BigInteger . ZERO ) > 0 ) {
final String [] suffixes = new String [ extensions . length ] ; for ( int i = 0 ; i < extensions . length ; i ++ ) { MST[rv.ROR2Mutator]MSP[N] suffixes [ i ] = lr_22 + extensions [ i ] ; } return suffixes ; }
final Collection < File > files = new java . util . LinkedList <> () ; if ( includeSubDirectories ) { files . add ( directory ) ; MST[NonVoidMethodCallMutator]MSP[N] } innerListFiles ( files , directory , FileFilterUtils . or ( effFileFilter , effDirFilter ) , includeSubDirectories ) ; return files ;
return IOUtils . copyLarge ( fis , output ) ; MST[rv.UOI1Mutator]MSP[N] } } private static void doCopyFile ( final File srcFile , final File destFile , final boolean preserveFileDate ) throws IOException { if ( destFile . exists () && destFile . isDirectory () ) {
throws IOException { final File [] srcFiles = filter == null ? srcDir . listFiles () : srcDir . listFiles ( filter ) ; if ( srcFiles == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] throw new IOException ( lr_40 + srcDir ) ; } if ( destDir . exists () ) {
final File [] srcFiles = filter == null ? srcDir . listFiles () : srcDir . listFiles ( filter ) ; MST[NegateConditionalsMutator]MSP[N] if ( srcFiles != null && srcFiles . length > 0 ) { exclusionList = new ArrayList <> ( srcFiles . length ) ;
displaySize = String . valueOf ( size . divide ( ONE_PB_BI ) ) + lr_13 ; } else if ( size . divide ( ONE_TB_BI ) . compareTo ( BigInteger . ZERO ) > 0 ) { MST[rv.ROR2Mutator]MSP[N]
return BigInteger . valueOf ( file . length () ) ; MST[NonVoidMethodCallMutator]MSP[S] } public static long sizeOfDirectory ( final File directory ) { checkDirectory ( directory ) ; return sizeOfDirectory0 ( directory ) ; } private static long sizeOfDirectory0 ( final File directory ) {
return lineIterator ( file , null ) ; } public static void writeStringToFile ( final File file , final String data , final Charset encoding ) throws IOException { writeStringToFile ( file , data , encoding , false ) ; MST[InlineConstantMutator]MSP[N] }
final String [] suffixes = new String [ extensions . length ] ; for ( int i = 0 ; i < extensions . length ; i ++ ) { suffixes [ i ] = lr_22 + extensions [ i ] ; MST[rv.ABSMutator]MSP[N] } return suffixes ; }
if ( ! parentFile . mkdirs () && ! parentFile . isDirectory () ) { MST[NegateConditionalsMutator]MSP[N] throw new IOException ( lr_27 + parentFile + lr_32 ) ; } } if ( destFile . exists () && destFile . canWrite () == false ) {
final boolean file1Exists = file1 . exists () ; if ( file1Exists != file2 . exists () ) { return false ; } if ( ! file1Exists ) { return true ; MST[ReturnValsMutator]MSP[S] } if ( file1 . isDirectory () || file2 . isDirectory () ) {
public static void write ( final File file , final CharSequence data , final String encoding ) throws IOException { write ( file , data , encoding , false ) ; MST[InlineConstantMutator]MSP[N] }
throw new IOException ( lr_23 ) ; } if ( file1 . length () != file2 . length () ) { return false ; } if ( file1 . getCanonicalFile () . equals ( file2 . getCanonicalFile () ) ) { MST[NegateConditionalsMutator]MSP[S] return true ; }
return false ; } return file . lastModified () > timeMillis ; MST[rv.CRCR2Mutator]MSP[N] } public static boolean isFileOlder ( final File file , final File reference ) { if ( reference == null ) { throw new IllegalArgumentException ( lr_54 ) ; }
if ( ! destDir . exists () ) { throw new FileNotFoundException ( lr_66 + destDir + MST[rv.UOI3Mutator]MSP[N] lr_67 + createDestDir + lr_68 ) ; } if ( ! destDir . isDirectory () ) { throw new IOException ( lr_27 + destDir + lr_28 ) ; }
displaySize = String . valueOf ( size . divide ( ONE_EB_BI ) ) + lr_12 ; } else if ( size . divide ( ONE_PB_BI ) . compareTo ( BigInteger . ZERO ) > 0 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N]
throws IOException { final File [] srcFiles = filter == null ? srcDir . listFiles () : srcDir . listFiles ( filter ) ; if ( srcFiles == null ) { throw new IOException ( lr_40 + srcDir ) ; } if ( destDir . exists () ) { MST[NonVoidMethodCallMutator]MSP[N]
throws IOException { final boolean file1Exists = file1 . exists () ; if ( file1Exists != file2 . exists () ) { MST[rv.UOI1Mutator]MSP[S] return false ; } if ( ! file1Exists ) { return true ; } if ( file1 . isDirectory () || file2 . isDirectory () ) {
try ( OutputStream out = openOutputStream ( file , append ) ) { MST[rv.ABSMutator]MSP[N] out . write ( data , off , len ) ; } } public static void writeLines ( final File file , final String encoding , final Collection < ? > lines ) throws IOException {
if ( ! src . exists () ) { MST[rv.ROR4Mutator]MSP[N] throw new FileNotFoundException ( lr_29 + src + lr_8 ) ; } } private static void doCopyDirectory ( final File srcDir , final File destDir , final FileFilter filter , final boolean preserveFileDate , final List < String > exclusionList )
private static void checkDirectory ( final File directory ) { if ( ! directory . exists () ) { throw new IllegalArgumentException ( directory + lr_42 ) ; } if ( ! directory . isDirectory () ) { throw new IllegalArgumentException ( directory + lr_47 ) ; MST[experimental.NakedReceiverMutator]MSP[N] } }
throw new IOException ( lr_40 + directory ) ; MST[experimental.NakedReceiverMutator]MSP[S] } return files ; } public static boolean waitFor ( final File file , final int seconds ) { final long finishAt = System . currentTimeMillis () + ( seconds * 1000L ) ; boolean wasInterrupted = false ; try {
return BigInteger . valueOf ( file . length () ) ; } public static long sizeOfDirectory ( final File directory ) { checkDirectory ( directory ) ; return sizeOfDirectory0 ( directory ) ; MST[ReturnValsMutator]MSP[N] } private static long sizeOfDirectory0 ( final File directory ) {
if ( ! srcDir . isDirectory () ) { throw new IOException ( lr_29 + srcDir + lr_39 ) ; MST[NonVoidMethodCallMutator]MSP[S] } if ( srcDir . getCanonicalPath () . equals ( destDir . getCanonicalPath () ) ) {
validateMoveParameters ( srcDir , destDir ) ; if ( ! srcDir . isDirectory () ) { throw new IOException ( lr_29 + srcDir + lr_28 ) ; MST[NonVoidMethodCallMutator]MSP[S] } if ( destDir . exists () ) { throw new FileExistsException ( lr_27 + destDir + lr_60 ) ; }
public static File getUserDirectory () { return new File ( getUserDirectoryPath () ) ; } public static FileInputStream openInputStream ( final File file ) throws IOException { if ( file . exists () ) { if ( file . isDirectory () ) { MST[NonVoidMethodCallMutator]MSP[N]
final boolean filePresent = file . exists () ; if ( ! file . delete () ) { if ( ! filePresent ) { throw new FileNotFoundException ( lr_48 + file ) ; MST[NonVoidMethodCallMutator]MSP[N] } final String message = lr_49 + file ; throw new IOException ( message ) ; }
checksum ( file , crc ) ; return crc . getValue () ; } public static Checksum checksum ( final File file , final Checksum checksum ) throws IOException { if ( file . isDirectory () ) { MST[rv.ROR4Mutator]MSP[S] throw new IllegalArgumentException ( lr_59 ) ; }
return new File ( filename ) ; } static String decodeUrl ( final String url ) { String decoded = url ; if ( url != null && url . indexOf ( '%' ) >= 0 ) { final int n = url . length () ; MST[NonVoidMethodCallMutator]MSP[N]
public static void copyInputStreamToFile ( final InputStream source , final File destination ) throws IOException { try ( InputStream in = source ) { copyToFile ( in , destination ) ; MST[VoidMethodCallMutator]MSP[N] } } public static void copyToFile ( final InputStream source , final File destination ) throws IOException {
validateMoveParameters ( srcFile , destDir ) ; if ( ! destDir . exists () && createDestDir ) { destDir . mkdirs () ; } if ( ! destDir . exists () ) { throw new FileNotFoundException ( lr_66 + destDir + MST[rv.UOI2Mutator]MSP[N] lr_67 + createDestDir + lr_68 ) ; }
final File [] files = directory . listFiles () ; if ( files == null ) { return 0L ; } long size = 0 ; for ( final File file : files ) { if ( ! isSymlink ( file ) ) { MST[rv.ROR2Mutator]MSP[N]
if ( url == null || ! lr_24 . equalsIgnoreCase ( url . getProtocol () ) ) { return null ; } String filename = url . getFile () . replace ( '/' , File . separatorChar ) ; MST[rv.CRCR4Mutator]MSP[N] filename = decodeUrl ( filename ) ;
public static void copyURLToFile ( final URL source , final File destination ) throws IOException { copyInputStreamToFile ( source . openStream () , destination ) ; MST[NonVoidMethodCallMutator]MSP[N] } public static void copyURLToFile ( final URL source , final File destination ,
if ( ! directory . isDirectory () ) { throw new IllegalArgumentException ( lr_46 + directory ) ; } if ( child == null ) { return false ; } if ( ! directory . exists () || ! child . exists () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] return false ; }
return byteCountToDisplaySize ( BigInteger . valueOf ( size ) ) ; MST[rv.ABSMutator]MSP[N] } public static void touch ( final File file ) throws IOException { if ( ! file . exists () ) { openOutputStream ( file ) . close () ; }
} while ( i < n && url . charAt ( i ) == '%' ); MST[rv.CRCR2Mutator]MSP[S] continue; } catch ( final RuntimeException e ) { } finally { if ( bytes . position () > 0 ) { bytes . flip () ;
public static boolean isFileNewer ( final File file , final File reference ) { if ( reference == null ) { throw new IllegalArgumentException ( lr_54 ) ; } if ( ! reference . exists () ) { throw new IllegalArgumentException ( lr_55 MST[NonVoidMethodCallMutator]MSP[S] + reference + lr_56 ) ; }
validateMoveParameters ( srcDir , destDir ) ; if ( ! srcDir . isDirectory () ) { MST[rv.ROR1Mutator]MSP[N] throw new IOException ( lr_29 + srcDir + lr_28 ) ; } if ( destDir . exists () ) { throw new FileExistsException ( lr_27 + destDir + lr_60 ) ; }
size += sizeOf0 ( file ) ; if ( size < 0 ) { break; } } } return size ; MST[PrimitiveReturnsMutator]MSP[N] } private static long sizeOf0 ( final File file ) { if ( file . isDirectory () ) { return sizeOfDirectory0 ( file ) ; }
throw new IllegalArgumentException ( lr_58 ) ; } if ( ! file . exists () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] return false ; } return file . lastModified () < timeMillis ; } public static long checksumCRC32 ( final File file ) throws IOException { final CRC32 crc = new CRC32 () ;
: new InputStreamReader ( new FileInputStream ( file2 ) , charsetName ) ) { return IOUtils . contentEqualsIgnoreEOL ( input1 , input2 ) ; MST[rv.UOI2Mutator]MSP[N] } } public static File toFile ( final URL url ) {
throw new IllegalArgumentException ( lr_58 ) ; } if ( ! file . exists () ) { return false ; MST[rv.CRCR5Mutator]MSP[S] } return file . lastModified () < timeMillis ; } public static long checksumCRC32 ( final File file ) throws IOException { final CRC32 crc = new CRC32 () ;
validateMoveParameters ( srcFile , destDir ) ; if ( ! destDir . exists () && createDestDir ) { MST[rv.UOI2Mutator]MSP[N] destDir . mkdirs () ; } if ( ! destDir . exists () ) { throw new FileNotFoundException ( lr_66 + destDir + lr_67 + createDestDir + lr_68 ) ; }
if ( ! srcDir . isDirectory () ) { throw new IOException ( lr_29 + srcDir + lr_39 ) ; } if ( srcDir . getCanonicalPath () . equals ( destDir . getCanonicalPath () ) ) { MST[rv.ROR3Mutator]MSP[N]
public static File getFile ( final File directory , final String ... names ) { if ( directory == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] throw new NullPointerException ( lr_1 ) ; } if ( names == null ) { throw new NullPointerException ( lr_2 ) ; } File file = directory ;
throw new IOException ( lr_40 + directory ) ; } return files ; } public static boolean waitFor ( final File file , final int seconds ) { final long finishAt = System . currentTimeMillis () + ( seconds * 1000L ) ; boolean wasInterrupted = false ; MST[InlineConstantMutator]MSP[N] try {
if ( ! file . exists () ) { final String message = file + lr_42 ; throw new IllegalArgumentException ( message ) ; } if ( file . isDirectory () ) { MST[rv.ROR4Mutator]MSP[N] return sizeOfDirectory0 ( file ) ; } return file . length () ; }
final boolean rename = srcDir . renameTo ( destDir ) ; if ( ! rename ) { if ( destDir . getCanonicalPath () . startsWith ( srcDir . getCanonicalPath () + File . separator ) ) { throw new IOException ( lr_61 + srcDir + lr_62 + destDir ) ; MST[experimental.NakedReceiverMutator]MSP[N]
} while ( i < n && url . charAt ( i ) == '%' ); MST[rv.UOI2Mutator]MSP[N] continue; } catch ( final RuntimeException e ) { } finally { if ( bytes . position () > 0 ) { bytes . flip () ;
throw new IOException ( lr_29 + srcFile + lr_69 ) ; } if ( destFile . exists () ) { throw new FileExistsException ( lr_27 + destFile + lr_60 ) ; MST[NonVoidMethodCallMutator]MSP[S] } if ( destFile . isDirectory () ) {
cleanDirectory ( directory ) ; } if ( ! directory . delete () ) { MST[rv.ROR3Mutator]MSP[N] final String message = lr_44 + directory + lr_22 ; throw new IOException ( message ) ; } } public static boolean deleteQuietly ( final File file ) {
if ( ! destDir . exists () ) { MST[rv.ROR2Mutator]MSP[N] throw new FileNotFoundException ( lr_66 + destDir + lr_67 + createDestDir + lr_68 ) ; } if ( ! destDir . isDirectory () ) { throw new IOException ( lr_27 + destDir + lr_28 ) ; }
: new InputStreamReader ( new FileInputStream ( file2 ) , charsetName ) ) { return IOUtils . contentEqualsIgnoreEOL ( input1 , input2 ) ; MST[BooleanTrueReturnValsMutator]MSP[S] } } public static File toFile ( final URL url ) {
final boolean append ) throws IOException { writeStringToFile ( file , data , Charsets . toCharset ( encoding ) , append ) ; MST[rv.UOI3Mutator]MSP[S] } @Deprecated public static void writeStringToFile ( final File file , final String data ) throws IOException {
throw new IOException ( lr_27 + destDir + lr_32 ) ; } } if ( destDir . canWrite () == false ) { MST[rv.ROR2Mutator]MSP[N] throw new IOException ( lr_27 + destDir + lr_9 ) ; } for ( final File srcFile : srcFiles ) {
final byte octet = ( byte ) Integer . parseInt ( url . substring ( i + 1 , i + 3 ) , 16 ) ; MST[InlineConstantMutator]MSP[N] bytes . put ( octet ) ; i += 3 ;
try ( OutputStream out = openOutputStream ( destination ) ) { IOUtils . copy ( source , out ) ; } } public static void copyToDirectory ( final File src , final File destDir ) throws IOException { if ( src == null ) { MST[rv.ROR5Mutator]MSP[N]
return fileLength > 0 ? IOUtils . toByteArray ( in , fileLength ) : IOUtils . toByteArray ( in ) ; MST[rv.ROR3Mutator]MSP[N] } } public static List < String > readLines ( final File file , final Charset encoding ) throws IOException {
public static void moveToDirectory ( final File src , final File destDir , final boolean createDestDir ) throws IOException { validateMoveParameters ( src , destDir ) ; if ( src . isDirectory () ) { moveDirectoryToDirectory ( src , destDir , createDestDir ) ; MST[rv.UOI3Mutator]MSP[N] } else {
for ( int i = 0 ; i < urls . length ; i ++ ) { final URL url = urls [ i ] ; if ( url != null ) { if ( url . getProtocol () . equals ( lr_24 ) == false ) { MST[NonVoidMethodCallMutator]MSP[N]
throw new IOException ( lr_27 + destDir + lr_32 ) ; } } if ( destDir . canWrite () == false ) { throw new IOException ( lr_27 + destDir + lr_9 ) ; } for ( final File srcFile : srcFiles ) { MST[rv.UOI1Mutator]MSP[N]
final String [] suffixes = new String [ extensions . length ] ; for ( int i = 0 ; i < extensions . length ; i ++ ) { MST[rv.UOI3Mutator]MSP[N] suffixes [ i ] = lr_22 + extensions [ i ] ; } return suffixes ; }
if ( url == null || ! lr_24 . equalsIgnoreCase ( url . getProtocol () ) ) { return null ; } String filename = url . getFile () . replace ( '/' , File . separatorChar ) ; MST[rv.CRCR1Mutator]MSP[N] filename = decodeUrl ( filename ) ;
writeByteArrayToFile ( file , data , off , len , false ) ; MST[InlineConstantMutator]MSP[N] } public static void writeByteArrayToFile ( final File file , final byte [] data , final int off , final int len , final boolean append ) throws IOException {
File file = null ; for ( final String name : names ) { MST[rv.ABSMutator]MSP[S] if ( file == null ) { file = new File ( name ) ; } else { file = new File ( file , name ) ; } } return file ; }
} while ( i < n && url . charAt ( i ) == '%' ); MST[rv.ROR5Mutator]MSP[N] continue; } catch ( final RuntimeException e ) { } finally { if ( bytes . position () > 0 ) { bytes . flip () ;
throw new IOException ( lr_23 ) ; } if ( file1 . length () != file2 . length () ) { return false ; MST[InlineConstantMutator]MSP[N] } if ( file1 . getCanonicalFile () . equals ( file2 . getCanonicalFile () ) ) { return true ; }
if ( srcLen != dstLen ) { MST[rv.UOI4Mutator]MSP[N] throw new IOException ( lr_34 + srcFile + lr_35 + destFile + lr_36 + srcLen + lr_37 + dstLen ) ; } } public static void copyDirectoryToDirectory ( final File srcDir , final File destDir ) throws IOException {
} catch ( final Exception ignored ) { return false ; } } public static boolean directoryContains ( final File directory , final File child ) throws IOException { if ( directory == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] throw new IllegalArgumentException ( lr_45 ) ; }
throws IOException { final boolean file1Exists = file1 . exists () ; if ( file1Exists != file2 . exists () ) { return false ; } if ( ! file1Exists ) { return true ; } if ( file1 . isDirectory () || file2 . isDirectory () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
return false ; } return file . lastModified () > timeMillis ; MST[rv.ROR1Mutator]MSP[S] } public static boolean isFileOlder ( final File file , final File reference ) { if ( reference == null ) { throw new IllegalArgumentException ( lr_54 ) ; }
final boolean rename = srcDir . renameTo ( destDir ) ; if ( ! rename ) { if ( destDir . getCanonicalPath () . startsWith ( srcDir . getCanonicalPath () + File . separator ) ) { MST[NonVoidMethodCallMutator]MSP[N] throw new IOException ( lr_61 + srcDir + lr_62 + destDir ) ;
validateMoveParameters ( srcFile , destDir ) ; if ( ! destDir . exists () && createDestDir ) { MST[rv.ROR3Mutator]MSP[N] destDir . mkdirs () ; } if ( ! destDir . exists () ) { throw new FileNotFoundException ( lr_66 + destDir + lr_67 + createDestDir + lr_68 ) ; }
public static void copyURLToFile ( final URL source , final File destination ) throws IOException { copyInputStreamToFile ( source . openStream () , destination ) ; MST[VoidMethodCallMutator]MSP[N] } public static void copyURLToFile ( final URL source , final File destination ,
while ( ! file . exists () ) { final long remaining = finishAt - System . currentTimeMillis () ; if ( remaining < 0 ) { MST[InlineConstantMutator]MSP[N] return false ; } try { Thread . sleep ( Math . min ( 100 , remaining ) ) ;
writeByteArrayToFile ( file , data , off , len , false ) ; MST[rv.ABSMutator]MSP[S] } public static void writeByteArrayToFile ( final File file , final byte [] data , final int off , final int len , final boolean append ) throws IOException {
return false ; } return file . lastModified () > timeMillis ; } public static boolean isFileOlder ( final File file , final File reference ) { if ( reference == null ) { throw new IllegalArgumentException ( lr_54 ) ; MST[ConstructorCallMutator]MSP[S] }
for ( final String name : names ) { file = new File ( file , name ) ; } return file ; } public static File getFile ( final String ... names ) { if ( names == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] throw new NullPointerException ( lr_2 ) ; }
if ( ! directory . exists () ) { MST[rv.ROR4Mutator]MSP[N] return; } directory . deleteOnExit () ; if ( ! isSymlink ( directory ) ) { cleanDirectoryOnExit ( directory ) ; } } private static void cleanDirectoryOnExit ( final File directory ) throws IOException {
if ( ! file . exists () ) { final String message = file + lr_42 ; throw new IllegalArgumentException ( message ) ; } if ( file . isDirectory () ) { return sizeOfDirectory0 ( file ) ; } return file . length () ; MST[PrimitiveReturnsMutator]MSP[N] }
throw new IllegalArgumentException ( lr_58 ) ; } if ( ! file . exists () ) { MST[NegateConditionalsMutator]MSP[S] return false ; } return file . lastModified () < timeMillis ; } public static long checksumCRC32 ( final File file ) throws IOException { final CRC32 crc = new CRC32 () ;
displaySize = String . valueOf ( size . divide ( ONE_PB_BI ) ) + lr_13 ; } else if ( size . divide ( ONE_TB_BI ) . compareTo ( BigInteger . ZERO ) > 0 ) { MST[rv.ROR5Mutator]MSP[N]
moveFileToDirectory ( src , destDir , createDestDir ) ; } } private static void validateMoveParameters ( final File src , final File dest ) throws FileNotFoundException { if ( src == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] throw new NullPointerException ( lr_38 ) ; } if ( dest == null ) {
} public static void write ( final File file , final CharSequence data , final String encoding , final boolean append ) throws IOException { write ( file , data , Charsets . toCharset ( encoding ) , append ) ; MST[rv.UOI1Mutator]MSP[N] }
throw new IOException ( lr_29 + srcFile + lr_69 ) ; } if ( destFile . exists () ) { throw new FileExistsException ( lr_27 + destFile + lr_60 ) ; MST[experimental.NakedReceiverMutator]MSP[N] } if ( destFile . isDirectory () ) {
try { if ( in != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] in . close () ; } } catch ( final IOException e ) { ex . addSuppressed ( e ) ; } throw ex ; } } public static LineIterator lineIterator ( final File file ) throws IOException {
} while ( i < n && url . charAt ( i ) == '%' ); MST[rv.ABSMutator]MSP[S] continue; } catch ( final RuntimeException e ) { } finally { if ( bytes . position () > 0 ) { bytes . flip () ;
throw new NullPointerException ( lr_38 ) ; } if ( src . isFile () ) { copyFileToDirectory ( src , destDir ) ; } else if ( src . isDirectory () ) { MST[NonVoidMethodCallMutator]MSP[S] copyDirectoryToDirectory ( src , destDir ) ; } else {
File file = null ; for ( final String name : names ) { MST[rv.UOI2Mutator]MSP[S] if ( file == null ) { file = new File ( name ) ; } else { file = new File ( file , name ) ; } } return file ; }
private static void checkDirectory ( final File directory ) { if ( ! directory . exists () ) { throw new IllegalArgumentException ( directory + lr_42 ) ; } if ( ! directory . isDirectory () ) { throw new IllegalArgumentException ( directory + lr_47 ) ; MST[ConstructorCallMutator]MSP[N] } }
public static void writeByteArrayToFile ( final File file , final byte [] data ) throws IOException { writeByteArrayToFile ( file , data , false ) ; MST[VoidMethodCallMutator]MSP[S] } public static void writeByteArrayToFile ( final File file , final byte [] data , final boolean append ) throws IOException {
checksum ( file , crc ) ; return crc . getValue () ; MST[ReturnValsMutator]MSP[S] } public static Checksum checksum ( final File file , final Checksum checksum ) throws IOException { if ( file . isDirectory () ) { throw new IllegalArgumentException ( lr_59 ) ; }
public static Collection < File > listFiles ( final File directory , final String [] extensions , final boolean recursive ) { IOFileFilter filter ; if ( extensions == null ) { MST[NegateConditionalsMutator]MSP[N] filter = TrueFileFilter . INSTANCE ; } else {
final boolean rename = srcDir . renameTo ( destDir ) ; if ( ! rename ) { if ( destDir . getCanonicalPath () . startsWith ( srcDir . getCanonicalPath () + File . separator ) ) { throw new IOException ( lr_61 + srcDir + lr_62 + destDir ) ; MST[NonVoidMethodCallMutator]MSP[S]
final File [] files = verifiedListFiles ( directory ) ; IOException exception = null ; for ( final File file : files ) { MST[rv.UOI1Mutator]MSP[N] try { forceDelete ( file ) ; } catch ( final IOException ioe ) { exception = ioe ; } }
while ( ! file . exists () ) { final long remaining = finishAt - System . currentTimeMillis () ; if ( remaining < 0 ) { return false ; } try { Thread . sleep ( Math . min ( 100 , remaining ) ) ; MST[ArgumentPropagationMutator]MSP[N]
if ( ! destDir . exists () ) { throw new FileNotFoundException ( lr_66 + destDir + lr_67 + createDestDir + lr_68 ) ; } if ( ! destDir . isDirectory () ) { MST[rv.ROR5Mutator]MSP[N] throw new IOException ( lr_27 + destDir + lr_28 ) ; }
if ( ! srcDir . isDirectory () ) { throw new IOException ( lr_29 + srcDir + lr_39 ) ; MST[experimental.NakedReceiverMutator]MSP[N] } if ( srcDir . getCanonicalPath () . equals ( destDir . getCanonicalPath () ) ) {
} catch ( final InterruptedException ignore ) { wasInterrupted = true ; } catch ( final Exception ex ) { break; } } } finally { if ( wasInterrupted ) { Thread . currentThread () . interrupt () ; MST[NonVoidMethodCallMutator]MSP[S] } } return true ; }
displaySize = String . valueOf ( size . divide ( ONE_TB_BI ) ) + lr_14 ; } else if ( size . divide ( ONE_GB_BI ) . compareTo ( BigInteger . ZERO ) > 0 ) { MST[experimental.NakedReceiverMutator]MSP[N]
throw new IllegalArgumentException ( lr_58 ) ; } if ( ! file . exists () ) { return false ; } return file . lastModified () < timeMillis ; MST[rv.CRCR1Mutator]MSP[S] } public static long checksumCRC32 ( final File file ) throws IOException { final CRC32 crc = new CRC32 () ;
return fileLength > 0 ? IOUtils . toByteArray ( in , fileLength ) : IOUtils . toByteArray ( in ) ; MST[rv.UOI3Mutator]MSP[S] } } public static List < String > readLines ( final File file , final Charset encoding ) throws IOException {
FileUtils . deleteQuietly ( destFile ) ; throw new IOException ( lr_70 + srcFile + MST[experimental.NakedReceiverMutator]MSP[N] lr_64 + destFile + lr_65 ) ; } } } public static void moveFileToDirectory ( final File srcFile , final File destDir , final boolean createDestDir ) throws IOException {
final File [] srcFiles = filter == null ? srcDir . listFiles () : srcDir . listFiles ( filter ) ; if ( srcFiles != null && srcFiles . length > 0 ) { MST[rv.ROR4Mutator]MSP[N] exclusionList = new ArrayList <> ( srcFiles . length ) ;
size += sizeOf0 ( file ) ; if ( size < 0 ) { break; } } } return size ; } private static long sizeOf0 ( final File file ) { if ( file . isDirectory () ) { MST[rv.ROR1Mutator]MSP[N] return sizeOfDirectory0 ( file ) ; }
throw new IOException ( lr_27 + destFile + lr_6 ) ; } final Path srcPath = srcFile . toPath () ; final Path destPath = destFile . toPath () ; final long newLastModifed = preserveFileDate ? srcFile . lastModified () : destFile . lastModified () ; MST[NonVoidMethodCallMutator]MSP[S]
throw new IOException ( lr_41 + src + lr_42 ) ; MST[NonVoidMethodCallMutator]MSP[S] } } public static void copyToDirectory ( final Iterable < File > srcs , final File destDir ) throws IOException { if ( srcs == null ) { throw new NullPointerException ( lr_43 ) ; }
final boolean filePresent = file . exists () ; if ( ! file . delete () ) { if ( ! filePresent ) { throw new FileNotFoundException ( lr_48 + file ) ; MST[experimental.NakedReceiverMutator]MSP[N] } final String message = lr_49 + file ; throw new IOException ( message ) ; }
if ( ! directory . isDirectory () ) { final String message = directory + lr_47 ; MST[NonVoidMethodCallMutator]MSP[S] throw new IllegalArgumentException ( message ) ; } final File [] files = directory . listFiles () ; if ( files == null ) {
final File directory , final IOFileFilter fileFilter , final IOFileFilter dirFilter ) { return innerListFilesOrDirectories ( directory , fileFilter , dirFilter , false ) ; } private static void validateListFilesParameters ( final File directory , final IOFileFilter fileFilter ) { if ( ! directory . isDirectory () ) { MST[rv.ROR3Mutator]MSP[N]
return file . length () ; MST[NonVoidMethodCallMutator]MSP[N] } public static BigInteger sizeOfDirectoryAsBigInteger ( final File directory ) { checkDirectory ( directory ) ; return sizeOfDirectoryBig0 ( directory ) ; } private static BigInteger sizeOfDirectoryBig0 ( final File directory ) { final File [] files = directory . listFiles () ;
doCopyDirectory ( srcFile , dstFile , filter , preserveFileDate , exclusionList ) ; } else { doCopyFile ( srcFile , dstFile , preserveFileDate ) ; } } } if ( preserveFileDate ) { MST[rv.UOI1Mutator]MSP[N] destDir . setLastModified ( srcDir . lastModified () ) ; } }
if ( files == null ) { return BigInteger . ZERO ; } BigInteger size = BigInteger . ZERO ; for ( final File file : files ) { if ( ! isSymlink ( file ) ) { MST[NonVoidMethodCallMutator]MSP[S] size = size . add ( sizeOfBig0 ( file ) ) ;
if ( destDir == null ) { throw new NullPointerException ( lr_26 ) ; } if ( destDir . exists () && destDir . isDirectory () == false ) { MST[NonVoidMethodCallMutator]MSP[N] throw new IllegalArgumentException ( lr_27 + destDir + lr_28 ) ; }
throw new IOException ( lr_23 ) ; } if ( file1 . length () != file2 . length () ) { return false ; } if ( file1 . getCanonicalFile () . equals ( file2 . getCanonicalFile () ) ) { return true ; MST[ReturnValsMutator]MSP[N] }
if ( ! directory . isDirectory () ) { MST[rv.ROR3Mutator]MSP[N] throw new IllegalArgumentException ( lr_46 + directory ) ; } if ( child == null ) { return false ; } if ( ! directory . exists () || ! child . exists () ) { return false ; }
validateMoveParameters ( srcDir , destDir ) ; if ( ! srcDir . isDirectory () ) { throw new IOException ( lr_29 + srcDir + lr_28 ) ; MST[experimental.NakedReceiverMutator]MSP[N] } if ( destDir . exists () ) { throw new FileExistsException ( lr_27 + destDir + lr_60 ) ; }
public static String readFileToString ( final File file , final Charset encoding ) throws IOException { try ( InputStream in = openInputStream ( file ) ) { return IOUtils . toString ( in , Charsets . toCharset ( encoding ) ) ; MST[EmptyObjectReturnValsMutator]MSP[N] } }
throws IOException { final boolean file1Exists = file1 . exists () ; if ( file1Exists != file2 . exists () ) { return false ; } if ( ! file1Exists ) { MST[rv.ROR3Mutator]MSP[N] return true ; } if ( file1 . isDirectory () || file2 . isDirectory () ) {
if ( ! destDir . isDirectory () ) { MST[rv.ROR1Mutator]MSP[N] throw new IOException ( lr_27 + destDir + lr_28 ) ; } moveFile ( srcFile , new File ( destDir , srcFile . getName () ) ) ; }
if ( ! destDir . isDirectory () ) { MST[rv.ROR4Mutator]MSP[N] throw new IOException ( lr_27 + destDir + lr_28 ) ; } moveFile ( srcFile , new File ( destDir , srcFile . getName () ) ) ; }
try ( OutputStream out = openOutputStream ( file , append ) ) { out . write ( data , off , len ) ; MST[rv.UOI3Mutator]MSP[N] } } public static void writeLines ( final File file , final String encoding , final Collection < ? > lines ) throws IOException {
try ( InputStream input1 = new FileInputStream ( file1 ) ; InputStream input2 = new FileInputStream ( file2 ) ) { return IOUtils . contentEquals ( input1 , input2 ) ; MST[BooleanFalseReturnValsMutator]MSP[S] } } public static boolean contentEqualsIgnoreEOL ( final File file1 , final File file2 , final String charsetName )
displaySize = String . valueOf ( size . divide ( ONE_EB_BI ) ) + lr_12 ; } else if ( size . divide ( ONE_PB_BI ) . compareTo ( BigInteger . ZERO ) > 0 ) { MST[NonVoidMethodCallMutator]MSP[N]
} } return size ; } private static BigInteger sizeOfBig0 ( final File fileOrDir ) { if ( fileOrDir . isDirectory () ) { MST[rv.ROR2Mutator]MSP[N] return sizeOfDirectoryBig0 ( fileOrDir ) ; } return BigInteger . valueOf ( fileOrDir . length () ) ; }
final boolean file1Exists = file1 . exists () ; if ( file1Exists != file2 . exists () ) { MST[NegateConditionalsMutator]MSP[N] return false ; } if ( ! file1Exists ) { return true ; } if ( file1 . isDirectory () || file2 . isDirectory () ) {
final Collection < File > files = new java . util . LinkedList <> () ; if ( includeSubDirectories ) { files . add ( directory ) ; } innerListFiles ( files , directory , FileFilterUtils . or ( effFileFilter , effDirFilter ) , includeSubDirectories ) ; MST[rv.UOI2Mutator]MSP[N] return files ;
while ( ! file . exists () ) { final long remaining = finishAt - System . currentTimeMillis () ; if ( remaining < 0 ) { MST[rv.ROR4Mutator]MSP[N] return false ; } try { Thread . sleep ( Math . min ( 100 , remaining ) ) ;
} else { final File parent = file . getParentFile () ; if ( parent != null ) { if ( ! parent . mkdirs () && ! parent . isDirectory () ) { MST[rv.ROR5Mutator]MSP[N] throw new IOException ( lr_10 + parent + lr_11 ) ; } } }
} else { final File parent = file . getParentFile () ; MST[NonVoidMethodCallMutator]MSP[S] if ( parent != null ) { if ( ! parent . mkdirs () && ! parent . isDirectory () ) { throw new IOException ( lr_10 + parent + lr_11 ) ; } } }
} copyDirectory ( srcDir , destDir ) ; deleteDirectory ( srcDir ) ; if ( srcDir . exists () ) { MST[NonVoidMethodCallMutator]MSP[N] throw new IOException ( lr_63 + srcDir + lr_64 + destDir + lr_65 ) ; } } }
while ( ! file . exists () ) { final long remaining = finishAt - System . currentTimeMillis () ; if ( remaining < 0 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] return false ; } try { Thread . sleep ( Math . min ( 100 , remaining ) ) ;
copyDirectory ( srcDir , new File ( destDir , srcDir . getName () ) , true ) ; } public static void copyDirectory ( final File srcDir , final File destDir ) throws IOException { copyDirectory ( srcDir , destDir , true ) ; MST[rv.CRCR5Mutator]MSP[N] }
displaySize = String . valueOf ( size . divide ( ONE_TB_BI ) ) + lr_14 ; MST[experimental.BigIntegerMutator]MSP[N] } else if ( size . divide ( ONE_GB_BI ) . compareTo ( BigInteger . ZERO ) > 0 ) {
while ( ! file . exists () ) { final long remaining = finishAt - System . currentTimeMillis () ; if ( remaining < 0 ) { MST[rv.ABSMutator]MSP[N] return false ; } try { Thread . sleep ( Math . min ( 100 , remaining ) ) ;
size += sizeOf0 ( file ) ; if ( size < 0 ) { break; } } } return size ; } private static long sizeOf0 ( final File file ) { if ( file . isDirectory () ) { MST[NegateConditionalsMutator]MSP[N] return sizeOfDirectory0 ( file ) ; }
return new File ( filename ) ; } static String decodeUrl ( final String url ) { String decoded = url ; if ( url != null && url . indexOf ( '%' ) >= 0 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] final int n = url . length () ;
} while ( i < n && url . charAt ( i ) == '%' ); continue; } catch ( final RuntimeException e ) { } finally { if ( bytes . position () > 0 ) { MST[ConditionalsBoundaryMutator]MSP[N] bytes . flip () ;
throw new NullPointerException ( lr_38 ) ; } if ( src . isFile () ) { copyFileToDirectory ( src , destDir ) ; } else if ( src . isDirectory () ) { MST[rv.ROR2Mutator]MSP[N] copyDirectoryToDirectory ( src , destDir ) ; } else {
final boolean filePresent = file . exists () ; if ( ! file . delete () ) { if ( ! filePresent ) { MST[rv.ROR3Mutator]MSP[N] throw new FileNotFoundException ( lr_48 + file ) ; } final String message = lr_49 + file ; throw new IOException ( message ) ; }
if ( ! reference . exists () ) { throw new IllegalArgumentException ( lr_55 MST[NonVoidMethodCallMutator]MSP[S] + reference + lr_56 ) ; } return isFileOlder ( file , reference . lastModified () ) ; } public static boolean isFileOlder ( final File file , final Date date ) {
public static void moveToDirectory ( final File src , final File destDir , final boolean createDestDir ) throws IOException { validateMoveParameters ( src , destDir ) ; if ( src . isDirectory () ) { MST[NonVoidMethodCallMutator]MSP[S] moveDirectoryToDirectory ( src , destDir , createDestDir ) ; } else {
public static void moveDirectoryToDirectory ( final File src , final File destDir , final boolean createDestDir ) throws IOException { validateMoveParameters ( src , destDir ) ; if ( ! destDir . exists () && createDestDir ) { MST[rv.UOI3Mutator]MSP[N] destDir . mkdirs () ; }
throw new IOException ( lr_29 + srcDir + lr_30 + destDir + lr_31 ) ; MST[NonVoidMethodCallMutator]MSP[S] } List < String > exclusionList = null ; if ( destDir . getCanonicalPath () . startsWith ( srcDir . getCanonicalPath () ) ) {
throw new NullPointerException ( lr_26 ) ; MST[ConstructorCallMutator]MSP[N] } if ( ! src . exists () ) { throw new FileNotFoundException ( lr_29 + src + lr_8 ) ; } } public static boolean isSymlink ( final File file ) { if ( file == null ) {
final FileFilter filter ) throws IOException { copyDirectory ( srcDir , destDir , filter , true ) ; MST[rv.CRCR2Mutator]MSP[N] } public static void copyDirectory ( final File srcDir , final File destDir , final FileFilter filter , final boolean preserveFileDate ) throws IOException { checkFileRequirements ( srcDir , destDir ) ;
throws IOException { final boolean file1Exists = file1 . exists () ; if ( file1Exists != file2 . exists () ) { return false ; } if ( ! file1Exists ) { MST[rv.UOI2Mutator]MSP[N] return true ; } if ( file1 . isDirectory () || file2 . isDirectory () ) {
} while ( i < n && url . charAt ( i ) == '%' ); MST[NonVoidMethodCallMutator]MSP[S] continue; } catch ( final RuntimeException e ) { } finally { if ( bytes . position () > 0 ) { bytes . flip () ;
if ( file . exists () ) { if ( file . isDirectory () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] throw new IOException ( lr_5 + file + lr_6 ) ; } if ( file . canWrite () == false ) { throw new IOException ( lr_5 + file + lr_9 ) ; }
throw new IOException ( lr_23 ) ; } if ( file1 . length () != file2 . length () ) { return false ; MST[rv.CRCR1Mutator]MSP[N] } if ( file1 . getCanonicalFile () . equals ( file2 . getCanonicalFile () ) ) { return true ; }
return IOUtils . copyLarge ( fis , output ) ; } } private static void doCopyFile ( final File srcFile , final File destFile , final boolean preserveFileDate ) throws IOException { if ( destFile . exists () && destFile . isDirectory () ) { MST[rv.ROR1Mutator]MSP[N]
final StringBuilder buffer = new StringBuilder () ; final ByteBuffer bytes = ByteBuffer . allocate ( n ) ; MST[rv.UOI4Mutator]MSP[N] for ( int i = 0 ; i < n ; ) { if ( url . charAt ( i ) == '%' ) { try { do {
} else { final File parent = file . getParentFile () ; if ( parent != null ) { if ( ! parent . mkdirs () && ! parent . isDirectory () ) { MST[rv.ROR2Mutator]MSP[N] throw new IOException ( lr_10 + parent + lr_11 ) ; } } }
return byteCountToDisplaySize ( BigInteger . valueOf ( size ) ) ; MST[rv.UOI2Mutator]MSP[N] } public static void touch ( final File file ) throws IOException { if ( ! file . exists () ) { openOutputStream ( file ) . close () ; }
final boolean file1Exists = file1 . exists () ; if ( file1Exists != file2 . exists () ) { MST[rv.UOI2Mutator]MSP[N] return false ; } if ( ! file1Exists ) { return true ; } if ( file1 . isDirectory () || file2 . isDirectory () ) {
throw new IOException ( lr_5 + file + lr_6 ) ; } if ( file . canRead () == false ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] throw new IOException ( lr_5 + file + lr_7 ) ; } } else { throw new FileNotFoundException ( lr_5 + file + lr_8 ) ; }
return new FileInputStream ( file ) ; } public static FileOutputStream openOutputStream ( final File file ) throws IOException { return openOutputStream ( file , false ) ; MST[ReturnValsMutator]MSP[N] } public static FileOutputStream openOutputStream ( final File file , final boolean append ) throws IOException {
if ( file == null ) { return false ; MST[BooleanTrueReturnValsMutator]MSP[N] } try { if ( file . isDirectory () ) { cleanDirectory ( file ) ; } } catch ( final Exception ignored ) { } try { return file . delete () ;
private static void checkDirectory ( final File directory ) { if ( ! directory . exists () ) { throw new IllegalArgumentException ( directory + lr_42 ) ; } if ( ! directory . isDirectory () ) { throw new IllegalArgumentException ( directory + lr_47 ) ; MST[NonVoidMethodCallMutator]MSP[N] } }
size += sizeOf0 ( file ) ; if ( size < 0 ) { MST[NegateConditionalsMutator]MSP[N] break; } } } return size ; } private static long sizeOf0 ( final File file ) { if ( file . isDirectory () ) { return sizeOfDirectory0 ( file ) ; }
if ( srcLen != dstLen ) { throw new IOException ( lr_34 + srcFile + lr_35 + destFile MST[rv.UOI1Mutator]MSP[N] + lr_36 + srcLen + lr_37 + dstLen ) ; } } public static void copyDirectoryToDirectory ( final File srcDir , final File destDir ) throws IOException {
validateMoveParameters ( srcFile , destDir ) ; if ( ! destDir . exists () && createDestDir ) { destDir . mkdirs () ; } if ( ! destDir . exists () ) { throw new FileNotFoundException ( lr_66 + destDir + MST[experimental.NakedReceiverMutator]MSP[N] lr_67 + createDestDir + lr_68 ) ; }
if ( destDir == null ) { MST[rv.ROR5Mutator]MSP[N] throw new NullPointerException ( lr_26 ) ; } if ( destDir . exists () && destDir . isDirectory () == false ) { throw new IllegalArgumentException ( lr_27 + destDir + lr_28 ) ; }
final boolean filePresent = file . exists () ; if ( ! file . delete () ) { if ( ! filePresent ) { MST[rv.UOI2Mutator]MSP[N] throw new FileNotFoundException ( lr_48 + file ) ; } final String message = lr_49 + file ; throw new IOException ( message ) ; }
public static Collection < File > listFilesAndDirs ( final File directory , final IOFileFilter fileFilter , final IOFileFilter dirFilter ) { return innerListFilesOrDirectories ( directory , fileFilter , dirFilter , true ) ; MST[EmptyObjectReturnValsMutator]MSP[N] } private static Collection < File > innerListFilesOrDirectories (
return lineIterator ( file , null ) ; MST[NullReturnValsMutator]MSP[S] } public static void writeStringToFile ( final File file , final String data , final Charset encoding ) throws IOException { writeStringToFile ( file , data , encoding , false ) ; }
while ( ! file . exists () ) { final long remaining = finishAt - System . currentTimeMillis () ; if ( remaining < 0 ) { MST[rv.ROR1Mutator]MSP[N] return false ; } try { Thread . sleep ( Math . min ( 100 , remaining ) ) ;
: new InputStreamReader ( new FileInputStream ( file2 ) , charsetName ) ) { return IOUtils . contentEqualsIgnoreEOL ( input1 , input2 ) ; MST[rv.ABSMutator]MSP[N] } } public static File toFile ( final URL url ) {
writeByteArrayToFile ( file , data , 0 , data . length , append ) ; MST[rv.CRCR6Mutator]MSP[N] } public static void writeByteArrayToFile ( final File file , final byte [] data , final int off , final int len ) throws IOException {
try ( InputStream input1 = new FileInputStream ( file1 ) ; InputStream input2 = new FileInputStream ( file2 ) ) { return IOUtils . contentEquals ( input1 , input2 ) ; MST[ReturnValsMutator]MSP[N] } } public static boolean contentEqualsIgnoreEOL ( final File file1 , final File file2 , final String charsetName )
return FileFilterUtils . and ( fileFilter , FileFilterUtils . notFileFilter ( DirectoryFileFilter . INSTANCE ) ) ; MST[rv.CRCR2Mutator]MSP[N] } private static IOFileFilter setUpEffectiveDirFilter ( final IOFileFilter dirFilter ) { return dirFilter == null ? FalseFileFilter . INSTANCE : FileFilterUtils . and ( dirFilter , DirectoryFileFilter . INSTANCE ) ; }
validateMoveParameters ( srcFile , destDir ) ; if ( ! destDir . exists () && createDestDir ) { destDir . mkdirs () ; } if ( ! destDir . exists () ) { MST[rv.ROR1Mutator]MSP[N] throw new FileNotFoundException ( lr_66 + destDir + lr_67 + createDestDir + lr_68 ) ; }
final File dstFile = new File ( destDir , srcFile . getName () ) ; if ( exclusionList == null || ! exclusionList . contains ( srcFile . getCanonicalPath () ) ) { MST[NegateConditionalsMutator]MSP[N] if ( srcFile . isDirectory () ) {
if ( null != exception ) { throw exception ; } } public static void forceMkdir ( final File directory ) throws IOException { if ( directory . exists () ) { if ( ! directory . isDirectory () ) { final String message = MST[experimental.NakedReceiverMutator]MSP[N] lr_50 + directory + lr_51
copyDirectory ( srcDir , new File ( destDir , srcDir . getName () ) , true ) ; } public static void copyDirectory ( final File srcDir , final File destDir ) throws IOException { copyDirectory ( srcDir , destDir , true ) ; MST[VoidMethodCallMutator]MSP[N] }
final File [] files = directory . listFiles () ; if ( files == null ) { return 0L ; } long size = 0 ; for ( final File file : files ) { MST[rv.UOI4Mutator]MSP[N] if ( ! isSymlink ( file ) ) {
} catch ( final Exception ignored ) { return false ; MST[rv.CRCR3Mutator]MSP[S] } } public static boolean directoryContains ( final File directory , final File child ) throws IOException { if ( directory == null ) { throw new IllegalArgumentException ( lr_45 ) ; }
if ( ! src . exists () ) { MST[rv.ROR1Mutator]MSP[N] throw new FileNotFoundException ( lr_29 + src + lr_8 ) ; } } private static void doCopyDirectory ( final File srcDir , final File destDir , final FileFilter filter , final boolean preserveFileDate , final List < String > exclusionList )
final String [] suffixes = new String [ extensions . length ] ; for ( int i = 0 ; i < extensions . length ; i ++ ) { suffixes [ i ] = lr_22 + extensions [ i ] ; } return suffixes ; MST[NullReturnValsMutator]MSP[N] }
public static BigInteger sizeOfAsBigInteger ( final File file ) { if ( ! file . exists () ) { MST[rv.ROR1Mutator]MSP[N] final String message = file + lr_42 ; throw new IllegalArgumentException ( message ) ; } if ( file . isDirectory () ) { return sizeOfDirectoryBig0 ( file ) ; }
public static void moveDirectoryToDirectory ( final File src , final File destDir , final boolean createDestDir ) throws IOException { validateMoveParameters ( src , destDir ) ; if ( ! destDir . exists () && createDestDir ) { MST[rv.ROR4Mutator]MSP[S] destDir . mkdirs () ; }
displaySize = String . valueOf ( size . divide ( ONE_KB_BI ) ) + lr_17 ; } else { displaySize = String . valueOf ( size ) + lr_18 ; MST[NonVoidMethodCallMutator]MSP[N] } return displaySize ; } public static String byteCountToDisplaySize ( final long size ) {
validateMoveParameters ( srcFile , destDir ) ; if ( ! destDir . exists () && createDestDir ) { destDir . mkdirs () ; } if ( ! destDir . exists () ) { throw new FileNotFoundException ( lr_66 + destDir + MST[ConstructorCallMutator]MSP[S] lr_67 + createDestDir + lr_68 ) ; }
final StringBuilder buffer = new StringBuilder () ; final ByteBuffer bytes = ByteBuffer . allocate ( n ) ; for ( int i = 0 ; i < n ; ) { MST[rv.CRCR1Mutator]MSP[N] if ( url . charAt ( i ) == '%' ) { try { do {
final boolean rename = srcDir . renameTo ( destDir ) ; if ( ! rename ) { MST[rv.UOI2Mutator]MSP[N] if ( destDir . getCanonicalPath () . startsWith ( srcDir . getCanonicalPath () + File . separator ) ) { throw new IOException ( lr_61 + srcDir + lr_62 + destDir ) ;
final File [] found = directory . listFiles ( ( FileFilter ) filter ) ; if ( found != null ) { for ( final File file : found ) { MST[rv.UOI3Mutator]MSP[N] if ( file . isDirectory () ) { if ( includeSubDirectories ) {
return IOUtils . copyLarge ( fis , output ) ; MST[rv.UOI4Mutator]MSP[N] } } private static void doCopyFile ( final File srcFile , final File destFile , final boolean preserveFileDate ) throws IOException { if ( destFile . exists () && destFile . isDirectory () ) {
final boolean rename = srcDir . renameTo ( destDir ) ; if ( ! rename ) { MST[rv.ROR3Mutator]MSP[N] if ( destDir . getCanonicalPath () . startsWith ( srcDir . getCanonicalPath () + File . separator ) ) { throw new IOException ( lr_61 + srcDir + lr_62 + destDir ) ;
for ( int i = 0 ; i < urls . length ; i ++ ) { MST[rv.UOI3Mutator]MSP[N] final URL url = urls [ i ] ; if ( url != null ) { if ( url . getProtocol () . equals ( lr_24 ) == false ) {
private static void checkDirectory ( final File directory ) { if ( ! directory . exists () ) { MST[rv.ROR5Mutator]MSP[N] throw new IllegalArgumentException ( directory + lr_42 ) ; } if ( ! directory . isDirectory () ) { throw new IllegalArgumentException ( directory + lr_47 ) ; } }
if ( destDir . isDirectory () == false ) { throw new IOException ( lr_27 + destDir + lr_39 ) ; } } else { if ( ! destDir . mkdirs () && ! destDir . isDirectory () ) { MST[rv.ROR5Mutator]MSP[N]
} catch ( final InterruptedException ignore ) { wasInterrupted = true ; } catch ( final Exception ex ) { break; } } } finally { if ( wasInterrupted ) { MST[rv.UOI1Mutator]MSP[N] Thread . currentThread () . interrupt () ; } } return true ; }
validateMoveParameters ( srcFile , destDir ) ; if ( ! destDir . exists () && createDestDir ) { destDir . mkdirs () ; MST[NonVoidMethodCallMutator]MSP[N] } if ( ! destDir . exists () ) { throw new FileNotFoundException ( lr_66 + destDir + lr_67 + createDestDir + lr_68 ) ; }
public static void writeLines ( final File file , final String encoding , final Collection < ? > lines , final String lineEnding , final boolean append ) throws IOException { try ( OutputStream out = new BufferedOutputStream ( openOutputStream ( file , append ) ) ) { MST[rv.UOI2Mutator]MSP[N]
public static BigInteger sizeOfAsBigInteger ( final File file ) { if ( ! file . exists () ) { final String message = file + lr_42 ; MST[NonVoidMethodCallMutator]MSP[N] throw new IllegalArgumentException ( message ) ; } if ( file . isDirectory () ) { return sizeOfDirectoryBig0 ( file ) ; }
displaySize = String . valueOf ( size . divide ( ONE_TB_BI ) ) + lr_14 ; } else if ( size . divide ( ONE_GB_BI ) . compareTo ( BigInteger . ZERO ) > 0 ) { MST[rv.ROR2Mutator]MSP[N]
displaySize = String . valueOf ( size . divide ( ONE_KB_BI ) ) + lr_17 ; MST[NonVoidMethodCallMutator]MSP[N] } else { displaySize = String . valueOf ( size ) + lr_18 ; } return displaySize ; } public static String byteCountToDisplaySize ( final long size ) {
if ( destDir . isDirectory () == false ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] throw new IOException ( lr_27 + destDir + lr_39 ) ; } } else { if ( ! destDir . mkdirs () && ! destDir . isDirectory () ) {
if ( ! file . exists () ) { MST[NonVoidMethodCallMutator]MSP[N] final String message = file + lr_42 ; throw new IllegalArgumentException ( message ) ; } if ( file . isDirectory () ) { return sizeOfDirectory0 ( file ) ; } return file . length () ; }
final File destFile = new File ( destDir , srcFile . getName () ) ; copyFile ( srcFile , destFile , preserveFileDate ) ; MST[rv.UOI3Mutator]MSP[N] } public static void copyFile ( final File srcFile , final File destFile ) throws IOException { copyFile ( srcFile , destFile , true ) ;
final File directory , final IOFileFilter fileFilter , final IOFileFilter dirFilter , final boolean includeSubDirectories ) { validateListFilesParameters ( directory , fileFilter ) ; final IOFileFilter effFileFilter = setUpEffectiveFileFilter ( fileFilter ) ; MST[ArgumentPropagationMutator]MSP[N] final IOFileFilter effDirFilter = setUpEffectiveDirFilter ( dirFilter ) ;
final File [] found = directory . listFiles ( ( FileFilter ) filter ) ; if ( found != null ) { for ( final File file : found ) { if ( file . isDirectory () ) { if ( includeSubDirectories ) { MST[rv.UOI2Mutator]MSP[N]
final StringBuilder buffer = new StringBuilder () ; final ByteBuffer bytes = ByteBuffer . allocate ( n ) ; for ( int i = 0 ; i < n ; ) { if ( url . charAt ( i ) == '%' ) { MST[rv.ROR5Mutator]MSP[N] try { do {
throw new NullPointerException ( lr_26 ) ; } if ( ! src . exists () ) { MST[rv.ROR4Mutator]MSP[N] throw new FileNotFoundException ( lr_29 + src + lr_8 ) ; } } public static boolean isSymlink ( final File file ) { if ( file == null ) {
final File [] files = directory . listFiles () ; if ( files == null ) { return 0L ; } long size = 0 ; for ( final File file : files ) { if ( ! isSymlink ( file ) ) { MST[rv.ROR5Mutator]MSP[N]
public static boolean isFileNewer ( final File file , final File reference ) { if ( reference == null ) { throw new IllegalArgumentException ( lr_54 ) ; } if ( ! reference . exists () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] throw new IllegalArgumentException ( lr_55 + reference + lr_56 ) ; }
public static void writeByteArrayToFile ( final File file , final byte [] data ) throws IOException { writeByteArrayToFile ( file , data , false ) ; MST[rv.CRCR5Mutator]MSP[N] } public static void writeByteArrayToFile ( final File file , final byte [] data , final boolean append ) throws IOException {
final String [] suffixes = toSuffixes ( extensions ) ; filter = new SuffixFileFilter ( suffixes ) ; } return listFiles ( directory , filter , MST[rv.UOI3Mutator]MSP[N] recursive ? TrueFileFilter . INSTANCE : FalseFileFilter . INSTANCE ) ; } public static Iterator < File > iterateFiles (
} while ( i < n && url . charAt ( i ) == '%' ); MST[rv.CRCR5Mutator]MSP[S] continue; } catch ( final RuntimeException e ) { } finally { if ( bytes . position () > 0 ) { bytes . flip () ;
return false ; } return file . lastModified () > timeMillis ; MST[rv.CRCR6Mutator]MSP[N] } public static boolean isFileOlder ( final File file , final File reference ) { if ( reference == null ) { throw new IllegalArgumentException ( lr_54 ) ; }
writeByteArrayToFile ( file , data , off , len , false ) ; MST[rv.CRCR1Mutator]MSP[N] } public static void writeByteArrayToFile ( final File file , final byte [] data , final int off , final int len , final boolean append ) throws IOException {
public static File getFile ( final File directory , final String ... names ) { if ( directory == null ) { throw new NullPointerException ( lr_1 ) ; } if ( names == null ) { throw new NullPointerException ( lr_2 ) ; MST[ConstructorCallMutator]MSP[N] } File file = directory ;
FileUtils . deleteQuietly ( destFile ) ; throw new IOException ( lr_70 + srcFile + MST[NonVoidMethodCallMutator]MSP[S] lr_64 + destFile + lr_65 ) ; } } } public static void moveFileToDirectory ( final File srcFile , final File destDir , final boolean createDestDir ) throws IOException {
if ( null != exception ) { throw exception ; } } public static void forceMkdir ( final File directory ) throws IOException { if ( directory . exists () ) { if ( ! directory . isDirectory () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] final String message = lr_50 + directory + lr_51
final StringBuilder buffer = new StringBuilder () ; final ByteBuffer bytes = ByteBuffer . allocate ( n ) ; for ( int i = 0 ; i < n ; ) { if ( url . charAt ( i ) == '%' ) { MST[NonVoidMethodCallMutator]MSP[N] try { do {
for ( int i = 0 ; i < urls . length ; i ++ ) { final URL url = urls [ i ] ; if ( url != null ) { MST[rv.ROR5Mutator]MSP[N] if ( url . getProtocol () . equals ( lr_24 ) == false ) {
return new FileInputStream ( file ) ; } public static FileOutputStream openOutputStream ( final File file ) throws IOException { return openOutputStream ( file , false ) ; MST[rv.CRCR5Mutator]MSP[N] } public static FileOutputStream openOutputStream ( final File file , final boolean append ) throws IOException {
validateMoveParameters ( srcDir , destDir ) ; if ( ! srcDir . isDirectory () ) { MST[NegateConditionalsMutator]MSP[N] throw new IOException ( lr_29 + srcDir + lr_28 ) ; } if ( destDir . exists () ) { throw new FileExistsException ( lr_27 + destDir + lr_60 ) ; }
} public static void write ( final File file , final CharSequence data , final String encoding , final boolean append ) throws IOException { write ( file , data , Charsets . toCharset ( encoding ) , append ) ; MST[rv.UOI4Mutator]MSP[N] }
return new File ( filename ) ; } static String decodeUrl ( final String url ) { String decoded = url ; if ( url != null && url . indexOf ( '%' ) >= 0 ) { MST[ConditionalsBoundaryMutator]MSP[S] final int n = url . length () ;
final boolean filePresent = file . exists () ; if ( ! file . delete () ) { if ( ! filePresent ) { throw new FileNotFoundException ( lr_48 + file ) ; MST[ConstructorCallMutator]MSP[N] } final String message = lr_49 + file ; throw new IOException ( message ) ; }
public static File getUserDirectory () { return new File ( getUserDirectoryPath () ) ; MST[ReturnValsMutator]MSP[S] } public static FileInputStream openInputStream ( final File file ) throws IOException { if ( file . exists () ) { if ( file . isDirectory () ) {
if ( ! parentFile . mkdirs () && ! parentFile . isDirectory () ) { MST[rv.ROR1Mutator]MSP[N] throw new IOException ( lr_27 + parentFile + lr_32 ) ; } } if ( destFile . exists () && destFile . canWrite () == false ) {
if ( ! srcDir . isDirectory () ) { throw new IOException ( lr_29 + srcDir + lr_39 ) ; } if ( srcDir . getCanonicalPath () . equals ( destDir . getCanonicalPath () ) ) { MST[NonVoidMethodCallMutator]MSP[N]
return byteCountToDisplaySize ( BigInteger . valueOf ( size ) ) ; } public static void touch ( final File file ) throws IOException { if ( ! file . exists () ) { MST[rv.ROR1Mutator]MSP[S] openOutputStream ( file ) . close () ; }
size += sizeOf0 ( file ) ; MST[rv.AOR4Mutator]MSP[N] if ( size < 0 ) { break; } } } return size ; } private static long sizeOf0 ( final File file ) { if ( file . isDirectory () ) { return sizeOfDirectory0 ( file ) ; }
displaySize = String . valueOf ( size . divide ( ONE_GB_BI ) ) + lr_15 ; } else if ( size . divide ( ONE_MB_BI ) . compareTo ( BigInteger . ZERO ) > 0 ) { MST[NonVoidMethodCallMutator]MSP[N]
throw new NullPointerException ( lr_71 ) ; } return Files . isSymbolicLink ( file . toPath () ) ; MST[BooleanFalseReturnValsMutator]MSP[N] }
while ( ! file . exists () ) { final long remaining = finishAt - System . currentTimeMillis () ; if ( remaining < 0 ) { return false ; MST[rv.UOI3Mutator]MSP[N] } try { Thread . sleep ( Math . min ( 100 , remaining ) ) ;
throws IOException { final boolean file1Exists = file1 . exists () ; if ( file1Exists != file2 . exists () ) { MST[rv.UOI4Mutator]MSP[S] return false ; } if ( ! file1Exists ) { return true ; } if ( file1 . isDirectory () || file2 . isDirectory () ) {
throw new NullPointerException ( lr_38 ) ; } if ( src . isFile () ) { MST[NegateConditionalsMutator]MSP[N] copyFileToDirectory ( src , destDir ) ; } else if ( src . isDirectory () ) { copyDirectoryToDirectory ( src , destDir ) ; } else {
public static BigInteger sizeOfAsBigInteger ( final File file ) { if ( ! file . exists () ) { final String message = file + lr_42 ; throw new IllegalArgumentException ( message ) ; } if ( file . isDirectory () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return sizeOfDirectoryBig0 ( file ) ; }
if ( ! directory . isDirectory () ) { throw new IllegalArgumentException ( lr_46 + directory ) ; MST[experimental.NakedReceiverMutator]MSP[N] } if ( child == null ) { return false ; } if ( ! directory . exists () || ! child . exists () ) { return false ; }
for ( final File srcFile : srcFiles ) { MST[rv.UOI2Mutator]MSP[N] final File copiedFile = new File ( destDir , srcFile . getName () ) ; exclusionList . add ( copiedFile . getCanonicalPath () ) ; } } } doCopyDirectory ( srcDir , destDir , filter , preserveFileDate , exclusionList ) ;
displaySize = String . valueOf ( size . divide ( ONE_PB_BI ) ) + lr_13 ; } else if ( size . divide ( ONE_TB_BI ) . compareTo ( BigInteger . ZERO ) > 0 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N]
writeLines ( file , null , lines , lineEnding , append ) ; } public static void forceDelete ( final File file ) throws IOException { if ( file . isDirectory () ) { MST[rv.ROR2Mutator]MSP[S] deleteDirectory ( file ) ; } else {
if ( ! directory . isDirectory () ) { throw new IllegalArgumentException ( lr_46 + directory ) ; } if ( child == null ) { return false ; MST[rv.CRCR5Mutator]MSP[S] } if ( ! directory . exists () || ! child . exists () ) { return false ; }
throw new IOException ( lr_27 + destFile + lr_69 ) ; } final boolean rename = srcFile . renameTo ( destFile ) ; if ( ! rename ) { MST[rv.ROR5Mutator]MSP[N] copyFile ( srcFile , destFile ) ; if ( ! srcFile . delete () ) {
displaySize = String . valueOf ( size . divide ( ONE_EB_BI ) ) + lr_12 ; MST[experimental.NakedReceiverMutator]MSP[N] } else if ( size . divide ( ONE_PB_BI ) . compareTo ( BigInteger . ZERO ) > 0 ) {
throw new IOException ( lr_23 ) ; } if ( file1 . length () != file2 . length () ) { return false ; } if ( file1 . getCanonicalFile () . equals ( file2 . getCanonicalFile () ) ) { MST[rv.ROR1Mutator]MSP[S] return true ; }
if ( url == null || ! lr_24 . equalsIgnoreCase ( url . getProtocol () ) ) { MST[rv.ROR1Mutator]MSP[N] return null ; } String filename = url . getFile () . replace ( '/' , File . separatorChar ) ; filename = decodeUrl ( filename ) ;
} } public static void forceDeleteOnExit ( final File file ) throws IOException { if ( file . isDirectory () ) { MST[NegateConditionalsMutator]MSP[N] deleteDirectoryOnExit ( file ) ; } else { file . deleteOnExit () ; } } private static void deleteDirectoryOnExit ( final File directory ) throws IOException {
files . add ( file ) ; } innerListFiles ( files , file , filter , includeSubDirectories ) ; MST[rv.UOI1Mutator]MSP[N] } else { files . add ( file ) ; } } } } public static Collection < File > listFiles (
throw new IllegalArgumentException ( lr_58 ) ; } if ( ! file . exists () ) { return false ; MST[BooleanTrueReturnValsMutator]MSP[S] } return file . lastModified () < timeMillis ; } public static long checksumCRC32 ( final File file ) throws IOException { final CRC32 crc = new CRC32 () ;
if ( ! directory . isDirectory () ) { throw new IllegalArgumentException ( lr_46 + directory ) ; MST[NonVoidMethodCallMutator]MSP[N] } if ( child == null ) { return false ; } if ( ! directory . exists () || ! child . exists () ) { return false ; }
while ( ! file . exists () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] final long remaining = finishAt - System . currentTimeMillis () ; if ( remaining < 0 ) { return false ; } try { Thread . sleep ( Math . min ( 100 , remaining ) ) ;
throw new IOException ( lr_5 + file + lr_6 ) ; } if ( file . canRead () == false ) { throw new IOException ( lr_5 + file + lr_7 ) ; } } else { throw new FileNotFoundException ( lr_5 + file + lr_8 ) ; MST[experimental.NakedReceiverMutator]MSP[N] }
if ( files == null ) { return BigInteger . ZERO ; } BigInteger size = BigInteger . ZERO ; for ( final File file : files ) { MST[rv.ABSMutator]MSP[N] if ( ! isSymlink ( file ) ) { size = size . add ( sizeOfBig0 ( file ) ) ;
if ( ! reference . exists () ) { throw new IllegalArgumentException ( lr_55 MST[experimental.NakedReceiverMutator]MSP[N] + reference + lr_56 ) ; } return isFileOlder ( file , reference . lastModified () ) ; } public static boolean isFileOlder ( final File file , final Date date ) {
Files . copy ( srcPath , destPath , StandardCopyOption . REPLACE_EXISTING ) ; checkEqualSizes ( srcFile , destFile , Files . size ( srcPath ) , Files . size ( destPath ) ) ; MST[NonVoidMethodCallMutator]MSP[N]
throws IOException { final boolean file1Exists = file1 . exists () ; if ( file1Exists != file2 . exists () ) { return false ; } if ( ! file1Exists ) { MST[rv.UOI3Mutator]MSP[S] return true ; } if ( file1 . isDirectory () || file2 . isDirectory () ) {
writeStringToFile ( file , data , Charset . defaultCharset () , false ) ; MST[rv.CRCR1Mutator]MSP[N] } @Deprecated public static void writeStringToFile ( final File file , final String data , final boolean append ) throws IOException { writeStringToFile ( file , data , Charset . defaultCharset () , append ) ;
displaySize = String . valueOf ( size . divide ( ONE_PB_BI ) ) + lr_13 ; } else if ( size . divide ( ONE_TB_BI ) . compareTo ( BigInteger . ZERO ) > 0 ) { MST[NonVoidMethodCallMutator]MSP[N]
if ( ! srcDir . isDirectory () ) { MST[rv.ROR3Mutator]MSP[N] throw new IOException ( lr_29 + srcDir + lr_39 ) ; } if ( srcDir . getCanonicalPath () . equals ( destDir . getCanonicalPath () ) ) {
if ( ! directory . isDirectory () ) { MST[rv.ROR4Mutator]MSP[N] final String message = directory + lr_47 ; throw new IllegalArgumentException ( message ) ; } final File [] files = directory . listFiles () ; if ( files == null ) {
File file = null ; for ( final String name : names ) { if ( file == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] file = new File ( name ) ; } else { file = new File ( file , name ) ; } } return file ; }
return fileLength > 0 ? IOUtils . toByteArray ( in , fileLength ) : IOUtils . toByteArray ( in ) ; MST[rv.ROR5Mutator]MSP[N] } } public static List < String > readLines ( final File file , final Charset encoding ) throws IOException {
public static void moveToDirectory ( final File src , final File destDir , final boolean createDestDir ) throws IOException { validateMoveParameters ( src , destDir ) ; if ( src . isDirectory () ) { moveDirectoryToDirectory ( src , destDir , createDestDir ) ; MST[rv.UOI1Mutator]MSP[N] } else {
checkEqualSizes ( srcFile , destFile , srcFile . length () , destFile . length () ) ; destFile . setLastModified ( newLastModifed ) ; MST[NonVoidMethodCallMutator]MSP[S] } private static void checkEqualSizes ( final File srcFile , final File destFile , final long srcLen , final long dstLen ) throws IOException {
if ( srcLen != dstLen ) { MST[rv.ABSMutator]MSP[N] throw new IOException ( lr_34 + srcFile + lr_35 + destFile + lr_36 + srcLen + lr_37 + dstLen ) ; } } public static void copyDirectoryToDirectory ( final File srcDir , final File destDir ) throws IOException {
final boolean rename = srcDir . renameTo ( destDir ) ; if ( ! rename ) { MST[rv.UOI1Mutator]MSP[N] if ( destDir . getCanonicalPath () . startsWith ( srcDir . getCanonicalPath () + File . separator ) ) { throw new IOException ( lr_61 + srcDir + lr_62 + destDir ) ;
final File [] found = directory . listFiles ( ( FileFilter ) filter ) ; if ( found != null ) { for ( final File file : found ) { if ( file . isDirectory () ) { if ( includeSubDirectories ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
final File directory , final IOFileFilter fileFilter , final IOFileFilter dirFilter ) { return innerListFilesOrDirectories ( directory , fileFilter , dirFilter , false ) ; MST[rv.CRCR1Mutator]MSP[N] } private static void validateListFilesParameters ( final File directory , final IOFileFilter fileFilter ) { if ( ! directory . isDirectory () ) {
size += sizeOf0 ( file ) ; if ( size < 0 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] break; } } } return size ; } private static long sizeOf0 ( final File file ) { if ( file . isDirectory () ) { return sizeOfDirectory0 ( file ) ; }
while ( ! file . exists () ) { final long remaining = finishAt - System . currentTimeMillis () ; if ( remaining < 0 ) { MST[rv.UOI4Mutator]MSP[N] return false ; } try { Thread . sleep ( Math . min ( 100 , remaining ) ) ;
return new File ( filename ) ; } static String decodeUrl ( final String url ) { String decoded = url ; if ( url != null && url . indexOf ( '%' ) >= 0 ) { MST[rv.CRCR5Mutator]MSP[N] final int n = url . length () ;
private static void checkDirectory ( final File directory ) { if ( ! directory . exists () ) { throw new IllegalArgumentException ( directory + lr_42 ) ; MST[ConstructorCallMutator]MSP[N] } if ( ! directory . isDirectory () ) { throw new IllegalArgumentException ( directory + lr_47 ) ; } }
moveDirectory ( src , new File ( destDir , src . getName () ) ) ; } public static void moveFile ( final File srcFile , final File destFile ) throws IOException { validateMoveParameters ( srcFile , destFile ) ; if ( srcFile . isDirectory () ) { MST[NegateConditionalsMutator]MSP[N]
} catch ( final Exception ignored ) { return false ; MST[rv.CRCR6Mutator]MSP[S] } } public static boolean directoryContains ( final File directory , final File child ) throws IOException { if ( directory == null ) { throw new IllegalArgumentException ( lr_45 ) ; }
final File directory , final IOFileFilter fileFilter , final IOFileFilter dirFilter ) { return innerListFilesOrDirectories ( directory , fileFilter , dirFilter , false ) ; } private static void validateListFilesParameters ( final File directory , final IOFileFilter fileFilter ) { if ( ! directory . isDirectory () ) { MST[rv.ROR5Mutator]MSP[N]
} public static File [] toFiles ( final URL [] urls ) { if ( urls == null || urls . length == 0 ) { return EMPTY_FILE_ARRAY ; MST[NullReturnValsMutator]MSP[N] } final File [] files = new File [ urls . length ] ;
if ( file . exists () ) { if ( file . isDirectory () ) { throw new IOException ( lr_5 + file + lr_6 ) ; } if ( file . canWrite () == false ) { MST[NonVoidMethodCallMutator]MSP[N] throw new IOException ( lr_5 + file + lr_9 ) ; }
if ( ! parentFile . mkdirs () && ! parentFile . isDirectory () ) { throw new IOException ( lr_27 + parentFile + lr_32 ) ; } } if ( destFile . exists () && destFile . canWrite () == false ) { MST[rv.ROR2Mutator]MSP[N]
throws IOException { final boolean file1Exists = file1 . exists () ; if ( file1Exists != file2 . exists () ) { return false ; } if ( ! file1Exists ) { MST[rv.ROR4Mutator]MSP[S] return true ; } if ( file1 . isDirectory () || file2 . isDirectory () ) {
if ( ! destDir . isDirectory () ) { MST[rv.ROR2Mutator]MSP[N] throw new IOException ( lr_27 + destDir + lr_28 ) ; } moveFile ( srcFile , new File ( destDir , srcFile . getName () ) ) ; }
return fileLength > 0 ? IOUtils . toByteArray ( in , fileLength ) : IOUtils . toByteArray ( in ) ; MST[NegateConditionalsMutator]MSP[N] } } public static List < String > readLines ( final File file , final Charset encoding ) throws IOException {
try ( OutputStream out = openOutputStream ( file , append ) ) { out . write ( data , off , len ) ; MST[rv.UOI1Mutator]MSP[N] } } public static void writeLines ( final File file , final String encoding , final Collection < ? > lines ) throws IOException {
final Collection < File > files = new java . util . LinkedList <> () ; if ( includeSubDirectories ) { files . add ( directory ) ; } innerListFiles ( files , directory , MST[rv.CRCR3Mutator]MSP[N] FileFilterUtils . or ( effFileFilter , effDirFilter ) , includeSubDirectories ) ; return files ;
? new InputStreamReader ( new FileInputStream ( file1 ) , Charset . defaultCharset () ) : new InputStreamReader ( new FileInputStream ( file1 ) , charsetName ) ; Reader input2 = charsetName == null ? new InputStreamReader ( new FileInputStream ( file2 ) , Charset . defaultCharset () ) MST[ConstructorCallMutator]MSP[S]
writeByteArrayToFile ( file , data , off , len , false ) ; MST[rv.UOI4Mutator]MSP[S] } public static void writeByteArrayToFile ( final File file , final byte [] data , final int off , final int len , final boolean append ) throws IOException {
final Collection < File > files = new java . util . LinkedList <> () ; if ( includeSubDirectories ) { files . add ( directory ) ; } innerListFiles ( files , directory , MST[rv.CRCR6Mutator]MSP[N] FileFilterUtils . or ( effFileFilter , effDirFilter ) , includeSubDirectories ) ; return files ;
return byteCountToDisplaySize ( BigInteger . valueOf ( size ) ) ; MST[rv.UOI3Mutator]MSP[N] } public static void touch ( final File file ) throws IOException { if ( ! file . exists () ) { openOutputStream ( file ) . close () ; }
throw new IOException ( lr_5 + file + lr_6 ) ; } if ( file . canRead () == false ) { throw new IOException ( lr_5 + file + lr_7 ) ; } } else { throw new FileNotFoundException ( lr_5 + file + lr_8 ) ; MST[NonVoidMethodCallMutator]MSP[N] }
final String [] suffixes = toSuffixes ( extensions ) ; filter = new SuffixFileFilter ( suffixes ) ; } return listFiles ( directory , filter , MST[rv.ROR1Mutator]MSP[N] recursive ? TrueFileFilter . INSTANCE : FalseFileFilter . INSTANCE ) ; } public static Iterator < File > iterateFiles (
if ( ! destDir . exists () ) { throw new FileNotFoundException ( lr_66 + destDir + lr_67 + createDestDir + lr_68 ) ; } if ( ! destDir . isDirectory () ) { throw new IOException ( lr_27 + destDir + lr_28 ) ; MST[ConstructorCallMutator]MSP[S] }
moveDirectory ( src , new File ( destDir , src . getName () ) ) ; } public static void moveFile ( final File srcFile , final File destFile ) throws IOException { validateMoveParameters ( srcFile , destFile ) ; if ( srcFile . isDirectory () ) { MST[rv.ROR5Mutator]MSP[N]
throws IOException { final boolean file1Exists = file1 . exists () ; if ( file1Exists != file2 . exists () ) { return false ; } if ( ! file1Exists ) { return true ; } if ( file1 . isDirectory () || file2 . isDirectory () ) { MST[rv.ROR3Mutator]MSP[N]
} catch ( final Exception ignored ) { return false ; } } public static boolean directoryContains ( final File directory , final File child ) throws IOException { if ( directory == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] throw new IllegalArgumentException ( lr_45 ) ; }
final File [] found = directory . listFiles ( ( FileFilter ) filter ) ; if ( found != null ) { for ( final File file : found ) { MST[rv.UOI2Mutator]MSP[N] if ( file . isDirectory () ) { if ( includeSubDirectories ) {
copyDirectory ( srcDir , new File ( destDir , srcDir . getName () ) , true ) ; MST[rv.CRCR6Mutator]MSP[N] } public static void copyDirectory ( final File srcDir , final File destDir ) throws IOException { copyDirectory ( srcDir , destDir , true ) ; }
final File directory , final String [] extensions , final boolean recursive ) { return listFiles ( directory , extensions , recursive ) . iterator () ; MST[rv.ABSMutator]MSP[N] } public static boolean contentEquals ( final File file1 , final File file2 ) throws IOException {
if ( ! destDir . exists () ) { MST[NonVoidMethodCallMutator]MSP[N] throw new FileNotFoundException ( lr_66 + destDir + lr_67 + createDestDir + lr_68 ) ; } if ( ! destDir . isDirectory () ) { throw new IOException ( lr_27 + destDir + lr_28 ) ; }
cleanDirectory ( directory ) ; } if ( ! directory . delete () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] final String message = lr_44 + directory + lr_22 ; throw new IOException ( message ) ; } } public static boolean deleteQuietly ( final File file ) {
final File directory , final IOFileFilter fileFilter , final IOFileFilter dirFilter ) { return innerListFilesOrDirectories ( directory , fileFilter , dirFilter , false ) ; } private static void validateListFilesParameters ( final File directory , final IOFileFilter fileFilter ) { if ( ! directory . isDirectory () ) { MST[NegateConditionalsMutator]MSP[N]
final File directory , final String [] extensions , final boolean recursive ) { return listFiles ( directory , extensions , recursive ) . iterator () ; MST[rv.UOI2Mutator]MSP[N] } public static boolean contentEquals ( final File file1 , final File file2 ) throws IOException {
displaySize = String . valueOf ( size . divide ( ONE_GB_BI ) ) + lr_15 ; MST[experimental.BigIntegerMutator]MSP[N] } else if ( size . divide ( ONE_MB_BI ) . compareTo ( BigInteger . ZERO ) > 0 ) {
writeLines ( file , encoding , lines , null , append ) ; MST[rv.UOI3Mutator]MSP[S] } public static void writeLines ( final File file , final Collection < ? > lines ) throws IOException { writeLines ( file , null , lines , null , false ) ; }
throw new IOException ( lr_40 + directory ) ; } return files ; } public static boolean waitFor ( final File file , final int seconds ) { final long finishAt = System . currentTimeMillis () + ( seconds * 1000L ) ; MST[InlineConstantMutator]MSP[N] boolean wasInterrupted = false ; try {
final Collection < File > files = new java . util . LinkedList <> () ; if ( includeSubDirectories ) { MST[rv.ROR4Mutator]MSP[N] files . add ( directory ) ; } innerListFiles ( files , directory , FileFilterUtils . or ( effFileFilter , effDirFilter ) , includeSubDirectories ) ; return files ;
final Collection < File > files = new java . util . LinkedList <> () ; if ( includeSubDirectories ) { files . add ( directory ) ; } innerListFiles ( files , directory , MST[rv.CRCR2Mutator]MSP[N] FileFilterUtils . or ( effFileFilter , effDirFilter ) , includeSubDirectories ) ; return files ;
public static void write ( final File file , final CharSequence data , final Charset encoding ) throws IOException { write ( file , data , encoding , false ) ; MST[rv.CRCR1Mutator]MSP[N] }
if ( null != exception ) { throw exception ; } } public static void forceMkdir ( final File directory ) throws IOException { if ( directory . exists () ) { if ( ! directory . isDirectory () ) { final String message = MST[experimental.NakedReceiverMutator]MSP[N] lr_50 + directory + lr_51
} public static void forceMkdirParent ( final File file ) throws IOException { final File parent = file . getParentFile () ; MST[NonVoidMethodCallMutator]MSP[S] if ( parent == null ) { return; } forceMkdir ( parent ) ; } public static long sizeOf ( final File file ) {
validateMoveParameters ( srcFile , destDir ) ; if ( ! destDir . exists () && createDestDir ) { destDir . mkdirs () ; } if ( ! destDir . exists () ) { throw new FileNotFoundException ( lr_66 + destDir + MST[rv.UOI3Mutator]MSP[N] lr_67 + createDestDir + lr_68 ) ; }
public static void moveToDirectory ( final File src , final File destDir , final boolean createDestDir ) throws IOException { validateMoveParameters ( src , destDir ) ; if ( src . isDirectory () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] moveDirectoryToDirectory ( src , destDir , createDestDir ) ; } else {
writeLines ( file , encoding , lines , null , append ) ; } public static void writeLines ( final File file , final Collection < ? > lines ) throws IOException { writeLines ( file , null , lines , null , false ) ; MST[InlineConstantMutator]MSP[N] }
if ( ! reference . exists () ) { MST[NegateConditionalsMutator]MSP[S] throw new IllegalArgumentException ( lr_55 + reference + lr_56 ) ; } return isFileOlder ( file , reference . lastModified () ) ; } public static boolean isFileOlder ( final File file , final Date date ) {
final File [] found = directory . listFiles ( ( FileFilter ) filter ) ; if ( found != null ) { for ( final File file : found ) { MST[rv.ABSMutator]MSP[N] if ( file . isDirectory () ) { if ( includeSubDirectories ) {
return false ; } return file . lastModified () > timeMillis ; MST[rv.CRCR6Mutator]MSP[N] } public static boolean isFileOlder ( final File file , final File reference ) { if ( reference == null ) { throw new IllegalArgumentException ( lr_54 ) ; }
final boolean rename = srcDir . renameTo ( destDir ) ; if ( ! rename ) { MST[rv.ROR2Mutator]MSP[N] if ( destDir . getCanonicalPath () . startsWith ( srcDir . getCanonicalPath () + File . separator ) ) { throw new IOException ( lr_61 + srcDir + lr_62 + destDir ) ;
return new FileOutputStream ( file , append ) ; MST[ReturnValsMutator]MSP[N] } public static String byteCountToDisplaySize ( final BigInteger size ) { String displaySize ; if ( size . divide ( ONE_EB_BI ) . compareTo ( BigInteger . ZERO ) > 0 ) {
while ( ! file . exists () ) { final long remaining = finishAt - System . currentTimeMillis () ; MST[rv.UOI2Mutator]MSP[N] if ( remaining < 0 ) { return false ; } try { Thread . sleep ( Math . min ( 100 , remaining ) ) ;
final URL [] urls = new URL [ files . length ] ; for ( int i = 0 ; i < urls . length ; i ++ ) { MST[InlineConstantMutator]MSP[S] urls [ i ] = files [ i ] . toURI () . toURL () ; } return urls ;
buffer . append ( StandardCharsets . UTF_8 . decode ( bytes ) . toString () ) ; MST[NonVoidMethodCallMutator]MSP[S] bytes . clear () ; } } } buffer . append ( url . charAt ( i ++ ) ) ; } decoded = buffer . toString () ; } return decoded ;
if ( srcLen != dstLen ) { throw new IOException ( lr_34 + srcFile + lr_35 + destFile MST[NonVoidMethodCallMutator]MSP[S] + lr_36 + srcLen + lr_37 + dstLen ) ; } } public static void copyDirectoryToDirectory ( final File srcDir , final File destDir ) throws IOException {
if ( ! directory . isDirectory () ) { throw new IllegalArgumentException ( lr_46 + directory ) ; } if ( child == null ) { return false ; } if ( ! directory . exists () || ! child . exists () ) { MST[rv.ROR5Mutator]MSP[N] return false ; }
try ( InputStream in = openInputStream ( file ) ) { MST[NonVoidMethodCallMutator]MSP[S] return IOUtils . readLines ( in , Charsets . toCharset ( encoding ) ) ; } } public static List < String > readLines ( final File file , final String encoding ) throws IOException {
} private static void checkFileRequirements ( final File src , final File dest ) throws FileNotFoundException { if ( src == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] throw new NullPointerException ( lr_38 ) ; } if ( dest == null ) { throw new NullPointerException ( lr_26 ) ; }
if ( ! file . exists () ) { final String message = file + lr_42 ; MST[NonVoidMethodCallMutator]MSP[N] throw new IllegalArgumentException ( message ) ; } if ( file . isDirectory () ) { return sizeOfDirectory0 ( file ) ; } return file . length () ; }
checksum ( file , crc ) ; return crc . getValue () ; } public static Checksum checksum ( final File file , final Checksum checksum ) throws IOException { if ( file . isDirectory () ) { MST[rv.ROR5Mutator]MSP[N] throw new IllegalArgumentException ( lr_59 ) ; }
} public static Iterator < File > iterateFiles ( final File directory , final IOFileFilter fileFilter , final IOFileFilter dirFilter ) { return listFiles ( directory , fileFilter , dirFilter ) . iterator () ; MST[ReturnValsMutator]MSP[S] }
public static File getUserDirectory () { return new File ( getUserDirectoryPath () ) ; MST[ConstructorCallMutator]MSP[S] } public static FileInputStream openInputStream ( final File file ) throws IOException { if ( file . exists () ) { if ( file . isDirectory () ) {
if ( file . exists () ) { if ( file . isDirectory () ) { throw new IOException ( lr_5 + file + lr_6 ) ; } if ( file . canWrite () == false ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] throw new IOException ( lr_5 + file + lr_9 ) ; }
validateMoveParameters ( srcFile , destDir ) ; if ( ! destDir . exists () && createDestDir ) { destDir . mkdirs () ; } if ( ! destDir . exists () ) { throw new FileNotFoundException ( lr_66 + destDir + MST[NonVoidMethodCallMutator]MSP[S] lr_67 + createDestDir + lr_68 ) ; }
if ( files == null ) { return BigInteger . ZERO ; } BigInteger size = BigInteger . ZERO ; for ( final File file : files ) { MST[rv.UOI2Mutator]MSP[S] if ( ! isSymlink ( file ) ) { size = size . add ( sizeOfBig0 ( file ) ) ;
return IOUtils . copyLarge ( fis , output ) ; MST[rv.UOI2Mutator]MSP[N] } } private static void doCopyFile ( final File srcFile , final File destFile , final boolean preserveFileDate ) throws IOException { if ( destFile . exists () && destFile . isDirectory () ) {
} while ( i < n && url . charAt ( i ) == '%' ); MST[rv.CRCR6Mutator]MSP[S] continue; } catch ( final RuntimeException e ) { } finally { if ( bytes . position () > 0 ) { bytes . flip () ;
} public static void write ( final File file , final CharSequence data , final String encoding , final boolean append ) throws IOException { write ( file , data , Charsets . toCharset ( encoding ) , append ) ; MST[rv.UOI3Mutator]MSP[S] }
validateMoveParameters ( srcDir , destDir ) ; if ( ! srcDir . isDirectory () ) { throw new IOException ( lr_29 + srcDir + lr_28 ) ; } if ( destDir . exists () ) { throw new FileExistsException ( lr_27 + destDir + lr_60 ) ; MST[experimental.NakedReceiverMutator]MSP[N] }
displaySize = String . valueOf ( size . divide ( ONE_MB_BI ) ) + lr_16 ; } else if ( size . divide ( ONE_KB_BI ) . compareTo ( BigInteger . ZERO ) > 0 ) { MST[rv.ROR1Mutator]MSP[N]
if ( destDir == null ) { throw new NullPointerException ( lr_26 ) ; } if ( destDir . exists () && destDir . isDirectory () == false ) { MST[rv.ROR1Mutator]MSP[N] throw new IllegalArgumentException ( lr_27 + destDir + lr_28 ) ; }
throw new IOException ( lr_29 + srcDir + lr_30 + destDir + lr_31 ) ; MST[experimental.NakedReceiverMutator]MSP[N] } List < String > exclusionList = null ; if ( destDir . getCanonicalPath () . startsWith ( srcDir . getCanonicalPath () ) ) {
validateMoveParameters ( srcFile , destDir ) ; if ( ! destDir . exists () && createDestDir ) { MST[rv.UOI3Mutator]MSP[S] destDir . mkdirs () ; } if ( ! destDir . exists () ) { throw new FileNotFoundException ( lr_66 + destDir + lr_67 + createDestDir + lr_68 ) ; }
final boolean filePresent = file . exists () ; if ( ! file . delete () ) { if ( ! filePresent ) { MST[rv.ROR1Mutator]MSP[S] throw new FileNotFoundException ( lr_48 + file ) ; } final String message = lr_49 + file ; throw new IOException ( message ) ; }
throw new IOException ( lr_29 + srcFile + lr_69 ) ; } if ( destFile . exists () ) { MST[rv.ROR1Mutator]MSP[N] throw new FileExistsException ( lr_27 + destFile + lr_60 ) ; } if ( destFile . isDirectory () ) {
throw new IOException ( lr_29 + srcFile + lr_69 ) ; } if ( destFile . exists () ) { throw new FileExistsException ( lr_27 + destFile + lr_60 ) ; MST[NonVoidMethodCallMutator]MSP[S] } if ( destFile . isDirectory () ) {
if ( srcDir == null ) { throw new NullPointerException ( lr_38 ) ; } if ( srcDir . exists () && srcDir . isDirectory () == false ) { MST[rv.ROR2Mutator]MSP[N] throw new IllegalArgumentException ( lr_29 + destDir + lr_28 ) ; } if ( destDir == null ) {
if ( null != exception ) { throw exception ; } } private static File [] verifiedListFiles ( final File directory ) throws IOException { if ( ! directory . exists () ) { MST[rv.ROR3Mutator]MSP[N] final String message = directory + lr_42 ; throw new IllegalArgumentException ( message ) ; }
return fileLength > 0 ? IOUtils . toByteArray ( in , fileLength ) : IOUtils . toByteArray ( in ) ; MST[ConditionalsBoundaryMutator]MSP[N] } } public static List < String > readLines ( final File file , final Charset encoding ) throws IOException {
return BigInteger . valueOf ( file . length () ) ; } public static long sizeOfDirectory ( final File directory ) { checkDirectory ( directory ) ; return sizeOfDirectory0 ( directory ) ; MST[PrimitiveReturnsMutator]MSP[N] } private static long sizeOfDirectory0 ( final File directory ) {
try ( OutputStream out = openOutputStream ( file , append ) ) { out . write ( data , off , len ) ; MST[rv.UOI2Mutator]MSP[N] } } public static void writeLines ( final File file , final String encoding , final Collection < ? > lines ) throws IOException {
final boolean filePresent = file . exists () ; if ( ! file . delete () ) { if ( ! filePresent ) { throw new FileNotFoundException ( lr_48 + file ) ; MST[NonVoidMethodCallMutator]MSP[N] } final String message = lr_49 + file ; throw new IOException ( message ) ; }
final File [] files = directory . listFiles () ; if ( files == null ) { return 0L ; } long size = 0 ; for ( final File file : files ) { MST[rv.UOI3Mutator]MSP[N] if ( ! isSymlink ( file ) ) {
if ( ! destDir . exists () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] throw new FileNotFoundException ( lr_66 + destDir + lr_67 + createDestDir + lr_68 ) ; } if ( ! destDir . isDirectory () ) { throw new IOException ( lr_27 + destDir + lr_28 ) ; }
return false ; } return file . lastModified () > timeMillis ; MST[ReturnValsMutator]MSP[N] } public static boolean isFileOlder ( final File file , final File reference ) { if ( reference == null ) { throw new IllegalArgumentException ( lr_54 ) ; }
throw new IOException ( lr_29 + srcDir + lr_30 + destDir + lr_31 ) ; } List < String > exclusionList = null ; if ( destDir . getCanonicalPath () . startsWith ( srcDir . getCanonicalPath () ) ) { MST[rv.ROR4Mutator]MSP[S]
throw new IOException ( lr_40 + directory ) ; } return files ; } public static boolean waitFor ( final File file , final int seconds ) { final long finishAt = System . currentTimeMillis () + ( seconds * 1000L ) ; MST[rv.CRCR4Mutator]MSP[N] boolean wasInterrupted = false ; try {
if ( ! directory . exists () ) { MST[rv.ROR1Mutator]MSP[N] return; } directory . deleteOnExit () ; if ( ! isSymlink ( directory ) ) { cleanDirectoryOnExit ( directory ) ; } } private static void cleanDirectoryOnExit ( final File directory ) throws IOException {
File file = null ; for ( final String name : names ) { if ( file == null ) { file = new File ( name ) ; } else { file = new File ( file , name ) ; MST[ConstructorCallMutator]MSP[S] } } return file ; }
if ( srcFile . getCanonicalPath () . equals ( destFile . getCanonicalPath () ) ) { MST[rv.ROR2Mutator]MSP[N] throw new IOException ( lr_29 + srcFile + lr_30 + destFile + lr_31 ) ; } final File parentFile = destFile . getParentFile () ; if ( parentFile != null ) {
return fileLength > 0 ? IOUtils . toByteArray ( in , fileLength ) : IOUtils . toByteArray ( in ) ; MST[NullReturnValsMutator]MSP[N] } } public static List < String > readLines ( final File file , final Charset encoding ) throws IOException {
final File [] files = directory . listFiles () ; if ( files == null ) { return 0L ; } long size = 0 ; MST[rv.CRCR5Mutator]MSP[N] for ( final File file : files ) { if ( ! isSymlink ( file ) ) {
if ( url == null || ! lr_24 . equalsIgnoreCase ( url . getProtocol () ) ) { MST[NegateConditionalsMutator]MSP[N] return null ; } String filename = url . getFile () . replace ( '/' , File . separatorChar ) ; filename = decodeUrl ( filename ) ;
size += sizeOf0 ( file ) ; if ( size < 0 ) { MST[rv.UOI3Mutator]MSP[N] break; } } } return size ; } private static long sizeOf0 ( final File file ) { if ( file . isDirectory () ) { return sizeOfDirectory0 ( file ) ; }
displaySize = String . valueOf ( size . divide ( ONE_PB_BI ) ) + lr_13 ; } else if ( size . divide ( ONE_TB_BI ) . compareTo ( BigInteger . ZERO ) > 0 ) { MST[ArgumentPropagationMutator]MSP[N]
if ( ! src . exists () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] throw new FileNotFoundException ( lr_29 + src + lr_8 ) ; } } private static void doCopyDirectory ( final File srcDir , final File destDir , final FileFilter filter , final boolean preserveFileDate , final List < String > exclusionList )
public static void write ( final File file , final CharSequence data , final Charset encoding ) throws IOException { write ( file , data , encoding , false ) ; MST[VoidMethodCallMutator]MSP[N] }
throw new IOException ( lr_40 + directory ) ; } return files ; } public static boolean waitFor ( final File file , final int seconds ) { final long finishAt = System . currentTimeMillis () + ( seconds * 1000L ) ; MST[rv.UOI3Mutator]MSP[N] boolean wasInterrupted = false ; try {
} else { final File parent = file . getParentFile () ; if ( parent != null ) { if ( ! parent . mkdirs () && ! parent . isDirectory () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] throw new IOException ( lr_10 + parent + lr_11 ) ; } } }
for ( int i = 0 ; i < urls . length ; i ++ ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] final URL url = urls [ i ] ; if ( url != null ) { if ( url . getProtocol () . equals ( lr_24 ) == false ) {
if ( file == null ) { return false ; } try { if ( file . isDirectory () ) { cleanDirectory ( file ) ; } } catch ( final Exception ignored ) { } try { return file . delete () ; MST[BooleanTrueReturnValsMutator]MSP[S]
public static Collection < File > listFilesAndDirs ( final File directory , final IOFileFilter fileFilter , final IOFileFilter dirFilter ) { return innerListFilesOrDirectories ( directory , fileFilter , dirFilter , true ) ; MST[rv.CRCR2Mutator]MSP[N] } private static Collection < File > innerListFilesOrDirectories (
final URL [] urls = new URL [ files . length ] ; for ( int i = 0 ; i < urls . length ; i ++ ) { MST[rv.ROR4Mutator]MSP[N] urls [ i ] = files [ i ] . toURI () . toURL () ; } return urls ;
final StringBuilder buffer = new StringBuilder () ; final ByteBuffer bytes = ByteBuffer . allocate ( n ) ; for ( int i = 0 ; i < n ; ) { if ( url . charAt ( i ) == '%' ) { MST[rv.CRCR6Mutator]MSP[N] try { do {
throw new IOException ( lr_29 + srcFile + lr_69 ) ; MST[NonVoidMethodCallMutator]MSP[N] } if ( destFile . exists () ) { throw new FileExistsException ( lr_27 + destFile + lr_60 ) ; } if ( destFile . isDirectory () ) {
throw new NullPointerException ( lr_26 ) ; } if ( destDir . exists () && destDir . isDirectory () == false ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] throw new IllegalArgumentException ( lr_27 + destDir + lr_28 ) ; }
throws IOException { final File [] srcFiles = filter == null ? srcDir . listFiles () : srcDir . listFiles ( filter ) ; if ( srcFiles == null ) { throw new IOException ( lr_40 + srcDir ) ; } if ( destDir . exists () ) { MST[rv.ROR4Mutator]MSP[N]
final File destFile = new File ( destDir , srcFile . getName () ) ; copyFile ( srcFile , destFile , preserveFileDate ) ; } public static void copyFile ( final File srcFile , final File destFile ) throws IOException { copyFile ( srcFile , destFile , true ) ; MST[rv.CRCR3Mutator]MSP[N]
while ( ! file . exists () ) { MST[NonVoidMethodCallMutator]MSP[N] final long remaining = finishAt - System . currentTimeMillis () ; if ( remaining < 0 ) { return false ; } try { Thread . sleep ( Math . min ( 100 , remaining ) ) ;
while ( ! file . exists () ) { final long remaining = finishAt - System . currentTimeMillis () ; MST[rv.ABSMutator]MSP[N] if ( remaining < 0 ) { return false ; } try { Thread . sleep ( Math . min ( 100 , remaining ) ) ;
throw new IOException ( lr_23 ) ; } if ( file1 . getCanonicalFile () . equals ( file2 . getCanonicalFile () ) ) { return true ; } try ( Reader input1 = charsetName == null MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
public static Collection < File > listFilesAndDirs ( final File directory , final IOFileFilter fileFilter , final IOFileFilter dirFilter ) { return innerListFilesOrDirectories ( directory , fileFilter , dirFilter , true ) ; MST[NonVoidMethodCallMutator]MSP[N] } private static Collection < File > innerListFilesOrDirectories (
displaySize = String . valueOf ( size . divide ( ONE_MB_BI ) ) + lr_16 ; MST[NonVoidMethodCallMutator]MSP[N] } else if ( size . divide ( ONE_KB_BI ) . compareTo ( BigInteger . ZERO ) > 0 ) {
throw new IOException ( lr_27 + destFile + lr_69 ) ; } final boolean rename = srcFile . renameTo ( destFile ) ; if ( ! rename ) { MST[rv.ROR3Mutator]MSP[N] copyFile ( srcFile , destFile ) ; if ( ! srcFile . delete () ) {
} catch ( final InterruptedException ignore ) { wasInterrupted = true ; } catch ( final Exception ex ) { break; } } } finally { if ( wasInterrupted ) { MST[rv.ROR2Mutator]MSP[N] Thread . currentThread () . interrupt () ; } } return true ; }
final byte octet = ( byte ) Integer . parseInt ( url . substring ( i + 1 , i + 3 ) , 16 ) ; bytes . put ( octet ) ; MST[rv.UOI1Mutator]MSP[N] i += 3 ;
public static String readFileToString ( final File file , final String encoding ) throws IOException { return readFileToString ( file , Charsets . toCharset ( encoding ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } @Deprecated public static String readFileToString ( final File file ) throws IOException {
writeStringToFile ( file , data , Charset . defaultCharset () , false ) ; } @Deprecated public static void writeStringToFile ( final File file , final String data , final boolean append ) throws IOException { writeStringToFile ( file , data , Charset . defaultCharset () , append ) ; MST[rv.UOI4Mutator]MSP[N]
return false ; } return file . lastModified () > timeMillis ; MST[rv.CRCR3Mutator]MSP[N] } public static boolean isFileOlder ( final File file , final File reference ) { if ( reference == null ) { throw new IllegalArgumentException ( lr_54 ) ; }
public static void writeLines ( final File file , final Collection < ? > lines , final boolean append ) throws IOException { writeLines ( file , null , lines , null , append ) ; MST[rv.ABSMutator]MSP[N] }
final boolean filePresent = file . exists () ; if ( ! file . delete () ) { MST[rv.ROR4Mutator]MSP[N] if ( ! filePresent ) { throw new FileNotFoundException ( lr_48 + file ) ; } final String message = lr_49 + file ; throw new IOException ( message ) ; }
displaySize = String . valueOf ( size . divide ( ONE_EB_BI ) ) + lr_12 ; } else if ( size . divide ( ONE_PB_BI ) . compareTo ( BigInteger . ZERO ) > 0 ) { MST[experimental.NakedReceiverMutator]MSP[N]
if ( destDir == null ) { throw new NullPointerException ( lr_26 ) ; } if ( destDir . exists () && destDir . isDirectory () == false ) { MST[NegateConditionalsMutator]MSP[N] throw new IllegalArgumentException ( lr_27 + destDir + lr_28 ) ; }
final String [] suffixes = toSuffixes ( extensions ) ; filter = new SuffixFileFilter ( suffixes ) ; } return listFiles ( directory , filter , MST[ReturnValsMutator]MSP[N] recursive ? TrueFileFilter . INSTANCE : FalseFileFilter . INSTANCE ) ; } public static Iterator < File > iterateFiles (
throw new NullPointerException ( lr_26 ) ; } if ( destDir . exists () && destDir . isDirectory () == false ) { MST[NonVoidMethodCallMutator]MSP[N] throw new IllegalArgumentException ( lr_27 + destDir + lr_28 ) ; }
final boolean rename = srcDir . renameTo ( destDir ) ; if ( ! rename ) { if ( destDir . getCanonicalPath () . startsWith ( srcDir . getCanonicalPath () + File . separator ) ) { MST[NonVoidMethodCallMutator]MSP[N] throw new IOException ( lr_61 + srcDir + lr_62 + destDir ) ;
throw new IllegalArgumentException ( MST[experimental.NakedReceiverMutator]MSP[N] lr_25 + url ) ; } files [ i ] = toFile ( url ) ; } } return files ; } public static URL [] toURLs ( final File [] files ) throws IOException {
return new File ( filename ) ; } static String decodeUrl ( final String url ) { String decoded = url ; if ( url != null && url . indexOf ( '%' ) >= 0 ) { MST[rv.ROR3Mutator]MSP[N] final int n = url . length () ;
throw new IOException ( lr_29 + srcFile + lr_69 ) ; } if ( destFile . exists () ) { throw new FileExistsException ( lr_27 + destFile + lr_60 ) ; } if ( destFile . isDirectory () ) { MST[rv.ROR4Mutator]MSP[N]
} while ( i < n && url . charAt ( i ) == '%' ); MST[rv.ROR2Mutator]MSP[S] continue; } catch ( final RuntimeException e ) { } finally { if ( bytes . position () > 0 ) { bytes . flip () ;
try ( OutputStream out = openOutputStream ( file , append ) ) { MST[rv.UOI3Mutator]MSP[N] out . write ( data , off , len ) ; } } public static void writeLines ( final File file , final String encoding , final Collection < ? > lines ) throws IOException {
throw new IOException ( lr_41 + src + lr_42 ) ; MST[ConstructorCallMutator]MSP[S] } } public static void copyToDirectory ( final Iterable < File > srcs , final File destDir ) throws IOException { if ( srcs == null ) { throw new NullPointerException ( lr_43 ) ; }
throw new IOException ( lr_27 + destFile + lr_69 ) ; } final boolean rename = srcFile . renameTo ( destFile ) ; if ( ! rename ) { copyFile ( srcFile , destFile ) ; MST[VoidMethodCallMutator]MSP[S] if ( ! srcFile . delete () ) {
checksum ( file , crc ) ; return crc . getValue () ; } public static Checksum checksum ( final File file , final Checksum checksum ) throws IOException { if ( file . isDirectory () ) { MST[NegateConditionalsMutator]MSP[N] throw new IllegalArgumentException ( lr_59 ) ; }
} public static void copyFileToDirectory ( final File srcFile , final File destDir ) throws IOException { copyFileToDirectory ( srcFile , destDir , true ) ; MST[VoidMethodCallMutator]MSP[N] } public static void copyFileToDirectory ( final File srcFile , final File destDir , final boolean preserveFileDate ) throws IOException {
throw new IllegalArgumentException ( lr_58 ) ; } if ( ! file . exists () ) { return false ; } return file . lastModified () < timeMillis ; MST[rv.UOI4Mutator]MSP[N] } public static long checksumCRC32 ( final File file ) throws IOException { final CRC32 crc = new CRC32 () ;
final byte octet = ( byte ) Integer . parseInt ( url . substring ( i + 1 , i + 3 ) , 16 ) ; MST[rv.UOI3Mutator]MSP[N] bytes . put ( octet ) ; i += 3 ;
throw new IOException ( lr_40 + directory ) ; } return files ; } public static boolean waitFor ( final File file , final int seconds ) { final long finishAt = System . currentTimeMillis () + ( seconds * 1000L ) ; boolean wasInterrupted = false ; MST[rv.CRCR6Mutator]MSP[N] try {
final StringBuilder buffer = new StringBuilder () ; final ByteBuffer bytes = ByteBuffer . allocate ( n ) ; for ( int i = 0 ; i < n ; ) { MST[rv.ABSMutator]MSP[N] if ( url . charAt ( i ) == '%' ) { try { do {
} else { final File parent = file . getParentFile () ; if ( parent != null ) { if ( ! parent . mkdirs () && ! parent . isDirectory () ) { throw new IOException ( lr_10 + parent + lr_11 ) ; MST[ConstructorCallMutator]MSP[S] } } }
if ( srcFile . getCanonicalPath () . equals ( destFile . getCanonicalPath () ) ) { throw new IOException ( lr_29 + srcFile + lr_30 + destFile + lr_31 ) ; MST[ConstructorCallMutator]MSP[S] } final File parentFile = destFile . getParentFile () ; if ( parentFile != null ) {
if ( null != exception ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] throw exception ; } } private static File [] verifiedListFiles ( final File directory ) throws IOException { if ( ! directory . exists () ) { final String message = directory + lr_42 ; throw new IllegalArgumentException ( message ) ; }
final boolean file1Exists = file1 . exists () ; if ( file1Exists != file2 . exists () ) { MST[rv.ROR3Mutator]MSP[N] return false ; } if ( ! file1Exists ) { return true ; } if ( file1 . isDirectory () || file2 . isDirectory () ) {
while ( ! file . exists () ) { final long remaining = finishAt - System . currentTimeMillis () ; if ( remaining < 0 ) { MST[rv.CRCR6Mutator]MSP[N] return false ; } try { Thread . sleep ( Math . min ( 100 , remaining ) ) ;
throws IOException { final boolean file1Exists = file1 . exists () ; if ( file1Exists != file2 . exists () ) { return false ; } if ( ! file1Exists ) { return true ; } if ( file1 . isDirectory () || file2 . isDirectory () ) { MST[rv.ROR1Mutator]MSP[S]
throw new IOException ( lr_27 + destDir + lr_32 ) ; } } if ( destDir . canWrite () == false ) { throw new IOException ( lr_27 + destDir + lr_9 ) ; } for ( final File srcFile : srcFiles ) { MST[rv.ABSMutator]MSP[N]
throw new NullPointerException ( lr_26 ) ; } if ( ! src . exists () ) { throw new FileNotFoundException ( lr_29 + src + lr_8 ) ; MST[NonVoidMethodCallMutator]MSP[N] } } public static boolean isSymlink ( final File file ) { if ( file == null ) {
final int connectionTimeout , final int readTimeout ) throws IOException { final URLConnection connection = source . openConnection () ; connection . setConnectTimeout ( connectionTimeout ) ; MST[rv.UOI4Mutator]MSP[N] connection . setReadTimeout ( readTimeout ) ; copyInputStreamToFile ( connection . getInputStream () , destination ) ; }
throw new IOException ( lr_23 ) ; } if ( file1 . length () != file2 . length () ) { MST[NonVoidMethodCallMutator]MSP[N] return false ; } if ( file1 . getCanonicalFile () . equals ( file2 . getCanonicalFile () ) ) { return true ; }
final boolean success = file . setLastModified ( System . currentTimeMillis () ) ; if ( ! success ) { MST[rv.UOI1Mutator]MSP[N] throw new IOException ( lr_19 + file ) ; } } public static File [] convertFileCollectionToFileArray ( final Collection < File > files ) {
for ( final File srcFile : srcFiles ) { final File copiedFile = new File ( destDir , srcFile . getName () ) ; exclusionList . add ( copiedFile . getCanonicalPath () ) ; } } } doCopyDirectory ( srcDir , destDir , filter , preserveFileDate , exclusionList ) ; MST[rv.UOI4Mutator]MSP[S]
public static void moveDirectoryToDirectory ( final File src , final File destDir , final boolean createDestDir ) throws IOException { validateMoveParameters ( src , destDir ) ; if ( ! destDir . exists () && createDestDir ) { MST[rv.ROR2Mutator]MSP[N] destDir . mkdirs () ; }
if ( ! reference . exists () ) { throw new IllegalArgumentException ( lr_55 MST[NonVoidMethodCallMutator]MSP[S] + reference + lr_56 ) ; } return isFileOlder ( file , reference . lastModified () ) ; } public static boolean isFileOlder ( final File file , final Date date ) {
} } public static void forceDeleteOnExit ( final File file ) throws IOException { if ( file . isDirectory () ) { MST[rv.ROR5Mutator]MSP[N] deleteDirectoryOnExit ( file ) ; } else { file . deleteOnExit () ; } } private static void deleteDirectoryOnExit ( final File directory ) throws IOException {
} } return size ; } private static BigInteger sizeOfBig0 ( final File fileOrDir ) { if ( fileOrDir . isDirectory () ) { return sizeOfDirectoryBig0 ( fileOrDir ) ; } return BigInteger . valueOf ( fileOrDir . length () ) ; MST[NonVoidMethodCallMutator]MSP[N] }
final StringBuilder buffer = new StringBuilder () ; final ByteBuffer bytes = ByteBuffer . allocate ( n ) ; for ( int i = 0 ; i < n ; ) { MST[rv.UOI3Mutator]MSP[N] if ( url . charAt ( i ) == '%' ) { try { do {
for ( int i = 0 ; i < urls . length ; i ++ ) { MST[rv.CRCR1Mutator]MSP[N] final URL url = urls [ i ] ; if ( url != null ) { if ( url . getProtocol () . equals ( lr_24 ) == false ) {
displaySize = String . valueOf ( size . divide ( ONE_KB_BI ) ) + lr_17 ; MST[experimental.NakedReceiverMutator]MSP[N] } else { displaySize = String . valueOf ( size ) + lr_18 ; } return displaySize ; } public static String byteCountToDisplaySize ( final long size ) {
public static void write ( final File file , final CharSequence data , final boolean append ) throws IOException { write ( file , data , Charset . defaultCharset () , append ) ; MST[rv.UOI1Mutator]MSP[N] }
final byte octet = ( byte ) Integer . parseInt ( url . substring ( i + 1 , i + 3 ) , 16 ) ; MST[rv.CRCR5Mutator]MSP[N] bytes . put ( octet ) ; i += 3 ;
validateMoveParameters ( srcDir , destDir ) ; if ( ! srcDir . isDirectory () ) { throw new IOException ( lr_29 + srcDir + lr_28 ) ; } if ( destDir . exists () ) { MST[rv.ROR3Mutator]MSP[N] throw new FileExistsException ( lr_27 + destDir + lr_60 ) ; }
return isFileNewer ( file , date . getTime () ) ; } public static boolean isFileNewer ( final File file , final long timeMillis ) { if ( file == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] throw new IllegalArgumentException ( lr_58 ) ; } if ( ! file . exists () ) {
if ( ! destDir . exists () ) { throw new FileNotFoundException ( lr_66 + destDir + MST[ConstructorCallMutator]MSP[S] lr_67 + createDestDir + lr_68 ) ; } if ( ! destDir . isDirectory () ) { throw new IOException ( lr_27 + destDir + lr_28 ) ; }
private static void checkDirectory ( final File directory ) { if ( ! directory . exists () ) { throw new IllegalArgumentException ( directory + lr_42 ) ; } if ( ! directory . isDirectory () ) { MST[rv.ROR4Mutator]MSP[N] throw new IllegalArgumentException ( directory + lr_47 ) ; } }
doCopyDirectory ( srcFile , dstFile , filter , preserveFileDate , exclusionList ) ; MST[rv.UOI4Mutator]MSP[S] } else { doCopyFile ( srcFile , dstFile , preserveFileDate ) ; } } } if ( preserveFileDate ) { destDir . setLastModified ( srcDir . lastModified () ) ; } }
throw new NullPointerException ( lr_26 ) ; } if ( ! src . exists () ) { MST[rv.ROR1Mutator]MSP[N] throw new FileNotFoundException ( lr_29 + src + lr_8 ) ; } } public static boolean isSymlink ( final File file ) { if ( file == null ) {
throw new IOException ( lr_23 ) ; } if ( file1 . length () != file2 . length () ) { return false ; } if ( file1 . getCanonicalFile () . equals ( file2 . getCanonicalFile () ) ) { return true ; MST[BooleanFalseReturnValsMutator]MSP[N] }
final File dstFile = new File ( destDir , srcFile . getName () ) ; if ( exclusionList == null || ! exclusionList . contains ( srcFile . getCanonicalPath () ) ) { MST[rv.ROR2Mutator]MSP[S] if ( srcFile . isDirectory () ) {
final File dstFile = new File ( destDir , srcFile . getName () ) ; if ( exclusionList == null || ! exclusionList . contains ( srcFile . getCanonicalPath () ) ) { if ( srcFile . isDirectory () ) { MST[rv.ROR4Mutator]MSP[N]
if ( url == null || ! lr_24 . equalsIgnoreCase ( url . getProtocol () ) ) { MST[rv.ROR5Mutator]MSP[N] return null ; } String filename = url . getFile () . replace ( '/' , File . separatorChar ) ; filename = decodeUrl ( filename ) ;
if ( ! reference . exists () ) { MST[rv.ROR5Mutator]MSP[S] throw new IllegalArgumentException ( lr_55 + reference + lr_56 ) ; } return isFileOlder ( file , reference . lastModified () ) ; } public static boolean isFileOlder ( final File file , final Date date ) {
if ( srcLen != dstLen ) { MST[rv.UOI2Mutator]MSP[N] throw new IOException ( lr_34 + srcFile + lr_35 + destFile + lr_36 + srcLen + lr_37 + dstLen ) ; } } public static void copyDirectoryToDirectory ( final File srcDir , final File destDir ) throws IOException {
File file = null ; for ( final String name : names ) { if ( file == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] file = new File ( name ) ; } else { file = new File ( file , name ) ; } } return file ; }
return isFileNewer ( file , reference . lastModified () ) ; } public static boolean isFileNewer ( final File file , final Date date ) { if ( date == null ) { throw new IllegalArgumentException ( lr_57 ) ; MST[ConstructorCallMutator]MSP[N] }
displaySize = String . valueOf ( size . divide ( ONE_TB_BI ) ) + lr_14 ; MST[NonVoidMethodCallMutator]MSP[N] } else if ( size . divide ( ONE_GB_BI ) . compareTo ( BigInteger . ZERO ) > 0 ) {
throw new IOException ( lr_5 + file + lr_6 ) ; MST[experimental.NakedReceiverMutator]MSP[N] } if ( file . canRead () == false ) { throw new IOException ( lr_5 + file + lr_7 ) ; } } else { throw new FileNotFoundException ( lr_5 + file + lr_8 ) ; }
displaySize = String . valueOf ( size . divide ( ONE_KB_BI ) ) + lr_17 ; } else { displaySize = String . valueOf ( size ) + lr_18 ; MST[experimental.NakedReceiverMutator]MSP[N] } return displaySize ; } public static String byteCountToDisplaySize ( final long size ) {
if ( destDir . isDirectory () == false ) { throw new IOException ( lr_27 + destDir + lr_39 ) ; } } else { if ( ! destDir . mkdirs () && ! destDir . isDirectory () ) { MST[rv.ROR3Mutator]MSP[N]
return readLines ( file , Charsets . toCharset ( encoding ) ) ; MST[ReturnValsMutator]MSP[S] } @Deprecated public static List < String > readLines ( final File file ) throws IOException { return readLines ( file , Charset . defaultCharset () ) ; }
throw new IOException ( lr_23 ) ; } if ( file1 . getCanonicalFile () . equals ( file2 . getCanonicalFile () ) ) { MST[rv.ROR1Mutator]MSP[S] return true ; } try ( Reader input1 = charsetName == null
writeByteArrayToFile ( file , data , 0 , data . length , append ) ; MST[rv.ABSMutator]MSP[N] } public static void writeByteArrayToFile ( final File file , final byte [] data , final int off , final int len ) throws IOException {
final boolean rename = srcDir . renameTo ( destDir ) ; if ( ! rename ) { if ( destDir . getCanonicalPath () . startsWith ( srcDir . getCanonicalPath () + File . separator ) ) { MST[rv.ROR4Mutator]MSP[S] throw new IOException ( lr_61 + srcDir + lr_62 + destDir ) ;
displaySize = String . valueOf ( size . divide ( ONE_TB_BI ) ) + lr_14 ; } else if ( size . divide ( ONE_GB_BI ) . compareTo ( BigInteger . ZERO ) > 0 ) { MST[NonVoidMethodCallMutator]MSP[N]
+ lr_52 ; throw new IOException ( message ) ; } } else { if ( ! directory . mkdirs () ) { MST[rv.ROR1Mutator]MSP[S] if ( ! directory . isDirectory () ) { final String message = lr_53 + directory ; throw new IOException ( message ) ; } } }
doCopyDirectory ( srcFile , dstFile , filter , preserveFileDate , exclusionList ) ; } else { doCopyFile ( srcFile , dstFile , preserveFileDate ) ; } } } if ( preserveFileDate ) { MST[rv.ROR3Mutator]MSP[S] destDir . setLastModified ( srcDir . lastModified () ) ; } }
throw new IllegalArgumentException ( lr_58 ) ; } if ( ! file . exists () ) { MST[rv.ROR1Mutator]MSP[S] return false ; } return file . lastModified () < timeMillis ; } public static long checksumCRC32 ( final File file ) throws IOException { final CRC32 crc = new CRC32 () ;
displaySize = String . valueOf ( size . divide ( ONE_KB_BI ) ) + lr_17 ; MST[ArgumentPropagationMutator]MSP[N] } else { displaySize = String . valueOf ( size ) + lr_18 ; } return displaySize ; } public static String byteCountToDisplaySize ( final long size ) {
if ( srcFile . getCanonicalPath () . equals ( destFile . getCanonicalPath () ) ) { throw new IOException ( lr_29 + srcFile + lr_30 + destFile + lr_31 ) ; MST[experimental.NakedReceiverMutator]MSP[N] } final File parentFile = destFile . getParentFile () ; if ( parentFile != null ) {
return IOUtils . copyLarge ( fis , output ) ; } } private static void doCopyFile ( final File srcFile , final File destFile , final boolean preserveFileDate ) throws IOException { if ( destFile . exists () && destFile . isDirectory () ) { MST[rv.ROR2Mutator]MSP[N]
final StringBuilder buffer = new StringBuilder () ; final ByteBuffer bytes = ByteBuffer . allocate ( n ) ; MST[rv.UOI3Mutator]MSP[N] for ( int i = 0 ; i < n ; ) { if ( url . charAt ( i ) == '%' ) { try { do {
size += sizeOf0 ( file ) ; if ( size < 0 ) { break; } } } return size ; MST[rv.UOI4Mutator]MSP[N] } private static long sizeOf0 ( final File file ) { if ( file . isDirectory () ) { return sizeOfDirectory0 ( file ) ; }
if ( file . exists () ) { if ( file . isDirectory () ) { MST[rv.ROR4Mutator]MSP[N] throw new IOException ( lr_5 + file + lr_6 ) ; } if ( file . canWrite () == false ) { throw new IOException ( lr_5 + file + lr_9 ) ; }
try ( InputStream input1 = new FileInputStream ( file1 ) ; MST[ConstructorCallMutator]MSP[N] InputStream input2 = new FileInputStream ( file2 ) ) { return IOUtils . contentEquals ( input1 , input2 ) ; } } public static boolean contentEqualsIgnoreEOL ( final File file1 , final File file2 , final String charsetName )
public static void writeStringToFile ( final File file , final String data , final String encoding ) throws IOException { writeStringToFile ( file , data , encoding , false ) ; MST[rv.CRCR6Mutator]MSP[N] } public static void writeStringToFile ( final File file , final String data , final Charset encoding ,
size += sizeOf0 ( file ) ; if ( size < 0 ) { MST[rv.ROR2Mutator]MSP[N] break; } } } return size ; } private static long sizeOf0 ( final File file ) { if ( file . isDirectory () ) { return sizeOfDirectory0 ( file ) ; }
final File directory , final String [] extensions , final boolean recursive ) { return listFiles ( directory , extensions , recursive ) . iterator () ; MST[NullReturnValsMutator]MSP[S] } public static boolean contentEquals ( final File file1 , final File file2 ) throws IOException {
final boolean append ) throws IOException { try ( OutputStream out = openOutputStream ( file , append ) ) { MST[rv.ABSMutator]MSP[N] IOUtils . write ( data , out , encoding ) ; } } public static void writeStringToFile ( final File file , final String data , final String encoding ,
return new FileOutputStream ( file , append ) ; } public static String byteCountToDisplaySize ( final BigInteger size ) { String displaySize ; if ( size . divide ( ONE_EB_BI ) . compareTo ( BigInteger . ZERO ) > 0 ) { MST[rv.ROR5Mutator]MSP[N]
final String [] suffixes = new String [ extensions . length ] ; for ( int i = 0 ; i < extensions . length ; i ++ ) { MST[NegateConditionalsMutator]MSP[N] suffixes [ i ] = lr_22 + extensions [ i ] ; } return suffixes ; }
} catch ( final InterruptedException ignore ) { wasInterrupted = true ; } catch ( final Exception ex ) { break; } } } finally { if ( wasInterrupted ) { MST[rv.UOI4Mutator]MSP[S] Thread . currentThread () . interrupt () ; } } return true ; }
} while ( i < n && url . charAt ( i ) == '%' ); MST[rv.ABSMutator]MSP[N] continue; } catch ( final RuntimeException e ) { } finally { if ( bytes . position () > 0 ) { bytes . flip () ;
if ( ! destDir . isDirectory () ) { throw new IOException ( lr_27 + destDir + lr_28 ) ; MST[NonVoidMethodCallMutator]MSP[S] } moveFile ( srcFile , new File ( destDir , srcFile . getName () ) ) ; }
if ( ! srcDir . isDirectory () ) { throw new IOException ( lr_29 + srcDir + lr_39 ) ; MST[NonVoidMethodCallMutator]MSP[S] } if ( srcDir . getCanonicalPath () . equals ( destDir . getCanonicalPath () ) ) {
throw new IOException ( lr_23 ) ; MST[ConstructorCallMutator]MSP[S] } if ( file1 . length () != file2 . length () ) { return false ; } if ( file1 . getCanonicalFile () . equals ( file2 . getCanonicalFile () ) ) { return true ; }
final byte octet = ( byte ) Integer . parseInt ( url . substring ( i + 1 , i + 3 ) , 16 ) ; MST[rv.AOD1Mutator]MSP[N] bytes . put ( octet ) ; i += 3 ;
public static void moveDirectoryToDirectory ( final File src , final File destDir , final boolean createDestDir ) throws IOException { validateMoveParameters ( src , destDir ) ; if ( ! destDir . exists () && createDestDir ) { MST[rv.ROR3Mutator]MSP[N] destDir . mkdirs () ; }
if ( null != exception ) { throw exception ; } } public static void forceMkdir ( final File directory ) throws IOException { if ( directory . exists () ) { MST[rv.ROR5Mutator]MSP[N] if ( ! directory . isDirectory () ) { final String message = lr_50 + directory + lr_51
final boolean file1Exists = file1 . exists () ; if ( file1Exists != file2 . exists () ) { MST[rv.UOI3Mutator]MSP[N] return false ; } if ( ! file1Exists ) { return true ; } if ( file1 . isDirectory () || file2 . isDirectory () ) {
if ( ! directory . isDirectory () ) { throw new IllegalArgumentException ( lr_46 + directory ) ; } if ( child == null ) { return false ; } if ( ! directory . exists () || ! child . exists () ) { MST[rv.ROR1Mutator]MSP[N] return false ; }
buffer . append ( StandardCharsets . UTF_8 . decode ( bytes ) . toString () ) ; bytes . clear () ; } } } buffer . append ( url . charAt ( i ++ ) ) ; MST[rv.UOI3Mutator]MSP[N] } decoded = buffer . toString () ; } return decoded ;
if ( ! file . exists () ) { MST[rv.ROR2Mutator]MSP[N] final String message = file + lr_42 ; throw new IllegalArgumentException ( message ) ; } if ( file . isDirectory () ) { return sizeOfDirectory0 ( file ) ; } return file . length () ; }
throw new IllegalArgumentException ( lr_58 ) ; } if ( ! file . exists () ) { return false ; } return file . lastModified () < timeMillis ; MST[ConditionalsBoundaryMutator]MSP[N] } public static long checksumCRC32 ( final File file ) throws IOException { final CRC32 crc = new CRC32 () ;
final File [] found = directory . listFiles ( ( FileFilter ) filter ) ; if ( found != null ) { for ( final File file : found ) { if ( file . isDirectory () ) { if ( includeSubDirectories ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
throw new IOException ( lr_27 + destFile + lr_6 ) ; } final Path srcPath = srcFile . toPath () ; final Path destPath = destFile . toPath () ; final long newLastModifed = preserveFileDate ? srcFile . lastModified () : destFile . lastModified () ; MST[rv.UOI1Mutator]MSP[N]
if ( ! destDir . exists () ) { throw new FileNotFoundException ( lr_66 + destDir + lr_67 + createDestDir + lr_68 ) ; } if ( ! destDir . isDirectory () ) { throw new IOException ( lr_27 + destDir + lr_28 ) ; MST[ConstructorCallMutator]MSP[S] }
throw new IOException ( lr_27 + destFile + lr_6 ) ; } final Path srcPath = srcFile . toPath () ; final Path destPath = destFile . toPath () ; final long newLastModifed = preserveFileDate ? srcFile . lastModified () : destFile . lastModified () ; MST[rv.ROR2Mutator]MSP[N]
final boolean append ) throws IOException { try ( OutputStream out = openOutputStream ( file , append ) ) { MST[rv.UOI2Mutator]MSP[N] IOUtils . write ( data , out , encoding ) ; } } public static void writeStringToFile ( final File file , final String data , final String encoding ,
final byte octet = ( byte ) Integer . parseInt ( url . substring ( i + 1 , i + 3 ) , 16 ) ; MST[rv.CRCR2Mutator]MSP[N] bytes . put ( octet ) ; i += 3 ;
throw new IOException ( lr_27 + destDir + lr_32 ) ; } } if ( destDir . canWrite () == false ) { throw new IOException ( lr_27 + destDir + lr_9 ) ; } for ( final File srcFile : srcFiles ) { MST[rv.UOI4Mutator]MSP[N]
public static void writeLines ( final File file , final String encoding , final Collection < ? > lines , final String lineEnding , final boolean append ) throws IOException { try ( OutputStream out = new BufferedOutputStream ( openOutputStream ( file , append ) ) ) { MST[rv.UOI1Mutator]MSP[N]
File file = null ; for ( final String name : names ) { MST[rv.UOI3Mutator]MSP[S] if ( file == null ) { file = new File ( name ) ; } else { file = new File ( file , name ) ; } } return file ; }
final File [] srcFiles = filter == null ? srcDir . listFiles () : srcDir . listFiles ( filter ) ; if ( srcFiles != null && srcFiles . length > 0 ) { MST[rv.ROR1Mutator]MSP[N] exclusionList = new ArrayList <> ( srcFiles . length ) ;
for ( int i = 0 ; i < urls . length ; i ++ ) { MST[rv.UOI2Mutator]MSP[N] final URL url = urls [ i ] ; if ( url != null ) { if ( url . getProtocol () . equals ( lr_24 ) == false ) {
if ( ! parentFile . mkdirs () && ! parentFile . isDirectory () ) { MST[rv.ROR1Mutator]MSP[N] throw new IOException ( lr_27 + parentFile + lr_32 ) ; } } if ( destFile . exists () && destFile . canWrite () == false ) {
throw new IOException ( lr_40 + directory ) ; } return files ; } public static boolean waitFor ( final File file , final int seconds ) { final long finishAt = System . currentTimeMillis () + ( seconds * 1000L ) ; MST[rv.AOR1Mutator]MSP[N] boolean wasInterrupted = false ; try {
final StringBuilder buffer = new StringBuilder () ; final ByteBuffer bytes = ByteBuffer . allocate ( n ) ; for ( int i = 0 ; i < n ; ) { MST[rv.UOI2Mutator]MSP[N] if ( url . charAt ( i ) == '%' ) { try { do {
return fileLength > 0 ? IOUtils . toByteArray ( in , fileLength ) : IOUtils . toByteArray ( in ) ; MST[rv.CRCR1Mutator]MSP[N] } } public static List < String > readLines ( final File file , final Charset encoding ) throws IOException {
writeStringToFile ( file , data , Charset . defaultCharset () , false ) ; MST[NonVoidMethodCallMutator]MSP[N] } @Deprecated public static void writeStringToFile ( final File file , final String data , final boolean append ) throws IOException { writeStringToFile ( file , data , Charset . defaultCharset () , append ) ;
public static File getUserDirectory () { return new File ( getUserDirectoryPath () ) ; } public static FileInputStream openInputStream ( final File file ) throws IOException { if ( file . exists () ) { MST[NonVoidMethodCallMutator]MSP[N] if ( file . isDirectory () ) {
public static void writeLines ( final File file , final String encoding , final Collection < ? > lines , final String lineEnding ) throws IOException { writeLines ( file , encoding , lines , lineEnding , false ) ; MST[rv.CRCR1Mutator]MSP[N] }
final boolean rename = srcDir . renameTo ( destDir ) ; if ( ! rename ) { if ( destDir . getCanonicalPath () . startsWith ( srcDir . getCanonicalPath () + File . separator ) ) { MST[experimental.NakedReceiverMutator]MSP[S] throw new IOException ( lr_61 + srcDir + lr_62 + destDir ) ;
throw new IOException ( lr_23 ) ; } if ( file1 . length () != file2 . length () ) { return false ; } if ( file1 . getCanonicalFile () . equals ( file2 . getCanonicalFile () ) ) { MST[rv.ROR2Mutator]MSP[N] return true ; }
if ( date == null ) { throw new IllegalArgumentException ( lr_57 ) ; } return isFileOlder ( file , date . getTime () ) ; MST[NonVoidMethodCallMutator]MSP[S] } public static boolean isFileOlder ( final File file , final long timeMillis ) { if ( file == null ) {
if ( destDir . isDirectory () == false ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] throw new IOException ( lr_27 + destDir + lr_39 ) ; } } else { if ( ! destDir . mkdirs () && ! destDir . isDirectory () ) {
} public static void copyFile ( final File srcFile , final File destFile , final boolean preserveFileDate ) throws IOException { checkFileRequirements ( srcFile , destFile ) ; MST[VoidMethodCallMutator]MSP[N] if ( srcFile . isDirectory () ) { throw new IOException ( lr_29 + srcFile + lr_6 ) ; }
throw new NullPointerException ( lr_26 ) ; } if ( destDir . exists () && destDir . isDirectory () == false ) { MST[rv.ROR2Mutator]MSP[N] throw new IllegalArgumentException ( lr_27 + destDir + lr_28 ) ; }
displaySize = String . valueOf ( size . divide ( ONE_MB_BI ) ) + lr_16 ; MST[experimental.BigIntegerMutator]MSP[N] } else if ( size . divide ( ONE_KB_BI ) . compareTo ( BigInteger . ZERO ) > 0 ) {
} catch ( final InterruptedException ignore ) { wasInterrupted = true ; MST[rv.CRCR4Mutator]MSP[N] } catch ( final Exception ex ) { break; } } } finally { if ( wasInterrupted ) { Thread . currentThread () . interrupt () ; } } return true ; }
throw new IOException ( lr_27 + destFile + lr_69 ) ; } final boolean rename = srcFile . renameTo ( destFile ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( ! rename ) { copyFile ( srcFile , destFile ) ; if ( ! srcFile . delete () ) {
if ( file . exists () ) { if ( file . isDirectory () ) { throw new IOException ( lr_5 + file + lr_6 ) ; } if ( file . canWrite () == false ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] throw new IOException ( lr_5 + file + lr_9 ) ; }
if ( srcFile . getCanonicalPath () . equals ( destFile . getCanonicalPath () ) ) { throw new IOException ( lr_29 + srcFile + lr_30 + destFile + lr_31 ) ; MST[NonVoidMethodCallMutator]MSP[S] } final File parentFile = destFile . getParentFile () ; if ( parentFile != null ) {
public static void write ( final File file , final CharSequence data , final Charset encoding , final boolean append ) throws IOException { final String str = data == null ? null : data . toString () ; writeStringToFile ( file , str , encoding , append ) ; MST[rv.UOI1Mutator]MSP[N]
public static void write ( final File file , final CharSequence data , final Charset encoding , final boolean append ) throws IOException { final String str = data == null ? null : data . toString () ; writeStringToFile ( file , str , encoding , append ) ; MST[rv.ABSMutator]MSP[N]
public static BigInteger sizeOfAsBigInteger ( final File file ) { if ( ! file . exists () ) { final String message = file + lr_42 ; MST[NonVoidMethodCallMutator]MSP[S] throw new IllegalArgumentException ( message ) ; } if ( file . isDirectory () ) { return sizeOfDirectoryBig0 ( file ) ; }
if ( file == null ) { return false ; } try { if ( file . isDirectory () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] cleanDirectory ( file ) ; } } catch ( final Exception ignored ) { } try { return file . delete () ;
IOUtils . writeLines ( lines , lineEnding , out , encoding ) ; MST[VoidMethodCallMutator]MSP[N] } } public static void writeLines ( final File file , final Collection < ? > lines , final String lineEnding ) throws IOException {
final Collection < File > files = new java . util . LinkedList <> () ; MST[ConstructorCallMutator]MSP[N] if ( includeSubDirectories ) { files . add ( directory ) ; } innerListFiles ( files , directory , FileFilterUtils . or ( effFileFilter , effDirFilter ) , includeSubDirectories ) ; return files ;
validateMoveParameters ( srcDir , destDir ) ; if ( ! srcDir . isDirectory () ) { MST[NonVoidMethodCallMutator]MSP[N] throw new IOException ( lr_29 + srcDir + lr_28 ) ; } if ( destDir . exists () ) { throw new FileExistsException ( lr_27 + destDir + lr_60 ) ; }
if ( srcLen != dstLen ) { MST[rv.UOI3Mutator]MSP[N] throw new IOException ( lr_34 + srcFile + lr_35 + destFile + lr_36 + srcLen + lr_37 + dstLen ) ; } } public static void copyDirectoryToDirectory ( final File srcDir , final File destDir ) throws IOException {
if ( destDir . isDirectory () == false ) { throw new IOException ( lr_27 + destDir + lr_39 ) ; MST[ConstructorCallMutator]MSP[S] } } else { if ( ! destDir . mkdirs () && ! destDir . isDirectory () ) {
throw new IOException ( lr_5 + file + lr_6 ) ; MST[NonVoidMethodCallMutator]MSP[S] } if ( file . canRead () == false ) { throw new IOException ( lr_5 + file + lr_7 ) ; } } else { throw new FileNotFoundException ( lr_5 + file + lr_8 ) ; }
for ( int i = 0 ; i < urls . length ; i ++ ) { final URL url = urls [ i ] ; if ( url != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] if ( url . getProtocol () . equals ( lr_24 ) == false ) {
doCopyDirectory ( srcFile , dstFile , filter , preserveFileDate , exclusionList ) ; } else { doCopyFile ( srcFile , dstFile , preserveFileDate ) ; MST[rv.UOI3Mutator]MSP[S] } } } if ( preserveFileDate ) { destDir . setLastModified ( srcDir . lastModified () ) ; } }
throw new NullPointerException ( lr_26 ) ; } if ( ! src . exists () ) { throw new FileNotFoundException ( lr_29 + src + lr_8 ) ; MST[experimental.NakedReceiverMutator]MSP[N] } } public static boolean isSymlink ( final File file ) { if ( file == null ) {
if ( srcDir == null ) { throw new NullPointerException ( lr_38 ) ; } if ( srcDir . exists () && srcDir . isDirectory () == false ) { throw new IllegalArgumentException ( lr_29 + destDir + lr_28 ) ; } if ( destDir == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
while ( ! file . exists () ) { final long remaining = finishAt - System . currentTimeMillis () ; if ( remaining < 0 ) { return false ; MST[rv.UOI2Mutator]MSP[N] } try { Thread . sleep ( Math . min ( 100 , remaining ) ) ;
return FileFilterUtils . and ( fileFilter , FileFilterUtils . notFileFilter ( DirectoryFileFilter . INSTANCE ) ) ; MST[ArgumentPropagationMutator]MSP[N] } private static IOFileFilter setUpEffectiveDirFilter ( final IOFileFilter dirFilter ) { return dirFilter == null ? FalseFileFilter . INSTANCE : FileFilterUtils . and ( dirFilter , DirectoryFileFilter . INSTANCE ) ; }
final String [] suffixes = new String [ extensions . length ] ; for ( int i = 0 ; i < extensions . length ; i ++ ) { MST[InlineConstantMutator]MSP[N] suffixes [ i ] = lr_22 + extensions [ i ] ; } return suffixes ; }
writeByteArrayToFile ( file , data , 0 , data . length , append ) ; MST[rv.UOI2Mutator]MSP[N] } public static void writeByteArrayToFile ( final File file , final byte [] data , final int off , final int len ) throws IOException {
while ( ! file . exists () ) { final long remaining = finishAt - System . currentTimeMillis () ; if ( remaining < 0 ) { return false ; } try { Thread . sleep ( Math . min ( 100 , remaining ) ) ; MST[rv.UOI4Mutator]MSP[N]
final StringBuilder buffer = new StringBuilder () ; final ByteBuffer bytes = ByteBuffer . allocate ( n ) ; for ( int i = 0 ; i < n ; ) { if ( url . charAt ( i ) == '%' ) { MST[rv.ROR4Mutator]MSP[N] try { do {
final FileFilter filter ) throws IOException { copyDirectory ( srcDir , destDir , filter , true ) ; MST[VoidMethodCallMutator]MSP[S] } public static void copyDirectory ( final File srcDir , final File destDir , final FileFilter filter , final boolean preserveFileDate ) throws IOException { checkFileRequirements ( srcDir , destDir ) ;
if ( file == null ) { return false ; MST[rv.CRCR5Mutator]MSP[N] } try { if ( file . isDirectory () ) { cleanDirectory ( file ) ; } } catch ( final Exception ignored ) { } try { return file . delete () ;
if ( ! destDir . exists () ) { throw new FileNotFoundException ( lr_66 + destDir + lr_67 + createDestDir + lr_68 ) ; } if ( ! destDir . isDirectory () ) { MST[NonVoidMethodCallMutator]MSP[N] throw new IOException ( lr_27 + destDir + lr_28 ) ; }
if ( srcFile . getCanonicalPath () . equals ( destFile . getCanonicalPath () ) ) { throw new IOException ( lr_29 + srcFile + lr_30 + destFile + lr_31 ) ; } final File parentFile = destFile . getParentFile () ; if ( parentFile != null ) { MST[rv.ROR5Mutator]MSP[N]
final byte octet = ( byte ) Integer . parseInt ( url . substring ( i + 1 , i + 3 ) , 16 ) ; MST[rv.AOR2Mutator]MSP[N] bytes . put ( octet ) ; i += 3 ;
public static void writeLines ( final File file , final String encoding , final Collection < ? > lines , final String lineEnding , final boolean append ) throws IOException { try ( OutputStream out = new BufferedOutputStream ( openOutputStream ( file , append ) ) ) { MST[rv.ABSMutator]MSP[N]
final String [] suffixes = new String [ extensions . length ] ; for ( int i = 0 ; i < extensions . length ; i ++ ) { suffixes [ i ] = lr_22 + extensions [ i ] ; MST[experimental.NakedReceiverMutator]MSP[N] } return suffixes ; }
public static void moveToDirectory ( final File src , final File destDir , final boolean createDestDir ) throws IOException { validateMoveParameters ( src , destDir ) ; if ( src . isDirectory () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] moveDirectoryToDirectory ( src , destDir , createDestDir ) ; } else {
return new FileInputStream ( file ) ; } public static FileOutputStream openOutputStream ( final File file ) throws IOException { return openOutputStream ( file , false ) ; MST[rv.CRCR6Mutator]MSP[N] } public static FileOutputStream openOutputStream ( final File file , final boolean append ) throws IOException {
return file . length () ; } public static BigInteger sizeOfDirectoryAsBigInteger ( final File directory ) { checkDirectory ( directory ) ; return sizeOfDirectoryBig0 ( directory ) ; MST[ReturnValsMutator]MSP[S] } private static BigInteger sizeOfDirectoryBig0 ( final File directory ) { final File [] files = directory . listFiles () ;
if ( ! src . exists () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] throw new FileNotFoundException ( lr_29 + src + lr_8 ) ; } } private static void doCopyDirectory ( final File srcDir , final File destDir , final FileFilter filter , final boolean preserveFileDate , final List < String > exclusionList )
return isFileNewer ( file , date . getTime () ) ; } public static boolean isFileNewer ( final File file , final long timeMillis ) { if ( file == null ) { throw new IllegalArgumentException ( lr_58 ) ; } if ( ! file . exists () ) { MST[rv.ROR3Mutator]MSP[N]
if ( ! directory . isDirectory () ) { throw new IllegalArgumentException ( lr_46 + directory ) ; } if ( child == null ) { return false ; } if ( ! directory . exists () || ! child . exists () ) { return false ; MST[rv.CRCR3Mutator]MSP[N] }
if ( ! file . exists () ) { final String message = file + lr_42 ; throw new IllegalArgumentException ( message ) ; } if ( file . isDirectory () ) { MST[rv.ROR3Mutator]MSP[N] return sizeOfDirectory0 ( file ) ; } return file . length () ; }
return readLines ( file , Charsets . toCharset ( encoding ) ) ; MST[NonVoidMethodCallMutator]MSP[S] } @Deprecated public static List < String > readLines ( final File file ) throws IOException { return readLines ( file , Charset . defaultCharset () ) ; }
} while ( i < n && url . charAt ( i ) == '%' ); MST[rv.UOI1Mutator]MSP[N] continue; } catch ( final RuntimeException e ) { } finally { if ( bytes . position () > 0 ) { bytes . flip () ;
for ( final File srcFile : srcFiles ) { final File copiedFile = new File ( destDir , srcFile . getName () ) ; MST[ConstructorCallMutator]MSP[N] exclusionList . add ( copiedFile . getCanonicalPath () ) ; } } } doCopyDirectory ( srcDir , destDir , filter , preserveFileDate , exclusionList ) ;
throw new IOException ( lr_5 + file + lr_6 ) ; } if ( file . canRead () == false ) { MST[NegateConditionalsMutator]MSP[N] throw new IOException ( lr_5 + file + lr_7 ) ; } } else { throw new FileNotFoundException ( lr_5 + file + lr_8 ) ; }
if ( ! reference . exists () ) { throw new IllegalArgumentException ( lr_55 + reference + lr_56 ) ; } return isFileOlder ( file , reference . lastModified () ) ; MST[BooleanFalseReturnValsMutator]MSP[S] } public static boolean isFileOlder ( final File file , final Date date ) {
final File [] files = verifiedListFiles ( directory ) ; IOException exception = null ; for ( final File file : files ) { MST[rv.UOI3Mutator]MSP[S] try { forceDeleteOnExit ( file ) ; } catch ( final IOException ioe ) { exception = ioe ; } }
throw new IOException ( lr_27 + destDir + lr_32 ) ; } } if ( destDir . canWrite () == false ) { MST[rv.ROR3Mutator]MSP[N] throw new IOException ( lr_27 + destDir + lr_9 ) ; } for ( final File srcFile : srcFiles ) {
final boolean append ) throws IOException { writeStringToFile ( file , data , Charsets . toCharset ( encoding ) , append ) ; MST[rv.UOI4Mutator]MSP[N] } @Deprecated public static void writeStringToFile ( final File file , final String data ) throws IOException {
throws IOException { final boolean file1Exists = file1 . exists () ; if ( file1Exists != file2 . exists () ) { return false ; } if ( ! file1Exists ) { return true ; MST[ReturnValsMutator]MSP[S] } if ( file1 . isDirectory () || file2 . isDirectory () ) {
throw new IllegalArgumentException ( lr_58 ) ; } if ( ! file . exists () ) { return false ; } return file . lastModified () < timeMillis ; MST[rv.ROR5Mutator]MSP[S] } public static long checksumCRC32 ( final File file ) throws IOException { final CRC32 crc = new CRC32 () ;
copyDirectory ( srcDir , new File ( destDir , srcDir . getName () ) , true ) ; MST[NonVoidMethodCallMutator]MSP[N] } public static void copyDirectory ( final File srcDir , final File destDir ) throws IOException { copyDirectory ( srcDir , destDir , true ) ; }
public static String getTempDirectoryPath () { return System . getProperty ( lr_3 ) ; } public static File getTempDirectory () { return new File ( getTempDirectoryPath () ) ; MST[NonVoidMethodCallMutator]MSP[S] } public static String getUserDirectoryPath () { return System . getProperty ( lr_4 ) ; }
final FileFilter filter ) throws IOException { copyDirectory ( srcDir , destDir , filter , true ) ; MST[rv.CRCR6Mutator]MSP[N] } public static void copyDirectory ( final File srcDir , final File destDir , final FileFilter filter , final boolean preserveFileDate ) throws IOException { checkFileRequirements ( srcDir , destDir ) ;
throw new NullPointerException ( lr_38 ) ; } if ( src . isFile () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] copyFileToDirectory ( src , destDir ) ; } else if ( src . isDirectory () ) { copyDirectoryToDirectory ( src , destDir ) ; } else {
if ( ! file . exists () ) { final String message = file + lr_42 ; MST[experimental.NakedReceiverMutator]MSP[N] throw new IllegalArgumentException ( message ) ; } if ( file . isDirectory () ) { return sizeOfDirectory0 ( file ) ; } return file . length () ; }
throw new IOException ( lr_27 + destFile + lr_69 ) ; } final boolean rename = srcFile . renameTo ( destFile ) ; if ( ! rename ) { MST[rv.ABSMutator]MSP[N] copyFile ( srcFile , destFile ) ; if ( ! srcFile . delete () ) {
if ( srcLen != dstLen ) { throw new IOException ( lr_34 + srcFile + lr_35 + destFile MST[experimental.NakedReceiverMutator]MSP[N] + lr_36 + srcLen + lr_37 + dstLen ) ; } } public static void copyDirectoryToDirectory ( final File srcDir , final File destDir ) throws IOException {
if ( ! directory . isDirectory () ) { throw new IllegalArgumentException ( lr_46 + directory ) ; } if ( child == null ) { return false ; MST[rv.CRCR6Mutator]MSP[S] } if ( ! directory . exists () || ! child . exists () ) { return false ; }
throw new IllegalArgumentException ( lr_58 ) ; } if ( ! file . exists () ) { return false ; } return file . lastModified () < timeMillis ; MST[InlineConstantMutator]MSP[S] } public static long checksumCRC32 ( final File file ) throws IOException { final CRC32 crc = new CRC32 () ;
while ( ! file . exists () ) { final long remaining = finishAt - System . currentTimeMillis () ; if ( remaining < 0 ) { return false ; } try { Thread . sleep ( Math . min ( 100 , remaining ) ) ; MST[rv.CRCR1Mutator]MSP[N]
size += sizeOf0 ( file ) ; if ( size < 0 ) { break; } } } return size ; } private static long sizeOf0 ( final File file ) { if ( file . isDirectory () ) { return sizeOfDirectory0 ( file ) ; MST[PrimitiveReturnsMutator]MSP[N] }
throw new IOException ( lr_23 ) ; } if ( file1 . getCanonicalFile () . equals ( file2 . getCanonicalFile () ) ) { return true ; } try ( Reader input1 = charsetName == null MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S]
moveDirectory ( src , new File ( destDir , src . getName () ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } public static void moveFile ( final File srcFile , final File destFile ) throws IOException { validateMoveParameters ( srcFile , destFile ) ; if ( srcFile . isDirectory () ) {
final boolean file1Exists = file1 . exists () ; if ( file1Exists != file2 . exists () ) { return false ; } if ( ! file1Exists ) { return true ; MST[BooleanFalseReturnValsMutator]MSP[S] } if ( file1 . isDirectory () || file2 . isDirectory () ) {
if ( destDir == null ) { throw new NullPointerException ( lr_26 ) ; } if ( destDir . exists () && destDir . isDirectory () == false ) { MST[rv.ROR5Mutator]MSP[N] throw new IllegalArgumentException ( lr_27 + destDir + lr_28 ) ; }
for ( int i = 0 ; i < urls . length ; i ++ ) { MST[rv.ROR2Mutator]MSP[N] final URL url = urls [ i ] ; if ( url != null ) { if ( url . getProtocol () . equals ( lr_24 ) == false ) {
throw new IOException ( lr_5 + file + lr_6 ) ; } if ( file . canRead () == false ) { MST[rv.ROR5Mutator]MSP[N] throw new IOException ( lr_5 + file + lr_7 ) ; } } else { throw new FileNotFoundException ( lr_5 + file + lr_8 ) ; }
} else { final File parent = file . getParentFile () ; if ( parent != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] if ( ! parent . mkdirs () && ! parent . isDirectory () ) { throw new IOException ( lr_10 + parent + lr_11 ) ; } } }
final boolean file1Exists = file1 . exists () ; if ( file1Exists != file2 . exists () ) { return false ; } if ( ! file1Exists ) { MST[rv.ROR2Mutator]MSP[N] return true ; } if ( file1 . isDirectory () || file2 . isDirectory () ) {
private static void checkDirectory ( final File directory ) { if ( ! directory . exists () ) { MST[NonVoidMethodCallMutator]MSP[N] throw new IllegalArgumentException ( directory + lr_42 ) ; } if ( ! directory . isDirectory () ) { throw new IllegalArgumentException ( directory + lr_47 ) ; } }
} catch ( final Exception ignored ) { return false ; MST[BooleanTrueReturnValsMutator]MSP[S] } } public static boolean directoryContains ( final File directory , final File child ) throws IOException { if ( directory == null ) { throw new IllegalArgumentException ( lr_45 ) ; }
displaySize = String . valueOf ( size . divide ( ONE_KB_BI ) ) + lr_17 ; MST[NonVoidMethodCallMutator]MSP[N] } else { displaySize = String . valueOf ( size ) + lr_18 ; } return displaySize ; } public static String byteCountToDisplaySize ( final long size ) {
+ lr_52 ; throw new IOException ( message ) ; MST[ConstructorCallMutator]MSP[S] } } else { if ( ! directory . mkdirs () ) { if ( ! directory . isDirectory () ) { final String message = lr_53 + directory ; throw new IOException ( message ) ; } } }
writeStringToFile ( file , data , Charset . defaultCharset () , false ) ; MST[VoidMethodCallMutator]MSP[S] } @Deprecated public static void writeStringToFile ( final File file , final String data , final boolean append ) throws IOException { writeStringToFile ( file , data , Charset . defaultCharset () , append ) ;
try ( OutputStream out = openOutputStream ( file , append ) ) { out . write ( data , off , len ) ; MST[rv.ABSMutator]MSP[N] } } public static void writeLines ( final File file , final String encoding , final Collection < ? > lines ) throws IOException {
final String [] suffixes = toSuffixes ( extensions ) ; filter = new SuffixFileFilter ( suffixes ) ; MST[ConstructorCallMutator]MSP[N] } return listFiles ( directory , filter , recursive ? TrueFileFilter . INSTANCE : FalseFileFilter . INSTANCE ) ; } public static Iterator < File > iterateFiles (
throw new IllegalArgumentException ( lr_58 ) ; } if ( ! file . exists () ) { return false ; } return file . lastModified () < timeMillis ; MST[NegateConditionalsMutator]MSP[S] } public static long checksumCRC32 ( final File file ) throws IOException { final CRC32 crc = new CRC32 () ;
public static BigInteger sizeOfAsBigInteger ( final File file ) { if ( ! file . exists () ) { MST[rv.ROR5Mutator]MSP[N] final String message = file + lr_42 ; throw new IllegalArgumentException ( message ) ; } if ( file . isDirectory () ) { return sizeOfDirectoryBig0 ( file ) ; }
validateMoveParameters ( srcDir , destDir ) ; if ( ! srcDir . isDirectory () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] throw new IOException ( lr_29 + srcDir + lr_28 ) ; } if ( destDir . exists () ) { throw new FileExistsException ( lr_27 + destDir + lr_60 ) ; }
return false ; MST[rv.CRCR1Mutator]MSP[N] } return file . lastModified () > timeMillis ; } public static boolean isFileOlder ( final File file , final File reference ) { if ( reference == null ) { throw new IllegalArgumentException ( lr_54 ) ; }
throw new IllegalArgumentException ( MST[NonVoidMethodCallMutator]MSP[S] lr_25 + url ) ; } files [ i ] = toFile ( url ) ; } } return files ; } public static URL [] toURLs ( final File [] files ) throws IOException {
moveFileToDirectory ( src , destDir , createDestDir ) ; } } private static void validateMoveParameters ( final File src , final File dest ) throws FileNotFoundException { if ( src == null ) { throw new NullPointerException ( lr_38 ) ; } if ( dest == null ) { MST[NegateConditionalsMutator]MSP[N]
if ( ! directory . exists () ) { return; } directory . deleteOnExit () ; if ( ! isSymlink ( directory ) ) { MST[NegateConditionalsMutator]MSP[S] cleanDirectoryOnExit ( directory ) ; } } private static void cleanDirectoryOnExit ( final File directory ) throws IOException {
return new File ( filename ) ; MST[ReturnValsMutator]MSP[N] } static String decodeUrl ( final String url ) { String decoded = url ; if ( url != null && url . indexOf ( '%' ) >= 0 ) { final int n = url . length () ;
validateMoveParameters ( srcDir , destDir ) ; if ( ! srcDir . isDirectory () ) { throw new IOException ( lr_29 + srcDir + lr_28 ) ; } if ( destDir . exists () ) { throw new FileExistsException ( lr_27 + destDir + lr_60 ) ; MST[NonVoidMethodCallMutator]MSP[S] }
throw new IOException ( lr_29 + srcFile + lr_69 ) ; MST[experimental.NakedReceiverMutator]MSP[N] } if ( destFile . exists () ) { throw new FileExistsException ( lr_27 + destFile + lr_60 ) ; } if ( destFile . isDirectory () ) {
return FileFilterUtils . and ( fileFilter , FileFilterUtils . notFileFilter ( DirectoryFileFilter . INSTANCE ) ) ; MST[rv.CRCR1Mutator]MSP[N] } private static IOFileFilter setUpEffectiveDirFilter ( final IOFileFilter dirFilter ) { return dirFilter == null ? FalseFileFilter . INSTANCE : FileFilterUtils . and ( dirFilter , DirectoryFileFilter . INSTANCE ) ; }
size += sizeOf0 ( file ) ; if ( size < 0 ) { break; } } } return size ; } private static long sizeOf0 ( final File file ) { if ( file . isDirectory () ) { MST[rv.ROR2Mutator]MSP[N] return sizeOfDirectory0 ( file ) ; }
if ( ! parentFile . mkdirs () && ! parentFile . isDirectory () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] throw new IOException ( lr_27 + parentFile + lr_32 ) ; } } if ( destFile . exists () && destFile . canWrite () == false ) {
} while ( i < n && url . charAt ( i ) == '%' ); MST[RemoveConditionalMutator_ORDER_ELSE]MSP[S] continue; } catch ( final RuntimeException e ) { } finally { if ( bytes . position () > 0 ) { bytes . flip () ;
throw new NullPointerException ( lr_38 ) ; } if ( src . isFile () ) { MST[NonVoidMethodCallMutator]MSP[N] copyFileToDirectory ( src , destDir ) ; } else if ( src . isDirectory () ) { copyDirectoryToDirectory ( src , destDir ) ; } else {
if ( null != exception ) { throw exception ; } } public static void forceMkdir ( final File directory ) throws IOException { if ( directory . exists () ) { if ( ! directory . isDirectory () ) { MST[rv.ROR1Mutator]MSP[N] final String message = lr_50 + directory + lr_51
public static BigInteger sizeOfAsBigInteger ( final File file ) { if ( ! file . exists () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] final String message = file + lr_42 ; throw new IllegalArgumentException ( message ) ; } if ( file . isDirectory () ) { return sizeOfDirectoryBig0 ( file ) ; }
if ( ! reference . exists () ) { throw new IllegalArgumentException ( lr_55 + reference + lr_56 ) ; } return isFileOlder ( file , reference . lastModified () ) ; MST[NonVoidMethodCallMutator]MSP[S] } public static boolean isFileOlder ( final File file , final Date date ) {
moveFileToDirectory ( src , destDir , createDestDir ) ; } } private static void validateMoveParameters ( final File src , final File dest ) throws FileNotFoundException { if ( src == null ) { throw new NullPointerException ( lr_38 ) ; } if ( dest == null ) { MST[rv.ROR5Mutator]MSP[N]
} copyDirectory ( srcDir , destDir ) ; deleteDirectory ( srcDir ) ; if ( srcDir . exists () ) { MST[NegateConditionalsMutator]MSP[S] throw new IOException ( lr_63 + srcDir + lr_64 + destDir + lr_65 ) ; } } }
throws IOException { final boolean file1Exists = file1 . exists () ; if ( file1Exists != file2 . exists () ) { return false ; } if ( ! file1Exists ) { return true ; } if ( file1 . isDirectory () || file2 . isDirectory () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S]
final String [] suffixes = new String [ extensions . length ] ; for ( int i = 0 ; i < extensions . length ; i ++ ) { suffixes [ i ] = lr_22 + extensions [ i ] ; MST[NonVoidMethodCallMutator]MSP[N] } return suffixes ; }
if ( ! file . exists () ) { final String message = file + lr_42 ; throw new IllegalArgumentException ( message ) ; } if ( file . isDirectory () ) { return sizeOfDirectory0 ( file ) ; } return file . length () ; MST[ReturnValsMutator]MSP[S] }
if ( ! destDir . exists () ) { throw new FileNotFoundException ( lr_66 + destDir + MST[experimental.NakedReceiverMutator]MSP[N] lr_67 + createDestDir + lr_68 ) ; } if ( ! destDir . isDirectory () ) { throw new IOException ( lr_27 + destDir + lr_28 ) ; }
return IOUtils . copyLarge ( fis , output ) ; MST[rv.ABSMutator]MSP[N] } } private static void doCopyFile ( final File srcFile , final File destFile , final boolean preserveFileDate ) throws IOException { if ( destFile . exists () && destFile . isDirectory () ) {
if ( ! destDir . isDirectory () ) { throw new IOException ( lr_27 + destDir + lr_28 ) ; MST[experimental.NakedReceiverMutator]MSP[N] } moveFile ( srcFile , new File ( destDir , srcFile . getName () ) ) ; }
if ( null != exception ) { throw exception ; } } public static void forceMkdir ( final File directory ) throws IOException { if ( directory . exists () ) { MST[NegateConditionalsMutator]MSP[N] if ( ! directory . isDirectory () ) { final String message = lr_50 + directory + lr_51
final File directory , final IOFileFilter fileFilter , final IOFileFilter dirFilter , final boolean includeSubDirectories ) { validateListFilesParameters ( directory , fileFilter ) ; MST[VoidMethodCallMutator]MSP[S] final IOFileFilter effFileFilter = setUpEffectiveFileFilter ( fileFilter ) ; final IOFileFilter effDirFilter = setUpEffectiveDirFilter ( dirFilter ) ;
public static File getUserDirectory () { return new File ( getUserDirectoryPath () ) ; } public static FileInputStream openInputStream ( final File file ) throws IOException { if ( file . exists () ) { if ( file . isDirectory () ) { MST[rv.ROR2Mutator]MSP[N]
final String [] suffixes = new String [ extensions . length ] ; for ( int i = 0 ; i < extensions . length ; i ++ ) { suffixes [ i ] = lr_22 + extensions [ i ] ; MST[rv.UOI1Mutator]MSP[N] } return suffixes ; }
final boolean file1Exists = file1 . exists () ; if ( file1Exists != file2 . exists () ) { return false ; } if ( ! file1Exists ) { MST[rv.UOI1Mutator]MSP[N] return true ; } if ( file1 . isDirectory () || file2 . isDirectory () ) {
throw new IOException ( lr_23 ) ; } if ( file1 . getCanonicalFile () . equals ( file2 . getCanonicalFile () ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] return true ; } try ( Reader input1 = charsetName == null
throw new IOException ( lr_29 + srcFile + lr_69 ) ; MST[ConstructorCallMutator]MSP[S] } if ( destFile . exists () ) { throw new FileExistsException ( lr_27 + destFile + lr_60 ) ; } if ( destFile . isDirectory () ) {
for ( int i = 0 ; i < urls . length ; i ++ ) { final URL url = urls [ i ] ; if ( url != null ) { if ( url . getProtocol () . equals ( lr_24 ) == false ) { MST[rv.ROR2Mutator]MSP[N]
if ( srcFile . getCanonicalPath () . equals ( destFile . getCanonicalPath () ) ) { throw new IOException ( lr_29 + srcFile + lr_30 + destFile + lr_31 ) ; } final File parentFile = destFile . getParentFile () ; if ( parentFile != null ) { MST[NegateConditionalsMutator]MSP[N]
displaySize = String . valueOf ( size . divide ( ONE_GB_BI ) ) + lr_15 ; MST[NonVoidMethodCallMutator]MSP[N] } else if ( size . divide ( ONE_MB_BI ) . compareTo ( BigInteger . ZERO ) > 0 ) {
if ( files == null ) { return BigInteger . ZERO ; } BigInteger size = BigInteger . ZERO ; for ( final File file : files ) { if ( ! isSymlink ( file ) ) { MST[rv.ROR3Mutator]MSP[N] size = size . add ( sizeOfBig0 ( file ) ) ;
try ( OutputStream out = openOutputStream ( destination ) ) { MST[NonVoidMethodCallMutator]MSP[N] IOUtils . copy ( source , out ) ; } } public static void copyToDirectory ( final File src , final File destDir ) throws IOException { if ( src == null ) {
final Collection < File > files = new java . util . LinkedList <> () ; if ( includeSubDirectories ) { MST[rv.UOI3Mutator]MSP[N] files . add ( directory ) ; } innerListFiles ( files , directory , FileFilterUtils . or ( effFileFilter , effDirFilter ) , includeSubDirectories ) ; return files ;
for ( final String name : names ) { MST[rv.UOI1Mutator]MSP[S] file = new File ( file , name ) ; } return file ; } public static File getFile ( final String ... names ) { if ( names == null ) { throw new NullPointerException ( lr_2 ) ; }
final String [] suffixes = new String [ extensions . length ] ; for ( int i = 0 ; i < extensions . length ; i ++ ) { MST[ConditionalsBoundaryMutator]MSP[N] suffixes [ i ] = lr_22 + extensions [ i ] ; } return suffixes ; }
for ( final String name : names ) { file = new File ( file , name ) ; } return file ; } public static File getFile ( final String ... names ) { if ( names == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] throw new NullPointerException ( lr_2 ) ; }
doCopyDirectory ( srcFile , dstFile , filter , preserveFileDate , exclusionList ) ; } else { doCopyFile ( srcFile , dstFile , preserveFileDate ) ; } } } if ( preserveFileDate ) { MST[rv.UOI2Mutator]MSP[N] destDir . setLastModified ( srcDir . lastModified () ) ; } }
validateMoveParameters ( srcFile , destDir ) ; if ( ! destDir . exists () && createDestDir ) { MST[rv.ROR4Mutator]MSP[N] destDir . mkdirs () ; } if ( ! destDir . exists () ) { throw new FileNotFoundException ( lr_66 + destDir + lr_67 + createDestDir + lr_68 ) ; }
if ( srcDir == null ) { throw new NullPointerException ( lr_38 ) ; } if ( srcDir . exists () && srcDir . isDirectory () == false ) { MST[rv.ROR4Mutator]MSP[N] throw new IllegalArgumentException ( lr_29 + destDir + lr_28 ) ; } if ( destDir == null ) {
moveFileToDirectory ( src , destDir , createDestDir ) ; MST[rv.UOI1Mutator]MSP[N] } } private static void validateMoveParameters ( final File src , final File dest ) throws FileNotFoundException { if ( src == null ) { throw new NullPointerException ( lr_38 ) ; } if ( dest == null ) {
checkEqualSizes ( srcFile , destFile , srcFile . length () , destFile . length () ) ; MST[NonVoidMethodCallMutator]MSP[N] destFile . setLastModified ( newLastModifed ) ; } private static void checkEqualSizes ( final File srcFile , final File destFile , final long srcLen , final long dstLen ) throws IOException {
} @Deprecated public static void write ( final File file , final CharSequence data ) throws IOException { write ( file , data , Charset . defaultCharset () , false ) ; MST[rv.CRCR3Mutator]MSP[N] } @Deprecated
? new InputStreamReader ( new FileInputStream ( file1 ) , Charset . defaultCharset () ) MST[NonVoidMethodCallMutator]MSP[S] : new InputStreamReader ( new FileInputStream ( file1 ) , charsetName ) ; Reader input2 = charsetName == null ? new InputStreamReader ( new FileInputStream ( file2 ) , Charset . defaultCharset () )
if ( ! src . exists () ) { throw new FileNotFoundException ( lr_29 + src + lr_8 ) ; MST[NonVoidMethodCallMutator]MSP[N] } } private static void doCopyDirectory ( final File srcDir , final File destDir , final FileFilter filter , final boolean preserveFileDate , final List < String > exclusionList )
final boolean file1Exists = file1 . exists () ; if ( file1Exists != file2 . exists () ) { return false ; } if ( ! file1Exists ) { return true ; } if ( file1 . isDirectory () || file2 . isDirectory () ) { MST[rv.ROR1Mutator]MSP[N]
} } return size ; } private static BigInteger sizeOfBig0 ( final File fileOrDir ) { if ( fileOrDir . isDirectory () ) { MST[rv.ROR3Mutator]MSP[N] return sizeOfDirectoryBig0 ( fileOrDir ) ; } return BigInteger . valueOf ( fileOrDir . length () ) ; }
final File [] files = directory . listFiles () ; if ( files == null ) { return 0L ; } long size = 0 ; for ( final File file : files ) { if ( ! isSymlink ( file ) ) { MST[NonVoidMethodCallMutator]MSP[N]
try ( InputStream input1 = new FileInputStream ( file1 ) ; InputStream input2 = new FileInputStream ( file2 ) ) { return IOUtils . contentEquals ( input1 , input2 ) ; MST[rv.UOI4Mutator]MSP[N] } } public static boolean contentEqualsIgnoreEOL ( final File file1 , final File file2 , final String charsetName )
throw new IOException ( lr_29 + srcDir + lr_30 + destDir + lr_31 ) ; } List < String > exclusionList = null ; if ( destDir . getCanonicalPath () . startsWith ( srcDir . getCanonicalPath () ) ) { MST[NonVoidMethodCallMutator]MSP[N]
displaySize = String . valueOf ( size . divide ( ONE_EB_BI ) ) + lr_12 ; } else if ( size . divide ( ONE_PB_BI ) . compareTo ( BigInteger . ZERO ) > 0 ) { MST[ArgumentPropagationMutator]MSP[N]
final StringBuilder buffer = new StringBuilder () ; final ByteBuffer bytes = ByteBuffer . allocate ( n ) ; for ( int i = 0 ; i < n ; ) { MST[rv.ROR3Mutator]MSP[N] if ( url . charAt ( i ) == '%' ) { try { do {
return new FileOutputStream ( file , append ) ; } public static String byteCountToDisplaySize ( final BigInteger size ) { String displaySize ; if ( size . divide ( ONE_EB_BI ) . compareTo ( BigInteger . ZERO ) > 0 ) { MST[NegateConditionalsMutator]MSP[N]
throw new IOException ( lr_41 + src + lr_42 ) ; MST[NonVoidMethodCallMutator]MSP[N] } } public static void copyToDirectory ( final Iterable < File > srcs , final File destDir ) throws IOException { if ( srcs == null ) { throw new NullPointerException ( lr_43 ) ; }
return fileLength > 0 ? IOUtils . toByteArray ( in , fileLength ) : IOUtils . toByteArray ( in ) ; MST[rv.UOI2Mutator]MSP[N] } } public static List < String > readLines ( final File file , final Charset encoding ) throws IOException {
size += sizeOf0 ( file ) ; MST[rv.ABSMutator]MSP[N] if ( size < 0 ) { break; } } } return size ; } private static long sizeOf0 ( final File file ) { if ( file . isDirectory () ) { return sizeOfDirectory0 ( file ) ; }
if ( files == null ) { return BigInteger . ZERO ; } BigInteger size = BigInteger . ZERO ; for ( final File file : files ) { MST[rv.UOI3Mutator]MSP[N] if ( ! isSymlink ( file ) ) { size = size . add ( sizeOfBig0 ( file ) ) ;
return FileFilterUtils . and ( fileFilter , FileFilterUtils . notFileFilter ( DirectoryFileFilter . INSTANCE ) ) ; MST[rv.CRCR3Mutator]MSP[N] } private static IOFileFilter setUpEffectiveDirFilter ( final IOFileFilter dirFilter ) { return dirFilter == null ? FalseFileFilter . INSTANCE : FileFilterUtils . and ( dirFilter , DirectoryFileFilter . INSTANCE ) ; }
public static void copyDirectory ( final File srcDir , final File destDir , final boolean preserveFileDate ) throws IOException { copyDirectory ( srcDir , destDir , null , preserveFileDate ) ; MST[VoidMethodCallMutator]MSP[N] } public static void copyDirectory ( final File srcDir , final File destDir ,
final String [] suffixes = new String [ extensions . length ] ; for ( int i = 0 ; i < extensions . length ; i ++ ) { MST[rv.ROR5Mutator]MSP[N] suffixes [ i ] = lr_22 + extensions [ i ] ; } return suffixes ; }
if ( ! directory . isDirectory () ) { MST[rv.ROR4Mutator]MSP[S] throw new IllegalArgumentException ( lr_46 + directory ) ; } if ( child == null ) { return false ; } if ( ! directory . exists () || ! child . exists () ) { return false ; }
return FileFilterUtils . and ( fileFilter , FileFilterUtils . notFileFilter ( DirectoryFileFilter . INSTANCE ) ) ; MST[InlineConstantMutator]MSP[N] } private static IOFileFilter setUpEffectiveDirFilter ( final IOFileFilter dirFilter ) { return dirFilter == null ? FalseFileFilter . INSTANCE : FileFilterUtils . and ( dirFilter , DirectoryFileFilter . INSTANCE ) ; }
validateMoveParameters ( srcFile , destDir ) ; if ( ! destDir . exists () && createDestDir ) { destDir . mkdirs () ; } if ( ! destDir . exists () ) { MST[rv.ROR2Mutator]MSP[N] throw new FileNotFoundException ( lr_66 + destDir + lr_67 + createDestDir + lr_68 ) ; }
final boolean success = file . setLastModified ( System . currentTimeMillis () ) ; if ( ! success ) { MST[rv.ROR1Mutator]MSP[N] throw new IOException ( lr_19 + file ) ; } } public static File [] convertFileCollectionToFileArray ( final Collection < File > files ) {
return new FileOutputStream ( file , append ) ; } public static String byteCountToDisplaySize ( final BigInteger size ) { String displaySize ; if ( size . divide ( ONE_EB_BI ) . compareTo ( BigInteger . ZERO ) > 0 ) { MST[experimental.BigIntegerMutator]MSP[N]
throw new IllegalArgumentException ( lr_58 ) ; } if ( ! file . exists () ) { return false ; MST[rv.CRCR6Mutator]MSP[S] } return file . lastModified () < timeMillis ; } public static long checksumCRC32 ( final File file ) throws IOException { final CRC32 crc = new CRC32 () ;
for ( final String name : names ) { MST[rv.UOI1Mutator]MSP[S] file = new File ( file , name ) ; } return file ; } public static File getFile ( final String ... names ) { if ( names == null ) { throw new NullPointerException ( lr_2 ) ; }
if ( srcDir == null ) { throw new NullPointerException ( lr_38 ) ; } if ( srcDir . exists () && srcDir . isDirectory () == false ) { MST[rv.ROR3Mutator]MSP[N] throw new IllegalArgumentException ( lr_29 + destDir + lr_28 ) ; } if ( destDir == null ) {
if ( null != exception ) { throw exception ; } } public static void forceMkdir ( final File directory ) throws IOException { if ( directory . exists () ) { if ( ! directory . isDirectory () ) { final String message = MST[NonVoidMethodCallMutator]MSP[S] lr_50 + directory + lr_51
if ( ! file . exists () ) { final String message = file + lr_42 ; throw new IllegalArgumentException ( message ) ; } if ( file . isDirectory () ) { MST[rv.ROR2Mutator]MSP[N] return sizeOfDirectory0 ( file ) ; } return file . length () ; }
writeLines ( file , encoding , lines , null , append ) ; } public static void writeLines ( final File file , final Collection < ? > lines ) throws IOException { writeLines ( file , null , lines , null , false ) ; MST[rv.CRCR3Mutator]MSP[N] }
final boolean filePresent = file . exists () ; if ( ! file . delete () ) { if ( ! filePresent ) { MST[rv.ROR2Mutator]MSP[N] throw new FileNotFoundException ( lr_48 + file ) ; } final String message = lr_49 + file ; throw new IOException ( message ) ; }
final byte octet = ( byte ) Integer . parseInt ( url . substring ( i + 1 , i + 3 ) , 16 ) ; MST[rv.AOD2Mutator]MSP[N] bytes . put ( octet ) ; i += 3 ;
validateMoveParameters ( srcFile , destDir ) ; if ( ! destDir . exists () && createDestDir ) { MST[rv.UOI4Mutator]MSP[N] destDir . mkdirs () ; } if ( ! destDir . exists () ) { throw new FileNotFoundException ( lr_66 + destDir + lr_67 + createDestDir + lr_68 ) ; }
cleanDirectory ( directory ) ; } if ( ! directory . delete () ) { MST[rv.ROR1Mutator]MSP[N] final String message = lr_44 + directory + lr_22 ; throw new IOException ( message ) ; } } public static boolean deleteQuietly ( final File file ) {
displaySize = String . valueOf ( size . divide ( ONE_PB_BI ) ) + lr_13 ; MST[NonVoidMethodCallMutator]MSP[N] } else if ( size . divide ( ONE_TB_BI ) . compareTo ( BigInteger . ZERO ) > 0 ) {
throw new IOException ( lr_27 + destDir + lr_32 ) ; } } if ( destDir . canWrite () == false ) { MST[rv.ROR4Mutator]MSP[N] throw new IOException ( lr_27 + destDir + lr_9 ) ; } for ( final File srcFile : srcFiles ) {
for ( final String name : names ) { file = new File ( file , name ) ; } return file ; } public static File getFile ( final String ... names ) { if ( names == null ) { throw new NullPointerException ( lr_2 ) ; MST[ConstructorCallMutator]MSP[N] }
if ( ! directory . isDirectory () ) { throw new IllegalArgumentException ( lr_46 + directory ) ; } if ( child == null ) { return false ; } if ( ! directory . exists () || ! child . exists () ) { MST[NonVoidMethodCallMutator]MSP[S] return false ; }
writeByteArrayToFile ( file , data , off , len , false ) ; MST[rv.UOI4Mutator]MSP[S] } public static void writeByteArrayToFile ( final File file , final byte [] data , final int off , final int len , final boolean append ) throws IOException {
throw new IOException ( lr_29 + srcFile + lr_69 ) ; } if ( destFile . exists () ) { MST[rv.ROR2Mutator]MSP[N] throw new FileExistsException ( lr_27 + destFile + lr_60 ) ; } if ( destFile . isDirectory () ) {
throw new IOException ( lr_5 + file + lr_6 ) ; } if ( file . canRead () == false ) { throw new IOException ( lr_5 + file + lr_7 ) ; } } else { throw new FileNotFoundException ( lr_5 + file + lr_8 ) ; MST[NonVoidMethodCallMutator]MSP[N] }
public static LineIterator lineIterator ( final File file , final String encoding ) throws IOException { InputStream in = null ; try { in = openInputStream ( file ) ; return IOUtils . lineIterator ( in , encoding ) ; MST[NullReturnValsMutator]MSP[N] } catch ( final IOException | RuntimeException ex ) {
checksum ( file , crc ) ; return crc . getValue () ; MST[NonVoidMethodCallMutator]MSP[S] } public static Checksum checksum ( final File file , final Checksum checksum ) throws IOException { if ( file . isDirectory () ) { throw new IllegalArgumentException ( lr_59 ) ; }
public static File getFile ( final File directory , final String ... names ) { if ( directory == null ) { MST[rv.ROR5Mutator]MSP[S] throw new NullPointerException ( lr_1 ) ; } if ( names == null ) { throw new NullPointerException ( lr_2 ) ; } File file = directory ;
public static String getTempDirectoryPath () { return System . getProperty ( lr_3 ) ; MST[EmptyObjectReturnValsMutator]MSP[N] } public static File getTempDirectory () { return new File ( getTempDirectoryPath () ) ; } public static String getUserDirectoryPath () { return System . getProperty ( lr_4 ) ; }
moveDirectory ( src , new File ( destDir , src . getName () ) ) ; MST[VoidMethodCallMutator]MSP[N] } public static void moveFile ( final File srcFile , final File destFile ) throws IOException { validateMoveParameters ( srcFile , destFile ) ; if ( srcFile . isDirectory () ) {
public static File getUserDirectory () { return new File ( getUserDirectoryPath () ) ; } public static FileInputStream openInputStream ( final File file ) throws IOException { if ( file . exists () ) { MST[rv.ROR5Mutator]MSP[N] if ( file . isDirectory () ) {
displaySize = String . valueOf ( size . divide ( ONE_KB_BI ) ) + lr_17 ; } else { displaySize = String . valueOf ( size ) + lr_18 ; } return displaySize ; MST[ReturnValsMutator]MSP[N] } public static String byteCountToDisplaySize ( final long size ) {
final File [] found = directory . listFiles ( ( FileFilter ) filter ) ; if ( found != null ) { for ( final File file : found ) { MST[rv.UOI2Mutator]MSP[N] if ( file . isDirectory () ) { if ( includeSubDirectories ) {
final File [] files = directory . listFiles () ; if ( files == null ) { MST[NegateConditionalsMutator]MSP[N] return 0L ; } long size = 0 ; for ( final File file : files ) { if ( ! isSymlink ( file ) ) {
throw new IllegalArgumentException ( lr_58 ) ; } if ( ! file . exists () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] return false ; } return file . lastModified () < timeMillis ; } public static long checksumCRC32 ( final File file ) throws IOException { final CRC32 crc = new CRC32 () ;
displaySize = String . valueOf ( size . divide ( ONE_MB_BI ) ) + lr_16 ; } else if ( size . divide ( ONE_KB_BI ) . compareTo ( BigInteger . ZERO ) > 0 ) { MST[rv.ROR2Mutator]MSP[N]
throw new IOException ( lr_40 + directory ) ; } return files ; } public static boolean waitFor ( final File file , final int seconds ) { final long finishAt = System . currentTimeMillis () + ( seconds * 1000L ) ; MST[rv.UOI2Mutator]MSP[N] boolean wasInterrupted = false ; try {
final File [] found = directory . listFiles ( ( FileFilter ) filter ) ; if ( found != null ) { for ( final File file : found ) { if ( file . isDirectory () ) { MST[rv.ROR2Mutator]MSP[N] if ( includeSubDirectories ) {
for ( int i = 0 ; i < urls . length ; i ++ ) { MST[rv.ROR1Mutator]MSP[N] final URL url = urls [ i ] ; if ( url != null ) { if ( url . getProtocol () . equals ( lr_24 ) == false ) {
if ( ! directory . isDirectory () ) { throw new IllegalArgumentException ( lr_46 + directory ) ; MST[NonVoidMethodCallMutator]MSP[S] } if ( child == null ) { return false ; } if ( ! directory . exists () || ! child . exists () ) { return false ; }
return readFileToString ( file , Charset . defaultCharset () ) ; MST[EmptyObjectReturnValsMutator]MSP[N] } public static byte [] readFileToByteArray ( final File file ) throws IOException { try ( InputStream in = openInputStream ( file ) ) { final long fileLength = file . length () ;
public static Collection < File > listFilesAndDirs ( final File directory , final IOFileFilter fileFilter , final IOFileFilter dirFilter ) { return innerListFilesOrDirectories ( directory , fileFilter , dirFilter , true ) ; MST[rv.CRCR3Mutator]MSP[N] } private static Collection < File > innerListFilesOrDirectories (
if ( null != exception ) { throw exception ; } } public static void forceMkdir ( final File directory ) throws IOException { if ( directory . exists () ) { MST[NonVoidMethodCallMutator]MSP[S] if ( ! directory . isDirectory () ) { final String message = lr_50 + directory + lr_51
return byteCountToDisplaySize ( BigInteger . valueOf ( size ) ) ; } public static void touch ( final File file ) throws IOException { if ( ! file . exists () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] openOutputStream ( file ) . close () ; }
} } return size ; MST[NullReturnValsMutator]MSP[N] } private static BigInteger sizeOfBig0 ( final File fileOrDir ) { if ( fileOrDir . isDirectory () ) { return sizeOfDirectoryBig0 ( fileOrDir ) ; } return BigInteger . valueOf ( fileOrDir . length () ) ; }
final File destFile = new File ( destDir , srcFile . getName () ) ; copyFile ( srcFile , destFile , preserveFileDate ) ; } public static void copyFile ( final File srcFile , final File destFile ) throws IOException { copyFile ( srcFile , destFile , true ) ; MST[rv.CRCR2Mutator]MSP[N]
displaySize = String . valueOf ( size . divide ( ONE_GB_BI ) ) + lr_15 ; MST[experimental.NakedReceiverMutator]MSP[N] } else if ( size . divide ( ONE_MB_BI ) . compareTo ( BigInteger . ZERO ) > 0 ) {
} else { final File parent = file . getParentFile () ; if ( parent != null ) { if ( ! parent . mkdirs () && ! parent . isDirectory () ) { MST[rv.ROR3Mutator]MSP[N] throw new IOException ( lr_10 + parent + lr_11 ) ; } } }
for ( int i = 0 ; i < urls . length ; i ++ ) { final URL url = urls [ i ] ; if ( url != null ) { if ( url . getProtocol () . equals ( lr_24 ) == false ) { MST[rv.ROR1Mutator]MSP[N]
public static File getUserDirectory () { return new File ( getUserDirectoryPath () ) ; } public static FileInputStream openInputStream ( final File file ) throws IOException { if ( file . exists () ) { MST[NegateConditionalsMutator]MSP[N] if ( file . isDirectory () ) {
public static File getFile ( final File directory , final String ... names ) { if ( directory == null ) { MST[NegateConditionalsMutator]MSP[S] throw new NullPointerException ( lr_1 ) ; } if ( names == null ) { throw new NullPointerException ( lr_2 ) ; } File file = directory ;
public static void moveToDirectory ( final File src , final File destDir , final boolean createDestDir ) throws IOException { validateMoveParameters ( src , destDir ) ; if ( src . isDirectory () ) { MST[rv.ROR1Mutator]MSP[S] moveDirectoryToDirectory ( src , destDir , createDestDir ) ; } else {
writeLines ( file , encoding , lines , null , false ) ; MST[VoidMethodCallMutator]MSP[S] } public static void writeLines ( final File file , final String encoding , final Collection < ? > lines , final boolean append ) throws IOException {
public static void writeLines ( final File file , final Collection < ? > lines , final boolean append ) throws IOException { writeLines ( file , null , lines , null , append ) ; MST[rv.UOI1Mutator]MSP[N] }
return new FileOutputStream ( file , append ) ; } public static String byteCountToDisplaySize ( final BigInteger size ) { String displaySize ; if ( size . divide ( ONE_EB_BI ) . compareTo ( BigInteger . ZERO ) > 0 ) { MST[NonVoidMethodCallMutator]MSP[N]
public static boolean isFileNewer ( final File file , final File reference ) { if ( reference == null ) { throw new IllegalArgumentException ( lr_54 ) ; } if ( ! reference . exists () ) { throw new IllegalArgumentException ( lr_55 MST[NonVoidMethodCallMutator]MSP[S] + reference + lr_56 ) ; }
throw new IOException ( lr_27 + destFile + lr_6 ) ; } final Path srcPath = srcFile . toPath () ; final Path destPath = destFile . toPath () ; MST[NonVoidMethodCallMutator]MSP[N] final long newLastModifed = preserveFileDate ? srcFile . lastModified () : destFile . lastModified () ;
if ( url == null || ! lr_24 . equalsIgnoreCase ( url . getProtocol () ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return null ; } String filename = url . getFile () . replace ( '/' , File . separatorChar ) ; filename = decodeUrl ( filename ) ;
throw new IOException ( lr_23 ) ; } if ( file1 . length () != file2 . length () ) { return false ; } if ( file1 . getCanonicalFile () . equals ( file2 . getCanonicalFile () ) ) { MST[rv.ROR3Mutator]MSP[S] return true ; }
throw new IllegalArgumentException ( lr_58 ) ; } if ( ! file . exists () ) { return false ; } return file . lastModified () < timeMillis ; MST[rv.CRCR5Mutator]MSP[S] } public static long checksumCRC32 ( final File file ) throws IOException { final CRC32 crc = new CRC32 () ;
displaySize = String . valueOf ( size . divide ( ONE_TB_BI ) ) + lr_14 ; } else if ( size . divide ( ONE_GB_BI ) . compareTo ( BigInteger . ZERO ) > 0 ) { MST[rv.ROR1Mutator]MSP[N]
return new File ( filename ) ; } static String decodeUrl ( final String url ) { String decoded = url ; if ( url != null && url . indexOf ( '%' ) >= 0 ) { MST[rv.ROR2Mutator]MSP[N] final int n = url . length () ;
return new File ( filename ) ; } static String decodeUrl ( final String url ) { String decoded = url ; if ( url != null && url . indexOf ( '%' ) >= 0 ) { MST[rv.ROR5Mutator]MSP[N] final int n = url . length () ;
final Collection < File > files = new java . util . LinkedList <> () ; if ( includeSubDirectories ) { files . add ( directory ) ; } innerListFiles ( files , directory , MST[rv.CRCR1Mutator]MSP[N] FileFilterUtils . or ( effFileFilter , effDirFilter ) , includeSubDirectories ) ; return files ;
throw new IOException ( lr_40 + directory ) ; } return files ; } public static boolean waitFor ( final File file , final int seconds ) { final long finishAt = System . currentTimeMillis () + ( seconds * 1000L ) ; MST[rv.ABSMutator]MSP[N] boolean wasInterrupted = false ; try {
try ( OutputStream out = openOutputStream ( file , append ) ) { out . write ( data , off , len ) ; MST[rv.ABSMutator]MSP[N] } } public static void writeLines ( final File file , final String encoding , final Collection < ? > lines ) throws IOException {
return FileFilterUtils . and ( fileFilter , FileFilterUtils . notFileFilter ( DirectoryFileFilter . INSTANCE ) ) ; } private static IOFileFilter setUpEffectiveDirFilter ( final IOFileFilter dirFilter ) { return dirFilter == null ? FalseFileFilter . INSTANCE : FileFilterUtils . and ( dirFilter , MST[NullReturnValsMutator]MSP[N] DirectoryFileFilter . INSTANCE ) ; }
buffer . append ( StandardCharsets . UTF_8 . decode ( bytes ) . toString () ) ; bytes . clear () ; MST[NonVoidMethodCallMutator]MSP[N] } } } buffer . append ( url . charAt ( i ++ ) ) ; } decoded = buffer . toString () ; } return decoded ;
throw new NullPointerException ( lr_26 ) ; } if ( ! src . exists () ) { MST[rv.ROR2Mutator]MSP[N] throw new FileNotFoundException ( lr_29 + src + lr_8 ) ; } } public static boolean isSymlink ( final File file ) { if ( file == null ) {
if ( ! directory . exists () ) { return; } directory . deleteOnExit () ; if ( ! isSymlink ( directory ) ) { MST[rv.ROR5Mutator]MSP[S] cleanDirectoryOnExit ( directory ) ; } } private static void cleanDirectoryOnExit ( final File directory ) throws IOException {
throw new IOException ( lr_5 + file + lr_6 ) ; } if ( file . canRead () == false ) { throw new IOException ( lr_5 + file + lr_7 ) ; } } else { throw new FileNotFoundException ( lr_5 + file + lr_8 ) ; MST[ConstructorCallMutator]MSP[N] }
public static Iterator < File > iterateFilesAndDirs ( final File directory , final IOFileFilter fileFilter , final IOFileFilter dirFilter ) { return listFilesAndDirs ( directory , fileFilter , dirFilter ) . iterator () ; MST[NonVoidMethodCallMutator]MSP[S] } private static String [] toSuffixes ( final String [] extensions ) {
return fileLength > 0 ? IOUtils . toByteArray ( in , fileLength ) : IOUtils . toByteArray ( in ) ; MST[rv.UOI1Mutator]MSP[N] } } public static List < String > readLines ( final File file , final Charset encoding ) throws IOException {
final StringBuilder buffer = new StringBuilder () ; final ByteBuffer bytes = ByteBuffer . allocate ( n ) ; for ( int i = 0 ; i < n ; ) { if ( url . charAt ( i ) == '%' ) { MST[rv.UOI4Mutator]MSP[N] try { do {
return new File ( filename ) ; } static String decodeUrl ( final String url ) { String decoded = url ; if ( url != null && url . indexOf ( '%' ) >= 0 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] final int n = url . length () ;
if ( ! parentFile . mkdirs () && ! parentFile . isDirectory () ) { MST[NonVoidMethodCallMutator]MSP[N] throw new IOException ( lr_27 + parentFile + lr_32 ) ; } } if ( destFile . exists () && destFile . canWrite () == false ) {
throw new IOException ( lr_23 ) ; } if ( file1 . length () != file2 . length () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return false ; } if ( file1 . getCanonicalFile () . equals ( file2 . getCanonicalFile () ) ) { return true ; }
throw new IOException ( lr_27 + destDir + lr_32 ) ; } } if ( destDir . canWrite () == false ) { throw new IOException ( lr_27 + destDir + lr_9 ) ; } for ( final File srcFile : srcFiles ) { MST[rv.UOI3Mutator]MSP[N]
public static BigInteger sizeOfAsBigInteger ( final File file ) { if ( ! file . exists () ) { MST[NonVoidMethodCallMutator]MSP[N] final String message = file + lr_42 ; throw new IllegalArgumentException ( message ) ; } if ( file . isDirectory () ) { return sizeOfDirectoryBig0 ( file ) ; }
return readLines ( file , Charsets . toCharset ( encoding ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } @Deprecated public static List < String > readLines ( final File file ) throws IOException { return readLines ( file , Charset . defaultCharset () ) ; }
} } public static void forceDeleteOnExit ( final File file ) throws IOException { if ( file . isDirectory () ) { MST[rv.ROR4Mutator]MSP[S] deleteDirectoryOnExit ( file ) ; } else { file . deleteOnExit () ; } } private static void deleteDirectoryOnExit ( final File directory ) throws IOException {
validateMoveParameters ( srcFile , destDir ) ; if ( ! destDir . exists () && createDestDir ) { MST[rv.ROR5Mutator]MSP[N] destDir . mkdirs () ; } if ( ! destDir . exists () ) { throw new FileNotFoundException ( lr_66 + destDir + lr_67 + createDestDir + lr_68 ) ; }
if ( file == null ) { return false ; } try { if ( file . isDirectory () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] cleanDirectory ( file ) ; } } catch ( final Exception ignored ) { } try { return file . delete () ;
throw new NullPointerException ( lr_38 ) ; } if ( src . isFile () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] copyFileToDirectory ( src , destDir ) ; } else if ( src . isDirectory () ) { copyDirectoryToDirectory ( src , destDir ) ; } else {
if ( destDir . isDirectory () == false ) { throw new IOException ( lr_27 + destDir + lr_39 ) ; MST[ConstructorCallMutator]MSP[S] } } else { if ( ! destDir . mkdirs () && ! destDir . isDirectory () ) {
final String [] suffixes = toSuffixes ( extensions ) ; filter = new SuffixFileFilter ( suffixes ) ; } return listFiles ( directory , filter , MST[NonVoidMethodCallMutator]MSP[N] recursive ? TrueFileFilter . INSTANCE : FalseFileFilter . INSTANCE ) ; } public static Iterator < File > iterateFiles (
for ( final File srcFile : srcFiles ) { MST[rv.UOI3Mutator]MSP[N] final File copiedFile = new File ( destDir , srcFile . getName () ) ; exclusionList . add ( copiedFile . getCanonicalPath () ) ; } } } doCopyDirectory ( srcDir , destDir , filter , preserveFileDate , exclusionList ) ;
if ( ! file . exists () ) { final String message = file + lr_42 ; throw new IllegalArgumentException ( message ) ; } if ( file . isDirectory () ) { return sizeOfDirectory0 ( file ) ; MST[PrimitiveReturnsMutator]MSP[S] } return file . length () ; }
if ( ! destDir . exists () ) { throw new FileNotFoundException ( lr_66 + destDir + MST[NonVoidMethodCallMutator]MSP[S] lr_67 + createDestDir + lr_68 ) ; } if ( ! destDir . isDirectory () ) { throw new IOException ( lr_27 + destDir + lr_28 ) ; }
final byte octet = ( byte ) Integer . parseInt ( url . substring ( i + 1 , i + 3 ) , 16 ) ; bytes . put ( octet ) ; MST[experimental.NakedReceiverMutator]MSP[N] i += 3 ;
final byte octet = ( byte ) Integer . parseInt ( url . substring ( i + 1 , i + 3 ) , 16 ) ; MST[ArgumentPropagationMutator]MSP[N] bytes . put ( octet ) ; i += 3 ;
if ( srcFile . getCanonicalPath () . equals ( destFile . getCanonicalPath () ) ) { MST[rv.ROR3Mutator]MSP[N] throw new IOException ( lr_29 + srcFile + lr_30 + destFile + lr_31 ) ; } final File parentFile = destFile . getParentFile () ; if ( parentFile != null ) {
public static void writeByteArrayToFile ( final File file , final byte [] data ) throws IOException { writeByteArrayToFile ( file , data , false ) ; MST[rv.CRCR6Mutator]MSP[N] } public static void writeByteArrayToFile ( final File file , final byte [] data , final boolean append ) throws IOException {
final File [] found = directory . listFiles ( ( FileFilter ) filter ) ; if ( found != null ) { for ( final File file : found ) { MST[rv.ABSMutator]MSP[N] if ( file . isDirectory () ) { if ( includeSubDirectories ) {
final boolean file1Exists = file1 . exists () ; if ( file1Exists != file2 . exists () ) { return false ; } if ( ! file1Exists ) { return true ; } if ( file1 . isDirectory () || file2 . isDirectory () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
while ( ! file . exists () ) { final long remaining = finishAt - System . currentTimeMillis () ; if ( remaining < 0 ) { return false ; } try { Thread . sleep ( Math . min ( 100 , remaining ) ) ; MST[rv.CRCR2Mutator]MSP[N]
return FileFilterUtils . and ( fileFilter , FileFilterUtils . notFileFilter ( DirectoryFileFilter . INSTANCE ) ) ; MST[rv.CRCR2Mutator]MSP[N] } private static IOFileFilter setUpEffectiveDirFilter ( final IOFileFilter dirFilter ) { return dirFilter == null ? FalseFileFilter . INSTANCE : FileFilterUtils . and ( dirFilter , DirectoryFileFilter . INSTANCE ) ; }
return new FileOutputStream ( file , append ) ; MST[rv.UOI1Mutator]MSP[N] } public static String byteCountToDisplaySize ( final BigInteger size ) { String displaySize ; if ( size . divide ( ONE_EB_BI ) . compareTo ( BigInteger . ZERO ) > 0 ) {
throws IOException { final boolean file1Exists = file1 . exists () ; if ( file1Exists != file2 . exists () ) { return false ; } if ( ! file1Exists ) { MST[rv.UOI4Mutator]MSP[S] return true ; } if ( file1 . isDirectory () || file2 . isDirectory () ) {
throws IOException { final boolean file1Exists = file1 . exists () ; if ( file1Exists != file2 . exists () ) { MST[rv.ROR5Mutator]MSP[S] return false ; } if ( ! file1Exists ) { return true ; } if ( file1 . isDirectory () || file2 . isDirectory () ) {
final File dstFile = new File ( destDir , srcFile . getName () ) ; if ( exclusionList == null || ! exclusionList . contains ( srcFile . getCanonicalPath () ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] if ( srcFile . isDirectory () ) {
} } return size ; } private static BigInteger sizeOfBig0 ( final File fileOrDir ) { if ( fileOrDir . isDirectory () ) { return sizeOfDirectoryBig0 ( fileOrDir ) ; } return BigInteger . valueOf ( fileOrDir . length () ) ; MST[NonVoidMethodCallMutator]MSP[N] }
moveFileToDirectory ( src , destDir , createDestDir ) ; MST[rv.ABSMutator]MSP[N] } } private static void validateMoveParameters ( final File src , final File dest ) throws FileNotFoundException { if ( src == null ) { throw new NullPointerException ( lr_38 ) ; } if ( dest == null ) {
+ lr_52 ; throw new IOException ( message ) ; } } else { if ( ! directory . mkdirs () ) { MST[rv.ROR2Mutator]MSP[S] if ( ! directory . isDirectory () ) { final String message = lr_53 + directory ; throw new IOException ( message ) ; } } }
for ( final String name : names ) { MST[rv.ABSMutator]MSP[S] file = new File ( file , name ) ; } return file ; } public static File getFile ( final String ... names ) { if ( names == null ) { throw new NullPointerException ( lr_2 ) ; }
} catch ( final InterruptedException ignore ) { wasInterrupted = true ; MST[InlineConstantMutator]MSP[S] } catch ( final Exception ex ) { break; } } } finally { if ( wasInterrupted ) { Thread . currentThread () . interrupt () ; } } return true ; }
if ( ! destDir . exists () ) { MST[rv.ROR1Mutator]MSP[N] throw new FileNotFoundException ( lr_66 + destDir + lr_67 + createDestDir + lr_68 ) ; } if ( ! destDir . isDirectory () ) { throw new IOException ( lr_27 + destDir + lr_28 ) ; }
if ( url == null || ! lr_24 . equalsIgnoreCase ( url . getProtocol () ) ) { MST[rv.ROR2Mutator]MSP[N] return null ; } String filename = url . getFile () . replace ( '/' , File . separatorChar ) ; filename = decodeUrl ( filename ) ;
if ( ! file . exists () ) { final String message = file + lr_42 ; MST[NonVoidMethodCallMutator]MSP[S] throw new IllegalArgumentException ( message ) ; } if ( file . isDirectory () ) { return sizeOfDirectory0 ( file ) ; } return file . length () ; }
} copyDirectory ( srcDir , destDir ) ; MST[VoidMethodCallMutator]MSP[S] deleteDirectory ( srcDir ) ; if ( srcDir . exists () ) { throw new IOException ( lr_63 + srcDir + lr_64 + destDir + lr_65 ) ; } } }
Files . copy ( srcPath , destPath , StandardCopyOption . REPLACE_EXISTING ) ; checkEqualSizes ( srcFile , destFile , Files . size ( srcPath ) , Files . size ( destPath ) ) ; MST[VoidMethodCallMutator]MSP[N]
throw new IOException ( lr_23 ) ; MST[ConstructorCallMutator]MSP[S] } if ( file1 . getCanonicalFile () . equals ( file2 . getCanonicalFile () ) ) { return true ; } try ( Reader input1 = charsetName == null
final boolean file1Exists = file1 . exists () ; if ( file1Exists != file2 . exists () ) { return false ; } if ( ! file1Exists ) { return true ; } if ( file1 . isDirectory () || file2 . isDirectory () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
displaySize = String . valueOf ( size . divide ( ONE_MB_BI ) ) + lr_16 ; MST[NonVoidMethodCallMutator]MSP[N] } else if ( size . divide ( ONE_KB_BI ) . compareTo ( BigInteger . ZERO ) > 0 ) {
return file . length () ; } public static BigInteger sizeOfDirectoryAsBigInteger ( final File directory ) { checkDirectory ( directory ) ; return sizeOfDirectoryBig0 ( directory ) ; MST[NullReturnValsMutator]MSP[S] } private static BigInteger sizeOfDirectoryBig0 ( final File directory ) { final File [] files = directory . listFiles () ;
throw new IOException ( lr_29 + srcFile + lr_69 ) ; } if ( destFile . exists () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] throw new FileExistsException ( lr_27 + destFile + lr_60 ) ; } if ( destFile . isDirectory () ) {
return byteCountToDisplaySize ( BigInteger . valueOf ( size ) ) ; MST[rv.UOI4Mutator]MSP[S] } public static void touch ( final File file ) throws IOException { if ( ! file . exists () ) { openOutputStream ( file ) . close () ; }
final boolean file1Exists = file1 . exists () ; if ( file1Exists != file2 . exists () ) { MST[rv.UOI4Mutator]MSP[N] return false ; } if ( ! file1Exists ) { return true ; } if ( file1 . isDirectory () || file2 . isDirectory () ) {
while ( ! file . exists () ) { final long remaining = finishAt - System . currentTimeMillis () ; if ( remaining < 0 ) { MST[rv.ROR3Mutator]MSP[N] return false ; } try { Thread . sleep ( Math . min ( 100 , remaining ) ) ;
} public static File [] toFiles ( final URL [] urls ) { if ( urls == null || urls . length == 0 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return EMPTY_FILE_ARRAY ; } final File [] files = new File [ urls . length ] ;
if ( file == null ) { return false ; } try { if ( file . isDirectory () ) { MST[NonVoidMethodCallMutator]MSP[N] cleanDirectory ( file ) ; } } catch ( final Exception ignored ) { } try { return file . delete () ;
validateMoveParameters ( srcFile , destDir ) ; if ( ! destDir . exists () && createDestDir ) { MST[NonVoidMethodCallMutator]MSP[N] destDir . mkdirs () ; } if ( ! destDir . exists () ) { throw new FileNotFoundException ( lr_66 + destDir + lr_67 + createDestDir + lr_68 ) ; }
doCopyDirectory ( srcFile , dstFile , filter , preserveFileDate , exclusionList ) ; } else { doCopyFile ( srcFile , dstFile , preserveFileDate ) ; } } } if ( preserveFileDate ) { destDir . setLastModified ( srcDir . lastModified () ) ; MST[NonVoidMethodCallMutator]MSP[S] } }
final boolean filePresent = file . exists () ; if ( ! file . delete () ) { if ( ! filePresent ) { throw new FileNotFoundException ( lr_48 + file ) ; MST[experimental.NakedReceiverMutator]MSP[N] } final String message = lr_49 + file ; throw new IOException ( message ) ; }
if ( srcLen != dstLen ) { MST[rv.UOI1Mutator]MSP[N] throw new IOException ( lr_34 + srcFile + lr_35 + destFile + lr_36 + srcLen + lr_37 + dstLen ) ; } } public static void copyDirectoryToDirectory ( final File srcDir , final File destDir ) throws IOException {
throw new IOException ( lr_27 + destFile + lr_6 ) ; } final Path srcPath = srcFile . toPath () ; final Path destPath = destFile . toPath () ; final long newLastModifed = preserveFileDate ? srcFile . lastModified () : destFile . lastModified () ; MST[rv.UOI2Mutator]MSP[N]
final URL [] urls = new URL [ files . length ] ; for ( int i = 0 ; i < urls . length ; i ++ ) { MST[ConditionalsBoundaryMutator]MSP[N] urls [ i ] = files [ i ] . toURI () . toURL () ; } return urls ;
final File directory , final IOFileFilter fileFilter , final IOFileFilter dirFilter ) { return innerListFilesOrDirectories ( directory , fileFilter , dirFilter , false ) ; } private static void validateListFilesParameters ( final File directory , final IOFileFilter fileFilter ) { if ( ! directory . isDirectory () ) { MST[rv.ROR4Mutator]MSP[N]
} while ( i < n && url . charAt ( i ) == '%' ); MST[rv.ROR4Mutator]MSP[S] continue; } catch ( final RuntimeException e ) { } finally { if ( bytes . position () > 0 ) { bytes . flip () ;
final FileFilter filter ) throws IOException { copyDirectory ( srcDir , destDir , filter , true ) ; } public static void copyDirectory ( final File srcDir , final File destDir , final FileFilter filter , final boolean preserveFileDate ) throws IOException { checkFileRequirements ( srcDir , destDir ) ; MST[VoidMethodCallMutator]MSP[S]
return byteCountToDisplaySize ( BigInteger . valueOf ( size ) ) ; } public static void touch ( final File file ) throws IOException { if ( ! file . exists () ) { MST[NonVoidMethodCallMutator]MSP[S] openOutputStream ( file ) . close () ; }
return false ; } return file . lastModified () > timeMillis ; MST[InlineConstantMutator]MSP[N] } public static boolean isFileOlder ( final File file , final File reference ) { if ( reference == null ) { throw new IllegalArgumentException ( lr_54 ) ; }
if ( srcDir == null ) { throw new NullPointerException ( lr_38 ) ; } if ( srcDir . exists () && srcDir . isDirectory () == false ) { throw new IllegalArgumentException ( lr_29 + destDir + lr_28 ) ; } if ( destDir == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
if ( file == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] return false ; } try { if ( file . isDirectory () ) { cleanDirectory ( file ) ; } } catch ( final Exception ignored ) { } try { return file . delete () ;
if ( ! destDir . isDirectory () ) { MST[rv.ROR3Mutator]MSP[N] throw new IOException ( lr_27 + destDir + lr_28 ) ; } moveFile ( srcFile , new File ( destDir , srcFile . getName () ) ) ; }
validateMoveParameters ( srcDir , destDir ) ; if ( ! srcDir . isDirectory () ) { throw new IOException ( lr_29 + srcDir + lr_28 ) ; MST[NonVoidMethodCallMutator]MSP[S] } if ( destDir . exists () ) { throw new FileExistsException ( lr_27 + destDir + lr_60 ) ; }
throw new IOException ( lr_23 ) ; } if ( file1 . length () != file2 . length () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return false ; } if ( file1 . getCanonicalFile () . equals ( file2 . getCanonicalFile () ) ) { return true ; }
final Collection < File > files = new java . util . LinkedList <> () ; if ( includeSubDirectories ) { files . add ( directory ) ; } innerListFiles ( files , directory , MST[rv.CRCR2Mutator]MSP[N] FileFilterUtils . or ( effFileFilter , effDirFilter ) , includeSubDirectories ) ; return files ;
throw new IllegalArgumentException ( lr_25 + url ) ; } files [ i ] = toFile ( url ) ; MST[rv.UOI4Mutator]MSP[N] } } return files ; } public static URL [] toURLs ( final File [] files ) throws IOException {
for ( final File srcFile : srcFiles ) { MST[rv.ABSMutator]MSP[N] final File copiedFile = new File ( destDir , srcFile . getName () ) ; exclusionList . add ( copiedFile . getCanonicalPath () ) ; } } } doCopyDirectory ( srcDir , destDir , filter , preserveFileDate , exclusionList ) ;
throw new IOException ( lr_27 + destFile + lr_6 ) ; } final Path srcPath = srcFile . toPath () ; final Path destPath = destFile . toPath () ; final long newLastModifed = preserveFileDate ? srcFile . lastModified () : destFile . lastModified () ; MST[rv.ABSMutator]MSP[N]
validateMoveParameters ( srcDir , destDir ) ; if ( ! srcDir . isDirectory () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] throw new IOException ( lr_29 + srcDir + lr_28 ) ; } if ( destDir . exists () ) { throw new FileExistsException ( lr_27 + destDir + lr_60 ) ; }
final StringBuilder buffer = new StringBuilder () ; final ByteBuffer bytes = ByteBuffer . allocate ( n ) ; for ( int i = 0 ; i < n ; ) { MST[rv.ABSMutator]MSP[N] if ( url . charAt ( i ) == '%' ) { try { do {
for ( final File srcFile : srcFiles ) { final File copiedFile = new File ( destDir , srcFile . getName () ) ; MST[NonVoidMethodCallMutator]MSP[N] exclusionList . add ( copiedFile . getCanonicalPath () ) ; } } } doCopyDirectory ( srcDir , destDir , filter , preserveFileDate , exclusionList ) ;
if ( date == null ) { throw new IllegalArgumentException ( lr_57 ) ; } return isFileOlder ( file , date . getTime () ) ; MST[NonVoidMethodCallMutator]MSP[S] } public static boolean isFileOlder ( final File file , final long timeMillis ) { if ( file == null ) {
final String [] suffixes = new String [ extensions . length ] ; for ( int i = 0 ; i < extensions . length ; i ++ ) { MST[rv.CRCR5Mutator]MSP[N] suffixes [ i ] = lr_22 + extensions [ i ] ; } return suffixes ; }
public static void moveToDirectory ( final File src , final File destDir , final boolean createDestDir ) throws IOException { validateMoveParameters ( src , destDir ) ; if ( src . isDirectory () ) { moveDirectoryToDirectory ( src , destDir , createDestDir ) ; MST[rv.UOI2Mutator]MSP[N] } else {
displaySize = String . valueOf ( size . divide ( ONE_KB_BI ) ) + lr_17 ; MST[experimental.BigIntegerMutator]MSP[N] } else { displaySize = String . valueOf ( size ) + lr_18 ; } return displaySize ; } public static String byteCountToDisplaySize ( final long size ) {
displaySize = String . valueOf ( size . divide ( ONE_GB_BI ) ) + lr_15 ; } else if ( size . divide ( ONE_MB_BI ) . compareTo ( BigInteger . ZERO ) > 0 ) { MST[ArgumentPropagationMutator]MSP[N]
public static BigInteger sizeOfAsBigInteger ( final File file ) { if ( ! file . exists () ) { final String message = file + lr_42 ; throw new IllegalArgumentException ( message ) ; } if ( file . isDirectory () ) { MST[rv.ROR1Mutator]MSP[N] return sizeOfDirectoryBig0 ( file ) ; }
return new File ( filename ) ; } static String decodeUrl ( final String url ) { String decoded = url ; if ( url != null && url . indexOf ( '%' ) >= 0 ) { MST[rv.CRCR6Mutator]MSP[N] final int n = url . length () ;
final String [] suffixes = new String [ extensions . length ] ; for ( int i = 0 ; i < extensions . length ; i ++ ) { MST[rv.UOI4Mutator]MSP[N] suffixes [ i ] = lr_22 + extensions [ i ] ; } return suffixes ; }
displaySize = String . valueOf ( size . divide ( ONE_EB_BI ) ) + lr_12 ; } else if ( size . divide ( ONE_PB_BI ) . compareTo ( BigInteger . ZERO ) > 0 ) { MST[experimental.BigIntegerMutator]MSP[N]
final File directory , final String [] extensions , final boolean recursive ) { return listFiles ( directory , extensions , recursive ) . iterator () ; MST[rv.UOI3Mutator]MSP[S] } public static boolean contentEquals ( final File file1 , final File file2 ) throws IOException {
copyDirectory ( srcDir , new File ( destDir , srcDir . getName () ) , true ) ; MST[ConstructorCallMutator]MSP[N] } public static void copyDirectory ( final File srcDir , final File destDir ) throws IOException { copyDirectory ( srcDir , destDir , true ) ; }
private static void checkDirectory ( final File directory ) { if ( ! directory . exists () ) { throw new IllegalArgumentException ( directory + lr_42 ) ; } if ( ! directory . isDirectory () ) { MST[NegateConditionalsMutator]MSP[N] throw new IllegalArgumentException ( directory + lr_47 ) ; } }
buffer . append ( StandardCharsets . UTF_8 . decode ( bytes ) . toString () ) ; bytes . clear () ; } } } buffer . append ( url . charAt ( i ++ ) ) ; } decoded = buffer . toString () ; } return decoded ; MST[ReturnValsMutator]MSP[N]
try ( OutputStream out = openOutputStream ( file , append ) ) { MST[rv.UOI4Mutator]MSP[N] out . write ( data , off , len ) ; } } public static void writeLines ( final File file , final String encoding , final Collection < ? > lines ) throws IOException {
final boolean file1Exists = file1 . exists () ; if ( file1Exists != file2 . exists () ) { return false ; } if ( ! file1Exists ) { return true ; } if ( file1 . isDirectory () || file2 . isDirectory () ) { MST[NonVoidMethodCallMutator]MSP[N]
if ( ! parentFile . mkdirs () && ! parentFile . isDirectory () ) { MST[rv.ROR2Mutator]MSP[N] throw new IOException ( lr_27 + parentFile + lr_32 ) ; } } if ( destFile . exists () && destFile . canWrite () == false ) {
try ( OutputStream out = openOutputStream ( destination ) ) { IOUtils . copy ( source , out ) ; MST[NonVoidMethodCallMutator]MSP[N] } } public static void copyToDirectory ( final File src , final File destDir ) throws IOException { if ( src == null ) {
} while ( i < n && url . charAt ( i ) == '%' ); MST[rv.ROR1Mutator]MSP[N] continue; } catch ( final RuntimeException e ) { } finally { if ( bytes . position () > 0 ) { bytes . flip () ;
final File [] found = directory . listFiles ( ( FileFilter ) filter ) ; if ( found != null ) { for ( final File file : found ) { if ( file . isDirectory () ) { if ( includeSubDirectories ) { MST[rv.UOI4Mutator]MSP[N]
validateMoveParameters ( srcFile , destDir ) ; if ( ! destDir . exists () && createDestDir ) { destDir . mkdirs () ; } if ( ! destDir . exists () ) { throw new FileNotFoundException ( lr_66 + destDir + MST[experimental.NakedReceiverMutator]MSP[N] lr_67 + createDestDir + lr_68 ) ; }
final File [] srcFiles = filter == null ? srcDir . listFiles () : srcDir . listFiles ( filter ) ; if ( srcFiles != null && srcFiles . length > 0 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[S] exclusionList = new ArrayList <> ( srcFiles . length ) ;
public static boolean isFileNewer ( final File file , final File reference ) { if ( reference == null ) { throw new IllegalArgumentException ( lr_54 ) ; } if ( ! reference . exists () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] throw new IllegalArgumentException ( lr_55 + reference + lr_56 ) ; }
if ( destDir . isDirectory () == false ) { MST[rv.ROR1Mutator]MSP[N] throw new IOException ( lr_27 + destDir + lr_39 ) ; } } else { if ( ! destDir . mkdirs () && ! destDir . isDirectory () ) {
if ( srcLen != dstLen ) { throw new IOException ( lr_34 + srcFile + lr_35 + destFile MST[experimental.NakedReceiverMutator]MSP[S] + lr_36 + srcLen + lr_37 + dstLen ) ; } } public static void copyDirectoryToDirectory ( final File srcDir , final File destDir ) throws IOException {
for ( final File srcFile : srcFiles ) { MST[rv.UOI4Mutator]MSP[N] final File copiedFile = new File ( destDir , srcFile . getName () ) ; exclusionList . add ( copiedFile . getCanonicalPath () ) ; } } } doCopyDirectory ( srcDir , destDir , filter , preserveFileDate , exclusionList ) ;
final Collection < File > files = new java . util . LinkedList <> () ; if ( includeSubDirectories ) { files . add ( directory ) ; } innerListFiles ( files , directory , FileFilterUtils . or ( effFileFilter , effDirFilter ) , includeSubDirectories ) ; MST[rv.UOI3Mutator]MSP[N] return files ;
final File destFile = new File ( destDir , srcFile . getName () ) ; copyFile ( srcFile , destFile , preserveFileDate ) ; } public static void copyFile ( final File srcFile , final File destFile ) throws IOException { copyFile ( srcFile , destFile , true ) ; MST[InlineConstantMutator]MSP[N]
throw new IOException ( lr_29 + srcFile + lr_69 ) ; MST[ConstructorCallMutator]MSP[S] } if ( destFile . exists () ) { throw new FileExistsException ( lr_27 + destFile + lr_60 ) ; } if ( destFile . isDirectory () ) {
final byte octet = ( byte ) Integer . parseInt ( url . substring ( i + 1 , i + 3 ) , 16 ) ; MST[rv.AOR3Mutator]MSP[N] bytes . put ( octet ) ; i += 3 ;
public static void write ( final File file , final CharSequence data , final String encoding ) throws IOException { write ( file , data , encoding , false ) ; MST[rv.CRCR3Mutator]MSP[N] }
} public static void write ( final File file , final CharSequence data , final String encoding , final boolean append ) throws IOException { write ( file , data , Charsets . toCharset ( encoding ) , append ) ; MST[rv.UOI2Mutator]MSP[N] }
if ( destDir . isDirectory () == false ) { throw new IOException ( lr_27 + destDir + lr_39 ) ; MST[NonVoidMethodCallMutator]MSP[S] } } else { if ( ! destDir . mkdirs () && ! destDir . isDirectory () ) {
if ( srcLen != dstLen ) { MST[rv.UOI2Mutator]MSP[N] throw new IOException ( lr_34 + srcFile + lr_35 + destFile + lr_36 + srcLen + lr_37 + dstLen ) ; } } public static void copyDirectoryToDirectory ( final File srcDir , final File destDir ) throws IOException {
final byte octet = ( byte ) Integer . parseInt ( url . substring ( i + 1 , i + 3 ) , 16 ) ; MST[rv.ABSMutator]MSP[N] bytes . put ( octet ) ; i += 3 ;
final File [] srcFiles = filter == null ? srcDir . listFiles () : srcDir . listFiles ( filter ) ; if ( srcFiles != null && srcFiles . length > 0 ) { exclusionList = new ArrayList <> ( srcFiles . length ) ; MST[ConstructorCallMutator]MSP[N]
moveFileToDirectory ( src , destDir , createDestDir ) ; } } private static void validateMoveParameters ( final File src , final File dest ) throws FileNotFoundException { if ( src == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] throw new NullPointerException ( lr_38 ) ; } if ( dest == null ) {
displaySize = String . valueOf ( size . divide ( ONE_TB_BI ) ) + lr_14 ; MST[NonVoidMethodCallMutator]MSP[N] } else if ( size . divide ( ONE_GB_BI ) . compareTo ( BigInteger . ZERO ) > 0 ) {
copyDirectory ( srcDir , new File ( destDir , srcDir . getName () ) , true ) ; } public static void copyDirectory ( final File srcDir , final File destDir ) throws IOException { copyDirectory ( srcDir , destDir , true ) ; MST[rv.CRCR6Mutator]MSP[N] }
for ( int i = 0 ; i < urls . length ; i ++ ) { final URL url = urls [ i ] ; MST[rv.UOI3Mutator]MSP[N] if ( url != null ) { if ( url . getProtocol () . equals ( lr_24 ) == false ) {
final String [] suffixes = toSuffixes ( extensions ) ; filter = new SuffixFileFilter ( suffixes ) ; } return listFiles ( directory , filter , MST[rv.UOI1Mutator]MSP[N] recursive ? TrueFileFilter . INSTANCE : FalseFileFilter . INSTANCE ) ; } public static Iterator < File > iterateFiles (
if ( ! parentFile . mkdirs () && ! parentFile . isDirectory () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] throw new IOException ( lr_27 + parentFile + lr_32 ) ; } } if ( destFile . exists () && destFile . canWrite () == false ) {
Files . copy ( srcPath , destPath , StandardCopyOption . REPLACE_EXISTING ) ; MST[rv.CRCR4Mutator]MSP[N] checkEqualSizes ( srcFile , destFile , Files . size ( srcPath ) , Files . size ( destPath ) ) ;
throws IOException { final boolean file1Exists = file1 . exists () ; if ( file1Exists != file2 . exists () ) { MST[NegateConditionalsMutator]MSP[S] return false ; } if ( ! file1Exists ) { return true ; } if ( file1 . isDirectory () || file2 . isDirectory () ) {
throw new IOException ( lr_29 + srcFile + lr_69 ) ; } if ( destFile . exists () ) { throw new FileExistsException ( lr_27 + destFile + lr_60 ) ; } if ( destFile . isDirectory () ) { MST[NegateConditionalsMutator]MSP[N]
public static boolean isFileNewer ( final File file , final File reference ) { if ( reference == null ) { throw new IllegalArgumentException ( lr_54 ) ; } if ( ! reference . exists () ) { MST[rv.ROR1Mutator]MSP[N] throw new IllegalArgumentException ( lr_55 + reference + lr_56 ) ; }
final String [] suffixes = toSuffixes ( extensions ) ; filter = new SuffixFileFilter ( suffixes ) ; } return listFiles ( directory , filter , MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] recursive ? TrueFileFilter . INSTANCE : FalseFileFilter . INSTANCE ) ; } public static Iterator < File > iterateFiles (
while ( ! file . exists () ) { final long remaining = finishAt - System . currentTimeMillis () ; if ( remaining < 0 ) { return false ; MST[rv.CRCR3Mutator]MSP[N] } try { Thread . sleep ( Math . min ( 100 , remaining ) ) ;
final boolean rename = srcDir . renameTo ( destDir ) ; if ( ! rename ) { MST[rv.ROR1Mutator]MSP[N] if ( destDir . getCanonicalPath () . startsWith ( srcDir . getCanonicalPath () + File . separator ) ) { throw new IOException ( lr_61 + srcDir + lr_62 + destDir ) ;
return isFileNewer ( file , reference . lastModified () ) ; } public static boolean isFileNewer ( final File file , final Date date ) { if ( date == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] throw new IllegalArgumentException ( lr_57 ) ; }
final File [] found = directory . listFiles ( ( FileFilter ) filter ) ; if ( found != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] for ( final File file : found ) { if ( file . isDirectory () ) { if ( includeSubDirectories ) {
return lineIterator ( file , null ) ; } public static void writeStringToFile ( final File file , final String data , final Charset encoding ) throws IOException { writeStringToFile ( file , data , encoding , false ) ; MST[rv.CRCR3Mutator]MSP[N] }
try ( OutputStream out = openOutputStream ( file , append ) ) { out . write ( data , off , len ) ; MST[rv.UOI2Mutator]MSP[N] } } public static void writeLines ( final File file , final String encoding , final Collection < ? > lines ) throws IOException {
validateMoveParameters ( srcFile , destDir ) ; if ( ! destDir . exists () && createDestDir ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] destDir . mkdirs () ; } if ( ! destDir . exists () ) { throw new FileNotFoundException ( lr_66 + destDir + lr_67 + createDestDir + lr_68 ) ; }
throws IOException { final File [] srcFiles = filter == null ? srcDir . listFiles () : srcDir . listFiles ( filter ) ; if ( srcFiles == null ) { throw new IOException ( lr_40 + srcDir ) ; } if ( destDir . exists () ) { MST[rv.ROR5Mutator]MSP[N]
throw new IOException ( lr_27 + destFile + lr_33 ) ; } doCopyFile ( srcFile , destFile , preserveFileDate ) ; MST[rv.UOI1Mutator]MSP[N] } public static long copyFile ( final File input , final OutputStream output ) throws IOException { try ( FileInputStream fis = new FileInputStream ( input ) ) {
public static BigInteger sizeOfAsBigInteger ( final File file ) { if ( ! file . exists () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] final String message = file + lr_42 ; throw new IllegalArgumentException ( message ) ; } if ( file . isDirectory () ) { return sizeOfDirectoryBig0 ( file ) ; }
if ( ! directory . isDirectory () ) { final String message = directory + lr_47 ; MST[ConstructorCallMutator]MSP[S] throw new IllegalArgumentException ( message ) ; } final File [] files = directory . listFiles () ; if ( files == null ) {
throw new NullPointerException ( lr_26 ) ; } if ( destDir . exists () && destDir . isDirectory () == false ) { MST[rv.ROR3Mutator]MSP[S] throw new IllegalArgumentException ( lr_27 + destDir + lr_28 ) ; }
if ( ! directory . exists () ) { MST[rv.ROR2Mutator]MSP[N] return; } directory . deleteOnExit () ; if ( ! isSymlink ( directory ) ) { cleanDirectoryOnExit ( directory ) ; } } private static void cleanDirectoryOnExit ( final File directory ) throws IOException {
public static BigInteger sizeOfAsBigInteger ( final File file ) { if ( ! file . exists () ) { final String message = file + lr_42 ; throw new IllegalArgumentException ( message ) ; } if ( file . isDirectory () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return sizeOfDirectoryBig0 ( file ) ; }
throws IOException { final boolean file1Exists = file1 . exists () ; if ( file1Exists != file2 . exists () ) { return false ; } if ( ! file1Exists ) { return true ; MST[rv.CRCR2Mutator]MSP[S] } if ( file1 . isDirectory () || file2 . isDirectory () ) {
final StringBuilder buffer = new StringBuilder () ; final ByteBuffer bytes = ByteBuffer . allocate ( n ) ; for ( int i = 0 ; i < n ; ) { MST[rv.CRCR3Mutator]MSP[N] if ( url . charAt ( i ) == '%' ) { try { do {
final File [] found = directory . listFiles ( ( FileFilter ) filter ) ; if ( found != null ) { for ( final File file : found ) { MST[rv.UOI1Mutator]MSP[N] if ( file . isDirectory () ) { if ( includeSubDirectories ) {
for ( int i = 0 ; i < urls . length ; i ++ ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] final URL url = urls [ i ] ; if ( url != null ) { if ( url . getProtocol () . equals ( lr_24 ) == false ) {
public static File getUserDirectory () { return new File ( getUserDirectoryPath () ) ; } public static FileInputStream openInputStream ( final File file ) throws IOException { if ( file . exists () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] if ( file . isDirectory () ) {
throws IOException { final File [] srcFiles = filter == null ? srcDir . listFiles () : srcDir . listFiles ( filter ) ; MST[NegateConditionalsMutator]MSP[S] if ( srcFiles == null ) { throw new IOException ( lr_40 + srcDir ) ; } if ( destDir . exists () ) {
throw new IllegalArgumentException ( lr_58 ) ; } if ( ! file . exists () ) { return false ; } return file . lastModified () < timeMillis ; MST[NonVoidMethodCallMutator]MSP[S] } public static long checksumCRC32 ( final File file ) throws IOException { final CRC32 crc = new CRC32 () ;
while ( ! file . exists () ) { final long remaining = finishAt - System . currentTimeMillis () ; if ( remaining < 0 ) { return false ; MST[BooleanTrueReturnValsMutator]MSP[N] } try { Thread . sleep ( Math . min ( 100 , remaining ) ) ;
final File [] found = directory . listFiles ( ( FileFilter ) filter ) ; if ( found != null ) { for ( final File file : found ) { if ( file . isDirectory () ) { if ( includeSubDirectories ) { MST[NegateConditionalsMutator]MSP[N]
final boolean rename = srcDir . renameTo ( destDir ) ; if ( ! rename ) { if ( destDir . getCanonicalPath () . startsWith ( srcDir . getCanonicalPath () + File . separator ) ) { throw new IOException ( lr_61 + srcDir + lr_62 + destDir ) ; MST[NonVoidMethodCallMutator]MSP[S]
if ( ! srcDir . isDirectory () ) { throw new IOException ( lr_29 + srcDir + lr_39 ) ; MST[experimental.NakedReceiverMutator]MSP[N] } if ( srcDir . getCanonicalPath () . equals ( destDir . getCanonicalPath () ) ) {
while ( ! file . exists () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] final long remaining = finishAt - System . currentTimeMillis () ; if ( remaining < 0 ) { return false ; } try { Thread . sleep ( Math . min ( 100 , remaining ) ) ;
throw new IllegalArgumentException ( lr_58 ) ; } if ( ! file . exists () ) { return false ; } return file . lastModified () < timeMillis ; MST[rv.ROR4Mutator]MSP[S] } public static long checksumCRC32 ( final File file ) throws IOException { final CRC32 crc = new CRC32 () ;
final byte octet = ( byte ) Integer . parseInt ( url . substring ( i + 1 , i + 3 ) , 16 ) ; MST[experimental.NakedReceiverMutator]MSP[N] bytes . put ( octet ) ; i += 3 ;
copyDirectory ( srcDir , new File ( destDir , srcDir . getName () ) , true ) ; MST[VoidMethodCallMutator]MSP[N] } public static void copyDirectory ( final File srcDir , final File destDir ) throws IOException { copyDirectory ( srcDir , destDir , true ) ; }
} while ( i < n && url . charAt ( i ) == '%' ); MST[RemoveConditionalMutator_ORDER_IF]MSP[N] continue; } catch ( final RuntimeException e ) { } finally { if ( bytes . position () > 0 ) { bytes . flip () ;
public static BigInteger sizeOfAsBigInteger ( final File file ) { if ( ! file . exists () ) { final String message = file + lr_42 ; throw new IllegalArgumentException ( message ) ; } if ( file . isDirectory () ) { return sizeOfDirectoryBig0 ( file ) ; MST[NullReturnValsMutator]MSP[N] }
FileUtils . deleteQuietly ( destFile ) ; throw new IOException ( lr_70 + srcFile + MST[experimental.NakedReceiverMutator]MSP[N] lr_64 + destFile + lr_65 ) ; } } } public static void moveFileToDirectory ( final File srcFile , final File destDir , final boolean createDestDir ) throws IOException {
final String canonicalParent = directory . getCanonicalPath () ; final String canonicalChild = child . getCanonicalPath () ; return FilenameUtils . directoryContains ( canonicalParent , canonicalChild ) ; MST[NonVoidMethodCallMutator]MSP[S] } public static void cleanDirectory ( final File directory ) throws IOException {
FileUtils . deleteQuietly ( destFile ) ; throw new IOException ( lr_70 + srcFile + MST[NonVoidMethodCallMutator]MSP[S] lr_64 + destFile + lr_65 ) ; } } } public static void moveFileToDirectory ( final File srcFile , final File destDir , final boolean createDestDir ) throws IOException {
return FileFilterUtils . and ( fileFilter , FileFilterUtils . notFileFilter ( DirectoryFileFilter . INSTANCE ) ) ; MST[rv.CRCR3Mutator]MSP[N] } private static IOFileFilter setUpEffectiveDirFilter ( final IOFileFilter dirFilter ) { return dirFilter == null ? FalseFileFilter . INSTANCE : FileFilterUtils . and ( dirFilter , DirectoryFileFilter . INSTANCE ) ; }
} while ( i < n && url . charAt ( i ) == '%' ); continue; } catch ( final RuntimeException e ) { } finally { if ( bytes . position () > 0 ) { MST[rv.ROR5Mutator]MSP[N] bytes . flip () ;
while ( ! file . exists () ) { MST[rv.ROR5Mutator]MSP[N] final long remaining = finishAt - System . currentTimeMillis () ; if ( remaining < 0 ) { return false ; } try { Thread . sleep ( Math . min ( 100 , remaining ) ) ;
} } public static void forceDeleteOnExit ( final File file ) throws IOException { if ( file . isDirectory () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] deleteDirectoryOnExit ( file ) ; } else { file . deleteOnExit () ; } } private static void deleteDirectoryOnExit ( final File directory ) throws IOException {
: new InputStreamReader ( new FileInputStream ( file2 ) , charsetName ) ) { return IOUtils . contentEqualsIgnoreEOL ( input1 , input2 ) ; MST[rv.UOI3Mutator]MSP[S] } } public static File toFile ( final URL url ) {
if ( destDir == null ) { throw new NullPointerException ( lr_26 ) ; } if ( destDir . exists () && destDir . isDirectory () == false ) { MST[rv.ROR4Mutator]MSP[N] throw new IllegalArgumentException ( lr_27 + destDir + lr_28 ) ; }
if ( date == null ) { MST[NegateConditionalsMutator]MSP[S] throw new IllegalArgumentException ( lr_57 ) ; } return isFileOlder ( file , date . getTime () ) ; } public static boolean isFileOlder ( final File file , final long timeMillis ) { if ( file == null ) {
if ( file . exists () ) { if ( file . isDirectory () ) { throw new IOException ( lr_5 + file + lr_6 ) ; } if ( file . canWrite () == false ) { MST[rv.ROR1Mutator]MSP[N] throw new IOException ( lr_5 + file + lr_9 ) ; }
final boolean file1Exists = file1 . exists () ; if ( file1Exists != file2 . exists () ) { return false ; } if ( ! file1Exists ) { MST[rv.ABSMutator]MSP[N] return true ; } if ( file1 . isDirectory () || file2 . isDirectory () ) {
throw new IOException ( lr_40 + directory ) ; MST[experimental.NakedReceiverMutator]MSP[S] } return files ; } public static boolean waitFor ( final File file , final int seconds ) { final long finishAt = System . currentTimeMillis () + ( seconds * 1000L ) ; boolean wasInterrupted = false ; try {
throw new IOException ( lr_40 + directory ) ; MST[NonVoidMethodCallMutator]MSP[S] } return files ; } public static boolean waitFor ( final File file , final int seconds ) { final long finishAt = System . currentTimeMillis () + ( seconds * 1000L ) ; boolean wasInterrupted = false ; try {
if ( ! src . exists () ) { MST[NonVoidMethodCallMutator]MSP[N] throw new FileNotFoundException ( lr_29 + src + lr_8 ) ; } } private static void doCopyDirectory ( final File srcDir , final File destDir , final FileFilter filter , final boolean preserveFileDate , final List < String > exclusionList )
final URL [] urls = new URL [ files . length ] ; for ( int i = 0 ; i < urls . length ; i ++ ) { urls [ i ] = files [ i ] . toURI () . toURL () ; MST[rv.UOI4Mutator]MSP[S] } return urls ;
displaySize = String . valueOf ( size . divide ( ONE_EB_BI ) ) + lr_12 ; } else if ( size . divide ( ONE_PB_BI ) . compareTo ( BigInteger . ZERO ) > 0 ) { MST[NonVoidMethodCallMutator]MSP[N]
final File [] files = directory . listFiles () ; if ( files == null ) { return 0L ; } long size = 0 ; for ( final File file : files ) { if ( ! isSymlink ( file ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
throw new NullPointerException ( lr_26 ) ; } if ( ! src . exists () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] throw new FileNotFoundException ( lr_29 + src + lr_8 ) ; } } public static boolean isSymlink ( final File file ) { if ( file == null ) {
doCopyDirectory ( srcFile , dstFile , filter , preserveFileDate , exclusionList ) ; } else { doCopyFile ( srcFile , dstFile , preserveFileDate ) ; MST[VoidMethodCallMutator]MSP[N] } } } if ( preserveFileDate ) { destDir . setLastModified ( srcDir . lastModified () ) ; } }
} copyDirectory ( srcDir , destDir ) ; deleteDirectory ( srcDir ) ; if ( srcDir . exists () ) { MST[rv.ROR4Mutator]MSP[N] throw new IOException ( lr_63 + srcDir + lr_64 + destDir + lr_65 ) ; } } }
displaySize = String . valueOf ( size . divide ( ONE_MB_BI ) ) + lr_16 ; } else if ( size . divide ( ONE_KB_BI ) . compareTo ( BigInteger . ZERO ) > 0 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N]
final URL [] urls = new URL [ files . length ] ; for ( int i = 0 ; i < urls . length ; i ++ ) { MST[rv.CRCR5Mutator]MSP[S] urls [ i ] = files [ i ] . toURI () . toURL () ; } return urls ;
Files . copy ( srcPath , destPath , StandardCopyOption . REPLACE_EXISTING ) ; MST[InlineConstantMutator]MSP[N] checkEqualSizes ( srcFile , destFile , Files . size ( srcPath ) , Files . size ( destPath ) ) ;
if ( destDir == null ) { throw new NullPointerException ( lr_26 ) ; } if ( destDir . exists () && destDir . isDirectory () == false ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] throw new IllegalArgumentException ( lr_27 + destDir + lr_28 ) ; }
throw new IOException ( lr_40 + directory ) ; } return files ; } public static boolean waitFor ( final File file , final int seconds ) { final long finishAt = System . currentTimeMillis () + ( seconds * 1000L ) ; MST[rv.AOR2Mutator]MSP[N] boolean wasInterrupted = false ; try {
if ( date == null ) { throw new IllegalArgumentException ( lr_57 ) ; } return isFileOlder ( file , date . getTime () ) ; MST[BooleanTrueReturnValsMutator]MSP[S] } public static boolean isFileOlder ( final File file , final long timeMillis ) { if ( file == null ) {
} public static Iterator < File > iterateFiles ( final File directory , final IOFileFilter fileFilter , final IOFileFilter dirFilter ) { return listFiles ( directory , fileFilter , dirFilter ) . iterator () ; MST[NonVoidMethodCallMutator]MSP[S] }
} while ( i < n && url . charAt ( i ) == '%' ); continue; } catch ( final RuntimeException e ) { } finally { if ( bytes . position () > 0 ) { MST[NegateConditionalsMutator]MSP[N] bytes . flip () ;
if ( url == null || ! lr_24 . equalsIgnoreCase ( url . getProtocol () ) ) { MST[NonVoidMethodCallMutator]MSP[N] return null ; } String filename = url . getFile () . replace ( '/' , File . separatorChar ) ; filename = decodeUrl ( filename ) ;
throw new IOException ( lr_23 ) ; } if ( file1 . getCanonicalFile () . equals ( file2 . getCanonicalFile () ) ) { return true ; MST[rv.CRCR5Mutator]MSP[S] } try ( Reader input1 = charsetName == null
return new File ( filename ) ; } static String decodeUrl ( final String url ) { String decoded = url ; if ( url != null && url . indexOf ( '%' ) >= 0 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] final int n = url . length () ;
final boolean rename = srcDir . renameTo ( destDir ) ; if ( ! rename ) { if ( destDir . getCanonicalPath () . startsWith ( srcDir . getCanonicalPath () + File . separator ) ) { throw new IOException ( lr_61 + srcDir + lr_62 + destDir ) ; MST[experimental.NakedReceiverMutator]MSP[N]
throw new IOException ( lr_29 + srcFile + lr_69 ) ; } if ( destFile . exists () ) { throw new FileExistsException ( lr_27 + destFile + lr_60 ) ; MST[NonVoidMethodCallMutator]MSP[S] } if ( destFile . isDirectory () ) {
throw new IOException ( lr_27 + destFile + lr_69 ) ; } final boolean rename = srcFile . renameTo ( destFile ) ; if ( ! rename ) { copyFile ( srcFile , destFile ) ; if ( ! srcFile . delete () ) { MST[rv.ROR2Mutator]MSP[N]
throws IOException { final File [] srcFiles = filter == null ? srcDir . listFiles () : srcDir . listFiles ( filter ) ; if ( srcFiles == null ) { throw new IOException ( lr_40 + srcDir ) ; } if ( destDir . exists () ) { MST[NegateConditionalsMutator]MSP[N]
if ( null != exception ) { throw exception ; } } public static void forceMkdir ( final File directory ) throws IOException { if ( directory . exists () ) { if ( ! directory . isDirectory () ) { MST[rv.ROR2Mutator]MSP[N] final String message = lr_50 + directory + lr_51
for ( final File srcFile : srcFiles ) { MST[rv.UOI1Mutator]MSP[N] final File copiedFile = new File ( destDir , srcFile . getName () ) ; exclusionList . add ( copiedFile . getCanonicalPath () ) ; } } } doCopyDirectory ( srcDir , destDir , filter , preserveFileDate , exclusionList ) ;
return fileLength > 0 ? IOUtils . toByteArray ( in , fileLength ) : IOUtils . toByteArray ( in ) ; MST[rv.ABSMutator]MSP[S] } } public static List < String > readLines ( final File file , final Charset encoding ) throws IOException {
return new FileInputStream ( file ) ; MST[ConstructorCallMutator]MSP[N] } public static FileOutputStream openOutputStream ( final File file ) throws IOException { return openOutputStream ( file , false ) ; } public static FileOutputStream openOutputStream ( final File file , final boolean append ) throws IOException {
final StringBuilder buffer = new StringBuilder () ; final ByteBuffer bytes = ByteBuffer . allocate ( n ) ; for ( int i = 0 ; i < n ; ) { MST[rv.ROR2Mutator]MSP[N] if ( url . charAt ( i ) == '%' ) { try { do {
checksum ( file , crc ) ; return crc . getValue () ; } public static Checksum checksum ( final File file , final Checksum checksum ) throws IOException { if ( file . isDirectory () ) { MST[NonVoidMethodCallMutator]MSP[S] throw new IllegalArgumentException ( lr_59 ) ; }
public static void writeLines ( final File file , final String encoding , final Collection < ? > lines , final String lineEnding ) throws IOException { writeLines ( file , encoding , lines , lineEnding , false ) ; MST[VoidMethodCallMutator]MSP[S] }
throws IOException { final boolean file1Exists = file1 . exists () ; if ( file1Exists != file2 . exists () ) { return false ; } if ( ! file1Exists ) { return true ; } if ( file1 . isDirectory () || file2 . isDirectory () ) { MST[rv.ROR4Mutator]MSP[S]
if ( ! directory . isDirectory () ) { throw new IllegalArgumentException ( lr_46 + directory ) ; } if ( child == null ) { return false ; } if ( ! directory . exists () || ! child . exists () ) { MST[rv.ROR2Mutator]MSP[N] return false ; }
if ( files == null ) { return BigInteger . ZERO ; } BigInteger size = BigInteger . ZERO ; for ( final File file : files ) { MST[rv.UOI4Mutator]MSP[N] if ( ! isSymlink ( file ) ) { size = size . add ( sizeOfBig0 ( file ) ) ;
size += sizeOf0 ( file ) ; MST[rv.UOI2Mutator]MSP[N] if ( size < 0 ) { break; } } } return size ; } private static long sizeOf0 ( final File file ) { if ( file . isDirectory () ) { return sizeOfDirectory0 ( file ) ; }
if ( ! destDir . exists () ) { throw new FileNotFoundException ( lr_66 + destDir + MST[rv.UOI1Mutator]MSP[N] lr_67 + createDestDir + lr_68 ) ; } if ( ! destDir . isDirectory () ) { throw new IOException ( lr_27 + destDir + lr_28 ) ; }
if ( null != exception ) { throw exception ; } } public static void forceMkdir ( final File directory ) throws IOException { if ( directory . exists () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] if ( ! directory . isDirectory () ) { final String message = lr_50 + directory + lr_51
final String [] suffixes = new String [ extensions . length ] ; for ( int i = 0 ; i < extensions . length ; i ++ ) { MST[rv.ROR4Mutator]MSP[N] suffixes [ i ] = lr_22 + extensions [ i ] ; } return suffixes ; }
if ( ! directory . isDirectory () ) { throw new IllegalArgumentException ( lr_46 + directory ) ; } if ( child == null ) { return false ; } if ( ! directory . exists () || ! child . exists () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] return false ; }
} public static void copyFileToDirectory ( final File srcFile , final File destDir ) throws IOException { copyFileToDirectory ( srcFile , destDir , true ) ; MST[rv.CRCR2Mutator]MSP[N] } public static void copyFileToDirectory ( final File srcFile , final File destDir , final boolean preserveFileDate ) throws IOException {
throws IOException { final File [] srcFiles = filter == null ? srcDir . listFiles () : srcDir . listFiles ( filter ) ; MST[rv.ROR5Mutator]MSP[S] if ( srcFiles == null ) { throw new IOException ( lr_40 + srcDir ) ; } if ( destDir . exists () ) {
final boolean file1Exists = file1 . exists () ; if ( file1Exists != file2 . exists () ) { return false ; } if ( ! file1Exists ) { return true ; } if ( file1 . isDirectory () || file2 . isDirectory () ) { MST[rv.ROR2Mutator]MSP[N]
private static void checkDirectory ( final File directory ) { if ( ! directory . exists () ) { throw new IllegalArgumentException ( directory + lr_42 ) ; MST[NonVoidMethodCallMutator]MSP[N] } if ( ! directory . isDirectory () ) { throw new IllegalArgumentException ( directory + lr_47 ) ; } }
return FileFilterUtils . and ( fileFilter , FileFilterUtils . notFileFilter ( DirectoryFileFilter . INSTANCE ) ) ; MST[ReturnValsMutator]MSP[N] } private static IOFileFilter setUpEffectiveDirFilter ( final IOFileFilter dirFilter ) { return dirFilter == null ? FalseFileFilter . INSTANCE : FileFilterUtils . and ( dirFilter , DirectoryFileFilter . INSTANCE ) ; }
throw new IOException ( lr_41 + src + lr_42 ) ; MST[experimental.NakedReceiverMutator]MSP[N] } } public static void copyToDirectory ( final Iterable < File > srcs , final File destDir ) throws IOException { if ( srcs == null ) { throw new NullPointerException ( lr_43 ) ; }
return isFileNewer ( file , date . getTime () ) ; MST[ReturnValsMutator]MSP[N] } public static boolean isFileNewer ( final File file , final long timeMillis ) { if ( file == null ) { throw new IllegalArgumentException ( lr_58 ) ; } if ( ! file . exists () ) {
throw new NullPointerException ( lr_26 ) ; } if ( destDir . exists () && destDir . isDirectory () == false ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] throw new IllegalArgumentException ( lr_27 + destDir + lr_28 ) ; }
final Collection < File > files = new java . util . LinkedList <> () ; if ( includeSubDirectories ) { MST[rv.UOI4Mutator]MSP[N] files . add ( directory ) ; } innerListFiles ( files , directory , FileFilterUtils . or ( effFileFilter , effDirFilter ) , includeSubDirectories ) ; return files ;
} catch ( final Exception ignored ) { return false ; MST[rv.CRCR5Mutator]MSP[S] } } public static boolean directoryContains ( final File directory , final File child ) throws IOException { if ( directory == null ) { throw new IllegalArgumentException ( lr_45 ) ; }
throws IOException { final boolean file1Exists = file1 . exists () ; if ( file1Exists != file2 . exists () ) { return false ; } if ( ! file1Exists ) { return true ; MST[InlineConstantMutator]MSP[S] } if ( file1 . isDirectory () || file2 . isDirectory () ) {
if ( file . exists () ) { if ( file . isDirectory () ) { throw new IOException ( lr_5 + file + lr_6 ) ; MST[NonVoidMethodCallMutator]MSP[S] } if ( file . canWrite () == false ) { throw new IOException ( lr_5 + file + lr_9 ) ; }
displaySize = String . valueOf ( size . divide ( ONE_GB_BI ) ) + lr_15 ; } else if ( size . divide ( ONE_MB_BI ) . compareTo ( BigInteger . ZERO ) > 0 ) { MST[rv.ROR1Mutator]MSP[N]
final StringBuilder buffer = new StringBuilder () ; final ByteBuffer bytes = ByteBuffer . allocate ( n ) ; for ( int i = 0 ; i < n ; ) { MST[rv.UOI2Mutator]MSP[N] if ( url . charAt ( i ) == '%' ) { try { do {
public static File getUserDirectory () { return new File ( getUserDirectoryPath () ) ; } public static FileInputStream openInputStream ( final File file ) throws IOException { if ( file . exists () ) { if ( file . isDirectory () ) { MST[rv.ROR1Mutator]MSP[N]
final Collection < File > files = new java . util . LinkedList <> () ; if ( includeSubDirectories ) { MST[NegateConditionalsMutator]MSP[N] files . add ( directory ) ; } innerListFiles ( files , directory , FileFilterUtils . or ( effFileFilter , effDirFilter ) , includeSubDirectories ) ; return files ;
displaySize = String . valueOf ( size . divide ( ONE_KB_BI ) ) + lr_17 ; } else { displaySize = String . valueOf ( size ) + lr_18 ; MST[NonVoidMethodCallMutator]MSP[N] } return displaySize ; } public static String byteCountToDisplaySize ( final long size ) {
public static void moveDirectoryToDirectory ( final File src , final File destDir , final boolean createDestDir ) throws IOException { validateMoveParameters ( src , destDir ) ; if ( ! destDir . exists () && createDestDir ) { MST[rv.ABSMutator]MSP[N] destDir . mkdirs () ; }
if ( file . exists () ) { if ( file . isDirectory () ) { throw new IOException ( lr_5 + file + lr_6 ) ; MST[experimental.NakedReceiverMutator]MSP[N] } if ( file . canWrite () == false ) { throw new IOException ( lr_5 + file + lr_9 ) ; }
final File [] found = directory . listFiles ( ( FileFilter ) filter ) ; if ( found != null ) { for ( final File file : found ) { if ( file . isDirectory () ) { if ( includeSubDirectories ) { MST[rv.ROR5Mutator]MSP[N]
if ( srcLen != dstLen ) { throw new IOException ( lr_34 + srcFile + lr_35 + destFile MST[NonVoidMethodCallMutator]MSP[S] + lr_36 + srcLen + lr_37 + dstLen ) ; } } public static void copyDirectoryToDirectory ( final File srcDir , final File destDir ) throws IOException {
final boolean file1Exists = file1 . exists () ; if ( file1Exists != file2 . exists () ) { return false ; } if ( ! file1Exists ) { MST[rv.UOI2Mutator]MSP[N] return true ; } if ( file1 . isDirectory () || file2 . isDirectory () ) {
if ( file . exists () ) { MST[rv.ROR2Mutator]MSP[N] if ( file . isDirectory () ) { throw new IOException ( lr_5 + file + lr_6 ) ; } if ( file . canWrite () == false ) { throw new IOException ( lr_5 + file + lr_9 ) ; }
if ( file . exists () ) { MST[NonVoidMethodCallMutator]MSP[N] if ( file . isDirectory () ) { throw new IOException ( lr_5 + file + lr_6 ) ; } if ( file . canWrite () == false ) { throw new IOException ( lr_5 + file + lr_9 ) ; }
Files . copy ( srcPath , destPath , StandardCopyOption . REPLACE_EXISTING ) ; MST[rv.CRCR1Mutator]MSP[N] checkEqualSizes ( srcFile , destFile , Files . size ( srcPath ) , Files . size ( destPath ) ) ;
if ( ! destDir . exists () ) { throw new FileNotFoundException ( lr_66 + destDir + MST[NonVoidMethodCallMutator]MSP[S] lr_67 + createDestDir + lr_68 ) ; } if ( ! destDir . isDirectory () ) { throw new IOException ( lr_27 + destDir + lr_28 ) ; }
for ( final File src : srcs ) { copyFileToDirectory ( src , destDir ) ; } } public static void deleteDirectory ( final File directory ) throws IOException { if ( ! directory . exists () ) { MST[rv.ROR3Mutator]MSP[S] return; } if ( ! isSymlink ( directory ) ) {
} catch ( final InterruptedException ignore ) { wasInterrupted = true ; } catch ( final Exception ex ) { break; } } } finally { if ( wasInterrupted ) { MST[rv.UOI3Mutator]MSP[N] Thread . currentThread () . interrupt () ; } } return true ; }
if ( ! directory . exists () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] return; } directory . deleteOnExit () ; if ( ! isSymlink ( directory ) ) { cleanDirectoryOnExit ( directory ) ; } } private static void cleanDirectoryOnExit ( final File directory ) throws IOException {
return IOUtils . copyLarge ( fis , output ) ; } } private static void doCopyFile ( final File srcFile , final File destFile , final boolean preserveFileDate ) throws IOException { if ( destFile . exists () && destFile . isDirectory () ) { MST[rv.ROR3Mutator]MSP[N]
throw new NullPointerException ( lr_38 ) ; } if ( src . isFile () ) { copyFileToDirectory ( src , destDir ) ; } else if ( src . isDirectory () ) { MST[rv.ROR4Mutator]MSP[S] copyDirectoryToDirectory ( src , destDir ) ; } else {
final boolean rename = srcDir . renameTo ( destDir ) ; if ( ! rename ) { if ( destDir . getCanonicalPath () . startsWith ( srcDir . getCanonicalPath () + File . separator ) ) { MST[rv.ROR3Mutator]MSP[N] throw new IOException ( lr_61 + srcDir + lr_62 + destDir ) ;
displaySize = String . valueOf ( size . divide ( ONE_KB_BI ) ) + lr_17 ; MST[NonVoidMethodCallMutator]MSP[N] } else { displaySize = String . valueOf ( size ) + lr_18 ; } return displaySize ; } public static String byteCountToDisplaySize ( final long size ) {
} while ( i < n && url . charAt ( i ) == '%' ); MST[rv.UOI4Mutator]MSP[N] continue; } catch ( final RuntimeException e ) { } finally { if ( bytes . position () > 0 ) { bytes . flip () ;
doCopyDirectory ( srcFile , dstFile , filter , preserveFileDate , exclusionList ) ; } else { doCopyFile ( srcFile , dstFile , preserveFileDate ) ; } } } if ( preserveFileDate ) { MST[rv.ROR4Mutator]MSP[S] destDir . setLastModified ( srcDir . lastModified () ) ; } }
buffer . append ( StandardCharsets . UTF_8 . decode ( bytes ) . toString () ) ; MST[NonVoidMethodCallMutator]MSP[S] bytes . clear () ; } } } buffer . append ( url . charAt ( i ++ ) ) ; } decoded = buffer . toString () ; } return decoded ;
displaySize = String . valueOf ( size . divide ( ONE_TB_BI ) ) + lr_14 ; } else if ( size . divide ( ONE_GB_BI ) . compareTo ( BigInteger . ZERO ) > 0 ) { MST[ArgumentPropagationMutator]MSP[N]
while ( ! file . exists () ) { final long remaining = finishAt - System . currentTimeMillis () ; if ( remaining < 0 ) { return false ; MST[rv.ABSMutator]MSP[N] } try { Thread . sleep ( Math . min ( 100 , remaining ) ) ;
} public static File [] toFiles ( final URL [] urls ) { if ( urls == null || urls . length == 0 ) { return EMPTY_FILE_ARRAY ; MST[ReturnValsMutator]MSP[N] } final File [] files = new File [ urls . length ] ;
final StringBuilder buffer = new StringBuilder () ; final ByteBuffer bytes = ByteBuffer . allocate ( n ) ; MST[rv.UOI2Mutator]MSP[N] for ( int i = 0 ; i < n ; ) { if ( url . charAt ( i ) == '%' ) { try { do {
throw new IOException ( lr_23 ) ; } if ( file1 . length () != file2 . length () ) { return false ; MST[rv.CRCR3Mutator]MSP[N] } if ( file1 . getCanonicalFile () . equals ( file2 . getCanonicalFile () ) ) { return true ; }
public static void moveDirectoryToDirectory ( final File src , final File destDir , final boolean createDestDir ) throws IOException { validateMoveParameters ( src , destDir ) ; if ( ! destDir . exists () && createDestDir ) { MST[rv.UOI1Mutator]MSP[N] destDir . mkdirs () ; }
if ( ! destDir . exists () ) { throw new FileNotFoundException ( lr_66 + destDir + MST[NonVoidMethodCallMutator]MSP[N] lr_67 + createDestDir + lr_68 ) ; } if ( ! destDir . isDirectory () ) { throw new IOException ( lr_27 + destDir + lr_28 ) ; }
if ( file . exists () ) { if ( file . isDirectory () ) { MST[NegateConditionalsMutator]MSP[N] throw new IOException ( lr_5 + file + lr_6 ) ; } if ( file . canWrite () == false ) { throw new IOException ( lr_5 + file + lr_9 ) ; }
} public static File [] toFiles ( final URL [] urls ) { if ( urls == null || urls . length == 0 ) { MST[NegateConditionalsMutator]MSP[N] return EMPTY_FILE_ARRAY ; } final File [] files = new File [ urls . length ] ;
return FileFilterUtils . and ( fileFilter , FileFilterUtils . notFileFilter ( DirectoryFileFilter . INSTANCE ) ) ; } private static IOFileFilter setUpEffectiveDirFilter ( final IOFileFilter dirFilter ) { return dirFilter == null ? FalseFileFilter . INSTANCE : FileFilterUtils . and ( dirFilter , MST[rv.CRCR6Mutator]MSP[N] DirectoryFileFilter . INSTANCE ) ; }
final File [] files = verifiedListFiles ( directory ) ; IOException exception = null ; for ( final File file : files ) { MST[rv.UOI2Mutator]MSP[N] try { forceDelete ( file ) ; } catch ( final IOException ioe ) { exception = ioe ; } }
if ( files == null ) { return BigInteger . ZERO ; } BigInteger size = BigInteger . ZERO ; for ( final File file : files ) { MST[rv.UOI3Mutator]MSP[N] if ( ! isSymlink ( file ) ) { size = size . add ( sizeOfBig0 ( file ) ) ;
for ( int i = 0 ; i < urls . length ; i ++ ) { final URL url = urls [ i ] ; if ( url != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] if ( url . getProtocol () . equals ( lr_24 ) == false ) {
final boolean append ) throws IOException { writeStringToFile ( file , data , Charsets . toCharset ( encoding ) , append ) ; MST[rv.ABSMutator]MSP[N] } @Deprecated public static void writeStringToFile ( final File file , final String data ) throws IOException {
if ( ! file . exists () ) { MST[rv.ROR1Mutator]MSP[N] final String message = file + lr_42 ; throw new IllegalArgumentException ( message ) ; } if ( file . isDirectory () ) { return sizeOfDirectory0 ( file ) ; } return file . length () ; }
throw new NullPointerException ( lr_71 ) ; } return Files . isSymbolicLink ( file . toPath () ) ; MST[NonVoidMethodCallMutator]MSP[N] }
if ( srcLen != dstLen ) { throw new IOException ( lr_34 + srcFile + lr_35 + destFile MST[rv.UOI3Mutator]MSP[N] + lr_36 + srcLen + lr_37 + dstLen ) ; } } public static void copyDirectoryToDirectory ( final File srcDir , final File destDir ) throws IOException {
public static void moveToDirectory ( final File src , final File destDir , final boolean createDestDir ) throws IOException { validateMoveParameters ( src , destDir ) ; if ( src . isDirectory () ) { moveDirectoryToDirectory ( src , destDir , createDestDir ) ; MST[rv.ABSMutator]MSP[N] } else {
return FileFilterUtils . and ( fileFilter , FileFilterUtils . notFileFilter ( DirectoryFileFilter . INSTANCE ) ) ; MST[rv.CRCR4Mutator]MSP[N] } private static IOFileFilter setUpEffectiveDirFilter ( final IOFileFilter dirFilter ) { return dirFilter == null ? FalseFileFilter . INSTANCE : FileFilterUtils . and ( dirFilter , DirectoryFileFilter . INSTANCE ) ; }
return file . length () ; MST[ReturnValsMutator]MSP[N] } public static BigInteger sizeOfDirectoryAsBigInteger ( final File directory ) { checkDirectory ( directory ) ; return sizeOfDirectoryBig0 ( directory ) ; } private static BigInteger sizeOfDirectoryBig0 ( final File directory ) { final File [] files = directory . listFiles () ;
copyDirectory ( srcDir , new File ( destDir , srcDir . getName () ) , true ) ; MST[rv.CRCR5Mutator]MSP[N] } public static void copyDirectory ( final File srcDir , final File destDir ) throws IOException { copyDirectory ( srcDir , destDir , true ) ; }
return new File ( filename ) ; } static String decodeUrl ( final String url ) { String decoded = url ; if ( url != null && url . indexOf ( '%' ) >= 0 ) { MST[NegateConditionalsMutator]MSP[N] final int n = url . length () ;
throw new NullPointerException ( lr_26 ) ; } if ( ! src . exists () ) { MST[NonVoidMethodCallMutator]MSP[N] throw new FileNotFoundException ( lr_29 + src + lr_8 ) ; } } public static boolean isSymlink ( final File file ) { if ( file == null ) {
validateMoveParameters ( srcFile , destDir ) ; if ( ! destDir . exists () && createDestDir ) { destDir . mkdirs () ; } if ( ! destDir . exists () ) { MST[rv.ROR3Mutator]MSP[N] throw new FileNotFoundException ( lr_66 + destDir + lr_67 + createDestDir + lr_68 ) ; }
} public static void copyFile ( final File srcFile , final File destFile , final boolean preserveFileDate ) throws IOException { checkFileRequirements ( srcFile , destFile ) ; if ( srcFile . isDirectory () ) { MST[rv.ROR2Mutator]MSP[N] throw new IOException ( lr_29 + srcFile + lr_6 ) ; }
for ( final String name : names ) { MST[rv.UOI2Mutator]MSP[S] file = new File ( file , name ) ; } return file ; } public static File getFile ( final String ... names ) { if ( names == null ) { throw new NullPointerException ( lr_2 ) ; }
doCopyDirectory ( srcFile , dstFile , filter , preserveFileDate , exclusionList ) ; } else { doCopyFile ( srcFile , dstFile , preserveFileDate ) ; } } } if ( preserveFileDate ) { MST[rv.UOI3Mutator]MSP[S] destDir . setLastModified ( srcDir . lastModified () ) ; } }
return new File ( filename ) ; MST[ConstructorCallMutator]MSP[N] } static String decodeUrl ( final String url ) { String decoded = url ; if ( url != null && url . indexOf ( '%' ) >= 0 ) { final int n = url . length () ;
if ( srcDir == null ) { throw new NullPointerException ( lr_38 ) ; } if ( srcDir . exists () && srcDir . isDirectory () == false ) { MST[rv.ROR5Mutator]MSP[N] throw new IllegalArgumentException ( lr_29 + destDir + lr_28 ) ; } if ( destDir == null ) {
throw new IOException ( lr_40 + directory ) ; } return files ; } public static boolean waitFor ( final File file , final int seconds ) { final long finishAt = System . currentTimeMillis () + ( seconds * 1000L ) ; MST[rv.AOR1Mutator]MSP[N] boolean wasInterrupted = false ; try {
return new FileOutputStream ( file , append ) ; } public static String byteCountToDisplaySize ( final BigInteger size ) { String displaySize ; if ( size . divide ( ONE_EB_BI ) . compareTo ( BigInteger . ZERO ) > 0 ) { MST[experimental.NakedReceiverMutator]MSP[N]
checkEqualSizes ( srcFile , destFile , srcFile . length () , destFile . length () ) ; MST[VoidMethodCallMutator]MSP[S] destFile . setLastModified ( newLastModifed ) ; } private static void checkEqualSizes ( final File srcFile , final File destFile , final long srcLen , final long dstLen ) throws IOException {
moveFileToDirectory ( src , destDir , createDestDir ) ; MST[rv.UOI2Mutator]MSP[N] } } private static void validateMoveParameters ( final File src , final File dest ) throws FileNotFoundException { if ( src == null ) { throw new NullPointerException ( lr_38 ) ; } if ( dest == null ) {
throws IOException { final boolean file1Exists = file1 . exists () ; if ( file1Exists != file2 . exists () ) { return false ; } if ( ! file1Exists ) { MST[rv.ROR5Mutator]MSP[S] return true ; } if ( file1 . isDirectory () || file2 . isDirectory () ) {
if ( ! destDir . exists () ) { throw new FileNotFoundException ( lr_66 + destDir + lr_67 + createDestDir + lr_68 ) ; } if ( ! destDir . isDirectory () ) { throw new IOException ( lr_27 + destDir + lr_28 ) ; MST[NonVoidMethodCallMutator]MSP[S] }
throw new IOException ( lr_23 ) ; } if ( file1 . length () != file2 . length () ) { return false ; } if ( file1 . getCanonicalFile () . equals ( file2 . getCanonicalFile () ) ) { return true ; MST[rv.CRCR6Mutator]MSP[N] }
} } return size ; } private static BigInteger sizeOfBig0 ( final File fileOrDir ) { if ( fileOrDir . isDirectory () ) { return sizeOfDirectoryBig0 ( fileOrDir ) ; } return BigInteger . valueOf ( fileOrDir . length () ) ; MST[ReturnValsMutator]MSP[N] }
} private static void checkFileRequirements ( final File src , final File dest ) throws FileNotFoundException { if ( src == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] throw new NullPointerException ( lr_38 ) ; } if ( dest == null ) { throw new NullPointerException ( lr_26 ) ; }
if ( files == null ) { return BigInteger . ZERO ; } BigInteger size = BigInteger . ZERO ; for ( final File file : files ) { if ( ! isSymlink ( file ) ) { MST[rv.ROR4Mutator]MSP[N] size = size . add ( sizeOfBig0 ( file ) ) ;
public static void write ( final File file , final CharSequence data , final Charset encoding ) throws IOException { write ( file , data , encoding , false ) ; MST[rv.CRCR6Mutator]MSP[N] }
} else { final File parent = file . getParentFile () ; if ( parent != null ) { if ( ! parent . mkdirs () && ! parent . isDirectory () ) { throw new IOException ( lr_10 + parent + lr_11 ) ; MST[ConstructorCallMutator]MSP[S] } } }
if ( ! directory . isDirectory () ) { throw new IllegalArgumentException ( lr_46 + directory ) ; MST[experimental.NakedReceiverMutator]MSP[N] } if ( child == null ) { return false ; } if ( ! directory . exists () || ! child . exists () ) { return false ; }
public static String readFileToString ( final File file , final String encoding ) throws IOException { return readFileToString ( file , Charsets . toCharset ( encoding ) ) ; MST[ReturnValsMutator]MSP[N] } @Deprecated public static String readFileToString ( final File file ) throws IOException {
throw new IOException ( lr_27 + destFile + lr_69 ) ; } final boolean rename = srcFile . renameTo ( destFile ) ; if ( ! rename ) { MST[rv.UOI2Mutator]MSP[N] copyFile ( srcFile , destFile ) ; if ( ! srcFile . delete () ) {
public static Iterator < File > iterateFilesAndDirs ( final File directory , final IOFileFilter fileFilter , final IOFileFilter dirFilter ) { return listFilesAndDirs ( directory , fileFilter , dirFilter ) . iterator () ; MST[NonVoidMethodCallMutator]MSP[S] } private static String [] toSuffixes ( final String [] extensions ) {
if ( url == null || ! lr_24 . equalsIgnoreCase ( url . getProtocol () ) ) { return null ; } String filename = url . getFile () . replace ( '/' , File . separatorChar ) ; MST[rv.CRCR6Mutator]MSP[N] filename = decodeUrl ( filename ) ;
throws IOException { final File [] srcFiles = filter == null ? srcDir . listFiles () : srcDir . listFiles ( filter ) ; if ( srcFiles == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] throw new IOException ( lr_40 + srcDir ) ; } if ( destDir . exists () ) {
while ( ! file . exists () ) { final long remaining = finishAt - System . currentTimeMillis () ; if ( remaining < 0 ) { MST[rv.UOI3Mutator]MSP[N] return false ; } try { Thread . sleep ( Math . min ( 100 , remaining ) ) ;
size += sizeOf0 ( file ) ; if ( size < 0 ) { MST[rv.ROR3Mutator]MSP[N] break; } } } return size ; } private static long sizeOf0 ( final File file ) { if ( file . isDirectory () ) { return sizeOfDirectory0 ( file ) ; }
final byte octet = ( byte ) Integer . parseInt ( url . substring ( i + 1 , i + 3 ) , 16 ) ; MST[rv.CRCR3Mutator]MSP[N] bytes . put ( octet ) ; i += 3 ;
writeLines ( file , encoding , lines , null , append ) ; MST[rv.UOI2Mutator]MSP[N] } public static void writeLines ( final File file , final Collection < ? > lines ) throws IOException { writeLines ( file , null , lines , null , false ) ; }
if ( ! destDir . exists () ) { throw new FileNotFoundException ( lr_66 + destDir + lr_67 + createDestDir + lr_68 ) ; } if ( ! destDir . isDirectory () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] throw new IOException ( lr_27 + destDir + lr_28 ) ; }
if ( ! directory . isDirectory () ) { throw new IllegalArgumentException ( lr_46 + directory ) ; } if ( child == null ) { return false ; } if ( ! directory . exists () || ! child . exists () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return false ; }
validateMoveParameters ( srcFile , destDir ) ; if ( ! destDir . exists () && createDestDir ) { MST[NegateConditionalsMutator]MSP[N] destDir . mkdirs () ; } if ( ! destDir . exists () ) { throw new FileNotFoundException ( lr_66 + destDir + lr_67 + createDestDir + lr_68 ) ; }
final File [] srcFiles = filter == null ? srcDir . listFiles () : srcDir . listFiles ( filter ) ; if ( srcFiles != null && srcFiles . length > 0 ) { MST[rv.ROR2Mutator]MSP[S] exclusionList = new ArrayList <> ( srcFiles . length ) ;
displaySize = String . valueOf ( size . divide ( ONE_MB_BI ) ) + lr_16 ; MST[experimental.NakedReceiverMutator]MSP[N] } else if ( size . divide ( ONE_KB_BI ) . compareTo ( BigInteger . ZERO ) > 0 ) {
final URL [] urls = new URL [ files . length ] ; for ( int i = 0 ; i < urls . length ; i ++ ) { MST[rv.UOI4Mutator]MSP[N] urls [ i ] = files [ i ] . toURI () . toURL () ; } return urls ;
final Collection < File > files = new java . util . LinkedList <> () ; if ( includeSubDirectories ) { MST[rv.ROR5Mutator]MSP[N] files . add ( directory ) ; } innerListFiles ( files , directory , FileFilterUtils . or ( effFileFilter , effDirFilter ) , includeSubDirectories ) ; return files ;
final StringBuilder buffer = new StringBuilder () ; final ByteBuffer bytes = ByteBuffer . allocate ( n ) ; for ( int i = 0 ; i < n ; ) { MST[rv.UOI1Mutator]MSP[N] if ( url . charAt ( i ) == '%' ) { try { do {
throw new IOException ( lr_29 + srcDir + lr_30 + destDir + lr_31 ) ; MST[NonVoidMethodCallMutator]MSP[S] } List < String > exclusionList = null ; if ( destDir . getCanonicalPath () . startsWith ( srcDir . getCanonicalPath () ) ) {
throw new IOException ( lr_41 + src + lr_42 ) ; MST[ConstructorCallMutator]MSP[S] } } public static void copyToDirectory ( final Iterable < File > srcs , final File destDir ) throws IOException { if ( srcs == null ) { throw new NullPointerException ( lr_43 ) ; }
if ( files == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return BigInteger . ZERO ; } BigInteger size = BigInteger . ZERO ; for ( final File file : files ) { if ( ! isSymlink ( file ) ) { size = size . add ( sizeOfBig0 ( file ) ) ;
throws IOException { final boolean file1Exists = file1 . exists () ; if ( file1Exists != file2 . exists () ) { return false ; } if ( ! file1Exists ) { MST[NegateConditionalsMutator]MSP[S] return true ; } if ( file1 . isDirectory () || file2 . isDirectory () ) {
displaySize = String . valueOf ( size . divide ( ONE_GB_BI ) ) + lr_15 ; MST[NonVoidMethodCallMutator]MSP[N] } else if ( size . divide ( ONE_MB_BI ) . compareTo ( BigInteger . ZERO ) > 0 ) {
writeLines ( file , encoding , lines , null , false ) ; MST[rv.CRCR1Mutator]MSP[N] } public static void writeLines ( final File file , final String encoding , final Collection < ? > lines , final boolean append ) throws IOException {
if ( srcFile . getCanonicalPath () . equals ( destFile . getCanonicalPath () ) ) { throw new IOException ( lr_29 + srcFile + lr_30 + destFile + lr_31 ) ; } final File parentFile = destFile . getParentFile () ; if ( parentFile != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
displaySize = String . valueOf ( size . divide ( ONE_PB_BI ) ) + lr_13 ; } else if ( size . divide ( ONE_TB_BI ) . compareTo ( BigInteger . ZERO ) > 0 ) { MST[experimental.BigIntegerMutator]MSP[N]
try ( InputStream input1 = new FileInputStream ( file1 ) ; InputStream input2 = new FileInputStream ( file2 ) ) { MST[ConstructorCallMutator]MSP[N] return IOUtils . contentEquals ( input1 , input2 ) ; } } public static boolean contentEqualsIgnoreEOL ( final File file1 , final File file2 , final String charsetName )
File file = null ; for ( final String name : names ) { if ( file == null ) { file = new File ( name ) ; MST[ConstructorCallMutator]MSP[S] } else { file = new File ( file , name ) ; } } return file ; }
if ( srcDir == null ) { throw new NullPointerException ( lr_38 ) ; } if ( srcDir . exists () && srcDir . isDirectory () == false ) { MST[NegateConditionalsMutator]MSP[N] throw new IllegalArgumentException ( lr_29 + destDir + lr_28 ) ; } if ( destDir == null ) {
return isFileNewer ( file , date . getTime () ) ; } public static boolean isFileNewer ( final File file , final long timeMillis ) { if ( file == null ) { throw new IllegalArgumentException ( lr_58 ) ; } if ( ! file . exists () ) { MST[rv.ROR2Mutator]MSP[N]
throw new IOException ( lr_27 + destFile + lr_6 ) ; } final Path srcPath = srcFile . toPath () ; final Path destPath = destFile . toPath () ; final long newLastModifed = preserveFileDate ? srcFile . lastModified () : destFile . lastModified () ; MST[rv.ROR3Mutator]MSP[S]
throw new IOException ( lr_27 + destFile + lr_69 ) ; } final boolean rename = srcFile . renameTo ( destFile ) ; if ( ! rename ) { copyFile ( srcFile , destFile ) ; if ( ! srcFile . delete () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S]
for ( int i = 0 ; i < urls . length ; i ++ ) { MST[rv.ABSMutator]MSP[N] final URL url = urls [ i ] ; if ( url != null ) { if ( url . getProtocol () . equals ( lr_24 ) == false ) {
Files . copy ( srcPath , destPath , StandardCopyOption . REPLACE_EXISTING ) ; MST[NonVoidMethodCallMutator]MSP[N] checkEqualSizes ( srcFile , destFile , Files . size ( srcPath ) , Files . size ( destPath ) ) ;
try ( InputStream input1 = new FileInputStream ( file1 ) ; InputStream input2 = new FileInputStream ( file2 ) ) { return IOUtils . contentEquals ( input1 , input2 ) ; MST[BooleanTrueReturnValsMutator]MSP[S] } } public static boolean contentEqualsIgnoreEOL ( final File file1 , final File file2 , final String charsetName )
final byte octet = ( byte ) Integer . parseInt ( url . substring ( i + 1 , i + 3 ) , 16 ) ; MST[NonVoidMethodCallMutator]MSP[N] bytes . put ( octet ) ; i += 3 ;
throw new IOException ( lr_5 + file + lr_6 ) ; } if ( file . canRead () == false ) { MST[rv.ROR4Mutator]MSP[N] throw new IOException ( lr_5 + file + lr_7 ) ; } } else { throw new FileNotFoundException ( lr_5 + file + lr_8 ) ; }
final File [] files = directory . listFiles () ; if ( files == null ) { MST[rv.ROR5Mutator]MSP[N] return 0L ; } long size = 0 ; for ( final File file : files ) { if ( ! isSymlink ( file ) ) {
final boolean file1Exists = file1 . exists () ; if ( file1Exists != file2 . exists () ) { return false ; } if ( ! file1Exists ) { MST[rv.ROR3Mutator]MSP[N] return true ; } if ( file1 . isDirectory () || file2 . isDirectory () ) {
writeByteArrayToFile ( file , data , 0 , data . length , append ) ; MST[rv.UOI1Mutator]MSP[N] } public static void writeByteArrayToFile ( final File file , final byte [] data , final int off , final int len ) throws IOException {
} public static File [] toFiles ( final URL [] urls ) { if ( urls == null || urls . length == 0 ) { MST[rv.ROR5Mutator]MSP[N] return EMPTY_FILE_ARRAY ; } final File [] files = new File [ urls . length ] ;
public static void moveDirectoryToDirectory ( final File src , final File destDir , final boolean createDestDir ) throws IOException { validateMoveParameters ( src , destDir ) ; if ( ! destDir . exists () && createDestDir ) { MST[rv.ROR4Mutator]MSP[S] destDir . mkdirs () ; }
return FileFilterUtils . and ( fileFilter , FileFilterUtils . notFileFilter ( DirectoryFileFilter . INSTANCE ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } private static IOFileFilter setUpEffectiveDirFilter ( final IOFileFilter dirFilter ) { return dirFilter == null ? FalseFileFilter . INSTANCE : FileFilterUtils . and ( dirFilter , DirectoryFileFilter . INSTANCE ) ; }
doCopyDirectory ( srcFile , dstFile , filter , preserveFileDate , exclusionList ) ; } else { doCopyFile ( srcFile , dstFile , preserveFileDate ) ; MST[rv.UOI4Mutator]MSP[S] } } } if ( preserveFileDate ) { destDir . setLastModified ( srcDir . lastModified () ) ; } }
final String [] suffixes = new String [ extensions . length ] ; for ( int i = 0 ; i < extensions . length ; i ++ ) { suffixes [ i ] = lr_22 + extensions [ i ] ; MST[NonVoidMethodCallMutator]MSP[N] } return suffixes ; }
if ( ! directory . exists () ) { MST[NonVoidMethodCallMutator]MSP[N] return; } directory . deleteOnExit () ; if ( ! isSymlink ( directory ) ) { cleanDirectoryOnExit ( directory ) ; } } private static void cleanDirectoryOnExit ( final File directory ) throws IOException {
writeByteArrayToFile ( file , data , off , len , false ) ; MST[rv.CRCR6Mutator]MSP[N] } public static void writeByteArrayToFile ( final File file , final byte [] data , final int off , final int len , final boolean append ) throws IOException {
if ( srcLen != dstLen ) { MST[rv.ROR2Mutator]MSP[N] throw new IOException ( lr_34 + srcFile + lr_35 + destFile + lr_36 + srcLen + lr_37 + dstLen ) ; } } public static void copyDirectoryToDirectory ( final File srcDir , final File destDir ) throws IOException {
if ( file . exists () ) { if ( file . isDirectory () ) { MST[rv.ROR5Mutator]MSP[N] throw new IOException ( lr_5 + file + lr_6 ) ; } if ( file . canWrite () == false ) { throw new IOException ( lr_5 + file + lr_9 ) ; }
} catch ( final InterruptedException ignore ) { wasInterrupted = true ; MST[rv.CRCR5Mutator]MSP[N] } catch ( final Exception ex ) { break; } } } finally { if ( wasInterrupted ) { Thread . currentThread () . interrupt () ; } } return true ; }
writeByteArrayToFile ( file , data , 0 , data . length , append ) ; MST[rv.CRCR1Mutator]MSP[N] } public static void writeByteArrayToFile ( final File file , final byte [] data , final int off , final int len ) throws IOException {
private static void checkDirectory ( final File directory ) { if ( ! directory . exists () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] throw new IllegalArgumentException ( directory + lr_42 ) ; } if ( ! directory . isDirectory () ) { throw new IllegalArgumentException ( directory + lr_47 ) ; } }
throw new IOException ( lr_29 + srcFile + lr_69 ) ; } if ( destFile . exists () ) { throw new FileExistsException ( lr_27 + destFile + lr_60 ) ; MST[experimental.NakedReceiverMutator]MSP[N] } if ( destFile . isDirectory () ) {
final int connectionTimeout , final int readTimeout ) throws IOException { final URLConnection connection = source . openConnection () ; connection . setConnectTimeout ( connectionTimeout ) ; connection . setReadTimeout ( readTimeout ) ; MST[VoidMethodCallMutator]MSP[N] copyInputStreamToFile ( connection . getInputStream () , destination ) ; }
final boolean file1Exists = file1 . exists () ; if ( file1Exists != file2 . exists () ) { return false ; } if ( ! file1Exists ) { return true ; } if ( file1 . isDirectory () || file2 . isDirectory () ) { MST[rv.ROR4Mutator]MSP[N]
if ( ! parentFile . mkdirs () && ! parentFile . isDirectory () ) { MST[NonVoidMethodCallMutator]MSP[N] throw new IOException ( lr_27 + parentFile + lr_32 ) ; } } if ( destFile . exists () && destFile . canWrite () == false ) {
+ lr_52 ; throw new IOException ( message ) ; } } else { if ( ! directory . mkdirs () ) { MST[rv.ROR3Mutator]MSP[S] if ( ! directory . isDirectory () ) { final String message = lr_53 + directory ; throw new IOException ( message ) ; } } }
final byte octet = ( byte ) Integer . parseInt ( url . substring ( i + 1 , i + 3 ) , 16 ) ; bytes . put ( octet ) ; MST[NonVoidMethodCallMutator]MSP[N] i += 3 ;
final StringBuilder buffer = new StringBuilder () ; final ByteBuffer bytes = ByteBuffer . allocate ( n ) ; for ( int i = 0 ; i < n ; ) { MST[NegateConditionalsMutator]MSP[N] if ( url . charAt ( i ) == '%' ) { try { do {
return false ; } return file . lastModified () > timeMillis ; } public static boolean isFileOlder ( final File file , final File reference ) { if ( reference == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] throw new IllegalArgumentException ( lr_54 ) ; }
throw new NullPointerException ( lr_38 ) ; } if ( src . isFile () ) { MST[rv.ROR2Mutator]MSP[N] copyFileToDirectory ( src , destDir ) ; } else if ( src . isDirectory () ) { copyDirectoryToDirectory ( src , destDir ) ; } else {
: new InputStreamReader ( new FileInputStream ( file2 ) , charsetName ) ) { return IOUtils . contentEqualsIgnoreEOL ( input1 , input2 ) ; MST[rv.UOI1Mutator]MSP[N] } } public static File toFile ( final URL url ) {
if ( null != exception ) { throw exception ; } } public static void forceMkdir ( final File directory ) throws IOException { if ( directory . exists () ) { if ( ! directory . isDirectory () ) { final String message = MST[experimental.NakedReceiverMutator]MSP[N] lr_50 + directory + lr_51
public static File getUserDirectory () { return new File ( getUserDirectoryPath () ) ; } public static FileInputStream openInputStream ( final File file ) throws IOException { if ( file . exists () ) { MST[rv.ROR1Mutator]MSP[S] if ( file . isDirectory () ) {
if ( srcDir == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] throw new NullPointerException ( lr_38 ) ; } if ( srcDir . exists () && srcDir . isDirectory () == false ) { throw new IllegalArgumentException ( lr_29 + destDir + lr_28 ) ; } if ( destDir == null ) {
return FileFilterUtils . and ( fileFilter , FileFilterUtils . notFileFilter ( DirectoryFileFilter . INSTANCE ) ) ; MST[rv.CRCR1Mutator]MSP[N] } private static IOFileFilter setUpEffectiveDirFilter ( final IOFileFilter dirFilter ) { return dirFilter == null ? FalseFileFilter . INSTANCE : FileFilterUtils . and ( dirFilter , DirectoryFileFilter . INSTANCE ) ; }
displaySize = String . valueOf ( size . divide ( ONE_PB_BI ) ) + lr_13 ; MST[experimental.NakedReceiverMutator]MSP[N] } else if ( size . divide ( ONE_TB_BI ) . compareTo ( BigInteger . ZERO ) > 0 ) {
if ( srcFile . getCanonicalPath () . equals ( destFile . getCanonicalPath () ) ) { throw new IOException ( lr_29 + srcFile + lr_30 + destFile + lr_31 ) ; MST[NonVoidMethodCallMutator]MSP[S] } final File parentFile = destFile . getParentFile () ; if ( parentFile != null ) {
throw new IOException ( lr_40 + directory ) ; } return files ; } public static boolean waitFor ( final File file , final int seconds ) { final long finishAt = System . currentTimeMillis () + ( seconds * 1000L ) ; MST[MathMutator]MSP[N] boolean wasInterrupted = false ; try {
public static BigInteger sizeOfAsBigInteger ( final File file ) { if ( ! file . exists () ) { final String message = file + lr_42 ; throw new IllegalArgumentException ( message ) ; } if ( file . isDirectory () ) { MST[rv.ROR2Mutator]MSP[N] return sizeOfDirectoryBig0 ( file ) ; }
validateMoveParameters ( srcDir , destDir ) ; if ( ! srcDir . isDirectory () ) { MST[rv.ROR2Mutator]MSP[N] throw new IOException ( lr_29 + srcDir + lr_28 ) ; } if ( destDir . exists () ) { throw new FileExistsException ( lr_27 + destDir + lr_60 ) ; }
} catch ( final InterruptedException ignore ) { wasInterrupted = true ; } catch ( final Exception ex ) { break; } } } finally { if ( wasInterrupted ) { MST[rv.UOI2Mutator]MSP[N] Thread . currentThread () . interrupt () ; } } return true ; }
public static void moveToDirectory ( final File src , final File destDir , final boolean createDestDir ) throws IOException { validateMoveParameters ( src , destDir ) ; if ( src . isDirectory () ) { MST[NegateConditionalsMutator]MSP[S] moveDirectoryToDirectory ( src , destDir , createDestDir ) ; } else {
throw new IOException ( lr_5 + file + lr_6 ) ; } if ( file . canRead () == false ) { MST[NonVoidMethodCallMutator]MSP[N] throw new IOException ( lr_5 + file + lr_7 ) ; } } else { throw new FileNotFoundException ( lr_5 + file + lr_8 ) ; }
size += sizeOf0 ( file ) ; MST[rv.AOR2Mutator]MSP[N] if ( size < 0 ) { break; } } } return size ; } private static long sizeOf0 ( final File file ) { if ( file . isDirectory () ) { return sizeOfDirectory0 ( file ) ; }
public static String readFileToString ( final File file , final Charset encoding ) throws IOException { try ( InputStream in = openInputStream ( file ) ) { MST[NonVoidMethodCallMutator]MSP[N] return IOUtils . toString ( in , Charsets . toCharset ( encoding ) ) ; } }
if ( files == null ) { return BigInteger . ZERO ; } BigInteger size = BigInteger . ZERO ; for ( final File file : files ) { if ( ! isSymlink ( file ) ) { MST[rv.ROR1Mutator]MSP[N] size = size . add ( sizeOfBig0 ( file ) ) ;
doCopyDirectory ( srcFile , dstFile , filter , preserveFileDate , exclusionList ) ; } else { doCopyFile ( srcFile , dstFile , preserveFileDate ) ; } } } if ( preserveFileDate ) { MST[NegateConditionalsMutator]MSP[S] destDir . setLastModified ( srcDir . lastModified () ) ; } }
while ( ! file . exists () ) { final long remaining = finishAt - System . currentTimeMillis () ; if ( remaining < 0 ) { return false ; } try { Thread . sleep ( Math . min ( 100 , remaining ) ) ; MST[NonVoidMethodCallMutator]MSP[N]
displaySize = String . valueOf ( size . divide ( ONE_EB_BI ) ) + lr_12 ; } else if ( size . divide ( ONE_PB_BI ) . compareTo ( BigInteger . ZERO ) > 0 ) { MST[rv.ROR1Mutator]MSP[N]
final boolean filePresent = file . exists () ; if ( ! file . delete () ) { if ( ! filePresent ) { throw new FileNotFoundException ( lr_48 + file ) ; MST[ConstructorCallMutator]MSP[N] } final String message = lr_49 + file ; throw new IOException ( message ) ; }
throw new IOException ( lr_29 + srcFile + lr_69 ) ; } if ( destFile . exists () ) { throw new FileExistsException ( lr_27 + destFile + lr_60 ) ; MST[ConstructorCallMutator]MSP[S] } if ( destFile . isDirectory () ) {
if ( ! src . exists () ) { MST[rv.ROR2Mutator]MSP[N] throw new FileNotFoundException ( lr_29 + src + lr_8 ) ; } } private static void doCopyDirectory ( final File srcDir , final File destDir , final FileFilter filter , final boolean preserveFileDate , final List < String > exclusionList )
final boolean filePresent = file . exists () ; MST[NonVoidMethodCallMutator]MSP[N] if ( ! file . delete () ) { if ( ! filePresent ) { throw new FileNotFoundException ( lr_48 + file ) ; } final String message = lr_49 + file ; throw new IOException ( message ) ; }
validateMoveParameters ( srcFile , destDir ) ; if ( ! destDir . exists () && createDestDir ) { MST[rv.ROR1Mutator]MSP[N] destDir . mkdirs () ; } if ( ! destDir . exists () ) { throw new FileNotFoundException ( lr_66 + destDir + lr_67 + createDestDir + lr_68 ) ; }
if ( srcLen != dstLen ) { throw new IOException ( lr_34 + srcFile + lr_35 + destFile MST[NonVoidMethodCallMutator]MSP[S] + lr_36 + srcLen + lr_37 + dstLen ) ; } } public static void copyDirectoryToDirectory ( final File srcDir , final File destDir ) throws IOException {
while ( ! file . exists () ) { final long remaining = finishAt - System . currentTimeMillis () ; if ( remaining < 0 ) { return false ; MST[rv.UOI1Mutator]MSP[N] } try { Thread . sleep ( Math . min ( 100 , remaining ) ) ;
final StringBuilder buffer = new StringBuilder () ; final ByteBuffer bytes = ByteBuffer . allocate ( n ) ; for ( int i = 0 ; i < n ; ) { if ( url . charAt ( i ) == '%' ) { MST[rv.CRCR1Mutator]MSP[N] try { do {
} public static File [] toFiles ( final URL [] urls ) { if ( urls == null || urls . length == 0 ) { MST[rv.ROR4Mutator]MSP[N] return EMPTY_FILE_ARRAY ; } final File [] files = new File [ urls . length ] ;
final boolean file1Exists = file1 . exists () ; if ( file1Exists != file2 . exists () ) { return false ; } if ( ! file1Exists ) { return true ; } if ( file1 . isDirectory () || file2 . isDirectory () ) { MST[rv.ROR3Mutator]MSP[N]
writeByteArrayToFile ( file , data , 0 , data . length , append ) ; MST[rv.UOI4Mutator]MSP[N] } public static void writeByteArrayToFile ( final File file , final byte [] data , final int off , final int len ) throws IOException {
} } return size ; } private static BigInteger sizeOfBig0 ( final File fileOrDir ) { if ( fileOrDir . isDirectory () ) { MST[rv.ROR4Mutator]MSP[S] return sizeOfDirectoryBig0 ( fileOrDir ) ; } return BigInteger . valueOf ( fileOrDir . length () ) ; }
throw new NullPointerException ( lr_26 ) ; } if ( ! src . exists () ) { MST[rv.ROR3Mutator]MSP[N] throw new FileNotFoundException ( lr_29 + src + lr_8 ) ; } } public static boolean isSymlink ( final File file ) { if ( file == null ) {
if ( file == null ) { return false ; } try { if ( file . isDirectory () ) { MST[rv.ROR1Mutator]MSP[S] cleanDirectory ( file ) ; } } catch ( final Exception ignored ) { } try { return file . delete () ;
final String [] suffixes = new String [ extensions . length ] ; for ( int i = 0 ; i < extensions . length ; i ++ ) { MST[rv.ROR3Mutator]MSP[N] suffixes [ i ] = lr_22 + extensions [ i ] ; } return suffixes ; }
while ( ! file . exists () ) { final long remaining = finishAt - System . currentTimeMillis () ; if ( remaining < 0 ) { MST[rv.ROR2Mutator]MSP[N] return false ; } try { Thread . sleep ( Math . min ( 100 , remaining ) ) ;
throws IOException { final boolean file1Exists = file1 . exists () ; if ( file1Exists != file2 . exists () ) { return false ; } if ( ! file1Exists ) { return true ; MST[BooleanFalseReturnValsMutator]MSP[S] } if ( file1 . isDirectory () || file2 . isDirectory () ) {
validateMoveParameters ( srcFile , destDir ) ; if ( ! destDir . exists () && createDestDir ) { destDir . mkdirs () ; } if ( ! destDir . exists () ) { throw new FileNotFoundException ( lr_66 + destDir + MST[NonVoidMethodCallMutator]MSP[S] lr_67 + createDestDir + lr_68 ) ; }
throw new IOException ( lr_29 + srcDir + lr_30 + destDir + lr_31 ) ; MST[experimental.NakedReceiverMutator]MSP[N] } List < String > exclusionList = null ; if ( destDir . getCanonicalPath () . startsWith ( srcDir . getCanonicalPath () ) ) {
throw new IOException ( lr_23 ) ; } if ( file1 . length () != file2 . length () ) { MST[rv.ROR4Mutator]MSP[N] return false ; } if ( file1 . getCanonicalFile () . equals ( file2 . getCanonicalFile () ) ) { return true ; }
copyDirectory ( srcDir , new File ( destDir , srcDir . getName () ) , true ) ; } public static void copyDirectory ( final File srcDir , final File destDir ) throws IOException { copyDirectory ( srcDir , destDir , true ) ; MST[InlineConstantMutator]MSP[N] }
final byte octet = ( byte ) Integer . parseInt ( url . substring ( i + 1 , i + 3 ) , 16 ) ; MST[rv.AOR4Mutator]MSP[N] bytes . put ( octet ) ; i += 3 ;
} catch ( final InterruptedException ignore ) { wasInterrupted = true ; } catch ( final Exception ex ) { break; } } } finally { if ( wasInterrupted ) { MST[rv.ABSMutator]MSP[N] Thread . currentThread () . interrupt () ; } } return true ; }
if ( ! destDir . exists () ) { throw new FileNotFoundException ( lr_66 + destDir + MST[rv.UOI2Mutator]MSP[N] lr_67 + createDestDir + lr_68 ) ; } if ( ! destDir . isDirectory () ) { throw new IOException ( lr_27 + destDir + lr_28 ) ; }
for ( int i = 0 ; i < urls . length ; i ++ ) { final URL url = urls [ i ] ; if ( url != null ) { if ( url . getProtocol () . equals ( lr_24 ) == false ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
if ( destDir . isDirectory () == false ) { MST[rv.ROR5Mutator]MSP[N] throw new IOException ( lr_27 + destDir + lr_39 ) ; } } else { if ( ! destDir . mkdirs () && ! destDir . isDirectory () ) {
displaySize = String . valueOf ( size . divide ( ONE_TB_BI ) ) + lr_14 ; MST[ArgumentPropagationMutator]MSP[N] } else if ( size . divide ( ONE_GB_BI ) . compareTo ( BigInteger . ZERO ) > 0 ) {
throw new IllegalArgumentException ( lr_58 ) ; } if ( ! file . exists () ) { return false ; } return file . lastModified () < timeMillis ; MST[rv.CRCR6Mutator]MSP[S] } public static long checksumCRC32 ( final File file ) throws IOException { final CRC32 crc = new CRC32 () ;
return new FileOutputStream ( file , append ) ; MST[NullReturnValsMutator]MSP[N] } public static String byteCountToDisplaySize ( final BigInteger size ) { String displaySize ; if ( size . divide ( ONE_EB_BI ) . compareTo ( BigInteger . ZERO ) > 0 ) {
final URL [] urls = new URL [ files . length ] ; for ( int i = 0 ; i < urls . length ; i ++ ) { MST[rv.UOI3Mutator]MSP[S] urls [ i ] = files [ i ] . toURI () . toURL () ; } return urls ;
} catch ( final InterruptedException ignore ) { wasInterrupted = true ; MST[rv.CRCR6Mutator]MSP[S] } catch ( final Exception ex ) { break; } } } finally { if ( wasInterrupted ) { Thread . currentThread () . interrupt () ; } } return true ; }
File file = null ; for ( final String name : names ) { MST[rv.UOI4Mutator]MSP[S] if ( file == null ) { file = new File ( name ) ; } else { file = new File ( file , name ) ; } } return file ; }
moveFileToDirectory ( src , destDir , createDestDir ) ; } } private static void validateMoveParameters ( final File src , final File dest ) throws FileNotFoundException { if ( src == null ) { throw new NullPointerException ( lr_38 ) ; } if ( dest == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S]
if ( ! reference . exists () ) { throw new IllegalArgumentException ( lr_55 MST[experimental.NakedReceiverMutator]MSP[S] + reference + lr_56 ) ; } return isFileOlder ( file , reference . lastModified () ) ; } public static boolean isFileOlder ( final File file , final Date date ) {
throw new NullPointerException ( lr_26 ) ; } if ( destDir . exists () && destDir . isDirectory () == false ) { MST[rv.ROR4Mutator]MSP[N] throw new IllegalArgumentException ( lr_27 + destDir + lr_28 ) ; }
final File [] files = directory . listFiles () ; if ( files == null ) { return 0L ; } long size = 0 ; for ( final File file : files ) { if ( ! isSymlink ( file ) ) { MST[rv.ROR1Mutator]MSP[N]
throw new NullPointerException ( lr_26 ) ; } if ( ! src . exists () ) { throw new FileNotFoundException ( lr_29 + src + lr_8 ) ; MST[ConstructorCallMutator]MSP[N] } } public static boolean isSymlink ( final File file ) { if ( file == null ) {
} public static void forceMkdirParent ( final File file ) throws IOException { final File parent = file . getParentFile () ; if ( parent == null ) { MST[NegateConditionalsMutator]MSP[N] return; } forceMkdir ( parent ) ; } public static long sizeOf ( final File file ) {
if ( ! directory . isDirectory () ) { MST[rv.ROR5Mutator]MSP[N] throw new IllegalArgumentException ( lr_46 + directory ) ; } if ( child == null ) { return false ; } if ( ! directory . exists () || ! child . exists () ) { return false ; }
if ( ! srcDir . isDirectory () ) { throw new IOException ( lr_29 + srcDir + lr_39 ) ; } if ( srcDir . getCanonicalPath () . equals ( destDir . getCanonicalPath () ) ) { MST[NegateConditionalsMutator]MSP[N]
if ( ! destDir . exists () ) { throw new FileNotFoundException ( lr_66 + destDir + MST[rv.ABSMutator]MSP[N] lr_67 + createDestDir + lr_68 ) ; } if ( ! destDir . isDirectory () ) { throw new IOException ( lr_27 + destDir + lr_28 ) ; }
} while ( i < n && url . charAt ( i ) == '%' ); MST[rv.CRCR1Mutator]MSP[S] continue; } catch ( final RuntimeException e ) { } finally { if ( bytes . position () > 0 ) { bytes . flip () ;
return fileLength > 0 ? IOUtils . toByteArray ( in , fileLength ) : IOUtils . toByteArray ( in ) ; MST[NonVoidMethodCallMutator]MSP[S] } } public static List < String > readLines ( final File file , final Charset encoding ) throws IOException {
return false ; } return file . lastModified () > timeMillis ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] } public static boolean isFileOlder ( final File file , final File reference ) { if ( reference == null ) { throw new IllegalArgumentException ( lr_54 ) ; }
cleanDirectory ( directory ) ; } if ( ! directory . delete () ) { MST[NegateConditionalsMutator]MSP[N] final String message = lr_44 + directory + lr_22 ; throw new IOException ( message ) ; } } public static boolean deleteQuietly ( final File file ) {
public static boolean isFileNewer ( final File file , final File reference ) { if ( reference == null ) { throw new IllegalArgumentException ( lr_54 ) ; } if ( ! reference . exists () ) { MST[rv.ROR2Mutator]MSP[N] throw new IllegalArgumentException ( lr_55 + reference + lr_56 ) ; }
if ( ! destDir . exists () ) { MST[NegateConditionalsMutator]MSP[N] throw new FileNotFoundException ( lr_66 + destDir + lr_67 + createDestDir + lr_68 ) ; } if ( ! destDir . isDirectory () ) { throw new IOException ( lr_27 + destDir + lr_28 ) ; }
throw new IOException ( lr_23 ) ; } if ( file1 . getCanonicalFile () . equals ( file2 . getCanonicalFile () ) ) { return true ; } try ( Reader input1 = charsetName == null MST[ConstructorCallMutator]MSP[S]
final byte octet = ( byte ) Integer . parseInt ( url . substring ( i + 1 , i + 3 ) , 16 ) ; MST[rv.AOD2Mutator]MSP[N] bytes . put ( octet ) ; i += 3 ;
if ( srcDir == null ) { throw new NullPointerException ( lr_38 ) ; } if ( srcDir . exists () && srcDir . isDirectory () == false ) { MST[rv.ROR3Mutator]MSP[N] throw new IllegalArgumentException ( lr_29 + destDir + lr_28 ) ; } if ( destDir == null ) {
throw new IllegalArgumentException ( lr_25 + url ) ; } files [ i ] = toFile ( url ) ; MST[NonVoidMethodCallMutator]MSP[N] } } return files ; } public static URL [] toURLs ( final File [] files ) throws IOException {
public static void write ( final File file , final CharSequence data , final Charset encoding , final boolean append ) throws IOException { final String str = data == null ? null : data . toString () ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] writeStringToFile ( file , str , encoding , append ) ;
public static boolean isFileNewer ( final File file , final File reference ) { if ( reference == null ) { throw new IllegalArgumentException ( lr_54 ) ; } if ( ! reference . exists () ) { MST[rv.ROR5Mutator]MSP[N] throw new IllegalArgumentException ( lr_55 + reference + lr_56 ) ; }
final File [] files = verifiedListFiles ( directory ) ; IOException exception = null ; for ( final File file : files ) { MST[rv.UOI4Mutator]MSP[N] try { forceDeleteOnExit ( file ) ; } catch ( final IOException ioe ) { exception = ioe ; } }
public static void moveDirectoryToDirectory ( final File src , final File destDir , final boolean createDestDir ) throws IOException { validateMoveParameters ( src , destDir ) ; if ( ! destDir . exists () && createDestDir ) { MST[rv.ROR5Mutator]MSP[S] destDir . mkdirs () ; }
throw new IOException ( lr_40 + directory ) ; } return files ; } public static boolean waitFor ( final File file , final int seconds ) { final long finishAt = System . currentTimeMillis () + ( seconds * 1000L ) ; MST[rv.AOD1Mutator]MSP[N] boolean wasInterrupted = false ; try {
} else { final File parent = file . getParentFile () ; if ( parent != null ) { if ( ! parent . mkdirs () && ! parent . isDirectory () ) { throw new IOException ( lr_10 + parent + lr_11 ) ; MST[experimental.NakedReceiverMutator]MSP[N] } } }
writeStringToFile ( file , data , Charset . defaultCharset () , false ) ; } @Deprecated public static void writeStringToFile ( final File file , final String data , final boolean append ) throws IOException { writeStringToFile ( file , data , Charset . defaultCharset () , append ) ; MST[rv.UOI2Mutator]MSP[N]
final boolean filePresent = file . exists () ; if ( ! file . delete () ) { if ( ! filePresent ) { throw new FileNotFoundException ( lr_48 + file ) ; } final String message = MST[NonVoidMethodCallMutator]MSP[S] lr_49 + file ; throw new IOException ( message ) ; }
throw new IOException ( lr_29 + srcFile + lr_69 ) ; MST[experimental.NakedReceiverMutator]MSP[N] } if ( destFile . exists () ) { throw new FileExistsException ( lr_27 + destFile + lr_60 ) ; } if ( destFile . isDirectory () ) {
throws IOException { final boolean file1Exists = file1 . exists () ; if ( file1Exists != file2 . exists () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return false ; } if ( ! file1Exists ) { return true ; } if ( file1 . isDirectory () || file2 . isDirectory () ) {
final byte octet = ( byte ) Integer . parseInt ( url . substring ( i + 1 , i + 3 ) , 16 ) ; bytes . put ( octet ) ; MST[rv.UOI3Mutator]MSP[N] i += 3 ;
return isFileNewer ( file , reference . lastModified () ) ; MST[NonVoidMethodCallMutator]MSP[S] } public static boolean isFileNewer ( final File file , final Date date ) { if ( date == null ) { throw new IllegalArgumentException ( lr_57 ) ; }
if ( destDir . isDirectory () == false ) { throw new IOException ( lr_27 + destDir + lr_39 ) ; MST[NonVoidMethodCallMutator]MSP[N] } } else { if ( ! destDir . mkdirs () && ! destDir . isDirectory () ) {
return fileLength > 0 ? IOUtils . toByteArray ( in , fileLength ) : IOUtils . toByteArray ( in ) ; MST[ReturnValsMutator]MSP[N] } } public static List < String > readLines ( final File file , final Charset encoding ) throws IOException {
if ( ! srcDir . isDirectory () ) { throw new IOException ( lr_29 + srcDir + lr_39 ) ; } if ( srcDir . getCanonicalPath () . equals ( destDir . getCanonicalPath () ) ) { MST[rv.ROR2Mutator]MSP[N]
if ( ! destDir . exists () ) { throw new FileNotFoundException ( lr_66 + destDir + MST[experimental.NakedReceiverMutator]MSP[N] lr_67 + createDestDir + lr_68 ) ; } if ( ! destDir . isDirectory () ) { throw new IOException ( lr_27 + destDir + lr_28 ) ; }
public static void moveDirectoryToDirectory ( final File src , final File destDir , final boolean createDestDir ) throws IOException { validateMoveParameters ( src , destDir ) ; if ( ! destDir . exists () && createDestDir ) { destDir . mkdirs () ; MST[NonVoidMethodCallMutator]MSP[S] }
throw new IllegalArgumentException ( MST[experimental.NakedReceiverMutator]MSP[N] lr_25 + url ) ; } files [ i ] = toFile ( url ) ; } } return files ; } public static URL [] toURLs ( final File [] files ) throws IOException {
return lineIterator ( file , null ) ; } public static void writeStringToFile ( final File file , final String data , final Charset encoding ) throws IOException { writeStringToFile ( file , data , encoding , false ) ; MST[VoidMethodCallMutator]MSP[S] }
cleanDirectory ( directory ) ; } if ( ! directory . delete () ) { MST[rv.ROR2Mutator]MSP[N] final String message = lr_44 + directory + lr_22 ; throw new IOException ( message ) ; } } public static boolean deleteQuietly ( final File file ) {
final boolean rename = srcDir . renameTo ( destDir ) ; if ( ! rename ) { if ( destDir . getCanonicalPath () . startsWith ( srcDir . getCanonicalPath () + File . separator ) ) { throw new IOException ( lr_61 + srcDir + lr_62 + destDir ) ; MST[experimental.NakedReceiverMutator]MSP[N]
validateMoveParameters ( srcDir , destDir ) ; if ( ! srcDir . isDirectory () ) { throw new IOException ( lr_29 + srcDir + lr_28 ) ; } if ( destDir . exists () ) { MST[NegateConditionalsMutator]MSP[N] throw new FileExistsException ( lr_27 + destDir + lr_60 ) ; }
} while ( i < n && url . charAt ( i ) == '%' ); MST[rv.UOI3Mutator]MSP[N] continue; } catch ( final RuntimeException e ) { } finally { if ( bytes . position () > 0 ) { bytes . flip () ;
size += sizeOf0 ( file ) ; if ( size < 0 ) { break; } } } return size ; } private static long sizeOf0 ( final File file ) { if ( file . isDirectory () ) { MST[NonVoidMethodCallMutator]MSP[N] return sizeOfDirectory0 ( file ) ; }
throw new IllegalArgumentException ( lr_58 ) ; } if ( ! file . exists () ) { MST[rv.ROR2Mutator]MSP[S] return false ; } return file . lastModified () < timeMillis ; } public static long checksumCRC32 ( final File file ) throws IOException { final CRC32 crc = new CRC32 () ;
} } return size ; } private static BigInteger sizeOfBig0 ( final File fileOrDir ) { if ( fileOrDir . isDirectory () ) { return sizeOfDirectoryBig0 ( fileOrDir ) ; MST[ReturnValsMutator]MSP[S] } return BigInteger . valueOf ( fileOrDir . length () ) ; }
final boolean append ) throws IOException { writeStringToFile ( file , data , Charsets . toCharset ( encoding ) , append ) ; MST[rv.UOI2Mutator]MSP[N] } @Deprecated public static void writeStringToFile ( final File file , final String data ) throws IOException {
throw new IOException ( lr_27 + destFile + lr_69 ) ; } final boolean rename = srcFile . renameTo ( destFile ) ; if ( ! rename ) { copyFile ( srcFile , destFile ) ; if ( ! srcFile . delete () ) { MST[NonVoidMethodCallMutator]MSP[S]
throw new IOException ( lr_5 + file + lr_6 ) ; } if ( file . canRead () == false ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] throw new IOException ( lr_5 + file + lr_7 ) ; } } else { throw new FileNotFoundException ( lr_5 + file + lr_8 ) ; }
throw new IllegalArgumentException ( lr_58 ) ; } if ( ! file . exists () ) { return false ; } return file . lastModified () < timeMillis ; MST[rv.ROR3Mutator]MSP[N] } public static long checksumCRC32 ( final File file ) throws IOException { final CRC32 crc = new CRC32 () ;
} else { final File parent = file . getParentFile () ; if ( parent != null ) { if ( ! parent . mkdirs () && ! parent . isDirectory () ) { MST[rv.ROR4Mutator]MSP[N] throw new IOException ( lr_10 + parent + lr_11 ) ; } } }
public static void write ( final File file , final CharSequence data , final String encoding ) throws IOException { write ( file , data , encoding , false ) ; MST[VoidMethodCallMutator]MSP[S] }
throw new NullPointerException ( lr_26 ) ; } if ( destDir . exists () && destDir . isDirectory () == false ) { MST[rv.ROR5Mutator]MSP[N] throw new IllegalArgumentException ( lr_27 + destDir + lr_28 ) ; }
displaySize = String . valueOf ( size . divide ( ONE_KB_BI ) ) + lr_17 ; MST[experimental.NakedReceiverMutator]MSP[N] } else { displaySize = String . valueOf ( size ) + lr_18 ; } return displaySize ; } public static String byteCountToDisplaySize ( final long size ) {
if ( ! directory . exists () ) { MST[rv.ROR3Mutator]MSP[S] return; } directory . deleteOnExit () ; if ( ! isSymlink ( directory ) ) { cleanDirectoryOnExit ( directory ) ; } } private static void cleanDirectoryOnExit ( final File directory ) throws IOException {
if ( ! file . exists () ) { MST[rv.ROR3Mutator]MSP[N] final String message = file + lr_42 ; throw new IllegalArgumentException ( message ) ; } if ( file . isDirectory () ) { return sizeOfDirectory0 ( file ) ; } return file . length () ; }
} catch ( final Exception ignored ) { return false ; MST[rv.CRCR1Mutator]MSP[S] } } public static boolean directoryContains ( final File directory , final File child ) throws IOException { if ( directory == null ) { throw new IllegalArgumentException ( lr_45 ) ; }
final boolean filePresent = file . exists () ; if ( ! file . delete () ) { if ( ! filePresent ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] throw new FileNotFoundException ( lr_48 + file ) ; } final String message = lr_49 + file ; throw new IOException ( message ) ; }
if ( ! src . exists () ) { MST[rv.ROR5Mutator]MSP[N] throw new FileNotFoundException ( lr_29 + src + lr_8 ) ; } } private static void doCopyDirectory ( final File srcDir , final File destDir , final FileFilter filter , final boolean preserveFileDate , final List < String > exclusionList )
return false ; } return file . lastModified () > timeMillis ; MST[rv.UOI1Mutator]MSP[N] } public static boolean isFileOlder ( final File file , final File reference ) { if ( reference == null ) { throw new IllegalArgumentException ( lr_54 ) ; }
return false ; MST[BooleanTrueReturnValsMutator]MSP[N] } return file . lastModified () > timeMillis ; } public static boolean isFileOlder ( final File file , final File reference ) { if ( reference == null ) { throw new IllegalArgumentException ( lr_54 ) ; }
final File directory , final IOFileFilter fileFilter , final IOFileFilter dirFilter ) { return innerListFilesOrDirectories ( directory , fileFilter , dirFilter , false ) ; MST[rv.CRCR6Mutator]MSP[N] } private static void validateListFilesParameters ( final File directory , final IOFileFilter fileFilter ) { if ( ! directory . isDirectory () ) {
} } public static void forceDeleteOnExit ( final File file ) throws IOException { if ( file . isDirectory () ) { MST[NonVoidMethodCallMutator]MSP[N] deleteDirectoryOnExit ( file ) ; } else { file . deleteOnExit () ; } } private static void deleteDirectoryOnExit ( final File directory ) throws IOException {
final Collection < File > files = new java . util . LinkedList <> () ; if ( includeSubDirectories ) { MST[rv.UOI1Mutator]MSP[N] files . add ( directory ) ; } innerListFiles ( files , directory , FileFilterUtils . or ( effFileFilter , effDirFilter ) , includeSubDirectories ) ; return files ;
public static void moveDirectoryToDirectory ( final File src , final File destDir , final boolean createDestDir ) throws IOException { validateMoveParameters ( src , destDir ) ; if ( ! destDir . exists () && createDestDir ) { MST[rv.ROR2Mutator]MSP[S] destDir . mkdirs () ; }
} public static void copyFile ( final File srcFile , final File destFile , final boolean preserveFileDate ) throws IOException { checkFileRequirements ( srcFile , destFile ) ; if ( srcFile . isDirectory () ) { MST[NonVoidMethodCallMutator]MSP[N] throw new IOException ( lr_29 + srcFile + lr_6 ) ; }
for ( final File srcFile : srcFiles ) { MST[rv.UOI4Mutator]MSP[N] final File copiedFile = new File ( destDir , srcFile . getName () ) ; exclusionList . add ( copiedFile . getCanonicalPath () ) ; } } } doCopyDirectory ( srcDir , destDir , filter , preserveFileDate , exclusionList ) ;
doCopyDirectory ( srcFile , dstFile , filter , preserveFileDate , exclusionList ) ; } else { doCopyFile ( srcFile , dstFile , preserveFileDate ) ; MST[rv.UOI2Mutator]MSP[S] } } } if ( preserveFileDate ) { destDir . setLastModified ( srcDir . lastModified () ) ; } }
while ( ! file . exists () ) { final long remaining = finishAt - System . currentTimeMillis () ; if ( remaining < 0 ) { return false ; } try { Thread . sleep ( Math . min ( 100 , remaining ) ) ; MST[rv.UOI3Mutator]MSP[N]
} } return size ; } private static BigInteger sizeOfBig0 ( final File fileOrDir ) { if ( fileOrDir . isDirectory () ) { MST[rv.ROR1Mutator]MSP[N] return sizeOfDirectoryBig0 ( fileOrDir ) ; } return BigInteger . valueOf ( fileOrDir . length () ) ; }
public static File getUserDirectory () { return new File ( getUserDirectoryPath () ) ; } public static FileInputStream openInputStream ( final File file ) throws IOException { if ( file . exists () ) { MST[rv.ROR4Mutator]MSP[N] if ( file . isDirectory () ) {
final Collection < File > files = new java . util . LinkedList <> () ; if ( includeSubDirectories ) { files . add ( directory ) ; } innerListFiles ( files , directory , FileFilterUtils . or ( effFileFilter , effDirFilter ) , includeSubDirectories ) ; MST[rv.UOI4Mutator]MSP[N] return files ;
return FileFilterUtils . and ( fileFilter , FileFilterUtils . notFileFilter ( DirectoryFileFilter . INSTANCE ) ) ; MST[rv.CRCR4Mutator]MSP[N] } private static IOFileFilter setUpEffectiveDirFilter ( final IOFileFilter dirFilter ) { return dirFilter == null ? FalseFileFilter . INSTANCE : FileFilterUtils . and ( dirFilter , DirectoryFileFilter . INSTANCE ) ; }
displaySize = String . valueOf ( size . divide ( ONE_TB_BI ) ) + lr_14 ; MST[NonVoidMethodCallMutator]MSP[N] } else if ( size . divide ( ONE_GB_BI ) . compareTo ( BigInteger . ZERO ) > 0 ) {
final byte octet = ( byte ) Integer . parseInt ( url . substring ( i + 1 , i + 3 ) , 16 ) ; MST[rv.AOR3Mutator]MSP[N] bytes . put ( octet ) ; i += 3 ;
if ( srcLen != dstLen ) { MST[rv.ROR4Mutator]MSP[S] throw new IOException ( lr_34 + srcFile + lr_35 + destFile + lr_36 + srcLen + lr_37 + dstLen ) ; } } public static void copyDirectoryToDirectory ( final File srcDir , final File destDir ) throws IOException {
if ( ! file . exists () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] final String message = file + lr_42 ; throw new IllegalArgumentException ( message ) ; } if ( file . isDirectory () ) { return sizeOfDirectory0 ( file ) ; } return file . length () ; }
displaySize = String . valueOf ( size . divide ( ONE_TB_BI ) ) + lr_14 ; } else if ( size . divide ( ONE_GB_BI ) . compareTo ( BigInteger . ZERO ) > 0 ) { MST[NegateConditionalsMutator]MSP[N]
displaySize = String . valueOf ( size . divide ( ONE_KB_BI ) ) + lr_17 ; } else { displaySize = String . valueOf ( size ) + lr_18 ; MST[experimental.NakedReceiverMutator]MSP[N] } return displaySize ; } public static String byteCountToDisplaySize ( final long size ) {
for ( final File srcFile : srcFiles ) { final File copiedFile = new File ( destDir , srcFile . getName () ) ; exclusionList . add ( copiedFile . getCanonicalPath () ) ; } } } doCopyDirectory ( srcDir , destDir , filter , preserveFileDate , exclusionList ) ; MST[rv.ABSMutator]MSP[N]
return FileFilterUtils . and ( fileFilter , FileFilterUtils . notFileFilter ( DirectoryFileFilter . INSTANCE ) ) ; MST[rv.CRCR5Mutator]MSP[N] } private static IOFileFilter setUpEffectiveDirFilter ( final IOFileFilter dirFilter ) { return dirFilter == null ? FalseFileFilter . INSTANCE : FileFilterUtils . and ( dirFilter , DirectoryFileFilter . INSTANCE ) ; }
public static BigInteger sizeOfAsBigInteger ( final File file ) { if ( ! file . exists () ) { final String message = file + lr_42 ; throw new IllegalArgumentException ( message ) ; } if ( file . isDirectory () ) { MST[rv.ROR5Mutator]MSP[N] return sizeOfDirectoryBig0 ( file ) ; }
public static String getTempDirectoryPath () { return System . getProperty ( lr_3 ) ; } public static File getTempDirectory () { return new File ( getTempDirectoryPath () ) ; MST[ConstructorCallMutator]MSP[S] } public static String getUserDirectoryPath () { return System . getProperty ( lr_4 ) ; }
if ( ! directory . exists () ) { return; } directory . deleteOnExit () ; if ( ! isSymlink ( directory ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] cleanDirectoryOnExit ( directory ) ; } } private static void cleanDirectoryOnExit ( final File directory ) throws IOException {
File file = null ; for ( final String name : names ) { if ( file == null ) { file = new File ( name ) ; } else { file = new File ( file , name ) ; } } return file ; MST[ReturnValsMutator]MSP[S] }
for ( int i = 0 ; i < urls . length ; i ++ ) { MST[rv.UOI1Mutator]MSP[N] final URL url = urls [ i ] ; if ( url != null ) { if ( url . getProtocol () . equals ( lr_24 ) == false ) {
if ( files == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return BigInteger . ZERO ; } BigInteger size = BigInteger . ZERO ; for ( final File file : files ) { if ( ! isSymlink ( file ) ) { size = size . add ( sizeOfBig0 ( file ) ) ;
if ( date == null ) { MST[rv.ROR5Mutator]MSP[S] throw new IllegalArgumentException ( lr_57 ) ; } return isFileOlder ( file , date . getTime () ) ; } public static boolean isFileOlder ( final File file , final long timeMillis ) { if ( file == null ) {
throws IOException { final boolean file1Exists = file1 . exists () ; if ( file1Exists != file2 . exists () ) { MST[NonVoidMethodCallMutator]MSP[S] return false ; } if ( ! file1Exists ) { return true ; } if ( file1 . isDirectory () || file2 . isDirectory () ) {
if ( files == null ) { return BigInteger . ZERO ; } BigInteger size = BigInteger . ZERO ; for ( final File file : files ) { MST[rv.UOI1Mutator]MSP[N] if ( ! isSymlink ( file ) ) { size = size . add ( sizeOfBig0 ( file ) ) ;
throw new IllegalArgumentException ( lr_20 + directory ) ; } if ( fileFilter == null ) { MST[rv.ROR5Mutator]MSP[N] throw new NullPointerException ( lr_21 ) ; } } private static IOFileFilter setUpEffectiveFileFilter ( final IOFileFilter fileFilter ) {
if ( null != exception ) { throw exception ; } } public static void forceMkdir ( final File directory ) throws IOException { if ( directory . exists () ) { if ( ! directory . isDirectory () ) { MST[rv.ROR3Mutator]MSP[S] final String message = lr_50 + directory + lr_51
final Collection < File > files = new java . util . LinkedList <> () ; if ( includeSubDirectories ) { MST[rv.ROR2Mutator]MSP[N] files . add ( directory ) ; } innerListFiles ( files , directory , FileFilterUtils . or ( effFileFilter , effDirFilter ) , includeSubDirectories ) ; return files ;
final File destFile = new File ( destDir , srcFile . getName () ) ; copyFile ( srcFile , destFile , preserveFileDate ) ; MST[rv.UOI1Mutator]MSP[N] } public static void copyFile ( final File srcFile , final File destFile ) throws IOException { copyFile ( srcFile , destFile , true ) ;
Files . copy ( srcPath , destPath , StandardCopyOption . REPLACE_EXISTING ) ; checkEqualSizes ( srcFile , destFile , Files . size ( srcPath ) , Files . size ( destPath ) ) ; MST[NonVoidMethodCallMutator]MSP[N]
if ( file == null ) { return false ; } try { if ( file . isDirectory () ) { cleanDirectory ( file ) ; } } catch ( final Exception ignored ) { } try { return file . delete () ; MST[NonVoidMethodCallMutator]MSP[N]
if ( file == null ) { return false ; } try { if ( file . isDirectory () ) { MST[rv.ROR4Mutator]MSP[N] cleanDirectory ( file ) ; } } catch ( final Exception ignored ) { } try { return file . delete () ;
throw new IllegalArgumentException ( lr_58 ) ; } if ( ! file . exists () ) { return false ; MST[InlineConstantMutator]MSP[S] } return file . lastModified () < timeMillis ; } public static long checksumCRC32 ( final File file ) throws IOException { final CRC32 crc = new CRC32 () ;
while ( ! file . exists () ) { final long remaining = finishAt - System . currentTimeMillis () ; if ( remaining < 0 ) { return false ; MST[InlineConstantMutator]MSP[N] } try { Thread . sleep ( Math . min ( 100 , remaining ) ) ;
final StringBuilder buffer = new StringBuilder () ; final ByteBuffer bytes = ByteBuffer . allocate ( n ) ; for ( int i = 0 ; i < n ; ) { if ( url . charAt ( i ) == '%' ) { MST[rv.ROR3Mutator]MSP[N] try { do {
} catch ( final InterruptedException ignore ) { wasInterrupted = true ; } catch ( final Exception ex ) { break; } } } finally { if ( wasInterrupted ) { MST[rv.ROR1Mutator]MSP[N] Thread . currentThread () . interrupt () ; } } return true ; }
writeLines ( file , null , lines , lineEnding , append ) ; MST[VoidMethodCallMutator]MSP[N] } public static void forceDelete ( final File file ) throws IOException { if ( file . isDirectory () ) { deleteDirectory ( file ) ; } else {
throw new IOException ( lr_40 + directory ) ; } return files ; } public static boolean waitFor ( final File file , final int seconds ) { final long finishAt = System . currentTimeMillis () + ( seconds * 1000L ) ; MST[rv.AOR3Mutator]MSP[N] boolean wasInterrupted = false ; try {
throw new IOException ( lr_40 + directory ) ; } return files ; } public static boolean waitFor ( final File file , final int seconds ) { final long finishAt = System . currentTimeMillis () + ( seconds * 1000L ) ; MST[NonVoidMethodCallMutator]MSP[N] boolean wasInterrupted = false ; try {
throw new IllegalArgumentException ( lr_58 ) ; } if ( ! file . exists () ) { return false ; } return file . lastModified () < timeMillis ; MST[rv.CRCR3Mutator]MSP[S] } public static long checksumCRC32 ( final File file ) throws IOException { final CRC32 crc = new CRC32 () ;
final boolean file1Exists = file1 . exists () ; if ( file1Exists != file2 . exists () ) { return false ; } if ( ! file1Exists ) { return true ; } if ( file1 . isDirectory () || file2 . isDirectory () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
private static void checkDirectory ( final File directory ) { if ( ! directory . exists () ) { throw new IllegalArgumentException ( directory + lr_42 ) ; MST[ConstructorCallMutator]MSP[N] } if ( ! directory . isDirectory () ) { throw new IllegalArgumentException ( directory + lr_47 ) ; } }
return isFileNewer ( file , date . getTime () ) ; } public static boolean isFileNewer ( final File file , final long timeMillis ) { if ( file == null ) { throw new IllegalArgumentException ( lr_58 ) ; } if ( ! file . exists () ) { MST[rv.ROR4Mutator]MSP[N]
final boolean file1Exists = file1 . exists () ; if ( file1Exists != file2 . exists () ) { return false ; } if ( ! file1Exists ) { return true ; MST[rv.CRCR6Mutator]MSP[S] } if ( file1 . isDirectory () || file2 . isDirectory () ) {
final boolean append ) throws IOException { writeStringToFile ( file , data , Charsets . toCharset ( encoding ) , append ) ; MST[VoidMethodCallMutator]MSP[N] } @Deprecated public static void writeStringToFile ( final File file , final String data ) throws IOException {
displaySize = String . valueOf ( size . divide ( ONE_EB_BI ) ) + lr_12 ; } else if ( size . divide ( ONE_PB_BI ) . compareTo ( BigInteger . ZERO ) > 0 ) { MST[rv.ROR4Mutator]MSP[N]
writeByteArrayToFile ( file , data , off , len , false ) ; MST[VoidMethodCallMutator]MSP[S] } public static void writeByteArrayToFile ( final File file , final byte [] data , final int off , final int len , final boolean append ) throws IOException {
} while ( i < n && url . charAt ( i ) == '%' ); MST[rv.ROR3Mutator]MSP[N] continue; } catch ( final RuntimeException e ) { } finally { if ( bytes . position () > 0 ) { bytes . flip () ;
final File directory , final IOFileFilter fileFilter , final IOFileFilter dirFilter ) { return innerListFilesOrDirectories ( directory , fileFilter , dirFilter , false ) ; } private static void validateListFilesParameters ( final File directory , final IOFileFilter fileFilter ) { if ( ! directory . isDirectory () ) { MST[NonVoidMethodCallMutator]MSP[N]
if ( srcFile . getCanonicalPath () . equals ( destFile . getCanonicalPath () ) ) { throw new IOException ( lr_29 + srcFile + lr_30 + destFile + lr_31 ) ; } final File parentFile = destFile . getParentFile () ; MST[NonVoidMethodCallMutator]MSP[N] if ( parentFile != null ) {
doCopyDirectory ( srcFile , dstFile , filter , preserveFileDate , exclusionList ) ; MST[rv.ABSMutator]MSP[N] } else { doCopyFile ( srcFile , dstFile , preserveFileDate ) ; } } } if ( preserveFileDate ) { destDir . setLastModified ( srcDir . lastModified () ) ; } }
buffer . append ( StandardCharsets . UTF_8 . decode ( bytes ) . toString () ) ; bytes . clear () ; } } } buffer . append ( url . charAt ( i ++ ) ) ; MST[experimental.NakedReceiverMutator]MSP[N] } decoded = buffer . toString () ; } return decoded ;
if ( ! reference . exists () ) { throw new IllegalArgumentException ( lr_55 MST[ConstructorCallMutator]MSP[S] + reference + lr_56 ) ; } return isFileOlder ( file , reference . lastModified () ) ; } public static boolean isFileOlder ( final File file , final Date date ) {
final File [] found = directory . listFiles ( ( FileFilter ) filter ) ; if ( found != null ) { for ( final File file : found ) { if ( file . isDirectory () ) { if ( includeSubDirectories ) { MST[rv.ROR1Mutator]MSP[N]
final Collection < File > files = new java . util . LinkedList <> () ; if ( includeSubDirectories ) { files . add ( directory ) ; } innerListFiles ( files , directory , MST[rv.CRCR1Mutator]MSP[N] FileFilterUtils . or ( effFileFilter , effDirFilter ) , includeSubDirectories ) ; return files ;
return FileFilterUtils . and ( fileFilter , FileFilterUtils . notFileFilter ( DirectoryFileFilter . INSTANCE ) ) ; } private static IOFileFilter setUpEffectiveDirFilter ( final IOFileFilter dirFilter ) { return dirFilter == null ? FalseFileFilter . INSTANCE : FileFilterUtils . and ( dirFilter , MST[rv.CRCR6Mutator]MSP[N] DirectoryFileFilter . INSTANCE ) ; }
final File dstFile = new File ( destDir , srcFile . getName () ) ; if ( exclusionList == null || ! exclusionList . contains ( srcFile . getCanonicalPath () ) ) { if ( srcFile . isDirectory () ) { MST[NegateConditionalsMutator]MSP[N]
public static File getFile ( final File directory , final String ... names ) { if ( directory == null ) { throw new NullPointerException ( lr_1 ) ; } if ( names == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] throw new NullPointerException ( lr_2 ) ; } File file = directory ;
size += sizeOf0 ( file ) ; if ( size < 0 ) { break; } } } return size ; MST[rv.UOI3Mutator]MSP[N] } private static long sizeOf0 ( final File file ) { if ( file . isDirectory () ) { return sizeOfDirectory0 ( file ) ; }
if ( destDir == null ) { throw new NullPointerException ( lr_26 ) ; } if ( destDir . exists () && destDir . isDirectory () == false ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] throw new IllegalArgumentException ( lr_27 + destDir + lr_28 ) ; }
while ( ! file . exists () ) { MST[NegateConditionalsMutator]MSP[N] final long remaining = finishAt - System . currentTimeMillis () ; if ( remaining < 0 ) { return false ; } try { Thread . sleep ( Math . min ( 100 , remaining ) ) ;
throw new IOException ( lr_23 ) ; } if ( file1 . getCanonicalFile () . equals ( file2 . getCanonicalFile () ) ) { return true ; } try ( Reader input1 = charsetName == null MST[NegateConditionalsMutator]MSP[S]
final File [] srcFiles = filter == null ? srcDir . listFiles () : srcDir . listFiles ( filter ) ; if ( srcFiles != null && srcFiles . length > 0 ) { MST[rv.ROR5Mutator]MSP[S] exclusionList = new ArrayList <> ( srcFiles . length ) ;
return isFileNewer ( file , date . getTime () ) ; MST[BooleanFalseReturnValsMutator]MSP[S] } public static boolean isFileNewer ( final File file , final long timeMillis ) { if ( file == null ) { throw new IllegalArgumentException ( lr_58 ) ; } if ( ! file . exists () ) {
if ( srcLen != dstLen ) { throw new IOException ( lr_34 + srcFile + lr_35 + destFile MST[ConstructorCallMutator]MSP[S] + lr_36 + srcLen + lr_37 + dstLen ) ; } } public static void copyDirectoryToDirectory ( final File srcDir , final File destDir ) throws IOException {
throw new IOException ( lr_27 + destFile + lr_69 ) ; } final boolean rename = srcFile . renameTo ( destFile ) ; if ( ! rename ) { copyFile ( srcFile , destFile ) ; if ( ! srcFile . delete () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S]
if ( null != exception ) { throw exception ; } } public static void forceMkdir ( final File directory ) throws IOException { if ( directory . exists () ) { if ( ! directory . isDirectory () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] final String message = lr_50 + directory + lr_51
throw new IllegalArgumentException ( lr_20 + directory ) ; } if ( fileFilter == null ) { throw new NullPointerException ( lr_21 ) ; MST[ConstructorCallMutator]MSP[N] } } private static IOFileFilter setUpEffectiveFileFilter ( final IOFileFilter fileFilter ) {
throw new NullPointerException ( lr_38 ) ; } if ( src . isFile () ) { copyFileToDirectory ( src , destDir ) ; } else if ( src . isDirectory () ) { MST[rv.ROR3Mutator]MSP[S] copyDirectoryToDirectory ( src , destDir ) ; } else {
writeLines ( file , null , lines , lineEnding , append ) ; MST[rv.UOI1Mutator]MSP[N] } public static void forceDelete ( final File file ) throws IOException { if ( file . isDirectory () ) { deleteDirectory ( file ) ; } else {
if ( file . exists () ) { if ( file . isDirectory () ) { throw new IOException ( lr_5 + file + lr_6 ) ; MST[NonVoidMethodCallMutator]MSP[N] } if ( file . canWrite () == false ) { throw new IOException ( lr_5 + file + lr_9 ) ; }
final File [] files = directory . listFiles () ; if ( files == null ) { return 0L ; } long size = 0 ; for ( final File file : files ) { MST[rv.UOI4Mutator]MSP[N] if ( ! isSymlink ( file ) ) {
moveFileToDirectory ( src , destDir , createDestDir ) ; } } private static void validateMoveParameters ( final File src , final File dest ) throws FileNotFoundException { if ( src == null ) { throw new NullPointerException ( lr_38 ) ; MST[ConstructorCallMutator]MSP[N] } if ( dest == null ) {
} public static Iterator < File > iterateFiles ( final File directory , final IOFileFilter fileFilter , final IOFileFilter dirFilter ) { return listFiles ( directory , fileFilter , dirFilter ) . iterator () ; MST[NonVoidMethodCallMutator]MSP[S] }
+ lr_52 ; throw new IOException ( message ) ; } } else { if ( ! directory . mkdirs () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] if ( ! directory . isDirectory () ) { final String message = lr_53 + directory ; throw new IOException ( message ) ; } } }
public static void moveDirectoryToDirectory ( final File src , final File destDir , final boolean createDestDir ) throws IOException { validateMoveParameters ( src , destDir ) ; if ( ! destDir . exists () && createDestDir ) { MST[rv.UOI2Mutator]MSP[N] destDir . mkdirs () ; }
final File [] files = verifiedListFiles ( directory ) ; IOException exception = null ; for ( final File file : files ) { MST[rv.UOI1Mutator]MSP[S] try { forceDeleteOnExit ( file ) ; } catch ( final IOException ioe ) { exception = ioe ; } }
throws IOException { final boolean file1Exists = file1 . exists () ; if ( file1Exists != file2 . exists () ) { return false ; } if ( ! file1Exists ) { MST[rv.UOI1Mutator]MSP[N] return true ; } if ( file1 . isDirectory () || file2 . isDirectory () ) {
if ( ! directory . isDirectory () ) { throw new IllegalArgumentException ( lr_46 + directory ) ; } if ( child == null ) { return false ; MST[BooleanTrueReturnValsMutator]MSP[S] } if ( ! directory . exists () || ! child . exists () ) { return false ; }
return false ; } return file . lastModified () > timeMillis ; } public static boolean isFileOlder ( final File file , final File reference ) { if ( reference == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] throw new IllegalArgumentException ( lr_54 ) ; }
File file = null ; for ( final String name : names ) { if ( file == null ) { MST[rv.ROR5Mutator]MSP[S] file = new File ( name ) ; } else { file = new File ( file , name ) ; } } return file ; }
while ( ! file . exists () ) { MST[rv.ROR1Mutator]MSP[N] final long remaining = finishAt - System . currentTimeMillis () ; if ( remaining < 0 ) { return false ; } try { Thread . sleep ( Math . min ( 100 , remaining ) ) ;
final File directory , final IOFileFilter fileFilter , final IOFileFilter dirFilter ) { return innerListFilesOrDirectories ( directory , fileFilter , dirFilter , false ) ; } private static void validateListFilesParameters ( final File directory , final IOFileFilter fileFilter ) { if ( ! directory . isDirectory () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
if ( ! destDir . isDirectory () ) { throw new IOException ( lr_27 + destDir + lr_28 ) ; MST[experimental.NakedReceiverMutator]MSP[N] } moveFile ( srcFile , new File ( destDir , srcFile . getName () ) ) ; }
final int connectionTimeout , final int readTimeout ) throws IOException { final URLConnection connection = source . openConnection () ; connection . setConnectTimeout ( connectionTimeout ) ; connection . setReadTimeout ( readTimeout ) ; MST[rv.ABSMutator]MSP[S] copyInputStreamToFile ( connection . getInputStream () , destination ) ; }
throw new IOException ( lr_27 + destFile + lr_69 ) ; } final boolean rename = srcFile . renameTo ( destFile ) ; if ( ! rename ) { MST[rv.ROR4Mutator]MSP[N] copyFile ( srcFile , destFile ) ; if ( ! srcFile . delete () ) {
final boolean rename = srcDir . renameTo ( destDir ) ; if ( ! rename ) { MST[rv.UOI3Mutator]MSP[N] if ( destDir . getCanonicalPath () . startsWith ( srcDir . getCanonicalPath () + File . separator ) ) { throw new IOException ( lr_61 + srcDir + lr_62 + destDir ) ;
throw new IOException ( lr_27 + destFile + lr_69 ) ; } final boolean rename = srcFile . renameTo ( destFile ) ; if ( ! rename ) { MST[rv.UOI3Mutator]MSP[N] copyFile ( srcFile , destFile ) ; if ( ! srcFile . delete () ) {
final File [] found = directory . listFiles ( ( FileFilter ) filter ) ; if ( found != null ) { for ( final File file : found ) { MST[rv.UOI4Mutator]MSP[N] if ( file . isDirectory () ) { if ( includeSubDirectories ) {
throw new IOException ( lr_29 + srcDir + lr_30 + destDir + lr_31 ) ; MST[NonVoidMethodCallMutator]MSP[N] } List < String > exclusionList = null ; if ( destDir . getCanonicalPath () . startsWith ( srcDir . getCanonicalPath () ) ) {
} while ( i < n && url . charAt ( i ) == '%' ); continue; } catch ( final RuntimeException e ) { } finally { if ( bytes . position () > 0 ) { MST[rv.ROR1Mutator]MSP[N] bytes . flip () ;
if ( url == null || ! lr_24 . equalsIgnoreCase ( url . getProtocol () ) ) { return null ; } String filename = url . getFile () . replace ( '/' , File . separatorChar ) ; MST[rv.CRCR5Mutator]MSP[N] filename = decodeUrl ( filename ) ;
if ( url == null || ! lr_24 . equalsIgnoreCase ( url . getProtocol () ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] return null ; } String filename = url . getFile () . replace ( '/' , File . separatorChar ) ; filename = decodeUrl ( filename ) ;
if ( destDir . isDirectory () == false ) { throw new IOException ( lr_27 + destDir + lr_39 ) ; } } else { if ( ! destDir . mkdirs () && ! destDir . isDirectory () ) { MST[rv.ROR4Mutator]MSP[N]
throw new IllegalArgumentException ( lr_58 ) ; } if ( ! file . exists () ) { return false ; MST[rv.CRCR1Mutator]MSP[S] } return file . lastModified () < timeMillis ; } public static long checksumCRC32 ( final File file ) throws IOException { final CRC32 crc = new CRC32 () ;
final File dstFile = new File ( destDir , srcFile . getName () ) ; if ( exclusionList == null || ! exclusionList . contains ( srcFile . getCanonicalPath () ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] if ( srcFile . isDirectory () ) {
if ( srcFile . getCanonicalPath () . equals ( destFile . getCanonicalPath () ) ) { throw new IOException ( lr_29 + srcFile + lr_30 + destFile + lr_31 ) ; MST[NonVoidMethodCallMutator]MSP[S] } final File parentFile = destFile . getParentFile () ; if ( parentFile != null ) {
if ( file . exists () ) { if ( file . isDirectory () ) { throw new IOException ( lr_5 + file + lr_6 ) ; } if ( file . canWrite () == false ) { MST[rv.ROR5Mutator]MSP[N] throw new IOException ( lr_5 + file + lr_9 ) ; }
try ( InputStream in = openInputStream ( file ) ) { return IOUtils . readLines ( in , Charsets . toCharset ( encoding ) ) ; MST[NonVoidMethodCallMutator]MSP[S] } } public static List < String > readLines ( final File file , final String encoding ) throws IOException {
final boolean append ) throws IOException { try ( OutputStream out = openOutputStream ( file , append ) ) { MST[NonVoidMethodCallMutator]MSP[N] IOUtils . write ( data , out , encoding ) ; } } public static void writeStringToFile ( final File file , final String data , final String encoding ,
for ( final String name : names ) { MST[rv.UOI3Mutator]MSP[S] file = new File ( file , name ) ; } return file ; } public static File getFile ( final String ... names ) { if ( names == null ) { throw new NullPointerException ( lr_2 ) ; }
if ( ! directory . isDirectory () ) { MST[rv.ROR2Mutator]MSP[N] throw new IllegalArgumentException ( lr_46 + directory ) ; } if ( child == null ) { return false ; } if ( ! directory . exists () || ! child . exists () ) { return false ; }
throw new IOException ( lr_5 + file + lr_6 ) ; MST[NonVoidMethodCallMutator]MSP[S] } if ( file . canRead () == false ) { throw new IOException ( lr_5 + file + lr_7 ) ; } } else { throw new FileNotFoundException ( lr_5 + file + lr_8 ) ; }
displaySize = String . valueOf ( size . divide ( ONE_EB_BI ) ) + lr_12 ; MST[NonVoidMethodCallMutator]MSP[N] } else if ( size . divide ( ONE_PB_BI ) . compareTo ( BigInteger . ZERO ) > 0 ) {
return false ; } return file . lastModified () > timeMillis ; MST[rv.ROR5Mutator]MSP[N] } public static boolean isFileOlder ( final File file , final File reference ) { if ( reference == null ) { throw new IllegalArgumentException ( lr_54 ) ; }
displaySize = String . valueOf ( size . divide ( ONE_TB_BI ) ) + lr_14 ; } else if ( size . divide ( ONE_GB_BI ) . compareTo ( BigInteger . ZERO ) > 0 ) { MST[experimental.BigIntegerMutator]MSP[N]
throw new IOException ( lr_5 + file + lr_6 ) ; } if ( file . canRead () == false ) { throw new IOException ( lr_5 + file + lr_7 ) ; } } else { throw new FileNotFoundException ( lr_5 + file + lr_8 ) ; MST[ConstructorCallMutator]MSP[N] }
throw new NullPointerException ( lr_26 ) ; } if ( ! src . exists () ) { throw new FileNotFoundException ( lr_29 + src + lr_8 ) ; MST[experimental.NakedReceiverMutator]MSP[N] } } public static boolean isSymlink ( final File file ) { if ( file == null ) {
displaySize = String . valueOf ( size . divide ( ONE_TB_BI ) ) + lr_14 ; MST[experimental.NakedReceiverMutator]MSP[N] } else if ( size . divide ( ONE_GB_BI ) . compareTo ( BigInteger . ZERO ) > 0 ) {
final File [] files = directory . listFiles () ; if ( files == null ) { return 0L ; } long size = 0 ; for ( final File file : files ) { MST[rv.UOI3Mutator]MSP[N] if ( ! isSymlink ( file ) ) {
if ( file . exists () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] if ( file . isDirectory () ) { throw new IOException ( lr_5 + file + lr_6 ) ; } if ( file . canWrite () == false ) { throw new IOException ( lr_5 + file + lr_9 ) ; }
final boolean append ) throws IOException { writeStringToFile ( file , data , Charsets . toCharset ( encoding ) , append ) ; MST[NonVoidMethodCallMutator]MSP[N] } @Deprecated public static void writeStringToFile ( final File file , final String data ) throws IOException {
for ( final File srcFile : srcFiles ) { MST[rv.UOI1Mutator]MSP[N] final File copiedFile = new File ( destDir , srcFile . getName () ) ; exclusionList . add ( copiedFile . getCanonicalPath () ) ; } } } doCopyDirectory ( srcDir , destDir , filter , preserveFileDate , exclusionList ) ;
private static void checkDirectory ( final File directory ) { if ( ! directory . exists () ) { throw new IllegalArgumentException ( directory + lr_42 ) ; } if ( ! directory . isDirectory () ) { MST[rv.ROR5Mutator]MSP[N] throw new IllegalArgumentException ( directory + lr_47 ) ; } }
if ( ! destDir . exists () ) { throw new FileNotFoundException ( lr_66 + destDir + lr_67 + createDestDir + lr_68 ) ; } if ( ! destDir . isDirectory () ) { MST[rv.ROR4Mutator]MSP[N] throw new IOException ( lr_27 + destDir + lr_28 ) ; }
displaySize = String . valueOf ( size . divide ( ONE_PB_BI ) ) + lr_13 ; } else if ( size . divide ( ONE_TB_BI ) . compareTo ( BigInteger . ZERO ) > 0 ) { MST[rv.ROR1Mutator]MSP[N]
while ( ! file . exists () ) { final long remaining = finishAt - System . currentTimeMillis () ; if ( remaining < 0 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] return false ; } try { Thread . sleep ( Math . min ( 100 , remaining ) ) ;
validateMoveParameters ( srcFile , destDir ) ; if ( ! destDir . exists () && createDestDir ) { destDir . mkdirs () ; } if ( ! destDir . exists () ) { throw new FileNotFoundException ( lr_66 + destDir + MST[rv.UOI4Mutator]MSP[N] lr_67 + createDestDir + lr_68 ) ; }
} while ( i < n && url . charAt ( i ) == '%' ); MST[rv.CRCR4Mutator]MSP[S] continue; } catch ( final RuntimeException e ) { } finally { if ( bytes . position () > 0 ) { bytes . flip () ;
size += sizeOf0 ( file ) ; if ( size < 0 ) { MST[rv.UOI4Mutator]MSP[N] break; } } } return size ; } private static long sizeOf0 ( final File file ) { if ( file . isDirectory () ) { return sizeOfDirectory0 ( file ) ; }
throw new IOException ( lr_29 + srcDir + lr_30 + destDir + lr_31 ) ; MST[experimental.NakedReceiverMutator]MSP[N] } List < String > exclusionList = null ; if ( destDir . getCanonicalPath () . startsWith ( srcDir . getCanonicalPath () ) ) {
return new File ( filename ) ; } static String decodeUrl ( final String url ) { String decoded = url ; if ( url != null && url . indexOf ( '%' ) >= 0 ) { MST[rv.ROR4Mutator]MSP[S] final int n = url . length () ;
writeLines ( file , encoding , lines , null , append ) ; MST[rv.UOI1Mutator]MSP[N] } public static void writeLines ( final File file , final Collection < ? > lines ) throws IOException { writeLines ( file , null , lines , null , false ) ; }
final String [] suffixes = new String [ extensions . length ] ; for ( int i = 0 ; i < extensions . length ; i ++ ) { suffixes [ i ] = lr_22 + extensions [ i ] ; } return suffixes ; MST[ReturnValsMutator]MSP[N] }
return new File ( filename ) ; } static String decodeUrl ( final String url ) { String decoded = url ; if ( url != null && url . indexOf ( '%' ) >= 0 ) { MST[rv.ROR1Mutator]MSP[S] final int n = url . length () ;
public static void writeStringToFile ( final File file , final String data , final String encoding ) throws IOException { writeStringToFile ( file , data , encoding , false ) ; MST[InlineConstantMutator]MSP[N] } public static void writeStringToFile ( final File file , final String data , final Charset encoding ,
public static String readFileToString ( final File file , final Charset encoding ) throws IOException { try ( InputStream in = openInputStream ( file ) ) { return IOUtils . toString ( in , Charsets . toCharset ( encoding ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } }
final File [] found = directory . listFiles ( ( FileFilter ) filter ) ; if ( found != null ) { for ( final File file : found ) { if ( file . isDirectory () ) { if ( includeSubDirectories ) { MST[rv.UOI3Mutator]MSP[N]
validateMoveParameters ( srcDir , destDir ) ; if ( ! srcDir . isDirectory () ) { throw new IOException ( lr_29 + srcDir + lr_28 ) ; MST[NonVoidMethodCallMutator]MSP[N] } if ( destDir . exists () ) { throw new FileExistsException ( lr_27 + destDir + lr_60 ) ; }
displaySize = String . valueOf ( size . divide ( ONE_KB_BI ) ) + lr_17 ; } else { displaySize = String . valueOf ( size ) + lr_18 ; MST[NonVoidMethodCallMutator]MSP[N] } return displaySize ; } public static String byteCountToDisplaySize ( final long size ) {
final String [] suffixes = toSuffixes ( extensions ) ; filter = new SuffixFileFilter ( suffixes ) ; } return listFiles ( directory , filter , MST[rv.ROR2Mutator]MSP[N] recursive ? TrueFileFilter . INSTANCE : FalseFileFilter . INSTANCE ) ; } public static Iterator < File > iterateFiles (
if ( srcLen != dstLen ) { MST[rv.ROR1Mutator]MSP[N] throw new IOException ( lr_34 + srcFile + lr_35 + destFile + lr_36 + srcLen + lr_37 + dstLen ) ; } } public static void copyDirectoryToDirectory ( final File srcDir , final File destDir ) throws IOException {
final String [] suffixes = new String [ extensions . length ] ; for ( int i = 0 ; i < extensions . length ; i ++ ) { suffixes [ i ] = lr_22 + extensions [ i ] ; MST[rv.UOI3Mutator]MSP[N] } return suffixes ; }
throw new NullPointerException ( lr_26 ) ; } if ( ! src . exists () ) { throw new FileNotFoundException ( lr_29 + src + lr_8 ) ; MST[ConstructorCallMutator]MSP[N] } } public static boolean isSymlink ( final File file ) { if ( file == null ) {
validateMoveParameters ( srcFile , destDir ) ; if ( ! destDir . exists () && createDestDir ) { destDir . mkdirs () ; } if ( ! destDir . exists () ) { throw new FileNotFoundException ( lr_66 + destDir + MST[rv.UOI1Mutator]MSP[N] lr_67 + createDestDir + lr_68 ) ; }
displaySize = String . valueOf ( size . divide ( ONE_PB_BI ) ) + lr_13 ; MST[ArgumentPropagationMutator]MSP[N] } else if ( size . divide ( ONE_TB_BI ) . compareTo ( BigInteger . ZERO ) > 0 ) {
private static void checkDirectory ( final File directory ) { if ( ! directory . exists () ) { MST[rv.ROR4Mutator]MSP[N] throw new IllegalArgumentException ( directory + lr_42 ) ; } if ( ! directory . isDirectory () ) { throw new IllegalArgumentException ( directory + lr_47 ) ; } }
return new FileInputStream ( file ) ; } public static FileOutputStream openOutputStream ( final File file ) throws IOException { return openOutputStream ( file , false ) ; MST[rv.CRCR1Mutator]MSP[N] } public static FileOutputStream openOutputStream ( final File file , final boolean append ) throws IOException {
if ( srcDir == null ) { throw new NullPointerException ( lr_38 ) ; } if ( srcDir . exists () && srcDir . isDirectory () == false ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] throw new IllegalArgumentException ( lr_29 + destDir + lr_28 ) ; } if ( destDir == null ) {
} private static void checkFileRequirements ( final File src , final File dest ) throws FileNotFoundException { if ( src == null ) { MST[rv.ROR5Mutator]MSP[N] throw new NullPointerException ( lr_38 ) ; } if ( dest == null ) { throw new NullPointerException ( lr_26 ) ; }
public static File getFile ( final File directory , final String ... names ) { if ( directory == null ) { throw new NullPointerException ( lr_1 ) ; MST[ConstructorCallMutator]MSP[N] } if ( names == null ) { throw new NullPointerException ( lr_2 ) ; } File file = directory ;
public static File getUserDirectory () { return new File ( getUserDirectoryPath () ) ; } public static FileInputStream openInputStream ( final File file ) throws IOException { if ( file . exists () ) { if ( file . isDirectory () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
return false ; MST[rv.CRCR6Mutator]MSP[N] } return file . lastModified () > timeMillis ; } public static boolean isFileOlder ( final File file , final File reference ) { if ( reference == null ) { throw new IllegalArgumentException ( lr_54 ) ; }
public static void moveDirectoryToDirectory ( final File src , final File destDir , final boolean createDestDir ) throws IOException { validateMoveParameters ( src , destDir ) ; if ( ! destDir . exists () && createDestDir ) { MST[rv.ROR3Mutator]MSP[S] destDir . mkdirs () ; }
} } public static void forceDeleteOnExit ( final File file ) throws IOException { if ( file . isDirectory () ) { deleteDirectoryOnExit ( file ) ; } else { file . deleteOnExit () ; MST[VoidMethodCallMutator]MSP[S] } } private static void deleteDirectoryOnExit ( final File directory ) throws IOException {
return false ; MST[rv.CRCR3Mutator]MSP[N] } return file . lastModified () > timeMillis ; } public static boolean isFileOlder ( final File file , final File reference ) { if ( reference == null ) { throw new IllegalArgumentException ( lr_54 ) ; }
if ( ! srcDir . isDirectory () ) { throw new IOException ( lr_29 + srcDir + lr_39 ) ; MST[NonVoidMethodCallMutator]MSP[S] } if ( srcDir . getCanonicalPath () . equals ( destDir . getCanonicalPath () ) ) {
throw new IOException ( lr_29 + srcDir + lr_30 + destDir + lr_31 ) ; MST[ConstructorCallMutator]MSP[S] } List < String > exclusionList = null ; if ( destDir . getCanonicalPath () . startsWith ( srcDir . getCanonicalPath () ) ) {
return new File ( filename ) ; } static String decodeUrl ( final String url ) { String decoded = url ; if ( url != null && url . indexOf ( '%' ) >= 0 ) { MST[InlineConstantMutator]MSP[N] final int n = url . length () ;
throw new IOException ( lr_40 + directory ) ; } return files ; } public static boolean waitFor ( final File file , final int seconds ) { final long finishAt = System . currentTimeMillis () + ( seconds * 1000L ) ; MST[rv.UOI1Mutator]MSP[N] boolean wasInterrupted = false ; try {
throw new IOException ( lr_40 + directory ) ; } return files ; } public static boolean waitFor ( final File file , final int seconds ) { final long finishAt = System . currentTimeMillis () + ( seconds * 1000L ) ; MST[rv.UOI4Mutator]MSP[N] boolean wasInterrupted = false ; try {
} public static File [] toFiles ( final URL [] urls ) { if ( urls == null || urls . length == 0 ) { MST[rv.ROR1Mutator]MSP[N] return EMPTY_FILE_ARRAY ; } final File [] files = new File [ urls . length ] ;
if ( ! srcDir . isDirectory () ) { MST[rv.ROR4Mutator]MSP[N] throw new IOException ( lr_29 + srcDir + lr_39 ) ; } if ( srcDir . getCanonicalPath () . equals ( destDir . getCanonicalPath () ) ) {
validateMoveParameters ( srcDir , destDir ) ; if ( ! srcDir . isDirectory () ) { throw new IOException ( lr_29 + srcDir + lr_28 ) ; } if ( destDir . exists () ) { throw new FileExistsException ( lr_27 + destDir + lr_60 ) ; MST[NonVoidMethodCallMutator]MSP[S] }
throw new IOException ( lr_27 + destFile + lr_69 ) ; } final boolean rename = srcFile . renameTo ( destFile ) ; if ( ! rename ) { MST[rv.ROR1Mutator]MSP[N] copyFile ( srcFile , destFile ) ; if ( ! srcFile . delete () ) {
final boolean append ) throws IOException { try ( OutputStream out = openOutputStream ( file , append ) ) { IOUtils . write ( data , out , encoding ) ; MST[VoidMethodCallMutator]MSP[N] } } public static void writeStringToFile ( final File file , final String data , final String encoding ,
buffer . append ( StandardCharsets . UTF_8 . decode ( bytes ) . toString () ) ; bytes . clear () ; } } } buffer . append ( url . charAt ( i ++ ) ) ; MST[rv.ABSMutator]MSP[N] } decoded = buffer . toString () ; } return decoded ;
for ( final File src : srcs ) { copyFileToDirectory ( src , destDir ) ; } } public static void deleteDirectory ( final File directory ) throws IOException { if ( ! directory . exists () ) { return; } if ( ! isSymlink ( directory ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
final File directory , final IOFileFilter fileFilter , final IOFileFilter dirFilter ) { return innerListFilesOrDirectories ( directory , fileFilter , dirFilter , false ) ; MST[EmptyObjectReturnValsMutator]MSP[N] } private static void validateListFilesParameters ( final File directory , final IOFileFilter fileFilter ) { if ( ! directory . isDirectory () ) {
final String [] suffixes = toSuffixes ( extensions ) ; filter = new SuffixFileFilter ( suffixes ) ; } return listFiles ( directory , filter , MST[rv.UOI2Mutator]MSP[N] recursive ? TrueFileFilter . INSTANCE : FalseFileFilter . INSTANCE ) ; } public static Iterator < File > iterateFiles (
return false ; } return file . lastModified () > timeMillis ; MST[rv.CRCR5Mutator]MSP[N] } public static boolean isFileOlder ( final File file , final File reference ) { if ( reference == null ) { throw new IllegalArgumentException ( lr_54 ) ; }
writeByteArrayToFile ( file , data , 0 , data . length , append ) ; MST[rv.CRCR5Mutator]MSP[N] } public static void writeByteArrayToFile ( final File file , final byte [] data , final int off , final int len ) throws IOException {
displaySize = String . valueOf ( size . divide ( ONE_GB_BI ) ) + lr_15 ; } else if ( size . divide ( ONE_MB_BI ) . compareTo ( BigInteger . ZERO ) > 0 ) { MST[NegateConditionalsMutator]MSP[N]
public static boolean isFileNewer ( final File file , final File reference ) { if ( reference == null ) { throw new IllegalArgumentException ( lr_54 ) ; } if ( ! reference . exists () ) { throw new IllegalArgumentException ( lr_55 MST[ConstructorCallMutator]MSP[S] + reference + lr_56 ) ; }
files . add ( file ) ; } innerListFiles ( files , file , filter , includeSubDirectories ) ; MST[rv.UOI2Mutator]MSP[N] } else { files . add ( file ) ; } } } } public static Collection < File > listFiles (
writeLines ( file , null , lines , lineEnding , append ) ; MST[rv.UOI4Mutator]MSP[N] } public static void forceDelete ( final File file ) throws IOException { if ( file . isDirectory () ) { deleteDirectory ( file ) ; } else {
validateMoveParameters ( srcFile , destDir ) ; if ( ! destDir . exists () && createDestDir ) { MST[rv.UOI1Mutator]MSP[N] destDir . mkdirs () ; } if ( ! destDir . exists () ) { throw new FileNotFoundException ( lr_66 + destDir + lr_67 + createDestDir + lr_68 ) ; }
public static File getFile ( final File directory , final String ... names ) { if ( directory == null ) { throw new NullPointerException ( lr_1 ) ; } if ( names == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] throw new NullPointerException ( lr_2 ) ; } File file = directory ;
for ( final String name : names ) { file = new File ( file , name ) ; MST[ConstructorCallMutator]MSP[S] } return file ; } public static File getFile ( final String ... names ) { if ( names == null ) { throw new NullPointerException ( lr_2 ) ; }
final File [] files = directory . listFiles () ; if ( files == null ) { return 0L ; } long size = 0 ; for ( final File file : files ) { MST[rv.UOI1Mutator]MSP[N] if ( ! isSymlink ( file ) ) {
doCopyDirectory ( srcFile , dstFile , filter , preserveFileDate , exclusionList ) ; MST[rv.UOI2Mutator]MSP[S] } else { doCopyFile ( srcFile , dstFile , preserveFileDate ) ; } } } if ( preserveFileDate ) { destDir . setLastModified ( srcDir . lastModified () ) ; } }
if ( ! destDir . exists () ) { throw new FileNotFoundException ( lr_66 + destDir + MST[experimental.NakedReceiverMutator]MSP[N] lr_67 + createDestDir + lr_68 ) ; } if ( ! destDir . isDirectory () ) { throw new IOException ( lr_27 + destDir + lr_28 ) ; }
} copyDirectory ( srcDir , destDir ) ; deleteDirectory ( srcDir ) ; if ( srcDir . exists () ) { MST[rv.ROR3Mutator]MSP[S] throw new IOException ( lr_63 + srcDir + lr_64 + destDir + lr_65 ) ; } } }
size += sizeOf0 ( file ) ; if ( size < 0 ) { MST[rv.UOI1Mutator]MSP[N] break; } } } return size ; } private static long sizeOf0 ( final File file ) { if ( file . isDirectory () ) { return sizeOfDirectory0 ( file ) ; }
while ( ! file . exists () ) { final long remaining = finishAt - System . currentTimeMillis () ; if ( remaining < 0 ) { MST[rv.ROR5Mutator]MSP[N] return false ; } try { Thread . sleep ( Math . min ( 100 , remaining ) ) ;
try ( InputStream in = new CheckedInputStream ( new FileInputStream ( file ) , checksum ) ) { MST[ConstructorCallMutator]MSP[N] IOUtils . copy ( in , new NullOutputStream () ) ; } return checksum ; } public static void moveDirectory ( final File srcDir , final File destDir ) throws IOException {
public static File getUserDirectory () { return new File ( getUserDirectoryPath () ) ; MST[NullReturnValsMutator]MSP[S] } public static FileInputStream openInputStream ( final File file ) throws IOException { if ( file . exists () ) { if ( file . isDirectory () ) {
return isFileNewer ( file , reference . lastModified () ) ; } public static boolean isFileNewer ( final File file , final Date date ) { if ( date == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] throw new IllegalArgumentException ( lr_57 ) ; }
if ( file . exists () ) { if ( file . isDirectory () ) { throw new IOException ( lr_5 + file + lr_6 ) ; } if ( file . canWrite () == false ) { MST[rv.ROR2Mutator]MSP[N] throw new IOException ( lr_5 + file + lr_9 ) ; }
throws IOException { final boolean file1Exists = file1 . exists () ; if ( file1Exists != file2 . exists () ) { MST[rv.UOI3Mutator]MSP[S] return false ; } if ( ! file1Exists ) { return true ; } if ( file1 . isDirectory () || file2 . isDirectory () ) {
validateMoveParameters ( srcFile , destDir ) ; if ( ! destDir . exists () && createDestDir ) { MST[rv.ROR4Mutator]MSP[N] destDir . mkdirs () ; } if ( ! destDir . exists () ) { throw new FileNotFoundException ( lr_66 + destDir + lr_67 + createDestDir + lr_68 ) ; }
buffer . append ( StandardCharsets . UTF_8 . decode ( bytes ) . toString () ) ; MST[NonVoidMethodCallMutator]MSP[S] bytes . clear () ; } } } buffer . append ( url . charAt ( i ++ ) ) ; } decoded = buffer . toString () ; } return decoded ;
final StringBuilder buffer = new StringBuilder () ; final ByteBuffer bytes = ByteBuffer . allocate ( n ) ; MST[rv.ABSMutator]MSP[N] for ( int i = 0 ; i < n ; ) { if ( url . charAt ( i ) == '%' ) { try { do {
final URL [] urls = new URL [ files . length ] ; for ( int i = 0 ; i < urls . length ; i ++ ) { urls [ i ] = files [ i ] . toURI () . toURL () ; MST[rv.UOI3Mutator]MSP[S] } return urls ;
while ( ! file . exists () ) { final long remaining = finishAt - System . currentTimeMillis () ; if ( remaining < 0 ) { return false ; MST[rv.UOI4Mutator]MSP[N] } try { Thread . sleep ( Math . min ( 100 , remaining ) ) ;
return FileFilterUtils . and ( fileFilter , FileFilterUtils . notFileFilter ( DirectoryFileFilter . INSTANCE ) ) ; } private static IOFileFilter setUpEffectiveDirFilter ( final IOFileFilter dirFilter ) { return dirFilter == null ? FalseFileFilter . INSTANCE : FileFilterUtils . and ( dirFilter , MST[ReturnValsMutator]MSP[N] DirectoryFileFilter . INSTANCE ) ; }
private static void checkDirectory ( final File directory ) { if ( ! directory . exists () ) { throw new IllegalArgumentException ( directory + lr_42 ) ; } if ( ! directory . isDirectory () ) { MST[rv.ROR2Mutator]MSP[N] throw new IllegalArgumentException ( directory + lr_47 ) ; } }
displaySize = String . valueOf ( size . divide ( ONE_GB_BI ) ) + lr_15 ; MST[NonVoidMethodCallMutator]MSP[N] } else if ( size . divide ( ONE_MB_BI ) . compareTo ( BigInteger . ZERO ) > 0 ) {
return FileFilterUtils . and ( fileFilter , FileFilterUtils . notFileFilter ( DirectoryFileFilter . INSTANCE ) ) ; } private static IOFileFilter setUpEffectiveDirFilter ( final IOFileFilter dirFilter ) { return dirFilter == null ? FalseFileFilter . INSTANCE : FileFilterUtils . and ( dirFilter , MST[NonVoidMethodCallMutator]MSP[N] DirectoryFileFilter . INSTANCE ) ; }
throw new IOException ( lr_23 ) ; } if ( file1 . length () != file2 . length () ) { return false ; } if ( file1 . getCanonicalFile () . equals ( file2 . getCanonicalFile () ) ) { MST[NonVoidMethodCallMutator]MSP[N] return true ; }
if ( destDir . isDirectory () == false ) { throw new IOException ( lr_27 + destDir + lr_39 ) ; } } else { if ( ! destDir . mkdirs () && ! destDir . isDirectory () ) { MST[rv.ROR1Mutator]MSP[N]
final byte octet = ( byte ) Integer . parseInt ( url . substring ( i + 1 , i + 3 ) , 16 ) ; MST[InlineConstantMutator]MSP[N] bytes . put ( octet ) ; i += 3 ;
public static boolean isFileNewer ( final File file , final File reference ) { if ( reference == null ) { MST[NegateConditionalsMutator]MSP[N] throw new IllegalArgumentException ( lr_54 ) ; } if ( ! reference . exists () ) { throw new IllegalArgumentException ( lr_55 + reference + lr_56 ) ; }
public static void writeStringToFile ( final File file , final String data , final String encoding ) throws IOException { writeStringToFile ( file , data , encoding , false ) ; MST[rv.CRCR1Mutator]MSP[N] } public static void writeStringToFile ( final File file , final String data , final Charset encoding ,
} public static void write ( final File file , final CharSequence data , final String encoding , final boolean append ) throws IOException { write ( file , data , Charsets . toCharset ( encoding ) , append ) ; MST[rv.ABSMutator]MSP[N] }
checksum ( file , crc ) ; MST[NonVoidMethodCallMutator]MSP[S] return crc . getValue () ; } public static Checksum checksum ( final File file , final Checksum checksum ) throws IOException { if ( file . isDirectory () ) { throw new IllegalArgumentException ( lr_59 ) ; }
throw new IOException ( lr_27 + destDir + lr_32 ) ; } } if ( destDir . canWrite () == false ) { MST[NegateConditionalsMutator]MSP[N] throw new IOException ( lr_27 + destDir + lr_9 ) ; } for ( final File srcFile : srcFiles ) {
final File [] files = directory . listFiles () ; if ( files == null ) { return 0L ; } long size = 0 ; for ( final File file : files ) { if ( ! isSymlink ( file ) ) { MST[rv.ROR4Mutator]MSP[N]
} @Deprecated public static void write ( final File file , final CharSequence data ) throws IOException { write ( file , data , Charset . defaultCharset () , false ) ; MST[NonVoidMethodCallMutator]MSP[N] } @Deprecated
return fileLength > 0 ? IOUtils . toByteArray ( in , fileLength ) : IOUtils . toByteArray ( in ) ; MST[rv.ROR4Mutator]MSP[N] } } public static List < String > readLines ( final File file , final Charset encoding ) throws IOException {
return file . length () ; } public static BigInteger sizeOfDirectoryAsBigInteger ( final File directory ) { checkDirectory ( directory ) ; return sizeOfDirectoryBig0 ( directory ) ; MST[NonVoidMethodCallMutator]MSP[S] } private static BigInteger sizeOfDirectoryBig0 ( final File directory ) { final File [] files = directory . listFiles () ;
final String [] suffixes = toSuffixes ( extensions ) ; filter = new SuffixFileFilter ( suffixes ) ; } return listFiles ( directory , filter , MST[rv.UOI4Mutator]MSP[N] recursive ? TrueFileFilter . INSTANCE : FalseFileFilter . INSTANCE ) ; } public static Iterator < File > iterateFiles (
if ( ! reference . exists () ) { MST[rv.ROR3Mutator]MSP[N] throw new IllegalArgumentException ( lr_55 + reference + lr_56 ) ; } return isFileOlder ( file , reference . lastModified () ) ; } public static boolean isFileOlder ( final File file , final Date date ) {
private static void checkDirectory ( final File directory ) { if ( ! directory . exists () ) { MST[rv.ROR1Mutator]MSP[N] throw new IllegalArgumentException ( directory + lr_42 ) ; } if ( ! directory . isDirectory () ) { throw new IllegalArgumentException ( directory + lr_47 ) ; } }
if ( url == null || ! lr_24 . equalsIgnoreCase ( url . getProtocol () ) ) { return null ; } String filename = url . getFile () . replace ( '/' , File . separatorChar ) ; MST[rv.CRCR2Mutator]MSP[N] filename = decodeUrl ( filename ) ;
if ( ! srcDir . isDirectory () ) { MST[rv.ROR2Mutator]MSP[N] throw new IOException ( lr_29 + srcDir + lr_39 ) ; } if ( srcDir . getCanonicalPath () . equals ( destDir . getCanonicalPath () ) ) {
validateMoveParameters ( srcDir , destDir ) ; if ( ! srcDir . isDirectory () ) { throw new IOException ( lr_29 + srcDir + lr_28 ) ; } if ( destDir . exists () ) { throw new FileExistsException ( lr_27 + destDir + lr_60 ) ; MST[experimental.NakedReceiverMutator]MSP[N] }
} else { final File parent = file . getParentFile () ; if ( parent != null ) { if ( ! parent . mkdirs () && ! parent . isDirectory () ) { throw new IOException ( lr_10 + parent + lr_11 ) ; MST[NonVoidMethodCallMutator]MSP[S] } } }
: new InputStreamReader ( new FileInputStream ( file2 ) , charsetName ) ) { return IOUtils . contentEqualsIgnoreEOL ( input1 , input2 ) ; MST[rv.UOI4Mutator]MSP[S] } } public static File toFile ( final URL url ) {
return isFileNewer ( file , date . getTime () ) ; } public static boolean isFileNewer ( final File file , final long timeMillis ) { if ( file == null ) { throw new IllegalArgumentException ( lr_58 ) ; } if ( ! file . exists () ) { MST[rv.ROR1Mutator]MSP[N]
if ( ! directory . isDirectory () ) { throw new IllegalArgumentException ( lr_46 + directory ) ; } if ( child == null ) { return false ; } if ( ! directory . exists () || ! child . exists () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] return false ; }
public static void writeLines ( final File file , final String encoding , final Collection < ? > lines , final String lineEnding , final boolean append ) throws IOException { try ( OutputStream out = new BufferedOutputStream ( openOutputStream ( file , append ) ) ) { MST[rv.UOI3Mutator]MSP[N]
} } return size ; } private static BigInteger sizeOfBig0 ( final File fileOrDir ) { if ( fileOrDir . isDirectory () ) { return sizeOfDirectoryBig0 ( fileOrDir ) ; MST[NonVoidMethodCallMutator]MSP[S] } return BigInteger . valueOf ( fileOrDir . length () ) ; }
throw new IOException ( lr_23 ) ; } if ( file1 . getCanonicalFile () . equals ( file2 . getCanonicalFile () ) ) { return true ; MST[rv.CRCR4Mutator]MSP[N] } try ( Reader input1 = charsetName == null
throw new IOException ( lr_29 + srcFile + lr_69 ) ; } if ( destFile . exists () ) { MST[NonVoidMethodCallMutator]MSP[S] throw new FileExistsException ( lr_27 + destFile + lr_60 ) ; } if ( destFile . isDirectory () ) {
if ( destDir . isDirectory () == false ) { throw new IOException ( lr_27 + destDir + lr_39 ) ; MST[experimental.NakedReceiverMutator]MSP[N] } } else { if ( ! destDir . mkdirs () && ! destDir . isDirectory () ) {
if ( destDir == null ) { throw new NullPointerException ( lr_26 ) ; } if ( destDir . exists () && destDir . isDirectory () == false ) { MST[NonVoidMethodCallMutator]MSP[N] throw new IllegalArgumentException ( lr_27 + destDir + lr_28 ) ; }
} @Deprecated public static void write ( final File file , final CharSequence data ) throws IOException { write ( file , data , Charset . defaultCharset () , false ) ; MST[VoidMethodCallMutator]MSP[S] } @Deprecated
File file = null ; for ( final String name : names ) { MST[rv.UOI1Mutator]MSP[S] if ( file == null ) { file = new File ( name ) ; } else { file = new File ( file , name ) ; } } return file ; }
public static BigInteger sizeOfAsBigInteger ( final File file ) { if ( ! file . exists () ) { final String message = file + lr_42 ; MST[ConstructorCallMutator]MSP[S] throw new IllegalArgumentException ( message ) ; } if ( file . isDirectory () ) { return sizeOfDirectoryBig0 ( file ) ; }
try ( OutputStream out = openOutputStream ( file , append ) ) { MST[rv.UOI1Mutator]MSP[N] out . write ( data , off , len ) ; } } public static void writeLines ( final File file , final String encoding , final Collection < ? > lines ) throws IOException {
final File [] files = verifiedListFiles ( directory ) ; MST[NonVoidMethodCallMutator]MSP[S] IOException exception = null ; for ( final File file : files ) { try { forceDeleteOnExit ( file ) ; } catch ( final IOException ioe ) { exception = ioe ; } }
} } return size ; } private static BigInteger sizeOfBig0 ( final File fileOrDir ) { if ( fileOrDir . isDirectory () ) { return sizeOfDirectoryBig0 ( fileOrDir ) ; } return BigInteger . valueOf ( fileOrDir . length () ) ; MST[NullReturnValsMutator]MSP[N] }
final File destFile = new File ( destDir , srcFile . getName () ) ; copyFile ( srcFile , destFile , preserveFileDate ) ; MST[rv.UOI4Mutator]MSP[N] } public static void copyFile ( final File srcFile , final File destFile ) throws IOException { copyFile ( srcFile , destFile , true ) ;
if ( ! directory . isDirectory () ) { throw new IllegalArgumentException ( lr_46 + directory ) ; } if ( child == null ) { return false ; } if ( ! directory . exists () || ! child . exists () ) { MST[rv.ROR3Mutator]MSP[S] return false ; }
if ( srcLen != dstLen ) { throw new IOException ( lr_34 + srcFile + lr_35 + destFile MST[experimental.NakedReceiverMutator]MSP[N] + lr_36 + srcLen + lr_37 + dstLen ) ; } } public static void copyDirectoryToDirectory ( final File srcDir , final File destDir ) throws IOException {
if ( ! directory . exists () ) { return; } directory . deleteOnExit () ; if ( ! isSymlink ( directory ) ) { cleanDirectoryOnExit ( directory ) ; MST[VoidMethodCallMutator]MSP[S] } } private static void cleanDirectoryOnExit ( final File directory ) throws IOException {
public static void write ( final File file , final CharSequence data , final boolean append ) throws IOException { write ( file , data , Charset . defaultCharset () , append ) ; MST[rv.ABSMutator]MSP[N] }
final File [] found = directory . listFiles ( ( FileFilter ) filter ) ; if ( found != null ) { for ( final File file : found ) { if ( file . isDirectory () ) { if ( includeSubDirectories ) { MST[rv.UOI1Mutator]MSP[N]
return FileFilterUtils . and ( fileFilter , FileFilterUtils . notFileFilter ( DirectoryFileFilter . INSTANCE ) ) ; } private static IOFileFilter setUpEffectiveDirFilter ( final IOFileFilter dirFilter ) { return dirFilter == null ? FalseFileFilter . INSTANCE : FileFilterUtils . and ( dirFilter , MST[rv.ROR5Mutator]MSP[N] DirectoryFileFilter . INSTANCE ) ; }
doCopyDirectory ( srcFile , dstFile , filter , preserveFileDate , exclusionList ) ; } else { doCopyFile ( srcFile , dstFile , preserveFileDate ) ; MST[rv.ABSMutator]MSP[N] } } } if ( preserveFileDate ) { destDir . setLastModified ( srcDir . lastModified () ) ; } }
if ( ! destDir . exists () ) { throw new FileNotFoundException ( lr_66 + destDir + lr_67 + createDestDir + lr_68 ) ; } if ( ! destDir . isDirectory () ) { MST[rv.ROR1Mutator]MSP[N] throw new IOException ( lr_27 + destDir + lr_28 ) ; }
displaySize = String . valueOf ( size . divide ( ONE_PB_BI ) ) + lr_13 ; } else if ( size . divide ( ONE_TB_BI ) . compareTo ( BigInteger . ZERO ) > 0 ) { MST[rv.ROR4Mutator]MSP[N]
return IOUtils . copyLarge ( fis , output ) ; MST[rv.UOI3Mutator]MSP[N] } } private static void doCopyFile ( final File srcFile , final File destFile , final boolean preserveFileDate ) throws IOException { if ( destFile . exists () && destFile . isDirectory () ) {
return FileFilterUtils . and ( fileFilter , FileFilterUtils . notFileFilter ( DirectoryFileFilter . INSTANCE ) ) ; } private static IOFileFilter setUpEffectiveDirFilter ( final IOFileFilter dirFilter ) { return dirFilter == null ? FalseFileFilter . INSTANCE : FileFilterUtils . and ( dirFilter , MST[rv.CRCR3Mutator]MSP[N] DirectoryFileFilter . INSTANCE ) ; }
checkEqualSizes ( srcFile , destFile , srcFile . length () , destFile . length () ) ; MST[NonVoidMethodCallMutator]MSP[N] destFile . setLastModified ( newLastModifed ) ; } private static void checkEqualSizes ( final File srcFile , final File destFile , final long srcLen , final long dstLen ) throws IOException {
final boolean rename = srcDir . renameTo ( destDir ) ; if ( ! rename ) { MST[rv.ROR4Mutator]MSP[N] if ( destDir . getCanonicalPath () . startsWith ( srcDir . getCanonicalPath () + File . separator ) ) { throw new IOException ( lr_61 + srcDir + lr_62 + destDir ) ;
for ( int i = 0 ; i < urls . length ; i ++ ) { MST[rv.UOI4Mutator]MSP[N] final URL url = urls [ i ] ; if ( url != null ) { if ( url . getProtocol () . equals ( lr_24 ) == false ) {
return false ; } return file . lastModified () > timeMillis ; MST[ConditionalsBoundaryMutator]MSP[S] } public static boolean isFileOlder ( final File file , final File reference ) { if ( reference == null ) { throw new IllegalArgumentException ( lr_54 ) ; }
if ( file == null ) { MST[NegateConditionalsMutator]MSP[N] return false ; } try { if ( file . isDirectory () ) { cleanDirectory ( file ) ; } } catch ( final Exception ignored ) { } try { return file . delete () ;
copyDirectory ( srcDir , new File ( destDir , srcDir . getName () ) , true ) ; } public static void copyDirectory ( final File srcDir , final File destDir ) throws IOException { copyDirectory ( srcDir , destDir , true ) ; MST[rv.CRCR4Mutator]MSP[N] }
for ( final String name : names ) { file = new File ( file , name ) ; } return file ; } public static File getFile ( final String ... names ) { if ( names == null ) { MST[rv.ROR5Mutator]MSP[S] throw new NullPointerException ( lr_2 ) ; }
final Collection < File > files = new java . util . LinkedList <> () ; if ( includeSubDirectories ) { files . add ( directory ) ; } innerListFiles ( files , directory , FileFilterUtils . or ( effFileFilter , effDirFilter ) , includeSubDirectories ) ; MST[rv.UOI1Mutator]MSP[N] return files ;
for ( final File src : srcs ) { copyFileToDirectory ( src , destDir ) ; } } public static void deleteDirectory ( final File directory ) throws IOException { if ( ! directory . exists () ) { MST[rv.ROR4Mutator]MSP[N] return; } if ( ! isSymlink ( directory ) ) {
if ( null != exception ) { throw exception ; } } public static void forceMkdir ( final File directory ) throws IOException { if ( directory . exists () ) { if ( ! directory . isDirectory () ) { final String message = MST[NonVoidMethodCallMutator]MSP[N] lr_50 + directory + lr_51
final File [] found = directory . listFiles ( ( FileFilter ) filter ) ; if ( found != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] for ( final File file : found ) { if ( file . isDirectory () ) { if ( includeSubDirectories ) {
throw new IOException ( lr_29 + srcDir + lr_30 + destDir + lr_31 ) ; } List < String > exclusionList = null ; if ( destDir . getCanonicalPath () . startsWith ( srcDir . getCanonicalPath () ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S]
final File [] files = verifiedListFiles ( directory ) ; IOException exception = null ; for ( final File file : files ) { MST[rv.ABSMutator]MSP[S] try { forceDeleteOnExit ( file ) ; } catch ( final IOException ioe ) { exception = ioe ; } }
return FileFilterUtils . and ( fileFilter , FileFilterUtils . notFileFilter ( DirectoryFileFilter . INSTANCE ) ) ; } private static IOFileFilter setUpEffectiveDirFilter ( final IOFileFilter dirFilter ) { return dirFilter == null ? FalseFileFilter . INSTANCE : FileFilterUtils . and ( dirFilter , MST[InlineConstantMutator]MSP[N] DirectoryFileFilter . INSTANCE ) ; }
if ( ! reference . exists () ) { throw new IllegalArgumentException ( lr_55 MST[ConstructorCallMutator]MSP[S] + reference + lr_56 ) ; } return isFileOlder ( file , reference . lastModified () ) ; } public static boolean isFileOlder ( final File file , final Date date ) {
if ( ! destDir . isDirectory () ) { throw new IOException ( lr_27 + destDir + lr_28 ) ; MST[NonVoidMethodCallMutator]MSP[S] } moveFile ( srcFile , new File ( destDir , srcFile . getName () ) ) ; }
final File directory , final IOFileFilter fileFilter , final IOFileFilter dirFilter ) { return innerListFilesOrDirectories ( directory , fileFilter , dirFilter , false ) ; MST[rv.CRCR3Mutator]MSP[N] } private static void validateListFilesParameters ( final File directory , final IOFileFilter fileFilter ) { if ( ! directory . isDirectory () ) {
public static boolean isFileNewer ( final File file , final File reference ) { if ( reference == null ) { throw new IllegalArgumentException ( lr_54 ) ; } if ( ! reference . exists () ) { throw new IllegalArgumentException ( lr_55 MST[experimental.NakedReceiverMutator]MSP[N] + reference + lr_56 ) ; }
displaySize = String . valueOf ( size . divide ( ONE_PB_BI ) ) + lr_13 ; MST[NonVoidMethodCallMutator]MSP[N] } else if ( size . divide ( ONE_TB_BI ) . compareTo ( BigInteger . ZERO ) > 0 ) {
final Collection < File > files = new java . util . LinkedList <> () ; if ( includeSubDirectories ) { files . add ( directory ) ; } innerListFiles ( files , directory , MST[rv.CRCR5Mutator]MSP[N] FileFilterUtils . or ( effFileFilter , effDirFilter ) , includeSubDirectories ) ; return files ;
if ( ! directory . isDirectory () ) { throw new IllegalArgumentException ( lr_46 + directory ) ; } if ( child == null ) { return false ; } if ( ! directory . exists () || ! child . exists () ) { MST[rv.ROR4Mutator]MSP[S] return false ; }
final StringBuilder buffer = new StringBuilder () ; final ByteBuffer bytes = ByteBuffer . allocate ( n ) ; for ( int i = 0 ; i < n ; ) { if ( url . charAt ( i ) == '%' ) { MST[rv.CRCR4Mutator]MSP[N] try { do {
validateMoveParameters ( srcFile , destDir ) ; if ( ! destDir . exists () && createDestDir ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] destDir . mkdirs () ; } if ( ! destDir . exists () ) { throw new FileNotFoundException ( lr_66 + destDir + lr_67 + createDestDir + lr_68 ) ; }
} else { final File parent = file . getParentFile () ; if ( parent != null ) { MST[rv.ROR5Mutator]MSP[N] if ( ! parent . mkdirs () && ! parent . isDirectory () ) { throw new IOException ( lr_10 + parent + lr_11 ) ; } } }
final File [] found = directory . listFiles ( ( FileFilter ) filter ) ; if ( found != null ) { for ( final File file : found ) { if ( file . isDirectory () ) { if ( includeSubDirectories ) { MST[rv.ROR4Mutator]MSP[N]
moveDirectory ( src , new File ( destDir , src . getName () ) ) ; } public static void moveFile ( final File srcFile , final File destFile ) throws IOException { validateMoveParameters ( srcFile , destFile ) ; if ( srcFile . isDirectory () ) { MST[rv.ROR3Mutator]MSP[N]
return byteCountToDisplaySize ( BigInteger . valueOf ( size ) ) ; MST[rv.UOI1Mutator]MSP[N] } public static void touch ( final File file ) throws IOException { if ( ! file . exists () ) { openOutputStream ( file ) . close () ; }
} else { final File parent = file . getParentFile () ; if ( parent != null ) { if ( ! parent . mkdirs () && ! parent . isDirectory () ) { MST[rv.ROR1Mutator]MSP[N] throw new IOException ( lr_10 + parent + lr_11 ) ; } } }
if ( ! directory . isDirectory () ) { MST[rv.ROR3Mutator]MSP[S] final String message = directory + lr_47 ; throw new IllegalArgumentException ( message ) ; } final File [] files = directory . listFiles () ; if ( files == null ) {
while ( ! file . exists () ) { final long remaining = finishAt - System . currentTimeMillis () ; if ( remaining < 0 ) { MST[ConditionalsBoundaryMutator]MSP[N] return false ; } try { Thread . sleep ( Math . min ( 100 , remaining ) ) ;
} catch ( final InterruptedException ignore ) { wasInterrupted = true ; } catch ( final Exception ex ) { break; } } } finally { if ( wasInterrupted ) { MST[rv.ROR4Mutator]MSP[S] Thread . currentThread () . interrupt () ; } } return true ; }
if ( srcLen != dstLen ) { throw new IOException ( lr_34 + srcFile + lr_35 + destFile MST[rv.UOI2Mutator]MSP[N] + lr_36 + srcLen + lr_37 + dstLen ) ; } } public static void copyDirectoryToDirectory ( final File srcDir , final File destDir ) throws IOException {
final boolean filePresent = file . exists () ; if ( ! file . delete () ) { if ( ! filePresent ) { MST[rv.UOI1Mutator]MSP[N] throw new FileNotFoundException ( lr_48 + file ) ; } final String message = lr_49 + file ; throw new IOException ( message ) ; }
if ( null != exception ) { MST[NegateConditionalsMutator]MSP[S] throw exception ; } } public static void forceMkdir ( final File directory ) throws IOException { if ( directory . exists () ) { if ( ! directory . isDirectory () ) { final String message = lr_50 + directory + lr_51
validateMoveParameters ( srcFile , destDir ) ; if ( ! destDir . exists () && createDestDir ) { MST[NegateConditionalsMutator]MSP[N] destDir . mkdirs () ; } if ( ! destDir . exists () ) { throw new FileNotFoundException ( lr_66 + destDir + lr_67 + createDestDir + lr_68 ) ; }
if ( ! reference . exists () ) { throw new IllegalArgumentException ( lr_55 MST[NonVoidMethodCallMutator]MSP[S] + reference + lr_56 ) ; } return isFileOlder ( file , reference . lastModified () ) ; } public static boolean isFileOlder ( final File file , final Date date ) {
validateMoveParameters ( srcDir , destDir ) ; if ( ! srcDir . isDirectory () ) { throw new IOException ( lr_29 + srcDir + lr_28 ) ; MST[ConstructorCallMutator]MSP[S] } if ( destDir . exists () ) { throw new FileExistsException ( lr_27 + destDir + lr_60 ) ; }
if ( srcFile . getCanonicalPath () . equals ( destFile . getCanonicalPath () ) ) { throw new IOException ( lr_29 + srcFile + lr_30 + destFile + lr_31 ) ; MST[experimental.NakedReceiverMutator]MSP[N] } final File parentFile = destFile . getParentFile () ; if ( parentFile != null ) {
if ( srcLen != dstLen ) { throw new IOException ( lr_34 + srcFile + lr_35 + destFile MST[experimental.NakedReceiverMutator]MSP[N] + lr_36 + srcLen + lr_37 + dstLen ) ; } } public static void copyDirectoryToDirectory ( final File srcDir , final File destDir ) throws IOException {
final File [] files = directory . listFiles () ; if ( files == null ) { return 0L ; } long size = 0 ; for ( final File file : files ) { if ( ! isSymlink ( file ) ) { MST[NegateConditionalsMutator]MSP[N]
validateMoveParameters ( srcFile , destDir ) ; if ( ! destDir . exists () && createDestDir ) { destDir . mkdirs () ; } if ( ! destDir . exists () ) { throw new FileNotFoundException ( lr_66 + destDir + MST[experimental.NakedReceiverMutator]MSP[N] lr_67 + createDestDir + lr_68 ) ; }
throw new NullPointerException ( lr_38 ) ; } if ( src . isFile () ) { copyFileToDirectory ( src , destDir ) ; } else if ( src . isDirectory () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] copyDirectoryToDirectory ( src , destDir ) ; } else {
final Collection < File > files = new java . util . LinkedList <> () ; if ( includeSubDirectories ) { files . add ( directory ) ; } innerListFiles ( files , directory , MST[InlineConstantMutator]MSP[N] FileFilterUtils . or ( effFileFilter , effDirFilter ) , includeSubDirectories ) ; return files ;
throw new IOException ( lr_29 + srcDir + lr_30 + destDir + lr_31 ) ; MST[NonVoidMethodCallMutator]MSP[S] } List < String > exclusionList = null ; if ( destDir . getCanonicalPath () . startsWith ( srcDir . getCanonicalPath () ) ) {
displaySize = String . valueOf ( size . divide ( ONE_GB_BI ) ) + lr_15 ; } else if ( size . divide ( ONE_MB_BI ) . compareTo ( BigInteger . ZERO ) > 0 ) { MST[experimental.BigIntegerMutator]MSP[N]
try ( OutputStream out = openOutputStream ( file , append ) ) { out . write ( data , off , len ) ; MST[rv.UOI1Mutator]MSP[N] } } public static void writeLines ( final File file , final String encoding , final Collection < ? > lines ) throws IOException {
final byte octet = ( byte ) Integer . parseInt ( url . substring ( i + 1 , i + 3 ) , 16 ) ; MST[rv.CRCR3Mutator]MSP[N] bytes . put ( octet ) ; i += 3 ;
if ( srcFile . getCanonicalPath () . equals ( destFile . getCanonicalPath () ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] throw new IOException ( lr_29 + srcFile + lr_30 + destFile + lr_31 ) ; } final File parentFile = destFile . getParentFile () ; if ( parentFile != null ) {
buffer . append ( StandardCharsets . UTF_8 . decode ( bytes ) . toString () ) ; MST[NonVoidMethodCallMutator]MSP[N] bytes . clear () ; } } } buffer . append ( url . charAt ( i ++ ) ) ; } decoded = buffer . toString () ; } return decoded ;
if ( ! reference . exists () ) { throw new IllegalArgumentException ( lr_55 + reference + lr_56 ) ; } return isFileOlder ( file , reference . lastModified () ) ; MST[ReturnValsMutator]MSP[S] } public static boolean isFileOlder ( final File file , final Date date ) {
final URL [] urls = new URL [ files . length ] ; for ( int i = 0 ; i < urls . length ; i ++ ) { urls [ i ] = files [ i ] . toURI () . toURL () ; MST[NonVoidMethodCallMutator]MSP[S] } return urls ;
if ( srcDir == null ) { throw new NullPointerException ( lr_38 ) ; } if ( srcDir . exists () && srcDir . isDirectory () == false ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] throw new IllegalArgumentException ( lr_29 + destDir + lr_28 ) ; } if ( destDir == null ) {
return new File ( filename ) ; } static String decodeUrl ( final String url ) { String decoded = url ; if ( url != null && url . indexOf ( '%' ) >= 0 ) { MST[rv.CRCR1Mutator]MSP[N] final int n = url . length () ;
throw new IllegalArgumentException ( lr_58 ) ; } if ( ! file . exists () ) { return false ; } return file . lastModified () < timeMillis ; MST[BooleanTrueReturnValsMutator]MSP[S] } public static long checksumCRC32 ( final File file ) throws IOException { final CRC32 crc = new CRC32 () ;
displaySize = String . valueOf ( size . divide ( ONE_MB_BI ) ) + lr_16 ; MST[ArgumentPropagationMutator]MSP[N] } else if ( size . divide ( ONE_KB_BI ) . compareTo ( BigInteger . ZERO ) > 0 ) {
if ( file == null ) { return false ; } try { if ( file . isDirectory () ) { MST[NegateConditionalsMutator]MSP[N] cleanDirectory ( file ) ; } } catch ( final Exception ignored ) { } try { return file . delete () ;
} public static void copyFile ( final File srcFile , final File destFile , final boolean preserveFileDate ) throws IOException { checkFileRequirements ( srcFile , destFile ) ; if ( srcFile . isDirectory () ) { MST[rv.ROR1Mutator]MSP[N] throw new IOException ( lr_29 + srcFile + lr_6 ) ; }
throws IOException { final File [] srcFiles = filter == null ? srcDir . listFiles () : srcDir . listFiles ( filter ) ; if ( srcFiles == null ) { throw new IOException ( lr_40 + srcDir ) ; } if ( destDir . exists () ) { MST[rv.ROR3Mutator]MSP[N]
final URL [] urls = new URL [ files . length ] ; for ( int i = 0 ; i < urls . length ; i ++ ) { urls [ i ] = files [ i ] . toURI () . toURL () ; } return urls ; MST[ReturnValsMutator]MSP[N]
return new FileInputStream ( file ) ; } public static FileOutputStream openOutputStream ( final File file ) throws IOException { return openOutputStream ( file , false ) ; MST[NullReturnValsMutator]MSP[N] } public static FileOutputStream openOutputStream ( final File file , final boolean append ) throws IOException {
final boolean file1Exists = file1 . exists () ; if ( file1Exists != file2 . exists () ) { return false ; } if ( ! file1Exists ) { MST[rv.ROR5Mutator]MSP[N] return true ; } if ( file1 . isDirectory () || file2 . isDirectory () ) {
} @Deprecated public static void write ( final File file , final CharSequence data ) throws IOException { write ( file , data , Charset . defaultCharset () , false ) ; MST[rv.CRCR5Mutator]MSP[N] } @Deprecated
return lineIterator ( file , null ) ; } public static void writeStringToFile ( final File file , final String data , final Charset encoding ) throws IOException { writeStringToFile ( file , data , encoding , false ) ; MST[rv.CRCR5Mutator]MSP[N] }
File file = null ; for ( final String name : names ) { MST[rv.UOI4Mutator]MSP[S] if ( file == null ) { file = new File ( name ) ; } else { file = new File ( file , name ) ; } } return file ; }
private static void checkDirectory ( final File directory ) { if ( ! directory . exists () ) { throw new IllegalArgumentException ( directory + lr_42 ) ; } if ( ! directory . isDirectory () ) { MST[NonVoidMethodCallMutator]MSP[N] throw new IllegalArgumentException ( directory + lr_47 ) ; } }
final File directory , final IOFileFilter fileFilter , final IOFileFilter dirFilter , final boolean includeSubDirectories ) { validateListFilesParameters ( directory , fileFilter ) ; final IOFileFilter effFileFilter = setUpEffectiveFileFilter ( fileFilter ) ; MST[NonVoidMethodCallMutator]MSP[N] final IOFileFilter effDirFilter = setUpEffectiveDirFilter ( dirFilter ) ;
final byte octet = ( byte ) Integer . parseInt ( url . substring ( i + 1 , i + 3 ) , 16 ) ; MST[rv.CRCR4Mutator]MSP[N] bytes . put ( octet ) ; i += 3 ;
return BigInteger . valueOf ( file . length () ) ; } public static long sizeOfDirectory ( final File directory ) { checkDirectory ( directory ) ; MST[VoidMethodCallMutator]MSP[S] return sizeOfDirectory0 ( directory ) ; } private static long sizeOfDirectory0 ( final File directory ) {
final StringBuilder buffer = new StringBuilder () ; final ByteBuffer bytes = ByteBuffer . allocate ( n ) ; for ( int i = 0 ; i < n ; ) { MST[rv.ROR1Mutator]MSP[N] if ( url . charAt ( i ) == '%' ) { try { do {
throw new IOException ( lr_27 + destFile + lr_33 ) ; } doCopyFile ( srcFile , destFile , preserveFileDate ) ; MST[rv.UOI3Mutator]MSP[N] } public static long copyFile ( final File input , final OutputStream output ) throws IOException { try ( FileInputStream fis = new FileInputStream ( input ) ) {
size += sizeOf0 ( file ) ; if ( size < 0 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] break; } } } return size ; } private static long sizeOf0 ( final File file ) { if ( file . isDirectory () ) { return sizeOfDirectory0 ( file ) ; }
final boolean file1Exists = file1 . exists () ; if ( file1Exists != file2 . exists () ) { return false ; } if ( ! file1Exists ) { MST[rv.UOI4Mutator]MSP[N] return true ; } if ( file1 . isDirectory () || file2 . isDirectory () ) {
if ( srcLen != dstLen ) { MST[rv.ABSMutator]MSP[N] throw new IOException ( lr_34 + srcFile + lr_35 + destFile + lr_36 + srcLen + lr_37 + dstLen ) ; } } public static void copyDirectoryToDirectory ( final File srcDir , final File destDir ) throws IOException {
final Collection < File > files = new java . util . LinkedList <> () ; if ( includeSubDirectories ) { files . add ( directory ) ; } innerListFiles ( files , directory , FileFilterUtils . or ( effFileFilter , effDirFilter ) , includeSubDirectories ) ; return files ; MST[EmptyObjectReturnValsMutator]MSP[N]
for ( int i = 0 ; i < urls . length ; i ++ ) { MST[InlineConstantMutator]MSP[N] final URL url = urls [ i ] ; if ( url != null ) { if ( url . getProtocol () . equals ( lr_24 ) == false ) {
if ( files == null ) { return BigInteger . ZERO ; } BigInteger size = BigInteger . ZERO ; for ( final File file : files ) { MST[rv.ABSMutator]MSP[N] if ( ! isSymlink ( file ) ) { size = size . add ( sizeOfBig0 ( file ) ) ;
if ( srcFile . getCanonicalPath () . equals ( destFile . getCanonicalPath () ) ) { throw new IOException ( lr_29 + srcFile + lr_30 + destFile + lr_31 ) ; MST[NonVoidMethodCallMutator]MSP[N] } final File parentFile = destFile . getParentFile () ; if ( parentFile != null ) {
final File [] srcFiles = filter == null ? srcDir . listFiles () : srcDir . listFiles ( filter ) ; if ( srcFiles != null && srcFiles . length > 0 ) { MST[rv.ROR3Mutator]MSP[S] exclusionList = new ArrayList <> ( srcFiles . length ) ;
if ( ! file . exists () ) { final String message = file + lr_42 ; throw new IllegalArgumentException ( message ) ; } if ( file . isDirectory () ) { return sizeOfDirectory0 ( file ) ; MST[NonVoidMethodCallMutator]MSP[S] } return file . length () ; }
final String [] suffixes = toSuffixes ( extensions ) ; filter = new SuffixFileFilter ( suffixes ) ; } return listFiles ( directory , filter , MST[rv.ROR5Mutator]MSP[N] recursive ? TrueFileFilter . INSTANCE : FalseFileFilter . INSTANCE ) ; } public static Iterator < File > iterateFiles (
writeStringToFile ( file , data , Charset . defaultCharset () , false ) ; } @Deprecated public static void writeStringToFile ( final File file , final String data , final boolean append ) throws IOException { writeStringToFile ( file , data , Charset . defaultCharset () , append ) ; MST[NonVoidMethodCallMutator]MSP[N]
final String canonicalParent = directory . getCanonicalPath () ; final String canonicalChild = child . getCanonicalPath () ; return FilenameUtils . directoryContains ( canonicalParent , canonicalChild ) ; MST[ReturnValsMutator]MSP[N] } public static void cleanDirectory ( final File directory ) throws IOException {
final byte octet = ( byte ) Integer . parseInt ( url . substring ( i + 1 , i + 3 ) , 16 ) ; MST[rv.CRCR5Mutator]MSP[N] bytes . put ( octet ) ; i += 3 ;
throw new IOException ( lr_23 ) ; } if ( file1 . length () != file2 . length () ) { MST[NegateConditionalsMutator]MSP[N] return false ; } if ( file1 . getCanonicalFile () . equals ( file2 . getCanonicalFile () ) ) { return true ; }
if ( ! parentFile . mkdirs () && ! parentFile . isDirectory () ) { MST[rv.ROR4Mutator]MSP[N] throw new IOException ( lr_27 + parentFile + lr_32 ) ; } } if ( destFile . exists () && destFile . canWrite () == false ) {
throw new IOException ( lr_29 + srcFile + lr_69 ) ; } if ( destFile . exists () ) { throw new FileExistsException ( lr_27 + destFile + lr_60 ) ; } if ( destFile . isDirectory () ) { MST[rv.ROR3Mutator]MSP[N]
while ( ! file . exists () ) { final long remaining = finishAt - System . currentTimeMillis () ; if ( remaining < 0 ) { MST[rv.CRCR5Mutator]MSP[N] return false ; } try { Thread . sleep ( Math . min ( 100 , remaining ) ) ;
final boolean rename = srcDir . renameTo ( destDir ) ; if ( ! rename ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] if ( destDir . getCanonicalPath () . startsWith ( srcDir . getCanonicalPath () + File . separator ) ) { throw new IOException ( lr_61 + srcDir + lr_62 + destDir ) ;
if ( files == null ) { return BigInteger . ZERO ; } BigInteger size = BigInteger . ZERO ; for ( final File file : files ) { if ( ! isSymlink ( file ) ) { MST[NegateConditionalsMutator]MSP[N] size = size . add ( sizeOfBig0 ( file ) ) ;
if ( srcLen != dstLen ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] throw new IOException ( lr_34 + srcFile + lr_35 + destFile + lr_36 + srcLen + lr_37 + dstLen ) ; } } public static void copyDirectoryToDirectory ( final File srcDir , final File destDir ) throws IOException {
throw new IOException ( lr_27 + destFile + lr_69 ) ; } final boolean rename = srcFile . renameTo ( destFile ) ; if ( ! rename ) { copyFile ( srcFile , destFile ) ; if ( ! srcFile . delete () ) { MST[rv.ROR1Mutator]MSP[S]
checkEqualSizes ( srcFile , destFile , srcFile . length () , destFile . length () ) ; destFile . setLastModified ( newLastModifed ) ; MST[rv.ABSMutator]MSP[N] } private static void checkEqualSizes ( final File srcFile , final File destFile , final long srcLen , final long dstLen ) throws IOException {
throw new IOException ( lr_27 + destFile + lr_69 ) ; } final boolean rename = srcFile . renameTo ( destFile ) ; if ( ! rename ) { copyFile ( srcFile , destFile ) ; if ( ! srcFile . delete () ) { MST[rv.ROR4Mutator]MSP[S]
throw new IllegalArgumentException ( lr_58 ) ; } if ( ! file . exists () ) { MST[NonVoidMethodCallMutator]MSP[S] return false ; } return file . lastModified () < timeMillis ; } public static long checksumCRC32 ( final File file ) throws IOException { final CRC32 crc = new CRC32 () ;
for ( final File src : srcs ) { copyFileToDirectory ( src , destDir ) ; MST[VoidMethodCallMutator]MSP[S] } } public static void deleteDirectory ( final File directory ) throws IOException { if ( ! directory . exists () ) { return; } if ( ! isSymlink ( directory ) ) {
} catch ( final InterruptedException ignore ) { wasInterrupted = true ; } catch ( final Exception ex ) { break; } } } finally { if ( wasInterrupted ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] Thread . currentThread () . interrupt () ; } } return true ; }
if ( date == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] throw new IllegalArgumentException ( lr_57 ) ; } return isFileOlder ( file , date . getTime () ) ; } public static boolean isFileOlder ( final File file , final long timeMillis ) { if ( file == null ) {
public static void writeByteArrayToFile ( final File file , final byte [] data ) throws IOException { writeByteArrayToFile ( file , data , false ) ; MST[rv.CRCR1Mutator]MSP[N] } public static void writeByteArrayToFile ( final File file , final byte [] data , final boolean append ) throws IOException {
public static void copyDirectory ( final File srcDir , final File destDir , final boolean preserveFileDate ) throws IOException { copyDirectory ( srcDir , destDir , null , preserveFileDate ) ; MST[rv.UOI3Mutator]MSP[S] } public static void copyDirectory ( final File srcDir , final File destDir ,
displaySize = String . valueOf ( size . divide ( ONE_MB_BI ) ) + lr_16 ; MST[NonVoidMethodCallMutator]MSP[N] } else if ( size . divide ( ONE_KB_BI ) . compareTo ( BigInteger . ZERO ) > 0 ) {
if ( files == null ) { return BigInteger . ZERO ; } BigInteger size = BigInteger . ZERO ; for ( final File file : files ) { MST[rv.UOI2Mutator]MSP[N] if ( ! isSymlink ( file ) ) { size = size . add ( sizeOfBig0 ( file ) ) ;
final URL [] urls = new URL [ files . length ] ; for ( int i = 0 ; i < urls . length ; i ++ ) { MST[rv.CRCR6Mutator]MSP[N] urls [ i ] = files [ i ] . toURI () . toURL () ; } return urls ;
final StringBuilder buffer = new StringBuilder () ; final ByteBuffer bytes = ByteBuffer . allocate ( n ) ; for ( int i = 0 ; i < n ; ) { MST[rv.ROR4Mutator]MSP[N] if ( url . charAt ( i ) == '%' ) { try { do {
if ( ! parentFile . mkdirs () && ! parentFile . isDirectory () ) { throw new IOException ( lr_27 + parentFile + lr_32 ) ; } } if ( destFile . exists () && destFile . canWrite () == false ) { MST[rv.ROR1Mutator]MSP[N]
throw new IOException ( lr_29 + srcDir + lr_30 + destDir + lr_31 ) ; } List < String > exclusionList = null ; if ( destDir . getCanonicalPath () . startsWith ( srcDir . getCanonicalPath () ) ) { MST[NegateConditionalsMutator]MSP[S]
final byte octet = ( byte ) Integer . parseInt ( url . substring ( i + 1 , i + 3 ) , 16 ) ; MST[MathMutator]MSP[N] bytes . put ( octet ) ; i += 3 ;
final File dstFile = new File ( destDir , srcFile . getName () ) ; if ( exclusionList == null || ! exclusionList . contains ( srcFile . getCanonicalPath () ) ) { if ( srcFile . isDirectory () ) { MST[rv.ROR3Mutator]MSP[N]
if ( ! directory . isDirectory () ) { throw new IllegalArgumentException ( lr_46 + directory ) ; } if ( child == null ) { return false ; } if ( ! directory . exists () || ! child . exists () ) { return false ; MST[ReturnValsMutator]MSP[N] }
writeByteArrayToFile ( file , data , off , len , false ) ; MST[rv.CRCR5Mutator]MSP[N] } public static void writeByteArrayToFile ( final File file , final byte [] data , final int off , final int len , final boolean append ) throws IOException {
final File [] found = directory . listFiles ( ( FileFilter ) filter ) ; if ( found != null ) { MST[NegateConditionalsMutator]MSP[N] for ( final File file : found ) { if ( file . isDirectory () ) { if ( includeSubDirectories ) {
throw new IllegalArgumentException ( MST[ConstructorCallMutator]MSP[S] lr_25 + url ) ; } files [ i ] = toFile ( url ) ; } } return files ; } public static URL [] toURLs ( final File [] files ) throws IOException {
if ( ! src . exists () ) { throw new FileNotFoundException ( lr_29 + src + lr_8 ) ; MST[ConstructorCallMutator]MSP[N] } } private static void doCopyDirectory ( final File srcDir , final File destDir , final FileFilter filter , final boolean preserveFileDate , final List < String > exclusionList )
try ( InputStream input1 = new FileInputStream ( file1 ) ; InputStream input2 = new FileInputStream ( file2 ) ) { return IOUtils . contentEquals ( input1 , input2 ) ; MST[NonVoidMethodCallMutator]MSP[S] } } public static boolean contentEqualsIgnoreEOL ( final File file1 , final File file2 , final String charsetName )
final File destFile = new File ( destDir , srcFile . getName () ) ; copyFile ( srcFile , destFile , preserveFileDate ) ; MST[VoidMethodCallMutator]MSP[N] } public static void copyFile ( final File srcFile , final File destFile ) throws IOException { copyFile ( srcFile , destFile , true ) ;
final File [] files = directory . listFiles () ; if ( files == null ) { return 0L ; } long size = 0 ; for ( final File file : files ) { if ( ! isSymlink ( file ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
throw new NullPointerException ( lr_38 ) ; } if ( src . isFile () ) { copyFileToDirectory ( src , destDir ) ; } else if ( src . isDirectory () ) { MST[NegateConditionalsMutator]MSP[S] copyDirectoryToDirectory ( src , destDir ) ; } else {
validateMoveParameters ( srcDir , destDir ) ; if ( ! srcDir . isDirectory () ) { throw new IOException ( lr_29 + srcDir + lr_28 ) ; } if ( destDir . exists () ) { MST[rv.ROR4Mutator]MSP[S] throw new FileExistsException ( lr_27 + destDir + lr_60 ) ; }
if ( ! parentFile . mkdirs () && ! parentFile . isDirectory () ) { MST[rv.ROR5Mutator]MSP[N] throw new IOException ( lr_27 + parentFile + lr_32 ) ; } } if ( destFile . exists () && destFile . canWrite () == false ) {
if ( ! directory . isDirectory () ) { throw new IllegalArgumentException ( lr_46 + directory ) ; } if ( child == null ) { return false ; MST[rv.CRCR1Mutator]MSP[S] } if ( ! directory . exists () || ! child . exists () ) { return false ; }
throw new IOException ( lr_40 + directory ) ; } return files ; } public static boolean waitFor ( final File file , final int seconds ) { final long finishAt = System . currentTimeMillis () + ( seconds * 1000L ) ; boolean wasInterrupted = false ; MST[rv.CRCR5Mutator]MSP[N] try {
if ( ! directory . isDirectory () ) { final String message = directory + lr_47 ; throw new IllegalArgumentException ( message ) ; } final File [] files = directory . listFiles () ; if ( files == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S]
throw new IOException ( lr_40 + directory ) ; } return files ; } public static boolean waitFor ( final File file , final int seconds ) { final long finishAt = System . currentTimeMillis () + ( seconds * 1000L ) ; MST[rv.CRCR3Mutator]MSP[N] boolean wasInterrupted = false ; try {
final URL [] urls = new URL [ files . length ] ; for ( int i = 0 ; i < urls . length ; i ++ ) { MST[rv.CRCR3Mutator]MSP[N] urls [ i ] = files [ i ] . toURI () . toURL () ; } return urls ;
private static void checkDirectory ( final File directory ) { if ( ! directory . exists () ) { throw new IllegalArgumentException ( directory + lr_42 ) ; } if ( ! directory . isDirectory () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] throw new IllegalArgumentException ( directory + lr_47 ) ; } }
final StringBuilder buffer = new StringBuilder () ; MST[ConstructorCallMutator]MSP[N] final ByteBuffer bytes = ByteBuffer . allocate ( n ) ; for ( int i = 0 ; i < n ; ) { if ( url . charAt ( i ) == '%' ) { try { do {
throw new IOException ( lr_40 + directory ) ; } return files ; } public static boolean waitFor ( final File file , final int seconds ) { final long finishAt = System . currentTimeMillis () + ( seconds * 1000L ) ; MST[MathMutator]MSP[N] boolean wasInterrupted = false ; try {
writeStringToFile ( file , data , Charset . defaultCharset () , false ) ; } @Deprecated public static void writeStringToFile ( final File file , final String data , final boolean append ) throws IOException { writeStringToFile ( file , data , Charset . defaultCharset () , append ) ; MST[VoidMethodCallMutator]MSP[N]
for ( final File srcFile : srcFiles ) { final File copiedFile = new File ( destDir , srcFile . getName () ) ; exclusionList . add ( copiedFile . getCanonicalPath () ) ; } } } doCopyDirectory ( srcDir , destDir , filter , preserveFileDate , exclusionList ) ; MST[rv.UOI3Mutator]MSP[S]
if ( null != exception ) { throw exception ; } } public static void forceMkdir ( final File directory ) throws IOException { if ( directory . exists () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] if ( ! directory . isDirectory () ) { final String message = lr_50 + directory + lr_51
final boolean append ) throws IOException { try ( OutputStream out = openOutputStream ( file , append ) ) { MST[rv.UOI4Mutator]MSP[N] IOUtils . write ( data , out , encoding ) ; } } public static void writeStringToFile ( final File file , final String data , final String encoding ,
if ( destDir == null ) { throw new NullPointerException ( lr_26 ) ; } if ( destDir . exists () && destDir . isDirectory () == false ) { MST[rv.ROR2Mutator]MSP[N] throw new IllegalArgumentException ( lr_27 + destDir + lr_28 ) ; }
return IOUtils . copyLarge ( fis , output ) ; } } private static void doCopyFile ( final File srcFile , final File destFile , final boolean preserveFileDate ) throws IOException { if ( destFile . exists () && destFile . isDirectory () ) { MST[rv.ROR5Mutator]MSP[N]
if ( destDir . isDirectory () == false ) { throw new IOException ( lr_27 + destDir + lr_39 ) ; } } else { if ( ! destDir . mkdirs () && ! destDir . isDirectory () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
public static boolean isFileNewer ( final File file , final File reference ) { if ( reference == null ) { throw new IllegalArgumentException ( lr_54 ) ; } if ( ! reference . exists () ) { throw new IllegalArgumentException ( lr_55 MST[ConstructorCallMutator]MSP[S] + reference + lr_56 ) ; }
if ( ! srcDir . isDirectory () ) { throw new IOException ( lr_29 + srcDir + lr_39 ) ; } if ( srcDir . getCanonicalPath () . equals ( destDir . getCanonicalPath () ) ) { MST[rv.ROR4Mutator]MSP[S]
writeByteArrayToFile ( file , data , off , len , false ) ; MST[rv.UOI1Mutator]MSP[N] } public static void writeByteArrayToFile ( final File file , final byte [] data , final int off , final int len , final boolean append ) throws IOException {
} private static void checkFileRequirements ( final File src , final File dest ) throws FileNotFoundException { if ( src == null ) { throw new NullPointerException ( lr_38 ) ; MST[ConstructorCallMutator]MSP[N] } if ( dest == null ) { throw new NullPointerException ( lr_26 ) ; }
final File [] files = verifiedListFiles ( directory ) ; IOException exception = null ; for ( final File file : files ) { MST[rv.UOI4Mutator]MSP[S] try { forceDeleteOnExit ( file ) ; } catch ( final IOException ioe ) { exception = ioe ; } }
throw new IOException ( lr_23 ) ; } if ( file1 . length () != file2 . length () ) { return false ; MST[ReturnValsMutator]MSP[N] } if ( file1 . getCanonicalFile () . equals ( file2 . getCanonicalFile () ) ) { return true ; }
public static void writeLines ( final File file , final String encoding , final Collection < ? > lines , final String lineEnding , final boolean append ) throws IOException { try ( OutputStream out = new BufferedOutputStream ( openOutputStream ( file , append ) ) ) { MST[ConstructorCallMutator]MSP[N]
final File [] files = directory . listFiles () ; if ( files == null ) { return 0L ; } long size = 0 ; for ( final File file : files ) { MST[rv.UOI2Mutator]MSP[N] if ( ! isSymlink ( file ) ) {
if ( destDir == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] throw new NullPointerException ( lr_26 ) ; } if ( destDir . exists () && destDir . isDirectory () == false ) { throw new IllegalArgumentException ( lr_27 + destDir + lr_28 ) ; }
return FileFilterUtils . and ( fileFilter , FileFilterUtils . notFileFilter ( DirectoryFileFilter . INSTANCE ) ) ; } private static IOFileFilter setUpEffectiveDirFilter ( final IOFileFilter dirFilter ) { return dirFilter == null ? FalseFileFilter . INSTANCE : FileFilterUtils . and ( dirFilter , MST[rv.CRCR4Mutator]MSP[N] DirectoryFileFilter . INSTANCE ) ; }
if ( ! directory . isDirectory () ) { throw new IllegalArgumentException ( lr_46 + directory ) ; } if ( child == null ) { return false ; } if ( ! directory . exists () || ! child . exists () ) { MST[rv.ROR1Mutator]MSP[S] return false ; }
final boolean filePresent = file . exists () ; if ( ! file . delete () ) { if ( ! filePresent ) { throw new FileNotFoundException ( lr_48 + file ) ; } final String message = MST[NonVoidMethodCallMutator]MSP[S] lr_49 + file ; throw new IOException ( message ) ; }
if ( ! directory . isDirectory () ) { final String message = directory + lr_47 ; MST[experimental.NakedReceiverMutator]MSP[N] throw new IllegalArgumentException ( message ) ; } final File [] files = directory . listFiles () ; if ( files == null ) {
throws IOException { final boolean file1Exists = file1 . exists () ; if ( file1Exists != file2 . exists () ) { return false ; } if ( ! file1Exists ) { return true ; MST[rv.CRCR3Mutator]MSP[N] } if ( file1 . isDirectory () || file2 . isDirectory () ) {
return new File ( filename ) ; } static String decodeUrl ( final String url ) { String decoded = url ; if ( url != null && url . indexOf ( '%' ) >= 0 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] final int n = url . length () ;
final URL [] urls = new URL [ files . length ] ; for ( int i = 0 ; i < urls . length ; i ++ ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[S] urls [ i ] = files [ i ] . toURI () . toURL () ; } return urls ;
if ( date == null ) { throw new IllegalArgumentException ( lr_57 ) ; } return isFileOlder ( file , date . getTime () ) ; } public static boolean isFileOlder ( final File file , final long timeMillis ) { if ( file == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S]
if ( destDir . isDirectory () == false ) { throw new IOException ( lr_27 + destDir + lr_39 ) ; } } else { if ( ! destDir . mkdirs () && ! destDir . isDirectory () ) { MST[NegateConditionalsMutator]MSP[N]
return false ; MST[ReturnValsMutator]MSP[N] } return file . lastModified () > timeMillis ; } public static boolean isFileOlder ( final File file , final File reference ) { if ( reference == null ) { throw new IllegalArgumentException ( lr_54 ) ; }
throw new IOException ( lr_27 + destFile + lr_69 ) ; } final boolean rename = srcFile . renameTo ( destFile ) ; if ( ! rename ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] copyFile ( srcFile , destFile ) ; if ( ! srcFile . delete () ) {
if ( srcLen != dstLen ) { MST[rv.UOI3Mutator]MSP[N] throw new IOException ( lr_34 + srcFile + lr_35 + destFile + lr_36 + srcLen + lr_37 + dstLen ) ; } } public static void copyDirectoryToDirectory ( final File srcDir , final File destDir ) throws IOException {
final boolean rename = srcDir . renameTo ( destDir ) ; if ( ! rename ) { if ( destDir . getCanonicalPath () . startsWith ( srcDir . getCanonicalPath () + File . separator ) ) { MST[rv.ROR1Mutator]MSP[S] throw new IOException ( lr_61 + srcDir + lr_62 + destDir ) ;
throw new IOException ( lr_27 + destFile + lr_6 ) ; } final Path srcPath = srcFile . toPath () ; final Path destPath = destFile . toPath () ; final long newLastModifed = preserveFileDate ? srcFile . lastModified () : destFile . lastModified () ; MST[rv.UOI4Mutator]MSP[S]
return FileFilterUtils . and ( fileFilter , FileFilterUtils . notFileFilter ( DirectoryFileFilter . INSTANCE ) ) ; MST[rv.CRCR6Mutator]MSP[N] } private static IOFileFilter setUpEffectiveDirFilter ( final IOFileFilter dirFilter ) { return dirFilter == null ? FalseFileFilter . INSTANCE : FileFilterUtils . and ( dirFilter , DirectoryFileFilter . INSTANCE ) ; }
validateMoveParameters ( srcFile , destDir ) ; if ( ! destDir . exists () && createDestDir ) { destDir . mkdirs () ; } if ( ! destDir . exists () ) { MST[rv.ROR5Mutator]MSP[N] throw new FileNotFoundException ( lr_66 + destDir + lr_67 + createDestDir + lr_68 ) ; }
if ( date == null ) { throw new IllegalArgumentException ( lr_57 ) ; } return isFileOlder ( file , date . getTime () ) ; } public static boolean isFileOlder ( final File file , final long timeMillis ) { if ( file == null ) { MST[NegateConditionalsMutator]MSP[S]
File file = null ; for ( final String name : names ) { MST[rv.ABSMutator]MSP[S] if ( file == null ) { file = new File ( name ) ; } else { file = new File ( file , name ) ; } } return file ; }
final boolean filePresent = file . exists () ; if ( ! file . delete () ) { if ( ! filePresent ) { throw new FileNotFoundException ( lr_48 + file ) ; } final String message = MST[experimental.NakedReceiverMutator]MSP[S] lr_49 + file ; throw new IOException ( message ) ; }
final boolean rename = srcDir . renameTo ( destDir ) ; if ( ! rename ) { if ( destDir . getCanonicalPath () . startsWith ( srcDir . getCanonicalPath () + File . separator ) ) { MST[NonVoidMethodCallMutator]MSP[S] throw new IOException ( lr_61 + srcDir + lr_62 + destDir ) ;
} while ( i < n && url . charAt ( i ) == '%' ); MST[InlineConstantMutator]MSP[S] continue; } catch ( final RuntimeException e ) { } finally { if ( bytes . position () > 0 ) { bytes . flip () ;
return FileFilterUtils . and ( fileFilter , FileFilterUtils . notFileFilter ( DirectoryFileFilter . INSTANCE ) ) ; MST[InlineConstantMutator]MSP[N] } private static IOFileFilter setUpEffectiveDirFilter ( final IOFileFilter dirFilter ) { return dirFilter == null ? FalseFileFilter . INSTANCE : FileFilterUtils . and ( dirFilter , DirectoryFileFilter . INSTANCE ) ; }
displaySize = String . valueOf ( size . divide ( ONE_GB_BI ) ) + lr_15 ; } else if ( size . divide ( ONE_MB_BI ) . compareTo ( BigInteger . ZERO ) > 0 ) { MST[rv.ROR3Mutator]MSP[N]
if ( srcDir == null ) { throw new NullPointerException ( lr_38 ) ; } if ( srcDir . exists () && srcDir . isDirectory () == false ) { throw new IllegalArgumentException ( lr_29 + destDir + lr_28 ) ; } if ( destDir == null ) { MST[rv.ROR5Mutator]MSP[N]
public static void write ( final File file , final CharSequence data , final boolean append ) throws IOException { write ( file , data , Charset . defaultCharset () , append ) ; MST[rv.UOI2Mutator]MSP[N] }
final boolean file1Exists = file1 . exists () ; if ( file1Exists != file2 . exists () ) { return false ; } if ( ! file1Exists ) { return true ; } if ( file1 . isDirectory () || file2 . isDirectory () ) { MST[NegateConditionalsMutator]MSP[N]
throw new IllegalArgumentException ( lr_58 ) ; } if ( ! file . exists () ) { return false ; } return file . lastModified () < timeMillis ; MST[rv.ABSMutator]MSP[S] } public static long checksumCRC32 ( final File file ) throws IOException { final CRC32 crc = new CRC32 () ;
while ( ! file . exists () ) { final long remaining = finishAt - System . currentTimeMillis () ; if ( remaining < 0 ) { return false ; } try { Thread . sleep ( Math . min ( 100 , remaining ) ) ; MST[VoidMethodCallMutator]MSP[N]
final File [] srcFiles = filter == null ? srcDir . listFiles () : srcDir . listFiles ( filter ) ; MST[rv.ROR5Mutator]MSP[N] if ( srcFiles != null && srcFiles . length > 0 ) { exclusionList = new ArrayList <> ( srcFiles . length ) ;
final File dstFile = new File ( destDir , srcFile . getName () ) ; if ( exclusionList == null || ! exclusionList . contains ( srcFile . getCanonicalPath () ) ) { MST[rv.ROR5Mutator]MSP[N] if ( srcFile . isDirectory () ) {
if ( destDir == null ) { MST[NegateConditionalsMutator]MSP[N] throw new NullPointerException ( lr_26 ) ; } if ( destDir . exists () && destDir . isDirectory () == false ) { throw new IllegalArgumentException ( lr_27 + destDir + lr_28 ) ; }
if ( srcLen != dstLen ) { throw new IOException ( lr_34 + srcFile + lr_35 + destFile MST[rv.UOI4Mutator]MSP[N] + lr_36 + srcLen + lr_37 + dstLen ) ; } } public static void copyDirectoryToDirectory ( final File srcDir , final File destDir ) throws IOException {
public static void moveToDirectory ( final File src , final File destDir , final boolean createDestDir ) throws IOException { validateMoveParameters ( src , destDir ) ; if ( src . isDirectory () ) { moveDirectoryToDirectory ( src , destDir , createDestDir ) ; MST[VoidMethodCallMutator]MSP[S] } else {
if ( file . exists () ) { if ( file . isDirectory () ) { MST[rv.ROR3Mutator]MSP[N] throw new IOException ( lr_5 + file + lr_6 ) ; } if ( file . canWrite () == false ) { throw new IOException ( lr_5 + file + lr_9 ) ; }
final boolean file1Exists = file1 . exists () ; if ( file1Exists != file2 . exists () ) { MST[rv.ROR2Mutator]MSP[N] return false ; } if ( ! file1Exists ) { return true ; } if ( file1 . isDirectory () || file2 . isDirectory () ) {
} while ( i < n && url . charAt ( i ) == '%' ); continue; } catch ( final RuntimeException e ) { } finally { if ( bytes . position () > 0 ) { MST[rv.ROR4Mutator]MSP[N] bytes . flip () ;
final int connectionTimeout , final int readTimeout ) throws IOException { final URLConnection connection = source . openConnection () ; connection . setConnectTimeout ( connectionTimeout ) ; MST[rv.UOI3Mutator]MSP[N] connection . setReadTimeout ( readTimeout ) ; copyInputStreamToFile ( connection . getInputStream () , destination ) ; }
if ( ! destDir . exists () ) { throw new FileNotFoundException ( lr_66 + destDir + MST[NonVoidMethodCallMutator]MSP[S] lr_67 + createDestDir + lr_68 ) ; } if ( ! destDir . isDirectory () ) { throw new IOException ( lr_27 + destDir + lr_28 ) ; }
for ( int i = 0 ; i < urls . length ; i ++ ) { final URL url = urls [ i ] ; MST[rv.UOI4Mutator]MSP[N] if ( url != null ) { if ( url . getProtocol () . equals ( lr_24 ) == false ) {
throw new IOException ( lr_41 + src + lr_42 ) ; } } public static void copyToDirectory ( final Iterable < File > srcs , final File destDir ) throws IOException { if ( srcs == null ) { MST[rv.ROR5Mutator]MSP[S] throw new NullPointerException ( lr_43 ) ; }
} while ( i < n && url . charAt ( i ) == '%' ); continue; } catch ( final RuntimeException e ) { } finally { if ( bytes . position () > 0 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] bytes . flip () ;
writeLines ( file , encoding , lines , null , append ) ; MST[rv.UOI4Mutator]MSP[N] } public static void writeLines ( final File file , final Collection < ? > lines ) throws IOException { writeLines ( file , null , lines , null , false ) ; }
return new FileOutputStream ( file , append ) ; } public static String byteCountToDisplaySize ( final BigInteger size ) { String displaySize ; if ( size . divide ( ONE_EB_BI ) . compareTo ( BigInteger . ZERO ) > 0 ) { MST[ArgumentPropagationMutator]MSP[N]
displaySize = String . valueOf ( size . divide ( ONE_EB_BI ) ) + lr_12 ; } else if ( size . divide ( ONE_PB_BI ) . compareTo ( BigInteger . ZERO ) > 0 ) { MST[NegateConditionalsMutator]MSP[N]
return byteCountToDisplaySize ( BigInteger . valueOf ( size ) ) ; MST[ReturnValsMutator]MSP[N] } public static void touch ( final File file ) throws IOException { if ( ! file . exists () ) { openOutputStream ( file ) . close () ; }
final StringBuilder buffer = new StringBuilder () ; final ByteBuffer bytes = ByteBuffer . allocate ( n ) ; for ( int i = 0 ; i < n ; ) { MST[rv.UOI3Mutator]MSP[N] if ( url . charAt ( i ) == '%' ) { try { do {
final StringBuilder buffer = new StringBuilder () ; final ByteBuffer bytes = ByteBuffer . allocate ( n ) ; for ( int i = 0 ; i < n ; ) { if ( url . charAt ( i ) == '%' ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] try { do {
size += sizeOf0 ( file ) ; if ( size < 0 ) { MST[rv.CRCR5Mutator]MSP[N] break; } } } return size ; } private static long sizeOf0 ( final File file ) { if ( file . isDirectory () ) { return sizeOfDirectory0 ( file ) ; }
final boolean rename = srcDir . renameTo ( destDir ) ; if ( ! rename ) { if ( destDir . getCanonicalPath () . startsWith ( srcDir . getCanonicalPath () + File . separator ) ) { throw new IOException ( lr_61 + srcDir + lr_62 + destDir ) ; MST[NonVoidMethodCallMutator]MSP[S]
final Collection < File > files = new java . util . LinkedList <> () ; if ( includeSubDirectories ) { files . add ( directory ) ; } innerListFiles ( files , directory , MST[rv.CRCR6Mutator]MSP[N] FileFilterUtils . or ( effFileFilter , effDirFilter ) , includeSubDirectories ) ; return files ;
final File [] files = verifiedListFiles ( directory ) ; IOException exception = null ; for ( final File file : files ) { try { forceDeleteOnExit ( file ) ; MST[VoidMethodCallMutator]MSP[N] } catch ( final IOException ioe ) { exception = ioe ; } }
throw new IOException ( lr_29 + srcFile + lr_69 ) ; MST[NonVoidMethodCallMutator]MSP[S] } if ( destFile . exists () ) { throw new FileExistsException ( lr_27 + destFile + lr_60 ) ; } if ( destFile . isDirectory () ) {
try ( OutputStream out = openOutputStream ( file , append ) ) { out . write ( data , off , len ) ; MST[VoidMethodCallMutator]MSP[N] } } public static void writeLines ( final File file , final String encoding , final Collection < ? > lines ) throws IOException {
return isFileNewer ( file , date . getTime () ) ; } public static boolean isFileNewer ( final File file , final long timeMillis ) { if ( file == null ) { throw new IllegalArgumentException ( lr_58 ) ; MST[ConstructorCallMutator]MSP[N] } if ( ! file . exists () ) {
return FileFilterUtils . and ( fileFilter , FileFilterUtils . notFileFilter ( DirectoryFileFilter . INSTANCE ) ) ; } private static IOFileFilter setUpEffectiveDirFilter ( final IOFileFilter dirFilter ) { return dirFilter == null ? FalseFileFilter . INSTANCE : FileFilterUtils . and ( dirFilter , MST[rv.CRCR5Mutator]MSP[N] DirectoryFileFilter . INSTANCE ) ; }
private static void checkDirectory ( final File directory ) { if ( ! directory . exists () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] throw new IllegalArgumentException ( directory + lr_42 ) ; } if ( ! directory . isDirectory () ) { throw new IllegalArgumentException ( directory + lr_47 ) ; } }
final File [] srcFiles = filter == null ? srcDir . listFiles () : srcDir . listFiles ( filter ) ; if ( srcFiles != null && srcFiles . length > 0 ) { MST[ConditionalsBoundaryMutator]MSP[N] exclusionList = new ArrayList <> ( srcFiles . length ) ;
validateMoveParameters ( srcFile , destDir ) ; MST[VoidMethodCallMutator]MSP[N] if ( ! destDir . exists () && createDestDir ) { destDir . mkdirs () ; } if ( ! destDir . exists () ) { throw new FileNotFoundException ( lr_66 + destDir + lr_67 + createDestDir + lr_68 ) ; }
size += sizeOf0 ( file ) ; if ( size < 0 ) { break; } } } return size ; } private static long sizeOf0 ( final File file ) { if ( file . isDirectory () ) { MST[rv.ROR5Mutator]MSP[N] return sizeOfDirectory0 ( file ) ; }
throw new IOException ( lr_27 + destFile + lr_6 ) ; } final Path srcPath = srcFile . toPath () ; final Path destPath = destFile . toPath () ; final long newLastModifed = preserveFileDate ? srcFile . lastModified () : destFile . lastModified () ; MST[rv.ROR5Mutator]MSP[S]
public static Collection < File > listFiles ( final File directory , final String [] extensions , final boolean recursive ) { IOFileFilter filter ; if ( extensions == null ) { MST[rv.ROR5Mutator]MSP[N] filter = TrueFileFilter . INSTANCE ; } else {
if ( destDir == null ) { throw new NullPointerException ( lr_26 ) ; } if ( destDir . exists () && destDir . isDirectory () == false ) { MST[rv.ROR3Mutator]MSP[N] throw new IllegalArgumentException ( lr_27 + destDir + lr_28 ) ; }
public static void write ( final File file , final CharSequence data , final Charset encoding ) throws IOException { write ( file , data , encoding , false ) ; MST[InlineConstantMutator]MSP[N] }
} public static void copyFile ( final File srcFile , final File destFile , final boolean preserveFileDate ) throws IOException { checkFileRequirements ( srcFile , destFile ) ; if ( srcFile . isDirectory () ) { MST[rv.ROR4Mutator]MSP[N] throw new IOException ( lr_29 + srcFile + lr_6 ) ; }
if ( ! directory . isDirectory () ) { throw new IllegalArgumentException ( lr_46 + directory ) ; MST[NonVoidMethodCallMutator]MSP[S] } if ( child == null ) { return false ; } if ( ! directory . exists () || ! child . exists () ) { return false ; }
displaySize = String . valueOf ( size . divide ( ONE_EB_BI ) ) + lr_12 ; MST[NonVoidMethodCallMutator]MSP[N] } else if ( size . divide ( ONE_PB_BI ) . compareTo ( BigInteger . ZERO ) > 0 ) {
checkEqualSizes ( srcFile , destFile , srcFile . length () , destFile . length () ) ; destFile . setLastModified ( newLastModifed ) ; MST[rv.UOI2Mutator]MSP[N] } private static void checkEqualSizes ( final File srcFile , final File destFile , final long srcLen , final long dstLen ) throws IOException {
final URL [] urls = new URL [ files . length ] ; for ( int i = 0 ; i < urls . length ; i ++ ) { MST[rv.ROR5Mutator]MSP[N] urls [ i ] = files [ i ] . toURI () . toURL () ; } return urls ;
return fileLength > 0 ? IOUtils . toByteArray ( in , fileLength ) : IOUtils . toByteArray ( in ) ; MST[rv.UOI3Mutator]MSP[N] } } public static List < String > readLines ( final File file , final Charset encoding ) throws IOException {
if ( url == null || ! lr_24 . equalsIgnoreCase ( url . getProtocol () ) ) { return null ; } String filename = url . getFile () . replace ( '/' , File . separatorChar ) ; MST[NonVoidMethodCallMutator]MSP[N] filename = decodeUrl ( filename ) ;
files . add ( file ) ; } innerListFiles ( files , file , filter , includeSubDirectories ) ; MST[rv.ABSMutator]MSP[N] } else { files . add ( file ) ; } } } } public static Collection < File > listFiles (
} else { final File parent = file . getParentFile () ; if ( parent != null ) { if ( ! parent . mkdirs () && ! parent . isDirectory () ) { MST[NegateConditionalsMutator]MSP[N] throw new IOException ( lr_10 + parent + lr_11 ) ; } } }
throw new IllegalArgumentException ( lr_25 + url ) ; } files [ i ] = toFile ( url ) ; MST[rv.UOI3Mutator]MSP[N] } } return files ; } public static URL [] toURLs ( final File [] files ) throws IOException {
if ( ! directory . exists () ) { return; } directory . deleteOnExit () ; MST[VoidMethodCallMutator]MSP[S] if ( ! isSymlink ( directory ) ) { cleanDirectoryOnExit ( directory ) ; } } private static void cleanDirectoryOnExit ( final File directory ) throws IOException {
throw new IOException ( lr_23 ) ; } if ( file1 . length () != file2 . length () ) { return false ; } if ( file1 . getCanonicalFile () . equals ( file2 . getCanonicalFile () ) ) { MST[experimental.NakedReceiverMutator]MSP[N] return true ; }
if ( ! parentFile . mkdirs () && ! parentFile . isDirectory () ) { throw new IOException ( lr_27 + parentFile + lr_32 ) ; } } if ( destFile . exists () && destFile . canWrite () == false ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
throw new IOException ( lr_23 ) ; } if ( file1 . length () != file2 . length () ) { return false ; MST[rv.CRCR5Mutator]MSP[N] } if ( file1 . getCanonicalFile () . equals ( file2 . getCanonicalFile () ) ) { return true ; }
displaySize = String . valueOf ( size . divide ( ONE_GB_BI ) ) + lr_15 ; MST[experimental.NakedReceiverMutator]MSP[N] } else if ( size . divide ( ONE_MB_BI ) . compareTo ( BigInteger . ZERO ) > 0 ) {
throws IOException { final boolean file1Exists = file1 . exists () ; if ( file1Exists != file2 . exists () ) { return false ; } if ( ! file1Exists ) { return true ; } if ( file1 . isDirectory () || file2 . isDirectory () ) { MST[rv.ROR5Mutator]MSP[S]
moveFileToDirectory ( src , destDir , createDestDir ) ; MST[rv.UOI4Mutator]MSP[S] } } private static void validateMoveParameters ( final File src , final File dest ) throws FileNotFoundException { if ( src == null ) { throw new NullPointerException ( lr_38 ) ; } if ( dest == null ) {
throw new IOException ( lr_40 + directory ) ; } return files ; } public static boolean waitFor ( final File file , final int seconds ) { final long finishAt = System . currentTimeMillis () + ( seconds * 1000L ) ; MST[rv.AOR3Mutator]MSP[N] boolean wasInterrupted = false ; try {
size += sizeOf0 ( file ) ; MST[rv.UOI1Mutator]MSP[N] if ( size < 0 ) { break; } } } return size ; } private static long sizeOf0 ( final File file ) { if ( file . isDirectory () ) { return sizeOfDirectory0 ( file ) ; }
if ( ! destDir . exists () ) { throw new FileNotFoundException ( lr_66 + destDir + lr_67 + createDestDir + lr_68 ) ; } if ( ! destDir . isDirectory () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] throw new IOException ( lr_27 + destDir + lr_28 ) ; }
while ( ! file . exists () ) { MST[rv.ROR4Mutator]MSP[N] final long remaining = finishAt - System . currentTimeMillis () ; if ( remaining < 0 ) { return false ; } try { Thread . sleep ( Math . min ( 100 , remaining ) ) ;
size += sizeOf0 ( file ) ; MST[MathMutator]MSP[N] if ( size < 0 ) { break; } } } return size ; } private static long sizeOf0 ( final File file ) { if ( file . isDirectory () ) { return sizeOfDirectory0 ( file ) ; }
} while ( i < n && url . charAt ( i ) == '%' ); MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] continue; } catch ( final RuntimeException e ) { } finally { if ( bytes . position () > 0 ) { bytes . flip () ;
public static LineIterator lineIterator ( final File file , final String encoding ) throws IOException { InputStream in = null ; try { in = openInputStream ( file ) ; return IOUtils . lineIterator ( in , encoding ) ; MST[ReturnValsMutator]MSP[N] } catch ( final IOException | RuntimeException ex ) {
for ( final String name : names ) { MST[rv.UOI3Mutator]MSP[S] file = new File ( file , name ) ; } return file ; } public static File getFile ( final String ... names ) { if ( names == null ) { throw new NullPointerException ( lr_2 ) ; }
Files . copy ( srcPath , destPath , StandardCopyOption . REPLACE_EXISTING ) ; MST[rv.CRCR6Mutator]MSP[N] checkEqualSizes ( srcFile , destFile , Files . size ( srcPath ) , Files . size ( destPath ) ) ;
doCopyDirectory ( srcFile , dstFile , filter , preserveFileDate , exclusionList ) ; } else { doCopyFile ( srcFile , dstFile , preserveFileDate ) ; } } } if ( preserveFileDate ) { MST[rv.ABSMutator]MSP[N] destDir . setLastModified ( srcDir . lastModified () ) ; } }
displaySize = String . valueOf ( size . divide ( ONE_EB_BI ) ) + lr_12 ; MST[NonVoidMethodCallMutator]MSP[N] } else if ( size . divide ( ONE_PB_BI ) . compareTo ( BigInteger . ZERO ) > 0 ) {
if ( srcDir == null ) { throw new NullPointerException ( lr_38 ) ; } if ( srcDir . exists () && srcDir . isDirectory () == false ) { MST[rv.ROR1Mutator]MSP[N] throw new IllegalArgumentException ( lr_29 + destDir + lr_28 ) ; } if ( destDir == null ) {
writeLines ( file , encoding , lines , null , append ) ; } public static void writeLines ( final File file , final Collection < ? > lines ) throws IOException { writeLines ( file , null , lines , null , false ) ; MST[rv.CRCR1Mutator]MSP[N] }
} while ( i < n && url . charAt ( i ) == '%' ); MST[NegateConditionalsMutator]MSP[N] continue; } catch ( final RuntimeException e ) { } finally { if ( bytes . position () > 0 ) { bytes . flip () ;
if ( null != exception ) { throw exception ; } } private static File [] verifiedListFiles ( final File directory ) throws IOException { if ( ! directory . exists () ) { MST[rv.ROR4Mutator]MSP[N] final String message = directory + lr_42 ; throw new IllegalArgumentException ( message ) ; }
} else { final File parent = file . getParentFile () ; if ( parent != null ) { if ( ! parent . mkdirs () && ! parent . isDirectory () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] throw new IOException ( lr_10 + parent + lr_11 ) ; } } }
throw new IllegalArgumentException ( lr_58 ) ; } if ( ! file . exists () ) { MST[rv.ROR5Mutator]MSP[S] return false ; } return file . lastModified () < timeMillis ; } public static long checksumCRC32 ( final File file ) throws IOException { final CRC32 crc = new CRC32 () ;
throws IOException { final boolean file1Exists = file1 . exists () ; if ( file1Exists != file2 . exists () ) { MST[rv.ROR4Mutator]MSP[N] return false ; } if ( ! file1Exists ) { return true ; } if ( file1 . isDirectory () || file2 . isDirectory () ) {
public static Iterator < File > iterateFilesAndDirs ( final File directory , final IOFileFilter fileFilter , final IOFileFilter dirFilter ) { return listFilesAndDirs ( directory , fileFilter , dirFilter ) . iterator () ; MST[ReturnValsMutator]MSP[S] } private static String [] toSuffixes ( final String [] extensions ) {
return new File ( filename ) ; MST[NullReturnValsMutator]MSP[N] } static String decodeUrl ( final String url ) { String decoded = url ; if ( url != null && url . indexOf ( '%' ) >= 0 ) { final int n = url . length () ;
displaySize = String . valueOf ( size . divide ( ONE_MB_BI ) ) + lr_16 ; } else if ( size . divide ( ONE_KB_BI ) . compareTo ( BigInteger . ZERO ) > 0 ) { MST[experimental.BigIntegerMutator]MSP[N]
if ( srcLen != dstLen ) { throw new IOException ( lr_34 + srcFile + lr_35 + destFile MST[rv.UOI1Mutator]MSP[N] + lr_36 + srcLen + lr_37 + dstLen ) ; } } public static void copyDirectoryToDirectory ( final File srcDir , final File destDir ) throws IOException {
if ( ! src . exists () ) { throw new FileNotFoundException ( lr_29 + src + lr_8 ) ; MST[NonVoidMethodCallMutator]MSP[N] } } private static void doCopyDirectory ( final File srcDir , final File destDir , final FileFilter filter , final boolean preserveFileDate , final List < String > exclusionList )
final File [] files = verifiedListFiles ( directory ) ; IOException exception = null ; for ( final File file : files ) { MST[rv.ABSMutator]MSP[N] try { forceDelete ( file ) ; } catch ( final IOException ioe ) { exception = ioe ; } }
try ( InputStream in = openInputStream ( file ) ) { return IOUtils . readLines ( in , Charsets . toCharset ( encoding ) ) ; MST[ReturnValsMutator]MSP[S] } } public static List < String > readLines ( final File file , final String encoding ) throws IOException {
if ( srcLen != dstLen ) { throw new IOException ( lr_34 + srcFile + lr_35 + destFile MST[rv.ABSMutator]MSP[N] + lr_36 + srcLen + lr_37 + dstLen ) ; } } public static void copyDirectoryToDirectory ( final File srcDir , final File destDir ) throws IOException {
return false ; } return file . lastModified () > timeMillis ; MST[rv.UOI4Mutator]MSP[S] } public static boolean isFileOlder ( final File file , final File reference ) { if ( reference == null ) { throw new IllegalArgumentException ( lr_54 ) ; }
final boolean filePresent = file . exists () ; if ( ! file . delete () ) { MST[rv.ROR3Mutator]MSP[S] if ( ! filePresent ) { throw new FileNotFoundException ( lr_48 + file ) ; } final String message = lr_49 + file ; throw new IOException ( message ) ; }
validateMoveParameters ( srcDir , destDir ) ; if ( ! srcDir . isDirectory () ) { throw new IOException ( lr_29 + srcDir + lr_28 ) ; MST[ConstructorCallMutator]MSP[S] } if ( destDir . exists () ) { throw new FileExistsException ( lr_27 + destDir + lr_60 ) ; }
cleanDirectory ( directory ) ; } if ( ! directory . delete () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] final String message = lr_44 + directory + lr_22 ; throw new IOException ( message ) ; } } public static boolean deleteQuietly ( final File file ) {
for ( final String name : names ) { MST[rv.UOI4Mutator]MSP[S] file = new File ( file , name ) ; } return file ; } public static File getFile ( final String ... names ) { if ( names == null ) { throw new NullPointerException ( lr_2 ) ; }
return new FileOutputStream ( file , append ) ; } public static String byteCountToDisplaySize ( final BigInteger size ) { String displaySize ; if ( size . divide ( ONE_EB_BI ) . compareTo ( BigInteger . ZERO ) > 0 ) { MST[rv.ROR1Mutator]MSP[N]
if ( file . exists () ) { if ( file . isDirectory () ) { throw new IOException ( lr_5 + file + lr_6 ) ; MST[NonVoidMethodCallMutator]MSP[S] } if ( file . canWrite () == false ) { throw new IOException ( lr_5 + file + lr_9 ) ; }
if ( ! src . exists () ) { throw new FileNotFoundException ( lr_29 + src + lr_8 ) ; MST[experimental.NakedReceiverMutator]MSP[N] } } private static void doCopyDirectory ( final File srcDir , final File destDir , final FileFilter filter , final boolean preserveFileDate , final List < String > exclusionList )
throw new IOException ( lr_5 + file + lr_6 ) ; } if ( file . canRead () == false ) { MST[rv.ROR2Mutator]MSP[N] throw new IOException ( lr_5 + file + lr_7 ) ; } } else { throw new FileNotFoundException ( lr_5 + file + lr_8 ) ; }
Files . copy ( srcPath , destPath , StandardCopyOption . REPLACE_EXISTING ) ; MST[rv.CRCR5Mutator]MSP[N] checkEqualSizes ( srcFile , destFile , Files . size ( srcPath ) , Files . size ( destPath ) ) ;
FileUtils . deleteQuietly ( destFile ) ; throw new IOException ( lr_70 + srcFile + MST[NonVoidMethodCallMutator]MSP[S] lr_64 + destFile + lr_65 ) ; } } } public static void moveFileToDirectory ( final File srcFile , final File destDir , final boolean createDestDir ) throws IOException {
validateMoveParameters ( srcFile , destDir ) ; if ( ! destDir . exists () && createDestDir ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] destDir . mkdirs () ; } if ( ! destDir . exists () ) { throw new FileNotFoundException ( lr_66 + destDir + lr_67 + createDestDir + lr_68 ) ; }
throw new IOException ( lr_41 + src + lr_42 ) ; MST[experimental.NakedReceiverMutator]MSP[N] } } public static void copyToDirectory ( final Iterable < File > srcs , final File destDir ) throws IOException { if ( srcs == null ) { throw new NullPointerException ( lr_43 ) ; }
private static void checkDirectory ( final File directory ) { if ( ! directory . exists () ) { throw new IllegalArgumentException ( directory + lr_42 ) ; MST[NonVoidMethodCallMutator]MSP[N] } if ( ! directory . isDirectory () ) { throw new IllegalArgumentException ( directory + lr_47 ) ; } }
if ( srcFile . getCanonicalPath () . equals ( destFile . getCanonicalPath () ) ) { throw new IOException ( lr_29 + srcFile + lr_30 + destFile + lr_31 ) ; } final File parentFile = destFile . getParentFile () ; MST[experimental.NakedReceiverMutator]MSP[N] if ( parentFile != null ) {
if ( srcLen != dstLen ) { throw new IOException ( lr_34 + srcFile + lr_35 + destFile MST[NonVoidMethodCallMutator]MSP[S] + lr_36 + srcLen + lr_37 + dstLen ) ; } } public static void copyDirectoryToDirectory ( final File srcDir , final File destDir ) throws IOException {
throw new NullPointerException ( lr_26 ) ; } if ( destDir . exists () && destDir . isDirectory () == false ) { MST[rv.ROR1Mutator]MSP[S] throw new IllegalArgumentException ( lr_27 + destDir + lr_28 ) ; }
writeLines ( file , encoding , lines , null , false ) ; MST[rv.CRCR6Mutator]MSP[N] } public static void writeLines ( final File file , final String encoding , final Collection < ? > lines , final boolean append ) throws IOException {
} catch ( final InterruptedException ignore ) { wasInterrupted = true ; MST[rv.CRCR3Mutator]MSP[N] } catch ( final Exception ex ) { break; } } } finally { if ( wasInterrupted ) { Thread . currentThread () . interrupt () ; } } return true ; }
final String [] suffixes = new String [ extensions . length ] ; for ( int i = 0 ; i < extensions . length ; i ++ ) { suffixes [ i ] = lr_22 + extensions [ i ] ; MST[rv.UOI1Mutator]MSP[N] } return suffixes ; }
if ( null != exception ) { throw exception ; } } public static void forceMkdir ( final File directory ) throws IOException { if ( directory . exists () ) { MST[rv.ROR1Mutator]MSP[N] if ( ! directory . isDirectory () ) { final String message = lr_50 + directory + lr_51
if ( srcFile . getCanonicalPath () . equals ( destFile . getCanonicalPath () ) ) { MST[rv.ROR1Mutator]MSP[N] throw new IOException ( lr_29 + srcFile + lr_30 + destFile + lr_31 ) ; } final File parentFile = destFile . getParentFile () ; if ( parentFile != null ) {
final int connectionTimeout , final int readTimeout ) throws IOException { final URLConnection connection = source . openConnection () ; connection . setConnectTimeout ( connectionTimeout ) ; connection . setReadTimeout ( readTimeout ) ; MST[rv.UOI2Mutator]MSP[N] copyInputStreamToFile ( connection . getInputStream () , destination ) ; }
final byte octet = ( byte ) Integer . parseInt ( url . substring ( i + 1 , i + 3 ) , 16 ) ; MST[NonVoidMethodCallMutator]MSP[N] bytes . put ( octet ) ; i += 3 ;
} public static File [] toFiles ( final URL [] urls ) { if ( urls == null || urls . length == 0 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] return EMPTY_FILE_ARRAY ; } final File [] files = new File [ urls . length ] ;
throw new NullPointerException ( lr_26 ) ; } if ( destDir . exists () && destDir . isDirectory () == false ) { MST[rv.ROR2Mutator]MSP[N] throw new IllegalArgumentException ( lr_27 + destDir + lr_28 ) ; }
final File [] files = directory . listFiles () ; if ( files == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return 0L ; } long size = 0 ; for ( final File file : files ) { if ( ! isSymlink ( file ) ) {
if ( ! destDir . exists () ) { throw new FileNotFoundException ( lr_66 + destDir + lr_67 + createDestDir + lr_68 ) ; } if ( ! destDir . isDirectory () ) { MST[NegateConditionalsMutator]MSP[N] throw new IOException ( lr_27 + destDir + lr_28 ) ; }
throw new IOException ( lr_5 + file + lr_6 ) ; MST[experimental.NakedReceiverMutator]MSP[N] } if ( file . canRead () == false ) { throw new IOException ( lr_5 + file + lr_7 ) ; } } else { throw new FileNotFoundException ( lr_5 + file + lr_8 ) ; }
for ( final File src : srcs ) { copyFileToDirectory ( src , destDir ) ; } } public static void deleteDirectory ( final File directory ) throws IOException { if ( ! directory . exists () ) { return; } if ( ! isSymlink ( directory ) ) { MST[rv.ROR1Mutator]MSP[S]
try ( InputStream in = openInputStream ( file ) ) { return IOUtils . readLines ( in , Charsets . toCharset ( encoding ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } } public static List < String > readLines ( final File file , final String encoding ) throws IOException {
displaySize = String . valueOf ( size . divide ( ONE_KB_BI ) ) + lr_17 ; MST[NonVoidMethodCallMutator]MSP[N] } else { displaySize = String . valueOf ( size ) + lr_18 ; } return displaySize ; } public static String byteCountToDisplaySize ( final long size ) {
if ( ! directory . isDirectory () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] throw new IllegalArgumentException ( lr_46 + directory ) ; } if ( child == null ) { return false ; } if ( ! directory . exists () || ! child . exists () ) { return false ; }
try { if ( in != null ) { MST[rv.ROR5Mutator]MSP[S] in . close () ; } } catch ( final IOException e ) { ex . addSuppressed ( e ) ; } throw ex ; } } public static LineIterator lineIterator ( final File file ) throws IOException {
final int connectionTimeout , final int readTimeout ) throws IOException { final URLConnection connection = source . openConnection () ; connection . setConnectTimeout ( connectionTimeout ) ; connection . setReadTimeout ( readTimeout ) ; copyInputStreamToFile ( connection . getInputStream () , destination ) ; MST[NonVoidMethodCallMutator]MSP[S] }
if ( destDir . isDirectory () == false ) { MST[rv.ROR2Mutator]MSP[N] throw new IOException ( lr_27 + destDir + lr_39 ) ; } } else { if ( ! destDir . mkdirs () && ! destDir . isDirectory () ) {
throw new IOException ( lr_27 + destFile + lr_69 ) ; } final boolean rename = srcFile . renameTo ( destFile ) ; if ( ! rename ) { MST[NegateConditionalsMutator]MSP[N] copyFile ( srcFile , destFile ) ; if ( ! srcFile . delete () ) {
checksum ( file , crc ) ; return crc . getValue () ; } public static Checksum checksum ( final File file , final Checksum checksum ) throws IOException { if ( file . isDirectory () ) { throw new IllegalArgumentException ( lr_59 ) ; MST[ConstructorCallMutator]MSP[S] }
public static LineIterator lineIterator ( final File file , final String encoding ) throws IOException { InputStream in = null ; try { in = openInputStream ( file ) ; return IOUtils . lineIterator ( in , encoding ) ; MST[NonVoidMethodCallMutator]MSP[N] } catch ( final IOException | RuntimeException ex ) {
if ( ! destDir . exists () ) { throw new FileNotFoundException ( lr_66 + destDir + lr_67 + createDestDir + lr_68 ) ; } if ( ! destDir . isDirectory () ) { throw new IOException ( lr_27 + destDir + lr_28 ) ; MST[experimental.NakedReceiverMutator]MSP[N] }
public static BigInteger sizeOfAsBigInteger ( final File file ) { if ( ! file . exists () ) { final String message = file + lr_42 ; throw new IllegalArgumentException ( message ) ; } if ( file . isDirectory () ) { MST[NonVoidMethodCallMutator]MSP[N] return sizeOfDirectoryBig0 ( file ) ; }
return new FileInputStream ( file ) ; } public static FileOutputStream openOutputStream ( final File file ) throws IOException { return openOutputStream ( file , false ) ; MST[InlineConstantMutator]MSP[N] } public static FileOutputStream openOutputStream ( final File file , final boolean append ) throws IOException {
if ( ! src . exists () ) { throw new FileNotFoundException ( lr_29 + src + lr_8 ) ; MST[ConstructorCallMutator]MSP[N] } } private static void doCopyDirectory ( final File srcDir , final File destDir , final FileFilter filter , final boolean preserveFileDate , final List < String > exclusionList )
private static void checkDirectory ( final File directory ) { if ( ! directory . exists () ) { MST[NegateConditionalsMutator]MSP[N] throw new IllegalArgumentException ( directory + lr_42 ) ; } if ( ! directory . isDirectory () ) { throw new IllegalArgumentException ( directory + lr_47 ) ; } }
final boolean success = file . setLastModified ( System . currentTimeMillis () ) ; if ( ! success ) { MST[rv.ROR2Mutator]MSP[N] throw new IOException ( lr_19 + file ) ; } } public static File [] convertFileCollectionToFileArray ( final Collection < File > files ) {
throw new IOException ( lr_27 + destDir + lr_32 ) ; } } if ( destDir . canWrite () == false ) { throw new IOException ( lr_27 + destDir + lr_9 ) ; } for ( final File srcFile : srcFiles ) { MST[rv.UOI4Mutator]MSP[N]
validateMoveParameters ( srcDir , destDir ) ; if ( ! srcDir . isDirectory () ) { MST[rv.ROR5Mutator]MSP[N] throw new IOException ( lr_29 + srcDir + lr_28 ) ; } if ( destDir . exists () ) { throw new FileExistsException ( lr_27 + destDir + lr_60 ) ; }
for ( int i = 0 ; i < urls . length ; i ++ ) { MST[rv.ROR3Mutator]MSP[N] final URL url = urls [ i ] ; if ( url != null ) { if ( url . getProtocol () . equals ( lr_24 ) == false ) {
public static String readFileToString ( final File file , final Charset encoding ) throws IOException { try ( InputStream in = openInputStream ( file ) ) { return IOUtils . toString ( in , Charsets . toCharset ( encoding ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } }
throw new NullPointerException ( lr_26 ) ; } if ( ! src . exists () ) { throw new FileNotFoundException ( lr_29 + src + lr_8 ) ; MST[NonVoidMethodCallMutator]MSP[N] } } public static boolean isSymlink ( final File file ) { if ( file == null ) {
public static boolean isFileNewer ( final File file , final File reference ) { if ( reference == null ) { throw new IllegalArgumentException ( lr_54 ) ; } if ( ! reference . exists () ) { MST[NonVoidMethodCallMutator]MSP[N] throw new IllegalArgumentException ( lr_55 + reference + lr_56 ) ; }
if ( ! parentFile . mkdirs () && ! parentFile . isDirectory () ) { throw new IOException ( lr_27 + parentFile + lr_32 ) ; } } if ( destFile . exists () && destFile . canWrite () == false ) { MST[rv.ROR4Mutator]MSP[N]
throws IOException { final boolean file1Exists = file1 . exists () ; if ( file1Exists != file2 . exists () ) { return false ; } if ( ! file1Exists ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] return true ; } if ( file1 . isDirectory () || file2 . isDirectory () ) {
public static String getTempDirectoryPath () { return System . getProperty ( lr_3 ) ; } public static File getTempDirectory () { return new File ( getTempDirectoryPath () ) ; } public static String getUserDirectoryPath () { return System . getProperty ( lr_4 ) ; MST[ReturnValsMutator]MSP[N] }
displaySize = String . valueOf ( size . divide ( ONE_GB_BI ) ) + lr_15 ; MST[ArgumentPropagationMutator]MSP[N] } else if ( size . divide ( ONE_MB_BI ) . compareTo ( BigInteger . ZERO ) > 0 ) {
size += sizeOf0 ( file ) ; if ( size < 0 ) { MST[rv.ROR5Mutator]MSP[N] break; } } } return size ; } private static long sizeOf0 ( final File file ) { if ( file . isDirectory () ) { return sizeOfDirectory0 ( file ) ; }
try ( OutputStream out = openOutputStream ( destination ) ) { IOUtils . copy ( source , out ) ; } } public static void copyToDirectory ( final File src , final File destDir ) throws IOException { if ( src == null ) { MST[NegateConditionalsMutator]MSP[N]
displaySize = String . valueOf ( size . divide ( ONE_EB_BI ) ) + lr_12 ; MST[experimental.NakedReceiverMutator]MSP[N] } else if ( size . divide ( ONE_PB_BI ) . compareTo ( BigInteger . ZERO ) > 0 ) {
} public static void copyFile ( final File srcFile , final File destFile , final boolean preserveFileDate ) throws IOException { checkFileRequirements ( srcFile , destFile ) ; if ( srcFile . isDirectory () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] throw new IOException ( lr_29 + srcFile + lr_6 ) ; }
throws IOException { final File [] srcFiles = filter == null ? srcDir . listFiles () : srcDir . listFiles ( filter ) ; if ( srcFiles == null ) { MST[rv.ROR5Mutator]MSP[N] throw new IOException ( lr_40 + srcDir ) ; } if ( destDir . exists () ) {
final StringBuilder buffer = new StringBuilder () ; final ByteBuffer bytes = ByteBuffer . allocate ( n ) ; for ( int i = 0 ; i < n ; ) { if ( url . charAt ( i ) == '%' ) { MST[NegateConditionalsMutator]MSP[N] try { do {
final StringBuilder buffer = new StringBuilder () ; final ByteBuffer bytes = ByteBuffer . allocate ( n ) ; for ( int i = 0 ; i < n ; ) { if ( url . charAt ( i ) == '%' ) { MST[InlineConstantMutator]MSP[N] try { do {
throw new IOException ( lr_29 + srcDir + lr_30 + destDir + lr_31 ) ; MST[NonVoidMethodCallMutator]MSP[S] } List < String > exclusionList = null ; if ( destDir . getCanonicalPath () . startsWith ( srcDir . getCanonicalPath () ) ) {
return isFileNewer ( file , date . getTime () ) ; } public static boolean isFileNewer ( final File file , final long timeMillis ) { if ( file == null ) { throw new IllegalArgumentException ( lr_58 ) ; } if ( ! file . exists () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
} private static void checkFileRequirements ( final File src , final File dest ) throws FileNotFoundException { if ( src == null ) { throw new NullPointerException ( lr_38 ) ; } if ( dest == null ) { MST[NegateConditionalsMutator]MSP[N] throw new NullPointerException ( lr_26 ) ; }
for ( int i = 0 ; i < urls . length ; i ++ ) { final URL url = urls [ i ] ; if ( url != null ) { if ( url . getProtocol () . equals ( lr_24 ) == false ) { MST[rv.ROR3Mutator]MSP[N]
public static boolean isFileNewer ( final File file , final File reference ) { if ( reference == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] throw new IllegalArgumentException ( lr_54 ) ; } if ( ! reference . exists () ) { throw new IllegalArgumentException ( lr_55 + reference + lr_56 ) ; }
for ( final String name : names ) { file = new File ( file , name ) ; } return file ; MST[ReturnValsMutator]MSP[S] } public static File getFile ( final String ... names ) { if ( names == null ) { throw new NullPointerException ( lr_2 ) ; }
if ( srcDir == null ) { throw new NullPointerException ( lr_38 ) ; } if ( srcDir . exists () && srcDir . isDirectory () == false ) { MST[rv.ROR4Mutator]MSP[N] throw new IllegalArgumentException ( lr_29 + destDir + lr_28 ) ; } if ( destDir == null ) {
displaySize = String . valueOf ( size . divide ( ONE_MB_BI ) ) + lr_16 ; MST[experimental.NakedReceiverMutator]MSP[N] } else if ( size . divide ( ONE_KB_BI ) . compareTo ( BigInteger . ZERO ) > 0 ) {
for ( int i = 0 ; i < urls . length ; i ++ ) { final URL url = urls [ i ] ; if ( url != null ) { MST[NegateConditionalsMutator]MSP[N] if ( url . getProtocol () . equals ( lr_24 ) == false ) {
try ( OutputStream out = openOutputStream ( file , append ) ) { out . write ( data , off , len ) ; MST[rv.UOI4Mutator]MSP[N] } } public static void writeLines ( final File file , final String encoding , final Collection < ? > lines ) throws IOException {
final StringBuilder buffer = new StringBuilder () ; final ByteBuffer bytes = ByteBuffer . allocate ( n ) ; for ( int i = 0 ; i < n ; ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] if ( url . charAt ( i ) == '%' ) { try { do {
Files . copy ( srcPath , destPath , StandardCopyOption . REPLACE_EXISTING ) ; MST[rv.CRCR3Mutator]MSP[N] checkEqualSizes ( srcFile , destFile , Files . size ( srcPath ) , Files . size ( destPath ) ) ;
while ( ! file . exists () ) { final long remaining = finishAt - System . currentTimeMillis () ; if ( remaining < 0 ) { return false ; MST[BooleanFalseReturnValsMutator]MSP[N] } try { Thread . sleep ( Math . min ( 100 , remaining ) ) ;
if ( url == null || ! lr_24 . equalsIgnoreCase ( url . getProtocol () ) ) { MST[rv.ROR4Mutator]MSP[S] return null ; } String filename = url . getFile () . replace ( '/' , File . separatorChar ) ; filename = decodeUrl ( filename ) ;
} while ( i < n && url . charAt ( i ) == '%' ); MST[rv.UOI2Mutator]MSP[N] continue; } catch ( final RuntimeException e ) { } finally { if ( bytes . position () > 0 ) { bytes . flip () ;
} public static File [] toFiles ( final URL [] urls ) { if ( urls == null || urls . length == 0 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return EMPTY_FILE_ARRAY ; } final File [] files = new File [ urls . length ] ;
if ( destDir . isDirectory () == false ) { MST[NonVoidMethodCallMutator]MSP[N] throw new IOException ( lr_27 + destDir + lr_39 ) ; } } else { if ( ! destDir . mkdirs () && ! destDir . isDirectory () ) {
throw new NullPointerException ( lr_38 ) ; } if ( src . isFile () ) { MST[rv.ROR5Mutator]MSP[N] copyFileToDirectory ( src , destDir ) ; } else if ( src . isDirectory () ) { copyDirectoryToDirectory ( src , destDir ) ; } else {
return isFileNewer ( file , reference . lastModified () ) ; } public static boolean isFileNewer ( final File file , final Date date ) { if ( date == null ) { MST[NegateConditionalsMutator]MSP[N] throw new IllegalArgumentException ( lr_57 ) ; }
if ( ! destDir . exists () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] throw new FileNotFoundException ( lr_66 + destDir + lr_67 + createDestDir + lr_68 ) ; } if ( ! destDir . isDirectory () ) { throw new IOException ( lr_27 + destDir + lr_28 ) ; }
throw new IllegalArgumentException ( MST[NonVoidMethodCallMutator]MSP[N] lr_25 + url ) ; } files [ i ] = toFile ( url ) ; } } return files ; } public static URL [] toURLs ( final File [] files ) throws IOException {
final boolean file1Exists = file1 . exists () ; if ( file1Exists != file2 . exists () ) { return false ; } if ( ! file1Exists ) { return true ; } if ( file1 . isDirectory () || file2 . isDirectory () ) { MST[rv.ROR1Mutator]MSP[N]
final byte octet = ( byte ) Integer . parseInt ( url . substring ( i + 1 , i + 3 ) , 16 ) ; MST[rv.CRCR6Mutator]MSP[N] bytes . put ( octet ) ; i += 3 ;
try ( InputStream input1 = new FileInputStream ( file1 ) ; InputStream input2 = new FileInputStream ( file2 ) ) { return IOUtils . contentEquals ( input1 , input2 ) ; MST[rv.UOI3Mutator]MSP[N] } } public static boolean contentEqualsIgnoreEOL ( final File file1 , final File file2 , final String charsetName )
throw new IOException ( lr_40 + directory ) ; } return files ; } public static boolean waitFor ( final File file , final int seconds ) { final long finishAt = System . currentTimeMillis () + ( seconds * 1000L ) ; MST[rv.CRCR6Mutator]MSP[N] boolean wasInterrupted = false ; try {
throw new IOException ( lr_23 ) ; } if ( file1 . length () != file2 . length () ) { MST[rv.ROR1Mutator]MSP[N] return false ; } if ( file1 . getCanonicalFile () . equals ( file2 . getCanonicalFile () ) ) { return true ; }
final URL [] urls = new URL [ files . length ] ; for ( int i = 0 ; i < urls . length ; i ++ ) { MST[rv.ROR2Mutator]MSP[S] urls [ i ] = files [ i ] . toURI () . toURL () ; } return urls ;
if ( srcFile . getCanonicalPath () . equals ( destFile . getCanonicalPath () ) ) { MST[rv.ROR4Mutator]MSP[S] throw new IOException ( lr_29 + srcFile + lr_30 + destFile + lr_31 ) ; } final File parentFile = destFile . getParentFile () ; if ( parentFile != null ) {
copyDirectory ( srcDir , new File ( destDir , srcDir . getName () ) , true ) ; MST[rv.CRCR3Mutator]MSP[N] } public static void copyDirectory ( final File srcDir , final File destDir ) throws IOException { copyDirectory ( srcDir , destDir , true ) ; }
return byteCountToDisplaySize ( BigInteger . valueOf ( size ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } public static void touch ( final File file ) throws IOException { if ( ! file . exists () ) { openOutputStream ( file ) . close () ; }
final String [] suffixes = toSuffixes ( extensions ) ; MST[ArgumentPropagationMutator]MSP[N] filter = new SuffixFileFilter ( suffixes ) ; } return listFiles ( directory , filter , recursive ? TrueFileFilter . INSTANCE : FalseFileFilter . INSTANCE ) ; } public static Iterator < File > iterateFiles (
buffer . append ( StandardCharsets . UTF_8 . decode ( bytes ) . toString () ) ; bytes . clear () ; } } } buffer . append ( url . charAt ( i ++ ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } decoded = buffer . toString () ; } return decoded ;
final boolean append ) throws IOException { try ( OutputStream out = openOutputStream ( file , append ) ) { MST[rv.UOI1Mutator]MSP[N] IOUtils . write ( data , out , encoding ) ; } } public static void writeStringToFile ( final File file , final String data , final String encoding ,
public static void moveDirectoryToDirectory ( final File src , final File destDir , final boolean createDestDir ) throws IOException { validateMoveParameters ( src , destDir ) ; if ( ! destDir . exists () && createDestDir ) { MST[NonVoidMethodCallMutator]MSP[N] destDir . mkdirs () ; }
final File [] found = directory . listFiles ( ( FileFilter ) filter ) ; if ( found != null ) { for ( final File file : found ) { if ( file . isDirectory () ) { MST[rv.ROR3Mutator]MSP[N] if ( includeSubDirectories ) {
if ( file == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return false ; } try { if ( file . isDirectory () ) { cleanDirectory ( file ) ; } } catch ( final Exception ignored ) { } try { return file . delete () ;
} while ( i < n && url . charAt ( i ) == '%' ); MST[rv.UOI1Mutator]MSP[N] continue; } catch ( final RuntimeException e ) { } finally { if ( bytes . position () > 0 ) { bytes . flip () ;
public static String readFileToString ( final File file , final Charset encoding ) throws IOException { try ( InputStream in = openInputStream ( file ) ) { return IOUtils . toString ( in , Charsets . toCharset ( encoding ) ) ; MST[ReturnValsMutator]MSP[N] } }
Files . copy ( srcPath , destPath , StandardCopyOption . REPLACE_EXISTING ) ; MST[rv.CRCR2Mutator]MSP[N] checkEqualSizes ( srcFile , destFile , Files . size ( srcPath ) , Files . size ( destPath ) ) ;
throw new IOException ( lr_27 + destDir + lr_32 ) ; } } if ( destDir . canWrite () == false ) { throw new IOException ( lr_27 + destDir + lr_9 ) ; } for ( final File srcFile : srcFiles ) { MST[rv.UOI1Mutator]MSP[N]
public static void writeLines ( final File file , final Collection < ? > lines , final boolean append ) throws IOException { writeLines ( file , null , lines , null , append ) ; MST[rv.UOI2Mutator]MSP[N] }
while ( ! file . exists () ) { final long remaining = finishAt - System . currentTimeMillis () ; if ( remaining < 0 ) { return false ; MST[rv.CRCR1Mutator]MSP[N] } try { Thread . sleep ( Math . min ( 100 , remaining ) ) ;
displaySize = String . valueOf ( size . divide ( ONE_PB_BI ) ) + lr_13 ; } else if ( size . divide ( ONE_TB_BI ) . compareTo ( BigInteger . ZERO ) > 0 ) { MST[NegateConditionalsMutator]MSP[N]
return FileFilterUtils . and ( fileFilter , FileFilterUtils . notFileFilter ( DirectoryFileFilter . INSTANCE ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } private static IOFileFilter setUpEffectiveDirFilter ( final IOFileFilter dirFilter ) { return dirFilter == null ? FalseFileFilter . INSTANCE : FileFilterUtils . and ( dirFilter , DirectoryFileFilter . INSTANCE ) ; }
? new InputStreamReader ( new FileInputStream ( file1 ) , Charset . defaultCharset () ) : new InputStreamReader ( new FileInputStream ( file1 ) , charsetName ) ; Reader input2 = charsetName == null MST[ConstructorCallMutator]MSP[S] ? new InputStreamReader ( new FileInputStream ( file2 ) , Charset . defaultCharset () )
if ( ! directory . exists () ) { return; } directory . deleteOnExit () ; if ( ! isSymlink ( directory ) ) { MST[rv.ROR4Mutator]MSP[N] cleanDirectoryOnExit ( directory ) ; } } private static void cleanDirectoryOnExit ( final File directory ) throws IOException {
final File [] files = directory . listFiles () ; if ( files == null ) { return 0L ; } long size = 0 ; for ( final File file : files ) { MST[rv.ABSMutator]MSP[N] if ( ! isSymlink ( file ) ) {
if ( file . exists () ) { if ( file . isDirectory () ) { throw new IOException ( lr_5 + file + lr_6 ) ; MST[experimental.NakedReceiverMutator]MSP[N] } if ( file . canWrite () == false ) { throw new IOException ( lr_5 + file + lr_9 ) ; }
validateMoveParameters ( srcDir , destDir ) ; if ( ! srcDir . isDirectory () ) { throw new IOException ( lr_29 + srcDir + lr_28 ) ; } if ( destDir . exists () ) { MST[rv.ROR1Mutator]MSP[N] throw new FileExistsException ( lr_27 + destDir + lr_60 ) ; }
moveFileToDirectory ( src , destDir , createDestDir ) ; MST[VoidMethodCallMutator]MSP[S] } } private static void validateMoveParameters ( final File src , final File dest ) throws FileNotFoundException { if ( src == null ) { throw new NullPointerException ( lr_38 ) ; } if ( dest == null ) {
private static void checkDirectory ( final File directory ) { if ( ! directory . exists () ) { throw new IllegalArgumentException ( directory + lr_42 ) ; MST[experimental.NakedReceiverMutator]MSP[N] } if ( ! directory . isDirectory () ) { throw new IllegalArgumentException ( directory + lr_47 ) ; } }
public static File getUserDirectory () { return new File ( getUserDirectoryPath () ) ; } public static FileInputStream openInputStream ( final File file ) throws IOException { if ( file . exists () ) { if ( file . isDirectory () ) { MST[rv.ROR3Mutator]MSP[N]
if ( file . exists () ) { MST[rv.ROR4Mutator]MSP[N] if ( file . isDirectory () ) { throw new IOException ( lr_5 + file + lr_6 ) ; } if ( file . canWrite () == false ) { throw new IOException ( lr_5 + file + lr_9 ) ; }
final File dstFile = new File ( destDir , srcFile . getName () ) ; if ( exclusionList == null || ! exclusionList . contains ( srcFile . getCanonicalPath () ) ) { MST[rv.ROR4Mutator]MSP[S] if ( srcFile . isDirectory () ) {
throw new IOException ( lr_29 + srcFile + lr_69 ) ; } if ( destFile . exists () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] throw new FileExistsException ( lr_27 + destFile + lr_60 ) ; } if ( destFile . isDirectory () ) {
final Collection < File > files = new java . util . LinkedList <> () ; if ( includeSubDirectories ) { files . add ( directory ) ; } innerListFiles ( files , directory , MST[VoidMethodCallMutator]MSP[N] FileFilterUtils . or ( effFileFilter , effDirFilter ) , includeSubDirectories ) ; return files ;
throw new IOException ( lr_23 ) ; } if ( file1 . getCanonicalFile () . equals ( file2 . getCanonicalFile () ) ) { MST[rv.ROR3Mutator]MSP[S] return true ; } try ( Reader input1 = charsetName == null
final String canonicalParent = directory . getCanonicalPath () ; final String canonicalChild = child . getCanonicalPath () ; return FilenameUtils . directoryContains ( canonicalParent , canonicalChild ) ; MST[BooleanFalseReturnValsMutator]MSP[S] } public static void cleanDirectory ( final File directory ) throws IOException {
} } public static void forceDeleteOnExit ( final File file ) throws IOException { if ( file . isDirectory () ) { MST[rv.ROR2Mutator]MSP[S] deleteDirectoryOnExit ( file ) ; } else { file . deleteOnExit () ; } } private static void deleteDirectoryOnExit ( final File directory ) throws IOException {
return new FileOutputStream ( file , append ) ; MST[rv.UOI3Mutator]MSP[N] } public static String byteCountToDisplaySize ( final BigInteger size ) { String displaySize ; if ( size . divide ( ONE_EB_BI ) . compareTo ( BigInteger . ZERO ) > 0 ) {
final boolean rename = srcDir . renameTo ( destDir ) ; if ( ! rename ) { if ( destDir . getCanonicalPath () . startsWith ( srcDir . getCanonicalPath () + File . separator ) ) { MST[NegateConditionalsMutator]MSP[N] throw new IOException ( lr_61 + srcDir + lr_62 + destDir ) ;
displaySize = String . valueOf ( size . divide ( ONE_MB_BI ) ) + lr_16 ; } else if ( size . divide ( ONE_KB_BI ) . compareTo ( BigInteger . ZERO ) > 0 ) { MST[rv.ROR3Mutator]MSP[N]
final boolean success = file . setLastModified ( System . currentTimeMillis () ) ; if ( ! success ) { MST[rv.UOI4Mutator]MSP[N] throw new IOException ( lr_19 + file ) ; } } public static File [] convertFileCollectionToFileArray ( final Collection < File > files ) {
public static Collection < File > listFilesAndDirs ( final File directory , final IOFileFilter fileFilter , final IOFileFilter dirFilter ) { return innerListFilesOrDirectories ( directory , fileFilter , dirFilter , true ) ; MST[ReturnValsMutator]MSP[N] } private static Collection < File > innerListFilesOrDirectories (
if ( ! directory . isDirectory () ) { throw new IllegalArgumentException ( lr_46 + directory ) ; } if ( child == null ) { return false ; } if ( ! directory . exists () || ! child . exists () ) { MST[NegateConditionalsMutator]MSP[N] return false ; }
size += sizeOf0 ( file ) ; MST[rv.UOI4Mutator]MSP[N] if ( size < 0 ) { break; } } } return size ; } private static long sizeOf0 ( final File file ) { if ( file . isDirectory () ) { return sizeOfDirectory0 ( file ) ; }
if ( ! destDir . isDirectory () ) { throw new IOException ( lr_27 + destDir + lr_28 ) ; MST[NonVoidMethodCallMutator]MSP[N] } moveFile ( srcFile , new File ( destDir , srcFile . getName () ) ) ; }
final Collection < File > files = new java . util . LinkedList <> () ; if ( includeSubDirectories ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] files . add ( directory ) ; } innerListFiles ( files , directory , FileFilterUtils . or ( effFileFilter , effDirFilter ) , includeSubDirectories ) ; return files ;
throw new IllegalArgumentException ( lr_58 ) ; } if ( ! file . exists () ) { return false ; } return file . lastModified () < timeMillis ; MST[rv.UOI2Mutator]MSP[N] } public static long checksumCRC32 ( final File file ) throws IOException { final CRC32 crc = new CRC32 () ;
displaySize = String . valueOf ( size . divide ( ONE_PB_BI ) ) + lr_13 ; MST[NonVoidMethodCallMutator]MSP[N] } else if ( size . divide ( ONE_TB_BI ) . compareTo ( BigInteger . ZERO ) > 0 ) {
final Collection < File > files = new java . util . LinkedList <> () ; if ( includeSubDirectories ) { files . add ( directory ) ; } innerListFiles ( files , directory , MST[rv.CRCR3Mutator]MSP[N] FileFilterUtils . or ( effFileFilter , effDirFilter ) , includeSubDirectories ) ; return files ;
throw new IOException ( lr_41 + src + lr_42 ) ; MST[NonVoidMethodCallMutator]MSP[S] } } public static void copyToDirectory ( final Iterable < File > srcs , final File destDir ) throws IOException { if ( srcs == null ) { throw new NullPointerException ( lr_43 ) ; }
final boolean file1Exists = file1 . exists () ; if ( file1Exists != file2 . exists () ) { MST[rv.ROR5Mutator]MSP[N] return false ; } if ( ! file1Exists ) { return true ; } if ( file1 . isDirectory () || file2 . isDirectory () ) {
if ( null != exception ) { throw exception ; } } public static void forceMkdir ( final File directory ) throws IOException { if ( directory . exists () ) { MST[rv.ROR4Mutator]MSP[S] if ( ! directory . isDirectory () ) { final String message = lr_50 + directory + lr_51
throws IOException { final boolean file1Exists = file1 . exists () ; if ( file1Exists != file2 . exists () ) { return false ; } if ( ! file1Exists ) { return true ; } if ( file1 . isDirectory () || file2 . isDirectory () ) { MST[rv.ROR2Mutator]MSP[S]
throws IOException { final boolean file1Exists = file1 . exists () ; if ( file1Exists != file2 . exists () ) { return false ; } if ( ! file1Exists ) { return true ; } if ( file1 . isDirectory () || file2 . isDirectory () ) { MST[rv.ROR3Mutator]MSP[S]
final StringBuilder buffer = new StringBuilder () ; final ByteBuffer bytes = ByteBuffer . allocate ( n ) ; for ( int i = 0 ; i < n ; ) { if ( url . charAt ( i ) == '%' ) { MST[rv.UOI2Mutator]MSP[N] try { do {
final String [] suffixes = new String [ extensions . length ] ; for ( int i = 0 ; i < extensions . length ; i ++ ) { suffixes [ i ] = lr_22 + extensions [ i ] ; MST[rv.UOI4Mutator]MSP[N] } return suffixes ; }
final byte octet = ( byte ) Integer . parseInt ( url . substring ( i + 1 , i + 3 ) , 16 ) ; MST[rv.AOR1Mutator]MSP[N] bytes . put ( octet ) ; i += 3 ;
public static void writeLines ( final File file , final String encoding , final Collection < ? > lines , final String lineEnding , final boolean append ) throws IOException { try ( OutputStream out = new BufferedOutputStream ( openOutputStream ( file , append ) ) ) { MST[NonVoidMethodCallMutator]MSP[N]
FileUtils . deleteQuietly ( destFile ) ; throw new IOException ( lr_70 + srcFile + MST[experimental.NakedReceiverMutator]MSP[N] lr_64 + destFile + lr_65 ) ; } } } public static void moveFileToDirectory ( final File srcFile , final File destDir , final boolean createDestDir ) throws IOException {
if ( ! parentFile . mkdirs () && ! parentFile . isDirectory () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] throw new IOException ( lr_27 + parentFile + lr_32 ) ; } } if ( destFile . exists () && destFile . canWrite () == false ) {
public static File getUserDirectory () { return new File ( getUserDirectoryPath () ) ; } public static FileInputStream openInputStream ( final File file ) throws IOException { if ( file . exists () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] if ( file . isDirectory () ) {
for ( int i = 0 ; i < urls . length ; i ++ ) { final URL url = urls [ i ] ; MST[rv.UOI1Mutator]MSP[N] if ( url != null ) { if ( url . getProtocol () . equals ( lr_24 ) == false ) {
validateMoveParameters ( srcDir , destDir ) ; if ( ! srcDir . isDirectory () ) { throw new IOException ( lr_29 + srcDir + lr_28 ) ; MST[experimental.NakedReceiverMutator]MSP[N] } if ( destDir . exists () ) { throw new FileExistsException ( lr_27 + destDir + lr_60 ) ; }
File file = null ; for ( final String name : names ) { MST[rv.UOI1Mutator]MSP[S] if ( file == null ) { file = new File ( name ) ; } else { file = new File ( file , name ) ; } } return file ; }
return false ; } return file . lastModified () > timeMillis ; MST[NonVoidMethodCallMutator]MSP[S] } public static boolean isFileOlder ( final File file , final File reference ) { if ( reference == null ) { throw new IllegalArgumentException ( lr_54 ) ; }
} copyDirectory ( srcDir , destDir ) ; deleteDirectory ( srcDir ) ; if ( srcDir . exists () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] throw new IOException ( lr_63 + srcDir + lr_64 + destDir + lr_65 ) ; } } }
if ( ! reference . exists () ) { throw new IllegalArgumentException ( lr_55 + reference + lr_56 ) ; } return isFileOlder ( file , reference . lastModified () ) ; MST[NonVoidMethodCallMutator]MSP[S] } public static boolean isFileOlder ( final File file , final Date date ) {
writeLines ( file , encoding , lines , null , append ) ; MST[VoidMethodCallMutator]MSP[N] } public static void writeLines ( final File file , final Collection < ? > lines ) throws IOException { writeLines ( file , null , lines , null , false ) ; }
throw new IllegalArgumentException ( lr_25 + url ) ; } files [ i ] = toFile ( url ) ; } } return files ; MST[ReturnValsMutator]MSP[N] } public static URL [] toURLs ( final File [] files ) throws IOException {
throw new IOException ( lr_40 + directory ) ; MST[NonVoidMethodCallMutator]MSP[S] } return files ; } public static boolean waitFor ( final File file , final int seconds ) { final long finishAt = System . currentTimeMillis () + ( seconds * 1000L ) ; boolean wasInterrupted = false ; try {
public static Collection < File > listFilesAndDirs ( final File directory , final IOFileFilter fileFilter , final IOFileFilter dirFilter ) { return innerListFilesOrDirectories ( directory , fileFilter , dirFilter , true ) ; MST[rv.CRCR5Mutator]MSP[N] } private static Collection < File > innerListFilesOrDirectories (
if ( ! destDir . exists () ) { throw new FileNotFoundException ( lr_66 + destDir + lr_67 + createDestDir + lr_68 ) ; } if ( ! destDir . isDirectory () ) { throw new IOException ( lr_27 + destDir + lr_28 ) ; MST[NonVoidMethodCallMutator]MSP[S] }
return FileFilterUtils . and ( fileFilter , FileFilterUtils . notFileFilter ( DirectoryFileFilter . INSTANCE ) ) ; } private static IOFileFilter setUpEffectiveDirFilter ( final IOFileFilter dirFilter ) { return dirFilter == null ? FalseFileFilter . INSTANCE : FileFilterUtils . and ( dirFilter , MST[rv.CRCR1Mutator]MSP[N] DirectoryFileFilter . INSTANCE ) ; }
} } return size ; } private static BigInteger sizeOfBig0 ( final File fileOrDir ) { if ( fileOrDir . isDirectory () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return sizeOfDirectoryBig0 ( fileOrDir ) ; } return BigInteger . valueOf ( fileOrDir . length () ) ; }
throw new NullPointerException ( lr_38 ) ; } if ( src . isFile () ) { copyFileToDirectory ( src , destDir ) ; } else if ( src . isDirectory () ) { copyDirectoryToDirectory ( src , destDir ) ; MST[VoidMethodCallMutator]MSP[S] } else {
if ( url == null || ! lr_24 . equalsIgnoreCase ( url . getProtocol () ) ) { return null ; } String filename = url . getFile () . replace ( '/' , File . separatorChar ) ; filename = decodeUrl ( filename ) ; MST[NonVoidMethodCallMutator]MSP[N]
return new FileInputStream ( file ) ; MST[NullReturnValsMutator]MSP[N] } public static FileOutputStream openOutputStream ( final File file ) throws IOException { return openOutputStream ( file , false ) ; } public static FileOutputStream openOutputStream ( final File file , final boolean append ) throws IOException {
return new FileOutputStream ( file , append ) ; } public static String byteCountToDisplaySize ( final BigInteger size ) { String displaySize ; if ( size . divide ( ONE_EB_BI ) . compareTo ( BigInteger . ZERO ) > 0 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N]
return new File ( filename ) ; } static String decodeUrl ( final String url ) { String decoded = url ; if ( url != null && url . indexOf ( '%' ) >= 0 ) { MST[rv.CRCR4Mutator]MSP[N] final int n = url . length () ;
final boolean file1Exists = file1 . exists () ; if ( file1Exists != file2 . exists () ) { return false ; } if ( ! file1Exists ) { return true ; MST[InlineConstantMutator]MSP[S] } if ( file1 . isDirectory () || file2 . isDirectory () ) {
throw new IllegalArgumentException ( lr_58 ) ; } if ( ! file . exists () ) { return false ; } return file . lastModified () < timeMillis ; MST[rv.CRCR4Mutator]MSP[N] } public static long checksumCRC32 ( final File file ) throws IOException { final CRC32 crc = new CRC32 () ;
if ( files == null ) { return BigInteger . ZERO ; } BigInteger size = BigInteger . ZERO ; for ( final File file : files ) { if ( ! isSymlink ( file ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] size = size . add ( sizeOfBig0 ( file ) ) ;
if ( destDir == null ) { throw new NullPointerException ( lr_26 ) ; } if ( destDir . exists () && destDir . isDirectory () == false ) { MST[rv.ROR5Mutator]MSP[N] throw new IllegalArgumentException ( lr_27 + destDir + lr_28 ) ; }
public static void write ( final File file , final CharSequence data , final Charset encoding , final boolean append ) throws IOException { final String str = data == null ? null : data . toString () ; writeStringToFile ( file , str , encoding , append ) ; MST[rv.UOI2Mutator]MSP[N]
if ( ! srcDir . isDirectory () ) { throw new IOException ( lr_29 + srcDir + lr_39 ) ; } if ( srcDir . getCanonicalPath () . equals ( destDir . getCanonicalPath () ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S]
if ( null != exception ) { throw exception ; } } public static void forceMkdir ( final File directory ) throws IOException { if ( directory . exists () ) { if ( ! directory . isDirectory () ) { final String message = MST[ConstructorCallMutator]MSP[S] lr_50 + directory + lr_51
return new FileOutputStream ( file , append ) ; } public static String byteCountToDisplaySize ( final BigInteger size ) { String displaySize ; if ( size . divide ( ONE_EB_BI ) . compareTo ( BigInteger . ZERO ) > 0 ) { MST[rv.ROR4Mutator]MSP[N]
throw new IOException ( lr_27 + destDir + lr_32 ) ; } } if ( destDir . canWrite () == false ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] throw new IOException ( lr_27 + destDir + lr_9 ) ; } for ( final File srcFile : srcFiles ) {
