return Arrays . equals ( this . magicNumbers , fileBytes ) ; } } catch ( final IOException ioe ) { } } return false ; } @Override public String toString () { final StringBuilder builder = new StringBuilder ( super . toString () ) ; MST[NonVoidMethodCallMutator]MSP[N]
@Override public boolean accept ( final File file ) { if ( file != null && file . isFile () && file . canRead () ) { MST[rv.ROR2Mutator]MSP[S] try { try ( RandomAccessFile randomAccessFile = new RandomAccessFile ( file , lr_1 ) ) {
builder . append ( lr_2 ) ; builder . append ( new String ( magicNumbers , Charset . defaultCharset () ) ) ; builder . append ( lr_3 ) ; MST[experimental.NakedReceiverMutator]MSP[N] builder . append ( this . byteOffset ) ; builder . append ( lr_4 ) ;
@Override public boolean accept ( final File file ) { if ( file != null && file . isFile () && file . canRead () ) { MST[rv.ROR4Mutator]MSP[N] try { try ( RandomAccessFile randomAccessFile = new RandomAccessFile ( file , lr_1 ) ) {
final byte [] fileBytes = new byte [ this . magicNumbers . length ] ; randomAccessFile . seek ( byteOffset ) ; final int read = randomAccessFile . read ( fileBytes ) ; if ( read != magicNumbers . length ) { MST[rv.ROR1Mutator]MSP[N] return false ; }
final byte [] fileBytes = new byte [ this . magicNumbers . length ] ; randomAccessFile . seek ( byteOffset ) ; final int read = randomAccessFile . read ( fileBytes ) ; if ( read != magicNumbers . length ) { MST[rv.ROR3Mutator]MSP[N] return false ; }
final byte [] fileBytes = new byte [ this . magicNumbers . length ] ; randomAccessFile . seek ( byteOffset ) ; final int read = randomAccessFile . read ( fileBytes ) ; if ( read != magicNumbers . length ) { MST[rv.ROR5Mutator]MSP[N] return false ; }
final byte [] fileBytes = new byte [ this . magicNumbers . length ] ; randomAccessFile . seek ( byteOffset ) ; final int read = randomAccessFile . read ( fileBytes ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( read != magicNumbers . length ) { return false ; }
final byte [] fileBytes = new byte [ this . magicNumbers . length ] ; randomAccessFile . seek ( byteOffset ) ; final int read = randomAccessFile . read ( fileBytes ) ; if ( read != magicNumbers . length ) { MST[rv.UOI1Mutator]MSP[N] return false ; }
final byte [] fileBytes = new byte [ this . magicNumbers . length ] ; randomAccessFile . seek ( byteOffset ) ; final int read = randomAccessFile . read ( fileBytes ) ; if ( read != magicNumbers . length ) { return false ; MST[rv.CRCR3Mutator]MSP[N] }
final byte [] fileBytes = new byte [ this . magicNumbers . length ] ; randomAccessFile . seek ( byteOffset ) ; final int read = randomAccessFile . read ( fileBytes ) ; if ( read != magicNumbers . length ) { return false ; MST[rv.CRCR1Mutator]MSP[N] }
final byte [] fileBytes = new byte [ this . magicNumbers . length ] ; randomAccessFile . seek ( byteOffset ) ; final int read = randomAccessFile . read ( fileBytes ) ; if ( read != magicNumbers . length ) { return false ; MST[rv.CRCR5Mutator]MSP[N] }
builder . append ( lr_2 ) ; builder . append ( new String ( magicNumbers , Charset . defaultCharset () ) ) ; builder . append ( lr_3 ) ; builder . append ( this . byteOffset ) ; MST[experimental.NakedReceiverMutator]MSP[N] builder . append ( lr_4 ) ;
final byte [] fileBytes = new byte [ this . magicNumbers . length ] ; randomAccessFile . seek ( byteOffset ) ; final int read = randomAccessFile . read ( fileBytes ) ; if ( read != magicNumbers . length ) { return false ; MST[BooleanFalseReturnValsMutator]MSP[N] }
@Override public boolean accept ( final File file ) { if ( file != null && file . isFile () && file . canRead () ) { try { try ( RandomAccessFile randomAccessFile = new RandomAccessFile ( file , lr_1 ) ) { MST[ConstructorCallMutator]MSP[N]
final byte [] fileBytes = new byte [ this . magicNumbers . length ] ; randomAccessFile . seek ( byteOffset ) ; final int read = randomAccessFile . read ( fileBytes ) ; if ( read != magicNumbers . length ) { return false ; MST[rv.ABSMutator]MSP[N] }
return builder . toString () ; MST[ReturnValsMutator]MSP[N] }
final byte [] fileBytes = new byte [ this . magicNumbers . length ] ; randomAccessFile . seek ( byteOffset ) ; final int read = randomAccessFile . read ( fileBytes ) ; if ( read != magicNumbers . length ) { MST[rv.UOI3Mutator]MSP[N] return false ; }
builder . append ( lr_2 ) ; builder . append ( new String ( magicNumbers , Charset . defaultCharset () ) ) ; builder . append ( lr_3 ) ; builder . append ( this . byteOffset ) ; MST[rv.UOI4Mutator]MSP[N] builder . append ( lr_4 ) ;
return Arrays . equals ( this . magicNumbers , fileBytes ) ; MST[rv.UOI2Mutator]MSP[N] } } catch ( final IOException ioe ) { } } return false ; } @Override public String toString () { final StringBuilder builder = new StringBuilder ( super . toString () ) ;
return Arrays . equals ( this . magicNumbers , fileBytes ) ; } } catch ( final IOException ioe ) { } } return false ; MST[rv.CRCR6Mutator]MSP[S] } @Override public String toString () { final StringBuilder builder = new StringBuilder ( super . toString () ) ;
@Override public boolean accept ( final File file ) { if ( file != null && file . isFile () && file . canRead () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] try { try ( RandomAccessFile randomAccessFile = new RandomAccessFile ( file , lr_1 ) ) {
@Override public boolean accept ( final File file ) { if ( file != null && file . isFile () && file . canRead () ) { MST[rv.ROR3Mutator]MSP[N] try { try ( RandomAccessFile randomAccessFile = new RandomAccessFile ( file , lr_1 ) ) {
builder . append ( lr_2 ) ; MST[experimental.NakedReceiverMutator]MSP[N] builder . append ( new String ( magicNumbers , Charset . defaultCharset () ) ) ; builder . append ( lr_3 ) ; builder . append ( this . byteOffset ) ; builder . append ( lr_4 ) ;
builder . append ( lr_2 ) ; builder . append ( new String ( magicNumbers , Charset . defaultCharset () ) ) ; builder . append ( lr_3 ) ; MST[NonVoidMethodCallMutator]MSP[N] builder . append ( this . byteOffset ) ; builder . append ( lr_4 ) ;
@Override public boolean accept ( final File file ) { if ( file != null && file . isFile () && file . canRead () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] try { try ( RandomAccessFile randomAccessFile = new RandomAccessFile ( file , lr_1 ) ) {
final byte [] fileBytes = new byte [ this . magicNumbers . length ] ; randomAccessFile . seek ( byteOffset ) ; final int read = randomAccessFile . read ( fileBytes ) ; if ( read != magicNumbers . length ) { MST[NegateConditionalsMutator]MSP[N] return false ; }
builder . append ( lr_2 ) ; builder . append ( new String ( magicNumbers , Charset . defaultCharset () ) ) ; MST[NonVoidMethodCallMutator]MSP[N] builder . append ( lr_3 ) ; builder . append ( this . byteOffset ) ; builder . append ( lr_4 ) ;
builder . append ( lr_2 ) ; builder . append ( new String ( magicNumbers , Charset . defaultCharset () ) ) ; MST[ConstructorCallMutator]MSP[N] builder . append ( lr_3 ) ; builder . append ( this . byteOffset ) ; builder . append ( lr_4 ) ;
@Override public boolean accept ( final File file ) { if ( file != null && file . isFile () && file . canRead () ) { MST[NonVoidMethodCallMutator]MSP[N] try { try ( RandomAccessFile randomAccessFile = new RandomAccessFile ( file , lr_1 ) ) {
@Override public boolean accept ( final File file ) { if ( file != null && file . isFile () && file . canRead () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] try { try ( RandomAccessFile randomAccessFile = new RandomAccessFile ( file , lr_1 ) ) {
final byte [] fileBytes = new byte [ this . magicNumbers . length ] ; randomAccessFile . seek ( byteOffset ) ; final int read = randomAccessFile . read ( fileBytes ) ; if ( read != magicNumbers . length ) { return false ; MST[rv.UOI1Mutator]MSP[N] }
builder . append ( lr_2 ) ; builder . append ( new String ( magicNumbers , Charset . defaultCharset () ) ) ; MST[experimental.NakedReceiverMutator]MSP[N] builder . append ( lr_3 ) ; builder . append ( this . byteOffset ) ; builder . append ( lr_4 ) ;
return Arrays . equals ( this . magicNumbers , fileBytes ) ; } } catch ( final IOException ioe ) { } } return false ; } @Override public String toString () { final StringBuilder builder = new StringBuilder ( super . toString () ) ; MST[ConstructorCallMutator]MSP[N]
@Override public boolean accept ( final File file ) { if ( file != null && file . isFile () && file . canRead () ) { MST[NegateConditionalsMutator]MSP[N] try { try ( RandomAccessFile randomAccessFile = new RandomAccessFile ( file , lr_1 ) ) {
@Override public boolean accept ( final File file ) { if ( file != null && file . isFile () && file . canRead () ) { MST[rv.ROR5Mutator]MSP[N] try { try ( RandomAccessFile randomAccessFile = new RandomAccessFile ( file , lr_1 ) ) {
return Arrays . equals ( this . magicNumbers , fileBytes ) ; } } catch ( final IOException ioe ) { } } return false ; MST[rv.CRCR1Mutator]MSP[S] } @Override public String toString () { final StringBuilder builder = new StringBuilder ( super . toString () ) ;
builder . append ( lr_2 ) ; builder . append ( new String ( magicNumbers , Charset . defaultCharset () ) ) ; builder . append ( lr_3 ) ; builder . append ( this . byteOffset ) ; MST[NonVoidMethodCallMutator]MSP[N] builder . append ( lr_4 ) ;
return Arrays . equals ( this . magicNumbers , fileBytes ) ; MST[rv.ABSMutator]MSP[N] } } catch ( final IOException ioe ) { } } return false ; } @Override public String toString () { final StringBuilder builder = new StringBuilder ( super . toString () ) ;
@Override public boolean accept ( final File file ) { if ( file != null && file . isFile () && file . canRead () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] try { try ( RandomAccessFile randomAccessFile = new RandomAccessFile ( file , lr_1 ) ) {
final byte [] fileBytes = new byte [ this . magicNumbers . length ] ; randomAccessFile . seek ( byteOffset ) ; final int read = randomAccessFile . read ( fileBytes ) ; if ( read != magicNumbers . length ) { return false ; MST[InlineConstantMutator]MSP[N] }
final byte [] fileBytes = new byte [ this . magicNumbers . length ] ; randomAccessFile . seek ( byteOffset ) ; final int read = randomAccessFile . read ( fileBytes ) ; if ( read != magicNumbers . length ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return false ; }
return Arrays . equals ( this . magicNumbers , fileBytes ) ; MST[ReturnValsMutator]MSP[N] } } catch ( final IOException ioe ) { } } return false ; } @Override public String toString () { final StringBuilder builder = new StringBuilder ( super . toString () ) ;
builder . append ( lr_2 ) ; MST[NonVoidMethodCallMutator]MSP[N] builder . append ( new String ( magicNumbers , Charset . defaultCharset () ) ) ; builder . append ( lr_3 ) ; builder . append ( this . byteOffset ) ; builder . append ( lr_4 ) ;
final byte [] fileBytes = new byte [ this . magicNumbers . length ] ; randomAccessFile . seek ( byteOffset ) ; final int read = randomAccessFile . read ( fileBytes ) ; if ( read != magicNumbers . length ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return false ; }
return Arrays . equals ( this . magicNumbers , fileBytes ) ; MST[rv.UOI4Mutator]MSP[N] } } catch ( final IOException ioe ) { } } return false ; } @Override public String toString () { final StringBuilder builder = new StringBuilder ( super . toString () ) ;
builder . append ( lr_2 ) ; builder . append ( new String ( magicNumbers , Charset . defaultCharset () ) ) ; builder . append ( lr_3 ) ; builder . append ( this . byteOffset ) ; MST[rv.UOI2Mutator]MSP[S] builder . append ( lr_4 ) ;
@Override public boolean accept ( final File file ) { if ( file != null && file . isFile () && file . canRead () ) { MST[rv.ROR1Mutator]MSP[N] try { try ( RandomAccessFile randomAccessFile = new RandomAccessFile ( file , lr_1 ) ) {
return Arrays . equals ( this . magicNumbers , fileBytes ) ; MST[BooleanTrueReturnValsMutator]MSP[S] } } catch ( final IOException ioe ) { } } return false ; } @Override public String toString () { final StringBuilder builder = new StringBuilder ( super . toString () ) ;
return builder . toString () ; MST[EmptyObjectReturnValsMutator]MSP[N] }
final byte [] fileBytes = new byte [ this . magicNumbers . length ] ; randomAccessFile . seek ( byteOffset ) ; final int read = randomAccessFile . read ( fileBytes ) ; if ( read != magicNumbers . length ) { return false ; MST[rv.CRCR6Mutator]MSP[N] }
final byte [] fileBytes = new byte [ this . magicNumbers . length ] ; randomAccessFile . seek ( byteOffset ) ; final int read = randomAccessFile . read ( fileBytes ) ; if ( read != magicNumbers . length ) { return false ; MST[rv.UOI3Mutator]MSP[N] }
final byte [] fileBytes = new byte [ this . magicNumbers . length ] ; randomAccessFile . seek ( byteOffset ) ; MST[VoidMethodCallMutator]MSP[S] final int read = randomAccessFile . read ( fileBytes ) ; if ( read != magicNumbers . length ) { return false ; }
final byte [] fileBytes = new byte [ this . magicNumbers . length ] ; randomAccessFile . seek ( byteOffset ) ; MST[rv.UOI2Mutator]MSP[N] final int read = randomAccessFile . read ( fileBytes ) ; if ( read != magicNumbers . length ) { return false ; }
@Override public boolean accept ( final File file ) { if ( file != null && file . isFile () && file . canRead () ) { MST[rv.ROR1Mutator]MSP[S] try { try ( RandomAccessFile randomAccessFile = new RandomAccessFile ( file , lr_1 ) ) {
@Override public boolean accept ( final File file ) { if ( file != null && file . isFile () && file . canRead () ) { MST[rv.ROR5Mutator]MSP[N] try { try ( RandomAccessFile randomAccessFile = new RandomAccessFile ( file , lr_1 ) ) {
@Override public boolean accept ( final File file ) { if ( file != null && file . isFile () && file . canRead () ) { MST[rv.ROR3Mutator]MSP[N] try { try ( RandomAccessFile randomAccessFile = new RandomAccessFile ( file , lr_1 ) ) {
builder . append ( lr_2 ) ; builder . append ( new String ( magicNumbers , Charset . defaultCharset () ) ) ; builder . append ( lr_3 ) ; builder . append ( this . byteOffset ) ; builder . append ( lr_4 ) ; MST[NonVoidMethodCallMutator]MSP[N]
return Arrays . equals ( this . magicNumbers , fileBytes ) ; MST[rv.UOI1Mutator]MSP[N] } } catch ( final IOException ioe ) { } } return false ; } @Override public String toString () { final StringBuilder builder = new StringBuilder ( super . toString () ) ;
final byte [] fileBytes = new byte [ this . magicNumbers . length ] ; randomAccessFile . seek ( byteOffset ) ; MST[rv.ABSMutator]MSP[S] final int read = randomAccessFile . read ( fileBytes ) ; if ( read != magicNumbers . length ) { return false ; }
return Arrays . equals ( this . magicNumbers , fileBytes ) ; MST[rv.UOI3Mutator]MSP[N] } } catch ( final IOException ioe ) { } } return false ; } @Override public String toString () { final StringBuilder builder = new StringBuilder ( super . toString () ) ;
builder . append ( lr_2 ) ; builder . append ( new String ( magicNumbers , Charset . defaultCharset () ) ) ; builder . append ( lr_3 ) ; builder . append ( this . byteOffset ) ; MST[rv.UOI3Mutator]MSP[N] builder . append ( lr_4 ) ;
@Override public boolean accept ( final File file ) { if ( file != null && file . isFile () && file . canRead () ) { MST[rv.ROR4Mutator]MSP[N] try { try ( RandomAccessFile randomAccessFile = new RandomAccessFile ( file , lr_1 ) ) {
return Arrays . equals ( this . magicNumbers , fileBytes ) ; } } catch ( final IOException ioe ) { } } return false ; MST[rv.CRCR5Mutator]MSP[S] } @Override public String toString () { final StringBuilder builder = new StringBuilder ( super . toString () ) ;
@Override public boolean accept ( final File file ) { if ( file != null && file . isFile () && file . canRead () ) { MST[NegateConditionalsMutator]MSP[N] try { try ( RandomAccessFile randomAccessFile = new RandomAccessFile ( file , lr_1 ) ) {
final byte [] fileBytes = new byte [ this . magicNumbers . length ] ; randomAccessFile . seek ( byteOffset ) ; final int read = randomAccessFile . read ( fileBytes ) ; if ( read != magicNumbers . length ) { MST[rv.ROR4Mutator]MSP[N] return false ; }
return Arrays . equals ( this . magicNumbers , fileBytes ) ; } } catch ( final IOException ioe ) { } } return false ; MST[BooleanTrueReturnValsMutator]MSP[S] } @Override public String toString () { final StringBuilder builder = new StringBuilder ( super . toString () ) ;
final byte [] fileBytes = new byte [ this . magicNumbers . length ] ; randomAccessFile . seek ( byteOffset ) ; final int read = randomAccessFile . read ( fileBytes ) ; if ( read != magicNumbers . length ) { MST[rv.UOI2Mutator]MSP[N] return false ; }
final byte [] fileBytes = new byte [ this . magicNumbers . length ] ; randomAccessFile . seek ( byteOffset ) ; final int read = randomAccessFile . read ( fileBytes ) ; if ( read != magicNumbers . length ) { return false ; MST[BooleanTrueReturnValsMutator]MSP[N] }
return Arrays . equals ( this . magicNumbers , fileBytes ) ; MST[NonVoidMethodCallMutator]MSP[N] } } catch ( final IOException ioe ) { } } return false ; } @Override public String toString () { final StringBuilder builder = new StringBuilder ( super . toString () ) ;
final byte [] fileBytes = new byte [ this . magicNumbers . length ] ; randomAccessFile . seek ( byteOffset ) ; MST[rv.UOI4Mutator]MSP[N] final int read = randomAccessFile . read ( fileBytes ) ; if ( read != magicNumbers . length ) { return false ; }
final byte [] fileBytes = new byte [ this . magicNumbers . length ] ; randomAccessFile . seek ( byteOffset ) ; final int read = randomAccessFile . read ( fileBytes ) ; if ( read != magicNumbers . length ) { return false ; MST[rv.UOI2Mutator]MSP[N] }
final byte [] fileBytes = new byte [ this . magicNumbers . length ] ; randomAccessFile . seek ( byteOffset ) ; final int read = randomAccessFile . read ( fileBytes ) ; if ( read != magicNumbers . length ) { return false ; MST[rv.UOI4Mutator]MSP[N] }
final byte [] fileBytes = new byte [ this . magicNumbers . length ] ; randomAccessFile . seek ( byteOffset ) ; final int read = randomAccessFile . read ( fileBytes ) ; if ( read != magicNumbers . length ) { MST[rv.ABSMutator]MSP[N] return false ; }
final byte [] fileBytes = new byte [ this . magicNumbers . length ] ; randomAccessFile . seek ( byteOffset ) ; MST[rv.UOI1Mutator]MSP[N] final int read = randomAccessFile . read ( fileBytes ) ; if ( read != magicNumbers . length ) { return false ; }
final byte [] fileBytes = new byte [ this . magicNumbers . length ] ; randomAccessFile . seek ( byteOffset ) ; MST[rv.UOI3Mutator]MSP[N] final int read = randomAccessFile . read ( fileBytes ) ; if ( read != magicNumbers . length ) { return false ; }
builder . append ( lr_2 ) ; builder . append ( new String ( magicNumbers , Charset . defaultCharset () ) ) ; builder . append ( lr_3 ) ; builder . append ( this . byteOffset ) ; builder . append ( lr_4 ) ; MST[experimental.NakedReceiverMutator]MSP[N]
final byte [] fileBytes = new byte [ this . magicNumbers . length ] ; randomAccessFile . seek ( byteOffset ) ; final int read = randomAccessFile . read ( fileBytes ) ; if ( read != magicNumbers . length ) { MST[rv.UOI4Mutator]MSP[N] return false ; }
@Override public boolean accept ( final File file ) { if ( file != null && file . isFile () && file . canRead () ) { MST[NonVoidMethodCallMutator]MSP[N] try { try ( RandomAccessFile randomAccessFile = new RandomAccessFile ( file , lr_1 ) ) {
builder . append ( lr_2 ) ; builder . append ( new String ( magicNumbers , Charset . defaultCharset () ) ) ; builder . append ( lr_3 ) ; builder . append ( this . byteOffset ) ; MST[rv.UOI1Mutator]MSP[S] builder . append ( lr_4 ) ;
final byte [] fileBytes = new byte [ this . magicNumbers . length ] ; randomAccessFile . seek ( byteOffset ) ; final int read = randomAccessFile . read ( fileBytes ) ; if ( read != magicNumbers . length ) { return false ; MST[ReturnValsMutator]MSP[N] }
@Override public boolean accept ( final File file ) { if ( file != null && file . isFile () && file . canRead () ) { MST[rv.ROR5Mutator]MSP[N] try { try ( RandomAccessFile randomAccessFile = new RandomAccessFile ( file , lr_1 ) ) {
@Override public boolean accept ( final File file ) { if ( file != null && file . isFile () && file . canRead () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] try { try ( RandomAccessFile randomAccessFile = new RandomAccessFile ( file , lr_1 ) ) {
@Override public boolean accept ( final File file ) { if ( file != null && file . isFile () && file . canRead () ) { MST[rv.ROR2Mutator]MSP[N] try { try ( RandomAccessFile randomAccessFile = new RandomAccessFile ( file , lr_1 ) ) {
return Arrays . equals ( this . magicNumbers , fileBytes ) ; } } catch ( final IOException ioe ) { } } return false ; MST[rv.CRCR3Mutator]MSP[S] } @Override public String toString () { final StringBuilder builder = new StringBuilder ( super . toString () ) ;
return builder . toString () ; MST[NonVoidMethodCallMutator]MSP[N] }
@Override public boolean accept ( final File file ) { if ( file != null && file . isFile () && file . canRead () ) { MST[NegateConditionalsMutator]MSP[N] try { try ( RandomAccessFile randomAccessFile = new RandomAccessFile ( file , lr_1 ) ) {
return Arrays . equals ( this . magicNumbers , fileBytes ) ; } } catch ( final IOException ioe ) { } } return false ; MST[InlineConstantMutator]MSP[S] } @Override public String toString () { final StringBuilder builder = new StringBuilder ( super . toString () ) ;
return Arrays . equals ( this . magicNumbers , fileBytes ) ; MST[BooleanFalseReturnValsMutator]MSP[N] } } catch ( final IOException ioe ) { } } return false ; } @Override public String toString () { final StringBuilder builder = new StringBuilder ( super . toString () ) ;
return Arrays . equals ( this . magicNumbers , fileBytes ) ; } } catch ( final IOException ioe ) { } } return false ; MST[ReturnValsMutator]MSP[S] } @Override public String toString () { final StringBuilder builder = new StringBuilder ( super . toString () ) ;
@Override public boolean accept ( final File file ) { if ( file != null && file . isFile () && file . canRead () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] try { try ( RandomAccessFile randomAccessFile = new RandomAccessFile ( file , lr_1 ) ) {
builder . append ( lr_2 ) ; builder . append ( new String ( magicNumbers , Charset . defaultCharset () ) ) ; builder . append ( lr_3 ) ; builder . append ( this . byteOffset ) ; MST[rv.ABSMutator]MSP[S] builder . append ( lr_4 ) ;
final byte [] fileBytes = new byte [ this . magicNumbers . length ] ; randomAccessFile . seek ( byteOffset ) ; final int read = randomAccessFile . read ( fileBytes ) ; if ( read != magicNumbers . length ) { MST[rv.ROR2Mutator]MSP[N] return false ; }
builder . append ( lr_2 ) ; builder . append ( new String ( magicNumbers , Charset . defaultCharset () ) ) ; MST[NonVoidMethodCallMutator]MSP[N] builder . append ( lr_3 ) ; builder . append ( this . byteOffset ) ; builder . append ( lr_4 ) ;
