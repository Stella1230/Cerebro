if ( posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2 ) { return NOT_FOUND ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; MST[NegateConditionalsMutator]MSP[N] posWin = posWin == NOT_FOUND ? posUnix : posWin ;
if ( array [ size - 1 ] != separator ) { MST[NegateConditionalsMutator]MSP[N] array [ size ++ ] = separator ; lastIsDirectory = false ; } for ( int i = prefix + 1 ; i < size ; i ++ ) {
public static String getFullPathNoEndSeparator ( final String fileName ) { return doGetFullPath ( fileName , false ) ; MST[rv.CRCR3Mutator]MSP[N] } private static String doGetFullPath ( final String fileName , final boolean includeSeparator ) { if ( fileName == null ) { return null ; }
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND ) { return len + 1 ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; MST[rv.CRCR5Mutator]MSP[N] posWin = posWin == NOT_FOUND ? posUnix : posWin ; return Math . min ( posUnix , posWin ) + 1 ; }
} else if ( isSeparator ( ch0 ) && isSeparator ( ch1 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] int posUnix = fileName . indexOf ( UNIX_SEPARATOR , 2 ) ; int posWin = fileName . indexOf ( WINDOWS_SEPARATOR , 2 ) ;
final int lastWindowsPos = fileName . lastIndexOf ( WINDOWS_SEPARATOR ) ; return Math . max ( lastUnixPos , lastWindowsPos ) ; MST[NonVoidMethodCallMutator]MSP[N] } public static int indexOfExtension ( final String fileName ) throws IllegalArgumentException { if ( fileName == null ) { return NOT_FOUND ; }
final char [] array = new char [ size + 2 ] ; MST[InlineConstantMutator]MSP[S] fileName . getChars ( 0 , fileName . length () , array , 0 ) ; final char otherSeparator = separator == SYSTEM_SEPARATOR ? OTHER_SEPARATOR : SYSTEM_SEPARATOR ;
if ( validOctets > IPV6_MAX_HEX_GROUPS || ( validOctets < IPV6_MAX_HEX_GROUPS && ! containsCompressedZeroes ) ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] return false ; } return true ; } private static boolean isRFC3986HostName ( final String name ) { final String [] parts = name . split ( lr_13 , - 1 ) ;
if ( len == 0 ) { return 0 ; } char ch0 = fileName . charAt ( 0 ) ; if ( ch0 == ':' ) { MST[rv.ROR4Mutator]MSP[N] return NOT_FOUND ; } if ( len == 1 ) { if ( ch0 == '~' ) { return 2 ; }
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND ) { return len + 1 ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; MST[rv.UOI1Mutator]MSP[N] posWin = posWin == NOT_FOUND ? posUnix : posWin ; return Math . min ( posUnix , posWin ) + 1 ; }
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2 ) { MST[rv.ROR3Mutator]MSP[N] return NOT_FOUND ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ;
for ( int i = prefix + 1 ; i < size ; i ++ ) { MST[rv.UOI1Mutator]MSP[N] if ( array [ i ] == separator && array [ i - 1 ] == '.' &&
System . arraycopy ( array , i + 1 , array , prefix , size - i ) ; MST[rv.AOR1Mutator]MSP[N] size -= i + 1 - prefix ; i = prefix + 1 ; } } if ( size <= 0 ) { return EMPTY_STRING ; }
final char [] array = new char [ size + 2 ] ; fileName . getChars ( 0 , fileName . length () , array , 0 ) ; final char otherSeparator = separator == SYSTEM_SEPARATOR ? OTHER_SEPARATOR : SYSTEM_SEPARATOR ; MST[rv.ROR4Mutator]MSP[N]
return new String ( array , 0 , size - 1 ) ; } public static String concat ( final String basePath , final String fullFileNameToAdd ) { final int prefix = getPrefixLength ( fullFileNameToAdd ) ; if ( prefix < 0 ) { MST[rv.UOI1Mutator]MSP[N] return null ; }
final int prefix = getPrefixLength ( fileName ) ; if ( prefix < 0 ) { return null ; } if ( prefix >= fileName . length () ) { MST[rv.ROR5Mutator]MSP[N] if ( includeSeparator ) { return getPrefix ( fileName ) ; } return fileName ; }
if ( array [ size - 1 ] != separator ) { MST[rv.CRCR2Mutator]MSP[N] array [ size ++ ] = separator ; lastIsDirectory = false ; } for ( int i = prefix + 1 ; i < size ; i ++ ) {
return false ; } static String [] splitOnTokens ( final String text ) { if ( text . indexOf ( '?' ) == NOT_FOUND && text . indexOf ( '*' ) == NOT_FOUND ) { MST[NegateConditionalsMutator]MSP[N] return new String [] { text } ; }
fileName2 = normalize ( fileName2 ) ; if ( fileName1 == null || fileName2 == null ) { MST[rv.ROR5Mutator]MSP[N] throw new NullPointerException ( lr_5 ) ; } } if ( caseSensitivity == null ) { caseSensitivity = IOCase . SENSITIVE ; }
return null ; } return isSystemWindows () ? separatorsToWindows ( path ) : separatorsToUnix ( path ) ; MST[EmptyObjectReturnValsMutator]MSP[N] } public static int getPrefixLength ( final String fileName ) { if ( fileName == null ) { return NOT_FOUND ; } final int len = fileName . length () ;
for ( int i = prefix + 1 ; i < size ; i ++ ) { if ( array [ i ] == separator && array [ i - 1 ] == '.' && MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
|| ( inet6Address . endsWith ( lr_10 ) && ! inet6Address . endsWith ( lr_9 ) ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return false ; } String [] octets = inet6Address . split ( lr_10 ) ; if ( containsCompressedZeroes ) {
if ( array [ j ] == separator ) { System . arraycopy ( array , i + 1 , array , j + 1 , size - i ) ; MST[rv.UOI1Mutator]MSP[N] size -= i - j ; i = j + 1 ; continue outer; } }
if ( i == prefix + 2 ) { return null ; } if ( i == size - 1 ) { lastIsDirectory = true ; } int j ; for ( j = i - 4 ; j >= prefix ; j -- ) { MST[MathMutator]MSP[N]
for ( int i = 1 ; i <= 4 ; i ++ ) { final String ipSegment = m . group ( i ) ; final int iIpSegment = Integer . parseInt ( ipSegment ) ; if ( iIpSegment > IPV4_MAX_OCTET_VALUE ) { MST[rv.CRCR2Mutator]MSP[S] return false ; }
if ( i == prefix + 2 ) { MST[rv.CRCR6Mutator]MSP[N] return null ; } if ( i == size - 1 ) { lastIsDirectory = true ; } int j ; for ( j = i - 4 ; j >= prefix ; j -- ) {
textIdx = array [ 1 ] ; anyChars = true ; } while ( wcsIdx < wcs . length ) { MST[NegateConditionalsMutator]MSP[N] if ( wcs [ wcsIdx ] . equals ( lr_6 ) ) { textIdx ++ ; if ( textIdx > fileName . length () ) { break; }
int size = fileName . length () ; if ( size == 0 ) { return fileName ; } final int prefix = getPrefixLength ( fileName ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( prefix < 0 ) { return null ; }
if ( array [ i ] == separator && array [ i - 1 ] == separator ) { System . arraycopy ( array , i , array , i - 1 , size - i ) ; MST[VoidMethodCallMutator]MSP[N] size -- ; i -- ; } }
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND ) { return len + 1 ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ; return Math . min ( posUnix , posWin ) + 1 ; MST[rv.UOI2Mutator]MSP[N] }
anyChars = false ; MST[InlineConstantMutator]MSP[S] } else if ( wcs [ wcsIdx ] . equals ( lr_7 ) ) { anyChars = true ; if ( wcsIdx == wcs . length - 1 ) { textIdx = fileName . length () ; } } else { if ( anyChars ) {
if ( ! REG_NAME_PART_PATTERN . matcher ( parts [ i ] ) . matches () ) { return false ; } } return true ; MST[rv.CRCR4Mutator]MSP[N] }
if ( prefix > 0 ) { MST[rv.UOI4Mutator]MSP[S] return normalize ( fullFileNameToAdd ) ; } if ( basePath == null ) { return null ; } final int len = basePath . length () ; if ( len == 0 ) { return normalize ( fullFileNameToAdd ) ; }
System . arraycopy ( array , i + 1 , array , prefix , size - i ) ; size -= i + 1 - prefix ; i = prefix + 1 ; } } if ( size <= 0 ) { MST[rv.ROR1Mutator]MSP[N] return EMPTY_STRING ; }
list . add ( lr_6 ) ; } else if ( prevChar != '*' ) { list . add ( lr_7 ) ; } } else { buffer . append ( ch ) ; MST[NonVoidMethodCallMutator]MSP[N] } prevChar = ch ; } if ( buffer . length () != 0 ) {
for ( int i = prefix + 1 ; i < size ; i ++ ) { if ( array [ i ] == separator && array [ i - 1 ] == '.' && MST[rv.AOD1Mutator]MSP[N]
if ( size <= prefix ) { return new String ( array , 0 , size ) ; } if ( lastIsDirectory && keepSeparator ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return new String ( array , 0 , size ) ; }
int wcsIdx = 0 ; MST[rv.CRCR5Mutator]MSP[N] final Stack < int [] > backtrack = new Stack <> () ; do { if ( backtrack . size () > 0 ) { final int [] array = backtrack . pop () ; wcsIdx = array [ 0 ] ;
System . arraycopy ( array , i + 1 , array , i - 1 , size - i ) ; MST[rv.UOI4Mutator]MSP[N] size -= 2 ; i -- ; } } outer: for ( int i = prefix + 2 ; i < size ; i ++ ) {
if ( path == null || path . indexOf ( UNIX_SEPARATOR ) == NOT_FOUND ) { MST[InlineConstantMutator]MSP[S] return path ; } return path . replace ( UNIX_SEPARATOR , WINDOWS_SEPARATOR ) ; } public static String separatorsToSystem ( final String path ) { if ( path == null ) {
list . add ( lr_6 ) ; } else if ( prevChar != '*' ) { MST[NegateConditionalsMutator]MSP[N] list . add ( lr_7 ) ; } } else { buffer . append ( ch ) ; } prevChar = ch ; } if ( buffer . length () != 0 ) {
textIdx += wcs [ wcsIdx ] . length () ; anyChars = false ; } wcsIdx ++ ; } if ( wcsIdx == wcs . length && textIdx == fileName . length () ) { return true ; } } while ( backtrack . size () > 0 ); MST[rv.ROR5Mutator]MSP[N]
textIdx += wcs [ wcsIdx ] . length () ; MST[rv.AOR1Mutator]MSP[N] anyChars = false ; } wcsIdx ++ ; } if ( wcsIdx == wcs . length && textIdx == fileName . length () ) { return true ; } } while ( backtrack . size () > 0 );
if ( array [ i ] == separator && array [ i - 1 ] == '.' && array [ i - 2 ] == '.' && MST[rv.CRCR5Mutator]MSP[S] ( i == prefix + 2 || array [ i - 3 ] == separator ) ) {
public static String normalizeNoEndSeparator ( final String fileName ) { return doNormalize ( fileName , SYSTEM_SEPARATOR , false ) ; } public static String normalizeNoEndSeparator ( final String fileName , final boolean unixSeparator ) { final char separator = unixSeparator ? UNIX_SEPARATOR : WINDOWS_SEPARATOR ; MST[rv.CRCR2Mutator]MSP[N]
if ( len == 2 || isSeparator ( fileName . charAt ( 2 ) ) == false ) { MST[rv.CRCR3Mutator]MSP[N] return 2 ; } return 3 ; } else if ( ch0 == UNIX_SEPARATOR ) { return 1 ; } return NOT_FOUND ;
if ( containsCompressedZeroes && ( inet6Address . indexOf ( lr_9 ) != inet6Address . lastIndexOf ( lr_9 ) ) ) { return false ; MST[rv.CRCR3Mutator]MSP[S] } if ( ( inet6Address . startsWith ( lr_10 ) && ! inet6Address . startsWith ( lr_9 ) )
static boolean isSystemWindows () { return SYSTEM_SEPARATOR == WINDOWS_SEPARATOR ; } private static boolean isSeparator ( final char ch ) { return ch == UNIX_SEPARATOR || ch == WINDOWS_SEPARATOR ; MST[InlineConstantMutator]MSP[N] } public static String normalize ( final String fileName ) {
if ( ! isIPv4Address ( octet ) ) { return false ; } validOctets += 2 ; continue; } if ( octet . length () > IPV6_MAX_HEX_DIGITS_PER_GROUP ) { MST[rv.CRCR3Mutator]MSP[N] return false ; } int octetInt = 0 ; try {
String fileName1 , String fileName2 , final boolean normalized , IOCase caseSensitivity ) { if ( fileName1 == null || fileName2 == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return fileName1 == null && fileName2 == null ; } if ( normalized ) { fileName1 = normalize ( fileName1 ) ;
if ( validOctets > IPV6_MAX_HEX_GROUPS || ( validOctets < IPV6_MAX_HEX_GROUPS && ! containsCompressedZeroes ) ) { MST[rv.CRCR5Mutator]MSP[N] return false ; } return true ; } private static boolean isRFC3986HostName ( final String name ) { final String [] parts = name . split ( lr_13 , - 1 ) ;
return indexOfExtension ( fileName ) == NOT_FOUND ; MST[rv.CRCR5Mutator]MSP[N] } final String fileExt = getExtension ( fileName ) ; for ( final String extension : extensions ) { if ( fileExt . equals ( extension ) ) { return true ; } } return false ; }
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2 ) { return NOT_FOUND ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; MST[rv.CRCR6Mutator]MSP[N] posWin = posWin == NOT_FOUND ? posUnix : posWin ;
return isSeparator ( ch0 ) ? 1 : 0 ; } } public static int indexOfLastSeparator ( final String fileName ) { if ( fileName == null ) { return NOT_FOUND ; } final int lastUnixPos = fileName . lastIndexOf ( UNIX_SEPARATOR ) ; MST[rv.CRCR1Mutator]MSP[N]
if ( i == prefix + 2 ) { return null ; } if ( i == size - 1 ) { lastIsDirectory = true ; } int j ; for ( j = i - 4 ; j >= prefix ; j -- ) { MST[rv.UOI1Mutator]MSP[N]
for ( int i = 0 ; i < parts . length ; i ++ ) { if ( parts [ i ] . length () == 0 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return i == parts . length - 1 ; }
for ( int i = prefix + 1 ; i < size ; i ++ ) { if ( array [ i ] == separator && array [ i - 1 ] == '.' && MST[rv.ROR4Mutator]MSP[N]
textIdx += wcs [ wcsIdx ] . length () ; anyChars = false ; } wcsIdx ++ ; } if ( wcsIdx == wcs . length && textIdx == fileName . length () ) { MST[rv.UOI3Mutator]MSP[N] return true ; } } while ( backtrack . size () > 0 );
return doNormalize ( fileName , SYSTEM_SEPARATOR , true ) ; MST[rv.CRCR5Mutator]MSP[N] } public static String normalize ( final String fileName , final boolean unixSeparator ) { final char separator = unixSeparator ? UNIX_SEPARATOR : WINDOWS_SEPARATOR ; return doNormalize ( fileName , separator , true ) ; }
if ( array [ size - 1 ] != separator ) { MST[rv.CRCR5Mutator]MSP[N] array [ size ++ ] = separator ; lastIsDirectory = false ; } for ( int i = prefix + 1 ; i < size ; i ++ ) {
static boolean isSystemWindows () { return SYSTEM_SEPARATOR == WINDOWS_SEPARATOR ; MST[rv.CRCR5Mutator]MSP[N] } private static boolean isSeparator ( final char ch ) { return ch == UNIX_SEPARATOR || ch == WINDOWS_SEPARATOR ; } public static String normalize ( final String fileName ) {
if ( i == prefix + 2 ) { MST[rv.AOR3Mutator]MSP[N] return null ; } if ( i == size - 1 ) { lastIsDirectory = true ; } int j ; for ( j = i - 4 ; j >= prefix ; j -- ) {
return doNormalize ( fileName , SYSTEM_SEPARATOR , true ) ; } public static String normalize ( final String fileName , final boolean unixSeparator ) { final char separator = unixSeparator ? UNIX_SEPARATOR : WINDOWS_SEPARATOR ; MST[rv.CRCR4Mutator]MSP[S] return doNormalize ( fileName , separator , true ) ; }
textIdx += wcs [ wcsIdx ] . length () ; MST[rv.UOI1Mutator]MSP[N] anyChars = false ; } wcsIdx ++ ; } if ( wcsIdx == wcs . length && textIdx == fileName . length () ) { return true ; } } while ( backtrack . size () > 0 );
if ( octet . length () == 0 ) { emptyOctets ++ ; if ( emptyOctets > 1 ) { MST[rv.UOI2Mutator]MSP[N] return false ; } } else { emptyOctets = 0 ; if ( index == octets . length - 1 && octet . contains ( lr_12 ) ) {
if ( array [ i ] == separator && array [ i - 1 ] == separator ) { MST[rv.UOI1Mutator]MSP[N] System . arraycopy ( array , i , array , i - 1 , size - i ) ; size -- ; i -- ; } }
public static String getExtension ( final String fileName ) throws IllegalArgumentException { if ( fileName == null ) { return null ; } final int index = indexOfExtension ( fileName ) ; if ( index == NOT_FOUND ) { MST[rv.ROR5Mutator]MSP[N] return EMPTY_STRING ; }
return isSeparator ( ch0 ) ? 1 : 0 ; } if ( ch0 == '~' ) { MST[rv.UOI1Mutator]MSP[N] int posUnix = fileName . indexOf ( UNIX_SEPARATOR , 1 ) ; int posWin = fileName . indexOf ( WINDOWS_SEPARATOR , 1 ) ;
return isSeparator ( ch0 ) ? 1 : 0 ; MST[rv.ROR1Mutator]MSP[N] } if ( ch0 == '~' ) { int posUnix = fileName . indexOf ( UNIX_SEPARATOR , 1 ) ; int posWin = fileName . indexOf ( WINDOWS_SEPARATOR , 1 ) ;
final int pos = Math . min ( posUnix , posWin ) + 1 ; final String hostnamePart = fileName . substring ( 2 , pos - 1 ) ; MST[InlineConstantMutator]MSP[N] return isValidHostName ( hostnamePart ) ? pos : NOT_FOUND ; } else {
list . add ( lr_6 ) ; } else if ( prevChar != '*' ) { list . add ( lr_7 ) ; } } else { buffer . append ( ch ) ; } prevChar = ch ; } if ( buffer . length () != 0 ) { MST[rv.ROR2Mutator]MSP[N]
if ( array [ i ] == separator && array [ i - 1 ] == '.' && array [ i - 2 ] == '.' && MST[rv.ROR2Mutator]MSP[N] ( i == prefix + 2 || array [ i - 3 ] == separator ) ) {
return doNormalize ( fileName , SYSTEM_SEPARATOR , true ) ; } public static String normalize ( final String fileName , final boolean unixSeparator ) { final char separator = unixSeparator ? UNIX_SEPARATOR : WINDOWS_SEPARATOR ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return doNormalize ( fileName , separator , true ) ; }
if ( array [ i ] == separator && array [ i - 1 ] == '.' && array [ i - 2 ] == '.' && MST[rv.CRCR6Mutator]MSP[N] ( i == prefix + 2 || array [ i - 3 ] == separator ) ) {
System . arraycopy ( array , i + 1 , array , i - 1 , size - i ) ; MST[rv.UOI3Mutator]MSP[N] size -= 2 ; i -- ; } } outer: for ( int i = prefix + 2 ; i < size ; i ++ ) {
for ( int i = 0 ; i < array . length ; i ++ ) { if ( array [ i ] == otherSeparator ) { MST[rv.ROR1Mutator]MSP[N] array [ i ] = separator ; } } boolean lastIsDirectory = true ;
String fileName1 , String fileName2 , final boolean normalized , IOCase caseSensitivity ) { if ( fileName1 == null || fileName2 == null ) { MST[rv.ROR5Mutator]MSP[N] return fileName1 == null && fileName2 == null ; } if ( normalized ) { fileName1 = normalize ( fileName1 ) ;
int size = fileName . length () ; if ( size == 0 ) { MST[rv.ROR5Mutator]MSP[N] return fileName ; } final int prefix = getPrefixLength ( fileName ) ; if ( prefix < 0 ) { return null ; }
if ( len == 0 ) { return 0 ; } char ch0 = fileName . charAt ( 0 ) ; if ( ch0 == ':' ) { return NOT_FOUND ; } if ( len == 1 ) { MST[rv.CRCR4Mutator]MSP[N] if ( ch0 == '~' ) { return 2 ; }
final int index = indexOfLastSeparator ( fileName ) ; if ( index < 0 ) { return fileName . substring ( 0 , prefix ) ; } int end = index + ( includeSeparator ? 1 : 0 ) ; MST[MathMutator]MSP[S] if ( end == 0 ) { end ++ ;
final List < String > octetList = new ArrayList <> ( Arrays . asList ( octets ) ) ; if ( inet6Address . endsWith ( lr_9 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] octetList . add ( lr_11 ) ;
if ( i == prefix + 2 ) { return null ; } if ( i == size - 1 ) { MST[rv.UOI1Mutator]MSP[N] lastIsDirectory = true ; } int j ; for ( j = i - 4 ; j >= prefix ; j -- ) {
public static boolean directoryContains ( final String canonicalParent , final String canonicalChild ) throws IOException { if ( canonicalParent == null ) { throw new IllegalArgumentException ( lr_1 ) ; } if ( canonicalChild == null ) { return false ; MST[rv.CRCR6Mutator]MSP[N] }
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2 ) { MST[rv.UOI1Mutator]MSP[N] return NOT_FOUND ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ;
System . arraycopy ( array , i + 1 , array , prefix , size - i ) ; MST[rv.AOD2Mutator]MSP[N] size -= i + 1 - prefix ; i = prefix + 1 ; } } if ( size <= 0 ) { return EMPTY_STRING ; }
private static boolean isIPv4Address ( final String name ) { final Matcher m = IPV4_PATTERN . matcher ( name ) ; if ( ! m . matches () || m . groupCount () != 4 ) { MST[rv.CRCR3Mutator]MSP[S] return false ; }
final char ch = basePath . charAt ( len - 1 ) ; if ( isSeparator ( ch ) ) { return normalize ( basePath + fullFileNameToAdd ) ; } return normalize ( basePath + '/' + fullFileNameToAdd ) ; MST[experimental.NakedReceiverMutator]MSP[N] }
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND ) { return len + 1 ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ; return Math . min ( posUnix , posWin ) + 1 ; MST[InlineConstantMutator]MSP[N] }
return isSeparator ( ch0 ) ? 1 : 0 ; } if ( ch0 == '~' ) { int posUnix = fileName . indexOf ( UNIX_SEPARATOR , 1 ) ; int posWin = fileName . indexOf ( WINDOWS_SEPARATOR , 1 ) ; MST[NonVoidMethodCallMutator]MSP[N]
System . arraycopy ( array , i + 1 , array , i - 1 , size - i ) ; size -= 2 ; i -- ; } } outer: for ( int i = prefix + 2 ; i < size ; i ++ ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N]
if ( octet . length () == 0 ) { emptyOctets ++ ; if ( emptyOctets > 1 ) { return false ; } } else { emptyOctets = 0 ; if ( index == octets . length - 1 && octet . contains ( lr_12 ) ) { MST[rv.UOI1Mutator]MSP[N]
final int index = indexOfLastSeparator ( fileName ) ; final int endIndex = index + separatorAdd ; if ( prefix >= fileName . length () || index < 0 || prefix >= endIndex ) { MST[rv.UOI4Mutator]MSP[S] return EMPTY_STRING ; }
if ( containsCompressedZeroes && ( inet6Address . indexOf ( lr_9 ) != inet6Address . lastIndexOf ( lr_9 ) ) ) { MST[rv.UOI2Mutator]MSP[N] return false ; } if ( ( inet6Address . startsWith ( lr_10 ) && ! inet6Address . startsWith ( lr_9 ) )
public static String normalizeNoEndSeparator ( final String fileName ) { return doNormalize ( fileName , SYSTEM_SEPARATOR , false ) ; } public static String normalizeNoEndSeparator ( final String fileName , final boolean unixSeparator ) { final char separator = unixSeparator ? UNIX_SEPARATOR : WINDOWS_SEPARATOR ; MST[rv.UOI4Mutator]MSP[N]
textIdx = array [ 1 ] ; anyChars = true ; MST[rv.CRCR5Mutator]MSP[N] } while ( wcsIdx < wcs . length ) { if ( wcs [ wcsIdx ] . equals ( lr_6 ) ) { textIdx ++ ; if ( textIdx > fileName . length () ) { break; }
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND ) { return len + 1 ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ; return Math . min ( posUnix , posWin ) + 1 ; MST[rv.CRCR3Mutator]MSP[N] }
if ( prefix > 0 ) { return normalize ( fullFileNameToAdd ) ; } if ( basePath == null ) { return null ; } final int len = basePath . length () ; if ( len == 0 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return normalize ( fullFileNameToAdd ) ; }
if ( array [ size - 1 ] != separator ) { array [ size ++ ] = separator ; MST[rv.ABSMutator]MSP[N] lastIsDirectory = false ; } for ( int i = prefix + 1 ; i < size ; i ++ ) {
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND ) { MST[rv.ABSMutator]MSP[N] return len + 1 ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ; return Math . min ( posUnix , posWin ) + 1 ; }
( i == prefix + 1 || array [ i - 2 ] == separator ) ) { if ( i == size - 1 ) { MST[rv.UOI3Mutator]MSP[N] lastIsDirectory = true ; }
System . arraycopy ( array , i + 1 , array , i - 1 , size - i ) ; size -= 2 ; i -- ; } } outer: for ( int i = prefix + 2 ; i < size ; i ++ ) { MST[rv.CRCR5Mutator]MSP[N]
if ( i == prefix + 2 ) { MST[rv.ABSMutator]MSP[N] return null ; } if ( i == size - 1 ) { lastIsDirectory = true ; } int j ; for ( j = i - 4 ; j >= prefix ; j -- ) {
final int index = indexOfLastSeparator ( fileName ) ; if ( index < 0 ) { return fileName . substring ( 0 , prefix ) ; } int end = index + ( includeSeparator ? 1 : 0 ) ; MST[rv.ROR3Mutator]MSP[N] if ( end == 0 ) { end ++ ;
final char [] array = new char [ size + 2 ] ; fileName . getChars ( 0 , fileName . length () , array , 0 ) ; final char otherSeparator = separator == SYSTEM_SEPARATOR ? OTHER_SEPARATOR : SYSTEM_SEPARATOR ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
if ( IOCase . SYSTEM . checkEquals ( canonicalParent , canonicalChild ) ) { MST[rv.ROR3Mutator]MSP[N] return false ; } return IOCase . SYSTEM . checkStartsWith ( canonicalChild , canonicalParent ) ; } public static String separatorsToUnix ( final String path ) {
( i == prefix + 1 || array [ i - 2 ] == separator ) ) { if ( i == size - 1 ) { MST[rv.ROR5Mutator]MSP[N] lastIsDirectory = true ; }
if ( path == null || path . indexOf ( WINDOWS_SEPARATOR ) == NOT_FOUND ) { MST[InlineConstantMutator]MSP[N] return path ; } return path . replace ( WINDOWS_SEPARATOR , UNIX_SEPARATOR ) ; } public static String separatorsToWindows ( final String path ) {
if ( len == 2 || isSeparator ( fileName . charAt ( 2 ) ) == false ) { return 2 ; } return 3 ; } else if ( ch0 == UNIX_SEPARATOR ) { MST[rv.ROR4Mutator]MSP[N] return 1 ; } return NOT_FOUND ;
} else if ( inet6Address . startsWith ( lr_9 ) && ! octetList . isEmpty () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] octetList . remove ( 0 ) ; } octets = octetList . toArray ( new String [ octetList . size () ] ) ; }
int size = fileName . length () ; if ( size == 0 ) { return fileName ; } final int prefix = getPrefixLength ( fileName ) ; if ( prefix < 0 ) { MST[rv.ROR4Mutator]MSP[N] return null ; }
int size = fileName . length () ; if ( size == 0 ) { return fileName ; } final int prefix = getPrefixLength ( fileName ) ; if ( prefix < 0 ) { MST[rv.UOI3Mutator]MSP[N] return null ; }
if ( index == NOT_FOUND ) { return fileName ; } return fileName . substring ( 0 , index ) ; } public static boolean equals ( final String fileName1 , final String fileName2 ) { return equals ( fileName1 , fileName2 , false , IOCase . SENSITIVE ) ; MST[BooleanFalseReturnValsMutator]MSP[S]
final int pos = Math . min ( posUnix , posWin ) + 1 ; MST[ArgumentPropagationMutator]MSP[N] final String hostnamePart = fileName . substring ( 2 , pos - 1 ) ; return isValidHostName ( hostnamePart ) ? pos : NOT_FOUND ; } else {
if ( size <= prefix ) { return new String ( array , 0 , size ) ; MST[EmptyObjectReturnValsMutator]MSP[N] } if ( lastIsDirectory && keepSeparator ) { return new String ( array , 0 , size ) ; }
final String path = fileName . substring ( prefix , endIndex ) ; MST[rv.ABSMutator]MSP[N] failIfNullBytePresent ( path ) ; return path ; } public static String getFullPath ( final String fileName ) { return doGetFullPath ( fileName , true ) ; }
if ( IOCase . SYSTEM . checkEquals ( canonicalParent , canonicalChild ) ) { MST[NegateConditionalsMutator]MSP[N] return false ; } return IOCase . SYSTEM . checkStartsWith ( canonicalChild , canonicalParent ) ; } public static String separatorsToUnix ( final String path ) {
fileName2 = normalize ( fileName2 ) ; if ( fileName1 == null || fileName2 == null ) { throw new NullPointerException ( lr_5 ) ; } } if ( caseSensitivity == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] caseSensitivity = IOCase . SENSITIVE ; }
octetInt = Integer . parseInt ( octet , BASE_16 ) ; MST[rv.CRCR2Mutator]MSP[N] } catch ( final NumberFormatException e ) { return false ; } if ( octetInt < 0 || octetInt > MAX_UNSIGNED_SHORT ) { return false ; } } validOctets ++ ; }
octetInt = Integer . parseInt ( octet , BASE_16 ) ; } catch ( final NumberFormatException e ) { return false ; MST[BooleanTrueReturnValsMutator]MSP[S] } if ( octetInt < 0 || octetInt > MAX_UNSIGNED_SHORT ) { return false ; } } validOctets ++ ; }
if ( ch == '?' || ch == '*' ) { MST[rv.CRCR2Mutator]MSP[N] if ( buffer . length () != 0 ) { list . add ( buffer . toString () ) ; buffer . setLength ( 0 ) ; } if ( ch == '?' ) {
if ( ch == '?' || ch == '*' ) { if ( buffer . length () != 0 ) { list . add ( buffer . toString () ) ; buffer . setLength ( 0 ) ; } if ( ch == '?' ) { MST[rv.ROR5Mutator]MSP[N]
final int lastWindowsPos = fileName . lastIndexOf ( WINDOWS_SEPARATOR ) ; MST[rv.CRCR3Mutator]MSP[N] return Math . max ( lastUnixPos , lastWindowsPos ) ; } public static int indexOfExtension ( final String fileName ) throws IllegalArgumentException { if ( fileName == null ) { return NOT_FOUND ; }
final int pos = Math . min ( posUnix , posWin ) + 1 ; final String hostnamePart = fileName . substring ( 2 , pos - 1 ) ; return isValidHostName ( hostnamePart ) ? pos : NOT_FOUND ; MST[rv.ROR1Mutator]MSP[N] } else {
list . add ( buffer . toString () ) ; } return list . toArray ( new String [ list . size () ] ) ; } private static boolean isValidHostName ( final String name ) { return isIPv6Address ( name ) || isRFC3986HostName ( name ) ; MST[rv.ROR4Mutator]MSP[N] }
if ( array [ j ] == separator ) { System . arraycopy ( array , i + 1 , array , j + 1 , size - i ) ; MST[rv.CRCR3Mutator]MSP[N] size -= i - j ; i = j + 1 ; continue outer; } }
System . arraycopy ( array , i + 1 , array , i - 1 , size - i ) ; MST[rv.AOD1Mutator]MSP[N] size -= 2 ; i -- ; } } outer: for ( int i = prefix + 2 ; i < size ; i ++ ) {
final int lastWindowsPos = fileName . lastIndexOf ( WINDOWS_SEPARATOR ) ; return Math . max ( lastUnixPos , lastWindowsPos ) ; MST[rv.UOI3Mutator]MSP[N] } public static int indexOfExtension ( final String fileName ) throws IllegalArgumentException { if ( fileName == null ) { return NOT_FOUND ; }
if ( i == prefix + 2 ) { return null ; } if ( i == size - 1 ) { lastIsDirectory = true ; } int j ; for ( j = i - 4 ; j >= prefix ; j -- ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N]
if ( index == NOT_FOUND ) { return fileName ; } return fileName . substring ( 0 , index ) ; MST[rv.CRCR6Mutator]MSP[S] } public static boolean equals ( final String fileName1 , final String fileName2 ) { return equals ( fileName1 , fileName2 , false , IOCase . SENSITIVE ) ;
list . add ( buffer . toString () ) ; } return list . toArray ( new String [ list . size () ] ) ; } private static boolean isValidHostName ( final String name ) { return isIPv6Address ( name ) || isRFC3986HostName ( name ) ; MST[rv.CRCR6Mutator]MSP[N] }
final char [] array = new char [ size + 2 ] ; MST[rv.CRCR1Mutator]MSP[N] fileName . getChars ( 0 , fileName . length () , array , 0 ) ; final char otherSeparator = separator == SYSTEM_SEPARATOR ? OTHER_SEPARATOR : SYSTEM_SEPARATOR ;
System . arraycopy ( array , i + 1 , array , prefix , size - i ) ; size -= i + 1 - prefix ; i = prefix + 1 ; } } if ( size <= 0 ) { return EMPTY_STRING ; MST[ReturnValsMutator]MSP[N] }
if ( i == prefix + 2 ) { return null ; } if ( i == size - 1 ) { lastIsDirectory = true ; } int j ; for ( j = i - 4 ; j >= prefix ; j -- ) { MST[rv.ROR5Mutator]MSP[N]
if ( array [ i ] == separator && array [ i - 1 ] == '.' && array [ i - 2 ] == '.' && MST[rv.AOD2Mutator]MSP[N] ( i == prefix + 2 || array [ i - 3 ] == separator ) ) {
} else if ( isSeparator ( ch0 ) && isSeparator ( ch1 ) ) { MST[rv.UOI2Mutator]MSP[N] int posUnix = fileName . indexOf ( UNIX_SEPARATOR , 2 ) ; int posWin = fileName . indexOf ( WINDOWS_SEPARATOR , 2 ) ;
} else if ( isSeparator ( ch0 ) && isSeparator ( ch1 ) ) { MST[rv.UOI3Mutator]MSP[N] int posUnix = fileName . indexOf ( UNIX_SEPARATOR , 2 ) ; int posWin = fileName . indexOf ( WINDOWS_SEPARATOR , 2 ) ;
public static String normalizeNoEndSeparator ( final String fileName ) { return doNormalize ( fileName , SYSTEM_SEPARATOR , false ) ; } public static String normalizeNoEndSeparator ( final String fileName , final boolean unixSeparator ) { final char separator = unixSeparator ? UNIX_SEPARATOR : WINDOWS_SEPARATOR ; MST[rv.ROR2Mutator]MSP[N]
octetInt = Integer . parseInt ( octet , BASE_16 ) ; } catch ( final NumberFormatException e ) { return false ; } if ( octetInt < 0 || octetInt > MAX_UNSIGNED_SHORT ) { MST[rv.CRCR3Mutator]MSP[N] return false ; } } validOctets ++ ; }
if ( array [ i ] == separator && array [ i - 1 ] == '.' && array [ i - 2 ] == '.' && MST[rv.UOI1Mutator]MSP[N] ( i == prefix + 2 || array [ i - 3 ] == separator ) ) {
return fileName . substring ( index + 1 ) ; MST[rv.ABSMutator]MSP[N] } private static void failIfNullBytePresent ( final String path ) { final int len = path . length () ; for ( int i = 0 ; i < len ; i ++ ) {
final char ch1 = fileName . charAt ( 1 ) ; if ( ch1 == ':' ) { ch0 = Character . toUpperCase ( ch0 ) ; if ( ch0 >= 'A' && ch0 <= 'Z' ) { MST[rv.CRCR5Mutator]MSP[S]
anyChars = false ; } else if ( wcs [ wcsIdx ] . equals ( lr_7 ) ) { anyChars = true ; if ( wcsIdx == wcs . length - 1 ) { textIdx = fileName . length () ; } } else { if ( anyChars ) { MST[rv.ABSMutator]MSP[N]
if ( prefix > 0 ) { MST[rv.ROR2Mutator]MSP[N] return normalize ( fullFileNameToAdd ) ; } if ( basePath == null ) { return null ; } final int len = basePath . length () ; if ( len == 0 ) { return normalize ( fullFileNameToAdd ) ; }
System . arraycopy ( array , i + 1 , array , prefix , size - i ) ; size -= i + 1 - prefix ; i = prefix + 1 ; } } if ( size <= 0 ) { MST[rv.UOI3Mutator]MSP[N] return EMPTY_STRING ; }
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2 ) { return NOT_FOUND ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ; MST[rv.UOI4Mutator]MSP[N]
if ( extension == null || extension . isEmpty () ) { return indexOfExtension ( fileName ) == NOT_FOUND ; MST[rv.CRCR2Mutator]MSP[N] } final String fileExt = getExtension ( fileName ) ; return fileExt . equals ( extension ) ; }
if ( len < 0 ) { return null ; } if ( len > fileName . length () ) { failIfNullBytePresent ( fileName + UNIX_SEPARATOR ) ; MST[VoidMethodCallMutator]MSP[N] return fileName + UNIX_SEPARATOR ; } final String path = fileName . substring ( 0 , len ) ;
octetInt = Integer . parseInt ( octet , BASE_16 ) ; } catch ( final NumberFormatException e ) { return false ; } if ( octetInt < 0 || octetInt > MAX_UNSIGNED_SHORT ) { MST[NegateConditionalsMutator]MSP[N] return false ; } } validOctets ++ ; }
if ( prefix > 0 ) { return normalize ( fullFileNameToAdd ) ; } if ( basePath == null ) { return null ; } final int len = basePath . length () ; if ( len == 0 ) { MST[rv.ROR5Mutator]MSP[N] return normalize ( fullFileNameToAdd ) ; }
if ( len == 2 || isSeparator ( fileName . charAt ( 2 ) ) == false ) { MST[rv.CRCR2Mutator]MSP[N] return 2 ; } return 3 ; } else if ( ch0 == UNIX_SEPARATOR ) { return 1 ; } return NOT_FOUND ;
final int lastWindowsPos = fileName . lastIndexOf ( WINDOWS_SEPARATOR ) ; return Math . max ( lastUnixPos , lastWindowsPos ) ; MST[ReturnValsMutator]MSP[N] } public static int indexOfExtension ( final String fileName ) throws IllegalArgumentException { if ( fileName == null ) { return NOT_FOUND ; }
return new String ( array , 0 , size - 1 ) ; MST[rv.AOR1Mutator]MSP[N] } public static String concat ( final String basePath , final String fullFileNameToAdd ) { final int prefix = getPrefixLength ( fullFileNameToAdd ) ; if ( prefix < 0 ) { return null ; }
if ( size <= prefix ) { return new String ( array , 0 , size ) ; } if ( lastIsDirectory && keepSeparator ) { return new String ( array , 0 , size ) ; MST[rv.UOI3Mutator]MSP[N] }
System . arraycopy ( array , i + 1 , array , i - 1 , size - i ) ; MST[MathMutator]MSP[N] size -= 2 ; i -- ; } } outer: for ( int i = prefix + 2 ; i < size ; i ++ ) {
if ( index == NOT_FOUND ) { return fileName ; MST[EmptyObjectReturnValsMutator]MSP[N] } return fileName . substring ( 0 , index ) ; } public static boolean equals ( final String fileName1 , final String fileName2 ) { return equals ( fileName1 , fileName2 , false , IOCase . SENSITIVE ) ;
for ( int i = 1 ; i <= 4 ; i ++ ) { final String ipSegment = m . group ( i ) ; final int iIpSegment = Integer . parseInt ( ipSegment ) ; if ( iIpSegment > IPV4_MAX_OCTET_VALUE ) { return false ; MST[BooleanTrueReturnValsMutator]MSP[N] }
( i == prefix + 1 || array [ i - 2 ] == separator ) ) { if ( i == size - 1 ) { MST[rv.CRCR4Mutator]MSP[N] lastIsDirectory = true ; }
for ( int i = prefix + 1 ; i < size ; i ++ ) { MST[rv.ROR5Mutator]MSP[N] if ( array [ i ] == separator && array [ i - 1 ] == '.' &&
list . add ( buffer . toString () ) ; } return list . toArray ( new String [ list . size () ] ) ; } private static boolean isValidHostName ( final String name ) { return isIPv6Address ( name ) || isRFC3986HostName ( name ) ; MST[rv.ROR3Mutator]MSP[N] }
if ( validOctets > IPV6_MAX_HEX_GROUPS || ( validOctets < IPV6_MAX_HEX_GROUPS && ! containsCompressedZeroes ) ) { MST[rv.CRCR4Mutator]MSP[N] return false ; } return true ; } private static boolean isRFC3986HostName ( final String name ) { final String [] parts = name . split ( lr_13 , - 1 ) ;
if ( octet . length () == 0 ) { emptyOctets ++ ; if ( emptyOctets > 1 ) { return false ; } } else { emptyOctets = 0 ; if ( index == octets . length - 1 && octet . contains ( lr_12 ) ) { MST[rv.AOR2Mutator]MSP[S]
if ( array [ i ] == separator && array [ i - 1 ] == '.' && array [ i - 2 ] == '.' && MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] ( i == prefix + 2 || array [ i - 3 ] == separator ) ) {
if ( len == 2 || isSeparator ( fileName . charAt ( 2 ) ) == false ) { return 2 ; MST[ReturnValsMutator]MSP[N] } return 3 ; } else if ( ch0 == UNIX_SEPARATOR ) { return 1 ; } return NOT_FOUND ;
private static boolean isIPv4Address ( final String name ) { final Matcher m = IPV4_PATTERN . matcher ( name ) ; if ( ! m . matches () || m . groupCount () != 4 ) { return false ; MST[ReturnValsMutator]MSP[N] }
final int index = indexOfLastSeparator ( fileName ) ; if ( index < 0 ) { return fileName . substring ( 0 , prefix ) ; } int end = index + ( includeSeparator ? 1 : 0 ) ; MST[rv.CRCR3Mutator]MSP[N] if ( end == 0 ) { end ++ ;
return indexOfExtension ( fileName ) == NOT_FOUND ; } final String fileExt = getExtension ( fileName ) ; MST[NonVoidMethodCallMutator]MSP[S] for ( final String extension : extensions ) { if ( fileExt . equals ( extension ) ) { return true ; } } return false ; }
System . arraycopy ( array , i + 1 , array , i - 1 , size - i ) ; size -= 2 ; i -- ; } } outer: for ( int i = prefix + 2 ; i < size ; i ++ ) { MST[rv.UOI1Mutator]MSP[N]
final char ch = basePath . charAt ( len - 1 ) ; if ( isSeparator ( ch ) ) { return normalize ( basePath + fullFileNameToAdd ) ; MST[ConstructorCallMutator]MSP[N] } return normalize ( basePath + '/' + fullFileNameToAdd ) ; }
list . add ( lr_6 ) ; } else if ( prevChar != '*' ) { MST[rv.CRCR3Mutator]MSP[S] list . add ( lr_7 ) ; } } else { buffer . append ( ch ) ; } prevChar = ch ; } if ( buffer . length () != 0 ) {
public static String normalizeNoEndSeparator ( final String fileName ) { return doNormalize ( fileName , SYSTEM_SEPARATOR , false ) ; MST[NonVoidMethodCallMutator]MSP[N] } public static String normalizeNoEndSeparator ( final String fileName , final boolean unixSeparator ) { final char separator = unixSeparator ? UNIX_SEPARATOR : WINDOWS_SEPARATOR ;
if ( fileName == null || wildcardMatcher == null ) { return false ; } if ( caseSensitivity == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] caseSensitivity = IOCase . SENSITIVE ; } final String [] wcs = splitOnTokens ( wildcardMatcher ) ; boolean anyChars = false ; int textIdx = 0 ;
for ( int i = 0 ; i < array . length ; i ++ ) { if ( array [ i ] == otherSeparator ) { MST[rv.UOI3Mutator]MSP[N] array [ i ] = separator ; } } boolean lastIsDirectory = true ;
if ( len == 2 || isSeparator ( fileName . charAt ( 2 ) ) == false ) { MST[InlineConstantMutator]MSP[N] return 2 ; } return 3 ; } else if ( ch0 == UNIX_SEPARATOR ) { return 1 ; } return NOT_FOUND ;
for ( int i = 0 ; i < parts . length ; i ++ ) { if ( parts [ i ] . length () == 0 ) { return i == parts . length - 1 ; MST[rv.ROR4Mutator]MSP[N] }
System . arraycopy ( array , i + 1 , array , prefix , size - i ) ; MST[rv.CRCR4Mutator]MSP[N] size -= i + 1 - prefix ; i = prefix + 1 ; } } if ( size <= 0 ) { return EMPTY_STRING ; }
textIdx = array [ 1 ] ; MST[rv.UOI2Mutator]MSP[N] anyChars = true ; } while ( wcsIdx < wcs . length ) { if ( wcs [ wcsIdx ] . equals ( lr_6 ) ) { textIdx ++ ; if ( textIdx > fileName . length () ) { break; }
if ( path == null || path . indexOf ( UNIX_SEPARATOR ) == NOT_FOUND ) { return path ; } return path . replace ( UNIX_SEPARATOR , WINDOWS_SEPARATOR ) ; MST[rv.CRCR2Mutator]MSP[N] } public static String separatorsToSystem ( final String path ) { if ( path == null ) {
if ( array [ j ] == separator ) { System . arraycopy ( array , i + 1 , array , j + 1 , size - i ) ; MST[rv.ABSMutator]MSP[N] size -= i - j ; i = j + 1 ; continue outer; } }
if ( octets . length > IPV6_MAX_HEX_GROUPS ) { return false ; } int validOctets = 0 ; int emptyOctets = 0 ; for ( int index = 0 ; index < octets . length ; index ++ ) { MST[rv.UOI1Mutator]MSP[N] final String octet = octets [ index ] ;
if ( len == 2 || isSeparator ( fileName . charAt ( 2 ) ) == false ) { MST[rv.CRCR6Mutator]MSP[N] return 2 ; } return 3 ; } else if ( ch0 == UNIX_SEPARATOR ) { return 1 ; } return NOT_FOUND ;
if ( len == 2 || isSeparator ( fileName . charAt ( 2 ) ) == false ) { return 2 ; } return 3 ; } else if ( ch0 == UNIX_SEPARATOR ) { MST[InlineConstantMutator]MSP[N] return 1 ; } return NOT_FOUND ;
if ( len == 2 || isSeparator ( fileName . charAt ( 2 ) ) == false ) { return 2 ; } return 3 ; } else if ( ch0 == UNIX_SEPARATOR ) { MST[rv.UOI2Mutator]MSP[S] return 1 ; } return NOT_FOUND ;
if ( len < 0 ) { return null ; } if ( len > fileName . length () ) { failIfNullBytePresent ( fileName + UNIX_SEPARATOR ) ; MST[experimental.NakedReceiverMutator]MSP[N] return fileName + UNIX_SEPARATOR ; } final String path = fileName . substring ( 0 , len ) ;
list . add ( buffer . toString () ) ; } return list . toArray ( new String [ list . size () ] ) ; } private static boolean isValidHostName ( final String name ) { return isIPv6Address ( name ) || isRFC3986HostName ( name ) ; MST[InlineConstantMutator]MSP[N] }
return new String ( array , 0 , size - 1 ) ; MST[rv.CRCR1Mutator]MSP[N] } public static String concat ( final String basePath , final String fullFileNameToAdd ) { final int prefix = getPrefixLength ( fullFileNameToAdd ) ; if ( prefix < 0 ) { return null ; }
for ( int i = 0 ; i < parts . length ; i ++ ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] if ( parts [ i ] . length () == 0 ) { return i == parts . length - 1 ; }
for ( int i = prefix + 1 ; i < size ; i ++ ) { if ( array [ i ] == separator && array [ i - 1 ] == '.' && MST[rv.ROR2Mutator]MSP[N]
if ( repeat >= 0 ) { backtrack . push ( new int [] { wcsIdx , repeat } ) ; MST[rv.UOI3Mutator]MSP[S] } } else { if ( ! caseSensitivity . checkRegionMatches ( fileName , textIdx , wcs [ wcsIdx ] ) ) { break; } }
textIdx = array [ 1 ] ; anyChars = true ; } while ( wcsIdx < wcs . length ) { if ( wcs [ wcsIdx ] . equals ( lr_6 ) ) { textIdx ++ ; MST[IncrementsMutator]MSP[N] if ( textIdx > fileName . length () ) { break; }
if ( index == NOT_FOUND ) { return fileName ; } return fileName . substring ( 0 , index ) ; } public static boolean equals ( final String fileName1 , final String fileName2 ) { return equals ( fileName1 , fileName2 , false , IOCase . SENSITIVE ) ; MST[ReturnValsMutator]MSP[N]
int wcsIdx = 0 ; final Stack < int [] > backtrack = new Stack <> () ; do { if ( backtrack . size () > 0 ) { MST[ConditionalsBoundaryMutator]MSP[N] final int [] array = backtrack . pop () ; wcsIdx = array [ 0 ] ;
if ( ! isIPv4Address ( octet ) ) { return false ; } validOctets += 2 ; continue; } if ( octet . length () > IPV6_MAX_HEX_DIGITS_PER_GROUP ) { return false ; MST[rv.CRCR5Mutator]MSP[N] } int octetInt = 0 ; try {
static boolean isSystemWindows () { return SYSTEM_SEPARATOR == WINDOWS_SEPARATOR ; MST[rv.ROR5Mutator]MSP[N] } private static boolean isSeparator ( final char ch ) { return ch == UNIX_SEPARATOR || ch == WINDOWS_SEPARATOR ; } public static String normalize ( final String fileName ) {
return null ; } return isSystemWindows () ? separatorsToWindows ( path ) : separatorsToUnix ( path ) ; } public static int getPrefixLength ( final String fileName ) { if ( fileName == null ) { return NOT_FOUND ; MST[InlineConstantMutator]MSP[N] } final int len = fileName . length () ;
final int lastSeparator = indexOfLastSeparator ( fileName ) ; return lastSeparator > extensionPos ? NOT_FOUND : extensionPos ; } public static String getPrefix ( final String fileName ) { if ( fileName == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return null ; } final int len = getPrefixLength ( fileName ) ;
if ( len < 0 ) { return null ; } if ( len > fileName . length () ) { failIfNullBytePresent ( fileName + UNIX_SEPARATOR ) ; MST[NonVoidMethodCallMutator]MSP[N] return fileName + UNIX_SEPARATOR ; } final String path = fileName . substring ( 0 , len ) ;
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2 ) { MST[rv.UOI4Mutator]MSP[N] return NOT_FOUND ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ;
textIdx = array [ 1 ] ; MST[rv.CRCR3Mutator]MSP[S] anyChars = true ; } while ( wcsIdx < wcs . length ) { if ( wcs [ wcsIdx ] . equals ( lr_6 ) ) { textIdx ++ ; if ( textIdx > fileName . length () ) { break; }
if ( array [ i ] == separator && array [ i - 1 ] == '.' && array [ i - 2 ] == '.' && MST[rv.UOI3Mutator]MSP[N] ( i == prefix + 2 || array [ i - 3 ] == separator ) ) {
if ( i == prefix + 2 ) { MST[rv.AOD2Mutator]MSP[N] return null ; } if ( i == size - 1 ) { lastIsDirectory = true ; } int j ; for ( j = i - 4 ; j >= prefix ; j -- ) {
public static boolean directoryContains ( final String canonicalParent , final String canonicalChild ) throws IOException { if ( canonicalParent == null ) { throw new IllegalArgumentException ( lr_1 ) ; } if ( canonicalChild == null ) { return false ; MST[rv.CRCR1Mutator]MSP[N] }
System . arraycopy ( array , i + 1 , array , prefix , size - i ) ; size -= i + 1 - prefix ; MST[rv.UOI1Mutator]MSP[N] i = prefix + 1 ; } } if ( size <= 0 ) { return EMPTY_STRING ; }
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND ) { return len + 1 ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return Math . min ( posUnix , posWin ) + 1 ; }
public static boolean wildcardMatch ( final String fileName , final String wildcardMatcher ) { return wildcardMatch ( fileName , wildcardMatcher , IOCase . SENSITIVE ) ; MST[NonVoidMethodCallMutator]MSP[N] } public static boolean wildcardMatchOnSystem ( final String fileName , final String wildcardMatcher ) {
final int index = indexOfLastSeparator ( fileName ) ; final int endIndex = index + separatorAdd ; if ( prefix >= fileName . length () || index < 0 || prefix >= endIndex ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] return EMPTY_STRING ; }
if ( prefix > 0 ) { return normalize ( fullFileNameToAdd ) ; MST[EmptyObjectReturnValsMutator]MSP[N] } if ( basePath == null ) { return null ; } final int len = basePath . length () ; if ( len == 0 ) { return normalize ( fullFileNameToAdd ) ; }
textIdx = array [ 1 ] ; anyChars = true ; } while ( wcsIdx < wcs . length ) { if ( wcs [ wcsIdx ] . equals ( lr_6 ) ) { MST[rv.ROR1Mutator]MSP[N] textIdx ++ ; if ( textIdx > fileName . length () ) { break; }
for ( int i = prefix + 1 ; i < size ; i ++ ) { if ( array [ i ] == separator && array [ i - 1 ] == '.' && MST[rv.UOI1Mutator]MSP[N]
if ( array [ i ] == separator && array [ i - 1 ] == separator ) { MST[rv.UOI4Mutator]MSP[N] System . arraycopy ( array , i , array , i - 1 , size - i ) ; size -- ; i -- ; } }
if ( array [ i ] == separator && array [ i - 1 ] == '.' && array [ i - 2 ] == '.' && MST[rv.ROR4Mutator]MSP[N] ( i == prefix + 2 || array [ i - 3 ] == separator ) ) {
String fileName1 , String fileName2 , final boolean normalized , IOCase caseSensitivity ) { if ( fileName1 == null || fileName2 == null ) { return fileName1 == null && fileName2 == null ; } if ( normalized ) { MST[rv.ABSMutator]MSP[N] fileName1 = normalize ( fileName1 ) ;
anyChars = false ; } else if ( wcs [ wcsIdx ] . equals ( lr_7 ) ) { anyChars = true ; if ( wcsIdx == wcs . length - 1 ) { MST[rv.AOR2Mutator]MSP[N] textIdx = fileName . length () ; } } else { if ( anyChars ) {
final int lastSeparator = indexOfLastSeparator ( fileName ) ; return lastSeparator > extensionPos ? NOT_FOUND : extensionPos ; MST[rv.ABSMutator]MSP[N] } public static String getPrefix ( final String fileName ) { if ( fileName == null ) { return null ; } final int len = getPrefixLength ( fileName ) ;
for ( int i = 1 ; i <= 4 ; i ++ ) { final String ipSegment = m . group ( i ) ; final int iIpSegment = Integer . parseInt ( ipSegment ) ; if ( iIpSegment > IPV4_MAX_OCTET_VALUE ) { return false ; MST[rv.CRCR1Mutator]MSP[N] }
return doNormalize ( fileName , SYSTEM_SEPARATOR , true ) ; } public static String normalize ( final String fileName , final boolean unixSeparator ) { final char separator = unixSeparator ? UNIX_SEPARATOR : WINDOWS_SEPARATOR ; return doNormalize ( fileName , separator , true ) ; MST[rv.CRCR2Mutator]MSP[N] }
if ( array [ i ] == separator && array [ i - 1 ] == '.' && array [ i - 2 ] == '.' && MST[rv.AOR4Mutator]MSP[N] ( i == prefix + 2 || array [ i - 3 ] == separator ) ) {
if ( array [ size - 1 ] != separator ) { MST[rv.UOI4Mutator]MSP[N] array [ size ++ ] = separator ; lastIsDirectory = false ; } for ( int i = prefix + 1 ; i < size ; i ++ ) {
if ( len == 2 || isSeparator ( fileName . charAt ( 2 ) ) == false ) { MST[rv.CRCR5Mutator]MSP[N] return 2 ; } return 3 ; } else if ( ch0 == UNIX_SEPARATOR ) { return 1 ; } return NOT_FOUND ;
final int index = indexOfLastSeparator ( fileName ) ; if ( index < 0 ) { return fileName . substring ( 0 , prefix ) ; } int end = index + ( includeSeparator ? 1 : 0 ) ; MST[rv.UOI2Mutator]MSP[N] if ( end == 0 ) { end ++ ;
for ( int i = 0 ; i < parts . length ; i ++ ) { if ( parts [ i ] . length () == 0 ) { return i == parts . length - 1 ; MST[rv.ABSMutator]MSP[N] }
if ( len < 0 ) { return null ; } if ( len > fileName . length () ) { MST[NegateConditionalsMutator]MSP[N] failIfNullBytePresent ( fileName + UNIX_SEPARATOR ) ; return fileName + UNIX_SEPARATOR ; } final String path = fileName . substring ( 0 , len ) ;
for ( int i = prefix + 1 ; i < size ; i ++ ) { if ( array [ i ] == separator && array [ i - 1 ] == '.' && MST[rv.CRCR4Mutator]MSP[N]
if ( len == 0 ) { return 0 ; } char ch0 = fileName . charAt ( 0 ) ; if ( ch0 == ':' ) { return NOT_FOUND ; } if ( len == 1 ) { MST[rv.ROR4Mutator]MSP[N] if ( ch0 == '~' ) { return 2 ; }
return false ; } static String [] splitOnTokens ( final String text ) { if ( text . indexOf ( '?' ) == NOT_FOUND && text . indexOf ( '*' ) == NOT_FOUND ) { return new String [] { text } ; MST[rv.CRCR3Mutator]MSP[N] }
list . add ( lr_6 ) ; } else if ( prevChar != '*' ) { list . add ( lr_7 ) ; } } else { buffer . append ( ch ) ; MST[rv.UOI4Mutator]MSP[N] } prevChar = ch ; } if ( buffer . length () != 0 ) {
if ( len == 0 ) { return 0 ; } char ch0 = fileName . charAt ( 0 ) ; if ( ch0 == ':' ) { return NOT_FOUND ; MST[rv.CRCR2Mutator]MSP[N] } if ( len == 1 ) { if ( ch0 == '~' ) { return 2 ; }
public static String getExtension ( final String fileName ) throws IllegalArgumentException { if ( fileName == null ) { return null ; } final int index = indexOfExtension ( fileName ) ; if ( index == NOT_FOUND ) { MST[rv.UOI1Mutator]MSP[N] return EMPTY_STRING ; }
return equals ( fileName1 , fileName2 , true , IOCase . SENSITIVE ) ; MST[rv.CRCR3Mutator]MSP[N] } public static boolean equalsNormalizedOnSystem ( final String fileName1 , final String fileName2 ) { return equals ( fileName1 , fileName2 , true , IOCase . SYSTEM ) ; } public static boolean equals (
private static boolean isIPv4Address ( final String name ) { final Matcher m = IPV4_PATTERN . matcher ( name ) ; if ( ! m . matches () || m . groupCount () != 4 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] return false ; }
System . arraycopy ( array , i + 1 , array , i - 1 , size - i ) ; MST[VoidMethodCallMutator]MSP[N] size -= 2 ; i -- ; } } outer: for ( int i = prefix + 2 ; i < size ; i ++ ) {
final char ch = basePath . charAt ( len - 1 ) ; MST[rv.AOR3Mutator]MSP[N] if ( isSeparator ( ch ) ) { return normalize ( basePath + fullFileNameToAdd ) ; } return normalize ( basePath + '/' + fullFileNameToAdd ) ; }
return isSeparator ( ch0 ) ? 1 : 0 ; } } public static int indexOfLastSeparator ( final String fileName ) { if ( fileName == null ) { return NOT_FOUND ; } final int lastUnixPos = fileName . lastIndexOf ( UNIX_SEPARATOR ) ; MST[InlineConstantMutator]MSP[N]
return false ; } static String [] splitOnTokens ( final String text ) { if ( text . indexOf ( '?' ) == NOT_FOUND && text . indexOf ( '*' ) == NOT_FOUND ) { MST[rv.CRCR4Mutator]MSP[N] return new String [] { text } ; }
if ( array [ i ] == separator && array [ i - 1 ] == '.' && array [ i - 2 ] == '.' && MST[rv.CRCR2Mutator]MSP[N] ( i == prefix + 2 || array [ i - 3 ] == separator ) ) {
textIdx += wcs [ wcsIdx ] . length () ; anyChars = false ; } wcsIdx ++ ; } if ( wcsIdx == wcs . length && textIdx == fileName . length () ) { MST[NegateConditionalsMutator]MSP[N] return true ; } } while ( backtrack . size () > 0 );
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2 ) { MST[rv.UOI3Mutator]MSP[N] return NOT_FOUND ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ;
final int lastSeparator = indexOfLastSeparator ( fileName ) ; return lastSeparator > extensionPos ? NOT_FOUND : extensionPos ; MST[RemoveConditionalMutator_ORDER_IF]MSP[N] } public static String getPrefix ( final String fileName ) { if ( fileName == null ) { return null ; } final int len = getPrefixLength ( fileName ) ;
return equals ( fileName1 , fileName2 , true , IOCase . SENSITIVE ) ; } public static boolean equalsNormalizedOnSystem ( final String fileName1 , final String fileName2 ) { return equals ( fileName1 , fileName2 , true , IOCase . SYSTEM ) ; MST[BooleanFalseReturnValsMutator]MSP[S] } public static boolean equals (
if ( ! isIPv4Address ( octet ) ) { return false ; } validOctets += 2 ; continue; } if ( octet . length () > IPV6_MAX_HEX_DIGITS_PER_GROUP ) { MST[NegateConditionalsMutator]MSP[N] return false ; } int octetInt = 0 ; try {
final char ch = basePath . charAt ( len - 1 ) ; if ( isSeparator ( ch ) ) { MST[rv.ROR5Mutator]MSP[N] return normalize ( basePath + fullFileNameToAdd ) ; } return normalize ( basePath + '/' + fullFileNameToAdd ) ; }
list . add ( buffer . toString () ) ; } return list . toArray ( new String [ list . size () ] ) ; } private static boolean isValidHostName ( final String name ) { return isIPv6Address ( name ) || isRFC3986HostName ( name ) ; MST[rv.CRCR5Mutator]MSP[N] }
if ( array [ j ] == separator ) { System . arraycopy ( array , i + 1 , array , j + 1 , size - i ) ; MST[MathMutator]MSP[N] size -= i - j ; i = j + 1 ; continue outer; } }
final String path = fileName . substring ( prefix , endIndex ) ; failIfNullBytePresent ( path ) ; return path ; } public static String getFullPath ( final String fileName ) { return doGetFullPath ( fileName , true ) ; MST[rv.CRCR5Mutator]MSP[N] }
final char ch1 = fileName . charAt ( 1 ) ; if ( ch1 == ':' ) { ch0 = Character . toUpperCase ( ch0 ) ; MST[rv.ABSMutator]MSP[N] if ( ch0 >= 'A' && ch0 <= 'Z' ) {
octetInt = Integer . parseInt ( octet , BASE_16 ) ; } catch ( final NumberFormatException e ) { return false ; } if ( octetInt < 0 || octetInt > MAX_UNSIGNED_SHORT ) { return false ; } } validOctets ++ ; MST[experimental.RemoveIncrementsMutator]MSP[N] }
if ( array [ i ] == separator && array [ i - 1 ] == '.' && array [ i - 2 ] == '.' && MST[rv.UOI3Mutator]MSP[N] ( i == prefix + 2 || array [ i - 3 ] == separator ) ) {
return doNormalize ( fileName , SYSTEM_SEPARATOR , true ) ; } public static String normalize ( final String fileName , final boolean unixSeparator ) { final char separator = unixSeparator ? UNIX_SEPARATOR : WINDOWS_SEPARATOR ; MST[rv.UOI2Mutator]MSP[S] return doNormalize ( fileName , separator , true ) ; }
textIdx += wcs [ wcsIdx ] . length () ; MST[rv.AOD2Mutator]MSP[N] anyChars = false ; } wcsIdx ++ ; } if ( wcsIdx == wcs . length && textIdx == fileName . length () ) { return true ; } } while ( backtrack . size () > 0 );
} public static boolean equalsOnSystem ( final String fileName1 , final String fileName2 ) { return equals ( fileName1 , fileName2 , false , IOCase . SYSTEM ) ; MST[rv.CRCR5Mutator]MSP[S] } public static boolean equalsNormalized ( final String fileName1 , final String fileName2 ) {
} else if ( isSeparator ( ch0 ) && isSeparator ( ch1 ) ) { int posUnix = fileName . indexOf ( UNIX_SEPARATOR , 2 ) ; int posWin = fileName . indexOf ( WINDOWS_SEPARATOR , 2 ) ; MST[rv.CRCR2Mutator]MSP[N]
} else if ( inet6Address . startsWith ( lr_9 ) && ! octetList . isEmpty () ) { octetList . remove ( 0 ) ; MST[rv.CRCR6Mutator]MSP[N] } octets = octetList . toArray ( new String [ octetList . size () ] ) ; }
if ( array [ i ] == separator && array [ i - 1 ] == separator ) { System . arraycopy ( array , i , array , i - 1 , size - i ) ; MST[rv.AOR1Mutator]MSP[N] size -- ; i -- ; } }
return indexOfExtension ( fileName ) == NOT_FOUND ; } final String fileExt = getExtension ( fileName ) ; MST[ArgumentPropagationMutator]MSP[S] for ( final String extension : extensions ) { if ( fileExt . equals ( extension ) ) { return true ; } } return false ; }
if ( i == prefix + 2 ) { MST[rv.UOI2Mutator]MSP[N] return null ; } if ( i == size - 1 ) { lastIsDirectory = true ; } int j ; for ( j = i - 4 ; j >= prefix ; j -- ) {
return isSeparator ( ch0 ) ? 1 : 0 ; MST[rv.UOI2Mutator]MSP[S] } if ( ch0 == '~' ) { int posUnix = fileName . indexOf ( UNIX_SEPARATOR , 1 ) ; int posWin = fileName . indexOf ( WINDOWS_SEPARATOR , 1 ) ;
return false ; } static String [] splitOnTokens ( final String text ) { if ( text . indexOf ( '?' ) == NOT_FOUND && text . indexOf ( '*' ) == NOT_FOUND ) { return new String [] { text } ; MST[rv.CRCR2Mutator]MSP[N] }
if ( array [ j ] == separator ) { System . arraycopy ( array , i + 1 , array , j + 1 , size - i ) ; size -= i - j ; MST[rv.UOI1Mutator]MSP[N] i = j + 1 ; continue outer; } }
textIdx = array [ 1 ] ; anyChars = true ; } while ( wcsIdx < wcs . length ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] if ( wcs [ wcsIdx ] . equals ( lr_6 ) ) { textIdx ++ ; if ( textIdx > fileName . length () ) { break; }
for ( int i = 0 ; i < parts . length ; i ++ ) { if ( parts [ i ] . length () == 0 ) { return i == parts . length - 1 ; MST[rv.UOI2Mutator]MSP[N] }
final int index = indexOfLastSeparator ( fileName ) ; if ( index < 0 ) { return fileName . substring ( 0 , prefix ) ; } int end = index + ( includeSeparator ? 1 : 0 ) ; MST[rv.ABSMutator]MSP[N] if ( end == 0 ) { end ++ ;
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2 ) { return NOT_FOUND ; MST[rv.CRCR4Mutator]MSP[N] } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ;
return doNormalize ( fileName , separator , false ) ; } private static String doNormalize ( final String fileName , final char separator , final boolean keepSeparator ) { if ( fileName == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return null ; } failIfNullBytePresent ( fileName ) ;
textIdx += wcs [ wcsIdx ] . length () ; anyChars = false ; } wcsIdx ++ ; } if ( wcsIdx == wcs . length && textIdx == fileName . length () ) { MST[rv.ROR2Mutator]MSP[N] return true ; } } while ( backtrack . size () > 0 );
if ( array [ size - 1 ] != separator ) { array [ size ++ ] = separator ; MST[rv.UOI2Mutator]MSP[N] lastIsDirectory = false ; } for ( int i = prefix + 1 ; i < size ; i ++ ) {
static boolean isSystemWindows () { return SYSTEM_SEPARATOR == WINDOWS_SEPARATOR ; } private static boolean isSeparator ( final char ch ) { return ch == UNIX_SEPARATOR || ch == WINDOWS_SEPARATOR ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } public static String normalize ( final String fileName ) {
final int index = indexOfLastSeparator ( fileName ) ; final int endIndex = index + separatorAdd ; if ( prefix >= fileName . length () || index < 0 || prefix >= endIndex ) { MST[rv.ROR4Mutator]MSP[N] return EMPTY_STRING ; }
if ( path == null || path . indexOf ( WINDOWS_SEPARATOR ) == NOT_FOUND ) { MST[NonVoidMethodCallMutator]MSP[N] return path ; } return path . replace ( WINDOWS_SEPARATOR , UNIX_SEPARATOR ) ; } public static String separatorsToWindows ( final String path ) {
textIdx += wcs [ wcsIdx ] . length () ; anyChars = false ; } wcsIdx ++ ; } if ( wcsIdx == wcs . length && textIdx == fileName . length () ) { MST[rv.ROR5Mutator]MSP[N] return true ; } } while ( backtrack . size () > 0 );
return wildcardMatch ( fileName , wildcardMatcher , IOCase . SYSTEM ) ; MST[BooleanFalseReturnValsMutator]MSP[S] } public static boolean wildcardMatch ( final String fileName , final String wildcardMatcher , IOCase caseSensitivity ) { if ( fileName == null && wildcardMatcher == null ) { return true ; }
if ( octet . length () == 0 ) { emptyOctets ++ ; if ( emptyOctets > 1 ) { return false ; } } else { emptyOctets = 0 ; if ( index == octets . length - 1 && octet . contains ( lr_12 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S]
if ( len == 0 ) { return 0 ; } char ch0 = fileName . charAt ( 0 ) ; if ( ch0 == ':' ) { return NOT_FOUND ; } if ( len == 1 ) { if ( ch0 == '~' ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return 2 ; }
String fileName1 , String fileName2 , final boolean normalized , IOCase caseSensitivity ) { if ( fileName1 == null || fileName2 == null ) { return fileName1 == null && fileName2 == null ; MST[rv.CRCR3Mutator]MSP[N] } if ( normalized ) { fileName1 = normalize ( fileName1 ) ;
final char [] array = new char [ size + 2 ] ; fileName . getChars ( 0 , fileName . length () , array , 0 ) ; final char otherSeparator = separator == SYSTEM_SEPARATOR ? OTHER_SEPARATOR : SYSTEM_SEPARATOR ; MST[rv.ROR1Mutator]MSP[N]
if ( array [ i ] == separator && array [ i - 1 ] == '.' && array [ i - 2 ] == '.' && MST[rv.CRCR3Mutator]MSP[N] ( i == prefix + 2 || array [ i - 3 ] == separator ) ) {
return wildcardMatch ( fileName , wildcardMatcher , IOCase . SYSTEM ) ; } public static boolean wildcardMatch ( final String fileName , final String wildcardMatcher , IOCase caseSensitivity ) { if ( fileName == null && wildcardMatcher == null ) { return true ; MST[rv.CRCR6Mutator]MSP[N] }
if ( array [ j ] == separator ) { System . arraycopy ( array , i + 1 , array , j + 1 , size - i ) ; MST[rv.CRCR2Mutator]MSP[N] size -= i - j ; i = j + 1 ; continue outer; } }
return wildcardMatch ( fileName , wildcardMatcher , IOCase . SYSTEM ) ; } public static boolean wildcardMatch ( final String fileName , final String wildcardMatcher , IOCase caseSensitivity ) { if ( fileName == null && wildcardMatcher == null ) { return true ; MST[rv.CRCR3Mutator]MSP[N] }
} else if ( isSeparator ( ch0 ) && isSeparator ( ch1 ) ) { int posUnix = fileName . indexOf ( UNIX_SEPARATOR , 2 ) ; MST[ArgumentPropagationMutator]MSP[N] int posWin = fileName . indexOf ( WINDOWS_SEPARATOR , 2 ) ;
return isSeparator ( ch0 ) ? 1 : 0 ; MST[rv.CRCR4Mutator]MSP[N] } if ( ch0 == '~' ) { int posUnix = fileName . indexOf ( UNIX_SEPARATOR , 1 ) ; int posWin = fileName . indexOf ( WINDOWS_SEPARATOR , 1 ) ;
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND ) { return len + 1 ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ; return Math . min ( posUnix , posWin ) + 1 ; MST[rv.CRCR6Mutator]MSP[N] }
if ( array [ j ] == separator ) { System . arraycopy ( array , i + 1 , array , j + 1 , size - i ) ; size -= i - j ; MST[rv.AOR2Mutator]MSP[N] i = j + 1 ; continue outer; } }
if ( index == NOT_FOUND ) { return fileName ; } return fileName . substring ( 0 , index ) ; MST[rv.ABSMutator]MSP[S] } public static boolean equals ( final String fileName1 , final String fileName2 ) { return equals ( fileName1 , fileName2 , false , IOCase . SENSITIVE ) ;
return indexOfExtension ( fileName ) == NOT_FOUND ; MST[rv.CRCR2Mutator]MSP[N] } final String fileExt = getExtension ( fileName ) ; for ( final String extension : extensions ) { if ( fileExt . equals ( extension ) ) { return true ; } } return false ; }
anyChars = false ; } else if ( wcs [ wcsIdx ] . equals ( lr_7 ) ) { anyChars = true ; if ( wcsIdx == wcs . length - 1 ) { textIdx = fileName . length () ; MST[NonVoidMethodCallMutator]MSP[N] } } else { if ( anyChars ) {
public static boolean isExtension ( final String fileName , final String ... extensions ) { if ( fileName == null ) { MST[rv.ROR5Mutator]MSP[N] return false ; } failIfNullBytePresent ( fileName ) ; if ( extensions == null || extensions . length == 0 ) {
return isSeparator ( ch0 ) ? 1 : 0 ; } if ( ch0 == '~' ) { int posUnix = fileName . indexOf ( UNIX_SEPARATOR , 1 ) ; MST[rv.CRCR4Mutator]MSP[N] int posWin = fileName . indexOf ( WINDOWS_SEPARATOR , 1 ) ;
final char ch1 = fileName . charAt ( 1 ) ; if ( ch1 == ':' ) { MST[rv.UOI1Mutator]MSP[N] ch0 = Character . toUpperCase ( ch0 ) ; if ( ch0 >= 'A' && ch0 <= 'Z' ) {
return fileName . substring ( index + 1 ) ; MST[EmptyObjectReturnValsMutator]MSP[N] } private static void failIfNullBytePresent ( final String path ) { final int len = path . length () ; for ( int i = 0 ; i < len ; i ++ ) {
if ( array [ j ] == separator ) { System . arraycopy ( array , i + 1 , array , j + 1 , size - i ) ; size -= i - j ; MST[rv.UOI4Mutator]MSP[N] i = j + 1 ; continue outer; } }
list . add ( buffer . toString () ) ; } return list . toArray ( new String [ list . size () ] ) ; } private static boolean isValidHostName ( final String name ) { return isIPv6Address ( name ) || isRFC3986HostName ( name ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] }
if ( ch == '?' || ch == '*' ) { if ( buffer . length () != 0 ) { list . add ( buffer . toString () ) ; buffer . setLength ( 0 ) ; } if ( ch == '?' ) { MST[rv.CRCR5Mutator]MSP[N]
return fileName . substring ( index + 1 ) ; MST[rv.AOD2Mutator]MSP[N] } private static void failIfNullBytePresent ( final String path ) { final int len = path . length () ; for ( int i = 0 ; i < len ; i ++ ) {
anyChars = false ; } else if ( wcs [ wcsIdx ] . equals ( lr_7 ) ) { anyChars = true ; if ( wcsIdx == wcs . length - 1 ) { textIdx = fileName . length () ; } } else { if ( anyChars ) { MST[NegateConditionalsMutator]MSP[N]
if ( path == null || path . indexOf ( WINDOWS_SEPARATOR ) == NOT_FOUND ) { MST[rv.CRCR2Mutator]MSP[N] return path ; } return path . replace ( WINDOWS_SEPARATOR , UNIX_SEPARATOR ) ; } public static String separatorsToWindows ( final String path ) {
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND ) { return len + 1 ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ; return Math . min ( posUnix , posWin ) + 1 ; MST[rv.UOI4Mutator]MSP[N] }
return indexOfExtension ( fileName ) == NOT_FOUND ; } final String fileExt = getExtension ( fileName ) ; for ( final String extension : extensions ) { MST[rv.UOI4Mutator]MSP[N] if ( fileExt . equals ( extension ) ) { return true ; } } return false ; }
for ( int i = 1 ; i <= 4 ; i ++ ) { MST[InlineConstantMutator]MSP[N] final String ipSegment = m . group ( i ) ; final int iIpSegment = Integer . parseInt ( ipSegment ) ; if ( iIpSegment > IPV4_MAX_OCTET_VALUE ) { return false ; }
System . arraycopy ( array , i + 1 , array , i - 1 , size - i ) ; MST[InlineConstantMutator]MSP[N] size -= 2 ; i -- ; } } outer: for ( int i = prefix + 2 ; i < size ; i ++ ) {
return indexOfExtension ( fileName ) == NOT_FOUND ; } final String fileExt = getExtension ( fileName ) ; for ( final String extension : extensions ) { if ( fileExt . equals ( extension ) ) { return true ; MST[rv.CRCR4Mutator]MSP[N] } } return false ; }
if ( repeat >= 0 ) { backtrack . push ( new int [] { wcsIdx , repeat } ) ; } } else { if ( ! caseSensitivity . checkRegionMatches ( fileName , textIdx , wcs [ wcsIdx ] ) ) { MST[rv.UOI3Mutator]MSP[N] break; } }
anyChars = false ; } else if ( wcs [ wcsIdx ] . equals ( lr_7 ) ) { MST[NonVoidMethodCallMutator]MSP[N] anyChars = true ; if ( wcsIdx == wcs . length - 1 ) { textIdx = fileName . length () ; } } else { if ( anyChars ) {
for ( int i = 0 ; i < array . length ; i ++ ) { if ( array [ i ] == otherSeparator ) { MST[rv.ABSMutator]MSP[N] array [ i ] = separator ; } } boolean lastIsDirectory = true ;
System . arraycopy ( array , i + 1 , array , prefix , size - i ) ; size -= i + 1 - prefix ; MST[rv.AOR3Mutator]MSP[N] i = prefix + 1 ; } } if ( size <= 0 ) { return EMPTY_STRING ; }
final char [] array = new char [ size + 2 ] ; MST[rv.AOR1Mutator]MSP[N] fileName . getChars ( 0 , fileName . length () , array , 0 ) ; final char otherSeparator = separator == SYSTEM_SEPARATOR ? OTHER_SEPARATOR : SYSTEM_SEPARATOR ;
if ( len == 2 || isSeparator ( fileName . charAt ( 2 ) ) == false ) { return 2 ; } return 3 ; } else if ( ch0 == UNIX_SEPARATOR ) { MST[rv.ABSMutator]MSP[N] return 1 ; } return NOT_FOUND ;
private static boolean isIPv4Address ( final String name ) { final Matcher m = IPV4_PATTERN . matcher ( name ) ; if ( ! m . matches () || m . groupCount () != 4 ) { MST[rv.ROR5Mutator]MSP[N] return false ; }
return equals ( fileName1 , fileName2 , true , IOCase . SENSITIVE ) ; MST[rv.CRCR6Mutator]MSP[S] } public static boolean equalsNormalizedOnSystem ( final String fileName1 , final String fileName2 ) { return equals ( fileName1 , fileName2 , true , IOCase . SYSTEM ) ; } public static boolean equals (
failIfNullBytePresent ( path ) ; return path ; MST[ReturnValsMutator]MSP[N] } public static String getPath ( final String fileName ) { return doGetPath ( fileName , 1 ) ; } public static String getPathNoEndSeparator ( final String fileName ) { return doGetPath ( fileName , 0 ) ; }
public static boolean isExtension ( final String fileName , final String ... extensions ) { if ( fileName == null ) { return false ; } failIfNullBytePresent ( fileName ) ; if ( extensions == null || extensions . length == 0 ) { MST[NegateConditionalsMutator]MSP[N]
if ( array [ i ] == separator && array [ i - 1 ] == separator ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] System . arraycopy ( array , i , array , i - 1 , size - i ) ; size -- ; i -- ; } }
textIdx = array [ 1 ] ; anyChars = true ; } while ( wcsIdx < wcs . length ) { if ( wcs [ wcsIdx ] . equals ( lr_6 ) ) { textIdx ++ ; if ( textIdx > fileName . length () ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] break; }
if ( len == 2 || isSeparator ( fileName . charAt ( 2 ) ) == false ) { MST[rv.ROR2Mutator]MSP[N] return 2 ; } return 3 ; } else if ( ch0 == UNIX_SEPARATOR ) { return 1 ; } return NOT_FOUND ;
final char ch = basePath . charAt ( len - 1 ) ; MST[rv.UOI2Mutator]MSP[N] if ( isSeparator ( ch ) ) { return normalize ( basePath + fullFileNameToAdd ) ; } return normalize ( basePath + '/' + fullFileNameToAdd ) ; }
textIdx = array [ 1 ] ; anyChars = true ; } while ( wcsIdx < wcs . length ) { if ( wcs [ wcsIdx ] . equals ( lr_6 ) ) { textIdx ++ ; if ( textIdx > fileName . length () ) { MST[rv.ROR4Mutator]MSP[N] break; }
System . arraycopy ( array , i + 1 , array , prefix , size - i ) ; MST[rv.AOR4Mutator]MSP[N] size -= i + 1 - prefix ; i = prefix + 1 ; } } if ( size <= 0 ) { return EMPTY_STRING ; }
if ( IOCase . SYSTEM . checkEquals ( canonicalParent , canonicalChild ) ) { return false ; MST[rv.CRCR5Mutator]MSP[S] } return IOCase . SYSTEM . checkStartsWith ( canonicalChild , canonicalParent ) ; } public static String separatorsToUnix ( final String path ) {
textIdx += wcs [ wcsIdx ] . length () ; anyChars = false ; } wcsIdx ++ ; } if ( wcsIdx == wcs . length && textIdx == fileName . length () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] return true ; } } while ( backtrack . size () > 0 );
final int pos = Math . min ( posUnix , posWin ) + 1 ; final String hostnamePart = fileName . substring ( 2 , pos - 1 ) ; return isValidHostName ( hostnamePart ) ? pos : NOT_FOUND ; MST[rv.UOI3Mutator]MSP[N] } else {
if ( containsCompressedZeroes && ( inet6Address . indexOf ( lr_9 ) != inet6Address . lastIndexOf ( lr_9 ) ) ) { return false ; } if ( ( inet6Address . startsWith ( lr_10 ) && ! inet6Address . startsWith ( lr_9 ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
return isSeparator ( ch0 ) ? 1 : 0 ; MST[ReturnValsMutator]MSP[N] } } public static int indexOfLastSeparator ( final String fileName ) { if ( fileName == null ) { return NOT_FOUND ; } final int lastUnixPos = fileName . lastIndexOf ( UNIX_SEPARATOR ) ;
if ( array [ i ] == separator && array [ i - 1 ] == separator ) { MST[rv.UOI1Mutator]MSP[N] System . arraycopy ( array , i , array , i - 1 , size - i ) ; size -- ; i -- ; } }
return wildcardMatch ( fileName , wildcardMatcher , IOCase . SYSTEM ) ; } public static boolean wildcardMatch ( final String fileName , final String wildcardMatcher , IOCase caseSensitivity ) { if ( fileName == null && wildcardMatcher == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return true ; }
textIdx = array [ 1 ] ; anyChars = true ; } while ( wcsIdx < wcs . length ) { MST[rv.ROR4Mutator]MSP[N] if ( wcs [ wcsIdx ] . equals ( lr_6 ) ) { textIdx ++ ; if ( textIdx > fileName . length () ) { break; }
for ( int i = 0 ; i < array . length ; i ++ ) { if ( array [ i ] == otherSeparator ) { MST[NegateConditionalsMutator]MSP[N] array [ i ] = separator ; } } boolean lastIsDirectory = true ;
} else if ( isSeparator ( ch0 ) && isSeparator ( ch1 ) ) { MST[NegateConditionalsMutator]MSP[N] int posUnix = fileName . indexOf ( UNIX_SEPARATOR , 2 ) ; int posWin = fileName . indexOf ( WINDOWS_SEPARATOR , 2 ) ;
final int pos = Math . min ( posUnix , posWin ) + 1 ; MST[rv.UOI2Mutator]MSP[N] final String hostnamePart = fileName . substring ( 2 , pos - 1 ) ; return isValidHostName ( hostnamePart ) ? pos : NOT_FOUND ; } else {
if ( array [ i ] == separator && array [ i - 1 ] == separator ) { System . arraycopy ( array , i , array , i - 1 , size - i ) ; MST[rv.UOI3Mutator]MSP[N] size -- ; i -- ; } }
final char ch1 = fileName . charAt ( 1 ) ; if ( ch1 == ':' ) { ch0 = Character . toUpperCase ( ch0 ) ; if ( ch0 >= 'A' && ch0 <= 'Z' ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N]
final int pos = Math . min ( posUnix , posWin ) + 1 ; MST[rv.CRCR4Mutator]MSP[N] final String hostnamePart = fileName . substring ( 2 , pos - 1 ) ; return isValidHostName ( hostnamePart ) ? pos : NOT_FOUND ; } else {
( i == prefix + 1 || array [ i - 2 ] == separator ) ) { if ( i == size - 1 ) { MST[rv.AOR4Mutator]MSP[N] lastIsDirectory = true ; }
if ( ch == '?' || ch == '*' ) { MST[rv.UOI4Mutator]MSP[N] if ( buffer . length () != 0 ) { list . add ( buffer . toString () ) ; buffer . setLength ( 0 ) ; } if ( ch == '?' ) {
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND ) { MST[rv.CRCR4Mutator]MSP[N] return len + 1 ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ; return Math . min ( posUnix , posWin ) + 1 ; }
final int pos = Math . min ( posUnix , posWin ) + 1 ; final String hostnamePart = fileName . substring ( 2 , pos - 1 ) ; MST[rv.CRCR6Mutator]MSP[N] return isValidHostName ( hostnamePart ) ? pos : NOT_FOUND ; } else {
if ( i == prefix + 2 ) { return null ; } if ( i == size - 1 ) { MST[rv.CRCR2Mutator]MSP[S] lastIsDirectory = true ; } int j ; for ( j = i - 4 ; j >= prefix ; j -- ) {
if ( array [ i ] == separator && array [ i - 1 ] == separator ) { System . arraycopy ( array , i , array , i - 1 , size - i ) ; MST[rv.UOI4Mutator]MSP[N] size -- ; i -- ; } }
if ( ch == '?' || ch == '*' ) { MST[rv.UOI3Mutator]MSP[N] if ( buffer . length () != 0 ) { list . add ( buffer . toString () ) ; buffer . setLength ( 0 ) ; } if ( ch == '?' ) {
if ( len == 0 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return 0 ; } char ch0 = fileName . charAt ( 0 ) ; if ( ch0 == ':' ) { return NOT_FOUND ; } if ( len == 1 ) { if ( ch0 == '~' ) { return 2 ; }
String fileName1 , String fileName2 , final boolean normalized , IOCase caseSensitivity ) { if ( fileName1 == null || fileName2 == null ) { return fileName1 == null && fileName2 == null ; MST[rv.ROR5Mutator]MSP[N] } if ( normalized ) { fileName1 = normalize ( fileName1 ) ;
if ( ch == '?' || ch == '*' ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] if ( buffer . length () != 0 ) { list . add ( buffer . toString () ) ; buffer . setLength ( 0 ) ; } if ( ch == '?' ) {
if ( prefix > 0 ) { return normalize ( fullFileNameToAdd ) ; } if ( basePath == null ) { return null ; } final int len = basePath . length () ; if ( len == 0 ) { MST[rv.UOI4Mutator]MSP[N] return normalize ( fullFileNameToAdd ) ; }
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND ) { return len + 1 ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; MST[rv.UOI1Mutator]MSP[N] posWin = posWin == NOT_FOUND ? posUnix : posWin ; return Math . min ( posUnix , posWin ) + 1 ; }
if ( ipSegment . length () > 1 && ipSegment . startsWith ( lr_8 ) ) { return false ; } } return true ; MST[rv.CRCR6Mutator]MSP[S] } private static boolean isIPv6Address ( final String inet6Address ) { final boolean containsCompressedZeroes = inet6Address . contains ( lr_9 ) ;
if ( array [ i ] == separator && array [ i - 1 ] == separator ) { MST[rv.ABSMutator]MSP[N] System . arraycopy ( array , i , array , i - 1 , size - i ) ; size -- ; i -- ; } }
textIdx += wcs [ wcsIdx ] . length () ; anyChars = false ; } wcsIdx ++ ; } if ( wcsIdx == wcs . length && textIdx == fileName . length () ) { MST[rv.ABSMutator]MSP[N] return true ; } } while ( backtrack . size () > 0 );
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND ) { return len + 1 ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; MST[rv.UOI2Mutator]MSP[N] posWin = posWin == NOT_FOUND ? posUnix : posWin ; return Math . min ( posUnix , posWin ) + 1 ; }
System . arraycopy ( array , i + 1 , array , prefix , size - i ) ; size -= i + 1 - prefix ; MST[rv.UOI4Mutator]MSP[N] i = prefix + 1 ; } } if ( size <= 0 ) { return EMPTY_STRING ; }
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND ) { MST[rv.ROR3Mutator]MSP[N] return len + 1 ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ; return Math . min ( posUnix , posWin ) + 1 ; }
if ( size <= prefix ) { return new String ( array , 0 , size ) ; } if ( lastIsDirectory && keepSeparator ) { MST[rv.ROR1Mutator]MSP[N] return new String ( array , 0 , size ) ; }
return false ; MST[rv.CRCR1Mutator]MSP[N] } static String [] splitOnTokens ( final String text ) { if ( text . indexOf ( '?' ) == NOT_FOUND && text . indexOf ( '*' ) == NOT_FOUND ) { return new String [] { text } ; }
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND ) { return len + 1 ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ; MST[rv.CRCR1Mutator]MSP[N] return Math . min ( posUnix , posWin ) + 1 ; }
anyChars = false ; } else if ( wcs [ wcsIdx ] . equals ( lr_7 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] anyChars = true ; if ( wcsIdx == wcs . length - 1 ) { textIdx = fileName . length () ; } } else { if ( anyChars ) {
final int prefix = getPrefixLength ( fileName ) ; if ( prefix < 0 ) { return null ; } if ( prefix >= fileName . length () ) { if ( includeSeparator ) { MST[NegateConditionalsMutator]MSP[N] return getPrefix ( fileName ) ; } return fileName ; }
if ( array [ size - 1 ] != separator ) { array [ size ++ ] = separator ; lastIsDirectory = false ; } for ( int i = prefix + 1 ; i < size ; i ++ ) { MST[rv.ABSMutator]MSP[N]
failIfNullBytePresent ( path ) ; return path ; } public static String getPath ( final String fileName ) { return doGetPath ( fileName , 1 ) ; } public static String getPathNoEndSeparator ( final String fileName ) { return doGetPath ( fileName , 0 ) ; MST[rv.CRCR1Mutator]MSP[S] }
if ( octet . length () == 0 ) { emptyOctets ++ ; if ( emptyOctets > 1 ) { return false ; } } else { emptyOctets = 0 ; if ( index == octets . length - 1 && octet . contains ( lr_12 ) ) { MST[rv.AOD1Mutator]MSP[S]
if ( len == 0 ) { MST[rv.ROR1Mutator]MSP[N] return 0 ; } char ch0 = fileName . charAt ( 0 ) ; if ( ch0 == ':' ) { return NOT_FOUND ; } if ( len == 1 ) { if ( ch0 == '~' ) { return 2 ; }
for ( int i = 0 ; i < parts . length ; i ++ ) { if ( parts [ i ] . length () == 0 ) { return i == parts . length - 1 ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] }
if ( array [ i ] == separator && array [ i - 1 ] == separator ) { MST[rv.AOR3Mutator]MSP[N] System . arraycopy ( array , i , array , i - 1 , size - i ) ; size -- ; i -- ; } }
textIdx += wcs [ wcsIdx ] . length () ; anyChars = false ; } wcsIdx ++ ; } if ( wcsIdx == wcs . length && textIdx == fileName . length () ) { return true ; MST[InlineConstantMutator]MSP[N] } } while ( backtrack . size () > 0 );
final int index = indexOfLastSeparator ( fileName ) ; if ( index < 0 ) { return fileName . substring ( 0 , prefix ) ; MST[experimental.NakedReceiverMutator]MSP[N] } int end = index + ( includeSeparator ? 1 : 0 ) ; if ( end == 0 ) { end ++ ;
public static boolean isExtension ( final String fileName , final String ... extensions ) { if ( fileName == null ) { return false ; MST[InlineConstantMutator]MSP[N] } failIfNullBytePresent ( fileName ) ; if ( extensions == null || extensions . length == 0 ) {
textIdx += wcs [ wcsIdx ] . length () ; MST[rv.ABSMutator]MSP[N] anyChars = false ; } wcsIdx ++ ; } if ( wcsIdx == wcs . length && textIdx == fileName . length () ) { return true ; } } while ( backtrack . size () > 0 );
} else if ( isSeparator ( ch0 ) && isSeparator ( ch1 ) ) { int posUnix = fileName . indexOf ( UNIX_SEPARATOR , 2 ) ; int posWin = fileName . indexOf ( WINDOWS_SEPARATOR , 2 ) ; MST[rv.CRCR5Mutator]MSP[N]
if ( len < 0 ) { return null ; } if ( len > fileName . length () ) { failIfNullBytePresent ( fileName + UNIX_SEPARATOR ) ; MST[rv.CRCR1Mutator]MSP[N] return fileName + UNIX_SEPARATOR ; } final String path = fileName . substring ( 0 , len ) ;
if ( containsCompressedZeroes && ( inet6Address . indexOf ( lr_9 ) != inet6Address . lastIndexOf ( lr_9 ) ) ) { MST[rv.ROR5Mutator]MSP[N] return false ; } if ( ( inet6Address . startsWith ( lr_10 ) && ! inet6Address . startsWith ( lr_9 ) )
final char [] array = text . toCharArray () ; final ArrayList < String > list = new ArrayList <> () ; final StringBuilder buffer = new StringBuilder () ; char prevChar = 0 ; for ( final char ch : array ) { MST[rv.UOI3Mutator]MSP[N]
return caseSensitivity . checkEquals ( fileName1 , fileName2 ) ; MST[BooleanTrueReturnValsMutator]MSP[N] } public static boolean isExtension ( final String fileName , final String extension ) { if ( fileName == null ) { return false ; } failIfNullBytePresent ( fileName ) ;
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return len + 1 ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ; return Math . min ( posUnix , posWin ) + 1 ; }
if ( fileName == null || wildcardMatcher == null ) { return false ; } if ( caseSensitivity == null ) { caseSensitivity = IOCase . SENSITIVE ; } final String [] wcs = splitOnTokens ( wildcardMatcher ) ; boolean anyChars = false ; MST[rv.CRCR5Mutator]MSP[S] int textIdx = 0 ;
return isSeparator ( ch0 ) ? 1 : 0 ; } } public static int indexOfLastSeparator ( final String fileName ) { if ( fileName == null ) { return NOT_FOUND ; } final int lastUnixPos = fileName . lastIndexOf ( UNIX_SEPARATOR ) ; MST[ArgumentPropagationMutator]MSP[N]
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND ) { MST[rv.CRCR6Mutator]MSP[N] return len + 1 ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ; return Math . min ( posUnix , posWin ) + 1 ; }
if ( i == prefix + 2 ) { return null ; } if ( i == size - 1 ) { MST[rv.CRCR5Mutator]MSP[S] lastIsDirectory = true ; } int j ; for ( j = i - 4 ; j >= prefix ; j -- ) {
if ( array [ j ] == separator ) { System . arraycopy ( array , i + 1 , array , j + 1 , size - i ) ; MST[rv.UOI2Mutator]MSP[N] size -= i - j ; i = j + 1 ; continue outer; } }
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND ) { return len + 1 ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ; MST[rv.UOI2Mutator]MSP[N] return Math . min ( posUnix , posWin ) + 1 ; }
return indexOfExtension ( fileName ) == NOT_FOUND ; } final String fileExt = getExtension ( fileName ) ; for ( final String extension : extensions ) { if ( fileExt . equals ( extension ) ) { return true ; MST[rv.CRCR4Mutator]MSP[N] } } return false ; }
if ( octet . length () == 0 ) { emptyOctets ++ ; if ( emptyOctets > 1 ) { MST[rv.CRCR6Mutator]MSP[N] return false ; } } else { emptyOctets = 0 ; if ( index == octets . length - 1 && octet . contains ( lr_12 ) ) {
for ( int i = prefix + 1 ; i < size ; i ++ ) { if ( array [ i ] == separator && array [ i - 1 ] == '.' && MST[rv.AOD1Mutator]MSP[N]
if ( octet . length () == 0 ) { emptyOctets ++ ; if ( emptyOctets > 1 ) { MST[rv.ROR3Mutator]MSP[N] return false ; } } else { emptyOctets = 0 ; if ( index == octets . length - 1 && octet . contains ( lr_12 ) ) {
if ( array [ size - 1 ] != separator ) { MST[rv.UOI1Mutator]MSP[N] array [ size ++ ] = separator ; lastIsDirectory = false ; } for ( int i = prefix + 1 ; i < size ; i ++ ) {
anyChars = false ; MST[rv.CRCR1Mutator]MSP[S] } else if ( wcs [ wcsIdx ] . equals ( lr_7 ) ) { anyChars = true ; if ( wcsIdx == wcs . length - 1 ) { textIdx = fileName . length () ; } } else { if ( anyChars ) {
final char [] array = new char [ size + 2 ] ; MST[rv.UOI3Mutator]MSP[N] fileName . getChars ( 0 , fileName . length () , array , 0 ) ; final char otherSeparator = separator == SYSTEM_SEPARATOR ? OTHER_SEPARATOR : SYSTEM_SEPARATOR ;
if ( len == 2 || isSeparator ( fileName . charAt ( 2 ) ) == false ) { MST[rv.ROR5Mutator]MSP[N] return 2 ; } return 3 ; } else if ( ch0 == UNIX_SEPARATOR ) { return 1 ; } return NOT_FOUND ;
if ( validOctets > IPV6_MAX_HEX_GROUPS || ( validOctets < IPV6_MAX_HEX_GROUPS && ! containsCompressedZeroes ) ) { return false ; MST[rv.CRCR5Mutator]MSP[S] } return true ; } private static boolean isRFC3986HostName ( final String name ) { final String [] parts = name . split ( lr_13 , - 1 ) ;
if ( path == null || path . indexOf ( WINDOWS_SEPARATOR ) == NOT_FOUND ) { MST[rv.ROR2Mutator]MSP[N] return path ; } return path . replace ( WINDOWS_SEPARATOR , UNIX_SEPARATOR ) ; } public static String separatorsToWindows ( final String path ) {
return equals ( fileName1 , fileName2 , true , IOCase . SENSITIVE ) ; } public static boolean equalsNormalizedOnSystem ( final String fileName1 , final String fileName2 ) { return equals ( fileName1 , fileName2 , true , IOCase . SYSTEM ) ; MST[rv.CRCR2Mutator]MSP[S] } public static boolean equals (
for ( int i = 0 ; i < array . length ; i ++ ) { if ( array [ i ] == otherSeparator ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] array [ i ] = separator ; } } boolean lastIsDirectory = true ;
final int index = indexOfLastSeparator ( fileName ) ; if ( index < 0 ) { return fileName . substring ( 0 , prefix ) ; } int end = index + ( includeSeparator ? 1 : 0 ) ; MST[rv.CRCR4Mutator]MSP[S] if ( end == 0 ) { end ++ ;
for ( int i = 1 ; i <= 4 ; i ++ ) { MST[rv.CRCR4Mutator]MSP[N] final String ipSegment = m . group ( i ) ; final int iIpSegment = Integer . parseInt ( ipSegment ) ; if ( iIpSegment > IPV4_MAX_OCTET_VALUE ) { return false ; }
if ( array [ i ] == separator && array [ i - 1 ] == '.' && array [ i - 2 ] == '.' && MST[rv.CRCR5Mutator]MSP[N] ( i == prefix + 2 || array [ i - 3 ] == separator ) ) {
static boolean isSystemWindows () { return SYSTEM_SEPARATOR == WINDOWS_SEPARATOR ; MST[ReturnValsMutator]MSP[N] } private static boolean isSeparator ( final char ch ) { return ch == UNIX_SEPARATOR || ch == WINDOWS_SEPARATOR ; } public static String normalize ( final String fileName ) {
String fileName1 , String fileName2 , final boolean normalized , IOCase caseSensitivity ) { if ( fileName1 == null || fileName2 == null ) { return fileName1 == null && fileName2 == null ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } if ( normalized ) { fileName1 = normalize ( fileName1 ) ;
if ( octets . length > IPV6_MAX_HEX_GROUPS ) { return false ; } int validOctets = 0 ; int emptyOctets = 0 ; for ( int index = 0 ; index < octets . length ; index ++ ) { MST[IncrementsMutator]MSP[N] final String octet = octets [ index ] ;
return new String ( array , 0 , size - 1 ) ; MST[ConstructorCallMutator]MSP[N] } public static String concat ( final String basePath , final String fullFileNameToAdd ) { final int prefix = getPrefixLength ( fullFileNameToAdd ) ; if ( prefix < 0 ) { return null ; }
if ( array [ j ] == separator ) { System . arraycopy ( array , i + 1 , array , j + 1 , size - i ) ; size -= i - j ; i = j + 1 ; MST[rv.CRCR2Mutator]MSP[N] continue outer; } }
} return fileName . substring ( 0 , end ) ; MST[rv.CRCR5Mutator]MSP[N] } public static String getName ( final String fileName ) { if ( fileName == null ) { return null ; } failIfNullBytePresent ( fileName ) ; final int index = indexOfLastSeparator ( fileName ) ;
for ( int i = prefix + 1 ; i < size ; i ++ ) { if ( array [ i ] == separator && array [ i - 1 ] == '.' && MST[rv.UOI4Mutator]MSP[N]
final int lastSeparator = indexOfLastSeparator ( fileName ) ; return lastSeparator > extensionPos ? NOT_FOUND : extensionPos ; MST[rv.UOI3Mutator]MSP[N] } public static String getPrefix ( final String fileName ) { if ( fileName == null ) { return null ; } final int len = getPrefixLength ( fileName ) ;
if ( index == NOT_FOUND ) { return fileName ; } return fileName . substring ( 0 , index ) ; MST[rv.UOI2Mutator]MSP[N] } public static boolean equals ( final String fileName1 , final String fileName2 ) { return equals ( fileName1 , fileName2 , false , IOCase . SENSITIVE ) ;
return indexOfExtension ( fileName ) == NOT_FOUND ; MST[rv.CRCR5Mutator]MSP[N] } final String fileExt = getExtension ( fileName ) ; for ( final String extension : extensions ) { if ( fileExt . equals ( extension ) ) { return true ; } } return false ; }
static boolean isSystemWindows () { return SYSTEM_SEPARATOR == WINDOWS_SEPARATOR ; } private static boolean isSeparator ( final char ch ) { return ch == UNIX_SEPARATOR || ch == WINDOWS_SEPARATOR ; MST[rv.ROR1Mutator]MSP[N] } public static String normalize ( final String fileName ) {
final int index = indexOfLastSeparator ( fileName ) ; final int endIndex = index + separatorAdd ; if ( prefix >= fileName . length () || index < 0 || prefix >= endIndex ) { MST[ConditionalsBoundaryMutator]MSP[N] return EMPTY_STRING ; }
for ( int i = 1 ; i <= 4 ; i ++ ) { final String ipSegment = m . group ( i ) ; final int iIpSegment = Integer . parseInt ( ipSegment ) ; if ( iIpSegment > IPV4_MAX_OCTET_VALUE ) { MST[rv.UOI4Mutator]MSP[N] return false ; }
if ( array [ i ] == separator && array [ i - 1 ] == '.' && array [ i - 2 ] == '.' && MST[rv.UOI1Mutator]MSP[N] ( i == prefix + 2 || array [ i - 3 ] == separator ) ) {
for ( int i = prefix + 1 ; i < size ; i ++ ) { if ( array [ i ] == separator && array [ i - 1 ] == '.' && MST[rv.ROR5Mutator]MSP[N]
return doNormalize ( fileName , SYSTEM_SEPARATOR , true ) ; } public static String normalize ( final String fileName , final boolean unixSeparator ) { final char separator = unixSeparator ? UNIX_SEPARATOR : WINDOWS_SEPARATOR ; return doNormalize ( fileName , separator , true ) ; MST[rv.CRCR5Mutator]MSP[S] }
final int lastSeparator = indexOfLastSeparator ( fileName ) ; return lastSeparator > extensionPos ? NOT_FOUND : extensionPos ; MST[rv.ROR4Mutator]MSP[N] } public static String getPrefix ( final String fileName ) { if ( fileName == null ) { return null ; } final int len = getPrefixLength ( fileName ) ;
final int index = indexOfLastSeparator ( fileName ) ; if ( index < 0 ) { return fileName . substring ( 0 , prefix ) ; } int end = index + ( includeSeparator ? 1 : 0 ) ; if ( end == 0 ) { MST[rv.UOI1Mutator]MSP[N] end ++ ;
if ( array [ j ] == separator ) { System . arraycopy ( array , i + 1 , array , j + 1 , size - i ) ; MST[rv.AOR3Mutator]MSP[N] size -= i - j ; i = j + 1 ; continue outer; } }
for ( int i = prefix + 1 ; i < size ; i ++ ) { MST[rv.AOD1Mutator]MSP[S] if ( array [ i ] == separator && array [ i - 1 ] == '.' &&
if ( array [ i ] == separator && array [ i - 1 ] == '.' && array [ i - 2 ] == '.' && MST[rv.ROR3Mutator]MSP[N] ( i == prefix + 2 || array [ i - 3 ] == separator ) ) {
if ( array [ i ] == separator && array [ i - 1 ] == separator ) { System . arraycopy ( array , i , array , i - 1 , size - i ) ; MST[rv.AOR2Mutator]MSP[N] size -- ; i -- ; } }
if ( path == null || path . indexOf ( WINDOWS_SEPARATOR ) == NOT_FOUND ) { MST[rv.CRCR5Mutator]MSP[N] return path ; } return path . replace ( WINDOWS_SEPARATOR , UNIX_SEPARATOR ) ; } public static String separatorsToWindows ( final String path ) {
if ( ch == '?' || ch == '*' ) { if ( buffer . length () != 0 ) { list . add ( buffer . toString () ) ; buffer . setLength ( 0 ) ; } if ( ch == '?' ) { MST[rv.CRCR2Mutator]MSP[N]
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2 ) { return NOT_FOUND ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ; MST[rv.UOI1Mutator]MSP[N]
return fileName . substring ( index + 1 ) ; MST[rv.AOR3Mutator]MSP[N] } private static int getAdsCriticalOffset ( final String fileName ) { final int offset1 = fileName . lastIndexOf ( SYSTEM_SEPARATOR ) ; final int offset2 = fileName . lastIndexOf ( OTHER_SEPARATOR ) ;
public static boolean isExtension ( final String fileName , final Collection < String > extensions ) { if ( fileName == null ) { return false ; } failIfNullBytePresent ( fileName ) ; if ( extensions == null || extensions . isEmpty () ) { MST[rv.ROR5Mutator]MSP[N]
if ( ch == '?' || ch == '*' ) { if ( buffer . length () != 0 ) { list . add ( buffer . toString () ) ; buffer . setLength ( 0 ) ; } if ( ch == '?' ) { MST[rv.ROR2Mutator]MSP[N]
final int pos = Math . min ( posUnix , posWin ) + 1 ; final String hostnamePart = fileName . substring ( 2 , pos - 1 ) ; MST[rv.AOR4Mutator]MSP[N] return isValidHostName ( hostnamePart ) ? pos : NOT_FOUND ; } else {
String fileName1 , String fileName2 , final boolean normalized , IOCase caseSensitivity ) { if ( fileName1 == null || fileName2 == null ) { return fileName1 == null && fileName2 == null ; } if ( normalized ) { MST[NegateConditionalsMutator]MSP[N] fileName1 = normalize ( fileName1 ) ;
if ( containsCompressedZeroes && ( inet6Address . indexOf ( lr_9 ) != inet6Address . lastIndexOf ( lr_9 ) ) ) { MST[NonVoidMethodCallMutator]MSP[S] return false ; } if ( ( inet6Address . startsWith ( lr_10 ) && ! inet6Address . startsWith ( lr_9 ) )
if ( i == prefix + 2 ) { MST[rv.ROR4Mutator]MSP[N] return null ; } if ( i == size - 1 ) { lastIsDirectory = true ; } int j ; for ( j = i - 4 ; j >= prefix ; j -- ) {
anyChars = false ; } else if ( wcs [ wcsIdx ] . equals ( lr_7 ) ) { anyChars = true ; if ( wcsIdx == wcs . length - 1 ) { textIdx = fileName . length () ; } } else { if ( anyChars ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
public static boolean directoryContains ( final String canonicalParent , final String canonicalChild ) throws IOException { if ( canonicalParent == null ) { MST[NegateConditionalsMutator]MSP[N] throw new IllegalArgumentException ( lr_1 ) ; } if ( canonicalChild == null ) { return false ; }
if ( len == 0 ) { return 0 ; } char ch0 = fileName . charAt ( 0 ) ; if ( ch0 == ':' ) { return NOT_FOUND ; } if ( len == 1 ) { if ( ch0 == '~' ) { MST[rv.CRCR3Mutator]MSP[N] return 2 ; }
return indexOfExtension ( fileName ) == NOT_FOUND ; } final String fileExt = getExtension ( fileName ) ; for ( final String extension : extensions ) { if ( fileExt . equals ( extension ) ) { return true ; } } return false ; MST[rv.CRCR1Mutator]MSP[N] }
list . add ( lr_6 ) ; } else if ( prevChar != '*' ) { MST[rv.ABSMutator]MSP[S] list . add ( lr_7 ) ; } } else { buffer . append ( ch ) ; } prevChar = ch ; } if ( buffer . length () != 0 ) {
if ( octet . length () == 0 ) { emptyOctets ++ ; if ( emptyOctets > 1 ) { return false ; } } else { emptyOctets = 0 ; if ( index == octets . length - 1 && octet . contains ( lr_12 ) ) { MST[rv.ROR3Mutator]MSP[N]
System . arraycopy ( array , i + 1 , array , prefix , size - i ) ; MST[rv.UOI2Mutator]MSP[N] size -= i + 1 - prefix ; i = prefix + 1 ; } } if ( size <= 0 ) { return EMPTY_STRING ; }
if ( array [ i ] == separator && array [ i - 1 ] == '.' && array [ i - 2 ] == '.' && MST[rv.CRCR6Mutator]MSP[N] ( i == prefix + 2 || array [ i - 3 ] == separator ) ) {
final char ch1 = fileName . charAt ( 1 ) ; if ( ch1 == ':' ) { ch0 = Character . toUpperCase ( ch0 ) ; if ( ch0 >= 'A' && ch0 <= 'Z' ) { MST[rv.UOI2Mutator]MSP[N]
System . arraycopy ( array , i + 1 , array , i - 1 , size - i ) ; size -= 2 ; i -- ; } } outer: for ( int i = prefix + 2 ; i < size ; i ++ ) { MST[rv.UOI1Mutator]MSP[N]
System . arraycopy ( array , i + 1 , array , prefix , size - i ) ; size -= i + 1 - prefix ; MST[rv.AOD1Mutator]MSP[N] i = prefix + 1 ; } } if ( size <= 0 ) { return EMPTY_STRING ; }
final int index = indexOfLastSeparator ( fileName ) ; final int endIndex = index + separatorAdd ; if ( prefix >= fileName . length () || index < 0 || prefix >= endIndex ) { MST[rv.UOI2Mutator]MSP[N] return EMPTY_STRING ; }
System . arraycopy ( array , i + 1 , array , i - 1 , size - i ) ; size -= 2 ; i -- ; } } outer: for ( int i = prefix + 2 ; i < size ; i ++ ) { MST[rv.AOR2Mutator]MSP[N]
return Math . max ( offset1 , offset2 ) + 1 ; } public static String removeExtension ( final String fileName ) { if ( fileName == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] return null ; } failIfNullBytePresent ( fileName ) ; final int index = indexOfExtension ( fileName ) ;
public static String getFullPathNoEndSeparator ( final String fileName ) { return doGetFullPath ( fileName , false ) ; MST[ArgumentPropagationMutator]MSP[N] } private static String doGetFullPath ( final String fileName , final boolean includeSeparator ) { if ( fileName == null ) { return null ; }
static boolean isSystemWindows () { return SYSTEM_SEPARATOR == WINDOWS_SEPARATOR ; } private static boolean isSeparator ( final char ch ) { return ch == UNIX_SEPARATOR || ch == WINDOWS_SEPARATOR ; MST[rv.CRCR1Mutator]MSP[N] } public static String normalize ( final String fileName ) {
if ( size <= prefix ) { return new String ( array , 0 , size ) ; MST[rv.CRCR1Mutator]MSP[N] } if ( lastIsDirectory && keepSeparator ) { return new String ( array , 0 , size ) ; }
list . add ( buffer . toString () ) ; } return list . toArray ( new String [ list . size () ] ) ; } private static boolean isValidHostName ( final String name ) { return isIPv6Address ( name ) || isRFC3986HostName ( name ) ; MST[rv.CRCR2Mutator]MSP[N] }
} public static boolean equalsOnSystem ( final String fileName1 , final String fileName2 ) { return equals ( fileName1 , fileName2 , false , IOCase . SYSTEM ) ; MST[ReturnValsMutator]MSP[N] } public static boolean equalsNormalized ( final String fileName1 , final String fileName2 ) {
if ( array [ i ] == separator && array [ i - 1 ] == separator ) { MST[rv.ROR5Mutator]MSP[N] System . arraycopy ( array , i , array , i - 1 , size - i ) ; size -- ; i -- ; } }
if ( array [ i ] == separator && array [ i - 1 ] == '.' && array [ i - 2 ] == '.' && MST[rv.AOR2Mutator]MSP[N] ( i == prefix + 2 || array [ i - 3 ] == separator ) ) {
} else if ( inet6Address . startsWith ( lr_9 ) && ! octetList . isEmpty () ) { octetList . remove ( 0 ) ; MST[rv.CRCR3Mutator]MSP[N] } octets = octetList . toArray ( new String [ octetList . size () ] ) ; }
return null ; } return isSystemWindows () ? separatorsToWindows ( path ) : separatorsToUnix ( path ) ; MST[NegateConditionalsMutator]MSP[N] } public static int getPrefixLength ( final String fileName ) { if ( fileName == null ) { return NOT_FOUND ; } final int len = fileName . length () ;
return doNormalize ( fileName , SYSTEM_SEPARATOR , true ) ; } public static String normalize ( final String fileName , final boolean unixSeparator ) { final char separator = unixSeparator ? UNIX_SEPARATOR : WINDOWS_SEPARATOR ; MST[rv.ABSMutator]MSP[S] return doNormalize ( fileName , separator , true ) ; }
} else if ( isSeparator ( ch0 ) && isSeparator ( ch1 ) ) { int posUnix = fileName . indexOf ( UNIX_SEPARATOR , 2 ) ; MST[rv.CRCR3Mutator]MSP[N] int posWin = fileName . indexOf ( WINDOWS_SEPARATOR , 2 ) ;
return caseSensitivity . checkEquals ( fileName1 , fileName2 ) ; } public static boolean isExtension ( final String fileName , final String extension ) { if ( fileName == null ) { return false ; MST[InlineConstantMutator]MSP[S] } failIfNullBytePresent ( fileName ) ;
return null ; } return isSystemWindows () ? separatorsToWindows ( path ) : separatorsToUnix ( path ) ; MST[rv.ROR4Mutator]MSP[N] } public static int getPrefixLength ( final String fileName ) { if ( fileName == null ) { return NOT_FOUND ; } final int len = fileName . length () ;
return indexOfExtension ( fileName ) == NOT_FOUND ; } final String fileExt = getExtension ( fileName ) ; for ( final String extension : extensions ) { MST[rv.ABSMutator]MSP[N] if ( fileExt . equals ( extension ) ) { return true ; } } return false ; }
return fileName . substring ( index + 1 ) ; MST[rv.UOI2Mutator]MSP[N] } private static int getAdsCriticalOffset ( final String fileName ) { final int offset1 = fileName . lastIndexOf ( SYSTEM_SEPARATOR ) ; final int offset2 = fileName . lastIndexOf ( OTHER_SEPARATOR ) ;
if ( len == 0 ) { return 0 ; } char ch0 = fileName . charAt ( 0 ) ; if ( ch0 == ':' ) { return NOT_FOUND ; MST[rv.CRCR5Mutator]MSP[N] } if ( len == 1 ) { if ( ch0 == '~' ) { return 2 ; }
System . arraycopy ( array , i + 1 , array , prefix , size - i ) ; size -= i + 1 - prefix ; i = prefix + 1 ; MST[rv.CRCR3Mutator]MSP[N] } } if ( size <= 0 ) { return EMPTY_STRING ; }
int wcsIdx = 0 ; final Stack < int [] > backtrack = new Stack <> () ; do { if ( backtrack . size () > 0 ) { final int [] array = backtrack . pop () ; wcsIdx = array [ 0 ] ; MST[rv.UOI3Mutator]MSP[N]
if ( extension == null || extension . isEmpty () ) { return indexOfExtension ( fileName ) == NOT_FOUND ; MST[rv.CRCR1Mutator]MSP[S] } final String fileExt = getExtension ( fileName ) ; return fileExt . equals ( extension ) ; }
final char ch = basePath . charAt ( len - 1 ) ; if ( isSeparator ( ch ) ) { return normalize ( basePath + fullFileNameToAdd ) ; } return normalize ( basePath + '/' + fullFileNameToAdd ) ; MST[rv.CRCR4Mutator]MSP[N] }
return null ; } return isSystemWindows () ? separatorsToWindows ( path ) : separatorsToUnix ( path ) ; MST[ArgumentPropagationMutator]MSP[S] } public static int getPrefixLength ( final String fileName ) { if ( fileName == null ) { return NOT_FOUND ; } final int len = fileName . length () ;
public static String getExtension ( final String fileName ) throws IllegalArgumentException { if ( fileName == null ) { return null ; } final int index = indexOfExtension ( fileName ) ; if ( index == NOT_FOUND ) { MST[rv.UOI4Mutator]MSP[N] return EMPTY_STRING ; }
if ( containsCompressedZeroes && ( inet6Address . indexOf ( lr_9 ) != inet6Address . lastIndexOf ( lr_9 ) ) ) { return false ; } if ( ( inet6Address . startsWith ( lr_10 ) && ! inet6Address . startsWith ( lr_9 ) ) MST[rv.ROR3Mutator]MSP[S]
System . arraycopy ( array , i + 1 , array , i - 1 , size - i ) ; MST[rv.UOI1Mutator]MSP[N] size -= 2 ; i -- ; } } outer: for ( int i = prefix + 2 ; i < size ; i ++ ) {
return new String ( array , 0 , size - 1 ) ; MST[rv.AOR4Mutator]MSP[N] } public static String concat ( final String basePath , final String fullFileNameToAdd ) { final int prefix = getPrefixLength ( fullFileNameToAdd ) ; if ( prefix < 0 ) { return null ; }
return fileName . substring ( index + 1 ) ; MST[rv.CRCR3Mutator]MSP[S] } private static void failIfNullBytePresent ( final String path ) { final int len = path . length () ; for ( int i = 0 ; i < len ; i ++ ) {
if ( len == 0 ) { return 0 ; } char ch0 = fileName . charAt ( 0 ) ; if ( ch0 == ':' ) { return NOT_FOUND ; MST[ReturnValsMutator]MSP[N] } if ( len == 1 ) { if ( ch0 == '~' ) { return 2 ; }
anyChars = false ; } else if ( wcs [ wcsIdx ] . equals ( lr_7 ) ) { anyChars = true ; MST[rv.CRCR6Mutator]MSP[N] if ( wcsIdx == wcs . length - 1 ) { textIdx = fileName . length () ; } } else { if ( anyChars ) {
if ( prefix > 0 ) { return normalize ( fullFileNameToAdd ) ; } if ( basePath == null ) { return null ; } final int len = basePath . length () ; if ( len == 0 ) { MST[rv.ROR2Mutator]MSP[N] return normalize ( fullFileNameToAdd ) ; }
if ( size <= prefix ) { return new String ( array , 0 , size ) ; } if ( lastIsDirectory && keepSeparator ) { MST[rv.UOI3Mutator]MSP[N] return new String ( array , 0 , size ) ; }
final int index = indexOfLastSeparator ( fileName ) ; final int endIndex = index + separatorAdd ; if ( prefix >= fileName . length () || index < 0 || prefix >= endIndex ) { MST[rv.UOI1Mutator]MSP[N] return EMPTY_STRING ; }
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND ) { MST[rv.ROR4Mutator]MSP[N] return len + 1 ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ; return Math . min ( posUnix , posWin ) + 1 ; }
octetInt = Integer . parseInt ( octet , BASE_16 ) ; } catch ( final NumberFormatException e ) { return false ; } if ( octetInt < 0 || octetInt > MAX_UNSIGNED_SHORT ) { MST[rv.ABSMutator]MSP[N] return false ; } } validOctets ++ ; }
if ( array [ size - 1 ] != separator ) { array [ size ++ ] = separator ; lastIsDirectory = false ; } for ( int i = prefix + 1 ; i < size ; i ++ ) { MST[rv.AOR3Mutator]MSP[S]
return fileName . substring ( index + 1 ) ; MST[MathMutator]MSP[S] } private static void failIfNullBytePresent ( final String path ) { final int len = path . length () ; for ( int i = 0 ; i < len ; i ++ ) {
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND ) { return len + 1 ; MST[rv.AOR3Mutator]MSP[N] } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ; return Math . min ( posUnix , posWin ) + 1 ; }
final char ch1 = fileName . charAt ( 1 ) ; if ( ch1 == ':' ) { ch0 = Character . toUpperCase ( ch0 ) ; if ( ch0 >= 'A' && ch0 <= 'Z' ) { MST[InlineConstantMutator]MSP[N]
if ( len == 2 || isSeparator ( fileName . charAt ( 2 ) ) == false ) { return 2 ; } return 3 ; } else if ( ch0 == UNIX_SEPARATOR ) { return 1 ; MST[rv.CRCR2Mutator]MSP[S] } return NOT_FOUND ;
if ( path == null || path . indexOf ( UNIX_SEPARATOR ) == NOT_FOUND ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return path ; } return path . replace ( UNIX_SEPARATOR , WINDOWS_SEPARATOR ) ; } public static String separatorsToSystem ( final String path ) { if ( path == null ) {
System . arraycopy ( array , i + 1 , array , prefix , size - i ) ; size -= i + 1 - prefix ; i = prefix + 1 ; MST[MathMutator]MSP[N] } } if ( size <= 0 ) { return EMPTY_STRING ; }
if ( extension == null || extension . isEmpty () ) { return indexOfExtension ( fileName ) == NOT_FOUND ; } final String fileExt = getExtension ( fileName ) ; return fileExt . equals ( extension ) ; MST[ReturnValsMutator]MSP[N] }
if ( i == prefix + 2 ) { return null ; } if ( i == size - 1 ) { lastIsDirectory = true ; } int j ; for ( j = i - 4 ; j >= prefix ; j -- ) { MST[rv.ROR2Mutator]MSP[N]
if ( len == 0 ) { MST[rv.UOI3Mutator]MSP[N] return 0 ; } char ch0 = fileName . charAt ( 0 ) ; if ( ch0 == ':' ) { return NOT_FOUND ; } if ( len == 1 ) { if ( ch0 == '~' ) { return 2 ; }
if ( array [ size - 1 ] != separator ) { MST[rv.AOR2Mutator]MSP[N] array [ size ++ ] = separator ; lastIsDirectory = false ; } for ( int i = prefix + 1 ; i < size ; i ++ ) {
if ( array [ j ] == separator ) { System . arraycopy ( array , i + 1 , array , j + 1 , size - i ) ; MST[rv.ABSMutator]MSP[N] size -= i - j ; i = j + 1 ; continue outer; } }
final char [] array = new char [ size + 2 ] ; fileName . getChars ( 0 , fileName . length () , array , 0 ) ; MST[rv.CRCR1Mutator]MSP[N] final char otherSeparator = separator == SYSTEM_SEPARATOR ? OTHER_SEPARATOR : SYSTEM_SEPARATOR ;
if ( size <= prefix ) { MST[rv.UOI3Mutator]MSP[N] return new String ( array , 0 , size ) ; } if ( lastIsDirectory && keepSeparator ) { return new String ( array , 0 , size ) ; }
System . arraycopy ( array , i + 1 , array , i - 1 , size - i ) ; MST[rv.AOD1Mutator]MSP[N] size -= 2 ; i -- ; } } outer: for ( int i = prefix + 2 ; i < size ; i ++ ) {
if ( prefix > 0 ) { MST[rv.ROR5Mutator]MSP[N] return normalize ( fullFileNameToAdd ) ; } if ( basePath == null ) { return null ; } final int len = basePath . length () ; if ( len == 0 ) { return normalize ( fullFileNameToAdd ) ; }
if ( array [ i ] == separator && array [ i - 1 ] == '.' && array [ i - 2 ] == '.' && MST[rv.AOR1Mutator]MSP[N] ( i == prefix + 2 || array [ i - 3 ] == separator ) ) {
if ( prefix > 0 ) { return normalize ( fullFileNameToAdd ) ; } if ( basePath == null ) { return null ; } final int len = basePath . length () ; if ( len == 0 ) { MST[rv.UOI1Mutator]MSP[N] return normalize ( fullFileNameToAdd ) ; }
if ( size <= prefix ) { MST[rv.ROR4Mutator]MSP[N] return new String ( array , 0 , size ) ; } if ( lastIsDirectory && keepSeparator ) { return new String ( array , 0 , size ) ; }
if ( array [ i ] == separator && array [ i - 1 ] == '.' && array [ i - 2 ] == '.' && MST[rv.AOD1Mutator]MSP[N] ( i == prefix + 2 || array [ i - 3 ] == separator ) ) {
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND ) { return len + 1 ; MST[rv.CRCR3Mutator]MSP[N] } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ; return Math . min ( posUnix , posWin ) + 1 ; }
list . add ( lr_6 ) ; } else if ( prevChar != '*' ) { list . add ( lr_7 ) ; } } else { buffer . append ( ch ) ; } prevChar = ch ; } if ( buffer . length () != 0 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
if ( array [ size - 1 ] != separator ) { array [ size ++ ] = separator ; MST[rv.UOI4Mutator]MSP[N] lastIsDirectory = false ; } for ( int i = prefix + 1 ; i < size ; i ++ ) {
for ( int i = prefix + 1 ; i < size ; i ++ ) { if ( array [ i ] == separator && array [ i - 1 ] == '.' && MST[rv.CRCR5Mutator]MSP[N]
if ( array [ size - 1 ] != separator ) { array [ size ++ ] = separator ; lastIsDirectory = false ; } for ( int i = prefix + 1 ; i < size ; i ++ ) { MST[rv.AOD2Mutator]MSP[N]
if ( validOctets > IPV6_MAX_HEX_GROUPS || ( validOctets < IPV6_MAX_HEX_GROUPS && ! containsCompressedZeroes ) ) { return false ; } return true ; } private static boolean isRFC3986HostName ( final String name ) { final String [] parts = name . split ( lr_13 , - 1 ) ; MST[NonVoidMethodCallMutator]MSP[N]
System . arraycopy ( array , i + 1 , array , i - 1 , size - i ) ; MST[rv.UOI1Mutator]MSP[N] size -= 2 ; i -- ; } } outer: for ( int i = prefix + 2 ; i < size ; i ++ ) {
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return len + 1 ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ; return Math . min ( posUnix , posWin ) + 1 ; }
for ( int i = 0 ; i < array . length ; i ++ ) { MST[rv.ROR4Mutator]MSP[S] if ( array [ i ] == otherSeparator ) { array [ i ] = separator ; } } boolean lastIsDirectory = true ;
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND ) { return len + 1 ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ; MST[rv.CRCR4Mutator]MSP[N] return Math . min ( posUnix , posWin ) + 1 ; }
if ( repeat >= 0 ) { backtrack . push ( new int [] { wcsIdx , repeat } ) ; MST[rv.CRCR1Mutator]MSP[N] } } else { if ( ! caseSensitivity . checkRegionMatches ( fileName , textIdx , wcs [ wcsIdx ] ) ) { break; } }
if ( len < 0 ) { return null ; } if ( len > fileName . length () ) { failIfNullBytePresent ( fileName + UNIX_SEPARATOR ) ; return fileName + UNIX_SEPARATOR ; MST[NonVoidMethodCallMutator]MSP[N] } final String path = fileName . substring ( 0 , len ) ;
( i == prefix + 1 || array [ i - 2 ] == separator ) ) { if ( i == size - 1 ) { lastIsDirectory = true ; MST[rv.CRCR6Mutator]MSP[N] }
System . arraycopy ( array , i + 1 , array , i - 1 , size - i ) ; size -= 2 ; i -- ; } } outer: for ( int i = prefix + 2 ; i < size ; i ++ ) { MST[rv.UOI3Mutator]MSP[N]
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2 ) { MST[rv.UOI3Mutator]MSP[N] return NOT_FOUND ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ;
return fileName . substring ( index + 1 ) ; MST[experimental.NakedReceiverMutator]MSP[N] } private static int getAdsCriticalOffset ( final String fileName ) { final int offset1 = fileName . lastIndexOf ( SYSTEM_SEPARATOR ) ; final int offset2 = fileName . lastIndexOf ( OTHER_SEPARATOR ) ;
System . arraycopy ( array , i + 1 , array , prefix , size - i ) ; MST[rv.ABSMutator]MSP[N] size -= i + 1 - prefix ; i = prefix + 1 ; } } if ( size <= 0 ) { return EMPTY_STRING ; }
octetInt = Integer . parseInt ( octet , BASE_16 ) ; } catch ( final NumberFormatException e ) { return false ; } if ( octetInt < 0 || octetInt > MAX_UNSIGNED_SHORT ) { MST[rv.UOI2Mutator]MSP[N] return false ; } } validOctets ++ ; }
if ( path . charAt ( i ) == 0 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] throw new IllegalArgumentException ( lr_3 + lr_4 ) ; } } } public static String getBaseName ( final String fileName ) { return removeExtension ( getName ( fileName ) ) ; }
} return fileName . substring ( 0 , end ) ; } public static String getName ( final String fileName ) { if ( fileName == null ) { MST[rv.ROR5Mutator]MSP[N] return null ; } failIfNullBytePresent ( fileName ) ; final int index = indexOfLastSeparator ( fileName ) ;
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2 ) { return NOT_FOUND ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ; MST[rv.CRCR2Mutator]MSP[N]
textIdx = caseSensitivity . checkIndexOf ( fileName , textIdx , wcs [ wcsIdx ] ) ; if ( textIdx == NOT_FOUND ) { MST[rv.ROR3Mutator]MSP[N] break; } final int repeat = caseSensitivity . checkIndexOf ( fileName , textIdx + 1 , wcs [ wcsIdx ] ) ;
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2 ) { MST[rv.UOI4Mutator]MSP[N] return NOT_FOUND ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ;
System . arraycopy ( array , i + 1 , array , i - 1 , size - i ) ; MST[rv.AOR2Mutator]MSP[N] size -= 2 ; i -- ; } } outer: for ( int i = prefix + 2 ; i < size ; i ++ ) {
final int index = indexOfLastSeparator ( fileName ) ; if ( index < 0 ) { return fileName . substring ( 0 , prefix ) ; } int end = index + ( includeSeparator ? 1 : 0 ) ; if ( end == 0 ) { MST[rv.ROR5Mutator]MSP[N] end ++ ;
list . add ( lr_6 ) ; } else if ( prevChar != '*' ) { list . add ( lr_7 ) ; } } else { buffer . append ( ch ) ; } prevChar = ch ; MST[rv.UOI3Mutator]MSP[S] } if ( buffer . length () != 0 ) {
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND ) { return len + 1 ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ; MST[rv.ROR1Mutator]MSP[N] return Math . min ( posUnix , posWin ) + 1 ; }
if ( path . charAt ( i ) == 0 ) { throw new IllegalArgumentException ( lr_3 + lr_4 ) ; } } } public static String getBaseName ( final String fileName ) { return removeExtension ( getName ( fileName ) ) ; MST[NonVoidMethodCallMutator]MSP[N] }
if ( ch == '?' || ch == '*' ) { MST[rv.UOI1Mutator]MSP[N] if ( buffer . length () != 0 ) { list . add ( buffer . toString () ) ; buffer . setLength ( 0 ) ; } if ( ch == '?' ) {
if ( path == null || path . indexOf ( WINDOWS_SEPARATOR ) == NOT_FOUND ) { MST[rv.CRCR4Mutator]MSP[N] return path ; } return path . replace ( WINDOWS_SEPARATOR , UNIX_SEPARATOR ) ; } public static String separatorsToWindows ( final String path ) {
for ( int i = 0 ; i < parts . length ; i ++ ) { if ( parts [ i ] . length () == 0 ) { return i == parts . length - 1 ; MST[InlineConstantMutator]MSP[N] }
if ( len == 2 || isSeparator ( fileName . charAt ( 2 ) ) == false ) { return 2 ; } return 3 ; } else if ( ch0 == UNIX_SEPARATOR ) { return 1 ; } return NOT_FOUND ; MST[InlineConstantMutator]MSP[N]
final String path = fileName . substring ( prefix , endIndex ) ; failIfNullBytePresent ( path ) ; return path ; MST[EmptyObjectReturnValsMutator]MSP[N] } public static String getFullPath ( final String fileName ) { return doGetFullPath ( fileName , true ) ; }
if ( array [ i ] == separator && array [ i - 1 ] == '.' && array [ i - 2 ] == '.' && MST[rv.UOI3Mutator]MSP[N] ( i == prefix + 2 || array [ i - 3 ] == separator ) ) {
if ( size <= prefix ) { return new String ( array , 0 , size ) ; } if ( lastIsDirectory && keepSeparator ) { MST[rv.UOI2Mutator]MSP[S] return new String ( array , 0 , size ) ; }
list . add ( lr_6 ) ; } else if ( prevChar != '*' ) { MST[rv.UOI2Mutator]MSP[N] list . add ( lr_7 ) ; } } else { buffer . append ( ch ) ; } prevChar = ch ; } if ( buffer . length () != 0 ) {
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2 ) { return NOT_FOUND ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; MST[rv.UOI3Mutator]MSP[N] posWin = posWin == NOT_FOUND ? posUnix : posWin ;
} else if ( inet6Address . startsWith ( lr_9 ) && ! octetList . isEmpty () ) { MST[rv.ROR4Mutator]MSP[N] octetList . remove ( 0 ) ; } octets = octetList . toArray ( new String [ octetList . size () ] ) ; }
final int lastSeparator = indexOfLastSeparator ( fileName ) ; return lastSeparator > extensionPos ? NOT_FOUND : extensionPos ; MST[rv.ROR1Mutator]MSP[N] } public static String getPrefix ( final String fileName ) { if ( fileName == null ) { return null ; } final int len = getPrefixLength ( fileName ) ;
final int index = indexOfLastSeparator ( fileName ) ; if ( index < 0 ) { return fileName . substring ( 0 , prefix ) ; MST[InlineConstantMutator]MSP[N] } int end = index + ( includeSeparator ? 1 : 0 ) ; if ( end == 0 ) { end ++ ;
private static boolean isIPv4Address ( final String name ) { final Matcher m = IPV4_PATTERN . matcher ( name ) ; if ( ! m . matches () || m . groupCount () != 4 ) { MST[rv.ROR2Mutator]MSP[N] return false ; }
if ( prefix > 0 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] return normalize ( fullFileNameToAdd ) ; } if ( basePath == null ) { return null ; } final int len = basePath . length () ; if ( len == 0 ) { return normalize ( fullFileNameToAdd ) ; }
private static boolean isIPv4Address ( final String name ) { final Matcher m = IPV4_PATTERN . matcher ( name ) ; if ( ! m . matches () || m . groupCount () != 4 ) { MST[rv.CRCR6Mutator]MSP[S] return false ; }
final char ch1 = fileName . charAt ( 1 ) ; if ( ch1 == ':' ) { ch0 = Character . toUpperCase ( ch0 ) ; if ( ch0 >= 'A' && ch0 <= 'Z' ) { MST[rv.ABSMutator]MSP[S]
final int lastSeparator = indexOfLastSeparator ( fileName ) ; return lastSeparator > extensionPos ? NOT_FOUND : extensionPos ; } public static String getPrefix ( final String fileName ) { if ( fileName == null ) { return null ; MST[ReturnValsMutator]MSP[S] } final int len = getPrefixLength ( fileName ) ;
private static String doGetPath ( final String fileName , final int separatorAdd ) { if ( fileName == null ) { return null ; } final int prefix = getPrefixLength ( fileName ) ; if ( prefix < 0 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] return null ; }
static boolean isSystemWindows () { return SYSTEM_SEPARATOR == WINDOWS_SEPARATOR ; } private static boolean isSeparator ( final char ch ) { return ch == UNIX_SEPARATOR || ch == WINDOWS_SEPARATOR ; MST[rv.CRCR1Mutator]MSP[N] } public static String normalize ( final String fileName ) {
if ( index == NOT_FOUND ) { MST[rv.CRCR5Mutator]MSP[N] return fileName ; } return fileName . substring ( 0 , index ) ; } public static boolean equals ( final String fileName1 , final String fileName2 ) { return equals ( fileName1 , fileName2 , false , IOCase . SENSITIVE ) ;
static boolean isSystemWindows () { return SYSTEM_SEPARATOR == WINDOWS_SEPARATOR ; } private static boolean isSeparator ( final char ch ) { return ch == UNIX_SEPARATOR || ch == WINDOWS_SEPARATOR ; MST[rv.CRCR3Mutator]MSP[N] } public static String normalize ( final String fileName ) {
if ( extension == null || extension . isEmpty () ) { return indexOfExtension ( fileName ) == NOT_FOUND ; MST[InlineConstantMutator]MSP[S] } final String fileExt = getExtension ( fileName ) ; return fileExt . equals ( extension ) ; }
for ( int i = prefix + 1 ; i < size ; i ++ ) { if ( array [ i ] == separator && array [ i - 1 ] == '.' && MST[rv.UOI1Mutator]MSP[N]
if ( len == 2 || isSeparator ( fileName . charAt ( 2 ) ) == false ) { return 2 ; } return 3 ; } else if ( ch0 == UNIX_SEPARATOR ) { return 1 ; MST[PrimitiveReturnsMutator]MSP[S] } return NOT_FOUND ;
return new String ( array , 0 , size - 1 ) ; MST[rv.UOI3Mutator]MSP[N] } public static String concat ( final String basePath , final String fullFileNameToAdd ) { final int prefix = getPrefixLength ( fullFileNameToAdd ) ; if ( prefix < 0 ) { return null ; }
return false ; } static String [] splitOnTokens ( final String text ) { if ( text . indexOf ( '?' ) == NOT_FOUND && text . indexOf ( '*' ) == NOT_FOUND ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return new String [] { text } ; }
return doNormalize ( fileName , SYSTEM_SEPARATOR , true ) ; } public static String normalize ( final String fileName , final boolean unixSeparator ) { final char separator = unixSeparator ? UNIX_SEPARATOR : WINDOWS_SEPARATOR ; MST[rv.CRCR1Mutator]MSP[S] return doNormalize ( fileName , separator , true ) ; }
for ( int i = prefix + 1 ; i < size ; i ++ ) { if ( array [ i ] == separator && array [ i - 1 ] == '.' && MST[InlineConstantMutator]MSP[N]
final int index = indexOfLastSeparator ( fileName ) ; if ( index < 0 ) { return fileName . substring ( 0 , prefix ) ; } int end = index + ( includeSeparator ? 1 : 0 ) ; MST[rv.AOR3Mutator]MSP[N] if ( end == 0 ) { end ++ ;
int size = fileName . length () ; if ( size == 0 ) { MST[rv.UOI1Mutator]MSP[N] return fileName ; } final int prefix = getPrefixLength ( fileName ) ; if ( prefix < 0 ) { return null ; }
if ( validOctets > IPV6_MAX_HEX_GROUPS || ( validOctets < IPV6_MAX_HEX_GROUPS && ! containsCompressedZeroes ) ) { MST[rv.UOI3Mutator]MSP[N] return false ; } return true ; } private static boolean isRFC3986HostName ( final String name ) { final String [] parts = name . split ( lr_13 , - 1 ) ;
if ( octet . length () == 0 ) { emptyOctets ++ ; if ( emptyOctets > 1 ) { MST[rv.CRCR3Mutator]MSP[N] return false ; } } else { emptyOctets = 0 ; if ( index == octets . length - 1 && octet . contains ( lr_12 ) ) {
if ( validOctets > IPV6_MAX_HEX_GROUPS || ( validOctets < IPV6_MAX_HEX_GROUPS && ! containsCompressedZeroes ) ) { MST[rv.UOI4Mutator]MSP[N] return false ; } return true ; } private static boolean isRFC3986HostName ( final String name ) { final String [] parts = name . split ( lr_13 , - 1 ) ;
return isSeparator ( ch0 ) ? 1 : 0 ; } if ( ch0 == '~' ) { MST[rv.UOI4Mutator]MSP[N] int posUnix = fileName . indexOf ( UNIX_SEPARATOR , 1 ) ; int posWin = fileName . indexOf ( WINDOWS_SEPARATOR , 1 ) ;
for ( int i = 0 ; i < parts . length ; i ++ ) { if ( parts [ i ] . length () == 0 ) { MST[NonVoidMethodCallMutator]MSP[N] return i == parts . length - 1 ; }
final int lastSeparator = indexOfLastSeparator ( fileName ) ; return lastSeparator > extensionPos ? NOT_FOUND : extensionPos ; } public static String getPrefix ( final String fileName ) { if ( fileName == null ) { return null ; } final int len = getPrefixLength ( fileName ) ; MST[NonVoidMethodCallMutator]MSP[N]
if ( array [ size - 1 ] != separator ) { MST[rv.AOD1Mutator]MSP[N] array [ size ++ ] = separator ; lastIsDirectory = false ; } for ( int i = prefix + 1 ; i < size ; i ++ ) {
int wcsIdx = 0 ; final Stack < int [] > backtrack = new Stack <> () ; do { if ( backtrack . size () > 0 ) { final int [] array = backtrack . pop () ; MST[NonVoidMethodCallMutator]MSP[S] wcsIdx = array [ 0 ] ;
final List < String > octetList = new ArrayList <> ( Arrays . asList ( octets ) ) ; if ( inet6Address . endsWith ( lr_9 ) ) { MST[rv.ROR4Mutator]MSP[N] octetList . add ( lr_11 ) ;
for ( int i = prefix + 1 ; i < size ; i ++ ) { if ( array [ i ] == separator && array [ i - 1 ] == '.' && MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
if ( len == 0 ) { return 0 ; } char ch0 = fileName . charAt ( 0 ) ; if ( ch0 == ':' ) { return NOT_FOUND ; } if ( len == 1 ) { if ( ch0 == '~' ) { MST[rv.ROR3Mutator]MSP[N] return 2 ; }
final int index = indexOfLastSeparator ( fileName ) ; if ( index < 0 ) { MST[rv.ROR2Mutator]MSP[N] return fileName . substring ( 0 , prefix ) ; } int end = index + ( includeSeparator ? 1 : 0 ) ; if ( end == 0 ) { end ++ ;
int size = fileName . length () ; if ( size == 0 ) { return fileName ; } final int prefix = getPrefixLength ( fileName ) ; if ( prefix < 0 ) { MST[NegateConditionalsMutator]MSP[N] return null ; }
System . arraycopy ( array , i + 1 , array , prefix , size - i ) ; MST[rv.AOR3Mutator]MSP[N] size -= i + 1 - prefix ; i = prefix + 1 ; } } if ( size <= 0 ) { return EMPTY_STRING ; }
if ( ipSegment . length () > 1 && ipSegment . startsWith ( lr_8 ) ) { return false ; MST[rv.CRCR3Mutator]MSP[N] } } return true ; } private static boolean isIPv6Address ( final String inet6Address ) { final boolean containsCompressedZeroes = inet6Address . contains ( lr_9 ) ;
return false ; } static String [] splitOnTokens ( final String text ) { if ( text . indexOf ( '?' ) == NOT_FOUND && text . indexOf ( '*' ) == NOT_FOUND ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return new String [] { text } ; }
return isSeparator ( ch0 ) ? 1 : 0 ; MST[rv.CRCR6Mutator]MSP[N] } } public static int indexOfLastSeparator ( final String fileName ) { if ( fileName == null ) { return NOT_FOUND ; } final int lastUnixPos = fileName . lastIndexOf ( UNIX_SEPARATOR ) ;
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2 ) { return NOT_FOUND ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ; MST[rv.UOI3Mutator]MSP[N]
if ( array [ j ] == separator ) { System . arraycopy ( array , i + 1 , array , j + 1 , size - i ) ; MST[rv.AOD2Mutator]MSP[N] size -= i - j ; i = j + 1 ; continue outer; } }
if ( path == null || path . indexOf ( UNIX_SEPARATOR ) == NOT_FOUND ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return path ; } return path . replace ( UNIX_SEPARATOR , WINDOWS_SEPARATOR ) ; } public static String separatorsToSystem ( final String path ) { if ( path == null ) {
} else if ( inet6Address . startsWith ( lr_9 ) && ! octetList . isEmpty () ) { MST[rv.ROR3Mutator]MSP[N] octetList . remove ( 0 ) ; } octets = octetList . toArray ( new String [ octetList . size () ] ) ; }
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2 ) { return NOT_FOUND ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; MST[rv.UOI2Mutator]MSP[N] posWin = posWin == NOT_FOUND ? posUnix : posWin ;
public static String getExtension ( final String fileName ) throws IllegalArgumentException { if ( fileName == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return null ; } final int index = indexOfExtension ( fileName ) ; if ( index == NOT_FOUND ) { return EMPTY_STRING ; }
|| ( inet6Address . endsWith ( lr_10 ) && ! inet6Address . endsWith ( lr_9 ) ) ) { return false ; } String [] octets = inet6Address . split ( lr_10 ) ; if ( containsCompressedZeroes ) { MST[rv.UOI4Mutator]MSP[N]
for ( int i = 0 ; i < parts . length ; i ++ ) { MST[rv.CRCR3Mutator]MSP[N] if ( parts [ i ] . length () == 0 ) { return i == parts . length - 1 ; }
final int prefix = getPrefixLength ( fileName ) ; if ( prefix < 0 ) { return null ; } if ( prefix >= fileName . length () ) { if ( includeSeparator ) { MST[rv.ROR1Mutator]MSP[S] return getPrefix ( fileName ) ; } return fileName ; }
if ( size <= prefix ) { return new String ( array , 0 , size ) ; } if ( lastIsDirectory && keepSeparator ) { MST[rv.ABSMutator]MSP[S] return new String ( array , 0 , size ) ; }
for ( int i = prefix + 1 ; i < size ; i ++ ) { MST[rv.UOI1Mutator]MSP[N] if ( array [ i ] == separator && array [ i - 1 ] == '.' &&
if ( i == prefix + 2 ) { return null ; } if ( i == size - 1 ) { MST[rv.UOI3Mutator]MSP[N] lastIsDirectory = true ; } int j ; for ( j = i - 4 ; j >= prefix ; j -- ) {
if ( size <= prefix ) { return new String ( array , 0 , size ) ; } if ( lastIsDirectory && keepSeparator ) { MST[rv.ROR3Mutator]MSP[N] return new String ( array , 0 , size ) ; }
if ( isSystemWindows () ) { final int offset = fileName . indexOf ( ':' , getAdsCriticalOffset ( fileName ) ) ; if ( offset != - 1 ) { throw new IllegalArgumentException ( lr_2 ) ; } } final int extensionPos = fileName . lastIndexOf ( EXTENSION_SEPARATOR ) ; MST[rv.CRCR6Mutator]MSP[N]
return indexOfExtension ( fileName ) == NOT_FOUND ; MST[rv.CRCR6Mutator]MSP[N] } final String fileExt = getExtension ( fileName ) ; for ( final String extension : extensions ) { if ( fileExt . equals ( extension ) ) { return true ; } } return false ; }
return false ; } static String [] splitOnTokens ( final String text ) { if ( text . indexOf ( '?' ) == NOT_FOUND && text . indexOf ( '*' ) == NOT_FOUND ) { MST[InlineConstantMutator]MSP[N] return new String [] { text } ; }
final int index = indexOfLastSeparator ( fileName ) ; final int endIndex = index + separatorAdd ; if ( prefix >= fileName . length () || index < 0 || prefix >= endIndex ) { MST[rv.ROR1Mutator]MSP[N] return EMPTY_STRING ; }
for ( int i = 0 ; i < parts . length ; i ++ ) { if ( parts [ i ] . length () == 0 ) { return i == parts . length - 1 ; MST[rv.CRCR4Mutator]MSP[N] }
for ( int i = 0 ; i < array . length ; i ++ ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] if ( array [ i ] == otherSeparator ) { array [ i ] = separator ; } } boolean lastIsDirectory = true ;
static boolean isSystemWindows () { return SYSTEM_SEPARATOR == WINDOWS_SEPARATOR ; } private static boolean isSeparator ( final char ch ) { return ch == UNIX_SEPARATOR || ch == WINDOWS_SEPARATOR ; MST[rv.CRCR6Mutator]MSP[N] } public static String normalize ( final String fileName ) {
for ( int i = 1 ; i <= 4 ; i ++ ) { final String ipSegment = m . group ( i ) ; final int iIpSegment = Integer . parseInt ( ipSegment ) ; if ( iIpSegment > IPV4_MAX_OCTET_VALUE ) { return false ; MST[InlineConstantMutator]MSP[N] }
return new String ( array , 0 , size - 1 ) ; MST[InlineConstantMutator]MSP[N] } public static String concat ( final String basePath , final String fullFileNameToAdd ) { final int prefix = getPrefixLength ( fullFileNameToAdd ) ; if ( prefix < 0 ) { return null ; }
for ( int i = 1 ; i <= 4 ; i ++ ) { final String ipSegment = m . group ( i ) ; final int iIpSegment = Integer . parseInt ( ipSegment ) ; if ( iIpSegment > IPV4_MAX_OCTET_VALUE ) { MST[rv.UOI1Mutator]MSP[N] return false ; }
return null ; } return isSystemWindows () ? separatorsToWindows ( path ) : separatorsToUnix ( path ) ; } public static int getPrefixLength ( final String fileName ) { if ( fileName == null ) { MST[rv.ROR5Mutator]MSP[N] return NOT_FOUND ; } final int len = fileName . length () ;
System . arraycopy ( array , i + 1 , array , i - 1 , size - i ) ; MST[rv.AOR1Mutator]MSP[N] size -= 2 ; i -- ; } } outer: for ( int i = prefix + 2 ; i < size ; i ++ ) {
if ( size <= prefix ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] return new String ( array , 0 , size ) ; } if ( lastIsDirectory && keepSeparator ) { return new String ( array , 0 , size ) ; }
final char ch = basePath . charAt ( len - 1 ) ; if ( isSeparator ( ch ) ) { return normalize ( basePath + fullFileNameToAdd ) ; MST[ArgumentPropagationMutator]MSP[S] } return normalize ( basePath + '/' + fullFileNameToAdd ) ; }
if ( repeat >= 0 ) { backtrack . push ( new int [] { wcsIdx , repeat } ) ; } } else { if ( ! caseSensitivity . checkRegionMatches ( fileName , textIdx , wcs [ wcsIdx ] ) ) { MST[rv.UOI1Mutator]MSP[N] break; } }
return isSeparator ( ch0 ) ? 1 : 0 ; } if ( ch0 == '~' ) { int posUnix = fileName . indexOf ( UNIX_SEPARATOR , 1 ) ; int posWin = fileName . indexOf ( WINDOWS_SEPARATOR , 1 ) ; MST[rv.CRCR4Mutator]MSP[N]
if ( len == 0 ) { return 0 ; } char ch0 = fileName . charAt ( 0 ) ; if ( ch0 == ':' ) { MST[InlineConstantMutator]MSP[N] return NOT_FOUND ; } if ( len == 1 ) { if ( ch0 == '~' ) { return 2 ; }
public static String getFullPathNoEndSeparator ( final String fileName ) { return doGetFullPath ( fileName , false ) ; } private static String doGetFullPath ( final String fileName , final boolean includeSeparator ) { if ( fileName == null ) { return null ; MST[EmptyObjectReturnValsMutator]MSP[N] }
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND ) { return len + 1 ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ; MST[rv.UOI1Mutator]MSP[N] return Math . min ( posUnix , posWin ) + 1 ; }
if ( array [ i ] == separator && array [ i - 1 ] == separator ) { MST[rv.AOD2Mutator]MSP[N] System . arraycopy ( array , i , array , i - 1 , size - i ) ; size -- ; i -- ; } }
String fileName1 , String fileName2 , final boolean normalized , IOCase caseSensitivity ) { if ( fileName1 == null || fileName2 == null ) { return fileName1 == null && fileName2 == null ; } if ( normalized ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] fileName1 = normalize ( fileName1 ) ;
if ( size <= prefix ) { return new String ( array , 0 , size ) ; } if ( lastIsDirectory && keepSeparator ) { MST[NegateConditionalsMutator]MSP[N] return new String ( array , 0 , size ) ; }
if ( path == null || path . indexOf ( WINDOWS_SEPARATOR ) == NOT_FOUND ) { return path ; } return path . replace ( WINDOWS_SEPARATOR , UNIX_SEPARATOR ) ; MST[rv.CRCR3Mutator]MSP[N] } public static String separatorsToWindows ( final String path ) {
} public static boolean equalsOnSystem ( final String fileName1 , final String fileName2 ) { return equals ( fileName1 , fileName2 , false , IOCase . SYSTEM ) ; MST[BooleanFalseReturnValsMutator]MSP[N] } public static boolean equalsNormalized ( final String fileName1 , final String fileName2 ) {
} else if ( inet6Address . startsWith ( lr_9 ) && ! octetList . isEmpty () ) { MST[rv.ROR1Mutator]MSP[N] octetList . remove ( 0 ) ; } octets = octetList . toArray ( new String [ octetList . size () ] ) ; }
if ( ipSegment . length () > 1 && ipSegment . startsWith ( lr_8 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return false ; } } return true ; } private static boolean isIPv6Address ( final String inet6Address ) { final boolean containsCompressedZeroes = inet6Address . contains ( lr_9 ) ;
if ( array [ i ] == separator && array [ i - 1 ] == '.' && array [ i - 2 ] == '.' && MST[rv.CRCR3Mutator]MSP[N] ( i == prefix + 2 || array [ i - 3 ] == separator ) ) {
if ( array [ j ] == separator ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] System . arraycopy ( array , i + 1 , array , j + 1 , size - i ) ; size -= i - j ; i = j + 1 ; continue outer; } }
for ( int i = prefix + 1 ; i < size ; i ++ ) { if ( array [ i ] == separator && array [ i - 1 ] == '.' && MST[rv.AOR2Mutator]MSP[N]
if ( array [ i ] == separator && array [ i - 1 ] == '.' && array [ i - 2 ] == '.' && MST[MathMutator]MSP[N] ( i == prefix + 2 || array [ i - 3 ] == separator ) ) {
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND ) { return len + 1 ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; MST[rv.UOI4Mutator]MSP[N] posWin = posWin == NOT_FOUND ? posUnix : posWin ; return Math . min ( posUnix , posWin ) + 1 ; }
if ( array [ size - 1 ] != separator ) { array [ size ++ ] = separator ; lastIsDirectory = false ; } for ( int i = prefix + 1 ; i < size ; i ++ ) { MST[rv.UOI2Mutator]MSP[N]
private static String doGetPath ( final String fileName , final int separatorAdd ) { if ( fileName == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return null ; } final int prefix = getPrefixLength ( fileName ) ; if ( prefix < 0 ) { return null ; }
textIdx = caseSensitivity . checkIndexOf ( fileName , textIdx , wcs [ wcsIdx ] ) ; if ( textIdx == NOT_FOUND ) { break; } final int repeat = caseSensitivity . checkIndexOf ( fileName , textIdx + 1 , wcs [ wcsIdx ] ) ; MST[rv.UOI1Mutator]MSP[N]
for ( int i = 0 ; i < parts . length ; i ++ ) { if ( parts [ i ] . length () == 0 ) { return i == parts . length - 1 ; MST[rv.CRCR5Mutator]MSP[N] }
if ( path == null || path . indexOf ( UNIX_SEPARATOR ) == NOT_FOUND ) { return path ; } return path . replace ( UNIX_SEPARATOR , WINDOWS_SEPARATOR ) ; MST[NonVoidMethodCallMutator]MSP[N] } public static String separatorsToSystem ( final String path ) { if ( path == null ) {
if ( len == 0 ) { MST[rv.ROR4Mutator]MSP[N] return 0 ; } char ch0 = fileName . charAt ( 0 ) ; if ( ch0 == ':' ) { return NOT_FOUND ; } if ( len == 1 ) { if ( ch0 == '~' ) { return 2 ; }
return fileName . substring ( index + 1 ) ; MST[rv.ABSMutator]MSP[N] } private static int getAdsCriticalOffset ( final String fileName ) { final int offset1 = fileName . lastIndexOf ( SYSTEM_SEPARATOR ) ; final int offset2 = fileName . lastIndexOf ( OTHER_SEPARATOR ) ;
if ( i == prefix + 2 ) { return null ; } if ( i == size - 1 ) { lastIsDirectory = true ; } int j ; for ( j = i - 4 ; j >= prefix ; j -- ) { MST[rv.UOI1Mutator]MSP[N]
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND ) { return len + 1 ; MST[MathMutator]MSP[N] } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ; return Math . min ( posUnix , posWin ) + 1 ; }
if ( len < 0 ) { return null ; } if ( len > fileName . length () ) { failIfNullBytePresent ( fileName + UNIX_SEPARATOR ) ; return fileName + UNIX_SEPARATOR ; } final String path = fileName . substring ( 0 , len ) ; MST[rv.UOI4Mutator]MSP[N]
textIdx = array [ 1 ] ; anyChars = true ; } while ( wcsIdx < wcs . length ) { if ( wcs [ wcsIdx ] . equals ( lr_6 ) ) { MST[rv.ROR4Mutator]MSP[N] textIdx ++ ; if ( textIdx > fileName . length () ) { break; }
if ( extension == null || extension . isEmpty () ) { return indexOfExtension ( fileName ) == NOT_FOUND ; } final String fileExt = getExtension ( fileName ) ; MST[ArgumentPropagationMutator]MSP[N] return fileExt . equals ( extension ) ; }
if ( len == 0 ) { return 0 ; } char ch0 = fileName . charAt ( 0 ) ; if ( ch0 == ':' ) { MST[NegateConditionalsMutator]MSP[N] return NOT_FOUND ; } if ( len == 1 ) { if ( ch0 == '~' ) { return 2 ; }
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND ) { return len + 1 ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ; return Math . min ( posUnix , posWin ) + 1 ; MST[rv.AOD2Mutator]MSP[N] }
if ( array [ size - 1 ] != separator ) { array [ size ++ ] = separator ; MST[IncrementsMutator]MSP[N] lastIsDirectory = false ; } for ( int i = prefix + 1 ; i < size ; i ++ ) {
if ( array [ i ] == separator && array [ i - 1 ] == separator ) { System . arraycopy ( array , i , array , i - 1 , size - i ) ; MST[rv.AOD1Mutator]MSP[N] size -- ; i -- ; } }
return isSeparator ( ch0 ) ? 1 : 0 ; MST[rv.UOI4Mutator]MSP[N] } } public static int indexOfLastSeparator ( final String fileName ) { if ( fileName == null ) { return NOT_FOUND ; } final int lastUnixPos = fileName . lastIndexOf ( UNIX_SEPARATOR ) ;
final char [] array = new char [ size + 2 ] ; MST[rv.AOR4Mutator]MSP[N] fileName . getChars ( 0 , fileName . length () , array , 0 ) ; final char otherSeparator = separator == SYSTEM_SEPARATOR ? OTHER_SEPARATOR : SYSTEM_SEPARATOR ;
final char [] array = text . toCharArray () ; final ArrayList < String > list = new ArrayList <> () ; final StringBuilder buffer = new StringBuilder () ; char prevChar = 0 ; for ( final char ch : array ) { MST[rv.UOI4Mutator]MSP[N]
private static String doGetPath ( final String fileName , final int separatorAdd ) { if ( fileName == null ) { return null ; } final int prefix = getPrefixLength ( fileName ) ; if ( prefix < 0 ) { MST[rv.ROR5Mutator]MSP[N] return null ; }
final char [] array = text . toCharArray () ; final ArrayList < String > list = new ArrayList <> () ; final StringBuilder buffer = new StringBuilder () ; char prevChar = 0 ; for ( final char ch : array ) { MST[rv.UOI3Mutator]MSP[N]
if ( ! REG_NAME_PART_PATTERN . matcher ( parts [ i ] ) . matches () ) { return false ; MST[rv.CRCR6Mutator]MSP[N] } } return true ; }
if ( len < 0 ) { return null ; } if ( len > fileName . length () ) { failIfNullBytePresent ( fileName + UNIX_SEPARATOR ) ; MST[rv.CRCR4Mutator]MSP[N] return fileName + UNIX_SEPARATOR ; } final String path = fileName . substring ( 0 , len ) ;
final int pos = Math . min ( posUnix , posWin ) + 1 ; final String hostnamePart = fileName . substring ( 2 , pos - 1 ) ; MST[rv.CRCR4Mutator]MSP[N] return isValidHostName ( hostnamePart ) ? pos : NOT_FOUND ; } else {
if ( array [ size - 1 ] != separator ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] array [ size ++ ] = separator ; lastIsDirectory = false ; } for ( int i = prefix + 1 ; i < size ; i ++ ) {
return indexOfExtension ( fileName ) == NOT_FOUND ; MST[InlineConstantMutator]MSP[S] } final String fileExt = getExtension ( fileName ) ; for ( final String extension : extensions ) { if ( fileExt . equals ( extension ) ) { return true ; } } return false ; }
if ( repeat >= 0 ) { MST[rv.ROR1Mutator]MSP[N] backtrack . push ( new int [] { wcsIdx , repeat } ) ; } } else { if ( ! caseSensitivity . checkRegionMatches ( fileName , textIdx , wcs [ wcsIdx ] ) ) { break; } }
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND ) { return len + 1 ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ; MST[rv.ROR4Mutator]MSP[N] return Math . min ( posUnix , posWin ) + 1 ; }
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND ) { return len + 1 ; MST[rv.CRCR6Mutator]MSP[N] } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ; return Math . min ( posUnix , posWin ) + 1 ; }
for ( int i = 0 ; i < parts . length ; i ++ ) { MST[rv.ROR5Mutator]MSP[N] if ( parts [ i ] . length () == 0 ) { return i == parts . length - 1 ; }
for ( int i = 0 ; i < parts . length ; i ++ ) { if ( parts [ i ] . length () == 0 ) { MST[rv.UOI3Mutator]MSP[N] return i == parts . length - 1 ; }
if ( array [ i ] == separator && array [ i - 1 ] == '.' && array [ i - 2 ] == '.' && MST[rv.ROR1Mutator]MSP[S] ( i == prefix + 2 || array [ i - 3 ] == separator ) ) {
if ( index == NOT_FOUND ) { MST[rv.ROR5Mutator]MSP[N] return fileName ; } return fileName . substring ( 0 , index ) ; } public static boolean equals ( final String fileName1 , final String fileName2 ) { return equals ( fileName1 , fileName2 , false , IOCase . SENSITIVE ) ;
if ( repeat >= 0 ) { backtrack . push ( new int [] { wcsIdx , repeat } ) ; MST[rv.CRCR5Mutator]MSP[S] } } else { if ( ! caseSensitivity . checkRegionMatches ( fileName , textIdx , wcs [ wcsIdx ] ) ) { break; } }
if ( ! REG_NAME_PART_PATTERN . matcher ( parts [ i ] ) . matches () ) { return false ; MST[BooleanTrueReturnValsMutator]MSP[N] } } return true ; }
if ( octets . length > IPV6_MAX_HEX_GROUPS ) { MST[rv.ROR3Mutator]MSP[N] return false ; } int validOctets = 0 ; int emptyOctets = 0 ; for ( int index = 0 ; index < octets . length ; index ++ ) { final String octet = octets [ index ] ;
if ( octets . length > IPV6_MAX_HEX_GROUPS ) { return false ; } int validOctets = 0 ; int emptyOctets = 0 ; for ( int index = 0 ; index < octets . length ; index ++ ) { MST[rv.CRCR6Mutator]MSP[N] final String octet = octets [ index ] ;
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2 ) { return NOT_FOUND ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] posWin = posWin == NOT_FOUND ? posUnix : posWin ;
if ( array [ i ] == separator && array [ i - 1 ] == '.' && array [ i - 2 ] == '.' && MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] ( i == prefix + 2 || array [ i - 3 ] == separator ) ) {
return fileName . substring ( index + 1 ) ; } private static void failIfNullBytePresent ( final String path ) { final int len = path . length () ; for ( int i = 0 ; i < len ; i ++ ) { MST[rv.UOI3Mutator]MSP[N]
} else if ( isSeparator ( ch0 ) && isSeparator ( ch1 ) ) { MST[rv.ROR1Mutator]MSP[N] int posUnix = fileName . indexOf ( UNIX_SEPARATOR , 2 ) ; int posWin = fileName . indexOf ( WINDOWS_SEPARATOR , 2 ) ;
return new String ( array , 0 , size - 1 ) ; } public static String concat ( final String basePath , final String fullFileNameToAdd ) { final int prefix = getPrefixLength ( fullFileNameToAdd ) ; if ( prefix < 0 ) { MST[rv.ROR5Mutator]MSP[N] return null ; }
final String path = fileName . substring ( prefix , endIndex ) ; failIfNullBytePresent ( path ) ; return path ; } public static String getFullPath ( final String fileName ) { return doGetFullPath ( fileName , true ) ; MST[rv.CRCR2Mutator]MSP[S] }
final int pos = Math . min ( posUnix , posWin ) + 1 ; MST[rv.ABSMutator]MSP[N] final String hostnamePart = fileName . substring ( 2 , pos - 1 ) ; return isValidHostName ( hostnamePart ) ? pos : NOT_FOUND ; } else {
return isSeparator ( ch0 ) ? 1 : 0 ; } if ( ch0 == '~' ) { int posUnix = fileName . indexOf ( UNIX_SEPARATOR , 1 ) ; int posWin = fileName . indexOf ( WINDOWS_SEPARATOR , 1 ) ; MST[InlineConstantMutator]MSP[N]
System . arraycopy ( array , i + 1 , array , prefix , size - i ) ; size -= i + 1 - prefix ; i = prefix + 1 ; } } if ( size <= 0 ) { MST[NegateConditionalsMutator]MSP[N] return EMPTY_STRING ; }
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2 ) { return NOT_FOUND ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ; MST[rv.ROR2Mutator]MSP[N]
if ( i == prefix + 2 ) { MST[rv.ABSMutator]MSP[N] return null ; } if ( i == size - 1 ) { lastIsDirectory = true ; } int j ; for ( j = i - 4 ; j >= prefix ; j -- ) {
if ( len < 0 ) { return null ; } if ( len > fileName . length () ) { failIfNullBytePresent ( fileName + UNIX_SEPARATOR ) ; return fileName + UNIX_SEPARATOR ; MST[rv.CRCR2Mutator]MSP[N] } final String path = fileName . substring ( 0 , len ) ;
if ( array [ j ] == separator ) { System . arraycopy ( array , i + 1 , array , j + 1 , size - i ) ; MST[rv.UOI2Mutator]MSP[N] size -= i - j ; i = j + 1 ; continue outer; } }
if ( ch == '?' || ch == '*' ) { if ( buffer . length () != 0 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] list . add ( buffer . toString () ) ; buffer . setLength ( 0 ) ; } if ( ch == '?' ) {
if ( len < 0 ) { MST[rv.ROR3Mutator]MSP[N] return null ; } if ( len > fileName . length () ) { failIfNullBytePresent ( fileName + UNIX_SEPARATOR ) ; return fileName + UNIX_SEPARATOR ; } final String path = fileName . substring ( 0 , len ) ;
return caseSensitivity . checkEquals ( fileName1 , fileName2 ) ; } public static boolean isExtension ( final String fileName , final String extension ) { if ( fileName == null ) { return false ; MST[rv.CRCR1Mutator]MSP[S] } failIfNullBytePresent ( fileName ) ;
if ( IOCase . SYSTEM . checkEquals ( canonicalParent , canonicalChild ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return false ; } return IOCase . SYSTEM . checkStartsWith ( canonicalChild , canonicalParent ) ; } public static String separatorsToUnix ( final String path ) {
if ( path == null || path . indexOf ( WINDOWS_SEPARATOR ) == NOT_FOUND ) { return path ; } return path . replace ( WINDOWS_SEPARATOR , UNIX_SEPARATOR ) ; MST[rv.CRCR6Mutator]MSP[N] } public static String separatorsToWindows ( final String path ) {
if ( len == 2 || isSeparator ( fileName . charAt ( 2 ) ) == false ) { return 2 ; } return 3 ; } else if ( ch0 == UNIX_SEPARATOR ) { MST[NegateConditionalsMutator]MSP[N] return 1 ; } return NOT_FOUND ;
final char ch = basePath . charAt ( len - 1 ) ; MST[MathMutator]MSP[N] if ( isSeparator ( ch ) ) { return normalize ( basePath + fullFileNameToAdd ) ; } return normalize ( basePath + '/' + fullFileNameToAdd ) ; }
private static boolean isIPv4Address ( final String name ) { final Matcher m = IPV4_PATTERN . matcher ( name ) ; if ( ! m . matches () || m . groupCount () != 4 ) { MST[NonVoidMethodCallMutator]MSP[S] return false ; }
return false ; } static String [] splitOnTokens ( final String text ) { if ( text . indexOf ( '?' ) == NOT_FOUND && text . indexOf ( '*' ) == NOT_FOUND ) { MST[rv.CRCR1Mutator]MSP[N] return new String [] { text } ; }
return isSeparator ( ch0 ) ? 1 : 0 ; MST[rv.ABSMutator]MSP[N] } if ( ch0 == '~' ) { int posUnix = fileName . indexOf ( UNIX_SEPARATOR , 1 ) ; int posWin = fileName . indexOf ( WINDOWS_SEPARATOR , 1 ) ;
if ( array [ i ] == separator && array [ i - 1 ] == '.' && array [ i - 2 ] == '.' && MST[rv.CRCR6Mutator]MSP[N] ( i == prefix + 2 || array [ i - 3 ] == separator ) ) {
list . add ( lr_6 ) ; } else if ( prevChar != '*' ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] list . add ( lr_7 ) ; } } else { buffer . append ( ch ) ; } prevChar = ch ; } if ( buffer . length () != 0 ) {
return fileName . substring ( index + 1 ) ; MST[rv.CRCR6Mutator]MSP[N] } private static void failIfNullBytePresent ( final String path ) { final int len = path . length () ; for ( int i = 0 ; i < len ; i ++ ) {
static boolean isSystemWindows () { return SYSTEM_SEPARATOR == WINDOWS_SEPARATOR ; } private static boolean isSeparator ( final char ch ) { return ch == UNIX_SEPARATOR || ch == WINDOWS_SEPARATOR ; MST[rv.ROR3Mutator]MSP[N] } public static String normalize ( final String fileName ) {
if ( prefix > 0 ) { return normalize ( fullFileNameToAdd ) ; } if ( basePath == null ) { return null ; } final int len = basePath . length () ; if ( len == 0 ) { return normalize ( fullFileNameToAdd ) ; MST[ArgumentPropagationMutator]MSP[S] }
anyChars = false ; } else if ( wcs [ wcsIdx ] . equals ( lr_7 ) ) { anyChars = true ; MST[rv.CRCR3Mutator]MSP[N] if ( wcsIdx == wcs . length - 1 ) { textIdx = fileName . length () ; } } else { if ( anyChars ) {
textIdx += wcs [ wcsIdx ] . length () ; anyChars = false ; } wcsIdx ++ ; } if ( wcsIdx == wcs . length && textIdx == fileName . length () ) { MST[rv.UOI2Mutator]MSP[N] return true ; } } while ( backtrack . size () > 0 );
if ( validOctets > IPV6_MAX_HEX_GROUPS || ( validOctets < IPV6_MAX_HEX_GROUPS && ! containsCompressedZeroes ) ) { return false ; } return true ; MST[InlineConstantMutator]MSP[N] } private static boolean isRFC3986HostName ( final String name ) { final String [] parts = name . split ( lr_13 , - 1 ) ;
System . arraycopy ( array , i + 1 , array , prefix , size - i ) ; MST[rv.UOI3Mutator]MSP[N] size -= i + 1 - prefix ; i = prefix + 1 ; } } if ( size <= 0 ) { return EMPTY_STRING ; }
final int index = indexOfLastSeparator ( fileName ) ; if ( index < 0 ) { return fileName . substring ( 0 , prefix ) ; } int end = index + ( includeSeparator ? 1 : 0 ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] if ( end == 0 ) { end ++ ;
public static boolean isExtension ( final String fileName , final String ... extensions ) { if ( fileName == null ) { return false ; } failIfNullBytePresent ( fileName ) ; if ( extensions == null || extensions . length == 0 ) { MST[rv.ROR2Mutator]MSP[N]
static boolean isSystemWindows () { return SYSTEM_SEPARATOR == WINDOWS_SEPARATOR ; } private static boolean isSeparator ( final char ch ) { return ch == UNIX_SEPARATOR || ch == WINDOWS_SEPARATOR ; MST[rv.CRCR4Mutator]MSP[N] } public static String normalize ( final String fileName ) {
final char ch = basePath . charAt ( len - 1 ) ; MST[rv.CRCR3Mutator]MSP[N] if ( isSeparator ( ch ) ) { return normalize ( basePath + fullFileNameToAdd ) ; } return normalize ( basePath + '/' + fullFileNameToAdd ) ; }
final char ch1 = fileName . charAt ( 1 ) ; if ( ch1 == ':' ) { ch0 = Character . toUpperCase ( ch0 ) ; if ( ch0 >= 'A' && ch0 <= 'Z' ) { MST[rv.UOI4Mutator]MSP[N]
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2 ) { return NOT_FOUND ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ; MST[rv.CRCR5Mutator]MSP[N]
if ( validOctets > IPV6_MAX_HEX_GROUPS || ( validOctets < IPV6_MAX_HEX_GROUPS && ! containsCompressedZeroes ) ) { MST[rv.ABSMutator]MSP[N] return false ; } return true ; } private static boolean isRFC3986HostName ( final String name ) { final String [] parts = name . split ( lr_13 , - 1 ) ;
if ( extension == null || extension . isEmpty () ) { MST[rv.ROR5Mutator]MSP[N] return indexOfExtension ( fileName ) == NOT_FOUND ; } final String fileExt = getExtension ( fileName ) ; return fileExt . equals ( extension ) ; }
return doNormalize ( fileName , SYSTEM_SEPARATOR , true ) ; } public static String normalize ( final String fileName , final boolean unixSeparator ) { final char separator = unixSeparator ? UNIX_SEPARATOR : WINDOWS_SEPARATOR ; MST[rv.CRCR5Mutator]MSP[N] return doNormalize ( fileName , separator , true ) ; }
return doNormalize ( fileName , SYSTEM_SEPARATOR , true ) ; } public static String normalize ( final String fileName , final boolean unixSeparator ) { final char separator = unixSeparator ? UNIX_SEPARATOR : WINDOWS_SEPARATOR ; MST[rv.ROR3Mutator]MSP[N] return doNormalize ( fileName , separator , true ) ; }
if ( octet . length () == 0 ) { MST[rv.ROR3Mutator]MSP[N] emptyOctets ++ ; if ( emptyOctets > 1 ) { return false ; } } else { emptyOctets = 0 ; if ( index == octets . length - 1 && octet . contains ( lr_12 ) ) {
final char ch1 = fileName . charAt ( 1 ) ; if ( ch1 == ':' ) { MST[rv.CRCR2Mutator]MSP[N] ch0 = Character . toUpperCase ( ch0 ) ; if ( ch0 >= 'A' && ch0 <= 'Z' ) {
final int index = indexOfLastSeparator ( fileName ) ; if ( index < 0 ) { return fileName . substring ( 0 , prefix ) ; } int end = index + ( includeSeparator ? 1 : 0 ) ; if ( end == 0 ) { MST[rv.ROR2Mutator]MSP[N] end ++ ;
if ( octet . length () == 0 ) { emptyOctets ++ ; if ( emptyOctets > 1 ) { return false ; } } else { emptyOctets = 0 ; MST[rv.CRCR6Mutator]MSP[N] if ( index == octets . length - 1 && octet . contains ( lr_12 ) ) {
if ( array [ i ] == separator && array [ i - 1 ] == '.' && array [ i - 2 ] == '.' && MST[rv.ROR4Mutator]MSP[N] ( i == prefix + 2 || array [ i - 3 ] == separator ) ) {
if ( path == null || path . indexOf ( UNIX_SEPARATOR ) == NOT_FOUND ) { return path ; } return path . replace ( UNIX_SEPARATOR , WINDOWS_SEPARATOR ) ; } public static String separatorsToSystem ( final String path ) { if ( path == null ) { MST[NegateConditionalsMutator]MSP[N]
if ( len == 0 ) { return 0 ; } char ch0 = fileName . charAt ( 0 ) ; if ( ch0 == ':' ) { return NOT_FOUND ; } if ( len == 1 ) { if ( ch0 == '~' ) { MST[rv.CRCR6Mutator]MSP[N] return 2 ; }
final String path = fileName . substring ( prefix , endIndex ) ; MST[rv.UOI3Mutator]MSP[N] failIfNullBytePresent ( path ) ; return path ; } public static String getFullPath ( final String fileName ) { return doGetFullPath ( fileName , true ) ; }
final int pos = Math . min ( posUnix , posWin ) + 1 ; MST[rv.AOR4Mutator]MSP[N] final String hostnamePart = fileName . substring ( 2 , pos - 1 ) ; return isValidHostName ( hostnamePart ) ? pos : NOT_FOUND ; } else {
for ( int i = 0 ; i < parts . length ; i ++ ) { MST[rv.CRCR6Mutator]MSP[N] if ( parts [ i ] . length () == 0 ) { return i == parts . length - 1 ; }
for ( int i = 0 ; i < array . length ; i ++ ) { MST[rv.CRCR5Mutator]MSP[N] if ( array [ i ] == otherSeparator ) { array [ i ] = separator ; } } boolean lastIsDirectory = true ;
return doNormalize ( fileName , separator , false ) ; MST[rv.UOI3Mutator]MSP[N] } private static String doNormalize ( final String fileName , final char separator , final boolean keepSeparator ) { if ( fileName == null ) { return null ; } failIfNullBytePresent ( fileName ) ;
final int lastSeparator = indexOfLastSeparator ( fileName ) ; return lastSeparator > extensionPos ? NOT_FOUND : extensionPos ; MST[rv.UOI2Mutator]MSP[N] } public static String getPrefix ( final String fileName ) { if ( fileName == null ) { return null ; } final int len = getPrefixLength ( fileName ) ;
if ( repeat >= 0 ) { backtrack . push ( new int [] { wcsIdx , repeat } ) ; MST[InlineConstantMutator]MSP[N] } } else { if ( ! caseSensitivity . checkRegionMatches ( fileName , textIdx , wcs [ wcsIdx ] ) ) { break; } }
if ( size <= prefix ) { return new String ( array , 0 , size ) ; } if ( lastIsDirectory && keepSeparator ) { return new String ( array , 0 , size ) ; MST[EmptyObjectReturnValsMutator]MSP[N] }
final int pos = Math . min ( posUnix , posWin ) + 1 ; final String hostnamePart = fileName . substring ( 2 , pos - 1 ) ; MST[rv.AOR1Mutator]MSP[N] return isValidHostName ( hostnamePart ) ? pos : NOT_FOUND ; } else {
if ( path . charAt ( i ) == 0 ) { MST[rv.ABSMutator]MSP[N] throw new IllegalArgumentException ( lr_3 + lr_4 ) ; } } } public static String getBaseName ( final String fileName ) { return removeExtension ( getName ( fileName ) ) ; }
if ( isSystemWindows () ) { final int offset = fileName . indexOf ( ':' , getAdsCriticalOffset ( fileName ) ) ; if ( offset != - 1 ) { throw new IllegalArgumentException ( lr_2 ) ; } } final int extensionPos = fileName . lastIndexOf ( EXTENSION_SEPARATOR ) ; MST[rv.CRCR3Mutator]MSP[N]
if ( len == 0 ) { return 0 ; } char ch0 = fileName . charAt ( 0 ) ; if ( ch0 == ':' ) { return NOT_FOUND ; } if ( len == 1 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] if ( ch0 == '~' ) { return 2 ; }
if ( octets . length > IPV6_MAX_HEX_GROUPS ) { return false ; } int validOctets = 0 ; int emptyOctets = 0 ; for ( int index = 0 ; index < octets . length ; index ++ ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] final String octet = octets [ index ] ;
if ( len == 2 || isSeparator ( fileName . charAt ( 2 ) ) == false ) { return 2 ; } return 3 ; } else if ( ch0 == UNIX_SEPARATOR ) { return 1 ; MST[rv.CRCR5Mutator]MSP[S] } return NOT_FOUND ;
if ( index == NOT_FOUND ) { MST[rv.UOI1Mutator]MSP[N] return fileName ; } return fileName . substring ( 0 , index ) ; } public static boolean equals ( final String fileName1 , final String fileName2 ) { return equals ( fileName1 , fileName2 , false , IOCase . SENSITIVE ) ;
if ( i == prefix + 2 ) { return null ; } if ( i == size - 1 ) { MST[rv.ROR5Mutator]MSP[N] lastIsDirectory = true ; } int j ; for ( j = i - 4 ; j >= prefix ; j -- ) {
private static boolean isIPv4Address ( final String name ) { final Matcher m = IPV4_PATTERN . matcher ( name ) ; if ( ! m . matches () || m . groupCount () != 4 ) { return false ; MST[rv.CRCR5Mutator]MSP[N] }
if ( ipSegment . length () > 1 && ipSegment . startsWith ( lr_8 ) ) { MST[rv.ROR3Mutator]MSP[N] return false ; } } return true ; } private static boolean isIPv6Address ( final String inet6Address ) { final boolean containsCompressedZeroes = inet6Address . contains ( lr_9 ) ;
final List < String > octetList = new ArrayList <> ( Arrays . asList ( octets ) ) ; MST[ConstructorCallMutator]MSP[N] if ( inet6Address . endsWith ( lr_9 ) ) { octetList . add ( lr_11 ) ;
for ( int i = prefix + 1 ; i < size ; i ++ ) { if ( array [ i ] == separator && array [ i - 1 ] == '.' && MST[NegateConditionalsMutator]MSP[N]
System . arraycopy ( array , i + 1 , array , i - 1 , size - i ) ; size -= 2 ; i -- ; } } outer: for ( int i = prefix + 2 ; i < size ; i ++ ) { MST[rv.UOI4Mutator]MSP[N]
return equals ( fileName1 , fileName2 , true , IOCase . SENSITIVE ) ; } public static boolean equalsNormalizedOnSystem ( final String fileName1 , final String fileName2 ) { return equals ( fileName1 , fileName2 , true , IOCase . SYSTEM ) ; MST[rv.CRCR5Mutator]MSP[N] } public static boolean equals (
if ( octets . length > IPV6_MAX_HEX_GROUPS ) { return false ; } int validOctets = 0 ; int emptyOctets = 0 ; for ( int index = 0 ; index < octets . length ; index ++ ) { final String octet = octets [ index ] ; MST[rv.UOI3Mutator]MSP[N]
for ( int i = prefix + 1 ; i < size ; i ++ ) { if ( array [ i ] == separator && array [ i - 1 ] == '.' && MST[InlineConstantMutator]MSP[N]
|| ( inet6Address . endsWith ( lr_10 ) && ! inet6Address . endsWith ( lr_9 ) ) ) { return false ; } String [] octets = inet6Address . split ( lr_10 ) ; if ( containsCompressedZeroes ) { MST[rv.ROR5Mutator]MSP[N]
if ( ! isIPv4Address ( octet ) ) { MST[rv.ROR3Mutator]MSP[N] return false ; } validOctets += 2 ; continue; } if ( octet . length () > IPV6_MAX_HEX_DIGITS_PER_GROUP ) { return false ; } int octetInt = 0 ; try {
anyChars = false ; } else if ( wcs [ wcsIdx ] . equals ( lr_7 ) ) { anyChars = true ; if ( wcsIdx == wcs . length - 1 ) { MST[rv.AOD1Mutator]MSP[N] textIdx = fileName . length () ; } } else { if ( anyChars ) {
static boolean isSystemWindows () { return SYSTEM_SEPARATOR == WINDOWS_SEPARATOR ; } private static boolean isSeparator ( final char ch ) { return ch == UNIX_SEPARATOR || ch == WINDOWS_SEPARATOR ; MST[rv.ROR4Mutator]MSP[N] } public static String normalize ( final String fileName ) {
( i == prefix + 1 || array [ i - 2 ] == separator ) ) { if ( i == size - 1 ) { MST[rv.UOI3Mutator]MSP[N] lastIsDirectory = true ; }
if ( len < 0 ) { return null ; } if ( len > fileName . length () ) { MST[rv.ABSMutator]MSP[N] failIfNullBytePresent ( fileName + UNIX_SEPARATOR ) ; return fileName + UNIX_SEPARATOR ; } final String path = fileName . substring ( 0 , len ) ;
list . add ( lr_6 ) ; } else if ( prevChar != '*' ) { list . add ( lr_7 ) ; } } else { buffer . append ( ch ) ; MST[rv.UOI1Mutator]MSP[N] } prevChar = ch ; } if ( buffer . length () != 0 ) {
if ( len == 0 ) { return 0 ; } char ch0 = fileName . charAt ( 0 ) ; if ( ch0 == ':' ) { MST[rv.CRCR1Mutator]MSP[N] return NOT_FOUND ; } if ( len == 1 ) { if ( ch0 == '~' ) { return 2 ; }
final int index = indexOfLastSeparator ( fileName ) ; if ( index < 0 ) { return fileName . substring ( 0 , prefix ) ; } int end = index + ( includeSeparator ? 1 : 0 ) ; if ( end == 0 ) { MST[rv.UOI4Mutator]MSP[N] end ++ ;
return wildcardMatch ( fileName , wildcardMatcher , IOCase . SYSTEM ) ; MST[ReturnValsMutator]MSP[N] } public static boolean wildcardMatch ( final String fileName , final String wildcardMatcher , IOCase caseSensitivity ) { if ( fileName == null && wildcardMatcher == null ) { return true ; }
if ( array [ i ] == separator && array [ i - 1 ] == separator ) { System . arraycopy ( array , i , array , i - 1 , size - i ) ; MST[rv.AOR4Mutator]MSP[N] size -- ; i -- ; } }
if ( octet . length () == 0 ) { emptyOctets ++ ; if ( emptyOctets > 1 ) { MST[ConditionalsBoundaryMutator]MSP[N] return false ; } } else { emptyOctets = 0 ; if ( index == octets . length - 1 && octet . contains ( lr_12 ) ) {
System . arraycopy ( array , i + 1 , array , i - 1 , size - i ) ; MST[rv.UOI4Mutator]MSP[N] size -= 2 ; i -- ; } } outer: for ( int i = prefix + 2 ; i < size ; i ++ ) {
if ( size <= prefix ) { return new String ( array , 0 , size ) ; MST[rv.UOI3Mutator]MSP[N] } if ( lastIsDirectory && keepSeparator ) { return new String ( array , 0 , size ) ; }
public static boolean directoryContains ( final String canonicalParent , final String canonicalChild ) throws IOException { if ( canonicalParent == null ) { throw new IllegalArgumentException ( lr_1 ) ; } if ( canonicalChild == null ) { MST[rv.ROR5Mutator]MSP[N] return false ; }
if ( array [ i ] == separator && array [ i - 1 ] == separator ) { System . arraycopy ( array , i , array , i - 1 , size - i ) ; MST[rv.ABSMutator]MSP[N] size -- ; i -- ; } }
for ( int i = prefix + 1 ; i < size ; i ++ ) { if ( array [ i ] == separator && array [ i - 1 ] == '.' && MST[rv.CRCR1Mutator]MSP[N]
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND ) { return len + 1 ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; MST[rv.ABSMutator]MSP[N] posWin = posWin == NOT_FOUND ? posUnix : posWin ; return Math . min ( posUnix , posWin ) + 1 ; }
public static boolean isExtension ( final String fileName , final Collection < String > extensions ) { if ( fileName == null ) { return false ; } failIfNullBytePresent ( fileName ) ; if ( extensions == null || extensions . isEmpty () ) { MST[rv.ROR3Mutator]MSP[N]
list . add ( buffer . toString () ) ; } return list . toArray ( new String [ list . size () ] ) ; } private static boolean isValidHostName ( final String name ) { return isIPv6Address ( name ) || isRFC3986HostName ( name ) ; MST[NegateConditionalsMutator]MSP[N] }
return doNormalize ( fileName , SYSTEM_SEPARATOR , true ) ; } public static String normalize ( final String fileName , final boolean unixSeparator ) { final char separator = unixSeparator ? UNIX_SEPARATOR : WINDOWS_SEPARATOR ; MST[InlineConstantMutator]MSP[S] return doNormalize ( fileName , separator , true ) ; }
final int index = indexOfLastSeparator ( fileName ) ; if ( index < 0 ) { return fileName . substring ( 0 , prefix ) ; MST[rv.UOI3Mutator]MSP[N] } int end = index + ( includeSeparator ? 1 : 0 ) ; if ( end == 0 ) { end ++ ;
if ( array [ i ] == separator && array [ i - 1 ] == separator ) { MST[rv.ROR2Mutator]MSP[N] System . arraycopy ( array , i , array , i - 1 , size - i ) ; size -- ; i -- ; } }
final int pos = Math . min ( posUnix , posWin ) + 1 ; final String hostnamePart = fileName . substring ( 2 , pos - 1 ) ; MST[NonVoidMethodCallMutator]MSP[N] return isValidHostName ( hostnamePart ) ? pos : NOT_FOUND ; } else {
System . arraycopy ( array , i + 1 , array , i - 1 , size - i ) ; size -= 2 ; i -- ; } } outer: for ( int i = prefix + 2 ; i < size ; i ++ ) { MST[rv.AOD1Mutator]MSP[S]
final int index = indexOfLastSeparator ( fileName ) ; if ( index < 0 ) { MST[rv.UOI1Mutator]MSP[N] return fileName . substring ( 0 , prefix ) ; } int end = index + ( includeSeparator ? 1 : 0 ) ; if ( end == 0 ) { end ++ ;
if ( len == 0 ) { return 0 ; } char ch0 = fileName . charAt ( 0 ) ; if ( ch0 == ':' ) { return NOT_FOUND ; } if ( len == 1 ) { MST[rv.UOI3Mutator]MSP[N] if ( ch0 == '~' ) { return 2 ; }
|| ( inet6Address . endsWith ( lr_10 ) && ! inet6Address . endsWith ( lr_9 ) ) ) { MST[rv.ROR4Mutator]MSP[N] return false ; } String [] octets = inet6Address . split ( lr_10 ) ; if ( containsCompressedZeroes ) {
int wcsIdx = 0 ; final Stack < int [] > backtrack = new Stack <> () ; do { if ( backtrack . size () > 0 ) { final int [] array = backtrack . pop () ; wcsIdx = array [ 0 ] ; MST[rv.CRCR1Mutator]MSP[N]
System . arraycopy ( array , i + 1 , array , i - 1 , size - i ) ; size -= 2 ; MST[experimental.RemoveIncrementsMutator]MSP[N] i -- ; } } outer: for ( int i = prefix + 2 ; i < size ; i ++ ) {
for ( int i = 1 ; i <= 4 ; i ++ ) { final String ipSegment = m . group ( i ) ; final int iIpSegment = Integer . parseInt ( ipSegment ) ; if ( iIpSegment > IPV4_MAX_OCTET_VALUE ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] return false ; }
return null ; } return isSystemWindows () ? separatorsToWindows ( path ) : separatorsToUnix ( path ) ; MST[rv.ROR1Mutator]MSP[N] } public static int getPrefixLength ( final String fileName ) { if ( fileName == null ) { return NOT_FOUND ; } final int len = fileName . length () ;
if ( len == 2 || isSeparator ( fileName . charAt ( 2 ) ) == false ) { return 2 ; } return 3 ; } else if ( ch0 == UNIX_SEPARATOR ) { return 1 ; } return NOT_FOUND ; MST[rv.CRCR1Mutator]MSP[N]
if ( ! REG_NAME_PART_PATTERN . matcher ( parts [ i ] ) . matches () ) { MST[NonVoidMethodCallMutator]MSP[N] return false ; } } return true ; }
System . arraycopy ( array , i + 1 , array , i - 1 , size - i ) ; MST[rv.CRCR4Mutator]MSP[N] size -= 2 ; i -- ; } } outer: for ( int i = prefix + 2 ; i < size ; i ++ ) {
textIdx = array [ 1 ] ; anyChars = true ; } while ( wcsIdx < wcs . length ) { if ( wcs [ wcsIdx ] . equals ( lr_6 ) ) { MST[rv.UOI2Mutator]MSP[N] textIdx ++ ; if ( textIdx > fileName . length () ) { break; }
if ( octets . length > IPV6_MAX_HEX_GROUPS ) { MST[rv.CRCR6Mutator]MSP[N] return false ; } int validOctets = 0 ; int emptyOctets = 0 ; for ( int index = 0 ; index < octets . length ; index ++ ) { final String octet = octets [ index ] ;
if ( len < 0 ) { return null ; } if ( len > fileName . length () ) { MST[rv.ROR1Mutator]MSP[N] failIfNullBytePresent ( fileName + UNIX_SEPARATOR ) ; return fileName + UNIX_SEPARATOR ; } final String path = fileName . substring ( 0 , len ) ;
public static boolean isExtension ( final String fileName , final Collection < String > extensions ) { if ( fileName == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return false ; } failIfNullBytePresent ( fileName ) ; if ( extensions == null || extensions . isEmpty () ) {
if ( i == prefix + 2 ) { MST[rv.ROR1Mutator]MSP[N] return null ; } if ( i == size - 1 ) { lastIsDirectory = true ; } int j ; for ( j = i - 4 ; j >= prefix ; j -- ) {
return fileName . substring ( index + 1 ) ; MST[rv.AOD2Mutator]MSP[N] } private static int getAdsCriticalOffset ( final String fileName ) { final int offset1 = fileName . lastIndexOf ( SYSTEM_SEPARATOR ) ; final int offset2 = fileName . lastIndexOf ( OTHER_SEPARATOR ) ;
for ( int i = 0 ; i < parts . length ; i ++ ) { if ( parts [ i ] . length () == 0 ) { return i == parts . length - 1 ; MST[rv.AOR1Mutator]MSP[N] }
if ( containsCompressedZeroes && ( inet6Address . indexOf ( lr_9 ) != inet6Address . lastIndexOf ( lr_9 ) ) ) { MST[rv.ROR2Mutator]MSP[S] return false ; } if ( ( inet6Address . startsWith ( lr_10 ) && ! inet6Address . startsWith ( lr_9 ) )
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND ) { return len + 1 ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ; MST[rv.ABSMutator]MSP[N] return Math . min ( posUnix , posWin ) + 1 ; }
} else if ( isSeparator ( ch0 ) && isSeparator ( ch1 ) ) { int posUnix = fileName . indexOf ( UNIX_SEPARATOR , 2 ) ; MST[rv.CRCR6Mutator]MSP[N] int posWin = fileName . indexOf ( WINDOWS_SEPARATOR , 2 ) ;
final char [] array = new char [ size + 2 ] ; fileName . getChars ( 0 , fileName . length () , array , 0 ) ; MST[rv.CRCR5Mutator]MSP[N] final char otherSeparator = separator == SYSTEM_SEPARATOR ? OTHER_SEPARATOR : SYSTEM_SEPARATOR ;
if ( fileName == null || wildcardMatcher == null ) { return false ; } if ( caseSensitivity == null ) { caseSensitivity = IOCase . SENSITIVE ; } final String [] wcs = splitOnTokens ( wildcardMatcher ) ; boolean anyChars = false ; int textIdx = 0 ; MST[rv.CRCR3Mutator]MSP[N]
return wildcardMatch ( fileName , wildcardMatcher , IOCase . SYSTEM ) ; } public static boolean wildcardMatch ( final String fileName , final String wildcardMatcher , IOCase caseSensitivity ) { if ( fileName == null && wildcardMatcher == null ) { return true ; MST[InlineConstantMutator]MSP[N] }
if ( ! isIPv4Address ( octet ) ) { return false ; } validOctets += 2 ; continue; } if ( octet . length () > IPV6_MAX_HEX_DIGITS_PER_GROUP ) { return false ; MST[rv.CRCR1Mutator]MSP[N] } int octetInt = 0 ; try {
octetInt = Integer . parseInt ( octet , BASE_16 ) ; } catch ( final NumberFormatException e ) { return false ; } if ( octetInt < 0 || octetInt > MAX_UNSIGNED_SHORT ) { MST[NegateConditionalsMutator]MSP[N] return false ; } } validOctets ++ ; }
if ( len == 2 || isSeparator ( fileName . charAt ( 2 ) ) == false ) { MST[rv.CRCR2Mutator]MSP[N] return 2 ; } return 3 ; } else if ( ch0 == UNIX_SEPARATOR ) { return 1 ; } return NOT_FOUND ;
for ( int i = 0 ; i < parts . length ; i ++ ) { MST[rv.ROR4Mutator]MSP[N] if ( parts [ i ] . length () == 0 ) { return i == parts . length - 1 ; }
final char [] array = new char [ size + 2 ] ; fileName . getChars ( 0 , fileName . length () , array , 0 ) ; MST[InlineConstantMutator]MSP[N] final char otherSeparator = separator == SYSTEM_SEPARATOR ? OTHER_SEPARATOR : SYSTEM_SEPARATOR ;
if ( array [ j ] == separator ) { MST[rv.ROR1Mutator]MSP[N] System . arraycopy ( array , i + 1 , array , j + 1 , size - i ) ; size -= i - j ; i = j + 1 ; continue outer; } }
public static String normalizeNoEndSeparator ( final String fileName ) { return doNormalize ( fileName , SYSTEM_SEPARATOR , false ) ; } public static String normalizeNoEndSeparator ( final String fileName , final boolean unixSeparator ) { final char separator = unixSeparator ? UNIX_SEPARATOR : WINDOWS_SEPARATOR ; MST[rv.CRCR6Mutator]MSP[N]
public static String normalizeNoEndSeparator ( final String fileName ) { return doNormalize ( fileName , SYSTEM_SEPARATOR , false ) ; } public static String normalizeNoEndSeparator ( final String fileName , final boolean unixSeparator ) { final char separator = unixSeparator ? UNIX_SEPARATOR : WINDOWS_SEPARATOR ; MST[rv.CRCR3Mutator]MSP[N]
if ( path . charAt ( i ) == 0 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] throw new IllegalArgumentException ( lr_3 + lr_4 ) ; } } } public static String getBaseName ( final String fileName ) { return removeExtension ( getName ( fileName ) ) ; }
if ( ! isIPv4Address ( octet ) ) { return false ; } validOctets += 2 ; continue; } if ( octet . length () > IPV6_MAX_HEX_DIGITS_PER_GROUP ) { MST[rv.CRCR4Mutator]MSP[N] return false ; } int octetInt = 0 ; try {
if ( size <= prefix ) { return new String ( array , 0 , size ) ; } if ( lastIsDirectory && keepSeparator ) { MST[rv.ROR2Mutator]MSP[N] return new String ( array , 0 , size ) ; }
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2 ) { MST[rv.ABSMutator]MSP[N] return NOT_FOUND ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ;
final int index = indexOfLastSeparator ( fileName ) ; final int endIndex = index + separatorAdd ; if ( prefix >= fileName . length () || index < 0 || prefix >= endIndex ) { MST[NonVoidMethodCallMutator]MSP[N] return EMPTY_STRING ; }
return doNormalize ( fileName , separator , false ) ; MST[ArgumentPropagationMutator]MSP[N] } private static String doNormalize ( final String fileName , final char separator , final boolean keepSeparator ) { if ( fileName == null ) { return null ; } failIfNullBytePresent ( fileName ) ;
if ( index == NOT_FOUND ) { MST[rv.ROR4Mutator]MSP[S] return fileName ; } return fileName . substring ( 0 , index ) ; } public static boolean equals ( final String fileName1 , final String fileName2 ) { return equals ( fileName1 , fileName2 , false , IOCase . SENSITIVE ) ;
public static boolean directoryContains ( final String canonicalParent , final String canonicalChild ) throws IOException { if ( canonicalParent == null ) { throw new IllegalArgumentException ( lr_1 ) ; } if ( canonicalChild == null ) { return false ; MST[ReturnValsMutator]MSP[N] }
if ( validOctets > IPV6_MAX_HEX_GROUPS || ( validOctets < IPV6_MAX_HEX_GROUPS && ! containsCompressedZeroes ) ) { MST[rv.CRCR6Mutator]MSP[N] return false ; } return true ; } private static boolean isRFC3986HostName ( final String name ) { final String [] parts = name . split ( lr_13 , - 1 ) ;
final int pos = Math . min ( posUnix , posWin ) + 1 ; final String hostnamePart = fileName . substring ( 2 , pos - 1 ) ; return isValidHostName ( hostnamePart ) ? pos : NOT_FOUND ; MST[rv.UOI4Mutator]MSP[N] } else {
if ( ch == '?' || ch == '*' ) { MST[rv.ROR4Mutator]MSP[N] if ( buffer . length () != 0 ) { list . add ( buffer . toString () ) ; buffer . setLength ( 0 ) ; } if ( ch == '?' ) {
System . arraycopy ( array , i + 1 , array , prefix , size - i ) ; size -= i + 1 - prefix ; i = prefix + 1 ; } } if ( size <= 0 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] return EMPTY_STRING ; }
final char ch = basePath . charAt ( len - 1 ) ; MST[rv.CRCR6Mutator]MSP[N] if ( isSeparator ( ch ) ) { return normalize ( basePath + fullFileNameToAdd ) ; } return normalize ( basePath + '/' + fullFileNameToAdd ) ; }
final int index = indexOfLastSeparator ( fileName ) ; final int endIndex = index + separatorAdd ; if ( prefix >= fileName . length () || index < 0 || prefix >= endIndex ) { MST[ConditionalsBoundaryMutator]MSP[N] return EMPTY_STRING ; }
if ( extension == null || extension . isEmpty () ) { MST[rv.ROR2Mutator]MSP[N] return indexOfExtension ( fileName ) == NOT_FOUND ; } final String fileExt = getExtension ( fileName ) ; return fileExt . equals ( extension ) ; }
System . arraycopy ( array , i + 1 , array , prefix , size - i ) ; size -= i + 1 - prefix ; MST[rv.ABSMutator]MSP[N] i = prefix + 1 ; } } if ( size <= 0 ) { return EMPTY_STRING ; }
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2 ) { MST[InlineConstantMutator]MSP[N] return NOT_FOUND ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ;
for ( int i = prefix + 1 ; i < size ; i ++ ) { if ( array [ i ] == separator && array [ i - 1 ] == '.' && MST[rv.AOR1Mutator]MSP[N]
octetInt = Integer . parseInt ( octet , BASE_16 ) ; } catch ( final NumberFormatException e ) { return false ; MST[InlineConstantMutator]MSP[S] } if ( octetInt < 0 || octetInt > MAX_UNSIGNED_SHORT ) { return false ; } } validOctets ++ ; }
if ( prefix > 0 ) { return normalize ( fullFileNameToAdd ) ; } if ( basePath == null ) { MST[NegateConditionalsMutator]MSP[N] return null ; } final int len = basePath . length () ; if ( len == 0 ) { return normalize ( fullFileNameToAdd ) ; }
final char [] array = text . toCharArray () ; final ArrayList < String > list = new ArrayList <> () ; final StringBuilder buffer = new StringBuilder () ; char prevChar = 0 ; for ( final char ch : array ) { MST[rv.UOI1Mutator]MSP[N]
final char ch1 = fileName . charAt ( 1 ) ; if ( ch1 == ':' ) { MST[rv.CRCR5Mutator]MSP[N] ch0 = Character . toUpperCase ( ch0 ) ; if ( ch0 >= 'A' && ch0 <= 'Z' ) {
return fileName . substring ( index + 1 ) ; } private static void failIfNullBytePresent ( final String path ) { final int len = path . length () ; for ( int i = 0 ; i < len ; i ++ ) { MST[rv.CRCR3Mutator]MSP[N]
if ( array [ j ] == separator ) { System . arraycopy ( array , i + 1 , array , j + 1 , size - i ) ; MST[rv.AOR2Mutator]MSP[N] size -= i - j ; i = j + 1 ; continue outer; } }
for ( int i = 1 ; i <= 4 ; i ++ ) { MST[rv.ROR1Mutator]MSP[N] final String ipSegment = m . group ( i ) ; final int iIpSegment = Integer . parseInt ( ipSegment ) ; if ( iIpSegment > IPV4_MAX_OCTET_VALUE ) { return false ; }
return doNormalize ( fileName , SYSTEM_SEPARATOR , true ) ; } public static String normalize ( final String fileName , final boolean unixSeparator ) { final char separator = unixSeparator ? UNIX_SEPARATOR : WINDOWS_SEPARATOR ; return doNormalize ( fileName , separator , true ) ; MST[rv.CRCR6Mutator]MSP[N] }
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND ) { return len + 1 ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ; return Math . min ( posUnix , posWin ) + 1 ; MST[rv.UOI1Mutator]MSP[N] }
return isSeparator ( ch0 ) ? 1 : 0 ; } if ( ch0 == '~' ) { MST[rv.ABSMutator]MSP[N] int posUnix = fileName . indexOf ( UNIX_SEPARATOR , 1 ) ; int posWin = fileName . indexOf ( WINDOWS_SEPARATOR , 1 ) ;
return indexOfExtension ( fileName ) == NOT_FOUND ; MST[rv.ROR5Mutator]MSP[N] } final String fileExt = getExtension ( fileName ) ; for ( final String extension : extensions ) { if ( fileExt . equals ( extension ) ) { return true ; } } return false ; }
octetInt = Integer . parseInt ( octet , BASE_16 ) ; } catch ( final NumberFormatException e ) { return false ; } if ( octetInt < 0 || octetInt > MAX_UNSIGNED_SHORT ) { MST[rv.ROR5Mutator]MSP[N] return false ; } } validOctets ++ ; }
if ( path == null || path . indexOf ( WINDOWS_SEPARATOR ) == NOT_FOUND ) { return path ; } return path . replace ( WINDOWS_SEPARATOR , UNIX_SEPARATOR ) ; MST[rv.CRCR5Mutator]MSP[N] } public static String separatorsToWindows ( final String path ) {
if ( path == null || path . indexOf ( UNIX_SEPARATOR ) == NOT_FOUND ) { MST[rv.ROR5Mutator]MSP[N] return path ; } return path . replace ( UNIX_SEPARATOR , WINDOWS_SEPARATOR ) ; } public static String separatorsToSystem ( final String path ) { if ( path == null ) {
if ( extension == null || extension . isEmpty () ) { return indexOfExtension ( fileName ) == NOT_FOUND ; MST[rv.CRCR3Mutator]MSP[N] } final String fileExt = getExtension ( fileName ) ; return fileExt . equals ( extension ) ; }
if ( prefix > 0 ) { return normalize ( fullFileNameToAdd ) ; } if ( basePath == null ) { MST[rv.ROR5Mutator]MSP[N] return null ; } final int len = basePath . length () ; if ( len == 0 ) { return normalize ( fullFileNameToAdd ) ; }
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND ) { return len + 1 ; MST[ReturnValsMutator]MSP[N] } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ; return Math . min ( posUnix , posWin ) + 1 ; }
anyChars = false ; } else if ( wcs [ wcsIdx ] . equals ( lr_7 ) ) { anyChars = true ; MST[rv.CRCR4Mutator]MSP[N] if ( wcsIdx == wcs . length - 1 ) { textIdx = fileName . length () ; } } else { if ( anyChars ) {
System . arraycopy ( array , i + 1 , array , i - 1 , size - i ) ; MST[rv.CRCR6Mutator]MSP[N] size -= 2 ; i -- ; } } outer: for ( int i = prefix + 2 ; i < size ; i ++ ) {
if ( array [ i ] == separator && array [ i - 1 ] == '.' && array [ i - 2 ] == '.' && MST[rv.CRCR5Mutator]MSP[N] ( i == prefix + 2 || array [ i - 3 ] == separator ) ) {
if ( array [ i ] == separator && array [ i - 1 ] == '.' && array [ i - 2 ] == '.' && MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] ( i == prefix + 2 || array [ i - 3 ] == separator ) ) {
textIdx = array [ 1 ] ; anyChars = true ; } while ( wcsIdx < wcs . length ) { if ( wcs [ wcsIdx ] . equals ( lr_6 ) ) { textIdx ++ ; if ( textIdx > fileName . length () ) { MST[NonVoidMethodCallMutator]MSP[N] break; }
if ( size <= prefix ) { return new String ( array , 0 , size ) ; } if ( lastIsDirectory && keepSeparator ) { MST[rv.UOI1Mutator]MSP[N] return new String ( array , 0 , size ) ; }
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND ) { return len + 1 ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; MST[rv.UOI2Mutator]MSP[N] posWin = posWin == NOT_FOUND ? posUnix : posWin ; return Math . min ( posUnix , posWin ) + 1 ; }
failIfNullBytePresent ( path ) ; return path ; } public static String getPath ( final String fileName ) { return doGetPath ( fileName , 1 ) ; MST[rv.CRCR2Mutator]MSP[S] } public static String getPathNoEndSeparator ( final String fileName ) { return doGetPath ( fileName , 0 ) ; }
return indexOfExtension ( fileName ) == NOT_FOUND ; } final String fileExt = getExtension ( fileName ) ; for ( final String extension : extensions ) { if ( fileExt . equals ( extension ) ) { MST[rv.ROR5Mutator]MSP[N] return true ; } } return false ; }
final int index = indexOfLastSeparator ( fileName ) ; if ( index < 0 ) { MST[NegateConditionalsMutator]MSP[N] return fileName . substring ( 0 , prefix ) ; } int end = index + ( includeSeparator ? 1 : 0 ) ; if ( end == 0 ) { end ++ ;
return equals ( fileName1 , fileName2 , true , IOCase . SENSITIVE ) ; } public static boolean equalsNormalizedOnSystem ( final String fileName1 , final String fileName2 ) { return equals ( fileName1 , fileName2 , true , IOCase . SYSTEM ) ; MST[rv.CRCR3Mutator]MSP[N] } public static boolean equals (
public static String getExtension ( final String fileName ) throws IllegalArgumentException { if ( fileName == null ) { return null ; } final int index = indexOfExtension ( fileName ) ; if ( index == NOT_FOUND ) { MST[rv.CRCR5Mutator]MSP[N] return EMPTY_STRING ; }
return fileName . substring ( index + 1 ) ; } private static void failIfNullBytePresent ( final String path ) { final int len = path . length () ; for ( int i = 0 ; i < len ; i ++ ) { MST[rv.UOI4Mutator]MSP[N]
if ( len == 0 ) { return 0 ; } char ch0 = fileName . charAt ( 0 ) ; if ( ch0 == ':' ) { return NOT_FOUND ; } if ( len == 1 ) { if ( ch0 == '~' ) { return 2 ; MST[PrimitiveReturnsMutator]MSP[N] }
failIfNullBytePresent ( path ) ; return path ; } public static String getPath ( final String fileName ) { return doGetPath ( fileName , 1 ) ; MST[NonVoidMethodCallMutator]MSP[N] } public static String getPathNoEndSeparator ( final String fileName ) { return doGetPath ( fileName , 0 ) ; }
for ( int i = prefix + 1 ; i < size ; i ++ ) { if ( array [ i ] == separator && array [ i - 1 ] == '.' && MST[NegateConditionalsMutator]MSP[N]
anyChars = false ; } else if ( wcs [ wcsIdx ] . equals ( lr_7 ) ) { anyChars = true ; if ( wcsIdx == wcs . length - 1 ) { textIdx = fileName . length () ; } } else { if ( anyChars ) { MST[rv.ROR1Mutator]MSP[N]
if ( ! isIPv4Address ( octet ) ) { return false ; } validOctets += 2 ; continue; } if ( octet . length () > IPV6_MAX_HEX_DIGITS_PER_GROUP ) { return false ; } int octetInt = 0 ; MST[InlineConstantMutator]MSP[N] try {
static boolean isSystemWindows () { return SYSTEM_SEPARATOR == WINDOWS_SEPARATOR ; MST[rv.CRCR4Mutator]MSP[N] } private static boolean isSeparator ( final char ch ) { return ch == UNIX_SEPARATOR || ch == WINDOWS_SEPARATOR ; } public static String normalize ( final String fileName ) {
list . add ( lr_6 ) ; } else if ( prevChar != '*' ) { MST[rv.CRCR1Mutator]MSP[S] list . add ( lr_7 ) ; } } else { buffer . append ( ch ) ; } prevChar = ch ; } if ( buffer . length () != 0 ) {
if ( fileName == null || wildcardMatcher == null ) { return false ; MST[rv.CRCR1Mutator]MSP[N] } if ( caseSensitivity == null ) { caseSensitivity = IOCase . SENSITIVE ; } final String [] wcs = splitOnTokens ( wildcardMatcher ) ; boolean anyChars = false ; int textIdx = 0 ;
if ( array [ j ] == separator ) { System . arraycopy ( array , i + 1 , array , j + 1 , size - i ) ; MST[rv.UOI3Mutator]MSP[N] size -= i - j ; i = j + 1 ; continue outer; } }
int size = fileName . length () ; if ( size == 0 ) { return fileName ; } final int prefix = getPrefixLength ( fileName ) ; if ( prefix < 0 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] return null ; }
textIdx = caseSensitivity . checkIndexOf ( fileName , textIdx , wcs [ wcsIdx ] ) ; MST[rv.UOI2Mutator]MSP[N] if ( textIdx == NOT_FOUND ) { break; } final int repeat = caseSensitivity . checkIndexOf ( fileName , textIdx + 1 , wcs [ wcsIdx ] ) ;
} public static boolean equalsOnSystem ( final String fileName1 , final String fileName2 ) { return equals ( fileName1 , fileName2 , false , IOCase . SYSTEM ) ; MST[rv.CRCR1Mutator]MSP[S] } public static boolean equalsNormalized ( final String fileName1 , final String fileName2 ) {
public static boolean isExtension ( final String fileName , final String ... extensions ) { if ( fileName == null ) { return false ; } failIfNullBytePresent ( fileName ) ; if ( extensions == null || extensions . length == 0 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
if ( fileName == null || wildcardMatcher == null ) { MST[NegateConditionalsMutator]MSP[N] return false ; } if ( caseSensitivity == null ) { caseSensitivity = IOCase . SENSITIVE ; } final String [] wcs = splitOnTokens ( wildcardMatcher ) ; boolean anyChars = false ; int textIdx = 0 ;
if ( fileName == null || wildcardMatcher == null ) { return false ; } if ( caseSensitivity == null ) { caseSensitivity = IOCase . SENSITIVE ; } final String [] wcs = splitOnTokens ( wildcardMatcher ) ; boolean anyChars = false ; MST[rv.CRCR6Mutator]MSP[S] int textIdx = 0 ;
return isSeparator ( ch0 ) ? 1 : 0 ; MST[NonVoidMethodCallMutator]MSP[N] } if ( ch0 == '~' ) { int posUnix = fileName . indexOf ( UNIX_SEPARATOR , 1 ) ; int posWin = fileName . indexOf ( WINDOWS_SEPARATOR , 1 ) ;
textIdx = array [ 1 ] ; anyChars = true ; } while ( wcsIdx < wcs . length ) { if ( wcs [ wcsIdx ] . equals ( lr_6 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] textIdx ++ ; if ( textIdx > fileName . length () ) { break; }
final char [] array = new char [ size + 2 ] ; fileName . getChars ( 0 , fileName . length () , array , 0 ) ; MST[VoidMethodCallMutator]MSP[N] final char otherSeparator = separator == SYSTEM_SEPARATOR ? OTHER_SEPARATOR : SYSTEM_SEPARATOR ;
if ( size <= prefix ) { MST[rv.UOI1Mutator]MSP[N] return new String ( array , 0 , size ) ; } if ( lastIsDirectory && keepSeparator ) { return new String ( array , 0 , size ) ; }
if ( path == null || path . indexOf ( WINDOWS_SEPARATOR ) == NOT_FOUND ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return path ; } return path . replace ( WINDOWS_SEPARATOR , UNIX_SEPARATOR ) ; } public static String separatorsToWindows ( final String path ) {
final int index = indexOfLastSeparator ( fileName ) ; if ( index < 0 ) { MST[rv.ROR5Mutator]MSP[N] return fileName . substring ( 0 , prefix ) ; } int end = index + ( includeSeparator ? 1 : 0 ) ; if ( end == 0 ) { end ++ ;
if ( len == 0 ) { return 0 ; } char ch0 = fileName . charAt ( 0 ) ; if ( ch0 == ':' ) { return NOT_FOUND ; } if ( len == 1 ) { if ( ch0 == '~' ) { MST[rv.ROR1Mutator]MSP[S] return 2 ; }
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2 ) { MST[rv.CRCR6Mutator]MSP[N] return NOT_FOUND ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ;
final char ch = basePath . charAt ( len - 1 ) ; if ( isSeparator ( ch ) ) { return normalize ( basePath + fullFileNameToAdd ) ; } return normalize ( basePath + '/' + fullFileNameToAdd ) ; MST[NonVoidMethodCallMutator]MSP[N] }
System . arraycopy ( array , i + 1 , array , prefix , size - i ) ; size -= i + 1 - prefix ; MST[rv.CRCR6Mutator]MSP[N] i = prefix + 1 ; } } if ( size <= 0 ) { return EMPTY_STRING ; }
if ( len == 0 ) { return 0 ; } char ch0 = fileName . charAt ( 0 ) ; if ( ch0 == ':' ) { return NOT_FOUND ; } if ( len == 1 ) { MST[NegateConditionalsMutator]MSP[N] if ( ch0 == '~' ) { return 2 ; }
return isSeparator ( ch0 ) ? 1 : 0 ; MST[rv.UOI2Mutator]MSP[S] } } public static int indexOfLastSeparator ( final String fileName ) { if ( fileName == null ) { return NOT_FOUND ; } final int lastUnixPos = fileName . lastIndexOf ( UNIX_SEPARATOR ) ;
System . arraycopy ( array , i + 1 , array , prefix , size - i ) ; MST[rv.UOI3Mutator]MSP[N] size -= i + 1 - prefix ; i = prefix + 1 ; } } if ( size <= 0 ) { return EMPTY_STRING ; }
if ( i == prefix + 2 ) { return null ; } if ( i == size - 1 ) { lastIsDirectory = true ; } int j ; for ( j = i - 4 ; j >= prefix ; j -- ) { MST[rv.UOI4Mutator]MSP[N]
if ( ch == '?' || ch == '*' ) { MST[rv.CRCR3Mutator]MSP[N] if ( buffer . length () != 0 ) { list . add ( buffer . toString () ) ; buffer . setLength ( 0 ) ; } if ( ch == '?' ) {
if ( ipSegment . length () > 1 && ipSegment . startsWith ( lr_8 ) ) { return false ; MST[ReturnValsMutator]MSP[N] } } return true ; } private static boolean isIPv6Address ( final String inet6Address ) { final boolean containsCompressedZeroes = inet6Address . contains ( lr_9 ) ;
final int index = indexOfLastSeparator ( fileName ) ; if ( index < 0 ) { MST[ConditionalsBoundaryMutator]MSP[N] return fileName . substring ( 0 , prefix ) ; } int end = index + ( includeSeparator ? 1 : 0 ) ; if ( end == 0 ) { end ++ ;
String fileName1 , String fileName2 , final boolean normalized , IOCase caseSensitivity ) { if ( fileName1 == null || fileName2 == null ) { return fileName1 == null && fileName2 == null ; MST[rv.CRCR4Mutator]MSP[N] } if ( normalized ) { fileName1 = normalize ( fileName1 ) ;
if ( array [ i ] == separator && array [ i - 1 ] == '.' && array [ i - 2 ] == '.' && MST[rv.ABSMutator]MSP[N] ( i == prefix + 2 || array [ i - 3 ] == separator ) ) {
if ( len == 0 ) { return 0 ; } char ch0 = fileName . charAt ( 0 ) ; if ( ch0 == ':' ) { return NOT_FOUND ; } if ( len == 1 ) { if ( ch0 == '~' ) { return 2 ; MST[rv.CRCR6Mutator]MSP[N] }
textIdx += wcs [ wcsIdx ] . length () ; anyChars = false ; } wcsIdx ++ ; } if ( wcsIdx == wcs . length && textIdx == fileName . length () ) { MST[rv.ROR1Mutator]MSP[N] return true ; } } while ( backtrack . size () > 0 );
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND ) { return len + 1 ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; MST[rv.ABSMutator]MSP[N] posWin = posWin == NOT_FOUND ? posUnix : posWin ; return Math . min ( posUnix , posWin ) + 1 ; }
anyChars = false ; } else if ( wcs [ wcsIdx ] . equals ( lr_7 ) ) { anyChars = true ; if ( wcsIdx == wcs . length - 1 ) { MST[rv.CRCR5Mutator]MSP[N] textIdx = fileName . length () ; } } else { if ( anyChars ) {
octetInt = Integer . parseInt ( octet , BASE_16 ) ; } catch ( final NumberFormatException e ) { return false ; } if ( octetInt < 0 || octetInt > MAX_UNSIGNED_SHORT ) { MST[rv.UOI4Mutator]MSP[N] return false ; } } validOctets ++ ; }
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND ) { return len + 1 ; MST[rv.UOI1Mutator]MSP[N] } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ; return Math . min ( posUnix , posWin ) + 1 ; }
public static boolean isExtension ( final String fileName , final Collection < String > extensions ) { if ( fileName == null ) { return false ; } failIfNullBytePresent ( fileName ) ; if ( extensions == null || extensions . isEmpty () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
if ( validOctets > IPV6_MAX_HEX_GROUPS || ( validOctets < IPV6_MAX_HEX_GROUPS && ! containsCompressedZeroes ) ) { MST[rv.ROR3Mutator]MSP[N] return false ; } return true ; } private static boolean isRFC3986HostName ( final String name ) { final String [] parts = name . split ( lr_13 , - 1 ) ;
static boolean isSystemWindows () { return SYSTEM_SEPARATOR == WINDOWS_SEPARATOR ; } private static boolean isSeparator ( final char ch ) { return ch == UNIX_SEPARATOR || ch == WINDOWS_SEPARATOR ; MST[rv.CRCR5Mutator]MSP[N] } public static String normalize ( final String fileName ) {
public static boolean directoryContains ( final String canonicalParent , final String canonicalChild ) throws IOException { if ( canonicalParent == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] throw new IllegalArgumentException ( lr_1 ) ; } if ( canonicalChild == null ) { return false ; }
if ( index == NOT_FOUND ) { return fileName ; } return fileName . substring ( 0 , index ) ; MST[rv.UOI1Mutator]MSP[N] } public static boolean equals ( final String fileName1 , final String fileName2 ) { return equals ( fileName1 , fileName2 , false , IOCase . SENSITIVE ) ;
for ( int i = prefix + 1 ; i < size ; i ++ ) { if ( array [ i ] == separator && array [ i - 1 ] == '.' && MST[rv.ROR5Mutator]MSP[N]
return equals ( fileName1 , fileName2 , true , IOCase . SENSITIVE ) ; MST[InlineConstantMutator]MSP[S] } public static boolean equalsNormalizedOnSystem ( final String fileName1 , final String fileName2 ) { return equals ( fileName1 , fileName2 , true , IOCase . SYSTEM ) ; } public static boolean equals (
if ( len == 2 || isSeparator ( fileName . charAt ( 2 ) ) == false ) { return 2 ; } return 3 ; } else if ( ch0 == UNIX_SEPARATOR ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return 1 ; } return NOT_FOUND ;
if ( len == 0 ) { MST[rv.UOI4Mutator]MSP[N] return 0 ; } char ch0 = fileName . charAt ( 0 ) ; if ( ch0 == ':' ) { return NOT_FOUND ; } if ( len == 1 ) { if ( ch0 == '~' ) { return 2 ; }
final char ch1 = fileName . charAt ( 1 ) ; MST[rv.CRCR3Mutator]MSP[N] if ( ch1 == ':' ) { ch0 = Character . toUpperCase ( ch0 ) ; if ( ch0 >= 'A' && ch0 <= 'Z' ) {
System . arraycopy ( array , i + 1 , array , i - 1 , size - i ) ; MST[rv.CRCR3Mutator]MSP[N] size -= 2 ; i -- ; } } outer: for ( int i = prefix + 2 ; i < size ; i ++ ) {
for ( int i = prefix + 1 ; i < size ; i ++ ) { if ( array [ i ] == separator && array [ i - 1 ] == '.' && MST[rv.CRCR6Mutator]MSP[N]
if ( i == prefix + 2 ) { return null ; } if ( i == size - 1 ) { lastIsDirectory = true ; MST[rv.CRCR4Mutator]MSP[N] } int j ; for ( j = i - 4 ; j >= prefix ; j -- ) {
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND ) { return len + 1 ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; MST[InlineConstantMutator]MSP[N] posWin = posWin == NOT_FOUND ? posUnix : posWin ; return Math . min ( posUnix , posWin ) + 1 ; }
if ( array [ i ] == separator && array [ i - 1 ] == '.' && array [ i - 2 ] == '.' && MST[rv.ROR4Mutator]MSP[N] ( i == prefix + 2 || array [ i - 3 ] == separator ) ) {
final int lastWindowsPos = fileName . lastIndexOf ( WINDOWS_SEPARATOR ) ; return Math . max ( lastUnixPos , lastWindowsPos ) ; MST[PrimitiveReturnsMutator]MSP[N] } public static int indexOfExtension ( final String fileName ) throws IllegalArgumentException { if ( fileName == null ) { return NOT_FOUND ; }
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2 ) { return NOT_FOUND ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ; MST[rv.UOI1Mutator]MSP[N]
if ( array [ i ] == separator && array [ i - 1 ] == separator ) { System . arraycopy ( array , i , array , i - 1 , size - i ) ; MST[rv.UOI4Mutator]MSP[N] size -- ; i -- ; } }
anyChars = false ; } else if ( wcs [ wcsIdx ] . equals ( lr_7 ) ) { anyChars = true ; if ( wcsIdx == wcs . length - 1 ) { MST[rv.ROR3Mutator]MSP[N] textIdx = fileName . length () ; } } else { if ( anyChars ) {
if ( path == null || path . indexOf ( UNIX_SEPARATOR ) == NOT_FOUND ) { MST[NegateConditionalsMutator]MSP[N] return path ; } return path . replace ( UNIX_SEPARATOR , WINDOWS_SEPARATOR ) ; } public static String separatorsToSystem ( final String path ) { if ( path == null ) {
if ( octets . length > IPV6_MAX_HEX_GROUPS ) { return false ; } int validOctets = 0 ; int emptyOctets = 0 ; for ( int index = 0 ; index < octets . length ; index ++ ) { MST[rv.ROR5Mutator]MSP[N] final String octet = octets [ index ] ;
if ( i == prefix + 2 ) { MST[rv.UOI2Mutator]MSP[N] return null ; } if ( i == size - 1 ) { lastIsDirectory = true ; } int j ; for ( j = i - 4 ; j >= prefix ; j -- ) {
return indexOfExtension ( fileName ) == NOT_FOUND ; MST[NegateConditionalsMutator]MSP[N] } final String fileExt = getExtension ( fileName ) ; for ( final String extension : extensions ) { if ( fileExt . equals ( extension ) ) { return true ; } } return false ; }
if ( repeat >= 0 ) { backtrack . push ( new int [] { wcsIdx , repeat } ) ; } } else { if ( ! caseSensitivity . checkRegionMatches ( fileName , textIdx , wcs [ wcsIdx ] ) ) { MST[rv.UOI4Mutator]MSP[N] break; } }
if ( octet . length () == 0 ) { emptyOctets ++ ; if ( emptyOctets > 1 ) { MST[rv.CRCR5Mutator]MSP[N] return false ; } } else { emptyOctets = 0 ; if ( index == octets . length - 1 && octet . contains ( lr_12 ) ) {
if ( validOctets > IPV6_MAX_HEX_GROUPS || ( validOctets < IPV6_MAX_HEX_GROUPS && ! containsCompressedZeroes ) ) { return false ; } return true ; } private static boolean isRFC3986HostName ( final String name ) { final String [] parts = name . split ( lr_13 , - 1 ) ; MST[rv.CRCR1Mutator]MSP[N]
return isSeparator ( ch0 ) ? 1 : 0 ; } if ( ch0 == '~' ) { int posUnix = fileName . indexOf ( UNIX_SEPARATOR , 1 ) ; int posWin = fileName . indexOf ( WINDOWS_SEPARATOR , 1 ) ; MST[rv.CRCR1Mutator]MSP[N]
final char [] array = new char [ size + 2 ] ; MST[rv.UOI1Mutator]MSP[N] fileName . getChars ( 0 , fileName . length () , array , 0 ) ; final char otherSeparator = separator == SYSTEM_SEPARATOR ? OTHER_SEPARATOR : SYSTEM_SEPARATOR ;
if ( size <= prefix ) { return new String ( array , 0 , size ) ; MST[InlineConstantMutator]MSP[N] } if ( lastIsDirectory && keepSeparator ) { return new String ( array , 0 , size ) ; }
if ( array [ j ] == separator ) { System . arraycopy ( array , i + 1 , array , j + 1 , size - i ) ; size -= i - j ; i = j + 1 ; MST[MathMutator]MSP[N] continue outer; } }
if ( prefix > 0 ) { return normalize ( fullFileNameToAdd ) ; } if ( basePath == null ) { return null ; } final int len = basePath . length () ; if ( len == 0 ) { MST[rv.ROR1Mutator]MSP[N] return normalize ( fullFileNameToAdd ) ; }
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND ) { MST[rv.ROR5Mutator]MSP[N] return len + 1 ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ; return Math . min ( posUnix , posWin ) + 1 ; }
for ( int i = 1 ; i <= 4 ; i ++ ) { MST[rv.CRCR6Mutator]MSP[N] final String ipSegment = m . group ( i ) ; final int iIpSegment = Integer . parseInt ( ipSegment ) ; if ( iIpSegment > IPV4_MAX_OCTET_VALUE ) { return false ; }
if ( array [ size - 1 ] != separator ) { array [ size ++ ] = separator ; lastIsDirectory = false ; } for ( int i = prefix + 1 ; i < size ; i ++ ) { MST[rv.AOR2Mutator]MSP[S]
for ( int i = prefix + 1 ; i < size ; i ++ ) { if ( array [ i ] == separator && array [ i - 1 ] == '.' && MST[rv.ROR1Mutator]MSP[S]
final char ch1 = fileName . charAt ( 1 ) ; if ( ch1 == ':' ) { ch0 = Character . toUpperCase ( ch0 ) ; if ( ch0 >= 'A' && ch0 <= 'Z' ) { MST[rv.UOI2Mutator]MSP[N]
static boolean isSystemWindows () { return SYSTEM_SEPARATOR == WINDOWS_SEPARATOR ; } private static boolean isSeparator ( final char ch ) { return ch == UNIX_SEPARATOR || ch == WINDOWS_SEPARATOR ; MST[rv.CRCR1Mutator]MSP[N] } public static String normalize ( final String fileName ) {
return indexOfExtension ( fileName ) == NOT_FOUND ; } final String fileExt = getExtension ( fileName ) ; for ( final String extension : extensions ) { if ( fileExt . equals ( extension ) ) { MST[NegateConditionalsMutator]MSP[N] return true ; } } return false ; }
for ( int i = prefix + 1 ; i < size ; i ++ ) { MST[rv.CRCR6Mutator]MSP[S] if ( array [ i ] == separator && array [ i - 1 ] == '.' &&
final char ch = basePath . charAt ( len - 1 ) ; MST[rv.AOD2Mutator]MSP[N] if ( isSeparator ( ch ) ) { return normalize ( basePath + fullFileNameToAdd ) ; } return normalize ( basePath + '/' + fullFileNameToAdd ) ; }
textIdx = array [ 1 ] ; MST[rv.CRCR4Mutator]MSP[S] anyChars = true ; } while ( wcsIdx < wcs . length ) { if ( wcs [ wcsIdx ] . equals ( lr_6 ) ) { textIdx ++ ; if ( textIdx > fileName . length () ) { break; }
if ( path == null || path . indexOf ( UNIX_SEPARATOR ) == NOT_FOUND ) { MST[rv.CRCR4Mutator]MSP[N] return path ; } return path . replace ( UNIX_SEPARATOR , WINDOWS_SEPARATOR ) ; } public static String separatorsToSystem ( final String path ) { if ( path == null ) {
if ( array [ i ] == separator && array [ i - 1 ] == separator ) { MST[rv.AOR2Mutator]MSP[N] System . arraycopy ( array , i , array , i - 1 , size - i ) ; size -- ; i -- ; } }
return isSeparator ( ch0 ) ? 1 : 0 ; MST[ReturnValsMutator]MSP[N] } if ( ch0 == '~' ) { int posUnix = fileName . indexOf ( UNIX_SEPARATOR , 1 ) ; int posWin = fileName . indexOf ( WINDOWS_SEPARATOR , 1 ) ;
octetInt = Integer . parseInt ( octet , BASE_16 ) ; } catch ( final NumberFormatException e ) { return false ; } if ( octetInt < 0 || octetInt > MAX_UNSIGNED_SHORT ) { MST[rv.CRCR4Mutator]MSP[N] return false ; } } validOctets ++ ; }
public static String normalizeNoEndSeparator ( final String fileName ) { return doNormalize ( fileName , SYSTEM_SEPARATOR , false ) ; } public static String normalizeNoEndSeparator ( final String fileName , final boolean unixSeparator ) { final char separator = unixSeparator ? UNIX_SEPARATOR : WINDOWS_SEPARATOR ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S]
final char ch = basePath . charAt ( len - 1 ) ; if ( isSeparator ( ch ) ) { return normalize ( basePath + fullFileNameToAdd ) ; MST[EmptyObjectReturnValsMutator]MSP[N] } return normalize ( basePath + '/' + fullFileNameToAdd ) ; }
anyChars = false ; } else if ( wcs [ wcsIdx ] . equals ( lr_7 ) ) { anyChars = true ; if ( wcsIdx == wcs . length - 1 ) { MST[rv.AOR3Mutator]MSP[N] textIdx = fileName . length () ; } } else { if ( anyChars ) {
return fileName . substring ( index + 1 ) ; MST[rv.AOR1Mutator]MSP[N] } private static int getAdsCriticalOffset ( final String fileName ) { final int offset1 = fileName . lastIndexOf ( SYSTEM_SEPARATOR ) ; final int offset2 = fileName . lastIndexOf ( OTHER_SEPARATOR ) ;
final int index = indexOfLastSeparator ( fileName ) ; if ( index < 0 ) { return fileName . substring ( 0 , prefix ) ; } int end = index + ( includeSeparator ? 1 : 0 ) ; MST[rv.AOR1Mutator]MSP[S] if ( end == 0 ) { end ++ ;
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2 ) { return NOT_FOUND ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ; MST[rv.UOI3Mutator]MSP[N]
private static boolean isIPv4Address ( final String name ) { final Matcher m = IPV4_PATTERN . matcher ( name ) ; if ( ! m . matches () || m . groupCount () != 4 ) { return false ; MST[InlineConstantMutator]MSP[N] }
for ( int i = 0 ; i < array . length ; i ++ ) { MST[rv.ROR1Mutator]MSP[N] if ( array [ i ] == otherSeparator ) { array [ i ] = separator ; } } boolean lastIsDirectory = true ;
if ( size <= prefix ) { MST[rv.ROR1Mutator]MSP[N] return new String ( array , 0 , size ) ; } if ( lastIsDirectory && keepSeparator ) { return new String ( array , 0 , size ) ; }
for ( int i = 0 ; i < parts . length ; i ++ ) { if ( parts [ i ] . length () == 0 ) { MST[NegateConditionalsMutator]MSP[N] return i == parts . length - 1 ; }
if ( len == 0 ) { return 0 ; } char ch0 = fileName . charAt ( 0 ) ; if ( ch0 == ':' ) { return NOT_FOUND ; } if ( len == 1 ) { if ( ch0 == '~' ) { MST[rv.UOI1Mutator]MSP[N] return 2 ; }
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND ) { return len + 1 ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; MST[rv.UOI3Mutator]MSP[N] posWin = posWin == NOT_FOUND ? posUnix : posWin ; return Math . min ( posUnix , posWin ) + 1 ; }
if ( len == 0 ) { return 0 ; } char ch0 = fileName . charAt ( 0 ) ; if ( ch0 == ':' ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return NOT_FOUND ; } if ( len == 1 ) { if ( ch0 == '~' ) { return 2 ; }
return isSeparator ( ch0 ) ? 1 : 0 ; } } public static int indexOfLastSeparator ( final String fileName ) { if ( fileName == null ) { return NOT_FOUND ; } final int lastUnixPos = fileName . lastIndexOf ( UNIX_SEPARATOR ) ; MST[rv.CRCR3Mutator]MSP[N]
if ( octets . length > IPV6_MAX_HEX_GROUPS ) { return false ; } int validOctets = 0 ; int emptyOctets = 0 ; MST[rv.CRCR1Mutator]MSP[N] for ( int index = 0 ; index < octets . length ; index ++ ) { final String octet = octets [ index ] ;
final int pos = Math . min ( posUnix , posWin ) + 1 ; final String hostnamePart = fileName . substring ( 2 , pos - 1 ) ; return isValidHostName ( hostnamePart ) ? pos : NOT_FOUND ; MST[NonVoidMethodCallMutator]MSP[N] } else {
for ( int i = prefix + 1 ; i < size ; i ++ ) { if ( array [ i ] == separator && array [ i - 1 ] == '.' && MST[rv.ROR2Mutator]MSP[N]
( i == prefix + 1 || array [ i - 2 ] == separator ) ) { if ( i == size - 1 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] lastIsDirectory = true ; }
return isSeparator ( ch0 ) ? 1 : 0 ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } if ( ch0 == '~' ) { int posUnix = fileName . indexOf ( UNIX_SEPARATOR , 1 ) ; int posWin = fileName . indexOf ( WINDOWS_SEPARATOR , 1 ) ;
return wildcardMatch ( fileName , wildcardMatcher , IOCase . SYSTEM ) ; } public static boolean wildcardMatch ( final String fileName , final String wildcardMatcher , IOCase caseSensitivity ) { if ( fileName == null && wildcardMatcher == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return true ; }
final int prefix = getPrefixLength ( fileName ) ; if ( prefix < 0 ) { return null ; } if ( prefix >= fileName . length () ) { if ( includeSeparator ) { return getPrefix ( fileName ) ; MST[EmptyObjectReturnValsMutator]MSP[S] } return fileName ; }
final char ch1 = fileName . charAt ( 1 ) ; if ( ch1 == ':' ) { ch0 = Character . toUpperCase ( ch0 ) ; if ( ch0 >= 'A' && ch0 <= 'Z' ) { MST[InlineConstantMutator]MSP[S]
return false ; MST[ReturnValsMutator]MSP[N] } static String [] splitOnTokens ( final String text ) { if ( text . indexOf ( '?' ) == NOT_FOUND && text . indexOf ( '*' ) == NOT_FOUND ) { return new String [] { text } ; }
return indexOfExtension ( fileName ) == NOT_FOUND ; } final String fileExt = getExtension ( fileName ) ; for ( final String extension : extensions ) { if ( fileExt . equals ( extension ) ) { return true ; MST[InlineConstantMutator]MSP[N] } } return false ; }
for ( int i = 0 ; i < parts . length ; i ++ ) { MST[InlineConstantMutator]MSP[N] if ( parts [ i ] . length () == 0 ) { return i == parts . length - 1 ; }
System . arraycopy ( array , i + 1 , array , prefix , size - i ) ; size -= i + 1 - prefix ; MST[rv.UOI4Mutator]MSP[N] i = prefix + 1 ; } } if ( size <= 0 ) { return EMPTY_STRING ; }
return doNormalize ( fileName , SYSTEM_SEPARATOR , true ) ; MST[rv.CRCR3Mutator]MSP[N] } public static String normalize ( final String fileName , final boolean unixSeparator ) { final char separator = unixSeparator ? UNIX_SEPARATOR : WINDOWS_SEPARATOR ; return doNormalize ( fileName , separator , true ) ; }
if ( len == 0 ) { MST[rv.ROR5Mutator]MSP[N] return 0 ; } char ch0 = fileName . charAt ( 0 ) ; if ( ch0 == ':' ) { return NOT_FOUND ; } if ( len == 1 ) { if ( ch0 == '~' ) { return 2 ; }
if ( array [ size - 1 ] != separator ) { MST[rv.ABSMutator]MSP[N] array [ size ++ ] = separator ; lastIsDirectory = false ; } for ( int i = prefix + 1 ; i < size ; i ++ ) {
if ( array [ i ] == separator && array [ i - 1 ] == separator ) { System . arraycopy ( array , i , array , i - 1 , size - i ) ; MST[rv.UOI2Mutator]MSP[N] size -- ; i -- ; } }
if ( octet . length () == 0 ) { emptyOctets ++ ; if ( emptyOctets > 1 ) { return false ; } } else { emptyOctets = 0 ; if ( index == octets . length - 1 && octet . contains ( lr_12 ) ) { MST[rv.CRCR6Mutator]MSP[S]
if ( ! REG_NAME_PART_PATTERN . matcher ( parts [ i ] ) . matches () ) { return false ; MST[rv.CRCR3Mutator]MSP[N] } } return true ; }
final List < String > octetList = new ArrayList <> ( Arrays . asList ( octets ) ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( inet6Address . endsWith ( lr_9 ) ) { octetList . add ( lr_11 ) ;
private static String doGetPath ( final String fileName , final int separatorAdd ) { if ( fileName == null ) { return null ; } final int prefix = getPrefixLength ( fileName ) ; if ( prefix < 0 ) { return null ; MST[ReturnValsMutator]MSP[S] }
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND ) { MST[rv.CRCR2Mutator]MSP[N] return len + 1 ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ; return Math . min ( posUnix , posWin ) + 1 ; }
if ( ipSegment . length () > 1 && ipSegment . startsWith ( lr_8 ) ) { return false ; } } return true ; MST[BooleanFalseReturnValsMutator]MSP[S] } private static boolean isIPv6Address ( final String inet6Address ) { final boolean containsCompressedZeroes = inet6Address . contains ( lr_9 ) ;
final List < String > octetList = new ArrayList <> ( Arrays . asList ( octets ) ) ; if ( inet6Address . endsWith ( lr_9 ) ) { MST[rv.ROR1Mutator]MSP[N] octetList . add ( lr_11 ) ;
for ( int i = prefix + 1 ; i < size ; i ++ ) { if ( array [ i ] == separator && array [ i - 1 ] == '.' && MST[rv.CRCR3Mutator]MSP[N]
if ( len == 2 || isSeparator ( fileName . charAt ( 2 ) ) == false ) { MST[rv.CRCR4Mutator]MSP[N] return 2 ; } return 3 ; } else if ( ch0 == UNIX_SEPARATOR ) { return 1 ; } return NOT_FOUND ;
for ( int i = 0 ; i < parts . length ; i ++ ) { if ( parts [ i ] . length () == 0 ) { MST[rv.ROR5Mutator]MSP[N] return i == parts . length - 1 ; }
if ( array [ i ] == separator && array [ i - 1 ] == separator ) { MST[rv.CRCR4Mutator]MSP[N] System . arraycopy ( array , i , array , i - 1 , size - i ) ; size -- ; i -- ; } }
if ( path . charAt ( i ) == 0 ) { MST[NonVoidMethodCallMutator]MSP[N] throw new IllegalArgumentException ( lr_3 + lr_4 ) ; } } } public static String getBaseName ( final String fileName ) { return removeExtension ( getName ( fileName ) ) ; }
for ( int i = prefix + 1 ; i < size ; i ++ ) { MST[rv.UOI4Mutator]MSP[N] if ( array [ i ] == separator && array [ i - 1 ] == '.' &&
return fileName . substring ( index + 1 ) ; MST[ReturnValsMutator]MSP[N] } private static int getAdsCriticalOffset ( final String fileName ) { final int offset1 = fileName . lastIndexOf ( SYSTEM_SEPARATOR ) ; final int offset2 = fileName . lastIndexOf ( OTHER_SEPARATOR ) ;
if ( i == prefix + 2 ) { MST[InlineConstantMutator]MSP[N] return null ; } if ( i == size - 1 ) { lastIsDirectory = true ; } int j ; for ( j = i - 4 ; j >= prefix ; j -- ) {
return fileName . substring ( index + 1 ) ; MST[rv.CRCR2Mutator]MSP[N] } private static void failIfNullBytePresent ( final String path ) { final int len = path . length () ; for ( int i = 0 ; i < len ; i ++ ) {
return fileName . substring ( index + 1 ) ; MST[rv.CRCR3Mutator]MSP[N] } private static int getAdsCriticalOffset ( final String fileName ) { final int offset1 = fileName . lastIndexOf ( SYSTEM_SEPARATOR ) ; final int offset2 = fileName . lastIndexOf ( OTHER_SEPARATOR ) ;
final char ch = basePath . charAt ( len - 1 ) ; MST[rv.AOR4Mutator]MSP[N] if ( isSeparator ( ch ) ) { return normalize ( basePath + fullFileNameToAdd ) ; } return normalize ( basePath + '/' + fullFileNameToAdd ) ; }
if ( len == 2 || isSeparator ( fileName . charAt ( 2 ) ) == false ) { return 2 ; MST[rv.CRCR3Mutator]MSP[N] } return 3 ; } else if ( ch0 == UNIX_SEPARATOR ) { return 1 ; } return NOT_FOUND ;
final char ch1 = fileName . charAt ( 1 ) ; if ( ch1 == ':' ) { ch0 = Character . toUpperCase ( ch0 ) ; if ( ch0 >= 'A' && ch0 <= 'Z' ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N]
if ( validOctets > IPV6_MAX_HEX_GROUPS || ( validOctets < IPV6_MAX_HEX_GROUPS && ! containsCompressedZeroes ) ) { MST[rv.CRCR2Mutator]MSP[N] return false ; } return true ; } private static boolean isRFC3986HostName ( final String name ) { final String [] parts = name . split ( lr_13 , - 1 ) ;
final int index = indexOfLastSeparator ( fileName ) ; if ( index < 0 ) { return fileName . substring ( 0 , prefix ) ; } int end = index + ( includeSeparator ? 1 : 0 ) ; MST[rv.CRCR5Mutator]MSP[N] if ( end == 0 ) { end ++ ;
( i == prefix + 1 || array [ i - 2 ] == separator ) ) { if ( i == size - 1 ) { MST[rv.CRCR2Mutator]MSP[N] lastIsDirectory = true ; }
|| ( inet6Address . endsWith ( lr_10 ) && ! inet6Address . endsWith ( lr_9 ) ) ) { MST[rv.ROR1Mutator]MSP[N] return false ; } String [] octets = inet6Address . split ( lr_10 ) ; if ( containsCompressedZeroes ) {
if ( octets . length > IPV6_MAX_HEX_GROUPS ) { return false ; MST[ReturnValsMutator]MSP[S] } int validOctets = 0 ; int emptyOctets = 0 ; for ( int index = 0 ; index < octets . length ; index ++ ) { final String octet = octets [ index ] ;
static boolean isSystemWindows () { return SYSTEM_SEPARATOR == WINDOWS_SEPARATOR ; } private static boolean isSeparator ( final char ch ) { return ch == UNIX_SEPARATOR || ch == WINDOWS_SEPARATOR ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } public static String normalize ( final String fileName ) {
if ( array [ i ] == separator && array [ i - 1 ] == '.' && array [ i - 2 ] == '.' && MST[rv.CRCR1Mutator]MSP[N] ( i == prefix + 2 || array [ i - 3 ] == separator ) ) {
int size = fileName . length () ; if ( size == 0 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return fileName ; } final int prefix = getPrefixLength ( fileName ) ; if ( prefix < 0 ) { return null ; }
final char ch = basePath . charAt ( len - 1 ) ; if ( isSeparator ( ch ) ) { return normalize ( basePath + fullFileNameToAdd ) ; } return normalize ( basePath + '/' + fullFileNameToAdd ) ; MST[InlineConstantMutator]MSP[N] }
final int index = indexOfLastSeparator ( fileName ) ; final int endIndex = index + separatorAdd ; if ( prefix >= fileName . length () || index < 0 || prefix >= endIndex ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] return EMPTY_STRING ; }
return indexOfExtension ( fileName ) == NOT_FOUND ; } final String fileExt = getExtension ( fileName ) ; for ( final String extension : extensions ) { if ( fileExt . equals ( extension ) ) { MST[NegateConditionalsMutator]MSP[N] return true ; } } return false ; }
textIdx = caseSensitivity . checkIndexOf ( fileName , textIdx , wcs [ wcsIdx ] ) ; if ( textIdx == NOT_FOUND ) { break; } final int repeat = caseSensitivity . checkIndexOf ( fileName , textIdx + 1 , wcs [ wcsIdx ] ) ; MST[rv.UOI4Mutator]MSP[N]
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2 ) { MST[rv.UOI4Mutator]MSP[N] return NOT_FOUND ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ;
final int lastSeparator = indexOfLastSeparator ( fileName ) ; return lastSeparator > extensionPos ? NOT_FOUND : extensionPos ; MST[ConditionalsBoundaryMutator]MSP[N] } public static String getPrefix ( final String fileName ) { if ( fileName == null ) { return null ; } final int len = getPrefixLength ( fileName ) ;
public static String getFullPathNoEndSeparator ( final String fileName ) { return doGetFullPath ( fileName , false ) ; } private static String doGetFullPath ( final String fileName , final boolean includeSeparator ) { if ( fileName == null ) { return null ; MST[ReturnValsMutator]MSP[N] }
return null ; MST[ReturnValsMutator]MSP[N] } return isSystemWindows () ? separatorsToWindows ( path ) : separatorsToUnix ( path ) ; } public static int getPrefixLength ( final String fileName ) { if ( fileName == null ) { return NOT_FOUND ; } final int len = fileName . length () ;
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND ) { return len + 1 ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ; return Math . min ( posUnix , posWin ) + 1 ; MST[rv.ABSMutator]MSP[N] }
return doNormalize ( fileName , separator , false ) ; MST[InlineConstantMutator]MSP[S] } private static String doNormalize ( final String fileName , final char separator , final boolean keepSeparator ) { if ( fileName == null ) { return null ; } failIfNullBytePresent ( fileName ) ;
System . arraycopy ( array , i + 1 , array , prefix , size - i ) ; MST[rv.CRCR2Mutator]MSP[N] size -= i + 1 - prefix ; i = prefix + 1 ; } } if ( size <= 0 ) { return EMPTY_STRING ; }
if ( array [ size - 1 ] != separator ) { array [ size ++ ] = separator ; lastIsDirectory = false ; } for ( int i = prefix + 1 ; i < size ; i ++ ) { MST[rv.CRCR4Mutator]MSP[N]
if ( array [ j ] == separator ) { System . arraycopy ( array , i + 1 , array , j + 1 , size - i ) ; size -= i - j ; MST[rv.UOI4Mutator]MSP[N] i = j + 1 ; continue outer; } }
if ( array [ i ] == separator && array [ i - 1 ] == separator ) { System . arraycopy ( array , i , array , i - 1 , size - i ) ; MST[rv.UOI1Mutator]MSP[N] size -- ; i -- ; } }
final int lastSeparator = indexOfLastSeparator ( fileName ) ; return lastSeparator > extensionPos ? NOT_FOUND : extensionPos ; MST[NegateConditionalsMutator]MSP[N] } public static String getPrefix ( final String fileName ) { if ( fileName == null ) { return null ; } final int len = getPrefixLength ( fileName ) ;
return null ; } return isSystemWindows () ? separatorsToWindows ( path ) : separatorsToUnix ( path ) ; MST[rv.ROR3Mutator]MSP[N] } public static int getPrefixLength ( final String fileName ) { if ( fileName == null ) { return NOT_FOUND ; } final int len = fileName . length () ;
if ( path == null || path . indexOf ( WINDOWS_SEPARATOR ) == NOT_FOUND ) { MST[rv.CRCR1Mutator]MSP[N] return path ; } return path . replace ( WINDOWS_SEPARATOR , UNIX_SEPARATOR ) ; } public static String separatorsToWindows ( final String path ) {
if ( i == prefix + 2 ) { return null ; } if ( i == size - 1 ) { lastIsDirectory = true ; MST[InlineConstantMutator]MSP[S] } int j ; for ( j = i - 4 ; j >= prefix ; j -- ) {
return false ; } static String [] splitOnTokens ( final String text ) { if ( text . indexOf ( '?' ) == NOT_FOUND && text . indexOf ( '*' ) == NOT_FOUND ) { MST[rv.CRCR1Mutator]MSP[N] return new String [] { text } ; }
private static boolean isIPv4Address ( final String name ) { final Matcher m = IPV4_PATTERN . matcher ( name ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( ! m . matches () || m . groupCount () != 4 ) { return false ; }
if ( ! REG_NAME_PART_PATTERN . matcher ( parts [ i ] ) . matches () ) { return false ; } } return true ; MST[ReturnValsMutator]MSP[N] }
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2 ) { return NOT_FOUND ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ; MST[rv.UOI4Mutator]MSP[N]
return wildcardMatch ( fileName , wildcardMatcher , IOCase . SYSTEM ) ; } public static boolean wildcardMatch ( final String fileName , final String wildcardMatcher , IOCase caseSensitivity ) { if ( fileName == null && wildcardMatcher == null ) { MST[rv.ROR5Mutator]MSP[N] return true ; }
textIdx += wcs [ wcsIdx ] . length () ; anyChars = false ; } wcsIdx ++ ; } if ( wcsIdx == wcs . length && textIdx == fileName . length () ) { return true ; MST[rv.CRCR3Mutator]MSP[N] } } while ( backtrack . size () > 0 );
if ( array [ i ] == separator && array [ i - 1 ] == '.' && array [ i - 2 ] == '.' && MST[rv.CRCR2Mutator]MSP[N] ( i == prefix + 2 || array [ i - 3 ] == separator ) ) {
if ( ! isIPv4Address ( octet ) ) { return false ; MST[ReturnValsMutator]MSP[N] } validOctets += 2 ; continue; } if ( octet . length () > IPV6_MAX_HEX_DIGITS_PER_GROUP ) { return false ; } int octetInt = 0 ; try {
final int lastWindowsPos = fileName . lastIndexOf ( WINDOWS_SEPARATOR ) ; MST[rv.CRCR5Mutator]MSP[N] return Math . max ( lastUnixPos , lastWindowsPos ) ; } public static int indexOfExtension ( final String fileName ) throws IllegalArgumentException { if ( fileName == null ) { return NOT_FOUND ; }
final int pos = Math . min ( posUnix , posWin ) + 1 ; final String hostnamePart = fileName . substring ( 2 , pos - 1 ) ; return isValidHostName ( hostnamePart ) ? pos : NOT_FOUND ; MST[ReturnValsMutator]MSP[N] } else {
if ( len < 0 ) { return null ; } if ( len > fileName . length () ) { failIfNullBytePresent ( fileName + UNIX_SEPARATOR ) ; return fileName + UNIX_SEPARATOR ; MST[NonVoidMethodCallMutator]MSP[N] } final String path = fileName . substring ( 0 , len ) ;
return isSeparator ( ch0 ) ? 1 : 0 ; MST[rv.CRCR2Mutator]MSP[N] } } public static int indexOfLastSeparator ( final String fileName ) { if ( fileName == null ) { return NOT_FOUND ; } final int lastUnixPos = fileName . lastIndexOf ( UNIX_SEPARATOR ) ;
return isSeparator ( ch0 ) ? 1 : 0 ; } } public static int indexOfLastSeparator ( final String fileName ) { if ( fileName == null ) { return NOT_FOUND ; MST[rv.CRCR1Mutator]MSP[N] } final int lastUnixPos = fileName . lastIndexOf ( UNIX_SEPARATOR ) ;
if ( len == 2 || isSeparator ( fileName . charAt ( 2 ) ) == false ) { return 2 ; } return 3 ; } else if ( ch0 == UNIX_SEPARATOR ) { MST[rv.CRCR1Mutator]MSP[N] return 1 ; } return NOT_FOUND ;
if ( ch == '?' || ch == '*' ) { if ( buffer . length () != 0 ) { list . add ( buffer . toString () ) ; buffer . setLength ( 0 ) ; } if ( ch == '?' ) { MST[rv.ROR3Mutator]MSP[N]
return wildcardMatch ( fileName , wildcardMatcher , IOCase . SYSTEM ) ; } public static boolean wildcardMatch ( final String fileName , final String wildcardMatcher , IOCase caseSensitivity ) { if ( fileName == null && wildcardMatcher == null ) { return true ; MST[rv.CRCR4Mutator]MSP[N] }
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2 ) { MST[rv.ROR4Mutator]MSP[N] return NOT_FOUND ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ;
if ( index == NOT_FOUND ) { MST[rv.UOI4Mutator]MSP[N] return fileName ; } return fileName . substring ( 0 , index ) ; } public static boolean equals ( final String fileName1 , final String fileName2 ) { return equals ( fileName1 , fileName2 , false , IOCase . SENSITIVE ) ;
if ( array [ i ] == separator && array [ i - 1 ] == '.' && array [ i - 2 ] == '.' && MST[rv.AOR3Mutator]MSP[N] ( i == prefix + 2 || array [ i - 3 ] == separator ) ) {
return equals ( fileName1 , fileName2 , true , IOCase . SENSITIVE ) ; } public static boolean equalsNormalizedOnSystem ( final String fileName1 , final String fileName2 ) { return equals ( fileName1 , fileName2 , true , IOCase . SYSTEM ) ; MST[NonVoidMethodCallMutator]MSP[N] } public static boolean equals (
return isSeparator ( ch0 ) ? 1 : 0 ; MST[rv.CRCR3Mutator]MSP[N] } if ( ch0 == '~' ) { int posUnix = fileName . indexOf ( UNIX_SEPARATOR , 1 ) ; int posWin = fileName . indexOf ( WINDOWS_SEPARATOR , 1 ) ;
private static String doGetPath ( final String fileName , final int separatorAdd ) { if ( fileName == null ) { return null ; } final int prefix = getPrefixLength ( fileName ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( prefix < 0 ) { return null ; }
final int index = indexOfLastSeparator ( fileName ) ; final int endIndex = index + separatorAdd ; if ( prefix >= fileName . length () || index < 0 || prefix >= endIndex ) { MST[NegateConditionalsMutator]MSP[N] return EMPTY_STRING ; }
final int pos = Math . min ( posUnix , posWin ) + 1 ; final String hostnamePart = fileName . substring ( 2 , pos - 1 ) ; return isValidHostName ( hostnamePart ) ? pos : NOT_FOUND ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } else {
final int index = indexOfLastSeparator ( fileName ) ; final int endIndex = index + separatorAdd ; MST[rv.UOI4Mutator]MSP[N] if ( prefix >= fileName . length () || index < 0 || prefix >= endIndex ) { return EMPTY_STRING ; }
if ( index == NOT_FOUND ) { return fileName ; } return fileName . substring ( 0 , index ) ; } public static boolean equals ( final String fileName1 , final String fileName2 ) { return equals ( fileName1 , fileName2 , false , IOCase . SENSITIVE ) ; MST[rv.CRCR1Mutator]MSP[S]
final char ch1 = fileName . charAt ( 1 ) ; if ( ch1 == ':' ) { MST[rv.UOI3Mutator]MSP[N] ch0 = Character . toUpperCase ( ch0 ) ; if ( ch0 >= 'A' && ch0 <= 'Z' ) {
final int prefix = getPrefixLength ( fileName ) ; if ( prefix < 0 ) { return null ; } if ( prefix >= fileName . length () ) { MST[rv.ROR4Mutator]MSP[N] if ( includeSeparator ) { return getPrefix ( fileName ) ; } return fileName ; }
final int lastSeparator = indexOfLastSeparator ( fileName ) ; return lastSeparator > extensionPos ? NOT_FOUND : extensionPos ; MST[rv.ROR5Mutator]MSP[S] } public static String getPrefix ( final String fileName ) { if ( fileName == null ) { return null ; } final int len = getPrefixLength ( fileName ) ;
if ( validOctets > IPV6_MAX_HEX_GROUPS || ( validOctets < IPV6_MAX_HEX_GROUPS && ! containsCompressedZeroes ) ) { MST[rv.UOI2Mutator]MSP[N] return false ; } return true ; } private static boolean isRFC3986HostName ( final String name ) { final String [] parts = name . split ( lr_13 , - 1 ) ;
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2 ) { return NOT_FOUND ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; MST[rv.UOI4Mutator]MSP[N] posWin = posWin == NOT_FOUND ? posUnix : posWin ;
if ( len < 0 ) { return null ; } if ( len > fileName . length () ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] failIfNullBytePresent ( fileName + UNIX_SEPARATOR ) ; return fileName + UNIX_SEPARATOR ; } final String path = fileName . substring ( 0 , len ) ;
if ( array [ i ] == separator && array [ i - 1 ] == '.' && array [ i - 2 ] == '.' && MST[rv.UOI3Mutator]MSP[N] ( i == prefix + 2 || array [ i - 3 ] == separator ) ) {
return indexOfExtension ( fileName ) == NOT_FOUND ; } final String fileExt = getExtension ( fileName ) ; for ( final String extension : extensions ) { MST[rv.UOI3Mutator]MSP[N] if ( fileExt . equals ( extension ) ) { return true ; } } return false ; }
System . arraycopy ( array , i + 1 , array , prefix , size - i ) ; size -= i + 1 - prefix ; i = prefix + 1 ; } } if ( size <= 0 ) { MST[rv.ROR2Mutator]MSP[N] return EMPTY_STRING ; }
if ( array [ i ] == separator && array [ i - 1 ] == '.' && array [ i - 2 ] == '.' && MST[rv.CRCR4Mutator]MSP[N] ( i == prefix + 2 || array [ i - 3 ] == separator ) ) {
return indexOfExtension ( fileName ) == NOT_FOUND ; } final String fileExt = getExtension ( fileName ) ; for ( final String extension : extensions ) { if ( fileExt . equals ( extension ) ) { return true ; MST[rv.CRCR3Mutator]MSP[N] } } return false ; }
final char [] array = text . toCharArray () ; final ArrayList < String > list = new ArrayList <> () ; final StringBuilder buffer = new StringBuilder () ; char prevChar = 0 ; for ( final char ch : array ) { MST[rv.UOI4Mutator]MSP[N]
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2 ) { MST[rv.ROR2Mutator]MSP[N] return NOT_FOUND ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ;
octetInt = Integer . parseInt ( octet , BASE_16 ) ; } catch ( final NumberFormatException e ) { return false ; } if ( octetInt < 0 || octetInt > MAX_UNSIGNED_SHORT ) { MST[ConditionalsBoundaryMutator]MSP[N] return false ; } } validOctets ++ ; }
if ( isSystemWindows () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] final int offset = fileName . indexOf ( ':' , getAdsCriticalOffset ( fileName ) ) ; if ( offset != - 1 ) { throw new IllegalArgumentException ( lr_2 ) ; } } final int extensionPos = fileName . lastIndexOf ( EXTENSION_SEPARATOR ) ;
if ( len < 0 ) { MST[ConditionalsBoundaryMutator]MSP[N] return null ; } if ( len > fileName . length () ) { failIfNullBytePresent ( fileName + UNIX_SEPARATOR ) ; return fileName + UNIX_SEPARATOR ; } final String path = fileName . substring ( 0 , len ) ;
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND ) { return len + 1 ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ; return Math . min ( posUnix , posWin ) + 1 ; MST[ArgumentPropagationMutator]MSP[N] }
textIdx += wcs [ wcsIdx ] . length () ; MST[rv.UOI3Mutator]MSP[N] anyChars = false ; } wcsIdx ++ ; } if ( wcsIdx == wcs . length && textIdx == fileName . length () ) { return true ; } } while ( backtrack . size () > 0 );
for ( int i = prefix + 1 ; i < size ; i ++ ) { if ( array [ i ] == separator && array [ i - 1 ] == '.' && MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
return false ; } static String [] splitOnTokens ( final String text ) { if ( text . indexOf ( '?' ) == NOT_FOUND && text . indexOf ( '*' ) == NOT_FOUND ) { MST[rv.CRCR5Mutator]MSP[N] return new String [] { text } ; }
return null ; } return isSystemWindows () ? separatorsToWindows ( path ) : separatorsToUnix ( path ) ; } public static int getPrefixLength ( final String fileName ) { if ( fileName == null ) { return NOT_FOUND ; MST[rv.CRCR1Mutator]MSP[N] } final int len = fileName . length () ;
final int index = indexOfLastSeparator ( fileName ) ; if ( index < 0 ) { MST[rv.UOI4Mutator]MSP[N] return fileName . substring ( 0 , prefix ) ; } int end = index + ( includeSeparator ? 1 : 0 ) ; if ( end == 0 ) { end ++ ;
private static boolean isIPv4Address ( final String name ) { final Matcher m = IPV4_PATTERN . matcher ( name ) ; if ( ! m . matches () || m . groupCount () != 4 ) { MST[rv.CRCR1Mutator]MSP[S] return false ; }
static boolean isSystemWindows () { return SYSTEM_SEPARATOR == WINDOWS_SEPARATOR ; } private static boolean isSeparator ( final char ch ) { return ch == UNIX_SEPARATOR || ch == WINDOWS_SEPARATOR ; MST[rv.CRCR2Mutator]MSP[N] } public static String normalize ( final String fileName ) {
System . arraycopy ( array , i + 1 , array , prefix , size - i ) ; MST[rv.UOI2Mutator]MSP[N] size -= i + 1 - prefix ; i = prefix + 1 ; } } if ( size <= 0 ) { return EMPTY_STRING ; }
final int index = indexOfLastSeparator ( fileName ) ; final int endIndex = index + separatorAdd ; if ( prefix >= fileName . length () || index < 0 || prefix >= endIndex ) { MST[rv.UOI2Mutator]MSP[S] return EMPTY_STRING ; }
String fileName1 , String fileName2 , final boolean normalized , IOCase caseSensitivity ) { if ( fileName1 == null || fileName2 == null ) { return fileName1 == null && fileName2 == null ; MST[rv.CRCR1Mutator]MSP[N] } if ( normalized ) { fileName1 = normalize ( fileName1 ) ;
System . arraycopy ( array , i + 1 , array , i - 1 , size - i ) ; MST[rv.AOR4Mutator]MSP[N] size -= 2 ; i -- ; } } outer: for ( int i = prefix + 2 ; i < size ; i ++ ) {
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND ) { MST[NegateConditionalsMutator]MSP[N] return len + 1 ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ; return Math . min ( posUnix , posWin ) + 1 ; }
return isSeparator ( ch0 ) ? 1 : 0 ; } if ( ch0 == '~' ) { MST[rv.ROR2Mutator]MSP[N] int posUnix = fileName . indexOf ( UNIX_SEPARATOR , 1 ) ; int posWin = fileName . indexOf ( WINDOWS_SEPARATOR , 1 ) ;
if ( octet . length () == 0 ) { emptyOctets ++ ; if ( emptyOctets > 1 ) { return false ; } } else { emptyOctets = 0 ; if ( index == octets . length - 1 && octet . contains ( lr_12 ) ) { MST[rv.AOD2Mutator]MSP[S]
if ( path == null || path . indexOf ( WINDOWS_SEPARATOR ) == NOT_FOUND ) { return path ; } return path . replace ( WINDOWS_SEPARATOR , UNIX_SEPARATOR ) ; MST[EmptyObjectReturnValsMutator]MSP[N] } public static String separatorsToWindows ( final String path ) {
if ( len == 2 || isSeparator ( fileName . charAt ( 2 ) ) == false ) { return 2 ; } return 3 ; MST[PrimitiveReturnsMutator]MSP[N] } else if ( ch0 == UNIX_SEPARATOR ) { return 1 ; } return NOT_FOUND ;
for ( int i = 1 ; i <= 4 ; i ++ ) { final String ipSegment = m . group ( i ) ; final int iIpSegment = Integer . parseInt ( ipSegment ) ; if ( iIpSegment > IPV4_MAX_OCTET_VALUE ) { MST[rv.ROR2Mutator]MSP[S] return false ; }
if ( array [ i ] == separator && array [ i - 1 ] == '.' && array [ i - 2 ] == '.' && MST[rv.ROR1Mutator]MSP[N] ( i == prefix + 2 || array [ i - 3 ] == separator ) ) {
} else if ( isSeparator ( ch0 ) && isSeparator ( ch1 ) ) { int posUnix = fileName . indexOf ( UNIX_SEPARATOR , 2 ) ; MST[rv.CRCR3Mutator]MSP[N] int posWin = fileName . indexOf ( WINDOWS_SEPARATOR , 2 ) ;
if ( IOCase . SYSTEM . checkEquals ( canonicalParent , canonicalChild ) ) { MST[rv.ROR1Mutator]MSP[N] return false ; } return IOCase . SYSTEM . checkStartsWith ( canonicalChild , canonicalParent ) ; } public static String separatorsToUnix ( final String path ) {
System . arraycopy ( array , i + 1 , array , i - 1 , size - i ) ; MST[rv.UOI4Mutator]MSP[N] size -= 2 ; i -- ; } } outer: for ( int i = prefix + 2 ; i < size ; i ++ ) {
int size = fileName . length () ; if ( size == 0 ) { return fileName ; } final int prefix = getPrefixLength ( fileName ) ; if ( prefix < 0 ) { MST[rv.ROR2Mutator]MSP[N] return null ; }
if ( array [ i ] == separator && array [ i - 1 ] == '.' && array [ i - 2 ] == '.' && MST[rv.UOI1Mutator]MSP[N] ( i == prefix + 2 || array [ i - 3 ] == separator ) ) {
final int index = indexOfLastSeparator ( fileName ) ; if ( index < 0 ) { return fileName . substring ( 0 , prefix ) ; } int end = index + ( includeSeparator ? 1 : 0 ) ; if ( end == 0 ) { MST[NegateConditionalsMutator]MSP[N] end ++ ;
return isSeparator ( ch0 ) ? 1 : 0 ; MST[InlineConstantMutator]MSP[N] } if ( ch0 == '~' ) { int posUnix = fileName . indexOf ( UNIX_SEPARATOR , 1 ) ; int posWin = fileName . indexOf ( WINDOWS_SEPARATOR , 1 ) ;
|| ( inet6Address . endsWith ( lr_10 ) && ! inet6Address . endsWith ( lr_9 ) ) ) { MST[NegateConditionalsMutator]MSP[S] return false ; } String [] octets = inet6Address . split ( lr_10 ) ; if ( containsCompressedZeroes ) {
if ( array [ i ] == separator && array [ i - 1 ] == separator ) { MST[rv.ROR1Mutator]MSP[N] System . arraycopy ( array , i , array , i - 1 , size - i ) ; size -- ; i -- ; } }
if ( size <= prefix ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] return new String ( array , 0 , size ) ; } if ( lastIsDirectory && keepSeparator ) { return new String ( array , 0 , size ) ; }
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND ) { return len + 1 ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ; MST[rv.ROR5Mutator]MSP[N] return Math . min ( posUnix , posWin ) + 1 ; }
if ( repeat >= 0 ) { backtrack . push ( new int [] { wcsIdx , repeat } ) ; MST[rv.UOI2Mutator]MSP[N] } } else { if ( ! caseSensitivity . checkRegionMatches ( fileName , textIdx , wcs [ wcsIdx ] ) ) { break; } }
return false ; } static String [] splitOnTokens ( final String text ) { if ( text . indexOf ( '?' ) == NOT_FOUND && text . indexOf ( '*' ) == NOT_FOUND ) { MST[rv.CRCR3Mutator]MSP[N] return new String [] { text } ; }
static boolean isSystemWindows () { return SYSTEM_SEPARATOR == WINDOWS_SEPARATOR ; } private static boolean isSeparator ( final char ch ) { return ch == UNIX_SEPARATOR || ch == WINDOWS_SEPARATOR ; MST[rv.UOI3Mutator]MSP[N] } public static String normalize ( final String fileName ) {
for ( int i = prefix + 1 ; i < size ; i ++ ) { if ( array [ i ] == separator && array [ i - 1 ] == '.' && MST[rv.CRCR4Mutator]MSP[N]
System . arraycopy ( array , i + 1 , array , prefix , size - i ) ; size -= i + 1 - prefix ; MST[rv.AOR1Mutator]MSP[N] i = prefix + 1 ; } } if ( size <= 0 ) { return EMPTY_STRING ; }
return isSeparator ( ch0 ) ? 1 : 0 ; MST[rv.ROR2Mutator]MSP[S] } } public static int indexOfLastSeparator ( final String fileName ) { if ( fileName == null ) { return NOT_FOUND ; } final int lastUnixPos = fileName . lastIndexOf ( UNIX_SEPARATOR ) ;
int wcsIdx = 0 ; final Stack < int [] > backtrack = new Stack <> () ; do { if ( backtrack . size () > 0 ) { MST[rv.ROR2Mutator]MSP[N] final int [] array = backtrack . pop () ; wcsIdx = array [ 0 ] ;
if ( array [ i ] == separator && array [ i - 1 ] == '.' && array [ i - 2 ] == '.' && MST[rv.ROR2Mutator]MSP[N] ( i == prefix + 2 || array [ i - 3 ] == separator ) ) {
if ( ch == '?' || ch == '*' ) { if ( buffer . length () != 0 ) { list . add ( buffer . toString () ) ; buffer . setLength ( 0 ) ; } if ( ch == '?' ) { MST[rv.UOI3Mutator]MSP[N]
for ( int i = prefix + 1 ; i < size ; i ++ ) { if ( array [ i ] == separator && array [ i - 1 ] == '.' && MST[rv.ABSMutator]MSP[N]
list . add ( buffer . toString () ) ; } return list . toArray ( new String [ list . size () ] ) ; } private static boolean isValidHostName ( final String name ) { return isIPv6Address ( name ) || isRFC3986HostName ( name ) ; MST[NonVoidMethodCallMutator]MSP[N] }
final char ch = basePath . charAt ( len - 1 ) ; if ( isSeparator ( ch ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return normalize ( basePath + fullFileNameToAdd ) ; } return normalize ( basePath + '/' + fullFileNameToAdd ) ; }
final int lastWindowsPos = fileName . lastIndexOf ( WINDOWS_SEPARATOR ) ; return Math . max ( lastUnixPos , lastWindowsPos ) ; } public static int indexOfExtension ( final String fileName ) throws IllegalArgumentException { if ( fileName == null ) { return NOT_FOUND ; MST[PrimitiveReturnsMutator]MSP[N] }
if ( octets . length > IPV6_MAX_HEX_GROUPS ) { return false ; } int validOctets = 0 ; int emptyOctets = 0 ; for ( int index = 0 ; index < octets . length ; index ++ ) { MST[rv.CRCR5Mutator]MSP[N] final String octet = octets [ index ] ;
if ( array [ i ] == separator && array [ i - 1 ] == separator ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] System . arraycopy ( array , i , array , i - 1 , size - i ) ; size -- ; i -- ; } }
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2 ) { MST[InlineConstantMutator]MSP[N] return NOT_FOUND ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ;
for ( int i = prefix + 1 ; i < size ; i ++ ) { if ( array [ i ] == separator && array [ i - 1 ] == '.' && MST[rv.ABSMutator]MSP[N]
return doNormalize ( fileName , SYSTEM_SEPARATOR , true ) ; } public static String normalize ( final String fileName , final boolean unixSeparator ) { final char separator = unixSeparator ? UNIX_SEPARATOR : WINDOWS_SEPARATOR ; MST[rv.CRCR6Mutator]MSP[N] return doNormalize ( fileName , separator , true ) ; }
if ( array [ i ] == separator && array [ i - 1 ] == separator ) { MST[rv.UOI3Mutator]MSP[N] System . arraycopy ( array , i , array , i - 1 , size - i ) ; size -- ; i -- ; } }
textIdx = array [ 1 ] ; anyChars = true ; } while ( wcsIdx < wcs . length ) { if ( wcs [ wcsIdx ] . equals ( lr_6 ) ) { MST[rv.UOI1Mutator]MSP[N] textIdx ++ ; if ( textIdx > fileName . length () ) { break; }
} return fileName . substring ( 0 , end ) ; MST[rv.UOI2Mutator]MSP[N] } public static String getName ( final String fileName ) { if ( fileName == null ) { return null ; } failIfNullBytePresent ( fileName ) ; final int index = indexOfLastSeparator ( fileName ) ;
final int lastSeparator = indexOfLastSeparator ( fileName ) ; return lastSeparator > extensionPos ? NOT_FOUND : extensionPos ; MST[rv.UOI4Mutator]MSP[N] } public static String getPrefix ( final String fileName ) { if ( fileName == null ) { return null ; } final int len = getPrefixLength ( fileName ) ;
if ( array [ i ] == separator && array [ i - 1 ] == '.' && array [ i - 2 ] == '.' && MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] ( i == prefix + 2 || array [ i - 3 ] == separator ) ) {
list . add ( lr_6 ) ; } else if ( prevChar != '*' ) { list . add ( lr_7 ) ; } } else { buffer . append ( ch ) ; MST[rv.ABSMutator]MSP[N] } prevChar = ch ; } if ( buffer . length () != 0 ) {
if ( octets . length > IPV6_MAX_HEX_GROUPS ) { MST[rv.CRCR5Mutator]MSP[N] return false ; } int validOctets = 0 ; int emptyOctets = 0 ; for ( int index = 0 ; index < octets . length ; index ++ ) { final String octet = octets [ index ] ;
private static String doGetPath ( final String fileName , final int separatorAdd ) { if ( fileName == null ) { return null ; } final int prefix = getPrefixLength ( fileName ) ; if ( prefix < 0 ) { MST[rv.UOI3Mutator]MSP[N] return null ; }
for ( int i = 1 ; i <= 4 ; i ++ ) { final String ipSegment = m . group ( i ) ; MST[rv.UOI3Mutator]MSP[N] final int iIpSegment = Integer . parseInt ( ipSegment ) ; if ( iIpSegment > IPV4_MAX_OCTET_VALUE ) { return false ; }
final int lastWindowsPos = fileName . lastIndexOf ( WINDOWS_SEPARATOR ) ; return Math . max ( lastUnixPos , lastWindowsPos ) ; } public static int indexOfExtension ( final String fileName ) throws IllegalArgumentException { if ( fileName == null ) { return NOT_FOUND ; MST[rv.CRCR6Mutator]MSP[N] }
private static String doGetPath ( final String fileName , final int separatorAdd ) { if ( fileName == null ) { return null ; } final int prefix = getPrefixLength ( fileName ) ; if ( prefix < 0 ) { MST[rv.ROR4Mutator]MSP[N] return null ; }
octetInt = Integer . parseInt ( octet , BASE_16 ) ; } catch ( final NumberFormatException e ) { return false ; } if ( octetInt < 0 || octetInt > MAX_UNSIGNED_SHORT ) { MST[InlineConstantMutator]MSP[N] return false ; } } validOctets ++ ; }
if ( index == NOT_FOUND ) { return fileName ; } return fileName . substring ( 0 , index ) ; } public static boolean equals ( final String fileName1 , final String fileName2 ) { return equals ( fileName1 , fileName2 , false , IOCase . SENSITIVE ) ; MST[BooleanTrueReturnValsMutator]MSP[N]
if ( validOctets > IPV6_MAX_HEX_GROUPS || ( validOctets < IPV6_MAX_HEX_GROUPS && ! containsCompressedZeroes ) ) { MST[rv.ROR5Mutator]MSP[S] return false ; } return true ; } private static boolean isRFC3986HostName ( final String name ) { final String [] parts = name . split ( lr_13 , - 1 ) ;
if ( len < 0 ) { return null ; } if ( len > fileName . length () ) { failIfNullBytePresent ( fileName + UNIX_SEPARATOR ) ; return fileName + UNIX_SEPARATOR ; MST[experimental.NakedReceiverMutator]MSP[N] } final String path = fileName . substring ( 0 , len ) ;
if ( array [ i ] == separator && array [ i - 1 ] == '.' && array [ i - 2 ] == '.' && MST[rv.UOI1Mutator]MSP[N] ( i == prefix + 2 || array [ i - 3 ] == separator ) ) {
if ( ! isIPv4Address ( octet ) ) { return false ; } validOctets += 2 ; continue; } if ( octet . length () > IPV6_MAX_HEX_DIGITS_PER_GROUP ) { MST[rv.ROR3Mutator]MSP[N] return false ; } int octetInt = 0 ; try {
final char ch = basePath . charAt ( len - 1 ) ; if ( isSeparator ( ch ) ) { return normalize ( basePath + fullFileNameToAdd ) ; } return normalize ( basePath + '/' + fullFileNameToAdd ) ; MST[rv.CRCR3Mutator]MSP[N] }
if ( prefix > 0 ) { return normalize ( fullFileNameToAdd ) ; } if ( basePath == null ) { return null ; } final int len = basePath . length () ; if ( len == 0 ) { return normalize ( fullFileNameToAdd ) ; MST[EmptyObjectReturnValsMutator]MSP[N] }
final int lastSeparator = indexOfLastSeparator ( fileName ) ; return lastSeparator > extensionPos ? NOT_FOUND : extensionPos ; MST[rv.CRCR5Mutator]MSP[N] } public static String getPrefix ( final String fileName ) { if ( fileName == null ) { return null ; } final int len = getPrefixLength ( fileName ) ;
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND ) { return len + 1 ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; MST[rv.ROR2Mutator]MSP[N] posWin = posWin == NOT_FOUND ? posUnix : posWin ; return Math . min ( posUnix , posWin ) + 1 ; }
if ( extension == null || extension . isEmpty () ) { return indexOfExtension ( fileName ) == NOT_FOUND ; MST[BooleanTrueReturnValsMutator]MSP[S] } final String fileExt = getExtension ( fileName ) ; return fileExt . equals ( extension ) ; }
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND ) { return len + 1 ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ; return Math . min ( posUnix , posWin ) + 1 ; MST[MathMutator]MSP[N] }
final int index = indexOfLastSeparator ( fileName ) ; final int endIndex = index + separatorAdd ; MST[rv.AOD2Mutator]MSP[N] if ( prefix >= fileName . length () || index < 0 || prefix >= endIndex ) { return EMPTY_STRING ; }
textIdx = array [ 1 ] ; anyChars = true ; } while ( wcsIdx < wcs . length ) { if ( wcs [ wcsIdx ] . equals ( lr_6 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] textIdx ++ ; if ( textIdx > fileName . length () ) { break; }
if ( octet . length () == 0 ) { emptyOctets ++ ; if ( emptyOctets > 1 ) { MST[rv.ROR4Mutator]MSP[N] return false ; } } else { emptyOctets = 0 ; if ( index == octets . length - 1 && octet . contains ( lr_12 ) ) {
public static String normalizeNoEndSeparator ( final String fileName ) { return doNormalize ( fileName , SYSTEM_SEPARATOR , false ) ; MST[rv.CRCR1Mutator]MSP[S] } public static String normalizeNoEndSeparator ( final String fileName , final boolean unixSeparator ) { final char separator = unixSeparator ? UNIX_SEPARATOR : WINDOWS_SEPARATOR ;
if ( extension == null || extension . isEmpty () ) { return indexOfExtension ( fileName ) == NOT_FOUND ; MST[rv.CRCR5Mutator]MSP[N] } final String fileExt = getExtension ( fileName ) ; return fileExt . equals ( extension ) ; }
int wcsIdx = 0 ; final Stack < int [] > backtrack = new Stack <> () ; MST[ConstructorCallMutator]MSP[N] do { if ( backtrack . size () > 0 ) { final int [] array = backtrack . pop () ; wcsIdx = array [ 0 ] ;
public static boolean isExtension ( final String fileName , final Collection < String > extensions ) { if ( fileName == null ) { return false ; MST[rv.CRCR1Mutator]MSP[N] } failIfNullBytePresent ( fileName ) ; if ( extensions == null || extensions . isEmpty () ) {
return equals ( fileName1 , fileName2 , true , IOCase . SENSITIVE ) ; MST[ArgumentPropagationMutator]MSP[N] } public static boolean equalsNormalizedOnSystem ( final String fileName1 , final String fileName2 ) { return equals ( fileName1 , fileName2 , true , IOCase . SYSTEM ) ; } public static boolean equals (
System . arraycopy ( array , i + 1 , array , prefix , size - i ) ; size -= i + 1 - prefix ; i = prefix + 1 ; MST[rv.CRCR6Mutator]MSP[N] } } if ( size <= 0 ) { return EMPTY_STRING ; }
textIdx += wcs [ wcsIdx ] . length () ; anyChars = false ; } wcsIdx ++ ; } if ( wcsIdx == wcs . length && textIdx == fileName . length () ) { MST[rv.UOI1Mutator]MSP[N] return true ; } } while ( backtrack . size () > 0 );
|| ( inet6Address . endsWith ( lr_10 ) && ! inet6Address . endsWith ( lr_9 ) ) ) { MST[rv.ROR5Mutator]MSP[S] return false ; } String [] octets = inet6Address . split ( lr_10 ) ; if ( containsCompressedZeroes ) {
final char [] array = new char [ size + 2 ] ; fileName . getChars ( 0 , fileName . length () , array , 0 ) ; final char otherSeparator = separator == SYSTEM_SEPARATOR ? OTHER_SEPARATOR : SYSTEM_SEPARATOR ; MST[rv.UOI2Mutator]MSP[N]
if ( octet . length () == 0 ) { emptyOctets ++ ; if ( emptyOctets > 1 ) { return false ; } } else { emptyOctets = 0 ; if ( index == octets . length - 1 && octet . contains ( lr_12 ) ) { MST[rv.AOR4Mutator]MSP[S]
static boolean isSystemWindows () { return SYSTEM_SEPARATOR == WINDOWS_SEPARATOR ; } private static boolean isSeparator ( final char ch ) { return ch == UNIX_SEPARATOR || ch == WINDOWS_SEPARATOR ; MST[rv.CRCR5Mutator]MSP[N] } public static String normalize ( final String fileName ) {
if ( size <= prefix ) { return new String ( array , 0 , size ) ; } if ( lastIsDirectory && keepSeparator ) { return new String ( array , 0 , size ) ; MST[rv.UOI1Mutator]MSP[N] }
if ( ! isIPv4Address ( octet ) ) { return false ; } validOctets += 2 ; continue; } if ( octet . length () > IPV6_MAX_HEX_DIGITS_PER_GROUP ) { MST[InlineConstantMutator]MSP[N] return false ; } int octetInt = 0 ; try {
fileName2 = normalize ( fileName2 ) ; if ( fileName1 == null || fileName2 == null ) { throw new NullPointerException ( lr_5 ) ; } } if ( caseSensitivity == null ) { MST[NegateConditionalsMutator]MSP[N] caseSensitivity = IOCase . SENSITIVE ; }
private static boolean isIPv4Address ( final String name ) { final Matcher m = IPV4_PATTERN . matcher ( name ) ; if ( ! m . matches () || m . groupCount () != 4 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return false ; }
if ( size <= prefix ) { return new String ( array , 0 , size ) ; MST[ReturnValsMutator]MSP[N] } if ( lastIsDirectory && keepSeparator ) { return new String ( array , 0 , size ) ; }
} else if ( isSeparator ( ch0 ) && isSeparator ( ch1 ) ) { MST[rv.ROR1Mutator]MSP[N] int posUnix = fileName . indexOf ( UNIX_SEPARATOR , 2 ) ; int posWin = fileName . indexOf ( WINDOWS_SEPARATOR , 2 ) ;
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND ) { MST[rv.UOI1Mutator]MSP[N] return len + 1 ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ; return Math . min ( posUnix , posWin ) + 1 ; }
final int pos = Math . min ( posUnix , posWin ) + 1 ; MST[rv.CRCR6Mutator]MSP[N] final String hostnamePart = fileName . substring ( 2 , pos - 1 ) ; return isValidHostName ( hostnamePart ) ? pos : NOT_FOUND ; } else {
if ( ch == '?' || ch == '*' ) { if ( buffer . length () != 0 ) { MST[rv.ROR4Mutator]MSP[N] list . add ( buffer . toString () ) ; buffer . setLength ( 0 ) ; } if ( ch == '?' ) {
|| ( inet6Address . endsWith ( lr_10 ) && ! inet6Address . endsWith ( lr_9 ) ) ) { return false ; MST[ReturnValsMutator]MSP[S] } String [] octets = inet6Address . split ( lr_10 ) ; if ( containsCompressedZeroes ) {
for ( int i = 0 ; i < array . length ; i ++ ) { MST[rv.UOI2Mutator]MSP[N] if ( array [ i ] == otherSeparator ) { array [ i ] = separator ; } } boolean lastIsDirectory = true ;
} return fileName . substring ( 0 , end ) ; MST[EmptyObjectReturnValsMutator]MSP[N] } public static String getName ( final String fileName ) { if ( fileName == null ) { return null ; } failIfNullBytePresent ( fileName ) ; final int index = indexOfLastSeparator ( fileName ) ;
if ( validOctets > IPV6_MAX_HEX_GROUPS || ( validOctets < IPV6_MAX_HEX_GROUPS && ! containsCompressedZeroes ) ) { MST[NegateConditionalsMutator]MSP[S] return false ; } return true ; } private static boolean isRFC3986HostName ( final String name ) { final String [] parts = name . split ( lr_13 , - 1 ) ;
for ( int i = 0 ; i < array . length ; i ++ ) { if ( array [ i ] == otherSeparator ) { MST[rv.UOI1Mutator]MSP[N] array [ i ] = separator ; } } boolean lastIsDirectory = true ;
if ( array [ j ] == separator ) { System . arraycopy ( array , i + 1 , array , j + 1 , size - i ) ; MST[rv.UOI3Mutator]MSP[N] size -= i - j ; i = j + 1 ; continue outer; } }
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND ) { MST[rv.CRCR6Mutator]MSP[N] return len + 1 ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ; return Math . min ( posUnix , posWin ) + 1 ; }
if ( array [ j ] == separator ) { System . arraycopy ( array , i + 1 , array , j + 1 , size - i ) ; size -= i - j ; MST[rv.AOD2Mutator]MSP[N] i = j + 1 ; continue outer; } }
String fileName1 , String fileName2 , final boolean normalized , IOCase caseSensitivity ) { if ( fileName1 == null || fileName2 == null ) { return fileName1 == null && fileName2 == null ; } if ( normalized ) { MST[rv.ROR1Mutator]MSP[S] fileName1 = normalize ( fileName1 ) ;
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2 ) { return NOT_FOUND ; MST[rv.CRCR6Mutator]MSP[S] } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ;
final int index = indexOfLastSeparator ( fileName ) ; final int endIndex = index + separatorAdd ; MST[rv.AOR4Mutator]MSP[N] if ( prefix >= fileName . length () || index < 0 || prefix >= endIndex ) { return EMPTY_STRING ; }
textIdx += wcs [ wcsIdx ] . length () ; anyChars = false ; } wcsIdx ++ ; } if ( wcsIdx == wcs . length && textIdx == fileName . length () ) { MST[rv.ROR4Mutator]MSP[N] return true ; } } while ( backtrack . size () > 0 );
return doNormalize ( fileName , separator , false ) ; MST[rv.UOI2Mutator]MSP[N] } private static String doNormalize ( final String fileName , final char separator , final boolean keepSeparator ) { if ( fileName == null ) { return null ; } failIfNullBytePresent ( fileName ) ;
for ( int i = 0 ; i < array . length ; i ++ ) { MST[rv.CRCR1Mutator]MSP[N] if ( array [ i ] == otherSeparator ) { array [ i ] = separator ; } } boolean lastIsDirectory = true ;
if ( i == prefix + 2 ) { MST[rv.ROR2Mutator]MSP[N] return null ; } if ( i == size - 1 ) { lastIsDirectory = true ; } int j ; for ( j = i - 4 ; j >= prefix ; j -- ) {
if ( size <= prefix ) { return new String ( array , 0 , size ) ; } if ( lastIsDirectory && keepSeparator ) { MST[rv.ROR4Mutator]MSP[N] return new String ( array , 0 , size ) ; }
for ( int i = 0 ; i < array . length ; i ++ ) { MST[rv.ABSMutator]MSP[N] if ( array [ i ] == otherSeparator ) { array [ i ] = separator ; } } boolean lastIsDirectory = true ;
if ( len == 0 ) { return 0 ; } char ch0 = fileName . charAt ( 0 ) ; if ( ch0 == ':' ) { return NOT_FOUND ; } if ( len == 1 ) { if ( ch0 == '~' ) { MST[rv.CRCR2Mutator]MSP[N] return 2 ; }
octetInt = Integer . parseInt ( octet , BASE_16 ) ; } catch ( final NumberFormatException e ) { return false ; } if ( octetInt < 0 || octetInt > MAX_UNSIGNED_SHORT ) { MST[rv.ROR3Mutator]MSP[N] return false ; } } validOctets ++ ; }
if ( len == 2 || isSeparator ( fileName . charAt ( 2 ) ) == false ) { return 2 ; } return 3 ; } else if ( ch0 == UNIX_SEPARATOR ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return 1 ; } return NOT_FOUND ;
if ( octet . length () == 0 ) { emptyOctets ++ ; if ( emptyOctets > 1 ) { return false ; } } else { emptyOctets = 0 ; if ( index == octets . length - 1 && octet . contains ( lr_12 ) ) { MST[rv.ROR4Mutator]MSP[S]
return fileName . substring ( index + 1 ) ; MST[InlineConstantMutator]MSP[N] } private static int getAdsCriticalOffset ( final String fileName ) { final int offset1 = fileName . lastIndexOf ( SYSTEM_SEPARATOR ) ; final int offset2 = fileName . lastIndexOf ( OTHER_SEPARATOR ) ;
return isSeparator ( ch0 ) ? 1 : 0 ; MST[rv.CRCR6Mutator]MSP[N] } if ( ch0 == '~' ) { int posUnix = fileName . indexOf ( UNIX_SEPARATOR , 1 ) ; int posWin = fileName . indexOf ( WINDOWS_SEPARATOR , 1 ) ;
final char [] array = new char [ size + 2 ] ; fileName . getChars ( 0 , fileName . length () , array , 0 ) ; final char otherSeparator = separator == SYSTEM_SEPARATOR ? OTHER_SEPARATOR : SYSTEM_SEPARATOR ; MST[rv.ABSMutator]MSP[N]
if ( containsCompressedZeroes && ( inet6Address . indexOf ( lr_9 ) != inet6Address . lastIndexOf ( lr_9 ) ) ) { MST[NegateConditionalsMutator]MSP[S] return false ; } if ( ( inet6Address . startsWith ( lr_10 ) && ! inet6Address . startsWith ( lr_9 ) )
textIdx = array [ 1 ] ; anyChars = true ; } while ( wcsIdx < wcs . length ) { if ( wcs [ wcsIdx ] . equals ( lr_6 ) ) { MST[rv.ABSMutator]MSP[N] textIdx ++ ; if ( textIdx > fileName . length () ) { break; }
final char [] array = new char [ size + 2 ] ; MST[rv.CRCR3Mutator]MSP[N] fileName . getChars ( 0 , fileName . length () , array , 0 ) ; final char otherSeparator = separator == SYSTEM_SEPARATOR ? OTHER_SEPARATOR : SYSTEM_SEPARATOR ;
if ( containsCompressedZeroes && ( inet6Address . indexOf ( lr_9 ) != inet6Address . lastIndexOf ( lr_9 ) ) ) { return false ; MST[InlineConstantMutator]MSP[S] } if ( ( inet6Address . startsWith ( lr_10 ) && ! inet6Address . startsWith ( lr_9 ) )
if ( size <= prefix ) { return new String ( array , 0 , size ) ; } if ( lastIsDirectory && keepSeparator ) { return new String ( array , 0 , size ) ; MST[rv.CRCR5Mutator]MSP[N] }
return doNormalize ( fileName , SYSTEM_SEPARATOR , true ) ; } public static String normalize ( final String fileName , final boolean unixSeparator ) { final char separator = unixSeparator ? UNIX_SEPARATOR : WINDOWS_SEPARATOR ; MST[rv.ROR2Mutator]MSP[S] return doNormalize ( fileName , separator , true ) ; }
return doNormalize ( fileName , separator , false ) ; } private static String doNormalize ( final String fileName , final char separator , final boolean keepSeparator ) { if ( fileName == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return null ; } failIfNullBytePresent ( fileName ) ;
for ( int i = 0 ; i < array . length ; i ++ ) { if ( array [ i ] == otherSeparator ) { array [ i ] = separator ; } } boolean lastIsDirectory = true ; MST[rv.CRCR5Mutator]MSP[S]
return isSeparator ( ch0 ) ? 1 : 0 ; } if ( ch0 == '~' ) { int posUnix = fileName . indexOf ( UNIX_SEPARATOR , 1 ) ; MST[rv.CRCR6Mutator]MSP[N] int posWin = fileName . indexOf ( WINDOWS_SEPARATOR , 1 ) ;
if ( isSystemWindows () ) { MST[NonVoidMethodCallMutator]MSP[N] final int offset = fileName . indexOf ( ':' , getAdsCriticalOffset ( fileName ) ) ; if ( offset != - 1 ) { throw new IllegalArgumentException ( lr_2 ) ; } } final int extensionPos = fileName . lastIndexOf ( EXTENSION_SEPARATOR ) ;
public static String normalizeNoEndSeparator ( final String fileName ) { return doNormalize ( fileName , SYSTEM_SEPARATOR , false ) ; } public static String normalizeNoEndSeparator ( final String fileName , final boolean unixSeparator ) { final char separator = unixSeparator ? UNIX_SEPARATOR : WINDOWS_SEPARATOR ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
if ( ! REG_NAME_PART_PATTERN . matcher ( parts [ i ] ) . matches () ) { return false ; MST[InlineConstantMutator]MSP[N] } } return true ; }
System . arraycopy ( array , i + 1 , array , prefix , size - i ) ; size -= i + 1 - prefix ; i = prefix + 1 ; MST[rv.AOR3Mutator]MSP[N] } } if ( size <= 0 ) { return EMPTY_STRING ; }
final int prefix = getPrefixLength ( fileName ) ; if ( prefix < 0 ) { MST[rv.UOI4Mutator]MSP[N] return null ; } if ( prefix >= fileName . length () ) { if ( includeSeparator ) { return getPrefix ( fileName ) ; } return fileName ; }
static boolean isSystemWindows () { return SYSTEM_SEPARATOR == WINDOWS_SEPARATOR ; MST[InlineConstantMutator]MSP[N] } private static boolean isSeparator ( final char ch ) { return ch == UNIX_SEPARATOR || ch == WINDOWS_SEPARATOR ; } public static String normalize ( final String fileName ) {
final int index = indexOfLastSeparator ( fileName ) ; if ( index < 0 ) { return fileName . substring ( 0 , prefix ) ; MST[NonVoidMethodCallMutator]MSP[N] } int end = index + ( includeSeparator ? 1 : 0 ) ; if ( end == 0 ) { end ++ ;
if ( array [ size - 1 ] != separator ) { array [ size ++ ] = separator ; lastIsDirectory = false ; } for ( int i = prefix + 1 ; i < size ; i ++ ) { MST[InlineConstantMutator]MSP[S]
if ( octet . length () == 0 ) { emptyOctets ++ ; if ( emptyOctets > 1 ) { return false ; } } else { emptyOctets = 0 ; MST[rv.CRCR5Mutator]MSP[S] if ( index == octets . length - 1 && octet . contains ( lr_12 ) ) {
final int prefix = getPrefixLength ( fileName ) ; if ( prefix < 0 ) { return null ; } if ( prefix >= fileName . length () ) { if ( includeSeparator ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] return getPrefix ( fileName ) ; } return fileName ; }
public static boolean isExtension ( final String fileName , final String ... extensions ) { if ( fileName == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] return false ; } failIfNullBytePresent ( fileName ) ; if ( extensions == null || extensions . length == 0 ) {
if ( ch == '?' || ch == '*' ) { MST[rv.ABSMutator]MSP[N] if ( buffer . length () != 0 ) { list . add ( buffer . toString () ) ; buffer . setLength ( 0 ) ; } if ( ch == '?' ) {
System . arraycopy ( array , i + 1 , array , prefix , size - i ) ; size -= i + 1 - prefix ; i = prefix + 1 ; } } if ( size <= 0 ) { MST[rv.UOI1Mutator]MSP[N] return EMPTY_STRING ; }
for ( int i = 1 ; i <= 4 ; i ++ ) { MST[rv.UOI1Mutator]MSP[N] final String ipSegment = m . group ( i ) ; final int iIpSegment = Integer . parseInt ( ipSegment ) ; if ( iIpSegment > IPV4_MAX_OCTET_VALUE ) { return false ; }
final int index = indexOfLastSeparator ( fileName ) ; if ( index < 0 ) { return fileName . substring ( 0 , prefix ) ; } int end = index + ( includeSeparator ? 1 : 0 ) ; MST[rv.UOI1Mutator]MSP[N] if ( end == 0 ) { end ++ ;
System . arraycopy ( array , i + 1 , array , i - 1 , size - i ) ; MST[rv.UOI1Mutator]MSP[N] size -= 2 ; i -- ; } } outer: for ( int i = prefix + 2 ; i < size ; i ++ ) {
if ( len == 0 ) { return 0 ; } char ch0 = fileName . charAt ( 0 ) ; if ( ch0 == ':' ) { return NOT_FOUND ; MST[rv.CRCR4Mutator]MSP[N] } if ( len == 1 ) { if ( ch0 == '~' ) { return 2 ; }
public static String getExtension ( final String fileName ) throws IllegalArgumentException { if ( fileName == null ) { return null ; } final int index = indexOfExtension ( fileName ) ; if ( index == NOT_FOUND ) { MST[rv.UOI3Mutator]MSP[N] return EMPTY_STRING ; }
if ( len == 0 ) { return 0 ; } char ch0 = fileName . charAt ( 0 ) ; if ( ch0 == ':' ) { return NOT_FOUND ; } if ( len == 1 ) { MST[rv.CRCR6Mutator]MSP[N] if ( ch0 == '~' ) { return 2 ; }
if ( containsCompressedZeroes && ( inet6Address . indexOf ( lr_9 ) != inet6Address . lastIndexOf ( lr_9 ) ) ) { return false ; } if ( ( inet6Address . startsWith ( lr_10 ) && ! inet6Address . startsWith ( lr_9 ) ) MST[rv.ROR4Mutator]MSP[N]
if ( array [ size - 1 ] != separator ) { MST[rv.UOI2Mutator]MSP[N] array [ size ++ ] = separator ; lastIsDirectory = false ; } for ( int i = prefix + 1 ; i < size ; i ++ ) {
if ( index == NOT_FOUND ) { return fileName ; MST[ReturnValsMutator]MSP[N] } return fileName . substring ( 0 , index ) ; } public static boolean equals ( final String fileName1 , final String fileName2 ) { return equals ( fileName1 , fileName2 , false , IOCase . SENSITIVE ) ;
final char ch1 = fileName . charAt ( 1 ) ; if ( ch1 == ':' ) { ch0 = Character . toUpperCase ( ch0 ) ; if ( ch0 >= 'A' && ch0 <= 'Z' ) { MST[rv.ROR2Mutator]MSP[N]
return doNormalize ( fileName , SYSTEM_SEPARATOR , true ) ; } public static String normalize ( final String fileName , final boolean unixSeparator ) { final char separator = unixSeparator ? UNIX_SEPARATOR : WINDOWS_SEPARATOR ; return doNormalize ( fileName , separator , true ) ; MST[rv.UOI4Mutator]MSP[N] }
if ( len == 2 || isSeparator ( fileName . charAt ( 2 ) ) == false ) { MST[rv.UOI2Mutator]MSP[N] return 2 ; } return 3 ; } else if ( ch0 == UNIX_SEPARATOR ) { return 1 ; } return NOT_FOUND ;
if ( i == prefix + 2 ) { return null ; } if ( i == size - 1 ) { lastIsDirectory = true ; } int j ; for ( j = i - 4 ; j >= prefix ; j -- ) { MST[rv.AOD1Mutator]MSP[N]
list . add ( lr_6 ) ; } else if ( prevChar != '*' ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] list . add ( lr_7 ) ; } } else { buffer . append ( ch ) ; } prevChar = ch ; } if ( buffer . length () != 0 ) {
final int index = indexOfLastSeparator ( fileName ) ; final int endIndex = index + separatorAdd ; if ( prefix >= fileName . length () || index < 0 || prefix >= endIndex ) { MST[rv.ABSMutator]MSP[N] return EMPTY_STRING ; }
final int index = indexOfLastSeparator ( fileName ) ; final int endIndex = index + separatorAdd ; if ( prefix >= fileName . length () || index < 0 || prefix >= endIndex ) { MST[rv.ROR3Mutator]MSP[N] return EMPTY_STRING ; }
if ( array [ i ] == separator && array [ i - 1 ] == separator ) { System . arraycopy ( array , i , array , i - 1 , size - i ) ; MST[rv.AOR4Mutator]MSP[N] size -- ; i -- ; } }
if ( validOctets > IPV6_MAX_HEX_GROUPS || ( validOctets < IPV6_MAX_HEX_GROUPS && ! containsCompressedZeroes ) ) { MST[rv.ROR1Mutator]MSP[N] return false ; } return true ; } private static boolean isRFC3986HostName ( final String name ) { final String [] parts = name . split ( lr_13 , - 1 ) ;
if ( array [ i ] == separator && array [ i - 1 ] == '.' && array [ i - 2 ] == '.' && MST[InlineConstantMutator]MSP[N] ( i == prefix + 2 || array [ i - 3 ] == separator ) ) {
final int pos = Math . min ( posUnix , posWin ) + 1 ; final String hostnamePart = fileName . substring ( 2 , pos - 1 ) ; return isValidHostName ( hostnamePart ) ? pos : NOT_FOUND ; MST[InlineConstantMutator]MSP[N] } else {
if ( array [ size - 1 ] != separator ) { array [ size ++ ] = separator ; lastIsDirectory = false ; } for ( int i = prefix + 1 ; i < size ; i ++ ) { MST[rv.UOI4Mutator]MSP[N]
failIfNullBytePresent ( path ) ; return path ; } public static String getPath ( final String fileName ) { return doGetPath ( fileName , 1 ) ; MST[ReturnValsMutator]MSP[N] } public static String getPathNoEndSeparator ( final String fileName ) { return doGetPath ( fileName , 0 ) ; }
( i == prefix + 1 || array [ i - 2 ] == separator ) ) { if ( i == size - 1 ) { MST[rv.UOI1Mutator]MSP[N] lastIsDirectory = true ; }
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2 ) { return NOT_FOUND ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ; MST[rv.ROR3Mutator]MSP[N]
final char [] array = new char [ size + 2 ] ; fileName . getChars ( 0 , fileName . length () , array , 0 ) ; MST[rv.CRCR1Mutator]MSP[N] final char otherSeparator = separator == SYSTEM_SEPARATOR ? OTHER_SEPARATOR : SYSTEM_SEPARATOR ;
for ( int i = 0 ; i < array . length ; i ++ ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] if ( array [ i ] == otherSeparator ) { array [ i ] = separator ; } } boolean lastIsDirectory = true ;
for ( int i = 1 ; i <= 4 ; i ++ ) { final String ipSegment = m . group ( i ) ; final int iIpSegment = Integer . parseInt ( ipSegment ) ; if ( iIpSegment > IPV4_MAX_OCTET_VALUE ) { return false ; MST[rv.CRCR6Mutator]MSP[N] }
list . add ( lr_6 ) ; } else if ( prevChar != '*' ) { list . add ( lr_7 ) ; } } else { buffer . append ( ch ) ; MST[rv.UOI2Mutator]MSP[N] } prevChar = ch ; } if ( buffer . length () != 0 ) {
final int index = indexOfLastSeparator ( fileName ) ; if ( index < 0 ) { return fileName . substring ( 0 , prefix ) ; } int end = index + ( includeSeparator ? 1 : 0 ) ; MST[rv.ROR1Mutator]MSP[N] if ( end == 0 ) { end ++ ;
} else if ( isSeparator ( ch0 ) && isSeparator ( ch1 ) ) { int posUnix = fileName . indexOf ( UNIX_SEPARATOR , 2 ) ; MST[rv.CRCR2Mutator]MSP[N] int posWin = fileName . indexOf ( WINDOWS_SEPARATOR , 2 ) ;
if ( len == 0 ) { MST[NegateConditionalsMutator]MSP[N] return 0 ; } char ch0 = fileName . charAt ( 0 ) ; if ( ch0 == ':' ) { return NOT_FOUND ; } if ( len == 1 ) { if ( ch0 == '~' ) { return 2 ; }
return fileName . substring ( index + 1 ) ; MST[rv.UOI1Mutator]MSP[N] } private static int getAdsCriticalOffset ( final String fileName ) { final int offset1 = fileName . lastIndexOf ( SYSTEM_SEPARATOR ) ; final int offset2 = fileName . lastIndexOf ( OTHER_SEPARATOR ) ;
list . add ( lr_6 ) ; } else if ( prevChar != '*' ) { list . add ( lr_7 ) ; } } else { buffer . append ( ch ) ; } prevChar = ch ; MST[rv.UOI4Mutator]MSP[S] } if ( buffer . length () != 0 ) {
} else if ( isSeparator ( ch0 ) && isSeparator ( ch1 ) ) { int posUnix = fileName . indexOf ( UNIX_SEPARATOR , 2 ) ; int posWin = fileName . indexOf ( WINDOWS_SEPARATOR , 2 ) ; MST[rv.CRCR4Mutator]MSP[N]
if ( len < 0 ) { MST[rv.ROR4Mutator]MSP[N] return null ; } if ( len > fileName . length () ) { failIfNullBytePresent ( fileName + UNIX_SEPARATOR ) ; return fileName + UNIX_SEPARATOR ; } final String path = fileName . substring ( 0 , len ) ;
if ( containsCompressedZeroes && ( inet6Address . indexOf ( lr_9 ) != inet6Address . lastIndexOf ( lr_9 ) ) ) { MST[rv.UOI4Mutator]MSP[N] return false ; } if ( ( inet6Address . startsWith ( lr_10 ) && ! inet6Address . startsWith ( lr_9 ) )
int size = fileName . length () ; if ( size == 0 ) { return fileName ; } final int prefix = getPrefixLength ( fileName ) ; if ( prefix < 0 ) { MST[rv.UOI1Mutator]MSP[N] return null ; }
if ( array [ i ] == separator && array [ i - 1 ] == '.' && array [ i - 2 ] == '.' && MST[rv.AOD2Mutator]MSP[N] ( i == prefix + 2 || array [ i - 3 ] == separator ) ) {
if ( path == null || path . indexOf ( WINDOWS_SEPARATOR ) == NOT_FOUND ) { return path ; } return path . replace ( WINDOWS_SEPARATOR , UNIX_SEPARATOR ) ; MST[rv.CRCR6Mutator]MSP[N] } public static String separatorsToWindows ( final String path ) {
final char ch1 = fileName . charAt ( 1 ) ; if ( ch1 == ':' ) { ch0 = Character . toUpperCase ( ch0 ) ; if ( ch0 >= 'A' && ch0 <= 'Z' ) { MST[rv.CRCR1Mutator]MSP[N]
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND ) { return len + 1 ; MST[rv.CRCR2Mutator]MSP[N] } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ; return Math . min ( posUnix , posWin ) + 1 ; }
if ( array [ i ] == separator && array [ i - 1 ] == '.' && array [ i - 2 ] == '.' && MST[rv.ABSMutator]MSP[N] ( i == prefix + 2 || array [ i - 3 ] == separator ) ) {
String fileName1 , String fileName2 , final boolean normalized , IOCase caseSensitivity ) { if ( fileName1 == null || fileName2 == null ) { return fileName1 == null && fileName2 == null ; MST[InlineConstantMutator]MSP[N] } if ( normalized ) { fileName1 = normalize ( fileName1 ) ;
if ( validOctets > IPV6_MAX_HEX_GROUPS || ( validOctets < IPV6_MAX_HEX_GROUPS && ! containsCompressedZeroes ) ) { return false ; } return true ; MST[rv.CRCR4Mutator]MSP[N] } private static boolean isRFC3986HostName ( final String name ) { final String [] parts = name . split ( lr_13 , - 1 ) ;
for ( int i = 0 ; i < parts . length ; i ++ ) { if ( parts [ i ] . length () == 0 ) { return i == parts . length - 1 ; MST[MathMutator]MSP[N] }
String fileName1 , String fileName2 , final boolean normalized , IOCase caseSensitivity ) { if ( fileName1 == null || fileName2 == null ) { MST[NegateConditionalsMutator]MSP[N] return fileName1 == null && fileName2 == null ; } if ( normalized ) { fileName1 = normalize ( fileName1 ) ;
for ( int i = 1 ; i <= 4 ; i ++ ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] final String ipSegment = m . group ( i ) ; final int iIpSegment = Integer . parseInt ( ipSegment ) ; if ( iIpSegment > IPV4_MAX_OCTET_VALUE ) { return false ; }
( i == prefix + 1 || array [ i - 2 ] == separator ) ) { if ( i == size - 1 ) { lastIsDirectory = true ; MST[rv.CRCR5Mutator]MSP[N] }
final char ch1 = fileName . charAt ( 1 ) ; if ( ch1 == ':' ) { ch0 = Character . toUpperCase ( ch0 ) ; if ( ch0 >= 'A' && ch0 <= 'Z' ) { MST[rv.ABSMutator]MSP[N]
int size = fileName . length () ; if ( size == 0 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return fileName ; } final int prefix = getPrefixLength ( fileName ) ; if ( prefix < 0 ) { return null ; }
if ( array [ j ] == separator ) { System . arraycopy ( array , i + 1 , array , j + 1 , size - i ) ; MST[InlineConstantMutator]MSP[N] size -= i - j ; i = j + 1 ; continue outer; } }
return doNormalize ( fileName , SYSTEM_SEPARATOR , true ) ; MST[ReturnValsMutator]MSP[N] } public static String normalize ( final String fileName , final boolean unixSeparator ) { final char separator = unixSeparator ? UNIX_SEPARATOR : WINDOWS_SEPARATOR ; return doNormalize ( fileName , separator , true ) ; }
if ( size <= prefix ) { return new String ( array , 0 , size ) ; } if ( lastIsDirectory && keepSeparator ) { return new String ( array , 0 , size ) ; MST[rv.ABSMutator]MSP[N] }
final int index = indexOfLastSeparator ( fileName ) ; final int endIndex = index + separatorAdd ; if ( prefix >= fileName . length () || index < 0 || prefix >= endIndex ) { MST[rv.ROR5Mutator]MSP[N] return EMPTY_STRING ; }
if ( array [ size - 1 ] != separator ) { array [ size ++ ] = separator ; lastIsDirectory = false ; } for ( int i = prefix + 1 ; i < size ; i ++ ) { MST[NegateConditionalsMutator]MSP[N]
final char ch1 = fileName . charAt ( 1 ) ; if ( ch1 == ':' ) { MST[rv.ROR3Mutator]MSP[N] ch0 = Character . toUpperCase ( ch0 ) ; if ( ch0 >= 'A' && ch0 <= 'Z' ) {
final int lastWindowsPos = fileName . lastIndexOf ( WINDOWS_SEPARATOR ) ; return Math . max ( lastUnixPos , lastWindowsPos ) ; MST[rv.UOI4Mutator]MSP[N] } public static int indexOfExtension ( final String fileName ) throws IllegalArgumentException { if ( fileName == null ) { return NOT_FOUND ; }
final char ch = basePath . charAt ( len - 1 ) ; if ( isSeparator ( ch ) ) { return normalize ( basePath + fullFileNameToAdd ) ; } return normalize ( basePath + '/' + fullFileNameToAdd ) ; MST[experimental.NakedReceiverMutator]MSP[N] }
for ( int i = 1 ; i <= 4 ; i ++ ) { MST[rv.CRCR3Mutator]MSP[N] final String ipSegment = m . group ( i ) ; final int iIpSegment = Integer . parseInt ( ipSegment ) ; if ( iIpSegment > IPV4_MAX_OCTET_VALUE ) { return false ; }
list . add ( lr_6 ) ; } else if ( prevChar != '*' ) { list . add ( lr_7 ) ; } } else { buffer . append ( ch ) ; } prevChar = ch ; } if ( buffer . length () != 0 ) { MST[rv.ROR4Mutator]MSP[N]
return isSeparator ( ch0 ) ? 1 : 0 ; } if ( ch0 == '~' ) { int posUnix = fileName . indexOf ( UNIX_SEPARATOR , 1 ) ; MST[rv.CRCR5Mutator]MSP[N] int posWin = fileName . indexOf ( WINDOWS_SEPARATOR , 1 ) ;
} else if ( isSeparator ( ch0 ) && isSeparator ( ch1 ) ) { MST[rv.ROR5Mutator]MSP[N] int posUnix = fileName . indexOf ( UNIX_SEPARATOR , 2 ) ; int posWin = fileName . indexOf ( WINDOWS_SEPARATOR , 2 ) ;
public static String getExtension ( final String fileName ) throws IllegalArgumentException { if ( fileName == null ) { return null ; } final int index = indexOfExtension ( fileName ) ; if ( index == NOT_FOUND ) { MST[rv.ROR3Mutator]MSP[N] return EMPTY_STRING ; }
if ( i == prefix + 2 ) { return null ; } if ( i == size - 1 ) { lastIsDirectory = true ; } int j ; for ( j = i - 4 ; j >= prefix ; j -- ) { MST[rv.CRCR6Mutator]MSP[N]
if ( array [ j ] == separator ) { System . arraycopy ( array , i + 1 , array , j + 1 , size - i ) ; MST[MathMutator]MSP[N] size -= i - j ; i = j + 1 ; continue outer; } }
return doNormalize ( fileName , SYSTEM_SEPARATOR , true ) ; } public static String normalize ( final String fileName , final boolean unixSeparator ) { final char separator = unixSeparator ? UNIX_SEPARATOR : WINDOWS_SEPARATOR ; MST[rv.CRCR2Mutator]MSP[S] return doNormalize ( fileName , separator , true ) ; }
if ( ! REG_NAME_PART_PATTERN . matcher ( parts [ i ] ) . matches () ) { MST[rv.ROR5Mutator]MSP[N] return false ; } } return true ; }
if ( len < 0 ) { return null ; } if ( len > fileName . length () ) { MST[rv.ROR2Mutator]MSP[N] failIfNullBytePresent ( fileName + UNIX_SEPARATOR ) ; return fileName + UNIX_SEPARATOR ; } final String path = fileName . substring ( 0 , len ) ;
if ( ch == '?' || ch == '*' ) { if ( buffer . length () != 0 ) { list . add ( buffer . toString () ) ; buffer . setLength ( 0 ) ; } if ( ch == '?' ) { MST[InlineConstantMutator]MSP[N]
final String path = fileName . substring ( prefix , endIndex ) ; failIfNullBytePresent ( path ) ; return path ; } public static String getFullPath ( final String fileName ) { return doGetFullPath ( fileName , true ) ; MST[rv.CRCR6Mutator]MSP[S] }
if ( array [ i ] == separator && array [ i - 1 ] == '.' && array [ i - 2 ] == '.' && MST[rv.ROR3Mutator]MSP[S] ( i == prefix + 2 || array [ i - 3 ] == separator ) ) {
return indexOfExtension ( fileName ) == NOT_FOUND ; MST[NonVoidMethodCallMutator]MSP[N] } final String fileExt = getExtension ( fileName ) ; for ( final String extension : extensions ) { if ( fileExt . equals ( extension ) ) { return true ; } } return false ; }
if ( len == 0 ) { return 0 ; MST[rv.CRCR3Mutator]MSP[N] } char ch0 = fileName . charAt ( 0 ) ; if ( ch0 == ':' ) { return NOT_FOUND ; } if ( len == 1 ) { if ( ch0 == '~' ) { return 2 ; }
} else if ( isSeparator ( ch0 ) && isSeparator ( ch1 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] int posUnix = fileName . indexOf ( UNIX_SEPARATOR , 2 ) ; int posWin = fileName . indexOf ( WINDOWS_SEPARATOR , 2 ) ;
if ( len < 0 ) { return null ; } if ( len > fileName . length () ) { failIfNullBytePresent ( fileName + UNIX_SEPARATOR ) ; MST[rv.CRCR3Mutator]MSP[N] return fileName + UNIX_SEPARATOR ; } final String path = fileName . substring ( 0 , len ) ;
for ( int i = 1 ; i <= 4 ; i ++ ) { final String ipSegment = m . group ( i ) ; MST[rv.ABSMutator]MSP[N] final int iIpSegment = Integer . parseInt ( ipSegment ) ; if ( iIpSegment > IPV4_MAX_OCTET_VALUE ) { return false ; }
if ( ch == '?' || ch == '*' ) { if ( buffer . length () != 0 ) { list . add ( buffer . toString () ) ; buffer . setLength ( 0 ) ; MST[rv.CRCR3Mutator]MSP[N] } if ( ch == '?' ) {
if ( array [ j ] == separator ) { System . arraycopy ( array , i + 1 , array , j + 1 , size - i ) ; MST[rv.AOR3Mutator]MSP[N] size -= i - j ; i = j + 1 ; continue outer; } }
if ( array [ size - 1 ] != separator ) { MST[rv.AOD2Mutator]MSP[N] array [ size ++ ] = separator ; lastIsDirectory = false ; } for ( int i = prefix + 1 ; i < size ; i ++ ) {
private static boolean isIPv4Address ( final String name ) { final Matcher m = IPV4_PATTERN . matcher ( name ) ; if ( ! m . matches () || m . groupCount () != 4 ) { MST[rv.ROR3Mutator]MSP[N] return false ; }
public static boolean isExtension ( final String fileName , final Collection < String > extensions ) { if ( fileName == null ) { return false ; } failIfNullBytePresent ( fileName ) ; if ( extensions == null || extensions . isEmpty () ) { MST[rv.ROR4Mutator]MSP[S]
if ( containsCompressedZeroes && ( inet6Address . indexOf ( lr_9 ) != inet6Address . lastIndexOf ( lr_9 ) ) ) { return false ; } if ( ( inet6Address . startsWith ( lr_10 ) && ! inet6Address . startsWith ( lr_9 ) ) MST[rv.ROR1Mutator]MSP[N]
return isSeparator ( ch0 ) ? 1 : 0 ; MST[rv.ABSMutator]MSP[N] } } public static int indexOfLastSeparator ( final String fileName ) { if ( fileName == null ) { return NOT_FOUND ; } final int lastUnixPos = fileName . lastIndexOf ( UNIX_SEPARATOR ) ;
for ( int i = 0 ; i < array . length ; i ++ ) { if ( array [ i ] == otherSeparator ) { MST[rv.ABSMutator]MSP[N] array [ i ] = separator ; } } boolean lastIsDirectory = true ;
for ( int i = 1 ; i <= 4 ; i ++ ) { final String ipSegment = m . group ( i ) ; final int iIpSegment = Integer . parseInt ( ipSegment ) ; if ( iIpSegment > IPV4_MAX_OCTET_VALUE ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[S] return false ; }
public static String getFullPathNoEndSeparator ( final String fileName ) { return doGetFullPath ( fileName , false ) ; MST[rv.CRCR1Mutator]MSP[N] } private static String doGetFullPath ( final String fileName , final boolean includeSeparator ) { if ( fileName == null ) { return null ; }
if ( array [ i ] == separator && array [ i - 1 ] == '.' && array [ i - 2 ] == '.' && MST[rv.AOR4Mutator]MSP[N] ( i == prefix + 2 || array [ i - 3 ] == separator ) ) {
if ( octets . length > IPV6_MAX_HEX_GROUPS ) { return false ; } int validOctets = 0 ; MST[InlineConstantMutator]MSP[N] int emptyOctets = 0 ; for ( int index = 0 ; index < octets . length ; index ++ ) { final String octet = octets [ index ] ;
if ( i == prefix + 2 ) { return null ; } if ( i == size - 1 ) { MST[MathMutator]MSP[S] lastIsDirectory = true ; } int j ; for ( j = i - 4 ; j >= prefix ; j -- ) {
return equals ( fileName1 , fileName2 , true , IOCase . SENSITIVE ) ; } public static boolean equalsNormalizedOnSystem ( final String fileName1 , final String fileName2 ) { return equals ( fileName1 , fileName2 , true , IOCase . SYSTEM ) ; MST[ReturnValsMutator]MSP[N] } public static boolean equals (
if ( validOctets > IPV6_MAX_HEX_GROUPS || ( validOctets < IPV6_MAX_HEX_GROUPS && ! containsCompressedZeroes ) ) { MST[ConditionalsBoundaryMutator]MSP[N] return false ; } return true ; } private static boolean isRFC3986HostName ( final String name ) { final String [] parts = name . split ( lr_13 , - 1 ) ;
if ( len == 2 || isSeparator ( fileName . charAt ( 2 ) ) == false ) { MST[NegateConditionalsMutator]MSP[N] return 2 ; } return 3 ; } else if ( ch0 == UNIX_SEPARATOR ) { return 1 ; } return NOT_FOUND ;
System . arraycopy ( array , i + 1 , array , i - 1 , size - i ) ; size -= 2 ; i -- ; } } outer: for ( int i = prefix + 2 ; i < size ; i ++ ) { MST[rv.AOD2Mutator]MSP[S]
if ( len == 0 ) { return 0 ; } char ch0 = fileName . charAt ( 0 ) ; if ( ch0 == ':' ) { return NOT_FOUND ; } if ( len == 1 ) { MST[rv.UOI4Mutator]MSP[N] if ( ch0 == '~' ) { return 2 ; }
return fileName . substring ( index + 1 ) ; } private static void failIfNullBytePresent ( final String path ) { final int len = path . length () ; for ( int i = 0 ; i < len ; i ++ ) { MST[rv.ROR4Mutator]MSP[S]
if ( extension == null || extension . isEmpty () ) { MST[NegateConditionalsMutator]MSP[N] return indexOfExtension ( fileName ) == NOT_FOUND ; } final String fileExt = getExtension ( fileName ) ; return fileExt . equals ( extension ) ; }
if ( validOctets > IPV6_MAX_HEX_GROUPS || ( validOctets < IPV6_MAX_HEX_GROUPS && ! containsCompressedZeroes ) ) { return false ; MST[rv.CRCR1Mutator]MSP[S] } return true ; } private static boolean isRFC3986HostName ( final String name ) { final String [] parts = name . split ( lr_13 , - 1 ) ;
if ( len == 2 || isSeparator ( fileName . charAt ( 2 ) ) == false ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return 2 ; } return 3 ; } else if ( ch0 == UNIX_SEPARATOR ) { return 1 ; } return NOT_FOUND ;
fileName2 = normalize ( fileName2 ) ; if ( fileName1 == null || fileName2 == null ) { throw new NullPointerException ( lr_5 ) ; } } if ( caseSensitivity == null ) { MST[rv.ROR5Mutator]MSP[N] caseSensitivity = IOCase . SENSITIVE ; }
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND ) { return len + 1 ; MST[rv.AOR1Mutator]MSP[N] } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ; return Math . min ( posUnix , posWin ) + 1 ; }
return fileName . substring ( index + 1 ) ; } private static void failIfNullBytePresent ( final String path ) { final int len = path . length () ; for ( int i = 0 ; i < len ; i ++ ) { MST[rv.UOI3Mutator]MSP[N]
if ( len == 0 ) { return 0 ; } char ch0 = fileName . charAt ( 0 ) ; if ( ch0 == ':' ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return NOT_FOUND ; } if ( len == 1 ) { if ( ch0 == '~' ) { return 2 ; }
return wildcardMatch ( fileName , wildcardMatcher , IOCase . SYSTEM ) ; } public static boolean wildcardMatch ( final String fileName , final String wildcardMatcher , IOCase caseSensitivity ) { if ( fileName == null && wildcardMatcher == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return true ; }
if ( array [ i ] == separator && array [ i - 1 ] == separator ) { MST[InlineConstantMutator]MSP[N] System . arraycopy ( array , i , array , i - 1 , size - i ) ; size -- ; i -- ; } }
if ( i == prefix + 2 ) { MST[rv.CRCR4Mutator]MSP[N] return null ; } if ( i == size - 1 ) { lastIsDirectory = true ; } int j ; for ( j = i - 4 ; j >= prefix ; j -- ) {
final int prefix = getPrefixLength ( fileName ) ; if ( prefix < 0 ) { return null ; } if ( prefix >= fileName . length () ) { MST[rv.UOI4Mutator]MSP[N] if ( includeSeparator ) { return getPrefix ( fileName ) ; } return fileName ; }
return indexOfExtension ( fileName ) == NOT_FOUND ; } final String fileExt = getExtension ( fileName ) ; for ( final String extension : extensions ) { if ( fileExt . equals ( extension ) ) { return true ; } } return false ; MST[InlineConstantMutator]MSP[N] }
list . add ( buffer . toString () ) ; } return list . toArray ( new String [ list . size () ] ) ; } private static boolean isValidHostName ( final String name ) { return isIPv6Address ( name ) || isRFC3986HostName ( name ) ; MST[rv.CRCR1Mutator]MSP[N] }
if ( array [ size - 1 ] != separator ) { MST[rv.AOR4Mutator]MSP[N] array [ size ++ ] = separator ; lastIsDirectory = false ; } for ( int i = prefix + 1 ; i < size ; i ++ ) {
if ( array [ j ] == separator ) { System . arraycopy ( array , i + 1 , array , j + 1 , size - i ) ; MST[rv.AOD1Mutator]MSP[N] size -= i - j ; i = j + 1 ; continue outer; } }
for ( int i = 0 ; i < array . length ; i ++ ) { if ( array [ i ] == otherSeparator ) { MST[rv.UOI3Mutator]MSP[N] array [ i ] = separator ; } } boolean lastIsDirectory = true ;
if ( ! REG_NAME_PART_PATTERN . matcher ( parts [ i ] ) . matches () ) { MST[NegateConditionalsMutator]MSP[N] return false ; } } return true ; }
if ( ! REG_NAME_PART_PATTERN . matcher ( parts [ i ] ) . matches () ) { return false ; } } return true ; MST[rv.CRCR2Mutator]MSP[N] }
if ( path == null || path . indexOf ( UNIX_SEPARATOR ) == NOT_FOUND ) { return path ; } return path . replace ( UNIX_SEPARATOR , WINDOWS_SEPARATOR ) ; MST[rv.CRCR1Mutator]MSP[N] } public static String separatorsToSystem ( final String path ) { if ( path == null ) {
if ( ch == '?' || ch == '*' ) { MST[rv.ROR2Mutator]MSP[N] if ( buffer . length () != 0 ) { list . add ( buffer . toString () ) ; buffer . setLength ( 0 ) ; } if ( ch == '?' ) {
if ( array [ j ] == separator ) { System . arraycopy ( array , i + 1 , array , j + 1 , size - i ) ; MST[rv.UOI4Mutator]MSP[N] size -= i - j ; i = j + 1 ; continue outer; } }
if ( path == null || path . indexOf ( WINDOWS_SEPARATOR ) == NOT_FOUND ) { MST[rv.CRCR3Mutator]MSP[N] return path ; } return path . replace ( WINDOWS_SEPARATOR , UNIX_SEPARATOR ) ; } public static String separatorsToWindows ( final String path ) {
if ( i == prefix + 2 ) { MST[rv.UOI3Mutator]MSP[N] return null ; } if ( i == size - 1 ) { lastIsDirectory = true ; } int j ; for ( j = i - 4 ; j >= prefix ; j -- ) {
if ( ipSegment . length () > 1 && ipSegment . startsWith ( lr_8 ) ) { MST[rv.CRCR2Mutator]MSP[S] return false ; } } return true ; } private static boolean isIPv6Address ( final String inet6Address ) { final boolean containsCompressedZeroes = inet6Address . contains ( lr_9 ) ;
if ( path == null || path . indexOf ( UNIX_SEPARATOR ) == NOT_FOUND ) { MST[InlineConstantMutator]MSP[N] return path ; } return path . replace ( UNIX_SEPARATOR , WINDOWS_SEPARATOR ) ; } public static String separatorsToSystem ( final String path ) { if ( path == null ) {
if ( isSystemWindows () ) { final int offset = fileName . indexOf ( ':' , getAdsCriticalOffset ( fileName ) ) ; if ( offset != - 1 ) { throw new IllegalArgumentException ( lr_2 ) ; } } final int extensionPos = fileName . lastIndexOf ( EXTENSION_SEPARATOR ) ; MST[rv.CRCR2Mutator]MSP[N]
for ( int i = 0 ; i < parts . length ; i ++ ) { if ( parts [ i ] . length () == 0 ) { return i == parts . length - 1 ; MST[rv.UOI1Mutator]MSP[N] }
return new String ( array , 0 , size - 1 ) ; MST[rv.CRCR2Mutator]MSP[N] } public static String concat ( final String basePath , final String fullFileNameToAdd ) { final int prefix = getPrefixLength ( fullFileNameToAdd ) ; if ( prefix < 0 ) { return null ; }
return indexOfExtension ( fileName ) == NOT_FOUND ; } final String fileExt = getExtension ( fileName ) ; for ( final String extension : extensions ) { if ( fileExt . equals ( extension ) ) { return true ; } } return false ; MST[rv.CRCR3Mutator]MSP[N] }
return false ; } static String [] splitOnTokens ( final String text ) { if ( text . indexOf ( '?' ) == NOT_FOUND && text . indexOf ( '*' ) == NOT_FOUND ) { return new String [] { text } ; MST[rv.CRCR5Mutator]MSP[N] }
} else if ( inet6Address . startsWith ( lr_9 ) && ! octetList . isEmpty () ) { MST[rv.ROR4Mutator]MSP[N] octetList . remove ( 0 ) ; } octets = octetList . toArray ( new String [ octetList . size () ] ) ; }
if ( ipSegment . length () > 1 && ipSegment . startsWith ( lr_8 ) ) { MST[rv.ROR4Mutator]MSP[N] return false ; } } return true ; } private static boolean isIPv6Address ( final String inet6Address ) { final boolean containsCompressedZeroes = inet6Address . contains ( lr_9 ) ;
if ( len == 2 || isSeparator ( fileName . charAt ( 2 ) ) == false ) { MST[rv.ROR5Mutator]MSP[N] return 2 ; } return 3 ; } else if ( ch0 == UNIX_SEPARATOR ) { return 1 ; } return NOT_FOUND ;
if ( array [ size - 1 ] != separator ) { array [ size ++ ] = separator ; MST[rv.UOI3Mutator]MSP[N] lastIsDirectory = false ; } for ( int i = prefix + 1 ; i < size ; i ++ ) {
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2 ) { MST[rv.ROR4Mutator]MSP[N] return NOT_FOUND ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ;
if ( octet . length () == 0 ) { emptyOctets ++ ; if ( emptyOctets > 1 ) { return false ; } } else { emptyOctets = 0 ; if ( index == octets . length - 1 && octet . contains ( lr_12 ) ) { MST[rv.ROR1Mutator]MSP[N]
System . arraycopy ( array , i + 1 , array , i - 1 , size - i ) ; size -= 2 ; i -- ; } } outer: for ( int i = prefix + 2 ; i < size ; i ++ ) { MST[rv.AOR4Mutator]MSP[N]
final char [] array = new char [ size + 2 ] ; fileName . getChars ( 0 , fileName . length () , array , 0 ) ; final char otherSeparator = separator == SYSTEM_SEPARATOR ? OTHER_SEPARATOR : SYSTEM_SEPARATOR ; MST[rv.ROR2Mutator]MSP[N]
final char ch1 = fileName . charAt ( 1 ) ; if ( ch1 == ':' ) { ch0 = Character . toUpperCase ( ch0 ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( ch0 >= 'A' && ch0 <= 'Z' ) {
if ( ! REG_NAME_PART_PATTERN . matcher ( parts [ i ] ) . matches () ) { MST[NonVoidMethodCallMutator]MSP[N] return false ; } } return true ; }
if ( extension == null || extension . isEmpty () ) { MST[rv.ROR5Mutator]MSP[N] return indexOfExtension ( fileName ) == NOT_FOUND ; } final String fileExt = getExtension ( fileName ) ; return fileExt . equals ( extension ) ; }
return false ; } static String [] splitOnTokens ( final String text ) { if ( text . indexOf ( '?' ) == NOT_FOUND && text . indexOf ( '*' ) == NOT_FOUND ) { MST[rv.ROR4Mutator]MSP[N] return new String [] { text } ; }
return indexOfExtension ( fileName ) == NOT_FOUND ; MST[rv.CRCR5Mutator]MSP[N] } final String fileExt = getExtension ( fileName ) ; for ( final String extension : extensions ) { if ( fileExt . equals ( extension ) ) { return true ; } } return false ; }
int wcsIdx = 0 ; final Stack < int [] > backtrack = new Stack <> () ; do { if ( backtrack . size () > 0 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] final int [] array = backtrack . pop () ; wcsIdx = array [ 0 ] ;
if ( len == 0 ) { return 0 ; MST[InlineConstantMutator]MSP[N] } char ch0 = fileName . charAt ( 0 ) ; if ( ch0 == ':' ) { return NOT_FOUND ; } if ( len == 1 ) { if ( ch0 == '~' ) { return 2 ; }
list . add ( buffer . toString () ) ; } return list . toArray ( new String [ list . size () ] ) ; } private static boolean isValidHostName ( final String name ) { return isIPv6Address ( name ) || isRFC3986HostName ( name ) ; MST[rv.CRCR4Mutator]MSP[N] }
return isSeparator ( ch0 ) ? 1 : 0 ; } if ( ch0 == '~' ) { MST[rv.CRCR3Mutator]MSP[N] int posUnix = fileName . indexOf ( UNIX_SEPARATOR , 1 ) ; int posWin = fileName . indexOf ( WINDOWS_SEPARATOR , 1 ) ;
textIdx += wcs [ wcsIdx ] . length () ; MST[rv.UOI1Mutator]MSP[N] anyChars = false ; } wcsIdx ++ ; } if ( wcsIdx == wcs . length && textIdx == fileName . length () ) { return true ; } } while ( backtrack . size () > 0 );
if ( array [ j ] == separator ) { MST[rv.ABSMutator]MSP[N] System . arraycopy ( array , i + 1 , array , j + 1 , size - i ) ; size -= i - j ; i = j + 1 ; continue outer; } }
if ( fileName == null || wildcardMatcher == null ) { MST[rv.ROR5Mutator]MSP[N] return false ; } if ( caseSensitivity == null ) { caseSensitivity = IOCase . SENSITIVE ; } final String [] wcs = splitOnTokens ( wildcardMatcher ) ; boolean anyChars = false ; int textIdx = 0 ;
if ( array [ i ] == separator && array [ i - 1 ] == separator ) { System . arraycopy ( array , i , array , i - 1 , size - i ) ; MST[rv.AOD2Mutator]MSP[N] size -- ; i -- ; } }
return doNormalize ( fileName , SYSTEM_SEPARATOR , true ) ; } public static String normalize ( final String fileName , final boolean unixSeparator ) { final char separator = unixSeparator ? UNIX_SEPARATOR : WINDOWS_SEPARATOR ; MST[rv.UOI1Mutator]MSP[S] return doNormalize ( fileName , separator , true ) ; }
if ( fileName == null || wildcardMatcher == null ) { return false ; MST[ReturnValsMutator]MSP[N] } if ( caseSensitivity == null ) { caseSensitivity = IOCase . SENSITIVE ; } final String [] wcs = splitOnTokens ( wildcardMatcher ) ; boolean anyChars = false ; int textIdx = 0 ;
if ( len == 0 ) { return 0 ; } char ch0 = fileName . charAt ( 0 ) ; MST[rv.CRCR5Mutator]MSP[N] if ( ch0 == ':' ) { return NOT_FOUND ; } if ( len == 1 ) { if ( ch0 == '~' ) { return 2 ; }
if ( array [ size - 1 ] != separator ) { array [ size ++ ] = separator ; lastIsDirectory = false ; } for ( int i = prefix + 1 ; i < size ; i ++ ) { MST[IncrementsMutator]MSP[N]
return new String ( array , 0 , size - 1 ) ; } public static String concat ( final String basePath , final String fullFileNameToAdd ) { final int prefix = getPrefixLength ( fullFileNameToAdd ) ; if ( prefix < 0 ) { return null ; MST[EmptyObjectReturnValsMutator]MSP[N] }
if ( fileName == null || wildcardMatcher == null ) { return false ; } if ( caseSensitivity == null ) { caseSensitivity = IOCase . SENSITIVE ; } final String [] wcs = splitOnTokens ( wildcardMatcher ) ; boolean anyChars = false ; int textIdx = 0 ; MST[InlineConstantMutator]MSP[N]
textIdx += wcs [ wcsIdx ] . length () ; anyChars = false ; MST[rv.CRCR5Mutator]MSP[N] } wcsIdx ++ ; } if ( wcsIdx == wcs . length && textIdx == fileName . length () ) { return true ; } } while ( backtrack . size () > 0 );
if ( ch == '?' || ch == '*' ) { MST[rv.UOI4Mutator]MSP[N] if ( buffer . length () != 0 ) { list . add ( buffer . toString () ) ; buffer . setLength ( 0 ) ; } if ( ch == '?' ) {
} return fileName . substring ( 0 , end ) ; } public static String getName ( final String fileName ) { if ( fileName == null ) { return null ; MST[ReturnValsMutator]MSP[S] } failIfNullBytePresent ( fileName ) ; final int index = indexOfLastSeparator ( fileName ) ;
static boolean isSystemWindows () { return SYSTEM_SEPARATOR == WINDOWS_SEPARATOR ; } private static boolean isSeparator ( final char ch ) { return ch == UNIX_SEPARATOR || ch == WINDOWS_SEPARATOR ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } public static String normalize ( final String fileName ) {
System . arraycopy ( array , i + 1 , array , prefix , size - i ) ; size -= i + 1 - prefix ; i = prefix + 1 ; MST[rv.AOD1Mutator]MSP[N] } } if ( size <= 0 ) { return EMPTY_STRING ; }
if ( len < 0 ) { return null ; } if ( len > fileName . length () ) { failIfNullBytePresent ( fileName + UNIX_SEPARATOR ) ; MST[InlineConstantMutator]MSP[N] return fileName + UNIX_SEPARATOR ; } final String path = fileName . substring ( 0 , len ) ;
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND ) { return len + 1 ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ; MST[NegateConditionalsMutator]MSP[N] return Math . min ( posUnix , posWin ) + 1 ; }
if ( len == 2 || isSeparator ( fileName . charAt ( 2 ) ) == false ) { MST[NonVoidMethodCallMutator]MSP[N] return 2 ; } return 3 ; } else if ( ch0 == UNIX_SEPARATOR ) { return 1 ; } return NOT_FOUND ;
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2 ) { MST[rv.CRCR3Mutator]MSP[N] return NOT_FOUND ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ;
return false ; } static String [] splitOnTokens ( final String text ) { if ( text . indexOf ( '?' ) == NOT_FOUND && text . indexOf ( '*' ) == NOT_FOUND ) { MST[NonVoidMethodCallMutator]MSP[N] return new String [] { text } ; }
System . arraycopy ( array , i + 1 , array , prefix , size - i ) ; MST[rv.UOI4Mutator]MSP[N] size -= i + 1 - prefix ; i = prefix + 1 ; } } if ( size <= 0 ) { return EMPTY_STRING ; }
if ( ch == '?' || ch == '*' ) { MST[rv.CRCR6Mutator]MSP[N] if ( buffer . length () != 0 ) { list . add ( buffer . toString () ) ; buffer . setLength ( 0 ) ; } if ( ch == '?' ) {
String fileName1 , String fileName2 , final boolean normalized , IOCase caseSensitivity ) { if ( fileName1 == null || fileName2 == null ) { MST[rv.ROR5Mutator]MSP[N] return fileName1 == null && fileName2 == null ; } if ( normalized ) { fileName1 = normalize ( fileName1 ) ;
final int index = indexOfLastSeparator ( fileName ) ; final int endIndex = index + separatorAdd ; if ( prefix >= fileName . length () || index < 0 || prefix >= endIndex ) { MST[rv.UOI4Mutator]MSP[N] return EMPTY_STRING ; }
public static boolean isExtension ( final String fileName , final String ... extensions ) { if ( fileName == null ) { return false ; } failIfNullBytePresent ( fileName ) ; if ( extensions == null || extensions . length == 0 ) { MST[rv.ROR1Mutator]MSP[N]
if ( array [ i ] == separator && array [ i - 1 ] == '.' && array [ i - 2 ] == '.' && MST[MathMutator]MSP[N] ( i == prefix + 2 || array [ i - 3 ] == separator ) ) {
if ( path == null || path . indexOf ( WINDOWS_SEPARATOR ) == NOT_FOUND ) { return path ; MST[EmptyObjectReturnValsMutator]MSP[N] } return path . replace ( WINDOWS_SEPARATOR , UNIX_SEPARATOR ) ; } public static String separatorsToWindows ( final String path ) {
System . arraycopy ( array , i + 1 , array , prefix , size - i ) ; size -= i + 1 - prefix ; MST[rv.UOI2Mutator]MSP[N] i = prefix + 1 ; } } if ( size <= 0 ) { return EMPTY_STRING ; }
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND ) { MST[rv.UOI4Mutator]MSP[N] return len + 1 ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ; return Math . min ( posUnix , posWin ) + 1 ; }
System . arraycopy ( array , i + 1 , array , prefix , size - i ) ; size -= i + 1 - prefix ; i = prefix + 1 ; MST[rv.UOI4Mutator]MSP[N] } } if ( size <= 0 ) { return EMPTY_STRING ; }
if ( array [ size - 1 ] != separator ) { array [ size ++ ] = separator ; lastIsDirectory = false ; } for ( int i = prefix + 1 ; i < size ; i ++ ) { MST[ConditionalsBoundaryMutator]MSP[N]
public static boolean isExtension ( final String fileName , final String ... extensions ) { if ( fileName == null ) { return false ; } failIfNullBytePresent ( fileName ) ; MST[VoidMethodCallMutator]MSP[N] if ( extensions == null || extensions . length == 0 ) {
if ( array [ size - 1 ] != separator ) { array [ size ++ ] = separator ; lastIsDirectory = false ; } for ( int i = prefix + 1 ; i < size ; i ++ ) { MST[rv.ROR5Mutator]MSP[N]
final int index = indexOfLastSeparator ( fileName ) ; if ( index < 0 ) { return fileName . substring ( 0 , prefix ) ; } int end = index + ( includeSeparator ? 1 : 0 ) ; if ( end == 0 ) { end ++ ; MST[experimental.RemoveIncrementsMutator]MSP[S]
( i == prefix + 1 || array [ i - 2 ] == separator ) ) { if ( i == size - 1 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] lastIsDirectory = true ; }
if ( array [ size - 1 ] != separator ) { MST[rv.ROR3Mutator]MSP[N] array [ size ++ ] = separator ; lastIsDirectory = false ; } for ( int i = prefix + 1 ; i < size ; i ++ ) {
for ( int i = 1 ; i <= 4 ; i ++ ) { final String ipSegment = m . group ( i ) ; final int iIpSegment = Integer . parseInt ( ipSegment ) ; if ( iIpSegment > IPV4_MAX_OCTET_VALUE ) { MST[rv.UOI2Mutator]MSP[N] return false ; }
textIdx = caseSensitivity . checkIndexOf ( fileName , textIdx , wcs [ wcsIdx ] ) ; if ( textIdx == NOT_FOUND ) { MST[rv.CRCR4Mutator]MSP[S] break; } final int repeat = caseSensitivity . checkIndexOf ( fileName , textIdx + 1 , wcs [ wcsIdx ] ) ;
if ( repeat >= 0 ) { backtrack . push ( new int [] { wcsIdx , repeat } ) ; MST[ArgumentPropagationMutator]MSP[N] } } else { if ( ! caseSensitivity . checkRegionMatches ( fileName , textIdx , wcs [ wcsIdx ] ) ) { break; } }
} else if ( isSeparator ( ch0 ) && isSeparator ( ch1 ) ) { int posUnix = fileName . indexOf ( UNIX_SEPARATOR , 2 ) ; int posWin = fileName . indexOf ( WINDOWS_SEPARATOR , 2 ) ; MST[InlineConstantMutator]MSP[N]
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2 ) { MST[rv.CRCR5Mutator]MSP[N] return NOT_FOUND ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ;
if ( len < 0 ) { return null ; } if ( len > fileName . length () ) { failIfNullBytePresent ( fileName + UNIX_SEPARATOR ) ; return fileName + UNIX_SEPARATOR ; MST[rv.CRCR1Mutator]MSP[N] } final String path = fileName . substring ( 0 , len ) ;
private static boolean isIPv4Address ( final String name ) { final Matcher m = IPV4_PATTERN . matcher ( name ) ; if ( ! m . matches () || m . groupCount () != 4 ) { MST[NonVoidMethodCallMutator]MSP[S] return false ; }
} else if ( isSeparator ( ch0 ) && isSeparator ( ch1 ) ) { int posUnix = fileName . indexOf ( UNIX_SEPARATOR , 2 ) ; int posWin = fileName . indexOf ( WINDOWS_SEPARATOR , 2 ) ; MST[rv.CRCR3Mutator]MSP[N]
if ( containsCompressedZeroes && ( inet6Address . indexOf ( lr_9 ) != inet6Address . lastIndexOf ( lr_9 ) ) ) { MST[rv.ROR5Mutator]MSP[S] return false ; } if ( ( inet6Address . startsWith ( lr_10 ) && ! inet6Address . startsWith ( lr_9 ) )
if ( path == null || path . indexOf ( WINDOWS_SEPARATOR ) == NOT_FOUND ) { return path ; } return path . replace ( WINDOWS_SEPARATOR , UNIX_SEPARATOR ) ; MST[rv.CRCR5Mutator]MSP[N] } public static String separatorsToWindows ( final String path ) {
if ( len == 2 || isSeparator ( fileName . charAt ( 2 ) ) == false ) { MST[NonVoidMethodCallMutator]MSP[N] return 2 ; } return 3 ; } else if ( ch0 == UNIX_SEPARATOR ) { return 1 ; } return NOT_FOUND ;
int size = fileName . length () ; if ( size == 0 ) { return fileName ; } final int prefix = getPrefixLength ( fileName ) ; if ( prefix < 0 ) { MST[rv.UOI2Mutator]MSP[N] return null ; }
if ( path == null || path . indexOf ( UNIX_SEPARATOR ) == NOT_FOUND ) { return path ; MST[EmptyObjectReturnValsMutator]MSP[N] } return path . replace ( UNIX_SEPARATOR , WINDOWS_SEPARATOR ) ; } public static String separatorsToSystem ( final String path ) { if ( path == null ) {
if ( ! isIPv4Address ( octet ) ) { return false ; } validOctets += 2 ; continue; } if ( octet . length () > IPV6_MAX_HEX_DIGITS_PER_GROUP ) { return false ; MST[ReturnValsMutator]MSP[N] } int octetInt = 0 ; try {
if ( size <= prefix ) { return new String ( array , 0 , size ) ; MST[ConstructorCallMutator]MSP[N] } if ( lastIsDirectory && keepSeparator ) { return new String ( array , 0 , size ) ; }
final char ch = basePath . charAt ( len - 1 ) ; if ( isSeparator ( ch ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return normalize ( basePath + fullFileNameToAdd ) ; } return normalize ( basePath + '/' + fullFileNameToAdd ) ; }
if ( size <= prefix ) { MST[rv.ROR2Mutator]MSP[N] return new String ( array , 0 , size ) ; } if ( lastIsDirectory && keepSeparator ) { return new String ( array , 0 , size ) ; }
for ( int i = 0 ; i < array . length ; i ++ ) { MST[rv.ROR2Mutator]MSP[N] if ( array [ i ] == otherSeparator ) { array [ i ] = separator ; } } boolean lastIsDirectory = true ;
final int prefix = getPrefixLength ( fileName ) ; if ( prefix < 0 ) { return null ; } if ( prefix >= fileName . length () ) { if ( includeSeparator ) { return getPrefix ( fileName ) ; } return fileName ; MST[ReturnValsMutator]MSP[N] }
if ( path == null || path . indexOf ( UNIX_SEPARATOR ) == NOT_FOUND ) { MST[ArgumentPropagationMutator]MSP[N] return path ; } return path . replace ( UNIX_SEPARATOR , WINDOWS_SEPARATOR ) ; } public static String separatorsToSystem ( final String path ) { if ( path == null ) {
final int index = indexOfLastSeparator ( fileName ) ; final int endIndex = index + separatorAdd ; if ( prefix >= fileName . length () || index < 0 || prefix >= endIndex ) { MST[rv.ROR4Mutator]MSP[N] return EMPTY_STRING ; }
if ( repeat >= 0 ) { backtrack . push ( new int [] { wcsIdx , repeat } ) ; MST[rv.CRCR3Mutator]MSP[S] } } else { if ( ! caseSensitivity . checkRegionMatches ( fileName , textIdx , wcs [ wcsIdx ] ) ) { break; } }
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND ) { return len + 1 ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; MST[rv.UOI4Mutator]MSP[N] posWin = posWin == NOT_FOUND ? posUnix : posWin ; return Math . min ( posUnix , posWin ) + 1 ; }
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND ) { return len + 1 ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ; MST[rv.CRCR6Mutator]MSP[N] return Math . min ( posUnix , posWin ) + 1 ; }
for ( int i = 0 ; i < parts . length ; i ++ ) { MST[ConditionalsBoundaryMutator]MSP[N] if ( parts [ i ] . length () == 0 ) { return i == parts . length - 1 ; }
( i == prefix + 1 || array [ i - 2 ] == separator ) ) { if ( i == size - 1 ) { lastIsDirectory = true ; MST[rv.CRCR4Mutator]MSP[N] }
if ( len == 2 || isSeparator ( fileName . charAt ( 2 ) ) == false ) { return 2 ; } return 3 ; MST[rv.CRCR5Mutator]MSP[N] } else if ( ch0 == UNIX_SEPARATOR ) { return 1 ; } return NOT_FOUND ;
textIdx += wcs [ wcsIdx ] . length () ; MST[MathMutator]MSP[N] anyChars = false ; } wcsIdx ++ ; } if ( wcsIdx == wcs . length && textIdx == fileName . length () ) { return true ; } } while ( backtrack . size () > 0 );
if ( octets . length > IPV6_MAX_HEX_GROUPS ) { MST[rv.ROR4Mutator]MSP[N] return false ; } int validOctets = 0 ; int emptyOctets = 0 ; for ( int index = 0 ; index < octets . length ; index ++ ) { final String octet = octets [ index ] ;
final char ch = basePath . charAt ( len - 1 ) ; MST[rv.AOD1Mutator]MSP[N] if ( isSeparator ( ch ) ) { return normalize ( basePath + fullFileNameToAdd ) ; } return normalize ( basePath + '/' + fullFileNameToAdd ) ; }
System . arraycopy ( array , i + 1 , array , i - 1 , size - i ) ; MST[MathMutator]MSP[N] size -= 2 ; i -- ; } } outer: for ( int i = prefix + 2 ; i < size ; i ++ ) {
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2 ) { return NOT_FOUND ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; MST[rv.CRCR1Mutator]MSP[N] posWin = posWin == NOT_FOUND ? posUnix : posWin ;
System . arraycopy ( array , i + 1 , array , prefix , size - i ) ; size -= i + 1 - prefix ; MST[rv.AOD1Mutator]MSP[N] i = prefix + 1 ; } } if ( size <= 0 ) { return EMPTY_STRING ; }
final char ch1 = fileName . charAt ( 1 ) ; if ( ch1 == ':' ) { ch0 = Character . toUpperCase ( ch0 ) ; if ( ch0 >= 'A' && ch0 <= 'Z' ) { MST[rv.ROR1Mutator]MSP[N]
for ( int i = prefix + 1 ; i < size ; i ++ ) { MST[rv.CRCR5Mutator]MSP[N] if ( array [ i ] == separator && array [ i - 1 ] == '.' &&
return fileName . substring ( index + 1 ) ; } private static void failIfNullBytePresent ( final String path ) { final int len = path . length () ; for ( int i = 0 ; i < len ; i ++ ) { MST[rv.UOI4Mutator]MSP[N]
return false ; } static String [] splitOnTokens ( final String text ) { if ( text . indexOf ( '?' ) == NOT_FOUND && text . indexOf ( '*' ) == NOT_FOUND ) { return new String [] { text } ; MST[InlineConstantMutator]MSP[N] }
final char ch1 = fileName . charAt ( 1 ) ; if ( ch1 == ':' ) { ch0 = Character . toUpperCase ( ch0 ) ; if ( ch0 >= 'A' && ch0 <= 'Z' ) { MST[rv.UOI3Mutator]MSP[N]
System . arraycopy ( array , i + 1 , array , i - 1 , size - i ) ; size -= 2 ; i -- ; } } outer: for ( int i = prefix + 2 ; i < size ; i ++ ) { MST[rv.UOI1Mutator]MSP[N]
if ( i == prefix + 2 ) { MST[rv.CRCR3Mutator]MSP[N] return null ; } if ( i == size - 1 ) { lastIsDirectory = true ; } int j ; for ( j = i - 4 ; j >= prefix ; j -- ) {
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2 ) { return NOT_FOUND ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ; MST[rv.CRCR4Mutator]MSP[N]
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2 ) { MST[NegateConditionalsMutator]MSP[N] return NOT_FOUND ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ;
return indexOfExtension ( fileName ) == NOT_FOUND ; MST[rv.CRCR2Mutator]MSP[N] } final String fileExt = getExtension ( fileName ) ; for ( final String extension : extensions ) { if ( fileExt . equals ( extension ) ) { return true ; } } return false ; }
System . arraycopy ( array , i + 1 , array , i - 1 , size - i ) ; MST[rv.AOR4Mutator]MSP[N] size -= 2 ; i -- ; } } outer: for ( int i = prefix + 2 ; i < size ; i ++ ) {
if ( path == null || path . indexOf ( UNIX_SEPARATOR ) == NOT_FOUND ) { MST[rv.CRCR5Mutator]MSP[N] return path ; } return path . replace ( UNIX_SEPARATOR , WINDOWS_SEPARATOR ) ; } public static String separatorsToSystem ( final String path ) { if ( path == null ) {
if ( octet . length () == 0 ) { emptyOctets ++ ; if ( emptyOctets > 1 ) { return false ; } } else { emptyOctets = 0 ; if ( index == octets . length - 1 && octet . contains ( lr_12 ) ) { MST[NonVoidMethodCallMutator]MSP[S]
for ( int i = 0 ; i < array . length ; i ++ ) { if ( array [ i ] == otherSeparator ) { array [ i ] = separator ; MST[rv.UOI4Mutator]MSP[N] } } boolean lastIsDirectory = true ;
if ( array [ j ] == separator ) { System . arraycopy ( array , i + 1 , array , j + 1 , size - i ) ; MST[rv.AOD2Mutator]MSP[N] size -= i - j ; i = j + 1 ; continue outer; } }
( i == prefix + 1 || array [ i - 2 ] == separator ) ) { if ( i == size - 1 ) { MST[rv.UOI2Mutator]MSP[N] lastIsDirectory = true ; }
return isSeparator ( ch0 ) ? 1 : 0 ; } } public static int indexOfLastSeparator ( final String fileName ) { if ( fileName == null ) { return NOT_FOUND ; } final int lastUnixPos = fileName . lastIndexOf ( UNIX_SEPARATOR ) ; MST[NonVoidMethodCallMutator]MSP[N]
int size = fileName . length () ; if ( size == 0 ) { return fileName ; } final int prefix = getPrefixLength ( fileName ) ; if ( prefix < 0 ) { MST[rv.ROR3Mutator]MSP[N] return null ; }
if ( size <= prefix ) { return new String ( array , 0 , size ) ; } if ( lastIsDirectory && keepSeparator ) { return new String ( array , 0 , size ) ; MST[InlineConstantMutator]MSP[N] }
if ( path == null || path . indexOf ( WINDOWS_SEPARATOR ) == NOT_FOUND ) { MST[rv.CRCR2Mutator]MSP[N] return path ; } return path . replace ( WINDOWS_SEPARATOR , UNIX_SEPARATOR ) ; } public static String separatorsToWindows ( final String path ) {
System . arraycopy ( array , i + 1 , array , i - 1 , size - i ) ; MST[rv.UOI2Mutator]MSP[N] size -= 2 ; i -- ; } } outer: for ( int i = prefix + 2 ; i < size ; i ++ ) {
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2 ) { return NOT_FOUND ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; MST[rv.UOI2Mutator]MSP[N] posWin = posWin == NOT_FOUND ? posUnix : posWin ;
if ( size <= prefix ) { MST[rv.UOI1Mutator]MSP[S] return new String ( array , 0 , size ) ; } if ( lastIsDirectory && keepSeparator ) { return new String ( array , 0 , size ) ; }
for ( int i = prefix + 1 ; i < size ; i ++ ) { if ( array [ i ] == separator && array [ i - 1 ] == '.' && MST[rv.AOR4Mutator]MSP[N]
return fileName . substring ( index + 1 ) ; } private static void failIfNullBytePresent ( final String path ) { final int len = path . length () ; for ( int i = 0 ; i < len ; i ++ ) { MST[IncrementsMutator]MSP[N]
final int index = indexOfLastSeparator ( fileName ) ; if ( index < 0 ) { MST[rv.UOI3Mutator]MSP[N] return fileName . substring ( 0 , prefix ) ; } int end = index + ( includeSeparator ? 1 : 0 ) ; if ( end == 0 ) { end ++ ;
if ( ipSegment . length () > 1 && ipSegment . startsWith ( lr_8 ) ) { MST[NonVoidMethodCallMutator]MSP[N] return false ; } } return true ; } private static boolean isIPv6Address ( final String inet6Address ) { final boolean containsCompressedZeroes = inet6Address . contains ( lr_9 ) ;
if ( octets . length > IPV6_MAX_HEX_GROUPS ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] return false ; } int validOctets = 0 ; int emptyOctets = 0 ; for ( int index = 0 ; index < octets . length ; index ++ ) { final String octet = octets [ index ] ;
textIdx = caseSensitivity . checkIndexOf ( fileName , textIdx , wcs [ wcsIdx ] ) ; if ( textIdx == NOT_FOUND ) { break; } final int repeat = caseSensitivity . checkIndexOf ( fileName , textIdx + 1 , wcs [ wcsIdx ] ) ; MST[rv.UOI3Mutator]MSP[N]
if ( containsCompressedZeroes && ( inet6Address . indexOf ( lr_9 ) != inet6Address . lastIndexOf ( lr_9 ) ) ) { return false ; } if ( ( inet6Address . startsWith ( lr_10 ) && ! inet6Address . startsWith ( lr_9 ) ) MST[NonVoidMethodCallMutator]MSP[N]
|| ( inet6Address . endsWith ( lr_10 ) && ! inet6Address . endsWith ( lr_9 ) ) ) { MST[rv.ROR2Mutator]MSP[N] return false ; } String [] octets = inet6Address . split ( lr_10 ) ; if ( containsCompressedZeroes ) {
final int index = indexOfLastSeparator ( fileName ) ; if ( index < 0 ) { return fileName . substring ( 0 , prefix ) ; MST[ReturnValsMutator]MSP[N] } int end = index + ( includeSeparator ? 1 : 0 ) ; if ( end == 0 ) { end ++ ;
final int index = indexOfLastSeparator ( fileName ) ; final int endIndex = index + separatorAdd ; if ( prefix >= fileName . length () || index < 0 || prefix >= endIndex ) { MST[rv.UOI3Mutator]MSP[N] return EMPTY_STRING ; }
final char [] array = new char [ size + 2 ] ; fileName . getChars ( 0 , fileName . length () , array , 0 ) ; MST[NonVoidMethodCallMutator]MSP[N] final char otherSeparator = separator == SYSTEM_SEPARATOR ? OTHER_SEPARATOR : SYSTEM_SEPARATOR ;
} else if ( isSeparator ( ch0 ) && isSeparator ( ch1 ) ) { MST[NonVoidMethodCallMutator]MSP[N] int posUnix = fileName . indexOf ( UNIX_SEPARATOR , 2 ) ; int posWin = fileName . indexOf ( WINDOWS_SEPARATOR , 2 ) ;
return indexOfExtension ( fileName ) == NOT_FOUND ; MST[rv.CRCR4Mutator]MSP[N] } final String fileExt = getExtension ( fileName ) ; for ( final String extension : extensions ) { if ( fileExt . equals ( extension ) ) { return true ; } } return false ; }
public static boolean isExtension ( final String fileName , final String ... extensions ) { if ( fileName == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return false ; } failIfNullBytePresent ( fileName ) ; if ( extensions == null || extensions . length == 0 ) {
final int index = indexOfLastSeparator ( fileName ) ; final int endIndex = index + separatorAdd ; MST[rv.UOI4Mutator]MSP[N] if ( prefix >= fileName . length () || index < 0 || prefix >= endIndex ) { return EMPTY_STRING ; }
final int prefix = getPrefixLength ( fileName ) ; if ( prefix < 0 ) { return null ; } if ( prefix >= fileName . length () ) { MST[rv.ROR3Mutator]MSP[N] if ( includeSeparator ) { return getPrefix ( fileName ) ; } return fileName ; }
if ( ! REG_NAME_PART_PATTERN . matcher ( parts [ i ] ) . matches () ) { MST[rv.ROR4Mutator]MSP[N] return false ; } } return true ; }
if ( array [ i ] == separator && array [ i - 1 ] == separator ) { System . arraycopy ( array , i , array , i - 1 , size - i ) ; MST[rv.UOI3Mutator]MSP[N] size -- ; i -- ; } }
if ( i == prefix + 2 ) { return null ; } if ( i == size - 1 ) { lastIsDirectory = true ; } int j ; for ( j = i - 4 ; j >= prefix ; j -- ) { MST[rv.CRCR5Mutator]MSP[N]
if ( i == prefix + 2 ) { return null ; } if ( i == size - 1 ) { lastIsDirectory = true ; MST[rv.CRCR3Mutator]MSP[N] } int j ; for ( j = i - 4 ; j >= prefix ; j -- ) {
return indexOfExtension ( fileName ) == NOT_FOUND ; MST[InlineConstantMutator]MSP[N] } final String fileExt = getExtension ( fileName ) ; for ( final String extension : extensions ) { if ( fileExt . equals ( extension ) ) { return true ; } } return false ; }
} else if ( isSeparator ( ch0 ) && isSeparator ( ch1 ) ) { MST[rv.ABSMutator]MSP[N] int posUnix = fileName . indexOf ( UNIX_SEPARATOR , 2 ) ; int posWin = fileName . indexOf ( WINDOWS_SEPARATOR , 2 ) ;
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND ) { return len + 1 ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ; return Math . min ( posUnix , posWin ) + 1 ; MST[rv.UOI1Mutator]MSP[N] }
System . arraycopy ( array , i + 1 , array , prefix , size - i ) ; size -= i + 1 - prefix ; i = prefix + 1 ; } } if ( size <= 0 ) { MST[rv.UOI2Mutator]MSP[N] return EMPTY_STRING ; }
final int pos = Math . min ( posUnix , posWin ) + 1 ; final String hostnamePart = fileName . substring ( 2 , pos - 1 ) ; MST[rv.CRCR6Mutator]MSP[N] return isValidHostName ( hostnamePart ) ? pos : NOT_FOUND ; } else {
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2 ) { return NOT_FOUND ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; MST[rv.ABSMutator]MSP[N] posWin = posWin == NOT_FOUND ? posUnix : posWin ;
if ( array [ i ] == separator && array [ i - 1 ] == '.' && array [ i - 2 ] == '.' && MST[rv.ROR2Mutator]MSP[N] ( i == prefix + 2 || array [ i - 3 ] == separator ) ) {
final String path = fileName . substring ( prefix , endIndex ) ; MST[NonVoidMethodCallMutator]MSP[N] failIfNullBytePresent ( path ) ; return path ; } public static String getFullPath ( final String fileName ) { return doGetFullPath ( fileName , true ) ; }
return Math . max ( offset1 , offset2 ) + 1 ; } public static String removeExtension ( final String fileName ) { if ( fileName == null ) { return null ; MST[EmptyObjectReturnValsMutator]MSP[S] } failIfNullBytePresent ( fileName ) ; final int index = indexOfExtension ( fileName ) ;
if ( i == prefix + 2 ) { return null ; } if ( i == size - 1 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] lastIsDirectory = true ; } int j ; for ( j = i - 4 ; j >= prefix ; j -- ) {
private static boolean isIPv4Address ( final String name ) { final Matcher m = IPV4_PATTERN . matcher ( name ) ; if ( ! m . matches () || m . groupCount () != 4 ) { MST[NegateConditionalsMutator]MSP[S] return false ; }
return Math . max ( offset1 , offset2 ) + 1 ; } public static String removeExtension ( final String fileName ) { if ( fileName == null ) { return null ; } failIfNullBytePresent ( fileName ) ; MST[VoidMethodCallMutator]MSP[N] final int index = indexOfExtension ( fileName ) ;
return isSeparator ( ch0 ) ? 1 : 0 ; MST[rv.CRCR5Mutator]MSP[N] } } public static int indexOfLastSeparator ( final String fileName ) { if ( fileName == null ) { return NOT_FOUND ; } final int lastUnixPos = fileName . lastIndexOf ( UNIX_SEPARATOR ) ;
if ( ! isIPv4Address ( octet ) ) { return false ; MST[rv.CRCR1Mutator]MSP[N] } validOctets += 2 ; continue; } if ( octet . length () > IPV6_MAX_HEX_DIGITS_PER_GROUP ) { return false ; } int octetInt = 0 ; try {
if ( len == 2 || isSeparator ( fileName . charAt ( 2 ) ) == false ) { return 2 ; } return 3 ; } else if ( ch0 == UNIX_SEPARATOR ) { return 1 ; MST[rv.CRCR4Mutator]MSP[S] } return NOT_FOUND ;
return isSeparator ( ch0 ) ? 1 : 0 ; } } public static int indexOfLastSeparator ( final String fileName ) { if ( fileName == null ) { return NOT_FOUND ; MST[ReturnValsMutator]MSP[N] } final int lastUnixPos = fileName . lastIndexOf ( UNIX_SEPARATOR ) ;
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2 ) { MST[rv.ROR5Mutator]MSP[N] return NOT_FOUND ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ;
return fileName . substring ( index + 1 ) ; } private static void failIfNullBytePresent ( final String path ) { final int len = path . length () ; for ( int i = 0 ; i < len ; i ++ ) { MST[NegateConditionalsMutator]MSP[N]
if ( index == NOT_FOUND ) { MST[rv.UOI3Mutator]MSP[N] return fileName ; } return fileName . substring ( 0 , index ) ; } public static boolean equals ( final String fileName1 , final String fileName2 ) { return equals ( fileName1 , fileName2 , false , IOCase . SENSITIVE ) ;
static boolean isSystemWindows () { return SYSTEM_SEPARATOR == WINDOWS_SEPARATOR ; } private static boolean isSeparator ( final char ch ) { return ch == UNIX_SEPARATOR || ch == WINDOWS_SEPARATOR ; MST[rv.CRCR3Mutator]MSP[N] } public static String normalize ( final String fileName ) {
System . arraycopy ( array , i + 1 , array , i - 1 , size - i ) ; MST[rv.AOR3Mutator]MSP[N] size -= 2 ; i -- ; } } outer: for ( int i = prefix + 2 ; i < size ; i ++ ) {
if ( size <= prefix ) { return new String ( array , 0 , size ) ; MST[rv.CRCR3Mutator]MSP[N] } if ( lastIsDirectory && keepSeparator ) { return new String ( array , 0 , size ) ; }
final char [] array = text . toCharArray () ; final ArrayList < String > list = new ArrayList <> () ; final StringBuilder buffer = new StringBuilder () ; char prevChar = 0 ; for ( final char ch : array ) { MST[rv.ABSMutator]MSP[N]
final int lastSeparator = indexOfLastSeparator ( fileName ) ; return lastSeparator > extensionPos ? NOT_FOUND : extensionPos ; MST[InlineConstantMutator]MSP[N] } public static String getPrefix ( final String fileName ) { if ( fileName == null ) { return null ; } final int len = getPrefixLength ( fileName ) ;
static boolean isSystemWindows () { return SYSTEM_SEPARATOR == WINDOWS_SEPARATOR ; MST[rv.CRCR5Mutator]MSP[N] } private static boolean isSeparator ( final char ch ) { return ch == UNIX_SEPARATOR || ch == WINDOWS_SEPARATOR ; } public static String normalize ( final String fileName ) {
textIdx = caseSensitivity . checkIndexOf ( fileName , textIdx , wcs [ wcsIdx ] ) ; MST[rv.UOI1Mutator]MSP[N] if ( textIdx == NOT_FOUND ) { break; } final int repeat = caseSensitivity . checkIndexOf ( fileName , textIdx + 1 , wcs [ wcsIdx ] ) ;
for ( int i = 0 ; i < array . length ; i ++ ) { if ( array [ i ] == otherSeparator ) { MST[rv.UOI2Mutator]MSP[N] array [ i ] = separator ; } } boolean lastIsDirectory = true ;
if ( octet . length () == 0 ) { MST[rv.ROR4Mutator]MSP[N] emptyOctets ++ ; if ( emptyOctets > 1 ) { return false ; } } else { emptyOctets = 0 ; if ( index == octets . length - 1 && octet . contains ( lr_12 ) ) {
for ( int i = prefix + 1 ; i < size ; i ++ ) { if ( array [ i ] == separator && array [ i - 1 ] == '.' && MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
return isSeparator ( ch0 ) ? 1 : 0 ; } if ( ch0 == '~' ) { int posUnix = fileName . indexOf ( UNIX_SEPARATOR , 1 ) ; int posWin = fileName . indexOf ( WINDOWS_SEPARATOR , 1 ) ; MST[rv.CRCR6Mutator]MSP[N]
System . arraycopy ( array , i + 1 , array , i - 1 , size - i ) ; MST[rv.ABSMutator]MSP[N] size -= 2 ; i -- ; } } outer: for ( int i = prefix + 2 ; i < size ; i ++ ) {
return isSeparator ( ch0 ) ? 1 : 0 ; } if ( ch0 == '~' ) { MST[rv.ROR3Mutator]MSP[N] int posUnix = fileName . indexOf ( UNIX_SEPARATOR , 1 ) ; int posWin = fileName . indexOf ( WINDOWS_SEPARATOR , 1 ) ;
final int pos = Math . min ( posUnix , posWin ) + 1 ; final String hostnamePart = fileName . substring ( 2 , pos - 1 ) ; MST[rv.CRCR1Mutator]MSP[N] return isValidHostName ( hostnamePart ) ? pos : NOT_FOUND ; } else {
System . arraycopy ( array , i + 1 , array , prefix , size - i ) ; size -= i + 1 - prefix ; i = prefix + 1 ; } } if ( size <= 0 ) { MST[rv.ABSMutator]MSP[N] return EMPTY_STRING ; }
if ( path == null || path . indexOf ( UNIX_SEPARATOR ) == NOT_FOUND ) { return path ; } return path . replace ( UNIX_SEPARATOR , WINDOWS_SEPARATOR ) ; MST[rv.CRCR1Mutator]MSP[N] } public static String separatorsToSystem ( final String path ) { if ( path == null ) {
return null ; } return isSystemWindows () ? separatorsToWindows ( path ) : separatorsToUnix ( path ) ; MST[rv.ROR2Mutator]MSP[N] } public static int getPrefixLength ( final String fileName ) { if ( fileName == null ) { return NOT_FOUND ; } final int len = fileName . length () ;
return fileName . substring ( index + 1 ) ; } private static void failIfNullBytePresent ( final String path ) { final int len = path . length () ; for ( int i = 0 ; i < len ; i ++ ) { MST[InlineConstantMutator]MSP[N]
for ( int i = prefix + 1 ; i < size ; i ++ ) { if ( array [ i ] == separator && array [ i - 1 ] == '.' && MST[MathMutator]MSP[N]
for ( int i = 0 ; i < array . length ; i ++ ) { if ( array [ i ] == otherSeparator ) { array [ i ] = separator ; } } boolean lastIsDirectory = true ; MST[InlineConstantMutator]MSP[N]
( i == prefix + 1 || array [ i - 2 ] == separator ) ) { if ( i == size - 1 ) { MST[rv.ABSMutator]MSP[N] lastIsDirectory = true ; }
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2 ) { MST[rv.ROR3Mutator]MSP[N] return NOT_FOUND ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ;
static boolean isSystemWindows () { return SYSTEM_SEPARATOR == WINDOWS_SEPARATOR ; } private static boolean isSeparator ( final char ch ) { return ch == UNIX_SEPARATOR || ch == WINDOWS_SEPARATOR ; MST[rv.ROR5Mutator]MSP[N] } public static String normalize ( final String fileName ) {
final char ch = basePath . charAt ( len - 1 ) ; if ( isSeparator ( ch ) ) { return normalize ( basePath + fullFileNameToAdd ) ; } return normalize ( basePath + '/' + fullFileNameToAdd ) ; MST[NonVoidMethodCallMutator]MSP[N] }
return false ; } static String [] splitOnTokens ( final String text ) { if ( text . indexOf ( '?' ) == NOT_FOUND && text . indexOf ( '*' ) == NOT_FOUND ) { MST[ArgumentPropagationMutator]MSP[N] return new String [] { text } ; }
if ( size <= prefix ) { return new String ( array , 0 , size ) ; } if ( lastIsDirectory && keepSeparator ) { return new String ( array , 0 , size ) ; MST[rv.UOI2Mutator]MSP[N] }
if ( ! isIPv4Address ( octet ) ) { MST[rv.ROR4Mutator]MSP[N] return false ; } validOctets += 2 ; continue; } if ( octet . length () > IPV6_MAX_HEX_DIGITS_PER_GROUP ) { return false ; } int octetInt = 0 ; try {
System . arraycopy ( array , i + 1 , array , prefix , size - i ) ; MST[rv.UOI3Mutator]MSP[N] size -= i + 1 - prefix ; i = prefix + 1 ; } } if ( size <= 0 ) { return EMPTY_STRING ; }
if ( path . charAt ( i ) == 0 ) { throw new IllegalArgumentException ( lr_3 + MST[ConstructorCallMutator]MSP[N] lr_4 ) ; } } } public static String getBaseName ( final String fileName ) { return removeExtension ( getName ( fileName ) ) ; }
return false ; } static String [] splitOnTokens ( final String text ) { if ( text . indexOf ( '?' ) == NOT_FOUND && text . indexOf ( '*' ) == NOT_FOUND ) { MST[rv.CRCR4Mutator]MSP[N] return new String [] { text } ; }
if ( index == NOT_FOUND ) { return fileName ; } return fileName . substring ( 0 , index ) ; MST[ReturnValsMutator]MSP[N] } public static boolean equals ( final String fileName1 , final String fileName2 ) { return equals ( fileName1 , fileName2 , false , IOCase . SENSITIVE ) ;
if ( array [ j ] == separator ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] System . arraycopy ( array , i + 1 , array , j + 1 , size - i ) ; size -= i - j ; i = j + 1 ; continue outer; } }
return equals ( fileName1 , fileName2 , true , IOCase . SENSITIVE ) ; } public static boolean equalsNormalizedOnSystem ( final String fileName1 , final String fileName2 ) { return equals ( fileName1 , fileName2 , true , IOCase . SYSTEM ) ; MST[rv.CRCR4Mutator]MSP[N] } public static boolean equals (
for ( int i = prefix + 1 ; i < size ; i ++ ) { if ( array [ i ] == separator && array [ i - 1 ] == '.' && MST[rv.UOI1Mutator]MSP[N]
list . add ( buffer . toString () ) ; } return list . toArray ( new String [ list . size () ] ) ; } private static boolean isValidHostName ( final String name ) { return isIPv6Address ( name ) || isRFC3986HostName ( name ) ; MST[BooleanTrueReturnValsMutator]MSP[N] }
textIdx += wcs [ wcsIdx ] . length () ; anyChars = false ; } wcsIdx ++ ; } if ( wcsIdx == wcs . length && textIdx == fileName . length () ) { MST[rv.UOI4Mutator]MSP[N] return true ; } } while ( backtrack . size () > 0 );
for ( int i = prefix + 1 ; i < size ; i ++ ) { if ( array [ i ] == separator && array [ i - 1 ] == '.' && MST[rv.ROR3Mutator]MSP[N]
return doNormalize ( fileName , SYSTEM_SEPARATOR , true ) ; MST[rv.CRCR4Mutator]MSP[N] } public static String normalize ( final String fileName , final boolean unixSeparator ) { final char separator = unixSeparator ? UNIX_SEPARATOR : WINDOWS_SEPARATOR ; return doNormalize ( fileName , separator , true ) ; }
if ( extension == null || extension . isEmpty () ) { return indexOfExtension ( fileName ) == NOT_FOUND ; MST[InlineConstantMutator]MSP[N] } final String fileExt = getExtension ( fileName ) ; return fileExt . equals ( extension ) ; }
textIdx += wcs [ wcsIdx ] . length () ; MST[rv.UOI2Mutator]MSP[N] anyChars = false ; } wcsIdx ++ ; } if ( wcsIdx == wcs . length && textIdx == fileName . length () ) { return true ; } } while ( backtrack . size () > 0 );
static boolean isSystemWindows () { return SYSTEM_SEPARATOR == WINDOWS_SEPARATOR ; } private static boolean isSeparator ( final char ch ) { return ch == UNIX_SEPARATOR || ch == WINDOWS_SEPARATOR ; MST[rv.ROR3Mutator]MSP[N] } public static String normalize ( final String fileName ) {
final char ch1 = fileName . charAt ( 1 ) ; if ( ch1 == ':' ) { MST[rv.UOI4Mutator]MSP[N] ch0 = Character . toUpperCase ( ch0 ) ; if ( ch0 >= 'A' && ch0 <= 'Z' ) {
if ( index == NOT_FOUND ) { return fileName ; } return fileName . substring ( 0 , index ) ; MST[rv.CRCR5Mutator]MSP[N] } public static boolean equals ( final String fileName1 , final String fileName2 ) { return equals ( fileName1 , fileName2 , false , IOCase . SENSITIVE ) ;
String fileName1 , String fileName2 , final boolean normalized , IOCase caseSensitivity ) { if ( fileName1 == null || fileName2 == null ) { return fileName1 == null && fileName2 == null ; } if ( normalized ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] fileName1 = normalize ( fileName1 ) ;
if ( extension == null || extension . isEmpty () ) { return indexOfExtension ( fileName ) == NOT_FOUND ; MST[rv.ROR4Mutator]MSP[N] } final String fileExt = getExtension ( fileName ) ; return fileExt . equals ( extension ) ; }
if ( repeat >= 0 ) { backtrack . push ( new int [] { wcsIdx , repeat } ) ; MST[InlineConstantMutator]MSP[N] } } else { if ( ! caseSensitivity . checkRegionMatches ( fileName , textIdx , wcs [ wcsIdx ] ) ) { break; } }
final int prefix = getPrefixLength ( fileName ) ; if ( prefix < 0 ) { MST[NegateConditionalsMutator]MSP[N] return null ; } if ( prefix >= fileName . length () ) { if ( includeSeparator ) { return getPrefix ( fileName ) ; } return fileName ; }
if ( validOctets > IPV6_MAX_HEX_GROUPS || ( validOctets < IPV6_MAX_HEX_GROUPS && ! containsCompressedZeroes ) ) { MST[rv.UOI3Mutator]MSP[S] return false ; } return true ; } private static boolean isRFC3986HostName ( final String name ) { final String [] parts = name . split ( lr_13 , - 1 ) ;
failIfNullBytePresent ( path ) ; return path ; } public static String getPath ( final String fileName ) { return doGetPath ( fileName , 1 ) ; } public static String getPathNoEndSeparator ( final String fileName ) { return doGetPath ( fileName , 0 ) ; MST[rv.CRCR6Mutator]MSP[S] }
if ( validOctets > IPV6_MAX_HEX_GROUPS || ( validOctets < IPV6_MAX_HEX_GROUPS && ! containsCompressedZeroes ) ) { MST[rv.UOI1Mutator]MSP[N] return false ; } return true ; } private static boolean isRFC3986HostName ( final String name ) { final String [] parts = name . split ( lr_13 , - 1 ) ;
if ( octet . length () == 0 ) { emptyOctets ++ ; if ( emptyOctets > 1 ) { return false ; } } else { emptyOctets = 0 ; if ( index == octets . length - 1 && octet . contains ( lr_12 ) ) { MST[rv.CRCR5Mutator]MSP[S]
int size = fileName . length () ; if ( size == 0 ) { return fileName ; } final int prefix = getPrefixLength ( fileName ) ; if ( prefix < 0 ) { MST[rv.ABSMutator]MSP[N] return null ; }
for ( int i = prefix + 1 ; i < size ; i ++ ) { if ( array [ i ] == separator && array [ i - 1 ] == '.' && MST[rv.AOR3Mutator]MSP[N]
if ( array [ size - 1 ] != separator ) { array [ size ++ ] = separator ; lastIsDirectory = false ; } for ( int i = prefix + 1 ; i < size ; i ++ ) { MST[rv.AOD1Mutator]MSP[S]
int wcsIdx = 0 ; MST[rv.CRCR1Mutator]MSP[N] final Stack < int [] > backtrack = new Stack <> () ; do { if ( backtrack . size () > 0 ) { final int [] array = backtrack . pop () ; wcsIdx = array [ 0 ] ;
} else if ( isSeparator ( ch0 ) && isSeparator ( ch1 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] int posUnix = fileName . indexOf ( UNIX_SEPARATOR , 2 ) ; int posWin = fileName . indexOf ( WINDOWS_SEPARATOR , 2 ) ;
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2 ) { return NOT_FOUND ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; MST[rv.ROR1Mutator]MSP[N] posWin = posWin == NOT_FOUND ? posUnix : posWin ;
if ( len == 2 || isSeparator ( fileName . charAt ( 2 ) ) == false ) { MST[rv.CRCR1Mutator]MSP[N] return 2 ; } return 3 ; } else if ( ch0 == UNIX_SEPARATOR ) { return 1 ; } return NOT_FOUND ;
public static String normalizeNoEndSeparator ( final String fileName ) { return doNormalize ( fileName , SYSTEM_SEPARATOR , false ) ; } public static String normalizeNoEndSeparator ( final String fileName , final boolean unixSeparator ) { final char separator = unixSeparator ? UNIX_SEPARATOR : WINDOWS_SEPARATOR ; MST[rv.CRCR5Mutator]MSP[S]
public static String normalizeNoEndSeparator ( final String fileName ) { return doNormalize ( fileName , SYSTEM_SEPARATOR , false ) ; } public static String normalizeNoEndSeparator ( final String fileName , final boolean unixSeparator ) { final char separator = unixSeparator ? UNIX_SEPARATOR : WINDOWS_SEPARATOR ; MST[rv.CRCR4Mutator]MSP[N]
for ( int i = prefix + 1 ; i < size ; i ++ ) { if ( array [ i ] == separator && array [ i - 1 ] == '.' && MST[rv.CRCR6Mutator]MSP[N]
return false ; } static String [] splitOnTokens ( final String text ) { if ( text . indexOf ( '?' ) == NOT_FOUND && text . indexOf ( '*' ) == NOT_FOUND ) { MST[rv.CRCR2Mutator]MSP[N] return new String [] { text } ; }
for ( int i = 0 ; i < parts . length ; i ++ ) { MST[rv.ROR3Mutator]MSP[N] if ( parts [ i ] . length () == 0 ) { return i == parts . length - 1 ; }
return isSeparator ( ch0 ) ? 1 : 0 ; MST[rv.ROR3Mutator]MSP[N] } } public static int indexOfLastSeparator ( final String fileName ) { if ( fileName == null ) { return NOT_FOUND ; } final int lastUnixPos = fileName . lastIndexOf ( UNIX_SEPARATOR ) ;
final char ch1 = fileName . charAt ( 1 ) ; MST[InlineConstantMutator]MSP[N] if ( ch1 == ':' ) { ch0 = Character . toUpperCase ( ch0 ) ; if ( ch0 >= 'A' && ch0 <= 'Z' ) {
if ( size <= prefix ) { return new String ( array , 0 , size ) ; } if ( lastIsDirectory && keepSeparator ) { MST[rv.ABSMutator]MSP[N] return new String ( array , 0 , size ) ; }
if ( path == null || path . indexOf ( WINDOWS_SEPARATOR ) == NOT_FOUND ) { MST[ArgumentPropagationMutator]MSP[N] return path ; } return path . replace ( WINDOWS_SEPARATOR , UNIX_SEPARATOR ) ; } public static String separatorsToWindows ( final String path ) {
return indexOfExtension ( fileName ) == NOT_FOUND ; MST[rv.ROR2Mutator]MSP[N] } final String fileExt = getExtension ( fileName ) ; for ( final String extension : extensions ) { if ( fileExt . equals ( extension ) ) { return true ; } } return false ; }
octetInt = Integer . parseInt ( octet , BASE_16 ) ; } catch ( final NumberFormatException e ) { return false ; } if ( octetInt < 0 || octetInt > MAX_UNSIGNED_SHORT ) { MST[rv.UOI3Mutator]MSP[N] return false ; } } validOctets ++ ; }
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2 ) { return NOT_FOUND ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] posWin = posWin == NOT_FOUND ? posUnix : posWin ;
public static String getExtension ( final String fileName ) throws IllegalArgumentException { if ( fileName == null ) { return null ; } final int index = indexOfExtension ( fileName ) ; if ( index == NOT_FOUND ) { MST[rv.CRCR6Mutator]MSP[N] return EMPTY_STRING ; }
if ( array [ j ] == separator ) { System . arraycopy ( array , i + 1 , array , j + 1 , size - i ) ; size -= i - j ; MST[rv.AOR3Mutator]MSP[N] i = j + 1 ; continue outer; } }
final int pos = Math . min ( posUnix , posWin ) + 1 ; MST[NonVoidMethodCallMutator]MSP[N] final String hostnamePart = fileName . substring ( 2 , pos - 1 ) ; return isValidHostName ( hostnamePart ) ? pos : NOT_FOUND ; } else {
} else if ( isSeparator ( ch0 ) && isSeparator ( ch1 ) ) { MST[rv.ROR2Mutator]MSP[S] int posUnix = fileName . indexOf ( UNIX_SEPARATOR , 2 ) ; int posWin = fileName . indexOf ( WINDOWS_SEPARATOR , 2 ) ;
if ( index == NOT_FOUND ) { MST[rv.CRCR6Mutator]MSP[S] return fileName ; } return fileName . substring ( 0 , index ) ; } public static boolean equals ( final String fileName1 , final String fileName2 ) { return equals ( fileName1 , fileName2 , false , IOCase . SENSITIVE ) ;
for ( int i = 0 ; i < parts . length ; i ++ ) { if ( parts [ i ] . length () == 0 ) { return i == parts . length - 1 ; MST[rv.CRCR3Mutator]MSP[N] }
static boolean isSystemWindows () { return SYSTEM_SEPARATOR == WINDOWS_SEPARATOR ; MST[rv.ROR2Mutator]MSP[N] } private static boolean isSeparator ( final char ch ) { return ch == UNIX_SEPARATOR || ch == WINDOWS_SEPARATOR ; } public static String normalize ( final String fileName ) {
static boolean isSystemWindows () { return SYSTEM_SEPARATOR == WINDOWS_SEPARATOR ; MST[rv.CRCR3Mutator]MSP[N] } private static boolean isSeparator ( final char ch ) { return ch == UNIX_SEPARATOR || ch == WINDOWS_SEPARATOR ; } public static String normalize ( final String fileName ) {
if ( array [ j ] == separator ) { MST[rv.UOI1Mutator]MSP[N] System . arraycopy ( array , i + 1 , array , j + 1 , size - i ) ; size -= i - j ; i = j + 1 ; continue outer; } }
if ( octet . length () == 0 ) { emptyOctets ++ ; if ( emptyOctets > 1 ) { MST[rv.UOI4Mutator]MSP[N] return false ; } } else { emptyOctets = 0 ; if ( index == octets . length - 1 && octet . contains ( lr_12 ) ) {
if ( i == prefix + 2 ) { MST[rv.AOR1Mutator]MSP[N] return null ; } if ( i == size - 1 ) { lastIsDirectory = true ; } int j ; for ( j = i - 4 ; j >= prefix ; j -- ) {
final int prefix = getPrefixLength ( fileName ) ; if ( prefix < 0 ) { return null ; MST[EmptyObjectReturnValsMutator]MSP[N] } if ( prefix >= fileName . length () ) { if ( includeSeparator ) { return getPrefix ( fileName ) ; } return fileName ; }
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2 ) { return NOT_FOUND ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ; MST[rv.ROR4Mutator]MSP[N]
if ( octet . length () == 0 ) { emptyOctets ++ ; if ( emptyOctets > 1 ) { return false ; } } else { emptyOctets = 0 ; MST[InlineConstantMutator]MSP[S] if ( index == octets . length - 1 && octet . contains ( lr_12 ) ) {
final int prefix = getPrefixLength ( fileName ) ; if ( prefix < 0 ) { MST[rv.ROR5Mutator]MSP[N] return null ; } if ( prefix >= fileName . length () ) { if ( includeSeparator ) { return getPrefix ( fileName ) ; } return fileName ; }
if ( containsCompressedZeroes && ( inet6Address . indexOf ( lr_9 ) != inet6Address . lastIndexOf ( lr_9 ) ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] return false ; } if ( ( inet6Address . startsWith ( lr_10 ) && ! inet6Address . startsWith ( lr_9 ) )
private static String doGetPath ( final String fileName , final int separatorAdd ) { if ( fileName == null ) { return null ; } final int prefix = getPrefixLength ( fileName ) ; if ( prefix < 0 ) { MST[rv.ABSMutator]MSP[N] return null ; }
if ( ch == '?' || ch == '*' ) { MST[NegateConditionalsMutator]MSP[N] if ( buffer . length () != 0 ) { list . add ( buffer . toString () ) ; buffer . setLength ( 0 ) ; } if ( ch == '?' ) {
if ( containsCompressedZeroes && ( inet6Address . indexOf ( lr_9 ) != inet6Address . lastIndexOf ( lr_9 ) ) ) { return false ; } if ( ( inet6Address . startsWith ( lr_10 ) && ! inet6Address . startsWith ( lr_9 ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND ) { return len + 1 ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ; return Math . min ( posUnix , posWin ) + 1 ; MST[rv.ABSMutator]MSP[N] }
if ( len < 0 ) { MST[rv.UOI4Mutator]MSP[N] return null ; } if ( len > fileName . length () ) { failIfNullBytePresent ( fileName + UNIX_SEPARATOR ) ; return fileName + UNIX_SEPARATOR ; } final String path = fileName . substring ( 0 , len ) ;
static boolean isSystemWindows () { return SYSTEM_SEPARATOR == WINDOWS_SEPARATOR ; MST[BooleanTrueReturnValsMutator]MSP[N] } private static boolean isSeparator ( final char ch ) { return ch == UNIX_SEPARATOR || ch == WINDOWS_SEPARATOR ; } public static String normalize ( final String fileName ) {
if ( size <= prefix ) { MST[rv.ABSMutator]MSP[N] return new String ( array , 0 , size ) ; } if ( lastIsDirectory && keepSeparator ) { return new String ( array , 0 , size ) ; }
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND ) { return len + 1 ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; MST[rv.ROR3Mutator]MSP[N] posWin = posWin == NOT_FOUND ? posUnix : posWin ; return Math . min ( posUnix , posWin ) + 1 ; }
if ( size <= prefix ) { return new String ( array , 0 , size ) ; } if ( lastIsDirectory && keepSeparator ) { MST[rv.UOI3Mutator]MSP[N] return new String ( array , 0 , size ) ; }
if ( repeat >= 0 ) { backtrack . push ( new int [] { wcsIdx , repeat } ) ; MST[rv.CRCR5Mutator]MSP[N] } } else { if ( ! caseSensitivity . checkRegionMatches ( fileName , textIdx , wcs [ wcsIdx ] ) ) { break; } }
System . arraycopy ( array , i + 1 , array , prefix , size - i ) ; size -= i + 1 - prefix ; MST[rv.AOR3Mutator]MSP[N] i = prefix + 1 ; } } if ( size <= 0 ) { return EMPTY_STRING ; }
if ( validOctets > IPV6_MAX_HEX_GROUPS || ( validOctets < IPV6_MAX_HEX_GROUPS && ! containsCompressedZeroes ) ) { return false ; MST[ReturnValsMutator]MSP[S] } return true ; } private static boolean isRFC3986HostName ( final String name ) { final String [] parts = name . split ( lr_13 , - 1 ) ;
if ( ! isIPv4Address ( octet ) ) { return false ; } validOctets += 2 ; continue; } if ( octet . length () > IPV6_MAX_HEX_DIGITS_PER_GROUP ) { return false ; } int octetInt = 0 ; MST[rv.CRCR3Mutator]MSP[N] try {
if ( IOCase . SYSTEM . checkEquals ( canonicalParent , canonicalChild ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] return false ; } return IOCase . SYSTEM . checkStartsWith ( canonicalChild , canonicalParent ) ; } public static String separatorsToUnix ( final String path ) {
return equals ( fileName1 , fileName2 , true , IOCase . SENSITIVE ) ; MST[NonVoidMethodCallMutator]MSP[N] } public static boolean equalsNormalizedOnSystem ( final String fileName1 , final String fileName2 ) { return equals ( fileName1 , fileName2 , true , IOCase . SYSTEM ) ; } public static boolean equals (
System . arraycopy ( array , i + 1 , array , i - 1 , size - i ) ; MST[rv.CRCR5Mutator]MSP[N] size -= 2 ; i -- ; } } outer: for ( int i = prefix + 2 ; i < size ; i ++ ) {
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND ) { return len + 1 ; MST[rv.ABSMutator]MSP[N] } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ; return Math . min ( posUnix , posWin ) + 1 ; }
if ( len < 0 ) { return null ; } if ( len > fileName . length () ) { failIfNullBytePresent ( fileName + UNIX_SEPARATOR ) ; return fileName + UNIX_SEPARATOR ; MST[NonVoidMethodCallMutator]MSP[N] } final String path = fileName . substring ( 0 , len ) ;
if ( octets . length > IPV6_MAX_HEX_GROUPS ) { return false ; } int validOctets = 0 ; int emptyOctets = 0 ; for ( int index = 0 ; index < octets . length ; index ++ ) { MST[InlineConstantMutator]MSP[N] final String octet = octets [ index ] ;
String fileName1 , String fileName2 , final boolean normalized , IOCase caseSensitivity ) { if ( fileName1 == null || fileName2 == null ) { return fileName1 == null && fileName2 == null ; MST[NegateConditionalsMutator]MSP[N] } if ( normalized ) { fileName1 = normalize ( fileName1 ) ;
if ( array [ i ] == separator && array [ i - 1 ] == separator ) { MST[rv.AOD1Mutator]MSP[N] System . arraycopy ( array , i , array , i - 1 , size - i ) ; size -- ; i -- ; } }
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2 ) { MST[rv.UOI1Mutator]MSP[N] return NOT_FOUND ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ;
int wcsIdx = 0 ; final Stack < int [] > backtrack = new Stack <> () ; do { if ( backtrack . size () > 0 ) { final int [] array = backtrack . pop () ; wcsIdx = array [ 0 ] ; MST[rv.CRCR3Mutator]MSP[S]
if ( array [ i ] == separator && array [ i - 1 ] == '.' && array [ i - 2 ] == '.' && MST[rv.AOR2Mutator]MSP[N] ( i == prefix + 2 || array [ i - 3 ] == separator ) ) {
textIdx = caseSensitivity . checkIndexOf ( fileName , textIdx , wcs [ wcsIdx ] ) ; if ( textIdx == NOT_FOUND ) { MST[rv.ROR2Mutator]MSP[N] break; } final int repeat = caseSensitivity . checkIndexOf ( fileName , textIdx + 1 , wcs [ wcsIdx ] ) ;
public static boolean directoryContains ( final String canonicalParent , final String canonicalChild ) throws IOException { if ( canonicalParent == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] throw new IllegalArgumentException ( lr_1 ) ; } if ( canonicalChild == null ) { return false ; }
if ( array [ i ] == separator && array [ i - 1 ] == separator ) { MST[rv.UOI1Mutator]MSP[N] System . arraycopy ( array , i , array , i - 1 , size - i ) ; size -- ; i -- ; } }
System . arraycopy ( array , i + 1 , array , i - 1 , size - i ) ; MST[rv.CRCR2Mutator]MSP[N] size -= 2 ; i -- ; } } outer: for ( int i = prefix + 2 ; i < size ; i ++ ) {
if ( array [ j ] == separator ) { MST[rv.UOI2Mutator]MSP[N] System . arraycopy ( array , i + 1 , array , j + 1 , size - i ) ; size -= i - j ; i = j + 1 ; continue outer; } }
if ( prefix > 0 ) { return normalize ( fullFileNameToAdd ) ; MST[ArgumentPropagationMutator]MSP[S] } if ( basePath == null ) { return null ; } final int len = basePath . length () ; if ( len == 0 ) { return normalize ( fullFileNameToAdd ) ; }
if ( octets . length > IPV6_MAX_HEX_GROUPS ) { MST[rv.CRCR4Mutator]MSP[N] return false ; } int validOctets = 0 ; int emptyOctets = 0 ; for ( int index = 0 ; index < octets . length ; index ++ ) { final String octet = octets [ index ] ;
return doNormalize ( fileName , separator , false ) ; } private static String doNormalize ( final String fileName , final char separator , final boolean keepSeparator ) { if ( fileName == null ) { return null ; } failIfNullBytePresent ( fileName ) ; MST[VoidMethodCallMutator]MSP[N]
if ( index == NOT_FOUND ) { return fileName ; } return fileName . substring ( 0 , index ) ; MST[InlineConstantMutator]MSP[N] } public static boolean equals ( final String fileName1 , final String fileName2 ) { return equals ( fileName1 , fileName2 , false , IOCase . SENSITIVE ) ;
final int lastWindowsPos = fileName . lastIndexOf ( WINDOWS_SEPARATOR ) ; return Math . max ( lastUnixPos , lastWindowsPos ) ; } public static int indexOfExtension ( final String fileName ) throws IllegalArgumentException { if ( fileName == null ) { return NOT_FOUND ; MST[rv.CRCR5Mutator]MSP[N] }
if ( ch == '?' || ch == '*' ) { MST[rv.UOI2Mutator]MSP[N] if ( buffer . length () != 0 ) { list . add ( buffer . toString () ) ; buffer . setLength ( 0 ) ; } if ( ch == '?' ) {
final int prefix = getPrefixLength ( fileName ) ; if ( prefix < 0 ) { return null ; } if ( prefix >= fileName . length () ) { if ( includeSeparator ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] return getPrefix ( fileName ) ; } return fileName ; }
if ( ch == '?' || ch == '*' ) { MST[rv.ROR5Mutator]MSP[N] if ( buffer . length () != 0 ) { list . add ( buffer . toString () ) ; buffer . setLength ( 0 ) ; } if ( ch == '?' ) {
System . arraycopy ( array , i + 1 , array , prefix , size - i ) ; size -= i + 1 - prefix ; i = prefix + 1 ; } } if ( size <= 0 ) { MST[rv.ROR3Mutator]MSP[S] return EMPTY_STRING ; }
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2 ) { MST[rv.CRCR5Mutator]MSP[N] return NOT_FOUND ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ;
return doNormalize ( fileName , SYSTEM_SEPARATOR , true ) ; MST[InlineConstantMutator]MSP[N] } public static String normalize ( final String fileName , final boolean unixSeparator ) { final char separator = unixSeparator ? UNIX_SEPARATOR : WINDOWS_SEPARATOR ; return doNormalize ( fileName , separator , true ) ; }
System . arraycopy ( array , i + 1 , array , prefix , size - i ) ; MST[rv.AOR2Mutator]MSP[N] size -= i + 1 - prefix ; i = prefix + 1 ; } } if ( size <= 0 ) { return EMPTY_STRING ; }
if ( i == prefix + 2 ) { return null ; } if ( i == size - 1 ) { lastIsDirectory = true ; } int j ; for ( j = i - 4 ; j >= prefix ; j -- ) { MST[rv.AOR3Mutator]MSP[N]
if ( octets . length > IPV6_MAX_HEX_GROUPS ) { MST[InlineConstantMutator]MSP[N] return false ; } int validOctets = 0 ; int emptyOctets = 0 ; for ( int index = 0 ; index < octets . length ; index ++ ) { final String octet = octets [ index ] ;
if ( ipSegment . length () > 1 && ipSegment . startsWith ( lr_8 ) ) { return false ; MST[rv.CRCR1Mutator]MSP[N] } } return true ; } private static boolean isIPv6Address ( final String inet6Address ) { final boolean containsCompressedZeroes = inet6Address . contains ( lr_9 ) ;
if ( array [ j ] == separator ) { System . arraycopy ( array , i + 1 , array , j + 1 , size - i ) ; MST[rv.AOD1Mutator]MSP[N] size -= i - j ; i = j + 1 ; continue outer; } }
return doNormalize ( fileName , separator , false ) ; MST[rv.UOI1Mutator]MSP[N] } private static String doNormalize ( final String fileName , final char separator , final boolean keepSeparator ) { if ( fileName == null ) { return null ; } failIfNullBytePresent ( fileName ) ;
if ( octet . length () == 0 ) { emptyOctets ++ ; if ( emptyOctets > 1 ) { return false ; } } else { emptyOctets = 0 ; if ( index == octets . length - 1 && octet . contains ( lr_12 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
String fileName1 , String fileName2 , final boolean normalized , IOCase caseSensitivity ) { if ( fileName1 == null || fileName2 == null ) { return fileName1 == null && fileName2 == null ; MST[rv.ROR5Mutator]MSP[N] } if ( normalized ) { fileName1 = normalize ( fileName1 ) ;
String fileName1 , String fileName2 , final boolean normalized , IOCase caseSensitivity ) { if ( fileName1 == null || fileName2 == null ) { return fileName1 == null && fileName2 == null ; MST[rv.CRCR5Mutator]MSP[N] } if ( normalized ) { fileName1 = normalize ( fileName1 ) ;
System . arraycopy ( array , i + 1 , array , prefix , size - i ) ; size -= i + 1 - prefix ; MST[rv.CRCR5Mutator]MSP[N] i = prefix + 1 ; } } if ( size <= 0 ) { return EMPTY_STRING ; }
return isSeparator ( ch0 ) ? 1 : 0 ; } } public static int indexOfLastSeparator ( final String fileName ) { if ( fileName == null ) { return NOT_FOUND ; MST[rv.CRCR2Mutator]MSP[N] } final int lastUnixPos = fileName . lastIndexOf ( UNIX_SEPARATOR ) ;
if ( len == 0 ) { return 0 ; } char ch0 = fileName . charAt ( 0 ) ; if ( ch0 == ':' ) { return NOT_FOUND ; } if ( len == 1 ) { if ( ch0 == '~' ) { return 2 ; MST[rv.CRCR5Mutator]MSP[S] }
private static boolean isIPv4Address ( final String name ) { final Matcher m = IPV4_PATTERN . matcher ( name ) ; if ( ! m . matches () || m . groupCount () != 4 ) { return false ; MST[rv.CRCR3Mutator]MSP[N] }
( i == prefix + 1 || array [ i - 2 ] == separator ) ) { if ( i == size - 1 ) { lastIsDirectory = true ; MST[InlineConstantMutator]MSP[N] }
if ( octets . length > IPV6_MAX_HEX_GROUPS ) { return false ; } int validOctets = 0 ; int emptyOctets = 0 ; for ( int index = 0 ; index < octets . length ; index ++ ) { final String octet = octets [ index ] ; MST[rv.UOI1Mutator]MSP[S]
return fileName . substring ( index + 1 ) ; MST[rv.AOR1Mutator]MSP[S] } private static void failIfNullBytePresent ( final String path ) { final int len = path . length () ; for ( int i = 0 ; i < len ; i ++ ) {
textIdx += wcs [ wcsIdx ] . length () ; MST[rv.ABSMutator]MSP[N] anyChars = false ; } wcsIdx ++ ; } if ( wcsIdx == wcs . length && textIdx == fileName . length () ) { return true ; } } while ( backtrack . size () > 0 );
if ( len == 2 || isSeparator ( fileName . charAt ( 2 ) ) == false ) { return 2 ; MST[InlineConstantMutator]MSP[N] } return 3 ; } else if ( ch0 == UNIX_SEPARATOR ) { return 1 ; } return NOT_FOUND ;
return fileName . substring ( index + 1 ) ; MST[rv.UOI1Mutator]MSP[N] } private static void failIfNullBytePresent ( final String path ) { final int len = path . length () ; for ( int i = 0 ; i < len ; i ++ ) {
public static String getExtension ( final String fileName ) throws IllegalArgumentException { if ( fileName == null ) { return null ; } final int index = indexOfExtension ( fileName ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( index == NOT_FOUND ) { return EMPTY_STRING ; }
final char [] array = text . toCharArray () ; final ArrayList < String > list = new ArrayList <> () ; final StringBuilder buffer = new StringBuilder () ; char prevChar = 0 ; for ( final char ch : array ) { MST[rv.UOI4Mutator]MSP[N]
return indexOfExtension ( fileName ) == NOT_FOUND ; } final String fileExt = getExtension ( fileName ) ; for ( final String extension : extensions ) { if ( fileExt . equals ( extension ) ) { return true ; } } return false ; MST[rv.CRCR1Mutator]MSP[N] }
octetInt = Integer . parseInt ( octet , BASE_16 ) ; } catch ( final NumberFormatException e ) { return false ; MST[rv.CRCR3Mutator]MSP[S] } if ( octetInt < 0 || octetInt > MAX_UNSIGNED_SHORT ) { return false ; } } validOctets ++ ; }
for ( int i = 0 ; i < parts . length ; i ++ ) { if ( parts [ i ] . length () == 0 ) { MST[rv.ROR4Mutator]MSP[N] return i == parts . length - 1 ; }
if ( len < 0 ) { MST[rv.ROR5Mutator]MSP[N] return null ; } if ( len > fileName . length () ) { failIfNullBytePresent ( fileName + UNIX_SEPARATOR ) ; return fileName + UNIX_SEPARATOR ; } final String path = fileName . substring ( 0 , len ) ;
if ( len < 0 ) { return null ; } if ( len > fileName . length () ) { failIfNullBytePresent ( fileName + UNIX_SEPARATOR ) ; return fileName + UNIX_SEPARATOR ; } final String path = fileName . substring ( 0 , len ) ; MST[rv.CRCR1Mutator]MSP[N]
return fileName . substring ( index + 1 ) ; MST[NonVoidMethodCallMutator]MSP[N] } private static void failIfNullBytePresent ( final String path ) { final int len = path . length () ; for ( int i = 0 ; i < len ; i ++ ) {
final int lastSeparator = indexOfLastSeparator ( fileName ) ; return lastSeparator > extensionPos ? NOT_FOUND : extensionPos ; MST[rv.CRCR4Mutator]MSP[N] } public static String getPrefix ( final String fileName ) { if ( fileName == null ) { return null ; } final int len = getPrefixLength ( fileName ) ;
return indexOfExtension ( fileName ) == NOT_FOUND ; } final String fileExt = getExtension ( fileName ) ; for ( final String extension : extensions ) { if ( fileExt . equals ( extension ) ) { return true ; MST[rv.CRCR3Mutator]MSP[N] } } return false ; }
for ( int i = 0 ; i < array . length ; i ++ ) { if ( array [ i ] == otherSeparator ) { MST[rv.ROR3Mutator]MSP[N] array [ i ] = separator ; } } boolean lastIsDirectory = true ;
if ( validOctets > IPV6_MAX_HEX_GROUPS || ( validOctets < IPV6_MAX_HEX_GROUPS && ! containsCompressedZeroes ) ) { return false ; } return true ; } private static boolean isRFC3986HostName ( final String name ) { final String [] parts = name . split ( lr_13 , - 1 ) ; MST[rv.CRCR2Mutator]MSP[N]
if ( extension == null || extension . isEmpty () ) { return indexOfExtension ( fileName ) == NOT_FOUND ; MST[rv.CRCR4Mutator]MSP[N] } final String fileExt = getExtension ( fileName ) ; return fileExt . equals ( extension ) ; }
for ( int i = prefix + 1 ; i < size ; i ++ ) { MST[rv.AOR3Mutator]MSP[S] if ( array [ i ] == separator && array [ i - 1 ] == '.' &&
} else if ( inet6Address . startsWith ( lr_9 ) && ! octetList . isEmpty () ) { MST[rv.ROR2Mutator]MSP[N] octetList . remove ( 0 ) ; } octets = octetList . toArray ( new String [ octetList . size () ] ) ; }
if ( path == null || path . indexOf ( WINDOWS_SEPARATOR ) == NOT_FOUND ) { return path ; } return path . replace ( WINDOWS_SEPARATOR , UNIX_SEPARATOR ) ; MST[rv.CRCR4Mutator]MSP[N] } public static String separatorsToWindows ( final String path ) {
if ( array [ i ] == separator && array [ i - 1 ] == '.' && array [ i - 2 ] == '.' && MST[rv.CRCR4Mutator]MSP[N] ( i == prefix + 2 || array [ i - 3 ] == separator ) ) {
return fileName . substring ( index + 1 ) ; MST[rv.CRCR4Mutator]MSP[N] } private static int getAdsCriticalOffset ( final String fileName ) { final int offset1 = fileName . lastIndexOf ( SYSTEM_SEPARATOR ) ; final int offset2 = fileName . lastIndexOf ( OTHER_SEPARATOR ) ;
if ( validOctets > IPV6_MAX_HEX_GROUPS || ( validOctets < IPV6_MAX_HEX_GROUPS && ! containsCompressedZeroes ) ) { MST[rv.CRCR1Mutator]MSP[N] return false ; } return true ; } private static boolean isRFC3986HostName ( final String name ) { final String [] parts = name . split ( lr_13 , - 1 ) ;
for ( int i = 0 ; i < parts . length ; i ++ ) { if ( parts [ i ] . length () == 0 ) { return i == parts . length - 1 ; MST[rv.CRCR6Mutator]MSP[N] }
System . arraycopy ( array , i + 1 , array , i - 1 , size - i ) ; size -= 2 ; i -- ; } } outer: for ( int i = prefix + 2 ; i < size ; i ++ ) { MST[rv.ROR1Mutator]MSP[N]
final int index = indexOfLastSeparator ( fileName ) ; if ( index < 0 ) { return fileName . substring ( 0 , prefix ) ; } int end = index + ( includeSeparator ? 1 : 0 ) ; MST[rv.CRCR6Mutator]MSP[N] if ( end == 0 ) { end ++ ;
if ( len == 2 || isSeparator ( fileName . charAt ( 2 ) ) == false ) { MST[rv.UOI3Mutator]MSP[N] return 2 ; } return 3 ; } else if ( ch0 == UNIX_SEPARATOR ) { return 1 ; } return NOT_FOUND ;
if ( extension == null || extension . isEmpty () ) { return indexOfExtension ( fileName ) == NOT_FOUND ; MST[rv.CRCR6Mutator]MSP[S] } final String fileExt = getExtension ( fileName ) ; return fileExt . equals ( extension ) ; }
final char ch1 = fileName . charAt ( 1 ) ; if ( ch1 == ':' ) { ch0 = Character . toUpperCase ( ch0 ) ; if ( ch0 >= 'A' && ch0 <= 'Z' ) { MST[rv.ROR3Mutator]MSP[N]
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2 ) { MST[rv.UOI2Mutator]MSP[N] return NOT_FOUND ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ;
if ( array [ size - 1 ] != separator ) { array [ size ++ ] = separator ; lastIsDirectory = false ; } for ( int i = prefix + 1 ; i < size ; i ++ ) { MST[rv.UOI3Mutator]MSP[N]
final char ch = basePath . charAt ( len - 1 ) ; MST[rv.CRCR5Mutator]MSP[N] if ( isSeparator ( ch ) ) { return normalize ( basePath + fullFileNameToAdd ) ; } return normalize ( basePath + '/' + fullFileNameToAdd ) ; }
if ( len < 0 ) { return null ; MST[ReturnValsMutator]MSP[S] } if ( len > fileName . length () ) { failIfNullBytePresent ( fileName + UNIX_SEPARATOR ) ; return fileName + UNIX_SEPARATOR ; } final String path = fileName . substring ( 0 , len ) ;
if ( validOctets > IPV6_MAX_HEX_GROUPS || ( validOctets < IPV6_MAX_HEX_GROUPS && ! containsCompressedZeroes ) ) { MST[rv.ROR4Mutator]MSP[S] return false ; } return true ; } private static boolean isRFC3986HostName ( final String name ) { final String [] parts = name . split ( lr_13 , - 1 ) ;
static boolean isSystemWindows () { return SYSTEM_SEPARATOR == WINDOWS_SEPARATOR ; } private static boolean isSeparator ( final char ch ) { return ch == UNIX_SEPARATOR || ch == WINDOWS_SEPARATOR ; MST[rv.CRCR6Mutator]MSP[N] } public static String normalize ( final String fileName ) {
static boolean isSystemWindows () { return SYSTEM_SEPARATOR == WINDOWS_SEPARATOR ; MST[rv.ROR3Mutator]MSP[N] } private static boolean isSeparator ( final char ch ) { return ch == UNIX_SEPARATOR || ch == WINDOWS_SEPARATOR ; } public static String normalize ( final String fileName ) {
if ( extension == null || extension . isEmpty () ) { MST[rv.ROR3Mutator]MSP[N] return indexOfExtension ( fileName ) == NOT_FOUND ; } final String fileExt = getExtension ( fileName ) ; return fileExt . equals ( extension ) ; }
if ( repeat >= 0 ) { backtrack . push ( new int [] { wcsIdx , repeat } ) ; } } else { if ( ! caseSensitivity . checkRegionMatches ( fileName , textIdx , wcs [ wcsIdx ] ) ) { MST[rv.ROR3Mutator]MSP[N] break; } }
for ( int i = 0 ; i < parts . length ; i ++ ) { MST[rv.UOI4Mutator]MSP[N] if ( parts [ i ] . length () == 0 ) { return i == parts . length - 1 ; }
if ( IOCase . SYSTEM . checkEquals ( canonicalParent , canonicalChild ) ) { return false ; } return IOCase . SYSTEM . checkStartsWith ( canonicalChild , canonicalParent ) ; MST[BooleanFalseReturnValsMutator]MSP[N] } public static String separatorsToUnix ( final String path ) {
final char ch1 = fileName . charAt ( 1 ) ; MST[rv.CRCR2Mutator]MSP[N] if ( ch1 == ':' ) { ch0 = Character . toUpperCase ( ch0 ) ; if ( ch0 >= 'A' && ch0 <= 'Z' ) {
for ( int i = prefix + 1 ; i < size ; i ++ ) { if ( array [ i ] == separator && array [ i - 1 ] == '.' && MST[rv.CRCR5Mutator]MSP[N]
} else if ( isSeparator ( ch0 ) && isSeparator ( ch1 ) ) { int posUnix = fileName . indexOf ( UNIX_SEPARATOR , 2 ) ; MST[InlineConstantMutator]MSP[N] int posWin = fileName . indexOf ( WINDOWS_SEPARATOR , 2 ) ;
public static String normalizeNoEndSeparator ( final String fileName ) { return doNormalize ( fileName , SYSTEM_SEPARATOR , false ) ; MST[rv.CRCR6Mutator]MSP[S] } public static String normalizeNoEndSeparator ( final String fileName , final boolean unixSeparator ) { final char separator = unixSeparator ? UNIX_SEPARATOR : WINDOWS_SEPARATOR ;
} public static boolean equalsOnSystem ( final String fileName1 , final String fileName2 ) { return equals ( fileName1 , fileName2 , false , IOCase . SYSTEM ) ; MST[BooleanTrueReturnValsMutator]MSP[N] } public static boolean equalsNormalized ( final String fileName1 , final String fileName2 ) {
final char ch1 = fileName . charAt ( 1 ) ; if ( ch1 == ':' ) { MST[rv.CRCR4Mutator]MSP[N] ch0 = Character . toUpperCase ( ch0 ) ; if ( ch0 >= 'A' && ch0 <= 'Z' ) {
if ( len < 0 ) { MST[rv.UOI3Mutator]MSP[N] return null ; } if ( len > fileName . length () ) { failIfNullBytePresent ( fileName + UNIX_SEPARATOR ) ; return fileName + UNIX_SEPARATOR ; } final String path = fileName . substring ( 0 , len ) ;
final int index = indexOfLastSeparator ( fileName ) ; if ( index < 0 ) { return fileName . substring ( 0 , prefix ) ; } int end = index + ( includeSeparator ? 1 : 0 ) ; if ( end == 0 ) { MST[rv.ROR4Mutator]MSP[S] end ++ ;
final int index = indexOfLastSeparator ( fileName ) ; final int endIndex = index + separatorAdd ; if ( prefix >= fileName . length () || index < 0 || prefix >= endIndex ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[S] return EMPTY_STRING ; }
for ( int i = 1 ; i <= 4 ; i ++ ) { MST[rv.ROR2Mutator]MSP[N] final String ipSegment = m . group ( i ) ; final int iIpSegment = Integer . parseInt ( ipSegment ) ; if ( iIpSegment > IPV4_MAX_OCTET_VALUE ) { return false ; }
return caseSensitivity . checkEquals ( fileName1 , fileName2 ) ; } public static boolean isExtension ( final String fileName , final String extension ) { if ( fileName == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return false ; } failIfNullBytePresent ( fileName ) ;
final List < String > octetList = new ArrayList <> ( Arrays . asList ( octets ) ) ; if ( inet6Address . endsWith ( lr_9 ) ) { MST[rv.ROR2Mutator]MSP[N] octetList . add ( lr_11 ) ;
if ( array [ i ] == separator && array [ i - 1 ] == '.' && array [ i - 2 ] == '.' && MST[rv.CRCR6Mutator]MSP[N] ( i == prefix + 2 || array [ i - 3 ] == separator ) ) {
if ( validOctets > IPV6_MAX_HEX_GROUPS || ( validOctets < IPV6_MAX_HEX_GROUPS && ! containsCompressedZeroes ) ) { return false ; } return true ; MST[rv.CRCR3Mutator]MSP[N] } private static boolean isRFC3986HostName ( final String name ) { final String [] parts = name . split ( lr_13 , - 1 ) ;
return wildcardMatch ( fileName , wildcardMatcher , IOCase . SYSTEM ) ; MST[NonVoidMethodCallMutator]MSP[S] } public static boolean wildcardMatch ( final String fileName , final String wildcardMatcher , IOCase caseSensitivity ) { if ( fileName == null && wildcardMatcher == null ) { return true ; }
return new String ( array , 0 , size - 1 ) ; MST[rv.CRCR3Mutator]MSP[N] } public static String concat ( final String basePath , final String fullFileNameToAdd ) { final int prefix = getPrefixLength ( fullFileNameToAdd ) ; if ( prefix < 0 ) { return null ; }
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2 ) { MST[rv.ABSMutator]MSP[N] return NOT_FOUND ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ;
if ( array [ i ] == separator && array [ i - 1 ] == separator ) { System . arraycopy ( array , i , array , i - 1 , size - i ) ; MST[rv.CRCR2Mutator]MSP[N] size -- ; i -- ; } }
return indexOfExtension ( fileName ) == NOT_FOUND ; MST[rv.ROR1Mutator]MSP[S] } final String fileExt = getExtension ( fileName ) ; for ( final String extension : extensions ) { if ( fileExt . equals ( extension ) ) { return true ; } } return false ; }
return indexOfExtension ( fileName ) == NOT_FOUND ; MST[rv.CRCR6Mutator]MSP[N] } final String fileExt = getExtension ( fileName ) ; for ( final String extension : extensions ) { if ( fileExt . equals ( extension ) ) { return true ; } } return false ; }
return false ; } static String [] splitOnTokens ( final String text ) { if ( text . indexOf ( '?' ) == NOT_FOUND && text . indexOf ( '*' ) == NOT_FOUND ) { MST[InlineConstantMutator]MSP[N] return new String [] { text } ; }
if ( path == null || path . indexOf ( UNIX_SEPARATOR ) == NOT_FOUND ) { return path ; } return path . replace ( UNIX_SEPARATOR , WINDOWS_SEPARATOR ) ; MST[EmptyObjectReturnValsMutator]MSP[N] } public static String separatorsToSystem ( final String path ) { if ( path == null ) {
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND ) { return len + 1 ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return Math . min ( posUnix , posWin ) + 1 ; }
fileName2 = normalize ( fileName2 ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( fileName1 == null || fileName2 == null ) { throw new NullPointerException ( lr_5 ) ; } } if ( caseSensitivity == null ) { caseSensitivity = IOCase . SENSITIVE ; }
textIdx = array [ 1 ] ; MST[rv.CRCR5Mutator]MSP[S] anyChars = true ; } while ( wcsIdx < wcs . length ) { if ( wcs [ wcsIdx ] . equals ( lr_6 ) ) { textIdx ++ ; if ( textIdx > fileName . length () ) { break; }
for ( int i = prefix + 1 ; i < size ; i ++ ) { MST[rv.AOD2Mutator]MSP[S] if ( array [ i ] == separator && array [ i - 1 ] == '.' &&
} return fileName . substring ( 0 , end ) ; MST[rv.CRCR6Mutator]MSP[N] } public static String getName ( final String fileName ) { if ( fileName == null ) { return null ; } failIfNullBytePresent ( fileName ) ; final int index = indexOfLastSeparator ( fileName ) ;
return fileName . substring ( index + 1 ) ; MST[NonVoidMethodCallMutator]MSP[N] } private static int getAdsCriticalOffset ( final String fileName ) { final int offset1 = fileName . lastIndexOf ( SYSTEM_SEPARATOR ) ; final int offset2 = fileName . lastIndexOf ( OTHER_SEPARATOR ) ;
for ( int i = 0 ; i < array . length ; i ++ ) { if ( array [ i ] == otherSeparator ) { MST[rv.UOI4Mutator]MSP[N] array [ i ] = separator ; } } boolean lastIsDirectory = true ;
public static boolean directoryContains ( final String canonicalParent , final String canonicalChild ) throws IOException { if ( canonicalParent == null ) { throw new IllegalArgumentException ( lr_1 ) ; } if ( canonicalChild == null ) { return false ; MST[rv.CRCR3Mutator]MSP[N] }
if ( array [ i ] == separator && array [ i - 1 ] == '.' && array [ i - 2 ] == '.' && MST[rv.UOI1Mutator]MSP[N] ( i == prefix + 2 || array [ i - 3 ] == separator ) ) {
textIdx = caseSensitivity . checkIndexOf ( fileName , textIdx , wcs [ wcsIdx ] ) ; if ( textIdx == NOT_FOUND ) { MST[rv.ABSMutator]MSP[S] break; } final int repeat = caseSensitivity . checkIndexOf ( fileName , textIdx + 1 , wcs [ wcsIdx ] ) ;
for ( int i = 1 ; i <= 4 ; i ++ ) { final String ipSegment = m . group ( i ) ; final int iIpSegment = Integer . parseInt ( ipSegment ) ; if ( iIpSegment > IPV4_MAX_OCTET_VALUE ) { MST[rv.ROR3Mutator]MSP[S] return false ; }
if ( array [ size - 1 ] != separator ) { MST[rv.ROR4Mutator]MSP[N] array [ size ++ ] = separator ; lastIsDirectory = false ; } for ( int i = prefix + 1 ; i < size ; i ++ ) {
final int prefix = getPrefixLength ( fileName ) ; if ( prefix < 0 ) { return null ; } if ( prefix >= fileName . length () ) { MST[rv.UOI3Mutator]MSP[N] if ( includeSeparator ) { return getPrefix ( fileName ) ; } return fileName ; }
return indexOfExtension ( fileName ) == NOT_FOUND ; } final String fileExt = getExtension ( fileName ) ; for ( final String extension : extensions ) { if ( fileExt . equals ( extension ) ) { return true ; MST[InlineConstantMutator]MSP[N] } } return false ; }
if ( array [ size - 1 ] != separator ) { MST[rv.AOR3Mutator]MSP[N] array [ size ++ ] = separator ; lastIsDirectory = false ; } for ( int i = prefix + 1 ; i < size ; i ++ ) {
} else if ( isSeparator ( ch0 ) && isSeparator ( ch1 ) ) { int posUnix = fileName . indexOf ( UNIX_SEPARATOR , 2 ) ; MST[rv.CRCR2Mutator]MSP[N] int posWin = fileName . indexOf ( WINDOWS_SEPARATOR , 2 ) ;
} else if ( isSeparator ( ch0 ) && isSeparator ( ch1 ) ) { int posUnix = fileName . indexOf ( UNIX_SEPARATOR , 2 ) ; MST[InlineConstantMutator]MSP[N] int posWin = fileName . indexOf ( WINDOWS_SEPARATOR , 2 ) ;
if ( containsCompressedZeroes && ( inet6Address . indexOf ( lr_9 ) != inet6Address . lastIndexOf ( lr_9 ) ) ) { return false ; } if ( ( inet6Address . startsWith ( lr_10 ) && ! inet6Address . startsWith ( lr_9 ) ) MST[NegateConditionalsMutator]MSP[S]
System . arraycopy ( array , i + 1 , array , i - 1 , size - i ) ; size -= 2 ; i -- ; } } outer: for ( int i = prefix + 2 ; i < size ; i ++ ) { MST[rv.CRCR6Mutator]MSP[S]
if ( array [ j ] == separator ) { System . arraycopy ( array , i + 1 , array , j + 1 , size - i ) ; size -= i - j ; MST[rv.AOD2Mutator]MSP[N] i = j + 1 ; continue outer; } }
if ( path == null || path . indexOf ( UNIX_SEPARATOR ) == NOT_FOUND ) { return path ; } return path . replace ( UNIX_SEPARATOR , WINDOWS_SEPARATOR ) ; MST[rv.CRCR2Mutator]MSP[N] } public static String separatorsToSystem ( final String path ) { if ( path == null ) {
if ( ipSegment . length () > 1 && ipSegment . startsWith ( lr_8 ) ) { return false ; } } return true ; } private static boolean isIPv6Address ( final String inet6Address ) { final boolean containsCompressedZeroes = inet6Address . contains ( lr_9 ) ; MST[NonVoidMethodCallMutator]MSP[N]
return wildcardMatch ( fileName , wildcardMatcher , IOCase . SYSTEM ) ; } public static boolean wildcardMatch ( final String fileName , final String wildcardMatcher , IOCase caseSensitivity ) { if ( fileName == null && wildcardMatcher == null ) { MST[NegateConditionalsMutator]MSP[N] return true ; }
return Math . max ( offset1 , offset2 ) + 1 ; } public static String removeExtension ( final String fileName ) { if ( fileName == null ) { MST[rv.ROR5Mutator]MSP[N] return null ; } failIfNullBytePresent ( fileName ) ; final int index = indexOfExtension ( fileName ) ;
return indexOfExtension ( fileName ) == NOT_FOUND ; } final String fileExt = getExtension ( fileName ) ; for ( final String extension : extensions ) { if ( fileExt . equals ( extension ) ) { return true ; MST[rv.CRCR2Mutator]MSP[N] } } return false ; }
if ( containsCompressedZeroes && ( inet6Address . indexOf ( lr_9 ) != inet6Address . lastIndexOf ( lr_9 ) ) ) { return false ; } if ( ( inet6Address . startsWith ( lr_10 ) && ! inet6Address . startsWith ( lr_9 ) ) MST[rv.ROR2Mutator]MSP[N]
if ( array [ i ] == separator && array [ i - 1 ] == separator ) { System . arraycopy ( array , i , array , i - 1 , size - i ) ; MST[rv.ABSMutator]MSP[N] size -- ; i -- ; } }
public static boolean isExtension ( final String fileName , final Collection < String > extensions ) { if ( fileName == null ) { return false ; } failIfNullBytePresent ( fileName ) ; if ( extensions == null || extensions . isEmpty () ) { MST[rv.ROR5Mutator]MSP[N]
if ( containsCompressedZeroes && ( inet6Address . indexOf ( lr_9 ) != inet6Address . lastIndexOf ( lr_9 ) ) ) { return false ; } if ( ( inet6Address . startsWith ( lr_10 ) && ! inet6Address . startsWith ( lr_9 ) ) MST[rv.ROR5Mutator]MSP[S]
final char [] array = new char [ size + 2 ] ; MST[rv.UOI2Mutator]MSP[N] fileName . getChars ( 0 , fileName . length () , array , 0 ) ; final char otherSeparator = separator == SYSTEM_SEPARATOR ? OTHER_SEPARATOR : SYSTEM_SEPARATOR ;
System . arraycopy ( array , i + 1 , array , prefix , size - i ) ; size -= i + 1 - prefix ; MST[rv.AOR1Mutator]MSP[N] i = prefix + 1 ; } } if ( size <= 0 ) { return EMPTY_STRING ; }
if ( size <= prefix ) { return new String ( array , 0 , size ) ; MST[rv.UOI1Mutator]MSP[N] } if ( lastIsDirectory && keepSeparator ) { return new String ( array , 0 , size ) ; }
final int pos = Math . min ( posUnix , posWin ) + 1 ; final String hostnamePart = fileName . substring ( 2 , pos - 1 ) ; return isValidHostName ( hostnamePart ) ? pos : NOT_FOUND ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } else {
if ( len == 0 ) { return 0 ; } char ch0 = fileName . charAt ( 0 ) ; if ( ch0 == ':' ) { return NOT_FOUND ; } if ( len == 1 ) { MST[rv.CRCR5Mutator]MSP[N] if ( ch0 == '~' ) { return 2 ; }
public static boolean isExtension ( final String fileName , final Collection < String > extensions ) { if ( fileName == null ) { return false ; MST[ReturnValsMutator]MSP[N] } failIfNullBytePresent ( fileName ) ; if ( extensions == null || extensions . isEmpty () ) {
|| ( inet6Address . endsWith ( lr_10 ) && ! inet6Address . endsWith ( lr_9 ) ) ) { MST[NonVoidMethodCallMutator]MSP[N] return false ; } String [] octets = inet6Address . split ( lr_10 ) ; if ( containsCompressedZeroes ) {
if ( path == null || path . indexOf ( WINDOWS_SEPARATOR ) == NOT_FOUND ) { MST[rv.ROR1Mutator]MSP[N] return path ; } return path . replace ( WINDOWS_SEPARATOR , UNIX_SEPARATOR ) ; } public static String separatorsToWindows ( final String path ) {
if ( len == 2 || isSeparator ( fileName . charAt ( 2 ) ) == false ) { return 2 ; MST[rv.CRCR2Mutator]MSP[N] } return 3 ; } else if ( ch0 == UNIX_SEPARATOR ) { return 1 ; } return NOT_FOUND ;
final int index = indexOfLastSeparator ( fileName ) ; if ( index < 0 ) { return fileName . substring ( 0 , prefix ) ; MST[rv.CRCR3Mutator]MSP[N] } int end = index + ( includeSeparator ? 1 : 0 ) ; if ( end == 0 ) { end ++ ;
if ( ch == '?' || ch == '*' ) { MST[rv.CRCR5Mutator]MSP[N] if ( buffer . length () != 0 ) { list . add ( buffer . toString () ) ; buffer . setLength ( 0 ) ; } if ( ch == '?' ) {
if ( i == prefix + 2 ) { return null ; } if ( i == size - 1 ) { lastIsDirectory = true ; } int j ; for ( j = i - 4 ; j >= prefix ; j -- ) { MST[rv.AOD2Mutator]MSP[N]
final char ch = basePath . charAt ( len - 1 ) ; MST[rv.UOI4Mutator]MSP[N] if ( isSeparator ( ch ) ) { return normalize ( basePath + fullFileNameToAdd ) ; } return normalize ( basePath + '/' + fullFileNameToAdd ) ; }
public static boolean isExtension ( final String fileName , final String ... extensions ) { if ( fileName == null ) { return false ; MST[BooleanTrueReturnValsMutator]MSP[N] } failIfNullBytePresent ( fileName ) ; if ( extensions == null || extensions . length == 0 ) {
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2 ) { MST[NegateConditionalsMutator]MSP[N] return NOT_FOUND ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ;
final int lastWindowsPos = fileName . lastIndexOf ( WINDOWS_SEPARATOR ) ; return Math . max ( lastUnixPos , lastWindowsPos ) ; MST[rv.UOI3Mutator]MSP[N] } public static int indexOfExtension ( final String fileName ) throws IllegalArgumentException { if ( fileName == null ) { return NOT_FOUND ; }
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2 ) { return NOT_FOUND ; MST[PrimitiveReturnsMutator]MSP[N] } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ;
if ( validOctets > IPV6_MAX_HEX_GROUPS || ( validOctets < IPV6_MAX_HEX_GROUPS && ! containsCompressedZeroes ) ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] return false ; } return true ; } private static boolean isRFC3986HostName ( final String name ) { final String [] parts = name . split ( lr_13 , - 1 ) ;
final char [] array = text . toCharArray () ; final ArrayList < String > list = new ArrayList <> () ; final StringBuilder buffer = new StringBuilder () ; char prevChar = 0 ; MST[rv.CRCR3Mutator]MSP[N] for ( final char ch : array ) {
System . arraycopy ( array , i + 1 , array , prefix , size - i ) ; size -= i + 1 - prefix ; i = prefix + 1 ; MST[rv.AOR2Mutator]MSP[N] } } if ( size <= 0 ) { return EMPTY_STRING ; }
if ( len < 0 ) { return null ; } if ( len > fileName . length () ) { MST[rv.ROR3Mutator]MSP[N] failIfNullBytePresent ( fileName + UNIX_SEPARATOR ) ; return fileName + UNIX_SEPARATOR ; } final String path = fileName . substring ( 0 , len ) ;
if ( len == 0 ) { return 0 ; } char ch0 = fileName . charAt ( 0 ) ; if ( ch0 == ':' ) { return NOT_FOUND ; } if ( len == 1 ) { if ( ch0 == '~' ) { MST[InlineConstantMutator]MSP[N] return 2 ; }
return indexOfExtension ( fileName ) == NOT_FOUND ; } final String fileExt = getExtension ( fileName ) ; for ( final String extension : extensions ) { if ( fileExt . equals ( extension ) ) { return true ; } } return false ; MST[ReturnValsMutator]MSP[N] }
if ( path . charAt ( i ) == 0 ) { throw new IllegalArgumentException ( lr_3 + lr_4 ) ; } } } public static String getBaseName ( final String fileName ) { return removeExtension ( getName ( fileName ) ) ; MST[EmptyObjectReturnValsMutator]MSP[N] }
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND ) { MST[rv.CRCR1Mutator]MSP[N] return len + 1 ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ; return Math . min ( posUnix , posWin ) + 1 ; }
return false ; } static String [] splitOnTokens ( final String text ) { if ( text . indexOf ( '?' ) == NOT_FOUND && text . indexOf ( '*' ) == NOT_FOUND ) { return new String [] { text } ; MST[rv.CRCR4Mutator]MSP[N] }
if ( isSystemWindows () ) { final int offset = fileName . indexOf ( ':' , getAdsCriticalOffset ( fileName ) ) ; if ( offset != - 1 ) { throw new IllegalArgumentException ( lr_2 ) ; } } final int extensionPos = fileName . lastIndexOf ( EXTENSION_SEPARATOR ) ; MST[rv.CRCR1Mutator]MSP[N]
if ( len < 0 ) { MST[NegateConditionalsMutator]MSP[N] return null ; } if ( len > fileName . length () ) { failIfNullBytePresent ( fileName + UNIX_SEPARATOR ) ; return fileName + UNIX_SEPARATOR ; } final String path = fileName . substring ( 0 , len ) ;
if ( size <= prefix ) { MST[rv.UOI2Mutator]MSP[N] return new String ( array , 0 , size ) ; } if ( lastIsDirectory && keepSeparator ) { return new String ( array , 0 , size ) ; }
failIfNullBytePresent ( path ) ; return path ; } public static String getPath ( final String fileName ) { return doGetPath ( fileName , 1 ) ; MST[ArgumentPropagationMutator]MSP[N] } public static String getPathNoEndSeparator ( final String fileName ) { return doGetPath ( fileName , 0 ) ; }
if ( i == prefix + 2 ) { MST[rv.UOI4Mutator]MSP[N] return null ; } if ( i == size - 1 ) { lastIsDirectory = true ; } int j ; for ( j = i - 4 ; j >= prefix ; j -- ) {
octetInt = Integer . parseInt ( octet , BASE_16 ) ; MST[rv.CRCR6Mutator]MSP[N] } catch ( final NumberFormatException e ) { return false ; } if ( octetInt < 0 || octetInt > MAX_UNSIGNED_SHORT ) { return false ; } } validOctets ++ ; }
public static boolean isExtension ( final String fileName , final Collection < String > extensions ) { if ( fileName == null ) { return false ; } failIfNullBytePresent ( fileName ) ; if ( extensions == null || extensions . isEmpty () ) { MST[NegateConditionalsMutator]MSP[N]
if ( ipSegment . length () > 1 && ipSegment . startsWith ( lr_8 ) ) { MST[rv.ROR1Mutator]MSP[S] return false ; } } return true ; } private static boolean isIPv6Address ( final String inet6Address ) { final boolean containsCompressedZeroes = inet6Address . contains ( lr_9 ) ;
final int index = indexOfLastSeparator ( fileName ) ; final int endIndex = index + separatorAdd ; if ( prefix >= fileName . length () || index < 0 || prefix >= endIndex ) { MST[rv.ABSMutator]MSP[S] return EMPTY_STRING ; }
String fileName1 , String fileName2 , final boolean normalized , IOCase caseSensitivity ) { if ( fileName1 == null || fileName2 == null ) { return fileName1 == null && fileName2 == null ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } if ( normalized ) { fileName1 = normalize ( fileName1 ) ;
if ( array [ size - 1 ] != separator ) { array [ size ++ ] = separator ; MST[rv.UOI4Mutator]MSP[N] lastIsDirectory = false ; } for ( int i = prefix + 1 ; i < size ; i ++ ) {
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2 ) { MST[rv.ROR5Mutator]MSP[N] return NOT_FOUND ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ;
if ( octet . length () == 0 ) { emptyOctets ++ ; if ( emptyOctets > 1 ) { return false ; } } else { emptyOctets = 0 ; if ( index == octets . length - 1 && octet . contains ( lr_12 ) ) { MST[rv.ROR2Mutator]MSP[N]
if ( ch == '?' || ch == '*' ) { if ( buffer . length () != 0 ) { list . add ( buffer . toString () ) ; buffer . setLength ( 0 ) ; } if ( ch == '?' ) { MST[rv.ROR4Mutator]MSP[N]
if ( array [ j ] == separator ) { System . arraycopy ( array , i + 1 , array , j + 1 , size - i ) ; size -= i - j ; MST[MathMutator]MSP[N] i = j + 1 ; continue outer; } }
final int index = indexOfLastSeparator ( fileName ) ; final int endIndex = index + separatorAdd ; if ( prefix >= fileName . length () || index < 0 || prefix >= endIndex ) { MST[rv.UOI1Mutator]MSP[N] return EMPTY_STRING ; }
if ( array [ i ] == separator && array [ i - 1 ] == '.' && array [ i - 2 ] == '.' && MST[rv.CRCR5Mutator]MSP[N] ( i == prefix + 2 || array [ i - 3 ] == separator ) ) {
System . arraycopy ( array , i + 1 , array , i - 1 , size - i ) ; size -= 2 ; i -- ; } } outer: for ( int i = prefix + 2 ; i < size ; i ++ ) { MST[rv.AOR3Mutator]MSP[N]
if ( array [ i ] == separator && array [ i - 1 ] == separator ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] System . arraycopy ( array , i , array , i - 1 , size - i ) ; size -- ; i -- ; } }
if ( array [ j ] == separator ) { System . arraycopy ( array , i + 1 , array , j + 1 , size - i ) ; MST[rv.CRCR4Mutator]MSP[N] size -= i - j ; i = j + 1 ; continue outer; } }
for ( int i = prefix + 1 ; i < size ; i ++ ) { MST[rv.ROR1Mutator]MSP[N] if ( array [ i ] == separator && array [ i - 1 ] == '.' &&
final char ch = basePath . charAt ( len - 1 ) ; if ( isSeparator ( ch ) ) { MST[NonVoidMethodCallMutator]MSP[N] return normalize ( basePath + fullFileNameToAdd ) ; } return normalize ( basePath + '/' + fullFileNameToAdd ) ; }
textIdx = caseSensitivity . checkIndexOf ( fileName , textIdx , wcs [ wcsIdx ] ) ; if ( textIdx == NOT_FOUND ) { MST[rv.UOI1Mutator]MSP[N] break; } final int repeat = caseSensitivity . checkIndexOf ( fileName , textIdx + 1 , wcs [ wcsIdx ] ) ;
if ( len == 2 || isSeparator ( fileName . charAt ( 2 ) ) == false ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return 2 ; } return 3 ; } else if ( ch0 == UNIX_SEPARATOR ) { return 1 ; } return NOT_FOUND ;
public static boolean isExtension ( final String fileName , final String ... extensions ) { if ( fileName == null ) { return false ; } failIfNullBytePresent ( fileName ) ; if ( extensions == null || extensions . length == 0 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S]
final char [] array = new char [ size + 2 ] ; MST[rv.ABSMutator]MSP[N] fileName . getChars ( 0 , fileName . length () , array , 0 ) ; final char otherSeparator = separator == SYSTEM_SEPARATOR ? OTHER_SEPARATOR : SYSTEM_SEPARATOR ;
( i == prefix + 1 || array [ i - 2 ] == separator ) ) { if ( i == size - 1 ) { MST[rv.UOI1Mutator]MSP[N] lastIsDirectory = true ; }
return false ; } static String [] splitOnTokens ( final String text ) { if ( text . indexOf ( '?' ) == NOT_FOUND && text . indexOf ( '*' ) == NOT_FOUND ) { MST[rv.ROR1Mutator]MSP[N] return new String [] { text } ; }
if ( path == null || path . indexOf ( UNIX_SEPARATOR ) == NOT_FOUND ) { MST[rv.ROR1Mutator]MSP[N] return path ; } return path . replace ( UNIX_SEPARATOR , WINDOWS_SEPARATOR ) ; } public static String separatorsToSystem ( final String path ) { if ( path == null ) {
if ( octet . length () == 0 ) { emptyOctets ++ ; if ( emptyOctets > 1 ) { MST[NegateConditionalsMutator]MSP[N] return false ; } } else { emptyOctets = 0 ; if ( index == octets . length - 1 && octet . contains ( lr_12 ) ) {
final int lastWindowsPos = fileName . lastIndexOf ( WINDOWS_SEPARATOR ) ; MST[ArgumentPropagationMutator]MSP[N] return Math . max ( lastUnixPos , lastWindowsPos ) ; } public static int indexOfExtension ( final String fileName ) throws IllegalArgumentException { if ( fileName == null ) { return NOT_FOUND ; }
textIdx = caseSensitivity . checkIndexOf ( fileName , textIdx , wcs [ wcsIdx ] ) ; if ( textIdx == NOT_FOUND ) { MST[InlineConstantMutator]MSP[S] break; } final int repeat = caseSensitivity . checkIndexOf ( fileName , textIdx + 1 , wcs [ wcsIdx ] ) ;
System . arraycopy ( array , i + 1 , array , i - 1 , size - i ) ; MST[rv.AOD2Mutator]MSP[N] size -= 2 ; i -- ; } } outer: for ( int i = prefix + 2 ; i < size ; i ++ ) {
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND ) { return len + 1 ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ; return Math . min ( posUnix , posWin ) + 1 ; MST[rv.UOI2Mutator]MSP[N] }
} else if ( inet6Address . startsWith ( lr_9 ) && ! octetList . isEmpty () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] octetList . remove ( 0 ) ; } octets = octetList . toArray ( new String [ octetList . size () ] ) ; }
System . arraycopy ( array , i + 1 , array , i - 1 , size - i ) ; size -= 2 ; i -- ; } } outer: for ( int i = prefix + 2 ; i < size ; i ++ ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N]
for ( int i = 0 ; i < parts . length ; i ++ ) { if ( parts [ i ] . length () == 0 ) { return i == parts . length - 1 ; MST[rv.ROR5Mutator]MSP[N] }
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2 ) { return NOT_FOUND ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; MST[rv.UOI1Mutator]MSP[N] posWin = posWin == NOT_FOUND ? posUnix : posWin ;
if ( octet . length () == 0 ) { emptyOctets ++ ; if ( emptyOctets > 1 ) { return false ; } } else { emptyOctets = 0 ; if ( index == octets . length - 1 && octet . contains ( lr_12 ) ) { MST[NegateConditionalsMutator]MSP[S]
return indexOfExtension ( fileName ) == NOT_FOUND ; } final String fileExt = getExtension ( fileName ) ; MST[ArgumentPropagationMutator]MSP[N] for ( final String extension : extensions ) { if ( fileExt . equals ( extension ) ) { return true ; } } return false ; }
int wcsIdx = 0 ; final Stack < int [] > backtrack = new Stack <> () ; do { if ( backtrack . size () > 0 ) { final int [] array = backtrack . pop () ; wcsIdx = array [ 0 ] ; MST[rv.UOI4Mutator]MSP[N]
if ( octet . length () == 0 ) { emptyOctets ++ ; MST[experimental.RemoveIncrementsMutator]MSP[N] if ( emptyOctets > 1 ) { return false ; } } else { emptyOctets = 0 ; if ( index == octets . length - 1 && octet . contains ( lr_12 ) ) {
if ( len == 2 || isSeparator ( fileName . charAt ( 2 ) ) == false ) { MST[rv.CRCR3Mutator]MSP[N] return 2 ; } return 3 ; } else if ( ch0 == UNIX_SEPARATOR ) { return 1 ; } return NOT_FOUND ;
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2 ) { MST[rv.CRCR2Mutator]MSP[N] return NOT_FOUND ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ;
public static boolean isExtension ( final String fileName , final String ... extensions ) { if ( fileName == null ) { return false ; MST[rv.CRCR3Mutator]MSP[N] } failIfNullBytePresent ( fileName ) ; if ( extensions == null || extensions . length == 0 ) {
final int pos = Math . min ( posUnix , posWin ) + 1 ; final String hostnamePart = fileName . substring ( 2 , pos - 1 ) ; MST[rv.AOD2Mutator]MSP[N] return isValidHostName ( hostnamePart ) ? pos : NOT_FOUND ; } else {
private static String doGetPath ( final String fileName , final int separatorAdd ) { if ( fileName == null ) { return null ; } final int prefix = getPrefixLength ( fileName ) ; if ( prefix < 0 ) { MST[ConditionalsBoundaryMutator]MSP[N] return null ; }
anyChars = false ; } else if ( wcs [ wcsIdx ] . equals ( lr_7 ) ) { MST[rv.ROR5Mutator]MSP[N] anyChars = true ; if ( wcsIdx == wcs . length - 1 ) { textIdx = fileName . length () ; } } else { if ( anyChars ) {
textIdx += wcs [ wcsIdx ] . length () ; anyChars = false ; } wcsIdx ++ ; } if ( wcsIdx == wcs . length && textIdx == fileName . length () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return true ; } } while ( backtrack . size () > 0 );
System . arraycopy ( array , i + 1 , array , prefix , size - i ) ; MST[rv.UOI1Mutator]MSP[N] size -= i + 1 - prefix ; i = prefix + 1 ; } } if ( size <= 0 ) { return EMPTY_STRING ; }
if ( i == prefix + 2 ) { return null ; } if ( i == size - 1 ) { lastIsDirectory = true ; } int j ; for ( j = i - 4 ; j >= prefix ; j -- ) { MST[rv.ROR1Mutator]MSP[N]
anyChars = false ; } else if ( wcs [ wcsIdx ] . equals ( lr_7 ) ) { anyChars = true ; MST[rv.CRCR5Mutator]MSP[N] if ( wcsIdx == wcs . length - 1 ) { textIdx = fileName . length () ; } } else { if ( anyChars ) {
if ( array [ i ] == separator && array [ i - 1 ] == '.' && array [ i - 2 ] == '.' && MST[InlineConstantMutator]MSP[N] ( i == prefix + 2 || array [ i - 3 ] == separator ) ) {
return indexOfExtension ( fileName ) == NOT_FOUND ; } final String fileExt = getExtension ( fileName ) ; for ( final String extension : extensions ) { if ( fileExt . equals ( extension ) ) { MST[NonVoidMethodCallMutator]MSP[N] return true ; } } return false ; }
if ( array [ i ] == separator && array [ i - 1 ] == separator ) { System . arraycopy ( array , i , array , i - 1 , size - i ) ; MST[MathMutator]MSP[N] size -- ; i -- ; } }
} else if ( isSeparator ( ch0 ) && isSeparator ( ch1 ) ) { int posUnix = fileName . indexOf ( UNIX_SEPARATOR , 2 ) ; int posWin = fileName . indexOf ( WINDOWS_SEPARATOR , 2 ) ; MST[ArgumentPropagationMutator]MSP[N]
return false ; } static String [] splitOnTokens ( final String text ) { if ( text . indexOf ( '?' ) == NOT_FOUND && text . indexOf ( '*' ) == NOT_FOUND ) { MST[rv.CRCR6Mutator]MSP[N] return new String [] { text } ; }
final List < String > octetList = new ArrayList <> ( Arrays . asList ( octets ) ) ; if ( inet6Address . endsWith ( lr_9 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] octetList . add ( lr_11 ) ;
for ( int i = prefix + 1 ; i < size ; i ++ ) { if ( array [ i ] == separator && array [ i - 1 ] == '.' && MST[rv.AOD2Mutator]MSP[N]
list . add ( buffer . toString () ) ; } return list . toArray ( new String [ list . size () ] ) ; } private static boolean isValidHostName ( final String name ) { return isIPv6Address ( name ) || isRFC3986HostName ( name ) ; MST[rv.ROR2Mutator]MSP[N] }
if ( size <= prefix ) { return new String ( array , 0 , size ) ; } if ( lastIsDirectory && keepSeparator ) { MST[rv.UOI2Mutator]MSP[N] return new String ( array , 0 , size ) ; }
final char ch1 = fileName . charAt ( 1 ) ; if ( ch1 == ':' ) { MST[rv.ROR4Mutator]MSP[N] ch0 = Character . toUpperCase ( ch0 ) ; if ( ch0 >= 'A' && ch0 <= 'Z' ) {
} return fileName . substring ( 0 , end ) ; MST[rv.ABSMutator]MSP[N] } public static String getName ( final String fileName ) { if ( fileName == null ) { return null ; } failIfNullBytePresent ( fileName ) ; final int index = indexOfLastSeparator ( fileName ) ;
for ( int i = 1 ; i <= 4 ; i ++ ) { MST[rv.CRCR2Mutator]MSP[N] final String ipSegment = m . group ( i ) ; final int iIpSegment = Integer . parseInt ( ipSegment ) ; if ( iIpSegment > IPV4_MAX_OCTET_VALUE ) { return false ; }
list . add ( buffer . toString () ) ; } return list . toArray ( new String [ list . size () ] ) ; } private static boolean isValidHostName ( final String name ) { return isIPv6Address ( name ) || isRFC3986HostName ( name ) ; MST[rv.CRCR3Mutator]MSP[N] }
if ( path == null || path . indexOf ( WINDOWS_SEPARATOR ) == NOT_FOUND ) { return path ; } return path . replace ( WINDOWS_SEPARATOR , UNIX_SEPARATOR ) ; MST[InlineConstantMutator]MSP[N] } public static String separatorsToWindows ( final String path ) {
if ( octets . length > IPV6_MAX_HEX_GROUPS ) { return false ; } int validOctets = 0 ; int emptyOctets = 0 ; for ( int index = 0 ; index < octets . length ; index ++ ) { MST[ConditionalsBoundaryMutator]MSP[N] final String octet = octets [ index ] ;
for ( int i = prefix + 1 ; i < size ; i ++ ) { MST[IncrementsMutator]MSP[N] if ( array [ i ] == separator && array [ i - 1 ] == '.' &&
list . add ( buffer . toString () ) ; } return list . toArray ( new String [ list . size () ] ) ; } private static boolean isValidHostName ( final String name ) { return isIPv6Address ( name ) || isRFC3986HostName ( name ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] }
if ( path == null || path . indexOf ( WINDOWS_SEPARATOR ) == NOT_FOUND ) { MST[NegateConditionalsMutator]MSP[N] return path ; } return path . replace ( WINDOWS_SEPARATOR , UNIX_SEPARATOR ) ; } public static String separatorsToWindows ( final String path ) {
textIdx += wcs [ wcsIdx ] . length () ; anyChars = false ; MST[rv.CRCR6Mutator]MSP[N] } wcsIdx ++ ; } if ( wcsIdx == wcs . length && textIdx == fileName . length () ) { return true ; } } while ( backtrack . size () > 0 );
if ( array [ i ] == separator && array [ i - 1 ] == '.' && array [ i - 2 ] == '.' && MST[rv.AOR3Mutator]MSP[N] ( i == prefix + 2 || array [ i - 3 ] == separator ) ) {
if ( array [ i ] == separator && array [ i - 1 ] == '.' && array [ i - 2 ] == '.' && MST[rv.AOD1Mutator]MSP[N] ( i == prefix + 2 || array [ i - 3 ] == separator ) ) {
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND ) { return len + 1 ; MST[InlineConstantMutator]MSP[N] } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ; return Math . min ( posUnix , posWin ) + 1 ; }
if ( array [ j ] == separator ) { System . arraycopy ( array , i + 1 , array , j + 1 , size - i ) ; MST[rv.AOR2Mutator]MSP[N] size -= i - j ; i = j + 1 ; continue outer; } }
( i == prefix + 1 || array [ i - 2 ] == separator ) ) { if ( i == size - 1 ) { MST[rv.ROR1Mutator]MSP[N] lastIsDirectory = true ; }
for ( int i = 0 ; i < parts . length ; i ++ ) { if ( parts [ i ] . length () == 0 ) { return i == parts . length - 1 ; MST[NegateConditionalsMutator]MSP[N] }
static boolean isSystemWindows () { return SYSTEM_SEPARATOR == WINDOWS_SEPARATOR ; } private static boolean isSeparator ( final char ch ) { return ch == UNIX_SEPARATOR || ch == WINDOWS_SEPARATOR ; MST[NegateConditionalsMutator]MSP[N] } public static String normalize ( final String fileName ) {
for ( int i = prefix + 1 ; i < size ; i ++ ) { if ( array [ i ] == separator && array [ i - 1 ] == '.' && MST[rv.CRCR3Mutator]MSP[N]
public static String normalizeNoEndSeparator ( final String fileName ) { return doNormalize ( fileName , SYSTEM_SEPARATOR , false ) ; } public static String normalizeNoEndSeparator ( final String fileName , final boolean unixSeparator ) { final char separator = unixSeparator ? UNIX_SEPARATOR : WINDOWS_SEPARATOR ; MST[rv.CRCR1Mutator]MSP[S]
final int pos = Math . min ( posUnix , posWin ) + 1 ; final String hostnamePart = fileName . substring ( 2 , pos - 1 ) ; return isValidHostName ( hostnamePart ) ? pos : NOT_FOUND ; MST[rv.CRCR2Mutator]MSP[N] } else {
if ( size <= prefix ) { return new String ( array , 0 , size ) ; MST[rv.ABSMutator]MSP[N] } if ( lastIsDirectory && keepSeparator ) { return new String ( array , 0 , size ) ; }
static boolean isSystemWindows () { return SYSTEM_SEPARATOR == WINDOWS_SEPARATOR ; } private static boolean isSeparator ( final char ch ) { return ch == UNIX_SEPARATOR || ch == WINDOWS_SEPARATOR ; MST[rv.UOI2Mutator]MSP[S] } public static String normalize ( final String fileName ) {
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND ) { MST[rv.ROR1Mutator]MSP[N] return len + 1 ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ; return Math . min ( posUnix , posWin ) + 1 ; }
if ( size <= prefix ) { return new String ( array , 0 , size ) ; } if ( lastIsDirectory && keepSeparator ) { MST[rv.ROR3Mutator]MSP[N] return new String ( array , 0 , size ) ; }
if ( array [ i ] == separator && array [ i - 1 ] == '.' && array [ i - 2 ] == '.' && MST[rv.ABSMutator]MSP[N] ( i == prefix + 2 || array [ i - 3 ] == separator ) ) {
anyChars = false ; } else if ( wcs [ wcsIdx ] . equals ( lr_7 ) ) { MST[NegateConditionalsMutator]MSP[N] anyChars = true ; if ( wcsIdx == wcs . length - 1 ) { textIdx = fileName . length () ; } } else { if ( anyChars ) {
if ( index == NOT_FOUND ) { MST[rv.ROR3Mutator]MSP[N] return fileName ; } return fileName . substring ( 0 , index ) ; } public static boolean equals ( final String fileName1 , final String fileName2 ) { return equals ( fileName1 , fileName2 , false , IOCase . SENSITIVE ) ;
if ( ipSegment . length () > 1 && ipSegment . startsWith ( lr_8 ) ) { MST[NegateConditionalsMutator]MSP[S] return false ; } } return true ; } private static boolean isIPv6Address ( final String inet6Address ) { final boolean containsCompressedZeroes = inet6Address . contains ( lr_9 ) ;
if ( array [ i ] == separator && array [ i - 1 ] == separator ) { MST[rv.AOR1Mutator]MSP[N] System . arraycopy ( array , i , array , i - 1 , size - i ) ; size -- ; i -- ; } }
return isSeparator ( ch0 ) ? 1 : 0 ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } if ( ch0 == '~' ) { int posUnix = fileName . indexOf ( UNIX_SEPARATOR , 1 ) ; int posWin = fileName . indexOf ( WINDOWS_SEPARATOR , 1 ) ;
if ( octets . length > IPV6_MAX_HEX_GROUPS ) { return false ; MST[rv.CRCR1Mutator]MSP[S] } int validOctets = 0 ; int emptyOctets = 0 ; for ( int index = 0 ; index < octets . length ; index ++ ) { final String octet = octets [ index ] ;
if ( ch == '?' || ch == '*' ) { if ( buffer . length () != 0 ) { MST[rv.ROR5Mutator]MSP[N] list . add ( buffer . toString () ) ; buffer . setLength ( 0 ) ; } if ( ch == '?' ) {
return caseSensitivity . checkEquals ( fileName1 , fileName2 ) ; } public static boolean isExtension ( final String fileName , final String extension ) { if ( fileName == null ) { return false ; MST[BooleanTrueReturnValsMutator]MSP[S] } failIfNullBytePresent ( fileName ) ;
System . arraycopy ( array , i + 1 , array , prefix , size - i ) ; size -= i + 1 - prefix ; MST[rv.UOI3Mutator]MSP[N] i = prefix + 1 ; } } if ( size <= 0 ) { return EMPTY_STRING ; }
int size = fileName . length () ; if ( size == 0 ) { return fileName ; MST[EmptyObjectReturnValsMutator]MSP[S] } final int prefix = getPrefixLength ( fileName ) ; if ( prefix < 0 ) { return null ; }
if ( array [ i ] == separator && array [ i - 1 ] == '.' && array [ i - 2 ] == '.' && MST[NegateConditionalsMutator]MSP[N] ( i == prefix + 2 || array [ i - 3 ] == separator ) ) {
final int pos = Math . min ( posUnix , posWin ) + 1 ; MST[rv.AOD2Mutator]MSP[N] final String hostnamePart = fileName . substring ( 2 , pos - 1 ) ; return isValidHostName ( hostnamePart ) ? pos : NOT_FOUND ; } else {
textIdx = caseSensitivity . checkIndexOf ( fileName , textIdx , wcs [ wcsIdx ] ) ; if ( textIdx == NOT_FOUND ) { MST[rv.CRCR5Mutator]MSP[S] break; } final int repeat = caseSensitivity . checkIndexOf ( fileName , textIdx + 1 , wcs [ wcsIdx ] ) ;
if ( array [ j ] == separator ) { MST[rv.ROR2Mutator]MSP[N] System . arraycopy ( array , i + 1 , array , j + 1 , size - i ) ; size -= i - j ; i = j + 1 ; continue outer; } }
|| ( inet6Address . endsWith ( lr_10 ) && ! inet6Address . endsWith ( lr_9 ) ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return false ; } String [] octets = inet6Address . split ( lr_10 ) ; if ( containsCompressedZeroes ) {
final int pos = Math . min ( posUnix , posWin ) + 1 ; MST[rv.CRCR5Mutator]MSP[N] final String hostnamePart = fileName . substring ( 2 , pos - 1 ) ; return isValidHostName ( hostnamePart ) ? pos : NOT_FOUND ; } else {
final int lastWindowsPos = fileName . lastIndexOf ( WINDOWS_SEPARATOR ) ; return Math . max ( lastUnixPos , lastWindowsPos ) ; } public static int indexOfExtension ( final String fileName ) throws IllegalArgumentException { if ( fileName == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return NOT_FOUND ; }
for ( int i = 1 ; i <= 4 ; i ++ ) { final String ipSegment = m . group ( i ) ; final int iIpSegment = Integer . parseInt ( ipSegment ) ; if ( iIpSegment > IPV4_MAX_OCTET_VALUE ) { MST[rv.CRCR3Mutator]MSP[S] return false ; }
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND ) { MST[rv.CRCR5Mutator]MSP[N] return len + 1 ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ; return Math . min ( posUnix , posWin ) + 1 ; }
} else if ( isSeparator ( ch0 ) && isSeparator ( ch1 ) ) { int posUnix = fileName . indexOf ( UNIX_SEPARATOR , 2 ) ; int posWin = fileName . indexOf ( WINDOWS_SEPARATOR , 2 ) ; MST[rv.CRCR3Mutator]MSP[N]
if ( array [ j ] == separator ) { System . arraycopy ( array , i + 1 , array , j + 1 , size - i ) ; MST[rv.UOI4Mutator]MSP[N] size -= i - j ; i = j + 1 ; continue outer; } }
int size = fileName . length () ; if ( size == 0 ) { MST[rv.ROR1Mutator]MSP[N] return fileName ; } final int prefix = getPrefixLength ( fileName ) ; if ( prefix < 0 ) { return null ; }
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND ) { return len + 1 ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ; MST[rv.UOI3Mutator]MSP[N] return Math . min ( posUnix , posWin ) + 1 ; }
return equals ( fileName1 , fileName2 , true , IOCase . SENSITIVE ) ; } public static boolean equalsNormalizedOnSystem ( final String fileName1 , final String fileName2 ) { return equals ( fileName1 , fileName2 , true , IOCase . SYSTEM ) ; MST[ArgumentPropagationMutator]MSP[N] } public static boolean equals (
System . arraycopy ( array , i + 1 , array , prefix , size - i ) ; size -= i + 1 - prefix ; i = prefix + 1 ; MST[rv.AOD2Mutator]MSP[N] } } if ( size <= 0 ) { return EMPTY_STRING ; }
final char ch = basePath . charAt ( len - 1 ) ; if ( isSeparator ( ch ) ) { return normalize ( basePath + fullFileNameToAdd ) ; } return normalize ( basePath + '/' + fullFileNameToAdd ) ; MST[rv.CRCR2Mutator]MSP[N] }
if ( repeat >= 0 ) { backtrack . push ( new int [] { wcsIdx , repeat } ) ; } } else { if ( ! caseSensitivity . checkRegionMatches ( fileName , textIdx , wcs [ wcsIdx ] ) ) { MST[rv.UOI3Mutator]MSP[N] break; } }
if ( len == 0 ) { return 0 ; } char ch0 = fileName . charAt ( 0 ) ; if ( ch0 == ':' ) { return NOT_FOUND ; } if ( len == 1 ) { MST[rv.ROR5Mutator]MSP[N] if ( ch0 == '~' ) { return 2 ; }
public static String getExtension ( final String fileName ) throws IllegalArgumentException { if ( fileName == null ) { return null ; } final int index = indexOfExtension ( fileName ) ; if ( index == NOT_FOUND ) { MST[rv.UOI2Mutator]MSP[N] return EMPTY_STRING ; }
if ( extension == null || extension . isEmpty () ) { return indexOfExtension ( fileName ) == NOT_FOUND ; } final String fileExt = getExtension ( fileName ) ; return fileExt . equals ( extension ) ; MST[NonVoidMethodCallMutator]MSP[S] }
return equals ( fileName1 , fileName2 , true , IOCase . SENSITIVE ) ; MST[rv.CRCR4Mutator]MSP[N] } public static boolean equalsNormalizedOnSystem ( final String fileName1 , final String fileName2 ) { return equals ( fileName1 , fileName2 , true , IOCase . SYSTEM ) ; } public static boolean equals (
anyChars = false ; } else if ( wcs [ wcsIdx ] . equals ( lr_7 ) ) { anyChars = true ; MST[InlineConstantMutator]MSP[N] if ( wcsIdx == wcs . length - 1 ) { textIdx = fileName . length () ; } } else { if ( anyChars ) {
if ( array [ size - 1 ] != separator ) { array [ size ++ ] = separator ; lastIsDirectory = false ; } for ( int i = prefix + 1 ; i < size ; i ++ ) { MST[rv.AOR1Mutator]MSP[N]
if ( octet . length () == 0 ) { emptyOctets ++ ; if ( emptyOctets > 1 ) { return false ; } } else { emptyOctets = 0 ; if ( index == octets . length - 1 && octet . contains ( lr_12 ) ) { MST[rv.AOR3Mutator]MSP[S]
System . arraycopy ( array , i + 1 , array , prefix , size - i ) ; size -= i + 1 - prefix ; i = prefix + 1 ; MST[rv.CRCR5Mutator]MSP[N] } } if ( size <= 0 ) { return EMPTY_STRING ; }
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2 ) { MST[rv.UOI4Mutator]MSP[N] return NOT_FOUND ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ;
for ( int i = 1 ; i <= 4 ; i ++ ) { MST[IncrementsMutator]MSP[N] final String ipSegment = m . group ( i ) ; final int iIpSegment = Integer . parseInt ( ipSegment ) ; if ( iIpSegment > IPV4_MAX_OCTET_VALUE ) { return false ; }
if ( ch == '?' || ch == '*' ) { if ( buffer . length () != 0 ) { MST[NegateConditionalsMutator]MSP[N] list . add ( buffer . toString () ) ; buffer . setLength ( 0 ) ; } if ( ch == '?' ) {
public static String getExtension ( final String fileName ) throws IllegalArgumentException { if ( fileName == null ) { return null ; MST[ReturnValsMutator]MSP[S] } final int index = indexOfExtension ( fileName ) ; if ( index == NOT_FOUND ) { return EMPTY_STRING ; }
private static String doGetPath ( final String fileName , final int separatorAdd ) { if ( fileName == null ) { return null ; } final int prefix = getPrefixLength ( fileName ) ; if ( prefix < 0 ) { MST[rv.ROR3Mutator]MSP[N] return null ; }
public static String normalizeNoEndSeparator ( final String fileName ) { return doNormalize ( fileName , SYSTEM_SEPARATOR , false ) ; } public static String normalizeNoEndSeparator ( final String fileName , final boolean unixSeparator ) { final char separator = unixSeparator ? UNIX_SEPARATOR : WINDOWS_SEPARATOR ; MST[InlineConstantMutator]MSP[N]
if ( ! isIPv4Address ( octet ) ) { return false ; } validOctets += 2 ; MST[IncrementsMutator]MSP[N] continue; } if ( octet . length () > IPV6_MAX_HEX_DIGITS_PER_GROUP ) { return false ; } int octetInt = 0 ; try {
final char [] array = new char [ size + 2 ] ; MST[rv.CRCR2Mutator]MSP[N] fileName . getChars ( 0 , fileName . length () , array , 0 ) ; final char otherSeparator = separator == SYSTEM_SEPARATOR ? OTHER_SEPARATOR : SYSTEM_SEPARATOR ;
if ( octet . length () == 0 ) { emptyOctets ++ ; if ( emptyOctets > 1 ) { MST[InlineConstantMutator]MSP[N] return false ; } } else { emptyOctets = 0 ; if ( index == octets . length - 1 && octet . contains ( lr_12 ) ) {
if ( path == null || path . indexOf ( UNIX_SEPARATOR ) == NOT_FOUND ) { MST[rv.CRCR4Mutator]MSP[N] return path ; } return path . replace ( UNIX_SEPARATOR , WINDOWS_SEPARATOR ) ; } public static String separatorsToSystem ( final String path ) { if ( path == null ) {
private static String doGetPath ( final String fileName , final int separatorAdd ) { if ( fileName == null ) { return null ; } final int prefix = getPrefixLength ( fileName ) ; if ( prefix < 0 ) { MST[rv.UOI2Mutator]MSP[S] return null ; }
if ( len < 0 ) { return null ; } if ( len > fileName . length () ) { failIfNullBytePresent ( fileName + UNIX_SEPARATOR ) ; return fileName + UNIX_SEPARATOR ; } final String path = fileName . substring ( 0 , len ) ; MST[NonVoidMethodCallMutator]MSP[N]
if ( ! isIPv4Address ( octet ) ) { return false ; } validOctets += 2 ; continue; } if ( octet . length () > IPV6_MAX_HEX_DIGITS_PER_GROUP ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] return false ; } int octetInt = 0 ; try {
} else if ( isSeparator ( ch0 ) && isSeparator ( ch1 ) ) { MST[rv.UOI1Mutator]MSP[N] int posUnix = fileName . indexOf ( UNIX_SEPARATOR , 2 ) ; int posWin = fileName . indexOf ( WINDOWS_SEPARATOR , 2 ) ;
if ( len == 0 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return 0 ; } char ch0 = fileName . charAt ( 0 ) ; if ( ch0 == ':' ) { return NOT_FOUND ; } if ( len == 1 ) { if ( ch0 == '~' ) { return 2 ; }
final char [] array = new char [ size + 2 ] ; fileName . getChars ( 0 , fileName . length () , array , 0 ) ; MST[rv.CRCR3Mutator]MSP[N] final char otherSeparator = separator == SYSTEM_SEPARATOR ? OTHER_SEPARATOR : SYSTEM_SEPARATOR ;
return Math . max ( offset1 , offset2 ) + 1 ; } public static String removeExtension ( final String fileName ) { if ( fileName == null ) { MST[NegateConditionalsMutator]MSP[N] return null ; } failIfNullBytePresent ( fileName ) ; final int index = indexOfExtension ( fileName ) ;
if ( len == 0 ) { return 0 ; } char ch0 = fileName . charAt ( 0 ) ; if ( ch0 == ':' ) { MST[rv.CRCR6Mutator]MSP[N] return NOT_FOUND ; } if ( len == 1 ) { if ( ch0 == '~' ) { return 2 ; }
if ( ! REG_NAME_PART_PATTERN . matcher ( parts [ i ] ) . matches () ) { return false ; MST[ReturnValsMutator]MSP[N] } } return true ; }
final int lastWindowsPos = fileName . lastIndexOf ( WINDOWS_SEPARATOR ) ; return Math . max ( lastUnixPos , lastWindowsPos ) ; MST[rv.UOI4Mutator]MSP[N] } public static int indexOfExtension ( final String fileName ) throws IllegalArgumentException { if ( fileName == null ) { return NOT_FOUND ; }
if ( ! isIPv4Address ( octet ) ) { return false ; } validOctets += 2 ; continue; } if ( octet . length () > IPV6_MAX_HEX_DIGITS_PER_GROUP ) { MST[rv.ROR4Mutator]MSP[N] return false ; } int octetInt = 0 ; try {
final int index = indexOfLastSeparator ( fileName ) ; if ( index < 0 ) { MST[rv.ROR4Mutator]MSP[N] return fileName . substring ( 0 , prefix ) ; } int end = index + ( includeSeparator ? 1 : 0 ) ; if ( end == 0 ) { end ++ ;
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2 ) { return NOT_FOUND ; MST[rv.CRCR5Mutator]MSP[N] } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ;
if ( index == NOT_FOUND ) { return fileName ; } return fileName . substring ( 0 , index ) ; MST[experimental.NakedReceiverMutator]MSP[N] } public static boolean equals ( final String fileName1 , final String fileName2 ) { return equals ( fileName1 , fileName2 , false , IOCase . SENSITIVE ) ;
System . arraycopy ( array , i + 1 , array , prefix , size - i ) ; MST[rv.UOI4Mutator]MSP[N] size -= i + 1 - prefix ; i = prefix + 1 ; } } if ( size <= 0 ) { return EMPTY_STRING ; }
if ( i == prefix + 2 ) { return null ; } if ( i == size - 1 ) { MST[rv.UOI1Mutator]MSP[N] lastIsDirectory = true ; } int j ; for ( j = i - 4 ; j >= prefix ; j -- ) {
if ( octet . length () == 0 ) { emptyOctets ++ ; if ( emptyOctets > 1 ) { return false ; } } else { emptyOctets = 0 ; if ( index == octets . length - 1 && octet . contains ( lr_12 ) ) { MST[rv.ROR5Mutator]MSP[S]
textIdx = array [ 1 ] ; anyChars = true ; } while ( wcsIdx < wcs . length ) { if ( wcs [ wcsIdx ] . equals ( lr_6 ) ) { MST[NonVoidMethodCallMutator]MSP[N] textIdx ++ ; if ( textIdx > fileName . length () ) { break; }
anyChars = false ; } else if ( wcs [ wcsIdx ] . equals ( lr_7 ) ) { anyChars = true ; if ( wcsIdx == wcs . length - 1 ) { MST[rv.CRCR6Mutator]MSP[N] textIdx = fileName . length () ; } } else { if ( anyChars ) {
octetInt = Integer . parseInt ( octet , BASE_16 ) ; } catch ( final NumberFormatException e ) { return false ; } if ( octetInt < 0 || octetInt > MAX_UNSIGNED_SHORT ) { MST[rv.ROR4Mutator]MSP[N] return false ; } } validOctets ++ ; }
final char [] array = new char [ size + 2 ] ; fileName . getChars ( 0 , fileName . length () , array , 0 ) ; final char otherSeparator = separator == SYSTEM_SEPARATOR ? OTHER_SEPARATOR : SYSTEM_SEPARATOR ; MST[rv.ROR3Mutator]MSP[S]
for ( int i = 0 ; i < parts . length ; i ++ ) { if ( parts [ i ] . length () == 0 ) { return i == parts . length - 1 ; MST[rv.CRCR2Mutator]MSP[N] }
return isSeparator ( ch0 ) ? 1 : 0 ; MST[rv.CRCR5Mutator]MSP[N] } if ( ch0 == '~' ) { int posUnix = fileName . indexOf ( UNIX_SEPARATOR , 1 ) ; int posWin = fileName . indexOf ( WINDOWS_SEPARATOR , 1 ) ;
if ( array [ i ] == separator && array [ i - 1 ] == '.' && array [ i - 2 ] == '.' && MST[rv.UOI3Mutator]MSP[N] ( i == prefix + 2 || array [ i - 3 ] == separator ) ) {
if ( ch == '?' || ch == '*' ) { MST[rv.ROR3Mutator]MSP[N] if ( buffer . length () != 0 ) { list . add ( buffer . toString () ) ; buffer . setLength ( 0 ) ; } if ( ch == '?' ) {
if ( len == 2 || isSeparator ( fileName . charAt ( 2 ) ) == false ) { return 2 ; } return 3 ; } else if ( ch0 == UNIX_SEPARATOR ) { return 1 ; } return NOT_FOUND ; MST[rv.CRCR6Mutator]MSP[N]
return indexOfExtension ( fileName ) == NOT_FOUND ; } final String fileExt = getExtension ( fileName ) ; for ( final String extension : extensions ) { if ( fileExt . equals ( extension ) ) { MST[rv.ROR5Mutator]MSP[N] return true ; } } return false ; }
return indexOfExtension ( fileName ) == NOT_FOUND ; MST[rv.CRCR1Mutator]MSP[S] } final String fileExt = getExtension ( fileName ) ; for ( final String extension : extensions ) { if ( fileExt . equals ( extension ) ) { return true ; } } return false ; }
if ( array [ i ] == separator && array [ i - 1 ] == '.' && array [ i - 2 ] == '.' && MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] ( i == prefix + 2 || array [ i - 3 ] == separator ) ) {
} else if ( isSeparator ( ch0 ) && isSeparator ( ch1 ) ) { int posUnix = fileName . indexOf ( UNIX_SEPARATOR , 2 ) ; MST[rv.CRCR1Mutator]MSP[N] int posWin = fileName . indexOf ( WINDOWS_SEPARATOR , 2 ) ;
if ( ! REG_NAME_PART_PATTERN . matcher ( parts [ i ] ) . matches () ) { return false ; } } return true ; MST[rv.CRCR3Mutator]MSP[N] }
} else if ( inet6Address . startsWith ( lr_9 ) && ! octetList . isEmpty () ) { octetList . remove ( 0 ) ; MST[rv.CRCR5Mutator]MSP[N] } octets = octetList . toArray ( new String [ octetList . size () ] ) ; }
if ( array [ i ] == separator && array [ i - 1 ] == '.' && array [ i - 2 ] == '.' && MST[rv.ROR1Mutator]MSP[N] ( i == prefix + 2 || array [ i - 3 ] == separator ) ) {
return false ; } static String [] splitOnTokens ( final String text ) { if ( text . indexOf ( '?' ) == NOT_FOUND && text . indexOf ( '*' ) == NOT_FOUND ) { MST[NegateConditionalsMutator]MSP[N] return new String [] { text } ; }
} else if ( inet6Address . startsWith ( lr_9 ) && ! octetList . isEmpty () ) { MST[NonVoidMethodCallMutator]MSP[N] octetList . remove ( 0 ) ; } octets = octetList . toArray ( new String [ octetList . size () ] ) ; }
if ( i == prefix + 2 ) { MST[rv.UOI3Mutator]MSP[N] return null ; } if ( i == size - 1 ) { lastIsDirectory = true ; } int j ; for ( j = i - 4 ; j >= prefix ; j -- ) {
if ( len < 0 ) { return null ; } if ( len > fileName . length () ) { MST[rv.UOI3Mutator]MSP[N] failIfNullBytePresent ( fileName + UNIX_SEPARATOR ) ; return fileName + UNIX_SEPARATOR ; } final String path = fileName . substring ( 0 , len ) ;
final char [] array = text . toCharArray () ; MST[NonVoidMethodCallMutator]MSP[N] final ArrayList < String > list = new ArrayList <> () ; final StringBuilder buffer = new StringBuilder () ; char prevChar = 0 ; for ( final char ch : array ) {
if ( array [ i ] == separator && array [ i - 1 ] == '.' && array [ i - 2 ] == '.' && MST[rv.ABSMutator]MSP[N] ( i == prefix + 2 || array [ i - 3 ] == separator ) ) {
if ( array [ i ] == separator && array [ i - 1 ] == '.' && array [ i - 2 ] == '.' && MST[rv.UOI1Mutator]MSP[N] ( i == prefix + 2 || array [ i - 3 ] == separator ) ) {
} return fileName . substring ( 0 , end ) ; } public static String getName ( final String fileName ) { if ( fileName == null ) { return null ; } failIfNullBytePresent ( fileName ) ; final int index = indexOfLastSeparator ( fileName ) ; MST[NonVoidMethodCallMutator]MSP[N]
if ( octet . length () == 0 ) { emptyOctets ++ ; if ( emptyOctets > 1 ) { MST[rv.ROR5Mutator]MSP[N] return false ; } } else { emptyOctets = 0 ; if ( index == octets . length - 1 && octet . contains ( lr_12 ) ) {
return isSeparator ( ch0 ) ? 1 : 0 ; } } public static int indexOfLastSeparator ( final String fileName ) { if ( fileName == null ) { return NOT_FOUND ; MST[PrimitiveReturnsMutator]MSP[N] } final int lastUnixPos = fileName . lastIndexOf ( UNIX_SEPARATOR ) ;
return doNormalize ( fileName , separator , false ) ; MST[rv.ABSMutator]MSP[N] } private static String doNormalize ( final String fileName , final char separator , final boolean keepSeparator ) { if ( fileName == null ) { return null ; } failIfNullBytePresent ( fileName ) ;
private static boolean isIPv4Address ( final String name ) { final Matcher m = IPV4_PATTERN . matcher ( name ) ; if ( ! m . matches () || m . groupCount () != 4 ) { MST[rv.ROR4Mutator]MSP[S] return false ; }
static boolean isSystemWindows () { return SYSTEM_SEPARATOR == WINDOWS_SEPARATOR ; MST[rv.CRCR1Mutator]MSP[N] } private static boolean isSeparator ( final char ch ) { return ch == UNIX_SEPARATOR || ch == WINDOWS_SEPARATOR ; } public static String normalize ( final String fileName ) {
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2 ) { MST[rv.ROR2Mutator]MSP[N] return NOT_FOUND ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ;
octetInt = Integer . parseInt ( octet , BASE_16 ) ; } catch ( final NumberFormatException e ) { return false ; } if ( octetInt < 0 || octetInt > MAX_UNSIGNED_SHORT ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] return false ; } } validOctets ++ ; }
if ( len == 2 || isSeparator ( fileName . charAt ( 2 ) ) == false ) { MST[rv.ROR3Mutator]MSP[N] return 2 ; } return 3 ; } else if ( ch0 == UNIX_SEPARATOR ) { return 1 ; } return NOT_FOUND ;
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2 ) { MST[rv.UOI2Mutator]MSP[N] return NOT_FOUND ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ;
return fileName . substring ( index + 1 ) ; } private static void failIfNullBytePresent ( final String path ) { final int len = path . length () ; for ( int i = 0 ; i < len ; i ++ ) { MST[rv.ROR5Mutator]MSP[N]
System . arraycopy ( array , i + 1 , array , prefix , size - i ) ; MST[rv.AOD1Mutator]MSP[N] size -= i + 1 - prefix ; i = prefix + 1 ; } } if ( size <= 0 ) { return EMPTY_STRING ; }
final int index = indexOfLastSeparator ( fileName ) ; final int endIndex = index + separatorAdd ; if ( prefix >= fileName . length () || index < 0 || prefix >= endIndex ) { MST[rv.ROR2Mutator]MSP[N] return EMPTY_STRING ; }
|| ( inet6Address . endsWith ( lr_10 ) && ! inet6Address . endsWith ( lr_9 ) ) ) { return false ; } String [] octets = inet6Address . split ( lr_10 ) ; if ( containsCompressedZeroes ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
for ( int i = prefix + 1 ; i < size ; i ++ ) { if ( array [ i ] == separator && array [ i - 1 ] == '.' && MST[rv.ROR2Mutator]MSP[N]
final int index = indexOfLastSeparator ( fileName ) ; if ( index < 0 ) { return fileName . substring ( 0 , prefix ) ; } int end = index + ( includeSeparator ? 1 : 0 ) ; MST[rv.CRCR2Mutator]MSP[S] if ( end == 0 ) { end ++ ;
static boolean isSystemWindows () { return SYSTEM_SEPARATOR == WINDOWS_SEPARATOR ; } private static boolean isSeparator ( final char ch ) { return ch == UNIX_SEPARATOR || ch == WINDOWS_SEPARATOR ; MST[rv.CRCR6Mutator]MSP[N] } public static String normalize ( final String fileName ) {
return new String ( array , 0 , size - 1 ) ; MST[rv.UOI1Mutator]MSP[S] } public static String concat ( final String basePath , final String fullFileNameToAdd ) { final int prefix = getPrefixLength ( fullFileNameToAdd ) ; if ( prefix < 0 ) { return null ; }
if ( array [ j ] == separator ) { System . arraycopy ( array , i + 1 , array , j + 1 , size - i ) ; MST[rv.AOR1Mutator]MSP[N] size -= i - j ; i = j + 1 ; continue outer; } }
for ( int i = 0 ; i < array . length ; i ++ ) { if ( array [ i ] == otherSeparator ) { array [ i ] = separator ; } } boolean lastIsDirectory = true ; MST[rv.CRCR4Mutator]MSP[S]
return isSeparator ( ch0 ) ? 1 : 0 ; } if ( ch0 == '~' ) { int posUnix = fileName . indexOf ( UNIX_SEPARATOR , 1 ) ; MST[rv.CRCR5Mutator]MSP[N] int posWin = fileName . indexOf ( WINDOWS_SEPARATOR , 1 ) ;
return doNormalize ( fileName , SYSTEM_SEPARATOR , true ) ; } public static String normalize ( final String fileName , final boolean unixSeparator ) { final char separator = unixSeparator ? UNIX_SEPARATOR : WINDOWS_SEPARATOR ; MST[rv.CRCR3Mutator]MSP[S] return doNormalize ( fileName , separator , true ) ; }
if ( array [ size - 1 ] != separator ) { MST[rv.CRCR6Mutator]MSP[N] array [ size ++ ] = separator ; lastIsDirectory = false ; } for ( int i = prefix + 1 ; i < size ; i ++ ) {
if ( len == 0 ) { return 0 ; } char ch0 = fileName . charAt ( 0 ) ; if ( ch0 == ':' ) { return NOT_FOUND ; } if ( len == 1 ) { if ( ch0 == '~' ) { MST[rv.CRCR1Mutator]MSP[N] return 2 ; }
anyChars = false ; } else if ( wcs [ wcsIdx ] . equals ( lr_7 ) ) { anyChars = true ; if ( wcsIdx == wcs . length - 1 ) { MST[rv.ROR2Mutator]MSP[N] textIdx = fileName . length () ; } } else { if ( anyChars ) {
return isSeparator ( ch0 ) ? 1 : 0 ; } if ( ch0 == '~' ) { MST[rv.UOI2Mutator]MSP[N] int posUnix = fileName . indexOf ( UNIX_SEPARATOR , 1 ) ; int posWin = fileName . indexOf ( WINDOWS_SEPARATOR , 1 ) ;
anyChars = false ; } else if ( wcs [ wcsIdx ] . equals ( lr_7 ) ) { anyChars = true ; if ( wcsIdx == wcs . length - 1 ) { textIdx = fileName . length () ; } } else { if ( anyChars ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
} else if ( inet6Address . startsWith ( lr_9 ) && ! octetList . isEmpty () ) { MST[NegateConditionalsMutator]MSP[N] octetList . remove ( 0 ) ; } octets = octetList . toArray ( new String [ octetList . size () ] ) ; }
list . add ( buffer . toString () ) ; } return list . toArray ( new String [ list . size () ] ) ; } private static boolean isValidHostName ( final String name ) { return isIPv6Address ( name ) || isRFC3986HostName ( name ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] }
final List < String > octetList = new ArrayList <> ( Arrays . asList ( octets ) ) ; if ( inet6Address . endsWith ( lr_9 ) ) { MST[NonVoidMethodCallMutator]MSP[N] octetList . add ( lr_11 ) ;
for ( int i = 1 ; i <= 4 ; i ++ ) { final String ipSegment = m . group ( i ) ; MST[rv.UOI4Mutator]MSP[N] final int iIpSegment = Integer . parseInt ( ipSegment ) ; if ( iIpSegment > IPV4_MAX_OCTET_VALUE ) { return false ; }
return doNormalize ( fileName , separator , false ) ; MST[ReturnValsMutator]MSP[N] } private static String doNormalize ( final String fileName , final char separator , final boolean keepSeparator ) { if ( fileName == null ) { return null ; } failIfNullBytePresent ( fileName ) ;
if ( ch == '?' || ch == '*' ) { if ( buffer . length () != 0 ) { list . add ( buffer . toString () ) ; buffer . setLength ( 0 ) ; } if ( ch == '?' ) { MST[rv.CRCR4Mutator]MSP[N]
if ( array [ i ] == separator && array [ i - 1 ] == '.' && array [ i - 2 ] == '.' && MST[rv.ROR5Mutator]MSP[N] ( i == prefix + 2 || array [ i - 3 ] == separator ) ) {
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND ) { return len + 1 ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ; return Math . min ( posUnix , posWin ) + 1 ; MST[rv.AOR1Mutator]MSP[N] }
return caseSensitivity . checkEquals ( fileName1 , fileName2 ) ; } public static boolean isExtension ( final String fileName , final String extension ) { if ( fileName == null ) { return false ; MST[rv.CRCR6Mutator]MSP[S] } failIfNullBytePresent ( fileName ) ;
private static String doGetPath ( final String fileName , final int separatorAdd ) { if ( fileName == null ) { return null ; MST[EmptyObjectReturnValsMutator]MSP[N] } final int prefix = getPrefixLength ( fileName ) ; if ( prefix < 0 ) { return null ; }
for ( int i = 1 ; i <= 4 ; i ++ ) { MST[rv.UOI2Mutator]MSP[N] final String ipSegment = m . group ( i ) ; final int iIpSegment = Integer . parseInt ( ipSegment ) ; if ( iIpSegment > IPV4_MAX_OCTET_VALUE ) { return false ; }
final int index = indexOfLastSeparator ( fileName ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( index < 0 ) { return fileName . substring ( 0 , prefix ) ; } int end = index + ( includeSeparator ? 1 : 0 ) ; if ( end == 0 ) { end ++ ;
if ( validOctets > IPV6_MAX_HEX_GROUPS || ( validOctets < IPV6_MAX_HEX_GROUPS && ! containsCompressedZeroes ) ) { return false ; } return true ; MST[ReturnValsMutator]MSP[N] } private static boolean isRFC3986HostName ( final String name ) { final String [] parts = name . split ( lr_13 , - 1 ) ;
return false ; } static String [] splitOnTokens ( final String text ) { if ( text . indexOf ( '?' ) == NOT_FOUND && text . indexOf ( '*' ) == NOT_FOUND ) { MST[rv.CRCR1Mutator]MSP[N] return new String [] { text } ; }
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2 ) { return NOT_FOUND ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; MST[rv.ROR2Mutator]MSP[N] posWin = posWin == NOT_FOUND ? posUnix : posWin ;
for ( int i = prefix + 1 ; i < size ; i ++ ) { if ( array [ i ] == separator && array [ i - 1 ] == '.' && MST[rv.CRCR2Mutator]MSP[N]
return indexOfExtension ( fileName ) == NOT_FOUND ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] } final String fileExt = getExtension ( fileName ) ; for ( final String extension : extensions ) { if ( fileExt . equals ( extension ) ) { return true ; } } return false ; }
static boolean isSystemWindows () { return SYSTEM_SEPARATOR == WINDOWS_SEPARATOR ; } private static boolean isSeparator ( final char ch ) { return ch == UNIX_SEPARATOR || ch == WINDOWS_SEPARATOR ; MST[InlineConstantMutator]MSP[N] } public static String normalize ( final String fileName ) {
if ( path == null || path . indexOf ( WINDOWS_SEPARATOR ) == NOT_FOUND ) { return path ; } return path . replace ( WINDOWS_SEPARATOR , UNIX_SEPARATOR ) ; MST[rv.CRCR1Mutator]MSP[N] } public static String separatorsToWindows ( final String path ) {
final char ch = basePath . charAt ( len - 1 ) ; if ( isSeparator ( ch ) ) { return normalize ( basePath + fullFileNameToAdd ) ; } return normalize ( basePath + '/' + fullFileNameToAdd ) ; MST[NonVoidMethodCallMutator]MSP[N] }
int wcsIdx = 0 ; final Stack < int [] > backtrack = new Stack <> () ; do { if ( backtrack . size () > 0 ) { MST[rv.ROR4Mutator]MSP[N] final int [] array = backtrack . pop () ; wcsIdx = array [ 0 ] ;
return isSeparator ( ch0 ) ? 1 : 0 ; MST[rv.ROR4Mutator]MSP[N] } } public static int indexOfLastSeparator ( final String fileName ) { if ( fileName == null ) { return NOT_FOUND ; } final int lastUnixPos = fileName . lastIndexOf ( UNIX_SEPARATOR ) ;
return new String ( array , 0 , size - 1 ) ; MST[rv.CRCR5Mutator]MSP[N] } public static String concat ( final String basePath , final String fullFileNameToAdd ) { final int prefix = getPrefixLength ( fullFileNameToAdd ) ; if ( prefix < 0 ) { return null ; }
if ( repeat >= 0 ) { backtrack . push ( new int [] { wcsIdx , repeat } ) ; MST[rv.CRCR4Mutator]MSP[S] } } else { if ( ! caseSensitivity . checkRegionMatches ( fileName , textIdx , wcs [ wcsIdx ] ) ) { break; } }
if ( validOctets > IPV6_MAX_HEX_GROUPS || ( validOctets < IPV6_MAX_HEX_GROUPS && ! containsCompressedZeroes ) ) { return false ; } return true ; MST[rv.CRCR5Mutator]MSP[N] } private static boolean isRFC3986HostName ( final String name ) { final String [] parts = name . split ( lr_13 , - 1 ) ;
failIfNullBytePresent ( path ) ; return path ; } public static String getPath ( final String fileName ) { return doGetPath ( fileName , 1 ) ; } public static String getPathNoEndSeparator ( final String fileName ) { return doGetPath ( fileName , 0 ) ; MST[NonVoidMethodCallMutator]MSP[N] }
final int index = indexOfLastSeparator ( fileName ) ; final int endIndex = index + separatorAdd ; if ( prefix >= fileName . length () || index < 0 || prefix >= endIndex ) { return EMPTY_STRING ; MST[ReturnValsMutator]MSP[N] }
textIdx = caseSensitivity . checkIndexOf ( fileName , textIdx , wcs [ wcsIdx ] ) ; if ( textIdx == NOT_FOUND ) { MST[rv.ROR1Mutator]MSP[N] break; } final int repeat = caseSensitivity . checkIndexOf ( fileName , textIdx + 1 , wcs [ wcsIdx ] ) ;
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND ) { return len + 1 ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ; MST[rv.CRCR2Mutator]MSP[N] return Math . min ( posUnix , posWin ) + 1 ; }
return indexOfExtension ( fileName ) == NOT_FOUND ; MST[rv.ROR3Mutator]MSP[N] } final String fileExt = getExtension ( fileName ) ; for ( final String extension : extensions ) { if ( fileExt . equals ( extension ) ) { return true ; } } return false ; }
if ( octets . length > IPV6_MAX_HEX_GROUPS ) { return false ; } int validOctets = 0 ; int emptyOctets = 0 ; MST[rv.CRCR6Mutator]MSP[N] for ( int index = 0 ; index < octets . length ; index ++ ) { final String octet = octets [ index ] ;
if ( array [ i ] == separator && array [ i - 1 ] == '.' && array [ i - 2 ] == '.' && MST[InlineConstantMutator]MSP[N] ( i == prefix + 2 || array [ i - 3 ] == separator ) ) {
final char ch1 = fileName . charAt ( 1 ) ; if ( ch1 == ':' ) { ch0 = Character . toUpperCase ( ch0 ) ; if ( ch0 >= 'A' && ch0 <= 'Z' ) { MST[rv.ROR5Mutator]MSP[N]
octetInt = Integer . parseInt ( octet , BASE_16 ) ; } catch ( final NumberFormatException e ) { return false ; } if ( octetInt < 0 || octetInt > MAX_UNSIGNED_SHORT ) { MST[rv.UOI4Mutator]MSP[N] return false ; } } validOctets ++ ; }
textIdx = array [ 1 ] ; anyChars = true ; } while ( wcsIdx < wcs . length ) { if ( wcs [ wcsIdx ] . equals ( lr_6 ) ) { MST[rv.ROR5Mutator]MSP[N] textIdx ++ ; if ( textIdx > fileName . length () ) { break; }
textIdx += wcs [ wcsIdx ] . length () ; anyChars = false ; } wcsIdx ++ ; } if ( wcsIdx == wcs . length && textIdx == fileName . length () ) { MST[rv.UOI3Mutator]MSP[N] return true ; } } while ( backtrack . size () > 0 );
return doNormalize ( fileName , SYSTEM_SEPARATOR , true ) ; } public static String normalize ( final String fileName , final boolean unixSeparator ) { final char separator = unixSeparator ? UNIX_SEPARATOR : WINDOWS_SEPARATOR ; MST[rv.CRCR4Mutator]MSP[N] return doNormalize ( fileName , separator , true ) ; }
final char ch = basePath . charAt ( len - 1 ) ; if ( isSeparator ( ch ) ) { return normalize ( basePath + fullFileNameToAdd ) ; } return normalize ( basePath + '/' + fullFileNameToAdd ) ; MST[EmptyObjectReturnValsMutator]MSP[N] }
final int lastSeparator = indexOfLastSeparator ( fileName ) ; return lastSeparator > extensionPos ? NOT_FOUND : extensionPos ; MST[rv.UOI2Mutator]MSP[N] } public static String getPrefix ( final String fileName ) { if ( fileName == null ) { return null ; } final int len = getPrefixLength ( fileName ) ;
if ( array [ i ] == separator && array [ i - 1 ] == separator ) { MST[rv.UOI1Mutator]MSP[N] System . arraycopy ( array , i , array , i - 1 , size - i ) ; size -- ; i -- ; } }
textIdx = array [ 1 ] ; anyChars = true ; } while ( wcsIdx < wcs . length ) { if ( wcs [ wcsIdx ] . equals ( lr_6 ) ) { MST[rv.UOI3Mutator]MSP[N] textIdx ++ ; if ( textIdx > fileName . length () ) { break; }
} else if ( inet6Address . startsWith ( lr_9 ) && ! octetList . isEmpty () ) { octetList . remove ( 0 ) ; MST[InlineConstantMutator]MSP[N] } octets = octetList . toArray ( new String [ octetList . size () ] ) ; }
for ( int i = 0 ; i < parts . length ; i ++ ) { if ( parts [ i ] . length () == 0 ) { MST[rv.UOI4Mutator]MSP[N] return i == parts . length - 1 ; }
for ( int i = 1 ; i <= 4 ; i ++ ) { final String ipSegment = m . group ( i ) ; final int iIpSegment = Integer . parseInt ( ipSegment ) ; if ( iIpSegment > IPV4_MAX_OCTET_VALUE ) { return false ; MST[rv.CRCR5Mutator]MSP[N] }
if ( containsCompressedZeroes && ( inet6Address . indexOf ( lr_9 ) != inet6Address . lastIndexOf ( lr_9 ) ) ) { MST[NonVoidMethodCallMutator]MSP[S] return false ; } if ( ( inet6Address . startsWith ( lr_10 ) && ! inet6Address . startsWith ( lr_9 ) )
if ( ch == '?' || ch == '*' ) { MST[rv.UOI3Mutator]MSP[N] if ( buffer . length () != 0 ) { list . add ( buffer . toString () ) ; buffer . setLength ( 0 ) ; } if ( ch == '?' ) {
final int index = indexOfLastSeparator ( fileName ) ; if ( index < 0 ) { return fileName . substring ( 0 , prefix ) ; } int end = index + ( includeSeparator ? 1 : 0 ) ; if ( end == 0 ) { MST[rv.ROR3Mutator]MSP[N] end ++ ;
final char ch = basePath . charAt ( len - 1 ) ; if ( isSeparator ( ch ) ) { return normalize ( basePath + fullFileNameToAdd ) ; MST[NonVoidMethodCallMutator]MSP[N] } return normalize ( basePath + '/' + fullFileNameToAdd ) ; }
list . add ( lr_6 ) ; } else if ( prevChar != '*' ) { list . add ( lr_7 ) ; } } else { buffer . append ( ch ) ; } prevChar = ch ; } if ( buffer . length () != 0 ) { MST[NegateConditionalsMutator]MSP[N]
if ( octets . length > IPV6_MAX_HEX_GROUPS ) { return false ; } int validOctets = 0 ; int emptyOctets = 0 ; for ( int index = 0 ; index < octets . length ; index ++ ) { final String octet = octets [ index ] ; MST[rv.ABSMutator]MSP[N]
if ( array [ i ] == separator && array [ i - 1 ] == '.' && array [ i - 2 ] == '.' && MST[rv.CRCR6Mutator]MSP[N] ( i == prefix + 2 || array [ i - 3 ] == separator ) ) {
System . arraycopy ( array , i + 1 , array , i - 1 , size - i ) ; MST[rv.UOI3Mutator]MSP[N] size -= 2 ; i -- ; } } outer: for ( int i = prefix + 2 ; i < size ; i ++ ) {
return indexOfExtension ( fileName ) == NOT_FOUND ; } final String fileExt = getExtension ( fileName ) ; for ( final String extension : extensions ) { if ( fileExt . equals ( extension ) ) { return true ; MST[rv.CRCR5Mutator]MSP[N] } } return false ; }
if ( len == 0 ) { return 0 ; } char ch0 = fileName . charAt ( 0 ) ; if ( ch0 == ':' ) { return NOT_FOUND ; MST[rv.CRCR6Mutator]MSP[N] } if ( len == 1 ) { if ( ch0 == '~' ) { return 2 ; }
for ( int i = 1 ; i <= 4 ; i ++ ) { final String ipSegment = m . group ( i ) ; final int iIpSegment = Integer . parseInt ( ipSegment ) ; if ( iIpSegment > IPV4_MAX_OCTET_VALUE ) { return false ; MST[ReturnValsMutator]MSP[N] }
if ( i == prefix + 2 ) { return null ; } if ( i == size - 1 ) { lastIsDirectory = true ; } int j ; for ( j = i - 4 ; j >= prefix ; j -- ) { MST[rv.CRCR1Mutator]MSP[N]
public static String getFullPathNoEndSeparator ( final String fileName ) { return doGetFullPath ( fileName , false ) ; } private static String doGetFullPath ( final String fileName , final boolean includeSeparator ) { if ( fileName == null ) { MST[NegateConditionalsMutator]MSP[N] return null ; }
final int index = indexOfLastSeparator ( fileName ) ; if ( index < 0 ) { return fileName . substring ( 0 , prefix ) ; MST[rv.UOI1Mutator]MSP[N] } int end = index + ( includeSeparator ? 1 : 0 ) ; if ( end == 0 ) { end ++ ;
System . arraycopy ( array , i + 1 , array , prefix , size - i ) ; MST[rv.UOI4Mutator]MSP[N] size -= i + 1 - prefix ; i = prefix + 1 ; } } if ( size <= 0 ) { return EMPTY_STRING ; }
if ( repeat >= 0 ) { MST[rv.UOI1Mutator]MSP[N] backtrack . push ( new int [] { wcsIdx , repeat } ) ; } } else { if ( ! caseSensitivity . checkRegionMatches ( fileName , textIdx , wcs [ wcsIdx ] ) ) { break; } }
System . arraycopy ( array , i + 1 , array , prefix , size - i ) ; MST[rv.UOI2Mutator]MSP[N] size -= i + 1 - prefix ; i = prefix + 1 ; } } if ( size <= 0 ) { return EMPTY_STRING ; }
if ( ch == '?' || ch == '*' ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] if ( buffer . length () != 0 ) { list . add ( buffer . toString () ) ; buffer . setLength ( 0 ) ; } if ( ch == '?' ) {
if ( ! isIPv4Address ( octet ) ) { MST[rv.ROR5Mutator]MSP[S] return false ; } validOctets += 2 ; continue; } if ( octet . length () > IPV6_MAX_HEX_DIGITS_PER_GROUP ) { return false ; } int octetInt = 0 ; try {
textIdx += wcs [ wcsIdx ] . length () ; MST[rv.UOI3Mutator]MSP[N] anyChars = false ; } wcsIdx ++ ; } if ( wcsIdx == wcs . length && textIdx == fileName . length () ) { return true ; } } while ( backtrack . size () > 0 );
if ( i == prefix + 2 ) { return null ; } if ( i == size - 1 ) { MST[rv.ABSMutator]MSP[S] lastIsDirectory = true ; } int j ; for ( j = i - 4 ; j >= prefix ; j -- ) {
return indexOfExtension ( fileName ) == NOT_FOUND ; } final String fileExt = getExtension ( fileName ) ; for ( final String extension : extensions ) { if ( fileExt . equals ( extension ) ) { return true ; MST[ReturnValsMutator]MSP[N] } } return false ; }
final int index = indexOfLastSeparator ( fileName ) ; final int endIndex = index + separatorAdd ; if ( prefix >= fileName . length () || index < 0 || prefix >= endIndex ) { MST[rv.ROR1Mutator]MSP[N] return EMPTY_STRING ; }
if ( ch == '?' || ch == '*' ) { if ( buffer . length () != 0 ) { list . add ( buffer . toString () ) ; MST[NonVoidMethodCallMutator]MSP[N] buffer . setLength ( 0 ) ; } if ( ch == '?' ) {
final char ch1 = fileName . charAt ( 1 ) ; if ( ch1 == ':' ) { ch0 = Character . toUpperCase ( ch0 ) ; if ( ch0 >= 'A' && ch0 <= 'Z' ) { MST[rv.ROR4Mutator]MSP[N]
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND ) { return len + 1 ; MST[rv.AOR2Mutator]MSP[N] } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ; return Math . min ( posUnix , posWin ) + 1 ; }
if ( array [ size - 1 ] != separator ) { array [ size ++ ] = separator ; lastIsDirectory = false ; } for ( int i = prefix + 1 ; i < size ; i ++ ) { MST[rv.UOI1Mutator]MSP[N]
final char ch = basePath . charAt ( len - 1 ) ; if ( isSeparator ( ch ) ) { MST[rv.ROR1Mutator]MSP[N] return normalize ( basePath + fullFileNameToAdd ) ; } return normalize ( basePath + '/' + fullFileNameToAdd ) ; }
if ( len < 0 ) { return null ; } if ( len > fileName . length () ) { failIfNullBytePresent ( fileName + UNIX_SEPARATOR ) ; return fileName + UNIX_SEPARATOR ; } final String path = fileName . substring ( 0 , len ) ; MST[InlineConstantMutator]MSP[N]
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return len + 1 ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ; return Math . min ( posUnix , posWin ) + 1 ; }
static boolean isSystemWindows () { return SYSTEM_SEPARATOR == WINDOWS_SEPARATOR ; MST[rv.ROR1Mutator]MSP[N] } private static boolean isSeparator ( final char ch ) { return ch == UNIX_SEPARATOR || ch == WINDOWS_SEPARATOR ; } public static String normalize ( final String fileName ) {
for ( int i = 1 ; i <= 4 ; i ++ ) { MST[rv.CRCR4Mutator]MSP[N] final String ipSegment = m . group ( i ) ; final int iIpSegment = Integer . parseInt ( ipSegment ) ; if ( iIpSegment > IPV4_MAX_OCTET_VALUE ) { return false ; }
( i == prefix + 1 || array [ i - 2 ] == separator ) ) { if ( i == size - 1 ) { MST[rv.UOI2Mutator]MSP[N] lastIsDirectory = true ; }
} else if ( isSeparator ( ch0 ) && isSeparator ( ch1 ) ) { int posUnix = fileName . indexOf ( UNIX_SEPARATOR , 2 ) ; int posWin = fileName . indexOf ( WINDOWS_SEPARATOR , 2 ) ; MST[rv.CRCR6Mutator]MSP[N]
if ( containsCompressedZeroes && ( inet6Address . indexOf ( lr_9 ) != inet6Address . lastIndexOf ( lr_9 ) ) ) { MST[rv.ROR4Mutator]MSP[N] return false ; } if ( ( inet6Address . startsWith ( lr_10 ) && ! inet6Address . startsWith ( lr_9 ) )
if ( size <= prefix ) { return new String ( array , 0 , size ) ; } if ( lastIsDirectory && keepSeparator ) { return new String ( array , 0 , size ) ; MST[ConstructorCallMutator]MSP[N] }
} else if ( isSeparator ( ch0 ) && isSeparator ( ch1 ) ) { int posUnix = fileName . indexOf ( UNIX_SEPARATOR , 2 ) ; MST[rv.CRCR4Mutator]MSP[N] int posWin = fileName . indexOf ( WINDOWS_SEPARATOR , 2 ) ;
if ( len < 0 ) { return null ; } if ( len > fileName . length () ) { failIfNullBytePresent ( fileName + UNIX_SEPARATOR ) ; MST[rv.CRCR2Mutator]MSP[N] return fileName + UNIX_SEPARATOR ; } final String path = fileName . substring ( 0 , len ) ;
return fileName . substring ( index + 1 ) ; MST[rv.UOI3Mutator]MSP[N] } private static int getAdsCriticalOffset ( final String fileName ) { final int offset1 = fileName . lastIndexOf ( SYSTEM_SEPARATOR ) ; final int offset2 = fileName . lastIndexOf ( OTHER_SEPARATOR ) ;
final int pos = Math . min ( posUnix , posWin ) + 1 ; final String hostnamePart = fileName . substring ( 2 , pos - 1 ) ; MST[rv.CRCR2Mutator]MSP[N] return isValidHostName ( hostnamePart ) ? pos : NOT_FOUND ; } else {
final int index = indexOfLastSeparator ( fileName ) ; if ( index < 0 ) { return fileName . substring ( 0 , prefix ) ; } int end = index + ( includeSeparator ? 1 : 0 ) ; if ( end == 0 ) { MST[rv.ABSMutator]MSP[N] end ++ ;
for ( int i = 0 ; i < parts . length ; i ++ ) { MST[rv.CRCR5Mutator]MSP[N] if ( parts [ i ] . length () == 0 ) { return i == parts . length - 1 ; }
public static boolean directoryContains ( final String canonicalParent , final String canonicalChild ) throws IOException { if ( canonicalParent == null ) { throw new IllegalArgumentException ( lr_1 ) ; } if ( canonicalChild == null ) { MST[NegateConditionalsMutator]MSP[N] return false ; }
final int pos = Math . min ( posUnix , posWin ) + 1 ; final String hostnamePart = fileName . substring ( 2 , pos - 1 ) ; MST[rv.AOR3Mutator]MSP[N] return isValidHostName ( hostnamePart ) ? pos : NOT_FOUND ; } else {
return doNormalize ( fileName , SYSTEM_SEPARATOR , true ) ; } public static String normalize ( final String fileName , final boolean unixSeparator ) { final char separator = unixSeparator ? UNIX_SEPARATOR : WINDOWS_SEPARATOR ; MST[rv.UOI3Mutator]MSP[N] return doNormalize ( fileName , separator , true ) ; }
( i == prefix + 1 || array [ i - 2 ] == separator ) ) { if ( i == size - 1 ) { MST[rv.ABSMutator]MSP[N] lastIsDirectory = true ; }
} else if ( inet6Address . startsWith ( lr_9 ) && ! octetList . isEmpty () ) { MST[rv.ROR2Mutator]MSP[N] octetList . remove ( 0 ) ; } octets = octetList . toArray ( new String [ octetList . size () ] ) ; }
} else if ( inet6Address . startsWith ( lr_9 ) && ! octetList . isEmpty () ) { MST[rv.ROR5Mutator]MSP[N] octetList . remove ( 0 ) ; } octets = octetList . toArray ( new String [ octetList . size () ] ) ; }
for ( int i = 0 ; i < parts . length ; i ++ ) { if ( parts [ i ] . length () == 0 ) { return i == parts . length - 1 ; MST[rv.CRCR6Mutator]MSP[N] }
return isSeparator ( ch0 ) ? 1 : 0 ; MST[rv.CRCR4Mutator]MSP[N] } } public static int indexOfLastSeparator ( final String fileName ) { if ( fileName == null ) { return NOT_FOUND ; } final int lastUnixPos = fileName . lastIndexOf ( UNIX_SEPARATOR ) ;
if ( i == prefix + 2 ) { return null ; } if ( i == size - 1 ) { MST[rv.ROR4Mutator]MSP[N] lastIsDirectory = true ; } int j ; for ( j = i - 4 ; j >= prefix ; j -- ) {
System . arraycopy ( array , i + 1 , array , prefix , size - i ) ; MST[rv.ABSMutator]MSP[N] size -= i + 1 - prefix ; i = prefix + 1 ; } } if ( size <= 0 ) { return EMPTY_STRING ; }
final int index = indexOfLastSeparator ( fileName ) ; final int endIndex = index + separatorAdd ; if ( prefix >= fileName . length () || index < 0 || prefix >= endIndex ) { MST[rv.UOI3Mutator]MSP[N] return EMPTY_STRING ; }
final int pos = Math . min ( posUnix , posWin ) + 1 ; final String hostnamePart = fileName . substring ( 2 , pos - 1 ) ; return isValidHostName ( hostnamePart ) ? pos : NOT_FOUND ; MST[rv.ROR5Mutator]MSP[N] } else {
if ( array [ j ] == separator ) { System . arraycopy ( array , i + 1 , array , j + 1 , size - i ) ; MST[rv.CRCR3Mutator]MSP[N] size -= i - j ; i = j + 1 ; continue outer; } }
if ( len == 2 || isSeparator ( fileName . charAt ( 2 ) ) == false ) { return 2 ; } return 3 ; } else if ( ch0 == UNIX_SEPARATOR ) { return 1 ; MST[rv.CRCR3Mutator]MSP[S] } return NOT_FOUND ;
System . arraycopy ( array , i + 1 , array , i - 1 , size - i ) ; size -= 2 ; i -- ; } } outer: for ( int i = prefix + 2 ; i < size ; i ++ ) { MST[rv.UOI3Mutator]MSP[N]
list . add ( lr_6 ) ; } else if ( prevChar != '*' ) { list . add ( lr_7 ) ; } } else { buffer . append ( ch ) ; } prevChar = ch ; MST[rv.ABSMutator]MSP[S] } if ( buffer . length () != 0 ) {
if ( array [ j ] == separator ) { System . arraycopy ( array , i + 1 , array , j + 1 , size - i ) ; size -= i - j ; i = j + 1 ; MST[rv.CRCR3Mutator]MSP[N] continue outer; } }
if ( path . charAt ( i ) == 0 ) { throw new IllegalArgumentException ( lr_3 + lr_4 ) ; } } } public static String getBaseName ( final String fileName ) { return removeExtension ( getName ( fileName ) ) ; MST[ArgumentPropagationMutator]MSP[S] }
for ( int i = 1 ; i <= 4 ; i ++ ) { final String ipSegment = m . group ( i ) ; final int iIpSegment = Integer . parseInt ( ipSegment ) ; if ( iIpSegment > IPV4_MAX_OCTET_VALUE ) { MST[rv.UOI3Mutator]MSP[N] return false ; }
public static boolean wildcardMatch ( final String fileName , final String wildcardMatcher ) { return wildcardMatch ( fileName , wildcardMatcher , IOCase . SENSITIVE ) ; MST[BooleanTrueReturnValsMutator]MSP[N] } public static boolean wildcardMatchOnSystem ( final String fileName , final String wildcardMatcher ) {
public static String getFullPathNoEndSeparator ( final String fileName ) { return doGetFullPath ( fileName , false ) ; MST[ReturnValsMutator]MSP[N] } private static String doGetFullPath ( final String fileName , final boolean includeSeparator ) { if ( fileName == null ) { return null ; }
( i == prefix + 1 || array [ i - 2 ] == separator ) ) { if ( i == size - 1 ) { MST[NegateConditionalsMutator]MSP[N] lastIsDirectory = true ; }
textIdx = array [ 1 ] ; anyChars = true ; } while ( wcsIdx < wcs . length ) { if ( wcs [ wcsIdx ] . equals ( lr_6 ) ) { textIdx ++ ; if ( textIdx > fileName . length () ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] break; }
if ( ipSegment . length () > 1 && ipSegment . startsWith ( lr_8 ) ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] return false ; } } return true ; } private static boolean isIPv6Address ( final String inet6Address ) { final boolean containsCompressedZeroes = inet6Address . contains ( lr_9 ) ;
list . add ( buffer . toString () ) ; } return list . toArray ( new String [ list . size () ] ) ; } private static boolean isValidHostName ( final String name ) { return isIPv6Address ( name ) || isRFC3986HostName ( name ) ; MST[rv.CRCR6Mutator]MSP[N] }
final int index = indexOfLastSeparator ( fileName ) ; final int endIndex = index + separatorAdd ; if ( prefix >= fileName . length () || index < 0 || prefix >= endIndex ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] return EMPTY_STRING ; }
if ( array [ i ] == separator && array [ i - 1 ] == '.' && array [ i - 2 ] == '.' && MST[rv.AOR1Mutator]MSP[N] ( i == prefix + 2 || array [ i - 3 ] == separator ) ) {
if ( path == null || path . indexOf ( UNIX_SEPARATOR ) == NOT_FOUND ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return path ; } return path . replace ( UNIX_SEPARATOR , WINDOWS_SEPARATOR ) ; } public static String separatorsToSystem ( final String path ) { if ( path == null ) {
if ( repeat >= 0 ) { backtrack . push ( new int [] { wcsIdx , repeat } ) ; } } else { if ( ! caseSensitivity . checkRegionMatches ( fileName , textIdx , wcs [ wcsIdx ] ) ) { MST[NegateConditionalsMutator]MSP[N] break; } }
if ( fileName == null || wildcardMatcher == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return false ; } if ( caseSensitivity == null ) { caseSensitivity = IOCase . SENSITIVE ; } final String [] wcs = splitOnTokens ( wildcardMatcher ) ; boolean anyChars = false ; int textIdx = 0 ;
if ( size <= prefix ) { return new String ( array , 0 , size ) ; MST[rv.UOI2Mutator]MSP[N] } if ( lastIsDirectory && keepSeparator ) { return new String ( array , 0 , size ) ; }
if ( array [ size - 1 ] != separator ) { MST[rv.UOI3Mutator]MSP[N] array [ size ++ ] = separator ; lastIsDirectory = false ; } for ( int i = prefix + 1 ; i < size ; i ++ ) {
return indexOfExtension ( fileName ) == NOT_FOUND ; } final String fileExt = getExtension ( fileName ) ; for ( final String extension : extensions ) { if ( fileExt . equals ( extension ) ) { return true ; MST[rv.CRCR2Mutator]MSP[N] } } return false ; }
for ( int i = prefix + 1 ; i < size ; i ++ ) { if ( array [ i ] == separator && array [ i - 1 ] == '.' && MST[rv.CRCR5Mutator]MSP[N]
System . arraycopy ( array , i + 1 , array , prefix , size - i ) ; size -= i + 1 - prefix ; i = prefix + 1 ; MST[rv.CRCR4Mutator]MSP[N] } } if ( size <= 0 ) { return EMPTY_STRING ; }
final char ch = basePath . charAt ( len - 1 ) ; if ( isSeparator ( ch ) ) { return normalize ( basePath + fullFileNameToAdd ) ; } return normalize ( basePath + '/' + fullFileNameToAdd ) ; MST[rv.CRCR5Mutator]MSP[N] }
if ( len == 2 || isSeparator ( fileName . charAt ( 2 ) ) == false ) { MST[rv.CRCR6Mutator]MSP[N] return 2 ; } return 3 ; } else if ( ch0 == UNIX_SEPARATOR ) { return 1 ; } return NOT_FOUND ;
if ( extension == null || extension . isEmpty () ) { return indexOfExtension ( fileName ) == NOT_FOUND ; MST[rv.CRCR5Mutator]MSP[S] } final String fileExt = getExtension ( fileName ) ; return fileExt . equals ( extension ) ; }
if ( size <= prefix ) { return new String ( array , 0 , size ) ; } if ( lastIsDirectory && keepSeparator ) { MST[rv.UOI4Mutator]MSP[N] return new String ( array , 0 , size ) ; }
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND ) { return len + 1 ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; MST[rv.ROR4Mutator]MSP[N] posWin = posWin == NOT_FOUND ? posUnix : posWin ; return Math . min ( posUnix , posWin ) + 1 ; }
} public static boolean equalsOnSystem ( final String fileName1 , final String fileName2 ) { return equals ( fileName1 , fileName2 , false , IOCase . SYSTEM ) ; MST[NonVoidMethodCallMutator]MSP[N] } public static boolean equalsNormalized ( final String fileName1 , final String fileName2 ) {
final int lastSeparator = indexOfLastSeparator ( fileName ) ; return lastSeparator > extensionPos ? NOT_FOUND : extensionPos ; MST[rv.ROR3Mutator]MSP[N] } public static String getPrefix ( final String fileName ) { if ( fileName == null ) { return null ; } final int len = getPrefixLength ( fileName ) ;
if ( array [ i ] == separator && array [ i - 1 ] == separator ) { MST[rv.ROR1Mutator]MSP[N] System . arraycopy ( array , i , array , i - 1 , size - i ) ; size -- ; i -- ; } }
if ( isSystemWindows () ) { MST[rv.ROR2Mutator]MSP[N] final int offset = fileName . indexOf ( ':' , getAdsCriticalOffset ( fileName ) ) ; if ( offset != - 1 ) { throw new IllegalArgumentException ( lr_2 ) ; } } final int extensionPos = fileName . lastIndexOf ( EXTENSION_SEPARATOR ) ;
private static String doGetPath ( final String fileName , final int separatorAdd ) { if ( fileName == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return null ; } final int prefix = getPrefixLength ( fileName ) ; if ( prefix < 0 ) { return null ; }
if ( size <= prefix ) { return new String ( array , 0 , size ) ; } if ( lastIsDirectory && keepSeparator ) { MST[rv.UOI1Mutator]MSP[S] return new String ( array , 0 , size ) ; }
if ( len == 0 ) { return 0 ; } char ch0 = fileName . charAt ( 0 ) ; if ( ch0 == ':' ) { MST[rv.UOI1Mutator]MSP[N] return NOT_FOUND ; } if ( len == 1 ) { if ( ch0 == '~' ) { return 2 ; }
final char ch = basePath . charAt ( len - 1 ) ; MST[rv.AOR2Mutator]MSP[N] if ( isSeparator ( ch ) ) { return normalize ( basePath + fullFileNameToAdd ) ; } return normalize ( basePath + '/' + fullFileNameToAdd ) ; }
final int index = indexOfLastSeparator ( fileName ) ; if ( index < 0 ) { return fileName . substring ( 0 , prefix ) ; } int end = index + ( includeSeparator ? 1 : 0 ) ; MST[rv.CRCR3Mutator]MSP[S] if ( end == 0 ) { end ++ ;
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2 ) { MST[rv.UOI3Mutator]MSP[N] return NOT_FOUND ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ;
System . arraycopy ( array , i + 1 , array , i - 1 , size - i ) ; MST[MathMutator]MSP[N] size -= 2 ; i -- ; } } outer: for ( int i = prefix + 2 ; i < size ; i ++ ) {
if ( array [ i ] == separator && array [ i - 1 ] == '.' && array [ i - 2 ] == '.' && MST[rv.UOI2Mutator]MSP[N] ( i == prefix + 2 || array [ i - 3 ] == separator ) ) {
if ( len == 0 ) { return 0 ; } char ch0 = fileName . charAt ( 0 ) ; if ( ch0 == ':' ) { MST[rv.UOI4Mutator]MSP[N] return NOT_FOUND ; } if ( len == 1 ) { if ( ch0 == '~' ) { return 2 ; }
if ( extension == null || extension . isEmpty () ) { return indexOfExtension ( fileName ) == NOT_FOUND ; MST[NegateConditionalsMutator]MSP[N] } final String fileExt = getExtension ( fileName ) ; return fileExt . equals ( extension ) ; }
if ( validOctets > IPV6_MAX_HEX_GROUPS || ( validOctets < IPV6_MAX_HEX_GROUPS && ! containsCompressedZeroes ) ) { MST[rv.ABSMutator]MSP[N] return false ; } return true ; } private static boolean isRFC3986HostName ( final String name ) { final String [] parts = name . split ( lr_13 , - 1 ) ;
if ( array [ i ] == separator && array [ i - 1 ] == '.' && array [ i - 2 ] == '.' && MST[rv.UOI3Mutator]MSP[N] ( i == prefix + 2 || array [ i - 3 ] == separator ) ) {
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND ) { return len + 1 ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ; return Math . min ( posUnix , posWin ) + 1 ; MST[PrimitiveReturnsMutator]MSP[N] }
} else if ( isSeparator ( ch0 ) && isSeparator ( ch1 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] int posUnix = fileName . indexOf ( UNIX_SEPARATOR , 2 ) ; int posWin = fileName . indexOf ( WINDOWS_SEPARATOR , 2 ) ;
if ( ! REG_NAME_PART_PATTERN . matcher ( parts [ i ] ) . matches () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return false ; } } return true ; }
if ( fileName == null || wildcardMatcher == null ) { MST[NegateConditionalsMutator]MSP[N] return false ; } if ( caseSensitivity == null ) { caseSensitivity = IOCase . SENSITIVE ; } final String [] wcs = splitOnTokens ( wildcardMatcher ) ; boolean anyChars = false ; int textIdx = 0 ;
fileName2 = normalize ( fileName2 ) ; if ( fileName1 == null || fileName2 == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] throw new NullPointerException ( lr_5 ) ; } } if ( caseSensitivity == null ) { caseSensitivity = IOCase . SENSITIVE ; }
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND ) { return len + 1 ; MST[rv.CRCR4Mutator]MSP[N] } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ; return Math . min ( posUnix , posWin ) + 1 ; }
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2 ) { return NOT_FOUND ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; MST[rv.ROR5Mutator]MSP[N] posWin = posWin == NOT_FOUND ? posUnix : posWin ;
if ( path == null || path . indexOf ( WINDOWS_SEPARATOR ) == NOT_FOUND ) { return path ; } return path . replace ( WINDOWS_SEPARATOR , UNIX_SEPARATOR ) ; MST[rv.CRCR4Mutator]MSP[N] } public static String separatorsToWindows ( final String path ) {
return indexOfExtension ( fileName ) == NOT_FOUND ; MST[InlineConstantMutator]MSP[S] } final String fileExt = getExtension ( fileName ) ; for ( final String extension : extensions ) { if ( fileExt . equals ( extension ) ) { return true ; } } return false ; }
return wildcardMatch ( fileName , wildcardMatcher , IOCase . SYSTEM ) ; } public static boolean wildcardMatch ( final String fileName , final String wildcardMatcher , IOCase caseSensitivity ) { if ( fileName == null && wildcardMatcher == null ) { MST[rv.ROR5Mutator]MSP[N] return true ; }
if ( size <= prefix ) { MST[rv.ABSMutator]MSP[N] return new String ( array , 0 , size ) ; } if ( lastIsDirectory && keepSeparator ) { return new String ( array , 0 , size ) ; }
for ( int i = 0 ; i < parts . length ; i ++ ) { if ( parts [ i ] . length () == 0 ) { MST[rv.UOI1Mutator]MSP[N] return i == parts . length - 1 ; }
if ( validOctets > IPV6_MAX_HEX_GROUPS || ( validOctets < IPV6_MAX_HEX_GROUPS && ! containsCompressedZeroes ) ) { return false ; } return true ; MST[rv.CRCR2Mutator]MSP[N] } private static boolean isRFC3986HostName ( final String name ) { final String [] parts = name . split ( lr_13 , - 1 ) ;
for ( int i = prefix + 1 ; i < size ; i ++ ) { if ( array [ i ] == separator && array [ i - 1 ] == '.' && MST[rv.ROR1Mutator]MSP[N]
if ( repeat >= 0 ) { MST[rv.ROR5Mutator]MSP[N] backtrack . push ( new int [] { wcsIdx , repeat } ) ; } } else { if ( ! caseSensitivity . checkRegionMatches ( fileName , textIdx , wcs [ wcsIdx ] ) ) { break; } }
for ( int i = prefix + 1 ; i < size ; i ++ ) { if ( array [ i ] == separator && array [ i - 1 ] == '.' && MST[rv.CRCR5Mutator]MSP[N]
} return fileName . substring ( 0 , end ) ; MST[rv.CRCR1Mutator]MSP[N] } public static String getName ( final String fileName ) { if ( fileName == null ) { return null ; } failIfNullBytePresent ( fileName ) ; final int index = indexOfLastSeparator ( fileName ) ;
int wcsIdx = 0 ; final Stack < int [] > backtrack = new Stack <> () ; do { if ( backtrack . size () > 0 ) { MST[rv.ROR1Mutator]MSP[N] final int [] array = backtrack . pop () ; wcsIdx = array [ 0 ] ;
int size = fileName . length () ; if ( size == 0 ) { MST[NegateConditionalsMutator]MSP[N] return fileName ; } final int prefix = getPrefixLength ( fileName ) ; if ( prefix < 0 ) { return null ; }
if ( validOctets > IPV6_MAX_HEX_GROUPS || ( validOctets < IPV6_MAX_HEX_GROUPS && ! containsCompressedZeroes ) ) { MST[rv.CRCR1Mutator]MSP[S] return false ; } return true ; } private static boolean isRFC3986HostName ( final String name ) { final String [] parts = name . split ( lr_13 , - 1 ) ;
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND ) { return len + 1 ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ; MST[rv.CRCR5Mutator]MSP[N] return Math . min ( posUnix , posWin ) + 1 ; }
if ( octets . length > IPV6_MAX_HEX_GROUPS ) { MST[rv.ROR5Mutator]MSP[N] return false ; } int validOctets = 0 ; int emptyOctets = 0 ; for ( int index = 0 ; index < octets . length ; index ++ ) { final String octet = octets [ index ] ;
if ( octets . length > IPV6_MAX_HEX_GROUPS ) { return false ; } int validOctets = 0 ; int emptyOctets = 0 ; MST[rv.CRCR3Mutator]MSP[N] for ( int index = 0 ; index < octets . length ; index ++ ) { final String octet = octets [ index ] ;
if ( ! isIPv4Address ( octet ) ) { return false ; } validOctets += 2 ; continue; } if ( octet . length () > IPV6_MAX_HEX_DIGITS_PER_GROUP ) { return false ; MST[rv.CRCR6Mutator]MSP[N] } int octetInt = 0 ; try {
static boolean isSystemWindows () { return SYSTEM_SEPARATOR == WINDOWS_SEPARATOR ; MST[rv.ROR4Mutator]MSP[N] } private static boolean isSeparator ( final char ch ) { return ch == UNIX_SEPARATOR || ch == WINDOWS_SEPARATOR ; } public static String normalize ( final String fileName ) {
anyChars = false ; } else if ( wcs [ wcsIdx ] . equals ( lr_7 ) ) { anyChars = true ; if ( wcsIdx == wcs . length - 1 ) { MST[InlineConstantMutator]MSP[N] textIdx = fileName . length () ; } } else { if ( anyChars ) {
System . arraycopy ( array , i + 1 , array , i - 1 , size - i ) ; size -= 2 ; i -- ; } } outer: for ( int i = prefix + 2 ; i < size ; i ++ ) { MST[rv.ABSMutator]MSP[N]
if ( IOCase . SYSTEM . checkEquals ( canonicalParent , canonicalChild ) ) { return false ; MST[rv.CRCR1Mutator]MSP[S] } return IOCase . SYSTEM . checkStartsWith ( canonicalChild , canonicalParent ) ; } public static String separatorsToUnix ( final String path ) {
final int index = indexOfLastSeparator ( fileName ) ; final int endIndex = index + separatorAdd ; if ( prefix >= fileName . length () || index < 0 || prefix >= endIndex ) { MST[rv.ROR3Mutator]MSP[N] return EMPTY_STRING ; }
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2 ) { MST[rv.UOI2Mutator]MSP[N] return NOT_FOUND ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ;
if ( len < 0 ) { return null ; } if ( len > fileName . length () ) { failIfNullBytePresent ( fileName + UNIX_SEPARATOR ) ; MST[rv.CRCR5Mutator]MSP[N] return fileName + UNIX_SEPARATOR ; } final String path = fileName . substring ( 0 , len ) ;
fileName2 = normalize ( fileName2 ) ; if ( fileName1 == null || fileName2 == null ) { throw new NullPointerException ( MST[ConstructorCallMutator]MSP[N] lr_5 ) ; } } if ( caseSensitivity == null ) { caseSensitivity = IOCase . SENSITIVE ; }
if ( array [ j ] == separator ) { System . arraycopy ( array , i + 1 , array , j + 1 , size - i ) ; MST[rv.UOI4Mutator]MSP[N] size -= i - j ; i = j + 1 ; continue outer; } }
for ( int i = 1 ; i <= 4 ; i ++ ) { MST[rv.CRCR1Mutator]MSP[N] final String ipSegment = m . group ( i ) ; final int iIpSegment = Integer . parseInt ( ipSegment ) ; if ( iIpSegment > IPV4_MAX_OCTET_VALUE ) { return false ; }
if ( path == null || path . indexOf ( WINDOWS_SEPARATOR ) == NOT_FOUND ) { MST[rv.ROR5Mutator]MSP[N] return path ; } return path . replace ( WINDOWS_SEPARATOR , UNIX_SEPARATOR ) ; } public static String separatorsToWindows ( final String path ) {
if ( len == 0 ) { return 0 ; } char ch0 = fileName . charAt ( 0 ) ; MST[InlineConstantMutator]MSP[N] if ( ch0 == ':' ) { return NOT_FOUND ; } if ( len == 1 ) { if ( ch0 == '~' ) { return 2 ; }
final String path = fileName . substring ( prefix , endIndex ) ; failIfNullBytePresent ( path ) ; return path ; } public static String getFullPath ( final String fileName ) { return doGetFullPath ( fileName , true ) ; MST[rv.CRCR4Mutator]MSP[N] }
final char ch = basePath . charAt ( len - 1 ) ; if ( isSeparator ( ch ) ) { MST[rv.ROR4Mutator]MSP[N] return normalize ( basePath + fullFileNameToAdd ) ; } return normalize ( basePath + '/' + fullFileNameToAdd ) ; }
public static String getExtension ( final String fileName ) throws IllegalArgumentException { if ( fileName == null ) { return null ; } final int index = indexOfExtension ( fileName ) ; if ( index == NOT_FOUND ) { MST[rv.ABSMutator]MSP[N] return EMPTY_STRING ; }
if ( i == prefix + 2 ) { return null ; } if ( i == size - 1 ) { MST[rv.AOD2Mutator]MSP[S] lastIsDirectory = true ; } int j ; for ( j = i - 4 ; j >= prefix ; j -- ) {
if ( ! REG_NAME_PART_PATTERN . matcher ( parts [ i ] ) . matches () ) { MST[rv.ROR3Mutator]MSP[N] return false ; } } return true ; }
if ( i == prefix + 2 ) { return null ; } if ( i == size - 1 ) { lastIsDirectory = true ; } int j ; for ( j = i - 4 ; j >= prefix ; j -- ) { MST[rv.CRCR4Mutator]MSP[N]
final char ch1 = fileName . charAt ( 1 ) ; if ( ch1 == ':' ) { ch0 = Character . toUpperCase ( ch0 ) ; if ( ch0 >= 'A' && ch0 <= 'Z' ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N]
if ( repeat >= 0 ) { backtrack . push ( new int [] { wcsIdx , repeat } ) ; MST[rv.UOI4Mutator]MSP[N] } } else { if ( ! caseSensitivity . checkRegionMatches ( fileName , textIdx , wcs [ wcsIdx ] ) ) { break; } }
final int prefix = getPrefixLength ( fileName ) ; if ( prefix < 0 ) { return null ; } if ( prefix >= fileName . length () ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] if ( includeSeparator ) { return getPrefix ( fileName ) ; } return fileName ; }
static boolean isSystemWindows () { return SYSTEM_SEPARATOR == WINDOWS_SEPARATOR ; } private static boolean isSeparator ( final char ch ) { return ch == UNIX_SEPARATOR || ch == WINDOWS_SEPARATOR ; MST[BooleanTrueReturnValsMutator]MSP[N] } public static String normalize ( final String fileName ) {
if ( path == null || path . indexOf ( UNIX_SEPARATOR ) == NOT_FOUND ) { return path ; } return path . replace ( UNIX_SEPARATOR , WINDOWS_SEPARATOR ) ; } public static String separatorsToSystem ( final String path ) { if ( path == null ) { MST[rv.ROR5Mutator]MSP[N]
return null ; } return isSystemWindows () ? separatorsToWindows ( path ) : separatorsToUnix ( path ) ; MST[ReturnValsMutator]MSP[N] } public static int getPrefixLength ( final String fileName ) { if ( fileName == null ) { return NOT_FOUND ; } final int len = fileName . length () ;
if ( len == 2 || isSeparator ( fileName . charAt ( 2 ) ) == false ) { return 2 ; } return 3 ; } else if ( ch0 == UNIX_SEPARATOR ) { return 1 ; } return NOT_FOUND ; MST[PrimitiveReturnsMutator]MSP[N]
if ( array [ i ] == separator && array [ i - 1 ] == '.' && array [ i - 2 ] == '.' && MST[rv.UOI2Mutator]MSP[N] ( i == prefix + 2 || array [ i - 3 ] == separator ) ) {
final int pos = Math . min ( posUnix , posWin ) + 1 ; final String hostnamePart = fileName . substring ( 2 , pos - 1 ) ; MST[rv.CRCR5Mutator]MSP[N] return isValidHostName ( hostnamePart ) ? pos : NOT_FOUND ; } else {
final List < String > octetList = new ArrayList <> ( Arrays . asList ( octets ) ) ; if ( inet6Address . endsWith ( lr_9 ) ) { MST[rv.ROR3Mutator]MSP[N] octetList . add ( lr_11 ) ;
final int index = indexOfLastSeparator ( fileName ) ; final int endIndex = index + separatorAdd ; MST[rv.AOD1Mutator]MSP[S] if ( prefix >= fileName . length () || index < 0 || prefix >= endIndex ) { return EMPTY_STRING ; }
final int index = indexOfLastSeparator ( fileName ) ; if ( index < 0 ) { return fileName . substring ( 0 , prefix ) ; } int end = index + ( includeSeparator ? 1 : 0 ) ; MST[rv.UOI3Mutator]MSP[N] if ( end == 0 ) { end ++ ;
if ( repeat >= 0 ) { backtrack . push ( new int [] { wcsIdx , repeat } ) ; } } else { if ( ! caseSensitivity . checkRegionMatches ( fileName , textIdx , wcs [ wcsIdx ] ) ) { MST[rv.UOI4Mutator]MSP[N] break; } }
if ( array [ i ] == separator && array [ i - 1 ] == '.' && array [ i - 2 ] == '.' && MST[rv.AOD2Mutator]MSP[N] ( i == prefix + 2 || array [ i - 3 ] == separator ) ) {
list . add ( lr_6 ) ; } else if ( prevChar != '*' ) { list . add ( lr_7 ) ; } } else { buffer . append ( ch ) ; MST[rv.UOI3Mutator]MSP[N] } prevChar = ch ; } if ( buffer . length () != 0 ) {
final String path = fileName . substring ( prefix , endIndex ) ; MST[rv.UOI1Mutator]MSP[N] failIfNullBytePresent ( path ) ; return path ; } public static String getFullPath ( final String fileName ) { return doGetFullPath ( fileName , true ) ; }
final char [] array = new char [ size + 2 ] ; MST[rv.AOR2Mutator]MSP[N] fileName . getChars ( 0 , fileName . length () , array , 0 ) ; final char otherSeparator = separator == SYSTEM_SEPARATOR ? OTHER_SEPARATOR : SYSTEM_SEPARATOR ;
if ( validOctets > IPV6_MAX_HEX_GROUPS || ( validOctets < IPV6_MAX_HEX_GROUPS && ! containsCompressedZeroes ) ) { return false ; MST[BooleanTrueReturnValsMutator]MSP[S] } return true ; } private static boolean isRFC3986HostName ( final String name ) { final String [] parts = name . split ( lr_13 , - 1 ) ;
System . arraycopy ( array , i + 1 , array , prefix , size - i ) ; size -= i + 1 - prefix ; MST[rv.AOR4Mutator]MSP[N] i = prefix + 1 ; } } if ( size <= 0 ) { return EMPTY_STRING ; }
if ( containsCompressedZeroes && ( inet6Address . indexOf ( lr_9 ) != inet6Address . lastIndexOf ( lr_9 ) ) ) { return false ; } if ( ( inet6Address . startsWith ( lr_10 ) && ! inet6Address . startsWith ( lr_9 ) ) MST[rv.ROR2Mutator]MSP[N]
} else if ( inet6Address . startsWith ( lr_9 ) && ! octetList . isEmpty () ) { MST[rv.ROR3Mutator]MSP[N] octetList . remove ( 0 ) ; } octets = octetList . toArray ( new String [ octetList . size () ] ) ; }
return false ; } static String [] splitOnTokens ( final String text ) { if ( text . indexOf ( '?' ) == NOT_FOUND && text . indexOf ( '*' ) == NOT_FOUND ) { MST[rv.CRCR5Mutator]MSP[N] return new String [] { text } ; }
if ( index == NOT_FOUND ) { MST[rv.ABSMutator]MSP[S] return fileName ; } return fileName . substring ( 0 , index ) ; } public static boolean equals ( final String fileName1 , final String fileName2 ) { return equals ( fileName1 , fileName2 , false , IOCase . SENSITIVE ) ;
if ( len == 2 || isSeparator ( fileName . charAt ( 2 ) ) == false ) { MST[rv.ROR1Mutator]MSP[N] return 2 ; } return 3 ; } else if ( ch0 == UNIX_SEPARATOR ) { return 1 ; } return NOT_FOUND ;
final int index = indexOfLastSeparator ( fileName ) ; final int endIndex = index + separatorAdd ; if ( prefix >= fileName . length () || index < 0 || prefix >= endIndex ) { MST[rv.UOI2Mutator]MSP[N] return EMPTY_STRING ; }
System . arraycopy ( array , i + 1 , array , prefix , size - i ) ; MST[rv.UOI1Mutator]MSP[N] size -= i + 1 - prefix ; i = prefix + 1 ; } } if ( size <= 0 ) { return EMPTY_STRING ; }
final char ch = basePath . charAt ( len - 1 ) ; MST[rv.UOI3Mutator]MSP[N] if ( isSeparator ( ch ) ) { return normalize ( basePath + fullFileNameToAdd ) ; } return normalize ( basePath + '/' + fullFileNameToAdd ) ; }
return Math . max ( offset1 , offset2 ) + 1 ; } public static String removeExtension ( final String fileName ) { if ( fileName == null ) { return null ; } failIfNullBytePresent ( fileName ) ; final int index = indexOfExtension ( fileName ) ; MST[NonVoidMethodCallMutator]MSP[N]
if ( array [ size - 1 ] != separator ) { array [ size ++ ] = separator ; lastIsDirectory = false ; } for ( int i = prefix + 1 ; i < size ; i ++ ) { MST[rv.UOI4Mutator]MSP[N]
final int index = indexOfLastSeparator ( fileName ) ; final int endIndex = index + separatorAdd ; if ( prefix >= fileName . length () || index < 0 || prefix >= endIndex ) { MST[rv.ROR4Mutator]MSP[N] return EMPTY_STRING ; }
if ( len == 0 ) { return 0 ; } char ch0 = fileName . charAt ( 0 ) ; if ( ch0 == ':' ) { return NOT_FOUND ; } if ( len == 1 ) { if ( ch0 == '~' ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return 2 ; }
for ( int i = 0 ; i < parts . length ; i ++ ) { if ( parts [ i ] . length () == 0 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return i == parts . length - 1 ; }
for ( int i = prefix + 1 ; i < size ; i ++ ) { MST[rv.CRCR4Mutator]MSP[N] if ( array [ i ] == separator && array [ i - 1 ] == '.' &&
if ( index == NOT_FOUND ) { return fileName ; } return fileName . substring ( 0 , index ) ; } public static boolean equals ( final String fileName1 , final String fileName2 ) { return equals ( fileName1 , fileName2 , false , IOCase . SENSITIVE ) ; MST[rv.CRCR6Mutator]MSP[S]
textIdx = array [ 1 ] ; anyChars = true ; } while ( wcsIdx < wcs . length ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] if ( wcs [ wcsIdx ] . equals ( lr_6 ) ) { textIdx ++ ; if ( textIdx > fileName . length () ) { break; }
final int index = indexOfLastSeparator ( fileName ) ; if ( index < 0 ) { return fileName . substring ( 0 , prefix ) ; } int end = index + ( includeSeparator ? 1 : 0 ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] if ( end == 0 ) { end ++ ;
return indexOfExtension ( fileName ) == NOT_FOUND ; MST[BooleanTrueReturnValsMutator]MSP[S] } final String fileExt = getExtension ( fileName ) ; for ( final String extension : extensions ) { if ( fileExt . equals ( extension ) ) { return true ; } } return false ; }
if ( index == NOT_FOUND ) { return fileName ; } return fileName . substring ( 0 , index ) ; MST[NonVoidMethodCallMutator]MSP[N] } public static boolean equals ( final String fileName1 , final String fileName2 ) { return equals ( fileName1 , fileName2 , false , IOCase . SENSITIVE ) ;
textIdx = array [ 1 ] ; anyChars = true ; } while ( wcsIdx < wcs . length ) { if ( wcs [ wcsIdx ] . equals ( lr_6 ) ) { MST[rv.ROR2Mutator]MSP[N] textIdx ++ ; if ( textIdx > fileName . length () ) { break; }
final char [] array = text . toCharArray () ; final ArrayList < String > list = new ArrayList <> () ; final StringBuilder buffer = new StringBuilder () ; char prevChar = 0 ; for ( final char ch : array ) { MST[rv.ABSMutator]MSP[N]
if ( array [ i ] == separator && array [ i - 1 ] == separator ) { MST[rv.UOI3Mutator]MSP[N] System . arraycopy ( array , i , array , i - 1 , size - i ) ; size -- ; i -- ; } }
return null ; } return isSystemWindows () ? separatorsToWindows ( path ) : separatorsToUnix ( path ) ; } public static int getPrefixLength ( final String fileName ) { if ( fileName == null ) { return NOT_FOUND ; } final int len = fileName . length () ; MST[NonVoidMethodCallMutator]MSP[N]
return false ; } static String [] splitOnTokens ( final String text ) { if ( text . indexOf ( '?' ) == NOT_FOUND && text . indexOf ( '*' ) == NOT_FOUND ) { return new String [] { text } ; MST[InlineConstantMutator]MSP[N] }
if ( array [ i ] == separator && array [ i - 1 ] == separator ) { MST[rv.ROR4Mutator]MSP[N] System . arraycopy ( array , i , array , i - 1 , size - i ) ; size -- ; i -- ; } }
return doNormalize ( fileName , SYSTEM_SEPARATOR , true ) ; } public static String normalize ( final String fileName , final boolean unixSeparator ) { final char separator = unixSeparator ? UNIX_SEPARATOR : WINDOWS_SEPARATOR ; MST[rv.CRCR1Mutator]MSP[N] return doNormalize ( fileName , separator , true ) ; }
anyChars = false ; } else if ( wcs [ wcsIdx ] . equals ( lr_7 ) ) { anyChars = true ; if ( wcsIdx == wcs . length - 1 ) { MST[rv.AOR1Mutator]MSP[N] textIdx = fileName . length () ; } } else { if ( anyChars ) {
final int lastSeparator = indexOfLastSeparator ( fileName ) ; return lastSeparator > extensionPos ? NOT_FOUND : extensionPos ; MST[ReturnValsMutator]MSP[N] } public static String getPrefix ( final String fileName ) { if ( fileName == null ) { return null ; } final int len = getPrefixLength ( fileName ) ;
if ( array [ j ] == separator ) { System . arraycopy ( array , i + 1 , array , j + 1 , size - i ) ; size -= i - j ; i = j + 1 ; MST[rv.CRCR6Mutator]MSP[N] continue outer; } }
for ( int i = prefix + 1 ; i < size ; i ++ ) { if ( array [ i ] == separator && array [ i - 1 ] == '.' && MST[MathMutator]MSP[N]
return indexOfExtension ( fileName ) == NOT_FOUND ; } final String fileExt = getExtension ( fileName ) ; for ( final String extension : extensions ) { MST[rv.UOI4Mutator]MSP[N] if ( fileExt . equals ( extension ) ) { return true ; } } return false ; }
if ( array [ i ] == separator && array [ i - 1 ] == separator ) { System . arraycopy ( array , i , array , i - 1 , size - i ) ; size -- ; MST[IncrementsMutator]MSP[N] i -- ; } }
if ( ch == '?' || ch == '*' ) { if ( buffer . length () != 0 ) { list . add ( buffer . toString () ) ; buffer . setLength ( 0 ) ; } if ( ch == '?' ) { MST[rv.CRCR6Mutator]MSP[N]
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2 ) { MST[InlineConstantMutator]MSP[N] return NOT_FOUND ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ;
textIdx += wcs [ wcsIdx ] . length () ; anyChars = false ; } wcsIdx ++ ; } if ( wcsIdx == wcs . length && textIdx == fileName . length () ) { return true ; MST[BooleanFalseReturnValsMutator]MSP[N] } } while ( backtrack . size () > 0 );
if ( array [ j ] == separator ) { System . arraycopy ( array , i + 1 , array , j + 1 , size - i ) ; MST[rv.CRCR6Mutator]MSP[N] size -= i - j ; i = j + 1 ; continue outer; } }
System . arraycopy ( array , i + 1 , array , prefix , size - i ) ; MST[rv.AOR1Mutator]MSP[N] size -= i + 1 - prefix ; i = prefix + 1 ; } } if ( size <= 0 ) { return EMPTY_STRING ; }
return false ; } static String [] splitOnTokens ( final String text ) { if ( text . indexOf ( '?' ) == NOT_FOUND && text . indexOf ( '*' ) == NOT_FOUND ) { return new String [] { text } ; MST[rv.CRCR3Mutator]MSP[N] }
final int index = indexOfLastSeparator ( fileName ) ; if ( index < 0 ) { MST[rv.ABSMutator]MSP[N] return fileName . substring ( 0 , prefix ) ; } int end = index + ( includeSeparator ? 1 : 0 ) ; if ( end == 0 ) { end ++ ;
for ( int i = 0 ; i < parts . length ; i ++ ) { if ( parts [ i ] . length () == 0 ) { return i == parts . length - 1 ; MST[rv.UOI3Mutator]MSP[N] }
final int index = indexOfLastSeparator ( fileName ) ; final int endIndex = index + separatorAdd ; MST[rv.AOR3Mutator]MSP[N] if ( prefix >= fileName . length () || index < 0 || prefix >= endIndex ) { return EMPTY_STRING ; }
list . add ( lr_6 ) ; MST[NonVoidMethodCallMutator]MSP[N] } else if ( prevChar != '*' ) { list . add ( lr_7 ) ; } } else { buffer . append ( ch ) ; } prevChar = ch ; } if ( buffer . length () != 0 ) {
textIdx += wcs [ wcsIdx ] . length () ; anyChars = false ; } wcsIdx ++ ; } if ( wcsIdx == wcs . length && textIdx == fileName . length () ) { MST[rv.ROR3Mutator]MSP[N] return true ; } } while ( backtrack . size () > 0 );
if ( array [ j ] == separator ) { System . arraycopy ( array , i + 1 , array , j + 1 , size - i ) ; MST[rv.AOD2Mutator]MSP[N] size -= i - j ; i = j + 1 ; continue outer; } }
if ( i == prefix + 2 ) { MST[rv.ROR3Mutator]MSP[N] return null ; } if ( i == size - 1 ) { lastIsDirectory = true ; } int j ; for ( j = i - 4 ; j >= prefix ; j -- ) {
if ( len == 0 ) { return 0 ; } char ch0 = fileName . charAt ( 0 ) ; if ( ch0 == ':' ) { return NOT_FOUND ; } if ( len == 1 ) { if ( ch0 == '~' ) { MST[rv.CRCR4Mutator]MSP[N] return 2 ; }
String fileName1 , String fileName2 , final boolean normalized , IOCase caseSensitivity ) { if ( fileName1 == null || fileName2 == null ) { return fileName1 == null && fileName2 == null ; MST[rv.CRCR6Mutator]MSP[N] } if ( normalized ) { fileName1 = normalize ( fileName1 ) ;
return isSeparator ( ch0 ) ? 1 : 0 ; } if ( ch0 == '~' ) { int posUnix = fileName . indexOf ( UNIX_SEPARATOR , 1 ) ; MST[InlineConstantMutator]MSP[N] int posWin = fileName . indexOf ( WINDOWS_SEPARATOR , 1 ) ;
if ( index == NOT_FOUND ) { return fileName ; } return fileName . substring ( 0 , index ) ; MST[rv.UOI3Mutator]MSP[N] } public static boolean equals ( final String fileName1 , final String fileName2 ) { return equals ( fileName1 , fileName2 , false , IOCase . SENSITIVE ) ;
if ( octet . length () == 0 ) { emptyOctets ++ ; if ( emptyOctets > 1 ) { return false ; } } else { emptyOctets = 0 ; if ( index == octets . length - 1 && octet . contains ( lr_12 ) ) { MST[rv.ROR2Mutator]MSP[S]
if ( size <= prefix ) { return new String ( array , 0 , size ) ; } if ( lastIsDirectory && keepSeparator ) { MST[rv.ROR5Mutator]MSP[N] return new String ( array , 0 , size ) ; }
public static boolean isExtension ( final String fileName , final String ... extensions ) { if ( fileName == null ) { return false ; } failIfNullBytePresent ( fileName ) ; if ( extensions == null || extensions . length == 0 ) { MST[NegateConditionalsMutator]MSP[N]
final int pos = Math . min ( posUnix , posWin ) + 1 ; MST[MathMutator]MSP[N] final String hostnamePart = fileName . substring ( 2 , pos - 1 ) ; return isValidHostName ( hostnamePart ) ? pos : NOT_FOUND ; } else {
return wildcardMatch ( fileName , wildcardMatcher , IOCase . SYSTEM ) ; } public static boolean wildcardMatch ( final String fileName , final String wildcardMatcher , IOCase caseSensitivity ) { if ( fileName == null && wildcardMatcher == null ) { return true ; MST[rv.CRCR5Mutator]MSP[N] }
if ( ipSegment . length () > 1 && ipSegment . startsWith ( lr_8 ) ) { MST[rv.ROR5Mutator]MSP[S] return false ; } } return true ; } private static boolean isIPv6Address ( final String inet6Address ) { final boolean containsCompressedZeroes = inet6Address . contains ( lr_9 ) ;
if ( array [ i ] == separator && array [ i - 1 ] == separator ) { System . arraycopy ( array , i , array , i - 1 , size - i ) ; MST[rv.AOR2Mutator]MSP[N] size -- ; i -- ; } }
textIdx = array [ 1 ] ; anyChars = true ; } while ( wcsIdx < wcs . length ) { if ( wcs [ wcsIdx ] . equals ( lr_6 ) ) { textIdx ++ ; if ( textIdx > fileName . length () ) { MST[ConditionalsBoundaryMutator]MSP[N] break; }
for ( int i = prefix + 1 ; i < size ; i ++ ) { if ( array [ i ] == separator && array [ i - 1 ] == '.' && MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
final char ch1 = fileName . charAt ( 1 ) ; if ( ch1 == ':' ) { ch0 = Character . toUpperCase ( ch0 ) ; MST[rv.UOI4Mutator]MSP[N] if ( ch0 >= 'A' && ch0 <= 'Z' ) {
if ( path . charAt ( i ) == 0 ) { MST[rv.UOI1Mutator]MSP[N] throw new IllegalArgumentException ( lr_3 + lr_4 ) ; } } } public static String getBaseName ( final String fileName ) { return removeExtension ( getName ( fileName ) ) ; }
static boolean isSystemWindows () { return SYSTEM_SEPARATOR == WINDOWS_SEPARATOR ; } private static boolean isSeparator ( final char ch ) { return ch == UNIX_SEPARATOR || ch == WINDOWS_SEPARATOR ; MST[rv.ROR2Mutator]MSP[N] } public static String normalize ( final String fileName ) {
static boolean isSystemWindows () { return SYSTEM_SEPARATOR == WINDOWS_SEPARATOR ; } private static boolean isSeparator ( final char ch ) { return ch == UNIX_SEPARATOR || ch == WINDOWS_SEPARATOR ; MST[rv.ROR1Mutator]MSP[N] } public static String normalize ( final String fileName ) {
final int lastSeparator = indexOfLastSeparator ( fileName ) ; return lastSeparator > extensionPos ? NOT_FOUND : extensionPos ; MST[rv.UOI4Mutator]MSP[N] } public static String getPrefix ( final String fileName ) { if ( fileName == null ) { return null ; } final int len = getPrefixLength ( fileName ) ;
if ( i == prefix + 2 ) { return null ; } if ( i == size - 1 ) { lastIsDirectory = true ; MST[rv.CRCR2Mutator]MSP[S] } int j ; for ( j = i - 4 ; j >= prefix ; j -- ) {
return indexOfExtension ( fileName ) == NOT_FOUND ; MST[rv.CRCR6Mutator]MSP[N] } final String fileExt = getExtension ( fileName ) ; for ( final String extension : extensions ) { if ( fileExt . equals ( extension ) ) { return true ; } } return false ; }
if ( array [ i ] == separator && array [ i - 1 ] == '.' && array [ i - 2 ] == '.' && MST[rv.ABSMutator]MSP[N] ( i == prefix + 2 || array [ i - 3 ] == separator ) ) {
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2 ) { return NOT_FOUND ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ; MST[NegateConditionalsMutator]MSP[N]
if ( array [ i ] == separator && array [ i - 1 ] == separator ) { System . arraycopy ( array , i , array , i - 1 , size - i ) ; MST[rv.UOI2Mutator]MSP[N] size -- ; i -- ; } }
if ( array [ i ] == separator && array [ i - 1 ] == '.' && array [ i - 2 ] == '.' && MST[rv.ROR2Mutator]MSP[N] ( i == prefix + 2 || array [ i - 3 ] == separator ) ) {
if ( array [ j ] == separator ) { System . arraycopy ( array , i + 1 , array , j + 1 , size - i ) ; size -= i - j ; i = j + 1 ; MST[rv.AOD2Mutator]MSP[N] continue outer; } }
final int index = indexOfLastSeparator ( fileName ) ; if ( index < 0 ) { return fileName . substring ( 0 , prefix ) ; } int end = index + ( includeSeparator ? 1 : 0 ) ; if ( end == 0 ) { MST[rv.UOI2Mutator]MSP[N] end ++ ;
if ( path == null || path . indexOf ( WINDOWS_SEPARATOR ) == NOT_FOUND ) { MST[rv.CRCR6Mutator]MSP[N] return path ; } return path . replace ( WINDOWS_SEPARATOR , UNIX_SEPARATOR ) ; } public static String separatorsToWindows ( final String path ) {
if ( array [ i ] == separator && array [ i - 1 ] == separator ) { System . arraycopy ( array , i , array , i - 1 , size - i ) ; MST[rv.AOR3Mutator]MSP[N] size -- ; i -- ; } }
if ( array [ i ] == separator && array [ i - 1 ] == separator ) { System . arraycopy ( array , i , array , i - 1 , size - i ) ; MST[rv.UOI3Mutator]MSP[N] size -- ; i -- ; } }
if ( ch == '?' || ch == '*' ) { MST[rv.UOI2Mutator]MSP[N] if ( buffer . length () != 0 ) { list . add ( buffer . toString () ) ; buffer . setLength ( 0 ) ; } if ( ch == '?' ) {
if ( ch == '?' || ch == '*' ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] if ( buffer . length () != 0 ) { list . add ( buffer . toString () ) ; buffer . setLength ( 0 ) ; } if ( ch == '?' ) {
if ( len == 0 ) { return 0 ; } char ch0 = fileName . charAt ( 0 ) ; if ( ch0 == ':' ) { return NOT_FOUND ; } if ( len == 1 ) { MST[rv.ROR3Mutator]MSP[S] if ( ch0 == '~' ) { return 2 ; }
final int pos = Math . min ( posUnix , posWin ) + 1 ; final String hostnamePart = fileName . substring ( 2 , pos - 1 ) ; MST[rv.AOD1Mutator]MSP[N] return isValidHostName ( hostnamePart ) ? pos : NOT_FOUND ; } else {
private static boolean isIPv4Address ( final String name ) { final Matcher m = IPV4_PATTERN . matcher ( name ) ; if ( ! m . matches () || m . groupCount () != 4 ) { MST[rv.ROR1Mutator]MSP[N] return false ; }
if ( octet . length () == 0 ) { emptyOctets ++ ; if ( emptyOctets > 1 ) { MST[rv.ROR2Mutator]MSP[N] return false ; } } else { emptyOctets = 0 ; if ( index == octets . length - 1 && octet . contains ( lr_12 ) ) {
public static boolean isExtension ( final String fileName , final Collection < String > extensions ) { if ( fileName == null ) { return false ; MST[rv.CRCR6Mutator]MSP[N] } failIfNullBytePresent ( fileName ) ; if ( extensions == null || extensions . isEmpty () ) {
return equals ( fileName1 , fileName2 , true , IOCase . SENSITIVE ) ; MST[rv.CRCR2Mutator]MSP[S] } public static boolean equalsNormalizedOnSystem ( final String fileName1 , final String fileName2 ) { return equals ( fileName1 , fileName2 , true , IOCase . SYSTEM ) ; } public static boolean equals (
final int pos = Math . min ( posUnix , posWin ) + 1 ; final String hostnamePart = fileName . substring ( 2 , pos - 1 ) ; return isValidHostName ( hostnamePart ) ? pos : NOT_FOUND ; MST[rv.UOI2Mutator]MSP[N] } else {
System . arraycopy ( array , i + 1 , array , prefix , size - i ) ; size -= i + 1 - prefix ; i = prefix + 1 ; MST[InlineConstantMutator]MSP[N] } } if ( size <= 0 ) { return EMPTY_STRING ; }
if ( i == prefix + 2 ) { return null ; } if ( i == size - 1 ) { MST[rv.CRCR6Mutator]MSP[S] lastIsDirectory = true ; } int j ; for ( j = i - 4 ; j >= prefix ; j -- ) {
if ( i == prefix + 2 ) { MST[rv.CRCR2Mutator]MSP[N] return null ; } if ( i == size - 1 ) { lastIsDirectory = true ; } int j ; for ( j = i - 4 ; j >= prefix ; j -- ) {
return new String ( array , 0 , size - 1 ) ; MST[rv.ABSMutator]MSP[N] } public static String concat ( final String basePath , final String fullFileNameToAdd ) { final int prefix = getPrefixLength ( fullFileNameToAdd ) ; if ( prefix < 0 ) { return null ; }
return doNormalize ( fileName , SYSTEM_SEPARATOR , true ) ; } public static String normalize ( final String fileName , final boolean unixSeparator ) { final char separator = unixSeparator ? UNIX_SEPARATOR : WINDOWS_SEPARATOR ; MST[rv.ROR1Mutator]MSP[N] return doNormalize ( fileName , separator , true ) ; }
if ( array [ j ] == separator ) { System . arraycopy ( array , i + 1 , array , j + 1 , size - i ) ; size -= i - j ; MST[rv.AOR3Mutator]MSP[N] i = j + 1 ; continue outer; } }
if ( array [ i ] == separator && array [ i - 1 ] == separator ) { System . arraycopy ( array , i , array , i - 1 , size - i ) ; size -- ; i -- ; MST[experimental.RemoveIncrementsMutator]MSP[N] } }
if ( len == 0 ) { return 0 ; } char ch0 = fileName . charAt ( 0 ) ; if ( ch0 == ':' ) { return NOT_FOUND ; } if ( len == 1 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] if ( ch0 == '~' ) { return 2 ; }
if ( fileName == null || wildcardMatcher == null ) { return false ; MST[rv.CRCR3Mutator]MSP[N] } if ( caseSensitivity == null ) { caseSensitivity = IOCase . SENSITIVE ; } final String [] wcs = splitOnTokens ( wildcardMatcher ) ; boolean anyChars = false ; int textIdx = 0 ;
if ( len < 0 ) { return null ; } if ( len > fileName . length () ) { failIfNullBytePresent ( fileName + UNIX_SEPARATOR ) ; return fileName + UNIX_SEPARATOR ; } final String path = fileName . substring ( 0 , len ) ; MST[experimental.NakedReceiverMutator]MSP[N]
return indexOfExtension ( fileName ) == NOT_FOUND ; } final String fileExt = getExtension ( fileName ) ; for ( final String extension : extensions ) { if ( fileExt . equals ( extension ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return true ; } } return false ; }
if ( array [ i ] == separator && array [ i - 1 ] == '.' && array [ i - 2 ] == '.' && MST[rv.ROR3Mutator]MSP[S] ( i == prefix + 2 || array [ i - 3 ] == separator ) ) {
final int pos = Math . min ( posUnix , posWin ) + 1 ; MST[rv.UOI1Mutator]MSP[N] final String hostnamePart = fileName . substring ( 2 , pos - 1 ) ; return isValidHostName ( hostnamePart ) ? pos : NOT_FOUND ; } else {
if ( extension == null || extension . isEmpty () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return indexOfExtension ( fileName ) == NOT_FOUND ; } final String fileExt = getExtension ( fileName ) ; return fileExt . equals ( extension ) ; }
return isSeparator ( ch0 ) ? 1 : 0 ; } if ( ch0 == '~' ) { int posUnix = fileName . indexOf ( UNIX_SEPARATOR , 1 ) ; int posWin = fileName . indexOf ( WINDOWS_SEPARATOR , 1 ) ; MST[rv.CRCR5Mutator]MSP[N]
textIdx = array [ 1 ] ; anyChars = true ; } while ( wcsIdx < wcs . length ) { MST[ConditionalsBoundaryMutator]MSP[N] if ( wcs [ wcsIdx ] . equals ( lr_6 ) ) { textIdx ++ ; if ( textIdx > fileName . length () ) { break; }
if ( octet . length () == 0 ) { MST[rv.ROR5Mutator]MSP[N] emptyOctets ++ ; if ( emptyOctets > 1 ) { return false ; } } else { emptyOctets = 0 ; if ( index == octets . length - 1 && octet . contains ( lr_12 ) ) {
if ( octets . length > IPV6_MAX_HEX_GROUPS ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] return false ; } int validOctets = 0 ; int emptyOctets = 0 ; for ( int index = 0 ; index < octets . length ; index ++ ) { final String octet = octets [ index ] ;
if ( array [ i ] == separator && array [ i - 1 ] == separator ) { System . arraycopy ( array , i , array , i - 1 , size - i ) ; MST[rv.UOI1Mutator]MSP[N] size -- ; i -- ; } }
if ( array [ i ] == separator && array [ i - 1 ] == '.' && array [ i - 2 ] == '.' && MST[NegateConditionalsMutator]MSP[N] ( i == prefix + 2 || array [ i - 3 ] == separator ) ) {
if ( array [ j ] == separator ) { System . arraycopy ( array , i + 1 , array , j + 1 , size - i ) ; size -= i - j ; MST[rv.UOI3Mutator]MSP[N] i = j + 1 ; continue outer; } }
if ( prefix > 0 ) { return normalize ( fullFileNameToAdd ) ; MST[ReturnValsMutator]MSP[N] } if ( basePath == null ) { return null ; } final int len = basePath . length () ; if ( len == 0 ) { return normalize ( fullFileNameToAdd ) ; }
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND ) { return len + 1 ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ; return Math . min ( posUnix , posWin ) + 1 ; MST[rv.UOI3Mutator]MSP[N] }
public static String normalizeNoEndSeparator ( final String fileName ) { return doNormalize ( fileName , SYSTEM_SEPARATOR , false ) ; MST[ReturnValsMutator]MSP[N] } public static String normalizeNoEndSeparator ( final String fileName , final boolean unixSeparator ) { final char separator = unixSeparator ? UNIX_SEPARATOR : WINDOWS_SEPARATOR ;
anyChars = false ; } else if ( wcs [ wcsIdx ] . equals ( lr_7 ) ) { anyChars = true ; if ( wcsIdx == wcs . length - 1 ) { MST[NegateConditionalsMutator]MSP[N] textIdx = fileName . length () ; } } else { if ( anyChars ) {
return fileName . substring ( index + 1 ) ; } private static void failIfNullBytePresent ( final String path ) { final int len = path . length () ; for ( int i = 0 ; i < len ; i ++ ) { MST[rv.CRCR1Mutator]MSP[N]
if ( fileName == null || wildcardMatcher == null ) { return false ; } if ( caseSensitivity == null ) { caseSensitivity = IOCase . SENSITIVE ; } final String [] wcs = splitOnTokens ( wildcardMatcher ) ; boolean anyChars = false ; int textIdx = 0 ; MST[rv.CRCR5Mutator]MSP[N]
public static String getFullPathNoEndSeparator ( final String fileName ) { return doGetFullPath ( fileName , false ) ; MST[NonVoidMethodCallMutator]MSP[N] } private static String doGetFullPath ( final String fileName , final boolean includeSeparator ) { if ( fileName == null ) { return null ; }
if ( ! isIPv4Address ( octet ) ) { return false ; } validOctets += 2 ; continue; } if ( octet . length () > IPV6_MAX_HEX_DIGITS_PER_GROUP ) { return false ; MST[rv.CRCR3Mutator]MSP[N] } int octetInt = 0 ; try {
return indexOfExtension ( fileName ) == NOT_FOUND ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] } final String fileExt = getExtension ( fileName ) ; for ( final String extension : extensions ) { if ( fileExt . equals ( extension ) ) { return true ; } } return false ; }
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND ) { MST[rv.ROR2Mutator]MSP[N] return len + 1 ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ; return Math . min ( posUnix , posWin ) + 1 ; }
if ( repeat >= 0 ) { MST[ConditionalsBoundaryMutator]MSP[N] backtrack . push ( new int [] { wcsIdx , repeat } ) ; } } else { if ( ! caseSensitivity . checkRegionMatches ( fileName , textIdx , wcs [ wcsIdx ] ) ) { break; } }
if ( octets . length > IPV6_MAX_HEX_GROUPS ) { MST[rv.ROR2Mutator]MSP[N] return false ; } int validOctets = 0 ; int emptyOctets = 0 ; for ( int index = 0 ; index < octets . length ; index ++ ) { final String octet = octets [ index ] ;
for ( int i = prefix + 1 ; i < size ; i ++ ) { if ( array [ i ] == separator && array [ i - 1 ] == '.' && MST[rv.UOI3Mutator]MSP[N]
final int pos = Math . min ( posUnix , posWin ) + 1 ; final String hostnamePart = fileName . substring ( 2 , pos - 1 ) ; return isValidHostName ( hostnamePart ) ? pos : NOT_FOUND ; MST[rv.ABSMutator]MSP[N] } else {
if ( ipSegment . length () > 1 && ipSegment . startsWith ( lr_8 ) ) { return false ; } } return true ; MST[ReturnValsMutator]MSP[S] } private static boolean isIPv6Address ( final String inet6Address ) { final boolean containsCompressedZeroes = inet6Address . contains ( lr_9 ) ;
if ( path == null || path . indexOf ( UNIX_SEPARATOR ) == NOT_FOUND ) { return path ; } return path . replace ( UNIX_SEPARATOR , WINDOWS_SEPARATOR ) ; MST[rv.CRCR6Mutator]MSP[N] } public static String separatorsToSystem ( final String path ) { if ( path == null ) {
final char ch = basePath . charAt ( len - 1 ) ; MST[rv.CRCR4Mutator]MSP[N] if ( isSeparator ( ch ) ) { return normalize ( basePath + fullFileNameToAdd ) ; } return normalize ( basePath + '/' + fullFileNameToAdd ) ; }
final int prefix = getPrefixLength ( fileName ) ; if ( prefix < 0 ) { return null ; } if ( prefix >= fileName . length () ) { MST[NegateConditionalsMutator]MSP[N] if ( includeSeparator ) { return getPrefix ( fileName ) ; } return fileName ; }
if ( extension == null || extension . isEmpty () ) { MST[rv.ROR4Mutator]MSP[N] return indexOfExtension ( fileName ) == NOT_FOUND ; } final String fileExt = getExtension ( fileName ) ; return fileExt . equals ( extension ) ; }
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2 ) { return NOT_FOUND ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ; MST[rv.CRCR6Mutator]MSP[N]
textIdx = array [ 1 ] ; anyChars = true ; } while ( wcsIdx < wcs . length ) { MST[rv.ROR5Mutator]MSP[N] if ( wcs [ wcsIdx ] . equals ( lr_6 ) ) { textIdx ++ ; if ( textIdx > fileName . length () ) { break; }
list . add ( buffer . toString () ) ; } return list . toArray ( new String [ list . size () ] ) ; } private static boolean isValidHostName ( final String name ) { return isIPv6Address ( name ) || isRFC3986HostName ( name ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] }
return indexOfExtension ( fileName ) == NOT_FOUND ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } final String fileExt = getExtension ( fileName ) ; for ( final String extension : extensions ) { if ( fileExt . equals ( extension ) ) { return true ; } } return false ; }
if ( array [ j ] == separator ) { MST[rv.ABSMutator]MSP[N] System . arraycopy ( array , i + 1 , array , j + 1 , size - i ) ; size -= i - j ; i = j + 1 ; continue outer; } }
public static String normalizeNoEndSeparator ( final String fileName ) { return doNormalize ( fileName , SYSTEM_SEPARATOR , false ) ; MST[rv.CRCR5Mutator]MSP[S] } public static String normalizeNoEndSeparator ( final String fileName , final boolean unixSeparator ) { final char separator = unixSeparator ? UNIX_SEPARATOR : WINDOWS_SEPARATOR ;
final char [] array = text . toCharArray () ; final ArrayList < String > list = new ArrayList <> () ; final StringBuilder buffer = new StringBuilder () ; char prevChar = 0 ; for ( final char ch : array ) { MST[rv.UOI3Mutator]MSP[N]
fileName2 = normalize ( fileName2 ) ; if ( fileName1 == null || fileName2 == null ) { MST[NegateConditionalsMutator]MSP[N] throw new NullPointerException ( lr_5 ) ; } } if ( caseSensitivity == null ) { caseSensitivity = IOCase . SENSITIVE ; }
if ( array [ j ] == separator ) { System . arraycopy ( array , i + 1 , array , j + 1 , size - i ) ; size -= i - j ; MST[rv.UOI3Mutator]MSP[N] i = j + 1 ; continue outer; } }
final char ch1 = fileName . charAt ( 1 ) ; if ( ch1 == ':' ) { MST[rv.CRCR3Mutator]MSP[N] ch0 = Character . toUpperCase ( ch0 ) ; if ( ch0 >= 'A' && ch0 <= 'Z' ) {
if ( len < 0 ) { return null ; } if ( len > fileName . length () ) { failIfNullBytePresent ( fileName + UNIX_SEPARATOR ) ; MST[ConstructorCallMutator]MSP[N] return fileName + UNIX_SEPARATOR ; } final String path = fileName . substring ( 0 , len ) ;
textIdx += wcs [ wcsIdx ] . length () ; anyChars = false ; MST[InlineConstantMutator]MSP[N] } wcsIdx ++ ; } if ( wcsIdx == wcs . length && textIdx == fileName . length () ) { return true ; } } while ( backtrack . size () > 0 );
final int index = indexOfLastSeparator ( fileName ) ; if ( index < 0 ) { return fileName . substring ( 0 , prefix ) ; } int end = index + ( includeSeparator ? 1 : 0 ) ; if ( end == 0 ) { end ++ ; MST[IncrementsMutator]MSP[S]
anyChars = false ; } else if ( wcs [ wcsIdx ] . equals ( lr_7 ) ) { anyChars = true ; if ( wcsIdx == wcs . length - 1 ) { MST[rv.AOR4Mutator]MSP[N] textIdx = fileName . length () ; } } else { if ( anyChars ) {
list . add ( lr_6 ) ; } else if ( prevChar != '*' ) { list . add ( lr_7 ) ; } } else { buffer . append ( ch ) ; MST[experimental.NakedReceiverMutator]MSP[N] } prevChar = ch ; } if ( buffer . length () != 0 ) {
public static boolean isExtension ( final String fileName , final Collection < String > extensions ) { if ( fileName == null ) { return false ; } failIfNullBytePresent ( fileName ) ; if ( extensions == null || extensions . isEmpty () ) { MST[NegateConditionalsMutator]MSP[N]
static boolean isSystemWindows () { return SYSTEM_SEPARATOR == WINDOWS_SEPARATOR ; } private static boolean isSeparator ( final char ch ) { return ch == UNIX_SEPARATOR || ch == WINDOWS_SEPARATOR ; MST[rv.ROR4Mutator]MSP[N] } public static String normalize ( final String fileName ) {
} return fileName . substring ( 0 , end ) ; MST[experimental.NakedReceiverMutator]MSP[N] } public static String getName ( final String fileName ) { if ( fileName == null ) { return null ; } failIfNullBytePresent ( fileName ) ; final int index = indexOfLastSeparator ( fileName ) ;
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND ) { MST[rv.ROR3Mutator]MSP[N] return len + 1 ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ; return Math . min ( posUnix , posWin ) + 1 ; }
if ( len == 2 || isSeparator ( fileName . charAt ( 2 ) ) == false ) { MST[rv.ROR4Mutator]MSP[N] return 2 ; } return 3 ; } else if ( ch0 == UNIX_SEPARATOR ) { return 1 ; } return NOT_FOUND ;
if ( array [ i ] == separator && array [ i - 1 ] == separator ) { MST[rv.ABSMutator]MSP[N] System . arraycopy ( array , i , array , i - 1 , size - i ) ; size -- ; i -- ; } }
public static boolean isExtension ( final String fileName , final Collection < String > extensions ) { if ( fileName == null ) { MST[rv.ROR5Mutator]MSP[N] return false ; } failIfNullBytePresent ( fileName ) ; if ( extensions == null || extensions . isEmpty () ) {
if ( fileName == null || wildcardMatcher == null ) { return false ; MST[BooleanTrueReturnValsMutator]MSP[N] } if ( caseSensitivity == null ) { caseSensitivity = IOCase . SENSITIVE ; } final String [] wcs = splitOnTokens ( wildcardMatcher ) ; boolean anyChars = false ; int textIdx = 0 ;
for ( int i = 1 ; i <= 4 ; i ++ ) { MST[rv.CRCR5Mutator]MSP[N] final String ipSegment = m . group ( i ) ; final int iIpSegment = Integer . parseInt ( ipSegment ) ; if ( iIpSegment > IPV4_MAX_OCTET_VALUE ) { return false ; }
|| ( inet6Address . endsWith ( lr_10 ) && ! inet6Address . endsWith ( lr_9 ) ) ) { return false ; } String [] octets = inet6Address . split ( lr_10 ) ; if ( containsCompressedZeroes ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
list . add ( buffer . toString () ) ; } return list . toArray ( new String [ list . size () ] ) ; } private static boolean isValidHostName ( final String name ) { return isIPv6Address ( name ) || isRFC3986HostName ( name ) ; MST[ReturnValsMutator]MSP[N] }
if ( IOCase . SYSTEM . checkEquals ( canonicalParent , canonicalChild ) ) { return false ; MST[InlineConstantMutator]MSP[S] } return IOCase . SYSTEM . checkStartsWith ( canonicalChild , canonicalParent ) ; } public static String separatorsToUnix ( final String path ) {
for ( int i = prefix + 1 ; i < size ; i ++ ) { if ( array [ i ] == separator && array [ i - 1 ] == '.' && MST[rv.ROR3Mutator]MSP[N]
textIdx = array [ 1 ] ; anyChars = true ; } while ( wcsIdx < wcs . length ) { if ( wcs [ wcsIdx ] . equals ( lr_6 ) ) { textIdx ++ ; if ( textIdx > fileName . length () ) { MST[rv.ROR5Mutator]MSP[N] break; }
for ( int i = prefix + 1 ; i < size ; i ++ ) { if ( array [ i ] == separator && array [ i - 1 ] == '.' && MST[rv.UOI2Mutator]MSP[N]
for ( int i = 0 ; i < parts . length ; i ++ ) { if ( parts [ i ] . length () == 0 ) { return i == parts . length - 1 ; MST[BooleanTrueReturnValsMutator]MSP[N] }
if ( validOctets > IPV6_MAX_HEX_GROUPS || ( validOctets < IPV6_MAX_HEX_GROUPS && ! containsCompressedZeroes ) ) { MST[rv.ROR2Mutator]MSP[N] return false ; } return true ; } private static boolean isRFC3986HostName ( final String name ) { final String [] parts = name . split ( lr_13 , - 1 ) ;
|| ( inet6Address . endsWith ( lr_10 ) && ! inet6Address . endsWith ( lr_9 ) ) ) { return false ; } String [] octets = inet6Address . split ( lr_10 ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( containsCompressedZeroes ) {
private static boolean isIPv4Address ( final String name ) { final Matcher m = IPV4_PATTERN . matcher ( name ) ; if ( ! m . matches () || m . groupCount () != 4 ) { return false ; MST[BooleanTrueReturnValsMutator]MSP[N] }
System . arraycopy ( array , i + 1 , array , prefix , size - i ) ; size -= i + 1 - prefix ; MST[rv.UOI3Mutator]MSP[N] i = prefix + 1 ; } } if ( size <= 0 ) { return EMPTY_STRING ; }
System . arraycopy ( array , i + 1 , array , prefix , size - i ) ; size -= i + 1 - prefix ; MST[rv.UOI4Mutator]MSP[N] i = prefix + 1 ; } } if ( size <= 0 ) { return EMPTY_STRING ; }
anyChars = false ; } else if ( wcs [ wcsIdx ] . equals ( lr_7 ) ) { anyChars = true ; if ( wcsIdx == wcs . length - 1 ) { MST[rv.AOD2Mutator]MSP[N] textIdx = fileName . length () ; } } else { if ( anyChars ) {
if ( len < 0 ) { return null ; } if ( len > fileName . length () ) { failIfNullBytePresent ( fileName + UNIX_SEPARATOR ) ; return fileName + UNIX_SEPARATOR ; MST[rv.CRCR3Mutator]MSP[N] } final String path = fileName . substring ( 0 , len ) ;
if ( repeat >= 0 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] backtrack . push ( new int [] { wcsIdx , repeat } ) ; } } else { if ( ! caseSensitivity . checkRegionMatches ( fileName , textIdx , wcs [ wcsIdx ] ) ) { break; } }
if ( repeat >= 0 ) { backtrack . push ( new int [] { wcsIdx , repeat } ) ; } } else { if ( ! caseSensitivity . checkRegionMatches ( fileName , textIdx , wcs [ wcsIdx ] ) ) { MST[rv.UOI2Mutator]MSP[N] break; } }
if ( len == 2 || isSeparator ( fileName . charAt ( 2 ) ) == false ) { return 2 ; } return 3 ; } else if ( ch0 == UNIX_SEPARATOR ) { MST[rv.UOI4Mutator]MSP[N] return 1 ; } return NOT_FOUND ;
textIdx = caseSensitivity . checkIndexOf ( fileName , textIdx , wcs [ wcsIdx ] ) ; if ( textIdx == NOT_FOUND ) { MST[rv.CRCR2Mutator]MSP[S] break; } final int repeat = caseSensitivity . checkIndexOf ( fileName , textIdx + 1 , wcs [ wcsIdx ] ) ;
if ( len < 0 ) { return null ; } if ( len > fileName . length () ) { failIfNullBytePresent ( fileName + UNIX_SEPARATOR ) ; return fileName + UNIX_SEPARATOR ; MST[InlineConstantMutator]MSP[N] } final String path = fileName . substring ( 0 , len ) ;
if ( i == prefix + 2 ) { MST[rv.UOI1Mutator]MSP[N] return null ; } if ( i == size - 1 ) { lastIsDirectory = true ; } int j ; for ( j = i - 4 ; j >= prefix ; j -- ) {
if ( i == prefix + 2 ) { return null ; } if ( i == size - 1 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] lastIsDirectory = true ; } int j ; for ( j = i - 4 ; j >= prefix ; j -- ) {
return isSeparator ( ch0 ) ? 1 : 0 ; MST[rv.UOI4Mutator]MSP[N] } if ( ch0 == '~' ) { int posUnix = fileName . indexOf ( UNIX_SEPARATOR , 1 ) ; int posWin = fileName . indexOf ( WINDOWS_SEPARATOR , 1 ) ;
if ( path == null || path . indexOf ( WINDOWS_SEPARATOR ) == NOT_FOUND ) { return path ; MST[ReturnValsMutator]MSP[N] } return path . replace ( WINDOWS_SEPARATOR , UNIX_SEPARATOR ) ; } public static String separatorsToWindows ( final String path ) {
return indexOfExtension ( fileName ) == NOT_FOUND ; } final String fileExt = getExtension ( fileName ) ; for ( final String extension : extensions ) { if ( fileExt . equals ( extension ) ) { return true ; } } return false ; MST[rv.CRCR5Mutator]MSP[N] }
final int pos = Math . min ( posUnix , posWin ) + 1 ; MST[rv.AOR3Mutator]MSP[N] final String hostnamePart = fileName . substring ( 2 , pos - 1 ) ; return isValidHostName ( hostnamePart ) ? pos : NOT_FOUND ; } else {
return doNormalize ( fileName , SYSTEM_SEPARATOR , true ) ; MST[EmptyObjectReturnValsMutator]MSP[N] } public static String normalize ( final String fileName , final boolean unixSeparator ) { final char separator = unixSeparator ? UNIX_SEPARATOR : WINDOWS_SEPARATOR ; return doNormalize ( fileName , separator , true ) ; }
for ( int i = 0 ; i < array . length ; i ++ ) { MST[rv.CRCR6Mutator]MSP[N] if ( array [ i ] == otherSeparator ) { array [ i ] = separator ; } } boolean lastIsDirectory = true ;
if ( ipSegment . length () > 1 && ipSegment . startsWith ( lr_8 ) ) { MST[rv.ROR2Mutator]MSP[S] return false ; } } return true ; } private static boolean isIPv6Address ( final String inet6Address ) { final boolean containsCompressedZeroes = inet6Address . contains ( lr_9 ) ;
final int index = indexOfLastSeparator ( fileName ) ; final int endIndex = index + separatorAdd ; if ( prefix >= fileName . length () || index < 0 || prefix >= endIndex ) { MST[rv.ROR2Mutator]MSP[N] return EMPTY_STRING ; }
String fileName1 , String fileName2 , final boolean normalized , IOCase caseSensitivity ) { if ( fileName1 == null || fileName2 == null ) { MST[NegateConditionalsMutator]MSP[N] return fileName1 == null && fileName2 == null ; } if ( normalized ) { fileName1 = normalize ( fileName1 ) ;
if ( ! REG_NAME_PART_PATTERN . matcher ( parts [ i ] ) . matches () ) { return false ; } } return true ; MST[BooleanFalseReturnValsMutator]MSP[N] }
if ( array [ size - 1 ] != separator ) { array [ size ++ ] = separator ; MST[rv.UOI1Mutator]MSP[N] lastIsDirectory = false ; } for ( int i = prefix + 1 ; i < size ; i ++ ) {
return new String ( array , 0 , size - 1 ) ; MST[rv.AOD2Mutator]MSP[N] } public static String concat ( final String basePath , final String fullFileNameToAdd ) { final int prefix = getPrefixLength ( fullFileNameToAdd ) ; if ( prefix < 0 ) { return null ; }
return wildcardMatch ( fileName , wildcardMatcher , IOCase . SYSTEM ) ; } public static boolean wildcardMatch ( final String fileName , final String wildcardMatcher , IOCase caseSensitivity ) { if ( fileName == null && wildcardMatcher == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return true ; }
if ( len == 2 || isSeparator ( fileName . charAt ( 2 ) ) == false ) { return 2 ; } return 3 ; } else if ( ch0 == UNIX_SEPARATOR ) { return 1 ; MST[rv.CRCR6Mutator]MSP[S] } return NOT_FOUND ;
if ( fileName == null || wildcardMatcher == null ) { return false ; } if ( caseSensitivity == null ) { caseSensitivity = IOCase . SENSITIVE ; } final String [] wcs = splitOnTokens ( wildcardMatcher ) ; MST[NonVoidMethodCallMutator]MSP[N] boolean anyChars = false ; int textIdx = 0 ;
for ( int i = prefix + 1 ; i < size ; i ++ ) { if ( array [ i ] == separator && array [ i - 1 ] == '.' && MST[rv.ABSMutator]MSP[N]
|| ( inet6Address . endsWith ( lr_10 ) && ! inet6Address . endsWith ( lr_9 ) ) ) { return false ; } String [] octets = inet6Address . split ( lr_10 ) ; if ( containsCompressedZeroes ) { MST[rv.ROR1Mutator]MSP[N]
if ( octet . length () == 0 ) { emptyOctets ++ ; if ( emptyOctets > 1 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] return false ; } } else { emptyOctets = 0 ; if ( index == octets . length - 1 && octet . contains ( lr_12 ) ) {
System . arraycopy ( array , i + 1 , array , i - 1 , size - i ) ; size -= 2 ; i -- ; MST[experimental.RemoveIncrementsMutator]MSP[N] } } outer: for ( int i = prefix + 2 ; i < size ; i ++ ) {
final int prefix = getPrefixLength ( fileName ) ; if ( prefix < 0 ) { return null ; } if ( prefix >= fileName . length () ) { if ( includeSeparator ) { MST[rv.UOI1Mutator]MSP[N] return getPrefix ( fileName ) ; } return fileName ; }
return isSeparator ( ch0 ) ? 1 : 0 ; } } public static int indexOfLastSeparator ( final String fileName ) { if ( fileName == null ) { return NOT_FOUND ; MST[rv.CRCR6Mutator]MSP[N] } final int lastUnixPos = fileName . lastIndexOf ( UNIX_SEPARATOR ) ;
if ( path == null || path . indexOf ( WINDOWS_SEPARATOR ) == NOT_FOUND ) { return path ; } return path . replace ( WINDOWS_SEPARATOR , UNIX_SEPARATOR ) ; MST[InlineConstantMutator]MSP[N] } public static String separatorsToWindows ( final String path ) {
if ( len == 2 || isSeparator ( fileName . charAt ( 2 ) ) == false ) { return 2 ; } return 3 ; } else if ( ch0 == UNIX_SEPARATOR ) { return 1 ; } return NOT_FOUND ; MST[rv.CRCR2Mutator]MSP[N]
if ( len == 0 ) { MST[rv.UOI2Mutator]MSP[N] return 0 ; } char ch0 = fileName . charAt ( 0 ) ; if ( ch0 == ':' ) { return NOT_FOUND ; } if ( len == 1 ) { if ( ch0 == '~' ) { return 2 ; }
if ( ch == '?' || ch == '*' ) { if ( buffer . length () != 0 ) { list . add ( buffer . toString () ) ; buffer . setLength ( 0 ) ; MST[InlineConstantMutator]MSP[N] } if ( ch == '?' ) {
for ( int i = prefix + 1 ; i < size ; i ++ ) { if ( array [ i ] == separator && array [ i - 1 ] == '.' && MST[NegateConditionalsMutator]MSP[N]
System . arraycopy ( array , i + 1 , array , i - 1 , size - i ) ; MST[rv.CRCR5Mutator]MSP[N] size -= 2 ; i -- ; } } outer: for ( int i = prefix + 2 ; i < size ; i ++ ) {
final char ch1 = fileName . charAt ( 1 ) ; if ( ch1 == ':' ) { MST[InlineConstantMutator]MSP[N] ch0 = Character . toUpperCase ( ch0 ) ; if ( ch0 >= 'A' && ch0 <= 'Z' ) {
anyChars = false ; } else if ( wcs [ wcsIdx ] . equals ( lr_7 ) ) { anyChars = true ; if ( wcsIdx == wcs . length - 1 ) { MST[rv.ROR1Mutator]MSP[N] textIdx = fileName . length () ; } } else { if ( anyChars ) {
for ( int i = 1 ; i <= 4 ; i ++ ) { MST[rv.ABSMutator]MSP[N] final String ipSegment = m . group ( i ) ; final int iIpSegment = Integer . parseInt ( ipSegment ) ; if ( iIpSegment > IPV4_MAX_OCTET_VALUE ) { return false ; }
if ( prefix > 0 ) { MST[rv.ROR4Mutator]MSP[N] return normalize ( fullFileNameToAdd ) ; } if ( basePath == null ) { return null ; } final int len = basePath . length () ; if ( len == 0 ) { return normalize ( fullFileNameToAdd ) ; }
} else if ( isSeparator ( ch0 ) && isSeparator ( ch1 ) ) { MST[rv.UOI1Mutator]MSP[N] int posUnix = fileName . indexOf ( UNIX_SEPARATOR , 2 ) ; int posWin = fileName . indexOf ( WINDOWS_SEPARATOR , 2 ) ;
} else if ( inet6Address . startsWith ( lr_9 ) && ! octetList . isEmpty () ) { octetList . remove ( 0 ) ; MST[rv.CRCR1Mutator]MSP[N] } octets = octetList . toArray ( new String [ octetList . size () ] ) ; }
return false ; } static String [] splitOnTokens ( final String text ) { if ( text . indexOf ( '?' ) == NOT_FOUND && text . indexOf ( '*' ) == NOT_FOUND ) { return new String [] { text } ; MST[ReturnValsMutator]MSP[N] }
System . arraycopy ( array , i + 1 , array , i - 1 , size - i ) ; MST[rv.UOI3Mutator]MSP[N] size -= 2 ; i -- ; } } outer: for ( int i = prefix + 2 ; i < size ; i ++ ) {
if ( validOctets > IPV6_MAX_HEX_GROUPS || ( validOctets < IPV6_MAX_HEX_GROUPS && ! containsCompressedZeroes ) ) { MST[rv.ROR5Mutator]MSP[N] return false ; } return true ; } private static boolean isRFC3986HostName ( final String name ) { final String [] parts = name . split ( lr_13 , - 1 ) ;
if ( ch == '?' || ch == '*' ) { if ( buffer . length () != 0 ) { list . add ( buffer . toString () ) ; buffer . setLength ( 0 ) ; } if ( ch == '?' ) { MST[rv.CRCR3Mutator]MSP[N]
final char [] array = new char [ size + 2 ] ; fileName . getChars ( 0 , fileName . length () , array , 0 ) ; MST[rv.CRCR6Mutator]MSP[N] final char otherSeparator = separator == SYSTEM_SEPARATOR ? OTHER_SEPARATOR : SYSTEM_SEPARATOR ;
for ( int i = prefix + 1 ; i < size ; i ++ ) { if ( array [ i ] == separator && array [ i - 1 ] == '.' && MST[rv.CRCR2Mutator]MSP[N]
if ( validOctets > IPV6_MAX_HEX_GROUPS || ( validOctets < IPV6_MAX_HEX_GROUPS && ! containsCompressedZeroes ) ) { return false ; } return true ; } private static boolean isRFC3986HostName ( final String name ) { final String [] parts = name . split ( lr_13 , - 1 ) ; MST[rv.CRCR6Mutator]MSP[N]
if ( size <= prefix ) { MST[rv.UOI2Mutator]MSP[S] return new String ( array , 0 , size ) ; } if ( lastIsDirectory && keepSeparator ) { return new String ( array , 0 , size ) ; }
anyChars = false ; MST[rv.CRCR3Mutator]MSP[S] } else if ( wcs [ wcsIdx ] . equals ( lr_7 ) ) { anyChars = true ; if ( wcsIdx == wcs . length - 1 ) { textIdx = fileName . length () ; } } else { if ( anyChars ) {
return fileName . substring ( index + 1 ) ; MST[rv.AOD1Mutator]MSP[N] } private static int getAdsCriticalOffset ( final String fileName ) { final int offset1 = fileName . lastIndexOf ( SYSTEM_SEPARATOR ) ; final int offset2 = fileName . lastIndexOf ( OTHER_SEPARATOR ) ;
if ( ch == '?' || ch == '*' ) { if ( buffer . length () != 0 ) { list . add ( buffer . toString () ) ; buffer . setLength ( 0 ) ; } if ( ch == '?' ) { MST[NegateConditionalsMutator]MSP[N]
if ( len == 2 || isSeparator ( fileName . charAt ( 2 ) ) == false ) { return 2 ; MST[rv.CRCR1Mutator]MSP[N] } return 3 ; } else if ( ch0 == UNIX_SEPARATOR ) { return 1 ; } return NOT_FOUND ;
anyChars = false ; } else if ( wcs [ wcsIdx ] . equals ( lr_7 ) ) { anyChars = true ; MST[rv.CRCR2Mutator]MSP[N] if ( wcsIdx == wcs . length - 1 ) { textIdx = fileName . length () ; } } else { if ( anyChars ) {
if ( validOctets > IPV6_MAX_HEX_GROUPS || ( validOctets < IPV6_MAX_HEX_GROUPS && ! containsCompressedZeroes ) ) { return false ; MST[rv.CRCR6Mutator]MSP[S] } return true ; } private static boolean isRFC3986HostName ( final String name ) { final String [] parts = name . split ( lr_13 , - 1 ) ;
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2 ) { MST[rv.UOI3Mutator]MSP[N] return NOT_FOUND ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ;
final char ch = basePath . charAt ( len - 1 ) ; if ( isSeparator ( ch ) ) { return normalize ( basePath + fullFileNameToAdd ) ; } return normalize ( basePath + '/' + fullFileNameToAdd ) ; MST[ConstructorCallMutator]MSP[N] }
|| ( inet6Address . endsWith ( lr_10 ) && ! inet6Address . endsWith ( lr_9 ) ) ) { MST[rv.ROR3Mutator]MSP[N] return false ; } String [] octets = inet6Address . split ( lr_10 ) ; if ( containsCompressedZeroes ) {
final int index = indexOfLastSeparator ( fileName ) ; if ( index < 0 ) { return fileName . substring ( 0 , prefix ) ; } int end = index + ( includeSeparator ? 1 : 0 ) ; MST[rv.CRCR6Mutator]MSP[S] if ( end == 0 ) { end ++ ;
final char [] array = new char [ size + 2 ] ; MST[MathMutator]MSP[N] fileName . getChars ( 0 , fileName . length () , array , 0 ) ; final char otherSeparator = separator == SYSTEM_SEPARATOR ? OTHER_SEPARATOR : SYSTEM_SEPARATOR ;
return fileName . substring ( index + 1 ) ; } private static void failIfNullBytePresent ( final String path ) { final int len = path . length () ; for ( int i = 0 ; i < len ; i ++ ) { MST[rv.ABSMutator]MSP[N]
public static boolean directoryContains ( final String canonicalParent , final String canonicalChild ) throws IOException { if ( canonicalParent == null ) { MST[rv.ROR5Mutator]MSP[N] throw new IllegalArgumentException ( lr_1 ) ; } if ( canonicalChild == null ) { return false ; }
if ( array [ i ] == separator && array [ i - 1 ] == '.' && array [ i - 2 ] == '.' && MST[rv.AOR4Mutator]MSP[N] ( i == prefix + 2 || array [ i - 3 ] == separator ) ) {
if ( i == prefix + 2 ) { return null ; } if ( i == size - 1 ) { MST[rv.ROR1Mutator]MSP[N] lastIsDirectory = true ; } int j ; for ( j = i - 4 ; j >= prefix ; j -- ) {
textIdx = caseSensitivity . checkIndexOf ( fileName , textIdx , wcs [ wcsIdx ] ) ; if ( textIdx == NOT_FOUND ) { MST[rv.ROR4Mutator]MSP[N] break; } final int repeat = caseSensitivity . checkIndexOf ( fileName , textIdx + 1 , wcs [ wcsIdx ] ) ;
final char ch1 = fileName . charAt ( 1 ) ; if ( ch1 == ':' ) { MST[NegateConditionalsMutator]MSP[N] ch0 = Character . toUpperCase ( ch0 ) ; if ( ch0 >= 'A' && ch0 <= 'Z' ) {
final int prefix = getPrefixLength ( fileName ) ; if ( prefix < 0 ) { return null ; } if ( prefix >= fileName . length () ) { MST[rv.UOI2Mutator]MSP[N] if ( includeSeparator ) { return getPrefix ( fileName ) ; } return fileName ; }
|| ( inet6Address . endsWith ( lr_10 ) && ! inet6Address . endsWith ( lr_9 ) ) ) { return false ; } String [] octets = inet6Address . split ( lr_10 ) ; if ( containsCompressedZeroes ) { MST[rv.ROR4Mutator]MSP[N]
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND ) { return len + 1 ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ; return Math . min ( posUnix , posWin ) + 1 ; MST[NonVoidMethodCallMutator]MSP[N] }
final int prefix = getPrefixLength ( fileName ) ; if ( prefix < 0 ) { return null ; } if ( prefix >= fileName . length () ) { if ( includeSeparator ) { MST[rv.UOI4Mutator]MSP[N] return getPrefix ( fileName ) ; } return fileName ; }
for ( int i = 0 ; i < array . length ; i ++ ) { if ( array [ i ] == otherSeparator ) { MST[rv.UOI1Mutator]MSP[N] array [ i ] = separator ; } } boolean lastIsDirectory = true ;
if ( array [ j ] == separator ) { MST[rv.ROR3Mutator]MSP[N] System . arraycopy ( array , i + 1 , array , j + 1 , size - i ) ; size -= i - j ; i = j + 1 ; continue outer; } }
if ( len < 0 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] return null ; } if ( len > fileName . length () ) { failIfNullBytePresent ( fileName + UNIX_SEPARATOR ) ; return fileName + UNIX_SEPARATOR ; } final String path = fileName . substring ( 0 , len ) ;
if ( i == prefix + 2 ) { return null ; } if ( i == size - 1 ) { lastIsDirectory = true ; } int j ; for ( j = i - 4 ; j >= prefix ; j -- ) { MST[InlineConstantMutator]MSP[N]
} public static boolean equalsOnSystem ( final String fileName1 , final String fileName2 ) { return equals ( fileName1 , fileName2 , false , IOCase . SYSTEM ) ; MST[rv.CRCR3Mutator]MSP[S] } public static boolean equalsNormalized ( final String fileName1 , final String fileName2 ) {
if ( path == null || path . indexOf ( UNIX_SEPARATOR ) == NOT_FOUND ) { return path ; } return path . replace ( UNIX_SEPARATOR , WINDOWS_SEPARATOR ) ; MST[rv.CRCR3Mutator]MSP[N] } public static String separatorsToSystem ( final String path ) { if ( path == null ) {
return null ; } return isSystemWindows () ? separatorsToWindows ( path ) : separatorsToUnix ( path ) ; MST[rv.ROR5Mutator]MSP[N] } public static int getPrefixLength ( final String fileName ) { if ( fileName == null ) { return NOT_FOUND ; } final int len = fileName . length () ;
if ( fileName == null || wildcardMatcher == null ) { return false ; } if ( caseSensitivity == null ) { caseSensitivity = IOCase . SENSITIVE ; } final String [] wcs = splitOnTokens ( wildcardMatcher ) ; boolean anyChars = false ; MST[rv.CRCR1Mutator]MSP[S] int textIdx = 0 ;
final char [] array = text . toCharArray () ; final ArrayList < String > list = new ArrayList <> () ; final StringBuilder buffer = new StringBuilder () ; MST[ConstructorCallMutator]MSP[N] char prevChar = 0 ; for ( final char ch : array ) {
if ( len < 0 ) { return null ; } if ( len > fileName . length () ) { MST[ConditionalsBoundaryMutator]MSP[N] failIfNullBytePresent ( fileName + UNIX_SEPARATOR ) ; return fileName + UNIX_SEPARATOR ; } final String path = fileName . substring ( 0 , len ) ;
if ( size <= prefix ) { MST[rv.ROR3Mutator]MSP[N] return new String ( array , 0 , size ) ; } if ( lastIsDirectory && keepSeparator ) { return new String ( array , 0 , size ) ; }
if ( prefix > 0 ) { return normalize ( fullFileNameToAdd ) ; } if ( basePath == null ) { return null ; } final int len = basePath . length () ; if ( len == 0 ) { MST[rv.UOI2Mutator]MSP[N] return normalize ( fullFileNameToAdd ) ; }
for ( int i = 0 ; i < array . length ; i ++ ) { MST[rv.ROR3Mutator]MSP[N] if ( array [ i ] == otherSeparator ) { array [ i ] = separator ; } } boolean lastIsDirectory = true ;
final int pos = Math . min ( posUnix , posWin ) + 1 ; MST[rv.UOI4Mutator]MSP[N] final String hostnamePart = fileName . substring ( 2 , pos - 1 ) ; return isValidHostName ( hostnamePart ) ? pos : NOT_FOUND ; } else {
for ( int i = prefix + 1 ; i < size ; i ++ ) { MST[NegateConditionalsMutator]MSP[N] if ( array [ i ] == separator && array [ i - 1 ] == '.' &&
if ( array [ size - 1 ] != separator ) { array [ size ++ ] = separator ; MST[rv.UOI3Mutator]MSP[N] lastIsDirectory = false ; } for ( int i = prefix + 1 ; i < size ; i ++ ) {
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND ) { return len + 1 ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; MST[rv.UOI4Mutator]MSP[N] posWin = posWin == NOT_FOUND ? posUnix : posWin ; return Math . min ( posUnix , posWin ) + 1 ; }
if ( extension == null || extension . isEmpty () ) { MST[rv.ROR1Mutator]MSP[N] return indexOfExtension ( fileName ) == NOT_FOUND ; } final String fileExt = getExtension ( fileName ) ; return fileExt . equals ( extension ) ; }
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND ) { MST[rv.ROR5Mutator]MSP[N] return len + 1 ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ; return Math . min ( posUnix , posWin ) + 1 ; }
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2 ) { MST[rv.UOI2Mutator]MSP[N] return NOT_FOUND ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ;
return false ; MST[rv.CRCR3Mutator]MSP[N] } static String [] splitOnTokens ( final String text ) { if ( text . indexOf ( '?' ) == NOT_FOUND && text . indexOf ( '*' ) == NOT_FOUND ) { return new String [] { text } ; }
octetInt = Integer . parseInt ( octet , BASE_16 ) ; } catch ( final NumberFormatException e ) { return false ; } if ( octetInt < 0 || octetInt > MAX_UNSIGNED_SHORT ) { MST[rv.UOI1Mutator]MSP[N] return false ; } } validOctets ++ ; }
if ( ! isIPv4Address ( octet ) ) { return false ; } validOctets += 2 ; continue; } if ( octet . length () > IPV6_MAX_HEX_DIGITS_PER_GROUP ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] return false ; } int octetInt = 0 ; try {
if ( index == NOT_FOUND ) { MST[rv.CRCR4Mutator]MSP[S] return fileName ; } return fileName . substring ( 0 , index ) ; } public static boolean equals ( final String fileName1 , final String fileName2 ) { return equals ( fileName1 , fileName2 , false , IOCase . SENSITIVE ) ;
System . arraycopy ( array , i + 1 , array , prefix , size - i ) ; size -= i + 1 - prefix ; MST[InlineConstantMutator]MSP[N] i = prefix + 1 ; } } if ( size <= 0 ) { return EMPTY_STRING ; }
return new String ( array , 0 , size - 1 ) ; MST[rv.UOI2Mutator]MSP[S] } public static String concat ( final String basePath , final String fullFileNameToAdd ) { final int prefix = getPrefixLength ( fullFileNameToAdd ) ; if ( prefix < 0 ) { return null ; }
public static boolean isExtension ( final String fileName , final Collection < String > extensions ) { if ( fileName == null ) { return false ; MST[InlineConstantMutator]MSP[N] } failIfNullBytePresent ( fileName ) ; if ( extensions == null || extensions . isEmpty () ) {
textIdx = caseSensitivity . checkIndexOf ( fileName , textIdx , wcs [ wcsIdx ] ) ; if ( textIdx == NOT_FOUND ) { break; } final int repeat = caseSensitivity . checkIndexOf ( fileName , textIdx + 1 , wcs [ wcsIdx ] ) ; MST[ArgumentPropagationMutator]MSP[N]
if ( len == 0 ) { MST[rv.ROR3Mutator]MSP[S] return 0 ; } char ch0 = fileName . charAt ( 0 ) ; if ( ch0 == ':' ) { return NOT_FOUND ; } if ( len == 1 ) { if ( ch0 == '~' ) { return 2 ; }
if ( ! REG_NAME_PART_PATTERN . matcher ( parts [ i ] ) . matches () ) { MST[rv.UOI1Mutator]MSP[N] return false ; } } return true ; }
if ( array [ i ] == separator && array [ i - 1 ] == separator ) { System . arraycopy ( array , i , array , i - 1 , size - i ) ; MST[rv.UOI4Mutator]MSP[N] size -- ; i -- ; } }
if ( validOctets > IPV6_MAX_HEX_GROUPS || ( validOctets < IPV6_MAX_HEX_GROUPS && ! containsCompressedZeroes ) ) { MST[rv.UOI2Mutator]MSP[N] return false ; } return true ; } private static boolean isRFC3986HostName ( final String name ) { final String [] parts = name . split ( lr_13 , - 1 ) ;
if ( len < 0 ) { return null ; } if ( len > fileName . length () ) { failIfNullBytePresent ( fileName + UNIX_SEPARATOR ) ; return fileName + UNIX_SEPARATOR ; MST[rv.CRCR6Mutator]MSP[N] } final String path = fileName . substring ( 0 , len ) ;
if ( containsCompressedZeroes && ( inet6Address . indexOf ( lr_9 ) != inet6Address . lastIndexOf ( lr_9 ) ) ) { MST[rv.ROR1Mutator]MSP[N] return false ; } if ( ( inet6Address . startsWith ( lr_10 ) && ! inet6Address . startsWith ( lr_9 ) )
if ( ! REG_NAME_PART_PATTERN . matcher ( parts [ i ] ) . matches () ) { return false ; MST[rv.CRCR5Mutator]MSP[N] } } return true ; }
if ( i == prefix + 2 ) { return null ; } if ( i == size - 1 ) { MST[rv.CRCR3Mutator]MSP[S] lastIsDirectory = true ; } int j ; for ( j = i - 4 ; j >= prefix ; j -- ) {
} public static boolean equalsOnSystem ( final String fileName1 , final String fileName2 ) { return equals ( fileName1 , fileName2 , false , IOCase . SYSTEM ) ; MST[rv.CRCR6Mutator]MSP[S] } public static boolean equalsNormalized ( final String fileName1 , final String fileName2 ) {
public static boolean isExtension ( final String fileName , final Collection < String > extensions ) { if ( fileName == null ) { return false ; } failIfNullBytePresent ( fileName ) ; if ( extensions == null || extensions . isEmpty () ) { MST[rv.ROR2Mutator]MSP[N]
return isSeparator ( ch0 ) ? 1 : 0 ; } if ( ch0 == '~' ) { MST[rv.UOI3Mutator]MSP[N] int posUnix = fileName . indexOf ( UNIX_SEPARATOR , 1 ) ; int posWin = fileName . indexOf ( WINDOWS_SEPARATOR , 1 ) ;
if ( ch == '?' || ch == '*' ) { if ( buffer . length () != 0 ) { list . add ( buffer . toString () ) ; buffer . setLength ( 0 ) ; MST[rv.CRCR1Mutator]MSP[N] } if ( ch == '?' ) {
return caseSensitivity . checkEquals ( fileName1 , fileName2 ) ; } public static boolean isExtension ( final String fileName , final String extension ) { if ( fileName == null ) { return false ; MST[rv.CRCR5Mutator]MSP[S] } failIfNullBytePresent ( fileName ) ;
if ( len < 0 ) { return null ; } if ( len > fileName . length () ) { MST[rv.UOI4Mutator]MSP[N] failIfNullBytePresent ( fileName + UNIX_SEPARATOR ) ; return fileName + UNIX_SEPARATOR ; } final String path = fileName . substring ( 0 , len ) ;
if ( len == 0 ) { return 0 ; } char ch0 = fileName . charAt ( 0 ) ; if ( ch0 == ':' ) { MST[rv.CRCR2Mutator]MSP[N] return NOT_FOUND ; } if ( len == 1 ) { if ( ch0 == '~' ) { return 2 ; }
list . add ( lr_6 ) ; } else if ( prevChar != '*' ) { MST[rv.ROR5Mutator]MSP[N] list . add ( lr_7 ) ; } } else { buffer . append ( ch ) ; } prevChar = ch ; } if ( buffer . length () != 0 ) {
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2 ) { return NOT_FOUND ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; MST[rv.UOI2Mutator]MSP[N] posWin = posWin == NOT_FOUND ? posUnix : posWin ;
if ( array [ i ] == separator && array [ i - 1 ] == '.' && array [ i - 2 ] == '.' && MST[rv.UOI2Mutator]MSP[N] ( i == prefix + 2 || array [ i - 3 ] == separator ) ) {
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2 ) { MST[rv.CRCR1Mutator]MSP[N] return NOT_FOUND ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ;
list . add ( lr_6 ) ; } else if ( prevChar != '*' ) { MST[rv.UOI1Mutator]MSP[N] list . add ( lr_7 ) ; } } else { buffer . append ( ch ) ; } prevChar = ch ; } if ( buffer . length () != 0 ) {
for ( int i = prefix + 1 ; i < size ; i ++ ) { MST[InlineConstantMutator]MSP[S] if ( array [ i ] == separator && array [ i - 1 ] == '.' &&
final int index = indexOfLastSeparator ( fileName ) ; if ( index < 0 ) { return fileName . substring ( 0 , prefix ) ; MST[rv.UOI4Mutator]MSP[N] } int end = index + ( includeSeparator ? 1 : 0 ) ; if ( end == 0 ) { end ++ ;
if ( i == prefix + 2 ) { MST[rv.UOI4Mutator]MSP[N] return null ; } if ( i == size - 1 ) { lastIsDirectory = true ; } int j ; for ( j = i - 4 ; j >= prefix ; j -- ) {
if ( path == null || path . indexOf ( UNIX_SEPARATOR ) == NOT_FOUND ) { MST[NonVoidMethodCallMutator]MSP[N] return path ; } return path . replace ( UNIX_SEPARATOR , WINDOWS_SEPARATOR ) ; } public static String separatorsToSystem ( final String path ) { if ( path == null ) {
return indexOfExtension ( fileName ) == NOT_FOUND ; } final String fileExt = getExtension ( fileName ) ; for ( final String extension : extensions ) { if ( fileExt . equals ( extension ) ) { MST[NonVoidMethodCallMutator]MSP[N] return true ; } } return false ; }
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND ) { return len + 1 ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; MST[rv.UOI3Mutator]MSP[N] posWin = posWin == NOT_FOUND ? posUnix : posWin ; return Math . min ( posUnix , posWin ) + 1 ; }
final int index = indexOfLastSeparator ( fileName ) ; if ( index < 0 ) { MST[rv.UOI2Mutator]MSP[N] return fileName . substring ( 0 , prefix ) ; } int end = index + ( includeSeparator ? 1 : 0 ) ; if ( end == 0 ) { end ++ ;
for ( int i = 0 ; i < parts . length ; i ++ ) { if ( parts [ i ] . length () == 0 ) { return i == parts . length - 1 ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] }
textIdx += wcs [ wcsIdx ] . length () ; MST[NonVoidMethodCallMutator]MSP[N] anyChars = false ; } wcsIdx ++ ; } if ( wcsIdx == wcs . length && textIdx == fileName . length () ) { return true ; } } while ( backtrack . size () > 0 );
for ( int i = 0 ; i < parts . length ; i ++ ) { if ( parts [ i ] . length () == 0 ) { return i == parts . length - 1 ; MST[rv.CRCR4Mutator]MSP[N] }
return indexOfExtension ( fileName ) == NOT_FOUND ; MST[ReturnValsMutator]MSP[N] } final String fileExt = getExtension ( fileName ) ; for ( final String extension : extensions ) { if ( fileExt . equals ( extension ) ) { return true ; } } return false ; }
if ( i == prefix + 2 ) { MST[rv.AOD1Mutator]MSP[N] return null ; } if ( i == size - 1 ) { lastIsDirectory = true ; } int j ; for ( j = i - 4 ; j >= prefix ; j -- ) {
for ( int i = 1 ; i <= 4 ; i ++ ) { final String ipSegment = m . group ( i ) ; final int iIpSegment = Integer . parseInt ( ipSegment ) ; if ( iIpSegment > IPV4_MAX_OCTET_VALUE ) { MST[rv.ROR4Mutator]MSP[S] return false ; }
if ( i == prefix + 2 ) { return null ; } if ( i == size - 1 ) { lastIsDirectory = true ; } int j ; for ( j = i - 4 ; j >= prefix ; j -- ) { MST[NegateConditionalsMutator]MSP[N]
if ( array [ size - 1 ] != separator ) { array [ size ++ ] = separator ; lastIsDirectory = false ; } for ( int i = prefix + 1 ; i < size ; i ++ ) { MST[rv.UOI3Mutator]MSP[S]
final char ch1 = fileName . charAt ( 1 ) ; MST[rv.CRCR4Mutator]MSP[N] if ( ch1 == ':' ) { ch0 = Character . toUpperCase ( ch0 ) ; if ( ch0 >= 'A' && ch0 <= 'Z' ) {
if ( ! isIPv4Address ( octet ) ) { MST[rv.ROR2Mutator]MSP[S] return false ; } validOctets += 2 ; continue; } if ( octet . length () > IPV6_MAX_HEX_DIGITS_PER_GROUP ) { return false ; } int octetInt = 0 ; try {
System . arraycopy ( array , i + 1 , array , i - 1 , size - i ) ; MST[rv.AOR3Mutator]MSP[N] size -= 2 ; i -- ; } } outer: for ( int i = prefix + 2 ; i < size ; i ++ ) {
list . add ( lr_6 ) ; } else if ( prevChar != '*' ) { list . add ( lr_7 ) ; } } else { buffer . append ( ch ) ; } prevChar = ch ; MST[rv.UOI2Mutator]MSP[N] } if ( buffer . length () != 0 ) {
System . arraycopy ( array , i + 1 , array , i - 1 , size - i ) ; MST[rv.AOR2Mutator]MSP[N] size -= 2 ; i -- ; } } outer: for ( int i = prefix + 2 ; i < size ; i ++ ) {
} else if ( isSeparator ( ch0 ) && isSeparator ( ch1 ) ) { int posUnix = fileName . indexOf ( UNIX_SEPARATOR , 2 ) ; MST[rv.CRCR1Mutator]MSP[N] int posWin = fileName . indexOf ( WINDOWS_SEPARATOR , 2 ) ;
final char ch1 = fileName . charAt ( 1 ) ; if ( ch1 == ':' ) { MST[rv.CRCR6Mutator]MSP[N] ch0 = Character . toUpperCase ( ch0 ) ; if ( ch0 >= 'A' && ch0 <= 'Z' ) {
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2 ) { return NOT_FOUND ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ; MST[rv.UOI2Mutator]MSP[N]
for ( int i = prefix + 1 ; i < size ; i ++ ) { if ( array [ i ] == separator && array [ i - 1 ] == '.' && MST[InlineConstantMutator]MSP[N]
if ( octet . length () == 0 ) { emptyOctets ++ ; if ( emptyOctets > 1 ) { return false ; } } else { emptyOctets = 0 ; if ( index == octets . length - 1 && octet . contains ( lr_12 ) ) { MST[InlineConstantMutator]MSP[S]
octetInt = Integer . parseInt ( octet , BASE_16 ) ; } catch ( final NumberFormatException e ) { return false ; } if ( octetInt < 0 || octetInt > MAX_UNSIGNED_SHORT ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] return false ; } } validOctets ++ ; }
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND ) { return len + 1 ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ; MST[rv.UOI1Mutator]MSP[N] return Math . min ( posUnix , posWin ) + 1 ; }
System . arraycopy ( array , i + 1 , array , prefix , size - i ) ; MST[rv.AOR4Mutator]MSP[N] size -= i + 1 - prefix ; i = prefix + 1 ; } } if ( size <= 0 ) { return EMPTY_STRING ; }
final int index = indexOfLastSeparator ( fileName ) ; if ( index < 0 ) { MST[rv.ROR3Mutator]MSP[N] return fileName . substring ( 0 , prefix ) ; } int end = index + ( includeSeparator ? 1 : 0 ) ; if ( end == 0 ) { end ++ ;
if ( array [ i ] == separator && array [ i - 1 ] == '.' && array [ i - 2 ] == '.' && MST[rv.ROR3Mutator]MSP[N] ( i == prefix + 2 || array [ i - 3 ] == separator ) ) {
if ( containsCompressedZeroes && ( inet6Address . indexOf ( lr_9 ) != inet6Address . lastIndexOf ( lr_9 ) ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] return false ; } if ( ( inet6Address . startsWith ( lr_10 ) && ! inet6Address . startsWith ( lr_9 ) )
public static String getExtension ( final String fileName ) throws IllegalArgumentException { if ( fileName == null ) { return null ; } final int index = indexOfExtension ( fileName ) ; if ( index == NOT_FOUND ) { MST[NegateConditionalsMutator]MSP[N] return EMPTY_STRING ; }
return indexOfExtension ( fileName ) == NOT_FOUND ; } final String fileExt = getExtension ( fileName ) ; for ( final String extension : extensions ) { if ( fileExt . equals ( extension ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return true ; } } return false ; }
if ( len == 0 ) { return 0 ; } char ch0 = fileName . charAt ( 0 ) ; if ( ch0 == ':' ) { return NOT_FOUND ; } if ( len == 1 ) { if ( ch0 == '~' ) { MST[rv.ROR2Mutator]MSP[N] return 2 ; }
static boolean isSystemWindows () { return SYSTEM_SEPARATOR == WINDOWS_SEPARATOR ; } private static boolean isSeparator ( final char ch ) { return ch == UNIX_SEPARATOR || ch == WINDOWS_SEPARATOR ; MST[rv.ROR5Mutator]MSP[N] } public static String normalize ( final String fileName ) {
|| ( inet6Address . endsWith ( lr_10 ) && ! inet6Address . endsWith ( lr_9 ) ) ) { return false ; } String [] octets = inet6Address . split ( lr_10 ) ; if ( containsCompressedZeroes ) { MST[rv.UOI3Mutator]MSP[S]
final int pos = Math . min ( posUnix , posWin ) + 1 ; final String hostnamePart = fileName . substring ( 2 , pos - 1 ) ; MST[MathMutator]MSP[N] return isValidHostName ( hostnamePart ) ? pos : NOT_FOUND ; } else {
final int lastSeparator = indexOfLastSeparator ( fileName ) ; return lastSeparator > extensionPos ? NOT_FOUND : extensionPos ; MST[rv.UOI1Mutator]MSP[N] } public static String getPrefix ( final String fileName ) { if ( fileName == null ) { return null ; } final int len = getPrefixLength ( fileName ) ;
final String path = fileName . substring ( prefix , endIndex ) ; MST[rv.UOI4Mutator]MSP[N] failIfNullBytePresent ( path ) ; return path ; } public static String getFullPath ( final String fileName ) { return doGetFullPath ( fileName , true ) ; }
return doNormalize ( fileName , separator , false ) ; MST[rv.UOI4Mutator]MSP[N] } private static String doNormalize ( final String fileName , final char separator , final boolean keepSeparator ) { if ( fileName == null ) { return null ; } failIfNullBytePresent ( fileName ) ;
if ( i == prefix + 2 ) { return null ; } if ( i == size - 1 ) { MST[rv.UOI2Mutator]MSP[N] lastIsDirectory = true ; } int j ; for ( j = i - 4 ; j >= prefix ; j -- ) {
if ( size <= prefix ) { return new String ( array , 0 , size ) ; } if ( lastIsDirectory && keepSeparator ) { MST[rv.ROR2Mutator]MSP[S] return new String ( array , 0 , size ) ; }
final int prefix = getPrefixLength ( fileName ) ; if ( prefix < 0 ) { return null ; } if ( prefix >= fileName . length () ) { if ( includeSeparator ) { MST[rv.ROR2Mutator]MSP[N] return getPrefix ( fileName ) ; } return fileName ; }
final char ch = basePath . charAt ( len - 1 ) ; if ( isSeparator ( ch ) ) { return normalize ( basePath + fullFileNameToAdd ) ; MST[experimental.NakedReceiverMutator]MSP[N] } return normalize ( basePath + '/' + fullFileNameToAdd ) ; }
for ( int i = 0 ; i < parts . length ; i ++ ) { if ( parts [ i ] . length () == 0 ) { return i == parts . length - 1 ; MST[rv.CRCR3Mutator]MSP[N] }
if ( array [ i ] == separator && array [ i - 1 ] == '.' && array [ i - 2 ] == '.' && MST[rv.CRCR4Mutator]MSP[N] ( i == prefix + 2 || array [ i - 3 ] == separator ) ) {
String fileName1 , String fileName2 , final boolean normalized , IOCase caseSensitivity ) { if ( fileName1 == null || fileName2 == null ) { return fileName1 == null && fileName2 == null ; MST[rv.CRCR3Mutator]MSP[N] } if ( normalized ) { fileName1 = normalize ( fileName1 ) ;
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2 ) { return NOT_FOUND ; MST[ReturnValsMutator]MSP[N] } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ;
final int index = indexOfLastSeparator ( fileName ) ; final int endIndex = index + separatorAdd ; if ( prefix >= fileName . length () || index < 0 || prefix >= endIndex ) { MST[rv.ROR5Mutator]MSP[N] return EMPTY_STRING ; }
for ( int i = 1 ; i <= 4 ; i ++ ) { MST[InlineConstantMutator]MSP[N] final String ipSegment = m . group ( i ) ; final int iIpSegment = Integer . parseInt ( ipSegment ) ; if ( iIpSegment > IPV4_MAX_OCTET_VALUE ) { return false ; }
for ( int i = prefix + 1 ; i < size ; i ++ ) { if ( array [ i ] == separator && array [ i - 1 ] == '.' && MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
if ( index == NOT_FOUND ) { MST[rv.UOI2Mutator]MSP[N] return fileName ; } return fileName . substring ( 0 , index ) ; } public static boolean equals ( final String fileName1 , final String fileName2 ) { return equals ( fileName1 , fileName2 , false , IOCase . SENSITIVE ) ;
textIdx += wcs [ wcsIdx ] . length () ; anyChars = false ; } wcsIdx ++ ; } if ( wcsIdx == wcs . length && textIdx == fileName . length () ) { return true ; MST[ReturnValsMutator]MSP[N] } } while ( backtrack . size () > 0 );
static boolean isSystemWindows () { return SYSTEM_SEPARATOR == WINDOWS_SEPARATOR ; } private static boolean isSeparator ( final char ch ) { return ch == UNIX_SEPARATOR || ch == WINDOWS_SEPARATOR ; MST[rv.CRCR2Mutator]MSP[N] } public static String normalize ( final String fileName ) {
if ( path == null || path . indexOf ( WINDOWS_SEPARATOR ) == NOT_FOUND ) { MST[NegateConditionalsMutator]MSP[N] return path ; } return path . replace ( WINDOWS_SEPARATOR , UNIX_SEPARATOR ) ; } public static String separatorsToWindows ( final String path ) {
static boolean isSystemWindows () { return SYSTEM_SEPARATOR == WINDOWS_SEPARATOR ; } private static boolean isSeparator ( final char ch ) { return ch == UNIX_SEPARATOR || ch == WINDOWS_SEPARATOR ; MST[rv.CRCR3Mutator]MSP[N] } public static String normalize ( final String fileName ) {
final char ch1 = fileName . charAt ( 1 ) ; if ( ch1 == ':' ) { ch0 = Character . toUpperCase ( ch0 ) ; if ( ch0 >= 'A' && ch0 <= 'Z' ) { MST[rv.UOI4Mutator]MSP[N]
final int index = indexOfLastSeparator ( fileName ) ; final int endIndex = index + separatorAdd ; if ( prefix >= fileName . length () || index < 0 || prefix >= endIndex ) { MST[ConditionalsBoundaryMutator]MSP[N] return EMPTY_STRING ; }
return wildcardMatch ( fileName , wildcardMatcher , IOCase . SYSTEM ) ; } public static boolean wildcardMatch ( final String fileName , final String wildcardMatcher , IOCase caseSensitivity ) { if ( fileName == null && wildcardMatcher == null ) { return true ; MST[rv.CRCR2Mutator]MSP[N] }
for ( int i = 1 ; i <= 4 ; i ++ ) { MST[rv.CRCR2Mutator]MSP[N] final String ipSegment = m . group ( i ) ; final int iIpSegment = Integer . parseInt ( ipSegment ) ; if ( iIpSegment > IPV4_MAX_OCTET_VALUE ) { return false ; }
return doNormalize ( fileName , separator , false ) ; } private static String doNormalize ( final String fileName , final char separator , final boolean keepSeparator ) { if ( fileName == null ) { return null ; MST[EmptyObjectReturnValsMutator]MSP[N] } failIfNullBytePresent ( fileName ) ;
if ( i == prefix + 2 ) { return null ; } if ( i == size - 1 ) { lastIsDirectory = true ; } int j ; for ( j = i - 4 ; j >= prefix ; j -- ) { MST[ConditionalsBoundaryMutator]MSP[N]
final char ch = basePath . charAt ( len - 1 ) ; if ( isSeparator ( ch ) ) { return normalize ( basePath + fullFileNameToAdd ) ; } return normalize ( basePath + '/' + fullFileNameToAdd ) ; MST[experimental.NakedReceiverMutator]MSP[N] }
final int pos = Math . min ( posUnix , posWin ) + 1 ; final String hostnamePart = fileName . substring ( 2 , pos - 1 ) ; MST[rv.UOI1Mutator]MSP[N] return isValidHostName ( hostnamePart ) ? pos : NOT_FOUND ; } else {
return false ; } static String [] splitOnTokens ( final String text ) { if ( text . indexOf ( '?' ) == NOT_FOUND && text . indexOf ( '*' ) == NOT_FOUND ) { MST[InlineConstantMutator]MSP[N] return new String [] { text } ; }
for ( int i = 0 ; i < parts . length ; i ++ ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] if ( parts [ i ] . length () == 0 ) { return i == parts . length - 1 ; }
return false ; } static String [] splitOnTokens ( final String text ) { if ( text . indexOf ( '?' ) == NOT_FOUND && text . indexOf ( '*' ) == NOT_FOUND ) { MST[rv.ROR5Mutator]MSP[N] return new String [] { text } ; }
} else if ( isSeparator ( ch0 ) && isSeparator ( ch1 ) ) { MST[NonVoidMethodCallMutator]MSP[N] int posUnix = fileName . indexOf ( UNIX_SEPARATOR , 2 ) ; int posWin = fileName . indexOf ( WINDOWS_SEPARATOR , 2 ) ;
if ( fileName == null || wildcardMatcher == null ) { return false ; MST[rv.CRCR6Mutator]MSP[N] } if ( caseSensitivity == null ) { caseSensitivity = IOCase . SENSITIVE ; } final String [] wcs = splitOnTokens ( wildcardMatcher ) ; boolean anyChars = false ; int textIdx = 0 ;
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return NOT_FOUND ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ;
if ( validOctets > IPV6_MAX_HEX_GROUPS || ( validOctets < IPV6_MAX_HEX_GROUPS && ! containsCompressedZeroes ) ) { MST[rv.UOI4Mutator]MSP[N] return false ; } return true ; } private static boolean isRFC3986HostName ( final String name ) { final String [] parts = name . split ( lr_13 , - 1 ) ;
if ( len < 0 ) { return null ; } if ( len > fileName . length () ) { failIfNullBytePresent ( fileName + UNIX_SEPARATOR ) ; return fileName + UNIX_SEPARATOR ; MST[experimental.NakedReceiverMutator]MSP[N] } final String path = fileName . substring ( 0 , len ) ;
return doNormalize ( fileName , SYSTEM_SEPARATOR , true ) ; } public static String normalize ( final String fileName , final boolean unixSeparator ) { final char separator = unixSeparator ? UNIX_SEPARATOR : WINDOWS_SEPARATOR ; MST[rv.ROR4Mutator]MSP[N] return doNormalize ( fileName , separator , true ) ; }
if ( octet . length () == 0 ) { MST[rv.ROR2Mutator]MSP[N] emptyOctets ++ ; if ( emptyOctets > 1 ) { return false ; } } else { emptyOctets = 0 ; if ( index == octets . length - 1 && octet . contains ( lr_12 ) ) {
return indexOfExtension ( fileName ) == NOT_FOUND ; } final String fileExt = getExtension ( fileName ) ; for ( final String extension : extensions ) { if ( fileExt . equals ( extension ) ) { return true ; } } return false ; MST[InlineConstantMutator]MSP[N] }
final char [] array = text . toCharArray () ; final ArrayList < String > list = new ArrayList <> () ; final StringBuilder buffer = new StringBuilder () ; char prevChar = 0 ; for ( final char ch : array ) { MST[rv.UOI2Mutator]MSP[N]
return caseSensitivity . checkEquals ( fileName1 , fileName2 ) ; } public static boolean isExtension ( final String fileName , final String extension ) { if ( fileName == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] return false ; } failIfNullBytePresent ( fileName ) ;
if ( validOctets > IPV6_MAX_HEX_GROUPS || ( validOctets < IPV6_MAX_HEX_GROUPS && ! containsCompressedZeroes ) ) { MST[rv.UOI3Mutator]MSP[N] return false ; } return true ; } private static boolean isRFC3986HostName ( final String name ) { final String [] parts = name . split ( lr_13 , - 1 ) ;
final int index = indexOfLastSeparator ( fileName ) ; if ( index < 0 ) { return fileName . substring ( 0 , prefix ) ; } int end = index + ( includeSeparator ? 1 : 0 ) ; MST[rv.AOR2Mutator]MSP[N] if ( end == 0 ) { end ++ ;
private static String doGetPath ( final String fileName , final int separatorAdd ) { if ( fileName == null ) { return null ; } final int prefix = getPrefixLength ( fileName ) ; if ( prefix < 0 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] return null ; }
if ( prefix > 0 ) { return normalize ( fullFileNameToAdd ) ; } if ( basePath == null ) { return null ; MST[ReturnValsMutator]MSP[N] } final int len = basePath . length () ; if ( len == 0 ) { return normalize ( fullFileNameToAdd ) ; }
return indexOfExtension ( fileName ) == NOT_FOUND ; } final String fileExt = getExtension ( fileName ) ; for ( final String extension : extensions ) { if ( fileExt . equals ( extension ) ) { return true ; } } return false ; MST[rv.CRCR3Mutator]MSP[N] }
private static boolean isIPv4Address ( final String name ) { final Matcher m = IPV4_PATTERN . matcher ( name ) ; if ( ! m . matches () || m . groupCount () != 4 ) { MST[rv.ROR5Mutator]MSP[S] return false ; }
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND ) { return len + 1 ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ; MST[rv.UOI4Mutator]MSP[N] return Math . min ( posUnix , posWin ) + 1 ; }
final int index = indexOfLastSeparator ( fileName ) ; if ( index < 0 ) { return fileName . substring ( 0 , prefix ) ; } int end = index + ( includeSeparator ? 1 : 0 ) ; MST[InlineConstantMutator]MSP[N] if ( end == 0 ) { end ++ ;
return false ; } static String [] splitOnTokens ( final String text ) { if ( text . indexOf ( '?' ) == NOT_FOUND && text . indexOf ( '*' ) == NOT_FOUND ) { return new String [] { text } ; MST[rv.CRCR1Mutator]MSP[N] }
if ( octet . length () == 0 ) { emptyOctets ++ ; if ( emptyOctets > 1 ) { MST[rv.CRCR4Mutator]MSP[N] return false ; } } else { emptyOctets = 0 ; if ( index == octets . length - 1 && octet . contains ( lr_12 ) ) {
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return len + 1 ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ; return Math . min ( posUnix , posWin ) + 1 ; }
public static boolean isExtension ( final String fileName , final Collection < String > extensions ) { if ( fileName == null ) { return false ; MST[rv.CRCR3Mutator]MSP[N] } failIfNullBytePresent ( fileName ) ; if ( extensions == null || extensions . isEmpty () ) {
for ( int i = prefix + 1 ; i < size ; i ++ ) { if ( array [ i ] == separator && array [ i - 1 ] == '.' && MST[rv.AOR3Mutator]MSP[N]
public static String getExtension ( final String fileName ) throws IllegalArgumentException { if ( fileName == null ) { return null ; } final int index = indexOfExtension ( fileName ) ; if ( index == NOT_FOUND ) { MST[InlineConstantMutator]MSP[N] return EMPTY_STRING ; }
if ( path == null || path . indexOf ( UNIX_SEPARATOR ) == NOT_FOUND ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return path ; } return path . replace ( UNIX_SEPARATOR , WINDOWS_SEPARATOR ) ; } public static String separatorsToSystem ( final String path ) { if ( path == null ) {
return equals ( fileName1 , fileName2 , true , IOCase . SENSITIVE ) ; MST[rv.CRCR5Mutator]MSP[N] } public static boolean equalsNormalizedOnSystem ( final String fileName1 , final String fileName2 ) { return equals ( fileName1 , fileName2 , true , IOCase . SYSTEM ) ; } public static boolean equals (
return caseSensitivity . checkEquals ( fileName1 , fileName2 ) ; MST[NonVoidMethodCallMutator]MSP[N] } public static boolean isExtension ( final String fileName , final String extension ) { if ( fileName == null ) { return false ; } failIfNullBytePresent ( fileName ) ;
list . add ( buffer . toString () ) ; MST[NonVoidMethodCallMutator]MSP[N] } return list . toArray ( new String [ list . size () ] ) ; } private static boolean isValidHostName ( final String name ) { return isIPv6Address ( name ) || isRFC3986HostName ( name ) ; }
} else if ( isSeparator ( ch0 ) && isSeparator ( ch1 ) ) { int posUnix = fileName . indexOf ( UNIX_SEPARATOR , 2 ) ; int posWin = fileName . indexOf ( WINDOWS_SEPARATOR , 2 ) ; MST[NonVoidMethodCallMutator]MSP[N]
anyChars = false ; } else if ( wcs [ wcsIdx ] . equals ( lr_7 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] anyChars = true ; if ( wcsIdx == wcs . length - 1 ) { textIdx = fileName . length () ; } } else { if ( anyChars ) {
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2 ) { MST[rv.ABSMutator]MSP[N] return NOT_FOUND ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ;
return false ; } static String [] splitOnTokens ( final String text ) { if ( text . indexOf ( '?' ) == NOT_FOUND && text . indexOf ( '*' ) == NOT_FOUND ) { MST[rv.CRCR2Mutator]MSP[N] return new String [] { text } ; }
System . arraycopy ( array , i + 1 , array , i - 1 , size - i ) ; MST[InlineConstantMutator]MSP[N] size -= 2 ; i -- ; } } outer: for ( int i = prefix + 2 ; i < size ; i ++ ) {
final int lastWindowsPos = fileName . lastIndexOf ( WINDOWS_SEPARATOR ) ; MST[InlineConstantMutator]MSP[N] return Math . max ( lastUnixPos , lastWindowsPos ) ; } public static int indexOfExtension ( final String fileName ) throws IllegalArgumentException { if ( fileName == null ) { return NOT_FOUND ; }
textIdx = caseSensitivity . checkIndexOf ( fileName , textIdx , wcs [ wcsIdx ] ) ; if ( textIdx == NOT_FOUND ) { break; } final int repeat = caseSensitivity . checkIndexOf ( fileName , textIdx + 1 , wcs [ wcsIdx ] ) ; MST[rv.UOI2Mutator]MSP[N]
return isSeparator ( ch0 ) ? 1 : 0 ; MST[rv.CRCR1Mutator]MSP[N] } if ( ch0 == '~' ) { int posUnix = fileName . indexOf ( UNIX_SEPARATOR , 1 ) ; int posWin = fileName . indexOf ( WINDOWS_SEPARATOR , 1 ) ;
if ( array [ i ] == separator && array [ i - 1 ] == '.' && array [ i - 2 ] == '.' && MST[rv.CRCR3Mutator]MSP[N] ( i == prefix + 2 || array [ i - 3 ] == separator ) ) {
return indexOfExtension ( fileName ) == NOT_FOUND ; MST[BooleanTrueReturnValsMutator]MSP[S] } final String fileExt = getExtension ( fileName ) ; for ( final String extension : extensions ) { if ( fileExt . equals ( extension ) ) { return true ; } } return false ; }
return fileName . substring ( index + 1 ) ; } private static void failIfNullBytePresent ( final String path ) { final int len = path . length () ; for ( int i = 0 ; i < len ; i ++ ) { MST[rv.UOI2Mutator]MSP[N]
if ( path . charAt ( i ) == 0 ) { MST[rv.UOI4Mutator]MSP[N] throw new IllegalArgumentException ( lr_3 + lr_4 ) ; } } } public static String getBaseName ( final String fileName ) { return removeExtension ( getName ( fileName ) ) ; }
return fileName . substring ( index + 1 ) ; MST[rv.AOR4Mutator]MSP[N] } private static void failIfNullBytePresent ( final String path ) { final int len = path . length () ; for ( int i = 0 ; i < len ; i ++ ) {
|| ( inet6Address . endsWith ( lr_10 ) && ! inet6Address . endsWith ( lr_9 ) ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return false ; } String [] octets = inet6Address . split ( lr_10 ) ; if ( containsCompressedZeroes ) {
for ( int i = 0 ; i < parts . length ; i ++ ) { if ( parts [ i ] . length () == 0 ) { return i == parts . length - 1 ; MST[ReturnValsMutator]MSP[N] }
octetInt = Integer . parseInt ( octet , BASE_16 ) ; } catch ( final NumberFormatException e ) { return false ; MST[ReturnValsMutator]MSP[S] } if ( octetInt < 0 || octetInt > MAX_UNSIGNED_SHORT ) { return false ; } } validOctets ++ ; }
final int pos = Math . min ( posUnix , posWin ) + 1 ; MST[rv.AOD1Mutator]MSP[N] final String hostnamePart = fileName . substring ( 2 , pos - 1 ) ; return isValidHostName ( hostnamePart ) ? pos : NOT_FOUND ; } else {
for ( int i = prefix + 1 ; i < size ; i ++ ) { MST[ConditionalsBoundaryMutator]MSP[S] if ( array [ i ] == separator && array [ i - 1 ] == '.' &&
if ( array [ j ] == separator ) { System . arraycopy ( array , i + 1 , array , j + 1 , size - i ) ; MST[rv.UOI1Mutator]MSP[N] size -= i - j ; i = j + 1 ; continue outer; } }
return isSeparator ( ch0 ) ? 1 : 0 ; } if ( ch0 == '~' ) { int posUnix = fileName . indexOf ( UNIX_SEPARATOR , 1 ) ; int posWin = fileName . indexOf ( WINDOWS_SEPARATOR , 1 ) ; MST[rv.CRCR2Mutator]MSP[N]
return Math . max ( offset1 , offset2 ) + 1 ; } public static String removeExtension ( final String fileName ) { if ( fileName == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return null ; } failIfNullBytePresent ( fileName ) ; final int index = indexOfExtension ( fileName ) ;
return indexOfExtension ( fileName ) == NOT_FOUND ; } final String fileExt = getExtension ( fileName ) ; for ( final String extension : extensions ) { if ( fileExt . equals ( extension ) ) { return true ; MST[ReturnValsMutator]MSP[N] } } return false ; }
if ( octets . length > IPV6_MAX_HEX_GROUPS ) { return false ; } int validOctets = 0 ; int emptyOctets = 0 ; for ( int index = 0 ; index < octets . length ; index ++ ) { MST[rv.ROR4Mutator]MSP[N] final String octet = octets [ index ] ;
return indexOfExtension ( fileName ) == NOT_FOUND ; MST[InlineConstantMutator]MSP[N] } final String fileExt = getExtension ( fileName ) ; for ( final String extension : extensions ) { if ( fileExt . equals ( extension ) ) { return true ; } } return false ; }
if ( array [ i ] == separator && array [ i - 1 ] == '.' && array [ i - 2 ] == '.' && MST[rv.CRCR4Mutator]MSP[N] ( i == prefix + 2 || array [ i - 3 ] == separator ) ) {
static boolean isSystemWindows () { return SYSTEM_SEPARATOR == WINDOWS_SEPARATOR ; } private static boolean isSeparator ( final char ch ) { return ch == UNIX_SEPARATOR || ch == WINDOWS_SEPARATOR ; MST[rv.UOI1Mutator]MSP[S] } public static String normalize ( final String fileName ) {
if ( array [ i ] == separator && array [ i - 1 ] == separator ) { MST[rv.ROR3Mutator]MSP[N] System . arraycopy ( array , i , array , i - 1 , size - i ) ; size -- ; i -- ; } }
if ( array [ i ] == separator && array [ i - 1 ] == separator ) { MST[rv.ABSMutator]MSP[N] System . arraycopy ( array , i , array , i - 1 , size - i ) ; size -- ; i -- ; } }
final int pos = Math . min ( posUnix , posWin ) + 1 ; final String hostnamePart = fileName . substring ( 2 , pos - 1 ) ; return isValidHostName ( hostnamePart ) ? pos : NOT_FOUND ; MST[rv.CRCR1Mutator]MSP[N] } else {
public static String normalizeNoEndSeparator ( final String fileName ) { return doNormalize ( fileName , SYSTEM_SEPARATOR , false ) ; } public static String normalizeNoEndSeparator ( final String fileName , final boolean unixSeparator ) { final char separator = unixSeparator ? UNIX_SEPARATOR : WINDOWS_SEPARATOR ; MST[rv.CRCR2Mutator]MSP[S]
if ( len < 0 ) { return null ; } if ( len > fileName . length () ) { MST[rv.ROR5Mutator]MSP[N] failIfNullBytePresent ( fileName + UNIX_SEPARATOR ) ; return fileName + UNIX_SEPARATOR ; } final String path = fileName . substring ( 0 , len ) ;
final int prefix = getPrefixLength ( fileName ) ; if ( prefix < 0 ) { MST[ConditionalsBoundaryMutator]MSP[N] return null ; } if ( prefix >= fileName . length () ) { if ( includeSeparator ) { return getPrefix ( fileName ) ; } return fileName ; }
if ( array [ size - 1 ] != separator ) { array [ size ++ ] = separator ; lastIsDirectory = false ; } for ( int i = prefix + 1 ; i < size ; i ++ ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N]
return isSeparator ( ch0 ) ? 1 : 0 ; } } public static int indexOfLastSeparator ( final String fileName ) { if ( fileName == null ) { return NOT_FOUND ; } final int lastUnixPos = fileName . lastIndexOf ( UNIX_SEPARATOR ) ; MST[rv.CRCR2Mutator]MSP[N]
if ( i == prefix + 2 ) { return null ; } if ( i == size - 1 ) { MST[rv.ABSMutator]MSP[S] lastIsDirectory = true ; } int j ; for ( j = i - 4 ; j >= prefix ; j -- ) {
public static String getExtension ( final String fileName ) throws IllegalArgumentException { if ( fileName == null ) { return null ; } final int index = indexOfExtension ( fileName ) ; if ( index == NOT_FOUND ) { MST[rv.CRCR1Mutator]MSP[N] return EMPTY_STRING ; }
if ( ch == '?' || ch == '*' ) { if ( buffer . length () != 0 ) { list . add ( buffer . toString () ) ; MST[NonVoidMethodCallMutator]MSP[N] buffer . setLength ( 0 ) ; } if ( ch == '?' ) {
final char ch = basePath . charAt ( len - 1 ) ; if ( isSeparator ( ch ) ) { return normalize ( basePath + fullFileNameToAdd ) ; MST[experimental.NakedReceiverMutator]MSP[N] } return normalize ( basePath + '/' + fullFileNameToAdd ) ; }
return indexOfExtension ( fileName ) == NOT_FOUND ; MST[rv.CRCR4Mutator]MSP[N] } final String fileExt = getExtension ( fileName ) ; for ( final String extension : extensions ) { if ( fileExt . equals ( extension ) ) { return true ; } } return false ; }
for ( int i = prefix + 1 ; i < size ; i ++ ) { if ( array [ i ] == separator && array [ i - 1 ] == '.' && MST[rv.AOD2Mutator]MSP[N]
if ( len < 0 ) { return null ; } if ( len > fileName . length () ) { failIfNullBytePresent ( fileName + UNIX_SEPARATOR ) ; return fileName + UNIX_SEPARATOR ; } final String path = fileName . substring ( 0 , len ) ; MST[rv.UOI3Mutator]MSP[N]
|| ( inet6Address . endsWith ( lr_10 ) && ! inet6Address . endsWith ( lr_9 ) ) ) { return false ; MST[rv.CRCR3Mutator]MSP[S] } String [] octets = inet6Address . split ( lr_10 ) ; if ( containsCompressedZeroes ) {
for ( int i = 1 ; i <= 4 ; i ++ ) { final String ipSegment = m . group ( i ) ; final int iIpSegment = Integer . parseInt ( ipSegment ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( iIpSegment > IPV4_MAX_OCTET_VALUE ) { return false ; }
if ( i == prefix + 2 ) { return null ; } if ( i == size - 1 ) { lastIsDirectory = true ; } int j ; for ( j = i - 4 ; j >= prefix ; j -- ) { MST[rv.ABSMutator]MSP[N]
for ( int i = 1 ; i <= 4 ; i ++ ) { final String ipSegment = m . group ( i ) ; final int iIpSegment = Integer . parseInt ( ipSegment ) ; if ( iIpSegment > IPV4_MAX_OCTET_VALUE ) { MST[rv.ROR1Mutator]MSP[N] return false ; }
if ( array [ i ] == separator && array [ i - 1 ] == '.' && array [ i - 2 ] == '.' && MST[MathMutator]MSP[N] ( i == prefix + 2 || array [ i - 3 ] == separator ) ) {
if ( array [ size - 1 ] != separator ) { MST[rv.ROR2Mutator]MSP[N] array [ size ++ ] = separator ; lastIsDirectory = false ; } for ( int i = prefix + 1 ; i < size ; i ++ ) {
if ( array [ j ] == separator ) { System . arraycopy ( array , i + 1 , array , j + 1 , size - i ) ; MST[rv.UOI2Mutator]MSP[N] size -= i - j ; i = j + 1 ; continue outer; } }
System . arraycopy ( array , i + 1 , array , i - 1 , size - i ) ; size -= 2 ; i -- ; } } outer: for ( int i = prefix + 2 ; i < size ; i ++ ) { MST[rv.CRCR4Mutator]MSP[N]
} else if ( isSeparator ( ch0 ) && isSeparator ( ch1 ) ) { int posUnix = fileName . indexOf ( UNIX_SEPARATOR , 2 ) ; MST[rv.CRCR4Mutator]MSP[N] int posWin = fileName . indexOf ( WINDOWS_SEPARATOR , 2 ) ;
final int lastSeparator = indexOfLastSeparator ( fileName ) ; return lastSeparator > extensionPos ? NOT_FOUND : extensionPos ; } public static String getPrefix ( final String fileName ) { if ( fileName == null ) { return null ; MST[EmptyObjectReturnValsMutator]MSP[S] } final int len = getPrefixLength ( fileName ) ;
if ( array [ size - 1 ] != separator ) { array [ size ++ ] = separator ; lastIsDirectory = false ; } for ( int i = prefix + 1 ; i < size ; i ++ ) { MST[rv.CRCR5Mutator]MSP[S]
public static boolean isExtension ( final String fileName , final Collection < String > extensions ) { if ( fileName == null ) { return false ; MST[BooleanTrueReturnValsMutator]MSP[N] } failIfNullBytePresent ( fileName ) ; if ( extensions == null || extensions . isEmpty () ) {
if ( array [ j ] == separator ) { System . arraycopy ( array , i + 1 , array , j + 1 , size - i ) ; MST[rv.UOI3Mutator]MSP[N] size -= i - j ; i = j + 1 ; continue outer; } }
return indexOfExtension ( fileName ) == NOT_FOUND ; MST[rv.ROR1Mutator]MSP[S] } final String fileExt = getExtension ( fileName ) ; for ( final String extension : extensions ) { if ( fileExt . equals ( extension ) ) { return true ; } } return false ; }
if ( ! isIPv4Address ( octet ) ) { return false ; } validOctets += 2 ; continue; } if ( octet . length () > IPV6_MAX_HEX_DIGITS_PER_GROUP ) { MST[rv.ROR5Mutator]MSP[N] return false ; } int octetInt = 0 ; try {
if ( array [ j ] == separator ) { System . arraycopy ( array , i + 1 , array , j + 1 , size - i ) ; size -= i - j ; i = j + 1 ; MST[rv.UOI2Mutator]MSP[N] continue outer; } }
if ( array [ i ] == separator && array [ i - 1 ] == '.' && array [ i - 2 ] == '.' && MST[rv.CRCR5Mutator]MSP[N] ( i == prefix + 2 || array [ i - 3 ] == separator ) ) {
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND ) { return len + 1 ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ; MST[rv.UOI2Mutator]MSP[N] return Math . min ( posUnix , posWin ) + 1 ; }
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2 ) { MST[rv.CRCR4Mutator]MSP[N] return NOT_FOUND ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ;
public static boolean isExtension ( final String fileName , final String ... extensions ) { if ( fileName == null ) { return false ; MST[rv.CRCR5Mutator]MSP[N] } failIfNullBytePresent ( fileName ) ; if ( extensions == null || extensions . length == 0 ) {
anyChars = false ; } else if ( wcs [ wcsIdx ] . equals ( lr_7 ) ) { anyChars = true ; if ( wcsIdx == wcs . length - 1 ) { textIdx = fileName . length () ; } } else { if ( anyChars ) { MST[rv.UOI4Mutator]MSP[N]
public static boolean directoryContains ( final String canonicalParent , final String canonicalChild ) throws IOException { if ( canonicalParent == null ) { throw new IllegalArgumentException ( lr_1 ) ; MST[ConstructorCallMutator]MSP[S] } if ( canonicalChild == null ) { return false ; }
if ( len < 0 ) { return null ; } if ( len > fileName . length () ) { failIfNullBytePresent ( fileName + UNIX_SEPARATOR ) ; return fileName + UNIX_SEPARATOR ; } final String path = fileName . substring ( 0 , len ) ; MST[rv.CRCR3Mutator]MSP[N]
if ( array [ size - 1 ] != separator ) { MST[rv.UOI1Mutator]MSP[N] array [ size ++ ] = separator ; lastIsDirectory = false ; } for ( int i = prefix + 1 ; i < size ; i ++ ) {
System . arraycopy ( array , i + 1 , array , prefix , size - i ) ; MST[rv.UOI3Mutator]MSP[N] size -= i + 1 - prefix ; i = prefix + 1 ; } } if ( size <= 0 ) { return EMPTY_STRING ; }
final char ch = basePath . charAt ( len - 1 ) ; if ( isSeparator ( ch ) ) { MST[NegateConditionalsMutator]MSP[N] return normalize ( basePath + fullFileNameToAdd ) ; } return normalize ( basePath + '/' + fullFileNameToAdd ) ; }
for ( int i = 0 ; i < parts . length ; i ++ ) { MST[rv.UOI2Mutator]MSP[N] if ( parts [ i ] . length () == 0 ) { return i == parts . length - 1 ; }
final int pos = Math . min ( posUnix , posWin ) + 1 ; final String hostnamePart = fileName . substring ( 2 , pos - 1 ) ; return isValidHostName ( hostnamePart ) ? pos : NOT_FOUND ; MST[PrimitiveReturnsMutator]MSP[N] } else {
list . add ( lr_6 ) ; } else if ( prevChar != '*' ) { MST[rv.ROR2Mutator]MSP[N] list . add ( lr_7 ) ; } } else { buffer . append ( ch ) ; } prevChar = ch ; } if ( buffer . length () != 0 ) {
if ( validOctets > IPV6_MAX_HEX_GROUPS || ( validOctets < IPV6_MAX_HEX_GROUPS && ! containsCompressedZeroes ) ) { MST[InlineConstantMutator]MSP[N] return false ; } return true ; } private static boolean isRFC3986HostName ( final String name ) { final String [] parts = name . split ( lr_13 , - 1 ) ;
octetInt = Integer . parseInt ( octet , BASE_16 ) ; } catch ( final NumberFormatException e ) { return false ; } if ( octetInt < 0 || octetInt > MAX_UNSIGNED_SHORT ) { MST[rv.ROR1Mutator]MSP[N] return false ; } } validOctets ++ ; }
list . add ( buffer . toString () ) ; } return list . toArray ( new String [ list . size () ] ) ; } private static boolean isValidHostName ( final String name ) { return isIPv6Address ( name ) || isRFC3986HostName ( name ) ; MST[rv.ROR1Mutator]MSP[N] }
if ( len == 0 ) { return 0 ; } char ch0 = fileName . charAt ( 0 ) ; if ( ch0 == ':' ) { MST[rv.ROR2Mutator]MSP[N] return NOT_FOUND ; } if ( len == 1 ) { if ( ch0 == '~' ) { return 2 ; }
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2 ) { MST[rv.ROR1Mutator]MSP[N] return NOT_FOUND ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ;
return indexOfExtension ( fileName ) == NOT_FOUND ; } final String fileExt = getExtension ( fileName ) ; for ( final String extension : extensions ) { if ( fileExt . equals ( extension ) ) { MST[rv.ROR1Mutator]MSP[N] return true ; } } return false ; }
static boolean isSystemWindows () { return SYSTEM_SEPARATOR == WINDOWS_SEPARATOR ; MST[NegateConditionalsMutator]MSP[N] } private static boolean isSeparator ( final char ch ) { return ch == UNIX_SEPARATOR || ch == WINDOWS_SEPARATOR ; } public static String normalize ( final String fileName ) {
return doNormalize ( fileName , SYSTEM_SEPARATOR , true ) ; } public static String normalize ( final String fileName , final boolean unixSeparator ) { final char separator = unixSeparator ? UNIX_SEPARATOR : WINDOWS_SEPARATOR ; return doNormalize ( fileName , separator , true ) ; MST[rv.ABSMutator]MSP[N] }
final char ch1 = fileName . charAt ( 1 ) ; if ( ch1 == ':' ) { ch0 = Character . toUpperCase ( ch0 ) ; if ( ch0 >= 'A' && ch0 <= 'Z' ) { MST[NegateConditionalsMutator]MSP[N]
if ( array [ size - 1 ] != separator ) { MST[rv.CRCR4Mutator]MSP[N] array [ size ++ ] = separator ; lastIsDirectory = false ; } for ( int i = prefix + 1 ; i < size ; i ++ ) {
if ( repeat >= 0 ) { backtrack . push ( new int [] { wcsIdx , repeat } ) ; } } else { if ( ! caseSensitivity . checkRegionMatches ( fileName , textIdx , wcs [ wcsIdx ] ) ) { MST[rv.ROR1Mutator]MSP[N] break; } }
return new String ( array , 0 , size - 1 ) ; } public static String concat ( final String basePath , final String fullFileNameToAdd ) { final int prefix = getPrefixLength ( fullFileNameToAdd ) ; if ( prefix < 0 ) { MST[rv.UOI3Mutator]MSP[N] return null ; }
final String path = fileName . substring ( prefix , endIndex ) ; failIfNullBytePresent ( path ) ; return path ; MST[ReturnValsMutator]MSP[N] } public static String getFullPath ( final String fileName ) { return doGetFullPath ( fileName , true ) ; }
for ( int i = prefix + 1 ; i < size ; i ++ ) { if ( array [ i ] == separator && array [ i - 1 ] == '.' && MST[rv.ROR4Mutator]MSP[N]
list . add ( lr_6 ) ; } else if ( prevChar != '*' ) { MST[rv.CRCR5Mutator]MSP[S] list . add ( lr_7 ) ; } } else { buffer . append ( ch ) ; } prevChar = ch ; } if ( buffer . length () != 0 ) {
if ( array [ i ] == separator && array [ i - 1 ] == '.' && array [ i - 2 ] == '.' && MST[rv.ROR2Mutator]MSP[N] ( i == prefix + 2 || array [ i - 3 ] == separator ) ) {
anyChars = false ; } else if ( wcs [ wcsIdx ] . equals ( lr_7 ) ) { anyChars = true ; if ( wcsIdx == wcs . length - 1 ) { textIdx = fileName . length () ; } } else { if ( anyChars ) { MST[rv.ROR5Mutator]MSP[N]
for ( int i = 1 ; i <= 4 ; i ++ ) { final String ipSegment = m . group ( i ) ; final int iIpSegment = Integer . parseInt ( ipSegment ) ; if ( iIpSegment > IPV4_MAX_OCTET_VALUE ) { MST[rv.CRCR4Mutator]MSP[S] return false ; }
for ( int i = 1 ; i <= 4 ; i ++ ) { MST[NegateConditionalsMutator]MSP[N] final String ipSegment = m . group ( i ) ; final int iIpSegment = Integer . parseInt ( ipSegment ) ; if ( iIpSegment > IPV4_MAX_OCTET_VALUE ) { return false ; }
if ( array [ j ] == separator ) { System . arraycopy ( array , i + 1 , array , j + 1 , size - i ) ; MST[rv.AOR3Mutator]MSP[N] size -= i - j ; i = j + 1 ; continue outer; } }
if ( len < 0 ) { MST[rv.UOI1Mutator]MSP[N] return null ; } if ( len > fileName . length () ) { failIfNullBytePresent ( fileName + UNIX_SEPARATOR ) ; return fileName + UNIX_SEPARATOR ; } final String path = fileName . substring ( 0 , len ) ;
if ( array [ j ] == separator ) { System . arraycopy ( array , i + 1 , array , j + 1 , size - i ) ; MST[rv.AOR4Mutator]MSP[N] size -= i - j ; i = j + 1 ; continue outer; } }
final char ch = basePath . charAt ( len - 1 ) ; if ( isSeparator ( ch ) ) { return normalize ( basePath + fullFileNameToAdd ) ; MST[NonVoidMethodCallMutator]MSP[N] } return normalize ( basePath + '/' + fullFileNameToAdd ) ; }
textIdx += wcs [ wcsIdx ] . length () ; anyChars = false ; } wcsIdx ++ ; } if ( wcsIdx == wcs . length && textIdx == fileName . length () ) { return true ; MST[rv.CRCR5Mutator]MSP[N] } } while ( backtrack . size () > 0 );
if ( array [ j ] == separator ) { System . arraycopy ( array , i + 1 , array , j + 1 , size - i ) ; size -= i - j ; i = j + 1 ; MST[rv.ABSMutator]MSP[N] continue outer; } }
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND ) { return len + 1 ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ; MST[rv.ABSMutator]MSP[N] return Math . min ( posUnix , posWin ) + 1 ; }
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2 ) { return NOT_FOUND ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; MST[rv.UOI1Mutator]MSP[N] posWin = posWin == NOT_FOUND ? posUnix : posWin ;
return false ; } static String [] splitOnTokens ( final String text ) { if ( text . indexOf ( '?' ) == NOT_FOUND && text . indexOf ( '*' ) == NOT_FOUND ) { MST[rv.CRCR5Mutator]MSP[N] return new String [] { text } ; }
return new String ( array , 0 , size - 1 ) ; MST[rv.CRCR6Mutator]MSP[N] } public static String concat ( final String basePath , final String fullFileNameToAdd ) { final int prefix = getPrefixLength ( fullFileNameToAdd ) ; if ( prefix < 0 ) { return null ; }
textIdx += wcs [ wcsIdx ] . length () ; anyChars = false ; } wcsIdx ++ ; } if ( wcsIdx == wcs . length && textIdx == fileName . length () ) { return true ; MST[rv.CRCR2Mutator]MSP[N] } } while ( backtrack . size () > 0 );
if ( octet . length () == 0 ) { emptyOctets ++ ; if ( emptyOctets > 1 ) { return false ; } } else { emptyOctets = 0 ; if ( index == octets . length - 1 && octet . contains ( lr_12 ) ) { MST[rv.ROR3Mutator]MSP[N]
for ( int i = prefix + 1 ; i < size ; i ++ ) { if ( array [ i ] == separator && array [ i - 1 ] == '.' && MST[rv.ABSMutator]MSP[N]
if ( i == prefix + 2 ) { return null ; } if ( i == size - 1 ) { lastIsDirectory = true ; } int j ; for ( j = i - 4 ; j >= prefix ; j -- ) { MST[rv.AOR1Mutator]MSP[N]
octetInt = Integer . parseInt ( octet , BASE_16 ) ; } catch ( final NumberFormatException e ) { return false ; } if ( octetInt < 0 || octetInt > MAX_UNSIGNED_SHORT ) { MST[rv.ROR2Mutator]MSP[N] return false ; } } validOctets ++ ; }
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return NOT_FOUND ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ;
final int lastWindowsPos = fileName . lastIndexOf ( WINDOWS_SEPARATOR ) ; MST[rv.CRCR4Mutator]MSP[N] return Math . max ( lastUnixPos , lastWindowsPos ) ; } public static int indexOfExtension ( final String fileName ) throws IllegalArgumentException { if ( fileName == null ) { return NOT_FOUND ; }
list . add ( buffer . toString () ) ; } return list . toArray ( new String [ list . size () ] ) ; } private static boolean isValidHostName ( final String name ) { return isIPv6Address ( name ) || isRFC3986HostName ( name ) ; MST[rv.ROR5Mutator]MSP[N] }
private static boolean isIPv4Address ( final String name ) { final Matcher m = IPV4_PATTERN . matcher ( name ) ; if ( ! m . matches () || m . groupCount () != 4 ) { return false ; MST[rv.CRCR1Mutator]MSP[N] }
octetInt = Integer . parseInt ( octet , BASE_16 ) ; } catch ( final NumberFormatException e ) { return false ; } if ( octetInt < 0 || octetInt > MAX_UNSIGNED_SHORT ) { MST[rv.ROR5Mutator]MSP[N] return false ; } } validOctets ++ ; }
if ( len == 2 || isSeparator ( fileName . charAt ( 2 ) ) == false ) { return 2 ; } return 3 ; } else if ( ch0 == UNIX_SEPARATOR ) { MST[rv.CRCR2Mutator]MSP[N] return 1 ; } return NOT_FOUND ;
System . arraycopy ( array , i + 1 , array , i - 1 , size - i ) ; size -= 2 ; MST[IncrementsMutator]MSP[N] i -- ; } } outer: for ( int i = prefix + 2 ; i < size ; i ++ ) {
if ( fileName == null || wildcardMatcher == null ) { return false ; } if ( caseSensitivity == null ) { caseSensitivity = IOCase . SENSITIVE ; } final String [] wcs = splitOnTokens ( wildcardMatcher ) ; boolean anyChars = false ; MST[InlineConstantMutator]MSP[S] int textIdx = 0 ;
System . arraycopy ( array , i + 1 , array , prefix , size - i ) ; size -= i + 1 - prefix ; i = prefix + 1 ; MST[rv.UOI3Mutator]MSP[N] } } if ( size <= 0 ) { return EMPTY_STRING ; }
textIdx = array [ 1 ] ; anyChars = true ; } while ( wcsIdx < wcs . length ) { if ( wcs [ wcsIdx ] . equals ( lr_6 ) ) { textIdx ++ ; if ( textIdx > fileName . length () ) { MST[rv.UOI1Mutator]MSP[N] break; }
if ( array [ i ] == separator && array [ i - 1 ] == separator ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] System . arraycopy ( array , i , array , i - 1 , size - i ) ; size -- ; i -- ; } }
anyChars = false ; } else if ( wcs [ wcsIdx ] . equals ( lr_7 ) ) { anyChars = true ; if ( wcsIdx == wcs . length - 1 ) { textIdx = fileName . length () ; } } else { if ( anyChars ) { MST[rv.ROR2Mutator]MSP[N]
return doNormalize ( fileName , SYSTEM_SEPARATOR , true ) ; } public static String normalize ( final String fileName , final boolean unixSeparator ) { final char separator = unixSeparator ? UNIX_SEPARATOR : WINDOWS_SEPARATOR ; return doNormalize ( fileName , separator , true ) ; MST[rv.UOI2Mutator]MSP[S] }
if ( array [ size - 1 ] != separator ) { array [ size ++ ] = separator ; lastIsDirectory = false ; } for ( int i = prefix + 1 ; i < size ; i ++ ) { MST[rv.ROR4Mutator]MSP[N]
for ( int i = prefix + 1 ; i < size ; i ++ ) { MST[rv.ABSMutator]MSP[N] if ( array [ i ] == separator && array [ i - 1 ] == '.' &&
for ( int i = 0 ; i < array . length ; i ++ ) { MST[rv.UOI1Mutator]MSP[N] if ( array [ i ] == otherSeparator ) { array [ i ] = separator ; } } boolean lastIsDirectory = true ;
if ( path == null || path . indexOf ( UNIX_SEPARATOR ) == NOT_FOUND ) { MST[rv.CRCR5Mutator]MSP[S] return path ; } return path . replace ( UNIX_SEPARATOR , WINDOWS_SEPARATOR ) ; } public static String separatorsToSystem ( final String path ) { if ( path == null ) {
if ( len == 2 || isSeparator ( fileName . charAt ( 2 ) ) == false ) { return 2 ; } return 3 ; } else if ( ch0 == UNIX_SEPARATOR ) { return 1 ; } return NOT_FOUND ; MST[ReturnValsMutator]MSP[N]
final int prefix = getPrefixLength ( fileName ) ; if ( prefix < 0 ) { MST[rv.UOI2Mutator]MSP[N] return null ; } if ( prefix >= fileName . length () ) { if ( includeSeparator ) { return getPrefix ( fileName ) ; } return fileName ; }
return fileName . substring ( index + 1 ) ; MST[rv.UOI3Mutator]MSP[N] } private static void failIfNullBytePresent ( final String path ) { final int len = path . length () ; for ( int i = 0 ; i < len ; i ++ ) {
if ( array [ i ] == separator && array [ i - 1 ] == '.' && array [ i - 2 ] == '.' && MST[rv.AOR3Mutator]MSP[N] ( i == prefix + 2 || array [ i - 3 ] == separator ) ) {
return isSeparator ( ch0 ) ? 1 : 0 ; } if ( ch0 == '~' ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] int posUnix = fileName . indexOf ( UNIX_SEPARATOR , 1 ) ; int posWin = fileName . indexOf ( WINDOWS_SEPARATOR , 1 ) ;
System . arraycopy ( array , i + 1 , array , prefix , size - i ) ; MST[rv.CRCR3Mutator]MSP[N] size -= i + 1 - prefix ; i = prefix + 1 ; } } if ( size <= 0 ) { return EMPTY_STRING ; }
if ( prefix > 0 ) { return normalize ( fullFileNameToAdd ) ; } if ( basePath == null ) { return null ; } final int len = basePath . length () ; if ( len == 0 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return normalize ( fullFileNameToAdd ) ; }
for ( int i = 0 ; i < parts . length ; i ++ ) { if ( parts [ i ] . length () == 0 ) { return i == parts . length - 1 ; MST[rv.ROR3Mutator]MSP[N] }
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND ) { return len + 1 ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ; return Math . min ( posUnix , posWin ) + 1 ; MST[rv.AOR2Mutator]MSP[N] }
if ( ch == '?' || ch == '*' ) { MST[rv.ROR1Mutator]MSP[N] if ( buffer . length () != 0 ) { list . add ( buffer . toString () ) ; buffer . setLength ( 0 ) ; } if ( ch == '?' ) {
public static boolean isExtension ( final String fileName , final Collection < String > extensions ) { if ( fileName == null ) { return false ; } failIfNullBytePresent ( fileName ) ; if ( extensions == null || extensions . isEmpty () ) { MST[NonVoidMethodCallMutator]MSP[S]
if ( len == 0 ) { return 0 ; } char ch0 = fileName . charAt ( 0 ) ; MST[rv.CRCR3Mutator]MSP[N] if ( ch0 == ':' ) { return NOT_FOUND ; } if ( len == 1 ) { if ( ch0 == '~' ) { return 2 ; }
textIdx += wcs [ wcsIdx ] . length () ; anyChars = false ; MST[rv.CRCR1Mutator]MSP[N] } wcsIdx ++ ; } if ( wcsIdx == wcs . length && textIdx == fileName . length () ) { return true ; } } while ( backtrack . size () > 0 );
if ( IOCase . SYSTEM . checkEquals ( canonicalParent , canonicalChild ) ) { MST[NonVoidMethodCallMutator]MSP[S] return false ; } return IOCase . SYSTEM . checkStartsWith ( canonicalChild , canonicalParent ) ; } public static String separatorsToUnix ( final String path ) {
for ( int i = 1 ; i <= 4 ; i ++ ) { MST[rv.UOI3Mutator]MSP[N] final String ipSegment = m . group ( i ) ; final int iIpSegment = Integer . parseInt ( ipSegment ) ; if ( iIpSegment > IPV4_MAX_OCTET_VALUE ) { return false ; }
if ( containsCompressedZeroes && ( inet6Address . indexOf ( lr_9 ) != inet6Address . lastIndexOf ( lr_9 ) ) ) { return false ; } if ( ( inet6Address . startsWith ( lr_10 ) && ! inet6Address . startsWith ( lr_9 ) ) MST[rv.ROR3Mutator]MSP[N]
System . arraycopy ( array , i + 1 , array , prefix , size - i ) ; MST[MathMutator]MSP[N] size -= i + 1 - prefix ; i = prefix + 1 ; } } if ( size <= 0 ) { return EMPTY_STRING ; }
if ( len == 0 ) { return 0 ; } char ch0 = fileName . charAt ( 0 ) ; if ( ch0 == ':' ) { MST[rv.CRCR5Mutator]MSP[N] return NOT_FOUND ; } if ( len == 1 ) { if ( ch0 == '~' ) { return 2 ; }
if ( ch == '?' || ch == '*' ) { if ( buffer . length () != 0 ) { list . add ( buffer . toString () ) ; buffer . setLength ( 0 ) ; } if ( ch == '?' ) { MST[rv.ABSMutator]MSP[N]
String fileName1 , String fileName2 , final boolean normalized , IOCase caseSensitivity ) { if ( fileName1 == null || fileName2 == null ) { return fileName1 == null && fileName2 == null ; MST[NegateConditionalsMutator]MSP[N] } if ( normalized ) { fileName1 = normalize ( fileName1 ) ;
if ( len == 2 || isSeparator ( fileName . charAt ( 2 ) ) == false ) { return 2 ; MST[rv.CRCR4Mutator]MSP[N] } return 3 ; } else if ( ch0 == UNIX_SEPARATOR ) { return 1 ; } return NOT_FOUND ;
final char [] array = new char [ size + 2 ] ; fileName . getChars ( 0 , fileName . length () , array , 0 ) ; final char otherSeparator = separator == SYSTEM_SEPARATOR ? OTHER_SEPARATOR : SYSTEM_SEPARATOR ; MST[rv.UOI4Mutator]MSP[N]
final int index = indexOfLastSeparator ( fileName ) ; if ( index < 0 ) { return fileName . substring ( 0 , prefix ) ; MST[rv.CRCR5Mutator]MSP[N] } int end = index + ( includeSeparator ? 1 : 0 ) ; if ( end == 0 ) { end ++ ;
public static String getExtension ( final String fileName ) throws IllegalArgumentException { if ( fileName == null ) { return null ; } final int index = indexOfExtension ( fileName ) ; if ( index == NOT_FOUND ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return EMPTY_STRING ; }
private static boolean isIPv4Address ( final String name ) { final Matcher m = IPV4_PATTERN . matcher ( name ) ; if ( ! m . matches () || m . groupCount () != 4 ) { MST[rv.CRCR5Mutator]MSP[S] return false ; }
return isSeparator ( ch0 ) ? 1 : 0 ; MST[NegateConditionalsMutator]MSP[N] } } public static int indexOfLastSeparator ( final String fileName ) { if ( fileName == null ) { return NOT_FOUND ; } final int lastUnixPos = fileName . lastIndexOf ( UNIX_SEPARATOR ) ;
if ( i == prefix + 2 ) { return null ; } if ( i == size - 1 ) { MST[rv.AOR3Mutator]MSP[S] lastIsDirectory = true ; } int j ; for ( j = i - 4 ; j >= prefix ; j -- ) {
if ( prefix > 0 ) { return normalize ( fullFileNameToAdd ) ; } if ( basePath == null ) { return null ; } final int len = basePath . length () ; MST[NonVoidMethodCallMutator]MSP[N] if ( len == 0 ) { return normalize ( fullFileNameToAdd ) ; }
return indexOfExtension ( fileName ) == NOT_FOUND ; } final String fileExt = getExtension ( fileName ) ; for ( final String extension : extensions ) { if ( fileExt . equals ( extension ) ) { return true ; MST[BooleanFalseReturnValsMutator]MSP[N] } } return false ; }
if ( octet . length () == 0 ) { emptyOctets ++ ; if ( emptyOctets > 1 ) { return false ; } } else { emptyOctets = 0 ; if ( index == octets . length - 1 && octet . contains ( lr_12 ) ) { MST[rv.AOR1Mutator]MSP[S]
( i == prefix + 1 || array [ i - 2 ] == separator ) ) { if ( i == size - 1 ) { MST[rv.CRCR3Mutator]MSP[N] lastIsDirectory = true ; }
octetInt = Integer . parseInt ( octet , BASE_16 ) ; } catch ( final NumberFormatException e ) { return false ; } if ( octetInt < 0 || octetInt > MAX_UNSIGNED_SHORT ) { MST[rv.ROR4Mutator]MSP[N] return false ; } } validOctets ++ ; }
final int index = indexOfLastSeparator ( fileName ) ; final int endIndex = index + separatorAdd ; if ( prefix >= fileName . length () || index < 0 || prefix >= endIndex ) { MST[rv.UOI3Mutator]MSP[N] return EMPTY_STRING ; }
System . arraycopy ( array , i + 1 , array , i - 1 , size - i ) ; MST[rv.AOD2Mutator]MSP[N] size -= 2 ; i -- ; } } outer: for ( int i = prefix + 2 ; i < size ; i ++ ) {
if ( ch == '?' || ch == '*' ) { MST[rv.ROR3Mutator]MSP[N] if ( buffer . length () != 0 ) { list . add ( buffer . toString () ) ; buffer . setLength ( 0 ) ; } if ( ch == '?' ) {
if ( ch == '?' || ch == '*' ) { MST[rv.ROR4Mutator]MSP[N] if ( buffer . length () != 0 ) { list . add ( buffer . toString () ) ; buffer . setLength ( 0 ) ; } if ( ch == '?' ) {
if ( octets . length > IPV6_MAX_HEX_GROUPS ) { MST[rv.CRCR2Mutator]MSP[N] return false ; } int validOctets = 0 ; int emptyOctets = 0 ; for ( int index = 0 ; index < octets . length ; index ++ ) { final String octet = octets [ index ] ;
if ( len == 2 || isSeparator ( fileName . charAt ( 2 ) ) == false ) { return 2 ; } return 3 ; } else if ( ch0 == UNIX_SEPARATOR ) { return 1 ; } return NOT_FOUND ; MST[rv.CRCR5Mutator]MSP[N]
if ( octets . length > IPV6_MAX_HEX_GROUPS ) { return false ; } int validOctets = 0 ; MST[rv.CRCR5Mutator]MSP[N] int emptyOctets = 0 ; for ( int index = 0 ; index < octets . length ; index ++ ) { final String octet = octets [ index ] ;
return null ; } return isSystemWindows () ? separatorsToWindows ( path ) : separatorsToUnix ( path ) ; } public static int getPrefixLength ( final String fileName ) { if ( fileName == null ) { return NOT_FOUND ; MST[rv.CRCR2Mutator]MSP[N] } final int len = fileName . length () ;
return new String ( array , 0 , size - 1 ) ; MST[EmptyObjectReturnValsMutator]MSP[N] } public static String concat ( final String basePath , final String fullFileNameToAdd ) { final int prefix = getPrefixLength ( fullFileNameToAdd ) ; if ( prefix < 0 ) { return null ; }
return indexOfExtension ( fileName ) == NOT_FOUND ; } final String fileExt = getExtension ( fileName ) ; for ( final String extension : extensions ) { if ( fileExt . equals ( extension ) ) { MST[rv.ROR4Mutator]MSP[N] return true ; } } return false ; }
for ( int i = 0 ; i < array . length ; i ++ ) { MST[rv.UOI4Mutator]MSP[N] if ( array [ i ] == otherSeparator ) { array [ i ] = separator ; } } boolean lastIsDirectory = true ;
if ( path == null || path . indexOf ( UNIX_SEPARATOR ) == NOT_FOUND ) { MST[rv.CRCR2Mutator]MSP[S] return path ; } return path . replace ( UNIX_SEPARATOR , WINDOWS_SEPARATOR ) ; } public static String separatorsToSystem ( final String path ) { if ( path == null ) {
( i == prefix + 1 || array [ i - 2 ] == separator ) ) { if ( i == size - 1 ) { MST[MathMutator]MSP[N] lastIsDirectory = true ; }
if ( containsCompressedZeroes && ( inet6Address . indexOf ( lr_9 ) != inet6Address . lastIndexOf ( lr_9 ) ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return false ; } if ( ( inet6Address . startsWith ( lr_10 ) && ! inet6Address . startsWith ( lr_9 ) )
textIdx = array [ 1 ] ; anyChars = true ; } while ( wcsIdx < wcs . length ) { MST[rv.UOI1Mutator]MSP[N] if ( wcs [ wcsIdx ] . equals ( lr_6 ) ) { textIdx ++ ; if ( textIdx > fileName . length () ) { break; }
if ( IOCase . SYSTEM . checkEquals ( canonicalParent , canonicalChild ) ) { MST[rv.ROR5Mutator]MSP[N] return false ; } return IOCase . SYSTEM . checkStartsWith ( canonicalChild , canonicalParent ) ; } public static String separatorsToUnix ( final String path ) {
return doNormalize ( fileName , SYSTEM_SEPARATOR , true ) ; } public static String normalize ( final String fileName , final boolean unixSeparator ) { final char separator = unixSeparator ? UNIX_SEPARATOR : WINDOWS_SEPARATOR ; return doNormalize ( fileName , separator , true ) ; MST[InlineConstantMutator]MSP[N] }
if ( array [ j ] == separator ) { System . arraycopy ( array , i + 1 , array , j + 1 , size - i ) ; MST[rv.ABSMutator]MSP[N] size -= i - j ; i = j + 1 ; continue outer; } }
if ( ! isIPv4Address ( octet ) ) { return false ; } validOctets += 2 ; continue; } if ( octet . length () > IPV6_MAX_HEX_DIGITS_PER_GROUP ) { MST[rv.ROR2Mutator]MSP[N] return false ; } int octetInt = 0 ; try {
public static boolean isExtension ( final String fileName , final String ... extensions ) { if ( fileName == null ) { return false ; MST[ReturnValsMutator]MSP[N] } failIfNullBytePresent ( fileName ) ; if ( extensions == null || extensions . length == 0 ) {
System . arraycopy ( array , i + 1 , array , i - 1 , size - i ) ; MST[rv.AOD1Mutator]MSP[N] size -= 2 ; i -- ; } } outer: for ( int i = prefix + 2 ; i < size ; i ++ ) {
return indexOfExtension ( fileName ) == NOT_FOUND ; MST[rv.ROR4Mutator]MSP[N] } final String fileExt = getExtension ( fileName ) ; for ( final String extension : extensions ) { if ( fileExt . equals ( extension ) ) { return true ; } } return false ; }
final int pos = Math . min ( posUnix , posWin ) + 1 ; final String hostnamePart = fileName . substring ( 2 , pos - 1 ) ; return isValidHostName ( hostnamePart ) ? pos : NOT_FOUND ; MST[rv.CRCR4Mutator]MSP[N] } else {
if ( containsCompressedZeroes && ( inet6Address . indexOf ( lr_9 ) != inet6Address . lastIndexOf ( lr_9 ) ) ) { return false ; MST[rv.CRCR5Mutator]MSP[S] } if ( ( inet6Address . startsWith ( lr_10 ) && ! inet6Address . startsWith ( lr_9 ) )
if ( len == 2 || isSeparator ( fileName . charAt ( 2 ) ) == false ) { return 2 ; } return 3 ; } else if ( ch0 == UNIX_SEPARATOR ) { return 1 ; MST[InlineConstantMutator]MSP[S] } return NOT_FOUND ;
textIdx += wcs [ wcsIdx ] . length () ; anyChars = false ; } wcsIdx ++ ; } if ( wcsIdx == wcs . length && textIdx == fileName . length () ) { return true ; } } while ( backtrack . size () > 0 ); MST[rv.ROR1Mutator]MSP[N]
return equals ( fileName1 , fileName2 , true , IOCase . SENSITIVE ) ; } public static boolean equalsNormalizedOnSystem ( final String fileName1 , final String fileName2 ) { return equals ( fileName1 , fileName2 , true , IOCase . SYSTEM ) ; MST[InlineConstantMutator]MSP[S] } public static boolean equals (
static boolean isSystemWindows () { return SYSTEM_SEPARATOR == WINDOWS_SEPARATOR ; } private static boolean isSeparator ( final char ch ) { return ch == UNIX_SEPARATOR || ch == WINDOWS_SEPARATOR ; MST[rv.UOI4Mutator]MSP[N] } public static String normalize ( final String fileName ) {
if ( ! isIPv4Address ( octet ) ) { return false ; } validOctets += 2 ; continue; } if ( octet . length () > IPV6_MAX_HEX_DIGITS_PER_GROUP ) { MST[rv.CRCR5Mutator]MSP[N] return false ; } int octetInt = 0 ; try {
if ( array [ size - 1 ] != separator ) { MST[rv.ROR5Mutator]MSP[N] array [ size ++ ] = separator ; lastIsDirectory = false ; } for ( int i = prefix + 1 ; i < size ; i ++ ) {
if ( IOCase . SYSTEM . checkEquals ( canonicalParent , canonicalChild ) ) { return false ; } return IOCase . SYSTEM . checkStartsWith ( canonicalChild , canonicalParent ) ; MST[BooleanTrueReturnValsMutator]MSP[S] } public static String separatorsToUnix ( final String path ) {
if ( array [ i ] == separator && array [ i - 1 ] == separator ) { System . arraycopy ( array , i , array , i - 1 , size - i ) ; MST[rv.CRCR3Mutator]MSP[N] size -- ; i -- ; } }
if ( len == 0 ) { return 0 ; } char ch0 = fileName . charAt ( 0 ) ; if ( ch0 == ':' ) { return NOT_FOUND ; } if ( len == 1 ) { if ( ch0 == '~' ) { MST[rv.UOI3Mutator]MSP[N] return 2 ; }
if ( len < 0 ) { return null ; } if ( len > fileName . length () ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] failIfNullBytePresent ( fileName + UNIX_SEPARATOR ) ; return fileName + UNIX_SEPARATOR ; } final String path = fileName . substring ( 0 , len ) ;
final int index = indexOfLastSeparator ( fileName ) ; if ( index < 0 ) { return fileName . substring ( 0 , prefix ) ; } int end = index + ( includeSeparator ? 1 : 0 ) ; MST[rv.CRCR1Mutator]MSP[N] if ( end == 0 ) { end ++ ;
if ( len == 2 || isSeparator ( fileName . charAt ( 2 ) ) == false ) { MST[rv.ABSMutator]MSP[N] return 2 ; } return 3 ; } else if ( ch0 == UNIX_SEPARATOR ) { return 1 ; } return NOT_FOUND ;
if ( array [ j ] == separator ) { System . arraycopy ( array , i + 1 , array , j + 1 , size - i ) ; MST[rv.AOR1Mutator]MSP[N] size -= i - j ; i = j + 1 ; continue outer; } }
return indexOfExtension ( fileName ) == NOT_FOUND ; MST[rv.CRCR1Mutator]MSP[N] } final String fileExt = getExtension ( fileName ) ; for ( final String extension : extensions ) { if ( fileExt . equals ( extension ) ) { return true ; } } return false ; }
final int lastWindowsPos = fileName . lastIndexOf ( WINDOWS_SEPARATOR ) ; return Math . max ( lastUnixPos , lastWindowsPos ) ; MST[rv.UOI2Mutator]MSP[N] } public static int indexOfExtension ( final String fileName ) throws IllegalArgumentException { if ( fileName == null ) { return NOT_FOUND ; }
final int lastWindowsPos = fileName . lastIndexOf ( WINDOWS_SEPARATOR ) ; return Math . max ( lastUnixPos , lastWindowsPos ) ; } public static int indexOfExtension ( final String fileName ) throws IllegalArgumentException { if ( fileName == null ) { return NOT_FOUND ; MST[ReturnValsMutator]MSP[N] }
final char ch1 = fileName . charAt ( 1 ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( ch1 == ':' ) { ch0 = Character . toUpperCase ( ch0 ) ; if ( ch0 >= 'A' && ch0 <= 'Z' ) {
final int index = indexOfLastSeparator ( fileName ) ; final int endIndex = index + separatorAdd ; if ( prefix >= fileName . length () || index < 0 || prefix >= endIndex ) { MST[rv.UOI1Mutator]MSP[N] return EMPTY_STRING ; }
if ( ch == '?' || ch == '*' ) { if ( buffer . length () != 0 ) { MST[rv.ROR3Mutator]MSP[N] list . add ( buffer . toString () ) ; buffer . setLength ( 0 ) ; } if ( ch == '?' ) {
public static String getExtension ( final String fileName ) throws IllegalArgumentException { if ( fileName == null ) { return null ; } final int index = indexOfExtension ( fileName ) ; if ( index == NOT_FOUND ) { MST[rv.ROR1Mutator]MSP[N] return EMPTY_STRING ; }
octetInt = Integer . parseInt ( octet , BASE_16 ) ; MST[InlineConstantMutator]MSP[S] } catch ( final NumberFormatException e ) { return false ; } if ( octetInt < 0 || octetInt > MAX_UNSIGNED_SHORT ) { return false ; } } validOctets ++ ; }
return isSeparator ( ch0 ) ? 1 : 0 ; } if ( ch0 == '~' ) { int posUnix = fileName . indexOf ( UNIX_SEPARATOR , 1 ) ; MST[rv.CRCR3Mutator]MSP[N] int posWin = fileName . indexOf ( WINDOWS_SEPARATOR , 1 ) ;
for ( int i = prefix + 1 ; i < size ; i ++ ) { if ( array [ i ] == separator && array [ i - 1 ] == '.' && MST[rv.UOI1Mutator]MSP[N]
if ( array [ i ] == separator && array [ i - 1 ] == '.' && array [ i - 2 ] == '.' && MST[rv.ROR5Mutator]MSP[N] ( i == prefix + 2 || array [ i - 3 ] == separator ) ) {
anyChars = false ; } else if ( wcs [ wcsIdx ] . equals ( lr_7 ) ) { anyChars = true ; if ( wcsIdx == wcs . length - 1 ) { textIdx = fileName . length () ; } } else { if ( anyChars ) { MST[rv.UOI1Mutator]MSP[N]
for ( int i = 1 ; i <= 4 ; i ++ ) { final String ipSegment = m . group ( i ) ; final int iIpSegment = Integer . parseInt ( ipSegment ) ; if ( iIpSegment > IPV4_MAX_OCTET_VALUE ) { MST[rv.CRCR1Mutator]MSP[S] return false ; }
return new String ( array , 0 , size - 1 ) ; } public static String concat ( final String basePath , final String fullFileNameToAdd ) { final int prefix = getPrefixLength ( fullFileNameToAdd ) ; if ( prefix < 0 ) { MST[rv.ROR1Mutator]MSP[N] return null ; }
if ( fileName == null || wildcardMatcher == null ) { return false ; } if ( caseSensitivity == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] caseSensitivity = IOCase . SENSITIVE ; } final String [] wcs = splitOnTokens ( wildcardMatcher ) ; boolean anyChars = false ; int textIdx = 0 ;
if ( octets . length > IPV6_MAX_HEX_GROUPS ) { return false ; MST[BooleanTrueReturnValsMutator]MSP[S] } int validOctets = 0 ; int emptyOctets = 0 ; for ( int index = 0 ; index < octets . length ; index ++ ) { final String octet = octets [ index ] ;
public static String getFullPathNoEndSeparator ( final String fileName ) { return doGetFullPath ( fileName , false ) ; MST[rv.CRCR5Mutator]MSP[N] } private static String doGetFullPath ( final String fileName , final boolean includeSeparator ) { if ( fileName == null ) { return null ; }
static boolean isSystemWindows () { return SYSTEM_SEPARATOR == WINDOWS_SEPARATOR ; } private static boolean isSeparator ( final char ch ) { return ch == UNIX_SEPARATOR || ch == WINDOWS_SEPARATOR ; MST[rv.UOI3Mutator]MSP[N] } public static String normalize ( final String fileName ) {
if ( extension == null || extension . isEmpty () ) { return indexOfExtension ( fileName ) == NOT_FOUND ; MST[rv.CRCR4Mutator]MSP[N] } final String fileExt = getExtension ( fileName ) ; return fileExt . equals ( extension ) ; }
if ( path == null || path . indexOf ( WINDOWS_SEPARATOR ) == NOT_FOUND ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return path ; } return path . replace ( WINDOWS_SEPARATOR , UNIX_SEPARATOR ) ; } public static String separatorsToWindows ( final String path ) {
if ( len == 0 ) { return 0 ; MST[rv.CRCR1Mutator]MSP[N] } char ch0 = fileName . charAt ( 0 ) ; if ( ch0 == ':' ) { return NOT_FOUND ; } if ( len == 1 ) { if ( ch0 == '~' ) { return 2 ; }
private static boolean isIPv4Address ( final String name ) { final Matcher m = IPV4_PATTERN . matcher ( name ) ; if ( ! m . matches () || m . groupCount () != 4 ) { MST[rv.ROR2Mutator]MSP[N] return false ; }
return indexOfExtension ( fileName ) == NOT_FOUND ; } final String fileExt = getExtension ( fileName ) ; for ( final String extension : extensions ) { if ( fileExt . equals ( extension ) ) { return true ; MST[BooleanFalseReturnValsMutator]MSP[N] } } return false ; }
if ( array [ size - 1 ] != separator ) { MST[rv.UOI4Mutator]MSP[N] array [ size ++ ] = separator ; lastIsDirectory = false ; } for ( int i = prefix + 1 ; i < size ; i ++ ) {
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2 ) { MST[rv.CRCR1Mutator]MSP[N] return NOT_FOUND ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ;
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2 ) { MST[rv.ROR4Mutator]MSP[N] return NOT_FOUND ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ;
textIdx += wcs [ wcsIdx ] . length () ; anyChars = false ; } wcsIdx ++ ; } if ( wcsIdx == wcs . length && textIdx == fileName . length () ) { MST[NegateConditionalsMutator]MSP[N] return true ; } } while ( backtrack . size () > 0 );
for ( int i = prefix + 1 ; i < size ; i ++ ) { if ( array [ i ] == separator && array [ i - 1 ] == '.' && MST[rv.UOI1Mutator]MSP[N]
if ( prefix > 0 ) { return normalize ( fullFileNameToAdd ) ; } if ( basePath == null ) { return null ; } final int len = basePath . length () ; if ( len == 0 ) { MST[rv.ROR3Mutator]MSP[N] return normalize ( fullFileNameToAdd ) ; }
return indexOfExtension ( fileName ) == NOT_FOUND ; } final String fileExt = getExtension ( fileName ) ; for ( final String extension : extensions ) { if ( fileExt . equals ( extension ) ) { MST[rv.ROR4Mutator]MSP[N] return true ; } } return false ; }
( i == prefix + 1 || array [ i - 2 ] == separator ) ) { if ( i == size - 1 ) { MST[rv.CRCR6Mutator]MSP[N] lastIsDirectory = true ; }
if ( validOctets > IPV6_MAX_HEX_GROUPS || ( validOctets < IPV6_MAX_HEX_GROUPS && ! containsCompressedZeroes ) ) { MST[rv.CRCR6Mutator]MSP[N] return false ; } return true ; } private static boolean isRFC3986HostName ( final String name ) { final String [] parts = name . split ( lr_13 , - 1 ) ;
System . arraycopy ( array , i + 1 , array , prefix , size - i ) ; MST[rv.CRCR6Mutator]MSP[N] size -= i + 1 - prefix ; i = prefix + 1 ; } } if ( size <= 0 ) { return EMPTY_STRING ; }
final int prefix = getPrefixLength ( fileName ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( prefix < 0 ) { return null ; } if ( prefix >= fileName . length () ) { if ( includeSeparator ) { return getPrefix ( fileName ) ; } return fileName ; }
if ( validOctets > IPV6_MAX_HEX_GROUPS || ( validOctets < IPV6_MAX_HEX_GROUPS && ! containsCompressedZeroes ) ) { MST[rv.ROR4Mutator]MSP[N] return false ; } return true ; } private static boolean isRFC3986HostName ( final String name ) { final String [] parts = name . split ( lr_13 , - 1 ) ;
if ( validOctets > IPV6_MAX_HEX_GROUPS || ( validOctets < IPV6_MAX_HEX_GROUPS && ! containsCompressedZeroes ) ) { MST[rv.ROR3Mutator]MSP[N] return false ; } return true ; } private static boolean isRFC3986HostName ( final String name ) { final String [] parts = name . split ( lr_13 , - 1 ) ;
if ( array [ i ] == separator && array [ i - 1 ] == separator ) { MST[NegateConditionalsMutator]MSP[N] System . arraycopy ( array , i , array , i - 1 , size - i ) ; size -- ; i -- ; } }
String fileName1 , String fileName2 , final boolean normalized , IOCase caseSensitivity ) { if ( fileName1 == null || fileName2 == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return fileName1 == null && fileName2 == null ; } if ( normalized ) { fileName1 = normalize ( fileName1 ) ;
for ( int i = 0 ; i < array . length ; i ++ ) { if ( array [ i ] == otherSeparator ) { array [ i ] = separator ; } } boolean lastIsDirectory = true ; MST[rv.CRCR2Mutator]MSP[N]
return null ; } return isSystemWindows () ? separatorsToWindows ( path ) : separatorsToUnix ( path ) ; } public static int getPrefixLength ( final String fileName ) { if ( fileName == null ) { return NOT_FOUND ; MST[ReturnValsMutator]MSP[N] } final int len = fileName . length () ;
if ( size <= prefix ) { return new String ( array , 0 , size ) ; } if ( lastIsDirectory && keepSeparator ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return new String ( array , 0 , size ) ; }
return false ; } static String [] splitOnTokens ( final String text ) { if ( text . indexOf ( '?' ) == NOT_FOUND && text . indexOf ( '*' ) == NOT_FOUND ) { MST[rv.ROR2Mutator]MSP[N] return new String [] { text } ; }
return doNormalize ( fileName , SYSTEM_SEPARATOR , true ) ; } public static String normalize ( final String fileName , final boolean unixSeparator ) { final char separator = unixSeparator ? UNIX_SEPARATOR : WINDOWS_SEPARATOR ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return doNormalize ( fileName , separator , true ) ; }
final int prefix = getPrefixLength ( fileName ) ; if ( prefix < 0 ) { MST[rv.ABSMutator]MSP[N] return null ; } if ( prefix >= fileName . length () ) { if ( includeSeparator ) { return getPrefix ( fileName ) ; } return fileName ; }
anyChars = false ; } else if ( wcs [ wcsIdx ] . equals ( lr_7 ) ) { anyChars = true ; if ( wcsIdx == wcs . length - 1 ) { MST[rv.ROR4Mutator]MSP[N] textIdx = fileName . length () ; } } else { if ( anyChars ) {
if ( validOctets > IPV6_MAX_HEX_GROUPS || ( validOctets < IPV6_MAX_HEX_GROUPS && ! containsCompressedZeroes ) ) { MST[rv.UOI1Mutator]MSP[N] return false ; } return true ; } private static boolean isRFC3986HostName ( final String name ) { final String [] parts = name . split ( lr_13 , - 1 ) ;
return indexOfExtension ( fileName ) == NOT_FOUND ; } final String fileExt = getExtension ( fileName ) ; MST[NonVoidMethodCallMutator]MSP[N] for ( final String extension : extensions ) { if ( fileExt . equals ( extension ) ) { return true ; } } return false ; }
} else if ( isSeparator ( ch0 ) && isSeparator ( ch1 ) ) { int posUnix = fileName . indexOf ( UNIX_SEPARATOR , 2 ) ; int posWin = fileName . indexOf ( WINDOWS_SEPARATOR , 2 ) ; MST[rv.CRCR1Mutator]MSP[N]
if ( containsCompressedZeroes && ( inet6Address . indexOf ( lr_9 ) != inet6Address . lastIndexOf ( lr_9 ) ) ) { MST[NegateConditionalsMutator]MSP[N] return false ; } if ( ( inet6Address . startsWith ( lr_10 ) && ! inet6Address . startsWith ( lr_9 ) )
octetInt = Integer . parseInt ( octet , BASE_16 ) ; MST[rv.CRCR4Mutator]MSP[N] } catch ( final NumberFormatException e ) { return false ; } if ( octetInt < 0 || octetInt > MAX_UNSIGNED_SHORT ) { return false ; } } validOctets ++ ; }
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND ) { return len + 1 ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ; MST[rv.UOI4Mutator]MSP[N] return Math . min ( posUnix , posWin ) + 1 ; }
if ( array [ i ] == separator && array [ i - 1 ] == '.' && array [ i - 2 ] == '.' && MST[rv.ABSMutator]MSP[N] ( i == prefix + 2 || array [ i - 3 ] == separator ) ) {
if ( validOctets > IPV6_MAX_HEX_GROUPS || ( validOctets < IPV6_MAX_HEX_GROUPS && ! containsCompressedZeroes ) ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] return false ; } return true ; } private static boolean isRFC3986HostName ( final String name ) { final String [] parts = name . split ( lr_13 , - 1 ) ;
return false ; } static String [] splitOnTokens ( final String text ) { if ( text . indexOf ( '?' ) == NOT_FOUND && text . indexOf ( '*' ) == NOT_FOUND ) { MST[rv.CRCR2Mutator]MSP[N] return new String [] { text } ; }
return isSeparator ( ch0 ) ? 1 : 0 ; MST[rv.CRCR3Mutator]MSP[N] } } public static int indexOfLastSeparator ( final String fileName ) { if ( fileName == null ) { return NOT_FOUND ; } final int lastUnixPos = fileName . lastIndexOf ( UNIX_SEPARATOR ) ;
if ( ch == '?' || ch == '*' ) { MST[rv.CRCR4Mutator]MSP[N] if ( buffer . length () != 0 ) { list . add ( buffer . toString () ) ; buffer . setLength ( 0 ) ; } if ( ch == '?' ) {
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND ) { return len + 1 ; MST[PrimitiveReturnsMutator]MSP[N] } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ; return Math . min ( posUnix , posWin ) + 1 ; }
if ( array [ i ] == separator && array [ i - 1 ] == '.' && array [ i - 2 ] == '.' && MST[rv.CRCR3Mutator]MSP[N] ( i == prefix + 2 || array [ i - 3 ] == separator ) ) {
if ( i == prefix + 2 ) { return null ; } if ( i == size - 1 ) { lastIsDirectory = true ; } int j ; for ( j = i - 4 ; j >= prefix ; j -- ) { MST[rv.UOI3Mutator]MSP[N]
final int pos = Math . min ( posUnix , posWin ) + 1 ; final String hostnamePart = fileName . substring ( 2 , pos - 1 ) ; MST[rv.UOI4Mutator]MSP[N] return isValidHostName ( hostnamePart ) ? pos : NOT_FOUND ; } else {
textIdx += wcs [ wcsIdx ] . length () ; anyChars = false ; } wcsIdx ++ ; } if ( wcsIdx == wcs . length && textIdx == fileName . length () ) { MST[rv.ROR2Mutator]MSP[N] return true ; } } while ( backtrack . size () > 0 );
for ( int i = 0 ; i < parts . length ; i ++ ) { MST[rv.ABSMutator]MSP[N] if ( parts [ i ] . length () == 0 ) { return i == parts . length - 1 ; }
octetInt = Integer . parseInt ( octet , BASE_16 ) ; } catch ( final NumberFormatException e ) { return false ; } if ( octetInt < 0 || octetInt > MAX_UNSIGNED_SHORT ) { MST[rv.UOI3Mutator]MSP[N] return false ; } } validOctets ++ ; }
if ( octet . length () == 0 ) { emptyOctets ++ ; if ( emptyOctets > 1 ) { return false ; } } else { emptyOctets = 0 ; if ( index == octets . length - 1 && octet . contains ( lr_12 ) ) { MST[rv.ABSMutator]MSP[S]
final char ch1 = fileName . charAt ( 1 ) ; if ( ch1 == ':' ) { ch0 = Character . toUpperCase ( ch0 ) ; if ( ch0 >= 'A' && ch0 <= 'Z' ) { MST[rv.UOI1Mutator]MSP[N]
if ( array [ j ] == separator ) { System . arraycopy ( array , i + 1 , array , j + 1 , size - i ) ; MST[rv.CRCR5Mutator]MSP[N] size -= i - j ; i = j + 1 ; continue outer; } }
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND ) { return len + 1 ; MST[rv.UOI3Mutator]MSP[N] } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ; return Math . min ( posUnix , posWin ) + 1 ; }
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2 ) { MST[rv.ROR3Mutator]MSP[N] return NOT_FOUND ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ;
list . add ( buffer . toString () ) ; } return list . toArray ( new String [ list . size () ] ) ; } private static boolean isValidHostName ( final String name ) { return isIPv6Address ( name ) || isRFC3986HostName ( name ) ; MST[rv.ROR2Mutator]MSP[N] }
if ( ! isIPv4Address ( octet ) ) { return false ; MST[rv.CRCR6Mutator]MSP[N] } validOctets += 2 ; continue; } if ( octet . length () > IPV6_MAX_HEX_DIGITS_PER_GROUP ) { return false ; } int octetInt = 0 ; try {
if ( array [ i ] == separator && array [ i - 1 ] == '.' && array [ i - 2 ] == '.' && MST[InlineConstantMutator]MSP[N] ( i == prefix + 2 || array [ i - 3 ] == separator ) ) {
return indexOfExtension ( fileName ) == NOT_FOUND ; MST[rv.CRCR3Mutator]MSP[S] } final String fileExt = getExtension ( fileName ) ; for ( final String extension : extensions ) { if ( fileExt . equals ( extension ) ) { return true ; } } return false ; }
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return NOT_FOUND ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ;
if ( array [ i ] == separator && array [ i - 1 ] == separator ) { System . arraycopy ( array , i , array , i - 1 , size - i ) ; MST[MathMutator]MSP[N] size -- ; i -- ; } }
for ( int i = 0 ; i < parts . length ; i ++ ) { if ( parts [ i ] . length () == 0 ) { return i == parts . length - 1 ; MST[rv.AOD1Mutator]MSP[N] }
public static String normalizeNoEndSeparator ( final String fileName ) { return doNormalize ( fileName , SYSTEM_SEPARATOR , false ) ; } public static String normalizeNoEndSeparator ( final String fileName , final boolean unixSeparator ) { final char separator = unixSeparator ? UNIX_SEPARATOR : WINDOWS_SEPARATOR ; MST[rv.ROR4Mutator]MSP[S]
final String path = fileName . substring ( prefix , endIndex ) ; failIfNullBytePresent ( path ) ; return path ; } public static String getFullPath ( final String fileName ) { return doGetFullPath ( fileName , true ) ; MST[ArgumentPropagationMutator]MSP[N] }
textIdx = caseSensitivity . checkIndexOf ( fileName , textIdx , wcs [ wcsIdx ] ) ; MST[rv.UOI3Mutator]MSP[S] if ( textIdx == NOT_FOUND ) { break; } final int repeat = caseSensitivity . checkIndexOf ( fileName , textIdx + 1 , wcs [ wcsIdx ] ) ;
System . arraycopy ( array , i + 1 , array , prefix , size - i ) ; size -= i + 1 - prefix ; i = prefix + 1 ; MST[rv.AOR1Mutator]MSP[N] } } if ( size <= 0 ) { return EMPTY_STRING ; }
return isSeparator ( ch0 ) ? 1 : 0 ; } if ( ch0 == '~' ) { int posUnix = fileName . indexOf ( UNIX_SEPARATOR , 1 ) ; int posWin = fileName . indexOf ( WINDOWS_SEPARATOR , 1 ) ; MST[rv.CRCR5Mutator]MSP[N]
octetInt = Integer . parseInt ( octet , BASE_16 ) ; } catch ( final NumberFormatException e ) { return false ; } if ( octetInt < 0 || octetInt > MAX_UNSIGNED_SHORT ) { MST[rv.CRCR5Mutator]MSP[N] return false ; } } validOctets ++ ; }
if ( array [ size - 1 ] != separator ) { array [ size ++ ] = separator ; MST[experimental.RemoveIncrementsMutator]MSP[N] lastIsDirectory = false ; } for ( int i = prefix + 1 ; i < size ; i ++ ) {
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2 ) { return NOT_FOUND ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ; MST[rv.UOI3Mutator]MSP[N]
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2 ) { return NOT_FOUND ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ; MST[rv.UOI2Mutator]MSP[N]
if ( octets . length > IPV6_MAX_HEX_GROUPS ) { return false ; } int validOctets = 0 ; int emptyOctets = 0 ; for ( int index = 0 ; index < octets . length ; index ++ ) { MST[rv.ROR1Mutator]MSP[N] final String octet = octets [ index ] ;
if ( array [ size - 1 ] != separator ) { array [ size ++ ] = separator ; lastIsDirectory = false ; MST[rv.CRCR3Mutator]MSP[N] } for ( int i = prefix + 1 ; i < size ; i ++ ) {
return fileName . substring ( index + 1 ) ; MST[rv.AOR2Mutator]MSP[N] } private static int getAdsCriticalOffset ( final String fileName ) { final int offset1 = fileName . lastIndexOf ( SYSTEM_SEPARATOR ) ; final int offset2 = fileName . lastIndexOf ( OTHER_SEPARATOR ) ;
if ( array [ i ] == separator && array [ i - 1 ] == separator ) { MST[rv.CRCR5Mutator]MSP[N] System . arraycopy ( array , i , array , i - 1 , size - i ) ; size -- ; i -- ; } }
if ( extension == null || extension . isEmpty () ) { return indexOfExtension ( fileName ) == NOT_FOUND ; } final String fileExt = getExtension ( fileName ) ; MST[NonVoidMethodCallMutator]MSP[N] return fileExt . equals ( extension ) ; }
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2 ) { return NOT_FOUND ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ; MST[InlineConstantMutator]MSP[N]
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND ) { return len + 1 ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ; MST[rv.UOI1Mutator]MSP[N] return Math . min ( posUnix , posWin ) + 1 ; }
final String path = fileName . substring ( prefix , endIndex ) ; failIfNullBytePresent ( path ) ; return path ; } public static String getFullPath ( final String fileName ) { return doGetFullPath ( fileName , true ) ; MST[EmptyObjectReturnValsMutator]MSP[N] }
for ( int i = prefix + 1 ; i < size ; i ++ ) { MST[rv.UOI3Mutator]MSP[N] if ( array [ i ] == separator && array [ i - 1 ] == '.' &&
if ( ! REG_NAME_PART_PATTERN . matcher ( parts [ i ] ) . matches () ) { MST[rv.UOI4Mutator]MSP[N] return false ; } } return true ; }
if ( len < 0 ) { return null ; } if ( len > fileName . length () ) { failIfNullBytePresent ( fileName + UNIX_SEPARATOR ) ; return fileName + UNIX_SEPARATOR ; } final String path = fileName . substring ( 0 , len ) ; MST[rv.CRCR6Mutator]MSP[N]
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND ) { return len + 1 ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; MST[rv.CRCR1Mutator]MSP[N] posWin = posWin == NOT_FOUND ? posUnix : posWin ; return Math . min ( posUnix , posWin ) + 1 ; }
String fileName1 , String fileName2 , final boolean normalized , IOCase caseSensitivity ) { if ( fileName1 == null || fileName2 == null ) { return fileName1 == null && fileName2 == null ; } if ( normalized ) { fileName1 = normalize ( fileName1 ) ; MST[ArgumentPropagationMutator]MSP[N]
if ( ch == '?' || ch == '*' ) { MST[rv.CRCR3Mutator]MSP[N] if ( buffer . length () != 0 ) { list . add ( buffer . toString () ) ; buffer . setLength ( 0 ) ; } if ( ch == '?' ) {
return isSeparator ( ch0 ) ? 1 : 0 ; } if ( ch0 == '~' ) { MST[rv.CRCR1Mutator]MSP[N] int posUnix = fileName . indexOf ( UNIX_SEPARATOR , 1 ) ; int posWin = fileName . indexOf ( WINDOWS_SEPARATOR , 1 ) ;
if ( repeat >= 0 ) { backtrack . push ( new int [] { wcsIdx , repeat } ) ; MST[rv.CRCR4Mutator]MSP[S] } } else { if ( ! caseSensitivity . checkRegionMatches ( fileName , textIdx , wcs [ wcsIdx ] ) ) { break; } }
return doNormalize ( fileName , SYSTEM_SEPARATOR , true ) ; } public static String normalize ( final String fileName , final boolean unixSeparator ) { final char separator = unixSeparator ? UNIX_SEPARATOR : WINDOWS_SEPARATOR ; return doNormalize ( fileName , separator , true ) ; MST[ArgumentPropagationMutator]MSP[N] }
if ( len < 0 ) { return null ; } if ( len > fileName . length () ) { failIfNullBytePresent ( fileName + UNIX_SEPARATOR ) ; return fileName + UNIX_SEPARATOR ; MST[EmptyObjectReturnValsMutator]MSP[N] } final String path = fileName . substring ( 0 , len ) ;
list . add ( buffer . toString () ) ; } return list . toArray ( new String [ list . size () ] ) ; MST[NonVoidMethodCallMutator]MSP[N] } private static boolean isValidHostName ( final String name ) { return isIPv6Address ( name ) || isRFC3986HostName ( name ) ; }
return doNormalize ( fileName , SYSTEM_SEPARATOR , true ) ; } public static String normalize ( final String fileName , final boolean unixSeparator ) { final char separator = unixSeparator ? UNIX_SEPARATOR : WINDOWS_SEPARATOR ; return doNormalize ( fileName , separator , true ) ; MST[EmptyObjectReturnValsMutator]MSP[N] }
System . arraycopy ( array , i + 1 , array , i - 1 , size - i ) ; size -= 2 ; i -- ; } } outer: for ( int i = prefix + 2 ; i < size ; i ++ ) { MST[rv.ABSMutator]MSP[N]
if ( len == 0 ) { return 0 ; } char ch0 = fileName . charAt ( 0 ) ; if ( ch0 == ':' ) { MST[rv.ROR5Mutator]MSP[N] return NOT_FOUND ; } if ( len == 1 ) { if ( ch0 == '~' ) { return 2 ; }
private static String doGetPath ( final String fileName , final int separatorAdd ) { if ( fileName == null ) { return null ; } final int prefix = getPrefixLength ( fileName ) ; if ( prefix < 0 ) { MST[rv.ROR1Mutator]MSP[N] return null ; }
if ( octets . length > IPV6_MAX_HEX_GROUPS ) { return false ; } int validOctets = 0 ; int emptyOctets = 0 ; for ( int index = 0 ; index < octets . length ; index ++ ) { MST[rv.ABSMutator]MSP[N] final String octet = octets [ index ] ;
final int prefix = getPrefixLength ( fileName ) ; if ( prefix < 0 ) { return null ; } if ( prefix >= fileName . length () ) { if ( includeSeparator ) { MST[rv.ROR5Mutator]MSP[N] return getPrefix ( fileName ) ; } return fileName ; }
public static boolean isExtension ( final String fileName , final Collection < String > extensions ) { if ( fileName == null ) { return false ; } failIfNullBytePresent ( fileName ) ; if ( extensions == null || extensions . isEmpty () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S]
textIdx += wcs [ wcsIdx ] . length () ; anyChars = false ; } wcsIdx ++ ; } if ( wcsIdx == wcs . length && textIdx == fileName . length () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return true ; } } while ( backtrack . size () > 0 );
public static boolean isExtension ( final String fileName , final String ... extensions ) { if ( fileName == null ) { MST[NegateConditionalsMutator]MSP[N] return false ; } failIfNullBytePresent ( fileName ) ; if ( extensions == null || extensions . length == 0 ) {
final int index = indexOfLastSeparator ( fileName ) ; final int endIndex = index + separatorAdd ; MST[rv.ABSMutator]MSP[S] if ( prefix >= fileName . length () || index < 0 || prefix >= endIndex ) { return EMPTY_STRING ; }
if ( array [ j ] == separator ) { MST[rv.UOI2Mutator]MSP[N] System . arraycopy ( array , i + 1 , array , j + 1 , size - i ) ; size -= i - j ; i = j + 1 ; continue outer; } }
final int lastWindowsPos = fileName . lastIndexOf ( WINDOWS_SEPARATOR ) ; return Math . max ( lastUnixPos , lastWindowsPos ) ; } public static int indexOfExtension ( final String fileName ) throws IllegalArgumentException { if ( fileName == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] return NOT_FOUND ; }
for ( int i = prefix + 1 ; i < size ; i ++ ) { if ( array [ i ] == separator && array [ i - 1 ] == '.' && MST[rv.AOR2Mutator]MSP[N]
final char [] array = text . toCharArray () ; final ArrayList < String > list = new ArrayList <> () ; final StringBuilder buffer = new StringBuilder () ; char prevChar = 0 ; MST[rv.CRCR1Mutator]MSP[N] for ( final char ch : array ) {
System . arraycopy ( array , i + 1 , array , i - 1 , size - i ) ; size -= 2 ; i -- ; } } outer: for ( int i = prefix + 2 ; i < size ; i ++ ) { MST[InlineConstantMutator]MSP[N]
if ( path == null || path . indexOf ( UNIX_SEPARATOR ) == NOT_FOUND ) { MST[rv.ROR2Mutator]MSP[N] return path ; } return path . replace ( UNIX_SEPARATOR , WINDOWS_SEPARATOR ) ; } public static String separatorsToSystem ( final String path ) { if ( path == null ) {
if ( len == 2 || isSeparator ( fileName . charAt ( 2 ) ) == false ) { return 2 ; } return 3 ; } else if ( ch0 == UNIX_SEPARATOR ) { MST[rv.ROR2Mutator]MSP[N] return 1 ; } return NOT_FOUND ;
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND ) { return len + 1 ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ; return Math . min ( posUnix , posWin ) + 1 ; MST[ReturnValsMutator]MSP[N] }
fileName2 = normalize ( fileName2 ) ; if ( fileName1 == null || fileName2 == null ) { throw new NullPointerException ( lr_5 ) ; } } if ( caseSensitivity == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] caseSensitivity = IOCase . SENSITIVE ; }
if ( array [ i ] == separator && array [ i - 1 ] == separator ) { System . arraycopy ( array , i , array , i - 1 , size - i ) ; MST[rv.UOI3Mutator]MSP[N] size -- ; i -- ; } }
return indexOfExtension ( fileName ) == NOT_FOUND ; } final String fileExt = getExtension ( fileName ) ; for ( final String extension : extensions ) { if ( fileExt . equals ( extension ) ) { return true ; } } return false ; MST[rv.CRCR6Mutator]MSP[N] }
final char ch1 = fileName . charAt ( 1 ) ; if ( ch1 == ':' ) { ch0 = Character . toUpperCase ( ch0 ) ; if ( ch0 >= 'A' && ch0 <= 'Z' ) { MST[rv.CRCR2Mutator]MSP[N]
String fileName1 , String fileName2 , final boolean normalized , IOCase caseSensitivity ) { if ( fileName1 == null || fileName2 == null ) { return fileName1 == null && fileName2 == null ; } if ( normalized ) { MST[rv.UOI4Mutator]MSP[N] fileName1 = normalize ( fileName1 ) ;
for ( int i = prefix + 1 ; i < size ; i ++ ) { if ( array [ i ] == separator && array [ i - 1 ] == '.' && MST[rv.AOR4Mutator]MSP[N]
int wcsIdx = 0 ; MST[rv.CRCR6Mutator]MSP[N] final Stack < int [] > backtrack = new Stack <> () ; do { if ( backtrack . size () > 0 ) { final int [] array = backtrack . pop () ; wcsIdx = array [ 0 ] ;
textIdx += wcs [ wcsIdx ] . length () ; MST[rv.AOR2Mutator]MSP[N] anyChars = false ; } wcsIdx ++ ; } if ( wcsIdx == wcs . length && textIdx == fileName . length () ) { return true ; } } while ( backtrack . size () > 0 );
if ( ipSegment . length () > 1 && ipSegment . startsWith ( lr_8 ) ) { return false ; } } return true ; MST[rv.CRCR5Mutator]MSP[S] } private static boolean isIPv6Address ( final String inet6Address ) { final boolean containsCompressedZeroes = inet6Address . contains ( lr_9 ) ;
if ( ! isIPv4Address ( octet ) ) { return false ; } validOctets += 2 ; continue; } if ( octet . length () > IPV6_MAX_HEX_DIGITS_PER_GROUP ) { return false ; MST[BooleanTrueReturnValsMutator]MSP[N] } int octetInt = 0 ; try {
final int index = indexOfLastSeparator ( fileName ) ; if ( index < 0 ) { return fileName . substring ( 0 , prefix ) ; } int end = index + ( includeSeparator ? 1 : 0 ) ; if ( end == 0 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] end ++ ;
|| ( inet6Address . endsWith ( lr_10 ) && ! inet6Address . endsWith ( lr_9 ) ) ) { return false ; } String [] octets = inet6Address . split ( lr_10 ) ; if ( containsCompressedZeroes ) { MST[NegateConditionalsMutator]MSP[N]
if ( size <= prefix ) { return new String ( array , 0 , size ) ; } if ( lastIsDirectory && keepSeparator ) { return new String ( array , 0 , size ) ; MST[ReturnValsMutator]MSP[N] }
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND ) { return len + 1 ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; MST[rv.UOI1Mutator]MSP[N] posWin = posWin == NOT_FOUND ? posUnix : posWin ; return Math . min ( posUnix , posWin ) + 1 ; }
if ( repeat >= 0 ) { backtrack . push ( new int [] { wcsIdx , repeat } ) ; MST[rv.CRCR5Mutator]MSP[N] } } else { if ( ! caseSensitivity . checkRegionMatches ( fileName , textIdx , wcs [ wcsIdx ] ) ) { break; } }
if ( len == 2 || isSeparator ( fileName . charAt ( 2 ) ) == false ) { return 2 ; } return 3 ; MST[rv.CRCR3Mutator]MSP[N] } else if ( ch0 == UNIX_SEPARATOR ) { return 1 ; } return NOT_FOUND ;
if ( ! isIPv4Address ( octet ) ) { return false ; } validOctets += 2 ; continue; } if ( octet . length () > IPV6_MAX_HEX_DIGITS_PER_GROUP ) { MST[rv.CRCR2Mutator]MSP[N] return false ; } int octetInt = 0 ; try {
} else if ( isSeparator ( ch0 ) && isSeparator ( ch1 ) ) { int posUnix = fileName . indexOf ( UNIX_SEPARATOR , 2 ) ; MST[NonVoidMethodCallMutator]MSP[N] int posWin = fileName . indexOf ( WINDOWS_SEPARATOR , 2 ) ;
octetInt = Integer . parseInt ( octet , BASE_16 ) ; } catch ( final NumberFormatException e ) { return false ; } if ( octetInt < 0 || octetInt > MAX_UNSIGNED_SHORT ) { return false ; } } validOctets ++ ; MST[IncrementsMutator]MSP[N] }
if ( validOctets > IPV6_MAX_HEX_GROUPS || ( validOctets < IPV6_MAX_HEX_GROUPS && ! containsCompressedZeroes ) ) { MST[rv.CRCR4Mutator]MSP[S] return false ; } return true ; } private static boolean isRFC3986HostName ( final String name ) { final String [] parts = name . split ( lr_13 , - 1 ) ;
if ( IOCase . SYSTEM . checkEquals ( canonicalParent , canonicalChild ) ) { return false ; MST[rv.CRCR6Mutator]MSP[S] } return IOCase . SYSTEM . checkStartsWith ( canonicalChild , canonicalParent ) ; } public static String separatorsToUnix ( final String path ) {
return fileName . substring ( index + 1 ) ; } private static void failIfNullBytePresent ( final String path ) { final int len = path . length () ; for ( int i = 0 ; i < len ; i ++ ) { MST[rv.UOI2Mutator]MSP[N]
if ( validOctets > IPV6_MAX_HEX_GROUPS || ( validOctets < IPV6_MAX_HEX_GROUPS && ! containsCompressedZeroes ) ) { MST[rv.ROR1Mutator]MSP[S] return false ; } return true ; } private static boolean isRFC3986HostName ( final String name ) { final String [] parts = name . split ( lr_13 , - 1 ) ;
if ( i == prefix + 2 ) { MST[rv.CRCR5Mutator]MSP[N] return null ; } if ( i == size - 1 ) { lastIsDirectory = true ; } int j ; for ( j = i - 4 ; j >= prefix ; j -- ) {
final int pos = Math . min ( posUnix , posWin ) + 1 ; MST[rv.UOI1Mutator]MSP[N] final String hostnamePart = fileName . substring ( 2 , pos - 1 ) ; return isValidHostName ( hostnamePart ) ? pos : NOT_FOUND ; } else {
return new String ( array , 0 , size - 1 ) ; MST[MathMutator]MSP[N] } public static String concat ( final String basePath , final String fullFileNameToAdd ) { final int prefix = getPrefixLength ( fullFileNameToAdd ) ; if ( prefix < 0 ) { return null ; }
if ( repeat >= 0 ) { backtrack . push ( new int [] { wcsIdx , repeat } ) ; } } else { if ( ! caseSensitivity . checkRegionMatches ( fileName , textIdx , wcs [ wcsIdx ] ) ) { MST[rv.ABSMutator]MSP[N] break; } }
( i == prefix + 1 || array [ i - 2 ] == separator ) ) { if ( i == size - 1 ) { MST[rv.UOI4Mutator]MSP[N] lastIsDirectory = true ; }
if ( IOCase . SYSTEM . checkEquals ( canonicalParent , canonicalChild ) ) { MST[rv.ROR2Mutator]MSP[N] return false ; } return IOCase . SYSTEM . checkStartsWith ( canonicalChild , canonicalParent ) ; } public static String separatorsToUnix ( final String path ) {
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND ) { return len + 1 ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ; return Math . min ( posUnix , posWin ) + 1 ; MST[rv.UOI3Mutator]MSP[N] }
if ( octets . length > IPV6_MAX_HEX_GROUPS ) { return false ; } int validOctets = 0 ; int emptyOctets = 0 ; for ( int index = 0 ; index < octets . length ; index ++ ) { MST[rv.UOI2Mutator]MSP[N] final String octet = octets [ index ] ;
int size = fileName . length () ; if ( size == 0 ) { return fileName ; } final int prefix = getPrefixLength ( fileName ) ; if ( prefix < 0 ) { MST[rv.UOI4Mutator]MSP[N] return null ; }
if ( prefix > 0 ) { MST[rv.UOI3Mutator]MSP[N] return normalize ( fullFileNameToAdd ) ; } if ( basePath == null ) { return null ; } final int len = basePath . length () ; if ( len == 0 ) { return normalize ( fullFileNameToAdd ) ; }
} else if ( isSeparator ( ch0 ) && isSeparator ( ch1 ) ) { int posUnix = fileName . indexOf ( UNIX_SEPARATOR , 2 ) ; int posWin = fileName . indexOf ( WINDOWS_SEPARATOR , 2 ) ; MST[rv.CRCR4Mutator]MSP[N]
if ( containsCompressedZeroes && ( inet6Address . indexOf ( lr_9 ) != inet6Address . lastIndexOf ( lr_9 ) ) ) { MST[rv.UOI3Mutator]MSP[S] return false ; } if ( ( inet6Address . startsWith ( lr_10 ) && ! inet6Address . startsWith ( lr_9 ) )
public static String normalizeNoEndSeparator ( final String fileName ) { return doNormalize ( fileName , SYSTEM_SEPARATOR , false ) ; } public static String normalizeNoEndSeparator ( final String fileName , final boolean unixSeparator ) { final char separator = unixSeparator ? UNIX_SEPARATOR : WINDOWS_SEPARATOR ; MST[NegateConditionalsMutator]MSP[N]
textIdx = array [ 1 ] ; MST[rv.UOI1Mutator]MSP[N] anyChars = true ; } while ( wcsIdx < wcs . length ) { if ( wcs [ wcsIdx ] . equals ( lr_6 ) ) { textIdx ++ ; if ( textIdx > fileName . length () ) { break; }
if ( array [ i ] == separator && array [ i - 1 ] == '.' && array [ i - 2 ] == '.' && MST[rv.ROR3Mutator]MSP[N] ( i == prefix + 2 || array [ i - 3 ] == separator ) ) {
final char ch1 = fileName . charAt ( 1 ) ; if ( ch1 == ':' ) { ch0 = Character . toUpperCase ( ch0 ) ; if ( ch0 >= 'A' && ch0 <= 'Z' ) { MST[rv.CRCR1Mutator]MSP[N]
if ( array [ size - 1 ] != separator ) { MST[InlineConstantMutator]MSP[N] array [ size ++ ] = separator ; lastIsDirectory = false ; } for ( int i = prefix + 1 ; i < size ; i ++ ) {
int size = fileName . length () ; if ( size == 0 ) { return fileName ; } final int prefix = getPrefixLength ( fileName ) ; if ( prefix < 0 ) { MST[rv.ROR5Mutator]MSP[N] return null ; }
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2 ) { MST[rv.ROR1Mutator]MSP[N] return NOT_FOUND ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ;
if ( len < 0 ) { return null ; } if ( len > fileName . length () ) { MST[rv.UOI1Mutator]MSP[N] failIfNullBytePresent ( fileName + UNIX_SEPARATOR ) ; return fileName + UNIX_SEPARATOR ; } final String path = fileName . substring ( 0 , len ) ;
textIdx = caseSensitivity . checkIndexOf ( fileName , textIdx , wcs [ wcsIdx ] ) ; if ( textIdx == NOT_FOUND ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] break; } final int repeat = caseSensitivity . checkIndexOf ( fileName , textIdx + 1 , wcs [ wcsIdx ] ) ;
for ( int i = 0 ; i < array . length ; i ++ ) { if ( array [ i ] == otherSeparator ) { MST[rv.ROR2Mutator]MSP[N] array [ i ] = separator ; } } boolean lastIsDirectory = true ;
if ( i == prefix + 2 ) { return null ; MST[EmptyObjectReturnValsMutator]MSP[N] } if ( i == size - 1 ) { lastIsDirectory = true ; } int j ; for ( j = i - 4 ; j >= prefix ; j -- ) {
if ( i == prefix + 2 ) { MST[rv.UOI1Mutator]MSP[N] return null ; } if ( i == size - 1 ) { lastIsDirectory = true ; } int j ; for ( j = i - 4 ; j >= prefix ; j -- ) {
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2 ) { MST[rv.CRCR4Mutator]MSP[N] return NOT_FOUND ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ;
textIdx = caseSensitivity . checkIndexOf ( fileName , textIdx , wcs [ wcsIdx ] ) ; MST[rv.UOI4Mutator]MSP[N] if ( textIdx == NOT_FOUND ) { break; } final int repeat = caseSensitivity . checkIndexOf ( fileName , textIdx + 1 , wcs [ wcsIdx ] ) ;
final String path = fileName . substring ( prefix , endIndex ) ; MST[rv.UOI4Mutator]MSP[S] failIfNullBytePresent ( path ) ; return path ; } public static String getFullPath ( final String fileName ) { return doGetFullPath ( fileName , true ) ; }
if ( path . charAt ( i ) == 0 ) { MST[rv.ROR5Mutator]MSP[N] throw new IllegalArgumentException ( lr_3 + lr_4 ) ; } } } public static String getBaseName ( final String fileName ) { return removeExtension ( getName ( fileName ) ) ; }
return false ; } static String [] splitOnTokens ( final String text ) { if ( text . indexOf ( '?' ) == NOT_FOUND && text . indexOf ( '*' ) == NOT_FOUND ) { MST[rv.CRCR6Mutator]MSP[N] return new String [] { text } ; }
|| ( inet6Address . endsWith ( lr_10 ) && ! inet6Address . endsWith ( lr_9 ) ) ) { MST[rv.ROR1Mutator]MSP[S] return false ; } String [] octets = inet6Address . split ( lr_10 ) ; if ( containsCompressedZeroes ) {
static boolean isSystemWindows () { return SYSTEM_SEPARATOR == WINDOWS_SEPARATOR ; MST[rv.CRCR3Mutator]MSP[N] } private static boolean isSeparator ( final char ch ) { return ch == UNIX_SEPARATOR || ch == WINDOWS_SEPARATOR ; } public static String normalize ( final String fileName ) {
return fileName . substring ( index + 1 ) ; MST[rv.CRCR2Mutator]MSP[N] } private static int getAdsCriticalOffset ( final String fileName ) { final int offset1 = fileName . lastIndexOf ( SYSTEM_SEPARATOR ) ; final int offset2 = fileName . lastIndexOf ( OTHER_SEPARATOR ) ;
for ( int i = prefix + 1 ; i < size ; i ++ ) { MST[rv.AOR4Mutator]MSP[N] if ( array [ i ] == separator && array [ i - 1 ] == '.' &&
return fileName . substring ( index + 1 ) ; } private static void failIfNullBytePresent ( final String path ) { final int len = path . length () ; for ( int i = 0 ; i < len ; i ++ ) { MST[rv.ROR3Mutator]MSP[N]
textIdx += wcs [ wcsIdx ] . length () ; anyChars = false ; } wcsIdx ++ ; } if ( wcsIdx == wcs . length && textIdx == fileName . length () ) { MST[rv.UOI2Mutator]MSP[N] return true ; } } while ( backtrack . size () > 0 );
private static boolean isIPv4Address ( final String name ) { final Matcher m = IPV4_PATTERN . matcher ( name ) ; if ( ! m . matches () || m . groupCount () != 4 ) { MST[rv.CRCR2Mutator]MSP[S] return false ; }
for ( int i = prefix + 1 ; i < size ; i ++ ) { if ( array [ i ] == separator && array [ i - 1 ] == '.' && MST[rv.AOD1Mutator]MSP[N]
if ( validOctets > IPV6_MAX_HEX_GROUPS || ( validOctets < IPV6_MAX_HEX_GROUPS && ! containsCompressedZeroes ) ) { MST[rv.CRCR3Mutator]MSP[N] return false ; } return true ; } private static boolean isRFC3986HostName ( final String name ) { final String [] parts = name . split ( lr_13 , - 1 ) ;
for ( int i = prefix + 1 ; i < size ; i ++ ) { if ( array [ i ] == separator && array [ i - 1 ] == '.' && MST[rv.ROR5Mutator]MSP[N]
final int lastSeparator = indexOfLastSeparator ( fileName ) ; return lastSeparator > extensionPos ? NOT_FOUND : extensionPos ; MST[rv.UOI4Mutator]MSP[N] } public static String getPrefix ( final String fileName ) { if ( fileName == null ) { return null ; } final int len = getPrefixLength ( fileName ) ;
static boolean isSystemWindows () { return SYSTEM_SEPARATOR == WINDOWS_SEPARATOR ; } private static boolean isSeparator ( final char ch ) { return ch == UNIX_SEPARATOR || ch == WINDOWS_SEPARATOR ; MST[rv.CRCR4Mutator]MSP[N] } public static String normalize ( final String fileName ) {
String fileName1 , String fileName2 , final boolean normalized , IOCase caseSensitivity ) { if ( fileName1 == null || fileName2 == null ) { return fileName1 == null && fileName2 == null ; MST[BooleanTrueReturnValsMutator]MSP[N] } if ( normalized ) { fileName1 = normalize ( fileName1 ) ;
if ( array [ j ] == separator ) { System . arraycopy ( array , i + 1 , array , j + 1 , size - i ) ; size -= i - j ; MST[rv.AOR4Mutator]MSP[N] i = j + 1 ; continue outer; } }
return indexOfExtension ( fileName ) == NOT_FOUND ; MST[rv.CRCR5Mutator]MSP[S] } final String fileExt = getExtension ( fileName ) ; for ( final String extension : extensions ) { if ( fileExt . equals ( extension ) ) { return true ; } } return false ; }
return isSeparator ( ch0 ) ? 1 : 0 ; } if ( ch0 == '~' ) { int posUnix = fileName . indexOf ( UNIX_SEPARATOR , 1 ) ; MST[rv.CRCR6Mutator]MSP[N] int posWin = fileName . indexOf ( WINDOWS_SEPARATOR , 1 ) ;
return isSeparator ( ch0 ) ? 1 : 0 ; } if ( ch0 == '~' ) { MST[rv.CRCR4Mutator]MSP[N] int posUnix = fileName . indexOf ( UNIX_SEPARATOR , 1 ) ; int posWin = fileName . indexOf ( WINDOWS_SEPARATOR , 1 ) ;
return doNormalize ( fileName , SYSTEM_SEPARATOR , true ) ; MST[rv.CRCR6Mutator]MSP[N] } public static String normalize ( final String fileName , final boolean unixSeparator ) { final char separator = unixSeparator ? UNIX_SEPARATOR : WINDOWS_SEPARATOR ; return doNormalize ( fileName , separator , true ) ; }
if ( octet . length () == 0 ) { emptyOctets ++ ; if ( emptyOctets > 1 ) { MST[rv.UOI3Mutator]MSP[N] return false ; } } else { emptyOctets = 0 ; if ( index == octets . length - 1 && octet . contains ( lr_12 ) ) {
return doNormalize ( fileName , SYSTEM_SEPARATOR , true ) ; } public static String normalize ( final String fileName , final boolean unixSeparator ) { final char separator = unixSeparator ? UNIX_SEPARATOR : WINDOWS_SEPARATOR ; MST[rv.CRCR5Mutator]MSP[S] return doNormalize ( fileName , separator , true ) ; }
final char ch1 = fileName . charAt ( 1 ) ; if ( ch1 == ':' ) { MST[rv.UOI2Mutator]MSP[N] ch0 = Character . toUpperCase ( ch0 ) ; if ( ch0 >= 'A' && ch0 <= 'Z' ) {
final int lastSeparator = indexOfLastSeparator ( fileName ) ; return lastSeparator > extensionPos ? NOT_FOUND : extensionPos ; MST[PrimitiveReturnsMutator]MSP[N] } public static String getPrefix ( final String fileName ) { if ( fileName == null ) { return null ; } final int len = getPrefixLength ( fileName ) ;
public static String normalizeNoEndSeparator ( final String fileName ) { return doNormalize ( fileName , SYSTEM_SEPARATOR , false ) ; } public static String normalizeNoEndSeparator ( final String fileName , final boolean unixSeparator ) { final char separator = unixSeparator ? UNIX_SEPARATOR : WINDOWS_SEPARATOR ; MST[rv.ROR1Mutator]MSP[N]
return doNormalize ( fileName , separator , false ) ; MST[rv.CRCR3Mutator]MSP[S] } private static String doNormalize ( final String fileName , final char separator , final boolean keepSeparator ) { if ( fileName == null ) { return null ; } failIfNullBytePresent ( fileName ) ;
return null ; } return isSystemWindows () ? separatorsToWindows ( path ) : separatorsToUnix ( path ) ; } public static int getPrefixLength ( final String fileName ) { if ( fileName == null ) { MST[NegateConditionalsMutator]MSP[N] return NOT_FOUND ; } final int len = fileName . length () ;
return isSeparator ( ch0 ) ? 1 : 0 ; MST[rv.ROR2Mutator]MSP[S] } if ( ch0 == '~' ) { int posUnix = fileName . indexOf ( UNIX_SEPARATOR , 1 ) ; int posWin = fileName . indexOf ( WINDOWS_SEPARATOR , 1 ) ;
if ( ch == '?' || ch == '*' ) { if ( buffer . length () != 0 ) { list . add ( buffer . toString () ) ; buffer . setLength ( 0 ) ; } if ( ch == '?' ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
octetInt = Integer . parseInt ( octet , BASE_16 ) ; } catch ( final NumberFormatException e ) { return false ; } if ( octetInt < 0 || octetInt > MAX_UNSIGNED_SHORT ) { MST[rv.CRCR2Mutator]MSP[N] return false ; } } validOctets ++ ; }
if ( array [ j ] == separator ) { System . arraycopy ( array , i + 1 , array , j + 1 , size - i ) ; size -= i - j ; MST[rv.UOI2Mutator]MSP[N] i = j + 1 ; continue outer; } }
if ( index == NOT_FOUND ) { MST[rv.CRCR1Mutator]MSP[S] return fileName ; } return fileName . substring ( 0 , index ) ; } public static boolean equals ( final String fileName1 , final String fileName2 ) { return equals ( fileName1 , fileName2 , false , IOCase . SENSITIVE ) ;
return false ; } static String [] splitOnTokens ( final String text ) { if ( text . indexOf ( '?' ) == NOT_FOUND && text . indexOf ( '*' ) == NOT_FOUND ) { MST[rv.ROR3Mutator]MSP[N] return new String [] { text } ; }
return fileName . substring ( index + 1 ) ; MST[ReturnValsMutator]MSP[N] } private static void failIfNullBytePresent ( final String path ) { final int len = path . length () ; for ( int i = 0 ; i < len ; i ++ ) {
String fileName1 , String fileName2 , final boolean normalized , IOCase caseSensitivity ) { if ( fileName1 == null || fileName2 == null ) { return fileName1 == null && fileName2 == null ; } if ( normalized ) { MST[rv.ROR5Mutator]MSP[N] fileName1 = normalize ( fileName1 ) ;
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2 ) { return NOT_FOUND ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ; MST[rv.ABSMutator]MSP[N]
return indexOfExtension ( fileName ) == NOT_FOUND ; } final String fileExt = getExtension ( fileName ) ; for ( final String extension : extensions ) { MST[rv.UOI3Mutator]MSP[N] if ( fileExt . equals ( extension ) ) { return true ; } } return false ; }
if ( i == prefix + 2 ) { return null ; } if ( i == size - 1 ) { lastIsDirectory = true ; } int j ; for ( j = i - 4 ; j >= prefix ; j -- ) { MST[rv.AOR4Mutator]MSP[N]
if ( array [ j ] == separator ) { System . arraycopy ( array , i + 1 , array , j + 1 , size - i ) ; size -= i - j ; MST[rv.ABSMutator]MSP[N] i = j + 1 ; continue outer; } }
return isSeparator ( ch0 ) ? 1 : 0 ; MST[rv.UOI1Mutator]MSP[S] } if ( ch0 == '~' ) { int posUnix = fileName . indexOf ( UNIX_SEPARATOR , 1 ) ; int posWin = fileName . indexOf ( WINDOWS_SEPARATOR , 1 ) ;
final int index = indexOfLastSeparator ( fileName ) ; if ( index < 0 ) { return fileName . substring ( 0 , prefix ) ; } int end = index + ( includeSeparator ? 1 : 0 ) ; MST[rv.UOI1Mutator]MSP[N] if ( end == 0 ) { end ++ ;
final int index = indexOfLastSeparator ( fileName ) ; if ( index < 0 ) { return fileName . substring ( 0 , prefix ) ; } int end = index + ( includeSeparator ? 1 : 0 ) ; MST[rv.UOI4Mutator]MSP[N] if ( end == 0 ) { end ++ ;
} else if ( isSeparator ( ch0 ) && isSeparator ( ch1 ) ) { MST[rv.UOI4Mutator]MSP[N] int posUnix = fileName . indexOf ( UNIX_SEPARATOR , 2 ) ; int posWin = fileName . indexOf ( WINDOWS_SEPARATOR , 2 ) ;
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2 ) { MST[rv.CRCR3Mutator]MSP[N] return NOT_FOUND ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ;
System . arraycopy ( array , i + 1 , array , prefix , size - i ) ; size -= i + 1 - prefix ; MST[rv.CRCR4Mutator]MSP[N] i = prefix + 1 ; } } if ( size <= 0 ) { return EMPTY_STRING ; }
final int pos = Math . min ( posUnix , posWin ) + 1 ; final String hostnamePart = fileName . substring ( 2 , pos - 1 ) ; return isValidHostName ( hostnamePart ) ? pos : NOT_FOUND ; MST[rv.ROR2Mutator]MSP[N] } else {
final int index = indexOfLastSeparator ( fileName ) ; final int endIndex = index + separatorAdd ; MST[MathMutator]MSP[S] if ( prefix >= fileName . length () || index < 0 || prefix >= endIndex ) { return EMPTY_STRING ; }
textIdx = caseSensitivity . checkIndexOf ( fileName , textIdx , wcs [ wcsIdx ] ) ; if ( textIdx == NOT_FOUND ) { break; } final int repeat = caseSensitivity . checkIndexOf ( fileName , textIdx + 1 , wcs [ wcsIdx ] ) ; MST[rv.ABSMutator]MSP[N]
if ( ipSegment . length () > 1 && ipSegment . startsWith ( lr_8 ) ) { MST[rv.ROR3Mutator]MSP[S] return false ; } } return true ; } private static boolean isIPv6Address ( final String inet6Address ) { final boolean containsCompressedZeroes = inet6Address . contains ( lr_9 ) ;
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return NOT_FOUND ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ;
if ( len == 0 ) { return 0 ; } char ch0 = fileName . charAt ( 0 ) ; if ( ch0 == ':' ) { return NOT_FOUND ; } if ( len == 1 ) { if ( ch0 == '~' ) { return 2 ; MST[rv.CRCR3Mutator]MSP[N] }
if ( array [ size - 1 ] != separator ) { array [ size ++ ] = separator ; lastIsDirectory = false ; } for ( int i = prefix + 1 ; i < size ; i ++ ) { MST[rv.ROR1Mutator]MSP[N]
anyChars = false ; } else if ( wcs [ wcsIdx ] . equals ( lr_7 ) ) { anyChars = true ; if ( wcsIdx == wcs . length - 1 ) { MST[rv.CRCR4Mutator]MSP[N] textIdx = fileName . length () ; } } else { if ( anyChars ) {
if ( len == 2 || isSeparator ( fileName . charAt ( 2 ) ) == false ) { MST[NegateConditionalsMutator]MSP[N] return 2 ; } return 3 ; } else if ( ch0 == UNIX_SEPARATOR ) { return 1 ; } return NOT_FOUND ;
if ( len == 2 || isSeparator ( fileName . charAt ( 2 ) ) == false ) { return 2 ; } return 3 ; } else if ( ch0 == UNIX_SEPARATOR ) { MST[rv.CRCR5Mutator]MSP[N] return 1 ; } return NOT_FOUND ;
if ( extension == null || extension . isEmpty () ) { MST[NegateConditionalsMutator]MSP[N] return indexOfExtension ( fileName ) == NOT_FOUND ; } final String fileExt = getExtension ( fileName ) ; return fileExt . equals ( extension ) ; }
public static boolean isExtension ( final String fileName , final Collection < String > extensions ) { if ( fileName == null ) { return false ; } failIfNullBytePresent ( fileName ) ; if ( extensions == null || extensions . isEmpty () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S]
return indexOfExtension ( fileName ) == NOT_FOUND ; } final String fileExt = getExtension ( fileName ) ; for ( final String extension : extensions ) { if ( fileExt . equals ( extension ) ) { return true ; } } return false ; MST[ReturnValsMutator]MSP[N] }
final char ch1 = fileName . charAt ( 1 ) ; if ( ch1 == ':' ) { MST[rv.ABSMutator]MSP[N] ch0 = Character . toUpperCase ( ch0 ) ; if ( ch0 >= 'A' && ch0 <= 'Z' ) {
for ( int i = 1 ; i <= 4 ; i ++ ) { final String ipSegment = m . group ( i ) ; final int iIpSegment = Integer . parseInt ( ipSegment ) ; if ( iIpSegment > IPV4_MAX_OCTET_VALUE ) { MST[rv.ABSMutator]MSP[N] return false ; }
if ( array [ i ] == separator && array [ i - 1 ] == '.' && array [ i - 2 ] == '.' && MST[rv.UOI1Mutator]MSP[N] ( i == prefix + 2 || array [ i - 3 ] == separator ) ) {
final int index = indexOfLastSeparator ( fileName ) ; final int endIndex = index + separatorAdd ; MST[rv.UOI2Mutator]MSP[N] if ( prefix >= fileName . length () || index < 0 || prefix >= endIndex ) { return EMPTY_STRING ; }
textIdx = array [ 1 ] ; anyChars = true ; MST[rv.CRCR6Mutator]MSP[N] } while ( wcsIdx < wcs . length ) { if ( wcs [ wcsIdx ] . equals ( lr_6 ) ) { textIdx ++ ; if ( textIdx > fileName . length () ) { break; }
public static String normalizeNoEndSeparator ( final String fileName ) { return doNormalize ( fileName , SYSTEM_SEPARATOR , false ) ; } public static String normalizeNoEndSeparator ( final String fileName , final boolean unixSeparator ) { final char separator = unixSeparator ? UNIX_SEPARATOR : WINDOWS_SEPARATOR ; MST[rv.UOI3Mutator]MSP[N]
if ( index == NOT_FOUND ) { return fileName ; } return fileName . substring ( 0 , index ) ; } public static boolean equals ( final String fileName1 , final String fileName2 ) { return equals ( fileName1 , fileName2 , false , IOCase . SENSITIVE ) ; MST[rv.CRCR3Mutator]MSP[S]
return null ; } return isSystemWindows () ? separatorsToWindows ( path ) : separatorsToUnix ( path ) ; } public static int getPrefixLength ( final String fileName ) { if ( fileName == null ) { return NOT_FOUND ; MST[rv.CRCR5Mutator]MSP[N] } final int len = fileName . length () ;
return isSeparator ( ch0 ) ? 1 : 0 ; } if ( ch0 == '~' ) { MST[rv.ROR1Mutator]MSP[N] int posUnix = fileName . indexOf ( UNIX_SEPARATOR , 1 ) ; int posWin = fileName . indexOf ( WINDOWS_SEPARATOR , 1 ) ;
System . arraycopy ( array , i + 1 , array , i - 1 , size - i ) ; size -= 2 ; i -- ; } } outer: for ( int i = prefix + 2 ; i < size ; i ++ ) { MST[ConditionalsBoundaryMutator]MSP[S]
list . add ( lr_6 ) ; } else if ( prevChar != '*' ) { MST[rv.CRCR2Mutator]MSP[N] list . add ( lr_7 ) ; } } else { buffer . append ( ch ) ; } prevChar = ch ; } if ( buffer . length () != 0 ) {
for ( int i = prefix + 1 ; i < size ; i ++ ) { if ( array [ i ] == separator && array [ i - 1 ] == '.' && MST[rv.CRCR4Mutator]MSP[N]
for ( int i = 0 ; i < array . length ; i ++ ) { if ( array [ i ] == otherSeparator ) { MST[rv.UOI4Mutator]MSP[N] array [ i ] = separator ; } } boolean lastIsDirectory = true ;
textIdx = array [ 1 ] ; anyChars = true ; } while ( wcsIdx < wcs . length ) { MST[rv.UOI4Mutator]MSP[N] if ( wcs [ wcsIdx ] . equals ( lr_6 ) ) { textIdx ++ ; if ( textIdx > fileName . length () ) { break; }
if ( repeat >= 0 ) { backtrack . push ( new int [] { wcsIdx , repeat } ) ; } } else { if ( ! caseSensitivity . checkRegionMatches ( fileName , textIdx , wcs [ wcsIdx ] ) ) { MST[rv.ROR4Mutator]MSP[N] break; } }
if ( size <= prefix ) { return new String ( array , 0 , size ) ; MST[rv.CRCR5Mutator]MSP[N] } if ( lastIsDirectory && keepSeparator ) { return new String ( array , 0 , size ) ; }
if ( path == null || path . indexOf ( UNIX_SEPARATOR ) == NOT_FOUND ) { return path ; } return path . replace ( UNIX_SEPARATOR , WINDOWS_SEPARATOR ) ; MST[rv.CRCR3Mutator]MSP[N] } public static String separatorsToSystem ( final String path ) { if ( path == null ) {
if ( containsCompressedZeroes && ( inet6Address . indexOf ( lr_9 ) != inet6Address . lastIndexOf ( lr_9 ) ) ) { MST[rv.ROR4Mutator]MSP[S] return false ; } if ( ( inet6Address . startsWith ( lr_10 ) && ! inet6Address . startsWith ( lr_9 ) )
if ( prefix > 0 ) { MST[NegateConditionalsMutator]MSP[N] return normalize ( fullFileNameToAdd ) ; } if ( basePath == null ) { return null ; } final int len = basePath . length () ; if ( len == 0 ) { return normalize ( fullFileNameToAdd ) ; }
if ( path == null || path . indexOf ( WINDOWS_SEPARATOR ) == NOT_FOUND ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return path ; } return path . replace ( WINDOWS_SEPARATOR , UNIX_SEPARATOR ) ; } public static String separatorsToWindows ( final String path ) {
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2 ) { MST[rv.CRCR6Mutator]MSP[N] return NOT_FOUND ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ;
} else if ( inet6Address . startsWith ( lr_9 ) && ! octetList . isEmpty () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] octetList . remove ( 0 ) ; } octets = octetList . toArray ( new String [ octetList . size () ] ) ; }
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND ) { return len + 1 ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; MST[rv.ABSMutator]MSP[N] posWin = posWin == NOT_FOUND ? posUnix : posWin ; return Math . min ( posUnix , posWin ) + 1 ; }
for ( int i = 0 ; i < parts . length ; i ++ ) { if ( parts [ i ] . length () == 0 ) { MST[rv.ROR3Mutator]MSP[N] return i == parts . length - 1 ; }
System . arraycopy ( array , i + 1 , array , i - 1 , size - i ) ; MST[rv.UOI4Mutator]MSP[N] size -= 2 ; i -- ; } } outer: for ( int i = prefix + 2 ; i < size ; i ++ ) {
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND ) { return len + 1 ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; MST[rv.ROR1Mutator]MSP[N] posWin = posWin == NOT_FOUND ? posUnix : posWin ; return Math . min ( posUnix , posWin ) + 1 ; }
if ( prefix > 0 ) { return normalize ( fullFileNameToAdd ) ; } if ( basePath == null ) { return null ; } final int len = basePath . length () ; if ( len == 0 ) { MST[rv.ABSMutator]MSP[N] return normalize ( fullFileNameToAdd ) ; }
return doNormalize ( fileName , SYSTEM_SEPARATOR , true ) ; } public static String normalize ( final String fileName , final boolean unixSeparator ) { final char separator = unixSeparator ? UNIX_SEPARATOR : WINDOWS_SEPARATOR ; MST[InlineConstantMutator]MSP[N] return doNormalize ( fileName , separator , true ) ; }
return fileName . substring ( index + 1 ) ; MST[rv.CRCR5Mutator]MSP[N] } private static int getAdsCriticalOffset ( final String fileName ) { final int offset1 = fileName . lastIndexOf ( SYSTEM_SEPARATOR ) ; final int offset2 = fileName . lastIndexOf ( OTHER_SEPARATOR ) ;
|| ( inet6Address . endsWith ( lr_10 ) && ! inet6Address . endsWith ( lr_9 ) ) ) { MST[rv.ROR4Mutator]MSP[N] return false ; } String [] octets = inet6Address . split ( lr_10 ) ; if ( containsCompressedZeroes ) {
if ( ch == '?' || ch == '*' ) { MST[InlineConstantMutator]MSP[N] if ( buffer . length () != 0 ) { list . add ( buffer . toString () ) ; buffer . setLength ( 0 ) ; } if ( ch == '?' ) {
return isSeparator ( ch0 ) ? 1 : 0 ; } } public static int indexOfLastSeparator ( final String fileName ) { if ( fileName == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return NOT_FOUND ; } final int lastUnixPos = fileName . lastIndexOf ( UNIX_SEPARATOR ) ;
if ( path == null || path . indexOf ( UNIX_SEPARATOR ) == NOT_FOUND ) { return path ; } return path . replace ( UNIX_SEPARATOR , WINDOWS_SEPARATOR ) ; MST[rv.CRCR6Mutator]MSP[N] } public static String separatorsToSystem ( final String path ) { if ( path == null ) {
final int lastWindowsPos = fileName . lastIndexOf ( WINDOWS_SEPARATOR ) ; return Math . max ( lastUnixPos , lastWindowsPos ) ; MST[rv.UOI2Mutator]MSP[N] } public static int indexOfExtension ( final String fileName ) throws IllegalArgumentException { if ( fileName == null ) { return NOT_FOUND ; }
textIdx = array [ 1 ] ; anyChars = true ; } while ( wcsIdx < wcs . length ) { if ( wcs [ wcsIdx ] . equals ( lr_6 ) ) { textIdx ++ ; if ( textIdx > fileName . length () ) { MST[rv.UOI4Mutator]MSP[N] break; }
final char [] array = new char [ size + 2 ] ; fileName . getChars ( 0 , fileName . length () , array , 0 ) ; MST[rv.CRCR5Mutator]MSP[N] final char otherSeparator = separator == SYSTEM_SEPARATOR ? OTHER_SEPARATOR : SYSTEM_SEPARATOR ;
System . arraycopy ( array , i + 1 , array , i - 1 , size - i ) ; MST[rv.CRCR4Mutator]MSP[N] size -= 2 ; i -- ; } } outer: for ( int i = prefix + 2 ; i < size ; i ++ ) {
} return fileName . substring ( 0 , end ) ; } public static String getName ( final String fileName ) { if ( fileName == null ) { MST[NegateConditionalsMutator]MSP[N] return null ; } failIfNullBytePresent ( fileName ) ; final int index = indexOfLastSeparator ( fileName ) ;
anyChars = false ; } else if ( wcs [ wcsIdx ] . equals ( lr_7 ) ) { MST[rv.UOI4Mutator]MSP[N] anyChars = true ; if ( wcsIdx == wcs . length - 1 ) { textIdx = fileName . length () ; } } else { if ( anyChars ) {
if ( octets . length > IPV6_MAX_HEX_GROUPS ) { return false ; MST[rv.CRCR6Mutator]MSP[S] } int validOctets = 0 ; int emptyOctets = 0 ; for ( int index = 0 ; index < octets . length ; index ++ ) { final String octet = octets [ index ] ;
if ( i == prefix + 2 ) { MST[rv.AOR2Mutator]MSP[N] return null ; } if ( i == size - 1 ) { lastIsDirectory = true ; } int j ; for ( j = i - 4 ; j >= prefix ; j -- ) {
if ( containsCompressedZeroes && ( inet6Address . indexOf ( lr_9 ) != inet6Address . lastIndexOf ( lr_9 ) ) ) { MST[rv.ROR1Mutator]MSP[N] return false ; } if ( ( inet6Address . startsWith ( lr_10 ) && ! inet6Address . startsWith ( lr_9 ) )
if ( repeat >= 0 ) { backtrack . push ( new int [] { wcsIdx , repeat } ) ; MST[NonVoidMethodCallMutator]MSP[N] } } else { if ( ! caseSensitivity . checkRegionMatches ( fileName , textIdx , wcs [ wcsIdx ] ) ) { break; } }
} else if ( isSeparator ( ch0 ) && isSeparator ( ch1 ) ) { MST[rv.UOI3Mutator]MSP[N] int posUnix = fileName . indexOf ( UNIX_SEPARATOR , 2 ) ; int posWin = fileName . indexOf ( WINDOWS_SEPARATOR , 2 ) ;
if ( len == 0 ) { return 0 ; } char ch0 = fileName . charAt ( 0 ) ; MST[rv.CRCR6Mutator]MSP[N] if ( ch0 == ':' ) { return NOT_FOUND ; } if ( len == 1 ) { if ( ch0 == '~' ) { return 2 ; }
if ( prefix > 0 ) { MST[rv.ROR1Mutator]MSP[N] return normalize ( fullFileNameToAdd ) ; } if ( basePath == null ) { return null ; } final int len = basePath . length () ; if ( len == 0 ) { return normalize ( fullFileNameToAdd ) ; }
textIdx = array [ 1 ] ; anyChars = true ; } while ( wcsIdx < wcs . length ) { if ( wcs [ wcsIdx ] . equals ( lr_6 ) ) { textIdx ++ ; MST[experimental.RemoveIncrementsMutator]MSP[N] if ( textIdx > fileName . length () ) { break; }
list . add ( buffer . toString () ) ; } return list . toArray ( new String [ list . size () ] ) ; } private static boolean isValidHostName ( final String name ) { return isIPv6Address ( name ) || isRFC3986HostName ( name ) ; MST[InlineConstantMutator]MSP[N] }
return isSeparator ( ch0 ) ? 1 : 0 ; } if ( ch0 == '~' ) { int posUnix = fileName . indexOf ( UNIX_SEPARATOR , 1 ) ; MST[ArgumentPropagationMutator]MSP[N] int posWin = fileName . indexOf ( WINDOWS_SEPARATOR , 1 ) ;
return isSeparator ( ch0 ) ? 1 : 0 ; MST[rv.ROR5Mutator]MSP[N] } if ( ch0 == '~' ) { int posUnix = fileName . indexOf ( UNIX_SEPARATOR , 1 ) ; int posWin = fileName . indexOf ( WINDOWS_SEPARATOR , 1 ) ;
if ( len == 2 || isSeparator ( fileName . charAt ( 2 ) ) == false ) { return 2 ; } return 3 ; } else if ( ch0 == UNIX_SEPARATOR ) { MST[rv.UOI1Mutator]MSP[S] return 1 ; } return NOT_FOUND ;
return false ; } static String [] splitOnTokens ( final String text ) { if ( text . indexOf ( '?' ) == NOT_FOUND && text . indexOf ( '*' ) == NOT_FOUND ) { MST[rv.CRCR4Mutator]MSP[N] return new String [] { text } ; }
System . arraycopy ( array , i + 1 , array , prefix , size - i ) ; size -= i + 1 - prefix ; MST[rv.AOR2Mutator]MSP[N] i = prefix + 1 ; } } if ( size <= 0 ) { return EMPTY_STRING ; }
return isSeparator ( ch0 ) ? 1 : 0 ; MST[rv.ROR1Mutator]MSP[N] } } public static int indexOfLastSeparator ( final String fileName ) { if ( fileName == null ) { return NOT_FOUND ; } final int lastUnixPos = fileName . lastIndexOf ( UNIX_SEPARATOR ) ;
String fileName1 , String fileName2 , final boolean normalized , IOCase caseSensitivity ) { if ( fileName1 == null || fileName2 == null ) { return fileName1 == null && fileName2 == null ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } if ( normalized ) { fileName1 = normalize ( fileName1 ) ;
if ( ch == '?' || ch == '*' ) { if ( buffer . length () != 0 ) { list . add ( buffer . toString () ) ; buffer . setLength ( 0 ) ; } if ( ch == '?' ) { MST[rv.UOI2Mutator]MSP[S]
if ( ipSegment . length () > 1 && ipSegment . startsWith ( lr_8 ) ) { return false ; } } return true ; MST[rv.CRCR2Mutator]MSP[S] } private static boolean isIPv6Address ( final String inet6Address ) { final boolean containsCompressedZeroes = inet6Address . contains ( lr_9 ) ;
final int index = indexOfLastSeparator ( fileName ) ; final int endIndex = index + separatorAdd ; if ( prefix >= fileName . length () || index < 0 || prefix >= endIndex ) { MST[rv.ABSMutator]MSP[N] return EMPTY_STRING ; }
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2 ) { return NOT_FOUND ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; MST[rv.CRCR2Mutator]MSP[N] posWin = posWin == NOT_FOUND ? posUnix : posWin ;
if ( len == 2 || isSeparator ( fileName . charAt ( 2 ) ) == false ) { return 2 ; } return 3 ; MST[rv.CRCR6Mutator]MSP[N] } else if ( ch0 == UNIX_SEPARATOR ) { return 1 ; } return NOT_FOUND ;
public static String getExtension ( final String fileName ) throws IllegalArgumentException { if ( fileName == null ) { return null ; } final int index = indexOfExtension ( fileName ) ; if ( index == NOT_FOUND ) { return EMPTY_STRING ; MST[ReturnValsMutator]MSP[N] }
for ( int i = prefix + 1 ; i < size ; i ++ ) { if ( array [ i ] == separator && array [ i - 1 ] == '.' && MST[rv.AOR1Mutator]MSP[N]
return isSeparator ( ch0 ) ? 1 : 0 ; } } public static int indexOfLastSeparator ( final String fileName ) { if ( fileName == null ) { return NOT_FOUND ; } final int lastUnixPos = fileName . lastIndexOf ( UNIX_SEPARATOR ) ; MST[rv.CRCR5Mutator]MSP[N]
final char ch1 = fileName . charAt ( 1 ) ; if ( ch1 == ':' ) { ch0 = Character . toUpperCase ( ch0 ) ; if ( ch0 >= 'A' && ch0 <= 'Z' ) { MST[rv.ROR2Mutator]MSP[N]
System . arraycopy ( array , i + 1 , array , prefix , size - i ) ; size -= i + 1 - prefix ; MST[rv.UOI1Mutator]MSP[N] i = prefix + 1 ; } } if ( size <= 0 ) { return EMPTY_STRING ; }
final int prefix = getPrefixLength ( fileName ) ; if ( prefix < 0 ) { return null ; } if ( prefix >= fileName . length () ) { MST[rv.ABSMutator]MSP[N] if ( includeSeparator ) { return getPrefix ( fileName ) ; } return fileName ; }
System . arraycopy ( array , i + 1 , array , i - 1 , size - i ) ; size -= 2 ; i -- ; } } outer: for ( int i = prefix + 2 ; i < size ; i ++ ) { MST[rv.UOI2Mutator]MSP[N]
final int prefix = getPrefixLength ( fileName ) ; if ( prefix < 0 ) { MST[rv.ROR3Mutator]MSP[N] return null ; } if ( prefix >= fileName . length () ) { if ( includeSeparator ) { return getPrefix ( fileName ) ; } return fileName ; }
public static String getExtension ( final String fileName ) throws IllegalArgumentException { if ( fileName == null ) { return null ; } final int index = indexOfExtension ( fileName ) ; if ( index == NOT_FOUND ) { MST[rv.CRCR4Mutator]MSP[N] return EMPTY_STRING ; }
for ( int i = 0 ; i < parts . length ; i ++ ) { if ( parts [ i ] . length () == 0 ) { return i == parts . length - 1 ; MST[rv.CRCR5Mutator]MSP[N] }
if ( array [ j ] == separator ) { System . arraycopy ( array , i + 1 , array , j + 1 , size - i ) ; size -= i - j ; MST[rv.AOR1Mutator]MSP[N] i = j + 1 ; continue outer; } }
if ( IOCase . SYSTEM . checkEquals ( canonicalParent , canonicalChild ) ) { return false ; MST[BooleanTrueReturnValsMutator]MSP[S] } return IOCase . SYSTEM . checkStartsWith ( canonicalChild , canonicalParent ) ; } public static String separatorsToUnix ( final String path ) {
if ( extension == null || extension . isEmpty () ) { return indexOfExtension ( fileName ) == NOT_FOUND ; MST[rv.ROR3Mutator]MSP[N] } final String fileExt = getExtension ( fileName ) ; return fileExt . equals ( extension ) ; }
if ( octets . length > IPV6_MAX_HEX_GROUPS ) { return false ; MST[rv.CRCR3Mutator]MSP[S] } int validOctets = 0 ; int emptyOctets = 0 ; for ( int index = 0 ; index < octets . length ; index ++ ) { final String octet = octets [ index ] ;
textIdx = caseSensitivity . checkIndexOf ( fileName , textIdx , wcs [ wcsIdx ] ) ; MST[rv.UOI1Mutator]MSP[N] if ( textIdx == NOT_FOUND ) { break; } final int repeat = caseSensitivity . checkIndexOf ( fileName , textIdx + 1 , wcs [ wcsIdx ] ) ;
if ( octet . length () == 0 ) { emptyOctets ++ ; if ( emptyOctets > 1 ) { return false ; } } else { emptyOctets = 0 ; if ( index == octets . length - 1 && octet . contains ( lr_12 ) ) { MST[rv.CRCR4Mutator]MSP[S]
for ( int i = 0 ; i < array . length ; i ++ ) { if ( array [ i ] == otherSeparator ) { MST[rv.ROR5Mutator]MSP[N] array [ i ] = separator ; } } boolean lastIsDirectory = true ;
if ( len == 2 || isSeparator ( fileName . charAt ( 2 ) ) == false ) { MST[InlineConstantMutator]MSP[N] return 2 ; } return 3 ; } else if ( ch0 == UNIX_SEPARATOR ) { return 1 ; } return NOT_FOUND ;
failIfNullBytePresent ( path ) ; return path ; } public static String getPath ( final String fileName ) { return doGetPath ( fileName , 1 ) ; } public static String getPathNoEndSeparator ( final String fileName ) { return doGetPath ( fileName , 0 ) ; MST[rv.CRCR5Mutator]MSP[S] }
String fileName1 , String fileName2 , final boolean normalized , IOCase caseSensitivity ) { if ( fileName1 == null || fileName2 == null ) { return fileName1 == null && fileName2 == null ; } if ( normalized ) { MST[rv.ROR2Mutator]MSP[N] fileName1 = normalize ( fileName1 ) ;
anyChars = false ; } else if ( wcs [ wcsIdx ] . equals ( lr_7 ) ) { MST[rv.ROR3Mutator]MSP[N] anyChars = true ; if ( wcsIdx == wcs . length - 1 ) { textIdx = fileName . length () ; } } else { if ( anyChars ) {
final int lastSeparator = indexOfLastSeparator ( fileName ) ; return lastSeparator > extensionPos ? NOT_FOUND : extensionPos ; MST[rv.CRCR6Mutator]MSP[N] } public static String getPrefix ( final String fileName ) { if ( fileName == null ) { return null ; } final int len = getPrefixLength ( fileName ) ;
if ( array [ i ] == separator && array [ i - 1 ] == '.' && array [ i - 2 ] == '.' && MST[rv.CRCR2Mutator]MSP[N] ( i == prefix + 2 || array [ i - 3 ] == separator ) ) {
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2 ) { return NOT_FOUND ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; MST[rv.UOI3Mutator]MSP[N] posWin = posWin == NOT_FOUND ? posUnix : posWin ;
final char [] array = text . toCharArray () ; final ArrayList < String > list = new ArrayList <> () ; final StringBuilder buffer = new StringBuilder () ; char prevChar = 0 ; MST[InlineConstantMutator]MSP[N] for ( final char ch : array ) {
int size = fileName . length () ; MST[NonVoidMethodCallMutator]MSP[N] if ( size == 0 ) { return fileName ; } final int prefix = getPrefixLength ( fileName ) ; if ( prefix < 0 ) { return null ; }
for ( int i = prefix + 1 ; i < size ; i ++ ) { MST[rv.AOR1Mutator]MSP[N] if ( array [ i ] == separator && array [ i - 1 ] == '.' &&
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2 ) { MST[rv.ROR4Mutator]MSP[N] return NOT_FOUND ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ;
if ( path . charAt ( i ) == 0 ) { MST[rv.ROR2Mutator]MSP[N] throw new IllegalArgumentException ( lr_3 + lr_4 ) ; } } } public static String getBaseName ( final String fileName ) { return removeExtension ( getName ( fileName ) ) ; }
anyChars = false ; } else if ( wcs [ wcsIdx ] . equals ( lr_7 ) ) { MST[rv.UOI1Mutator]MSP[N] anyChars = true ; if ( wcsIdx == wcs . length - 1 ) { textIdx = fileName . length () ; } } else { if ( anyChars ) {
int size = fileName . length () ; if ( size == 0 ) { MST[rv.ABSMutator]MSP[S] return fileName ; } final int prefix = getPrefixLength ( fileName ) ; if ( prefix < 0 ) { return null ; }
final int pos = Math . min ( posUnix , posWin ) + 1 ; MST[rv.UOI4Mutator]MSP[N] final String hostnamePart = fileName . substring ( 2 , pos - 1 ) ; return isValidHostName ( hostnamePart ) ? pos : NOT_FOUND ; } else {
for ( int i = 0 ; i < parts . length ; i ++ ) { MST[NegateConditionalsMutator]MSP[N] if ( parts [ i ] . length () == 0 ) { return i == parts . length - 1 ; }
if ( i == prefix + 2 ) { return null ; } if ( i == size - 1 ) { MST[NegateConditionalsMutator]MSP[N] lastIsDirectory = true ; } int j ; for ( j = i - 4 ; j >= prefix ; j -- ) {
final char ch1 = fileName . charAt ( 1 ) ; if ( ch1 == ':' ) { ch0 = Character . toUpperCase ( ch0 ) ; if ( ch0 >= 'A' && ch0 <= 'Z' ) { MST[rv.ROR1Mutator]MSP[S]
private static boolean isIPv4Address ( final String name ) { final Matcher m = IPV4_PATTERN . matcher ( name ) ; if ( ! m . matches () || m . groupCount () != 4 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return false ; }
for ( int i = prefix + 1 ; i < size ; i ++ ) { if ( array [ i ] == separator && array [ i - 1 ] == '.' && MST[rv.ABSMutator]MSP[N]
if ( size <= prefix ) { return new String ( array , 0 , size ) ; } if ( lastIsDirectory && keepSeparator ) { return new String ( array , 0 , size ) ; MST[rv.UOI4Mutator]MSP[N] }
for ( int i = 0 ; i < parts . length ; i ++ ) { if ( parts [ i ] . length () == 0 ) { return i == parts . length - 1 ; MST[InlineConstantMutator]MSP[N] }
list . add ( buffer . toString () ) ; } return list . toArray ( new String [ list . size () ] ) ; } private static boolean isValidHostName ( final String name ) { return isIPv6Address ( name ) || isRFC3986HostName ( name ) ; MST[rv.ROR4Mutator]MSP[N] }
final char ch1 = fileName . charAt ( 1 ) ; if ( ch1 == ':' ) { ch0 = Character . toUpperCase ( ch0 ) ; MST[rv.UOI1Mutator]MSP[S] if ( ch0 >= 'A' && ch0 <= 'Z' ) {
static boolean isSystemWindows () { return SYSTEM_SEPARATOR == WINDOWS_SEPARATOR ; MST[rv.CRCR6Mutator]MSP[N] } private static boolean isSeparator ( final char ch ) { return ch == UNIX_SEPARATOR || ch == WINDOWS_SEPARATOR ; } public static String normalize ( final String fileName ) {
if ( array [ i ] == separator && array [ i - 1 ] == '.' && array [ i - 2 ] == '.' && MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] ( i == prefix + 2 || array [ i - 3 ] == separator ) ) {
for ( int i = prefix + 1 ; i < size ; i ++ ) { MST[rv.ABSMutator]MSP[N] if ( array [ i ] == separator && array [ i - 1 ] == '.' &&
} return fileName . substring ( 0 , end ) ; MST[rv.UOI3Mutator]MSP[N] } public static String getName ( final String fileName ) { if ( fileName == null ) { return null ; } failIfNullBytePresent ( fileName ) ; final int index = indexOfLastSeparator ( fileName ) ;
list . add ( buffer . toString () ) ; } return list . toArray ( new String [ list . size () ] ) ; } private static boolean isValidHostName ( final String name ) { return isIPv6Address ( name ) || isRFC3986HostName ( name ) ; MST[rv.CRCR5Mutator]MSP[N] }
return new String ( array , 0 , size - 1 ) ; } public static String concat ( final String basePath , final String fullFileNameToAdd ) { final int prefix = getPrefixLength ( fullFileNameToAdd ) ; if ( prefix < 0 ) { MST[NegateConditionalsMutator]MSP[N] return null ; }
if ( extension == null || extension . isEmpty () ) { return indexOfExtension ( fileName ) == NOT_FOUND ; MST[InlineConstantMutator]MSP[N] } final String fileExt = getExtension ( fileName ) ; return fileExt . equals ( extension ) ; }
if ( isSystemWindows () ) { final int offset = fileName . indexOf ( ':' , getAdsCriticalOffset ( fileName ) ) ; if ( offset != - 1 ) { throw new IllegalArgumentException ( lr_2 ) ; } } final int extensionPos = fileName . lastIndexOf ( EXTENSION_SEPARATOR ) ; MST[NonVoidMethodCallMutator]MSP[N]
return doNormalize ( fileName , SYSTEM_SEPARATOR , true ) ; MST[ArgumentPropagationMutator]MSP[N] } public static String normalize ( final String fileName , final boolean unixSeparator ) { final char separator = unixSeparator ? UNIX_SEPARATOR : WINDOWS_SEPARATOR ; return doNormalize ( fileName , separator , true ) ; }
for ( int i = 1 ; i <= 4 ; i ++ ) { MST[rv.ROR4Mutator]MSP[N] final String ipSegment = m . group ( i ) ; final int iIpSegment = Integer . parseInt ( ipSegment ) ; if ( iIpSegment > IPV4_MAX_OCTET_VALUE ) { return false ; }
final char ch1 = fileName . charAt ( 1 ) ; if ( ch1 == ':' ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] ch0 = Character . toUpperCase ( ch0 ) ; if ( ch0 >= 'A' && ch0 <= 'Z' ) {
return caseSensitivity . checkEquals ( fileName1 , fileName2 ) ; } public static boolean isExtension ( final String fileName , final String extension ) { if ( fileName == null ) { return false ; MST[ReturnValsMutator]MSP[S] } failIfNullBytePresent ( fileName ) ;
System . arraycopy ( array , i + 1 , array , i - 1 , size - i ) ; size -= 2 ; i -- ; } } outer: for ( int i = prefix + 2 ; i < size ; i ++ ) { MST[rv.CRCR1Mutator]MSP[S]
return isSeparator ( ch0 ) ? 1 : 0 ; } if ( ch0 == '~' ) { MST[rv.ROR4Mutator]MSP[N] int posUnix = fileName . indexOf ( UNIX_SEPARATOR , 1 ) ; int posWin = fileName . indexOf ( WINDOWS_SEPARATOR , 1 ) ;
final char ch1 = fileName . charAt ( 1 ) ; if ( ch1 == ':' ) { ch0 = Character . toUpperCase ( ch0 ) ; if ( ch0 >= 'A' && ch0 <= 'Z' ) { MST[rv.CRCR4Mutator]MSP[N]
final char ch1 = fileName . charAt ( 1 ) ; if ( ch1 == ':' ) { ch0 = Character . toUpperCase ( ch0 ) ; if ( ch0 >= 'A' && ch0 <= 'Z' ) { MST[rv.CRCR5Mutator]MSP[N]
for ( int i = 1 ; i <= 4 ; i ++ ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] final String ipSegment = m . group ( i ) ; final int iIpSegment = Integer . parseInt ( ipSegment ) ; if ( iIpSegment > IPV4_MAX_OCTET_VALUE ) { return false ; }
return null ; } return isSystemWindows () ? separatorsToWindows ( path ) : separatorsToUnix ( path ) ; } public static int getPrefixLength ( final String fileName ) { if ( fileName == null ) { return NOT_FOUND ; MST[PrimitiveReturnsMutator]MSP[N] } final int len = fileName . length () ;
if ( len == 2 || isSeparator ( fileName . charAt ( 2 ) ) == false ) { return 2 ; } return 3 ; } else if ( ch0 == UNIX_SEPARATOR ) { MST[rv.ROR5Mutator]MSP[N] return 1 ; } return NOT_FOUND ;
if ( ch == '?' || ch == '*' ) { MST[rv.CRCR1Mutator]MSP[N] if ( buffer . length () != 0 ) { list . add ( buffer . toString () ) ; buffer . setLength ( 0 ) ; } if ( ch == '?' ) {
return new String ( array , 0 , size - 1 ) ; MST[rv.CRCR3Mutator]MSP[N] } public static String concat ( final String basePath , final String fullFileNameToAdd ) { final int prefix = getPrefixLength ( fullFileNameToAdd ) ; if ( prefix < 0 ) { return null ; }
octetInt = Integer . parseInt ( octet , BASE_16 ) ; MST[rv.CRCR1Mutator]MSP[N] } catch ( final NumberFormatException e ) { return false ; } if ( octetInt < 0 || octetInt > MAX_UNSIGNED_SHORT ) { return false ; } } validOctets ++ ; }
return false ; } static String [] splitOnTokens ( final String text ) { if ( text . indexOf ( '?' ) == NOT_FOUND && text . indexOf ( '*' ) == NOT_FOUND ) { return new String [] { text } ; MST[rv.CRCR6Mutator]MSP[N] }
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2 ) { MST[rv.ROR3Mutator]MSP[N] return NOT_FOUND ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ;
textIdx += wcs [ wcsIdx ] . length () ; anyChars = false ; } wcsIdx ++ ; } if ( wcsIdx == wcs . length && textIdx == fileName . length () ) { MST[rv.ROR5Mutator]MSP[N] return true ; } } while ( backtrack . size () > 0 );
} else if ( inet6Address . startsWith ( lr_9 ) && ! octetList . isEmpty () ) { octetList . remove ( 0 ) ; } octets = octetList . toArray ( new String [ octetList . size () ] ) ; MST[NonVoidMethodCallMutator]MSP[N] }
System . arraycopy ( array , i + 1 , array , prefix , size - i ) ; size -= i + 1 - prefix ; i = prefix + 1 ; } } if ( size <= 0 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[S] return EMPTY_STRING ; }
return isSeparator ( ch0 ) ? 1 : 0 ; MST[rv.CRCR6Mutator]MSP[N] } } public static int indexOfLastSeparator ( final String fileName ) { if ( fileName == null ) { return NOT_FOUND ; } final int lastUnixPos = fileName . lastIndexOf ( UNIX_SEPARATOR ) ;
if ( validOctets > IPV6_MAX_HEX_GROUPS || ( validOctets < IPV6_MAX_HEX_GROUPS && ! containsCompressedZeroes ) ) { MST[ConditionalsBoundaryMutator]MSP[N] return false ; } return true ; } private static boolean isRFC3986HostName ( final String name ) { final String [] parts = name . split ( lr_13 , - 1 ) ;
if ( array [ j ] == separator ) { System . arraycopy ( array , i + 1 , array , j + 1 , size - i ) ; MST[rv.CRCR2Mutator]MSP[N] size -= i - j ; i = j + 1 ; continue outer; } }
return fileName . substring ( index + 1 ) ; } private static void failIfNullBytePresent ( final String path ) { final int len = path . length () ; for ( int i = 0 ; i < len ; i ++ ) { MST[ConditionalsBoundaryMutator]MSP[N]
return indexOfExtension ( fileName ) == NOT_FOUND ; } final String fileExt = getExtension ( fileName ) ; for ( final String extension : extensions ) { MST[rv.UOI1Mutator]MSP[S] if ( fileExt . equals ( extension ) ) { return true ; } } return false ; }
System . arraycopy ( array , i + 1 , array , i - 1 , size - i ) ; size -= 2 ; i -- ; } } outer: for ( int i = prefix + 2 ; i < size ; i ++ ) { MST[rv.ROR3Mutator]MSP[S]
if ( array [ size - 1 ] != separator ) { array [ size ++ ] = separator ; lastIsDirectory = false ; } for ( int i = prefix + 1 ; i < size ; i ++ ) { MST[rv.UOI3Mutator]MSP[N]
textIdx += wcs [ wcsIdx ] . length () ; anyChars = false ; } wcsIdx ++ ; } if ( wcsIdx == wcs . length && textIdx == fileName . length () ) { return true ; } } while ( backtrack . size () > 0 ); MST[RemoveConditionalMutator_ORDER_IF]MSP[N]
if ( octet . length () == 0 ) { emptyOctets ++ ; if ( emptyOctets > 1 ) { return false ; } } else { emptyOctets = 0 ; if ( index == octets . length - 1 && octet . contains ( lr_12 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S]
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND ) { return len + 1 ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ; return Math . min ( posUnix , posWin ) + 1 ; MST[rv.CRCR2Mutator]MSP[N] }
textIdx = caseSensitivity . checkIndexOf ( fileName , textIdx , wcs [ wcsIdx ] ) ; if ( textIdx == NOT_FOUND ) { MST[rv.UOI3Mutator]MSP[N] break; } final int repeat = caseSensitivity . checkIndexOf ( fileName , textIdx + 1 , wcs [ wcsIdx ] ) ;
for ( int i = 1 ; i <= 4 ; i ++ ) { final String ipSegment = m . group ( i ) ; final int iIpSegment = Integer . parseInt ( ipSegment ) ; if ( iIpSegment > IPV4_MAX_OCTET_VALUE ) { MST[InlineConstantMutator]MSP[N] return false ; }
if ( array [ j ] == separator ) { System . arraycopy ( array , i + 1 , array , j + 1 , size - i ) ; size -= i - j ; i = j + 1 ; MST[rv.AOR3Mutator]MSP[N] continue outer; } }
failIfNullBytePresent ( path ) ; return path ; } public static String getPath ( final String fileName ) { return doGetPath ( fileName , 1 ) ; } public static String getPathNoEndSeparator ( final String fileName ) { return doGetPath ( fileName , 0 ) ; MST[ReturnValsMutator]MSP[N] }
private static String doGetPath ( final String fileName , final int separatorAdd ) { if ( fileName == null ) { return null ; } final int prefix = getPrefixLength ( fileName ) ; if ( prefix < 0 ) { MST[NegateConditionalsMutator]MSP[N] return null ; }
final int index = indexOfLastSeparator ( fileName ) ; if ( index < 0 ) { return fileName . substring ( 0 , prefix ) ; } int end = index + ( includeSeparator ? 1 : 0 ) ; MST[rv.ROR2Mutator]MSP[N] if ( end == 0 ) { end ++ ;
System . arraycopy ( array , i + 1 , array , i - 1 , size - i ) ; MST[rv.AOR1Mutator]MSP[N] size -= 2 ; i -- ; } } outer: for ( int i = prefix + 2 ; i < size ; i ++ ) {
} else if ( isSeparator ( ch0 ) && isSeparator ( ch1 ) ) { int posUnix = fileName . indexOf ( UNIX_SEPARATOR , 2 ) ; int posWin = fileName . indexOf ( WINDOWS_SEPARATOR , 2 ) ; MST[InlineConstantMutator]MSP[N]
if ( len == 0 ) { return 0 ; } char ch0 = fileName . charAt ( 0 ) ; if ( ch0 == ':' ) { return NOT_FOUND ; MST[InlineConstantMutator]MSP[N] } if ( len == 1 ) { if ( ch0 == '~' ) { return 2 ; }
return indexOfExtension ( fileName ) == NOT_FOUND ; } final String fileExt = getExtension ( fileName ) ; for ( final String extension : extensions ) { if ( fileExt . equals ( extension ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return true ; } } return false ; }
octetInt = Integer . parseInt ( octet , BASE_16 ) ; } catch ( final NumberFormatException e ) { return false ; MST[rv.CRCR5Mutator]MSP[S] } if ( octetInt < 0 || octetInt > MAX_UNSIGNED_SHORT ) { return false ; } } validOctets ++ ; }
return equals ( fileName1 , fileName2 , true , IOCase . SENSITIVE ) ; MST[ReturnValsMutator]MSP[N] } public static boolean equalsNormalizedOnSystem ( final String fileName1 , final String fileName2 ) { return equals ( fileName1 , fileName2 , true , IOCase . SYSTEM ) ; } public static boolean equals (
if ( array [ i ] == separator && array [ i - 1 ] == separator ) { MST[rv.CRCR2Mutator]MSP[N] System . arraycopy ( array , i , array , i - 1 , size - i ) ; size -- ; i -- ; } }
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND ) { return len + 1 ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; MST[rv.CRCR4Mutator]MSP[N] posWin = posWin == NOT_FOUND ? posUnix : posWin ; return Math . min ( posUnix , posWin ) + 1 ; }
if ( ! isIPv4Address ( octet ) ) { return false ; } validOctets += 2 ; continue; } if ( octet . length () > IPV6_MAX_HEX_DIGITS_PER_GROUP ) { return false ; } int octetInt = 0 ; MST[rv.CRCR5Mutator]MSP[N] try {
System . arraycopy ( array , i + 1 , array , prefix , size - i ) ; size -= i + 1 - prefix ; MST[rv.AOR1Mutator]MSP[N] i = prefix + 1 ; } } if ( size <= 0 ) { return EMPTY_STRING ; }
} return fileName . substring ( 0 , end ) ; MST[InlineConstantMutator]MSP[N] } public static String getName ( final String fileName ) { if ( fileName == null ) { return null ; } failIfNullBytePresent ( fileName ) ; final int index = indexOfLastSeparator ( fileName ) ;
for ( int i = prefix + 1 ; i < size ; i ++ ) { if ( array [ i ] == separator && array [ i - 1 ] == '.' && MST[rv.ROR1Mutator]MSP[N]
if ( i == prefix + 2 ) { return null ; } if ( i == size - 1 ) { MST[rv.UOI2Mutator]MSP[N] lastIsDirectory = true ; } int j ; for ( j = i - 4 ; j >= prefix ; j -- ) {
public static boolean directoryContains ( final String canonicalParent , final String canonicalChild ) throws IOException { if ( canonicalParent == null ) { throw new IllegalArgumentException ( lr_1 ) ; } if ( canonicalChild == null ) { return false ; MST[rv.CRCR5Mutator]MSP[N] }
if ( index == NOT_FOUND ) { MST[NegateConditionalsMutator]MSP[N] return fileName ; } return fileName . substring ( 0 , index ) ; } public static boolean equals ( final String fileName1 , final String fileName2 ) { return equals ( fileName1 , fileName2 , false , IOCase . SENSITIVE ) ;
if ( isSystemWindows () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] final int offset = fileName . indexOf ( ':' , getAdsCriticalOffset ( fileName ) ) ; if ( offset != - 1 ) { throw new IllegalArgumentException ( lr_2 ) ; } } final int extensionPos = fileName . lastIndexOf ( EXTENSION_SEPARATOR ) ;
textIdx = caseSensitivity . checkIndexOf ( fileName , textIdx , wcs [ wcsIdx ] ) ; if ( textIdx == NOT_FOUND ) { break; } final int repeat = caseSensitivity . checkIndexOf ( fileName , textIdx + 1 , wcs [ wcsIdx ] ) ; MST[rv.UOI1Mutator]MSP[N]
int size = fileName . length () ; if ( size == 0 ) { return fileName ; } final int prefix = getPrefixLength ( fileName ) ; if ( prefix < 0 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] return null ; }
for ( int i = prefix + 1 ; i < size ; i ++ ) { if ( array [ i ] == separator && array [ i - 1 ] == '.' && MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
if ( array [ j ] == separator ) { MST[rv.UOI4Mutator]MSP[N] System . arraycopy ( array , i + 1 , array , j + 1 , size - i ) ; size -= i - j ; i = j + 1 ; continue outer; } }
if ( i == prefix + 2 ) { return null ; } if ( i == size - 1 ) { lastIsDirectory = true ; } int j ; for ( j = i - 4 ; j >= prefix ; j -- ) { MST[rv.UOI2Mutator]MSP[N]
if ( ! isIPv4Address ( octet ) ) { return false ; MST[rv.CRCR3Mutator]MSP[N] } validOctets += 2 ; continue; } if ( octet . length () > IPV6_MAX_HEX_DIGITS_PER_GROUP ) { return false ; } int octetInt = 0 ; try {
list . add ( lr_6 ) ; } else if ( prevChar != '*' ) { list . add ( lr_7 ) ; } } else { buffer . append ( ch ) ; } prevChar = ch ; } if ( buffer . length () != 0 ) { MST[rv.ROR3Mutator]MSP[N]
if ( octets . length > IPV6_MAX_HEX_GROUPS ) { return false ; } int validOctets = 0 ; int emptyOctets = 0 ; for ( int index = 0 ; index < octets . length ; index ++ ) { MST[NegateConditionalsMutator]MSP[N] final String octet = octets [ index ] ;
final int prefix = getPrefixLength ( fileName ) ; if ( prefix < 0 ) { return null ; } if ( prefix >= fileName . length () ) { MST[rv.ROR1Mutator]MSP[S] if ( includeSeparator ) { return getPrefix ( fileName ) ; } return fileName ; }
System . arraycopy ( array , i + 1 , array , prefix , size - i ) ; size -= i + 1 - prefix ; i = prefix + 1 ; MST[rv.AOR4Mutator]MSP[N] } } if ( size <= 0 ) { return EMPTY_STRING ; }
public static String getExtension ( final String fileName ) throws IllegalArgumentException { if ( fileName == null ) { return null ; } final int index = indexOfExtension ( fileName ) ; if ( index == NOT_FOUND ) { MST[rv.ROR4Mutator]MSP[N] return EMPTY_STRING ; }
if ( array [ i ] == separator && array [ i - 1 ] == separator ) { MST[rv.UOI2Mutator]MSP[N] System . arraycopy ( array , i , array , i - 1 , size - i ) ; size -- ; i -- ; } }
System . arraycopy ( array , i + 1 , array , i - 1 , size - i ) ; MST[rv.ABSMutator]MSP[N] size -= 2 ; i -- ; } } outer: for ( int i = prefix + 2 ; i < size ; i ++ ) {
if ( array [ size - 1 ] != separator ) { array [ size ++ ] = separator ; lastIsDirectory = false ; } for ( int i = prefix + 1 ; i < size ; i ++ ) { MST[rv.CRCR2Mutator]MSP[S]
if ( i == prefix + 2 ) { return null ; } if ( i == size - 1 ) { lastIsDirectory = true ; MST[rv.CRCR5Mutator]MSP[N] } int j ; for ( j = i - 4 ; j >= prefix ; j -- ) {
if ( repeat >= 0 ) { backtrack . push ( new int [] { wcsIdx , repeat } ) ; MST[rv.UOI3Mutator]MSP[N] } } else { if ( ! caseSensitivity . checkRegionMatches ( fileName , textIdx , wcs [ wcsIdx ] ) ) { break; } }
if ( containsCompressedZeroes && ( inet6Address . indexOf ( lr_9 ) != inet6Address . lastIndexOf ( lr_9 ) ) ) { return false ; } if ( ( inet6Address . startsWith ( lr_10 ) && ! inet6Address . startsWith ( lr_9 ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
if ( prefix > 0 ) { return normalize ( fullFileNameToAdd ) ; } if ( basePath == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return null ; } final int len = basePath . length () ; if ( len == 0 ) { return normalize ( fullFileNameToAdd ) ; }
final int lastWindowsPos = fileName . lastIndexOf ( WINDOWS_SEPARATOR ) ; return Math . max ( lastUnixPos , lastWindowsPos ) ; MST[rv.ABSMutator]MSP[N] } public static int indexOfExtension ( final String fileName ) throws IllegalArgumentException { if ( fileName == null ) { return NOT_FOUND ; }
final int pos = Math . min ( posUnix , posWin ) + 1 ; final String hostnamePart = fileName . substring ( 2 , pos - 1 ) ; MST[rv.CRCR2Mutator]MSP[N] return isValidHostName ( hostnamePart ) ? pos : NOT_FOUND ; } else {
System . arraycopy ( array , i + 1 , array , prefix , size - i ) ; size -= i + 1 - prefix ; i = prefix + 1 ; } } if ( size <= 0 ) { MST[rv.ROR5Mutator]MSP[S] return EMPTY_STRING ; }
if ( index == NOT_FOUND ) { MST[InlineConstantMutator]MSP[N] return fileName ; } return fileName . substring ( 0 , index ) ; } public static boolean equals ( final String fileName1 , final String fileName2 ) { return equals ( fileName1 , fileName2 , false , IOCase . SENSITIVE ) ;
if ( prefix > 0 ) { return normalize ( fullFileNameToAdd ) ; } if ( basePath == null ) { return null ; } final int len = basePath . length () ; if ( len == 0 ) { MST[rv.UOI3Mutator]MSP[N] return normalize ( fullFileNameToAdd ) ; }
} return fileName . substring ( 0 , end ) ; } public static String getName ( final String fileName ) { if ( fileName == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] return null ; } failIfNullBytePresent ( fileName ) ; final int index = indexOfLastSeparator ( fileName ) ;
list . add ( buffer . toString () ) ; } return list . toArray ( new String [ list . size () ] ) ; } private static boolean isValidHostName ( final String name ) { return isIPv6Address ( name ) || isRFC3986HostName ( name ) ; MST[NegateConditionalsMutator]MSP[N] }
final List < String > octetList = new ArrayList <> ( Arrays . asList ( octets ) ) ; if ( inet6Address . endsWith ( lr_9 ) ) { octetList . add ( lr_11 ) ; MST[NonVoidMethodCallMutator]MSP[N]
final int pos = Math . min ( posUnix , posWin ) + 1 ; MST[rv.UOI3Mutator]MSP[N] final String hostnamePart = fileName . substring ( 2 , pos - 1 ) ; return isValidHostName ( hostnamePart ) ? pos : NOT_FOUND ; } else {
if ( len == 0 ) { return 0 ; } char ch0 = fileName . charAt ( 0 ) ; if ( ch0 == ':' ) { return NOT_FOUND ; } if ( len == 1 ) { if ( ch0 == '~' ) { MST[rv.UOI4Mutator]MSP[N] return 2 ; }
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND ) { return len + 1 ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; MST[rv.UOI3Mutator]MSP[N] posWin = posWin == NOT_FOUND ? posUnix : posWin ; return Math . min ( posUnix , posWin ) + 1 ; }
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2 ) { return NOT_FOUND ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; MST[rv.CRCR5Mutator]MSP[N] posWin = posWin == NOT_FOUND ? posUnix : posWin ;
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2 ) { MST[rv.UOI1Mutator]MSP[N] return NOT_FOUND ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ;
if ( octets . length > IPV6_MAX_HEX_GROUPS ) { return false ; } int validOctets = 0 ; MST[rv.CRCR1Mutator]MSP[N] int emptyOctets = 0 ; for ( int index = 0 ; index < octets . length ; index ++ ) { final String octet = octets [ index ] ;
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND ) { MST[rv.ROR4Mutator]MSP[N] return len + 1 ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ; return Math . min ( posUnix , posWin ) + 1 ; }
return isSeparator ( ch0 ) ? 1 : 0 ; } } public static int indexOfLastSeparator ( final String fileName ) { if ( fileName == null ) { return NOT_FOUND ; } final int lastUnixPos = fileName . lastIndexOf ( UNIX_SEPARATOR ) ; MST[rv.CRCR6Mutator]MSP[N]
for ( int i = prefix + 1 ; i < size ; i ++ ) { if ( array [ i ] == separator && array [ i - 1 ] == '.' && MST[rv.UOI1Mutator]MSP[N]
|| ( inet6Address . endsWith ( lr_10 ) && ! inet6Address . endsWith ( lr_9 ) ) ) { return false ; MST[BooleanTrueReturnValsMutator]MSP[S] } String [] octets = inet6Address . split ( lr_10 ) ; if ( containsCompressedZeroes ) {
if ( i == prefix + 2 ) { return null ; } if ( i == size - 1 ) { lastIsDirectory = true ; } int j ; for ( j = i - 4 ; j >= prefix ; j -- ) { MST[rv.UOI2Mutator]MSP[N]
for ( int i = 1 ; i <= 4 ; i ++ ) { final String ipSegment = m . group ( i ) ; final int iIpSegment = Integer . parseInt ( ipSegment ) ; if ( iIpSegment > IPV4_MAX_OCTET_VALUE ) { MST[rv.ROR5Mutator]MSP[N] return false ; }
final String path = fileName . substring ( prefix , endIndex ) ; failIfNullBytePresent ( path ) ; MST[VoidMethodCallMutator]MSP[S] return path ; } public static String getFullPath ( final String fileName ) { return doGetFullPath ( fileName , true ) ; }
anyChars = false ; } else if ( wcs [ wcsIdx ] . equals ( lr_7 ) ) { anyChars = true ; if ( wcsIdx == wcs . length - 1 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] textIdx = fileName . length () ; } } else { if ( anyChars ) {
final int prefix = getPrefixLength ( fileName ) ; if ( prefix < 0 ) { return null ; } if ( prefix >= fileName . length () ) { MST[rv.UOI1Mutator]MSP[N] if ( includeSeparator ) { return getPrefix ( fileName ) ; } return fileName ; }
textIdx = array [ 1 ] ; anyChars = true ; } while ( wcsIdx < wcs . length ) { MST[rv.ROR3Mutator]MSP[N] if ( wcs [ wcsIdx ] . equals ( lr_6 ) ) { textIdx ++ ; if ( textIdx > fileName . length () ) { break; }
if ( path == null || path . indexOf ( UNIX_SEPARATOR ) == NOT_FOUND ) { MST[rv.CRCR1Mutator]MSP[N] return path ; } return path . replace ( UNIX_SEPARATOR , WINDOWS_SEPARATOR ) ; } public static String separatorsToSystem ( final String path ) { if ( path == null ) {
final int lastWindowsPos = fileName . lastIndexOf ( WINDOWS_SEPARATOR ) ; return Math . max ( lastUnixPos , lastWindowsPos ) ; MST[ArgumentPropagationMutator]MSP[N] } public static int indexOfExtension ( final String fileName ) throws IllegalArgumentException { if ( fileName == null ) { return NOT_FOUND ; }
list . add ( lr_6 ) ; } else if ( prevChar != '*' ) { list . add ( lr_7 ) ; } } else { buffer . append ( ch ) ; } prevChar = ch ; } if ( buffer . length () != 0 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
if ( IOCase . SYSTEM . checkEquals ( canonicalParent , canonicalChild ) ) { MST[rv.ROR4Mutator]MSP[S] return false ; } return IOCase . SYSTEM . checkStartsWith ( canonicalChild , canonicalParent ) ; } public static String separatorsToUnix ( final String path ) {
final int index = indexOfLastSeparator ( fileName ) ; final int endIndex = index + separatorAdd ; if ( prefix >= fileName . length () || index < 0 || prefix >= endIndex ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] return EMPTY_STRING ; }
return indexOfExtension ( fileName ) == NOT_FOUND ; MST[rv.CRCR6Mutator]MSP[N] } final String fileExt = getExtension ( fileName ) ; for ( final String extension : extensions ) { if ( fileExt . equals ( extension ) ) { return true ; } } return false ; }
final int pos = Math . min ( posUnix , posWin ) + 1 ; final String hostnamePart = fileName . substring ( 2 , pos - 1 ) ; MST[experimental.NakedReceiverMutator]MSP[N] return isValidHostName ( hostnamePart ) ? pos : NOT_FOUND ; } else {
int wcsIdx = 0 ; final Stack < int [] > backtrack = new Stack <> () ; do { if ( backtrack . size () > 0 ) { final int [] array = backtrack . pop () ; wcsIdx = array [ 0 ] ; MST[rv.ABSMutator]MSP[S]
failIfNullBytePresent ( path ) ; return path ; } public static String getPath ( final String fileName ) { return doGetPath ( fileName , 1 ) ; MST[EmptyObjectReturnValsMutator]MSP[N] } public static String getPathNoEndSeparator ( final String fileName ) { return doGetPath ( fileName , 0 ) ; }
if ( path == null || path . indexOf ( UNIX_SEPARATOR ) == NOT_FOUND ) { return path ; } return path . replace ( UNIX_SEPARATOR , WINDOWS_SEPARATOR ) ; MST[rv.CRCR4Mutator]MSP[N] } public static String separatorsToSystem ( final String path ) { if ( path == null ) {
failIfNullBytePresent ( path ) ; return path ; } public static String getPath ( final String fileName ) { return doGetPath ( fileName , 1 ) ; } public static String getPathNoEndSeparator ( final String fileName ) { return doGetPath ( fileName , 0 ) ; MST[InlineConstantMutator]MSP[S] }
} return fileName . substring ( 0 , end ) ; } public static String getName ( final String fileName ) { if ( fileName == null ) { return null ; MST[EmptyObjectReturnValsMutator]MSP[S] } failIfNullBytePresent ( fileName ) ; final int index = indexOfLastSeparator ( fileName ) ;
if ( index == NOT_FOUND ) { return fileName ; } return fileName . substring ( 0 , index ) ; } public static boolean equals ( final String fileName1 , final String fileName2 ) { return equals ( fileName1 , fileName2 , false , IOCase . SENSITIVE ) ; MST[ArgumentPropagationMutator]MSP[S]
if ( path == null || path . indexOf ( WINDOWS_SEPARATOR ) == NOT_FOUND ) { MST[rv.CRCR6Mutator]MSP[N] return path ; } return path . replace ( WINDOWS_SEPARATOR , UNIX_SEPARATOR ) ; } public static String separatorsToWindows ( final String path ) {
if ( ! isIPv4Address ( octet ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] return false ; } validOctets += 2 ; continue; } if ( octet . length () > IPV6_MAX_HEX_DIGITS_PER_GROUP ) { return false ; } int octetInt = 0 ; try {
list . add ( buffer . toString () ) ; } return list . toArray ( new String [ list . size () ] ) ; } private static boolean isValidHostName ( final String name ) { return isIPv6Address ( name ) || isRFC3986HostName ( name ) ; MST[rv.ROR5Mutator]MSP[N] }
if ( fileName == null || wildcardMatcher == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return false ; } if ( caseSensitivity == null ) { caseSensitivity = IOCase . SENSITIVE ; } final String [] wcs = splitOnTokens ( wildcardMatcher ) ; boolean anyChars = false ; int textIdx = 0 ;
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND ) { return len + 1 ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ; MST[rv.UOI3Mutator]MSP[N] return Math . min ( posUnix , posWin ) + 1 ; }
int wcsIdx = 0 ; final Stack < int [] > backtrack = new Stack <> () ; do { if ( backtrack . size () > 0 ) { final int [] array = backtrack . pop () ; wcsIdx = array [ 0 ] ; MST[rv.UOI2Mutator]MSP[N]
for ( int i = 0 ; i < parts . length ; i ++ ) { if ( parts [ i ] . length () == 0 ) { MST[rv.ROR2Mutator]MSP[N] return i == parts . length - 1 ; }
if ( i == prefix + 2 ) { MST[NegateConditionalsMutator]MSP[N] return null ; } if ( i == size - 1 ) { lastIsDirectory = true ; } int j ; for ( j = i - 4 ; j >= prefix ; j -- ) {
if ( array [ j ] == separator ) { System . arraycopy ( array , i + 1 , array , j + 1 , size - i ) ; size -= i - j ; MST[rv.UOI1Mutator]MSP[N] i = j + 1 ; continue outer; } }
if ( validOctets > IPV6_MAX_HEX_GROUPS || ( validOctets < IPV6_MAX_HEX_GROUPS && ! containsCompressedZeroes ) ) { return false ; } return true ; } private static boolean isRFC3986HostName ( final String name ) { final String [] parts = name . split ( lr_13 , - 1 ) ; MST[rv.CRCR4Mutator]MSP[N]
public static boolean isExtension ( final String fileName , final String ... extensions ) { if ( fileName == null ) { return false ; MST[rv.CRCR1Mutator]MSP[N] } failIfNullBytePresent ( fileName ) ; if ( extensions == null || extensions . length == 0 ) {
if ( len == 2 || isSeparator ( fileName . charAt ( 2 ) ) == false ) { MST[rv.CRCR1Mutator]MSP[N] return 2 ; } return 3 ; } else if ( ch0 == UNIX_SEPARATOR ) { return 1 ; } return NOT_FOUND ;
if ( array [ size - 1 ] != separator ) { MST[rv.AOR1Mutator]MSP[N] array [ size ++ ] = separator ; lastIsDirectory = false ; } for ( int i = prefix + 1 ; i < size ; i ++ ) {
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND ) { return len + 1 ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ; MST[rv.ABSMutator]MSP[N] return Math . min ( posUnix , posWin ) + 1 ; }
for ( int i = prefix + 1 ; i < size ; i ++ ) { MST[rv.UOI1Mutator]MSP[N] if ( array [ i ] == separator && array [ i - 1 ] == '.' &&
public static boolean directoryContains ( final String canonicalParent , final String canonicalChild ) throws IOException { if ( canonicalParent == null ) { throw new IllegalArgumentException ( lr_1 ) ; } if ( canonicalChild == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return false ; }
if ( array [ i ] == separator && array [ i - 1 ] == '.' && array [ i - 2 ] == '.' && MST[rv.CRCR1Mutator]MSP[N] ( i == prefix + 2 || array [ i - 3 ] == separator ) ) {
if ( prefix > 0 ) { return normalize ( fullFileNameToAdd ) ; } if ( basePath == null ) { return null ; } final int len = basePath . length () ; if ( len == 0 ) { MST[rv.ROR4Mutator]MSP[N] return normalize ( fullFileNameToAdd ) ; }
return equals ( fileName1 , fileName2 , true , IOCase . SENSITIVE ) ; MST[BooleanTrueReturnValsMutator]MSP[N] } public static boolean equalsNormalizedOnSystem ( final String fileName1 , final String fileName2 ) { return equals ( fileName1 , fileName2 , true , IOCase . SYSTEM ) ; } public static boolean equals (
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2 ) { MST[rv.ROR5Mutator]MSP[N] return NOT_FOUND ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ;
System . arraycopy ( array , i + 1 , array , prefix , size - i ) ; MST[rv.AOR3Mutator]MSP[N] size -= i + 1 - prefix ; i = prefix + 1 ; } } if ( size <= 0 ) { return EMPTY_STRING ; }
} else if ( inet6Address . startsWith ( lr_9 ) && ! octetList . isEmpty () ) { octetList . remove ( 0 ) ; MST[NonVoidMethodCallMutator]MSP[N] } octets = octetList . toArray ( new String [ octetList . size () ] ) ; }
if ( i == prefix + 2 ) { return null ; } if ( i == size - 1 ) { lastIsDirectory = true ; } int j ; for ( j = i - 4 ; j >= prefix ; j -- ) { MST[IncrementsMutator]MSP[N]
if ( ! isIPv4Address ( octet ) ) { return false ; MST[rv.CRCR5Mutator]MSP[N] } validOctets += 2 ; continue; } if ( octet . length () > IPV6_MAX_HEX_DIGITS_PER_GROUP ) { return false ; } int octetInt = 0 ; try {
for ( int i = 1 ; i <= 4 ; i ++ ) { final String ipSegment = m . group ( i ) ; final int iIpSegment = Integer . parseInt ( ipSegment ) ; if ( iIpSegment > IPV4_MAX_OCTET_VALUE ) { MST[NegateConditionalsMutator]MSP[S] return false ; }
if ( len == 0 ) { MST[rv.UOI1Mutator]MSP[N] return 0 ; } char ch0 = fileName . charAt ( 0 ) ; if ( ch0 == ':' ) { return NOT_FOUND ; } if ( len == 1 ) { if ( ch0 == '~' ) { return 2 ; }
if ( array [ i ] == separator && array [ i - 1 ] == '.' && array [ i - 2 ] == '.' && MST[rv.AOR1Mutator]MSP[N] ( i == prefix + 2 || array [ i - 3 ] == separator ) ) {
if ( len == 0 ) { MST[rv.ROR2Mutator]MSP[N] return 0 ; } char ch0 = fileName . charAt ( 0 ) ; if ( ch0 == ':' ) { return NOT_FOUND ; } if ( len == 1 ) { if ( ch0 == '~' ) { return 2 ; }
final char ch = basePath . charAt ( len - 1 ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( isSeparator ( ch ) ) { return normalize ( basePath + fullFileNameToAdd ) ; } return normalize ( basePath + '/' + fullFileNameToAdd ) ; }
|| ( inet6Address . endsWith ( lr_10 ) && ! inet6Address . endsWith ( lr_9 ) ) ) { return false ; } String [] octets = inet6Address . split ( lr_10 ) ; if ( containsCompressedZeroes ) { MST[rv.UOI1Mutator]MSP[S]
} else if ( isSeparator ( ch0 ) && isSeparator ( ch1 ) ) { MST[rv.UOI2Mutator]MSP[N] int posUnix = fileName . indexOf ( UNIX_SEPARATOR , 2 ) ; int posWin = fileName . indexOf ( WINDOWS_SEPARATOR , 2 ) ;
if ( array [ i ] == separator && array [ i - 1 ] == '.' && array [ i - 2 ] == '.' && MST[rv.AOR2Mutator]MSP[N] ( i == prefix + 2 || array [ i - 3 ] == separator ) ) {
if ( array [ size - 1 ] != separator ) { array [ size ++ ] = separator ; lastIsDirectory = false ; } for ( int i = prefix + 1 ; i < size ; i ++ ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N]
fileName2 = normalize ( fileName2 ) ; if ( fileName1 == null || fileName2 == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] throw new NullPointerException ( lr_5 ) ; } } if ( caseSensitivity == null ) { caseSensitivity = IOCase . SENSITIVE ; }
if ( array [ i ] == separator && array [ i - 1 ] == separator ) { System . arraycopy ( array , i , array , i - 1 , size - i ) ; MST[rv.UOI1Mutator]MSP[N] size -- ; i -- ; } }
if ( octets . length > IPV6_MAX_HEX_GROUPS ) { return false ; } int validOctets = 0 ; int emptyOctets = 0 ; for ( int index = 0 ; index < octets . length ; index ++ ) { MST[rv.ROR2Mutator]MSP[N] final String octet = octets [ index ] ;
if ( ipSegment . length () > 1 && ipSegment . startsWith ( lr_8 ) ) { return false ; MST[rv.CRCR5Mutator]MSP[N] } } return true ; } private static boolean isIPv6Address ( final String inet6Address ) { final boolean containsCompressedZeroes = inet6Address . contains ( lr_9 ) ;
if ( size <= prefix ) { return new String ( array , 0 , size ) ; } if ( lastIsDirectory && keepSeparator ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return new String ( array , 0 , size ) ; }
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2 ) { return NOT_FOUND ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ; MST[rv.UOI4Mutator]MSP[N]
octetInt = Integer . parseInt ( octet , BASE_16 ) ; MST[rv.CRCR3Mutator]MSP[N] } catch ( final NumberFormatException e ) { return false ; } if ( octetInt < 0 || octetInt > MAX_UNSIGNED_SHORT ) { return false ; } } validOctets ++ ; }
final int index = indexOfLastSeparator ( fileName ) ; if ( index < 0 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] return fileName . substring ( 0 , prefix ) ; } int end = index + ( includeSeparator ? 1 : 0 ) ; if ( end == 0 ) { end ++ ;
final String path = fileName . substring ( prefix , endIndex ) ; MST[rv.UOI2Mutator]MSP[N] failIfNullBytePresent ( path ) ; return path ; } public static String getFullPath ( final String fileName ) { return doGetFullPath ( fileName , true ) ; }
return null ; } return isSystemWindows () ? separatorsToWindows ( path ) : separatorsToUnix ( path ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } public static int getPrefixLength ( final String fileName ) { if ( fileName == null ) { return NOT_FOUND ; } final int len = fileName . length () ;
if ( i == prefix + 2 ) { MST[rv.ROR5Mutator]MSP[N] return null ; } if ( i == size - 1 ) { lastIsDirectory = true ; } int j ; for ( j = i - 4 ; j >= prefix ; j -- ) {
for ( int i = prefix + 1 ; i < size ; i ++ ) { MST[rv.UOI2Mutator]MSP[N] if ( array [ i ] == separator && array [ i - 1 ] == '.' &&
System . arraycopy ( array , i + 1 , array , prefix , size - i ) ; MST[rv.AOD1Mutator]MSP[N] size -= i + 1 - prefix ; i = prefix + 1 ; } } if ( size <= 0 ) { return EMPTY_STRING ; }
if ( i == prefix + 2 ) { return null ; } if ( i == size - 1 ) { lastIsDirectory = true ; } int j ; for ( j = i - 4 ; j >= prefix ; j -- ) { MST[rv.UOI1Mutator]MSP[N]
return isSeparator ( ch0 ) ? 1 : 0 ; MST[rv.CRCR3Mutator]MSP[N] } if ( ch0 == '~' ) { int posUnix = fileName . indexOf ( UNIX_SEPARATOR , 1 ) ; int posWin = fileName . indexOf ( WINDOWS_SEPARATOR , 1 ) ;
anyChars = false ; } else if ( wcs [ wcsIdx ] . equals ( lr_7 ) ) { anyChars = true ; if ( wcsIdx == wcs . length - 1 ) { MST[rv.CRCR2Mutator]MSP[N] textIdx = fileName . length () ; } } else { if ( anyChars ) {
if ( array [ i ] == separator && array [ i - 1 ] == '.' && array [ i - 2 ] == '.' && MST[rv.CRCR2Mutator]MSP[N] ( i == prefix + 2 || array [ i - 3 ] == separator ) ) {
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND ) { return len + 1 ; MST[rv.UOI4Mutator]MSP[N] } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ; return Math . min ( posUnix , posWin ) + 1 ; }
for ( int i = prefix + 1 ; i < size ; i ++ ) { if ( array [ i ] == separator && array [ i - 1 ] == '.' && MST[rv.UOI2Mutator]MSP[N]
if ( len < 0 ) { return null ; } if ( len > fileName . length () ) { failIfNullBytePresent ( fileName + UNIX_SEPARATOR ) ; MST[NonVoidMethodCallMutator]MSP[N] return fileName + UNIX_SEPARATOR ; } final String path = fileName . substring ( 0 , len ) ;
public static boolean isExtension ( final String fileName , final Collection < String > extensions ) { if ( fileName == null ) { return false ; } failIfNullBytePresent ( fileName ) ; MST[VoidMethodCallMutator]MSP[N] if ( extensions == null || extensions . isEmpty () ) {
if ( ipSegment . length () > 1 && ipSegment . startsWith ( lr_8 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] return false ; } } return true ; } private static boolean isIPv6Address ( final String inet6Address ) { final boolean containsCompressedZeroes = inet6Address . contains ( lr_9 ) ;
for ( int i = prefix + 1 ; i < size ; i ++ ) { if ( array [ i ] == separator && array [ i - 1 ] == '.' && MST[InlineConstantMutator]MSP[N]
return indexOfExtension ( fileName ) == NOT_FOUND ; MST[rv.CRCR5Mutator]MSP[S] } final String fileExt = getExtension ( fileName ) ; for ( final String extension : extensions ) { if ( fileExt . equals ( extension ) ) { return true ; } } return false ; }
if ( octet . length () == 0 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] emptyOctets ++ ; if ( emptyOctets > 1 ) { return false ; } } else { emptyOctets = 0 ; if ( index == octets . length - 1 && octet . contains ( lr_12 ) ) {
if ( array [ i ] == separator && array [ i - 1 ] == '.' && array [ i - 2 ] == '.' && MST[NegateConditionalsMutator]MSP[N] ( i == prefix + 2 || array [ i - 3 ] == separator ) ) {
octetInt = Integer . parseInt ( octet , BASE_16 ) ; } catch ( final NumberFormatException e ) { return false ; } if ( octetInt < 0 || octetInt > MAX_UNSIGNED_SHORT ) { MST[rv.CRCR1Mutator]MSP[N] return false ; } } validOctets ++ ; }
if ( i == prefix + 2 ) { return null ; } if ( i == size - 1 ) { lastIsDirectory = true ; } int j ; for ( j = i - 4 ; j >= prefix ; j -- ) { MST[rv.ROR3Mutator]MSP[N]
final int prefix = getPrefixLength ( fileName ) ; if ( prefix < 0 ) { return null ; } if ( prefix >= fileName . length () ) { if ( includeSeparator ) { MST[rv.ROR4Mutator]MSP[S] return getPrefix ( fileName ) ; } return fileName ; }
return fileName . substring ( index + 1 ) ; MST[rv.AOR3Mutator]MSP[N] } private static void failIfNullBytePresent ( final String path ) { final int len = path . length () ; for ( int i = 0 ; i < len ; i ++ ) {
static boolean isSystemWindows () { return SYSTEM_SEPARATOR == WINDOWS_SEPARATOR ; } private static boolean isSeparator ( final char ch ) { return ch == UNIX_SEPARATOR || ch == WINDOWS_SEPARATOR ; MST[rv.CRCR4Mutator]MSP[N] } public static String normalize ( final String fileName ) {
list . add ( lr_6 ) ; } else if ( prevChar != '*' ) { MST[rv.CRCR4Mutator]MSP[S] list . add ( lr_7 ) ; } } else { buffer . append ( ch ) ; } prevChar = ch ; } if ( buffer . length () != 0 ) {
int size = fileName . length () ; if ( size == 0 ) { MST[rv.UOI2Mutator]MSP[N] return fileName ; } final int prefix = getPrefixLength ( fileName ) ; if ( prefix < 0 ) { return null ; }
if ( prefix > 0 ) { MST[rv.ABSMutator]MSP[N] return normalize ( fullFileNameToAdd ) ; } if ( basePath == null ) { return null ; } final int len = basePath . length () ; if ( len == 0 ) { return normalize ( fullFileNameToAdd ) ; }
public static String normalizeNoEndSeparator ( final String fileName ) { return doNormalize ( fileName , SYSTEM_SEPARATOR , false ) ; } public static String normalizeNoEndSeparator ( final String fileName , final boolean unixSeparator ) { final char separator = unixSeparator ? UNIX_SEPARATOR : WINDOWS_SEPARATOR ; MST[rv.ABSMutator]MSP[N]
if ( size <= prefix ) { MST[rv.UOI4Mutator]MSP[N] return new String ( array , 0 , size ) ; } if ( lastIsDirectory && keepSeparator ) { return new String ( array , 0 , size ) ; }
if ( len == 0 ) { return 0 ; } char ch0 = fileName . charAt ( 0 ) ; if ( ch0 == ':' ) { return NOT_FOUND ; MST[rv.CRCR1Mutator]MSP[N] } if ( len == 1 ) { if ( ch0 == '~' ) { return 2 ; }
} else if ( isSeparator ( ch0 ) && isSeparator ( ch1 ) ) { MST[rv.ABSMutator]MSP[N] int posUnix = fileName . indexOf ( UNIX_SEPARATOR , 2 ) ; int posWin = fileName . indexOf ( WINDOWS_SEPARATOR , 2 ) ;
if ( len == 2 || isSeparator ( fileName . charAt ( 2 ) ) == false ) { return 2 ; } return 3 ; } else if ( ch0 == UNIX_SEPARATOR ) { MST[rv.ROR3Mutator]MSP[S] return 1 ; } return NOT_FOUND ;
textIdx += wcs [ wcsIdx ] . length () ; anyChars = false ; } wcsIdx ++ ; } if ( wcsIdx == wcs . length && textIdx == fileName . length () ) { return true ; } } while ( backtrack . size () > 0 ); MST[NonVoidMethodCallMutator]MSP[N]
final char [] array = text . toCharArray () ; final ArrayList < String > list = new ArrayList <> () ; MST[ConstructorCallMutator]MSP[N] final StringBuilder buffer = new StringBuilder () ; char prevChar = 0 ; for ( final char ch : array ) {
if ( array [ i ] == separator && array [ i - 1 ] == separator ) { System . arraycopy ( array , i , array , i - 1 , size - i ) ; MST[rv.AOR1Mutator]MSP[N] size -- ; i -- ; } }
return fileName . substring ( index + 1 ) ; MST[rv.AOR4Mutator]MSP[N] } private static int getAdsCriticalOffset ( final String fileName ) { final int offset1 = fileName . lastIndexOf ( SYSTEM_SEPARATOR ) ; final int offset2 = fileName . lastIndexOf ( OTHER_SEPARATOR ) ;
final char [] array = new char [ size + 2 ] ; MST[rv.UOI4Mutator]MSP[N] fileName . getChars ( 0 , fileName . length () , array , 0 ) ; final char otherSeparator = separator == SYSTEM_SEPARATOR ? OTHER_SEPARATOR : SYSTEM_SEPARATOR ;
octetInt = Integer . parseInt ( octet , BASE_16 ) ; } catch ( final NumberFormatException e ) { return false ; } if ( octetInt < 0 || octetInt > MAX_UNSIGNED_SHORT ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] return false ; } } validOctets ++ ; }
if ( validOctets > IPV6_MAX_HEX_GROUPS || ( validOctets < IPV6_MAX_HEX_GROUPS && ! containsCompressedZeroes ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] return false ; } return true ; } private static boolean isRFC3986HostName ( final String name ) { final String [] parts = name . split ( lr_13 , - 1 ) ;
textIdx += wcs [ wcsIdx ] . length () ; anyChars = false ; } wcsIdx ++ ; MST[IncrementsMutator]MSP[N] } if ( wcsIdx == wcs . length && textIdx == fileName . length () ) { return true ; } } while ( backtrack . size () > 0 );
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2 ) { return NOT_FOUND ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
if ( path . charAt ( i ) == 0 ) { MST[rv.ROR3Mutator]MSP[S] throw new IllegalArgumentException ( lr_3 + lr_4 ) ; } } } public static String getBaseName ( final String fileName ) { return removeExtension ( getName ( fileName ) ) ; }
if ( len == 0 ) { return 0 ; } char ch0 = fileName . charAt ( 0 ) ; if ( ch0 == ':' ) { return NOT_FOUND ; } if ( len == 1 ) { MST[rv.CRCR3Mutator]MSP[N] if ( ch0 == '~' ) { return 2 ; }
( i == prefix + 1 || array [ i - 2 ] == separator ) ) { if ( i == size - 1 ) { MST[rv.AOD1Mutator]MSP[N] lastIsDirectory = true ; }
return indexOfExtension ( fileName ) == NOT_FOUND ; } final String fileExt = getExtension ( fileName ) ; for ( final String extension : extensions ) { if ( fileExt . equals ( extension ) ) { MST[rv.ROR2Mutator]MSP[N] return true ; } } return false ; }
return false ; } static String [] splitOnTokens ( final String text ) { if ( text . indexOf ( '?' ) == NOT_FOUND && text . indexOf ( '*' ) == NOT_FOUND ) { MST[rv.CRCR3Mutator]MSP[N] return new String [] { text } ; }
if ( ch == '?' || ch == '*' ) { MST[rv.CRCR2Mutator]MSP[N] if ( buffer . length () != 0 ) { list . add ( buffer . toString () ) ; buffer . setLength ( 0 ) ; } if ( ch == '?' ) {
return fileName . substring ( index + 1 ) ; } private static void failIfNullBytePresent ( final String path ) { final int len = path . length () ; for ( int i = 0 ; i < len ; i ++ ) { MST[rv.ROR1Mutator]MSP[N]
if ( extension == null || extension . isEmpty () ) { return indexOfExtension ( fileName ) == NOT_FOUND ; MST[ReturnValsMutator]MSP[N] } final String fileExt = getExtension ( fileName ) ; return fileExt . equals ( extension ) ; }
if ( path == null || path . indexOf ( WINDOWS_SEPARATOR ) == NOT_FOUND ) { MST[rv.ROR3Mutator]MSP[N] return path ; } return path . replace ( WINDOWS_SEPARATOR , UNIX_SEPARATOR ) ; } public static String separatorsToWindows ( final String path ) {
if ( validOctets > IPV6_MAX_HEX_GROUPS || ( validOctets < IPV6_MAX_HEX_GROUPS && ! containsCompressedZeroes ) ) { MST[rv.CRCR5Mutator]MSP[N] return false ; } return true ; } private static boolean isRFC3986HostName ( final String name ) { final String [] parts = name . split ( lr_13 , - 1 ) ;
for ( int i = 1 ; i <= 4 ; i ++ ) { MST[rv.CRCR3Mutator]MSP[N] final String ipSegment = m . group ( i ) ; final int iIpSegment = Integer . parseInt ( ipSegment ) ; if ( iIpSegment > IPV4_MAX_OCTET_VALUE ) { return false ; }
int wcsIdx = 0 ; final Stack < int [] > backtrack = new Stack <> () ; do { if ( backtrack . size () > 0 ) { final int [] array = backtrack . pop () ; wcsIdx = array [ 0 ] ; MST[rv.CRCR5Mutator]MSP[N]
final char ch1 = fileName . charAt ( 1 ) ; if ( ch1 == ':' ) { ch0 = Character . toUpperCase ( ch0 ) ; if ( ch0 >= 'A' && ch0 <= 'Z' ) { MST[rv.UOI3Mutator]MSP[N]
if ( array [ i ] == separator && array [ i - 1 ] == separator ) { MST[rv.UOI3Mutator]MSP[S] System . arraycopy ( array , i , array , i - 1 , size - i ) ; size -- ; i -- ; } }
static boolean isSystemWindows () { return SYSTEM_SEPARATOR == WINDOWS_SEPARATOR ; } private static boolean isSeparator ( final char ch ) { return ch == UNIX_SEPARATOR || ch == WINDOWS_SEPARATOR ; MST[rv.CRCR2Mutator]MSP[N] } public static String normalize ( final String fileName ) {
final char [] array = new char [ size + 2 ] ; fileName . getChars ( 0 , fileName . length () , array , 0 ) ; final char otherSeparator = separator == SYSTEM_SEPARATOR ? OTHER_SEPARATOR : SYSTEM_SEPARATOR ; MST[NegateConditionalsMutator]MSP[N]
System . arraycopy ( array , i + 1 , array , i - 1 , size - i ) ; MST[rv.AOR4Mutator]MSP[N] size -= 2 ; i -- ; } } outer: for ( int i = prefix + 2 ; i < size ; i ++ ) {
if ( i == prefix + 2 ) { return null ; } if ( i == size - 1 ) { lastIsDirectory = true ; } int j ; for ( j = i - 4 ; j >= prefix ; j -- ) { MST[rv.ABSMutator]MSP[N]
String fileName1 , String fileName2 , final boolean normalized , IOCase caseSensitivity ) { if ( fileName1 == null || fileName2 == null ) { return fileName1 == null && fileName2 == null ; } if ( normalized ) { fileName1 = normalize ( fileName1 ) ; MST[NonVoidMethodCallMutator]MSP[N]
public static String normalizeNoEndSeparator ( final String fileName ) { return doNormalize ( fileName , SYSTEM_SEPARATOR , false ) ; } public static String normalizeNoEndSeparator ( final String fileName , final boolean unixSeparator ) { final char separator = unixSeparator ? UNIX_SEPARATOR : WINDOWS_SEPARATOR ; MST[rv.ROR3Mutator]MSP[N]
if ( len < 0 ) { return null ; } if ( len > fileName . length () ) { failIfNullBytePresent ( fileName + UNIX_SEPARATOR ) ; return fileName + UNIX_SEPARATOR ; MST[rv.CRCR5Mutator]MSP[N] } final String path = fileName . substring ( 0 , len ) ;
if ( ch == '?' || ch == '*' ) { MST[NegateConditionalsMutator]MSP[N] if ( buffer . length () != 0 ) { list . add ( buffer . toString () ) ; buffer . setLength ( 0 ) ; } if ( ch == '?' ) {
return new String ( array , 0 , size - 1 ) ; } public static String concat ( final String basePath , final String fullFileNameToAdd ) { final int prefix = getPrefixLength ( fullFileNameToAdd ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( prefix < 0 ) { return null ; }
return doNormalize ( fileName , SYSTEM_SEPARATOR , true ) ; } public static String normalize ( final String fileName , final boolean unixSeparator ) { final char separator = unixSeparator ? UNIX_SEPARATOR : WINDOWS_SEPARATOR ; return doNormalize ( fileName , separator , true ) ; MST[rv.CRCR3Mutator]MSP[S] }
} return fileName . substring ( 0 , end ) ; } public static String getName ( final String fileName ) { if ( fileName == null ) { return null ; } failIfNullBytePresent ( fileName ) ; MST[VoidMethodCallMutator]MSP[S] final int index = indexOfLastSeparator ( fileName ) ;
final int prefix = getPrefixLength ( fileName ) ; if ( prefix < 0 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] return null ; } if ( prefix >= fileName . length () ) { if ( includeSeparator ) { return getPrefix ( fileName ) ; } return fileName ; }
public static String normalizeNoEndSeparator ( final String fileName ) { return doNormalize ( fileName , SYSTEM_SEPARATOR , false ) ; } public static String normalizeNoEndSeparator ( final String fileName , final boolean unixSeparator ) { final char separator = unixSeparator ? UNIX_SEPARATOR : WINDOWS_SEPARATOR ; MST[rv.CRCR6Mutator]MSP[N]
textIdx += wcs [ wcsIdx ] . length () ; MST[rv.AOR3Mutator]MSP[N] anyChars = false ; } wcsIdx ++ ; } if ( wcsIdx == wcs . length && textIdx == fileName . length () ) { return true ; } } while ( backtrack . size () > 0 );
for ( int i = 0 ; i < parts . length ; i ++ ) { MST[rv.ROR1Mutator]MSP[N] if ( parts [ i ] . length () == 0 ) { return i == parts . length - 1 ; }
public static String normalizeNoEndSeparator ( final String fileName ) { return doNormalize ( fileName , SYSTEM_SEPARATOR , false ) ; } public static String normalizeNoEndSeparator ( final String fileName , final boolean unixSeparator ) { final char separator = unixSeparator ? UNIX_SEPARATOR : WINDOWS_SEPARATOR ; MST[rv.CRCR3Mutator]MSP[S]
System . arraycopy ( array , i + 1 , array , i - 1 , size - i ) ; MST[rv.UOI2Mutator]MSP[N] size -= 2 ; i -- ; } } outer: for ( int i = prefix + 2 ; i < size ; i ++ ) {
if ( len == 2 || isSeparator ( fileName . charAt ( 2 ) ) == false ) { MST[rv.CRCR5Mutator]MSP[N] return 2 ; } return 3 ; } else if ( ch0 == UNIX_SEPARATOR ) { return 1 ; } return NOT_FOUND ;
if ( array [ i ] == separator && array [ i - 1 ] == '.' && array [ i - 2 ] == '.' && MST[rv.CRCR3Mutator]MSP[N] ( i == prefix + 2 || array [ i - 3 ] == separator ) ) {
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND ) { return len + 1 ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ; MST[rv.ROR2Mutator]MSP[N] return Math . min ( posUnix , posWin ) + 1 ; }
if ( path == null || path . indexOf ( WINDOWS_SEPARATOR ) == NOT_FOUND ) { return path ; } return path . replace ( WINDOWS_SEPARATOR , UNIX_SEPARATOR ) ; MST[NonVoidMethodCallMutator]MSP[N] } public static String separatorsToWindows ( final String path ) {
return false ; } static String [] splitOnTokens ( final String text ) { if ( text . indexOf ( '?' ) == NOT_FOUND && text . indexOf ( '*' ) == NOT_FOUND ) { MST[rv.CRCR6Mutator]MSP[N] return new String [] { text } ; }
for ( int i = prefix + 1 ; i < size ; i ++ ) { if ( array [ i ] == separator && array [ i - 1 ] == '.' && MST[rv.ABSMutator]MSP[N]
final int index = indexOfLastSeparator ( fileName ) ; if ( index < 0 ) { return fileName . substring ( 0 , prefix ) ; } int end = index + ( includeSeparator ? 1 : 0 ) ; MST[NegateConditionalsMutator]MSP[N] if ( end == 0 ) { end ++ ;
return false ; } static String [] splitOnTokens ( final String text ) { if ( text . indexOf ( '?' ) == NOT_FOUND && text . indexOf ( '*' ) == NOT_FOUND ) { MST[ArgumentPropagationMutator]MSP[N] return new String [] { text } ; }
if ( size <= prefix ) { return new String ( array , 0 , size ) ; } if ( lastIsDirectory && keepSeparator ) { MST[rv.ROR5Mutator]MSP[N] return new String ( array , 0 , size ) ; }
if ( array [ i ] == separator && array [ i - 1 ] == '.' && array [ i - 2 ] == '.' && MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] ( i == prefix + 2 || array [ i - 3 ] == separator ) ) {
if ( ipSegment . length () > 1 && ipSegment . startsWith ( lr_8 ) ) { return false ; } } return true ; MST[rv.CRCR4Mutator]MSP[N] } private static boolean isIPv6Address ( final String inet6Address ) { final boolean containsCompressedZeroes = inet6Address . contains ( lr_9 ) ;
if ( validOctets > IPV6_MAX_HEX_GROUPS || ( validOctets < IPV6_MAX_HEX_GROUPS && ! containsCompressedZeroes ) ) { MST[rv.CRCR3Mutator]MSP[S] return false ; } return true ; } private static boolean isRFC3986HostName ( final String name ) { final String [] parts = name . split ( lr_13 , - 1 ) ;
if ( len == 0 ) { return 0 ; } char ch0 = fileName . charAt ( 0 ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( ch0 == ':' ) { return NOT_FOUND ; } if ( len == 1 ) { if ( ch0 == '~' ) { return 2 ; }
if ( index == NOT_FOUND ) { MST[rv.ROR1Mutator]MSP[N] return fileName ; } return fileName . substring ( 0 , index ) ; } public static boolean equals ( final String fileName1 , final String fileName2 ) { return equals ( fileName1 , fileName2 , false , IOCase . SENSITIVE ) ;
if ( extension == null || extension . isEmpty () ) { return indexOfExtension ( fileName ) == NOT_FOUND ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } final String fileExt = getExtension ( fileName ) ; return fileExt . equals ( extension ) ; }
if ( array [ size - 1 ] != separator ) { MST[rv.CRCR3Mutator]MSP[N] array [ size ++ ] = separator ; lastIsDirectory = false ; } for ( int i = prefix + 1 ; i < size ; i ++ ) {
if ( octets . length > IPV6_MAX_HEX_GROUPS ) { return false ; MST[rv.CRCR5Mutator]MSP[S] } int validOctets = 0 ; int emptyOctets = 0 ; for ( int index = 0 ; index < octets . length ; index ++ ) { final String octet = octets [ index ] ;
if ( array [ j ] == separator ) { MST[rv.UOI3Mutator]MSP[N] System . arraycopy ( array , i + 1 , array , j + 1 , size - i ) ; size -= i - j ; i = j + 1 ; continue outer; } }
return null ; } return isSystemWindows () ? separatorsToWindows ( path ) : separatorsToUnix ( path ) ; MST[NonVoidMethodCallMutator]MSP[N] } public static int getPrefixLength ( final String fileName ) { if ( fileName == null ) { return NOT_FOUND ; } final int len = fileName . length () ;
if ( validOctets > IPV6_MAX_HEX_GROUPS || ( validOctets < IPV6_MAX_HEX_GROUPS && ! containsCompressedZeroes ) ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[S] return false ; } return true ; } private static boolean isRFC3986HostName ( final String name ) { final String [] parts = name . split ( lr_13 , - 1 ) ;
System . arraycopy ( array , i + 1 , array , prefix , size - i ) ; size -= i + 1 - prefix ; MST[rv.ABSMutator]MSP[N] i = prefix + 1 ; } } if ( size <= 0 ) { return EMPTY_STRING ; }
final int lastSeparator = indexOfLastSeparator ( fileName ) ; return lastSeparator > extensionPos ? NOT_FOUND : extensionPos ; MST[rv.UOI1Mutator]MSP[N] } public static String getPrefix ( final String fileName ) { if ( fileName == null ) { return null ; } final int len = getPrefixLength ( fileName ) ;
static boolean isSystemWindows () { return SYSTEM_SEPARATOR == WINDOWS_SEPARATOR ; MST[rv.CRCR1Mutator]MSP[N] } private static boolean isSeparator ( final char ch ) { return ch == UNIX_SEPARATOR || ch == WINDOWS_SEPARATOR ; } public static String normalize ( final String fileName ) {
final int pos = Math . min ( posUnix , posWin ) + 1 ; MST[rv.UOI2Mutator]MSP[N] final String hostnamePart = fileName . substring ( 2 , pos - 1 ) ; return isValidHostName ( hostnamePart ) ? pos : NOT_FOUND ; } else {
if ( array [ j ] == separator ) { MST[rv.ROR4Mutator]MSP[N] System . arraycopy ( array , i + 1 , array , j + 1 , size - i ) ; size -= i - j ; i = j + 1 ; continue outer; } }
return new String ( array , 0 , size - 1 ) ; } public static String concat ( final String basePath , final String fullFileNameToAdd ) { final int prefix = getPrefixLength ( fullFileNameToAdd ) ; if ( prefix < 0 ) { MST[rv.ROR3Mutator]MSP[N] return null ; }
return isSeparator ( ch0 ) ? 1 : 0 ; MST[rv.ROR3Mutator]MSP[N] } if ( ch0 == '~' ) { int posUnix = fileName . indexOf ( UNIX_SEPARATOR , 1 ) ; int posWin = fileName . indexOf ( WINDOWS_SEPARATOR , 1 ) ;
final int pos = Math . min ( posUnix , posWin ) + 1 ; MST[rv.CRCR3Mutator]MSP[N] final String hostnamePart = fileName . substring ( 2 , pos - 1 ) ; return isValidHostName ( hostnamePart ) ? pos : NOT_FOUND ; } else {
if ( octet . length () == 0 ) { emptyOctets ++ ; if ( emptyOctets > 1 ) { MST[rv.CRCR2Mutator]MSP[N] return false ; } } else { emptyOctets = 0 ; if ( index == octets . length - 1 && octet . contains ( lr_12 ) ) {
return caseSensitivity . checkEquals ( fileName1 , fileName2 ) ; } public static boolean isExtension ( final String fileName , final String extension ) { if ( fileName == null ) { return false ; MST[rv.CRCR3Mutator]MSP[S] } failIfNullBytePresent ( fileName ) ;
textIdx = caseSensitivity . checkIndexOf ( fileName , textIdx , wcs [ wcsIdx ] ) ; if ( textIdx == NOT_FOUND ) { MST[rv.CRCR1Mutator]MSP[S] break; } final int repeat = caseSensitivity . checkIndexOf ( fileName , textIdx + 1 , wcs [ wcsIdx ] ) ;
if ( len < 0 ) { MST[rv.ROR1Mutator]MSP[N] return null ; } if ( len > fileName . length () ) { failIfNullBytePresent ( fileName + UNIX_SEPARATOR ) ; return fileName + UNIX_SEPARATOR ; } final String path = fileName . substring ( 0 , len ) ;
} else if ( isSeparator ( ch0 ) && isSeparator ( ch1 ) ) { int posUnix = fileName . indexOf ( UNIX_SEPARATOR , 2 ) ; int posWin = fileName . indexOf ( WINDOWS_SEPARATOR , 2 ) ; MST[rv.CRCR1Mutator]MSP[N]
for ( int i = 0 ; i < array . length ; i ++ ) { if ( array [ i ] == otherSeparator ) { array [ i ] = separator ; MST[rv.UOI1Mutator]MSP[N] } } boolean lastIsDirectory = true ;
if ( fileName == null || wildcardMatcher == null ) { return false ; } if ( caseSensitivity == null ) { caseSensitivity = IOCase . SENSITIVE ; } final String [] wcs = splitOnTokens ( wildcardMatcher ) ; boolean anyChars = false ; MST[rv.CRCR3Mutator]MSP[S] int textIdx = 0 ;
String fileName1 , String fileName2 , final boolean normalized , IOCase caseSensitivity ) { if ( fileName1 == null || fileName2 == null ) { return fileName1 == null && fileName2 == null ; } if ( normalized ) { MST[rv.UOI3Mutator]MSP[S] fileName1 = normalize ( fileName1 ) ;
String fileName1 , String fileName2 , final boolean normalized , IOCase caseSensitivity ) { if ( fileName1 == null || fileName2 == null ) { return fileName1 == null && fileName2 == null ; } if ( normalized ) { MST[rv.ROR4Mutator]MSP[N] fileName1 = normalize ( fileName1 ) ;
if ( repeat >= 0 ) { backtrack . push ( new int [] { wcsIdx , repeat } ) ; MST[rv.ABSMutator]MSP[S] } } else { if ( ! caseSensitivity . checkRegionMatches ( fileName , textIdx , wcs [ wcsIdx ] ) ) { break; } }
if ( array [ j ] == separator ) { System . arraycopy ( array , i + 1 , array , j + 1 , size - i ) ; size -= i - j ; MST[rv.ABSMutator]MSP[N] i = j + 1 ; continue outer; } }
return doNormalize ( fileName , SYSTEM_SEPARATOR , true ) ; } public static String normalize ( final String fileName , final boolean unixSeparator ) { final char separator = unixSeparator ? UNIX_SEPARATOR : WINDOWS_SEPARATOR ; return doNormalize ( fileName , separator , true ) ; MST[ReturnValsMutator]MSP[N] }
if ( size <= prefix ) { return new String ( array , 0 , size ) ; } if ( lastIsDirectory && keepSeparator ) { MST[rv.UOI4Mutator]MSP[N] return new String ( array , 0 , size ) ; }
return new String ( array , 0 , size - 1 ) ; MST[rv.AOR3Mutator]MSP[N] } public static String concat ( final String basePath , final String fullFileNameToAdd ) { final int prefix = getPrefixLength ( fullFileNameToAdd ) ; if ( prefix < 0 ) { return null ; }
final int index = indexOfLastSeparator ( fileName ) ; if ( index < 0 ) { return fileName . substring ( 0 , prefix ) ; MST[rv.CRCR6Mutator]MSP[N] } int end = index + ( includeSeparator ? 1 : 0 ) ; if ( end == 0 ) { end ++ ;
if ( ! REG_NAME_PART_PATTERN . matcher ( parts [ i ] ) . matches () ) { MST[rv.UOI3Mutator]MSP[N] return false ; } } return true ; }
if ( extension == null || extension . isEmpty () ) { return indexOfExtension ( fileName ) == NOT_FOUND ; } final String fileExt = getExtension ( fileName ) ; return fileExt . equals ( extension ) ; MST[BooleanTrueReturnValsMutator]MSP[N] }
if ( path == null || path . indexOf ( UNIX_SEPARATOR ) == NOT_FOUND ) { return path ; } return path . replace ( UNIX_SEPARATOR , WINDOWS_SEPARATOR ) ; } public static String separatorsToSystem ( final String path ) { if ( path == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
if ( validOctets > IPV6_MAX_HEX_GROUPS || ( validOctets < IPV6_MAX_HEX_GROUPS && ! containsCompressedZeroes ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return false ; } return true ; } private static boolean isRFC3986HostName ( final String name ) { final String [] parts = name . split ( lr_13 , - 1 ) ;
octetInt = Integer . parseInt ( octet , BASE_16 ) ; MST[ArgumentPropagationMutator]MSP[S] } catch ( final NumberFormatException e ) { return false ; } if ( octetInt < 0 || octetInt > MAX_UNSIGNED_SHORT ) { return false ; } } validOctets ++ ; }
final int pos = Math . min ( posUnix , posWin ) + 1 ; final String hostnamePart = fileName . substring ( 2 , pos - 1 ) ; return isValidHostName ( hostnamePart ) ? pos : NOT_FOUND ; MST[rv.UOI1Mutator]MSP[N] } else {
list . add ( buffer . toString () ) ; } return list . toArray ( new String [ list . size () ] ) ; MST[ArgumentPropagationMutator]MSP[N] } private static boolean isValidHostName ( final String name ) { return isIPv6Address ( name ) || isRFC3986HostName ( name ) ; }
for ( int i = prefix + 1 ; i < size ; i ++ ) { if ( array [ i ] == separator && array [ i - 1 ] == '.' && MST[rv.UOI3Mutator]MSP[N]
return isSeparator ( ch0 ) ? 1 : 0 ; } if ( ch0 == '~' ) { int posUnix = fileName . indexOf ( UNIX_SEPARATOR , 1 ) ; int posWin = fileName . indexOf ( WINDOWS_SEPARATOR , 1 ) ; MST[ArgumentPropagationMutator]MSP[N]
for ( int i = prefix + 1 ; i < size ; i ++ ) { if ( array [ i ] == separator && array [ i - 1 ] == '.' && MST[rv.ROR4Mutator]MSP[N]
if ( ! isIPv4Address ( octet ) ) { MST[NonVoidMethodCallMutator]MSP[S] return false ; } validOctets += 2 ; continue; } if ( octet . length () > IPV6_MAX_HEX_DIGITS_PER_GROUP ) { return false ; } int octetInt = 0 ; try {
final char ch = basePath . charAt ( len - 1 ) ; if ( isSeparator ( ch ) ) { return normalize ( basePath + fullFileNameToAdd ) ; } return normalize ( basePath + '/' + fullFileNameToAdd ) ; MST[ArgumentPropagationMutator]MSP[N] }
return isSeparator ( ch0 ) ? 1 : 0 ; } if ( ch0 == '~' ) { int posUnix = fileName . indexOf ( UNIX_SEPARATOR , 1 ) ; MST[rv.CRCR3Mutator]MSP[N] int posWin = fileName . indexOf ( WINDOWS_SEPARATOR , 1 ) ;
System . arraycopy ( array , i + 1 , array , i - 1 , size - i ) ; MST[rv.CRCR6Mutator]MSP[N] size -= 2 ; i -- ; } } outer: for ( int i = prefix + 2 ; i < size ; i ++ ) {
|| ( inet6Address . endsWith ( lr_10 ) && ! inet6Address . endsWith ( lr_9 ) ) ) { return false ; } String [] octets = inet6Address . split ( lr_10 ) ; if ( containsCompressedZeroes ) { MST[rv.ROR2Mutator]MSP[N]
for ( int i = 1 ; i <= 4 ; i ++ ) { final String ipSegment = m . group ( i ) ; MST[NonVoidMethodCallMutator]MSP[N] final int iIpSegment = Integer . parseInt ( ipSegment ) ; if ( iIpSegment > IPV4_MAX_OCTET_VALUE ) { return false ; }
if ( octet . length () == 0 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] emptyOctets ++ ; if ( emptyOctets > 1 ) { return false ; } } else { emptyOctets = 0 ; if ( index == octets . length - 1 && octet . contains ( lr_12 ) ) {
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND ) { return len + 1 ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ; return Math . min ( posUnix , posWin ) + 1 ; MST[rv.AOR3Mutator]MSP[N] }
final char [] array = new char [ size + 2 ] ; fileName . getChars ( 0 , fileName . length () , array , 0 ) ; MST[InlineConstantMutator]MSP[N] final char otherSeparator = separator == SYSTEM_SEPARATOR ? OTHER_SEPARATOR : SYSTEM_SEPARATOR ;
list . add ( buffer . toString () ) ; } return list . toArray ( new String [ list . size () ] ) ; MST[ReturnValsMutator]MSP[N] } private static boolean isValidHostName ( final String name ) { return isIPv6Address ( name ) || isRFC3986HostName ( name ) ; }
return isSeparator ( ch0 ) ? 1 : 0 ; } if ( ch0 == '~' ) { int posUnix = fileName . indexOf ( UNIX_SEPARATOR , 1 ) ; int posWin = fileName . indexOf ( WINDOWS_SEPARATOR , 1 ) ; MST[rv.CRCR4Mutator]MSP[N]
if ( fileName == null || wildcardMatcher == null ) { return false ; } if ( caseSensitivity == null ) { caseSensitivity = IOCase . SENSITIVE ; } final String [] wcs = splitOnTokens ( wildcardMatcher ) ; boolean anyChars = false ; int textIdx = 0 ; MST[rv.CRCR6Mutator]MSP[N]
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND ) { return len + 1 ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ; return Math . min ( posUnix , posWin ) + 1 ; MST[rv.UOI4Mutator]MSP[N] }
for ( int i = 1 ; i <= 4 ; i ++ ) { MST[rv.UOI4Mutator]MSP[N] final String ipSegment = m . group ( i ) ; final int iIpSegment = Integer . parseInt ( ipSegment ) ; if ( iIpSegment > IPV4_MAX_OCTET_VALUE ) { return false ; }
if ( prefix > 0 ) { MST[rv.UOI2Mutator]MSP[N] return normalize ( fullFileNameToAdd ) ; } if ( basePath == null ) { return null ; } final int len = basePath . length () ; if ( len == 0 ) { return normalize ( fullFileNameToAdd ) ; }
return indexOfExtension ( fileName ) == NOT_FOUND ; MST[rv.ROR2Mutator]MSP[N] } final String fileExt = getExtension ( fileName ) ; for ( final String extension : extensions ) { if ( fileExt . equals ( extension ) ) { return true ; } } return false ; }
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2 ) { MST[rv.CRCR2Mutator]MSP[N] return NOT_FOUND ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ;
if ( repeat >= 0 ) { backtrack . push ( new int [] { wcsIdx , repeat } ) ; } } else { if ( ! caseSensitivity . checkRegionMatches ( fileName , textIdx , wcs [ wcsIdx ] ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] break; } }
return indexOfExtension ( fileName ) == NOT_FOUND ; } final String fileExt = getExtension ( fileName ) ; for ( final String extension : extensions ) { if ( fileExt . equals ( extension ) ) { return true ; } } return false ; MST[rv.CRCR6Mutator]MSP[N] }
if ( len == 2 || isSeparator ( fileName . charAt ( 2 ) ) == false ) { MST[rv.ROR2Mutator]MSP[N] return 2 ; } return 3 ; } else if ( ch0 == UNIX_SEPARATOR ) { return 1 ; } return NOT_FOUND ;
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2 ) { MST[rv.ROR1Mutator]MSP[N] return NOT_FOUND ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ;
final char ch = basePath . charAt ( len - 1 ) ; if ( isSeparator ( ch ) ) { return normalize ( basePath + fullFileNameToAdd ) ; } return normalize ( basePath + '/' + fullFileNameToAdd ) ; MST[NonVoidMethodCallMutator]MSP[N] }
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2 ) { return NOT_FOUND ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; MST[rv.UOI3Mutator]MSP[N] posWin = posWin == NOT_FOUND ? posUnix : posWin ;
return null ; } return isSystemWindows () ? separatorsToWindows ( path ) : separatorsToUnix ( path ) ; } public static int getPrefixLength ( final String fileName ) { if ( fileName == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return NOT_FOUND ; } final int len = fileName . length () ;
final int pos = Math . min ( posUnix , posWin ) + 1 ; MST[rv.AOR1Mutator]MSP[N] final String hostnamePart = fileName . substring ( 2 , pos - 1 ) ; return isValidHostName ( hostnamePart ) ? pos : NOT_FOUND ; } else {
final int index = indexOfLastSeparator ( fileName ) ; final int endIndex = index + separatorAdd ; if ( prefix >= fileName . length () || index < 0 || prefix >= endIndex ) { MST[rv.ROR3Mutator]MSP[N] return EMPTY_STRING ; }
if ( len == 2 || isSeparator ( fileName . charAt ( 2 ) ) == false ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return 2 ; } return 3 ; } else if ( ch0 == UNIX_SEPARATOR ) { return 1 ; } return NOT_FOUND ;
return new String ( array , 0 , size - 1 ) ; MST[rv.CRCR5Mutator]MSP[N] } public static String concat ( final String basePath , final String fullFileNameToAdd ) { final int prefix = getPrefixLength ( fullFileNameToAdd ) ; if ( prefix < 0 ) { return null ; }
if ( isSystemWindows () ) { final int offset = fileName . indexOf ( ':' , getAdsCriticalOffset ( fileName ) ) ; if ( offset != - 1 ) { throw new IllegalArgumentException ( lr_2 ) ; } } final int extensionPos = fileName . lastIndexOf ( EXTENSION_SEPARATOR ) ; MST[rv.CRCR5Mutator]MSP[N]
public static boolean isExtension ( final String fileName , final Collection < String > extensions ) { if ( fileName == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] return false ; } failIfNullBytePresent ( fileName ) ; if ( extensions == null || extensions . isEmpty () ) {
public static String getFullPathNoEndSeparator ( final String fileName ) { return doGetFullPath ( fileName , false ) ; } private static String doGetFullPath ( final String fileName , final boolean includeSeparator ) { if ( fileName == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return null ; }
if ( octet . length () == 0 ) { emptyOctets ++ ; if ( emptyOctets > 1 ) { return false ; } } else { emptyOctets = 0 ; if ( index == octets . length - 1 && octet . contains ( lr_12 ) ) { MST[rv.ROR4Mutator]MSP[S]
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2 ) { MST[NegateConditionalsMutator]MSP[N] return NOT_FOUND ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ;
if ( i == prefix + 2 ) { return null ; } if ( i == size - 1 ) { MST[rv.ROR2Mutator]MSP[S] lastIsDirectory = true ; } int j ; for ( j = i - 4 ; j >= prefix ; j -- ) {
final int pos = Math . min ( posUnix , posWin ) + 1 ; final String hostnamePart = fileName . substring ( 2 , pos - 1 ) ; return isValidHostName ( hostnamePart ) ? pos : NOT_FOUND ; MST[rv.ROR3Mutator]MSP[N] } else {
return new String ( array , 0 , size - 1 ) ; MST[rv.AOD1Mutator]MSP[N] } public static String concat ( final String basePath , final String fullFileNameToAdd ) { final int prefix = getPrefixLength ( fullFileNameToAdd ) ; if ( prefix < 0 ) { return null ; }
System . arraycopy ( array , i + 1 , array , i - 1 , size - i ) ; size -= 2 ; i -- ; } } outer: for ( int i = prefix + 2 ; i < size ; i ++ ) { MST[rv.AOR1Mutator]MSP[N]
if ( ch == '?' || ch == '*' ) { MST[rv.ROR5Mutator]MSP[N] if ( buffer . length () != 0 ) { list . add ( buffer . toString () ) ; buffer . setLength ( 0 ) ; } if ( ch == '?' ) {
final int pos = Math . min ( posUnix , posWin ) + 1 ; final String hostnamePart = fileName . substring ( 2 , pos - 1 ) ; MST[rv.ABSMutator]MSP[N] return isValidHostName ( hostnamePart ) ? pos : NOT_FOUND ; } else {
final int prefix = getPrefixLength ( fileName ) ; if ( prefix < 0 ) { return null ; } if ( prefix >= fileName . length () ) { if ( includeSeparator ) { MST[rv.UOI3Mutator]MSP[S] return getPrefix ( fileName ) ; } return fileName ; }
for ( int i = prefix + 1 ; i < size ; i ++ ) { MST[rv.ROR3Mutator]MSP[S] if ( array [ i ] == separator && array [ i - 1 ] == '.' &&
return isSeparator ( ch0 ) ? 1 : 0 ; } if ( ch0 == '~' ) { int posUnix = fileName . indexOf ( UNIX_SEPARATOR , 1 ) ; MST[NonVoidMethodCallMutator]MSP[N] int posWin = fileName . indexOf ( WINDOWS_SEPARATOR , 1 ) ;
if ( len == 2 || isSeparator ( fileName . charAt ( 2 ) ) == false ) { return 2 ; } return 3 ; } else if ( ch0 == UNIX_SEPARATOR ) { return 1 ; } return NOT_FOUND ; MST[rv.CRCR4Mutator]MSP[N]
failIfNullBytePresent ( path ) ; return path ; MST[EmptyObjectReturnValsMutator]MSP[N] } public static String getPath ( final String fileName ) { return doGetPath ( fileName , 1 ) ; } public static String getPathNoEndSeparator ( final String fileName ) { return doGetPath ( fileName , 0 ) ; }
System . arraycopy ( array , i + 1 , array , prefix , size - i ) ; size -= i + 1 - prefix ; i = prefix + 1 ; MST[rv.UOI1Mutator]MSP[N] } } if ( size <= 0 ) { return EMPTY_STRING ; }
failIfNullBytePresent ( path ) ; MST[VoidMethodCallMutator]MSP[S] return path ; } public static String getPath ( final String fileName ) { return doGetPath ( fileName , 1 ) ; } public static String getPathNoEndSeparator ( final String fileName ) { return doGetPath ( fileName , 0 ) ; }
final int index = indexOfLastSeparator ( fileName ) ; final int endIndex = index + separatorAdd ; MST[rv.ABSMutator]MSP[N] if ( prefix >= fileName . length () || index < 0 || prefix >= endIndex ) { return EMPTY_STRING ; }
final int pos = Math . min ( posUnix , posWin ) + 1 ; final String hostnamePart = fileName . substring ( 2 , pos - 1 ) ; MST[rv.CRCR5Mutator]MSP[N] return isValidHostName ( hostnamePart ) ? pos : NOT_FOUND ; } else {
if ( ch == '?' || ch == '*' ) { if ( buffer . length () != 0 ) { list . add ( buffer . toString () ) ; buffer . setLength ( 0 ) ; } if ( ch == '?' ) { MST[rv.CRCR1Mutator]MSP[N]
return false ; } static String [] splitOnTokens ( final String text ) { if ( text . indexOf ( '?' ) == NOT_FOUND && text . indexOf ( '*' ) == NOT_FOUND ) { MST[rv.ROR3Mutator]MSP[N] return new String [] { text } ; }
if ( validOctets > IPV6_MAX_HEX_GROUPS || ( validOctets < IPV6_MAX_HEX_GROUPS && ! containsCompressedZeroes ) ) { MST[rv.UOI1Mutator]MSP[N] return false ; } return true ; } private static boolean isRFC3986HostName ( final String name ) { final String [] parts = name . split ( lr_13 , - 1 ) ;
if ( size <= prefix ) { return new String ( array , 0 , size ) ; } if ( lastIsDirectory && keepSeparator ) { return new String ( array , 0 , size ) ; MST[rv.CRCR1Mutator]MSP[N] }
fileName2 = normalize ( fileName2 ) ; if ( fileName1 == null || fileName2 == null ) { MST[NegateConditionalsMutator]MSP[N] throw new NullPointerException ( lr_5 ) ; } } if ( caseSensitivity == null ) { caseSensitivity = IOCase . SENSITIVE ; }
textIdx += wcs [ wcsIdx ] . length () ; MST[rv.AOD1Mutator]MSP[N] anyChars = false ; } wcsIdx ++ ; } if ( wcsIdx == wcs . length && textIdx == fileName . length () ) { return true ; } } while ( backtrack . size () > 0 );
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND ) { return len + 1 ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ; return Math . min ( posUnix , posWin ) + 1 ; MST[rv.AOD1Mutator]MSP[N] }
return indexOfExtension ( fileName ) == NOT_FOUND ; } final String fileExt = getExtension ( fileName ) ; for ( final String extension : extensions ) { MST[rv.UOI2Mutator]MSP[S] if ( fileExt . equals ( extension ) ) { return true ; } } return false ; }
System . arraycopy ( array , i + 1 , array , i - 1 , size - i ) ; MST[rv.AOD2Mutator]MSP[N] size -= 2 ; i -- ; } } outer: for ( int i = prefix + 2 ; i < size ; i ++ ) {
if ( ! REG_NAME_PART_PATTERN . matcher ( parts [ i ] ) . matches () ) { return false ; } } return true ; MST[rv.CRCR5Mutator]MSP[N] }
if ( containsCompressedZeroes && ( inet6Address . indexOf ( lr_9 ) != inet6Address . lastIndexOf ( lr_9 ) ) ) { return false ; } if ( ( inet6Address . startsWith ( lr_10 ) && ! inet6Address . startsWith ( lr_9 ) ) MST[rv.ROR4Mutator]MSP[N]
if ( len == 0 ) { return 0 ; } char ch0 = fileName . charAt ( 0 ) ; if ( ch0 == ':' ) { MST[rv.CRCR4Mutator]MSP[N] return NOT_FOUND ; } if ( len == 1 ) { if ( ch0 == '~' ) { return 2 ; }
System . arraycopy ( array , i + 1 , array , prefix , size - i ) ; MST[VoidMethodCallMutator]MSP[N] size -= i + 1 - prefix ; i = prefix + 1 ; } } if ( size <= 0 ) { return EMPTY_STRING ; }
int size = fileName . length () ; if ( size == 0 ) { MST[rv.ROR3Mutator]MSP[S] return fileName ; } final int prefix = getPrefixLength ( fileName ) ; if ( prefix < 0 ) { return null ; }
final int index = indexOfLastSeparator ( fileName ) ; if ( index < 0 ) { return fileName . substring ( 0 , prefix ) ; } int end = index + ( includeSeparator ? 1 : 0 ) ; MST[rv.ROR5Mutator]MSP[N] if ( end == 0 ) { end ++ ;
textIdx = caseSensitivity . checkIndexOf ( fileName , textIdx , wcs [ wcsIdx ] ) ; if ( textIdx == NOT_FOUND ) { break; } final int repeat = caseSensitivity . checkIndexOf ( fileName , textIdx + 1 , wcs [ wcsIdx ] ) ; MST[rv.CRCR5Mutator]MSP[N]
} else if ( isSeparator ( ch0 ) && isSeparator ( ch1 ) ) { MST[rv.UOI4Mutator]MSP[N] int posUnix = fileName . indexOf ( UNIX_SEPARATOR , 2 ) ; int posWin = fileName . indexOf ( WINDOWS_SEPARATOR , 2 ) ;
if ( octet . length () == 0 ) { MST[NonVoidMethodCallMutator]MSP[N] emptyOctets ++ ; if ( emptyOctets > 1 ) { return false ; } } else { emptyOctets = 0 ; if ( index == octets . length - 1 && octet . contains ( lr_12 ) ) {
if ( size <= prefix ) { MST[rv.UOI3Mutator]MSP[N] return new String ( array , 0 , size ) ; } if ( lastIsDirectory && keepSeparator ) { return new String ( array , 0 , size ) ; }
final int prefix = getPrefixLength ( fileName ) ; if ( prefix < 0 ) { return null ; } if ( prefix >= fileName . length () ) { if ( includeSeparator ) { return getPrefix ( fileName ) ; MST[ReturnValsMutator]MSP[N] } return fileName ; }
System . arraycopy ( array , i + 1 , array , i - 1 , size - i ) ; size -= 2 ; i -- ; } } outer: for ( int i = prefix + 2 ; i < size ; i ++ ) { MST[IncrementsMutator]MSP[N]
if ( ! isIPv4Address ( octet ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return false ; } validOctets += 2 ; continue; } if ( octet . length () > IPV6_MAX_HEX_DIGITS_PER_GROUP ) { return false ; } int octetInt = 0 ; try {
final int lastSeparator = indexOfLastSeparator ( fileName ) ; return lastSeparator > extensionPos ? NOT_FOUND : extensionPos ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[S] } public static String getPrefix ( final String fileName ) { if ( fileName == null ) { return null ; } final int len = getPrefixLength ( fileName ) ;
System . arraycopy ( array , i + 1 , array , prefix , size - i ) ; MST[rv.UOI1Mutator]MSP[N] size -= i + 1 - prefix ; i = prefix + 1 ; } } if ( size <= 0 ) { return EMPTY_STRING ; }
final char [] array = new char [ size + 2 ] ; fileName . getChars ( 0 , fileName . length () , array , 0 ) ; final char otherSeparator = separator == SYSTEM_SEPARATOR ? OTHER_SEPARATOR : SYSTEM_SEPARATOR ; MST[rv.ROR5Mutator]MSP[N]
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND ) { return len + 1 ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ; return Math . min ( posUnix , posWin ) + 1 ; MST[rv.CRCR5Mutator]MSP[N] }
return indexOfExtension ( fileName ) == NOT_FOUND ; MST[rv.CRCR2Mutator]MSP[N] } final String fileExt = getExtension ( fileName ) ; for ( final String extension : extensions ) { if ( fileExt . equals ( extension ) ) { return true ; } } return false ; }
System . arraycopy ( array , i + 1 , array , i - 1 , size - i ) ; size -= 2 ; i -- ; MST[IncrementsMutator]MSP[N] } } outer: for ( int i = prefix + 2 ; i < size ; i ++ ) {
if ( path == null || path . indexOf ( UNIX_SEPARATOR ) == NOT_FOUND ) { MST[rv.CRCR6Mutator]MSP[N] return path ; } return path . replace ( UNIX_SEPARATOR , WINDOWS_SEPARATOR ) ; } public static String separatorsToSystem ( final String path ) { if ( path == null ) {
final int index = indexOfLastSeparator ( fileName ) ; if ( index < 0 ) { return fileName . substring ( 0 , prefix ) ; } int end = index + ( includeSeparator ? 1 : 0 ) ; MST[rv.AOD2Mutator]MSP[N] if ( end == 0 ) { end ++ ;
if ( ! REG_NAME_PART_PATTERN . matcher ( parts [ i ] ) . matches () ) { MST[rv.ROR2Mutator]MSP[N] return false ; } } return true ; }
} public static boolean equalsOnSystem ( final String fileName1 , final String fileName2 ) { return equals ( fileName1 , fileName2 , false , IOCase . SYSTEM ) ; MST[ArgumentPropagationMutator]MSP[N] } public static boolean equalsNormalized ( final String fileName1 , final String fileName2 ) {
if ( array [ size - 1 ] != separator ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] array [ size ++ ] = separator ; lastIsDirectory = false ; } for ( int i = prefix + 1 ; i < size ; i ++ ) {
return fileName . substring ( index + 1 ) ; MST[EmptyObjectReturnValsMutator]MSP[N] } private static int getAdsCriticalOffset ( final String fileName ) { final int offset1 = fileName . lastIndexOf ( SYSTEM_SEPARATOR ) ; final int offset2 = fileName . lastIndexOf ( OTHER_SEPARATOR ) ;
System . arraycopy ( array , i + 1 , array , i - 1 , size - i ) ; size -= 2 ; i -- ; } } outer: for ( int i = prefix + 2 ; i < size ; i ++ ) { MST[rv.CRCR3Mutator]MSP[N]
for ( int i = 1 ; i <= 4 ; i ++ ) { final String ipSegment = m . group ( i ) ; final int iIpSegment = Integer . parseInt ( ipSegment ) ; if ( iIpSegment > IPV4_MAX_OCTET_VALUE ) { MST[rv.CRCR6Mutator]MSP[N] return false ; }
System . arraycopy ( array , i + 1 , array , prefix , size - i ) ; MST[MathMutator]MSP[N] size -= i + 1 - prefix ; i = prefix + 1 ; } } if ( size <= 0 ) { return EMPTY_STRING ; }
( i == prefix + 1 || array [ i - 2 ] == separator ) ) { if ( i == size - 1 ) { MST[rv.ROR3Mutator]MSP[N] lastIsDirectory = true ; }
final int lastWindowsPos = fileName . lastIndexOf ( WINDOWS_SEPARATOR ) ; return Math . max ( lastUnixPos , lastWindowsPos ) ; MST[rv.UOI1Mutator]MSP[N] } public static int indexOfExtension ( final String fileName ) throws IllegalArgumentException { if ( fileName == null ) { return NOT_FOUND ; }
if ( ch == '?' || ch == '*' ) { if ( buffer . length () != 0 ) { list . add ( buffer . toString () ) ; buffer . setLength ( 0 ) ; MST[rv.CRCR6Mutator]MSP[N] } if ( ch == '?' ) {
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND ) { return len + 1 ; MST[rv.AOD2Mutator]MSP[N] } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ; return Math . min ( posUnix , posWin ) + 1 ; }
} else if ( inet6Address . startsWith ( lr_9 ) && ! octetList . isEmpty () ) { MST[NonVoidMethodCallMutator]MSP[N] octetList . remove ( 0 ) ; } octets = octetList . toArray ( new String [ octetList . size () ] ) ; }
String fileName1 , String fileName2 , final boolean normalized , IOCase caseSensitivity ) { if ( fileName1 == null || fileName2 == null ) { return fileName1 == null && fileName2 == null ; MST[InlineConstantMutator]MSP[N] } if ( normalized ) { fileName1 = normalize ( fileName1 ) ;
if ( path == null || path . indexOf ( WINDOWS_SEPARATOR ) == NOT_FOUND ) { return path ; } return path . replace ( WINDOWS_SEPARATOR , UNIX_SEPARATOR ) ; MST[rv.CRCR3Mutator]MSP[N] } public static String separatorsToWindows ( final String path ) {
for ( int i = 0 ; i < parts . length ; i ++ ) { if ( parts [ i ] . length () == 0 ) { MST[rv.UOI2Mutator]MSP[N] return i == parts . length - 1 ; }
private static String doGetPath ( final String fileName , final int separatorAdd ) { if ( fileName == null ) { MST[NegateConditionalsMutator]MSP[N] return null ; } final int prefix = getPrefixLength ( fileName ) ; if ( prefix < 0 ) { return null ; }
( i == prefix + 1 || array [ i - 2 ] == separator ) ) { if ( i == size - 1 ) { lastIsDirectory = true ; MST[rv.CRCR2Mutator]MSP[N] }
final int lastSeparator = indexOfLastSeparator ( fileName ) ; return lastSeparator > extensionPos ? NOT_FOUND : extensionPos ; } public static String getPrefix ( final String fileName ) { if ( fileName == null ) { MST[NegateConditionalsMutator]MSP[N] return null ; } final int len = getPrefixLength ( fileName ) ;
if ( prefix > 0 ) { return normalize ( fullFileNameToAdd ) ; } if ( basePath == null ) { return null ; } final int len = basePath . length () ; if ( len == 0 ) { return normalize ( fullFileNameToAdd ) ; MST[NonVoidMethodCallMutator]MSP[N] }
textIdx += wcs [ wcsIdx ] . length () ; anyChars = false ; } wcsIdx ++ ; } if ( wcsIdx == wcs . length && textIdx == fileName . length () ) { MST[rv.ABSMutator]MSP[N] return true ; } } while ( backtrack . size () > 0 );
static boolean isSystemWindows () { return SYSTEM_SEPARATOR == WINDOWS_SEPARATOR ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } private static boolean isSeparator ( final char ch ) { return ch == UNIX_SEPARATOR || ch == WINDOWS_SEPARATOR ; } public static String normalize ( final String fileName ) {
if ( array [ i ] == separator && array [ i - 1 ] == separator ) { System . arraycopy ( array , i , array , i - 1 , size - i ) ; MST[rv.CRCR6Mutator]MSP[N] size -- ; i -- ; } }
textIdx = array [ 1 ] ; anyChars = true ; MST[InlineConstantMutator]MSP[N] } while ( wcsIdx < wcs . length ) { if ( wcs [ wcsIdx ] . equals ( lr_6 ) ) { textIdx ++ ; if ( textIdx > fileName . length () ) { break; }
final int index = indexOfLastSeparator ( fileName ) ; final int endIndex = index + separatorAdd ; if ( prefix >= fileName . length () || index < 0 || prefix >= endIndex ) { MST[rv.ROR2Mutator]MSP[N] return EMPTY_STRING ; }
for ( int i = 0 ; i < array . length ; i ++ ) { MST[ConditionalsBoundaryMutator]MSP[N] if ( array [ i ] == otherSeparator ) { array [ i ] = separator ; } } boolean lastIsDirectory = true ;
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2 ) { MST[rv.UOI1Mutator]MSP[N] return NOT_FOUND ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ;
final char ch1 = fileName . charAt ( 1 ) ; if ( ch1 == ':' ) { ch0 = Character . toUpperCase ( ch0 ) ; if ( ch0 >= 'A' && ch0 <= 'Z' ) { MST[rv.ROR3Mutator]MSP[N]
} return fileName . substring ( 0 , end ) ; } public static String getName ( final String fileName ) { if ( fileName == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return null ; } failIfNullBytePresent ( fileName ) ; final int index = indexOfLastSeparator ( fileName ) ;
if ( i == prefix + 2 ) { MST[rv.CRCR1Mutator]MSP[N] return null ; } if ( i == size - 1 ) { lastIsDirectory = true ; } int j ; for ( j = i - 4 ; j >= prefix ; j -- ) {
if ( array [ j ] == separator ) { System . arraycopy ( array , i + 1 , array , j + 1 , size - i ) ; MST[MathMutator]MSP[N] size -= i - j ; i = j + 1 ; continue outer; } }
for ( int i = prefix + 1 ; i < size ; i ++ ) { MST[rv.CRCR3Mutator]MSP[N] if ( array [ i ] == separator && array [ i - 1 ] == '.' &&
textIdx = array [ 1 ] ; anyChars = true ; } while ( wcsIdx < wcs . length ) { if ( wcs [ wcsIdx ] . equals ( lr_6 ) ) { MST[rv.ROR3Mutator]MSP[N] textIdx ++ ; if ( textIdx > fileName . length () ) { break; }
} else if ( isSeparator ( ch0 ) && isSeparator ( ch1 ) ) { int posUnix = fileName . indexOf ( UNIX_SEPARATOR , 2 ) ; MST[rv.CRCR6Mutator]MSP[N] int posWin = fileName . indexOf ( WINDOWS_SEPARATOR , 2 ) ;
public static String getFullPathNoEndSeparator ( final String fileName ) { return doGetFullPath ( fileName , false ) ; MST[InlineConstantMutator]MSP[N] } private static String doGetFullPath ( final String fileName , final boolean includeSeparator ) { if ( fileName == null ) { return null ; }
} return fileName . substring ( 0 , end ) ; MST[NonVoidMethodCallMutator]MSP[N] } public static String getName ( final String fileName ) { if ( fileName == null ) { return null ; } failIfNullBytePresent ( fileName ) ; final int index = indexOfLastSeparator ( fileName ) ;
if ( array [ i ] == separator && array [ i - 1 ] == separator ) { System . arraycopy ( array , i , array , i - 1 , size - i ) ; MST[rv.AOD1Mutator]MSP[N] size -- ; i -- ; } }
if ( array [ i ] == separator && array [ i - 1 ] == separator ) { MST[rv.UOI2Mutator]MSP[N] System . arraycopy ( array , i , array , i - 1 , size - i ) ; size -- ; i -- ; } }
final int lastSeparator = indexOfLastSeparator ( fileName ) ; return lastSeparator > extensionPos ? NOT_FOUND : extensionPos ; } public static String getPrefix ( final String fileName ) { if ( fileName == null ) { MST[rv.ROR5Mutator]MSP[N] return null ; } final int len = getPrefixLength ( fileName ) ;
return doNormalize ( fileName , SYSTEM_SEPARATOR , true ) ; } public static String normalize ( final String fileName , final boolean unixSeparator ) { final char separator = unixSeparator ? UNIX_SEPARATOR : WINDOWS_SEPARATOR ; MST[rv.CRCR2Mutator]MSP[N] return doNormalize ( fileName , separator , true ) ; }
if ( array [ size - 1 ] != separator ) { MST[rv.ABSMutator]MSP[N] array [ size ++ ] = separator ; lastIsDirectory = false ; } for ( int i = prefix + 1 ; i < size ; i ++ ) {
if ( size <= prefix ) { MST[ConditionalsBoundaryMutator]MSP[N] return new String ( array , 0 , size ) ; } if ( lastIsDirectory && keepSeparator ) { return new String ( array , 0 , size ) ; }
if ( containsCompressedZeroes && ( inet6Address . indexOf ( lr_9 ) != inet6Address . lastIndexOf ( lr_9 ) ) ) { return false ; } if ( ( inet6Address . startsWith ( lr_10 ) && ! inet6Address . startsWith ( lr_9 ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[S]
final int index = indexOfLastSeparator ( fileName ) ; if ( index < 0 ) { return fileName . substring ( 0 , prefix ) ; } int end = index + ( includeSeparator ? 1 : 0 ) ; if ( end == 0 ) { MST[rv.ROR1Mutator]MSP[N] end ++ ;
if ( array [ i ] == separator && array [ i - 1 ] == '.' && array [ i - 2 ] == '.' && MST[NegateConditionalsMutator]MSP[N] ( i == prefix + 2 || array [ i - 3 ] == separator ) ) {
public static boolean directoryContains ( final String canonicalParent , final String canonicalChild ) throws IOException { if ( canonicalParent == null ) { throw new IllegalArgumentException ( lr_1 ) ; } if ( canonicalChild == null ) { return false ; MST[BooleanTrueReturnValsMutator]MSP[N] }
public static boolean isExtension ( final String fileName , final String ... extensions ) { if ( fileName == null ) { return false ; } failIfNullBytePresent ( fileName ) ; if ( extensions == null || extensions . length == 0 ) { MST[rv.ROR3Mutator]MSP[N]
if ( containsCompressedZeroes && ( inet6Address . indexOf ( lr_9 ) != inet6Address . lastIndexOf ( lr_9 ) ) ) { return false ; } if ( ( inet6Address . startsWith ( lr_10 ) && ! inet6Address . startsWith ( lr_9 ) ) MST[rv.ROR1Mutator]MSP[S]
final char ch = basePath . charAt ( len - 1 ) ; if ( isSeparator ( ch ) ) { return normalize ( basePath + fullFileNameToAdd ) ; MST[ReturnValsMutator]MSP[N] } return normalize ( basePath + '/' + fullFileNameToAdd ) ; }
if ( path == null || path . indexOf ( UNIX_SEPARATOR ) == NOT_FOUND ) { MST[NegateConditionalsMutator]MSP[N] return path ; } return path . replace ( UNIX_SEPARATOR , WINDOWS_SEPARATOR ) ; } public static String separatorsToSystem ( final String path ) { if ( path == null ) {
return doNormalize ( fileName , separator , false ) ; } private static String doNormalize ( final String fileName , final char separator , final boolean keepSeparator ) { if ( fileName == null ) { return null ; MST[ReturnValsMutator]MSP[N] } failIfNullBytePresent ( fileName ) ;
return false ; } static String [] splitOnTokens ( final String text ) { if ( text . indexOf ( '?' ) == NOT_FOUND && text . indexOf ( '*' ) == NOT_FOUND ) { MST[rv.CRCR2Mutator]MSP[N] return new String [] { text } ; }
final int lastSeparator = indexOfLastSeparator ( fileName ) ; return lastSeparator > extensionPos ? NOT_FOUND : extensionPos ; MST[rv.ABSMutator]MSP[N] } public static String getPrefix ( final String fileName ) { if ( fileName == null ) { return null ; } final int len = getPrefixLength ( fileName ) ;
return indexOfExtension ( fileName ) == NOT_FOUND ; } final String fileExt = getExtension ( fileName ) ; for ( final String extension : extensions ) { if ( fileExt . equals ( extension ) ) { return true ; MST[rv.CRCR6Mutator]MSP[N] } } return false ; }
if ( len == 2 || isSeparator ( fileName . charAt ( 2 ) ) == false ) { return 2 ; MST[rv.CRCR6Mutator]MSP[N] } return 3 ; } else if ( ch0 == UNIX_SEPARATOR ) { return 1 ; } return NOT_FOUND ;
private static boolean isIPv4Address ( final String name ) { final Matcher m = IPV4_PATTERN . matcher ( name ) ; if ( ! m . matches () || m . groupCount () != 4 ) { MST[rv.ROR3Mutator]MSP[S] return false ; }
public static boolean isExtension ( final String fileName , final Collection < String > extensions ) { if ( fileName == null ) { return false ; MST[rv.CRCR5Mutator]MSP[N] } failIfNullBytePresent ( fileName ) ; if ( extensions == null || extensions . isEmpty () ) {
private static boolean isIPv4Address ( final String name ) { final Matcher m = IPV4_PATTERN . matcher ( name ) ; if ( ! m . matches () || m . groupCount () != 4 ) { MST[InlineConstantMutator]MSP[S] return false ; }
if ( array [ i ] == separator && array [ i - 1 ] == separator ) { MST[rv.ROR3Mutator]MSP[N] System . arraycopy ( array , i , array , i - 1 , size - i ) ; size -- ; i -- ; } }
return fileName . substring ( index + 1 ) ; MST[rv.CRCR5Mutator]MSP[N] } private static void failIfNullBytePresent ( final String path ) { final int len = path . length () ; for ( int i = 0 ; i < len ; i ++ ) {
if ( array [ i ] == separator && array [ i - 1 ] == '.' && array [ i - 2 ] == '.' && MST[rv.ABSMutator]MSP[N] ( i == prefix + 2 || array [ i - 3 ] == separator ) ) {
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2 ) { MST[rv.ROR5Mutator]MSP[N] return NOT_FOUND ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ;
if ( isSystemWindows () ) { MST[rv.ROR4Mutator]MSP[N] final int offset = fileName . indexOf ( ':' , getAdsCriticalOffset ( fileName ) ) ; if ( offset != - 1 ) { throw new IllegalArgumentException ( lr_2 ) ; } } final int extensionPos = fileName . lastIndexOf ( EXTENSION_SEPARATOR ) ;
System . arraycopy ( array , i + 1 , array , i - 1 , size - i ) ; size -= 2 ; i -- ; } } outer: for ( int i = prefix + 2 ; i < size ; i ++ ) { MST[rv.UOI3Mutator]MSP[N]
if ( len == 0 ) { return 0 ; } char ch0 = fileName . charAt ( 0 ) ; if ( ch0 == ':' ) { MST[rv.UOI2Mutator]MSP[N] return NOT_FOUND ; } if ( len == 1 ) { if ( ch0 == '~' ) { return 2 ; }
return fileName . substring ( index + 1 ) ; MST[rv.CRCR6Mutator]MSP[N] } private static int getAdsCriticalOffset ( final String fileName ) { final int offset1 = fileName . lastIndexOf ( SYSTEM_SEPARATOR ) ; final int offset2 = fileName . lastIndexOf ( OTHER_SEPARATOR ) ;
public static String getExtension ( final String fileName ) throws IllegalArgumentException { if ( fileName == null ) { MST[NegateConditionalsMutator]MSP[N] return null ; } final int index = indexOfExtension ( fileName ) ; if ( index == NOT_FOUND ) { return EMPTY_STRING ; }
return indexOfExtension ( fileName ) == NOT_FOUND ; MST[rv.CRCR1Mutator]MSP[S] } final String fileExt = getExtension ( fileName ) ; for ( final String extension : extensions ) { if ( fileExt . equals ( extension ) ) { return true ; } } return false ; }
System . arraycopy ( array , i + 1 , array , i - 1 , size - i ) ; size -= 2 ; i -- ; } } outer: for ( int i = prefix + 2 ; i < size ; i ++ ) { MST[rv.ABSMutator]MSP[N]
} else if ( isSeparator ( ch0 ) && isSeparator ( ch1 ) ) { MST[rv.ROR2Mutator]MSP[N] int posUnix = fileName . indexOf ( UNIX_SEPARATOR , 2 ) ; int posWin = fileName . indexOf ( WINDOWS_SEPARATOR , 2 ) ;
if ( octets . length > IPV6_MAX_HEX_GROUPS ) { return false ; } int validOctets = 0 ; int emptyOctets = 0 ; for ( int index = 0 ; index < octets . length ; index ++ ) { final String octet = octets [ index ] ; MST[rv.UOI4Mutator]MSP[N]
return null ; } return isSystemWindows () ? separatorsToWindows ( path ) : separatorsToUnix ( path ) ; } public static int getPrefixLength ( final String fileName ) { if ( fileName == null ) { return NOT_FOUND ; MST[rv.CRCR4Mutator]MSP[N] } final int len = fileName . length () ;
final int prefix = getPrefixLength ( fileName ) ; if ( prefix < 0 ) { MST[rv.ROR2Mutator]MSP[N] return null ; } if ( prefix >= fileName . length () ) { if ( includeSeparator ) { return getPrefix ( fileName ) ; } return fileName ; }
System . arraycopy ( array , i + 1 , array , i - 1 , size - i ) ; size -= 2 ; i -- ; } } outer: for ( int i = prefix + 2 ; i < size ; i ++ ) { MST[rv.ROR4Mutator]MSP[N]
final char ch = basePath . charAt ( len - 1 ) ; if ( isSeparator ( ch ) ) { MST[rv.ABSMutator]MSP[N] return normalize ( basePath + fullFileNameToAdd ) ; } return normalize ( basePath + '/' + fullFileNameToAdd ) ; }
if ( octet . length () == 0 ) { emptyOctets ++ ; if ( emptyOctets > 1 ) { return false ; } } else { emptyOctets = 0 ; if ( index == octets . length - 1 && octet . contains ( lr_12 ) ) { MST[rv.CRCR3Mutator]MSP[S]
if ( len == 2 || isSeparator ( fileName . charAt ( 2 ) ) == false ) { return 2 ; } return 3 ; } else if ( ch0 == UNIX_SEPARATOR ) { return 1 ; MST[ReturnValsMutator]MSP[S] } return NOT_FOUND ;
fileName2 = normalize ( fileName2 ) ; if ( fileName1 == null || fileName2 == null ) { MST[rv.ROR5Mutator]MSP[N] throw new NullPointerException ( lr_5 ) ; } } if ( caseSensitivity == null ) { caseSensitivity = IOCase . SENSITIVE ; }
return isSeparator ( ch0 ) ? 1 : 0 ; } if ( ch0 == '~' ) { int posUnix = fileName . indexOf ( UNIX_SEPARATOR , 1 ) ; MST[rv.CRCR2Mutator]MSP[N] int posWin = fileName . indexOf ( WINDOWS_SEPARATOR , 1 ) ;
final int prefix = getPrefixLength ( fileName ) ; if ( prefix < 0 ) { MST[rv.UOI1Mutator]MSP[N] return null ; } if ( prefix >= fileName . length () ) { if ( includeSeparator ) { return getPrefix ( fileName ) ; } return fileName ; }
textIdx = array [ 1 ] ; anyChars = true ; } while ( wcsIdx < wcs . length ) { MST[rv.UOI3Mutator]MSP[N] if ( wcs [ wcsIdx ] . equals ( lr_6 ) ) { textIdx ++ ; if ( textIdx > fileName . length () ) { break; }
for ( int i = prefix + 1 ; i < size ; i ++ ) { if ( array [ i ] == separator && array [ i - 1 ] == '.' && MST[rv.CRCR3Mutator]MSP[N]
return wildcardMatch ( fileName , wildcardMatcher , IOCase . SYSTEM ) ; } public static boolean wildcardMatch ( final String fileName , final String wildcardMatcher , IOCase caseSensitivity ) { if ( fileName == null && wildcardMatcher == null ) { return true ; MST[BooleanFalseReturnValsMutator]MSP[N] }
private static String doGetPath ( final String fileName , final int separatorAdd ) { if ( fileName == null ) { MST[rv.ROR5Mutator]MSP[N] return null ; } final int prefix = getPrefixLength ( fileName ) ; if ( prefix < 0 ) { return null ; }
if ( ipSegment . length () > 1 && ipSegment . startsWith ( lr_8 ) ) { MST[rv.CRCR5Mutator]MSP[N] return false ; } } return true ; } private static boolean isIPv6Address ( final String inet6Address ) { final boolean containsCompressedZeroes = inet6Address . contains ( lr_9 ) ;
if ( array [ size - 1 ] != separator ) { array [ size ++ ] = separator ; lastIsDirectory = false ; MST[rv.CRCR6Mutator]MSP[N] } for ( int i = prefix + 1 ; i < size ; i ++ ) {
if ( ! isIPv4Address ( octet ) ) { return false ; MST[BooleanTrueReturnValsMutator]MSP[N] } validOctets += 2 ; continue; } if ( octet . length () > IPV6_MAX_HEX_DIGITS_PER_GROUP ) { return false ; } int octetInt = 0 ; try {
for ( int i = 0 ; i < parts . length ; i ++ ) { if ( parts [ i ] . length () == 0 ) { return i == parts . length - 1 ; MST[rv.ROR2Mutator]MSP[N] }
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND ) { MST[rv.CRCR5Mutator]MSP[N] return len + 1 ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ; return Math . min ( posUnix , posWin ) + 1 ; }
if ( array [ i ] == separator && array [ i - 1 ] == separator ) { System . arraycopy ( array , i , array , i - 1 , size - i ) ; MST[rv.UOI2Mutator]MSP[N] size -- ; i -- ; } }
if ( len == 0 ) { return 0 ; } char ch0 = fileName . charAt ( 0 ) ; if ( ch0 == ':' ) { return NOT_FOUND ; } if ( len == 1 ) { if ( ch0 == '~' ) { MST[rv.ROR4Mutator]MSP[N] return 2 ; }
if ( array [ i ] == separator && array [ i - 1 ] == separator ) { System . arraycopy ( array , i , array , i - 1 , size - i ) ; MST[rv.ABSMutator]MSP[N] size -- ; i -- ; } }
if ( array [ i ] == separator && array [ i - 1 ] == '.' && array [ i - 2 ] == '.' && MST[rv.ROR1Mutator]MSP[N] ( i == prefix + 2 || array [ i - 3 ] == separator ) ) {
if ( array [ i ] == separator && array [ i - 1 ] == '.' && array [ i - 2 ] == '.' && MST[rv.ROR5Mutator]MSP[N] ( i == prefix + 2 || array [ i - 3 ] == separator ) ) {
if ( octet . length () == 0 ) { emptyOctets ++ ; if ( emptyOctets > 1 ) { return false ; } } else { emptyOctets = 0 ; if ( index == octets . length - 1 && octet . contains ( lr_12 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
return caseSensitivity . checkEquals ( fileName1 , fileName2 ) ; } public static boolean isExtension ( final String fileName , final String extension ) { if ( fileName == null ) { MST[NegateConditionalsMutator]MSP[N] return false ; } failIfNullBytePresent ( fileName ) ;
if ( len == 0 ) { return 0 ; } char ch0 = fileName . charAt ( 0 ) ; if ( ch0 == ':' ) { MST[rv.ABSMutator]MSP[N] return NOT_FOUND ; } if ( len == 1 ) { if ( ch0 == '~' ) { return 2 ; }
if ( index == NOT_FOUND ) { return fileName ; } return fileName . substring ( 0 , index ) ; MST[rv.UOI4Mutator]MSP[N] } public static boolean equals ( final String fileName1 , final String fileName2 ) { return equals ( fileName1 , fileName2 , false , IOCase . SENSITIVE ) ;
if ( octet . length () == 0 ) { emptyOctets ++ ; if ( emptyOctets > 1 ) { return false ; } } else { emptyOctets = 0 ; if ( index == octets . length - 1 && octet . contains ( lr_12 ) ) { MST[rv.ROR1Mutator]MSP[N]
if ( array [ i ] == separator && array [ i - 1 ] == '.' && array [ i - 2 ] == '.' && MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] ( i == prefix + 2 || array [ i - 3 ] == separator ) ) {
if ( array [ i ] == separator && array [ i - 1 ] == '.' && array [ i - 2 ] == '.' && MST[rv.CRCR6Mutator]MSP[N] ( i == prefix + 2 || array [ i - 3 ] == separator ) ) {
final int lastWindowsPos = fileName . lastIndexOf ( WINDOWS_SEPARATOR ) ; MST[rv.CRCR1Mutator]MSP[N] return Math . max ( lastUnixPos , lastWindowsPos ) ; } public static int indexOfExtension ( final String fileName ) throws IllegalArgumentException { if ( fileName == null ) { return NOT_FOUND ; }
if ( array [ j ] == separator ) { System . arraycopy ( array , i + 1 , array , j + 1 , size - i ) ; MST[rv.CRCR5Mutator]MSP[N] size -= i - j ; i = j + 1 ; continue outer; } }
return indexOfExtension ( fileName ) == NOT_FOUND ; MST[InlineConstantMutator]MSP[N] } final String fileExt = getExtension ( fileName ) ; for ( final String extension : extensions ) { if ( fileExt . equals ( extension ) ) { return true ; } } return false ; }
private static boolean isIPv4Address ( final String name ) { final Matcher m = IPV4_PATTERN . matcher ( name ) ; if ( ! m . matches () || m . groupCount () != 4 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] return false ; }
if ( validOctets > IPV6_MAX_HEX_GROUPS || ( validOctets < IPV6_MAX_HEX_GROUPS && ! containsCompressedZeroes ) ) { return false ; MST[InlineConstantMutator]MSP[S] } return true ; } private static boolean isRFC3986HostName ( final String name ) { final String [] parts = name . split ( lr_13 , - 1 ) ;
return indexOfExtension ( fileName ) == NOT_FOUND ; } final String fileExt = getExtension ( fileName ) ; for ( final String extension : extensions ) { MST[rv.ABSMutator]MSP[N] if ( fileExt . equals ( extension ) ) { return true ; } } return false ; }
if ( validOctets > IPV6_MAX_HEX_GROUPS || ( validOctets < IPV6_MAX_HEX_GROUPS && ! containsCompressedZeroes ) ) { MST[rv.ROR4Mutator]MSP[N] return false ; } return true ; } private static boolean isRFC3986HostName ( final String name ) { final String [] parts = name . split ( lr_13 , - 1 ) ;
if ( array [ j ] == separator ) { System . arraycopy ( array , i + 1 , array , j + 1 , size - i ) ; size -= i - j ; i = j + 1 ; MST[rv.CRCR5Mutator]MSP[N] continue outer; } }
return indexOfExtension ( fileName ) == NOT_FOUND ; MST[rv.CRCR4Mutator]MSP[N] } final String fileExt = getExtension ( fileName ) ; for ( final String extension : extensions ) { if ( fileExt . equals ( extension ) ) { return true ; } } return false ; }
list . add ( lr_6 ) ; } else if ( prevChar != '*' ) { list . add ( lr_7 ) ; } } else { buffer . append ( ch ) ; } prevChar = ch ; } if ( buffer . length () != 0 ) { MST[NonVoidMethodCallMutator]MSP[N]
final int index = indexOfLastSeparator ( fileName ) ; if ( index < 0 ) { return fileName . substring ( 0 , prefix ) ; } int end = index + ( includeSeparator ? 1 : 0 ) ; MST[rv.AOR4Mutator]MSP[N] if ( end == 0 ) { end ++ ;
} else if ( inet6Address . startsWith ( lr_9 ) && ! octetList . isEmpty () ) { MST[NegateConditionalsMutator]MSP[N] octetList . remove ( 0 ) ; } octets = octetList . toArray ( new String [ octetList . size () ] ) ; }
anyChars = false ; } else if ( wcs [ wcsIdx ] . equals ( lr_7 ) ) { anyChars = true ; if ( wcsIdx == wcs . length - 1 ) { textIdx = fileName . length () ; } } else { if ( anyChars ) { MST[rv.ROR4Mutator]MSP[N]
if ( array [ size - 1 ] != separator ) { array [ size ++ ] = separator ; lastIsDirectory = false ; } for ( int i = prefix + 1 ; i < size ; i ++ ) { MST[MathMutator]MSP[N]
if ( ! isIPv4Address ( octet ) ) { return false ; } validOctets += 2 ; continue; } if ( octet . length () > IPV6_MAX_HEX_DIGITS_PER_GROUP ) { MST[NonVoidMethodCallMutator]MSP[N] return false ; } int octetInt = 0 ; try {
for ( int i = 0 ; i < parts . length ; i ++ ) { if ( parts [ i ] . length () == 0 ) { return i == parts . length - 1 ; MST[rv.UOI4Mutator]MSP[N] }
if ( array [ i ] == separator && array [ i - 1 ] == '.' && array [ i - 2 ] == '.' && MST[rv.UOI3Mutator]MSP[N] ( i == prefix + 2 || array [ i - 3 ] == separator ) ) {
if ( array [ j ] == separator ) { System . arraycopy ( array , i + 1 , array , j + 1 , size - i ) ; size -= i - j ; MST[rv.UOI2Mutator]MSP[N] i = j + 1 ; continue outer; } }
if ( size <= prefix ) { MST[NegateConditionalsMutator]MSP[N] return new String ( array , 0 , size ) ; } if ( lastIsDirectory && keepSeparator ) { return new String ( array , 0 , size ) ; }
int wcsIdx = 0 ; MST[InlineConstantMutator]MSP[N] final Stack < int [] > backtrack = new Stack <> () ; do { if ( backtrack . size () > 0 ) { final int [] array = backtrack . pop () ; wcsIdx = array [ 0 ] ;
if ( prefix > 0 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] return normalize ( fullFileNameToAdd ) ; } if ( basePath == null ) { return null ; } final int len = basePath . length () ; if ( len == 0 ) { return normalize ( fullFileNameToAdd ) ; }
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2 ) { return NOT_FOUND ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; MST[rv.UOI4Mutator]MSP[N] posWin = posWin == NOT_FOUND ? posUnix : posWin ;
return null ; MST[EmptyObjectReturnValsMutator]MSP[S] } return isSystemWindows () ? separatorsToWindows ( path ) : separatorsToUnix ( path ) ; } public static int getPrefixLength ( final String fileName ) { if ( fileName == null ) { return NOT_FOUND ; } final int len = fileName . length () ;
octetInt = Integer . parseInt ( octet , BASE_16 ) ; } catch ( final NumberFormatException e ) { return false ; MST[rv.CRCR1Mutator]MSP[S] } if ( octetInt < 0 || octetInt > MAX_UNSIGNED_SHORT ) { return false ; } } validOctets ++ ; }
if ( array [ i ] == separator && array [ i - 1 ] == separator ) { System . arraycopy ( array , i , array , i - 1 , size - i ) ; size -- ; i -- ; MST[IncrementsMutator]MSP[N] } }
return indexOfExtension ( fileName ) == NOT_FOUND ; } final String fileExt = getExtension ( fileName ) ; for ( final String extension : extensions ) { MST[rv.UOI3Mutator]MSP[S] if ( fileExt . equals ( extension ) ) { return true ; } } return false ; }
return indexOfExtension ( fileName ) == NOT_FOUND ; } final String fileExt = getExtension ( fileName ) ; for ( final String extension : extensions ) { if ( fileExt . equals ( extension ) ) { return true ; } } return false ; MST[rv.CRCR5Mutator]MSP[N] }
if ( ! isIPv4Address ( octet ) ) { return false ; } validOctets += 2 ; continue; } if ( octet . length () > IPV6_MAX_HEX_DIGITS_PER_GROUP ) { return false ; } int octetInt = 0 ; MST[rv.CRCR1Mutator]MSP[N] try {
if ( octet . length () == 0 ) { emptyOctets ++ ; if ( emptyOctets > 1 ) { MST[rv.ROR1Mutator]MSP[N] return false ; } } else { emptyOctets = 0 ; if ( index == octets . length - 1 && octet . contains ( lr_12 ) ) {
static boolean isSystemWindows () { return SYSTEM_SEPARATOR == WINDOWS_SEPARATOR ; } private static boolean isSeparator ( final char ch ) { return ch == UNIX_SEPARATOR || ch == WINDOWS_SEPARATOR ; MST[rv.UOI2Mutator]MSP[N] } public static String normalize ( final String fileName ) {
list . add ( lr_6 ) ; } else if ( prevChar != '*' ) { MST[rv.UOI3Mutator]MSP[S] list . add ( lr_7 ) ; } } else { buffer . append ( ch ) ; } prevChar = ch ; } if ( buffer . length () != 0 ) {
final int index = indexOfLastSeparator ( fileName ) ; if ( index < 0 ) { return fileName . substring ( 0 , prefix ) ; MST[rv.UOI2Mutator]MSP[N] } int end = index + ( includeSeparator ? 1 : 0 ) ; if ( end == 0 ) { end ++ ;
list . add ( lr_6 ) ; } else if ( prevChar != '*' ) { MST[rv.ROR3Mutator]MSP[N] list . add ( lr_7 ) ; } } else { buffer . append ( ch ) ; } prevChar = ch ; } if ( buffer . length () != 0 ) {
final int index = indexOfLastSeparator ( fileName ) ; if ( index < 0 ) { return fileName . substring ( 0 , prefix ) ; } int end = index + ( includeSeparator ? 1 : 0 ) ; MST[rv.UOI4Mutator]MSP[N] if ( end == 0 ) { end ++ ;
if ( len < 0 ) { return null ; } if ( len > fileName . length () ) { failIfNullBytePresent ( fileName + UNIX_SEPARATOR ) ; return fileName + UNIX_SEPARATOR ; } final String path = fileName . substring ( 0 , len ) ; MST[rv.CRCR5Mutator]MSP[N]
anyChars = false ; } else if ( wcs [ wcsIdx ] . equals ( lr_7 ) ) { MST[rv.ROR2Mutator]MSP[N] anyChars = true ; if ( wcsIdx == wcs . length - 1 ) { textIdx = fileName . length () ; } } else { if ( anyChars ) {
if ( array [ i ] == separator && array [ i - 1 ] == separator ) { MST[rv.ABSMutator]MSP[N] System . arraycopy ( array , i , array , i - 1 , size - i ) ; size -- ; i -- ; } }
for ( int i = prefix + 1 ; i < size ; i ++ ) { if ( array [ i ] == separator && array [ i - 1 ] == '.' && MST[rv.ROR2Mutator]MSP[N]
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND ) { return len + 1 ; MST[rv.AOR4Mutator]MSP[N] } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ; return Math . min ( posUnix , posWin ) + 1 ; }
if ( i == prefix + 2 ) { return null ; } if ( i == size - 1 ) { MST[rv.UOI3Mutator]MSP[N] lastIsDirectory = true ; } int j ; for ( j = i - 4 ; j >= prefix ; j -- ) {
System . arraycopy ( array , i + 1 , array , prefix , size - i ) ; MST[rv.UOI4Mutator]MSP[N] size -= i + 1 - prefix ; i = prefix + 1 ; } } if ( size <= 0 ) { return EMPTY_STRING ; }
if ( octet . length () == 0 ) { emptyOctets ++ ; if ( emptyOctets > 1 ) { return false ; } } else { emptyOctets = 0 ; if ( index == octets . length - 1 && octet . contains ( lr_12 ) ) { MST[rv.UOI3Mutator]MSP[S]
if ( validOctets > IPV6_MAX_HEX_GROUPS || ( validOctets < IPV6_MAX_HEX_GROUPS && ! containsCompressedZeroes ) ) { MST[rv.ROR2Mutator]MSP[S] return false ; } return true ; } private static boolean isRFC3986HostName ( final String name ) { final String [] parts = name . split ( lr_13 , - 1 ) ;
if ( array [ size - 1 ] != separator ) { array [ size ++ ] = separator ; lastIsDirectory = false ; } for ( int i = prefix + 1 ; i < size ; i ++ ) { MST[rv.UOI1Mutator]MSP[S]
if ( array [ i ] == separator && array [ i - 1 ] == separator ) { System . arraycopy ( array , i , array , i - 1 , size - i ) ; MST[rv.AOR3Mutator]MSP[N] size -- ; i -- ; } }
final int index = indexOfLastSeparator ( fileName ) ; final int endIndex = index + separatorAdd ; if ( prefix >= fileName . length () || index < 0 || prefix >= endIndex ) { MST[rv.UOI4Mutator]MSP[S] return EMPTY_STRING ; }
failIfNullBytePresent ( path ) ; return path ; } public static String getPath ( final String fileName ) { return doGetPath ( fileName , 1 ) ; MST[rv.CRCR5Mutator]MSP[S] } public static String getPathNoEndSeparator ( final String fileName ) { return doGetPath ( fileName , 0 ) ; }
final int index = indexOfLastSeparator ( fileName ) ; final int endIndex = index + separatorAdd ; MST[rv.UOI2Mutator]MSP[N] if ( prefix >= fileName . length () || index < 0 || prefix >= endIndex ) { return EMPTY_STRING ; }
for ( int i = 0 ; i < parts . length ; i ++ ) { if ( parts [ i ] . length () == 0 ) { return i == parts . length - 1 ; MST[rv.CRCR2Mutator]MSP[N] }
System . arraycopy ( array , i + 1 , array , prefix , size - i ) ; size -= i + 1 - prefix ; MST[rv.UOI2Mutator]MSP[N] i = prefix + 1 ; } } if ( size <= 0 ) { return EMPTY_STRING ; }
for ( int i = 0 ; i < parts . length ; i ++ ) { if ( parts [ i ] . length () == 0 ) { return i == parts . length - 1 ; MST[rv.CRCR6Mutator]MSP[N] }
final String path = fileName . substring ( prefix , endIndex ) ; failIfNullBytePresent ( path ) ; return path ; } public static String getFullPath ( final String fileName ) { return doGetFullPath ( fileName , true ) ; MST[rv.CRCR3Mutator]MSP[N] }
for ( int i = prefix + 1 ; i < size ; i ++ ) { if ( array [ i ] == separator && array [ i - 1 ] == '.' && MST[rv.UOI2Mutator]MSP[N]
return new String ( array , 0 , size - 1 ) ; } public static String concat ( final String basePath , final String fullFileNameToAdd ) { final int prefix = getPrefixLength ( fullFileNameToAdd ) ; if ( prefix < 0 ) { MST[rv.ABSMutator]MSP[N] return null ; }
final int lastSeparator = indexOfLastSeparator ( fileName ) ; return lastSeparator > extensionPos ? NOT_FOUND : extensionPos ; MST[rv.UOI1Mutator]MSP[N] } public static String getPrefix ( final String fileName ) { if ( fileName == null ) { return null ; } final int len = getPrefixLength ( fileName ) ;
textIdx = array [ 1 ] ; anyChars = true ; MST[rv.CRCR3Mutator]MSP[N] } while ( wcsIdx < wcs . length ) { if ( wcs [ wcsIdx ] . equals ( lr_6 ) ) { textIdx ++ ; if ( textIdx > fileName . length () ) { break; }
if ( ch == '?' || ch == '*' ) { if ( buffer . length () != 0 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] list . add ( buffer . toString () ) ; buffer . setLength ( 0 ) ; } if ( ch == '?' ) {
final char ch1 = fileName . charAt ( 1 ) ; MST[rv.CRCR6Mutator]MSP[N] if ( ch1 == ':' ) { ch0 = Character . toUpperCase ( ch0 ) ; if ( ch0 >= 'A' && ch0 <= 'Z' ) {
} public static boolean equalsOnSystem ( final String fileName1 , final String fileName2 ) { return equals ( fileName1 , fileName2 , false , IOCase . SYSTEM ) ; MST[InlineConstantMutator]MSP[S] } public static boolean equalsNormalized ( final String fileName1 , final String fileName2 ) {
if ( i == prefix + 2 ) { return null ; } if ( i == size - 1 ) { lastIsDirectory = true ; } int j ; for ( j = i - 4 ; j >= prefix ; j -- ) { MST[rv.CRCR3Mutator]MSP[N]
( i == prefix + 1 || array [ i - 2 ] == separator ) ) { if ( i == size - 1 ) { MST[rv.UOI4Mutator]MSP[N] lastIsDirectory = true ; }
return fileName . substring ( index + 1 ) ; } private static void failIfNullBytePresent ( final String path ) { final int len = path . length () ; for ( int i = 0 ; i < len ; i ++ ) { MST[rv.CRCR6Mutator]MSP[N]
final char [] array = new char [ size + 2 ] ; MST[rv.AOD1Mutator]MSP[N] fileName . getChars ( 0 , fileName . length () , array , 0 ) ; final char otherSeparator = separator == SYSTEM_SEPARATOR ? OTHER_SEPARATOR : SYSTEM_SEPARATOR ;
if ( index == NOT_FOUND ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return fileName ; } return fileName . substring ( 0 , index ) ; } public static boolean equals ( final String fileName1 , final String fileName2 ) { return equals ( fileName1 , fileName2 , false , IOCase . SENSITIVE ) ;
int wcsIdx = 0 ; MST[rv.CRCR3Mutator]MSP[N] final Stack < int [] > backtrack = new Stack <> () ; do { if ( backtrack . size () > 0 ) { final int [] array = backtrack . pop () ; wcsIdx = array [ 0 ] ;
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2 ) { return NOT_FOUND ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; MST[rv.ROR3Mutator]MSP[N] posWin = posWin == NOT_FOUND ? posUnix : posWin ;
return indexOfExtension ( fileName ) == NOT_FOUND ; MST[rv.ROR4Mutator]MSP[N] } final String fileExt = getExtension ( fileName ) ; for ( final String extension : extensions ) { if ( fileExt . equals ( extension ) ) { return true ; } } return false ; }
|| ( inet6Address . endsWith ( lr_10 ) && ! inet6Address . endsWith ( lr_9 ) ) ) { MST[NegateConditionalsMutator]MSP[N] return false ; } String [] octets = inet6Address . split ( lr_10 ) ; if ( containsCompressedZeroes ) {
if ( containsCompressedZeroes && ( inet6Address . indexOf ( lr_9 ) != inet6Address . lastIndexOf ( lr_9 ) ) ) { return false ; MST[rv.CRCR1Mutator]MSP[S] } if ( ( inet6Address . startsWith ( lr_10 ) && ! inet6Address . startsWith ( lr_9 ) )
for ( int i = prefix + 1 ; i < size ; i ++ ) { if ( array [ i ] == separator && array [ i - 1 ] == '.' && MST[rv.CRCR4Mutator]MSP[N]
if ( ipSegment . length () > 1 && ipSegment . startsWith ( lr_8 ) ) { MST[NonVoidMethodCallMutator]MSP[N] return false ; } } return true ; } private static boolean isIPv6Address ( final String inet6Address ) { final boolean containsCompressedZeroes = inet6Address . contains ( lr_9 ) ;
if ( repeat >= 0 ) { backtrack . push ( new int [] { wcsIdx , repeat } ) ; MST[rv.UOI2Mutator]MSP[N] } } else { if ( ! caseSensitivity . checkRegionMatches ( fileName , textIdx , wcs [ wcsIdx ] ) ) { break; } }
return new String ( array , 0 , size - 1 ) ; } public static String concat ( final String basePath , final String fullFileNameToAdd ) { final int prefix = getPrefixLength ( fullFileNameToAdd ) ; if ( prefix < 0 ) { return null ; MST[ReturnValsMutator]MSP[N] }
final int pos = Math . min ( posUnix , posWin ) + 1 ; final String hostnamePart = fileName . substring ( 2 , pos - 1 ) ; return isValidHostName ( hostnamePart ) ? pos : NOT_FOUND ; MST[rv.CRCR6Mutator]MSP[S] } else {
for ( int i = 1 ; i <= 4 ; i ++ ) { MST[ConditionalsBoundaryMutator]MSP[N] final String ipSegment = m . group ( i ) ; final int iIpSegment = Integer . parseInt ( ipSegment ) ; if ( iIpSegment > IPV4_MAX_OCTET_VALUE ) { return false ; }
for ( int i = prefix + 1 ; i < size ; i ++ ) { if ( array [ i ] == separator && array [ i - 1 ] == '.' && MST[rv.AOR4Mutator]MSP[N]
return isSeparator ( ch0 ) ? 1 : 0 ; MST[rv.ROR5Mutator]MSP[N] } } public static int indexOfLastSeparator ( final String fileName ) { if ( fileName == null ) { return NOT_FOUND ; } final int lastUnixPos = fileName . lastIndexOf ( UNIX_SEPARATOR ) ;
if ( array [ size - 1 ] != separator ) { array [ size ++ ] = separator ; MST[rv.UOI1Mutator]MSP[N] lastIsDirectory = false ; } for ( int i = prefix + 1 ; i < size ; i ++ ) {
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND ) { return len + 1 ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; MST[NegateConditionalsMutator]MSP[N] posWin = posWin == NOT_FOUND ? posUnix : posWin ; return Math . min ( posUnix , posWin ) + 1 ; }
if ( validOctets > IPV6_MAX_HEX_GROUPS || ( validOctets < IPV6_MAX_HEX_GROUPS && ! containsCompressedZeroes ) ) { return false ; } return true ; MST[BooleanFalseReturnValsMutator]MSP[N] } private static boolean isRFC3986HostName ( final String name ) { final String [] parts = name . split ( lr_13 , - 1 ) ;
if ( len == 2 || isSeparator ( fileName . charAt ( 2 ) ) == false ) { return 2 ; } return 3 ; MST[rv.CRCR2Mutator]MSP[N] } else if ( ch0 == UNIX_SEPARATOR ) { return 1 ; } return NOT_FOUND ;
octetInt = Integer . parseInt ( octet , BASE_16 ) ; } catch ( final NumberFormatException e ) { return false ; } if ( octetInt < 0 || octetInt > MAX_UNSIGNED_SHORT ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] return false ; } } validOctets ++ ; }
if ( len < 0 ) { return null ; } if ( len > fileName . length () ) { failIfNullBytePresent ( fileName + UNIX_SEPARATOR ) ; return fileName + UNIX_SEPARATOR ; } final String path = fileName . substring ( 0 , len ) ; MST[rv.ABSMutator]MSP[N]
if ( extension == null || extension . isEmpty () ) { return indexOfExtension ( fileName ) == NOT_FOUND ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] } final String fileExt = getExtension ( fileName ) ; return fileExt . equals ( extension ) ; }
if ( octets . length > IPV6_MAX_HEX_GROUPS ) { return false ; } int validOctets = 0 ; int emptyOctets = 0 ; MST[rv.CRCR5Mutator]MSP[N] for ( int index = 0 ; index < octets . length ; index ++ ) { final String octet = octets [ index ] ;
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND ) { return len + 1 ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] posWin = posWin == NOT_FOUND ? posUnix : posWin ; return Math . min ( posUnix , posWin ) + 1 ; }
if ( ! isIPv4Address ( octet ) ) { return false ; } validOctets += 2 ; continue; } if ( octet . length () > IPV6_MAX_HEX_DIGITS_PER_GROUP ) { MST[rv.CRCR1Mutator]MSP[N] return false ; } int octetInt = 0 ; try {
if ( IOCase . SYSTEM . checkEquals ( canonicalParent , canonicalChild ) ) { return false ; MST[rv.CRCR3Mutator]MSP[S] } return IOCase . SYSTEM . checkStartsWith ( canonicalChild , canonicalParent ) ; } public static String separatorsToUnix ( final String path ) {
return false ; MST[rv.CRCR5Mutator]MSP[N] } static String [] splitOnTokens ( final String text ) { if ( text . indexOf ( '?' ) == NOT_FOUND && text . indexOf ( '*' ) == NOT_FOUND ) { return new String [] { text } ; }
return false ; } static String [] splitOnTokens ( final String text ) { if ( text . indexOf ( '?' ) == NOT_FOUND && text . indexOf ( '*' ) == NOT_FOUND ) { MST[InlineConstantMutator]MSP[N] return new String [] { text } ; }
return equals ( fileName1 , fileName2 , true , IOCase . SENSITIVE ) ; } public static boolean equalsNormalizedOnSystem ( final String fileName1 , final String fileName2 ) { return equals ( fileName1 , fileName2 , true , IOCase . SYSTEM ) ; MST[BooleanTrueReturnValsMutator]MSP[N] } public static boolean equals (
if ( i == prefix + 2 ) { return null ; } if ( i == size - 1 ) { lastIsDirectory = true ; } int j ; for ( j = i - 4 ; j >= prefix ; j -- ) { MST[rv.UOI3Mutator]MSP[N]
return null ; } return isSystemWindows () ? separatorsToWindows ( path ) : separatorsToUnix ( path ) ; MST[NonVoidMethodCallMutator]MSP[N] } public static int getPrefixLength ( final String fileName ) { if ( fileName == null ) { return NOT_FOUND ; } final int len = fileName . length () ;
final char [] array = text . toCharArray () ; final ArrayList < String > list = new ArrayList <> () ; final StringBuilder buffer = new StringBuilder () ; char prevChar = 0 ; for ( final char ch : array ) { MST[rv.UOI1Mutator]MSP[N]
if ( containsCompressedZeroes && ( inet6Address . indexOf ( lr_9 ) != inet6Address . lastIndexOf ( lr_9 ) ) ) { MST[rv.ROR3Mutator]MSP[N] return false ; } if ( ( inet6Address . startsWith ( lr_10 ) && ! inet6Address . startsWith ( lr_9 ) )
} else if ( isSeparator ( ch0 ) && isSeparator ( ch1 ) ) { MST[rv.ROR4Mutator]MSP[N] int posUnix = fileName . indexOf ( UNIX_SEPARATOR , 2 ) ; int posWin = fileName . indexOf ( WINDOWS_SEPARATOR , 2 ) ;
if ( array [ i ] == separator && array [ i - 1 ] == separator ) { MST[rv.ROR4Mutator]MSP[N] System . arraycopy ( array , i , array , i - 1 , size - i ) ; size -- ; i -- ; } }
anyChars = false ; } else if ( wcs [ wcsIdx ] . equals ( lr_7 ) ) { anyChars = true ; if ( wcsIdx == wcs . length - 1 ) { textIdx = fileName . length () ; } } else { if ( anyChars ) { MST[rv.UOI3Mutator]MSP[N]
return doNormalize ( fileName , separator , false ) ; MST[rv.CRCR6Mutator]MSP[S] } private static String doNormalize ( final String fileName , final char separator , final boolean keepSeparator ) { if ( fileName == null ) { return null ; } failIfNullBytePresent ( fileName ) ;
if ( index == NOT_FOUND ) { MST[rv.CRCR2Mutator]MSP[N] return fileName ; } return fileName . substring ( 0 , index ) ; } public static boolean equals ( final String fileName1 , final String fileName2 ) { return equals ( fileName1 , fileName2 , false , IOCase . SENSITIVE ) ;
for ( int i = 0 ; i < parts . length ; i ++ ) { if ( parts [ i ] . length () == 0 ) { return i == parts . length - 1 ; MST[rv.AOR2Mutator]MSP[N] }
if ( array [ j ] == separator ) { System . arraycopy ( array , i + 1 , array , j + 1 , size - i ) ; MST[rv.AOR2Mutator]MSP[N] size -= i - j ; i = j + 1 ; continue outer; } }
final int lastWindowsPos = fileName . lastIndexOf ( WINDOWS_SEPARATOR ) ; return Math . max ( lastUnixPos , lastWindowsPos ) ; MST[rv.ABSMutator]MSP[N] } public static int indexOfExtension ( final String fileName ) throws IllegalArgumentException { if ( fileName == null ) { return NOT_FOUND ; }
if ( array [ i ] == separator && array [ i - 1 ] == '.' && array [ i - 2 ] == '.' && MST[rv.UOI4Mutator]MSP[N] ( i == prefix + 2 || array [ i - 3 ] == separator ) ) {
final int pos = Math . min ( posUnix , posWin ) + 1 ; final String hostnamePart = fileName . substring ( 2 , pos - 1 ) ; MST[rv.CRCR3Mutator]MSP[N] return isValidHostName ( hostnamePart ) ? pos : NOT_FOUND ; } else {
final List < String > octetList = new ArrayList <> ( Arrays . asList ( octets ) ) ; if ( inet6Address . endsWith ( lr_9 ) ) { MST[rv.ROR5Mutator]MSP[N] octetList . add ( lr_11 ) ;
if ( len == 0 ) { return 0 ; } char ch0 = fileName . charAt ( 0 ) ; if ( ch0 == ':' ) { return NOT_FOUND ; } if ( len == 1 ) { MST[rv.ROR1Mutator]MSP[N] if ( ch0 == '~' ) { return 2 ; }
anyChars = false ; MST[rv.CRCR5Mutator]MSP[S] } else if ( wcs [ wcsIdx ] . equals ( lr_7 ) ) { anyChars = true ; if ( wcsIdx == wcs . length - 1 ) { textIdx = fileName . length () ; } } else { if ( anyChars ) {
if ( extension == null || extension . isEmpty () ) { return indexOfExtension ( fileName ) == NOT_FOUND ; MST[rv.CRCR2Mutator]MSP[N] } final String fileExt = getExtension ( fileName ) ; return fileExt . equals ( extension ) ; }
return false ; } static String [] splitOnTokens ( final String text ) { if ( text . indexOf ( '?' ) == NOT_FOUND && text . indexOf ( '*' ) == NOT_FOUND ) { return new String [] { text } ; MST[rv.CRCR6Mutator]MSP[N] }
final char ch = basePath . charAt ( len - 1 ) ; if ( isSeparator ( ch ) ) { return normalize ( basePath + fullFileNameToAdd ) ; } return normalize ( basePath + '/' + fullFileNameToAdd ) ; MST[rv.CRCR6Mutator]MSP[N] }
if ( containsCompressedZeroes && ( inet6Address . indexOf ( lr_9 ) != inet6Address . lastIndexOf ( lr_9 ) ) ) { return false ; } if ( ( inet6Address . startsWith ( lr_10 ) && ! inet6Address . startsWith ( lr_9 ) ) MST[NonVoidMethodCallMutator]MSP[N]
if ( path == null || path . indexOf ( WINDOWS_SEPARATOR ) == NOT_FOUND ) { return path ; } return path . replace ( WINDOWS_SEPARATOR , UNIX_SEPARATOR ) ; MST[rv.CRCR2Mutator]MSP[N] } public static String separatorsToWindows ( final String path ) {
final int lastSeparator = indexOfLastSeparator ( fileName ) ; return lastSeparator > extensionPos ? NOT_FOUND : extensionPos ; MST[rv.CRCR2Mutator]MSP[N] } public static String getPrefix ( final String fileName ) { if ( fileName == null ) { return null ; } final int len = getPrefixLength ( fileName ) ;
if ( array [ j ] == separator ) { System . arraycopy ( array , i + 1 , array , j + 1 , size - i ) ; size -= i - j ; i = j + 1 ; MST[rv.UOI3Mutator]MSP[N] continue outer; } }
if ( size <= prefix ) { return new String ( array , 0 , size ) ; MST[rv.UOI4Mutator]MSP[N] } if ( lastIsDirectory && keepSeparator ) { return new String ( array , 0 , size ) ; }
for ( int i = 0 ; i < parts . length ; i ++ ) { MST[rv.UOI1Mutator]MSP[N] if ( parts [ i ] . length () == 0 ) { return i == parts . length - 1 ; }
if ( repeat >= 0 ) { backtrack . push ( new int [] { wcsIdx , repeat } ) ; MST[rv.CRCR1Mutator]MSP[S] } } else { if ( ! caseSensitivity . checkRegionMatches ( fileName , textIdx , wcs [ wcsIdx ] ) ) { break; } }
for ( int i = prefix + 1 ; i < size ; i ++ ) { MST[rv.UOI3Mutator]MSP[N] if ( array [ i ] == separator && array [ i - 1 ] == '.' &&
if ( array [ i ] == separator && array [ i - 1 ] == '.' && array [ i - 2 ] == '.' && MST[rv.CRCR2Mutator]MSP[N] ( i == prefix + 2 || array [ i - 3 ] == separator ) ) {
for ( int i = 0 ; i < array . length ; i ++ ) { MST[NegateConditionalsMutator]MSP[N] if ( array [ i ] == otherSeparator ) { array [ i ] = separator ; } } boolean lastIsDirectory = true ;
return caseSensitivity . checkEquals ( fileName1 , fileName2 ) ; } public static boolean isExtension ( final String fileName , final String extension ) { if ( fileName == null ) { MST[rv.ROR5Mutator]MSP[N] return false ; } failIfNullBytePresent ( fileName ) ;
final char ch1 = fileName . charAt ( 1 ) ; if ( ch1 == ':' ) { ch0 = Character . toUpperCase ( ch0 ) ; if ( ch0 >= 'A' && ch0 <= 'Z' ) { MST[rv.ROR5Mutator]MSP[N]
if ( ! isIPv4Address ( octet ) ) { return false ; } validOctets += 2 ; continue; } if ( octet . length () > IPV6_MAX_HEX_DIGITS_PER_GROUP ) { return false ; MST[InlineConstantMutator]MSP[N] } int octetInt = 0 ; try {
|| ( inet6Address . endsWith ( lr_10 ) && ! inet6Address . endsWith ( lr_9 ) ) ) { MST[rv.ROR5Mutator]MSP[N] return false ; } String [] octets = inet6Address . split ( lr_10 ) ; if ( containsCompressedZeroes ) {
octetInt = Integer . parseInt ( octet , BASE_16 ) ; } catch ( final NumberFormatException e ) { return false ; } if ( octetInt < 0 || octetInt > MAX_UNSIGNED_SHORT ) { MST[rv.ROR2Mutator]MSP[N] return false ; } } validOctets ++ ; }
return equals ( fileName1 , fileName2 , true , IOCase . SENSITIVE ) ; } public static boolean equalsNormalizedOnSystem ( final String fileName1 , final String fileName2 ) { return equals ( fileName1 , fileName2 , true , IOCase . SYSTEM ) ; MST[rv.CRCR6Mutator]MSP[S] } public static boolean equals (
return doNormalize ( fileName , SYSTEM_SEPARATOR , true ) ; } public static String normalize ( final String fileName , final boolean unixSeparator ) { final char separator = unixSeparator ? UNIX_SEPARATOR : WINDOWS_SEPARATOR ; return doNormalize ( fileName , separator , true ) ; MST[rv.UOI1Mutator]MSP[S] }
if ( array [ j ] == separator ) { System . arraycopy ( array , i + 1 , array , j + 1 , size - i ) ; size -= i - j ; MST[rv.AOR1Mutator]MSP[N] i = j + 1 ; continue outer; } }
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2 ) { return NOT_FOUND ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ; MST[rv.CRCR1Mutator]MSP[N]
final List < String > octetList = new ArrayList <> ( Arrays . asList ( octets ) ) ; if ( inet6Address . endsWith ( lr_9 ) ) { MST[NegateConditionalsMutator]MSP[N] octetList . add ( lr_11 ) ;
} else if ( inet6Address . startsWith ( lr_9 ) && ! octetList . isEmpty () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] octetList . remove ( 0 ) ; } octets = octetList . toArray ( new String [ octetList . size () ] ) ; }
if ( array [ i ] == separator && array [ i - 1 ] == '.' && array [ i - 2 ] == '.' && MST[rv.ROR5Mutator]MSP[N] ( i == prefix + 2 || array [ i - 3 ] == separator ) ) {
return isSeparator ( ch0 ) ? 1 : 0 ; } if ( ch0 == '~' ) { int posUnix = fileName . indexOf ( UNIX_SEPARATOR , 1 ) ; int posWin = fileName . indexOf ( WINDOWS_SEPARATOR , 1 ) ; MST[InlineConstantMutator]MSP[N]
final char [] array = new char [ size + 2 ] ; MST[rv.CRCR6Mutator]MSP[N] fileName . getChars ( 0 , fileName . length () , array , 0 ) ; final char otherSeparator = separator == SYSTEM_SEPARATOR ? OTHER_SEPARATOR : SYSTEM_SEPARATOR ;
if ( array [ j ] == separator ) { System . arraycopy ( array , i + 1 , array , j + 1 , size - i ) ; size -= i - j ; i = j + 1 ; MST[rv.AOR2Mutator]MSP[N] continue outer; } }
if ( array [ i ] == separator && array [ i - 1 ] == '.' && array [ i - 2 ] == '.' && MST[rv.UOI4Mutator]MSP[N] ( i == prefix + 2 || array [ i - 3 ] == separator ) ) {
if ( ipSegment . length () > 1 && ipSegment . startsWith ( lr_8 ) ) { return false ; } } return true ; MST[InlineConstantMutator]MSP[S] } private static boolean isIPv6Address ( final String inet6Address ) { final boolean containsCompressedZeroes = inet6Address . contains ( lr_9 ) ;
private static String doGetPath ( final String fileName , final int separatorAdd ) { if ( fileName == null ) { return null ; } final int prefix = getPrefixLength ( fileName ) ; if ( prefix < 0 ) { return null ; MST[EmptyObjectReturnValsMutator]MSP[N] }
return isSeparator ( ch0 ) ? 1 : 0 ; } if ( ch0 == '~' ) { int posUnix = fileName . indexOf ( UNIX_SEPARATOR , 1 ) ; int posWin = fileName . indexOf ( WINDOWS_SEPARATOR , 1 ) ; MST[rv.CRCR3Mutator]MSP[N]
if ( array [ j ] == separator ) { System . arraycopy ( array , i + 1 , array , j + 1 , size - i ) ; MST[rv.UOI3Mutator]MSP[N] size -= i - j ; i = j + 1 ; continue outer; } }
if ( path == null || path . indexOf ( WINDOWS_SEPARATOR ) == NOT_FOUND ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] return path ; } return path . replace ( WINDOWS_SEPARATOR , UNIX_SEPARATOR ) ; } public static String separatorsToWindows ( final String path ) {
return isSeparator ( ch0 ) ? 1 : 0 ; } if ( ch0 == '~' ) { MST[NegateConditionalsMutator]MSP[N] int posUnix = fileName . indexOf ( UNIX_SEPARATOR , 1 ) ; int posWin = fileName . indexOf ( WINDOWS_SEPARATOR , 1 ) ;
if ( ch == '?' || ch == '*' ) { MST[rv.ROR1Mutator]MSP[N] if ( buffer . length () != 0 ) { list . add ( buffer . toString () ) ; buffer . setLength ( 0 ) ; } if ( ch == '?' ) {
if ( array [ i ] == separator && array [ i - 1 ] == '.' && array [ i - 2 ] == '.' && MST[rv.AOR3Mutator]MSP[N] ( i == prefix + 2 || array [ i - 3 ] == separator ) ) {
return null ; } return isSystemWindows () ? separatorsToWindows ( path ) : separatorsToUnix ( path ) ; } public static int getPrefixLength ( final String fileName ) { if ( fileName == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return NOT_FOUND ; } final int len = fileName . length () ;
int size = fileName . length () ; if ( size == 0 ) { return fileName ; } final int prefix = getPrefixLength ( fileName ) ; if ( prefix < 0 ) { return null ; MST[EmptyObjectReturnValsMutator]MSP[N] }
public static String getExtension ( final String fileName ) throws IllegalArgumentException { if ( fileName == null ) { MST[rv.ROR5Mutator]MSP[N] return null ; } final int index = indexOfExtension ( fileName ) ; if ( index == NOT_FOUND ) { return EMPTY_STRING ; }
textIdx += wcs [ wcsIdx ] . length () ; anyChars = false ; } wcsIdx ++ ; } if ( wcsIdx == wcs . length && textIdx == fileName . length () ) { return true ; MST[rv.CRCR6Mutator]MSP[N] } } while ( backtrack . size () > 0 );
if ( ipSegment . length () > 1 && ipSegment . startsWith ( lr_8 ) ) { return false ; MST[BooleanTrueReturnValsMutator]MSP[N] } } return true ; } private static boolean isIPv6Address ( final String inet6Address ) { final boolean containsCompressedZeroes = inet6Address . contains ( lr_9 ) ;
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND ) { return len + 1 ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ; MST[InlineConstantMutator]MSP[N] return Math . min ( posUnix , posWin ) + 1 ; }
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2 ) { MST[rv.CRCR2Mutator]MSP[N] return NOT_FOUND ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ;
if ( path == null || path . indexOf ( UNIX_SEPARATOR ) == NOT_FOUND ) { MST[rv.ROR5Mutator]MSP[N] return path ; } return path . replace ( UNIX_SEPARATOR , WINDOWS_SEPARATOR ) ; } public static String separatorsToSystem ( final String path ) { if ( path == null ) {
final int index = indexOfLastSeparator ( fileName ) ; if ( index < 0 ) { return fileName . substring ( 0 , prefix ) ; MST[EmptyObjectReturnValsMutator]MSP[N] } int end = index + ( includeSeparator ? 1 : 0 ) ; if ( end == 0 ) { end ++ ;
textIdx += wcs [ wcsIdx ] . length () ; anyChars = false ; } wcsIdx ++ ; } if ( wcsIdx == wcs . length && textIdx == fileName . length () ) { MST[rv.ROR1Mutator]MSP[N] return true ; } } while ( backtrack . size () > 0 );
System . arraycopy ( array , i + 1 , array , prefix , size - i ) ; size -= i + 1 - prefix ; MST[rv.CRCR3Mutator]MSP[N] i = prefix + 1 ; } } if ( size <= 0 ) { return EMPTY_STRING ; }
if ( ch == '?' || ch == '*' ) { if ( buffer . length () != 0 ) { MST[NonVoidMethodCallMutator]MSP[N] list . add ( buffer . toString () ) ; buffer . setLength ( 0 ) ; } if ( ch == '?' ) {
private static boolean isIPv4Address ( final String name ) { final Matcher m = IPV4_PATTERN . matcher ( name ) ; if ( ! m . matches () || m . groupCount () != 4 ) { return false ; MST[rv.CRCR6Mutator]MSP[N] }
final char ch = basePath . charAt ( len - 1 ) ; if ( isSeparator ( ch ) ) { MST[rv.UOI3Mutator]MSP[S] return normalize ( basePath + fullFileNameToAdd ) ; } return normalize ( basePath + '/' + fullFileNameToAdd ) ; }
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2 ) { MST[NegateConditionalsMutator]MSP[N] return NOT_FOUND ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ;
final int index = indexOfLastSeparator ( fileName ) ; final int endIndex = index + separatorAdd ; MST[rv.AOR1Mutator]MSP[S] if ( prefix >= fileName . length () || index < 0 || prefix >= endIndex ) { return EMPTY_STRING ; }
if ( len == 0 ) { return 0 ; } char ch0 = fileName . charAt ( 0 ) ; if ( ch0 == ':' ) { return NOT_FOUND ; } if ( len == 1 ) { if ( ch0 == '~' ) { return 2 ; MST[rv.CRCR2Mutator]MSP[N] }
textIdx += wcs [ wcsIdx ] . length () ; anyChars = false ; } wcsIdx ++ ; } if ( wcsIdx == wcs . length && textIdx == fileName . length () ) { MST[rv.ROR4Mutator]MSP[N] return true ; } } while ( backtrack . size () > 0 );
private static boolean isIPv4Address ( final String name ) { final Matcher m = IPV4_PATTERN . matcher ( name ) ; if ( ! m . matches () || m . groupCount () != 4 ) { MST[NegateConditionalsMutator]MSP[N] return false ; }
String fileName1 , String fileName2 , final boolean normalized , IOCase caseSensitivity ) { if ( fileName1 == null || fileName2 == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return fileName1 == null && fileName2 == null ; } if ( normalized ) { fileName1 = normalize ( fileName1 ) ;
return isSeparator ( ch0 ) ? 1 : 0 ; MST[rv.CRCR6Mutator]MSP[N] } if ( ch0 == '~' ) { int posUnix = fileName . indexOf ( UNIX_SEPARATOR , 1 ) ; int posWin = fileName . indexOf ( WINDOWS_SEPARATOR , 1 ) ;
public static boolean isExtension ( final String fileName , final String ... extensions ) { if ( fileName == null ) { return false ; } failIfNullBytePresent ( fileName ) ; if ( extensions == null || extensions . length == 0 ) { MST[rv.ROR5Mutator]MSP[N]
octetInt = Integer . parseInt ( octet , BASE_16 ) ; } catch ( final NumberFormatException e ) { return false ; } if ( octetInt < 0 || octetInt > MAX_UNSIGNED_SHORT ) { MST[rv.UOI1Mutator]MSP[N] return false ; } } validOctets ++ ; }
if ( len == 2 || isSeparator ( fileName . charAt ( 2 ) ) == false ) { return 2 ; } return 3 ; } else if ( ch0 == UNIX_SEPARATOR ) { MST[rv.CRCR4Mutator]MSP[N] return 1 ; } return NOT_FOUND ;
static boolean isSystemWindows () { return SYSTEM_SEPARATOR == WINDOWS_SEPARATOR ; } private static boolean isSeparator ( final char ch ) { return ch == UNIX_SEPARATOR || ch == WINDOWS_SEPARATOR ; MST[rv.CRCR5Mutator]MSP[N] } public static String normalize ( final String fileName ) {
for ( int i = prefix + 1 ; i < size ; i ++ ) { if ( array [ i ] == separator && array [ i - 1 ] == '.' && MST[rv.UOI3Mutator]MSP[N]
final char ch1 = fileName . charAt ( 1 ) ; if ( ch1 == ':' ) { ch0 = Character . toUpperCase ( ch0 ) ; MST[rv.UOI2Mutator]MSP[S] if ( ch0 >= 'A' && ch0 <= 'Z' ) {
return isSeparator ( ch0 ) ? 1 : 0 ; } } public static int indexOfLastSeparator ( final String fileName ) { if ( fileName == null ) { return NOT_FOUND ; MST[rv.CRCR4Mutator]MSP[N] } final int lastUnixPos = fileName . lastIndexOf ( UNIX_SEPARATOR ) ;
if ( ch == '?' || ch == '*' ) { if ( buffer . length () != 0 ) { list . add ( buffer . toString () ) ; buffer . setLength ( 0 ) ; } if ( ch == '?' ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
System . arraycopy ( array , i + 1 , array , i - 1 , size - i ) ; MST[rv.CRCR3Mutator]MSP[N] size -= 2 ; i -- ; } } outer: for ( int i = prefix + 2 ; i < size ; i ++ ) {
return false ; } static String [] splitOnTokens ( final String text ) { if ( text . indexOf ( '?' ) == NOT_FOUND && text . indexOf ( '*' ) == NOT_FOUND ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return new String [] { text } ; }
if ( array [ i ] == separator && array [ i - 1 ] == separator ) { System . arraycopy ( array , i , array , i - 1 , size - i ) ; MST[rv.UOI4Mutator]MSP[N] size -- ; i -- ; } }
System . arraycopy ( array , i + 1 , array , prefix , size - i ) ; size -= i + 1 - prefix ; MST[MathMutator]MSP[N] i = prefix + 1 ; } } if ( size <= 0 ) { return EMPTY_STRING ; }
if ( array [ i ] == separator && array [ i - 1 ] == '.' && array [ i - 2 ] == '.' && MST[rv.AOD1Mutator]MSP[N] ( i == prefix + 2 || array [ i - 3 ] == separator ) ) {
if ( fileName == null || wildcardMatcher == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return false ; } if ( caseSensitivity == null ) { caseSensitivity = IOCase . SENSITIVE ; } final String [] wcs = splitOnTokens ( wildcardMatcher ) ; boolean anyChars = false ; int textIdx = 0 ;
System . arraycopy ( array , i + 1 , array , i - 1 , size - i ) ; MST[rv.ABSMutator]MSP[N] size -= 2 ; i -- ; } } outer: for ( int i = prefix + 2 ; i < size ; i ++ ) {
return isSeparator ( ch0 ) ? 1 : 0 ; } if ( ch0 == '~' ) { MST[rv.ROR5Mutator]MSP[N] int posUnix = fileName . indexOf ( UNIX_SEPARATOR , 1 ) ; int posWin = fileName . indexOf ( WINDOWS_SEPARATOR , 1 ) ;
final int lastWindowsPos = fileName . lastIndexOf ( WINDOWS_SEPARATOR ) ; MST[NonVoidMethodCallMutator]MSP[N] return Math . max ( lastUnixPos , lastWindowsPos ) ; } public static int indexOfExtension ( final String fileName ) throws IllegalArgumentException { if ( fileName == null ) { return NOT_FOUND ; }
public static String normalizeNoEndSeparator ( final String fileName ) { return doNormalize ( fileName , SYSTEM_SEPARATOR , false ) ; MST[InlineConstantMutator]MSP[S] } public static String normalizeNoEndSeparator ( final String fileName , final boolean unixSeparator ) { final char separator = unixSeparator ? UNIX_SEPARATOR : WINDOWS_SEPARATOR ;
if ( path == null || path . indexOf ( UNIX_SEPARATOR ) == NOT_FOUND ) { return path ; MST[ReturnValsMutator]MSP[N] } return path . replace ( UNIX_SEPARATOR , WINDOWS_SEPARATOR ) ; } public static String separatorsToSystem ( final String path ) { if ( path == null ) {
final int pos = Math . min ( posUnix , posWin ) + 1 ; final String hostnamePart = fileName . substring ( 2 , pos - 1 ) ; MST[InlineConstantMutator]MSP[N] return isValidHostName ( hostnamePart ) ? pos : NOT_FOUND ; } else {
( i == prefix + 1 || array [ i - 2 ] == separator ) ) { if ( i == size - 1 ) { MST[rv.AOR3Mutator]MSP[N] lastIsDirectory = true ; }
if ( i == prefix + 2 ) { return null ; } if ( i == size - 1 ) { MST[InlineConstantMutator]MSP[S] lastIsDirectory = true ; } int j ; for ( j = i - 4 ; j >= prefix ; j -- ) {
final char ch = basePath . charAt ( len - 1 ) ; if ( isSeparator ( ch ) ) { return normalize ( basePath + fullFileNameToAdd ) ; MST[NonVoidMethodCallMutator]MSP[N] } return normalize ( basePath + '/' + fullFileNameToAdd ) ; }
for ( int i = prefix + 1 ; i < size ; i ++ ) { if ( array [ i ] == separator && array [ i - 1 ] == '.' && MST[rv.AOD2Mutator]MSP[N]
if ( path == null || path . indexOf ( UNIX_SEPARATOR ) == NOT_FOUND ) { return path ; } return path . replace ( UNIX_SEPARATOR , WINDOWS_SEPARATOR ) ; } public static String separatorsToSystem ( final String path ) { if ( path == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
System . arraycopy ( array , i + 1 , array , i - 1 , size - i ) ; MST[rv.UOI1Mutator]MSP[N] size -= 2 ; i -- ; } } outer: for ( int i = prefix + 2 ; i < size ; i ++ ) {
list . add ( lr_6 ) ; } else if ( prevChar != '*' ) { MST[InlineConstantMutator]MSP[S] list . add ( lr_7 ) ; } } else { buffer . append ( ch ) ; } prevChar = ch ; } if ( buffer . length () != 0 ) {
final char ch = basePath . charAt ( len - 1 ) ; if ( isSeparator ( ch ) ) { return normalize ( basePath + fullFileNameToAdd ) ; } return normalize ( basePath + '/' + fullFileNameToAdd ) ; MST[rv.CRCR1Mutator]MSP[N] }
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2 ) { MST[rv.CRCR6Mutator]MSP[N] return NOT_FOUND ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ;
final int lastSeparator = indexOfLastSeparator ( fileName ) ; return lastSeparator > extensionPos ? NOT_FOUND : extensionPos ; MST[rv.ROR2Mutator]MSP[N] } public static String getPrefix ( final String fileName ) { if ( fileName == null ) { return null ; } final int len = getPrefixLength ( fileName ) ;
anyChars = false ; } else if ( wcs [ wcsIdx ] . equals ( lr_7 ) ) { anyChars = true ; if ( wcsIdx == wcs . length - 1 ) { MST[rv.ABSMutator]MSP[N] textIdx = fileName . length () ; } } else { if ( anyChars ) {
public static String normalizeNoEndSeparator ( final String fileName ) { return doNormalize ( fileName , SYSTEM_SEPARATOR , false ) ; MST[rv.CRCR3Mutator]MSP[S] } public static String normalizeNoEndSeparator ( final String fileName , final boolean unixSeparator ) { final char separator = unixSeparator ? UNIX_SEPARATOR : WINDOWS_SEPARATOR ;
} else if ( inet6Address . startsWith ( lr_9 ) && ! octetList . isEmpty () ) { MST[rv.ROR5Mutator]MSP[N] octetList . remove ( 0 ) ; } octets = octetList . toArray ( new String [ octetList . size () ] ) ; }
failIfNullBytePresent ( path ) ; return path ; } public static String getPath ( final String fileName ) { return doGetPath ( fileName , 1 ) ; } public static String getPathNoEndSeparator ( final String fileName ) { return doGetPath ( fileName , 0 ) ; MST[ArgumentPropagationMutator]MSP[N] }
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND ) { MST[rv.ROR1Mutator]MSP[N] return len + 1 ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ; return Math . min ( posUnix , posWin ) + 1 ; }
public static boolean isExtension ( final String fileName , final Collection < String > extensions ) { if ( fileName == null ) { return false ; } failIfNullBytePresent ( fileName ) ; if ( extensions == null || extensions . isEmpty () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
final String path = fileName . substring ( prefix , endIndex ) ; MST[rv.UOI3Mutator]MSP[N] failIfNullBytePresent ( path ) ; return path ; } public static String getFullPath ( final String fileName ) { return doGetFullPath ( fileName , true ) ; }
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND ) { return len + 1 ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; MST[rv.ROR5Mutator]MSP[N] posWin = posWin == NOT_FOUND ? posUnix : posWin ; return Math . min ( posUnix , posWin ) + 1 ; }
if ( array [ i ] == separator && array [ i - 1 ] == '.' && array [ i - 2 ] == '.' && MST[InlineConstantMutator]MSP[N] ( i == prefix + 2 || array [ i - 3 ] == separator ) ) {
final char ch = basePath . charAt ( len - 1 ) ; MST[rv.AOR1Mutator]MSP[N] if ( isSeparator ( ch ) ) { return normalize ( basePath + fullFileNameToAdd ) ; } return normalize ( basePath + '/' + fullFileNameToAdd ) ; }
return isSeparator ( ch0 ) ? 1 : 0 ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } } public static int indexOfLastSeparator ( final String fileName ) { if ( fileName == null ) { return NOT_FOUND ; } final int lastUnixPos = fileName . lastIndexOf ( UNIX_SEPARATOR ) ;
if ( i == prefix + 2 ) { return null ; } if ( i == size - 1 ) { MST[rv.AOR2Mutator]MSP[S] lastIsDirectory = true ; } int j ; for ( j = i - 4 ; j >= prefix ; j -- ) {
final int prefix = getPrefixLength ( fileName ) ; if ( prefix < 0 ) { return null ; } if ( prefix >= fileName . length () ) { if ( includeSeparator ) { return getPrefix ( fileName ) ; } return fileName ; MST[EmptyObjectReturnValsMutator]MSP[N] }
textIdx = array [ 1 ] ; anyChars = true ; } while ( wcsIdx < wcs . length ) { if ( wcs [ wcsIdx ] . equals ( lr_6 ) ) { textIdx ++ ; if ( textIdx > fileName . length () ) { MST[rv.ROR3Mutator]MSP[N] break; }
if ( len == 2 || isSeparator ( fileName . charAt ( 2 ) ) == false ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return 2 ; } return 3 ; } else if ( ch0 == UNIX_SEPARATOR ) { return 1 ; } return NOT_FOUND ;
final int index = indexOfLastSeparator ( fileName ) ; final int endIndex = index + separatorAdd ; MST[rv.UOI1Mutator]MSP[N] if ( prefix >= fileName . length () || index < 0 || prefix >= endIndex ) { return EMPTY_STRING ; }
System . arraycopy ( array , i + 1 , array , prefix , size - i ) ; size -= i + 1 - prefix ; MST[rv.UOI1Mutator]MSP[N] i = prefix + 1 ; } } if ( size <= 0 ) { return EMPTY_STRING ; }
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND ) { MST[rv.UOI3Mutator]MSP[N] return len + 1 ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ; return Math . min ( posUnix , posWin ) + 1 ; }
final int pos = Math . min ( posUnix , posWin ) + 1 ; MST[rv.ABSMutator]MSP[N] final String hostnamePart = fileName . substring ( 2 , pos - 1 ) ; return isValidHostName ( hostnamePart ) ? pos : NOT_FOUND ; } else {
public static boolean isExtension ( final String fileName , final String ... extensions ) { if ( fileName == null ) { return false ; } failIfNullBytePresent ( fileName ) ; if ( extensions == null || extensions . length == 0 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
|| ( inet6Address . endsWith ( lr_10 ) && ! inet6Address . endsWith ( lr_9 ) ) ) { return false ; MST[rv.CRCR6Mutator]MSP[S] } String [] octets = inet6Address . split ( lr_10 ) ; if ( containsCompressedZeroes ) {
if ( prefix > 0 ) { return normalize ( fullFileNameToAdd ) ; } if ( basePath == null ) { return null ; } final int len = basePath . length () ; if ( len == 0 ) { return normalize ( fullFileNameToAdd ) ; MST[ReturnValsMutator]MSP[N] }
public static boolean wildcardMatch ( final String fileName , final String wildcardMatcher ) { return wildcardMatch ( fileName , wildcardMatcher , IOCase . SENSITIVE ) ; MST[BooleanFalseReturnValsMutator]MSP[N] } public static boolean wildcardMatchOnSystem ( final String fileName , final String wildcardMatcher ) {
if ( octets . length > IPV6_MAX_HEX_GROUPS ) { return false ; } int validOctets = 0 ; int emptyOctets = 0 ; for ( int index = 0 ; index < octets . length ; index ++ ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] final String octet = octets [ index ] ;
for ( int i = prefix + 1 ; i < size ; i ++ ) { if ( array [ i ] == separator && array [ i - 1 ] == '.' && MST[rv.ROR3Mutator]MSP[N]
if ( repeat >= 0 ) { backtrack . push ( new int [] { wcsIdx , repeat } ) ; } } else { if ( ! caseSensitivity . checkRegionMatches ( fileName , textIdx , wcs [ wcsIdx ] ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] break; } }
if ( path . charAt ( i ) == 0 ) { throw new IllegalArgumentException ( lr_3 + lr_4 ) ; } } } public static String getBaseName ( final String fileName ) { return removeExtension ( getName ( fileName ) ) ; MST[NonVoidMethodCallMutator]MSP[N] }
if ( repeat >= 0 ) { backtrack . push ( new int [] { wcsIdx , repeat } ) ; } } else { if ( ! caseSensitivity . checkRegionMatches ( fileName , textIdx , wcs [ wcsIdx ] ) ) { MST[rv.UOI2Mutator]MSP[N] break; } }
if ( path == null || path . indexOf ( WINDOWS_SEPARATOR ) == NOT_FOUND ) { MST[InlineConstantMutator]MSP[N] return path ; } return path . replace ( WINDOWS_SEPARATOR , UNIX_SEPARATOR ) ; } public static String separatorsToWindows ( final String path ) {
System . arraycopy ( array , i + 1 , array , i - 1 , size - i ) ; MST[rv.UOI3Mutator]MSP[N] size -= 2 ; i -- ; } } outer: for ( int i = prefix + 2 ; i < size ; i ++ ) {
textIdx += wcs [ wcsIdx ] . length () ; MST[rv.AOR4Mutator]MSP[N] anyChars = false ; } wcsIdx ++ ; } if ( wcsIdx == wcs . length && textIdx == fileName . length () ) { return true ; } } while ( backtrack . size () > 0 );
for ( int i = prefix + 1 ; i < size ; i ++ ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] if ( array [ i ] == separator && array [ i - 1 ] == '.' &&
final char ch1 = fileName . charAt ( 1 ) ; if ( ch1 == ':' ) { ch0 = Character . toUpperCase ( ch0 ) ; if ( ch0 >= 'A' && ch0 <= 'Z' ) { MST[rv.CRCR4Mutator]MSP[N]
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND ) { return len + 1 ; MST[rv.CRCR5Mutator]MSP[N] } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ; return Math . min ( posUnix , posWin ) + 1 ; }
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND ) { return len + 1 ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ; MST[rv.ROR3Mutator]MSP[N] return Math . min ( posUnix , posWin ) + 1 ; }
if ( prefix > 0 ) { return normalize ( fullFileNameToAdd ) ; MST[NonVoidMethodCallMutator]MSP[N] } if ( basePath == null ) { return null ; } final int len = basePath . length () ; if ( len == 0 ) { return normalize ( fullFileNameToAdd ) ; }
for ( int i = prefix + 1 ; i < size ; i ++ ) { if ( array [ i ] == separator && array [ i - 1 ] == '.' && MST[rv.CRCR3Mutator]MSP[N]
return false ; } static String [] splitOnTokens ( final String text ) { if ( text . indexOf ( '?' ) == NOT_FOUND && text . indexOf ( '*' ) == NOT_FOUND ) { MST[rv.CRCR5Mutator]MSP[N] return new String [] { text } ; }
static boolean isSystemWindows () { return SYSTEM_SEPARATOR == WINDOWS_SEPARATOR ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } private static boolean isSeparator ( final char ch ) { return ch == UNIX_SEPARATOR || ch == WINDOWS_SEPARATOR ; } public static String normalize ( final String fileName ) {
if ( validOctets > IPV6_MAX_HEX_GROUPS || ( validOctets < IPV6_MAX_HEX_GROUPS && ! containsCompressedZeroes ) ) { MST[rv.CRCR2Mutator]MSP[S] return false ; } return true ; } private static boolean isRFC3986HostName ( final String name ) { final String [] parts = name . split ( lr_13 , - 1 ) ;
if ( array [ size - 1 ] != separator ) { array [ size ++ ] = separator ; MST[rv.UOI2Mutator]MSP[N] lastIsDirectory = false ; } for ( int i = prefix + 1 ; i < size ; i ++ ) {
if ( ipSegment . length () > 1 && ipSegment . startsWith ( lr_8 ) ) { return false ; } } return true ; MST[rv.CRCR3Mutator]MSP[N] } private static boolean isIPv6Address ( final String inet6Address ) { final boolean containsCompressedZeroes = inet6Address . contains ( lr_9 ) ;
return isSeparator ( ch0 ) ? 1 : 0 ; } } public static int indexOfLastSeparator ( final String fileName ) { if ( fileName == null ) { MST[NegateConditionalsMutator]MSP[N] return NOT_FOUND ; } final int lastUnixPos = fileName . lastIndexOf ( UNIX_SEPARATOR ) ;
if ( ipSegment . length () > 1 && ipSegment . startsWith ( lr_8 ) ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[S] return false ; } } return true ; } private static boolean isIPv6Address ( final String inet6Address ) { final boolean containsCompressedZeroes = inet6Address . contains ( lr_9 ) ;
final int prefix = getPrefixLength ( fileName ) ; if ( prefix < 0 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] return null ; } if ( prefix >= fileName . length () ) { if ( includeSeparator ) { return getPrefix ( fileName ) ; } return fileName ; }
if ( len == 2 || isSeparator ( fileName . charAt ( 2 ) ) == false ) { return 2 ; } return 3 ; MST[ReturnValsMutator]MSP[N] } else if ( ch0 == UNIX_SEPARATOR ) { return 1 ; } return NOT_FOUND ;
final int index = indexOfLastSeparator ( fileName ) ; final int endIndex = index + separatorAdd ; if ( prefix >= fileName . length () || index < 0 || prefix >= endIndex ) { MST[NegateConditionalsMutator]MSP[N] return EMPTY_STRING ; }
for ( int i = 0 ; i < parts . length ; i ++ ) { if ( parts [ i ] . length () == 0 ) { return i == parts . length - 1 ; MST[InlineConstantMutator]MSP[N] }
if ( array [ j ] == separator ) { System . arraycopy ( array , i + 1 , array , j + 1 , size - i ) ; MST[InlineConstantMutator]MSP[N] size -= i - j ; i = j + 1 ; continue outer; } }
final char ch = basePath . charAt ( len - 1 ) ; MST[rv.ABSMutator]MSP[N] if ( isSeparator ( ch ) ) { return normalize ( basePath + fullFileNameToAdd ) ; } return normalize ( basePath + '/' + fullFileNameToAdd ) ; }
if ( containsCompressedZeroes && ( inet6Address . indexOf ( lr_9 ) != inet6Address . lastIndexOf ( lr_9 ) ) ) { MST[rv.UOI1Mutator]MSP[S] return false ; } if ( ( inet6Address . startsWith ( lr_10 ) && ! inet6Address . startsWith ( lr_9 ) )
textIdx = caseSensitivity . checkIndexOf ( fileName , textIdx , wcs [ wcsIdx ] ) ; if ( textIdx == NOT_FOUND ) { MST[rv.ROR5Mutator]MSP[N] break; } final int repeat = caseSensitivity . checkIndexOf ( fileName , textIdx + 1 , wcs [ wcsIdx ] ) ;
final char ch = basePath . charAt ( len - 1 ) ; MST[rv.CRCR2Mutator]MSP[N] if ( isSeparator ( ch ) ) { return normalize ( basePath + fullFileNameToAdd ) ; } return normalize ( basePath + '/' + fullFileNameToAdd ) ; }
if ( validOctets > IPV6_MAX_HEX_GROUPS || ( validOctets < IPV6_MAX_HEX_GROUPS && ! containsCompressedZeroes ) ) { MST[rv.ABSMutator]MSP[N] return false ; } return true ; } private static boolean isRFC3986HostName ( final String name ) { final String [] parts = name . split ( lr_13 , - 1 ) ;
} else if ( isSeparator ( ch0 ) && isSeparator ( ch1 ) ) { int posUnix = fileName . indexOf ( UNIX_SEPARATOR , 2 ) ; int posWin = fileName . indexOf ( WINDOWS_SEPARATOR , 2 ) ; MST[rv.CRCR6Mutator]MSP[N]
if ( extension == null || extension . isEmpty () ) { return indexOfExtension ( fileName ) == NOT_FOUND ; MST[NonVoidMethodCallMutator]MSP[N] } final String fileExt = getExtension ( fileName ) ; return fileExt . equals ( extension ) ; }
for ( int i = 1 ; i <= 4 ; i ++ ) { MST[rv.ROR5Mutator]MSP[N] final String ipSegment = m . group ( i ) ; final int iIpSegment = Integer . parseInt ( ipSegment ) ; if ( iIpSegment > IPV4_MAX_OCTET_VALUE ) { return false ; }
list . add ( lr_6 ) ; } else if ( prevChar != '*' ) { list . add ( lr_7 ) ; } } else { buffer . append ( ch ) ; } prevChar = ch ; MST[rv.UOI1Mutator]MSP[N] } if ( buffer . length () != 0 ) {
final char ch1 = fileName . charAt ( 1 ) ; if ( ch1 == ':' ) { MST[rv.CRCR1Mutator]MSP[N] ch0 = Character . toUpperCase ( ch0 ) ; if ( ch0 >= 'A' && ch0 <= 'Z' ) {
( i == prefix + 1 || array [ i - 2 ] == separator ) ) { if ( i == size - 1 ) { MST[rv.ROR4Mutator]MSP[N] lastIsDirectory = true ; }
textIdx = array [ 1 ] ; MST[rv.UOI3Mutator]MSP[N] anyChars = true ; } while ( wcsIdx < wcs . length ) { if ( wcs [ wcsIdx ] . equals ( lr_6 ) ) { textIdx ++ ; if ( textIdx > fileName . length () ) { break; }
if ( prefix > 0 ) { MST[rv.UOI1Mutator]MSP[N] return normalize ( fullFileNameToAdd ) ; } if ( basePath == null ) { return null ; } final int len = basePath . length () ; if ( len == 0 ) { return normalize ( fullFileNameToAdd ) ; }
return isSeparator ( ch0 ) ? 1 : 0 ; } } public static int indexOfLastSeparator ( final String fileName ) { if ( fileName == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return NOT_FOUND ; } final int lastUnixPos = fileName . lastIndexOf ( UNIX_SEPARATOR ) ;
return caseSensitivity . checkEquals ( fileName1 , fileName2 ) ; MST[BooleanFalseReturnValsMutator]MSP[N] } public static boolean isExtension ( final String fileName , final String extension ) { if ( fileName == null ) { return false ; } failIfNullBytePresent ( fileName ) ;
return new String ( array , 0 , size - 1 ) ; MST[rv.AOR2Mutator]MSP[N] } public static String concat ( final String basePath , final String fullFileNameToAdd ) { final int prefix = getPrefixLength ( fullFileNameToAdd ) ; if ( prefix < 0 ) { return null ; }
if ( path == null || path . indexOf ( WINDOWS_SEPARATOR ) == NOT_FOUND ) { return path ; } return path . replace ( WINDOWS_SEPARATOR , UNIX_SEPARATOR ) ; MST[rv.CRCR1Mutator]MSP[N] } public static String separatorsToWindows ( final String path ) {
if ( ! isIPv4Address ( octet ) ) { return false ; } validOctets += 2 ; continue; } if ( octet . length () > IPV6_MAX_HEX_DIGITS_PER_GROUP ) { return false ; } int octetInt = 0 ; MST[rv.CRCR6Mutator]MSP[N] try {
( i == prefix + 1 || array [ i - 2 ] == separator ) ) { if ( i == size - 1 ) { MST[rv.AOD2Mutator]MSP[N] lastIsDirectory = true ; }
final int pos = Math . min ( posUnix , posWin ) + 1 ; MST[rv.UOI3Mutator]MSP[N] final String hostnamePart = fileName . substring ( 2 , pos - 1 ) ; return isValidHostName ( hostnamePart ) ? pos : NOT_FOUND ; } else {
final int index = indexOfLastSeparator ( fileName ) ; final int endIndex = index + separatorAdd ; if ( prefix >= fileName . length () || index < 0 || prefix >= endIndex ) { MST[rv.ROR5Mutator]MSP[S] return EMPTY_STRING ; }
if ( repeat >= 0 ) { backtrack . push ( new int [] { wcsIdx , repeat } ) ; MST[rv.CRCR2Mutator]MSP[S] } } else { if ( ! caseSensitivity . checkRegionMatches ( fileName , textIdx , wcs [ wcsIdx ] ) ) { break; } }
if ( octets . length > IPV6_MAX_HEX_GROUPS ) { return false ; } int validOctets = 0 ; int emptyOctets = 0 ; MST[InlineConstantMutator]MSP[N] for ( int index = 0 ; index < octets . length ; index ++ ) { final String octet = octets [ index ] ;
if ( i == prefix + 2 ) { return null ; } if ( i == size - 1 ) { lastIsDirectory = true ; } int j ; for ( j = i - 4 ; j >= prefix ; j -- ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N]
if ( i == prefix + 2 ) { MST[MathMutator]MSP[N] return null ; } if ( i == size - 1 ) { lastIsDirectory = true ; } int j ; for ( j = i - 4 ; j >= prefix ; j -- ) {
for ( int i = 0 ; i < parts . length ; i ++ ) { if ( parts [ i ] . length () == 0 ) { return i == parts . length - 1 ; MST[rv.CRCR3Mutator]MSP[N] }
if ( array [ j ] == separator ) { System . arraycopy ( array , i + 1 , array , j + 1 , size - i ) ; MST[VoidMethodCallMutator]MSP[N] size -= i - j ; i = j + 1 ; continue outer; } }
final int prefix = getPrefixLength ( fileName ) ; if ( prefix < 0 ) { return null ; } if ( prefix >= fileName . length () ) { if ( includeSeparator ) { MST[rv.UOI2Mutator]MSP[N] return getPrefix ( fileName ) ; } return fileName ; }
if ( array [ j ] == separator ) { MST[rv.UOI4Mutator]MSP[N] System . arraycopy ( array , i + 1 , array , j + 1 , size - i ) ; size -= i - j ; i = j + 1 ; continue outer; } }
if ( len < 0 ) { return null ; } if ( len > fileName . length () ) { failIfNullBytePresent ( fileName + UNIX_SEPARATOR ) ; MST[rv.CRCR6Mutator]MSP[N] return fileName + UNIX_SEPARATOR ; } final String path = fileName . substring ( 0 , len ) ;
public static String normalizeNoEndSeparator ( final String fileName ) { return doNormalize ( fileName , SYSTEM_SEPARATOR , false ) ; } public static String normalizeNoEndSeparator ( final String fileName , final boolean unixSeparator ) { final char separator = unixSeparator ? UNIX_SEPARATOR : WINDOWS_SEPARATOR ; MST[InlineConstantMutator]MSP[S]
final char ch1 = fileName . charAt ( 1 ) ; if ( ch1 == ':' ) { ch0 = Character . toUpperCase ( ch0 ) ; if ( ch0 >= 'A' && ch0 <= 'Z' ) { MST[ConditionalsBoundaryMutator]MSP[S]
return isSeparator ( ch0 ) ? 1 : 0 ; } } public static int indexOfLastSeparator ( final String fileName ) { if ( fileName == null ) { return NOT_FOUND ; MST[rv.CRCR5Mutator]MSP[N] } final int lastUnixPos = fileName . lastIndexOf ( UNIX_SEPARATOR ) ;
return new String ( array , 0 , size - 1 ) ; } public static String concat ( final String basePath , final String fullFileNameToAdd ) { final int prefix = getPrefixLength ( fullFileNameToAdd ) ; if ( prefix < 0 ) { MST[rv.ROR4Mutator]MSP[N] return null ; }
System . arraycopy ( array , i + 1 , array , i - 1 , size - i ) ; MST[rv.CRCR2Mutator]MSP[N] size -= 2 ; i -- ; } } outer: for ( int i = prefix + 2 ; i < size ; i ++ ) {
|| ( inet6Address . endsWith ( lr_10 ) && ! inet6Address . endsWith ( lr_9 ) ) ) { return false ; } String [] octets = inet6Address . split ( lr_10 ) ; if ( containsCompressedZeroes ) { MST[rv.ABSMutator]MSP[N]
if ( i == prefix + 2 ) { return null ; } if ( i == size - 1 ) { MST[rv.AOD1Mutator]MSP[S] lastIsDirectory = true ; } int j ; for ( j = i - 4 ; j >= prefix ; j -- ) {
if ( fileName == null || wildcardMatcher == null ) { return false ; MST[rv.CRCR5Mutator]MSP[N] } if ( caseSensitivity == null ) { caseSensitivity = IOCase . SENSITIVE ; } final String [] wcs = splitOnTokens ( wildcardMatcher ) ; boolean anyChars = false ; int textIdx = 0 ;
if ( i == prefix + 2 ) { MST[rv.AOR4Mutator]MSP[N] return null ; } if ( i == size - 1 ) { lastIsDirectory = true ; } int j ; for ( j = i - 4 ; j >= prefix ; j -- ) {
return new String ( array , 0 , size - 1 ) ; } public static String concat ( final String basePath , final String fullFileNameToAdd ) { final int prefix = getPrefixLength ( fullFileNameToAdd ) ; if ( prefix < 0 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] return null ; }
if ( array [ j ] == separator ) { MST[rv.ROR5Mutator]MSP[N] System . arraycopy ( array , i + 1 , array , j + 1 , size - i ) ; size -= i - j ; i = j + 1 ; continue outer; } }
list . add ( lr_6 ) ; } else if ( prevChar != '*' ) { list . add ( lr_7 ) ; } } else { buffer . append ( ch ) ; } prevChar = ch ; } if ( buffer . length () != 0 ) { MST[rv.ROR1Mutator]MSP[N]
if ( len == 0 ) { return 0 ; MST[rv.CRCR6Mutator]MSP[N] } char ch0 = fileName . charAt ( 0 ) ; if ( ch0 == ':' ) { return NOT_FOUND ; } if ( len == 1 ) { if ( ch0 == '~' ) { return 2 ; }
for ( int i = 0 ; i < parts . length ; i ++ ) { if ( parts [ i ] . length () == 0 ) { return i == parts . length - 1 ; MST[rv.AOR3Mutator]MSP[N] }
if ( len < 0 ) { MST[rv.ROR2Mutator]MSP[N] return null ; } if ( len > fileName . length () ) { failIfNullBytePresent ( fileName + UNIX_SEPARATOR ) ; return fileName + UNIX_SEPARATOR ; } final String path = fileName . substring ( 0 , len ) ;
final char ch = basePath . charAt ( len - 1 ) ; MST[InlineConstantMutator]MSP[N] if ( isSeparator ( ch ) ) { return normalize ( basePath + fullFileNameToAdd ) ; } return normalize ( basePath + '/' + fullFileNameToAdd ) ; }
final char [] array = new char [ size + 2 ] ; fileName . getChars ( 0 , fileName . length () , array , 0 ) ; MST[rv.CRCR3Mutator]MSP[N] final char otherSeparator = separator == SYSTEM_SEPARATOR ? OTHER_SEPARATOR : SYSTEM_SEPARATOR ;
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2 ) { return NOT_FOUND ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ; MST[rv.ROR1Mutator]MSP[N]
if ( path == null || path . indexOf ( UNIX_SEPARATOR ) == NOT_FOUND ) { return path ; } return path . replace ( UNIX_SEPARATOR , WINDOWS_SEPARATOR ) ; MST[rv.CRCR4Mutator]MSP[N] } public static String separatorsToSystem ( final String path ) { if ( path == null ) {
textIdx = caseSensitivity . checkIndexOf ( fileName , textIdx , wcs [ wcsIdx ] ) ; if ( textIdx == NOT_FOUND ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] break; } final int repeat = caseSensitivity . checkIndexOf ( fileName , textIdx + 1 , wcs [ wcsIdx ] ) ;
octetInt = Integer . parseInt ( octet , BASE_16 ) ; } catch ( final NumberFormatException e ) { return false ; MST[rv.CRCR6Mutator]MSP[S] } if ( octetInt < 0 || octetInt > MAX_UNSIGNED_SHORT ) { return false ; } } validOctets ++ ; }
if ( prefix > 0 ) { return normalize ( fullFileNameToAdd ) ; } if ( basePath == null ) { return null ; } final int len = basePath . length () ; if ( len == 0 ) { MST[NegateConditionalsMutator]MSP[N] return normalize ( fullFileNameToAdd ) ; }
if ( len < 0 ) { return null ; } if ( len > fileName . length () ) { failIfNullBytePresent ( fileName + UNIX_SEPARATOR ) ; MST[experimental.NakedReceiverMutator]MSP[N] return fileName + UNIX_SEPARATOR ; } final String path = fileName . substring ( 0 , len ) ;
return false ; } static String [] splitOnTokens ( final String text ) { if ( text . indexOf ( '?' ) == NOT_FOUND && text . indexOf ( '*' ) == NOT_FOUND ) { return new String [] { text } ; MST[NullReturnValsMutator]MSP[N] }
return isSeparator ( ch0 ) ? 1 : 0 ; MST[NonVoidMethodCallMutator]MSP[N] } } public static int indexOfLastSeparator ( final String fileName ) { if ( fileName == null ) { return NOT_FOUND ; } final int lastUnixPos = fileName . lastIndexOf ( UNIX_SEPARATOR ) ;
if ( len == 2 || isSeparator ( fileName . charAt ( 2 ) ) == false ) { MST[rv.ROR3Mutator]MSP[N] return 2 ; } return 3 ; } else if ( ch0 == UNIX_SEPARATOR ) { return 1 ; } return NOT_FOUND ;
final int index = indexOfLastSeparator ( fileName ) ; final int endIndex = index + separatorAdd ; MST[rv.AOR2Mutator]MSP[N] if ( prefix >= fileName . length () || index < 0 || prefix >= endIndex ) { return EMPTY_STRING ; }
if ( len == 0 ) { return 0 ; } char ch0 = fileName . charAt ( 0 ) ; if ( ch0 == ':' ) { return NOT_FOUND ; } if ( len == 1 ) { if ( ch0 == '~' ) { MST[rv.CRCR5Mutator]MSP[N] return 2 ; }
if ( array [ j ] == separator ) { System . arraycopy ( array , i + 1 , array , j + 1 , size - i ) ; MST[rv.AOD1Mutator]MSP[N] size -= i - j ; i = j + 1 ; continue outer; } }
if ( path == null || path . indexOf ( WINDOWS_SEPARATOR ) == NOT_FOUND ) { return path ; } return path . replace ( WINDOWS_SEPARATOR , UNIX_SEPARATOR ) ; MST[ReturnValsMutator]MSP[N] } public static String separatorsToWindows ( final String path ) {
if ( size <= prefix ) { return new String ( array , 0 , size ) ; } if ( lastIsDirectory && keepSeparator ) { MST[rv.ROR1Mutator]MSP[N] return new String ( array , 0 , size ) ; }
if ( isSystemWindows () ) { final int offset = fileName . indexOf ( ':' , getAdsCriticalOffset ( fileName ) ) ; if ( offset != - 1 ) { throw new IllegalArgumentException ( lr_2 ) ; } } final int extensionPos = fileName . lastIndexOf ( EXTENSION_SEPARATOR ) ; MST[rv.CRCR4Mutator]MSP[N]
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2 ) { MST[rv.ROR2Mutator]MSP[N] return NOT_FOUND ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ;
final int pos = Math . min ( posUnix , posWin ) + 1 ; final String hostnamePart = fileName . substring ( 2 , pos - 1 ) ; MST[rv.AOR2Mutator]MSP[N] return isValidHostName ( hostnamePart ) ? pos : NOT_FOUND ; } else {
if ( i == prefix + 2 ) { return null ; } if ( i == size - 1 ) { MST[rv.ROR3Mutator]MSP[N] lastIsDirectory = true ; } int j ; for ( j = i - 4 ; j >= prefix ; j -- ) {
String fileName1 , String fileName2 , final boolean normalized , IOCase caseSensitivity ) { if ( fileName1 == null || fileName2 == null ) { return fileName1 == null && fileName2 == null ; MST[rv.CRCR5Mutator]MSP[N] } if ( normalized ) { fileName1 = normalize ( fileName1 ) ;
if ( ipSegment . length () > 1 && ipSegment . startsWith ( lr_8 ) ) { MST[rv.ROR4Mutator]MSP[N] return false ; } } return true ; } private static boolean isIPv6Address ( final String inet6Address ) { final boolean containsCompressedZeroes = inet6Address . contains ( lr_9 ) ;
final int index = indexOfLastSeparator ( fileName ) ; final int endIndex = index + separatorAdd ; if ( prefix >= fileName . length () || index < 0 || prefix >= endIndex ) { MST[rv.UOI4Mutator]MSP[N] return EMPTY_STRING ; }
if ( index == NOT_FOUND ) { return fileName ; } return fileName . substring ( 0 , index ) ; } public static boolean equals ( final String fileName1 , final String fileName2 ) { return equals ( fileName1 , fileName2 , false , IOCase . SENSITIVE ) ; MST[rv.CRCR5Mutator]MSP[S]
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND ) { MST[NegateConditionalsMutator]MSP[N] return len + 1 ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ; return Math . min ( posUnix , posWin ) + 1 ; }
final char [] array = new char [ size + 2 ] ; MST[rv.CRCR5Mutator]MSP[S] fileName . getChars ( 0 , fileName . length () , array , 0 ) ; final char otherSeparator = separator == SYSTEM_SEPARATOR ? OTHER_SEPARATOR : SYSTEM_SEPARATOR ;
public static String getExtension ( final String fileName ) throws IllegalArgumentException { if ( fileName == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] return null ; } final int index = indexOfExtension ( fileName ) ; if ( index == NOT_FOUND ) { return EMPTY_STRING ; }
final int prefix = getPrefixLength ( fileName ) ; if ( prefix < 0 ) { return null ; } if ( prefix >= fileName . length () ) { if ( includeSeparator ) { MST[rv.ABSMutator]MSP[N] return getPrefix ( fileName ) ; } return fileName ; }
if ( ! isIPv4Address ( octet ) ) { MST[rv.ROR1Mutator]MSP[S] return false ; } validOctets += 2 ; continue; } if ( octet . length () > IPV6_MAX_HEX_DIGITS_PER_GROUP ) { return false ; } int octetInt = 0 ; try {
return isSeparator ( ch0 ) ? 1 : 0 ; } } public static int indexOfLastSeparator ( final String fileName ) { if ( fileName == null ) { MST[rv.ROR5Mutator]MSP[N] return NOT_FOUND ; } final int lastUnixPos = fileName . lastIndexOf ( UNIX_SEPARATOR ) ;
if ( path . charAt ( i ) == 0 ) { throw new IllegalArgumentException ( lr_3 + lr_4 ) ; } } } public static String getBaseName ( final String fileName ) { return removeExtension ( getName ( fileName ) ) ; MST[ReturnValsMutator]MSP[N] }
|| ( inet6Address . endsWith ( lr_10 ) && ! inet6Address . endsWith ( lr_9 ) ) ) { return false ; } String [] octets = inet6Address . split ( lr_10 ) ; if ( containsCompressedZeroes ) { MST[rv.UOI2Mutator]MSP[N]
return fileName . substring ( index + 1 ) ; MST[rv.UOI4Mutator]MSP[N] } private static int getAdsCriticalOffset ( final String fileName ) { final int offset1 = fileName . lastIndexOf ( SYSTEM_SEPARATOR ) ; final int offset2 = fileName . lastIndexOf ( OTHER_SEPARATOR ) ;
if ( extension == null || extension . isEmpty () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] return indexOfExtension ( fileName ) == NOT_FOUND ; } final String fileExt = getExtension ( fileName ) ; return fileExt . equals ( extension ) ; }
return indexOfExtension ( fileName ) == NOT_FOUND ; } final String fileExt = getExtension ( fileName ) ; for ( final String extension : extensions ) { if ( fileExt . equals ( extension ) ) { MST[rv.ROR1Mutator]MSP[N] return true ; } } return false ; }
} else if ( isSeparator ( ch0 ) && isSeparator ( ch1 ) ) { int posUnix = fileName . indexOf ( UNIX_SEPARATOR , 2 ) ; MST[rv.CRCR5Mutator]MSP[N] int posWin = fileName . indexOf ( WINDOWS_SEPARATOR , 2 ) ;
public static String normalizeNoEndSeparator ( final String fileName ) { return doNormalize ( fileName , SYSTEM_SEPARATOR , false ) ; } public static String normalizeNoEndSeparator ( final String fileName , final boolean unixSeparator ) { final char separator = unixSeparator ? UNIX_SEPARATOR : WINDOWS_SEPARATOR ; MST[rv.UOI1Mutator]MSP[N]
if ( array [ i ] == separator && array [ i - 1 ] == '.' && array [ i - 2 ] == '.' && MST[rv.UOI1Mutator]MSP[N] ( i == prefix + 2 || array [ i - 3 ] == separator ) ) {
} return fileName . substring ( 0 , end ) ; MST[ReturnValsMutator]MSP[N] } public static String getName ( final String fileName ) { if ( fileName == null ) { return null ; } failIfNullBytePresent ( fileName ) ; final int index = indexOfLastSeparator ( fileName ) ;
final int lastWindowsPos = fileName . lastIndexOf ( WINDOWS_SEPARATOR ) ; return Math . max ( lastUnixPos , lastWindowsPos ) ; } public static int indexOfExtension ( final String fileName ) throws IllegalArgumentException { if ( fileName == null ) { MST[NegateConditionalsMutator]MSP[N] return NOT_FOUND ; }
return false ; } static String [] splitOnTokens ( final String text ) { if ( text . indexOf ( '?' ) == NOT_FOUND && text . indexOf ( '*' ) == NOT_FOUND ) { MST[rv.CRCR1Mutator]MSP[N] return new String [] { text } ; }
for ( int i = prefix + 1 ; i < size ; i ++ ) { if ( array [ i ] == separator && array [ i - 1 ] == '.' && MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
final int index = indexOfLastSeparator ( fileName ) ; if ( index < 0 ) { return fileName . substring ( 0 , prefix ) ; } int end = index + ( includeSeparator ? 1 : 0 ) ; MST[InlineConstantMutator]MSP[S] if ( end == 0 ) { end ++ ;
final int index = indexOfLastSeparator ( fileName ) ; if ( index < 0 ) { return fileName . substring ( 0 , prefix ) ; } int end = index + ( includeSeparator ? 1 : 0 ) ; MST[rv.ROR4Mutator]MSP[S] if ( end == 0 ) { end ++ ;
int size = fileName . length () ; if ( size == 0 ) { MST[rv.ROR4Mutator]MSP[N] return fileName ; } final int prefix = getPrefixLength ( fileName ) ; if ( prefix < 0 ) { return null ; }
if ( octet . length () == 0 ) { MST[rv.ROR1Mutator]MSP[N] emptyOctets ++ ; if ( emptyOctets > 1 ) { return false ; } } else { emptyOctets = 0 ; if ( index == octets . length - 1 && octet . contains ( lr_12 ) ) {
final String path = fileName . substring ( prefix , endIndex ) ; MST[rv.UOI2Mutator]MSP[N] failIfNullBytePresent ( path ) ; return path ; } public static String getFullPath ( final String fileName ) { return doGetFullPath ( fileName , true ) ; }
if ( array [ j ] == separator ) { System . arraycopy ( array , i + 1 , array , j + 1 , size - i ) ; size -= i - j ; i = j + 1 ; MST[InlineConstantMutator]MSP[N] continue outer; } }
return indexOfExtension ( fileName ) == NOT_FOUND ; MST[NonVoidMethodCallMutator]MSP[N] } final String fileExt = getExtension ( fileName ) ; for ( final String extension : extensions ) { if ( fileExt . equals ( extension ) ) { return true ; } } return false ; }
if ( len == 0 ) { return 0 ; } char ch0 = fileName . charAt ( 0 ) ; if ( ch0 == ':' ) { return NOT_FOUND ; } if ( len == 1 ) { MST[rv.UOI2Mutator]MSP[N] if ( ch0 == '~' ) { return 2 ; }
if ( octet . length () == 0 ) { emptyOctets ++ ; if ( emptyOctets > 1 ) { MST[rv.UOI1Mutator]MSP[N] return false ; } } else { emptyOctets = 0 ; if ( index == octets . length - 1 && octet . contains ( lr_12 ) ) {
static boolean isSystemWindows () { return SYSTEM_SEPARATOR == WINDOWS_SEPARATOR ; } private static boolean isSeparator ( final char ch ) { return ch == UNIX_SEPARATOR || ch == WINDOWS_SEPARATOR ; MST[rv.ROR2Mutator]MSP[N] } public static String normalize ( final String fileName ) {
if ( validOctets > IPV6_MAX_HEX_GROUPS || ( validOctets < IPV6_MAX_HEX_GROUPS && ! containsCompressedZeroes ) ) { return false ; MST[rv.CRCR3Mutator]MSP[S] } return true ; } private static boolean isRFC3986HostName ( final String name ) { final String [] parts = name . split ( lr_13 , - 1 ) ;
if ( array [ size - 1 ] != separator ) { array [ size ++ ] = separator ; lastIsDirectory = false ; } for ( int i = prefix + 1 ; i < size ; i ++ ) { MST[rv.ABSMutator]MSP[N]
for ( int i = prefix + 1 ; i < size ; i ++ ) { MST[rv.ROR4Mutator]MSP[N] if ( array [ i ] == separator && array [ i - 1 ] == '.' &&
return doNormalize ( fileName , SYSTEM_SEPARATOR , true ) ; } public static String normalize ( final String fileName , final boolean unixSeparator ) { final char separator = unixSeparator ? UNIX_SEPARATOR : WINDOWS_SEPARATOR ; return doNormalize ( fileName , separator , true ) ; MST[NonVoidMethodCallMutator]MSP[N] }
for ( int i = prefix + 1 ; i < size ; i ++ ) { if ( array [ i ] == separator && array [ i - 1 ] == '.' && MST[rv.UOI4Mutator]MSP[N]
static boolean isSystemWindows () { return SYSTEM_SEPARATOR == WINDOWS_SEPARATOR ; } private static boolean isSeparator ( final char ch ) { return ch == UNIX_SEPARATOR || ch == WINDOWS_SEPARATOR ; MST[rv.CRCR6Mutator]MSP[N] } public static String normalize ( final String fileName ) {
if ( array [ j ] == separator ) { System . arraycopy ( array , i + 1 , array , j + 1 , size - i ) ; size -= i - j ; i = j + 1 ; MST[rv.AOD1Mutator]MSP[N] continue outer; } }
if ( ipSegment . length () > 1 && ipSegment . startsWith ( lr_8 ) ) { MST[InlineConstantMutator]MSP[S] return false ; } } return true ; } private static boolean isIPv6Address ( final String inet6Address ) { final boolean containsCompressedZeroes = inet6Address . contains ( lr_9 ) ;
return fileName . substring ( index + 1 ) ; } private static void failIfNullBytePresent ( final String path ) { final int len = path . length () ; for ( int i = 0 ; i < len ; i ++ ) { MST[rv.UOI1Mutator]MSP[N]
String fileName1 , String fileName2 , final boolean normalized , IOCase caseSensitivity ) { if ( fileName1 == null || fileName2 == null ) { return fileName1 == null && fileName2 == null ; MST[ReturnValsMutator]MSP[N] } if ( normalized ) { fileName1 = normalize ( fileName1 ) ;
if ( array [ size - 1 ] != separator ) { array [ size ++ ] = separator ; MST[rv.ABSMutator]MSP[N] lastIsDirectory = false ; } for ( int i = prefix + 1 ; i < size ; i ++ ) {
if ( path . charAt ( i ) == 0 ) { throw new IllegalArgumentException ( lr_3 + lr_4 ) ; } } } public static String getBaseName ( final String fileName ) { return removeExtension ( getName ( fileName ) ) ; MST[ArgumentPropagationMutator]MSP[S] }
return new String ( array , 0 , size - 1 ) ; MST[rv.CRCR6Mutator]MSP[N] } public static String concat ( final String basePath , final String fullFileNameToAdd ) { final int prefix = getPrefixLength ( fullFileNameToAdd ) ; if ( prefix < 0 ) { return null ; }
final int lastSeparator = indexOfLastSeparator ( fileName ) ; return lastSeparator > extensionPos ? NOT_FOUND : extensionPos ; MST[rv.UOI3Mutator]MSP[N] } public static String getPrefix ( final String fileName ) { if ( fileName == null ) { return null ; } final int len = getPrefixLength ( fileName ) ;
textIdx = caseSensitivity . checkIndexOf ( fileName , textIdx , wcs [ wcsIdx ] ) ; if ( textIdx == NOT_FOUND ) { MST[NegateConditionalsMutator]MSP[N] break; } final int repeat = caseSensitivity . checkIndexOf ( fileName , textIdx + 1 , wcs [ wcsIdx ] ) ;
String fileName1 , String fileName2 , final boolean normalized , IOCase caseSensitivity ) { if ( fileName1 == null || fileName2 == null ) { return fileName1 == null && fileName2 == null ; } if ( normalized ) { MST[rv.ROR3Mutator]MSP[N] fileName1 = normalize ( fileName1 ) ;
if ( array [ i ] == separator && array [ i - 1 ] == '.' && array [ i - 2 ] == '.' && MST[rv.AOD2Mutator]MSP[N] ( i == prefix + 2 || array [ i - 3 ] == separator ) ) {
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2 ) { return NOT_FOUND ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; MST[rv.UOI4Mutator]MSP[N] posWin = posWin == NOT_FOUND ? posUnix : posWin ;
return doNormalize ( fileName , separator , false ) ; MST[rv.CRCR1Mutator]MSP[S] } private static String doNormalize ( final String fileName , final char separator , final boolean keepSeparator ) { if ( fileName == null ) { return null ; } failIfNullBytePresent ( fileName ) ;
if ( validOctets > IPV6_MAX_HEX_GROUPS || ( validOctets < IPV6_MAX_HEX_GROUPS && ! containsCompressedZeroes ) ) { MST[rv.UOI2Mutator]MSP[N] return false ; } return true ; } private static boolean isRFC3986HostName ( final String name ) { final String [] parts = name . split ( lr_13 , - 1 ) ;
for ( int i = 0 ; i < array . length ; i ++ ) { if ( array [ i ] == otherSeparator ) { array [ i ] = separator ; MST[rv.UOI1Mutator]MSP[N] } } boolean lastIsDirectory = true ;
return isSeparator ( ch0 ) ? 1 : 0 ; MST[rv.ROR4Mutator]MSP[N] } if ( ch0 == '~' ) { int posUnix = fileName . indexOf ( UNIX_SEPARATOR , 1 ) ; int posWin = fileName . indexOf ( WINDOWS_SEPARATOR , 1 ) ;
if ( len < 0 ) { return null ; } if ( len > fileName . length () ) { failIfNullBytePresent ( fileName + UNIX_SEPARATOR ) ; return fileName + UNIX_SEPARATOR ; MST[ConstructorCallMutator]MSP[N] } final String path = fileName . substring ( 0 , len ) ;
return indexOfExtension ( fileName ) == NOT_FOUND ; } final String fileExt = getExtension ( fileName ) ; for ( final String extension : extensions ) { MST[rv.UOI1Mutator]MSP[N] if ( fileExt . equals ( extension ) ) { return true ; } } return false ; }
return indexOfExtension ( fileName ) == NOT_FOUND ; } final String fileExt = getExtension ( fileName ) ; for ( final String extension : extensions ) { if ( fileExt . equals ( extension ) ) { return true ; } } return false ; MST[BooleanTrueReturnValsMutator]MSP[N] }
if ( size <= prefix ) { MST[rv.ROR5Mutator]MSP[S] return new String ( array , 0 , size ) ; } if ( lastIsDirectory && keepSeparator ) { return new String ( array , 0 , size ) ; }
final char ch1 = fileName . charAt ( 1 ) ; if ( ch1 == ':' ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] ch0 = Character . toUpperCase ( ch0 ) ; if ( ch0 >= 'A' && ch0 <= 'Z' ) {
if ( array [ j ] == separator ) { System . arraycopy ( array , i + 1 , array , j + 1 , size - i ) ; size -= i - j ; MST[rv.ABSMutator]MSP[N] i = j + 1 ; continue outer; } }
if ( ch == '?' || ch == '*' ) { if ( buffer . length () != 0 ) { list . add ( buffer . toString () ) ; buffer . setLength ( 0 ) ; MST[rv.CRCR5Mutator]MSP[N] } if ( ch == '?' ) {
return isSeparator ( ch0 ) ? 1 : 0 ; MST[InlineConstantMutator]MSP[N] } if ( ch0 == '~' ) { int posUnix = fileName . indexOf ( UNIX_SEPARATOR , 1 ) ; int posWin = fileName . indexOf ( WINDOWS_SEPARATOR , 1 ) ;
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND ) { return len + 1 ; MST[rv.AOD1Mutator]MSP[N] } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ; return Math . min ( posUnix , posWin ) + 1 ; }
if ( validOctets > IPV6_MAX_HEX_GROUPS || ( validOctets < IPV6_MAX_HEX_GROUPS && ! containsCompressedZeroes ) ) { MST[rv.UOI4Mutator]MSP[N] return false ; } return true ; } private static boolean isRFC3986HostName ( final String name ) { final String [] parts = name . split ( lr_13 , - 1 ) ;
if ( index == NOT_FOUND ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] return fileName ; } return fileName . substring ( 0 , index ) ; } public static boolean equals ( final String fileName1 , final String fileName2 ) { return equals ( fileName1 , fileName2 , false , IOCase . SENSITIVE ) ;
if ( containsCompressedZeroes && ( inet6Address . indexOf ( lr_9 ) != inet6Address . lastIndexOf ( lr_9 ) ) ) { return false ; } if ( ( inet6Address . startsWith ( lr_10 ) && ! inet6Address . startsWith ( lr_9 ) ) MST[NegateConditionalsMutator]MSP[N]
System . arraycopy ( array , i + 1 , array , prefix , size - i ) ; size -= i + 1 - prefix ; MST[rv.AOR4Mutator]MSP[N] i = prefix + 1 ; } } if ( size <= 0 ) { return EMPTY_STRING ; }
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2 ) { return NOT_FOUND ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; MST[rv.CRCR4Mutator]MSP[N] posWin = posWin == NOT_FOUND ? posUnix : posWin ;
if ( IOCase . SYSTEM . checkEquals ( canonicalParent , canonicalChild ) ) { return false ; MST[ReturnValsMutator]MSP[S] } return IOCase . SYSTEM . checkStartsWith ( canonicalChild , canonicalParent ) ; } public static String separatorsToUnix ( final String path ) {
if ( ch == '?' || ch == '*' ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] if ( buffer . length () != 0 ) { list . add ( buffer . toString () ) ; buffer . setLength ( 0 ) ; } if ( ch == '?' ) {
if ( validOctets > IPV6_MAX_HEX_GROUPS || ( validOctets < IPV6_MAX_HEX_GROUPS && ! containsCompressedZeroes ) ) { return false ; } return true ; MST[rv.CRCR6Mutator]MSP[N] } private static boolean isRFC3986HostName ( final String name ) { final String [] parts = name . split ( lr_13 , - 1 ) ;
final int prefix = getPrefixLength ( fileName ) ; if ( prefix < 0 ) { return null ; } if ( prefix >= fileName . length () ) { MST[NonVoidMethodCallMutator]MSP[N] if ( includeSeparator ) { return getPrefix ( fileName ) ; } return fileName ; }
final int index = indexOfLastSeparator ( fileName ) ; MST[NonVoidMethodCallMutator]MSP[N] final int endIndex = index + separatorAdd ; if ( prefix >= fileName . length () || index < 0 || prefix >= endIndex ) { return EMPTY_STRING ; }
if ( fileName == null || wildcardMatcher == null ) { return false ; MST[InlineConstantMutator]MSP[N] } if ( caseSensitivity == null ) { caseSensitivity = IOCase . SENSITIVE ; } final String [] wcs = splitOnTokens ( wildcardMatcher ) ; boolean anyChars = false ; int textIdx = 0 ;
return isSeparator ( ch0 ) ? 1 : 0 ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } } public static int indexOfLastSeparator ( final String fileName ) { if ( fileName == null ) { return NOT_FOUND ; } final int lastUnixPos = fileName . lastIndexOf ( UNIX_SEPARATOR ) ;
if ( repeat >= 0 ) { backtrack . push ( new int [] { wcsIdx , repeat } ) ; MST[rv.CRCR6Mutator]MSP[S] } } else { if ( ! caseSensitivity . checkRegionMatches ( fileName , textIdx , wcs [ wcsIdx ] ) ) { break; } }
final int lastWindowsPos = fileName . lastIndexOf ( WINDOWS_SEPARATOR ) ; return Math . max ( lastUnixPos , lastWindowsPos ) ; } public static int indexOfExtension ( final String fileName ) throws IllegalArgumentException { if ( fileName == null ) { MST[rv.ROR5Mutator]MSP[N] return NOT_FOUND ; }
for ( int i = prefix + 1 ; i < size ; i ++ ) { if ( array [ i ] == separator && array [ i - 1 ] == '.' && MST[rv.ABSMutator]MSP[N]
final char ch1 = fileName . charAt ( 1 ) ; if ( ch1 == ':' ) { ch0 = Character . toUpperCase ( ch0 ) ; if ( ch0 >= 'A' && ch0 <= 'Z' ) { MST[rv.ROR4Mutator]MSP[S]
if ( ! REG_NAME_PART_PATTERN . matcher ( parts [ i ] ) . matches () ) { MST[rv.ROR1Mutator]MSP[N] return false ; } } return true ; }
return doNormalize ( fileName , SYSTEM_SEPARATOR , true ) ; } public static String normalize ( final String fileName , final boolean unixSeparator ) { final char separator = unixSeparator ? UNIX_SEPARATOR : WINDOWS_SEPARATOR ; MST[rv.CRCR6Mutator]MSP[S] return doNormalize ( fileName , separator , true ) ; }
String fileName1 , String fileName2 , final boolean normalized , IOCase caseSensitivity ) { if ( fileName1 == null || fileName2 == null ) { return fileName1 == null && fileName2 == null ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } if ( normalized ) { fileName1 = normalize ( fileName1 ) ;
final char ch = basePath . charAt ( len - 1 ) ; if ( isSeparator ( ch ) ) { MST[rv.ROR2Mutator]MSP[N] return normalize ( basePath + fullFileNameToAdd ) ; } return normalize ( basePath + '/' + fullFileNameToAdd ) ; }
for ( int i = 1 ; i <= 4 ; i ++ ) { MST[rv.CRCR5Mutator]MSP[N] final String ipSegment = m . group ( i ) ; final int iIpSegment = Integer . parseInt ( ipSegment ) ; if ( iIpSegment > IPV4_MAX_OCTET_VALUE ) { return false ; }
if ( octet . length () == 0 ) { emptyOctets ++ ; if ( emptyOctets > 1 ) { return false ; } } else { emptyOctets = 0 ; if ( index == octets . length - 1 && octet . contains ( lr_12 ) ) { MST[rv.CRCR2Mutator]MSP[S]
final char ch1 = fileName . charAt ( 1 ) ; if ( ch1 == ':' ) { MST[rv.ROR1Mutator]MSP[N] ch0 = Character . toUpperCase ( ch0 ) ; if ( ch0 >= 'A' && ch0 <= 'Z' ) {
return new String ( array , 0 , size - 1 ) ; MST[rv.UOI4Mutator]MSP[N] } public static String concat ( final String basePath , final String fullFileNameToAdd ) { final int prefix = getPrefixLength ( fullFileNameToAdd ) ; if ( prefix < 0 ) { return null ; }
} else if ( isSeparator ( ch0 ) && isSeparator ( ch1 ) ) { MST[rv.ROR3Mutator]MSP[N] int posUnix = fileName . indexOf ( UNIX_SEPARATOR , 2 ) ; int posWin = fileName . indexOf ( WINDOWS_SEPARATOR , 2 ) ;
for ( int i = prefix + 1 ; i < size ; i ++ ) { MST[rv.ABSMutator]MSP[N] if ( array [ i ] == separator && array [ i - 1 ] == '.' &&
final String path = fileName . substring ( prefix , endIndex ) ; failIfNullBytePresent ( path ) ; return path ; } public static String getFullPath ( final String fileName ) { return doGetFullPath ( fileName , true ) ; MST[NonVoidMethodCallMutator]MSP[N] }
textIdx = caseSensitivity . checkIndexOf ( fileName , textIdx , wcs [ wcsIdx ] ) ; MST[rv.UOI3Mutator]MSP[N] if ( textIdx == NOT_FOUND ) { break; } final int repeat = caseSensitivity . checkIndexOf ( fileName , textIdx + 1 , wcs [ wcsIdx ] ) ;
final char [] array = text . toCharArray () ; final ArrayList < String > list = new ArrayList <> () ; final StringBuilder buffer = new StringBuilder () ; char prevChar = 0 ; MST[rv.CRCR6Mutator]MSP[N] for ( final char ch : array ) {
static boolean isSystemWindows () { return SYSTEM_SEPARATOR == WINDOWS_SEPARATOR ; MST[InlineConstantMutator]MSP[N] } private static boolean isSeparator ( final char ch ) { return ch == UNIX_SEPARATOR || ch == WINDOWS_SEPARATOR ; } public static String normalize ( final String fileName ) {
if ( len < 0 ) { return null ; } if ( len > fileName . length () ) { failIfNullBytePresent ( fileName + UNIX_SEPARATOR ) ; return fileName + UNIX_SEPARATOR ; MST[rv.CRCR4Mutator]MSP[N] } final String path = fileName . substring ( 0 , len ) ;
if ( ch == '?' || ch == '*' ) { if ( buffer . length () != 0 ) { MST[rv.ROR1Mutator]MSP[N] list . add ( buffer . toString () ) ; buffer . setLength ( 0 ) ; } if ( ch == '?' ) {
if ( len == 0 ) { return 0 ; } char ch0 = fileName . charAt ( 0 ) ; if ( ch0 == ':' ) { return NOT_FOUND ; } if ( len == 1 ) { MST[InlineConstantMutator]MSP[N] if ( ch0 == '~' ) { return 2 ; }
if ( ! REG_NAME_PART_PATTERN . matcher ( parts [ i ] ) . matches () ) { return false ; MST[rv.CRCR1Mutator]MSP[N] } } return true ; }
failIfNullBytePresent ( path ) ; return path ; } public static String getPath ( final String fileName ) { return doGetPath ( fileName , 1 ) ; } public static String getPathNoEndSeparator ( final String fileName ) { return doGetPath ( fileName , 0 ) ; MST[rv.CRCR3Mutator]MSP[S] }
final char [] array = new char [ size + 2 ] ; fileName . getChars ( 0 , fileName . length () , array , 0 ) ; final char otherSeparator = separator == SYSTEM_SEPARATOR ? OTHER_SEPARATOR : SYSTEM_SEPARATOR ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
if ( array [ i ] == separator && array [ i - 1 ] == separator ) { System . arraycopy ( array , i , array , i - 1 , size - i ) ; MST[rv.ABSMutator]MSP[N] size -- ; i -- ; } }
if ( containsCompressedZeroes && ( inet6Address . indexOf ( lr_9 ) != inet6Address . lastIndexOf ( lr_9 ) ) ) { return false ; } if ( ( inet6Address . startsWith ( lr_10 ) && ! inet6Address . startsWith ( lr_9 ) ) MST[rv.ROR5Mutator]MSP[N]
octetInt = Integer . parseInt ( octet , BASE_16 ) ; MST[NonVoidMethodCallMutator]MSP[S] } catch ( final NumberFormatException e ) { return false ; } if ( octetInt < 0 || octetInt > MAX_UNSIGNED_SHORT ) { return false ; } } validOctets ++ ; }
System . arraycopy ( array , i + 1 , array , i - 1 , size - i ) ; MST[rv.UOI2Mutator]MSP[N] size -= 2 ; i -- ; } } outer: for ( int i = prefix + 2 ; i < size ; i ++ ) {
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND ) { return len + 1 ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; MST[rv.CRCR6Mutator]MSP[N] posWin = posWin == NOT_FOUND ? posUnix : posWin ; return Math . min ( posUnix , posWin ) + 1 ; }
for ( int i = prefix + 1 ; i < size ; i ++ ) { if ( array [ i ] == separator && array [ i - 1 ] == '.' && MST[rv.AOR1Mutator]MSP[N]
if ( extension == null || extension . isEmpty () ) { return indexOfExtension ( fileName ) == NOT_FOUND ; MST[rv.ROR1Mutator]MSP[S] } final String fileExt = getExtension ( fileName ) ; return fileExt . equals ( extension ) ; }
return isSeparator ( ch0 ) ? 1 : 0 ; } if ( ch0 == '~' ) { int posUnix = fileName . indexOf ( UNIX_SEPARATOR , 1 ) ; MST[InlineConstantMutator]MSP[N] int posWin = fileName . indexOf ( WINDOWS_SEPARATOR , 1 ) ;
textIdx += wcs [ wcsIdx ] . length () ; anyChars = false ; } wcsIdx ++ ; } if ( wcsIdx == wcs . length && textIdx == fileName . length () ) { MST[rv.UOI1Mutator]MSP[N] return true ; } } while ( backtrack . size () > 0 );
final int prefix = getPrefixLength ( fileName ) ; if ( prefix < 0 ) { return null ; } if ( prefix >= fileName . length () ) { if ( includeSeparator ) { return getPrefix ( fileName ) ; MST[ArgumentPropagationMutator]MSP[S] } return fileName ; }
if ( len == 0 ) { return 0 ; } char ch0 = fileName . charAt ( 0 ) ; if ( ch0 == ':' ) { return NOT_FOUND ; } if ( len == 1 ) { if ( ch0 == '~' ) { MST[NegateConditionalsMutator]MSP[N] return 2 ; }
for ( int i = prefix + 1 ; i < size ; i ++ ) { if ( array [ i ] == separator && array [ i - 1 ] == '.' && MST[NegateConditionalsMutator]MSP[N]
if ( ! isIPv4Address ( octet ) ) { return false ; } validOctets += 2 ; MST[experimental.RemoveIncrementsMutator]MSP[N] continue; } if ( octet . length () > IPV6_MAX_HEX_DIGITS_PER_GROUP ) { return false ; } int octetInt = 0 ; try {
if ( len == 0 ) { return 0 ; } char ch0 = fileName . charAt ( 0 ) ; if ( ch0 == ':' ) { MST[rv.UOI3Mutator]MSP[N] return NOT_FOUND ; } if ( len == 1 ) { if ( ch0 == '~' ) { return 2 ; }
textIdx = caseSensitivity . checkIndexOf ( fileName , textIdx , wcs [ wcsIdx ] ) ; if ( textIdx == NOT_FOUND ) { break; } final int repeat = caseSensitivity . checkIndexOf ( fileName , textIdx + 1 , wcs [ wcsIdx ] ) ; MST[rv.UOI3Mutator]MSP[N]
|| ( inet6Address . endsWith ( lr_10 ) && ! inet6Address . endsWith ( lr_9 ) ) ) { MST[rv.ROR2Mutator]MSP[S] return false ; } String [] octets = inet6Address . split ( lr_10 ) ; if ( containsCompressedZeroes ) {
list . add ( buffer . toString () ) ; } return list . toArray ( new String [ list . size () ] ) ; MST[NonVoidMethodCallMutator]MSP[N] } private static boolean isValidHostName ( final String name ) { return isIPv6Address ( name ) || isRFC3986HostName ( name ) ; }
if ( len == 0 ) { MST[rv.ABSMutator]MSP[S] return 0 ; } char ch0 = fileName . charAt ( 0 ) ; if ( ch0 == ':' ) { return NOT_FOUND ; } if ( len == 1 ) { if ( ch0 == '~' ) { return 2 ; }
if ( path == null || path . indexOf ( UNIX_SEPARATOR ) == NOT_FOUND ) { return path ; } return path . replace ( UNIX_SEPARATOR , WINDOWS_SEPARATOR ) ; MST[rv.CRCR5Mutator]MSP[N] } public static String separatorsToSystem ( final String path ) { if ( path == null ) {
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND ) { MST[rv.UOI2Mutator]MSP[N] return len + 1 ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ; return Math . min ( posUnix , posWin ) + 1 ; }
return fileName . substring ( index + 1 ) ; MST[rv.AOR2Mutator]MSP[N] } private static void failIfNullBytePresent ( final String path ) { final int len = path . length () ; for ( int i = 0 ; i < len ; i ++ ) {
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND ) { return len + 1 ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] posWin = posWin == NOT_FOUND ? posUnix : posWin ; return Math . min ( posUnix , posWin ) + 1 ; }
if ( ! isIPv4Address ( octet ) ) { return false ; } validOctets += 2 ; continue; } if ( octet . length () > IPV6_MAX_HEX_DIGITS_PER_GROUP ) { MST[ConditionalsBoundaryMutator]MSP[N] return false ; } int octetInt = 0 ; try {
textIdx = array [ 1 ] ; anyChars = true ; } while ( wcsIdx < wcs . length ) { if ( wcs [ wcsIdx ] . equals ( lr_6 ) ) { MST[rv.UOI4Mutator]MSP[N] textIdx ++ ; if ( textIdx > fileName . length () ) { break; }
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2 ) { return NOT_FOUND ; MST[InlineConstantMutator]MSP[N] } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ;
for ( int i = 0 ; i < array . length ; i ++ ) { MST[rv.ROR5Mutator]MSP[N] if ( array [ i ] == otherSeparator ) { array [ i ] = separator ; } } boolean lastIsDirectory = true ;
final int pos = Math . min ( posUnix , posWin ) + 1 ; final String hostnamePart = fileName . substring ( 2 , pos - 1 ) ; MST[rv.CRCR4Mutator]MSP[N] return isValidHostName ( hostnamePart ) ? pos : NOT_FOUND ; } else {
if ( ! REG_NAME_PART_PATTERN . matcher ( parts [ i ] ) . matches () ) { return false ; } } return true ; MST[rv.CRCR6Mutator]MSP[N] }
if ( containsCompressedZeroes && ( inet6Address . indexOf ( lr_9 ) != inet6Address . lastIndexOf ( lr_9 ) ) ) { return false ; MST[ReturnValsMutator]MSP[S] } if ( ( inet6Address . startsWith ( lr_10 ) && ! inet6Address . startsWith ( lr_9 ) )
if ( size <= prefix ) { MST[rv.UOI4Mutator]MSP[N] return new String ( array , 0 , size ) ; } if ( lastIsDirectory && keepSeparator ) { return new String ( array , 0 , size ) ; }
if ( size <= prefix ) { return new String ( array , 0 , size ) ; MST[rv.CRCR6Mutator]MSP[N] } if ( lastIsDirectory && keepSeparator ) { return new String ( array , 0 , size ) ; }
if ( ch == '?' || ch == '*' ) { MST[rv.UOI1Mutator]MSP[N] if ( buffer . length () != 0 ) { list . add ( buffer . toString () ) ; buffer . setLength ( 0 ) ; } if ( ch == '?' ) {
if ( octets . length > IPV6_MAX_HEX_GROUPS ) { return false ; } int validOctets = 0 ; int emptyOctets = 0 ; for ( int index = 0 ; index < octets . length ; index ++ ) { MST[rv.UOI3Mutator]MSP[N] final String octet = octets [ index ] ;
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2 ) { return NOT_FOUND ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; MST[rv.ABSMutator]MSP[N] posWin = posWin == NOT_FOUND ? posUnix : posWin ;
final int index = indexOfLastSeparator ( fileName ) ; if ( index < 0 ) { return fileName . substring ( 0 , prefix ) ; } int end = index + ( includeSeparator ? 1 : 0 ) ; MST[rv.UOI3Mutator]MSP[N] if ( end == 0 ) { end ++ ;
final int index = indexOfLastSeparator ( fileName ) ; if ( index < 0 ) { MST[rv.ROR1Mutator]MSP[N] return fileName . substring ( 0 , prefix ) ; } int end = index + ( includeSeparator ? 1 : 0 ) ; if ( end == 0 ) { end ++ ;
anyChars = false ; } else if ( wcs [ wcsIdx ] . equals ( lr_7 ) ) { anyChars = true ; if ( wcsIdx == wcs . length - 1 ) { MST[rv.UOI1Mutator]MSP[N] textIdx = fileName . length () ; } } else { if ( anyChars ) {
final String path = fileName . substring ( prefix , endIndex ) ; MST[rv.UOI1Mutator]MSP[N] failIfNullBytePresent ( path ) ; return path ; } public static String getFullPath ( final String fileName ) { return doGetFullPath ( fileName , true ) ; }
return doNormalize ( fileName , SYSTEM_SEPARATOR , true ) ; } public static String normalize ( final String fileName , final boolean unixSeparator ) { final char separator = unixSeparator ? UNIX_SEPARATOR : WINDOWS_SEPARATOR ; MST[rv.UOI4Mutator]MSP[N] return doNormalize ( fileName , separator , true ) ; }
return null ; } return isSystemWindows () ? separatorsToWindows ( path ) : separatorsToUnix ( path ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } public static int getPrefixLength ( final String fileName ) { if ( fileName == null ) { return NOT_FOUND ; } final int len = fileName . length () ;
if ( len == 0 ) { return 0 ; } char ch0 = fileName . charAt ( 0 ) ; if ( ch0 == ':' ) { return NOT_FOUND ; } if ( len == 1 ) { if ( ch0 == '~' ) { MST[rv.ROR5Mutator]MSP[N] return 2 ; }
} else if ( inet6Address . startsWith ( lr_9 ) && ! octetList . isEmpty () ) { MST[rv.ROR1Mutator]MSP[N] octetList . remove ( 0 ) ; } octets = octetList . toArray ( new String [ octetList . size () ] ) ; }
for ( int i = 0 ; i < array . length ; i ++ ) { MST[rv.CRCR3Mutator]MSP[N] if ( array [ i ] == otherSeparator ) { array [ i ] = separator ; } } boolean lastIsDirectory = true ;
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2 ) { return NOT_FOUND ; MST[rv.CRCR2Mutator]MSP[N] } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ;
static boolean isSystemWindows () { return SYSTEM_SEPARATOR == WINDOWS_SEPARATOR ; } private static boolean isSeparator ( final char ch ) { return ch == UNIX_SEPARATOR || ch == WINDOWS_SEPARATOR ; MST[rv.ABSMutator]MSP[N] } public static String normalize ( final String fileName ) {
if ( array [ size - 1 ] != separator ) { array [ size ++ ] = separator ; lastIsDirectory = false ; } for ( int i = prefix + 1 ; i < size ; i ++ ) { MST[rv.ROR2Mutator]MSP[N]
if ( i == prefix + 2 ) { return null ; } if ( i == size - 1 ) { MST[rv.UOI4Mutator]MSP[N] lastIsDirectory = true ; } int j ; for ( j = i - 4 ; j >= prefix ; j -- ) {
final char ch1 = fileName . charAt ( 1 ) ; if ( ch1 == ':' ) { ch0 = Character . toUpperCase ( ch0 ) ; if ( ch0 >= 'A' && ch0 <= 'Z' ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[S]
anyChars = false ; } else if ( wcs [ wcsIdx ] . equals ( lr_7 ) ) { anyChars = true ; if ( wcsIdx == wcs . length - 1 ) { MST[rv.CRCR3Mutator]MSP[N] textIdx = fileName . length () ; } } else { if ( anyChars ) {
System . arraycopy ( array , i + 1 , array , prefix , size - i ) ; MST[rv.UOI1Mutator]MSP[N] size -= i + 1 - prefix ; i = prefix + 1 ; } } if ( size <= 0 ) { return EMPTY_STRING ; }
System . arraycopy ( array , i + 1 , array , i - 1 , size - i ) ; size -= 2 ; i -- ; } } outer: for ( int i = prefix + 2 ; i < size ; i ++ ) { MST[rv.UOI2Mutator]MSP[N]
if ( len == 0 ) { return 0 ; } char ch0 = fileName . charAt ( 0 ) ; if ( ch0 == ':' ) { return NOT_FOUND ; } if ( len == 1 ) { if ( ch0 == '~' ) { return 2 ; MST[ReturnValsMutator]MSP[N] }
for ( int i = prefix + 1 ; i < size ; i ++ ) { if ( array [ i ] == separator && array [ i - 1 ] == '.' && MST[rv.ROR5Mutator]MSP[N]
if ( array [ i ] == separator && array [ i - 1 ] == '.' && array [ i - 2 ] == '.' && MST[rv.CRCR1Mutator]MSP[N] ( i == prefix + 2 || array [ i - 3 ] == separator ) ) {
final int pos = Math . min ( posUnix , posWin ) + 1 ; final String hostnamePart = fileName . substring ( 2 , pos - 1 ) ; return isValidHostName ( hostnamePart ) ? pos : NOT_FOUND ; MST[rv.ROR4Mutator]MSP[N] } else {
for ( int i = 0 ; i < parts . length ; i ++ ) { if ( parts [ i ] . length () == 0 ) { return i == parts . length - 1 ; MST[rv.CRCR5Mutator]MSP[N] }
return isSeparator ( ch0 ) ? 1 : 0 ; MST[rv.CRCR2Mutator]MSP[N] } if ( ch0 == '~' ) { int posUnix = fileName . indexOf ( UNIX_SEPARATOR , 1 ) ; int posWin = fileName . indexOf ( WINDOWS_SEPARATOR , 1 ) ;
if ( ipSegment . length () > 1 && ipSegment . startsWith ( lr_8 ) ) { MST[rv.ROR1Mutator]MSP[S] return false ; } } return true ; } private static boolean isIPv6Address ( final String inet6Address ) { final boolean containsCompressedZeroes = inet6Address . contains ( lr_9 ) ;
final char [] array = new char [ size + 2 ] ; fileName . getChars ( 0 , fileName . length () , array , 0 ) ; MST[rv.CRCR6Mutator]MSP[N] final char otherSeparator = separator == SYSTEM_SEPARATOR ? OTHER_SEPARATOR : SYSTEM_SEPARATOR ;
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND ) { MST[InlineConstantMutator]MSP[N] return len + 1 ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ; return Math . min ( posUnix , posWin ) + 1 ; }
textIdx = array [ 1 ] ; anyChars = true ; } while ( wcsIdx < wcs . length ) { if ( wcs [ wcsIdx ] . equals ( lr_6 ) ) { textIdx ++ ; if ( textIdx > fileName . length () ) { MST[rv.UOI3Mutator]MSP[N] break; }
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND ) { MST[rv.UOI1Mutator]MSP[N] return len + 1 ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ; return Math . min ( posUnix , posWin ) + 1 ; }
final int index = indexOfLastSeparator ( fileName ) ; final int endIndex = index + separatorAdd ; if ( prefix >= fileName . length () || index < 0 || prefix >= endIndex ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] return EMPTY_STRING ; }
if ( array [ j ] == separator ) { MST[NegateConditionalsMutator]MSP[N] System . arraycopy ( array , i + 1 , array , j + 1 , size - i ) ; size -= i - j ; i = j + 1 ; continue outer; } }
final char [] array = text . toCharArray () ; final ArrayList < String > list = new ArrayList <> () ; final StringBuilder buffer = new StringBuilder () ; char prevChar = 0 ; for ( final char ch : array ) { MST[rv.ABSMutator]MSP[N]
System . arraycopy ( array , i + 1 , array , prefix , size - i ) ; MST[rv.AOD2Mutator]MSP[N] size -= i + 1 - prefix ; i = prefix + 1 ; } } if ( size <= 0 ) { return EMPTY_STRING ; }
|| ( inet6Address . endsWith ( lr_10 ) && ! inet6Address . endsWith ( lr_9 ) ) ) { return false ; } String [] octets = inet6Address . split ( lr_10 ) ; if ( containsCompressedZeroes ) { MST[rv.ROR3Mutator]MSP[N]
return isSeparator ( ch0 ) ? 1 : 0 ; } if ( ch0 == '~' ) { int posUnix = fileName . indexOf ( UNIX_SEPARATOR , 1 ) ; MST[rv.CRCR2Mutator]MSP[N] int posWin = fileName . indexOf ( WINDOWS_SEPARATOR , 1 ) ;
if ( path == null || path . indexOf ( UNIX_SEPARATOR ) == NOT_FOUND ) { return path ; } return path . replace ( UNIX_SEPARATOR , WINDOWS_SEPARATOR ) ; MST[ReturnValsMutator]MSP[N] } public static String separatorsToSystem ( final String path ) { if ( path == null ) {
final int pos = Math . min ( posUnix , posWin ) + 1 ; MST[InlineConstantMutator]MSP[N] final String hostnamePart = fileName . substring ( 2 , pos - 1 ) ; return isValidHostName ( hostnamePart ) ? pos : NOT_FOUND ; } else {
final char [] array = new char [ size + 2 ] ; MST[rv.AOR3Mutator]MSP[N] fileName . getChars ( 0 , fileName . length () , array , 0 ) ; final char otherSeparator = separator == SYSTEM_SEPARATOR ? OTHER_SEPARATOR : SYSTEM_SEPARATOR ;
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND ) { return len + 1 ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ; return Math . min ( posUnix , posWin ) + 1 ; MST[rv.AOR4Mutator]MSP[N] }
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2 ) { return NOT_FOUND ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ; MST[rv.ABSMutator]MSP[N]
if ( array [ j ] == separator ) { System . arraycopy ( array , i + 1 , array , j + 1 , size - i ) ; size -= i - j ; MST[rv.UOI3Mutator]MSP[N] i = j + 1 ; continue outer; } }
fileName2 = normalize ( fileName2 ) ; if ( fileName1 == null || fileName2 == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] throw new NullPointerException ( lr_5 ) ; } } if ( caseSensitivity == null ) { caseSensitivity = IOCase . SENSITIVE ; }
if ( ! REG_NAME_PART_PATTERN . matcher ( parts [ i ] ) . matches () ) { MST[rv.ABSMutator]MSP[N] return false ; } } return true ; }
anyChars = false ; } else if ( wcs [ wcsIdx ] . equals ( lr_7 ) ) { anyChars = true ; if ( wcsIdx == wcs . length - 1 ) { MST[rv.ROR5Mutator]MSP[N] textIdx = fileName . length () ; } } else { if ( anyChars ) {
public static boolean isExtension ( final String fileName , final String ... extensions ) { if ( fileName == null ) { return false ; } failIfNullBytePresent ( fileName ) ; if ( extensions == null || extensions . length == 0 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S]
if ( ipSegment . length () > 1 && ipSegment . startsWith ( lr_8 ) ) { MST[rv.CRCR4Mutator]MSP[S] return false ; } } return true ; } private static boolean isIPv6Address ( final String inet6Address ) { final boolean containsCompressedZeroes = inet6Address . contains ( lr_9 ) ;
if ( containsCompressedZeroes && ( inet6Address . indexOf ( lr_9 ) != inet6Address . lastIndexOf ( lr_9 ) ) ) { MST[rv.ROR2Mutator]MSP[N] return false ; } if ( ( inet6Address . startsWith ( lr_10 ) && ! inet6Address . startsWith ( lr_9 ) )
System . arraycopy ( array , i + 1 , array , i - 1 , size - i ) ; MST[rv.ABSMutator]MSP[N] size -= 2 ; i -- ; } } outer: for ( int i = prefix + 2 ; i < size ; i ++ ) {
final int lastWindowsPos = fileName . lastIndexOf ( WINDOWS_SEPARATOR ) ; return Math . max ( lastUnixPos , lastWindowsPos ) ; MST[rv.UOI1Mutator]MSP[N] } public static int indexOfExtension ( final String fileName ) throws IllegalArgumentException { if ( fileName == null ) { return NOT_FOUND ; }
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2 ) { MST[rv.CRCR6Mutator]MSP[N] return NOT_FOUND ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ;
if ( octet . length () == 0 ) { emptyOctets ++ ; MST[IncrementsMutator]MSP[N] if ( emptyOctets > 1 ) { return false ; } } else { emptyOctets = 0 ; if ( index == octets . length - 1 && octet . contains ( lr_12 ) ) {
if ( array [ size - 1 ] != separator ) { MST[rv.UOI2Mutator]MSP[N] array [ size ++ ] = separator ; lastIsDirectory = false ; } for ( int i = prefix + 1 ; i < size ; i ++ ) {
if ( array [ i ] == separator && array [ i - 1 ] == '.' && array [ i - 2 ] == '.' && MST[rv.AOD1Mutator]MSP[N] ( i == prefix + 2 || array [ i - 3 ] == separator ) ) {
if ( len == 0 ) { return 0 ; } char ch0 = fileName . charAt ( 0 ) ; if ( ch0 == ':' ) { return NOT_FOUND ; } if ( len == 1 ) { MST[rv.CRCR2Mutator]MSP[N] if ( ch0 == '~' ) { return 2 ; }
return fileName . substring ( index + 1 ) ; } private static void failIfNullBytePresent ( final String path ) { final int len = path . length () ; for ( int i = 0 ; i < len ; i ++ ) { MST[rv.ROR2Mutator]MSP[N]
anyChars = false ; } else if ( wcs [ wcsIdx ] . equals ( lr_7 ) ) { MST[rv.UOI3Mutator]MSP[N] anyChars = true ; if ( wcsIdx == wcs . length - 1 ) { textIdx = fileName . length () ; } } else { if ( anyChars ) {
if ( path . charAt ( i ) == 0 ) { MST[rv.ROR4Mutator]MSP[N] throw new IllegalArgumentException ( lr_3 + lr_4 ) ; } } } public static String getBaseName ( final String fileName ) { return removeExtension ( getName ( fileName ) ) ; }
return indexOfExtension ( fileName ) == NOT_FOUND ; } final String fileExt = getExtension ( fileName ) ; for ( final String extension : extensions ) { if ( fileExt . equals ( extension ) ) { MST[rv.ROR3Mutator]MSP[N] return true ; } } return false ; }
textIdx += wcs [ wcsIdx ] . length () ; MST[rv.UOI4Mutator]MSP[N] anyChars = false ; } wcsIdx ++ ; } if ( wcsIdx == wcs . length && textIdx == fileName . length () ) { return true ; } } while ( backtrack . size () > 0 );
static boolean isSystemWindows () { return SYSTEM_SEPARATOR == WINDOWS_SEPARATOR ; } private static boolean isSeparator ( final char ch ) { return ch == UNIX_SEPARATOR || ch == WINDOWS_SEPARATOR ; MST[rv.CRCR3Mutator]MSP[N] } public static String normalize ( final String fileName ) {
if ( octet . length () == 0 ) { emptyOctets ++ ; if ( emptyOctets > 1 ) { return false ; } } else { emptyOctets = 0 ; if ( index == octets . length - 1 && octet . contains ( lr_12 ) ) { MST[NegateConditionalsMutator]MSP[N]
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2 ) { MST[rv.ABSMutator]MSP[N] return NOT_FOUND ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ;
public static boolean isExtension ( final String fileName , final String ... extensions ) { if ( fileName == null ) { return false ; } failIfNullBytePresent ( fileName ) ; if ( extensions == null || extensions . length == 0 ) { MST[rv.ROR4Mutator]MSP[S]
textIdx += wcs [ wcsIdx ] . length () ; anyChars = false ; } wcsIdx ++ ; } if ( wcsIdx == wcs . length && textIdx == fileName . length () ) { MST[rv.UOI4Mutator]MSP[N] return true ; } } while ( backtrack . size () > 0 );
return isSeparator ( ch0 ) ? 1 : 0 ; } if ( ch0 == '~' ) { MST[rv.CRCR6Mutator]MSP[N] int posUnix = fileName . indexOf ( UNIX_SEPARATOR , 1 ) ; int posWin = fileName . indexOf ( WINDOWS_SEPARATOR , 1 ) ;
System . arraycopy ( array , i + 1 , array , prefix , size - i ) ; size -= i + 1 - prefix ; MST[rv.ABSMutator]MSP[N] i = prefix + 1 ; } } if ( size <= 0 ) { return EMPTY_STRING ; }
for ( int i = 1 ; i <= 4 ; i ++ ) { MST[rv.CRCR6Mutator]MSP[N] final String ipSegment = m . group ( i ) ; final int iIpSegment = Integer . parseInt ( ipSegment ) ; if ( iIpSegment > IPV4_MAX_OCTET_VALUE ) { return false ; }
final int lastSeparator = indexOfLastSeparator ( fileName ) ; return lastSeparator > extensionPos ? NOT_FOUND : extensionPos ; MST[rv.UOI2Mutator]MSP[N] } public static String getPrefix ( final String fileName ) { if ( fileName == null ) { return null ; } final int len = getPrefixLength ( fileName ) ;
static boolean isSystemWindows () { return SYSTEM_SEPARATOR == WINDOWS_SEPARATOR ; } private static boolean isSeparator ( final char ch ) { return ch == UNIX_SEPARATOR || ch == WINDOWS_SEPARATOR ; MST[rv.CRCR5Mutator]MSP[N] } public static String normalize ( final String fileName ) {
String fileName1 , String fileName2 , final boolean normalized , IOCase caseSensitivity ) { if ( fileName1 == null || fileName2 == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return fileName1 == null && fileName2 == null ; } if ( normalized ) { fileName1 = normalize ( fileName1 ) ;
final char ch = basePath . charAt ( len - 1 ) ; if ( isSeparator ( ch ) ) { MST[rv.ROR3Mutator]MSP[N] return normalize ( basePath + fullFileNameToAdd ) ; } return normalize ( basePath + '/' + fullFileNameToAdd ) ; }
for ( int i = prefix + 1 ; i < size ; i ++ ) { if ( array [ i ] == separator && array [ i - 1 ] == '.' && MST[rv.CRCR6Mutator]MSP[N]
System . arraycopy ( array , i + 1 , array , i - 1 , size - i ) ; MST[rv.AOR1Mutator]MSP[N] size -= 2 ; i -- ; } } outer: for ( int i = prefix + 2 ; i < size ; i ++ ) {
return indexOfExtension ( fileName ) == NOT_FOUND ; MST[rv.CRCR5Mutator]MSP[N] } final String fileExt = getExtension ( fileName ) ; for ( final String extension : extensions ) { if ( fileExt . equals ( extension ) ) { return true ; } } return false ; }
if ( size <= prefix ) { return new String ( array , 0 , size ) ; } if ( lastIsDirectory && keepSeparator ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return new String ( array , 0 , size ) ; }
return false ; } static String [] splitOnTokens ( final String text ) { if ( text . indexOf ( '?' ) == NOT_FOUND && text . indexOf ( '*' ) == NOT_FOUND ) { MST[rv.ROR1Mutator]MSP[N] return new String [] { text } ; }
final char ch = basePath . charAt ( len - 1 ) ; if ( isSeparator ( ch ) ) { return normalize ( basePath + fullFileNameToAdd ) ; } return normalize ( basePath + '/' + fullFileNameToAdd ) ; MST[ReturnValsMutator]MSP[N] }
if ( array [ i ] == separator && array [ i - 1 ] == '.' && array [ i - 2 ] == '.' && MST[rv.UOI4Mutator]MSP[N] ( i == prefix + 2 || array [ i - 3 ] == separator ) ) {
final int prefix = getPrefixLength ( fileName ) ; if ( prefix < 0 ) { return null ; MST[ReturnValsMutator]MSP[N] } if ( prefix >= fileName . length () ) { if ( includeSeparator ) { return getPrefix ( fileName ) ; } return fileName ; }
String fileName1 , String fileName2 , final boolean normalized , IOCase caseSensitivity ) { if ( fileName1 == null || fileName2 == null ) { return fileName1 == null && fileName2 == null ; } if ( normalized ) { MST[rv.UOI2Mutator]MSP[N] fileName1 = normalize ( fileName1 ) ;
if ( array [ j ] == separator ) { System . arraycopy ( array , i + 1 , array , j + 1 , size - i ) ; MST[rv.UOI1Mutator]MSP[N] size -= i - j ; i = j + 1 ; continue outer; } }
if ( array [ i ] == separator && array [ i - 1 ] == '.' && array [ i - 2 ] == '.' && MST[rv.ROR4Mutator]MSP[N] ( i == prefix + 2 || array [ i - 3 ] == separator ) ) {
if ( path == null || path . indexOf ( WINDOWS_SEPARATOR ) == NOT_FOUND ) { MST[rv.CRCR5Mutator]MSP[N] return path ; } return path . replace ( WINDOWS_SEPARATOR , UNIX_SEPARATOR ) ; } public static String separatorsToWindows ( final String path ) {
return indexOfExtension ( fileName ) == NOT_FOUND ; } final String fileExt = getExtension ( fileName ) ; for ( final String extension : extensions ) { MST[rv.UOI2Mutator]MSP[N] if ( fileExt . equals ( extension ) ) { return true ; } } return false ; }
public static String normalizeNoEndSeparator ( final String fileName ) { return doNormalize ( fileName , SYSTEM_SEPARATOR , false ) ; } public static String normalizeNoEndSeparator ( final String fileName , final boolean unixSeparator ) { final char separator = unixSeparator ? UNIX_SEPARATOR : WINDOWS_SEPARATOR ; MST[rv.CRCR4Mutator]MSP[S]
public static String normalizeNoEndSeparator ( final String fileName ) { return doNormalize ( fileName , SYSTEM_SEPARATOR , false ) ; } public static String normalizeNoEndSeparator ( final String fileName , final boolean unixSeparator ) { final char separator = unixSeparator ? UNIX_SEPARATOR : WINDOWS_SEPARATOR ; MST[rv.CRCR5Mutator]MSP[N]
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2 ) { return NOT_FOUND ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; MST[rv.ROR4Mutator]MSP[N] posWin = posWin == NOT_FOUND ? posUnix : posWin ;
return indexOfExtension ( fileName ) == NOT_FOUND ; MST[rv.ROR5Mutator]MSP[N] } final String fileExt = getExtension ( fileName ) ; for ( final String extension : extensions ) { if ( fileExt . equals ( extension ) ) { return true ; } } return false ; }
for ( int i = 0 ; i < array . length ; i ++ ) { if ( array [ i ] == otherSeparator ) { array [ i ] = separator ; MST[rv.ABSMutator]MSP[N] } } boolean lastIsDirectory = true ;
if ( repeat >= 0 ) { backtrack . push ( new int [] { wcsIdx , repeat } ) ; MST[rv.UOI1Mutator]MSP[S] } } else { if ( ! caseSensitivity . checkRegionMatches ( fileName , textIdx , wcs [ wcsIdx ] ) ) { break; } }
if ( len == 2 || isSeparator ( fileName . charAt ( 2 ) ) == false ) { MST[rv.CRCR4Mutator]MSP[N] return 2 ; } return 3 ; } else if ( ch0 == UNIX_SEPARATOR ) { return 1 ; } return NOT_FOUND ;
public static String normalizeNoEndSeparator ( final String fileName ) { return doNormalize ( fileName , SYSTEM_SEPARATOR , false ) ; } public static String normalizeNoEndSeparator ( final String fileName , final boolean unixSeparator ) { final char separator = unixSeparator ? UNIX_SEPARATOR : WINDOWS_SEPARATOR ; MST[rv.CRCR1Mutator]MSP[N]
anyChars = false ; } else if ( wcs [ wcsIdx ] . equals ( lr_7 ) ) { anyChars = true ; if ( wcsIdx == wcs . length - 1 ) { MST[MathMutator]MSP[N] textIdx = fileName . length () ; } } else { if ( anyChars ) {
return isSeparator ( ch0 ) ? 1 : 0 ; MST[InlineConstantMutator]MSP[N] } } public static int indexOfLastSeparator ( final String fileName ) { if ( fileName == null ) { return NOT_FOUND ; } final int lastUnixPos = fileName . lastIndexOf ( UNIX_SEPARATOR ) ;
} else if ( inet6Address . startsWith ( lr_9 ) && ! octetList . isEmpty () ) { octetList . remove ( 0 ) ; } octets = octetList . toArray ( new String [ octetList . size () ] ) ; MST[NonVoidMethodCallMutator]MSP[N] }
return fileName . substring ( index + 1 ) ; } private static void failIfNullBytePresent ( final String path ) { final int len = path . length () ; for ( int i = 0 ; i < len ; i ++ ) { MST[rv.ABSMutator]MSP[N]
if ( octets . length > IPV6_MAX_HEX_GROUPS ) { return false ; } int validOctets = 0 ; int emptyOctets = 0 ; for ( int index = 0 ; index < octets . length ; index ++ ) { MST[rv.CRCR1Mutator]MSP[N] final String octet = octets [ index ] ;
return false ; MST[rv.CRCR6Mutator]MSP[N] } static String [] splitOnTokens ( final String text ) { if ( text . indexOf ( '?' ) == NOT_FOUND && text . indexOf ( '*' ) == NOT_FOUND ) { return new String [] { text } ; }
final int lastWindowsPos = fileName . lastIndexOf ( WINDOWS_SEPARATOR ) ; return Math . max ( lastUnixPos , lastWindowsPos ) ; } public static int indexOfExtension ( final String fileName ) throws IllegalArgumentException { if ( fileName == null ) { return NOT_FOUND ; MST[rv.CRCR2Mutator]MSP[N] }
System . arraycopy ( array , i + 1 , array , prefix , size - i ) ; size -= i + 1 - prefix ; MST[rv.UOI3Mutator]MSP[N] i = prefix + 1 ; } } if ( size <= 0 ) { return EMPTY_STRING ; }
for ( int i = prefix + 1 ; i < size ; i ++ ) { if ( array [ i ] == separator && array [ i - 1 ] == '.' && MST[rv.UOI3Mutator]MSP[N]
|| ( inet6Address . endsWith ( lr_10 ) && ! inet6Address . endsWith ( lr_9 ) ) ) { return false ; MST[rv.CRCR5Mutator]MSP[S] } String [] octets = inet6Address . split ( lr_10 ) ; if ( containsCompressedZeroes ) {
if ( repeat >= 0 ) { backtrack . push ( new int [] { wcsIdx , repeat } ) ; } } else { if ( ! caseSensitivity . checkRegionMatches ( fileName , textIdx , wcs [ wcsIdx ] ) ) { MST[NonVoidMethodCallMutator]MSP[N] break; } }
if ( octets . length > IPV6_MAX_HEX_GROUPS ) { MST[rv.CRCR1Mutator]MSP[N] return false ; } int validOctets = 0 ; int emptyOctets = 0 ; for ( int index = 0 ; index < octets . length ; index ++ ) { final String octet = octets [ index ] ;
for ( int i = prefix + 1 ; i < size ; i ++ ) { if ( array [ i ] == separator && array [ i - 1 ] == '.' && MST[rv.AOR3Mutator]MSP[N]
return doNormalize ( fileName , SYSTEM_SEPARATOR , true ) ; } public static String normalize ( final String fileName , final boolean unixSeparator ) { final char separator = unixSeparator ? UNIX_SEPARATOR : WINDOWS_SEPARATOR ; return doNormalize ( fileName , separator , true ) ; MST[rv.CRCR4Mutator]MSP[S] }
for ( int i = prefix + 1 ; i < size ; i ++ ) { if ( array [ i ] == separator && array [ i - 1 ] == '.' && MST[rv.ROR4Mutator]MSP[N]
return fileName . substring ( index + 1 ) ; } private static void failIfNullBytePresent ( final String path ) { final int len = path . length () ; for ( int i = 0 ; i < len ; i ++ ) { MST[rv.CRCR5Mutator]MSP[N]
if ( array [ j ] == separator ) { System . arraycopy ( array , i + 1 , array , j + 1 , size - i ) ; MST[rv.AOR4Mutator]MSP[N] size -= i - j ; i = j + 1 ; continue outer; } }
if ( path == null || path . indexOf ( UNIX_SEPARATOR ) == NOT_FOUND ) { return path ; } return path . replace ( UNIX_SEPARATOR , WINDOWS_SEPARATOR ) ; MST[InlineConstantMutator]MSP[N] } public static String separatorsToSystem ( final String path ) { if ( path == null ) {
if ( array [ j ] == separator ) { System . arraycopy ( array , i + 1 , array , j + 1 , size - i ) ; MST[rv.UOI4Mutator]MSP[N] size -= i - j ; i = j + 1 ; continue outer; } }
if ( repeat >= 0 ) { backtrack . push ( new int [] { wcsIdx , repeat } ) ; } } else { if ( ! caseSensitivity . checkRegionMatches ( fileName , textIdx , wcs [ wcsIdx ] ) ) { MST[rv.UOI1Mutator]MSP[N] break; } }
for ( int i = 1 ; i <= 4 ; i ++ ) { final String ipSegment = m . group ( i ) ; final int iIpSegment = Integer . parseInt ( ipSegment ) ; if ( iIpSegment > IPV4_MAX_OCTET_VALUE ) { return false ; MST[rv.CRCR3Mutator]MSP[N] }
if ( ch == '?' || ch == '*' ) { MST[rv.ROR2Mutator]MSP[N] if ( buffer . length () != 0 ) { list . add ( buffer . toString () ) ; buffer . setLength ( 0 ) ; } if ( ch == '?' ) {
if ( array [ i ] == separator && array [ i - 1 ] == '.' && array [ i - 2 ] == '.' && MST[rv.AOR2Mutator]MSP[N] ( i == prefix + 2 || array [ i - 3 ] == separator ) ) {
if ( array [ j ] == separator ) { System . arraycopy ( array , i + 1 , array , j + 1 , size - i ) ; MST[rv.UOI1Mutator]MSP[N] size -= i - j ; i = j + 1 ; continue outer; } }
static boolean isSystemWindows () { return SYSTEM_SEPARATOR == WINDOWS_SEPARATOR ; } private static boolean isSeparator ( final char ch ) { return ch == UNIX_SEPARATOR || ch == WINDOWS_SEPARATOR ; MST[InlineConstantMutator]MSP[N] } public static String normalize ( final String fileName ) {
if ( array [ size - 1 ] != separator ) { array [ size ++ ] = separator ; lastIsDirectory = false ; } for ( int i = prefix + 1 ; i < size ; i ++ ) { MST[rv.AOR4Mutator]MSP[N]
System . arraycopy ( array , i + 1 , array , prefix , size - i ) ; size -= i + 1 - prefix ; i = prefix + 1 ; MST[rv.CRCR2Mutator]MSP[N] } } if ( size <= 0 ) { return EMPTY_STRING ; }
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND ) { MST[rv.CRCR2Mutator]MSP[N] return len + 1 ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ; return Math . min ( posUnix , posWin ) + 1 ; }
anyChars = false ; MST[rv.CRCR6Mutator]MSP[S] } else if ( wcs [ wcsIdx ] . equals ( lr_7 ) ) { anyChars = true ; if ( wcsIdx == wcs . length - 1 ) { textIdx = fileName . length () ; } } else { if ( anyChars ) {
octetInt = Integer . parseInt ( octet , BASE_16 ) ; } catch ( final NumberFormatException e ) { return false ; } if ( octetInt < 0 || octetInt > MAX_UNSIGNED_SHORT ) { MST[rv.ABSMutator]MSP[N] return false ; } } validOctets ++ ; }
if ( len == 0 ) { return 0 ; } char ch0 = fileName . charAt ( 0 ) ; if ( ch0 == ':' ) { MST[rv.CRCR3Mutator]MSP[N] return NOT_FOUND ; } if ( len == 1 ) { if ( ch0 == '~' ) { return 2 ; }
if ( extension == null || extension . isEmpty () ) { return indexOfExtension ( fileName ) == NOT_FOUND ; MST[rv.CRCR1Mutator]MSP[N] } final String fileExt = getExtension ( fileName ) ; return fileExt . equals ( extension ) ; }
if ( i == prefix + 2 ) { return null ; } if ( i == size - 1 ) { MST[rv.AOR1Mutator]MSP[S] lastIsDirectory = true ; } int j ; for ( j = i - 4 ; j >= prefix ; j -- ) {
if ( path == null || path . indexOf ( UNIX_SEPARATOR ) == NOT_FOUND ) { return path ; } return path . replace ( UNIX_SEPARATOR , WINDOWS_SEPARATOR ) ; MST[experimental.NakedReceiverMutator]MSP[N] } public static String separatorsToSystem ( final String path ) { if ( path == null ) {
|| ( inet6Address . endsWith ( lr_10 ) && ! inet6Address . endsWith ( lr_9 ) ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] return false ; } String [] octets = inet6Address . split ( lr_10 ) ; if ( containsCompressedZeroes ) {
if ( octet . length () == 0 ) { emptyOctets ++ ; if ( emptyOctets > 1 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] return false ; } } else { emptyOctets = 0 ; if ( index == octets . length - 1 && octet . contains ( lr_12 ) ) {
final int lastSeparator = indexOfLastSeparator ( fileName ) ; return lastSeparator > extensionPos ? NOT_FOUND : extensionPos ; MST[rv.CRCR1Mutator]MSP[N] } public static String getPrefix ( final String fileName ) { if ( fileName == null ) { return null ; } final int len = getPrefixLength ( fileName ) ;
if ( index == NOT_FOUND ) { return fileName ; } return fileName . substring ( 0 , index ) ; } public static boolean equals ( final String fileName1 , final String fileName2 ) { return equals ( fileName1 , fileName2 , false , IOCase . SENSITIVE ) ; MST[InlineConstantMutator]MSP[S]
if ( len == 0 ) { return 0 ; } char ch0 = fileName . charAt ( 0 ) ; if ( ch0 == ':' ) { return NOT_FOUND ; } if ( len == 1 ) { MST[rv.UOI1Mutator]MSP[N] if ( ch0 == '~' ) { return 2 ; }
if ( i == prefix + 2 ) { return null ; } if ( i == size - 1 ) { MST[rv.UOI4Mutator]MSP[N] lastIsDirectory = true ; } int j ; for ( j = i - 4 ; j >= prefix ; j -- ) {
public static boolean directoryContains ( final String canonicalParent , final String canonicalChild ) throws IOException { if ( canonicalParent == null ) { throw new IllegalArgumentException ( lr_1 ) ; } if ( canonicalChild == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] return false ; }
if ( len < 0 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[S] return null ; } if ( len > fileName . length () ) { failIfNullBytePresent ( fileName + UNIX_SEPARATOR ) ; return fileName + UNIX_SEPARATOR ; } final String path = fileName . substring ( 0 , len ) ;
return indexOfExtension ( fileName ) == NOT_FOUND ; MST[NegateConditionalsMutator]MSP[N] } final String fileExt = getExtension ( fileName ) ; for ( final String extension : extensions ) { if ( fileExt . equals ( extension ) ) { return true ; } } return false ; }
( i == prefix + 1 || array [ i - 2 ] == separator ) ) { if ( i == size - 1 ) { MST[rv.CRCR5Mutator]MSP[N] lastIsDirectory = true ; }
final int index = indexOfLastSeparator ( fileName ) ; if ( index < 0 ) { return fileName . substring ( 0 , prefix ) ; } int end = index + ( includeSeparator ? 1 : 0 ) ; MST[rv.CRCR5Mutator]MSP[S] if ( end == 0 ) { end ++ ;
System . arraycopy ( array , i + 1 , array , i - 1 , size - i ) ; size -= 2 ; i -- ; } } outer: for ( int i = prefix + 2 ; i < size ; i ++ ) { MST[NegateConditionalsMutator]MSP[N]
if ( validOctets > IPV6_MAX_HEX_GROUPS || ( validOctets < IPV6_MAX_HEX_GROUPS && ! containsCompressedZeroes ) ) { return false ; } return true ; } private static boolean isRFC3986HostName ( final String name ) { final String [] parts = name . split ( lr_13 , - 1 ) ; MST[InlineConstantMutator]MSP[N]
return indexOfExtension ( fileName ) == NOT_FOUND ; MST[rv.CRCR2Mutator]MSP[N] } final String fileExt = getExtension ( fileName ) ; for ( final String extension : extensions ) { if ( fileExt . equals ( extension ) ) { return true ; } } return false ; }
if ( array [ i ] == separator && array [ i - 1 ] == separator ) { MST[rv.UOI4Mutator]MSP[N] System . arraycopy ( array , i , array , i - 1 , size - i ) ; size -- ; i -- ; } }
if ( i == prefix + 2 ) { return null ; } if ( i == size - 1 ) { lastIsDirectory = true ; } int j ; for ( j = i - 4 ; j >= prefix ; j -- ) { MST[rv.UOI4Mutator]MSP[N]
final int pos = Math . min ( posUnix , posWin ) + 1 ; MST[rv.CRCR2Mutator]MSP[N] final String hostnamePart = fileName . substring ( 2 , pos - 1 ) ; return isValidHostName ( hostnamePart ) ? pos : NOT_FOUND ; } else {
if ( array [ i ] == separator && array [ i - 1 ] == separator ) { MST[rv.AOR4Mutator]MSP[N] System . arraycopy ( array , i , array , i - 1 , size - i ) ; size -- ; i -- ; } }
return indexOfExtension ( fileName ) == NOT_FOUND ; } final String fileExt = getExtension ( fileName ) ; for ( final String extension : extensions ) { if ( fileExt . equals ( extension ) ) { MST[rv.ROR2Mutator]MSP[N] return true ; } } return false ; }
if ( array [ i ] == separator && array [ i - 1 ] == separator ) { MST[rv.ROR5Mutator]MSP[N] System . arraycopy ( array , i , array , i - 1 , size - i ) ; size -- ; i -- ; } }
} else if ( isSeparator ( ch0 ) && isSeparator ( ch1 ) ) { MST[rv.ROR5Mutator]MSP[N] int posUnix = fileName . indexOf ( UNIX_SEPARATOR , 2 ) ; int posWin = fileName . indexOf ( WINDOWS_SEPARATOR , 2 ) ;
final char [] array = text . toCharArray () ; final ArrayList < String > list = new ArrayList <> () ; final StringBuilder buffer = new StringBuilder () ; char prevChar = 0 ; for ( final char ch : array ) { MST[rv.UOI2Mutator]MSP[N]
public static boolean isExtension ( final String fileName , final Collection < String > extensions ) { if ( fileName == null ) { return false ; } failIfNullBytePresent ( fileName ) ; if ( extensions == null || extensions . isEmpty () ) { MST[rv.ROR1Mutator]MSP[N]
if ( i == prefix + 2 ) { return null ; } if ( i == size - 1 ) { MST[rv.CRCR4Mutator]MSP[S] lastIsDirectory = true ; } int j ; for ( j = i - 4 ; j >= prefix ; j -- ) {
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2 ) { MST[rv.CRCR1Mutator]MSP[N] return NOT_FOUND ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ;
final int pos = Math . min ( posUnix , posWin ) + 1 ; MST[rv.AOR2Mutator]MSP[N] final String hostnamePart = fileName . substring ( 2 , pos - 1 ) ; return isValidHostName ( hostnamePart ) ? pos : NOT_FOUND ; } else {
if ( ch == '?' || ch == '*' ) { if ( buffer . length () != 0 ) { list . add ( buffer . toString () ) ; buffer . setLength ( 0 ) ; } if ( ch == '?' ) { MST[rv.ROR1Mutator]MSP[N]
static boolean isSystemWindows () { return SYSTEM_SEPARATOR == WINDOWS_SEPARATOR ; } private static boolean isSeparator ( final char ch ) { return ch == UNIX_SEPARATOR || ch == WINDOWS_SEPARATOR ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } public static String normalize ( final String fileName ) {
if ( octets . length > IPV6_MAX_HEX_GROUPS ) { return false ; MST[InlineConstantMutator]MSP[S] } int validOctets = 0 ; int emptyOctets = 0 ; for ( int index = 0 ; index < octets . length ; index ++ ) { final String octet = octets [ index ] ;
if ( len == 2 || isSeparator ( fileName . charAt ( 2 ) ) == false ) { return 2 ; } return 3 ; MST[InlineConstantMutator]MSP[N] } else if ( ch0 == UNIX_SEPARATOR ) { return 1 ; } return NOT_FOUND ;
final char ch = basePath . charAt ( len - 1 ) ; if ( isSeparator ( ch ) ) { MST[rv.UOI2Mutator]MSP[N] return normalize ( basePath + fullFileNameToAdd ) ; } return normalize ( basePath + '/' + fullFileNameToAdd ) ; }
if ( ch == '?' || ch == '*' ) { MST[rv.CRCR6Mutator]MSP[N] if ( buffer . length () != 0 ) { list . add ( buffer . toString () ) ; buffer . setLength ( 0 ) ; } if ( ch == '?' ) {
if ( octet . length () == 0 ) { emptyOctets ++ ; if ( emptyOctets > 1 ) { return false ; } } else { emptyOctets = 0 ; if ( index == octets . length - 1 && octet . contains ( lr_12 ) ) { MST[rv.ROR5Mutator]MSP[N]
return doNormalize ( fileName , separator , false ) ; MST[EmptyObjectReturnValsMutator]MSP[N] } private static String doNormalize ( final String fileName , final char separator , final boolean keepSeparator ) { if ( fileName == null ) { return null ; } failIfNullBytePresent ( fileName ) ;
textIdx += wcs [ wcsIdx ] . length () ; anyChars = false ; } wcsIdx ++ ; } if ( wcsIdx == wcs . length && textIdx == fileName . length () ) { MST[rv.ROR3Mutator]MSP[S] return true ; } } while ( backtrack . size () > 0 );
if ( containsCompressedZeroes && ( inet6Address . indexOf ( lr_9 ) != inet6Address . lastIndexOf ( lr_9 ) ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return false ; } if ( ( inet6Address . startsWith ( lr_10 ) && ! inet6Address . startsWith ( lr_9 ) )
if ( i == prefix + 2 ) { return null ; } if ( i == size - 1 ) { lastIsDirectory = true ; } int j ; for ( j = i - 4 ; j >= prefix ; j -- ) { MST[rv.UOI2Mutator]MSP[N]
final int lastWindowsPos = fileName . lastIndexOf ( WINDOWS_SEPARATOR ) ; MST[rv.CRCR2Mutator]MSP[N] return Math . max ( lastUnixPos , lastWindowsPos ) ; } public static int indexOfExtension ( final String fileName ) throws IllegalArgumentException { if ( fileName == null ) { return NOT_FOUND ; }
octetInt = Integer . parseInt ( octet , BASE_16 ) ; } catch ( final NumberFormatException e ) { return false ; } if ( octetInt < 0 || octetInt > MAX_UNSIGNED_SHORT ) { MST[rv.UOI2Mutator]MSP[N] return false ; } } validOctets ++ ; }
if ( isSystemWindows () ) { MST[NegateConditionalsMutator]MSP[S] final int offset = fileName . indexOf ( ':' , getAdsCriticalOffset ( fileName ) ) ; if ( offset != - 1 ) { throw new IllegalArgumentException ( lr_2 ) ; } } final int extensionPos = fileName . lastIndexOf ( EXTENSION_SEPARATOR ) ;
list . add ( buffer . toString () ) ; } return list . toArray ( new String [ list . size () ] ) ; } private static boolean isValidHostName ( final String name ) { return isIPv6Address ( name ) || isRFC3986HostName ( name ) ; MST[rv.ROR3Mutator]MSP[N] }
if ( i == prefix + 2 ) { return null ; } if ( i == size - 1 ) { lastIsDirectory = true ; } int j ; for ( j = i - 4 ; j >= prefix ; j -- ) { MST[rv.ABSMutator]MSP[N]
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND ) { return len + 1 ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ; return Math . min ( posUnix , posWin ) + 1 ; MST[rv.CRCR4Mutator]MSP[N] }
return doNormalize ( fileName , separator , false ) ; } private static String doNormalize ( final String fileName , final char separator , final boolean keepSeparator ) { if ( fileName == null ) { MST[NegateConditionalsMutator]MSP[N] return null ; } failIfNullBytePresent ( fileName ) ;
System . arraycopy ( array , i + 1 , array , prefix , size - i ) ; MST[rv.CRCR5Mutator]MSP[N] size -= i + 1 - prefix ; i = prefix + 1 ; } } if ( size <= 0 ) { return EMPTY_STRING ; }
if ( array [ size - 1 ] != separator ) { array [ size ++ ] = separator ; lastIsDirectory = false ; } for ( int i = prefix + 1 ; i < size ; i ++ ) { MST[rv.UOI1Mutator]MSP[N]
System . arraycopy ( array , i + 1 , array , i - 1 , size - i ) ; size -= 2 ; i -- ; } } outer: for ( int i = prefix + 2 ; i < size ; i ++ ) { MST[rv.ROR5Mutator]MSP[N]
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND ) { MST[rv.UOI4Mutator]MSP[N] return len + 1 ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ; return Math . min ( posUnix , posWin ) + 1 ; }
private static String doGetPath ( final String fileName , final int separatorAdd ) { if ( fileName == null ) { return null ; MST[ReturnValsMutator]MSP[S] } final int prefix = getPrefixLength ( fileName ) ; if ( prefix < 0 ) { return null ; }
if ( len < 0 ) { return null ; } if ( len > fileName . length () ) { MST[NonVoidMethodCallMutator]MSP[N] failIfNullBytePresent ( fileName + UNIX_SEPARATOR ) ; return fileName + UNIX_SEPARATOR ; } final String path = fileName . substring ( 0 , len ) ;
if ( path . charAt ( i ) == 0 ) { MST[rv.UOI3Mutator]MSP[N] throw new IllegalArgumentException ( lr_3 + lr_4 ) ; } } } public static String getBaseName ( final String fileName ) { return removeExtension ( getName ( fileName ) ) ; }
return wildcardMatch ( fileName , wildcardMatcher , IOCase . SYSTEM ) ; } public static boolean wildcardMatch ( final String fileName , final String wildcardMatcher , IOCase caseSensitivity ) { if ( fileName == null && wildcardMatcher == null ) { return true ; MST[ReturnValsMutator]MSP[N] }
final int index = indexOfLastSeparator ( fileName ) ; if ( index < 0 ) { return fileName . substring ( 0 , prefix ) ; } int end = index + ( includeSeparator ? 1 : 0 ) ; MST[rv.AOD1Mutator]MSP[S] if ( end == 0 ) { end ++ ;
if ( fileName == null || wildcardMatcher == null ) { return false ; } if ( caseSensitivity == null ) { MST[rv.ROR5Mutator]MSP[N] caseSensitivity = IOCase . SENSITIVE ; } final String [] wcs = splitOnTokens ( wildcardMatcher ) ; boolean anyChars = false ; int textIdx = 0 ;
if ( array [ j ] == separator ) { System . arraycopy ( array , i + 1 , array , j + 1 , size - i ) ; size -= i - j ; i = j + 1 ; MST[rv.AOR1Mutator]MSP[N] continue outer; } }
if ( repeat >= 0 ) { backtrack . push ( new int [] { wcsIdx , repeat } ) ; } } else { if ( ! caseSensitivity . checkRegionMatches ( fileName , textIdx , wcs [ wcsIdx ] ) ) { MST[rv.ABSMutator]MSP[N] break; } }
return isSeparator ( ch0 ) ? 1 : 0 ; } if ( ch0 == '~' ) { int posUnix = fileName . indexOf ( UNIX_SEPARATOR , 1 ) ; int posWin = fileName . indexOf ( WINDOWS_SEPARATOR , 1 ) ; MST[rv.CRCR3Mutator]MSP[N]
if ( array [ i ] == separator && array [ i - 1 ] == separator ) { System . arraycopy ( array , i , array , i - 1 , size - i ) ; MST[rv.UOI2Mutator]MSP[N] size -- ; i -- ; } }
if ( path == null || path . indexOf ( WINDOWS_SEPARATOR ) == NOT_FOUND ) { MST[rv.CRCR4Mutator]MSP[N] return path ; } return path . replace ( WINDOWS_SEPARATOR , UNIX_SEPARATOR ) ; } public static String separatorsToWindows ( final String path ) {
if ( octets . length > IPV6_MAX_HEX_GROUPS ) { return false ; } int validOctets = 0 ; int emptyOctets = 0 ; for ( int index = 0 ; index < octets . length ; index ++ ) { MST[rv.ROR3Mutator]MSP[N] final String octet = octets [ index ] ;
if ( len == 0 ) { return 0 ; } char ch0 = fileName . charAt ( 0 ) ; MST[rv.CRCR1Mutator]MSP[N] if ( ch0 == ':' ) { return NOT_FOUND ; } if ( len == 1 ) { if ( ch0 == '~' ) { return 2 ; }
private static boolean isIPv4Address ( final String name ) { final Matcher m = IPV4_PATTERN . matcher ( name ) ; if ( ! m . matches () || m . groupCount () != 4 ) { MST[rv.ROR4Mutator]MSP[N] return false ; }
if ( len == 0 ) { return 0 ; } char ch0 = fileName . charAt ( 0 ) ; if ( ch0 == ':' ) { return NOT_FOUND ; } if ( len == 1 ) { MST[rv.ROR2Mutator]MSP[N] if ( ch0 == '~' ) { return 2 ; }
return false ; } static String [] splitOnTokens ( final String text ) { if ( text . indexOf ( '?' ) == NOT_FOUND && text . indexOf ( '*' ) == NOT_FOUND ) { return new String [] { text } ; MST[rv.CRCR5Mutator]MSP[N] }
if ( array [ j ] == separator ) { System . arraycopy ( array , i + 1 , array , j + 1 , size - i ) ; size -= i - j ; MST[rv.UOI2Mutator]MSP[N] i = j + 1 ; continue outer; } }
for ( int i = prefix + 1 ; i < size ; i ++ ) { MST[rv.UOI2Mutator]MSP[N] if ( array [ i ] == separator && array [ i - 1 ] == '.' &&
return isSeparator ( ch0 ) ? 1 : 0 ; } } public static int indexOfLastSeparator ( final String fileName ) { if ( fileName == null ) { return NOT_FOUND ; MST[InlineConstantMutator]MSP[N] } final int lastUnixPos = fileName . lastIndexOf ( UNIX_SEPARATOR ) ;
if ( array [ j ] == separator ) { System . arraycopy ( array , i + 1 , array , j + 1 , size - i ) ; size -= i - j ; i = j + 1 ; MST[rv.UOI4Mutator]MSP[N] continue outer; } }
return fileName . substring ( index + 1 ) ; MST[rv.CRCR4Mutator]MSP[S] } private static void failIfNullBytePresent ( final String path ) { final int len = path . length () ; for ( int i = 0 ; i < len ; i ++ ) {
if ( validOctets > IPV6_MAX_HEX_GROUPS || ( validOctets < IPV6_MAX_HEX_GROUPS && ! containsCompressedZeroes ) ) { MST[NegateConditionalsMutator]MSP[N] return false ; } return true ; } private static boolean isRFC3986HostName ( final String name ) { final String [] parts = name . split ( lr_13 , - 1 ) ;
static boolean isSystemWindows () { return SYSTEM_SEPARATOR == WINDOWS_SEPARATOR ; } private static boolean isSeparator ( final char ch ) { return ch == UNIX_SEPARATOR || ch == WINDOWS_SEPARATOR ; MST[ReturnValsMutator]MSP[N] } public static String normalize ( final String fileName ) {
list . add ( buffer . toString () ) ; } return list . toArray ( new String [ list . size () ] ) ; } private static boolean isValidHostName ( final String name ) { return isIPv6Address ( name ) || isRFC3986HostName ( name ) ; MST[NonVoidMethodCallMutator]MSP[N] }
if ( extension == null || extension . isEmpty () ) { return indexOfExtension ( fileName ) == NOT_FOUND ; MST[rv.CRCR6Mutator]MSP[N] } final String fileExt = getExtension ( fileName ) ; return fileExt . equals ( extension ) ; }
anyChars = false ; } else if ( wcs [ wcsIdx ] . equals ( lr_7 ) ) { anyChars = true ; if ( wcsIdx == wcs . length - 1 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] textIdx = fileName . length () ; } } else { if ( anyChars ) {
if ( array [ i ] == separator && array [ i - 1 ] == '.' && array [ i - 2 ] == '.' && MST[rv.CRCR4Mutator]MSP[N] ( i == prefix + 2 || array [ i - 3 ] == separator ) ) {
return indexOfExtension ( fileName ) == NOT_FOUND ; } final String fileExt = getExtension ( fileName ) ; for ( final String extension : extensions ) { MST[rv.ABSMutator]MSP[N] if ( fileExt . equals ( extension ) ) { return true ; } } return false ; }
static boolean isSystemWindows () { return SYSTEM_SEPARATOR == WINDOWS_SEPARATOR ; MST[rv.CRCR6Mutator]MSP[N] } private static boolean isSeparator ( final char ch ) { return ch == UNIX_SEPARATOR || ch == WINDOWS_SEPARATOR ; } public static String normalize ( final String fileName ) {
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return NOT_FOUND ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ;
final char ch1 = fileName . charAt ( 1 ) ; if ( ch1 == ':' ) { ch0 = Character . toUpperCase ( ch0 ) ; MST[rv.UOI3Mutator]MSP[N] if ( ch0 >= 'A' && ch0 <= 'Z' ) {
return false ; } static String [] splitOnTokens ( final String text ) { if ( text . indexOf ( '?' ) == NOT_FOUND && text . indexOf ( '*' ) == NOT_FOUND ) { MST[rv.ROR4Mutator]MSP[N] return new String [] { text } ; }
return false ; } static String [] splitOnTokens ( final String text ) { if ( text . indexOf ( '?' ) == NOT_FOUND && text . indexOf ( '*' ) == NOT_FOUND ) { MST[NonVoidMethodCallMutator]MSP[N] return new String [] { text } ; }
return doNormalize ( fileName , SYSTEM_SEPARATOR , true ) ; } public static String normalize ( final String fileName , final boolean unixSeparator ) { final char separator = unixSeparator ? UNIX_SEPARATOR : WINDOWS_SEPARATOR ; MST[rv.ROR5Mutator]MSP[N] return doNormalize ( fileName , separator , true ) ; }
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2 ) { return NOT_FOUND ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
public static String normalizeNoEndSeparator ( final String fileName ) { return doNormalize ( fileName , SYSTEM_SEPARATOR , false ) ; MST[ArgumentPropagationMutator]MSP[N] } public static String normalizeNoEndSeparator ( final String fileName , final boolean unixSeparator ) { final char separator = unixSeparator ? UNIX_SEPARATOR : WINDOWS_SEPARATOR ;
return doNormalize ( fileName , SYSTEM_SEPARATOR , true ) ; } public static String normalize ( final String fileName , final boolean unixSeparator ) { final char separator = unixSeparator ? UNIX_SEPARATOR : WINDOWS_SEPARATOR ; MST[rv.CRCR3Mutator]MSP[N] return doNormalize ( fileName , separator , true ) ; }
anyChars = false ; } else if ( wcs [ wcsIdx ] . equals ( lr_7 ) ) { anyChars = true ; if ( wcsIdx == wcs . length - 1 ) { textIdx = fileName . length () ; } } else { if ( anyChars ) { MST[rv.UOI2Mutator]MSP[N]
if ( ipSegment . length () > 1 && ipSegment . startsWith ( lr_8 ) ) { return false ; MST[InlineConstantMutator]MSP[N] } } return true ; } private static boolean isIPv6Address ( final String inet6Address ) { final boolean containsCompressedZeroes = inet6Address . contains ( lr_9 ) ;
if ( array [ j ] == separator ) { System . arraycopy ( array , i + 1 , array , j + 1 , size - i ) ; MST[rv.AOR1Mutator]MSP[N] size -= i - j ; i = j + 1 ; continue outer; } }
final char ch1 = fileName . charAt ( 1 ) ; if ( ch1 == ':' ) { ch0 = Character . toUpperCase ( ch0 ) ; if ( ch0 >= 'A' && ch0 <= 'Z' ) { MST[rv.CRCR6Mutator]MSP[S]
final int index = indexOfLastSeparator ( fileName ) ; if ( index < 0 ) { return fileName . substring ( 0 , prefix ) ; MST[rv.ABSMutator]MSP[N] } int end = index + ( includeSeparator ? 1 : 0 ) ; if ( end == 0 ) { end ++ ;
if ( len == 2 || isSeparator ( fileName . charAt ( 2 ) ) == false ) { return 2 ; } return 3 ; } else if ( ch0 == UNIX_SEPARATOR ) { MST[rv.UOI3Mutator]MSP[N] return 1 ; } return NOT_FOUND ;
if ( IOCase . SYSTEM . checkEquals ( canonicalParent , canonicalChild ) ) { return false ; } return IOCase . SYSTEM . checkStartsWith ( canonicalChild , canonicalParent ) ; MST[ReturnValsMutator]MSP[N] } public static String separatorsToUnix ( final String path ) {
if ( path == null || path . indexOf ( WINDOWS_SEPARATOR ) == NOT_FOUND ) { return path ; } return path . replace ( WINDOWS_SEPARATOR , UNIX_SEPARATOR ) ; MST[rv.CRCR2Mutator]MSP[N] } public static String separatorsToWindows ( final String path ) {
int wcsIdx = 0 ; final Stack < int [] > backtrack = new Stack <> () ; do { if ( backtrack . size () > 0 ) { MST[rv.ROR5Mutator]MSP[N] final int [] array = backtrack . pop () ; wcsIdx = array [ 0 ] ;
if ( len == 0 ) { return 0 ; } char ch0 = fileName . charAt ( 0 ) ; if ( ch0 == ':' ) { return NOT_FOUND ; } if ( len == 1 ) { if ( ch0 == '~' ) { return 2 ; MST[InlineConstantMutator]MSP[S] }
if ( validOctets > IPV6_MAX_HEX_GROUPS || ( validOctets < IPV6_MAX_HEX_GROUPS && ! containsCompressedZeroes ) ) { MST[InlineConstantMutator]MSP[N] return false ; } return true ; } private static boolean isRFC3986HostName ( final String name ) { final String [] parts = name . split ( lr_13 , - 1 ) ;
list . add ( buffer . toString () ) ; MST[NonVoidMethodCallMutator]MSP[N] } return list . toArray ( new String [ list . size () ] ) ; } private static boolean isValidHostName ( final String name ) { return isIPv6Address ( name ) || isRFC3986HostName ( name ) ; }
if ( octets . length > IPV6_MAX_HEX_GROUPS ) { MST[rv.ROR1Mutator]MSP[N] return false ; } int validOctets = 0 ; int emptyOctets = 0 ; for ( int index = 0 ; index < octets . length ; index ++ ) { final String octet = octets [ index ] ;
public static String getExtension ( final String fileName ) throws IllegalArgumentException { if ( fileName == null ) { return null ; } final int index = indexOfExtension ( fileName ) ; if ( index == NOT_FOUND ) { MST[rv.CRCR2Mutator]MSP[N] return EMPTY_STRING ; }
if ( array [ i ] == separator && array [ i - 1 ] == separator ) { System . arraycopy ( array , i , array , i - 1 , size - i ) ; MST[rv.CRCR5Mutator]MSP[N] size -- ; i -- ; } }
if ( len == 0 ) { return 0 ; } char ch0 = fileName . charAt ( 0 ) ; if ( ch0 == ':' ) { return NOT_FOUND ; } if ( len == 1 ) { MST[rv.ABSMutator]MSP[N] if ( ch0 == '~' ) { return 2 ; }
if ( repeat >= 0 ) { backtrack . push ( new int [] { wcsIdx , repeat } ) ; MST[rv.CRCR3Mutator]MSP[S] } } else { if ( ! caseSensitivity . checkRegionMatches ( fileName , textIdx , wcs [ wcsIdx ] ) ) { break; } }
final int index = indexOfLastSeparator ( fileName ) ; final int endIndex = index + separatorAdd ; if ( prefix >= fileName . length () || index < 0 || prefix >= endIndex ) { MST[rv.ROR1Mutator]MSP[N] return EMPTY_STRING ; }
if ( path == null || path . indexOf ( WINDOWS_SEPARATOR ) == NOT_FOUND ) { return path ; } return path . replace ( WINDOWS_SEPARATOR , UNIX_SEPARATOR ) ; MST[experimental.NakedReceiverMutator]MSP[N] } public static String separatorsToWindows ( final String path ) {
final int index = indexOfLastSeparator ( fileName ) ; final int endIndex = index + separatorAdd ; if ( prefix >= fileName . length () || index < 0 || prefix >= endIndex ) { MST[rv.UOI3Mutator]MSP[N] return EMPTY_STRING ; }
return fileName . substring ( index + 1 ) ; } private static void failIfNullBytePresent ( final String path ) { final int len = path . length () ; for ( int i = 0 ; i < len ; i ++ ) { MST[rv.UOI1Mutator]MSP[N]
System . arraycopy ( array , i + 1 , array , prefix , size - i ) ; size -= i + 1 - prefix ; MST[rv.UOI2Mutator]MSP[N] i = prefix + 1 ; } } if ( size <= 0 ) { return EMPTY_STRING ; }
return new String ( array , 0 , size - 1 ) ; } public static String concat ( final String basePath , final String fullFileNameToAdd ) { final int prefix = getPrefixLength ( fullFileNameToAdd ) ; if ( prefix < 0 ) { MST[rv.UOI2Mutator]MSP[S] return null ; }
for ( int i = 0 ; i < array . length ; i ++ ) { if ( array [ i ] == otherSeparator ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] array [ i ] = separator ; } } boolean lastIsDirectory = true ;
return new String ( array , 0 , size - 1 ) ; MST[InlineConstantMutator]MSP[N] } public static String concat ( final String basePath , final String fullFileNameToAdd ) { final int prefix = getPrefixLength ( fullFileNameToAdd ) ; if ( prefix < 0 ) { return null ; }
return false ; MST[BooleanTrueReturnValsMutator]MSP[N] } static String [] splitOnTokens ( final String text ) { if ( text . indexOf ( '?' ) == NOT_FOUND && text . indexOf ( '*' ) == NOT_FOUND ) { return new String [] { text } ; }
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND ) { MST[rv.CRCR4Mutator]MSP[N] return len + 1 ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ; return Math . min ( posUnix , posWin ) + 1 ; }
if ( array [ j ] == separator ) { System . arraycopy ( array , i + 1 , array , j + 1 , size - i ) ; MST[rv.ABSMutator]MSP[N] size -= i - j ; i = j + 1 ; continue outer; } }
return doNormalize ( fileName , SYSTEM_SEPARATOR , true ) ; } public static String normalize ( final String fileName , final boolean unixSeparator ) { final char separator = unixSeparator ? UNIX_SEPARATOR : WINDOWS_SEPARATOR ; MST[NegateConditionalsMutator]MSP[N] return doNormalize ( fileName , separator , true ) ; }
if ( extension == null || extension . isEmpty () ) { return indexOfExtension ( fileName ) == NOT_FOUND ; MST[rv.CRCR3Mutator]MSP[S] } final String fileExt = getExtension ( fileName ) ; return fileExt . equals ( extension ) ; }
int wcsIdx = 0 ; final Stack < int [] > backtrack = new Stack <> () ; do { if ( backtrack . size () > 0 ) { final int [] array = backtrack . pop () ; wcsIdx = array [ 0 ] ; MST[rv.UOI1Mutator]MSP[N]
System . arraycopy ( array , i + 1 , array , i - 1 , size - i ) ; MST[rv.UOI2Mutator]MSP[N] size -= 2 ; i -- ; } } outer: for ( int i = prefix + 2 ; i < size ; i ++ ) {
return indexOfExtension ( fileName ) == NOT_FOUND ; } final String fileExt = getExtension ( fileName ) ; for ( final String extension : extensions ) { if ( fileExt . equals ( extension ) ) { return true ; MST[rv.CRCR5Mutator]MSP[N] } } return false ; }
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2 ) { MST[rv.CRCR5Mutator]MSP[N] return NOT_FOUND ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ;
public static boolean isExtension ( final String fileName , final String ... extensions ) { if ( fileName == null ) { return false ; MST[rv.CRCR6Mutator]MSP[N] } failIfNullBytePresent ( fileName ) ; if ( extensions == null || extensions . length == 0 ) {
for ( int i = 0 ; i < parts . length ; i ++ ) { if ( parts [ i ] . length () == 0 ) { MST[rv.ROR1Mutator]MSP[N] return i == parts . length - 1 ; }
if ( i == prefix + 2 ) { return null ; } if ( i == size - 1 ) { lastIsDirectory = true ; } int j ; for ( j = i - 4 ; j >= prefix ; j -- ) { MST[rv.CRCR2Mutator]MSP[N]
int size = fileName . length () ; if ( size == 0 ) { return fileName ; } final int prefix = getPrefixLength ( fileName ) ; if ( prefix < 0 ) { MST[ConditionalsBoundaryMutator]MSP[N] return null ; }
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND ) { MST[rv.ROR2Mutator]MSP[N] return len + 1 ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ; return Math . min ( posUnix , posWin ) + 1 ; }
textIdx = array [ 1 ] ; anyChars = true ; } while ( wcsIdx < wcs . length ) { if ( wcs [ wcsIdx ] . equals ( lr_6 ) ) { textIdx ++ ; if ( textIdx > fileName . length () ) { MST[rv.ROR2Mutator]MSP[N] break; }
|| ( inet6Address . endsWith ( lr_10 ) && ! inet6Address . endsWith ( lr_9 ) ) ) { MST[NonVoidMethodCallMutator]MSP[S] return false ; } String [] octets = inet6Address . split ( lr_10 ) ; if ( containsCompressedZeroes ) {
if ( isSystemWindows () ) { MST[rv.ROR5Mutator]MSP[S] final int offset = fileName . indexOf ( ':' , getAdsCriticalOffset ( fileName ) ) ; if ( offset != - 1 ) { throw new IllegalArgumentException ( lr_2 ) ; } } final int extensionPos = fileName . lastIndexOf ( EXTENSION_SEPARATOR ) ;
final int index = indexOfLastSeparator ( fileName ) ; if ( index < 0 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] return fileName . substring ( 0 , prefix ) ; } int end = index + ( includeSeparator ? 1 : 0 ) ; if ( end == 0 ) { end ++ ;
System . arraycopy ( array , i + 1 , array , prefix , size - i ) ; MST[rv.AOR2Mutator]MSP[N] size -= i + 1 - prefix ; i = prefix + 1 ; } } if ( size <= 0 ) { return EMPTY_STRING ; }
final int prefix = getPrefixLength ( fileName ) ; if ( prefix < 0 ) { return null ; } if ( prefix >= fileName . length () ) { if ( includeSeparator ) { return getPrefix ( fileName ) ; MST[NonVoidMethodCallMutator]MSP[N] } return fileName ; }
public static String getExtension ( final String fileName ) throws IllegalArgumentException { if ( fileName == null ) { return null ; } final int index = indexOfExtension ( fileName ) ; if ( index == NOT_FOUND ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return EMPTY_STRING ; }
if ( len == 0 ) { return 0 ; } char ch0 = fileName . charAt ( 0 ) ; if ( ch0 == ':' ) { MST[rv.ROR3Mutator]MSP[N] return NOT_FOUND ; } if ( len == 1 ) { if ( ch0 == '~' ) { return 2 ; }
if ( isSystemWindows () ) { final int offset = fileName . indexOf ( ':' , getAdsCriticalOffset ( fileName ) ) ; if ( offset != - 1 ) { throw new IllegalArgumentException ( lr_2 ) ; } } final int extensionPos = fileName . lastIndexOf ( EXTENSION_SEPARATOR ) ; MST[InlineConstantMutator]MSP[N]
if ( len < 0 ) { return null ; } if ( len > fileName . length () ) { failIfNullBytePresent ( fileName + UNIX_SEPARATOR ) ; return fileName + UNIX_SEPARATOR ; } final String path = fileName . substring ( 0 , len ) ; MST[rv.UOI2Mutator]MSP[N]
textIdx = array [ 1 ] ; anyChars = true ; } while ( wcsIdx < wcs . length ) { MST[rv.ROR2Mutator]MSP[N] if ( wcs [ wcsIdx ] . equals ( lr_6 ) ) { textIdx ++ ; if ( textIdx > fileName . length () ) { break; }
if ( ch == '?' || ch == '*' ) { MST[rv.ABSMutator]MSP[N] if ( buffer . length () != 0 ) { list . add ( buffer . toString () ) ; buffer . setLength ( 0 ) ; } if ( ch == '?' ) {
( i == prefix + 1 || array [ i - 2 ] == separator ) ) { if ( i == size - 1 ) { MST[rv.AOR2Mutator]MSP[N] lastIsDirectory = true ; }
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2 ) { MST[InlineConstantMutator]MSP[N] return NOT_FOUND ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ;
final int pos = Math . min ( posUnix , posWin ) + 1 ; final String hostnamePart = fileName . substring ( 2 , pos - 1 ) ; MST[rv.UOI2Mutator]MSP[N] return isValidHostName ( hostnamePart ) ? pos : NOT_FOUND ; } else {
if ( i == prefix + 2 ) { return null ; } if ( i == size - 1 ) { lastIsDirectory = true ; } int j ; for ( j = i - 4 ; j >= prefix ; j -- ) { MST[rv.ROR4Mutator]MSP[N]
final int prefix = getPrefixLength ( fileName ) ; if ( prefix < 0 ) { return null ; } if ( prefix >= fileName . length () ) { if ( includeSeparator ) { MST[rv.ROR3Mutator]MSP[N] return getPrefix ( fileName ) ; } return fileName ; }
if ( i == prefix + 2 ) { return null ; } if ( i == size - 1 ) { lastIsDirectory = true ; } int j ; for ( j = i - 4 ; j >= prefix ; j -- ) { MST[rv.UOI3Mutator]MSP[N]
if ( path == null || path . indexOf ( UNIX_SEPARATOR ) == NOT_FOUND ) { MST[rv.CRCR2Mutator]MSP[N] return path ; } return path . replace ( UNIX_SEPARATOR , WINDOWS_SEPARATOR ) ; } public static String separatorsToSystem ( final String path ) { if ( path == null ) {
final char [] array = text . toCharArray () ; final ArrayList < String > list = new ArrayList <> () ; final StringBuilder buffer = new StringBuilder () ; char prevChar = 0 ; for ( final char ch : array ) { MST[rv.UOI1Mutator]MSP[N]
if ( array [ i ] == separator && array [ i - 1 ] == separator ) { System . arraycopy ( array , i , array , i - 1 , size - i ) ; MST[rv.AOD2Mutator]MSP[N] size -- ; i -- ; } }
System . arraycopy ( array , i + 1 , array , prefix , size - i ) ; size -= i + 1 - prefix ; MST[MathMutator]MSP[N] i = prefix + 1 ; } } if ( size <= 0 ) { return EMPTY_STRING ; }
if ( fileName == null || wildcardMatcher == null ) { return false ; } if ( caseSensitivity == null ) { MST[NegateConditionalsMutator]MSP[N] caseSensitivity = IOCase . SENSITIVE ; } final String [] wcs = splitOnTokens ( wildcardMatcher ) ; boolean anyChars = false ; int textIdx = 0 ;
} else if ( isSeparator ( ch0 ) && isSeparator ( ch1 ) ) { int posUnix = fileName . indexOf ( UNIX_SEPARATOR , 2 ) ; MST[rv.CRCR5Mutator]MSP[N] int posWin = fileName . indexOf ( WINDOWS_SEPARATOR , 2 ) ;
for ( int i = 1 ; i <= 4 ; i ++ ) { final String ipSegment = m . group ( i ) ; final int iIpSegment = Integer . parseInt ( ipSegment ) ; if ( iIpSegment > IPV4_MAX_OCTET_VALUE ) { MST[ConditionalsBoundaryMutator]MSP[N] return false ; }
if ( prefix > 0 ) { MST[rv.ROR3Mutator]MSP[N] return normalize ( fullFileNameToAdd ) ; } if ( basePath == null ) { return null ; } final int len = basePath . length () ; if ( len == 0 ) { return normalize ( fullFileNameToAdd ) ; }
return wildcardMatch ( fileName , wildcardMatcher , IOCase . SYSTEM ) ; MST[BooleanTrueReturnValsMutator]MSP[S] } public static boolean wildcardMatch ( final String fileName , final String wildcardMatcher , IOCase caseSensitivity ) { if ( fileName == null && wildcardMatcher == null ) { return true ; }
return isSeparator ( ch0 ) ? 1 : 0 ; MST[rv.UOI3Mutator]MSP[N] } if ( ch0 == '~' ) { int posUnix = fileName . indexOf ( UNIX_SEPARATOR , 1 ) ; int posWin = fileName . indexOf ( WINDOWS_SEPARATOR , 1 ) ;
System . arraycopy ( array , i + 1 , array , prefix , size - i ) ; size -= i + 1 - prefix ; MST[rv.CRCR2Mutator]MSP[N] i = prefix + 1 ; } } if ( size <= 0 ) { return EMPTY_STRING ; }
for ( int i = 0 ; i < parts . length ; i ++ ) { MST[rv.CRCR1Mutator]MSP[N] if ( parts [ i ] . length () == 0 ) { return i == parts . length - 1 ; }
if ( path == null || path . indexOf ( UNIX_SEPARATOR ) == NOT_FOUND ) { MST[rv.ROR4Mutator]MSP[N] return path ; } return path . replace ( UNIX_SEPARATOR , WINDOWS_SEPARATOR ) ; } public static String separatorsToSystem ( final String path ) { if ( path == null ) {
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND ) { return len + 1 ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ; MST[rv.UOI2Mutator]MSP[N] return Math . min ( posUnix , posWin ) + 1 ; }
return false ; } static String [] splitOnTokens ( final String text ) { if ( text . indexOf ( '?' ) == NOT_FOUND && text . indexOf ( '*' ) == NOT_FOUND ) { MST[rv.CRCR4Mutator]MSP[N] return new String [] { text } ; }
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND ) { MST[rv.ABSMutator]MSP[N] return len + 1 ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ; return Math . min ( posUnix , posWin ) + 1 ; }
return isSeparator ( ch0 ) ? 1 : 0 ; MST[rv.CRCR1Mutator]MSP[N] } } public static int indexOfLastSeparator ( final String fileName ) { if ( fileName == null ) { return NOT_FOUND ; } final int lastUnixPos = fileName . lastIndexOf ( UNIX_SEPARATOR ) ;
for ( int i = prefix + 1 ; i < size ; i ++ ) { MST[rv.UOI3Mutator]MSP[N] if ( array [ i ] == separator && array [ i - 1 ] == '.' &&
String fileName1 , String fileName2 , final boolean normalized , IOCase caseSensitivity ) { if ( fileName1 == null || fileName2 == null ) { return fileName1 == null && fileName2 == null ; MST[rv.CRCR2Mutator]MSP[N] } if ( normalized ) { fileName1 = normalize ( fileName1 ) ;
if ( len == 2 || isSeparator ( fileName . charAt ( 2 ) ) == false ) { return 2 ; } return 3 ; } else if ( ch0 == UNIX_SEPARATOR ) { MST[rv.CRCR3Mutator]MSP[N] return 1 ; } return NOT_FOUND ;
if ( array [ i ] == separator && array [ i - 1 ] == '.' && array [ i - 2 ] == '.' && MST[rv.CRCR5Mutator]MSP[N] ( i == prefix + 2 || array [ i - 3 ] == separator ) ) {
public static String getFullPathNoEndSeparator ( final String fileName ) { return doGetFullPath ( fileName , false ) ; } private static String doGetFullPath ( final String fileName , final boolean includeSeparator ) { if ( fileName == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return null ; }
if ( array [ j ] == separator ) { System . arraycopy ( array , i + 1 , array , j + 1 , size - i ) ; MST[rv.CRCR4Mutator]MSP[N] size -= i - j ; i = j + 1 ; continue outer; } }
System . arraycopy ( array , i + 1 , array , prefix , size - i ) ; MST[rv.ABSMutator]MSP[N] size -= i + 1 - prefix ; i = prefix + 1 ; } } if ( size <= 0 ) { return EMPTY_STRING ; }
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2 ) { MST[rv.ROR1Mutator]MSP[N] return NOT_FOUND ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ;
failIfNullBytePresent ( path ) ; return path ; } public static String getPath ( final String fileName ) { return doGetPath ( fileName , 1 ) ; MST[rv.CRCR6Mutator]MSP[S] } public static String getPathNoEndSeparator ( final String fileName ) { return doGetPath ( fileName , 0 ) ; }
final int index = indexOfLastSeparator ( fileName ) ; final int endIndex = index + separatorAdd ; MST[rv.UOI1Mutator]MSP[N] if ( prefix >= fileName . length () || index < 0 || prefix >= endIndex ) { return EMPTY_STRING ; }
textIdx = array [ 1 ] ; anyChars = true ; MST[rv.CRCR4Mutator]MSP[N] } while ( wcsIdx < wcs . length ) { if ( wcs [ wcsIdx ] . equals ( lr_6 ) ) { textIdx ++ ; if ( textIdx > fileName . length () ) { break; }
if ( validOctets > IPV6_MAX_HEX_GROUPS || ( validOctets < IPV6_MAX_HEX_GROUPS && ! containsCompressedZeroes ) ) { MST[rv.ROR1Mutator]MSP[N] return false ; } return true ; } private static boolean isRFC3986HostName ( final String name ) { final String [] parts = name . split ( lr_13 , - 1 ) ;
if ( array [ i ] == separator && array [ i - 1 ] == '.' && array [ i - 2 ] == '.' && MST[rv.AOR1Mutator]MSP[N] ( i == prefix + 2 || array [ i - 3 ] == separator ) ) {
final char ch1 = fileName . charAt ( 1 ) ; MST[rv.CRCR5Mutator]MSP[N] if ( ch1 == ':' ) { ch0 = Character . toUpperCase ( ch0 ) ; if ( ch0 >= 'A' && ch0 <= 'Z' ) {
System . arraycopy ( array , i + 1 , array , i - 1 , size - i ) ; MST[rv.AOR3Mutator]MSP[N] size -= 2 ; i -- ; } } outer: for ( int i = prefix + 2 ; i < size ; i ++ ) {
if ( array [ i ] == separator && array [ i - 1 ] == '.' && array [ i - 2 ] == '.' && MST[rv.CRCR1Mutator]MSP[N] ( i == prefix + 2 || array [ i - 3 ] == separator ) ) {
System . arraycopy ( array , i + 1 , array , prefix , size - i ) ; size -= i + 1 - prefix ; i = prefix + 1 ; } } if ( size <= 0 ) { MST[ConditionalsBoundaryMutator]MSP[S] return EMPTY_STRING ; }
if ( array [ i ] == separator && array [ i - 1 ] == separator ) { MST[NegateConditionalsMutator]MSP[N] System . arraycopy ( array , i , array , i - 1 , size - i ) ; size -- ; i -- ; } }
System . arraycopy ( array , i + 1 , array , prefix , size - i ) ; size -= i + 1 - prefix ; i = prefix + 1 ; MST[rv.ABSMutator]MSP[N] } } if ( size <= 0 ) { return EMPTY_STRING ; }
return isSeparator ( ch0 ) ? 1 : 0 ; } if ( ch0 == '~' ) { int posUnix = fileName . indexOf ( UNIX_SEPARATOR , 1 ) ; int posWin = fileName . indexOf ( WINDOWS_SEPARATOR , 1 ) ; MST[rv.CRCR2Mutator]MSP[N]
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2 ) { return NOT_FOUND ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ; MST[rv.UOI1Mutator]MSP[N]
if ( array [ size - 1 ] != separator ) { array [ size ++ ] = separator ; lastIsDirectory = false ; MST[rv.CRCR5Mutator]MSP[N] } for ( int i = prefix + 1 ; i < size ; i ++ ) {
final char [] array = new char [ size + 2 ] ; MST[rv.AOD2Mutator]MSP[N] fileName . getChars ( 0 , fileName . length () , array , 0 ) ; final char otherSeparator = separator == SYSTEM_SEPARATOR ? OTHER_SEPARATOR : SYSTEM_SEPARATOR ;
return fileName . substring ( index + 1 ) ; } private static void failIfNullBytePresent ( final String path ) { final int len = path . length () ; for ( int i = 0 ; i < len ; i ++ ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N]
} else if ( isSeparator ( ch0 ) && isSeparator ( ch1 ) ) { MST[NegateConditionalsMutator]MSP[N] int posUnix = fileName . indexOf ( UNIX_SEPARATOR , 2 ) ; int posWin = fileName . indexOf ( WINDOWS_SEPARATOR , 2 ) ;
if ( octet . length () == 0 ) { emptyOctets ++ ; if ( emptyOctets > 1 ) { return false ; } } else { emptyOctets = 0 ; MST[rv.CRCR1Mutator]MSP[S] if ( index == octets . length - 1 && octet . contains ( lr_12 ) ) {
final String path = fileName . substring ( prefix , endIndex ) ; MST[rv.ABSMutator]MSP[N] failIfNullBytePresent ( path ) ; return path ; } public static String getFullPath ( final String fileName ) { return doGetFullPath ( fileName , true ) ; }
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2 ) { return NOT_FOUND ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; MST[rv.UOI1Mutator]MSP[N] posWin = posWin == NOT_FOUND ? posUnix : posWin ;
for ( int i = prefix + 1 ; i < size ; i ++ ) { if ( array [ i ] == separator && array [ i - 1 ] == '.' && MST[rv.CRCR6Mutator]MSP[N]
if ( extension == null || extension . isEmpty () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return indexOfExtension ( fileName ) == NOT_FOUND ; } final String fileExt = getExtension ( fileName ) ; return fileExt . equals ( extension ) ; }
if ( validOctets > IPV6_MAX_HEX_GROUPS || ( validOctets < IPV6_MAX_HEX_GROUPS && ! containsCompressedZeroes ) ) { return false ; } return true ; } private static boolean isRFC3986HostName ( final String name ) { final String [] parts = name . split ( lr_13 , - 1 ) ; MST[rv.CRCR5Mutator]MSP[N]
if ( len == 2 || isSeparator ( fileName . charAt ( 2 ) ) == false ) { return 2 ; MST[rv.CRCR5Mutator]MSP[N] } return 3 ; } else if ( ch0 == UNIX_SEPARATOR ) { return 1 ; } return NOT_FOUND ;
if ( ! isIPv4Address ( octet ) ) { return false ; MST[InlineConstantMutator]MSP[N] } validOctets += 2 ; continue; } if ( octet . length () > IPV6_MAX_HEX_DIGITS_PER_GROUP ) { return false ; } int octetInt = 0 ; try {
for ( int i = prefix + 1 ; i < size ; i ++ ) { if ( array [ i ] == separator && array [ i - 1 ] == '.' && MST[rv.CRCR2Mutator]MSP[N]
list . add ( lr_6 ) ; } else if ( prevChar != '*' ) { MST[rv.ROR4Mutator]MSP[N] list . add ( lr_7 ) ; } } else { buffer . append ( ch ) ; } prevChar = ch ; } if ( buffer . length () != 0 ) {
static boolean isSystemWindows () { return SYSTEM_SEPARATOR == WINDOWS_SEPARATOR ; } private static boolean isSeparator ( final char ch ) { return ch == UNIX_SEPARATOR || ch == WINDOWS_SEPARATOR ; MST[rv.UOI1Mutator]MSP[N] } public static String normalize ( final String fileName ) {
return indexOfExtension ( fileName ) == NOT_FOUND ; } final String fileExt = getExtension ( fileName ) ; for ( final String extension : extensions ) { if ( fileExt . equals ( extension ) ) { return true ; MST[rv.CRCR6Mutator]MSP[N] } } return false ; }
public static String getExtension ( final String fileName ) throws IllegalArgumentException { if ( fileName == null ) { return null ; MST[EmptyObjectReturnValsMutator]MSP[S] } final int index = indexOfExtension ( fileName ) ; if ( index == NOT_FOUND ) { return EMPTY_STRING ; }
for ( int i = 0 ; i < parts . length ; i ++ ) { if ( parts [ i ] . length () == 0 ) { MST[rv.ABSMutator]MSP[N] return i == parts . length - 1 ; }
int wcsIdx = 0 ; final Stack < int [] > backtrack = new Stack <> () ; do { if ( backtrack . size () > 0 ) { MST[NegateConditionalsMutator]MSP[N] final int [] array = backtrack . pop () ; wcsIdx = array [ 0 ] ;
private static boolean isIPv4Address ( final String name ) { final Matcher m = IPV4_PATTERN . matcher ( name ) ; if ( ! m . matches () || m . groupCount () != 4 ) { MST[rv.CRCR4Mutator]MSP[S] return false ; }
if ( path == null || path . indexOf ( WINDOWS_SEPARATOR ) == NOT_FOUND ) { MST[rv.ROR4Mutator]MSP[N] return path ; } return path . replace ( WINDOWS_SEPARATOR , UNIX_SEPARATOR ) ; } public static String separatorsToWindows ( final String path ) {
if ( ipSegment . length () > 1 && ipSegment . startsWith ( lr_8 ) ) { MST[NegateConditionalsMutator]MSP[S] return false ; } } return true ; } private static boolean isIPv6Address ( final String inet6Address ) { final boolean containsCompressedZeroes = inet6Address . contains ( lr_9 ) ;
return doNormalize ( fileName , separator , false ) ; } private static String doNormalize ( final String fileName , final char separator , final boolean keepSeparator ) { if ( fileName == null ) { MST[rv.ROR5Mutator]MSP[N] return null ; } failIfNullBytePresent ( fileName ) ;
final char ch = basePath . charAt ( len - 1 ) ; MST[rv.UOI1Mutator]MSP[N] if ( isSeparator ( ch ) ) { return normalize ( basePath + fullFileNameToAdd ) ; } return normalize ( basePath + '/' + fullFileNameToAdd ) ; }
final int lastSeparator = indexOfLastSeparator ( fileName ) ; return lastSeparator > extensionPos ? NOT_FOUND : extensionPos ; } public static String getPrefix ( final String fileName ) { if ( fileName == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return null ; } final int len = getPrefixLength ( fileName ) ;
int wcsIdx = 0 ; final Stack < int [] > backtrack = new Stack <> () ; do { if ( backtrack . size () > 0 ) { final int [] array = backtrack . pop () ; wcsIdx = array [ 0 ] ; MST[rv.CRCR6Mutator]MSP[S]
textIdx += wcs [ wcsIdx ] . length () ; anyChars = false ; } wcsIdx ++ ; } if ( wcsIdx == wcs . length && textIdx == fileName . length () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return true ; } } while ( backtrack . size () > 0 );
octetInt = Integer . parseInt ( octet , BASE_16 ) ; } catch ( final NumberFormatException e ) { return false ; } if ( octetInt < 0 || octetInt > MAX_UNSIGNED_SHORT ) { MST[rv.ROR3Mutator]MSP[N] return false ; } } validOctets ++ ; }
for ( int i = prefix + 1 ; i < size ; i ++ ) { if ( array [ i ] == separator && array [ i - 1 ] == '.' && MST[rv.UOI3Mutator]MSP[N]
for ( int i = prefix + 1 ; i < size ; i ++ ) { MST[rv.CRCR2Mutator]MSP[S] if ( array [ i ] == separator && array [ i - 1 ] == '.' &&
if ( array [ j ] == separator ) { System . arraycopy ( array , i + 1 , array , j + 1 , size - i ) ; size -= i - j ; i = j + 1 ; MST[rv.CRCR4Mutator]MSP[N] continue outer; } }
return indexOfExtension ( fileName ) == NOT_FOUND ; MST[rv.CRCR3Mutator]MSP[N] } final String fileExt = getExtension ( fileName ) ; for ( final String extension : extensions ) { if ( fileExt . equals ( extension ) ) { return true ; } } return false ; }
int size = fileName . length () ; if ( size == 0 ) { return fileName ; MST[ReturnValsMutator]MSP[N] } final int prefix = getPrefixLength ( fileName ) ; if ( prefix < 0 ) { return null ; }
} return fileName . substring ( 0 , end ) ; MST[rv.CRCR3Mutator]MSP[N] } public static String getName ( final String fileName ) { if ( fileName == null ) { return null ; } failIfNullBytePresent ( fileName ) ; final int index = indexOfLastSeparator ( fileName ) ;
int size = fileName . length () ; if ( size == 0 ) { MST[rv.UOI3Mutator]MSP[N] return fileName ; } final int prefix = getPrefixLength ( fileName ) ; if ( prefix < 0 ) { return null ; }
return fileName . substring ( index + 1 ) ; MST[rv.AOD1Mutator]MSP[N] } private static void failIfNullBytePresent ( final String path ) { final int len = path . length () ; for ( int i = 0 ; i < len ; i ++ ) {
return fileName . substring ( index + 1 ) ; MST[rv.UOI4Mutator]MSP[N] } private static void failIfNullBytePresent ( final String path ) { final int len = path . length () ; for ( int i = 0 ; i < len ; i ++ ) {
if ( validOctets > IPV6_MAX_HEX_GROUPS || ( validOctets < IPV6_MAX_HEX_GROUPS && ! containsCompressedZeroes ) ) { MST[rv.ROR5Mutator]MSP[N] return false ; } return true ; } private static boolean isRFC3986HostName ( final String name ) { final String [] parts = name . split ( lr_13 , - 1 ) ;
return doNormalize ( fileName , separator , false ) ; MST[rv.CRCR5Mutator]MSP[S] } private static String doNormalize ( final String fileName , final char separator , final boolean keepSeparator ) { if ( fileName == null ) { return null ; } failIfNullBytePresent ( fileName ) ;
final int pos = Math . min ( posUnix , posWin ) + 1 ; final String hostnamePart = fileName . substring ( 2 , pos - 1 ) ; return isValidHostName ( hostnamePart ) ? pos : NOT_FOUND ; MST[rv.CRCR5Mutator]MSP[N] } else {
if ( octets . length > IPV6_MAX_HEX_GROUPS ) { MST[ConditionalsBoundaryMutator]MSP[N] return false ; } int validOctets = 0 ; int emptyOctets = 0 ; for ( int index = 0 ; index < octets . length ; index ++ ) { final String octet = octets [ index ] ;
anyChars = false ; } else if ( wcs [ wcsIdx ] . equals ( lr_7 ) ) { MST[rv.ABSMutator]MSP[N] anyChars = true ; if ( wcsIdx == wcs . length - 1 ) { textIdx = fileName . length () ; } } else { if ( anyChars ) {
System . arraycopy ( array , i + 1 , array , prefix , size - i ) ; size -= i + 1 - prefix ; MST[rv.AOR3Mutator]MSP[N] i = prefix + 1 ; } } if ( size <= 0 ) { return EMPTY_STRING ; }
if ( len == 0 ) { return 0 ; } char ch0 = fileName . charAt ( 0 ) ; if ( ch0 == ':' ) { return NOT_FOUND ; MST[PrimitiveReturnsMutator]MSP[N] } if ( len == 1 ) { if ( ch0 == '~' ) { return 2 ; }
if ( octets . length > IPV6_MAX_HEX_GROUPS ) { return false ; } int validOctets = 0 ; int emptyOctets = 0 ; for ( int index = 0 ; index < octets . length ; index ++ ) { MST[rv.CRCR3Mutator]MSP[N] final String octet = octets [ index ] ;
if ( ch == '?' || ch == '*' ) { if ( buffer . length () != 0 ) { list . add ( buffer . toString () ) ; buffer . setLength ( 0 ) ; } if ( ch == '?' ) { MST[rv.UOI1Mutator]MSP[S]
if ( array [ i ] == separator && array [ i - 1 ] == separator ) { System . arraycopy ( array , i , array , i - 1 , size - i ) ; MST[rv.CRCR4Mutator]MSP[N] size -- ; i -- ; } }
final int index = indexOfLastSeparator ( fileName ) ; final int endIndex = index + separatorAdd ; if ( prefix >= fileName . length () || index < 0 || prefix >= endIndex ) { MST[rv.ABSMutator]MSP[N] return EMPTY_STRING ; }
if ( len == 2 || isSeparator ( fileName . charAt ( 2 ) ) == false ) { return 2 ; } return 3 ; MST[rv.CRCR1Mutator]MSP[N] } else if ( ch0 == UNIX_SEPARATOR ) { return 1 ; } return NOT_FOUND ;
if ( ! isIPv4Address ( octet ) ) { MST[NegateConditionalsMutator]MSP[S] return false ; } validOctets += 2 ; continue; } if ( octet . length () > IPV6_MAX_HEX_DIGITS_PER_GROUP ) { return false ; } int octetInt = 0 ; try {
failIfNullBytePresent ( path ) ; return path ; } public static String getPath ( final String fileName ) { return doGetPath ( fileName , 1 ) ; MST[InlineConstantMutator]MSP[S] } public static String getPathNoEndSeparator ( final String fileName ) { return doGetPath ( fileName , 0 ) ; }
for ( int i = prefix + 1 ; i < size ; i ++ ) { if ( array [ i ] == separator && array [ i - 1 ] == '.' && MST[rv.AOR2Mutator]MSP[N]
if ( len < 0 ) { return null ; } if ( len > fileName . length () ) { failIfNullBytePresent ( fileName + UNIX_SEPARATOR ) ; MST[NonVoidMethodCallMutator]MSP[N] return fileName + UNIX_SEPARATOR ; } final String path = fileName . substring ( 0 , len ) ;
if ( octets . length > IPV6_MAX_HEX_GROUPS ) { MST[rv.CRCR3Mutator]MSP[N] return false ; } int validOctets = 0 ; int emptyOctets = 0 ; for ( int index = 0 ; index < octets . length ; index ++ ) { final String octet = octets [ index ] ;
final int pos = Math . min ( posUnix , posWin ) + 1 ; final String hostnamePart = fileName . substring ( 2 , pos - 1 ) ; return isValidHostName ( hostnamePart ) ? pos : NOT_FOUND ; MST[NegateConditionalsMutator]MSP[N] } else {
private static String doGetPath ( final String fileName , final int separatorAdd ) { if ( fileName == null ) { return null ; } final int prefix = getPrefixLength ( fileName ) ; if ( prefix < 0 ) { MST[rv.ROR2Mutator]MSP[N] return null ; }
if ( validOctets > IPV6_MAX_HEX_GROUPS || ( validOctets < IPV6_MAX_HEX_GROUPS && ! containsCompressedZeroes ) ) { MST[rv.ROR3Mutator]MSP[N] return false ; } return true ; } private static boolean isRFC3986HostName ( final String name ) { final String [] parts = name . split ( lr_13 , - 1 ) ;
if ( prefix > 0 ) { return normalize ( fullFileNameToAdd ) ; } if ( basePath == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return null ; } final int len = basePath . length () ; if ( len == 0 ) { return normalize ( fullFileNameToAdd ) ; }
return new String ( array , 0 , size - 1 ) ; } public static String concat ( final String basePath , final String fullFileNameToAdd ) { final int prefix = getPrefixLength ( fullFileNameToAdd ) ; if ( prefix < 0 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[S] return null ; }
if ( array [ i ] == separator && array [ i - 1 ] == '.' && array [ i - 2 ] == '.' && MST[rv.UOI3Mutator]MSP[N] ( i == prefix + 2 || array [ i - 3 ] == separator ) ) {
} return fileName . substring ( 0 , end ) ; MST[rv.UOI4Mutator]MSP[N] } public static String getName ( final String fileName ) { if ( fileName == null ) { return null ; } failIfNullBytePresent ( fileName ) ; final int index = indexOfLastSeparator ( fileName ) ;
for ( int i = 1 ; i <= 4 ; i ++ ) { final String ipSegment = m . group ( i ) ; MST[rv.UOI1Mutator]MSP[N] final int iIpSegment = Integer . parseInt ( ipSegment ) ; if ( iIpSegment > IPV4_MAX_OCTET_VALUE ) { return false ; }
private static String doGetPath ( final String fileName , final int separatorAdd ) { if ( fileName == null ) { return null ; } final int prefix = getPrefixLength ( fileName ) ; if ( prefix < 0 ) { MST[rv.UOI1Mutator]MSP[N] return null ; }
if ( fileName == null || wildcardMatcher == null ) { MST[rv.ROR5Mutator]MSP[N] return false ; } if ( caseSensitivity == null ) { caseSensitivity = IOCase . SENSITIVE ; } final String [] wcs = splitOnTokens ( wildcardMatcher ) ; boolean anyChars = false ; int textIdx = 0 ;
final int index = indexOfLastSeparator ( fileName ) ; if ( index < 0 ) { return fileName . substring ( 0 , prefix ) ; } int end = index + ( includeSeparator ? 1 : 0 ) ; if ( end == 0 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] end ++ ;
} else if ( isSeparator ( ch0 ) && isSeparator ( ch1 ) ) { int posUnix = fileName . indexOf ( UNIX_SEPARATOR , 2 ) ; int posWin = fileName . indexOf ( WINDOWS_SEPARATOR , 2 ) ; MST[rv.CRCR2Mutator]MSP[N]
final int lastWindowsPos = fileName . lastIndexOf ( WINDOWS_SEPARATOR ) ; return Math . max ( lastUnixPos , lastWindowsPos ) ; } public static int indexOfExtension ( final String fileName ) throws IllegalArgumentException { if ( fileName == null ) { return NOT_FOUND ; MST[rv.CRCR4Mutator]MSP[N] }
if ( octets . length > IPV6_MAX_HEX_GROUPS ) { return false ; } int validOctets = 0 ; int emptyOctets = 0 ; for ( int index = 0 ; index < octets . length ; index ++ ) { MST[rv.UOI4Mutator]MSP[N] final String octet = octets [ index ] ;
if ( ! REG_NAME_PART_PATTERN . matcher ( parts [ i ] ) . matches () ) { return false ; } } return true ; MST[InlineConstantMutator]MSP[N] }
System . arraycopy ( array , i + 1 , array , prefix , size - i ) ; MST[InlineConstantMutator]MSP[N] size -= i + 1 - prefix ; i = prefix + 1 ; } } if ( size <= 0 ) { return EMPTY_STRING ; }
if ( array [ i ] == separator && array [ i - 1 ] == '.' && array [ i - 2 ] == '.' && MST[rv.ROR5Mutator]MSP[N] ( i == prefix + 2 || array [ i - 3 ] == separator ) ) {
if ( ! isIPv4Address ( octet ) ) { return false ; } validOctets += 2 ; continue; } if ( octet . length () > IPV6_MAX_HEX_DIGITS_PER_GROUP ) { MST[rv.ROR1Mutator]MSP[N] return false ; } int octetInt = 0 ; try {
static boolean isSystemWindows () { return SYSTEM_SEPARATOR == WINDOWS_SEPARATOR ; } private static boolean isSeparator ( final char ch ) { return ch == UNIX_SEPARATOR || ch == WINDOWS_SEPARATOR ; MST[rv.UOI4Mutator]MSP[N] } public static String normalize ( final String fileName ) {
if ( repeat >= 0 ) { backtrack . push ( new int [] { wcsIdx , repeat } ) ; MST[rv.CRCR6Mutator]MSP[S] } } else { if ( ! caseSensitivity . checkRegionMatches ( fileName , textIdx , wcs [ wcsIdx ] ) ) { break; } }
System . arraycopy ( array , i + 1 , array , prefix , size - i ) ; size -= i + 1 - prefix ; MST[rv.AOR2Mutator]MSP[N] i = prefix + 1 ; } } if ( size <= 0 ) { return EMPTY_STRING ; }
anyChars = false ; } else if ( wcs [ wcsIdx ] . equals ( lr_7 ) ) { MST[rv.ROR4Mutator]MSP[N] anyChars = true ; if ( wcsIdx == wcs . length - 1 ) { textIdx = fileName . length () ; } } else { if ( anyChars ) {
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return NOT_FOUND ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ;
return new String ( array , 0 , size - 1 ) ; } public static String concat ( final String basePath , final String fullFileNameToAdd ) { final int prefix = getPrefixLength ( fullFileNameToAdd ) ; if ( prefix < 0 ) { MST[ConditionalsBoundaryMutator]MSP[N] return null ; }
if ( len == 2 || isSeparator ( fileName . charAt ( 2 ) ) == false ) { MST[rv.UOI1Mutator]MSP[N] return 2 ; } return 3 ; } else if ( ch0 == UNIX_SEPARATOR ) { return 1 ; } return NOT_FOUND ;
failIfNullBytePresent ( path ) ; return path ; } public static String getPath ( final String fileName ) { return doGetPath ( fileName , 1 ) ; } public static String getPathNoEndSeparator ( final String fileName ) { return doGetPath ( fileName , 0 ) ; MST[EmptyObjectReturnValsMutator]MSP[N] }
textIdx = array [ 1 ] ; anyChars = true ; } while ( wcsIdx < wcs . length ) { if ( wcs [ wcsIdx ] . equals ( lr_6 ) ) { textIdx ++ ; if ( textIdx > fileName . length () ) { MST[rv.UOI2Mutator]MSP[N] break; }
if ( array [ i ] == separator && array [ i - 1 ] == '.' && array [ i - 2 ] == '.' && MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] ( i == prefix + 2 || array [ i - 3 ] == separator ) ) {
final int index = indexOfLastSeparator ( fileName ) ; final int endIndex = index + separatorAdd ; if ( prefix >= fileName . length () || index < 0 || prefix >= endIndex ) { MST[rv.UOI2Mutator]MSP[S] return EMPTY_STRING ; }
return indexOfExtension ( fileName ) == NOT_FOUND ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } final String fileExt = getExtension ( fileName ) ; for ( final String extension : extensions ) { if ( fileExt . equals ( extension ) ) { return true ; } } return false ; }
if ( array [ size - 1 ] != separator ) { array [ size ++ ] = separator ; lastIsDirectory = false ; } for ( int i = prefix + 1 ; i < size ; i ++ ) { MST[rv.UOI2Mutator]MSP[N]
list . add ( lr_6 ) ; } else if ( prevChar != '*' ) { list . add ( lr_7 ) ; } } else { buffer . append ( ch ) ; } prevChar = ch ; } if ( buffer . length () != 0 ) { MST[rv.ROR5Mutator]MSP[N]
for ( int i = prefix + 1 ; i < size ; i ++ ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] if ( array [ i ] == separator && array [ i - 1 ] == '.' &&
public static String getExtension ( final String fileName ) throws IllegalArgumentException { if ( fileName == null ) { return null ; } final int index = indexOfExtension ( fileName ) ; if ( index == NOT_FOUND ) { MST[rv.ROR2Mutator]MSP[N] return EMPTY_STRING ; }
final char ch1 = fileName . charAt ( 1 ) ; if ( ch1 == ':' ) { MST[rv.ROR2Mutator]MSP[N] ch0 = Character . toUpperCase ( ch0 ) ; if ( ch0 >= 'A' && ch0 <= 'Z' ) {
if ( repeat >= 0 ) { backtrack . push ( new int [] { wcsIdx , repeat } ) ; } } else { if ( ! caseSensitivity . checkRegionMatches ( fileName , textIdx , wcs [ wcsIdx ] ) ) { MST[rv.ROR5Mutator]MSP[N] break; } }
return fileName . substring ( index + 1 ) ; MST[rv.UOI2Mutator]MSP[N] } private static void failIfNullBytePresent ( final String path ) { final int len = path . length () ; for ( int i = 0 ; i < len ; i ++ ) {
System . arraycopy ( array , i + 1 , array , i - 1 , size - i ) ; MST[rv.AOR2Mutator]MSP[N] size -= 2 ; i -- ; } } outer: for ( int i = prefix + 2 ; i < size ; i ++ ) {
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2 ) { return NOT_FOUND ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ; MST[rv.ROR5Mutator]MSP[N]
return indexOfExtension ( fileName ) == NOT_FOUND ; } final String fileExt = getExtension ( fileName ) ; for ( final String extension : extensions ) { MST[rv.UOI4Mutator]MSP[N] if ( fileExt . equals ( extension ) ) { return true ; } } return false ; }
final int index = indexOfLastSeparator ( fileName ) ; if ( index < 0 ) { return fileName . substring ( 0 , prefix ) ; } int end = index + ( includeSeparator ? 1 : 0 ) ; MST[rv.UOI2Mutator]MSP[N] if ( end == 0 ) { end ++ ;
fileName2 = normalize ( fileName2 ) ; MST[ArgumentPropagationMutator]MSP[N] if ( fileName1 == null || fileName2 == null ) { throw new NullPointerException ( lr_5 ) ; } } if ( caseSensitivity == null ) { caseSensitivity = IOCase . SENSITIVE ; }
return caseSensitivity . checkEquals ( fileName1 , fileName2 ) ; } public static boolean isExtension ( final String fileName , final String extension ) { if ( fileName == null ) { return false ; } failIfNullBytePresent ( fileName ) ; MST[VoidMethodCallMutator]MSP[S]
if ( i == prefix + 2 ) { return null ; } if ( i == size - 1 ) { lastIsDirectory = true ; } int j ; for ( j = i - 4 ; j >= prefix ; j -- ) { MST[rv.AOR2Mutator]MSP[N]
if ( len < 0 ) { return null ; MST[EmptyObjectReturnValsMutator]MSP[S] } if ( len > fileName . length () ) { failIfNullBytePresent ( fileName + UNIX_SEPARATOR ) ; return fileName + UNIX_SEPARATOR ; } final String path = fileName . substring ( 0 , len ) ;
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2 ) { MST[rv.CRCR1Mutator]MSP[N] return NOT_FOUND ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ;
if ( len == 2 || isSeparator ( fileName . charAt ( 2 ) ) == false ) { MST[rv.ROR4Mutator]MSP[N] return 2 ; } return 3 ; } else if ( ch0 == UNIX_SEPARATOR ) { return 1 ; } return NOT_FOUND ;
return fileName . substring ( index + 1 ) ; MST[MathMutator]MSP[N] } private static int getAdsCriticalOffset ( final String fileName ) { final int offset1 = fileName . lastIndexOf ( SYSTEM_SEPARATOR ) ; final int offset2 = fileName . lastIndexOf ( OTHER_SEPARATOR ) ;
return false ; } static String [] splitOnTokens ( final String text ) { if ( text . indexOf ( '?' ) == NOT_FOUND && text . indexOf ( '*' ) == NOT_FOUND ) { MST[rv.CRCR6Mutator]MSP[N] return new String [] { text } ; }
final char ch = basePath . charAt ( len - 1 ) ; if ( isSeparator ( ch ) ) { MST[rv.UOI4Mutator]MSP[N] return normalize ( basePath + fullFileNameToAdd ) ; } return normalize ( basePath + '/' + fullFileNameToAdd ) ; }
if ( array [ i ] == separator && array [ i - 1 ] == '.' && array [ i - 2 ] == '.' && MST[rv.CRCR4Mutator]MSP[N] ( i == prefix + 2 || array [ i - 3 ] == separator ) ) {
if ( array [ size - 1 ] != separator ) { array [ size ++ ] = separator ; lastIsDirectory = false ; } for ( int i = prefix + 1 ; i < size ; i ++ ) { MST[rv.ABSMutator]MSP[N]
return isSeparator ( ch0 ) ? 1 : 0 ; MST[rv.CRCR5Mutator]MSP[N] } if ( ch0 == '~' ) { int posUnix = fileName . indexOf ( UNIX_SEPARATOR , 1 ) ; int posWin = fileName . indexOf ( WINDOWS_SEPARATOR , 1 ) ;
if ( ipSegment . length () > 1 && ipSegment . startsWith ( lr_8 ) ) { MST[rv.ROR5Mutator]MSP[S] return false ; } } return true ; } private static boolean isIPv6Address ( final String inet6Address ) { final boolean containsCompressedZeroes = inet6Address . contains ( lr_9 ) ;
if ( array [ j ] == separator ) { System . arraycopy ( array , i + 1 , array , j + 1 , size - i ) ; MST[rv.CRCR6Mutator]MSP[N] size -= i - j ; i = j + 1 ; continue outer; } }
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND ) { MST[rv.UOI3Mutator]MSP[N] return len + 1 ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ; return Math . min ( posUnix , posWin ) + 1 ; }
if ( array [ j ] == separator ) { MST[rv.UOI3Mutator]MSP[N] System . arraycopy ( array , i + 1 , array , j + 1 , size - i ) ; size -= i - j ; i = j + 1 ; continue outer; } }
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND ) { MST[rv.UOI2Mutator]MSP[N] return len + 1 ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ; return Math . min ( posUnix , posWin ) + 1 ; }
public static String normalizeNoEndSeparator ( final String fileName ) { return doNormalize ( fileName , SYSTEM_SEPARATOR , false ) ; MST[EmptyObjectReturnValsMutator]MSP[N] } public static String normalizeNoEndSeparator ( final String fileName , final boolean unixSeparator ) { final char separator = unixSeparator ? UNIX_SEPARATOR : WINDOWS_SEPARATOR ;
final int prefix = getPrefixLength ( fileName ) ; if ( prefix < 0 ) { return null ; } if ( prefix >= fileName . length () ) { MST[rv.ROR2Mutator]MSP[N] if ( includeSeparator ) { return getPrefix ( fileName ) ; } return fileName ; }
if ( repeat >= 0 ) { backtrack . push ( new int [] { wcsIdx , repeat } ) ; } } else { if ( ! caseSensitivity . checkRegionMatches ( fileName , textIdx , wcs [ wcsIdx ] ) ) { MST[rv.ROR2Mutator]MSP[N] break; } }
for ( int i = 0 ; i < array . length ; i ++ ) { if ( array [ i ] == otherSeparator ) { array [ i ] = separator ; } } boolean lastIsDirectory = true ; MST[rv.CRCR3Mutator]MSP[S]
if ( path == null || path . indexOf ( UNIX_SEPARATOR ) == NOT_FOUND ) { MST[rv.ROR3Mutator]MSP[N] return path ; } return path . replace ( UNIX_SEPARATOR , WINDOWS_SEPARATOR ) ; } public static String separatorsToSystem ( final String path ) { if ( path == null ) {
if ( size <= prefix ) { return new String ( array , 0 , size ) ; } if ( lastIsDirectory && keepSeparator ) { return new String ( array , 0 , size ) ; MST[rv.CRCR3Mutator]MSP[N] }
public static String getFullPathNoEndSeparator ( final String fileName ) { return doGetFullPath ( fileName , false ) ; } private static String doGetFullPath ( final String fileName , final boolean includeSeparator ) { if ( fileName == null ) { MST[rv.ROR5Mutator]MSP[N] return null ; }
System . arraycopy ( array , i + 1 , array , prefix , size - i ) ; size -= i + 1 - prefix ; i = prefix + 1 ; } } if ( size <= 0 ) { MST[rv.ROR4Mutator]MSP[N] return EMPTY_STRING ; }
if ( octet . length () == 0 ) { MST[NegateConditionalsMutator]MSP[N] emptyOctets ++ ; if ( emptyOctets > 1 ) { return false ; } } else { emptyOctets = 0 ; if ( index == octets . length - 1 && octet . contains ( lr_12 ) ) {
if ( i == prefix + 2 ) { return null ; MST[ReturnValsMutator]MSP[N] } if ( i == size - 1 ) { lastIsDirectory = true ; } int j ; for ( j = i - 4 ; j >= prefix ; j -- ) {
if ( array [ j ] == separator ) { System . arraycopy ( array , i + 1 , array , j + 1 , size - i ) ; size -= i - j ; MST[rv.UOI1Mutator]MSP[N] i = j + 1 ; continue outer; } }
if ( containsCompressedZeroes && ( inet6Address . indexOf ( lr_9 ) != inet6Address . lastIndexOf ( lr_9 ) ) ) { MST[rv.ABSMutator]MSP[N] return false ; } if ( ( inet6Address . startsWith ( lr_10 ) && ! inet6Address . startsWith ( lr_9 ) )
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2 ) { MST[rv.CRCR4Mutator]MSP[N] return NOT_FOUND ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ;
return false ; } static String [] splitOnTokens ( final String text ) { if ( text . indexOf ( '?' ) == NOT_FOUND && text . indexOf ( '*' ) == NOT_FOUND ) { MST[rv.ROR2Mutator]MSP[N] return new String [] { text } ; }
if ( ipSegment . length () > 1 && ipSegment . startsWith ( lr_8 ) ) { MST[rv.CRCR6Mutator]MSP[S] return false ; } } return true ; } private static boolean isIPv6Address ( final String inet6Address ) { final boolean containsCompressedZeroes = inet6Address . contains ( lr_9 ) ;
if ( octet . length () == 0 ) { emptyOctets ++ ; if ( emptyOctets > 1 ) { return false ; } } else { emptyOctets = 0 ; MST[rv.CRCR3Mutator]MSP[N] if ( index == octets . length - 1 && octet . contains ( lr_12 ) ) {
return indexOfExtension ( fileName ) == NOT_FOUND ; } final String fileExt = getExtension ( fileName ) ; for ( final String extension : extensions ) { MST[rv.UOI1Mutator]MSP[N] if ( fileExt . equals ( extension ) ) { return true ; } } return false ; }
return isSeparator ( ch0 ) ? 1 : 0 ; MST[NegateConditionalsMutator]MSP[N] } if ( ch0 == '~' ) { int posUnix = fileName . indexOf ( UNIX_SEPARATOR , 1 ) ; int posWin = fileName . indexOf ( WINDOWS_SEPARATOR , 1 ) ;
if ( len < 0 ) { return null ; } if ( len > fileName . length () ) { failIfNullBytePresent ( fileName + UNIX_SEPARATOR ) ; return fileName + UNIX_SEPARATOR ; MST[ReturnValsMutator]MSP[N] } final String path = fileName . substring ( 0 , len ) ;
if ( array [ i ] == separator && array [ i - 1 ] == separator ) { MST[rv.CRCR6Mutator]MSP[N] System . arraycopy ( array , i , array , i - 1 , size - i ) ; size -- ; i -- ; } }
list . add ( buffer . toString () ) ; } return list . toArray ( new String [ list . size () ] ) ; MST[NullReturnValsMutator]MSP[N] } private static boolean isValidHostName ( final String name ) { return isIPv6Address ( name ) || isRFC3986HostName ( name ) ; }
private static boolean isIPv4Address ( final String name ) { final Matcher m = IPV4_PATTERN . matcher ( name ) ; if ( ! m . matches () || m . groupCount () != 4 ) { MST[rv.ROR1Mutator]MSP[S] return false ; }
for ( int i = prefix + 1 ; i < size ; i ++ ) { MST[rv.AOR2Mutator]MSP[S] if ( array [ i ] == separator && array [ i - 1 ] == '.' &&
if ( extension == null || extension . isEmpty () ) { return indexOfExtension ( fileName ) == NOT_FOUND ; } final String fileExt = getExtension ( fileName ) ; return fileExt . equals ( extension ) ; MST[BooleanFalseReturnValsMutator]MSP[S] }
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2 ) { MST[rv.CRCR2Mutator]MSP[N] return NOT_FOUND ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ;
} else if ( inet6Address . startsWith ( lr_9 ) && ! octetList . isEmpty () ) { octetList . remove ( 0 ) ; } octets = octetList . toArray ( new String [ octetList . size () ] ) ; MST[ArgumentPropagationMutator]MSP[N] }
( i == prefix + 1 || array [ i - 2 ] == separator ) ) { if ( i == size - 1 ) { MST[InlineConstantMutator]MSP[N] lastIsDirectory = true ; }
for ( int i = 0 ; i < parts . length ; i ++ ) { MST[rv.UOI3Mutator]MSP[N] if ( parts [ i ] . length () == 0 ) { return i == parts . length - 1 ; }
if ( repeat >= 0 ) { backtrack . push ( new int [] { wcsIdx , repeat } ) ; MST[rv.CRCR3Mutator]MSP[S] } } else { if ( ! caseSensitivity . checkRegionMatches ( fileName , textIdx , wcs [ wcsIdx ] ) ) { break; } }
textIdx = array [ 1 ] ; anyChars = true ; } while ( wcsIdx < wcs . length ) { if ( wcs [ wcsIdx ] . equals ( lr_6 ) ) { textIdx ++ ; if ( textIdx > fileName . length () ) { MST[rv.ABSMutator]MSP[N] break; }
System . arraycopy ( array , i + 1 , array , i - 1 , size - i ) ; size -= 2 ; i -- ; } } outer: for ( int i = prefix + 2 ; i < size ; i ++ ) { MST[rv.ROR2Mutator]MSP[N]
if ( ch == '?' || ch == '*' ) { if ( buffer . length () != 0 ) { list . add ( buffer . toString () ) ; buffer . setLength ( 0 ) ; MST[VoidMethodCallMutator]MSP[N] } if ( ch == '?' ) {
public static boolean isExtension ( final String fileName , final String ... extensions ) { if ( fileName == null ) { return false ; } failIfNullBytePresent ( fileName ) ; if ( extensions == null || extensions . length == 0 ) { MST[rv.ROR5Mutator]MSP[N]
textIdx = caseSensitivity . checkIndexOf ( fileName , textIdx , wcs [ wcsIdx ] ) ; if ( textIdx == NOT_FOUND ) { break; } final int repeat = caseSensitivity . checkIndexOf ( fileName , textIdx + 1 , wcs [ wcsIdx ] ) ; MST[rv.UOI2Mutator]MSP[N]
for ( int i = prefix + 1 ; i < size ; i ++ ) { if ( array [ i ] == separator && array [ i - 1 ] == '.' && MST[rv.UOI3Mutator]MSP[N]
if ( len == 0 ) { return 0 ; } char ch0 = fileName . charAt ( 0 ) ; if ( ch0 == ':' ) { MST[rv.ROR1Mutator]MSP[N] return NOT_FOUND ; } if ( len == 1 ) { if ( ch0 == '~' ) { return 2 ; }
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return NOT_FOUND ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ;
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND ) { MST[InlineConstantMutator]MSP[N] return len + 1 ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ; return Math . min ( posUnix , posWin ) + 1 ; }
return false ; } static String [] splitOnTokens ( final String text ) { if ( text . indexOf ( '?' ) == NOT_FOUND && text . indexOf ( '*' ) == NOT_FOUND ) { MST[rv.ROR5Mutator]MSP[N] return new String [] { text } ; }
if ( array [ j ] == separator ) { System . arraycopy ( array , i + 1 , array , j + 1 , size - i ) ; size -= i - j ; MST[rv.AOR2Mutator]MSP[N] i = j + 1 ; continue outer; } }
textIdx = array [ 1 ] ; anyChars = true ; } while ( wcsIdx < wcs . length ) { MST[rv.ABSMutator]MSP[N] if ( wcs [ wcsIdx ] . equals ( lr_6 ) ) { textIdx ++ ; if ( textIdx > fileName . length () ) { break; }
if ( array [ j ] == separator ) { System . arraycopy ( array , i + 1 , array , j + 1 , size - i ) ; size -= i - j ; i = j + 1 ; MST[rv.AOR4Mutator]MSP[N] continue outer; } }
if ( len == 0 ) { return 0 ; } char ch0 = fileName . charAt ( 0 ) ; if ( ch0 == ':' ) { return NOT_FOUND ; } if ( len == 1 ) { if ( ch0 == '~' ) { return 2 ; MST[rv.CRCR1Mutator]MSP[N] }
} else if ( isSeparator ( ch0 ) && isSeparator ( ch1 ) ) { MST[rv.ROR3Mutator]MSP[N] int posUnix = fileName . indexOf ( UNIX_SEPARATOR , 2 ) ; int posWin = fileName . indexOf ( WINDOWS_SEPARATOR , 2 ) ;
} else if ( isSeparator ( ch0 ) && isSeparator ( ch1 ) ) { MST[rv.ROR4Mutator]MSP[N] int posUnix = fileName . indexOf ( UNIX_SEPARATOR , 2 ) ; int posWin = fileName . indexOf ( WINDOWS_SEPARATOR , 2 ) ;
} return fileName . substring ( 0 , end ) ; MST[rv.UOI1Mutator]MSP[N] } public static String getName ( final String fileName ) { if ( fileName == null ) { return null ; } failIfNullBytePresent ( fileName ) ; final int index = indexOfLastSeparator ( fileName ) ;
return isSeparator ( ch0 ) ? 1 : 0 ; } if ( ch0 == '~' ) { MST[rv.CRCR2Mutator]MSP[N] int posUnix = fileName . indexOf ( UNIX_SEPARATOR , 1 ) ; int posWin = fileName . indexOf ( WINDOWS_SEPARATOR , 1 ) ;
return indexOfExtension ( fileName ) == NOT_FOUND ; MST[rv.CRCR1Mutator]MSP[N] } final String fileExt = getExtension ( fileName ) ; for ( final String extension : extensions ) { if ( fileExt . equals ( extension ) ) { return true ; } } return false ; }
return indexOfExtension ( fileName ) == NOT_FOUND ; MST[rv.CRCR3Mutator]MSP[S] } final String fileExt = getExtension ( fileName ) ; for ( final String extension : extensions ) { if ( fileExt . equals ( extension ) ) { return true ; } } return false ; }
return isSeparator ( ch0 ) ? 1 : 0 ; } if ( ch0 == '~' ) { int posUnix = fileName . indexOf ( UNIX_SEPARATOR , 1 ) ; MST[rv.CRCR4Mutator]MSP[N] int posWin = fileName . indexOf ( WINDOWS_SEPARATOR , 1 ) ;
textIdx = array [ 1 ] ; anyChars = true ; } while ( wcsIdx < wcs . length ) { if ( wcs [ wcsIdx ] . equals ( lr_6 ) ) { MST[NegateConditionalsMutator]MSP[N] textIdx ++ ; if ( textIdx > fileName . length () ) { break; }
for ( int i = 0 ; i < parts . length ; i ++ ) { if ( parts [ i ] . length () == 0 ) { return i == parts . length - 1 ; MST[rv.AOD2Mutator]MSP[N] }
textIdx = caseSensitivity . checkIndexOf ( fileName , textIdx , wcs [ wcsIdx ] ) ; MST[rv.UOI2Mutator]MSP[N] if ( textIdx == NOT_FOUND ) { break; } final int repeat = caseSensitivity . checkIndexOf ( fileName , textIdx + 1 , wcs [ wcsIdx ] ) ;
final char [] array = text . toCharArray () ; final ArrayList < String > list = new ArrayList <> () ; final StringBuilder buffer = new StringBuilder () ; char prevChar = 0 ; MST[rv.CRCR5Mutator]MSP[N] for ( final char ch : array ) {
return indexOfExtension ( fileName ) == NOT_FOUND ; MST[ReturnValsMutator]MSP[N] } final String fileExt = getExtension ( fileName ) ; for ( final String extension : extensions ) { if ( fileExt . equals ( extension ) ) { return true ; } } return false ; }
if ( array [ j ] == separator ) { System . arraycopy ( array , i + 1 , array , j + 1 , size - i ) ; size -= i - j ; MST[rv.UOI4Mutator]MSP[N] i = j + 1 ; continue outer; } }
if ( array [ size - 1 ] != separator ) { array [ size ++ ] = separator ; lastIsDirectory = false ; } for ( int i = prefix + 1 ; i < size ; i ++ ) { MST[rv.CRCR6Mutator]MSP[S]
return isSeparator ( ch0 ) ? 1 : 0 ; } if ( ch0 == '~' ) { int posUnix = fileName . indexOf ( UNIX_SEPARATOR , 1 ) ; int posWin = fileName . indexOf ( WINDOWS_SEPARATOR , 1 ) ; MST[rv.CRCR6Mutator]MSP[N]
final int lastSeparator = indexOfLastSeparator ( fileName ) ; return lastSeparator > extensionPos ? NOT_FOUND : extensionPos ; MST[rv.ABSMutator]MSP[N] } public static String getPrefix ( final String fileName ) { if ( fileName == null ) { return null ; } final int len = getPrefixLength ( fileName ) ;
list . add ( lr_6 ) ; } else if ( prevChar != '*' ) { list . add ( lr_7 ) ; MST[NonVoidMethodCallMutator]MSP[N] } } else { buffer . append ( ch ) ; } prevChar = ch ; } if ( buffer . length () != 0 ) {
final int prefix = getPrefixLength ( fileName ) ; if ( prefix < 0 ) { MST[rv.ROR4Mutator]MSP[N] return null ; } if ( prefix >= fileName . length () ) { if ( includeSeparator ) { return getPrefix ( fileName ) ; } return fileName ; }
if ( path == null || path . indexOf ( WINDOWS_SEPARATOR ) == NOT_FOUND ) { MST[rv.CRCR1Mutator]MSP[N] return path ; } return path . replace ( WINDOWS_SEPARATOR , UNIX_SEPARATOR ) ; } public static String separatorsToWindows ( final String path ) {
if ( ipSegment . length () > 1 && ipSegment . startsWith ( lr_8 ) ) { MST[rv.CRCR3Mutator]MSP[S] return false ; } } return true ; } private static boolean isIPv6Address ( final String inet6Address ) { final boolean containsCompressedZeroes = inet6Address . contains ( lr_9 ) ;
if ( array [ j ] == separator ) { System . arraycopy ( array , i + 1 , array , j + 1 , size - i ) ; MST[rv.UOI2Mutator]MSP[N] size -= i - j ; i = j + 1 ; continue outer; } }
return new String ( array , 0 , size - 1 ) ; MST[ReturnValsMutator]MSP[N] } public static String concat ( final String basePath , final String fullFileNameToAdd ) { final int prefix = getPrefixLength ( fullFileNameToAdd ) ; if ( prefix < 0 ) { return null ; }
final char ch1 = fileName . charAt ( 1 ) ; if ( ch1 == ':' ) { ch0 = Character . toUpperCase ( ch0 ) ; if ( ch0 >= 'A' && ch0 <= 'Z' ) { MST[rv.CRCR3Mutator]MSP[N]
if ( containsCompressedZeroes && ( inet6Address . indexOf ( lr_9 ) != inet6Address . lastIndexOf ( lr_9 ) ) ) { return false ; MST[BooleanTrueReturnValsMutator]MSP[S] } if ( ( inet6Address . startsWith ( lr_10 ) && ! inet6Address . startsWith ( lr_9 ) )
if ( array [ i ] == separator && array [ i - 1 ] == separator ) { MST[rv.ROR2Mutator]MSP[N] System . arraycopy ( array , i , array , i - 1 , size - i ) ; size -- ; i -- ; } }
if ( repeat >= 0 ) { backtrack . push ( new int [] { wcsIdx , repeat } ) ; MST[rv.UOI1Mutator]MSP[N] } } else { if ( ! caseSensitivity . checkRegionMatches ( fileName , textIdx , wcs [ wcsIdx ] ) ) { break; } }
if ( octet . length () == 0 ) { emptyOctets ++ ; if ( emptyOctets > 1 ) { MST[rv.ABSMutator]MSP[N] return false ; } } else { emptyOctets = 0 ; if ( index == octets . length - 1 && octet . contains ( lr_12 ) ) {
final char ch = basePath . charAt ( len - 1 ) ; if ( isSeparator ( ch ) ) { return normalize ( basePath + fullFileNameToAdd ) ; } return normalize ( basePath + '/' + fullFileNameToAdd ) ; MST[NonVoidMethodCallMutator]MSP[N] }
for ( int i = prefix + 1 ; i < size ; i ++ ) { if ( array [ i ] == separator && array [ i - 1 ] == '.' && MST[rv.CRCR2Mutator]MSP[N]
if ( len == 2 || isSeparator ( fileName . charAt ( 2 ) ) == false ) { return 2 ; } return 3 ; MST[rv.CRCR4Mutator]MSP[N] } else if ( ch0 == UNIX_SEPARATOR ) { return 1 ; } return NOT_FOUND ;
( i == prefix + 1 || array [ i - 2 ] == separator ) ) { if ( i == size - 1 ) { lastIsDirectory = true ; MST[rv.CRCR3Mutator]MSP[N] }
if ( ch == '?' || ch == '*' ) { if ( buffer . length () != 0 ) { list . add ( buffer . toString () ) ; buffer . setLength ( 0 ) ; } if ( ch == '?' ) { MST[rv.UOI4Mutator]MSP[N]
static boolean isSystemWindows () { return SYSTEM_SEPARATOR == WINDOWS_SEPARATOR ; } private static boolean isSeparator ( final char ch ) { return ch == UNIX_SEPARATOR || ch == WINDOWS_SEPARATOR ; MST[InlineConstantMutator]MSP[N] } public static String normalize ( final String fileName ) {
final char ch1 = fileName . charAt ( 1 ) ; if ( ch1 == ':' ) { ch0 = Character . toUpperCase ( ch0 ) ; MST[ArgumentPropagationMutator]MSP[S] if ( ch0 >= 'A' && ch0 <= 'Z' ) {
if ( array [ i ] == separator && array [ i - 1 ] == '.' && array [ i - 2 ] == '.' && MST[InlineConstantMutator]MSP[N] ( i == prefix + 2 || array [ i - 3 ] == separator ) ) {
final char ch1 = fileName . charAt ( 1 ) ; if ( ch1 == ':' ) { ch0 = Character . toUpperCase ( ch0 ) ; if ( ch0 >= 'A' && ch0 <= 'Z' ) { MST[ConditionalsBoundaryMutator]MSP[N]
final int prefix = getPrefixLength ( fileName ) ; if ( prefix < 0 ) { MST[rv.ROR1Mutator]MSP[N] return null ; } if ( prefix >= fileName . length () ) { if ( includeSeparator ) { return getPrefix ( fileName ) ; } return fileName ; }
final char ch1 = fileName . charAt ( 1 ) ; if ( ch1 == ':' ) { MST[rv.ROR5Mutator]MSP[N] ch0 = Character . toUpperCase ( ch0 ) ; if ( ch0 >= 'A' && ch0 <= 'Z' ) {
final int index = indexOfLastSeparator ( fileName ) ; final int endIndex = index + separatorAdd ; if ( prefix >= fileName . length () || index < 0 || prefix >= endIndex ) { MST[NegateConditionalsMutator]MSP[N] return EMPTY_STRING ; }
if ( octets . length > IPV6_MAX_HEX_GROUPS ) { return false ; } int validOctets = 0 ; MST[rv.CRCR6Mutator]MSP[N] int emptyOctets = 0 ; for ( int index = 0 ; index < octets . length ; index ++ ) { final String octet = octets [ index ] ;
return new String ( array , 0 , size - 1 ) ; } public static String concat ( final String basePath , final String fullFileNameToAdd ) { final int prefix = getPrefixLength ( fullFileNameToAdd ) ; if ( prefix < 0 ) { MST[rv.UOI4Mutator]MSP[N] return null ; }
for ( int i = 0 ; i < parts . length ; i ++ ) { if ( parts [ i ] . length () == 0 ) { return i == parts . length - 1 ; MST[rv.CRCR1Mutator]MSP[N] }
if ( extension == null || extension . isEmpty () ) { return indexOfExtension ( fileName ) == NOT_FOUND ; MST[rv.ROR5Mutator]MSP[N] } final String fileExt = getExtension ( fileName ) ; return fileExt . equals ( extension ) ; }
final int lastSeparator = indexOfLastSeparator ( fileName ) ; return lastSeparator > extensionPos ? NOT_FOUND : extensionPos ; MST[rv.UOI3Mutator]MSP[N] } public static String getPrefix ( final String fileName ) { if ( fileName == null ) { return null ; } final int len = getPrefixLength ( fileName ) ;
if ( index == NOT_FOUND ) { return fileName ; } return fileName . substring ( 0 , index ) ; MST[EmptyObjectReturnValsMutator]MSP[N] } public static boolean equals ( final String fileName1 , final String fileName2 ) { return equals ( fileName1 , fileName2 , false , IOCase . SENSITIVE ) ;
for ( int i = prefix + 1 ; i < size ; i ++ ) { if ( array [ i ] == separator && array [ i - 1 ] == '.' && MST[rv.UOI3Mutator]MSP[N]
if ( len < 0 ) { return null ; } if ( len > fileName . length () ) { MST[rv.ROR4Mutator]MSP[N] failIfNullBytePresent ( fileName + UNIX_SEPARATOR ) ; return fileName + UNIX_SEPARATOR ; } final String path = fileName . substring ( 0 , len ) ;
if ( array [ size - 1 ] != separator ) { array [ size ++ ] = separator ; lastIsDirectory = false ; MST[InlineConstantMutator]MSP[N] } for ( int i = prefix + 1 ; i < size ; i ++ ) {
if ( len == 0 ) { return 0 ; MST[rv.CRCR5Mutator]MSP[N] } char ch0 = fileName . charAt ( 0 ) ; if ( ch0 == ':' ) { return NOT_FOUND ; } if ( len == 1 ) { if ( ch0 == '~' ) { return 2 ; }
for ( int i = 1 ; i <= 4 ; i ++ ) { final String ipSegment = m . group ( i ) ; final int iIpSegment = Integer . parseInt ( ipSegment ) ; if ( iIpSegment > IPV4_MAX_OCTET_VALUE ) { MST[rv.CRCR5Mutator]MSP[N] return false ; }
if ( array [ j ] == separator ) { System . arraycopy ( array , i + 1 , array , j + 1 , size - i ) ; MST[rv.AOR4Mutator]MSP[N] size -= i - j ; i = j + 1 ; continue outer; } }
if ( array [ j ] == separator ) { System . arraycopy ( array , i + 1 , array , j + 1 , size - i ) ; size -= i - j ; MST[rv.AOD1Mutator]MSP[N] i = j + 1 ; continue outer; } }
for ( int i = 0 ; i < parts . length ; i ++ ) { if ( parts [ i ] . length () == 0 ) { return i == parts . length - 1 ; MST[rv.AOR4Mutator]MSP[N] }
if ( len < 0 ) { MST[rv.UOI2Mutator]MSP[N] return null ; } if ( len > fileName . length () ) { failIfNullBytePresent ( fileName + UNIX_SEPARATOR ) ; return fileName + UNIX_SEPARATOR ; } final String path = fileName . substring ( 0 , len ) ;
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2 ) { return NOT_FOUND ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; MST[rv.ABSMutator]MSP[N] posWin = posWin == NOT_FOUND ? posUnix : posWin ;
int wcsIdx = 0 ; final Stack < int [] > backtrack = new Stack <> () ; do { if ( backtrack . size () > 0 ) { final int [] array = backtrack . pop () ; wcsIdx = array [ 0 ] ; MST[InlineConstantMutator]MSP[N]
if ( array [ i ] == separator && array [ i - 1 ] == '.' && array [ i - 2 ] == '.' && MST[rv.ROR1Mutator]MSP[S] ( i == prefix + 2 || array [ i - 3 ] == separator ) ) {
if ( size <= prefix ) { return new String ( array , 0 , size ) ; } if ( lastIsDirectory && keepSeparator ) { MST[NegateConditionalsMutator]MSP[N] return new String ( array , 0 , size ) ; }
final int index = indexOfLastSeparator ( fileName ) ; if ( index < 0 ) { return fileName . substring ( 0 , prefix ) ; } int end = index + ( includeSeparator ? 1 : 0 ) ; MST[rv.ABSMutator]MSP[N] if ( end == 0 ) { end ++ ;
public static boolean directoryContains ( final String canonicalParent , final String canonicalChild ) throws IOException { if ( canonicalParent == null ) { throw new IllegalArgumentException ( lr_1 ) ; } if ( canonicalChild == null ) { return false ; MST[InlineConstantMutator]MSP[N] }
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND ) { return len + 1 ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; MST[rv.CRCR2Mutator]MSP[N] posWin = posWin == NOT_FOUND ? posUnix : posWin ; return Math . min ( posUnix , posWin ) + 1 ; }
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2 ) { MST[rv.CRCR5Mutator]MSP[N] return NOT_FOUND ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ;
static boolean isSystemWindows () { return SYSTEM_SEPARATOR == WINDOWS_SEPARATOR ; } private static boolean isSeparator ( final char ch ) { return ch == UNIX_SEPARATOR || ch == WINDOWS_SEPARATOR ; MST[rv.ABSMutator]MSP[N] } public static String normalize ( final String fileName ) {
return caseSensitivity . checkEquals ( fileName1 , fileName2 ) ; MST[ReturnValsMutator]MSP[N] } public static boolean isExtension ( final String fileName , final String extension ) { if ( fileName == null ) { return false ; } failIfNullBytePresent ( fileName ) ;
list . add ( lr_6 ) ; } else if ( prevChar != '*' ) { MST[rv.ROR1Mutator]MSP[N] list . add ( lr_7 ) ; } } else { buffer . append ( ch ) ; } prevChar = ch ; } if ( buffer . length () != 0 ) {
if ( ch == '?' || ch == '*' ) { MST[rv.CRCR4Mutator]MSP[N] if ( buffer . length () != 0 ) { list . add ( buffer . toString () ) ; buffer . setLength ( 0 ) ; } if ( ch == '?' ) {
if ( array [ size - 1 ] != separator ) { MST[MathMutator]MSP[N] array [ size ++ ] = separator ; lastIsDirectory = false ; } for ( int i = prefix + 1 ; i < size ; i ++ ) {
return doNormalize ( fileName , separator , false ) ; MST[NonVoidMethodCallMutator]MSP[N] } private static String doNormalize ( final String fileName , final char separator , final boolean keepSeparator ) { if ( fileName == null ) { return null ; } failIfNullBytePresent ( fileName ) ;
if ( i == prefix + 2 ) { return null ; } if ( i == size - 1 ) { MST[rv.AOR4Mutator]MSP[S] lastIsDirectory = true ; } int j ; for ( j = i - 4 ; j >= prefix ; j -- ) {
final char [] array = new char [ size + 2 ] ; fileName . getChars ( 0 , fileName . length () , array , 0 ) ; final char otherSeparator = separator == SYSTEM_SEPARATOR ? OTHER_SEPARATOR : SYSTEM_SEPARATOR ; MST[rv.UOI3Mutator]MSP[N]
if ( len == 2 || isSeparator ( fileName . charAt ( 2 ) ) == false ) { MST[rv.UOI4Mutator]MSP[N] return 2 ; } return 3 ; } else if ( ch0 == UNIX_SEPARATOR ) { return 1 ; } return NOT_FOUND ;
System . arraycopy ( array , i + 1 , array , prefix , size - i ) ; MST[rv.UOI2Mutator]MSP[N] size -= i + 1 - prefix ; i = prefix + 1 ; } } if ( size <= 0 ) { return EMPTY_STRING ; }
if ( octets . length > IPV6_MAX_HEX_GROUPS ) { MST[NegateConditionalsMutator]MSP[N] return false ; } int validOctets = 0 ; int emptyOctets = 0 ; for ( int index = 0 ; index < octets . length ; index ++ ) { final String octet = octets [ index ] ;
System . arraycopy ( array , i + 1 , array , prefix , size - i ) ; size -= i + 1 - prefix ; i = prefix + 1 ; MST[rv.UOI2Mutator]MSP[N] } } if ( size <= 0 ) { return EMPTY_STRING ; }
final int lastWindowsPos = fileName . lastIndexOf ( WINDOWS_SEPARATOR ) ; return Math . max ( lastUnixPos , lastWindowsPos ) ; } public static int indexOfExtension ( final String fileName ) throws IllegalArgumentException { if ( fileName == null ) { return NOT_FOUND ; MST[rv.CRCR1Mutator]MSP[N] }
if ( size <= prefix ) { return new String ( array , 0 , size ) ; } if ( lastIsDirectory && keepSeparator ) { return new String ( array , 0 , size ) ; MST[rv.CRCR6Mutator]MSP[N] }
if ( array [ size - 1 ] != separator ) { MST[rv.ROR1Mutator]MSP[N] array [ size ++ ] = separator ; lastIsDirectory = false ; } for ( int i = prefix + 1 ; i < size ; i ++ ) {
return indexOfExtension ( fileName ) == NOT_FOUND ; } final String fileExt = getExtension ( fileName ) ; for ( final String extension : extensions ) { if ( fileExt . equals ( extension ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return true ; } } return false ; }
for ( int i = 0 ; i < array . length ; i ++ ) { if ( array [ i ] == otherSeparator ) { array [ i ] = separator ; } } boolean lastIsDirectory = true ; MST[rv.CRCR6Mutator]MSP[N]
return isSeparator ( ch0 ) ? 1 : 0 ; MST[InlineConstantMutator]MSP[N] } } public static int indexOfLastSeparator ( final String fileName ) { if ( fileName == null ) { return NOT_FOUND ; } final int lastUnixPos = fileName . lastIndexOf ( UNIX_SEPARATOR ) ;
if ( path == null || path . indexOf ( UNIX_SEPARATOR ) == NOT_FOUND ) { MST[rv.CRCR6Mutator]MSP[S] return path ; } return path . replace ( UNIX_SEPARATOR , WINDOWS_SEPARATOR ) ; } public static String separatorsToSystem ( final String path ) { if ( path == null ) {
final String path = fileName . substring ( prefix , endIndex ) ; MST[experimental.NakedReceiverMutator]MSP[N] failIfNullBytePresent ( path ) ; return path ; } public static String getFullPath ( final String fileName ) { return doGetFullPath ( fileName , true ) ; }
if ( isSystemWindows () ) { final int offset = fileName . indexOf ( ':' , getAdsCriticalOffset ( fileName ) ) ; if ( offset != - 1 ) { throw new IllegalArgumentException ( lr_2 ) ; } } final int extensionPos = fileName . lastIndexOf ( EXTENSION_SEPARATOR ) ; MST[ArgumentPropagationMutator]MSP[N]
if ( len < 0 ) { MST[rv.ABSMutator]MSP[N] return null ; } if ( len > fileName . length () ) { failIfNullBytePresent ( fileName + UNIX_SEPARATOR ) ; return fileName + UNIX_SEPARATOR ; } final String path = fileName . substring ( 0 , len ) ;
} else if ( isSeparator ( ch0 ) && isSeparator ( ch1 ) ) { int posUnix = fileName . indexOf ( UNIX_SEPARATOR , 2 ) ; int posWin = fileName . indexOf ( WINDOWS_SEPARATOR , 2 ) ; MST[rv.CRCR5Mutator]MSP[N]
if ( containsCompressedZeroes && ( inet6Address . indexOf ( lr_9 ) != inet6Address . lastIndexOf ( lr_9 ) ) ) { MST[rv.ROR3Mutator]MSP[S] return false ; } if ( ( inet6Address . startsWith ( lr_10 ) && ! inet6Address . startsWith ( lr_9 ) )
|| ( inet6Address . endsWith ( lr_10 ) && ! inet6Address . endsWith ( lr_9 ) ) ) { return false ; MST[InlineConstantMutator]MSP[S] } String [] octets = inet6Address . split ( lr_10 ) ; if ( containsCompressedZeroes ) {
System . arraycopy ( array , i + 1 , array , i - 1 , size - i ) ; size -= 2 ; i -- ; } } outer: for ( int i = prefix + 2 ; i < size ; i ++ ) { MST[MathMutator]MSP[N]
if ( array [ i ] == separator && array [ i - 1 ] == separator ) { System . arraycopy ( array , i , array , i - 1 , size - i ) ; MST[InlineConstantMutator]MSP[N] size -- ; i -- ; } }
final char ch = basePath . charAt ( len - 1 ) ; if ( isSeparator ( ch ) ) { MST[rv.UOI1Mutator]MSP[N] return normalize ( basePath + fullFileNameToAdd ) ; } return normalize ( basePath + '/' + fullFileNameToAdd ) ; }
final int lastWindowsPos = fileName . lastIndexOf ( WINDOWS_SEPARATOR ) ; MST[rv.CRCR6Mutator]MSP[N] return Math . max ( lastUnixPos , lastWindowsPos ) ; } public static int indexOfExtension ( final String fileName ) throws IllegalArgumentException { if ( fileName == null ) { return NOT_FOUND ; }
return fileName . substring ( index + 1 ) ; } private static void failIfNullBytePresent ( final String path ) { final int len = path . length () ; MST[NonVoidMethodCallMutator]MSP[N] for ( int i = 0 ; i < len ; i ++ ) {
if ( array [ size - 1 ] != separator ) { array [ size ++ ] = separator ; lastIsDirectory = false ; } for ( int i = prefix + 1 ; i < size ; i ++ ) { MST[rv.ROR3Mutator]MSP[N]
if ( ipSegment . length () > 1 && ipSegment . startsWith ( lr_8 ) ) { MST[rv.ROR2Mutator]MSP[N] return false ; } } return true ; } private static boolean isIPv6Address ( final String inet6Address ) { final boolean containsCompressedZeroes = inet6Address . contains ( lr_9 ) ;
octetInt = Integer . parseInt ( octet , BASE_16 ) ; } catch ( final NumberFormatException e ) { return false ; } if ( octetInt < 0 || octetInt > MAX_UNSIGNED_SHORT ) { MST[rv.ROR1Mutator]MSP[N] return false ; } } validOctets ++ ; }
if ( ch == '?' || ch == '*' ) { MST[InlineConstantMutator]MSP[N] if ( buffer . length () != 0 ) { list . add ( buffer . toString () ) ; buffer . setLength ( 0 ) ; } if ( ch == '?' ) {
if ( len == 2 || isSeparator ( fileName . charAt ( 2 ) ) == false ) { return 2 ; } return 3 ; } else if ( ch0 == UNIX_SEPARATOR ) { MST[rv.CRCR6Mutator]MSP[N] return 1 ; } return NOT_FOUND ;
list . add ( buffer . toString () ) ; } return list . toArray ( new String [ list . size () ] ) ; } private static boolean isValidHostName ( final String name ) { return isIPv6Address ( name ) || isRFC3986HostName ( name ) ; MST[rv.ROR1Mutator]MSP[N] }
if ( path == null || path . indexOf ( UNIX_SEPARATOR ) == NOT_FOUND ) { MST[rv.CRCR1Mutator]MSP[N] return path ; } return path . replace ( UNIX_SEPARATOR , WINDOWS_SEPARATOR ) ; } public static String separatorsToSystem ( final String path ) { if ( path == null ) {
if ( ipSegment . length () > 1 && ipSegment . startsWith ( lr_8 ) ) { MST[ConditionalsBoundaryMutator]MSP[S] return false ; } } return true ; } private static boolean isIPv6Address ( final String inet6Address ) { final boolean containsCompressedZeroes = inet6Address . contains ( lr_9 ) ;
failIfNullBytePresent ( path ) ; return path ; } public static String getPath ( final String fileName ) { return doGetPath ( fileName , 1 ) ; MST[rv.CRCR4Mutator]MSP[S] } public static String getPathNoEndSeparator ( final String fileName ) { return doGetPath ( fileName , 0 ) ; }
textIdx = caseSensitivity . checkIndexOf ( fileName , textIdx , wcs [ wcsIdx ] ) ; MST[rv.ABSMutator]MSP[N] if ( textIdx == NOT_FOUND ) { break; } final int repeat = caseSensitivity . checkIndexOf ( fileName , textIdx + 1 , wcs [ wcsIdx ] ) ;
if ( validOctets > IPV6_MAX_HEX_GROUPS || ( validOctets < IPV6_MAX_HEX_GROUPS && ! containsCompressedZeroes ) ) { MST[rv.ROR2Mutator]MSP[N] return false ; } return true ; } private static boolean isRFC3986HostName ( final String name ) { final String [] parts = name . split ( lr_13 , - 1 ) ;
final char ch1 = fileName . charAt ( 1 ) ; if ( ch1 == ':' ) { ch0 = Character . toUpperCase ( ch0 ) ; if ( ch0 >= 'A' && ch0 <= 'Z' ) { MST[NegateConditionalsMutator]MSP[N]
final int index = indexOfLastSeparator ( fileName ) ; final int endIndex = index + separatorAdd ; MST[rv.UOI3Mutator]MSP[N] if ( prefix >= fileName . length () || index < 0 || prefix >= endIndex ) { return EMPTY_STRING ; }
final int index = indexOfLastSeparator ( fileName ) ; if ( index < 0 ) { return fileName . substring ( 0 , prefix ) ; MST[rv.CRCR1Mutator]MSP[N] } int end = index + ( includeSeparator ? 1 : 0 ) ; if ( end == 0 ) { end ++ ;
textIdx = array [ 1 ] ; anyChars = true ; MST[rv.CRCR2Mutator]MSP[N] } while ( wcsIdx < wcs . length ) { if ( wcs [ wcsIdx ] . equals ( lr_6 ) ) { textIdx ++ ; if ( textIdx > fileName . length () ) { break; }
if ( IOCase . SYSTEM . checkEquals ( canonicalParent , canonicalChild ) ) { return false ; } return IOCase . SYSTEM . checkStartsWith ( canonicalChild , canonicalParent ) ; MST[NonVoidMethodCallMutator]MSP[N] } public static String separatorsToUnix ( final String path ) {
for ( int i = 0 ; i < array . length ; i ++ ) { MST[rv.UOI3Mutator]MSP[N] if ( array [ i ] == otherSeparator ) { array [ i ] = separator ; } } boolean lastIsDirectory = true ;
for ( int i = prefix + 1 ; i < size ; i ++ ) { if ( array [ i ] == separator && array [ i - 1 ] == '.' && MST[rv.ROR3Mutator]MSP[N]
if ( prefix > 0 ) { MST[ConditionalsBoundaryMutator]MSP[N] return normalize ( fullFileNameToAdd ) ; } if ( basePath == null ) { return null ; } final int len = basePath . length () ; if ( len == 0 ) { return normalize ( fullFileNameToAdd ) ; }
list . add ( lr_6 ) ; } else if ( prevChar != '*' ) { MST[rv.CRCR6Mutator]MSP[S] list . add ( lr_7 ) ; } } else { buffer . append ( ch ) ; } prevChar = ch ; } if ( buffer . length () != 0 ) {
textIdx = array [ 1 ] ; anyChars = true ; } while ( wcsIdx < wcs . length ) { MST[rv.UOI2Mutator]MSP[N] if ( wcs [ wcsIdx ] . equals ( lr_6 ) ) { textIdx ++ ; if ( textIdx > fileName . length () ) { break; }
for ( int i = 0 ; i < parts . length ; i ++ ) { if ( parts [ i ] . length () == 0 ) { return i == parts . length - 1 ; MST[rv.ROR1Mutator]MSP[N] }
return indexOfExtension ( fileName ) == NOT_FOUND ; } final String fileExt = getExtension ( fileName ) ; for ( final String extension : extensions ) { if ( fileExt . equals ( extension ) ) { MST[rv.ROR3Mutator]MSP[N] return true ; } } return false ; }
if ( array [ i ] == separator && array [ i - 1 ] == '.' && array [ i - 2 ] == '.' && MST[MathMutator]MSP[N] ( i == prefix + 2 || array [ i - 3 ] == separator ) ) {
if ( i == prefix + 2 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return null ; } if ( i == size - 1 ) { lastIsDirectory = true ; } int j ; for ( j = i - 4 ; j >= prefix ; j -- ) {
if ( path == null || path . indexOf ( UNIX_SEPARATOR ) == NOT_FOUND ) { return path ; } return path . replace ( UNIX_SEPARATOR , WINDOWS_SEPARATOR ) ; MST[rv.CRCR5Mutator]MSP[N] } public static String separatorsToSystem ( final String path ) { if ( path == null ) {
if ( len == 0 ) { return 0 ; MST[ReturnValsMutator]MSP[N] } char ch0 = fileName . charAt ( 0 ) ; if ( ch0 == ':' ) { return NOT_FOUND ; } if ( len == 1 ) { if ( ch0 == '~' ) { return 2 ; }
if ( extension == null || extension . isEmpty () ) { return indexOfExtension ( fileName ) == NOT_FOUND ; MST[rv.CRCR5Mutator]MSP[N] } final String fileExt = getExtension ( fileName ) ; return fileExt . equals ( extension ) ; }
anyChars = false ; } else if ( wcs [ wcsIdx ] . equals ( lr_7 ) ) { MST[rv.ROR1Mutator]MSP[N] anyChars = true ; if ( wcsIdx == wcs . length - 1 ) { textIdx = fileName . length () ; } } else { if ( anyChars ) {
if ( array [ size - 1 ] != separator ) { MST[rv.UOI3Mutator]MSP[N] array [ size ++ ] = separator ; lastIsDirectory = false ; } for ( int i = prefix + 1 ; i < size ; i ++ ) {
return wildcardMatch ( fileName , wildcardMatcher , IOCase . SYSTEM ) ; } public static boolean wildcardMatch ( final String fileName , final String wildcardMatcher , IOCase caseSensitivity ) { if ( fileName == null && wildcardMatcher == null ) { MST[NegateConditionalsMutator]MSP[N] return true ; }
return fileName . substring ( index + 1 ) ; MST[InlineConstantMutator]MSP[N] } private static void failIfNullBytePresent ( final String path ) { final int len = path . length () ; for ( int i = 0 ; i < len ; i ++ ) {
return doNormalize ( fileName , SYSTEM_SEPARATOR , true ) ; } public static String normalize ( final String fileName , final boolean unixSeparator ) { final char separator = unixSeparator ? UNIX_SEPARATOR : WINDOWS_SEPARATOR ; return doNormalize ( fileName , separator , true ) ; MST[rv.UOI3Mutator]MSP[N] }
System . arraycopy ( array , i + 1 , array , i - 1 , size - i ) ; size -= 2 ; i -- ; } } outer: for ( int i = prefix + 2 ; i < size ; i ++ ) { MST[rv.UOI4Mutator]MSP[N]
textIdx = caseSensitivity . checkIndexOf ( fileName , textIdx , wcs [ wcsIdx ] ) ; MST[ArgumentPropagationMutator]MSP[N] if ( textIdx == NOT_FOUND ) { break; } final int repeat = caseSensitivity . checkIndexOf ( fileName , textIdx + 1 , wcs [ wcsIdx ] ) ;
|| ( inet6Address . endsWith ( lr_10 ) && ! inet6Address . endsWith ( lr_9 ) ) ) { MST[rv.ROR3Mutator]MSP[N] return false ; } String [] octets = inet6Address . split ( lr_10 ) ; if ( containsCompressedZeroes ) {
return null ; } return isSystemWindows () ? separatorsToWindows ( path ) : separatorsToUnix ( path ) ; } public static int getPrefixLength ( final String fileName ) { if ( fileName == null ) { return NOT_FOUND ; MST[rv.CRCR6Mutator]MSP[N] } final int len = fileName . length () ;
list . add ( buffer . toString () ) ; } return list . toArray ( new String [ list . size () ] ) ; } private static boolean isValidHostName ( final String name ) { return isIPv6Address ( name ) || isRFC3986HostName ( name ) ; MST[rv.CRCR3Mutator]MSP[N] }
final char [] array = new char [ size + 2 ] ; MST[rv.CRCR4Mutator]MSP[N] fileName . getChars ( 0 , fileName . length () , array , 0 ) ; final char otherSeparator = separator == SYSTEM_SEPARATOR ? OTHER_SEPARATOR : SYSTEM_SEPARATOR ;
if ( array [ i ] == separator && array [ i - 1 ] == '.' && array [ i - 2 ] == '.' && MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] ( i == prefix + 2 || array [ i - 3 ] == separator ) ) {
static boolean isSystemWindows () { return SYSTEM_SEPARATOR == WINDOWS_SEPARATOR ; MST[rv.CRCR2Mutator]MSP[N] } private static boolean isSeparator ( final char ch ) { return ch == UNIX_SEPARATOR || ch == WINDOWS_SEPARATOR ; } public static String normalize ( final String fileName ) {
public static String getFullPathNoEndSeparator ( final String fileName ) { return doGetFullPath ( fileName , false ) ; MST[EmptyObjectReturnValsMutator]MSP[N] } private static String doGetFullPath ( final String fileName , final boolean includeSeparator ) { if ( fileName == null ) { return null ; }
if ( validOctets > IPV6_MAX_HEX_GROUPS || ( validOctets < IPV6_MAX_HEX_GROUPS && ! containsCompressedZeroes ) ) { MST[NegateConditionalsMutator]MSP[N] return false ; } return true ; } private static boolean isRFC3986HostName ( final String name ) { final String [] parts = name . split ( lr_13 , - 1 ) ;
final int prefix = getPrefixLength ( fileName ) ; if ( prefix < 0 ) { MST[rv.UOI3Mutator]MSP[N] return null ; } if ( prefix >= fileName . length () ) { if ( includeSeparator ) { return getPrefix ( fileName ) ; } return fileName ; }
if ( array [ i ] == separator && array [ i - 1 ] == '.' && array [ i - 2 ] == '.' && MST[rv.AOR4Mutator]MSP[N] ( i == prefix + 2 || array [ i - 3 ] == separator ) ) {
private static String doGetPath ( final String fileName , final int separatorAdd ) { if ( fileName == null ) { return null ; } final int prefix = getPrefixLength ( fileName ) ; if ( prefix < 0 ) { MST[rv.UOI4Mutator]MSP[N] return null ; }
if ( ch == '?' || ch == '*' ) { if ( buffer . length () != 0 ) { MST[rv.ROR2Mutator]MSP[N] list . add ( buffer . toString () ) ; buffer . setLength ( 0 ) ; } if ( ch == '?' ) {
anyChars = false ; } else if ( wcs [ wcsIdx ] . equals ( lr_7 ) ) { anyChars = true ; if ( wcsIdx == wcs . length - 1 ) { textIdx = fileName . length () ; } } else { if ( anyChars ) { MST[rv.ROR3Mutator]MSP[N]
return new String ( array , 0 , size - 1 ) ; } public static String concat ( final String basePath , final String fullFileNameToAdd ) { final int prefix = getPrefixLength ( fullFileNameToAdd ) ; if ( prefix < 0 ) { MST[rv.ROR2Mutator]MSP[N] return null ; }
for ( int i = 0 ; i < array . length ; i ++ ) { if ( array [ i ] == otherSeparator ) { array [ i ] = separator ; MST[rv.UOI2Mutator]MSP[N] } } boolean lastIsDirectory = true ;
final char ch1 = fileName . charAt ( 1 ) ; if ( ch1 == ':' ) { ch0 = Character . toUpperCase ( ch0 ) ; if ( ch0 >= 'A' && ch0 <= 'Z' ) { MST[rv.CRCR2Mutator]MSP[N]
return indexOfExtension ( fileName ) == NOT_FOUND ; MST[InlineConstantMutator]MSP[N] } final String fileExt = getExtension ( fileName ) ; for ( final String extension : extensions ) { if ( fileExt . equals ( extension ) ) { return true ; } } return false ; }
( i == prefix + 1 || array [ i - 2 ] == separator ) ) { if ( i == size - 1 ) { MST[rv.ROR2Mutator]MSP[N] lastIsDirectory = true ; }
textIdx += wcs [ wcsIdx ] . length () ; anyChars = false ; } wcsIdx ++ ; } if ( wcsIdx == wcs . length && textIdx == fileName . length () ) { MST[NonVoidMethodCallMutator]MSP[N] return true ; } } while ( backtrack . size () > 0 );
if ( fileName == null || wildcardMatcher == null ) { return false ; } if ( caseSensitivity == null ) { caseSensitivity = IOCase . SENSITIVE ; } final String [] wcs = splitOnTokens ( wildcardMatcher ) ; boolean anyChars = false ; int textIdx = 0 ; MST[rv.CRCR1Mutator]MSP[N]
if ( array [ i ] == separator && array [ i - 1 ] == '.' && array [ i - 2 ] == '.' && MST[rv.CRCR2Mutator]MSP[N] ( i == prefix + 2 || array [ i - 3 ] == separator ) ) {
if ( len == 0 ) { return 0 ; } char ch0 = fileName . charAt ( 0 ) ; if ( ch0 == ':' ) { return NOT_FOUND ; } if ( len == 1 ) { if ( ch0 == '~' ) { MST[rv.UOI2Mutator]MSP[N] return 2 ; }
for ( int i = 0 ; i < parts . length ; i ++ ) { MST[rv.ROR2Mutator]MSP[N] if ( parts [ i ] . length () == 0 ) { return i == parts . length - 1 ; }
if ( containsCompressedZeroes && ( inet6Address . indexOf ( lr_9 ) != inet6Address . lastIndexOf ( lr_9 ) ) ) { return false ; MST[rv.CRCR6Mutator]MSP[S] } if ( ( inet6Address . startsWith ( lr_10 ) && ! inet6Address . startsWith ( lr_9 ) )
if ( prefix > 0 ) { return normalize ( fullFileNameToAdd ) ; } if ( basePath == null ) { return null ; MST[EmptyObjectReturnValsMutator]MSP[S] } final int len = basePath . length () ; if ( len == 0 ) { return normalize ( fullFileNameToAdd ) ; }
if ( size <= prefix ) { return new String ( array , 0 , size ) ; } if ( lastIsDirectory && keepSeparator ) { MST[rv.ROR4Mutator]MSP[N] return new String ( array , 0 , size ) ; }
return isSeparator ( ch0 ) ? 1 : 0 ; } } public static int indexOfLastSeparator ( final String fileName ) { if ( fileName == null ) { return NOT_FOUND ; } final int lastUnixPos = fileName . lastIndexOf ( UNIX_SEPARATOR ) ; MST[rv.CRCR4Mutator]MSP[N]
if ( ! isIPv4Address ( octet ) ) { return false ; } validOctets += 2 ; continue; } if ( octet . length () > IPV6_MAX_HEX_DIGITS_PER_GROUP ) { MST[rv.CRCR6Mutator]MSP[N] return false ; } int octetInt = 0 ; try {
for ( int i = prefix + 1 ; i < size ; i ++ ) { if ( array [ i ] == separator && array [ i - 1 ] == '.' && MST[rv.ROR1Mutator]MSP[N]
if ( index == NOT_FOUND ) { MST[rv.ROR2Mutator]MSP[N] return fileName ; } return fileName . substring ( 0 , index ) ; } public static boolean equals ( final String fileName1 , final String fileName2 ) { return equals ( fileName1 , fileName2 , false , IOCase . SENSITIVE ) ;
if ( path . charAt ( i ) == 0 ) { MST[NegateConditionalsMutator]MSP[N] throw new IllegalArgumentException ( lr_3 + lr_4 ) ; } } } public static String getBaseName ( final String fileName ) { return removeExtension ( getName ( fileName ) ) ; }
final char ch1 = fileName . charAt ( 1 ) ; if ( ch1 == ':' ) { ch0 = Character . toUpperCase ( ch0 ) ; if ( ch0 >= 'A' && ch0 <= 'Z' ) { MST[rv.UOI1Mutator]MSP[N]
textIdx = array [ 1 ] ; anyChars = true ; } while ( wcsIdx < wcs . length ) { MST[rv.ROR1Mutator]MSP[N] if ( wcs [ wcsIdx ] . equals ( lr_6 ) ) { textIdx ++ ; if ( textIdx > fileName . length () ) { break; }
if ( len < 0 ) { return null ; } if ( len > fileName . length () ) { failIfNullBytePresent ( fileName + UNIX_SEPARATOR ) ; return fileName + UNIX_SEPARATOR ; } final String path = fileName . substring ( 0 , len ) ; MST[rv.UOI1Mutator]MSP[N]
|| ( inet6Address . endsWith ( lr_10 ) && ! inet6Address . endsWith ( lr_9 ) ) ) { return false ; MST[rv.CRCR1Mutator]MSP[S] } String [] octets = inet6Address . split ( lr_10 ) ; if ( containsCompressedZeroes ) {
if ( i == prefix + 2 ) { return null ; } if ( i == size - 1 ) { lastIsDirectory = true ; } int j ; for ( j = i - 4 ; j >= prefix ; j -- ) { MST[rv.UOI4Mutator]MSP[N]
if ( path == null || path . indexOf ( UNIX_SEPARATOR ) == NOT_FOUND ) { MST[rv.CRCR3Mutator]MSP[N] return path ; } return path . replace ( UNIX_SEPARATOR , WINDOWS_SEPARATOR ) ; } public static String separatorsToSystem ( final String path ) { if ( path == null ) {
System . arraycopy ( array , i + 1 , array , i - 1 , size - i ) ; size -= 2 ; i -- ; } } outer: for ( int i = prefix + 2 ; i < size ; i ++ ) { MST[rv.CRCR2Mutator]MSP[S]
if ( fileName == null || wildcardMatcher == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return false ; } if ( caseSensitivity == null ) { caseSensitivity = IOCase . SENSITIVE ; } final String [] wcs = splitOnTokens ( wildcardMatcher ) ; boolean anyChars = false ; int textIdx = 0 ;
int size = fileName . length () ; if ( size == 0 ) { return fileName ; } final int prefix = getPrefixLength ( fileName ) ; if ( prefix < 0 ) { MST[rv.ROR1Mutator]MSP[N] return null ; }
return indexOfExtension ( fileName ) == NOT_FOUND ; MST[rv.CRCR4Mutator]MSP[N] } final String fileExt = getExtension ( fileName ) ; for ( final String extension : extensions ) { if ( fileExt . equals ( extension ) ) { return true ; } } return false ; }
if ( array [ size - 1 ] != separator ) { array [ size ++ ] = separator ; lastIsDirectory = false ; } for ( int i = prefix + 1 ; i < size ; i ++ ) { MST[rv.CRCR3Mutator]MSP[N]
fileName2 = normalize ( fileName2 ) ; if ( fileName1 == null || fileName2 == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] throw new NullPointerException ( lr_5 ) ; } } if ( caseSensitivity == null ) { caseSensitivity = IOCase . SENSITIVE ; }
final char ch1 = fileName . charAt ( 1 ) ; if ( ch1 == ':' ) { ch0 = Character . toUpperCase ( ch0 ) ; if ( ch0 >= 'A' && ch0 <= 'Z' ) { MST[rv.CRCR6Mutator]MSP[N]
for ( int i = 0 ; i < array . length ; i ++ ) { if ( array [ i ] == otherSeparator ) { array [ i ] = separator ; MST[rv.UOI2Mutator]MSP[N] } } boolean lastIsDirectory = true ;
for ( int i = 1 ; i <= 4 ; i ++ ) { MST[rv.ROR3Mutator]MSP[N] final String ipSegment = m . group ( i ) ; final int iIpSegment = Integer . parseInt ( ipSegment ) ; if ( iIpSegment > IPV4_MAX_OCTET_VALUE ) { return false ; }
System . arraycopy ( array , i + 1 , array , prefix , size - i ) ; size -= i + 1 - prefix ; MST[MathMutator]MSP[N] i = prefix + 1 ; } } if ( size <= 0 ) { return EMPTY_STRING ; }
return indexOfExtension ( fileName ) == NOT_FOUND ; MST[rv.ROR3Mutator]MSP[N] } final String fileExt = getExtension ( fileName ) ; for ( final String extension : extensions ) { if ( fileExt . equals ( extension ) ) { return true ; } } return false ; }
public static String getFullPathNoEndSeparator ( final String fileName ) { return doGetFullPath ( fileName , false ) ; MST[rv.CRCR6Mutator]MSP[N] } private static String doGetFullPath ( final String fileName , final boolean includeSeparator ) { if ( fileName == null ) { return null ; }
if ( array [ i ] == separator && array [ i - 1 ] == separator ) { MST[rv.CRCR3Mutator]MSP[N] System . arraycopy ( array , i , array , i - 1 , size - i ) ; size -- ; i -- ; } }
int size = fileName . length () ; if ( size == 0 ) { MST[rv.ROR2Mutator]MSP[N] return fileName ; } final int prefix = getPrefixLength ( fileName ) ; if ( prefix < 0 ) { return null ; }
for ( int i = prefix + 1 ; i < size ; i ++ ) { MST[MathMutator]MSP[N] if ( array [ i ] == separator && array [ i - 1 ] == '.' &&
static boolean isSystemWindows () { return SYSTEM_SEPARATOR == WINDOWS_SEPARATOR ; } private static boolean isSeparator ( final char ch ) { return ch == UNIX_SEPARATOR || ch == WINDOWS_SEPARATOR ; MST[NegateConditionalsMutator]MSP[N] } public static String normalize ( final String fileName ) {
if ( path . charAt ( i ) == 0 ) { MST[rv.ROR1Mutator]MSP[N] throw new IllegalArgumentException ( lr_3 + lr_4 ) ; } } } public static String getBaseName ( final String fileName ) { return removeExtension ( getName ( fileName ) ) ; }
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return NOT_FOUND ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ;
if ( ch == '?' || ch == '*' ) { MST[rv.CRCR1Mutator]MSP[N] if ( buffer . length () != 0 ) { list . add ( buffer . toString () ) ; buffer . setLength ( 0 ) ; } if ( ch == '?' ) {
if ( path == null || path . indexOf ( WINDOWS_SEPARATOR ) == NOT_FOUND ) { MST[rv.ROR5Mutator]MSP[N] return path ; } return path . replace ( WINDOWS_SEPARATOR , UNIX_SEPARATOR ) ; } public static String separatorsToWindows ( final String path ) {
if ( array [ j ] == separator ) { System . arraycopy ( array , i + 1 , array , j + 1 , size - i ) ; size -= i - j ; MST[MathMutator]MSP[N] i = j + 1 ; continue outer; } }
return fileName . substring ( index + 1 ) ; } private static void failIfNullBytePresent ( final String path ) { final int len = path . length () ; for ( int i = 0 ; i < len ; i ++ ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N]
textIdx = array [ 1 ] ; anyChars = true ; } while ( wcsIdx < wcs . length ) { if ( wcs [ wcsIdx ] . equals ( lr_6 ) ) { textIdx ++ ; if ( textIdx > fileName . length () ) { MST[rv.ROR1Mutator]MSP[N] break; }
System . arraycopy ( array , i + 1 , array , prefix , size - i ) ; MST[rv.ABSMutator]MSP[N] size -= i + 1 - prefix ; i = prefix + 1 ; } } if ( size <= 0 ) { return EMPTY_STRING ; }
final int index = indexOfLastSeparator ( fileName ) ; final int endIndex = index + separatorAdd ; if ( prefix >= fileName . length () || index < 0 || prefix >= endIndex ) { MST[rv.UOI1Mutator]MSP[N] return EMPTY_STRING ; }
return Math . max ( offset1 , offset2 ) + 1 ; } public static String removeExtension ( final String fileName ) { if ( fileName == null ) { return null ; MST[ReturnValsMutator]MSP[S] } failIfNullBytePresent ( fileName ) ; final int index = indexOfExtension ( fileName ) ;
int size = fileName . length () ; if ( size == 0 ) { return fileName ; } final int prefix = getPrefixLength ( fileName ) ; if ( prefix < 0 ) { return null ; MST[ReturnValsMutator]MSP[N] }
final int index = indexOfLastSeparator ( fileName ) ; final int endIndex = index + separatorAdd ; MST[rv.UOI3Mutator]MSP[N] if ( prefix >= fileName . length () || index < 0 || prefix >= endIndex ) { return EMPTY_STRING ; }
for ( int i = prefix + 1 ; i < size ; i ++ ) { MST[rv.ROR2Mutator]MSP[N] if ( array [ i ] == separator && array [ i - 1 ] == '.' &&
if ( octets . length > IPV6_MAX_HEX_GROUPS ) { return false ; } int validOctets = 0 ; MST[rv.CRCR3Mutator]MSP[N] int emptyOctets = 0 ; for ( int index = 0 ; index < octets . length ; index ++ ) { final String octet = octets [ index ] ;
return doNormalize ( fileName , SYSTEM_SEPARATOR , true ) ; MST[rv.CRCR2Mutator]MSP[N] } public static String normalize ( final String fileName , final boolean unixSeparator ) { final char separator = unixSeparator ? UNIX_SEPARATOR : WINDOWS_SEPARATOR ; return doNormalize ( fileName , separator , true ) ; }
if ( index == NOT_FOUND ) { return fileName ; } return fileName . substring ( 0 , index ) ; MST[rv.CRCR3Mutator]MSP[S] } public static boolean equals ( final String fileName1 , final String fileName2 ) { return equals ( fileName1 , fileName2 , false , IOCase . SENSITIVE ) ;
if ( extension == null || extension . isEmpty () ) { return indexOfExtension ( fileName ) == NOT_FOUND ; MST[rv.ROR2Mutator]MSP[N] } final String fileExt = getExtension ( fileName ) ; return fileExt . equals ( extension ) ; }
return doNormalize ( fileName , SYSTEM_SEPARATOR , true ) ; MST[NonVoidMethodCallMutator]MSP[N] } public static String normalize ( final String fileName , final boolean unixSeparator ) { final char separator = unixSeparator ? UNIX_SEPARATOR : WINDOWS_SEPARATOR ; return doNormalize ( fileName , separator , true ) ; }
public static String normalizeNoEndSeparator ( final String fileName ) { return doNormalize ( fileName , SYSTEM_SEPARATOR , false ) ; } public static String normalizeNoEndSeparator ( final String fileName , final boolean unixSeparator ) { final char separator = unixSeparator ? UNIX_SEPARATOR : WINDOWS_SEPARATOR ; MST[rv.ROR5Mutator]MSP[N]
for ( int i = prefix + 1 ; i < size ; i ++ ) { if ( array [ i ] == separator && array [ i - 1 ] == '.' && MST[MathMutator]MSP[N]
if ( octet . length () == 0 ) { emptyOctets ++ ; if ( emptyOctets > 1 ) { return false ; } } else { emptyOctets = 0 ; if ( index == octets . length - 1 && octet . contains ( lr_12 ) ) { MST[MathMutator]MSP[S]
octetInt = Integer . parseInt ( octet , BASE_16 ) ; } catch ( final NumberFormatException e ) { return false ; } if ( octetInt < 0 || octetInt > MAX_UNSIGNED_SHORT ) { MST[rv.CRCR6Mutator]MSP[N] return false ; } } validOctets ++ ; }
if ( array [ i ] == separator && array [ i - 1 ] == '.' && array [ i - 2 ] == '.' && MST[rv.UOI2Mutator]MSP[N] ( i == prefix + 2 || array [ i - 3 ] == separator ) ) {
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2 ) { return NOT_FOUND ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ; MST[rv.UOI2Mutator]MSP[N]
if ( i == prefix + 2 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return null ; } if ( i == size - 1 ) { lastIsDirectory = true ; } int j ; for ( j = i - 4 ; j >= prefix ; j -- ) {
textIdx = caseSensitivity . checkIndexOf ( fileName , textIdx , wcs [ wcsIdx ] ) ; if ( textIdx == NOT_FOUND ) { MST[rv.CRCR6Mutator]MSP[N] break; } final int repeat = caseSensitivity . checkIndexOf ( fileName , textIdx + 1 , wcs [ wcsIdx ] ) ;
if ( extension == null || extension . isEmpty () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return indexOfExtension ( fileName ) == NOT_FOUND ; } final String fileExt = getExtension ( fileName ) ; return fileExt . equals ( extension ) ; }
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2 ) { MST[rv.CRCR4Mutator]MSP[N] return NOT_FOUND ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ;
if ( ipSegment . length () > 1 && ipSegment . startsWith ( lr_8 ) ) { return false ; MST[rv.CRCR6Mutator]MSP[N] } } return true ; } private static boolean isIPv6Address ( final String inet6Address ) { final boolean containsCompressedZeroes = inet6Address . contains ( lr_9 ) ;
octetInt = Integer . parseInt ( octet , BASE_16 ) ; MST[rv.CRCR5Mutator]MSP[S] } catch ( final NumberFormatException e ) { return false ; } if ( octetInt < 0 || octetInt > MAX_UNSIGNED_SHORT ) { return false ; } } validOctets ++ ; }
anyChars = false ; } else if ( wcs [ wcsIdx ] . equals ( lr_7 ) ) { anyChars = true ; if ( wcsIdx == wcs . length - 1 ) { MST[rv.UOI3Mutator]MSP[N] textIdx = fileName . length () ; } } else { if ( anyChars ) {
textIdx += wcs [ wcsIdx ] . length () ; anyChars = false ; } wcsIdx ++ ; } if ( wcsIdx == wcs . length && textIdx == fileName . length () ) { return true ; MST[rv.CRCR4Mutator]MSP[N] } } while ( backtrack . size () > 0 );
octetInt = Integer . parseInt ( octet , BASE_16 ) ; } catch ( final NumberFormatException e ) { return false ; } if ( octetInt < 0 || octetInt > MAX_UNSIGNED_SHORT ) { MST[ConditionalsBoundaryMutator]MSP[N] return false ; } } validOctets ++ ; }
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND ) { return len + 1 ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ; MST[rv.UOI3Mutator]MSP[N] return Math . min ( posUnix , posWin ) + 1 ; }
public static boolean wildcardMatch ( final String fileName , final String wildcardMatcher ) { return wildcardMatch ( fileName , wildcardMatcher , IOCase . SENSITIVE ) ; MST[ReturnValsMutator]MSP[N] } public static boolean wildcardMatchOnSystem ( final String fileName , final String wildcardMatcher ) {
return isSeparator ( ch0 ) ? 1 : 0 ; } if ( ch0 == '~' ) { int posUnix = fileName . indexOf ( UNIX_SEPARATOR , 1 ) ; MST[rv.CRCR1Mutator]MSP[N] int posWin = fileName . indexOf ( WINDOWS_SEPARATOR , 1 ) ;
final int lastSeparator = indexOfLastSeparator ( fileName ) ; MST[NonVoidMethodCallMutator]MSP[S] return lastSeparator > extensionPos ? NOT_FOUND : extensionPos ; } public static String getPrefix ( final String fileName ) { if ( fileName == null ) { return null ; } final int len = getPrefixLength ( fileName ) ;
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2 ) { return NOT_FOUND ; MST[rv.CRCR1Mutator]MSP[N] } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ;
if ( array [ i ] == separator && array [ i - 1 ] == '.' && array [ i - 2 ] == '.' && MST[rv.CRCR1Mutator]MSP[N] ( i == prefix + 2 || array [ i - 3 ] == separator ) ) {
return isSeparator ( ch0 ) ? 1 : 0 ; MST[rv.UOI1Mutator]MSP[S] } } public static int indexOfLastSeparator ( final String fileName ) { if ( fileName == null ) { return NOT_FOUND ; } final int lastUnixPos = fileName . lastIndexOf ( UNIX_SEPARATOR ) ;
if ( ch == '?' || ch == '*' ) { MST[rv.CRCR5Mutator]MSP[N] if ( buffer . length () != 0 ) { list . add ( buffer . toString () ) ; buffer . setLength ( 0 ) ; } if ( ch == '?' ) {
return new String ( array , 0 , size - 1 ) ; MST[rv.CRCR4Mutator]MSP[N] } public static String concat ( final String basePath , final String fullFileNameToAdd ) { final int prefix = getPrefixLength ( fullFileNameToAdd ) ; if ( prefix < 0 ) { return null ; }
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2 ) { return NOT_FOUND ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; MST[InlineConstantMutator]MSP[N] posWin = posWin == NOT_FOUND ? posUnix : posWin ;
for ( int i = prefix + 1 ; i < size ; i ++ ) { MST[rv.UOI4Mutator]MSP[N] if ( array [ i ] == separator && array [ i - 1 ] == '.' &&
String fileName1 , String fileName2 , final boolean normalized , IOCase caseSensitivity ) { if ( fileName1 == null || fileName2 == null ) { return fileName1 == null && fileName2 == null ; MST[rv.CRCR6Mutator]MSP[N] } if ( normalized ) { fileName1 = normalize ( fileName1 ) ;
return false ; MST[InlineConstantMutator]MSP[N] } static String [] splitOnTokens ( final String text ) { if ( text . indexOf ( '?' ) == NOT_FOUND && text . indexOf ( '*' ) == NOT_FOUND ) { return new String [] { text } ; }
if ( len == 0 ) { return 0 ; } char ch0 = fileName . charAt ( 0 ) ; if ( ch0 == ':' ) { return NOT_FOUND ; } if ( len == 1 ) { if ( ch0 == '~' ) { return 2 ; MST[rv.CRCR4Mutator]MSP[N] }
final int pos = Math . min ( posUnix , posWin ) + 1 ; final String hostnamePart = fileName . substring ( 2 , pos - 1 ) ; MST[rv.UOI3Mutator]MSP[N] return isValidHostName ( hostnamePart ) ? pos : NOT_FOUND ; } else {
public static boolean isExtension ( final String fileName , final Collection < String > extensions ) { if ( fileName == null ) { MST[NegateConditionalsMutator]MSP[N] return false ; } failIfNullBytePresent ( fileName ) ; if ( extensions == null || extensions . isEmpty () ) {
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND ) { return len + 1 ; MST[rv.UOI2Mutator]MSP[N] } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ; return Math . min ( posUnix , posWin ) + 1 ; }
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2 ) { MST[rv.ROR2Mutator]MSP[N] return NOT_FOUND ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ;
( i == prefix + 1 || array [ i - 2 ] == separator ) ) { if ( i == size - 1 ) { MST[rv.AOR1Mutator]MSP[N] lastIsDirectory = true ; }
return isSeparator ( ch0 ) ? 1 : 0 ; } if ( ch0 == '~' ) { MST[rv.CRCR5Mutator]MSP[N] int posUnix = fileName . indexOf ( UNIX_SEPARATOR , 1 ) ; int posWin = fileName . indexOf ( WINDOWS_SEPARATOR , 1 ) ;
for ( int i = prefix + 1 ; i < size ; i ++ ) { if ( array [ i ] == separator && array [ i - 1 ] == '.' && MST[rv.UOI4Mutator]MSP[N]
if ( index == NOT_FOUND ) { return fileName ; } return fileName . substring ( 0 , index ) ; } public static boolean equals ( final String fileName1 , final String fileName2 ) { return equals ( fileName1 , fileName2 , false , IOCase . SENSITIVE ) ; MST[NonVoidMethodCallMutator]MSP[S]
for ( int i = prefix + 1 ; i < size ; i ++ ) { if ( array [ i ] == separator && array [ i - 1 ] == '.' && MST[rv.UOI1Mutator]MSP[N]
if ( i == prefix + 2 ) { return null ; } if ( i == size - 1 ) { lastIsDirectory = true ; MST[rv.CRCR6Mutator]MSP[S] } int j ; for ( j = i - 4 ; j >= prefix ; j -- ) {
return indexOfExtension ( fileName ) == NOT_FOUND ; MST[rv.CRCR3Mutator]MSP[N] } final String fileExt = getExtension ( fileName ) ; for ( final String extension : extensions ) { if ( fileExt . equals ( extension ) ) { return true ; } } return false ; }
textIdx = array [ 1 ] ; anyChars = true ; } while ( wcsIdx < wcs . length ) { if ( wcs [ wcsIdx ] . equals ( lr_6 ) ) { textIdx ++ ; if ( textIdx > fileName . length () ) { MST[NegateConditionalsMutator]MSP[N] break; }
return indexOfExtension ( fileName ) == NOT_FOUND ; MST[rv.CRCR6Mutator]MSP[S] } final String fileExt = getExtension ( fileName ) ; for ( final String extension : extensions ) { if ( fileExt . equals ( extension ) ) { return true ; } } return false ; }
if ( extension == null || extension . isEmpty () ) { MST[NonVoidMethodCallMutator]MSP[N] return indexOfExtension ( fileName ) == NOT_FOUND ; } final String fileExt = getExtension ( fileName ) ; return fileExt . equals ( extension ) ; }
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2 ) { return NOT_FOUND ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ; MST[rv.ABSMutator]MSP[N]
int size = fileName . length () ; if ( size == 0 ) { MST[rv.UOI4Mutator]MSP[N] return fileName ; } final int prefix = getPrefixLength ( fileName ) ; if ( prefix < 0 ) { return null ; }
if ( len == 2 || isSeparator ( fileName . charAt ( 2 ) ) == false ) { return 2 ; } return 3 ; } else if ( ch0 == UNIX_SEPARATOR ) { MST[rv.ROR1Mutator]MSP[N] return 1 ; } return NOT_FOUND ;
final int prefix = getPrefixLength ( fileName ) ; if ( prefix < 0 ) { return null ; } if ( prefix >= fileName . length () ) { MST[ConditionalsBoundaryMutator]MSP[S] if ( includeSeparator ) { return getPrefix ( fileName ) ; } return fileName ; }
final int pos = Math . min ( posUnix , posWin ) + 1 ; final String hostnamePart = fileName . substring ( 2 , pos - 1 ) ; MST[rv.CRCR3Mutator]MSP[N] return isValidHostName ( hostnamePart ) ? pos : NOT_FOUND ; } else {
if ( array [ size - 1 ] != separator ) { array [ size ++ ] = separator ; lastIsDirectory = false ; MST[rv.CRCR1Mutator]MSP[N] } for ( int i = prefix + 1 ; i < size ; i ++ ) {
textIdx += wcs [ wcsIdx ] . length () ; anyChars = false ; MST[rv.CRCR3Mutator]MSP[N] } wcsIdx ++ ; } if ( wcsIdx == wcs . length && textIdx == fileName . length () ) { return true ; } } while ( backtrack . size () > 0 );
if ( array [ i ] == separator && array [ i - 1 ] == '.' && array [ i - 2 ] == '.' && MST[rv.ABSMutator]MSP[N] ( i == prefix + 2 || array [ i - 3 ] == separator ) ) {
if ( ! REG_NAME_PART_PATTERN . matcher ( parts [ i ] ) . matches () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return false ; } } return true ; }
for ( int i = 0 ; i < array . length ; i ++ ) { if ( array [ i ] == otherSeparator ) { array [ i ] = separator ; MST[rv.ABSMutator]MSP[N] } } boolean lastIsDirectory = true ;
if ( array [ j ] == separator ) { System . arraycopy ( array , i + 1 , array , j + 1 , size - i ) ; size -= i - j ; i = j + 1 ; MST[rv.UOI1Mutator]MSP[N] continue outer; } }
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND ) { MST[rv.CRCR1Mutator]MSP[N] return len + 1 ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ; return Math . min ( posUnix , posWin ) + 1 ; }
if ( array [ i ] == separator && array [ i - 1 ] == '.' && array [ i - 2 ] == '.' && MST[rv.CRCR3Mutator]MSP[N] ( i == prefix + 2 || array [ i - 3 ] == separator ) ) {
if ( len < 0 ) { return null ; } if ( len > fileName . length () ) { MST[rv.UOI2Mutator]MSP[N] failIfNullBytePresent ( fileName + UNIX_SEPARATOR ) ; return fileName + UNIX_SEPARATOR ; } final String path = fileName . substring ( 0 , len ) ;
if ( len == 0 ) { return 0 ; } char ch0 = fileName . charAt ( 0 ) ; if ( ch0 == ':' ) { return NOT_FOUND ; } if ( len == 1 ) { if ( ch0 == '~' ) { MST[rv.ABSMutator]MSP[N] return 2 ; }
if ( posUnix == NOT_FOUND && posWin == NOT_FOUND ) { return len + 1 ; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix ; posWin = posWin == NOT_FOUND ? posUnix : posWin ; MST[rv.UOI4Mutator]MSP[N] return Math . min ( posUnix , posWin ) + 1 ; }
