if ( appXml ) { return calculateRawEncoding ( bomEnc , xmlGuessEnc , xmlEnc ) ; MST[ArgumentPropagationMutator]MSP[] } return defaultEncoding == null ? US_ASCII : defaultEncoding ; } if ( cTEnc . equals ( UTF_16BE ) || cTEnc . equals ( UTF_16LE ) ) { if ( bomEnc != null ) {
String calculateHttpEncoding ( final String httpContentType , final String bomEnc , final String xmlGuessEnc , final String xmlEnc , final boolean lenient ) throws IOException { if ( lenient && xmlEnc != null ) { MST[rv.UOI3Mutator]MSP[] return xmlEnc ; } final String cTMime = getContentTypeMime ( httpContentType ) ;
mime . equals ( lr_9 ) || MST[NegateConditionalsMutator]MSP[] mime . equals ( lr_10 ) || mime . startsWith ( lr_11 ) && mime . endsWith ( lr_12 ) ) ; } static boolean isTextXml ( final String mime ) { return mime != null &&
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { offset += c ; MST[rv.ABSMutator]MSP[] max -= c ; c = is . read ( bytes , offset , max ) ;
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR6Mutator]MSP[] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
final String postMime = httpContentType . substring ( i + 1 ) ; final Matcher m = CHARSET_PATTERN . matcher ( postMime ) ; encoding = m . find () ? m . group ( 1 ) : null ; MST[rv.ROR2Mutator]MSP[]
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { offset += c ; max -= c ; MST[rv.AOR4Mutator]MSP[] c = is . read ( bytes , offset , max ) ;
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } if ( bomEnc . equals ( UTF_16BE ) || bomEnc . equals ( UTF_16LE ) ) { if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( bomEnc ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR3Mutator]MSP[] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( xmlEnc != null && ! xmlEnc . equals ( UTF_8 ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[InlineConstantMutator]MSP[]
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_32 ) && ! xmlEnc . equals ( bomEnc ) ) { MST[rv.ROR5Mutator]MSP[] final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
final String postMime = httpContentType . substring ( i + 1 ) ; MST[experimental.NakedReceiverMutator]MSP[] final Matcher m = CHARSET_PATTERN . matcher ( postMime ) ; encoding = m . find () ? m . group ( 1 ) : null ;
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } if ( bomEnc . equals ( UTF_16BE ) || bomEnc . equals ( UTF_16LE ) ) { MST[NonVoidMethodCallMutator]MSP[] if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( bomEnc ) ) {
encoding = encoding . substring ( 1 , encoding . length () - 1 ) ; MST[MathMutator]MSP[] } } } return encoding ; } static boolean isAppXml ( final String mime ) { return mime != null && ( mime . equals ( lr_8 ) ||
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( xmlEnc != null && ! xmlEnc . equals ( UTF_8 ) ) { MST[NegateConditionalsMutator]MSP[] final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } if ( bomEnc . equals ( UTF_16BE ) || bomEnc . equals ( UTF_16LE ) ) { if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( bomEnc ) ) { MST[rv.ROR3Mutator]MSP[]
final int i = httpContentType . indexOf ( lr_3 ) ; if ( i >= 0 ) { mime = httpContentType . substring ( 0 , i ) ; MST[NonVoidMethodCallMutator]MSP[] } else { mime = httpContentType ; } mime = mime . trim () ; } return mime ; }
throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[ConstructorCallMutator]MSP[] } return cTEnc ; } static String getContentTypeMime ( final String httpContentType ) { String mime = null ; if ( httpContentType != null ) {
xmlProlog = new String ( bytes , 0 , offset , guessedEnc ) ; firstGT = xmlProlog . indexOf ( '>' ) ; } if ( firstGT == - 1 ) { MST[rv.UOI3Mutator]MSP[] if ( c == - 1 ) { throw new IOException ( lr_5 ) ; }
throw new IOException ( lr_6 + offset + lr_7 ) ; } final int bytesRead = offset ; if ( bytesRead > 0 ) { is . reset () ; final BufferedReader bReader = new BufferedReader ( new StringReader ( MST[rv.AOR1Mutator]MSP[]
final int i = httpContentType . indexOf ( lr_3 ) ; if ( i >= 0 ) { mime = httpContentType . substring ( 0 , i ) ; } else { mime = httpContentType ; } mime = mime . trim () ; } return mime ; MST[EmptyObjectReturnValsMutator]MSP[] }
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { MST[rv.CRCR4Mutator]MSP[] offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ;
} return xmlEnc ; } if ( bomEnc . equals ( UTF_8 ) ) { if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( UTF_8 ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[InlineConstantMutator]MSP[]
encoding = encoding . substring ( 1 , encoding . length () - 1 ) ; } } } return encoding ; } static boolean isAppXml ( final String mime ) { return mime != null && ( mime . equals ( lr_8 ) || MST[NonVoidMethodCallMutator]MSP[]
final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR2Mutator]MSP[] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
final String msg = MessageFormat . format ( HTTP_EX_3 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR4Mutator]MSP[] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( cTEnc == null ) {
String calculateHttpEncoding ( final String httpContentType , final String bomEnc , final String xmlGuessEnc , final String xmlEnc , final boolean lenient ) throws IOException { if ( lenient && xmlEnc != null ) { MST[rv.ROR4Mutator]MSP[] return xmlEnc ; } final String cTMime = getContentTypeMime ( httpContentType ) ;
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } if ( bomEnc . equals ( UTF_16BE ) || bomEnc . equals ( UTF_16LE ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( bomEnc ) ) {
throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( cTEnc . equals ( UTF_32BE ) || cTEnc . equals ( UTF_32LE ) ) { MST[rv.ROR1Mutator]MSP[] if ( bomEnc != null ) {
if ( cTEnc . equals ( UTF_16 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_16 ) ) { MST[rv.ROR4Mutator]MSP[] return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ;
if ( cTEnc . equals ( UTF_32 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_32 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR6Mutator]MSP[]
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( xmlEnc != null && ! xmlEnc . equals ( UTF_8 ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR6Mutator]MSP[]
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR6Mutator]MSP[] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR5Mutator]MSP[] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } final String msg = MessageFormat . format ( RAW_EX_2 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR2Mutator]MSP[] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
if ( xmlGuessEnc == null || xmlEnc == null ) { return defaultEncoding == null ? UTF_8 : defaultEncoding ; } if ( xmlEnc . equals ( UTF_16 ) && ( xmlGuessEnc . equals ( UTF_16BE ) || xmlGuessEnc . equals ( UTF_16LE ) ) ) { MST[rv.ROR1Mutator]MSP[] return xmlGuessEnc ;
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } final String msg = MessageFormat . format ( RAW_EX_2 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR3Mutator]MSP[] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
final int i = httpContentType . indexOf ( lr_3 ) ; if ( i >= 0 ) { mime = httpContentType . substring ( 0 , i ) ; MST[rv.CRCR6Mutator]MSP[] } else { mime = httpContentType ; } mime = mime . trim () ; } return mime ; }
if ( guessedEnc != null ) { final byte [] bytes = new byte [ BUFFER_SIZE ] ; is . mark ( BUFFER_SIZE ) ; int offset = 0 ; int max = BUFFER_SIZE ; int c = is . read ( bytes , offset , max ) ; MST[rv.UOI3Mutator]MSP[]
if ( appXml ) { MST[rv.ROR4Mutator]MSP[] return calculateRawEncoding ( bomEnc , xmlGuessEnc , xmlEnc ) ; } return defaultEncoding == null ? US_ASCII : defaultEncoding ; } if ( cTEnc . equals ( UTF_16BE ) || cTEnc . equals ( UTF_16LE ) ) { if ( bomEnc != null ) {
( mime . equals ( lr_2 ) || mime . equals ( lr_13 ) || MST[rv.ROR4Mutator]MSP[] mime . startsWith ( lr_14 ) && mime . endsWith ( lr_12 ) ) ; }
if ( appXml ) { MST[rv.UOI3Mutator]MSP[] return calculateRawEncoding ( bomEnc , xmlGuessEnc , xmlEnc ) ; } return defaultEncoding == null ? US_ASCII : defaultEncoding ; } if ( cTEnc . equals ( UTF_16BE ) || cTEnc . equals ( UTF_16LE ) ) { if ( bomEnc != null ) {
( mime . equals ( lr_2 ) || MST[rv.ROR2Mutator]MSP[] mime . equals ( lr_13 ) || mime . startsWith ( lr_14 ) && mime . endsWith ( lr_12 ) ) ; }
final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR3Mutator]MSP[] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } if ( bomEnc . equals ( UTF_32BE ) || bomEnc . equals ( UTF_32LE ) ) { MST[NegateConditionalsMutator]MSP[] if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( bomEnc ) ) {
final String msg = MessageFormat . format ( HTTP_EX_3 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[InlineConstantMutator]MSP[] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( cTEnc == null ) {
if ( guessedEnc != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] final byte [] bytes = new byte [ BUFFER_SIZE ] ; is . mark ( BUFFER_SIZE ) ; int offset = 0 ; int max = BUFFER_SIZE ; int c = is . read ( bytes , offset , max ) ;
if ( appXml ) { return calculateRawEncoding ( bomEnc , xmlGuessEnc , xmlEnc ) ; } return defaultEncoding == null ? US_ASCII : defaultEncoding ; } if ( cTEnc . equals ( UTF_16BE ) || cTEnc . equals ( UTF_16LE ) ) { MST[rv.ROR1Mutator]MSP[] if ( bomEnc != null ) {
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( xmlEnc != null && ! xmlEnc . equals ( UTF_8 ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR4Mutator]MSP[]
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( xmlEnc != null && ! xmlEnc . equals ( UTF_8 ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR1Mutator]MSP[]
final String bomEnc = bom . getBOMCharsetName () ; final String xmlGuessEnc = pis . getBOMCharsetName () ; final String xmlEnc = getXmlProlog ( pis , xmlGuessEnc ) ; try { return calculateHttpEncoding ( httpContentType , bomEnc , MST[EmptyObjectReturnValsMutator]MSP[] xmlGuessEnc , xmlEnc , lenient ) ;
if ( appXml ) { return calculateRawEncoding ( bomEnc , xmlGuessEnc , xmlEnc ) ; } return defaultEncoding == null ? US_ASCII : defaultEncoding ; } if ( cTEnc . equals ( UTF_16BE ) || cTEnc . equals ( UTF_16LE ) ) { MST[rv.ROR4Mutator]MSP[] if ( bomEnc != null ) {
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_32 ) && ! xmlEnc . equals ( bomEnc ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[InlineConstantMutator]MSP[]
mime . equals ( lr_9 ) || mime . equals ( lr_10 ) || mime . startsWith ( lr_11 ) && mime . endsWith ( lr_12 ) ) ; MST[rv.CRCR4Mutator]MSP[] } static boolean isTextXml ( final String mime ) { return mime != null &&
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } final String msg = MessageFormat . format ( RAW_EX_2 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR5Mutator]MSP[] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
final String postMime = httpContentType . substring ( i + 1 ) ; MST[InlineConstantMutator]MSP[] final Matcher m = CHARSET_PATTERN . matcher ( postMime ) ; encoding = m . find () ? m . group ( 1 ) : null ;
if ( encoding == null ) { encoding = defaultEncoding == null ? UTF_8 : defaultEncoding ; } return encoding ; MST[EmptyObjectReturnValsMutator]MSP[] } String calculateRawEncoding ( final String bomEnc , final String xmlGuessEnc , final String xmlEnc ) throws IOException { if ( bomEnc == null ) {
final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[NonVoidMethodCallMutator]MSP[] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
final String cTEnc = getContentTypeEncoding ( httpContentType ) ; final boolean appXml = isAppXml ( cTMime ) ; final boolean textXml = isTextXml ( cTMime ) ; MST[NonVoidMethodCallMutator]MSP[] if ( ! appXml && ! textXml ) {
if ( cTEnc . equals ( UTF_16 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_16 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR6Mutator]MSP[]
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } final String msg = MessageFormat . format ( RAW_EX_2 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR6Mutator]MSP[] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
final String cTEnc = getContentTypeEncoding ( httpContentType ) ; final boolean appXml = isAppXml ( cTMime ) ; final boolean textXml = isTextXml ( cTMime ) ; if ( ! appXml && ! textXml ) { MST[NegateConditionalsMutator]MSP[]
return reader . read ( buf , offset , len ) ; MST[rv.UOI3Mutator]MSP[] } @Override public void close () throws IOException { reader . close () ; } private String doRawStream ( final BOMInputStream bom , final BOMInputStream pis , final boolean lenient ) throws IOException {
int firstGT = - 1 ; MST[rv.CRCR1Mutator]MSP[] String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ;
final String bomEnc = bom . getBOMCharsetName () ; final String xmlGuessEnc = pis . getBOMCharsetName () ; final String xmlEnc = getXmlProlog ( pis , xmlGuessEnc ) ; try { return calculateRawEncoding ( bomEnc , xmlGuessEnc , xmlEnc ) ; MST[EmptyObjectReturnValsMutator]MSP[] } catch ( final XmlStreamReaderException ex ) {
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ; MST[ArgumentPropagationMutator]MSP[]
if ( xmlGuessEnc == null || xmlEnc == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return defaultEncoding == null ? UTF_8 : defaultEncoding ; } if ( xmlEnc . equals ( UTF_16 ) && ( xmlGuessEnc . equals ( UTF_16BE ) || xmlGuessEnc . equals ( UTF_16LE ) ) ) { return xmlGuessEnc ;
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( xmlEnc != null && ! xmlEnc . equals ( UTF_8 ) ) { MST[rv.ROR2Mutator]MSP[] final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
( mime . equals ( lr_2 ) || mime . equals ( lr_13 ) || mime . startsWith ( lr_14 ) && mime . endsWith ( lr_12 ) ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] }
if ( guessedEnc != null ) { final byte [] bytes = new byte [ BUFFER_SIZE ] ; is . mark ( BUFFER_SIZE ) ; MST[rv.CRCR3Mutator]MSP[] int offset = 0 ; int max = BUFFER_SIZE ; int c = is . read ( bytes , offset , max ) ;
if ( cTEnc . equals ( UTF_16 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_16 ) ) { MST[rv.ROR1Mutator]MSP[] return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ;
String calculateHttpEncoding ( final String httpContentType , final String bomEnc , final String xmlGuessEnc , final String xmlEnc , final boolean lenient ) throws IOException { if ( lenient && xmlEnc != null ) { MST[rv.ROR1Mutator]MSP[] return xmlEnc ; } final String cTMime = getContentTypeMime ( httpContentType ) ;
mime . equals ( lr_9 ) || mime . equals ( lr_10 ) || mime . startsWith ( lr_11 ) && mime . endsWith ( lr_12 ) ) ; } static boolean isTextXml ( final String mime ) { return mime != null && MST[BooleanTrueReturnValsMutator]MSP[]
int firstGT = - 1 ; MST[rv.CRCR4Mutator]MSP[] String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ;
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { offset += c ; max -= c ; MST[rv.UOI4Mutator]MSP[] c = is . read ( bytes , offset , max ) ;
final String postMime = httpContentType . substring ( i + 1 ) ; MST[rv.UOI2Mutator]MSP[] final Matcher m = CHARSET_PATTERN . matcher ( postMime ) ; encoding = m . find () ? m . group ( 1 ) : null ;
mime . equals ( lr_9 ) || mime . equals ( lr_10 ) || mime . startsWith ( lr_11 ) && mime . endsWith ( lr_12 ) ) ; } static boolean isTextXml ( final String mime ) { return mime != null && MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( cTEnc . equals ( UTF_32BE ) || cTEnc . equals ( UTF_32LE ) ) { MST[rv.ROR4Mutator]MSP[] if ( bomEnc != null ) {
if ( cTEnc . equals ( UTF_32 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_32 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR3Mutator]MSP[]
if ( guessedEnc != null ) { final byte [] bytes = new byte [ BUFFER_SIZE ] ; is . mark ( BUFFER_SIZE ) ; int offset = 0 ; int max = BUFFER_SIZE ; MST[InlineConstantMutator]MSP[] int c = is . read ( bytes , offset , max ) ;
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { offset += c ; MST[rv.UOI2Mutator]MSP[] max -= c ; c = is . read ( bytes , offset , max ) ;
if ( httpContentType != null && httpContentType . startsWith ( lr_1 ) ) { httpContentType = httpContentType . substring ( lr_1 . length () ) ; httpContentType = lr_2 + httpContentType ; try { return calculateHttpEncoding ( httpContentType , ex . getBomEncoding () , MST[EmptyObjectReturnValsMutator]MSP[]
final int i = httpContentType . indexOf ( lr_3 ) ; if ( i >= 0 ) { MST[rv.UOI1Mutator]MSP[] mime = httpContentType . substring ( 0 , i ) ; } else { mime = httpContentType ; } mime = mime . trim () ; } return mime ; }
final int i = httpContentType . indexOf ( lr_3 ) ; if ( i >= 0 ) { MST[rv.UOI4Mutator]MSP[] mime = httpContentType . substring ( 0 , i ) ; } else { mime = httpContentType ; } mime = mime . trim () ; } return mime ; }
xmlProlog = new String ( bytes , 0 , offset , guessedEnc ) ; MST[rv.UOI4Mutator]MSP[] firstGT = xmlProlog . indexOf ( '>' ) ; } if ( firstGT == - 1 ) { if ( c == - 1 ) { throw new IOException ( lr_5 ) ; }
} final Matcher m = ENCODING_PATTERN . matcher ( prolog ) ; MST[NonVoidMethodCallMutator]MSP[] if ( m . find () ) { encoding = m . group ( 1 ) . toUpperCase ( Locale . ROOT ) ;
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ; MST[rv.UOI1Mutator]MSP[]
final int i = httpContentType . indexOf ( lr_3 ) ; if ( i >= 0 ) { mime = httpContentType . substring ( 0 , i ) ; MST[rv.UOI3Mutator]MSP[] } else { mime = httpContentType ; } mime = mime . trim () ; } return mime ; }
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( xmlEnc != null && ! xmlEnc . equals ( UTF_8 ) ) { MST[rv.ROR5Mutator]MSP[] final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
xmlProlog = new String ( bytes , 0 , offset , guessedEnc ) ; firstGT = xmlProlog . indexOf ( '>' ) ; } if ( firstGT == - 1 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] if ( c == - 1 ) { throw new IOException ( lr_5 ) ; }
final String cTEnc = getContentTypeEncoding ( httpContentType ) ; final boolean appXml = isAppXml ( cTMime ) ; final boolean textXml = isTextXml ( cTMime ) ; if ( ! appXml && ! textXml ) { MST[rv.UOI4Mutator]MSP[]
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_32 ) && ! xmlEnc . equals ( bomEnc ) ) { MST[NegateConditionalsMutator]MSP[] final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
final String cTEnc = getContentTypeEncoding ( httpContentType ) ; final boolean appXml = isAppXml ( cTMime ) ; final boolean textXml = isTextXml ( cTMime ) ; if ( ! appXml && ! textXml ) { MST[rv.ROR3Mutator]MSP[]
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_16 ) && ! xmlEnc . equals ( bomEnc ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
final String msg = MessageFormat . format ( HTTP_EX_3 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR1Mutator]MSP[] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( cTEnc == null ) {
throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; } static String getContentTypeMime ( final String httpContentType ) { String mime = null ; if ( httpContentType != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR6Mutator]MSP[] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
public String getDefaultEncoding () { return defaultEncoding ; MST[ReturnValsMutator]MSP[] } public String getEncoding () { return encoding ; } @Override public int read ( final char [] buf , final int offset , final int len ) throws IOException {
if ( xmlGuessEnc == null || xmlEnc == null ) { return defaultEncoding == null ? UTF_8 : defaultEncoding ; MST[NegateConditionalsMutator]MSP[] } if ( xmlEnc . equals ( UTF_16 ) && ( xmlGuessEnc . equals ( UTF_16BE ) || xmlGuessEnc . equals ( UTF_16LE ) ) ) { return xmlGuessEnc ;
final int i = httpContentType . indexOf ( lr_3 ) ; if ( i >= 0 ) { mime = httpContentType . substring ( 0 , i ) ; MST[rv.CRCR3Mutator]MSP[] } else { mime = httpContentType ; } mime = mime . trim () ; } return mime ; }
final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR4Mutator]MSP[] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR3Mutator]MSP[] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_32 ) && ! xmlEnc . equals ( bomEnc ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR6Mutator]MSP[]
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR1Mutator]MSP[] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } if ( bomEnc . equals ( UTF_16BE ) || bomEnc . equals ( UTF_16LE ) ) { if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( bomEnc ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( xmlEnc != null && ! xmlEnc . equals ( UTF_8 ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[InlineConstantMutator]MSP[]
final int i = httpContentType . indexOf ( lr_3 ) ; if ( i >= 0 ) { mime = httpContentType . substring ( 0 , i ) ; } else { mime = httpContentType ; } mime = mime . trim () ; MST[experimental.NakedReceiverMutator]MSP[] } return mime ; }
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_32 ) && ! xmlEnc . equals ( bomEnc ) ) { MST[rv.ROR5Mutator]MSP[] final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[ConstructorCallMutator]MSP[] } return cTEnc ; }
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } if ( bomEnc . equals ( UTF_16BE ) || bomEnc . equals ( UTF_16LE ) ) { MST[NonVoidMethodCallMutator]MSP[] if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( bomEnc ) ) {
if ( httpContentType != null && httpContentType . startsWith ( lr_1 ) ) { httpContentType = httpContentType . substring ( lr_1 . length () ) ; httpContentType = lr_2 + httpContentType ; MST[NonVoidMethodCallMutator]MSP[] try { return calculateHttpEncoding ( httpContentType , ex . getBomEncoding () ,
static String getContentTypeEncoding ( final String httpContentType ) { String encoding = null ; if ( httpContentType != null ) { final int i = httpContentType . indexOf ( lr_3 ) ; if ( i > - 1 ) { MST[rv.UOI3Mutator]MSP[]
final String cTEnc = getContentTypeEncoding ( httpContentType ) ; final boolean appXml = isAppXml ( cTMime ) ; final boolean textXml = isTextXml ( cTMime ) ; if ( ! appXml && ! textXml ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
} final Matcher m = ENCODING_PATTERN . matcher ( prolog ) ; if ( m . find () ) { encoding = m . group ( 1 ) . toUpperCase ( Locale . ROOT ) ; MST[NonVoidMethodCallMutator]MSP[]
} return xmlEnc ; } if ( bomEnc . equals ( UTF_8 ) ) { MST[rv.ROR1Mutator]MSP[] if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( UTF_8 ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
} return xmlEnc ; } if ( bomEnc . equals ( UTF_8 ) ) { if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( UTF_8 ) ) { MST[rv.ROR5Mutator]MSP[] final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
xmlProlog = new String ( bytes , 0 , offset , guessedEnc ) ; firstGT = xmlProlog . indexOf ( '>' ) ; MST[rv.CRCR4Mutator]MSP[] } if ( firstGT == - 1 ) { if ( c == - 1 ) { throw new IOException ( lr_5 ) ; }
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } if ( bomEnc . equals ( UTF_16BE ) || bomEnc . equals ( UTF_16LE ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( bomEnc ) ) {
if ( cTEnc . equals ( UTF_32 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_32 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR6Mutator]MSP[]
final String msg = MessageFormat . format ( HTTP_EX_3 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR4Mutator]MSP[] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( cTEnc == null ) {
static String getContentTypeEncoding ( final String httpContentType ) { String encoding = null ; if ( httpContentType != null ) { final int i = httpContentType . indexOf ( lr_3 ) ; if ( i > - 1 ) { MST[rv.CRCR5Mutator]MSP[]
throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( cTEnc . equals ( UTF_32BE ) || cTEnc . equals ( UTF_32LE ) ) { MST[rv.ROR1Mutator]MSP[] if ( bomEnc != null ) {
final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR5Mutator]MSP[] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
if ( cTEnc . equals ( UTF_16 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_16 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR1Mutator]MSP[]
xmlProlog = new String ( bytes , 0 , offset , guessedEnc ) ; MST[ConstructorCallMutator]MSP[] firstGT = xmlProlog . indexOf ( '>' ) ; } if ( firstGT == - 1 ) { if ( c == - 1 ) { throw new IOException ( lr_5 ) ; }
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR6Mutator]MSP[] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } if ( bomEnc . equals ( UTF_16BE ) || bomEnc . equals ( UTF_16LE ) ) { MST[rv.ROR3Mutator]MSP[] if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( bomEnc ) ) {
throw new IOException ( lr_6 + offset + lr_7 ) ; } final int bytesRead = offset ; if ( bytesRead > 0 ) { is . reset () ; final BufferedReader bReader = new BufferedReader ( new StringReader ( MST[rv.CRCR3Mutator]MSP[]
} return xmlEnc ; } if ( bomEnc . equals ( UTF_8 ) ) { if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( UTF_8 ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR4Mutator]MSP[]
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } final String msg = MessageFormat . format ( RAW_EX_2 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR3Mutator]MSP[] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
if ( cTEnc . equals ( UTF_16 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_16 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR3Mutator]MSP[]
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { MST[rv.CRCR1Mutator]MSP[] offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ;
throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[ConstructorCallMutator]MSP[] } if ( cTEnc . equals ( UTF_32BE ) || cTEnc . equals ( UTF_32LE ) ) { if ( bomEnc != null ) {
} return xmlEnc ; } if ( bomEnc . equals ( UTF_8 ) ) { if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( UTF_8 ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[NonVoidMethodCallMutator]MSP[]
if ( xmlGuessEnc == null || xmlEnc == null ) { return defaultEncoding == null ? UTF_8 : defaultEncoding ; } if ( xmlEnc . equals ( UTF_16 ) && ( xmlGuessEnc . equals ( UTF_16BE ) || xmlGuessEnc . equals ( UTF_16LE ) ) ) { MST[rv.ROR1Mutator]MSP[] return xmlGuessEnc ;
if ( appXml ) { return calculateRawEncoding ( bomEnc , xmlGuessEnc , xmlEnc ) ; } return defaultEncoding == null ? US_ASCII : defaultEncoding ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] } if ( cTEnc . equals ( UTF_16BE ) || cTEnc . equals ( UTF_16LE ) ) { if ( bomEnc != null ) {
} return xmlEnc ; } if ( bomEnc . equals ( UTF_8 ) ) { if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( UTF_8 ) ) { MST[NegateConditionalsMutator]MSP[] final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR2Mutator]MSP[] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
} return xmlEnc ; MST[EmptyObjectReturnValsMutator]MSP[] } if ( bomEnc . equals ( UTF_8 ) ) { if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( UTF_8 ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } if ( bomEnc . equals ( UTF_32BE ) || bomEnc . equals ( UTF_32LE ) ) { MST[NegateConditionalsMutator]MSP[] if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( bomEnc ) ) {
final String msg = MessageFormat . format ( HTTP_EX_3 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[InlineConstantMutator]MSP[] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( cTEnc == null ) {
final String msg = MessageFormat . format ( HTTP_EX_3 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR6Mutator]MSP[] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( cTEnc == null ) {
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { MST[rv.CRCR2Mutator]MSP[] offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ;
ex . getXmlGuessEncoding () , ex . getXmlEncoding () , true ) ; MST[rv.CRCR4Mutator]MSP[] } catch ( final XmlStreamReaderException ex2 ) { ex = ex2 ; } } String encoding = ex . getXmlEncoding () ; if ( encoding == null ) { encoding = ex . getContentTypeEncoding () ; }
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; MST[ReturnValsMutator]MSP[] } if ( bomEnc . equals ( UTF_32BE ) || bomEnc . equals ( UTF_32LE ) ) { if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( bomEnc ) ) {
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( xmlEnc != null && ! xmlEnc . equals ( UTF_8 ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR4Mutator]MSP[]
final String bomEnc = bom . getBOMCharsetName () ; final String xmlGuessEnc = pis . getBOMCharsetName () ; final String xmlEnc = getXmlProlog ( pis , xmlGuessEnc ) ; try { return calculateHttpEncoding ( httpContentType , bomEnc , MST[rv.UOI4Mutator]MSP[] xmlGuessEnc , xmlEnc , lenient ) ;
} return xmlEnc ; } if ( bomEnc . equals ( UTF_8 ) ) { if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( UTF_8 ) ) { MST[NegateConditionalsMutator]MSP[] final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
if ( appXml ) { return calculateRawEncoding ( bomEnc , xmlGuessEnc , xmlEnc ) ; } return defaultEncoding == null ? US_ASCII : defaultEncoding ; } if ( cTEnc . equals ( UTF_16BE ) || cTEnc . equals ( UTF_16LE ) ) { MST[rv.ROR4Mutator]MSP[] if ( bomEnc != null ) {
mime . equals ( lr_9 ) || mime . equals ( lr_10 ) || mime . startsWith ( lr_11 ) && mime . endsWith ( lr_12 ) ) ; MST[rv.CRCR1Mutator]MSP[] } static boolean isTextXml ( final String mime ) { return mime != null &&
if ( cTEnc . equals ( UTF_16 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_16 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR6Mutator]MSP[]
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { offset += c ; MST[rv.UOI3Mutator]MSP[] max -= c ; c = is . read ( bytes , offset , max ) ;
if ( cTEnc . equals ( UTF_32 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_32 ) ) { MST[rv.ROR1Mutator]MSP[] return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ;
if ( httpContentType != null && httpContentType . startsWith ( lr_1 ) ) { MST[rv.ROR1Mutator]MSP[] httpContentType = httpContentType . substring ( lr_1 . length () ) ; httpContentType = lr_2 + httpContentType ; try { return calculateHttpEncoding ( httpContentType , ex . getBomEncoding () ,
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_32 ) && ! xmlEnc . equals ( bomEnc ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[InlineConstantMutator]MSP[]
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR3Mutator]MSP[] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
final String postMime = httpContentType . substring ( i + 1 ) ; MST[rv.AOR1Mutator]MSP[] final Matcher m = CHARSET_PATTERN . matcher ( postMime ) ; encoding = m . find () ? m . group ( 1 ) : null ;
final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[InlineConstantMutator]MSP[] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } if ( bomEnc . equals ( UTF_32BE ) || bomEnc . equals ( UTF_32LE ) ) { MST[rv.ROR5Mutator]MSP[] if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( bomEnc ) ) {
encoding = encoding . substring ( 1 , encoding . length () - 1 ) ; } } } return encoding ; } static boolean isAppXml ( final String mime ) { return mime != null && ( mime . equals ( lr_8 ) || MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
} return xmlEnc ; } if ( bomEnc . equals ( UTF_8 ) ) { if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( UTF_8 ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[InlineConstantMutator]MSP[]
( mime . equals ( lr_2 ) || mime . equals ( lr_13 ) || mime . startsWith ( lr_14 ) && mime . endsWith ( lr_12 ) ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] }
if ( guessedEnc != null ) { final byte [] bytes = new byte [ BUFFER_SIZE ] ; is . mark ( BUFFER_SIZE ) ; int offset = 0 ; MST[rv.CRCR3Mutator]MSP[] int max = BUFFER_SIZE ; int c = is . read ( bytes , offset , max ) ;
xmlProlog = new String ( bytes , 0 , offset , guessedEnc ) ; MST[rv.CRCR1Mutator]MSP[] firstGT = xmlProlog . indexOf ( '>' ) ; } if ( firstGT == - 1 ) { if ( c == - 1 ) { throw new IOException ( lr_5 ) ; }
mime . equals ( lr_9 ) || MST[rv.ROR5Mutator]MSP[] mime . equals ( lr_10 ) || mime . startsWith ( lr_11 ) && mime . endsWith ( lr_12 ) ) ; } static boolean isTextXml ( final String mime ) { return mime != null &&
encoding = encoding . substring ( 1 , encoding . length () - 1 ) ; } } } return encoding ; } static boolean isAppXml ( final String mime ) { return mime != null && ( mime . equals ( lr_8 ) || MST[rv.ROR3Mutator]MSP[]
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_32 ) && ! xmlEnc . equals ( bomEnc ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR4Mutator]MSP[]
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { MST[rv.ROR2Mutator]MSP[] offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ;
} final Matcher m = ENCODING_PATTERN . matcher ( prolog ) ; if ( m . find () ) { encoding = m . group ( 1 ) . toUpperCase ( Locale . ROOT ) ; MST[rv.CRCR3Mutator]MSP[]
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { offset += c ; max -= c ; MST[rv.AOD2Mutator]MSP[] c = is . read ( bytes , offset , max ) ;
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_16 ) && ! xmlEnc . equals ( bomEnc ) ) { MST[NonVoidMethodCallMutator]MSP[] final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
if ( cTEnc . equals ( UTF_32 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_32 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR3Mutator]MSP[]
final int i = httpContentType . indexOf ( lr_3 ) ; if ( i >= 0 ) { MST[rv.ROR2Mutator]MSP[] mime = httpContentType . substring ( 0 , i ) ; } else { mime = httpContentType ; } mime = mime . trim () ; } return mime ; }
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_16 ) && ! xmlEnc . equals ( bomEnc ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR1Mutator]MSP[]
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( xmlEnc != null && ! xmlEnc . equals ( UTF_8 ) ) { MST[rv.ROR5Mutator]MSP[] final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
final String cTEnc = getContentTypeEncoding ( httpContentType ) ; final boolean appXml = isAppXml ( cTMime ) ; final boolean textXml = isTextXml ( cTMime ) ; if ( ! appXml && ! textXml ) { MST[rv.ROR5Mutator]MSP[]
if ( cTEnc . equals ( UTF_32 ) ) { MST[rv.ROR4Mutator]MSP[] if ( bomEnc != null && bomEnc . startsWith ( UTF_32 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ;
if ( guessedEnc != null ) { final byte [] bytes = new byte [ BUFFER_SIZE ] ; is . mark ( BUFFER_SIZE ) ; int offset = 0 ; MST[InlineConstantMutator]MSP[] int max = BUFFER_SIZE ; int c = is . read ( bytes , offset , max ) ;
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_32 ) && ! xmlEnc . equals ( bomEnc ) ) { MST[NegateConditionalsMutator]MSP[] final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ; MST[rv.UOI2Mutator]MSP[]
} final Matcher m = ENCODING_PATTERN . matcher ( prolog ) ; if ( m . find () ) { encoding = m . group ( 1 ) . toUpperCase ( Locale . ROOT ) ; MST[InlineConstantMutator]MSP[]
final String cTEnc = getContentTypeEncoding ( httpContentType ) ; final boolean appXml = isAppXml ( cTMime ) ; final boolean textXml = isTextXml ( cTMime ) ; if ( ! appXml && ! textXml ) { MST[rv.UOI2Mutator]MSP[]
final String msg = MessageFormat . format ( HTTP_EX_3 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR1Mutator]MSP[] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( cTEnc == null ) {
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_16 ) && ! xmlEnc . equals ( bomEnc ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { MST[rv.CRCR6Mutator]MSP[] offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ;
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_32 ) && ! xmlEnc . equals ( bomEnc ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[NonVoidMethodCallMutator]MSP[]
String calculateHttpEncoding ( final String httpContentType , final String bomEnc , final String xmlGuessEnc , final String xmlEnc , final boolean lenient ) throws IOException { if ( lenient && xmlEnc != null ) { return xmlEnc ; MST[EmptyObjectReturnValsMutator]MSP[] } final String cTMime = getContentTypeMime ( httpContentType ) ;
xmlProlog . substring ( 0 , firstGT + 1 ) ) ) ; final StringBuffer prolog = new StringBuffer () ; String line = bReader . readLine () ; while ( line != null ) { MST[NegateConditionalsMutator]MSP[] prolog . append ( line ) ; line = bReader . readLine () ;
final String bomEnc = bom . getBOMCharsetName () ; final String xmlGuessEnc = pis . getBOMCharsetName () ; final String xmlEnc = getXmlProlog ( pis , xmlGuessEnc ) ; try { return calculateRawEncoding ( bomEnc , xmlGuessEnc , xmlEnc ) ; MST[ReturnValsMutator]MSP[] } catch ( final XmlStreamReaderException ex ) {
if ( cTEnc . equals ( UTF_32 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_32 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR1Mutator]MSP[]
} catch ( final XmlStreamReaderException ex ) { if ( lenient ) { MST[rv.UOI3Mutator]MSP[] return doLenientDetection ( httpContentType , ex ) ; } throw ex ; } } private String doLenientDetection ( String httpContentType , XmlStreamReaderException ex ) throws IOException {
if ( httpContentType != null && httpContentType . startsWith ( lr_1 ) ) { MST[NegateConditionalsMutator]MSP[] httpContentType = httpContentType . substring ( lr_1 . length () ) ; httpContentType = lr_2 + httpContentType ; try { return calculateHttpEncoding ( httpContentType , ex . getBomEncoding () ,
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR6Mutator]MSP[] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; MST[EmptyObjectReturnValsMutator]MSP[] } static String getContentTypeMime ( final String httpContentType ) { String mime = null ; if ( httpContentType != null ) {
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR4Mutator]MSP[] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( xmlEnc != null && ! xmlEnc . equals ( UTF_8 ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[InlineConstantMutator]MSP[]
final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR1Mutator]MSP[] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_32 ) && ! xmlEnc . equals ( bomEnc ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR3Mutator]MSP[]
xmlProlog . substring ( 0 , firstGT + 1 ) ) ) ; final StringBuffer prolog = new StringBuffer () ; String line = bReader . readLine () ; while ( line != null ) { prolog . append ( line ) ; line = bReader . readLine () ; MST[NonVoidMethodCallMutator]MSP[]
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { offset += c ; max -= c ; MST[rv.UOI1Mutator]MSP[] c = is . read ( bytes , offset , max ) ;
mime . equals ( lr_9 ) || mime . equals ( lr_10 ) || mime . startsWith ( lr_11 ) && mime . endsWith ( lr_12 ) ) ; } static boolean isTextXml ( final String mime ) { return mime != null && MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
String calculateHttpEncoding ( final String httpContentType , final String bomEnc , final String xmlGuessEnc , final String xmlEnc , final boolean lenient ) throws IOException { if ( lenient && xmlEnc != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return xmlEnc ; } final String cTMime = getContentTypeMime ( httpContentType ) ;
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_32 ) && ! xmlEnc . equals ( bomEnc ) ) { MST[rv.ROR5Mutator]MSP[] final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
( mime . equals ( lr_2 ) || mime . equals ( lr_13 ) || mime . startsWith ( lr_14 ) && mime . endsWith ( lr_12 ) ) ; MST[rv.ROR3Mutator]MSP[] }
if ( cTEnc . equals ( UTF_32 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_32 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[NonVoidMethodCallMutator]MSP[]
throw new IOException ( lr_6 + offset + lr_7 ) ; } final int bytesRead = offset ; if ( bytesRead > 0 ) { is . reset () ; final BufferedReader bReader = new BufferedReader ( new StringReader ( MST[rv.ABSMutator]MSP[]
encoding = encoding . substring ( 1 , encoding . length () - 1 ) ; MST[rv.AOR2Mutator]MSP[] } } } return encoding ; } static boolean isAppXml ( final String mime ) { return mime != null && ( mime . equals ( lr_8 ) ||
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } if ( bomEnc . equals ( UTF_32BE ) || bomEnc . equals ( UTF_32LE ) ) { if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( bomEnc ) ) { MST[NegateConditionalsMutator]MSP[]
} return xmlEnc ; } if ( bomEnc . equals ( UTF_8 ) ) { if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( UTF_8 ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR1Mutator]MSP[]
( mime . equals ( lr_2 ) || mime . equals ( lr_13 ) || mime . startsWith ( lr_14 ) && mime . endsWith ( lr_12 ) ) ; MST[rv.CRCR5Mutator]MSP[] }
static String getContentTypeEncoding ( final String httpContentType ) { String encoding = null ; if ( httpContentType != null ) { MST[NegateConditionalsMutator]MSP[] final int i = httpContentType . indexOf ( lr_3 ) ; if ( i > - 1 ) {
if ( encoding == null ) { MST[NegateConditionalsMutator]MSP[] encoding = defaultEncoding == null ? UTF_8 : defaultEncoding ; } return encoding ; } String calculateRawEncoding ( final String bomEnc , final String xmlGuessEnc , final String xmlEnc ) throws IOException { if ( bomEnc == null ) {
} return xmlEnc ; } if ( bomEnc . equals ( UTF_8 ) ) { if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( UTF_8 ) ) { MST[rv.ROR5Mutator]MSP[] final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[ConstructorCallMutator]MSP[] }
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { MST[rv.UOI1Mutator]MSP[] offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ;
if ( cTEnc . equals ( UTF_32 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_32 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR6Mutator]MSP[]
static String getContentTypeEncoding ( final String httpContentType ) { String encoding = null ; if ( httpContentType != null ) { final int i = httpContentType . indexOf ( lr_3 ) ; if ( i > - 1 ) { MST[rv.ROR3Mutator]MSP[]
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } if ( bomEnc . equals ( UTF_16BE ) || bomEnc . equals ( UTF_16LE ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( bomEnc ) ) {
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR5Mutator]MSP[] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
mime . equals ( lr_9 ) || mime . equals ( lr_10 ) || mime . startsWith ( lr_11 ) && mime . endsWith ( lr_12 ) ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] } static boolean isTextXml ( final String mime ) { return mime != null &&
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR2Mutator]MSP[] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
final int i = httpContentType . indexOf ( lr_3 ) ; if ( i >= 0 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[] mime = httpContentType . substring ( 0 , i ) ; } else { mime = httpContentType ; } mime = mime . trim () ; } return mime ; }
throw new IOException ( lr_6 + offset + lr_7 ) ; } final int bytesRead = offset ; if ( bytesRead > 0 ) { is . reset () ; final BufferedReader bReader = new BufferedReader ( new StringReader ( MST[InlineConstantMutator]MSP[]
final String bomEnc = bom . getBOMCharsetName () ; final String xmlGuessEnc = pis . getBOMCharsetName () ; final String xmlEnc = getXmlProlog ( pis , xmlGuessEnc ) ; try { return calculateHttpEncoding ( httpContentType , bomEnc , MST[ReturnValsMutator]MSP[] xmlGuessEnc , xmlEnc , lenient ) ;
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_32 ) && ! xmlEnc . equals ( bomEnc ) ) { MST[rv.ROR2Mutator]MSP[] final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
static String getContentTypeEncoding ( final String httpContentType ) { String encoding = null ; if ( httpContentType != null ) { MST[rv.ROR5Mutator]MSP[] final int i = httpContentType . indexOf ( lr_3 ) ; if ( i > - 1 ) {
throw new IOException ( lr_6 + offset + lr_7 ) ; } final int bytesRead = offset ; if ( bytesRead > 0 ) { MST[rv.UOI2Mutator]MSP[] is . reset () ; final BufferedReader bReader = new BufferedReader ( new StringReader (
final String postMime = httpContentType . substring ( i + 1 ) ; final Matcher m = CHARSET_PATTERN . matcher ( postMime ) ; encoding = m . find () ? m . group ( 1 ) : null ; MST[rv.CRCR4Mutator]MSP[]
} return xmlEnc ; } if ( bomEnc . equals ( UTF_8 ) ) { MST[NegateConditionalsMutator]MSP[] if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( UTF_8 ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
final String bomEnc = bom . getBOMCharsetName () ; final String xmlGuessEnc = pis . getBOMCharsetName () ; final String xmlEnc = getXmlProlog ( pis , xmlGuessEnc ) ; try { return calculateHttpEncoding ( httpContentType , bomEnc , MST[ArgumentPropagationMutator]MSP[] xmlGuessEnc , xmlEnc , lenient ) ;
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[NonVoidMethodCallMutator]MSP[] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
} return xmlEnc ; } if ( bomEnc . equals ( UTF_8 ) ) { if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( UTF_8 ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR4Mutator]MSP[]
final String msg = MessageFormat . format ( HTTP_EX_3 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR3Mutator]MSP[] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( cTEnc == null ) {
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; MST[EmptyObjectReturnValsMutator]MSP[] } if ( bomEnc . equals ( UTF_32BE ) || bomEnc . equals ( UTF_32LE ) ) { if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( bomEnc ) ) {
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { offset += c ; MST[MathMutator]MSP[] max -= c ; c = is . read ( bytes , offset , max ) ;
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { MST[rv.UOI2Mutator]MSP[] offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ;
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( xmlEnc != null && ! xmlEnc . equals ( UTF_8 ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR1Mutator]MSP[]
if ( cTEnc . equals ( UTF_16 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_16 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR5Mutator]MSP[]
throw new IOException ( lr_6 + offset + lr_7 ) ; } final int bytesRead = offset ; MST[rv.UOI2Mutator]MSP[] if ( bytesRead > 0 ) { is . reset () ; final BufferedReader bReader = new BufferedReader ( new StringReader (
final String postMime = httpContentType . substring ( i + 1 ) ; MST[rv.AOR4Mutator]MSP[] final Matcher m = CHARSET_PATTERN . matcher ( postMime ) ; encoding = m . find () ? m . group ( 1 ) : null ;
encoding = encoding . substring ( 1 , encoding . length () - 1 ) ; MST[rv.CRCR5Mutator]MSP[] } } } return encoding ; } static boolean isAppXml ( final String mime ) { return mime != null && ( mime . equals ( lr_8 ) ||
if ( cTEnc . equals ( UTF_16 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_16 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR2Mutator]MSP[]
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[InlineConstantMutator]MSP[] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_16 ) && ! xmlEnc . equals ( bomEnc ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
public String getDefaultEncoding () { return defaultEncoding ; MST[EmptyObjectReturnValsMutator]MSP[] } public String getEncoding () { return encoding ; } @Override public int read ( final char [] buf , final int offset , final int len ) throws IOException {
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_32 ) && ! xmlEnc . equals ( bomEnc ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[InlineConstantMutator]MSP[]
xmlProlog = new String ( bytes , 0 , offset , guessedEnc ) ; firstGT = xmlProlog . indexOf ( '>' ) ; } if ( firstGT == - 1 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] if ( c == - 1 ) { throw new IOException ( lr_5 ) ; }
if ( httpContentType != null && httpContentType . startsWith ( lr_1 ) ) { MST[rv.ROR5Mutator]MSP[] httpContentType = httpContentType . substring ( lr_1 . length () ) ; httpContentType = lr_2 + httpContentType ; try { return calculateHttpEncoding ( httpContentType , ex . getBomEncoding () ,
} return xmlEnc ; } if ( bomEnc . equals ( UTF_8 ) ) { if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( UTF_8 ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR6Mutator]MSP[]
final String postMime = httpContentType . substring ( i + 1 ) ; MST[rv.CRCR3Mutator]MSP[] final Matcher m = CHARSET_PATTERN . matcher ( postMime ) ; encoding = m . find () ? m . group ( 1 ) : null ;
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } if ( bomEnc . equals ( UTF_32BE ) || bomEnc . equals ( UTF_32LE ) ) { MST[rv.ROR5Mutator]MSP[] if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( bomEnc ) ) {
throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; } static String getContentTypeMime ( final String httpContentType ) { String mime = null ; if ( httpContentType != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
throw new IOException ( lr_6 + offset + lr_7 ) ; } final int bytesRead = offset ; if ( bytesRead > 0 ) { is . reset () ; final BufferedReader bReader = new BufferedReader ( new StringReader ( MST[rv.AOD2Mutator]MSP[]
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_32 ) && ! xmlEnc . equals ( bomEnc ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR4Mutator]MSP[]
xmlProlog = new String ( bytes , 0 , offset , guessedEnc ) ; firstGT = xmlProlog . indexOf ( '>' ) ; } if ( firstGT == - 1 ) { MST[rv.ROR3Mutator]MSP[] if ( c == - 1 ) { throw new IOException ( lr_5 ) ; }
final String postMime = httpContentType . substring ( i + 1 ) ; final Matcher m = CHARSET_PATTERN . matcher ( postMime ) ; MST[NonVoidMethodCallMutator]MSP[] encoding = m . find () ? m . group ( 1 ) : null ;
if ( encoding == null ) { encoding = defaultEncoding == null ? UTF_8 : defaultEncoding ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] } return encoding ; } String calculateRawEncoding ( final String bomEnc , final String xmlGuessEnc , final String xmlEnc ) throws IOException { if ( bomEnc == null ) {
xmlProlog = new String ( bytes , 0 , offset , guessedEnc ) ; firstGT = xmlProlog . indexOf ( '>' ) ; } if ( firstGT == - 1 ) { MST[rv.CRCR5Mutator]MSP[] if ( c == - 1 ) { throw new IOException ( lr_5 ) ; }
if ( guessedEnc != null ) { final byte [] bytes = new byte [ BUFFER_SIZE ] ; MST[rv.CRCR1Mutator]MSP[] is . mark ( BUFFER_SIZE ) ; int offset = 0 ; int max = BUFFER_SIZE ; int c = is . read ( bytes , offset , max ) ;
final String cTEnc = getContentTypeEncoding ( httpContentType ) ; MST[ArgumentPropagationMutator]MSP[] final boolean appXml = isAppXml ( cTMime ) ; final boolean textXml = isTextXml ( cTMime ) ; if ( ! appXml && ! textXml ) {
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; MST[EmptyObjectReturnValsMutator]MSP[] }
mime . equals ( lr_9 ) || mime . equals ( lr_10 ) || mime . startsWith ( lr_11 ) && mime . endsWith ( lr_12 ) ) ; MST[rv.ROR2Mutator]MSP[] } static boolean isTextXml ( final String mime ) { return mime != null &&
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_32 ) && ! xmlEnc . equals ( bomEnc ) ) { MST[NegateConditionalsMutator]MSP[] final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
if ( cTEnc . equals ( UTF_32 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_32 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[InlineConstantMutator]MSP[]
mime . equals ( lr_9 ) || mime . equals ( lr_10 ) || mime . startsWith ( lr_11 ) && mime . endsWith ( lr_12 ) ) ; MST[rv.ROR5Mutator]MSP[] } static boolean isTextXml ( final String mime ) { return mime != null &&
encoding = encoding . substring ( 1 , encoding . length () - 1 ) ; MST[rv.CRCR4Mutator]MSP[] } } } return encoding ; } static boolean isAppXml ( final String mime ) { return mime != null && ( mime . equals ( lr_8 ) ||
if ( xmlGuessEnc == null || xmlEnc == null ) { return defaultEncoding == null ? UTF_8 : defaultEncoding ; MST[rv.ROR5Mutator]MSP[] } if ( xmlEnc . equals ( UTF_16 ) && ( xmlGuessEnc . equals ( UTF_16BE ) || xmlGuessEnc . equals ( UTF_16LE ) ) ) { return xmlGuessEnc ;
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( xmlEnc != null && ! xmlEnc . equals ( UTF_8 ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR3Mutator]MSP[]
if ( appXml ) { return calculateRawEncoding ( bomEnc , xmlGuessEnc , xmlEnc ) ; } return defaultEncoding == null ? US_ASCII : defaultEncoding ; MST[EmptyObjectReturnValsMutator]MSP[] } if ( cTEnc . equals ( UTF_16BE ) || cTEnc . equals ( UTF_16LE ) ) { if ( bomEnc != null ) {
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_16 ) && ! xmlEnc . equals ( bomEnc ) ) { MST[NonVoidMethodCallMutator]MSP[] final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { offset += c ; max -= c ; MST[rv.ABSMutator]MSP[] c = is . read ( bytes , offset , max ) ;
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_16 ) && ! xmlEnc . equals ( bomEnc ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR6Mutator]MSP[]
if ( guessedEnc != null ) { final byte [] bytes = new byte [ BUFFER_SIZE ] ; is . mark ( BUFFER_SIZE ) ; MST[InlineConstantMutator]MSP[] int offset = 0 ; int max = BUFFER_SIZE ; int c = is . read ( bytes , offset , max ) ;
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } if ( bomEnc . equals ( UTF_32BE ) || bomEnc . equals ( UTF_32LE ) ) { MST[rv.ROR2Mutator]MSP[] if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( bomEnc ) ) {
if ( xmlGuessEnc == null || xmlEnc == null ) { MST[NegateConditionalsMutator]MSP[] return defaultEncoding == null ? UTF_8 : defaultEncoding ; } if ( xmlEnc . equals ( UTF_16 ) && ( xmlGuessEnc . equals ( UTF_16BE ) || xmlGuessEnc . equals ( UTF_16LE ) ) ) { return xmlGuessEnc ;
final String postMime = httpContentType . substring ( i + 1 ) ; final Matcher m = CHARSET_PATTERN . matcher ( postMime ) ; encoding = m . find () ? m . group ( 1 ) : null ; MST[rv.ROR5Mutator]MSP[]
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_16 ) && ! xmlEnc . equals ( bomEnc ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[InlineConstantMutator]MSP[]
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR2Mutator]MSP[] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR3Mutator]MSP[] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR6Mutator]MSP[] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
if ( lenient ) { MST[rv.UOI2Mutator]MSP[] return doLenientDetection ( null , ex ) ; } throw ex ; } } private String doHttpStream ( final BOMInputStream bom , final BOMInputStream pis , final String httpContentType , final boolean lenient ) throws IOException {
final String cTEnc = getContentTypeEncoding ( httpContentType ) ; final boolean appXml = isAppXml ( cTMime ) ; final boolean textXml = isTextXml ( cTMime ) ; if ( ! appXml && ! textXml ) { MST[rv.ABSMutator]MSP[]
final String msg = MessageFormat . format ( HTTP_EX_3 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[ArgumentPropagationMutator]MSP[] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( cTEnc == null ) {
if ( httpContentType != null && httpContentType . startsWith ( lr_1 ) ) { httpContentType = httpContentType . substring ( lr_1 . length () ) ; MST[NonVoidMethodCallMutator]MSP[] httpContentType = lr_2 + httpContentType ; try { return calculateHttpEncoding ( httpContentType , ex . getBomEncoding () ,
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ; MST[rv.ABSMutator]MSP[]
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_16 ) && ! xmlEnc . equals ( bomEnc ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR3Mutator]MSP[]
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ; MST[rv.UOI4Mutator]MSP[]
( mime . equals ( lr_2 ) || mime . equals ( lr_13 ) || mime . startsWith ( lr_14 ) && mime . endsWith ( lr_12 ) ) ; MST[rv.ROR3Mutator]MSP[] }
} final Matcher m = ENCODING_PATTERN . matcher ( prolog ) ; if ( m . find () ) { MST[NonVoidMethodCallMutator]MSP[] encoding = m . group ( 1 ) . toUpperCase ( Locale . ROOT ) ;
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } if ( bomEnc . equals ( UTF_32BE ) || bomEnc . equals ( UTF_32LE ) ) { if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( bomEnc ) ) { MST[NegateConditionalsMutator]MSP[]
ex . getXmlGuessEncoding () , ex . getXmlEncoding () , true ) ; MST[InlineConstantMutator]MSP[] } catch ( final XmlStreamReaderException ex2 ) { ex = ex2 ; } } String encoding = ex . getXmlEncoding () ; if ( encoding == null ) { encoding = ex . getContentTypeEncoding () ; }
( mime . equals ( lr_2 ) || mime . equals ( lr_13 ) || mime . startsWith ( lr_14 ) && mime . endsWith ( lr_12 ) ) ; MST[rv.CRCR5Mutator]MSP[] }
final int i = httpContentType . indexOf ( lr_3 ) ; if ( i >= 0 ) { mime = httpContentType . substring ( 0 , i ) ; } else { mime = httpContentType ; } mime = mime . trim () ; MST[NonVoidMethodCallMutator]MSP[] } return mime ; }
if ( lenient ) { MST[rv.ROR3Mutator]MSP[] return doLenientDetection ( null , ex ) ; } throw ex ; } } private String doHttpStream ( final BOMInputStream bom , final BOMInputStream pis , final String httpContentType , final boolean lenient ) throws IOException {
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_16 ) && ! xmlEnc . equals ( bomEnc ) ) { MST[rv.ROR4Mutator]MSP[] final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { MST[rv.UOI3Mutator]MSP[] offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ;
if ( xmlGuessEnc == null || xmlEnc == null ) { return defaultEncoding == null ? UTF_8 : defaultEncoding ; } if ( xmlEnc . equals ( UTF_16 ) && ( xmlGuessEnc . equals ( UTF_16BE ) || xmlGuessEnc . equals ( UTF_16LE ) ) ) { return xmlGuessEnc ; MST[ReturnValsMutator]MSP[]
} return xmlEnc ; } if ( bomEnc . equals ( UTF_8 ) ) { MST[rv.ROR5Mutator]MSP[] if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( UTF_8 ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { MST[rv.ROR5Mutator]MSP[] offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ;
if ( guessedEnc != null ) { final byte [] bytes = new byte [ BUFFER_SIZE ] ; is . mark ( BUFFER_SIZE ) ; int offset = 0 ; int max = BUFFER_SIZE ; int c = is . read ( bytes , offset , max ) ; MST[NonVoidMethodCallMutator]MSP[]
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { MST[InlineConstantMutator]MSP[] offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ;
final String msg = MessageFormat . format ( HTTP_EX_3 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR4Mutator]MSP[] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( cTEnc == null ) {
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_32 ) && ! xmlEnc . equals ( bomEnc ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR1Mutator]MSP[]
mime . equals ( lr_9 ) || mime . equals ( lr_10 ) || mime . startsWith ( lr_11 ) && mime . endsWith ( lr_12 ) ) ; } static boolean isTextXml ( final String mime ) { return mime != null && MST[ReturnValsMutator]MSP[]
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } if ( bomEnc . equals ( UTF_16BE ) || bomEnc . equals ( UTF_16LE ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( bomEnc ) ) {
if ( cTEnc . equals ( UTF_32 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_32 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR2Mutator]MSP[]
final String postMime = httpContentType . substring ( i + 1 ) ; final Matcher m = CHARSET_PATTERN . matcher ( postMime ) ; encoding = m . find () ? m . group ( 1 ) : null ; MST[NegateConditionalsMutator]MSP[]
throw new IOException ( lr_6 + offset + lr_7 ) ; } final int bytesRead = offset ; if ( bytesRead > 0 ) { is . reset () ; final BufferedReader bReader = new BufferedReader ( new StringReader ( MST[rv.CRCR5Mutator]MSP[]
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR2Mutator]MSP[] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
if ( cTEnc . equals ( UTF_32 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_32 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR6Mutator]MSP[]
final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR2Mutator]MSP[] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
final String msg = MessageFormat . format ( HTTP_EX_3 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[InlineConstantMutator]MSP[] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( cTEnc == null ) {
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR6Mutator]MSP[] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
if ( xmlGuessEnc == null || xmlEnc == null ) { return defaultEncoding == null ? UTF_8 : defaultEncoding ; } if ( xmlEnc . equals ( UTF_16 ) && ( xmlGuessEnc . equals ( UTF_16BE ) || xmlGuessEnc . equals ( UTF_16LE ) ) ) { MST[rv.ROR5Mutator]MSP[] return xmlGuessEnc ;
} catch ( final XmlStreamReaderException ex ) { if ( lenient ) { MST[rv.ROR1Mutator]MSP[] return doLenientDetection ( httpContentType , ex ) ; } throw ex ; } } private String doLenientDetection ( String httpContentType , XmlStreamReaderException ex ) throws IOException {
mime . equals ( lr_9 ) || mime . equals ( lr_10 ) || mime . startsWith ( lr_11 ) && mime . endsWith ( lr_12 ) ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] } static boolean isTextXml ( final String mime ) { return mime != null &&
if ( guessedEnc != null ) { final byte [] bytes = new byte [ BUFFER_SIZE ] ; is . mark ( BUFFER_SIZE ) ; int offset = 0 ; int max = BUFFER_SIZE ; int c = is . read ( bytes , offset , max ) ; MST[rv.UOI2Mutator]MSP[]
throw new IOException ( lr_6 + offset + lr_7 ) ; } final int bytesRead = offset ; if ( bytesRead > 0 ) { is . reset () ; final BufferedReader bReader = new BufferedReader ( new StringReader ( MST[rv.AOR4Mutator]MSP[]
} return xmlEnc ; } if ( bomEnc . equals ( UTF_8 ) ) { if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( UTF_8 ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR3Mutator]MSP[]
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_32 ) && ! xmlEnc . equals ( bomEnc ) ) { MST[rv.ROR2Mutator]MSP[] final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR6Mutator]MSP[] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
final String msg = MessageFormat . format ( HTTP_EX_3 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR2Mutator]MSP[] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( cTEnc == null ) {
final String bomEnc = bom . getBOMCharsetName () ; final String xmlGuessEnc = pis . getBOMCharsetName () ; MST[NonVoidMethodCallMutator]MSP[] final String xmlEnc = getXmlProlog ( pis , xmlGuessEnc ) ; try { return calculateHttpEncoding ( httpContentType , bomEnc , xmlGuessEnc , xmlEnc , lenient ) ;
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { MST[NegateConditionalsMutator]MSP[] offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ;
final String bomEnc = bom . getBOMCharsetName () ; final String xmlGuessEnc = pis . getBOMCharsetName () ; final String xmlEnc = getXmlProlog ( pis , xmlGuessEnc ) ; try { return calculateHttpEncoding ( httpContentType , bomEnc , MST[rv.UOI1Mutator]MSP[] xmlGuessEnc , xmlEnc , lenient ) ;
final String postMime = httpContentType . substring ( i + 1 ) ; MST[rv.ABSMutator]MSP[] final Matcher m = CHARSET_PATTERN . matcher ( postMime ) ; encoding = m . find () ? m . group ( 1 ) : null ;
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } if ( bomEnc . equals ( UTF_32BE ) || bomEnc . equals ( UTF_32LE ) ) { if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( bomEnc ) ) { MST[rv.ROR5Mutator]MSP[]
xmlProlog . substring ( 0 , firstGT + 1 ) ) ) ; MST[ConstructorCallMutator]MSP[] final StringBuffer prolog = new StringBuffer () ; String line = bReader . readLine () ; while ( line != null ) { prolog . append ( line ) ; line = bReader . readLine () ;
if ( cTEnc . equals ( UTF_16 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_16 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR5Mutator]MSP[]
if ( cTEnc . equals ( UTF_16 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_16 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR2Mutator]MSP[]
if ( cTEnc . equals ( UTF_32 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_32 ) ) { MST[rv.ROR4Mutator]MSP[] return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ;
final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[ArgumentPropagationMutator]MSP[] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
if ( xmlGuessEnc == null || xmlEnc == null ) { return defaultEncoding == null ? UTF_8 : defaultEncoding ; } if ( xmlEnc . equals ( UTF_16 ) && ( xmlGuessEnc . equals ( UTF_16BE ) || xmlGuessEnc . equals ( UTF_16LE ) ) ) { MST[NegateConditionalsMutator]MSP[] return xmlGuessEnc ;
( mime . equals ( lr_2 ) || mime . equals ( lr_13 ) || MST[rv.ROR1Mutator]MSP[] mime . startsWith ( lr_14 ) && mime . endsWith ( lr_12 ) ) ; }
final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR4Mutator]MSP[] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { MST[rv.CRCR5Mutator]MSP[] offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ;
final String bomEnc = bom . getBOMCharsetName () ; final String xmlGuessEnc = pis . getBOMCharsetName () ; final String xmlEnc = getXmlProlog ( pis , xmlGuessEnc ) ; try { return calculateRawEncoding ( bomEnc , xmlGuessEnc , xmlEnc ) ; MST[ArgumentPropagationMutator]MSP[] } catch ( final XmlStreamReaderException ex ) {
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_16 ) && ! xmlEnc . equals ( bomEnc ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
if ( xmlGuessEnc == null || xmlEnc == null ) { return defaultEncoding == null ? UTF_8 : defaultEncoding ; } if ( xmlEnc . equals ( UTF_16 ) && ( xmlGuessEnc . equals ( UTF_16BE ) || xmlGuessEnc . equals ( UTF_16LE ) ) ) { return xmlGuessEnc ; MST[EmptyObjectReturnValsMutator]MSP[]
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( xmlEnc != null && ! xmlEnc . equals ( UTF_8 ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[NonVoidMethodCallMutator]MSP[]
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR1Mutator]MSP[] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
} return xmlEnc ; } if ( bomEnc . equals ( UTF_8 ) ) { if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( UTF_8 ) ) { MST[rv.ROR2Mutator]MSP[] final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
if ( cTEnc . equals ( UTF_16 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_16 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR4Mutator]MSP[]
mime . equals ( lr_9 ) || mime . equals ( lr_10 ) || mime . startsWith ( lr_11 ) && mime . endsWith ( lr_12 ) ) ; MST[rv.ROR2Mutator]MSP[] } static boolean isTextXml ( final String mime ) { return mime != null &&
xmlProlog = new String ( bytes , 0 , offset , guessedEnc ) ; firstGT = xmlProlog . indexOf ( '>' ) ; MST[rv.CRCR1Mutator]MSP[] } if ( firstGT == - 1 ) { if ( c == - 1 ) { throw new IOException ( lr_5 ) ; }
throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( cTEnc . equals ( UTF_32BE ) || cTEnc . equals ( UTF_32LE ) ) { MST[rv.ROR4Mutator]MSP[] if ( bomEnc != null ) {
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_16 ) && ! xmlEnc . equals ( bomEnc ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR6Mutator]MSP[]
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } if ( bomEnc . equals ( UTF_32BE ) || bomEnc . equals ( UTF_32LE ) ) { MST[rv.ROR2Mutator]MSP[] if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( bomEnc ) ) {
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_16 ) && ! xmlEnc . equals ( bomEnc ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } final String msg = MessageFormat . format ( RAW_EX_2 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[InlineConstantMutator]MSP[] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
if ( cTEnc . equals ( UTF_16 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_16 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[InlineConstantMutator]MSP[]
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR5Mutator]MSP[] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
xmlProlog . substring ( 0 , firstGT + 1 ) ) ) ; final StringBuffer prolog = new StringBuffer () ; MST[ConstructorCallMutator]MSP[] String line = bReader . readLine () ; while ( line != null ) { prolog . append ( line ) ; line = bReader . readLine () ;
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR2Mutator]MSP[] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { MST[rv.ROR5Mutator]MSP[] offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ;
} final Matcher m = ENCODING_PATTERN . matcher ( prolog ) ; if ( m . find () ) { MST[NegateConditionalsMutator]MSP[] encoding = m . group ( 1 ) . toUpperCase ( Locale . ROOT ) ;
mime . equals ( lr_9 ) || mime . equals ( lr_10 ) || mime . startsWith ( lr_11 ) && mime . endsWith ( lr_12 ) ) ; MST[NegateConditionalsMutator]MSP[] } static boolean isTextXml ( final String mime ) { return mime != null &&
} return xmlEnc ; } if ( bomEnc . equals ( UTF_8 ) ) { if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( UTF_8 ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR1Mutator]MSP[]
final String cTEnc = getContentTypeEncoding ( httpContentType ) ; final boolean appXml = isAppXml ( cTMime ) ; final boolean textXml = isTextXml ( cTMime ) ; if ( ! appXml && ! textXml ) { MST[rv.ROR4Mutator]MSP[]
throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( cTEnc . equals ( UTF_32BE ) || cTEnc . equals ( UTF_32LE ) ) { MST[NegateConditionalsMutator]MSP[] if ( bomEnc != null ) {
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_16 ) && ! xmlEnc . equals ( bomEnc ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR3Mutator]MSP[]
final int i = httpContentType . indexOf ( lr_3 ) ; if ( i >= 0 ) { mime = httpContentType . substring ( 0 , i ) ; MST[rv.UOI2Mutator]MSP[] } else { mime = httpContentType ; } mime = mime . trim () ; } return mime ; }
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ; MST[rv.UOI1Mutator]MSP[]
if ( xmlGuessEnc == null || xmlEnc == null ) { return defaultEncoding == null ? UTF_8 : defaultEncoding ; } if ( xmlEnc . equals ( UTF_16 ) && MST[NonVoidMethodCallMutator]MSP[] ( xmlGuessEnc . equals ( UTF_16BE ) || xmlGuessEnc . equals ( UTF_16LE ) ) ) { return xmlGuessEnc ;
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_32 ) && ! xmlEnc . equals ( bomEnc ) ) { MST[rv.ROR1Mutator]MSP[] final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
if ( guessedEnc != null ) { final byte [] bytes = new byte [ BUFFER_SIZE ] ; is . mark ( BUFFER_SIZE ) ; MST[VoidMethodCallMutator]MSP[] int offset = 0 ; int max = BUFFER_SIZE ; int c = is . read ( bytes , offset , max ) ;
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[ConstructorCallMutator]MSP[] } return bomEnc ; } final String msg = MessageFormat . format ( RAW_EX_2 , bomEnc , xmlGuessEnc , xmlEnc ) ; throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ;
final String postMime = httpContentType . substring ( i + 1 ) ; MST[NonVoidMethodCallMutator]MSP[] final Matcher m = CHARSET_PATTERN . matcher ( postMime ) ; encoding = m . find () ? m . group ( 1 ) : null ;
final String msg = MessageFormat . format ( HTTP_EX_3 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR3Mutator]MSP[] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( cTEnc == null ) {
final String bomEnc = bom . getBOMCharsetName () ; final String xmlGuessEnc = pis . getBOMCharsetName () ; final String xmlEnc = getXmlProlog ( pis , xmlGuessEnc ) ; MST[ArgumentPropagationMutator]MSP[] try { return calculateRawEncoding ( bomEnc , xmlGuessEnc , xmlEnc ) ; } catch ( final XmlStreamReaderException ex ) {
if ( cTEnc . equals ( UTF_32 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_32 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR5Mutator]MSP[]
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_16 ) && ! xmlEnc . equals ( bomEnc ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[ArgumentPropagationMutator]MSP[]
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { MST[rv.ROR4Mutator]MSP[] offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ;
} final Matcher m = ENCODING_PATTERN . matcher ( prolog ) ; if ( m . find () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] encoding = m . group ( 1 ) . toUpperCase ( Locale . ROOT ) ;
int firstGT = - 1 ; MST[rv.CRCR5Mutator]MSP[] String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ;
encoding = encoding . substring ( 1 , encoding . length () - 1 ) ; } } } return encoding ; MST[ReturnValsMutator]MSP[] } static boolean isAppXml ( final String mime ) { return mime != null && ( mime . equals ( lr_8 ) ||
} return xmlEnc ; } if ( bomEnc . equals ( UTF_8 ) ) { if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( UTF_8 ) ) { MST[rv.ROR4Mutator]MSP[] final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
if ( cTEnc . equals ( UTF_32 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_32 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR2Mutator]MSP[]
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { offset += c ; max -= c ; MST[rv.UOI3Mutator]MSP[] c = is . read ( bytes , offset , max ) ;
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { offset += c ; MST[rv.ABSMutator]MSP[] max -= c ; c = is . read ( bytes , offset , max ) ;
final String postMime = httpContentType . substring ( i + 1 ) ; MST[rv.UOI1Mutator]MSP[] final Matcher m = CHARSET_PATTERN . matcher ( postMime ) ; encoding = m . find () ? m . group ( 1 ) : null ;
final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR6Mutator]MSP[] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
String calculateHttpEncoding ( final String httpContentType , final String bomEnc , final String xmlGuessEnc , final String xmlEnc , final boolean lenient ) throws IOException { if ( lenient && xmlEnc != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return xmlEnc ; } final String cTMime = getContentTypeMime ( httpContentType ) ;
if ( guessedEnc != null ) { final byte [] bytes = new byte [ BUFFER_SIZE ] ; is . mark ( BUFFER_SIZE ) ; int offset = 0 ; MST[rv.CRCR1Mutator]MSP[] int max = BUFFER_SIZE ; int c = is . read ( bytes , offset , max ) ;
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR5Mutator]MSP[] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( cTEnc . equals ( UTF_32BE ) || cTEnc . equals ( UTF_32LE ) ) { MST[rv.ROR2Mutator]MSP[] if ( bomEnc != null ) {
throw new IOException ( lr_6 + offset + lr_7 ) ; } final int bytesRead = offset ; if ( bytesRead > 0 ) { is . reset () ; final BufferedReader bReader = new BufferedReader ( new StringReader ( MST[rv.CRCR4Mutator]MSP[]
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR2Mutator]MSP[] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
throw new IOException ( lr_6 + offset + lr_7 ) ; } final int bytesRead = offset ; if ( bytesRead > 0 ) { is . reset () ; final BufferedReader bReader = new BufferedReader ( new StringReader ( MST[rv.UOI4Mutator]MSP[]
public String getDefaultEncoding () { return defaultEncoding ; } public String getEncoding () { return encoding ; MST[ReturnValsMutator]MSP[] } @Override public int read ( final char [] buf , final int offset , final int len ) throws IOException {
throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( cTEnc . equals ( UTF_32BE ) || cTEnc . equals ( UTF_32LE ) ) { MST[rv.ROR5Mutator]MSP[] if ( bomEnc != null ) {
if ( guessedEnc != null ) { final byte [] bytes = new byte [ BUFFER_SIZE ] ; MST[InlineConstantMutator]MSP[] is . mark ( BUFFER_SIZE ) ; int offset = 0 ; int max = BUFFER_SIZE ; int c = is . read ( bytes , offset , max ) ;
return reader . read ( buf , offset , len ) ; MST[rv.UOI4Mutator]MSP[] } @Override public void close () throws IOException { reader . close () ; } private String doRawStream ( final BOMInputStream bom , final BOMInputStream pis , final boolean lenient ) throws IOException {
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } if ( bomEnc . equals ( UTF_32BE ) || bomEnc . equals ( UTF_32LE ) ) { MST[rv.ROR4Mutator]MSP[] if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( bomEnc ) ) {
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } final String msg = MessageFormat . format ( RAW_EX_2 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR6Mutator]MSP[] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
if ( appXml ) { return calculateRawEncoding ( bomEnc , xmlGuessEnc , xmlEnc ) ; MST[ReturnValsMutator]MSP[] } return defaultEncoding == null ? US_ASCII : defaultEncoding ; } if ( cTEnc . equals ( UTF_16BE ) || cTEnc . equals ( UTF_16LE ) ) { if ( bomEnc != null ) {
String calculateHttpEncoding ( final String httpContentType , final String bomEnc , final String xmlGuessEnc , final String xmlEnc , final boolean lenient ) throws IOException { if ( lenient && xmlEnc != null ) { MST[NegateConditionalsMutator]MSP[] return xmlEnc ; } final String cTMime = getContentTypeMime ( httpContentType ) ;
final String bomEnc = bom . getBOMCharsetName () ; final String xmlGuessEnc = pis . getBOMCharsetName () ; final String xmlEnc = getXmlProlog ( pis , xmlGuessEnc ) ; try { return calculateHttpEncoding ( httpContentType , bomEnc , MST[rv.UOI3Mutator]MSP[] xmlGuessEnc , xmlEnc , lenient ) ;
if ( cTEnc . equals ( UTF_32 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_32 ) ) { return bomEnc ; MST[ReturnValsMutator]MSP[] } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ;
if ( cTEnc . equals ( UTF_16 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] if ( bomEnc != null && bomEnc . startsWith ( UTF_16 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ;
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[InlineConstantMutator]MSP[] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
if ( cTEnc . equals ( UTF_16 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_16 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR5Mutator]MSP[]
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { offset += c ; MST[rv.UOI2Mutator]MSP[] max -= c ; c = is . read ( bytes , offset , max ) ;
if ( cTEnc . equals ( UTF_32 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_32 ) ) { MST[rv.ROR5Mutator]MSP[] return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ;
if ( cTEnc . equals ( UTF_16 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_16 ) ) { MST[NegateConditionalsMutator]MSP[] return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ;
if ( cTEnc . equals ( UTF_32 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_32 ) ) { MST[rv.ROR2Mutator]MSP[] return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ;
if ( cTEnc . equals ( UTF_16 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_16 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR2Mutator]MSP[]
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_16 ) && ! xmlEnc . equals ( bomEnc ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR2Mutator]MSP[]
xmlProlog = new String ( bytes , 0 , offset , guessedEnc ) ; firstGT = xmlProlog . indexOf ( '>' ) ; MST[ArgumentPropagationMutator]MSP[] } if ( firstGT == - 1 ) { if ( c == - 1 ) { throw new IOException ( lr_5 ) ; }
( mime . equals ( lr_2 ) || MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] mime . equals ( lr_13 ) || mime . startsWith ( lr_14 ) && mime . endsWith ( lr_12 ) ) ; }
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } final String msg = MessageFormat . format ( RAW_EX_2 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR4Mutator]MSP[] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
final String cTEnc = getContentTypeEncoding ( httpContentType ) ; final boolean appXml = isAppXml ( cTMime ) ; final boolean textXml = isTextXml ( cTMime ) ; if ( ! appXml && ! textXml ) { MST[rv.UOI3Mutator]MSP[]
ex . getXmlGuessEncoding () , ex . getXmlEncoding () , true ) ; } catch ( final XmlStreamReaderException ex2 ) { ex = ex2 ; } } String encoding = ex . getXmlEncoding () ; MST[NonVoidMethodCallMutator]MSP[] if ( encoding == null ) { encoding = ex . getContentTypeEncoding () ; }
final String postMime = httpContentType . substring ( i + 1 ) ; final Matcher m = CHARSET_PATTERN . matcher ( postMime ) ; encoding = m . find () ? m . group ( 1 ) : null ; MST[InlineConstantMutator]MSP[]
( mime . equals ( lr_2 ) || mime . equals ( lr_13 ) || mime . startsWith ( lr_14 ) && mime . endsWith ( lr_12 ) ) ; MST[InlineConstantMutator]MSP[] }
final String bomEnc = bom . getBOMCharsetName () ; final String xmlGuessEnc = pis . getBOMCharsetName () ; final String xmlEnc = getXmlProlog ( pis , xmlGuessEnc ) ; try { return calculateRawEncoding ( bomEnc , xmlGuessEnc , xmlEnc ) ; MST[NonVoidMethodCallMutator]MSP[] } catch ( final XmlStreamReaderException ex ) {
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } if ( bomEnc . equals ( UTF_32BE ) || bomEnc . equals ( UTF_32LE ) ) { MST[rv.ROR1Mutator]MSP[] if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( bomEnc ) ) {
final String msg = MessageFormat . format ( HTTP_EX_3 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR6Mutator]MSP[] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( cTEnc == null ) {
final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR4Mutator]MSP[] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[InlineConstantMutator]MSP[] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
xmlProlog = new String ( bytes , 0 , offset , guessedEnc ) ; firstGT = xmlProlog . indexOf ( '>' ) ; MST[rv.CRCR5Mutator]MSP[] } if ( firstGT == - 1 ) { if ( c == - 1 ) { throw new IOException ( lr_5 ) ; }
mime . equals ( lr_9 ) || MST[rv.ROR1Mutator]MSP[] mime . equals ( lr_10 ) || mime . startsWith ( lr_11 ) && mime . endsWith ( lr_12 ) ) ; } static boolean isTextXml ( final String mime ) { return mime != null &&
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { MST[NegateConditionalsMutator]MSP[] offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ;
if ( cTEnc . equals ( UTF_32 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_32 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[InlineConstantMutator]MSP[]
} catch ( final XmlStreamReaderException ex ) { if ( lenient ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return doLenientDetection ( httpContentType , ex ) ; } throw ex ; } } private String doLenientDetection ( String httpContentType , XmlStreamReaderException ex ) throws IOException {
} final Matcher m = ENCODING_PATTERN . matcher ( prolog ) ; if ( m . find () ) { encoding = m . group ( 1 ) . toUpperCase ( Locale . ROOT ) ; MST[rv.CRCR4Mutator]MSP[]
if ( appXml ) { return calculateRawEncoding ( bomEnc , xmlGuessEnc , xmlEnc ) ; } return defaultEncoding == null ? US_ASCII : defaultEncoding ; } if ( cTEnc . equals ( UTF_16BE ) || cTEnc . equals ( UTF_16LE ) ) { MST[NegateConditionalsMutator]MSP[] if ( bomEnc != null ) {
xmlProlog = new String ( bytes , 0 , offset , guessedEnc ) ; firstGT = xmlProlog . indexOf ( '>' ) ; MST[rv.CRCR2Mutator]MSP[] } if ( firstGT == - 1 ) { if ( c == - 1 ) { throw new IOException ( lr_5 ) ; }
mime . equals ( lr_9 ) || mime . equals ( lr_10 ) || MST[rv.ROR3Mutator]MSP[] mime . startsWith ( lr_11 ) && mime . endsWith ( lr_12 ) ) ; } static boolean isTextXml ( final String mime ) { return mime != null &&
if ( httpContentType != null && httpContentType . startsWith ( lr_1 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] httpContentType = httpContentType . substring ( lr_1 . length () ) ; httpContentType = lr_2 + httpContentType ; try { return calculateHttpEncoding ( httpContentType , ex . getBomEncoding () ,
final int i = httpContentType . indexOf ( lr_3 ) ; if ( i >= 0 ) { MST[rv.ROR1Mutator]MSP[] mime = httpContentType . substring ( 0 , i ) ; } else { mime = httpContentType ; } mime = mime . trim () ; } return mime ; }
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( xmlEnc != null && ! xmlEnc . equals ( UTF_8 ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[InlineConstantMutator]MSP[]
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_32 ) && ! xmlEnc . equals ( bomEnc ) ) { MST[rv.ROR4Mutator]MSP[] final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
if ( cTEnc . equals ( UTF_32 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_32 ) ) { MST[NegateConditionalsMutator]MSP[] return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ;
mime . equals ( lr_9 ) || mime . equals ( lr_10 ) || mime . startsWith ( lr_11 ) && mime . endsWith ( lr_12 ) ) ; MST[rv.CRCR5Mutator]MSP[] } static boolean isTextXml ( final String mime ) { return mime != null &&
final String postMime = httpContentType . substring ( i + 1 ) ; MST[rv.AOR2Mutator]MSP[] final Matcher m = CHARSET_PATTERN . matcher ( postMime ) ; encoding = m . find () ? m . group ( 1 ) : null ;
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } final String msg = MessageFormat . format ( RAW_EX_2 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR1Mutator]MSP[] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
( mime . equals ( lr_2 ) || mime . equals ( lr_13 ) || MST[NonVoidMethodCallMutator]MSP[] mime . startsWith ( lr_14 ) && mime . endsWith ( lr_12 ) ) ; }
} catch ( final XmlStreamReaderException ex ) { if ( lenient ) { MST[rv.ROR3Mutator]MSP[] return doLenientDetection ( httpContentType , ex ) ; } throw ex ; } } private String doLenientDetection ( String httpContentType , XmlStreamReaderException ex ) throws IOException {
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_16 ) && ! xmlEnc . equals ( bomEnc ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR6Mutator]MSP[]
if ( httpContentType != null && httpContentType . startsWith ( lr_1 ) ) { MST[rv.ROR2Mutator]MSP[] httpContentType = httpContentType . substring ( lr_1 . length () ) ; httpContentType = lr_2 + httpContentType ; try { return calculateHttpEncoding ( httpContentType , ex . getBomEncoding () ,
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_16 ) && ! xmlEnc . equals ( bomEnc ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR5Mutator]MSP[]
if ( encoding == null ) { encoding = defaultEncoding == null ? UTF_8 : defaultEncoding ; } return encoding ; MST[ReturnValsMutator]MSP[] } String calculateRawEncoding ( final String bomEnc , final String xmlGuessEnc , final String xmlEnc ) throws IOException { if ( bomEnc == null ) {
mime . equals ( lr_9 ) || mime . equals ( lr_10 ) || mime . startsWith ( lr_11 ) && mime . endsWith ( lr_12 ) ) ; MST[NegateConditionalsMutator]MSP[] } static boolean isTextXml ( final String mime ) { return mime != null &&
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } final String msg = MessageFormat . format ( RAW_EX_2 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[InlineConstantMutator]MSP[] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
encoding = encoding != null ? encoding . toUpperCase ( Locale . ROOT ) : null ; MST[experimental.NakedReceiverMutator]MSP[] } } return encoding ; } private static String getXmlProlog ( final InputStream is , final String guessedEnc ) throws IOException { String encoding = null ;
if ( httpContentType != null && httpContentType . startsWith ( lr_1 ) ) { MST[NegateConditionalsMutator]MSP[] httpContentType = httpContentType . substring ( lr_1 . length () ) ; httpContentType = lr_2 + httpContentType ; try { return calculateHttpEncoding ( httpContentType , ex . getBomEncoding () ,
encoding = encoding != null ? encoding . toUpperCase ( Locale . ROOT ) : null ; } } return encoding ; MST[ReturnValsMutator]MSP[] } private static String getXmlProlog ( final InputStream is , final String guessedEnc ) throws IOException { String encoding = null ;
} catch ( final XmlStreamReaderException ex ) { if ( lenient ) { MST[rv.UOI2Mutator]MSP[] return doLenientDetection ( httpContentType , ex ) ; } throw ex ; } } private String doLenientDetection ( String httpContentType , XmlStreamReaderException ex ) throws IOException {
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR5Mutator]MSP[] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
if ( cTEnc . equals ( UTF_32 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_32 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR4Mutator]MSP[]
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { MST[rv.ROR2Mutator]MSP[] offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ;
final String postMime = httpContentType . substring ( i + 1 ) ; final Matcher m = CHARSET_PATTERN . matcher ( postMime ) ; encoding = m . find () ? m . group ( 1 ) : null ; MST[rv.ROR1Mutator]MSP[]
if ( xmlGuessEnc == null || xmlEnc == null ) { return defaultEncoding == null ? UTF_8 : defaultEncoding ; } if ( xmlEnc . equals ( UTF_16 ) && MST[NegateConditionalsMutator]MSP[] ( xmlGuessEnc . equals ( UTF_16BE ) || xmlGuessEnc . equals ( UTF_16LE ) ) ) { return xmlGuessEnc ;
if ( appXml ) { return calculateRawEncoding ( bomEnc , xmlGuessEnc , xmlEnc ) ; } return defaultEncoding == null ? US_ASCII : defaultEncoding ; } if ( cTEnc . equals ( UTF_16BE ) || cTEnc . equals ( UTF_16LE ) ) { if ( bomEnc != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { offset += c ; max -= c ; MST[rv.UOI4Mutator]MSP[] c = is . read ( bytes , offset , max ) ;
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR2Mutator]MSP[] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_16 ) && ! xmlEnc . equals ( bomEnc ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR3Mutator]MSP[]
throw new IOException ( lr_6 + offset + lr_7 ) ; } final int bytesRead = offset ; if ( bytesRead > 0 ) { is . reset () ; final BufferedReader bReader = new BufferedReader ( new StringReader ( MST[rv.UOI1Mutator]MSP[]
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[ConstructorCallMutator]MSP[] } if ( xmlEnc != null && ! xmlEnc . equals ( UTF_8 ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[NonVoidMethodCallMutator]MSP[] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
if ( appXml ) { MST[rv.ROR5Mutator]MSP[] return calculateRawEncoding ( bomEnc , xmlGuessEnc , xmlEnc ) ; } return defaultEncoding == null ? US_ASCII : defaultEncoding ; } if ( cTEnc . equals ( UTF_16BE ) || cTEnc . equals ( UTF_16LE ) ) { if ( bomEnc != null ) {
xmlProlog = new String ( bytes , 0 , offset , guessedEnc ) ; firstGT = xmlProlog . indexOf ( '>' ) ; } if ( firstGT == - 1 ) { MST[rv.ABSMutator]MSP[] if ( c == - 1 ) { throw new IOException ( lr_5 ) ; }
final String msg = MessageFormat . format ( HTTP_EX_3 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR3Mutator]MSP[] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( cTEnc == null ) {
if ( guessedEnc != null ) { final byte [] bytes = new byte [ BUFFER_SIZE ] ; is . mark ( BUFFER_SIZE ) ; MST[rv.CRCR1Mutator]MSP[] int offset = 0 ; int max = BUFFER_SIZE ; int c = is . read ( bytes , offset , max ) ;
if ( cTEnc . equals ( UTF_32 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_32 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR5Mutator]MSP[]
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_32 ) && ! xmlEnc . equals ( bomEnc ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR1Mutator]MSP[]
mime . equals ( lr_9 ) || MST[rv.ROR4Mutator]MSP[] mime . equals ( lr_10 ) || mime . startsWith ( lr_11 ) && mime . endsWith ( lr_12 ) ) ; } static boolean isTextXml ( final String mime ) { return mime != null &&
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { MST[rv.UOI4Mutator]MSP[] offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ;
encoding = encoding . substring ( 1 , encoding . length () - 1 ) ; } } } return encoding ; } static boolean isAppXml ( final String mime ) { return mime != null && ( mime . equals ( lr_8 ) || MST[rv.ROR2Mutator]MSP[]
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR4Mutator]MSP[] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_32 ) && ! xmlEnc . equals ( bomEnc ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR5Mutator]MSP[]
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { MST[rv.ROR1Mutator]MSP[] offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ;
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { offset += c ; max -= c ; MST[rv.AOD1Mutator]MSP[] c = is . read ( bytes , offset , max ) ;
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR5Mutator]MSP[] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
if ( cTEnc . equals ( UTF_16 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_16 ) ) { return bomEnc ; MST[ReturnValsMutator]MSP[] } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ;
if ( xmlGuessEnc == null || xmlEnc == null ) { return defaultEncoding == null ? UTF_8 : defaultEncoding ; } if ( xmlEnc . equals ( UTF_16 ) && MST[RemoveConditionalMutator_EQUAL_IF]MSP[] ( xmlGuessEnc . equals ( UTF_16BE ) || xmlGuessEnc . equals ( UTF_16LE ) ) ) { return xmlGuessEnc ;
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { MST[rv.ROR3Mutator]MSP[] offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ;
xmlProlog = new String ( bytes , 0 , offset , guessedEnc ) ; firstGT = xmlProlog . indexOf ( '>' ) ; MST[InlineConstantMutator]MSP[] } if ( firstGT == - 1 ) { if ( c == - 1 ) { throw new IOException ( lr_5 ) ; }
if ( cTEnc . equals ( UTF_32 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_32 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR2Mutator]MSP[]
final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR6Mutator]MSP[] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } if ( bomEnc . equals ( UTF_16BE ) || bomEnc . equals ( UTF_16LE ) ) { if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( bomEnc ) ) { MST[rv.ROR2Mutator]MSP[]
throw new IOException ( lr_6 + offset + lr_7 ) ; } final int bytesRead = offset ; if ( bytesRead > 0 ) { MST[rv.ROR3Mutator]MSP[] is . reset () ; final BufferedReader bReader = new BufferedReader ( new StringReader (
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR2Mutator]MSP[] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
if ( httpContentType != null && httpContentType . startsWith ( lr_1 ) ) { httpContentType = httpContentType . substring ( lr_1 . length () ) ; httpContentType = lr_2 + httpContentType ; try { return calculateHttpEncoding ( httpContentType , ex . getBomEncoding () , MST[ArgumentPropagationMutator]MSP[]
int firstGT = - 1 ; MST[rv.CRCR2Mutator]MSP[] String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ;
return reader . read ( buf , offset , len ) ; MST[rv.UOI3Mutator]MSP[] } @Override public void close () throws IOException { reader . close () ; } private String doRawStream ( final BOMInputStream bom , final BOMInputStream pis , final boolean lenient ) throws IOException {
if ( httpContentType != null && httpContentType . startsWith ( lr_1 ) ) { httpContentType = httpContentType . substring ( lr_1 . length () ) ; httpContentType = lr_2 + httpContentType ; try { return calculateHttpEncoding ( httpContentType , ex . getBomEncoding () , MST[ReturnValsMutator]MSP[]
encoding = encoding != null ? encoding . toUpperCase ( Locale . ROOT ) : null ; } } return encoding ; MST[EmptyObjectReturnValsMutator]MSP[] } private static String getXmlProlog ( final InputStream is , final String guessedEnc ) throws IOException { String encoding = null ;
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } if ( bomEnc . equals ( UTF_32BE ) || bomEnc . equals ( UTF_32LE ) ) { MST[rv.ROR4Mutator]MSP[] if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( bomEnc ) ) {
if ( encoding == null ) { MST[rv.ROR5Mutator]MSP[] encoding = defaultEncoding == null ? UTF_8 : defaultEncoding ; } return encoding ; } String calculateRawEncoding ( final String bomEnc , final String xmlGuessEnc , final String xmlEnc ) throws IOException { if ( bomEnc == null ) {
final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[InlineConstantMutator]MSP[] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
if ( lenient ) { MST[rv.ABSMutator]MSP[] return doLenientDetection ( null , ex ) ; } throw ex ; } } private String doHttpStream ( final BOMInputStream bom , final BOMInputStream pis , final String httpContentType , final boolean lenient ) throws IOException {
if ( appXml ) { MST[NegateConditionalsMutator]MSP[] return calculateRawEncoding ( bomEnc , xmlGuessEnc , xmlEnc ) ; } return defaultEncoding == null ? US_ASCII : defaultEncoding ; } if ( cTEnc . equals ( UTF_16BE ) || cTEnc . equals ( UTF_16LE ) ) { if ( bomEnc != null ) {
( mime . equals ( lr_2 ) || mime . equals ( lr_13 ) || MST[NegateConditionalsMutator]MSP[] mime . startsWith ( lr_14 ) && mime . endsWith ( lr_12 ) ) ; }
final String msg = MessageFormat . format ( HTTP_EX_3 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( cTEnc == null ) { MST[NegateConditionalsMutator]MSP[]
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( xmlEnc != null && ! xmlEnc . equals ( UTF_8 ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR5Mutator]MSP[]
static String getContentTypeEncoding ( final String httpContentType ) { String encoding = null ; if ( httpContentType != null ) { final int i = httpContentType . indexOf ( lr_3 ) ; MST[NonVoidMethodCallMutator]MSP[] if ( i > - 1 ) {
if ( appXml ) { return calculateRawEncoding ( bomEnc , xmlGuessEnc , xmlEnc ) ; } return defaultEncoding == null ? US_ASCII : defaultEncoding ; } if ( cTEnc . equals ( UTF_16BE ) || cTEnc . equals ( UTF_16LE ) ) { MST[rv.ROR5Mutator]MSP[] if ( bomEnc != null ) {
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[InlineConstantMutator]MSP[] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
if ( cTEnc . equals ( UTF_16 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_16 ) ) { MST[NegateConditionalsMutator]MSP[] return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ;
if ( cTEnc . equals ( UTF_16 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_16 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR5Mutator]MSP[]
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { offset += c ; MST[rv.AOR3Mutator]MSP[] max -= c ; c = is . read ( bytes , offset , max ) ;
if ( guessedEnc != null ) { MST[rv.ROR5Mutator]MSP[] final byte [] bytes = new byte [ BUFFER_SIZE ] ; is . mark ( BUFFER_SIZE ) ; int offset = 0 ; int max = BUFFER_SIZE ; int c = is . read ( bytes , offset , max ) ;
} final Matcher m = ENCODING_PATTERN . matcher ( prolog ) ; if ( m . find () ) { MST[rv.ROR2Mutator]MSP[] encoding = m . group ( 1 ) . toUpperCase ( Locale . ROOT ) ;
if ( cTEnc . equals ( UTF_32 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_32 ) ) { MST[rv.ROR5Mutator]MSP[] return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ;
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_16 ) && ! xmlEnc . equals ( bomEnc ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
if ( cTEnc . equals ( UTF_16 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_16 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR2Mutator]MSP[]
if ( cTEnc . equals ( UTF_16 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_16 ) ) { return bomEnc ; MST[EmptyObjectReturnValsMutator]MSP[] } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ;
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } final String msg = MessageFormat . format ( RAW_EX_2 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR4Mutator]MSP[] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR3Mutator]MSP[] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
( mime . equals ( lr_2 ) || mime . equals ( lr_13 ) || mime . startsWith ( lr_14 ) && mime . endsWith ( lr_12 ) ) ; MST[InlineConstantMutator]MSP[] }
if ( httpContentType != null && httpContentType . startsWith ( lr_1 ) ) { MST[rv.ROR5Mutator]MSP[] httpContentType = httpContentType . substring ( lr_1 . length () ) ; httpContentType = lr_2 + httpContentType ; try { return calculateHttpEncoding ( httpContentType , ex . getBomEncoding () ,
final int i = httpContentType . indexOf ( lr_3 ) ; if ( i >= 0 ) { mime = httpContentType . substring ( 0 , i ) ; MST[InlineConstantMutator]MSP[] } else { mime = httpContentType ; } mime = mime . trim () ; } return mime ; }
final String msg = MessageFormat . format ( HTTP_EX_3 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR5Mutator]MSP[] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( cTEnc == null ) {
final String msg = MessageFormat . format ( HTTP_EX_3 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR6Mutator]MSP[] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( cTEnc == null ) {
String calculateHttpEncoding ( final String httpContentType , final String bomEnc , final String xmlGuessEnc , final String xmlEnc , final boolean lenient ) throws IOException { if ( lenient && xmlEnc != null ) { MST[rv.ROR5Mutator]MSP[] return xmlEnc ; } final String cTMime = getContentTypeMime ( httpContentType ) ;
( mime . equals ( lr_2 ) || mime . equals ( lr_13 ) || MST[RemoveConditionalMutator_EQUAL_IF]MSP[] mime . startsWith ( lr_14 ) && mime . endsWith ( lr_12 ) ) ; }
} catch ( final XmlStreamReaderException ex ) { if ( lenient ) { return doLenientDetection ( httpContentType , ex ) ; MST[ReturnValsMutator]MSP[] } throw ex ; } } private String doLenientDetection ( String httpContentType , XmlStreamReaderException ex ) throws IOException {
if ( guessedEnc != null ) { final byte [] bytes = new byte [ BUFFER_SIZE ] ; MST[rv.CRCR5Mutator]MSP[] is . mark ( BUFFER_SIZE ) ; int offset = 0 ; int max = BUFFER_SIZE ; int c = is . read ( bytes , offset , max ) ;
if ( cTEnc . equals ( UTF_32 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_32 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[InlineConstantMutator]MSP[]
mime . equals ( lr_9 ) || mime . equals ( lr_10 ) || mime . startsWith ( lr_11 ) && mime . endsWith ( lr_12 ) ) ; MST[rv.ROR5Mutator]MSP[] } static boolean isTextXml ( final String mime ) { return mime != null &&
if ( xmlGuessEnc == null || xmlEnc == null ) { return defaultEncoding == null ? UTF_8 : defaultEncoding ; MST[ReturnValsMutator]MSP[] } if ( xmlEnc . equals ( UTF_16 ) && ( xmlGuessEnc . equals ( UTF_16BE ) || xmlGuessEnc . equals ( UTF_16LE ) ) ) { return xmlGuessEnc ;
if ( cTEnc . equals ( UTF_16 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_16 ) ) { MST[rv.ROR5Mutator]MSP[] return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ;
int firstGT = - 1 ; MST[InlineConstantMutator]MSP[] String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ;
if ( appXml ) { return calculateRawEncoding ( bomEnc , xmlGuessEnc , xmlEnc ) ; } return defaultEncoding == null ? US_ASCII : defaultEncoding ; } if ( cTEnc . equals ( UTF_16BE ) || cTEnc . equals ( UTF_16LE ) ) { MST[NegateConditionalsMutator]MSP[] if ( bomEnc != null ) {
encoding = encoding . substring ( 1 , encoding . length () - 1 ) ; MST[experimental.NakedReceiverMutator]MSP[] } } } return encoding ; } static boolean isAppXml ( final String mime ) { return mime != null && ( mime . equals ( lr_8 ) ||
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[InlineConstantMutator]MSP[] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
if ( guessedEnc != null ) { final byte [] bytes = new byte [ BUFFER_SIZE ] ; is . mark ( BUFFER_SIZE ) ; int offset = 0 ; int max = BUFFER_SIZE ; MST[rv.CRCR4Mutator]MSP[] int c = is . read ( bytes , offset , max ) ;
ex . getXmlGuessEncoding () , ex . getXmlEncoding () , true ) ; MST[NonVoidMethodCallMutator]MSP[] } catch ( final XmlStreamReaderException ex2 ) { ex = ex2 ; } } String encoding = ex . getXmlEncoding () ; if ( encoding == null ) { encoding = ex . getContentTypeEncoding () ; }
final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR1Mutator]MSP[] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_32 ) && ! xmlEnc . equals ( bomEnc ) ) { MST[rv.ROR4Mutator]MSP[] final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
mime . equals ( lr_9 ) || mime . equals ( lr_10 ) || mime . startsWith ( lr_11 ) && mime . endsWith ( lr_12 ) ) ; MST[rv.CRCR5Mutator]MSP[] } static boolean isTextXml ( final String mime ) { return mime != null &&
if ( cTEnc . equals ( UTF_32 ) ) { MST[NegateConditionalsMutator]MSP[] if ( bomEnc != null && bomEnc . startsWith ( UTF_32 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ;
final String postMime = httpContentType . substring ( i + 1 ) ; final Matcher m = CHARSET_PATTERN . matcher ( postMime ) ; encoding = m . find () ? m . group ( 1 ) : null ; MST[rv.CRCR2Mutator]MSP[]
if ( cTEnc . equals ( UTF_16 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_16 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[NonVoidMethodCallMutator]MSP[]
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( xmlEnc != null && ! xmlEnc . equals ( UTF_8 ) ) { MST[rv.ROR1Mutator]MSP[] final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
final String postMime = httpContentType . substring ( i + 1 ) ; final Matcher m = CHARSET_PATTERN . matcher ( postMime ) ; encoding = m . find () ? m . group ( 1 ) : null ; MST[rv.ROR4Mutator]MSP[]
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } final String msg = MessageFormat . format ( RAW_EX_2 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[InlineConstantMutator]MSP[] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR5Mutator]MSP[] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR5Mutator]MSP[] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } if ( bomEnc . equals ( UTF_16BE ) || bomEnc . equals ( UTF_16LE ) ) { if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( bomEnc ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR2Mutator]MSP[] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
if ( cTEnc . equals ( UTF_16 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_16 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[InlineConstantMutator]MSP[]
final int i = httpContentType . indexOf ( lr_3 ) ; if ( i >= 0 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] mime = httpContentType . substring ( 0 , i ) ; } else { mime = httpContentType ; } mime = mime . trim () ; } return mime ; }
} return xmlEnc ; } if ( bomEnc . equals ( UTF_8 ) ) { if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( UTF_8 ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR5Mutator]MSP[]
final String msg = MessageFormat . format ( HTTP_EX_3 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[InlineConstantMutator]MSP[] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( cTEnc == null ) {
final String cTEnc = getContentTypeEncoding ( httpContentType ) ; final boolean appXml = isAppXml ( cTMime ) ; final boolean textXml = isTextXml ( cTMime ) ; if ( ! appXml && ! textXml ) { MST[rv.UOI1Mutator]MSP[]
} catch ( final XmlStreamReaderException ex ) { if ( lenient ) { MST[rv.ROR4Mutator]MSP[] return doLenientDetection ( httpContentType , ex ) ; } throw ex ; } } private String doLenientDetection ( String httpContentType , XmlStreamReaderException ex ) throws IOException {
if ( xmlGuessEnc == null || xmlEnc == null ) { return defaultEncoding == null ? UTF_8 : defaultEncoding ; } if ( xmlEnc . equals ( UTF_16 ) && ( xmlGuessEnc . equals ( UTF_16BE ) || xmlGuessEnc . equals ( UTF_16LE ) ) ) { MST[rv.ROR4Mutator]MSP[] return xmlGuessEnc ;
( mime . equals ( lr_2 ) || mime . equals ( lr_13 ) || mime . startsWith ( lr_14 ) && mime . endsWith ( lr_12 ) ) ; MST[rv.CRCR1Mutator]MSP[] }
if ( encoding == null ) { encoding = defaultEncoding == null ? UTF_8 : defaultEncoding ; } return encoding ; } String calculateRawEncoding ( final String bomEnc , final String xmlGuessEnc , final String xmlEnc ) throws IOException { if ( bomEnc == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_32 ) && ! xmlEnc . equals ( bomEnc ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR5Mutator]MSP[]
} catch ( final XmlStreamReaderException ex ) { if ( lenient ) { return doLenientDetection ( httpContentType , ex ) ; MST[ArgumentPropagationMutator]MSP[] } throw ex ; } } private String doLenientDetection ( String httpContentType , XmlStreamReaderException ex ) throws IOException {
} return xmlEnc ; } if ( bomEnc . equals ( UTF_8 ) ) { MST[rv.ROR4Mutator]MSP[] if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( UTF_8 ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
static String getContentTypeEncoding ( final String httpContentType ) { String encoding = null ; if ( httpContentType != null ) { final int i = httpContentType . indexOf ( lr_3 ) ; if ( i > - 1 ) { MST[rv.CRCR2Mutator]MSP[]
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { MST[rv.UOI2Mutator]MSP[] offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ;
encoding = encoding . substring ( 1 , encoding . length () - 1 ) ; } } } return encoding ; } static boolean isAppXml ( final String mime ) { return mime != null && ( mime . equals ( lr_8 ) || MST[rv.ROR5Mutator]MSP[]
mime . equals ( lr_9 ) || mime . equals ( lr_10 ) || mime . startsWith ( lr_11 ) && mime . endsWith ( lr_12 ) ) ; MST[InlineConstantMutator]MSP[] } static boolean isTextXml ( final String mime ) { return mime != null &&
final String msg = MessageFormat . format ( HTTP_EX_3 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR3Mutator]MSP[] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( cTEnc == null ) {
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { MST[rv.ABSMutator]MSP[] offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ;
throw new IOException ( lr_6 + offset + lr_7 ) ; } final int bytesRead = offset ; if ( bytesRead > 0 ) { is . reset () ; final BufferedReader bReader = new BufferedReader ( new StringReader ( MST[rv.AOD1Mutator]MSP[]
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_32 ) && ! xmlEnc . equals ( bomEnc ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR2Mutator]MSP[]
final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR6Mutator]MSP[] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR1Mutator]MSP[] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
if ( cTEnc . equals ( UTF_32 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_32 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR2Mutator]MSP[]
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { offset += c ; MST[rv.UOI4Mutator]MSP[] max -= c ; c = is . read ( bytes , offset , max ) ;
throw new IOException ( lr_6 + offset + lr_7 ) ; } final int bytesRead = offset ; if ( bytesRead > 0 ) { is . reset () ; final BufferedReader bReader = new BufferedReader ( new StringReader ( MST[rv.CRCR6Mutator]MSP[]
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } if ( bomEnc . equals ( UTF_16BE ) || bomEnc . equals ( UTF_16LE ) ) { MST[rv.ROR3Mutator]MSP[] if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( bomEnc ) ) {
encoding = encoding . substring ( 1 , encoding . length () - 1 ) ; MST[rv.CRCR5Mutator]MSP[] } } } return encoding ; } static boolean isAppXml ( final String mime ) { return mime != null && ( mime . equals ( lr_8 ) ||
throw new IOException ( lr_6 + offset + lr_7 ) ; } final int bytesRead = offset ; MST[rv.ABSMutator]MSP[] if ( bytesRead > 0 ) { is . reset () ; final BufferedReader bReader = new BufferedReader ( new StringReader (
if ( cTEnc . equals ( UTF_32 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_32 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR5Mutator]MSP[]
if ( cTEnc . equals ( UTF_16 ) ) { MST[rv.ROR4Mutator]MSP[] if ( bomEnc != null && bomEnc . startsWith ( UTF_16 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ;
mime . equals ( lr_9 ) || MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] mime . equals ( lr_10 ) || mime . startsWith ( lr_11 ) && mime . endsWith ( lr_12 ) ) ; } static boolean isTextXml ( final String mime ) { return mime != null &&
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ; MST[rv.UOI3Mutator]MSP[]
static String getContentTypeEncoding ( final String httpContentType ) { String encoding = null ; if ( httpContentType != null ) { final int i = httpContentType . indexOf ( lr_3 ) ; if ( i > - 1 ) { MST[rv.UOI2Mutator]MSP[]
ex . getXmlGuessEncoding () , ex . getXmlEncoding () , true ) ; } catch ( final XmlStreamReaderException ex2 ) { ex = ex2 ; } } String encoding = ex . getXmlEncoding () ; if ( encoding == null ) { encoding = ex . getContentTypeEncoding () ; MST[NonVoidMethodCallMutator]MSP[] }
final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[InlineConstantMutator]MSP[] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
final String postMime = httpContentType . substring ( i + 1 ) ; MST[rv.CRCR4Mutator]MSP[] final Matcher m = CHARSET_PATTERN . matcher ( postMime ) ; encoding = m . find () ? m . group ( 1 ) : null ;
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( xmlEnc != null && ! xmlEnc . equals ( UTF_8 ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR5Mutator]MSP[]
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { MST[InlineConstantMutator]MSP[] offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ;
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( xmlEnc != null && ! xmlEnc . equals ( UTF_8 ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR2Mutator]MSP[]
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { MST[rv.UOI1Mutator]MSP[] offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ;
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } if ( bomEnc . equals ( UTF_32BE ) || bomEnc . equals ( UTF_32LE ) ) { if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( bomEnc ) ) { MST[rv.ROR1Mutator]MSP[]
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } if ( bomEnc . equals ( UTF_32BE ) || bomEnc . equals ( UTF_32LE ) ) { if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( bomEnc ) ) { MST[rv.ROR4Mutator]MSP[]
encoding = encoding != null ? encoding . toUpperCase ( Locale . ROOT ) : null ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] } } return encoding ; } private static String getXmlProlog ( final InputStream is , final String guessedEnc ) throws IOException { String encoding = null ;
if ( guessedEnc != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] final byte [] bytes = new byte [ BUFFER_SIZE ] ; is . mark ( BUFFER_SIZE ) ; int offset = 0 ; int max = BUFFER_SIZE ; int c = is . read ( bytes , offset , max ) ;
throw new IOException ( lr_6 + offset + lr_7 ) ; } final int bytesRead = offset ; MST[rv.UOI1Mutator]MSP[] if ( bytesRead > 0 ) { is . reset () ; final BufferedReader bReader = new BufferedReader ( new StringReader (
if ( cTEnc . equals ( UTF_16 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_16 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR1Mutator]MSP[]
encoding = encoding . substring ( 1 , encoding . length () - 1 ) ; MST[rv.CRCR2Mutator]MSP[] } } } return encoding ; } static boolean isAppXml ( final String mime ) { return mime != null && ( mime . equals ( lr_8 ) ||
return reader . read ( buf , offset , len ) ; MST[rv.UOI1Mutator]MSP[] } @Override public void close () throws IOException { reader . close () ; } private String doRawStream ( final BOMInputStream bom , final BOMInputStream pis , final boolean lenient ) throws IOException {
final String bomEnc = bom . getBOMCharsetName () ; final String xmlGuessEnc = pis . getBOMCharsetName () ; final String xmlEnc = getXmlProlog ( pis , xmlGuessEnc ) ; MST[NonVoidMethodCallMutator]MSP[] try { return calculateRawEncoding ( bomEnc , xmlGuessEnc , xmlEnc ) ; } catch ( final XmlStreamReaderException ex ) {
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } final String msg = MessageFormat . format ( RAW_EX_2 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR3Mutator]MSP[] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[InlineConstantMutator]MSP[] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
if ( xmlGuessEnc == null || xmlEnc == null ) { return defaultEncoding == null ? UTF_8 : defaultEncoding ; } if ( xmlEnc . equals ( UTF_16 ) && MST[rv.ROR2Mutator]MSP[] ( xmlGuessEnc . equals ( UTF_16BE ) || xmlGuessEnc . equals ( UTF_16LE ) ) ) { return xmlGuessEnc ;
encoding = encoding . substring ( 1 , encoding . length () - 1 ) ; } } } return encoding ; } static boolean isAppXml ( final String mime ) { return mime != null && ( mime . equals ( lr_8 ) || MST[NegateConditionalsMutator]MSP[]
mime . equals ( lr_9 ) || mime . equals ( lr_10 ) || MST[RemoveConditionalMutator_EQUAL_IF]MSP[] mime . startsWith ( lr_11 ) && mime . endsWith ( lr_12 ) ) ; } static boolean isTextXml ( final String mime ) { return mime != null &&
if ( guessedEnc != null ) { final byte [] bytes = new byte [ BUFFER_SIZE ] ; is . mark ( BUFFER_SIZE ) ; int offset = 0 ; int max = BUFFER_SIZE ; int c = is . read ( bytes , offset , max ) ; MST[rv.UOI1Mutator]MSP[]
public String getDefaultEncoding () { return defaultEncoding ; } public String getEncoding () { return encoding ; MST[EmptyObjectReturnValsMutator]MSP[] } @Override public int read ( final char [] buf , final int offset , final int len ) throws IOException {
return reader . read ( buf , offset , len ) ; } @Override public void close () throws IOException { reader . close () ; MST[VoidMethodCallMutator]MSP[] } private String doRawStream ( final BOMInputStream bom , final BOMInputStream pis , final boolean lenient ) throws IOException {
if ( guessedEnc != null ) { final byte [] bytes = new byte [ BUFFER_SIZE ] ; is . mark ( BUFFER_SIZE ) ; int offset = 0 ; int max = BUFFER_SIZE ; int c = is . read ( bytes , offset , max ) ; MST[rv.ABSMutator]MSP[]
final String msg = MessageFormat . format ( HTTP_EX_3 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR6Mutator]MSP[] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( cTEnc == null ) {
final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR3Mutator]MSP[] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_16 ) && ! xmlEnc . equals ( bomEnc ) ) { MST[rv.ROR3Mutator]MSP[] final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[InlineConstantMutator]MSP[] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
if ( xmlGuessEnc == null || xmlEnc == null ) { return defaultEncoding == null ? UTF_8 : defaultEncoding ; MST[EmptyObjectReturnValsMutator]MSP[] } if ( xmlEnc . equals ( UTF_16 ) && ( xmlGuessEnc . equals ( UTF_16BE ) || xmlGuessEnc . equals ( UTF_16LE ) ) ) { return xmlGuessEnc ;
xmlProlog = new String ( bytes , 0 , offset , guessedEnc ) ; firstGT = xmlProlog . indexOf ( '>' ) ; } if ( firstGT == - 1 ) { MST[rv.CRCR2Mutator]MSP[] if ( c == - 1 ) { throw new IOException ( lr_5 ) ; }
if ( cTEnc . equals ( UTF_16 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_16 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR3Mutator]MSP[]
xmlProlog = new String ( bytes , 0 , offset , guessedEnc ) ; MST[rv.CRCR5Mutator]MSP[] firstGT = xmlProlog . indexOf ( '>' ) ; } if ( firstGT == - 1 ) { if ( c == - 1 ) { throw new IOException ( lr_5 ) ; }
if ( httpContentType != null && httpContentType . startsWith ( lr_1 ) ) { httpContentType = httpContentType . substring ( lr_1 . length () ) ; httpContentType = lr_2 + httpContentType ; try { return calculateHttpEncoding ( httpContentType , ex . getBomEncoding () , MST[NonVoidMethodCallMutator]MSP[]
if ( cTEnc . equals ( UTF_16 ) ) { MST[rv.ROR1Mutator]MSP[] if ( bomEnc != null && bomEnc . startsWith ( UTF_16 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ;
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } final String msg = MessageFormat . format ( RAW_EX_2 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR1Mutator]MSP[] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
} return xmlEnc ; } if ( bomEnc . equals ( UTF_8 ) ) { if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( UTF_8 ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR2Mutator]MSP[]
if ( cTEnc . equals ( UTF_32 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_32 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[InlineConstantMutator]MSP[]
if ( xmlGuessEnc == null || xmlEnc == null ) { return defaultEncoding == null ? UTF_8 : defaultEncoding ; } if ( xmlEnc . equals ( UTF_16 ) && MST[rv.ROR5Mutator]MSP[] ( xmlGuessEnc . equals ( UTF_16BE ) || xmlGuessEnc . equals ( UTF_16LE ) ) ) { return xmlGuessEnc ;
( mime . equals ( lr_2 ) || mime . equals ( lr_13 ) || mime . startsWith ( lr_14 ) && mime . endsWith ( lr_12 ) ) ; MST[rv.ROR4Mutator]MSP[] }
( mime . equals ( lr_2 ) || mime . equals ( lr_13 ) || MST[rv.ROR2Mutator]MSP[] mime . startsWith ( lr_14 ) && mime . endsWith ( lr_12 ) ) ; }
if ( xmlGuessEnc == null || xmlEnc == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return defaultEncoding == null ? UTF_8 : defaultEncoding ; } if ( xmlEnc . equals ( UTF_16 ) && ( xmlGuessEnc . equals ( UTF_16BE ) || xmlGuessEnc . equals ( UTF_16LE ) ) ) { return xmlGuessEnc ;
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { offset += c ; max -= c ; MST[rv.AOR1Mutator]MSP[] c = is . read ( bytes , offset , max ) ;
final String cTEnc = getContentTypeEncoding ( httpContentType ) ; final boolean appXml = isAppXml ( cTMime ) ; final boolean textXml = isTextXml ( cTMime ) ; if ( ! appXml && ! textXml ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
final int i = httpContentType . indexOf ( lr_3 ) ; if ( i >= 0 ) { mime = httpContentType . substring ( 0 , i ) ; MST[rv.CRCR1Mutator]MSP[] } else { mime = httpContentType ; } mime = mime . trim () ; } return mime ; }
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } if ( bomEnc . equals ( UTF_16BE ) || bomEnc . equals ( UTF_16LE ) ) { if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( bomEnc ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR1Mutator]MSP[] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
if ( httpContentType != null && httpContentType . startsWith ( lr_1 ) ) { httpContentType = httpContentType . substring ( lr_1 . length () ) ; httpContentType = lr_2 + httpContentType ; MST[experimental.NakedReceiverMutator]MSP[] try { return calculateHttpEncoding ( httpContentType , ex . getBomEncoding () ,
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ; MST[rv.UOI4Mutator]MSP[]
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR5Mutator]MSP[] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_32 ) && ! xmlEnc . equals ( bomEnc ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR4Mutator]MSP[]
ex . getXmlGuessEncoding () , ex . getXmlEncoding () , true ) ; } catch ( final XmlStreamReaderException ex2 ) { ex = ex2 ; } } String encoding = ex . getXmlEncoding () ; if ( encoding == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] encoding = ex . getContentTypeEncoding () ; }
final int i = httpContentType . indexOf ( lr_3 ) ; if ( i >= 0 ) { MST[rv.ROR5Mutator]MSP[] mime = httpContentType . substring ( 0 , i ) ; } else { mime = httpContentType ; } mime = mime . trim () ; } return mime ; }
if ( cTEnc . equals ( UTF_16 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_16 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[InlineConstantMutator]MSP[]
throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( cTEnc . equals ( UTF_32BE ) || cTEnc . equals ( UTF_32LE ) ) { MST[NegateConditionalsMutator]MSP[] if ( bomEnc != null ) {
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_32 ) && ! xmlEnc . equals ( bomEnc ) ) { MST[rv.ROR1Mutator]MSP[] final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
if ( xmlGuessEnc == null || xmlEnc == null ) { return defaultEncoding == null ? UTF_8 : defaultEncoding ; } if ( xmlEnc . equals ( UTF_16 ) && ( xmlGuessEnc . equals ( UTF_16BE ) || xmlGuessEnc . equals ( UTF_16LE ) ) ) { MST[rv.ROR4Mutator]MSP[] return xmlGuessEnc ;
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( xmlEnc != null && ! xmlEnc . equals ( UTF_8 ) ) { MST[NegateConditionalsMutator]MSP[] final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
if ( guessedEnc != null ) { final byte [] bytes = new byte [ BUFFER_SIZE ] ; is . mark ( BUFFER_SIZE ) ; int offset = 0 ; int max = BUFFER_SIZE ; int c = is . read ( bytes , offset , max ) ; MST[rv.UOI2Mutator]MSP[]
} return xmlEnc ; } if ( bomEnc . equals ( UTF_8 ) ) { if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( UTF_8 ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR5Mutator]MSP[]
if ( appXml ) { MST[rv.ROR1Mutator]MSP[] return calculateRawEncoding ( bomEnc , xmlGuessEnc , xmlEnc ) ; } return defaultEncoding == null ? US_ASCII : defaultEncoding ; } if ( cTEnc . equals ( UTF_16BE ) || cTEnc . equals ( UTF_16LE ) ) { if ( bomEnc != null ) {
( mime . equals ( lr_2 ) || MST[rv.ROR3Mutator]MSP[] mime . equals ( lr_13 ) || mime . startsWith ( lr_14 ) && mime . endsWith ( lr_12 ) ) ; }
if ( appXml ) { return calculateRawEncoding ( bomEnc , xmlGuessEnc , xmlEnc ) ; } return defaultEncoding == null ? US_ASCII : defaultEncoding ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] } if ( cTEnc . equals ( UTF_16BE ) || cTEnc . equals ( UTF_16LE ) ) { if ( bomEnc != null ) {
} return xmlEnc ; } if ( bomEnc . equals ( UTF_8 ) ) { if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( UTF_8 ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[InlineConstantMutator]MSP[]
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_32 ) && ! xmlEnc . equals ( bomEnc ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR5Mutator]MSP[]
} return xmlEnc ; } if ( bomEnc . equals ( UTF_8 ) ) { if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( UTF_8 ) ) { MST[rv.ROR1Mutator]MSP[] final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
final String msg = MessageFormat . format ( HTTP_EX_3 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR3Mutator]MSP[] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( cTEnc == null ) {
( mime . equals ( lr_2 ) || mime . equals ( lr_13 ) || MST[rv.ROR5Mutator]MSP[] mime . startsWith ( lr_14 ) && mime . endsWith ( lr_12 ) ) ; }
if ( cTEnc . equals ( UTF_32 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_32 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR1Mutator]MSP[]
mime . equals ( lr_9 ) || mime . equals ( lr_10 ) || mime . startsWith ( lr_11 ) && mime . endsWith ( lr_12 ) ) ; MST[InlineConstantMutator]MSP[] } static boolean isTextXml ( final String mime ) { return mime != null &&
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { offset += c ; MST[rv.UOI1Mutator]MSP[] max -= c ; c = is . read ( bytes , offset , max ) ;
mime . equals ( lr_9 ) || mime . equals ( lr_10 ) || MST[NonVoidMethodCallMutator]MSP[] mime . startsWith ( lr_11 ) && mime . endsWith ( lr_12 ) ) ; } static boolean isTextXml ( final String mime ) { return mime != null &&
if ( lenient ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return doLenientDetection ( null , ex ) ; } throw ex ; } } private String doHttpStream ( final BOMInputStream bom , final BOMInputStream pis , final String httpContentType , final boolean lenient ) throws IOException {
final int i = httpContentType . indexOf ( lr_3 ) ; if ( i >= 0 ) { MST[NegateConditionalsMutator]MSP[] mime = httpContentType . substring ( 0 , i ) ; } else { mime = httpContentType ; } mime = mime . trim () ; } return mime ; }
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR5Mutator]MSP[] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
if ( cTEnc . equals ( UTF_32 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_32 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR5Mutator]MSP[]
throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( cTEnc . equals ( UTF_32BE ) || cTEnc . equals ( UTF_32LE ) ) { MST[rv.ROR5Mutator]MSP[] if ( bomEnc != null ) {
xmlProlog = new String ( bytes , 0 , offset , guessedEnc ) ; MST[InlineConstantMutator]MSP[] firstGT = xmlProlog . indexOf ( '>' ) ; } if ( firstGT == - 1 ) { if ( c == - 1 ) { throw new IOException ( lr_5 ) ; }
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } if ( bomEnc . equals ( UTF_16BE ) || bomEnc . equals ( UTF_16LE ) ) { if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( bomEnc ) ) { MST[NonVoidMethodCallMutator]MSP[]
final String postMime = httpContentType . substring ( i + 1 ) ; MST[rv.UOI4Mutator]MSP[] final Matcher m = CHARSET_PATTERN . matcher ( postMime ) ; encoding = m . find () ? m . group ( 1 ) : null ;
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { offset += c ; MST[rv.AOD2Mutator]MSP[] max -= c ; c = is . read ( bytes , offset , max ) ;
if ( guessedEnc != null ) { final byte [] bytes = new byte [ BUFFER_SIZE ] ; is . mark ( BUFFER_SIZE ) ; int offset = 0 ; int max = BUFFER_SIZE ; int c = is . read ( bytes , offset , max ) ; MST[ArgumentPropagationMutator]MSP[]
if ( encoding == null ) { encoding = defaultEncoding == null ? UTF_8 : defaultEncoding ; MST[NegateConditionalsMutator]MSP[] } return encoding ; } String calculateRawEncoding ( final String bomEnc , final String xmlGuessEnc , final String xmlEnc ) throws IOException { if ( bomEnc == null ) {
encoding = encoding . substring ( 1 , encoding . length () - 1 ) ; MST[rv.AOR3Mutator]MSP[] } } } return encoding ; } static boolean isAppXml ( final String mime ) { return mime != null && ( mime . equals ( lr_8 ) ||
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { MST[rv.CRCR4Mutator]MSP[] offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ;
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { MST[rv.CRCR5Mutator]MSP[] offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ;
final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[InlineConstantMutator]MSP[] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { MST[rv.CRCR6Mutator]MSP[] offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ;
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[ConstructorCallMutator]MSP[] } return bomEnc ; } if ( bomEnc . equals ( UTF_16BE ) || bomEnc . equals ( UTF_16LE ) ) { if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( bomEnc ) ) {
if ( encoding == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] encoding = defaultEncoding == null ? UTF_8 : defaultEncoding ; } return encoding ; } String calculateRawEncoding ( final String bomEnc , final String xmlGuessEnc , final String xmlEnc ) throws IOException { if ( bomEnc == null ) {
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( xmlEnc != null && ! xmlEnc . equals ( UTF_8 ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR5Mutator]MSP[]
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( xmlEnc != null && ! xmlEnc . equals ( UTF_8 ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR2Mutator]MSP[]
if ( appXml ) { return calculateRawEncoding ( bomEnc , xmlGuessEnc , xmlEnc ) ; } return defaultEncoding == null ? US_ASCII : defaultEncoding ; } if ( cTEnc . equals ( UTF_16BE ) || cTEnc . equals ( UTF_16LE ) ) { MST[rv.ROR1Mutator]MSP[] if ( bomEnc != null ) {
xmlProlog = new String ( bytes , 0 , offset , guessedEnc ) ; MST[rv.UOI3Mutator]MSP[] firstGT = xmlProlog . indexOf ( '>' ) ; } if ( firstGT == - 1 ) { if ( c == - 1 ) { throw new IOException ( lr_5 ) ; }
throw new IOException ( lr_6 + offset + lr_7 ) ; } final int bytesRead = offset ; if ( bytesRead > 0 ) { MST[rv.ABSMutator]MSP[] is . reset () ; final BufferedReader bReader = new BufferedReader ( new StringReader (
if ( httpContentType != null && httpContentType . startsWith ( lr_1 ) ) { httpContentType = httpContentType . substring ( lr_1 . length () ) ; httpContentType = lr_2 + httpContentType ; MST[ConstructorCallMutator]MSP[] try { return calculateHttpEncoding ( httpContentType , ex . getBomEncoding () ,
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } final String msg = MessageFormat . format ( RAW_EX_2 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[NonVoidMethodCallMutator]MSP[] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR5Mutator]MSP[] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
if ( cTEnc . equals ( UTF_32 ) ) { MST[rv.ROR1Mutator]MSP[] if ( bomEnc != null && bomEnc . startsWith ( UTF_32 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ;
final String cTEnc = getContentTypeEncoding ( httpContentType ) ; final boolean appXml = isAppXml ( cTMime ) ; final boolean textXml = isTextXml ( cTMime ) ; if ( ! appXml && ! textXml ) { MST[rv.ROR2Mutator]MSP[]
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[InlineConstantMutator]MSP[] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
final String postMime = httpContentType . substring ( i + 1 ) ; final Matcher m = CHARSET_PATTERN . matcher ( postMime ) ; encoding = m . find () ? m . group ( 1 ) : null ; MST[rv.CRCR5Mutator]MSP[]
encoding = encoding . substring ( 1 , encoding . length () - 1 ) ; } } } return encoding ; } static boolean isAppXml ( final String mime ) { return mime != null && MST[BooleanTrueReturnValsMutator]MSP[] ( mime . equals ( lr_8 ) ||
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } if ( bomEnc . equals ( UTF_32BE ) || bomEnc . equals ( UTF_32LE ) ) { MST[rv.ROR1Mutator]MSP[] if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( bomEnc ) ) {
if ( encoding == null ) { encoding = defaultEncoding == null ? UTF_8 : defaultEncoding ; MST[rv.ROR5Mutator]MSP[] } return encoding ; } String calculateRawEncoding ( final String bomEnc , final String xmlGuessEnc , final String xmlEnc ) throws IOException { if ( bomEnc == null ) {
if ( httpContentType != null && httpContentType . startsWith ( lr_1 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] httpContentType = httpContentType . substring ( lr_1 . length () ) ; httpContentType = lr_2 + httpContentType ; try { return calculateHttpEncoding ( httpContentType , ex . getBomEncoding () ,
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[InlineConstantMutator]MSP[] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
if ( guessedEnc != null ) { final byte [] bytes = new byte [ BUFFER_SIZE ] ; is . mark ( BUFFER_SIZE ) ; MST[rv.CRCR4Mutator]MSP[] int offset = 0 ; int max = BUFFER_SIZE ; int c = is . read ( bytes , offset , max ) ;
final String msg = MessageFormat . format ( HTTP_EX_3 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR6Mutator]MSP[] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( cTEnc == null ) {
if ( guessedEnc != null ) { final byte [] bytes = new byte [ BUFFER_SIZE ] ; MST[rv.CRCR2Mutator]MSP[] is . mark ( BUFFER_SIZE ) ; int offset = 0 ; int max = BUFFER_SIZE ; int c = is . read ( bytes , offset , max ) ;
mime . equals ( lr_9 ) || mime . equals ( lr_10 ) || mime . startsWith ( lr_11 ) && mime . endsWith ( lr_12 ) ) ; MST[rv.ROR1Mutator]MSP[] } static boolean isTextXml ( final String mime ) { return mime != null &&
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_16 ) && ! xmlEnc . equals ( bomEnc ) ) { MST[rv.ROR3Mutator]MSP[] final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( xmlEnc != null && ! xmlEnc . equals ( UTF_8 ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR4Mutator]MSP[]
xmlProlog . substring ( 0 , firstGT + 1 ) ) ) ; final StringBuffer prolog = new StringBuffer () ; String line = bReader . readLine () ; while ( line != null ) { prolog . append ( line ) ; MST[NonVoidMethodCallMutator]MSP[] line = bReader . readLine () ;
final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR3Mutator]MSP[] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
if ( cTEnc . equals ( UTF_32 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_32 ) ) { MST[NegateConditionalsMutator]MSP[] return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ;
final String bomEnc = bom . getBOMCharsetName () ; final String xmlGuessEnc = pis . getBOMCharsetName () ; final String xmlEnc = getXmlProlog ( pis , xmlGuessEnc ) ; MST[ArgumentPropagationMutator]MSP[] try { return calculateHttpEncoding ( httpContentType , bomEnc , xmlGuessEnc , xmlEnc , lenient ) ;
if ( cTEnc . equals ( UTF_16 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_16 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR5Mutator]MSP[]
encoding = encoding . substring ( 1 , encoding . length () - 1 ) ; MST[InlineConstantMutator]MSP[] } } } return encoding ; } static boolean isAppXml ( final String mime ) { return mime != null && ( mime . equals ( lr_8 ) ||
} final Matcher m = ENCODING_PATTERN . matcher ( prolog ) ; if ( m . find () ) { MST[rv.ROR5Mutator]MSP[] encoding = m . group ( 1 ) . toUpperCase ( Locale . ROOT ) ;
( mime . equals ( lr_2 ) || mime . equals ( lr_13 ) || mime . startsWith ( lr_14 ) && mime . endsWith ( lr_12 ) ) ; MST[rv.ROR4Mutator]MSP[] }
if ( cTEnc . equals ( UTF_32 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_32 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[InlineConstantMutator]MSP[]
xmlProlog = new String ( bytes , 0 , offset , guessedEnc ) ; firstGT = xmlProlog . indexOf ( '>' ) ; } if ( firstGT == - 1 ) { MST[rv.UOI2Mutator]MSP[] if ( c == - 1 ) { throw new IOException ( lr_5 ) ; }
String calculateHttpEncoding ( final String httpContentType , final String bomEnc , final String xmlGuessEnc , final String xmlEnc , final boolean lenient ) throws IOException { if ( lenient && xmlEnc != null ) { return xmlEnc ; } final String cTMime = getContentTypeMime ( httpContentType ) ; MST[ArgumentPropagationMutator]MSP[]
final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR1Mutator]MSP[] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
( mime . equals ( lr_2 ) || mime . equals ( lr_13 ) || mime . startsWith ( lr_14 ) && mime . endsWith ( lr_12 ) ) ; MST[rv.CRCR4Mutator]MSP[] }
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } final String msg = MessageFormat . format ( RAW_EX_2 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[ArgumentPropagationMutator]MSP[] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_32 ) && ! xmlEnc . equals ( bomEnc ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR1Mutator]MSP[]
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { offset += c ; max -= c ; MST[MathMutator]MSP[] c = is . read ( bytes , offset , max ) ;
} catch ( final XmlStreamReaderException ex ) { if ( lenient ) { MST[rv.UOI1Mutator]MSP[] return doLenientDetection ( httpContentType , ex ) ; } throw ex ; } } private String doLenientDetection ( String httpContentType , XmlStreamReaderException ex ) throws IOException {
mime . equals ( lr_9 ) || mime . equals ( lr_10 ) || mime . startsWith ( lr_11 ) && mime . endsWith ( lr_12 ) ) ; } static boolean isTextXml ( final String mime ) { return mime != null && MST[NegateConditionalsMutator]MSP[]
final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[NonVoidMethodCallMutator]MSP[] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR6Mutator]MSP[] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
if ( cTEnc . equals ( UTF_32 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_32 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR3Mutator]MSP[]
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { offset += c ; max -= c ; MST[rv.UOI3Mutator]MSP[] c = is . read ( bytes , offset , max ) ;
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_32 ) && ! xmlEnc . equals ( bomEnc ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
if ( cTEnc . equals ( UTF_16 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_16 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[InlineConstantMutator]MSP[]
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { MST[rv.ROR1Mutator]MSP[] offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ;
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_32 ) && ! xmlEnc . equals ( bomEnc ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } if ( bomEnc . equals ( UTF_16BE ) || bomEnc . equals ( UTF_16LE ) ) { MST[NegateConditionalsMutator]MSP[] if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( bomEnc ) ) {
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; MST[ReturnValsMutator]MSP[] } if ( bomEnc . equals ( UTF_16BE ) || bomEnc . equals ( UTF_16LE ) ) { if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( bomEnc ) ) {
return reader . read ( buf , offset , len ) ; MST[rv.UOI4Mutator]MSP[] } @Override public void close () throws IOException { reader . close () ; } private String doRawStream ( final BOMInputStream bom , final BOMInputStream pis , final boolean lenient ) throws IOException {
( mime . equals ( lr_2 ) || mime . equals ( lr_13 ) || mime . startsWith ( lr_14 ) && mime . endsWith ( lr_12 ) ) ; MST[rv.ROR1Mutator]MSP[] }
( mime . equals ( lr_2 ) || mime . equals ( lr_13 ) || mime . startsWith ( lr_14 ) && mime . endsWith ( lr_12 ) ) ; MST[rv.CRCR3Mutator]MSP[] }
} catch ( final XmlStreamReaderException ex ) { if ( lenient ) { MST[rv.ROR2Mutator]MSP[] return doLenientDetection ( httpContentType , ex ) ; } throw ex ; } } private String doLenientDetection ( String httpContentType , XmlStreamReaderException ex ) throws IOException {
encoding = encoding . substring ( 1 , encoding . length () - 1 ) ; MST[rv.AOR4Mutator]MSP[] } } } return encoding ; } static boolean isAppXml ( final String mime ) { return mime != null && ( mime . equals ( lr_8 ) ||
} catch ( final XmlStreamReaderException ex ) { if ( lenient ) { return doLenientDetection ( httpContentType , ex ) ; MST[EmptyObjectReturnValsMutator]MSP[] } throw ex ; } } private String doLenientDetection ( String httpContentType , XmlStreamReaderException ex ) throws IOException {
xmlProlog . substring ( 0 , firstGT + 1 ) ) ) ; final StringBuffer prolog = new StringBuffer () ; String line = bReader . readLine () ; while ( line != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] prolog . append ( line ) ; line = bReader . readLine () ;
mime . equals ( lr_9 ) || MST[RemoveConditionalMutator_EQUAL_IF]MSP[] mime . equals ( lr_10 ) || mime . startsWith ( lr_11 ) && mime . endsWith ( lr_12 ) ) ; } static boolean isTextXml ( final String mime ) { return mime != null &&
} return xmlEnc ; } if ( bomEnc . equals ( UTF_8 ) ) { if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( UTF_8 ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR5Mutator]MSP[]
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_16 ) && ! xmlEnc . equals ( bomEnc ) ) { MST[rv.ROR5Mutator]MSP[] final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
if ( cTEnc . equals ( UTF_16 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_16 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR6Mutator]MSP[]
final String postMime = httpContentType . substring ( i + 1 ) ; MST[rv.AOD1Mutator]MSP[] final Matcher m = CHARSET_PATTERN . matcher ( postMime ) ; encoding = m . find () ? m . group ( 1 ) : null ;
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR3Mutator]MSP[] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( xmlEnc != null && ! xmlEnc . equals ( UTF_8 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
} final Matcher m = ENCODING_PATTERN . matcher ( prolog ) ; if ( m . find () ) { encoding = m . group ( 1 ) . toUpperCase ( Locale . ROOT ) ; MST[rv.CRCR5Mutator]MSP[]
if ( httpContentType != null && httpContentType . startsWith ( lr_1 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] httpContentType = httpContentType . substring ( lr_1 . length () ) ; httpContentType = lr_2 + httpContentType ; try { return calculateHttpEncoding ( httpContentType , ex . getBomEncoding () ,
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { MST[rv.ROR2Mutator]MSP[] offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ;
mime . equals ( lr_9 ) || mime . equals ( lr_10 ) || MST[rv.ROR2Mutator]MSP[] mime . startsWith ( lr_11 ) && mime . endsWith ( lr_12 ) ) ; } static boolean isTextXml ( final String mime ) { return mime != null &&
mime . equals ( lr_9 ) || mime . equals ( lr_10 ) || mime . startsWith ( lr_11 ) && mime . endsWith ( lr_12 ) ) ; MST[rv.ROR4Mutator]MSP[] } static boolean isTextXml ( final String mime ) { return mime != null &&
if ( guessedEnc != null ) { final byte [] bytes = new byte [ BUFFER_SIZE ] ; is . mark ( BUFFER_SIZE ) ; int offset = 0 ; MST[rv.CRCR5Mutator]MSP[] int max = BUFFER_SIZE ; int c = is . read ( bytes , offset , max ) ;
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR1Mutator]MSP[] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
if ( lenient ) { MST[rv.UOI1Mutator]MSP[] return doLenientDetection ( null , ex ) ; } throw ex ; } } private String doHttpStream ( final BOMInputStream bom , final BOMInputStream pis , final String httpContentType , final boolean lenient ) throws IOException {
} catch ( final XmlStreamReaderException ex ) { if ( lenient ) { return doLenientDetection ( httpContentType , ex ) ; MST[NonVoidMethodCallMutator]MSP[] } throw ex ; } } private String doLenientDetection ( String httpContentType , XmlStreamReaderException ex ) throws IOException {
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_16 ) && ! xmlEnc . equals ( bomEnc ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR4Mutator]MSP[]
xmlProlog = new String ( bytes , 0 , offset , guessedEnc ) ; firstGT = xmlProlog . indexOf ( '>' ) ; } if ( firstGT == - 1 ) { MST[NegateConditionalsMutator]MSP[] if ( c == - 1 ) { throw new IOException ( lr_5 ) ; }
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[ArgumentPropagationMutator]MSP[] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_32 ) && ! xmlEnc . equals ( bomEnc ) ) { MST[NonVoidMethodCallMutator]MSP[] final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
if ( lenient ) { MST[rv.ROR2Mutator]MSP[] return doLenientDetection ( null , ex ) ; } throw ex ; } } private String doHttpStream ( final BOMInputStream bom , final BOMInputStream pis , final String httpContentType , final boolean lenient ) throws IOException {
( mime . equals ( lr_2 ) || mime . equals ( lr_13 ) || mime . startsWith ( lr_14 ) && mime . endsWith ( lr_12 ) ) ; MST[rv.CRCR6Mutator]MSP[] }
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } if ( bomEnc . equals ( UTF_32BE ) || bomEnc . equals ( UTF_32LE ) ) { if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( bomEnc ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
final String msg = MessageFormat . format ( HTTP_EX_3 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR1Mutator]MSP[] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( cTEnc == null ) {
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { MST[rv.UOI4Mutator]MSP[] offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ;
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_16 ) && ! xmlEnc . equals ( bomEnc ) ) { MST[NegateConditionalsMutator]MSP[] final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } if ( bomEnc . equals ( UTF_32BE ) || bomEnc . equals ( UTF_32LE ) ) { if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( bomEnc ) ) { MST[rv.ROR3Mutator]MSP[]
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { offset += c ; MST[rv.UOI1Mutator]MSP[] max -= c ; c = is . read ( bytes , offset , max ) ;
throw new IOException ( lr_6 + offset + lr_7 ) ; } final int bytesRead = offset ; MST[rv.UOI4Mutator]MSP[] if ( bytesRead > 0 ) { is . reset () ; final BufferedReader bReader = new BufferedReader ( new StringReader (
if ( cTEnc . equals ( UTF_16 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_16 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR4Mutator]MSP[]
encoding = encoding . substring ( 1 , encoding . length () - 1 ) ; MST[rv.CRCR3Mutator]MSP[] } } } return encoding ; } static boolean isAppXml ( final String mime ) { return mime != null && ( mime . equals ( lr_8 ) ||
if ( cTEnc . equals ( UTF_16 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_16 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR1Mutator]MSP[]
final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR2Mutator]MSP[] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
throw new IOException ( lr_6 + offset + lr_7 ) ; } final int bytesRead = offset ; if ( bytesRead > 0 ) { MST[rv.ROR2Mutator]MSP[] is . reset () ; final BufferedReader bReader = new BufferedReader ( new StringReader (
} final Matcher m = ENCODING_PATTERN . matcher ( prolog ) ; if ( m . find () ) { MST[rv.ROR4Mutator]MSP[] encoding = m . group ( 1 ) . toUpperCase ( Locale . ROOT ) ;
static String getContentTypeEncoding ( final String httpContentType ) { String encoding = null ; if ( httpContentType != null ) { final int i = httpContentType . indexOf ( lr_3 ) ; if ( i > - 1 ) { MST[rv.ROR5Mutator]MSP[]
final String cTEnc = getContentTypeEncoding ( httpContentType ) ; final boolean appXml = isAppXml ( cTMime ) ; final boolean textXml = isTextXml ( cTMime ) ; if ( ! appXml && ! textXml ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
} return xmlEnc ; } if ( bomEnc . equals ( UTF_8 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( UTF_8 ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
} return xmlEnc ; } if ( bomEnc . equals ( UTF_8 ) ) { if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( UTF_8 ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR4Mutator]MSP[]
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_16 ) && ! xmlEnc . equals ( bomEnc ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[InlineConstantMutator]MSP[]
} return xmlEnc ; } if ( bomEnc . equals ( UTF_8 ) ) { MST[rv.ROR3Mutator]MSP[] if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( UTF_8 ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
if ( cTEnc . equals ( UTF_32 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_32 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR4Mutator]MSP[]
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } if ( bomEnc . equals ( UTF_32BE ) || bomEnc . equals ( UTF_32LE ) ) { MST[NonVoidMethodCallMutator]MSP[] if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( bomEnc ) ) {
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { MST[rv.UOI3Mutator]MSP[] offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ;
if ( httpContentType != null && httpContentType . startsWith ( lr_1 ) ) { httpContentType = httpContentType . substring ( lr_1 . length () ) ; httpContentType = lr_2 + httpContentType ; MST[NonVoidMethodCallMutator]MSP[] try { return calculateHttpEncoding ( httpContentType , ex . getBomEncoding () ,
if ( guessedEnc != null ) { final byte [] bytes = new byte [ BUFFER_SIZE ] ; MST[rv.CRCR6Mutator]MSP[] is . mark ( BUFFER_SIZE ) ; int offset = 0 ; int max = BUFFER_SIZE ; int c = is . read ( bytes , offset , max ) ;
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { MST[rv.ROR5Mutator]MSP[] offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ;
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_16 ) && ! xmlEnc . equals ( bomEnc ) ) { MST[rv.ROR2Mutator]MSP[] final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
if ( xmlGuessEnc == null || xmlEnc == null ) { return defaultEncoding == null ? UTF_8 : defaultEncoding ; } if ( xmlEnc . equals ( UTF_16 ) && ( xmlGuessEnc . equals ( UTF_16BE ) || xmlGuessEnc . equals ( UTF_16LE ) ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return xmlGuessEnc ;
mime . equals ( lr_9 ) || mime . equals ( lr_10 ) || mime . startsWith ( lr_11 ) && mime . endsWith ( lr_12 ) ) ; MST[rv.ROR1Mutator]MSP[] } static boolean isTextXml ( final String mime ) { return mime != null &&
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR4Mutator]MSP[] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR3Mutator]MSP[] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
throw new IOException ( lr_6 + offset + lr_7 ) ; } final int bytesRead = offset ; if ( bytesRead > 0 ) { is . reset () ; final BufferedReader bReader = new BufferedReader ( new StringReader ( MST[rv.CRCR3Mutator]MSP[]
final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[InlineConstantMutator]MSP[] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
throw new IOException ( lr_6 + offset + lr_7 ) ; } final int bytesRead = offset ; if ( bytesRead > 0 ) { MST[rv.ROR5Mutator]MSP[] is . reset () ; final BufferedReader bReader = new BufferedReader ( new StringReader (
} return xmlEnc ; } if ( bomEnc . equals ( UTF_8 ) ) { if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( UTF_8 ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR1Mutator]MSP[]
} final Matcher m = ENCODING_PATTERN . matcher ( prolog ) ; if ( m . find () ) { MST[rv.ROR1Mutator]MSP[] encoding = m . group ( 1 ) . toUpperCase ( Locale . ROOT ) ;
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } if ( bomEnc . equals ( UTF_32BE ) || bomEnc . equals ( UTF_32LE ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( bomEnc ) ) {
} return xmlEnc ; } if ( bomEnc . equals ( UTF_8 ) ) { if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( UTF_8 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
final String postMime = httpContentType . substring ( i + 1 ) ; final Matcher m = CHARSET_PATTERN . matcher ( postMime ) ; encoding = m . find () ? m . group ( 1 ) : null ; MST[rv.CRCR6Mutator]MSP[]
if ( guessedEnc != null ) { final byte [] bytes = new byte [ BUFFER_SIZE ] ; is . mark ( BUFFER_SIZE ) ; int offset = 0 ; int max = BUFFER_SIZE ; int c = is . read ( bytes , offset , max ) ; MST[rv.UOI4Mutator]MSP[]
if ( xmlGuessEnc == null || xmlEnc == null ) { return defaultEncoding == null ? UTF_8 : defaultEncoding ; } if ( xmlEnc . equals ( UTF_16 ) && ( xmlGuessEnc . equals ( UTF_16BE ) || xmlGuessEnc . equals ( UTF_16LE ) ) ) { MST[rv.ROR3Mutator]MSP[] return xmlGuessEnc ;
encoding = encoding . substring ( 1 , encoding . length () - 1 ) ; MST[rv.AOR1Mutator]MSP[] } } } return encoding ; } static boolean isAppXml ( final String mime ) { return mime != null && ( mime . equals ( lr_8 ) ||
final String msg = MessageFormat . format ( HTTP_EX_3 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR5Mutator]MSP[] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( cTEnc == null ) {
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ;
final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR5Mutator]MSP[] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
String calculateHttpEncoding ( final String httpContentType , final String bomEnc , final String xmlGuessEnc , final String xmlEnc , final boolean lenient ) throws IOException { if ( lenient && xmlEnc != null ) { return xmlEnc ; } final String cTMime = getContentTypeMime ( httpContentType ) ; MST[NonVoidMethodCallMutator]MSP[]
final String msg = MessageFormat . format ( HTTP_EX_3 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR4Mutator]MSP[] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( cTEnc == null ) {
if ( httpContentType != null && httpContentType . startsWith ( lr_1 ) ) { MST[NonVoidMethodCallMutator]MSP[] httpContentType = httpContentType . substring ( lr_1 . length () ) ; httpContentType = lr_2 + httpContentType ; try { return calculateHttpEncoding ( httpContentType , ex . getBomEncoding () ,
ex . getXmlGuessEncoding () , ex . getXmlEncoding () , true ) ; MST[rv.CRCR6Mutator]MSP[] } catch ( final XmlStreamReaderException ex2 ) { ex = ex2 ; } } String encoding = ex . getXmlEncoding () ; if ( encoding == null ) { encoding = ex . getContentTypeEncoding () ; }
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { MST[NegateConditionalsMutator]MSP[] offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ;
throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( cTEnc . equals ( UTF_32BE ) || cTEnc . equals ( UTF_32LE ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] if ( bomEnc != null ) {
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR3Mutator]MSP[] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR2Mutator]MSP[] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR1Mutator]MSP[] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { MST[rv.ROR4Mutator]MSP[] offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ;
if ( cTEnc . equals ( UTF_16 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_16 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[InlineConstantMutator]MSP[]
if ( httpContentType != null && httpContentType . startsWith ( lr_1 ) ) { httpContentType = httpContentType . substring ( lr_1 . length () ) ; MST[experimental.NakedReceiverMutator]MSP[] httpContentType = lr_2 + httpContentType ; try { return calculateHttpEncoding ( httpContentType , ex . getBomEncoding () ,
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } if ( bomEnc . equals ( UTF_16BE ) || bomEnc . equals ( UTF_16LE ) ) { MST[NegateConditionalsMutator]MSP[] if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( bomEnc ) ) {
throw new IOException ( lr_6 + offset + lr_7 ) ; } final int bytesRead = offset ; if ( bytesRead > 0 ) { MST[NegateConditionalsMutator]MSP[] is . reset () ; final BufferedReader bReader = new BufferedReader ( new StringReader (
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR5Mutator]MSP[] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_32 ) && ! xmlEnc . equals ( bomEnc ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
( mime . equals ( lr_2 ) || mime . equals ( lr_13 ) || mime . startsWith ( lr_14 ) && mime . endsWith ( lr_12 ) ) ; MST[rv.ROR1Mutator]MSP[] }
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_32 ) && ! xmlEnc . equals ( bomEnc ) ) { MST[rv.ROR3Mutator]MSP[] final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
final String cTEnc = getContentTypeEncoding ( httpContentType ) ; final boolean appXml = isAppXml ( cTMime ) ; final boolean textXml = isTextXml ( cTMime ) ; if ( ! appXml && ! textXml ) { MST[NegateConditionalsMutator]MSP[]
final String bomEnc = bom . getBOMCharsetName () ; final String xmlGuessEnc = pis . getBOMCharsetName () ; MST[NonVoidMethodCallMutator]MSP[] final String xmlEnc = getXmlProlog ( pis , xmlGuessEnc ) ; try { return calculateRawEncoding ( bomEnc , xmlGuessEnc , xmlEnc ) ; } catch ( final XmlStreamReaderException ex ) {
final String postMime = httpContentType . substring ( i + 1 ) ; final Matcher m = CHARSET_PATTERN . matcher ( postMime ) ; encoding = m . find () ? m . group ( 1 ) : null ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ; MST[NonVoidMethodCallMutator]MSP[]
if ( xmlGuessEnc == null || xmlEnc == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return defaultEncoding == null ? UTF_8 : defaultEncoding ; } if ( xmlEnc . equals ( UTF_16 ) && ( xmlGuessEnc . equals ( UTF_16BE ) || xmlGuessEnc . equals ( UTF_16LE ) ) ) { return xmlGuessEnc ;
if ( lenient ) { MST[rv.UOI4Mutator]MSP[] return doLenientDetection ( null , ex ) ; } throw ex ; } } private String doHttpStream ( final BOMInputStream bom , final BOMInputStream pis , final String httpContentType , final boolean lenient ) throws IOException {
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_16 ) && ! xmlEnc . equals ( bomEnc ) ) { MST[rv.ROR5Mutator]MSP[] final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( xmlEnc != null && ! xmlEnc . equals ( UTF_8 ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR1Mutator]MSP[]
if ( guessedEnc != null ) { final byte [] bytes = new byte [ BUFFER_SIZE ] ; is . mark ( BUFFER_SIZE ) ; int offset = 0 ; int max = BUFFER_SIZE ; MST[rv.CRCR5Mutator]MSP[] int c = is . read ( bytes , offset , max ) ;
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_32 ) && ! xmlEnc . equals ( bomEnc ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR2Mutator]MSP[]
if ( xmlGuessEnc == null || xmlEnc == null ) { return defaultEncoding == null ? UTF_8 : defaultEncoding ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] } if ( xmlEnc . equals ( UTF_16 ) && ( xmlGuessEnc . equals ( UTF_16BE ) || xmlGuessEnc . equals ( UTF_16LE ) ) ) { return xmlGuessEnc ;
if ( cTEnc . equals ( UTF_32 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_32 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ;
} final Matcher m = ENCODING_PATTERN . matcher ( prolog ) ; if ( m . find () ) { encoding = m . group ( 1 ) . toUpperCase ( Locale . ROOT ) ; MST[rv.CRCR2Mutator]MSP[]
static String getContentTypeEncoding ( final String httpContentType ) { String encoding = null ; if ( httpContentType != null ) { final int i = httpContentType . indexOf ( lr_3 ) ; if ( i > - 1 ) { MST[rv.ROR2Mutator]MSP[]
if ( httpContentType != null && httpContentType . startsWith ( lr_1 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] httpContentType = httpContentType . substring ( lr_1 . length () ) ; httpContentType = lr_2 + httpContentType ; try { return calculateHttpEncoding ( httpContentType , ex . getBomEncoding () ,
if ( cTEnc . equals ( UTF_32 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_32 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR5Mutator]MSP[]
if ( cTEnc . equals ( UTF_32 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_32 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR1Mutator]MSP[]
mime . equals ( lr_9 ) || mime . equals ( lr_10 ) || mime . startsWith ( lr_11 ) && mime . endsWith ( lr_12 ) ) ; MST[rv.ROR4Mutator]MSP[] } static boolean isTextXml ( final String mime ) { return mime != null &&
final String bomEnc = bom . getBOMCharsetName () ; final String xmlGuessEnc = pis . getBOMCharsetName () ; final String xmlEnc = getXmlProlog ( pis , xmlGuessEnc ) ; try { return calculateHttpEncoding ( httpContentType , bomEnc , MST[rv.ABSMutator]MSP[] xmlGuessEnc , xmlEnc , lenient ) ;
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_16 ) && ! xmlEnc . equals ( bomEnc ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR4Mutator]MSP[]
final int i = httpContentType . indexOf ( lr_3 ) ; if ( i >= 0 ) { mime = httpContentType . substring ( 0 , i ) ; MST[rv.UOI1Mutator]MSP[] } else { mime = httpContentType ; } mime = mime . trim () ; } return mime ; }
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; MST[ReturnValsMutator]MSP[] } final String msg = MessageFormat . format ( RAW_EX_2 , bomEnc , xmlGuessEnc , xmlEnc ) ; throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
final String cTEnc = getContentTypeEncoding ( httpContentType ) ; final boolean appXml = isAppXml ( cTMime ) ; final boolean textXml = isTextXml ( cTMime ) ; if ( ! appXml && ! textXml ) { MST[rv.ROR5Mutator]MSP[]
throw new IOException ( lr_6 + offset + lr_7 ) ; } final int bytesRead = offset ; if ( bytesRead > 0 ) { is . reset () ; final BufferedReader bReader = new BufferedReader ( new StringReader ( MST[MathMutator]MSP[]
final String cTEnc = getContentTypeEncoding ( httpContentType ) ; final boolean appXml = isAppXml ( cTMime ) ; final boolean textXml = isTextXml ( cTMime ) ; if ( ! appXml && ! textXml ) { MST[rv.UOI2Mutator]MSP[]
encoding = encoding . substring ( 1 , encoding . length () - 1 ) ; } } } return encoding ; } static boolean isAppXml ( final String mime ) { return mime != null && MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] ( mime . equals ( lr_8 ) ||
} catch ( final XmlStreamReaderException ex ) { if ( lenient ) { MST[rv.ROR5Mutator]MSP[] return doLenientDetection ( httpContentType , ex ) ; } throw ex ; } } private String doLenientDetection ( String httpContentType , XmlStreamReaderException ex ) throws IOException {
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_16 ) && ! xmlEnc . equals ( bomEnc ) ) { MST[NegateConditionalsMutator]MSP[] final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } if ( bomEnc . equals ( UTF_32BE ) || bomEnc . equals ( UTF_32LE ) ) { if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( bomEnc ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_32 ) && ! xmlEnc . equals ( bomEnc ) ) { MST[NonVoidMethodCallMutator]MSP[] final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
encoding = encoding . substring ( 1 , encoding . length () - 1 ) ; MST[rv.AOD2Mutator]MSP[] } } } return encoding ; } static boolean isAppXml ( final String mime ) { return mime != null && ( mime . equals ( lr_8 ) ||
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_16 ) && ! xmlEnc . equals ( bomEnc ) ) { MST[NegateConditionalsMutator]MSP[] final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
} catch ( final XmlStreamReaderException ex ) { if ( lenient ) { MST[NegateConditionalsMutator]MSP[] return doLenientDetection ( httpContentType , ex ) ; } throw ex ; } } private String doLenientDetection ( String httpContentType , XmlStreamReaderException ex ) throws IOException {
if ( encoding == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] encoding = defaultEncoding == null ? UTF_8 : defaultEncoding ; } return encoding ; } String calculateRawEncoding ( final String bomEnc , final String xmlGuessEnc , final String xmlEnc ) throws IOException { if ( bomEnc == null ) {
if ( cTEnc . equals ( UTF_16 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_16 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR4Mutator]MSP[]
encoding = encoding . substring ( 1 , encoding . length () - 1 ) ; MST[rv.CRCR6Mutator]MSP[] } } } return encoding ; } static boolean isAppXml ( final String mime ) { return mime != null && ( mime . equals ( lr_8 ) ||
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; MST[EmptyObjectReturnValsMutator]MSP[] } final String msg = MessageFormat . format ( RAW_EX_2 , bomEnc , xmlGuessEnc , xmlEnc ) ; throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { MST[rv.CRCR3Mutator]MSP[] offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ;
if ( xmlGuessEnc == null || xmlEnc == null ) { return defaultEncoding == null ? UTF_8 : defaultEncoding ; } if ( xmlEnc . equals ( UTF_16 ) && MST[rv.ROR4Mutator]MSP[] ( xmlGuessEnc . equals ( UTF_16BE ) || xmlGuessEnc . equals ( UTF_16LE ) ) ) { return xmlGuessEnc ;
mime . equals ( lr_9 ) || mime . equals ( lr_10 ) || mime . startsWith ( lr_11 ) && mime . endsWith ( lr_12 ) ) ; MST[rv.CRCR6Mutator]MSP[] } static boolean isTextXml ( final String mime ) { return mime != null &&
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR1Mutator]MSP[] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
throw new IOException ( lr_6 + offset + lr_7 ) ; } final int bytesRead = offset ; if ( bytesRead > 0 ) { MST[rv.UOI1Mutator]MSP[] is . reset () ; final BufferedReader bReader = new BufferedReader ( new StringReader (
static String getContentTypeEncoding ( final String httpContentType ) { String encoding = null ; if ( httpContentType != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] final int i = httpContentType . indexOf ( lr_3 ) ; if ( i > - 1 ) {
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } if ( bomEnc . equals ( UTF_32BE ) || bomEnc . equals ( UTF_32LE ) ) { MST[rv.ROR3Mutator]MSP[] if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( bomEnc ) ) {
if ( cTEnc . equals ( UTF_32 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_32 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[ArgumentPropagationMutator]MSP[]
final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[InlineConstantMutator]MSP[] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
} final Matcher m = ENCODING_PATTERN . matcher ( prolog ) ; if ( m . find () ) { encoding = m . group ( 1 ) . toUpperCase ( Locale . ROOT ) ; MST[NonVoidMethodCallMutator]MSP[]
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_16 ) && ! xmlEnc . equals ( bomEnc ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[InlineConstantMutator]MSP[]
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_16 ) && ! xmlEnc . equals ( bomEnc ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR6Mutator]MSP[]
mime . equals ( lr_9 ) || mime . equals ( lr_10 ) || mime . startsWith ( lr_11 ) && mime . endsWith ( lr_12 ) ) ; } static boolean isTextXml ( final String mime ) { return mime != null && MST[rv.ROR5Mutator]MSP[]
xmlProlog = new String ( bytes , 0 , offset , guessedEnc ) ; firstGT = xmlProlog . indexOf ( '>' ) ; } if ( firstGT == - 1 ) { MST[rv.ROR2Mutator]MSP[] if ( c == - 1 ) { throw new IOException ( lr_5 ) ; }
final String msg = MessageFormat . format ( HTTP_EX_3 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR2Mutator]MSP[] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( cTEnc == null ) {
xmlProlog = new String ( bytes , 0 , offset , guessedEnc ) ; firstGT = xmlProlog . indexOf ( '>' ) ; } if ( firstGT == - 1 ) { MST[rv.CRCR6Mutator]MSP[] if ( c == - 1 ) { throw new IOException ( lr_5 ) ; }
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { MST[InlineConstantMutator]MSP[] offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ;
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[InlineConstantMutator]MSP[] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } if ( bomEnc . equals ( UTF_32BE ) || bomEnc . equals ( UTF_32LE ) ) { MST[NonVoidMethodCallMutator]MSP[] if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( bomEnc ) ) {
final String msg = MessageFormat . format ( HTTP_EX_3 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR6Mutator]MSP[] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( cTEnc == null ) {
throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; } static String getContentTypeMime ( final String httpContentType ) { String mime = null ; if ( httpContentType != null ) { MST[NegateConditionalsMutator]MSP[]
if ( cTEnc . equals ( UTF_16 ) ) { MST[rv.ROR2Mutator]MSP[] if ( bomEnc != null && bomEnc . startsWith ( UTF_16 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ;
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } if ( bomEnc . equals ( UTF_16BE ) || bomEnc . equals ( UTF_16LE ) ) { MST[rv.ROR5Mutator]MSP[] if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( bomEnc ) ) {
} return xmlEnc ; } if ( bomEnc . equals ( UTF_8 ) ) { if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( UTF_8 ) ) { MST[NonVoidMethodCallMutator]MSP[] final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
if ( xmlGuessEnc == null || xmlEnc == null ) { return defaultEncoding == null ? UTF_8 : defaultEncoding ; } if ( xmlEnc . equals ( UTF_16 ) && ( xmlGuessEnc . equals ( UTF_16BE ) || xmlGuessEnc . equals ( UTF_16LE ) ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return xmlGuessEnc ;
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR4Mutator]MSP[] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
throw new IOException ( lr_6 + offset + lr_7 ) ; } final int bytesRead = offset ; if ( bytesRead > 0 ) { is . reset () ; final BufferedReader bReader = new BufferedReader ( new StringReader ( MST[rv.CRCR2Mutator]MSP[]
mime . equals ( lr_9 ) || MST[NonVoidMethodCallMutator]MSP[] mime . equals ( lr_10 ) || mime . startsWith ( lr_11 ) && mime . endsWith ( lr_12 ) ) ; } static boolean isTextXml ( final String mime ) { return mime != null &&
} return xmlEnc ; } if ( bomEnc . equals ( UTF_8 ) ) { if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( UTF_8 ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR2Mutator]MSP[]
if ( cTEnc . equals ( UTF_16 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_16 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR1Mutator]MSP[]
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } if ( bomEnc . equals ( UTF_32BE ) || bomEnc . equals ( UTF_32LE ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( bomEnc ) ) {
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } final String msg = MessageFormat . format ( RAW_EX_2 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR5Mutator]MSP[] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
if ( appXml ) { return calculateRawEncoding ( bomEnc , xmlGuessEnc , xmlEnc ) ; } return defaultEncoding == null ? US_ASCII : defaultEncoding ; MST[NegateConditionalsMutator]MSP[] } if ( cTEnc . equals ( UTF_16BE ) || cTEnc . equals ( UTF_16LE ) ) { if ( bomEnc != null ) {
} return xmlEnc ; } if ( bomEnc . equals ( UTF_8 ) ) { if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( UTF_8 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
final String postMime = httpContentType . substring ( i + 1 ) ; MST[rv.CRCR2Mutator]MSP[] final Matcher m = CHARSET_PATTERN . matcher ( postMime ) ; encoding = m . find () ? m . group ( 1 ) : null ;
final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR5Mutator]MSP[] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { offset += c ; max -= c ; MST[rv.AOR2Mutator]MSP[] c = is . read ( bytes , offset , max ) ;
final String bomEnc = bom . getBOMCharsetName () ; final String xmlGuessEnc = pis . getBOMCharsetName () ; final String xmlEnc = getXmlProlog ( pis , xmlGuessEnc ) ; MST[NonVoidMethodCallMutator]MSP[] try { return calculateHttpEncoding ( httpContentType , bomEnc , xmlGuessEnc , xmlEnc , lenient ) ;
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_32 ) && ! xmlEnc . equals ( bomEnc ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
} return xmlEnc ; } if ( bomEnc . equals ( UTF_8 ) ) { if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( UTF_8 ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[InlineConstantMutator]MSP[]
if ( cTEnc . equals ( UTF_16 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_16 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[ArgumentPropagationMutator]MSP[]
throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( cTEnc . equals ( UTF_32BE ) || cTEnc . equals ( UTF_32LE ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] if ( bomEnc != null ) {
String calculateHttpEncoding ( final String httpContentType , final String bomEnc , final String xmlGuessEnc , final String xmlEnc , final boolean lenient ) throws IOException { if ( lenient && xmlEnc != null ) { MST[rv.UOI1Mutator]MSP[] return xmlEnc ; } final String cTMime = getContentTypeMime ( httpContentType ) ;
throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( cTEnc . equals ( UTF_32BE ) || cTEnc . equals ( UTF_32LE ) ) { if ( bomEnc != null ) { MST[rv.ROR5Mutator]MSP[]
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR4Mutator]MSP[] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
if ( cTEnc . equals ( UTF_32 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_32 ) ) { MST[NonVoidMethodCallMutator]MSP[] return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ;
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR1Mutator]MSP[] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { MST[rv.CRCR2Mutator]MSP[] offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ;
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { MST[rv.CRCR1Mutator]MSP[] offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ;
return reader . read ( buf , offset , len ) ; MST[rv.ABSMutator]MSP[] } @Override public void close () throws IOException { reader . close () ; } private String doRawStream ( final BOMInputStream bom , final BOMInputStream pis , final boolean lenient ) throws IOException {
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ; MST[rv.UOI3Mutator]MSP[]
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } if ( bomEnc . equals ( UTF_16BE ) || bomEnc . equals ( UTF_16LE ) ) { if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( bomEnc ) ) { MST[rv.ROR5Mutator]MSP[]
static String getContentTypeEncoding ( final String httpContentType ) { String encoding = null ; if ( httpContentType != null ) { final int i = httpContentType . indexOf ( lr_3 ) ; if ( i > - 1 ) { MST[InlineConstantMutator]MSP[]
static String getContentTypeEncoding ( final String httpContentType ) { String encoding = null ; if ( httpContentType != null ) { final int i = httpContentType . indexOf ( lr_3 ) ; if ( i > - 1 ) { MST[rv.ABSMutator]MSP[]
xmlProlog = new String ( bytes , 0 , offset , guessedEnc ) ; firstGT = xmlProlog . indexOf ( '>' ) ; } if ( firstGT == - 1 ) { MST[rv.UOI1Mutator]MSP[] if ( c == - 1 ) { throw new IOException ( lr_5 ) ; }
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { MST[rv.CRCR5Mutator]MSP[] offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ;
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { MST[rv.CRCR6Mutator]MSP[] offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ;
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( xmlEnc != null && ! xmlEnc . equals ( UTF_8 ) ) { MST[NonVoidMethodCallMutator]MSP[] final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
final String msg = MessageFormat . format ( HTTP_EX_3 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( cTEnc == null ) { MST[rv.ROR5Mutator]MSP[]
encoding = encoding . substring ( 1 , encoding . length () - 1 ) ; } } } return encoding ; } static boolean isAppXml ( final String mime ) { return mime != null && ( mime . equals ( lr_8 ) || MST[rv.ROR1Mutator]MSP[]
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( xmlEnc != null && ! xmlEnc . equals ( UTF_8 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
static String getContentTypeEncoding ( final String httpContentType ) { String encoding = null ; if ( httpContentType != null ) { final int i = httpContentType . indexOf ( lr_3 ) ; if ( i > - 1 ) { MST[rv.CRCR6Mutator]MSP[]
mime . equals ( lr_9 ) || MST[rv.ROR3Mutator]MSP[] mime . equals ( lr_10 ) || mime . startsWith ( lr_11 ) && mime . endsWith ( lr_12 ) ) ; } static boolean isTextXml ( final String mime ) { return mime != null &&
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_16 ) && ! xmlEnc . equals ( bomEnc ) ) { MST[rv.ROR5Mutator]MSP[] final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
if ( cTEnc . equals ( UTF_32 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_32 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ;
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_32 ) && ! xmlEnc . equals ( bomEnc ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR6Mutator]MSP[]
if ( appXml ) { return calculateRawEncoding ( bomEnc , xmlGuessEnc , xmlEnc ) ; } return defaultEncoding == null ? US_ASCII : defaultEncoding ; } if ( cTEnc . equals ( UTF_16BE ) || cTEnc . equals ( UTF_16LE ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] if ( bomEnc != null ) {
throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( cTEnc . equals ( UTF_32BE ) || cTEnc . equals ( UTF_32LE ) ) { MST[NonVoidMethodCallMutator]MSP[] if ( bomEnc != null ) {
if ( cTEnc . equals ( UTF_32 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_32 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR1Mutator]MSP[]
throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( cTEnc . equals ( UTF_32BE ) || cTEnc . equals ( UTF_32LE ) ) { if ( bomEnc != null ) { MST[NegateConditionalsMutator]MSP[]
if ( guessedEnc != null ) { MST[NegateConditionalsMutator]MSP[] final byte [] bytes = new byte [ BUFFER_SIZE ] ; is . mark ( BUFFER_SIZE ) ; int offset = 0 ; int max = BUFFER_SIZE ; int c = is . read ( bytes , offset , max ) ;
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } if ( bomEnc . equals ( UTF_16BE ) || bomEnc . equals ( UTF_16LE ) ) { MST[rv.ROR2Mutator]MSP[] if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( bomEnc ) ) {
xmlProlog = new String ( bytes , 0 , offset , guessedEnc ) ; firstGT = xmlProlog . indexOf ( '>' ) ; MST[rv.CRCR3Mutator]MSP[] } if ( firstGT == - 1 ) { if ( c == - 1 ) { throw new IOException ( lr_5 ) ; }
final String msg = MessageFormat . format ( HTTP_EX_3 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[ConstructorCallMutator]MSP[] } if ( cTEnc == null ) {
final int i = httpContentType . indexOf ( lr_3 ) ; if ( i >= 0 ) { MST[rv.UOI3Mutator]MSP[] mime = httpContentType . substring ( 0 , i ) ; } else { mime = httpContentType ; } mime = mime . trim () ; } return mime ; }
final int i = httpContentType . indexOf ( lr_3 ) ; if ( i >= 0 ) { MST[rv.ROR4Mutator]MSP[] mime = httpContentType . substring ( 0 , i ) ; } else { mime = httpContentType ; } mime = mime . trim () ; } return mime ; }
throw new IOException ( lr_6 + offset + lr_7 ) ; } final int bytesRead = offset ; if ( bytesRead > 0 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] is . reset () ; final BufferedReader bReader = new BufferedReader ( new StringReader (
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_16 ) && ! xmlEnc . equals ( bomEnc ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[NonVoidMethodCallMutator]MSP[]
if ( cTEnc . equals ( UTF_32 ) ) { MST[rv.ROR2Mutator]MSP[] if ( bomEnc != null && bomEnc . startsWith ( UTF_32 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ;
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ;
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_16 ) && ! xmlEnc . equals ( bomEnc ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR3Mutator]MSP[]
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( xmlEnc != null && ! xmlEnc . equals ( UTF_8 ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR6Mutator]MSP[]
if ( appXml ) { return calculateRawEncoding ( bomEnc , xmlGuessEnc , xmlEnc ) ; MST[EmptyObjectReturnValsMutator]MSP[] } return defaultEncoding == null ? US_ASCII : defaultEncoding ; } if ( cTEnc . equals ( UTF_16BE ) || cTEnc . equals ( UTF_16LE ) ) { if ( bomEnc != null ) {
if ( appXml ) { return calculateRawEncoding ( bomEnc , xmlGuessEnc , xmlEnc ) ; } return defaultEncoding == null ? US_ASCII : defaultEncoding ; } if ( cTEnc . equals ( UTF_16BE ) || cTEnc . equals ( UTF_16LE ) ) { MST[rv.ROR5Mutator]MSP[] if ( bomEnc != null ) {
throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; } static String getContentTypeMime ( final String httpContentType ) { String mime = null ; if ( httpContentType != null ) { MST[rv.ROR5Mutator]MSP[]
if ( cTEnc . equals ( UTF_16 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_16 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ;
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { offset += c ; MST[rv.UOI4Mutator]MSP[] max -= c ; c = is . read ( bytes , offset , max ) ;
if ( appXml ) { return calculateRawEncoding ( bomEnc , xmlGuessEnc , xmlEnc ) ; } return defaultEncoding == null ? US_ASCII : defaultEncoding ; } if ( cTEnc . equals ( UTF_16BE ) || cTEnc . equals ( UTF_16LE ) ) { MST[rv.ROR2Mutator]MSP[] if ( bomEnc != null ) {
} return xmlEnc ; } if ( bomEnc . equals ( UTF_8 ) ) { if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( UTF_8 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
if ( cTEnc . equals ( UTF_16 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_16 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR4Mutator]MSP[]
String calculateHttpEncoding ( final String httpContentType , final String bomEnc , final String xmlGuessEnc , final String xmlEnc , final boolean lenient ) throws IOException { if ( lenient && xmlEnc != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return xmlEnc ; } final String cTMime = getContentTypeMime ( httpContentType ) ;
final String postMime = httpContentType . substring ( i + 1 ) ; MST[MathMutator]MSP[] final Matcher m = CHARSET_PATTERN . matcher ( postMime ) ; encoding = m . find () ? m . group ( 1 ) : null ;
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR1Mutator]MSP[] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
if ( cTEnc . equals ( UTF_32 ) ) { MST[rv.ROR5Mutator]MSP[] if ( bomEnc != null && bomEnc . startsWith ( UTF_32 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ;
if ( cTEnc . equals ( UTF_16 ) ) { MST[NegateConditionalsMutator]MSP[] if ( bomEnc != null && bomEnc . startsWith ( UTF_16 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ;
final String cTEnc = getContentTypeEncoding ( httpContentType ) ; final boolean appXml = isAppXml ( cTMime ) ; final boolean textXml = isTextXml ( cTMime ) ; if ( ! appXml && ! textXml ) { MST[rv.ABSMutator]MSP[]
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } final String msg = MessageFormat . format ( RAW_EX_2 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR2Mutator]MSP[] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
if ( appXml ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return calculateRawEncoding ( bomEnc , xmlGuessEnc , xmlEnc ) ; } return defaultEncoding == null ? US_ASCII : defaultEncoding ; } if ( cTEnc . equals ( UTF_16BE ) || cTEnc . equals ( UTF_16LE ) ) { if ( bomEnc != null ) {
final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR1Mutator]MSP[] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } if ( bomEnc . equals ( UTF_32BE ) || bomEnc . equals ( UTF_32LE ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( bomEnc ) ) {
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ;
encoding = encoding . substring ( 1 , encoding . length () - 1 ) ; } } } return encoding ; MST[EmptyObjectReturnValsMutator]MSP[] } static boolean isAppXml ( final String mime ) { return mime != null && ( mime . equals ( lr_8 ) ||
ex . getXmlGuessEncoding () , ex . getXmlEncoding () , true ) ; MST[rv.CRCR3Mutator]MSP[] } catch ( final XmlStreamReaderException ex2 ) { ex = ex2 ; } } String encoding = ex . getXmlEncoding () ; if ( encoding == null ) { encoding = ex . getContentTypeEncoding () ; }
final String msg = MessageFormat . format ( HTTP_EX_3 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR5Mutator]MSP[] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( cTEnc == null ) {
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { MST[ConditionalsBoundaryMutator]MSP[] offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ;
final String msg = MessageFormat . format ( HTTP_EX_3 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR2Mutator]MSP[] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( cTEnc == null ) {
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_16 ) && ! xmlEnc . equals ( bomEnc ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[InlineConstantMutator]MSP[]
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[ArgumentPropagationMutator]MSP[] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { MST[rv.ROR3Mutator]MSP[] offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ;
if ( cTEnc . equals ( UTF_32 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_32 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR4Mutator]MSP[]
if ( cTEnc . equals ( UTF_16 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_16 ) ) { MST[rv.ROR5Mutator]MSP[] return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ;
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } if ( bomEnc . equals ( UTF_16BE ) || bomEnc . equals ( UTF_16LE ) ) { if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( bomEnc ) ) { MST[NegateConditionalsMutator]MSP[]
( mime . equals ( lr_2 ) || mime . equals ( lr_13 ) || mime . startsWith ( lr_14 ) && mime . endsWith ( lr_12 ) ) ; MST[rv.ROR5Mutator]MSP[] }
throw new IOException ( lr_6 + offset + lr_7 ) ; } final int bytesRead = offset ; if ( bytesRead > 0 ) { MST[ConditionalsBoundaryMutator]MSP[] is . reset () ; final BufferedReader bReader = new BufferedReader ( new StringReader (
final int i = httpContentType . indexOf ( lr_3 ) ; MST[NonVoidMethodCallMutator]MSP[] if ( i >= 0 ) { mime = httpContentType . substring ( 0 , i ) ; } else { mime = httpContentType ; } mime = mime . trim () ; } return mime ; }
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; MST[EmptyObjectReturnValsMutator]MSP[] } if ( bomEnc . equals ( UTF_16BE ) || bomEnc . equals ( UTF_16LE ) ) { if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( bomEnc ) ) {
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } if ( bomEnc . equals ( UTF_16BE ) || bomEnc . equals ( UTF_16LE ) ) { MST[rv.ROR5Mutator]MSP[] if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( bomEnc ) ) {
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR4Mutator]MSP[] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
if ( cTEnc . equals ( UTF_16 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_16 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR1Mutator]MSP[]
throw new IOException ( lr_6 + offset + lr_7 ) ; } final int bytesRead = offset ; if ( bytesRead > 0 ) { is . reset () ; final BufferedReader bReader = new BufferedReader ( new StringReader ( MST[InlineConstantMutator]MSP[]
final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[ConstructorCallMutator]MSP[] }
return reader . read ( buf , offset , len ) ; MST[rv.UOI1Mutator]MSP[] } @Override public void close () throws IOException { reader . close () ; } private String doRawStream ( final BOMInputStream bom , final BOMInputStream pis , final boolean lenient ) throws IOException {
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } final String msg = MessageFormat . format ( RAW_EX_2 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR5Mutator]MSP[] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR5Mutator]MSP[] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR4Mutator]MSP[] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
throw new IOException ( lr_6 + offset + lr_7 ) ; } final int bytesRead = offset ; if ( bytesRead > 0 ) { is . reset () ; final BufferedReader bReader = new BufferedReader ( new StringReader ( MST[rv.AOR2Mutator]MSP[]
if ( appXml ) { MST[rv.UOI1Mutator]MSP[] return calculateRawEncoding ( bomEnc , xmlGuessEnc , xmlEnc ) ; } return defaultEncoding == null ? US_ASCII : defaultEncoding ; } if ( cTEnc . equals ( UTF_16BE ) || cTEnc . equals ( UTF_16LE ) ) { if ( bomEnc != null ) {
if ( guessedEnc != null ) { final byte [] bytes = new byte [ BUFFER_SIZE ] ; is . mark ( BUFFER_SIZE ) ; int offset = 0 ; int max = BUFFER_SIZE ; int c = is . read ( bytes , offset , max ) ; MST[rv.ABSMutator]MSP[]
if ( guessedEnc != null ) { final byte [] bytes = new byte [ BUFFER_SIZE ] ; is . mark ( BUFFER_SIZE ) ; int offset = 0 ; int max = BUFFER_SIZE ; int c = is . read ( bytes , offset , max ) ; MST[rv.UOI1Mutator]MSP[]
static String getContentTypeEncoding ( final String httpContentType ) { String encoding = null ; if ( httpContentType != null ) { final int i = httpContentType . indexOf ( lr_3 ) ; if ( i > - 1 ) { MST[ConditionalsBoundaryMutator]MSP[]
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_32 ) && ! xmlEnc . equals ( bomEnc ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR4Mutator]MSP[] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[ArgumentPropagationMutator]MSP[] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
String calculateHttpEncoding ( final String httpContentType , final String bomEnc , final String xmlGuessEnc , final String xmlEnc , final boolean lenient ) throws IOException { if ( lenient && xmlEnc != null ) { MST[rv.UOI4Mutator]MSP[] return xmlEnc ; } final String cTMime = getContentTypeMime ( httpContentType ) ;
if ( cTEnc . equals ( UTF_32 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_32 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR6Mutator]MSP[]
if ( appXml ) { return calculateRawEncoding ( bomEnc , xmlGuessEnc , xmlEnc ) ; } return defaultEncoding == null ? US_ASCII : defaultEncoding ; } if ( cTEnc . equals ( UTF_16BE ) || cTEnc . equals ( UTF_16LE ) ) { if ( bomEnc != null ) { MST[NegateConditionalsMutator]MSP[]
final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR6Mutator]MSP[] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR1Mutator]MSP[] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
xmlProlog . substring ( 0 , firstGT + 1 ) ) ) ; MST[experimental.NakedReceiverMutator]MSP[] final StringBuffer prolog = new StringBuffer () ; String line = bReader . readLine () ; while ( line != null ) { prolog . append ( line ) ; line = bReader . readLine () ;
encoding = encoding . substring ( 1 , encoding . length () - 1 ) ; } } } return encoding ; } static boolean isAppXml ( final String mime ) { return mime != null && MST[RemoveConditionalMutator_EQUAL_IF]MSP[] ( mime . equals ( lr_8 ) ||
final int i = httpContentType . indexOf ( lr_3 ) ; if ( i >= 0 ) { MST[rv.ABSMutator]MSP[] mime = httpContentType . substring ( 0 , i ) ; } else { mime = httpContentType ; } mime = mime . trim () ; } return mime ; }
throw new IOException ( lr_6 + offset + lr_7 ) ; } final int bytesRead = offset ; if ( bytesRead > 0 ) { is . reset () ; final BufferedReader bReader = new BufferedReader ( new StringReader ( MST[rv.UOI3Mutator]MSP[]
encoding = encoding . substring ( 1 , encoding . length () - 1 ) ; MST[InlineConstantMutator]MSP[] } } } return encoding ; } static boolean isAppXml ( final String mime ) { return mime != null && ( mime . equals ( lr_8 ) ||
throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( cTEnc . equals ( UTF_32BE ) || cTEnc . equals ( UTF_32LE ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] if ( bomEnc != null ) {
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } if ( bomEnc . equals ( UTF_16BE ) || bomEnc . equals ( UTF_16LE ) ) { if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( bomEnc ) ) { MST[rv.ROR5Mutator]MSP[]
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_16 ) && ! xmlEnc . equals ( bomEnc ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR1Mutator]MSP[]
static String getContentTypeEncoding ( final String httpContentType ) { String encoding = null ; if ( httpContentType != null ) { final int i = httpContentType . indexOf ( lr_3 ) ; if ( i > - 1 ) { MST[rv.UOI1Mutator]MSP[]
if ( xmlGuessEnc == null || xmlEnc == null ) { return defaultEncoding == null ? UTF_8 : defaultEncoding ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] } if ( xmlEnc . equals ( UTF_16 ) && ( xmlGuessEnc . equals ( UTF_16BE ) || xmlGuessEnc . equals ( UTF_16LE ) ) ) { return xmlGuessEnc ;
final int i = httpContentType . indexOf ( lr_3 ) ; if ( i >= 0 ) { mime = httpContentType . substring ( 0 , i ) ; MST[rv.CRCR5Mutator]MSP[] } else { mime = httpContentType ; } mime = mime . trim () ; } return mime ; }
if ( appXml ) { MST[rv.UOI4Mutator]MSP[] return calculateRawEncoding ( bomEnc , xmlGuessEnc , xmlEnc ) ; } return defaultEncoding == null ? US_ASCII : defaultEncoding ; } if ( cTEnc . equals ( UTF_16BE ) || cTEnc . equals ( UTF_16LE ) ) { if ( bomEnc != null ) {
( mime . equals ( lr_2 ) || mime . equals ( lr_13 ) || mime . startsWith ( lr_14 ) && mime . endsWith ( lr_12 ) ) ; MST[rv.CRCR3Mutator]MSP[] }
if ( lenient ) { MST[rv.ROR5Mutator]MSP[] return doLenientDetection ( null , ex ) ; } throw ex ; } } private String doHttpStream ( final BOMInputStream bom , final BOMInputStream pis , final String httpContentType , final boolean lenient ) throws IOException {
if ( cTEnc . equals ( UTF_32 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] if ( bomEnc != null && bomEnc . startsWith ( UTF_32 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ;
if ( xmlGuessEnc == null || xmlEnc == null ) { MST[rv.ROR5Mutator]MSP[] return defaultEncoding == null ? UTF_8 : defaultEncoding ; } if ( xmlEnc . equals ( UTF_16 ) && ( xmlGuessEnc . equals ( UTF_16BE ) || xmlGuessEnc . equals ( UTF_16LE ) ) ) { return xmlGuessEnc ;
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_32 ) && ! xmlEnc . equals ( bomEnc ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR6Mutator]MSP[]
if ( appXml ) { return calculateRawEncoding ( bomEnc , xmlGuessEnc , xmlEnc ) ; } return defaultEncoding == null ? US_ASCII : defaultEncoding ; } if ( cTEnc . equals ( UTF_16BE ) || cTEnc . equals ( UTF_16LE ) ) { if ( bomEnc != null ) { MST[rv.ROR5Mutator]MSP[]
if ( guessedEnc != null ) { final byte [] bytes = new byte [ BUFFER_SIZE ] ; MST[rv.CRCR3Mutator]MSP[] is . mark ( BUFFER_SIZE ) ; int offset = 0 ; int max = BUFFER_SIZE ; int c = is . read ( bytes , offset , max ) ;
( mime . equals ( lr_2 ) || MST[RemoveConditionalMutator_EQUAL_IF]MSP[] mime . equals ( lr_13 ) || mime . startsWith ( lr_14 ) && mime . endsWith ( lr_12 ) ) ; }
int firstGT = - 1 ; MST[rv.CRCR6Mutator]MSP[] String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ;
if ( appXml ) { return calculateRawEncoding ( bomEnc , xmlGuessEnc , xmlEnc ) ; } return defaultEncoding == null ? US_ASCII : defaultEncoding ; } if ( cTEnc . equals ( UTF_16BE ) || cTEnc . equals ( UTF_16LE ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] if ( bomEnc != null ) {
static String getContentTypeEncoding ( final String httpContentType ) { String encoding = null ; if ( httpContentType != null ) { final int i = httpContentType . indexOf ( lr_3 ) ; if ( i > - 1 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[]
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { offset += c ; max -= c ; MST[rv.UOI2Mutator]MSP[] c = is . read ( bytes , offset , max ) ;
xmlProlog = new String ( bytes , 0 , offset , guessedEnc ) ; firstGT = xmlProlog . indexOf ( '>' ) ; } if ( firstGT == - 1 ) { MST[InlineConstantMutator]MSP[] if ( c == - 1 ) { throw new IOException ( lr_5 ) ; }
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } if ( bomEnc . equals ( UTF_16BE ) || bomEnc . equals ( UTF_16LE ) ) { MST[rv.ROR2Mutator]MSP[] if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( bomEnc ) ) {
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( xmlEnc != null && ! xmlEnc . equals ( UTF_8 ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR5Mutator]MSP[]
if ( guessedEnc != null ) { final byte [] bytes = new byte [ BUFFER_SIZE ] ; is . mark ( BUFFER_SIZE ) ; MST[rv.CRCR5Mutator]MSP[] int offset = 0 ; int max = BUFFER_SIZE ; int c = is . read ( bytes , offset , max ) ;
throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( cTEnc . equals ( UTF_32BE ) || cTEnc . equals ( UTF_32LE ) ) { MST[rv.ROR2Mutator]MSP[] if ( bomEnc != null ) {
encoding = encoding . substring ( 1 , encoding . length () - 1 ) ; MST[rv.CRCR2Mutator]MSP[] } } } return encoding ; } static boolean isAppXml ( final String mime ) { return mime != null && ( mime . equals ( lr_8 ) ||
if ( cTEnc . equals ( UTF_32 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_32 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR1Mutator]MSP[]
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( xmlEnc != null && ! xmlEnc . equals ( UTF_8 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
mime . equals ( lr_9 ) || mime . equals ( lr_10 ) || MST[rv.ROR5Mutator]MSP[] mime . startsWith ( lr_11 ) && mime . endsWith ( lr_12 ) ) ; } static boolean isTextXml ( final String mime ) { return mime != null &&
if ( cTEnc . equals ( UTF_32 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_32 ) ) { return bomEnc ; MST[EmptyObjectReturnValsMutator]MSP[] } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ;
final String postMime = httpContentType . substring ( i + 1 ) ; final Matcher m = CHARSET_PATTERN . matcher ( postMime ) ; encoding = m . find () ? m . group ( 1 ) : null ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
xmlProlog = new String ( bytes , 0 , offset , guessedEnc ) ; MST[rv.UOI2Mutator]MSP[] firstGT = xmlProlog . indexOf ( '>' ) ; } if ( firstGT == - 1 ) { if ( c == - 1 ) { throw new IOException ( lr_5 ) ; }
final String cTEnc = getContentTypeEncoding ( httpContentType ) ; final boolean appXml = isAppXml ( cTMime ) ; final boolean textXml = isTextXml ( cTMime ) ; if ( ! appXml && ! textXml ) { MST[rv.ROR1Mutator]MSP[]
if ( cTEnc . equals ( UTF_32 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_32 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ;
final String cTEnc = getContentTypeEncoding ( httpContentType ) ; final boolean appXml = isAppXml ( cTMime ) ; final boolean textXml = isTextXml ( cTMime ) ; if ( ! appXml && ! textXml ) { MST[rv.ROR3Mutator]MSP[]
( mime . equals ( lr_2 ) || MST[NonVoidMethodCallMutator]MSP[] mime . equals ( lr_13 ) || mime . startsWith ( lr_14 ) && mime . endsWith ( lr_12 ) ) ; }
encoding = encoding != null ? encoding . toUpperCase ( Locale . ROOT ) : null ; MST[NonVoidMethodCallMutator]MSP[] } } return encoding ; } private static String getXmlProlog ( final InputStream is , final String guessedEnc ) throws IOException { String encoding = null ;
mime . equals ( lr_9 ) || mime . equals ( lr_10 ) || MST[NegateConditionalsMutator]MSP[] mime . startsWith ( lr_11 ) && mime . endsWith ( lr_12 ) ) ; } static boolean isTextXml ( final String mime ) { return mime != null &&
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( xmlEnc != null && ! xmlEnc . equals ( UTF_8 ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR6Mutator]MSP[]
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( xmlEnc != null && ! xmlEnc . equals ( UTF_8 ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR3Mutator]MSP[]
if ( xmlGuessEnc == null || xmlEnc == null ) { MST[NegateConditionalsMutator]MSP[] return defaultEncoding == null ? UTF_8 : defaultEncoding ; } if ( xmlEnc . equals ( UTF_16 ) && ( xmlGuessEnc . equals ( UTF_16BE ) || xmlGuessEnc . equals ( UTF_16LE ) ) ) { return xmlGuessEnc ;
throw new IOException ( lr_6 + offset + lr_7 ) ; } final int bytesRead = offset ; if ( bytesRead > 0 ) { MST[rv.UOI4Mutator]MSP[] is . reset () ; final BufferedReader bReader = new BufferedReader ( new StringReader (
if ( cTEnc . equals ( UTF_16 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_16 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ;
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { MST[rv.ABSMutator]MSP[] offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ;
if ( appXml ) { return calculateRawEncoding ( bomEnc , xmlGuessEnc , xmlEnc ) ; } return defaultEncoding == null ? US_ASCII : defaultEncoding ; } if ( cTEnc . equals ( UTF_16BE ) || cTEnc . equals ( UTF_16LE ) ) { MST[rv.ROR2Mutator]MSP[] if ( bomEnc != null ) {
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } final String msg = MessageFormat . format ( RAW_EX_2 , bomEnc , xmlGuessEnc , xmlEnc ) ; throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[ConstructorCallMutator]MSP[] }
if ( cTEnc . equals ( UTF_16 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_16 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR4Mutator]MSP[]
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( xmlEnc != null && ! xmlEnc . equals ( UTF_8 ) ) { MST[rv.ROR4Mutator]MSP[] final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
final String postMime = httpContentType . substring ( i + 1 ) ; MST[rv.UOI3Mutator]MSP[] final Matcher m = CHARSET_PATTERN . matcher ( postMime ) ; encoding = m . find () ? m . group ( 1 ) : null ;
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } final String msg = MessageFormat . format ( RAW_EX_2 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR2Mutator]MSP[] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
mime . equals ( lr_9 ) || mime . equals ( lr_10 ) || mime . startsWith ( lr_11 ) && mime . endsWith ( lr_12 ) ) ; MST[rv.CRCR2Mutator]MSP[] } static boolean isTextXml ( final String mime ) { return mime != null &&
final String msg = MessageFormat . format ( HTTP_EX_3 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( cTEnc == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } if ( bomEnc . equals ( UTF_32BE ) || bomEnc . equals ( UTF_32LE ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( bomEnc ) ) {
xmlProlog = new String ( bytes , 0 , offset , guessedEnc ) ; firstGT = xmlProlog . indexOf ( '>' ) ; } if ( firstGT == - 1 ) { MST[rv.ROR5Mutator]MSP[] if ( c == - 1 ) { throw new IOException ( lr_5 ) ; }
if ( httpContentType != null && httpContentType . startsWith ( lr_1 ) ) { MST[rv.ROR3Mutator]MSP[] httpContentType = httpContentType . substring ( lr_1 . length () ) ; httpContentType = lr_2 + httpContentType ; try { return calculateHttpEncoding ( httpContentType , ex . getBomEncoding () ,
} return xmlEnc ; } if ( bomEnc . equals ( UTF_8 ) ) { if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( UTF_8 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR2Mutator]MSP[] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
final String postMime = httpContentType . substring ( i + 1 ) ; MST[rv.CRCR5Mutator]MSP[] final Matcher m = CHARSET_PATTERN . matcher ( postMime ) ; encoding = m . find () ? m . group ( 1 ) : null ;
final String msg = MessageFormat . format ( HTTP_EX_3 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR5Mutator]MSP[] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( cTEnc == null ) {
static String getContentTypeEncoding ( final String httpContentType ) { String encoding = null ; if ( httpContentType != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] final int i = httpContentType . indexOf ( lr_3 ) ; if ( i > - 1 ) {
String calculateHttpEncoding ( final String httpContentType , final String bomEnc , final String xmlGuessEnc , final String xmlEnc , final boolean lenient ) throws IOException { if ( lenient && xmlEnc != null ) { MST[rv.ROR2Mutator]MSP[] return xmlEnc ; } final String cTMime = getContentTypeMime ( httpContentType ) ;
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_16 ) && ! xmlEnc . equals ( bomEnc ) ) { MST[rv.ROR2Mutator]MSP[] final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
final String msg = MessageFormat . format ( HTTP_EX_3 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR2Mutator]MSP[] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( cTEnc == null ) {
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR6Mutator]MSP[] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } if ( bomEnc . equals ( UTF_16BE ) || bomEnc . equals ( UTF_16LE ) ) { if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( bomEnc ) ) { MST[NegateConditionalsMutator]MSP[]
throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( cTEnc . equals ( UTF_32BE ) || cTEnc . equals ( UTF_32LE ) ) { if ( bomEnc != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
if ( cTEnc . equals ( UTF_32 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_32 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR4Mutator]MSP[]
if ( cTEnc . equals ( UTF_16 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_16 ) ) { MST[rv.ROR2Mutator]MSP[] return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ;
final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR4Mutator]MSP[] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_32 ) && ! xmlEnc . equals ( bomEnc ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[InlineConstantMutator]MSP[]
xmlProlog = new String ( bytes , 0 , offset , guessedEnc ) ; firstGT = xmlProlog . indexOf ( '>' ) ; MST[rv.CRCR6Mutator]MSP[] } if ( firstGT == - 1 ) { if ( c == - 1 ) { throw new IOException ( lr_5 ) ; }
if ( cTEnc . equals ( UTF_16 ) ) { MST[rv.ROR5Mutator]MSP[] if ( bomEnc != null && bomEnc . startsWith ( UTF_16 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ;
throw new IOException ( lr_6 + offset + lr_7 ) ; } final int bytesRead = offset ; if ( bytesRead > 0 ) { is . reset () ; final BufferedReader bReader = new BufferedReader ( new StringReader ( MST[rv.CRCR5Mutator]MSP[]
if ( appXml ) { return calculateRawEncoding ( bomEnc , xmlGuessEnc , xmlEnc ) ; MST[NonVoidMethodCallMutator]MSP[] } return defaultEncoding == null ? US_ASCII : defaultEncoding ; } if ( cTEnc . equals ( UTF_16BE ) || cTEnc . equals ( UTF_16LE ) ) { if ( bomEnc != null ) {
} return xmlEnc ; } if ( bomEnc . equals ( UTF_8 ) ) { if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( UTF_8 ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR6Mutator]MSP[]
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR4Mutator]MSP[] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
if ( lenient ) { MST[NegateConditionalsMutator]MSP[] return doLenientDetection ( null , ex ) ; } throw ex ; } } private String doHttpStream ( final BOMInputStream bom , final BOMInputStream pis , final String httpContentType , final boolean lenient ) throws IOException {
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } final String msg = MessageFormat . format ( RAW_EX_2 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR4Mutator]MSP[] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
if ( xmlGuessEnc == null || xmlEnc == null ) { return defaultEncoding == null ? UTF_8 : defaultEncoding ; } if ( xmlEnc . equals ( UTF_16 ) && MST[rv.ROR1Mutator]MSP[] ( xmlGuessEnc . equals ( UTF_16BE ) || xmlGuessEnc . equals ( UTF_16LE ) ) ) { return xmlGuessEnc ;
static String getContentTypeEncoding ( final String httpContentType ) { String encoding = null ; if ( httpContentType != null ) { final int i = httpContentType . indexOf ( lr_3 ) ; if ( i > - 1 ) { MST[NegateConditionalsMutator]MSP[]
if ( xmlGuessEnc == null || xmlEnc == null ) { return defaultEncoding == null ? UTF_8 : defaultEncoding ; } if ( xmlEnc . equals ( UTF_16 ) && ( xmlGuessEnc . equals ( UTF_16BE ) || xmlGuessEnc . equals ( UTF_16LE ) ) ) { MST[rv.ROR3Mutator]MSP[] return xmlGuessEnc ;
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } final String msg = MessageFormat . format ( RAW_EX_2 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR5Mutator]MSP[] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
( mime . equals ( lr_2 ) || mime . equals ( lr_13 ) || mime . startsWith ( lr_14 ) && mime . endsWith ( lr_12 ) ) ; MST[NegateConditionalsMutator]MSP[] }
if ( appXml ) { MST[rv.ROR2Mutator]MSP[] return calculateRawEncoding ( bomEnc , xmlGuessEnc , xmlEnc ) ; } return defaultEncoding == null ? US_ASCII : defaultEncoding ; } if ( cTEnc . equals ( UTF_16BE ) || cTEnc . equals ( UTF_16LE ) ) { if ( bomEnc != null ) {
( mime . equals ( lr_2 ) || MST[rv.ROR4Mutator]MSP[] mime . equals ( lr_13 ) || mime . startsWith ( lr_14 ) && mime . endsWith ( lr_12 ) ) ; }
encoding = encoding . substring ( 1 , encoding . length () - 1 ) ; MST[NonVoidMethodCallMutator]MSP[] } } } return encoding ; } static boolean isAppXml ( final String mime ) { return mime != null && ( mime . equals ( lr_8 ) ||
String calculateHttpEncoding ( final String httpContentType , final String bomEnc , final String xmlGuessEnc , final String xmlEnc , final boolean lenient ) throws IOException { if ( lenient && xmlEnc != null ) { MST[NegateConditionalsMutator]MSP[] return xmlEnc ; } final String cTMime = getContentTypeMime ( httpContentType ) ;
if ( encoding == null ) { encoding = defaultEncoding == null ? UTF_8 : defaultEncoding ; } return encoding ; } String calculateRawEncoding ( final String bomEnc , final String xmlGuessEnc , final String xmlEnc ) throws IOException { if ( bomEnc == null ) { MST[NegateConditionalsMutator]MSP[]
if ( appXml ) { return calculateRawEncoding ( bomEnc , xmlGuessEnc , xmlEnc ) ; } return defaultEncoding == null ? US_ASCII : defaultEncoding ; } if ( cTEnc . equals ( UTF_16BE ) || cTEnc . equals ( UTF_16LE ) ) { MST[NonVoidMethodCallMutator]MSP[] if ( bomEnc != null ) {
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR2Mutator]MSP[] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR3Mutator]MSP[] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_32 ) && ! xmlEnc . equals ( bomEnc ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR5Mutator]MSP[]
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR4Mutator]MSP[] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
if ( cTEnc . equals ( UTF_32 ) ) { MST[NonVoidMethodCallMutator]MSP[] if ( bomEnc != null && bomEnc . startsWith ( UTF_32 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ;
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[ConstructorCallMutator]MSP[] } return bomEnc ; } if ( bomEnc . equals ( UTF_32BE ) || bomEnc . equals ( UTF_32LE ) ) { if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( bomEnc ) ) {
} return xmlEnc ; } if ( bomEnc . equals ( UTF_8 ) ) { if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( UTF_8 ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR3Mutator]MSP[]
final String cTEnc = getContentTypeEncoding ( httpContentType ) ; final boolean appXml = isAppXml ( cTMime ) ; final boolean textXml = isTextXml ( cTMime ) ; if ( ! appXml && ! textXml ) { MST[rv.UOI3Mutator]MSP[]
throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( cTEnc . equals ( UTF_32BE ) || cTEnc . equals ( UTF_32LE ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] if ( bomEnc != null ) {
if ( xmlGuessEnc == null || xmlEnc == null ) { return defaultEncoding == null ? UTF_8 : defaultEncoding ; } if ( xmlEnc . equals ( UTF_16 ) && ( xmlGuessEnc . equals ( UTF_16BE ) || xmlGuessEnc . equals ( UTF_16LE ) ) ) { MST[rv.ROR2Mutator]MSP[] return xmlGuessEnc ;
final int i = httpContentType . indexOf ( lr_3 ) ; if ( i >= 0 ) { mime = httpContentType . substring ( 0 , i ) ; MST[experimental.NakedReceiverMutator]MSP[] } else { mime = httpContentType ; } mime = mime . trim () ; } return mime ; }
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; MST[ReturnValsMutator]MSP[] }
if ( httpContentType != null && httpContentType . startsWith ( lr_1 ) ) { httpContentType = httpContentType . substring ( lr_1 . length () ) ; httpContentType = lr_2 + httpContentType ; try { return calculateHttpEncoding ( httpContentType , ex . getBomEncoding () , MST[NonVoidMethodCallMutator]MSP[]
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( xmlEnc != null && ! xmlEnc . equals ( UTF_8 ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR2Mutator]MSP[]
( mime . equals ( lr_2 ) || mime . equals ( lr_13 ) || mime . startsWith ( lr_14 ) && mime . endsWith ( lr_12 ) ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] }
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_16 ) && ! xmlEnc . equals ( bomEnc ) ) { MST[rv.ROR4Mutator]MSP[] final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
if ( guessedEnc != null ) { final byte [] bytes = new byte [ BUFFER_SIZE ] ; is . mark ( BUFFER_SIZE ) ; int offset = 0 ; int max = BUFFER_SIZE ; MST[rv.CRCR6Mutator]MSP[] int c = is . read ( bytes , offset , max ) ;
String calculateHttpEncoding ( final String httpContentType , final String bomEnc , final String xmlGuessEnc , final String xmlEnc , final boolean lenient ) throws IOException { if ( lenient && xmlEnc != null ) { MST[rv.ROR5Mutator]MSP[] return xmlEnc ; } final String cTMime = getContentTypeMime ( httpContentType ) ;
xmlProlog = new String ( bytes , 0 , offset , guessedEnc ) ; MST[rv.CRCR3Mutator]MSP[] firstGT = xmlProlog . indexOf ( '>' ) ; } if ( firstGT == - 1 ) { if ( c == - 1 ) { throw new IOException ( lr_5 ) ; }
if ( cTEnc . equals ( UTF_16 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_16 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR2Mutator]MSP[]
final String bomEnc = bom . getBOMCharsetName () ; MST[NonVoidMethodCallMutator]MSP[] final String xmlGuessEnc = pis . getBOMCharsetName () ; final String xmlEnc = getXmlProlog ( pis , xmlGuessEnc ) ; try { return calculateRawEncoding ( bomEnc , xmlGuessEnc , xmlEnc ) ; } catch ( final XmlStreamReaderException ex ) {
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_16 ) && ! xmlEnc . equals ( bomEnc ) ) { MST[rv.ROR1Mutator]MSP[] final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_32 ) && ! xmlEnc . equals ( bomEnc ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR6Mutator]MSP[]
final int i = httpContentType . indexOf ( lr_3 ) ; if ( i >= 0 ) { mime = httpContentType . substring ( 0 , i ) ; MST[rv.ABSMutator]MSP[] } else { mime = httpContentType ; } mime = mime . trim () ; } return mime ; }
if ( xmlGuessEnc == null || xmlEnc == null ) { return defaultEncoding == null ? UTF_8 : defaultEncoding ; } if ( xmlEnc . equals ( UTF_16 ) && ( xmlGuessEnc . equals ( UTF_16BE ) || xmlGuessEnc . equals ( UTF_16LE ) ) ) { MST[rv.ROR5Mutator]MSP[] return xmlGuessEnc ;
( mime . equals ( lr_2 ) || mime . equals ( lr_13 ) || mime . startsWith ( lr_14 ) && mime . endsWith ( lr_12 ) ) ; MST[rv.ROR2Mutator]MSP[] }
if ( appXml ) { return calculateRawEncoding ( bomEnc , xmlGuessEnc , xmlEnc ) ; } return defaultEncoding == null ? US_ASCII : defaultEncoding ; } if ( cTEnc . equals ( UTF_16BE ) || cTEnc . equals ( UTF_16LE ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] if ( bomEnc != null ) {
final String bomEnc = bom . getBOMCharsetName () ; final String xmlGuessEnc = pis . getBOMCharsetName () ; final String xmlEnc = getXmlProlog ( pis , xmlGuessEnc ) ; try { return calculateHttpEncoding ( httpContentType , bomEnc , MST[NonVoidMethodCallMutator]MSP[] xmlGuessEnc , xmlEnc , lenient ) ;
if ( encoding == null ) { encoding = defaultEncoding == null ? UTF_8 : defaultEncoding ; } return encoding ; } String calculateRawEncoding ( final String bomEnc , final String xmlGuessEnc , final String xmlEnc ) throws IOException { if ( bomEnc == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
( mime . equals ( lr_2 ) || mime . equals ( lr_13 ) || mime . startsWith ( lr_14 ) && mime . endsWith ( lr_12 ) ) ; MST[rv.CRCR2Mutator]MSP[] }
if ( cTEnc . equals ( UTF_32 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_32 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ;
xmlProlog = new String ( bytes , 0 , offset , guessedEnc ) ; firstGT = xmlProlog . indexOf ( '>' ) ; } if ( firstGT == - 1 ) { MST[rv.ROR4Mutator]MSP[] if ( c == - 1 ) { throw new IOException ( lr_5 ) ; }
encoding = encoding != null ? encoding . toUpperCase ( Locale . ROOT ) : null ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] } } return encoding ; } private static String getXmlProlog ( final InputStream is , final String guessedEnc ) throws IOException { String encoding = null ;
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( xmlEnc != null && ! xmlEnc . equals ( UTF_8 ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR3Mutator]MSP[]
final String msg = MessageFormat . format ( HTTP_EX_3 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[NonVoidMethodCallMutator]MSP[] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( cTEnc == null ) {
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } if ( bomEnc . equals ( UTF_32BE ) || bomEnc . equals ( UTF_32LE ) ) { if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( bomEnc ) ) { MST[rv.ROR5Mutator]MSP[]
final String postMime = httpContentType . substring ( i + 1 ) ; final Matcher m = CHARSET_PATTERN . matcher ( postMime ) ; encoding = m . find () ? m . group ( 1 ) : null ; MST[NonVoidMethodCallMutator]MSP[]
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[InlineConstantMutator]MSP[] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
if ( httpContentType != null && httpContentType . startsWith ( lr_1 ) ) { httpContentType = httpContentType . substring ( lr_1 . length () ) ; httpContentType = lr_2 + httpContentType ; MST[NonVoidMethodCallMutator]MSP[] try { return calculateHttpEncoding ( httpContentType , ex . getBomEncoding () ,
if ( appXml ) { return calculateRawEncoding ( bomEnc , xmlGuessEnc , xmlEnc ) ; } return defaultEncoding == null ? US_ASCII : defaultEncoding ; } if ( cTEnc . equals ( UTF_16BE ) || cTEnc . equals ( UTF_16LE ) ) { MST[rv.ROR3Mutator]MSP[] if ( bomEnc != null ) {
if ( httpContentType != null && httpContentType . startsWith ( lr_1 ) ) { httpContentType = httpContentType . substring ( lr_1 . length () ) ; httpContentType = lr_2 + httpContentType ; MST[experimental.NakedReceiverMutator]MSP[] try { return calculateHttpEncoding ( httpContentType , ex . getBomEncoding () ,
if ( cTEnc . equals ( UTF_16 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_16 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR6Mutator]MSP[]
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( xmlEnc != null && ! xmlEnc . equals ( UTF_8 ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR6Mutator]MSP[]
if ( cTEnc . equals ( UTF_16 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_16 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR3Mutator]MSP[]
if ( xmlGuessEnc == null || xmlEnc == null ) { return defaultEncoding == null ? UTF_8 : defaultEncoding ; } if ( xmlEnc . equals ( UTF_16 ) && ( xmlGuessEnc . equals ( UTF_16BE ) || xmlGuessEnc . equals ( UTF_16LE ) ) ) { MST[NegateConditionalsMutator]MSP[] return xmlGuessEnc ;
final String cTEnc = getContentTypeEncoding ( httpContentType ) ; final boolean appXml = isAppXml ( cTMime ) ; final boolean textXml = isTextXml ( cTMime ) ; if ( ! appXml && ! textXml ) { MST[rv.ROR4Mutator]MSP[]
if ( cTEnc . equals ( UTF_32 ) ) { MST[rv.ROR3Mutator]MSP[] if ( bomEnc != null && bomEnc . startsWith ( UTF_32 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ;
if ( cTEnc . equals ( UTF_16 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_16 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ;
encoding = encoding != null ? encoding . toUpperCase ( Locale . ROOT ) : null ; MST[rv.ROR5Mutator]MSP[] } } return encoding ; } private static String getXmlProlog ( final InputStream is , final String guessedEnc ) throws IOException { String encoding = null ;
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { MST[rv.CRCR1Mutator]MSP[] offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ;
ex . getXmlGuessEncoding () , ex . getXmlEncoding () , true ) ; } catch ( final XmlStreamReaderException ex2 ) { ex = ex2 ; } } String encoding = ex . getXmlEncoding () ; if ( encoding == null ) { MST[NegateConditionalsMutator]MSP[] encoding = ex . getContentTypeEncoding () ; }
if ( appXml ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return calculateRawEncoding ( bomEnc , xmlGuessEnc , xmlEnc ) ; } return defaultEncoding == null ? US_ASCII : defaultEncoding ; } if ( cTEnc . equals ( UTF_16BE ) || cTEnc . equals ( UTF_16LE ) ) { if ( bomEnc != null ) {
final String postMime = httpContentType . substring ( i + 1 ) ; MST[rv.CRCR6Mutator]MSP[] final Matcher m = CHARSET_PATTERN . matcher ( postMime ) ; encoding = m . find () ? m . group ( 1 ) : null ;
if ( xmlGuessEnc == null || xmlEnc == null ) { MST[rv.ROR5Mutator]MSP[] return defaultEncoding == null ? UTF_8 : defaultEncoding ; } if ( xmlEnc . equals ( UTF_16 ) && ( xmlGuessEnc . equals ( UTF_16BE ) || xmlGuessEnc . equals ( UTF_16LE ) ) ) { return xmlGuessEnc ;
static String getContentTypeEncoding ( final String httpContentType ) { String encoding = null ; if ( httpContentType != null ) { final int i = httpContentType . indexOf ( lr_3 ) ; if ( i > - 1 ) { MST[rv.CRCR4Mutator]MSP[]
final String msg = MessageFormat . format ( HTTP_EX_3 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR5Mutator]MSP[] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( cTEnc == null ) {
encoding = encoding . substring ( 1 , encoding . length () - 1 ) ; } } } return encoding ; } static boolean isAppXml ( final String mime ) { return mime != null && ( mime . equals ( lr_8 ) || MST[rv.ROR4Mutator]MSP[]
if ( cTEnc . equals ( UTF_32 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_32 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR3Mutator]MSP[]
mime . equals ( lr_9 ) || mime . equals ( lr_10 ) || mime . startsWith ( lr_11 ) && mime . endsWith ( lr_12 ) ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] } static boolean isTextXml ( final String mime ) { return mime != null &&
final String msg = MessageFormat . format ( HTTP_EX_3 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR2Mutator]MSP[] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( cTEnc == null ) {
if ( lenient ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return doLenientDetection ( null , ex ) ; } throw ex ; } } private String doHttpStream ( final BOMInputStream bom , final BOMInputStream pis , final String httpContentType , final boolean lenient ) throws IOException {
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_32 ) && ! xmlEnc . equals ( bomEnc ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR3Mutator]MSP[]
} catch ( final XmlStreamReaderException ex ) { if ( lenient ) { MST[rv.ABSMutator]MSP[] return doLenientDetection ( httpContentType , ex ) ; } throw ex ; } } private String doLenientDetection ( String httpContentType , XmlStreamReaderException ex ) throws IOException {
if ( cTEnc . equals ( UTF_16 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_16 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[InlineConstantMutator]MSP[]
String calculateHttpEncoding ( final String httpContentType , final String bomEnc , final String xmlGuessEnc , final String xmlEnc , final boolean lenient ) throws IOException { if ( lenient && xmlEnc != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return xmlEnc ; } final String cTMime = getContentTypeMime ( httpContentType ) ;
mime . equals ( lr_9 ) || mime . equals ( lr_10 ) || mime . startsWith ( lr_11 ) && mime . endsWith ( lr_12 ) ) ; MST[NonVoidMethodCallMutator]MSP[] } static boolean isTextXml ( final String mime ) { return mime != null &&
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } if ( bomEnc . equals ( UTF_16BE ) || bomEnc . equals ( UTF_16LE ) ) { MST[rv.ROR4Mutator]MSP[] if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( bomEnc ) ) {
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } if ( bomEnc . equals ( UTF_16BE ) || bomEnc . equals ( UTF_16LE ) ) { MST[rv.ROR1Mutator]MSP[] if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( bomEnc ) ) {
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR3Mutator]MSP[] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR4Mutator]MSP[] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( xmlEnc != null && ! xmlEnc . equals ( UTF_8 ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[ArgumentPropagationMutator]MSP[]
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ; MST[rv.ABSMutator]MSP[]
final String cTEnc = getContentTypeEncoding ( httpContentType ) ; final boolean appXml = isAppXml ( cTMime ) ; final boolean textXml = isTextXml ( cTMime ) ; if ( ! appXml && ! textXml ) { MST[rv.ROR1Mutator]MSP[]
mime . equals ( lr_9 ) || mime . equals ( lr_10 ) || MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] mime . startsWith ( lr_11 ) && mime . endsWith ( lr_12 ) ) ; } static boolean isTextXml ( final String mime ) { return mime != null &&
encoding = encoding . substring ( 1 , encoding . length () - 1 ) ; } } } return encoding ; } static boolean isAppXml ( final String mime ) { return mime != null && MST[rv.ROR5Mutator]MSP[] ( mime . equals ( lr_8 ) ||
( mime . equals ( lr_2 ) || mime . equals ( lr_13 ) || mime . startsWith ( lr_14 ) && mime . endsWith ( lr_12 ) ) ; MST[NegateConditionalsMutator]MSP[] }
} return xmlEnc ; } if ( bomEnc . equals ( UTF_8 ) ) { if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( UTF_8 ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR6Mutator]MSP[]
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { MST[rv.CRCR4Mutator]MSP[] offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ;
final String postMime = httpContentType . substring ( i + 1 ) ; final Matcher m = CHARSET_PATTERN . matcher ( postMime ) ; encoding = m . find () ? m . group ( 1 ) : null ; MST[rv.ROR3Mutator]MSP[]
xmlProlog = new String ( bytes , 0 , offset , guessedEnc ) ; firstGT = xmlProlog . indexOf ( '>' ) ; MST[NonVoidMethodCallMutator]MSP[] } if ( firstGT == - 1 ) { if ( c == - 1 ) { throw new IOException ( lr_5 ) ; }
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { MST[rv.ABSMutator]MSP[] offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ;
if ( appXml ) { return calculateRawEncoding ( bomEnc , xmlGuessEnc , xmlEnc ) ; } return defaultEncoding == null ? US_ASCII : defaultEncoding ; } if ( cTEnc . equals ( UTF_16BE ) || cTEnc . equals ( UTF_16LE ) ) { MST[NonVoidMethodCallMutator]MSP[] if ( bomEnc != null ) {
String calculateHttpEncoding ( final String httpContentType , final String bomEnc , final String xmlGuessEnc , final String xmlEnc , final boolean lenient ) throws IOException { if ( lenient && xmlEnc != null ) { MST[rv.UOI2Mutator]MSP[] return xmlEnc ; } final String cTMime = getContentTypeMime ( httpContentType ) ;
if ( cTEnc . equals ( UTF_32 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_32 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR2Mutator]MSP[]
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR4Mutator]MSP[] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
ex . getXmlGuessEncoding () , ex . getXmlEncoding () , true ) ; } catch ( final XmlStreamReaderException ex2 ) { ex = ex2 ; } } String encoding = ex . getXmlEncoding () ; if ( encoding == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] encoding = ex . getContentTypeEncoding () ; }
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; MST[EmptyObjectReturnValsMutator]MSP[] }
} return xmlEnc ; } if ( bomEnc . equals ( UTF_8 ) ) { if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( UTF_8 ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR3Mutator]MSP[]
final String cTEnc = getContentTypeEncoding ( httpContentType ) ; MST[NonVoidMethodCallMutator]MSP[] final boolean appXml = isAppXml ( cTMime ) ; final boolean textXml = isTextXml ( cTMime ) ; if ( ! appXml && ! textXml ) {
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_16 ) && ! xmlEnc . equals ( bomEnc ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR1Mutator]MSP[]
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ; MST[rv.UOI2Mutator]MSP[]
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_16 ) && ! xmlEnc . equals ( bomEnc ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR5Mutator]MSP[]
( mime . equals ( lr_2 ) || MST[rv.ROR1Mutator]MSP[] mime . equals ( lr_13 ) || mime . startsWith ( lr_14 ) && mime . endsWith ( lr_12 ) ) ; }
xmlProlog . substring ( 0 , firstGT + 1 ) ) ) ; final StringBuffer prolog = new StringBuffer () ; String line = bReader . readLine () ; while ( line != null ) { prolog . append ( line ) ; MST[experimental.NakedReceiverMutator]MSP[] line = bReader . readLine () ;
if ( appXml ) { MST[rv.UOI2Mutator]MSP[] return calculateRawEncoding ( bomEnc , xmlGuessEnc , xmlEnc ) ; } return defaultEncoding == null ? US_ASCII : defaultEncoding ; } if ( cTEnc . equals ( UTF_16BE ) || cTEnc . equals ( UTF_16LE ) ) { if ( bomEnc != null ) {
if ( guessedEnc != null ) { final byte [] bytes = new byte [ BUFFER_SIZE ] ; is . mark ( BUFFER_SIZE ) ; int offset = 0 ; int max = BUFFER_SIZE ; int c = is . read ( bytes , offset , max ) ; MST[rv.UOI4Mutator]MSP[]
if ( lenient ) { MST[rv.ROR1Mutator]MSP[] return doLenientDetection ( null , ex ) ; } throw ex ; } } private String doHttpStream ( final BOMInputStream bom , final BOMInputStream pis , final String httpContentType , final boolean lenient ) throws IOException {
xmlProlog = new String ( bytes , 0 , offset , guessedEnc ) ; firstGT = xmlProlog . indexOf ( '>' ) ; } if ( firstGT == - 1 ) { MST[rv.ROR1Mutator]MSP[] if ( c == - 1 ) { throw new IOException ( lr_5 ) ; }
throw new IOException ( lr_6 + offset + lr_7 ) ; } final int bytesRead = offset ; if ( bytesRead > 0 ) { is . reset () ; final BufferedReader bReader = new BufferedReader ( new StringReader ( MST[rv.CRCR1Mutator]MSP[]
final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR1Mutator]MSP[] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
static String getContentTypeEncoding ( final String httpContentType ) { String encoding = null ; if ( httpContentType != null ) { final int i = httpContentType . indexOf ( lr_3 ) ; if ( i > - 1 ) { MST[rv.CRCR1Mutator]MSP[]
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( xmlEnc != null && ! xmlEnc . equals ( UTF_8 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
final String postMime = httpContentType . substring ( i + 1 ) ; MST[rv.AOD2Mutator]MSP[] final Matcher m = CHARSET_PATTERN . matcher ( postMime ) ; encoding = m . find () ? m . group ( 1 ) : null ;
} return xmlEnc ; } if ( bomEnc . equals ( UTF_8 ) ) { if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( UTF_8 ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[ArgumentPropagationMutator]MSP[]
throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( cTEnc . equals ( UTF_32BE ) || cTEnc . equals ( UTF_32LE ) ) { MST[NonVoidMethodCallMutator]MSP[] if ( bomEnc != null ) {
encoding = encoding . substring ( 1 , encoding . length () - 1 ) ; MST[rv.CRCR6Mutator]MSP[] } } } return encoding ; } static boolean isAppXml ( final String mime ) { return mime != null && ( mime . equals ( lr_8 ) ||
mime . equals ( lr_9 ) || mime . equals ( lr_10 ) || mime . startsWith ( lr_11 ) && mime . endsWith ( lr_12 ) ) ; MST[rv.ROR3Mutator]MSP[] } static boolean isTextXml ( final String mime ) { return mime != null &&
final String bomEnc = bom . getBOMCharsetName () ; MST[NonVoidMethodCallMutator]MSP[] final String xmlGuessEnc = pis . getBOMCharsetName () ; final String xmlEnc = getXmlProlog ( pis , xmlGuessEnc ) ; try { return calculateHttpEncoding ( httpContentType , bomEnc , xmlGuessEnc , xmlEnc , lenient ) ;
ex . getXmlGuessEncoding () , ex . getXmlEncoding () , true ) ; MST[NonVoidMethodCallMutator]MSP[] } catch ( final XmlStreamReaderException ex2 ) { ex = ex2 ; } } String encoding = ex . getXmlEncoding () ; if ( encoding == null ) { encoding = ex . getContentTypeEncoding () ; }
mime . equals ( lr_9 ) || mime . equals ( lr_10 ) || MST[rv.ROR1Mutator]MSP[] mime . startsWith ( lr_11 ) && mime . endsWith ( lr_12 ) ) ; } static boolean isTextXml ( final String mime ) { return mime != null &&
if ( cTEnc . equals ( UTF_16 ) ) { MST[rv.ROR3Mutator]MSP[] if ( bomEnc != null && bomEnc . startsWith ( UTF_16 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ;
final int i = httpContentType . indexOf ( lr_3 ) ; if ( i >= 0 ) { MST[rv.ROR3Mutator]MSP[] mime = httpContentType . substring ( 0 , i ) ; } else { mime = httpContentType ; } mime = mime . trim () ; } return mime ; }
if ( xmlGuessEnc == null || xmlEnc == null ) { return defaultEncoding == null ? UTF_8 : defaultEncoding ; } if ( xmlEnc . equals ( UTF_16 ) && MST[rv.ROR3Mutator]MSP[] ( xmlGuessEnc . equals ( UTF_16BE ) || xmlGuessEnc . equals ( UTF_16LE ) ) ) { return xmlGuessEnc ;
if ( appXml ) { return calculateRawEncoding ( bomEnc , xmlGuessEnc , xmlEnc ) ; } return defaultEncoding == null ? US_ASCII : defaultEncoding ; } if ( cTEnc . equals ( UTF_16BE ) || cTEnc . equals ( UTF_16LE ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] if ( bomEnc != null ) {
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[InlineConstantMutator]MSP[] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
if ( cTEnc . equals ( UTF_32 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] if ( bomEnc != null && bomEnc . startsWith ( UTF_32 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ;
xmlProlog = new String ( bytes , 0 , offset , guessedEnc ) ; firstGT = xmlProlog . indexOf ( '>' ) ; } if ( firstGT == - 1 ) { MST[rv.UOI4Mutator]MSP[] if ( c == - 1 ) { throw new IOException ( lr_5 ) ; }
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( xmlEnc != null && ! xmlEnc . equals ( UTF_8 ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR3Mutator]MSP[]
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } if ( bomEnc . equals ( UTF_32BE ) || bomEnc . equals ( UTF_32LE ) ) { if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( bomEnc ) ) { MST[rv.ROR2Mutator]MSP[]
if ( cTEnc . equals ( UTF_16 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_16 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR3Mutator]MSP[]
if ( cTEnc . equals ( UTF_16 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_16 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ;
throw new IOException ( lr_6 + offset + lr_7 ) ; } final int bytesRead = offset ; if ( bytesRead > 0 ) { MST[rv.ROR4Mutator]MSP[] is . reset () ; final BufferedReader bReader = new BufferedReader ( new StringReader (
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_32 ) && ! xmlEnc . equals ( bomEnc ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[ArgumentPropagationMutator]MSP[]
if ( cTEnc . equals ( UTF_32 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_32 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[InlineConstantMutator]MSP[]
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } final String msg = MessageFormat . format ( RAW_EX_2 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR1Mutator]MSP[] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
( mime . equals ( lr_2 ) || mime . equals ( lr_13 ) || MST[rv.ROR3Mutator]MSP[] mime . startsWith ( lr_14 ) && mime . endsWith ( lr_12 ) ) ; }
final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR6Mutator]MSP[] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
ex . getXmlGuessEncoding () , ex . getXmlEncoding () , true ) ; MST[rv.CRCR5Mutator]MSP[] } catch ( final XmlStreamReaderException ex2 ) { ex = ex2 ; } } String encoding = ex . getXmlEncoding () ; if ( encoding == null ) { encoding = ex . getContentTypeEncoding () ; }
if ( encoding == null ) { encoding = defaultEncoding == null ? UTF_8 : defaultEncoding ; } return encoding ; } String calculateRawEncoding ( final String bomEnc , final String xmlGuessEnc , final String xmlEnc ) throws IOException { if ( bomEnc == null ) { MST[rv.ROR5Mutator]MSP[]
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_32 ) && ! xmlEnc . equals ( bomEnc ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR3Mutator]MSP[]
if ( appXml ) { return calculateRawEncoding ( bomEnc , xmlGuessEnc , xmlEnc ) ; } return defaultEncoding == null ? US_ASCII : defaultEncoding ; MST[ReturnValsMutator]MSP[] } if ( cTEnc . equals ( UTF_16BE ) || cTEnc . equals ( UTF_16LE ) ) { if ( bomEnc != null ) {
final String msg = MessageFormat . format ( HTTP_EX_3 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( cTEnc == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
} return xmlEnc ; } if ( bomEnc . equals ( UTF_8 ) ) { MST[rv.ROR2Mutator]MSP[] if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( UTF_8 ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
xmlProlog . substring ( 0 , firstGT + 1 ) ) ) ; MST[NonVoidMethodCallMutator]MSP[] final StringBuffer prolog = new StringBuffer () ; String line = bReader . readLine () ; while ( line != null ) { prolog . append ( line ) ; line = bReader . readLine () ;
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { MST[rv.UOI1Mutator]MSP[] offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ;
mime . equals ( lr_9 ) || mime . equals ( lr_10 ) || mime . startsWith ( lr_11 ) && mime . endsWith ( lr_12 ) ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] } static boolean isTextXml ( final String mime ) { return mime != null &&
final String msg = MessageFormat . format ( HTTP_EX_3 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR5Mutator]MSP[] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( cTEnc == null ) {
static String getContentTypeEncoding ( final String httpContentType ) { String encoding = null ; if ( httpContentType != null ) { final int i = httpContentType . indexOf ( lr_3 ) ; if ( i > - 1 ) { MST[rv.ROR1Mutator]MSP[]
xmlProlog . substring ( 0 , firstGT + 1 ) ) ) ; final StringBuffer prolog = new StringBuffer () ; String line = bReader . readLine () ; while ( line != null ) { MST[rv.ROR5Mutator]MSP[] prolog . append ( line ) ; line = bReader . readLine () ;
if ( cTEnc . equals ( UTF_16 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_16 ) ) { MST[NonVoidMethodCallMutator]MSP[] return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ;
( mime . equals ( lr_2 ) || mime . equals ( lr_13 ) || mime . startsWith ( lr_14 ) && mime . endsWith ( lr_12 ) ) ; MST[rv.ROR5Mutator]MSP[] }
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } if ( bomEnc . equals ( UTF_16BE ) || bomEnc . equals ( UTF_16LE ) ) { MST[rv.ROR4Mutator]MSP[] if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( bomEnc ) ) {
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { MST[rv.ROR4Mutator]MSP[] offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ;
xmlProlog = new String ( bytes , 0 , offset , guessedEnc ) ; firstGT = xmlProlog . indexOf ( '>' ) ; } if ( firstGT == - 1 ) { MST[rv.CRCR1Mutator]MSP[] if ( c == - 1 ) { throw new IOException ( lr_5 ) ; }
xmlProlog = new String ( bytes , 0 , offset , guessedEnc ) ; MST[rv.CRCR6Mutator]MSP[] firstGT = xmlProlog . indexOf ( '>' ) ; } if ( firstGT == - 1 ) { if ( c == - 1 ) { throw new IOException ( lr_5 ) ; }
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR3Mutator]MSP[] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { offset += c ; MST[rv.UOI3Mutator]MSP[] max -= c ; c = is . read ( bytes , offset , max ) ;
if ( cTEnc . equals ( UTF_32 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_32 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR4Mutator]MSP[]
return reader . read ( buf , offset , len ) ; MST[rv.UOI2Mutator]MSP[] } @Override public void close () throws IOException { reader . close () ; } private String doRawStream ( final BOMInputStream bom , final BOMInputStream pis , final boolean lenient ) throws IOException {
String calculateHttpEncoding ( final String httpContentType , final String bomEnc , final String xmlGuessEnc , final String xmlEnc , final boolean lenient ) throws IOException { if ( lenient && xmlEnc != null ) { return xmlEnc ; MST[ReturnValsMutator]MSP[] } final String cTMime = getContentTypeMime ( httpContentType ) ;
throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( cTEnc . equals ( UTF_32BE ) || cTEnc . equals ( UTF_32LE ) ) { if ( bomEnc != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
mime . equals ( lr_9 ) || mime . equals ( lr_10 ) || mime . startsWith ( lr_11 ) && mime . endsWith ( lr_12 ) ) ; MST[NonVoidMethodCallMutator]MSP[] } static boolean isTextXml ( final String mime ) { return mime != null &&
static String getContentTypeEncoding ( final String httpContentType ) { String encoding = null ; if ( httpContentType != null ) { final int i = httpContentType . indexOf ( lr_3 ) ; if ( i > - 1 ) { MST[rv.UOI4Mutator]MSP[]
throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; MST[ReturnValsMutator]MSP[] } static String getContentTypeMime ( final String httpContentType ) { String mime = null ; if ( httpContentType != null ) {
} return xmlEnc ; } if ( bomEnc . equals ( UTF_8 ) ) { if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( UTF_8 ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR5Mutator]MSP[]
} return xmlEnc ; } if ( bomEnc . equals ( UTF_8 ) ) { if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( UTF_8 ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR6Mutator]MSP[]
final String msg = MessageFormat . format ( HTTP_EX_3 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR1Mutator]MSP[] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( cTEnc == null ) {
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR6Mutator]MSP[] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[] offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ;
xmlProlog . substring ( 0 , firstGT + 1 ) ) ) ; final StringBuffer prolog = new StringBuffer () ; String line = bReader . readLine () ; MST[NonVoidMethodCallMutator]MSP[] while ( line != null ) { prolog . append ( line ) ; line = bReader . readLine () ;
if ( cTEnc . equals ( UTF_32 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_32 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR5Mutator]MSP[]
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { MST[rv.ROR3Mutator]MSP[] offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ;
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR3Mutator]MSP[] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
throw new IOException ( lr_6 + offset + lr_7 ) ; } final int bytesRead = offset ; if ( bytesRead > 0 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[] is . reset () ; final BufferedReader bReader = new BufferedReader ( new StringReader (
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_32 ) && ! xmlEnc . equals ( bomEnc ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
return reader . read ( buf , offset , len ) ; MST[rv.UOI2Mutator]MSP[] } @Override public void close () throws IOException { reader . close () ; } private String doRawStream ( final BOMInputStream bom , final BOMInputStream pis , final boolean lenient ) throws IOException {
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_16 ) && ! xmlEnc . equals ( bomEnc ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR5Mutator]MSP[]
final int i = httpContentType . indexOf ( lr_3 ) ; if ( i >= 0 ) { MST[ConditionalsBoundaryMutator]MSP[] mime = httpContentType . substring ( 0 , i ) ; } else { mime = httpContentType ; } mime = mime . trim () ; } return mime ; }
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } if ( bomEnc . equals ( UTF_16BE ) || bomEnc . equals ( UTF_16LE ) ) { if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( bomEnc ) ) { MST[rv.ROR1Mutator]MSP[]
final String cTEnc = getContentTypeEncoding ( httpContentType ) ; final boolean appXml = isAppXml ( cTMime ) ; final boolean textXml = isTextXml ( cTMime ) ; if ( ! appXml && ! textXml ) { MST[rv.ROR2Mutator]MSP[]
throw new IOException ( lr_6 + offset + lr_7 ) ; } final int bytesRead = offset ; if ( bytesRead > 0 ) { is . reset () ; final BufferedReader bReader = new BufferedReader ( new StringReader ( MST[rv.AOR3Mutator]MSP[]
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_32 ) && ! xmlEnc . equals ( bomEnc ) ) { MST[rv.ROR3Mutator]MSP[] final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
} return xmlEnc ; } if ( bomEnc . equals ( UTF_8 ) ) { if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( UTF_8 ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR3Mutator]MSP[]
if ( cTEnc . equals ( UTF_32 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_32 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR6Mutator]MSP[]
if ( guessedEnc != null ) { final byte [] bytes = new byte [ BUFFER_SIZE ] ; is . mark ( BUFFER_SIZE ) ; MST[rv.CRCR2Mutator]MSP[] int offset = 0 ; int max = BUFFER_SIZE ; int c = is . read ( bytes , offset , max ) ;
final String msg = MessageFormat . format ( HTTP_EX_3 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR4Mutator]MSP[] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( cTEnc == null ) {
} final Matcher m = ENCODING_PATTERN . matcher ( prolog ) ; if ( m . find () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] encoding = m . group ( 1 ) . toUpperCase ( Locale . ROOT ) ;
throw new IOException ( lr_6 + offset + lr_7 ) ; } final int bytesRead = offset ; if ( bytesRead > 0 ) { is . reset () ; MST[VoidMethodCallMutator]MSP[] final BufferedReader bReader = new BufferedReader ( new StringReader (
if ( guessedEnc != null ) { final byte [] bytes = new byte [ BUFFER_SIZE ] ; MST[rv.CRCR4Mutator]MSP[] is . mark ( BUFFER_SIZE ) ; int offset = 0 ; int max = BUFFER_SIZE ; int c = is . read ( bytes , offset , max ) ;
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR6Mutator]MSP[] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
mime . equals ( lr_9 ) || mime . equals ( lr_10 ) || mime . startsWith ( lr_11 ) && mime . endsWith ( lr_12 ) ) ; MST[rv.ROR3Mutator]MSP[] } static boolean isTextXml ( final String mime ) { return mime != null &&
final int i = httpContentType . indexOf ( lr_3 ) ; if ( i >= 0 ) { mime = httpContentType . substring ( 0 , i ) ; } else { mime = httpContentType ; } mime = mime . trim () ; } return mime ; MST[ReturnValsMutator]MSP[] }
final int i = httpContentType . indexOf ( lr_3 ) ; if ( i >= 0 ) { mime = httpContentType . substring ( 0 , i ) ; MST[rv.UOI4Mutator]MSP[] } else { mime = httpContentType ; } mime = mime . trim () ; } return mime ; }
if ( guessedEnc != null ) { final byte [] bytes = new byte [ BUFFER_SIZE ] ; is . mark ( BUFFER_SIZE ) ; MST[rv.CRCR6Mutator]MSP[] int offset = 0 ; int max = BUFFER_SIZE ; int c = is . read ( bytes , offset , max ) ;
final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR3Mutator]MSP[] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
if ( cTEnc . equals ( UTF_16 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_16 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR3Mutator]MSP[]
} final Matcher m = ENCODING_PATTERN . matcher ( prolog ) ; if ( m . find () ) { MST[rv.ROR3Mutator]MSP[] encoding = m . group ( 1 ) . toUpperCase ( Locale . ROOT ) ;
( mime . equals ( lr_2 ) || mime . equals ( lr_13 ) || mime . startsWith ( lr_14 ) && mime . endsWith ( lr_12 ) ) ; MST[NonVoidMethodCallMutator]MSP[] }
mime . equals ( lr_9 ) || mime . equals ( lr_10 ) || mime . startsWith ( lr_11 ) && mime . endsWith ( lr_12 ) ) ; MST[rv.CRCR3Mutator]MSP[] } static boolean isTextXml ( final String mime ) { return mime != null &&
final String cTEnc = getContentTypeEncoding ( httpContentType ) ; final boolean appXml = isAppXml ( cTMime ) ; MST[NonVoidMethodCallMutator]MSP[] final boolean textXml = isTextXml ( cTMime ) ; if ( ! appXml && ! textXml ) {
final String msg = MessageFormat . format ( HTTP_EX_3 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[InlineConstantMutator]MSP[] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( cTEnc == null ) {
final String cTEnc = getContentTypeEncoding ( httpContentType ) ; final boolean appXml = isAppXml ( cTMime ) ; final boolean textXml = isTextXml ( cTMime ) ; if ( ! appXml && ! textXml ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
encoding = encoding . substring ( 1 , encoding . length () - 1 ) ; MST[rv.AOD1Mutator]MSP[] } } } return encoding ; } static boolean isAppXml ( final String mime ) { return mime != null && ( mime . equals ( lr_8 ) ||
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; MST[ReturnValsMutator]MSP[] }
} return xmlEnc ; MST[ReturnValsMutator]MSP[] } if ( bomEnc . equals ( UTF_8 ) ) { if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( UTF_8 ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
throw new IOException ( lr_6 + offset + lr_7 ) ; } final int bytesRead = offset ; if ( bytesRead > 0 ) { MST[rv.UOI3Mutator]MSP[] is . reset () ; final BufferedReader bReader = new BufferedReader ( new StringReader (
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { offset += c ; MST[rv.AOR1Mutator]MSP[] max -= c ; c = is . read ( bytes , offset , max ) ;
if ( cTEnc . equals ( UTF_16 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_16 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR6Mutator]MSP[]
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { offset += c ; MST[rv.AOR4Mutator]MSP[] max -= c ; c = is . read ( bytes , offset , max ) ;
if ( cTEnc . equals ( UTF_32 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_32 ) ) { MST[rv.ROR3Mutator]MSP[] return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ;
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { offset += c ; max -= c ; MST[rv.ABSMutator]MSP[] c = is . read ( bytes , offset , max ) ;
if ( appXml ) { return calculateRawEncoding ( bomEnc , xmlGuessEnc , xmlEnc ) ; } return defaultEncoding == null ? US_ASCII : defaultEncoding ; MST[rv.ROR5Mutator]MSP[] } if ( cTEnc . equals ( UTF_16BE ) || cTEnc . equals ( UTF_16LE ) ) { if ( bomEnc != null ) {
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR3Mutator]MSP[] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } final String msg = MessageFormat . format ( RAW_EX_2 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR6Mutator]MSP[] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
xmlProlog = new String ( bytes , 0 , offset , guessedEnc ) ; MST[rv.UOI1Mutator]MSP[] firstGT = xmlProlog . indexOf ( '>' ) ; } if ( firstGT == - 1 ) { if ( c == - 1 ) { throw new IOException ( lr_5 ) ; }
if ( cTEnc . equals ( UTF_16 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] if ( bomEnc != null && bomEnc . startsWith ( UTF_16 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ;
xmlProlog = new String ( bytes , 0 , offset , guessedEnc ) ; MST[rv.ABSMutator]MSP[] firstGT = xmlProlog . indexOf ( '>' ) ; } if ( firstGT == - 1 ) { if ( c == - 1 ) { throw new IOException ( lr_5 ) ; }
final String postMime = httpContentType . substring ( i + 1 ) ; final Matcher m = CHARSET_PATTERN . matcher ( postMime ) ; encoding = m . find () ? m . group ( 1 ) : null ; MST[rv.CRCR3Mutator]MSP[]
mime . equals ( lr_9 ) || mime . equals ( lr_10 ) || mime . startsWith ( lr_11 ) && mime . endsWith ( lr_12 ) ) ; MST[rv.CRCR6Mutator]MSP[] } static boolean isTextXml ( final String mime ) { return mime != null &&
final String cTEnc = getContentTypeEncoding ( httpContentType ) ; final boolean appXml = isAppXml ( cTMime ) ; final boolean textXml = isTextXml ( cTMime ) ; if ( ! appXml && ! textXml ) { MST[rv.UOI1Mutator]MSP[]
final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR6Mutator]MSP[] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
if ( xmlGuessEnc == null || xmlEnc == null ) { return defaultEncoding == null ? UTF_8 : defaultEncoding ; } if ( xmlEnc . equals ( UTF_16 ) && ( xmlGuessEnc . equals ( UTF_16BE ) || xmlGuessEnc . equals ( UTF_16LE ) ) ) { MST[NonVoidMethodCallMutator]MSP[] return xmlGuessEnc ;
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } if ( bomEnc . equals ( UTF_32BE ) || bomEnc . equals ( UTF_32LE ) ) { MST[rv.ROR3Mutator]MSP[] if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( bomEnc ) ) {
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } if ( bomEnc . equals ( UTF_32BE ) || bomEnc . equals ( UTF_32LE ) ) { if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( bomEnc ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
encoding = encoding . substring ( 1 , encoding . length () - 1 ) ; MST[NonVoidMethodCallMutator]MSP[] } } } return encoding ; } static boolean isAppXml ( final String mime ) { return mime != null && ( mime . equals ( lr_8 ) ||
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR5Mutator]MSP[] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
} catch ( final XmlStreamReaderException ex ) { if ( lenient ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return doLenientDetection ( httpContentType , ex ) ; } throw ex ; } } private String doLenientDetection ( String httpContentType , XmlStreamReaderException ex ) throws IOException {
( mime . equals ( lr_2 ) || MST[rv.ROR5Mutator]MSP[] mime . equals ( lr_13 ) || mime . startsWith ( lr_14 ) && mime . endsWith ( lr_12 ) ) ; }
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_32 ) && ! xmlEnc . equals ( bomEnc ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR3Mutator]MSP[]
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR2Mutator]MSP[] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
} return xmlEnc ; } if ( bomEnc . equals ( UTF_8 ) ) { if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( UTF_8 ) ) { MST[rv.ROR3Mutator]MSP[] final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
String calculateHttpEncoding ( final String httpContentType , final String bomEnc , final String xmlGuessEnc , final String xmlEnc , final boolean lenient ) throws IOException { if ( lenient && xmlEnc != null ) { MST[rv.ABSMutator]MSP[] return xmlEnc ; } final String cTMime = getContentTypeMime ( httpContentType ) ;
if ( cTEnc . equals ( UTF_32 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_32 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR3Mutator]MSP[]
if ( xmlGuessEnc == null || xmlEnc == null ) { return defaultEncoding == null ? UTF_8 : defaultEncoding ; } if ( xmlEnc . equals ( UTF_16 ) && ( xmlGuessEnc . equals ( UTF_16BE ) || xmlGuessEnc . equals ( UTF_16LE ) ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return xmlGuessEnc ;
throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( cTEnc . equals ( UTF_32BE ) || cTEnc . equals ( UTF_32LE ) ) { MST[rv.ROR3Mutator]MSP[] if ( bomEnc != null ) {
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { offset += c ; max -= c ; MST[rv.UOI1Mutator]MSP[] c = is . read ( bytes , offset , max ) ;
if ( guessedEnc != null ) { final byte [] bytes = new byte [ BUFFER_SIZE ] ; is . mark ( BUFFER_SIZE ) ; int offset = 0 ; int max = BUFFER_SIZE ; MST[rv.CRCR3Mutator]MSP[] int c = is . read ( bytes , offset , max ) ;
throw new IOException ( lr_6 + offset + lr_7 ) ; } final int bytesRead = offset ; if ( bytesRead > 0 ) { is . reset () ; final BufferedReader bReader = new BufferedReader ( new StringReader ( MST[rv.CRCR6Mutator]MSP[]
throw new IOException ( lr_6 + offset + lr_7 ) ; } final int bytesRead = offset ; if ( bytesRead > 0 ) { is . reset () ; final BufferedReader bReader = new BufferedReader ( new StringReader ( MST[rv.UOI2Mutator]MSP[]
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_16 ) && ! xmlEnc . equals ( bomEnc ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR2Mutator]MSP[]
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { MST[rv.CRCR2Mutator]MSP[] offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ;
} return xmlEnc ; } if ( bomEnc . equals ( UTF_8 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( UTF_8 ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[InlineConstantMutator]MSP[] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
return reader . read ( buf , offset , len ) ; MST[rv.ABSMutator]MSP[] } @Override public void close () throws IOException { reader . close () ; } private String doRawStream ( final BOMInputStream bom , final BOMInputStream pis , final boolean lenient ) throws IOException {
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } if ( bomEnc . equals ( UTF_16BE ) || bomEnc . equals ( UTF_16LE ) ) { if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( bomEnc ) ) { MST[rv.ROR4Mutator]MSP[]
if ( lenient ) { MST[rv.UOI3Mutator]MSP[] return doLenientDetection ( null , ex ) ; } throw ex ; } } private String doHttpStream ( final BOMInputStream bom , final BOMInputStream pis , final String httpContentType , final boolean lenient ) throws IOException {
if ( appXml ) { MST[rv.ABSMutator]MSP[] return calculateRawEncoding ( bomEnc , xmlGuessEnc , xmlEnc ) ; } return defaultEncoding == null ? US_ASCII : defaultEncoding ; } if ( cTEnc . equals ( UTF_16BE ) || cTEnc . equals ( UTF_16LE ) ) { if ( bomEnc != null ) {
} catch ( final XmlStreamReaderException ex ) { if ( lenient ) { MST[rv.UOI4Mutator]MSP[] return doLenientDetection ( httpContentType , ex ) ; } throw ex ; } } private String doLenientDetection ( String httpContentType , XmlStreamReaderException ex ) throws IOException {
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_32 ) && ! xmlEnc . equals ( bomEnc ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR2Mutator]MSP[]
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } if ( bomEnc . equals ( UTF_32BE ) || bomEnc . equals ( UTF_32LE ) ) { if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( bomEnc ) ) { MST[NonVoidMethodCallMutator]MSP[]
ex . getXmlGuessEncoding () , ex . getXmlEncoding () , true ) ; } catch ( final XmlStreamReaderException ex2 ) { ex = ex2 ; } } String encoding = ex . getXmlEncoding () ; if ( encoding == null ) { MST[rv.ROR5Mutator]MSP[] encoding = ex . getContentTypeEncoding () ; }
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR3Mutator]MSP[] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { offset += c ; max -= c ; MST[rv.UOI2Mutator]MSP[] c = is . read ( bytes , offset , max ) ;
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR5Mutator]MSP[] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { offset += c ; max -= c ; MST[rv.AOR3Mutator]MSP[] c = is . read ( bytes , offset , max ) ;
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_16 ) && ! xmlEnc . equals ( bomEnc ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR5Mutator]MSP[]
if ( appXml ) { return calculateRawEncoding ( bomEnc , xmlGuessEnc , xmlEnc ) ; } return defaultEncoding == null ? US_ASCII : defaultEncoding ; } if ( cTEnc . equals ( UTF_16BE ) || cTEnc . equals ( UTF_16LE ) ) { if ( bomEnc != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
if ( xmlGuessEnc == null || xmlEnc == null ) { return defaultEncoding == null ? UTF_8 : defaultEncoding ; } if ( xmlEnc . equals ( UTF_16 ) && ( xmlGuessEnc . equals ( UTF_16BE ) || xmlGuessEnc . equals ( UTF_16LE ) ) ) { MST[rv.ROR2Mutator]MSP[] return xmlGuessEnc ;
} final Matcher m = ENCODING_PATTERN . matcher ( prolog ) ; if ( m . find () ) { encoding = m . group ( 1 ) . toUpperCase ( Locale . ROOT ) ; MST[rv.CRCR6Mutator]MSP[]
( mime . equals ( lr_2 ) || mime . equals ( lr_13 ) || MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] mime . startsWith ( lr_14 ) && mime . endsWith ( lr_12 ) ) ; }
encoding = encoding . substring ( 1 , encoding . length () - 1 ) ; } } } return encoding ; } static boolean isAppXml ( final String mime ) { return mime != null && MST[NegateConditionalsMutator]MSP[] ( mime . equals ( lr_8 ) ||
if ( appXml ) { MST[rv.ROR3Mutator]MSP[] return calculateRawEncoding ( bomEnc , xmlGuessEnc , xmlEnc ) ; } return defaultEncoding == null ? US_ASCII : defaultEncoding ; } if ( cTEnc . equals ( UTF_16BE ) || cTEnc . equals ( UTF_16LE ) ) { if ( bomEnc != null ) {
if ( xmlGuessEnc == null || xmlEnc == null ) { return defaultEncoding == null ? UTF_8 : defaultEncoding ; } if ( xmlEnc . equals ( UTF_16 ) && MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] ( xmlGuessEnc . equals ( UTF_16BE ) || xmlGuessEnc . equals ( UTF_16LE ) ) ) { return xmlGuessEnc ;
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } final String msg = MessageFormat . format ( RAW_EX_2 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[InlineConstantMutator]MSP[] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
if ( encoding == null ) { encoding = defaultEncoding == null ? UTF_8 : defaultEncoding ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] } return encoding ; } String calculateRawEncoding ( final String bomEnc , final String xmlGuessEnc , final String xmlEnc ) throws IOException { if ( bomEnc == null ) {
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_16 ) && ! xmlEnc . equals ( bomEnc ) ) { MST[rv.ROR1Mutator]MSP[] final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
xmlProlog = new String ( bytes , 0 , offset , guessedEnc ) ; firstGT = xmlProlog . indexOf ( '>' ) ; } if ( firstGT == - 1 ) { MST[rv.CRCR4Mutator]MSP[] if ( c == - 1 ) { throw new IOException ( lr_5 ) ; }
String calculateHttpEncoding ( final String httpContentType , final String bomEnc , final String xmlGuessEnc , final String xmlEnc , final boolean lenient ) throws IOException { if ( lenient && xmlEnc != null ) { MST[rv.ROR3Mutator]MSP[] return xmlEnc ; } final String cTMime = getContentTypeMime ( httpContentType ) ;
} final Matcher m = ENCODING_PATTERN . matcher ( prolog ) ; if ( m . find () ) { encoding = m . group ( 1 ) . toUpperCase ( Locale . ROOT ) ; MST[experimental.NakedReceiverMutator]MSP[]
encoding = encoding . substring ( 1 , encoding . length () - 1 ) ; } } } return encoding ; } static boolean isAppXml ( final String mime ) { return mime != null && MST[ReturnValsMutator]MSP[] ( mime . equals ( lr_8 ) ||
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR6Mutator]MSP[] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
if ( cTEnc . equals ( UTF_16 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_16 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR5Mutator]MSP[]
if ( cTEnc . equals ( UTF_16 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_16 ) ) { MST[rv.ROR3Mutator]MSP[] return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ;
final int i = httpContentType . indexOf ( lr_3 ) ; if ( i >= 0 ) { MST[rv.UOI2Mutator]MSP[] mime = httpContentType . substring ( 0 , i ) ; } else { mime = httpContentType ; } mime = mime . trim () ; } return mime ; }
final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR1Mutator]MSP[] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR5Mutator]MSP[] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
if ( guessedEnc != null ) { final byte [] bytes = new byte [ BUFFER_SIZE ] ; is . mark ( BUFFER_SIZE ) ; int offset = 0 ; MST[rv.CRCR6Mutator]MSP[] int max = BUFFER_SIZE ; int c = is . read ( bytes , offset , max ) ;
( mime . equals ( lr_2 ) || mime . equals ( lr_13 ) || mime . startsWith ( lr_14 ) && mime . endsWith ( lr_12 ) ) ; MST[NonVoidMethodCallMutator]MSP[] }
if ( httpContentType != null && httpContentType . startsWith ( lr_1 ) ) { httpContentType = httpContentType . substring ( lr_1 . length () ) ; MST[NonVoidMethodCallMutator]MSP[] httpContentType = lr_2 + httpContentType ; try { return calculateHttpEncoding ( httpContentType , ex . getBomEncoding () ,
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } final String msg = MessageFormat . format ( RAW_EX_2 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR3Mutator]MSP[] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
mime . equals ( lr_9 ) || mime . equals ( lr_10 ) || mime . startsWith ( lr_11 ) && mime . endsWith ( lr_12 ) ) ; MST[rv.CRCR3Mutator]MSP[] } static boolean isTextXml ( final String mime ) { return mime != null &&
final String cTEnc = getContentTypeEncoding ( httpContentType ) ; final boolean appXml = isAppXml ( cTMime ) ; final boolean textXml = isTextXml ( cTMime ) ; if ( ! appXml && ! textXml ) { MST[rv.UOI4Mutator]MSP[]
( mime . equals ( lr_2 ) || mime . equals ( lr_13 ) || mime . startsWith ( lr_14 ) && mime . endsWith ( lr_12 ) ) ; MST[rv.ROR2Mutator]MSP[] }
final String msg = MessageFormat . format ( HTTP_EX_3 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[InlineConstantMutator]MSP[] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( cTEnc == null ) {
if ( httpContentType != null && httpContentType . startsWith ( lr_1 ) ) { MST[rv.ROR4Mutator]MSP[] httpContentType = httpContentType . substring ( lr_1 . length () ) ; httpContentType = lr_2 + httpContentType ; try { return calculateHttpEncoding ( httpContentType , ex . getBomEncoding () ,
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( xmlEnc != null && ! xmlEnc . equals ( UTF_8 ) ) { MST[rv.ROR3Mutator]MSP[] final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR3Mutator]MSP[] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
( mime . equals ( lr_2 ) || mime . equals ( lr_13 ) || mime . startsWith ( lr_14 ) && mime . endsWith ( lr_12 ) ) ; MST[rv.CRCR6Mutator]MSP[] }
( mime . equals ( lr_2 ) || mime . equals ( lr_13 ) || mime . startsWith ( lr_14 ) && mime . endsWith ( lr_12 ) ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] }
if ( xmlGuessEnc == null || xmlEnc == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return defaultEncoding == null ? UTF_8 : defaultEncoding ; } if ( xmlEnc . equals ( UTF_16 ) && ( xmlGuessEnc . equals ( UTF_16BE ) || xmlGuessEnc . equals ( UTF_16LE ) ) ) { return xmlGuessEnc ;
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { MST[rv.UOI3Mutator]MSP[] offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ;
( mime . equals ( lr_2 ) || MST[NegateConditionalsMutator]MSP[] mime . equals ( lr_13 ) || mime . startsWith ( lr_14 ) && mime . endsWith ( lr_12 ) ) ; }
final String bomEnc = bom . getBOMCharsetName () ; final String xmlGuessEnc = pis . getBOMCharsetName () ; final String xmlEnc = getXmlProlog ( pis , xmlGuessEnc ) ; try { return calculateHttpEncoding ( httpContentType , bomEnc , MST[rv.UOI2Mutator]MSP[] xmlGuessEnc , xmlEnc , lenient ) ;
final String postMime = httpContentType . substring ( i + 1 ) ; final Matcher m = CHARSET_PATTERN . matcher ( postMime ) ; encoding = m . find () ? m . group ( 1 ) : null ; MST[NonVoidMethodCallMutator]MSP[]
throw new IOException ( lr_6 + offset + lr_7 ) ; } final int bytesRead = offset ; MST[rv.UOI3Mutator]MSP[] if ( bytesRead > 0 ) { is . reset () ; final BufferedReader bReader = new BufferedReader ( new StringReader (
if ( cTEnc . equals ( UTF_16 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_16 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR6Mutator]MSP[]
if ( appXml ) { return calculateRawEncoding ( bomEnc , xmlGuessEnc , xmlEnc ) ; } return defaultEncoding == null ? US_ASCII : defaultEncoding ; } if ( cTEnc . equals ( UTF_16BE ) || cTEnc . equals ( UTF_16LE ) ) { MST[rv.ROR3Mutator]MSP[] if ( bomEnc != null ) {
final String postMime = httpContentType . substring ( i + 1 ) ; MST[rv.AOR3Mutator]MSP[] final Matcher m = CHARSET_PATTERN . matcher ( postMime ) ; encoding = m . find () ? m . group ( 1 ) : null ;
if ( cTEnc . equals ( UTF_16 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_16 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR3Mutator]MSP[]
encoding = encoding . substring ( 1 , encoding . length () - 1 ) ; MST[rv.CRCR4Mutator]MSP[] } } } return encoding ; } static boolean isAppXml ( final String mime ) { return mime != null && ( mime . equals ( lr_8 ) ||
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } if ( bomEnc . equals ( UTF_32BE ) || bomEnc . equals ( UTF_32LE ) ) { if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( bomEnc ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } final String msg = MessageFormat . format ( RAW_EX_2 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR6Mutator]MSP[] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
if ( guessedEnc != null ) { final byte [] bytes = new byte [ BUFFER_SIZE ] ; is . mark ( BUFFER_SIZE ) ; int offset = 0 ; int max = BUFFER_SIZE ; int c = is . read ( bytes , offset , max ) ; MST[rv.UOI3Mutator]MSP[]
final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR5Mutator]MSP[] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
final String msg = MessageFormat . format ( HTTP_EX_3 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR3Mutator]MSP[] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( cTEnc == null ) {
} return xmlEnc ; } if ( bomEnc . equals ( UTF_8 ) ) { if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( UTF_8 ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR2Mutator]MSP[]
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_16 ) && ! xmlEnc . equals ( bomEnc ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR4Mutator]MSP[]
final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR6Mutator]MSP[] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
if ( xmlGuessEnc == null || xmlEnc == null ) { return defaultEncoding == null ? UTF_8 : defaultEncoding ; } if ( xmlEnc . equals ( UTF_16 ) && ( xmlGuessEnc . equals ( UTF_16BE ) || xmlGuessEnc . equals ( UTF_16LE ) ) ) { MST[NonVoidMethodCallMutator]MSP[] return xmlGuessEnc ;
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { MST[rv.UOI2Mutator]MSP[] offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ;
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { MST[rv.UOI4Mutator]MSP[] offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ;
mime . equals ( lr_9 ) || MST[rv.ROR2Mutator]MSP[] mime . equals ( lr_10 ) || mime . startsWith ( lr_11 ) && mime . endsWith ( lr_12 ) ) ; } static boolean isTextXml ( final String mime ) { return mime != null &&
encoding = encoding != null ? encoding . toUpperCase ( Locale . ROOT ) : null ; MST[NegateConditionalsMutator]MSP[] } } return encoding ; } private static String getXmlProlog ( final InputStream is , final String guessedEnc ) throws IOException { String encoding = null ;
} return xmlEnc ; } if ( bomEnc . equals ( UTF_8 ) ) { MST[NonVoidMethodCallMutator]MSP[] if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( UTF_8 ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ;
static String getContentTypeEncoding ( final String httpContentType ) { String encoding = null ; if ( httpContentType != null ) { final int i = httpContentType . indexOf ( lr_3 ) ; if ( i > - 1 ) { MST[rv.ROR4Mutator]MSP[]
xmlProlog . substring ( 0 , firstGT + 1 ) ) ) ; MST[ConstructorCallMutator]MSP[] final StringBuffer prolog = new StringBuffer () ; String line = bReader . readLine () ; while ( line != null ) { prolog . append ( line ) ; line = bReader . readLine () ;
if ( cTEnc . equals ( UTF_16 ) ) { MST[NonVoidMethodCallMutator]MSP[] if ( bomEnc != null && bomEnc . startsWith ( UTF_16 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ;
if ( cTEnc . equals ( UTF_32 ) ) { if ( bomEnc != null && bomEnc . startsWith ( UTF_32 ) ) { return bomEnc ; } final String msg = MessageFormat . format ( HTTP_EX_2 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR3Mutator]MSP[]
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { MST[rv.ROR1Mutator]MSP[] offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ;
throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( cTEnc . equals ( UTF_32BE ) || cTEnc . equals ( UTF_32LE ) ) { MST[rv.ROR3Mutator]MSP[] if ( bomEnc != null ) {
encoding = encoding . substring ( 1 , encoding . length () - 1 ) ; MST[rv.CRCR3Mutator]MSP[] } } } return encoding ; } static boolean isAppXml ( final String mime ) { return mime != null && ( mime . equals ( lr_8 ) ||
if ( xmlGuessEnc == null || xmlEnc == null ) { return defaultEncoding == null ? UTF_8 : defaultEncoding ; } if ( xmlEnc . equals ( UTF_16 ) && ( xmlGuessEnc . equals ( UTF_16BE ) || xmlGuessEnc . equals ( UTF_16LE ) ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return xmlGuessEnc ;
mime . equals ( lr_9 ) || mime . equals ( lr_10 ) || MST[rv.ROR4Mutator]MSP[] mime . startsWith ( lr_11 ) && mime . endsWith ( lr_12 ) ) ; } static boolean isTextXml ( final String mime ) { return mime != null &&
throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; } return bomEnc ; } if ( bomEnc . equals ( UTF_16BE ) || bomEnc . equals ( UTF_16LE ) ) { MST[rv.ROR1Mutator]MSP[] if ( xmlGuessEnc != null && ! xmlGuessEnc . equals ( bomEnc ) ) {
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR3Mutator]MSP[] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } return cTEnc ; }
final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[InlineConstantMutator]MSP[] throw new XmlStreamReaderException ( msg , bomEnc , xmlGuessEnc , xmlEnc ) ; }
if ( xmlEnc != null && ! xmlEnc . equals ( UTF_16 ) && ! xmlEnc . equals ( bomEnc ) ) { final String msg = MessageFormat . format ( RAW_EX_1 , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR2Mutator]MSP[]
throw new IOException ( lr_6 + offset + lr_7 ) ; } final int bytesRead = offset ; if ( bytesRead > 0 ) { MST[rv.ROR1Mutator]MSP[] is . reset () ; final BufferedReader bReader = new BufferedReader ( new StringReader (
static String getContentTypeEncoding ( final String httpContentType ) { String encoding = null ; if ( httpContentType != null ) { final int i = httpContentType . indexOf ( lr_3 ) ; if ( i > - 1 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[]
final String msg = MessageFormat . format ( HTTP_EX_1 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[ConstructorCallMutator]MSP[] } return cTEnc ; }
int firstGT = - 1 ; String xmlProlog = lr_4 ; while ( c != - 1 && firstGT == - 1 && offset < BUFFER_SIZE ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] offset += c ; max -= c ; c = is . read ( bytes , offset , max ) ;
final String msg = MessageFormat . format ( HTTP_EX_3 , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; MST[rv.CRCR1Mutator]MSP[] throw new XmlStreamReaderException ( msg , cTMime , cTEnc , bomEnc , xmlGuessEnc , xmlEnc ) ; } if ( cTEnc == null ) {
if ( lenient ) { MST[rv.ROR4Mutator]MSP[] return doLenientDetection ( null , ex ) ; } throw ex ; } } private String doHttpStream ( final BOMInputStream bom , final BOMInputStream pis , final String httpContentType , final boolean lenient ) throws IOException {
encoding = encoding . substring ( 1 , encoding . length () - 1 ) ; } } } return encoding ; } static boolean isAppXml ( final String mime ) { return mime != null && ( mime . equals ( lr_8 ) || MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
ex . getXmlGuessEncoding () , ex . getXmlEncoding () , true ) ; MST[rv.CRCR2Mutator]MSP[] } catch ( final XmlStreamReaderException ex2 ) { ex = ex2 ; } } String encoding = ex . getXmlEncoding () ; if ( encoding == null ) { encoding = ex . getContentTypeEncoding () ; }
