encoding = m . group ( 1 ) . toUpperCase ( Locale . ROOT ) ; encoding = encoding . substring ( 1 , encoding . length () - 1 ) ; } else { encoding = defaultEncoding ; MST[experimental.MemberVariableMutator]MSP[N] } } else {
private void detectEncoding ( final char [] cbuf , final int off , final int len ) throws IOException { int size = len ; final StringBuffer xmlProlog = xmlPrologWriter . getBuffer () ; if ( xmlProlog . length () + len > BUFFER_SIZE ) { MST[rv.CRCR4Mutator]MSP[N]
final int xmlPrologEnd = xmlProlog . indexOf ( lr_2 ) ; if ( xmlPrologEnd > 0 ) { MST[rv.UOI1Mutator]MSP[S] final Matcher m = ENCODING_PATTERN . matcher ( xmlProlog . substring ( 0 , xmlPrologEnd ) ) ; if ( m . find () ) {
final int xmlPrologEnd = xmlProlog . indexOf ( lr_2 ) ; if ( xmlPrologEnd > 0 ) { MST[rv.UOI3Mutator]MSP[S] final Matcher m = ENCODING_PATTERN . matcher ( xmlProlog . substring ( 0 , xmlPrologEnd ) ) ; if ( m . find () ) {
private void detectEncoding ( final char [] cbuf , final int off , final int len ) throws IOException { int size = len ; final StringBuffer xmlProlog = xmlPrologWriter . getBuffer () ; if ( xmlProlog . length () + len > BUFFER_SIZE ) { MST[rv.AOR2Mutator]MSP[S]
size = BUFFER_SIZE - xmlProlog . length () ; } xmlPrologWriter . write ( cbuf , off , size ) ; if ( xmlProlog . length () >= 5 ) { if ( xmlProlog . substring ( 0 , 5 ) . equals ( lr_1 ) ) { MST[rv.CRCR6Mutator]MSP[N]
final int xmlPrologEnd = xmlProlog . indexOf ( lr_2 ) ; if ( xmlPrologEnd > 0 ) { final Matcher m = ENCODING_PATTERN . matcher ( xmlProlog . substring ( 0 , xmlPrologEnd ) ) ; if ( m . find () ) { MST[NonVoidMethodCallMutator]MSP[S]
size = BUFFER_SIZE - xmlProlog . length () ; } xmlPrologWriter . write ( cbuf , off , size ) ; if ( xmlProlog . length () >= 5 ) { if ( xmlProlog . substring ( 0 , 5 ) . equals ( lr_1 ) ) { MST[InlineConstantMutator]MSP[N]
if ( xmlProlog . length () >= BUFFER_SIZE ) { MST[rv.CRCR4Mutator]MSP[S] encoding = defaultEncoding ; } } } else { encoding = defaultEncoding ; } if ( encoding != null ) { xmlPrologWriter = null ; writer = new OutputStreamWriter ( out , encoding ) ;
public void write ( final char [] cbuf , final int off , final int len ) throws IOException { if ( xmlPrologWriter != null ) { MST[NegateConditionalsMutator]MSP[N] detectEncoding ( cbuf , off , len ) ; } else { writer . write ( cbuf , off , len ) ;
public void write ( final char [] cbuf , final int off , final int len ) throws IOException { if ( xmlPrologWriter != null ) { detectEncoding ( cbuf , off , len ) ; MST[rv.UOI3Mutator]MSP[N] } else { writer . write ( cbuf , off , len ) ;
public String getEncoding () { return encoding ; MST[EmptyObjectReturnValsMutator]MSP[N] } public String getDefaultEncoding () { return defaultEncoding ; } @Override public void close () throws IOException { if ( writer == null ) { encoding = defaultEncoding ; writer = new OutputStreamWriter ( out , encoding ) ;
size = BUFFER_SIZE - xmlProlog . length () ; } xmlPrologWriter . write ( cbuf , off , size ) ; if ( xmlProlog . length () >= 5 ) { if ( xmlProlog . substring ( 0 , 5 ) . equals ( lr_1 ) ) { MST[rv.CRCR3Mutator]MSP[N]
encoding = m . group ( 1 ) . toUpperCase ( Locale . ROOT ) ; MST[experimental.NakedReceiverMutator]MSP[N] encoding = encoding . substring ( 1 , encoding . length () - 1 ) ; } else { encoding = defaultEncoding ; } } else {
if ( xmlProlog . length () >= BUFFER_SIZE ) { MST[NonVoidMethodCallMutator]MSP[S] encoding = defaultEncoding ; } } } else { encoding = defaultEncoding ; } if ( encoding != null ) { xmlPrologWriter = null ; writer = new OutputStreamWriter ( out , encoding ) ;
writer . write ( xmlProlog . toString () ) ; if ( len > size ) { MST[rv.UOI3Mutator]MSP[N] writer . write ( cbuf , off + size , len - size ) ; } } } } @Override
public String getEncoding () { return encoding ; } public String getDefaultEncoding () { return defaultEncoding ; } @Override public void close () throws IOException { if ( writer == null ) { MST[NegateConditionalsMutator]MSP[N] encoding = defaultEncoding ; writer = new OutputStreamWriter ( out , encoding ) ;
size = BUFFER_SIZE - xmlProlog . length () ; } xmlPrologWriter . write ( cbuf , off , size ) ; MST[rv.UOI3Mutator]MSP[N] if ( xmlProlog . length () >= 5 ) { if ( xmlProlog . substring ( 0 , 5 ) . equals ( lr_1 ) ) {
final int xmlPrologEnd = xmlProlog . indexOf ( lr_2 ) ; if ( xmlPrologEnd > 0 ) { final Matcher m = ENCODING_PATTERN . matcher ( xmlProlog . substring ( 0 , xmlPrologEnd ) ) ; if ( m . find () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S]
size = BUFFER_SIZE - xmlProlog . length () ; } xmlPrologWriter . write ( cbuf , off , size ) ; if ( xmlProlog . length () >= 5 ) { MST[rv.ROR2Mutator]MSP[N] if ( xmlProlog . substring ( 0 , 5 ) . equals ( lr_1 ) ) {
writer . write ( xmlPrologWriter . toString () ) ; } writer . close () ; } @Override public void flush () throws IOException { if ( writer != null ) { MST[rv.ROR5Mutator]MSP[N] writer . flush () ; } }
size = BUFFER_SIZE - xmlProlog . length () ; } xmlPrologWriter . write ( cbuf , off , size ) ; if ( xmlProlog . length () >= 5 ) { MST[rv.ROR5Mutator]MSP[N] if ( xmlProlog . substring ( 0 , 5 ) . equals ( lr_1 ) ) {
encoding = m . group ( 1 ) . toUpperCase ( Locale . ROOT ) ; encoding = encoding . substring ( 1 , encoding . length () - 1 ) ; MST[rv.CRCR5Mutator]MSP[N] } else { encoding = defaultEncoding ; } } else {
private void detectEncoding ( final char [] cbuf , final int off , final int len ) throws IOException { int size = len ; final StringBuffer xmlProlog = xmlPrologWriter . getBuffer () ; if ( xmlProlog . length () + len > BUFFER_SIZE ) { MST[rv.AOD2Mutator]MSP[S]
if ( xmlProlog . length () >= BUFFER_SIZE ) { MST[ConditionalsBoundaryMutator]MSP[S] encoding = defaultEncoding ; } } } else { encoding = defaultEncoding ; } if ( encoding != null ) { xmlPrologWriter = null ; writer = new OutputStreamWriter ( out , encoding ) ;
writer . write ( xmlProlog . toString () ) ; if ( len > size ) { MST[rv.ABSMutator]MSP[N] writer . write ( cbuf , off + size , len - size ) ; } } } } @Override
if ( xmlProlog . length () >= BUFFER_SIZE ) { MST[rv.ROR5Mutator]MSP[S] encoding = defaultEncoding ; } } } else { encoding = defaultEncoding ; } if ( encoding != null ) { xmlPrologWriter = null ; writer = new OutputStreamWriter ( out , encoding ) ;
encoding = m . group ( 1 ) . toUpperCase ( Locale . ROOT ) ; MST[rv.CRCR3Mutator]MSP[N] encoding = encoding . substring ( 1 , encoding . length () - 1 ) ; } else { encoding = defaultEncoding ; } } else {
public String getEncoding () { return encoding ; } public String getDefaultEncoding () { return defaultEncoding ; } @Override public void close () throws IOException { if ( writer == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] encoding = defaultEncoding ; writer = new OutputStreamWriter ( out , encoding ) ;
encoding = m . group ( 1 ) . toUpperCase ( Locale . ROOT ) ; MST[NonVoidMethodCallMutator]MSP[N] encoding = encoding . substring ( 1 , encoding . length () - 1 ) ; } else { encoding = defaultEncoding ; } } else {
public void write ( final char [] cbuf , final int off , final int len ) throws IOException { if ( xmlPrologWriter != null ) { detectEncoding ( cbuf , off , len ) ; MST[rv.ABSMutator]MSP[N] } else { writer . write ( cbuf , off , len ) ;
private void detectEncoding ( final char [] cbuf , final int off , final int len ) throws IOException { int size = len ; MST[rv.UOI4Mutator]MSP[N] final StringBuffer xmlProlog = xmlPrologWriter . getBuffer () ; if ( xmlProlog . length () + len > BUFFER_SIZE ) {
private void detectEncoding ( final char [] cbuf , final int off , final int len ) throws IOException { int size = len ; final StringBuffer xmlProlog = xmlPrologWriter . getBuffer () ; if ( xmlProlog . length () + len > BUFFER_SIZE ) { MST[NonVoidMethodCallMutator]MSP[S]
private void detectEncoding ( final char [] cbuf , final int off , final int len ) throws IOException { int size = len ; final StringBuffer xmlProlog = xmlPrologWriter . getBuffer () ; if ( xmlProlog . length () + len > BUFFER_SIZE ) { MST[rv.ROR3Mutator]MSP[N]
final int xmlPrologEnd = xmlProlog . indexOf ( lr_2 ) ; if ( xmlPrologEnd > 0 ) { final Matcher m = ENCODING_PATTERN . matcher ( xmlProlog . substring ( 0 , MST[rv.UOI3Mutator]MSP[N] xmlPrologEnd ) ) ; if ( m . find () ) {
size = BUFFER_SIZE - xmlProlog . length () ; } xmlPrologWriter . write ( cbuf , off , size ) ; if ( xmlProlog . length () >= 5 ) { MST[rv.CRCR1Mutator]MSP[N] if ( xmlProlog . substring ( 0 , 5 ) . equals ( lr_1 ) ) {
size = BUFFER_SIZE - xmlProlog . length () ; } xmlPrologWriter . write ( cbuf , off , size ) ; if ( xmlProlog . length () >= 5 ) { if ( xmlProlog . substring ( 0 , 5 ) . equals ( lr_1 ) ) { MST[InlineConstantMutator]MSP[N]
public String getEncoding () { return encoding ; } public String getDefaultEncoding () { return defaultEncoding ; MST[EmptyObjectReturnValsMutator]MSP[N] } @Override public void close () throws IOException { if ( writer == null ) { encoding = defaultEncoding ; writer = new OutputStreamWriter ( out , encoding ) ;
if ( xmlProlog . length () >= BUFFER_SIZE ) { MST[rv.ROR3Mutator]MSP[S] encoding = defaultEncoding ; } } } else { encoding = defaultEncoding ; } if ( encoding != null ) { xmlPrologWriter = null ; writer = new OutputStreamWriter ( out , encoding ) ;
if ( xmlProlog . length () >= BUFFER_SIZE ) { MST[rv.CRCR1Mutator]MSP[S] encoding = defaultEncoding ; } } } else { encoding = defaultEncoding ; } if ( encoding != null ) { xmlPrologWriter = null ; writer = new OutputStreamWriter ( out , encoding ) ;
private void detectEncoding ( final char [] cbuf , final int off , final int len ) throws IOException { int size = len ; MST[rv.ABSMutator]MSP[N] final StringBuffer xmlProlog = xmlPrologWriter . getBuffer () ; if ( xmlProlog . length () + len > BUFFER_SIZE ) {
writer . write ( xmlPrologWriter . toString () ) ; } writer . close () ; } @Override public void flush () throws IOException { if ( writer != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] writer . flush () ; } }
encoding = m . group ( 1 ) . toUpperCase ( Locale . ROOT ) ; MST[InlineConstantMutator]MSP[N] encoding = encoding . substring ( 1 , encoding . length () - 1 ) ; } else { encoding = defaultEncoding ; } } else {
encoding = m . group ( 1 ) . toUpperCase ( Locale . ROOT ) ; encoding = encoding . substring ( 1 , encoding . length () - 1 ) ; MST[experimental.NakedReceiverMutator]MSP[N] } else { encoding = defaultEncoding ; } } else {
public void write ( final char [] cbuf , final int off , final int len ) throws IOException { if ( xmlPrologWriter != null ) { detectEncoding ( cbuf , off , len ) ; MST[rv.UOI3Mutator]MSP[N] } else { writer . write ( cbuf , off , len ) ;
if ( xmlProlog . length () >= BUFFER_SIZE ) { MST[rv.CRCR5Mutator]MSP[S] encoding = defaultEncoding ; } } } else { encoding = defaultEncoding ; } if ( encoding != null ) { xmlPrologWriter = null ; writer = new OutputStreamWriter ( out , encoding ) ;
final int xmlPrologEnd = xmlProlog . indexOf ( lr_2 ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( xmlPrologEnd > 0 ) { final Matcher m = ENCODING_PATTERN . matcher ( xmlProlog . substring ( 0 , xmlPrologEnd ) ) ; if ( m . find () ) {
public void write ( final char [] cbuf , final int off , final int len ) throws IOException { if ( xmlPrologWriter != null ) { detectEncoding ( cbuf , off , len ) ; MST[rv.UOI1Mutator]MSP[S] } else { writer . write ( cbuf , off , len ) ;
size = BUFFER_SIZE - xmlProlog . length () ; } xmlPrologWriter . write ( cbuf , off , size ) ; MST[rv.UOI2Mutator]MSP[S] if ( xmlProlog . length () >= 5 ) { if ( xmlProlog . substring ( 0 , 5 ) . equals ( lr_1 ) ) {
if ( xmlProlog . length () >= BUFFER_SIZE ) { MST[rv.CRCR3Mutator]MSP[S] encoding = defaultEncoding ; } } } else { encoding = defaultEncoding ; } if ( encoding != null ) { xmlPrologWriter = null ; writer = new OutputStreamWriter ( out , encoding ) ;
size = BUFFER_SIZE - xmlProlog . length () ; } xmlPrologWriter . write ( cbuf , off , size ) ; MST[rv.UOI3Mutator]MSP[N] if ( xmlProlog . length () >= 5 ) { if ( xmlProlog . substring ( 0 , 5 ) . equals ( lr_1 ) ) {
final int xmlPrologEnd = xmlProlog . indexOf ( lr_2 ) ; if ( xmlPrologEnd > 0 ) { final Matcher m = ENCODING_PATTERN . matcher ( xmlProlog . substring ( 0 , MST[rv.CRCR1Mutator]MSP[S] xmlPrologEnd ) ) ; if ( m . find () ) {
writer . write ( xmlPrologWriter . toString () ) ; } writer . close () ; } @Override public void flush () throws IOException { if ( writer != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] writer . flush () ; } }
size = BUFFER_SIZE - xmlProlog . length () ; } xmlPrologWriter . write ( cbuf , off , size ) ; if ( xmlProlog . length () >= 5 ) { if ( xmlProlog . substring ( 0 , 5 ) . equals ( lr_1 ) ) { MST[NonVoidMethodCallMutator]MSP[N]
if ( xmlProlog . length () >= BUFFER_SIZE ) { MST[rv.ROR2Mutator]MSP[S] encoding = defaultEncoding ; } } } else { encoding = defaultEncoding ; } if ( encoding != null ) { xmlPrologWriter = null ; writer = new OutputStreamWriter ( out , encoding ) ;
size = BUFFER_SIZE - xmlProlog . length () ; } xmlPrologWriter . write ( cbuf , off , size ) ; MST[rv.UOI1Mutator]MSP[S] if ( xmlProlog . length () >= 5 ) { if ( xmlProlog . substring ( 0 , 5 ) . equals ( lr_1 ) ) {
if ( xmlProlog . length () >= BUFFER_SIZE ) { MST[rv.ROR4Mutator]MSP[S] encoding = defaultEncoding ; } } } else { encoding = defaultEncoding ; } if ( encoding != null ) { xmlPrologWriter = null ; writer = new OutputStreamWriter ( out , encoding ) ;
writer . write ( xmlProlog . toString () ) ; if ( len > size ) { MST[NegateConditionalsMutator]MSP[N] writer . write ( cbuf , off + size , len - size ) ; } } } } @Override
size = BUFFER_SIZE - xmlProlog . length () ; } xmlPrologWriter . write ( cbuf , off , size ) ; if ( xmlProlog . length () >= 5 ) { if ( xmlProlog . substring ( 0 , 5 ) . equals ( lr_1 ) ) { MST[rv.ROR2Mutator]MSP[S]
size = BUFFER_SIZE - xmlProlog . length () ; } xmlPrologWriter . write ( cbuf , off , size ) ; MST[rv.UOI4Mutator]MSP[N] if ( xmlProlog . length () >= 5 ) { if ( xmlProlog . substring ( 0 , 5 ) . equals ( lr_1 ) ) {
size = BUFFER_SIZE - xmlProlog . length () ; } xmlPrologWriter . write ( cbuf , off , size ) ; if ( xmlProlog . length () >= 5 ) { if ( xmlProlog . substring ( 0 , 5 ) . equals ( lr_1 ) ) { MST[rv.ROR4Mutator]MSP[N]
size = BUFFER_SIZE - xmlProlog . length () ; } xmlPrologWriter . write ( cbuf , off , size ) ; if ( xmlProlog . length () >= 5 ) { MST[NonVoidMethodCallMutator]MSP[N] if ( xmlProlog . substring ( 0 , 5 ) . equals ( lr_1 ) ) {
final int xmlPrologEnd = xmlProlog . indexOf ( lr_2 ) ; if ( xmlPrologEnd > 0 ) { final Matcher m = ENCODING_PATTERN . matcher ( xmlProlog . substring ( 0 , MST[rv.CRCR5Mutator]MSP[S] xmlPrologEnd ) ) ; if ( m . find () ) {
final int xmlPrologEnd = xmlProlog . indexOf ( lr_2 ) ; if ( xmlPrologEnd > 0 ) { final Matcher m = ENCODING_PATTERN . matcher ( xmlProlog . substring ( 0 , MST[rv.CRCR3Mutator]MSP[N] xmlPrologEnd ) ) ; if ( m . find () ) {
encoding = m . group ( 1 ) . toUpperCase ( Locale . ROOT ) ; encoding = encoding . substring ( 1 , encoding . length () - 1 ) ; MST[NonVoidMethodCallMutator]MSP[S] } else { encoding = defaultEncoding ; } } else {
encoding = m . group ( 1 ) . toUpperCase ( Locale . ROOT ) ; encoding = encoding . substring ( 1 , encoding . length () - 1 ) ; MST[rv.CRCR6Mutator]MSP[N] } else { encoding = defaultEncoding ; } } else {
size = BUFFER_SIZE - xmlProlog . length () ; } xmlPrologWriter . write ( cbuf , off , size ) ; if ( xmlProlog . length () >= 5 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] if ( xmlProlog . substring ( 0 , 5 ) . equals ( lr_1 ) ) {
encoding = m . group ( 1 ) . toUpperCase ( Locale . ROOT ) ; encoding = encoding . substring ( 1 , encoding . length () - 1 ) ; MST[rv.CRCR4Mutator]MSP[N] } else { encoding = defaultEncoding ; } } else {
size = BUFFER_SIZE - xmlProlog . length () ; } xmlPrologWriter . write ( cbuf , off , size ) ; if ( xmlProlog . length () >= 5 ) { MST[ConditionalsBoundaryMutator]MSP[S] if ( xmlProlog . substring ( 0 , 5 ) . equals ( lr_1 ) ) {
encoding = m . group ( 1 ) . toUpperCase ( Locale . ROOT ) ; encoding = encoding . substring ( 1 , encoding . length () - 1 ) ; MST[rv.AOD1Mutator]MSP[N] } else { encoding = defaultEncoding ; } } else {
size = BUFFER_SIZE - xmlProlog . length () ; } xmlPrologWriter . write ( cbuf , off , size ) ; if ( xmlProlog . length () >= 5 ) { if ( xmlProlog . substring ( 0 , 5 ) . equals ( lr_1 ) ) { MST[rv.ROR1Mutator]MSP[S]
encoding = m . group ( 1 ) . toUpperCase ( Locale . ROOT ) ; encoding = encoding . substring ( 1 , encoding . length () - 1 ) ; MST[rv.CRCR2Mutator]MSP[N] } else { encoding = defaultEncoding ; } } else {
writer . write ( xmlPrologWriter . toString () ) ; } writer . close () ; } @Override public void flush () throws IOException { if ( writer != null ) { MST[NegateConditionalsMutator]MSP[N] writer . flush () ; } }
final int xmlPrologEnd = xmlProlog . indexOf ( lr_2 ) ; if ( xmlPrologEnd > 0 ) { final Matcher m = ENCODING_PATTERN . matcher ( xmlProlog . substring ( 0 , xmlPrologEnd ) ) ; if ( m . find () ) { MST[rv.ROR2Mutator]MSP[N]
final int xmlPrologEnd = xmlProlog . indexOf ( lr_2 ) ; if ( xmlPrologEnd > 0 ) { final Matcher m = ENCODING_PATTERN . matcher ( xmlProlog . substring ( 0 , xmlPrologEnd ) ) ; if ( m . find () ) { MST[rv.ROR4Mutator]MSP[S]
private void detectEncoding ( final char [] cbuf , final int off , final int len ) throws IOException { int size = len ; final StringBuffer xmlProlog = xmlPrologWriter . getBuffer () ; if ( xmlProlog . length () + len > BUFFER_SIZE ) { MST[rv.UOI3Mutator]MSP[N]
size = BUFFER_SIZE - xmlProlog . length () ; } xmlPrologWriter . write ( cbuf , off , size ) ; if ( xmlProlog . length () >= 5 ) { if ( xmlProlog . substring ( 0 , 5 ) . equals ( lr_1 ) ) { MST[rv.CRCR2Mutator]MSP[N]
public void write ( final char [] cbuf , final int off , final int len ) throws IOException { if ( xmlPrologWriter != null ) { detectEncoding ( cbuf , off , len ) ; MST[rv.UOI1Mutator]MSP[S] } else { writer . write ( cbuf , off , len ) ;
size = BUFFER_SIZE - xmlProlog . length () ; } xmlPrologWriter . write ( cbuf , off , size ) ; if ( xmlProlog . length () >= 5 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] if ( xmlProlog . substring ( 0 , 5 ) . equals ( lr_1 ) ) {
final int xmlPrologEnd = xmlProlog . indexOf ( lr_2 ) ; if ( xmlPrologEnd > 0 ) { MST[NegateConditionalsMutator]MSP[N] final Matcher m = ENCODING_PATTERN . matcher ( xmlProlog . substring ( 0 , xmlPrologEnd ) ) ; if ( m . find () ) {
size = BUFFER_SIZE - xmlProlog . length () ; } xmlPrologWriter . write ( cbuf , off , size ) ; MST[rv.UOI1Mutator]MSP[S] if ( xmlProlog . length () >= 5 ) { if ( xmlProlog . substring ( 0 , 5 ) . equals ( lr_1 ) ) {
if ( xmlProlog . length () >= BUFFER_SIZE ) { MST[rv.ROR1Mutator]MSP[S] encoding = defaultEncoding ; } } } else { encoding = defaultEncoding ; } if ( encoding != null ) { xmlPrologWriter = null ; writer = new OutputStreamWriter ( out , encoding ) ;
if ( xmlProlog . length () >= BUFFER_SIZE ) { encoding = defaultEncoding ; } } } else { encoding = defaultEncoding ; } if ( encoding != null ) { xmlPrologWriter = null ; MST[experimental.MemberVariableMutator]MSP[N] writer = new OutputStreamWriter ( out , encoding ) ;
writer . write ( xmlProlog . toString () ) ; if ( len > size ) { MST[rv.UOI1Mutator]MSP[N] writer . write ( cbuf , off + size , len - size ) ; } } } } @Override
writer . write ( xmlProlog . toString () ) ; if ( len > size ) { MST[rv.ROR5Mutator]MSP[N] writer . write ( cbuf , off + size , len - size ) ; } } } } @Override
public String getEncoding () { return encoding ; MST[ReturnValsMutator]MSP[N] } public String getDefaultEncoding () { return defaultEncoding ; } @Override public void close () throws IOException { if ( writer == null ) { encoding = defaultEncoding ; writer = new OutputStreamWriter ( out , encoding ) ;
size = BUFFER_SIZE - xmlProlog . length () ; } xmlPrologWriter . write ( cbuf , off , size ) ; if ( xmlProlog . length () >= 5 ) { MST[rv.ROR4Mutator]MSP[N] if ( xmlProlog . substring ( 0 , 5 ) . equals ( lr_1 ) ) {
writer . write ( xmlProlog . toString () ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( len > size ) { writer . write ( cbuf , off + size , len - size ) ; } } } } @Override
private void detectEncoding ( final char [] cbuf , final int off , final int len ) throws IOException { int size = len ; final StringBuffer xmlProlog = xmlPrologWriter . getBuffer () ; if ( xmlProlog . length () + len > BUFFER_SIZE ) { MST[rv.CRCR1Mutator]MSP[N]
encoding = m . group ( 1 ) . toUpperCase ( Locale . ROOT ) ; encoding = encoding . substring ( 1 , encoding . length () - 1 ) ; MST[rv.CRCR3Mutator]MSP[N] } else { encoding = defaultEncoding ; } } else {
public void write ( final char [] cbuf , final int off , final int len ) throws IOException { if ( xmlPrologWriter != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] detectEncoding ( cbuf , off , len ) ; } else { writer . write ( cbuf , off , len ) ;
private void detectEncoding ( final char [] cbuf , final int off , final int len ) throws IOException { int size = len ; final StringBuffer xmlProlog = xmlPrologWriter . getBuffer () ; if ( xmlProlog . length () + len > BUFFER_SIZE ) { MST[rv.CRCR5Mutator]MSP[S]
size = BUFFER_SIZE - xmlProlog . length () ; } xmlPrologWriter . write ( cbuf , off , size ) ; if ( xmlProlog . length () >= 5 ) { if ( xmlProlog . substring ( 0 , 5 ) . equals ( lr_1 ) ) { MST[rv.ROR3Mutator]MSP[N]
size = BUFFER_SIZE - xmlProlog . length () ; } xmlPrologWriter . write ( cbuf , off , size ) ; if ( xmlProlog . length () >= 5 ) { MST[rv.CRCR3Mutator]MSP[N] if ( xmlProlog . substring ( 0 , 5 ) . equals ( lr_1 ) ) {
if ( xmlProlog . length () >= BUFFER_SIZE ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[S] encoding = defaultEncoding ; } } } else { encoding = defaultEncoding ; } if ( encoding != null ) { xmlPrologWriter = null ; writer = new OutputStreamWriter ( out , encoding ) ;
private void detectEncoding ( final char [] cbuf , final int off , final int len ) throws IOException { int size = len ; MST[rv.UOI2Mutator]MSP[S] final StringBuffer xmlProlog = xmlPrologWriter . getBuffer () ; if ( xmlProlog . length () + len > BUFFER_SIZE ) {
size = BUFFER_SIZE - xmlProlog . length () ; } xmlPrologWriter . write ( cbuf , off , size ) ; if ( xmlProlog . length () >= 5 ) { if ( xmlProlog . substring ( 0 , 5 ) . equals ( lr_1 ) ) { MST[rv.CRCR6Mutator]MSP[N]
final int xmlPrologEnd = xmlProlog . indexOf ( lr_2 ) ; if ( xmlPrologEnd > 0 ) { final Matcher m = ENCODING_PATTERN . matcher ( xmlProlog . substring ( 0 , MST[rv.UOI1Mutator]MSP[N] xmlPrologEnd ) ) ; if ( m . find () ) {
size = BUFFER_SIZE - xmlProlog . length () ; } xmlPrologWriter . write ( cbuf , off , size ) ; if ( xmlProlog . length () >= 5 ) { MST[InlineConstantMutator]MSP[S] if ( xmlProlog . substring ( 0 , 5 ) . equals ( lr_1 ) ) {
writer . write ( xmlPrologWriter . toString () ) ; MST[NonVoidMethodCallMutator]MSP[N] } writer . close () ; } @Override public void flush () throws IOException { if ( writer != null ) { writer . flush () ; } }
size = BUFFER_SIZE - xmlProlog . length () ; } xmlPrologWriter . write ( cbuf , off , size ) ; MST[VoidMethodCallMutator]MSP[N] if ( xmlProlog . length () >= 5 ) { if ( xmlProlog . substring ( 0 , 5 ) . equals ( lr_1 ) ) {
final int xmlPrologEnd = xmlProlog . indexOf ( lr_2 ) ; if ( xmlPrologEnd > 0 ) { MST[rv.ROR2Mutator]MSP[N] final Matcher m = ENCODING_PATTERN . matcher ( xmlProlog . substring ( 0 , xmlPrologEnd ) ) ; if ( m . find () ) {
final int xmlPrologEnd = xmlProlog . indexOf ( lr_2 ) ; if ( xmlPrologEnd > 0 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] final Matcher m = ENCODING_PATTERN . matcher ( xmlProlog . substring ( 0 , xmlPrologEnd ) ) ; if ( m . find () ) {
size = BUFFER_SIZE - xmlProlog . length () ; } xmlPrologWriter . write ( cbuf , off , size ) ; if ( xmlProlog . length () >= 5 ) { if ( xmlProlog . substring ( 0 , 5 ) . equals ( lr_1 ) ) { MST[rv.ROR5Mutator]MSP[N]
final int xmlPrologEnd = xmlProlog . indexOf ( lr_2 ) ; if ( xmlPrologEnd > 0 ) { final Matcher m = ENCODING_PATTERN . matcher ( xmlProlog . substring ( 0 , xmlPrologEnd ) ) ; if ( m . find () ) { MST[rv.ROR5Mutator]MSP[N]
encoding = m . group ( 1 ) . toUpperCase ( Locale . ROOT ) ; encoding = encoding . substring ( 1 , encoding . length () - 1 ) ; MST[rv.AOR2Mutator]MSP[N] } else { encoding = defaultEncoding ; } } else {
public String getEncoding () { return encoding ; } public String getDefaultEncoding () { return defaultEncoding ; MST[ReturnValsMutator]MSP[N] } @Override public void close () throws IOException { if ( writer == null ) { encoding = defaultEncoding ; writer = new OutputStreamWriter ( out , encoding ) ;
if ( xmlProlog . length () >= BUFFER_SIZE ) { encoding = defaultEncoding ; } } } else { encoding = defaultEncoding ; MST[experimental.MemberVariableMutator]MSP[N] } if ( encoding != null ) { xmlPrologWriter = null ; writer = new OutputStreamWriter ( out , encoding ) ;
final int xmlPrologEnd = xmlProlog . indexOf ( lr_2 ) ; if ( xmlPrologEnd > 0 ) { MST[rv.ROR5Mutator]MSP[N] final Matcher m = ENCODING_PATTERN . matcher ( xmlProlog . substring ( 0 , xmlPrologEnd ) ) ; if ( m . find () ) {
final int xmlPrologEnd = xmlProlog . indexOf ( lr_2 ) ; if ( xmlPrologEnd > 0 ) { MST[rv.ROR4Mutator]MSP[S] final Matcher m = ENCODING_PATTERN . matcher ( xmlProlog . substring ( 0 , xmlPrologEnd ) ) ; if ( m . find () ) {
encoding = m . group ( 1 ) . toUpperCase ( Locale . ROOT ) ; encoding = encoding . substring ( 1 , encoding . length () - 1 ) ; MST[InlineConstantMutator]MSP[N] } else { encoding = defaultEncoding ; } } else {
private void detectEncoding ( final char [] cbuf , final int off , final int len ) throws IOException { int size = len ; final StringBuffer xmlProlog = xmlPrologWriter . getBuffer () ; if ( xmlProlog . length () + len > BUFFER_SIZE ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[S]
encoding = m . group ( 1 ) . toUpperCase ( Locale . ROOT ) ; MST[experimental.MemberVariableMutator]MSP[N] encoding = encoding . substring ( 1 , encoding . length () - 1 ) ; } else { encoding = defaultEncoding ; } } else {
private void detectEncoding ( final char [] cbuf , final int off , final int len ) throws IOException { int size = len ; final StringBuffer xmlProlog = xmlPrologWriter . getBuffer () ; if ( xmlProlog . length () + len > BUFFER_SIZE ) { MST[MathMutator]MSP[S]
if ( xmlProlog . length () >= BUFFER_SIZE ) { encoding = defaultEncoding ; } } } else { encoding = defaultEncoding ; } if ( encoding != null ) { xmlPrologWriter = null ; writer = new OutputStreamWriter ( out , encoding ) ; MST[experimental.MemberVariableMutator]MSP[N]
final int xmlPrologEnd = xmlProlog . indexOf ( lr_2 ) ; if ( xmlPrologEnd > 0 ) { final Matcher m = ENCODING_PATTERN . matcher ( xmlProlog . substring ( 0 , MST[InlineConstantMutator]MSP[S] xmlPrologEnd ) ) ; if ( m . find () ) {
if ( xmlProlog . length () >= BUFFER_SIZE ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[S] encoding = defaultEncoding ; } } } else { encoding = defaultEncoding ; } if ( encoding != null ) { xmlPrologWriter = null ; writer = new OutputStreamWriter ( out , encoding ) ;
writer . write ( xmlProlog . toString () ) ; if ( len > size ) { MST[rv.UOI2Mutator]MSP[N] writer . write ( cbuf , off + size , len - size ) ; } } } } @Override
writer . write ( xmlPrologWriter . toString () ) ; } writer . close () ; MST[VoidMethodCallMutator]MSP[N] } @Override public void flush () throws IOException { if ( writer != null ) { writer . flush () ; } }
encoding = m . group ( 1 ) . toUpperCase ( Locale . ROOT ) ; MST[rv.CRCR2Mutator]MSP[N] encoding = encoding . substring ( 1 , encoding . length () - 1 ) ; } else { encoding = defaultEncoding ; } } else {
if ( xmlProlog . length () >= BUFFER_SIZE ) { MST[InlineConstantMutator]MSP[S] encoding = defaultEncoding ; } } } else { encoding = defaultEncoding ; } if ( encoding != null ) { xmlPrologWriter = null ; writer = new OutputStreamWriter ( out , encoding ) ;
private void detectEncoding ( final char [] cbuf , final int off , final int len ) throws IOException { int size = len ; final StringBuffer xmlProlog = xmlPrologWriter . getBuffer () ; if ( xmlProlog . length () + len > BUFFER_SIZE ) { MST[rv.CRCR6Mutator]MSP[S]
encoding = m . group ( 1 ) . toUpperCase ( Locale . ROOT ) ; MST[rv.CRCR4Mutator]MSP[N] encoding = encoding . substring ( 1 , encoding . length () - 1 ) ; } else { encoding = defaultEncoding ; } } else {
private void detectEncoding ( final char [] cbuf , final int off , final int len ) throws IOException { int size = len ; final StringBuffer xmlProlog = xmlPrologWriter . getBuffer () ; if ( xmlProlog . length () + len > BUFFER_SIZE ) { MST[rv.ROR4Mutator]MSP[N]
public String getEncoding () { return encoding ; } public String getDefaultEncoding () { return defaultEncoding ; } @Override public void close () throws IOException { if ( writer == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] encoding = defaultEncoding ; writer = new OutputStreamWriter ( out , encoding ) ;
private void detectEncoding ( final char [] cbuf , final int off , final int len ) throws IOException { int size = len ; final StringBuffer xmlProlog = xmlPrologWriter . getBuffer () ; if ( xmlProlog . length () + len > BUFFER_SIZE ) { MST[rv.ROR2Mutator]MSP[N]
private void detectEncoding ( final char [] cbuf , final int off , final int len ) throws IOException { int size = len ; final StringBuffer xmlProlog = xmlPrologWriter . getBuffer () ; if ( xmlProlog . length () + len > BUFFER_SIZE ) { MST[rv.AOR4Mutator]MSP[N]
private void detectEncoding ( final char [] cbuf , final int off , final int len ) throws IOException { int size = len ; final StringBuffer xmlProlog = xmlPrologWriter . getBuffer () ; if ( xmlProlog . length () + len > BUFFER_SIZE ) { MST[NegateConditionalsMutator]MSP[N]
private void detectEncoding ( final char [] cbuf , final int off , final int len ) throws IOException { int size = len ; final StringBuffer xmlProlog = xmlPrologWriter . getBuffer () ; if ( xmlProlog . length () + len > BUFFER_SIZE ) { MST[rv.UOI1Mutator]MSP[N]
private void detectEncoding ( final char [] cbuf , final int off , final int len ) throws IOException { int size = len ; final StringBuffer xmlProlog = xmlPrologWriter . getBuffer () ; if ( xmlProlog . length () + len > BUFFER_SIZE ) { MST[rv.UOI4Mutator]MSP[S]
public void write ( final char [] cbuf , final int off , final int len ) throws IOException { if ( xmlPrologWriter != null ) { detectEncoding ( cbuf , off , len ) ; MST[rv.UOI2Mutator]MSP[S] } else { writer . write ( cbuf , off , len ) ;
final int xmlPrologEnd = xmlProlog . indexOf ( lr_2 ) ; if ( xmlPrologEnd > 0 ) { final Matcher m = ENCODING_PATTERN . matcher ( xmlProlog . substring ( 0 , xmlPrologEnd ) ) ; if ( m . find () ) { MST[NegateConditionalsMutator]MSP[N]
size = BUFFER_SIZE - xmlProlog . length () ; } xmlPrologWriter . write ( cbuf , off , size ) ; if ( xmlProlog . length () >= 5 ) { if ( xmlProlog . substring ( 0 , 5 ) . equals ( lr_1 ) ) { MST[rv.CRCR4Mutator]MSP[N]
public void write ( final char [] cbuf , final int off , final int len ) throws IOException { if ( xmlPrologWriter != null ) { detectEncoding ( cbuf , off , len ) ; MST[VoidMethodCallMutator]MSP[N] } else { writer . write ( cbuf , off , len ) ;
if ( xmlProlog . length () >= BUFFER_SIZE ) { encoding = defaultEncoding ; } } } else { encoding = defaultEncoding ; } if ( encoding != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] xmlPrologWriter = null ; writer = new OutputStreamWriter ( out , encoding ) ;
final int xmlPrologEnd = xmlProlog . indexOf ( lr_2 ) ; if ( xmlPrologEnd > 0 ) { final Matcher m = ENCODING_PATTERN . matcher ( xmlProlog . substring ( 0 , MST[rv.CRCR6Mutator]MSP[N] xmlPrologEnd ) ) ; if ( m . find () ) {
writer . write ( xmlProlog . toString () ) ; if ( len > size ) { MST[rv.UOI2Mutator]MSP[N] writer . write ( cbuf , off + size , len - size ) ; } } } } @Override
public String getEncoding () { return encoding ; } public String getDefaultEncoding () { return defaultEncoding ; } @Override public void close () throws IOException { if ( writer == null ) { encoding = defaultEncoding ; writer = new OutputStreamWriter ( out , encoding ) ; MST[ConstructorCallMutator]MSP[N]
size = BUFFER_SIZE - xmlProlog . length () ; } xmlPrologWriter . write ( cbuf , off , size ) ; MST[rv.UOI2Mutator]MSP[N] if ( xmlProlog . length () >= 5 ) { if ( xmlProlog . substring ( 0 , 5 ) . equals ( lr_1 ) ) {
size = BUFFER_SIZE - xmlProlog . length () ; } xmlPrologWriter . write ( cbuf , off , size ) ; if ( xmlProlog . length () >= 5 ) { MST[rv.ROR1Mutator]MSP[S] if ( xmlProlog . substring ( 0 , 5 ) . equals ( lr_1 ) ) {
if ( xmlProlog . length () >= BUFFER_SIZE ) { MST[NegateConditionalsMutator]MSP[S] encoding = defaultEncoding ; } } } else { encoding = defaultEncoding ; } if ( encoding != null ) { xmlPrologWriter = null ; writer = new OutputStreamWriter ( out , encoding ) ;
size = BUFFER_SIZE - xmlProlog . length () ; } xmlPrologWriter . write ( cbuf , off , size ) ; if ( xmlProlog . length () >= 5 ) { if ( xmlProlog . substring ( 0 , 5 ) . equals ( lr_1 ) ) { MST[NegateConditionalsMutator]MSP[N]
encoding = m . group ( 1 ) . toUpperCase ( Locale . ROOT ) ; encoding = encoding . substring ( 1 , encoding . length () - 1 ) ; MST[rv.CRCR5Mutator]MSP[N] } else { encoding = defaultEncoding ; } } else {
private void detectEncoding ( final char [] cbuf , final int off , final int len ) throws IOException { int size = len ; final StringBuffer xmlProlog = xmlPrologWriter . getBuffer () ; if ( xmlProlog . length () + len > BUFFER_SIZE ) { MST[rv.CRCR3Mutator]MSP[N]
writer . write ( xmlProlog . toString () ) ; if ( len > size ) { MST[rv.ROR2Mutator]MSP[N] writer . write ( cbuf , off + size , len - size ) ; } } } } @Override
encoding = m . group ( 1 ) . toUpperCase ( Locale . ROOT ) ; encoding = encoding . substring ( 1 , encoding . length () - 1 ) ; MST[NonVoidMethodCallMutator]MSP[N] } else { encoding = defaultEncoding ; } } else {
writer . write ( xmlProlog . toString () ) ; if ( len > size ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] writer . write ( cbuf , off + size , len - size ) ; } } } } @Override
final int xmlPrologEnd = xmlProlog . indexOf ( lr_2 ) ; if ( xmlPrologEnd > 0 ) { MST[rv.UOI2Mutator]MSP[N] final Matcher m = ENCODING_PATTERN . matcher ( xmlProlog . substring ( 0 , xmlPrologEnd ) ) ; if ( m . find () ) {
public String getEncoding () { return encoding ; } public String getDefaultEncoding () { return defaultEncoding ; } @Override public void close () throws IOException { if ( writer == null ) { MST[rv.ROR5Mutator]MSP[N] encoding = defaultEncoding ; writer = new OutputStreamWriter ( out , encoding ) ;
private void detectEncoding ( final char [] cbuf , final int off , final int len ) throws IOException { int size = len ; final StringBuffer xmlProlog = xmlPrologWriter . getBuffer () ; if ( xmlProlog . length () + len > BUFFER_SIZE ) { MST[rv.AOR1Mutator]MSP[S]
size = BUFFER_SIZE - xmlProlog . length () ; } xmlPrologWriter . write ( cbuf , off , size ) ; if ( xmlProlog . length () >= 5 ) { MST[rv.CRCR5Mutator]MSP[S] if ( xmlProlog . substring ( 0 , 5 ) . equals ( lr_1 ) ) {
public String getEncoding () { return encoding ; } public String getDefaultEncoding () { return defaultEncoding ; } @Override public void close () throws IOException { if ( writer == null ) { encoding = defaultEncoding ; MST[experimental.MemberVariableMutator]MSP[N] writer = new OutputStreamWriter ( out , encoding ) ;
encoding = m . group ( 1 ) . toUpperCase ( Locale . ROOT ) ; encoding = encoding . substring ( 1 , encoding . length () - 1 ) ; MST[rv.AOD2Mutator]MSP[N] } else { encoding = defaultEncoding ; } } else {
final int xmlPrologEnd = xmlProlog . indexOf ( lr_2 ) ; if ( xmlPrologEnd > 0 ) { final Matcher m = ENCODING_PATTERN . matcher ( xmlProlog . substring ( 0 , MST[NonVoidMethodCallMutator]MSP[N] xmlPrologEnd ) ) ; if ( m . find () ) {
private void detectEncoding ( final char [] cbuf , final int off , final int len ) throws IOException { int size = len ; final StringBuffer xmlProlog = xmlPrologWriter . getBuffer () ; if ( xmlProlog . length () + len > BUFFER_SIZE ) { MST[rv.AOD1Mutator]MSP[S]
public void write ( final char [] cbuf , final int off , final int len ) throws IOException { if ( xmlPrologWriter != null ) { MST[rv.ROR5Mutator]MSP[N] detectEncoding ( cbuf , off , len ) ; } else { writer . write ( cbuf , off , len ) ;
final int xmlPrologEnd = xmlProlog . indexOf ( lr_2 ) ; if ( xmlPrologEnd > 0 ) { final Matcher m = ENCODING_PATTERN . matcher ( xmlProlog . substring ( 0 , xmlPrologEnd ) ) ; if ( m . find () ) { MST[rv.ROR1Mutator]MSP[S]
encoding = m . group ( 1 ) . toUpperCase ( Locale . ROOT ) ; encoding = encoding . substring ( 1 , encoding . length () - 1 ) ; MST[rv.CRCR4Mutator]MSP[N] } else { encoding = defaultEncoding ; } } else {
if ( xmlProlog . length () >= BUFFER_SIZE ) { encoding = defaultEncoding ; } } } else { encoding = defaultEncoding ; } if ( encoding != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] xmlPrologWriter = null ; writer = new OutputStreamWriter ( out , encoding ) ;
final int xmlPrologEnd = xmlProlog . indexOf ( lr_2 ) ; if ( xmlPrologEnd > 0 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[S] final Matcher m = ENCODING_PATTERN . matcher ( xmlProlog . substring ( 0 , xmlPrologEnd ) ) ; if ( m . find () ) {
encoding = m . group ( 1 ) . toUpperCase ( Locale . ROOT ) ; encoding = encoding . substring ( 1 , encoding . length () - 1 ) ; MST[rv.CRCR6Mutator]MSP[N] } else { encoding = defaultEncoding ; } } else {
size = BUFFER_SIZE - xmlProlog . length () ; } xmlPrologWriter . write ( cbuf , off , size ) ; if ( xmlProlog . length () >= 5 ) { MST[NegateConditionalsMutator]MSP[N] if ( xmlProlog . substring ( 0 , 5 ) . equals ( lr_1 ) ) {
public void write ( final char [] cbuf , final int off , final int len ) throws IOException { if ( xmlPrologWriter != null ) { detectEncoding ( cbuf , off , len ) ; MST[rv.UOI4Mutator]MSP[N] } else { writer . write ( cbuf , off , len ) ;
encoding = m . group ( 1 ) . toUpperCase ( Locale . ROOT ) ; encoding = encoding . substring ( 1 , encoding . length () - 1 ) ; MST[rv.CRCR2Mutator]MSP[N] } else { encoding = defaultEncoding ; } } else {
writer . write ( xmlPrologWriter . toString () ) ; MST[VoidMethodCallMutator]MSP[S] } writer . close () ; } @Override public void flush () throws IOException { if ( writer != null ) { writer . flush () ; } }
public void write ( final char [] cbuf , final int off , final int len ) throws IOException { if ( xmlPrologWriter != null ) { detectEncoding ( cbuf , off , len ) ; MST[rv.ABSMutator]MSP[S] } else { writer . write ( cbuf , off , len ) ;
size = BUFFER_SIZE - xmlProlog . length () ; } xmlPrologWriter . write ( cbuf , off , size ) ; if ( xmlProlog . length () >= 5 ) { MST[rv.CRCR6Mutator]MSP[S] if ( xmlProlog . substring ( 0 , 5 ) . equals ( lr_1 ) ) {
size = BUFFER_SIZE - xmlProlog . length () ; } xmlPrologWriter . write ( cbuf , off , size ) ; if ( xmlProlog . length () >= 5 ) { MST[rv.CRCR4Mutator]MSP[N] if ( xmlProlog . substring ( 0 , 5 ) . equals ( lr_1 ) ) {
private void detectEncoding ( final char [] cbuf , final int off , final int len ) throws IOException { int size = len ; MST[rv.UOI3Mutator]MSP[N] final StringBuffer xmlProlog = xmlPrologWriter . getBuffer () ; if ( xmlProlog . length () + len > BUFFER_SIZE ) {
size = BUFFER_SIZE - xmlProlog . length () ; } xmlPrologWriter . write ( cbuf , off , size ) ; if ( xmlProlog . length () >= 5 ) { if ( xmlProlog . substring ( 0 , 5 ) . equals ( lr_1 ) ) { MST[rv.CRCR5Mutator]MSP[N]
private void detectEncoding ( final char [] cbuf , final int off , final int len ) throws IOException { int size = len ; final StringBuffer xmlProlog = xmlPrologWriter . getBuffer () ; MST[NonVoidMethodCallMutator]MSP[N] if ( xmlProlog . length () + len > BUFFER_SIZE ) {
final int xmlPrologEnd = xmlProlog . indexOf ( lr_2 ) ; if ( xmlPrologEnd > 0 ) { final Matcher m = ENCODING_PATTERN . matcher ( xmlProlog . substring ( 0 , MST[rv.UOI4Mutator]MSP[S] xmlPrologEnd ) ) ; if ( m . find () ) {
final int xmlPrologEnd = xmlProlog . indexOf ( lr_2 ) ; if ( xmlPrologEnd > 0 ) { final Matcher m = ENCODING_PATTERN . matcher ( xmlProlog . substring ( 0 , MST[rv.UOI2Mutator]MSP[N] xmlPrologEnd ) ) ; if ( m . find () ) {
size = BUFFER_SIZE - xmlProlog . length () ; } xmlPrologWriter . write ( cbuf , off , size ) ; if ( xmlProlog . length () >= 5 ) { if ( xmlProlog . substring ( 0 , 5 ) . equals ( lr_1 ) ) { MST[rv.CRCR1Mutator]MSP[N]
private void detectEncoding ( final char [] cbuf , final int off , final int len ) throws IOException { int size = len ; MST[rv.UOI1Mutator]MSP[N] final StringBuffer xmlProlog = xmlPrologWriter . getBuffer () ; if ( xmlProlog . length () + len > BUFFER_SIZE ) {
private void detectEncoding ( final char [] cbuf , final int off , final int len ) throws IOException { int size = len ; final StringBuffer xmlProlog = xmlPrologWriter . getBuffer () ; if ( xmlProlog . length () + len > BUFFER_SIZE ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N]
size = BUFFER_SIZE - xmlProlog . length () ; } xmlPrologWriter . write ( cbuf , off , size ) ; if ( xmlProlog . length () >= 5 ) { MST[rv.CRCR2Mutator]MSP[N] if ( xmlProlog . substring ( 0 , 5 ) . equals ( lr_1 ) ) {
private void detectEncoding ( final char [] cbuf , final int off , final int len ) throws IOException { int size = len ; final StringBuffer xmlProlog = xmlPrologWriter . getBuffer () ; if ( xmlProlog . length () + len > BUFFER_SIZE ) { MST[rv.ABSMutator]MSP[S]
final int xmlPrologEnd = xmlProlog . indexOf ( lr_2 ) ; if ( xmlPrologEnd > 0 ) { final Matcher m = ENCODING_PATTERN . matcher ( xmlProlog . substring ( 0 , MST[NonVoidMethodCallMutator]MSP[N] xmlPrologEnd ) ) ; if ( m . find () ) {
if ( xmlProlog . length () >= BUFFER_SIZE ) { encoding = defaultEncoding ; } } } else { encoding = defaultEncoding ; } if ( encoding != null ) { MST[rv.ROR5Mutator]MSP[N] xmlPrologWriter = null ; writer = new OutputStreamWriter ( out , encoding ) ;
public void write ( final char [] cbuf , final int off , final int len ) throws IOException { if ( xmlPrologWriter != null ) { detectEncoding ( cbuf , off , len ) ; MST[rv.UOI4Mutator]MSP[N] } else { writer . write ( cbuf , off , len ) ;
private void detectEncoding ( final char [] cbuf , final int off , final int len ) throws IOException { int size = len ; final StringBuffer xmlProlog = xmlPrologWriter . getBuffer () ; if ( xmlProlog . length () + len > BUFFER_SIZE ) { MST[rv.UOI2Mutator]MSP[S]
final int xmlPrologEnd = xmlProlog . indexOf ( lr_2 ) ; if ( xmlPrologEnd > 0 ) { final Matcher m = ENCODING_PATTERN . matcher ( xmlProlog . substring ( 0 , MST[rv.ABSMutator]MSP[N] xmlPrologEnd ) ) ; if ( m . find () ) {
size = BUFFER_SIZE - xmlProlog . length () ; } xmlPrologWriter . write ( cbuf , off , size ) ; if ( xmlProlog . length () >= 5 ) { if ( xmlProlog . substring ( 0 , 5 ) . equals ( lr_1 ) ) { MST[rv.CRCR1Mutator]MSP[N]
private void detectEncoding ( final char [] cbuf , final int off , final int len ) throws IOException { int size = len ; final StringBuffer xmlProlog = xmlPrologWriter . getBuffer () ; if ( xmlProlog . length () + len > BUFFER_SIZE ) { MST[InlineConstantMutator]MSP[S]
public String getEncoding () { return encoding ; } public String getDefaultEncoding () { return defaultEncoding ; } @Override public void close () throws IOException { if ( writer == null ) { encoding = defaultEncoding ; writer = new OutputStreamWriter ( out , encoding ) ; MST[experimental.MemberVariableMutator]MSP[N]
writer . write ( xmlPrologWriter . toString () ) ; } writer . close () ; } @Override public void flush () throws IOException { if ( writer != null ) { writer . flush () ; MST[VoidMethodCallMutator]MSP[N] } }
writer . write ( xmlProlog . toString () ) ; if ( len > size ) { MST[rv.UOI4Mutator]MSP[N] writer . write ( cbuf , off + size , len - size ) ; } } } } @Override
size = BUFFER_SIZE - xmlProlog . length () ; } xmlPrologWriter . write ( cbuf , off , size ) ; MST[rv.UOI4Mutator]MSP[N] if ( xmlProlog . length () >= 5 ) { if ( xmlProlog . substring ( 0 , 5 ) . equals ( lr_1 ) ) {
size = BUFFER_SIZE - xmlProlog . length () ; } xmlPrologWriter . write ( cbuf , off , size ) ; if ( xmlProlog . length () >= 5 ) { if ( xmlProlog . substring ( 0 , 5 ) . equals ( lr_1 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
size = BUFFER_SIZE - xmlProlog . length () ; } xmlPrologWriter . write ( cbuf , off , size ) ; if ( xmlProlog . length () >= 5 ) { MST[rv.ROR3Mutator]MSP[N] if ( xmlProlog . substring ( 0 , 5 ) . equals ( lr_1 ) ) {
writer . write ( xmlProlog . toString () ) ; if ( len > size ) { MST[rv.ROR4Mutator]MSP[N] writer . write ( cbuf , off + size , len - size ) ; } } } } @Override
final int xmlPrologEnd = xmlProlog . indexOf ( lr_2 ) ; if ( xmlPrologEnd > 0 ) { MST[rv.UOI4Mutator]MSP[N] final Matcher m = ENCODING_PATTERN . matcher ( xmlProlog . substring ( 0 , xmlPrologEnd ) ) ; if ( m . find () ) {
encoding = m . group ( 1 ) . toUpperCase ( Locale . ROOT ) ; MST[rv.CRCR5Mutator]MSP[N] encoding = encoding . substring ( 1 , encoding . length () - 1 ) ; } else { encoding = defaultEncoding ; } } else {
writer . write ( xmlProlog . toString () ) ; if ( len > size ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] writer . write ( cbuf , off + size , len - size ) ; } } } } @Override
size = BUFFER_SIZE - xmlProlog . length () ; } xmlPrologWriter . write ( cbuf , off , size ) ; MST[rv.ABSMutator]MSP[S] if ( xmlProlog . length () >= 5 ) { if ( xmlProlog . substring ( 0 , 5 ) . equals ( lr_1 ) ) {
encoding = m . group ( 1 ) . toUpperCase ( Locale . ROOT ) ; MST[NonVoidMethodCallMutator]MSP[N] encoding = encoding . substring ( 1 , encoding . length () - 1 ) ; } else { encoding = defaultEncoding ; } } else {
size = BUFFER_SIZE - xmlProlog . length () ; } xmlPrologWriter . write ( cbuf , off , size ) ; if ( xmlProlog . length () >= 5 ) { if ( xmlProlog . substring ( 0 , 5 ) . equals ( lr_1 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S]
final int xmlPrologEnd = xmlProlog . indexOf ( lr_2 ) ; if ( xmlPrologEnd > 0 ) { final Matcher m = ENCODING_PATTERN . matcher ( xmlProlog . substring ( 0 , xmlPrologEnd ) ) ; if ( m . find () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S]
writer . write ( xmlProlog . toString () ) ; if ( len > size ) { MST[ConditionalsBoundaryMutator]MSP[N] writer . write ( cbuf , off + size , len - size ) ; } } } } @Override
private void detectEncoding ( final char [] cbuf , final int off , final int len ) throws IOException { int size = len ; final StringBuffer xmlProlog = xmlPrologWriter . getBuffer () ; if ( xmlProlog . length () + len > BUFFER_SIZE ) { MST[rv.AOR3Mutator]MSP[N]
size = BUFFER_SIZE - xmlProlog . length () ; } xmlPrologWriter . write ( cbuf , off , size ) ; if ( xmlProlog . length () >= 5 ) { if ( xmlProlog . substring ( 0 , 5 ) . equals ( lr_1 ) ) { MST[rv.CRCR5Mutator]MSP[N]
if ( xmlProlog . length () >= BUFFER_SIZE ) { encoding = defaultEncoding ; } } } else { encoding = defaultEncoding ; } if ( encoding != null ) { xmlPrologWriter = null ; writer = new OutputStreamWriter ( out , encoding ) ; MST[ConstructorCallMutator]MSP[N]
private void detectEncoding ( final char [] cbuf , final int off , final int len ) throws IOException { int size = len ; final StringBuffer xmlProlog = xmlPrologWriter . getBuffer () ; if ( xmlProlog . length () + len > BUFFER_SIZE ) { MST[rv.ROR5Mutator]MSP[S]
size = BUFFER_SIZE - xmlProlog . length () ; } xmlPrologWriter . write ( cbuf , off , size ) ; if ( xmlProlog . length () >= 5 ) { if ( xmlProlog . substring ( 0 , 5 ) . equals ( lr_1 ) ) { MST[rv.CRCR3Mutator]MSP[N]
private void detectEncoding ( final char [] cbuf , final int off , final int len ) throws IOException { int size = len ; final StringBuffer xmlProlog = xmlPrologWriter . getBuffer () ; if ( xmlProlog . length () + len > BUFFER_SIZE ) { MST[rv.ROR1Mutator]MSP[S]
encoding = m . group ( 1 ) . toUpperCase ( Locale . ROOT ) ; encoding = encoding . substring ( 1 , encoding . length () - 1 ) ; MST[rv.CRCR3Mutator]MSP[N] } else { encoding = defaultEncoding ; } } else {
if ( xmlProlog . length () >= BUFFER_SIZE ) { encoding = defaultEncoding ; } } } else { encoding = defaultEncoding ; } if ( encoding != null ) { MST[NegateConditionalsMutator]MSP[N] xmlPrologWriter = null ; writer = new OutputStreamWriter ( out , encoding ) ;
final int xmlPrologEnd = xmlProlog . indexOf ( lr_2 ) ; if ( xmlPrologEnd > 0 ) { final Matcher m = ENCODING_PATTERN . matcher ( xmlProlog . substring ( 0 , xmlPrologEnd ) ) ; if ( m . find () ) { MST[rv.ROR3Mutator]MSP[N]
private void detectEncoding ( final char [] cbuf , final int off , final int len ) throws IOException { int size = len ; final StringBuffer xmlProlog = xmlPrologWriter . getBuffer () ; if ( xmlProlog . length () + len > BUFFER_SIZE ) { MST[ConditionalsBoundaryMutator]MSP[S]
writer . write ( xmlProlog . toString () ) ; MST[VoidMethodCallMutator]MSP[N] if ( len > size ) { writer . write ( cbuf , off + size , len - size ) ; } } } } @Override
encoding = m . group ( 1 ) . toUpperCase ( Locale . ROOT ) ; encoding = encoding . substring ( 1 , encoding . length () - 1 ) ; MST[MathMutator]MSP[N] } else { encoding = defaultEncoding ; } } else {
final int xmlPrologEnd = xmlProlog . indexOf ( lr_2 ) ; if ( xmlPrologEnd > 0 ) { MST[rv.ROR3Mutator]MSP[N] final Matcher m = ENCODING_PATTERN . matcher ( xmlProlog . substring ( 0 , xmlPrologEnd ) ) ; if ( m . find () ) {
public void write ( final char [] cbuf , final int off , final int len ) throws IOException { if ( xmlPrologWriter != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] detectEncoding ( cbuf , off , len ) ; } else { writer . write ( cbuf , off , len ) ;
public void write ( final char [] cbuf , final int off , final int len ) throws IOException { if ( xmlPrologWriter != null ) { detectEncoding ( cbuf , off , len ) ; MST[rv.UOI2Mutator]MSP[S] } else { writer . write ( cbuf , off , len ) ;
final int xmlPrologEnd = xmlProlog . indexOf ( lr_2 ) ; if ( xmlPrologEnd > 0 ) { MST[rv.ABSMutator]MSP[N] final Matcher m = ENCODING_PATTERN . matcher ( xmlProlog . substring ( 0 , xmlPrologEnd ) ) ; if ( m . find () ) {
encoding = m . group ( 1 ) . toUpperCase ( Locale . ROOT ) ; encoding = encoding . substring ( 1 , encoding . length () - 1 ) ; MST[InlineConstantMutator]MSP[N] } else { encoding = defaultEncoding ; } } else {
encoding = m . group ( 1 ) . toUpperCase ( Locale . ROOT ) ; encoding = encoding . substring ( 1 , encoding . length () - 1 ) ; MST[rv.AOR3Mutator]MSP[N] } else { encoding = defaultEncoding ; } } else {
encoding = m . group ( 1 ) . toUpperCase ( Locale . ROOT ) ; encoding = encoding . substring ( 1 , encoding . length () - 1 ) ; MST[rv.AOR4Mutator]MSP[N] } else { encoding = defaultEncoding ; } } else {
encoding = m . group ( 1 ) . toUpperCase ( Locale . ROOT ) ; encoding = encoding . substring ( 1 , encoding . length () - 1 ) ; MST[rv.AOR1Mutator]MSP[N] } else { encoding = defaultEncoding ; } } else {
final int xmlPrologEnd = xmlProlog . indexOf ( lr_2 ) ; if ( xmlPrologEnd > 0 ) { MST[rv.ROR1Mutator]MSP[S] final Matcher m = ENCODING_PATTERN . matcher ( xmlProlog . substring ( 0 , xmlPrologEnd ) ) ; if ( m . find () ) {
size = BUFFER_SIZE - xmlProlog . length () ; } xmlPrologWriter . write ( cbuf , off , size ) ; if ( xmlProlog . length () >= 5 ) { if ( xmlProlog . substring ( 0 , 5 ) . equals ( lr_1 ) ) { MST[NonVoidMethodCallMutator]MSP[N]
writer . write ( xmlProlog . toString () ) ; if ( len > size ) { MST[rv.UOI4Mutator]MSP[N] writer . write ( cbuf , off + size , len - size ) ; } } } } @Override
writer . write ( xmlProlog . toString () ) ; if ( len > size ) { MST[rv.UOI3Mutator]MSP[N] writer . write ( cbuf , off + size , len - size ) ; } } } } @Override
if ( xmlProlog . length () >= BUFFER_SIZE ) { MST[rv.CRCR6Mutator]MSP[S] encoding = defaultEncoding ; } } } else { encoding = defaultEncoding ; } if ( encoding != null ) { xmlPrologWriter = null ; writer = new OutputStreamWriter ( out , encoding ) ;
encoding = m . group ( 1 ) . toUpperCase ( Locale . ROOT ) ; MST[rv.CRCR6Mutator]MSP[N] encoding = encoding . substring ( 1 , encoding . length () - 1 ) ; } else { encoding = defaultEncoding ; } } else {
final int xmlPrologEnd = xmlProlog . indexOf ( lr_2 ) ; if ( xmlPrologEnd > 0 ) { MST[ConditionalsBoundaryMutator]MSP[S] final Matcher m = ENCODING_PATTERN . matcher ( xmlProlog . substring ( 0 , xmlPrologEnd ) ) ; if ( m . find () ) {
writer . write ( xmlProlog . toString () ) ; if ( len > size ) { MST[rv.UOI1Mutator]MSP[N] writer . write ( cbuf , off + size , len - size ) ; } } } } @Override
writer . write ( xmlProlog . toString () ) ; if ( len > size ) { MST[rv.ROR1Mutator]MSP[N] writer . write ( cbuf , off + size , len - size ) ; } } } } @Override
private void detectEncoding ( final char [] cbuf , final int off , final int len ) throws IOException { int size = len ; final StringBuffer xmlProlog = xmlPrologWriter . getBuffer () ; if ( xmlProlog . length () + len > BUFFER_SIZE ) { MST[rv.CRCR2Mutator]MSP[N]
encoding = m . group ( 1 ) . toUpperCase ( Locale . ROOT ) ; encoding = encoding . substring ( 1 , encoding . length () - 1 ) ; MST[experimental.MemberVariableMutator]MSP[N] } else { encoding = defaultEncoding ; } } else {
writer . write ( xmlProlog . toString () ) ; if ( len > size ) { MST[rv.ROR3Mutator]MSP[N] writer . write ( cbuf , off + size , len - size ) ; } } } } @Override
size = BUFFER_SIZE - xmlProlog . length () ; } xmlPrologWriter . write ( cbuf , off , size ) ; MST[rv.ABSMutator]MSP[N] if ( xmlProlog . length () >= 5 ) { if ( xmlProlog . substring ( 0 , 5 ) . equals ( lr_1 ) ) {
writer . write ( xmlProlog . toString () ) ; if ( len > size ) { MST[rv.ABSMutator]MSP[N] writer . write ( cbuf , off + size , len - size ) ; } } } } @Override
if ( xmlProlog . length () >= BUFFER_SIZE ) { MST[rv.CRCR2Mutator]MSP[S] encoding = defaultEncoding ; } } } else { encoding = defaultEncoding ; } if ( encoding != null ) { xmlPrologWriter = null ; writer = new OutputStreamWriter ( out , encoding ) ;
