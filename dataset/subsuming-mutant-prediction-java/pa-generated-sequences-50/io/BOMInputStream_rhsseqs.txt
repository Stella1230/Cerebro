if ( b >= 0 ) { buf [ off ++ ] = (byte) ( b & 0xFF ) ; len -- ; firstCount ++ ; } } final int secondCount = in . read ( buf , off , len ) ; MST[rv.ABSMutator]MSP[N]
return secondCount < 0 ? firstCount > 0 ? firstCount : EOF : firstCount + secondCount ; MST[NegateConditionalsMutator]MSP[N] } @Override public int read ( final byte [] buf ) throws IOException { return read ( buf , 0 , buf . length ) ; } @Override
fbLength ++ ; if ( firstBytes [ i ] < 0 ) { break; } } byteOrderMark = find () ; if ( byteOrderMark != null ) { if ( ! include ) { if ( byteOrderMark . length () < firstBytes . length ) { MST[rv.ROR2Mutator]MSP[S]
if ( b >= 0 ) { buf [ off ++ ] = (byte) ( b & 0xFF ) ; len -- ; MST[experimental.RemoveIncrementsMutator]MSP[N] firstCount ++ ; } } final int secondCount = in . read ( buf , off , len ) ;
final int maxBomSize = boms . get ( 0 ) . length () ; firstBytes = new int [ maxBomSize ] ; for ( int i = 0 ; i < firstBytes . length ; i ++ ) { MST[rv.ABSMutator]MSP[N] firstBytes [ i ] = in . read () ;
final int maxBomSize = boms . get ( 0 ) . length () ; firstBytes = new int [ maxBomSize ] ; for ( int i = 0 ; i < firstBytes . length ; i ++ ) { firstBytes [ i ] = in . read () ; MST[rv.UOI4Mutator]MSP[N]
fbIndex = byteOrderMark . length () ; } else { fbLength = 0 ; } } } } return byteOrderMark ; } public String getBOMCharsetName () throws IOException { getBOM () ; return byteOrderMark == null ? null : byteOrderMark . getCharsetName () ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] }
final int maxBomSize = boms . get ( 0 ) . length () ; MST[NonVoidMethodCallMutator]MSP[N] firstBytes = new int [ maxBomSize ] ; for ( int i = 0 ; i < firstBytes . length ; i ++ ) { firstBytes [ i ] = in . read () ;
throw new IllegalArgumentException ( lr_1 + bom ) ; } getBOM () ; return byteOrderMark != null && byteOrderMark . equals ( bom ) ; MST[rv.CRCR4Mutator]MSP[N] } public ByteOrderMark getBOM () throws IOException { if ( firstBytes == null ) { fbLength = 0 ;
throw new IllegalArgumentException ( lr_1 + bom ) ; } getBOM () ; return byteOrderMark != null && byteOrderMark . equals ( bom ) ; MST[rv.CRCR5Mutator]MSP[N] } public ByteOrderMark getBOM () throws IOException { if ( firstBytes == null ) { fbLength = 0 ;
} in . reset () ; } @Override public long skip ( final long n ) throws IOException { int skipped = 0 ; while ( ( n > skipped ) && ( readFirstBytes () >= 0 ) ) { MST[rv.UOI4Mutator]MSP[N] skipped ++ ; }
if ( b >= 0 ) { buf [ off ++ ] = (byte) ( b & 0xFF ) ; MST[IncrementsMutator]MSP[N] len -- ; firstCount ++ ; } } final int secondCount = in . read ( buf , off , len ) ;
return secondCount < 0 ? firstCount > 0 ? firstCount : EOF : firstCount + secondCount ; MST[rv.UOI4Mutator]MSP[N] } @Override public int read ( final byte [] buf ) throws IOException { return read ( buf , 0 , buf . length ) ; } @Override
} return null ; } private boolean matches ( final ByteOrderMark bom ) { for ( int i = 0 ; i < bom . length () ; i ++ ) { if ( bom . get ( i ) != firstBytes [ i ] ) { return false ; MST[rv.CRCR5Mutator]MSP[N]
} return null ; } private boolean matches ( final ByteOrderMark bom ) { for ( int i = 0 ; i < bom . length () ; i ++ ) { if ( bom . get ( i ) != firstBytes [ i ] ) { return false ; MST[rv.CRCR1Mutator]MSP[N]
final int maxBomSize = boms . get ( 0 ) . length () ; firstBytes = new int [ maxBomSize ] ; for ( int i = 0 ; i < firstBytes . length ; i ++ ) { MST[rv.CRCR5Mutator]MSP[N] firstBytes [ i ] = in . read () ;
} } return true ; } @Override public int read () throws IOException { final int b = readFirstBytes () ; return b >= 0 ? b : in . read () ; MST[rv.UOI2Mutator]MSP[N] } @Override
return in . skip ( n - skipped ) + skipped ; MST[ArgumentPropagationMutator]MSP[N] }
private int readFirstBytes () throws IOException { getBOM () ; return fbIndex < fbLength ? firstBytes [ fbIndex ++ ] : EOF ; MST[rv.CRCR4Mutator]MSP[N] } private ByteOrderMark find () { for ( final ByteOrderMark bom : boms ) { if ( matches ( bom ) ) { return bom ; }
final int maxBomSize = boms . get ( 0 ) . length () ; firstBytes = new int [ maxBomSize ] ; for ( int i = 0 ; i < firstBytes . length ; i ++ ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] firstBytes [ i ] = in . read () ;
return secondCount < 0 ? firstCount > 0 ? firstCount : EOF : firstCount + secondCount ; MST[rv.AOR3Mutator]MSP[N] } @Override public int read ( final byte [] buf ) throws IOException { return read ( buf , 0 , buf . length ) ; } @Override
throw new IllegalArgumentException ( lr_1 + bom ) ; MST[NonVoidMethodCallMutator]MSP[S] } getBOM () ; return byteOrderMark != null && byteOrderMark . equals ( bom ) ; } public ByteOrderMark getBOM () throws IOException { if ( firstBytes == null ) { fbLength = 0 ;
private int readFirstBytes () throws IOException { getBOM () ; return fbIndex < fbLength ? firstBytes [ fbIndex ++ ] : EOF ; MST[rv.UOI2Mutator]MSP[N] } private ByteOrderMark find () { for ( final ByteOrderMark bom : boms ) { if ( matches ( bom ) ) { return bom ; }
} return null ; } private boolean matches ( final ByteOrderMark bom ) { for ( int i = 0 ; i < bom . length () ; i ++ ) { if ( bom . get ( i ) != firstBytes [ i ] ) { MST[rv.ROR5Mutator]MSP[N] return false ;
} return null ; } private boolean matches ( final ByteOrderMark bom ) { for ( int i = 0 ; i < bom . length () ; i ++ ) { if ( bom . get ( i ) != firstBytes [ i ] ) { MST[rv.ROR1Mutator]MSP[N] return false ;
return secondCount < 0 ? firstCount > 0 ? firstCount : EOF : firstCount + secondCount ; MST[rv.UOI2Mutator]MSP[N] } @Override public int read ( final byte [] buf ) throws IOException { return read ( buf , 0 , buf . length ) ; } @Override
} return null ; } private boolean matches ( final ByteOrderMark bom ) { for ( int i = 0 ; i < bom . length () ; i ++ ) { MST[rv.UOI1Mutator]MSP[N] if ( bom . get ( i ) != firstBytes [ i ] ) { return false ;
} return null ; } private boolean matches ( final ByteOrderMark bom ) { for ( int i = 0 ; i < bom . length () ; i ++ ) { if ( bom . get ( i ) != firstBytes [ i ] ) { return false ; MST[ReturnValsMutator]MSP[N]
return in . skip ( n - skipped ) + skipped ; MST[rv.UOI4Mutator]MSP[N] }
return in . skip ( n - skipped ) + skipped ; MST[rv.UOI1Mutator]MSP[N] }
return in . skip ( n - skipped ) + skipped ; MST[PrimitiveReturnsMutator]MSP[N] }
public int read ( final byte [] buf , int off , int len ) throws IOException { int firstCount = 0 ; int b = 0 ; while ( len > 0 && b >= 0 ) { MST[rv.ROR2Mutator]MSP[N] b = readFirstBytes () ;
return 1 ; } return 0 ; } public boolean hasBOM () throws IOException { return getBOM () != null ; MST[NonVoidMethodCallMutator]MSP[N] } public boolean hasBOM ( final ByteOrderMark bom ) throws IOException { if ( ! boms . contains ( bom ) ) {
private int readFirstBytes () throws IOException { getBOM () ; return fbIndex < fbLength ? firstBytes [ fbIndex ++ ] : EOF ; MST[rv.ROR3Mutator]MSP[N] } private ByteOrderMark find () { for ( final ByteOrderMark bom : boms ) { if ( matches ( bom ) ) { return bom ; }
if ( b >= 0 ) { buf [ off ++ ] = (byte) ( b & 0xFF ) ; MST[rv.UOI1Mutator]MSP[S] len -- ; firstCount ++ ; } } final int secondCount = in . read ( buf , off , len ) ;
if ( b >= 0 ) { buf [ off ++ ] = (byte) ( b & 0xFF ) ; MST[rv.OBBN3Mutator]MSP[N] len -- ; firstCount ++ ; } } final int secondCount = in . read ( buf , off , len ) ;
} } return true ; } @Override public int read () throws IOException { final int b = readFirstBytes () ; return b >= 0 ? b : in . read () ; MST[rv.ROR3Mutator]MSP[N] } @Override
public synchronized void mark ( final int readlimit ) { markFbIndex = fbIndex ; markedAtStart = firstBytes == null ; in . mark ( readlimit ) ; } @Override public synchronized void reset () throws IOException { fbIndex = markFbIndex ; if ( markedAtStart ) { firstBytes = null ; MST[experimental.MemberVariableMutator]MSP[S]
return 1 ; } return 0 ; } public boolean hasBOM () throws IOException { return getBOM () != null ; MST[rv.CRCR3Mutator]MSP[N] } public boolean hasBOM ( final ByteOrderMark bom ) throws IOException { if ( ! boms . contains ( bom ) ) {
fbIndex = byteOrderMark . length () ; MST[NonVoidMethodCallMutator]MSP[S] } else { fbLength = 0 ; } } } } return byteOrderMark ; } public String getBOMCharsetName () throws IOException { getBOM () ; return byteOrderMark == null ? null : byteOrderMark . getCharsetName () ; }
fbLength ++ ; if ( firstBytes [ i ] < 0 ) { MST[rv.UOI4Mutator]MSP[N] break; } } byteOrderMark = find () ; if ( byteOrderMark != null ) { if ( ! include ) { if ( byteOrderMark . length () < firstBytes . length ) {
fbLength ++ ; MST[rv.UOI2Mutator]MSP[S] if ( firstBytes [ i ] < 0 ) { break; } } byteOrderMark = find () ; if ( byteOrderMark != null ) { if ( ! include ) { if ( byteOrderMark . length () < firstBytes . length ) {
if ( b >= 0 ) { buf [ off ++ ] = (byte) ( b & 0xFF ) ; len -- ; firstCount ++ ; } } final int secondCount = in . read ( buf , off , len ) ; MST[rv.ABSMutator]MSP[N]
return 1 ; } return 0 ; } public boolean hasBOM () throws IOException { return getBOM () != null ; } public boolean hasBOM ( final ByteOrderMark bom ) throws IOException { if ( ! boms . contains ( bom ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
final int maxBomSize = boms . get ( 0 ) . length () ; firstBytes = new int [ maxBomSize ] ; for ( int i = 0 ; i < firstBytes . length ; i ++ ) { MST[rv.UOI2Mutator]MSP[N] firstBytes [ i ] = in . read () ;
return secondCount < 0 ? firstCount > 0 ? firstCount : EOF : firstCount + secondCount ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] } @Override public int read ( final byte [] buf ) throws IOException { return read ( buf , 0 , buf . length ) ; } @Override
private int readFirstBytes () throws IOException { getBOM () ; return fbIndex < fbLength ? firstBytes [ fbIndex ++ ] : EOF ; } private ByteOrderMark find () { for ( final ByteOrderMark bom : boms ) { if ( matches ( bom ) ) { MST[NegateConditionalsMutator]MSP[N] return bom ; }
} in . reset () ; } @Override public long skip ( final long n ) throws IOException { int skipped = 0 ; while ( ( n > skipped ) && ( readFirstBytes () >= 0 ) ) { MST[rv.UOI4Mutator]MSP[N] skipped ++ ; }
final int maxBomSize = boms . get ( 0 ) . length () ; firstBytes = new int [ maxBomSize ] ; for ( int i = 0 ; i < firstBytes . length ; i ++ ) { MST[rv.ROR4Mutator]MSP[S] firstBytes [ i ] = in . read () ;
return secondCount < 0 ? firstCount > 0 ? firstCount : EOF : firstCount + secondCount ; MST[rv.ROR5Mutator]MSP[N] } @Override public int read ( final byte [] buf ) throws IOException { return read ( buf , 0 , buf . length ) ; } @Override
return secondCount < 0 ? firstCount > 0 ? firstCount : EOF : firstCount + secondCount ; } @Override public int read ( final byte [] buf ) throws IOException { return read ( buf , 0 , buf . length ) ; MST[PrimitiveReturnsMutator]MSP[N] } @Override
return secondCount < 0 ? firstCount > 0 ? firstCount : EOF : firstCount + secondCount ; MST[rv.ROR1Mutator]MSP[N] } @Override public int read ( final byte [] buf ) throws IOException { return read ( buf , 0 , buf . length ) ; } @Override
return secondCount < 0 ? firstCount > 0 ? firstCount : EOF : firstCount + secondCount ; MST[rv.ROR4Mutator]MSP[N] } @Override public int read ( final byte [] buf ) throws IOException { return read ( buf , 0 , buf . length ) ; } @Override
return in . skip ( n - skipped ) + skipped ; MST[rv.AOR2Mutator]MSP[N] }
final int maxBomSize = boms . get ( 0 ) . length () ; firstBytes = new int [ maxBomSize ] ; for ( int i = 0 ; i < firstBytes . length ; i ++ ) { MST[ConditionalsBoundaryMutator]MSP[N] firstBytes [ i ] = in . read () ;
public int read ( final byte [] buf , int off , int len ) throws IOException { int firstCount = 0 ; int b = 0 ; while ( len > 0 && b >= 0 ) { MST[rv.UOI1Mutator]MSP[S] b = readFirstBytes () ;
fbLength ++ ; if ( firstBytes [ i ] < 0 ) { break; } } byteOrderMark = find () ; if ( byteOrderMark != null ) { if ( ! include ) { MST[rv.ROR4Mutator]MSP[N] if ( byteOrderMark . length () < firstBytes . length ) {
return secondCount < 0 ? firstCount > 0 ? firstCount : EOF : firstCount + secondCount ; MST[rv.UOI2Mutator]MSP[N] } @Override public int read ( final byte [] buf ) throws IOException { return read ( buf , 0 , buf . length ) ; } @Override
} return null ; } private boolean matches ( final ByteOrderMark bom ) { for ( int i = 0 ; i < bom . length () ; i ++ ) { if ( bom . get ( i ) != firstBytes [ i ] ) { MST[rv.UOI3Mutator]MSP[N] return false ;
private int readFirstBytes () throws IOException { getBOM () ; return fbIndex < fbLength ? firstBytes [ fbIndex ++ ] : EOF ; MST[rv.ABSMutator]MSP[N] } private ByteOrderMark find () { for ( final ByteOrderMark bom : boms ) { if ( matches ( bom ) ) { return bom ; }
fbLength ++ ; MST[rv.AOD2Mutator]MSP[N] if ( firstBytes [ i ] < 0 ) { break; } } byteOrderMark = find () ; if ( byteOrderMark != null ) { if ( ! include ) { if ( byteOrderMark . length () < firstBytes . length ) {
} } return true ; } @Override public int read () throws IOException { final int b = readFirstBytes () ; return b >= 0 ? b : in . read () ; MST[rv.ABSMutator]MSP[N] } @Override
} return null ; } private boolean matches ( final ByteOrderMark bom ) { for ( int i = 0 ; i < bom . length () ; i ++ ) { if ( bom . get ( i ) != firstBytes [ i ] ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return false ;
} in . reset () ; } @Override public long skip ( final long n ) throws IOException { int skipped = 0 ; while ( ( n > skipped ) && ( readFirstBytes () >= 0 ) ) { MST[rv.ROR2Mutator]MSP[N] skipped ++ ; }
fbLength ++ ; if ( firstBytes [ i ] < 0 ) { MST[rv.UOI4Mutator]MSP[N] break; } } byteOrderMark = find () ; if ( byteOrderMark != null ) { if ( ! include ) { if ( byteOrderMark . length () < firstBytes . length ) {
fbLength ++ ; MST[rv.ABSMutator]MSP[N] if ( firstBytes [ i ] < 0 ) { break; } } byteOrderMark = find () ; if ( byteOrderMark != null ) { if ( ! include ) { if ( byteOrderMark . length () < firstBytes . length ) {
if ( b >= 0 ) { buf [ off ++ ] = (byte) ( b & 0xFF ) ; MST[rv.CRCR2Mutator]MSP[N] len -- ; firstCount ++ ; } } final int secondCount = in . read ( buf , off , len ) ;
} } return true ; } @Override public int read () throws IOException { final int b = readFirstBytes () ; return b >= 0 ? b : in . read () ; MST[ReturnValsMutator]MSP[N] } @Override
throw new IllegalArgumentException ( lr_1 + bom ) ; } getBOM () ; return byteOrderMark != null && byteOrderMark . equals ( bom ) ; MST[rv.ROR1Mutator]MSP[S] } public ByteOrderMark getBOM () throws IOException { if ( firstBytes == null ) { fbLength = 0 ;
return in . skip ( n - skipped ) + skipped ; MST[rv.AOD1Mutator]MSP[N] }
if ( b >= 0 ) { buf [ off ++ ] = (byte) ( b & 0xFF ) ; len -- ; firstCount ++ ; } } final int secondCount = in . read ( buf , off , len ) ; MST[rv.UOI1Mutator]MSP[S]
} in . reset () ; MST[VoidMethodCallMutator]MSP[N] } @Override public long skip ( final long n ) throws IOException { int skipped = 0 ; while ( ( n > skipped ) && ( readFirstBytes () >= 0 ) ) { skipped ++ ; }
private int readFirstBytes () throws IOException { getBOM () ; return fbIndex < fbLength ? firstBytes [ fbIndex ++ ] : EOF ; } private ByteOrderMark find () { for ( final ByteOrderMark bom : boms ) { if ( matches ( bom ) ) { MST[rv.ROR1Mutator]MSP[N] return bom ; }
throw new IllegalArgumentException ( lr_1 + bom ) ; } getBOM () ; return byteOrderMark != null && byteOrderMark . equals ( bom ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } public ByteOrderMark getBOM () throws IOException { if ( firstBytes == null ) { fbLength = 0 ;
final int maxBomSize = boms . get ( 0 ) . length () ; firstBytes = new int [ maxBomSize ] ; MST[rv.UOI3Mutator]MSP[N] for ( int i = 0 ; i < firstBytes . length ; i ++ ) { firstBytes [ i ] = in . read () ;
private int readFirstBytes () throws IOException { getBOM () ; return fbIndex < fbLength ? firstBytes [ fbIndex ++ ] : EOF ; } private ByteOrderMark find () { for ( final ByteOrderMark bom : boms ) { if ( matches ( bom ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return bom ; }
private int readFirstBytes () throws IOException { getBOM () ; return fbIndex < fbLength ? firstBytes [ fbIndex ++ ] : EOF ; MST[rv.UOI1Mutator]MSP[N] } private ByteOrderMark find () { for ( final ByteOrderMark bom : boms ) { if ( matches ( bom ) ) { return bom ; }
public synchronized void mark ( final int readlimit ) { markFbIndex = fbIndex ; markedAtStart = firstBytes == null ; MST[rv.CRCR4Mutator]MSP[N] in . mark ( readlimit ) ; } @Override public synchronized void reset () throws IOException { fbIndex = markFbIndex ; if ( markedAtStart ) { firstBytes = null ;
final int maxBomSize = boms . get ( 0 ) . length () ; firstBytes = new int [ maxBomSize ] ; MST[rv.UOI4Mutator]MSP[N] for ( int i = 0 ; i < firstBytes . length ; i ++ ) { firstBytes [ i ] = in . read () ;
throw new IllegalArgumentException ( lr_1 + bom ) ; } getBOM () ; return byteOrderMark != null && byteOrderMark . equals ( bom ) ; MST[rv.ROR4Mutator]MSP[N] } public ByteOrderMark getBOM () throws IOException { if ( firstBytes == null ) { fbLength = 0 ;
return secondCount < 0 ? firstCount > 0 ? firstCount : EOF : firstCount + secondCount ; MST[rv.ABSMutator]MSP[N] } @Override public int read ( final byte [] buf ) throws IOException { return read ( buf , 0 , buf . length ) ; } @Override
throw new IllegalArgumentException ( lr_1 + bom ) ; } getBOM () ; return byteOrderMark != null && byteOrderMark . equals ( bom ) ; MST[ReturnValsMutator]MSP[N] } public ByteOrderMark getBOM () throws IOException { if ( firstBytes == null ) { fbLength = 0 ;
} return null ; } private boolean matches ( final ByteOrderMark bom ) { for ( int i = 0 ; i < bom . length () ; i ++ ) { MST[rv.ROR2Mutator]MSP[N] if ( bom . get ( i ) != firstBytes [ i ] ) { return false ;
} } return true ; MST[rv.CRCR3Mutator]MSP[N] } @Override public int read () throws IOException { final int b = readFirstBytes () ; return b >= 0 ? b : in . read () ; } @Override
if ( b >= 0 ) { buf [ off ++ ] = (byte) ( b & 0xFF ) ; MST[rv.CRCR1Mutator]MSP[N] len -- ; firstCount ++ ; } } final int secondCount = in . read ( buf , off , len ) ;
private int readFirstBytes () throws IOException { getBOM () ; return fbIndex < fbLength ? firstBytes [ fbIndex ++ ] : EOF ; MST[RemoveConditionalMutator_ORDER_IF]MSP[N] } private ByteOrderMark find () { for ( final ByteOrderMark bom : boms ) { if ( matches ( bom ) ) { return bom ; }
public synchronized void mark ( final int readlimit ) { markFbIndex = fbIndex ; MST[rv.ABSMutator]MSP[S] markedAtStart = firstBytes == null ; in . mark ( readlimit ) ; } @Override public synchronized void reset () throws IOException { fbIndex = markFbIndex ; if ( markedAtStart ) { firstBytes = null ;
return secondCount < 0 ? firstCount > 0 ? firstCount : EOF : firstCount + secondCount ; } @Override public int read ( final byte [] buf ) throws IOException { return read ( buf , 0 , buf . length ) ; MST[NonVoidMethodCallMutator]MSP[N] } @Override
fbIndex = byteOrderMark . length () ; } else { fbLength = 0 ; MST[rv.CRCR5Mutator]MSP[N] } } } } return byteOrderMark ; } public String getBOMCharsetName () throws IOException { getBOM () ; return byteOrderMark == null ? null : byteOrderMark . getCharsetName () ; }
fbLength ++ ; MST[rv.CRCR6Mutator]MSP[N] if ( firstBytes [ i ] < 0 ) { break; } } byteOrderMark = find () ; if ( byteOrderMark != null ) { if ( ! include ) { if ( byteOrderMark . length () < firstBytes . length ) {
fbLength ++ ; if ( firstBytes [ i ] < 0 ) { MST[rv.ROR2Mutator]MSP[N] break; } } byteOrderMark = find () ; if ( byteOrderMark != null ) { if ( ! include ) { if ( byteOrderMark . length () < firstBytes . length ) {
public synchronized void mark ( final int readlimit ) { markFbIndex = fbIndex ; markedAtStart = firstBytes == null ; MST[rv.CRCR1Mutator]MSP[N] in . mark ( readlimit ) ; } @Override public synchronized void reset () throws IOException { fbIndex = markFbIndex ; if ( markedAtStart ) { firstBytes = null ;
private int readFirstBytes () throws IOException { getBOM () ; return fbIndex < fbLength ? firstBytes [ fbIndex ++ ] : EOF ; } private ByteOrderMark find () { for ( final ByteOrderMark bom : boms ) { if ( matches ( bom ) ) { return bom ; MST[ReturnValsMutator]MSP[N] }
fbLength ++ ; MST[rv.AOD1Mutator]MSP[N] if ( firstBytes [ i ] < 0 ) { break; } } byteOrderMark = find () ; if ( byteOrderMark != null ) { if ( ! include ) { if ( byteOrderMark . length () < firstBytes . length ) {
if ( b >= 0 ) { MST[rv.ROR5Mutator]MSP[N] buf [ off ++ ] = (byte) ( b & 0xFF ) ; len -- ; firstCount ++ ; } } final int secondCount = in . read ( buf , off , len ) ;
} in . reset () ; } @Override public long skip ( final long n ) throws IOException { int skipped = 0 ; while ( ( n > skipped ) && ( readFirstBytes () >= 0 ) ) { MST[rv.ROR5Mutator]MSP[S] skipped ++ ; }
} in . reset () ; } @Override public long skip ( final long n ) throws IOException { int skipped = 0 ; while ( ( n > skipped ) && ( readFirstBytes () >= 0 ) ) { skipped ++ ; MST[experimental.RemoveIncrementsMutator]MSP[N] }
throw new IllegalArgumentException ( lr_1 + bom ) ; } getBOM () ; return byteOrderMark != null && byteOrderMark . equals ( bom ) ; } public ByteOrderMark getBOM () throws IOException { if ( firstBytes == null ) { fbLength = 0 ; MST[rv.CRCR5Mutator]MSP[N]
return secondCount < 0 ? firstCount > 0 ? firstCount : EOF : firstCount + secondCount ; MST[ConditionalsBoundaryMutator]MSP[N] } @Override public int read ( final byte [] buf ) throws IOException { return read ( buf , 0 , buf . length ) ; } @Override
fbLength ++ ; MST[rv.AOR4Mutator]MSP[N] if ( firstBytes [ i ] < 0 ) { break; } } byteOrderMark = find () ; if ( byteOrderMark != null ) { if ( ! include ) { if ( byteOrderMark . length () < firstBytes . length ) {
public int read ( final byte [] buf , int off , int len ) throws IOException { int firstCount = 0 ; MST[rv.CRCR6Mutator]MSP[N] int b = 0 ; while ( len > 0 && b >= 0 ) { b = readFirstBytes () ;
fbLength ++ ; MST[MathMutator]MSP[N] if ( firstBytes [ i ] < 0 ) { break; } } byteOrderMark = find () ; if ( byteOrderMark != null ) { if ( ! include ) { if ( byteOrderMark . length () < firstBytes . length ) {
if ( b >= 0 ) { buf [ off ++ ] = (byte) ( b & 0xFF ) ; len -- ; firstCount ++ ; } } final int secondCount = in . read ( buf , off , len ) ; MST[rv.UOI1Mutator]MSP[S]
private int readFirstBytes () throws IOException { getBOM () ; return fbIndex < fbLength ? firstBytes [ fbIndex ++ ] : EOF ; MST[rv.AOR1Mutator]MSP[N] } private ByteOrderMark find () { for ( final ByteOrderMark bom : boms ) { if ( matches ( bom ) ) { return bom ; }
return in . skip ( n - skipped ) + skipped ; MST[ReturnValsMutator]MSP[N] }
final int maxBomSize = boms . get ( 0 ) . length () ; firstBytes = new int [ maxBomSize ] ; for ( int i = 0 ; i < firstBytes . length ; i ++ ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] firstBytes [ i ] = in . read () ;
final int maxBomSize = boms . get ( 0 ) . length () ; firstBytes = new int [ maxBomSize ] ; for ( int i = 0 ; i < firstBytes . length ; i ++ ) { MST[rv.UOI1Mutator]MSP[N] firstBytes [ i ] = in . read () ;
return secondCount < 0 ? firstCount > 0 ? firstCount : EOF : firstCount + secondCount ; MST[rv.ROR5Mutator]MSP[N] } @Override public int read ( final byte [] buf ) throws IOException { return read ( buf , 0 , buf . length ) ; } @Override
} } return true ; } @Override public int read () throws IOException { final int b = readFirstBytes () ; return b >= 0 ? b : in . read () ; MST[ConditionalsBoundaryMutator]MSP[N] } @Override
return secondCount < 0 ? firstCount > 0 ? firstCount : EOF : firstCount + secondCount ; MST[rv.ABSMutator]MSP[N] } @Override public int read ( final byte [] buf ) throws IOException { return read ( buf , 0 , buf . length ) ; } @Override
fbLength ++ ; MST[InlineConstantMutator]MSP[N] if ( firstBytes [ i ] < 0 ) { break; } } byteOrderMark = find () ; if ( byteOrderMark != null ) { if ( ! include ) { if ( byteOrderMark . length () < firstBytes . length ) {
} return null ; } private boolean matches ( final ByteOrderMark bom ) { for ( int i = 0 ; i < bom . length () ; i ++ ) { if ( bom . get ( i ) != firstBytes [ i ] ) { MST[rv.ABSMutator]MSP[N] return false ;
private int readFirstBytes () throws IOException { getBOM () ; return fbIndex < fbLength ? firstBytes [ fbIndex ++ ] : EOF ; } private ByteOrderMark find () { for ( final ByteOrderMark bom : boms ) { if ( matches ( bom ) ) { return bom ; MST[NullReturnValsMutator]MSP[N] }
if ( b >= 0 ) { MST[ConditionalsBoundaryMutator]MSP[N] buf [ off ++ ] = (byte) ( b & 0xFF ) ; len -- ; firstCount ++ ; } } final int secondCount = in . read ( buf , off , len ) ;
public synchronized void mark ( final int readlimit ) { markFbIndex = fbIndex ; MST[rv.UOI1Mutator]MSP[N] markedAtStart = firstBytes == null ; in . mark ( readlimit ) ; } @Override public synchronized void reset () throws IOException { fbIndex = markFbIndex ; if ( markedAtStart ) { firstBytes = null ;
private int readFirstBytes () throws IOException { getBOM () ; return fbIndex < fbLength ? firstBytes [ fbIndex ++ ] : EOF ; MST[rv.ABSMutator]MSP[N] } private ByteOrderMark find () { for ( final ByteOrderMark bom : boms ) { if ( matches ( bom ) ) { return bom ; }
return in . skip ( n - skipped ) + skipped ; MST[rv.ABSMutator]MSP[N] }
throw new IllegalArgumentException ( lr_1 + bom ) ; } getBOM () ; return byteOrderMark != null && byteOrderMark . equals ( bom ) ; MST[NegateConditionalsMutator]MSP[N] } public ByteOrderMark getBOM () throws IOException { if ( firstBytes == null ) { fbLength = 0 ;
fbLength ++ ; MST[rv.CRCR3Mutator]MSP[N] if ( firstBytes [ i ] < 0 ) { break; } } byteOrderMark = find () ; if ( byteOrderMark != null ) { if ( ! include ) { if ( byteOrderMark . length () < firstBytes . length ) {
return secondCount < 0 ? firstCount > 0 ? firstCount : EOF : firstCount + secondCount ; MST[rv.AOD1Mutator]MSP[N] } @Override public int read ( final byte [] buf ) throws IOException { return read ( buf , 0 , buf . length ) ; } @Override
private int readFirstBytes () throws IOException { getBOM () ; return fbIndex < fbLength ? firstBytes [ fbIndex ++ ] : EOF ; MST[rv.UOI3Mutator]MSP[N] } private ByteOrderMark find () { for ( final ByteOrderMark bom : boms ) { if ( matches ( bom ) ) { return bom ; }
} } return true ; } @Override public int read () throws IOException { final int b = readFirstBytes () ; return b >= 0 ? b : in . read () ; MST[rv.ABSMutator]MSP[N] } @Override
final int maxBomSize = boms . get ( 0 ) . length () ; firstBytes = new int [ maxBomSize ] ; for ( int i = 0 ; i < firstBytes . length ; i ++ ) { MST[rv.CRCR1Mutator]MSP[N] firstBytes [ i ] = in . read () ;
throw new IllegalArgumentException ( lr_1 + bom ) ; } getBOM () ; return byteOrderMark != null && byteOrderMark . equals ( bom ) ; } public ByteOrderMark getBOM () throws IOException { if ( firstBytes == null ) { MST[rv.ROR5Mutator]MSP[N] fbLength = 0 ;
fbLength ++ ; if ( firstBytes [ i ] < 0 ) { break; } } byteOrderMark = find () ; if ( byteOrderMark != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] if ( ! include ) { if ( byteOrderMark . length () < firstBytes . length ) {
throw new IllegalArgumentException ( lr_1 + bom ) ; MST[experimental.NakedReceiverMutator]MSP[N] } getBOM () ; return byteOrderMark != null && byteOrderMark . equals ( bom ) ; } public ByteOrderMark getBOM () throws IOException { if ( firstBytes == null ) { fbLength = 0 ;
fbIndex = byteOrderMark . length () ; MST[experimental.MemberVariableMutator]MSP[S] } else { fbLength = 0 ; } } } } return byteOrderMark ; } public String getBOMCharsetName () throws IOException { getBOM () ; return byteOrderMark == null ? null : byteOrderMark . getCharsetName () ; }
return secondCount < 0 ? firstCount > 0 ? firstCount : EOF : firstCount + secondCount ; } @Override public int read ( final byte [] buf ) throws IOException { return read ( buf , 0 , buf . length ) ; MST[rv.CRCR5Mutator]MSP[S] } @Override
return 1 ; } return 0 ; } public boolean hasBOM () throws IOException { return getBOM () != null ; } public boolean hasBOM ( final ByteOrderMark bom ) throws IOException { if ( ! boms . contains ( bom ) ) { MST[rv.ROR5Mutator]MSP[N]
public synchronized void mark ( final int readlimit ) { markFbIndex = fbIndex ; markedAtStart = firstBytes == null ; in . mark ( readlimit ) ; MST[rv.UOI2Mutator]MSP[N] } @Override public synchronized void reset () throws IOException { fbIndex = markFbIndex ; if ( markedAtStart ) { firstBytes = null ;
public synchronized void mark ( final int readlimit ) { markFbIndex = fbIndex ; markedAtStart = firstBytes == null ; in . mark ( readlimit ) ; } @Override public synchronized void reset () throws IOException { fbIndex = markFbIndex ; if ( markedAtStart ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] firstBytes = null ;
public int read ( final byte [] buf , int off , int len ) throws IOException { int firstCount = 0 ; MST[rv.CRCR3Mutator]MSP[N] int b = 0 ; while ( len > 0 && b >= 0 ) { b = readFirstBytes () ;
public synchronized void mark ( final int readlimit ) { markFbIndex = fbIndex ; markedAtStart = firstBytes == null ; MST[rv.ROR5Mutator]MSP[N] in . mark ( readlimit ) ; } @Override public synchronized void reset () throws IOException { fbIndex = markFbIndex ; if ( markedAtStart ) { firstBytes = null ;
return secondCount < 0 ? firstCount > 0 ? firstCount : EOF : firstCount + secondCount ; MST[rv.UOI3Mutator]MSP[N] } @Override public int read ( final byte [] buf ) throws IOException { return read ( buf , 0 , buf . length ) ; } @Override
fbLength ++ ; if ( firstBytes [ i ] < 0 ) { break; } } byteOrderMark = find () ; if ( byteOrderMark != null ) { if ( ! include ) { if ( byteOrderMark . length () < firstBytes . length ) { MST[rv.ROR3Mutator]MSP[N]
final int maxBomSize = boms . get ( 0 ) . length () ; firstBytes = new int [ maxBomSize ] ; for ( int i = 0 ; i < firstBytes . length ; i ++ ) { firstBytes [ i ] = in . read () ; MST[rv.UOI1Mutator]MSP[N]
public synchronized void mark ( final int readlimit ) { markFbIndex = fbIndex ; markedAtStart = firstBytes == null ; MST[InlineConstantMutator]MSP[S] in . mark ( readlimit ) ; } @Override public synchronized void reset () throws IOException { fbIndex = markFbIndex ; if ( markedAtStart ) { firstBytes = null ;
throw new IllegalArgumentException ( lr_1 + bom ) ; } getBOM () ; return byteOrderMark != null && byteOrderMark . equals ( bom ) ; MST[rv.CRCR6Mutator]MSP[N] } public ByteOrderMark getBOM () throws IOException { if ( firstBytes == null ) { fbLength = 0 ;
return secondCount < 0 ? firstCount > 0 ? firstCount : EOF : firstCount + secondCount ; MST[rv.UOI2Mutator]MSP[N] } @Override public int read ( final byte [] buf ) throws IOException { return read ( buf , 0 , buf . length ) ; } @Override
throw new IllegalArgumentException ( lr_1 + bom ) ; } getBOM () ; return byteOrderMark != null && byteOrderMark . equals ( bom ) ; MST[rv.CRCR5Mutator]MSP[N] } public ByteOrderMark getBOM () throws IOException { if ( firstBytes == null ) { fbLength = 0 ;
} return null ; } private boolean matches ( final ByteOrderMark bom ) { for ( int i = 0 ; i < bom . length () ; i ++ ) { if ( bom . get ( i ) != firstBytes [ i ] ) { return false ; MST[rv.CRCR6Mutator]MSP[N]
throw new IllegalArgumentException ( lr_1 + bom ) ; } getBOM () ; return byteOrderMark != null && byteOrderMark . equals ( bom ) ; MST[NonVoidMethodCallMutator]MSP[N] } public ByteOrderMark getBOM () throws IOException { if ( firstBytes == null ) { fbLength = 0 ;
private int readFirstBytes () throws IOException { getBOM () ; return fbIndex < fbLength ? firstBytes [ fbIndex ++ ] : EOF ; MST[rv.UOI3Mutator]MSP[N] } private ByteOrderMark find () { for ( final ByteOrderMark bom : boms ) { if ( matches ( bom ) ) { return bom ; }
private int readFirstBytes () throws IOException { getBOM () ; return fbIndex < fbLength ? firstBytes [ fbIndex ++ ] : EOF ; MST[rv.CRCR5Mutator]MSP[N] } private ByteOrderMark find () { for ( final ByteOrderMark bom : boms ) { if ( matches ( bom ) ) { return bom ; }
public synchronized void mark ( final int readlimit ) { markFbIndex = fbIndex ; markedAtStart = firstBytes == null ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] in . mark ( readlimit ) ; } @Override public synchronized void reset () throws IOException { fbIndex = markFbIndex ; if ( markedAtStart ) { firstBytes = null ;
return secondCount < 0 ? firstCount > 0 ? firstCount : EOF : firstCount + secondCount ; MST[rv.AOR4Mutator]MSP[N] } @Override public int read ( final byte [] buf ) throws IOException { return read ( buf , 0 , buf . length ) ; } @Override
} return null ; } private boolean matches ( final ByteOrderMark bom ) { for ( int i = 0 ; i < bom . length () ; i ++ ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] if ( bom . get ( i ) != firstBytes [ i ] ) { return false ;
} return null ; } private boolean matches ( final ByteOrderMark bom ) { for ( int i = 0 ; i < bom . length () ; i ++ ) { if ( bom . get ( i ) != firstBytes [ i ] ) { MST[rv.ROR2Mutator]MSP[N] return false ;
public int read ( final byte [] buf , int off , int len ) throws IOException { int firstCount = 0 ; int b = 0 ; while ( len > 0 && b >= 0 ) { MST[rv.ROR5Mutator]MSP[N] b = readFirstBytes () ;
return secondCount < 0 ? firstCount > 0 ? firstCount : EOF : firstCount + secondCount ; MST[rv.UOI1Mutator]MSP[N] } @Override public int read ( final byte [] buf ) throws IOException { return read ( buf , 0 , buf . length ) ; } @Override
return in . skip ( n - skipped ) + skipped ; MST[rv.UOI2Mutator]MSP[N] }
public int read ( final byte [] buf , int off , int len ) throws IOException { int firstCount = 0 ; int b = 0 ; while ( len > 0 && b >= 0 ) { MST[rv.ABSMutator]MSP[N] b = readFirstBytes () ;
return in . skip ( n - skipped ) + skipped ; MST[rv.UOI1Mutator]MSP[N] }
throw new IllegalArgumentException ( lr_1 + bom ) ; MST[ConstructorCallMutator]MSP[S] } getBOM () ; return byteOrderMark != null && byteOrderMark . equals ( bom ) ; } public ByteOrderMark getBOM () throws IOException { if ( firstBytes == null ) { fbLength = 0 ;
} in . reset () ; } @Override public long skip ( final long n ) throws IOException { int skipped = 0 ; while ( ( n > skipped ) && ( readFirstBytes () >= 0 ) ) { MST[NonVoidMethodCallMutator]MSP[N] skipped ++ ; }
} return null ; } private boolean matches ( final ByteOrderMark bom ) { for ( int i = 0 ; i < bom . length () ; i ++ ) { if ( bom . get ( i ) != firstBytes [ i ] ) { MST[rv.UOI3Mutator]MSP[N] return false ;
return 1 ; } return 0 ; } public boolean hasBOM () throws IOException { return getBOM () != null ; } public boolean hasBOM ( final ByteOrderMark bom ) throws IOException { if ( ! boms . contains ( bom ) ) { MST[rv.ROR2Mutator]MSP[N]
fbLength ++ ; if ( firstBytes [ i ] < 0 ) { break; } } byteOrderMark = find () ; if ( byteOrderMark != null ) { if ( ! include ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] if ( byteOrderMark . length () < firstBytes . length ) {
if ( b >= 0 ) { buf [ off ++ ] = (byte) ( b & 0xFF ) ; MST[rv.ABSMutator]MSP[N] len -- ; firstCount ++ ; } } final int secondCount = in . read ( buf , off , len ) ;
} return null ; } private boolean matches ( final ByteOrderMark bom ) { for ( int i = 0 ; i < bom . length () ; i ++ ) { MST[rv.CRCR1Mutator]MSP[S] if ( bom . get ( i ) != firstBytes [ i ] ) { return false ;
return secondCount < 0 ? firstCount > 0 ? firstCount : EOF : firstCount + secondCount ; MST[RemoveConditionalMutator_ORDER_IF]MSP[N] } @Override public int read ( final byte [] buf ) throws IOException { return read ( buf , 0 , buf . length ) ; } @Override
return in . skip ( n - skipped ) + skipped ; MST[MathMutator]MSP[N] }
public synchronized void mark ( final int readlimit ) { markFbIndex = fbIndex ; markedAtStart = firstBytes == null ; in . mark ( readlimit ) ; MST[rv.UOI1Mutator]MSP[N] } @Override public synchronized void reset () throws IOException { fbIndex = markFbIndex ; if ( markedAtStart ) { firstBytes = null ;
return secondCount < 0 ? firstCount > 0 ? firstCount : EOF : firstCount + secondCount ; MST[rv.CRCR6Mutator]MSP[N] } @Override public int read ( final byte [] buf ) throws IOException { return read ( buf , 0 , buf . length ) ; } @Override
} return null ; } private boolean matches ( final ByteOrderMark bom ) { for ( int i = 0 ; i < bom . length () ; i ++ ) { MST[rv.CRCR5Mutator]MSP[S] if ( bom . get ( i ) != firstBytes [ i ] ) { return false ;
private int readFirstBytes () throws IOException { getBOM () ; return fbIndex < fbLength ? firstBytes [ fbIndex ++ ] : EOF ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] } private ByteOrderMark find () { for ( final ByteOrderMark bom : boms ) { if ( matches ( bom ) ) { return bom ; }
fbLength ++ ; if ( firstBytes [ i ] < 0 ) { MST[NegateConditionalsMutator]MSP[N] break; } } byteOrderMark = find () ; if ( byteOrderMark != null ) { if ( ! include ) { if ( byteOrderMark . length () < firstBytes . length ) {
return secondCount < 0 ? firstCount > 0 ? firstCount : EOF : firstCount + secondCount ; MST[ConditionalsBoundaryMutator]MSP[N] } @Override public int read ( final byte [] buf ) throws IOException { return read ( buf , 0 , buf . length ) ; } @Override
} } return true ; } @Override public int read () throws IOException { final int b = readFirstBytes () ; return b >= 0 ? b : in . read () ; MST[PrimitiveReturnsMutator]MSP[N] } @Override
throw new IllegalArgumentException ( lr_1 + bom ) ; } getBOM () ; return byteOrderMark != null && byteOrderMark . equals ( bom ) ; } public ByteOrderMark getBOM () throws IOException { if ( firstBytes == null ) { fbLength = 0 ; MST[rv.CRCR1Mutator]MSP[N]
final int maxBomSize = boms . get ( 0 ) . length () ; firstBytes = new int [ maxBomSize ] ; for ( int i = 0 ; i < firstBytes . length ; i ++ ) { MST[rv.UOI3Mutator]MSP[N] firstBytes [ i ] = in . read () ;
public synchronized void mark ( final int readlimit ) { markFbIndex = fbIndex ; markedAtStart = firstBytes == null ; in . mark ( readlimit ) ; } @Override public synchronized void reset () throws IOException { fbIndex = markFbIndex ; MST[rv.UOI4Mutator]MSP[N] if ( markedAtStart ) { firstBytes = null ;
} in . reset () ; } @Override public long skip ( final long n ) throws IOException { int skipped = 0 ; while ( ( n > skipped ) && ( readFirstBytes () >= 0 ) ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] skipped ++ ; }
final int maxBomSize = boms . get ( 0 ) . length () ; firstBytes = new int [ maxBomSize ] ; for ( int i = 0 ; i < firstBytes . length ; i ++ ) { MST[rv.ROR1Mutator]MSP[N] firstBytes [ i ] = in . read () ;
final int maxBomSize = boms . get ( 0 ) . length () ; firstBytes = new int [ maxBomSize ] ; for ( int i = 0 ; i < firstBytes . length ; i ++ ) { MST[rv.ROR5Mutator]MSP[N] firstBytes [ i ] = in . read () ;
return secondCount < 0 ? firstCount > 0 ? firstCount : EOF : firstCount + secondCount ; MST[rv.ROR3Mutator]MSP[N] } @Override public int read ( final byte [] buf ) throws IOException { return read ( buf , 0 , buf . length ) ; } @Override
public synchronized void mark ( final int readlimit ) { markFbIndex = fbIndex ; MST[rv.UOI4Mutator]MSP[N] markedAtStart = firstBytes == null ; in . mark ( readlimit ) ; } @Override public synchronized void reset () throws IOException { fbIndex = markFbIndex ; if ( markedAtStart ) { firstBytes = null ;
throw new IllegalArgumentException ( lr_1 + bom ) ; MST[NonVoidMethodCallMutator]MSP[N] } getBOM () ; return byteOrderMark != null && byteOrderMark . equals ( bom ) ; } public ByteOrderMark getBOM () throws IOException { if ( firstBytes == null ) { fbLength = 0 ;
private int readFirstBytes () throws IOException { getBOM () ; return fbIndex < fbLength ? firstBytes [ fbIndex ++ ] : EOF ; MST[ConditionalsBoundaryMutator]MSP[N] } private ByteOrderMark find () { for ( final ByteOrderMark bom : boms ) { if ( matches ( bom ) ) { return bom ; }
public synchronized void mark ( final int readlimit ) { markFbIndex = fbIndex ; markedAtStart = firstBytes == null ; in . mark ( readlimit ) ; } @Override public synchronized void reset () throws IOException { fbIndex = markFbIndex ; if ( markedAtStart ) { MST[rv.ROR1Mutator]MSP[N] firstBytes = null ;
return in . skip ( n - skipped ) + skipped ; MST[rv.AOR3Mutator]MSP[N] }
fbLength ++ ; if ( firstBytes [ i ] < 0 ) { break; } } byteOrderMark = find () ; if ( byteOrderMark != null ) { if ( ! include ) { MST[rv.ROR5Mutator]MSP[N] if ( byteOrderMark . length () < firstBytes . length ) {
public int read ( final byte [] buf , int off , int len ) throws IOException { int firstCount = 0 ; int b = 0 ; while ( len > 0 && b >= 0 ) { MST[rv.UOI4Mutator]MSP[N] b = readFirstBytes () ;
fbLength ++ ; if ( firstBytes [ i ] < 0 ) { break; } } byteOrderMark = find () ; if ( byteOrderMark != null ) { if ( ! include ) { if ( byteOrderMark . length () < firstBytes . length ) { MST[NegateConditionalsMutator]MSP[S]
return secondCount < 0 ? firstCount > 0 ? firstCount : EOF : firstCount + secondCount ; MST[rv.UOI1Mutator]MSP[N] } @Override public int read ( final byte [] buf ) throws IOException { return read ( buf , 0 , buf . length ) ; } @Override
fbLength ++ ; if ( firstBytes [ i ] < 0 ) { break; } } byteOrderMark = find () ; if ( byteOrderMark != null ) { if ( ! include ) { MST[rv.ROR1Mutator]MSP[N] if ( byteOrderMark . length () < firstBytes . length ) {
return in . skip ( n - skipped ) + skipped ; MST[rv.AOR2Mutator]MSP[S] }
fbIndex = byteOrderMark . length () ; } else { fbLength = 0 ; MST[rv.CRCR1Mutator]MSP[N] } } } } return byteOrderMark ; } public String getBOMCharsetName () throws IOException { getBOM () ; return byteOrderMark == null ? null : byteOrderMark . getCharsetName () ; }
} return null ; } private boolean matches ( final ByteOrderMark bom ) { for ( int i = 0 ; i < bom . length () ; i ++ ) { if ( bom . get ( i ) != firstBytes [ i ] ) { MST[rv.UOI3Mutator]MSP[N] return false ;
public int read ( final byte [] buf , int off , int len ) throws IOException { int firstCount = 0 ; int b = 0 ; while ( len > 0 && b >= 0 ) { MST[rv.ROR1Mutator]MSP[N] b = readFirstBytes () ;
if ( b >= 0 ) { buf [ off ++ ] = (byte) ( b & 0xFF ) ; MST[rv.UOI4Mutator]MSP[N] len -- ; firstCount ++ ; } } final int secondCount = in . read ( buf , off , len ) ;
private int readFirstBytes () throws IOException { getBOM () ; return fbIndex < fbLength ? firstBytes [ fbIndex ++ ] : EOF ; MST[rv.ROR4Mutator]MSP[S] } private ByteOrderMark find () { for ( final ByteOrderMark bom : boms ) { if ( matches ( bom ) ) { return bom ; }
} in . reset () ; } @Override public long skip ( final long n ) throws IOException { int skipped = 0 ; MST[rv.CRCR6Mutator]MSP[N] while ( ( n > skipped ) && ( readFirstBytes () >= 0 ) ) { skipped ++ ; }
} } return true ; } @Override public int read () throws IOException { final int b = readFirstBytes () ; MST[NonVoidMethodCallMutator]MSP[N] return b >= 0 ? b : in . read () ; } @Override
} } return true ; } @Override public int read () throws IOException { final int b = readFirstBytes () ; return b >= 0 ? b : in . read () ; MST[rv.ROR2Mutator]MSP[N] } @Override
final int maxBomSize = boms . get ( 0 ) . length () ; firstBytes = new int [ maxBomSize ] ; for ( int i = 0 ; i < firstBytes . length ; i ++ ) { MST[InlineConstantMutator]MSP[N] firstBytes [ i ] = in . read () ;
return 1 ; } return 0 ; } public boolean hasBOM () throws IOException { return getBOM () != null ; MST[rv.CRCR6Mutator]MSP[N] } public boolean hasBOM ( final ByteOrderMark bom ) throws IOException { if ( ! boms . contains ( bom ) ) {
fbLength ++ ; if ( firstBytes [ i ] < 0 ) { MST[rv.UOI1Mutator]MSP[N] break; } } byteOrderMark = find () ; if ( byteOrderMark != null ) { if ( ! include ) { if ( byteOrderMark . length () < firstBytes . length ) {
throw new IllegalArgumentException ( lr_1 + bom ) ; } getBOM () ; return byteOrderMark != null && byteOrderMark . equals ( bom ) ; } public ByteOrderMark getBOM () throws IOException { if ( firstBytes == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] fbLength = 0 ;
} } return true ; MST[BooleanFalseReturnValsMutator]MSP[N] } @Override public int read () throws IOException { final int b = readFirstBytes () ; return b >= 0 ? b : in . read () ; } @Override
final int maxBomSize = boms . get ( 0 ) . length () ; MST[NonVoidMethodCallMutator]MSP[N] firstBytes = new int [ maxBomSize ] ; for ( int i = 0 ; i < firstBytes . length ; i ++ ) { firstBytes [ i ] = in . read () ;
return secondCount < 0 ? firstCount > 0 ? firstCount : EOF : firstCount + secondCount ; MST[NegateConditionalsMutator]MSP[N] } @Override public int read ( final byte [] buf ) throws IOException { return read ( buf , 0 , buf . length ) ; } @Override
private int readFirstBytes () throws IOException { getBOM () ; return fbIndex < fbLength ? firstBytes [ fbIndex ++ ] : EOF ; } private ByteOrderMark find () { for ( final ByteOrderMark bom : boms ) { if ( matches ( bom ) ) { MST[rv.ROR2Mutator]MSP[S] return bom ; }
public synchronized void mark ( final int readlimit ) { markFbIndex = fbIndex ; markedAtStart = firstBytes == null ; in . mark ( readlimit ) ; } @Override public synchronized void reset () throws IOException { fbIndex = markFbIndex ; MST[rv.ABSMutator]MSP[S] if ( markedAtStart ) { firstBytes = null ;
return secondCount < 0 ? firstCount > 0 ? firstCount : EOF : firstCount + secondCount ; MST[rv.UOI2Mutator]MSP[N] } @Override public int read ( final byte [] buf ) throws IOException { return read ( buf , 0 , buf . length ) ; } @Override
return 1 ; } return 0 ; } public boolean hasBOM () throws IOException { return getBOM () != null ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } public boolean hasBOM ( final ByteOrderMark bom ) throws IOException { if ( ! boms . contains ( bom ) ) {
private int readFirstBytes () throws IOException { getBOM () ; return fbIndex < fbLength ? firstBytes [ fbIndex ++ ] : EOF ; MST[rv.UOI2Mutator]MSP[N] } private ByteOrderMark find () { for ( final ByteOrderMark bom : boms ) { if ( matches ( bom ) ) { return bom ; }
throw new IllegalArgumentException ( lr_1 + bom ) ; MST[NonVoidMethodCallMutator]MSP[S] } getBOM () ; return byteOrderMark != null && byteOrderMark . equals ( bom ) ; } public ByteOrderMark getBOM () throws IOException { if ( firstBytes == null ) { fbLength = 0 ;
} return null ; } private boolean matches ( final ByteOrderMark bom ) { for ( int i = 0 ; i < bom . length () ; i ++ ) { if ( bom . get ( i ) != firstBytes [ i ] ) { MST[NonVoidMethodCallMutator]MSP[N] return false ;
throw new IllegalArgumentException ( lr_1 + bom ) ; } getBOM () ; return byteOrderMark != null && byteOrderMark . equals ( bom ) ; MST[rv.ROR5Mutator]MSP[N] } public ByteOrderMark getBOM () throws IOException { if ( firstBytes == null ) { fbLength = 0 ;
return in . skip ( n - skipped ) + skipped ; MST[NonVoidMethodCallMutator]MSP[N] }
public synchronized void mark ( final int readlimit ) { markFbIndex = fbIndex ; markedAtStart = firstBytes == null ; MST[rv.CRCR5Mutator]MSP[N] in . mark ( readlimit ) ; } @Override public synchronized void reset () throws IOException { fbIndex = markFbIndex ; if ( markedAtStart ) { firstBytes = null ;
throw new IllegalArgumentException ( lr_1 + bom ) ; } getBOM () ; return byteOrderMark != null && byteOrderMark . equals ( bom ) ; MST[NegateConditionalsMutator]MSP[N] } public ByteOrderMark getBOM () throws IOException { if ( firstBytes == null ) { fbLength = 0 ;
if ( b >= 0 ) { buf [ off ++ ] = (byte) ( b & 0xFF ) ; MST[rv.CRCR6Mutator]MSP[N] len -- ; firstCount ++ ; } } final int secondCount = in . read ( buf , off , len ) ;
} } return true ; MST[rv.CRCR4Mutator]MSP[N] } @Override public int read () throws IOException { final int b = readFirstBytes () ; return b >= 0 ? b : in . read () ; } @Override
} } return true ; MST[rv.CRCR5Mutator]MSP[N] } @Override public int read () throws IOException { final int b = readFirstBytes () ; return b >= 0 ? b : in . read () ; } @Override
} return null ; } private boolean matches ( final ByteOrderMark bom ) { for ( int i = 0 ; i < bom . length () ; i ++ ) { MST[rv.ROR3Mutator]MSP[N] if ( bom . get ( i ) != firstBytes [ i ] ) { return false ;
if ( b >= 0 ) { buf [ off ++ ] = (byte) ( b & 0xFF ) ; MST[rv.CRCR5Mutator]MSP[N] len -- ; firstCount ++ ; } } final int secondCount = in . read ( buf , off , len ) ;
private int readFirstBytes () throws IOException { getBOM () ; return fbIndex < fbLength ? firstBytes [ fbIndex ++ ] : EOF ; MST[rv.UOI1Mutator]MSP[N] } private ByteOrderMark find () { for ( final ByteOrderMark bom : boms ) { if ( matches ( bom ) ) { return bom ; }
} return null ; } private boolean matches ( final ByteOrderMark bom ) { for ( int i = 0 ; i < bom . length () ; i ++ ) { if ( bom . get ( i ) != firstBytes [ i ] ) { MST[rv.UOI2Mutator]MSP[N] return false ;
} in . reset () ; } @Override public long skip ( final long n ) throws IOException { int skipped = 0 ; MST[rv.CRCR5Mutator]MSP[N] while ( ( n > skipped ) && ( readFirstBytes () >= 0 ) ) { skipped ++ ; }
if ( b >= 0 ) { buf [ off ++ ] = (byte) ( b & 0xFF ) ; MST[rv.UOI3Mutator]MSP[N] len -- ; firstCount ++ ; } } final int secondCount = in . read ( buf , off , len ) ;
fbLength ++ ; MST[rv.CRCR4Mutator]MSP[N] if ( firstBytes [ i ] < 0 ) { break; } } byteOrderMark = find () ; if ( byteOrderMark != null ) { if ( ! include ) { if ( byteOrderMark . length () < firstBytes . length ) {
} return null ; } private boolean matches ( final ByteOrderMark bom ) { for ( int i = 0 ; i < bom . length () ; i ++ ) { if ( bom . get ( i ) != firstBytes [ i ] ) { MST[rv.UOI4Mutator]MSP[N] return false ;
public synchronized void mark ( final int readlimit ) { markFbIndex = fbIndex ; markedAtStart = firstBytes == null ; MST[rv.CRCR3Mutator]MSP[N] in . mark ( readlimit ) ; } @Override public synchronized void reset () throws IOException { fbIndex = markFbIndex ; if ( markedAtStart ) { firstBytes = null ;
if ( b >= 0 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] buf [ off ++ ] = (byte) ( b & 0xFF ) ; len -- ; firstCount ++ ; } } final int secondCount = in . read ( buf , off , len ) ;
private int readFirstBytes () throws IOException { getBOM () ; return fbIndex < fbLength ? firstBytes [ fbIndex ++ ] : EOF ; MST[rv.UOI4Mutator]MSP[N] } private ByteOrderMark find () { for ( final ByteOrderMark bom : boms ) { if ( matches ( bom ) ) { return bom ; }
} in . reset () ; } @Override public long skip ( final long n ) throws IOException { int skipped = 0 ; while ( ( n > skipped ) && ( readFirstBytes () >= 0 ) ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] skipped ++ ; }
if ( b >= 0 ) { MST[rv.UOI2Mutator]MSP[N] buf [ off ++ ] = (byte) ( b & 0xFF ) ; len -- ; firstCount ++ ; } } final int secondCount = in . read ( buf , off , len ) ;
return secondCount < 0 ? firstCount > 0 ? firstCount : EOF : firstCount + secondCount ; MST[rv.AOD2Mutator]MSP[S] } @Override public int read ( final byte [] buf ) throws IOException { return read ( buf , 0 , buf . length ) ; } @Override
} in . reset () ; } @Override public long skip ( final long n ) throws IOException { int skipped = 0 ; while ( ( n > skipped ) && ( readFirstBytes () >= 0 ) ) { MST[rv.UOI1Mutator]MSP[N] skipped ++ ; }
return secondCount < 0 ? firstCount > 0 ? firstCount : EOF : firstCount + secondCount ; MST[RemoveConditionalMutator_ORDER_IF]MSP[N] } @Override public int read ( final byte [] buf ) throws IOException { return read ( buf , 0 , buf . length ) ; } @Override
if ( b >= 0 ) { buf [ off ++ ] = (byte) ( b & 0xFF ) ; MST[rv.ABSMutator]MSP[N] len -- ; firstCount ++ ; } } final int secondCount = in . read ( buf , off , len ) ;
fbLength ++ ; if ( firstBytes [ i ] < 0 ) { MST[rv.UOI1Mutator]MSP[N] break; } } byteOrderMark = find () ; if ( byteOrderMark != null ) { if ( ! include ) { if ( byteOrderMark . length () < firstBytes . length ) {
return secondCount < 0 ? firstCount > 0 ? firstCount : EOF : firstCount + secondCount ; } @Override public int read ( final byte [] buf ) throws IOException { return read ( buf , 0 , buf . length ) ; MST[rv.CRCR6Mutator]MSP[S] } @Override
final int maxBomSize = boms . get ( 0 ) . length () ; MST[InlineConstantMutator]MSP[N] firstBytes = new int [ maxBomSize ] ; for ( int i = 0 ; i < firstBytes . length ; i ++ ) { firstBytes [ i ] = in . read () ;
final int maxBomSize = boms . get ( 0 ) . length () ; MST[rv.CRCR3Mutator]MSP[N] firstBytes = new int [ maxBomSize ] ; for ( int i = 0 ; i < firstBytes . length ; i ++ ) { firstBytes [ i ] = in . read () ;
} in . reset () ; } @Override public long skip ( final long n ) throws IOException { int skipped = 0 ; while ( ( n > skipped ) && ( readFirstBytes () >= 0 ) ) { MST[ConditionalsBoundaryMutator]MSP[S] skipped ++ ; }
return secondCount < 0 ? firstCount > 0 ? firstCount : EOF : firstCount + secondCount ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] } @Override public int read ( final byte [] buf ) throws IOException { return read ( buf , 0 , buf . length ) ; } @Override
public synchronized void mark ( final int readlimit ) { markFbIndex = fbIndex ; markedAtStart = firstBytes == null ; in . mark ( readlimit ) ; } @Override public synchronized void reset () throws IOException { fbIndex = markFbIndex ; MST[rv.UOI3Mutator]MSP[N] if ( markedAtStart ) { firstBytes = null ;
return 1 ; } return 0 ; } public boolean hasBOM () throws IOException { return getBOM () != null ; MST[rv.CRCR1Mutator]MSP[S] } public boolean hasBOM ( final ByteOrderMark bom ) throws IOException { if ( ! boms . contains ( bom ) ) {
return secondCount < 0 ? firstCount > 0 ? firstCount : EOF : firstCount + secondCount ; MST[rv.ROR4Mutator]MSP[S] } @Override public int read ( final byte [] buf ) throws IOException { return read ( buf , 0 , buf . length ) ; } @Override
fbIndex = byteOrderMark . length () ; } else { fbLength = 0 ; } } } } return byteOrderMark ; } public String getBOMCharsetName () throws IOException { getBOM () ; return byteOrderMark == null ? null : byteOrderMark . getCharsetName () ; MST[ReturnValsMutator]MSP[N] }
public int read ( final byte [] buf , int off , int len ) throws IOException { int firstCount = 0 ; int b = 0 ; while ( len > 0 && b >= 0 ) { MST[rv.UOI4Mutator]MSP[N] b = readFirstBytes () ;
public synchronized void mark ( final int readlimit ) { markFbIndex = fbIndex ; markedAtStart = firstBytes == null ; in . mark ( readlimit ) ; } @Override public synchronized void reset () throws IOException { fbIndex = markFbIndex ; if ( markedAtStart ) { MST[rv.ROR2Mutator]MSP[N] firstBytes = null ;
throw new IllegalArgumentException ( lr_1 + bom ) ; } getBOM () ; return byteOrderMark != null && byteOrderMark . equals ( bom ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } public ByteOrderMark getBOM () throws IOException { if ( firstBytes == null ) { fbLength = 0 ;
public synchronized void mark ( final int readlimit ) { markFbIndex = fbIndex ; markedAtStart = firstBytes == null ; MST[NegateConditionalsMutator]MSP[N] in . mark ( readlimit ) ; } @Override public synchronized void reset () throws IOException { fbIndex = markFbIndex ; if ( markedAtStart ) { firstBytes = null ;
} return null ; } private boolean matches ( final ByteOrderMark bom ) { for ( int i = 0 ; i < bom . length () ; i ++ ) { if ( bom . get ( i ) != firstBytes [ i ] ) { MST[rv.ABSMutator]MSP[N] return false ;
return in . skip ( n - skipped ) + skipped ; MST[rv.AOR1Mutator]MSP[N] }
if ( b >= 0 ) { buf [ off ++ ] = (byte) ( b & 0xFF ) ; MST[rv.UOI4Mutator]MSP[N] len -- ; firstCount ++ ; } } final int secondCount = in . read ( buf , off , len ) ;
return in . skip ( n - skipped ) + skipped ; MST[rv.UOI1Mutator]MSP[N] }
fbLength ++ ; if ( firstBytes [ i ] < 0 ) { MST[rv.ROR3Mutator]MSP[N] break; } } byteOrderMark = find () ; if ( byteOrderMark != null ) { if ( ! include ) { if ( byteOrderMark . length () < firstBytes . length ) {
public int read ( final byte [] buf , int off , int len ) throws IOException { int firstCount = 0 ; int b = 0 ; while ( len > 0 && b >= 0 ) { MST[rv.ROR1Mutator]MSP[N] b = readFirstBytes () ;
return 1 ; } return 0 ; } public boolean hasBOM () throws IOException { return getBOM () != null ; } public boolean hasBOM ( final ByteOrderMark bom ) throws IOException { if ( ! boms . contains ( bom ) ) { MST[rv.ROR1Mutator]MSP[N]
} return null ; } private boolean matches ( final ByteOrderMark bom ) { for ( int i = 0 ; i < bom . length () ; i ++ ) { if ( bom . get ( i ) != firstBytes [ i ] ) { MST[rv.UOI4Mutator]MSP[N] return false ;
} in . reset () ; } @Override public long skip ( final long n ) throws IOException { int skipped = 0 ; while ( ( n > skipped ) && ( readFirstBytes () >= 0 ) ) { MST[rv.ROR5Mutator]MSP[N] skipped ++ ; }
throw new IllegalArgumentException ( lr_1 + bom ) ; } getBOM () ; return byteOrderMark != null && byteOrderMark . equals ( bom ) ; MST[rv.CRCR1Mutator]MSP[N] } public ByteOrderMark getBOM () throws IOException { if ( firstBytes == null ) { fbLength = 0 ;
} in . reset () ; } @Override public long skip ( final long n ) throws IOException { int skipped = 0 ; while ( ( n > skipped ) && ( readFirstBytes () >= 0 ) ) { MST[rv.ROR4Mutator]MSP[S] skipped ++ ; }
} in . reset () ; } @Override public long skip ( final long n ) throws IOException { int skipped = 0 ; while ( ( n > skipped ) && ( readFirstBytes () >= 0 ) ) { skipped ++ ; MST[IncrementsMutator]MSP[N] }
} in . reset () ; } @Override public long skip ( final long n ) throws IOException { int skipped = 0 ; while ( ( n > skipped ) && ( readFirstBytes () >= 0 ) ) { MST[rv.UOI1Mutator]MSP[N] skipped ++ ; }
return secondCount < 0 ? firstCount > 0 ? firstCount : EOF : firstCount + secondCount ; } @Override public int read ( final byte [] buf ) throws IOException { return read ( buf , 0 , buf . length ) ; MST[rv.CRCR1Mutator]MSP[S] } @Override
} in . reset () ; } @Override public long skip ( final long n ) throws IOException { int skipped = 0 ; while ( ( n > skipped ) && ( readFirstBytes () >= 0 ) ) { MST[NegateConditionalsMutator]MSP[N] skipped ++ ; }
public int read ( final byte [] buf , int off , int len ) throws IOException { int firstCount = 0 ; int b = 0 ; MST[rv.CRCR3Mutator]MSP[N] while ( len > 0 && b >= 0 ) { b = readFirstBytes () ;
return secondCount < 0 ? firstCount > 0 ? firstCount : EOF : firstCount + secondCount ; MST[rv.CRCR5Mutator]MSP[N] } @Override public int read ( final byte [] buf ) throws IOException { return read ( buf , 0 , buf . length ) ; } @Override
fbLength ++ ; MST[rv.AOR3Mutator]MSP[N] if ( firstBytes [ i ] < 0 ) { break; } } byteOrderMark = find () ; if ( byteOrderMark != null ) { if ( ! include ) { if ( byteOrderMark . length () < firstBytes . length ) {
public int read ( final byte [] buf , int off , int len ) throws IOException { int firstCount = 0 ; int b = 0 ; MST[InlineConstantMutator]MSP[S] while ( len > 0 && b >= 0 ) { b = readFirstBytes () ;
fbLength ++ ; MST[rv.UOI3Mutator]MSP[N] if ( firstBytes [ i ] < 0 ) { break; } } byteOrderMark = find () ; if ( byteOrderMark != null ) { if ( ! include ) { if ( byteOrderMark . length () < firstBytes . length ) {
fbIndex = byteOrderMark . length () ; } else { fbLength = 0 ; } } } } return byteOrderMark ; } public String getBOMCharsetName () throws IOException { getBOM () ; return byteOrderMark == null ? null : byteOrderMark . getCharsetName () ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] }
return secondCount < 0 ? firstCount > 0 ? firstCount : EOF : firstCount + secondCount ; MST[rv.UOI2Mutator]MSP[S] } @Override public int read ( final byte [] buf ) throws IOException { return read ( buf , 0 , buf . length ) ; } @Override
fbIndex = byteOrderMark . length () ; } else { fbLength = 0 ; MST[InlineConstantMutator]MSP[N] } } } } return byteOrderMark ; } public String getBOMCharsetName () throws IOException { getBOM () ; return byteOrderMark == null ? null : byteOrderMark . getCharsetName () ; }
return secondCount < 0 ? firstCount > 0 ? firstCount : EOF : firstCount + secondCount ; MST[rv.UOI1Mutator]MSP[N] } @Override public int read ( final byte [] buf ) throws IOException { return read ( buf , 0 , buf . length ) ; } @Override
fbLength ++ ; if ( firstBytes [ i ] < 0 ) { break; } } byteOrderMark = find () ; if ( byteOrderMark != null ) { if ( ! include ) { if ( byteOrderMark . length () < firstBytes . length ) { MST[rv.ROR4Mutator]MSP[N]
} return null ; } private boolean matches ( final ByteOrderMark bom ) { for ( int i = 0 ; i < bom . length () ; i ++ ) { if ( bom . get ( i ) != firstBytes [ i ] ) { return false ; MST[BooleanTrueReturnValsMutator]MSP[N]
if ( b >= 0 ) { buf [ off ++ ] = (byte) ( b & 0xFF ) ; len -- ; MST[IncrementsMutator]MSP[N] firstCount ++ ; } } final int secondCount = in . read ( buf , off , len ) ;
if ( b >= 0 ) { buf [ off ++ ] = (byte) ( b & 0xFF ) ; MST[experimental.RemoveIncrementsMutator]MSP[N] len -- ; firstCount ++ ; } } final int secondCount = in . read ( buf , off , len ) ;
return secondCount < 0 ? firstCount > 0 ? firstCount : EOF : firstCount + secondCount ; MST[rv.UOI4Mutator]MSP[N] } @Override public int read ( final byte [] buf ) throws IOException { return read ( buf , 0 , buf . length ) ; } @Override
} in . reset () ; } @Override public long skip ( final long n ) throws IOException { int skipped = 0 ; while ( ( n > skipped ) && ( readFirstBytes () >= 0 ) ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] skipped ++ ; }
final int maxBomSize = boms . get ( 0 ) . length () ; firstBytes = new int [ maxBomSize ] ; for ( int i = 0 ; i < firstBytes . length ; i ++ ) { firstBytes [ i ] = in . read () ; MST[rv.UOI2Mutator]MSP[N]
fbLength ++ ; if ( firstBytes [ i ] < 0 ) { break; } } byteOrderMark = find () ; if ( byteOrderMark != null ) { if ( ! include ) { if ( byteOrderMark . length () < firstBytes . length ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[S]
public synchronized void mark ( final int readlimit ) { markFbIndex = fbIndex ; markedAtStart = firstBytes == null ; MST[InlineConstantMutator]MSP[N] in . mark ( readlimit ) ; } @Override public synchronized void reset () throws IOException { fbIndex = markFbIndex ; if ( markedAtStart ) { firstBytes = null ;
throw new IllegalArgumentException ( lr_1 + bom ) ; } getBOM () ; return byteOrderMark != null && byteOrderMark . equals ( bom ) ; MST[rv.CRCR3Mutator]MSP[N] } public ByteOrderMark getBOM () throws IOException { if ( firstBytes == null ) { fbLength = 0 ;
throw new IllegalArgumentException ( lr_1 + bom ) ; } getBOM () ; return byteOrderMark != null && byteOrderMark . equals ( bom ) ; MST[rv.CRCR2Mutator]MSP[N] } public ByteOrderMark getBOM () throws IOException { if ( firstBytes == null ) { fbLength = 0 ;
throw new IllegalArgumentException ( lr_1 + bom ) ; } getBOM () ; return byteOrderMark != null && byteOrderMark . equals ( bom ) ; MST[rv.CRCR6Mutator]MSP[N] } public ByteOrderMark getBOM () throws IOException { if ( firstBytes == null ) { fbLength = 0 ;
} } return true ; } @Override public int read () throws IOException { final int b = readFirstBytes () ; return b >= 0 ? b : in . read () ; MST[rv.UOI4Mutator]MSP[N] } @Override
} return null ; } private boolean matches ( final ByteOrderMark bom ) { for ( int i = 0 ; i < bom . length () ; i ++ ) { if ( bom . get ( i ) != firstBytes [ i ] ) { return false ; MST[rv.CRCR3Mutator]MSP[N]
final int maxBomSize = boms . get ( 0 ) . length () ; firstBytes = new int [ maxBomSize ] ; for ( int i = 0 ; i < firstBytes . length ; i ++ ) { MST[rv.CRCR3Mutator]MSP[N] firstBytes [ i ] = in . read () ;
} return null ; } private boolean matches ( final ByteOrderMark bom ) { for ( int i = 0 ; i < bom . length () ; i ++ ) { if ( bom . get ( i ) != firstBytes [ i ] ) { MST[ArgumentPropagationMutator]MSP[N] return false ;
public int read ( final byte [] buf , int off , int len ) throws IOException { int firstCount = 0 ; int b = 0 ; while ( len > 0 && b >= 0 ) { MST[ConditionalsBoundaryMutator]MSP[N] b = readFirstBytes () ;
} return null ; } private boolean matches ( final ByteOrderMark bom ) { for ( int i = 0 ; i < bom . length () ; i ++ ) { if ( bom . get ( i ) != firstBytes [ i ] ) { MST[rv.ABSMutator]MSP[N] return false ;
fbLength ++ ; if ( firstBytes [ i ] < 0 ) { break; } } byteOrderMark = find () ; if ( byteOrderMark != null ) { if ( ! include ) { if ( byteOrderMark . length () < firstBytes . length ) { MST[ConditionalsBoundaryMutator]MSP[N]
private int readFirstBytes () throws IOException { getBOM () ; return fbIndex < fbLength ? firstBytes [ fbIndex ++ ] : EOF ; MST[rv.UOI4Mutator]MSP[N] } private ByteOrderMark find () { for ( final ByteOrderMark bom : boms ) { if ( matches ( bom ) ) { return bom ; }
} return null ; } private boolean matches ( final ByteOrderMark bom ) { for ( int i = 0 ; i < bom . length () ; i ++ ) { if ( bom . get ( i ) != firstBytes [ i ] ) { MST[rv.ROR3Mutator]MSP[N] return false ;
} return null ; } private boolean matches ( final ByteOrderMark bom ) { for ( int i = 0 ; i < bom . length () ; i ++ ) { MST[rv.UOI3Mutator]MSP[S] if ( bom . get ( i ) != firstBytes [ i ] ) { return false ;
return secondCount < 0 ? firstCount > 0 ? firstCount : EOF : firstCount + secondCount ; MST[rv.AOR1Mutator]MSP[N] } @Override public int read ( final byte [] buf ) throws IOException { return read ( buf , 0 , buf . length ) ; } @Override
throw new IllegalArgumentException ( lr_1 + bom ) ; } getBOM () ; return byteOrderMark != null && byteOrderMark . equals ( bom ) ; } public ByteOrderMark getBOM () throws IOException { if ( firstBytes == null ) { fbLength = 0 ; MST[InlineConstantMutator]MSP[N]
} } return true ; } @Override public int read () throws IOException { final int b = readFirstBytes () ; return b >= 0 ? b : in . read () ; MST[rv.ROR1Mutator]MSP[N] } @Override
return in . skip ( n - skipped ) + skipped ; MST[rv.UOI2Mutator]MSP[N] }
private int readFirstBytes () throws IOException { getBOM () ; MST[NonVoidMethodCallMutator]MSP[N] return fbIndex < fbLength ? firstBytes [ fbIndex ++ ] : EOF ; } private ByteOrderMark find () { for ( final ByteOrderMark bom : boms ) { if ( matches ( bom ) ) { return bom ; }
public int read ( final byte [] buf , int off , int len ) throws IOException { int firstCount = 0 ; int b = 0 ; while ( len > 0 && b >= 0 ) { MST[rv.ROR4Mutator]MSP[N] b = readFirstBytes () ;
if ( b >= 0 ) { buf [ off ++ ] = (byte) ( b & 0xFF ) ; MST[rv.UOI3Mutator]MSP[N] len -- ; firstCount ++ ; } } final int secondCount = in . read ( buf , off , len ) ;
fbIndex = byteOrderMark . length () ; } else { fbLength = 0 ; } } } } return byteOrderMark ; } public String getBOMCharsetName () throws IOException { getBOM () ; MST[NonVoidMethodCallMutator]MSP[N] return byteOrderMark == null ? null : byteOrderMark . getCharsetName () ; }
private int readFirstBytes () throws IOException { getBOM () ; return fbIndex < fbLength ? firstBytes [ fbIndex ++ ] : EOF ; MST[rv.ROR1Mutator]MSP[N] } private ByteOrderMark find () { for ( final ByteOrderMark bom : boms ) { if ( matches ( bom ) ) { return bom ; }
private int readFirstBytes () throws IOException { getBOM () ; return fbIndex < fbLength ? firstBytes [ fbIndex ++ ] : EOF ; MST[rv.ROR5Mutator]MSP[N] } private ByteOrderMark find () { for ( final ByteOrderMark bom : boms ) { if ( matches ( bom ) ) { return bom ; }
fbLength ++ ; if ( firstBytes [ i ] < 0 ) { break; } } byteOrderMark = find () ; if ( byteOrderMark != null ) { MST[NegateConditionalsMutator]MSP[N] if ( ! include ) { if ( byteOrderMark . length () < firstBytes . length ) {
fbIndex = byteOrderMark . length () ; } else { fbLength = 0 ; } } } } return byteOrderMark ; } public String getBOMCharsetName () throws IOException { getBOM () ; return byteOrderMark == null ? null : byteOrderMark . getCharsetName () ; MST[rv.ROR5Mutator]MSP[N] }
if ( b >= 0 ) { buf [ off ++ ] = (byte) ( b & 0xFF ) ; MST[rv.OBBN1Mutator]MSP[N] len -- ; firstCount ++ ; } } final int secondCount = in . read ( buf , off , len ) ;
} } return true ; } @Override public int read () throws IOException { final int b = readFirstBytes () ; return b >= 0 ? b : in . read () ; MST[rv.ROR5Mutator]MSP[N] } @Override
return 1 ; } return 0 ; } public boolean hasBOM () throws IOException { return getBOM () != null ; MST[rv.CRCR5Mutator]MSP[N] } public boolean hasBOM ( final ByteOrderMark bom ) throws IOException { if ( ! boms . contains ( bom ) ) {
if ( b >= 0 ) { buf [ off ++ ] = (byte) ( b & 0xFF ) ; len -- ; firstCount ++ ; } } final int secondCount = in . read ( buf , off , len ) ; MST[rv.UOI4Mutator]MSP[N]
fbLength ++ ; if ( firstBytes [ i ] < 0 ) { MST[rv.UOI2Mutator]MSP[N] break; } } byteOrderMark = find () ; if ( byteOrderMark != null ) { if ( ! include ) { if ( byteOrderMark . length () < firstBytes . length ) {
} in . reset () ; } @Override public long skip ( final long n ) throws IOException { int skipped = 0 ; while ( ( n > skipped ) && ( readFirstBytes () >= 0 ) ) { MST[rv.ABSMutator]MSP[N] skipped ++ ; }
return in . skip ( n - skipped ) + skipped ; MST[MathMutator]MSP[N] }
fbLength ++ ; if ( firstBytes [ i ] < 0 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] break; } } byteOrderMark = find () ; if ( byteOrderMark != null ) { if ( ! include ) { if ( byteOrderMark . length () < firstBytes . length ) {
fbLength ++ ; MST[rv.UOI4Mutator]MSP[N] if ( firstBytes [ i ] < 0 ) { break; } } byteOrderMark = find () ; if ( byteOrderMark != null ) { if ( ! include ) { if ( byteOrderMark . length () < firstBytes . length ) {
public synchronized void mark ( final int readlimit ) { markFbIndex = fbIndex ; markedAtStart = firstBytes == null ; in . mark ( readlimit ) ; } @Override public synchronized void reset () throws IOException { fbIndex = markFbIndex ; MST[rv.UOI1Mutator]MSP[N] if ( markedAtStart ) { firstBytes = null ;
public synchronized void mark ( final int readlimit ) { markFbIndex = fbIndex ; markedAtStart = firstBytes == null ; in . mark ( readlimit ) ; MST[rv.UOI4Mutator]MSP[N] } @Override public synchronized void reset () throws IOException { fbIndex = markFbIndex ; if ( markedAtStart ) { firstBytes = null ;
final int maxBomSize = boms . get ( 0 ) . length () ; firstBytes = new int [ maxBomSize ] ; MST[experimental.MemberVariableMutator]MSP[N] for ( int i = 0 ; i < firstBytes . length ; i ++ ) { firstBytes [ i ] = in . read () ;
return secondCount < 0 ? firstCount > 0 ? firstCount : EOF : firstCount + secondCount ; MST[rv.ABSMutator]MSP[N] } @Override public int read ( final byte [] buf ) throws IOException { return read ( buf , 0 , buf . length ) ; } @Override
final int maxBomSize = boms . get ( 0 ) . length () ; firstBytes = new int [ maxBomSize ] ; for ( int i = 0 ; i < firstBytes . length ; i ++ ) { firstBytes [ i ] = in . read () ; MST[rv.ABSMutator]MSP[N]
fbLength ++ ; if ( firstBytes [ i ] < 0 ) { break; } } byteOrderMark = find () ; if ( byteOrderMark != null ) { if ( ! include ) { if ( byteOrderMark . length () < firstBytes . length ) { MST[NonVoidMethodCallMutator]MSP[N]
public synchronized void mark ( final int readlimit ) { markFbIndex = fbIndex ; MST[rv.UOI3Mutator]MSP[N] markedAtStart = firstBytes == null ; in . mark ( readlimit ) ; } @Override public synchronized void reset () throws IOException { fbIndex = markFbIndex ; if ( markedAtStart ) { firstBytes = null ;
public int read ( final byte [] buf , int off , int len ) throws IOException { int firstCount = 0 ; int b = 0 ; while ( len > 0 && b >= 0 ) { MST[rv.UOI3Mutator]MSP[N] b = readFirstBytes () ;
} return null ; } private boolean matches ( final ByteOrderMark bom ) { for ( int i = 0 ; i < bom . length () ; i ++ ) { if ( bom . get ( i ) != firstBytes [ i ] ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return false ;
fbLength ++ ; if ( firstBytes [ i ] < 0 ) { break; } } byteOrderMark = find () ; if ( byteOrderMark != null ) { if ( ! include ) { if ( byteOrderMark . length () < firstBytes . length ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N]
public synchronized void mark ( final int readlimit ) { markFbIndex = fbIndex ; markedAtStart = firstBytes == null ; in . mark ( readlimit ) ; } @Override public synchronized void reset () throws IOException { fbIndex = markFbIndex ; if ( markedAtStart ) { MST[rv.ROR4Mutator]MSP[S] firstBytes = null ;
fbIndex = byteOrderMark . length () ; } else { fbLength = 0 ; } } } } return byteOrderMark ; } public String getBOMCharsetName () throws IOException { getBOM () ; return byteOrderMark == null ? null : byteOrderMark . getCharsetName () ; MST[EmptyObjectReturnValsMutator]MSP[N] }
fbLength ++ ; if ( firstBytes [ i ] < 0 ) { break; } } byteOrderMark = find () ; MST[NonVoidMethodCallMutator]MSP[N] if ( byteOrderMark != null ) { if ( ! include ) { if ( byteOrderMark . length () < firstBytes . length ) {
public int read ( final byte [] buf , int off , int len ) throws IOException { int firstCount = 0 ; int b = 0 ; while ( len > 0 && b >= 0 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] b = readFirstBytes () ;
return in . skip ( n - skipped ) + skipped ; MST[rv.AOR3Mutator]MSP[N] }
throw new IllegalArgumentException ( lr_1 + bom ) ; } getBOM () ; return byteOrderMark != null && byteOrderMark . equals ( bom ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] } public ByteOrderMark getBOM () throws IOException { if ( firstBytes == null ) { fbLength = 0 ;
public int read ( final byte [] buf , int off , int len ) throws IOException { int firstCount = 0 ; int b = 0 ; while ( len > 0 && b >= 0 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] b = readFirstBytes () ;
return in . skip ( n - skipped ) + skipped ; MST[rv.UOI2Mutator]MSP[N] }
return in . skip ( n - skipped ) + skipped ; MST[rv.UOI3Mutator]MSP[N] }
fbLength ++ ; if ( firstBytes [ i ] < 0 ) { MST[rv.ABSMutator]MSP[N] break; } } byteOrderMark = find () ; if ( byteOrderMark != null ) { if ( ! include ) { if ( byteOrderMark . length () < firstBytes . length ) {
} return null ; } private boolean matches ( final ByteOrderMark bom ) { for ( int i = 0 ; i < bom . length () ; i ++ ) { if ( bom . get ( i ) != firstBytes [ i ] ) { MST[rv.UOI2Mutator]MSP[N] return false ;
fbLength ++ ; MST[rv.CRCR5Mutator]MSP[N] if ( firstBytes [ i ] < 0 ) { break; } } byteOrderMark = find () ; if ( byteOrderMark != null ) { if ( ! include ) { if ( byteOrderMark . length () < firstBytes . length ) {
private int readFirstBytes () throws IOException { getBOM () ; return fbIndex < fbLength ? firstBytes [ fbIndex ++ ] : EOF ; MST[rv.ABSMutator]MSP[N] } private ByteOrderMark find () { for ( final ByteOrderMark bom : boms ) { if ( matches ( bom ) ) { return bom ; }
} return null ; } private boolean matches ( final ByteOrderMark bom ) { for ( int i = 0 ; i < bom . length () ; i ++ ) { MST[NegateConditionalsMutator]MSP[N] if ( bom . get ( i ) != firstBytes [ i ] ) { return false ;
return 1 ; } return 0 ; } public boolean hasBOM () throws IOException { return getBOM () != null ; } public boolean hasBOM ( final ByteOrderMark bom ) throws IOException { if ( ! boms . contains ( bom ) ) { MST[rv.ROR3Mutator]MSP[N]
private int readFirstBytes () throws IOException { getBOM () ; return fbIndex < fbLength ? firstBytes [ fbIndex ++ ] : EOF ; MST[rv.UOI1Mutator]MSP[S] } private ByteOrderMark find () { for ( final ByteOrderMark bom : boms ) { if ( matches ( bom ) ) { return bom ; }
} in . reset () ; } @Override public long skip ( final long n ) throws IOException { int skipped = 0 ; while ( ( n > skipped ) && ( readFirstBytes () >= 0 ) ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[S] skipped ++ ; }
fbIndex = byteOrderMark . length () ; } else { fbLength = 0 ; } } } } return byteOrderMark ; } public String getBOMCharsetName () throws IOException { getBOM () ; return byteOrderMark == null ? null : byteOrderMark . getCharsetName () ; MST[NegateConditionalsMutator]MSP[N] }
} return null ; MST[ReturnValsMutator]MSP[N] } private boolean matches ( final ByteOrderMark bom ) { for ( int i = 0 ; i < bom . length () ; i ++ ) { if ( bom . get ( i ) != firstBytes [ i ] ) { return false ;
throw new IllegalArgumentException ( lr_1 + bom ) ; } getBOM () ; return byteOrderMark != null && byteOrderMark . equals ( bom ) ; MST[BooleanTrueReturnValsMutator]MSP[N] } public ByteOrderMark getBOM () throws IOException { if ( firstBytes == null ) { fbLength = 0 ;
return secondCount < 0 ? firstCount > 0 ? firstCount : EOF : firstCount + secondCount ; } @Override public int read ( final byte [] buf ) throws IOException { return read ( buf , 0 , buf . length ) ; MST[rv.CRCR3Mutator]MSP[S] } @Override
return 1 ; } return 0 ; } public boolean hasBOM () throws IOException { return getBOM () != null ; MST[rv.CRCR6Mutator]MSP[S] } public boolean hasBOM ( final ByteOrderMark bom ) throws IOException { if ( ! boms . contains ( bom ) ) {
if ( b >= 0 ) { buf [ off ++ ] = (byte) ( b & 0xFF ) ; len -- ; firstCount ++ ; } } final int secondCount = in . read ( buf , off , len ) ; MST[rv.UOI4Mutator]MSP[N]
throw new IllegalArgumentException ( lr_1 + bom ) ; } getBOM () ; return byteOrderMark != null && byteOrderMark . equals ( bom ) ; MST[InlineConstantMutator]MSP[N] } public ByteOrderMark getBOM () throws IOException { if ( firstBytes == null ) { fbLength = 0 ;
return 1 ; } return 0 ; } public boolean hasBOM () throws IOException { return getBOM () != null ; } public boolean hasBOM ( final ByteOrderMark bom ) throws IOException { if ( ! boms . contains ( bom ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
} return null ; } private boolean matches ( final ByteOrderMark bom ) { for ( int i = 0 ; i < bom . length () ; i ++ ) { MST[rv.CRCR6Mutator]MSP[N] if ( bom . get ( i ) != firstBytes [ i ] ) { return false ;
} } return true ; } @Override public int read () throws IOException { final int b = readFirstBytes () ; return b >= 0 ? b : in . read () ; MST[NonVoidMethodCallMutator]MSP[N] } @Override
throw new IllegalArgumentException ( lr_1 + bom ) ; } getBOM () ; return byteOrderMark != null && byteOrderMark . equals ( bom ) ; } public ByteOrderMark getBOM () throws IOException { if ( firstBytes == null ) { fbLength = 0 ; MST[rv.CRCR6Mutator]MSP[N]
fbLength ++ ; MST[rv.AOR1Mutator]MSP[N] if ( firstBytes [ i ] < 0 ) { break; } } byteOrderMark = find () ; if ( byteOrderMark != null ) { if ( ! include ) { if ( byteOrderMark . length () < firstBytes . length ) {
throw new IllegalArgumentException ( lr_1 + bom ) ; } getBOM () ; return byteOrderMark != null && byteOrderMark . equals ( bom ) ; MST[rv.ROR2Mutator]MSP[N] } public ByteOrderMark getBOM () throws IOException { if ( firstBytes == null ) { fbLength = 0 ;
private int readFirstBytes () throws IOException { getBOM () ; return fbIndex < fbLength ? firstBytes [ fbIndex ++ ] : EOF ; } private ByteOrderMark find () { for ( final ByteOrderMark bom : boms ) { if ( matches ( bom ) ) { MST[rv.ROR3Mutator]MSP[N] return bom ; }
return in . skip ( n - skipped ) + skipped ; MST[rv.AOD2Mutator]MSP[N] }
} } return true ; } @Override public int read () throws IOException { final int b = readFirstBytes () ; return b >= 0 ? b : in . read () ; MST[rv.UOI4Mutator]MSP[N] } @Override
return secondCount < 0 ? firstCount > 0 ? firstCount : EOF : firstCount + secondCount ; MST[rv.UOI1Mutator]MSP[N] } @Override public int read ( final byte [] buf ) throws IOException { return read ( buf , 0 , buf . length ) ; } @Override
private int readFirstBytes () throws IOException { getBOM () ; return fbIndex < fbLength ? firstBytes [ fbIndex ++ ] : EOF ; MST[rv.UOI3Mutator]MSP[N] } private ByteOrderMark find () { for ( final ByteOrderMark bom : boms ) { if ( matches ( bom ) ) { return bom ; }
final int maxBomSize = boms . get ( 0 ) . length () ; firstBytes = new int [ maxBomSize ] ; MST[rv.UOI1Mutator]MSP[S] for ( int i = 0 ; i < firstBytes . length ; i ++ ) { firstBytes [ i ] = in . read () ;
public int read ( final byte [] buf , int off , int len ) throws IOException { int firstCount = 0 ; int b = 0 ; while ( len > 0 && b >= 0 ) { MST[ConditionalsBoundaryMutator]MSP[N] b = readFirstBytes () ;
public synchronized void mark ( final int readlimit ) { markFbIndex = fbIndex ; markedAtStart = firstBytes == null ; MST[rv.CRCR5Mutator]MSP[S] in . mark ( readlimit ) ; } @Override public synchronized void reset () throws IOException { fbIndex = markFbIndex ; if ( markedAtStart ) { firstBytes = null ;
throw new IllegalArgumentException ( lr_1 + bom ) ; } getBOM () ; return byteOrderMark != null && byteOrderMark . equals ( bom ) ; } public ByteOrderMark getBOM () throws IOException { if ( firstBytes == null ) { fbLength = 0 ; MST[experimental.MemberVariableMutator]MSP[N]
fbLength ++ ; if ( firstBytes [ i ] < 0 ) { break; } } byteOrderMark = find () ; MST[experimental.MemberVariableMutator]MSP[N] if ( byteOrderMark != null ) { if ( ! include ) { if ( byteOrderMark . length () < firstBytes . length ) {
} } return true ; MST[ReturnValsMutator]MSP[N] } @Override public int read () throws IOException { final int b = readFirstBytes () ; return b >= 0 ? b : in . read () ; } @Override
public synchronized void mark ( final int readlimit ) { markFbIndex = fbIndex ; markedAtStart = firstBytes == null ; MST[rv.CRCR6Mutator]MSP[N] in . mark ( readlimit ) ; } @Override public synchronized void reset () throws IOException { fbIndex = markFbIndex ; if ( markedAtStart ) { firstBytes = null ;
} } return true ; MST[rv.CRCR6Mutator]MSP[N] } @Override public int read () throws IOException { final int b = readFirstBytes () ; return b >= 0 ? b : in . read () ; } @Override
return 1 ; } return 0 ; } public boolean hasBOM () throws IOException { return getBOM () != null ; MST[rv.ROR5Mutator]MSP[N] } public boolean hasBOM ( final ByteOrderMark bom ) throws IOException { if ( ! boms . contains ( bom ) ) {
} return null ; } private boolean matches ( final ByteOrderMark bom ) { for ( int i = 0 ; i < bom . length () ; i ++ ) { MST[rv.ROR4Mutator]MSP[S] if ( bom . get ( i ) != firstBytes [ i ] ) { return false ;
if ( b >= 0 ) { buf [ off ++ ] = (byte) ( b & 0xFF ) ; MST[rv.CRCR4Mutator]MSP[N] len -- ; firstCount ++ ; } } final int secondCount = in . read ( buf , off , len ) ;
fbLength ++ ; if ( firstBytes [ i ] < 0 ) { break; } } byteOrderMark = find () ; if ( byteOrderMark != null ) { MST[rv.ROR5Mutator]MSP[N] if ( ! include ) { if ( byteOrderMark . length () < firstBytes . length ) {
fbIndex = byteOrderMark . length () ; } else { fbLength = 0 ; MST[rv.CRCR3Mutator]MSP[N] } } } } return byteOrderMark ; } public String getBOMCharsetName () throws IOException { getBOM () ; return byteOrderMark == null ? null : byteOrderMark . getCharsetName () ; }
fbIndex = byteOrderMark . length () ; } else { fbLength = 0 ; MST[rv.CRCR6Mutator]MSP[N] } } } } return byteOrderMark ; } public String getBOMCharsetName () throws IOException { getBOM () ; return byteOrderMark == null ? null : byteOrderMark . getCharsetName () ; }
private int readFirstBytes () throws IOException { getBOM () ; return fbIndex < fbLength ? firstBytes [ fbIndex ++ ] : EOF ; MST[NegateConditionalsMutator]MSP[N] } private ByteOrderMark find () { for ( final ByteOrderMark bom : boms ) { if ( matches ( bom ) ) { return bom ; }
} return null ; } private boolean matches ( final ByteOrderMark bom ) { for ( int i = 0 ; i < bom . length () ; i ++ ) { MST[rv.ROR5Mutator]MSP[N] if ( bom . get ( i ) != firstBytes [ i ] ) { return false ;
fbLength ++ ; if ( firstBytes [ i ] < 0 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] break; } } byteOrderMark = find () ; if ( byteOrderMark != null ) { if ( ! include ) { if ( byteOrderMark . length () < firstBytes . length ) {
} return null ; } private boolean matches ( final ByteOrderMark bom ) { for ( int i = 0 ; i < bom . length () ; i ++ ) { if ( bom . get ( i ) != firstBytes [ i ] ) { return false ; MST[InlineConstantMutator]MSP[N]
fbLength ++ ; if ( firstBytes [ i ] < 0 ) { MST[rv.ROR4Mutator]MSP[N] break; } } byteOrderMark = find () ; if ( byteOrderMark != null ) { if ( ! include ) { if ( byteOrderMark . length () < firstBytes . length ) {
public synchronized void mark ( final int readlimit ) { markFbIndex = fbIndex ; markedAtStart = firstBytes == null ; MST[rv.CRCR3Mutator]MSP[N] in . mark ( readlimit ) ; } @Override public synchronized void reset () throws IOException { fbIndex = markFbIndex ; if ( markedAtStart ) { firstBytes = null ;
fbLength ++ ; if ( firstBytes [ i ] < 0 ) { break; } } byteOrderMark = find () ; if ( byteOrderMark != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] if ( ! include ) { if ( byteOrderMark . length () < firstBytes . length ) {
} in . reset () ; } @Override public long skip ( final long n ) throws IOException { int skipped = 0 ; MST[rv.CRCR1Mutator]MSP[N] while ( ( n > skipped ) && ( readFirstBytes () >= 0 ) ) { skipped ++ ; }
fbIndex = byteOrderMark . length () ; } else { fbLength = 0 ; MST[experimental.MemberVariableMutator]MSP[N] } } } } return byteOrderMark ; } public String getBOMCharsetName () throws IOException { getBOM () ; return byteOrderMark == null ? null : byteOrderMark . getCharsetName () ; }
} in . reset () ; } @Override public long skip ( final long n ) throws IOException { int skipped = 0 ; while ( ( n > skipped ) && ( readFirstBytes () >= 0 ) ) { MST[rv.ROR4Mutator]MSP[N] skipped ++ ; }
return 1 ; } return 0 ; } public boolean hasBOM () throws IOException { return getBOM () != null ; } public boolean hasBOM ( final ByteOrderMark bom ) throws IOException { if ( ! boms . contains ( bom ) ) { MST[NonVoidMethodCallMutator]MSP[N]
if ( b >= 0 ) { buf [ off ++ ] = (byte) ( b & 0xFF ) ; len -- ; firstCount ++ ; } } final int secondCount = in . read ( buf , off , len ) ; MST[rv.UOI3Mutator]MSP[N]
} in . reset () ; } @Override public long skip ( final long n ) throws IOException { int skipped = 0 ; while ( ( n > skipped ) && ( readFirstBytes () >= 0 ) ) { MST[NegateConditionalsMutator]MSP[N] skipped ++ ; }
fbLength ++ ; MST[rv.AOR2Mutator]MSP[N] if ( firstBytes [ i ] < 0 ) { break; } } byteOrderMark = find () ; if ( byteOrderMark != null ) { if ( ! include ) { if ( byteOrderMark . length () < firstBytes . length ) {
return 1 ; } return 0 ; } public boolean hasBOM () throws IOException { return getBOM () != null ; MST[InlineConstantMutator]MSP[S] } public boolean hasBOM ( final ByteOrderMark bom ) throws IOException { if ( ! boms . contains ( bom ) ) {
throw new IllegalArgumentException ( lr_1 + bom ) ; } getBOM () ; return byteOrderMark != null && byteOrderMark . equals ( bom ) ; } public ByteOrderMark getBOM () throws IOException { if ( firstBytes == null ) { fbLength = 0 ; MST[rv.CRCR3Mutator]MSP[N]
return secondCount < 0 ? firstCount > 0 ? firstCount : EOF : firstCount + secondCount ; MST[rv.ROR3Mutator]MSP[N] } @Override public int read ( final byte [] buf ) throws IOException { return read ( buf , 0 , buf . length ) ; } @Override
public synchronized void mark ( final int readlimit ) { markFbIndex = fbIndex ; markedAtStart = firstBytes == null ; in . mark ( readlimit ) ; } @Override public synchronized void reset () throws IOException { fbIndex = markFbIndex ; MST[rv.UOI2Mutator]MSP[N] if ( markedAtStart ) { firstBytes = null ;
final int maxBomSize = boms . get ( 0 ) . length () ; firstBytes = new int [ maxBomSize ] ; for ( int i = 0 ; i < firstBytes . length ; i ++ ) { MST[rv.UOI4Mutator]MSP[N] firstBytes [ i ] = in . read () ;
final int maxBomSize = boms . get ( 0 ) . length () ; firstBytes = new int [ maxBomSize ] ; for ( int i = 0 ; i < firstBytes . length ; i ++ ) { MST[rv.ROR2Mutator]MSP[N] firstBytes [ i ] = in . read () ;
return secondCount < 0 ? firstCount > 0 ? firstCount : EOF : firstCount + secondCount ; MST[rv.ABSMutator]MSP[N] } @Override public int read ( final byte [] buf ) throws IOException { return read ( buf , 0 , buf . length ) ; } @Override
return secondCount < 0 ? firstCount > 0 ? firstCount : EOF : firstCount + secondCount ; MST[rv.ROR2Mutator]MSP[N] } @Override public int read ( final byte [] buf ) throws IOException { return read ( buf , 0 , buf . length ) ; } @Override
throw new IllegalArgumentException ( lr_1 + bom ) ; } getBOM () ; return byteOrderMark != null && byteOrderMark . equals ( bom ) ; MST[rv.ROR5Mutator]MSP[N] } public ByteOrderMark getBOM () throws IOException { if ( firstBytes == null ) { fbLength = 0 ;
return in . skip ( n - skipped ) + skipped ; MST[rv.AOR1Mutator]MSP[N] }
public int read ( final byte [] buf , int off , int len ) throws IOException { int firstCount = 0 ; int b = 0 ; while ( len > 0 && b >= 0 ) { MST[rv.UOI2Mutator]MSP[N] b = readFirstBytes () ;
fbIndex = byteOrderMark . length () ; } else { fbLength = 0 ; } } } } return byteOrderMark ; } public String getBOMCharsetName () throws IOException { getBOM () ; return byteOrderMark == null ? null : byteOrderMark . getCharsetName () ; MST[NonVoidMethodCallMutator]MSP[N] }
public synchronized void mark ( final int readlimit ) { markFbIndex = fbIndex ; markedAtStart = firstBytes == null ; in . mark ( readlimit ) ; } @Override public synchronized void reset () throws IOException { fbIndex = markFbIndex ; MST[experimental.MemberVariableMutator]MSP[N] if ( markedAtStart ) { firstBytes = null ;
fbLength ++ ; if ( firstBytes [ i ] < 0 ) { break; } } byteOrderMark = find () ; if ( byteOrderMark != null ) { if ( ! include ) { MST[rv.ROR2Mutator]MSP[N] if ( byteOrderMark . length () < firstBytes . length ) {
} return null ; } private boolean matches ( final ByteOrderMark bom ) { for ( int i = 0 ; i < bom . length () ; i ++ ) { if ( bom . get ( i ) != firstBytes [ i ] ) { MST[rv.UOI4Mutator]MSP[N] return false ;
public synchronized void mark ( final int readlimit ) { markFbIndex = fbIndex ; markedAtStart = firstBytes == null ; in . mark ( readlimit ) ; } @Override public synchronized void reset () throws IOException { fbIndex = markFbIndex ; if ( markedAtStart ) { MST[rv.ROR3Mutator]MSP[N] firstBytes = null ;
return secondCount < 0 ? firstCount > 0 ? firstCount : EOF : firstCount + secondCount ; MST[rv.UOI4Mutator]MSP[N] } @Override public int read ( final byte [] buf ) throws IOException { return read ( buf , 0 , buf . length ) ; } @Override
return in . skip ( n - skipped ) + skipped ; MST[rv.AOR4Mutator]MSP[N] }
final int maxBomSize = boms . get ( 0 ) . length () ; firstBytes = new int [ maxBomSize ] ; MST[rv.ABSMutator]MSP[N] for ( int i = 0 ; i < firstBytes . length ; i ++ ) { firstBytes [ i ] = in . read () ;
} return null ; } private boolean matches ( final ByteOrderMark bom ) { for ( int i = 0 ; i < bom . length () ; i ++ ) { if ( bom . get ( i ) != firstBytes [ i ] ) { MST[rv.UOI1Mutator]MSP[N] return false ;
private int readFirstBytes () throws IOException { getBOM () ; return fbIndex < fbLength ? firstBytes [ fbIndex ++ ] : EOF ; } private ByteOrderMark find () { for ( final ByteOrderMark bom : boms ) { if ( matches ( bom ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return bom ; }
if ( b >= 0 ) { buf [ off ++ ] = (byte) ( b & 0xFF ) ; MST[rv.UOI2Mutator]MSP[N] len -- ; firstCount ++ ; } } final int secondCount = in . read ( buf , off , len ) ;
public int read ( final byte [] buf , int off , int len ) throws IOException { int firstCount = 0 ; int b = 0 ; while ( len > 0 && b >= 0 ) { MST[rv.ROR5Mutator]MSP[N] b = readFirstBytes () ;
} return null ; } private boolean matches ( final ByteOrderMark bom ) { for ( int i = 0 ; i < bom . length () ; i ++ ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] if ( bom . get ( i ) != firstBytes [ i ] ) { return false ;
public synchronized void mark ( final int readlimit ) { markFbIndex = fbIndex ; markedAtStart = firstBytes == null ; MST[rv.CRCR2Mutator]MSP[S] in . mark ( readlimit ) ; } @Override public synchronized void reset () throws IOException { fbIndex = markFbIndex ; if ( markedAtStart ) { firstBytes = null ;
if ( b >= 0 ) { buf [ off ++ ] = (byte) ( b & 0xFF ) ; MST[rv.OBBN2Mutator]MSP[S] len -- ; firstCount ++ ; } } final int secondCount = in . read ( buf , off , len ) ;
} } return true ; } @Override public int read () throws IOException { final int b = readFirstBytes () ; return b >= 0 ? b : in . read () ; MST[rv.UOI1Mutator]MSP[S] } @Override
private int readFirstBytes () throws IOException { getBOM () ; return fbIndex < fbLength ? firstBytes [ fbIndex ++ ] : EOF ; MST[rv.UOI2Mutator]MSP[N] } private ByteOrderMark find () { for ( final ByteOrderMark bom : boms ) { if ( matches ( bom ) ) { return bom ; }
} in . reset () ; } @Override public long skip ( final long n ) throws IOException { int skipped = 0 ; while ( ( n > skipped ) && ( readFirstBytes () >= 0 ) ) { MST[rv.ROR1Mutator]MSP[S] skipped ++ ; }
return 1 ; } return 0 ; } public boolean hasBOM () throws IOException { return getBOM () != null ; MST[rv.CRCR4Mutator]MSP[N] } public boolean hasBOM ( final ByteOrderMark bom ) throws IOException { if ( ! boms . contains ( bom ) ) {
} in . reset () ; } @Override public long skip ( final long n ) throws IOException { int skipped = 0 ; while ( ( n > skipped ) && ( readFirstBytes () >= 0 ) ) { MST[ConditionalsBoundaryMutator]MSP[S] skipped ++ ; }
} in . reset () ; } @Override public long skip ( final long n ) throws IOException { int skipped = 0 ; while ( ( n > skipped ) && ( readFirstBytes () >= 0 ) ) { MST[rv.UOI2Mutator]MSP[N] skipped ++ ; }
fbLength ++ ; if ( firstBytes [ i ] < 0 ) { MST[rv.UOI2Mutator]MSP[N] break; } } byteOrderMark = find () ; if ( byteOrderMark != null ) { if ( ! include ) { if ( byteOrderMark . length () < firstBytes . length ) {
final int maxBomSize = boms . get ( 0 ) . length () ; firstBytes = new int [ maxBomSize ] ; for ( int i = 0 ; i < firstBytes . length ; i ++ ) { firstBytes [ i ] = in . read () ; MST[NonVoidMethodCallMutator]MSP[N]
public synchronized void mark ( final int readlimit ) { markFbIndex = fbIndex ; markedAtStart = firstBytes == null ; in . mark ( readlimit ) ; MST[VoidMethodCallMutator]MSP[N] } @Override public synchronized void reset () throws IOException { fbIndex = markFbIndex ; if ( markedAtStart ) { firstBytes = null ;
public int read ( final byte [] buf , int off , int len ) throws IOException { int firstCount = 0 ; int b = 0 ; while ( len > 0 && b >= 0 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] b = readFirstBytes () ;
final int maxBomSize = boms . get ( 0 ) . length () ; firstBytes = new int [ maxBomSize ] ; for ( int i = 0 ; i < firstBytes . length ; i ++ ) { firstBytes [ i ] = in . read () ; MST[rv.UOI3Mutator]MSP[N]
public synchronized void mark ( final int readlimit ) { markFbIndex = fbIndex ; markedAtStart = firstBytes == null ; in . mark ( readlimit ) ; } @Override public synchronized void reset () throws IOException { fbIndex = markFbIndex ; if ( markedAtStart ) { MST[NegateConditionalsMutator]MSP[N] firstBytes = null ;
final int maxBomSize = boms . get ( 0 ) . length () ; firstBytes = new int [ maxBomSize ] ; for ( int i = 0 ; i < firstBytes . length ; i ++ ) { MST[NegateConditionalsMutator]MSP[N] firstBytes [ i ] = in . read () ;
return secondCount < 0 ? firstCount > 0 ? firstCount : EOF : firstCount + secondCount ; } @Override public int read ( final byte [] buf ) throws IOException { return read ( buf , 0 , buf . length ) ; MST[ReturnValsMutator]MSP[N] } @Override
return secondCount < 0 ? firstCount > 0 ? firstCount : EOF : firstCount + secondCount ; MST[rv.UOI4Mutator]MSP[N] } @Override public int read ( final byte [] buf ) throws IOException { return read ( buf , 0 , buf . length ) ; } @Override
throw new IllegalArgumentException ( lr_1 + bom ) ; } getBOM () ; return byteOrderMark != null && byteOrderMark . equals ( bom ) ; MST[rv.CRCR3Mutator]MSP[N] } public ByteOrderMark getBOM () throws IOException { if ( firstBytes == null ) { fbLength = 0 ;
fbLength ++ ; if ( firstBytes [ i ] < 0 ) { break; } } byteOrderMark = find () ; if ( byteOrderMark != null ) { if ( ! include ) { if ( byteOrderMark . length () < firstBytes . length ) { MST[rv.ROR1Mutator]MSP[S]
fbLength ++ ; if ( firstBytes [ i ] < 0 ) { break; } } byteOrderMark = find () ; if ( byteOrderMark != null ) { if ( ! include ) { if ( byteOrderMark . length () < firstBytes . length ) { MST[rv.ROR5Mutator]MSP[S]
} in . reset () ; } @Override public long skip ( final long n ) throws IOException { int skipped = 0 ; while ( ( n > skipped ) && ( readFirstBytes () >= 0 ) ) { MST[rv.UOI3Mutator]MSP[N] skipped ++ ; }
return secondCount < 0 ? firstCount > 0 ? firstCount : EOF : firstCount + secondCount ; MST[rv.UOI1Mutator]MSP[S] } @Override public int read ( final byte [] buf ) throws IOException { return read ( buf , 0 , buf . length ) ; } @Override
final int maxBomSize = boms . get ( 0 ) . length () ; firstBytes = new int [ maxBomSize ] ; for ( int i = 0 ; i < firstBytes . length ; i ++ ) { MST[rv.CRCR6Mutator]MSP[N] firstBytes [ i ] = in . read () ;
return secondCount < 0 ? firstCount > 0 ? firstCount : EOF : firstCount + secondCount ; MST[MathMutator]MSP[N] } @Override public int read ( final byte [] buf ) throws IOException { return read ( buf , 0 , buf . length ) ; } @Override
} } return true ; } @Override public int read () throws IOException { final int b = readFirstBytes () ; return b >= 0 ? b : in . read () ; MST[rv.UOI1Mutator]MSP[N] } @Override
} } return true ; } @Override public int read () throws IOException { final int b = readFirstBytes () ; return b >= 0 ? b : in . read () ; MST[rv.UOI3Mutator]MSP[N] } @Override
fbLength ++ ; if ( firstBytes [ i ] < 0 ) { break; } } byteOrderMark = find () ; if ( byteOrderMark != null ) { if ( ! include ) { MST[NegateConditionalsMutator]MSP[N] if ( byteOrderMark . length () < firstBytes . length ) {
private int readFirstBytes () throws IOException { getBOM () ; return fbIndex < fbLength ? firstBytes [ fbIndex ++ ] : EOF ; MST[rv.CRCR3Mutator]MSP[N] } private ByteOrderMark find () { for ( final ByteOrderMark bom : boms ) { if ( matches ( bom ) ) { return bom ; }
private int readFirstBytes () throws IOException { getBOM () ; return fbIndex < fbLength ? firstBytes [ fbIndex ++ ] : EOF ; MST[rv.UOI1Mutator]MSP[N] } private ByteOrderMark find () { for ( final ByteOrderMark bom : boms ) { if ( matches ( bom ) ) { return bom ; }
} return null ; } private boolean matches ( final ByteOrderMark bom ) { for ( int i = 0 ; i < bom . length () ; i ++ ) { MST[rv.UOI4Mutator]MSP[N] if ( bom . get ( i ) != firstBytes [ i ] ) { return false ;
} return null ; } private boolean matches ( final ByteOrderMark bom ) { for ( int i = 0 ; i < bom . length () ; i ++ ) { MST[NonVoidMethodCallMutator]MSP[N] if ( bom . get ( i ) != firstBytes [ i ] ) { return false ;
} } return true ; MST[InlineConstantMutator]MSP[N] } @Override public int read () throws IOException { final int b = readFirstBytes () ; return b >= 0 ? b : in . read () ; } @Override
} return null ; } private boolean matches ( final ByteOrderMark bom ) { for ( int i = 0 ; i < bom . length () ; i ++ ) { if ( bom . get ( i ) != firstBytes [ i ] ) { MST[rv.ROR4Mutator]MSP[N] return false ;
} return null ; } private boolean matches ( final ByteOrderMark bom ) { for ( int i = 0 ; i < bom . length () ; i ++ ) { MST[rv.UOI2Mutator]MSP[N] if ( bom . get ( i ) != firstBytes [ i ] ) { return false ;
return secondCount < 0 ? firstCount > 0 ? firstCount : EOF : firstCount + secondCount ; MST[rv.UOI3Mutator]MSP[N] } @Override public int read ( final byte [] buf ) throws IOException { return read ( buf , 0 , buf . length ) ; } @Override
return secondCount < 0 ? firstCount > 0 ? firstCount : EOF : firstCount + secondCount ; MST[rv.AOR2Mutator]MSP[N] } @Override public int read ( final byte [] buf ) throws IOException { return read ( buf , 0 , buf . length ) ; } @Override
return in . skip ( n - skipped ) + skipped ; MST[rv.UOI3Mutator]MSP[S] }
return secondCount < 0 ? firstCount > 0 ? firstCount : EOF : firstCount + secondCount ; MST[rv.CRCR2Mutator]MSP[N] } @Override public int read ( final byte [] buf ) throws IOException { return read ( buf , 0 , buf . length ) ; } @Override
return in . skip ( n - skipped ) + skipped ; MST[rv.UOI4Mutator]MSP[N] }
fbLength ++ ; MST[experimental.MemberVariableMutator]MSP[N] if ( firstBytes [ i ] < 0 ) { break; } } byteOrderMark = find () ; if ( byteOrderMark != null ) { if ( ! include ) { if ( byteOrderMark . length () < firstBytes . length ) {
public synchronized void mark ( final int readlimit ) { markFbIndex = fbIndex ; markedAtStart = firstBytes == null ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] in . mark ( readlimit ) ; } @Override public synchronized void reset () throws IOException { fbIndex = markFbIndex ; if ( markedAtStart ) { firstBytes = null ;
} return null ; } private boolean matches ( final ByteOrderMark bom ) { for ( int i = 0 ; i < bom . length () ; i ++ ) { if ( bom . get ( i ) != firstBytes [ i ] ) { MST[rv.UOI1Mutator]MSP[N] return false ;
return 1 ; } return 0 ; } public boolean hasBOM () throws IOException { return getBOM () != null ; } public boolean hasBOM ( final ByteOrderMark bom ) throws IOException { if ( ! boms . contains ( bom ) ) { MST[rv.ROR4Mutator]MSP[N]
private int readFirstBytes () throws IOException { getBOM () ; return fbIndex < fbLength ? firstBytes [ fbIndex ++ ] : EOF ; MST[rv.ABSMutator]MSP[N] } private ByteOrderMark find () { for ( final ByteOrderMark bom : boms ) { if ( matches ( bom ) ) { return bom ; }
} } return true ; } @Override public int read () throws IOException { final int b = readFirstBytes () ; return b >= 0 ? b : in . read () ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] } @Override
public synchronized void mark ( final int readlimit ) { markFbIndex = fbIndex ; markedAtStart = firstBytes == null ; in . mark ( readlimit ) ; } @Override public synchronized void reset () throws IOException { fbIndex = markFbIndex ; if ( markedAtStart ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] firstBytes = null ;
return 1 ; } return 0 ; } public boolean hasBOM () throws IOException { return getBOM () != null ; MST[rv.CRCR5Mutator]MSP[S] } public boolean hasBOM ( final ByteOrderMark bom ) throws IOException { if ( ! boms . contains ( bom ) ) {
} return null ; } private boolean matches ( final ByteOrderMark bom ) { for ( int i = 0 ; i < bom . length () ; i ++ ) { MST[rv.CRCR3Mutator]MSP[N] if ( bom . get ( i ) != firstBytes [ i ] ) { return false ;
private int readFirstBytes () throws IOException { getBOM () ; return fbIndex < fbLength ? firstBytes [ fbIndex ++ ] : EOF ; } private ByteOrderMark find () { for ( final ByteOrderMark bom : boms ) { if ( matches ( bom ) ) { MST[NonVoidMethodCallMutator]MSP[N] return bom ; }
return 1 ; } return 0 ; } public boolean hasBOM () throws IOException { return getBOM () != null ; MST[rv.CRCR3Mutator]MSP[S] } public boolean hasBOM ( final ByteOrderMark bom ) throws IOException { if ( ! boms . contains ( bom ) ) {
throw new IllegalArgumentException ( lr_1 + bom ) ; } getBOM () ; return byteOrderMark != null && byteOrderMark . equals ( bom ) ; } public ByteOrderMark getBOM () throws IOException { if ( firstBytes == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] fbLength = 0 ;
return secondCount < 0 ? firstCount > 0 ? firstCount : EOF : firstCount + secondCount ; MST[InlineConstantMutator]MSP[N] } @Override public int read ( final byte [] buf ) throws IOException { return read ( buf , 0 , buf . length ) ; } @Override
final int maxBomSize = boms . get ( 0 ) . length () ; MST[rv.CRCR5Mutator]MSP[N] firstBytes = new int [ maxBomSize ] ; for ( int i = 0 ; i < firstBytes . length ; i ++ ) { firstBytes [ i ] = in . read () ;
public synchronized void mark ( final int readlimit ) { markFbIndex = fbIndex ; markedAtStart = firstBytes == null ; in . mark ( readlimit ) ; MST[rv.UOI3Mutator]MSP[N] } @Override public synchronized void reset () throws IOException { fbIndex = markFbIndex ; if ( markedAtStart ) { firstBytes = null ;
if ( b >= 0 ) { buf [ off ++ ] = (byte) ( b & 0xFF ) ; len -- ; firstCount ++ ; MST[experimental.RemoveIncrementsMutator]MSP[N] } } final int secondCount = in . read ( buf , off , len ) ;
if ( b >= 0 ) { buf [ off ++ ] = (byte) ( b & 0xFF ) ; len -- ; firstCount ++ ; MST[IncrementsMutator]MSP[N] } } final int secondCount = in . read ( buf , off , len ) ;
return 1 ; } return 0 ; } public boolean hasBOM () throws IOException { return getBOM () != null ; MST[ReturnValsMutator]MSP[N] } public boolean hasBOM ( final ByteOrderMark bom ) throws IOException { if ( ! boms . contains ( bom ) ) {
return secondCount < 0 ? firstCount > 0 ? firstCount : EOF : firstCount + secondCount ; MST[rv.ROR2Mutator]MSP[N] } @Override public int read ( final byte [] buf ) throws IOException { return read ( buf , 0 , buf . length ) ; } @Override
public int read ( final byte [] buf , int off , int len ) throws IOException { int firstCount = 0 ; int b = 0 ; while ( len > 0 && b >= 0 ) { MST[rv.UOI2Mutator]MSP[S] b = readFirstBytes () ;
return 1 ; } return 0 ; } public boolean hasBOM () throws IOException { return getBOM () != null ; MST[NegateConditionalsMutator]MSP[N] } public boolean hasBOM ( final ByteOrderMark bom ) throws IOException { if ( ! boms . contains ( bom ) ) {
public synchronized void mark ( final int readlimit ) { markFbIndex = fbIndex ; markedAtStart = firstBytes == null ; in . mark ( readlimit ) ; } @Override public synchronized void reset () throws IOException { fbIndex = markFbIndex ; if ( markedAtStart ) { MST[rv.ROR5Mutator]MSP[N] firstBytes = null ;
public int read ( final byte [] buf , int off , int len ) throws IOException { int firstCount = 0 ; int b = 0 ; while ( len > 0 && b >= 0 ) { MST[NegateConditionalsMutator]MSP[N] b = readFirstBytes () ;
return in . skip ( n - skipped ) + skipped ; MST[rv.UOI3Mutator]MSP[N] }
public int read ( final byte [] buf , int off , int len ) throws IOException { int firstCount = 0 ; int b = 0 ; while ( len > 0 && b >= 0 ) { MST[rv.ROR3Mutator]MSP[N] b = readFirstBytes () ;
} in . reset () ; } @Override public long skip ( final long n ) throws IOException { int skipped = 0 ; while ( ( n > skipped ) && ( readFirstBytes () >= 0 ) ) { MST[rv.ROR3Mutator]MSP[N] skipped ++ ; }
public int read ( final byte [] buf , int off , int len ) throws IOException { int firstCount = 0 ; int b = 0 ; MST[rv.CRCR5Mutator]MSP[S] while ( len > 0 && b >= 0 ) { b = readFirstBytes () ;
fbLength ++ ; if ( firstBytes [ i ] < 0 ) { MST[rv.ROR1Mutator]MSP[N] break; } } byteOrderMark = find () ; if ( byteOrderMark != null ) { if ( ! include ) { if ( byteOrderMark . length () < firstBytes . length ) {
fbLength ++ ; if ( firstBytes [ i ] < 0 ) { MST[rv.ROR5Mutator]MSP[N] break; } } byteOrderMark = find () ; if ( byteOrderMark != null ) { if ( ! include ) { if ( byteOrderMark . length () < firstBytes . length ) {
if ( b >= 0 ) { buf [ off ++ ] = (byte) ( b & 0xFF ) ; MST[rv.UOI2Mutator]MSP[N] len -- ; firstCount ++ ; } } final int secondCount = in . read ( buf , off , len ) ;
} return null ; } private boolean matches ( final ByteOrderMark bom ) { for ( int i = 0 ; i < bom . length () ; i ++ ) { MST[rv.ABSMutator]MSP[N] if ( bom . get ( i ) != firstBytes [ i ] ) { return false ;
private int readFirstBytes () throws IOException { getBOM () ; return fbIndex < fbLength ? firstBytes [ fbIndex ++ ] : EOF ; MST[rv.UOI4Mutator]MSP[N] } private ByteOrderMark find () { for ( final ByteOrderMark bom : boms ) { if ( matches ( bom ) ) { return bom ; }
} return null ; } private boolean matches ( final ByteOrderMark bom ) { for ( int i = 0 ; i < bom . length () ; i ++ ) { MST[ConditionalsBoundaryMutator]MSP[N] if ( bom . get ( i ) != firstBytes [ i ] ) { return false ;
fbIndex = byteOrderMark . length () ; } else { fbLength = 0 ; } } } } return byteOrderMark ; MST[ReturnValsMutator]MSP[N] } public String getBOMCharsetName () throws IOException { getBOM () ; return byteOrderMark == null ? null : byteOrderMark . getCharsetName () ; }
throw new IllegalArgumentException ( lr_1 + bom ) ; MST[experimental.NakedReceiverMutator]MSP[N] } getBOM () ; return byteOrderMark != null && byteOrderMark . equals ( bom ) ; } public ByteOrderMark getBOM () throws IOException { if ( firstBytes == null ) { fbLength = 0 ;
private int readFirstBytes () throws IOException { getBOM () ; return fbIndex < fbLength ? firstBytes [ fbIndex ++ ] : EOF ; MST[MathMutator]MSP[N] } private ByteOrderMark find () { for ( final ByteOrderMark bom : boms ) { if ( matches ( bom ) ) { return bom ; }
return secondCount < 0 ? firstCount > 0 ? firstCount : EOF : firstCount + secondCount ; } @Override public int read ( final byte [] buf ) throws IOException { return read ( buf , 0 , buf . length ) ; MST[InlineConstantMutator]MSP[S] } @Override
throw new IllegalArgumentException ( lr_1 + bom ) ; } getBOM () ; return byteOrderMark != null && byteOrderMark . equals ( bom ) ; MST[InlineConstantMutator]MSP[N] } public ByteOrderMark getBOM () throws IOException { if ( firstBytes == null ) { fbLength = 0 ;
public int read ( final byte [] buf , int off , int len ) throws IOException { int firstCount = 0 ; int b = 0 ; MST[rv.CRCR1Mutator]MSP[S] while ( len > 0 && b >= 0 ) { b = readFirstBytes () ;
return 1 ; } return 0 ; } public boolean hasBOM () throws IOException { return getBOM () != null ; MST[rv.CRCR2Mutator]MSP[N] } public boolean hasBOM ( final ByteOrderMark bom ) throws IOException { if ( ! boms . contains ( bom ) ) {
if ( b >= 0 ) { buf [ off ++ ] = (byte) ( b & 0xFF ) ; len -- ; firstCount ++ ; } } final int secondCount = in . read ( buf , off , len ) ; MST[rv.UOI3Mutator]MSP[N]
public synchronized void mark ( final int readlimit ) { markFbIndex = fbIndex ; markedAtStart = firstBytes == null ; MST[experimental.MemberVariableMutator]MSP[S] in . mark ( readlimit ) ; } @Override public synchronized void reset () throws IOException { fbIndex = markFbIndex ; if ( markedAtStart ) { firstBytes = null ;
fbLength ++ ; MST[rv.UOI1Mutator]MSP[S] if ( firstBytes [ i ] < 0 ) { break; } } byteOrderMark = find () ; if ( byteOrderMark != null ) { if ( ! include ) { if ( byteOrderMark . length () < firstBytes . length ) {
if ( b >= 0 ) { buf [ off ++ ] = (byte) ( b & 0xFF ) ; MST[rv.CRCR3Mutator]MSP[S] len -- ; firstCount ++ ; } } final int secondCount = in . read ( buf , off , len ) ;
return in . skip ( n - skipped ) + skipped ; MST[rv.AOD2Mutator]MSP[N] }
private int readFirstBytes () throws IOException { getBOM () ; return fbIndex < fbLength ? firstBytes [ fbIndex ++ ] : EOF ; } private ByteOrderMark find () { for ( final ByteOrderMark bom : boms ) { if ( matches ( bom ) ) { MST[rv.ROR5Mutator]MSP[N] return bom ; }
return in . skip ( n - skipped ) + skipped ; MST[rv.AOD1Mutator]MSP[N] }
} } return true ; } @Override public int read () throws IOException { final int b = readFirstBytes () ; return b >= 0 ? b : in . read () ; MST[RemoveConditionalMutator_ORDER_IF]MSP[N] } @Override
private int readFirstBytes () throws IOException { getBOM () ; return fbIndex < fbLength ? firstBytes [ fbIndex ++ ] : EOF ; } private ByteOrderMark find () { for ( final ByteOrderMark bom : boms ) { if ( matches ( bom ) ) { MST[rv.ROR4Mutator]MSP[N] return bom ; }
return secondCount < 0 ? firstCount > 0 ? firstCount : EOF : firstCount + secondCount ; MST[rv.UOI4Mutator]MSP[N] } @Override public int read ( final byte [] buf ) throws IOException { return read ( buf , 0 , buf . length ) ; } @Override
} } return true ; } @Override public int read () throws IOException { final int b = readFirstBytes () ; return b >= 0 ? b : in . read () ; MST[rv.UOI3Mutator]MSP[N] } @Override
} } return true ; } @Override public int read () throws IOException { final int b = readFirstBytes () ; return b >= 0 ? b : in . read () ; MST[NegateConditionalsMutator]MSP[N] } @Override
} } return true ; MST[rv.CRCR2Mutator]MSP[N] } @Override public int read () throws IOException { final int b = readFirstBytes () ; return b >= 0 ? b : in . read () ; } @Override
final int maxBomSize = boms . get ( 0 ) . length () ; firstBytes = new int [ maxBomSize ] ; MST[rv.UOI2Mutator]MSP[S] for ( int i = 0 ; i < firstBytes . length ; i ++ ) { firstBytes [ i ] = in . read () ;
public synchronized void mark ( final int readlimit ) { markFbIndex = fbIndex ; markedAtStart = firstBytes == null ; MST[rv.CRCR6Mutator]MSP[S] in . mark ( readlimit ) ; } @Override public synchronized void reset () throws IOException { fbIndex = markFbIndex ; if ( markedAtStart ) { firstBytes = null ;
private int readFirstBytes () throws IOException { getBOM () ; return fbIndex < fbLength ? firstBytes [ fbIndex ++ ] : EOF ; MST[rv.UOI4Mutator]MSP[N] } private ByteOrderMark find () { for ( final ByteOrderMark bom : boms ) { if ( matches ( bom ) ) { return bom ; }
throw new IllegalArgumentException ( lr_1 + bom ) ; } getBOM () ; return byteOrderMark != null && byteOrderMark . equals ( bom ) ; MST[rv.ROR3Mutator]MSP[N] } public ByteOrderMark getBOM () throws IOException { if ( firstBytes == null ) { fbLength = 0 ;
fbLength ++ ; MST[rv.CRCR2Mutator]MSP[N] if ( firstBytes [ i ] < 0 ) { break; } } byteOrderMark = find () ; if ( byteOrderMark != null ) { if ( ! include ) { if ( byteOrderMark . length () < firstBytes . length ) {
} return null ; } private boolean matches ( final ByteOrderMark bom ) { for ( int i = 0 ; i < bom . length () ; i ++ ) { MST[rv.ROR1Mutator]MSP[N] if ( bom . get ( i ) != firstBytes [ i ] ) { return false ;
throw new IllegalArgumentException ( lr_1 + bom ) ; } getBOM () ; MST[NonVoidMethodCallMutator]MSP[S] return byteOrderMark != null && byteOrderMark . equals ( bom ) ; } public ByteOrderMark getBOM () throws IOException { if ( firstBytes == null ) { fbLength = 0 ;
fbIndex = byteOrderMark . length () ; } else { fbLength = 0 ; } } } } return byteOrderMark ; MST[NullReturnValsMutator]MSP[N] } public String getBOMCharsetName () throws IOException { getBOM () ; return byteOrderMark == null ? null : byteOrderMark . getCharsetName () ; }
} in . reset () ; } @Override public long skip ( final long n ) throws IOException { int skipped = 0 ; while ( ( n > skipped ) && ( readFirstBytes () >= 0 ) ) { MST[rv.ROR2Mutator]MSP[N] skipped ++ ; }
} in . reset () ; } @Override public long skip ( final long n ) throws IOException { int skipped = 0 ; while ( ( n > skipped ) && ( readFirstBytes () >= 0 ) ) { MST[rv.ROR1Mutator]MSP[S] skipped ++ ; }
public int read ( final byte [] buf , int off , int len ) throws IOException { int firstCount = 0 ; int b = 0 ; MST[rv.CRCR6Mutator]MSP[N] while ( len > 0 && b >= 0 ) { b = readFirstBytes () ;
throw new IllegalArgumentException ( lr_1 + bom ) ; MST[ConstructorCallMutator]MSP[S] } getBOM () ; return byteOrderMark != null && byteOrderMark . equals ( bom ) ; } public ByteOrderMark getBOM () throws IOException { if ( firstBytes == null ) { fbLength = 0 ;
throw new IllegalArgumentException ( lr_1 + bom ) ; } getBOM () ; return byteOrderMark != null && byteOrderMark . equals ( bom ) ; } public ByteOrderMark getBOM () throws IOException { if ( firstBytes == null ) { MST[NegateConditionalsMutator]MSP[N] fbLength = 0 ;
fbLength ++ ; if ( firstBytes [ i ] < 0 ) { MST[rv.ABSMutator]MSP[N] break; } } byteOrderMark = find () ; if ( byteOrderMark != null ) { if ( ! include ) { if ( byteOrderMark . length () < firstBytes . length ) {
} in . reset () ; } @Override public long skip ( final long n ) throws IOException { int skipped = 0 ; MST[rv.CRCR3Mutator]MSP[N] while ( ( n > skipped ) && ( readFirstBytes () >= 0 ) ) { skipped ++ ; }
public int read ( final byte [] buf , int off , int len ) throws IOException { int firstCount = 0 ; int b = 0 ; while ( len > 0 && b >= 0 ) { MST[rv.ROR4Mutator]MSP[N] b = readFirstBytes () ;
private int readFirstBytes () throws IOException { getBOM () ; return fbIndex < fbLength ? firstBytes [ fbIndex ++ ] : EOF ; MST[rv.UOI2Mutator]MSP[S] } private ByteOrderMark find () { for ( final ByteOrderMark bom : boms ) { if ( matches ( bom ) ) { return bom ; }
if ( b >= 0 ) { buf [ off ++ ] = (byte) ( b & 0xFF ) ; MST[rv.UOI1Mutator]MSP[N] len -- ; firstCount ++ ; } } final int secondCount = in . read ( buf , off , len ) ;
private int readFirstBytes () throws IOException { getBOM () ; return fbIndex < fbLength ? firstBytes [ fbIndex ++ ] : EOF ; MST[rv.UOI3Mutator]MSP[N] } private ByteOrderMark find () { for ( final ByteOrderMark bom : boms ) { if ( matches ( bom ) ) { return bom ; }
} } return true ; } @Override public int read () throws IOException { final int b = readFirstBytes () ; return b >= 0 ? b : in . read () ; MST[rv.UOI2Mutator]MSP[S] } @Override
if ( b >= 0 ) { MST[rv.UOI4Mutator]MSP[N] buf [ off ++ ] = (byte) ( b & 0xFF ) ; len -- ; firstCount ++ ; } } final int secondCount = in . read ( buf , off , len ) ;
throw new IllegalArgumentException ( lr_1 + bom ) ; } getBOM () ; return byteOrderMark != null && byteOrderMark . equals ( bom ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] } public ByteOrderMark getBOM () throws IOException { if ( firstBytes == null ) { fbLength = 0 ;
if ( b >= 0 ) { MST[rv.ROR1Mutator]MSP[N] buf [ off ++ ] = (byte) ( b & 0xFF ) ; len -- ; firstCount ++ ; } } final int secondCount = in . read ( buf , off , len ) ;
return 1 ; } return 0 ; } public boolean hasBOM () throws IOException { return getBOM () != null ; } public boolean hasBOM ( final ByteOrderMark bom ) throws IOException { if ( ! boms . contains ( bom ) ) { MST[NegateConditionalsMutator]MSP[N]
fbLength ++ ; if ( firstBytes [ i ] < 0 ) { MST[ConditionalsBoundaryMutator]MSP[N] break; } } byteOrderMark = find () ; if ( byteOrderMark != null ) { if ( ! include ) { if ( byteOrderMark . length () < firstBytes . length ) {
} return null ; } private boolean matches ( final ByteOrderMark bom ) { for ( int i = 0 ; i < bom . length () ; i ++ ) { MST[InlineConstantMutator]MSP[S] if ( bom . get ( i ) != firstBytes [ i ] ) { return false ;
public synchronized void mark ( final int readlimit ) { markFbIndex = fbIndex ; markedAtStart = firstBytes == null ; in . mark ( readlimit ) ; MST[rv.ABSMutator]MSP[N] } @Override public synchronized void reset () throws IOException { fbIndex = markFbIndex ; if ( markedAtStart ) { firstBytes = null ;
fbLength ++ ; if ( firstBytes [ i ] < 0 ) { MST[rv.UOI3Mutator]MSP[N] break; } } byteOrderMark = find () ; if ( byteOrderMark != null ) { if ( ! include ) { if ( byteOrderMark . length () < firstBytes . length ) {
final int maxBomSize = boms . get ( 0 ) . length () ; MST[rv.CRCR1Mutator]MSP[N] firstBytes = new int [ maxBomSize ] ; for ( int i = 0 ; i < firstBytes . length ; i ++ ) { firstBytes [ i ] = in . read () ;
return 1 ; } return 0 ; } public boolean hasBOM () throws IOException { return getBOM () != null ; MST[InlineConstantMutator]MSP[N] } public boolean hasBOM ( final ByteOrderMark bom ) throws IOException { if ( ! boms . contains ( bom ) ) {
} in . reset () ; } @Override public long skip ( final long n ) throws IOException { int skipped = 0 ; MST[InlineConstantMutator]MSP[N] while ( ( n > skipped ) && ( readFirstBytes () >= 0 ) ) { skipped ++ ; }
public synchronized void mark ( final int readlimit ) { markFbIndex = fbIndex ; MST[experimental.MemberVariableMutator]MSP[S] markedAtStart = firstBytes == null ; in . mark ( readlimit ) ; } @Override public synchronized void reset () throws IOException { fbIndex = markFbIndex ; if ( markedAtStart ) { firstBytes = null ;
return 1 ; } return 0 ; } public boolean hasBOM () throws IOException { return getBOM () != null ; MST[BooleanTrueReturnValsMutator]MSP[S] } public boolean hasBOM ( final ByteOrderMark bom ) throws IOException { if ( ! boms . contains ( bom ) ) {
if ( b >= 0 ) { buf [ off ++ ] = (byte) ( b & 0xFF ) ; len -- ; firstCount ++ ; } } final int secondCount = in . read ( buf , off , len ) ; MST[rv.UOI2Mutator]MSP[S]
final int maxBomSize = boms . get ( 0 ) . length () ; firstBytes = new int [ maxBomSize ] ; for ( int i = 0 ; i < firstBytes . length ; i ++ ) { MST[rv.ROR3Mutator]MSP[N] firstBytes [ i ] = in . read () ;
return secondCount < 0 ? firstCount > 0 ? firstCount : EOF : firstCount + secondCount ; MST[rv.ABSMutator]MSP[N] } @Override public int read ( final byte [] buf ) throws IOException { return read ( buf , 0 , buf . length ) ; } @Override
} in . reset () ; } @Override public long skip ( final long n ) throws IOException { int skipped = 0 ; while ( ( n > skipped ) && ( readFirstBytes () >= 0 ) ) { MST[rv.UOI3Mutator]MSP[N] skipped ++ ; }
return secondCount < 0 ? firstCount > 0 ? firstCount : EOF : firstCount + secondCount ; MST[rv.ROR1Mutator]MSP[N] } @Override public int read ( final byte [] buf ) throws IOException { return read ( buf , 0 , buf . length ) ; } @Override
public synchronized void mark ( final int readlimit ) { markFbIndex = fbIndex ; MST[rv.UOI2Mutator]MSP[N] markedAtStart = firstBytes == null ; in . mark ( readlimit ) ; } @Override public synchronized void reset () throws IOException { fbIndex = markFbIndex ; if ( markedAtStart ) { firstBytes = null ;
fbLength ++ ; if ( firstBytes [ i ] < 0 ) { break; } } byteOrderMark = find () ; if ( byteOrderMark != null ) { if ( ! include ) { MST[rv.ROR3Mutator]MSP[N] if ( byteOrderMark . length () < firstBytes . length ) {
return in . skip ( n - skipped ) + skipped ; MST[rv.AOR4Mutator]MSP[N] }
return in . skip ( n - skipped ) + skipped ; MST[rv.ABSMutator]MSP[N] }
public int read ( final byte [] buf , int off , int len ) throws IOException { int firstCount = 0 ; int b = 0 ; while ( len > 0 && b >= 0 ) { MST[rv.UOI1Mutator]MSP[N] b = readFirstBytes () ;
return secondCount < 0 ? firstCount > 0 ? firstCount : EOF : firstCount + secondCount ; MST[rv.UOI3Mutator]MSP[N] } @Override public int read ( final byte [] buf ) throws IOException { return read ( buf , 0 , buf . length ) ; } @Override
private int readFirstBytes () throws IOException { getBOM () ; return fbIndex < fbLength ? firstBytes [ fbIndex ++ ] : EOF ; MST[rv.CRCR6Mutator]MSP[S] } private ByteOrderMark find () { for ( final ByteOrderMark bom : boms ) { if ( matches ( bom ) ) { return bom ; }
} return null ; } private boolean matches ( final ByteOrderMark bom ) { for ( int i = 0 ; i < bom . length () ; i ++ ) { if ( bom . get ( i ) != firstBytes [ i ] ) { MST[NegateConditionalsMutator]MSP[N] return false ;
return in . skip ( n - skipped ) + skipped ; MST[rv.UOI4Mutator]MSP[N] }
public int read ( final byte [] buf , int off , int len ) throws IOException { int firstCount = 0 ; int b = 0 ; while ( len > 0 && b >= 0 ) { MST[NegateConditionalsMutator]MSP[N] b = readFirstBytes () ;
public int read ( final byte [] buf , int off , int len ) throws IOException { int firstCount = 0 ; int b = 0 ; while ( len > 0 && b >= 0 ) { MST[rv.ROR3Mutator]MSP[N] b = readFirstBytes () ;
} return null ; } private boolean matches ( final ByteOrderMark bom ) { for ( int i = 0 ; i < bom . length () ; i ++ ) { if ( bom . get ( i ) != firstBytes [ i ] ) { MST[rv.UOI1Mutator]MSP[S] return false ;
if ( b >= 0 ) { buf [ off ++ ] = (byte) ( b & 0xFF ) ; MST[InlineConstantMutator]MSP[N] len -- ; firstCount ++ ; } } final int secondCount = in . read ( buf , off , len ) ;
private int readFirstBytes () throws IOException { getBOM () ; return fbIndex < fbLength ? firstBytes [ fbIndex ++ ] : EOF ; MST[rv.ROR2Mutator]MSP[N] } private ByteOrderMark find () { for ( final ByteOrderMark bom : boms ) { if ( matches ( bom ) ) { return bom ; }
} in . reset () ; } @Override public long skip ( final long n ) throws IOException { int skipped = 0 ; while ( ( n > skipped ) && ( readFirstBytes () >= 0 ) ) { MST[rv.ABSMutator]MSP[S] skipped ++ ; }
} } return true ; } @Override public int read () throws IOException { final int b = readFirstBytes () ; return b >= 0 ? b : in . read () ; MST[rv.ROR4Mutator]MSP[N] } @Override
if ( b >= 0 ) { buf [ off ++ ] = (byte) ( b & 0xFF ) ; MST[MathMutator]MSP[N] len -- ; firstCount ++ ; } } final int secondCount = in . read ( buf , off , len ) ;
fbLength ++ ; if ( firstBytes [ i ] < 0 ) { break; } } byteOrderMark = find () ; if ( byteOrderMark != null ) { if ( ! include ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] if ( byteOrderMark . length () < firstBytes . length ) {
return 1 ; } return 0 ; } public boolean hasBOM () throws IOException { return getBOM () != null ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] } public boolean hasBOM ( final ByteOrderMark bom ) throws IOException { if ( ! boms . contains ( bom ) ) {
fbLength ++ ; if ( firstBytes [ i ] < 0 ) { MST[rv.UOI3Mutator]MSP[N] break; } } byteOrderMark = find () ; if ( byteOrderMark != null ) { if ( ! include ) { if ( byteOrderMark . length () < firstBytes . length ) {
if ( b >= 0 ) { buf [ off ++ ] = (byte) ( b & 0xFF ) ; len -- ; firstCount ++ ; } } final int secondCount = in . read ( buf , off , len ) ; MST[rv.UOI2Mutator]MSP[S]
final int maxBomSize = boms . get ( 0 ) . length () ; MST[rv.CRCR6Mutator]MSP[N] firstBytes = new int [ maxBomSize ] ; for ( int i = 0 ; i < firstBytes . length ; i ++ ) { firstBytes [ i ] = in . read () ;
return 1 ; MST[PrimitiveReturnsMutator]MSP[S] } return 0 ; } public boolean hasBOM () throws IOException { return getBOM () != null ; } public boolean hasBOM ( final ByteOrderMark bom ) throws IOException { if ( ! boms . contains ( bom ) ) {
return 1 ; } return 0 ; MST[ReturnValsMutator]MSP[S] } public boolean hasBOM () throws IOException { return getBOM () != null ; } public boolean hasBOM ( final ByteOrderMark bom ) throws IOException { if ( ! boms . contains ( bom ) ) {
return 1 ; } return 0 ; MST[rv.CRCR1Mutator]MSP[S] } public boolean hasBOM () throws IOException { return getBOM () != null ; } public boolean hasBOM ( final ByteOrderMark bom ) throws IOException { if ( ! boms . contains ( bom ) ) {
@Override public int compare ( final ByteOrderMark bom1 , final ByteOrderMark bom2 ) { final int len1 = bom1 . length () ; final int len2 = bom2 . length () ; if ( len1 > len2 ) { MST[ConditionalsBoundaryMutator]MSP[S] return EOF ; } if ( len2 > len1 ) {
@Override public int compare ( final ByteOrderMark bom1 , final ByteOrderMark bom2 ) { final int len1 = bom1 . length () ; final int len2 = bom2 . length () ; if ( len1 > len2 ) { return EOF ; MST[InlineConstantMutator]MSP[S] } if ( len2 > len1 ) {
@Override public int compare ( final ByteOrderMark bom1 , final ByteOrderMark bom2 ) { final int len1 = bom1 . length () ; final int len2 = bom2 . length () ; if ( len1 > len2 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] return EOF ; } if ( len2 > len1 ) {
@Override public int compare ( final ByteOrderMark bom1 , final ByteOrderMark bom2 ) { final int len1 = bom1 . length () ; final int len2 = bom2 . length () ; if ( len1 > len2 ) { return EOF ; } if ( len2 > len1 ) { MST[rv.ABSMutator]MSP[S]
@Override public int compare ( final ByteOrderMark bom1 , final ByteOrderMark bom2 ) { final int len1 = bom1 . length () ; final int len2 = bom2 . length () ; if ( len1 > len2 ) { return EOF ; } if ( len2 > len1 ) { MST[rv.ROR5Mutator]MSP[S]
@Override public int compare ( final ByteOrderMark bom1 , final ByteOrderMark bom2 ) { final int len1 = bom1 . length () ; final int len2 = bom2 . length () ; if ( len1 > len2 ) { return EOF ; } if ( len2 > len1 ) { MST[rv.ROR3Mutator]MSP[S]
@Override public int compare ( final ByteOrderMark bom1 , final ByteOrderMark bom2 ) { final int len1 = bom1 . length () ; final int len2 = bom2 . length () ; if ( len1 > len2 ) { return EOF ; } if ( len2 > len1 ) { MST[rv.UOI1Mutator]MSP[S]
@Override public int compare ( final ByteOrderMark bom1 , final ByteOrderMark bom2 ) { final int len1 = bom1 . length () ; final int len2 = bom2 . length () ; if ( len1 > len2 ) { return EOF ; MST[rv.CRCR5Mutator]MSP[S] } if ( len2 > len1 ) {
@Override public int compare ( final ByteOrderMark bom1 , final ByteOrderMark bom2 ) { final int len1 = bom1 . length () ; final int len2 = bom2 . length () ; if ( len1 > len2 ) { return EOF ; } if ( len2 > len1 ) { MST[rv.UOI2Mutator]MSP[S]
@Override public int compare ( final ByteOrderMark bom1 , final ByteOrderMark bom2 ) { final int len1 = bom1 . length () ; final int len2 = bom2 . length () ; if ( len1 > len2 ) { return EOF ; } if ( len2 > len1 ) { MST[rv.ROR1Mutator]MSP[S]
return 1 ; MST[InlineConstantMutator]MSP[S] } return 0 ; } public boolean hasBOM () throws IOException { return getBOM () != null ; } public boolean hasBOM ( final ByteOrderMark bom ) throws IOException { if ( ! boms . contains ( bom ) ) {
return 1 ; MST[rv.CRCR5Mutator]MSP[S] } return 0 ; } public boolean hasBOM () throws IOException { return getBOM () != null ; } public boolean hasBOM ( final ByteOrderMark bom ) throws IOException { if ( ! boms . contains ( bom ) ) {
@Override public int compare ( final ByteOrderMark bom1 , final ByteOrderMark bom2 ) { final int len1 = bom1 . length () ; final int len2 = bom2 . length () ; if ( len1 > len2 ) { return EOF ; } if ( len2 > len1 ) { MST[rv.UOI4Mutator]MSP[S]
return 1 ; MST[rv.CRCR3Mutator]MSP[S] } return 0 ; } public boolean hasBOM () throws IOException { return getBOM () != null ; } public boolean hasBOM ( final ByteOrderMark bom ) throws IOException { if ( ! boms . contains ( bom ) ) {
@Override public int compare ( final ByteOrderMark bom1 , final ByteOrderMark bom2 ) { final int len1 = bom1 . length () ; final int len2 = bom2 . length () ; if ( len1 > len2 ) { return EOF ; } if ( len2 > len1 ) { MST[rv.UOI3Mutator]MSP[S]
return 1 ; } return 0 ; MST[rv.CRCR6Mutator]MSP[S] } public boolean hasBOM () throws IOException { return getBOM () != null ; } public boolean hasBOM ( final ByteOrderMark bom ) throws IOException { if ( ! boms . contains ( bom ) ) {
@Override public int compare ( final ByteOrderMark bom1 , final ByteOrderMark bom2 ) { final int len1 = bom1 . length () ; final int len2 = bom2 . length () ; if ( len1 > len2 ) { MST[rv.UOI4Mutator]MSP[S] return EOF ; } if ( len2 > len1 ) {
@Override public int compare ( final ByteOrderMark bom1 , final ByteOrderMark bom2 ) { final int len1 = bom1 . length () ; final int len2 = bom2 . length () ; if ( len1 > len2 ) { MST[rv.ROR3Mutator]MSP[N] return EOF ; } if ( len2 > len1 ) {
@Override public int compare ( final ByteOrderMark bom1 , final ByteOrderMark bom2 ) { final int len1 = bom1 . length () ; final int len2 = bom2 . length () ; MST[NonVoidMethodCallMutator]MSP[S] if ( len1 > len2 ) { return EOF ; } if ( len2 > len1 ) {
@Override public int compare ( final ByteOrderMark bom1 , final ByteOrderMark bom2 ) { final int len1 = bom1 . length () ; final int len2 = bom2 . length () ; if ( len1 > len2 ) { MST[rv.ABSMutator]MSP[N] return EOF ; } if ( len2 > len1 ) {
@Override public int compare ( final ByteOrderMark bom1 , final ByteOrderMark bom2 ) { final int len1 = bom1 . length () ; final int len2 = bom2 . length () ; if ( len1 > len2 ) { MST[rv.ROR1Mutator]MSP[S] return EOF ; } if ( len2 > len1 ) {
@Override public int compare ( final ByteOrderMark bom1 , final ByteOrderMark bom2 ) { final int len1 = bom1 . length () ; final int len2 = bom2 . length () ; if ( len1 > len2 ) { MST[rv.ROR5Mutator]MSP[N] return EOF ; } if ( len2 > len1 ) {
@Override public int compare ( final ByteOrderMark bom1 , final ByteOrderMark bom2 ) { final int len1 = bom1 . length () ; final int len2 = bom2 . length () ; if ( len1 > len2 ) { MST[rv.UOI1Mutator]MSP[S] return EOF ; } if ( len2 > len1 ) {
@Override public int compare ( final ByteOrderMark bom1 , final ByteOrderMark bom2 ) { final int len1 = bom1 . length () ; final int len2 = bom2 . length () ; if ( len1 > len2 ) { MST[rv.UOI3Mutator]MSP[S] return EOF ; } if ( len2 > len1 ) {
@Override public int compare ( final ByteOrderMark bom1 , final ByteOrderMark bom2 ) { final int len1 = bom1 . length () ; final int len2 = bom2 . length () ; if ( len1 > len2 ) { MST[rv.UOI2Mutator]MSP[S] return EOF ; } if ( len2 > len1 ) {
@Override public int compare ( final ByteOrderMark bom1 , final ByteOrderMark bom2 ) { final int len1 = bom1 . length () ; final int len2 = bom2 . length () ; if ( len1 > len2 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[S] return EOF ; } if ( len2 > len1 ) {
return 1 ; MST[rv.CRCR2Mutator]MSP[S] } return 0 ; } public boolean hasBOM () throws IOException { return getBOM () != null ; } public boolean hasBOM ( final ByteOrderMark bom ) throws IOException { if ( ! boms . contains ( bom ) ) {
@Override public int compare ( final ByteOrderMark bom1 , final ByteOrderMark bom2 ) { final int len1 = bom1 . length () ; final int len2 = bom2 . length () ; if ( len1 > len2 ) { return EOF ; MST[rv.CRCR1Mutator]MSP[S] } if ( len2 > len1 ) {
@Override public int compare ( final ByteOrderMark bom1 , final ByteOrderMark bom2 ) { final int len1 = bom1 . length () ; final int len2 = bom2 . length () ; if ( len1 > len2 ) { return EOF ; MST[rv.CRCR2Mutator]MSP[S] } if ( len2 > len1 ) {
@Override public int compare ( final ByteOrderMark bom1 , final ByteOrderMark bom2 ) { final int len1 = bom1 . length () ; final int len2 = bom2 . length () ; if ( len1 > len2 ) { return EOF ; } if ( len2 > len1 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[S]
@Override public int compare ( final ByteOrderMark bom1 , final ByteOrderMark bom2 ) { final int len1 = bom1 . length () ; final int len2 = bom2 . length () ; if ( len1 > len2 ) { return EOF ; } if ( len2 > len1 ) { MST[rv.ABSMutator]MSP[S]
@Override public int compare ( final ByteOrderMark bom1 , final ByteOrderMark bom2 ) { final int len1 = bom1 . length () ; final int len2 = bom2 . length () ; if ( len1 > len2 ) { return EOF ; } if ( len2 > len1 ) { MST[rv.ROR4Mutator]MSP[S]
@Override public int compare ( final ByteOrderMark bom1 , final ByteOrderMark bom2 ) { final int len1 = bom1 . length () ; final int len2 = bom2 . length () ; if ( len1 > len2 ) { return EOF ; MST[rv.CRCR6Mutator]MSP[N] } if ( len2 > len1 ) {
@Override public int compare ( final ByteOrderMark bom1 , final ByteOrderMark bom2 ) { final int len1 = bom1 . length () ; final int len2 = bom2 . length () ; if ( len1 > len2 ) { return EOF ; } if ( len2 > len1 ) { MST[rv.ROR2Mutator]MSP[S]
@Override public int compare ( final ByteOrderMark bom1 , final ByteOrderMark bom2 ) { final int len1 = bom1 . length () ; final int len2 = bom2 . length () ; if ( len1 > len2 ) { return EOF ; MST[rv.CRCR4Mutator]MSP[S] } if ( len2 > len1 ) {
@Override public int compare ( final ByteOrderMark bom1 , final ByteOrderMark bom2 ) { final int len1 = bom1 . length () ; final int len2 = bom2 . length () ; if ( len1 > len2 ) { return EOF ; } if ( len2 > len1 ) { MST[rv.UOI1Mutator]MSP[S]
return 1 ; } return 0 ; MST[InlineConstantMutator]MSP[S] } public boolean hasBOM () throws IOException { return getBOM () != null ; } public boolean hasBOM ( final ByteOrderMark bom ) throws IOException { if ( ! boms . contains ( bom ) ) {
@Override public int compare ( final ByteOrderMark bom1 , final ByteOrderMark bom2 ) { final int len1 = bom1 . length () ; final int len2 = bom2 . length () ; if ( len1 > len2 ) { return EOF ; } if ( len2 > len1 ) { MST[rv.UOI4Mutator]MSP[S]
return 1 ; MST[rv.CRCR4Mutator]MSP[S] } return 0 ; } public boolean hasBOM () throws IOException { return getBOM () != null ; } public boolean hasBOM ( final ByteOrderMark bom ) throws IOException { if ( ! boms . contains ( bom ) ) {
return 1 ; MST[rv.CRCR6Mutator]MSP[S] } return 0 ; } public boolean hasBOM () throws IOException { return getBOM () != null ; } public boolean hasBOM ( final ByteOrderMark bom ) throws IOException { if ( ! boms . contains ( bom ) ) {
@Override public int compare ( final ByteOrderMark bom1 , final ByteOrderMark bom2 ) { final int len1 = bom1 . length () ; final int len2 = bom2 . length () ; if ( len1 > len2 ) { return EOF ; } if ( len2 > len1 ) { MST[rv.UOI3Mutator]MSP[S]
@Override public int compare ( final ByteOrderMark bom1 , final ByteOrderMark bom2 ) { final int len1 = bom1 . length () ; final int len2 = bom2 . length () ; if ( len1 > len2 ) { MST[NegateConditionalsMutator]MSP[N] return EOF ; } if ( len2 > len1 ) {
@Override public int compare ( final ByteOrderMark bom1 , final ByteOrderMark bom2 ) { final int len1 = bom1 . length () ; final int len2 = bom2 . length () ; if ( len1 > len2 ) { return EOF ; MST[ReturnValsMutator]MSP[N] } if ( len2 > len1 ) {
@Override public int compare ( final ByteOrderMark bom1 , final ByteOrderMark bom2 ) { final int len1 = bom1 . length () ; final int len2 = bom2 . length () ; if ( len1 > len2 ) { return EOF ; } if ( len2 > len1 ) { MST[rv.UOI2Mutator]MSP[S]
return 1 ; } return 0 ; MST[rv.CRCR5Mutator]MSP[S] } public boolean hasBOM () throws IOException { return getBOM () != null ; } public boolean hasBOM ( final ByteOrderMark bom ) throws IOException { if ( ! boms . contains ( bom ) ) {
@Override public int compare ( final ByteOrderMark bom1 , final ByteOrderMark bom2 ) { final int len1 = bom1 . length () ; final int len2 = bom2 . length () ; if ( len1 > len2 ) { return EOF ; } if ( len2 > len1 ) { MST[ConditionalsBoundaryMutator]MSP[S]
@Override public int compare ( final ByteOrderMark bom1 , final ByteOrderMark bom2 ) { final int len1 = bom1 . length () ; final int len2 = bom2 . length () ; if ( len1 > len2 ) { return EOF ; } if ( len2 > len1 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[S]
return 1 ; } return 0 ; MST[rv.CRCR3Mutator]MSP[S] } public boolean hasBOM () throws IOException { return getBOM () != null ; } public boolean hasBOM ( final ByteOrderMark bom ) throws IOException { if ( ! boms . contains ( bom ) ) {
@Override public int compare ( final ByteOrderMark bom1 , final ByteOrderMark bom2 ) { final int len1 = bom1 . length () ; final int len2 = bom2 . length () ; if ( len1 > len2 ) { MST[rv.ABSMutator]MSP[S] return EOF ; } if ( len2 > len1 ) {
@Override public int compare ( final ByteOrderMark bom1 , final ByteOrderMark bom2 ) { final int len1 = bom1 . length () ; final int len2 = bom2 . length () ; if ( len1 > len2 ) { return EOF ; } if ( len2 > len1 ) { MST[NegateConditionalsMutator]MSP[S]
@Override public int compare ( final ByteOrderMark bom1 , final ByteOrderMark bom2 ) { final int len1 = bom1 . length () ; MST[NonVoidMethodCallMutator]MSP[N] final int len2 = bom2 . length () ; if ( len1 > len2 ) { return EOF ; } if ( len2 > len1 ) {
@Override public int compare ( final ByteOrderMark bom1 , final ByteOrderMark bom2 ) { final int len1 = bom1 . length () ; final int len2 = bom2 . length () ; if ( len1 > len2 ) { MST[rv.UOI2Mutator]MSP[S] return EOF ; } if ( len2 > len1 ) {
@Override public int compare ( final ByteOrderMark bom1 , final ByteOrderMark bom2 ) { final int len1 = bom1 . length () ; final int len2 = bom2 . length () ; if ( len1 > len2 ) { MST[rv.ROR4Mutator]MSP[S] return EOF ; } if ( len2 > len1 ) {
@Override public int compare ( final ByteOrderMark bom1 , final ByteOrderMark bom2 ) { final int len1 = bom1 . length () ; final int len2 = bom2 . length () ; if ( len1 > len2 ) { MST[rv.UOI3Mutator]MSP[N] return EOF ; } if ( len2 > len1 ) {
@Override public int compare ( final ByteOrderMark bom1 , final ByteOrderMark bom2 ) { final int len1 = bom1 . length () ; final int len2 = bom2 . length () ; if ( len1 > len2 ) { MST[rv.ROR2Mutator]MSP[N] return EOF ; } if ( len2 > len1 ) {
@Override public int compare ( final ByteOrderMark bom1 , final ByteOrderMark bom2 ) { final int len1 = bom1 . length () ; final int len2 = bom2 . length () ; if ( len1 > len2 ) { MST[rv.UOI4Mutator]MSP[N] return EOF ; } if ( len2 > len1 ) {
@Override public int compare ( final ByteOrderMark bom1 , final ByteOrderMark bom2 ) { final int len1 = bom1 . length () ; final int len2 = bom2 . length () ; if ( len1 > len2 ) { MST[rv.UOI1Mutator]MSP[S] return EOF ; } if ( len2 > len1 ) {
@Override public int compare ( final ByteOrderMark bom1 , final ByteOrderMark bom2 ) { final int len1 = bom1 . length () ; final int len2 = bom2 . length () ; if ( len1 > len2 ) { return EOF ; MST[PrimitiveReturnsMutator]MSP[S] } if ( len2 > len1 ) {
return 1 ; MST[ReturnValsMutator]MSP[S] } return 0 ; } public boolean hasBOM () throws IOException { return getBOM () != null ; } public boolean hasBOM ( final ByteOrderMark bom ) throws IOException { if ( ! boms . contains ( bom ) ) {
