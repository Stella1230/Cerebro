public File getDirectory () { return rootEntry . getFile () ; } public FileFilter getFileFilter () { return fileFilter ; } public void addListener ( final FileAlterationListener listener ) { if ( listener != null ) { listeners . add ( listener ) ; } }
public void removeListener ( final FileAlterationListener listener ) { if ( listener != null ) { while ( listeners . remove ( listener ) ) { } } } public Iterable < FileAlterationListener > getListeners () { return listeners ; } public void initialize () throws Exception {
rootEntry . refresh ( rootEntry . getFile () ) ; final FileEntry [] children = doListFiles ( rootEntry . getFile () , rootEntry ) ; rootEntry . setChildren ( children ) ; } public void destroy () throws Exception { } public void checkAndNotify () {
for ( final FileAlterationListener listener : listeners ) { listener . onStart ( this ) ; } final File rootFile = rootEntry . getFile () ; if ( rootFile . exists () ) { checkAndNotify ( rootEntry , rootEntry . getChildren () , listFiles ( rootFile ) ) ;
} else if ( rootEntry . isExists () ) { checkAndNotify ( rootEntry , rootEntry . getChildren () , FileUtils . EMPTY_FILE_ARRAY ) ; } else { } for ( final FileAlterationListener listener : listeners ) { listener . onStop ( this ) ; } }
private void checkAndNotify ( final FileEntry parent , final FileEntry [] previous , final File [] files ) { int c = 0 ; final FileEntry [] current = files . length > 0 ? new FileEntry [ files . length ] : FileEntry . EMPTY_ENTRIES ;
for ( final FileEntry entry : previous ) { while ( c < files . length && comparator . compare ( entry . getFile () , files [ c ] ) > 0 ) { current [ c ] = createFileEntry ( parent , files [ c ] ) ;
doCreate ( current [ c ] ) ; c ++ ; } if ( c < files . length && comparator . compare ( entry . getFile () , files [ c ] ) == 0 ) { doMatch ( entry , files [ c ] ) ;
checkAndNotify ( entry , entry . getChildren () , listFiles ( files [ c ] ) ) ; current [ c ] = entry ; c ++ ; } else { checkAndNotify ( entry , entry . getChildren () , FileUtils . EMPTY_FILE_ARRAY ) ; doDelete ( entry ) ;
} } for (; c < files . length ; c ++ ) { current [ c ] = createFileEntry ( parent , files [ c ] ) ; doCreate ( current [ c ] ) ; } parent . setChildren ( current ) ; }
private FileEntry createFileEntry ( final FileEntry parent , final File file ) { final FileEntry entry = parent . newChildInstance ( file ) ; entry . refresh ( file ) ; final FileEntry [] children = doListFiles ( file , entry ) ; entry . setChildren ( children ) ;
return entry ; } private FileEntry [] doListFiles ( final File file , final FileEntry entry ) { final File [] files = listFiles ( file ) ;
final FileEntry [] children = files . length > 0 ? new FileEntry [ files . length ] : FileEntry . EMPTY_ENTRIES ; for ( int i = 0 ; i < files . length ; i ++ ) {
children [ i ] = createFileEntry ( entry , files [ i ] ) ; } return children ; } private void doCreate ( final FileEntry entry ) { for ( final FileAlterationListener listener : listeners ) { if ( entry . isDirectory () ) {
listener . onDirectoryCreate ( entry . getFile () ) ; } else { listener . onFileCreate ( entry . getFile () ) ; } } final FileEntry [] children = entry . getChildren () ; for ( final FileEntry aChildren : children ) { doCreate ( aChildren ) ; }
} private void doMatch ( final FileEntry entry , final File file ) { if ( entry . refresh ( file ) ) { for ( final FileAlterationListener listener : listeners ) { if ( entry . isDirectory () ) { listener . onDirectoryChange ( file ) ;
} else { listener . onFileChange ( file ) ; } } } } private void doDelete ( final FileEntry entry ) { for ( final FileAlterationListener listener : listeners ) { if ( entry . isDirectory () ) { listener . onDirectoryDelete ( entry . getFile () ) ;
} else { listener . onFileDelete ( entry . getFile () ) ; } } } private File [] listFiles ( final File file ) { File [] children = null ; if ( file . isDirectory () ) {
children = fileFilter == null ? file . listFiles () : file . listFiles ( fileFilter ) ; } if ( children == null ) { children = FileUtils . EMPTY_FILE_ARRAY ; } if ( comparator != null && children . length > 1 ) {
Arrays . sort ( children , comparator ) ; } return children ; } @Override public String toString () { final StringBuilder builder = new StringBuilder () ; builder . append ( getClass () . getSimpleName () ) ; builder . append ( lr_1 ) ;
builder . append ( getDirectory () . getPath () ) ; builder . append ( '\'' ) ; if ( fileFilter != null ) { builder . append ( lr_2 ) ; builder . append ( fileFilter . toString () ) ; } builder . append ( lr_3 ) ;
builder . append ( listeners . size () ) ; builder . append ( lr_4 ) ; return builder . toString () ; }
