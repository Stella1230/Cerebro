final List < File > acceptedFiles = new ArrayList <> () ; MST[ConstructorCallMutator]MSP[] for ( final File file : files ) { if ( file == null ) { throw new IllegalArgumentException ( lr_2 ) ; } if ( filter . accept ( file ) ) {
throw new IllegalArgumentException ( lr_5 + i + lr_6 ) ; } list . add ( filters [ i ] ) ; MST[rv.ABSMutator]MSP[] } return list ; } public static IOFileFilter notFileFilter ( final IOFileFilter filter ) { return new NotFileFilter ( filter ) ; }
return new HashSet <> ( Arrays . asList ( acceptedFiles ) ) ; MST[ReturnValsMutator]MSP[] } public static Set < File > filterSet ( final IOFileFilter filter , final Iterable < File > files ) { return filter ( filter , files , new HashSet < File > () ) ; }
} return acceptedFiles ; MST[EmptyObjectReturnValsMutator]MSP[] } public static IOFileFilter prefixFileFilter ( final String prefix ) { return new PrefixFileFilter ( prefix ) ; } public static IOFileFilter prefixFileFilter ( final String prefix , final IOCase caseSensitivity ) { return new PrefixFileFilter ( prefix , caseSensitivity ) ; }
return new SizeFileFilter ( threshold , acceptLarger ) ; } public static IOFileFilter sizeRangeFileFilter ( final long minSizeInclusive , final long maxSizeInclusive ) { final IOFileFilter minimumFilter = new SizeFileFilter ( minSizeInclusive , true ) ; final IOFileFilter maximumFilter = new SizeFileFilter ( maxSizeInclusive + 1L , false ) ; MST[rv.CRCR6Mutator]MSP[]
} final List < IOFileFilter > list = new ArrayList <> ( filters . length ) ; for ( int i = 0 ; i < filters . length ; i ++ ) { if ( filters [ i ] == null ) { MST[rv.UOI4Mutator]MSP[]
public static IOFileFilter asFileFilter ( final FilenameFilter filter ) { return new DelegateFileFilter ( filter ) ; } public static IOFileFilter ageFileFilter ( final long cutoff ) { return new AgeFileFilter ( cutoff ) ; MST[ConstructorCallMutator]MSP[] } public static IOFileFilter ageFileFilter ( final long cutoff , final boolean acceptOlder ) {
return new SizeFileFilter ( threshold , acceptLarger ) ; } public static IOFileFilter sizeRangeFileFilter ( final long minSizeInclusive , final long maxSizeInclusive ) { final IOFileFilter minimumFilter = new SizeFileFilter ( minSizeInclusive , true ) ; final IOFileFilter maximumFilter = new SizeFileFilter ( maxSizeInclusive + 1L , false ) ; MST[rv.AOR2Mutator]MSP[]
throw new IllegalArgumentException ( lr_5 + i + lr_6 ) ; MST[rv.UOI3Mutator]MSP[] } list . add ( filters [ i ] ) ; } return list ; } public static IOFileFilter notFileFilter ( final IOFileFilter filter ) { return new NotFileFilter ( filter ) ; }
return new SizeFileFilter ( threshold , acceptLarger ) ; MST[rv.UOI2Mutator]MSP[] } public static IOFileFilter sizeRangeFileFilter ( final long minSizeInclusive , final long maxSizeInclusive ) { final IOFileFilter minimumFilter = new SizeFileFilter ( minSizeInclusive , true ) ; final IOFileFilter maximumFilter = new SizeFileFilter ( maxSizeInclusive + 1L , false ) ;
return new AndFileFilter ( minimumFilter , maximumFilter ) ; MST[NullReturnValsMutator]MSP[] } public static IOFileFilter magicNumberFileFilter ( final String magicNumber ) { return new MagicNumberFileFilter ( magicNumber ) ; } public static IOFileFilter magicNumberFileFilter ( final String magicNumber , final long offset ) {
final List < File > acceptedFiles = new ArrayList <> () ; for ( final File file : files ) { if ( file == null ) { throw new IllegalArgumentException ( lr_2 ) ; } if ( filter . accept ( file ) ) { MST[rv.ROR5Mutator]MSP[]
final List < File > acceptedFiles = new ArrayList <> () ; for ( final File file : files ) { if ( file == null ) { throw new IllegalArgumentException ( lr_2 ) ; } if ( filter . accept ( file ) ) { MST[rv.ROR1Mutator]MSP[]
} final List < IOFileFilter > list = new ArrayList <> ( filters . length ) ; for ( int i = 0 ; i < filters . length ; i ++ ) { MST[ConditionalsBoundaryMutator]MSP[] if ( filters [ i ] == null ) {
public static IOFileFilter asFileFilter ( final FilenameFilter filter ) { return new DelegateFileFilter ( filter ) ; } public static IOFileFilter ageFileFilter ( final long cutoff ) { return new AgeFileFilter ( cutoff ) ; MST[rv.UOI3Mutator]MSP[] } public static IOFileFilter ageFileFilter ( final long cutoff , final boolean acceptOlder ) {
acceptedFiles . add ( file ) ; } } return acceptedFiles . toArray ( new File [ acceptedFiles . size () ] ) ; MST[ReturnValsMutator]MSP[] } public static File [] filter ( final IOFileFilter filter , final Iterable < File > files ) {
public static IOFileFilter trueFileFilter () { return TrueFileFilter . TRUE ; MST[NullReturnValsMutator]MSP[] } public static IOFileFilter falseFileFilter () { return FalseFileFilter . FALSE ; } public static IOFileFilter asFileFilter ( final FileFilter filter ) { return new DelegateFileFilter ( filter ) ; }
return filter == null ? svnFilter : and ( filter , svnFilter ) ; MST[InlineConstantMutator]MSP[] } public static IOFileFilter makeDirectoryOnly ( final IOFileFilter filter ) { if ( filter == null ) { return DirectoryFileFilter . DIRECTORY ; } return new AndFileFilter ( DirectoryFileFilter . DIRECTORY , filter ) ; }
public static IOFileFilter orFileFilter ( final IOFileFilter filter1 , final IOFileFilter filter2 ) { return new OrFileFilter ( filter1 , filter2 ) ; MST[NullReturnValsMutator]MSP[] } public static IOFileFilter and ( final IOFileFilter ... filters ) { return new AndFileFilter ( toList ( filters ) ) ; }
throw new IllegalArgumentException ( lr_5 + i + lr_6 ) ; MST[NonVoidMethodCallMutator]MSP[] } list . add ( filters [ i ] ) ; } return list ; } public static IOFileFilter notFileFilter ( final IOFileFilter filter ) { return new NotFileFilter ( filter ) ; }
return new MagicNumberFileFilter ( magicNumber , offset ) ; } public static IOFileFilter makeCVSAware ( final IOFileFilter filter ) { return filter == null ? cvsFilter : and ( filter , cvsFilter ) ; MST[rv.CRCR5Mutator]MSP[] } public static IOFileFilter makeSVNAware ( final IOFileFilter filter ) {
public static File [] filter ( final IOFileFilter filter , final File ... files ) { if ( filter == null ) { throw new IllegalArgumentException ( lr_1 ) ; } if ( files == null ) { return new File [ 0 ] ; MST[rv.CRCR5Mutator]MSP[] }
public static File [] filter ( final IOFileFilter filter , final File ... files ) { if ( filter == null ) { throw new IllegalArgumentException ( lr_1 ) ; } if ( files == null ) { return new File [ 0 ] ; MST[rv.CRCR1Mutator]MSP[] }
return new AgeFileFilter ( cutoffDate , acceptOlder ) ; } public static IOFileFilter ageFileFilter ( final File cutoffReference ) { return new AgeFileFilter ( cutoffReference ) ; MST[ReturnValsMutator]MSP[] } public static IOFileFilter ageFileFilter ( final File cutoffReference , final boolean acceptOlder ) {
final List < File > acceptedFiles = filterList ( filter , files ) ; return acceptedFiles . toArray ( new File [ acceptedFiles . size () ] ) ; MST[ReturnValsMutator]MSP[] } public static List < File > filterList ( final IOFileFilter filter , final Iterable < File > files ) {
return new AgeFileFilter ( cutoffDate , acceptOlder ) ; MST[rv.ABSMutator]MSP[] } public static IOFileFilter ageFileFilter ( final File cutoffReference ) { return new AgeFileFilter ( cutoffReference ) ; } public static IOFileFilter ageFileFilter ( final File cutoffReference , final boolean acceptOlder ) {
final List < File > acceptedFiles = new ArrayList <> () ; for ( final File file : files ) { MST[rv.UOI3Mutator]MSP[] if ( file == null ) { throw new IllegalArgumentException ( lr_2 ) ; } if ( filter . accept ( file ) ) {
} final List < IOFileFilter > list = new ArrayList <> ( filters . length ) ; for ( int i = 0 ; i < filters . length ; i ++ ) { MST[rv.UOI2Mutator]MSP[] if ( filters [ i ] == null ) {
final List < File > acceptedFiles = new ArrayList <> () ; for ( final File file : files ) { if ( file == null ) { throw new IllegalArgumentException ( lr_2 ) ; } if ( filter . accept ( file ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
if ( files != null ) { for ( final File file : files ) { if ( file == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] throw new IllegalArgumentException ( lr_3 ) ; } if ( filter . accept ( file ) ) { acceptedFiles . add ( file ) ; } }
final List < File > acceptedFiles = filterList ( filter , files ) ; return acceptedFiles . toArray ( new File [ acceptedFiles . size () ] ) ; MST[ArgumentPropagationMutator]MSP[] } public static List < File > filterList ( final IOFileFilter filter , final Iterable < File > files ) {
return new AgeFileFilter ( cutoffReference , acceptOlder ) ; MST[rv.UOI2Mutator]MSP[] } public static IOFileFilter sizeFileFilter ( final long threshold ) { return new SizeFileFilter ( threshold ) ; } public static IOFileFilter sizeFileFilter ( final long threshold , final boolean acceptLarger ) {
acceptedFiles . add ( file ) ; } } return acceptedFiles . toArray ( new File [ acceptedFiles . size () ] ) ; MST[ArgumentPropagationMutator]MSP[] } public static File [] filter ( final IOFileFilter filter , final Iterable < File > files ) {
return filter == null ? svnFilter : and ( filter , svnFilter ) ; MST[rv.CRCR3Mutator]MSP[] } public static IOFileFilter makeDirectoryOnly ( final IOFileFilter filter ) { if ( filter == null ) { return DirectoryFileFilter . DIRECTORY ; } return new AndFileFilter ( DirectoryFileFilter . DIRECTORY , filter ) ; }
return new SizeFileFilter ( threshold , acceptLarger ) ; MST[rv.UOI2Mutator]MSP[] } public static IOFileFilter sizeRangeFileFilter ( final long minSizeInclusive , final long maxSizeInclusive ) { final IOFileFilter minimumFilter = new SizeFileFilter ( minSizeInclusive , true ) ; final IOFileFilter maximumFilter = new SizeFileFilter ( maxSizeInclusive + 1L , false ) ;
public static IOFileFilter orFileFilter ( final IOFileFilter filter1 , final IOFileFilter filter2 ) { return new OrFileFilter ( filter1 , filter2 ) ; } public static IOFileFilter and ( final IOFileFilter ... filters ) { return new AndFileFilter ( toList ( filters ) ) ; MST[ReturnValsMutator]MSP[] }
return new AgeFileFilter ( cutoff , acceptOlder ) ; MST[rv.UOI3Mutator]MSP[] } public static IOFileFilter ageFileFilter ( final Date cutoffDate ) { return new AgeFileFilter ( cutoffDate ) ; } public static IOFileFilter ageFileFilter ( final Date cutoffDate , final boolean acceptOlder ) {
return new AgeFileFilter ( cutoffDate , acceptOlder ) ; MST[rv.UOI2Mutator]MSP[] } public static IOFileFilter ageFileFilter ( final File cutoffReference ) { return new AgeFileFilter ( cutoffReference ) ; } public static IOFileFilter ageFileFilter ( final File cutoffReference , final boolean acceptOlder ) {
return new AgeFileFilter ( cutoffReference , acceptOlder ) ; } public static IOFileFilter sizeFileFilter ( final long threshold ) { return new SizeFileFilter ( threshold ) ; MST[rv.ABSMutator]MSP[] } public static IOFileFilter sizeFileFilter ( final long threshold , final boolean acceptLarger ) {
return filter ( filter , files , new ArrayList < File > () ) ; MST[EmptyObjectReturnValsMutator]MSP[] } public static List < File > filterList ( final IOFileFilter filter , final File ... files ) { final File [] acceptedFiles = filter ( filter , files ) ;
public static IOFileFilter makeFileOnly ( final IOFileFilter filter ) { if ( filter == null ) { return FileFileFilter . FILE ; MST[ReturnValsMutator]MSP[] } return new AndFileFilter ( FileFileFilter . FILE , filter ) ; }
public static File [] filter ( final IOFileFilter filter , final File ... files ) { if ( filter == null ) { throw new IllegalArgumentException ( lr_1 ) ; } if ( files == null ) { return new File [ 0 ] ; MST[ReturnValsMutator]MSP[] }
return new SizeFileFilter ( threshold , acceptLarger ) ; } public static IOFileFilter sizeRangeFileFilter ( final long minSizeInclusive , final long maxSizeInclusive ) { final IOFileFilter minimumFilter = new SizeFileFilter ( minSizeInclusive , true ) ; final IOFileFilter maximumFilter = new SizeFileFilter ( maxSizeInclusive + 1L , false ) ; MST[rv.UOI1Mutator]MSP[]
public static IOFileFilter nameFileFilter ( final String name ) { return new NameFileFilter ( name ) ; } public static IOFileFilter nameFileFilter ( final String name , final IOCase caseSensitivity ) { return new NameFileFilter ( name , caseSensitivity ) ; MST[NullReturnValsMutator]MSP[] } public static IOFileFilter directoryFileFilter () {
if ( files != null ) { for ( final File file : files ) { if ( file == null ) { throw new IllegalArgumentException ( lr_3 ) ; } if ( filter . accept ( file ) ) { MST[rv.ROR4Mutator]MSP[] acceptedFiles . add ( file ) ; } }
public static File [] filter ( final IOFileFilter filter , final File ... files ) { if ( filter == null ) { throw new IllegalArgumentException ( lr_1 ) ; } if ( files == null ) { MST[rv.ROR5Mutator]MSP[] return new File [ 0 ] ; }
return new MagicNumberFileFilter ( magicNumber , offset ) ; } public static IOFileFilter makeCVSAware ( final IOFileFilter filter ) { return filter == null ? cvsFilter : and ( filter , cvsFilter ) ; MST[rv.CRCR3Mutator]MSP[] } public static IOFileFilter makeSVNAware ( final IOFileFilter filter ) {
return new MagicNumberFileFilter ( magicNumber , offset ) ; MST[rv.UOI4Mutator]MSP[] } public static IOFileFilter magicNumberFileFilter ( final byte [] magicNumber ) { return new MagicNumberFileFilter ( magicNumber ) ; } public static IOFileFilter magicNumberFileFilter ( final byte [] magicNumber , final long offset ) {
public static IOFileFilter makeFileOnly ( final IOFileFilter filter ) { if ( filter == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return FileFileFilter . FILE ; } return new AndFileFilter ( FileFileFilter . FILE , filter ) ; }
public static IOFileFilter or ( final IOFileFilter ... filters ) { return new OrFileFilter ( toList ( filters ) ) ; } public static List < IOFileFilter > toList ( final IOFileFilter ... filters ) { if ( filters == null ) { MST[rv.ROR5Mutator]MSP[] throw new IllegalArgumentException ( lr_4 ) ;
return new SizeFileFilter ( threshold , acceptLarger ) ; } public static IOFileFilter sizeRangeFileFilter ( final long minSizeInclusive , final long maxSizeInclusive ) { final IOFileFilter minimumFilter = new SizeFileFilter ( minSizeInclusive , true ) ; MST[rv.CRCR3Mutator]MSP[] final IOFileFilter maximumFilter = new SizeFileFilter ( maxSizeInclusive + 1L , false ) ;
private static < T extends Collection < File > > T filter ( final IOFileFilter filter , final Iterable < File > files , final T acceptedFiles ) { if ( filter == null ) { MST[NegateConditionalsMutator]MSP[] throw new IllegalArgumentException ( lr_1 ) ; }
final List < File > acceptedFiles = filterList ( filter , files ) ; MST[NonVoidMethodCallMutator]MSP[] return acceptedFiles . toArray ( new File [ acceptedFiles . size () ] ) ; } public static List < File > filterList ( final IOFileFilter filter , final Iterable < File > files ) {
} return acceptedFiles ; } public static IOFileFilter prefixFileFilter ( final String prefix ) { return new PrefixFileFilter ( prefix ) ; MST[ConstructorCallMutator]MSP[] } public static IOFileFilter prefixFileFilter ( final String prefix , final IOCase caseSensitivity ) { return new PrefixFileFilter ( prefix , caseSensitivity ) ; }
return new MagicNumberFileFilter ( magicNumber , offset ) ; MST[rv.UOI1Mutator]MSP[] } public static IOFileFilter magicNumberFileFilter ( final byte [] magicNumber ) { return new MagicNumberFileFilter ( magicNumber ) ; } public static IOFileFilter magicNumberFileFilter ( final byte [] magicNumber , final long offset ) {
final List < File > acceptedFiles = new ArrayList <> () ; for ( final File file : files ) { MST[rv.ABSMutator]MSP[] if ( file == null ) { throw new IllegalArgumentException ( lr_2 ) ; } if ( filter . accept ( file ) ) {
return new SizeFileFilter ( threshold , acceptLarger ) ; } public static IOFileFilter sizeRangeFileFilter ( final long minSizeInclusive , final long maxSizeInclusive ) { final IOFileFilter minimumFilter = new SizeFileFilter ( minSizeInclusive , true ) ; final IOFileFilter maximumFilter = new SizeFileFilter ( maxSizeInclusive + 1L , false ) ; MST[rv.AOD1Mutator]MSP[]
return new AgeFileFilter ( cutoff , acceptOlder ) ; MST[rv.UOI3Mutator]MSP[] } public static IOFileFilter ageFileFilter ( final Date cutoffDate ) { return new AgeFileFilter ( cutoffDate ) ; } public static IOFileFilter ageFileFilter ( final Date cutoffDate , final boolean acceptOlder ) {
return new SizeFileFilter ( threshold , acceptLarger ) ; } public static IOFileFilter sizeRangeFileFilter ( final long minSizeInclusive , final long maxSizeInclusive ) { final IOFileFilter minimumFilter = new SizeFileFilter ( minSizeInclusive , true ) ; MST[ConstructorCallMutator]MSP[] final IOFileFilter maximumFilter = new SizeFileFilter ( maxSizeInclusive + 1L , false ) ;
public static IOFileFilter asFileFilter ( final FilenameFilter filter ) { return new DelegateFileFilter ( filter ) ; MST[ConstructorCallMutator]MSP[] } public static IOFileFilter ageFileFilter ( final long cutoff ) { return new AgeFileFilter ( cutoff ) ; } public static IOFileFilter ageFileFilter ( final long cutoff , final boolean acceptOlder ) {
return filter == null ? svnFilter : and ( filter , svnFilter ) ; MST[ReturnValsMutator]MSP[] } public static IOFileFilter makeDirectoryOnly ( final IOFileFilter filter ) { if ( filter == null ) { return DirectoryFileFilter . DIRECTORY ; } return new AndFileFilter ( DirectoryFileFilter . DIRECTORY , filter ) ; }
return new SizeFileFilter ( threshold , acceptLarger ) ; } public static IOFileFilter sizeRangeFileFilter ( final long minSizeInclusive , final long maxSizeInclusive ) { final IOFileFilter minimumFilter = new SizeFileFilter ( minSizeInclusive , true ) ; final IOFileFilter maximumFilter = new SizeFileFilter ( maxSizeInclusive + 1L , false ) ; MST[rv.CRCR6Mutator]MSP[]
return new MagicNumberFileFilter ( magicNumber , offset ) ; } public static IOFileFilter magicNumberFileFilter ( final byte [] magicNumber ) { return new MagicNumberFileFilter ( magicNumber ) ; MST[NullReturnValsMutator]MSP[] } public static IOFileFilter magicNumberFileFilter ( final byte [] magicNumber , final long offset ) {
if ( files != null ) { for ( final File file : files ) { if ( file == null ) { MST[rv.ROR5Mutator]MSP[] throw new IllegalArgumentException ( lr_3 ) ; } if ( filter . accept ( file ) ) { acceptedFiles . add ( file ) ; } }
return new SizeFileFilter ( threshold , acceptLarger ) ; MST[rv.ABSMutator]MSP[] } public static IOFileFilter sizeRangeFileFilter ( final long minSizeInclusive , final long maxSizeInclusive ) { final IOFileFilter minimumFilter = new SizeFileFilter ( minSizeInclusive , true ) ; final IOFileFilter maximumFilter = new SizeFileFilter ( maxSizeInclusive + 1L , false ) ;
} final List < IOFileFilter > list = new ArrayList <> ( filters . length ) ; for ( int i = 0 ; i < filters . length ; i ++ ) { if ( filters [ i ] == null ) { MST[rv.ROR5Mutator]MSP[]
return filter == null ? svnFilter : and ( filter , svnFilter ) ; MST[rv.CRCR4Mutator]MSP[] } public static IOFileFilter makeDirectoryOnly ( final IOFileFilter filter ) { if ( filter == null ) { return DirectoryFileFilter . DIRECTORY ; } return new AndFileFilter ( DirectoryFileFilter . DIRECTORY , filter ) ; }
public static IOFileFilter makeFileOnly ( final IOFileFilter filter ) { if ( filter == null ) { return FileFileFilter . FILE ; } return new AndFileFilter ( FileFileFilter . FILE , filter ) ; MST[ConstructorCallMutator]MSP[] }
public static File [] filter ( final IOFileFilter filter , final File ... files ) { if ( filter == null ) { throw new IllegalArgumentException ( lr_1 ) ; } if ( files == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return new File [ 0 ] ; }
public static IOFileFilter orFileFilter ( final IOFileFilter filter1 , final IOFileFilter filter2 ) { return new OrFileFilter ( filter1 , filter2 ) ; } public static IOFileFilter and ( final IOFileFilter ... filters ) { return new AndFileFilter ( toList ( filters ) ) ; MST[NullReturnValsMutator]MSP[] }
return new AgeFileFilter ( cutoffDate , acceptOlder ) ; MST[rv.UOI1Mutator]MSP[] } public static IOFileFilter ageFileFilter ( final File cutoffReference ) { return new AgeFileFilter ( cutoffReference ) ; } public static IOFileFilter ageFileFilter ( final File cutoffReference , final boolean acceptOlder ) {
return filter == null ? svnFilter : and ( filter , svnFilter ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] } public static IOFileFilter makeDirectoryOnly ( final IOFileFilter filter ) { if ( filter == null ) { return DirectoryFileFilter . DIRECTORY ; } return new AndFileFilter ( DirectoryFileFilter . DIRECTORY , filter ) ; }
public static IOFileFilter or ( final IOFileFilter ... filters ) { return new OrFileFilter ( toList ( filters ) ) ; MST[ConstructorCallMutator]MSP[] } public static List < IOFileFilter > toList ( final IOFileFilter ... filters ) { if ( filters == null ) { throw new IllegalArgumentException ( lr_4 ) ;
private static < T extends Collection < File > > T filter ( final IOFileFilter filter , final Iterable < File > files , final T acceptedFiles ) { if ( filter == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] throw new IllegalArgumentException ( lr_1 ) ; }
return filter == null ? svnFilter : and ( filter , svnFilter ) ; } public static IOFileFilter makeDirectoryOnly ( final IOFileFilter filter ) { if ( filter == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return DirectoryFileFilter . DIRECTORY ; } return new AndFileFilter ( DirectoryFileFilter . DIRECTORY , filter ) ; }
return new MagicNumberFileFilter ( magicNumber , offset ) ; } public static IOFileFilter makeCVSAware ( final IOFileFilter filter ) { return filter == null ? cvsFilter : and ( filter , cvsFilter ) ; MST[rv.CRCR3Mutator]MSP[] } public static IOFileFilter makeSVNAware ( final IOFileFilter filter ) {
return filter ( filter , files , new ArrayList < File > () ) ; MST[NonVoidMethodCallMutator]MSP[] } public static List < File > filterList ( final IOFileFilter filter , final File ... files ) { final File [] acceptedFiles = filter ( filter , files ) ;
final List < File > acceptedFiles = new ArrayList <> () ; for ( final File file : files ) { if ( file == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] throw new IllegalArgumentException ( lr_2 ) ; } if ( filter . accept ( file ) ) {
public static File [] filter ( final IOFileFilter filter , final File ... files ) { if ( filter == null ) { throw new IllegalArgumentException ( lr_1 ) ; } if ( files == null ) { return new File [ 0 ] ; MST[rv.CRCR6Mutator]MSP[] }
final List < File > acceptedFiles = new ArrayList <> () ; for ( final File file : files ) { MST[rv.ABSMutator]MSP[] if ( file == null ) { throw new IllegalArgumentException ( lr_2 ) ; } if ( filter . accept ( file ) ) {
return new MagicNumberFileFilter ( magicNumber , offset ) ; MST[ReturnValsMutator]MSP[] } public static IOFileFilter magicNumberFileFilter ( final byte [] magicNumber ) { return new MagicNumberFileFilter ( magicNumber ) ; } public static IOFileFilter magicNumberFileFilter ( final byte [] magicNumber , final long offset ) {
return new AgeFileFilter ( cutoffReference , acceptOlder ) ; MST[rv.ABSMutator]MSP[] } public static IOFileFilter sizeFileFilter ( final long threshold ) { return new SizeFileFilter ( threshold ) ; } public static IOFileFilter sizeFileFilter ( final long threshold , final boolean acceptLarger ) {
return new HashSet <> ( Arrays . asList ( acceptedFiles ) ) ; } public static Set < File > filterSet ( final IOFileFilter filter , final Iterable < File > files ) { return filter ( filter , files , new HashSet < File > () ) ; MST[ReturnValsMutator]MSP[] }
if ( files != null ) { MST[rv.ROR5Mutator]MSP[] for ( final File file : files ) { if ( file == null ) { throw new IllegalArgumentException ( lr_3 ) ; } if ( filter . accept ( file ) ) { acceptedFiles . add ( file ) ; } }
} final List < IOFileFilter > list = new ArrayList <> ( filters . length ) ; for ( int i = 0 ; i < filters . length ; i ++ ) { MST[rv.ROR3Mutator]MSP[] if ( filters [ i ] == null ) {
throw new IllegalArgumentException ( lr_5 + i + lr_6 ) ; } list . add ( filters [ i ] ) ; } return list ; } public static IOFileFilter notFileFilter ( final IOFileFilter filter ) { return new NotFileFilter ( filter ) ; MST[NullReturnValsMutator]MSP[] }
public static IOFileFilter orFileFilter ( final IOFileFilter filter1 , final IOFileFilter filter2 ) { return new OrFileFilter ( filter1 , filter2 ) ; MST[ConstructorCallMutator]MSP[] } public static IOFileFilter and ( final IOFileFilter ... filters ) { return new AndFileFilter ( toList ( filters ) ) ; }
return new MagicNumberFileFilter ( magicNumber , offset ) ; MST[NullReturnValsMutator]MSP[] } public static IOFileFilter magicNumberFileFilter ( final byte [] magicNumber ) { return new MagicNumberFileFilter ( magicNumber ) ; } public static IOFileFilter magicNumberFileFilter ( final byte [] magicNumber , final long offset ) {
return new SizeFileFilter ( threshold , acceptLarger ) ; MST[rv.ABSMutator]MSP[] } public static IOFileFilter sizeRangeFileFilter ( final long minSizeInclusive , final long maxSizeInclusive ) { final IOFileFilter minimumFilter = new SizeFileFilter ( minSizeInclusive , true ) ; final IOFileFilter maximumFilter = new SizeFileFilter ( maxSizeInclusive + 1L , false ) ;
return DirectoryFileFilter . DIRECTORY ; } public static IOFileFilter fileFileFilter () { return FileFileFilter . FILE ; } @Deprecated public static IOFileFilter andFileFilter ( final IOFileFilter filter1 , final IOFileFilter filter2 ) { return new AndFileFilter ( filter1 , filter2 ) ; MST[ReturnValsMutator]MSP[] } @Deprecated
return new MagicNumberFileFilter ( magicNumber , offset ) ; } public static IOFileFilter magicNumberFileFilter ( final byte [] magicNumber ) { return new MagicNumberFileFilter ( magicNumber ) ; MST[ReturnValsMutator]MSP[] } public static IOFileFilter magicNumberFileFilter ( final byte [] magicNumber , final long offset ) {
throw new IllegalArgumentException ( lr_5 + i + lr_6 ) ; MST[experimental.NakedReceiverMutator]MSP[] } list . add ( filters [ i ] ) ; } return list ; } public static IOFileFilter notFileFilter ( final IOFileFilter filter ) { return new NotFileFilter ( filter ) ; }
public static IOFileFilter trueFileFilter () { return TrueFileFilter . TRUE ; MST[ReturnValsMutator]MSP[] } public static IOFileFilter falseFileFilter () { return FalseFileFilter . FALSE ; } public static IOFileFilter asFileFilter ( final FileFilter filter ) { return new DelegateFileFilter ( filter ) ; }
if ( files != null ) { for ( final File file : files ) { if ( file == null ) { throw new IllegalArgumentException ( lr_3 ) ; } if ( filter . accept ( file ) ) { MST[NonVoidMethodCallMutator]MSP[] acceptedFiles . add ( file ) ; } }
return new AgeFileFilter ( cutoff , acceptOlder ) ; MST[ConstructorCallMutator]MSP[] } public static IOFileFilter ageFileFilter ( final Date cutoffDate ) { return new AgeFileFilter ( cutoffDate ) ; } public static IOFileFilter ageFileFilter ( final Date cutoffDate , final boolean acceptOlder ) {
return filter == null ? svnFilter : and ( filter , svnFilter ) ; } public static IOFileFilter makeDirectoryOnly ( final IOFileFilter filter ) { if ( filter == null ) { return DirectoryFileFilter . DIRECTORY ; } return new AndFileFilter ( DirectoryFileFilter . DIRECTORY , filter ) ; MST[ConstructorCallMutator]MSP[] }
return new AgeFileFilter ( cutoff , acceptOlder ) ; } public static IOFileFilter ageFileFilter ( final Date cutoffDate ) { return new AgeFileFilter ( cutoffDate ) ; MST[ConstructorCallMutator]MSP[] } public static IOFileFilter ageFileFilter ( final Date cutoffDate , final boolean acceptOlder ) {
return new HashSet <> ( Arrays . asList ( acceptedFiles ) ) ; } public static Set < File > filterSet ( final IOFileFilter filter , final Iterable < File > files ) { return filter ( filter , files , new HashSet < File > () ) ; MST[ArgumentPropagationMutator]MSP[] }
acceptedFiles . add ( file ) ; MST[NonVoidMethodCallMutator]MSP[] } } return acceptedFiles . toArray ( new File [ acceptedFiles . size () ] ) ; } public static File [] filter ( final IOFileFilter filter , final Iterable < File > files ) {
} final List < IOFileFilter > list = new ArrayList <> ( filters . length ) ; for ( int i = 0 ; i < filters . length ; i ++ ) { MST[rv.CRCR5Mutator]MSP[] if ( filters [ i ] == null ) {
public static IOFileFilter orFileFilter ( final IOFileFilter filter1 , final IOFileFilter filter2 ) { return new OrFileFilter ( filter1 , filter2 ) ; MST[ReturnValsMutator]MSP[] } public static IOFileFilter and ( final IOFileFilter ... filters ) { return new AndFileFilter ( toList ( filters ) ) ; }
return new MagicNumberFileFilter ( magicNumber , offset ) ; } public static IOFileFilter makeCVSAware ( final IOFileFilter filter ) { return filter == null ? cvsFilter : and ( filter , cvsFilter ) ; MST[NonVoidMethodCallMutator]MSP[] } public static IOFileFilter makeSVNAware ( final IOFileFilter filter ) {
public static IOFileFilter asFileFilter ( final FilenameFilter filter ) { return new DelegateFileFilter ( filter ) ; } public static IOFileFilter ageFileFilter ( final long cutoff ) { return new AgeFileFilter ( cutoff ) ; MST[NullReturnValsMutator]MSP[] } public static IOFileFilter ageFileFilter ( final long cutoff , final boolean acceptOlder ) {
public static IOFileFilter nameFileFilter ( final String name ) { return new NameFileFilter ( name ) ; MST[NullReturnValsMutator]MSP[] } public static IOFileFilter nameFileFilter ( final String name , final IOCase caseSensitivity ) { return new NameFileFilter ( name , caseSensitivity ) ; } public static IOFileFilter directoryFileFilter () {
acceptedFiles . add ( file ) ; } } return acceptedFiles . toArray ( new File [ acceptedFiles . size () ] ) ; MST[NullReturnValsMutator]MSP[] } public static File [] filter ( final IOFileFilter filter , final Iterable < File > files ) {
throw new IllegalArgumentException ( lr_5 + i + lr_6 ) ; MST[rv.ABSMutator]MSP[] } list . add ( filters [ i ] ) ; } return list ; } public static IOFileFilter notFileFilter ( final IOFileFilter filter ) { return new NotFileFilter ( filter ) ; }
final List < File > acceptedFiles = new ArrayList <> () ; for ( final File file : files ) { if ( file == null ) { MST[NegateConditionalsMutator]MSP[] throw new IllegalArgumentException ( lr_2 ) ; } if ( filter . accept ( file ) ) {
throw new IllegalArgumentException ( lr_5 + i + lr_6 ) ; MST[ConstructorCallMutator]MSP[] } list . add ( filters [ i ] ) ; } return list ; } public static IOFileFilter notFileFilter ( final IOFileFilter filter ) { return new NotFileFilter ( filter ) ; }
return DirectoryFileFilter . DIRECTORY ; MST[NullReturnValsMutator]MSP[] } public static IOFileFilter fileFileFilter () { return FileFileFilter . FILE ; } @Deprecated public static IOFileFilter andFileFilter ( final IOFileFilter filter1 , final IOFileFilter filter2 ) { return new AndFileFilter ( filter1 , filter2 ) ; } @Deprecated
return new MagicNumberFileFilter ( magicNumber , offset ) ; } public static IOFileFilter makeCVSAware ( final IOFileFilter filter ) { return filter == null ? cvsFilter : and ( filter , cvsFilter ) ; MST[ReturnValsMutator]MSP[] } public static IOFileFilter makeSVNAware ( final IOFileFilter filter ) {
return new SizeFileFilter ( threshold , acceptLarger ) ; } public static IOFileFilter sizeRangeFileFilter ( final long minSizeInclusive , final long maxSizeInclusive ) { final IOFileFilter minimumFilter = new SizeFileFilter ( minSizeInclusive , true ) ; final IOFileFilter maximumFilter = new SizeFileFilter ( maxSizeInclusive + 1L , false ) ; MST[rv.CRCR1Mutator]MSP[]
return new SizeFileFilter ( threshold , acceptLarger ) ; } public static IOFileFilter sizeRangeFileFilter ( final long minSizeInclusive , final long maxSizeInclusive ) { final IOFileFilter minimumFilter = new SizeFileFilter ( minSizeInclusive , true ) ; final IOFileFilter maximumFilter = new SizeFileFilter ( maxSizeInclusive + 1L , false ) ; MST[rv.CRCR5Mutator]MSP[]
return new SizeFileFilter ( threshold , acceptLarger ) ; } public static IOFileFilter sizeRangeFileFilter ( final long minSizeInclusive , final long maxSizeInclusive ) { final IOFileFilter minimumFilter = new SizeFileFilter ( minSizeInclusive , true ) ; final IOFileFilter maximumFilter = new SizeFileFilter ( maxSizeInclusive + 1L , false ) ; MST[ConstructorCallMutator]MSP[]
return new AgeFileFilter ( cutoffDate , acceptOlder ) ; MST[ReturnValsMutator]MSP[] } public static IOFileFilter ageFileFilter ( final File cutoffReference ) { return new AgeFileFilter ( cutoffReference ) ; } public static IOFileFilter ageFileFilter ( final File cutoffReference , final boolean acceptOlder ) {
} final List < IOFileFilter > list = new ArrayList <> ( filters . length ) ; for ( int i = 0 ; i < filters . length ; i ++ ) { if ( filters [ i ] == null ) { MST[rv.UOI1Mutator]MSP[]
public static IOFileFilter trueFileFilter () { return TrueFileFilter . TRUE ; } public static IOFileFilter falseFileFilter () { return FalseFileFilter . FALSE ; MST[NullReturnValsMutator]MSP[] } public static IOFileFilter asFileFilter ( final FileFilter filter ) { return new DelegateFileFilter ( filter ) ; }
return new AgeFileFilter ( cutoffReference , acceptOlder ) ; MST[rv.UOI1Mutator]MSP[] } public static IOFileFilter sizeFileFilter ( final long threshold ) { return new SizeFileFilter ( threshold ) ; } public static IOFileFilter sizeFileFilter ( final long threshold , final boolean acceptLarger ) {
public static IOFileFilter makeFileOnly ( final IOFileFilter filter ) { if ( filter == null ) { return FileFileFilter . FILE ; MST[NullReturnValsMutator]MSP[] } return new AndFileFilter ( FileFileFilter . FILE , filter ) ; }
return new SizeFileFilter ( threshold , acceptLarger ) ; } public static IOFileFilter sizeRangeFileFilter ( final long minSizeInclusive , final long maxSizeInclusive ) { final IOFileFilter minimumFilter = new SizeFileFilter ( minSizeInclusive , true ) ; MST[InlineConstantMutator]MSP[] final IOFileFilter maximumFilter = new SizeFileFilter ( maxSizeInclusive + 1L , false ) ;
return filter == null ? svnFilter : and ( filter , svnFilter ) ; } public static IOFileFilter makeDirectoryOnly ( final IOFileFilter filter ) { if ( filter == null ) { MST[NegateConditionalsMutator]MSP[] return DirectoryFileFilter . DIRECTORY ; } return new AndFileFilter ( DirectoryFileFilter . DIRECTORY , filter ) ; }
if ( files != null ) { for ( final File file : files ) { if ( file == null ) { throw new IllegalArgumentException ( lr_3 ) ; } if ( filter . accept ( file ) ) { MST[rv.ROR3Mutator]MSP[] acceptedFiles . add ( file ) ; } }
} final List < IOFileFilter > list = new ArrayList <> ( filters . length ) ; MST[ConstructorCallMutator]MSP[] for ( int i = 0 ; i < filters . length ; i ++ ) { if ( filters [ i ] == null ) {
return new SizeFileFilter ( threshold , acceptLarger ) ; } public static IOFileFilter sizeRangeFileFilter ( final long minSizeInclusive , final long maxSizeInclusive ) { final IOFileFilter minimumFilter = new SizeFileFilter ( minSizeInclusive , true ) ; final IOFileFilter maximumFilter = new SizeFileFilter ( maxSizeInclusive + 1L , false ) ; MST[rv.UOI4Mutator]MSP[]
return new SizeFileFilter ( threshold , acceptLarger ) ; } public static IOFileFilter sizeRangeFileFilter ( final long minSizeInclusive , final long maxSizeInclusive ) { final IOFileFilter minimumFilter = new SizeFileFilter ( minSizeInclusive , true ) ; final IOFileFilter maximumFilter = new SizeFileFilter ( maxSizeInclusive + 1L , false ) ; MST[rv.UOI2Mutator]MSP[]
return new MagicNumberFileFilter ( magicNumber , offset ) ; } public static IOFileFilter makeCVSAware ( final IOFileFilter filter ) { return filter == null ? cvsFilter : and ( filter , cvsFilter ) ; MST[rv.CRCR6Mutator]MSP[] } public static IOFileFilter makeSVNAware ( final IOFileFilter filter ) {
throw new IllegalArgumentException ( lr_5 + i + lr_6 ) ; } list . add ( filters [ i ] ) ; MST[rv.UOI3Mutator]MSP[] } return list ; } public static IOFileFilter notFileFilter ( final IOFileFilter filter ) { return new NotFileFilter ( filter ) ; }
return new MagicNumberFileFilter ( magicNumber , offset ) ; } public static IOFileFilter makeCVSAware ( final IOFileFilter filter ) { return filter == null ? cvsFilter : and ( filter , cvsFilter ) ; MST[rv.CRCR2Mutator]MSP[] } public static IOFileFilter makeSVNAware ( final IOFileFilter filter ) {
return DirectoryFileFilter . DIRECTORY ; } public static IOFileFilter fileFileFilter () { return FileFileFilter . FILE ; MST[ReturnValsMutator]MSP[] } @Deprecated public static IOFileFilter andFileFilter ( final IOFileFilter filter1 , final IOFileFilter filter2 ) { return new AndFileFilter ( filter1 , filter2 ) ; } @Deprecated
return new SizeFileFilter ( threshold , acceptLarger ) ; } public static IOFileFilter sizeRangeFileFilter ( final long minSizeInclusive , final long maxSizeInclusive ) { final IOFileFilter minimumFilter = new SizeFileFilter ( minSizeInclusive , true ) ; final IOFileFilter maximumFilter = new SizeFileFilter ( maxSizeInclusive + 1L , false ) ; MST[rv.ABSMutator]MSP[]
return new MagicNumberFileFilter ( magicNumber , offset ) ; MST[rv.ABSMutator]MSP[] } public static IOFileFilter makeCVSAware ( final IOFileFilter filter ) { return filter == null ? cvsFilter : and ( filter , cvsFilter ) ; } public static IOFileFilter makeSVNAware ( final IOFileFilter filter ) {
return filter == null ? svnFilter : and ( filter , svnFilter ) ; } public static IOFileFilter makeDirectoryOnly ( final IOFileFilter filter ) { if ( filter == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return DirectoryFileFilter . DIRECTORY ; } return new AndFileFilter ( DirectoryFileFilter . DIRECTORY , filter ) ; }
return filter ( filter , files , new ArrayList < File > () ) ; } public static List < File > filterList ( final IOFileFilter filter , final File ... files ) { final File [] acceptedFiles = filter ( filter , files ) ; MST[NonVoidMethodCallMutator]MSP[]
return new MagicNumberFileFilter ( magicNumber , offset ) ; } public static IOFileFilter makeCVSAware ( final IOFileFilter filter ) { return filter == null ? cvsFilter : and ( filter , cvsFilter ) ; MST[rv.CRCR4Mutator]MSP[] } public static IOFileFilter makeSVNAware ( final IOFileFilter filter ) {
} return acceptedFiles ; } public static IOFileFilter prefixFileFilter ( final String prefix ) { return new PrefixFileFilter ( prefix ) ; } public static IOFileFilter prefixFileFilter ( final String prefix , final IOCase caseSensitivity ) { return new PrefixFileFilter ( prefix , caseSensitivity ) ; MST[ReturnValsMutator]MSP[] }
public static File [] filter ( final IOFileFilter filter , final File ... files ) { if ( filter == null ) { throw new IllegalArgumentException ( lr_1 ) ; } if ( files == null ) { return new File [ 0 ] ; MST[NullReturnValsMutator]MSP[] }
final List < File > acceptedFiles = new ArrayList <> () ; for ( final File file : files ) { if ( file == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] throw new IllegalArgumentException ( lr_2 ) ; } if ( filter . accept ( file ) ) {
return new MagicNumberFileFilter ( magicNumber , offset ) ; MST[rv.ABSMutator]MSP[] } public static IOFileFilter magicNumberFileFilter ( final byte [] magicNumber ) { return new MagicNumberFileFilter ( magicNumber ) ; } public static IOFileFilter magicNumberFileFilter ( final byte [] magicNumber , final long offset ) {
return filter ( filter , files , new ArrayList < File > () ) ; MST[ConstructorCallMutator]MSP[] } public static List < File > filterList ( final IOFileFilter filter , final File ... files ) { final File [] acceptedFiles = filter ( filter , files ) ;
return filter == null ? svnFilter : and ( filter , svnFilter ) ; MST[NullReturnValsMutator]MSP[] } public static IOFileFilter makeDirectoryOnly ( final IOFileFilter filter ) { if ( filter == null ) { return DirectoryFileFilter . DIRECTORY ; } return new AndFileFilter ( DirectoryFileFilter . DIRECTORY , filter ) ; }
} final List < IOFileFilter > list = new ArrayList <> ( filters . length ) ; for ( int i = 0 ; i < filters . length ; i ++ ) { MST[rv.UOI3Mutator]MSP[] if ( filters [ i ] == null ) {
} final List < IOFileFilter > list = new ArrayList <> ( filters . length ) ; for ( int i = 0 ; i < filters . length ; i ++ ) { if ( filters [ i ] == null ) { MST[NegateConditionalsMutator]MSP[]
throw new IllegalArgumentException ( lr_5 + i + lr_6 ) ; MST[experimental.NakedReceiverMutator]MSP[] } list . add ( filters [ i ] ) ; } return list ; } public static IOFileFilter notFileFilter ( final IOFileFilter filter ) { return new NotFileFilter ( filter ) ; }
return new HashSet <> ( Arrays . asList ( acceptedFiles ) ) ; } public static Set < File > filterSet ( final IOFileFilter filter , final Iterable < File > files ) { return filter ( filter , files , new HashSet < File > () ) ; MST[EmptyObjectReturnValsMutator]MSP[] }
if ( files != null ) { for ( final File file : files ) { if ( file == null ) { throw new IllegalArgumentException ( lr_3 ) ; } if ( filter . accept ( file ) ) { MST[NegateConditionalsMutator]MSP[] acceptedFiles . add ( file ) ; } }
return filter == null ? svnFilter : and ( filter , svnFilter ) ; MST[rv.CRCR2Mutator]MSP[] } public static IOFileFilter makeDirectoryOnly ( final IOFileFilter filter ) { if ( filter == null ) { return DirectoryFileFilter . DIRECTORY ; } return new AndFileFilter ( DirectoryFileFilter . DIRECTORY , filter ) ; }
return new AgeFileFilter ( cutoffReference , acceptOlder ) ; } public static IOFileFilter sizeFileFilter ( final long threshold ) { return new SizeFileFilter ( threshold ) ; MST[rv.UOI1Mutator]MSP[] } public static IOFileFilter sizeFileFilter ( final long threshold , final boolean acceptLarger ) {
public static File [] filter ( final IOFileFilter filter , final File ... files ) { if ( filter == null ) { MST[rv.ROR5Mutator]MSP[] throw new IllegalArgumentException ( lr_1 ) ; } if ( files == null ) { return new File [ 0 ] ; }
throw new IllegalArgumentException ( lr_5 + i + lr_6 ) ; MST[rv.UOI4Mutator]MSP[] } list . add ( filters [ i ] ) ; } return list ; } public static IOFileFilter notFileFilter ( final IOFileFilter filter ) { return new NotFileFilter ( filter ) ; }
final List < File > acceptedFiles = new ArrayList <> () ; for ( final File file : files ) { if ( file == null ) { throw new IllegalArgumentException ( lr_2 ) ; MST[ConstructorCallMutator]MSP[] } if ( filter . accept ( file ) ) {
} final List < IOFileFilter > list = new ArrayList <> ( filters . length ) ; for ( int i = 0 ; i < filters . length ; i ++ ) { MST[InlineConstantMutator]MSP[] if ( filters [ i ] == null ) {
return new MagicNumberFileFilter ( magicNumber , offset ) ; MST[rv.UOI2Mutator]MSP[] } public static IOFileFilter makeCVSAware ( final IOFileFilter filter ) { return filter == null ? cvsFilter : and ( filter , cvsFilter ) ; } public static IOFileFilter makeSVNAware ( final IOFileFilter filter ) {
return filter == null ? svnFilter : and ( filter , svnFilter ) ; } public static IOFileFilter makeDirectoryOnly ( final IOFileFilter filter ) { if ( filter == null ) { return DirectoryFileFilter . DIRECTORY ; MST[NullReturnValsMutator]MSP[] } return new AndFileFilter ( DirectoryFileFilter . DIRECTORY , filter ) ; }
public static IOFileFilter makeFileOnly ( final IOFileFilter filter ) { if ( filter == null ) { MST[NegateConditionalsMutator]MSP[] return FileFileFilter . FILE ; } return new AndFileFilter ( FileFileFilter . FILE , filter ) ; }
public static IOFileFilter trueFileFilter () { return TrueFileFilter . TRUE ; } public static IOFileFilter falseFileFilter () { return FalseFileFilter . FALSE ; } public static IOFileFilter asFileFilter ( final FileFilter filter ) { return new DelegateFileFilter ( filter ) ; MST[ReturnValsMutator]MSP[] }
return filter == null ? svnFilter : and ( filter , svnFilter ) ; MST[InlineConstantMutator]MSP[] } public static IOFileFilter makeDirectoryOnly ( final IOFileFilter filter ) { if ( filter == null ) { return DirectoryFileFilter . DIRECTORY ; } return new AndFileFilter ( DirectoryFileFilter . DIRECTORY , filter ) ; }
private static < T extends Collection < File > > T filter ( final IOFileFilter filter , final Iterable < File > files , final T acceptedFiles ) { if ( filter == null ) { throw new IllegalArgumentException ( lr_1 ) ; MST[ConstructorCallMutator]MSP[] }
return filter == null ? svnFilter : and ( filter , svnFilter ) ; } public static IOFileFilter makeDirectoryOnly ( final IOFileFilter filter ) { if ( filter == null ) { return DirectoryFileFilter . DIRECTORY ; MST[ReturnValsMutator]MSP[] } return new AndFileFilter ( DirectoryFileFilter . DIRECTORY , filter ) ; }
return new MagicNumberFileFilter ( magicNumber , offset ) ; MST[rv.UOI3Mutator]MSP[] } public static IOFileFilter magicNumberFileFilter ( final byte [] magicNumber ) { return new MagicNumberFileFilter ( magicNumber ) ; } public static IOFileFilter magicNumberFileFilter ( final byte [] magicNumber , final long offset ) {
if ( files != null ) { MST[NegateConditionalsMutator]MSP[] for ( final File file : files ) { if ( file == null ) { throw new IllegalArgumentException ( lr_3 ) ; } if ( filter . accept ( file ) ) { acceptedFiles . add ( file ) ; } }
return new AgeFileFilter ( cutoff , acceptOlder ) ; MST[rv.ABSMutator]MSP[] } public static IOFileFilter ageFileFilter ( final Date cutoffDate ) { return new AgeFileFilter ( cutoffDate ) ; } public static IOFileFilter ageFileFilter ( final Date cutoffDate , final boolean acceptOlder ) {
return new SizeFileFilter ( threshold , acceptLarger ) ; } public static IOFileFilter sizeRangeFileFilter ( final long minSizeInclusive , final long maxSizeInclusive ) { final IOFileFilter minimumFilter = new SizeFileFilter ( minSizeInclusive , true ) ; MST[rv.CRCR2Mutator]MSP[] final IOFileFilter maximumFilter = new SizeFileFilter ( maxSizeInclusive + 1L , false ) ;
public static IOFileFilter suffixFileFilter ( final String suffix ) { return new SuffixFileFilter ( suffix ) ; } public static IOFileFilter suffixFileFilter ( final String suffix , final IOCase caseSensitivity ) { return new SuffixFileFilter ( suffix , caseSensitivity ) ; MST[NullReturnValsMutator]MSP[] }
acceptedFiles . add ( file ) ; } } return acceptedFiles . toArray ( new File [ acceptedFiles . size () ] ) ; MST[NonVoidMethodCallMutator]MSP[] } public static File [] filter ( final IOFileFilter filter , final Iterable < File > files ) {
public static IOFileFilter or ( final IOFileFilter ... filters ) { return new OrFileFilter ( toList ( filters ) ) ; } public static List < IOFileFilter > toList ( final IOFileFilter ... filters ) { if ( filters == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] throw new IllegalArgumentException ( lr_4 ) ;
public static File [] filter ( final IOFileFilter filter , final File ... files ) { if ( filter == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] throw new IllegalArgumentException ( lr_1 ) ; } if ( files == null ) { return new File [ 0 ] ; }
} return acceptedFiles ; } public static IOFileFilter prefixFileFilter ( final String prefix ) { return new PrefixFileFilter ( prefix ) ; MST[ReturnValsMutator]MSP[] } public static IOFileFilter prefixFileFilter ( final String prefix , final IOCase caseSensitivity ) { return new PrefixFileFilter ( prefix , caseSensitivity ) ; }
public static IOFileFilter suffixFileFilter ( final String suffix ) { return new SuffixFileFilter ( suffix ) ; MST[NullReturnValsMutator]MSP[] } public static IOFileFilter suffixFileFilter ( final String suffix , final IOCase caseSensitivity ) { return new SuffixFileFilter ( suffix , caseSensitivity ) ; }
return new SizeFileFilter ( threshold , acceptLarger ) ; } public static IOFileFilter sizeRangeFileFilter ( final long minSizeInclusive , final long maxSizeInclusive ) { final IOFileFilter minimumFilter = new SizeFileFilter ( minSizeInclusive , true ) ; final IOFileFilter maximumFilter = new SizeFileFilter ( maxSizeInclusive + 1L , false ) ; MST[rv.CRCR5Mutator]MSP[]
return new SizeFileFilter ( threshold , acceptLarger ) ; } public static IOFileFilter sizeRangeFileFilter ( final long minSizeInclusive , final long maxSizeInclusive ) { final IOFileFilter minimumFilter = new SizeFileFilter ( minSizeInclusive , true ) ; final IOFileFilter maximumFilter = new SizeFileFilter ( maxSizeInclusive + 1L , false ) ; MST[rv.CRCR4Mutator]MSP[]
} final List < IOFileFilter > list = new ArrayList <> ( filters . length ) ; for ( int i = 0 ; i < filters . length ; i ++ ) { MST[rv.ABSMutator]MSP[] if ( filters [ i ] == null ) {
return new AgeFileFilter ( cutoffDate , acceptOlder ) ; MST[rv.UOI3Mutator]MSP[] } public static IOFileFilter ageFileFilter ( final File cutoffReference ) { return new AgeFileFilter ( cutoffReference ) ; } public static IOFileFilter ageFileFilter ( final File cutoffReference , final boolean acceptOlder ) {
return new SizeFileFilter ( threshold , acceptLarger ) ; MST[ConstructorCallMutator]MSP[] } public static IOFileFilter sizeRangeFileFilter ( final long minSizeInclusive , final long maxSizeInclusive ) { final IOFileFilter minimumFilter = new SizeFileFilter ( minSizeInclusive , true ) ; final IOFileFilter maximumFilter = new SizeFileFilter ( maxSizeInclusive + 1L , false ) ;
return new AgeFileFilter ( cutoffReference , acceptOlder ) ; } public static IOFileFilter sizeFileFilter ( final long threshold ) { return new SizeFileFilter ( threshold ) ; MST[rv.UOI2Mutator]MSP[] } public static IOFileFilter sizeFileFilter ( final long threshold , final boolean acceptLarger ) {
return filter == null ? svnFilter : and ( filter , svnFilter ) ; MST[rv.CRCR3Mutator]MSP[] } public static IOFileFilter makeDirectoryOnly ( final IOFileFilter filter ) { if ( filter == null ) { return DirectoryFileFilter . DIRECTORY ; } return new AndFileFilter ( DirectoryFileFilter . DIRECTORY , filter ) ; }
return new AgeFileFilter ( cutoff , acceptOlder ) ; MST[rv.UOI4Mutator]MSP[] } public static IOFileFilter ageFileFilter ( final Date cutoffDate ) { return new AgeFileFilter ( cutoffDate ) ; } public static IOFileFilter ageFileFilter ( final Date cutoffDate , final boolean acceptOlder ) {
} final List < IOFileFilter > list = new ArrayList <> ( filters . length ) ; for ( int i = 0 ; i < filters . length ; i ++ ) { if ( filters [ i ] == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
return new MagicNumberFileFilter ( magicNumber , offset ) ; MST[rv.UOI3Mutator]MSP[] } public static IOFileFilter makeCVSAware ( final IOFileFilter filter ) { return filter == null ? cvsFilter : and ( filter , cvsFilter ) ; } public static IOFileFilter makeSVNAware ( final IOFileFilter filter ) {
public static File [] filter ( final IOFileFilter filter , final File ... files ) { if ( filter == null ) { throw new IllegalArgumentException ( lr_1 ) ; } if ( files == null ) { MST[NegateConditionalsMutator]MSP[] return new File [ 0 ] ; }
return new AndFileFilter ( minimumFilter , maximumFilter ) ; } public static IOFileFilter magicNumberFileFilter ( final String magicNumber ) { return new MagicNumberFileFilter ( magicNumber ) ; MST[NullReturnValsMutator]MSP[] } public static IOFileFilter magicNumberFileFilter ( final String magicNumber , final long offset ) {
throw new IllegalArgumentException ( lr_5 + i + lr_6 ) ; } list . add ( filters [ i ] ) ; } return list ; } public static IOFileFilter notFileFilter ( final IOFileFilter filter ) { return new NotFileFilter ( filter ) ; MST[ConstructorCallMutator]MSP[] }
return new MagicNumberFileFilter ( magicNumber , offset ) ; } public static IOFileFilter makeCVSAware ( final IOFileFilter filter ) { return filter == null ? cvsFilter : and ( filter , cvsFilter ) ; MST[InlineConstantMutator]MSP[] } public static IOFileFilter makeSVNAware ( final IOFileFilter filter ) {
return new AgeFileFilter ( cutoff , acceptOlder ) ; MST[NullReturnValsMutator]MSP[] } public static IOFileFilter ageFileFilter ( final Date cutoffDate ) { return new AgeFileFilter ( cutoffDate ) ; } public static IOFileFilter ageFileFilter ( final Date cutoffDate , final boolean acceptOlder ) {
public static IOFileFilter makeFileOnly ( final IOFileFilter filter ) { if ( filter == null ) { MST[rv.ROR5Mutator]MSP[] return FileFileFilter . FILE ; } return new AndFileFilter ( FileFileFilter . FILE , filter ) ; }
public static IOFileFilter nameFileFilter ( final String name ) { return new NameFileFilter ( name ) ; } public static IOFileFilter nameFileFilter ( final String name , final IOCase caseSensitivity ) { return new NameFileFilter ( name , caseSensitivity ) ; MST[ReturnValsMutator]MSP[] } public static IOFileFilter directoryFileFilter () {
public static IOFileFilter or ( final IOFileFilter ... filters ) { return new OrFileFilter ( toList ( filters ) ) ; } public static List < IOFileFilter > toList ( final IOFileFilter ... filters ) { if ( filters == null ) { MST[NegateConditionalsMutator]MSP[] throw new IllegalArgumentException ( lr_4 ) ;
public static IOFileFilter suffixFileFilter ( final String suffix ) { return new SuffixFileFilter ( suffix ) ; } public static IOFileFilter suffixFileFilter ( final String suffix , final IOCase caseSensitivity ) { return new SuffixFileFilter ( suffix , caseSensitivity ) ; MST[ReturnValsMutator]MSP[] }
private static < T extends Collection < File > > T filter ( final IOFileFilter filter , final Iterable < File > files , final T acceptedFiles ) { if ( filter == null ) { MST[rv.ROR5Mutator]MSP[] throw new IllegalArgumentException ( lr_1 ) ; }
public static IOFileFilter nameFileFilter ( final String name ) { return new NameFileFilter ( name ) ; MST[ReturnValsMutator]MSP[] } public static IOFileFilter nameFileFilter ( final String name , final IOCase caseSensitivity ) { return new NameFileFilter ( name , caseSensitivity ) ; } public static IOFileFilter directoryFileFilter () {
return new MagicNumberFileFilter ( magicNumber , offset ) ; } public static IOFileFilter makeCVSAware ( final IOFileFilter filter ) { return filter == null ? cvsFilter : and ( filter , cvsFilter ) ; MST[rv.CRCR3Mutator]MSP[] } public static IOFileFilter makeSVNAware ( final IOFileFilter filter ) {
if ( files != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] for ( final File file : files ) { if ( file == null ) { throw new IllegalArgumentException ( lr_3 ) ; } if ( filter . accept ( file ) ) { acceptedFiles . add ( file ) ; } }
return new AgeFileFilter ( cutoff , acceptOlder ) ; MST[rv.ABSMutator]MSP[] } public static IOFileFilter ageFileFilter ( final Date cutoffDate ) { return new AgeFileFilter ( cutoffDate ) ; } public static IOFileFilter ageFileFilter ( final Date cutoffDate , final boolean acceptOlder ) {
final List < File > acceptedFiles = new ArrayList <> () ; for ( final File file : files ) { if ( file == null ) { MST[rv.ROR5Mutator]MSP[] throw new IllegalArgumentException ( lr_2 ) ; } if ( filter . accept ( file ) ) {
return new MagicNumberFileFilter ( magicNumber , offset ) ; } public static IOFileFilter magicNumberFileFilter ( final byte [] magicNumber ) { return new MagicNumberFileFilter ( magicNumber ) ; MST[ConstructorCallMutator]MSP[] } public static IOFileFilter magicNumberFileFilter ( final byte [] magicNumber , final long offset ) {
final List < File > acceptedFiles = new ArrayList <> () ; for ( final File file : files ) { MST[rv.UOI1Mutator]MSP[] if ( file == null ) { throw new IllegalArgumentException ( lr_2 ) ; } if ( filter . accept ( file ) ) {
} final List < IOFileFilter > list = new ArrayList <> ( filters . length ) ; for ( int i = 0 ; i < filters . length ; i ++ ) { MST[rv.UOI4Mutator]MSP[] if ( filters [ i ] == null ) {
public static File [] filter ( final IOFileFilter filter , final File ... files ) { if ( filter == null ) { throw new IllegalArgumentException ( lr_1 ) ; MST[ConstructorCallMutator]MSP[] } if ( files == null ) { return new File [ 0 ] ; }
throw new IllegalArgumentException ( lr_5 + i + lr_6 ) ; MST[experimental.NakedReceiverMutator]MSP[] } list . add ( filters [ i ] ) ; } return list ; } public static IOFileFilter notFileFilter ( final IOFileFilter filter ) { return new NotFileFilter ( filter ) ; }
final List < File > acceptedFiles = new ArrayList <> () ; for ( final File file : files ) { if ( file == null ) { throw new IllegalArgumentException ( lr_2 ) ; } if ( filter . accept ( file ) ) { MST[NegateConditionalsMutator]MSP[]
public static IOFileFilter suffixFileFilter ( final String suffix ) { return new SuffixFileFilter ( suffix ) ; MST[ReturnValsMutator]MSP[] } public static IOFileFilter suffixFileFilter ( final String suffix , final IOCase caseSensitivity ) { return new SuffixFileFilter ( suffix , caseSensitivity ) ; }
return new AndFileFilter ( minimumFilter , maximumFilter ) ; } public static IOFileFilter magicNumberFileFilter ( final String magicNumber ) { return new MagicNumberFileFilter ( magicNumber ) ; MST[ReturnValsMutator]MSP[] } public static IOFileFilter magicNumberFileFilter ( final String magicNumber , final long offset ) {
return Arrays . asList ( acceptedFiles ) ; MST[ReturnValsMutator]MSP[] } public static Set < File > filterSet ( final IOFileFilter filter , final File ... files ) { final File [] acceptedFiles = filter ( filter , files ) ;
return filter == null ? svnFilter : and ( filter , svnFilter ) ; } public static IOFileFilter makeDirectoryOnly ( final IOFileFilter filter ) { if ( filter == null ) { MST[rv.ROR5Mutator]MSP[] return DirectoryFileFilter . DIRECTORY ; } return new AndFileFilter ( DirectoryFileFilter . DIRECTORY , filter ) ; }
return new SizeFileFilter ( threshold , acceptLarger ) ; } public static IOFileFilter sizeRangeFileFilter ( final long minSizeInclusive , final long maxSizeInclusive ) { final IOFileFilter minimumFilter = new SizeFileFilter ( minSizeInclusive , true ) ; final IOFileFilter maximumFilter = new SizeFileFilter ( maxSizeInclusive + 1L , false ) ; MST[rv.AOR3Mutator]MSP[]
final List < File > acceptedFiles = new ArrayList <> () ; for ( final File file : files ) { if ( file == null ) { throw new IllegalArgumentException ( lr_2 ) ; } if ( filter . accept ( file ) ) { MST[rv.ROR4Mutator]MSP[]
if ( files != null ) { for ( final File file : files ) { if ( file == null ) { MST[NegateConditionalsMutator]MSP[] throw new IllegalArgumentException ( lr_3 ) ; } if ( filter . accept ( file ) ) { acceptedFiles . add ( file ) ; } }
if ( files != null ) { for ( final File file : files ) { if ( file == null ) { throw new IllegalArgumentException ( lr_3 ) ; } if ( filter . accept ( file ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] acceptedFiles . add ( file ) ; } }
return new AgeFileFilter ( cutoff , acceptOlder ) ; MST[rv.UOI4Mutator]MSP[] } public static IOFileFilter ageFileFilter ( final Date cutoffDate ) { return new AgeFileFilter ( cutoffDate ) ; } public static IOFileFilter ageFileFilter ( final Date cutoffDate , final boolean acceptOlder ) {
return filter == null ? svnFilter : and ( filter , svnFilter ) ; MST[rv.CRCR5Mutator]MSP[] } public static IOFileFilter makeDirectoryOnly ( final IOFileFilter filter ) { if ( filter == null ) { return DirectoryFileFilter . DIRECTORY ; } return new AndFileFilter ( DirectoryFileFilter . DIRECTORY , filter ) ; }
return new SizeFileFilter ( threshold , acceptLarger ) ; } public static IOFileFilter sizeRangeFileFilter ( final long minSizeInclusive , final long maxSizeInclusive ) { final IOFileFilter minimumFilter = new SizeFileFilter ( minSizeInclusive , true ) ; final IOFileFilter maximumFilter = new SizeFileFilter ( maxSizeInclusive + 1L , false ) ; MST[rv.UOI3Mutator]MSP[]
return Arrays . asList ( acceptedFiles ) ; } public static Set < File > filterSet ( final IOFileFilter filter , final File ... files ) { final File [] acceptedFiles = filter ( filter , files ) ; MST[NonVoidMethodCallMutator]MSP[]
public static IOFileFilter trueFileFilter () { return TrueFileFilter . TRUE ; } public static IOFileFilter falseFileFilter () { return FalseFileFilter . FALSE ; MST[ReturnValsMutator]MSP[] } public static IOFileFilter asFileFilter ( final FileFilter filter ) { return new DelegateFileFilter ( filter ) ; }
return new AgeFileFilter ( cutoff , acceptOlder ) ; MST[ReturnValsMutator]MSP[] } public static IOFileFilter ageFileFilter ( final Date cutoffDate ) { return new AgeFileFilter ( cutoffDate ) ; } public static IOFileFilter ageFileFilter ( final Date cutoffDate , final boolean acceptOlder ) {
return new HashSet <> ( Arrays . asList ( acceptedFiles ) ) ; } public static Set < File > filterSet ( final IOFileFilter filter , final Iterable < File > files ) { return filter ( filter , files , new HashSet < File > () ) ; MST[NonVoidMethodCallMutator]MSP[] }
return new MagicNumberFileFilter ( magicNumber , offset ) ; } public static IOFileFilter makeCVSAware ( final IOFileFilter filter ) { return filter == null ? cvsFilter : and ( filter , cvsFilter ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] } public static IOFileFilter makeSVNAware ( final IOFileFilter filter ) {
return new AgeFileFilter ( cutoffReference , acceptOlder ) ; MST[ConstructorCallMutator]MSP[] } public static IOFileFilter sizeFileFilter ( final long threshold ) { return new SizeFileFilter ( threshold ) ; } public static IOFileFilter sizeFileFilter ( final long threshold , final boolean acceptLarger ) {
return new MagicNumberFileFilter ( magicNumber , offset ) ; } public static IOFileFilter makeCVSAware ( final IOFileFilter filter ) { return filter == null ? cvsFilter : and ( filter , cvsFilter ) ; MST[rv.CRCR1Mutator]MSP[] } public static IOFileFilter makeSVNAware ( final IOFileFilter filter ) {
final List < File > acceptedFiles = filterList ( filter , files ) ; return acceptedFiles . toArray ( new File [ acceptedFiles . size () ] ) ; MST[NonVoidMethodCallMutator]MSP[] } public static List < File > filterList ( final IOFileFilter filter , final Iterable < File > files ) {
acceptedFiles . add ( file ) ; } } return acceptedFiles . toArray ( new File [ acceptedFiles . size () ] ) ; MST[NonVoidMethodCallMutator]MSP[] } public static File [] filter ( final IOFileFilter filter , final Iterable < File > files ) {
if ( files != null ) { for ( final File file : files ) { if ( file == null ) { throw new IllegalArgumentException ( lr_3 ) ; } if ( filter . accept ( file ) ) { acceptedFiles . add ( file ) ; MST[NonVoidMethodCallMutator]MSP[] } }
} final List < IOFileFilter > list = new ArrayList <> ( filters . length ) ; for ( int i = 0 ; i < filters . length ; i ++ ) { if ( filters [ i ] == null ) { MST[rv.ABSMutator]MSP[]
if ( files != null ) { for ( final File file : files ) { if ( file == null ) { throw new IllegalArgumentException ( lr_3 ) ; MST[ConstructorCallMutator]MSP[] } if ( filter . accept ( file ) ) { acceptedFiles . add ( file ) ; } }
return new MagicNumberFileFilter ( magicNumber , offset ) ; } public static IOFileFilter makeCVSAware ( final IOFileFilter filter ) { return filter == null ? cvsFilter : and ( filter , cvsFilter ) ; MST[NegateConditionalsMutator]MSP[] } public static IOFileFilter makeSVNAware ( final IOFileFilter filter ) {
return DirectoryFileFilter . DIRECTORY ; MST[ReturnValsMutator]MSP[] } public static IOFileFilter fileFileFilter () { return FileFileFilter . FILE ; } @Deprecated public static IOFileFilter andFileFilter ( final IOFileFilter filter1 , final IOFileFilter filter2 ) { return new AndFileFilter ( filter1 , filter2 ) ; } @Deprecated
return new SizeFileFilter ( threshold , acceptLarger ) ; } public static IOFileFilter sizeRangeFileFilter ( final long minSizeInclusive , final long maxSizeInclusive ) { final IOFileFilter minimumFilter = new SizeFileFilter ( minSizeInclusive , true ) ; final IOFileFilter maximumFilter = new SizeFileFilter ( maxSizeInclusive + 1L , false ) ; MST[rv.AOR4Mutator]MSP[]
final List < File > acceptedFiles = new ArrayList <> () ; for ( final File file : files ) { if ( file == null ) { throw new IllegalArgumentException ( lr_2 ) ; } if ( filter . accept ( file ) ) { MST[rv.ROR3Mutator]MSP[]
return new SizeFileFilter ( threshold , acceptLarger ) ; } public static IOFileFilter sizeRangeFileFilter ( final long minSizeInclusive , final long maxSizeInclusive ) { final IOFileFilter minimumFilter = new SizeFileFilter ( minSizeInclusive , true ) ; final IOFileFilter maximumFilter = new SizeFileFilter ( maxSizeInclusive + 1L , false ) ; MST[MathMutator]MSP[]
throw new IllegalArgumentException ( lr_5 + i + lr_6 ) ; MST[rv.UOI1Mutator]MSP[] } list . add ( filters [ i ] ) ; } return list ; } public static IOFileFilter notFileFilter ( final IOFileFilter filter ) { return new NotFileFilter ( filter ) ; }
return new SizeFileFilter ( threshold , acceptLarger ) ; MST[rv.UOI4Mutator]MSP[] } public static IOFileFilter sizeRangeFileFilter ( final long minSizeInclusive , final long maxSizeInclusive ) { final IOFileFilter minimumFilter = new SizeFileFilter ( minSizeInclusive , true ) ; final IOFileFilter maximumFilter = new SizeFileFilter ( maxSizeInclusive + 1L , false ) ;
return new AgeFileFilter ( cutoffDate , acceptOlder ) ; } public static IOFileFilter ageFileFilter ( final File cutoffReference ) { return new AgeFileFilter ( cutoffReference ) ; MST[ConstructorCallMutator]MSP[] } public static IOFileFilter ageFileFilter ( final File cutoffReference , final boolean acceptOlder ) {
public static IOFileFilter asFileFilter ( final FilenameFilter filter ) { return new DelegateFileFilter ( filter ) ; } public static IOFileFilter ageFileFilter ( final long cutoff ) { return new AgeFileFilter ( cutoff ) ; MST[rv.UOI1Mutator]MSP[] } public static IOFileFilter ageFileFilter ( final long cutoff , final boolean acceptOlder ) {
return Arrays . asList ( acceptedFiles ) ; MST[EmptyObjectReturnValsMutator]MSP[] } public static Set < File > filterSet ( final IOFileFilter filter , final File ... files ) { final File [] acceptedFiles = filter ( filter , files ) ;
return filter ( filter , files , new ArrayList < File > () ) ; } public static List < File > filterList ( final IOFileFilter filter , final File ... files ) { final File [] acceptedFiles = filter ( filter , files ) ; MST[ArgumentPropagationMutator]MSP[]
public static IOFileFilter or ( final IOFileFilter ... filters ) { return new OrFileFilter ( toList ( filters ) ) ; MST[NullReturnValsMutator]MSP[] } public static List < IOFileFilter > toList ( final IOFileFilter ... filters ) { if ( filters == null ) { throw new IllegalArgumentException ( lr_4 ) ;
final List < File > acceptedFiles = new ArrayList <> () ; for ( final File file : files ) { MST[rv.UOI4Mutator]MSP[] if ( file == null ) { throw new IllegalArgumentException ( lr_2 ) ; } if ( filter . accept ( file ) ) {
return new HashSet <> ( Arrays . asList ( acceptedFiles ) ) ; MST[NonVoidMethodCallMutator]MSP[] } public static Set < File > filterSet ( final IOFileFilter filter , final Iterable < File > files ) { return filter ( filter , files , new HashSet < File > () ) ; }
public static IOFileFilter orFileFilter ( final IOFileFilter filter1 , final IOFileFilter filter2 ) { return new OrFileFilter ( filter1 , filter2 ) ; } public static IOFileFilter and ( final IOFileFilter ... filters ) { return new AndFileFilter ( toList ( filters ) ) ; MST[ConstructorCallMutator]MSP[] }
public static IOFileFilter asFileFilter ( final FilenameFilter filter ) { return new DelegateFileFilter ( filter ) ; MST[ReturnValsMutator]MSP[] } public static IOFileFilter ageFileFilter ( final long cutoff ) { return new AgeFileFilter ( cutoff ) ; } public static IOFileFilter ageFileFilter ( final long cutoff , final boolean acceptOlder ) {
return new AgeFileFilter ( cutoffReference , acceptOlder ) ; MST[NullReturnValsMutator]MSP[] } public static IOFileFilter sizeFileFilter ( final long threshold ) { return new SizeFileFilter ( threshold ) ; } public static IOFileFilter sizeFileFilter ( final long threshold , final boolean acceptLarger ) {
return new MagicNumberFileFilter ( magicNumber , offset ) ; } public static IOFileFilter makeCVSAware ( final IOFileFilter filter ) { return filter == null ? cvsFilter : and ( filter , cvsFilter ) ; MST[NullReturnValsMutator]MSP[] } public static IOFileFilter makeSVNAware ( final IOFileFilter filter ) {
return new HashSet <> ( Arrays . asList ( acceptedFiles ) ) ; MST[ConstructorCallMutator]MSP[] } public static Set < File > filterSet ( final IOFileFilter filter , final Iterable < File > files ) { return filter ( filter , files , new HashSet < File > () ) ; }
private static < T extends Collection < File > > T filter ( final IOFileFilter filter , final Iterable < File > files , final T acceptedFiles ) { if ( filter == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] throw new IllegalArgumentException ( lr_1 ) ; }
return new MagicNumberFileFilter ( magicNumber , offset ) ; } public static IOFileFilter makeCVSAware ( final IOFileFilter filter ) { return filter == null ? cvsFilter : and ( filter , cvsFilter ) ; MST[rv.ROR5Mutator]MSP[] } public static IOFileFilter makeSVNAware ( final IOFileFilter filter ) {
return new SizeFileFilter ( threshold , acceptLarger ) ; } public static IOFileFilter sizeRangeFileFilter ( final long minSizeInclusive , final long maxSizeInclusive ) { final IOFileFilter minimumFilter = new SizeFileFilter ( minSizeInclusive , true ) ; MST[rv.UOI1Mutator]MSP[] final IOFileFilter maximumFilter = new SizeFileFilter ( maxSizeInclusive + 1L , false ) ;
final List < File > acceptedFiles = new ArrayList <> () ; for ( final File file : files ) { if ( file == null ) { throw new IllegalArgumentException ( lr_2 ) ; } if ( filter . accept ( file ) ) { MST[NonVoidMethodCallMutator]MSP[]
throw new IllegalArgumentException ( lr_5 + i + lr_6 ) ; } list . add ( filters [ i ] ) ; MST[rv.UOI4Mutator]MSP[] } return list ; } public static IOFileFilter notFileFilter ( final IOFileFilter filter ) { return new NotFileFilter ( filter ) ; }
return filter == null ? svnFilter : and ( filter , svnFilter ) ; MST[InlineConstantMutator]MSP[] } public static IOFileFilter makeDirectoryOnly ( final IOFileFilter filter ) { if ( filter == null ) { return DirectoryFileFilter . DIRECTORY ; } return new AndFileFilter ( DirectoryFileFilter . DIRECTORY , filter ) ; }
return Arrays . asList ( acceptedFiles ) ; MST[NonVoidMethodCallMutator]MSP[] } public static Set < File > filterSet ( final IOFileFilter filter , final File ... files ) { final File [] acceptedFiles = filter ( filter , files ) ;
} final List < IOFileFilter > list = new ArrayList <> ( filters . length ) ; for ( int i = 0 ; i < filters . length ; i ++ ) { MST[rv.CRCR3Mutator]MSP[] if ( filters [ i ] == null ) {
throw new IllegalArgumentException ( lr_5 + i + lr_6 ) ; MST[NonVoidMethodCallMutator]MSP[] } list . add ( filters [ i ] ) ; } return list ; } public static IOFileFilter notFileFilter ( final IOFileFilter filter ) { return new NotFileFilter ( filter ) ; }
final List < File > acceptedFiles = filterList ( filter , files ) ; return acceptedFiles . toArray ( new File [ acceptedFiles . size () ] ) ; MST[NonVoidMethodCallMutator]MSP[] } public static List < File > filterList ( final IOFileFilter filter , final Iterable < File > files ) {
final List < File > acceptedFiles = new ArrayList <> () ; for ( final File file : files ) { MST[rv.UOI4Mutator]MSP[] if ( file == null ) { throw new IllegalArgumentException ( lr_2 ) ; } if ( filter . accept ( file ) ) {
} return acceptedFiles ; } public static IOFileFilter prefixFileFilter ( final String prefix ) { return new PrefixFileFilter ( prefix ) ; } public static IOFileFilter prefixFileFilter ( final String prefix , final IOCase caseSensitivity ) { return new PrefixFileFilter ( prefix , caseSensitivity ) ; MST[NullReturnValsMutator]MSP[] }
public static IOFileFilter suffixFileFilter ( final String suffix ) { return new SuffixFileFilter ( suffix ) ; MST[ConstructorCallMutator]MSP[] } public static IOFileFilter suffixFileFilter ( final String suffix , final IOCase caseSensitivity ) { return new SuffixFileFilter ( suffix , caseSensitivity ) ; }
return new SizeFileFilter ( threshold , acceptLarger ) ; } public static IOFileFilter sizeRangeFileFilter ( final long minSizeInclusive , final long maxSizeInclusive ) { final IOFileFilter minimumFilter = new SizeFileFilter ( minSizeInclusive , true ) ; MST[rv.CRCR6Mutator]MSP[] final IOFileFilter maximumFilter = new SizeFileFilter ( maxSizeInclusive + 1L , false ) ;
return new AndFileFilter ( minimumFilter , maximumFilter ) ; } public static IOFileFilter magicNumberFileFilter ( final String magicNumber ) { return new MagicNumberFileFilter ( magicNumber ) ; MST[ConstructorCallMutator]MSP[] } public static IOFileFilter magicNumberFileFilter ( final String magicNumber , final long offset ) {
public static IOFileFilter asFileFilter ( final FilenameFilter filter ) { return new DelegateFileFilter ( filter ) ; MST[NullReturnValsMutator]MSP[] } public static IOFileFilter ageFileFilter ( final long cutoff ) { return new AgeFileFilter ( cutoff ) ; } public static IOFileFilter ageFileFilter ( final long cutoff , final boolean acceptOlder ) {
return new MagicNumberFileFilter ( magicNumber , offset ) ; MST[rv.UOI2Mutator]MSP[] } public static IOFileFilter magicNumberFileFilter ( final byte [] magicNumber ) { return new MagicNumberFileFilter ( magicNumber ) ; } public static IOFileFilter magicNumberFileFilter ( final byte [] magicNumber , final long offset ) {
return new AgeFileFilter ( cutoffReference , acceptOlder ) ; MST[ReturnValsMutator]MSP[] } public static IOFileFilter sizeFileFilter ( final long threshold ) { return new SizeFileFilter ( threshold ) ; } public static IOFileFilter sizeFileFilter ( final long threshold , final boolean acceptLarger ) {
return new SizeFileFilter ( threshold , acceptLarger ) ; } public static IOFileFilter sizeRangeFileFilter ( final long minSizeInclusive , final long maxSizeInclusive ) { final IOFileFilter minimumFilter = new SizeFileFilter ( minSizeInclusive , true ) ; final IOFileFilter maximumFilter = new SizeFileFilter ( maxSizeInclusive + 1L , false ) ; MST[rv.AOD2Mutator]MSP[]
return new SizeFileFilter ( threshold , acceptLarger ) ; MST[NullReturnValsMutator]MSP[] } public static IOFileFilter sizeRangeFileFilter ( final long minSizeInclusive , final long maxSizeInclusive ) { final IOFileFilter minimumFilter = new SizeFileFilter ( minSizeInclusive , true ) ; final IOFileFilter maximumFilter = new SizeFileFilter ( maxSizeInclusive + 1L , false ) ;
return DirectoryFileFilter . DIRECTORY ; } public static IOFileFilter fileFileFilter () { return FileFileFilter . FILE ; MST[NullReturnValsMutator]MSP[] } @Deprecated public static IOFileFilter andFileFilter ( final IOFileFilter filter1 , final IOFileFilter filter2 ) { return new AndFileFilter ( filter1 , filter2 ) ; } @Deprecated
return new AgeFileFilter ( cutoff , acceptOlder ) ; MST[rv.UOI2Mutator]MSP[] } public static IOFileFilter ageFileFilter ( final Date cutoffDate ) { return new AgeFileFilter ( cutoffDate ) ; } public static IOFileFilter ageFileFilter ( final Date cutoffDate , final boolean acceptOlder ) {
final List < File > acceptedFiles = new ArrayList <> () ; for ( final File file : files ) { MST[rv.UOI1Mutator]MSP[] if ( file == null ) { throw new IllegalArgumentException ( lr_2 ) ; } if ( filter . accept ( file ) ) {
return new HashSet <> ( Arrays . asList ( acceptedFiles ) ) ; } public static Set < File > filterSet ( final IOFileFilter filter , final Iterable < File > files ) { return filter ( filter , files , new HashSet < File > () ) ; MST[ConstructorCallMutator]MSP[] }
} return acceptedFiles ; } public static IOFileFilter prefixFileFilter ( final String prefix ) { return new PrefixFileFilter ( prefix ) ; MST[NullReturnValsMutator]MSP[] } public static IOFileFilter prefixFileFilter ( final String prefix , final IOCase caseSensitivity ) { return new PrefixFileFilter ( prefix , caseSensitivity ) ; }
public static IOFileFilter suffixFileFilter ( final String suffix ) { return new SuffixFileFilter ( suffix ) ; } public static IOFileFilter suffixFileFilter ( final String suffix , final IOCase caseSensitivity ) { return new SuffixFileFilter ( suffix , caseSensitivity ) ; MST[ConstructorCallMutator]MSP[] }
return new SizeFileFilter ( threshold , acceptLarger ) ; } public static IOFileFilter sizeRangeFileFilter ( final long minSizeInclusive , final long maxSizeInclusive ) { final IOFileFilter minimumFilter = new SizeFileFilter ( minSizeInclusive , true ) ; final IOFileFilter maximumFilter = new SizeFileFilter ( maxSizeInclusive + 1L , false ) ; MST[rv.CRCR3Mutator]MSP[]
return new HashSet <> ( Arrays . asList ( acceptedFiles ) ) ; MST[EmptyObjectReturnValsMutator]MSP[] } public static Set < File > filterSet ( final IOFileFilter filter , final Iterable < File > files ) { return filter ( filter , files , new HashSet < File > () ) ; }
public static File [] filter ( final IOFileFilter filter , final File ... files ) { if ( filter == null ) { MST[NegateConditionalsMutator]MSP[] throw new IllegalArgumentException ( lr_1 ) ; } if ( files == null ) { return new File [ 0 ] ; }
return new SizeFileFilter ( threshold , acceptLarger ) ; MST[rv.UOI1Mutator]MSP[] } public static IOFileFilter sizeRangeFileFilter ( final long minSizeInclusive , final long maxSizeInclusive ) { final IOFileFilter minimumFilter = new SizeFileFilter ( minSizeInclusive , true ) ; final IOFileFilter maximumFilter = new SizeFileFilter ( maxSizeInclusive + 1L , false ) ;
return filter == null ? svnFilter : and ( filter , svnFilter ) ; MST[rv.CRCR6Mutator]MSP[] } public static IOFileFilter makeDirectoryOnly ( final IOFileFilter filter ) { if ( filter == null ) { return DirectoryFileFilter . DIRECTORY ; } return new AndFileFilter ( DirectoryFileFilter . DIRECTORY , filter ) ; }
public static IOFileFilter makeFileOnly ( final IOFileFilter filter ) { if ( filter == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return FileFileFilter . FILE ; } return new AndFileFilter ( FileFileFilter . FILE , filter ) ; }
public static IOFileFilter trueFileFilter () { return TrueFileFilter . TRUE ; } public static IOFileFilter falseFileFilter () { return FalseFileFilter . FALSE ; } public static IOFileFilter asFileFilter ( final FileFilter filter ) { return new DelegateFileFilter ( filter ) ; MST[NullReturnValsMutator]MSP[] }
return new MagicNumberFileFilter ( magicNumber , offset ) ; MST[rv.UOI1Mutator]MSP[] } public static IOFileFilter makeCVSAware ( final IOFileFilter filter ) { return filter == null ? cvsFilter : and ( filter , cvsFilter ) ; } public static IOFileFilter makeSVNAware ( final IOFileFilter filter ) {
return filter == null ? svnFilter : and ( filter , svnFilter ) ; MST[rv.CRCR1Mutator]MSP[] } public static IOFileFilter makeDirectoryOnly ( final IOFileFilter filter ) { if ( filter == null ) { return DirectoryFileFilter . DIRECTORY ; } return new AndFileFilter ( DirectoryFileFilter . DIRECTORY , filter ) ; }
return new MagicNumberFileFilter ( magicNumber , offset ) ; } public static IOFileFilter makeCVSAware ( final IOFileFilter filter ) { return filter == null ? cvsFilter : and ( filter , cvsFilter ) ; MST[rv.CRCR1Mutator]MSP[] } public static IOFileFilter makeSVNAware ( final IOFileFilter filter ) {
} return acceptedFiles ; MST[ReturnValsMutator]MSP[] } public static IOFileFilter prefixFileFilter ( final String prefix ) { return new PrefixFileFilter ( prefix ) ; } public static IOFileFilter prefixFileFilter ( final String prefix , final IOCase caseSensitivity ) { return new PrefixFileFilter ( prefix , caseSensitivity ) ; }
return new MagicNumberFileFilter ( magicNumber , offset ) ; } public static IOFileFilter makeCVSAware ( final IOFileFilter filter ) { return filter == null ? cvsFilter : and ( filter , cvsFilter ) ; MST[InlineConstantMutator]MSP[] } public static IOFileFilter makeSVNAware ( final IOFileFilter filter ) {
if ( files != null ) { for ( final File file : files ) { if ( file == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] throw new IllegalArgumentException ( lr_3 ) ; } if ( filter . accept ( file ) ) { acceptedFiles . add ( file ) ; } }
public static IOFileFilter nameFileFilter ( final String name ) { return new NameFileFilter ( name ) ; } public static IOFileFilter nameFileFilter ( final String name , final IOCase caseSensitivity ) { return new NameFileFilter ( name , caseSensitivity ) ; MST[ConstructorCallMutator]MSP[] } public static IOFileFilter directoryFileFilter () {
return new MagicNumberFileFilter ( magicNumber , offset ) ; } public static IOFileFilter makeCVSAware ( final IOFileFilter filter ) { return filter == null ? cvsFilter : and ( filter , cvsFilter ) ; MST[rv.CRCR2Mutator]MSP[] } public static IOFileFilter makeSVNAware ( final IOFileFilter filter ) {
public static File [] filter ( final IOFileFilter filter , final File ... files ) { if ( filter == null ) { throw new IllegalArgumentException ( lr_1 ) ; } if ( files == null ) { return new File [ 0 ] ; MST[InlineConstantMutator]MSP[] }
return new AgeFileFilter ( cutoff , acceptOlder ) ; MST[rv.UOI2Mutator]MSP[] } public static IOFileFilter ageFileFilter ( final Date cutoffDate ) { return new AgeFileFilter ( cutoffDate ) ; } public static IOFileFilter ageFileFilter ( final Date cutoffDate , final boolean acceptOlder ) {
throw new IllegalArgumentException ( lr_5 + i + lr_6 ) ; } list . add ( filters [ i ] ) ; } return list ; } public static IOFileFilter notFileFilter ( final IOFileFilter filter ) { return new NotFileFilter ( filter ) ; MST[ReturnValsMutator]MSP[] }
public static File [] filter ( final IOFileFilter filter , final File ... files ) { if ( filter == null ) { throw new IllegalArgumentException ( lr_1 ) ; } if ( files == null ) { return new File [ 0 ] ; MST[rv.CRCR3Mutator]MSP[] }
final List < File > acceptedFiles = new ArrayList <> () ; for ( final File file : files ) { MST[rv.UOI1Mutator]MSP[] if ( file == null ) { throw new IllegalArgumentException ( lr_2 ) ; } if ( filter . accept ( file ) ) {
return new MagicNumberFileFilter ( magicNumber , offset ) ; MST[NullReturnValsMutator]MSP[] } public static IOFileFilter makeCVSAware ( final IOFileFilter filter ) { return filter == null ? cvsFilter : and ( filter , cvsFilter ) ; } public static IOFileFilter makeSVNAware ( final IOFileFilter filter ) {
final List < File > acceptedFiles = new ArrayList <> () ; for ( final File file : files ) { if ( file == null ) { throw new IllegalArgumentException ( lr_2 ) ; } if ( filter . accept ( file ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
return new AgeFileFilter ( cutoffDate , acceptOlder ) ; MST[NullReturnValsMutator]MSP[] } public static IOFileFilter ageFileFilter ( final File cutoffReference ) { return new AgeFileFilter ( cutoffReference ) ; } public static IOFileFilter ageFileFilter ( final File cutoffReference , final boolean acceptOlder ) {
return new SizeFileFilter ( threshold , acceptLarger ) ; MST[ReturnValsMutator]MSP[] } public static IOFileFilter sizeRangeFileFilter ( final long minSizeInclusive , final long maxSizeInclusive ) { final IOFileFilter minimumFilter = new SizeFileFilter ( minSizeInclusive , true ) ; final IOFileFilter maximumFilter = new SizeFileFilter ( maxSizeInclusive + 1L , false ) ;
return new AgeFileFilter ( cutoffReference , acceptOlder ) ; MST[rv.UOI4Mutator]MSP[] } public static IOFileFilter sizeFileFilter ( final long threshold ) { return new SizeFileFilter ( threshold ) ; } public static IOFileFilter sizeFileFilter ( final long threshold , final boolean acceptLarger ) {
return new AgeFileFilter ( cutoffDate , acceptOlder ) ; MST[rv.UOI4Mutator]MSP[] } public static IOFileFilter ageFileFilter ( final File cutoffReference ) { return new AgeFileFilter ( cutoffReference ) ; } public static IOFileFilter ageFileFilter ( final File cutoffReference , final boolean acceptOlder ) {
return filter == null ? svnFilter : and ( filter , svnFilter ) ; MST[rv.CRCR4Mutator]MSP[] } public static IOFileFilter makeDirectoryOnly ( final IOFileFilter filter ) { if ( filter == null ) { return DirectoryFileFilter . DIRECTORY ; } return new AndFileFilter ( DirectoryFileFilter . DIRECTORY , filter ) ; }
return filter == null ? svnFilter : and ( filter , svnFilter ) ; MST[rv.CRCR5Mutator]MSP[] } public static IOFileFilter makeDirectoryOnly ( final IOFileFilter filter ) { if ( filter == null ) { return DirectoryFileFilter . DIRECTORY ; } return new AndFileFilter ( DirectoryFileFilter . DIRECTORY , filter ) ; }
} final List < IOFileFilter > list = new ArrayList <> ( filters . length ) ; for ( int i = 0 ; i < filters . length ; i ++ ) { if ( filters [ i ] == null ) { MST[rv.UOI2Mutator]MSP[]
return new AgeFileFilter ( cutoffReference , acceptOlder ) ; } public static IOFileFilter sizeFileFilter ( final long threshold ) { return new SizeFileFilter ( threshold ) ; MST[rv.UOI3Mutator]MSP[] } public static IOFileFilter sizeFileFilter ( final long threshold , final boolean acceptLarger ) {
public static File [] filter ( final IOFileFilter filter , final File ... files ) { if ( filter == null ) { throw new IllegalArgumentException ( lr_1 ) ; } if ( files == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return new File [ 0 ] ; }
return new SizeFileFilter ( threshold , acceptLarger ) ; MST[rv.UOI1Mutator]MSP[] } public static IOFileFilter sizeRangeFileFilter ( final long minSizeInclusive , final long maxSizeInclusive ) { final IOFileFilter minimumFilter = new SizeFileFilter ( minSizeInclusive , true ) ; final IOFileFilter maximumFilter = new SizeFileFilter ( maxSizeInclusive + 1L , false ) ;
return new MagicNumberFileFilter ( magicNumber , offset ) ; MST[ReturnValsMutator]MSP[] } public static IOFileFilter makeCVSAware ( final IOFileFilter filter ) { return filter == null ? cvsFilter : and ( filter , cvsFilter ) ; } public static IOFileFilter makeSVNAware ( final IOFileFilter filter ) {
public static IOFileFilter nameFileFilter ( final String name ) { return new NameFileFilter ( name ) ; MST[ConstructorCallMutator]MSP[] } public static IOFileFilter nameFileFilter ( final String name , final IOCase caseSensitivity ) { return new NameFileFilter ( name , caseSensitivity ) ; } public static IOFileFilter directoryFileFilter () {
public static IOFileFilter asFileFilter ( final FilenameFilter filter ) { return new DelegateFileFilter ( filter ) ; } public static IOFileFilter ageFileFilter ( final long cutoff ) { return new AgeFileFilter ( cutoff ) ; MST[ReturnValsMutator]MSP[] } public static IOFileFilter ageFileFilter ( final long cutoff , final boolean acceptOlder ) {
return new SizeFileFilter ( threshold , acceptLarger ) ; MST[rv.UOI4Mutator]MSP[] } public static IOFileFilter sizeRangeFileFilter ( final long minSizeInclusive , final long maxSizeInclusive ) { final IOFileFilter minimumFilter = new SizeFileFilter ( minSizeInclusive , true ) ; final IOFileFilter maximumFilter = new SizeFileFilter ( maxSizeInclusive + 1L , false ) ;
if ( files != null ) { for ( final File file : files ) { if ( file == null ) { throw new IllegalArgumentException ( lr_3 ) ; } if ( filter . accept ( file ) ) { MST[rv.ROR2Mutator]MSP[] acceptedFiles . add ( file ) ; } }
return Arrays . asList ( acceptedFiles ) ; } public static Set < File > filterSet ( final IOFileFilter filter , final File ... files ) { final File [] acceptedFiles = filter ( filter , files ) ; MST[ArgumentPropagationMutator]MSP[]
return new MagicNumberFileFilter ( magicNumber , offset ) ; MST[rv.UOI4Mutator]MSP[] } public static IOFileFilter makeCVSAware ( final IOFileFilter filter ) { return filter == null ? cvsFilter : and ( filter , cvsFilter ) ; } public static IOFileFilter makeSVNAware ( final IOFileFilter filter ) {
return filter == null ? svnFilter : and ( filter , svnFilter ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] } public static IOFileFilter makeDirectoryOnly ( final IOFileFilter filter ) { if ( filter == null ) { return DirectoryFileFilter . DIRECTORY ; } return new AndFileFilter ( DirectoryFileFilter . DIRECTORY , filter ) ; }
return new MagicNumberFileFilter ( magicNumber , offset ) ; } public static IOFileFilter makeCVSAware ( final IOFileFilter filter ) { return filter == null ? cvsFilter : and ( filter , cvsFilter ) ; MST[rv.CRCR6Mutator]MSP[] } public static IOFileFilter makeSVNAware ( final IOFileFilter filter ) {
public static IOFileFilter asFileFilter ( final FilenameFilter filter ) { return new DelegateFileFilter ( filter ) ; } public static IOFileFilter ageFileFilter ( final long cutoff ) { return new AgeFileFilter ( cutoff ) ; MST[rv.UOI4Mutator]MSP[] } public static IOFileFilter ageFileFilter ( final long cutoff , final boolean acceptOlder ) {
return new MagicNumberFileFilter ( magicNumber , offset ) ; } public static IOFileFilter makeCVSAware ( final IOFileFilter filter ) { return filter == null ? cvsFilter : and ( filter , cvsFilter ) ; MST[rv.CRCR5Mutator]MSP[] } public static IOFileFilter makeSVNAware ( final IOFileFilter filter ) {
return new AndFileFilter ( minimumFilter , maximumFilter ) ; MST[ConstructorCallMutator]MSP[] } public static IOFileFilter magicNumberFileFilter ( final String magicNumber ) { return new MagicNumberFileFilter ( magicNumber ) ; } public static IOFileFilter magicNumberFileFilter ( final String magicNumber , final long offset ) {
public static IOFileFilter asFileFilter ( final FilenameFilter filter ) { return new DelegateFileFilter ( filter ) ; } public static IOFileFilter ageFileFilter ( final long cutoff ) { return new AgeFileFilter ( cutoff ) ; MST[rv.ABSMutator]MSP[] } public static IOFileFilter ageFileFilter ( final long cutoff , final boolean acceptOlder ) {
return new AgeFileFilter ( cutoffReference , acceptOlder ) ; } public static IOFileFilter sizeFileFilter ( final long threshold ) { return new SizeFileFilter ( threshold ) ; MST[ReturnValsMutator]MSP[] } public static IOFileFilter sizeFileFilter ( final long threshold , final boolean acceptLarger ) {
return DirectoryFileFilter . DIRECTORY ; } public static IOFileFilter fileFileFilter () { return FileFileFilter . FILE ; } @Deprecated public static IOFileFilter andFileFilter ( final IOFileFilter filter1 , final IOFileFilter filter2 ) { return new AndFileFilter ( filter1 , filter2 ) ; MST[NullReturnValsMutator]MSP[] } @Deprecated
public static IOFileFilter or ( final IOFileFilter ... filters ) { return new OrFileFilter ( toList ( filters ) ) ; } public static List < IOFileFilter > toList ( final IOFileFilter ... filters ) { if ( filters == null ) { throw new IllegalArgumentException ( lr_4 ) ; MST[ConstructorCallMutator]MSP[]
return new SizeFileFilter ( threshold , acceptLarger ) ; } public static IOFileFilter sizeRangeFileFilter ( final long minSizeInclusive , final long maxSizeInclusive ) { final IOFileFilter minimumFilter = new SizeFileFilter ( minSizeInclusive , true ) ; final IOFileFilter maximumFilter = new SizeFileFilter ( maxSizeInclusive + 1L , false ) ; MST[rv.CRCR3Mutator]MSP[]
return new SizeFileFilter ( threshold , acceptLarger ) ; } public static IOFileFilter sizeRangeFileFilter ( final long minSizeInclusive , final long maxSizeInclusive ) { final IOFileFilter minimumFilter = new SizeFileFilter ( minSizeInclusive , true ) ; final IOFileFilter maximumFilter = new SizeFileFilter ( maxSizeInclusive + 1L , false ) ; MST[InlineConstantMutator]MSP[]
final List < File > acceptedFiles = filterList ( filter , files ) ; return acceptedFiles . toArray ( new File [ acceptedFiles . size () ] ) ; MST[NullReturnValsMutator]MSP[] } public static List < File > filterList ( final IOFileFilter filter , final Iterable < File > files ) {
return new AgeFileFilter ( cutoffReference , acceptOlder ) ; } public static IOFileFilter sizeFileFilter ( final long threshold ) { return new SizeFileFilter ( threshold ) ; MST[ConstructorCallMutator]MSP[] } public static IOFileFilter sizeFileFilter ( final long threshold , final boolean acceptLarger ) {
} final List < IOFileFilter > list = new ArrayList <> ( filters . length ) ; for ( int i = 0 ; i < filters . length ; i ++ ) { if ( filters [ i ] == null ) { MST[rv.UOI3Mutator]MSP[]
throw new IllegalArgumentException ( lr_5 + i + lr_6 ) ; MST[ConstructorCallMutator]MSP[] } list . add ( filters [ i ] ) ; } return list ; } public static IOFileFilter notFileFilter ( final IOFileFilter filter ) { return new NotFileFilter ( filter ) ; }
return new AgeFileFilter ( cutoffDate , acceptOlder ) ; MST[ConstructorCallMutator]MSP[] } public static IOFileFilter ageFileFilter ( final File cutoffReference ) { return new AgeFileFilter ( cutoffReference ) ; } public static IOFileFilter ageFileFilter ( final File cutoffReference , final boolean acceptOlder ) {
return new SizeFileFilter ( threshold , acceptLarger ) ; } public static IOFileFilter sizeRangeFileFilter ( final long minSizeInclusive , final long maxSizeInclusive ) { final IOFileFilter minimumFilter = new SizeFileFilter ( minSizeInclusive , true ) ; MST[rv.UOI4Mutator]MSP[] final IOFileFilter maximumFilter = new SizeFileFilter ( maxSizeInclusive + 1L , false ) ;
return new SizeFileFilter ( threshold , acceptLarger ) ; } public static IOFileFilter sizeRangeFileFilter ( final long minSizeInclusive , final long maxSizeInclusive ) { final IOFileFilter minimumFilter = new SizeFileFilter ( minSizeInclusive , true ) ; MST[rv.UOI2Mutator]MSP[] final IOFileFilter maximumFilter = new SizeFileFilter ( maxSizeInclusive + 1L , false ) ;
if ( files != null ) { for ( final File file : files ) { if ( file == null ) { throw new IllegalArgumentException ( lr_3 ) ; } if ( filter . accept ( file ) ) { MST[rv.ROR5Mutator]MSP[] acceptedFiles . add ( file ) ; } }
return new MagicNumberFileFilter ( magicNumber , offset ) ; } public static IOFileFilter makeCVSAware ( final IOFileFilter filter ) { return filter == null ? cvsFilter : and ( filter , cvsFilter ) ; MST[rv.CRCR4Mutator]MSP[] } public static IOFileFilter makeSVNAware ( final IOFileFilter filter ) {
if ( files != null ) { for ( final File file : files ) { if ( file == null ) { throw new IllegalArgumentException ( lr_3 ) ; } if ( filter . accept ( file ) ) { MST[rv.ROR1Mutator]MSP[] acceptedFiles . add ( file ) ; } }
throw new IllegalArgumentException ( lr_5 + i + lr_6 ) ; MST[NonVoidMethodCallMutator]MSP[] } list . add ( filters [ i ] ) ; } return list ; } public static IOFileFilter notFileFilter ( final IOFileFilter filter ) { return new NotFileFilter ( filter ) ; }
return new MagicNumberFileFilter ( magicNumber , offset ) ; } public static IOFileFilter makeCVSAware ( final IOFileFilter filter ) { return filter == null ? cvsFilter : and ( filter , cvsFilter ) ; MST[rv.CRCR5Mutator]MSP[] } public static IOFileFilter makeSVNAware ( final IOFileFilter filter ) {
public static IOFileFilter trueFileFilter () { return TrueFileFilter . TRUE ; } public static IOFileFilter falseFileFilter () { return FalseFileFilter . FALSE ; } public static IOFileFilter asFileFilter ( final FileFilter filter ) { return new DelegateFileFilter ( filter ) ; MST[ConstructorCallMutator]MSP[] }
final List < File > acceptedFiles = new ArrayList <> () ; for ( final File file : files ) { MST[rv.UOI3Mutator]MSP[] if ( file == null ) { throw new IllegalArgumentException ( lr_2 ) ; } if ( filter . accept ( file ) ) {
if ( files != null ) { for ( final File file : files ) { if ( file == null ) { throw new IllegalArgumentException ( lr_3 ) ; } if ( filter . accept ( file ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] acceptedFiles . add ( file ) ; } }
return new SizeFileFilter ( threshold , acceptLarger ) ; } public static IOFileFilter sizeRangeFileFilter ( final long minSizeInclusive , final long maxSizeInclusive ) { final IOFileFilter minimumFilter = new SizeFileFilter ( minSizeInclusive , true ) ; MST[rv.ABSMutator]MSP[] final IOFileFilter maximumFilter = new SizeFileFilter ( maxSizeInclusive + 1L , false ) ;
final List < File > acceptedFiles = new ArrayList <> () ; for ( final File file : files ) { MST[rv.UOI4Mutator]MSP[] if ( file == null ) { throw new IllegalArgumentException ( lr_2 ) ; } if ( filter . accept ( file ) ) {
return filter == null ? svnFilter : and ( filter , svnFilter ) ; MST[rv.ROR5Mutator]MSP[] } public static IOFileFilter makeDirectoryOnly ( final IOFileFilter filter ) { if ( filter == null ) { return DirectoryFileFilter . DIRECTORY ; } return new AndFileFilter ( DirectoryFileFilter . DIRECTORY , filter ) ; }
return new AgeFileFilter ( cutoffReference , acceptOlder ) ; MST[rv.UOI3Mutator]MSP[] } public static IOFileFilter sizeFileFilter ( final long threshold ) { return new SizeFileFilter ( threshold ) ; } public static IOFileFilter sizeFileFilter ( final long threshold , final boolean acceptLarger ) {
return new MagicNumberFileFilter ( magicNumber , offset ) ; } public static IOFileFilter makeCVSAware ( final IOFileFilter filter ) { return filter == null ? cvsFilter : and ( filter , cvsFilter ) ; MST[InlineConstantMutator]MSP[] } public static IOFileFilter makeSVNAware ( final IOFileFilter filter ) {
return filter == null ? svnFilter : and ( filter , svnFilter ) ; MST[rv.CRCR6Mutator]MSP[] } public static IOFileFilter makeDirectoryOnly ( final IOFileFilter filter ) { if ( filter == null ) { return DirectoryFileFilter . DIRECTORY ; } return new AndFileFilter ( DirectoryFileFilter . DIRECTORY , filter ) ; }
return new SizeFileFilter ( threshold , acceptLarger ) ; } public static IOFileFilter sizeRangeFileFilter ( final long minSizeInclusive , final long maxSizeInclusive ) { final IOFileFilter minimumFilter = new SizeFileFilter ( minSizeInclusive , true ) ; final IOFileFilter maximumFilter = new SizeFileFilter ( maxSizeInclusive + 1L , false ) ; MST[rv.AOR1Mutator]MSP[]
return new AgeFileFilter ( cutoffDate , acceptOlder ) ; } public static IOFileFilter ageFileFilter ( final File cutoffReference ) { return new AgeFileFilter ( cutoffReference ) ; MST[NullReturnValsMutator]MSP[] } public static IOFileFilter ageFileFilter ( final File cutoffReference , final boolean acceptOlder ) {
public static IOFileFilter or ( final IOFileFilter ... filters ) { return new OrFileFilter ( toList ( filters ) ) ; } public static List < IOFileFilter > toList ( final IOFileFilter ... filters ) { if ( filters == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] throw new IllegalArgumentException ( lr_4 ) ;
return filter == null ? svnFilter : and ( filter , svnFilter ) ; MST[rv.CRCR3Mutator]MSP[] } public static IOFileFilter makeDirectoryOnly ( final IOFileFilter filter ) { if ( filter == null ) { return DirectoryFileFilter . DIRECTORY ; } return new AndFileFilter ( DirectoryFileFilter . DIRECTORY , filter ) ; }
return new SizeFileFilter ( threshold , acceptLarger ) ; MST[rv.UOI3Mutator]MSP[] } public static IOFileFilter sizeRangeFileFilter ( final long minSizeInclusive , final long maxSizeInclusive ) { final IOFileFilter minimumFilter = new SizeFileFilter ( minSizeInclusive , true ) ; final IOFileFilter maximumFilter = new SizeFileFilter ( maxSizeInclusive + 1L , false ) ;
if ( files != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] for ( final File file : files ) { if ( file == null ) { throw new IllegalArgumentException ( lr_3 ) ; } if ( filter . accept ( file ) ) { acceptedFiles . add ( file ) ; } }
final List < File > acceptedFiles = new ArrayList <> () ; for ( final File file : files ) { if ( file == null ) { throw new IllegalArgumentException ( lr_2 ) ; } if ( filter . accept ( file ) ) { MST[rv.ROR2Mutator]MSP[]
public static IOFileFilter asFileFilter ( final FilenameFilter filter ) { return new DelegateFileFilter ( filter ) ; } public static IOFileFilter ageFileFilter ( final long cutoff ) { return new AgeFileFilter ( cutoff ) ; MST[rv.UOI2Mutator]MSP[] } public static IOFileFilter ageFileFilter ( final long cutoff , final boolean acceptOlder ) {
public static IOFileFilter makeFileOnly ( final IOFileFilter filter ) { if ( filter == null ) { return FileFileFilter . FILE ; } return new AndFileFilter ( FileFileFilter . FILE , filter ) ; MST[NullReturnValsMutator]MSP[] }
return filter == null ? svnFilter : and ( filter , svnFilter ) ; } public static IOFileFilter makeDirectoryOnly ( final IOFileFilter filter ) { if ( filter == null ) { return DirectoryFileFilter . DIRECTORY ; } return new AndFileFilter ( DirectoryFileFilter . DIRECTORY , filter ) ; MST[NullReturnValsMutator]MSP[] }
return filter == null ? svnFilter : and ( filter , svnFilter ) ; MST[NegateConditionalsMutator]MSP[] } public static IOFileFilter makeDirectoryOnly ( final IOFileFilter filter ) { if ( filter == null ) { return DirectoryFileFilter . DIRECTORY ; } return new AndFileFilter ( DirectoryFileFilter . DIRECTORY , filter ) ; }
} final List < IOFileFilter > list = new ArrayList <> ( filters . length ) ; for ( int i = 0 ; i < filters . length ; i ++ ) { if ( filters [ i ] == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
return new SizeFileFilter ( threshold , acceptLarger ) ; } public static IOFileFilter sizeRangeFileFilter ( final long minSizeInclusive , final long maxSizeInclusive ) { final IOFileFilter minimumFilter = new SizeFileFilter ( minSizeInclusive , true ) ; MST[rv.CRCR5Mutator]MSP[] final IOFileFilter maximumFilter = new SizeFileFilter ( maxSizeInclusive + 1L , false ) ;
return new SizeFileFilter ( threshold , acceptLarger ) ; } public static IOFileFilter sizeRangeFileFilter ( final long minSizeInclusive , final long maxSizeInclusive ) { final IOFileFilter minimumFilter = new SizeFileFilter ( minSizeInclusive , true ) ; MST[rv.CRCR4Mutator]MSP[] final IOFileFilter maximumFilter = new SizeFileFilter ( maxSizeInclusive + 1L , false ) ;
public static IOFileFilter or ( final IOFileFilter ... filters ) { return new OrFileFilter ( toList ( filters ) ) ; MST[ReturnValsMutator]MSP[] } public static List < IOFileFilter > toList ( final IOFileFilter ... filters ) { if ( filters == null ) { throw new IllegalArgumentException ( lr_4 ) ;
return new SizeFileFilter ( threshold , acceptLarger ) ; } public static IOFileFilter sizeRangeFileFilter ( final long minSizeInclusive , final long maxSizeInclusive ) { final IOFileFilter minimumFilter = new SizeFileFilter ( minSizeInclusive , true ) ; final IOFileFilter maximumFilter = new SizeFileFilter ( maxSizeInclusive + 1L , false ) ; MST[rv.CRCR2Mutator]MSP[]
return new AgeFileFilter ( cutoff , acceptOlder ) ; MST[rv.UOI1Mutator]MSP[] } public static IOFileFilter ageFileFilter ( final Date cutoffDate ) { return new AgeFileFilter ( cutoffDate ) ; } public static IOFileFilter ageFileFilter ( final Date cutoffDate , final boolean acceptOlder ) {
return new SizeFileFilter ( threshold , acceptLarger ) ; } public static IOFileFilter sizeRangeFileFilter ( final long minSizeInclusive , final long maxSizeInclusive ) { final IOFileFilter minimumFilter = new SizeFileFilter ( minSizeInclusive , true ) ; final IOFileFilter maximumFilter = new SizeFileFilter ( maxSizeInclusive + 1L , false ) ; MST[InlineConstantMutator]MSP[]
final List < File > acceptedFiles = new ArrayList <> () ; for ( final File file : files ) { MST[rv.ABSMutator]MSP[] if ( file == null ) { throw new IllegalArgumentException ( lr_2 ) ; } if ( filter . accept ( file ) ) {
final List < File > acceptedFiles = new ArrayList <> () ; for ( final File file : files ) { MST[rv.UOI2Mutator]MSP[] if ( file == null ) { throw new IllegalArgumentException ( lr_2 ) ; } if ( filter . accept ( file ) ) {
} return acceptedFiles ; } public static IOFileFilter prefixFileFilter ( final String prefix ) { return new PrefixFileFilter ( prefix ) ; } public static IOFileFilter prefixFileFilter ( final String prefix , final IOCase caseSensitivity ) { return new PrefixFileFilter ( prefix , caseSensitivity ) ; MST[ConstructorCallMutator]MSP[] }
final List < File > acceptedFiles = new ArrayList <> () ; for ( final File file : files ) { MST[rv.UOI3Mutator]MSP[] if ( file == null ) { throw new IllegalArgumentException ( lr_2 ) ; } if ( filter . accept ( file ) ) {
public static File [] filter ( final IOFileFilter filter , final File ... files ) { if ( filter == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] throw new IllegalArgumentException ( lr_1 ) ; } if ( files == null ) { return new File [ 0 ] ; }
return filter == null ? svnFilter : and ( filter , svnFilter ) ; MST[rv.CRCR6Mutator]MSP[] } public static IOFileFilter makeDirectoryOnly ( final IOFileFilter filter ) { if ( filter == null ) { return DirectoryFileFilter . DIRECTORY ; } return new AndFileFilter ( DirectoryFileFilter . DIRECTORY , filter ) ; }
return filter == null ? svnFilter : and ( filter , svnFilter ) ; MST[NonVoidMethodCallMutator]MSP[] } public static IOFileFilter makeDirectoryOnly ( final IOFileFilter filter ) { if ( filter == null ) { return DirectoryFileFilter . DIRECTORY ; } return new AndFileFilter ( DirectoryFileFilter . DIRECTORY , filter ) ; }
return filter == null ? svnFilter : and ( filter , svnFilter ) ; MST[rv.CRCR5Mutator]MSP[] } public static IOFileFilter makeDirectoryOnly ( final IOFileFilter filter ) { if ( filter == null ) { return DirectoryFileFilter . DIRECTORY ; } return new AndFileFilter ( DirectoryFileFilter . DIRECTORY , filter ) ; }
return new SizeFileFilter ( threshold , acceptLarger ) ; MST[rv.UOI3Mutator]MSP[] } public static IOFileFilter sizeRangeFileFilter ( final long minSizeInclusive , final long maxSizeInclusive ) { final IOFileFilter minimumFilter = new SizeFileFilter ( minSizeInclusive , true ) ; final IOFileFilter maximumFilter = new SizeFileFilter ( maxSizeInclusive + 1L , false ) ;
return new AgeFileFilter ( cutoff , acceptOlder ) ; } public static IOFileFilter ageFileFilter ( final Date cutoffDate ) { return new AgeFileFilter ( cutoffDate ) ; MST[NullReturnValsMutator]MSP[] } public static IOFileFilter ageFileFilter ( final Date cutoffDate , final boolean acceptOlder ) {
return filter == null ? svnFilter : and ( filter , svnFilter ) ; MST[rv.CRCR2Mutator]MSP[] } public static IOFileFilter makeDirectoryOnly ( final IOFileFilter filter ) { if ( filter == null ) { return DirectoryFileFilter . DIRECTORY ; } return new AndFileFilter ( DirectoryFileFilter . DIRECTORY , filter ) ; }
return filter ( filter , files , new ArrayList < File > () ) ; MST[ReturnValsMutator]MSP[] } public static List < File > filterList ( final IOFileFilter filter , final File ... files ) { final File [] acceptedFiles = filter ( filter , files ) ;
public static IOFileFilter makeFileOnly ( final IOFileFilter filter ) { if ( filter == null ) { return FileFileFilter . FILE ; } return new AndFileFilter ( FileFileFilter . FILE , filter ) ; MST[ReturnValsMutator]MSP[] }
return new MagicNumberFileFilter ( magicNumber , offset ) ; } public static IOFileFilter makeCVSAware ( final IOFileFilter filter ) { return filter == null ? cvsFilter : and ( filter , cvsFilter ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] } public static IOFileFilter makeSVNAware ( final IOFileFilter filter ) {
} final List < IOFileFilter > list = new ArrayList <> ( filters . length ) ; for ( int i = 0 ; i < filters . length ; i ++ ) { MST[rv.CRCR6Mutator]MSP[] if ( filters [ i ] == null ) {
throw new IllegalArgumentException ( lr_5 + i + lr_6 ) ; MST[NonVoidMethodCallMutator]MSP[] } list . add ( filters [ i ] ) ; } return list ; } public static IOFileFilter notFileFilter ( final IOFileFilter filter ) { return new NotFileFilter ( filter ) ; }
return new MagicNumberFileFilter ( magicNumber , offset ) ; } public static IOFileFilter makeCVSAware ( final IOFileFilter filter ) { return filter == null ? cvsFilter : and ( filter , cvsFilter ) ; MST[rv.CRCR6Mutator]MSP[] } public static IOFileFilter makeSVNAware ( final IOFileFilter filter ) {
return new MagicNumberFileFilter ( magicNumber , offset ) ; MST[ConstructorCallMutator]MSP[] } public static IOFileFilter magicNumberFileFilter ( final byte [] magicNumber ) { return new MagicNumberFileFilter ( magicNumber ) ; } public static IOFileFilter magicNumberFileFilter ( final byte [] magicNumber , final long offset ) {
return filter == null ? svnFilter : and ( filter , svnFilter ) ; } public static IOFileFilter makeDirectoryOnly ( final IOFileFilter filter ) { if ( filter == null ) { return DirectoryFileFilter . DIRECTORY ; } return new AndFileFilter ( DirectoryFileFilter . DIRECTORY , filter ) ; MST[ReturnValsMutator]MSP[] }
return new AgeFileFilter ( cutoff , acceptOlder ) ; MST[rv.UOI1Mutator]MSP[] } public static IOFileFilter ageFileFilter ( final Date cutoffDate ) { return new AgeFileFilter ( cutoffDate ) ; } public static IOFileFilter ageFileFilter ( final Date cutoffDate , final boolean acceptOlder ) {
} final List < IOFileFilter > list = new ArrayList <> ( filters . length ) ; for ( int i = 0 ; i < filters . length ; i ++ ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[] if ( filters [ i ] == null ) {
return new AgeFileFilter ( cutoffReference , acceptOlder ) ; } public static IOFileFilter sizeFileFilter ( final long threshold ) { return new SizeFileFilter ( threshold ) ; MST[rv.UOI4Mutator]MSP[] } public static IOFileFilter sizeFileFilter ( final long threshold , final boolean acceptLarger ) {
return new MagicNumberFileFilter ( magicNumber , offset ) ; MST[ConstructorCallMutator]MSP[] } public static IOFileFilter makeCVSAware ( final IOFileFilter filter ) { return filter == null ? cvsFilter : and ( filter , cvsFilter ) ; } public static IOFileFilter makeSVNAware ( final IOFileFilter filter ) {
final List < File > acceptedFiles = new ArrayList <> () ; for ( final File file : files ) { MST[rv.UOI2Mutator]MSP[] if ( file == null ) { throw new IllegalArgumentException ( lr_2 ) ; } if ( filter . accept ( file ) ) {
} final List < IOFileFilter > list = new ArrayList <> ( filters . length ) ; for ( int i = 0 ; i < filters . length ; i ++ ) { MST[rv.UOI1Mutator]MSP[] if ( filters [ i ] == null ) {
} final List < IOFileFilter > list = new ArrayList <> ( filters . length ) ; for ( int i = 0 ; i < filters . length ; i ++ ) { MST[rv.ROR4Mutator]MSP[] if ( filters [ i ] == null ) {
return new AndFileFilter ( minimumFilter , maximumFilter ) ; MST[ReturnValsMutator]MSP[] } public static IOFileFilter magicNumberFileFilter ( final String magicNumber ) { return new MagicNumberFileFilter ( magicNumber ) ; } public static IOFileFilter magicNumberFileFilter ( final String magicNumber , final long offset ) {
return filter ( filter , files , new ArrayList < File > () ) ; MST[ArgumentPropagationMutator]MSP[] } public static List < File > filterList ( final IOFileFilter filter , final File ... files ) { final File [] acceptedFiles = filter ( filter , files ) ;
throw new IllegalArgumentException ( lr_5 + i + lr_6 ) ; MST[rv.UOI2Mutator]MSP[] } list . add ( filters [ i ] ) ; } return list ; } public static IOFileFilter notFileFilter ( final IOFileFilter filter ) { return new NotFileFilter ( filter ) ; }
return new AgeFileFilter ( cutoff , acceptOlder ) ; } public static IOFileFilter ageFileFilter ( final Date cutoffDate ) { return new AgeFileFilter ( cutoffDate ) ; MST[ReturnValsMutator]MSP[] } public static IOFileFilter ageFileFilter ( final Date cutoffDate , final boolean acceptOlder ) {
return new SizeFileFilter ( threshold , acceptLarger ) ; } public static IOFileFilter sizeRangeFileFilter ( final long minSizeInclusive , final long maxSizeInclusive ) { final IOFileFilter minimumFilter = new SizeFileFilter ( minSizeInclusive , true ) ; MST[rv.UOI3Mutator]MSP[] final IOFileFilter maximumFilter = new SizeFileFilter ( maxSizeInclusive + 1L , false ) ;
return new AgeFileFilter ( cutoffReference , acceptOlder ) ; } public static IOFileFilter sizeFileFilter ( final long threshold ) { return new SizeFileFilter ( threshold ) ; MST[NullReturnValsMutator]MSP[] } public static IOFileFilter sizeFileFilter ( final long threshold , final boolean acceptLarger ) {
return filter == null ? svnFilter : and ( filter , svnFilter ) ; MST[rv.CRCR1Mutator]MSP[] } public static IOFileFilter makeDirectoryOnly ( final IOFileFilter filter ) { if ( filter == null ) { return DirectoryFileFilter . DIRECTORY ; } return new AndFileFilter ( DirectoryFileFilter . DIRECTORY , filter ) ; }
return DirectoryFileFilter . DIRECTORY ; } public static IOFileFilter fileFileFilter () { return FileFileFilter . FILE ; } @Deprecated public static IOFileFilter andFileFilter ( final IOFileFilter filter1 , final IOFileFilter filter2 ) { return new AndFileFilter ( filter1 , filter2 ) ; MST[ConstructorCallMutator]MSP[] } @Deprecated
} final List < IOFileFilter > list = new ArrayList <> ( filters . length ) ; for ( int i = 0 ; i < filters . length ; i ++ ) { MST[rv.CRCR1Mutator]MSP[] if ( filters [ i ] == null ) {
