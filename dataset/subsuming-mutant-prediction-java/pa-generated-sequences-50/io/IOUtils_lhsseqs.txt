if ( EOF == count ) { break; } remaining -= count ; MST[rv.UOI4Mutator]MSP[] } return length - remaining ; } public static void readFully ( final InputStream input , final byte [] buffer ) throws IOException { readFully ( input , buffer , 0 , buffer . length ) ;
final int actual = read ( input , buffer ) ; if ( actual != expected ) { MST[rv.UOI3Mutator]MSP[] throw new EOFException ( lr_3 + expected + lr_4 + actual ) ; } } public static void readFully ( final Reader input , final char [] buffer ) throws IOException {
final int chunk = Math . min ( bytes , DEFAULT_BUFFER_SIZE ) ; MST[rv.CRCR4Mutator]MSP[] output . write ( data , offset , chunk ) ; bytes -= chunk ; offset += chunk ; } } } @Deprecated
public static long skip ( final Reader input , final long toSkip ) throws IOException { if ( toSkip < 0 ) { MST[rv.ROR2Mutator]MSP[] throw new IllegalArgumentException ( lr_6 + toSkip ) ; } if ( SKIP_CHAR_BUFFER == null ) { SKIP_CHAR_BUFFER = new char [ SKIP_BUFFER_SIZE ] ; }
if ( length == 0 ) { MST[rv.ROR3Mutator]MSP[] return 0 ; } final int bufferLength = buffer . length ; int bytesToRead = bufferLength ; if ( length > 0 && length < bufferLength ) { bytesToRead = ( int ) length ; } int read ;
while ( remaining > 0 ) { final int location = length - remaining ; final int count = input . read ( buffer , offset + location , remaining ) ; MST[rv.ABSMutator]MSP[] if ( EOF == count ) { break; } remaining -= count ; }
output . write ( buffer , 0 , n ) ; count += n ; } return count ; MST[rv.ABSMutator]MSP[] } public static long copyLarge ( final Reader input , final Writer output , final long inputOffset , final long length ) throws IOException {
final int ch2 = input2 . read () ; if ( ch != ch2 ) { MST[rv.UOI2Mutator]MSP[] return false ; } ch = input1 . read () ; } final int ch2 = input2 . read () ; return ch2 == EOF ; }
long totalRead = 0 ; while ( bytesToRead > 0 && EOF != ( read = input . read ( buffer , 0 , bytesToRead ) ) ) { MST[rv.ROR5Mutator]MSP[] output . write ( buffer , 0 , read ) ; totalRead += read ;
public static char [] toCharArray ( final InputStream is , final Charset encoding ) throws IOException { final CharArrayWriter output = new CharArrayWriter () ; copy ( is , output , encoding ) ; return output . toCharArray () ; MST[ReturnValsMutator]MSP[] }
final int actual = read ( input , buffer ) ; if ( actual != expected ) { throw new EOFException ( lr_3 + expected + lr_4 + actual ) ; MST[NonVoidMethodCallMutator]MSP[] } } public static void readFully ( final Reader input , final char [] buffer ) throws IOException {
bytesToRead = ( int ) length ; } int read ; long totalRead = 0 ; MST[rv.CRCR1Mutator]MSP[] while ( bytesToRead > 0 && EOF != ( read = input . read ( buffer , 0 , bytesToRead ) ) ) {
throw new IllegalArgumentException ( lr_2 + length ) ; } int remaining = length ; while ( remaining > 0 ) { final int location = length - remaining ; final int count = input . read ( buffer , offset + location , remaining ) ; MST[rv.UOI4Mutator]MSP[]
long totalRead = 0 ; while ( bytesToRead > 0 && EOF != ( read = input . read ( buffer , 0 , bytesToRead ) ) ) { output . write ( buffer , 0 , read ) ; MST[rv.UOI4Mutator]MSP[] totalRead += read ;
return new String ( input , Charset . defaultCharset () ) ; MST[EmptyObjectReturnValsMutator]MSP[] } public static String toString ( final byte [] input , final String encoding ) throws IOException { return new String ( input , Charsets . toCharset ( encoding ) ) ; } @Deprecated
public static void skipFully ( final Reader input , final long toSkip ) throws IOException { final long skipped = skip ( input , toSkip ) ; if ( skipped != toSkip ) { throw new EOFException ( lr_9 + toSkip + lr_4 + skipped ) ; MST[rv.UOI1Mutator]MSP[] } }
while ( EOF != ch ) { final int ch2 = input2 . read () ; if ( ch != ch2 ) { return false ; } ch = input1 . read () ; } final int ch2 = input2 . read () ; return ch2 == EOF ; MST[rv.UOI2Mutator]MSP[] }
final int count = input . read ( buffer ) ; if ( EOF == count ) { break; } } return length - buffer . remaining () ; MST[MathMutator]MSP[] } public static int read ( final Reader input , final char [] buffer ) throws IOException {
throw new IllegalArgumentException ( lr_2 + length ) ; } int remaining = length ; while ( remaining > 0 ) { final int location = length - remaining ; MST[rv.AOD1Mutator]MSP[] final int count = input . read ( buffer , offset + location , remaining ) ;
if ( lineEnding == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] lineEnding = LINE_SEPARATOR ; } for ( final Object line : lines ) { if ( line != null ) { writer . write ( line . toString () ) ; } writer . write ( lineEnding ) ; } }
if ( count > Integer . MAX_VALUE ) { return - 1 ; } return ( int ) count ; MST[rv.UOI1Mutator]MSP[] } public static long copy ( final InputStream input , final OutputStream output , final int bufferSize ) throws IOException {
if ( SKIP_BYTE_BUFFER == null ) { SKIP_BYTE_BUFFER = new byte [ SKIP_BUFFER_SIZE ] ; MST[rv.CRCR1Mutator]MSP[] } long remain = toSkip ; while ( remain > 0 ) {
public static int copy ( final Reader input , final Writer output ) throws IOException { final long count = copyLarge ( input , output ) ; if ( count > Integer . MAX_VALUE ) { return - 1 ; MST[rv.CRCR1Mutator]MSP[] } return ( int ) count ; }
while ( EOF != ch ) { final int ch2 = input2 . read () ; if ( ch != ch2 ) { return false ; MST[rv.CRCR6Mutator]MSP[] } ch = input1 . read () ; } final int ch2 = input2 . read () ; return ch2 == EOF ; }
throw new IllegalArgumentException ( lr_13 + size ) ; } return toByteArray ( input , ( int ) size ) ; } @Deprecated public static byte [] toByteArray ( final Reader input ) throws IOException { return toByteArray ( input , Charset . defaultCharset () ) ; MST[NonVoidMethodCallMutator]MSP[] }
while ( remaining > 0 ) { final int location = length - remaining ; final int count = input . read ( buffer , offset + location , remaining ) ; if ( EOF == count ) { MST[NegateConditionalsMutator]MSP[] break; } remaining -= count ; }
skipByteBuffer . limit ( ( int ) Math . min ( remain , SKIP_BUFFER_SIZE ) ) ; final int n = input . read ( skipByteBuffer ) ; if ( n == EOF ) { MST[InlineConstantMutator]MSP[] break; } remain -= n ; } return toSkip - remain ; }
while ( EOF != ch ) { final int ch2 = input2 . read () ; if ( ch != ch2 ) { return false ; } ch = input1 . read () ; } final int ch2 = input2 . read () ; return ch2 == EOF ; MST[InlineConstantMutator]MSP[] }
skipByteBuffer . limit ( ( int ) Math . min ( remain , SKIP_BUFFER_SIZE ) ) ; final int n = input . read ( skipByteBuffer ) ; if ( n == EOF ) { break; } remain -= n ; } return toSkip - remain ; MST[MathMutator]MSP[] }
final int ch2 = input2 . read () ; if ( ch != ch2 ) { MST[rv.ABSMutator]MSP[] return false ; } ch = input1 . read () ; } final int ch2 = input2 . read () ; return ch2 == EOF ; }
Objects . requireNonNull ( appendable , lr_1 ) ; MST[ArgumentPropagationMutator]MSP[] if ( appendable instanceof Writer ) { return ( Writer ) appendable ; } if ( appendable instanceof StringBuilder ) { return new StringBuilderWriter ( ( StringBuilder ) appendable ) ; } return new AppendableWriter <> ( appendable ) ; }
if ( length == 0 ) { return 0 ; } final int bufferLength = buffer . length ; int bytesToRead = bufferLength ; if ( length > 0 && length < bufferLength ) { MST[rv.CRCR3Mutator]MSP[] bytesToRead = ( int ) length ; } int read ;
long totalRead = 0 ; while ( bytesToRead > 0 && EOF != ( read = input . read ( buffer , 0 , bytesToRead ) ) ) { output . write ( buffer , 0 , read ) ; totalRead += read ; MST[rv.UOI1Mutator]MSP[]
while ( remaining > 0 ) { final int location = length - remaining ; final int count = input . read ( buffer , offset + location , remaining ) ; MST[rv.UOI2Mutator]MSP[] if ( EOF == count ) { break; } remaining -= count ; }
if ( length > 0 ) { bytesToRead = ( int ) Math . min ( length - totalRead , bufferLength ) ; MST[rv.UOI4Mutator]MSP[] } } return totalRead ; } public static long copy ( final Reader input , final Appendable output , final CharBuffer buffer ) throws IOException {
public static long skip ( final ReadableByteChannel input , final long toSkip ) throws IOException { if ( toSkip < 0 ) { MST[rv.UOI3Mutator]MSP[] throw new IllegalArgumentException ( lr_6 + toSkip ) ; }
long totalRead = 0 ; MST[InlineConstantMutator]MSP[] while ( bytesToRead > 0 && EOF != ( read = input . read ( buffer , 0 , bytesToRead ) ) ) { output . write ( buffer , 0 , read ) ; totalRead += read ;
if ( toSkip < 0 ) { throw new IllegalArgumentException ( lr_7 + toSkip ) ; MST[NonVoidMethodCallMutator]MSP[] } final long skipped = skip ( input , toSkip ) ; if ( skipped != toSkip ) { throw new EOFException ( lr_8 + toSkip + lr_4 + skipped ) ; } }
public static BufferedInputStream buffer ( final InputStream inputStream , final int size ) { if ( inputStream == null ) { throw new NullPointerException () ; } return inputStream instanceof BufferedInputStream ? MST[rv.ROR5Mutator]MSP[] ( BufferedInputStream ) inputStream : new BufferedInputStream ( inputStream , size ) ; }
if ( inputOffset > 0 ) { skipFully ( input , inputOffset ) ; } if ( length == 0 ) { return 0 ; } int bytesToRead = buffer . length ; if ( length > 0 && length < buffer . length ) { MST[rv.CRCR1Mutator]MSP[]
if ( toSkip < 0 ) { throw new IllegalArgumentException ( lr_7 + toSkip ) ; } final long skipped = skip ( input , toSkip ) ; if ( skipped != toSkip ) { MST[rv.UOI1Mutator]MSP[] throw new EOFException ( lr_8 + toSkip + lr_4 + skipped ) ; } }
if ( EOF == count ) { break; } remaining -= count ; } return length - remaining ; MST[rv.UOI3Mutator]MSP[] } public static void readFully ( final InputStream input , final byte [] buffer ) throws IOException { readFully ( input , buffer , 0 , buffer . length ) ;
while ( offset < size && ( read = input . read ( data , offset , size - offset ) ) != EOF ) { MST[rv.UOI4Mutator]MSP[] offset += read ; } if ( offset != size ) {
throw new IOException ( lr_11 + offset + lr_12 + size ) ; } return data ; } public static byte [] toByteArray ( final InputStream input , final long size ) throws IOException { if ( size > Integer . MAX_VALUE ) { MST[rv.CRCR2Mutator]MSP[]
final byte [] bytes = input . getBytes ( Charsets . toCharset ( encoding ) ) ; MST[NonVoidMethodCallMutator]MSP[] return new ByteArrayInputStream ( bytes ) ; } @Deprecated public static String toString ( final byte [] input ) throws IOException {
long totalRead = 0 ; while ( bytesToRead > 0 && EOF != ( read = input . read ( buffer , 0 , bytesToRead ) ) ) { MST[rv.ROR4Mutator]MSP[] output . write ( buffer , 0 , read ) ; totalRead += read ;
while ( offset < size && ( read = input . read ( data , offset , size - offset ) ) != EOF ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] offset += read ; } if ( offset != size ) {
long count = 0 ; int n ; while ( EOF != ( n = input . read ( buffer ) ) ) { output . write ( buffer , 0 , n ) ; MST[rv.CRCR3Mutator]MSP[] count += n ; } return count ; }
skipByteBuffer . limit ( ( int ) Math . min ( remain , SKIP_BUFFER_SIZE ) ) ; final int n = input . read ( skipByteBuffer ) ; if ( n == EOF ) { MST[rv.UOI2Mutator]MSP[] break; } remain -= n ; } return toSkip - remain ; }
while ( EOF != ch ) { final int ch2 = input2 . read () ; if ( ch != ch2 ) { return false ; } ch = input1 . read () ; MST[NonVoidMethodCallMutator]MSP[] } final int ch2 = input2 . read () ; return ch2 == EOF ; }
bytesToRead = ( int ) length ; } int read ; long totalRead = 0 ; while ( bytesToRead > 0 && EOF != ( read = input . read ( buffer , 0 , bytesToRead ) ) ) { MST[rv.ROR1Mutator]MSP[]
if ( toSkip < 0 ) { throw new IllegalArgumentException ( lr_7 + toSkip ) ; } final long skipped = skip ( input , toSkip ) ; if ( skipped != toSkip ) { MST[rv.ABSMutator]MSP[] throw new EOFException ( lr_8 + toSkip + lr_4 + skipped ) ; } }
try ( InputStream inputStream = url . openStream () ) { return toString ( inputStream , encoding ) ; } } public static String toString ( final URL url , final String encoding ) throws IOException { return toString ( url , Charsets . toCharset ( encoding ) ) ; MST[EmptyObjectReturnValsMutator]MSP[]
while ( EOF != ch ) { final int ch2 = input2 . read () ; if ( ch != ch2 ) { MST[rv.ROR1Mutator]MSP[] return false ; } ch = input1 . read () ; } final int ch2 = input2 . read () ; return ch2 == EOF ; }
public static void write ( final CharSequence data , final Writer output ) throws IOException { if ( data != null ) { MST[rv.ROR5Mutator]MSP[] write ( data . toString () , output ) ; } } @Deprecated public static void write ( final String data , final OutputStream output )
bytesToRead = ( int ) length ; MST[rv.UOI3Mutator]MSP[] } int read ; long totalRead = 0 ; while ( bytesToRead > 0 && EOF != ( read = input . read ( buffer , 0 , bytesToRead ) ) ) {
final int count = input . read ( buffer ) ; if ( EOF == count ) { break; } } return length - buffer . remaining () ; MST[NonVoidMethodCallMutator]MSP[] } public static int read ( final Reader input , final char [] buffer ) throws IOException {
public static InputStream toBufferedInputStream ( final InputStream input ) throws IOException { return ByteArrayOutputStream . toBufferedInputStream ( input ) ; } public static InputStream toBufferedInputStream ( final InputStream input , final int size ) throws IOException { return ByteArrayOutputStream . toBufferedInputStream ( input , size ) ; MST[rv.ABSMutator]MSP[] }
final int actual = read ( input , buffer , offset , length ) ; if ( actual != length ) { MST[rv.UOI1Mutator]MSP[] throw new EOFException ( lr_3 + length + lr_4 + actual ) ; } } @Deprecated
output . write ( buffer , 0 , read ) ; totalRead += read ; if ( length > 0 ) { MST[rv.CRCR1Mutator]MSP[] bytesToRead = ( int ) Math . min ( length - totalRead , buffer . length ) ; } } return totalRead ; }
final Charset cs = Charsets . toCharset ( encoding ) ; for ( final Object line : lines ) { if ( line != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] output . write ( line . toString () . getBytes ( cs ) ) ; }
while ( EOF != ch ) { final int ch2 = input2 . read () ; if ( ch != ch2 ) { MST[rv.UOI1Mutator]MSP[] return false ; } ch = input1 . read () ; } final int ch2 = input2 . read () ; return ch2 == EOF ; }
long totalRead = 0 ; while ( bytesToRead > 0 && EOF != ( read = input . read ( buffer , 0 , bytesToRead ) ) ) { MST[rv.UOI4Mutator]MSP[] output . write ( buffer , 0 , read ) ; totalRead += read ;
final int actual = read ( input , buffer ) ; if ( actual != expected ) { MST[rv.ROR4Mutator]MSP[] throw new EOFException ( lr_3 + expected + lr_4 + actual ) ; } } public static void readFully ( final Reader input , final char [] buffer ) throws IOException {
public static LineIterator lineIterator ( final InputStream input , final String encoding ) throws IOException { return lineIterator ( input , Charsets . toCharset ( encoding ) ) ; MST[ReturnValsMutator]MSP[] } public static LineIterator lineIterator ( final Reader reader ) { return new LineIterator ( reader ) ; }
return read ( input , buffer , 0 , buffer . length ) ; MST[rv.CRCR5Mutator]MSP[] } public static int read ( final Reader input , final char [] buffer , final int offset , final int length ) throws IOException { if ( length < 0 ) {
if ( toSkip < 0 ) { throw new IllegalArgumentException ( lr_7 + toSkip ) ; } final long skipped = skip ( input , toSkip ) ; if ( skipped != toSkip ) { throw new EOFException ( lr_8 + toSkip + lr_4 + skipped ) ; MST[rv.ABSMutator]MSP[] } }
while ( EOF != ch ) { final int ch2 = input2 . read () ; if ( ch != ch2 ) { return false ; } ch = input1 . read () ; } final int ch2 = input2 . read () ; return ch2 == EOF ; MST[rv.ABSMutator]MSP[] }
bytesToRead = ( int ) length ; } int read ; long totalRead = 0 ; while ( bytesToRead > 0 && EOF != ( read = input . read ( buffer , 0 , bytesToRead ) ) ) { MST[rv.UOI1Mutator]MSP[]
public static void close ( final URLConnection conn ) { if ( conn instanceof HttpURLConnection ) { MST[rv.ROR2Mutator]MSP[] ( ( HttpURLConnection ) conn ) . disconnect () ; } } @Deprecated public static void closeQuietly ( final Closeable closeable ) { try { if ( closeable != null ) {
} return toSkip - remain ; } public static void skipFully ( final InputStream input , final long toSkip ) throws IOException { if ( toSkip < 0 ) { throw new IllegalArgumentException ( lr_7 + toSkip ) ; MST[ConstructorCallMutator]MSP[] }
bytesToRead = ( int ) length ; } int read ; long totalRead = 0 ; while ( bytesToRead > 0 && EOF != ( read = input . read ( buffer , 0 , bytesToRead ) ) ) { MST[rv.UOI3Mutator]MSP[]
input1 = new BufferedInputStream ( input1 ) ; } if ( ! ( input2 instanceof BufferedInputStream ) ) { MST[NegateConditionalsMutator]MSP[] input2 = new BufferedInputStream ( input2 ) ; } int ch = input1 . read () ; while ( EOF != ch ) {
long count = 0 ; int n ; while ( EOF != ( n = input . read ( buffer ) ) ) { MST[rv.ROR1Mutator]MSP[] buffer . flip () ; output . append ( buffer , 0 , n ) ; count += n ; } return count ; }
final long n = input . read ( SKIP_BYTE_BUFFER , 0 , ( int ) Math . min ( remain , SKIP_BUFFER_SIZE ) ) ; MST[rv.UOI3Mutator]MSP[] if ( n < 0 ) { break; } remain -= n ; } return toSkip - remain ; }
final int actual = read ( input , buffer , offset , length ) ; if ( actual != length ) { throw new EOFException ( lr_3 + length + lr_4 + actual ) ; MST[rv.ABSMutator]MSP[] } } @Deprecated
public static BufferedOutputStream buffer ( final OutputStream outputStream ) { if ( outputStream == null ) { throw new NullPointerException () ; } return outputStream instanceof BufferedOutputStream ? MST[NegateConditionalsMutator]MSP[] ( BufferedOutputStream ) outputStream : new BufferedOutputStream ( outputStream ) ; }
public static int read ( final InputStream input , final byte [] buffer , final int offset , final int length ) throws IOException { if ( length < 0 ) { throw new IllegalArgumentException ( lr_2 + length ) ; MST[rv.UOI4Mutator]MSP[] } int remaining = length ;
public static int read ( final InputStream input , final byte [] buffer ) throws IOException { return read ( input , buffer , 0 , buffer . length ) ; MST[rv.CRCR5Mutator]MSP[] }
int offset = 0 ; MST[rv.CRCR1Mutator]MSP[] while ( bytes > 0 ) { final int chunk = Math . min ( bytes , DEFAULT_BUFFER_SIZE ) ; output . write ( data , offset , chunk ) ; bytes -= chunk ; offset += chunk ; } } }
while ( EOF != ch ) { MST[rv.UOI1Mutator]MSP[] final int ch2 = input2 . read () ; if ( ch != ch2 ) { return false ; } ch = input1 . read () ; } final int ch2 = input2 . read () ; return ch2 == EOF ; }
skipByteBuffer . limit ( ( int ) Math . min ( remain , SKIP_BUFFER_SIZE ) ) ; final int n = input . read ( skipByteBuffer ) ; if ( n == EOF ) { MST[rv.ROR2Mutator]MSP[] break; } remain -= n ; } return toSkip - remain ; }
public static long copyLarge ( final InputStream input , final OutputStream output , final long inputOffset , final long length ) throws IOException { return copyLarge ( input , output , inputOffset , length , new byte [ DEFAULT_BUFFER_SIZE ] ) ; MST[rv.CRCR2Mutator]MSP[] }
public static InputStream toInputStream ( final String input , final Charset encoding ) { return new ByteArrayInputStream ( input . getBytes ( Charsets . toCharset ( encoding ) ) ) ; MST[NullReturnValsMutator]MSP[] } public static InputStream toInputStream ( final String input , final String encoding ) throws IOException {
if ( length == 0 ) { return 0 ; } final int bufferLength = buffer . length ; int bytesToRead = bufferLength ; if ( length > 0 && length < bufferLength ) { MST[rv.ROR1Mutator]MSP[] bytesToRead = ( int ) length ; } int read ;
long count = 0 ; int n ; while ( EOF != ( n = input . read ( buffer ) ) ) { output . write ( buffer , 0 , n ) ; count += n ; } return count ; MST[rv.UOI3Mutator]MSP[] }
String line1 = br1 . readLine () ; String line2 = br2 . readLine () ; while ( line1 != null && line2 != null && line1 . equals ( line2 ) ) { MST[NegateConditionalsMutator]MSP[] line1 = br1 . readLine () ; line2 = br2 . readLine () ; }
final int ch2 = input2 . read () ; if ( ch != ch2 ) { return false ; } ch = input1 . read () ; } final int ch2 = input2 . read () ; return ch2 == EOF ; MST[rv.UOI3Mutator]MSP[] }
return read ( input , buffer , 0 , buffer . length ) ; MST[ArgumentPropagationMutator]MSP[] } public static int read ( final Reader input , final char [] buffer , final int offset , final int length ) throws IOException { if ( length < 0 ) {
} return toSkip - remain ; MST[rv.UOI4Mutator]MSP[] } public static void skipFully ( final InputStream input , final long toSkip ) throws IOException { if ( toSkip < 0 ) { throw new IllegalArgumentException ( lr_7 + toSkip ) ; }
if ( length > 0 ) { bytesToRead = ( int ) Math . min ( length - totalRead , bufferLength ) ; MST[rv.UOI2Mutator]MSP[] } } return totalRead ; } public static long copy ( final Reader input , final Appendable output , final CharBuffer buffer ) throws IOException {
return line1 == null ? line2 == null ? true : false : line1 . equals ( line2 ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] } public static int copy ( final InputStream input , final OutputStream output ) throws IOException { final long count = copyLarge ( input , output ) ;
return length - remaining ; MST[rv.UOI3Mutator]MSP[] } public static int read ( final ReadableByteChannel input , final ByteBuffer buffer ) throws IOException { final int length = buffer . remaining () ; while ( buffer . remaining () > 0 ) {
if ( EOF == count ) { break; } remaining -= count ; MST[rv.UOI3Mutator]MSP[] } return length - remaining ; } public static void readFully ( final InputStream input , final byte [] buffer ) throws IOException { readFully ( input , buffer , 0 , buffer . length ) ;
return toInputStream ( input , Charsets . toCharset ( encoding ) ) ; } @Deprecated public static InputStream toInputStream ( final String input ) { return toInputStream ( input , Charset . defaultCharset () ) ; MST[NonVoidMethodCallMutator]MSP[] }
if ( inputOffset > 0 ) { skipFully ( input , inputOffset ) ; } if ( length == 0 ) { return 0 ; } int bytesToRead = buffer . length ; if ( length > 0 && length < buffer . length ) { MST[NegateConditionalsMutator]MSP[]
if ( EOF == count ) { break; } remaining -= count ; } return length - remaining ; MST[rv.UOI2Mutator]MSP[] } public static void readFully ( final InputStream input , final byte [] buffer ) throws IOException { readFully ( input , buffer , 0 , buffer . length ) ;
bytesToRead = ( int ) length ; } int read ; long totalRead = 0 ; while ( bytesToRead > 0 && EOF != ( read = input . read ( buffer , 0 , bytesToRead ) ) ) { MST[rv.CRCR6Mutator]MSP[]
while ( remaining > 0 ) { final int location = length - remaining ; MST[rv.UOI4Mutator]MSP[] final int count = input . read ( buffer , offset + location , remaining ) ; if ( EOF == count ) { break; } remaining -= count ; }
final int ch2 = input2 . read () ; if ( ch != ch2 ) { return false ; } ch = input1 . read () ; } final int ch2 = input2 . read () ; return ch2 == EOF ; MST[rv.CRCR5Mutator]MSP[] }
Objects . requireNonNull ( appendable , lr_1 ) ; if ( appendable instanceof Writer ) { MST[rv.ROR4Mutator]MSP[] return ( Writer ) appendable ; } if ( appendable instanceof StringBuilder ) { return new StringBuilderWriter ( ( StringBuilder ) appendable ) ; } return new AppendableWriter <> ( appendable ) ; }
final int ch2 = input2 . read () ; if ( ch != ch2 ) { MST[rv.UOI1Mutator]MSP[] return false ; } ch = input1 . read () ; } final int ch2 = input2 . read () ; return ch2 == EOF ; }
throw new IOException ( lr_5 + name ) ; } return resource ; } public static long skip ( final InputStream input , final long toSkip ) throws IOException { if ( toSkip < 0 ) { MST[rv.ROR4Mutator]MSP[] throw new IllegalArgumentException ( lr_6 + toSkip ) ; }
closeable . close () ; } } catch ( final IOException ioe ) { } } @Deprecated public static void closeQuietly ( final Closeable ... closeables ) { if ( closeables == null ) { return; } for ( final Closeable closeable : closeables ) { MST[rv.ABSMutator]MSP[]
public static void skipFully ( final Reader input , final long toSkip ) throws IOException { final long skipped = skip ( input , toSkip ) ; if ( skipped != toSkip ) { MST[rv.ROR4Mutator]MSP[] throw new EOFException ( lr_9 + toSkip + lr_4 + skipped ) ; } }
public static void writeChunked ( final char [] data , final Writer output ) throws IOException { if ( data != null ) { int bytes = data . length ; int offset = 0 ; MST[rv.CRCR5Mutator]MSP[] while ( bytes > 0 ) {
readFully ( input , buffer , 0 , buffer . length ) ; MST[rv.CRCR5Mutator]MSP[] return buffer ; } public static void readFully ( final ReadableByteChannel input , final ByteBuffer buffer ) throws IOException { final int expected = buffer . remaining () ;
try ( final StringBuilderWriter sw = new StringBuilderWriter () ) { copy ( input , sw , encoding ) ; return sw . toString () ; MST[ReturnValsMutator]MSP[] } } public static String toString ( final InputStream input , final String encoding ) throws IOException {
skipByteBuffer . limit ( ( int ) Math . min ( remain , SKIP_BUFFER_SIZE ) ) ; final int n = input . read ( skipByteBuffer ) ; if ( n == EOF ) { break; } remain -= n ; MST[rv.UOI1Mutator]MSP[] } return toSkip - remain ; }
throw new IllegalArgumentException ( lr_13 + size ) ; MST[rv.UOI3Mutator]MSP[] } return toByteArray ( input , ( int ) size ) ; } @Deprecated public static byte [] toByteArray ( final Reader input ) throws IOException { return toByteArray ( input , Charset . defaultCharset () ) ; }
} public static void readFully ( final InputStream input , final byte [] buffer , final int offset , final int length ) throws IOException { final int actual = read ( input , buffer , offset , length ) ; if ( actual != length ) { MST[rv.ROR2Mutator]MSP[]
if ( toSkip < 0 ) { throw new IllegalArgumentException ( lr_7 + toSkip ) ; } final long skipped = skip ( input , toSkip ) ; if ( skipped != toSkip ) { throw new EOFException ( lr_8 + toSkip + lr_4 + skipped ) ; MST[rv.UOI2Mutator]MSP[] } }
while ( offset < size && ( read = input . read ( data , offset , size - offset ) ) != EOF ) { offset += read ; MST[rv.AOR1Mutator]MSP[] } if ( offset != size ) {
public static void write ( final CharSequence data , final Writer output ) throws IOException { if ( data != null ) { MST[NegateConditionalsMutator]MSP[] write ( data . toString () , output ) ; } } @Deprecated public static void write ( final String data , final OutputStream output )
while ( EOF != ch ) { final int ch2 = input2 . read () ; if ( ch != ch2 ) { return false ; } ch = input1 . read () ; } final int ch2 = input2 . read () ; return ch2 == EOF ; MST[rv.CRCR4Mutator]MSP[] }
while ( remaining > 0 ) { final int location = length - remaining ; MST[rv.UOI3Mutator]MSP[] final int count = input . read ( buffer , offset + location , remaining ) ; if ( EOF == count ) { break; } remaining -= count ; }
while ( offset < size && ( read = input . read ( data , offset , size - offset ) ) != EOF ) { offset += read ; MST[rv.UOI1Mutator]MSP[] } if ( offset != size ) {
public static BufferedInputStream buffer ( final InputStream inputStream , final int size ) { if ( inputStream == null ) { throw new NullPointerException () ; } return inputStream instanceof BufferedInputStream ? MST[NegateConditionalsMutator]MSP[] ( BufferedInputStream ) inputStream : new BufferedInputStream ( inputStream , size ) ; }
output . write ( buffer , 0 , read ) ; totalRead += read ; MST[rv.UOI4Mutator]MSP[] if ( length > 0 ) { bytesToRead = ( int ) Math . min ( length - totalRead , buffer . length ) ; } } return totalRead ; }
skipByteBuffer . limit ( ( int ) Math . min ( remain , SKIP_BUFFER_SIZE ) ) ; MST[rv.CRCR1Mutator]MSP[] final int n = input . read ( skipByteBuffer ) ; if ( n == EOF ) { break; } remain -= n ; } return toSkip - remain ; }
final int actual = read ( input , buffer , offset , length ) ; if ( actual != length ) { throw new EOFException ( lr_3 + length + lr_4 + actual ) ; MST[rv.UOI2Mutator]MSP[] } } @Deprecated
if ( inputOffset > 0 ) { skipFully ( input , inputOffset ) ; MST[rv.ABSMutator]MSP[] } if ( length == 0 ) { return 0 ; } int bytesToRead = buffer . length ; if ( length > 0 && length < buffer . length ) {
if ( length > 0 ) { MST[rv.ROR2Mutator]MSP[] bytesToRead = ( int ) Math . min ( length - totalRead , bufferLength ) ; } } return totalRead ; } public static long copy ( final Reader input , final Appendable output , final CharBuffer buffer ) throws IOException {
long totalRead = 0 ; while ( bytesToRead > 0 && EOF != ( read = input . read ( buffer , 0 , bytesToRead ) ) ) { output . write ( buffer , 0 , read ) ; MST[rv.CRCR1Mutator]MSP[] totalRead += read ;
if ( toSkip < 0 ) { throw new IllegalArgumentException ( lr_7 + toSkip ) ; } final long skipped = skip ( input , toSkip ) ; if ( skipped != toSkip ) { MST[rv.UOI2Mutator]MSP[] throw new EOFException ( lr_8 + toSkip + lr_4 + skipped ) ; } }
return reader instanceof BufferedReader ? ( BufferedReader ) reader : new BufferedReader ( reader , size ) ; MST[rv.UOI3Mutator]MSP[] } public static BufferedWriter buffer ( final Writer writer ) { return writer instanceof BufferedWriter ? ( BufferedWriter ) writer : new BufferedWriter ( writer ) ; }
final long skipped = skip ( input , toSkip ) ; MST[rv.UOI1Mutator]MSP[] if ( skipped != toSkip ) { throw new EOFException ( lr_8 + toSkip + lr_4 + skipped ) ; } } public static void skipFully ( final ReadableByteChannel input , final long toSkip ) throws IOException {
final long skipped = skip ( input , toSkip ) ; if ( skipped != toSkip ) { MST[rv.UOI3Mutator]MSP[] throw new EOFException ( lr_8 + toSkip + lr_4 + skipped ) ; } } public static void skipFully ( final ReadableByteChannel input , final long toSkip ) throws IOException {
String line1 = br1 . readLine () ; String line2 = br2 . readLine () ; while ( line1 != null && line2 != null && line1 . equals ( line2 ) ) { line1 = br1 . readLine () ; line2 = br2 . readLine () ; MST[NonVoidMethodCallMutator]MSP[] }
final int actual = read ( input , buffer ) ; if ( actual != expected ) { throw new EOFException ( lr_3 + expected + lr_4 + actual ) ; MST[rv.UOI1Mutator]MSP[] } } public static void readFully ( final Reader input , final char [] buffer ) throws IOException {
throw new EOFException ( lr_3 + length + lr_4 + actual ) ; } } public static byte [] readFully ( final InputStream input , final int length ) throws IOException { final byte [] buffer = new byte [ length ] ; MST[rv.UOI1Mutator]MSP[]
final int actual = read ( input , buffer , offset , length ) ; if ( actual != length ) { throw new EOFException ( lr_3 + length + lr_4 + actual ) ; MST[experimental.NakedReceiverMutator]MSP[] } } @Deprecated
public static BufferedOutputStream buffer ( final OutputStream outputStream ) { if ( outputStream == null ) { throw new NullPointerException () ; } return outputStream instanceof BufferedOutputStream ? MST[rv.ROR5Mutator]MSP[] ( BufferedOutputStream ) outputStream : new BufferedOutputStream ( outputStream ) ; }
if ( inputOffset > 0 ) { MST[rv.CRCR3Mutator]MSP[] skipFully ( input , inputOffset ) ; } if ( length == 0 ) { return 0 ; } int bytesToRead = buffer . length ; if ( length > 0 && length < buffer . length ) {
public static BufferedReader buffer ( final Reader reader ) { return reader instanceof BufferedReader ? ( BufferedReader ) reader : new BufferedReader ( reader ) ; MST[NegateConditionalsMutator]MSP[] } public static BufferedReader buffer ( final Reader reader , final int size ) {
throw new IOException ( lr_5 + name ) ; } return resource ; } public static long skip ( final InputStream input , final long toSkip ) throws IOException { if ( toSkip < 0 ) { throw new IllegalArgumentException ( lr_6 + toSkip ) ; MST[ConstructorCallMutator]MSP[] }
return input . getBytes ( Charset . defaultCharset () ) ; } public static byte [] toByteArray ( final URI uri ) throws IOException { return IOUtils . toByteArray ( uri . toURL () ) ; MST[ReturnValsMutator]MSP[] } public static byte [] toByteArray ( final URL url ) throws IOException {
skipByteBuffer . limit ( ( int ) Math . min ( remain , SKIP_BUFFER_SIZE ) ) ; final int n = input . read ( skipByteBuffer ) ; if ( n == EOF ) { MST[rv.ABSMutator]MSP[] break; } remain -= n ; } return toSkip - remain ; }
final int chunk = Math . min ( bytes , DEFAULT_BUFFER_SIZE ) ; MST[rv.UOI2Mutator]MSP[] output . write ( data , offset , chunk ) ; bytes -= chunk ; offset += chunk ; } } } @Deprecated
throw new IllegalArgumentException ( lr_2 + length ) ; } int remaining = length ; while ( remaining > 0 ) { final int location = length - remaining ; final int count = input . read ( buffer , offset + location , remaining ) ; MST[rv.AOR3Mutator]MSP[]
while ( offset < size && ( read = input . read ( data , offset , size - offset ) ) != EOF ) { MST[rv.UOI1Mutator]MSP[] offset += read ; } if ( offset != size ) {
output . write ( buffer , 0 , read ) ; totalRead += read ; if ( length > 0 ) { MST[NegateConditionalsMutator]MSP[] bytesToRead = ( int ) Math . min ( length - totalRead , buffer . length ) ; } } return totalRead ; }
return reader instanceof BufferedReader ? ( BufferedReader ) reader : new BufferedReader ( reader , size ) ; } public static BufferedWriter buffer ( final Writer writer ) { return writer instanceof BufferedWriter ? ( BufferedWriter ) writer : new BufferedWriter ( writer ) ; MST[rv.ROR2Mutator]MSP[] }
return toString ( resourceToURL ( name , classLoader ) , encoding ) ; MST[NonVoidMethodCallMutator]MSP[] } public static URL resourceToURL ( final String name ) throws IOException { return resourceToURL ( name , null ) ; }
String line1 = br1 . readLine () ; String line2 = br2 . readLine () ; while ( line1 != null && line2 != null && line1 . equals ( line2 ) ) { MST[rv.ROR5Mutator]MSP[] line1 = br1 . readLine () ; line2 = br2 . readLine () ; }
return line1 == null ? line2 == null ? true : false : line1 . equals ( line2 ) ; MST[rv.CRCR3Mutator]MSP[] } public static int copy ( final InputStream input , final OutputStream output ) throws IOException { final long count = copyLarge ( input , output ) ;
return reader instanceof BufferedReader ? ( BufferedReader ) reader : new BufferedReader ( reader , size ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] } public static byte [] toByteArray ( final InputStream input ) throws IOException { try ( final ByteArrayOutputStream output = new ByteArrayOutputStream () ) { copy ( input , output ) ;
throw new IOException ( lr_5 + name ) ; MST[experimental.NakedReceiverMutator]MSP[] } return resource ; } public static long skip ( final InputStream input , final long toSkip ) throws IOException { if ( toSkip < 0 ) { throw new IllegalArgumentException ( lr_6 + toSkip ) ; }
final long n = input . read ( SKIP_BYTE_BUFFER , 0 , ( int ) Math . min ( remain , SKIP_BUFFER_SIZE ) ) ; if ( n < 0 ) { break; } remain -= n ; MST[rv.UOI1Mutator]MSP[] } return toSkip - remain ; }
if ( length == 0 ) { return 0 ; MST[ReturnValsMutator]MSP[] } final int bufferLength = buffer . length ; int bytesToRead = bufferLength ; if ( length > 0 && length < bufferLength ) { bytesToRead = ( int ) length ; } int read ;
if ( data != null ) { output . write ( data . toString () ) ; } } public static void writeChunked ( final byte [] data , final OutputStream output ) throws IOException { if ( data != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] int bytes = data . length ;
public static BufferedOutputStream buffer ( final OutputStream outputStream , final int size ) { if ( outputStream == null ) { throw new NullPointerException () ; } return outputStream instanceof BufferedOutputStream ? MST[rv.ROR3Mutator]MSP[] ( BufferedOutputStream ) outputStream : new BufferedOutputStream ( outputStream , size ) ; }
skipByteBuffer . limit ( ( int ) Math . min ( remain , SKIP_BUFFER_SIZE ) ) ; final int n = input . read ( skipByteBuffer ) ; if ( n == EOF ) { MST[rv.CRCR4Mutator]MSP[] break; } remain -= n ; } return toSkip - remain ; }
public static URL resourceToURL ( final String name , final ClassLoader classLoader ) throws IOException { final URL resource = classLoader == null ? IOUtils . class . getResource ( name ) : classLoader . getResource ( name ) ; MST[NonVoidMethodCallMutator]MSP[] if ( resource == null ) {
if ( toSkip < 0 ) { throw new IllegalArgumentException ( lr_7 + toSkip ) ; } final long skipped = skip ( input , toSkip ) ; if ( skipped != toSkip ) { throw new EOFException ( lr_8 + toSkip + lr_4 + skipped ) ; MST[NonVoidMethodCallMutator]MSP[] } }
skipByteBuffer . limit ( ( int ) Math . min ( remain , SKIP_BUFFER_SIZE ) ) ; final int n = input . read ( skipByteBuffer ) ; if ( n == EOF ) { break; } remain -= n ; MST[rv.ABSMutator]MSP[] } return toSkip - remain ; }
closeable . close () ; } } catch ( final IOException ioe ) { } } @Deprecated public static void closeQuietly ( final Closeable ... closeables ) { if ( closeables == null ) { return; } for ( final Closeable closeable : closeables ) { MST[rv.UOI3Mutator]MSP[]
while ( offset < size && ( read = input . read ( data , offset , size - offset ) ) != EOF ) { MST[NegateConditionalsMutator]MSP[] offset += read ; } if ( offset != size ) {
} public static void readFully ( final InputStream input , final byte [] buffer , final int offset , final int length ) throws IOException { final int actual = read ( input , buffer , offset , length ) ; if ( actual != length ) { MST[rv.UOI1Mutator]MSP[]
} } @Deprecated public static String toString ( final URI uri ) throws IOException { return toString ( uri , Charset . defaultCharset () ) ; MST[ReturnValsMutator]MSP[] } public static String toString ( final URI uri , final Charset encoding ) throws IOException {
final int actual = read ( input , buffer , offset , length ) ; if ( actual != length ) { throw new EOFException ( lr_3 + length + lr_4 + actual ) ; MST[NonVoidMethodCallMutator]MSP[] } } @Deprecated
writeLines ( lines , lineEnding , output , Charsets . toCharset ( encoding ) ) ; } public static void writeLines ( final Collection < ? > lines , String lineEnding , final Writer writer ) throws IOException { if ( lines == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return; }
if ( inputOffset > 0 ) { MST[rv.ROR1Mutator]MSP[] skipFully ( input , inputOffset ) ; } if ( length == 0 ) { return 0 ; } int bytesToRead = buffer . length ; if ( length > 0 && length < buffer . length ) {
public static void skipFully ( final Reader input , final long toSkip ) throws IOException { final long skipped = skip ( input , toSkip ) ; if ( skipped != toSkip ) { MST[rv.UOI4Mutator]MSP[] throw new EOFException ( lr_9 + toSkip + lr_4 + skipped ) ; } }
} catch ( final IOException ioe ) { } } } @Deprecated public static void closeQuietly ( final ServerSocket sock ) { if ( sock != null ) { try { sock . close () ; MST[VoidMethodCallMutator]MSP[] } catch ( final IOException ioe ) { } } } @Deprecated
final ByteBuffer skipByteBuffer = ByteBuffer . allocate ( ( int ) Math . min ( toSkip , SKIP_BUFFER_SIZE ) ) ; MST[rv.CRCR2Mutator]MSP[] long remain = toSkip ; while ( remain > 0 ) { skipByteBuffer . position ( 0 ) ;
final int ch2 = input2 . read () ; if ( ch != ch2 ) { return false ; MST[rv.CRCR1Mutator]MSP[] } ch = input1 . read () ; } final int ch2 = input2 . read () ; return ch2 == EOF ; }
return output . toByteArray () ; } } public static byte [] toByteArray ( final InputStream input , final int size ) throws IOException { if ( size < 0 ) { throw new IllegalArgumentException ( lr_10 + size ) ; } if ( size == 0 ) { MST[rv.UOI3Mutator]MSP[]
final long n = input . read ( SKIP_BYTE_BUFFER , 0 , ( int ) Math . min ( remain , SKIP_BUFFER_SIZE ) ) ; if ( n < 0 ) { break; } remain -= n ; } return toSkip - remain ; MST[MathMutator]MSP[] }
public static long skip ( final Reader input , final long toSkip ) throws IOException { if ( toSkip < 0 ) { MST[InlineConstantMutator]MSP[] throw new IllegalArgumentException ( lr_6 + toSkip ) ; } if ( SKIP_CHAR_BUFFER == null ) { SKIP_CHAR_BUFFER = new char [ SKIP_BUFFER_SIZE ] ; }
public static int length ( final byte [] array ) { return array == null ? 0 : array . length ; } public static int length ( final char [] array ) { return array == null ? 0 : array . length ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] }
public static InputStream toBufferedInputStream ( final InputStream input ) throws IOException { return ByteArrayOutputStream . toBufferedInputStream ( input ) ; } public static InputStream toBufferedInputStream ( final InputStream input , final int size ) throws IOException { return ByteArrayOutputStream . toBufferedInputStream ( input , size ) ; MST[NullReturnValsMutator]MSP[] }
String line1 = br1 . readLine () ; String line2 = br2 . readLine () ; while ( line1 != null && line2 != null && line1 . equals ( line2 ) ) { MST[rv.ROR1Mutator]MSP[] line1 = br1 . readLine () ; line2 = br2 . readLine () ; }
output . write ( buffer , 0 , read ) ; totalRead += read ; if ( length > 0 ) { bytesToRead = ( int ) Math . min ( length - totalRead , buffer . length ) ; MST[rv.AOR1Mutator]MSP[] } } return totalRead ; }
long totalRead = 0 ; while ( bytesToRead > 0 && EOF != ( read = input . read ( buffer , 0 , bytesToRead ) ) ) { output . write ( buffer , 0 , read ) ; totalRead += read ; MST[MathMutator]MSP[]
final long n = input . read ( SKIP_BYTE_BUFFER , 0 , ( int ) Math . min ( remain , SKIP_BUFFER_SIZE ) ) ; MST[ArgumentPropagationMutator]MSP[] if ( n < 0 ) { break; } remain -= n ; } return toSkip - remain ; }
return new byte [ 0 ] ; } final byte [] data = new byte [ size ] ; MST[rv.ABSMutator]MSP[] int offset = 0 ; int read ;
return length - remaining ; MST[rv.ABSMutator]MSP[] } public static int read ( final ReadableByteChannel input , final ByteBuffer buffer ) throws IOException { final int length = buffer . remaining () ; while ( buffer . remaining () > 0 ) {
public static void write ( final char [] data , final OutputStream output , final Charset encoding ) throws IOException { if ( data != null ) { output . write ( new String ( data ) . getBytes ( Charsets . toCharset ( encoding ) ) ) ; MST[NonVoidMethodCallMutator]MSP[] }
public static void skipFully ( final Reader input , final long toSkip ) throws IOException { final long skipped = skip ( input , toSkip ) ; if ( skipped != toSkip ) { throw new EOFException ( lr_9 + toSkip + lr_4 + skipped ) ; MST[rv.UOI4Mutator]MSP[] } }
int offset = 0 ; while ( bytes > 0 ) { final int chunk = Math . min ( bytes , DEFAULT_BUFFER_SIZE ) ; output . write ( data , offset , chunk ) ; bytes -= chunk ; MST[rv.UOI1Mutator]MSP[] offset += chunk ; } } }
while ( remaining > 0 ) { final int location = length - remaining ; MST[rv.AOD1Mutator]MSP[] final int count = input . read ( buffer , offset + location , remaining ) ; if ( EOF == count ) { break; } remaining -= count ; }
public static void closeQuietly ( final Reader input ) { closeQuietly ( ( Closeable ) input ) ; } @Deprecated public static void closeQuietly ( final Selector selector ) { if ( selector != null ) { try { selector . close () ; MST[VoidMethodCallMutator]MSP[]
final int count = input . read ( buffer ) ; if ( EOF == count ) { break; } } return length - buffer . remaining () ; MST[rv.UOI1Mutator]MSP[] } public static int read ( final Reader input , final char [] buffer ) throws IOException {
String line1 = br1 . readLine () ; String line2 = br2 . readLine () ; while ( line1 != null && line2 != null && line1 . equals ( line2 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] line1 = br1 . readLine () ; line2 = br2 . readLine () ; }
if ( inputOffset > 0 ) { skipFully ( input , inputOffset ) ; } if ( length == 0 ) { return 0 ; } int bytesToRead = buffer . length ; if ( length > 0 && length < buffer . length ) { MST[rv.ROR1Mutator]MSP[]
final long n = input . read ( SKIP_BYTE_BUFFER , 0 , ( int ) Math . min ( remain , SKIP_BUFFER_SIZE ) ) ; MST[rv.CRCR4Mutator]MSP[] if ( n < 0 ) { break; } remain -= n ; } return toSkip - remain ; }
return copyLarge ( input , output , new byte [ bufferSize ] ) ; MST[rv.ABSMutator]MSP[] } @Deprecated public static void copy ( final InputStream input , final Writer output ) throws IOException { copy ( input , output , Charset . defaultCharset () ) ; }
while ( remaining > 0 ) { final int location = length - remaining ; final int count = input . read ( buffer , offset + location , remaining ) ; MST[rv.AOD2Mutator]MSP[] if ( EOF == count ) { break; } remaining -= count ; }
return length - remaining ; } public static int read ( final ReadableByteChannel input , final ByteBuffer buffer ) throws IOException { final int length = buffer . remaining () ; while ( buffer . remaining () > 0 ) { MST[NonVoidMethodCallMutator]MSP[]
copy ( input , output , Charsets . toCharset ( outputEncoding ) ) ; } public static long copy ( final Reader input , final Appendable output ) throws IOException { return copy ( input , output , CharBuffer . allocate ( DEFAULT_BUFFER_SIZE ) ) ; MST[NonVoidMethodCallMutator]MSP[] }
if ( count > Integer . MAX_VALUE ) { return - 1 ; MST[rv.CRCR1Mutator]MSP[] } return ( int ) count ; } public static long copy ( final InputStream input , final OutputStream output , final int bufferSize ) throws IOException {
if ( length == 0 ) { MST[rv.UOI4Mutator]MSP[] return 0 ; } final int bufferLength = buffer . length ; int bytesToRead = bufferLength ; if ( length > 0 && length < bufferLength ) { bytesToRead = ( int ) length ; } int read ;
if ( length > 0 ) { bytesToRead = ( int ) Math . min ( length - totalRead , bufferLength ) ; MST[rv.AOD2Mutator]MSP[] } } return totalRead ; } public static long copy ( final Reader input , final Appendable output , final CharBuffer buffer ) throws IOException {
final int chunk = Math . min ( bytes , DEFAULT_BUFFER_SIZE ) ; output . write ( data , offset , chunk ) ; MST[rv.UOI3Mutator]MSP[] bytes -= chunk ; offset += chunk ; } } } @Deprecated
return new byte [ 0 ] ; } final byte [] data = new byte [ size ] ; MST[rv.UOI2Mutator]MSP[] int offset = 0 ; int read ;
final long n = input . read ( SKIP_BYTE_BUFFER , 0 , ( int ) Math . min ( remain , SKIP_BUFFER_SIZE ) ) ; if ( n < 0 ) { break; } remain -= n ; MST[rv.AOR1Mutator]MSP[] } return toSkip - remain ; }
final long skipped = skip ( input , toSkip ) ; if ( skipped != toSkip ) { throw new EOFException ( lr_8 + toSkip + lr_4 + skipped ) ; MST[experimental.NakedReceiverMutator]MSP[] } } public static void skipFully ( final ReadableByteChannel input , final long toSkip ) throws IOException {
int offset = 0 ; while ( bytes > 0 ) { MST[rv.ABSMutator]MSP[] final int chunk = Math . min ( bytes , DEFAULT_BUFFER_SIZE ) ; output . write ( data , offset , chunk ) ; bytes -= chunk ; offset += chunk ; } } }
if ( inputOffset > 0 ) { skipFully ( input , inputOffset ) ; } if ( length == 0 ) { MST[rv.CRCR6Mutator]MSP[] return 0 ; } int bytesToRead = buffer . length ; if ( length > 0 && length < buffer . length ) {
if ( length == 0 ) { return 0 ; } final int bufferLength = buffer . length ; int bytesToRead = bufferLength ; if ( length > 0 && length < bufferLength ) { MST[rv.ROR4Mutator]MSP[] bytesToRead = ( int ) length ; } int read ;
int offset = 0 ; while ( bytes > 0 ) { final int chunk = Math . min ( bytes , DEFAULT_BUFFER_SIZE ) ; output . write ( data , offset , chunk ) ; bytes -= chunk ; offset += chunk ; MST[rv.AOR3Mutator]MSP[] } } }
write ( data , output , Charsets . toCharset ( encoding ) ) ; } public static void write ( final String data , final Writer output ) throws IOException { if ( data != null ) { output . write ( data ) ; MST[VoidMethodCallMutator]MSP[] } } @Deprecated
if ( inputOffset > 0 ) { skipFully ( input , inputOffset ) ; } if ( length == 0 ) { return 0 ; } int bytesToRead = buffer . length ; if ( length > 0 && length < buffer . length ) { MST[rv.UOI3Mutator]MSP[]
final int actual = read ( input , buffer ) ; if ( actual != expected ) { MST[rv.UOI4Mutator]MSP[] throw new EOFException ( lr_3 + expected + lr_4 + actual ) ; } } public static void readFully ( final Reader input , final char [] buffer ) throws IOException {
public static void write ( final byte [] data , final Writer output , final Charset encoding ) throws IOException { if ( data != null ) { output . write ( new String ( data , Charsets . toCharset ( encoding ) ) ) ; MST[VoidMethodCallMutator]MSP[] } }
public static long skip ( final Reader input , final long toSkip ) throws IOException { if ( toSkip < 0 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[] throw new IllegalArgumentException ( lr_6 + toSkip ) ; } if ( SKIP_CHAR_BUFFER == null ) { SKIP_CHAR_BUFFER = new char [ SKIP_BUFFER_SIZE ] ; }
if ( SKIP_BYTE_BUFFER == null ) { SKIP_BYTE_BUFFER = new byte [ SKIP_BUFFER_SIZE ] ; } long remain = toSkip ; MST[rv.UOI1Mutator]MSP[] while ( remain > 0 ) {
int offset = 0 ; while ( bytes > 0 ) { final int chunk = Math . min ( bytes , DEFAULT_BUFFER_SIZE ) ; output . write ( data , offset , chunk ) ; bytes -= chunk ; MST[rv.ABSMutator]MSP[] offset += chunk ; } } }
while ( EOF != ch ) { final int ch2 = input2 . read () ; if ( ch != ch2 ) { return false ; } ch = input1 . read () ; } final int ch2 = input2 . read () ; MST[NonVoidMethodCallMutator]MSP[] return ch2 == EOF ; }
final int actual = read ( input , buffer , offset , length ) ; if ( actual != length ) { MST[rv.UOI1Mutator]MSP[] throw new EOFException ( lr_3 + length + lr_4 + actual ) ; } } @Deprecated
public static void skipFully ( final Reader input , final long toSkip ) throws IOException { final long skipped = skip ( input , toSkip ) ; if ( skipped != toSkip ) { MST[rv.UOI3Mutator]MSP[] throw new EOFException ( lr_9 + toSkip + lr_4 + skipped ) ; } }
throw new IOException ( lr_5 + name ) ; } return resource ; } public static long skip ( final InputStream input , final long toSkip ) throws IOException { if ( toSkip < 0 ) { MST[rv.UOI4Mutator]MSP[] throw new IllegalArgumentException ( lr_6 + toSkip ) ; }
input1 = new BufferedInputStream ( input1 ) ; } if ( ! ( input2 instanceof BufferedInputStream ) ) { input2 = new BufferedInputStream ( input2 ) ; } int ch = input1 . read () ; while ( EOF != ch ) { MST[rv.ROR4Mutator]MSP[]
output . write ( buffer , 0 , read ) ; MST[rv.CRCR5Mutator]MSP[] totalRead += read ; if ( length > 0 ) { bytesToRead = ( int ) Math . min ( length - totalRead , buffer . length ) ; } } return totalRead ; }
public static void write ( final char [] data , final OutputStream output ) throws IOException { write ( data , output , Charset . defaultCharset () ) ; MST[VoidMethodCallMutator]MSP[] }
throw new EOFException ( lr_3 + length + lr_4 + actual ) ; MST[rv.UOI2Mutator]MSP[] } } public static byte [] readFully ( final InputStream input , final int length ) throws IOException { final byte [] buffer = new byte [ length ] ;
public static boolean contentEquals ( Reader input1 , Reader input2 ) throws IOException { if ( input1 == input2 ) { return true ; MST[BooleanFalseReturnValsMutator]MSP[] } input1 = toBufferedReader ( input1 ) ; input2 = toBufferedReader ( input2 ) ; int ch = input1 . read () ;
while ( EOF != ch ) { final int ch2 = input2 . read () ; if ( ch != ch2 ) { return false ; } ch = input1 . read () ; } final int ch2 = input2 . read () ; return ch2 == EOF ; MST[rv.CRCR2Mutator]MSP[] }
} return toSkip - remain ; } public static void skipFully ( final InputStream input , final long toSkip ) throws IOException { if ( toSkip < 0 ) { throw new IllegalArgumentException ( lr_7 + toSkip ) ; MST[rv.UOI1Mutator]MSP[] }
public static long copyLarge ( final InputStream input , final OutputStream output , final long inputOffset , final long length , final byte [] buffer ) throws IOException { if ( inputOffset > 0 ) { MST[rv.ROR5Mutator]MSP[] skipFully ( input , inputOffset ) ; }
if ( inputOffset > 0 ) { skipFully ( input , inputOffset ) ; } if ( length == 0 ) { MST[rv.ROR5Mutator]MSP[] return 0 ; } int bytesToRead = buffer . length ; if ( length > 0 && length < buffer . length ) {
if ( toSkip < 0 ) { throw new IllegalArgumentException ( lr_7 + toSkip ) ; } final long skipped = skip ( input , toSkip ) ; if ( skipped != toSkip ) { MST[rv.ROR2Mutator]MSP[] throw new EOFException ( lr_8 + toSkip + lr_4 + skipped ) ; } }
long remain = toSkip ; while ( remain > 0 ) { final long n = input . read ( SKIP_CHAR_BUFFER , 0 , ( int ) Math . min ( remain , SKIP_BUFFER_SIZE ) ) ; MST[InlineConstantMutator]MSP[] if ( n < 0 ) { break; } remain -= n ;
return copyLarge ( input , output , inputOffset , length , new char [ DEFAULT_BUFFER_SIZE ] ) ; MST[rv.UOI4Mutator]MSP[] } public static long copyLarge ( final Reader input , final Writer output , final long inputOffset , final long length , final char [] buffer ) throws IOException {
long remain = toSkip ; while ( remain > 0 ) { final long n = input . read ( SKIP_CHAR_BUFFER , 0 , ( int ) Math . min ( remain , SKIP_BUFFER_SIZE ) ) ; MST[rv.CRCR3Mutator]MSP[] if ( n < 0 ) { break; } remain -= n ;
final long n = input . read ( SKIP_BYTE_BUFFER , 0 , ( int ) Math . min ( remain , SKIP_BUFFER_SIZE ) ) ; if ( n < 0 ) { break; } remain -= n ; MST[rv.UOI2Mutator]MSP[] } return toSkip - remain ; }
final int ch2 = input2 . read () ; if ( ch != ch2 ) { return false ; } ch = input1 . read () ; } final int ch2 = input2 . read () ; return ch2 == EOF ; MST[BooleanTrueReturnValsMutator]MSP[] }
final int ch2 = input2 . read () ; if ( ch != ch2 ) { return false ; } ch = input1 . read () ; } final int ch2 = input2 . read () ; return ch2 == EOF ; MST[rv.CRCR4Mutator]MSP[] }
public static BufferedOutputStream buffer ( final OutputStream outputStream ) { if ( outputStream == null ) { throw new NullPointerException () ; } return outputStream instanceof BufferedOutputStream ? MST[NullReturnValsMutator]MSP[] ( BufferedOutputStream ) outputStream : new BufferedOutputStream ( outputStream ) ; }
public static InputStream toInputStream ( final CharSequence input , final Charset encoding ) { return toInputStream ( input . toString () , encoding ) ; MST[NonVoidMethodCallMutator]MSP[] } public static InputStream toInputStream ( final CharSequence input , final String encoding ) throws IOException {
public static int length ( final byte [] array ) { return array == null ? 0 : array . length ; } public static int length ( final char [] array ) { return array == null ? 0 : array . length ; MST[rv.CRCR5Mutator]MSP[] }
public static String resourceToString ( final String name , final Charset encoding ) throws IOException { return resourceToString ( name , encoding , null ) ; MST[ArgumentPropagationMutator]MSP[] } public static String resourceToString ( final String name , final Charset encoding , final ClassLoader classLoader ) throws IOException {
if ( toSkip < 0 ) { throw new IllegalArgumentException ( lr_7 + toSkip ) ; MST[experimental.NakedReceiverMutator]MSP[] } final long skipped = skip ( input , toSkip ) ; if ( skipped != toSkip ) { throw new EOFException ( lr_8 + toSkip + lr_4 + skipped ) ; } }
long remain = toSkip ; while ( remain > 0 ) { final long n = input . read ( SKIP_CHAR_BUFFER , 0 , ( int ) Math . min ( remain , SKIP_BUFFER_SIZE ) ) ; if ( n < 0 ) { break; } remain -= n ; MST[MathMutator]MSP[]
return toString ( resourceToURL ( name , classLoader ) , encoding ) ; MST[ReturnValsMutator]MSP[] } public static URL resourceToURL ( final String name ) throws IOException { return resourceToURL ( name , null ) ; }
throw new IllegalArgumentException ( lr_2 + length ) ; } int remaining = length ; while ( remaining > 0 ) { final int location = length - remaining ; final int count = input . read ( buffer , offset + location , remaining ) ; MST[rv.AOD2Mutator]MSP[]
if ( count > Integer . MAX_VALUE ) { MST[rv.UOI3Mutator]MSP[] return - 1 ; } return ( int ) count ; } public static long copy ( final InputStream input , final OutputStream output , final int bufferSize ) throws IOException {
return line1 == null ? line2 == null ? true : false : line1 . equals ( line2 ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] } public static int copy ( final InputStream input , final OutputStream output ) throws IOException { final long count = copyLarge ( input , output ) ;
public static void skipFully ( final Reader input , final long toSkip ) throws IOException { final long skipped = skip ( input , toSkip ) ; if ( skipped != toSkip ) { throw new EOFException ( lr_9 + toSkip + lr_4 + skipped ) ; MST[NonVoidMethodCallMutator]MSP[] } }
final int chunk = Math . min ( bytes , DEFAULT_BUFFER_SIZE ) ; output . write ( data , offset , chunk ) ; bytes -= chunk ; offset += chunk ; MST[rv.UOI1Mutator]MSP[] } } } @Deprecated
} return toSkip - remain ; } public static void skipFully ( final InputStream input , final long toSkip ) throws IOException { if ( toSkip < 0 ) { MST[rv.ROR4Mutator]MSP[] throw new IllegalArgumentException ( lr_7 + toSkip ) ; }
return input . getBytes ( Charset . defaultCharset () ) ; } public static byte [] toByteArray ( final URI uri ) throws IOException { return IOUtils . toByteArray ( uri . toURL () ) ; MST[NonVoidMethodCallMutator]MSP[] } public static byte [] toByteArray ( final URL url ) throws IOException {
if ( inputOffset > 0 ) { skipFully ( input , inputOffset ) ; } if ( length == 0 ) { return 0 ; } int bytesToRead = buffer . length ; if ( length > 0 && length < buffer . length ) { MST[rv.ABSMutator]MSP[]
throw new IllegalArgumentException ( lr_2 + length ) ; } int remaining = length ; while ( remaining > 0 ) { final int location = length - remaining ; final int count = input . read ( buffer , offset + location , remaining ) ; MST[rv.UOI1Mutator]MSP[]
return toString ( uri . toURL () , Charsets . toCharset ( encoding ) ) ; } public static String toString ( final URI uri , final String encoding ) throws IOException { return toString ( uri , Charsets . toCharset ( encoding ) ) ; MST[NonVoidMethodCallMutator]MSP[] } @Deprecated
public static boolean contentEqualsIgnoreEOL ( final Reader input1 , final Reader input2 ) throws IOException { if ( input1 == input2 ) { return true ; MST[BooleanFalseReturnValsMutator]MSP[] } final BufferedReader br1 = toBufferedReader ( input1 ) ; final BufferedReader br2 = toBufferedReader ( input2 ) ;
try ( InputStream inputStream = urlConn . getInputStream () ) { MST[NonVoidMethodCallMutator]MSP[] return IOUtils . toByteArray ( inputStream ) ; } } @Deprecated public static char [] toCharArray ( final InputStream is ) throws IOException { return toCharArray ( is , Charset . defaultCharset () ) ; }
output . write ( buffer , 0 , read ) ; totalRead += read ; if ( length > 0 ) { bytesToRead = ( int ) Math . min ( length - totalRead , buffer . length ) ; MST[rv.UOI1Mutator]MSP[] } } return totalRead ; }
if ( length > 0 ) { MST[InlineConstantMutator]MSP[] bytesToRead = ( int ) Math . min ( length - totalRead , bufferLength ) ; } } return totalRead ; } public static long copy ( final Reader input , final Appendable output , final CharBuffer buffer ) throws IOException {
public static long skip ( final Reader input , final long toSkip ) throws IOException { if ( toSkip < 0 ) { throw new IllegalArgumentException ( lr_6 + toSkip ) ; } if ( SKIP_CHAR_BUFFER == null ) { SKIP_CHAR_BUFFER = new char [ SKIP_BUFFER_SIZE ] ; MST[rv.CRCR6Mutator]MSP[] }
throw new IllegalArgumentException ( lr_2 + length ) ; MST[rv.UOI3Mutator]MSP[] } int remaining = length ; while ( remaining > 0 ) { final int location = length - remaining ; final int count = input . read ( buffer , offset + location , remaining ) ;
if ( length > 0 ) { bytesToRead = ( int ) Math . min ( length - totalRead , bufferLength ) ; MST[rv.UOI4Mutator]MSP[] } } return totalRead ; } public static long copy ( final Reader input , final Appendable output , final CharBuffer buffer ) throws IOException {
while ( EOF != ch ) { final int ch2 = input2 . read () ; if ( ch != ch2 ) { return false ; MST[BooleanTrueReturnValsMutator]MSP[] } ch = input1 . read () ; } final int ch2 = input2 . read () ; return ch2 == EOF ; }
public static int length ( final byte [] array ) { return array == null ? 0 : array . length ; } public static int length ( final char [] array ) { return array == null ? 0 : array . length ; MST[rv.ROR5Mutator]MSP[] }
while ( EOF != ch ) { final int ch2 = input2 . read () ; if ( ch != ch2 ) { return false ; } ch = input1 . read () ; } final int ch2 = input2 . read () ; return ch2 == EOF ; MST[rv.ROR2Mutator]MSP[] }
final long skipped = skip ( input , toSkip ) ; if ( skipped != toSkip ) { MST[rv.ROR3Mutator]MSP[] throw new EOFException ( lr_8 + toSkip + lr_4 + skipped ) ; } } public static void skipFully ( final ReadableByteChannel input , final long toSkip ) throws IOException {
while ( offset < size && ( read = input . read ( data , offset , size - offset ) ) != EOF ) { offset += read ; } if ( offset != size ) { MST[rv.UOI1Mutator]MSP[]
while ( EOF != ch ) { MST[rv.ROR2Mutator]MSP[] final int ch2 = input2 . read () ; if ( ch != ch2 ) { return false ; } ch = input1 . read () ; } final int ch2 = input2 . read () ; return ch2 == EOF ; }
if ( EOF == count ) { break; } remaining -= count ; } return length - remaining ; MST[rv.AOD1Mutator]MSP[] } public static void readFully ( final InputStream input , final byte [] buffer ) throws IOException { readFully ( input , buffer , 0 , buffer . length ) ;
public static long copyLarge ( final InputStream input , final OutputStream output , final long inputOffset , final long length , final byte [] buffer ) throws IOException { if ( inputOffset > 0 ) { MST[NegateConditionalsMutator]MSP[] skipFully ( input , inputOffset ) ; }
while ( offset < size && ( read = input . read ( data , offset , size - offset ) ) != EOF ) { MST[rv.ROR1Mutator]MSP[] offset += read ; } if ( offset != size ) {
throw new IllegalArgumentException ( lr_2 + length ) ; } int remaining = length ; while ( remaining > 0 ) { final int location = length - remaining ; MST[rv.UOI3Mutator]MSP[] final int count = input . read ( buffer , offset + location , remaining ) ;
return copyLarge ( input , output , inputOffset , length , new char [ DEFAULT_BUFFER_SIZE ] ) ; MST[rv.CRCR5Mutator]MSP[] } public static long copyLarge ( final Reader input , final Writer output , final long inputOffset , final long length , final char [] buffer ) throws IOException {
throw new IllegalArgumentException ( lr_13 + size ) ; } return toByteArray ( input , ( int ) size ) ; MST[NullReturnValsMutator]MSP[] } @Deprecated public static byte [] toByteArray ( final Reader input ) throws IOException { return toByteArray ( input , Charset . defaultCharset () ) ; }
final int ch2 = input2 . read () ; if ( ch != ch2 ) { return false ; } ch = input1 . read () ; } final int ch2 = input2 . read () ; return ch2 == EOF ; MST[rv.ROR4Mutator]MSP[] }
final long skipped = skip ( input , toSkip ) ; if ( skipped != toSkip ) { MST[rv.ABSMutator]MSP[] throw new EOFException ( lr_8 + toSkip + lr_4 + skipped ) ; } } public static void skipFully ( final ReadableByteChannel input , final long toSkip ) throws IOException {
return copyLarge ( input , output , inputOffset , length , new char [ DEFAULT_BUFFER_SIZE ] ) ; MST[rv.UOI3Mutator]MSP[] } public static long copyLarge ( final Reader input , final Writer output , final long inputOffset , final long length , final char [] buffer ) throws IOException {
final int actual = read ( input , buffer , offset , length ) ; if ( actual != length ) { MST[rv.ABSMutator]MSP[] throw new EOFException ( lr_3 + length + lr_4 + actual ) ; } } @Deprecated
long count = 0 ; int n ; while ( EOF != ( n = input . read ( buffer ) ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] buffer . flip () ; output . append ( buffer , 0 , n ) ; count += n ; } return count ; }
if ( EOF == count ) { break; } remaining -= count ; } return length - remaining ; } public static void readFully ( final InputStream input , final byte [] buffer ) throws IOException { readFully ( input , buffer , 0 , buffer . length ) ; MST[rv.CRCR1Mutator]MSP[]
output . write ( buffer , 0 , read ) ; totalRead += read ; if ( length > 0 ) { bytesToRead = ( int ) Math . min ( length - totalRead , buffer . length ) ; } } return totalRead ; MST[PrimitiveReturnsMutator]MSP[] }
final Charset cs = Charsets . toCharset ( encoding ) ; for ( final Object line : lines ) { if ( line != null ) { output . write ( line . toString () . getBytes ( cs ) ) ; MST[NonVoidMethodCallMutator]MSP[] }
} return toSkip - remain ; } public static void skipFully ( final InputStream input , final long toSkip ) throws IOException { if ( toSkip < 0 ) { throw new IllegalArgumentException ( lr_7 + toSkip ) ; MST[experimental.NakedReceiverMutator]MSP[] }
public static void close ( final URLConnection conn ) { if ( conn instanceof HttpURLConnection ) { MST[rv.ROR1Mutator]MSP[] ( ( HttpURLConnection ) conn ) . disconnect () ; } } @Deprecated public static void closeQuietly ( final Closeable closeable ) { try { if ( closeable != null ) {
public static int length ( final byte [] array ) { return array == null ? 0 : array . length ; } public static int length ( final char [] array ) { return array == null ? 0 : array . length ; MST[PrimitiveReturnsMutator]MSP[] }
long totalRead = 0 ; while ( bytesToRead > 0 && EOF != ( read = input . read ( buffer , 0 , bytesToRead ) ) ) { output . write ( buffer , 0 , read ) ; MST[VoidMethodCallMutator]MSP[] totalRead += read ;
final CharArrayWriter sw = new CharArrayWriter () ; copy ( input , sw ) ; return sw . toCharArray () ; } @Deprecated public static InputStream toInputStream ( final CharSequence input ) { return toInputStream ( input , Charset . defaultCharset () ) ; MST[NonVoidMethodCallMutator]MSP[] }
if ( length == 0 ) { return 0 ; } final int bufferLength = buffer . length ; int bytesToRead = bufferLength ; if ( length > 0 && length < bufferLength ) { MST[InlineConstantMutator]MSP[] bytesToRead = ( int ) length ; } int read ;
if ( inputOffset > 0 ) { skipFully ( input , inputOffset ) ; } if ( length == 0 ) { MST[rv.CRCR1Mutator]MSP[] return 0 ; } int bytesToRead = buffer . length ; if ( length > 0 && length < buffer . length ) {
int offset = 0 ; while ( bytes > 0 ) { final int chunk = Math . min ( bytes , DEFAULT_BUFFER_SIZE ) ; output . write ( data , offset , chunk ) ; bytes -= chunk ; offset += chunk ; MST[rv.AOR2Mutator]MSP[] } } }
final int actual = read ( input , buffer ) ; if ( actual != expected ) { throw new EOFException ( lr_3 + expected + lr_4 + actual ) ; MST[rv.UOI2Mutator]MSP[] } } public static void readFully ( final Reader input , final char [] buffer ) throws IOException {
return reader instanceof BufferedReader ? ( BufferedReader ) reader : new BufferedReader ( reader , size ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] } public static BufferedWriter buffer ( final Writer writer ) { return writer instanceof BufferedWriter ? ( BufferedWriter ) writer : new BufferedWriter ( writer ) ; }
return toInputStream ( input , Charsets . toCharset ( encoding ) ) ; MST[NullReturnValsMutator]MSP[] } @Deprecated public static InputStream toInputStream ( final String input ) { return toInputStream ( input , Charset . defaultCharset () ) ; }
public static void skipFully ( final Reader input , final long toSkip ) throws IOException { final long skipped = skip ( input , toSkip ) ; MST[ArgumentPropagationMutator]MSP[] if ( skipped != toSkip ) { throw new EOFException ( lr_9 + toSkip + lr_4 + skipped ) ; } }
public static int length ( final CharSequence csq ) { return csq == null ? 0 : csq . length () ; MST[InlineConstantMutator]MSP[] } public static int length ( final Object [] array ) { return array == null ? 0 : array . length ; }
long totalRead = 0 ; while ( bytesToRead > 0 && EOF != ( read = input . read ( buffer , 0 , bytesToRead ) ) ) { MST[rv.CRCR4Mutator]MSP[] output . write ( buffer , 0 , read ) ; totalRead += read ;
public static int read ( final InputStream input , final byte [] buffer , final int offset , final int length ) throws IOException { if ( length < 0 ) { MST[rv.ROR1Mutator]MSP[] throw new IllegalArgumentException ( lr_2 + length ) ; } int remaining = length ;
if ( length > 0 ) { bytesToRead = ( int ) Math . min ( length - totalRead , bufferLength ) ; MST[rv.UOI1Mutator]MSP[] } } return totalRead ; } public static long copy ( final Reader input , final Appendable output , final CharBuffer buffer ) throws IOException {
skipByteBuffer . limit ( ( int ) Math . min ( remain , SKIP_BUFFER_SIZE ) ) ; final int n = input . read ( skipByteBuffer ) ; if ( n == EOF ) { break; } remain -= n ; MST[rv.AOR1Mutator]MSP[] } return toSkip - remain ; }
final int actual = read ( input , buffer ) ; if ( actual != expected ) { MST[NegateConditionalsMutator]MSP[] throw new EOFException ( lr_3 + expected + lr_4 + actual ) ; } } public static void readFully ( final Reader input , final char [] buffer ) throws IOException {
while ( remaining > 0 ) { final int location = length - remaining ; MST[rv.AOD2Mutator]MSP[] final int count = input . read ( buffer , offset + location , remaining ) ; if ( EOF == count ) { break; } remaining -= count ; }
write ( data . toString () , output , encoding ) ; } } public static void write ( final CharSequence data , final OutputStream output , final String encoding ) throws IOException { write ( data , output , Charsets . toCharset ( encoding ) ) ; MST[VoidMethodCallMutator]MSP[] }
} public static void readFully ( final InputStream input , final byte [] buffer , final int offset , final int length ) throws IOException { final int actual = read ( input , buffer , offset , length ) ; if ( actual != length ) { MST[rv.ROR1Mutator]MSP[]
output . write ( buffer , 0 , read ) ; totalRead += read ; if ( length > 0 ) { bytesToRead = ( int ) Math . min ( length - totalRead , buffer . length ) ; MST[rv.ABSMutator]MSP[] } } return totalRead ; }
throw new EOFException ( lr_3 + length + lr_4 + actual ) ; MST[NonVoidMethodCallMutator]MSP[] } } public static byte [] readFully ( final InputStream input , final int length ) throws IOException { final byte [] buffer = new byte [ length ] ;
public static void write ( final byte [] data , final Writer output , final Charset encoding ) throws IOException { if ( data != null ) { output . write ( new String ( data , Charsets . toCharset ( encoding ) ) ) ; MST[ArgumentPropagationMutator]MSP[] } }
if ( inputOffset > 0 ) { skipFully ( input , inputOffset ) ; } if ( length == 0 ) { MST[rv.UOI4Mutator]MSP[] return 0 ; } int bytesToRead = buffer . length ; if ( length > 0 && length < buffer . length ) {
public static void write ( final byte [] data , final Writer output , final Charset encoding ) throws IOException { if ( data != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] output . write ( new String ( data , Charsets . toCharset ( encoding ) ) ) ; } }
throw new IOException ( lr_5 + name ) ; } return resource ; } public static long skip ( final InputStream input , final long toSkip ) throws IOException { if ( toSkip < 0 ) { MST[rv.ROR5Mutator]MSP[] throw new IllegalArgumentException ( lr_6 + toSkip ) ; }
public static BufferedInputStream buffer ( final InputStream inputStream , final int size ) { if ( inputStream == null ) { throw new NullPointerException () ; } return inputStream instanceof BufferedInputStream ? MST[rv.ABSMutator]MSP[] ( BufferedInputStream ) inputStream : new BufferedInputStream ( inputStream , size ) ; }
try ( InputStream inputStream = url . openStream () ) { return toString ( inputStream , encoding ) ; MST[EmptyObjectReturnValsMutator]MSP[] } } public static String toString ( final URL url , final String encoding ) throws IOException { return toString ( url , Charsets . toCharset ( encoding ) ) ;
output . write ( buffer , 0 , read ) ; MST[rv.ABSMutator]MSP[] totalRead += read ; if ( length > 0 ) { bytesToRead = ( int ) Math . min ( length - totalRead , buffer . length ) ; } } return totalRead ; }
return toString ( input , Charsets . toCharset ( encoding ) ) ; } public static String toString ( final Reader input ) throws IOException { try ( final StringBuilderWriter sw = new StringBuilderWriter () ) { copy ( input , sw ) ; return sw . toString () ; MST[EmptyObjectReturnValsMutator]MSP[]
final int actual = read ( input , buffer ) ; if ( actual != expected ) { throw new EOFException ( lr_3 + expected + lr_4 + actual ) ; MST[experimental.NakedReceiverMutator]MSP[] } } public static void readFully ( final Reader input , final char [] buffer ) throws IOException {
final ByteBuffer skipByteBuffer = ByteBuffer . allocate ( ( int ) Math . min ( toSkip , SKIP_BUFFER_SIZE ) ) ; long remain = toSkip ; while ( remain > 0 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] skipByteBuffer . position ( 0 ) ;
} return toSkip - remain ; } public static void skipFully ( final InputStream input , final long toSkip ) throws IOException { if ( toSkip < 0 ) { throw new IllegalArgumentException ( lr_7 + toSkip ) ; MST[NonVoidMethodCallMutator]MSP[] }
final int chunk = Math . min ( bytes , DEFAULT_BUFFER_SIZE ) ; output . write ( data , offset , chunk ) ; MST[rv.ABSMutator]MSP[] bytes -= chunk ; offset += chunk ; } } } @Deprecated
return output . toByteArray () ; } } public static byte [] toByteArray ( final InputStream input , final int size ) throws IOException { if ( size < 0 ) { throw new IllegalArgumentException ( lr_10 + size ) ; MST[rv.UOI4Mutator]MSP[] } if ( size == 0 ) {
throw new EOFException ( lr_3 + length + lr_4 + actual ) ; } } public static byte [] readFully ( final InputStream input , final int length ) throws IOException { final byte [] buffer = new byte [ length ] ; MST[rv.UOI2Mutator]MSP[]
final int ch2 = input2 . read () ; if ( ch != ch2 ) { return false ; } ch = input1 . read () ; } final int ch2 = input2 . read () ; return ch2 == EOF ; MST[rv.CRCR6Mutator]MSP[] }
final int ch2 = input2 . read () ; if ( ch != ch2 ) { MST[rv.ROR3Mutator]MSP[] return false ; } ch = input1 . read () ; } final int ch2 = input2 . read () ; return ch2 == EOF ; }
final int ch2 = input2 . read () ; if ( ch != ch2 ) { return false ; } ch = input1 . read () ; } final int ch2 = input2 . read () ; return ch2 == EOF ; MST[rv.CRCR4Mutator]MSP[] }
public static long skip ( final ReadableByteChannel input , final long toSkip ) throws IOException { if ( toSkip < 0 ) { MST[rv.ABSMutator]MSP[] throw new IllegalArgumentException ( lr_6 + toSkip ) ; }
while ( EOF != ch ) { final int ch2 = input2 . read () ; if ( ch != ch2 ) { return false ; } ch = input1 . read () ; } final int ch2 = input2 . read () ; return ch2 == EOF ; MST[rv.CRCR3Mutator]MSP[] }
public static InputStream toBufferedInputStream ( final InputStream input ) throws IOException { return ByteArrayOutputStream . toBufferedInputStream ( input ) ; } public static InputStream toBufferedInputStream ( final InputStream input , final int size ) throws IOException { return ByteArrayOutputStream . toBufferedInputStream ( input , size ) ; MST[ArgumentPropagationMutator]MSP[] }
output . write ( buffer , 0 , read ) ; totalRead += read ; MST[rv.UOI3Mutator]MSP[] if ( length > 0 ) { bytesToRead = ( int ) Math . min ( length - totalRead , buffer . length ) ; } } return totalRead ; }
bytesToRead = ( int ) length ; } int read ; long totalRead = 0 ; while ( bytesToRead > 0 && EOF != ( read = input . read ( buffer , 0 , bytesToRead ) ) ) { MST[rv.ABSMutator]MSP[]
long count = 0 ; int n ; while ( EOF != ( n = input . read ( buffer ) ) ) { buffer . flip () ; output . append ( buffer , 0 , n ) ; MST[rv.CRCR6Mutator]MSP[] count += n ; } return count ; }
public static long skip ( final Reader input , final long toSkip ) throws IOException { if ( toSkip < 0 ) { throw new IllegalArgumentException ( lr_6 + toSkip ) ; MST[NonVoidMethodCallMutator]MSP[] } if ( SKIP_CHAR_BUFFER == null ) { SKIP_CHAR_BUFFER = new char [ SKIP_BUFFER_SIZE ] ; }
public static long copyLarge ( final Reader input , final Writer output , final char [] buffer ) throws IOException { long count = 0 ; int n ; while ( EOF != ( n = input . read ( buffer ) ) ) { MST[rv.CRCR4Mutator]MSP[]
public static boolean contentEquals ( Reader input1 , Reader input2 ) throws IOException { if ( input1 == input2 ) { return true ; MST[ReturnValsMutator]MSP[] } input1 = toBufferedReader ( input1 ) ; input2 = toBufferedReader ( input2 ) ; int ch = input1 . read () ;
public static void closeQuietly ( final Socket sock ) { if ( sock != null ) { try { sock . close () ; MST[VoidMethodCallMutator]MSP[] } catch ( final IOException ioe ) { } } } @Deprecated public static void closeQuietly ( final Writer output ) {
final int actual = read ( input , buffer , offset , length ) ; if ( actual != length ) { throw new EOFException ( lr_3 + length + lr_4 + actual ) ; MST[rv.UOI1Mutator]MSP[] } } @Deprecated
if ( EOF == count ) { break; } remaining -= count ; MST[rv.UOI3Mutator]MSP[] } return length - remaining ; } public static void readFully ( final InputStream input , final byte [] buffer ) throws IOException { readFully ( input , buffer , 0 , buffer . length ) ;
public static long skip ( final Reader input , final long toSkip ) throws IOException { if ( toSkip < 0 ) { MST[rv.ROR3Mutator]MSP[] throw new IllegalArgumentException ( lr_6 + toSkip ) ; } if ( SKIP_CHAR_BUFFER == null ) { SKIP_CHAR_BUFFER = new char [ SKIP_BUFFER_SIZE ] ; }
String line1 = br1 . readLine () ; String line2 = br2 . readLine () ; while ( line1 != null && line2 != null && line1 . equals ( line2 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] line1 = br1 . readLine () ; line2 = br2 . readLine () ; }
return read ( input , buffer , 0 , buffer . length ) ; MST[ReturnValsMutator]MSP[] } public static int read ( final Reader input , final char [] buffer , final int offset , final int length ) throws IOException { if ( length < 0 ) {
if ( EOF == count ) { break; } remaining -= count ; MST[rv.AOR4Mutator]MSP[] } return length - remaining ; } public static void readFully ( final InputStream input , final byte [] buffer ) throws IOException { readFully ( input , buffer , 0 , buffer . length ) ;
final int actual = read ( input , buffer ) ; if ( actual != expected ) { MST[rv.UOI4Mutator]MSP[] throw new EOFException ( lr_3 + expected + lr_4 + actual ) ; } } public static void readFully ( final Reader input , final char [] buffer ) throws IOException {
public static void skipFully ( final Reader input , final long toSkip ) throws IOException { final long skipped = skip ( input , toSkip ) ; if ( skipped != toSkip ) { throw new EOFException ( lr_9 + toSkip + lr_4 + skipped ) ; MST[rv.ABSMutator]MSP[] } }
bytesToRead = ( int ) length ; } int read ; long totalRead = 0 ; while ( bytesToRead > 0 && EOF != ( read = input . read ( buffer , 0 , bytesToRead ) ) ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[]
closeable . close () ; } } catch ( final IOException ioe ) { } } @Deprecated public static void closeQuietly ( final Closeable ... closeables ) { if ( closeables == null ) { return; } for ( final Closeable closeable : closeables ) { MST[rv.ABSMutator]MSP[]
if ( length > 0 ) { bytesToRead = ( int ) Math . min ( length - totalRead , bufferLength ) ; } } return totalRead ; MST[rv.ABSMutator]MSP[] } public static long copy ( final Reader input , final Appendable output , final CharBuffer buffer ) throws IOException {
public static int copy ( final Reader input , final Writer output ) throws IOException { final long count = copyLarge ( input , output ) ; if ( count > Integer . MAX_VALUE ) { MST[rv.UOI2Mutator]MSP[] return - 1 ; } return ( int ) count ; }
long count = 0 ; int n ; while ( EOF != ( n = input . read ( buffer ) ) ) { MST[rv.ROR2Mutator]MSP[] buffer . flip () ; output . append ( buffer , 0 , n ) ; count += n ; } return count ; }
skipByteBuffer . limit ( ( int ) Math . min ( remain , SKIP_BUFFER_SIZE ) ) ; final int n = input . read ( skipByteBuffer ) ; if ( n == EOF ) { break; } remain -= n ; MST[rv.UOI1Mutator]MSP[] } return toSkip - remain ; }
final int chunk = Math . min ( bytes , DEFAULT_BUFFER_SIZE ) ; MST[ArgumentPropagationMutator]MSP[] output . write ( data , offset , chunk ) ; bytes -= chunk ; offset += chunk ; } } } @Deprecated
} return toSkip - remain ; } public static void skipFully ( final InputStream input , final long toSkip ) throws IOException { if ( toSkip < 0 ) { MST[rv.UOI4Mutator]MSP[] throw new IllegalArgumentException ( lr_7 + toSkip ) ; }
long count = 0 ; int n ; while ( EOF != ( n = input . read ( buffer ) ) ) { buffer . flip () ; output . append ( buffer , 0 , n ) ; count += n ; MST[MathMutator]MSP[] } return count ; }
throw new IOException ( lr_11 + offset + lr_12 + size ) ; MST[rv.UOI3Mutator]MSP[] } return data ; } public static byte [] toByteArray ( final InputStream input , final long size ) throws IOException { if ( size > Integer . MAX_VALUE ) {
final Charset cs = Charsets . toCharset ( encoding ) ; MST[ArgumentPropagationMutator]MSP[] for ( final Object line : lines ) { if ( line != null ) { output . write ( line . toString () . getBytes ( cs ) ) ; }
input1 = new BufferedInputStream ( input1 ) ; } if ( ! ( input2 instanceof BufferedInputStream ) ) { input2 = new BufferedInputStream ( input2 ) ; } int ch = input1 . read () ; while ( EOF != ch ) { MST[rv.UOI3Mutator]MSP[]
final int actual = read ( input , buffer ) ; if ( actual != expected ) { MST[rv.ABSMutator]MSP[] throw new EOFException ( lr_3 + expected + lr_4 + actual ) ; } } public static void readFully ( final Reader input , final char [] buffer ) throws IOException {
public static void skipFully ( final Reader input , final long toSkip ) throws IOException { final long skipped = skip ( input , toSkip ) ; if ( skipped != toSkip ) { MST[NegateConditionalsMutator]MSP[] throw new EOFException ( lr_9 + toSkip + lr_4 + skipped ) ; } }
if ( inputOffset > 0 ) { skipFully ( input , inputOffset ) ; } if ( length == 0 ) { return 0 ; } int bytesToRead = buffer . length ; if ( length > 0 && length < buffer . length ) { MST[rv.UOI2Mutator]MSP[]
while ( remaining > 0 ) { MST[rv.UOI1Mutator]MSP[] final int location = length - remaining ; final int count = input . read ( buffer , offset + location , remaining ) ; if ( EOF == count ) { break; } remaining -= count ; }
while ( remaining > 0 ) { final int location = length - remaining ; MST[rv.UOI4Mutator]MSP[] final int count = input . read ( buffer , offset + location , remaining ) ; if ( EOF == count ) { break; } remaining -= count ; }
long remain = toSkip ; while ( remain > 0 ) { final long n = input . read ( SKIP_CHAR_BUFFER , 0 , ( int ) Math . min ( remain , SKIP_BUFFER_SIZE ) ) ; if ( n < 0 ) { break; } remain -= n ; MST[rv.AOR4Mutator]MSP[]
long remain = toSkip ; while ( remain > 0 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] final long n = input . read ( SKIP_CHAR_BUFFER , 0 , ( int ) Math . min ( remain , SKIP_BUFFER_SIZE ) ) ; if ( n < 0 ) { break; } remain -= n ;
long remain = toSkip ; while ( remain > 0 ) { final long n = input . read ( SKIP_CHAR_BUFFER , 0 , ( int ) Math . min ( remain , SKIP_BUFFER_SIZE ) ) ; MST[ArgumentPropagationMutator]MSP[] if ( n < 0 ) { break; } remain -= n ;
throw new IllegalArgumentException ( lr_2 + length ) ; } int remaining = length ; while ( remaining > 0 ) { final int location = length - remaining ; MST[rv.AOD2Mutator]MSP[] final int count = input . read ( buffer , offset + location , remaining ) ;
closeQuietly ( ( Closeable ) output ) ; } public static boolean contentEquals ( InputStream input1 , InputStream input2 ) throws IOException { if ( input1 == input2 ) { return true ; MST[BooleanFalseReturnValsMutator]MSP[] } if ( ! ( input1 instanceof BufferedInputStream ) ) {
if ( inputOffset > 0 ) { skipFully ( input , inputOffset ) ; } if ( length == 0 ) { MST[NegateConditionalsMutator]MSP[] return 0 ; } int bytesToRead = buffer . length ; if ( length > 0 && length < buffer . length ) {
if ( toSkip < 0 ) { throw new IllegalArgumentException ( lr_7 + toSkip ) ; } final long skipped = skip ( input , toSkip ) ; if ( skipped != toSkip ) { MST[rv.UOI2Mutator]MSP[] throw new EOFException ( lr_8 + toSkip + lr_4 + skipped ) ; } }
public static boolean contentEqualsIgnoreEOL ( final Reader input1 , final Reader input2 ) throws IOException { if ( input1 == input2 ) { return true ; MST[rv.CRCR6Mutator]MSP[] } final BufferedReader br1 = toBufferedReader ( input1 ) ; final BufferedReader br2 = toBufferedReader ( input2 ) ;
public static BufferedReader buffer ( final Reader reader ) { return reader instanceof BufferedReader ? ( BufferedReader ) reader : new BufferedReader ( reader ) ; MST[rv.ROR4Mutator]MSP[] } public static BufferedReader buffer ( final Reader reader , final int size ) {
public static void skipFully ( final Reader input , final long toSkip ) throws IOException { final long skipped = skip ( input , toSkip ) ; if ( skipped != toSkip ) { throw new EOFException ( lr_9 + toSkip + lr_4 + skipped ) ; MST[experimental.NakedReceiverMutator]MSP[] } }
while ( remaining > 0 ) { final int location = length - remaining ; MST[rv.ABSMutator]MSP[] final int count = input . read ( buffer , offset + location , remaining ) ; if ( EOF == count ) { break; } remaining -= count ; }
} return toSkip - remain ; MST[PrimitiveReturnsMutator]MSP[] } public static void skipFully ( final InputStream input , final long toSkip ) throws IOException { if ( toSkip < 0 ) { throw new IllegalArgumentException ( lr_7 + toSkip ) ; }
long remain = toSkip ; while ( remain > 0 ) { final long n = input . read ( SKIP_CHAR_BUFFER , 0 , ( int ) Math . min ( remain , SKIP_BUFFER_SIZE ) ) ; if ( n < 0 ) { MST[rv.UOI1Mutator]MSP[] break; } remain -= n ;
while ( offset < size && ( read = input . read ( data , offset , size - offset ) ) != EOF ) { MST[rv.UOI1Mutator]MSP[] offset += read ; } if ( offset != size ) {
public static void writeChunked ( final char [] data , final Writer output ) throws IOException { if ( data != null ) { int bytes = data . length ; int offset = 0 ; MST[rv.CRCR6Mutator]MSP[] while ( bytes > 0 ) {
output . write ( buffer , 0 , read ) ; totalRead += read ; MST[rv.AOR4Mutator]MSP[] if ( length > 0 ) { bytesToRead = ( int ) Math . min ( length - totalRead , buffer . length ) ; } } return totalRead ; }
final int ch2 = input2 . read () ; if ( ch != ch2 ) { return false ; } ch = input1 . read () ; } final int ch2 = input2 . read () ; MST[NonVoidMethodCallMutator]MSP[] return ch2 == EOF ; }
throw new IllegalArgumentException ( lr_13 + size ) ; MST[rv.UOI4Mutator]MSP[] } return toByteArray ( input , ( int ) size ) ; } @Deprecated public static byte [] toByteArray ( final Reader input ) throws IOException { return toByteArray ( input , Charset . defaultCharset () ) ; }
throw new IllegalArgumentException ( lr_2 + length ) ; } int remaining = length ; MST[rv.UOI3Mutator]MSP[] while ( remaining > 0 ) { final int location = length - remaining ; final int count = input . read ( buffer , offset + location , remaining ) ;
return toString ( input , Charsets . toCharset ( encoding ) ) ; } public static String toString ( final Reader input ) throws IOException { try ( final StringBuilderWriter sw = new StringBuilderWriter () ) { copy ( input , sw ) ; MST[NonVoidMethodCallMutator]MSP[] return sw . toString () ;
return length - remaining ; MST[rv.UOI4Mutator]MSP[] } public static int read ( final ReadableByteChannel input , final ByteBuffer buffer ) throws IOException { final int length = buffer . remaining () ; while ( buffer . remaining () > 0 ) {
int offset = 0 ; while ( bytes > 0 ) { final int chunk = Math . min ( bytes , DEFAULT_BUFFER_SIZE ) ; output . write ( data , offset , chunk ) ; bytes -= chunk ; offset += chunk ; MST[rv.UOI4Mutator]MSP[] } } }
throw new IllegalArgumentException ( lr_2 + length ) ; } int remaining = length ; while ( remaining > 0 ) { final int location = length - remaining ; final int count = input . read ( buffer , offset + location , remaining ) ; MST[rv.UOI3Mutator]MSP[]
skipByteBuffer . limit ( ( int ) Math . min ( remain , SKIP_BUFFER_SIZE ) ) ; final int n = input . read ( skipByteBuffer ) ; if ( n == EOF ) { break; } remain -= n ; MST[MathMutator]MSP[] } return toSkip - remain ; }
final int actual = read ( input , buffer ) ; if ( actual != expected ) { MST[rv.ROR5Mutator]MSP[] throw new EOFException ( lr_3 + expected + lr_4 + actual ) ; } } public static void readFully ( final Reader input , final char [] buffer ) throws IOException {
final int ch2 = input2 . read () ; if ( ch != ch2 ) { MST[rv.UOI2Mutator]MSP[] return false ; } ch = input1 . read () ; } final int ch2 = input2 . read () ; return ch2 == EOF ; }
output . write ( buffer , 0 , read ) ; totalRead += read ; MST[rv.UOI4Mutator]MSP[] if ( length > 0 ) { bytesToRead = ( int ) Math . min ( length - totalRead , buffer . length ) ; } } return totalRead ; }
closeable . close () ; } } catch ( final IOException ioe ) { } } @Deprecated public static void closeQuietly ( final Closeable ... closeables ) { if ( closeables == null ) { return; } for ( final Closeable closeable : closeables ) { MST[rv.UOI3Mutator]MSP[]
final int ch2 = input2 . read () ; if ( ch != ch2 ) { return false ; } ch = input1 . read () ; } final int ch2 = input2 . read () ; return ch2 == EOF ; MST[rv.UOI4Mutator]MSP[] }
int offset = 0 ; while ( bytes > 0 ) { MST[rv.UOI2Mutator]MSP[] final int chunk = Math . min ( bytes , DEFAULT_BUFFER_SIZE ) ; output . write ( data , offset , chunk ) ; bytes -= chunk ; offset += chunk ; } } }
public static BufferedReader toBufferedReader ( final Reader reader ) { return reader instanceof BufferedReader ? ( BufferedReader ) reader : new BufferedReader ( reader ) ; MST[rv.ROR5Mutator]MSP[] } public static BufferedReader toBufferedReader ( final Reader reader , final int size ) {
long totalRead = 0 ; while ( bytesToRead > 0 && EOF != ( read = input . read ( buffer , 0 , bytesToRead ) ) ) { MST[InlineConstantMutator]MSP[] output . write ( buffer , 0 , read ) ; totalRead += read ;
return new byte [ 0 ] ; } final byte [] data = new byte [ size ] ; MST[rv.UOI3Mutator]MSP[] int offset = 0 ; int read ;
if ( lineEnding == null ) { MST[rv.ROR5Mutator]MSP[] lineEnding = LINE_SEPARATOR ; } for ( final Object line : lines ) { if ( line != null ) { writer . write ( line . toString () ) ; } writer . write ( lineEnding ) ; } }
closeQuietly ( ( Closeable ) output ) ; } public static boolean contentEquals ( InputStream input1 , InputStream input2 ) throws IOException { if ( input1 == input2 ) { return true ; } if ( ! ( input1 instanceof BufferedInputStream ) ) { MST[rv.ROR3Mutator]MSP[]
final int ch2 = input2 . read () ; if ( ch != ch2 ) { return false ; } ch = input1 . read () ; } final int ch2 = input2 . read () ; return ch2 == EOF ; MST[rv.ABSMutator]MSP[] }
public static void skipFully ( final Reader input , final long toSkip ) throws IOException { final long skipped = skip ( input , toSkip ) ; if ( skipped != toSkip ) { MST[rv.UOI4Mutator]MSP[] throw new EOFException ( lr_9 + toSkip + lr_4 + skipped ) ; } }
throw new IllegalArgumentException ( lr_2 + length ) ; } int remaining = length ; while ( remaining > 0 ) { final int location = length - remaining ; final int count = input . read ( buffer , offset + location , remaining ) ; MST[rv.UOI2Mutator]MSP[]
public static BufferedReader toBufferedReader ( final Reader reader ) { return reader instanceof BufferedReader ? ( BufferedReader ) reader : new BufferedReader ( reader ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] } public static BufferedReader toBufferedReader ( final Reader reader , final int size ) {
public static BufferedInputStream buffer ( final InputStream inputStream ) { if ( inputStream == null ) { throw new NullPointerException () ; } return inputStream instanceof BufferedInputStream ? MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] ( BufferedInputStream ) inputStream : new BufferedInputStream ( inputStream ) ; }
write ( data . toString () , output , encoding ) ; MST[NonVoidMethodCallMutator]MSP[] } } public static void write ( final CharSequence data , final OutputStream output , final String encoding ) throws IOException { write ( data , output , Charsets . toCharset ( encoding ) ) ; }
throw new EOFException ( lr_3 + length + lr_4 + actual ) ; MST[rv.UOI4Mutator]MSP[] } } public static byte [] readFully ( final InputStream input , final int length ) throws IOException { final byte [] buffer = new byte [ length ] ;
throw new EOFException ( lr_3 + length + lr_4 + actual ) ; MST[rv.UOI1Mutator]MSP[] } } public static byte [] readFully ( final InputStream input , final int length ) throws IOException { final byte [] buffer = new byte [ length ] ;
while ( EOF != ch ) { final int ch2 = input2 . read () ; if ( ch != ch2 ) { return false ; } ch = input1 . read () ; } final int ch2 = input2 . read () ; return ch2 == EOF ; MST[rv.CRCR6Mutator]MSP[] }
} public static void readFully ( final InputStream input , final byte [] buffer , final int offset , final int length ) throws IOException { final int actual = read ( input , buffer , offset , length ) ; MST[rv.UOI4Mutator]MSP[] if ( actual != length ) {
} public static void write ( final byte [] data , final OutputStream output ) throws IOException { if ( data != null ) { MST[NegateConditionalsMutator]MSP[] output . write ( data ) ; } } @Deprecated
final URLConnection conn = url . openConnection () ; MST[NonVoidMethodCallMutator]MSP[] try { return IOUtils . toByteArray ( conn ) ; } finally { close ( conn ) ; } } public static byte [] toByteArray ( final URLConnection urlConn ) throws IOException {
throw new IllegalArgumentException ( lr_13 + size ) ; MST[NonVoidMethodCallMutator]MSP[] } return toByteArray ( input , ( int ) size ) ; } @Deprecated public static byte [] toByteArray ( final Reader input ) throws IOException { return toByteArray ( input , Charset . defaultCharset () ) ; }
return length - remaining ; MST[rv.ABSMutator]MSP[] } public static int read ( final ReadableByteChannel input , final ByteBuffer buffer ) throws IOException { final int length = buffer . remaining () ; while ( buffer . remaining () > 0 ) {
output . write ( buffer , 0 , read ) ; totalRead += read ; MST[rv.AOD1Mutator]MSP[] if ( length > 0 ) { bytesToRead = ( int ) Math . min ( length - totalRead , buffer . length ) ; } } return totalRead ; }
public static long copyLarge ( final InputStream input , final OutputStream output ) throws IOException { return copy ( input , output , DEFAULT_BUFFER_SIZE ) ; MST[rv.CRCR3Mutator]MSP[] } public static long copyLarge ( final InputStream input , final OutputStream output , final byte [] buffer ) throws IOException {
final CharArrayWriter sw = new CharArrayWriter () ; copy ( input , sw ) ; return sw . toCharArray () ; MST[NonVoidMethodCallMutator]MSP[] } @Deprecated public static InputStream toInputStream ( final CharSequence input ) { return toInputStream ( input , Charset . defaultCharset () ) ; }
long remain = toSkip ; while ( remain > 0 ) { final long n = input . read ( SKIP_CHAR_BUFFER , 0 , ( int ) Math . min ( remain , SKIP_BUFFER_SIZE ) ) ; if ( n < 0 ) { MST[rv.ROR1Mutator]MSP[] break; } remain -= n ;
long totalRead = 0 ; while ( bytesToRead > 0 && EOF != ( read = input . read ( buffer , 0 , bytesToRead ) ) ) { output . write ( buffer , 0 , read ) ; MST[rv.CRCR6Mutator]MSP[] totalRead += read ;
final long n = input . read ( SKIP_BYTE_BUFFER , 0 , ( int ) Math . min ( remain , SKIP_BUFFER_SIZE ) ) ; if ( n < 0 ) { break; } remain -= n ; MST[rv.AOR2Mutator]MSP[] } return toSkip - remain ; }
if ( EOF == count ) { break; } remaining -= count ; } return length - remaining ; MST[rv.UOI1Mutator]MSP[] } public static void readFully ( final InputStream input , final byte [] buffer ) throws IOException { readFully ( input , buffer , 0 , buffer . length ) ;
final int ch2 = input2 . read () ; if ( ch != ch2 ) { return false ; } ch = input1 . read () ; } final int ch2 = input2 . read () ; return ch2 == EOF ; MST[rv.CRCR3Mutator]MSP[] }
Objects . requireNonNull ( appendable , lr_1 ) ; if ( appendable instanceof Writer ) { MST[rv.ROR5Mutator]MSP[] return ( Writer ) appendable ; } if ( appendable instanceof StringBuilder ) { return new StringBuilderWriter ( ( StringBuilder ) appendable ) ; } return new AppendableWriter <> ( appendable ) ; }
public static boolean contentEquals ( Reader input1 , Reader input2 ) throws IOException { if ( input1 == input2 ) { return true ; } input1 = toBufferedReader ( input1 ) ; input2 = toBufferedReader ( input2 ) ; int ch = input1 . read () ; MST[NonVoidMethodCallMutator]MSP[]
throw new IOException ( lr_5 + name ) ; } return resource ; } public static long skip ( final InputStream input , final long toSkip ) throws IOException { if ( toSkip < 0 ) { MST[rv.CRCR5Mutator]MSP[] throw new IllegalArgumentException ( lr_6 + toSkip ) ; }
public static long copyLarge ( final InputStream input , final OutputStream output , final long inputOffset , final long length ) throws IOException { return copyLarge ( input , output , inputOffset , length , new byte [ DEFAULT_BUFFER_SIZE ] ) ; MST[rv.CRCR1Mutator]MSP[] }
if ( length == 0 ) { MST[rv.UOI3Mutator]MSP[] return 0 ; } final int bufferLength = buffer . length ; int bytesToRead = bufferLength ; if ( length > 0 && length < bufferLength ) { bytesToRead = ( int ) length ; } int read ;
if ( inputOffset > 0 ) { skipFully ( input , inputOffset ) ; } if ( length == 0 ) { MST[rv.ROR4Mutator]MSP[] return 0 ; } int bytesToRead = buffer . length ; if ( length > 0 && length < buffer . length ) {
if ( length > 0 ) { bytesToRead = ( int ) Math . min ( length - totalRead , bufferLength ) ; MST[rv.AOD1Mutator]MSP[] } } return totalRead ; } public static long copy ( final Reader input , final Appendable output , final CharBuffer buffer ) throws IOException {
closeQuietly ( ( Closeable ) output ) ; MST[VoidMethodCallMutator]MSP[] } public static boolean contentEquals ( InputStream input1 , InputStream input2 ) throws IOException { if ( input1 == input2 ) { return true ; } if ( ! ( input1 instanceof BufferedInputStream ) ) {
if ( lineEnding == null ) { lineEnding = LINE_SEPARATOR ; } for ( final Object line : lines ) { if ( line != null ) { writer . write ( line . toString () ) ; } writer . write ( lineEnding ) ; MST[VoidMethodCallMutator]MSP[] } }
public static long copyLarge ( final InputStream input , final OutputStream output , final long inputOffset , final long length ) throws IOException { return copyLarge ( input , output , inputOffset , length , new byte [ DEFAULT_BUFFER_SIZE ] ) ; MST[rv.UOI1Mutator]MSP[] }
output . write ( buffer , 0 , read ) ; totalRead += read ; if ( length > 0 ) { MST[rv.ROR5Mutator]MSP[] bytesToRead = ( int ) Math . min ( length - totalRead , buffer . length ) ; } } return totalRead ; }
Objects . requireNonNull ( appendable , lr_1 ) ; if ( appendable instanceof Writer ) { MST[NegateConditionalsMutator]MSP[] return ( Writer ) appendable ; } if ( appendable instanceof StringBuilder ) { return new StringBuilderWriter ( ( StringBuilder ) appendable ) ; } return new AppendableWriter <> ( appendable ) ; }
if ( toSkip < 0 ) { throw new IllegalArgumentException ( lr_7 + toSkip ) ; } final long skipped = skip ( input , toSkip ) ; if ( skipped != toSkip ) { throw new EOFException ( lr_8 + toSkip + lr_4 + skipped ) ; MST[rv.UOI3Mutator]MSP[] } }
int offset = 0 ; while ( bytes > 0 ) { final int chunk = Math . min ( bytes , DEFAULT_BUFFER_SIZE ) ; MST[rv.CRCR6Mutator]MSP[] output . write ( data , offset , chunk ) ; bytes -= chunk ; offset += chunk ; } } }
public static long skip ( final Reader input , final long toSkip ) throws IOException { if ( toSkip < 0 ) { throw new IllegalArgumentException ( lr_6 + toSkip ) ; MST[experimental.NakedReceiverMutator]MSP[] } if ( SKIP_CHAR_BUFFER == null ) { SKIP_CHAR_BUFFER = new char [ SKIP_BUFFER_SIZE ] ; }
long remain = toSkip ; while ( remain > 0 ) { final long n = input . read ( SKIP_CHAR_BUFFER , 0 , ( int ) Math . min ( remain , SKIP_BUFFER_SIZE ) ) ; MST[rv.UOI2Mutator]MSP[] if ( n < 0 ) { break; } remain -= n ;
output . write ( buffer , 0 , read ) ; totalRead += read ; if ( length > 0 ) { bytesToRead = ( int ) Math . min ( length - totalRead , buffer . length ) ; MST[rv.AOR2Mutator]MSP[] } } return totalRead ; }
Objects . requireNonNull ( appendable , lr_1 ) ; if ( appendable instanceof Writer ) { return ( Writer ) appendable ; MST[ReturnValsMutator]MSP[] } if ( appendable instanceof StringBuilder ) { return new StringBuilderWriter ( ( StringBuilder ) appendable ) ; } return new AppendableWriter <> ( appendable ) ; }
return copyLarge ( input , output , inputOffset , length , new char [ DEFAULT_BUFFER_SIZE ] ) ; MST[rv.CRCR6Mutator]MSP[] } public static long copyLarge ( final Reader input , final Writer output , final long inputOffset , final long length , final char [] buffer ) throws IOException {
String line1 = br1 . readLine () ; String line2 = br2 . readLine () ; while ( line1 != null && line2 != null && line1 . equals ( line2 ) ) { MST[NegateConditionalsMutator]MSP[] line1 = br1 . readLine () ; line2 = br2 . readLine () ; }
int offset = 0 ; while ( bytes > 0 ) { final int chunk = Math . min ( bytes , DEFAULT_BUFFER_SIZE ) ; output . write ( data , offset , chunk ) ; bytes -= chunk ; MST[rv.ABSMutator]MSP[] offset += chunk ; } } }
} return toSkip - remain ; } public static void skipFully ( final InputStream input , final long toSkip ) throws IOException { if ( toSkip < 0 ) { MST[rv.ROR3Mutator]MSP[] throw new IllegalArgumentException ( lr_7 + toSkip ) ; }
if ( inputOffset > 0 ) { skipFully ( input , inputOffset ) ; } if ( length == 0 ) { return 0 ; } int bytesToRead = buffer . length ; if ( length > 0 && length < buffer . length ) { MST[rv.CRCR6Mutator]MSP[]
return input . getBytes ( Charset . defaultCharset () ) ; } public static byte [] toByteArray ( final URI uri ) throws IOException { return IOUtils . toByteArray ( uri . toURL () ) ; MST[NonVoidMethodCallMutator]MSP[] } public static byte [] toByteArray ( final URL url ) throws IOException {
return line1 == null ? line2 == null ? true : false : line1 . equals ( line2 ) ; MST[rv.CRCR6Mutator]MSP[] } public static int copy ( final InputStream input , final OutputStream output ) throws IOException { final long count = copyLarge ( input , output ) ;
return line1 == null ? line2 == null ? true : false : line1 . equals ( line2 ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] } public static int copy ( final InputStream input , final OutputStream output ) throws IOException { final long count = copyLarge ( input , output ) ;
if ( toSkip < 0 ) { throw new IllegalArgumentException ( lr_7 + toSkip ) ; } final long skipped = skip ( input , toSkip ) ; if ( skipped != toSkip ) { MST[rv.UOI3Mutator]MSP[] throw new EOFException ( lr_8 + toSkip + lr_4 + skipped ) ; } }
final int actual = read ( input , buffer , offset , length ) ; if ( actual != length ) { MST[rv.ROR1Mutator]MSP[] throw new EOFException ( lr_3 + length + lr_4 + actual ) ; } } @Deprecated
return output . toByteArray () ; } } public static byte [] toByteArray ( final InputStream input , final int size ) throws IOException { if ( size < 0 ) { throw new IllegalArgumentException ( lr_10 + size ) ; } if ( size == 0 ) { MST[rv.UOI4Mutator]MSP[]
final long n = input . read ( SKIP_BYTE_BUFFER , 0 , ( int ) Math . min ( remain , SKIP_BUFFER_SIZE ) ) ; if ( n < 0 ) { break; } remain -= n ; MST[rv.UOI1Mutator]MSP[] } return toSkip - remain ; }
bytesToRead = ( int ) length ; } int read ; long totalRead = 0 ; while ( bytesToRead > 0 && EOF != ( read = input . read ( buffer , 0 , bytesToRead ) ) ) { MST[rv.CRCR1Mutator]MSP[]
throw new EOFException ( lr_3 + length + lr_4 + actual ) ; MST[rv.ABSMutator]MSP[] } } public static byte [] readFully ( final InputStream input , final int length ) throws IOException { final byte [] buffer = new byte [ length ] ;
if ( EOF == count ) { break; } remaining -= count ; MST[rv.UOI2Mutator]MSP[] } return length - remaining ; } public static void readFully ( final InputStream input , final byte [] buffer ) throws IOException { readFully ( input , buffer , 0 , buffer . length ) ;
copy ( input , output , Charsets . toCharset ( outputEncoding ) ) ; } public static long copy ( final Reader input , final Appendable output ) throws IOException { return copy ( input , output , CharBuffer . allocate ( DEFAULT_BUFFER_SIZE ) ) ; MST[NonVoidMethodCallMutator]MSP[] }
public static long skip ( final Reader input , final long toSkip ) throws IOException { if ( toSkip < 0 ) { throw new IllegalArgumentException ( lr_6 + toSkip ) ; } if ( SKIP_CHAR_BUFFER == null ) { SKIP_CHAR_BUFFER = new char [ SKIP_BUFFER_SIZE ] ; MST[rv.CRCR5Mutator]MSP[] }
bytesToRead = ( int ) length ; } int read ; long totalRead = 0 ; MST[rv.CRCR6Mutator]MSP[] while ( bytesToRead > 0 && EOF != ( read = input . read ( buffer , 0 , bytesToRead ) ) ) {
if ( lineEnding == null ) { MST[NegateConditionalsMutator]MSP[] lineEnding = LINE_SEPARATOR ; } for ( final Object line : lines ) { if ( line != null ) { writer . write ( line . toString () ) ; } writer . write ( lineEnding ) ; } }
while ( EOF != ch ) { final int ch2 = input2 . read () ; if ( ch != ch2 ) { return false ; } ch = input1 . read () ; } final int ch2 = input2 . read () ; return ch2 == EOF ; MST[rv.UOI1Mutator]MSP[] }
while ( EOF != ch ) { final int ch2 = input2 . read () ; if ( ch != ch2 ) { return false ; } ch = input1 . read () ; } final int ch2 = input2 . read () ; return ch2 == EOF ; MST[rv.ROR1Mutator]MSP[] }
if ( inputOffset > 0 ) { skipFully ( input , inputOffset ) ; } if ( length == 0 ) { return 0 ; } int bytesToRead = buffer . length ; if ( length > 0 && length < buffer . length ) { MST[rv.ROR5Mutator]MSP[]
final int chunk = Math . min ( bytes , DEFAULT_BUFFER_SIZE ) ; MST[rv.CRCR5Mutator]MSP[] output . write ( data , offset , chunk ) ; bytes -= chunk ; offset += chunk ; } } } @Deprecated
return read ( input , buffer , 0 , buffer . length ) ; } public static int read ( final Reader input , final char [] buffer , final int offset , final int length ) throws IOException { if ( length < 0 ) { MST[rv.UOI4Mutator]MSP[]
final int ch2 = input2 . read () ; if ( ch != ch2 ) { MST[rv.UOI3Mutator]MSP[] return false ; } ch = input1 . read () ; } final int ch2 = input2 . read () ; return ch2 == EOF ; }
closeable . close () ; } } catch ( final IOException ioe ) { } } @Deprecated public static void closeQuietly ( final Closeable ... closeables ) { if ( closeables == null ) { return; } for ( final Closeable closeable : closeables ) { MST[rv.UOI1Mutator]MSP[]
output . write ( buffer , 0 , read ) ; MST[rv.UOI1Mutator]MSP[] totalRead += read ; if ( length > 0 ) { bytesToRead = ( int ) Math . min ( length - totalRead , buffer . length ) ; } } return totalRead ; }
while ( EOF != ch ) { final int ch2 = input2 . read () ; if ( ch != ch2 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return false ; } ch = input1 . read () ; } final int ch2 = input2 . read () ; return ch2 == EOF ; }
if ( SKIP_BYTE_BUFFER == null ) { SKIP_BYTE_BUFFER = new byte [ SKIP_BUFFER_SIZE ] ; } long remain = toSkip ; while ( remain > 0 ) { MST[rv.UOI3Mutator]MSP[]
public static int read ( final InputStream input , final byte [] buffer , final int offset , final int length ) throws IOException { if ( length < 0 ) { throw new IllegalArgumentException ( lr_2 + length ) ; MST[ConstructorCallMutator]MSP[] } int remaining = length ;
if ( toSkip < 0 ) { throw new IllegalArgumentException ( lr_7 + toSkip ) ; MST[rv.UOI1Mutator]MSP[] } final long skipped = skip ( input , toSkip ) ; if ( skipped != toSkip ) { throw new EOFException ( lr_8 + toSkip + lr_4 + skipped ) ; } }
if ( toSkip < 0 ) { throw new IllegalArgumentException ( lr_7 + toSkip ) ; } final long skipped = skip ( input , toSkip ) ; if ( skipped != toSkip ) { throw new EOFException ( lr_8 + toSkip + lr_4 + skipped ) ; MST[ConstructorCallMutator]MSP[] } }
if ( length == 0 ) { return 0 ; } final int bufferLength = buffer . length ; int bytesToRead = bufferLength ; if ( length > 0 && length < bufferLength ) { MST[ConditionalsBoundaryMutator]MSP[] bytesToRead = ( int ) length ; } int read ;
output . write ( buffer , 0 , read ) ; totalRead += read ; if ( length > 0 ) { MST[rv.CRCR6Mutator]MSP[] bytesToRead = ( int ) Math . min ( length - totalRead , buffer . length ) ; } } return totalRead ; }
long count = 0 ; int n ; while ( EOF != ( n = input . read ( buffer ) ) ) { buffer . flip () ; output . append ( buffer , 0 , n ) ; count += n ; MST[rv.AOR4Mutator]MSP[] } return count ; }
public static int copy ( final Reader input , final Writer output ) throws IOException { final long count = copyLarge ( input , output ) ; if ( count > Integer . MAX_VALUE ) { return - 1 ; MST[rv.CRCR2Mutator]MSP[] } return ( int ) count ; }
if ( SKIP_BYTE_BUFFER == null ) { SKIP_BYTE_BUFFER = new byte [ SKIP_BUFFER_SIZE ] ; MST[rv.CRCR6Mutator]MSP[] } long remain = toSkip ; while ( remain > 0 ) {
output . write ( buffer , 0 , read ) ; totalRead += read ; if ( length > 0 ) { bytesToRead = ( int ) Math . min ( length - totalRead , buffer . length ) ; MST[rv.UOI1Mutator]MSP[] } } return totalRead ; }
if ( inputOffset > 0 ) { skipFully ( input , inputOffset ) ; MST[rv.UOI2Mutator]MSP[] } if ( length == 0 ) { return 0 ; } int bytesToRead = buffer . length ; if ( length > 0 && length < buffer . length ) {
final byte [] bytes = input . getBytes ( Charsets . toCharset ( encoding ) ) ; return new ByteArrayInputStream ( bytes ) ; MST[ConstructorCallMutator]MSP[] } @Deprecated public static String toString ( final byte [] input ) throws IOException {
return length - remaining ; MST[rv.AOR2Mutator]MSP[] } public static int read ( final ReadableByteChannel input , final ByteBuffer buffer ) throws IOException { final int length = buffer . remaining () ; while ( buffer . remaining () > 0 ) {
public static int copy ( final Reader input , final Writer output ) throws IOException { final long count = copyLarge ( input , output ) ; if ( count > Integer . MAX_VALUE ) { return - 1 ; } return ( int ) count ; MST[ReturnValsMutator]MSP[] }
if ( length > 0 ) { bytesToRead = ( int ) Math . min ( length - totalRead , bufferLength ) ; MST[rv.UOI3Mutator]MSP[] } } return totalRead ; } public static long copy ( final Reader input , final Appendable output , final CharBuffer buffer ) throws IOException {
public static int read ( final InputStream input , final byte [] buffer , final int offset , final int length ) throws IOException { if ( length < 0 ) { throw new IllegalArgumentException ( lr_2 + length ) ; MST[experimental.NakedReceiverMutator]MSP[] } int remaining = length ;
if ( toSkip < 0 ) { throw new IllegalArgumentException ( lr_7 + toSkip ) ; } final long skipped = skip ( input , toSkip ) ; if ( skipped != toSkip ) { throw new EOFException ( lr_8 + toSkip + lr_4 + skipped ) ; MST[experimental.NakedReceiverMutator]MSP[] } }
public static void skipFully ( final Reader input , final long toSkip ) throws IOException { final long skipped = skip ( input , toSkip ) ; MST[rv.UOI2Mutator]MSP[] if ( skipped != toSkip ) { throw new EOFException ( lr_9 + toSkip + lr_4 + skipped ) ; } }
throw new EOFException ( lr_3 + length + lr_4 + actual ) ; } } public static byte [] readFully ( final InputStream input , final int length ) throws IOException { final byte [] buffer = new byte [ length ] ; MST[rv.ABSMutator]MSP[]
public static int read ( final InputStream input , final byte [] buffer , final int offset , final int length ) throws IOException { if ( length < 0 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] throw new IllegalArgumentException ( lr_2 + length ) ; } int remaining = length ;
while ( remaining > 0 ) { final int location = length - remaining ; final int count = input . read ( buffer , offset + location , remaining ) ; MST[rv.ABSMutator]MSP[] if ( EOF == count ) { break; } remaining -= count ; }
while ( offset < size && ( read = input . read ( data , offset , size - offset ) ) != EOF ) { offset += read ; MST[rv.ABSMutator]MSP[] } if ( offset != size ) {
output . write ( buffer , 0 , read ) ; totalRead += read ; if ( length > 0 ) { bytesToRead = ( int ) Math . min ( length - totalRead , buffer . length ) ; } } return totalRead ; MST[rv.UOI4Mutator]MSP[] }
closeQuietly ( ( Closeable ) output ) ; } public static boolean contentEquals ( InputStream input1 , InputStream input2 ) throws IOException { if ( input1 == input2 ) { return true ; MST[ReturnValsMutator]MSP[] } if ( ! ( input1 instanceof BufferedInputStream ) ) {
return new byte [ 0 ] ; MST[ReturnValsMutator]MSP[] } final byte [] data = new byte [ size ] ; int offset = 0 ; int read ;
return read ( input , buffer , 0 , buffer . length ) ; MST[rv.CRCR6Mutator]MSP[] } public static int read ( final Reader input , final char [] buffer , final int offset , final int length ) throws IOException { if ( length < 0 ) {
public static long skip ( final ReadableByteChannel input , final long toSkip ) throws IOException { if ( toSkip < 0 ) { MST[rv.UOI2Mutator]MSP[] throw new IllegalArgumentException ( lr_6 + toSkip ) ; }
if ( length == 0 ) { return 0 ; } final int bufferLength = buffer . length ; int bytesToRead = bufferLength ; if ( length > 0 && length < bufferLength ) { MST[rv.UOI1Mutator]MSP[] bytesToRead = ( int ) length ; } int read ;
return copyLarge ( input , output , inputOffset , length , new char [ DEFAULT_BUFFER_SIZE ] ) ; MST[rv.UOI3Mutator]MSP[] } public static long copyLarge ( final Reader input , final Writer output , final long inputOffset , final long length , final char [] buffer ) throws IOException {
final OutputStreamWriter out = new OutputStreamWriter ( output , Charsets . toCharset ( outputEncoding ) ) ; copy ( input , out ) ; MST[NonVoidMethodCallMutator]MSP[] out . flush () ; } public static void copy ( final Reader input , final OutputStream output , final String outputEncoding ) throws IOException {
while ( remaining > 0 ) { final int location = length - remaining ; final int count = input . read ( buffer , offset + location , remaining ) ; if ( EOF == count ) { break; } remaining -= count ; MST[rv.ABSMutator]MSP[] }
return toString ( uri . toURL () , Charsets . toCharset ( encoding ) ) ; } public static String toString ( final URI uri , final String encoding ) throws IOException { return toString ( uri , Charsets . toCharset ( encoding ) ) ; MST[NonVoidMethodCallMutator]MSP[] } @Deprecated
if ( toSkip < 0 ) { MST[rv.ROR4Mutator]MSP[] throw new IllegalArgumentException ( lr_7 + toSkip ) ; } final long skipped = skip ( input , toSkip ) ; if ( skipped != toSkip ) { throw new EOFException ( lr_8 + toSkip + lr_4 + skipped ) ; } }
final int ch2 = input2 . read () ; if ( ch != ch2 ) { return false ; } ch = input1 . read () ; } final int ch2 = input2 . read () ; return ch2 == EOF ; MST[InlineConstantMutator]MSP[] }
if ( EOF == count ) { break; } remaining -= count ; } return length - remaining ; MST[rv.ABSMutator]MSP[] } public static void readFully ( final InputStream input , final byte [] buffer ) throws IOException { readFully ( input , buffer , 0 , buffer . length ) ;
if ( toSkip < 0 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[] throw new IllegalArgumentException ( lr_7 + toSkip ) ; } final long skipped = skip ( input , toSkip ) ; if ( skipped != toSkip ) { throw new EOFException ( lr_8 + toSkip + lr_4 + skipped ) ; } }
public static BufferedOutputStream buffer ( final OutputStream outputStream , final int size ) { if ( outputStream == null ) { MST[rv.ROR5Mutator]MSP[] throw new NullPointerException () ; } return outputStream instanceof BufferedOutputStream ? ( BufferedOutputStream ) outputStream : new BufferedOutputStream ( outputStream , size ) ; }
bytesToRead = ( int ) length ; } int read ; long totalRead = 0 ; while ( bytesToRead > 0 && EOF != ( read = input . read ( buffer , 0 , bytesToRead ) ) ) { MST[rv.ROR2Mutator]MSP[]
final int ch2 = input2 . read () ; if ( ch != ch2 ) { return false ; } ch = input1 . read () ; } final int ch2 = input2 . read () ; return ch2 == EOF ; MST[NegateConditionalsMutator]MSP[] }
final int ch2 = input2 . read () ; if ( ch != ch2 ) { return false ; } ch = input1 . read () ; MST[NonVoidMethodCallMutator]MSP[] } final int ch2 = input2 . read () ; return ch2 == EOF ; }
if ( length == 0 ) { return 0 ; } final int bufferLength = buffer . length ; int bytesToRead = bufferLength ; if ( length > 0 && length < bufferLength ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[] bytesToRead = ( int ) length ; } int read ;
skipByteBuffer . limit ( ( int ) Math . min ( remain , SKIP_BUFFER_SIZE ) ) ; final int n = input . read ( skipByteBuffer ) ; if ( n == EOF ) { MST[rv.UOI1Mutator]MSP[] break; } remain -= n ; } return toSkip - remain ; }
final int chunk = Math . min ( bytes , DEFAULT_BUFFER_SIZE ) ; output . write ( data , offset , chunk ) ; MST[rv.UOI2Mutator]MSP[] bytes -= chunk ; offset += chunk ; } } } @Deprecated
skipByteBuffer . limit ( ( int ) Math . min ( remain , SKIP_BUFFER_SIZE ) ) ; final int n = input . read ( skipByteBuffer ) ; if ( n == EOF ) { break; } remain -= n ; } return toSkip - remain ; MST[PrimitiveReturnsMutator]MSP[] }
if ( toSkip < 0 ) { MST[rv.CRCR3Mutator]MSP[] throw new IllegalArgumentException ( lr_7 + toSkip ) ; } final long skipped = skip ( input , toSkip ) ; if ( skipped != toSkip ) { throw new EOFException ( lr_8 + toSkip + lr_4 + skipped ) ; } }
String line = reader . readLine () ; while ( line != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] list . add ( line ) ; line = reader . readLine () ; } return list ; } public static byte [] resourceToByteArray ( final String name ) throws IOException {
public static String resourceToString ( final String name , final Charset encoding ) throws IOException { return resourceToString ( name , encoding , null ) ; MST[NonVoidMethodCallMutator]MSP[] } public static String resourceToString ( final String name , final Charset encoding , final ClassLoader classLoader ) throws IOException {
final long n = input . read ( SKIP_BYTE_BUFFER , 0 , ( int ) Math . min ( remain , SKIP_BUFFER_SIZE ) ) ; if ( n < 0 ) { break; } remain -= n ; } return toSkip - remain ; MST[PrimitiveReturnsMutator]MSP[] }
return length - remaining ; MST[rv.UOI4Mutator]MSP[] } public static int read ( final ReadableByteChannel input , final ByteBuffer buffer ) throws IOException { final int length = buffer . remaining () ; while ( buffer . remaining () > 0 ) {
public static void skipFully ( final Reader input , final long toSkip ) throws IOException { final long skipped = skip ( input , toSkip ) ; if ( skipped != toSkip ) { MST[rv.UOI2Mutator]MSP[] throw new EOFException ( lr_9 + toSkip + lr_4 + skipped ) ; } }
int offset = 0 ; while ( bytes > 0 ) { final int chunk = Math . min ( bytes , DEFAULT_BUFFER_SIZE ) ; output . write ( data , offset , chunk ) ; bytes -= chunk ; offset += chunk ; MST[rv.UOI1Mutator]MSP[] } } }
write ( data , output , Charsets . toCharset ( encoding ) ) ; MST[NonVoidMethodCallMutator]MSP[] } public static void write ( final String data , final Writer output ) throws IOException { if ( data != null ) { output . write ( data ) ; } } @Deprecated
skipByteBuffer . limit ( ( int ) Math . min ( remain , SKIP_BUFFER_SIZE ) ) ; final int n = input . read ( skipByteBuffer ) ; if ( n == EOF ) { MST[rv.CRCR2Mutator]MSP[] break; } remain -= n ; } return toSkip - remain ; }
throw new IOException ( lr_5 + name ) ; } return resource ; } public static long skip ( final InputStream input , final long toSkip ) throws IOException { if ( toSkip < 0 ) { throw new IllegalArgumentException ( lr_6 + toSkip ) ; MST[NonVoidMethodCallMutator]MSP[] }
public static BufferedInputStream buffer ( final InputStream inputStream ) { if ( inputStream == null ) { throw new NullPointerException () ; } return inputStream instanceof BufferedInputStream ? MST[rv.ROR5Mutator]MSP[] ( BufferedInputStream ) inputStream : new BufferedInputStream ( inputStream ) ; }
output . write ( buffer , 0 , read ) ; totalRead += read ; MST[rv.UOI3Mutator]MSP[] if ( length > 0 ) { bytesToRead = ( int ) Math . min ( length - totalRead , buffer . length ) ; } } return totalRead ; }
return reader instanceof BufferedReader ? ( BufferedReader ) reader : new BufferedReader ( reader , size ) ; MST[rv.ROR5Mutator]MSP[] } public static byte [] toByteArray ( final InputStream input ) throws IOException { try ( final ByteArrayOutputStream output = new ByteArrayOutputStream () ) { copy ( input , output ) ;
closeable . close () ; } } catch ( final IOException ioe ) { } } @Deprecated public static void closeQuietly ( final Closeable ... closeables ) { if ( closeables == null ) { return; } for ( final Closeable closeable : closeables ) { MST[rv.UOI1Mutator]MSP[]
final int count = input . read ( buffer ) ; if ( EOF == count ) { break; } } return length - buffer . remaining () ; MST[rv.AOR4Mutator]MSP[] } public static int read ( final Reader input , final char [] buffer ) throws IOException {
final int chunk = Math . min ( bytes , DEFAULT_BUFFER_SIZE ) ; output . write ( data , offset , chunk ) ; bytes -= chunk ; MST[rv.UOI3Mutator]MSP[] offset += chunk ; } } } @Deprecated
public static void copy ( final InputStream input , final Writer output , final String inputEncoding ) throws IOException { copy ( input , output , Charsets . toCharset ( inputEncoding ) ) ; MST[NonVoidMethodCallMutator]MSP[] } @Deprecated public static void copy ( final Reader input , final OutputStream output )
if ( toSkip < 0 ) { throw new IllegalArgumentException ( lr_7 + toSkip ) ; } final long skipped = skip ( input , toSkip ) ; MST[rv.UOI4Mutator]MSP[] if ( skipped != toSkip ) { throw new EOFException ( lr_8 + toSkip + lr_4 + skipped ) ; } }
if ( inputOffset > 0 ) { skipFully ( input , inputOffset ) ; } if ( length == 0 ) { return 0 ; } int bytesToRead = buffer . length ; if ( length > 0 && length < buffer . length ) { MST[rv.UOI1Mutator]MSP[]
final int actual = read ( input , buffer , offset , length ) ; if ( actual != length ) { MST[rv.ROR3Mutator]MSP[] throw new EOFException ( lr_3 + length + lr_4 + actual ) ; } } @Deprecated
public static long skip ( final Reader input , final long toSkip ) throws IOException { if ( toSkip < 0 ) { throw new IllegalArgumentException ( lr_6 + toSkip ) ; } if ( SKIP_CHAR_BUFFER == null ) { SKIP_CHAR_BUFFER = new char [ SKIP_BUFFER_SIZE ] ; MST[InlineConstantMutator]MSP[] }
long count = 0 ; int n ; while ( EOF != ( n = input . read ( buffer ) ) ) { buffer . flip () ; output . append ( buffer , 0 , n ) ; count += n ; MST[rv.UOI4Mutator]MSP[] } return count ; }
if ( inputOffset > 0 ) { skipFully ( input , inputOffset ) ; } if ( length == 0 ) { MST[rv.CRCR5Mutator]MSP[] return 0 ; } int bytesToRead = buffer . length ; if ( length > 0 && length < buffer . length ) {
if ( length == 0 ) { return 0 ; } final int bufferLength = buffer . length ; int bytesToRead = bufferLength ; if ( length > 0 && length < bufferLength ) { MST[rv.ROR5Mutator]MSP[] bytesToRead = ( int ) length ; } int read ;
final int count = input . read ( buffer ) ; if ( EOF == count ) { break; } } return length - buffer . remaining () ; MST[rv.AOD2Mutator]MSP[] } public static int read ( final Reader input , final char [] buffer ) throws IOException {
final int actual = read ( input , buffer ) ; if ( actual != expected ) { throw new EOFException ( lr_3 + expected + lr_4 + actual ) ; MST[rv.UOI3Mutator]MSP[] } } public static void readFully ( final Reader input , final char [] buffer ) throws IOException {
return toString ( uri . toURL () , Charsets . toCharset ( encoding ) ) ; MST[EmptyObjectReturnValsMutator]MSP[] } public static String toString ( final URI uri , final String encoding ) throws IOException { return toString ( uri , Charsets . toCharset ( encoding ) ) ; } @Deprecated
int offset = 0 ; while ( bytes > 0 ) { final int chunk = Math . min ( bytes , DEFAULT_BUFFER_SIZE ) ; output . write ( data , offset , chunk ) ; bytes -= chunk ; MST[MathMutator]MSP[] offset += chunk ; } } }
public static void writeLines ( final Collection < ? > lines , String lineEnding , final OutputStream output , final Charset encoding ) throws IOException { if ( lines == null ) { return; } if ( lineEnding == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] lineEnding = LINE_SEPARATOR ; }
long remain = toSkip ; while ( remain > 0 ) { final long n = input . read ( SKIP_CHAR_BUFFER , 0 , ( int ) Math . min ( remain , SKIP_BUFFER_SIZE ) ) ; if ( n < 0 ) { MST[rv.UOI2Mutator]MSP[] break; } remain -= n ;
public static void write ( final CharSequence data , final Writer output ) throws IOException { if ( data != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] write ( data . toString () , output ) ; } } @Deprecated public static void write ( final String data , final OutputStream output )
if ( toSkip < 0 ) { throw new IllegalArgumentException ( lr_7 + toSkip ) ; } final long skipped = skip ( input , toSkip ) ; if ( skipped != toSkip ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] throw new EOFException ( lr_8 + toSkip + lr_4 + skipped ) ; } }
return readLines ( input , Charsets . toCharset ( encoding ) ) ; MST[NonVoidMethodCallMutator]MSP[] } public static List < String > readLines ( final Reader input ) throws IOException { final BufferedReader reader = toBufferedReader ( input ) ; final List < String > list = new ArrayList <> () ;
if ( EOF == count ) { MST[rv.CRCR2Mutator]MSP[] break; } remaining -= count ; } return length - remaining ; } public static void readFully ( final InputStream input , final byte [] buffer ) throws IOException { readFully ( input , buffer , 0 , buffer . length ) ;
public static BufferedOutputStream buffer ( final OutputStream outputStream , final int size ) { if ( outputStream == null ) { throw new NullPointerException () ; } return outputStream instanceof BufferedOutputStream ? MST[rv.ABSMutator]MSP[] ( BufferedOutputStream ) outputStream : new BufferedOutputStream ( outputStream , size ) ; }
final int count = input . read ( buffer ) ; if ( EOF == count ) { break; } } return length - buffer . remaining () ; MST[rv.UOI2Mutator]MSP[] } public static int read ( final Reader input , final char [] buffer ) throws IOException {
output . write ( buffer , 0 , read ) ; totalRead += read ; if ( length > 0 ) { bytesToRead = ( int ) Math . min ( length - totalRead , buffer . length ) ; MST[rv.UOI2Mutator]MSP[] } } return totalRead ; }
public static void write ( final byte [] data , final Writer output , final String encoding ) throws IOException { write ( data , output , Charsets . toCharset ( encoding ) ) ; MST[VoidMethodCallMutator]MSP[] } @Deprecated
public static LineIterator lineIterator ( final InputStream input , final String encoding ) throws IOException { return lineIterator ( input , Charsets . toCharset ( encoding ) ) ; MST[NullReturnValsMutator]MSP[] } public static LineIterator lineIterator ( final Reader reader ) { return new LineIterator ( reader ) ; }
final int actual = read ( input , buffer ) ; MST[NonVoidMethodCallMutator]MSP[] if ( actual != expected ) { throw new EOFException ( lr_3 + expected + lr_4 + actual ) ; } } public static void readFully ( final Reader input , final char [] buffer ) throws IOException {
return output . toByteArray () ; } } public static byte [] toByteArray ( final InputStream input , final int size ) throws IOException { if ( size < 0 ) { throw new IllegalArgumentException ( lr_10 + size ) ; } if ( size == 0 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
final int actual = read ( input , buffer ) ; if ( actual != expected ) { throw new EOFException ( lr_3 + expected + lr_4 + actual ) ; MST[NonVoidMethodCallMutator]MSP[] } } public static void readFully ( final Reader input , final char [] buffer ) throws IOException {
if ( data != null ) { output . write ( data . toString () . getBytes ( Charsets . toCharset ( encoding ) ) ) ; MST[VoidMethodCallMutator]MSP[] } } @Deprecated public static void write ( final StringBuffer data , final Writer output ) throws IOException {
final int chunk = Math . min ( bytes , DEFAULT_BUFFER_SIZE ) ; output . write ( data , offset , chunk ) ; MST[rv.UOI1Mutator]MSP[] bytes -= chunk ; offset += chunk ; } } } @Deprecated
public static long copyLarge ( final InputStream input , final OutputStream output , final long inputOffset , final long length ) throws IOException { return copyLarge ( input , output , inputOffset , length , new byte [ DEFAULT_BUFFER_SIZE ] ) ; MST[InlineConstantMutator]MSP[] }
bytesToRead = ( int ) length ; } int read ; long totalRead = 0 ; while ( bytesToRead > 0 && EOF != ( read = input . read ( buffer , 0 , bytesToRead ) ) ) { MST[InlineConstantMutator]MSP[]
while ( offset < size && ( read = input . read ( data , offset , size - offset ) ) != EOF ) { MST[rv.AOR4Mutator]MSP[] offset += read ; } if ( offset != size ) {
if ( inputOffset > 0 ) { skipFully ( input , inputOffset ) ; } if ( length == 0 ) { return 0 ; } int bytesToRead = buffer . length ; if ( length > 0 && length < buffer . length ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[]
throw new IOException ( lr_5 + name ) ; } return resource ; } public static long skip ( final InputStream input , final long toSkip ) throws IOException { if ( toSkip < 0 ) { throw new IllegalArgumentException ( lr_6 + toSkip ) ; MST[rv.UOI3Mutator]MSP[] }
while ( EOF != ch ) { final int ch2 = input2 . read () ; if ( ch != ch2 ) { return false ; } ch = input1 . read () ; } final int ch2 = input2 . read () ; return ch2 == EOF ; MST[InlineConstantMutator]MSP[] }
if ( EOF == count ) { break; } remaining -= count ; } return length - remaining ; MST[rv.AOD2Mutator]MSP[] } public static void readFully ( final InputStream input , final byte [] buffer ) throws IOException { readFully ( input , buffer , 0 , buffer . length ) ;
final int ch2 = input2 . read () ; if ( ch != ch2 ) { MST[rv.UOI3Mutator]MSP[] return false ; } ch = input1 . read () ; } final int ch2 = input2 . read () ; return ch2 == EOF ; }
public static long skip ( final ReadableByteChannel input , final long toSkip ) throws IOException { if ( toSkip < 0 ) { MST[rv.ROR4Mutator]MSP[] throw new IllegalArgumentException ( lr_6 + toSkip ) ; }
output . write ( buffer , 0 , read ) ; totalRead += read ; if ( length > 0 ) { bytesToRead = ( int ) Math . min ( length - totalRead , buffer . length ) ; MST[MathMutator]MSP[] } } return totalRead ; }
public static InputStream toInputStream ( final String input , final Charset encoding ) { return new ByteArrayInputStream ( input . getBytes ( Charsets . toCharset ( encoding ) ) ) ; MST[ConstructorCallMutator]MSP[] } public static InputStream toInputStream ( final String input , final String encoding ) throws IOException {
public static long skip ( final ReadableByteChannel input , final long toSkip ) throws IOException { if ( toSkip < 0 ) { throw new IllegalArgumentException ( lr_6 + toSkip ) ; MST[NonVoidMethodCallMutator]MSP[] }
public static String toString ( final InputStream input ) throws IOException { return toString ( input , Charset . defaultCharset () ) ; MST[ReturnValsMutator]MSP[] } public static String toString ( final InputStream input , final Charset encoding ) throws IOException {
} return toSkip - remain ; } public static void skipFully ( final InputStream input , final long toSkip ) throws IOException { if ( toSkip < 0 ) { MST[rv.UOI3Mutator]MSP[] throw new IllegalArgumentException ( lr_7 + toSkip ) ; }
if ( toSkip < 0 ) { MST[rv.CRCR6Mutator]MSP[] throw new IllegalArgumentException ( lr_7 + toSkip ) ; } final long skipped = skip ( input , toSkip ) ; if ( skipped != toSkip ) { throw new EOFException ( lr_8 + toSkip + lr_4 + skipped ) ; } }
int offset = 0 ; while ( bytes > 0 ) { final int chunk = Math . min ( bytes , DEFAULT_BUFFER_SIZE ) ; output . write ( data , offset , chunk ) ; bytes -= chunk ; offset += chunk ; MST[rv.UOI4Mutator]MSP[] } } }
public static long copyLarge ( final InputStream input , final OutputStream output , final long inputOffset , final long length , final byte [] buffer ) throws IOException { if ( inputOffset > 0 ) { MST[rv.ROR1Mutator]MSP[] skipFully ( input , inputOffset ) ; }
final int actual = read ( input , buffer ) ; if ( actual != expected ) { MST[rv.ABSMutator]MSP[] throw new EOFException ( lr_3 + expected + lr_4 + actual ) ; } } public static void readFully ( final Reader input , final char [] buffer ) throws IOException {
output . write ( buffer , 0 , read ) ; MST[rv.CRCR3Mutator]MSP[] totalRead += read ; if ( length > 0 ) { bytesToRead = ( int ) Math . min ( length - totalRead , buffer . length ) ; } } return totalRead ; }
} public static void write ( final byte [] data , final OutputStream output ) throws IOException { if ( data != null ) { output . write ( data ) ; MST[VoidMethodCallMutator]MSP[] } } @Deprecated
skipByteBuffer . limit ( ( int ) Math . min ( remain , SKIP_BUFFER_SIZE ) ) ; final int n = input . read ( skipByteBuffer ) ; if ( n == EOF ) { MST[rv.CRCR5Mutator]MSP[] break; } remain -= n ; } return toSkip - remain ; }
public static BufferedInputStream buffer ( final InputStream inputStream ) { if ( inputStream == null ) { throw new NullPointerException () ; } return inputStream instanceof BufferedInputStream ? MST[rv.ROR2Mutator]MSP[] ( BufferedInputStream ) inputStream : new BufferedInputStream ( inputStream ) ; }
public static int length ( final byte [] array ) { return array == null ? 0 : array . length ; } public static int length ( final char [] array ) { return array == null ? 0 : array . length ; MST[rv.CRCR1Mutator]MSP[] }
return new byte [ 0 ] ; } final byte [] data = new byte [ size ] ; int offset = 0 ; MST[rv.CRCR6Mutator]MSP[] int read ;
while ( EOF != ch ) { final int ch2 = input2 . read () ; if ( ch != ch2 ) { return false ; } ch = input1 . read () ; } final int ch2 = input2 . read () ; return ch2 == EOF ; MST[rv.CRCR4Mutator]MSP[] }
long totalRead = 0 ; while ( bytesToRead > 0 && EOF != ( read = input . read ( buffer , 0 , bytesToRead ) ) ) { output . write ( buffer , 0 , read ) ; totalRead += read ; MST[rv.AOR1Mutator]MSP[]
try ( InputStream inputStream = url . openStream () ) { return toString ( inputStream , encoding ) ; MST[NonVoidMethodCallMutator]MSP[] } } public static String toString ( final URL url , final String encoding ) throws IOException { return toString ( url , Charsets . toCharset ( encoding ) ) ;
long count = 0 ; int n ; while ( EOF != ( n = input . read ( buffer ) ) ) { buffer . flip () ; output . append ( buffer , 0 , n ) ; count += n ; MST[rv.UOI1Mutator]MSP[] } return count ; }
long count = 0 ; int n ; while ( EOF != ( n = input . read ( buffer ) ) ) { buffer . flip () ; output . append ( buffer , 0 , n ) ; MST[rv.ABSMutator]MSP[] count += n ; } return count ; }
int offset = 0 ; while ( bytes > 0 ) { final int chunk = Math . min ( bytes , DEFAULT_BUFFER_SIZE ) ; MST[rv.UOI3Mutator]MSP[] output . write ( data , offset , chunk ) ; bytes -= chunk ; offset += chunk ; } } }
throw new IllegalArgumentException ( lr_2 + length ) ; } int remaining = length ; while ( remaining > 0 ) { final int location = length - remaining ; MST[rv.UOI1Mutator]MSP[] final int count = input . read ( buffer , offset + location , remaining ) ;
skipByteBuffer . limit ( ( int ) Math . min ( remain , SKIP_BUFFER_SIZE ) ) ; final int n = input . read ( skipByteBuffer ) ; if ( n == EOF ) { break; } remain -= n ; MST[rv.AOR2Mutator]MSP[] } return toSkip - remain ; }
final ByteBuffer skipByteBuffer = ByteBuffer . allocate ( ( int ) Math . min ( toSkip , SKIP_BUFFER_SIZE ) ) ; long remain = toSkip ; while ( remain > 0 ) { MST[rv.ROR4Mutator]MSP[] skipByteBuffer . position ( 0 ) ;
while ( EOF != ch ) { final int ch2 = input2 . read () ; if ( ch != ch2 ) { MST[rv.ROR3Mutator]MSP[] return false ; } ch = input1 . read () ; } final int ch2 = input2 . read () ; return ch2 == EOF ; }
public static long copyLarge ( final InputStream input , final OutputStream output , final long inputOffset , final long length , final byte [] buffer ) throws IOException { if ( inputOffset > 0 ) { MST[rv.CRCR6Mutator]MSP[] skipFully ( input , inputOffset ) ; }
output . write ( buffer , 0 , read ) ; totalRead += read ; if ( length > 0 ) { bytesToRead = ( int ) Math . min ( length - totalRead , buffer . length ) ; MST[rv.ABSMutator]MSP[] } } return totalRead ; }
public static int copy ( final Reader input , final Writer output ) throws IOException { final long count = copyLarge ( input , output ) ; if ( count > Integer . MAX_VALUE ) { return - 1 ; MST[rv.CRCR6Mutator]MSP[] } return ( int ) count ; }
throw new IllegalArgumentException ( lr_2 + length ) ; MST[experimental.NakedReceiverMutator]MSP[] } int remaining = length ; while ( remaining > 0 ) { final int location = length - remaining ; final int count = input . read ( buffer , offset + location , remaining ) ;
final int actual = read ( input , buffer , offset , length ) ; if ( actual != length ) { throw new EOFException ( lr_3 + length + lr_4 + actual ) ; MST[experimental.NakedReceiverMutator]MSP[] } } @Deprecated
long remain = toSkip ; while ( remain > 0 ) { final long n = input . read ( SKIP_CHAR_BUFFER , 0 , ( int ) Math . min ( remain , SKIP_BUFFER_SIZE ) ) ; if ( n < 0 ) { MST[ConditionalsBoundaryMutator]MSP[] break; } remain -= n ;
while ( remaining > 0 ) { final int location = length - remaining ; MST[rv.ABSMutator]MSP[] final int count = input . read ( buffer , offset + location , remaining ) ; if ( EOF == count ) { break; } remaining -= count ; }
final CharArrayWriter sw = new CharArrayWriter () ; MST[ConstructorCallMutator]MSP[] copy ( input , sw ) ; return sw . toCharArray () ; } @Deprecated public static InputStream toInputStream ( final CharSequence input ) { return toInputStream ( input , Charset . defaultCharset () ) ; }
public static int read ( final InputStream input , final byte [] buffer , final int offset , final int length ) throws IOException { if ( length < 0 ) { throw new IllegalArgumentException ( lr_2 + length ) ; MST[rv.ABSMutator]MSP[] } int remaining = length ;
final int count = input . read ( buffer ) ; if ( EOF == count ) { break; } } return length - buffer . remaining () ; MST[rv.AOR1Mutator]MSP[] } public static int read ( final Reader input , final char [] buffer ) throws IOException {
throw new IllegalArgumentException ( lr_2 + length ) ; } int remaining = length ; while ( remaining > 0 ) { MST[rv.ABSMutator]MSP[] final int location = length - remaining ; final int count = input . read ( buffer , offset + location , remaining ) ;
closeable . close () ; } } catch ( final IOException ioe ) { } } @Deprecated public static void closeQuietly ( final Closeable ... closeables ) { if ( closeables == null ) { MST[NegateConditionalsMutator]MSP[] return; } for ( final Closeable closeable : closeables ) {
return read ( input , buffer , 0 , buffer . length ) ; MST[InlineConstantMutator]MSP[] } public static int read ( final Reader input , final char [] buffer , final int offset , final int length ) throws IOException { if ( length < 0 ) {
if ( toSkip < 0 ) { throw new IllegalArgumentException ( lr_7 + toSkip ) ; } final long skipped = skip ( input , toSkip ) ; MST[rv.UOI1Mutator]MSP[] if ( skipped != toSkip ) { throw new EOFException ( lr_8 + toSkip + lr_4 + skipped ) ; } }
String line1 = br1 . readLine () ; String line2 = br2 . readLine () ; while ( line1 != null && line2 != null && line1 . equals ( line2 ) ) { MST[rv.ROR5Mutator]MSP[] line1 = br1 . readLine () ; line2 = br2 . readLine () ; }
if ( SKIP_BYTE_BUFFER == null ) { SKIP_BYTE_BUFFER = new byte [ SKIP_BUFFER_SIZE ] ; } long remain = toSkip ; while ( remain > 0 ) { MST[rv.ROR4Mutator]MSP[]
while ( remaining > 0 ) { final int location = length - remaining ; final int count = input . read ( buffer , offset + location , remaining ) ; if ( EOF == count ) { MST[rv.ABSMutator]MSP[] break; } remaining -= count ; }
output . write ( buffer , 0 , read ) ; totalRead += read ; if ( length > 0 ) { MST[rv.ROR4Mutator]MSP[] bytesToRead = ( int ) Math . min ( length - totalRead , buffer . length ) ; } } return totalRead ; }
return read ( input , buffer , 0 , buffer . length ) ; } public static int read ( final Reader input , final char [] buffer , final int offset , final int length ) throws IOException { if ( length < 0 ) { MST[NegateConditionalsMutator]MSP[]
if ( EOF == count ) { break; } remaining -= count ; } return length - remaining ; MST[rv.UOI1Mutator]MSP[] } public static void readFully ( final InputStream input , final byte [] buffer ) throws IOException { readFully ( input , buffer , 0 , buffer . length ) ;
long remain = toSkip ; while ( remain > 0 ) { final long n = input . read ( SKIP_CHAR_BUFFER , 0 , ( int ) Math . min ( remain , SKIP_BUFFER_SIZE ) ) ; if ( n < 0 ) { MST[NegateConditionalsMutator]MSP[] break; } remain -= n ;
bytesToRead = ( int ) length ; } int read ; long totalRead = 0 ; while ( bytesToRead > 0 && EOF != ( read = input . read ( buffer , 0 , bytesToRead ) ) ) { MST[rv.CRCR4Mutator]MSP[]
final long n = input . read ( SKIP_BYTE_BUFFER , 0 , ( int ) Math . min ( remain , SKIP_BUFFER_SIZE ) ) ; MST[rv.CRCR6Mutator]MSP[] if ( n < 0 ) { break; } remain -= n ; } return toSkip - remain ; }
bytesToRead = ( int ) length ; } int read ; long totalRead = 0 ; while ( bytesToRead > 0 && EOF != ( read = input . read ( buffer , 0 , bytesToRead ) ) ) { MST[rv.ROR3Mutator]MSP[]
public static long skip ( final Reader input , final long toSkip ) throws IOException { if ( toSkip < 0 ) { throw new IllegalArgumentException ( lr_6 + toSkip ) ; } if ( SKIP_CHAR_BUFFER == null ) { SKIP_CHAR_BUFFER = new char [ SKIP_BUFFER_SIZE ] ; MST[rv.CRCR4Mutator]MSP[] }
} public static void write ( final char [] data , final OutputStream output , final String encoding ) throws IOException { write ( data , output , Charsets . toCharset ( encoding ) ) ; MST[VoidMethodCallMutator]MSP[] }
while ( offset < size && ( read = input . read ( data , offset , size - offset ) ) != EOF ) { offset += read ; MST[MathMutator]MSP[] } if ( offset != size ) {
throw new IOException ( lr_11 + offset + lr_12 + size ) ; MST[rv.UOI4Mutator]MSP[] } return data ; } public static byte [] toByteArray ( final InputStream input , final long size ) throws IOException { if ( size > Integer . MAX_VALUE ) {
final int chunk = Math . min ( bytes , DEFAULT_BUFFER_SIZE ) ; output . write ( data , offset , chunk ) ; bytes -= chunk ; offset += chunk ; MST[rv.ABSMutator]MSP[] } } } @Deprecated
return output . toByteArray () ; } } public static byte [] toByteArray ( final InputStream input , final int size ) throws IOException { if ( size < 0 ) { throw new IllegalArgumentException ( lr_10 + size ) ; MST[NonVoidMethodCallMutator]MSP[] } if ( size == 0 ) {
final ByteBuffer skipByteBuffer = ByteBuffer . allocate ( ( int ) Math . min ( toSkip , SKIP_BUFFER_SIZE ) ) ; MST[rv.CRCR3Mutator]MSP[] long remain = toSkip ; while ( remain > 0 ) { skipByteBuffer . position ( 0 ) ;
public static InputStream toInputStream ( final String input , final Charset encoding ) { return new ByteArrayInputStream ( input . getBytes ( Charsets . toCharset ( encoding ) ) ) ; MST[ArgumentPropagationMutator]MSP[] } public static InputStream toInputStream ( final String input , final String encoding ) throws IOException {
return line1 == null ? line2 == null ? true : false : line1 . equals ( line2 ) ; MST[ReturnValsMutator]MSP[] } public static int copy ( final InputStream input , final OutputStream output ) throws IOException { final long count = copyLarge ( input , output ) ;
return output . toByteArray () ; } } public static byte [] toByteArray ( final InputStream input , final int size ) throws IOException { if ( size < 0 ) { MST[rv.ROR1Mutator]MSP[] throw new IllegalArgumentException ( lr_10 + size ) ; } if ( size == 0 ) {
while ( remaining > 0 ) { final int location = length - remaining ; final int count = input . read ( buffer , offset + location , remaining ) ; if ( EOF == count ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] break; } remaining -= count ; }
bytesToRead = ( int ) length ; } int read ; long totalRead = 0 ; while ( bytesToRead > 0 && EOF != ( read = input . read ( buffer , 0 , bytesToRead ) ) ) { MST[rv.CRCR5Mutator]MSP[]
final int ch2 = input2 . read () ; if ( ch != ch2 ) { MST[rv.ROR4Mutator]MSP[] return false ; } ch = input1 . read () ; } final int ch2 = input2 . read () ; return ch2 == EOF ; }
if ( inputOffset > 0 ) { skipFully ( input , inputOffset ) ; MST[rv.UOI4Mutator]MSP[] } if ( length == 0 ) { return 0 ; } int bytesToRead = buffer . length ; if ( length > 0 && length < buffer . length ) {
public static long skip ( final ReadableByteChannel input , final long toSkip ) throws IOException { if ( toSkip < 0 ) { throw new IllegalArgumentException ( lr_6 + toSkip ) ; MST[rv.UOI4Mutator]MSP[] }
skipByteBuffer . limit ( ( int ) Math . min ( remain , SKIP_BUFFER_SIZE ) ) ; final int n = input . read ( skipByteBuffer ) ; if ( n == EOF ) { MST[rv.ROR1Mutator]MSP[] break; } remain -= n ; } return toSkip - remain ; }
skipByteBuffer . limit ( ( int ) Math . min ( remain , SKIP_BUFFER_SIZE ) ) ; MST[rv.CRCR6Mutator]MSP[] final int n = input . read ( skipByteBuffer ) ; if ( n == EOF ) { break; } remain -= n ; } return toSkip - remain ; }
return length - remaining ; MST[rv.AOR4Mutator]MSP[] } public static int read ( final ReadableByteChannel input , final ByteBuffer buffer ) throws IOException { final int length = buffer . remaining () ; while ( buffer . remaining () > 0 ) {
return reader instanceof BufferedReader ? ( BufferedReader ) reader : new BufferedReader ( reader , size ) ; MST[ReturnValsMutator]MSP[] } public static BufferedWriter buffer ( final Writer writer ) { return writer instanceof BufferedWriter ? ( BufferedWriter ) writer : new BufferedWriter ( writer ) ; }
long totalRead = 0 ; MST[rv.CRCR5Mutator]MSP[] while ( bytesToRead > 0 && EOF != ( read = input . read ( buffer , 0 , bytesToRead ) ) ) { output . write ( buffer , 0 , read ) ; totalRead += read ;
if ( inputOffset > 0 ) { skipFully ( input , inputOffset ) ; } if ( length == 0 ) { return 0 ; } int bytesToRead = buffer . length ; if ( length > 0 && length < buffer . length ) { MST[rv.ROR4Mutator]MSP[]
final int chunk = Math . min ( bytes , DEFAULT_BUFFER_SIZE ) ; MST[rv.CRCR6Mutator]MSP[] output . write ( data , offset , chunk ) ; bytes -= chunk ; offset += chunk ; } } } @Deprecated
public static int read ( final InputStream input , final byte [] buffer ) throws IOException { return read ( input , buffer , 0 , buffer . length ) ; MST[rv.CRCR6Mutator]MSP[] }
public static int read ( final InputStream input , final byte [] buffer , final int offset , final int length ) throws IOException { if ( length < 0 ) { throw new IllegalArgumentException ( lr_2 + length ) ; } int remaining = length ; MST[rv.UOI3Mutator]MSP[]
if ( length > 0 ) { MST[rv.CRCR5Mutator]MSP[] bytesToRead = ( int ) Math . min ( length - totalRead , bufferLength ) ; } } return totalRead ; } public static long copy ( final Reader input , final Appendable output , final CharBuffer buffer ) throws IOException {
closeQuietly ( ( Closeable ) output ) ; } public static boolean contentEquals ( InputStream input1 , InputStream input2 ) throws IOException { if ( input1 == input2 ) { MST[NegateConditionalsMutator]MSP[] return true ; } if ( ! ( input1 instanceof BufferedInputStream ) ) {
throw new IOException ( lr_11 + offset + lr_12 + size ) ; } return data ; MST[NullReturnValsMutator]MSP[] } public static byte [] toByteArray ( final InputStream input , final long size ) throws IOException { if ( size > Integer . MAX_VALUE ) {
output . write ( lineEnding . getBytes ( cs ) ) ; MST[NonVoidMethodCallMutator]MSP[] } } public static void writeLines ( final Collection < ? > lines , final String lineEnding , final OutputStream output , final String encoding ) throws IOException {
if ( inputOffset > 0 ) { skipFully ( input , inputOffset ) ; MST[rv.UOI1Mutator]MSP[] } if ( length == 0 ) { return 0 ; } int bytesToRead = buffer . length ; if ( length > 0 && length < buffer . length ) {
public static BufferedOutputStream buffer ( final OutputStream outputStream ) { if ( outputStream == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] throw new NullPointerException () ; } return outputStream instanceof BufferedOutputStream ? ( BufferedOutputStream ) outputStream : new BufferedOutputStream ( outputStream ) ; }
final int actual = read ( input , buffer , offset , length ) ; if ( actual != length ) { throw new EOFException ( lr_3 + length + lr_4 + actual ) ; MST[rv.UOI4Mutator]MSP[] } } @Deprecated
while ( EOF != ch ) { final int ch2 = input2 . read () ; if ( ch != ch2 ) { MST[rv.UOI2Mutator]MSP[] return false ; } ch = input1 . read () ; } final int ch2 = input2 . read () ; return ch2 == EOF ; }
long count = 0 ; int n ; while ( EOF != ( n = input . read ( buffer ) ) ) { buffer . flip () ; output . append ( buffer , 0 , n ) ; count += n ; } return count ; MST[rv.UOI4Mutator]MSP[] }
final long skipped = skip ( input , toSkip ) ; if ( skipped != toSkip ) { MST[rv.ROR5Mutator]MSP[] throw new EOFException ( lr_8 + toSkip + lr_4 + skipped ) ; } } public static void skipFully ( final ReadableByteChannel input , final long toSkip ) throws IOException {
final int ch2 = input2 . read () ; if ( ch != ch2 ) { MST[rv.ROR1Mutator]MSP[] return false ; } ch = input1 . read () ; } final int ch2 = input2 . read () ; return ch2 == EOF ; }
final int actual = read ( input , buffer , offset , length ) ; if ( actual != length ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] throw new EOFException ( lr_3 + length + lr_4 + actual ) ; } } @Deprecated
public static int length ( final CharSequence csq ) { return csq == null ? 0 : csq . length () ; MST[PrimitiveReturnsMutator]MSP[] } public static int length ( final Object [] array ) { return array == null ? 0 : array . length ; }
if ( inputOffset > 0 ) { MST[NegateConditionalsMutator]MSP[] skipFully ( input , inputOffset ) ; } if ( length == 0 ) { return 0 ; } int bytesToRead = buffer . length ; if ( length > 0 && length < buffer . length ) {
throw new IllegalArgumentException ( lr_2 + length ) ; } int remaining = length ; while ( remaining > 0 ) { final int location = length - remaining ; MST[rv.UOI4Mutator]MSP[] final int count = input . read ( buffer , offset + location , remaining ) ;
throw new IOException ( lr_5 + name ) ; MST[ConstructorCallMutator]MSP[] } return resource ; } public static long skip ( final InputStream input , final long toSkip ) throws IOException { if ( toSkip < 0 ) { throw new IllegalArgumentException ( lr_6 + toSkip ) ; }
if ( SKIP_BYTE_BUFFER == null ) { SKIP_BYTE_BUFFER = new byte [ SKIP_BUFFER_SIZE ] ; } long remain = toSkip ; while ( remain > 0 ) { MST[rv.UOI2Mutator]MSP[]
final int ch2 = input2 . read () ; if ( ch != ch2 ) { return false ; } ch = input1 . read () ; } final int ch2 = input2 . read () ; return ch2 == EOF ; MST[rv.UOI2Mutator]MSP[] }
} public static void write ( final char [] data , final OutputStream output , final String encoding ) throws IOException { write ( data , output , Charsets . toCharset ( encoding ) ) ; MST[NonVoidMethodCallMutator]MSP[] }
if ( toSkip < 0 ) { throw new IllegalArgumentException ( lr_7 + toSkip ) ; } final long skipped = skip ( input , toSkip ) ; if ( skipped != toSkip ) { MST[rv.UOI3Mutator]MSP[] throw new EOFException ( lr_8 + toSkip + lr_4 + skipped ) ; } }
return reader instanceof BufferedReader ? ( BufferedReader ) reader : new BufferedReader ( reader , size ) ; MST[rv.ROR4Mutator]MSP[] } public static BufferedWriter buffer ( final Writer writer ) { return writer instanceof BufferedWriter ? ( BufferedWriter ) writer : new BufferedWriter ( writer ) ; }
return reader instanceof BufferedReader ? ( BufferedReader ) reader : new BufferedReader ( reader , size ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] } public static BufferedWriter buffer ( final Writer writer ) { return writer instanceof BufferedWriter ? ( BufferedWriter ) writer : new BufferedWriter ( writer ) ; }
while ( EOF != ch ) { final int ch2 = input2 . read () ; if ( ch != ch2 ) { return false ; } ch = input1 . read () ; } final int ch2 = input2 . read () ; return ch2 == EOF ; MST[BooleanTrueReturnValsMutator]MSP[] }
public static void skipFully ( final Reader input , final long toSkip ) throws IOException { final long skipped = skip ( input , toSkip ) ; if ( skipped != toSkip ) { throw new EOFException ( lr_9 + toSkip + lr_4 + skipped ) ; MST[experimental.NakedReceiverMutator]MSP[] } }
final CharArrayWriter sw = new CharArrayWriter () ; copy ( input , sw ) ; return sw . toCharArray () ; } @Deprecated public static InputStream toInputStream ( final CharSequence input ) { return toInputStream ( input , Charset . defaultCharset () ) ; MST[NullReturnValsMutator]MSP[] }
output . write ( buffer , 0 , read ) ; totalRead += read ; if ( length > 0 ) { bytesToRead = ( int ) Math . min ( length - totalRead , buffer . length ) ; } } return totalRead ; MST[rv.UOI3Mutator]MSP[] }
if ( toSkip < 0 ) { throw new IllegalArgumentException ( lr_7 + toSkip ) ; } final long skipped = skip ( input , toSkip ) ; if ( skipped != toSkip ) { throw new EOFException ( lr_8 + toSkip + lr_4 + skipped ) ; MST[NonVoidMethodCallMutator]MSP[] } }
final int actual = read ( input , buffer , offset , length ) ; if ( actual != length ) { throw new EOFException ( lr_3 + length + lr_4 + actual ) ; MST[NonVoidMethodCallMutator]MSP[] } } @Deprecated
} public static void write ( final byte [] data , final OutputStream output ) throws IOException { if ( data != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] output . write ( data ) ; } } @Deprecated
return length - remaining ; MST[PrimitiveReturnsMutator]MSP[] } public static int read ( final ReadableByteChannel input , final ByteBuffer buffer ) throws IOException { final int length = buffer . remaining () ; while ( buffer . remaining () > 0 ) {
if ( inputOffset > 0 ) { skipFully ( input , inputOffset ) ; } if ( length == 0 ) { return 0 ; } int bytesToRead = buffer . length ; if ( length > 0 && length < buffer . length ) { MST[NegateConditionalsMutator]MSP[]
public static int length ( final byte [] array ) { return array == null ? 0 : array . length ; } public static int length ( final char [] array ) { return array == null ? 0 : array . length ; MST[InlineConstantMutator]MSP[] }
final int ch2 = input2 . read () ; if ( ch != ch2 ) { return false ; MST[ReturnValsMutator]MSP[] } ch = input1 . read () ; } final int ch2 = input2 . read () ; return ch2 == EOF ; }
return output . toByteArray () ; } } public static byte [] toByteArray ( final InputStream input , final int size ) throws IOException { if ( size < 0 ) { throw new IllegalArgumentException ( lr_10 + size ) ; MST[rv.UOI1Mutator]MSP[] } if ( size == 0 ) {
final long skipped = skip ( input , toSkip ) ; if ( skipped != toSkip ) { MST[rv.UOI4Mutator]MSP[] throw new EOFException ( lr_8 + toSkip + lr_4 + skipped ) ; } } public static void skipFully ( final ReadableByteChannel input , final long toSkip ) throws IOException {
final long skipped = skip ( input , toSkip ) ; MST[rv.UOI2Mutator]MSP[] if ( skipped != toSkip ) { throw new EOFException ( lr_8 + toSkip + lr_4 + skipped ) ; } } public static void skipFully ( final ReadableByteChannel input , final long toSkip ) throws IOException {
final int chunk = Math . min ( bytes , DEFAULT_BUFFER_SIZE ) ; output . write ( data , offset , chunk ) ; bytes -= chunk ; offset += chunk ; MST[MathMutator]MSP[] } } } @Deprecated
skipByteBuffer . limit ( ( int ) Math . min ( remain , SKIP_BUFFER_SIZE ) ) ; final int n = input . read ( skipByteBuffer ) ; if ( n == EOF ) { break; } remain -= n ; } return toSkip - remain ; MST[rv.UOI4Mutator]MSP[] }
public static BufferedInputStream buffer ( final InputStream inputStream , final int size ) { if ( inputStream == null ) { throw new NullPointerException () ; } return inputStream instanceof BufferedInputStream ? MST[rv.UOI4Mutator]MSP[] ( BufferedInputStream ) inputStream : new BufferedInputStream ( inputStream , size ) ; }
final long n = input . read ( SKIP_BYTE_BUFFER , 0 , ( int ) Math . min ( remain , SKIP_BUFFER_SIZE ) ) ; MST[ArgumentPropagationMutator]MSP[] if ( n < 0 ) { break; } remain -= n ; } return toSkip - remain ; }
copy ( input , output , Charsets . toCharset ( outputEncoding ) ) ; } public static long copy ( final Reader input , final Appendable output ) throws IOException { return copy ( input , output , CharBuffer . allocate ( DEFAULT_BUFFER_SIZE ) ) ; MST[rv.CRCR3Mutator]MSP[] }
final ByteBuffer skipByteBuffer = ByteBuffer . allocate ( ( int ) Math . min ( toSkip , SKIP_BUFFER_SIZE ) ) ; long remain = toSkip ; while ( remain > 0 ) { MST[InlineConstantMutator]MSP[] skipByteBuffer . position ( 0 ) ;
final int chunk = Math . min ( bytes , DEFAULT_BUFFER_SIZE ) ; output . write ( data , offset , chunk ) ; bytes -= chunk ; offset += chunk ; MST[rv.UOI2Mutator]MSP[] } } } @Deprecated
skipByteBuffer . limit ( ( int ) Math . min ( remain , SKIP_BUFFER_SIZE ) ) ; final int n = input . read ( skipByteBuffer ) ; if ( n == EOF ) { break; } remain -= n ; } return toSkip - remain ; MST[ReturnValsMutator]MSP[] }
public static int copy ( final Reader input , final Writer output ) throws IOException { final long count = copyLarge ( input , output ) ; if ( count > Integer . MAX_VALUE ) { return - 1 ; MST[PrimitiveReturnsMutator]MSP[] } return ( int ) count ; }
String line1 = br1 . readLine () ; String line2 = br2 . readLine () ; while ( line1 != null && line2 != null && line1 . equals ( line2 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] line1 = br1 . readLine () ; line2 = br2 . readLine () ; }
return length - remaining ; MST[rv.UOI1Mutator]MSP[] } public static int read ( final ReadableByteChannel input , final ByteBuffer buffer ) throws IOException { final int length = buffer . remaining () ; while ( buffer . remaining () > 0 ) {
if ( length == 0 ) { return 0 ; } final int bufferLength = buffer . length ; int bytesToRead = bufferLength ; if ( length > 0 && length < bufferLength ) { MST[rv.ROR3Mutator]MSP[] bytesToRead = ( int ) length ; } int read ;
return toString ( uri . toURL () , Charsets . toCharset ( encoding ) ) ; MST[ArgumentPropagationMutator]MSP[] } public static String toString ( final URI uri , final String encoding ) throws IOException { return toString ( uri , Charsets . toCharset ( encoding ) ) ; } @Deprecated
throw new IllegalArgumentException ( lr_2 + length ) ; } int remaining = length ; while ( remaining > 0 ) { final int location = length - remaining ; final int count = input . read ( buffer , offset + location , remaining ) ; MST[rv.UOI1Mutator]MSP[]
long totalRead = 0 ; while ( bytesToRead > 0 && EOF != ( read = input . read ( buffer , 0 , bytesToRead ) ) ) { output . write ( buffer , 0 , read ) ; totalRead += read ; MST[rv.ABSMutator]MSP[]
public static boolean contentEquals ( Reader input1 , Reader input2 ) throws IOException { if ( input1 == input2 ) { return true ; } input1 = toBufferedReader ( input1 ) ; input2 = toBufferedReader ( input2 ) ; MST[NonVoidMethodCallMutator]MSP[] int ch = input1 . read () ;
write ( data . toString () , output , encoding ) ; MST[VoidMethodCallMutator]MSP[] } } public static void write ( final CharSequence data , final OutputStream output , final String encoding ) throws IOException { write ( data , output , Charsets . toCharset ( encoding ) ) ; }
if ( inputOffset > 0 ) { skipFully ( input , inputOffset ) ; } if ( length == 0 ) { return 0 ; } int bytesToRead = buffer . length ; if ( length > 0 && length < buffer . length ) { MST[rv.ROR1Mutator]MSP[]
long totalRead = 0 ; while ( bytesToRead > 0 && EOF != ( read = input . read ( buffer , 0 , bytesToRead ) ) ) { MST[rv.ROR4Mutator]MSP[] output . write ( buffer , 0 , read ) ; totalRead += read ;
copy ( input , output , Charsets . toCharset ( outputEncoding ) ) ; MST[VoidMethodCallMutator]MSP[] } public static long copy ( final Reader input , final Appendable output ) throws IOException { return copy ( input , output , CharBuffer . allocate ( DEFAULT_BUFFER_SIZE ) ) ; }
return read ( input , buffer , 0 , buffer . length ) ; } public static int read ( final Reader input , final char [] buffer , final int offset , final int length ) throws IOException { if ( length < 0 ) { MST[rv.ROR1Mutator]MSP[]
skipByteBuffer . limit ( ( int ) Math . min ( remain , SKIP_BUFFER_SIZE ) ) ; final int n = input . read ( skipByteBuffer ) ; if ( n == EOF ) { MST[rv.ROR4Mutator]MSP[] break; } remain -= n ; } return toSkip - remain ; }
long count = 0 ; int n ; while ( EOF != ( n = input . read ( buffer ) ) ) { buffer . flip () ; output . append ( buffer , 0 , n ) ; count += n ; } return count ; MST[rv.UOI1Mutator]MSP[] }
return line1 == null ? line2 == null ? true : false : line1 . equals ( line2 ) ; MST[NegateConditionalsMutator]MSP[] } public static int copy ( final InputStream input , final OutputStream output ) throws IOException { final long count = copyLarge ( input , output ) ;
if ( EOF == count ) { MST[rv.CRCR5Mutator]MSP[] break; } remaining -= count ; } return length - remaining ; } public static void readFully ( final InputStream input , final byte [] buffer ) throws IOException { readFully ( input , buffer , 0 , buffer . length ) ;
if ( inputOffset > 0 ) { skipFully ( input , inputOffset ) ; } if ( length == 0 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return 0 ; } int bytesToRead = buffer . length ; if ( length > 0 && length < buffer . length ) {
if ( length > 0 ) { bytesToRead = ( int ) Math . min ( length - totalRead , bufferLength ) ; MST[rv.UOI4Mutator]MSP[] } } return totalRead ; } public static long copy ( final Reader input , final Appendable output , final CharBuffer buffer ) throws IOException {
closeQuietly ( ( Closeable ) output ) ; } public static boolean contentEquals ( InputStream input1 , InputStream input2 ) throws IOException { if ( input1 == input2 ) { return true ; } if ( ! ( input1 instanceof BufferedInputStream ) ) { MST[rv.ROR4Mutator]MSP[]
skipByteBuffer . limit ( ( int ) Math . min ( remain , SKIP_BUFFER_SIZE ) ) ; final int n = input . read ( skipByteBuffer ) ; if ( n == EOF ) { break; } remain -= n ; MST[rv.UOI3Mutator]MSP[] } return toSkip - remain ; }
if ( length > 0 ) { bytesToRead = ( int ) Math . min ( length - totalRead , bufferLength ) ; MST[rv.UOI3Mutator]MSP[] } } return totalRead ; } public static long copy ( final Reader input , final Appendable output , final CharBuffer buffer ) throws IOException {
return line1 == null ? line2 == null ? true : false : line1 . equals ( line2 ) ; MST[rv.CRCR5Mutator]MSP[] } public static int copy ( final InputStream input , final OutputStream output ) throws IOException { final long count = copyLarge ( input , output ) ;
while ( EOF != ch ) { final int ch2 = input2 . read () ; if ( ch != ch2 ) { return false ; } ch = input1 . read () ; } final int ch2 = input2 . read () ; return ch2 == EOF ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] }
if ( SKIP_BYTE_BUFFER == null ) { SKIP_BYTE_BUFFER = new byte [ SKIP_BUFFER_SIZE ] ; MST[rv.CRCR2Mutator]MSP[] } long remain = toSkip ; while ( remain > 0 ) {
final ByteBuffer skipByteBuffer = ByteBuffer . allocate ( ( int ) Math . min ( toSkip , SKIP_BUFFER_SIZE ) ) ; long remain = toSkip ; while ( remain > 0 ) { MST[rv.ABSMutator]MSP[] skipByteBuffer . position ( 0 ) ;
while ( remaining > 0 ) { final int location = length - remaining ; final int count = input . read ( buffer , offset + location , remaining ) ; if ( EOF == count ) { MST[rv.CRCR6Mutator]MSP[] break; } remaining -= count ; }
final int count = input . read ( buffer ) ; if ( EOF == count ) { break; } } return length - buffer . remaining () ; MST[rv.ABSMutator]MSP[] } public static int read ( final Reader input , final char [] buffer ) throws IOException {
return copyLarge ( input , output , inputOffset , length , new char [ DEFAULT_BUFFER_SIZE ] ) ; MST[ArgumentPropagationMutator]MSP[] } public static long copyLarge ( final Reader input , final Writer output , final long inputOffset , final long length , final char [] buffer ) throws IOException {
final long skipped = skip ( input , toSkip ) ; if ( skipped != toSkip ) { throw new EOFException ( lr_8 + toSkip + lr_4 + skipped ) ; MST[experimental.NakedReceiverMutator]MSP[] } } public static void skipFully ( final ReadableByteChannel input , final long toSkip ) throws IOException {
final int actual = read ( input , buffer ) ; if ( actual != expected ) { throw new EOFException ( lr_3 + expected + lr_4 + actual ) ; MST[experimental.NakedReceiverMutator]MSP[] } } public static void readFully ( final Reader input , final char [] buffer ) throws IOException {
readFully ( input , buffer , 0 , buffer . length ) ; MST[rv.CRCR5Mutator]MSP[] } public static void readFully ( final Reader input , final char [] buffer , final int offset , final int length ) throws IOException {
while ( offset < size && ( read = input . read ( data , offset , size - offset ) ) != EOF ) { offset += read ; } if ( offset != size ) { MST[rv.ROR3Mutator]MSP[]
while ( offset < size && ( read = input . read ( data , offset , size - offset ) ) != EOF ) { offset += read ; MST[rv.ABSMutator]MSP[] } if ( offset != size ) {
public static long skip ( final ReadableByteChannel input , final long toSkip ) throws IOException { if ( toSkip < 0 ) { MST[InlineConstantMutator]MSP[] throw new IllegalArgumentException ( lr_6 + toSkip ) ; }
while ( EOF != ch ) { final int ch2 = input2 . read () ; if ( ch != ch2 ) { MST[rv.ABSMutator]MSP[] return false ; } ch = input1 . read () ; } final int ch2 = input2 . read () ; return ch2 == EOF ; }
final Charset cs = Charsets . toCharset ( encoding ) ; for ( final Object line : lines ) { if ( line != null ) { MST[rv.ROR5Mutator]MSP[] output . write ( line . toString () . getBytes ( cs ) ) ; }
final long skipped = skip ( input , toSkip ) ; if ( skipped != toSkip ) { MST[rv.UOI1Mutator]MSP[] throw new EOFException ( lr_8 + toSkip + lr_4 + skipped ) ; } } public static void skipFully ( final ReadableByteChannel input , final long toSkip ) throws IOException {
while ( offset < size && ( read = input . read ( data , offset , size - offset ) ) != EOF ) { MST[rv.UOI1Mutator]MSP[] offset += read ; } if ( offset != size ) {
long count = 0 ; int n ; while ( EOF != ( n = input . read ( buffer ) ) ) { buffer . flip () ; output . append ( buffer , 0 , n ) ; count += n ; MST[rv.AOD1Mutator]MSP[] } return count ; }
long count = 0 ; int n ; while ( EOF != ( n = input . read ( buffer ) ) ) { buffer . flip () ; output . append ( buffer , 0 , n ) ; MST[rv.UOI2Mutator]MSP[] count += n ; } return count ; }
public static BufferedReader toBufferedReader ( final Reader reader ) { return reader instanceof BufferedReader ? ( BufferedReader ) reader : new BufferedReader ( reader ) ; MST[NullReturnValsMutator]MSP[] } public static BufferedReader toBufferedReader ( final Reader reader , final int size ) {
while ( remaining > 0 ) { final int location = length - remaining ; final int count = input . read ( buffer , offset + location , remaining ) ; if ( EOF == count ) { break; } remaining -= count ; MST[rv.ABSMutator]MSP[] }
throw new IOException ( lr_5 + name ) ; MST[experimental.NakedReceiverMutator]MSP[] } return resource ; } public static long skip ( final InputStream input , final long toSkip ) throws IOException { if ( toSkip < 0 ) { throw new IllegalArgumentException ( lr_6 + toSkip ) ; }
if ( toSkip < 0 ) { throw new IllegalArgumentException ( lr_7 + toSkip ) ; } final long skipped = skip ( input , toSkip ) ; if ( skipped != toSkip ) { throw new EOFException ( lr_8 + toSkip + lr_4 + skipped ) ; MST[rv.UOI4Mutator]MSP[] } }
if ( data != null ) { output . write ( data . toString () . getBytes ( Charsets . toCharset ( encoding ) ) ) ; MST[NonVoidMethodCallMutator]MSP[] } } @Deprecated public static void write ( final StringBuffer data , final Writer output ) throws IOException {
output . write ( buffer , 0 , read ) ; totalRead += read ; if ( length > 0 ) { MST[rv.ROR1Mutator]MSP[] bytesToRead = ( int ) Math . min ( length - totalRead , buffer . length ) ; } } return totalRead ; }
public static URL resourceToURL ( final String name , final ClassLoader classLoader ) throws IOException { final URL resource = classLoader == null ? IOUtils . class . getResource ( name ) : classLoader . getResource ( name ) ; MST[NonVoidMethodCallMutator]MSP[] if ( resource == null ) {
public static void write ( final char [] data , final OutputStream output , final Charset encoding ) throws IOException { if ( data != null ) { MST[rv.ROR5Mutator]MSP[] output . write ( new String ( data ) . getBytes ( Charsets . toCharset ( encoding ) ) ) ; }
bytesToRead = ( int ) length ; } int read ; long totalRead = 0 ; while ( bytesToRead > 0 && EOF != ( read = input . read ( buffer , 0 , bytesToRead ) ) ) { MST[rv.CRCR1Mutator]MSP[]
public static long copyLarge ( final InputStream input , final OutputStream output , final long inputOffset , final long length ) throws IOException { return copyLarge ( input , output , inputOffset , length , new byte [ DEFAULT_BUFFER_SIZE ] ) ; MST[ArgumentPropagationMutator]MSP[] }
if ( inputOffset > 0 ) { skipFully ( input , inputOffset ) ; } if ( length == 0 ) { return 0 ; } int bytesToRead = buffer . length ; if ( length > 0 && length < buffer . length ) { MST[rv.ROR3Mutator]MSP[]
skipByteBuffer . limit ( ( int ) Math . min ( remain , SKIP_BUFFER_SIZE ) ) ; MST[rv.CRCR3Mutator]MSP[] final int n = input . read ( skipByteBuffer ) ; if ( n == EOF ) { break; } remain -= n ; } return toSkip - remain ; }
while ( offset < size && ( read = input . read ( data , offset , size - offset ) ) != EOF ) { MST[rv.ABSMutator]MSP[] offset += read ; } if ( offset != size ) {
return toInputStream ( input , Charsets . toCharset ( encoding ) ) ; } @Deprecated public static InputStream toInputStream ( final String input ) { return toInputStream ( input , Charset . defaultCharset () ) ; MST[ReturnValsMutator]MSP[] }
} public static void readFully ( final InputStream input , final byte [] buffer , final int offset , final int length ) throws IOException { final int actual = read ( input , buffer , offset , length ) ; MST[rv.UOI1Mutator]MSP[] if ( actual != length ) {
output . write ( buffer , 0 , read ) ; totalRead += read ; MST[rv.AOR2Mutator]MSP[] if ( length > 0 ) { bytesToRead = ( int ) Math . min ( length - totalRead , buffer . length ) ; } } return totalRead ; }
} public static void readFully ( final InputStream input , final byte [] buffer , final int offset , final int length ) throws IOException { final int actual = read ( input , buffer , offset , length ) ; if ( actual != length ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
while ( remaining > 0 ) { final int location = length - remaining ; final int count = input . read ( buffer , offset + location , remaining ) ; if ( EOF == count ) { break; } remaining -= count ; MST[rv.UOI3Mutator]MSP[] }
if ( length == 0 ) { return 0 ; } final int bufferLength = buffer . length ; int bytesToRead = bufferLength ; if ( length > 0 && length < bufferLength ) { MST[NegateConditionalsMutator]MSP[] bytesToRead = ( int ) length ; } int read ;
long totalRead = 0 ; while ( bytesToRead > 0 && EOF != ( read = input . read ( buffer , 0 , bytesToRead ) ) ) { MST[rv.UOI3Mutator]MSP[] output . write ( buffer , 0 , read ) ; totalRead += read ;
public static long copyLarge ( final InputStream input , final OutputStream output , final long inputOffset , final long length , final byte [] buffer ) throws IOException { if ( inputOffset > 0 ) { skipFully ( input , inputOffset ) ; MST[rv.ABSMutator]MSP[] }
public static void skipFully ( final Reader input , final long toSkip ) throws IOException { final long skipped = skip ( input , toSkip ) ; if ( skipped != toSkip ) { MST[rv.ABSMutator]MSP[] throw new EOFException ( lr_9 + toSkip + lr_4 + skipped ) ; } }
public static BufferedInputStream buffer ( final InputStream inputStream , final int size ) { if ( inputStream == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] throw new NullPointerException () ; } return inputStream instanceof BufferedInputStream ? ( BufferedInputStream ) inputStream : new BufferedInputStream ( inputStream , size ) ; }
if ( EOF == count ) { break; } remaining -= count ; MST[rv.UOI1Mutator]MSP[] } return length - remaining ; } public static void readFully ( final InputStream input , final byte [] buffer ) throws IOException { readFully ( input , buffer , 0 , buffer . length ) ;
public static void closeQuietly ( final Reader input ) { closeQuietly ( ( Closeable ) input ) ; } @Deprecated public static void closeQuietly ( final Selector selector ) { if ( selector != null ) { MST[NegateConditionalsMutator]MSP[] try { selector . close () ;
while ( EOF != ch ) { final int ch2 = input2 . read () ; if ( ch != ch2 ) { return false ; MST[ReturnValsMutator]MSP[] } ch = input1 . read () ; } final int ch2 = input2 . read () ; return ch2 == EOF ; }
public static LineIterator lineIterator ( final InputStream input , final String encoding ) throws IOException { return lineIterator ( input , Charsets . toCharset ( encoding ) ) ; MST[NonVoidMethodCallMutator]MSP[] } public static LineIterator lineIterator ( final Reader reader ) { return new LineIterator ( reader ) ; }
while ( remaining > 0 ) { final int location = length - remaining ; final int count = input . read ( buffer , offset + location , remaining ) ; MST[rv.UOI3Mutator]MSP[] if ( EOF == count ) { break; } remaining -= count ; }
public static long skip ( final Reader input , final long toSkip ) throws IOException { if ( toSkip < 0 ) { throw new IllegalArgumentException ( lr_6 + toSkip ) ; } if ( SKIP_CHAR_BUFFER == null ) { SKIP_CHAR_BUFFER = new char [ SKIP_BUFFER_SIZE ] ; MST[rv.CRCR1Mutator]MSP[] }
while ( remaining > 0 ) { final int location = length - remaining ; final int count = input . read ( buffer , offset + location , remaining ) ; MST[rv.UOI4Mutator]MSP[] if ( EOF == count ) { break; } remaining -= count ; }
public static void skipFully ( final Reader input , final long toSkip ) throws IOException { final long skipped = skip ( input , toSkip ) ; if ( skipped != toSkip ) { throw new EOFException ( lr_9 + toSkip + lr_4 + skipped ) ; MST[NonVoidMethodCallMutator]MSP[] } }
long remain = toSkip ; while ( remain > 0 ) { MST[rv.CRCR5Mutator]MSP[] final long n = input . read ( SKIP_CHAR_BUFFER , 0 , ( int ) Math . min ( remain , SKIP_BUFFER_SIZE ) ) ; if ( n < 0 ) { break; } remain -= n ;
if ( count > Integer . MAX_VALUE ) { return - 1 ; MST[ReturnValsMutator]MSP[] } return ( int ) count ; } public static long copy ( final InputStream input , final OutputStream output , final int bufferSize ) throws IOException {
throw new EOFException ( lr_3 + length + lr_4 + actual ) ; MST[ConstructorCallMutator]MSP[] } } public static byte [] readFully ( final InputStream input , final int length ) throws IOException { final byte [] buffer = new byte [ length ] ;
throw new IllegalArgumentException ( lr_13 + size ) ; MST[rv.UOI1Mutator]MSP[] } return toByteArray ( input , ( int ) size ) ; } @Deprecated public static byte [] toByteArray ( final Reader input ) throws IOException { return toByteArray ( input , Charset . defaultCharset () ) ; }
closeQuietly ( ( Closeable ) output ) ; } public static boolean contentEquals ( InputStream input1 , InputStream input2 ) throws IOException { if ( input1 == input2 ) { return true ; } if ( ! ( input1 instanceof BufferedInputStream ) ) { MST[rv.ROR1Mutator]MSP[]
throw new IllegalArgumentException ( lr_13 + size ) ; } return toByteArray ( input , ( int ) size ) ; } @Deprecated public static byte [] toByteArray ( final Reader input ) throws IOException { return toByteArray ( input , Charset . defaultCharset () ) ; MST[NonVoidMethodCallMutator]MSP[] }
if ( inputOffset > 0 ) { skipFully ( input , inputOffset ) ; } if ( length == 0 ) { MST[rv.ROR2Mutator]MSP[] return 0 ; } int bytesToRead = buffer . length ; if ( length > 0 && length < buffer . length ) {
public static int read ( final InputStream input , final byte [] buffer , final int offset , final int length ) throws IOException { if ( length < 0 ) { throw new IllegalArgumentException ( lr_2 + length ) ; MST[rv.UOI3Mutator]MSP[] } int remaining = length ;
throw new IllegalArgumentException ( lr_2 + length ) ; } int remaining = length ; while ( remaining > 0 ) { final int location = length - remaining ; final int count = input . read ( buffer , offset + location , remaining ) ; MST[rv.UOI4Mutator]MSP[]
return read ( input , buffer , 0 , buffer . length ) ; } public static int read ( final Reader input , final char [] buffer , final int offset , final int length ) throws IOException { if ( length < 0 ) { MST[rv.UOI3Mutator]MSP[]
while ( EOF != ch ) { MST[rv.UOI2Mutator]MSP[] final int ch2 = input2 . read () ; if ( ch != ch2 ) { return false ; } ch = input1 . read () ; } final int ch2 = input2 . read () ; return ch2 == EOF ; }
final InputStreamReader reader = new InputStreamReader ( input , Charsets . toCharset ( encoding ) ) ; MST[ArgumentPropagationMutator]MSP[] return readLines ( reader ) ; } public static List < String > readLines ( final InputStream input , final String encoding ) throws IOException {
