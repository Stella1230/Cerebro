encoding = m . group ( 1 ) . toUpperCase ( Locale . ROOT ) ; encoding = encoding . substring ( 1 , encoding . length () - 1 ) ; } else { encoding = defaultEncoding ; MST[experimental.MemberVariableMutator]MSP[] } } else {
private void detectEncoding ( final char [] cbuf , final int off , final int len ) throws IOException { int size = len ; final StringBuffer xmlProlog = xmlPrologWriter . getBuffer () ; if ( xmlProlog . length () + len > BUFFER_SIZE ) { MST[rv.CRCR4Mutator]MSP[]
final int xmlPrologEnd = xmlProlog . indexOf ( lr_2 ) ; if ( xmlPrologEnd > 0 ) { MST[rv.UOI1Mutator]MSP[] final Matcher m = ENCODING_PATTERN . matcher ( xmlProlog . substring ( 0 , xmlPrologEnd ) ) ; if ( m . find () ) {
final int xmlPrologEnd = xmlProlog . indexOf ( lr_2 ) ; if ( xmlPrologEnd > 0 ) { MST[rv.UOI3Mutator]MSP[] final Matcher m = ENCODING_PATTERN . matcher ( xmlProlog . substring ( 0 , xmlPrologEnd ) ) ; if ( m . find () ) {
private void detectEncoding ( final char [] cbuf , final int off , final int len ) throws IOException { int size = len ; final StringBuffer xmlProlog = xmlPrologWriter . getBuffer () ; if ( xmlProlog . length () + len > BUFFER_SIZE ) { MST[rv.AOR2Mutator]MSP[]
size = BUFFER_SIZE - xmlProlog . length () ; } xmlPrologWriter . write ( cbuf , off , size ) ; if ( xmlProlog . length () >= 5 ) { if ( xmlProlog . substring ( 0 , 5 ) . equals ( lr_1 ) ) { MST[rv.CRCR6Mutator]MSP[]
final int xmlPrologEnd = xmlProlog . indexOf ( lr_2 ) ; if ( xmlPrologEnd > 0 ) { final Matcher m = ENCODING_PATTERN . matcher ( xmlProlog . substring ( 0 , xmlPrologEnd ) ) ; if ( m . find () ) { MST[NonVoidMethodCallMutator]MSP[]
size = BUFFER_SIZE - xmlProlog . length () ; } xmlPrologWriter . write ( cbuf , off , size ) ; if ( xmlProlog . length () >= 5 ) { if ( xmlProlog . substring ( 0 , 5 ) . equals ( lr_1 ) ) { MST[InlineConstantMutator]MSP[]
if ( xmlProlog . length () >= BUFFER_SIZE ) { MST[rv.CRCR4Mutator]MSP[] encoding = defaultEncoding ; } } } else { encoding = defaultEncoding ; } if ( encoding != null ) { xmlPrologWriter = null ; writer = new OutputStreamWriter ( out , encoding ) ;
public void write ( final char [] cbuf , final int off , final int len ) throws IOException { if ( xmlPrologWriter != null ) { MST[NegateConditionalsMutator]MSP[] detectEncoding ( cbuf , off , len ) ; } else { writer . write ( cbuf , off , len ) ;
public void write ( final char [] cbuf , final int off , final int len ) throws IOException { if ( xmlPrologWriter != null ) { detectEncoding ( cbuf , off , len ) ; MST[rv.UOI3Mutator]MSP[] } else { writer . write ( cbuf , off , len ) ;
public String getEncoding () { return encoding ; MST[EmptyObjectReturnValsMutator]MSP[] } public String getDefaultEncoding () { return defaultEncoding ; } @Override public void close () throws IOException { if ( writer == null ) { encoding = defaultEncoding ; writer = new OutputStreamWriter ( out , encoding ) ;
size = BUFFER_SIZE - xmlProlog . length () ; } xmlPrologWriter . write ( cbuf , off , size ) ; if ( xmlProlog . length () >= 5 ) { if ( xmlProlog . substring ( 0 , 5 ) . equals ( lr_1 ) ) { MST[rv.CRCR3Mutator]MSP[]
encoding = m . group ( 1 ) . toUpperCase ( Locale . ROOT ) ; MST[experimental.NakedReceiverMutator]MSP[] encoding = encoding . substring ( 1 , encoding . length () - 1 ) ; } else { encoding = defaultEncoding ; } } else {
if ( xmlProlog . length () >= BUFFER_SIZE ) { MST[NonVoidMethodCallMutator]MSP[] encoding = defaultEncoding ; } } } else { encoding = defaultEncoding ; } if ( encoding != null ) { xmlPrologWriter = null ; writer = new OutputStreamWriter ( out , encoding ) ;
writer . write ( xmlProlog . toString () ) ; if ( len > size ) { MST[rv.UOI3Mutator]MSP[] writer . write ( cbuf , off + size , len - size ) ; } } } } @Override
public String getEncoding () { return encoding ; } public String getDefaultEncoding () { return defaultEncoding ; } @Override public void close () throws IOException { if ( writer == null ) { MST[NegateConditionalsMutator]MSP[] encoding = defaultEncoding ; writer = new OutputStreamWriter ( out , encoding ) ;
size = BUFFER_SIZE - xmlProlog . length () ; } xmlPrologWriter . write ( cbuf , off , size ) ; MST[rv.UOI3Mutator]MSP[] if ( xmlProlog . length () >= 5 ) { if ( xmlProlog . substring ( 0 , 5 ) . equals ( lr_1 ) ) {
final int xmlPrologEnd = xmlProlog . indexOf ( lr_2 ) ; if ( xmlPrologEnd > 0 ) { final Matcher m = ENCODING_PATTERN . matcher ( xmlProlog . substring ( 0 , xmlPrologEnd ) ) ; if ( m . find () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
size = BUFFER_SIZE - xmlProlog . length () ; } xmlPrologWriter . write ( cbuf , off , size ) ; if ( xmlProlog . length () >= 5 ) { MST[rv.ROR2Mutator]MSP[] if ( xmlProlog . substring ( 0 , 5 ) . equals ( lr_1 ) ) {
writer . write ( xmlPrologWriter . toString () ) ; } writer . close () ; } @Override public void flush () throws IOException { if ( writer != null ) { MST[rv.ROR5Mutator]MSP[] writer . flush () ; } }
size = BUFFER_SIZE - xmlProlog . length () ; } xmlPrologWriter . write ( cbuf , off , size ) ; if ( xmlProlog . length () >= 5 ) { MST[rv.ROR5Mutator]MSP[] if ( xmlProlog . substring ( 0 , 5 ) . equals ( lr_1 ) ) {
encoding = m . group ( 1 ) . toUpperCase ( Locale . ROOT ) ; encoding = encoding . substring ( 1 , encoding . length () - 1 ) ; MST[rv.CRCR5Mutator]MSP[] } else { encoding = defaultEncoding ; } } else {
private void detectEncoding ( final char [] cbuf , final int off , final int len ) throws IOException { int size = len ; final StringBuffer xmlProlog = xmlPrologWriter . getBuffer () ; if ( xmlProlog . length () + len > BUFFER_SIZE ) { MST[rv.AOD2Mutator]MSP[]
if ( xmlProlog . length () >= BUFFER_SIZE ) { MST[ConditionalsBoundaryMutator]MSP[] encoding = defaultEncoding ; } } } else { encoding = defaultEncoding ; } if ( encoding != null ) { xmlPrologWriter = null ; writer = new OutputStreamWriter ( out , encoding ) ;
writer . write ( xmlProlog . toString () ) ; if ( len > size ) { MST[rv.ABSMutator]MSP[] writer . write ( cbuf , off + size , len - size ) ; } } } } @Override
if ( xmlProlog . length () >= BUFFER_SIZE ) { MST[rv.ROR5Mutator]MSP[] encoding = defaultEncoding ; } } } else { encoding = defaultEncoding ; } if ( encoding != null ) { xmlPrologWriter = null ; writer = new OutputStreamWriter ( out , encoding ) ;
encoding = m . group ( 1 ) . toUpperCase ( Locale . ROOT ) ; MST[rv.CRCR3Mutator]MSP[] encoding = encoding . substring ( 1 , encoding . length () - 1 ) ; } else { encoding = defaultEncoding ; } } else {
public String getEncoding () { return encoding ; } public String getDefaultEncoding () { return defaultEncoding ; } @Override public void close () throws IOException { if ( writer == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] encoding = defaultEncoding ; writer = new OutputStreamWriter ( out , encoding ) ;
encoding = m . group ( 1 ) . toUpperCase ( Locale . ROOT ) ; MST[NonVoidMethodCallMutator]MSP[] encoding = encoding . substring ( 1 , encoding . length () - 1 ) ; } else { encoding = defaultEncoding ; } } else {
public void write ( final char [] cbuf , final int off , final int len ) throws IOException { if ( xmlPrologWriter != null ) { detectEncoding ( cbuf , off , len ) ; MST[rv.ABSMutator]MSP[] } else { writer . write ( cbuf , off , len ) ;
private void detectEncoding ( final char [] cbuf , final int off , final int len ) throws IOException { int size = len ; MST[rv.UOI4Mutator]MSP[] final StringBuffer xmlProlog = xmlPrologWriter . getBuffer () ; if ( xmlProlog . length () + len > BUFFER_SIZE ) {
private void detectEncoding ( final char [] cbuf , final int off , final int len ) throws IOException { int size = len ; final StringBuffer xmlProlog = xmlPrologWriter . getBuffer () ; if ( xmlProlog . length () + len > BUFFER_SIZE ) { MST[NonVoidMethodCallMutator]MSP[]
private void detectEncoding ( final char [] cbuf , final int off , final int len ) throws IOException { int size = len ; final StringBuffer xmlProlog = xmlPrologWriter . getBuffer () ; if ( xmlProlog . length () + len > BUFFER_SIZE ) { MST[rv.ROR3Mutator]MSP[]
final int xmlPrologEnd = xmlProlog . indexOf ( lr_2 ) ; if ( xmlPrologEnd > 0 ) { final Matcher m = ENCODING_PATTERN . matcher ( xmlProlog . substring ( 0 , MST[rv.UOI3Mutator]MSP[] xmlPrologEnd ) ) ; if ( m . find () ) {
size = BUFFER_SIZE - xmlProlog . length () ; } xmlPrologWriter . write ( cbuf , off , size ) ; if ( xmlProlog . length () >= 5 ) { MST[rv.CRCR1Mutator]MSP[] if ( xmlProlog . substring ( 0 , 5 ) . equals ( lr_1 ) ) {
size = BUFFER_SIZE - xmlProlog . length () ; } xmlPrologWriter . write ( cbuf , off , size ) ; if ( xmlProlog . length () >= 5 ) { if ( xmlProlog . substring ( 0 , 5 ) . equals ( lr_1 ) ) { MST[InlineConstantMutator]MSP[]
public String getEncoding () { return encoding ; } public String getDefaultEncoding () { return defaultEncoding ; MST[EmptyObjectReturnValsMutator]MSP[] } @Override public void close () throws IOException { if ( writer == null ) { encoding = defaultEncoding ; writer = new OutputStreamWriter ( out , encoding ) ;
if ( xmlProlog . length () >= BUFFER_SIZE ) { MST[rv.ROR3Mutator]MSP[] encoding = defaultEncoding ; } } } else { encoding = defaultEncoding ; } if ( encoding != null ) { xmlPrologWriter = null ; writer = new OutputStreamWriter ( out , encoding ) ;
if ( xmlProlog . length () >= BUFFER_SIZE ) { MST[rv.CRCR1Mutator]MSP[] encoding = defaultEncoding ; } } } else { encoding = defaultEncoding ; } if ( encoding != null ) { xmlPrologWriter = null ; writer = new OutputStreamWriter ( out , encoding ) ;
private void detectEncoding ( final char [] cbuf , final int off , final int len ) throws IOException { int size = len ; MST[rv.ABSMutator]MSP[] final StringBuffer xmlProlog = xmlPrologWriter . getBuffer () ; if ( xmlProlog . length () + len > BUFFER_SIZE ) {
writer . write ( xmlPrologWriter . toString () ) ; } writer . close () ; } @Override public void flush () throws IOException { if ( writer != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] writer . flush () ; } }
encoding = m . group ( 1 ) . toUpperCase ( Locale . ROOT ) ; MST[InlineConstantMutator]MSP[] encoding = encoding . substring ( 1 , encoding . length () - 1 ) ; } else { encoding = defaultEncoding ; } } else {
encoding = m . group ( 1 ) . toUpperCase ( Locale . ROOT ) ; encoding = encoding . substring ( 1 , encoding . length () - 1 ) ; MST[experimental.NakedReceiverMutator]MSP[] } else { encoding = defaultEncoding ; } } else {
public void write ( final char [] cbuf , final int off , final int len ) throws IOException { if ( xmlPrologWriter != null ) { detectEncoding ( cbuf , off , len ) ; MST[rv.UOI3Mutator]MSP[] } else { writer . write ( cbuf , off , len ) ;
if ( xmlProlog . length () >= BUFFER_SIZE ) { MST[rv.CRCR5Mutator]MSP[] encoding = defaultEncoding ; } } } else { encoding = defaultEncoding ; } if ( encoding != null ) { xmlPrologWriter = null ; writer = new OutputStreamWriter ( out , encoding ) ;
final int xmlPrologEnd = xmlProlog . indexOf ( lr_2 ) ; MST[NonVoidMethodCallMutator]MSP[] if ( xmlPrologEnd > 0 ) { final Matcher m = ENCODING_PATTERN . matcher ( xmlProlog . substring ( 0 , xmlPrologEnd ) ) ; if ( m . find () ) {
public void write ( final char [] cbuf , final int off , final int len ) throws IOException { if ( xmlPrologWriter != null ) { detectEncoding ( cbuf , off , len ) ; MST[rv.UOI1Mutator]MSP[] } else { writer . write ( cbuf , off , len ) ;
size = BUFFER_SIZE - xmlProlog . length () ; } xmlPrologWriter . write ( cbuf , off , size ) ; MST[rv.UOI2Mutator]MSP[] if ( xmlProlog . length () >= 5 ) { if ( xmlProlog . substring ( 0 , 5 ) . equals ( lr_1 ) ) {
if ( xmlProlog . length () >= BUFFER_SIZE ) { MST[rv.CRCR3Mutator]MSP[] encoding = defaultEncoding ; } } } else { encoding = defaultEncoding ; } if ( encoding != null ) { xmlPrologWriter = null ; writer = new OutputStreamWriter ( out , encoding ) ;
size = BUFFER_SIZE - xmlProlog . length () ; } xmlPrologWriter . write ( cbuf , off , size ) ; MST[rv.UOI3Mutator]MSP[] if ( xmlProlog . length () >= 5 ) { if ( xmlProlog . substring ( 0 , 5 ) . equals ( lr_1 ) ) {
final int xmlPrologEnd = xmlProlog . indexOf ( lr_2 ) ; if ( xmlPrologEnd > 0 ) { final Matcher m = ENCODING_PATTERN . matcher ( xmlProlog . substring ( 0 , MST[rv.CRCR1Mutator]MSP[] xmlPrologEnd ) ) ; if ( m . find () ) {
writer . write ( xmlPrologWriter . toString () ) ; } writer . close () ; } @Override public void flush () throws IOException { if ( writer != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] writer . flush () ; } }
size = BUFFER_SIZE - xmlProlog . length () ; } xmlPrologWriter . write ( cbuf , off , size ) ; if ( xmlProlog . length () >= 5 ) { if ( xmlProlog . substring ( 0 , 5 ) . equals ( lr_1 ) ) { MST[NonVoidMethodCallMutator]MSP[]
if ( xmlProlog . length () >= BUFFER_SIZE ) { MST[rv.ROR2Mutator]MSP[] encoding = defaultEncoding ; } } } else { encoding = defaultEncoding ; } if ( encoding != null ) { xmlPrologWriter = null ; writer = new OutputStreamWriter ( out , encoding ) ;
size = BUFFER_SIZE - xmlProlog . length () ; } xmlPrologWriter . write ( cbuf , off , size ) ; MST[rv.UOI1Mutator]MSP[] if ( xmlProlog . length () >= 5 ) { if ( xmlProlog . substring ( 0 , 5 ) . equals ( lr_1 ) ) {
if ( xmlProlog . length () >= BUFFER_SIZE ) { MST[rv.ROR4Mutator]MSP[] encoding = defaultEncoding ; } } } else { encoding = defaultEncoding ; } if ( encoding != null ) { xmlPrologWriter = null ; writer = new OutputStreamWriter ( out , encoding ) ;
writer . write ( xmlProlog . toString () ) ; if ( len > size ) { MST[NegateConditionalsMutator]MSP[] writer . write ( cbuf , off + size , len - size ) ; } } } } @Override
size = BUFFER_SIZE - xmlProlog . length () ; } xmlPrologWriter . write ( cbuf , off , size ) ; if ( xmlProlog . length () >= 5 ) { if ( xmlProlog . substring ( 0 , 5 ) . equals ( lr_1 ) ) { MST[rv.ROR2Mutator]MSP[]
size = BUFFER_SIZE - xmlProlog . length () ; } xmlPrologWriter . write ( cbuf , off , size ) ; MST[rv.UOI4Mutator]MSP[] if ( xmlProlog . length () >= 5 ) { if ( xmlProlog . substring ( 0 , 5 ) . equals ( lr_1 ) ) {
size = BUFFER_SIZE - xmlProlog . length () ; } xmlPrologWriter . write ( cbuf , off , size ) ; if ( xmlProlog . length () >= 5 ) { if ( xmlProlog . substring ( 0 , 5 ) . equals ( lr_1 ) ) { MST[rv.ROR4Mutator]MSP[]
size = BUFFER_SIZE - xmlProlog . length () ; } xmlPrologWriter . write ( cbuf , off , size ) ; if ( xmlProlog . length () >= 5 ) { MST[NonVoidMethodCallMutator]MSP[] if ( xmlProlog . substring ( 0 , 5 ) . equals ( lr_1 ) ) {
final int xmlPrologEnd = xmlProlog . indexOf ( lr_2 ) ; if ( xmlPrologEnd > 0 ) { final Matcher m = ENCODING_PATTERN . matcher ( xmlProlog . substring ( 0 , MST[rv.CRCR5Mutator]MSP[] xmlPrologEnd ) ) ; if ( m . find () ) {
final int xmlPrologEnd = xmlProlog . indexOf ( lr_2 ) ; if ( xmlPrologEnd > 0 ) { final Matcher m = ENCODING_PATTERN . matcher ( xmlProlog . substring ( 0 , MST[rv.CRCR3Mutator]MSP[] xmlPrologEnd ) ) ; if ( m . find () ) {
encoding = m . group ( 1 ) . toUpperCase ( Locale . ROOT ) ; encoding = encoding . substring ( 1 , encoding . length () - 1 ) ; MST[NonVoidMethodCallMutator]MSP[] } else { encoding = defaultEncoding ; } } else {
encoding = m . group ( 1 ) . toUpperCase ( Locale . ROOT ) ; encoding = encoding . substring ( 1 , encoding . length () - 1 ) ; MST[rv.CRCR6Mutator]MSP[] } else { encoding = defaultEncoding ; } } else {
size = BUFFER_SIZE - xmlProlog . length () ; } xmlPrologWriter . write ( cbuf , off , size ) ; if ( xmlProlog . length () >= 5 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] if ( xmlProlog . substring ( 0 , 5 ) . equals ( lr_1 ) ) {
encoding = m . group ( 1 ) . toUpperCase ( Locale . ROOT ) ; encoding = encoding . substring ( 1 , encoding . length () - 1 ) ; MST[rv.CRCR4Mutator]MSP[] } else { encoding = defaultEncoding ; } } else {
size = BUFFER_SIZE - xmlProlog . length () ; } xmlPrologWriter . write ( cbuf , off , size ) ; if ( xmlProlog . length () >= 5 ) { MST[ConditionalsBoundaryMutator]MSP[] if ( xmlProlog . substring ( 0 , 5 ) . equals ( lr_1 ) ) {
encoding = m . group ( 1 ) . toUpperCase ( Locale . ROOT ) ; encoding = encoding . substring ( 1 , encoding . length () - 1 ) ; MST[rv.AOD1Mutator]MSP[] } else { encoding = defaultEncoding ; } } else {
size = BUFFER_SIZE - xmlProlog . length () ; } xmlPrologWriter . write ( cbuf , off , size ) ; if ( xmlProlog . length () >= 5 ) { if ( xmlProlog . substring ( 0 , 5 ) . equals ( lr_1 ) ) { MST[rv.ROR1Mutator]MSP[]
encoding = m . group ( 1 ) . toUpperCase ( Locale . ROOT ) ; encoding = encoding . substring ( 1 , encoding . length () - 1 ) ; MST[rv.CRCR2Mutator]MSP[] } else { encoding = defaultEncoding ; } } else {
writer . write ( xmlPrologWriter . toString () ) ; } writer . close () ; } @Override public void flush () throws IOException { if ( writer != null ) { MST[NegateConditionalsMutator]MSP[] writer . flush () ; } }
final int xmlPrologEnd = xmlProlog . indexOf ( lr_2 ) ; if ( xmlPrologEnd > 0 ) { final Matcher m = ENCODING_PATTERN . matcher ( xmlProlog . substring ( 0 , xmlPrologEnd ) ) ; if ( m . find () ) { MST[rv.ROR2Mutator]MSP[]
final int xmlPrologEnd = xmlProlog . indexOf ( lr_2 ) ; if ( xmlPrologEnd > 0 ) { final Matcher m = ENCODING_PATTERN . matcher ( xmlProlog . substring ( 0 , xmlPrologEnd ) ) ; if ( m . find () ) { MST[rv.ROR4Mutator]MSP[]
private void detectEncoding ( final char [] cbuf , final int off , final int len ) throws IOException { int size = len ; final StringBuffer xmlProlog = xmlPrologWriter . getBuffer () ; if ( xmlProlog . length () + len > BUFFER_SIZE ) { MST[rv.UOI3Mutator]MSP[]
size = BUFFER_SIZE - xmlProlog . length () ; } xmlPrologWriter . write ( cbuf , off , size ) ; if ( xmlProlog . length () >= 5 ) { if ( xmlProlog . substring ( 0 , 5 ) . equals ( lr_1 ) ) { MST[rv.CRCR2Mutator]MSP[]
public void write ( final char [] cbuf , final int off , final int len ) throws IOException { if ( xmlPrologWriter != null ) { detectEncoding ( cbuf , off , len ) ; MST[rv.UOI1Mutator]MSP[] } else { writer . write ( cbuf , off , len ) ;
size = BUFFER_SIZE - xmlProlog . length () ; } xmlPrologWriter . write ( cbuf , off , size ) ; if ( xmlProlog . length () >= 5 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[] if ( xmlProlog . substring ( 0 , 5 ) . equals ( lr_1 ) ) {
final int xmlPrologEnd = xmlProlog . indexOf ( lr_2 ) ; if ( xmlPrologEnd > 0 ) { MST[NegateConditionalsMutator]MSP[] final Matcher m = ENCODING_PATTERN . matcher ( xmlProlog . substring ( 0 , xmlPrologEnd ) ) ; if ( m . find () ) {
size = BUFFER_SIZE - xmlProlog . length () ; } xmlPrologWriter . write ( cbuf , off , size ) ; MST[rv.UOI1Mutator]MSP[] if ( xmlProlog . length () >= 5 ) { if ( xmlProlog . substring ( 0 , 5 ) . equals ( lr_1 ) ) {
if ( xmlProlog . length () >= BUFFER_SIZE ) { MST[rv.ROR1Mutator]MSP[] encoding = defaultEncoding ; } } } else { encoding = defaultEncoding ; } if ( encoding != null ) { xmlPrologWriter = null ; writer = new OutputStreamWriter ( out , encoding ) ;
if ( xmlProlog . length () >= BUFFER_SIZE ) { encoding = defaultEncoding ; } } } else { encoding = defaultEncoding ; } if ( encoding != null ) { xmlPrologWriter = null ; MST[experimental.MemberVariableMutator]MSP[] writer = new OutputStreamWriter ( out , encoding ) ;
writer . write ( xmlProlog . toString () ) ; if ( len > size ) { MST[rv.UOI1Mutator]MSP[] writer . write ( cbuf , off + size , len - size ) ; } } } } @Override
writer . write ( xmlProlog . toString () ) ; if ( len > size ) { MST[rv.ROR5Mutator]MSP[] writer . write ( cbuf , off + size , len - size ) ; } } } } @Override
public String getEncoding () { return encoding ; MST[ReturnValsMutator]MSP[] } public String getDefaultEncoding () { return defaultEncoding ; } @Override public void close () throws IOException { if ( writer == null ) { encoding = defaultEncoding ; writer = new OutputStreamWriter ( out , encoding ) ;
size = BUFFER_SIZE - xmlProlog . length () ; } xmlPrologWriter . write ( cbuf , off , size ) ; if ( xmlProlog . length () >= 5 ) { MST[rv.ROR4Mutator]MSP[] if ( xmlProlog . substring ( 0 , 5 ) . equals ( lr_1 ) ) {
writer . write ( xmlProlog . toString () ) ; MST[NonVoidMethodCallMutator]MSP[] if ( len > size ) { writer . write ( cbuf , off + size , len - size ) ; } } } } @Override
private void detectEncoding ( final char [] cbuf , final int off , final int len ) throws IOException { int size = len ; final StringBuffer xmlProlog = xmlPrologWriter . getBuffer () ; if ( xmlProlog . length () + len > BUFFER_SIZE ) { MST[rv.CRCR1Mutator]MSP[]
encoding = m . group ( 1 ) . toUpperCase ( Locale . ROOT ) ; encoding = encoding . substring ( 1 , encoding . length () - 1 ) ; MST[rv.CRCR3Mutator]MSP[] } else { encoding = defaultEncoding ; } } else {
public void write ( final char [] cbuf , final int off , final int len ) throws IOException { if ( xmlPrologWriter != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] detectEncoding ( cbuf , off , len ) ; } else { writer . write ( cbuf , off , len ) ;
private void detectEncoding ( final char [] cbuf , final int off , final int len ) throws IOException { int size = len ; final StringBuffer xmlProlog = xmlPrologWriter . getBuffer () ; if ( xmlProlog . length () + len > BUFFER_SIZE ) { MST[rv.CRCR5Mutator]MSP[]
size = BUFFER_SIZE - xmlProlog . length () ; } xmlPrologWriter . write ( cbuf , off , size ) ; if ( xmlProlog . length () >= 5 ) { if ( xmlProlog . substring ( 0 , 5 ) . equals ( lr_1 ) ) { MST[rv.ROR3Mutator]MSP[]
size = BUFFER_SIZE - xmlProlog . length () ; } xmlPrologWriter . write ( cbuf , off , size ) ; if ( xmlProlog . length () >= 5 ) { MST[rv.CRCR3Mutator]MSP[] if ( xmlProlog . substring ( 0 , 5 ) . equals ( lr_1 ) ) {
if ( xmlProlog . length () >= BUFFER_SIZE ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] encoding = defaultEncoding ; } } } else { encoding = defaultEncoding ; } if ( encoding != null ) { xmlPrologWriter = null ; writer = new OutputStreamWriter ( out , encoding ) ;
private void detectEncoding ( final char [] cbuf , final int off , final int len ) throws IOException { int size = len ; MST[rv.UOI2Mutator]MSP[] final StringBuffer xmlProlog = xmlPrologWriter . getBuffer () ; if ( xmlProlog . length () + len > BUFFER_SIZE ) {
size = BUFFER_SIZE - xmlProlog . length () ; } xmlPrologWriter . write ( cbuf , off , size ) ; if ( xmlProlog . length () >= 5 ) { if ( xmlProlog . substring ( 0 , 5 ) . equals ( lr_1 ) ) { MST[rv.CRCR6Mutator]MSP[]
final int xmlPrologEnd = xmlProlog . indexOf ( lr_2 ) ; if ( xmlPrologEnd > 0 ) { final Matcher m = ENCODING_PATTERN . matcher ( xmlProlog . substring ( 0 , MST[rv.UOI1Mutator]MSP[] xmlPrologEnd ) ) ; if ( m . find () ) {
size = BUFFER_SIZE - xmlProlog . length () ; } xmlPrologWriter . write ( cbuf , off , size ) ; if ( xmlProlog . length () >= 5 ) { MST[InlineConstantMutator]MSP[] if ( xmlProlog . substring ( 0 , 5 ) . equals ( lr_1 ) ) {
writer . write ( xmlPrologWriter . toString () ) ; MST[NonVoidMethodCallMutator]MSP[] } writer . close () ; } @Override public void flush () throws IOException { if ( writer != null ) { writer . flush () ; } }
size = BUFFER_SIZE - xmlProlog . length () ; } xmlPrologWriter . write ( cbuf , off , size ) ; MST[VoidMethodCallMutator]MSP[] if ( xmlProlog . length () >= 5 ) { if ( xmlProlog . substring ( 0 , 5 ) . equals ( lr_1 ) ) {
final int xmlPrologEnd = xmlProlog . indexOf ( lr_2 ) ; if ( xmlPrologEnd > 0 ) { MST[rv.ROR2Mutator]MSP[] final Matcher m = ENCODING_PATTERN . matcher ( xmlProlog . substring ( 0 , xmlPrologEnd ) ) ; if ( m . find () ) {
final int xmlPrologEnd = xmlProlog . indexOf ( lr_2 ) ; if ( xmlPrologEnd > 0 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] final Matcher m = ENCODING_PATTERN . matcher ( xmlProlog . substring ( 0 , xmlPrologEnd ) ) ; if ( m . find () ) {
size = BUFFER_SIZE - xmlProlog . length () ; } xmlPrologWriter . write ( cbuf , off , size ) ; if ( xmlProlog . length () >= 5 ) { if ( xmlProlog . substring ( 0 , 5 ) . equals ( lr_1 ) ) { MST[rv.ROR5Mutator]MSP[]
final int xmlPrologEnd = xmlProlog . indexOf ( lr_2 ) ; if ( xmlPrologEnd > 0 ) { final Matcher m = ENCODING_PATTERN . matcher ( xmlProlog . substring ( 0 , xmlPrologEnd ) ) ; if ( m . find () ) { MST[rv.ROR5Mutator]MSP[]
encoding = m . group ( 1 ) . toUpperCase ( Locale . ROOT ) ; encoding = encoding . substring ( 1 , encoding . length () - 1 ) ; MST[rv.AOR2Mutator]MSP[] } else { encoding = defaultEncoding ; } } else {
public String getEncoding () { return encoding ; } public String getDefaultEncoding () { return defaultEncoding ; MST[ReturnValsMutator]MSP[] } @Override public void close () throws IOException { if ( writer == null ) { encoding = defaultEncoding ; writer = new OutputStreamWriter ( out , encoding ) ;
if ( xmlProlog . length () >= BUFFER_SIZE ) { encoding = defaultEncoding ; } } } else { encoding = defaultEncoding ; MST[experimental.MemberVariableMutator]MSP[] } if ( encoding != null ) { xmlPrologWriter = null ; writer = new OutputStreamWriter ( out , encoding ) ;
final int xmlPrologEnd = xmlProlog . indexOf ( lr_2 ) ; if ( xmlPrologEnd > 0 ) { MST[rv.ROR5Mutator]MSP[] final Matcher m = ENCODING_PATTERN . matcher ( xmlProlog . substring ( 0 , xmlPrologEnd ) ) ; if ( m . find () ) {
final int xmlPrologEnd = xmlProlog . indexOf ( lr_2 ) ; if ( xmlPrologEnd > 0 ) { MST[rv.ROR4Mutator]MSP[] final Matcher m = ENCODING_PATTERN . matcher ( xmlProlog . substring ( 0 , xmlPrologEnd ) ) ; if ( m . find () ) {
encoding = m . group ( 1 ) . toUpperCase ( Locale . ROOT ) ; encoding = encoding . substring ( 1 , encoding . length () - 1 ) ; MST[InlineConstantMutator]MSP[] } else { encoding = defaultEncoding ; } } else {
private void detectEncoding ( final char [] cbuf , final int off , final int len ) throws IOException { int size = len ; final StringBuffer xmlProlog = xmlPrologWriter . getBuffer () ; if ( xmlProlog . length () + len > BUFFER_SIZE ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[]
encoding = m . group ( 1 ) . toUpperCase ( Locale . ROOT ) ; MST[experimental.MemberVariableMutator]MSP[] encoding = encoding . substring ( 1 , encoding . length () - 1 ) ; } else { encoding = defaultEncoding ; } } else {
private void detectEncoding ( final char [] cbuf , final int off , final int len ) throws IOException { int size = len ; final StringBuffer xmlProlog = xmlPrologWriter . getBuffer () ; if ( xmlProlog . length () + len > BUFFER_SIZE ) { MST[MathMutator]MSP[]
if ( xmlProlog . length () >= BUFFER_SIZE ) { encoding = defaultEncoding ; } } } else { encoding = defaultEncoding ; } if ( encoding != null ) { xmlPrologWriter = null ; writer = new OutputStreamWriter ( out , encoding ) ; MST[experimental.MemberVariableMutator]MSP[]
final int xmlPrologEnd = xmlProlog . indexOf ( lr_2 ) ; if ( xmlPrologEnd > 0 ) { final Matcher m = ENCODING_PATTERN . matcher ( xmlProlog . substring ( 0 , MST[InlineConstantMutator]MSP[] xmlPrologEnd ) ) ; if ( m . find () ) {
if ( xmlProlog . length () >= BUFFER_SIZE ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[] encoding = defaultEncoding ; } } } else { encoding = defaultEncoding ; } if ( encoding != null ) { xmlPrologWriter = null ; writer = new OutputStreamWriter ( out , encoding ) ;
writer . write ( xmlProlog . toString () ) ; if ( len > size ) { MST[rv.UOI2Mutator]MSP[] writer . write ( cbuf , off + size , len - size ) ; } } } } @Override
writer . write ( xmlPrologWriter . toString () ) ; } writer . close () ; MST[VoidMethodCallMutator]MSP[] } @Override public void flush () throws IOException { if ( writer != null ) { writer . flush () ; } }
encoding = m . group ( 1 ) . toUpperCase ( Locale . ROOT ) ; MST[rv.CRCR2Mutator]MSP[] encoding = encoding . substring ( 1 , encoding . length () - 1 ) ; } else { encoding = defaultEncoding ; } } else {
if ( xmlProlog . length () >= BUFFER_SIZE ) { MST[InlineConstantMutator]MSP[] encoding = defaultEncoding ; } } } else { encoding = defaultEncoding ; } if ( encoding != null ) { xmlPrologWriter = null ; writer = new OutputStreamWriter ( out , encoding ) ;
private void detectEncoding ( final char [] cbuf , final int off , final int len ) throws IOException { int size = len ; final StringBuffer xmlProlog = xmlPrologWriter . getBuffer () ; if ( xmlProlog . length () + len > BUFFER_SIZE ) { MST[rv.CRCR6Mutator]MSP[]
encoding = m . group ( 1 ) . toUpperCase ( Locale . ROOT ) ; MST[rv.CRCR4Mutator]MSP[] encoding = encoding . substring ( 1 , encoding . length () - 1 ) ; } else { encoding = defaultEncoding ; } } else {
private void detectEncoding ( final char [] cbuf , final int off , final int len ) throws IOException { int size = len ; final StringBuffer xmlProlog = xmlPrologWriter . getBuffer () ; if ( xmlProlog . length () + len > BUFFER_SIZE ) { MST[rv.ROR4Mutator]MSP[]
public String getEncoding () { return encoding ; } public String getDefaultEncoding () { return defaultEncoding ; } @Override public void close () throws IOException { if ( writer == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] encoding = defaultEncoding ; writer = new OutputStreamWriter ( out , encoding ) ;
private void detectEncoding ( final char [] cbuf , final int off , final int len ) throws IOException { int size = len ; final StringBuffer xmlProlog = xmlPrologWriter . getBuffer () ; if ( xmlProlog . length () + len > BUFFER_SIZE ) { MST[rv.ROR2Mutator]MSP[]
private void detectEncoding ( final char [] cbuf , final int off , final int len ) throws IOException { int size = len ; final StringBuffer xmlProlog = xmlPrologWriter . getBuffer () ; if ( xmlProlog . length () + len > BUFFER_SIZE ) { MST[rv.AOR4Mutator]MSP[]
private void detectEncoding ( final char [] cbuf , final int off , final int len ) throws IOException { int size = len ; final StringBuffer xmlProlog = xmlPrologWriter . getBuffer () ; if ( xmlProlog . length () + len > BUFFER_SIZE ) { MST[NegateConditionalsMutator]MSP[]
private void detectEncoding ( final char [] cbuf , final int off , final int len ) throws IOException { int size = len ; final StringBuffer xmlProlog = xmlPrologWriter . getBuffer () ; if ( xmlProlog . length () + len > BUFFER_SIZE ) { MST[rv.UOI1Mutator]MSP[]
private void detectEncoding ( final char [] cbuf , final int off , final int len ) throws IOException { int size = len ; final StringBuffer xmlProlog = xmlPrologWriter . getBuffer () ; if ( xmlProlog . length () + len > BUFFER_SIZE ) { MST[rv.UOI4Mutator]MSP[]
public void write ( final char [] cbuf , final int off , final int len ) throws IOException { if ( xmlPrologWriter != null ) { detectEncoding ( cbuf , off , len ) ; MST[rv.UOI2Mutator]MSP[] } else { writer . write ( cbuf , off , len ) ;
final int xmlPrologEnd = xmlProlog . indexOf ( lr_2 ) ; if ( xmlPrologEnd > 0 ) { final Matcher m = ENCODING_PATTERN . matcher ( xmlProlog . substring ( 0 , xmlPrologEnd ) ) ; if ( m . find () ) { MST[NegateConditionalsMutator]MSP[]
size = BUFFER_SIZE - xmlProlog . length () ; } xmlPrologWriter . write ( cbuf , off , size ) ; if ( xmlProlog . length () >= 5 ) { if ( xmlProlog . substring ( 0 , 5 ) . equals ( lr_1 ) ) { MST[rv.CRCR4Mutator]MSP[]
public void write ( final char [] cbuf , final int off , final int len ) throws IOException { if ( xmlPrologWriter != null ) { detectEncoding ( cbuf , off , len ) ; MST[VoidMethodCallMutator]MSP[] } else { writer . write ( cbuf , off , len ) ;
if ( xmlProlog . length () >= BUFFER_SIZE ) { encoding = defaultEncoding ; } } } else { encoding = defaultEncoding ; } if ( encoding != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] xmlPrologWriter = null ; writer = new OutputStreamWriter ( out , encoding ) ;
final int xmlPrologEnd = xmlProlog . indexOf ( lr_2 ) ; if ( xmlPrologEnd > 0 ) { final Matcher m = ENCODING_PATTERN . matcher ( xmlProlog . substring ( 0 , MST[rv.CRCR6Mutator]MSP[] xmlPrologEnd ) ) ; if ( m . find () ) {
writer . write ( xmlProlog . toString () ) ; if ( len > size ) { MST[rv.UOI2Mutator]MSP[] writer . write ( cbuf , off + size , len - size ) ; } } } } @Override
public String getEncoding () { return encoding ; } public String getDefaultEncoding () { return defaultEncoding ; } @Override public void close () throws IOException { if ( writer == null ) { encoding = defaultEncoding ; writer = new OutputStreamWriter ( out , encoding ) ; MST[ConstructorCallMutator]MSP[]
size = BUFFER_SIZE - xmlProlog . length () ; } xmlPrologWriter . write ( cbuf , off , size ) ; MST[rv.UOI2Mutator]MSP[] if ( xmlProlog . length () >= 5 ) { if ( xmlProlog . substring ( 0 , 5 ) . equals ( lr_1 ) ) {
size = BUFFER_SIZE - xmlProlog . length () ; } xmlPrologWriter . write ( cbuf , off , size ) ; if ( xmlProlog . length () >= 5 ) { MST[rv.ROR1Mutator]MSP[] if ( xmlProlog . substring ( 0 , 5 ) . equals ( lr_1 ) ) {
if ( xmlProlog . length () >= BUFFER_SIZE ) { MST[NegateConditionalsMutator]MSP[] encoding = defaultEncoding ; } } } else { encoding = defaultEncoding ; } if ( encoding != null ) { xmlPrologWriter = null ; writer = new OutputStreamWriter ( out , encoding ) ;
size = BUFFER_SIZE - xmlProlog . length () ; } xmlPrologWriter . write ( cbuf , off , size ) ; if ( xmlProlog . length () >= 5 ) { if ( xmlProlog . substring ( 0 , 5 ) . equals ( lr_1 ) ) { MST[NegateConditionalsMutator]MSP[]
encoding = m . group ( 1 ) . toUpperCase ( Locale . ROOT ) ; encoding = encoding . substring ( 1 , encoding . length () - 1 ) ; MST[rv.CRCR5Mutator]MSP[] } else { encoding = defaultEncoding ; } } else {
private void detectEncoding ( final char [] cbuf , final int off , final int len ) throws IOException { int size = len ; final StringBuffer xmlProlog = xmlPrologWriter . getBuffer () ; if ( xmlProlog . length () + len > BUFFER_SIZE ) { MST[rv.CRCR3Mutator]MSP[]
writer . write ( xmlProlog . toString () ) ; if ( len > size ) { MST[rv.ROR2Mutator]MSP[] writer . write ( cbuf , off + size , len - size ) ; } } } } @Override
encoding = m . group ( 1 ) . toUpperCase ( Locale . ROOT ) ; encoding = encoding . substring ( 1 , encoding . length () - 1 ) ; MST[NonVoidMethodCallMutator]MSP[] } else { encoding = defaultEncoding ; } } else {
writer . write ( xmlProlog . toString () ) ; if ( len > size ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] writer . write ( cbuf , off + size , len - size ) ; } } } } @Override
final int xmlPrologEnd = xmlProlog . indexOf ( lr_2 ) ; if ( xmlPrologEnd > 0 ) { MST[rv.UOI2Mutator]MSP[] final Matcher m = ENCODING_PATTERN . matcher ( xmlProlog . substring ( 0 , xmlPrologEnd ) ) ; if ( m . find () ) {
public String getEncoding () { return encoding ; } public String getDefaultEncoding () { return defaultEncoding ; } @Override public void close () throws IOException { if ( writer == null ) { MST[rv.ROR5Mutator]MSP[] encoding = defaultEncoding ; writer = new OutputStreamWriter ( out , encoding ) ;
private void detectEncoding ( final char [] cbuf , final int off , final int len ) throws IOException { int size = len ; final StringBuffer xmlProlog = xmlPrologWriter . getBuffer () ; if ( xmlProlog . length () + len > BUFFER_SIZE ) { MST[rv.AOR1Mutator]MSP[]
size = BUFFER_SIZE - xmlProlog . length () ; } xmlPrologWriter . write ( cbuf , off , size ) ; if ( xmlProlog . length () >= 5 ) { MST[rv.CRCR5Mutator]MSP[] if ( xmlProlog . substring ( 0 , 5 ) . equals ( lr_1 ) ) {
public String getEncoding () { return encoding ; } public String getDefaultEncoding () { return defaultEncoding ; } @Override public void close () throws IOException { if ( writer == null ) { encoding = defaultEncoding ; MST[experimental.MemberVariableMutator]MSP[] writer = new OutputStreamWriter ( out , encoding ) ;
encoding = m . group ( 1 ) . toUpperCase ( Locale . ROOT ) ; encoding = encoding . substring ( 1 , encoding . length () - 1 ) ; MST[rv.AOD2Mutator]MSP[] } else { encoding = defaultEncoding ; } } else {
final int xmlPrologEnd = xmlProlog . indexOf ( lr_2 ) ; if ( xmlPrologEnd > 0 ) { final Matcher m = ENCODING_PATTERN . matcher ( xmlProlog . substring ( 0 , MST[NonVoidMethodCallMutator]MSP[] xmlPrologEnd ) ) ; if ( m . find () ) {
private void detectEncoding ( final char [] cbuf , final int off , final int len ) throws IOException { int size = len ; final StringBuffer xmlProlog = xmlPrologWriter . getBuffer () ; if ( xmlProlog . length () + len > BUFFER_SIZE ) { MST[rv.AOD1Mutator]MSP[]
public void write ( final char [] cbuf , final int off , final int len ) throws IOException { if ( xmlPrologWriter != null ) { MST[rv.ROR5Mutator]MSP[] detectEncoding ( cbuf , off , len ) ; } else { writer . write ( cbuf , off , len ) ;
final int xmlPrologEnd = xmlProlog . indexOf ( lr_2 ) ; if ( xmlPrologEnd > 0 ) { final Matcher m = ENCODING_PATTERN . matcher ( xmlProlog . substring ( 0 , xmlPrologEnd ) ) ; if ( m . find () ) { MST[rv.ROR1Mutator]MSP[]
encoding = m . group ( 1 ) . toUpperCase ( Locale . ROOT ) ; encoding = encoding . substring ( 1 , encoding . length () - 1 ) ; MST[rv.CRCR4Mutator]MSP[] } else { encoding = defaultEncoding ; } } else {
if ( xmlProlog . length () >= BUFFER_SIZE ) { encoding = defaultEncoding ; } } } else { encoding = defaultEncoding ; } if ( encoding != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] xmlPrologWriter = null ; writer = new OutputStreamWriter ( out , encoding ) ;
final int xmlPrologEnd = xmlProlog . indexOf ( lr_2 ) ; if ( xmlPrologEnd > 0 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[] final Matcher m = ENCODING_PATTERN . matcher ( xmlProlog . substring ( 0 , xmlPrologEnd ) ) ; if ( m . find () ) {
encoding = m . group ( 1 ) . toUpperCase ( Locale . ROOT ) ; encoding = encoding . substring ( 1 , encoding . length () - 1 ) ; MST[rv.CRCR6Mutator]MSP[] } else { encoding = defaultEncoding ; } } else {
size = BUFFER_SIZE - xmlProlog . length () ; } xmlPrologWriter . write ( cbuf , off , size ) ; if ( xmlProlog . length () >= 5 ) { MST[NegateConditionalsMutator]MSP[] if ( xmlProlog . substring ( 0 , 5 ) . equals ( lr_1 ) ) {
public void write ( final char [] cbuf , final int off , final int len ) throws IOException { if ( xmlPrologWriter != null ) { detectEncoding ( cbuf , off , len ) ; MST[rv.UOI4Mutator]MSP[] } else { writer . write ( cbuf , off , len ) ;
encoding = m . group ( 1 ) . toUpperCase ( Locale . ROOT ) ; encoding = encoding . substring ( 1 , encoding . length () - 1 ) ; MST[rv.CRCR2Mutator]MSP[] } else { encoding = defaultEncoding ; } } else {
writer . write ( xmlPrologWriter . toString () ) ; MST[VoidMethodCallMutator]MSP[] } writer . close () ; } @Override public void flush () throws IOException { if ( writer != null ) { writer . flush () ; } }
public void write ( final char [] cbuf , final int off , final int len ) throws IOException { if ( xmlPrologWriter != null ) { detectEncoding ( cbuf , off , len ) ; MST[rv.ABSMutator]MSP[] } else { writer . write ( cbuf , off , len ) ;
size = BUFFER_SIZE - xmlProlog . length () ; } xmlPrologWriter . write ( cbuf , off , size ) ; if ( xmlProlog . length () >= 5 ) { MST[rv.CRCR6Mutator]MSP[] if ( xmlProlog . substring ( 0 , 5 ) . equals ( lr_1 ) ) {
size = BUFFER_SIZE - xmlProlog . length () ; } xmlPrologWriter . write ( cbuf , off , size ) ; if ( xmlProlog . length () >= 5 ) { MST[rv.CRCR4Mutator]MSP[] if ( xmlProlog . substring ( 0 , 5 ) . equals ( lr_1 ) ) {
private void detectEncoding ( final char [] cbuf , final int off , final int len ) throws IOException { int size = len ; MST[rv.UOI3Mutator]MSP[] final StringBuffer xmlProlog = xmlPrologWriter . getBuffer () ; if ( xmlProlog . length () + len > BUFFER_SIZE ) {
size = BUFFER_SIZE - xmlProlog . length () ; } xmlPrologWriter . write ( cbuf , off , size ) ; if ( xmlProlog . length () >= 5 ) { if ( xmlProlog . substring ( 0 , 5 ) . equals ( lr_1 ) ) { MST[rv.CRCR5Mutator]MSP[]
private void detectEncoding ( final char [] cbuf , final int off , final int len ) throws IOException { int size = len ; final StringBuffer xmlProlog = xmlPrologWriter . getBuffer () ; MST[NonVoidMethodCallMutator]MSP[] if ( xmlProlog . length () + len > BUFFER_SIZE ) {
final int xmlPrologEnd = xmlProlog . indexOf ( lr_2 ) ; if ( xmlPrologEnd > 0 ) { final Matcher m = ENCODING_PATTERN . matcher ( xmlProlog . substring ( 0 , MST[rv.UOI4Mutator]MSP[] xmlPrologEnd ) ) ; if ( m . find () ) {
final int xmlPrologEnd = xmlProlog . indexOf ( lr_2 ) ; if ( xmlPrologEnd > 0 ) { final Matcher m = ENCODING_PATTERN . matcher ( xmlProlog . substring ( 0 , MST[rv.UOI2Mutator]MSP[] xmlPrologEnd ) ) ; if ( m . find () ) {
size = BUFFER_SIZE - xmlProlog . length () ; } xmlPrologWriter . write ( cbuf , off , size ) ; if ( xmlProlog . length () >= 5 ) { if ( xmlProlog . substring ( 0 , 5 ) . equals ( lr_1 ) ) { MST[rv.CRCR1Mutator]MSP[]
private void detectEncoding ( final char [] cbuf , final int off , final int len ) throws IOException { int size = len ; MST[rv.UOI1Mutator]MSP[] final StringBuffer xmlProlog = xmlPrologWriter . getBuffer () ; if ( xmlProlog . length () + len > BUFFER_SIZE ) {
private void detectEncoding ( final char [] cbuf , final int off , final int len ) throws IOException { int size = len ; final StringBuffer xmlProlog = xmlPrologWriter . getBuffer () ; if ( xmlProlog . length () + len > BUFFER_SIZE ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[]
size = BUFFER_SIZE - xmlProlog . length () ; } xmlPrologWriter . write ( cbuf , off , size ) ; if ( xmlProlog . length () >= 5 ) { MST[rv.CRCR2Mutator]MSP[] if ( xmlProlog . substring ( 0 , 5 ) . equals ( lr_1 ) ) {
private void detectEncoding ( final char [] cbuf , final int off , final int len ) throws IOException { int size = len ; final StringBuffer xmlProlog = xmlPrologWriter . getBuffer () ; if ( xmlProlog . length () + len > BUFFER_SIZE ) { MST[rv.ABSMutator]MSP[]
final int xmlPrologEnd = xmlProlog . indexOf ( lr_2 ) ; if ( xmlPrologEnd > 0 ) { final Matcher m = ENCODING_PATTERN . matcher ( xmlProlog . substring ( 0 , MST[NonVoidMethodCallMutator]MSP[] xmlPrologEnd ) ) ; if ( m . find () ) {
if ( xmlProlog . length () >= BUFFER_SIZE ) { encoding = defaultEncoding ; } } } else { encoding = defaultEncoding ; } if ( encoding != null ) { MST[rv.ROR5Mutator]MSP[] xmlPrologWriter = null ; writer = new OutputStreamWriter ( out , encoding ) ;
public void write ( final char [] cbuf , final int off , final int len ) throws IOException { if ( xmlPrologWriter != null ) { detectEncoding ( cbuf , off , len ) ; MST[rv.UOI4Mutator]MSP[] } else { writer . write ( cbuf , off , len ) ;
private void detectEncoding ( final char [] cbuf , final int off , final int len ) throws IOException { int size = len ; final StringBuffer xmlProlog = xmlPrologWriter . getBuffer () ; if ( xmlProlog . length () + len > BUFFER_SIZE ) { MST[rv.UOI2Mutator]MSP[]
final int xmlPrologEnd = xmlProlog . indexOf ( lr_2 ) ; if ( xmlPrologEnd > 0 ) { final Matcher m = ENCODING_PATTERN . matcher ( xmlProlog . substring ( 0 , MST[rv.ABSMutator]MSP[] xmlPrologEnd ) ) ; if ( m . find () ) {
size = BUFFER_SIZE - xmlProlog . length () ; } xmlPrologWriter . write ( cbuf , off , size ) ; if ( xmlProlog . length () >= 5 ) { if ( xmlProlog . substring ( 0 , 5 ) . equals ( lr_1 ) ) { MST[rv.CRCR1Mutator]MSP[]
private void detectEncoding ( final char [] cbuf , final int off , final int len ) throws IOException { int size = len ; final StringBuffer xmlProlog = xmlPrologWriter . getBuffer () ; if ( xmlProlog . length () + len > BUFFER_SIZE ) { MST[InlineConstantMutator]MSP[]
public String getEncoding () { return encoding ; } public String getDefaultEncoding () { return defaultEncoding ; } @Override public void close () throws IOException { if ( writer == null ) { encoding = defaultEncoding ; writer = new OutputStreamWriter ( out , encoding ) ; MST[experimental.MemberVariableMutator]MSP[]
writer . write ( xmlPrologWriter . toString () ) ; } writer . close () ; } @Override public void flush () throws IOException { if ( writer != null ) { writer . flush () ; MST[VoidMethodCallMutator]MSP[] } }
writer . write ( xmlProlog . toString () ) ; if ( len > size ) { MST[rv.UOI4Mutator]MSP[] writer . write ( cbuf , off + size , len - size ) ; } } } } @Override
size = BUFFER_SIZE - xmlProlog . length () ; } xmlPrologWriter . write ( cbuf , off , size ) ; MST[rv.UOI4Mutator]MSP[] if ( xmlProlog . length () >= 5 ) { if ( xmlProlog . substring ( 0 , 5 ) . equals ( lr_1 ) ) {
size = BUFFER_SIZE - xmlProlog . length () ; } xmlPrologWriter . write ( cbuf , off , size ) ; if ( xmlProlog . length () >= 5 ) { if ( xmlProlog . substring ( 0 , 5 ) . equals ( lr_1 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
size = BUFFER_SIZE - xmlProlog . length () ; } xmlPrologWriter . write ( cbuf , off , size ) ; if ( xmlProlog . length () >= 5 ) { MST[rv.ROR3Mutator]MSP[] if ( xmlProlog . substring ( 0 , 5 ) . equals ( lr_1 ) ) {
writer . write ( xmlProlog . toString () ) ; if ( len > size ) { MST[rv.ROR4Mutator]MSP[] writer . write ( cbuf , off + size , len - size ) ; } } } } @Override
final int xmlPrologEnd = xmlProlog . indexOf ( lr_2 ) ; if ( xmlPrologEnd > 0 ) { MST[rv.UOI4Mutator]MSP[] final Matcher m = ENCODING_PATTERN . matcher ( xmlProlog . substring ( 0 , xmlPrologEnd ) ) ; if ( m . find () ) {
encoding = m . group ( 1 ) . toUpperCase ( Locale . ROOT ) ; MST[rv.CRCR5Mutator]MSP[] encoding = encoding . substring ( 1 , encoding . length () - 1 ) ; } else { encoding = defaultEncoding ; } } else {
writer . write ( xmlProlog . toString () ) ; if ( len > size ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[] writer . write ( cbuf , off + size , len - size ) ; } } } } @Override
size = BUFFER_SIZE - xmlProlog . length () ; } xmlPrologWriter . write ( cbuf , off , size ) ; MST[rv.ABSMutator]MSP[] if ( xmlProlog . length () >= 5 ) { if ( xmlProlog . substring ( 0 , 5 ) . equals ( lr_1 ) ) {
encoding = m . group ( 1 ) . toUpperCase ( Locale . ROOT ) ; MST[NonVoidMethodCallMutator]MSP[] encoding = encoding . substring ( 1 , encoding . length () - 1 ) ; } else { encoding = defaultEncoding ; } } else {
size = BUFFER_SIZE - xmlProlog . length () ; } xmlPrologWriter . write ( cbuf , off , size ) ; if ( xmlProlog . length () >= 5 ) { if ( xmlProlog . substring ( 0 , 5 ) . equals ( lr_1 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
final int xmlPrologEnd = xmlProlog . indexOf ( lr_2 ) ; if ( xmlPrologEnd > 0 ) { final Matcher m = ENCODING_PATTERN . matcher ( xmlProlog . substring ( 0 , xmlPrologEnd ) ) ; if ( m . find () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
writer . write ( xmlProlog . toString () ) ; if ( len > size ) { MST[ConditionalsBoundaryMutator]MSP[] writer . write ( cbuf , off + size , len - size ) ; } } } } @Override
private void detectEncoding ( final char [] cbuf , final int off , final int len ) throws IOException { int size = len ; final StringBuffer xmlProlog = xmlPrologWriter . getBuffer () ; if ( xmlProlog . length () + len > BUFFER_SIZE ) { MST[rv.AOR3Mutator]MSP[]
size = BUFFER_SIZE - xmlProlog . length () ; } xmlPrologWriter . write ( cbuf , off , size ) ; if ( xmlProlog . length () >= 5 ) { if ( xmlProlog . substring ( 0 , 5 ) . equals ( lr_1 ) ) { MST[rv.CRCR5Mutator]MSP[]
if ( xmlProlog . length () >= BUFFER_SIZE ) { encoding = defaultEncoding ; } } } else { encoding = defaultEncoding ; } if ( encoding != null ) { xmlPrologWriter = null ; writer = new OutputStreamWriter ( out , encoding ) ; MST[ConstructorCallMutator]MSP[]
private void detectEncoding ( final char [] cbuf , final int off , final int len ) throws IOException { int size = len ; final StringBuffer xmlProlog = xmlPrologWriter . getBuffer () ; if ( xmlProlog . length () + len > BUFFER_SIZE ) { MST[rv.ROR5Mutator]MSP[]
size = BUFFER_SIZE - xmlProlog . length () ; } xmlPrologWriter . write ( cbuf , off , size ) ; if ( xmlProlog . length () >= 5 ) { if ( xmlProlog . substring ( 0 , 5 ) . equals ( lr_1 ) ) { MST[rv.CRCR3Mutator]MSP[]
private void detectEncoding ( final char [] cbuf , final int off , final int len ) throws IOException { int size = len ; final StringBuffer xmlProlog = xmlPrologWriter . getBuffer () ; if ( xmlProlog . length () + len > BUFFER_SIZE ) { MST[rv.ROR1Mutator]MSP[]
encoding = m . group ( 1 ) . toUpperCase ( Locale . ROOT ) ; encoding = encoding . substring ( 1 , encoding . length () - 1 ) ; MST[rv.CRCR3Mutator]MSP[] } else { encoding = defaultEncoding ; } } else {
if ( xmlProlog . length () >= BUFFER_SIZE ) { encoding = defaultEncoding ; } } } else { encoding = defaultEncoding ; } if ( encoding != null ) { MST[NegateConditionalsMutator]MSP[] xmlPrologWriter = null ; writer = new OutputStreamWriter ( out , encoding ) ;
final int xmlPrologEnd = xmlProlog . indexOf ( lr_2 ) ; if ( xmlPrologEnd > 0 ) { final Matcher m = ENCODING_PATTERN . matcher ( xmlProlog . substring ( 0 , xmlPrologEnd ) ) ; if ( m . find () ) { MST[rv.ROR3Mutator]MSP[]
private void detectEncoding ( final char [] cbuf , final int off , final int len ) throws IOException { int size = len ; final StringBuffer xmlProlog = xmlPrologWriter . getBuffer () ; if ( xmlProlog . length () + len > BUFFER_SIZE ) { MST[ConditionalsBoundaryMutator]MSP[]
writer . write ( xmlProlog . toString () ) ; MST[VoidMethodCallMutator]MSP[] if ( len > size ) { writer . write ( cbuf , off + size , len - size ) ; } } } } @Override
encoding = m . group ( 1 ) . toUpperCase ( Locale . ROOT ) ; encoding = encoding . substring ( 1 , encoding . length () - 1 ) ; MST[MathMutator]MSP[] } else { encoding = defaultEncoding ; } } else {
final int xmlPrologEnd = xmlProlog . indexOf ( lr_2 ) ; if ( xmlPrologEnd > 0 ) { MST[rv.ROR3Mutator]MSP[] final Matcher m = ENCODING_PATTERN . matcher ( xmlProlog . substring ( 0 , xmlPrologEnd ) ) ; if ( m . find () ) {
public void write ( final char [] cbuf , final int off , final int len ) throws IOException { if ( xmlPrologWriter != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] detectEncoding ( cbuf , off , len ) ; } else { writer . write ( cbuf , off , len ) ;
public void write ( final char [] cbuf , final int off , final int len ) throws IOException { if ( xmlPrologWriter != null ) { detectEncoding ( cbuf , off , len ) ; MST[rv.UOI2Mutator]MSP[] } else { writer . write ( cbuf , off , len ) ;
final int xmlPrologEnd = xmlProlog . indexOf ( lr_2 ) ; if ( xmlPrologEnd > 0 ) { MST[rv.ABSMutator]MSP[] final Matcher m = ENCODING_PATTERN . matcher ( xmlProlog . substring ( 0 , xmlPrologEnd ) ) ; if ( m . find () ) {
encoding = m . group ( 1 ) . toUpperCase ( Locale . ROOT ) ; encoding = encoding . substring ( 1 , encoding . length () - 1 ) ; MST[InlineConstantMutator]MSP[] } else { encoding = defaultEncoding ; } } else {
encoding = m . group ( 1 ) . toUpperCase ( Locale . ROOT ) ; encoding = encoding . substring ( 1 , encoding . length () - 1 ) ; MST[rv.AOR3Mutator]MSP[] } else { encoding = defaultEncoding ; } } else {
encoding = m . group ( 1 ) . toUpperCase ( Locale . ROOT ) ; encoding = encoding . substring ( 1 , encoding . length () - 1 ) ; MST[rv.AOR4Mutator]MSP[] } else { encoding = defaultEncoding ; } } else {
encoding = m . group ( 1 ) . toUpperCase ( Locale . ROOT ) ; encoding = encoding . substring ( 1 , encoding . length () - 1 ) ; MST[rv.AOR1Mutator]MSP[] } else { encoding = defaultEncoding ; } } else {
final int xmlPrologEnd = xmlProlog . indexOf ( lr_2 ) ; if ( xmlPrologEnd > 0 ) { MST[rv.ROR1Mutator]MSP[] final Matcher m = ENCODING_PATTERN . matcher ( xmlProlog . substring ( 0 , xmlPrologEnd ) ) ; if ( m . find () ) {
size = BUFFER_SIZE - xmlProlog . length () ; } xmlPrologWriter . write ( cbuf , off , size ) ; if ( xmlProlog . length () >= 5 ) { if ( xmlProlog . substring ( 0 , 5 ) . equals ( lr_1 ) ) { MST[NonVoidMethodCallMutator]MSP[]
writer . write ( xmlProlog . toString () ) ; if ( len > size ) { MST[rv.UOI4Mutator]MSP[] writer . write ( cbuf , off + size , len - size ) ; } } } } @Override
writer . write ( xmlProlog . toString () ) ; if ( len > size ) { MST[rv.UOI3Mutator]MSP[] writer . write ( cbuf , off + size , len - size ) ; } } } } @Override
if ( xmlProlog . length () >= BUFFER_SIZE ) { MST[rv.CRCR6Mutator]MSP[] encoding = defaultEncoding ; } } } else { encoding = defaultEncoding ; } if ( encoding != null ) { xmlPrologWriter = null ; writer = new OutputStreamWriter ( out , encoding ) ;
encoding = m . group ( 1 ) . toUpperCase ( Locale . ROOT ) ; MST[rv.CRCR6Mutator]MSP[] encoding = encoding . substring ( 1 , encoding . length () - 1 ) ; } else { encoding = defaultEncoding ; } } else {
final int xmlPrologEnd = xmlProlog . indexOf ( lr_2 ) ; if ( xmlPrologEnd > 0 ) { MST[ConditionalsBoundaryMutator]MSP[] final Matcher m = ENCODING_PATTERN . matcher ( xmlProlog . substring ( 0 , xmlPrologEnd ) ) ; if ( m . find () ) {
writer . write ( xmlProlog . toString () ) ; if ( len > size ) { MST[rv.UOI1Mutator]MSP[] writer . write ( cbuf , off + size , len - size ) ; } } } } @Override
writer . write ( xmlProlog . toString () ) ; if ( len > size ) { MST[rv.ROR1Mutator]MSP[] writer . write ( cbuf , off + size , len - size ) ; } } } } @Override
private void detectEncoding ( final char [] cbuf , final int off , final int len ) throws IOException { int size = len ; final StringBuffer xmlProlog = xmlPrologWriter . getBuffer () ; if ( xmlProlog . length () + len > BUFFER_SIZE ) { MST[rv.CRCR2Mutator]MSP[]
encoding = m . group ( 1 ) . toUpperCase ( Locale . ROOT ) ; encoding = encoding . substring ( 1 , encoding . length () - 1 ) ; MST[experimental.MemberVariableMutator]MSP[] } else { encoding = defaultEncoding ; } } else {
writer . write ( xmlProlog . toString () ) ; if ( len > size ) { MST[rv.ROR3Mutator]MSP[] writer . write ( cbuf , off + size , len - size ) ; } } } } @Override
size = BUFFER_SIZE - xmlProlog . length () ; } xmlPrologWriter . write ( cbuf , off , size ) ; MST[rv.ABSMutator]MSP[] if ( xmlProlog . length () >= 5 ) { if ( xmlProlog . substring ( 0 , 5 ) . equals ( lr_1 ) ) {
writer . write ( xmlProlog . toString () ) ; if ( len > size ) { MST[rv.ABSMutator]MSP[] writer . write ( cbuf , off + size , len - size ) ; } } } } @Override
if ( xmlProlog . length () >= BUFFER_SIZE ) { MST[rv.CRCR2Mutator]MSP[] encoding = defaultEncoding ; } } } else { encoding = defaultEncoding ; } if ( encoding != null ) { xmlPrologWriter = null ; writer = new OutputStreamWriter ( out , encoding ) ;
