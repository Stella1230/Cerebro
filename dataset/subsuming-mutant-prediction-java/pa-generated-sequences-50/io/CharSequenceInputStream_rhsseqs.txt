if ( len < 0 || ( off + len ) > b . length ) { throw new IndexOutOfBoundsException ( lr_2 + b . length + MST[rv.ABSMutator]MSP[N] lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { return 0 ; }
for (; ; ) { if ( this . bbuf . hasRemaining () ) { return this . bbuf . get () & 0xFF ; } fillBuffer () ; if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) { MST[rv.ROR1Mutator]MSP[N]
final int chunk = Math . min ( this . bbuf . remaining () , len ) ; this . bbuf . get ( b , off , chunk ) ; off += chunk ; MST[rv.ABSMutator]MSP[N] len -= chunk ; bytesRead += chunk ; } else { fillBuffer () ;
public boolean markSupported () { return true ; MST[InlineConstantMutator]MSP[N] }
final int chunk = Math . min ( this . bbuf . remaining () , len ) ; this . bbuf . get ( b , off , chunk ) ; off += chunk ; len -= chunk ; MST[rv.UOI3Mutator]MSP[N] bytesRead += chunk ; } else { fillBuffer () ;
private void fillBuffer () throws CharacterCodingException { this . bbuf . compact () ; final CoderResult result = this . encoder . encode ( this . cbuf , this . bbuf , true ) ; if ( result . isError () ) { MST[rv.ROR3Mutator]MSP[N] result . throwException () ; }
final int chunk = Math . min ( this . bbuf . remaining () , len ) ; this . bbuf . get ( b , off , chunk ) ; MST[rv.UOI4Mutator]MSP[N] off += chunk ; len -= chunk ; bytesRead += chunk ; } else { fillBuffer () ;
if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) { break; } } } return bytesRead == 0 && ! this . cbuf . hasRemaining () ? EOF : bytesRead ; MST[rv.ABSMutator]MSP[N] } @Override public int read () throws IOException {
while( this . cbuf . position () < this . mark_cbuf ) { MST[rv.ROR4Mutator]MSP[N] this . bbuf . rewind () ; this . bbuf . limit ( 0 ) ; fillBuffer () ; } } if ( this . cbuf . position () != this . mark_cbuf ) {
while( this . cbuf . position () < this . mark_cbuf ) { this . bbuf . rewind () ; this . bbuf . limit ( 0 ) ; MST[rv.CRCR6Mutator]MSP[N] fillBuffer () ; } } if ( this . cbuf . position () != this . mark_cbuf ) {
while ( n > 0 && available () > 0 ) { MST[ConditionalsBoundaryMutator]MSP[S] this . read () ; n -- ; skipped ++ ; } return skipped ; } @Override public int available () throws IOException {
if ( len < 0 || ( off + len ) > b . length ) { throw new IndexOutOfBoundsException ( lr_2 + b . length + lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { return 0 ; MST[rv.CRCR5Mutator]MSP[N] }
final int chunk = Math . min ( this . bbuf . remaining () , len ) ; MST[rv.UOI2Mutator]MSP[N] this . bbuf . get ( b , off , chunk ) ; off += chunk ; len -= chunk ; bytesRead += chunk ; } else { fillBuffer () ;
this . mark_bbuf = this . bbuf . position () ; this . cbuf . mark () ; this . bbuf . mark () ; } @Override public synchronized void reset () throws IOException { if ( this . mark_cbuf != NO_MARK ) { MST[rv.CRCR1Mutator]MSP[N]
return EOF ; } } } @Override public int read ( final byte [] b ) throws IOException { return read ( b , 0 , b . length ) ; MST[rv.CRCR3Mutator]MSP[N] } @Override public long skip ( long n ) throws IOException { long skipped = 0 ;
final int chunk = Math . min ( this . bbuf . remaining () , len ) ; this . bbuf . get ( b , off , chunk ) ; off += chunk ; MST[rv.AOD1Mutator]MSP[N] len -= chunk ; bytesRead += chunk ; } else { fillBuffer () ;
if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) { MST[NonVoidMethodCallMutator]MSP[N] return EOF ; } int bytesRead = 0 ; while ( len > 0 ) { if ( this . bbuf . hasRemaining () ) {
if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) { break; } } } return bytesRead == 0 && ! this . cbuf . hasRemaining () ? EOF : bytesRead ; MST[NegateConditionalsMutator]MSP[N] } @Override public int read () throws IOException {
while ( n > 0 && available () > 0 ) { MST[rv.ROR3Mutator]MSP[N] this . read () ; n -- ; skipped ++ ; } return skipped ; } @Override public int available () throws IOException {
while ( n > 0 && available () > 0 ) { MST[rv.ROR4Mutator]MSP[N] this . read () ; n -- ; skipped ++ ; } return skipped ; } @Override public int available () throws IOException {
if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) { return EOF ; } int bytesRead = 0 ; while ( len > 0 ) { MST[rv.ROR4Mutator]MSP[N] if ( this . bbuf . hasRemaining () ) {
for (; ; ) { if ( this . bbuf . hasRemaining () ) { return this . bbuf . get () & 0xFF ; } fillBuffer () ; if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) { return EOF ; } int bytesRead = 0 ; while ( len > 0 ) { MST[rv.UOI3Mutator]MSP[N] if ( this . bbuf . hasRemaining () ) {
if ( len < 0 || ( off + len ) > b . length ) { throw new IndexOutOfBoundsException ( lr_2 + b . length + MST[experimental.NakedReceiverMutator]MSP[N] lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { return 0 ; }
while( this . cbuf . position () < this . mark_cbuf ) { this . bbuf . rewind () ; this . bbuf . limit ( 0 ) ; fillBuffer () ; } } if ( this . cbuf . position () != this . mark_cbuf ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) { MST[NegateConditionalsMutator]MSP[N] return EOF ; } int bytesRead = 0 ; while ( len > 0 ) { if ( this . bbuf . hasRemaining () ) {
if ( len < 0 || ( off + len ) > b . length ) { throw new IndexOutOfBoundsException ( lr_2 + b . length + MST[ConstructorCallMutator]MSP[S] lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { return 0 ; }
while ( n > 0 && available () > 0 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[S] this . read () ; n -- ; skipped ++ ; } return skipped ; } @Override public int available () throws IOException {
while ( n > 0 && available () > 0 ) { this . read () ; n -- ; MST[rv.AOR2Mutator]MSP[S] skipped ++ ; } return skipped ; } @Override public int available () throws IOException {
private void fillBuffer () throws CharacterCodingException { this . bbuf . compact () ; final CoderResult result = this . encoder . encode ( this . cbuf , this . bbuf , true ) ; if ( result . isError () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] result . throwException () ; }
for (; ; ) { if ( this . bbuf . hasRemaining () ) { return this . bbuf . get () & 0xFF ; MST[ReturnValsMutator]MSP[N] } fillBuffer () ; if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) {
throw new IllegalStateException ( lr_5 + cbuf . position () + lr_6 + lr_7 + this . mark_cbuf ) ; } this . bbuf . position ( this . mark_bbuf ) ; this . mark_cbuf = NO_MARK ; MST[rv.CRCR6Mutator]MSP[N] this . mark_bbuf = NO_MARK ; } } @Override
if ( len < 0 || ( off + len ) > b . length ) { throw new IndexOutOfBoundsException ( lr_2 + b . length + MST[rv.UOI2Mutator]MSP[N] lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { return 0 ; }
throw new IllegalStateException ( lr_5 + cbuf . position () + lr_6 + lr_7 + this . mark_cbuf ) ; } this . bbuf . position ( this . mark_bbuf ) ; this . mark_cbuf = NO_MARK ; MST[rv.CRCR2Mutator]MSP[N] this . mark_bbuf = NO_MARK ; } } @Override
final int chunk = Math . min ( this . bbuf . remaining () , len ) ; this . bbuf . get ( b , off , chunk ) ; off += chunk ; MST[rv.UOI2Mutator]MSP[N] len -= chunk ; bytesRead += chunk ; } else { fillBuffer () ;
for (; ; ) { if ( this . bbuf . hasRemaining () ) { return this . bbuf . get () & 0xFF ; MST[rv.OBBN3Mutator]MSP[N] } fillBuffer () ; if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) {
final int chunk = Math . min ( this . bbuf . remaining () , len ) ; MST[rv.ABSMutator]MSP[N] this . bbuf . get ( b , off , chunk ) ; off += chunk ; len -= chunk ; bytesRead += chunk ; } else { fillBuffer () ;
if ( len < 0 || ( off + len ) > b . length ) { throw new IndexOutOfBoundsException ( lr_2 + b . length + lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { return 0 ; MST[ReturnValsMutator]MSP[N] }
this . mark_bbuf = this . bbuf . position () ; this . cbuf . mark () ; this . bbuf . mark () ; } @Override public synchronized void reset () throws IOException { if ( this . mark_cbuf != NO_MARK ) { MST[rv.CRCR5Mutator]MSP[N]
if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) { break; } } } return bytesRead == 0 && ! this . cbuf . hasRemaining () ? EOF : bytesRead ; MST[rv.UOI2Mutator]MSP[N] } @Override public int read () throws IOException {
if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) { MST[rv.ROR1Mutator]MSP[N] return EOF ; } int bytesRead = 0 ; while ( len > 0 ) { if ( this . bbuf . hasRemaining () ) {
if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) { break; } } } return bytesRead == 0 && ! this . cbuf . hasRemaining () ? EOF : bytesRead ; MST[rv.ROR5Mutator]MSP[N] } @Override public int read () throws IOException {
if ( len < 0 || ( off + len ) > b . length ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] throw new IndexOutOfBoundsException ( lr_2 + b . length + lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { return 0 ; }
while ( n > 0 && available () > 0 ) { MST[rv.UOI1Mutator]MSP[S] this . read () ; n -- ; skipped ++ ; } return skipped ; } @Override public int available () throws IOException {
for (; ; ) { if ( this . bbuf . hasRemaining () ) { MST[NegateConditionalsMutator]MSP[N] return this . bbuf . get () & 0xFF ; } fillBuffer () ; if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) {
while ( n > 0 && available () > 0 ) { MST[rv.ABSMutator]MSP[N] this . read () ; n -- ; skipped ++ ; } return skipped ; } @Override public int available () throws IOException {
if ( len < 0 || ( off + len ) > b . length ) { throw new IndexOutOfBoundsException ( lr_2 + b . length + MST[NonVoidMethodCallMutator]MSP[N] lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { return 0 ; }
this . mark_bbuf = this . bbuf . position () ; this . cbuf . mark () ; this . bbuf . mark () ; } @Override public synchronized void reset () throws IOException { if ( this . mark_cbuf != NO_MARK ) { MST[rv.ROR2Mutator]MSP[N]
if ( this . cbuf . position () != 0 ) { MST[rv.ROR4Mutator]MSP[N] this . encoder . reset () ; this . cbuf . rewind () ; this . bbuf . rewind () ; this . bbuf . limit ( 0 ) ;
if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) { MST[rv.ROR5Mutator]MSP[N] return EOF ; } int bytesRead = 0 ; while ( len > 0 ) { if ( this . bbuf . hasRemaining () ) {
while( this . cbuf . position () < this . mark_cbuf ) { this . bbuf . rewind () ; this . bbuf . limit ( 0 ) ; MST[NonVoidMethodCallMutator]MSP[N] fillBuffer () ; } } if ( this . cbuf . position () != this . mark_cbuf ) {
while ( n > 0 && available () > 0 ) { this . read () ; n -- ; skipped ++ ; MST[rv.AOD2Mutator]MSP[N] } return skipped ; } @Override public int available () throws IOException {
while( this . cbuf . position () < this . mark_cbuf ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] this . bbuf . rewind () ; this . bbuf . limit ( 0 ) ; fillBuffer () ; } } if ( this . cbuf . position () != this . mark_cbuf ) {
for (; ; ) { if ( this . bbuf . hasRemaining () ) { return this . bbuf . get () & 0xFF ; MST[rv.CRCR5Mutator]MSP[N] } fillBuffer () ; if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) {
for (; ; ) { if ( this . bbuf . hasRemaining () ) { return this . bbuf . get () & 0xFF ; MST[rv.CRCR1Mutator]MSP[N] } fillBuffer () ; if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) {
final int chunk = Math . min ( this . bbuf . remaining () , len ) ; this . bbuf . get ( b , off , chunk ) ; off += chunk ; MST[rv.UOI1Mutator]MSP[N] len -= chunk ; bytesRead += chunk ; } else { fillBuffer () ;
private void fillBuffer () throws CharacterCodingException { this . bbuf . compact () ; final CoderResult result = this . encoder . encode ( this . cbuf , this . bbuf , true ) ; MST[rv.CRCR4Mutator]MSP[N] if ( result . isError () ) { result . throwException () ; }
if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) { return EOF ; MST[rv.CRCR1Mutator]MSP[N] } int bytesRead = 0 ; while ( len > 0 ) { if ( this . bbuf . hasRemaining () ) {
if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) { return EOF ; } int bytesRead = 0 ; while ( len > 0 ) { if ( this . bbuf . hasRemaining () ) { MST[rv.ROR2Mutator]MSP[N]
private void fillBuffer () throws CharacterCodingException { this . bbuf . compact () ; final CoderResult result = this . encoder . encode ( this . cbuf , this . bbuf , true ) ; if ( result . isError () ) { MST[NonVoidMethodCallMutator]MSP[N] result . throwException () ; }
throw new IllegalStateException ( lr_5 + cbuf . position () + lr_6 + lr_7 + this . mark_cbuf ) ; } this . bbuf . position ( this . mark_bbuf ) ; MST[rv.UOI1Mutator]MSP[N] this . mark_cbuf = NO_MARK ; this . mark_bbuf = NO_MARK ; } } @Override
if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) { break; } } } return bytesRead == 0 && ! this . cbuf . hasRemaining () ? EOF : bytesRead ; MST[rv.UOI3Mutator]MSP[N] } @Override public int read () throws IOException {
for (; ; ) { if ( this . bbuf . hasRemaining () ) { MST[rv.ROR5Mutator]MSP[N] return this . bbuf . get () & 0xFF ; } fillBuffer () ; if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) {
final int chunk = Math . min ( this . bbuf . remaining () , len ) ; this . bbuf . get ( b , off , chunk ) ; off += chunk ; len -= chunk ; MST[rv.AOD2Mutator]MSP[N] bytesRead += chunk ; } else { fillBuffer () ;
while ( n > 0 && available () > 0 ) { MST[rv.UOI2Mutator]MSP[N] this . read () ; n -- ; skipped ++ ; } return skipped ; } @Override public int available () throws IOException {
public boolean markSupported () { return true ; MST[rv.CRCR2Mutator]MSP[N] }
final int chunk = Math . min ( this . bbuf . remaining () , len ) ; this . bbuf . get ( b , off , chunk ) ; off += chunk ; MST[rv.AOR3Mutator]MSP[N] len -= chunk ; bytesRead += chunk ; } else { fillBuffer () ;
while ( n > 0 && available () > 0 ) { MST[InlineConstantMutator]MSP[S] this . read () ; n -- ; skipped ++ ; } return skipped ; } @Override public int available () throws IOException {
if ( len < 0 || ( off + len ) > b . length ) { MST[rv.UOI4Mutator]MSP[N] throw new IndexOutOfBoundsException ( lr_2 + b . length + lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { return 0 ; }
if ( len < 0 || ( off + len ) > b . length ) { MST[rv.ROR5Mutator]MSP[N] throw new IndexOutOfBoundsException ( lr_2 + b . length + lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { return 0 ; }
if ( len < 0 || ( off + len ) > b . length ) { throw new IndexOutOfBoundsException ( lr_2 + b . length + MST[experimental.NakedReceiverMutator]MSP[N] lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { return 0 ; }
if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) { break; } } } return bytesRead == 0 && ! this . cbuf . hasRemaining () ? EOF : bytesRead ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } @Override public int read () throws IOException {
if ( this . cbuf . position () != 0 ) { this . encoder . reset () ; this . cbuf . rewind () ; this . bbuf . rewind () ; this . bbuf . limit ( 0 ) ; MST[rv.CRCR5Mutator]MSP[N]
if ( this . cbuf . position () != 0 ) { MST[rv.ROR3Mutator]MSP[N] this . encoder . reset () ; this . cbuf . rewind () ; this . bbuf . rewind () ; this . bbuf . limit ( 0 ) ;
if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) { MST[rv.ROR4Mutator]MSP[N] return EOF ; } int bytesRead = 0 ; while ( len > 0 ) { if ( this . bbuf . hasRemaining () ) {
while( this . cbuf . position () < this . mark_cbuf ) { this . bbuf . rewind () ; this . bbuf . limit ( 0 ) ; fillBuffer () ; } } if ( this . cbuf . position () != this . mark_cbuf ) { MST[rv.UOI2Mutator]MSP[N]
final int chunk = Math . min ( this . bbuf . remaining () , len ) ; this . bbuf . get ( b , off , chunk ) ; off += chunk ; len -= chunk ; MST[rv.UOI3Mutator]MSP[N] bytesRead += chunk ; } else { fillBuffer () ;
if ( len < 0 || ( off + len ) > b . length ) { throw new IndexOutOfBoundsException ( lr_2 + b . length + lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { MST[rv.UOI4Mutator]MSP[N] return 0 ; }
final int chunk = Math . min ( this . bbuf . remaining () , len ) ; this . bbuf . get ( b , off , chunk ) ; off += chunk ; MST[rv.UOI1Mutator]MSP[N] len -= chunk ; bytesRead += chunk ; } else { fillBuffer () ;
this . mark_bbuf = this . bbuf . position () ; this . cbuf . mark () ; this . bbuf . mark () ; } @Override public synchronized void reset () throws IOException { if ( this . mark_cbuf != NO_MARK ) { MST[rv.UOI4Mutator]MSP[N]
final int chunk = Math . min ( this . bbuf . remaining () , len ) ; this . bbuf . get ( b , off , chunk ) ; off += chunk ; MST[rv.ABSMutator]MSP[S] len -= chunk ; bytesRead += chunk ; } else { fillBuffer () ;
while ( n > 0 && available () > 0 ) { this . read () ; n -- ; MST[rv.CRCR5Mutator]MSP[N] skipped ++ ; } return skipped ; } @Override public int available () throws IOException {
if ( len < 0 || ( off + len ) > b . length ) { throw new IndexOutOfBoundsException ( lr_2 + b . length + MST[rv.UOI1Mutator]MSP[N] lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { return 0 ; }
while ( n > 0 && available () > 0 ) { this . read () ; n -- ; MST[rv.AOD1Mutator]MSP[S] skipped ++ ; } return skipped ; } @Override public int available () throws IOException {
while ( n > 0 && available () > 0 ) { this . read () ; n -- ; skipped ++ ; MST[rv.CRCR2Mutator]MSP[N] } return skipped ; } @Override public int available () throws IOException {
if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return EOF ; } int bytesRead = 0 ; while ( len > 0 ) { if ( this . bbuf . hasRemaining () ) {
return this . bbuf . remaining () + this . cbuf . remaining () ; MST[rv.AOR2Mutator]MSP[N] } @Override public void close () throws IOException { } @Override public synchronized void mark ( final int readlimit ) { this . mark_cbuf = this . cbuf . position () ;
return EOF ; } } } @Override public int read ( final byte [] b ) throws IOException { return read ( b , 0 , b . length ) ; } @Override public long skip ( long n ) throws IOException { long skipped = 0 ; MST[rv.CRCR1Mutator]MSP[N]
while ( n > 0 && available () > 0 ) { MST[rv.CRCR6Mutator]MSP[N] this . read () ; n -- ; skipped ++ ; } return skipped ; } @Override public int available () throws IOException {
if ( len < 0 || ( off + len ) > b . length ) { MST[rv.ROR2Mutator]MSP[N] throw new IndexOutOfBoundsException ( lr_2 + b . length + lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { return 0 ; }
if ( len < 0 || ( off + len ) > b . length ) { throw new IndexOutOfBoundsException ( lr_2 + b . length + lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { return 0 ; MST[rv.CRCR1Mutator]MSP[N] }
if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) { break; } } } return bytesRead == 0 && ! this . cbuf . hasRemaining () ? EOF : bytesRead ; MST[rv.UOI1Mutator]MSP[N] } @Override public int read () throws IOException {
if ( len < 0 || ( off + len ) > b . length ) { MST[rv.UOI4Mutator]MSP[N] throw new IndexOutOfBoundsException ( lr_2 + b . length + lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { return 0 ; }
throw new IllegalStateException ( lr_5 + cbuf . position () + lr_6 + lr_7 + this . mark_cbuf ) ; } this . bbuf . position ( this . mark_bbuf ) ; MST[rv.UOI4Mutator]MSP[N] this . mark_cbuf = NO_MARK ; this . mark_bbuf = NO_MARK ; } } @Override
this . mark_bbuf = this . bbuf . position () ; this . cbuf . mark () ; MST[NonVoidMethodCallMutator]MSP[N] this . bbuf . mark () ; } @Override public synchronized void reset () throws IOException { if ( this . mark_cbuf != NO_MARK ) {
if ( this . cbuf . position () != 0 ) { this . encoder . reset () ; this . cbuf . rewind () ; MST[NonVoidMethodCallMutator]MSP[N] this . bbuf . rewind () ; this . bbuf . limit ( 0 ) ;
if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) { MST[rv.ROR3Mutator]MSP[N] break; } } } return bytesRead == 0 && ! this . cbuf . hasRemaining () ? EOF : bytesRead ; } @Override public int read () throws IOException {
if ( len < 0 || ( off + len ) > b . length ) { MST[rv.AOR1Mutator]MSP[N] throw new IndexOutOfBoundsException ( lr_2 + b . length + lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { return 0 ; }
if ( len < 0 || ( off + len ) > b . length ) { MST[rv.UOI3Mutator]MSP[N] throw new IndexOutOfBoundsException ( lr_2 + b . length + lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { return 0 ; }
while ( n > 0 && available () > 0 ) { this . read () ; n -- ; MST[rv.ABSMutator]MSP[N] skipped ++ ; } return skipped ; } @Override public int available () throws IOException {
while ( n > 0 && available () > 0 ) { this . read () ; n -- ; skipped ++ ; MST[rv.AOR3Mutator]MSP[N] } return skipped ; } @Override public int available () throws IOException {
return this . bbuf . remaining () + this . cbuf . remaining () ; MST[PrimitiveReturnsMutator]MSP[N] } @Override public void close () throws IOException { } @Override public synchronized void mark ( final int readlimit ) { this . mark_cbuf = this . cbuf . position () ;
final int chunk = Math . min ( this . bbuf . remaining () , len ) ; this . bbuf . get ( b , off , chunk ) ; off += chunk ; len -= chunk ; bytesRead += chunk ; MST[rv.AOR2Mutator]MSP[N] } else { fillBuffer () ;
while ( n > 0 && available () > 0 ) { this . read () ; n -- ; skipped ++ ; MST[rv.UOI3Mutator]MSP[N] } return skipped ; } @Override public int available () throws IOException {
while ( n > 0 && available () > 0 ) { MST[rv.ROR3Mutator]MSP[N] this . read () ; n -- ; skipped ++ ; } return skipped ; } @Override public int available () throws IOException {
while ( n > 0 && available () > 0 ) { this . read () ; n -- ; MST[rv.UOI1Mutator]MSP[N] skipped ++ ; } return skipped ; } @Override public int available () throws IOException {
this . bbuf . flip () ; } @Override public int read ( final byte [] b , int off , int len ) throws IOException { if ( b == null ) { MST[NegateConditionalsMutator]MSP[N] throw new NullPointerException ( lr_1 ) ; }
if ( len < 0 || ( off + len ) > b . length ) { MST[ConditionalsBoundaryMutator]MSP[N] throw new IndexOutOfBoundsException ( lr_2 + b . length + lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { return 0 ; }
while( this . cbuf . position () < this . mark_cbuf ) { this . bbuf . rewind () ; this . bbuf . limit ( 0 ) ; fillBuffer () ; } } if ( this . cbuf . position () != this . mark_cbuf ) { MST[rv.ROR2Mutator]MSP[N]
while ( n > 0 && available () > 0 ) { this . read () ; n -- ; MST[rv.AOR1Mutator]MSP[S] skipped ++ ; } return skipped ; } @Override public int available () throws IOException {
if ( len < 0 || ( off + len ) > b . length ) { MST[rv.AOD2Mutator]MSP[S] throw new IndexOutOfBoundsException ( lr_2 + b . length + lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { return 0 ; }
for (; ; ) { if ( this . bbuf . hasRemaining () ) { return this . bbuf . get () & 0xFF ; } fillBuffer () ; if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) { MST[rv.ROR3Mutator]MSP[N]
final int chunk = Math . min ( this . bbuf . remaining () , len ) ; this . bbuf . get ( b , off , chunk ) ; off += chunk ; len -= chunk ; MST[rv.UOI4Mutator]MSP[N] bytesRead += chunk ; } else { fillBuffer () ;
while( this . cbuf . position () < this . mark_cbuf ) { this . bbuf . rewind () ; this . bbuf . limit ( 0 ) ; MST[rv.CRCR1Mutator]MSP[S] fillBuffer () ; } } if ( this . cbuf . position () != this . mark_cbuf ) {
while( this . cbuf . position () < this . mark_cbuf ) { this . bbuf . rewind () ; this . bbuf . limit ( 0 ) ; MST[rv.CRCR5Mutator]MSP[S] fillBuffer () ; } } if ( this . cbuf . position () != this . mark_cbuf ) {
final int chunk = Math . min ( this . bbuf . remaining () , len ) ; MST[rv.UOI3Mutator]MSP[N] this . bbuf . get ( b , off , chunk ) ; off += chunk ; len -= chunk ; bytesRead += chunk ; } else { fillBuffer () ;
final int chunk = Math . min ( this . bbuf . remaining () , len ) ; this . bbuf . get ( b , off , chunk ) ; MST[rv.UOI1Mutator]MSP[N] off += chunk ; len -= chunk ; bytesRead += chunk ; } else { fillBuffer () ;
return EOF ; } } } @Override public int read ( final byte [] b ) throws IOException { return read ( b , 0 , b . length ) ; MST[rv.CRCR6Mutator]MSP[N] } @Override public long skip ( long n ) throws IOException { long skipped = 0 ;
while ( n > 0 && available () > 0 ) { this . read () ; n -- ; MST[rv.UOI4Mutator]MSP[N] skipped ++ ; } return skipped ; } @Override public int available () throws IOException {
if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) { MST[NonVoidMethodCallMutator]MSP[N] break; } } } return bytesRead == 0 && ! this . cbuf . hasRemaining () ? EOF : bytesRead ; } @Override public int read () throws IOException {
for (; ; ) { if ( this . bbuf . hasRemaining () ) { return this . bbuf . get () & 0xFF ; } fillBuffer () ; if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
if ( len < 0 || ( off + len ) > b . length ) { MST[rv.UOI4Mutator]MSP[N] throw new IndexOutOfBoundsException ( lr_2 + b . length + lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { return 0 ; }
if ( len < 0 || ( off + len ) > b . length ) { MST[rv.UOI1Mutator]MSP[N] throw new IndexOutOfBoundsException ( lr_2 + b . length + lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { return 0 ; }
final int chunk = Math . min ( this . bbuf . remaining () , len ) ; this . bbuf . get ( b , off , chunk ) ; off += chunk ; len -= chunk ; MST[rv.AOR3Mutator]MSP[N] bytesRead += chunk ; } else { fillBuffer () ;
while ( n > 0 && available () > 0 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] this . read () ; n -- ; skipped ++ ; } return skipped ; } @Override public int available () throws IOException {
while ( n > 0 && available () > 0 ) { MST[NegateConditionalsMutator]MSP[N] this . read () ; n -- ; skipped ++ ; } return skipped ; } @Override public int available () throws IOException {
if ( len < 0 || ( off + len ) > b . length ) { throw new IndexOutOfBoundsException ( lr_2 + b . length + MST[experimental.NakedReceiverMutator]MSP[N] lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { return 0 ; }
throw new IllegalStateException ( lr_5 + cbuf . position () + lr_6 + lr_7 + this . mark_cbuf ) ; } this . bbuf . position ( this . mark_bbuf ) ; this . mark_cbuf = NO_MARK ; this . mark_bbuf = NO_MARK ; MST[InlineConstantMutator]MSP[N] } } @Override
this . mark_bbuf = this . bbuf . position () ; this . cbuf . mark () ; this . bbuf . mark () ; } @Override public synchronized void reset () throws IOException { if ( this . mark_cbuf != NO_MARK ) { MST[rv.ABSMutator]MSP[N]
this . mark_bbuf = this . bbuf . position () ; this . cbuf . mark () ; this . bbuf . mark () ; } @Override public synchronized void reset () throws IOException { if ( this . mark_cbuf != NO_MARK ) { MST[rv.ROR1Mutator]MSP[N]
this . mark_bbuf = this . bbuf . position () ; this . cbuf . mark () ; this . bbuf . mark () ; } @Override public synchronized void reset () throws IOException { if ( this . mark_cbuf != NO_MARK ) { MST[rv.ROR5Mutator]MSP[N]
for (; ; ) { if ( this . bbuf . hasRemaining () ) { return this . bbuf . get () & 0xFF ; MST[rv.CRCR6Mutator]MSP[S] } fillBuffer () ; if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) {
for (; ; ) { if ( this . bbuf . hasRemaining () ) { return this . bbuf . get () & 0xFF ; MST[rv.CRCR2Mutator]MSP[N] } fillBuffer () ; if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) {
throw new IllegalStateException ( lr_5 + cbuf . position () + lr_6 + lr_7 + this . mark_cbuf ) ; } this . bbuf . position ( this . mark_bbuf ) ; this . mark_cbuf = NO_MARK ; MST[rv.CRCR5Mutator]MSP[N] this . mark_bbuf = NO_MARK ; } } @Override
this . mark_bbuf = this . bbuf . position () ; this . cbuf . mark () ; this . bbuf . mark () ; } @Override public synchronized void reset () throws IOException { if ( this . mark_cbuf != NO_MARK ) { MST[rv.UOI2Mutator]MSP[N]
while ( n > 0 && available () > 0 ) { this . read () ; n -- ; MST[rv.CRCR6Mutator]MSP[S] skipped ++ ; } return skipped ; } @Override public int available () throws IOException {
final int chunk = Math . min ( this . bbuf . remaining () , len ) ; this . bbuf . get ( b , off , chunk ) ; off += chunk ; len -= chunk ; bytesRead += chunk ; MST[rv.UOI2Mutator]MSP[N] } else { fillBuffer () ;
while ( n > 0 && available () > 0 ) { this . read () ; n -- ; MST[rv.CRCR2Mutator]MSP[S] skipped ++ ; } return skipped ; } @Override public int available () throws IOException {
if ( len < 0 || ( off + len ) > b . length ) { throw new IndexOutOfBoundsException ( lr_2 + b . length + MST[rv.UOI3Mutator]MSP[N] lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { return 0 ; }
final int chunk = Math . min ( this . bbuf . remaining () , len ) ; this . bbuf . get ( b , off , chunk ) ; off += chunk ; len -= chunk ; MST[rv.ABSMutator]MSP[N] bytesRead += chunk ; } else { fillBuffer () ;
throw new IllegalStateException ( lr_5 + cbuf . position () + lr_6 + lr_7 + this . mark_cbuf ) ; } this . bbuf . position ( this . mark_bbuf ) ; this . mark_cbuf = NO_MARK ; MST[rv.CRCR1Mutator]MSP[N] this . mark_bbuf = NO_MARK ; } } @Override
final int chunk = Math . min ( this . bbuf . remaining () , len ) ; this . bbuf . get ( b , off , chunk ) ; off += chunk ; MST[rv.UOI3Mutator]MSP[N] len -= chunk ; bytesRead += chunk ; } else { fillBuffer () ;
if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) { return EOF ; } int bytesRead = 0 ; MST[rv.CRCR3Mutator]MSP[N] while ( len > 0 ) { if ( this . bbuf . hasRemaining () ) {
while ( n > 0 && available () > 0 ) { this . read () ; n -- ; skipped ++ ; MST[rv.CRCR4Mutator]MSP[N] } return skipped ; } @Override public int available () throws IOException {
if ( len < 0 || ( off + len ) > b . length ) { MST[rv.AOR4Mutator]MSP[N] throw new IndexOutOfBoundsException ( lr_2 + b . length + lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { return 0 ; }
final int chunk = Math . min ( this . bbuf . remaining () , len ) ; this . bbuf . get ( b , off , chunk ) ; off += chunk ; len -= chunk ; MST[rv.UOI4Mutator]MSP[N] bytesRead += chunk ; } else { fillBuffer () ;
if ( len < 0 || ( off + len ) > b . length ) { throw new IndexOutOfBoundsException ( lr_2 + b . length + MST[NonVoidMethodCallMutator]MSP[S] lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { return 0 ; }
if ( len < 0 || ( off + len ) > b . length ) { throw new IndexOutOfBoundsException ( lr_2 + b . length + MST[rv.UOI2Mutator]MSP[N] lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { return 0 ; }
final int chunk = Math . min ( this . bbuf . remaining () , len ) ; this . bbuf . get ( b , off , chunk ) ; MST[rv.UOI1Mutator]MSP[N] off += chunk ; len -= chunk ; bytesRead += chunk ; } else { fillBuffer () ;
if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) { break; } } } return bytesRead == 0 && ! this . cbuf . hasRemaining () ? EOF : bytesRead ; MST[rv.UOI3Mutator]MSP[N] } @Override public int read () throws IOException {
while ( n > 0 && available () > 0 ) { MST[rv.CRCR1Mutator]MSP[S] this . read () ; n -- ; skipped ++ ; } return skipped ; } @Override public int available () throws IOException {
this . mark_bbuf = this . bbuf . position () ; MST[NonVoidMethodCallMutator]MSP[S] this . cbuf . mark () ; this . bbuf . mark () ; } @Override public synchronized void reset () throws IOException { if ( this . mark_cbuf != NO_MARK ) {
if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) { break; } } } return bytesRead == 0 && ! this . cbuf . hasRemaining () ? EOF : bytesRead ; MST[rv.UOI4Mutator]MSP[N] } @Override public int read () throws IOException {
final int chunk = Math . min ( this . bbuf . remaining () , len ) ; MST[ArgumentPropagationMutator]MSP[N] this . bbuf . get ( b , off , chunk ) ; off += chunk ; len -= chunk ; bytesRead += chunk ; } else { fillBuffer () ;
while ( n > 0 && available () > 0 ) { MST[rv.ROR5Mutator]MSP[N] this . read () ; n -- ; skipped ++ ; } return skipped ; } @Override public int available () throws IOException {
while ( n > 0 && available () > 0 ) { MST[rv.ROR4Mutator]MSP[S] this . read () ; n -- ; skipped ++ ; } return skipped ; } @Override public int available () throws IOException {
if ( len < 0 || ( off + len ) > b . length ) { MST[NegateConditionalsMutator]MSP[N] throw new IndexOutOfBoundsException ( lr_2 + b . length + lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { return 0 ; }
public boolean markSupported () { return true ; MST[rv.CRCR3Mutator]MSP[N] }
if ( len < 0 || ( off + len ) > b . length ) { MST[rv.ABSMutator]MSP[N] throw new IndexOutOfBoundsException ( lr_2 + b . length + lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { return 0 ; }
while ( n > 0 && available () > 0 ) { this . read () ; n -- ; skipped ++ ; MST[rv.UOI1Mutator]MSP[N] } return skipped ; } @Override public int available () throws IOException {
while( this . cbuf . position () < this . mark_cbuf ) { this . bbuf . rewind () ; this . bbuf . limit ( 0 ) ; fillBuffer () ; } } if ( this . cbuf . position () != this . mark_cbuf ) { MST[NonVoidMethodCallMutator]MSP[N]
if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) { MST[rv.ROR5Mutator]MSP[N] return EOF ; } int bytesRead = 0 ; while ( len > 0 ) { if ( this . bbuf . hasRemaining () ) {
if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) { MST[rv.ROR1Mutator]MSP[N] return EOF ; } int bytesRead = 0 ; while ( len > 0 ) { if ( this . bbuf . hasRemaining () ) {
final int chunk = Math . min ( this . bbuf . remaining () , len ) ; this . bbuf . get ( b , off , chunk ) ; off += chunk ; MST[MathMutator]MSP[N] len -= chunk ; bytesRead += chunk ; } else { fillBuffer () ;
while ( n > 0 && available () > 0 ) { this . read () ; n -- ; skipped ++ ; } return skipped ; MST[rv.ABSMutator]MSP[N] } @Override public int available () throws IOException {
final int chunk = Math . min ( this . bbuf . remaining () , len ) ; this . bbuf . get ( b , off , chunk ) ; off += chunk ; len -= chunk ; bytesRead += chunk ; MST[rv.UOI1Mutator]MSP[N] } else { fillBuffer () ;
final int chunk = Math . min ( this . bbuf . remaining () , len ) ; this . bbuf . get ( b , off , chunk ) ; off += chunk ; MST[rv.UOI2Mutator]MSP[N] len -= chunk ; bytesRead += chunk ; } else { fillBuffer () ;
this . bbuf . flip () ; } @Override public int read ( final byte [] b , int off , int len ) throws IOException { if ( b == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] throw new NullPointerException ( lr_1 ) ; }
while ( n > 0 && available () > 0 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] this . read () ; n -- ; skipped ++ ; } return skipped ; } @Override public int available () throws IOException {
private void fillBuffer () throws CharacterCodingException { this . bbuf . compact () ; final CoderResult result = this . encoder . encode ( this . cbuf , this . bbuf , true ) ; MST[rv.CRCR3Mutator]MSP[N] if ( result . isError () ) { result . throwException () ; }
throw new IllegalStateException ( lr_5 + cbuf . position () + lr_6 + lr_7 + this . mark_cbuf ) ; } this . bbuf . position ( this . mark_bbuf ) ; this . mark_cbuf = NO_MARK ; this . mark_bbuf = NO_MARK ; MST[rv.CRCR2Mutator]MSP[N] } } @Override
if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) { break; } } } return bytesRead == 0 && ! this . cbuf . hasRemaining () ? EOF : bytesRead ; MST[rv.ROR2Mutator]MSP[N] } @Override public int read () throws IOException {
if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) { break; } } } return bytesRead == 0 && ! this . cbuf . hasRemaining () ? EOF : bytesRead ; MST[rv.ROR1Mutator]MSP[N] } @Override public int read () throws IOException {
this . mark_bbuf = this . bbuf . position () ; MST[experimental.MemberVariableMutator]MSP[N] this . cbuf . mark () ; this . bbuf . mark () ; } @Override public synchronized void reset () throws IOException { if ( this . mark_cbuf != NO_MARK ) {
throw new IllegalStateException ( lr_5 + cbuf . position () + lr_6 + lr_7 + this . mark_cbuf ) ; } this . bbuf . position ( this . mark_bbuf ) ; MST[NonVoidMethodCallMutator]MSP[S] this . mark_cbuf = NO_MARK ; this . mark_bbuf = NO_MARK ; } } @Override
throw new IllegalStateException ( lr_5 + cbuf . position () + lr_6 + lr_7 + this . mark_cbuf ) ; } this . bbuf . position ( this . mark_bbuf ) ; MST[rv.UOI2Mutator]MSP[N] this . mark_cbuf = NO_MARK ; this . mark_bbuf = NO_MARK ; } } @Override
while ( n > 0 && available () > 0 ) { this . read () ; n -- ; skipped ++ ; MST[MathMutator]MSP[N] } return skipped ; } @Override public int available () throws IOException {
if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) { MST[rv.ROR2Mutator]MSP[N] return EOF ; } int bytesRead = 0 ; while ( len > 0 ) { if ( this . bbuf . hasRemaining () ) {
throw new IllegalStateException ( lr_5 + cbuf . position () + lr_6 + lr_7 + this . mark_cbuf ) ; } this . bbuf . position ( this . mark_bbuf ) ; MST[rv.UOI3Mutator]MSP[N] this . mark_cbuf = NO_MARK ; this . mark_bbuf = NO_MARK ; } } @Override
return EOF ; } } } @Override public int read ( final byte [] b ) throws IOException { return read ( b , 0 , b . length ) ; } @Override public long skip ( long n ) throws IOException { long skipped = 0 ; MST[rv.CRCR5Mutator]MSP[N]
while ( n > 0 && available () > 0 ) { this . read () ; n -- ; skipped ++ ; MST[rv.AOR2Mutator]MSP[N] } return skipped ; } @Override public int available () throws IOException {
if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) { return EOF ; } int bytesRead = 0 ; MST[InlineConstantMutator]MSP[N] while ( len > 0 ) { if ( this . bbuf . hasRemaining () ) {
for (; ; ) { if ( this . bbuf . hasRemaining () ) { MST[rv.ROR1Mutator]MSP[N] return this . bbuf . get () & 0xFF ; } fillBuffer () ; if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) {
public boolean markSupported () { return true ; MST[rv.CRCR4Mutator]MSP[N] }
this . mark_bbuf = this . bbuf . position () ; this . cbuf . mark () ; this . bbuf . mark () ; } @Override public synchronized void reset () throws IOException { if ( this . mark_cbuf != NO_MARK ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
while ( n > 0 && available () > 0 ) { this . read () ; n -- ; skipped ++ ; } return skipped ; MST[rv.UOI4Mutator]MSP[N] } @Override public int available () throws IOException {
if ( len < 0 || ( off + len ) > b . length ) { MST[rv.ROR1Mutator]MSP[N] throw new IndexOutOfBoundsException ( lr_2 + b . length + lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { return 0 ; }
if ( len < 0 || ( off + len ) > b . length ) { throw new IndexOutOfBoundsException ( lr_2 + b . length + MST[NonVoidMethodCallMutator]MSP[S] lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { return 0 ; }
if ( len < 0 || ( off + len ) > b . length ) { throw new IndexOutOfBoundsException ( lr_2 + b . length + MST[experimental.NakedReceiverMutator]MSP[N] lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { return 0 ; }
final int chunk = Math . min ( this . bbuf . remaining () , len ) ; this . bbuf . get ( b , off , chunk ) ; MST[experimental.NakedReceiverMutator]MSP[N] off += chunk ; len -= chunk ; bytesRead += chunk ; } else { fillBuffer () ;
final int chunk = Math . min ( this . bbuf . remaining () , len ) ; this . bbuf . get ( b , off , chunk ) ; off += chunk ; len -= chunk ; bytesRead += chunk ; MST[rv.AOR1Mutator]MSP[N] } else { fillBuffer () ;
while ( n > 0 && available () > 0 ) { this . read () ; n -- ; skipped ++ ; MST[rv.UOI2Mutator]MSP[N] } return skipped ; } @Override public int available () throws IOException {
if ( this . cbuf . position () != 0 ) { this . encoder . reset () ; this . cbuf . rewind () ; this . bbuf . rewind () ; this . bbuf . limit ( 0 ) ; MST[rv.CRCR3Mutator]MSP[N]
while ( n > 0 && available () > 0 ) { MST[NonVoidMethodCallMutator]MSP[N] this . read () ; n -- ; skipped ++ ; } return skipped ; } @Override public int available () throws IOException {
while( this . cbuf . position () < this . mark_cbuf ) { this . bbuf . rewind () ; this . bbuf . limit ( 0 ) ; fillBuffer () ; } } if ( this . cbuf . position () != this . mark_cbuf ) { MST[rv.UOI4Mutator]MSP[N]
while( this . cbuf . position () < this . mark_cbuf ) { this . bbuf . rewind () ; this . bbuf . limit ( 0 ) ; fillBuffer () ; } } if ( this . cbuf . position () != this . mark_cbuf ) { MST[rv.ROR1Mutator]MSP[N]
while ( n > 0 && available () > 0 ) { this . read () ; n -- ; MST[rv.AOD2Mutator]MSP[S] skipped ++ ; } return skipped ; } @Override public int available () throws IOException {
return this . bbuf . remaining () + this . cbuf . remaining () ; MST[rv.AOR1Mutator]MSP[N] } @Override public void close () throws IOException { } @Override public synchronized void mark ( final int readlimit ) { this . mark_cbuf = this . cbuf . position () ;
if ( len < 0 || ( off + len ) > b . length ) { throw new IndexOutOfBoundsException ( lr_2 + b . length + MST[NonVoidMethodCallMutator]MSP[S] lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { return 0 ; }
if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] break; } } } return bytesRead == 0 && ! this . cbuf . hasRemaining () ? EOF : bytesRead ; } @Override public int read () throws IOException {
if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return EOF ; } int bytesRead = 0 ; while ( len > 0 ) { if ( this . bbuf . hasRemaining () ) {
while ( n > 0 && available () > 0 ) { this . read () ; n -- ; skipped ++ ; MST[rv.CRCR3Mutator]MSP[N] } return skipped ; } @Override public int available () throws IOException {
for (; ; ) { if ( this . bbuf . hasRemaining () ) { return this . bbuf . get () & 0xFF ; MST[rv.OBBN2Mutator]MSP[S] } fillBuffer () ; if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) {
if ( len < 0 || ( off + len ) > b . length ) { MST[rv.ROR3Mutator]MSP[N] throw new IndexOutOfBoundsException ( lr_2 + b . length + lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { return 0 ; }
if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) { break; } } } return bytesRead == 0 && ! this . cbuf . hasRemaining () ? EOF : bytesRead ; MST[PrimitiveReturnsMutator]MSP[N] } @Override public int read () throws IOException {
if ( this . cbuf . position () != 0 ) { this . encoder . reset () ; this . cbuf . rewind () ; this . bbuf . rewind () ; this . bbuf . limit ( 0 ) ; MST[NonVoidMethodCallMutator]MSP[N]
if ( len < 0 || ( off + len ) > b . length ) { throw new IndexOutOfBoundsException ( lr_2 + b . length + MST[rv.UOI1Mutator]MSP[N] lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { return 0 ; }
this . mark_bbuf = this . bbuf . position () ; this . cbuf . mark () ; this . bbuf . mark () ; } @Override public synchronized void reset () throws IOException { if ( this . mark_cbuf != NO_MARK ) { MST[rv.CRCR4Mutator]MSP[N]
final int chunk = Math . min ( this . bbuf . remaining () , len ) ; this . bbuf . get ( b , off , chunk ) ; off += chunk ; len -= chunk ; MST[rv.AOD1Mutator]MSP[N] bytesRead += chunk ; } else { fillBuffer () ;
public boolean markSupported () { return true ; MST[BooleanFalseReturnValsMutator]MSP[N] }
if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) { MST[rv.ROR3Mutator]MSP[N] break; } } } return bytesRead == 0 && ! this . cbuf . hasRemaining () ? EOF : bytesRead ; } @Override public int read () throws IOException {
while ( n > 0 && available () > 0 ) { this . read () ; n -- ; skipped ++ ; MST[InlineConstantMutator]MSP[N] } return skipped ; } @Override public int available () throws IOException {
final int chunk = Math . min ( this . bbuf . remaining () , len ) ; this . bbuf . get ( b , off , chunk ) ; off += chunk ; len -= chunk ; MST[rv.AOR4Mutator]MSP[S] bytesRead += chunk ; } else { fillBuffer () ;
while ( n > 0 && available () > 0 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] this . read () ; n -- ; skipped ++ ; } return skipped ; } @Override public int available () throws IOException {
final int chunk = Math . min ( this . bbuf . remaining () , len ) ; this . bbuf . get ( b , off , chunk ) ; off += chunk ; MST[rv.AOR2Mutator]MSP[S] len -= chunk ; bytesRead += chunk ; } else { fillBuffer () ;
if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) { return EOF ; } int bytesRead = 0 ; while ( len > 0 ) { MST[rv.UOI4Mutator]MSP[N] if ( this . bbuf . hasRemaining () ) {
while( this . cbuf . position () < this . mark_cbuf ) { this . bbuf . rewind () ; this . bbuf . limit ( 0 ) ; fillBuffer () ; } } if ( this . cbuf . position () != this . mark_cbuf ) { MST[rv.ABSMutator]MSP[N]
final int chunk = Math . min ( this . bbuf . remaining () , len ) ; this . bbuf . get ( b , off , chunk ) ; off += chunk ; len -= chunk ; bytesRead += chunk ; MST[rv.UOI1Mutator]MSP[N] } else { fillBuffer () ;
if ( this . cbuf . position () != 0 ) { MST[rv.ROR2Mutator]MSP[N] this . encoder . reset () ; this . cbuf . rewind () ; this . bbuf . rewind () ; this . bbuf . limit ( 0 ) ;
while ( n > 0 && available () > 0 ) { this . read () ; n -- ; skipped ++ ; } return skipped ; MST[ReturnValsMutator]MSP[N] } @Override public int available () throws IOException {
if ( len < 0 || ( off + len ) > b . length ) { MST[rv.AOD1Mutator]MSP[S] throw new IndexOutOfBoundsException ( lr_2 + b . length + lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { return 0 ; }
while( this . cbuf . position () < this . mark_cbuf ) { this . bbuf . rewind () ; MST[NonVoidMethodCallMutator]MSP[N] this . bbuf . limit ( 0 ) ; fillBuffer () ; } } if ( this . cbuf . position () != this . mark_cbuf ) {
if ( len < 0 || ( off + len ) > b . length ) { throw new IndexOutOfBoundsException ( lr_2 + b . length + lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { MST[rv.ABSMutator]MSP[N] return 0 ; }
private void fillBuffer () throws CharacterCodingException { this . bbuf . compact () ; final CoderResult result = this . encoder . encode ( this . cbuf , this . bbuf , true ) ; if ( result . isError () ) { MST[rv.ROR1Mutator]MSP[N] result . throwException () ; }
final int chunk = Math . min ( this . bbuf . remaining () , len ) ; this . bbuf . get ( b , off , chunk ) ; off += chunk ; len -= chunk ; MST[rv.UOI1Mutator]MSP[N] bytesRead += chunk ; } else { fillBuffer () ;
private void fillBuffer () throws CharacterCodingException { this . bbuf . compact () ; final CoderResult result = this . encoder . encode ( this . cbuf , this . bbuf , true ) ; if ( result . isError () ) { MST[rv.ROR5Mutator]MSP[N] result . throwException () ; }
private void fillBuffer () throws CharacterCodingException { this . bbuf . compact () ; final CoderResult result = this . encoder . encode ( this . cbuf , this . bbuf , true ) ; MST[InlineConstantMutator]MSP[N] if ( result . isError () ) { result . throwException () ; }
final int chunk = Math . min ( this . bbuf . remaining () , len ) ; this . bbuf . get ( b , off , chunk ) ; MST[rv.UOI2Mutator]MSP[N] off += chunk ; len -= chunk ; bytesRead += chunk ; } else { fillBuffer () ;
for (; ; ) { if ( this . bbuf . hasRemaining () ) { return this . bbuf . get () & 0xFF ; } fillBuffer () ; if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) { MST[rv.ROR3Mutator]MSP[N]
final int chunk = Math . min ( this . bbuf . remaining () , len ) ; MST[rv.UOI4Mutator]MSP[N] this . bbuf . get ( b , off , chunk ) ; off += chunk ; len -= chunk ; bytesRead += chunk ; } else { fillBuffer () ;
while( this . cbuf . position () < this . mark_cbuf ) { MST[rv.ROR2Mutator]MSP[N] this . bbuf . rewind () ; this . bbuf . limit ( 0 ) ; fillBuffer () ; } } if ( this . cbuf . position () != this . mark_cbuf ) {
if ( len < 0 || ( off + len ) > b . length ) { throw new IndexOutOfBoundsException ( lr_2 + b . length + lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] return 0 ; }
return EOF ; } } } @Override public int read ( final byte [] b ) throws IOException { return read ( b , 0 , b . length ) ; MST[rv.CRCR1Mutator]MSP[N] } @Override public long skip ( long n ) throws IOException { long skipped = 0 ;
return EOF ; } } } @Override public int read ( final byte [] b ) throws IOException { return read ( b , 0 , b . length ) ; MST[rv.CRCR5Mutator]MSP[N] } @Override public long skip ( long n ) throws IOException { long skipped = 0 ;
while ( n > 0 && available () > 0 ) { MST[rv.ROR5Mutator]MSP[N] this . read () ; n -- ; skipped ++ ; } return skipped ; } @Override public int available () throws IOException {
if ( this . cbuf . position () != 0 ) { this . encoder . reset () ; this . cbuf . rewind () ; this . bbuf . rewind () ; this . bbuf . limit ( 0 ) ; MST[InlineConstantMutator]MSP[N]
final int chunk = Math . min ( this . bbuf . remaining () , len ) ; this . bbuf . get ( b , off , chunk ) ; off += chunk ; len -= chunk ; bytesRead += chunk ; MST[rv.AOD2Mutator]MSP[N] } else { fillBuffer () ;
while ( n > 0 && available () > 0 ) { this . read () ; n -- ; MST[MathMutator]MSP[S] skipped ++ ; } return skipped ; } @Override public int available () throws IOException {
while ( n > 0 && available () > 0 ) { MST[rv.ROR1Mutator]MSP[N] this . read () ; n -- ; skipped ++ ; } return skipped ; } @Override public int available () throws IOException {
if ( len < 0 || ( off + len ) > b . length ) { MST[rv.ABSMutator]MSP[N] throw new IndexOutOfBoundsException ( lr_2 + b . length + lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { return 0 ; }
if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) { return EOF ; } int bytesRead = 0 ; while ( len > 0 ) { MST[rv.UOI1Mutator]MSP[N] if ( this . bbuf . hasRemaining () ) {
if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) { MST[NonVoidMethodCallMutator]MSP[S] break; } } } return bytesRead == 0 && ! this . cbuf . hasRemaining () ? EOF : bytesRead ; } @Override public int read () throws IOException {
return this . bbuf . remaining () + this . cbuf . remaining () ; MST[rv.AOR4Mutator]MSP[N] } @Override public void close () throws IOException { } @Override public synchronized void mark ( final int readlimit ) { this . mark_cbuf = this . cbuf . position () ;
return EOF ; } } } @Override public int read ( final byte [] b ) throws IOException { return read ( b , 0 , b . length ) ; } @Override public long skip ( long n ) throws IOException { long skipped = 0 ; MST[InlineConstantMutator]MSP[N]
if ( len < 0 || ( off + len ) > b . length ) { throw new IndexOutOfBoundsException ( lr_2 + b . length + lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { MST[rv.ROR3Mutator]MSP[N] return 0 ; }
while ( n > 0 && available () > 0 ) { this . read () ; n -- ; MST[rv.AOR4Mutator]MSP[N] skipped ++ ; } return skipped ; } @Override public int available () throws IOException {
while ( n > 0 && available () > 0 ) { MST[rv.ROR2Mutator]MSP[N] this . read () ; n -- ; skipped ++ ; } return skipped ; } @Override public int available () throws IOException {
if ( len < 0 || ( off + len ) > b . length ) { throw new IndexOutOfBoundsException ( lr_2 + b . length + MST[experimental.NakedReceiverMutator]MSP[N] lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { return 0 ; }
return EOF ; } } } @Override public int read ( final byte [] b ) throws IOException { return read ( b , 0 , b . length ) ; MST[PrimitiveReturnsMutator]MSP[N] } @Override public long skip ( long n ) throws IOException { long skipped = 0 ;
while ( n > 0 && available () > 0 ) { this . read () ; n -- ; MST[rv.CRCR3Mutator]MSP[S] skipped ++ ; } return skipped ; } @Override public int available () throws IOException {
private void fillBuffer () throws CharacterCodingException { this . bbuf . compact () ; final CoderResult result = this . encoder . encode ( this . cbuf , this . bbuf , true ) ; if ( result . isError () ) { MST[NegateConditionalsMutator]MSP[N] result . throwException () ; }
final int chunk = Math . min ( this . bbuf . remaining () , len ) ; this . bbuf . get ( b , off , chunk ) ; off += chunk ; len -= chunk ; bytesRead += chunk ; MST[rv.UOI3Mutator]MSP[N] } else { fillBuffer () ;
private void fillBuffer () throws CharacterCodingException { this . bbuf . compact () ; final CoderResult result = this . encoder . encode ( this . cbuf , this . bbuf , true ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( result . isError () ) { result . throwException () ; }
if ( len < 0 || ( off + len ) > b . length ) { throw new IndexOutOfBoundsException ( lr_2 + b . length + MST[NonVoidMethodCallMutator]MSP[S] lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { return 0 ; }
if ( len < 0 || ( off + len ) > b . length ) { MST[rv.AOR3Mutator]MSP[N] throw new IndexOutOfBoundsException ( lr_2 + b . length + lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { return 0 ; }
if ( len < 0 || ( off + len ) > b . length ) { throw new IndexOutOfBoundsException ( lr_2 + b . length + lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { MST[rv.UOI2Mutator]MSP[N] return 0 ; }
final int chunk = Math . min ( this . bbuf . remaining () , len ) ; this . bbuf . get ( b , off , chunk ) ; off += chunk ; len -= chunk ; MST[rv.UOI1Mutator]MSP[N] bytesRead += chunk ; } else { fillBuffer () ;
while ( n > 0 && available () > 0 ) { this . read () ; n -- ; skipped ++ ; MST[rv.CRCR5Mutator]MSP[N] } return skipped ; } @Override public int available () throws IOException {
while ( n > 0 && available () > 0 ) { this . read () ; n -- ; skipped ++ ; } return skipped ; MST[rv.UOI2Mutator]MSP[N] } @Override public int available () throws IOException {
if ( len < 0 || ( off + len ) > b . length ) { MST[rv.ROR4Mutator]MSP[N] throw new IndexOutOfBoundsException ( lr_2 + b . length + lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { return 0 ; }
if ( len < 0 || ( off + len ) > b . length ) { throw new IndexOutOfBoundsException ( lr_2 + b . length + MST[rv.UOI3Mutator]MSP[N] lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { return 0 ; }
return this . bbuf . remaining () + this . cbuf . remaining () ; MST[MathMutator]MSP[N] } @Override public void close () throws IOException { } @Override public synchronized void mark ( final int readlimit ) { this . mark_cbuf = this . cbuf . position () ;
final int chunk = Math . min ( this . bbuf . remaining () , len ) ; this . bbuf . get ( b , off , chunk ) ; MST[rv.ABSMutator]MSP[N] off += chunk ; len -= chunk ; bytesRead += chunk ; } else { fillBuffer () ;
if ( this . cbuf . position () != 0 ) { this . encoder . reset () ; MST[NonVoidMethodCallMutator]MSP[N] this . cbuf . rewind () ; this . bbuf . rewind () ; this . bbuf . limit ( 0 ) ;
if ( len < 0 || ( off + len ) > b . length ) { MST[ConditionalsBoundaryMutator]MSP[N] throw new IndexOutOfBoundsException ( lr_2 + b . length + lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { return 0 ; }
if ( len < 0 || ( off + len ) > b . length ) { throw new IndexOutOfBoundsException ( lr_2 + b . length + lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { return 0 ; MST[rv.CRCR3Mutator]MSP[N] }
this . mark_bbuf = this . bbuf . position () ; this . cbuf . mark () ; this . bbuf . mark () ; MST[NonVoidMethodCallMutator]MSP[N] } @Override public synchronized void reset () throws IOException { if ( this . mark_cbuf != NO_MARK ) {
while ( n > 0 && available () > 0 ) { this . read () ; n -- ; skipped ++ ; MST[rv.AOR1Mutator]MSP[N] } return skipped ; } @Override public int available () throws IOException {
return EOF ; } } } @Override public int read ( final byte [] b ) throws IOException { return read ( b , 0 , b . length ) ; } @Override public long skip ( long n ) throws IOException { long skipped = 0 ; MST[rv.CRCR6Mutator]MSP[N]
return this . bbuf . remaining () + this . cbuf . remaining () ; MST[NonVoidMethodCallMutator]MSP[N] } @Override public void close () throws IOException { } @Override public synchronized void mark ( final int readlimit ) { this . mark_cbuf = this . cbuf . position () ;
if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) { MST[rv.ROR1Mutator]MSP[N] break; } } } return bytesRead == 0 && ! this . cbuf . hasRemaining () ? EOF : bytesRead ; } @Override public int read () throws IOException {
if ( len < 0 || ( off + len ) > b . length ) { MST[rv.UOI2Mutator]MSP[N] throw new IndexOutOfBoundsException ( lr_2 + b . length + lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { return 0 ; }
final int chunk = Math . min ( this . bbuf . remaining () , len ) ; this . bbuf . get ( b , off , chunk ) ; off += chunk ; len -= chunk ; MST[rv.AOR2Mutator]MSP[N] bytesRead += chunk ; } else { fillBuffer () ;
if ( len < 0 || ( off + len ) > b . length ) { MST[rv.UOI1Mutator]MSP[N] throw new IndexOutOfBoundsException ( lr_2 + b . length + lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { return 0 ; }
while ( n > 0 && available () > 0 ) { MST[NegateConditionalsMutator]MSP[N] this . read () ; n -- ; skipped ++ ; } return skipped ; } @Override public int available () throws IOException {
if ( len < 0 || ( off + len ) > b . length ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] throw new IndexOutOfBoundsException ( lr_2 + b . length + lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { return 0 ; }
if ( len < 0 || ( off + len ) > b . length ) { MST[rv.ROR2Mutator]MSP[N] throw new IndexOutOfBoundsException ( lr_2 + b . length + lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { return 0 ; }
final int chunk = Math . min ( this . bbuf . remaining () , len ) ; this . bbuf . get ( b , off , chunk ) ; off += chunk ; len -= chunk ; bytesRead += chunk ; MST[rv.AOR4Mutator]MSP[N] } else { fillBuffer () ;
while( this . cbuf . position () < this . mark_cbuf ) { this . bbuf . rewind () ; this . bbuf . limit ( 0 ) ; fillBuffer () ; } } if ( this . cbuf . position () != this . mark_cbuf ) { MST[NegateConditionalsMutator]MSP[N]
while( this . cbuf . position () < this . mark_cbuf ) { this . bbuf . rewind () ; this . bbuf . limit ( 0 ) ; fillBuffer () ; } } if ( this . cbuf . position () != this . mark_cbuf ) { MST[rv.UOI3Mutator]MSP[N]
while ( n > 0 && available () > 0 ) { this . read () ; n -- ; MST[rv.UOI3Mutator]MSP[S] skipped ++ ; } return skipped ; } @Override public int available () throws IOException {
for (; ; ) { if ( this . bbuf . hasRemaining () ) { return this . bbuf . get () & 0xFF ; } fillBuffer () ; if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) { MST[NonVoidMethodCallMutator]MSP[N]
if ( len < 0 || ( off + len ) > b . length ) { throw new IndexOutOfBoundsException ( lr_2 + b . length + lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { return 0 ; MST[InlineConstantMutator]MSP[N] }
this . mark_bbuf = this . bbuf . position () ; this . cbuf . mark () ; this . bbuf . mark () ; } @Override public synchronized void reset () throws IOException { if ( this . mark_cbuf != NO_MARK ) { MST[NegateConditionalsMutator]MSP[N]
final int chunk = Math . min ( this . bbuf . remaining () , len ) ; this . bbuf . get ( b , off , chunk ) ; off += chunk ; len -= chunk ; bytesRead += chunk ; MST[rv.UOI2Mutator]MSP[N] } else { fillBuffer () ;
final int chunk = Math . min ( this . bbuf . remaining () , len ) ; this . bbuf . get ( b , off , chunk ) ; off += chunk ; MST[rv.UOI3Mutator]MSP[N] len -= chunk ; bytesRead += chunk ; } else { fillBuffer () ;
final int chunk = Math . min ( this . bbuf . remaining () , len ) ; this . bbuf . get ( b , off , chunk ) ; off += chunk ; MST[rv.UOI4Mutator]MSP[N] len -= chunk ; bytesRead += chunk ; } else { fillBuffer () ;
final int chunk = Math . min ( this . bbuf . remaining () , len ) ; this . bbuf . get ( b , off , chunk ) ; off += chunk ; len -= chunk ; bytesRead += chunk ; MST[MathMutator]MSP[N] } else { fillBuffer () ;
throw new IllegalStateException ( lr_5 + cbuf . position () + lr_6 + lr_7 + this . mark_cbuf ) ; } this . bbuf . position ( this . mark_bbuf ) ; this . mark_cbuf = NO_MARK ; this . mark_bbuf = NO_MARK ; MST[rv.CRCR1Mutator]MSP[N] } } @Override
final int chunk = Math . min ( this . bbuf . remaining () , len ) ; this . bbuf . get ( b , off , chunk ) ; off += chunk ; len -= chunk ; MST[rv.ABSMutator]MSP[N] bytesRead += chunk ; } else { fillBuffer () ;
throw new IllegalStateException ( lr_5 + cbuf . position () + lr_6 + lr_7 + this . mark_cbuf ) ; } this . bbuf . position ( this . mark_bbuf ) ; this . mark_cbuf = NO_MARK ; this . mark_bbuf = NO_MARK ; MST[rv.CRCR6Mutator]MSP[N] } } @Override
if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) { break; } } } return bytesRead == 0 && ! this . cbuf . hasRemaining () ? EOF : bytesRead ; MST[ReturnValsMutator]MSP[N] } @Override public int read () throws IOException {
private void fillBuffer () throws CharacterCodingException { this . bbuf . compact () ; final CoderResult result = this . encoder . encode ( this . cbuf , this . bbuf , true ) ; MST[rv.CRCR2Mutator]MSP[N] if ( result . isError () ) { result . throwException () ; }
if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) { break; } } } return bytesRead == 0 && ! this . cbuf . hasRemaining () ? EOF : bytesRead ; MST[rv.ROR3Mutator]MSP[N] } @Override public int read () throws IOException {
return this . bbuf . remaining () + this . cbuf . remaining () ; MST[NonVoidMethodCallMutator]MSP[N] } @Override public void close () throws IOException { } @Override public synchronized void mark ( final int readlimit ) { this . mark_cbuf = this . cbuf . position () ;
final int chunk = Math . min ( this . bbuf . remaining () , len ) ; this . bbuf . get ( b , off , chunk ) ; off += chunk ; MST[rv.AOR1Mutator]MSP[N] len -= chunk ; bytesRead += chunk ; } else { fillBuffer () ;
if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) { break; } } } return bytesRead == 0 && ! this . cbuf . hasRemaining () ? EOF : bytesRead ; MST[rv.UOI1Mutator]MSP[N] } @Override public int read () throws IOException {
for (; ; ) { if ( this . bbuf . hasRemaining () ) { return this . bbuf . get () & 0xFF ; MST[rv.OBBN1Mutator]MSP[N] } fillBuffer () ; if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) {
if ( len < 0 || ( off + len ) > b . length ) { MST[rv.ROR3Mutator]MSP[N] throw new IndexOutOfBoundsException ( lr_2 + b . length + lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { return 0 ; }
if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) { break; } } } return bytesRead == 0 && ! this . cbuf . hasRemaining () ? EOF : bytesRead ; MST[rv.ABSMutator]MSP[N] } @Override public int read () throws IOException {
if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] break; } } } return bytesRead == 0 && ! this . cbuf . hasRemaining () ? EOF : bytesRead ; } @Override public int read () throws IOException {
public boolean markSupported () { return true ; MST[ReturnValsMutator]MSP[N] }
while ( n > 0 && available () > 0 ) { MST[rv.UOI4Mutator]MSP[N] this . read () ; n -- ; skipped ++ ; } return skipped ; } @Override public int available () throws IOException {
return EOF ; } } } @Override public int read ( final byte [] b ) throws IOException { return read ( b , 0 , b . length ) ; MST[NonVoidMethodCallMutator]MSP[N] } @Override public long skip ( long n ) throws IOException { long skipped = 0 ;
if ( this . cbuf . position () != 0 ) { MST[rv.ROR1Mutator]MSP[N] this . encoder . reset () ; this . cbuf . rewind () ; this . bbuf . rewind () ; this . bbuf . limit ( 0 ) ;
if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) { MST[rv.ROR2Mutator]MSP[N] return EOF ; } int bytesRead = 0 ; while ( len > 0 ) { if ( this . bbuf . hasRemaining () ) {
while( this . cbuf . position () < this . mark_cbuf ) { this . bbuf . rewind () ; this . bbuf . limit ( 0 ) ; fillBuffer () ; } } if ( this . cbuf . position () != this . mark_cbuf ) { MST[rv.ROR5Mutator]MSP[N]
this . mark_bbuf = this . bbuf . position () ; this . cbuf . mark () ; this . bbuf . mark () ; } @Override public synchronized void reset () throws IOException { if ( this . mark_cbuf != NO_MARK ) { MST[InlineConstantMutator]MSP[N]
throw new IllegalStateException ( lr_5 + cbuf . position () + lr_6 + lr_7 + this . mark_cbuf ) ; } this . bbuf . position ( this . mark_bbuf ) ; this . mark_cbuf = NO_MARK ; MST[rv.CRCR4Mutator]MSP[N] this . mark_bbuf = NO_MARK ; } } @Override
if ( this . cbuf . position () != 0 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] this . encoder . reset () ; this . cbuf . rewind () ; this . bbuf . rewind () ; this . bbuf . limit ( 0 ) ;
throw new IllegalStateException ( lr_5 + cbuf . position () + lr_6 + lr_7 + this . mark_cbuf ) ; } this . bbuf . position ( this . mark_bbuf ) ; this . mark_cbuf = NO_MARK ; this . mark_bbuf = NO_MARK ; MST[experimental.MemberVariableMutator]MSP[N] } } @Override
if ( this . cbuf . position () != 0 ) { this . encoder . reset () ; MST[experimental.NakedReceiverMutator]MSP[N] this . cbuf . rewind () ; this . bbuf . rewind () ; this . bbuf . limit ( 0 ) ;
if ( len < 0 || ( off + len ) > b . length ) { throw new IndexOutOfBoundsException ( lr_2 + b . length + MST[rv.UOI4Mutator]MSP[N] lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { return 0 ; }
if ( len < 0 || ( off + len ) > b . length ) { throw new IndexOutOfBoundsException ( lr_2 + b . length + MST[NonVoidMethodCallMutator]MSP[S] lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { return 0 ; }
if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return EOF ; } int bytesRead = 0 ; while ( len > 0 ) { if ( this . bbuf . hasRemaining () ) {
final int chunk = Math . min ( this . bbuf . remaining () , len ) ; this . bbuf . get ( b , off , chunk ) ; off += chunk ; MST[rv.UOI4Mutator]MSP[N] len -= chunk ; bytesRead += chunk ; } else { fillBuffer () ;
if ( len < 0 || ( off + len ) > b . length ) { throw new IndexOutOfBoundsException ( lr_2 + b . length + lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { MST[rv.UOI1Mutator]MSP[N] return 0 ; }
final int chunk = Math . min ( this . bbuf . remaining () , len ) ; this . bbuf . get ( b , off , chunk ) ; MST[NonVoidMethodCallMutator]MSP[N] off += chunk ; len -= chunk ; bytesRead += chunk ; } else { fillBuffer () ;
while ( n > 0 && available () > 0 ) { this . read () ; n -- ; skipped ++ ; } return skipped ; MST[rv.UOI3Mutator]MSP[N] } @Override public int available () throws IOException {
final int chunk = Math . min ( this . bbuf . remaining () , len ) ; this . bbuf . get ( b , off , chunk ) ; MST[rv.UOI2Mutator]MSP[N] off += chunk ; len -= chunk ; bytesRead += chunk ; } else { fillBuffer () ;
while ( n > 0 && available () > 0 ) { MST[rv.CRCR3Mutator]MSP[N] this . read () ; n -- ; skipped ++ ; } return skipped ; } @Override public int available () throws IOException {
throw new IllegalStateException ( lr_5 + cbuf . position () + lr_6 + lr_7 + this . mark_cbuf ) ; } this . bbuf . position ( this . mark_bbuf ) ; MST[rv.ABSMutator]MSP[N] this . mark_cbuf = NO_MARK ; this . mark_bbuf = NO_MARK ; } } @Override
if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) { break; } } } return bytesRead == 0 && ! this . cbuf . hasRemaining () ? EOF : bytesRead ; MST[rv.UOI4Mutator]MSP[N] } @Override public int read () throws IOException {
while( this . cbuf . position () < this . mark_cbuf ) { MST[rv.UOI4Mutator]MSP[N] this . bbuf . rewind () ; this . bbuf . limit ( 0 ) ; fillBuffer () ; } } if ( this . cbuf . position () != this . mark_cbuf ) {
public boolean markSupported () { return true ; MST[rv.CRCR5Mutator]MSP[N] }
for (; ; ) { if ( this . bbuf . hasRemaining () ) { return this . bbuf . get () & 0xFF ; MST[InlineConstantMutator]MSP[N] } fillBuffer () ; if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) {
while ( n > 0 && available () > 0 ) { this . read () ; n -- ; skipped ++ ; } return skipped ; MST[PrimitiveReturnsMutator]MSP[N] } @Override public int available () throws IOException {
while ( n > 0 && available () > 0 ) { MST[rv.ROR2Mutator]MSP[N] this . read () ; n -- ; skipped ++ ; } return skipped ; } @Override public int available () throws IOException {
for (; ; ) { if ( this . bbuf . hasRemaining () ) { MST[rv.ROR2Mutator]MSP[N] return this . bbuf . get () & 0xFF ; } fillBuffer () ; if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) {
if ( len < 0 || ( off + len ) > b . length ) { MST[rv.ABSMutator]MSP[S] throw new IndexOutOfBoundsException ( lr_2 + b . length + lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { return 0 ; }
if ( len < 0 || ( off + len ) > b . length ) { MST[rv.UOI1Mutator]MSP[N] throw new IndexOutOfBoundsException ( lr_2 + b . length + lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { return 0 ; }
for (; ; ) { if ( this . bbuf . hasRemaining () ) { return this . bbuf . get () & 0xFF ; MST[MathMutator]MSP[N] } fillBuffer () ; if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) {
if ( len < 0 || ( off + len ) > b . length ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] throw new IndexOutOfBoundsException ( lr_2 + b . length + lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { return 0 ; }
while ( n > 0 && available () > 0 ) { this . read () ; MST[NonVoidMethodCallMutator]MSP[S] n -- ; skipped ++ ; } return skipped ; } @Override public int available () throws IOException {
if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) { break; } } } return bytesRead == 0 && ! this . cbuf . hasRemaining () ? EOF : bytesRead ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } @Override public int read () throws IOException {
return this . bbuf . remaining () + this . cbuf . remaining () ; MST[rv.AOD2Mutator]MSP[N] } @Override public void close () throws IOException { } @Override public synchronized void mark ( final int readlimit ) { this . mark_cbuf = this . cbuf . position () ;
if ( len < 0 || ( off + len ) > b . length ) { throw new IndexOutOfBoundsException ( lr_2 + b . length + MST[experimental.NakedReceiverMutator]MSP[N] lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { return 0 ; }
if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) { MST[rv.ROR3Mutator]MSP[N] return EOF ; } int bytesRead = 0 ; while ( len > 0 ) { if ( this . bbuf . hasRemaining () ) {
this . mark_bbuf = this . bbuf . position () ; this . cbuf . mark () ; this . bbuf . mark () ; } @Override public synchronized void reset () throws IOException { if ( this . mark_cbuf != NO_MARK ) { MST[rv.ROR4Mutator]MSP[N]
for (; ; ) { if ( this . bbuf . hasRemaining () ) { return this . bbuf . get () & 0xFF ; MST[rv.CRCR3Mutator]MSP[S] } fillBuffer () ; if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) {
final int chunk = Math . min ( this . bbuf . remaining () , len ) ; this . bbuf . get ( b , off , chunk ) ; off += chunk ; len -= chunk ; MST[rv.UOI2Mutator]MSP[N] bytesRead += chunk ; } else { fillBuffer () ;
if ( len < 0 || ( off + len ) > b . length ) { throw new IndexOutOfBoundsException ( lr_2 + b . length + MST[rv.ABSMutator]MSP[N] lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { return 0 ; }
for (; ; ) { if ( this . bbuf . hasRemaining () ) { return this . bbuf . get () & 0xFF ; } fillBuffer () ; if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) { MST[rv.ROR1Mutator]MSP[N]
if ( len < 0 || ( off + len ) > b . length ) { throw new IndexOutOfBoundsException ( lr_2 + b . length + MST[NonVoidMethodCallMutator]MSP[S] lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { return 0 ; }
private void fillBuffer () throws CharacterCodingException { this . bbuf . compact () ; final CoderResult result = this . encoder . encode ( this . cbuf , this . bbuf , true ) ; if ( result . isError () ) { MST[rv.ROR2Mutator]MSP[N] result . throwException () ; }
if ( len < 0 || ( off + len ) > b . length ) { throw new IndexOutOfBoundsException ( lr_2 + b . length + lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { MST[rv.ROR4Mutator]MSP[N] return 0 ; }
private void fillBuffer () throws CharacterCodingException { this . bbuf . compact () ; final CoderResult result = this . encoder . encode ( this . cbuf , this . bbuf , true ) ; if ( result . isError () ) { MST[rv.ROR4Mutator]MSP[N] result . throwException () ; }
return this . bbuf . remaining () + this . cbuf . remaining () ; } @Override public void close () throws IOException { } @Override public synchronized void mark ( final int readlimit ) { this . mark_cbuf = this . cbuf . position () ; MST[NonVoidMethodCallMutator]MSP[N]
final int chunk = Math . min ( this . bbuf . remaining () , len ) ; MST[rv.UOI1Mutator]MSP[N] this . bbuf . get ( b , off , chunk ) ; off += chunk ; len -= chunk ; bytesRead += chunk ; } else { fillBuffer () ;
final int chunk = Math . min ( this . bbuf . remaining () , len ) ; this . bbuf . get ( b , off , chunk ) ; MST[rv.UOI3Mutator]MSP[N] off += chunk ; len -= chunk ; bytesRead += chunk ; } else { fillBuffer () ;
while( this . cbuf . position () < this . mark_cbuf ) { MST[rv.ROR5Mutator]MSP[N] this . bbuf . rewind () ; this . bbuf . limit ( 0 ) ; fillBuffer () ; } } if ( this . cbuf . position () != this . mark_cbuf ) {
while( this . cbuf . position () < this . mark_cbuf ) { this . bbuf . rewind () ; this . bbuf . limit ( 0 ) ; MST[rv.CRCR3Mutator]MSP[N] fillBuffer () ; } } if ( this . cbuf . position () != this . mark_cbuf ) {
if ( len < 0 || ( off + len ) > b . length ) { throw new IndexOutOfBoundsException ( lr_2 + b . length + lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { return 0 ; MST[rv.CRCR6Mutator]MSP[N] }
while( this . cbuf . position () < this . mark_cbuf ) { MST[rv.ABSMutator]MSP[N] this . bbuf . rewind () ; this . bbuf . limit ( 0 ) ; fillBuffer () ; } } if ( this . cbuf . position () != this . mark_cbuf ) {
final int chunk = Math . min ( this . bbuf . remaining () , len ) ; this . bbuf . get ( b , off , chunk ) ; off += chunk ; MST[rv.AOD2Mutator]MSP[N] len -= chunk ; bytesRead += chunk ; } else { fillBuffer () ;
this . bbuf . flip () ; } @Override public int read ( final byte [] b , int off , int len ) throws IOException { if ( b == null ) { throw new NullPointerException ( lr_1 ) ; MST[ConstructorCallMutator]MSP[N] }
if ( len < 0 || ( off + len ) > b . length ) { MST[rv.UOI2Mutator]MSP[N] throw new IndexOutOfBoundsException ( lr_2 + b . length + lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { return 0 ; }
if ( len < 0 || ( off + len ) > b . length ) { MST[rv.UOI3Mutator]MSP[N] throw new IndexOutOfBoundsException ( lr_2 + b . length + lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { return 0 ; }
if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) { MST[NonVoidMethodCallMutator]MSP[N] return EOF ; } int bytesRead = 0 ; while ( len > 0 ) { if ( this . bbuf . hasRemaining () ) {
if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) { return EOF ; } int bytesRead = 0 ; MST[rv.CRCR5Mutator]MSP[N] while ( len > 0 ) { if ( this . bbuf . hasRemaining () ) {
final int chunk = Math . min ( this . bbuf . remaining () , len ) ; this . bbuf . get ( b , off , chunk ) ; off += chunk ; len -= chunk ; MST[rv.AOR1Mutator]MSP[N] bytesRead += chunk ; } else { fillBuffer () ;
this . mark_bbuf = this . bbuf . position () ; this . cbuf . mark () ; this . bbuf . mark () ; } @Override public synchronized void reset () throws IOException { if ( this . mark_cbuf != NO_MARK ) { MST[rv.ROR3Mutator]MSP[N]
if ( this . cbuf . position () != 0 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] this . encoder . reset () ; this . cbuf . rewind () ; this . bbuf . rewind () ; this . bbuf . limit ( 0 ) ;
if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) { MST[NegateConditionalsMutator]MSP[N] return EOF ; } int bytesRead = 0 ; while ( len > 0 ) { if ( this . bbuf . hasRemaining () ) {
while ( n > 0 && available () > 0 ) { this . read () ; n -- ; MST[rv.UOI2Mutator]MSP[N] skipped ++ ; } return skipped ; } @Override public int available () throws IOException {
for (; ; ) { if ( this . bbuf . hasRemaining () ) { return this . bbuf . get () & 0xFF ; MST[rv.CRCR4Mutator]MSP[N] } fillBuffer () ; if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) {
return this . bbuf . remaining () + this . cbuf . remaining () ; MST[rv.AOD1Mutator]MSP[N] } @Override public void close () throws IOException { } @Override public synchronized void mark ( final int readlimit ) { this . mark_cbuf = this . cbuf . position () ;
if ( len < 0 || ( off + len ) > b . length ) { throw new IndexOutOfBoundsException ( lr_2 + b . length + lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { MST[rv.UOI3Mutator]MSP[N] return 0 ; }
this . mark_bbuf = this . bbuf . position () ; this . cbuf . mark () ; this . bbuf . mark () ; } @Override public synchronized void reset () throws IOException { if ( this . mark_cbuf != NO_MARK ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
if ( len < 0 || ( off + len ) > b . length ) { MST[rv.ROR1Mutator]MSP[N] throw new IndexOutOfBoundsException ( lr_2 + b . length + lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { return 0 ; }
return EOF ; } } } @Override public int read ( final byte [] b ) throws IOException { return read ( b , 0 , b . length ) ; MST[ReturnValsMutator]MSP[N] } @Override public long skip ( long n ) throws IOException { long skipped = 0 ;
while ( n > 0 && available () > 0 ) { this . read () ; n -- ; skipped ++ ; } return skipped ; MST[rv.UOI1Mutator]MSP[N] } @Override public int available () throws IOException {
while ( n > 0 && available () > 0 ) { MST[rv.CRCR5Mutator]MSP[S] this . read () ; n -- ; skipped ++ ; } return skipped ; } @Override public int available () throws IOException {
return EOF ; } } } @Override public int read ( final byte [] b ) throws IOException { return read ( b , 0 , b . length ) ; } @Override public long skip ( long n ) throws IOException { long skipped = 0 ; MST[rv.CRCR3Mutator]MSP[N]
while( this . cbuf . position () < this . mark_cbuf ) { MST[rv.UOI2Mutator]MSP[N] this . bbuf . rewind () ; this . bbuf . limit ( 0 ) ; fillBuffer () ; } } if ( this . cbuf . position () != this . mark_cbuf ) {
if ( len < 0 || ( off + len ) > b . length ) { MST[rv.ROR5Mutator]MSP[N] throw new IndexOutOfBoundsException ( lr_2 + b . length + lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { return 0 ; }
this . mark_bbuf = this . bbuf . position () ; this . cbuf . mark () ; this . bbuf . mark () ; } @Override public synchronized void reset () throws IOException { if ( this . mark_cbuf != NO_MARK ) { MST[rv.CRCR6Mutator]MSP[N]
if ( len < 0 || ( off + len ) > b . length ) { MST[MathMutator]MSP[N] throw new IndexOutOfBoundsException ( lr_2 + b . length + lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { return 0 ; }
while ( n > 0 && available () > 0 ) { MST[ConditionalsBoundaryMutator]MSP[N] this . read () ; n -- ; skipped ++ ; } return skipped ; } @Override public int available () throws IOException {
if ( len < 0 || ( off + len ) > b . length ) { MST[rv.UOI3Mutator]MSP[N] throw new IndexOutOfBoundsException ( lr_2 + b . length + lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { return 0 ; }
this . mark_bbuf = this . bbuf . position () ; this . cbuf . mark () ; this . bbuf . mark () ; } @Override public synchronized void reset () throws IOException { if ( this . mark_cbuf != NO_MARK ) { MST[rv.CRCR2Mutator]MSP[N]
while ( n > 0 && available () > 0 ) { this . read () ; n -- ; MST[InlineConstantMutator]MSP[N] skipped ++ ; } return skipped ; } @Override public int available () throws IOException {
final int chunk = Math . min ( this . bbuf . remaining () , len ) ; this . bbuf . get ( b , off , chunk ) ; off += chunk ; MST[rv.AOR4Mutator]MSP[N] len -= chunk ; bytesRead += chunk ; } else { fillBuffer () ;
return EOF ; } } } @Override public int read ( final byte [] b ) throws IOException { return read ( b , 0 , b . length ) ; MST[InlineConstantMutator]MSP[N] } @Override public long skip ( long n ) throws IOException { long skipped = 0 ;
if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) { MST[rv.ROR1Mutator]MSP[S] break; } } } return bytesRead == 0 && ! this . cbuf . hasRemaining () ? EOF : bytesRead ; } @Override public int read () throws IOException {
final int chunk = Math . min ( this . bbuf . remaining () , len ) ; this . bbuf . get ( b , off , chunk ) ; off += chunk ; len -= chunk ; bytesRead += chunk ; MST[rv.AOD1Mutator]MSP[N] } else { fillBuffer () ;
if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) { return EOF ; } int bytesRead = 0 ; while ( len > 0 ) { MST[rv.UOI2Mutator]MSP[N] if ( this . bbuf . hasRemaining () ) {
while ( n > 0 && available () > 0 ) { this . read () ; n -- ; MST[rv.AOR3Mutator]MSP[S] skipped ++ ; } return skipped ; } @Override public int available () throws IOException {
while( this . cbuf . position () < this . mark_cbuf ) { this . bbuf . rewind () ; this . bbuf . limit ( 0 ) ; fillBuffer () ; } } if ( this . cbuf . position () != this . mark_cbuf ) { MST[rv.ROR4Mutator]MSP[N]
return this . bbuf . remaining () + this . cbuf . remaining () ; MST[rv.AOR3Mutator]MSP[N] } @Override public void close () throws IOException { } @Override public synchronized void mark ( final int readlimit ) { this . mark_cbuf = this . cbuf . position () ;
while ( n > 0 && available () > 0 ) { MST[rv.ROR1Mutator]MSP[S] this . read () ; n -- ; skipped ++ ; } return skipped ; } @Override public int available () throws IOException {
while ( n > 0 && available () > 0 ) { this . read () ; n -- ; skipped ++ ; MST[rv.ABSMutator]MSP[N] } return skipped ; } @Override public int available () throws IOException {
if ( this . cbuf . position () != 0 ) { MST[NegateConditionalsMutator]MSP[N] this . encoder . reset () ; this . cbuf . rewind () ; this . bbuf . rewind () ; this . bbuf . limit ( 0 ) ;
if ( this . cbuf . position () != 0 ) { this . encoder . reset () ; this . cbuf . rewind () ; this . bbuf . rewind () ; this . bbuf . limit ( 0 ) ; MST[rv.CRCR1Mutator]MSP[N]
final int chunk = Math . min ( this . bbuf . remaining () , len ) ; this . bbuf . get ( b , off , chunk ) ; MST[rv.ABSMutator]MSP[N] off += chunk ; len -= chunk ; bytesRead += chunk ; } else { fillBuffer () ;
if ( len < 0 || ( off + len ) > b . length ) { throw new IndexOutOfBoundsException ( lr_2 + b . length + MST[ConstructorCallMutator]MSP[S] lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { return 0 ; }
this . bbuf . flip () ; } @Override public int read ( final byte [] b , int off , int len ) throws IOException { if ( b == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] throw new NullPointerException ( lr_1 ) ; }
final int chunk = Math . min ( this . bbuf . remaining () , len ) ; this . bbuf . get ( b , off , chunk ) ; off += chunk ; len -= chunk ; bytesRead += chunk ; MST[rv.UOI3Mutator]MSP[N] } else { fillBuffer () ;
for (; ; ) { if ( this . bbuf . hasRemaining () ) { return this . bbuf . get () & 0xFF ; MST[PrimitiveReturnsMutator]MSP[N] } fillBuffer () ; if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) {
throw new IllegalStateException ( lr_5 + cbuf . position () + lr_6 + lr_7 + this . mark_cbuf ) ; } this . bbuf . position ( this . mark_bbuf ) ; this . mark_cbuf = NO_MARK ; MST[experimental.MemberVariableMutator]MSP[N] this . mark_bbuf = NO_MARK ; } } @Override
final int chunk = Math . min ( this . bbuf . remaining () , len ) ; this . bbuf . get ( b , off , chunk ) ; off += chunk ; len -= chunk ; bytesRead += chunk ; MST[rv.UOI4Mutator]MSP[N] } else { fillBuffer () ;
private void fillBuffer () throws CharacterCodingException { this . bbuf . compact () ; final CoderResult result = this . encoder . encode ( this . cbuf , this . bbuf , true ) ; MST[rv.CRCR6Mutator]MSP[N] if ( result . isError () ) { result . throwException () ; }
for (; ; ) { if ( this . bbuf . hasRemaining () ) { return this . bbuf . get () & 0xFF ; } fillBuffer () ; if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) { MST[NonVoidMethodCallMutator]MSP[N]
while( this . cbuf . position () < this . mark_cbuf ) { this . bbuf . rewind () ; this . bbuf . limit ( 0 ) ; MST[InlineConstantMutator]MSP[S] fillBuffer () ; } } if ( this . cbuf . position () != this . mark_cbuf ) {
private void fillBuffer () throws CharacterCodingException { this . bbuf . compact () ; final CoderResult result = this . encoder . encode ( this . cbuf , this . bbuf , true ) ; MST[rv.CRCR5Mutator]MSP[N] if ( result . isError () ) { result . throwException () ; }
throw new IllegalStateException ( lr_5 + cbuf . position () + lr_6 + lr_7 + this . mark_cbuf ) ; } this . bbuf . position ( this . mark_bbuf ) ; this . mark_cbuf = NO_MARK ; this . mark_bbuf = NO_MARK ; MST[rv.CRCR4Mutator]MSP[N] } } @Override
throw new IllegalStateException ( lr_5 + cbuf . position () + lr_6 + lr_7 + this . mark_cbuf ) ; } this . bbuf . position ( this . mark_bbuf ) ; this . mark_cbuf = NO_MARK ; this . mark_bbuf = NO_MARK ; MST[rv.CRCR5Mutator]MSP[N] } } @Override
if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) { return EOF ; MST[rv.CRCR4Mutator]MSP[N] } int bytesRead = 0 ; while ( len > 0 ) { if ( this . bbuf . hasRemaining () ) {
if ( this . cbuf . position () != 0 ) { this . encoder . reset () ; this . cbuf . rewind () ; this . bbuf . rewind () ; MST[NonVoidMethodCallMutator]MSP[N] this . bbuf . limit ( 0 ) ;
public boolean markSupported () { return true ; MST[rv.CRCR6Mutator]MSP[N] }
for (; ; ) { if ( this . bbuf . hasRemaining () ) { MST[rv.ROR3Mutator]MSP[N] return this . bbuf . get () & 0xFF ; } fillBuffer () ; if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) {
while ( n > 0 && available () > 0 ) { this . read () ; n -- ; skipped ++ ; MST[rv.UOI4Mutator]MSP[N] } return skipped ; } @Override public int available () throws IOException {
if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) { break; } } } return bytesRead == 0 && ! this . cbuf . hasRemaining () ? EOF : bytesRead ; MST[rv.ROR4Mutator]MSP[N] } @Override public int read () throws IOException {
if ( len < 0 || ( off + len ) > b . length ) { MST[rv.UOI2Mutator]MSP[N] throw new IndexOutOfBoundsException ( lr_2 + b . length + lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { return 0 ; }
while( this . cbuf . position () < this . mark_cbuf ) { this . bbuf . rewind () ; this . bbuf . limit ( 0 ) ; fillBuffer () ; } } if ( this . cbuf . position () != this . mark_cbuf ) { MST[rv.ROR3Mutator]MSP[N]
return EOF ; } } } @Override public int read ( final byte [] b ) throws IOException { return read ( b , 0 , b . length ) ; MST[ArgumentPropagationMutator]MSP[N] } @Override public long skip ( long n ) throws IOException { long skipped = 0 ;
final int chunk = Math . min ( this . bbuf . remaining () , len ) ; this . bbuf . get ( b , off , chunk ) ; off += chunk ; len -= chunk ; bytesRead += chunk ; MST[rv.ABSMutator]MSP[N] } else { fillBuffer () ;
if ( this . cbuf . position () != 0 ) { MST[rv.ROR5Mutator]MSP[N] this . encoder . reset () ; this . cbuf . rewind () ; this . bbuf . rewind () ; this . bbuf . limit ( 0 ) ;
while ( n > 0 && available () > 0 ) { this . read () ; n -- ; skipped ++ ; MST[rv.AOR4Mutator]MSP[N] } return skipped ; } @Override public int available () throws IOException {
final int chunk = Math . min ( this . bbuf . remaining () , len ) ; this . bbuf . get ( b , off , chunk ) ; off += chunk ; len -= chunk ; bytesRead += chunk ; MST[rv.AOR3Mutator]MSP[N] } else { fillBuffer () ;
if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) { MST[rv.ROR4Mutator]MSP[N] return EOF ; } int bytesRead = 0 ; while ( len > 0 ) { if ( this . bbuf . hasRemaining () ) {
this . bbuf . flip () ; } @Override public int read ( final byte [] b , int off , int len ) throws IOException { if ( b == null ) { MST[rv.ROR5Mutator]MSP[N] throw new NullPointerException ( lr_1 ) ; }
while ( n > 0 && available () > 0 ) { this . read () ; n -- ; skipped ++ ; MST[rv.AOD1Mutator]MSP[N] } return skipped ; } @Override public int available () throws IOException {
while ( n > 0 && available () > 0 ) { this . read () ; n -- ; skipped ++ ; MST[rv.CRCR6Mutator]MSP[N] } return skipped ; } @Override public int available () throws IOException {
final int chunk = Math . min ( this . bbuf . remaining () , len ) ; this . bbuf . get ( b , off , chunk ) ; off += chunk ; len -= chunk ; MST[rv.UOI2Mutator]MSP[N] bytesRead += chunk ; } else { fillBuffer () ;
while( this . cbuf . position () < this . mark_cbuf ) { this . bbuf . rewind () ; this . bbuf . limit ( 0 ) ; fillBuffer () ; } } if ( this . cbuf . position () != this . mark_cbuf ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
final int chunk = Math . min ( this . bbuf . remaining () , len ) ; this . bbuf . get ( b , off , chunk ) ; off += chunk ; len -= chunk ; bytesRead += chunk ; MST[rv.UOI4Mutator]MSP[N] } else { fillBuffer () ;
while ( n > 0 && available () > 0 ) { this . read () ; n -- ; MST[rv.CRCR4Mutator]MSP[S] skipped ++ ; } return skipped ; } @Override public int available () throws IOException {
if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return EOF ; } int bytesRead = 0 ; while ( len > 0 ) { if ( this . bbuf . hasRemaining () ) {
if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) { return EOF ; } int bytesRead = 0 ; MST[rv.CRCR1Mutator]MSP[N] while ( len > 0 ) { if ( this . bbuf . hasRemaining () ) {
return this . bbuf . remaining () + this . cbuf . remaining () ; } @Override public void close () throws IOException { } @Override public synchronized void mark ( final int readlimit ) { this . mark_cbuf = this . cbuf . position () ; MST[experimental.MemberVariableMutator]MSP[N]
if ( len < 0 || ( off + len ) > b . length ) { MST[rv.AOR2Mutator]MSP[N] throw new IndexOutOfBoundsException ( lr_2 + b . length + lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { return 0 ; }
if ( len < 0 || ( off + len ) > b . length ) { throw new IndexOutOfBoundsException ( lr_2 + b . length + MST[rv.UOI4Mutator]MSP[N] lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { return 0 ; }
final int chunk = Math . min ( this . bbuf . remaining () , len ) ; this . bbuf . get ( b , off , chunk ) ; MST[rv.UOI3Mutator]MSP[N] off += chunk ; len -= chunk ; bytesRead += chunk ; } else { fillBuffer () ;
if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) { break; } } } return bytesRead == 0 && ! this . cbuf . hasRemaining () ? EOF : bytesRead ; MST[rv.UOI2Mutator]MSP[N] } @Override public int read () throws IOException {
if ( len < 0 || ( off + len ) > b . length ) { MST[NegateConditionalsMutator]MSP[N] throw new IndexOutOfBoundsException ( lr_2 + b . length + lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { return 0 ; }
while ( n > 0 && available () > 0 ) { MST[rv.UOI3Mutator]MSP[N] this . read () ; n -- ; skipped ++ ; } return skipped ; } @Override public int available () throws IOException {
if ( this . cbuf . position () != 0 ) { MST[NonVoidMethodCallMutator]MSP[N] this . encoder . reset () ; this . cbuf . rewind () ; this . bbuf . rewind () ; this . bbuf . limit ( 0 ) ;
if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) { return EOF ; } int bytesRead = 0 ; MST[rv.CRCR6Mutator]MSP[N] while ( len > 0 ) { if ( this . bbuf . hasRemaining () ) {
if ( len < 0 || ( off + len ) > b . length ) { MST[rv.ROR4Mutator]MSP[N] throw new IndexOutOfBoundsException ( lr_2 + b . length + lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { return 0 ; }
final int chunk = Math . min ( this . bbuf . remaining () , len ) ; this . bbuf . get ( b , off , chunk ) ; off += chunk ; len -= chunk ; bytesRead += chunk ; MST[rv.ABSMutator]MSP[N] } else { fillBuffer () ;
for (; ; ) { if ( this . bbuf . hasRemaining () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return this . bbuf . get () & 0xFF ; } fillBuffer () ; if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) {
final int chunk = Math . min ( this . bbuf . remaining () , len ) ; this . bbuf . get ( b , off , chunk ) ; off += chunk ; len -= chunk ; MST[MathMutator]MSP[N] bytesRead += chunk ; } else { fillBuffer () ;
if ( len < 0 || ( off + len ) > b . length ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[S] throw new IndexOutOfBoundsException ( lr_2 + b . length + lr_3 + off + lr_4 + len ) ; } if ( len == 0 ) { return 0 ; }
private void fillBuffer () throws CharacterCodingException { this . bbuf . compact () ; final CoderResult result = this . encoder . encode ( this . cbuf , this . bbuf , true ) ; if ( result . isError () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] result . throwException () ; }
if ( ! this . bbuf . hasRemaining () && ! this . cbuf . hasRemaining () ) { MST[rv.ROR3Mutator]MSP[N] return EOF ; } int bytesRead = 0 ; while ( len > 0 ) { if ( this . bbuf . hasRemaining () ) {
throw new IllegalStateException ( lr_5 + cbuf . position () + lr_6 + lr_7 + this . mark_cbuf ) ; } this . bbuf . position ( this . mark_bbuf ) ; this . mark_cbuf = NO_MARK ; MST[InlineConstantMutator]MSP[N] this . mark_bbuf = NO_MARK ; } } @Override
return this . bbuf . remaining () + this . cbuf . remaining () ; MST[ReturnValsMutator]MSP[N] } @Override public void close () throws IOException { } @Override public synchronized void mark ( final int readlimit ) { this . mark_cbuf = this . cbuf . position () ;
if ( this . cbuf . position () != 0 ) { this . encoder . reset () ; this . cbuf . rewind () ; this . bbuf . rewind () ; this . bbuf . limit ( 0 ) ; MST[rv.CRCR6Mutator]MSP[N]
while( this . cbuf . position () < this . mark_cbuf ) { this . bbuf . rewind () ; this . bbuf . limit ( 0 ) ; fillBuffer () ; } } if ( this . cbuf . position () != this . mark_cbuf ) { MST[rv.UOI1Mutator]MSP[N]
