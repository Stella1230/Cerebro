public Set < Map . Entry < K , V > > entrySet () { final Set < Map . Entry < K , V > > set = map . entrySet () ; MST[NonVoidMethodCallMutator]MSP[N] return UnmodifiableSet . unmodifiableSet ( set ) ; } @Override
return UnmodifiableCollection . unmodifiableCollection ( coll ) ; } @Override public boolean isFull () { return true ; MST[rv.CRCR2Mutator]MSP[S] } @Override public int maxSize () { return size () ; }
return UnmodifiableCollection . unmodifiableCollection ( coll ) ; } @Override public boolean isFull () { return true ; MST[rv.CRCR4Mutator]MSP[N] } @Override public int maxSize () { return size () ; }
return UnmodifiableCollection . unmodifiableCollection ( coll ) ; } @Override public boolean isFull () { return true ; MST[rv.CRCR3Mutator]MSP[N] } @Override public int maxSize () { return size () ; }
return UnmodifiableCollection . unmodifiableCollection ( coll ) ; MST[ReturnValsMutator]MSP[N] } @Override public boolean isFull () { return true ; } @Override public int maxSize () { return size () ; }
public static < K , V > FixedSizeMap < K , V > fixedSizeMap ( final Map < K , V > map ) { return new FixedSizeMap <> ( map ) ; MST[ReturnValsMutator]MSP[N] } private void writeObject ( final ObjectOutputStream out ) throws IOException { out . defaultWriteObject () ;
public V put ( final K key , final V value ) { if ( map . containsKey ( key ) == false ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] throw new IllegalArgumentException ( lr_2 ) ; } return map . put ( key , value ) ; } @Override
public Set < K > keySet () { final Set < K > set = map . keySet () ; return UnmodifiableSet . unmodifiableSet ( set ) ; MST[ReturnValsMutator]MSP[N] } @Override public Collection < V > values () { final Collection < V > coll = map . values () ;
out . writeObject ( map ) ; } @SuppressWarnings ( lr_1 ) private void readObject ( final ObjectInputStream in ) throws IOException , ClassNotFoundException { in . defaultReadObject () ; MST[VoidMethodCallMutator]MSP[N] map = ( Map < K , V > ) in . readObject () ; } @Override
return UnmodifiableCollection . unmodifiableCollection ( coll ) ; } @Override public boolean isFull () { return true ; } @Override public int maxSize () { return size () ; MST[PrimitiveReturnsMutator]MSP[N] }
return UnmodifiableCollection . unmodifiableCollection ( coll ) ; } @Override public boolean isFull () { return true ; MST[BooleanFalseReturnValsMutator]MSP[S] } @Override public int maxSize () { return size () ; }
public Set < Map . Entry < K , V > > entrySet () { final Set < Map . Entry < K , V > > set = map . entrySet () ; return UnmodifiableSet . unmodifiableSet ( set ) ; MST[EmptyObjectReturnValsMutator]MSP[S] } @Override
public Set < K > keySet () { final Set < K > set = map . keySet () ; return UnmodifiableSet . unmodifiableSet ( set ) ; MST[NonVoidMethodCallMutator]MSP[N] } @Override public Collection < V > values () { final Collection < V > coll = map . values () ;
public Set < K > keySet () { final Set < K > set = map . keySet () ; return UnmodifiableSet . unmodifiableSet ( set ) ; MST[ArgumentPropagationMutator]MSP[N] } @Override public Collection < V > values () { final Collection < V > coll = map . values () ;
public Set < K > keySet () { final Set < K > set = map . keySet () ; return UnmodifiableSet . unmodifiableSet ( set ) ; MST[EmptyObjectReturnValsMutator]MSP[N] } @Override public Collection < V > values () { final Collection < V > coll = map . values () ;
return UnmodifiableCollection . unmodifiableCollection ( coll ) ; MST[EmptyObjectReturnValsMutator]MSP[S] } @Override public boolean isFull () { return true ; } @Override public int maxSize () { return size () ; }
public Set < Map . Entry < K , V > > entrySet () { final Set < Map . Entry < K , V > > set = map . entrySet () ; return UnmodifiableSet . unmodifiableSet ( set ) ; MST[ArgumentPropagationMutator]MSP[N] } @Override
public void putAll ( final Map < ? extends K , ? extends V > mapToCopy ) { for ( final K key : mapToCopy . keySet () ) { if ( ! containsKey ( key ) ) { throw new IllegalArgumentException ( lr_2 ) ; MST[ConstructorCallMutator]MSP[S] } }
public void putAll ( final Map < ? extends K , ? extends V > mapToCopy ) { for ( final K key : mapToCopy . keySet () ) { MST[NonVoidMethodCallMutator]MSP[S] if ( ! containsKey ( key ) ) { throw new IllegalArgumentException ( lr_2 ) ; } }
map . putAll ( mapToCopy ) ; MST[VoidMethodCallMutator]MSP[N] } @Override public void clear () { throw new UnsupportedOperationException ( lr_3 ) ; } @Override public V remove ( final Object key ) { throw new UnsupportedOperationException ( lr_3 ) ; } @Override
public static < K , V > FixedSizeMap < K , V > fixedSizeMap ( final Map < K , V > map ) { return new FixedSizeMap <> ( map ) ; MST[NullReturnValsMutator]MSP[N] } private void writeObject ( final ObjectOutputStream out ) throws IOException { out . defaultWriteObject () ;
return UnmodifiableCollection . unmodifiableCollection ( coll ) ; } @Override public boolean isFull () { return true ; MST[InlineConstantMutator]MSP[S] } @Override public int maxSize () { return size () ; }
public V put ( final K key , final V value ) { if ( map . containsKey ( key ) == false ) { MST[rv.ROR3Mutator]MSP[N] throw new IllegalArgumentException ( lr_2 ) ; } return map . put ( key , value ) ; } @Override
public V put ( final K key , final V value ) { if ( map . containsKey ( key ) == false ) { throw new IllegalArgumentException ( lr_2 ) ; MST[ConstructorCallMutator]MSP[S] } return map . put ( key , value ) ; } @Override
public Set < K > keySet () { final Set < K > set = map . keySet () ; return UnmodifiableSet . unmodifiableSet ( set ) ; } @Override public Collection < V > values () { final Collection < V > coll = map . values () ; MST[NonVoidMethodCallMutator]MSP[N]
map . putAll ( mapToCopy ) ; } @Override public void clear () { throw new UnsupportedOperationException ( lr_3 ) ; } @Override public V remove ( final Object key ) { throw new UnsupportedOperationException ( lr_3 ) ; MST[ConstructorCallMutator]MSP[S] } @Override
public V put ( final K key , final V value ) { if ( map . containsKey ( key ) == false ) { MST[rv.ROR1Mutator]MSP[S] throw new IllegalArgumentException ( lr_2 ) ; } return map . put ( key , value ) ; } @Override
public V put ( final K key , final V value ) { if ( map . containsKey ( key ) == false ) { MST[rv.ROR5Mutator]MSP[N] throw new IllegalArgumentException ( lr_2 ) ; } return map . put ( key , value ) ; } @Override
public V put ( final K key , final V value ) { if ( map . containsKey ( key ) == false ) { throw new IllegalArgumentException ( lr_2 ) ; } return map . put ( key , value ) ; MST[NullReturnValsMutator]MSP[S] } @Override
public V put ( final K key , final V value ) { if ( map . containsKey ( key ) == false ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] throw new IllegalArgumentException ( lr_2 ) ; } return map . put ( key , value ) ; } @Override
return UnmodifiableCollection . unmodifiableCollection ( coll ) ; } @Override public boolean isFull () { return true ; MST[rv.CRCR5Mutator]MSP[S] } @Override public int maxSize () { return size () ; }
public void putAll ( final Map < ? extends K , ? extends V > mapToCopy ) { for ( final K key : mapToCopy . keySet () ) { if ( ! containsKey ( key ) ) { MST[rv.ROR1Mutator]MSP[S] throw new IllegalArgumentException ( lr_2 ) ; } }
public void putAll ( final Map < ? extends K , ? extends V > mapToCopy ) { for ( final K key : mapToCopy . keySet () ) { if ( ! containsKey ( key ) ) { MST[rv.ROR3Mutator]MSP[N] throw new IllegalArgumentException ( lr_2 ) ; } }
public void putAll ( final Map < ? extends K , ? extends V > mapToCopy ) { for ( final K key : mapToCopy . keySet () ) { if ( ! containsKey ( key ) ) { MST[rv.ROR5Mutator]MSP[N] throw new IllegalArgumentException ( lr_2 ) ; } }
public V put ( final K key , final V value ) { if ( map . containsKey ( key ) == false ) { throw new IllegalArgumentException ( lr_2 ) ; } return map . put ( key , value ) ; MST[ArgumentPropagationMutator]MSP[S] } @Override
return UnmodifiableCollection . unmodifiableCollection ( coll ) ; } @Override public boolean isFull () { return true ; } @Override public int maxSize () { return size () ; MST[ReturnValsMutator]MSP[N] }
public V put ( final K key , final V value ) { if ( map . containsKey ( key ) == false ) { throw new IllegalArgumentException ( lr_2 ) ; } return map . put ( key , value ) ; MST[ReturnValsMutator]MSP[N] } @Override
public Set < Map . Entry < K , V > > entrySet () { final Set < Map . Entry < K , V > > set = map . entrySet () ; return UnmodifiableSet . unmodifiableSet ( set ) ; MST[NonVoidMethodCallMutator]MSP[N] } @Override
public void putAll ( final Map < ? extends K , ? extends V > mapToCopy ) { for ( final K key : mapToCopy . keySet () ) { if ( ! containsKey ( key ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] throw new IllegalArgumentException ( lr_2 ) ; } }
out . writeObject ( map ) ; } @SuppressWarnings ( lr_1 ) private void readObject ( final ObjectInputStream in ) throws IOException , ClassNotFoundException { in . defaultReadObject () ; map = ( Map < K , V > ) in . readObject () ; MST[experimental.MemberVariableMutator]MSP[S] } @Override
public void putAll ( final Map < ? extends K , ? extends V > mapToCopy ) { for ( final K key : mapToCopy . keySet () ) { if ( ! containsKey ( key ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] throw new IllegalArgumentException ( lr_2 ) ; } }
out . writeObject ( map ) ; } @SuppressWarnings ( lr_1 ) private void readObject ( final ObjectInputStream in ) throws IOException , ClassNotFoundException { in . defaultReadObject () ; map = ( Map < K , V > ) in . readObject () ; MST[NonVoidMethodCallMutator]MSP[S] } @Override
map . putAll ( mapToCopy ) ; } @Override public void clear () { throw new UnsupportedOperationException ( lr_3 ) ; MST[ConstructorCallMutator]MSP[S] } @Override public V remove ( final Object key ) { throw new UnsupportedOperationException ( lr_3 ) ; } @Override
public Set < Map . Entry < K , V > > entrySet () { final Set < Map . Entry < K , V > > set = map . entrySet () ; return UnmodifiableSet . unmodifiableSet ( set ) ; MST[ReturnValsMutator]MSP[N] } @Override
return UnmodifiableCollection . unmodifiableCollection ( coll ) ; } @Override public boolean isFull () { return true ; } @Override public int maxSize () { return size () ; MST[NonVoidMethodCallMutator]MSP[N] }
public V put ( final K key , final V value ) { if ( map . containsKey ( key ) == false ) { throw new IllegalArgumentException ( lr_2 ) ; } return map . put ( key , value ) ; MST[NonVoidMethodCallMutator]MSP[S] } @Override
public Set < K > keySet () { final Set < K > set = map . keySet () ; MST[NonVoidMethodCallMutator]MSP[N] return UnmodifiableSet . unmodifiableSet ( set ) ; } @Override public Collection < V > values () { final Collection < V > coll = map . values () ;
public void putAll ( final Map < ? extends K , ? extends V > mapToCopy ) { for ( final K key : mapToCopy . keySet () ) { if ( ! containsKey ( key ) ) { MST[NegateConditionalsMutator]MSP[N] throw new IllegalArgumentException ( lr_2 ) ; } }
public static < K , V > FixedSizeMap < K , V > fixedSizeMap ( final Map < K , V > map ) { return new FixedSizeMap <> ( map ) ; MST[ConstructorCallMutator]MSP[N] } private void writeObject ( final ObjectOutputStream out ) throws IOException { out . defaultWriteObject () ;
public V put ( final K key , final V value ) { if ( map . containsKey ( key ) == false ) { MST[NonVoidMethodCallMutator]MSP[S] throw new IllegalArgumentException ( lr_2 ) ; } return map . put ( key , value ) ; } @Override
return UnmodifiableCollection . unmodifiableCollection ( coll ) ; MST[NonVoidMethodCallMutator]MSP[N] } @Override public boolean isFull () { return true ; } @Override public int maxSize () { return size () ; }
return UnmodifiableCollection . unmodifiableCollection ( coll ) ; MST[ArgumentPropagationMutator]MSP[N] } @Override public boolean isFull () { return true ; } @Override public int maxSize () { return size () ; }
public V put ( final K key , final V value ) { if ( map . containsKey ( key ) == false ) { MST[rv.ROR2Mutator]MSP[N] throw new IllegalArgumentException ( lr_2 ) ; } return map . put ( key , value ) ; } @Override
public V put ( final K key , final V value ) { if ( map . containsKey ( key ) == false ) { MST[rv.ROR4Mutator]MSP[S] throw new IllegalArgumentException ( lr_2 ) ; } return map . put ( key , value ) ; } @Override
public void putAll ( final Map < ? extends K , ? extends V > mapToCopy ) { for ( final K key : mapToCopy . keySet () ) { if ( ! containsKey ( key ) ) { MST[NonVoidMethodCallMutator]MSP[S] throw new IllegalArgumentException ( lr_2 ) ; } }
return UnmodifiableCollection . unmodifiableCollection ( coll ) ; } @Override public boolean isFull () { return true ; MST[rv.CRCR6Mutator]MSP[S] } @Override public int maxSize () { return size () ; }
public static < K , V > FixedSizeMap < K , V > fixedSizeMap ( final Map < K , V > map ) { return new FixedSizeMap <> ( map ) ; } private void writeObject ( final ObjectOutputStream out ) throws IOException { out . defaultWriteObject () ; MST[VoidMethodCallMutator]MSP[N]
return UnmodifiableCollection . unmodifiableCollection ( coll ) ; } @Override public boolean isFull () { return true ; MST[ReturnValsMutator]MSP[S] } @Override public int maxSize () { return size () ; }
public V put ( final K key , final V value ) { if ( map . containsKey ( key ) == false ) { MST[NegateConditionalsMutator]MSP[N] throw new IllegalArgumentException ( lr_2 ) ; } return map . put ( key , value ) ; } @Override
out . writeObject ( map ) ; MST[VoidMethodCallMutator]MSP[S] } @SuppressWarnings ( lr_1 ) private void readObject ( final ObjectInputStream in ) throws IOException , ClassNotFoundException { in . defaultReadObject () ; map = ( Map < K , V > ) in . readObject () ; } @Override
public void putAll ( final Map < ? extends K , ? extends V > mapToCopy ) { for ( final K key : mapToCopy . keySet () ) { if ( ! containsKey ( key ) ) { MST[rv.ROR2Mutator]MSP[N] throw new IllegalArgumentException ( lr_2 ) ; } }
public void putAll ( final Map < ? extends K , ? extends V > mapToCopy ) { for ( final K key : mapToCopy . keySet () ) { if ( ! containsKey ( key ) ) { MST[rv.ROR4Mutator]MSP[S] throw new IllegalArgumentException ( lr_2 ) ; } }
