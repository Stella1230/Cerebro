return this . parent . containsKey ( value ) ; } @Override public void clear () { this . parent . clear () ; } @Override MST[experimental.MemberVariableMutator]MSP[] public K next () { return getIterator () . next () . getKey () ; }
return this . parent . containsKey ( value ) ; } @Override public void clear () { this . parent . clear () ; } @Override public K next () { return getIterator () . next () . getKey () ; MST[NonVoidMethodCallMutator]MSP[] }
return this . parent . containsKey ( value ) ; } @Override public void clear () { this . parent . clear () ; } @Override public K next () { return getIterator () . next () . getKey () ; MST[NonVoidMethodCallMutator]MSP[] }
return this . parent . containsKey ( value ) ; } @Override public void clear () { this . parent . clear () ; } @Override public K next () { return getIterator () . next () . getKey () ; MST[NonVoidMethodCallMutator]MSP[] }
return this . parent . containsKey ( value ) ; } @Override public void clear () { this . parent . clear () ; } @Override public K next () { return getIterator () . next () . getKey () ; MST[NullReturnValsMutator]MSP[] }
return this . parent . containsKey ( value ) ; } @Override public void clear () { this . parent . clear () ; } @Override public K next () { return getIterator () . next () . getKey () ; MST[ReturnValsMutator]MSP[] }
public boolean hasPrevious () { return iterator . hasPrevious () ; } @Override public K previous () { last = iterator . previous () ; readable = true ; return last ; } @Override public void remove () { if ( readable == false ) { MST[rv.ROR1Mutator]MSP[]
return parent . decorated () . put ( getKey () , value ) ; } @Override public boolean hasNext () { return iterator . hasNext () ; } @Override public K next () { last = iterator . next () ; readable = true ; MST[InlineConstantMutator]MSP[] return last ; } @Override
public boolean hasPrevious () { return iterator . hasPrevious () ; } @Override public K previous () { last = iterator . previous () ; readable = true ; return last ; } @Override public void remove () { if ( readable == false ) { MST[rv.ROR2Mutator]MSP[]
public boolean hasPrevious () { return iterator . hasPrevious () ; } @Override public K previous () { last = iterator . previous () ; readable = true ; return last ; } @Override public void remove () { if ( readable == false ) { MST[rv.ROR3Mutator]MSP[]
throw new IllegalStateException ( AbstractHashedMap . GETKEY_INVALID ) ; } return last ; } @Override public V getValue () { if ( readable == false ) { MST[rv.ROR1Mutator]MSP[] throw new IllegalStateException ( AbstractHashedMap . GETVALUE_INVALID ) ; } return parent . get ( last ) ; } @Override
throw new IllegalStateException ( AbstractHashedMap . GETKEY_INVALID ) ; } return last ; } @Override public V getValue () { if ( readable == false ) { MST[rv.ROR2Mutator]MSP[] throw new IllegalStateException ( AbstractHashedMap . GETVALUE_INVALID ) ; } return parent . get ( last ) ; } @Override
public boolean hasPrevious () { return iterator . hasPrevious () ; } @Override public K previous () { last = iterator . previous () ; MST[experimental.MemberVariableMutator]MSP[] readable = true ; return last ; } @Override public void remove () { if ( readable == false ) {
public boolean hasPrevious () { return iterator . hasPrevious () ; MST[NonVoidMethodCallMutator]MSP[] } @Override public K previous () { last = iterator . previous () ; readable = true ; return last ; } @Override public void remove () { if ( readable == false ) {
public boolean hasPrevious () { return iterator . hasPrevious () ; } @Override public K previous () { last = iterator . previous () ; readable = true ; MST[rv.CRCR4Mutator]MSP[] return last ; } @Override public void remove () { if ( readable == false ) {
iterator = parent . insertOrder . listIterator () ; last = null ; readable = false ; MST[rv.CRCR1Mutator]MSP[] } @Override public String toString () { if ( readable == true ) { return lr_8 + getKey () + lr_9 + getValue () + lr_10 ; } return lr_11 ; }
public boolean hasPrevious () { return iterator . hasPrevious () ; } @Override public K previous () { last = iterator . previous () ; readable = true ; MST[rv.CRCR2Mutator]MSP[] return last ; } @Override public void remove () { if ( readable == false ) {
iterator = parent . insertOrder . listIterator () ; last = null ; readable = false ; MST[rv.CRCR3Mutator]MSP[] } @Override public String toString () { if ( readable == true ) { return lr_8 + getKey () + lr_9 + getValue () + lr_10 ; } return lr_11 ; }
public boolean hasPrevious () { return iterator . hasPrevious () ; } @Override public K previous () { last = iterator . previous () ; readable = true ; MST[rv.CRCR3Mutator]MSP[] return last ; } @Override public void remove () { if ( readable == false ) {
public boolean hasPrevious () { return iterator . hasPrevious () ; } @Override public K previous () { last = iterator . previous () ; readable = true ; return last ; } @Override public void remove () { if ( readable == false ) { MST[rv.ROR5Mutator]MSP[]
public boolean hasPrevious () { return iterator . hasPrevious () ; } @Override public K previous () { last = iterator . previous () ; readable = true ; MST[rv.CRCR6Mutator]MSP[] return last ; } @Override public void remove () { if ( readable == false ) {
public boolean hasPrevious () { return iterator . hasPrevious () ; } @Override public K previous () { last = iterator . previous () ; readable = true ; MST[rv.CRCR5Mutator]MSP[] return last ; } @Override public void remove () { if ( readable == false ) {
public boolean hasPrevious () { return iterator . hasPrevious () ; } @Override public K previous () { last = iterator . previous () ; readable = true ; return last ; } @Override public void remove () { if ( readable == false ) { MST[rv.ROR4Mutator]MSP[]
iterator = parent . insertOrder . listIterator () ; last = null ; readable = false ; MST[rv.CRCR5Mutator]MSP[] } @Override public String toString () { if ( readable == true ) { return lr_8 + getKey () + lr_9 + getValue () + lr_10 ; } return lr_11 ; }
iterator = parent . insertOrder . listIterator () ; last = null ; readable = false ; } @Override public String toString () { if ( readable == true ) { return lr_8 + getKey () + lr_9 + getValue () + lr_10 ; } return lr_11 ; MST[ReturnValsMutator]MSP[] }
return parent . decorated () . put ( getKey () , value ) ; } @Override public boolean hasNext () { return iterator . hasNext () ; MST[BooleanFalseReturnValsMutator]MSP[] } @Override public K next () { last = iterator . next () ; readable = true ; return last ; } @Override
public boolean hasPrevious () { return iterator . hasPrevious () ; } @Override public K previous () { last = iterator . previous () ; readable = true ; return last ; MST[ReturnValsMutator]MSP[] } @Override public void remove () { if ( readable == false ) {
return parent . decorated () . put ( getKey () , value ) ; } @Override MST[InlineConstantMutator]MSP[] public boolean hasNext () { return iterator . hasNext () ; } @Override public K next () { last = iterator . next () ; readable = true ; return last ; } @Override
iterator = parent . insertOrder . listIterator () ; MST[NonVoidMethodCallMutator]MSP[] last = null ; readable = false ; } @Override public String toString () { if ( readable == true ) { return lr_8 + getKey () + lr_9 + getValue () + lr_10 ; } return lr_11 ; }
public boolean hasPrevious () { return iterator . hasPrevious () ; } @Override public K previous () { last = iterator . previous () ; readable = true ; return last ; } @Override public void remove () { if ( readable == false ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
throw new IllegalStateException ( AbstractHashedMap . GETKEY_INVALID ) ; } return last ; } @Override public V getValue () { if ( readable == false ) { MST[rv.ROR5Mutator]MSP[] throw new IllegalStateException ( AbstractHashedMap . GETVALUE_INVALID ) ; } return parent . get ( last ) ; } @Override
throw new IllegalStateException ( AbstractHashedMap . REMOVE_INVALID ) ; } iterator . remove () ; parent . map . remove ( last ) ; readable = false ; } @Override public K getKey () { if ( readable == false ) { MST[rv.ROR3Mutator]MSP[]
throw new IllegalStateException ( AbstractHashedMap . REMOVE_INVALID ) ; } iterator . remove () ; parent . map . remove ( last ) ; readable = false ; } @Override public K getKey () { if ( readable == false ) { MST[rv.ROR1Mutator]MSP[]
throw new IllegalStateException ( AbstractHashedMap . GETKEY_INVALID ) ; } return last ; } @Override public V getValue () { if ( readable == false ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] throw new IllegalStateException ( AbstractHashedMap . GETVALUE_INVALID ) ; } return parent . get ( last ) ; } @Override
throw new IllegalStateException ( AbstractHashedMap . GETKEY_INVALID ) ; } return last ; } @Override public V getValue () { if ( readable == false ) { MST[rv.ROR3Mutator]MSP[] throw new IllegalStateException ( AbstractHashedMap . GETVALUE_INVALID ) ; } return parent . get ( last ) ; } @Override
iterator = parent . insertOrder . listIterator () ; last = null ; MST[experimental.MemberVariableMutator]MSP[] readable = false ; } @Override public String toString () { if ( readable == true ) { return lr_8 + getKey () + lr_9 + getValue () + lr_10 ; } return lr_11 ; }
iterator = parent . insertOrder . listIterator () ; last = null ; readable = false ; } @Override public String toString () { if ( readable == true ) { MST[rv.CRCR3Mutator]MSP[] return lr_8 + getKey () + lr_9 + getValue () + lr_10 ; } return lr_11 ; }
iterator = parent . insertOrder . listIterator () ; last = null ; readable = false ; } @Override public String toString () { if ( readable == true ) { MST[rv.CRCR2Mutator]MSP[] return lr_8 + getKey () + lr_9 + getValue () + lr_10 ; } return lr_11 ; }
throw new IllegalStateException ( AbstractHashedMap . REMOVE_INVALID ) ; } iterator . remove () ; parent . map . remove ( last ) ; readable = false ; } @Override public K getKey () { if ( readable == false ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
return parent . decorated () . put ( getKey () , value ) ; } @Override MST[rv.CRCR3Mutator]MSP[] public boolean hasNext () { return iterator . hasNext () ; } @Override public K next () { last = iterator . next () ; readable = true ; return last ; } @Override
public boolean hasPrevious () { return iterator . hasPrevious () ; } @Override public K previous () { last = iterator . previous () ; readable = true ; MST[experimental.MemberVariableMutator]MSP[] return last ; } @Override public void remove () { if ( readable == false ) {
return parent . decorated () . put ( getKey () , value ) ; } @Override MST[rv.CRCR6Mutator]MSP[] public boolean hasNext () { return iterator . hasNext () ; } @Override public K next () { last = iterator . next () ; readable = true ; return last ; } @Override
iterator = parent . insertOrder . listIterator () ; last = null ; readable = false ; } @Override public String toString () { if ( readable == true ) { MST[rv.ROR3Mutator]MSP[] return lr_8 + getKey () + lr_9 + getValue () + lr_10 ; } return lr_11 ; }
return parent . decorated () . put ( getKey () , value ) ; } @Override public boolean hasNext () { return iterator . hasNext () ; MST[BooleanTrueReturnValsMutator]MSP[] } @Override public K next () { last = iterator . next () ; readable = true ; return last ; } @Override
public V setValue ( final V value ) { if ( readable == false ) { throw new IllegalStateException ( AbstractHashedMap . SETVALUE_INVALID ) ; MST[ConstructorCallMutator]MSP[] } return parent . map . put ( last , value ) ; } @Override public void reset () {
iterator = parent . insertOrder . listIterator () ; last = null ; readable = false ; } @Override public String toString () { if ( readable == true ) { MST[rv.ROR4Mutator]MSP[] return lr_8 + getKey () + lr_9 + getValue () + lr_10 ; } return lr_11 ; }
throw new IllegalStateException ( AbstractHashedMap . GETKEY_INVALID ) ; } return last ; } @Override public V getValue () { if ( readable == false ) { throw new IllegalStateException ( AbstractHashedMap . GETVALUE_INVALID ) ; } return parent . get ( last ) ; MST[ArgumentPropagationMutator]MSP[] } @Override
return parent . decorated () . put ( getKey () , value ) ; } @Override public boolean hasNext () { return iterator . hasNext () ; } @Override public K next () { last = iterator . next () ; readable = true ; return last ; MST[NullReturnValsMutator]MSP[] } @Override
throw new IllegalStateException ( AbstractHashedMap . GETKEY_INVALID ) ; } return last ; } @Override public V getValue () { if ( readable == false ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] throw new IllegalStateException ( AbstractHashedMap . GETVALUE_INVALID ) ; } return parent . get ( last ) ; } @Override
iterator = parent . insertOrder . listIterator () ; last = null ; readable = false ; } @Override public String toString () { if ( readable == true ) { MST[InlineConstantMutator]MSP[] return lr_8 + getKey () + lr_9 + getValue () + lr_10 ; } return lr_11 ; }
public V setValue ( final V value ) { if ( readable == false ) { MST[NegateConditionalsMutator]MSP[] throw new IllegalStateException ( AbstractHashedMap . SETVALUE_INVALID ) ; } return parent . map . put ( last , value ) ; } @Override public void reset () {
return parent . decorated () . put ( getKey () , value ) ; } @Override public boolean hasNext () { return iterator . hasNext () ; MST[NonVoidMethodCallMutator]MSP[] } @Override public K next () { last = iterator . next () ; readable = true ; return last ; } @Override
public V setValue ( final V value ) { if ( readable == false ) { MST[rv.ROR4Mutator]MSP[] throw new IllegalStateException ( AbstractHashedMap . SETVALUE_INVALID ) ; } return parent . map . put ( last , value ) ; } @Override public void reset () {
return parent . decorated () . put ( getKey () , value ) ; } @Override public boolean hasNext () { return iterator . hasNext () ; } @Override public K next () { last = iterator . next () ; readable = true ; MST[rv.CRCR3Mutator]MSP[] return last ; } @Override
throw new IllegalStateException ( AbstractHashedMap . REMOVE_INVALID ) ; } iterator . remove () ; parent . map . remove ( last ) ; readable = false ; } @Override public K getKey () { if ( readable == false ) { MST[rv.ROR2Mutator]MSP[]
iterator = parent . insertOrder . listIterator () ; last = null ; readable = false ; } @Override public String toString () { if ( readable == true ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return lr_8 + getKey () + lr_9 + getValue () + lr_10 ; } return lr_11 ; }
iterator = parent . insertOrder . listIterator () ; MST[experimental.MemberVariableMutator]MSP[] last = null ; readable = false ; } @Override public String toString () { if ( readable == true ) { return lr_8 + getKey () + lr_9 + getValue () + lr_10 ; } return lr_11 ; }
return parent . decorated () . put ( getKey () , value ) ; } @Override MST[experimental.MemberVariableMutator]MSP[] public boolean hasNext () { return iterator . hasNext () ; } @Override public K next () { last = iterator . next () ; readable = true ; return last ; } @Override
public boolean hasPrevious () { return iterator . hasPrevious () ; MST[ReturnValsMutator]MSP[] } @Override public K previous () { last = iterator . previous () ; readable = true ; return last ; } @Override public void remove () { if ( readable == false ) {
throw new IllegalStateException ( AbstractHashedMap . REMOVE_INVALID ) ; } iterator . remove () ; parent . map . remove ( last ) ; readable = false ; } @Override public K getKey () { if ( readable == false ) { MST[NegateConditionalsMutator]MSP[]
iterator = parent . insertOrder . listIterator () ; last = null ; readable = false ; } @Override public String toString () { if ( readable == true ) { return lr_8 + getKey () + lr_9 + getValue () + lr_10 ; } return lr_11 ; MST[EmptyObjectReturnValsMutator]MSP[] }
throw new IllegalStateException ( AbstractHashedMap . GETKEY_INVALID ) ; } return last ; } @Override public V getValue () { if ( readable == false ) { throw new IllegalStateException ( AbstractHashedMap . GETVALUE_INVALID ) ; MST[ConstructorCallMutator]MSP[] } return parent . get ( last ) ; } @Override
throw new IllegalStateException ( AbstractHashedMap . REMOVE_INVALID ) ; MST[ConstructorCallMutator]MSP[] } iterator . remove () ; parent . map . remove ( last ) ; readable = false ; } @Override public K getKey () { if ( readable == false ) {
return parent . decorated () . put ( getKey () , value ) ; } @Override public boolean hasNext () { return iterator . hasNext () ; } @Override public K next () { last = iterator . next () ; readable = true ; return last ; MST[ReturnValsMutator]MSP[] } @Override
public boolean hasPrevious () { return iterator . hasPrevious () ; MST[BooleanFalseReturnValsMutator]MSP[] } @Override public K previous () { last = iterator . previous () ; readable = true ; return last ; } @Override public void remove () { if ( readable == false ) {
public boolean hasPrevious () { return iterator . hasPrevious () ; MST[BooleanTrueReturnValsMutator]MSP[] } @Override public K previous () { last = iterator . previous () ; readable = true ; return last ; } @Override public void remove () { if ( readable == false ) {
public V setValue ( final V value ) { if ( readable == false ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] throw new IllegalStateException ( AbstractHashedMap . SETVALUE_INVALID ) ; } return parent . map . put ( last , value ) ; } @Override public void reset () {
public boolean hasPrevious () { return iterator . hasPrevious () ; } @Override public K previous () { last = iterator . previous () ; readable = true ; MST[InlineConstantMutator]MSP[] return last ; } @Override public void remove () { if ( readable == false ) {
throw new IllegalStateException ( AbstractHashedMap . GETKEY_INVALID ) ; } return last ; } @Override public V getValue () { if ( readable == false ) { throw new IllegalStateException ( AbstractHashedMap . GETVALUE_INVALID ) ; } return parent . get ( last ) ; MST[NonVoidMethodCallMutator]MSP[] } @Override
public V setValue ( final V value ) { if ( readable == false ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] throw new IllegalStateException ( AbstractHashedMap . SETVALUE_INVALID ) ; } return parent . map . put ( last , value ) ; } @Override public void reset () {
return parent . decorated () . put ( getKey () , value ) ; } @Override public boolean hasNext () { return iterator . hasNext () ; } @Override public K next () { last = iterator . next () ; readable = true ; MST[rv.CRCR4Mutator]MSP[] return last ; } @Override
return parent . decorated () . put ( getKey () , value ) ; } @Override public boolean hasNext () { return iterator . hasNext () ; } @Override public K next () { last = iterator . next () ; readable = true ; MST[rv.CRCR6Mutator]MSP[] return last ; } @Override
return parent . decorated () . put ( getKey () , value ) ; } @Override public boolean hasNext () { return iterator . hasNext () ; } @Override public K next () { last = iterator . next () ; readable = true ; MST[rv.CRCR2Mutator]MSP[] return last ; } @Override
public V setValue ( final V value ) { if ( readable == false ) { MST[rv.ROR3Mutator]MSP[] throw new IllegalStateException ( AbstractHashedMap . SETVALUE_INVALID ) ; } return parent . map . put ( last , value ) ; } @Override public void reset () {
public V setValue ( final V value ) { if ( readable == false ) { MST[rv.ROR5Mutator]MSP[] throw new IllegalStateException ( AbstractHashedMap . SETVALUE_INVALID ) ; } return parent . map . put ( last , value ) ; } @Override public void reset () {
iterator = parent . insertOrder . listIterator () ; last = null ; readable = false ; } @Override public String toString () { if ( readable == true ) { MST[NegateConditionalsMutator]MSP[] return lr_8 + getKey () + lr_9 + getValue () + lr_10 ; } return lr_11 ; }
throw new IllegalStateException ( AbstractHashedMap . GETKEY_INVALID ) ; } return last ; MST[ReturnValsMutator]MSP[] } @Override public V getValue () { if ( readable == false ) { throw new IllegalStateException ( AbstractHashedMap . GETVALUE_INVALID ) ; } return parent . get ( last ) ; } @Override
throw new IllegalStateException ( AbstractHashedMap . GETKEY_INVALID ) ; MST[ConstructorCallMutator]MSP[] } return last ; } @Override public V getValue () { if ( readable == false ) { throw new IllegalStateException ( AbstractHashedMap . GETVALUE_INVALID ) ; } return parent . get ( last ) ; } @Override
throw new IllegalStateException ( AbstractHashedMap . GETKEY_INVALID ) ; } return last ; } @Override public V getValue () { if ( readable == false ) { throw new IllegalStateException ( AbstractHashedMap . GETVALUE_INVALID ) ; } return parent . get ( last ) ; MST[NullReturnValsMutator]MSP[] } @Override
return parent . decorated () . put ( getKey () , value ) ; } @Override public boolean hasNext () { return iterator . hasNext () ; } @Override public K next () { last = iterator . next () ; readable = true ; MST[experimental.MemberVariableMutator]MSP[] return last ; } @Override
iterator = parent . insertOrder . listIterator () ; last = null ; readable = false ; } @Override public String toString () { if ( readable == true ) { MST[rv.CRCR6Mutator]MSP[] return lr_8 + getKey () + lr_9 + getValue () + lr_10 ; } return lr_11 ; }
throw new IllegalStateException ( AbstractHashedMap . REMOVE_INVALID ) ; } iterator . remove () ; parent . map . remove ( last ) ; readable = false ; } @Override public K getKey () { if ( readable == false ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
iterator = parent . insertOrder . listIterator () ; last = null ; readable = false ; } @Override public String toString () { if ( readable == true ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return lr_8 + getKey () + lr_9 + getValue () + lr_10 ; } return lr_11 ; }
iterator = parent . insertOrder . listIterator () ; last = null ; readable = false ; } @Override public String toString () { if ( readable == true ) { MST[rv.CRCR4Mutator]MSP[] return lr_8 + getKey () + lr_9 + getValue () + lr_10 ; } return lr_11 ; }
throw new IllegalStateException ( AbstractHashedMap . REMOVE_INVALID ) ; } iterator . remove () ; parent . map . remove ( last ) ; readable = false ; } @Override public K getKey () { if ( readable == false ) { MST[rv.ROR5Mutator]MSP[]
return parent . decorated () . put ( getKey () , value ) ; } @Override MST[rv.CRCR1Mutator]MSP[] public boolean hasNext () { return iterator . hasNext () ; } @Override public K next () { last = iterator . next () ; readable = true ; return last ; } @Override
throw new IllegalStateException ( AbstractHashedMap . REMOVE_INVALID ) ; } iterator . remove () ; parent . map . remove ( last ) ; readable = false ; } @Override public K getKey () { if ( readable == false ) { MST[rv.ROR4Mutator]MSP[]
public V setValue ( final V value ) { if ( readable == false ) { MST[rv.ROR1Mutator]MSP[] throw new IllegalStateException ( AbstractHashedMap . SETVALUE_INVALID ) ; } return parent . map . put ( last , value ) ; } @Override public void reset () {
public boolean hasPrevious () { return iterator . hasPrevious () ; } @Override public K previous () { last = iterator . previous () ; readable = true ; return last ; } @Override public void remove () { if ( readable == false ) { MST[NegateConditionalsMutator]MSP[]
return parent . decorated () . put ( getKey () , value ) ; } @Override MST[rv.CRCR5Mutator]MSP[] public boolean hasNext () { return iterator . hasNext () ; } @Override public K next () { last = iterator . next () ; readable = true ; return last ; } @Override
iterator = parent . insertOrder . listIterator () ; last = null ; readable = false ; MST[InlineConstantMutator]MSP[] } @Override public String toString () { if ( readable == true ) { return lr_8 + getKey () + lr_9 + getValue () + lr_10 ; } return lr_11 ; }
iterator = parent . insertOrder . listIterator () ; last = null ; readable = false ; } @Override public String toString () { if ( readable == true ) { MST[rv.ROR5Mutator]MSP[] return lr_8 + getKey () + lr_9 + getValue () + lr_10 ; } return lr_11 ; }
iterator = parent . insertOrder . listIterator () ; last = null ; readable = false ; } @Override public String toString () { if ( readable == true ) { MST[rv.ROR2Mutator]MSP[] return lr_8 + getKey () + lr_9 + getValue () + lr_10 ; } return lr_11 ; }
iterator = parent . insertOrder . listIterator () ; last = null ; readable = false ; } @Override public String toString () { if ( readable == true ) { MST[rv.ROR1Mutator]MSP[] return lr_8 + getKey () + lr_9 + getValue () + lr_10 ; } return lr_11 ; }
throw new IllegalStateException ( AbstractHashedMap . GETKEY_INVALID ) ; } return last ; } @Override public V getValue () { if ( readable == false ) { throw new IllegalStateException ( AbstractHashedMap . GETVALUE_INVALID ) ; } return parent . get ( last ) ; MST[ReturnValsMutator]MSP[] } @Override
iterator = parent . insertOrder . listIterator () ; last = null ; readable = false ; MST[experimental.MemberVariableMutator]MSP[] } @Override public String toString () { if ( readable == true ) { return lr_8 + getKey () + lr_9 + getValue () + lr_10 ; } return lr_11 ; }
throw new IllegalStateException ( AbstractHashedMap . GETKEY_INVALID ) ; } return last ; MST[NullReturnValsMutator]MSP[] } @Override public V getValue () { if ( readable == false ) { throw new IllegalStateException ( AbstractHashedMap . GETVALUE_INVALID ) ; } return parent . get ( last ) ; } @Override
iterator = parent . insertOrder . listIterator () ; last = null ; readable = false ; MST[rv.CRCR6Mutator]MSP[] } @Override public String toString () { if ( readable == true ) { return lr_8 + getKey () + lr_9 + getValue () + lr_10 ; } return lr_11 ; }
public boolean hasPrevious () { return iterator . hasPrevious () ; } @Override public K previous () { last = iterator . previous () ; readable = true ; return last ; } @Override public void remove () { if ( readable == false ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
iterator = parent . insertOrder . listIterator () ; MST[NonVoidMethodCallMutator]MSP[] last = null ; readable = false ; } @Override public String toString () { if ( readable == true ) { return lr_8 + getKey () + lr_9 + getValue () + lr_10 ; } return lr_11 ; }
return parent . decorated () . put ( getKey () , value ) ; } @Override public boolean hasNext () { return iterator . hasNext () ; } @Override public K next () { last = iterator . next () ; readable = true ; MST[rv.CRCR5Mutator]MSP[] return last ; } @Override
public V setValue ( final V value ) { if ( readable == false ) { MST[rv.ROR2Mutator]MSP[] throw new IllegalStateException ( AbstractHashedMap . SETVALUE_INVALID ) ; } return parent . map . put ( last , value ) ; } @Override public void reset () {
return parent . decorated () . put ( getKey () , value ) ; } @Override public boolean hasNext () { return iterator . hasNext () ; } @Override public K next () { last = iterator . next () ; MST[experimental.MemberVariableMutator]MSP[] readable = true ; return last ; } @Override
public boolean hasPrevious () { return iterator . hasPrevious () ; } @Override public K previous () { last = iterator . previous () ; readable = true ; return last ; MST[NullReturnValsMutator]MSP[] } @Override public void remove () { if ( readable == false ) {
throw new IllegalStateException ( AbstractHashedMap . GETKEY_INVALID ) ; } return last ; } @Override public V getValue () { if ( readable == false ) { MST[rv.ROR4Mutator]MSP[] throw new IllegalStateException ( AbstractHashedMap . GETVALUE_INVALID ) ; } return parent . get ( last ) ; } @Override
return parent . decorated () . put ( getKey () , value ) ; } @Override public boolean hasNext () { return iterator . hasNext () ; MST[ReturnValsMutator]MSP[] } @Override public K next () { last = iterator . next () ; readable = true ; return last ; } @Override
iterator = parent . insertOrder . listIterator () ; last = null ; readable = false ; } @Override public String toString () { if ( readable == true ) { MST[rv.CRCR5Mutator]MSP[] return lr_8 + getKey () + lr_9 + getValue () + lr_10 ; } return lr_11 ; }
throw new IllegalStateException ( AbstractHashedMap . GETKEY_INVALID ) ; } return last ; } @Override public V getValue () { if ( readable == false ) { MST[NegateConditionalsMutator]MSP[] throw new IllegalStateException ( AbstractHashedMap . GETVALUE_INVALID ) ; } return parent . get ( last ) ; } @Override
private Set < Map . Entry < K , V > > getEntrySet () { if ( entrySet == null ) { entrySet = parent . decorated () . entrySet () ; } return entrySet ; MST[ReturnValsMutator]MSP[] } @Override public int size () {
public boolean containsAll ( final Collection < ? > coll ) { return getEntrySet () . containsAll ( coll ) ; } @Override @SuppressWarnings ( lr_1 ) public boolean remove ( final Object obj ) { if ( obj instanceof Map . Entry == false ) { return false ; MST[rv.CRCR6Mutator]MSP[]
public boolean containsAll ( final Collection < ? > coll ) { return getEntrySet () . containsAll ( coll ) ; } @Override @SuppressWarnings ( lr_1 ) public boolean remove ( final Object obj ) { if ( obj instanceof Map . Entry == false ) { return false ; MST[rv.CRCR3Mutator]MSP[]
public boolean containsAll ( final Collection < ? > coll ) { return getEntrySet () . containsAll ( coll ) ; } @Override @SuppressWarnings ( lr_1 ) public boolean remove ( final Object obj ) { if ( obj instanceof Map . Entry == false ) { return false ; MST[rv.CRCR5Mutator]MSP[]
public boolean containsAll ( final Collection < ? > coll ) { return getEntrySet () . containsAll ( coll ) ; } @Override @SuppressWarnings ( lr_1 ) public boolean remove ( final Object obj ) { if ( obj instanceof Map . Entry == false ) { return false ; MST[ReturnValsMutator]MSP[]
public boolean containsAll ( final Collection < ? > coll ) { return getEntrySet () . containsAll ( coll ) ; } @Override @SuppressWarnings ( lr_1 ) public boolean remove ( final Object obj ) { if ( obj instanceof Map . Entry == false ) { return false ; MST[BooleanTrueReturnValsMutator]MSP[]
return this . parent . size () ; } @Override public boolean isEmpty () { return this . parent . isEmpty () ; MST[NonVoidMethodCallMutator]MSP[] } @Override public boolean contains ( final Object obj ) { return getEntrySet () . contains ( obj ) ; } @Override
} if ( getEntrySet () . contains ( obj ) ) { MST[NonVoidMethodCallMutator]MSP[] final Object key = ( ( Map . Entry < K , V > ) obj ) . getKey () ; parent . remove ( key ) ; return true ; } return false ; } @Override
public boolean containsAll ( final Collection < ? > coll ) { return getEntrySet () . containsAll ( coll ) ; MST[NonVoidMethodCallMutator]MSP[] } @Override @SuppressWarnings ( lr_1 ) public boolean remove ( final Object obj ) { if ( obj instanceof Map . Entry == false ) { return false ;
return getEntrySet () . hashCode () ; } @Override public String toString () { return getEntrySet () . toString () ; MST[NonVoidMethodCallMutator]MSP[] } @Override public Iterator < Map . Entry < K , V > > iterator () { return new ListOrderedIterator <> ( parent , insertOrder ) ; } @Override
return this . parent . size () ; MST[PrimitiveReturnsMutator]MSP[] } @Override public boolean isEmpty () { return this . parent . isEmpty () ; } @Override public boolean contains ( final Object obj ) { return getEntrySet () . contains ( obj ) ; } @Override
return this . parent . size () ; } @Override public boolean isEmpty () { return this . parent . isEmpty () ; } @Override public boolean contains ( final Object obj ) { return getEntrySet () . contains ( obj ) ; MST[NonVoidMethodCallMutator]MSP[] } @Override
return this . parent . size () ; } @Override public boolean isEmpty () { return this . parent . isEmpty () ; } @Override public boolean contains ( final Object obj ) { return getEntrySet () . contains ( obj ) ; MST[BooleanFalseReturnValsMutator]MSP[] } @Override
public boolean containsAll ( final Collection < ? > coll ) { return getEntrySet () . containsAll ( coll ) ; } @Override @SuppressWarnings ( lr_1 ) public boolean remove ( final Object obj ) { if ( obj instanceof Map . Entry == false ) { return false ; MST[rv.CRCR1Mutator]MSP[]
return this . parent . size () ; } @Override public boolean isEmpty () { return this . parent . isEmpty () ; } @Override public boolean contains ( final Object obj ) { return getEntrySet () . contains ( obj ) ; MST[BooleanTrueReturnValsMutator]MSP[] } @Override
private Set < Map . Entry < K , V > > getEntrySet () { if ( entrySet == null ) { entrySet = parent . decorated () . entrySet () ; MST[NonVoidMethodCallMutator]MSP[] } return entrySet ; } @Override public int size () {
public void clear () { this . parent . clear () ; } @Override public boolean equals ( final Object obj ) { if ( obj == this ) { MST[NegateConditionalsMutator]MSP[] return true ; } return getEntrySet () . equals ( obj ) ; } @Override public int hashCode () {
private Set < Map . Entry < K , V > > getEntrySet () { if ( entrySet == null ) { MST[NegateConditionalsMutator]MSP[] entrySet = parent . decorated () . entrySet () ; } return entrySet ; } @Override public int size () {
public boolean containsAll ( final Collection < ? > coll ) { return getEntrySet () . containsAll ( coll ) ; } @Override @SuppressWarnings ( lr_1 ) public boolean remove ( final Object obj ) { if ( obj instanceof Map . Entry == false ) { MST[rv.ROR3Mutator]MSP[] return false ;
return getEntrySet () . hashCode () ; MST[ReturnValsMutator]MSP[] } @Override public String toString () { return getEntrySet () . toString () ; } @Override public Iterator < Map . Entry < K , V > > iterator () { return new ListOrderedIterator <> ( parent , insertOrder ) ; } @Override
public boolean containsAll ( final Collection < ? > coll ) { return getEntrySet () . containsAll ( coll ) ; } @Override @SuppressWarnings ( lr_1 ) public boolean remove ( final Object obj ) { if ( obj instanceof Map . Entry == false ) { MST[rv.ROR1Mutator]MSP[] return false ;
public boolean containsAll ( final Collection < ? > coll ) { return getEntrySet () . containsAll ( coll ) ; } @Override @SuppressWarnings ( lr_1 ) public boolean remove ( final Object obj ) { if ( obj instanceof Map . Entry == false ) { MST[rv.ROR5Mutator]MSP[] return false ;
public void clear () { this . parent . clear () ; } @Override public boolean equals ( final Object obj ) { if ( obj == this ) { return true ; } return getEntrySet () . equals ( obj ) ; MST[BooleanFalseReturnValsMutator]MSP[] } @Override public int hashCode () {
public void clear () { this . parent . clear () ; } @Override public boolean equals ( final Object obj ) { if ( obj == this ) { return true ; } return getEntrySet () . equals ( obj ) ; MST[NonVoidMethodCallMutator]MSP[] } @Override public int hashCode () {
private Set < Map . Entry < K , V > > getEntrySet () { if ( entrySet == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] entrySet = parent . decorated () . entrySet () ; } return entrySet ; } @Override public int size () {
return getEntrySet () . hashCode () ; } @Override public String toString () { return getEntrySet () . toString () ; MST[NonVoidMethodCallMutator]MSP[] } @Override public Iterator < Map . Entry < K , V > > iterator () { return new ListOrderedIterator <> ( parent , insertOrder ) ; } @Override
public void clear () { this . parent . clear () ; } @Override public boolean equals ( final Object obj ) { if ( obj == this ) { return true ; } return getEntrySet () . equals ( obj ) ; MST[BooleanTrueReturnValsMutator]MSP[] } @Override public int hashCode () {
return getEntrySet () . hashCode () ; MST[PrimitiveReturnsMutator]MSP[] } @Override public String toString () { return getEntrySet () . toString () ; } @Override public Iterator < Map . Entry < K , V > > iterator () { return new ListOrderedIterator <> ( parent , insertOrder ) ; } @Override
private Set < Map . Entry < K , V > > getEntrySet () { if ( entrySet == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] entrySet = parent . decorated () . entrySet () ; } return entrySet ; } @Override public int size () {
return getEntrySet () . hashCode () ; } @Override public String toString () { return getEntrySet () . toString () ; MST[EmptyObjectReturnValsMutator]MSP[] } @Override public Iterator < Map . Entry < K , V > > iterator () { return new ListOrderedIterator <> ( parent , insertOrder ) ; } @Override
public boolean containsAll ( final Collection < ? > coll ) { return getEntrySet () . containsAll ( coll ) ; } @Override @SuppressWarnings ( lr_1 ) public boolean remove ( final Object obj ) { if ( obj instanceof Map . Entry == false ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return false ;
return this . parent . size () ; MST[NonVoidMethodCallMutator]MSP[] } @Override public boolean isEmpty () { return this . parent . isEmpty () ; } @Override public boolean contains ( final Object obj ) { return getEntrySet () . contains ( obj ) ; } @Override
private Set < Map . Entry < K , V > > getEntrySet () { if ( entrySet == null ) { entrySet = parent . decorated () . entrySet () ; MST[experimental.MemberVariableMutator]MSP[] } return entrySet ; } @Override public int size () {
public void clear () { this . parent . clear () ; } @Override public boolean equals ( final Object obj ) { if ( obj == this ) { MST[rv.ROR5Mutator]MSP[] return true ; } return getEntrySet () . equals ( obj ) ; } @Override public int hashCode () {
return getEntrySet () . hashCode () ; } @Override public String toString () { return getEntrySet () . toString () ; } @Override public Iterator < Map . Entry < K , V > > iterator () { return new ListOrderedIterator <> ( parent , insertOrder ) ; MST[ConstructorCallMutator]MSP[] } @Override
return getEntrySet () . hashCode () ; } @Override public String toString () { return getEntrySet () . toString () ; } @Override public Iterator < Map . Entry < K , V > > iterator () { return new ListOrderedIterator <> ( parent , insertOrder ) ; MST[ReturnValsMutator]MSP[] } @Override
public boolean containsAll ( final Collection < ? > coll ) { return getEntrySet () . containsAll ( coll ) ; } @Override @SuppressWarnings ( lr_1 ) public boolean remove ( final Object obj ) { if ( obj instanceof Map . Entry == false ) { MST[rv.ROR2Mutator]MSP[] return false ;
return this . parent . size () ; } @Override public boolean isEmpty () { return this . parent . isEmpty () ; } @Override public boolean contains ( final Object obj ) { return getEntrySet () . contains ( obj ) ; MST[ReturnValsMutator]MSP[] } @Override
return this . parent . size () ; } @Override public boolean isEmpty () { return this . parent . isEmpty () ; MST[BooleanFalseReturnValsMutator]MSP[] } @Override public boolean contains ( final Object obj ) { return getEntrySet () . contains ( obj ) ; } @Override
public boolean containsAll ( final Collection < ? > coll ) { return getEntrySet () . containsAll ( coll ) ; MST[ReturnValsMutator]MSP[] } @Override @SuppressWarnings ( lr_1 ) public boolean remove ( final Object obj ) { if ( obj instanceof Map . Entry == false ) { return false ;
public boolean containsAll ( final Collection < ? > coll ) { return getEntrySet () . containsAll ( coll ) ; MST[BooleanTrueReturnValsMutator]MSP[] } @Override @SuppressWarnings ( lr_1 ) public boolean remove ( final Object obj ) { if ( obj instanceof Map . Entry == false ) { return false ;
return this . parent . size () ; } @Override public boolean isEmpty () { return this . parent . isEmpty () ; MST[ReturnValsMutator]MSP[] } @Override public boolean contains ( final Object obj ) { return getEntrySet () . contains ( obj ) ; } @Override
public boolean containsAll ( final Collection < ? > coll ) { return getEntrySet () . containsAll ( coll ) ; MST[BooleanFalseReturnValsMutator]MSP[] } @Override @SuppressWarnings ( lr_1 ) public boolean remove ( final Object obj ) { if ( obj instanceof Map . Entry == false ) { return false ;
public boolean containsAll ( final Collection < ? > coll ) { return getEntrySet () . containsAll ( coll ) ; MST[NonVoidMethodCallMutator]MSP[] } @Override @SuppressWarnings ( lr_1 ) public boolean remove ( final Object obj ) { if ( obj instanceof Map . Entry == false ) { return false ;
return this . parent . size () ; } @Override public boolean isEmpty () { return this . parent . isEmpty () ; } @Override public boolean contains ( final Object obj ) { return getEntrySet () . contains ( obj ) ; MST[NonVoidMethodCallMutator]MSP[] } @Override
public boolean containsAll ( final Collection < ? > coll ) { return getEntrySet () . containsAll ( coll ) ; } @Override @SuppressWarnings ( lr_1 ) public boolean remove ( final Object obj ) { if ( obj instanceof Map . Entry == false ) { return false ; MST[InlineConstantMutator]MSP[]
return getEntrySet () . hashCode () ; MST[NonVoidMethodCallMutator]MSP[] } @Override public String toString () { return getEntrySet () . toString () ; } @Override public Iterator < Map . Entry < K , V > > iterator () { return new ListOrderedIterator <> ( parent , insertOrder ) ; } @Override
return getEntrySet () . hashCode () ; } @Override public String toString () { return getEntrySet () . toString () ; } @Override public Iterator < Map . Entry < K , V > > iterator () { return new ListOrderedIterator <> ( parent , insertOrder ) ; MST[NullReturnValsMutator]MSP[] } @Override
public void clear () { this . parent . clear () ; } @Override public boolean equals ( final Object obj ) { if ( obj == this ) { return true ; } return getEntrySet () . equals ( obj ) ; MST[ReturnValsMutator]MSP[] } @Override public int hashCode () {
return this . parent . size () ; } @Override public boolean isEmpty () { return this . parent . isEmpty () ; MST[BooleanTrueReturnValsMutator]MSP[] } @Override public boolean contains ( final Object obj ) { return getEntrySet () . contains ( obj ) ; } @Override
public void clear () { this . parent . clear () ; } @Override public boolean equals ( final Object obj ) { if ( obj == this ) { return true ; } return getEntrySet () . equals ( obj ) ; MST[NonVoidMethodCallMutator]MSP[] } @Override public int hashCode () {
return getEntrySet () . hashCode () ; } @Override public String toString () { return getEntrySet () . toString () ; MST[ReturnValsMutator]MSP[] } @Override public Iterator < Map . Entry < K , V > > iterator () { return new ListOrderedIterator <> ( parent , insertOrder ) ; } @Override
public boolean containsAll ( final Collection < ? > coll ) { return getEntrySet () . containsAll ( coll ) ; } @Override @SuppressWarnings ( lr_1 ) public boolean remove ( final Object obj ) { if ( obj instanceof Map . Entry == false ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return false ;
return this . parent . size () ; MST[ReturnValsMutator]MSP[] } @Override public boolean isEmpty () { return this . parent . isEmpty () ; } @Override public boolean contains ( final Object obj ) { return getEntrySet () . contains ( obj ) ; } @Override
public void clear () { this . parent . clear () ; MST[VoidMethodCallMutator]MSP[] } @Override public boolean equals ( final Object obj ) { if ( obj == this ) { return true ; } return getEntrySet () . equals ( obj ) ; } @Override public int hashCode () {
return getEntrySet () . hashCode () ; MST[NonVoidMethodCallMutator]MSP[] } @Override public String toString () { return getEntrySet () . toString () ; } @Override public Iterator < Map . Entry < K , V > > iterator () { return new ListOrderedIterator <> ( parent , insertOrder ) ; } @Override
public void clear () { this . parent . clear () ; } @Override public boolean equals ( final Object obj ) { if ( obj == this ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return true ; } return getEntrySet () . equals ( obj ) ; } @Override public int hashCode () {
public boolean containsAll ( final Collection < ? > coll ) { return getEntrySet () . containsAll ( coll ) ; } @Override @SuppressWarnings ( lr_1 ) public boolean remove ( final Object obj ) { if ( obj instanceof Map . Entry == false ) { MST[NegateConditionalsMutator]MSP[] return false ;
private Set < Map . Entry < K , V > > getEntrySet () { if ( entrySet == null ) { entrySet = parent . decorated () . entrySet () ; MST[NonVoidMethodCallMutator]MSP[] } return entrySet ; } @Override public int size () {
private Set < Map . Entry < K , V > > getEntrySet () { if ( entrySet == null ) { entrySet = parent . decorated () . entrySet () ; } return entrySet ; MST[EmptyObjectReturnValsMutator]MSP[] } @Override public int size () {
private Set < Map . Entry < K , V > > getEntrySet () { if ( entrySet == null ) { MST[rv.ROR5Mutator]MSP[] entrySet = parent . decorated () . entrySet () ; } return entrySet ; } @Override public int size () {
public boolean containsAll ( final Collection < ? > coll ) { return getEntrySet () . containsAll ( coll ) ; } @Override @SuppressWarnings ( lr_1 ) public boolean remove ( final Object obj ) { if ( obj instanceof Map . Entry == false ) { MST[rv.ROR4Mutator]MSP[] return false ;
return parent . decorated () . put ( getKey () , value ) ; MST[ReturnValsMutator]MSP[] } @Override public boolean hasNext () { return iterator . hasNext () ; } @Override public K next () { last = iterator . next () ; readable = true ; return last ; } @Override
parent . decorated () . remove ( last ) ; } @Override public V getValue () { return parent . get ( getKey () ) ; MST[ArgumentPropagationMutator]MSP[] } @Override public V setValue ( final V value ) {
return parent . decorated () . put ( getKey () , value ) ; MST[NonVoidMethodCallMutator]MSP[] } @Override public boolean hasNext () { return iterator . hasNext () ; } @Override public K next () { last = iterator . next () ; readable = true ; return last ; } @Override
parent . decorated () . remove ( last ) ; } @Override public V getValue () { return parent . get ( getKey () ) ; MST[ReturnValsMutator]MSP[] } @Override public V setValue ( final V value ) {
return parent . decorated () . put ( getKey () , value ) ; MST[NonVoidMethodCallMutator]MSP[] } @Override public boolean hasNext () { return iterator . hasNext () ; } @Override public K next () { last = iterator . next () ; readable = true ; return last ; } @Override
parent . decorated () . remove ( last ) ; } @Override public V getValue () { return parent . get ( getKey () ) ; MST[NullReturnValsMutator]MSP[] } @Override public V setValue ( final V value ) {
return parent . decorated () . put ( getKey () , value ) ; MST[NonVoidMethodCallMutator]MSP[] } @Override public boolean hasNext () { return iterator . hasNext () ; } @Override public K next () { last = iterator . next () ; readable = true ; return last ; } @Override
return parent . decorated () . put ( getKey () , value ) ; MST[ArgumentPropagationMutator]MSP[] } @Override public boolean hasNext () { return iterator . hasNext () ; } @Override public K next () { last = iterator . next () ; readable = true ; return last ; } @Override
parent . decorated () . remove ( last ) ; } @Override public V getValue () { return parent . get ( getKey () ) ; MST[NonVoidMethodCallMutator]MSP[] } @Override public V setValue ( final V value ) {
parent . decorated () . remove ( last ) ; } @Override public V getValue () { return parent . get ( getKey () ) ; MST[NonVoidMethodCallMutator]MSP[] } @Override public V setValue ( final V value ) {
return parent . decorated () . put ( getKey () , value ) ; MST[NullReturnValsMutator]MSP[] } @Override public boolean hasNext () { return iterator . hasNext () ; } @Override public K next () { last = iterator . next () ; readable = true ; return last ; } @Override
return UnmodifiableList . unmodifiableList ( insertOrder ) ; } @Override public Collection < V > values () { return new ValuesView <> ( this ) ; MST[ConstructorCallMutator]MSP[] } public List < V > valueList () { return new ValuesView <> ( this ) ; } @Override
if ( index < 0 || index > insertOrder . size () ) { MST[rv.ABSMutator]MSP[] throw new IndexOutOfBoundsException ( lr_3 + index + lr_4 + insertOrder . size () ) ; } final Map < K , V > m = decorated () ;
out . writeObject ( map ) ; } @SuppressWarnings ( lr_1 ) private void readObject ( final ObjectInputStream in ) throws IOException , ClassNotFoundException { in . defaultReadObject () ; map = ( Map < K , V > ) in . readObject () ; MST[NonVoidMethodCallMutator]MSP[] } @Override
buf . append ( value == this ? lr_7 : value ) ; } buf . append ( '}' ) ; MST[NonVoidMethodCallMutator]MSP[] return buf . toString () ; } public K get ( final int index ) { return insertOrder . get ( index ) ; }
final V value = entry . getValue () ; if ( first ) { MST[rv.ROR1Mutator]MSP[] first = false ; } else { buf . append ( lr_6 ) ; } buf . append ( key == this ? lr_7 : key ) ; buf . append ( '=' ) ;
final V value = entry . getValue () ; if ( first ) { MST[rv.ROR5Mutator]MSP[] first = false ; } else { buf . append ( lr_6 ) ; } buf . append ( key == this ? lr_7 : key ) ; buf . append ( '=' ) ;
if ( index < 0 || index > insertOrder . size () ) { throw new IndexOutOfBoundsException ( lr_3 + index + lr_4 + insertOrder . size () ) ; MST[experimental.NakedReceiverMutator]MSP[] } final Map < K , V > m = decorated () ;
final int index = insertOrder . indexOf ( key ) ; if ( index >= 0 && index < size () - 1 ) { return insertOrder . get ( index + 1 ) ; MST[rv.CRCR6Mutator]MSP[] } return null ; } @Override public K previousKey ( final Object key ) {
buf . append ( value == this ? lr_7 : value ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] } buf . append ( '}' ) ; return buf . toString () ; } public K get ( final int index ) { return insertOrder . get ( index ) ; }
buf . append ( value == this ? lr_7 : value ) ; } buf . append ( '}' ) ; MST[experimental.NakedReceiverMutator]MSP[] return buf . toString () ; } public K get ( final int index ) { return insertOrder . get ( index ) ; }
if ( decorated () . containsKey ( key ) ) { MST[NonVoidMethodCallMutator]MSP[] return decorated () . put ( key , value ) ; } final V result = decorated () . put ( key , value ) ; insertOrder . add ( key ) ; return result ; } @Override
public V getValue ( final int index ) { return get ( insertOrder . get ( index ) ) ; MST[rv.UOI1Mutator]MSP[] } public int indexOf ( final Object key ) { return insertOrder . indexOf ( key ) ; }
public Set < Map . Entry < K , V > > entrySet () { return new EntrySetView <> ( this , this . insertOrder ) ; } @Override public String toString () { if ( isEmpty () ) { MST[NegateConditionalsMutator]MSP[] return lr_5 ; }
final V value = entry . getValue () ; if ( first ) { first = false ; } else { buf . append ( lr_6 ) ; } buf . append ( key == this ? lr_7 : key ) ; buf . append ( '=' ) ; MST[rv.CRCR4Mutator]MSP[]
if ( index < 0 || index > insertOrder . size () ) { throw new IndexOutOfBoundsException ( lr_3 + index + lr_4 + insertOrder . size () ) ; MST[NonVoidMethodCallMutator]MSP[] } final Map < K , V > m = decorated () ;
insertOrder . add ( index , key ) ; m . put ( key , value ) ; return result ; } insertOrder . add ( index , key ) ; MST[rv.UOI4Mutator]MSP[] m . put ( key , value ) ; return null ; }
if ( decorated () . containsKey ( key ) ) { return decorated () . put ( key , value ) ; MST[ReturnValsMutator]MSP[] } final V result = decorated () . put ( key , value ) ; insertOrder . add ( key ) ; return result ; } @Override
final int index = insertOrder . indexOf ( key ) ; if ( index >= 0 && index < size () - 1 ) { return insertOrder . get ( index + 1 ) ; MST[rv.AOD1Mutator]MSP[] } return null ; } @Override public K previousKey ( final Object key ) {
final int index = insertOrder . indexOf ( key ) ; if ( index >= 0 && index < size () - 1 ) { MST[rv.UOI3Mutator]MSP[] return insertOrder . get ( index + 1 ) ; } return null ; } @Override public K previousKey ( final Object key ) {
return UnmodifiableList . unmodifiableList ( insertOrder ) ; MST[EmptyObjectReturnValsMutator]MSP[] } @Override public Collection < V > values () { return new ValuesView <> ( this ) ; } public List < V > valueList () { return new ValuesView <> ( this ) ; } @Override
final V value = entry . getValue () ; if ( first ) { first = false ; MST[rv.CRCR1Mutator]MSP[] } else { buf . append ( lr_6 ) ; } buf . append ( key == this ? lr_7 : key ) ; buf . append ( '=' ) ;
public V remove ( final int index ) { return remove ( get ( index ) ) ; MST[rv.UOI4Mutator]MSP[] } public List < K > asList () { return keyList () ; } @Override public int size () { return this . parent . size () ; } @Override
final boolean contains = containsKey ( key ) ; put ( index , entry . getKey () , entry . getValue () ) ; if ( ! contains ) { MST[rv.ROR4Mutator]MSP[] index ++ ; } else { index = indexOf ( entry . getKey () ) + 1 ; } }
buf . append ( value == this ? lr_7 : value ) ; } buf . append ( '}' ) ; MST[rv.CRCR2Mutator]MSP[] return buf . toString () ; } public K get ( final int index ) { return insertOrder . get ( index ) ; }
return UnmodifiableList . unmodifiableList ( insertOrder ) ; } @Override public Collection < V > values () { return new ValuesView <> ( this ) ; } public List < V > valueList () { return new ValuesView <> ( this ) ; MST[ConstructorCallMutator]MSP[] } @Override
final int index = insertOrder . indexOf ( key ) ; if ( index >= 0 && index < size () - 1 ) { return insertOrder . get ( index + 1 ) ; MST[rv.CRCR2Mutator]MSP[] } return null ; } @Override public K previousKey ( final Object key ) {
final int index = insertOrder . indexOf ( key ) ; if ( index > 0 ) { return insertOrder . get ( index - 1 ) ; MST[rv.UOI1Mutator]MSP[] } return null ; } @Override public V put ( final K key , final V value ) {
final int index = insertOrder . indexOf ( key ) ; if ( index >= 0 && index < size () - 1 ) { MST[rv.CRCR4Mutator]MSP[] return insertOrder . get ( index + 1 ) ; } return null ; } @Override public K previousKey ( final Object key ) {
final V value = entry . getValue () ; if ( first ) { first = false ; MST[rv.CRCR5Mutator]MSP[] } else { buf . append ( lr_6 ) ; } buf . append ( key == this ? lr_7 : key ) ; buf . append ( '=' ) ;
@Override public K lastKey () { if ( size () == 0 ) { MST[rv.ROR2Mutator]MSP[] throw new NoSuchElementException ( lr_2 ) ; } return insertOrder . get ( size () - 1 ) ; } @Override public K nextKey ( final Object key ) {
final V value = entry . getValue () ; if ( first ) { MST[NegateConditionalsMutator]MSP[] first = false ; } else { buf . append ( lr_6 ) ; } buf . append ( key == this ? lr_7 : key ) ; buf . append ( '=' ) ;
if ( index < 0 || index > insertOrder . size () ) { MST[rv.ROR4Mutator]MSP[] throw new IndexOutOfBoundsException ( lr_3 + index + lr_4 + insertOrder . size () ) ; } final Map < K , V > m = decorated () ;
public Set < Map . Entry < K , V > > entrySet () { return new EntrySetView <> ( this , this . insertOrder ) ; } @Override public String toString () { if ( isEmpty () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return lr_5 ; }
@Override public K lastKey () { if ( size () == 0 ) { throw new NoSuchElementException ( lr_2 ) ; MST[ConstructorCallMutator]MSP[] } return insertOrder . get ( size () - 1 ) ; } @Override public K nextKey ( final Object key ) {
throw new IndexOutOfBoundsException ( lr_3 + index + lr_4 + insertOrder . size () ) ; } for ( final Map . Entry < ? extends K , ? extends V > entry : map . entrySet () ) { MST[NonVoidMethodCallMutator]MSP[] final K key = entry . getKey () ;
final int index = insertOrder . indexOf ( key ) ; if ( index > 0 ) { return insertOrder . get ( index - 1 ) ; MST[rv.AOR2Mutator]MSP[] } return null ; } @Override public V put ( final K key , final V value ) {
buf . append ( value == this ? lr_7 : value ) ; } buf . append ( '}' ) ; MST[rv.CRCR6Mutator]MSP[] return buf . toString () ; } public K get ( final int index ) { return insertOrder . get ( index ) ; }
if ( index < 0 || index > insertOrder . size () ) { MST[ConditionalsBoundaryMutator]MSP[] throw new IndexOutOfBoundsException ( lr_3 + index + lr_4 + insertOrder . size () ) ; } final Map < K , V > m = decorated () ;
final V value = entry . getValue () ; if ( first ) { MST[rv.UOI4Mutator]MSP[] first = false ; } else { buf . append ( lr_6 ) ; } buf . append ( key == this ? lr_7 : key ) ; buf . append ( '=' ) ;
buf . append ( value == this ? lr_7 : value ) ; } buf . append ( '}' ) ; MST[InlineConstantMutator]MSP[] return buf . toString () ; } public K get ( final int index ) { return insertOrder . get ( index ) ; }
final int index = insertOrder . indexOf ( key ) ; if ( index > 0 ) { MST[rv.UOI4Mutator]MSP[] return insertOrder . get ( index - 1 ) ; } return null ; } @Override public V put ( final K key , final V value ) {
public Set < Map . Entry < K , V > > entrySet () { return new EntrySetView <> ( this , this . insertOrder ) ; MST[ConstructorCallMutator]MSP[] } @Override public String toString () { if ( isEmpty () ) { return lr_5 ; }
final StringBuilder buf = new StringBuilder () ; buf . append ( '{' ) ; boolean first = true ; MST[rv.CRCR5Mutator]MSP[] for ( final Map . Entry < K , V > entry : entrySet () ) { final K key = entry . getKey () ;
final int index = insertOrder . indexOf ( key ) ; if ( index >= 0 && index < size () - 1 ) { MST[rv.ROR4Mutator]MSP[] return insertOrder . get ( index + 1 ) ; } return null ; } @Override public K previousKey ( final Object key ) {
final int index = insertOrder . indexOf ( key ) ; if ( index > 0 ) { MST[NegateConditionalsMutator]MSP[] return insertOrder . get ( index - 1 ) ; } return null ; } @Override public V put ( final K key , final V value ) {
throw new IndexOutOfBoundsException ( lr_3 + index + lr_4 + insertOrder . size () ) ; MST[NonVoidMethodCallMutator]MSP[] } for ( final Map . Entry < ? extends K , ? extends V > entry : map . entrySet () ) { final K key = entry . getKey () ;
public Set < Map . Entry < K , V > > entrySet () { return new EntrySetView <> ( this , this . insertOrder ) ; } @Override public String toString () { if ( isEmpty () ) { MST[rv.ROR5Mutator]MSP[] return lr_5 ; }
public void clear () { decorated () . clear () ; MST[VoidMethodCallMutator]MSP[] insertOrder . clear () ; } @Override public Set < K > keySet () { return new KeySetView <> ( this ) ; } public List < K > keyList () {
public Set < Map . Entry < K , V > > entrySet () { return new EntrySetView <> ( this , this . insertOrder ) ; } @Override public String toString () { if ( isEmpty () ) { MST[rv.ROR1Mutator]MSP[] return lr_5 ; }
final int index = insertOrder . indexOf ( key ) ; if ( index > 0 ) { MST[rv.ROR5Mutator]MSP[] return insertOrder . get ( index - 1 ) ; } return null ; } @Override public V put ( final K key , final V value ) {
if ( m . containsKey ( key ) ) { MST[rv.ROR4Mutator]MSP[] final V result = m . remove ( key ) ; final int pos = insertOrder . indexOf ( key ) ; insertOrder . remove ( pos ) ; if ( pos < index ) { index -- ; }
put ( entry . getKey () , entry . getValue () ) ; } } public void putAll ( int index , final Map < ? extends K , ? extends V > map ) { if ( index < 0 || index > insertOrder . size () ) { MST[NegateConditionalsMutator]MSP[]
buf . append ( value == this ? lr_7 : value ) ; } buf . append ( '}' ) ; return buf . toString () ; } public K get ( final int index ) { return insertOrder . get ( index ) ; MST[NonVoidMethodCallMutator]MSP[] }
public V remove ( final int index ) { return remove ( get ( index ) ) ; } public List < K > asList () { return keyList () ; MST[ReturnValsMutator]MSP[] } @Override public int size () { return this . parent . size () ; } @Override
public OrderedMapIterator < K , V > mapIterator () { return new ListOrderedMapIterator <> ( this ) ; } @Override public K firstKey () { if ( size () == 0 ) { throw new NoSuchElementException ( lr_2 ) ; } return insertOrder . get ( 0 ) ; MST[rv.CRCR3Mutator]MSP[] }
final int index = insertOrder . indexOf ( key ) ; if ( index >= 0 && index < size () - 1 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[] return insertOrder . get ( index + 1 ) ; } return null ; } @Override public K previousKey ( final Object key ) {
throw new IndexOutOfBoundsException ( lr_3 + index + lr_4 + insertOrder . size () ) ; MST[experimental.NakedReceiverMutator]MSP[] } for ( final Map . Entry < ? extends K , ? extends V > entry : map . entrySet () ) { final K key = entry . getKey () ;
final int index = insertOrder . indexOf ( key ) ; if ( index > 0 ) { MST[rv.ROR1Mutator]MSP[] return insertOrder . get ( index - 1 ) ; } return null ; } @Override public V put ( final K key , final V value ) {
return UnmodifiableList . unmodifiableList ( insertOrder ) ; } @Override public Collection < V > values () { return new ValuesView <> ( this ) ; } public List < V > valueList () { return new ValuesView <> ( this ) ; MST[EmptyObjectReturnValsMutator]MSP[] } @Override
final int index = insertOrder . indexOf ( key ) ; if ( index >= 0 && index < size () - 1 ) { return insertOrder . get ( index + 1 ) ; MST[NonVoidMethodCallMutator]MSP[] } return null ; } @Override public K previousKey ( final Object key ) {
if ( decorated () . containsKey ( key ) ) { return decorated () . put ( key , value ) ; MST[ArgumentPropagationMutator]MSP[] } final V result = decorated () . put ( key , value ) ; insertOrder . add ( key ) ; return result ; } @Override
final int index = insertOrder . indexOf ( key ) ; if ( index >= 0 && index < size () - 1 ) { MST[ConditionalsBoundaryMutator]MSP[] return insertOrder . get ( index + 1 ) ; } return null ; } @Override public K previousKey ( final Object key ) {
if ( index < 0 || index > insertOrder . size () ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[] throw new IndexOutOfBoundsException ( lr_3 + index + lr_4 + insertOrder . size () ) ; } final Map < K , V > m = decorated () ;
buf . append ( value == this ? lr_7 : value ) ; } buf . append ( '}' ) ; return buf . toString () ; } public K get ( final int index ) { return insertOrder . get ( index ) ; MST[rv.UOI2Mutator]MSP[] }
if ( index < 0 || index > insertOrder . size () ) { MST[rv.UOI2Mutator]MSP[] throw new IndexOutOfBoundsException ( lr_3 + index + lr_4 + insertOrder . size () ) ; } final Map < K , V > m = decorated () ;
public OrderedMapIterator < K , V > mapIterator () { return new ListOrderedMapIterator <> ( this ) ; } @Override public K firstKey () { if ( size () == 0 ) { throw new NoSuchElementException ( lr_2 ) ; } return insertOrder . get ( 0 ) ; MST[InlineConstantMutator]MSP[] }
final V value = entry . getValue () ; if ( first ) { first = false ; } else { buf . append ( lr_6 ) ; MST[experimental.NakedReceiverMutator]MSP[] } buf . append ( key == this ? lr_7 : key ) ; buf . append ( '=' ) ;
public OrderedMapIterator < K , V > mapIterator () { return new ListOrderedMapIterator <> ( this ) ; } @Override public K firstKey () { if ( size () == 0 ) { MST[rv.ROR4Mutator]MSP[] throw new NoSuchElementException ( lr_2 ) ; } return insertOrder . get ( 0 ) ; }
put ( entry . getKey () , entry . getValue () ) ; MST[NonVoidMethodCallMutator]MSP[] } } public void putAll ( int index , final Map < ? extends K , ? extends V > map ) { if ( index < 0 || index > insertOrder . size () ) {
if ( index < 0 || index > insertOrder . size () ) { MST[rv.ROR2Mutator]MSP[] throw new IndexOutOfBoundsException ( lr_3 + index + lr_4 + insertOrder . size () ) ; } final Map < K , V > m = decorated () ;
if ( index < 0 || index > insertOrder . size () ) { throw new IndexOutOfBoundsException ( lr_3 + index + lr_4 + insertOrder . size () ) ; MST[rv.UOI2Mutator]MSP[] } final Map < K , V > m = decorated () ;
final int index = insertOrder . indexOf ( key ) ; if ( index > 0 ) { return insertOrder . get ( index - 1 ) ; MST[rv.CRCR2Mutator]MSP[] } return null ; } @Override public V put ( final K key , final V value ) {
final int index = insertOrder . indexOf ( key ) ; if ( index >= 0 && index < size () - 1 ) { return insertOrder . get ( index + 1 ) ; MST[rv.UOI2Mutator]MSP[] } return null ; } @Override public K previousKey ( final Object key ) {
public OrderedMapIterator < K , V > mapIterator () { return new ListOrderedMapIterator <> ( this ) ; } @Override public K firstKey () { if ( size () == 0 ) { MST[rv.ROR1Mutator]MSP[] throw new NoSuchElementException ( lr_2 ) ; } return insertOrder . get ( 0 ) ; }
if ( index < 0 || index > insertOrder . size () ) { throw new IndexOutOfBoundsException ( lr_3 + index + lr_4 + insertOrder . size () ) ; MST[experimental.NakedReceiverMutator]MSP[] } final Map < K , V > m = decorated () ;
final int index = insertOrder . indexOf ( key ) ; if ( index >= 0 && index < size () - 1 ) { return insertOrder . get ( index + 1 ) ; MST[InlineConstantMutator]MSP[] } return null ; } @Override public K previousKey ( final Object key ) {
final StringBuilder buf = new StringBuilder () ; buf . append ( '{' ) ; MST[rv.CRCR3Mutator]MSP[] boolean first = true ; for ( final Map . Entry < K , V > entry : entrySet () ) { final K key = entry . getKey () ;
throw new IndexOutOfBoundsException ( lr_3 + index + lr_4 + insertOrder . size () ) ; MST[rv.ABSMutator]MSP[] } for ( final Map . Entry < ? extends K , ? extends V > entry : map . entrySet () ) { final K key = entry . getKey () ;
if ( decorated () . containsKey ( key ) ) { MST[NonVoidMethodCallMutator]MSP[] return decorated () . put ( key , value ) ; } final V result = decorated () . put ( key , value ) ; insertOrder . add ( key ) ; return result ; } @Override
public void putAll ( final Map < ? extends K , ? extends V > map ) { for ( final Map . Entry < ? extends K , ? extends V > entry : map . entrySet () ) { MST[NonVoidMethodCallMutator]MSP[]
if ( index < 0 || index > insertOrder . size () ) { throw new IndexOutOfBoundsException ( lr_3 + index + lr_4 + insertOrder . size () ) ; MST[NonVoidMethodCallMutator]MSP[] } final Map < K , V > m = decorated () ;
put ( entry . getKey () , entry . getValue () ) ; } } public void putAll ( int index , final Map < ? extends K , ? extends V > map ) { if ( index < 0 || index > insertOrder . size () ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[]
final int index = insertOrder . indexOf ( key ) ; if ( index >= 0 && index < size () - 1 ) { MST[rv.UOI3Mutator]MSP[] return insertOrder . get ( index + 1 ) ; } return null ; } @Override public K previousKey ( final Object key ) {
if ( decorated () . containsKey ( key ) ) { MST[NegateConditionalsMutator]MSP[] return decorated () . put ( key , value ) ; } final V result = decorated () . put ( key , value ) ; insertOrder . add ( key ) ; return result ; } @Override
put ( entry . getKey () , entry . getValue () ) ; } } public void putAll ( int index , final Map < ? extends K , ? extends V > map ) { if ( index < 0 || index > insertOrder . size () ) { MST[rv.ROR5Mutator]MSP[]
insertOrder . add ( index , key ) ; m . put ( key , value ) ; return result ; } insertOrder . add ( index , key ) ; m . put ( key , value ) ; MST[NonVoidMethodCallMutator]MSP[] return null ; }
final boolean contains = containsKey ( key ) ; put ( index , entry . getKey () , entry . getValue () ) ; MST[NonVoidMethodCallMutator]MSP[] if ( ! contains ) { index ++ ; } else { index = indexOf ( entry . getKey () ) + 1 ; } }
final int index = insertOrder . indexOf ( key ) ; if ( index > 0 ) { MST[rv.UOI3Mutator]MSP[] return insertOrder . get ( index - 1 ) ; } return null ; } @Override public V put ( final K key , final V value ) {
put ( entry . getKey () , entry . getValue () ) ; } } public void putAll ( int index , final Map < ? extends K , ? extends V > map ) { if ( index < 0 || index > insertOrder . size () ) { MST[ConditionalsBoundaryMutator]MSP[]
final int index = insertOrder . indexOf ( key ) ; MST[NonVoidMethodCallMutator]MSP[] if ( index > 0 ) { return insertOrder . get ( index - 1 ) ; } return null ; } @Override public V put ( final K key , final V value ) {
if ( index < 0 || index > insertOrder . size () ) { throw new IndexOutOfBoundsException ( lr_3 + index + lr_4 + insertOrder . size () ) ; MST[ConstructorCallMutator]MSP[] } final Map < K , V > m = decorated () ;
final V value = entry . getValue () ; if ( first ) { first = false ; } else { buf . append ( lr_6 ) ; } buf . append ( key == this ? lr_7 : key ) ; MST[experimental.NakedReceiverMutator]MSP[] buf . append ( '=' ) ;
throw new IndexOutOfBoundsException ( lr_3 + index + lr_4 + insertOrder . size () ) ; } for ( final Map . Entry < ? extends K , ? extends V > entry : map . entrySet () ) { final K key = entry . getKey () ; MST[NonVoidMethodCallMutator]MSP[]
public Set < Map . Entry < K , V > > entrySet () { return new EntrySetView <> ( this , this . insertOrder ) ; MST[EmptyObjectReturnValsMutator]MSP[] } @Override public String toString () { if ( isEmpty () ) { return lr_5 ; }
final boolean contains = containsKey ( key ) ; put ( index , entry . getKey () , entry . getValue () ) ; MST[rv.UOI4Mutator]MSP[] if ( ! contains ) { index ++ ; } else { index = indexOf ( entry . getKey () ) + 1 ; } }
if ( index < 0 || index > insertOrder . size () ) { MST[rv.ROR3Mutator]MSP[] throw new IndexOutOfBoundsException ( lr_3 + index + lr_4 + insertOrder . size () ) ; } final Map < K , V > m = decorated () ;
put ( entry . getKey () , entry . getValue () ) ; } } public void putAll ( int index , final Map < ? extends K , ? extends V > map ) { if ( index < 0 || index > insertOrder . size () ) { MST[rv.ABSMutator]MSP[]
public V setValue ( final int index , final V value ) { final K key = insertOrder . get ( index ) ; MST[rv.ABSMutator]MSP[] return put ( key , value ) ; } public V put ( int index , final K key , final V value ) {
final boolean contains = containsKey ( key ) ; put ( index , entry . getKey () , entry . getValue () ) ; if ( ! contains ) { index ++ ; MST[experimental.RemoveIncrementsMutator]MSP[] } else { index = indexOf ( entry . getKey () ) + 1 ; } }
public OrderedMapIterator < K , V > mapIterator () { return new ListOrderedMapIterator <> ( this ) ; } @Override public K firstKey () { if ( size () == 0 ) { MST[NegateConditionalsMutator]MSP[] throw new NoSuchElementException ( lr_2 ) ; } return insertOrder . get ( 0 ) ; }
@Override public K lastKey () { if ( size () == 0 ) { throw new NoSuchElementException ( lr_2 ) ; } return insertOrder . get ( size () - 1 ) ; MST[rv.AOR2Mutator]MSP[] } @Override public K nextKey ( final Object key ) {
final int index = insertOrder . indexOf ( key ) ; if ( index > 0 ) { return insertOrder . get ( index - 1 ) ; MST[rv.AOR3Mutator]MSP[] } return null ; } @Override public V put ( final K key , final V value ) {
final int index = insertOrder . indexOf ( key ) ; if ( index >= 0 && index < size () - 1 ) { MST[rv.ABSMutator]MSP[] return insertOrder . get ( index + 1 ) ; } return null ; } @Override public K previousKey ( final Object key ) {
public Set < Map . Entry < K , V > > entrySet () { return new EntrySetView <> ( this , this . insertOrder ) ; } @Override public String toString () { if ( isEmpty () ) { MST[rv.ROR4Mutator]MSP[] return lr_5 ; }
final int index = insertOrder . indexOf ( key ) ; if ( index >= 0 && index < size () - 1 ) { MST[rv.ROR3Mutator]MSP[] return insertOrder . get ( index + 1 ) ; } return null ; } @Override public K previousKey ( final Object key ) {
return UnmodifiableList . unmodifiableList ( insertOrder ) ; MST[NonVoidMethodCallMutator]MSP[] } @Override public Collection < V > values () { return new ValuesView <> ( this ) ; } public List < V > valueList () { return new ValuesView <> ( this ) ; } @Override
final int index = insertOrder . indexOf ( key ) ; if ( index >= 0 && index < size () - 1 ) { MST[rv.ROR5Mutator]MSP[] return insertOrder . get ( index + 1 ) ; } return null ; } @Override public K previousKey ( final Object key ) {
if ( decorated () . containsKey ( key ) ) { return decorated () . put ( key , value ) ; MST[NullReturnValsMutator]MSP[] } final V result = decorated () . put ( key , value ) ; insertOrder . add ( key ) ; return result ; } @Override
final int index = insertOrder . indexOf ( key ) ; MST[NonVoidMethodCallMutator]MSP[] if ( index >= 0 && index < size () - 1 ) { return insertOrder . get ( index + 1 ) ; } return null ; } @Override public K previousKey ( final Object key ) {
} @Override public V remove ( final Object key ) { V result = null ; if ( decorated () . containsKey ( key ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] result = decorated () . remove ( key ) ; insertOrder . remove ( key ) ; } return result ; } @Override
put ( entry . getKey () , entry . getValue () ) ; } } public void putAll ( int index , final Map < ? extends K , ? extends V > map ) { if ( index < 0 || index > insertOrder . size () ) { MST[rv.ROR3Mutator]MSP[]
if ( decorated () . containsKey ( key ) ) { MST[rv.ROR4Mutator]MSP[] return decorated () . put ( key , value ) ; } final V result = decorated () . put ( key , value ) ; insertOrder . add ( key ) ; return result ; } @Override
throw new IndexOutOfBoundsException ( lr_3 + index + lr_4 + insertOrder . size () ) ; MST[experimental.NakedReceiverMutator]MSP[] } for ( final Map . Entry < ? extends K , ? extends V > entry : map . entrySet () ) { final K key = entry . getKey () ;
public static < K , V > ListOrderedMap < K , V > listOrderedMap ( final Map < K , V > map ) { MST[experimental.MemberVariableMutator]MSP[] return new ListOrderedMap <> ( map ) ; } private void writeObject ( final ObjectOutputStream out ) throws IOException { out . defaultWriteObject () ;
final int index = insertOrder . indexOf ( key ) ; if ( index >= 0 && index < size () - 1 ) { return insertOrder . get ( index + 1 ) ; MST[rv.AOR2Mutator]MSP[] } return null ; } @Override public K previousKey ( final Object key ) {
final boolean contains = containsKey ( key ) ; put ( index , entry . getKey () , entry . getValue () ) ; MST[NonVoidMethodCallMutator]MSP[] if ( ! contains ) { index ++ ; } else { index = indexOf ( entry . getKey () ) + 1 ; } }
final StringBuilder buf = new StringBuilder () ; MST[ConstructorCallMutator]MSP[] buf . append ( '{' ) ; boolean first = true ; for ( final Map . Entry < K , V > entry : entrySet () ) { final K key = entry . getKey () ;
if ( index < 0 || index > insertOrder . size () ) { MST[rv.UOI2Mutator]MSP[] throw new IndexOutOfBoundsException ( lr_3 + index + lr_4 + insertOrder . size () ) ; } final Map < K , V > m = decorated () ;
final StringBuilder buf = new StringBuilder () ; buf . append ( '{' ) ; boolean first = true ; for ( final Map . Entry < K , V > entry : entrySet () ) { MST[NonVoidMethodCallMutator]MSP[] final K key = entry . getKey () ;
public V remove ( final int index ) { return remove ( get ( index ) ) ; MST[rv.UOI1Mutator]MSP[] } public List < K > asList () { return keyList () ; } @Override public int size () { return this . parent . size () ; } @Override
} @Override public V remove ( final Object key ) { V result = null ; if ( decorated () . containsKey ( key ) ) { result = decorated () . remove ( key ) ; insertOrder . remove ( key ) ; } return result ; MST[ReturnValsMutator]MSP[] } @Override
final boolean contains = containsKey ( key ) ; put ( index , entry . getKey () , entry . getValue () ) ; MST[rv.UOI1Mutator]MSP[] if ( ! contains ) { index ++ ; } else { index = indexOf ( entry . getKey () ) + 1 ; } }
public V setValue ( final int index , final V value ) { final K key = insertOrder . get ( index ) ; MST[rv.UOI1Mutator]MSP[] return put ( key , value ) ; } public V put ( int index , final K key , final V value ) {
if ( m . containsKey ( key ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] final V result = m . remove ( key ) ; final int pos = insertOrder . indexOf ( key ) ; insertOrder . remove ( pos ) ; if ( pos < index ) { index -- ; }
put ( entry . getKey () , entry . getValue () ) ; MST[NonVoidMethodCallMutator]MSP[] } } public void putAll ( int index , final Map < ? extends K , ? extends V > map ) { if ( index < 0 || index > insertOrder . size () ) {
buf . append ( value == this ? lr_7 : value ) ; } buf . append ( '}' ) ; return buf . toString () ; MST[EmptyObjectReturnValsMutator]MSP[] } public K get ( final int index ) { return insertOrder . get ( index ) ; }
if ( index < 0 || index > insertOrder . size () ) { throw new IndexOutOfBoundsException ( lr_3 + index + lr_4 + insertOrder . size () ) ; MST[experimental.NakedReceiverMutator]MSP[] } final Map < K , V > m = decorated () ;
public V getValue ( final int index ) { return get ( insertOrder . get ( index ) ) ; MST[NonVoidMethodCallMutator]MSP[] } public int indexOf ( final Object key ) { return insertOrder . indexOf ( key ) ; }
public V remove ( final int index ) { return remove ( get ( index ) ) ; } public List < K > asList () { return keyList () ; MST[NonVoidMethodCallMutator]MSP[] } @Override public int size () { return this . parent . size () ; } @Override
} @Override public V remove ( final Object key ) { V result = null ; if ( decorated () . containsKey ( key ) ) { MST[NegateConditionalsMutator]MSP[] result = decorated () . remove ( key ) ; insertOrder . remove ( key ) ; } return result ; } @Override
final int index = insertOrder . indexOf ( key ) ; if ( index >= 0 && index < size () - 1 ) { MST[rv.AOD2Mutator]MSP[] return insertOrder . get ( index + 1 ) ; } return null ; } @Override public K previousKey ( final Object key ) {
public void clear () { decorated () . clear () ; insertOrder . clear () ; MST[VoidMethodCallMutator]MSP[] } @Override public Set < K > keySet () { return new KeySetView <> ( this ) ; } public List < K > keyList () {
final int index = insertOrder . indexOf ( key ) ; if ( index > 0 ) { MST[ConditionalsBoundaryMutator]MSP[] return insertOrder . get ( index - 1 ) ; } return null ; } @Override public V put ( final K key , final V value ) {
public V getValue ( final int index ) { return get ( insertOrder . get ( index ) ) ; MST[rv.UOI2Mutator]MSP[] } public int indexOf ( final Object key ) { return insertOrder . indexOf ( key ) ; }
public V getValue ( final int index ) { return get ( insertOrder . get ( index ) ) ; MST[rv.UOI4Mutator]MSP[] } public int indexOf ( final Object key ) { return insertOrder . indexOf ( key ) ; }
insertOrder . add ( index , key ) ; m . put ( key , value ) ; return result ; } insertOrder . add ( index , key ) ; MST[rv.UOI3Mutator]MSP[] m . put ( key , value ) ; return null ; }
final V value = entry . getValue () ; if ( first ) { first = false ; } else { buf . append ( lr_6 ) ; } buf . append ( key == this ? lr_7 : key ) ; buf . append ( '=' ) ; MST[rv.CRCR5Mutator]MSP[]
if ( decorated () . containsKey ( key ) ) { MST[rv.ROR3Mutator]MSP[] return decorated () . put ( key , value ) ; } final V result = decorated () . put ( key , value ) ; insertOrder . add ( key ) ; return result ; } @Override
public OrderedMapIterator < K , V > mapIterator () { return new ListOrderedMapIterator <> ( this ) ; } @Override public K firstKey () { if ( size () == 0 ) { MST[NonVoidMethodCallMutator]MSP[] throw new NoSuchElementException ( lr_2 ) ; } return insertOrder . get ( 0 ) ; }
final int index = insertOrder . indexOf ( key ) ; if ( index > 0 ) { return insertOrder . get ( index - 1 ) ; MST[ReturnValsMutator]MSP[] } return null ; } @Override public V put ( final K key , final V value ) {
if ( index < 0 || index > insertOrder . size () ) { throw new IndexOutOfBoundsException ( lr_3 + index + lr_4 + insertOrder . size () ) ; MST[NonVoidMethodCallMutator]MSP[] } final Map < K , V > m = decorated () ;
@Override public K lastKey () { if ( size () == 0 ) { throw new NoSuchElementException ( lr_2 ) ; } return insertOrder . get ( size () - 1 ) ; MST[NonVoidMethodCallMutator]MSP[] } @Override public K nextKey ( final Object key ) {
final int index = insertOrder . indexOf ( key ) ; if ( index > 0 ) { MST[rv.ROR4Mutator]MSP[] return insertOrder . get ( index - 1 ) ; } return null ; } @Override public V put ( final K key , final V value ) {
if ( m . containsKey ( key ) ) { MST[rv.ROR5Mutator]MSP[] final V result = m . remove ( key ) ; final int pos = insertOrder . indexOf ( key ) ; insertOrder . remove ( pos ) ; if ( pos < index ) { index -- ; }
if ( index < 0 || index > insertOrder . size () ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[] throw new IndexOutOfBoundsException ( lr_3 + index + lr_4 + insertOrder . size () ) ; } final Map < K , V > m = decorated () ;
if ( decorated () . containsKey ( key ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return decorated () . put ( key , value ) ; } final V result = decorated () . put ( key , value ) ; insertOrder . add ( key ) ; return result ; } @Override
final boolean contains = containsKey ( key ) ; put ( index , entry . getKey () , entry . getValue () ) ; if ( ! contains ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] index ++ ; } else { index = indexOf ( entry . getKey () ) + 1 ; } }
out . writeObject ( map ) ; } @SuppressWarnings ( lr_1 ) private void readObject ( final ObjectInputStream in ) throws IOException , ClassNotFoundException { in . defaultReadObject () ; map = ( Map < K , V > ) in . readObject () ; MST[experimental.MemberVariableMutator]MSP[] } @Override
@Override public K lastKey () { if ( size () == 0 ) { throw new NoSuchElementException ( lr_2 ) ; } return insertOrder . get ( size () - 1 ) ; MST[rv.CRCR2Mutator]MSP[] } @Override public K nextKey ( final Object key ) {
buf . append ( value == this ? lr_7 : value ) ; } buf . append ( '}' ) ; return buf . toString () ; } public K get ( final int index ) { return insertOrder . get ( index ) ; MST[rv.UOI3Mutator]MSP[] }
if ( index < 0 || index > insertOrder . size () ) { MST[rv.UOI1Mutator]MSP[] throw new IndexOutOfBoundsException ( lr_3 + index + lr_4 + insertOrder . size () ) ; } final Map < K , V > m = decorated () ;
if ( index < 0 || index > insertOrder . size () ) { MST[rv.ROR5Mutator]MSP[] throw new IndexOutOfBoundsException ( lr_3 + index + lr_4 + insertOrder . size () ) ; } final Map < K , V > m = decorated () ;
final int index = insertOrder . indexOf ( key ) ; if ( index >= 0 && index < size () - 1 ) { MST[rv.ROR1Mutator]MSP[] return insertOrder . get ( index + 1 ) ; } return null ; } @Override public K previousKey ( final Object key ) {
public V getValue ( final int index ) { return get ( insertOrder . get ( index ) ) ; MST[rv.ABSMutator]MSP[] } public int indexOf ( final Object key ) { return insertOrder . indexOf ( key ) ; }
put ( entry . getKey () , entry . getValue () ) ; MST[NonVoidMethodCallMutator]MSP[] } } public void putAll ( int index , final Map < ? extends K , ? extends V > map ) { if ( index < 0 || index > insertOrder . size () ) {
@Override public K lastKey () { if ( size () == 0 ) { throw new NoSuchElementException ( lr_2 ) ; } return insertOrder . get ( size () - 1 ) ; MST[InlineConstantMutator]MSP[] } @Override public K nextKey ( final Object key ) {
@Override public K lastKey () { if ( size () == 0 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] throw new NoSuchElementException ( lr_2 ) ; } return insertOrder . get ( size () - 1 ) ; } @Override public K nextKey ( final Object key ) {
final V value = entry . getValue () ; if ( first ) { MST[rv.UOI3Mutator]MSP[] first = false ; } else { buf . append ( lr_6 ) ; } buf . append ( key == this ? lr_7 : key ) ; buf . append ( '=' ) ;
buf . append ( value == this ? lr_7 : value ) ; } buf . append ( '}' ) ; return buf . toString () ; MST[NonVoidMethodCallMutator]MSP[] } public K get ( final int index ) { return insertOrder . get ( index ) ; }
final int index = insertOrder . indexOf ( key ) ; if ( index > 0 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[] return insertOrder . get ( index - 1 ) ; } return null ; } @Override public V put ( final K key , final V value ) {
if ( m . containsKey ( key ) ) { MST[NegateConditionalsMutator]MSP[] final V result = m . remove ( key ) ; final int pos = insertOrder . indexOf ( key ) ; insertOrder . remove ( pos ) ; if ( pos < index ) { index -- ; }
if ( index < 0 || index > insertOrder . size () ) { throw new IndexOutOfBoundsException ( lr_3 + index + lr_4 + insertOrder . size () ) ; MST[NonVoidMethodCallMutator]MSP[] } final Map < K , V > m = decorated () ;
public Set < Map . Entry < K , V > > entrySet () { return new EntrySetView <> ( this , this . insertOrder ) ; } @Override public String toString () { if ( isEmpty () ) { MST[NonVoidMethodCallMutator]MSP[] return lr_5 ; }
public V remove ( final int index ) { return remove ( get ( index ) ) ; MST[rv.UOI3Mutator]MSP[] } public List < K > asList () { return keyList () ; } @Override public int size () { return this . parent . size () ; } @Override
public static < K , V > ListOrderedMap < K , V > listOrderedMap ( final Map < K , V > map ) { MST[ConstructorCallMutator]MSP[] return new ListOrderedMap <> ( map ) ; } private void writeObject ( final ObjectOutputStream out ) throws IOException { out . defaultWriteObject () ;
final int index = insertOrder . indexOf ( key ) ; if ( index >= 0 && index < size () - 1 ) { return insertOrder . get ( index + 1 ) ; MST[rv.AOR4Mutator]MSP[] } return null ; } @Override public K previousKey ( final Object key ) {
final boolean contains = containsKey ( key ) ; put ( index , entry . getKey () , entry . getValue () ) ; MST[NonVoidMethodCallMutator]MSP[] if ( ! contains ) { index ++ ; } else { index = indexOf ( entry . getKey () ) + 1 ; } }
final boolean contains = containsKey ( key ) ; put ( index , entry . getKey () , entry . getValue () ) ; if ( ! contains ) { MST[rv.ROR3Mutator]MSP[] index ++ ; } else { index = indexOf ( entry . getKey () ) + 1 ; } }
final int index = insertOrder . indexOf ( key ) ; if ( index >= 0 && index < size () - 1 ) { MST[MathMutator]MSP[] return insertOrder . get ( index + 1 ) ; } return null ; } @Override public K previousKey ( final Object key ) {
put ( entry . getKey () , entry . getValue () ) ; } } public void putAll ( int index , final Map < ? extends K , ? extends V > map ) { if ( index < 0 || index > insertOrder . size () ) { MST[rv.ROR4Mutator]MSP[]
buf . append ( value == this ? lr_7 : value ) ; } buf . append ( '}' ) ; MST[rv.CRCR3Mutator]MSP[] return buf . toString () ; } public K get ( final int index ) { return insertOrder . get ( index ) ; }
final boolean contains = containsKey ( key ) ; put ( index , entry . getKey () , entry . getValue () ) ; MST[rv.UOI3Mutator]MSP[] if ( ! contains ) { index ++ ; } else { index = indexOf ( entry . getKey () ) + 1 ; } }
put ( entry . getKey () , entry . getValue () ) ; } } public void putAll ( int index , final Map < ? extends K , ? extends V > map ) { if ( index < 0 || index > insertOrder . size () ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[]
if ( decorated () . containsKey ( key ) ) { return decorated () . put ( key , value ) ; MST[NonVoidMethodCallMutator]MSP[] } final V result = decorated () . put ( key , value ) ; insertOrder . add ( key ) ; return result ; } @Override
final int index = insertOrder . indexOf ( key ) ; if ( index >= 0 && index < size () - 1 ) { MST[rv.CRCR3Mutator]MSP[] return insertOrder . get ( index + 1 ) ; } return null ; } @Override public K previousKey ( final Object key ) {
} @Override public V remove ( final Object key ) { V result = null ; if ( decorated () . containsKey ( key ) ) { MST[rv.ROR5Mutator]MSP[] result = decorated () . remove ( key ) ; insertOrder . remove ( key ) ; } return result ; } @Override
@Override public K lastKey () { if ( size () == 0 ) { MST[rv.ROR3Mutator]MSP[] throw new NoSuchElementException ( lr_2 ) ; } return insertOrder . get ( size () - 1 ) ; } @Override public K nextKey ( final Object key ) {
if ( index < 0 || index > insertOrder . size () ) { MST[NegateConditionalsMutator]MSP[] throw new IndexOutOfBoundsException ( lr_3 + index + lr_4 + insertOrder . size () ) ; } final Map < K , V > m = decorated () ;
final int index = insertOrder . indexOf ( key ) ; if ( index >= 0 && index < size () - 1 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] return insertOrder . get ( index + 1 ) ; } return null ; } @Override public K previousKey ( final Object key ) {
public OrderedMapIterator < K , V > mapIterator () { return new ListOrderedMapIterator <> ( this ) ; } @Override public K firstKey () { if ( size () == 0 ) { MST[rv.ROR5Mutator]MSP[] throw new NoSuchElementException ( lr_2 ) ; } return insertOrder . get ( 0 ) ; }
final int index = insertOrder . indexOf ( key ) ; if ( index > 0 ) { return insertOrder . get ( index - 1 ) ; MST[rv.AOD1Mutator]MSP[] } return null ; } @Override public V put ( final K key , final V value ) {
if ( index < 0 || index > insertOrder . size () ) { MST[rv.ROR3Mutator]MSP[] throw new IndexOutOfBoundsException ( lr_3 + index + lr_4 + insertOrder . size () ) ; } final Map < K , V > m = decorated () ;
if ( decorated () . containsKey ( key ) ) { return decorated () . put ( key , value ) ; } final V result = decorated () . put ( key , value ) ; insertOrder . add ( key ) ; MST[NonVoidMethodCallMutator]MSP[] return result ; } @Override
public void clear () { decorated () . clear () ; insertOrder . clear () ; } @Override public Set < K > keySet () { return new KeySetView <> ( this ) ; MST[ConstructorCallMutator]MSP[] } public List < K > keyList () {
final int index = insertOrder . indexOf ( key ) ; if ( index >= 0 && index < size () - 1 ) { return insertOrder . get ( index + 1 ) ; MST[rv.UOI3Mutator]MSP[] } return null ; } @Override public K previousKey ( final Object key ) {
final StringBuilder buf = new StringBuilder () ; buf . append ( '{' ) ; MST[rv.CRCR4Mutator]MSP[] boolean first = true ; for ( final Map . Entry < K , V > entry : entrySet () ) { final K key = entry . getKey () ;
if ( index < 0 || index > insertOrder . size () ) { throw new IndexOutOfBoundsException ( lr_3 + index + lr_4 + insertOrder . size () ) ; MST[rv.UOI1Mutator]MSP[] } final Map < K , V > m = decorated () ;
public Set < Map . Entry < K , V > > entrySet () { return new EntrySetView <> ( this , this . insertOrder ) ; } @Override public String toString () { if ( isEmpty () ) { return lr_5 ; MST[ReturnValsMutator]MSP[] }
final int index = insertOrder . indexOf ( key ) ; if ( index > 0 ) { return insertOrder . get ( index - 1 ) ; MST[rv.CRCR6Mutator]MSP[] } return null ; } @Override public V put ( final K key , final V value ) {
final V value = entry . getValue () ; MST[NonVoidMethodCallMutator]MSP[] if ( first ) { first = false ; } else { buf . append ( lr_6 ) ; } buf . append ( key == this ? lr_7 : key ) ; buf . append ( '=' ) ;
final int index = insertOrder . indexOf ( key ) ; if ( index >= 0 && index < size () - 1 ) { return insertOrder . get ( index + 1 ) ; MST[rv.UOI4Mutator]MSP[] } return null ; } @Override public K previousKey ( final Object key ) {
final int index = insertOrder . indexOf ( key ) ; if ( index > 0 ) { return insertOrder . get ( index - 1 ) ; MST[rv.CRCR5Mutator]MSP[] } return null ; } @Override public V put ( final K key , final V value ) {
final int index = insertOrder . indexOf ( key ) ; if ( index >= 0 && index < size () - 1 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[] return insertOrder . get ( index + 1 ) ; } return null ; } @Override public K previousKey ( final Object key ) {
final int index = insertOrder . indexOf ( key ) ; if ( index >= 0 && index < size () - 1 ) { MST[NegateConditionalsMutator]MSP[] return insertOrder . get ( index + 1 ) ; } return null ; } @Override public K previousKey ( final Object key ) {
public OrderedMapIterator < K , V > mapIterator () { return new ListOrderedMapIterator <> ( this ) ; MST[ConstructorCallMutator]MSP[] } @Override public K firstKey () { if ( size () == 0 ) { throw new NoSuchElementException ( lr_2 ) ; } return insertOrder . get ( 0 ) ; }
final int index = insertOrder . indexOf ( key ) ; if ( index >= 0 && index < size () - 1 ) { MST[rv.AOR1Mutator]MSP[] return insertOrder . get ( index + 1 ) ; } return null ; } @Override public K previousKey ( final Object key ) {
final int index = insertOrder . indexOf ( key ) ; if ( index >= 0 && index < size () - 1 ) { return insertOrder . get ( index + 1 ) ; MST[ReturnValsMutator]MSP[] } return null ; } @Override public K previousKey ( final Object key ) {
final V value = entry . getValue () ; if ( first ) { first = false ; } else { buf . append ( lr_6 ) ; MST[NonVoidMethodCallMutator]MSP[] } buf . append ( key == this ? lr_7 : key ) ; buf . append ( '=' ) ;
final int index = insertOrder . indexOf ( key ) ; if ( index >= 0 && index < size () - 1 ) { return insertOrder . get ( index + 1 ) ; MST[rv.AOR3Mutator]MSP[] } return null ; } @Override public K previousKey ( final Object key ) {
public OrderedMapIterator < K , V > mapIterator () { return new ListOrderedMapIterator <> ( this ) ; MST[NullReturnValsMutator]MSP[] } @Override public K firstKey () { if ( size () == 0 ) { throw new NoSuchElementException ( lr_2 ) ; } return insertOrder . get ( 0 ) ; }
public static < K , V > ListOrderedMap < K , V > listOrderedMap ( final Map < K , V > map ) { return new ListOrderedMap <> ( map ) ; MST[ReturnValsMutator]MSP[] } private void writeObject ( final ObjectOutputStream out ) throws IOException { out . defaultWriteObject () ;
put ( entry . getKey () , entry . getValue () ) ; } } public void putAll ( int index , final Map < ? extends K , ? extends V > map ) { if ( index < 0 || index > insertOrder . size () ) { MST[rv.ROR3Mutator]MSP[]
public OrderedMapIterator < K , V > mapIterator () { return new ListOrderedMapIterator <> ( this ) ; } @Override public K firstKey () { if ( size () == 0 ) { throw new NoSuchElementException ( lr_2 ) ; } return insertOrder . get ( 0 ) ; MST[NonVoidMethodCallMutator]MSP[] }
final int index = insertOrder . indexOf ( key ) ; if ( index > 0 ) { return insertOrder . get ( index - 1 ) ; MST[rv.ABSMutator]MSP[] } return null ; } @Override public V put ( final K key , final V value ) {
final V value = entry . getValue () ; if ( first ) { first = false ; } else { buf . append ( lr_6 ) ; } buf . append ( key == this ? lr_7 : key ) ; MST[NonVoidMethodCallMutator]MSP[] buf . append ( '=' ) ;
if ( index < 0 || index > insertOrder . size () ) { MST[rv.UOI1Mutator]MSP[] throw new IndexOutOfBoundsException ( lr_3 + index + lr_4 + insertOrder . size () ) ; } final Map < K , V > m = decorated () ;
} @Override public V remove ( final Object key ) { V result = null ; if ( decorated () . containsKey ( key ) ) { MST[rv.ROR4Mutator]MSP[] result = decorated () . remove ( key ) ; insertOrder . remove ( key ) ; } return result ; } @Override
put ( entry . getKey () , entry . getValue () ) ; } } public void putAll ( int index , final Map < ? extends K , ? extends V > map ) { if ( index < 0 || index > insertOrder . size () ) { MST[rv.ROR2Mutator]MSP[]
@Override public K lastKey () { if ( size () == 0 ) { MST[NegateConditionalsMutator]MSP[] throw new NoSuchElementException ( lr_2 ) ; } return insertOrder . get ( size () - 1 ) ; } @Override public K nextKey ( final Object key ) {
final boolean contains = containsKey ( key ) ; put ( index , entry . getKey () , entry . getValue () ) ; MST[rv.UOI2Mutator]MSP[] if ( ! contains ) { index ++ ; } else { index = indexOf ( entry . getKey () ) + 1 ; } }
buf . append ( value == this ? lr_7 : value ) ; } buf . append ( '}' ) ; return buf . toString () ; } public K get ( final int index ) { return insertOrder . get ( index ) ; MST[rv.ABSMutator]MSP[] }
if ( index < 0 || index > insertOrder . size () ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] throw new IndexOutOfBoundsException ( lr_3 + index + lr_4 + insertOrder . size () ) ; } final Map < K , V > m = decorated () ;
final int index = insertOrder . indexOf ( key ) ; if ( index >= 0 && index < size () - 1 ) { MST[rv.ROR4Mutator]MSP[] return insertOrder . get ( index + 1 ) ; } return null ; } @Override public K previousKey ( final Object key ) {
final int index = insertOrder . indexOf ( key ) ; if ( index >= 0 && index < size () - 1 ) { return insertOrder . get ( index + 1 ) ; MST[rv.ABSMutator]MSP[] } return null ; } @Override public K previousKey ( final Object key ) {
final int index = insertOrder . indexOf ( key ) ; if ( index > 0 ) { return insertOrder . get ( index - 1 ) ; MST[rv.AOR4Mutator]MSP[] } return null ; } @Override public V put ( final K key , final V value ) {
if ( index < 0 || index > insertOrder . size () ) { MST[NonVoidMethodCallMutator]MSP[] throw new IndexOutOfBoundsException ( lr_3 + index + lr_4 + insertOrder . size () ) ; } final Map < K , V > m = decorated () ;
public V remove ( final int index ) { return remove ( get ( index ) ) ; } public List < K > asList () { return keyList () ; MST[EmptyObjectReturnValsMutator]MSP[] } @Override public int size () { return this . parent . size () ; } @Override
@Override public K lastKey () { if ( size () == 0 ) { throw new NoSuchElementException ( lr_2 ) ; } return insertOrder . get ( size () - 1 ) ; MST[rv.AOR1Mutator]MSP[] } @Override public K nextKey ( final Object key ) {
if ( index < 0 || index > insertOrder . size () ) { throw new IndexOutOfBoundsException ( lr_3 + index + lr_4 + insertOrder . size () ) ; MST[ConstructorCallMutator]MSP[] } final Map < K , V > m = decorated () ;
if ( decorated () . containsKey ( key ) ) { return decorated () . put ( key , value ) ; MST[NonVoidMethodCallMutator]MSP[] } final V result = decorated () . put ( key , value ) ; insertOrder . add ( key ) ; return result ; } @Override
final boolean contains = containsKey ( key ) ; put ( index , entry . getKey () , entry . getValue () ) ; MST[ArgumentPropagationMutator]MSP[] if ( ! contains ) { index ++ ; } else { index = indexOf ( entry . getKey () ) + 1 ; } }
public Set < Map . Entry < K , V > > entrySet () { return new EntrySetView <> ( this , this . insertOrder ) ; } @Override public String toString () { if ( isEmpty () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return lr_5 ; }
if ( decorated () . containsKey ( key ) ) { return decorated () . put ( key , value ) ; } final V result = decorated () . put ( key , value ) ; insertOrder . add ( key ) ; return result ; MST[NullReturnValsMutator]MSP[] } @Override
public static < K , V > ListOrderedMap < K , V > listOrderedMap ( final Map < K , V > map ) { return new ListOrderedMap <> ( map ) ; } private void writeObject ( final ObjectOutputStream out ) throws IOException { out . defaultWriteObject () ; MST[VoidMethodCallMutator]MSP[]
public V setValue ( final int index , final V value ) { final K key = insertOrder . get ( index ) ; return put ( key , value ) ; MST[NonVoidMethodCallMutator]MSP[] } public V put ( int index , final K key , final V value ) {
final int index = insertOrder . indexOf ( key ) ; if ( index >= 0 && index < size () - 1 ) { return insertOrder . get ( index + 1 ) ; MST[NullReturnValsMutator]MSP[] } return null ; } @Override public K previousKey ( final Object key ) {
final StringBuilder buf = new StringBuilder () ; buf . append ( '{' ) ; boolean first = true ; MST[rv.CRCR6Mutator]MSP[] for ( final Map . Entry < K , V > entry : entrySet () ) { final K key = entry . getKey () ;
final int index = insertOrder . indexOf ( key ) ; if ( index >= 0 && index < size () - 1 ) { MST[rv.ROR2Mutator]MSP[] return insertOrder . get ( index + 1 ) ; } return null ; } @Override public K previousKey ( final Object key ) {
public OrderedMapIterator < K , V > mapIterator () { return new ListOrderedMapIterator <> ( this ) ; } @Override public K firstKey () { if ( size () == 0 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] throw new NoSuchElementException ( lr_2 ) ; } return insertOrder . get ( 0 ) ; }
throw new IndexOutOfBoundsException ( lr_3 + index + lr_4 + insertOrder . size () ) ; MST[experimental.NakedReceiverMutator]MSP[] } for ( final Map . Entry < ? extends K , ? extends V > entry : map . entrySet () ) { final K key = entry . getKey () ;
final int index = insertOrder . indexOf ( key ) ; if ( index > 0 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] return insertOrder . get ( index - 1 ) ; } return null ; } @Override public V put ( final K key , final V value ) {
if ( m . containsKey ( key ) ) { MST[NonVoidMethodCallMutator]MSP[] final V result = m . remove ( key ) ; final int pos = insertOrder . indexOf ( key ) ; insertOrder . remove ( pos ) ; if ( pos < index ) { index -- ; }
final int index = insertOrder . indexOf ( key ) ; if ( index > 0 ) { MST[rv.UOI2Mutator]MSP[] return insertOrder . get ( index - 1 ) ; } return null ; } @Override public V put ( final K key , final V value ) {
public static < K , V > ListOrderedMap < K , V > listOrderedMap ( final Map < K , V > map ) { return new ListOrderedMap <> ( map ) ; MST[NullReturnValsMutator]MSP[] } private void writeObject ( final ObjectOutputStream out ) throws IOException { out . defaultWriteObject () ;
if ( decorated () . containsKey ( key ) ) { return decorated () . put ( key , value ) ; } final V result = decorated () . put ( key , value ) ; insertOrder . add ( key ) ; return result ; MST[ReturnValsMutator]MSP[] } @Override
final int index = insertOrder . indexOf ( key ) ; if ( index >= 0 && index < size () - 1 ) { return insertOrder . get ( index + 1 ) ; MST[rv.CRCR5Mutator]MSP[] } return null ; } @Override public K previousKey ( final Object key ) {
final int index = insertOrder . indexOf ( key ) ; if ( index > 0 ) { return insertOrder . get ( index - 1 ) ; MST[rv.UOI4Mutator]MSP[] } return null ; } @Override public V put ( final K key , final V value ) {
buf . append ( value == this ? lr_7 : value ) ; } buf . append ( '}' ) ; return buf . toString () ; } public K get ( final int index ) { return insertOrder . get ( index ) ; MST[rv.UOI4Mutator]MSP[] }
final V value = entry . getValue () ; if ( first ) { first = false ; MST[rv.CRCR6Mutator]MSP[] } else { buf . append ( lr_6 ) ; } buf . append ( key == this ? lr_7 : key ) ; buf . append ( '=' ) ;
public OrderedMapIterator < K , V > mapIterator () { return new ListOrderedMapIterator <> ( this ) ; } @Override public K firstKey () { if ( size () == 0 ) { throw new NoSuchElementException ( lr_2 ) ; MST[ConstructorCallMutator]MSP[] } return insertOrder . get ( 0 ) ; }
return UnmodifiableList . unmodifiableList ( insertOrder ) ; } @Override public Collection < V > values () { return new ValuesView <> ( this ) ; } public List < V > valueList () { return new ValuesView <> ( this ) ; MST[ReturnValsMutator]MSP[] } @Override
final V value = entry . getValue () ; if ( first ) { first = false ; } else { buf . append ( lr_6 ) ; } buf . append ( key == this ? lr_7 : key ) ; buf . append ( '=' ) ; MST[rv.CRCR2Mutator]MSP[]
throw new IndexOutOfBoundsException ( lr_3 + index + lr_4 + insertOrder . size () ) ; MST[NonVoidMethodCallMutator]MSP[] } for ( final Map . Entry < ? extends K , ? extends V > entry : map . entrySet () ) { final K key = entry . getKey () ;
insertOrder . add ( index , key ) ; m . put ( key , value ) ; return result ; } insertOrder . add ( index , key ) ; m . put ( key , value ) ; return null ; MST[ReturnValsMutator]MSP[] }
final int index = insertOrder . indexOf ( key ) ; if ( index >= 0 && index < size () - 1 ) { MST[rv.CRCR6Mutator]MSP[] return insertOrder . get ( index + 1 ) ; } return null ; } @Override public K previousKey ( final Object key ) {
public V remove ( final int index ) { return remove ( get ( index ) ) ; MST[NonVoidMethodCallMutator]MSP[] } public List < K > asList () { return keyList () ; } @Override public int size () { return this . parent . size () ; } @Override
final V value = entry . getValue () ; if ( first ) { MST[rv.ABSMutator]MSP[] first = false ; } else { buf . append ( lr_6 ) ; } buf . append ( key == this ? lr_7 : key ) ; buf . append ( '=' ) ;
final V value = entry . getValue () ; if ( first ) { MST[rv.ROR3Mutator]MSP[] first = false ; } else { buf . append ( lr_6 ) ; } buf . append ( key == this ? lr_7 : key ) ; buf . append ( '=' ) ;
public V getValue ( final int index ) { return get ( insertOrder . get ( index ) ) ; MST[rv.UOI3Mutator]MSP[] } public int indexOf ( final Object key ) { return insertOrder . indexOf ( key ) ; }
final int index = insertOrder . indexOf ( key ) ; if ( index >= 0 && index < size () - 1 ) { MST[rv.AOD1Mutator]MSP[] return insertOrder . get ( index + 1 ) ; } return null ; } @Override public K previousKey ( final Object key ) {
public Set < Map . Entry < K , V > > entrySet () { return new EntrySetView <> ( this , this . insertOrder ) ; } @Override public String toString () { if ( isEmpty () ) { return lr_5 ; MST[EmptyObjectReturnValsMutator]MSP[] }
final V value = entry . getValue () ; if ( first ) { first = false ; } else { buf . append ( lr_6 ) ; } buf . append ( key == this ? lr_7 : key ) ; buf . append ( '=' ) ; MST[rv.CRCR6Mutator]MSP[]
insertOrder . add ( index , key ) ; m . put ( key , value ) ; return result ; } insertOrder . add ( index , key ) ; MST[rv.UOI2Mutator]MSP[] m . put ( key , value ) ; return null ; }
if ( decorated () . containsKey ( key ) ) { MST[rv.ROR2Mutator]MSP[] return decorated () . put ( key , value ) ; } final V result = decorated () . put ( key , value ) ; insertOrder . add ( key ) ; return result ; } @Override
final int index = insertOrder . indexOf ( key ) ; if ( index >= 0 && index < size () - 1 ) { MST[rv.UOI1Mutator]MSP[] return insertOrder . get ( index + 1 ) ; } return null ; } @Override public K previousKey ( final Object key ) {
buf . append ( value == this ? lr_7 : value ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] } buf . append ( '}' ) ; return buf . toString () ; } public K get ( final int index ) { return insertOrder . get ( index ) ; }
final int index = insertOrder . indexOf ( key ) ; if ( index > 0 ) { MST[rv.ABSMutator]MSP[] return insertOrder . get ( index - 1 ) ; } return null ; } @Override public V put ( final K key , final V value ) {
final V value = entry . getValue () ; if ( first ) { first = false ; MST[rv.CRCR3Mutator]MSP[] } else { buf . append ( lr_6 ) ; } buf . append ( key == this ? lr_7 : key ) ; buf . append ( '=' ) ;
return UnmodifiableList . unmodifiableList ( insertOrder ) ; } @Override public Collection < V > values () { return new ValuesView <> ( this ) ; MST[ReturnValsMutator]MSP[] } public List < V > valueList () { return new ValuesView <> ( this ) ; } @Override
final boolean contains = containsKey ( key ) ; put ( index , entry . getKey () , entry . getValue () ) ; if ( ! contains ) { MST[rv.ROR2Mutator]MSP[] index ++ ; } else { index = indexOf ( entry . getKey () ) + 1 ; } }
buf . append ( value == this ? lr_7 : value ) ; MST[NegateConditionalsMutator]MSP[] } buf . append ( '}' ) ; return buf . toString () ; } public K get ( final int index ) { return insertOrder . get ( index ) ; }
final V value = entry . getValue () ; if ( first ) { first = false ; } else { buf . append ( lr_6 ) ; } buf . append ( key == this ? lr_7 : key ) ; buf . append ( '=' ) ; MST[experimental.NakedReceiverMutator]MSP[]
final int index = insertOrder . indexOf ( key ) ; if ( index >= 0 && index < size () - 1 ) { return insertOrder . get ( index + 1 ) ; MST[rv.CRCR4Mutator]MSP[] } return null ; } @Override public K previousKey ( final Object key ) {
final int index = insertOrder . indexOf ( key ) ; if ( index > 0 ) { return insertOrder . get ( index - 1 ) ; MST[rv.UOI3Mutator]MSP[] } return null ; } @Override public V put ( final K key , final V value ) {
final int index = insertOrder . indexOf ( key ) ; if ( index >= 0 && index < size () - 1 ) { MST[rv.CRCR2Mutator]MSP[] return insertOrder . get ( index + 1 ) ; } return null ; } @Override public K previousKey ( final Object key ) {
buf . append ( value == this ? lr_7 : value ) ; } buf . append ( '}' ) ; MST[rv.CRCR4Mutator]MSP[] return buf . toString () ; } public K get ( final int index ) { return insertOrder . get ( index ) ; }
final V value = entry . getValue () ; if ( first ) { first = false ; } else { buf . append ( lr_6 ) ; } buf . append ( key == this ? lr_7 : key ) ; buf . append ( '=' ) ; MST[NonVoidMethodCallMutator]MSP[]
if ( index < 0 || index > insertOrder . size () ) { MST[NegateConditionalsMutator]MSP[] throw new IndexOutOfBoundsException ( lr_3 + index + lr_4 + insertOrder . size () ) ; } final Map < K , V > m = decorated () ;
final V value = entry . getValue () ; if ( first ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] first = false ; } else { buf . append ( lr_6 ) ; } buf . append ( key == this ? lr_7 : key ) ; buf . append ( '=' ) ;
@Override public K lastKey () { if ( size () == 0 ) { MST[rv.ROR4Mutator]MSP[] throw new NoSuchElementException ( lr_2 ) ; } return insertOrder . get ( size () - 1 ) ; } @Override public K nextKey ( final Object key ) {
public V remove ( final int index ) { return remove ( get ( index ) ) ; MST[rv.UOI2Mutator]MSP[] } public List < K > asList () { return keyList () ; } @Override public int size () { return this . parent . size () ; } @Override
if ( decorated () . containsKey ( key ) ) { return decorated () . put ( key , value ) ; } final V result = decorated () . put ( key , value ) ; MST[ArgumentPropagationMutator]MSP[] insertOrder . add ( key ) ; return result ; } @Override
} @Override public V remove ( final Object key ) { V result = null ; if ( decorated () . containsKey ( key ) ) { MST[NonVoidMethodCallMutator]MSP[] result = decorated () . remove ( key ) ; insertOrder . remove ( key ) ; } return result ; } @Override
@Override public K lastKey () { if ( size () == 0 ) { throw new NoSuchElementException ( lr_2 ) ; } return insertOrder . get ( size () - 1 ) ; MST[MathMutator]MSP[] } @Override public K nextKey ( final Object key ) {
final int index = insertOrder . indexOf ( key ) ; if ( index >= 0 && index < size () - 1 ) { MST[rv.ROR3Mutator]MSP[] return insertOrder . get ( index + 1 ) ; } return null ; } @Override public K previousKey ( final Object key ) {
throw new IndexOutOfBoundsException ( lr_3 + index + lr_4 + insertOrder . size () ) ; MST[NonVoidMethodCallMutator]MSP[] } for ( final Map . Entry < ? extends K , ? extends V > entry : map . entrySet () ) { final K key = entry . getKey () ;
return UnmodifiableList . unmodifiableList ( insertOrder ) ; MST[ReturnValsMutator]MSP[] } @Override public Collection < V > values () { return new ValuesView <> ( this ) ; } public List < V > valueList () { return new ValuesView <> ( this ) ; } @Override
@Override public K lastKey () { if ( size () == 0 ) { throw new NoSuchElementException ( lr_2 ) ; } return insertOrder . get ( size () - 1 ) ; MST[rv.AOR4Mutator]MSP[] } @Override public K nextKey ( final Object key ) {
final int index = insertOrder . indexOf ( key ) ; if ( index > 0 ) { return insertOrder . get ( index - 1 ) ; MST[NullReturnValsMutator]MSP[] } return null ; } @Override public V put ( final K key , final V value ) {
public static < K , V > ListOrderedMap < K , V > listOrderedMap ( final Map < K , V > map ) { return new ListOrderedMap <> ( map ) ; MST[ConstructorCallMutator]MSP[] } private void writeObject ( final ObjectOutputStream out ) throws IOException { out . defaultWriteObject () ;
final int index = insertOrder . indexOf ( key ) ; if ( index >= 0 && index < size () - 1 ) { MST[rv.AOR3Mutator]MSP[] return insertOrder . get ( index + 1 ) ; } return null ; } @Override public K previousKey ( final Object key ) {
put ( entry . getKey () , entry . getValue () ) ; } } public void putAll ( int index , final Map < ? extends K , ? extends V > map ) { if ( index < 0 || index > insertOrder . size () ) { MST[rv.ROR5Mutator]MSP[]
public OrderedMapIterator < K , V > mapIterator () { return new ListOrderedMapIterator <> ( this ) ; MST[ReturnValsMutator]MSP[] } @Override public K firstKey () { if ( size () == 0 ) { throw new NoSuchElementException ( lr_2 ) ; } return insertOrder . get ( 0 ) ; }
insertOrder . add ( index , key ) ; m . put ( key , value ) ; return result ; } insertOrder . add ( index , key ) ; MST[rv.ABSMutator]MSP[] m . put ( key , value ) ; return null ; }
public Set < Map . Entry < K , V > > entrySet () { return new EntrySetView <> ( this , this . insertOrder ) ; MST[ReturnValsMutator]MSP[] } @Override public String toString () { if ( isEmpty () ) { return lr_5 ; }
final V value = entry . getValue () ; if ( first ) { first = false ; } else { buf . append ( lr_6 ) ; } buf . append ( key == this ? lr_7 : key ) ; buf . append ( '=' ) ; MST[InlineConstantMutator]MSP[]
final int index = insertOrder . indexOf ( key ) ; if ( index >= 0 && index < size () - 1 ) { MST[InlineConstantMutator]MSP[] return insertOrder . get ( index + 1 ) ; } return null ; } @Override public K previousKey ( final Object key ) {
buf . append ( value == this ? lr_7 : value ) ; MST[rv.ROR5Mutator]MSP[] } buf . append ( '}' ) ; return buf . toString () ; } public K get ( final int index ) { return insertOrder . get ( index ) ; }
put ( entry . getKey () , entry . getValue () ) ; } } public void putAll ( int index , final Map < ? extends K , ? extends V > map ) { if ( index < 0 || index > insertOrder . size () ) { MST[rv.ROR1Mutator]MSP[]
@Override public K lastKey () { if ( size () == 0 ) { throw new NoSuchElementException ( lr_2 ) ; } return insertOrder . get ( size () - 1 ) ; MST[rv.CRCR3Mutator]MSP[] } @Override public K nextKey ( final Object key ) {
put ( entry . getKey () , entry . getValue () ) ; } } public void putAll ( int index , final Map < ? extends K , ? extends V > map ) { if ( index < 0 || index > insertOrder . size () ) { MST[rv.UOI4Mutator]MSP[]
if ( index < 0 || index > insertOrder . size () ) { MST[rv.ROR5Mutator]MSP[] throw new IndexOutOfBoundsException ( lr_3 + index + lr_4 + insertOrder . size () ) ; } final Map < K , V > m = decorated () ;
buf . append ( value == this ? lr_7 : value ) ; MST[NonVoidMethodCallMutator]MSP[] } buf . append ( '}' ) ; return buf . toString () ; } public K get ( final int index ) { return insertOrder . get ( index ) ; }
throw new IndexOutOfBoundsException ( lr_3 + index + lr_4 + insertOrder . size () ) ; MST[NonVoidMethodCallMutator]MSP[] } for ( final Map . Entry < ? extends K , ? extends V > entry : map . entrySet () ) { final K key = entry . getKey () ;
final int index = insertOrder . indexOf ( key ) ; if ( index > 0 ) { return insertOrder . get ( index - 1 ) ; MST[rv.AOD2Mutator]MSP[] } return null ; } @Override public V put ( final K key , final V value ) {
if ( index < 0 || index > insertOrder . size () ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] throw new IndexOutOfBoundsException ( lr_3 + index + lr_4 + insertOrder . size () ) ; } final Map < K , V > m = decorated () ;
final int index = insertOrder . indexOf ( key ) ; if ( index > 0 ) { return insertOrder . get ( index - 1 ) ; MST[rv.CRCR4Mutator]MSP[] } return null ; } @Override public V put ( final K key , final V value ) {
public OrderedMapIterator < K , V > mapIterator () { return new ListOrderedMapIterator <> ( this ) ; } @Override public K firstKey () { if ( size () == 0 ) { MST[rv.ROR2Mutator]MSP[] throw new NoSuchElementException ( lr_2 ) ; } return insertOrder . get ( 0 ) ; }
public V getValue ( final int index ) { return get ( insertOrder . get ( index ) ) ; } public int indexOf ( final Object key ) { return insertOrder . indexOf ( key ) ; MST[ReturnValsMutator]MSP[] }
public V setValue ( final int index , final V value ) { final K key = insertOrder . get ( index ) ; return put ( key , value ) ; MST[ArgumentPropagationMutator]MSP[] } public V put ( int index , final K key , final V value ) {
final int index = insertOrder . indexOf ( key ) ; if ( index >= 0 && index < size () - 1 ) { MST[rv.UOI1Mutator]MSP[] return insertOrder . get ( index + 1 ) ; } return null ; } @Override public K previousKey ( final Object key ) {
final StringBuilder buf = new StringBuilder () ; buf . append ( '{' ) ; MST[rv.CRCR5Mutator]MSP[] boolean first = true ; for ( final Map . Entry < K , V > entry : entrySet () ) { final K key = entry . getKey () ;
final StringBuilder buf = new StringBuilder () ; buf . append ( '{' ) ; MST[rv.CRCR6Mutator]MSP[] boolean first = true ; for ( final Map . Entry < K , V > entry : entrySet () ) { final K key = entry . getKey () ;
final int index = insertOrder . indexOf ( key ) ; if ( index >= 0 && index < size () - 1 ) { MST[rv.UOI4Mutator]MSP[] return insertOrder . get ( index + 1 ) ; } return null ; } @Override public K previousKey ( final Object key ) {
final int index = insertOrder . indexOf ( key ) ; if ( index >= 0 && index < size () - 1 ) { return insertOrder . get ( index + 1 ) ; } return null ; MST[ReturnValsMutator]MSP[] } @Override public K previousKey ( final Object key ) {
buf . append ( value == this ? lr_7 : value ) ; } buf . append ( '}' ) ; return buf . toString () ; MST[ReturnValsMutator]MSP[] } public K get ( final int index ) { return insertOrder . get ( index ) ; }
final int index = insertOrder . indexOf ( key ) ; if ( index > 0 ) { MST[rv.UOI1Mutator]MSP[] return insertOrder . get ( index - 1 ) ; } return null ; } @Override public V put ( final K key , final V value ) {
put ( entry . getKey () , entry . getValue () ) ; } } public void putAll ( int index , final Map < ? extends K , ? extends V > map ) { if ( index < 0 || index > insertOrder . size () ) { MST[rv.UOI1Mutator]MSP[]
final boolean contains = containsKey ( key ) ; put ( index , entry . getKey () , entry . getValue () ) ; if ( ! contains ) { MST[rv.UOI1Mutator]MSP[] index ++ ; } else { index = indexOf ( entry . getKey () ) + 1 ; } }
throw new IndexOutOfBoundsException ( lr_3 + index + lr_4 + insertOrder . size () ) ; MST[rv.UOI4Mutator]MSP[] } for ( final Map . Entry < ? extends K , ? extends V > entry : map . entrySet () ) { final K key = entry . getKey () ;
final StringBuilder buf = new StringBuilder () ; buf . append ( '{' ) ; MST[NonVoidMethodCallMutator]MSP[] boolean first = true ; for ( final Map . Entry < K , V > entry : entrySet () ) { final K key = entry . getKey () ;
@Override public K lastKey () { if ( size () == 0 ) { MST[NonVoidMethodCallMutator]MSP[] throw new NoSuchElementException ( lr_2 ) ; } return insertOrder . get ( size () - 1 ) ; } @Override public K nextKey ( final Object key ) {
throw new IndexOutOfBoundsException ( lr_3 + index + lr_4 + insertOrder . size () ) ; MST[ConstructorCallMutator]MSP[] } for ( final Map . Entry < ? extends K , ? extends V > entry : map . entrySet () ) { final K key = entry . getKey () ;
if ( index < 0 || index > insertOrder . size () ) { MST[rv.ROR4Mutator]MSP[] throw new IndexOutOfBoundsException ( lr_3 + index + lr_4 + insertOrder . size () ) ; } final Map < K , V > m = decorated () ;
} @Override public V remove ( final Object key ) { V result = null ; if ( decorated () . containsKey ( key ) ) { MST[NonVoidMethodCallMutator]MSP[] result = decorated () . remove ( key ) ; insertOrder . remove ( key ) ; } return result ; } @Override
public V setValue ( final int index , final V value ) { final K key = insertOrder . get ( index ) ; MST[rv.UOI4Mutator]MSP[] return put ( key , value ) ; } public V put ( int index , final K key , final V value ) {
if ( index < 0 || index > insertOrder . size () ) { MST[rv.ROR1Mutator]MSP[] throw new IndexOutOfBoundsException ( lr_3 + index + lr_4 + insertOrder . size () ) ; } final Map < K , V > m = decorated () ;
@Override public K lastKey () { if ( size () == 0 ) { MST[rv.ROR5Mutator]MSP[] throw new NoSuchElementException ( lr_2 ) ; } return insertOrder . get ( size () - 1 ) ; } @Override public K nextKey ( final Object key ) {
final int index = insertOrder . indexOf ( key ) ; if ( index >= 0 && index < size () - 1 ) { MST[NonVoidMethodCallMutator]MSP[] return insertOrder . get ( index + 1 ) ; } return null ; } @Override public K previousKey ( final Object key ) {
final StringBuilder buf = new StringBuilder () ; buf . append ( '{' ) ; boolean first = true ; MST[rv.CRCR2Mutator]MSP[] for ( final Map . Entry < K , V > entry : entrySet () ) { final K key = entry . getKey () ;
final V value = entry . getValue () ; if ( first ) { first = false ; } else { buf . append ( lr_6 ) ; } buf . append ( key == this ? lr_7 : key ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] buf . append ( '=' ) ;
final int index = insertOrder . indexOf ( key ) ; if ( index >= 0 && index < size () - 1 ) { MST[ConditionalsBoundaryMutator]MSP[] return insertOrder . get ( index + 1 ) ; } return null ; } @Override public K previousKey ( final Object key ) {
final V value = entry . getValue () ; if ( first ) { MST[rv.UOI2Mutator]MSP[] first = false ; } else { buf . append ( lr_6 ) ; } buf . append ( key == this ? lr_7 : key ) ; buf . append ( '=' ) ;
throw new IndexOutOfBoundsException ( lr_3 + index + lr_4 + insertOrder . size () ) ; MST[rv.UOI1Mutator]MSP[] } for ( final Map . Entry < ? extends K , ? extends V > entry : map . entrySet () ) { final K key = entry . getKey () ;
} @Override public V remove ( final Object key ) { V result = null ; if ( decorated () . containsKey ( key ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] result = decorated () . remove ( key ) ; insertOrder . remove ( key ) ; } return result ; } @Override
public void clear () { decorated () . clear () ; insertOrder . clear () ; } @Override public Set < K > keySet () { return new KeySetView <> ( this ) ; MST[ReturnValsMutator]MSP[] } public List < K > keyList () {
if ( m . containsKey ( key ) ) { MST[rv.ROR1Mutator]MSP[] final V result = m . remove ( key ) ; final int pos = insertOrder . indexOf ( key ) ; insertOrder . remove ( pos ) ; if ( pos < index ) { index -- ; }
if ( index < 0 || index > insertOrder . size () ) { throw new IndexOutOfBoundsException ( lr_3 + index + lr_4 + insertOrder . size () ) ; MST[NonVoidMethodCallMutator]MSP[] } final Map < K , V > m = decorated () ;
final int index = insertOrder . indexOf ( key ) ; if ( index >= 0 && index < size () - 1 ) { MST[rv.AOR2Mutator]MSP[] return insertOrder . get ( index + 1 ) ; } return null ; } @Override public K previousKey ( final Object key ) {
@Override public K lastKey () { if ( size () == 0 ) { throw new NoSuchElementException ( lr_2 ) ; } return insertOrder . get ( size () - 1 ) ; MST[NonVoidMethodCallMutator]MSP[] } @Override public K nextKey ( final Object key ) {
public OrderedMapIterator < K , V > mapIterator () { return new ListOrderedMapIterator <> ( this ) ; } @Override public K firstKey () { if ( size () == 0 ) { throw new NoSuchElementException ( lr_2 ) ; } return insertOrder . get ( 0 ) ; MST[rv.CRCR5Mutator]MSP[] }
final int index = insertOrder . indexOf ( key ) ; if ( index > 0 ) { MST[rv.ROR3Mutator]MSP[] return insertOrder . get ( index - 1 ) ; } return null ; } @Override public V put ( final K key , final V value ) {
final boolean contains = containsKey ( key ) ; put ( index , entry . getKey () , entry . getValue () ) ; MST[rv.ABSMutator]MSP[] if ( ! contains ) { index ++ ; } else { index = indexOf ( entry . getKey () ) + 1 ; } }
final StringBuilder buf = new StringBuilder () ; buf . append ( '{' ) ; MST[InlineConstantMutator]MSP[] boolean first = true ; for ( final Map . Entry < K , V > entry : entrySet () ) { final K key = entry . getKey () ;
public OrderedMapIterator < K , V > mapIterator () { return new ListOrderedMapIterator <> ( this ) ; } @Override public K firstKey () { if ( size () == 0 ) { throw new NoSuchElementException ( lr_2 ) ; } return insertOrder . get ( 0 ) ; MST[ReturnValsMutator]MSP[] }
buf . append ( value == this ? lr_7 : value ) ; } buf . append ( '}' ) ; MST[rv.CRCR1Mutator]MSP[] return buf . toString () ; } public K get ( final int index ) { return insertOrder . get ( index ) ; }
} @Override public V remove ( final Object key ) { V result = null ; if ( decorated () . containsKey ( key ) ) { MST[rv.ROR3Mutator]MSP[] result = decorated () . remove ( key ) ; insertOrder . remove ( key ) ; } return result ; } @Override
public V remove ( final int index ) { return remove ( get ( index ) ) ; MST[rv.ABSMutator]MSP[] } public List < K > asList () { return keyList () ; } @Override public int size () { return this . parent . size () ; } @Override
put ( entry . getKey () , entry . getValue () ) ; } } public void putAll ( int index , final Map < ? extends K , ? extends V > map ) { if ( index < 0 || index > insertOrder . size () ) { MST[rv.ROR2Mutator]MSP[]
final boolean contains = containsKey ( key ) ; put ( index , entry . getKey () , entry . getValue () ) ; if ( ! contains ) { MST[rv.ROR1Mutator]MSP[] index ++ ; } else { index = indexOf ( entry . getKey () ) + 1 ; } }
@Override public K lastKey () { if ( size () == 0 ) { throw new NoSuchElementException ( lr_2 ) ; } return insertOrder . get ( size () - 1 ) ; MST[rv.AOD2Mutator]MSP[] } @Override public K nextKey ( final Object key ) {
final boolean contains = containsKey ( key ) ; put ( index , entry . getKey () , entry . getValue () ) ; if ( ! contains ) { MST[rv.UOI4Mutator]MSP[] index ++ ; } else { index = indexOf ( entry . getKey () ) + 1 ; } }
put ( entry . getKey () , entry . getValue () ) ; } } public void putAll ( int index , final Map < ? extends K , ? extends V > map ) { if ( index < 0 || index > insertOrder . size () ) { MST[rv.UOI4Mutator]MSP[]
throw new IndexOutOfBoundsException ( lr_3 + index + lr_4 + insertOrder . size () ) ; MST[experimental.NakedReceiverMutator]MSP[] } for ( final Map . Entry < ? extends K , ? extends V > entry : map . entrySet () ) { final K key = entry . getKey () ;
if ( index < 0 || index > insertOrder . size () ) { throw new IndexOutOfBoundsException ( lr_3 + index + lr_4 + insertOrder . size () ) ; MST[experimental.NakedReceiverMutator]MSP[] } final Map < K , V > m = decorated () ;
final boolean contains = containsKey ( key ) ; put ( index , entry . getKey () , entry . getValue () ) ; if ( ! contains ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] index ++ ; } else { index = indexOf ( entry . getKey () ) + 1 ; } }
final V value = entry . getValue () ; if ( first ) { first = false ; } else { buf . append ( lr_6 ) ; } buf . append ( key == this ? lr_7 : key ) ; buf . append ( '=' ) ; MST[rv.CRCR1Mutator]MSP[]
final V value = entry . getValue () ; if ( first ) { first = false ; } else { buf . append ( lr_6 ) ; } buf . append ( key == this ? lr_7 : key ) ; buf . append ( '=' ) ; MST[rv.CRCR3Mutator]MSP[]
final V value = entry . getValue () ; if ( first ) { MST[rv.ROR4Mutator]MSP[] first = false ; } else { buf . append ( lr_6 ) ; } buf . append ( key == this ? lr_7 : key ) ; buf . append ( '=' ) ;
final V value = entry . getValue () ; if ( first ) { MST[rv.ROR2Mutator]MSP[] first = false ; } else { buf . append ( lr_6 ) ; } buf . append ( key == this ? lr_7 : key ) ; buf . append ( '=' ) ;
insertOrder . add ( index , key ) ; m . put ( key , value ) ; return result ; } insertOrder . add ( index , key ) ; m . put ( key , value ) ; MST[ArgumentPropagationMutator]MSP[] return null ; }
final int index = insertOrder . indexOf ( key ) ; if ( index >= 0 && index < size () - 1 ) { MST[rv.UOI2Mutator]MSP[] return insertOrder . get ( index + 1 ) ; } return null ; } @Override public K previousKey ( final Object key ) {
final int index = insertOrder . indexOf ( key ) ; if ( index >= 0 && index < size () - 1 ) { MST[NegateConditionalsMutator]MSP[] return insertOrder . get ( index + 1 ) ; } return null ; } @Override public K previousKey ( final Object key ) {
put ( entry . getKey () , entry . getValue () ) ; } } public void putAll ( int index , final Map < ? extends K , ? extends V > map ) { if ( index < 0 || index > insertOrder . size () ) { MST[NonVoidMethodCallMutator]MSP[]
final V value = entry . getValue () ; if ( first ) { first = false ; } else { buf . append ( lr_6 ) ; } buf . append ( key == this ? lr_7 : key ) ; MST[NegateConditionalsMutator]MSP[] buf . append ( '=' ) ;
if ( index < 0 || index > insertOrder . size () ) { throw new IndexOutOfBoundsException ( lr_3 + index + lr_4 + insertOrder . size () ) ; MST[NonVoidMethodCallMutator]MSP[] } final Map < K , V > m = decorated () ;
if ( decorated () . containsKey ( key ) ) { MST[rv.ROR1Mutator]MSP[] return decorated () . put ( key , value ) ; } final V result = decorated () . put ( key , value ) ; insertOrder . add ( key ) ; return result ; } @Override
public V getValue ( final int index ) { return get ( insertOrder . get ( index ) ) ; } public int indexOf ( final Object key ) { return insertOrder . indexOf ( key ) ; MST[NonVoidMethodCallMutator]MSP[] }
insertOrder . add ( index , key ) ; m . put ( key , value ) ; return result ; } insertOrder . add ( index , key ) ; MST[rv.UOI1Mutator]MSP[] m . put ( key , value ) ; return null ; }
final int index = insertOrder . indexOf ( key ) ; if ( index >= 0 && index < size () - 1 ) { return insertOrder . get ( index + 1 ) ; MST[rv.AOD2Mutator]MSP[] } return null ; } @Override public K previousKey ( final Object key ) {
final int index = insertOrder . indexOf ( key ) ; if ( index >= 0 && index < size () - 1 ) { MST[rv.UOI4Mutator]MSP[] return insertOrder . get ( index + 1 ) ; } return null ; } @Override public K previousKey ( final Object key ) {
@Override public K lastKey () { if ( size () == 0 ) { throw new NoSuchElementException ( lr_2 ) ; } return insertOrder . get ( size () - 1 ) ; MST[rv.CRCR6Mutator]MSP[] } @Override public K nextKey ( final Object key ) {
public OrderedMapIterator < K , V > mapIterator () { return new ListOrderedMapIterator <> ( this ) ; } @Override public K firstKey () { if ( size () == 0 ) { throw new NoSuchElementException ( lr_2 ) ; } return insertOrder . get ( 0 ) ; MST[NullReturnValsMutator]MSP[] }
final boolean contains = containsKey ( key ) ; MST[NonVoidMethodCallMutator]MSP[] put ( index , entry . getKey () , entry . getValue () ) ; if ( ! contains ) { index ++ ; } else { index = indexOf ( entry . getKey () ) + 1 ; } }
if ( m . containsKey ( key ) ) { MST[rv.ROR3Mutator]MSP[] final V result = m . remove ( key ) ; final int pos = insertOrder . indexOf ( key ) ; insertOrder . remove ( pos ) ; if ( pos < index ) { index -- ; }
@Override public K lastKey () { if ( size () == 0 ) { throw new NoSuchElementException ( lr_2 ) ; } return insertOrder . get ( size () - 1 ) ; MST[rv.CRCR4Mutator]MSP[] } @Override public K nextKey ( final Object key ) {
if ( decorated () . containsKey ( key ) ) { MST[rv.ROR5Mutator]MSP[] return decorated () . put ( key , value ) ; } final V result = decorated () . put ( key , value ) ; insertOrder . add ( key ) ; return result ; } @Override
public OrderedMapIterator < K , V > mapIterator () { return new ListOrderedMapIterator <> ( this ) ; } @Override public K firstKey () { if ( size () == 0 ) { throw new NoSuchElementException ( lr_2 ) ; } return insertOrder . get ( 0 ) ; MST[rv.CRCR6Mutator]MSP[] }
final int index = insertOrder . indexOf ( key ) ; if ( index > 0 ) { MST[rv.ROR2Mutator]MSP[] return insertOrder . get ( index - 1 ) ; } return null ; } @Override public V put ( final K key , final V value ) {
buf . append ( value == this ? lr_7 : value ) ; } buf . append ( '}' ) ; return buf . toString () ; } public K get ( final int index ) { return insertOrder . get ( index ) ; MST[rv.UOI1Mutator]MSP[] }
if ( index < 0 || index > insertOrder . size () ) { MST[rv.UOI3Mutator]MSP[] throw new IndexOutOfBoundsException ( lr_3 + index + lr_4 + insertOrder . size () ) ; } final Map < K , V > m = decorated () ;
if ( m . containsKey ( key ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] final V result = m . remove ( key ) ; final int pos = insertOrder . indexOf ( key ) ; insertOrder . remove ( pos ) ; if ( pos < index ) { index -- ; }
} @Override public V remove ( final Object key ) { V result = null ; if ( decorated () . containsKey ( key ) ) { result = decorated () . remove ( key ) ; insertOrder . remove ( key ) ; } return result ; MST[NullReturnValsMutator]MSP[] } @Override
@Override public K lastKey () { if ( size () == 0 ) { throw new NoSuchElementException ( lr_2 ) ; } return insertOrder . get ( size () - 1 ) ; MST[rv.AOD1Mutator]MSP[] } @Override public K nextKey ( final Object key ) {
put ( entry . getKey () , entry . getValue () ) ; } } public void putAll ( int index , final Map < ? extends K , ? extends V > map ) { if ( index < 0 || index > insertOrder . size () ) { MST[rv.UOI1Mutator]MSP[]
put ( entry . getKey () , entry . getValue () ) ; } } public void putAll ( int index , final Map < ? extends K , ? extends V > map ) { if ( index < 0 || index > insertOrder . size () ) { MST[rv.UOI3Mutator]MSP[]
final boolean contains = containsKey ( key ) ; put ( index , entry . getKey () , entry . getValue () ) ; if ( ! contains ) { MST[rv.ABSMutator]MSP[] index ++ ; } else { index = indexOf ( entry . getKey () ) + 1 ; } }
final boolean contains = containsKey ( key ) ; put ( index , entry . getKey () , entry . getValue () ) ; if ( ! contains ) { MST[NegateConditionalsMutator]MSP[] index ++ ; } else { index = indexOf ( entry . getKey () ) + 1 ; } }
put ( entry . getKey () , entry . getValue () ) ; } } public void putAll ( int index , final Map < ? extends K , ? extends V > map ) { if ( index < 0 || index > insertOrder . size () ) { MST[rv.ABSMutator]MSP[]
if ( decorated () . containsKey ( key ) ) { return decorated () . put ( key , value ) ; } final V result = decorated () . put ( key , value ) ; MST[NonVoidMethodCallMutator]MSP[] insertOrder . add ( key ) ; return result ; } @Override
final int index = insertOrder . indexOf ( key ) ; if ( index >= 0 && index < size () - 1 ) { MST[rv.ROR2Mutator]MSP[] return insertOrder . get ( index + 1 ) ; } return null ; } @Override public K previousKey ( final Object key ) {
final StringBuilder buf = new StringBuilder () ; buf . append ( '{' ) ; boolean first = true ; MST[rv.CRCR4Mutator]MSP[] for ( final Map . Entry < K , V > entry : entrySet () ) { final K key = entry . getKey () ;
final V value = entry . getValue () ; if ( first ) { first = false ; } else { buf . append ( lr_6 ) ; } buf . append ( key == this ? lr_7 : key ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] buf . append ( '=' ) ;
@Override public K lastKey () { if ( size () == 0 ) { throw new NoSuchElementException ( lr_2 ) ; } return insertOrder . get ( size () - 1 ) ; MST[rv.AOR3Mutator]MSP[] } @Override public K nextKey ( final Object key ) {
final int index = insertOrder . indexOf ( key ) ; if ( index > 0 ) { return insertOrder . get ( index - 1 ) ; MST[rv.AOR1Mutator]MSP[] } return null ; } @Override public V put ( final K key , final V value ) {
final StringBuilder buf = new StringBuilder () ; buf . append ( '{' ) ; boolean first = true ; for ( final Map . Entry < K , V > entry : entrySet () ) { final K key = entry . getKey () ; MST[NonVoidMethodCallMutator]MSP[]
final V value = entry . getValue () ; if ( first ) { first = false ; } else { buf . append ( lr_6 ) ; } buf . append ( key == this ? lr_7 : key ) ; MST[rv.ROR5Mutator]MSP[] buf . append ( '=' ) ;
out . writeObject ( map ) ; MST[VoidMethodCallMutator]MSP[] } @SuppressWarnings ( lr_1 ) private void readObject ( final ObjectInputStream in ) throws IOException , ClassNotFoundException { in . defaultReadObject () ; map = ( Map < K , V > ) in . readObject () ; } @Override
final int index = insertOrder . indexOf ( key ) ; if ( index >= 0 && index < size () - 1 ) { MST[rv.ABSMutator]MSP[] return insertOrder . get ( index + 1 ) ; } return null ; } @Override public K previousKey ( final Object key ) {
final int index = insertOrder . indexOf ( key ) ; if ( index >= 0 && index < size () - 1 ) { MST[rv.AOR4Mutator]MSP[] return insertOrder . get ( index + 1 ) ; } return null ; } @Override public K previousKey ( final Object key ) {
final int index = insertOrder . indexOf ( key ) ; if ( index >= 0 && index < size () - 1 ) { MST[rv.ROR5Mutator]MSP[] return insertOrder . get ( index + 1 ) ; } return null ; } @Override public K previousKey ( final Object key ) {
public Set < Map . Entry < K , V > > entrySet () { return new EntrySetView <> ( this , this . insertOrder ) ; } @Override public String toString () { if ( isEmpty () ) { MST[rv.ROR2Mutator]MSP[] return lr_5 ; }
throw new IndexOutOfBoundsException ( lr_3 + index + lr_4 + insertOrder . size () ) ; MST[NonVoidMethodCallMutator]MSP[] } for ( final Map . Entry < ? extends K , ? extends V > entry : map . entrySet () ) { final K key = entry . getKey () ;
if ( index < 0 || index > insertOrder . size () ) { throw new IndexOutOfBoundsException ( lr_3 + index + lr_4 + insertOrder . size () ) ; } final Map < K , V > m = decorated () ; MST[NonVoidMethodCallMutator]MSP[]
put ( entry . getKey () , entry . getValue () ) ; MST[ArgumentPropagationMutator]MSP[] } } public void putAll ( int index , final Map < ? extends K , ? extends V > map ) { if ( index < 0 || index > insertOrder . size () ) {
@Override public K lastKey () { if ( size () == 0 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] throw new NoSuchElementException ( lr_2 ) ; } return insertOrder . get ( size () - 1 ) ; } @Override public K nextKey ( final Object key ) {
put ( entry . getKey () , entry . getValue () ) ; } } public void putAll ( int index , final Map < ? extends K , ? extends V > map ) { if ( index < 0 || index > insertOrder . size () ) { MST[rv.UOI2Mutator]MSP[]
public V setValue ( final int index , final V value ) { final K key = insertOrder . get ( index ) ; return put ( key , value ) ; MST[ReturnValsMutator]MSP[] } public V put ( int index , final K key , final V value ) {
put ( entry . getKey () , entry . getValue () ) ; } } public void putAll ( int index , final Map < ? extends K , ? extends V > map ) { if ( index < 0 || index > insertOrder . size () ) { MST[ConditionalsBoundaryMutator]MSP[]
final boolean contains = containsKey ( key ) ; put ( index , entry . getKey () , entry . getValue () ) ; if ( ! contains ) { MST[rv.UOI2Mutator]MSP[] index ++ ; } else { index = indexOf ( entry . getKey () ) + 1 ; } }
throw new IndexOutOfBoundsException ( lr_3 + index + lr_4 + insertOrder . size () ) ; MST[rv.UOI3Mutator]MSP[] } for ( final Map . Entry < ? extends K , ? extends V > entry : map . entrySet () ) { final K key = entry . getKey () ;
final int index = insertOrder . indexOf ( key ) ; if ( index >= 0 && index < size () - 1 ) { return insertOrder . get ( index + 1 ) ; MST[rv.CRCR3Mutator]MSP[] } return null ; } @Override public K previousKey ( final Object key ) {
final int index = insertOrder . indexOf ( key ) ; if ( index > 0 ) { return insertOrder . get ( index - 1 ) ; MST[rv.UOI2Mutator]MSP[] } return null ; } @Override public V put ( final K key , final V value ) {
final int index = insertOrder . indexOf ( key ) ; if ( index >= 0 && index < size () - 1 ) { return insertOrder . get ( index + 1 ) ; MST[MathMutator]MSP[] } return null ; } @Override public K previousKey ( final Object key ) {
if ( index < 0 || index > insertOrder . size () ) { MST[rv.UOI4Mutator]MSP[] throw new IndexOutOfBoundsException ( lr_3 + index + lr_4 + insertOrder . size () ) ; } final Map < K , V > m = decorated () ;
} @Override public V remove ( final Object key ) { V result = null ; if ( decorated () . containsKey ( key ) ) { MST[rv.ROR1Mutator]MSP[] result = decorated () . remove ( key ) ; insertOrder . remove ( key ) ; } return result ; } @Override
public void clear () { decorated () . clear () ; insertOrder . clear () ; } @Override public Set < K > keySet () { return new KeySetView <> ( this ) ; MST[EmptyObjectReturnValsMutator]MSP[] } public List < K > keyList () {
public V setValue ( final int index , final V value ) { final K key = insertOrder . get ( index ) ; MST[rv.UOI3Mutator]MSP[] return put ( key , value ) ; } public V put ( int index , final K key , final V value ) {
if ( index < 0 || index > insertOrder . size () ) { throw new IndexOutOfBoundsException ( lr_3 + index + lr_4 + insertOrder . size () ) ; MST[rv.UOI3Mutator]MSP[] } final Map < K , V > m = decorated () ;
if ( index < 0 || index > insertOrder . size () ) { throw new IndexOutOfBoundsException ( lr_3 + index + lr_4 + insertOrder . size () ) ; MST[rv.UOI4Mutator]MSP[] } final Map < K , V > m = decorated () ;
final V value = entry . getValue () ; if ( first ) { first = false ; MST[InlineConstantMutator]MSP[] } else { buf . append ( lr_6 ) ; } buf . append ( key == this ? lr_7 : key ) ; buf . append ( '=' ) ;
if ( index < 0 || index > insertOrder . size () ) { MST[rv.ROR1Mutator]MSP[] throw new IndexOutOfBoundsException ( lr_3 + index + lr_4 + insertOrder . size () ) ; } final Map < K , V > m = decorated () ;
public OrderedMapIterator < K , V > mapIterator () { return new ListOrderedMapIterator <> ( this ) ; } @Override public K firstKey () { if ( size () == 0 ) { MST[rv.ROR3Mutator]MSP[] throw new NoSuchElementException ( lr_2 ) ; } return insertOrder . get ( 0 ) ; }
final int index = insertOrder . indexOf ( key ) ; if ( index > 0 ) { return insertOrder . get ( index - 1 ) ; MST[rv.CRCR3Mutator]MSP[] } return null ; } @Override public V put ( final K key , final V value ) {
final int index = insertOrder . indexOf ( key ) ; if ( index >= 0 && index < size () - 1 ) { return insertOrder . get ( index + 1 ) ; MST[rv.UOI1Mutator]MSP[] } return null ; } @Override public K previousKey ( final Object key ) {
if ( index < 0 || index > insertOrder . size () ) { MST[rv.ABSMutator]MSP[] throw new IndexOutOfBoundsException ( lr_3 + index + lr_4 + insertOrder . size () ) ; } final Map < K , V > m = decorated () ;
final StringBuilder buf = new StringBuilder () ; buf . append ( '{' ) ; MST[rv.CRCR2Mutator]MSP[] boolean first = true ; for ( final Map . Entry < K , V > entry : entrySet () ) { final K key = entry . getKey () ;
public V setValue ( final int index , final V value ) { final K key = insertOrder . get ( index ) ; MST[NonVoidMethodCallMutator]MSP[] return put ( key , value ) ; } public V put ( int index , final K key , final V value ) {
final StringBuilder buf = new StringBuilder () ; buf . append ( '{' ) ; MST[rv.CRCR1Mutator]MSP[] boolean first = true ; for ( final Map . Entry < K , V > entry : entrySet () ) { final K key = entry . getKey () ;
final int index = insertOrder . indexOf ( key ) ; if ( index >= 0 && index < size () - 1 ) { MST[rv.UOI2Mutator]MSP[] return insertOrder . get ( index + 1 ) ; } return null ; } @Override public K previousKey ( final Object key ) {
return UnmodifiableList . unmodifiableList ( insertOrder ) ; } @Override public Collection < V > values () { return new ValuesView <> ( this ) ; MST[EmptyObjectReturnValsMutator]MSP[] } public List < V > valueList () { return new ValuesView <> ( this ) ; } @Override
final int index = insertOrder . indexOf ( key ) ; if ( index >= 0 && index < size () - 1 ) { return insertOrder . get ( index + 1 ) ; MST[rv.AOR1Mutator]MSP[] } return null ; } @Override public K previousKey ( final Object key ) {
if ( index < 0 || index > insertOrder . size () ) { MST[ConditionalsBoundaryMutator]MSP[] throw new IndexOutOfBoundsException ( lr_3 + index + lr_4 + insertOrder . size () ) ; } final Map < K , V > m = decorated () ;
buf . append ( value == this ? lr_7 : value ) ; MST[experimental.NakedReceiverMutator]MSP[] } buf . append ( '}' ) ; return buf . toString () ; } public K get ( final int index ) { return insertOrder . get ( index ) ; }
insertOrder . add ( index , key ) ; m . put ( key , value ) ; return result ; } insertOrder . add ( index , key ) ; MST[VoidMethodCallMutator]MSP[] m . put ( key , value ) ; return null ; }
put ( entry . getKey () , entry . getValue () ) ; } } public void putAll ( int index , final Map < ? extends K , ? extends V > map ) { if ( index < 0 || index > insertOrder . size () ) { MST[rv.ROR4Mutator]MSP[]
final StringBuilder buf = new StringBuilder () ; buf . append ( '{' ) ; boolean first = true ; MST[InlineConstantMutator]MSP[] for ( final Map . Entry < K , V > entry : entrySet () ) { final K key = entry . getKey () ;
final boolean contains = containsKey ( key ) ; put ( index , entry . getKey () , entry . getValue () ) ; if ( ! contains ) { MST[rv.UOI3Mutator]MSP[] index ++ ; } else { index = indexOf ( entry . getKey () ) + 1 ; } }
throw new IndexOutOfBoundsException ( lr_3 + index + lr_4 + insertOrder . size () ) ; MST[rv.UOI2Mutator]MSP[] } for ( final Map . Entry < ? extends K , ? extends V > entry : map . entrySet () ) { final K key = entry . getKey () ;
final StringBuilder buf = new StringBuilder () ; buf . append ( '{' ) ; MST[experimental.NakedReceiverMutator]MSP[] boolean first = true ; for ( final Map . Entry < K , V > entry : entrySet () ) { final K key = entry . getKey () ;
if ( index < 0 || index > insertOrder . size () ) { MST[rv.UOI3Mutator]MSP[] throw new IndexOutOfBoundsException ( lr_3 + index + lr_4 + insertOrder . size () ) ; } final Map < K , V > m = decorated () ;
public OrderedMapIterator < K , V > mapIterator () { return new ListOrderedMapIterator <> ( this ) ; } @Override public K firstKey () { if ( size () == 0 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] throw new NoSuchElementException ( lr_2 ) ; } return insertOrder . get ( 0 ) ; }
put ( entry . getKey () , entry . getValue () ) ; } } public void putAll ( int index , final Map < ? extends K , ? extends V > map ) { if ( index < 0 || index > insertOrder . size () ) { MST[rv.ROR1Mutator]MSP[]
} @Override public V remove ( final Object key ) { V result = null ; if ( decorated () . containsKey ( key ) ) { MST[rv.ROR2Mutator]MSP[] result = decorated () . remove ( key ) ; insertOrder . remove ( key ) ; } return result ; } @Override
@Override public K lastKey () { if ( size () == 0 ) { throw new NoSuchElementException ( lr_2 ) ; } return insertOrder . get ( size () - 1 ) ; MST[ReturnValsMutator]MSP[] } @Override public K nextKey ( final Object key ) {
public V setValue ( final int index , final V value ) { final K key = insertOrder . get ( index ) ; return put ( key , value ) ; MST[NullReturnValsMutator]MSP[] } public V put ( int index , final K key , final V value ) {
put ( entry . getKey () , entry . getValue () ) ; } } public void putAll ( int index , final Map < ? extends K , ? extends V > map ) { if ( index < 0 || index > insertOrder . size () ) { MST[rv.UOI3Mutator]MSP[]
put ( entry . getKey () , entry . getValue () ) ; } } public void putAll ( int index , final Map < ? extends K , ? extends V > map ) { if ( index < 0 || index > insertOrder . size () ) { MST[NegateConditionalsMutator]MSP[]
throw new IndexOutOfBoundsException ( lr_3 + index + lr_4 + insertOrder . size () ) ; MST[ConstructorCallMutator]MSP[] } for ( final Map . Entry < ? extends K , ? extends V > entry : map . entrySet () ) { final K key = entry . getKey () ;
put ( entry . getKey () , entry . getValue () ) ; } } public void putAll ( int index , final Map < ? extends K , ? extends V > map ) { if ( index < 0 || index > insertOrder . size () ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[]
public V setValue ( final int index , final V value ) { final K key = insertOrder . get ( index ) ; MST[rv.UOI2Mutator]MSP[] return put ( key , value ) ; } public V put ( int index , final K key , final V value ) {
final StringBuilder buf = new StringBuilder () ; buf . append ( '{' ) ; boolean first = true ; MST[rv.CRCR3Mutator]MSP[] for ( final Map . Entry < K , V > entry : entrySet () ) { final K key = entry . getKey () ;
if ( decorated () . containsKey ( key ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return decorated () . put ( key , value ) ; } final V result = decorated () . put ( key , value ) ; insertOrder . add ( key ) ; return result ; } @Override
public V getValue ( final int index ) { return get ( insertOrder . get ( index ) ) ; } public int indexOf ( final Object key ) { return insertOrder . indexOf ( key ) ; MST[PrimitiveReturnsMutator]MSP[] }
buf . append ( value == this ? lr_7 : value ) ; } buf . append ( '}' ) ; MST[rv.CRCR5Mutator]MSP[] return buf . toString () ; } public K get ( final int index ) { return insertOrder . get ( index ) ; }
final V value = entry . getValue () ; if ( first ) { MST[rv.UOI1Mutator]MSP[] first = false ; } else { buf . append ( lr_6 ) ; } buf . append ( key == this ? lr_7 : key ) ; buf . append ( '=' ) ;
public void clear () { decorated () . clear () ; MST[NonVoidMethodCallMutator]MSP[] insertOrder . clear () ; } @Override public Set < K > keySet () { return new KeySetView <> ( this ) ; } public List < K > keyList () {
return UnmodifiableList . unmodifiableList ( insertOrder ) ; MST[ArgumentPropagationMutator]MSP[] } @Override public Collection < V > values () { return new ValuesView <> ( this ) ; } public List < V > valueList () { return new ValuesView <> ( this ) ; } @Override
final int index = insertOrder . indexOf ( key ) ; if ( index > 0 ) { return insertOrder . get ( index - 1 ) ; } return null ; MST[ReturnValsMutator]MSP[] } @Override public V put ( final K key , final V value ) {
public Set < Map . Entry < K , V > > entrySet () { return new EntrySetView <> ( this , this . insertOrder ) ; } @Override public String toString () { if ( isEmpty () ) { MST[rv.ROR3Mutator]MSP[] return lr_5 ; }
final int index = insertOrder . indexOf ( key ) ; if ( index >= 0 && index < size () - 1 ) { MST[rv.ROR1Mutator]MSP[] return insertOrder . get ( index + 1 ) ; } return null ; } @Override public K previousKey ( final Object key ) {
throw new IndexOutOfBoundsException ( lr_3 + index + lr_4 + insertOrder . size () ) ; MST[NonVoidMethodCallMutator]MSP[] } for ( final Map . Entry < ? extends K , ? extends V > entry : map . entrySet () ) { final K key = entry . getKey () ;
if ( m . containsKey ( key ) ) { MST[rv.ROR2Mutator]MSP[] final V result = m . remove ( key ) ; final int pos = insertOrder . indexOf ( key ) ; insertOrder . remove ( pos ) ; if ( pos < index ) { index -- ; }
put ( entry . getKey () , entry . getValue () ) ; } } public void putAll ( int index , final Map < ? extends K , ? extends V > map ) { if ( index < 0 || index > insertOrder . size () ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[]
@Override public K lastKey () { if ( size () == 0 ) { throw new NoSuchElementException ( lr_2 ) ; } return insertOrder . get ( size () - 1 ) ; MST[rv.CRCR5Mutator]MSP[] } @Override public K nextKey ( final Object key ) {
out . writeObject ( map ) ; } @SuppressWarnings ( lr_1 ) private void readObject ( final ObjectInputStream in ) throws IOException , ClassNotFoundException { in . defaultReadObject () ; MST[VoidMethodCallMutator]MSP[] map = ( Map < K , V > ) in . readObject () ; } @Override
@Override public K lastKey () { if ( size () == 0 ) { throw new NoSuchElementException ( lr_2 ) ; } return insertOrder . get ( size () - 1 ) ; MST[NullReturnValsMutator]MSP[] } @Override public K nextKey ( final Object key ) {
final boolean contains = containsKey ( key ) ; put ( index , entry . getKey () , entry . getValue () ) ; if ( ! contains ) { MST[rv.ROR5Mutator]MSP[] index ++ ; } else { index = indexOf ( entry . getKey () ) + 1 ; } }
public OrderedMapIterator < K , V > mapIterator () { return new ListOrderedMapIterator <> ( this ) ; } @Override public K firstKey () { if ( size () == 0 ) { throw new NoSuchElementException ( lr_2 ) ; } return insertOrder . get ( 0 ) ; MST[rv.CRCR1Mutator]MSP[] }
final int index = insertOrder . indexOf ( key ) ; if ( index > 0 ) { return insertOrder . get ( index - 1 ) ; MST[InlineConstantMutator]MSP[] } return null ; } @Override public V put ( final K key , final V value ) {
if ( index < 0 || index > insertOrder . size () ) { MST[rv.UOI4Mutator]MSP[] throw new IndexOutOfBoundsException ( lr_3 + index + lr_4 + insertOrder . size () ) ; } final Map < K , V > m = decorated () ;
final int index = insertOrder . indexOf ( key ) ; if ( index > 0 ) { return insertOrder . get ( index - 1 ) ; MST[NonVoidMethodCallMutator]MSP[] } return null ; } @Override public V put ( final K key , final V value ) {
@Override public K lastKey () { if ( size () == 0 ) { MST[rv.ROR1Mutator]MSP[] throw new NoSuchElementException ( lr_2 ) ; } return insertOrder . get ( size () - 1 ) ; } @Override public K nextKey ( final Object key ) {
final int index = insertOrder . indexOf ( key ) ; if ( index > 0 ) { return insertOrder . get ( index - 1 ) ; MST[MathMutator]MSP[] } return null ; } @Override public V put ( final K key , final V value ) {
if ( index < 0 || index > insertOrder . size () ) { throw new IndexOutOfBoundsException ( lr_3 + index + lr_4 + insertOrder . size () ) ; MST[rv.ABSMutator]MSP[] } final Map < K , V > m = decorated () ;
final int index = insertOrder . indexOf ( key ) ; if ( index >= 0 && index < size () - 1 ) { MST[rv.CRCR5Mutator]MSP[] return insertOrder . get ( index + 1 ) ; } return null ; } @Override public K previousKey ( final Object key ) {
final int index = insertOrder . indexOf ( key ) ; if ( index >= 0 && index < size () - 1 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] return insertOrder . get ( index + 1 ) ; } return null ; } @Override public K previousKey ( final Object key ) {
final boolean contains = containsKey ( key ) ; put ( index , entry . getKey () , entry . getValue () ) ; if ( ! contains ) { index ++ ; MST[IncrementsMutator]MSP[] } else { index = indexOf ( entry . getKey () ) + 1 ; } }
final V value = entry . getValue () ; if ( first ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] first = false ; } else { buf . append ( lr_6 ) ; } buf . append ( key == this ? lr_7 : key ) ; buf . append ( '=' ) ;
if ( decorated () . containsKey ( key ) ) { return decorated () . put ( key , value ) ; } final V result = decorated () . put ( key , value ) ; MST[NonVoidMethodCallMutator]MSP[] insertOrder . add ( key ) ; return result ; } @Override
put ( entry . getKey () , entry . getValue () ) ; } } public void putAll ( int index , final Map < ? extends K , ? extends V > map ) { if ( index < 0 || index > insertOrder . size () ) { MST[rv.UOI2Mutator]MSP[]
if ( index < 0 || index > insertOrder . size () ) { MST[rv.ROR2Mutator]MSP[] throw new IndexOutOfBoundsException ( lr_3 + index + lr_4 + insertOrder . size () ) ; } final Map < K , V > m = decorated () ;
public boolean contains ( final Object value ) { return this . parent . containsValue ( value ) ; } @Override public void clear () { this . parent . clear () ; MST[VoidMethodCallMutator]MSP[] } @Override public V next () { return getIterator () . next () . getValue () ;
public V remove ( final int index ) { return this . parent . remove ( index ) ; MST[rv.ABSMutator]MSP[] } @Override public int size () { return this . parent . size () ; } @Override public boolean contains ( final Object value ) {
public V remove ( final int index ) { return this . parent . remove ( index ) ; MST[rv.UOI1Mutator]MSP[] } @Override public int size () { return this . parent . size () ; } @Override public boolean contains ( final Object value ) {
} @Override public V get ( final int index ) { return this . parent . getValue ( index ) ; } @Override public V set ( final int index , final V value ) { return this . parent . setValue ( index , value ) ; MST[rv.UOI1Mutator]MSP[] } @Override
public V remove ( final int index ) { return this . parent . remove ( index ) ; MST[rv.UOI2Mutator]MSP[] } @Override public int size () { return this . parent . size () ; } @Override public boolean contains ( final Object value ) {
public V remove ( final int index ) { return this . parent . remove ( index ) ; MST[NonVoidMethodCallMutator]MSP[] } @Override public int size () { return this . parent . size () ; } @Override public boolean contains ( final Object value ) {
} @Override public V get ( final int index ) { return this . parent . getValue ( index ) ; } @Override public V set ( final int index , final V value ) { return this . parent . setValue ( index , value ) ; MST[rv.UOI2Mutator]MSP[] } @Override
} @Override public V get ( final int index ) { return this . parent . getValue ( index ) ; } @Override public V set ( final int index , final V value ) { return this . parent . setValue ( index , value ) ; MST[rv.UOI4Mutator]MSP[] } @Override
} @Override public V get ( final int index ) { return this . parent . getValue ( index ) ; } @Override public V set ( final int index , final V value ) { return this . parent . setValue ( index , value ) ; MST[rv.UOI3Mutator]MSP[] } @Override
public V remove ( final int index ) { return this . parent . remove ( index ) ; MST[rv.UOI4Mutator]MSP[] } @Override public int size () { return this . parent . size () ; } @Override public boolean contains ( final Object value ) {
public boolean contains ( final Object value ) { return this . parent . containsValue ( value ) ; } @Override public void clear () { this . parent . clear () ; } @Override MST[ReturnValsMutator]MSP[] public V next () { return getIterator () . next () . getValue () ;
public V remove ( final int index ) { return this . parent . remove ( index ) ; MST[rv.UOI3Mutator]MSP[] } @Override public int size () { return this . parent . size () ; } @Override public boolean contains ( final Object value ) {
} @Override public V get ( final int index ) { return this . parent . getValue ( index ) ; } @Override public V set ( final int index , final V value ) { return this . parent . setValue ( index , value ) ; MST[NonVoidMethodCallMutator]MSP[] } @Override
} @Override public V get ( final int index ) { return this . parent . getValue ( index ) ; } @Override public V set ( final int index , final V value ) { return this . parent . setValue ( index , value ) ; MST[ArgumentPropagationMutator]MSP[] } @Override
public boolean contains ( final Object value ) { return this . parent . containsValue ( value ) ; MST[ReturnValsMutator]MSP[] } @Override public void clear () { this . parent . clear () ; } @Override public V next () { return getIterator () . next () . getValue () ;
} @Override public V get ( final int index ) { return this . parent . getValue ( index ) ; MST[rv.ABSMutator]MSP[] } @Override public V set ( final int index , final V value ) { return this . parent . setValue ( index , value ) ; } @Override
public boolean contains ( final Object value ) { return this . parent . containsValue ( value ) ; } @Override public void clear () { this . parent . clear () ; } @Override MST[ConstructorCallMutator]MSP[] public V next () { return getIterator () . next () . getValue () ;
} @Override public V get ( final int index ) { return this . parent . getValue ( index ) ; MST[rv.UOI1Mutator]MSP[] } @Override public V set ( final int index , final V value ) { return this . parent . setValue ( index , value ) ; } @Override
public boolean contains ( final Object value ) { return this . parent . containsValue ( value ) ; MST[BooleanTrueReturnValsMutator]MSP[] } @Override public void clear () { this . parent . clear () ; } @Override public V next () { return getIterator () . next () . getValue () ;
} @Override public V get ( final int index ) { return this . parent . getValue ( index ) ; MST[rv.UOI3Mutator]MSP[] } @Override public V set ( final int index , final V value ) { return this . parent . setValue ( index , value ) ; } @Override
} @Override public V get ( final int index ) { return this . parent . getValue ( index ) ; MST[rv.UOI4Mutator]MSP[] } @Override public V set ( final int index , final V value ) { return this . parent . setValue ( index , value ) ; } @Override
} @Override public V get ( final int index ) { return this . parent . getValue ( index ) ; MST[rv.UOI2Mutator]MSP[] } @Override public V set ( final int index , final V value ) { return this . parent . setValue ( index , value ) ; } @Override
public boolean contains ( final Object value ) { return this . parent . containsValue ( value ) ; } @Override public void clear () { this . parent . clear () ; } @Override MST[NullReturnValsMutator]MSP[] public V next () { return getIterator () . next () . getValue () ;
public V remove ( final int index ) { return remove ( get ( index ) ) ; } public List < K > asList () { return keyList () ; } @Override public int size () { return this . parent . size () ; MST[NonVoidMethodCallMutator]MSP[] } @Override
} @Override public V get ( final int index ) { return this . parent . getValue ( index ) ; MST[NonVoidMethodCallMutator]MSP[] } @Override public V set ( final int index , final V value ) { return this . parent . setValue ( index , value ) ; } @Override
} @Override public V get ( final int index ) { return this . parent . getValue ( index ) ; } @Override public V set ( final int index , final V value ) { return this . parent . setValue ( index , value ) ; MST[rv.ABSMutator]MSP[] } @Override
public V remove ( final int index ) { return remove ( get ( index ) ) ; } public List < K > asList () { return keyList () ; } @Override public int size () { return this . parent . size () ; MST[PrimitiveReturnsMutator]MSP[] } @Override
public V remove ( final int index ) { return remove ( get ( index ) ) ; } public List < K > asList () { return keyList () ; } @Override public int size () { return this . parent . size () ; MST[ReturnValsMutator]MSP[] } @Override
public boolean contains ( final Object value ) { return this . parent . containsValue ( value ) ; MST[NonVoidMethodCallMutator]MSP[] } @Override public void clear () { this . parent . clear () ; } @Override public V next () { return getIterator () . next () . getValue () ;
public boolean contains ( final Object value ) { return this . parent . containsValue ( value ) ; MST[BooleanFalseReturnValsMutator]MSP[] } @Override public void clear () { this . parent . clear () ; } @Override public V next () { return getIterator () . next () . getValue () ;
public boolean contains ( final Object value ) { return this . parent . containsValue ( value ) ; } @Override public void clear () { this . parent . clear () ; } @Override MST[NonVoidMethodCallMutator]MSP[] public V next () { return getIterator () . next () . getValue () ;
public boolean contains ( final Object value ) { return this . parent . containsValue ( value ) ; } @Override public void clear () { this . parent . clear () ; } @Override MST[NonVoidMethodCallMutator]MSP[] public V next () { return getIterator () . next () . getValue () ;
return getEntrySet () . hashCode () ; } @Override public String toString () { return getEntrySet () . toString () ; } @Override public Iterator < Map . Entry < K , V > > iterator () { return new ListOrderedIterator <> ( parent , insertOrder ) ; } @Override MST[experimental.MemberVariableMutator]MSP[]
public Map . Entry < K , V > next () { last = getIterator () . next () ; MST[NonVoidMethodCallMutator]MSP[] return new ListOrderedMapEntry <> ( parent , last ) ; } @Override public void remove () { super . remove () ;
public Map . Entry < K , V > next () { last = getIterator () . next () ; return new ListOrderedMapEntry <> ( parent , last ) ; } @Override public void remove () { super . remove () ; MST[VoidMethodCallMutator]MSP[]
public Map . Entry < K , V > next () { last = getIterator () . next () ; return new ListOrderedMapEntry <> ( parent , last ) ; MST[ReturnValsMutator]MSP[] } @Override public void remove () { super . remove () ;
public Map . Entry < K , V > next () { last = getIterator () . next () ; return new ListOrderedMapEntry <> ( parent , last ) ; MST[ConstructorCallMutator]MSP[] } @Override public void remove () { super . remove () ;
public Map . Entry < K , V > next () { last = getIterator () . next () ; MST[experimental.MemberVariableMutator]MSP[] return new ListOrderedMapEntry <> ( parent , last ) ; } @Override public void remove () { super . remove () ;
public Map . Entry < K , V > next () { last = getIterator () . next () ; return new ListOrderedMapEntry <> ( parent , last ) ; MST[NullReturnValsMutator]MSP[] } @Override public void remove () { super . remove () ;
public boolean contains ( final Object value ) { return this . parent . containsValue ( value ) ; } @Override public void clear () { this . parent . clear () ; } @Override public V next () { return getIterator () . next () . getValue () ; MST[NullReturnValsMutator]MSP[]
public boolean contains ( final Object value ) { return this . parent . containsValue ( value ) ; } @Override public void clear () { this . parent . clear () ; } @Override public V next () { return getIterator () . next () . getValue () ; MST[NonVoidMethodCallMutator]MSP[]
public boolean contains ( final Object value ) { return this . parent . containsValue ( value ) ; } @Override public void clear () { this . parent . clear () ; } @Override MST[experimental.MemberVariableMutator]MSP[] public V next () { return getIterator () . next () . getValue () ;
public boolean contains ( final Object value ) { return this . parent . containsValue ( value ) ; } @Override public void clear () { this . parent . clear () ; } @Override public V next () { return getIterator () . next () . getValue () ; MST[NonVoidMethodCallMutator]MSP[]
public boolean contains ( final Object value ) { return this . parent . containsValue ( value ) ; } @Override public void clear () { this . parent . clear () ; } @Override public V next () { return getIterator () . next () . getValue () ; MST[NonVoidMethodCallMutator]MSP[]
public boolean contains ( final Object value ) { return this . parent . containsValue ( value ) ; } @Override public void clear () { this . parent . clear () ; } @Override public V next () { return getIterator () . next () . getValue () ; MST[ReturnValsMutator]MSP[]
return this . parent . containsKey ( value ) ; MST[BooleanTrueReturnValsMutator]MSP[] } @Override public void clear () { this . parent . clear () ; } @Override public K next () { return getIterator () . next () . getKey () ; }
return this . parent . containsKey ( value ) ; MST[ReturnValsMutator]MSP[] } @Override public void clear () { this . parent . clear () ; } @Override public K next () { return getIterator () . next () . getKey () ; }
return this . parent . containsKey ( value ) ; } @Override public void clear () { this . parent . clear () ; } @Override MST[NullReturnValsMutator]MSP[] public K next () { return getIterator () . next () . getKey () ; }
public V remove ( final int index ) { return this . parent . remove ( index ) ; } @Override public int size () { return this . parent . size () ; MST[PrimitiveReturnsMutator]MSP[] } @Override public boolean contains ( final Object value ) {
return this . parent . containsKey ( value ) ; } @Override public void clear () { this . parent . clear () ; } @Override MST[ReturnValsMutator]MSP[] public K next () { return getIterator () . next () . getKey () ; }
return this . parent . containsKey ( value ) ; MST[BooleanFalseReturnValsMutator]MSP[] } @Override public void clear () { this . parent . clear () ; } @Override public K next () { return getIterator () . next () . getKey () ; }
return this . parent . containsKey ( value ) ; MST[NonVoidMethodCallMutator]MSP[] } @Override public void clear () { this . parent . clear () ; } @Override public K next () { return getIterator () . next () . getKey () ; }
public V remove ( final int index ) { return this . parent . remove ( index ) ; } @Override public int size () { return this . parent . size () ; MST[NonVoidMethodCallMutator]MSP[] } @Override public boolean contains ( final Object value ) {
return this . parent . containsKey ( value ) ; } @Override public void clear () { this . parent . clear () ; } @Override MST[NonVoidMethodCallMutator]MSP[] public K next () { return getIterator () . next () . getKey () ; }
return this . parent . containsKey ( value ) ; } @Override public void clear () { this . parent . clear () ; MST[VoidMethodCallMutator]MSP[] } @Override public K next () { return getIterator () . next () . getKey () ; }
return this . parent . containsKey ( value ) ; } @Override public void clear () { this . parent . clear () ; } @Override MST[NonVoidMethodCallMutator]MSP[] public K next () { return getIterator () . next () . getKey () ; }
public V remove ( final int index ) { return this . parent . remove ( index ) ; } @Override public int size () { return this . parent . size () ; MST[ReturnValsMutator]MSP[] } @Override public boolean contains ( final Object value ) {
return this . parent . containsKey ( value ) ; } @Override public void clear () { this . parent . clear () ; } @Override MST[ConstructorCallMutator]MSP[] public K next () { return getIterator () . next () . getKey () ; }
