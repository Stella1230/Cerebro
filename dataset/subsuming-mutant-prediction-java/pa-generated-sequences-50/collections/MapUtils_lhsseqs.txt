R value = map != null && getFunction != null ? getFunction . apply ( map , key ) : null ; if ( value == null ) { value = defaultFunction != null ? defaultFunction . apply ( key ) : null ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] }
return answer . toString () ; } } return null ; MST[ReturnValsMutator]MSP[] } public static < K > String getString ( final Map < ? super K , ? > map , final K key , final Function < K , String > defaultFunction ) {
for ( int i = 0 ; i < array . length - 1 ; ) { MST[InlineConstantMutator]MSP[] map . put ( ( K ) array [ i ++ ] , ( V ) array [ i ++ ] ) ; } } return map ; }
public static < K > long getLongValue ( final Map < ? super K , ? > map , final K key ) { return applyDefaultValue ( map , key , MapUtils :: getLong , 0L ) . longValue () ; MST[PrimitiveReturnsMutator]MSP[] }
return applyDefaultFunction ( map , key , MapUtils :: getDouble , defaultFunction , 0d ) . doubleValue () ; MST[NonVoidMethodCallMutator]MSP[] } public static < K > Float getFloat ( final Map < ? super K , ? > map , final K key ) {
final Number answer = getNumber ( map , key ) ; if ( answer == null ) { MST[NegateConditionalsMutator]MSP[] return null ; } if ( answer instanceof Integer ) { return ( Integer ) answer ; } return Integer . valueOf ( answer . intValue () ) ; }
out . println ( debug ? lr_12 + map . getClass () . getName () : lr_13 ) ; MST[rv.ROR5Mutator]MSP[] }
public static < K > byte getByteValue ( final Map < ? super K , ? > map , final K key , final byte defaultValue ) { return applyDefaultValue ( map , key , MapUtils :: getByte , defaultValue ) . byteValue () ; MST[NonVoidMethodCallMutator]MSP[] }
for ( int i = 0 ; i < array . length - 1 ; ) { map . put ( ( K ) array [ i ++ ] , ( V ) array [ i ++ ] ) ; MST[rv.UOI4Mutator]MSP[] } } return map ; }
if ( array == null || array . length == 0 ) { return map ; } final Object obj = array [ 0 ] ; if ( obj instanceof Map . Entry ) { for ( final Object element : array ) { MST[rv.ABSMutator]MSP[]
out . print ( childValue ) ; } else if ( lineage . size () - 1 == lineageIndex ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] out . print ( lr_9 ) ; } else {
if ( sub == null || sub . length < 2 ) { MST[rv.CRCR3Mutator]MSP[] throw new IllegalArgumentException ( lr_4 + i ) ; } map . put ( ( K ) sub [ 0 ] , ( V ) sub [ 1 ] ) ; } } else {
final Number answer = getNumber ( map , key ) ; if ( answer == null ) { return null ; } if ( answer instanceof Byte ) { return ( Byte ) answer ; } return Byte . valueOf ( answer . byteValue () ) ; MST[ReturnValsMutator]MSP[] }
public static < K > short getShortValue ( final Map < ? super K , ? > map , final K key ) { return applyDefaultValue ( map , key , MapUtils :: getShort , 0 ) . shortValue () ; MST[NonVoidMethodCallMutator]MSP[] }
out . println ( debug ? lr_12 + map . getClass () . getName () : lr_13 ) ; MST[experimental.NakedReceiverMutator]MSP[] }
out . print ( childValue ) ; } else if ( lineage . size () - 1 == lineageIndex ) { MST[rv.AOR2Mutator]MSP[] out . print ( lr_9 ) ; } else {
for ( int i = 0 ; i < array . length - 1 ; ) { MST[rv.AOR3Mutator]MSP[] map . put ( ( K ) array [ i ++ ] , ( V ) array [ i ++ ] ) ; } } return map ; }
if ( array == null || array . length == 0 ) { return map ; } final Object obj = array [ 0 ] ; MST[rv.CRCR5Mutator]MSP[] if ( obj instanceof Map . Entry ) { for ( final Object element : array ) {
return map == null ? Collections . <K , V > emptyMap () : map ; MST[rv.ROR5Mutator]MSP[] } public static < K , V > IterableMap < K , V > fixedSizeMap ( final Map < K , V > map ) { return FixedSizeMap . fixedSizeMap ( map ) ;
return n . intValue () != 0 ? Boolean . TRUE : Boolean . FALSE ; MST[rv.ROR1Mutator]MSP[] } } } return null ; }
out . print ( lr_10 + ( lineage . size () - 1 - lineageIndex - 1 ) + lr_11 ) ; MST[rv.AOD2Mutator]MSP[] } if ( debug && childValue != null ) { out . print ( ' ' ) ;
if ( map != null ) { MST[NegateConditionalsMutator]MSP[] final Object answer = map . get ( key ) ; if ( answer != null && answer instanceof Map ) { return ( Map < ? , ? > ) answer ; } } return null ; }
out . put ( entry . getValue () , entry . getKey () ) ; MST[NonVoidMethodCallMutator]MSP[] } return out ; } public static boolean isEmpty ( final Map < ? , ? > map ) { return map == null || map . isEmpty () ; }
if ( sub == null || sub . length < 2 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] throw new IllegalArgumentException ( lr_4 + i ) ; } map . put ( ( K ) sub [ 0 ] , ( V ) sub [ 1 ] ) ; } } else {
out . println ( debug ? lr_12 + map . getClass () . getName () : lr_13 ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] }
if ( map != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] final Object answer = map . get ( key ) ; if ( answer != null && answer instanceof Map ) { return ( Map < ? , ? > ) answer ; } } return null ; }
public static < K > short getShortValue ( final Map < ? super K , ? > map , final K key ) { return applyDefaultValue ( map , key , MapUtils :: getShort , 0 ) . shortValue () ; MST[rv.CRCR6Mutator]MSP[] }
return map == null ? Collections . <K , V > emptyMap () : map ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] } public static < K , V > IterableMap < K , V > fixedSizeMap ( final Map < K , V > map ) { return FixedSizeMap . fixedSizeMap ( map ) ;
return n . intValue () != 0 ? Boolean . TRUE : Boolean . FALSE ; } } } return null ; MST[BooleanTrueReturnValsMutator]MSP[] }
printIndent ( out , lineage . size () ) ; out . print ( childKey ) ; out . print ( lr_6 ) ; final int lineageIndex = IterableUtils . indexOf ( lineage , PredicateUtils . equalPredicate ( childValue ) ) ; if ( lineageIndex == - 1 ) { MST[rv.CRCR6Mutator]MSP[]
if ( answer instanceof Boolean ) { MST[rv.ROR5Mutator]MSP[] return ( Boolean ) answer ; } if ( answer instanceof String ) { return Boolean . valueOf ( ( String ) answer ) ; } if ( answer instanceof Number ) { final Number n = ( Number ) answer ;
for ( int i = 0 ; i < indent ; i ++ ) { MST[rv.CRCR3Mutator]MSP[] out . print ( INDENT_STRING ) ; } } @SuppressWarnings ( lr_3 )
public static < K > long getLongValue ( final Map < ? super K , ? > map , final K key ) { return applyDefaultValue ( map , key , MapUtils :: getLong , 0L ) . longValue () ; MST[ArgumentPropagationMutator]MSP[] }
out . println ( debug ? lr_12 + map . getClass () . getName () : lr_13 ) ; MST[NonVoidMethodCallMutator]MSP[] }
return value == null ? defaultValue : value ; MST[ReturnValsMutator]MSP[] } public static void debugPrint ( final PrintStream out , final Object label , final Map < ? , ? > map ) {
final Number answer = getNumber ( map , key ) ; MST[NonVoidMethodCallMutator]MSP[] if ( answer == null ) { return null ; } if ( answer instanceof Integer ) { return ( Integer ) answer ; } return Integer . valueOf ( answer . intValue () ) ; }
public static boolean isNotEmpty ( final Map < ? , ? > map ) { return ! MapUtils . isEmpty ( map ) ; MST[rv.CRCR3Mutator]MSP[] } public static < K , V > IterableMap < K , V > iterableMap ( final Map < K , V > map ) {
for ( int i = 0 ; i < array . length - 1 ; ) { MST[ConditionalsBoundaryMutator]MSP[] map . put ( ( K ) array [ i ++ ] , ( V ) array [ i ++ ] ) ; } } return map ; }
if ( map == null ) { if ( label != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] out . print ( label ) ; out . print ( lr_6 ) ; } out . println ( lr_7 ) ; return; } if ( label != null ) {
if ( sub == null || sub . length < 2 ) { throw new IllegalArgumentException ( lr_4 + i ) ; } map . put ( ( K ) sub [ 0 ] , ( V ) sub [ 1 ] ) ; MST[rv.CRCR5Mutator]MSP[] } } else {
private static void verbosePrintInternal ( final PrintStream out , final Object label , final Map < ? , ? > map , final Deque < Map < ? , ? > > lineage , final boolean debug ) { printIndent ( out , lineage . size () ) ; MST[VoidMethodCallMutator]MSP[]
public static < K > int getIntValue ( final Map < ? super K , ? > map , final K key ) { return applyDefaultValue ( map , key , MapUtils :: getInteger , 0 ) . intValue () ; MST[NonVoidMethodCallMutator]MSP[] }
final Object answer = map . get ( key ) ; if ( answer != null ) { if ( answer instanceof Number ) { return ( Number ) answer ; } if ( answer instanceof String ) { MST[rv.ROR2Mutator]MSP[] try { final String text = ( String ) answer ;
final BiFunction < Map < ? super K , ? > , K , R > getFunction , final Function < K , R > defaultFunction ) { return applyDefaultFunction ( map , key , getFunction , defaultFunction , null ) ; MST[NullReturnValsMutator]MSP[] }
final Iterator < ? extends E > iter = elements . iterator () ; while ( iter . hasNext () ) { MST[NegateConditionalsMutator]MSP[] final E temp = iter . next () ; map . put ( keyTransformer . transform ( temp ) , valueTransformer . transform ( temp ) ) ;
public static < K > double getDoubleValue ( final Map < ? super K , ? > map , final K key ) { return applyDefaultValue ( map , key , MapUtils :: getDouble , 0d ) . doubleValue () ; MST[ReturnValsMutator]MSP[] }
public static < K > int getIntValue ( final Map < ? super K , ? > map , final K key ) { return applyDefaultValue ( map , key , MapUtils :: getInteger , 0 ) . intValue () ; MST[rv.CRCR1Mutator]MSP[] }
public static < K > Short getShort ( final Map < ? super K , ? > map , final K key , final Function < K , Short > defaultFunction ) { return applyDefaultFunction ( map , key , MapUtils :: getShort , defaultFunction ) ; MST[ArgumentPropagationMutator]MSP[] }
Objects . requireNonNull ( map , lr_1 ) ; return map instanceof IterableMap ? ( IterableMap < K , V > ) map : new AbstractMapDecorator < K , V > ( map ) { MST[rv.ROR1Mutator]MSP[] } ; }
if ( sub == null || sub . length < 2 ) { throw new IllegalArgumentException ( lr_4 + i ) ; MST[NonVoidMethodCallMutator]MSP[] } map . put ( ( K ) sub [ 0 ] , ( V ) sub [ 1 ] ) ; } } else {
public static void verbosePrint ( final PrintStream out , final Object label , final Map < ? , ? > map ) { verbosePrintInternal ( out , label , map , new ArrayDeque < Map < ? , ? > > () , false ) ; MST[rv.CRCR3Mutator]MSP[] }
} else if ( obj instanceof Object [] ) { for ( int i = 0 ; i < array . length ; i ++ ) { final Object [] sub = ( Object [] ) array [ i ] ; MST[rv.UOI4Mutator]MSP[]
final BiFunction < Map < ? super K , ? > , K , R > getFunction , final R defaultValue ) { final R value = map != null && getFunction != null ? getFunction . apply ( map , key ) : null ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
public static < K > Boolean getBoolean ( final Map < ? super K , ? > map , final K key ) { if ( map != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] final Object answer = map . get ( key ) ; if ( answer != null ) {
map . put ( keyTransformer . transform ( temp ) , valueTransformer . transform ( temp ) ) ; MST[ArgumentPropagationMutator]MSP[] } } public static < K , V > void populateMap ( final MultiMap < K , V > map , final Iterable < ? extends V > elements ,
final Number answer = getNumber ( map , key ) ; if ( answer == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return null ; } if ( answer instanceof Integer ) { return ( Integer ) answer ; } return Integer . valueOf ( answer . intValue () ) ; }
out . print ( childValue ) ; } else if ( lineage . size () - 1 == lineageIndex ) { MST[rv.ABSMutator]MSP[] out . print ( lr_9 ) ; } else {
return applyDefaultFunction ( map , key , MapUtils :: getLong , defaultFunction , 0L ) . byteValue () ; MST[rv.CRCR3Mutator]MSP[] } public static < K > long getLongValue ( final Map < ? super K , ? > map , final K key , final long defaultValue ) {
R value = map != null && getFunction != null ? getFunction . apply ( map , key ) : null ; if ( value == null ) { value = defaultFunction != null ? defaultFunction . apply ( key ) : null ; MST[NonVoidMethodCallMutator]MSP[] }
if ( array == null || array . length == 0 ) { return map ; } final Object obj = array [ 0 ] ; if ( obj instanceof Map . Entry ) { for ( final Object element : array ) { MST[rv.UOI2Mutator]MSP[]
out . println ( debug ? lr_12 + map . getClass () . getName () : lr_13 ) ; MST[rv.UOI4Mutator]MSP[] }
if ( array == null || array . length == 0 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return map ; } final Object obj = array [ 0 ] ; if ( obj instanceof Map . Entry ) { for ( final Object element : array ) {
if ( map != null ) { MST[rv.ROR5Mutator]MSP[] final Object answer = map . get ( key ) ; if ( answer != null && answer instanceof Map ) { return ( Map < ? , ? > ) answer ; } } return null ; }
public static < K > Double getDouble ( final Map < ? super K , ? > map , final K key , final Function < K , Double > defaultFunction ) { return applyDefaultFunction ( map , key , MapUtils :: getDouble , defaultFunction ) ; MST[ArgumentPropagationMutator]MSP[] }
out . print ( childValue ) ; } else if ( lineage . size () - 1 == lineageIndex ) { MST[rv.ROR3Mutator]MSP[] out . print ( lr_9 ) ; } else {
return value != null ? value : defaultValue ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] } private static < K , R > R applyDefaultValue ( final Map < ? super K , ? > map , final K key ,
public static boolean isNotEmpty ( final Map < ? , ? > map ) { return ! MapUtils . isEmpty ( map ) ; MST[rv.CRCR6Mutator]MSP[] } public static < K , V > IterableMap < K , V > iterableMap ( final Map < K , V > map ) {
for ( int i = 0 ; i < array . length - 1 ; ) { MST[rv.AOD1Mutator]MSP[] map . put ( ( K ) array [ i ++ ] , ( V ) array [ i ++ ] ) ; } } return map ; }
return applyDefaultFunction ( map , key , MapUtils :: getBoolean , defaultFunction , false ) . booleanValue () ; MST[ReturnValsMutator]MSP[] } public static < K > Byte getByte ( final Map < ? super K , ? > map , final K key ) {
out . print ( lr_10 + ( lineage . size () - 1 - lineageIndex - 1 ) + lr_11 ) ; MST[rv.AOR4Mutator]MSP[] } if ( debug && childValue != null ) { out . print ( ' ' ) ;
verbosePrintInternal ( out , label , map , new ArrayDeque < Map < ? , ? > > () , true ) ; MST[rv.CRCR6Mutator]MSP[] } public static < K , V > Map < K , V > emptyIfNull ( final Map < K , V > map ) {
final Number answer = getNumber ( map , key ) ; MST[NonVoidMethodCallMutator]MSP[] if ( answer == null ) { return null ; } if ( answer instanceof Short ) { return ( Short ) answer ; } return Short . valueOf ( answer . shortValue () ) ; }
out . put ( entry . getValue () , entry . getKey () ) ; } return out ; } public static boolean isEmpty ( final Map < ? , ? > map ) { return map == null || map . isEmpty () ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] }
final Map . Entry < K , V > entry = ( Map . Entry < K , V > ) element ; map . put ( entry . getKey () , entry . getValue () ) ; MST[NonVoidMethodCallMutator]MSP[] } } else if ( obj instanceof KeyValue ) {
for ( int i = 0 ; i < array . length - 1 ; ) { map . put ( ( K ) array [ i ++ ] , ( V ) array [ i ++ ] ) ; MST[rv.UOI1Mutator]MSP[] } } return map ; }
final Number answer = getNumber ( map , key ) ; if ( answer == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return null ; } if ( answer instanceof Short ) { return ( Short ) answer ; } return Short . valueOf ( answer . shortValue () ) ; }
out . print ( lr_10 + ( lineage . size () - 1 - lineageIndex - 1 ) + lr_11 ) ; MST[MathMutator]MSP[] } if ( debug && childValue != null ) { out . print ( ' ' ) ;
if ( childValue instanceof Map && ! lineage . contains ( childValue ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] verbosePrintInternal ( out , childKey == null ? lr_7 : childKey , ( Map < ? , ? > ) childValue , lineage , debug ) ; } else {
public static < K > Double getDouble ( final Map < ? super K , ? > map , final K key , final Function < K , Double > defaultFunction ) { return applyDefaultFunction ( map , key , MapUtils :: getDouble , defaultFunction ) ; MST[ReturnValsMutator]MSP[] }
final Object answer = map . get ( key ) ; if ( answer != null ) { if ( answer instanceof Number ) { MST[rv.ROR4Mutator]MSP[] return ( Number ) answer ; } if ( answer instanceof String ) { try { final String text = ( String ) answer ;
if ( array == null || array . length == 0 ) { return map ; } final Object obj = array [ 0 ] ; if ( obj instanceof Map . Entry ) { MST[rv.ROR4Mutator]MSP[] for ( final Object element : array ) {
out . print ( label ) ; out . println ( lr_6 ) ; } printIndent ( out , lineage . size () ) ; MST[VoidMethodCallMutator]MSP[] out . println ( lr_8 ) ; lineage . addLast ( map ) ;
if ( answer instanceof Boolean ) { MST[NegateConditionalsMutator]MSP[] return ( Boolean ) answer ; } if ( answer instanceof String ) { return Boolean . valueOf ( ( String ) answer ) ; } if ( answer instanceof Number ) { final Number n = ( Number ) answer ;
public static < K > short getShortValue ( final Map < ? super K , ? > map , final K key , final short defaultValue ) { return applyDefaultValue ( map , key , MapUtils :: getShort , defaultValue ) . shortValue () ; MST[ArgumentPropagationMutator]MSP[] }
return applyDefaultFunction ( map , key , MapUtils :: getFloat , defaultFunction , 0f ) . floatValue () ; MST[InlineConstantMutator]MSP[] } public static < K > Integer getInteger ( final Map < ? super K , ? > map , final K key ) {
final Function < K , Number > defaultFunction ) { return applyDefaultFunction ( map , key , MapUtils :: getNumber , defaultFunction ) ; MST[NonVoidMethodCallMutator]MSP[] }
public static < K > String getString ( final Map < ? super K , ? > map , final K key ) { if ( map != null ) { final Object answer = map . get ( key ) ; MST[ArgumentPropagationMutator]MSP[] if ( answer != null ) {
} else if ( obj instanceof Object [] ) { for ( int i = 0 ; i < array . length ; i ++ ) { MST[rv.UOI3Mutator]MSP[] final Object [] sub = ( Object [] ) array [ i ] ;
final Number answer = getNumber ( map , key ) ; if ( answer == null ) { return null ; MST[ReturnValsMutator]MSP[] } if ( answer instanceof Short ) { return ( Short ) answer ; } return Short . valueOf ( answer . shortValue () ) ; }
public static < K > double getDoubleValue ( final Map < ? super K , ? > map , final K key , final double defaultValue ) { return applyDefaultValue ( map , key , MapUtils :: getDouble , defaultValue ) . doubleValue () ; MST[rv.UOI4Mutator]MSP[] }
Objects . requireNonNull ( map , lr_1 ) ; MST[NonVoidMethodCallMutator]MSP[] return map instanceof IterableMap ? ( IterableMap < K , V > ) map : new AbstractMapDecorator < K , V > ( map ) { } ; }
final Number answer = getNumber ( map , key ) ; if ( answer == null ) { return null ; } if ( answer instanceof Float ) { MST[rv.ROR1Mutator]MSP[] return ( Float ) answer ; } return Float . valueOf ( answer . floatValue () ) ; }
if ( answer instanceof Boolean ) { return ( Boolean ) answer ; } if ( answer instanceof String ) { MST[rv.ROR3Mutator]MSP[] return Boolean . valueOf ( ( String ) answer ) ; } if ( answer instanceof Number ) { final Number n = ( Number ) answer ;
final Object answer = map . get ( key ) ; if ( answer != null ) { if ( answer instanceof Number ) { return ( Number ) answer ; MST[NullReturnValsMutator]MSP[] } if ( answer instanceof String ) { try { final String text = ( String ) answer ;
if ( childValue instanceof Map && ! lineage . contains ( childValue ) ) { verbosePrintInternal ( out , childKey == null ? lr_7 : childKey , ( Map < ? , ? > ) childValue , lineage , debug ) ; MST[rv.UOI2Mutator]MSP[] } else {
if ( array == null || array . length == 0 ) { return map ; } final Object obj = array [ 0 ] ; if ( obj instanceof Map . Entry ) { for ( final Object element : array ) { MST[rv.UOI1Mutator]MSP[]
public static < K > short getShortValue ( final Map < ? super K , ? > map , final K key ) { return applyDefaultValue ( map , key , MapUtils :: getShort , 0 ) . shortValue () ; MST[NonVoidMethodCallMutator]MSP[] }
final Object answer = map . get ( key ) ; if ( answer != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] if ( answer instanceof Number ) { return ( Number ) answer ; } if ( answer instanceof String ) { try { final String text = ( String ) answer ;
if ( array == null || array . length == 0 ) { return map ; } final Object obj = array [ 0 ] ; if ( obj instanceof Map . Entry ) { for ( final Object element : array ) { MST[rv.UOI3Mutator]MSP[]
out . print ( childValue ) ; MST[VoidMethodCallMutator]MSP[] } else if ( lineage . size () - 1 == lineageIndex ) { out . print ( lr_9 ) ; } else {
public static < K > boolean getBooleanValue ( final Map < ? super K , ? > map , final K key ) { return Boolean . TRUE . equals ( getBoolean ( map , key ) ) ; MST[ReturnValsMutator]MSP[] }
public static int size ( final Map < ? , ? > map ) { return map == null ? 0 : map . size () ; MST[NegateConditionalsMutator]MSP[] }
out . print ( lr_10 + ( lineage . size () - 1 - lineageIndex - 1 ) + lr_11 ) ; MST[rv.CRCR3Mutator]MSP[] } if ( debug && childValue != null ) { out . print ( ' ' ) ;
if ( answer instanceof Boolean ) { return ( Boolean ) answer ; } if ( answer instanceof String ) { return Boolean . valueOf ( ( String ) answer ) ; } if ( answer instanceof Number ) { MST[rv.ROR2Mutator]MSP[] final Number n = ( Number ) answer ;
out . put ( entry . getValue () , entry . getKey () ) ; } return out ; } public static boolean isEmpty ( final Map < ? , ? > map ) { return map == null || map . isEmpty () ; MST[rv.ROR4Mutator]MSP[] }
final Iterator < ? extends E > iter = elements . iterator () ; while ( iter . hasNext () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] final E temp = iter . next () ; map . put ( keyTransformer . transform ( temp ) , valueTransformer . transform ( temp ) ) ;
if ( childValue instanceof Map && ! lineage . contains ( childValue ) ) { MST[rv.ROR3Mutator]MSP[] verbosePrintInternal ( out , childKey == null ? lr_7 : childKey , ( Map < ? , ? > ) childValue , lineage , debug ) ; } else {
return applyDefaultFunction ( map , key , MapUtils :: getFloat , defaultFunction , 0f ) . floatValue () ; MST[NonVoidMethodCallMutator]MSP[] } public static < K > Integer getInteger ( final Map < ? super K , ? > map , final K key ) {
out . put ( entry . getValue () , entry . getKey () ) ; MST[NonVoidMethodCallMutator]MSP[] } return out ; } public static boolean isEmpty ( final Map < ? , ? > map ) { return map == null || map . isEmpty () ; }
for ( final Object element : array ) { MST[rv.UOI1Mutator]MSP[] final KeyValue < K , V > keyval = ( KeyValue < K , V > ) element ; map . put ( keyval . getKey () , keyval . getValue () ) ; }
if ( map != null ) { final Object answer = map . get ( key ) ; if ( answer != null && answer instanceof Map ) { return ( Map < ? , ? > ) answer ; } } return null ; MST[ReturnValsMutator]MSP[] }
final Number answer = getNumber ( map , key ) ; if ( answer == null ) { MST[rv.ROR5Mutator]MSP[] return null ; } if ( answer instanceof Short ) { return ( Short ) answer ; } return Short . valueOf ( answer . shortValue () ) ; }
if ( array == null || array . length == 0 ) { MST[rv.ROR4Mutator]MSP[] return map ; } final Object obj = array [ 0 ] ; if ( obj instanceof Map . Entry ) { for ( final Object element : array ) {
out . print ( lr_10 + ( lineage . size () - 1 - lineageIndex - 1 ) + lr_11 ) ; MST[rv.AOD2Mutator]MSP[] } if ( debug && childValue != null ) { out . print ( ' ' ) ;
final Number answer = getNumber ( map , key ) ; if ( answer == null ) { return null ; } if ( answer instanceof Byte ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return ( Byte ) answer ; } return Byte . valueOf ( answer . byteValue () ) ; }
if ( sub == null || sub . length < 2 ) { throw new IllegalArgumentException ( lr_4 + i ) ; MST[ConstructorCallMutator]MSP[] } map . put ( ( K ) sub [ 0 ] , ( V ) sub [ 1 ] ) ; } } else {
out . put ( entry . getValue () , entry . getKey () ) ; } return out ; } public static boolean isEmpty ( final Map < ? , ? > map ) { return map == null || map . isEmpty () ; MST[rv.CRCR1Mutator]MSP[] }
public static < K > Byte getByte ( final Map < ? super K , ? > map , final K key , final Byte defaultValue ) { return applyDefaultValue ( map , key , MapUtils :: getByte , defaultValue ) ; MST[ArgumentPropagationMutator]MSP[] }
return value == null ? defaultValue : value ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] } public static void debugPrint ( final PrintStream out , final Object label , final Map < ? , ? > map ) {
out . print ( lr_10 + ( lineage . size () - 1 - lineageIndex - 1 ) + lr_11 ) ; MST[experimental.NakedReceiverMutator]MSP[] } if ( debug && childValue != null ) { out . print ( ' ' ) ;
final Number answer = getNumber ( map , key ) ; if ( answer == null ) { return null ; } if ( answer instanceof Long ) { MST[rv.ROR3Mutator]MSP[] return ( Long ) answer ; } return Long . valueOf ( answer . longValue () ) ; }
final Number answer = getNumber ( map , key ) ; if ( answer == null ) { return null ; } if ( answer instanceof Long ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return ( Long ) answer ; } return Long . valueOf ( answer . longValue () ) ; }
public static int size ( final Map < ? , ? > map ) { return map == null ? 0 : map . size () ; MST[rv.CRCR3Mutator]MSP[] }
final BiFunction < Map < ? super K , ? > , K , R > getFunction , final R defaultValue ) { final R value = map != null && getFunction != null ? getFunction . apply ( map , key ) : null ; MST[ArgumentPropagationMutator]MSP[]
verbosePrintInternal ( out , label , map , new ArrayDeque < Map < ? , ? > > () , true ) ; MST[rv.CRCR3Mutator]MSP[] } public static < K , V > Map < K , V > emptyIfNull ( final Map < K , V > map ) {
populateMap ( map , elements , keyTransformer , TransformerUtils . <V > nopTransformer () ) ; MST[VoidMethodCallMutator]MSP[] } public static < K , V , E > void populateMap ( final MultiMap < K , V > map , final Iterable < ? extends E > elements ,
if ( sub == null || sub . length < 2 ) { throw new IllegalArgumentException ( lr_4 + i ) ; } map . put ( ( K ) sub [ 0 ] , ( V ) sub [ 1 ] ) ; MST[rv.CRCR1Mutator]MSP[] } } else {
for ( int i = 0 ; i < array . length - 1 ; ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] map . put ( ( K ) array [ i ++ ] , ( V ) array [ i ++ ] ) ; } } return map ; }
return value == null ? defaultValue : value ; MST[NegateConditionalsMutator]MSP[] } public static void debugPrint ( final PrintStream out , final Object label , final Map < ? , ? > map ) {
public static < K > long getLongValue ( final Map < ? super K , ? > map , final K key ) { return applyDefaultValue ( map , key , MapUtils :: getLong , 0L ) . longValue () ; MST[NonVoidMethodCallMutator]MSP[] }
return applyDefaultFunction ( map , key , MapUtils :: getInteger , defaultFunction , 0 ) . byteValue () ; MST[rv.CRCR3Mutator]MSP[] } public static < K > int getIntValue ( final Map < ? super K , ? > map , final K key , final int defaultValue ) {
final Transformer < E , K > keyTransformer , final Transformer < E , V > valueTransformer ) { final Iterator < ? extends E > iter = elements . iterator () ; while ( iter . hasNext () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] final E temp = iter . next () ;
for ( int i = 0 ; i < array . length - 1 ; ) { map . put ( ( K ) array [ i ++ ] , ( V ) array [ i ++ ] ) ; MST[ArgumentPropagationMutator]MSP[] } } return map ; }
} else if ( obj instanceof Object [] ) { MST[rv.ROR5Mutator]MSP[] for ( int i = 0 ; i < array . length ; i ++ ) { final Object [] sub = ( Object [] ) array [ i ] ;
printIndent ( out , lineage . size () ) ; out . print ( childKey ) ; out . print ( lr_6 ) ; MST[VoidMethodCallMutator]MSP[] final int lineageIndex = IterableUtils . indexOf ( lineage , PredicateUtils . equalPredicate ( childValue ) ) ; if ( lineageIndex == - 1 ) {
return applyDefaultValue ( map , key , MapUtils :: getLong , defaultValue ) . longValue () ; MST[NonVoidMethodCallMutator]MSP[] } public static < K > Map < ? , ? > getMap ( final Map < ? super K , ? > map , final K key ) {
out . print ( lr_10 + ( lineage . size () - 1 - lineageIndex - 1 ) + lr_11 ) ; MST[rv.UOI2Mutator]MSP[] } if ( debug && childValue != null ) { out . print ( ' ' ) ;
final Number answer = getNumber ( map , key ) ; if ( answer == null ) { return null ; } if ( answer instanceof Integer ) { return ( Integer ) answer ; MST[EmptyObjectReturnValsMutator]MSP[] } return Integer . valueOf ( answer . intValue () ) ; }
public static < K > Integer getInteger ( final Map < ? super K , ? > map , final K key , final Function < K , Integer > defaultFunction ) { return applyDefaultFunction ( map , key , MapUtils :: getInteger , defaultFunction ) ; MST[EmptyObjectReturnValsMutator]MSP[] }
final Transformer < E , K > keyTransformer , final Transformer < E , V > valueTransformer ) { final Iterator < ? extends E > iter = elements . iterator () ; while ( iter . hasNext () ) { MST[rv.ROR3Mutator]MSP[] final E temp = iter . next () ;
if ( sub == null || sub . length < 2 ) { MST[ConditionalsBoundaryMutator]MSP[] throw new IllegalArgumentException ( lr_4 + i ) ; } map . put ( ( K ) sub [ 0 ] , ( V ) sub [ 1 ] ) ; } } else {
} else if ( obj instanceof Object [] ) { MST[rv.ROR2Mutator]MSP[] for ( int i = 0 ; i < array . length ; i ++ ) { final Object [] sub = ( Object [] ) array [ i ] ;
public static < K > int getIntValue ( final Map < ? super K , ? > map , final K key ) { return applyDefaultValue ( map , key , MapUtils :: getInteger , 0 ) . intValue () ; MST[ArgumentPropagationMutator]MSP[] }
for ( int i = 0 ; i < array . length - 1 ; ) { MST[rv.ABSMutator]MSP[] map . put ( ( K ) array [ i ++ ] , ( V ) array [ i ++ ] ) ; } } return map ; }
final BiFunction < Map < ? super K , ? > , K , R > getFunction , final R defaultValue ) { final R value = map != null && getFunction != null ? getFunction . apply ( map , key ) : null ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
final Number answer = getNumber ( map , key ) ; if ( answer == null ) { return null ; } if ( answer instanceof Byte ) { MST[rv.ROR3Mutator]MSP[] return ( Byte ) answer ; } return Byte . valueOf ( answer . byteValue () ) ; }
public static < K > float getFloatValue ( final Map < ? super K , ? > map , final K key ) { return applyDefaultValue ( map , key , MapUtils :: getFloat , 0f ) . floatValue () ; MST[rv.CRCR5Mutator]MSP[] }
public static < K > float getFloatValue ( final Map < ? super K , ? > map , final K key , final float defaultValue ) { return applyDefaultValue ( map , key , MapUtils :: getFloat , defaultValue ) . floatValue () ; MST[rv.UOI4Mutator]MSP[] }
return applyDefaultFunction ( map , key , MapUtils :: getDouble , defaultFunction , 0d ) . doubleValue () ; MST[InlineConstantMutator]MSP[] } public static < K > Float getFloat ( final Map < ? super K , ? > map , final K key ) {
out . print ( lr_10 + ( lineage . size () - 1 - lineageIndex - 1 ) + lr_11 ) ; MST[rv.AOR4Mutator]MSP[] } if ( debug && childValue != null ) { out . print ( ' ' ) ;
for ( int i = 0 ; i < array . length - 1 ; ) { MST[rv.CRCR1Mutator]MSP[] map . put ( ( K ) array [ i ++ ] , ( V ) array [ i ++ ] ) ; } } return map ; }
public static < K > Boolean getBoolean ( final Map < ? super K , ? > map , final K key ) { if ( map != null ) { MST[rv.ROR5Mutator]MSP[] final Object answer = map . get ( key ) ; if ( answer != null ) {
final Object value = resourceBundle . getObject ( key ) ; map . put ( key , value ) ; MST[NonVoidMethodCallMutator]MSP[] } return map ; } public static < K , V > Properties toProperties ( final Map < K , V > map ) {
} else if ( obj instanceof Object [] ) { for ( int i = 0 ; i < array . length ; i ++ ) { MST[rv.CRCR5Mutator]MSP[] final Object [] sub = ( Object [] ) array [ i ] ;
final BiFunction < Map < ? super K , ? > , K , R > getFunction , final R defaultValue ) { final R value = map != null && getFunction != null ? getFunction . apply ( map , key ) : null ; MST[NegateConditionalsMutator]MSP[]
printIndent ( out , lineage . size () ) ; out . print ( childKey ) ; out . print ( lr_6 ) ; final int lineageIndex = IterableUtils . indexOf ( lineage , PredicateUtils . equalPredicate ( childValue ) ) ; if ( lineageIndex == - 1 ) { MST[rv.ROR3Mutator]MSP[]
final Number answer = getNumber ( map , key ) ; if ( answer == null ) { return null ; } if ( answer instanceof Double ) { return ( Double ) answer ; MST[ReturnValsMutator]MSP[] } return Double . valueOf ( answer . doubleValue () ) ; }
return applyDefaultFunction ( map , key , MapUtils :: getByte , defaultFunction , ( byte ) 0 ) . byteValue () ; MST[PrimitiveReturnsMutator]MSP[] } public static < K > Double getDouble ( final Map < ? super K , ? > map , final K key ) {
out . print ( lr_10 + ( lineage . size () - 1 - lineageIndex - 1 ) + lr_11 ) ; MST[MathMutator]MSP[] } if ( debug && childValue != null ) { out . print ( ' ' ) ;
out . print ( childValue ) ; } else if ( lineage . size () - 1 == lineageIndex ) { MST[rv.CRCR6Mutator]MSP[] out . print ( lr_9 ) ; } else {
public static < K > Byte getByte ( final Map < ? super K , ? > map , final K key , final Byte defaultValue ) { return applyDefaultValue ( map , key , MapUtils :: getByte , defaultValue ) ; MST[ReturnValsMutator]MSP[] }
if ( answer instanceof Boolean ) { return ( Boolean ) answer ; } if ( answer instanceof String ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return Boolean . valueOf ( ( String ) answer ) ; } if ( answer instanceof Number ) { final Number n = ( Number ) answer ;
printIndent ( out , lineage . size () ) ; out . print ( childKey ) ; out . print ( lr_6 ) ; final int lineageIndex = IterableUtils . indexOf ( lineage , PredicateUtils . equalPredicate ( childValue ) ) ; if ( lineageIndex == - 1 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
} else if ( obj instanceof Object [] ) { MST[NegateConditionalsMutator]MSP[] for ( int i = 0 ; i < array . length ; i ++ ) { final Object [] sub = ( Object [] ) array [ i ] ;
out . println ( debug ? lr_12 + map . getClass () . getName () : lr_13 ) ; MST[rv.ROR2Mutator]MSP[] }
if ( map == null ) { if ( label != null ) { out . print ( label ) ; MST[VoidMethodCallMutator]MSP[] out . print ( lr_6 ) ; } out . println ( lr_7 ) ; return; } if ( label != null ) {
public static < K > boolean getBooleanValue ( final Map < ? super K , ? > map , final K key , final boolean defaultValue ) { return applyDefaultValue ( map , key , MapUtils :: getBoolean , defaultValue ) . booleanValue () ; MST[rv.ABSMutator]MSP[] }
for ( int i = 0 ; i < array . length - 1 ; ) { map . put ( ( K ) array [ i ++ ] , ( V ) array [ i ++ ] ) ; MST[rv.UOI1Mutator]MSP[] } } return map ; }
if ( map != null ) { final Object answer = map . get ( key ) ; if ( answer != null && answer instanceof Map ) { MST[rv.ROR3Mutator]MSP[] return ( Map < ? , ? > ) answer ; } } return null ; }
final Enumeration < String > enumeration = resourceBundle . getKeys () ; final Map < String , Object > map = new HashMap <> () ; while ( enumeration . hasMoreElements () ) { MST[rv.ROR1Mutator]MSP[] final String key = enumeration . nextElement () ;
out . print ( lr_10 + ( lineage . size () - 1 - lineageIndex - 1 ) + lr_11 ) ; MST[rv.ABSMutator]MSP[] } if ( debug && childValue != null ) { out . print ( ' ' ) ;
final Number answer = getNumber ( map , key ) ; if ( answer == null ) { return null ; } if ( answer instanceof Float ) { return ( Float ) answer ; } return Float . valueOf ( answer . floatValue () ) ; MST[NonVoidMethodCallMutator]MSP[] }
if ( sub == null || sub . length < 2 ) { MST[rv.CRCR6Mutator]MSP[] throw new IllegalArgumentException ( lr_4 + i ) ; } map . put ( ( K ) sub [ 0 ] , ( V ) sub [ 1 ] ) ; } } else {
public static < K > String getString ( final Map < ? super K , ? > map , final K key ) { if ( map != null ) { final Object answer = map . get ( key ) ; if ( answer != null ) { MST[NegateConditionalsMutator]MSP[]
final Number answer = getNumber ( map , key ) ; if ( answer == null ) { return null ; } if ( answer instanceof Short ) { MST[rv.ROR4Mutator]MSP[] return ( Short ) answer ; } return Short . valueOf ( answer . shortValue () ) ; }
public static < K > Integer getInteger ( final Map < ? super K , ? > map , final K key , final Integer defaultValue ) { return applyDefaultValue ( map , key , MapUtils :: getInteger , defaultValue ) ; MST[EmptyObjectReturnValsMutator]MSP[] }
final Enumeration < String > enumeration = resourceBundle . getKeys () ; final Map < String , Object > map = new HashMap <> () ; while ( enumeration . hasMoreElements () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] final String key = enumeration . nextElement () ;
Objects . requireNonNull ( map , lr_1 ) ; return map instanceof IterableMap ? ( IterableMap < K , V > ) map : new AbstractMapDecorator < K , V > ( map ) { MST[NullReturnValsMutator]MSP[] } ; }
if ( answer instanceof Boolean ) { return ( Boolean ) answer ; } if ( answer instanceof String ) { return Boolean . valueOf ( ( String ) answer ) ; MST[ReturnValsMutator]MSP[] } if ( answer instanceof Number ) { final Number n = ( Number ) answer ;
public static < K > byte getByteValue ( final Map < ? super K , ? > map , final K key , final byte defaultValue ) { return applyDefaultValue ( map , key , MapUtils :: getByte , defaultValue ) . byteValue () ; MST[rv.UOI3Mutator]MSP[] }
out . print ( childValue ) ; } else if ( lineage . size () - 1 == lineageIndex ) { out . print ( lr_9 ) ; MST[VoidMethodCallMutator]MSP[] } else {
} else if ( obj instanceof Object [] ) { for ( int i = 0 ; i < array . length ; i ++ ) { MST[rv.ROR1Mutator]MSP[] final Object [] sub = ( Object [] ) array [ i ] ;
final Number answer = getNumber ( map , key ) ; if ( answer == null ) { return null ; } if ( answer instanceof Double ) { return ( Double ) answer ; } return Double . valueOf ( answer . doubleValue () ) ; MST[NonVoidMethodCallMutator]MSP[] }
public static void verbosePrint ( final PrintStream out , final Object label , final Map < ? , ? > map ) { verbosePrintInternal ( out , label , map , new ArrayDeque < Map < ? , ? > > () , false ) ; MST[rv.CRCR6Mutator]MSP[] }
if ( answer instanceof Boolean ) { return ( Boolean ) answer ; } if ( answer instanceof String ) { MST[NegateConditionalsMutator]MSP[] return Boolean . valueOf ( ( String ) answer ) ; } if ( answer instanceof Number ) { final Number n = ( Number ) answer ;
} else if ( obj instanceof Object [] ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] for ( int i = 0 ; i < array . length ; i ++ ) { final Object [] sub = ( Object [] ) array [ i ] ;
public static < K > short getShortValue ( final Map < ? super K , ? > map , final K key ) { return applyDefaultValue ( map , key , MapUtils :: getShort , 0 ) . shortValue () ; MST[PrimitiveReturnsMutator]MSP[] }
final Iterator < ? extends E > iter = elements . iterator () ; while ( iter . hasNext () ) { MST[NonVoidMethodCallMutator]MSP[] final E temp = iter . next () ; map . put ( keyTransformer . transform ( temp ) , valueTransformer . transform ( temp ) ) ;
return applyDefaultValue ( map , key , MapUtils :: getString , defaultValue ) ; MST[NonVoidMethodCallMutator]MSP[] } public static < K , V > Map < V , K > invertMap ( final Map < K , V > map ) {
if ( sub == null || sub . length < 2 ) { throw new IllegalArgumentException ( lr_4 + i ) ; } map . put ( ( K ) sub [ 0 ] , ( V ) sub [ 1 ] ) ; MST[rv.CRCR2Mutator]MSP[] } } else {
public static boolean isNotEmpty ( final Map < ? , ? > map ) { return ! MapUtils . isEmpty ( map ) ; MST[rv.CRCR3Mutator]MSP[] } public static < K , V > IterableMap < K , V > iterableMap ( final Map < K , V > map ) {
for ( final Object element : array ) { MST[rv.UOI2Mutator]MSP[] final KeyValue < K , V > keyval = ( KeyValue < K , V > ) element ; map . put ( keyval . getKey () , keyval . getValue () ) ; }
return applyDefaultValue ( map , key , MapUtils :: getInteger , defaultValue ) . intValue () ; MST[rv.UOI4Mutator]MSP[] } public static < K > Long getLong ( final Map < ? super K , ? > map , final K key ) {
return applyDefaultValue ( map , key , MapUtils :: getInteger , defaultValue ) . intValue () ; MST[rv.UOI2Mutator]MSP[] } public static < K > Long getLong ( final Map < ? super K , ? > map , final K key ) {
public static < K , V > IterableSortedMap < K , V > iterableSortedMap ( final SortedMap < K , V > sortedMap ) { Objects . requireNonNull ( sortedMap , lr_2 ) ; return sortedMap instanceof IterableSortedMap ? ( IterableSortedMap < K , V > ) sortedMap MST[rv.ROR5Mutator]MSP[]
if ( answer != null ) { return answer ; } } return defaultValue ; MST[ReturnValsMutator]MSP[] } public static < K > Short getShort ( final Map < ? super K , ? > map , final K key ) {
for ( final Object element : array ) { final KeyValue < K , V > keyval = ( KeyValue < K , V > ) element ; map . put ( keyval . getKey () , keyval . getValue () ) ; MST[NonVoidMethodCallMutator]MSP[] }
return value != null ? value : defaultValue ; MST[NullReturnValsMutator]MSP[] } private static < K , R > R applyDefaultValue ( final Map < ? super K , ? > map , final K key ,
} else if ( obj instanceof Object [] ) { for ( int i = 0 ; i < array . length ; i ++ ) { MST[InlineConstantMutator]MSP[] final Object [] sub = ( Object [] ) array [ i ] ;
public static < K , V > IterableSortedMap < K , V > iterableSortedMap ( final SortedMap < K , V > sortedMap ) { Objects . requireNonNull ( sortedMap , lr_2 ) ; return sortedMap instanceof IterableSortedMap ? ( IterableSortedMap < K , V > ) sortedMap MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
out . print ( lr_10 + ( lineage . size () - 1 - lineageIndex - 1 ) + lr_11 ) ; MST[rv.UOI4Mutator]MSP[] } if ( debug && childValue != null ) { out . print ( ' ' ) ;
public static < K > int getIntValue ( final Map < ? super K , ? > map , final K key ) { return applyDefaultValue ( map , key , MapUtils :: getInteger , 0 ) . intValue () ; MST[rv.CRCR6Mutator]MSP[] }
public static < K > String getString ( final Map < ? super K , ? > map , final K key ) { if ( map != null ) { final Object answer = map . get ( key ) ; if ( answer != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
if ( childValue instanceof Map && ! lineage . contains ( childValue ) ) { verbosePrintInternal ( out , childKey == null ? lr_7 : childKey , ( Map < ? , ? > ) childValue , lineage , debug ) ; MST[rv.ABSMutator]MSP[] } else {
return applyDefaultFunction ( map , key , MapUtils :: getDouble , defaultFunction , 0d ) . doubleValue () ; MST[rv.CRCR5Mutator]MSP[] } public static < K > Float getFloat ( final Map < ? super K , ? > map , final K key ) {
if ( array == null || array . length == 0 ) { return map ; MST[NullReturnValsMutator]MSP[] } final Object obj = array [ 0 ] ; if ( obj instanceof Map . Entry ) { for ( final Object element : array ) {
for ( int i = 0 ; i < indent ; i ++ ) { MST[rv.UOI1Mutator]MSP[] out . print ( INDENT_STRING ) ; } } @SuppressWarnings ( lr_3 )
public static < K > Boolean getBoolean ( final Map < ? super K , ? > map , final K key , final Function < K , Boolean > defaultFunction ) { return applyDefaultFunction ( map , key , MapUtils :: getBoolean , defaultFunction ) ; MST[ReturnValsMutator]MSP[] }
public static < K > Float getFloat ( final Map < ? super K , ? > map , final K key , final Function < K , Float > defaultFunction ) { return applyDefaultFunction ( map , key , MapUtils :: getFloat , defaultFunction ) ; MST[NonVoidMethodCallMutator]MSP[] }
for ( int i = 0 ; i < array . length - 1 ; ) { map . put ( ( K ) array [ i ++ ] , ( V ) array [ i ++ ] ) ; MST[experimental.RemoveIncrementsMutator]MSP[] } } return map ; }
out . println ( childValue . getClass () . getName () ) ; } else { out . println () ; } } } lineage . removeLast () ; printIndent ( out , lineage . size () ) ; MST[VoidMethodCallMutator]MSP[]
public static < K > long getLongValue ( final Map < ? super K , ? > map , final K key ) { return applyDefaultValue ( map , key , MapUtils :: getLong , 0L ) . longValue () ; MST[rv.CRCR6Mutator]MSP[] }
return NumberFormat . getInstance () . parse ( text ) ; } catch ( final ParseException e ) { } } } } return null ; MST[ReturnValsMutator]MSP[] } public static < K > Number getNumber ( final Map < ? super K , ? > map , final K key ,
final Map . Entry < K , V > entry = ( Map . Entry < K , V > ) element ; map . put ( entry . getKey () , entry . getValue () ) ; } } else if ( obj instanceof KeyValue ) { MST[rv.ROR4Mutator]MSP[]
final Iterator < ? extends E > iter = elements . iterator () ; while ( iter . hasNext () ) { final E temp = iter . next () ; map . put ( keyTransformer . transform ( temp ) , valueTransformer . transform ( temp ) ) ; MST[NonVoidMethodCallMutator]MSP[]
printIndent ( out , lineage . size () ) ; out . print ( childKey ) ; out . print ( lr_6 ) ; final int lineageIndex = IterableUtils . indexOf ( lineage , PredicateUtils . equalPredicate ( childValue ) ) ; if ( lineageIndex == - 1 ) { MST[rv.UOI1Mutator]MSP[]
return applyDefaultValue ( map , key , MapUtils :: getString , defaultValue ) ; MST[ReturnValsMutator]MSP[] } public static < K , V > Map < V , K > invertMap ( final Map < K , V > map ) {
public static < K > float getFloatValue ( final Map < ? super K , ? > map , final K key , final float defaultValue ) { return applyDefaultValue ( map , key , MapUtils :: getFloat , defaultValue ) . floatValue () ; MST[rv.UOI2Mutator]MSP[] }
final Number answer = getNumber ( map , key ) ; if ( answer == null ) { return null ; } if ( answer instanceof Double ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return ( Double ) answer ; } return Double . valueOf ( answer . doubleValue () ) ; }
if ( childValue instanceof Map && ! lineage . contains ( childValue ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] verbosePrintInternal ( out , childKey == null ? lr_7 : childKey , ( Map < ? , ? > ) childValue , lineage , debug ) ; } else {
out . println ( debug ? lr_12 + map . getClass () . getName () : lr_13 ) ; MST[experimental.NakedReceiverMutator]MSP[] }
public static < K > short getShortValue ( final Map < ? super K , ? > map , final K key , final short defaultValue ) { return applyDefaultValue ( map , key , MapUtils :: getShort , defaultValue ) . shortValue () ; MST[PrimitiveReturnsMutator]MSP[] }
final Number answer = getNumber ( map , key ) ; if ( answer == null ) { return null ; } if ( answer instanceof Double ) { return ( Double ) answer ; } return Double . valueOf ( answer . doubleValue () ) ; MST[EmptyObjectReturnValsMutator]MSP[] }
public static int size ( final Map < ? , ? > map ) { return map == null ? 0 : map . size () ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] }
for ( int i = 0 ; i < indent ; i ++ ) { MST[rv.CRCR6Mutator]MSP[] out . print ( INDENT_STRING ) ; } } @SuppressWarnings ( lr_3 )
out . print ( lr_10 + ( lineage . size () - 1 - lineageIndex - 1 ) + lr_11 ) ; MST[MathMutator]MSP[] } if ( debug && childValue != null ) { out . print ( ' ' ) ;
final Iterator < ? extends E > iter = elements . iterator () ; while ( iter . hasNext () ) { MST[rv.ROR5Mutator]MSP[] final E temp = iter . next () ; map . put ( keyTransformer . transform ( temp ) , valueTransformer . transform ( temp ) ) ;
return applyDefaultValue ( map , key , MapUtils :: getInteger , defaultValue ) . intValue () ; MST[rv.ABSMutator]MSP[] } public static < K > Long getLong ( final Map < ? super K , ? > map , final K key ) {
final Object answer = map . get ( key ) ; if ( answer != null ) { if ( answer instanceof Number ) { return ( Number ) answer ; } if ( answer instanceof String ) { MST[rv.ROR5Mutator]MSP[] try { final String text = ( String ) answer ;
return applyDefaultFunction ( map , key , MapUtils :: getShort , defaultFunction , ( short ) 0 ) . shortValue () ; MST[rv.CRCR5Mutator]MSP[] }
public static < K > float getFloatValue ( final Map < ? super K , ? > map , final K key ) { return applyDefaultValue ( map , key , MapUtils :: getFloat , 0f ) . floatValue () ; MST[rv.CRCR3Mutator]MSP[] }
return applyDefaultValue ( map , key , MapUtils :: getLong , defaultValue ) . longValue () ; MST[rv.UOI3Mutator]MSP[] } public static < K > Map < ? , ? > getMap ( final Map < ? super K , ? > map , final K key ) {
out . print ( lr_10 + ( lineage . size () - 1 - lineageIndex - 1 ) + lr_11 ) ; } if ( debug && childValue != null ) { MST[rv.UOI1Mutator]MSP[] out . print ( ' ' ) ;
final Number answer = getNumber ( map , key ) ; if ( answer == null ) { return null ; } if ( answer instanceof Byte ) { MST[NegateConditionalsMutator]MSP[] return ( Byte ) answer ; } return Byte . valueOf ( answer . byteValue () ) ; }
for ( int i = 0 ; i < array . length - 1 ; ) { MST[rv.UOI2Mutator]MSP[] map . put ( ( K ) array [ i ++ ] , ( V ) array [ i ++ ] ) ; } } return map ; }
return applyDefaultFunction ( map , key , MapUtils :: getByte , defaultFunction , ( byte ) 0 ) . byteValue () ; MST[ArgumentPropagationMutator]MSP[] } public static < K > Double getDouble ( final Map < ? super K , ? > map , final K key ) {
public static int size ( final Map < ? , ? > map ) { return map == null ? 0 : map . size () ; MST[PrimitiveReturnsMutator]MSP[] }
final Object value = resourceBundle . getObject ( key ) ; map . put ( key , value ) ; MST[ArgumentPropagationMutator]MSP[] } return map ; } public static < K , V > Properties toProperties ( final Map < K , V > map ) {
final BiFunction < Map < ? super K , ? > , K , R > getFunction , final Function < K , R > defaultFunction ) { return applyDefaultFunction ( map , key , getFunction , defaultFunction , null ) ; MST[ReturnValsMutator]MSP[] }
public static < K > Short getShort ( final Map < ? super K , ? > map , final K key , final Function < K , Short > defaultFunction ) { return applyDefaultFunction ( map , key , MapUtils :: getShort , defaultFunction ) ; MST[ReturnValsMutator]MSP[] }
if ( array == null || array . length == 0 ) { return map ; } final Object obj = array [ 0 ] ; if ( obj instanceof Map . Entry ) { for ( final Object element : array ) { MST[rv.UOI3Mutator]MSP[]
if ( childValue instanceof Map && ! lineage . contains ( childValue ) ) { MST[rv.ROR3Mutator]MSP[] verbosePrintInternal ( out , childKey == null ? lr_7 : childKey , ( Map < ? , ? > ) childValue , lineage , debug ) ; } else {
out . print ( lr_10 + ( lineage . size () - 1 - lineageIndex - 1 ) + lr_11 ) ; MST[rv.CRCR5Mutator]MSP[] } if ( debug && childValue != null ) { out . print ( ' ' ) ;
out . print ( lr_10 + ( lineage . size () - 1 - lineageIndex - 1 ) + lr_11 ) ; MST[rv.CRCR3Mutator]MSP[] } if ( debug && childValue != null ) { out . print ( ' ' ) ;
map . put ( keyTransformer . transform ( temp ) , valueTransformer . transform ( temp ) ) ; MST[NonVoidMethodCallMutator]MSP[] } } public static < K , V > void populateMap ( final MultiMap < K , V > map , final Iterable < ? extends V > elements ,
return value != null ? value : defaultValue ; MST[ReturnValsMutator]MSP[] } private static < K , R > R applyDefaultValue ( final Map < ? super K , ? > map , final K key ,
final Enumeration < String > enumeration = resourceBundle . getKeys () ; final Map < String , Object > map = new HashMap <> () ; while ( enumeration . hasMoreElements () ) { MST[NonVoidMethodCallMutator]MSP[] final String key = enumeration . nextElement () ;
out . print ( childValue ) ; } else if ( lineage . size () - 1 == lineageIndex ) { MST[rv.UOI2Mutator]MSP[] out . print ( lr_9 ) ; } else {
public static < K > float getFloatValue ( final Map < ? super K , ? > map , final K key , final float defaultValue ) { return applyDefaultValue ( map , key , MapUtils :: getFloat , defaultValue ) . floatValue () ; MST[ReturnValsMutator]MSP[] }
out . put ( entry . getValue () , entry . getKey () ) ; } return out ; } public static boolean isEmpty ( final Map < ? , ? > map ) { return map == null || map . isEmpty () ; MST[rv.ROR1Mutator]MSP[] }
final Number answer = getNumber ( map , key ) ; if ( answer == null ) { return null ; } if ( answer instanceof Integer ) { return ( Integer ) answer ; } return Integer . valueOf ( answer . intValue () ) ; MST[NonVoidMethodCallMutator]MSP[] }
for ( int i = 0 ; i < array . length - 1 ; ) { map . put ( ( K ) array [ i ++ ] , ( V ) array [ i ++ ] ) ; MST[NonVoidMethodCallMutator]MSP[] } } return map ; }
for ( final Object element : array ) { MST[rv.UOI3Mutator]MSP[] final KeyValue < K , V > keyval = ( KeyValue < K , V > ) element ; map . put ( keyval . getKey () , keyval . getValue () ) ; }
public static < K > boolean getBooleanValue ( final Map < ? super K , ? > map , final K key , final boolean defaultValue ) { return applyDefaultValue ( map , key , MapUtils :: getBoolean , defaultValue ) . booleanValue () ; MST[ArgumentPropagationMutator]MSP[] }
public static < K > byte getByteValue ( final Map < ? super K , ? > map , final K key ) { return applyDefaultValue ( map , key , MapUtils :: getByte , 0 ) . byteValue () ; MST[NonVoidMethodCallMutator]MSP[] }
final Number answer = getNumber ( map , key ) ; if ( answer == null ) { return null ; } if ( answer instanceof Short ) { return ( Short ) answer ; MST[EmptyObjectReturnValsMutator]MSP[] } return Short . valueOf ( answer . shortValue () ) ; }
printIndent ( out , lineage . size () ) ; out . print ( childKey ) ; out . print ( lr_6 ) ; final int lineageIndex = IterableUtils . indexOf ( lineage , PredicateUtils . equalPredicate ( childValue ) ) ; if ( lineageIndex == - 1 ) { MST[NegateConditionalsMutator]MSP[]
for ( int i = 0 ; i < array . length - 1 ; ) { MST[rv.CRCR5Mutator]MSP[] map . put ( ( K ) array [ i ++ ] , ( V ) array [ i ++ ] ) ; } } return map ; }
public static < K > double getDoubleValue ( final Map < ? super K , ? > map , final K key , final double defaultValue ) { return applyDefaultValue ( map , key , MapUtils :: getDouble , defaultValue ) . doubleValue () ; MST[ReturnValsMutator]MSP[] }
public static boolean isNotEmpty ( final Map < ? , ? > map ) { return ! MapUtils . isEmpty ( map ) ; MST[rv.ROR3Mutator]MSP[] } public static < K , V > IterableMap < K , V > iterableMap ( final Map < K , V > map ) {
final Map . Entry < K , V > entry = ( Map . Entry < K , V > ) element ; map . put ( entry . getKey () , entry . getValue () ) ; } } else if ( obj instanceof KeyValue ) { MST[rv.ROR5Mutator]MSP[]
final Properties answer = new Properties () ; if ( map != null ) { MST[rv.ROR5Mutator]MSP[] for ( final Entry < K , V > entry2 : map . entrySet () ) { final Map . Entry < ? , ? > entry = entry2 ;
final BiFunction < Map < ? super K , ? > , K , R > getFunction , final R defaultValue ) { final R value = map != null && getFunction != null ? getFunction . apply ( map , key ) : null ; MST[NonVoidMethodCallMutator]MSP[]
public static < K > float getFloatValue ( final Map < ? super K , ? > map , final K key ) { return applyDefaultValue ( map , key , MapUtils :: getFloat , 0f ) . floatValue () ; MST[ReturnValsMutator]MSP[] }
public static < K > String getString ( final Map < ? super K , ? > map , final K key ) { if ( map != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] final Object answer = map . get ( key ) ; if ( answer != null ) {
return applyDefaultValue ( map , key , MapUtils :: getString , defaultValue ) ; MST[ArgumentPropagationMutator]MSP[] } public static < K , V > Map < V , K > invertMap ( final Map < K , V > map ) {
if ( array == null || array . length == 0 ) { return map ; } final Object obj = array [ 0 ] ; if ( obj instanceof Map . Entry ) { MST[rv.ROR1Mutator]MSP[] for ( final Object element : array ) {
if ( answer instanceof Boolean ) { return ( Boolean ) answer ; } if ( answer instanceof String ) { return Boolean . valueOf ( ( String ) answer ) ; } if ( answer instanceof Number ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] final Number n = ( Number ) answer ;
return applyDefaultFunction ( map , key , MapUtils :: getShort , defaultFunction , ( short ) 0 ) . shortValue () ; MST[ReturnValsMutator]MSP[] }
final Object answer = map . get ( key ) ; if ( answer != null ) { if ( answer instanceof Number ) { MST[rv.ROR1Mutator]MSP[] return ( Number ) answer ; } if ( answer instanceof String ) { try { final String text = ( String ) answer ;
out . println ( debug ? lr_12 + map . getClass () . getName () : lr_13 ) ; MST[NonVoidMethodCallMutator]MSP[] }
return applyDefaultFunction ( map , key , MapUtils :: getLong , defaultFunction , 0L ) . byteValue () ; MST[NonVoidMethodCallMutator]MSP[] } public static < K > long getLongValue ( final Map < ? super K , ? > map , final K key , final long defaultValue ) {
for ( final Object element : array ) { MST[rv.UOI1Mutator]MSP[] final KeyValue < K , V > keyval = ( KeyValue < K , V > ) element ; map . put ( keyval . getKey () , keyval . getValue () ) ; }
final Object answer = map . get ( key ) ; if ( answer != null ) { if ( answer instanceof Number ) { return ( Number ) answer ; } if ( answer instanceof String ) { MST[NegateConditionalsMutator]MSP[] try { final String text = ( String ) answer ;
public static < K > double getDoubleValue ( final Map < ? super K , ? > map , final K key ) { return applyDefaultValue ( map , key , MapUtils :: getDouble , 0d ) . doubleValue () ; MST[rv.CRCR3Mutator]MSP[] }
return applyDefaultValue ( map , key , MapUtils :: getInteger , defaultValue ) . intValue () ; MST[ReturnValsMutator]MSP[] } public static < K > Long getLong ( final Map < ? super K , ? > map , final K key ) {
final Object answer = map . get ( key ) ; if ( answer != null ) { if ( answer instanceof Number ) { return ( Number ) answer ; } if ( answer instanceof String ) { MST[rv.ROR4Mutator]MSP[] try { final String text = ( String ) answer ;
if ( sub == null || sub . length < 2 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] throw new IllegalArgumentException ( lr_4 + i ) ; } map . put ( ( K ) sub [ 0 ] , ( V ) sub [ 1 ] ) ; } } else {
return applyDefaultFunction ( map , key , MapUtils :: getLong , defaultFunction , 0L ) . byteValue () ; MST[PrimitiveReturnsMutator]MSP[] } public static < K > long getLongValue ( final Map < ? super K , ? > map , final K key , final long defaultValue ) {
final Transformer < E , K > keyTransformer , final Transformer < E , V > valueTransformer ) { final Iterator < ? extends E > iter = elements . iterator () ; while ( iter . hasNext () ) { MST[NonVoidMethodCallMutator]MSP[] final E temp = iter . next () ;
out . println ( debug ? lr_12 + map . getClass () . getName () : lr_13 ) ; MST[ConstructorCallMutator]MSP[] }
public static < K > boolean getBooleanValue ( final Map < ? super K , ? > map , final K key ) { return Boolean . TRUE . equals ( getBoolean ( map , key ) ) ; MST[NonVoidMethodCallMutator]MSP[] }
public static void verbosePrint ( final PrintStream out , final Object label , final Map < ? , ? > map ) { verbosePrintInternal ( out , label , map , new ArrayDeque < Map < ? , ? > > () , false ) ; MST[rv.CRCR1Mutator]MSP[] }
public static < K > double getDoubleValue ( final Map < ? super K , ? > map , final K key ) { return applyDefaultValue ( map , key , MapUtils :: getDouble , 0d ) . doubleValue () ; MST[NonVoidMethodCallMutator]MSP[] }
public static < K > byte getByteValue ( final Map < ? super K , ? > map , final K key ) { return applyDefaultValue ( map , key , MapUtils :: getByte , 0 ) . byteValue () ; MST[InlineConstantMutator]MSP[] }
} else if ( obj instanceof Object [] ) { for ( int i = 0 ; i < array . length ; i ++ ) { final Object [] sub = ( Object [] ) array [ i ] ; MST[rv.UOI1Mutator]MSP[]
if ( sub == null || sub . length < 2 ) { throw new IllegalArgumentException ( lr_4 + i ) ; MST[NonVoidMethodCallMutator]MSP[] } map . put ( ( K ) sub [ 0 ] , ( V ) sub [ 1 ] ) ; } } else {
final Map . Entry < K , V > entry = ( Map . Entry < K , V > ) element ; map . put ( entry . getKey () , entry . getValue () ) ; MST[NonVoidMethodCallMutator]MSP[] } } else if ( obj instanceof KeyValue ) {
final Properties answer = new Properties () ; if ( map != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] for ( final Entry < K , V > entry2 : map . entrySet () ) { final Map . Entry < ? , ? > entry = entry2 ;
return applyDefaultFunction ( map , key , MapUtils :: getBoolean , defaultFunction , false ) . booleanValue () ; MST[rv.CRCR5Mutator]MSP[] } public static < K > Byte getByte ( final Map < ? super K , ? > map , final K key ) {
public static < K > long getLongValue ( final Map < ? super K , ? > map , final K key ) { return applyDefaultValue ( map , key , MapUtils :: getLong , 0L ) . longValue () ; MST[rv.CRCR1Mutator]MSP[] }
for ( int i = 0 ; i < indent ; i ++ ) { MST[rv.ROR4Mutator]MSP[] out . print ( INDENT_STRING ) ; } } @SuppressWarnings ( lr_3 )
R value = map != null && getFunction != null ? getFunction . apply ( map , key ) : null ; if ( value == null ) { value = defaultFunction != null ? defaultFunction . apply ( key ) : null ; MST[NegateConditionalsMutator]MSP[] }
final Number answer = getNumber ( map , key ) ; if ( answer == null ) { return null ; } if ( answer instanceof Float ) { return ( Float ) answer ; } return Float . valueOf ( answer . floatValue () ) ; MST[EmptyObjectReturnValsMutator]MSP[] }
public static < K > Byte getByte ( final Map < ? super K , ? > map , final K key , final Function < K , Byte > defaultFunction ) { return applyDefaultFunction ( map , key , MapUtils :: getByte , defaultFunction ) ; MST[NonVoidMethodCallMutator]MSP[] }
if ( array == null || array . length == 0 ) { return map ; } final Object obj = array [ 0 ] ; MST[InlineConstantMutator]MSP[] if ( obj instanceof Map . Entry ) { for ( final Object element : array ) {
return applyDefaultFunction ( map , key , MapUtils :: getFloat , defaultFunction , 0f ) . floatValue () ; MST[rv.CRCR5Mutator]MSP[] } public static < K > Integer getInteger ( final Map < ? super K , ? > map , final K key ) {
if ( sub == null || sub . length < 2 ) { throw new IllegalArgumentException ( lr_4 + i ) ; MST[rv.UOI3Mutator]MSP[] } map . put ( ( K ) sub [ 0 ] , ( V ) sub [ 1 ] ) ; } } else {
out . print ( childValue ) ; } else if ( lineage . size () - 1 == lineageIndex ) { MST[NegateConditionalsMutator]MSP[] out . print ( lr_9 ) ; } else {
public static < K > short getShortValue ( final Map < ? super K , ? > map , final K key ) { return applyDefaultValue ( map , key , MapUtils :: getShort , 0 ) . shortValue () ; MST[rv.CRCR3Mutator]MSP[] }
if ( sub == null || sub . length < 2 ) { throw new IllegalArgumentException ( lr_4 + i ) ; } map . put ( ( K ) sub [ 0 ] , ( V ) sub [ 1 ] ) ; MST[InlineConstantMutator]MSP[] } } else {
out . print ( lr_10 + ( lineage . size () - 1 - lineageIndex - 1 ) + lr_11 ) ; } if ( debug && childValue != null ) { out . print ( ' ' ) ; MST[rv.CRCR5Mutator]MSP[]
for ( int i = 0 ; i < array . length - 1 ; ) { map . put ( ( K ) array [ i ++ ] , ( V ) array [ i ++ ] ) ; } } return map ; MST[NullReturnValsMutator]MSP[] }
out . print ( lr_10 + ( lineage . size () - 1 - lineageIndex - 1 ) + lr_11 ) ; MST[rv.AOR2Mutator]MSP[] } if ( debug && childValue != null ) { out . print ( ' ' ) ;
out . print ( lr_10 + ( lineage . size () - 1 - lineageIndex - 1 ) + lr_11 ) ; } if ( debug && childValue != null ) { MST[rv.ROR4Mutator]MSP[] out . print ( ' ' ) ;
public static int size ( final Map < ? , ? > map ) { return map == null ? 0 : map . size () ; MST[NonVoidMethodCallMutator]MSP[] }
public static < K > short getShortValue ( final Map < ? super K , ? > map , final K key , final short defaultValue ) { return applyDefaultValue ( map , key , MapUtils :: getShort , defaultValue ) . shortValue () ; MST[NonVoidMethodCallMutator]MSP[] }
return n . intValue () != 0 ? Boolean . TRUE : Boolean . FALSE ; } } } return null ; MST[BooleanFalseReturnValsMutator]MSP[] }
final Number answer = getNumber ( map , key ) ; if ( answer == null ) { return null ; } if ( answer instanceof Double ) { MST[rv.ROR1Mutator]MSP[] return ( Double ) answer ; } return Double . valueOf ( answer . doubleValue () ) ; }
out . print ( lr_10 + ( lineage . size () - 1 - lineageIndex - 1 ) + lr_11 ) ; } if ( debug && childValue != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] out . print ( ' ' ) ;
public static < K > boolean getBooleanValue ( final Map < ? super K , ? > map , final K key , final boolean defaultValue ) { return applyDefaultValue ( map , key , MapUtils :: getBoolean , defaultValue ) . booleanValue () ; MST[BooleanFalseReturnValsMutator]MSP[] }
out . println ( debug ? lr_12 + map . getClass () . getName () : lr_13 ) ; MST[rv.ROR3Mutator]MSP[] }
public static < K > float getFloatValue ( final Map < ? super K , ? > map , final K key ) { return applyDefaultValue ( map , key , MapUtils :: getFloat , 0f ) . floatValue () ; MST[InlineConstantMutator]MSP[] }
out . put ( entry . getValue () , entry . getKey () ) ; } return out ; } public static boolean isEmpty ( final Map < ? , ? > map ) { return map == null || map . isEmpty () ; MST[InlineConstantMutator]MSP[] }
for ( int i = 0 ; i < array . length - 1 ; ) { map . put ( ( K ) array [ i ++ ] , ( V ) array [ i ++ ] ) ; MST[rv.UOI2Mutator]MSP[] } } return map ; }
out . print ( lr_10 + ( lineage . size () - 1 - lineageIndex - 1 ) + lr_11 ) ; MST[ConstructorCallMutator]MSP[] } if ( debug && childValue != null ) { out . print ( ' ' ) ;
final Number answer = getNumber ( map , key ) ; if ( answer == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return null ; } if ( answer instanceof Long ) { return ( Long ) answer ; } return Long . valueOf ( answer . longValue () ) ; }
public static < K > Number getNumber ( final Map < ? super K , ? > map , final K key , final Number defaultValue ) { return applyDefaultValue ( map , key , MapUtils :: getNumber , defaultValue ) ; MST[ReturnValsMutator]MSP[] }
return map == null ? Collections . <K , V > emptyMap () : map ; MST[NonVoidMethodCallMutator]MSP[] } public static < K , V > IterableMap < K , V > fixedSizeMap ( final Map < K , V > map ) { return FixedSizeMap . fixedSizeMap ( map ) ;
return n . intValue () != 0 ? Boolean . TRUE : Boolean . FALSE ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] } } } return null ; }
if ( array == null || array . length == 0 ) { MST[NegateConditionalsMutator]MSP[] return map ; } final Object obj = array [ 0 ] ; if ( obj instanceof Map . Entry ) { for ( final Object element : array ) {
final Object key = entry . getKey () ; MST[NonVoidMethodCallMutator]MSP[] final Object value = entry . getValue () ; answer . put ( key , value ) ; } } return answer ; }
for ( int i = 0 ; i < array . length - 1 ; ) { MST[rv.AOR1Mutator]MSP[] map . put ( ( K ) array [ i ++ ] , ( V ) array [ i ++ ] ) ; } } return map ; }
if ( map != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] final Object answer = map . get ( key ) ; if ( answer != null && answer instanceof Map ) { return ( Map < ? , ? > ) answer ; } } return null ; }
public static < K , V > V getObject ( final Map < ? super K , V > map , final K key ) { if ( map != null ) { return map . get ( key ) ; MST[ArgumentPropagationMutator]MSP[] } return null ; }
return n . intValue () != 0 ? Boolean . TRUE : Boolean . FALSE ; MST[rv.ROR3Mutator]MSP[] } } } return null ; }
final Number answer = getNumber ( map , key ) ; if ( answer == null ) { return null ; } if ( answer instanceof Short ) { MST[rv.ROR5Mutator]MSP[] return ( Short ) answer ; } return Short . valueOf ( answer . shortValue () ) ; }
return n . intValue () != 0 ? Boolean . TRUE : Boolean . FALSE ; } } } return null ; MST[ReturnValsMutator]MSP[] }
if ( array == null || array . length == 0 ) { return map ; } final Object obj = array [ 0 ] ; MST[rv.CRCR3Mutator]MSP[] if ( obj instanceof Map . Entry ) { for ( final Object element : array ) {
if ( sub == null || sub . length < 2 ) { MST[rv.CRCR1Mutator]MSP[] throw new IllegalArgumentException ( lr_4 + i ) ; } map . put ( ( K ) sub [ 0 ] , ( V ) sub [ 1 ] ) ; } } else {
if ( sub == null || sub . length < 2 ) { MST[rv.CRCR5Mutator]MSP[] throw new IllegalArgumentException ( lr_4 + i ) ; } map . put ( ( K ) sub [ 0 ] , ( V ) sub [ 1 ] ) ; } } else {
public static < K > Boolean getBoolean ( final Map < ? super K , ? > map , final K key , final Boolean defaultValue ) { return applyDefaultValue ( map , key , MapUtils :: getBoolean , defaultValue ) ; MST[NonVoidMethodCallMutator]MSP[] }
return applyDefaultFunction ( map , key , MapUtils :: getFloat , defaultFunction , 0f ) . floatValue () ; MST[PrimitiveReturnsMutator]MSP[] } public static < K > Integer getInteger ( final Map < ? super K , ? > map , final K key ) {
return applyDefaultFunction ( map , key , MapUtils :: getByte , defaultFunction , ( byte ) 0 ) . byteValue () ; MST[NonVoidMethodCallMutator]MSP[] } public static < K > Double getDouble ( final Map < ? super K , ? > map , final K key ) {
final Function < K , Number > defaultFunction ) { return applyDefaultFunction ( map , key , MapUtils :: getNumber , defaultFunction ) ; MST[ArgumentPropagationMutator]MSP[] }
Objects . requireNonNull ( map , lr_1 ) ; MST[ArgumentPropagationMutator]MSP[] return map instanceof IterableMap ? ( IterableMap < K , V > ) map : new AbstractMapDecorator < K , V > ( map ) { } ; }
if ( sub == null || sub . length < 2 ) { throw new IllegalArgumentException ( lr_4 + i ) ; MST[rv.UOI4Mutator]MSP[] } map . put ( ( K ) sub [ 0 ] , ( V ) sub [ 1 ] ) ; } } else {
printIndent ( out , lineage . size () ) ; out . print ( childKey ) ; out . print ( lr_6 ) ; final int lineageIndex = IterableUtils . indexOf ( lineage , PredicateUtils . equalPredicate ( childValue ) ) ; MST[NonVoidMethodCallMutator]MSP[] if ( lineageIndex == - 1 ) {
public static < K > boolean getBooleanValue ( final Map < ? super K , ? > map , final K key , final boolean defaultValue ) { return applyDefaultValue ( map , key , MapUtils :: getBoolean , defaultValue ) . booleanValue () ; MST[rv.UOI3Mutator]MSP[] }
printIndent ( out , lineage . size () ) ; out . print ( childKey ) ; out . print ( lr_6 ) ; final int lineageIndex = IterableUtils . indexOf ( lineage , PredicateUtils . equalPredicate ( childValue ) ) ; if ( lineageIndex == - 1 ) { MST[rv.CRCR4Mutator]MSP[]
public static < K > byte getByteValue ( final Map < ? super K , ? > map , final K key , final byte defaultValue ) { return applyDefaultValue ( map , key , MapUtils :: getByte , defaultValue ) . byteValue () ; MST[ReturnValsMutator]MSP[] }
return applyDefaultFunction ( map , key , MapUtils :: getLong , defaultFunction , 0L ) . byteValue () ; MST[NonVoidMethodCallMutator]MSP[] } public static < K > long getLongValue ( final Map < ? super K , ? > map , final K key , final long defaultValue ) {
out . print ( lr_10 + ( lineage . size () - 1 - lineageIndex - 1 ) + lr_11 ) ; MST[NonVoidMethodCallMutator]MSP[] } if ( debug && childValue != null ) { out . print ( ' ' ) ;
return applyDefaultFunction ( map , key , MapUtils :: getString , defaultFunction ) ; MST[NonVoidMethodCallMutator]MSP[] } public static < K > String getString ( final Map < ? super K , ? > map , final K key , final String defaultValue ) {
for ( int i = 0 ; i < indent ; i ++ ) { MST[rv.CRCR5Mutator]MSP[] out . print ( INDENT_STRING ) ; } } @SuppressWarnings ( lr_3 )
out . put ( entry . getValue () , entry . getKey () ) ; } return out ; } public static boolean isEmpty ( final Map < ? , ? > map ) { return map == null || map . isEmpty () ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] }
if ( sub == null || sub . length < 2 ) { MST[rv.ROR5Mutator]MSP[] throw new IllegalArgumentException ( lr_4 + i ) ; } map . put ( ( K ) sub [ 0 ] , ( V ) sub [ 1 ] ) ; } } else {
public static < K > float getFloatValue ( final Map < ? super K , ? > map , final K key , final float defaultValue ) { return applyDefaultValue ( map , key , MapUtils :: getFloat , defaultValue ) . floatValue () ; MST[NonVoidMethodCallMutator]MSP[] }
public static < K , V > V getObject ( final Map < ? super K , V > map , final K key ) { if ( map != null ) { MST[NegateConditionalsMutator]MSP[] return map . get ( key ) ; } return null ; }
return applyDefaultFunction ( map , key , MapUtils :: getDouble , defaultFunction , 0d ) . doubleValue () ; MST[ReturnValsMutator]MSP[] } public static < K > Float getFloat ( final Map < ? super K , ? > map , final K key ) {
out . print ( lr_10 + ( lineage . size () - 1 - lineageIndex - 1 ) + lr_11 ) ; } if ( debug && childValue != null ) { MST[rv.ROR5Mutator]MSP[] out . print ( ' ' ) ;
public static boolean isNotEmpty ( final Map < ? , ? > map ) { return ! MapUtils . isEmpty ( map ) ; MST[rv.CRCR1Mutator]MSP[] } public static < K , V > IterableMap < K , V > iterableMap ( final Map < K , V > map ) {
final Number answer = getNumber ( map , key ) ; if ( answer == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return null ; } if ( answer instanceof Short ) { return ( Short ) answer ; } return Short . valueOf ( answer . shortValue () ) ; }
public static < K > Float getFloat ( final Map < ? super K , ? > map , final K key , final Float defaultValue ) { return applyDefaultValue ( map , key , MapUtils :: getFloat , defaultValue ) ; MST[ArgumentPropagationMutator]MSP[] }
final Number answer = getNumber ( map , key ) ; if ( answer == null ) { MST[rv.ROR5Mutator]MSP[] return null ; } if ( answer instanceof Double ) { return ( Double ) answer ; } return Double . valueOf ( answer . doubleValue () ) ; }
final Object key = entry . getKey () ; final Object value = entry . getValue () ; answer . put ( key , value ) ; MST[ArgumentPropagationMutator]MSP[] } } return answer ; }
public static < K , V > IterableSortedMap < K , V > iterableSortedMap ( final SortedMap < K , V > sortedMap ) { Objects . requireNonNull ( sortedMap , lr_2 ) ; return sortedMap instanceof IterableSortedMap ? ( IterableSortedMap < K , V > ) sortedMap MST[NullReturnValsMutator]MSP[]
public static < K > double getDoubleValue ( final Map < ? super K , ? > map , final K key ) { return applyDefaultValue ( map , key , MapUtils :: getDouble , 0d ) . doubleValue () ; MST[NonVoidMethodCallMutator]MSP[] }
final Iterator < ? extends E > iter = elements . iterator () ; while ( iter . hasNext () ) { final E temp = iter . next () ; map . put ( keyTransformer . transform ( temp ) , valueTransformer . transform ( temp ) ) ; MST[ArgumentPropagationMutator]MSP[]
public static < K > double getDoubleValue ( final Map < ? super K , ? > map , final K key , final double defaultValue ) { return applyDefaultValue ( map , key , MapUtils :: getDouble , defaultValue ) . doubleValue () ; MST[rv.ABSMutator]MSP[] }
final Number answer = getNumber ( map , key ) ; if ( answer == null ) { return null ; } if ( answer instanceof Short ) { return ( Short ) answer ; MST[ReturnValsMutator]MSP[] } return Short . valueOf ( answer . shortValue () ) ; }
public static boolean isNotEmpty ( final Map < ? , ? > map ) { return ! MapUtils . isEmpty ( map ) ; MST[ReturnValsMutator]MSP[] } public static < K , V > IterableMap < K , V > iterableMap ( final Map < K , V > map ) {
return applyDefaultFunction ( map , key , MapUtils :: getFloat , defaultFunction , 0f ) . floatValue () ; MST[ArgumentPropagationMutator]MSP[] } public static < K > Integer getInteger ( final Map < ? super K , ? > map , final K key ) {
public static < K > long getLongValue ( final Map < ? super K , ? > map , final K key ) { return applyDefaultValue ( map , key , MapUtils :: getLong , 0L ) . longValue () ; MST[rv.CRCR3Mutator]MSP[] }
} else if ( obj instanceof Object [] ) { for ( int i = 0 ; i < array . length ; i ++ ) { MST[rv.ROR2Mutator]MSP[] final Object [] sub = ( Object [] ) array [ i ] ;
for ( int i = 0 ; i < array . length - 1 ; ) { map . put ( ( K ) array [ i ++ ] , ( V ) array [ i ++ ] ) ; MST[experimental.RemoveIncrementsMutator]MSP[] } } return map ; }
public static < K > float getFloatValue ( final Map < ? super K , ? > map , final K key ) { return applyDefaultValue ( map , key , MapUtils :: getFloat , 0f ) . floatValue () ; MST[NonVoidMethodCallMutator]MSP[] }
if ( map == null ) { if ( label != null ) { out . print ( label ) ; out . print ( lr_6 ) ; } out . println ( lr_7 ) ; MST[VoidMethodCallMutator]MSP[] return; } if ( label != null ) {
for ( int i = 0 ; i < indent ; i ++ ) { MST[rv.ABSMutator]MSP[] out . print ( INDENT_STRING ) ; } } @SuppressWarnings ( lr_3 )
final Number answer = getNumber ( map , key ) ; if ( answer == null ) { return null ; } if ( answer instanceof Byte ) { MST[rv.ROR1Mutator]MSP[] return ( Byte ) answer ; } return Byte . valueOf ( answer . byteValue () ) ; }
final Number answer = getNumber ( map , key ) ; if ( answer == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return null ; } if ( answer instanceof Integer ) { return ( Integer ) answer ; } return Integer . valueOf ( answer . intValue () ) ; }
return applyDefaultFunction ( map , key , MapUtils :: getByte , defaultFunction , ( byte ) 0 ) . byteValue () ; MST[rv.CRCR6Mutator]MSP[] } public static < K > Double getDouble ( final Map < ? super K , ? > map , final K key ) {
public static < K , V > V getObject ( final Map < ? super K , V > map , final K key ) { if ( map != null ) { MST[rv.ROR5Mutator]MSP[] return map . get ( key ) ; } return null ; }
printIndent ( out , lineage . size () ) ; out . print ( childKey ) ; out . print ( lr_6 ) ; final int lineageIndex = IterableUtils . indexOf ( lineage , PredicateUtils . equalPredicate ( childValue ) ) ; if ( lineageIndex == - 1 ) { MST[rv.ROR1Mutator]MSP[]
out . print ( lr_10 + ( lineage . size () - 1 - lineageIndex - 1 ) + lr_11 ) ; MST[rv.AOR2Mutator]MSP[] } if ( debug && childValue != null ) { out . print ( ' ' ) ;
final Number answer = getNumber ( map , key ) ; if ( answer == null ) { return null ; } if ( answer instanceof Byte ) { return ( Byte ) answer ; } return Byte . valueOf ( answer . byteValue () ) ; MST[NonVoidMethodCallMutator]MSP[] }
for ( int i = 0 ; i < array . length - 1 ; ) { MST[rv.CRCR4Mutator]MSP[] map . put ( ( K ) array [ i ++ ] , ( V ) array [ i ++ ] ) ; } } return map ; }
return applyDefaultValue ( map , key , MapUtils :: getLong , defaultValue ) . longValue () ; MST[ReturnValsMutator]MSP[] } public static < K > Map < ? , ? > getMap ( final Map < ? super K , ? > map , final K key ) {
final Function < K , Number > defaultFunction ) { return applyDefaultFunction ( map , key , MapUtils :: getNumber , defaultFunction ) ; MST[ReturnValsMutator]MSP[] }
final Transformer < E , K > keyTransformer , final Transformer < E , V > valueTransformer ) { final Iterator < ? extends E > iter = elements . iterator () ; while ( iter . hasNext () ) { MST[NegateConditionalsMutator]MSP[] final E temp = iter . next () ;
public static < K > short getShortValue ( final Map < ? super K , ? > map , final K key , final short defaultValue ) { return applyDefaultValue ( map , key , MapUtils :: getShort , defaultValue ) . shortValue () ; MST[NonVoidMethodCallMutator]MSP[] }
final Number answer = getNumber ( map , key ) ; if ( answer == null ) { return null ; } if ( answer instanceof Short ) { return ( Short ) answer ; } return Short . valueOf ( answer . shortValue () ) ; MST[NonVoidMethodCallMutator]MSP[] }
final Number answer = getNumber ( map , key ) ; if ( answer == null ) { MST[NegateConditionalsMutator]MSP[] return null ; } if ( answer instanceof Double ) { return ( Double ) answer ; } return Double . valueOf ( answer . doubleValue () ) ; }
out . print ( lr_10 + ( lineage . size () - 1 - lineageIndex - 1 ) + lr_11 ) ; } if ( debug && childValue != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] out . print ( ' ' ) ;
verbosePrintInternal ( out , label , map , new ArrayDeque < Map < ? , ? > > () , true ) ; MST[VoidMethodCallMutator]MSP[] } public static < K , V > Map < K , V > emptyIfNull ( final Map < K , V > map ) {
if ( sub == null || sub . length < 2 ) { throw new IllegalArgumentException ( lr_4 + i ) ; } map . put ( ( K ) sub [ 0 ] , ( V ) sub [ 1 ] ) ; MST[rv.CRCR6Mutator]MSP[] } } else {
public static < K > double getDoubleValue ( final Map < ? super K , ? > map , final K key , final double defaultValue ) { return applyDefaultValue ( map , key , MapUtils :: getDouble , defaultValue ) . doubleValue () ; MST[rv.UOI2Mutator]MSP[] }
if ( answer instanceof Boolean ) { return ( Boolean ) answer ; } if ( answer instanceof String ) { MST[rv.ROR5Mutator]MSP[] return Boolean . valueOf ( ( String ) answer ) ; } if ( answer instanceof Number ) { final Number n = ( Number ) answer ;
final Number answer = getNumber ( map , key ) ; if ( answer == null ) { return null ; } if ( answer instanceof Integer ) { return ( Integer ) answer ; } return Integer . valueOf ( answer . intValue () ) ; MST[EmptyObjectReturnValsMutator]MSP[] }
final Number answer = getNumber ( map , key ) ; if ( answer == null ) { return null ; } if ( answer instanceof Float ) { MST[rv.ROR3Mutator]MSP[] return ( Float ) answer ; } return Float . valueOf ( answer . floatValue () ) ; }
public static < K > Long getLong ( final Map < ? super K , ? > map , final K key , final Long defaultValue ) { return applyDefaultValue ( map , key , MapUtils :: getLong , defaultValue ) ; MST[EmptyObjectReturnValsMutator]MSP[] }
public static < K > byte getByteValue ( final Map < ? super K , ? > map , final K key ) { return applyDefaultValue ( map , key , MapUtils :: getByte , 0 ) . byteValue () ; MST[ReturnValsMutator]MSP[] }
public static < K > double getDoubleValue ( final Map < ? super K , ? > map , final K key , final double defaultValue ) { return applyDefaultValue ( map , key , MapUtils :: getDouble , defaultValue ) . doubleValue () ; MST[NonVoidMethodCallMutator]MSP[] }
public static < K > Float getFloat ( final Map < ? super K , ? > map , final K key , final Function < K , Float > defaultFunction ) { return applyDefaultFunction ( map , key , MapUtils :: getFloat , defaultFunction ) ; MST[EmptyObjectReturnValsMutator]MSP[] }
out . print ( lr_10 + ( lineage . size () - 1 - lineageIndex - 1 ) + lr_11 ) ; MST[rv.CRCR6Mutator]MSP[] } if ( debug && childValue != null ) { out . print ( ' ' ) ;
out . print ( lr_10 + ( lineage . size () - 1 - lineageIndex - 1 ) + lr_11 ) ; } if ( debug && childValue != null ) { out . print ( ' ' ) ; MST[rv.CRCR1Mutator]MSP[]
public static boolean isNotEmpty ( final Map < ? , ? > map ) { return ! MapUtils . isEmpty ( map ) ; MST[rv.ROR4Mutator]MSP[] } public static < K , V > IterableMap < K , V > iterableMap ( final Map < K , V > map ) {
out . put ( entry . getValue () , entry . getKey () ) ; } return out ; } public static boolean isEmpty ( final Map < ? , ? > map ) { return map == null || map . isEmpty () ; MST[rv.ROR5Mutator]MSP[] }
if ( answer instanceof Boolean ) { return ( Boolean ) answer ; } if ( answer instanceof String ) { return Boolean . valueOf ( ( String ) answer ) ; } if ( answer instanceof Number ) { MST[rv.ROR4Mutator]MSP[] final Number n = ( Number ) answer ;
return applyDefaultFunction ( map , key , MapUtils :: getShort , defaultFunction , ( short ) 0 ) . shortValue () ; MST[NonVoidMethodCallMutator]MSP[] }
if ( answer instanceof Boolean ) { return ( Boolean ) answer ; } if ( answer instanceof String ) { return Boolean . valueOf ( ( String ) answer ) ; } if ( answer instanceof Number ) { MST[rv.ROR1Mutator]MSP[] final Number n = ( Number ) answer ;
out . print ( childValue ) ; } else if ( lineage . size () - 1 == lineageIndex ) { MST[rv.UOI3Mutator]MSP[] out . print ( lr_9 ) ; } else {
return applyDefaultFunction ( map , key , MapUtils :: getInteger , defaultFunction , 0 ) . byteValue () ; MST[NonVoidMethodCallMutator]MSP[] } public static < K > int getIntValue ( final Map < ? super K , ? > map , final K key , final int defaultValue ) {
if ( answer instanceof Boolean ) { return ( Boolean ) answer ; } if ( answer instanceof String ) { return Boolean . valueOf ( ( String ) answer ) ; MST[NonVoidMethodCallMutator]MSP[] } if ( answer instanceof Number ) { final Number n = ( Number ) answer ;
final Object answer = map . get ( key ) ; if ( answer != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] if ( answer instanceof Number ) { return ( Number ) answer ; } if ( answer instanceof String ) { try { final String text = ( String ) answer ;
if ( array == null || array . length == 0 ) { MST[rv.ROR2Mutator]MSP[] return map ; } final Object obj = array [ 0 ] ; if ( obj instanceof Map . Entry ) { for ( final Object element : array ) {
Objects . requireNonNull ( map , lr_1 ) ; return map instanceof IterableMap ? ( IterableMap < K , V > ) map : new AbstractMapDecorator < K , V > ( map ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] } ; }
out . print ( lr_10 + ( lineage . size () - 1 - lineageIndex - 1 ) + lr_11 ) ; } if ( debug && childValue != null ) { out . print ( ' ' ) ; MST[rv.CRCR6Mutator]MSP[]
out . put ( entry . getValue () , entry . getKey () ) ; } return out ; } public static boolean isEmpty ( final Map < ? , ? > map ) { return map == null || map . isEmpty () ; MST[rv.CRCR5Mutator]MSP[] }
public static < K > void safeAddToMap ( final Map < ? super K , Object > map , final K key , final Object value ) throws NullPointerException { map . put ( key , value == null ? lr_5 : value ) ; MST[NonVoidMethodCallMutator]MSP[] }
public static < K > Boolean getBoolean ( final Map < ? super K , ? > map , final K key , final Function < K , Boolean > defaultFunction ) { return applyDefaultFunction ( map , key , MapUtils :: getBoolean , defaultFunction ) ; MST[ArgumentPropagationMutator]MSP[] }
verbosePrintInternal ( out , label , map , new ArrayDeque < Map < ? , ? > > () , true ) ; MST[rv.CRCR5Mutator]MSP[] } public static < K , V > Map < K , V > emptyIfNull ( final Map < K , V > map ) {
return applyDefaultFunction ( map , key , MapUtils :: getInteger , defaultFunction , 0 ) . byteValue () ; MST[InlineConstantMutator]MSP[] } public static < K > int getIntValue ( final Map < ? super K , ? > map , final K key , final int defaultValue ) {
public static < K > float getFloatValue ( final Map < ? super K , ? > map , final K key , final float defaultValue ) { return applyDefaultValue ( map , key , MapUtils :: getFloat , defaultValue ) . floatValue () ; MST[rv.UOI1Mutator]MSP[] }
out . put ( entry . getValue () , entry . getKey () ) ; } return out ; } public static boolean isEmpty ( final Map < ? , ? > map ) { return map == null || map . isEmpty () ; MST[rv.CRCR3Mutator]MSP[] }
public static < K > long getLongValue ( final Map < ? super K , ? > map , final K key ) { return applyDefaultValue ( map , key , MapUtils :: getLong , 0L ) . longValue () ; MST[InlineConstantMutator]MSP[] }
for ( int i = 0 ; i < array . length - 1 ; ) { MST[rv.CRCR6Mutator]MSP[] map . put ( ( K ) array [ i ++ ] , ( V ) array [ i ++ ] ) ; } } return map ; }
final Object answer = map . get ( key ) ; if ( answer != null ) { if ( answer instanceof Number ) { MST[rv.ROR5Mutator]MSP[] return ( Number ) answer ; } if ( answer instanceof String ) { try { final String text = ( String ) answer ;
final Number answer = getNumber ( map , key ) ; if ( answer == null ) { return null ; } if ( answer instanceof Double ) { return ( Double ) answer ; } return Double . valueOf ( answer . doubleValue () ) ; MST[ReturnValsMutator]MSP[] }
final Number answer = getNumber ( map , key ) ; if ( answer == null ) { return null ; } if ( answer instanceof Long ) { MST[rv.ROR1Mutator]MSP[] return ( Long ) answer ; } return Long . valueOf ( answer . longValue () ) ; }
public static < K > Float getFloat ( final Map < ? super K , ? > map , final K key , final Float defaultValue ) { return applyDefaultValue ( map , key , MapUtils :: getFloat , defaultValue ) ; MST[ReturnValsMutator]MSP[] }
public static < K > float getFloatValue ( final Map < ? super K , ? > map , final K key , final float defaultValue ) { return applyDefaultValue ( map , key , MapUtils :: getFloat , defaultValue ) . floatValue () ; MST[NonVoidMethodCallMutator]MSP[] }
return applyDefaultFunction ( map , key , MapUtils :: getLong , defaultFunction , 0L ) . byteValue () ; MST[ArgumentPropagationMutator]MSP[] } public static < K > long getLongValue ( final Map < ? super K , ? > map , final K key , final long defaultValue ) {
if ( answer instanceof Boolean ) { return ( Boolean ) answer ; } if ( answer instanceof String ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return Boolean . valueOf ( ( String ) answer ) ; } if ( answer instanceof Number ) { final Number n = ( Number ) answer ;
final Number answer = getNumber ( map , key ) ; if ( answer == null ) { return null ; } if ( answer instanceof Float ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return ( Float ) answer ; } return Float . valueOf ( answer . floatValue () ) ; }
return applyDefaultFunction ( map , key , MapUtils :: getBoolean , defaultFunction , false ) . booleanValue () ; MST[NonVoidMethodCallMutator]MSP[] } public static < K > Byte getByte ( final Map < ? super K , ? > map , final K key ) {
for ( final Object element : array ) { final KeyValue < K , V > keyval = ( KeyValue < K , V > ) element ; map . put ( keyval . getKey () , keyval . getValue () ) ; MST[NonVoidMethodCallMutator]MSP[] }
final Map < V , K > out = new HashMap <> ( map . size () ) ; MST[NonVoidMethodCallMutator]MSP[] for ( final Entry < K , V > entry : map . entrySet () ) {
final Enumeration < String > enumeration = resourceBundle . getKeys () ; final Map < String , Object > map = new HashMap <> () ; while ( enumeration . hasMoreElements () ) { MST[NegateConditionalsMutator]MSP[] final String key = enumeration . nextElement () ;
for ( int i = 0 ; i < array . length - 1 ; ) { MST[rv.ROR5Mutator]MSP[] map . put ( ( K ) array [ i ++ ] , ( V ) array [ i ++ ] ) ; } } return map ; }
Objects . requireNonNull ( map , lr_1 ) ; return map instanceof IterableMap ? ( IterableMap < K , V > ) map : new AbstractMapDecorator < K , V > ( map ) { MST[rv.ROR3Mutator]MSP[] } ; }
final Object answer = map . get ( key ) ; if ( answer != null ) { if ( answer instanceof Number ) { return ( Number ) answer ; MST[ReturnValsMutator]MSP[] } if ( answer instanceof String ) { try { final String text = ( String ) answer ;
public static < K > short getShortValue ( final Map < ? super K , ? > map , final K key ) { return applyDefaultValue ( map , key , MapUtils :: getShort , 0 ) . shortValue () ; MST[ArgumentPropagationMutator]MSP[] }
for ( int i = 0 ; i < indent ; i ++ ) { MST[rv.ROR3Mutator]MSP[] out . print ( INDENT_STRING ) ; } } @SuppressWarnings ( lr_3 )
public static < K , V > IterableSortedMap < K , V > iterableSortedMap ( final SortedMap < K , V > sortedMap ) { Objects . requireNonNull ( sortedMap , lr_2 ) ; return sortedMap instanceof IterableSortedMap ? ( IterableSortedMap < K , V > ) sortedMap MST[ConstructorCallMutator]MSP[]
return applyDefaultFunction ( map , key , MapUtils :: getByte , defaultFunction , ( byte ) 0 ) . byteValue () ; MST[InlineConstantMutator]MSP[] } public static < K > Double getDouble ( final Map < ? super K , ? > map , final K key ) {
out . println ( debug ? lr_12 + map . getClass () . getName () : lr_13 ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] }
R value = map != null && getFunction != null ? getFunction . apply ( map , key ) : null ; MST[ArgumentPropagationMutator]MSP[] if ( value == null ) { value = defaultFunction != null ? defaultFunction . apply ( key ) : null ; }
if ( map != null ) { final Object answer = map . get ( key ) ; if ( answer != null && answer instanceof Map ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return ( Map < ? , ? > ) answer ; } } return null ; }
final Map . Entry < K , V > entry = ( Map . Entry < K , V > ) element ; map . put ( entry . getKey () , entry . getValue () ) ; } } else if ( obj instanceof KeyValue ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
return applyDefaultFunction ( map , key , MapUtils :: getBoolean , defaultFunction , false ) . booleanValue () ; MST[rv.CRCR1Mutator]MSP[] } public static < K > Byte getByte ( final Map < ? super K , ? > map , final K key ) {
public static < K > Integer getInteger ( final Map < ? super K , ? > map , final K key , final Integer defaultValue ) { return applyDefaultValue ( map , key , MapUtils :: getInteger , defaultValue ) ; MST[NonVoidMethodCallMutator]MSP[] }
return applyDefaultFunction ( map , key , MapUtils :: getBoolean , defaultFunction , false ) . booleanValue () ; MST[rv.CRCR6Mutator]MSP[] } public static < K > Byte getByte ( final Map < ? super K , ? > map , final K key ) {
return applyDefaultValue ( map , key , MapUtils :: getMap , defaultValue ) ; } public static < K > Number getNumber ( final Map < ? super K , ? > map , final K key ) { if ( map != null ) { MST[rv.ROR5Mutator]MSP[]
final Number answer = getNumber ( map , key ) ; if ( answer == null ) { return null ; } if ( answer instanceof Long ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return ( Long ) answer ; } return Long . valueOf ( answer . longValue () ) ; }
public static < K , V > Map < K , V > putAll ( final Map < K , V > map , final Object [] array ) { Objects . requireNonNull ( map , lr_1 ) ; MST[NonVoidMethodCallMutator]MSP[]
for ( final Object element : array ) { MST[rv.UOI4Mutator]MSP[] final KeyValue < K , V > keyval = ( KeyValue < K , V > ) element ; map . put ( keyval . getKey () , keyval . getValue () ) ; }
out . println ( childValue . getClass () . getName () ) ; MST[NonVoidMethodCallMutator]MSP[] } else { out . println () ; } } } lineage . removeLast () ; printIndent ( out , lineage . size () ) ;
final Number answer = getNumber ( map , key ) ; if ( answer == null ) { return null ; } if ( answer instanceof Short ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return ( Short ) answer ; } return Short . valueOf ( answer . shortValue () ) ; }
public static < K > Short getShort ( final Map < ? super K , ? > map , final K key , final Short defaultValue ) { return applyDefaultValue ( map , key , MapUtils :: getShort , defaultValue ) ; MST[NonVoidMethodCallMutator]MSP[] }
final Properties answer = new Properties () ; if ( map != null ) { MST[NegateConditionalsMutator]MSP[] for ( final Entry < K , V > entry2 : map . entrySet () ) { final Map . Entry < ? , ? > entry = entry2 ;
out . print ( lr_10 + ( lineage . size () - 1 - lineageIndex - 1 ) + lr_11 ) ; MST[rv.AOR2Mutator]MSP[] } if ( debug && childValue != null ) { out . print ( ' ' ) ;
if ( array == null || array . length == 0 ) { return map ; } final Object obj = array [ 0 ] ; if ( obj instanceof Map . Entry ) { for ( final Object element : array ) { MST[rv.UOI4Mutator]MSP[]
if ( sub == null || sub . length < 2 ) { MST[NegateConditionalsMutator]MSP[] throw new IllegalArgumentException ( lr_4 + i ) ; } map . put ( ( K ) sub [ 0 ] , ( V ) sub [ 1 ] ) ; } } else {
if ( array == null || array . length == 0 ) { return map ; } final Object obj = array [ 0 ] ; if ( obj instanceof Map . Entry ) { MST[rv.ROR2Mutator]MSP[] for ( final Object element : array ) {
if ( answer instanceof Boolean ) { MST[rv.ROR2Mutator]MSP[] return ( Boolean ) answer ; } if ( answer instanceof String ) { return Boolean . valueOf ( ( String ) answer ) ; } if ( answer instanceof Number ) { final Number n = ( Number ) answer ;
return applyDefaultFunction ( map , key , MapUtils :: getFloat , defaultFunction , 0f ) . floatValue () ; MST[rv.CRCR1Mutator]MSP[] } public static < K > Integer getInteger ( final Map < ? super K , ? > map , final K key ) {
final Iterator < ? extends E > iter = elements . iterator () ; while ( iter . hasNext () ) { MST[rv.ROR3Mutator]MSP[] final E temp = iter . next () ; map . put ( keyTransformer . transform ( temp ) , valueTransformer . transform ( temp ) ) ;
final Number answer = getNumber ( map , key ) ; if ( answer == null ) { return null ; MST[ReturnValsMutator]MSP[] } if ( answer instanceof Float ) { return ( Float ) answer ; } return Float . valueOf ( answer . floatValue () ) ; }
public static boolean isNotEmpty ( final Map < ? , ? > map ) { return ! MapUtils . isEmpty ( map ) ; MST[rv.CRCR4Mutator]MSP[] } public static < K , V > IterableMap < K , V > iterableMap ( final Map < K , V > map ) {
for ( final Object element : array ) { MST[rv.UOI3Mutator]MSP[] final KeyValue < K , V > keyval = ( KeyValue < K , V > ) element ; map . put ( keyval . getKey () , keyval . getValue () ) ; }
return applyDefaultValue ( map , key , MapUtils :: getInteger , defaultValue ) . intValue () ; MST[PrimitiveReturnsMutator]MSP[] } public static < K > Long getLong ( final Map < ? super K , ? > map , final K key ) {
final Enumeration < String > enumeration = resourceBundle . getKeys () ; final Map < String , Object > map = new HashMap <> () ; while ( enumeration . hasMoreElements () ) { MST[rv.ROR3Mutator]MSP[] final String key = enumeration . nextElement () ;
out . put ( entry . getValue () , entry . getKey () ) ; } return out ; } public static boolean isEmpty ( final Map < ? , ? > map ) { return map == null || map . isEmpty () ; MST[InlineConstantMutator]MSP[] }
for ( int i = 0 ; i < array . length - 1 ; ) { MST[NegateConditionalsMutator]MSP[] map . put ( ( K ) array [ i ++ ] , ( V ) array [ i ++ ] ) ; } } return map ; }
public static < K > int getIntValue ( final Map < ? super K , ? > map , final K key ) { return applyDefaultValue ( map , key , MapUtils :: getInteger , 0 ) . intValue () ; MST[NonVoidMethodCallMutator]MSP[] }
public static < K > Double getDouble ( final Map < ? super K , ? > map , final K key , final Double defaultValue ) { return applyDefaultValue ( map , key , MapUtils :: getDouble , defaultValue ) ; MST[ArgumentPropagationMutator]MSP[] }
public static < K > Float getFloat ( final Map < ? super K , ? > map , final K key , final Function < K , Float > defaultFunction ) { return applyDefaultFunction ( map , key , MapUtils :: getFloat , defaultFunction ) ; MST[ReturnValsMutator]MSP[] }
if ( map != null ) { final Object answer = map . get ( key ) ; if ( answer != null && answer instanceof Map ) { MST[rv.ROR5Mutator]MSP[] return ( Map < ? , ? > ) answer ; } } return null ; }
for ( int i = 0 ; i < array . length - 1 ; ) { map . put ( ( K ) array [ i ++ ] , ( V ) array [ i ++ ] ) ; MST[rv.UOI4Mutator]MSP[] } } return map ; }
out . print ( lr_10 + ( lineage . size () - 1 - lineageIndex - 1 ) + lr_11 ) ; MST[InlineConstantMutator]MSP[] } if ( debug && childValue != null ) { out . print ( ' ' ) ;
printIndent ( out , lineage . size () ) ; out . print ( childKey ) ; out . print ( lr_6 ) ; final int lineageIndex = IterableUtils . indexOf ( lineage , PredicateUtils . equalPredicate ( childValue ) ) ; if ( lineageIndex == - 1 ) { MST[rv.CRCR1Mutator]MSP[]
return applyDefaultValue ( map , key , MapUtils :: getLong , defaultValue ) . longValue () ; MST[NonVoidMethodCallMutator]MSP[] } public static < K > Map < ? , ? > getMap ( final Map < ? super K , ? > map , final K key ) {
final Number answer = getNumber ( map , key ) ; if ( answer == null ) { return null ; } if ( answer instanceof Short ) { MST[rv.ROR2Mutator]MSP[] return ( Short ) answer ; } return Short . valueOf ( answer . shortValue () ) ; }
final Number answer = getNumber ( map , key ) ; if ( answer == null ) { return null ; } if ( answer instanceof Float ) { return ( Float ) answer ; MST[EmptyObjectReturnValsMutator]MSP[] } return Float . valueOf ( answer . floatValue () ) ; }
out . print ( childValue ) ; } else if ( lineage . size () - 1 == lineageIndex ) { MST[rv.AOR3Mutator]MSP[] out . print ( lr_9 ) ; } else {
public static < K > Float getFloat ( final Map < ? super K , ? > map , final K key , final Float defaultValue ) { return applyDefaultValue ( map , key , MapUtils :: getFloat , defaultValue ) ; MST[EmptyObjectReturnValsMutator]MSP[] }
return applyDefaultFunction ( map , key , MapUtils :: getInteger , defaultFunction , 0 ) . byteValue () ; MST[PrimitiveReturnsMutator]MSP[] } public static < K > int getIntValue ( final Map < ? super K , ? > map , final K key , final int defaultValue ) {
return NumberFormat . getInstance () . parse ( text ) ; MST[NonVoidMethodCallMutator]MSP[] } catch ( final ParseException e ) { } } } } return null ; } public static < K > Number getNumber ( final Map < ? super K , ? > map , final K key ,
map . put ( keyTransformer . transform ( temp ) , valueTransformer . transform ( temp ) ) ; MST[ArgumentPropagationMutator]MSP[] } } public static < K , V > void populateMap ( final MultiMap < K , V > map , final Iterable < ? extends V > elements ,
return applyDefaultFunction ( map , key , MapUtils :: getShort , defaultFunction , ( short ) 0 ) . shortValue () ; MST[NonVoidMethodCallMutator]MSP[] }
public static boolean isNotEmpty ( final Map < ? , ? > map ) { return ! MapUtils . isEmpty ( map ) ; MST[NonVoidMethodCallMutator]MSP[] } public static < K , V > IterableMap < K , V > iterableMap ( final Map < K , V > map ) {
return map == null ? Collections . <K , V > emptyMap () : map ; MST[ReturnValsMutator]MSP[] } public static < K , V > IterableMap < K , V > fixedSizeMap ( final Map < K , V > map ) { return FixedSizeMap . fixedSizeMap ( map ) ;
return applyDefaultFunction ( map , key , MapUtils :: getByte , defaultFunction , ( byte ) 0 ) . byteValue () ; MST[rv.CRCR1Mutator]MSP[] } public static < K > Double getDouble ( final Map < ? super K , ? > map , final K key ) {
if ( sub == null || sub . length < 2 ) { MST[rv.ROR3Mutator]MSP[] throw new IllegalArgumentException ( lr_4 + i ) ; } map . put ( ( K ) sub [ 0 ] , ( V ) sub [ 1 ] ) ; } } else {
private static void verbosePrintInternal ( final PrintStream out , final Object label , final Map < ? , ? > map , final Deque < Map < ? , ? > > lineage , final boolean debug ) { printIndent ( out , lineage . size () ) ; MST[NonVoidMethodCallMutator]MSP[]
final Number answer = getNumber ( map , key ) ; if ( answer == null ) { return null ; } if ( answer instanceof Byte ) { return ( Byte ) answer ; } return Byte . valueOf ( answer . byteValue () ) ; MST[NullReturnValsMutator]MSP[] }
public static < K > Integer getInteger ( final Map < ? super K , ? > map , final K key , final Function < K , Integer > defaultFunction ) { return applyDefaultFunction ( map , key , MapUtils :: getInteger , defaultFunction ) ; MST[NonVoidMethodCallMutator]MSP[] }
return applyDefaultFunction ( map , key , MapUtils :: getInteger , defaultFunction , 0 ) . byteValue () ; MST[ArgumentPropagationMutator]MSP[] } public static < K > int getIntValue ( final Map < ? super K , ? > map , final K key , final int defaultValue ) {
public static < K > String getString ( final Map < ? super K , ? > map , final K key ) { if ( map != null ) { final Object answer = map . get ( key ) ; MST[NonVoidMethodCallMutator]MSP[] if ( answer != null ) {
public static < K > double getDoubleValue ( final Map < ? super K , ? > map , final K key , final double defaultValue ) { return applyDefaultValue ( map , key , MapUtils :: getDouble , defaultValue ) . doubleValue () ; MST[PrimitiveReturnsMutator]MSP[] }
final Object key = entry . getKey () ; final Object value = entry . getValue () ; answer . put ( key , value ) ; } } return answer ; MST[NullReturnValsMutator]MSP[] }
public static < K > int getIntValue ( final Map < ? super K , ? > map , final K key ) { return applyDefaultValue ( map , key , MapUtils :: getInteger , 0 ) . intValue () ; MST[InlineConstantMutator]MSP[] }
public static < K > Boolean getBoolean ( final Map < ? super K , ? > map , final K key ) { if ( map != null ) { final Object answer = map . get ( key ) ; MST[NonVoidMethodCallMutator]MSP[] if ( answer != null ) {
final Number answer = getNumber ( map , key ) ; if ( answer == null ) { return null ; } if ( answer instanceof Integer ) { MST[rv.ROR2Mutator]MSP[] return ( Integer ) answer ; } return Integer . valueOf ( answer . intValue () ) ; }
out . print ( label ) ; out . println ( lr_6 ) ; } printIndent ( out , lineage . size () ) ; MST[NonVoidMethodCallMutator]MSP[] out . println ( lr_8 ) ; lineage . addLast ( map ) ;
out . print ( label ) ; out . println ( lr_6 ) ; } printIndent ( out , lineage . size () ) ; out . println ( lr_8 ) ; MST[VoidMethodCallMutator]MSP[] lineage . addLast ( map ) ;
final Number answer = getNumber ( map , key ) ; if ( answer == null ) { return null ; } if ( answer instanceof Integer ) { MST[rv.ROR4Mutator]MSP[] return ( Integer ) answer ; } return Integer . valueOf ( answer . intValue () ) ; }
public static < K > byte getByteValue ( final Map < ? super K , ? > map , final K key , final byte defaultValue ) { return applyDefaultValue ( map , key , MapUtils :: getByte , defaultValue ) . byteValue () ; MST[rv.UOI1Mutator]MSP[] }
if ( sub == null || sub . length < 2 ) { MST[rv.ROR5Mutator]MSP[] throw new IllegalArgumentException ( lr_4 + i ) ; } map . put ( ( K ) sub [ 0 ] , ( V ) sub [ 1 ] ) ; } } else {
public static < K > boolean getBooleanValue ( final Map < ? super K , ? > map , final K key , final boolean defaultValue ) { return applyDefaultValue ( map , key , MapUtils :: getBoolean , defaultValue ) . booleanValue () ; MST[NonVoidMethodCallMutator]MSP[] }
final Object answer = map . get ( key ) ; MST[ArgumentPropagationMutator]MSP[] if ( answer != null ) { if ( answer instanceof Number ) { return ( Number ) answer ; } if ( answer instanceof String ) { try { final String text = ( String ) answer ;
public static < K , V > IterableSortedMap < K , V > iterableSortedMap ( final SortedMap < K , V > sortedMap ) { Objects . requireNonNull ( sortedMap , lr_2 ) ; return sortedMap instanceof IterableSortedMap ? ( IterableSortedMap < K , V > ) sortedMap MST[rv.ROR3Mutator]MSP[]
final Object answer = map . get ( key ) ; if ( answer != null ) { if ( answer instanceof Number ) { return ( Number ) answer ; } if ( answer instanceof String ) { MST[rv.ROR1Mutator]MSP[] try { final String text = ( String ) answer ;
return applyDefaultFunction ( map , key , MapUtils :: getInteger , defaultFunction , 0 ) . byteValue () ; MST[rv.CRCR5Mutator]MSP[] } public static < K > int getIntValue ( final Map < ? super K , ? > map , final K key , final int defaultValue ) {
public static int size ( final Map < ? , ? > map ) { return map == null ? 0 : map . size () ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] }
public static < K > Double getDouble ( final Map < ? super K , ? > map , final K key , final Double defaultValue ) { return applyDefaultValue ( map , key , MapUtils :: getDouble , defaultValue ) ; MST[ReturnValsMutator]MSP[] }
public static < K > Float getFloat ( final Map < ? super K , ? > map , final K key , final Function < K , Float > defaultFunction ) { return applyDefaultFunction ( map , key , MapUtils :: getFloat , defaultFunction ) ; MST[ArgumentPropagationMutator]MSP[] }
public static < K > Byte getByte ( final Map < ? super K , ? > map , final K key , final Function < K , Byte > defaultFunction ) { return applyDefaultFunction ( map , key , MapUtils :: getByte , defaultFunction ) ; MST[NullReturnValsMutator]MSP[] }
out . put ( entry . getValue () , entry . getKey () ) ; } return out ; } public static boolean isEmpty ( final Map < ? , ? > map ) { return map == null || map . isEmpty () ; MST[NegateConditionalsMutator]MSP[] }
final Properties answer = new Properties () ; if ( map != null ) { for ( final Entry < K , V > entry2 : map . entrySet () ) { MST[NonVoidMethodCallMutator]MSP[] final Map . Entry < ? , ? > entry = entry2 ;
final Number answer = getNumber ( map , key ) ; if ( answer == null ) { return null ; } if ( answer instanceof Double ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return ( Double ) answer ; } return Double . valueOf ( answer . doubleValue () ) ; }
return applyDefaultFunction ( map , key , MapUtils :: getDouble , defaultFunction , 0d ) . doubleValue () ; MST[NonVoidMethodCallMutator]MSP[] } public static < K > Float getFloat ( final Map < ? super K , ? > map , final K key ) {
public static < K , V > V getObject ( final Map < K , V > map , final K key , final V defaultValue ) { if ( map != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] final V answer = map . get ( key ) ;
final Transformer < E , K > keyTransformer , final Transformer < E , V > valueTransformer ) { final Iterator < ? extends E > iter = elements . iterator () ; MST[NonVoidMethodCallMutator]MSP[] while ( iter . hasNext () ) { final E temp = iter . next () ;
final Iterator < ? extends E > iter = elements . iterator () ; while ( iter . hasNext () ) { final E temp = iter . next () ; map . put ( keyTransformer . transform ( temp ) , valueTransformer . transform ( temp ) ) ; MST[ArgumentPropagationMutator]MSP[]
final Transformer < E , K > keyTransformer , final Transformer < E , V > valueTransformer ) { final Iterator < ? extends E > iter = elements . iterator () ; while ( iter . hasNext () ) { MST[rv.ROR1Mutator]MSP[] final E temp = iter . next () ;
out . print ( childValue ) ; } else if ( lineage . size () - 1 == lineageIndex ) { MST[rv.AOD1Mutator]MSP[] out . print ( lr_9 ) ; } else {
if ( map != null ) { final Object answer = map . get ( key ) ; if ( answer != null && answer instanceof Map ) { MST[NegateConditionalsMutator]MSP[] return ( Map < ? , ? > ) answer ; } } return null ; }
return applyDefaultFunction ( map , key , MapUtils :: getBoolean , defaultFunction , false ) . booleanValue () ; MST[rv.CRCR3Mutator]MSP[] } public static < K > Byte getByte ( final Map < ? super K , ? > map , final K key ) {
for ( int i = 0 ; i < array . length - 1 ; ) { MST[rv.ROR3Mutator]MSP[] map . put ( ( K ) array [ i ++ ] , ( V ) array [ i ++ ] ) ; } } return map ; }
return applyDefaultFunction ( map , key , MapUtils :: getBoolean , defaultFunction , false ) . booleanValue () ; MST[InlineConstantMutator]MSP[] } public static < K > Byte getByte ( final Map < ? super K , ? > map , final K key ) {
out . print ( lr_10 + ( lineage . size () - 1 - lineageIndex - 1 ) + lr_11 ) ; } if ( debug && childValue != null ) { out . print ( ' ' ) ; MST[InlineConstantMutator]MSP[]
public static < K > double getDoubleValue ( final Map < ? super K , ? > map , final K key ) { return applyDefaultValue ( map , key , MapUtils :: getDouble , 0d ) . doubleValue () ; MST[rv.CRCR5Mutator]MSP[] }
if ( map != null ) { final Object answer = map . get ( key ) ; if ( answer != null && answer instanceof Map ) { return ( Map < ? , ? > ) answer ; MST[ReturnValsMutator]MSP[] } } return null ; }
final Object value = resourceBundle . getObject ( key ) ; map . put ( key , value ) ; } return map ; MST[NullReturnValsMutator]MSP[] } public static < K , V > Properties toProperties ( final Map < K , V > map ) {
public static < K , V > IterableSortedMap < K , V > iterableSortedMap ( final SortedMap < K , V > sortedMap ) { Objects . requireNonNull ( sortedMap , lr_2 ) ; return sortedMap instanceof IterableSortedMap ? ( IterableSortedMap < K , V > ) sortedMap MST[NegateConditionalsMutator]MSP[]
out . print ( label ) ; MST[VoidMethodCallMutator]MSP[] out . println ( lr_6 ) ; } printIndent ( out , lineage . size () ) ; out . println ( lr_8 ) ; lineage . addLast ( map ) ;
public static < K > short getShortValue ( final Map < ? super K , ? > map , final K key , final short defaultValue ) { return applyDefaultValue ( map , key , MapUtils :: getShort , defaultValue ) . shortValue () ; MST[rv.UOI3Mutator]MSP[] }
public static < K > long getLongValue ( final Map < ? super K , ? > map , final K key ) { return applyDefaultValue ( map , key , MapUtils :: getLong , 0L ) . longValue () ; MST[NonVoidMethodCallMutator]MSP[] }
for ( int i = 0 ; i < array . length - 1 ; ) { map . put ( ( K ) array [ i ++ ] , ( V ) array [ i ++ ] ) ; MST[IncrementsMutator]MSP[] } } return map ; }
if ( sub == null || sub . length < 2 ) { throw new IllegalArgumentException ( lr_4 + i ) ; MST[rv.UOI1Mutator]MSP[] } map . put ( ( K ) sub [ 0 ] , ( V ) sub [ 1 ] ) ; } } else {
out . print ( lr_10 + ( lineage . size () - 1 - lineageIndex - 1 ) + lr_11 ) ; } if ( debug && childValue != null ) { out . print ( ' ' ) ; MST[rv.CRCR3Mutator]MSP[]
public static < K > byte getByteValue ( final Map < ? super K , ? > map , final K key ) { return applyDefaultValue ( map , key , MapUtils :: getByte , 0 ) . byteValue () ; MST[rv.CRCR1Mutator]MSP[] }
final Object answer = map . get ( key ) ; if ( answer != null ) { if ( answer instanceof Number ) { MST[NegateConditionalsMutator]MSP[] return ( Number ) answer ; } if ( answer instanceof String ) { try { final String text = ( String ) answer ;
} else if ( obj instanceof Object [] ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] for ( int i = 0 ; i < array . length ; i ++ ) { final Object [] sub = ( Object [] ) array [ i ] ;
public static < K > Short getShort ( final Map < ? super K , ? > map , final K key , final Function < K , Short > defaultFunction ) { return applyDefaultFunction ( map , key , MapUtils :: getShort , defaultFunction ) ; MST[NonVoidMethodCallMutator]MSP[] }
public static < K > short getShortValue ( final Map < ? super K , ? > map , final K key ) { return applyDefaultValue ( map , key , MapUtils :: getShort , 0 ) . shortValue () ; MST[rv.CRCR5Mutator]MSP[] }
if ( answer instanceof Boolean ) { MST[rv.ROR4Mutator]MSP[] return ( Boolean ) answer ; } if ( answer instanceof String ) { return Boolean . valueOf ( ( String ) answer ) ; } if ( answer instanceof Number ) { final Number n = ( Number ) answer ;
final Number answer = getNumber ( map , key ) ; MST[NonVoidMethodCallMutator]MSP[] if ( answer == null ) { return null ; } if ( answer instanceof Float ) { return ( Float ) answer ; } return Float . valueOf ( answer . floatValue () ) ; }
final Number answer = getNumber ( map , key ) ; if ( answer == null ) { return null ; } if ( answer instanceof Long ) { MST[rv.ROR4Mutator]MSP[] return ( Long ) answer ; } return Long . valueOf ( answer . longValue () ) ; }
final Number answer = getNumber ( map , key ) ; if ( answer == null ) { return null ; } if ( answer instanceof Float ) { MST[NegateConditionalsMutator]MSP[] return ( Float ) answer ; } return Float . valueOf ( answer . floatValue () ) ; }
printIndent ( out , lineage . size () ) ; MST[VoidMethodCallMutator]MSP[] out . print ( childKey ) ; out . print ( lr_6 ) ; final int lineageIndex = IterableUtils . indexOf ( lineage , PredicateUtils . equalPredicate ( childValue ) ) ; if ( lineageIndex == - 1 ) {
final Iterator < ? extends E > iter = elements . iterator () ; while ( iter . hasNext () ) { MST[rv.ROR1Mutator]MSP[] final E temp = iter . next () ; map . put ( keyTransformer . transform ( temp ) , valueTransformer . transform ( temp ) ) ;
for ( final Object element : array ) { MST[rv.ABSMutator]MSP[] final KeyValue < K , V > keyval = ( KeyValue < K , V > ) element ; map . put ( keyval . getKey () , keyval . getValue () ) ; }
public static boolean isNotEmpty ( final Map < ? , ? > map ) { return ! MapUtils . isEmpty ( map ) ; MST[rv.CRCR6Mutator]MSP[] } public static < K , V > IterableMap < K , V > iterableMap ( final Map < K , V > map ) {
out . print ( childValue ) ; } else if ( lineage . size () - 1 == lineageIndex ) { MST[rv.CRCR4Mutator]MSP[] out . print ( lr_9 ) ; } else {
out . print ( lr_10 + ( lineage . size () - 1 - lineageIndex - 1 ) + lr_11 ) ; } if ( debug && childValue != null ) { MST[rv.ROR2Mutator]MSP[] out . print ( ' ' ) ;
if ( answer instanceof Boolean ) { return ( Boolean ) answer ; } if ( answer instanceof String ) { MST[rv.ROR2Mutator]MSP[] return Boolean . valueOf ( ( String ) answer ) ; } if ( answer instanceof Number ) { final Number n = ( Number ) answer ;
return PredicatedMap . predicatedMap ( map , keyPred , valuePred ) ; MST[NullReturnValsMutator]MSP[] } public static < K , V > SortedMap < K , V > predicatedSortedMap ( final SortedMap < K , V > map ,
} else if ( obj instanceof Object [] ) { for ( int i = 0 ; i < array . length ; i ++ ) { MST[rv.UOI1Mutator]MSP[] final Object [] sub = ( Object [] ) array [ i ] ;
Objects . requireNonNull ( map , lr_1 ) ; return map instanceof IterableMap ? ( IterableMap < K , V > ) map : new AbstractMapDecorator < K , V > ( map ) { MST[NegateConditionalsMutator]MSP[] } ; }
final Number answer = getNumber ( map , key ) ; if ( answer == null ) { return null ; } if ( answer instanceof Float ) { MST[rv.ROR5Mutator]MSP[] return ( Float ) answer ; } return Float . valueOf ( answer . floatValue () ) ; }
public static < K > Double getDouble ( final Map < ? super K , ? > map , final K key , final Function < K , Double > defaultFunction ) { return applyDefaultFunction ( map , key , MapUtils :: getDouble , defaultFunction ) ; MST[EmptyObjectReturnValsMutator]MSP[] }
return NumberFormat . getInstance () . parse ( text ) ; MST[NonVoidMethodCallMutator]MSP[] } catch ( final ParseException e ) { } } } } return null ; } public static < K > Number getNumber ( final Map < ? super K , ? > map , final K key ,
if ( array == null || array . length == 0 ) { return map ; } final Object obj = array [ 0 ] ; if ( obj instanceof Map . Entry ) { for ( final Object element : array ) { MST[rv.UOI1Mutator]MSP[]
out . print ( lr_10 + ( lineage . size () - 1 - lineageIndex - 1 ) + lr_11 ) ; MST[rv.CRCR6Mutator]MSP[] } if ( debug && childValue != null ) { out . print ( ' ' ) ;
} else if ( obj instanceof Object [] ) { for ( int i = 0 ; i < array . length ; i ++ ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[] final Object [] sub = ( Object [] ) array [ i ] ;
if ( childValue instanceof Map && ! lineage . contains ( childValue ) ) { MST[rv.ROR1Mutator]MSP[] verbosePrintInternal ( out , childKey == null ? lr_7 : childKey , ( Map < ? , ? > ) childValue , lineage , debug ) ; } else {
out . put ( entry . getValue () , entry . getKey () ) ; } return out ; } public static boolean isEmpty ( final Map < ? , ? > map ) { return map == null || map . isEmpty () ; MST[rv.ROR3Mutator]MSP[] }
if ( array == null || array . length == 0 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return map ; } final Object obj = array [ 0 ] ; if ( obj instanceof Map . Entry ) { for ( final Object element : array ) {
out . put ( entry . getValue () , entry . getKey () ) ; } return out ; } public static boolean isEmpty ( final Map < ? , ? > map ) { return map == null || map . isEmpty () ; MST[rv.CRCR5Mutator]MSP[] }
out . put ( entry . getValue () , entry . getKey () ) ; } return out ; } public static boolean isEmpty ( final Map < ? , ? > map ) { return map == null || map . isEmpty () ; MST[rv.CRCR3Mutator]MSP[] }
public static < K > float getFloatValue ( final Map < ? super K , ? > map , final K key ) { return applyDefaultValue ( map , key , MapUtils :: getFloat , 0f ) . floatValue () ; MST[rv.CRCR6Mutator]MSP[] }
public static < K > byte getByteValue ( final Map < ? super K , ? > map , final K key ) { return applyDefaultValue ( map , key , MapUtils :: getByte , 0 ) . byteValue () ; MST[rv.CRCR6Mutator]MSP[] }
if ( map != null ) { final Object answer = map . get ( key ) ; if ( answer != null && answer instanceof Map ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return ( Map < ? , ? > ) answer ; } } return null ; }
public static boolean isNotEmpty ( final Map < ? , ? > map ) { return ! MapUtils . isEmpty ( map ) ; MST[rv.ROR1Mutator]MSP[] } public static < K , V > IterableMap < K , V > iterableMap ( final Map < K , V > map ) {
public static < K > Double getDouble ( final Map < ? super K , ? > map , final K key , final Double defaultValue ) { return applyDefaultValue ( map , key , MapUtils :: getDouble , defaultValue ) ; MST[EmptyObjectReturnValsMutator]MSP[] }
if ( map == null ) { if ( label != null ) { out . print ( label ) ; out . print ( lr_6 ) ; } out . println ( lr_7 ) ; return; } if ( label != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
printIndent ( out , lineage . size () ) ; out . print ( childKey ) ; out . print ( lr_6 ) ; final int lineageIndex = IterableUtils . indexOf ( lineage , PredicateUtils . equalPredicate ( childValue ) ) ; if ( lineageIndex == - 1 ) { MST[rv.UOI4Mutator]MSP[]
final Number answer = getNumber ( map , key ) ; if ( answer == null ) { return null ; } if ( answer instanceof Double ) { MST[rv.ROR4Mutator]MSP[] return ( Double ) answer ; } return Double . valueOf ( answer . doubleValue () ) ; }
public static int size ( final Map < ? , ? > map ) { return map == null ? 0 : map . size () ; MST[rv.CRCR5Mutator]MSP[] }
final Object answer = map . get ( key ) ; if ( answer != null ) { if ( answer instanceof Number ) { MST[rv.ROR3Mutator]MSP[] return ( Number ) answer ; } if ( answer instanceof String ) { try { final String text = ( String ) answer ;
final Number answer = getNumber ( map , key ) ; if ( answer == null ) { return null ; } if ( answer instanceof Float ) { return ( Float ) answer ; MST[ReturnValsMutator]MSP[] } return Float . valueOf ( answer . floatValue () ) ; }
final Iterator < ? extends E > iter = elements . iterator () ; MST[NonVoidMethodCallMutator]MSP[] while ( iter . hasNext () ) { final E temp = iter . next () ; map . put ( keyTransformer . transform ( temp ) , valueTransformer . transform ( temp ) ) ;
public static < K > Boolean getBoolean ( final Map < ? super K , ? > map , final K key , final Function < K , Boolean > defaultFunction ) { return applyDefaultFunction ( map , key , MapUtils :: getBoolean , defaultFunction ) ; MST[BooleanFalseReturnValsMutator]MSP[] }
public static < K > boolean getBooleanValue ( final Map < ? super K , ? > map , final K key , final boolean defaultValue ) { return applyDefaultValue ( map , key , MapUtils :: getBoolean , defaultValue ) . booleanValue () ; MST[NonVoidMethodCallMutator]MSP[] }
out . print ( lr_10 + ( lineage . size () - 1 - lineageIndex - 1 ) + lr_11 ) ; } if ( debug && childValue != null ) { MST[rv.UOI4Mutator]MSP[] out . print ( ' ' ) ;
public static < K > Number getNumber ( final Map < ? super K , ? > map , final K key , final Number defaultValue ) { return applyDefaultValue ( map , key , MapUtils :: getNumber , defaultValue ) ; MST[ArgumentPropagationMutator]MSP[] }
public static < K > int getIntValue ( final Map < ? super K , ? > map , final K key ) { return applyDefaultValue ( map , key , MapUtils :: getInteger , 0 ) . intValue () ; MST[rv.CRCR3Mutator]MSP[] }
public static < K > String getString ( final Map < ? super K , ? > map , final K key ) { if ( map != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] final Object answer = map . get ( key ) ; if ( answer != null ) {
final Number answer = getNumber ( map , key ) ; if ( answer == null ) { MST[rv.ROR5Mutator]MSP[] return null ; } if ( answer instanceof Integer ) { return ( Integer ) answer ; } return Integer . valueOf ( answer . intValue () ) ; }
public static < K > byte getByteValue ( final Map < ? super K , ? > map , final K key , final byte defaultValue ) { return applyDefaultValue ( map , key , MapUtils :: getByte , defaultValue ) . byteValue () ; MST[NonVoidMethodCallMutator]MSP[] }
final Number answer = getNumber ( map , key ) ; if ( answer == null ) { return null ; } if ( answer instanceof Integer ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return ( Integer ) answer ; } return Integer . valueOf ( answer . intValue () ) ; }
out . println ( debug ? lr_12 + map . getClass () . getName () : lr_13 ) ; MST[NegateConditionalsMutator]MSP[] }
out . println ( debug ? lr_12 + map . getClass () . getName () : lr_13 ) ; MST[rv.UOI2Mutator]MSP[] }
} else if ( obj instanceof Object [] ) { for ( int i = 0 ; i < array . length ; i ++ ) { MST[rv.ROR4Mutator]MSP[] final Object [] sub = ( Object [] ) array [ i ] ;
if ( sub == null || sub . length < 2 ) { MST[InlineConstantMutator]MSP[] throw new IllegalArgumentException ( lr_4 + i ) ; } map . put ( ( K ) sub [ 0 ] , ( V ) sub [ 1 ] ) ; } } else {
if ( map == null ) { if ( label != null ) { out . print ( label ) ; out . print ( lr_6 ) ; MST[VoidMethodCallMutator]MSP[] } out . println ( lr_7 ) ; return; } if ( label != null ) {
return applyDefaultValue ( map , key , MapUtils :: getMap , defaultValue ) ; } public static < K > Number getNumber ( final Map < ? super K , ? > map , final K key ) { if ( map != null ) { MST[NegateConditionalsMutator]MSP[]
return applyDefaultFunction ( map , key , MapUtils :: getLong , defaultFunction , 0L ) . byteValue () ; MST[rv.CRCR5Mutator]MSP[] } public static < K > long getLongValue ( final Map < ? super K , ? > map , final K key , final long defaultValue ) {
out . print ( childValue ) ; } else if ( lineage . size () - 1 == lineageIndex ) { MST[rv.ROR1Mutator]MSP[] out . print ( lr_9 ) ; } else {
public static int size ( final Map < ? , ? > map ) { return map == null ? 0 : map . size () ; MST[rv.ROR5Mutator]MSP[] }
return applyDefaultValue ( map , key , MapUtils :: getMap , defaultValue ) ; MST[NullReturnValsMutator]MSP[] } public static < K > Number getNumber ( final Map < ? super K , ? > map , final K key ) { if ( map != null ) {
final Number answer = getNumber ( map , key ) ; if ( answer == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return null ; } if ( answer instanceof Double ) { return ( Double ) answer ; } return Double . valueOf ( answer . doubleValue () ) ; }
public static < K > Long getLong ( final Map < ? super K , ? > map , final K key , final Function < K , Long > defaultFunction ) { return applyDefaultFunction ( map , key , MapUtils :: getLong , defaultFunction ) ; MST[NonVoidMethodCallMutator]MSP[] }
final Map . Entry < K , V > entry = ( Map . Entry < K , V > ) element ; map . put ( entry . getKey () , entry . getValue () ) ; } } else if ( obj instanceof KeyValue ) { MST[rv.ROR2Mutator]MSP[]
final Number answer = getNumber ( map , key ) ; if ( answer == null ) { MST[NegateConditionalsMutator]MSP[] return null ; } if ( answer instanceof Short ) { return ( Short ) answer ; } return Short . valueOf ( answer . shortValue () ) ; }
final Number answer = getNumber ( map , key ) ; if ( answer == null ) { return null ; } if ( answer instanceof Short ) { return ( Short ) answer ; } return Short . valueOf ( answer . shortValue () ) ; MST[EmptyObjectReturnValsMutator]MSP[] }
if ( sub == null || sub . length < 2 ) { MST[NegateConditionalsMutator]MSP[] throw new IllegalArgumentException ( lr_4 + i ) ; } map . put ( ( K ) sub [ 0 ] , ( V ) sub [ 1 ] ) ; } } else {
if ( array == null || array . length == 0 ) { return map ; } final Object obj = array [ 0 ] ; if ( obj instanceof Map . Entry ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] for ( final Object element : array ) {
if ( answer instanceof Boolean ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return ( Boolean ) answer ; } if ( answer instanceof String ) { return Boolean . valueOf ( ( String ) answer ) ; } if ( answer instanceof Number ) { final Number n = ( Number ) answer ;
for ( int i = 0 ; i < array . length - 1 ; ) { MST[rv.CRCR2Mutator]MSP[] map . put ( ( K ) array [ i ++ ] , ( V ) array [ i ++ ] ) ; } } return map ; }
public static < K > short getShortValue ( final Map < ? super K , ? > map , final K key , final short defaultValue ) { return applyDefaultValue ( map , key , MapUtils :: getShort , defaultValue ) . shortValue () ; MST[rv.ABSMutator]MSP[] }
out . println ( debug ? lr_12 + map . getClass () . getName () : lr_13 ) ; MST[VoidMethodCallMutator]MSP[] }
public static < K > int getIntValue ( final Map < ? super K , ? > map , final K key ) { return applyDefaultValue ( map , key , MapUtils :: getInteger , 0 ) . intValue () ; MST[PrimitiveReturnsMutator]MSP[] }
Objects . requireNonNull ( map , lr_1 ) ; return map instanceof IterableMap ? ( IterableMap < K , V > ) map : new AbstractMapDecorator < K , V > ( map ) { MST[ConstructorCallMutator]MSP[] } ; }
for ( final Object element : array ) { MST[rv.UOI4Mutator]MSP[] final KeyValue < K , V > keyval = ( KeyValue < K , V > ) element ; map . put ( keyval . getKey () , keyval . getValue () ) ; }
public static < K > float getFloatValue ( final Map < ? super K , ? > map , final K key ) { return applyDefaultValue ( map , key , MapUtils :: getFloat , 0f ) . floatValue () ; MST[rv.CRCR1Mutator]MSP[] }
return applyDefaultValue ( map , key , MapUtils :: getLong , defaultValue ) . longValue () ; MST[rv.UOI1Mutator]MSP[] } public static < K > Map < ? , ? > getMap ( final Map < ? super K , ? > map , final K key ) {
public static < K , V > V getObject ( final Map < ? super K , V > map , final K key ) { if ( map != null ) { return map . get ( key ) ; } return null ; MST[ReturnValsMutator]MSP[] }
for ( int i = 0 ; i < indent ; i ++ ) { MST[rv.UOI4Mutator]MSP[] out . print ( INDENT_STRING ) ; } } @SuppressWarnings ( lr_3 )
return n . intValue () != 0 ? Boolean . TRUE : Boolean . FALSE ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] } } } return null ; }
out . println ( debug ? lr_12 + map . getClass () . getName () : lr_13 ) ; MST[rv.ROR1Mutator]MSP[] }
if ( array == null || array . length == 0 ) { return map ; } final Object obj = array [ 0 ] ; MST[rv.CRCR1Mutator]MSP[] if ( obj instanceof Map . Entry ) { for ( final Object element : array ) {
if ( map != null ) { final Object answer = map . get ( key ) ; if ( answer != null && answer instanceof Map ) { MST[rv.ROR4Mutator]MSP[] return ( Map < ? , ? > ) answer ; } } return null ; }
if ( sub == null || sub . length < 2 ) { throw new IllegalArgumentException ( lr_4 + i ) ; MST[NonVoidMethodCallMutator]MSP[] } map . put ( ( K ) sub [ 0 ] , ( V ) sub [ 1 ] ) ; } } else {
verbosePrintInternal ( out , label , map , new ArrayDeque < Map < ? , ? > > () , true ) ; MST[InlineConstantMutator]MSP[] } public static < K , V > Map < K , V > emptyIfNull ( final Map < K , V > map ) {
final Enumeration < String > enumeration = resourceBundle . getKeys () ; final Map < String , Object > map = new HashMap <> () ; while ( enumeration . hasMoreElements () ) { MST[rv.ROR2Mutator]MSP[] final String key = enumeration . nextElement () ;
out . print ( lr_10 + ( lineage . size () - 1 - lineageIndex - 1 ) + lr_11 ) ; MST[InlineConstantMutator]MSP[] } if ( debug && childValue != null ) { out . print ( ' ' ) ;
final Number answer = getNumber ( map , key ) ; if ( answer == null ) { MST[NegateConditionalsMutator]MSP[] return null ; } if ( answer instanceof Byte ) { return ( Byte ) answer ; } return Byte . valueOf ( answer . byteValue () ) ; }
return applyDefaultFunction ( map , key , MapUtils :: getByte , defaultFunction , ( byte ) 0 ) . byteValue () ; MST[ReturnValsMutator]MSP[] } public static < K > Double getDouble ( final Map < ? super K , ? > map , final K key ) {
final Number answer = getNumber ( map , key ) ; if ( answer == null ) { return null ; } if ( answer instanceof Short ) { return ( Short ) answer ; } return Short . valueOf ( answer . shortValue () ) ; MST[ReturnValsMutator]MSP[] }
if ( childValue instanceof Map && ! lineage . contains ( childValue ) ) { verbosePrintInternal ( out , childKey == null ? lr_7 : childKey , ( Map < ? , ? > ) childValue , lineage , debug ) ; MST[NegateConditionalsMutator]MSP[] } else {
map . put ( keyTransformer . transform ( temp ) , valueTransformer . transform ( temp ) ) ; MST[ArgumentPropagationMutator]MSP[] } } public static < K , V > void populateMap ( final MultiMap < K , V > map , final Iterable < ? extends V > elements ,
if ( map != null ) { final Object answer = map . get ( key ) ; if ( answer != null && answer instanceof Map ) { return ( Map < ? , ? > ) answer ; MST[NullReturnValsMutator]MSP[] } } return null ; }
final Number answer = getNumber ( map , key ) ; if ( answer == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return null ; } if ( answer instanceof Long ) { return ( Long ) answer ; } return Long . valueOf ( answer . longValue () ) ; }
return n . intValue () != 0 ? Boolean . TRUE : Boolean . FALSE ; MST[rv.ROR5Mutator]MSP[] } } } return null ; }
out . put ( entry . getValue () , entry . getKey () ) ; } return out ; } public static boolean isEmpty ( final Map < ? , ? > map ) { return map == null || map . isEmpty () ; MST[NonVoidMethodCallMutator]MSP[] }
for ( int i = 0 ; i < array . length - 1 ; ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[] map . put ( ( K ) array [ i ++ ] , ( V ) array [ i ++ ] ) ; } } return map ; }
if ( answer instanceof Boolean ) { return ( Boolean ) answer ; } if ( answer instanceof String ) { return Boolean . valueOf ( ( String ) answer ) ; MST[BooleanFalseReturnValsMutator]MSP[] } if ( answer instanceof Number ) { final Number n = ( Number ) answer ;
public static < K > void safeAddToMap ( final Map < ? super K , Object > map , final K key , final Object value ) throws NullPointerException { map . put ( key , value == null ? lr_5 : value ) ; MST[ArgumentPropagationMutator]MSP[] }
final Number answer = getNumber ( map , key ) ; if ( answer == null ) { return null ; } if ( answer instanceof Short ) { MST[rv.ROR3Mutator]MSP[] return ( Short ) answer ; } return Short . valueOf ( answer . shortValue () ) ; }
final Iterator < ? extends E > iter = elements . iterator () ; while ( iter . hasNext () ) { final E temp = iter . next () ; map . put ( keyTransformer . transform ( temp ) , valueTransformer . transform ( temp ) ) ; MST[NonVoidMethodCallMutator]MSP[]
public static < K > short getShortValue ( final Map < ? super K , ? > map , final K key , final short defaultValue ) { return applyDefaultValue ( map , key , MapUtils :: getShort , defaultValue ) . shortValue () ; MST[rv.UOI4Mutator]MSP[] }
if ( sub == null || sub . length < 2 ) { throw new IllegalArgumentException ( lr_4 + i ) ; MST[rv.UOI2Mutator]MSP[] } map . put ( ( K ) sub [ 0 ] , ( V ) sub [ 1 ] ) ; } } else {
public static < K > long getLongValue ( final Map < ? super K , ? > map , final K key ) { return applyDefaultValue ( map , key , MapUtils :: getLong , 0L ) . longValue () ; MST[rv.CRCR5Mutator]MSP[] }
out . print ( lr_10 + ( lineage . size () - 1 - lineageIndex - 1 ) + lr_11 ) ; MST[rv.AOR3Mutator]MSP[] } if ( debug && childValue != null ) { out . print ( ' ' ) ;
final Map . Entry < K , V > entry = ( Map . Entry < K , V > ) element ; map . put ( entry . getKey () , entry . getValue () ) ; MST[NonVoidMethodCallMutator]MSP[] } } else if ( obj instanceof KeyValue ) {
final Number answer = getNumber ( map , key ) ; if ( answer == null ) { return null ; } if ( answer instanceof Integer ) { return ( Integer ) answer ; } return Integer . valueOf ( answer . intValue () ) ; MST[ReturnValsMutator]MSP[] }
out . print ( lr_10 + ( lineage . size () - 1 - lineageIndex - 1 ) + lr_11 ) ; } if ( debug && childValue != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] out . print ( ' ' ) ;
if ( answer instanceof Boolean ) { return ( Boolean ) answer ; MST[ReturnValsMutator]MSP[] } if ( answer instanceof String ) { return Boolean . valueOf ( ( String ) answer ) ; } if ( answer instanceof Number ) { final Number n = ( Number ) answer ;
public static < K > boolean getBooleanValue ( final Map < ? super K , ? > map , final K key , final boolean defaultValue ) { return applyDefaultValue ( map , key , MapUtils :: getBoolean , defaultValue ) . booleanValue () ; MST[rv.UOI1Mutator]MSP[] }
printIndent ( out , lineage . size () ) ; out . print ( childKey ) ; out . print ( lr_6 ) ; final int lineageIndex = IterableUtils . indexOf ( lineage , PredicateUtils . equalPredicate ( childValue ) ) ; if ( lineageIndex == - 1 ) { MST[rv.CRCR2Mutator]MSP[]
final Number answer = getNumber ( map , key ) ; if ( answer == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return null ; } if ( answer instanceof Float ) { return ( Float ) answer ; } return Float . valueOf ( answer . floatValue () ) ; }
} else if ( obj instanceof Object [] ) { for ( int i = 0 ; i < array . length ; i ++ ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] final Object [] sub = ( Object [] ) array [ i ] ;
if ( answer instanceof Boolean ) { MST[rv.ROR1Mutator]MSP[] return ( Boolean ) answer ; } if ( answer instanceof String ) { return Boolean . valueOf ( ( String ) answer ) ; } if ( answer instanceof Number ) { final Number n = ( Number ) answer ;
for ( final Object element : array ) { MST[rv.ABSMutator]MSP[] final KeyValue < K , V > keyval = ( KeyValue < K , V > ) element ; map . put ( keyval . getKey () , keyval . getValue () ) ; }
out . print ( lr_10 + ( lineage . size () - 1 - lineageIndex - 1 ) + lr_11 ) ; } if ( debug && childValue != null ) { MST[rv.ROR3Mutator]MSP[] out . print ( ' ' ) ;
final Number answer = getNumber ( map , key ) ; if ( answer == null ) { MST[rv.ROR5Mutator]MSP[] return null ; } if ( answer instanceof Long ) { return ( Long ) answer ; } return Long . valueOf ( answer . longValue () ) ; }
Objects . requireNonNull ( map , lr_1 ) ; return map instanceof IterableMap ? ( IterableMap < K , V > ) map : new AbstractMapDecorator < K , V > ( map ) { MST[rv.ROR5Mutator]MSP[] } ; }
public static < K > int getIntValue ( final Map < ? super K , ? > map , final K key ) { return applyDefaultValue ( map , key , MapUtils :: getInteger , 0 ) . intValue () ; MST[rv.CRCR5Mutator]MSP[] }
public static < K > float getFloatValue ( final Map < ? super K , ? > map , final K key ) { return applyDefaultValue ( map , key , MapUtils :: getFloat , 0f ) . floatValue () ; MST[ArgumentPropagationMutator]MSP[] }
out . print ( lr_10 + ( lineage . size () - 1 - lineageIndex - 1 ) + lr_11 ) ; } if ( debug && childValue != null ) { out . print ( ' ' ) ; MST[VoidMethodCallMutator]MSP[]
final Number answer = getNumber ( map , key ) ; MST[NonVoidMethodCallMutator]MSP[] if ( answer == null ) { return null ; } if ( answer instanceof Byte ) { return ( Byte ) answer ; } return Byte . valueOf ( answer . byteValue () ) ; }
public static < K > byte getByteValue ( final Map < ? super K , ? > map , final K key , final byte defaultValue ) { return applyDefaultValue ( map , key , MapUtils :: getByte , defaultValue ) . byteValue () ; MST[NonVoidMethodCallMutator]MSP[] }
for ( int i = 0 ; i < array . length - 1 ; ) { MST[rv.ROR4Mutator]MSP[] map . put ( ( K ) array [ i ++ ] , ( V ) array [ i ++ ] ) ; } } return map ; }
out . println ( childValue . getClass () . getName () ) ; } else { out . println () ; } } } lineage . removeLast () ; printIndent ( out , lineage . size () ) ; MST[NonVoidMethodCallMutator]MSP[]
final Enumeration < String > enumeration = resourceBundle . getKeys () ; final Map < String , Object > map = new HashMap <> () ; MST[ConstructorCallMutator]MSP[] while ( enumeration . hasMoreElements () ) { final String key = enumeration . nextElement () ;
public static < K > String getString ( final Map < ? super K , ? > map , final K key ) { if ( map != null ) { MST[rv.ROR5Mutator]MSP[] final Object answer = map . get ( key ) ; if ( answer != null ) {
if ( map == null ) { if ( label != null ) { out . print ( label ) ; out . print ( lr_6 ) ; } out . println ( lr_7 ) ; return; } if ( label != null ) { MST[NegateConditionalsMutator]MSP[]
public static < K > short getShortValue ( final Map < ? super K , ? > map , final K key , final short defaultValue ) { return applyDefaultValue ( map , key , MapUtils :: getShort , defaultValue ) . shortValue () ; MST[ReturnValsMutator]MSP[] }
final Map < V , K > out = new HashMap <> ( map . size () ) ; for ( final Entry < K , V > entry : map . entrySet () ) { MST[NonVoidMethodCallMutator]MSP[]
for ( int i = 0 ; i < indent ; i ++ ) { MST[rv.ROR5Mutator]MSP[] out . print ( INDENT_STRING ) ; } } @SuppressWarnings ( lr_3 )
return n . intValue () != 0 ? Boolean . TRUE : Boolean . FALSE ; MST[NegateConditionalsMutator]MSP[] } } } return null ; }
final Map . Entry < K , V > entry = ( Map . Entry < K , V > ) element ; map . put ( entry . getKey () , entry . getValue () ) ; } } else if ( obj instanceof KeyValue ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
final Enumeration < String > enumeration = resourceBundle . getKeys () ; final Map < String , Object > map = new HashMap <> () ; while ( enumeration . hasMoreElements () ) { final String key = enumeration . nextElement () ; MST[NonVoidMethodCallMutator]MSP[]
out . put ( entry . getValue () , entry . getKey () ) ; } return out ; MST[ReturnValsMutator]MSP[] } public static boolean isEmpty ( final Map < ? , ? > map ) { return map == null || map . isEmpty () ; }
for ( final Object element : array ) { MST[rv.UOI1Mutator]MSP[] final KeyValue < K , V > keyval = ( KeyValue < K , V > ) element ; map . put ( keyval . getKey () , keyval . getValue () ) ; }
printIndent ( out , lineage . size () ) ; out . print ( childKey ) ; out . print ( lr_6 ) ; final int lineageIndex = IterableUtils . indexOf ( lineage , PredicateUtils . equalPredicate ( childValue ) ) ; if ( lineageIndex == - 1 ) { MST[rv.ABSMutator]MSP[]
public static < K > byte getByteValue ( final Map < ? super K , ? > map , final K key , final byte defaultValue ) { return applyDefaultValue ( map , key , MapUtils :: getByte , defaultValue ) . byteValue () ; MST[rv.UOI2Mutator]MSP[] }
if ( answer != null ) { MST[NegateConditionalsMutator]MSP[] return answer ; } } return defaultValue ; } public static < K > Short getShort ( final Map < ? super K , ? > map , final K key ) {
if ( childValue instanceof Map && ! lineage . contains ( childValue ) ) { verbosePrintInternal ( out , childKey == null ? lr_7 : childKey , ( Map < ? , ? > ) childValue , lineage , debug ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] } else {
out . print ( lr_10 + ( lineage . size () - 1 - lineageIndex - 1 ) + lr_11 ) ; } if ( debug && childValue != null ) { MST[rv.ABSMutator]MSP[] out . print ( ' ' ) ;
verbosePrintInternal ( out , label , map , new ArrayDeque < Map < ? , ? > > () , true ) ; MST[rv.CRCR2Mutator]MSP[] } public static < K , V > Map < K , V > emptyIfNull ( final Map < K , V > map ) {
public static void verbosePrint ( final PrintStream out , final Object label , final Map < ? , ? > map ) { verbosePrintInternal ( out , label , map , new ArrayDeque < Map < ? , ? > > () , false ) ; MST[InlineConstantMutator]MSP[] }
return applyDefaultFunction ( map , key , MapUtils :: getFloat , defaultFunction , 0f ) . floatValue () ; MST[rv.CRCR3Mutator]MSP[] } public static < K > Integer getInteger ( final Map < ? super K , ? > map , final K key ) {
public static < K > Long getLong ( final Map < ? super K , ? > map , final K key , final Function < K , Long > defaultFunction ) { return applyDefaultFunction ( map , key , MapUtils :: getLong , defaultFunction ) ; MST[EmptyObjectReturnValsMutator]MSP[] }
public static < K , V > IterableSortedMap < K , V > iterableSortedMap ( final SortedMap < K , V > sortedMap ) { Objects . requireNonNull ( sortedMap , lr_2 ) ; return sortedMap instanceof IterableSortedMap ? ( IterableSortedMap < K , V > ) sortedMap MST[rv.ROR4Mutator]MSP[]
final Number answer = getNumber ( map , key ) ; MST[NonVoidMethodCallMutator]MSP[] if ( answer == null ) { return null ; } if ( answer instanceof Long ) { return ( Long ) answer ; } return Long . valueOf ( answer . longValue () ) ; }
public static boolean isNotEmpty ( final Map < ? , ? > map ) { return ! MapUtils . isEmpty ( map ) ; MST[rv.CRCR2Mutator]MSP[] } public static < K , V > IterableMap < K , V > iterableMap ( final Map < K , V > map ) {
if ( sub == null || sub . length < 2 ) { throw new IllegalArgumentException ( lr_4 + i ) ; MST[rv.ABSMutator]MSP[] } map . put ( ( K ) sub [ 0 ] , ( V ) sub [ 1 ] ) ; } } else {
public static < K > byte getByteValue ( final Map < ? super K , ? > map , final K key ) { return applyDefaultValue ( map , key , MapUtils :: getByte , 0 ) . byteValue () ; MST[NonVoidMethodCallMutator]MSP[] }
final Number answer = getNumber ( map , key ) ; if ( answer == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return null ; } if ( answer instanceof Byte ) { return ( Byte ) answer ; } return Byte . valueOf ( answer . byteValue () ) ; }
return applyDefaultFunction ( map , key , MapUtils :: getLong , defaultFunction , 0L ) . byteValue () ; MST[ReturnValsMutator]MSP[] } public static < K > long getLongValue ( final Map < ? super K , ? > map , final K key , final long defaultValue ) {
final Number answer = getNumber ( map , key ) ; if ( answer == null ) { return null ; MST[EmptyObjectReturnValsMutator]MSP[] } if ( answer instanceof Double ) { return ( Double ) answer ; } return Double . valueOf ( answer . doubleValue () ) ; }
} else if ( obj instanceof Object [] ) { for ( int i = 0 ; i < array . length ; i ++ ) { MST[rv.UOI2Mutator]MSP[] final Object [] sub = ( Object [] ) array [ i ] ;
if ( answer != null ) { return answer ; MST[ReturnValsMutator]MSP[] } } return defaultValue ; } public static < K > Short getShort ( final Map < ? super K , ? > map , final K key ) {
for ( int i = 0 ; i < array . length - 1 ; ) { MST[rv.UOI1Mutator]MSP[] map . put ( ( K ) array [ i ++ ] , ( V ) array [ i ++ ] ) ; } } return map ; }
return applyDefaultValue ( map , key , MapUtils :: getLong , defaultValue ) . longValue () ; MST[NonVoidMethodCallMutator]MSP[] } public static < K > Map < ? , ? > getMap ( final Map < ? super K , ? > map , final K key ) {
public static < K > String getString ( final Map < ? super K , ? > map , final K key ) { if ( map != null ) { MST[NegateConditionalsMutator]MSP[] final Object answer = map . get ( key ) ; if ( answer != null ) {
final Enumeration < String > enumeration = resourceBundle . getKeys () ; MST[NonVoidMethodCallMutator]MSP[] final Map < String , Object > map = new HashMap <> () ; while ( enumeration . hasMoreElements () ) { final String key = enumeration . nextElement () ;
return applyDefaultFunction ( map , key , MapUtils :: getString , defaultFunction ) ; MST[ReturnValsMutator]MSP[] } public static < K > String getString ( final Map < ? super K , ? > map , final K key , final String defaultValue ) {
if ( childValue instanceof Map && ! lineage . contains ( childValue ) ) { MST[rv.ROR2Mutator]MSP[] verbosePrintInternal ( out , childKey == null ? lr_7 : childKey , ( Map < ? , ? > ) childValue , lineage , debug ) ; } else {
public static < K > float getFloatValue ( final Map < ? super K , ? > map , final K key ) { return applyDefaultValue ( map , key , MapUtils :: getFloat , 0f ) . floatValue () ; MST[PrimitiveReturnsMutator]MSP[] }
for ( final Map . Entry < ? , ? > entry : map . entrySet () ) { final Object childKey = entry . getKey () ; MST[NonVoidMethodCallMutator]MSP[] final Object childValue = entry . getValue () ;
out . print ( lr_10 + ( lineage . size () - 1 - lineageIndex - 1 ) + lr_11 ) ; MST[rv.CRCR2Mutator]MSP[] } if ( debug && childValue != null ) { out . print ( ' ' ) ;
out . print ( lr_10 + ( lineage . size () - 1 - lineageIndex - 1 ) + lr_11 ) ; MST[rv.AOD1Mutator]MSP[] } if ( debug && childValue != null ) { out . print ( ' ' ) ;
out . print ( lr_10 + ( lineage . size () - 1 - lineageIndex - 1 ) + lr_11 ) ; MST[rv.CRCR4Mutator]MSP[] } if ( debug && childValue != null ) { out . print ( ' ' ) ;
if ( map == null ) { if ( label != null ) { out . print ( label ) ; out . print ( lr_6 ) ; } out . println ( lr_7 ) ; return; } if ( label != null ) { MST[rv.ROR5Mutator]MSP[]
for ( final Object element : array ) { final KeyValue < K , V > keyval = ( KeyValue < K , V > ) element ; map . put ( keyval . getKey () , keyval . getValue () ) ; MST[ArgumentPropagationMutator]MSP[] }
if ( childValue instanceof Map && ! lineage . contains ( childValue ) ) { MST[rv.ROR4Mutator]MSP[] verbosePrintInternal ( out , childKey == null ? lr_7 : childKey , ( Map < ? , ? > ) childValue , lineage , debug ) ; } else {
for ( int i = 0 ; i < array . length - 1 ; ) { MST[rv.AOD2Mutator]MSP[] map . put ( ( K ) array [ i ++ ] , ( V ) array [ i ++ ] ) ; } } return map ; }
return applyDefaultValue ( map , key , MapUtils :: getMap , defaultValue ) ; MST[NonVoidMethodCallMutator]MSP[] } public static < K > Number getNumber ( final Map < ? super K , ? > map , final K key ) { if ( map != null ) {
final Map . Entry < K , V > entry = ( Map . Entry < K , V > ) element ; map . put ( entry . getKey () , entry . getValue () ) ; } } else if ( obj instanceof KeyValue ) { MST[rv.ROR3Mutator]MSP[]
out . print ( lr_10 + ( lineage . size () - 1 - lineageIndex - 1 ) + lr_11 ) ; } if ( debug && childValue != null ) { out . print ( ' ' ) ; MST[rv.CRCR4Mutator]MSP[]
return applyDefaultFunction ( map , key , MapUtils :: getShort , defaultFunction , ( short ) 0 ) . shortValue () ; MST[PrimitiveReturnsMutator]MSP[] }
for ( int i = 0 ; i < array . length - 1 ; ) { MST[rv.CRCR3Mutator]MSP[] map . put ( ( K ) array [ i ++ ] , ( V ) array [ i ++ ] ) ; } } return map ; }
if ( answer != null ) { return answer ; MST[NullReturnValsMutator]MSP[] } } return defaultValue ; } public static < K > Short getShort ( final Map < ? super K , ? > map , final K key ) {
out . print ( lr_10 + ( lineage . size () - 1 - lineageIndex - 1 ) + lr_11 ) ; } if ( debug && childValue != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] out . print ( ' ' ) ;
public static boolean isNotEmpty ( final Map < ? , ? > map ) { return ! MapUtils . isEmpty ( map ) ; MST[InlineConstantMutator]MSP[] } public static < K , V > IterableMap < K , V > iterableMap ( final Map < K , V > map ) {
public static < K , V > V getObject ( final Map < K , V > map , final K key , final V defaultValue ) { if ( map != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] final V answer = map . get ( key ) ;
return applyDefaultValue ( map , key , MapUtils :: getLong , defaultValue ) . longValue () ; MST[rv.UOI2Mutator]MSP[] } public static < K > Map < ? , ? > getMap ( final Map < ? super K , ? > map , final K key ) {
public static < K , V > IterableSortedMap < K , V > iterableSortedMap ( final SortedMap < K , V > sortedMap ) { Objects . requireNonNull ( sortedMap , lr_2 ) ; MST[ArgumentPropagationMutator]MSP[] return sortedMap instanceof IterableSortedMap ? ( IterableSortedMap < K , V > ) sortedMap
final Number answer = getNumber ( map , key ) ; if ( answer == null ) { return null ; } if ( answer instanceof Double ) { MST[rv.ROR2Mutator]MSP[] return ( Double ) answer ; } return Double . valueOf ( answer . doubleValue () ) ; }
for ( int i = 0 ; i < indent ; i ++ ) { MST[InlineConstantMutator]MSP[] out . print ( INDENT_STRING ) ; } } @SuppressWarnings ( lr_3 )
return applyDefaultFunction ( map , key , MapUtils :: getDouble , defaultFunction , 0d ) . doubleValue () ; MST[rv.CRCR3Mutator]MSP[] } public static < K > Float getFloat ( final Map < ? super K , ? > map , final K key ) {
final Number answer = getNumber ( map , key ) ; if ( answer == null ) { return null ; MST[ReturnValsMutator]MSP[] } if ( answer instanceof Long ) { return ( Long ) answer ; } return Long . valueOf ( answer . longValue () ) ; }
public static int size ( final Map < ? , ? > map ) { return map == null ? 0 : map . size () ; MST[ReturnValsMutator]MSP[] }
for ( int i = 0 ; i < indent ; i ++ ) { MST[rv.UOI3Mutator]MSP[] out . print ( INDENT_STRING ) ; } } @SuppressWarnings ( lr_3 )
final Number answer = getNumber ( map , key ) ; if ( answer == null ) { MST[rv.ROR5Mutator]MSP[] return null ; } if ( answer instanceof Byte ) { return ( Byte ) answer ; } return Byte . valueOf ( answer . byteValue () ) ; }
final Object answer = map . get ( key ) ; if ( answer != null ) { if ( answer instanceof Number ) { return ( Number ) answer ; } if ( answer instanceof String ) { MST[rv.ROR3Mutator]MSP[] try { final String text = ( String ) answer ;
} else if ( obj instanceof Object [] ) { for ( int i = 0 ; i < array . length ; i ++ ) { MST[ConditionalsBoundaryMutator]MSP[] final Object [] sub = ( Object [] ) array [ i ] ;
return applyDefaultFunction ( map , key , MapUtils :: getDouble , defaultFunction , 0d ) . doubleValue () ; MST[rv.CRCR6Mutator]MSP[] } public static < K > Float getFloat ( final Map < ? super K , ? > map , final K key ) {
return applyDefaultFunction ( map , key , MapUtils :: getDouble , defaultFunction , 0d ) . doubleValue () ; MST[NonVoidMethodCallMutator]MSP[] } public static < K > Float getFloat ( final Map < ? super K , ? > map , final K key ) {
public static < K > Boolean getBoolean ( final Map < ? super K , ? > map , final K key ) { if ( map != null ) { final Object answer = map . get ( key ) ; if ( answer != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
final Number answer = getNumber ( map , key ) ; if ( answer == null ) { return null ; } if ( answer instanceof Short ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return ( Short ) answer ; } return Short . valueOf ( answer . shortValue () ) ; }
if ( array == null || array . length == 0 ) { return map ; } final Object obj = array [ 0 ] ; if ( obj instanceof Map . Entry ) { for ( final Object element : array ) { MST[rv.ABSMutator]MSP[]
if ( childValue instanceof Map && ! lineage . contains ( childValue ) ) { verbosePrintInternal ( out , childKey == null ? lr_7 : childKey , ( Map < ? , ? > ) childValue , lineage , debug ) ; MST[rv.ROR5Mutator]MSP[] } else {
out . println ( debug ? lr_12 + map . getClass () . getName () : lr_13 ) ; MST[rv.UOI3Mutator]MSP[] }
for ( final Map . Entry < ? , ? > entry : map . entrySet () ) { MST[NonVoidMethodCallMutator]MSP[] final Object childKey = entry . getKey () ; final Object childValue = entry . getValue () ;
if ( sub == null || sub . length < 2 ) { throw new IllegalArgumentException ( lr_4 + i ) ; } map . put ( ( K ) sub [ 0 ] , ( V ) sub [ 1 ] ) ; MST[ArgumentPropagationMutator]MSP[] } } else {
final Number answer = getNumber ( map , key ) ; if ( answer == null ) { return null ; MST[ReturnValsMutator]MSP[] } if ( answer instanceof Byte ) { return ( Byte ) answer ; } return Byte . valueOf ( answer . byteValue () ) ; }
public static < K , V > V getObject ( final Map < K , V > map , final K key , final V defaultValue ) { if ( map != null ) { final V answer = map . get ( key ) ; MST[NonVoidMethodCallMutator]MSP[]
public static < K > Number getNumber ( final Map < ? super K , ? > map , final K key , final Number defaultValue ) { return applyDefaultValue ( map , key , MapUtils :: getNumber , defaultValue ) ; MST[NonVoidMethodCallMutator]MSP[] }
out . print ( lr_10 + ( lineage . size () - 1 - lineageIndex - 1 ) + lr_11 ) ; MST[rv.AOD1Mutator]MSP[] } if ( debug && childValue != null ) { out . print ( ' ' ) ;
final Object answer = map . get ( key ) ; if ( answer != null ) { if ( answer instanceof Number ) { return ( Number ) answer ; } if ( answer instanceof String ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] try { final String text = ( String ) answer ;
public static boolean isNotEmpty ( final Map < ? , ? > map ) { return ! MapUtils . isEmpty ( map ) ; MST[rv.ROR2Mutator]MSP[] } public static < K , V > IterableMap < K , V > iterableMap ( final Map < K , V > map ) {
if ( map != null ) { final Object answer = map . get ( key ) ; MST[ArgumentPropagationMutator]MSP[] if ( answer != null && answer instanceof Map ) { return ( Map < ? , ? > ) answer ; } } return null ; }
out . put ( entry . getValue () , entry . getKey () ) ; MST[NonVoidMethodCallMutator]MSP[] } return out ; } public static boolean isEmpty ( final Map < ? , ? > map ) { return map == null || map . isEmpty () ; }
for ( int i = 0 ; i < array . length - 1 ; ) { MST[rv.CRCR6Mutator]MSP[] map . put ( ( K ) array [ i ++ ] , ( V ) array [ i ++ ] ) ; } } return map ; }
populateMap ( map , elements , keyTransformer , TransformerUtils . <V > nopTransformer () ) ; MST[NonVoidMethodCallMutator]MSP[] } public static < K , V , E > void populateMap ( final MultiMap < K , V > map , final Iterable < ? extends E > elements ,
if ( answer != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return answer ; } } return defaultValue ; } public static < K > Short getShort ( final Map < ? super K , ? > map , final K key ) {
Objects . requireNonNull ( map , lr_1 ) ; return map instanceof IterableMap ? ( IterableMap < K , V > ) map : new AbstractMapDecorator < K , V > ( map ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] } ; }
final Number answer = getNumber ( map , key ) ; if ( answer == null ) { return null ; } if ( answer instanceof Float ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return ( Float ) answer ; } return Float . valueOf ( answer . floatValue () ) ; }
return NumberFormat . getInstance () . parse ( text ) ; MST[NullReturnValsMutator]MSP[] } catch ( final ParseException e ) { } } } } return null ; } public static < K > Number getNumber ( final Map < ? super K , ? > map , final K key ,
public static < K > Boolean getBoolean ( final Map < ? super K , ? > map , final K key , final Function < K , Boolean > defaultFunction ) { return applyDefaultFunction ( map , key , MapUtils :: getBoolean , defaultFunction ) ; MST[BooleanTrueReturnValsMutator]MSP[] }
final Number answer = getNumber ( map , key ) ; if ( answer == null ) { return null ; } if ( answer instanceof Double ) { MST[rv.ROR5Mutator]MSP[] return ( Double ) answer ; } return Double . valueOf ( answer . doubleValue () ) ; }
if ( map != null ) { final Object answer = map . get ( key ) ; if ( answer != null && answer instanceof Map ) { MST[rv.ROR1Mutator]MSP[] return ( Map < ? , ? > ) answer ; } } return null ; }
return applyDefaultValue ( map , key , MapUtils :: getMap , defaultValue ) ; } public static < K > Number getNumber ( final Map < ? super K , ? > map , final K key ) { if ( map != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
for ( final Object element : array ) { final KeyValue < K , V > keyval = ( KeyValue < K , V > ) element ; map . put ( keyval . getKey () , keyval . getValue () ) ; MST[NonVoidMethodCallMutator]MSP[] }
out . println ( debug ? lr_12 + map . getClass () . getName () : lr_13 ) ; MST[NonVoidMethodCallMutator]MSP[] }
public static < K > boolean getBooleanValue ( final Map < ? super K , ? > map , final K key ) { return Boolean . TRUE . equals ( getBoolean ( map , key ) ) ; MST[NonVoidMethodCallMutator]MSP[] }
public static < K > void safeAddToMap ( final Map < ? super K , Object > map , final K key , final Object value ) throws NullPointerException { map . put ( key , value == null ? lr_5 : value ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] }
final Enumeration < String > enumeration = resourceBundle . getKeys () ; final Map < String , Object > map = new HashMap <> () ; while ( enumeration . hasMoreElements () ) { MST[rv.ROR5Mutator]MSP[] final String key = enumeration . nextElement () ;
public static < K > double getDoubleValue ( final Map < ? super K , ? > map , final K key , final double defaultValue ) { return applyDefaultValue ( map , key , MapUtils :: getDouble , defaultValue ) . doubleValue () ; MST[ArgumentPropagationMutator]MSP[] }
out . put ( entry . getValue () , entry . getKey () ) ; } return out ; MST[NullReturnValsMutator]MSP[] } public static boolean isEmpty ( final Map < ? , ? > map ) { return map == null || map . isEmpty () ; }
for ( int i = 0 ; i < array . length - 1 ; ) { MST[rv.AOR2Mutator]MSP[] map . put ( ( K ) array [ i ++ ] , ( V ) array [ i ++ ] ) ; } } return map ; }
out . print ( childValue ) ; } else if ( lineage . size () - 1 == lineageIndex ) { MST[rv.AOR1Mutator]MSP[] out . print ( lr_9 ) ; } else {
return applyDefaultFunction ( map , key , MapUtils :: getLong , defaultFunction , 0L ) . byteValue () ; MST[InlineConstantMutator]MSP[] } public static < K > long getLongValue ( final Map < ? super K , ? > map , final K key , final long defaultValue ) {
if ( answer instanceof Boolean ) { return ( Boolean ) answer ; } if ( answer instanceof String ) { return Boolean . valueOf ( ( String ) answer ) ; MST[BooleanTrueReturnValsMutator]MSP[] } if ( answer instanceof Number ) { final Number n = ( Number ) answer ;
return n . intValue () != 0 ? Boolean . TRUE : Boolean . FALSE ; MST[rv.ROR2Mutator]MSP[] } } } return null ; }
out . println ( childValue . getClass () . getName () ) ; } else { out . println () ; MST[VoidMethodCallMutator]MSP[] } } } lineage . removeLast () ; printIndent ( out , lineage . size () ) ;
public static < K > Short getShort ( final Map < ? super K , ? > map , final K key , final Short defaultValue ) { return applyDefaultValue ( map , key , MapUtils :: getShort , defaultValue ) ; MST[ArgumentPropagationMutator]MSP[] }
return applyDefaultFunction ( map , key , MapUtils :: getByte , defaultFunction , ( byte ) 0 ) . byteValue () ; MST[rv.CRCR3Mutator]MSP[] } public static < K > Double getDouble ( final Map < ? super K , ? > map , final K key ) {
return applyDefaultFunction ( map , key , MapUtils :: getByte , defaultFunction , ( byte ) 0 ) . byteValue () ; MST[rv.CRCR5Mutator]MSP[] } public static < K > Double getDouble ( final Map < ? super K , ? > map , final K key ) {
out . print ( childValue ) ; } else if ( lineage . size () - 1 == lineageIndex ) { MST[InlineConstantMutator]MSP[] out . print ( lr_9 ) ; } else {
public static < K > Boolean getBoolean ( final Map < ? super K , ? > map , final K key ) { if ( map != null ) { final Object answer = map . get ( key ) ; if ( answer != null ) { MST[NegateConditionalsMutator]MSP[]
return applyDefaultFunction ( map , key , MapUtils :: getFloat , defaultFunction , 0f ) . floatValue () ; MST[rv.CRCR6Mutator]MSP[] } public static < K > Integer getInteger ( final Map < ? super K , ? > map , final K key ) {
public static < K > boolean getBooleanValue ( final Map < ? super K , ? > map , final K key , final boolean defaultValue ) { return applyDefaultValue ( map , key , MapUtils :: getBoolean , defaultValue ) . booleanValue () ; MST[ReturnValsMutator]MSP[] }
final Iterator < ? extends E > iter = elements . iterator () ; while ( iter . hasNext () ) { final E temp = iter . next () ; map . put ( keyTransformer . transform ( temp ) , valueTransformer . transform ( temp ) ) ; MST[NonVoidMethodCallMutator]MSP[]
out . print ( lr_10 + ( lineage . size () - 1 - lineageIndex - 1 ) + lr_11 ) ; MST[rv.AOR3Mutator]MSP[] } if ( debug && childValue != null ) { out . print ( ' ' ) ;
for ( int i = 0 ; i < array . length - 1 ; ) { MST[rv.AOR4Mutator]MSP[] map . put ( ( K ) array [ i ++ ] , ( V ) array [ i ++ ] ) ; } } return map ; }
public static < K > Long getLong ( final Map < ? super K , ? > map , final K key , final Long defaultValue ) { return applyDefaultValue ( map , key , MapUtils :: getLong , defaultValue ) ; MST[ReturnValsMutator]MSP[] }
return answer . toString () ; MST[EmptyObjectReturnValsMutator]MSP[] } } return null ; } public static < K > String getString ( final Map < ? super K , ? > map , final K key , final Function < K , String > defaultFunction ) {
public static < K > Long getLong ( final Map < ? super K , ? > map , final K key , final Long defaultValue ) { return applyDefaultValue ( map , key , MapUtils :: getLong , defaultValue ) ; MST[ArgumentPropagationMutator]MSP[] }
public static < K > double getDoubleValue ( final Map < ? super K , ? > map , final K key ) { return applyDefaultValue ( map , key , MapUtils :: getDouble , 0d ) . doubleValue () ; MST[ArgumentPropagationMutator]MSP[] }
printIndent ( out , lineage . size () ) ; out . print ( childKey ) ; out . print ( lr_6 ) ; final int lineageIndex = IterableUtils . indexOf ( lineage , PredicateUtils . equalPredicate ( childValue ) ) ; if ( lineageIndex == - 1 ) { MST[rv.ROR4Mutator]MSP[]
return applyDefaultValue ( map , key , MapUtils :: getInteger , defaultValue ) . intValue () ; MST[NonVoidMethodCallMutator]MSP[] } public static < K > Long getLong ( final Map < ? super K , ? > map , final K key ) {
public static < K , V > IterableSortedMap < K , V > iterableSortedMap ( final SortedMap < K , V > sortedMap ) { Objects . requireNonNull ( sortedMap , lr_2 ) ; return sortedMap instanceof IterableSortedMap ? ( IterableSortedMap < K , V > ) sortedMap MST[rv.ROR1Mutator]MSP[]
public static < K > boolean getBooleanValue ( final Map < ? super K , ? > map , final K key , final boolean defaultValue ) { return applyDefaultValue ( map , key , MapUtils :: getBoolean , defaultValue ) . booleanValue () ; MST[BooleanTrueReturnValsMutator]MSP[] }
verbosePrintInternal ( out , label , map , new ArrayDeque < Map < ? , ? > > () , true ) ; MST[ConstructorCallMutator]MSP[] } public static < K , V > Map < K , V > emptyIfNull ( final Map < K , V > map ) {
for ( int i = 0 ; i < array . length - 1 ; ) { map . put ( ( K ) array [ i ++ ] , ( V ) array [ i ++ ] ) ; MST[rv.UOI2Mutator]MSP[] } } return map ; }
public static < K > float getFloatValue ( final Map < ? super K , ? > map , final K key , final float defaultValue ) { return applyDefaultValue ( map , key , MapUtils :: getFloat , defaultValue ) . floatValue () ; MST[ArgumentPropagationMutator]MSP[] }
if ( sub == null || sub . length < 2 ) { throw new IllegalArgumentException ( lr_4 + i ) ; } map . put ( ( K ) sub [ 0 ] , ( V ) sub [ 1 ] ) ; MST[rv.CRCR4Mutator]MSP[] } } else {
if ( sub == null || sub . length < 2 ) { MST[rv.ROR1Mutator]MSP[] throw new IllegalArgumentException ( lr_4 + i ) ; } map . put ( ( K ) sub [ 0 ] , ( V ) sub [ 1 ] ) ; } } else {
public static int size ( final Map < ? , ? > map ) { return map == null ? 0 : map . size () ; MST[InlineConstantMutator]MSP[] }
return applyDefaultValue ( map , key , MapUtils :: getString , defaultValue ) ; MST[EmptyObjectReturnValsMutator]MSP[] } public static < K , V > Map < V , K > invertMap ( final Map < K , V > map ) {
for ( int i = 0 ; i < indent ; i ++ ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] out . print ( INDENT_STRING ) ; } } @SuppressWarnings ( lr_3 )
public static < K > double getDoubleValue ( final Map < ? super K , ? > map , final K key ) { return applyDefaultValue ( map , key , MapUtils :: getDouble , 0d ) . doubleValue () ; MST[PrimitiveReturnsMutator]MSP[] }
out . print ( lr_10 + ( lineage . size () - 1 - lineageIndex - 1 ) + lr_11 ) ; MST[NonVoidMethodCallMutator]MSP[] } if ( debug && childValue != null ) { out . print ( ' ' ) ;
R value = map != null && getFunction != null ? getFunction . apply ( map , key ) : null ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] if ( value == null ) { value = defaultFunction != null ? defaultFunction . apply ( key ) : null ; }
if ( map == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] if ( label != null ) { out . print ( label ) ; out . print ( lr_6 ) ; } out . println ( lr_7 ) ; return; } if ( label != null ) {
final Transformer < E , K > keyTransformer , final Transformer < E , V > valueTransformer ) { final Iterator < ? extends E > iter = elements . iterator () ; while ( iter . hasNext () ) { MST[rv.ROR5Mutator]MSP[] final E temp = iter . next () ;
final Object answer = map . get ( key ) ; if ( answer != null ) { if ( answer instanceof Number ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return ( Number ) answer ; } if ( answer instanceof String ) { try { final String text = ( String ) answer ;
return applyDefaultFunction ( map , key , MapUtils :: getFloat , defaultFunction , 0f ) . floatValue () ; MST[ReturnValsMutator]MSP[] } public static < K > Integer getInteger ( final Map < ? super K , ? > map , final K key ) {
final Number answer = getNumber ( map , key ) ; if ( answer == null ) { return null ; } if ( answer instanceof Byte ) { MST[rv.ROR4Mutator]MSP[] return ( Byte ) answer ; } return Byte . valueOf ( answer . byteValue () ) ; }
final Number answer = getNumber ( map , key ) ; if ( answer == null ) { return null ; } if ( answer instanceof Float ) { return ( Float ) answer ; } return Float . valueOf ( answer . floatValue () ) ; MST[NonVoidMethodCallMutator]MSP[] }
} else if ( obj instanceof Object [] ) { MST[rv.ROR3Mutator]MSP[] for ( int i = 0 ; i < array . length ; i ++ ) { final Object [] sub = ( Object [] ) array [ i ] ;
final Object key = entry . getKey () ; final Object value = entry . getValue () ; MST[NonVoidMethodCallMutator]MSP[] answer . put ( key , value ) ; } } return answer ; }
public static void verbosePrint ( final PrintStream out , final Object label , final Map < ? , ? > map ) { verbosePrintInternal ( out , label , map , new ArrayDeque < Map < ? , ? > > () , false ) ; MST[ConstructorCallMutator]MSP[] }
out . print ( lr_10 + ( lineage . size () - 1 - lineageIndex - 1 ) + lr_11 ) ; MST[rv.AOD1Mutator]MSP[] } if ( debug && childValue != null ) { out . print ( ' ' ) ;
final Object answer = map . get ( key ) ; if ( answer != null ) { MST[rv.ROR5Mutator]MSP[] if ( answer instanceof Number ) { return ( Number ) answer ; } if ( answer instanceof String ) { try { final String text = ( String ) answer ;
final Number answer = getNumber ( map , key ) ; if ( answer == null ) { return null ; } if ( answer instanceof Byte ) { return ( Byte ) answer ; MST[NullReturnValsMutator]MSP[] } return Byte . valueOf ( answer . byteValue () ) ; }
} else if ( obj instanceof Object [] ) { for ( int i = 0 ; i < array . length ; i ++ ) { MST[rv.CRCR3Mutator]MSP[] final Object [] sub = ( Object [] ) array [ i ] ;
if ( childValue instanceof Map && ! lineage . contains ( childValue ) ) { verbosePrintInternal ( out , childKey == null ? lr_7 : childKey , ( Map < ? , ? > ) childValue , lineage , debug ) ; MST[VoidMethodCallMutator]MSP[] } else {
return answer . toString () ; MST[NonVoidMethodCallMutator]MSP[] } } return null ; } public static < K > String getString ( final Map < ? super K , ? > map , final K key , final Function < K , String > defaultFunction ) {
R value = map != null && getFunction != null ? getFunction . apply ( map , key ) : null ; if ( value == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] value = defaultFunction != null ? defaultFunction . apply ( key ) : null ; }
public static < K > float getFloatValue ( final Map < ? super K , ? > map , final K key , final float defaultValue ) { return applyDefaultValue ( map , key , MapUtils :: getFloat , defaultValue ) . floatValue () ; MST[NonVoidMethodCallMutator]MSP[] }
public static < K > boolean getBooleanValue ( final Map < ? super K , ? > map , final K key , final boolean defaultValue ) { return applyDefaultValue ( map , key , MapUtils :: getBoolean , defaultValue ) . booleanValue () ; MST[rv.UOI4Mutator]MSP[] }
public static < K , V > V getObject ( final Map < ? super K , V > map , final K key ) { if ( map != null ) { return map . get ( key ) ; MST[NullReturnValsMutator]MSP[] } return null ; }
public static < K > Boolean getBoolean ( final Map < ? super K , ? > map , final K key ) { if ( map != null ) { final Object answer = map . get ( key ) ; if ( answer != null ) { MST[rv.ROR5Mutator]MSP[]
return applyDefaultFunction ( map , key , MapUtils :: getBoolean , defaultFunction , false ) . booleanValue () ; MST[ArgumentPropagationMutator]MSP[] } public static < K > Byte getByte ( final Map < ? super K , ? > map , final K key ) {
out . println ( debug ? lr_12 + map . getClass () . getName () : lr_13 ) ; MST[NonVoidMethodCallMutator]MSP[] }
out . print ( lr_10 + ( lineage . size () - 1 - lineageIndex - 1 ) + lr_11 ) ; } if ( debug && childValue != null ) { MST[NegateConditionalsMutator]MSP[] out . print ( ' ' ) ;
for ( final Object element : array ) { MST[rv.UOI2Mutator]MSP[] final KeyValue < K , V > keyval = ( KeyValue < K , V > ) element ; map . put ( keyval . getKey () , keyval . getValue () ) ; }
public static < K > void safeAddToMap ( final Map < ? super K , Object > map , final K key , final Object value ) throws NullPointerException { map . put ( key , value == null ? lr_5 : value ) ; MST[NegateConditionalsMutator]MSP[] }
return applyDefaultFunction ( map , key , MapUtils :: getLong , defaultFunction , 0L ) . byteValue () ; MST[NonVoidMethodCallMutator]MSP[] } public static < K > long getLongValue ( final Map < ? super K , ? > map , final K key , final long defaultValue ) {
public static < K > Integer getInteger ( final Map < ? super K , ? > map , final K key , final Function < K , Integer > defaultFunction ) { return applyDefaultFunction ( map , key , MapUtils :: getInteger , defaultFunction ) ; MST[ArgumentPropagationMutator]MSP[] }
} else if ( obj instanceof Object [] ) { for ( int i = 0 ; i < array . length ; i ++ ) { MST[rv.UOI4Mutator]MSP[] final Object [] sub = ( Object [] ) array [ i ] ;
if ( array == null || array . length == 0 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return map ; } final Object obj = array [ 0 ] ; if ( obj instanceof Map . Entry ) { for ( final Object element : array ) {
public static < K > double getDoubleValue ( final Map < ? super K , ? > map , final K key , final double defaultValue ) { return applyDefaultValue ( map , key , MapUtils :: getDouble , defaultValue ) . doubleValue () ; MST[rv.UOI3Mutator]MSP[] }
public static < K > short getShortValue ( final Map < ? super K , ? > map , final K key ) { return applyDefaultValue ( map , key , MapUtils :: getShort , 0 ) . shortValue () ; MST[InlineConstantMutator]MSP[] }
for ( int i = 0 ; i < array . length - 1 ; ) { MST[rv.UOI3Mutator]MSP[] map . put ( ( K ) array [ i ++ ] , ( V ) array [ i ++ ] ) ; } } return map ; }
if ( childValue instanceof Map && ! lineage . contains ( childValue ) ) { verbosePrintInternal ( out , childKey == null ? lr_7 : childKey , ( Map < ? , ? > ) childValue , lineage , debug ) ; MST[rv.UOI3Mutator]MSP[] } else {
public static boolean isNotEmpty ( final Map < ? , ? > map ) { return ! MapUtils . isEmpty ( map ) ; MST[InlineConstantMutator]MSP[] } public static < K , V > IterableMap < K , V > iterableMap ( final Map < K , V > map ) {
final Number answer = getNumber ( map , key ) ; if ( answer == null ) { return null ; } if ( answer instanceof Float ) { MST[rv.ROR2Mutator]MSP[] return ( Float ) answer ; } return Float . valueOf ( answer . floatValue () ) ; }
public static < K > Integer getInteger ( final Map < ? super K , ? > map , final K key , final Integer defaultValue ) { return applyDefaultValue ( map , key , MapUtils :: getInteger , defaultValue ) ; MST[ReturnValsMutator]MSP[] }
if ( answer instanceof Boolean ) { return ( Boolean ) answer ; } if ( answer instanceof String ) { MST[rv.ROR4Mutator]MSP[] return Boolean . valueOf ( ( String ) answer ) ; } if ( answer instanceof Number ) { final Number n = ( Number ) answer ;
if ( array == null || array . length == 0 ) { return map ; } final Object obj = array [ 0 ] ; if ( obj instanceof Map . Entry ) { for ( final Object element : array ) { MST[rv.UOI2Mutator]MSP[]
if ( childValue instanceof Map && ! lineage . contains ( childValue ) ) { MST[rv.ROR4Mutator]MSP[] verbosePrintInternal ( out , childKey == null ? lr_7 : childKey , ( Map < ? , ? > ) childValue , lineage , debug ) ; } else {
if ( array == null || array . length == 0 ) { return map ; } final Object obj = array [ 0 ] ; if ( obj instanceof Map . Entry ) { for ( final Object element : array ) { MST[rv.UOI4Mutator]MSP[]
out . print ( lr_10 + ( lineage . size () - 1 - lineageIndex - 1 ) + lr_11 ) ; MST[rv.CRCR4Mutator]MSP[] } if ( debug && childValue != null ) { out . print ( ' ' ) ;
if ( answer instanceof Boolean ) { return ( Boolean ) answer ; } if ( answer instanceof String ) { return Boolean . valueOf ( ( String ) answer ) ; } if ( answer instanceof Number ) { MST[rv.ROR3Mutator]MSP[] final Number n = ( Number ) answer ;
out . print ( childValue ) ; } else if ( lineage . size () - 1 == lineageIndex ) { MST[rv.UOI1Mutator]MSP[] out . print ( lr_9 ) ; } else {
public static < K > Boolean getBoolean ( final Map < ? super K , ? > map , final K key , final Boolean defaultValue ) { return applyDefaultValue ( map , key , MapUtils :: getBoolean , defaultValue ) ; MST[ArgumentPropagationMutator]MSP[] }
public static < K > double getDoubleValue ( final Map < ? super K , ? > map , final K key ) { return applyDefaultValue ( map , key , MapUtils :: getDouble , 0d ) . doubleValue () ; MST[InlineConstantMutator]MSP[] }
if ( map != null ) { final Object answer = map . get ( key ) ; if ( answer != null && answer instanceof Map ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return ( Map < ? , ? > ) answer ; } } return null ; }
return LazyMap . lazyMap ( map , factory ) ; MST[NullReturnValsMutator]MSP[] } public static < K , V > IterableMap < K , V > lazyMap ( final Map < K , V > map , final Transformer < ? super K , ? extends V > transformerFactory ) {
public static < K > float getFloatValue ( final Map < ? super K , ? > map , final K key , final float defaultValue ) { return applyDefaultValue ( map , key , MapUtils :: getFloat , defaultValue ) . floatValue () ; MST[rv.UOI3Mutator]MSP[] }
if ( childValue instanceof Map && ! lineage . contains ( childValue ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] verbosePrintInternal ( out , childKey == null ? lr_7 : childKey , ( Map < ? , ? > ) childValue , lineage , debug ) ; } else {
return value != null ? value : defaultValue ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] } private static < K , R > R applyDefaultValue ( final Map < ? super K , ? > map , final K key ,
final Number answer = getNumber ( map , key ) ; if ( answer == null ) { return null ; } if ( answer instanceof Byte ) { return ( Byte ) answer ; MST[ReturnValsMutator]MSP[] } return Byte . valueOf ( answer . byteValue () ) ; }
printIndent ( out , lineage . size () ) ; out . print ( childKey ) ; out . print ( lr_6 ) ; final int lineageIndex = IterableUtils . indexOf ( lineage , PredicateUtils . equalPredicate ( childValue ) ) ; if ( lineageIndex == - 1 ) { MST[rv.UOI2Mutator]MSP[]
if ( array == null || array . length == 0 ) { MST[rv.ROR5Mutator]MSP[] return map ; } final Object obj = array [ 0 ] ; if ( obj instanceof Map . Entry ) { for ( final Object element : array ) {
out . print ( lr_10 + ( lineage . size () - 1 - lineageIndex - 1 ) + lr_11 ) ; MST[rv.AOR3Mutator]MSP[] } if ( debug && childValue != null ) { out . print ( ' ' ) ;
if ( answer != null ) { MST[rv.ROR5Mutator]MSP[] return answer ; } } return defaultValue ; } public static < K > Short getShort ( final Map < ? super K , ? > map , final K key ) {
final Object answer = map . get ( key ) ; if ( answer != null ) { MST[NegateConditionalsMutator]MSP[] if ( answer instanceof Number ) { return ( Number ) answer ; } if ( answer instanceof String ) { try { final String text = ( String ) answer ;
out . put ( entry . getValue () , entry . getKey () ) ; } return out ; } public static boolean isEmpty ( final Map < ? , ? > map ) { return map == null || map . isEmpty () ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] }
final Number answer = getNumber ( map , key ) ; if ( answer == null ) { return null ; MST[EmptyObjectReturnValsMutator]MSP[] } if ( answer instanceof Float ) { return ( Float ) answer ; } return Float . valueOf ( answer . floatValue () ) ; }
final Iterator < ? extends E > iter = elements . iterator () ; while ( iter . hasNext () ) { MST[rv.ROR4Mutator]MSP[] final E temp = iter . next () ; map . put ( keyTransformer . transform ( temp ) , valueTransformer . transform ( temp ) ) ;
out . print ( lr_10 + ( lineage . size () - 1 - lineageIndex - 1 ) + lr_11 ) ; } if ( debug && childValue != null ) { MST[rv.ROR5Mutator]MSP[] out . print ( ' ' ) ;
public static < K > byte getByteValue ( final Map < ? super K , ? > map , final K key , final byte defaultValue ) { return applyDefaultValue ( map , key , MapUtils :: getByte , defaultValue ) . byteValue () ; MST[rv.ABSMutator]MSP[] }
final Map . Entry < K , V > entry = ( Map . Entry < K , V > ) element ; map . put ( entry . getKey () , entry . getValue () ) ; MST[ArgumentPropagationMutator]MSP[] } } else if ( obj instanceof KeyValue ) {
if ( map == null ) { if ( label != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] out . print ( label ) ; out . print ( lr_6 ) ; } out . println ( lr_7 ) ; return; } if ( label != null ) {
out . print ( lr_10 + ( lineage . size () - 1 - lineageIndex - 1 ) + lr_11 ) ; MST[NonVoidMethodCallMutator]MSP[] } if ( debug && childValue != null ) { out . print ( ' ' ) ;
if ( array == null || array . length == 0 ) { return map ; } final Object obj = array [ 0 ] ; if ( obj instanceof Map . Entry ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] for ( final Object element : array ) {
return applyDefaultFunction ( map , key , MapUtils :: getInteger , defaultFunction , 0 ) . byteValue () ; MST[rv.CRCR1Mutator]MSP[] } public static < K > int getIntValue ( final Map < ? super K , ? > map , final K key , final int defaultValue ) {
return applyDefaultValue ( map , key , MapUtils :: getLong , defaultValue ) . longValue () ; MST[rv.UOI4Mutator]MSP[] } public static < K > Map < ? , ? > getMap ( final Map < ? super K , ? > map , final K key ) {
public static < K , V > IterableSortedMap < K , V > iterableSortedMap ( final SortedMap < K , V > sortedMap ) { Objects . requireNonNull ( sortedMap , lr_2 ) ; MST[NonVoidMethodCallMutator]MSP[] return sortedMap instanceof IterableSortedMap ? ( IterableSortedMap < K , V > ) sortedMap
public static < K > Short getShort ( final Map < ? super K , ? > map , final K key , final Short defaultValue ) { return applyDefaultValue ( map , key , MapUtils :: getShort , defaultValue ) ; MST[ReturnValsMutator]MSP[] }
out . print ( lr_10 + ( lineage . size () - 1 - lineageIndex - 1 ) + lr_11 ) ; } if ( debug && childValue != null ) { MST[rv.UOI2Mutator]MSP[] out . print ( ' ' ) ;
out . print ( childValue ) ; } else if ( lineage . size () - 1 == lineageIndex ) { MST[rv.CRCR2Mutator]MSP[] out . print ( lr_9 ) ; } else {
public static < K , V > V getObject ( final Map < ? super K , V > map , final K key ) { if ( map != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return map . get ( key ) ; } return null ; }
if ( array == null || array . length == 0 ) { return map ; } final Object obj = array [ 0 ] ; if ( obj instanceof Map . Entry ) { for ( final Object element : array ) { MST[rv.ABSMutator]MSP[]
R value = map != null && getFunction != null ? getFunction . apply ( map , key ) : null ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] if ( value == null ) { value = defaultFunction != null ? defaultFunction . apply ( key ) : null ; }
public static < K > Boolean getBoolean ( final Map < ? super K , ? > map , final K key , final Boolean defaultValue ) { return applyDefaultValue ( map , key , MapUtils :: getBoolean , defaultValue ) ; MST[ReturnValsMutator]MSP[] }
public static < K > Integer getInteger ( final Map < ? super K , ? > map , final K key , final Integer defaultValue ) { return applyDefaultValue ( map , key , MapUtils :: getInteger , defaultValue ) ; MST[ArgumentPropagationMutator]MSP[] }
Objects . requireNonNull ( map , lr_1 ) ; return map instanceof IterableMap ? ( IterableMap < K , V > ) map : new AbstractMapDecorator < K , V > ( map ) { MST[rv.ROR2Mutator]MSP[] } ; }
out . print ( lr_10 + ( lineage . size () - 1 - lineageIndex - 1 ) + lr_11 ) ; MST[rv.UOI3Mutator]MSP[] } if ( debug && childValue != null ) { out . print ( ' ' ) ;
if ( map != null ) { final Object answer = map . get ( key ) ; MST[NonVoidMethodCallMutator]MSP[] if ( answer != null && answer instanceof Map ) { return ( Map < ? , ? > ) answer ; } } return null ; }
public static < K > byte getByteValue ( final Map < ? super K , ? > map , final K key ) { return applyDefaultValue ( map , key , MapUtils :: getByte , 0 ) . byteValue () ; MST[PrimitiveReturnsMutator]MSP[] }
return applyDefaultValue ( map , key , MapUtils :: getInteger , defaultValue ) . intValue () ; MST[ArgumentPropagationMutator]MSP[] } public static < K > Long getLong ( final Map < ? super K , ? > map , final K key ) {
out . print ( childValue ) ; } else if ( lineage . size () - 1 == lineageIndex ) { MST[rv.ROR4Mutator]MSP[] out . print ( lr_9 ) ; } else {
public static < K > short getShortValue ( final Map < ? super K , ? > map , final K key ) { return applyDefaultValue ( map , key , MapUtils :: getShort , 0 ) . shortValue () ; MST[NonVoidMethodCallMutator]MSP[] }
public static boolean isNotEmpty ( final Map < ? , ? > map ) { return ! MapUtils . isEmpty ( map ) ; MST[BooleanTrueReturnValsMutator]MSP[] } public static < K , V > IterableMap < K , V > iterableMap ( final Map < K , V > map ) {
if ( array == null || array . length == 0 ) { return map ; } final Object obj = array [ 0 ] ; if ( obj instanceof Map . Entry ) { for ( final Object element : array ) { MST[rv.UOI3Mutator]MSP[]
for ( int i = 0 ; i < array . length - 1 ; ) { MST[rv.ROR1Mutator]MSP[] map . put ( ( K ) array [ i ++ ] , ( V ) array [ i ++ ] ) ; } } return map ; }
} else if ( obj instanceof Object [] ) { for ( int i = 0 ; i < array . length ; i ++ ) { MST[rv.ABSMutator]MSP[] final Object [] sub = ( Object [] ) array [ i ] ;
map . put ( keyTransformer . transform ( temp ) , valueTransformer . transform ( temp ) ) ; MST[NonVoidMethodCallMutator]MSP[] } } public static < K , V > void populateMap ( final MultiMap < K , V > map , final Iterable < ? extends V > elements ,
return applyDefaultFunction ( map , key , MapUtils :: getDouble , defaultFunction , 0d ) . doubleValue () ; MST[ArgumentPropagationMutator]MSP[] } public static < K > Float getFloat ( final Map < ? super K , ? > map , final K key ) {
return LazyMap . lazyMap ( map , factory ) ; MST[ReturnValsMutator]MSP[] } public static < K , V > IterableMap < K , V > lazyMap ( final Map < K , V > map , final Transformer < ? super K , ? extends V > transformerFactory ) {
final Number answer = getNumber ( map , key ) ; if ( answer == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return null ; } if ( answer instanceof Double ) { return ( Double ) answer ; } return Double . valueOf ( answer . doubleValue () ) ; }
public static < K > Integer getInteger ( final Map < ? super K , ? > map , final K key , final Function < K , Integer > defaultFunction ) { return applyDefaultFunction ( map , key , MapUtils :: getInteger , defaultFunction ) ; MST[ReturnValsMutator]MSP[] }
return applyDefaultFunction ( map , key , MapUtils :: getShort , defaultFunction , ( short ) 0 ) . shortValue () ; MST[ArgumentPropagationMutator]MSP[] }
public static < K , V > OrderedMap < K , V > orderedMap ( final Map < K , V > map ) { return ListOrderedMap . listOrderedMap ( map ) ; MST[ReturnValsMutator]MSP[] }
out . put ( entry . getValue () , entry . getKey () ) ; } return out ; } public static boolean isEmpty ( final Map < ? , ? > map ) { return map == null || map . isEmpty () ; MST[rv.ROR5Mutator]MSP[] }
if ( sub == null || sub . length < 2 ) { throw new IllegalArgumentException ( lr_4 + i ) ; } map . put ( ( K ) sub [ 0 ] , ( V ) sub [ 1 ] ) ; MST[NonVoidMethodCallMutator]MSP[] } } else {
public static < K , V > OrderedMap < K , V > orderedMap ( final Map < K , V > map ) { return ListOrderedMap . listOrderedMap ( map ) ; MST[NullReturnValsMutator]MSP[] }
public static < K > byte getByteValue ( final Map < ? super K , ? > map , final K key , final byte defaultValue ) { return applyDefaultValue ( map , key , MapUtils :: getByte , defaultValue ) . byteValue () ; MST[rv.UOI4Mutator]MSP[] }
final Number answer = getNumber ( map , key ) ; if ( answer == null ) { MST[NegateConditionalsMutator]MSP[] return null ; } if ( answer instanceof Long ) { return ( Long ) answer ; } return Long . valueOf ( answer . longValue () ) ; }
R value = map != null && getFunction != null ? getFunction . apply ( map , key ) : null ; MST[NonVoidMethodCallMutator]MSP[] if ( value == null ) { value = defaultFunction != null ? defaultFunction . apply ( key ) : null ; }
public static < K > byte getByteValue ( final Map < ? super K , ? > map , final K key ) { return applyDefaultValue ( map , key , MapUtils :: getByte , 0 ) . byteValue () ; MST[rv.CRCR3Mutator]MSP[] }
out . put ( entry . getValue () , entry . getKey () ) ; } return out ; } public static boolean isEmpty ( final Map < ? , ? > map ) { return map == null || map . isEmpty () ; MST[rv.CRCR6Mutator]MSP[] }
public static < K > short getShortValue ( final Map < ? super K , ? > map , final K key , final short defaultValue ) { return applyDefaultValue ( map , key , MapUtils :: getShort , defaultValue ) . shortValue () ; MST[rv.UOI1Mutator]MSP[] }
printIndent ( out , lineage . size () ) ; out . print ( childKey ) ; out . print ( lr_6 ) ; final int lineageIndex = IterableUtils . indexOf ( lineage , PredicateUtils . equalPredicate ( childValue ) ) ; if ( lineageIndex == - 1 ) { MST[InlineConstantMutator]MSP[]
final Number answer = getNumber ( map , key ) ; if ( answer == null ) { return null ; } if ( answer instanceof Double ) { return ( Double ) answer ; } return Double . valueOf ( answer . doubleValue () ) ; MST[NonVoidMethodCallMutator]MSP[] }
return applyDefaultValue ( map , key , MapUtils :: getLong , defaultValue ) . longValue () ; MST[rv.ABSMutator]MSP[] } public static < K > Map < ? , ? > getMap ( final Map < ? super K , ? > map , final K key ) {
public static < K > double getDoubleValue ( final Map < ? super K , ? > map , final K key ) { return applyDefaultValue ( map , key , MapUtils :: getDouble , 0d ) . doubleValue () ; MST[NonVoidMethodCallMutator]MSP[] }
final Number answer = getNumber ( map , key ) ; if ( answer == null ) { return null ; } if ( answer instanceof Long ) { MST[rv.ROR2Mutator]MSP[] return ( Long ) answer ; } return Long . valueOf ( answer . longValue () ) ; }
final Number answer = getNumber ( map , key ) ; if ( answer == null ) { return null ; } if ( answer instanceof Integer ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return ( Integer ) answer ; } return Integer . valueOf ( answer . intValue () ) ; }
if ( sub == null || sub . length < 2 ) { throw new IllegalArgumentException ( lr_4 + i ) ; } map . put ( ( K ) sub [ 0 ] , ( V ) sub [ 1 ] ) ; MST[rv.CRCR3Mutator]MSP[] } } else {
out . print ( lr_10 + ( lineage . size () - 1 - lineageIndex - 1 ) + lr_11 ) ; } if ( debug && childValue != null ) { MST[NegateConditionalsMutator]MSP[] out . print ( ' ' ) ;
final BiFunction < Map < ? super K , ? > , K , R > getFunction , final Function < K , R > defaultFunction ) { return applyDefaultFunction ( map , key , getFunction , defaultFunction , null ) ; MST[ArgumentPropagationMutator]MSP[] }
public static < K > boolean getBooleanValue ( final Map < ? super K , ? > map , final K key ) { return Boolean . TRUE . equals ( getBoolean ( map , key ) ) ; MST[BooleanFalseReturnValsMutator]MSP[] }
public static < K > byte getByteValue ( final Map < ? super K , ? > map , final K key ) { return applyDefaultValue ( map , key , MapUtils :: getByte , 0 ) . byteValue () ; MST[NonVoidMethodCallMutator]MSP[] }
out . println ( debug ? lr_12 + map . getClass () . getName () : lr_13 ) ; MST[NonVoidMethodCallMutator]MSP[] }
return applyDefaultValue ( map , key , MapUtils :: getInteger , defaultValue ) . intValue () ; MST[rv.UOI3Mutator]MSP[] } public static < K > Long getLong ( final Map < ? super K , ? > map , final K key ) {
final Number answer = getNumber ( map , key ) ; if ( answer == null ) { MST[NegateConditionalsMutator]MSP[] return null ; } if ( answer instanceof Float ) { return ( Float ) answer ; } return Float . valueOf ( answer . floatValue () ) ; }
return LazyMap . lazyMap ( map , transformerFactory ) ; MST[NullReturnValsMutator]MSP[] } public static < K , V > SortedMap < K , V > lazySortedMap ( final SortedMap < K , V > map , final Factory < ? extends V > factory ) {
public static boolean isNotEmpty ( final Map < ? , ? > map ) { return ! MapUtils . isEmpty ( map ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] } public static < K , V > IterableMap < K , V > iterableMap ( final Map < K , V > map ) {
out . print ( label ) ; out . println ( lr_6 ) ; } printIndent ( out , lineage . size () ) ; out . println ( lr_8 ) ; lineage . addLast ( map ) ; MST[VoidMethodCallMutator]MSP[]
public static < K , V > V getObject ( final Map < ? super K , V > map , final K key ) { if ( map != null ) { return map . get ( key ) ; MST[ReturnValsMutator]MSP[] } return null ; }
return applyDefaultFunction ( map , key , MapUtils :: getShort , defaultFunction , ( short ) 0 ) . shortValue () ; MST[InlineConstantMutator]MSP[] }
out . put ( entry . getValue () , entry . getKey () ) ; } return out ; } public static boolean isEmpty ( final Map < ? , ? > map ) { return map == null || map . isEmpty () ; MST[NegateConditionalsMutator]MSP[] }
final Enumeration < String > enumeration = resourceBundle . getKeys () ; final Map < String , Object > map = new HashMap <> () ; while ( enumeration . hasMoreElements () ) { MST[rv.ROR4Mutator]MSP[] final String key = enumeration . nextElement () ;
for ( int i = 0 ; i < indent ; i ++ ) { MST[rv.UOI2Mutator]MSP[] out . print ( INDENT_STRING ) ; } } @SuppressWarnings ( lr_3 )
return applyDefaultValue ( map , key , MapUtils :: getMap , defaultValue ) ; MST[ArgumentPropagationMutator]MSP[] } public static < K > Number getNumber ( final Map < ? super K , ? > map , final K key ) { if ( map != null ) {
public static < K > Byte getByte ( final Map < ? super K , ? > map , final K key , final Function < K , Byte > defaultFunction ) { return applyDefaultFunction ( map , key , MapUtils :: getByte , defaultFunction ) ; MST[ReturnValsMutator]MSP[] }
final Iterator < ? extends E > iter = elements . iterator () ; while ( iter . hasNext () ) { final E temp = iter . next () ; map . put ( keyTransformer . transform ( temp ) , valueTransformer . transform ( temp ) ) ; MST[ArgumentPropagationMutator]MSP[]
if ( map != null ) { final Object answer = map . get ( key ) ; if ( answer != null && answer instanceof Map ) { MST[rv.ROR2Mutator]MSP[] return ( Map < ? , ? > ) answer ; } } return null ; }
final Map . Entry < K , V > entry = ( Map . Entry < K , V > ) element ; map . put ( entry . getKey () , entry . getValue () ) ; } } else if ( obj instanceof KeyValue ) { MST[NegateConditionalsMutator]MSP[]
final Number answer = getNumber ( map , key ) ; if ( answer == null ) { return null ; } if ( answer instanceof Short ) { MST[rv.ROR1Mutator]MSP[] return ( Short ) answer ; } return Short . valueOf ( answer . shortValue () ) ; }
out . print ( childValue ) ; } else if ( lineage . size () - 1 == lineageIndex ) { MST[rv.AOR4Mutator]MSP[] out . print ( lr_9 ) ; } else {
final Number answer = getNumber ( map , key ) ; if ( answer == null ) { return null ; MST[EmptyObjectReturnValsMutator]MSP[] } if ( answer instanceof Short ) { return ( Short ) answer ; } return Short . valueOf ( answer . shortValue () ) ; }
out . println ( debug ? lr_12 + map . getClass () . getName () : lr_13 ) ; MST[rv.ABSMutator]MSP[] }
out . print ( lr_10 + ( lineage . size () - 1 - lineageIndex - 1 ) + lr_11 ) ; MST[experimental.NakedReceiverMutator]MSP[] } if ( debug && childValue != null ) { out . print ( ' ' ) ;
if ( answer instanceof Boolean ) { return ( Boolean ) answer ; MST[BooleanTrueReturnValsMutator]MSP[] } if ( answer instanceof String ) { return Boolean . valueOf ( ( String ) answer ) ; } if ( answer instanceof Number ) { final Number n = ( Number ) answer ;
R value = map != null && getFunction != null ? getFunction . apply ( map , key ) : null ; if ( value == null ) { value = defaultFunction != null ? defaultFunction . apply ( key ) : null ; MST[rv.ROR5Mutator]MSP[] }
return n . intValue () != 0 ? Boolean . TRUE : Boolean . FALSE ; MST[BooleanFalseReturnValsMutator]MSP[] } } } return null ; }
return applyDefaultFunction ( map , key , MapUtils :: getString , defaultFunction ) ; MST[EmptyObjectReturnValsMutator]MSP[] } public static < K > String getString ( final Map < ? super K , ? > map , final K key , final String defaultValue ) {
if ( sub == null || sub . length < 2 ) { throw new IllegalArgumentException ( lr_4 + i ) ; MST[ConstructorCallMutator]MSP[] } map . put ( ( K ) sub [ 0 ] , ( V ) sub [ 1 ] ) ; } } else {
final Number answer = getNumber ( map , key ) ; if ( answer == null ) { return null ; MST[EmptyObjectReturnValsMutator]MSP[] } if ( answer instanceof Long ) { return ( Long ) answer ; } return Long . valueOf ( answer . longValue () ) ; }
for ( int i = 0 ; i < indent ; i ++ ) { MST[rv.CRCR1Mutator]MSP[] out . print ( INDENT_STRING ) ; } } @SuppressWarnings ( lr_3 )
final Number answer = getNumber ( map , key ) ; if ( answer == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return null ; } if ( answer instanceof Byte ) { return ( Byte ) answer ; } return Byte . valueOf ( answer . byteValue () ) ; }
final Number answer = getNumber ( map , key ) ; if ( answer == null ) { return null ; MST[ReturnValsMutator]MSP[] } if ( answer instanceof Double ) { return ( Double ) answer ; } return Double . valueOf ( answer . doubleValue () ) ; }
out . print ( childValue ) ; } else if ( lineage . size () - 1 == lineageIndex ) { MST[MathMutator]MSP[] out . print ( lr_9 ) ; } else {
out . print ( lr_10 + ( lineage . size () - 1 - lineageIndex - 1 ) + lr_11 ) ; MST[rv.AOR1Mutator]MSP[] } if ( debug && childValue != null ) { out . print ( ' ' ) ;
final Number answer = getNumber ( map , key ) ; if ( answer == null ) { MST[rv.ROR5Mutator]MSP[] return null ; } if ( answer instanceof Float ) { return ( Float ) answer ; } return Float . valueOf ( answer . floatValue () ) ; }
public static < K > short getShortValue ( final Map < ? super K , ? > map , final K key , final short defaultValue ) { return applyDefaultValue ( map , key , MapUtils :: getShort , defaultValue ) . shortValue () ; MST[rv.UOI2Mutator]MSP[] }
if ( sub == null || sub . length < 2 ) { throw new IllegalArgumentException ( lr_4 + i ) ; } map . put ( ( K ) sub [ 0 ] , ( V ) sub [ 1 ] ) ; MST[InlineConstantMutator]MSP[] } } else {
if ( childValue instanceof Map && ! lineage . contains ( childValue ) ) { verbosePrintInternal ( out , childKey == null ? lr_7 : childKey , ( Map < ? , ? > ) childValue , lineage , debug ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] } else {
if ( childValue instanceof Map && ! lineage . contains ( childValue ) ) { MST[NegateConditionalsMutator]MSP[] verbosePrintInternal ( out , childKey == null ? lr_7 : childKey , ( Map < ? , ? > ) childValue , lineage , debug ) ; } else {
out . print ( label ) ; out . println ( lr_6 ) ; MST[VoidMethodCallMutator]MSP[] } printIndent ( out , lineage . size () ) ; out . println ( lr_8 ) ; lineage . addLast ( map ) ;
if ( answer instanceof Boolean ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return ( Boolean ) answer ; } if ( answer instanceof String ) { return Boolean . valueOf ( ( String ) answer ) ; } if ( answer instanceof Number ) { final Number n = ( Number ) answer ;
printIndent ( out , lineage . size () ) ; out . print ( childKey ) ; out . print ( lr_6 ) ; final int lineageIndex = IterableUtils . indexOf ( lineage , PredicateUtils . equalPredicate ( childValue ) ) ; if ( lineageIndex == - 1 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
public static < K > Long getLong ( final Map < ? super K , ? > map , final K key , final Function < K , Long > defaultFunction ) { return applyDefaultFunction ( map , key , MapUtils :: getLong , defaultFunction ) ; MST[ReturnValsMutator]MSP[] }
final Object answer = map . get ( key ) ; MST[NonVoidMethodCallMutator]MSP[] if ( answer != null ) { if ( answer instanceof Number ) { return ( Number ) answer ; } if ( answer instanceof String ) { try { final String text = ( String ) answer ;
if ( answer instanceof Boolean ) { MST[rv.ROR3Mutator]MSP[] return ( Boolean ) answer ; } if ( answer instanceof String ) { return Boolean . valueOf ( ( String ) answer ) ; } if ( answer instanceof Number ) { final Number n = ( Number ) answer ;
public static < K > short getShortValue ( final Map < ? super K , ? > map , final K key , final short defaultValue ) { return applyDefaultValue ( map , key , MapUtils :: getShort , defaultValue ) . shortValue () ; MST[NonVoidMethodCallMutator]MSP[] }
if ( map == null ) { if ( label != null ) { MST[NegateConditionalsMutator]MSP[] out . print ( label ) ; out . print ( lr_6 ) ; } out . println ( lr_7 ) ; return; } if ( label != null ) {
public static < K > short getShortValue ( final Map < ? super K , ? > map , final K key ) { return applyDefaultValue ( map , key , MapUtils :: getShort , 0 ) . shortValue () ; MST[ReturnValsMutator]MSP[] }
out . put ( entry . getValue () , entry . getKey () ) ; } return out ; } public static boolean isEmpty ( final Map < ? , ? > map ) { return map == null || map . isEmpty () ; MST[BooleanTrueReturnValsMutator]MSP[] }
return LazyMap . lazyMap ( map , transformerFactory ) ; MST[ReturnValsMutator]MSP[] } public static < K , V > SortedMap < K , V > lazySortedMap ( final SortedMap < K , V > map , final Factory < ? extends V > factory ) {
printIndent ( out , lineage . size () ) ; MST[NonVoidMethodCallMutator]MSP[] out . print ( childKey ) ; out . print ( lr_6 ) ; final int lineageIndex = IterableUtils . indexOf ( lineage , PredicateUtils . equalPredicate ( childValue ) ) ; if ( lineageIndex == - 1 ) {
printIndent ( out , lineage . size () ) ; out . print ( childKey ) ; MST[VoidMethodCallMutator]MSP[] out . print ( lr_6 ) ; final int lineageIndex = IterableUtils . indexOf ( lineage , PredicateUtils . equalPredicate ( childValue ) ) ; if ( lineageIndex == - 1 ) {
public static boolean isNotEmpty ( final Map < ? , ? > map ) { return ! MapUtils . isEmpty ( map ) ; MST[rv.CRCR5Mutator]MSP[] } public static < K , V > IterableMap < K , V > iterableMap ( final Map < K , V > map ) {
out . print ( lr_10 + ( lineage . size () - 1 - lineageIndex - 1 ) + lr_11 ) ; } if ( debug && childValue != null ) { MST[rv.ROR1Mutator]MSP[] out . print ( ' ' ) ;
return applyDefaultFunction ( map , key , MapUtils :: getInteger , defaultFunction , 0 ) . byteValue () ; MST[rv.CRCR6Mutator]MSP[] } public static < K > int getIntValue ( final Map < ? super K , ? > map , final K key , final int defaultValue ) {
out . print ( lr_10 + ( lineage . size () - 1 - lineageIndex - 1 ) + lr_11 ) ; MST[rv.UOI1Mutator]MSP[] } if ( debug && childValue != null ) { out . print ( ' ' ) ;
return applyDefaultFunction ( map , key , MapUtils :: getInteger , defaultFunction , 0 ) . byteValue () ; MST[NonVoidMethodCallMutator]MSP[] } public static < K > int getIntValue ( final Map < ? super K , ? > map , final K key , final int defaultValue ) {
public static < K > Boolean getBoolean ( final Map < ? super K , ? > map , final K key ) { if ( map != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] final Object answer = map . get ( key ) ; if ( answer != null ) {
return applyDefaultValue ( map , key , MapUtils :: getInteger , defaultValue ) . intValue () ; MST[NonVoidMethodCallMutator]MSP[] } public static < K > Long getLong ( final Map < ? super K , ? > map , final K key ) {
public static boolean isNotEmpty ( final Map < ? , ? > map ) { return ! MapUtils . isEmpty ( map ) ; MST[NegateConditionalsMutator]MSP[] } public static < K , V > IterableMap < K , V > iterableMap ( final Map < K , V > map ) {
final Number answer = getNumber ( map , key ) ; if ( answer == null ) { return null ; } if ( answer instanceof Short ) { return ( Short ) answer ; } return Short . valueOf ( answer . shortValue () ) ; MST[NonVoidMethodCallMutator]MSP[] }
return PredicatedMap . predicatedMap ( map , keyPred , valuePred ) ; MST[NonVoidMethodCallMutator]MSP[] } public static < K , V > SortedMap < K , V > predicatedSortedMap ( final SortedMap < K , V > map ,
R value = map != null && getFunction != null ? getFunction . apply ( map , key ) : null ; if ( value == null ) { value = defaultFunction != null ? defaultFunction . apply ( key ) : null ; MST[ArgumentPropagationMutator]MSP[] }
final Transformer < E , K > keyTransformer , final Transformer < E , V > valueTransformer ) { final Iterator < ? extends E > iter = elements . iterator () ; while ( iter . hasNext () ) { MST[rv.ROR4Mutator]MSP[] final E temp = iter . next () ;
for ( int i = 0 ; i < array . length - 1 ; ) { map . put ( ( K ) array [ i ++ ] , ( V ) array [ i ++ ] ) ; } } return map ; MST[ReturnValsMutator]MSP[] }
out . print ( childValue ) ; } else if ( lineage . size () - 1 == lineageIndex ) { MST[rv.AOD2Mutator]MSP[] out . print ( lr_9 ) ; } else {
public static < K > Short getShort ( final Map < ? super K , ? > map , final K key , final Short defaultValue ) { return applyDefaultValue ( map , key , MapUtils :: getShort , defaultValue ) ; MST[EmptyObjectReturnValsMutator]MSP[] }
public static < K > double getDoubleValue ( final Map < ? super K , ? > map , final K key , final double defaultValue ) { return applyDefaultValue ( map , key , MapUtils :: getDouble , defaultValue ) . doubleValue () ; MST[NonVoidMethodCallMutator]MSP[] }
public static < K > Boolean getBoolean ( final Map < ? super K , ? > map , final K key , final Boolean defaultValue ) { return applyDefaultValue ( map , key , MapUtils :: getBoolean , defaultValue ) ; MST[BooleanTrueReturnValsMutator]MSP[] }
if ( sub == null || sub . length < 2 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] throw new IllegalArgumentException ( lr_4 + i ) ; } map . put ( ( K ) sub [ 0 ] , ( V ) sub [ 1 ] ) ; } } else {
} else if ( obj instanceof Object [] ) { MST[rv.ROR4Mutator]MSP[] for ( int i = 0 ; i < array . length ; i ++ ) { final Object [] sub = ( Object [] ) array [ i ] ;
final Number answer = getNumber ( map , key ) ; if ( answer == null ) { return null ; } if ( answer instanceof Byte ) { MST[rv.ROR5Mutator]MSP[] return ( Byte ) answer ; } return Byte . valueOf ( answer . byteValue () ) ; }
return applyDefaultValue ( map , key , MapUtils :: getInteger , defaultValue ) . intValue () ; MST[rv.UOI1Mutator]MSP[] } public static < K > Long getLong ( final Map < ? super K , ? > map , final K key ) {
if ( array == null || array . length == 0 ) { MST[rv.ROR1Mutator]MSP[] return map ; } final Object obj = array [ 0 ] ; if ( obj instanceof Map . Entry ) { for ( final Object element : array ) {
if ( sub == null || sub . length < 2 ) { MST[rv.ROR2Mutator]MSP[] throw new IllegalArgumentException ( lr_4 + i ) ; } map . put ( ( K ) sub [ 0 ] , ( V ) sub [ 1 ] ) ; } } else {
final Number answer = getNumber ( map , key ) ; if ( answer == null ) { return null ; } if ( answer instanceof Integer ) { return ( Integer ) answer ; } return Integer . valueOf ( answer . intValue () ) ; MST[NonVoidMethodCallMutator]MSP[] }
final Number answer = getNumber ( map , key ) ; if ( answer == null ) { return null ; } if ( answer instanceof Short ) { MST[NegateConditionalsMutator]MSP[] return ( Short ) answer ; } return Short . valueOf ( answer . shortValue () ) ; }
out . print ( childValue ) ; } else if ( lineage . size () - 1 == lineageIndex ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] out . print ( lr_9 ) ; } else {
return value != null ? value : defaultValue ; MST[NegateConditionalsMutator]MSP[] } private static < K , R > R applyDefaultValue ( final Map < ? super K , ? > map , final K key ,
Objects . requireNonNull ( map , lr_1 ) ; return map instanceof IterableMap ? ( IterableMap < K , V > ) map : new AbstractMapDecorator < K , V > ( map ) { MST[ReturnValsMutator]MSP[] } ; }
if ( array == null || array . length == 0 ) { MST[rv.ROR5Mutator]MSP[] return map ; } final Object obj = array [ 0 ] ; if ( obj instanceof Map . Entry ) { for ( final Object element : array ) {
final Number answer = getNumber ( map , key ) ; if ( answer == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return null ; } if ( answer instanceof Float ) { return ( Float ) answer ; } return Float . valueOf ( answer . floatValue () ) ; }
if ( map == null ) { if ( label != null ) { out . print ( label ) ; out . print ( lr_6 ) ; } out . println ( lr_7 ) ; return; } if ( label != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
printIndent ( out , lineage . size () ) ; out . print ( childKey ) ; out . print ( lr_6 ) ; final int lineageIndex = IterableUtils . indexOf ( lineage , PredicateUtils . equalPredicate ( childValue ) ) ; MST[NonVoidMethodCallMutator]MSP[] if ( lineageIndex == - 1 ) {
for ( int i = 0 ; i < array . length - 1 ; ) { map . put ( ( K ) array [ i ++ ] , ( V ) array [ i ++ ] ) ; MST[rv.ABSMutator]MSP[] } } return map ; }
return applyDefaultValue ( map , key , MapUtils :: getLong , defaultValue ) . longValue () ; MST[ArgumentPropagationMutator]MSP[] } public static < K > Map < ? , ? > getMap ( final Map < ? super K , ? > map , final K key ) {
final Number answer = getNumber ( map , key ) ; if ( answer == null ) { return null ; } if ( answer instanceof Float ) { return ( Float ) answer ; } return Float . valueOf ( answer . floatValue () ) ; MST[ReturnValsMutator]MSP[] }
printIndent ( out , lineage . size () ) ; out . print ( childKey ) ; out . print ( lr_6 ) ; final int lineageIndex = IterableUtils . indexOf ( lineage , PredicateUtils . equalPredicate ( childValue ) ) ; if ( lineageIndex == - 1 ) { MST[rv.ROR5Mutator]MSP[]
R value = map != null && getFunction != null ? getFunction . apply ( map , key ) : null ; if ( value == null ) { value = defaultFunction != null ? defaultFunction . apply ( key ) : null ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] }
final Number answer = getNumber ( map , key ) ; if ( answer == null ) { return null ; } if ( answer instanceof Integer ) { MST[rv.ROR1Mutator]MSP[] return ( Integer ) answer ; } return Integer . valueOf ( answer . intValue () ) ; }
for ( int i = 0 ; i < array . length - 1 ; ) { MST[rv.CRCR3Mutator]MSP[] map . put ( ( K ) array [ i ++ ] , ( V ) array [ i ++ ] ) ; } } return map ; }
if ( answer != null ) { return answer ; } } return defaultValue ; MST[NullReturnValsMutator]MSP[] } public static < K > Short getShort ( final Map < ? super K , ? > map , final K key ) {
final Number answer = getNumber ( map , key ) ; if ( answer == null ) { return null ; MST[EmptyObjectReturnValsMutator]MSP[] } if ( answer instanceof Integer ) { return ( Integer ) answer ; } return Integer . valueOf ( answer . intValue () ) ; }
for ( int i = 0 ; i < array . length - 1 ; ) { MST[InlineConstantMutator]MSP[] map . put ( ( K ) array [ i ++ ] , ( V ) array [ i ++ ] ) ; } } return map ; }
final Number answer = getNumber ( map , key ) ; if ( answer == null ) { return null ; } if ( answer instanceof Integer ) { MST[rv.ROR5Mutator]MSP[] return ( Integer ) answer ; } return Integer . valueOf ( answer . intValue () ) ; }
final Number answer = getNumber ( map , key ) ; if ( answer == null ) { return null ; } if ( answer instanceof Integer ) { return ( Integer ) answer ; MST[ReturnValsMutator]MSP[] } return Integer . valueOf ( answer . intValue () ) ; }
return applyDefaultFunction ( map , key , MapUtils :: getBoolean , defaultFunction , false ) . booleanValue () ; MST[NonVoidMethodCallMutator]MSP[] } public static < K > Byte getByte ( final Map < ? super K , ? > map , final K key ) {
return applyDefaultValue ( map , key , MapUtils :: getLong , defaultValue ) . longValue () ; MST[PrimitiveReturnsMutator]MSP[] } public static < K > Map < ? , ? > getMap ( final Map < ? super K , ? > map , final K key ) {
public static < K > Byte getByte ( final Map < ? super K , ? > map , final K key , final Byte defaultValue ) { return applyDefaultValue ( map , key , MapUtils :: getByte , defaultValue ) ; MST[NullReturnValsMutator]MSP[] }
if ( sub == null || sub . length < 2 ) { throw new IllegalArgumentException ( lr_4 + i ) ; } map . put ( ( K ) sub [ 0 ] , ( V ) sub [ 1 ] ) ; MST[rv.CRCR3Mutator]MSP[] } } else {
for ( int i = 0 ; i < array . length - 1 ; ) { MST[rv.UOI4Mutator]MSP[] map . put ( ( K ) array [ i ++ ] , ( V ) array [ i ++ ] ) ; } } return map ; }
for ( int i = 0 ; i < indent ; i ++ ) { out . print ( INDENT_STRING ) ; MST[VoidMethodCallMutator]MSP[] } } @SuppressWarnings ( lr_3 )
public static int size ( final Map < ? , ? > map ) { return map == null ? 0 : map . size () ; MST[rv.CRCR1Mutator]MSP[] }
if ( array == null || array . length == 0 ) { return map ; MST[ReturnValsMutator]MSP[] } final Object obj = array [ 0 ] ; if ( obj instanceof Map . Entry ) { for ( final Object element : array ) {
out . println ( childValue . getClass () . getName () ) ; MST[VoidMethodCallMutator]MSP[] } else { out . println () ; } } } lineage . removeLast () ; printIndent ( out , lineage . size () ) ;
if ( childValue instanceof Map && ! lineage . contains ( childValue ) ) { verbosePrintInternal ( out , childKey == null ? lr_7 : childKey , ( Map < ? , ? > ) childValue , lineage , debug ) ; MST[rv.UOI4Mutator]MSP[] } else {
if ( childValue instanceof Map && ! lineage . contains ( childValue ) ) { verbosePrintInternal ( out , childKey == null ? lr_7 : childKey , ( Map < ? , ? > ) childValue , lineage , debug ) ; MST[rv.UOI1Mutator]MSP[] } else {
public static boolean isNotEmpty ( final Map < ? , ? > map ) { return ! MapUtils . isEmpty ( map ) ; MST[rv.ROR5Mutator]MSP[] } public static < K , V > IterableMap < K , V > iterableMap ( final Map < K , V > map ) {
if ( childValue instanceof Map && ! lineage . contains ( childValue ) ) { MST[rv.ROR5Mutator]MSP[] verbosePrintInternal ( out , childKey == null ? lr_7 : childKey , ( Map < ? , ? > ) childValue , lineage , debug ) ; } else {
out . print ( lr_10 + ( lineage . size () - 1 - lineageIndex - 1 ) + lr_11 ) ; MST[experimental.NakedReceiverMutator]MSP[] } if ( debug && childValue != null ) { out . print ( ' ' ) ;
final Object value = resourceBundle . getObject ( key ) ; MST[NonVoidMethodCallMutator]MSP[] map . put ( key , value ) ; } return map ; } public static < K , V > Properties toProperties ( final Map < K , V > map ) {
public static < K > float getFloatValue ( final Map < ? super K , ? > map , final K key , final float defaultValue ) { return applyDefaultValue ( map , key , MapUtils :: getFloat , defaultValue ) . floatValue () ; MST[rv.ABSMutator]MSP[] }
final Iterator < ? extends E > iter = elements . iterator () ; while ( iter . hasNext () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] final E temp = iter . next () ; map . put ( keyTransformer . transform ( temp ) , valueTransformer . transform ( temp ) ) ;
out . print ( lr_10 + ( lineage . size () - 1 - lineageIndex - 1 ) + lr_11 ) ; MST[rv.CRCR5Mutator]MSP[] } if ( debug && childValue != null ) { out . print ( ' ' ) ;
out . print ( childValue ) ; } else if ( lineage . size () - 1 == lineageIndex ) { MST[NonVoidMethodCallMutator]MSP[] out . print ( lr_9 ) ; } else {
public static < K > float getFloatValue ( final Map < ? super K , ? > map , final K key ) { return applyDefaultValue ( map , key , MapUtils :: getFloat , 0f ) . floatValue () ; MST[NonVoidMethodCallMutator]MSP[] }
out . put ( entry . getValue () , entry . getKey () ) ; } return out ; } public static boolean isEmpty ( final Map < ? , ? > map ) { return map == null || map . isEmpty () ; MST[rv.ROR2Mutator]MSP[] }
public static < K > Double getDouble ( final Map < ? super K , ? > map , final K key , final Function < K , Double > defaultFunction ) { return applyDefaultFunction ( map , key , MapUtils :: getDouble , defaultFunction ) ; MST[NonVoidMethodCallMutator]MSP[] }
final Map . Entry < K , V > entry = ( Map . Entry < K , V > ) element ; map . put ( entry . getKey () , entry . getValue () ) ; } } else if ( obj instanceof KeyValue ) { MST[rv.ROR1Mutator]MSP[]
final Number answer = getNumber ( map , key ) ; if ( answer == null ) { return null ; } if ( answer instanceof Byte ) { return ( Byte ) answer ; } return Byte . valueOf ( answer . byteValue () ) ; MST[NonVoidMethodCallMutator]MSP[] }
out . println ( childValue . getClass () . getName () ) ; MST[NonVoidMethodCallMutator]MSP[] } else { out . println () ; } } } lineage . removeLast () ; printIndent ( out , lineage . size () ) ;
public static < K > byte getByteValue ( final Map < ? super K , ? > map , final K key , final byte defaultValue ) { return applyDefaultValue ( map , key , MapUtils :: getByte , defaultValue ) . byteValue () ; MST[ArgumentPropagationMutator]MSP[] }
final Object answer = map . get ( key ) ; if ( answer != null ) { if ( answer instanceof Number ) { return ( Number ) answer ; } if ( answer instanceof String ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] try { final String text = ( String ) answer ;
public static < K > Boolean getBoolean ( final Map < ? super K , ? > map , final K key ) { if ( map != null ) { final Object answer = map . get ( key ) ; if ( answer != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
out . print ( lr_10 + ( lineage . size () - 1 - lineageIndex - 1 ) + lr_11 ) ; MST[rv.AOR1Mutator]MSP[] } if ( debug && childValue != null ) { out . print ( ' ' ) ;
if ( array == null || array . length == 0 ) { MST[NegateConditionalsMutator]MSP[] return map ; } final Object obj = array [ 0 ] ; if ( obj instanceof Map . Entry ) { for ( final Object element : array ) {
return value != null ? value : defaultValue ; MST[rv.ROR5Mutator]MSP[] } private static < K , R > R applyDefaultValue ( final Map < ? super K , ? > map , final K key ,
public static < K > Double getDouble ( final Map < ? super K , ? > map , final K key , final Double defaultValue ) { return applyDefaultValue ( map , key , MapUtils :: getDouble , defaultValue ) ; MST[NonVoidMethodCallMutator]MSP[] }
public static < K > boolean getBooleanValue ( final Map < ? super K , ? > map , final K key ) { return Boolean . TRUE . equals ( getBoolean ( map , key ) ) ; MST[BooleanTrueReturnValsMutator]MSP[] }
return applyDefaultFunction ( map , key , MapUtils :: getDouble , defaultFunction , 0d ) . doubleValue () ; MST[PrimitiveReturnsMutator]MSP[] } public static < K > Float getFloat ( final Map < ? super K , ? > map , final K key ) {
return applyDefaultFunction ( map , key , MapUtils :: getShort , defaultFunction , ( short ) 0 ) . shortValue () ; MST[rv.CRCR6Mutator]MSP[] }
if ( array == null || array . length == 0 ) { return map ; } final Object obj = array [ 0 ] ; if ( obj instanceof Map . Entry ) { MST[rv.ROR5Mutator]MSP[] for ( final Object element : array ) {
R value = map != null && getFunction != null ? getFunction . apply ( map , key ) : null ; MST[NegateConditionalsMutator]MSP[] if ( value == null ) { value = defaultFunction != null ? defaultFunction . apply ( key ) : null ; }
final Number answer = getNumber ( map , key ) ; if ( answer == null ) { return null ; } if ( answer instanceof Integer ) { MST[NegateConditionalsMutator]MSP[] return ( Integer ) answer ; } return Integer . valueOf ( answer . intValue () ) ; }
for ( final Object element : array ) { MST[rv.UOI3Mutator]MSP[] final KeyValue < K , V > keyval = ( KeyValue < K , V > ) element ; map . put ( keyval . getKey () , keyval . getValue () ) ; }
for ( int i = 0 ; i < indent ; i ++ ) { MST[ConditionalsBoundaryMutator]MSP[] out . print ( INDENT_STRING ) ; } } @SuppressWarnings ( lr_3 )
return applyDefaultFunction ( map , key , MapUtils :: getInteger , defaultFunction , 0 ) . byteValue () ; MST[NonVoidMethodCallMutator]MSP[] } public static < K > int getIntValue ( final Map < ? super K , ? > map , final K key , final int defaultValue ) {
if ( answer != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return answer ; } } return defaultValue ; } public static < K > Short getShort ( final Map < ? super K , ? > map , final K key ) {
out . print ( childValue ) ; } else if ( lineage . size () - 1 == lineageIndex ) { MST[rv.CRCR3Mutator]MSP[] out . print ( lr_9 ) ; } else {
final Map < V , K > out = new HashMap <> ( map . size () ) ; MST[ConstructorCallMutator]MSP[] for ( final Entry < K , V > entry : map . entrySet () ) {
return answer . toString () ; MST[ReturnValsMutator]MSP[] } } return null ; } public static < K > String getString ( final Map < ? super K , ? > map , final K key , final Function < K , String > defaultFunction ) {
if ( answer instanceof Boolean ) { return ( Boolean ) answer ; } if ( answer instanceof String ) { return Boolean . valueOf ( ( String ) answer ) ; } if ( answer instanceof Number ) { MST[NegateConditionalsMutator]MSP[] final Number n = ( Number ) answer ;
final Number answer = getNumber ( map , key ) ; if ( answer == null ) { return null ; } if ( answer instanceof Byte ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return ( Byte ) answer ; } return Byte . valueOf ( answer . byteValue () ) ; }
public static < K > Long getLong ( final Map < ? super K , ? > map , final K key , final Function < K , Long > defaultFunction ) { return applyDefaultFunction ( map , key , MapUtils :: getLong , defaultFunction ) ; MST[ArgumentPropagationMutator]MSP[] }
if ( map != null ) { final Object answer = map . get ( key ) ; if ( answer != null && answer instanceof Map ) { MST[rv.ROR5Mutator]MSP[] return ( Map < ? , ? > ) answer ; } } return null ; }
} else if ( obj instanceof Object [] ) { for ( int i = 0 ; i < array . length ; i ++ ) { MST[rv.ROR3Mutator]MSP[] final Object [] sub = ( Object [] ) array [ i ] ;
public static < K > double getDoubleValue ( final Map < ? super K , ? > map , final K key , final double defaultValue ) { return applyDefaultValue ( map , key , MapUtils :: getDouble , defaultValue ) . doubleValue () ; MST[NonVoidMethodCallMutator]MSP[] }
public static < K > float getFloatValue ( final Map < ? super K , ? > map , final K key , final float defaultValue ) { return applyDefaultValue ( map , key , MapUtils :: getFloat , defaultValue ) . floatValue () ; MST[PrimitiveReturnsMutator]MSP[] }
map . put ( keyTransformer . transform ( temp ) , valueTransformer . transform ( temp ) ) ; MST[NonVoidMethodCallMutator]MSP[] } } public static < K , V > void populateMap ( final MultiMap < K , V > map , final Iterable < ? extends V > elements ,
for ( int i = 0 ; i < array . length - 1 ; ) { MST[rv.ROR2Mutator]MSP[] map . put ( ( K ) array [ i ++ ] , ( V ) array [ i ++ ] ) ; } } return map ; }
R value = map != null && getFunction != null ? getFunction . apply ( map , key ) : null ; if ( value == null ) { MST[NegateConditionalsMutator]MSP[] value = defaultFunction != null ? defaultFunction . apply ( key ) : null ; }
if ( array == null || array . length == 0 ) { return map ; } final Object obj = array [ 0 ] ; if ( obj instanceof Map . Entry ) { for ( final Object element : array ) { MST[rv.UOI4Mutator]MSP[]
out . println ( childValue . getClass () . getName () ) ; } else { out . println () ; } } } lineage . removeLast () ; MST[NonVoidMethodCallMutator]MSP[] printIndent ( out , lineage . size () ) ;
final Properties answer = new Properties () ; MST[ConstructorCallMutator]MSP[] if ( map != null ) { for ( final Entry < K , V > entry2 : map . entrySet () ) { final Map . Entry < ? , ? > entry = entry2 ;
return applyDefaultFunction ( map , key , MapUtils :: getLong , defaultFunction , 0L ) . byteValue () ; MST[rv.CRCR1Mutator]MSP[] } public static < K > long getLongValue ( final Map < ? super K , ? > map , final K key , final long defaultValue ) {
return applyDefaultFunction ( map , key , MapUtils :: getShort , defaultFunction , ( short ) 0 ) . shortValue () ; MST[NonVoidMethodCallMutator]MSP[] }
public static < K > String getString ( final Map < ? super K , ? > map , final K key ) { if ( map != null ) { final Object answer = map . get ( key ) ; if ( answer != null ) { MST[rv.ROR5Mutator]MSP[]
if ( array == null || array . length == 0 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return map ; } final Object obj = array [ 0 ] ; if ( obj instanceof Map . Entry ) { for ( final Object element : array ) {
public static < K > Byte getByte ( final Map < ? super K , ? > map , final K key , final Function < K , Byte > defaultFunction ) { return applyDefaultFunction ( map , key , MapUtils :: getByte , defaultFunction ) ; MST[ArgumentPropagationMutator]MSP[] }
out . print ( childValue ) ; } else if ( lineage . size () - 1 == lineageIndex ) { MST[rv.ROR5Mutator]MSP[] out . print ( lr_9 ) ; } else {
return applyDefaultFunction ( map , key , MapUtils :: getByte , defaultFunction , ( byte ) 0 ) . byteValue () ; MST[NonVoidMethodCallMutator]MSP[] } public static < K > Double getDouble ( final Map < ? super K , ? > map , final K key ) {
out . put ( entry . getValue () , entry . getKey () ) ; } return out ; } public static boolean isEmpty ( final Map < ? , ? > map ) { return map == null || map . isEmpty () ; MST[rv.CRCR2Mutator]MSP[] }
public static < K > float getFloatValue ( final Map < ? super K , ? > map , final K key ) { return applyDefaultValue ( map , key , MapUtils :: getFloat , 0f ) . floatValue () ; MST[NonVoidMethodCallMutator]MSP[] }
if ( map == null ) { if ( label != null ) { MST[rv.ROR5Mutator]MSP[] out . print ( label ) ; out . print ( lr_6 ) ; } out . println ( lr_7 ) ; return; } if ( label != null ) {
return applyDefaultFunction ( map , key , MapUtils :: getShort , defaultFunction , ( short ) 0 ) . shortValue () ; MST[rv.CRCR3Mutator]MSP[] }
return map == null ? Collections . <K , V > emptyMap () : map ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] } public static < K , V > IterableMap < K , V > fixedSizeMap ( final Map < K , V > map ) { return FixedSizeMap . fixedSizeMap ( map ) ;
return applyDefaultFunction ( map , key , MapUtils :: getBoolean , defaultFunction , false ) . booleanValue () ; MST[BooleanTrueReturnValsMutator]MSP[] } public static < K > Byte getByte ( final Map < ? super K , ? > map , final K key ) {
out . put ( entry . getValue () , entry . getKey () ) ; } return out ; } public static boolean isEmpty ( final Map < ? , ? > map ) { return map == null || map . isEmpty () ; MST[rv.CRCR6Mutator]MSP[] }
printIndent ( out , lineage . size () ) ; out . print ( childKey ) ; out . print ( lr_6 ) ; final int lineageIndex = IterableUtils . indexOf ( lineage , PredicateUtils . equalPredicate ( childValue ) ) ; if ( lineageIndex == - 1 ) { MST[rv.UOI3Mutator]MSP[]
return answer . toString () ; } } return null ; MST[EmptyObjectReturnValsMutator]MSP[] } public static < K > String getString ( final Map < ? super K , ? > map , final K key , final Function < K , String > defaultFunction ) {
return n . intValue () != 0 ? Boolean . TRUE : Boolean . FALSE ; MST[NonVoidMethodCallMutator]MSP[] } } } return null ; }
public static < K > int getIntValue ( final Map < ? super K , ? > map , final K key ) { return applyDefaultValue ( map , key , MapUtils :: getInteger , 0 ) . intValue () ; MST[ReturnValsMutator]MSP[] }
public static void verbosePrint ( final PrintStream out , final Object label , final Map < ? , ? > map ) { verbosePrintInternal ( out , label , map , new ArrayDeque < Map < ? , ? > > () , false ) ; MST[rv.CRCR5Mutator]MSP[] }
return applyDefaultValue ( map , key , MapUtils :: getInteger , defaultValue ) . intValue () ; MST[NonVoidMethodCallMutator]MSP[] } public static < K > Long getLong ( final Map < ? super K , ? > map , final K key ) {
final Object answer = map . get ( key ) ; if ( answer != null ) { if ( answer instanceof Number ) { MST[rv.ROR2Mutator]MSP[] return ( Number ) answer ; } if ( answer instanceof String ) { try { final String text = ( String ) answer ;
public static int size ( final Map < ? , ? > map ) { return map == null ? 0 : map . size () ; MST[rv.CRCR6Mutator]MSP[] }
for ( int i = 0 ; i < array . length - 1 ; ) { map . put ( ( K ) array [ i ++ ] , ( V ) array [ i ++ ] ) ; MST[rv.UOI3Mutator]MSP[] } } return map ; }
public static < K > boolean getBooleanValue ( final Map < ? super K , ? > map , final K key , final boolean defaultValue ) { return applyDefaultValue ( map , key , MapUtils :: getBoolean , defaultValue ) . booleanValue () ; MST[rv.UOI2Mutator]MSP[] }
final Transformer < E , K > keyTransformer , final Transformer < E , V > valueTransformer ) { final Iterator < ? extends E > iter = elements . iterator () ; while ( iter . hasNext () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] final E temp = iter . next () ;
final BiFunction < Map < ? super K , ? > , K , R > getFunction , final Function < K , R > defaultFunction ) { return applyDefaultFunction ( map , key , getFunction , defaultFunction , null ) ; MST[NonVoidMethodCallMutator]MSP[] }
public static < K > boolean getBooleanValue ( final Map < ? super K , ? > map , final K key , final boolean defaultValue ) { return applyDefaultValue ( map , key , MapUtils :: getBoolean , defaultValue ) . booleanValue () ; MST[NonVoidMethodCallMutator]MSP[] }
public static < K , V > IterableSortedMap < K , V > iterableSortedMap ( final SortedMap < K , V > sortedMap ) { Objects . requireNonNull ( sortedMap , lr_2 ) ; return sortedMap instanceof IterableSortedMap ? ( IterableSortedMap < K , V > ) sortedMap MST[rv.ROR2Mutator]MSP[]
public static < K > byte getByteValue ( final Map < ? super K , ? > map , final K key ) { return applyDefaultValue ( map , key , MapUtils :: getByte , 0 ) . byteValue () ; MST[ArgumentPropagationMutator]MSP[] }
out . print ( lr_10 + ( lineage . size () - 1 - lineageIndex - 1 ) + lr_11 ) ; } if ( debug && childValue != null ) { MST[rv.UOI3Mutator]MSP[] out . print ( ' ' ) ;
if ( answer instanceof Boolean ) { return ( Boolean ) answer ; MST[BooleanFalseReturnValsMutator]MSP[] } if ( answer instanceof String ) { return Boolean . valueOf ( ( String ) answer ) ; } if ( answer instanceof Number ) { final Number n = ( Number ) answer ;
final Number answer = getNumber ( map , key ) ; if ( answer == null ) { return null ; } if ( answer instanceof Double ) { MST[NegateConditionalsMutator]MSP[] return ( Double ) answer ; } return Double . valueOf ( answer . doubleValue () ) ; }
public static < K > Boolean getBoolean ( final Map < ? super K , ? > map , final K key , final Function < K , Boolean > defaultFunction ) { return applyDefaultFunction ( map , key , MapUtils :: getBoolean , defaultFunction ) ; MST[NonVoidMethodCallMutator]MSP[] }
public static < K > Short getShort ( final Map < ? super K , ? > map , final K key , final Function < K , Short > defaultFunction ) { return applyDefaultFunction ( map , key , MapUtils :: getShort , defaultFunction ) ; MST[EmptyObjectReturnValsMutator]MSP[] }
for ( int i = 0 ; i < array . length - 1 ; ) { map . put ( ( K ) array [ i ++ ] , ( V ) array [ i ++ ] ) ; MST[rv.UOI3Mutator]MSP[] } } return map ; }
out . println ( debug ? lr_12 + map . getClass () . getName () : lr_13 ) ; MST[rv.ROR4Mutator]MSP[] }
public static void verbosePrint ( final PrintStream out , final Object label , final Map < ? , ? > map ) { verbosePrintInternal ( out , label , map , new ArrayDeque < Map < ? , ? > > () , false ) ; MST[VoidMethodCallMutator]MSP[] }
R value = map != null && getFunction != null ? getFunction . apply ( map , key ) : null ; if ( value == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] value = defaultFunction != null ? defaultFunction . apply ( key ) : null ; }
public static < K > Byte getByte ( final Map < ? super K , ? > map , final K key , final Byte defaultValue ) { return applyDefaultValue ( map , key , MapUtils :: getByte , defaultValue ) ; MST[NonVoidMethodCallMutator]MSP[] }
if ( array == null || array . length == 0 ) { return map ; } final Object obj = array [ 0 ] ; MST[rv.CRCR6Mutator]MSP[] if ( obj instanceof Map . Entry ) { for ( final Object element : array ) {
return applyDefaultValue ( map , key , MapUtils :: getMap , defaultValue ) ; } public static < K > Number getNumber ( final Map < ? super K , ? > map , final K key ) { if ( map != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
if ( sub == null || sub . length < 2 ) { MST[rv.CRCR2Mutator]MSP[] throw new IllegalArgumentException ( lr_4 + i ) ; } map . put ( ( K ) sub [ 0 ] , ( V ) sub [ 1 ] ) ; } } else {
return n . intValue () != 0 ? Boolean . TRUE : Boolean . FALSE ; MST[rv.ROR4Mutator]MSP[] } } } return null ; }
if ( map != null ) { final Object answer = map . get ( key ) ; if ( answer != null && answer instanceof Map ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return ( Map < ? , ? > ) answer ; } } return null ; }
R value = map != null && getFunction != null ? getFunction . apply ( map , key ) : null ; if ( value == null ) { MST[rv.ROR5Mutator]MSP[] value = defaultFunction != null ? defaultFunction . apply ( key ) : null ; }
if ( sub == null || sub . length < 2 ) { MST[rv.CRCR4Mutator]MSP[] throw new IllegalArgumentException ( lr_4 + i ) ; } map . put ( ( K ) sub [ 0 ] , ( V ) sub [ 1 ] ) ; } } else {
final BiFunction < Map < ? super K , ? > , K , R > getFunction , final R defaultValue ) { final R value = map != null && getFunction != null ? getFunction . apply ( map , key ) : null ; MST[rv.ROR5Mutator]MSP[]
public static boolean isNotEmpty ( final Map < ? , ? > map ) { return ! MapUtils . isEmpty ( map ) ; MST[rv.CRCR5Mutator]MSP[] } public static < K , V > IterableMap < K , V > iterableMap ( final Map < K , V > map ) {
return NumberFormat . getInstance () . parse ( text ) ; MST[ReturnValsMutator]MSP[] } catch ( final ParseException e ) { } } } } return null ; } public static < K > Number getNumber ( final Map < ? super K , ? > map , final K key ,
final Object key = entry . getKey () ; final Object value = entry . getValue () ; answer . put ( key , value ) ; MST[NonVoidMethodCallMutator]MSP[] } } return answer ; }
public static < K > Boolean getBoolean ( final Map < ? super K , ? > map , final K key , final Boolean defaultValue ) { return applyDefaultValue ( map , key , MapUtils :: getBoolean , defaultValue ) ; MST[BooleanFalseReturnValsMutator]MSP[] }
public static < K > long getLongValue ( final Map < ? super K , ? > map , final K key ) { return applyDefaultValue ( map , key , MapUtils :: getLong , 0L ) . longValue () ; MST[NonVoidMethodCallMutator]MSP[] }
public static < K > Number getNumber ( final Map < ? super K , ? > map , final K key , final Number defaultValue ) { return applyDefaultValue ( map , key , MapUtils :: getNumber , defaultValue ) ; MST[NullReturnValsMutator]MSP[] }
printIndent ( out , lineage . size () ) ; out . print ( childKey ) ; out . print ( lr_6 ) ; final int lineageIndex = IterableUtils . indexOf ( lineage , PredicateUtils . equalPredicate ( childValue ) ) ; if ( lineageIndex == - 1 ) { MST[rv.ROR2Mutator]MSP[]
return applyDefaultFunction ( map , key , MapUtils :: getString , defaultFunction ) ; MST[ArgumentPropagationMutator]MSP[] } public static < K > String getString ( final Map < ? super K , ? > map , final K key , final String defaultValue ) {
public static < K , V > V getObject ( final Map < K , V > map , final K key , final V defaultValue ) { if ( map != null ) { MST[rv.ROR5Mutator]MSP[] final V answer = map . get ( key ) ;
public static < K > void safeAddToMap ( final Map < ? super K , Object > map , final K key , final Object value ) throws NullPointerException { map . put ( key , value == null ? lr_5 : value ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] }
out . print ( lr_10 + ( lineage . size () - 1 - lineageIndex - 1 ) + lr_11 ) ; MST[rv.AOR1Mutator]MSP[] } if ( debug && childValue != null ) { out . print ( ' ' ) ;
public static < K > void safeAddToMap ( final Map < ? super K , Object > map , final K key , final Object value ) throws NullPointerException { map . put ( key , value == null ? lr_5 : value ) ; MST[rv.ROR5Mutator]MSP[] }
return LazyMap . lazyMap ( map , factory ) ; MST[NonVoidMethodCallMutator]MSP[] } public static < K , V > IterableMap < K , V > lazyMap ( final Map < K , V > map , final Transformer < ? super K , ? extends V > transformerFactory ) {
final Number answer = getNumber ( map , key ) ; if ( answer == null ) { return null ; } if ( answer instanceof Double ) { return ( Double ) answer ; MST[EmptyObjectReturnValsMutator]MSP[] } return Double . valueOf ( answer . doubleValue () ) ; }
for ( final Object element : array ) { MST[rv.UOI4Mutator]MSP[] final KeyValue < K , V > keyval = ( KeyValue < K , V > ) element ; map . put ( keyval . getKey () , keyval . getValue () ) ; }
for ( final Object element : array ) { MST[rv.ABSMutator]MSP[] final KeyValue < K , V > keyval = ( KeyValue < K , V > ) element ; map . put ( keyval . getKey () , keyval . getValue () ) ; }
R value = map != null && getFunction != null ? getFunction . apply ( map , key ) : null ; MST[NegateConditionalsMutator]MSP[] if ( value == null ) { value = defaultFunction != null ? defaultFunction . apply ( key ) : null ; }
if ( map == null ) { MST[NegateConditionalsMutator]MSP[] if ( label != null ) { out . print ( label ) ; out . print ( lr_6 ) ; } out . println ( lr_7 ) ; return; } if ( label != null ) {
for ( int i = 0 ; i < array . length - 1 ; ) { MST[MathMutator]MSP[] map . put ( ( K ) array [ i ++ ] , ( V ) array [ i ++ ] ) ; } } return map ; }
final Function < K , Number > defaultFunction ) { return applyDefaultFunction ( map , key , MapUtils :: getNumber , defaultFunction ) ; MST[NullReturnValsMutator]MSP[] }
public static < K > double getDoubleValue ( final Map < ? super K , ? > map , final K key ) { return applyDefaultValue ( map , key , MapUtils :: getDouble , 0d ) . doubleValue () ; MST[rv.CRCR1Mutator]MSP[] }
final BiFunction < Map < ? super K , ? > , K , R > getFunction , final R defaultValue ) { final R value = map != null && getFunction != null ? getFunction . apply ( map , key ) : null ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
public static < K > String getString ( final Map < ? super K , ? > map , final K key ) { if ( map != null ) { final Object answer = map . get ( key ) ; if ( answer != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
if ( map == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] if ( label != null ) { out . print ( label ) ; out . print ( lr_6 ) ; } out . println ( lr_7 ) ; return; } if ( label != null ) {
} else if ( obj instanceof Object [] ) { for ( int i = 0 ; i < array . length ; i ++ ) { final Object [] sub = ( Object [] ) array [ i ] ; MST[rv.UOI3Mutator]MSP[]
R value = map != null && getFunction != null ? getFunction . apply ( map , key ) : null ; MST[rv.ROR5Mutator]MSP[] if ( value == null ) { value = defaultFunction != null ? defaultFunction . apply ( key ) : null ; }
return applyDefaultFunction ( map , key , MapUtils :: getDouble , defaultFunction , 0d ) . doubleValue () ; MST[rv.CRCR1Mutator]MSP[] } public static < K > Float getFloat ( final Map < ? super K , ? > map , final K key ) {
} else if ( obj instanceof Object [] ) { for ( int i = 0 ; i < array . length ; i ++ ) { MST[rv.ROR5Mutator]MSP[] final Object [] sub = ( Object [] ) array [ i ] ;
Objects . requireNonNull ( map , lr_1 ) ; return map instanceof IterableMap ? ( IterableMap < K , V > ) map : new AbstractMapDecorator < K , V > ( map ) { MST[rv.ROR4Mutator]MSP[] } ; }
for ( int i = 0 ; i < indent ; i ++ ) { MST[rv.ROR2Mutator]MSP[] out . print ( INDENT_STRING ) ; } } @SuppressWarnings ( lr_3 )
if ( array == null || array . length == 0 ) { return map ; } final Object obj = array [ 0 ] ; if ( obj instanceof Map . Entry ) { for ( final Object element : array ) { MST[rv.UOI1Mutator]MSP[]
out . println ( debug ? lr_12 + map . getClass () . getName () : lr_13 ) ; MST[rv.UOI1Mutator]MSP[] }
return LazyMap . lazyMap ( map , transformerFactory ) ; MST[NonVoidMethodCallMutator]MSP[] } public static < K , V > SortedMap < K , V > lazySortedMap ( final SortedMap < K , V > map , final Factory < ? extends V > factory ) {
out . print ( childValue ) ; } else if ( lineage . size () - 1 == lineageIndex ) { MST[rv.ROR2Mutator]MSP[] out . print ( lr_9 ) ; } else {
return applyDefaultFunction ( map , key , MapUtils :: getLong , defaultFunction , 0L ) . byteValue () ; MST[rv.CRCR6Mutator]MSP[] } public static < K > long getLongValue ( final Map < ? super K , ? > map , final K key , final long defaultValue ) {
return n . intValue () != 0 ? Boolean . TRUE : Boolean . FALSE ; MST[ReturnValsMutator]MSP[] } } } return null ; }
public static < K > Float getFloat ( final Map < ? super K , ? > map , final K key , final Float defaultValue ) { return applyDefaultValue ( map , key , MapUtils :: getFloat , defaultValue ) ; MST[NonVoidMethodCallMutator]MSP[] }
out . print ( lr_10 + ( lineage . size () - 1 - lineageIndex - 1 ) + lr_11 ) ; MST[rv.AOR4Mutator]MSP[] } if ( debug && childValue != null ) { out . print ( ' ' ) ;
public static < K > short getShortValue ( final Map < ? super K , ? > map , final K key ) { return applyDefaultValue ( map , key , MapUtils :: getShort , 0 ) . shortValue () ; MST[rv.CRCR1Mutator]MSP[] }
return applyDefaultFunction ( map , key , MapUtils :: getFloat , defaultFunction , 0f ) . floatValue () ; MST[NonVoidMethodCallMutator]MSP[] } public static < K > Integer getInteger ( final Map < ? super K , ? > map , final K key ) {
final Properties answer = new Properties () ; if ( map != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] for ( final Entry < K , V > entry2 : map . entrySet () ) { final Map . Entry < ? , ? > entry = entry2 ;
out . put ( entry . getValue () , entry . getKey () ) ; } return out ; } public static boolean isEmpty ( final Map < ? , ? > map ) { return map == null || map . isEmpty () ; MST[rv.CRCR4Mutator]MSP[] }
public static < K > byte getByteValue ( final Map < ? super K , ? > map , final K key ) { return applyDefaultValue ( map , key , MapUtils :: getByte , 0 ) . byteValue () ; MST[rv.CRCR5Mutator]MSP[] }
public static < K , V > OrderedMap < K , V > orderedMap ( final Map < K , V > map ) { return ListOrderedMap . listOrderedMap ( map ) ; MST[NonVoidMethodCallMutator]MSP[] }
return applyDefaultFunction ( map , key , MapUtils :: getByte , defaultFunction , ( byte ) 0 ) . byteValue () ; MST[NonVoidMethodCallMutator]MSP[] } public static < K > Double getDouble ( final Map < ? super K , ? > map , final K key ) {
return applyDefaultFunction ( map , key , MapUtils :: getShort , defaultFunction , ( short ) 0 ) . shortValue () ; MST[rv.CRCR1Mutator]MSP[] }
final BiFunction < Map < ? super K , ? > , K , R > getFunction , final R defaultValue ) { final R value = map != null && getFunction != null ? getFunction . apply ( map , key ) : null ; MST[NegateConditionalsMutator]MSP[]
final Number answer = getNumber ( map , key ) ; if ( answer == null ) { return null ; } if ( answer instanceof Long ) { return ( Long ) answer ; MST[EmptyObjectReturnValsMutator]MSP[] } return Long . valueOf ( answer . longValue () ) ; }
for ( int i = 0 ; i < array . length - 1 ; ) { map . put ( ( K ) array [ i ++ ] , ( V ) array [ i ++ ] ) ; MST[rv.ABSMutator]MSP[] } } return map ; }
return value == null ? defaultValue : value ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] } public static void debugPrint ( final PrintStream out , final Object label , final Map < ? , ? > map ) {
final Number answer = getNumber ( map , key ) ; if ( answer == null ) { return null ; } if ( answer instanceof Double ) { MST[rv.ROR3Mutator]MSP[] return ( Double ) answer ; } return Double . valueOf ( answer . doubleValue () ) ; }
out . print ( lr_10 + ( lineage . size () - 1 - lineageIndex - 1 ) + lr_11 ) ; MST[VoidMethodCallMutator]MSP[] } if ( debug && childValue != null ) { out . print ( ' ' ) ;
public static < K , V > IterableSortedMap < K , V > iterableSortedMap ( final SortedMap < K , V > sortedMap ) { Objects . requireNonNull ( sortedMap , lr_2 ) ; return sortedMap instanceof IterableSortedMap ? ( IterableSortedMap < K , V > ) sortedMap MST[ReturnValsMutator]MSP[]
final Enumeration < String > enumeration = resourceBundle . getKeys () ; final Map < String , Object > map = new HashMap <> () ; while ( enumeration . hasMoreElements () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] final String key = enumeration . nextElement () ;
printIndent ( out , lineage . size () ) ; out . print ( childKey ) ; out . print ( lr_6 ) ; final int lineageIndex = IterableUtils . indexOf ( lineage , PredicateUtils . equalPredicate ( childValue ) ) ; if ( lineageIndex == - 1 ) { MST[rv.CRCR5Mutator]MSP[]
R value = map != null && getFunction != null ? getFunction . apply ( map , key ) : null ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] if ( value == null ) { value = defaultFunction != null ? defaultFunction . apply ( key ) : null ; }
final Number answer = getNumber ( map , key ) ; if ( answer == null ) { return null ; } if ( answer instanceof Long ) { MST[NegateConditionalsMutator]MSP[] return ( Long ) answer ; } return Long . valueOf ( answer . longValue () ) ; }
return value == null ? defaultValue : value ; MST[NullReturnValsMutator]MSP[] } public static void debugPrint ( final PrintStream out , final Object label , final Map < ? , ? > map ) {
if ( array == null || array . length == 0 ) { return map ; } final Object obj = array [ 0 ] ; if ( obj instanceof Map . Entry ) { MST[NegateConditionalsMutator]MSP[] for ( final Object element : array ) {
out . print ( lr_10 + ( lineage . size () - 1 - lineageIndex - 1 ) + lr_11 ) ; MST[NonVoidMethodCallMutator]MSP[] } if ( debug && childValue != null ) { out . print ( ' ' ) ;
if ( sub == null || sub . length < 2 ) { throw new IllegalArgumentException ( lr_4 + i ) ; } map . put ( ( K ) sub [ 0 ] , ( V ) sub [ 1 ] ) ; MST[rv.CRCR5Mutator]MSP[] } } else {
if ( answer instanceof Boolean ) { return ( Boolean ) answer ; } if ( answer instanceof String ) { MST[rv.ROR1Mutator]MSP[] return Boolean . valueOf ( ( String ) answer ) ; } if ( answer instanceof Number ) { final Number n = ( Number ) answer ;
public static < K > Long getLong ( final Map < ? super K , ? > map , final K key , final Long defaultValue ) { return applyDefaultValue ( map , key , MapUtils :: getLong , defaultValue ) ; MST[NonVoidMethodCallMutator]MSP[] }
public static < K , V > Map < K , V > putAll ( final Map < K , V > map , final Object [] array ) { Objects . requireNonNull ( map , lr_1 ) ; MST[ArgumentPropagationMutator]MSP[]
public static < K , V > V getObject ( final Map < K , V > map , final K key , final V defaultValue ) { if ( map != null ) { final V answer = map . get ( key ) ; MST[ArgumentPropagationMutator]MSP[]
public static < K > double getDoubleValue ( final Map < ? super K , ? > map , final K key , final double defaultValue ) { return applyDefaultValue ( map , key , MapUtils :: getDouble , defaultValue ) . doubleValue () ; MST[rv.UOI1Mutator]MSP[] }
if ( sub == null || sub . length < 2 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[] throw new IllegalArgumentException ( lr_4 + i ) ; } map . put ( ( K ) sub [ 0 ] , ( V ) sub [ 1 ] ) ; } } else {
out . put ( entry . getValue () , entry . getKey () ) ; } return out ; } public static boolean isEmpty ( final Map < ? , ? > map ) { return map == null || map . isEmpty () ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] }
final Number answer = getNumber ( map , key ) ; if ( answer == null ) { return null ; } if ( answer instanceof Float ) { MST[rv.ROR4Mutator]MSP[] return ( Float ) answer ; } return Float . valueOf ( answer . floatValue () ) ; }
public static < K , V > V getObject ( final Map < ? super K , V > map , final K key ) { if ( map != null ) { return map . get ( key ) ; MST[NonVoidMethodCallMutator]MSP[] } return null ; }
if ( map != null ) { final Object answer = map . get ( key ) ; if ( answer != null && answer instanceof Map ) { MST[NegateConditionalsMutator]MSP[] return ( Map < ? , ? > ) answer ; } } return null ; }
if ( sub == null || sub . length < 2 ) { throw new IllegalArgumentException ( lr_4 + i ) ; MST[experimental.NakedReceiverMutator]MSP[] } map . put ( ( K ) sub [ 0 ] , ( V ) sub [ 1 ] ) ; } } else {
} else if ( obj instanceof Object [] ) { for ( int i = 0 ; i < array . length ; i ++ ) { MST[NegateConditionalsMutator]MSP[] final Object [] sub = ( Object [] ) array [ i ] ;
out . print ( lr_10 + ( lineage . size () - 1 - lineageIndex - 1 ) + lr_11 ) ; MST[rv.AOD2Mutator]MSP[] } if ( debug && childValue != null ) { out . print ( ' ' ) ;
out . print ( lr_10 + ( lineage . size () - 1 - lineageIndex - 1 ) + lr_11 ) ; MST[rv.CRCR2Mutator]MSP[] } if ( debug && childValue != null ) { out . print ( ' ' ) ;
if ( answer instanceof Boolean ) { return ( Boolean ) answer ; } if ( answer instanceof String ) { return Boolean . valueOf ( ( String ) answer ) ; } if ( answer instanceof Number ) { MST[rv.ROR5Mutator]MSP[] final Number n = ( Number ) answer ;
final Object value = resourceBundle . getObject ( key ) ; map . put ( key , value ) ; } return map ; MST[ReturnValsMutator]MSP[] } public static < K , V > Properties toProperties ( final Map < K , V > map ) {
out . print ( childValue ) ; } else if ( lineage . size () - 1 == lineageIndex ) { MST[rv.UOI4Mutator]MSP[] out . print ( lr_9 ) ; } else {
final BiFunction < Map < ? super K , ? > , K , R > getFunction , final R defaultValue ) { final R value = map != null && getFunction != null ? getFunction . apply ( map , key ) : null ; MST[rv.ROR5Mutator]MSP[]
out . print ( lr_10 + ( lineage . size () - 1 - lineageIndex - 1 ) + lr_11 ) ; } if ( debug && childValue != null ) { out . print ( ' ' ) ; MST[rv.CRCR2Mutator]MSP[]
} else if ( obj instanceof Object [] ) { for ( int i = 0 ; i < array . length ; i ++ ) { final Object [] sub = ( Object [] ) array [ i ] ; MST[rv.ABSMutator]MSP[]
final Number answer = getNumber ( map , key ) ; if ( answer == null ) { return null ; MST[ReturnValsMutator]MSP[] } if ( answer instanceof Integer ) { return ( Integer ) answer ; } return Integer . valueOf ( answer . intValue () ) ; }
public static < K > Boolean getBoolean ( final Map < ? super K , ? > map , final K key ) { if ( map != null ) { MST[NegateConditionalsMutator]MSP[] final Object answer = map . get ( key ) ; if ( answer != null ) {
} else if ( obj instanceof Object [] ) { for ( int i = 0 ; i < array . length ; i ++ ) { MST[rv.CRCR6Mutator]MSP[] final Object [] sub = ( Object [] ) array [ i ] ;
final Number answer = getNumber ( map , key ) ; if ( answer == null ) { return null ; } if ( answer instanceof Long ) { MST[rv.ROR5Mutator]MSP[] return ( Long ) answer ; } return Long . valueOf ( answer . longValue () ) ; }
final Iterator < ? extends E > iter = elements . iterator () ; while ( iter . hasNext () ) { MST[rv.ROR2Mutator]MSP[] final E temp = iter . next () ; map . put ( keyTransformer . transform ( temp ) , valueTransformer . transform ( temp ) ) ;
return applyDefaultFunction ( map , key , MapUtils :: getBoolean , defaultFunction , false ) . booleanValue () ; MST[BooleanFalseReturnValsMutator]MSP[] } public static < K > Byte getByte ( final Map < ? super K , ? > map , final K key ) {
public static boolean isNotEmpty ( final Map < ? , ? > map ) { return ! MapUtils . isEmpty ( map ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] } public static < K , V > IterableMap < K , V > iterableMap ( final Map < K , V > map ) {
public static < K > Boolean getBoolean ( final Map < ? super K , ? > map , final K key ) { if ( map != null ) { final Object answer = map . get ( key ) ; MST[ArgumentPropagationMutator]MSP[] if ( answer != null ) {
if ( array == null || array . length == 0 ) { return map ; } final Object obj = array [ 0 ] ; if ( obj instanceof Map . Entry ) { MST[rv.ROR3Mutator]MSP[] for ( final Object element : array ) {
public static < K > byte getByteValue ( final Map < ? super K , ? > map , final K key , final byte defaultValue ) { return applyDefaultValue ( map , key , MapUtils :: getByte , defaultValue ) . byteValue () ; MST[PrimitiveReturnsMutator]MSP[] }
final Number answer = getNumber ( map , key ) ; MST[NonVoidMethodCallMutator]MSP[] if ( answer == null ) { return null ; } if ( answer instanceof Double ) { return ( Double ) answer ; } return Double . valueOf ( answer . doubleValue () ) ; }
out . print ( childValue ) ; } else if ( lineage . size () - 1 == lineageIndex ) { MST[rv.CRCR5Mutator]MSP[] out . print ( lr_9 ) ; } else {
final Number answer = getNumber ( map , key ) ; if ( answer == null ) { return null ; } if ( answer instanceof Long ) { return ( Long ) answer ; MST[ReturnValsMutator]MSP[] } return Long . valueOf ( answer . longValue () ) ; }
out . put ( entry . getValue () , entry . getKey () ) ; MST[ArgumentPropagationMutator]MSP[] } return out ; } public static boolean isEmpty ( final Map < ? , ? > map ) { return map == null || map . isEmpty () ; }
final Transformer < E , K > keyTransformer , final Transformer < E , V > valueTransformer ) { final Iterator < ? extends E > iter = elements . iterator () ; while ( iter . hasNext () ) { MST[rv.ROR2Mutator]MSP[] final E temp = iter . next () ;
if ( sub == null || sub . length < 2 ) { throw new IllegalArgumentException ( lr_4 + i ) ; } map . put ( ( K ) sub [ 0 ] , ( V ) sub [ 1 ] ) ; MST[rv.CRCR6Mutator]MSP[] } } else {
public static < K > int getIntValue ( final Map < ? super K , ? > map , final K key ) { return applyDefaultValue ( map , key , MapUtils :: getInteger , 0 ) . intValue () ; MST[NonVoidMethodCallMutator]MSP[] }
final BiFunction < Map < ? super K , ? > , K , R > getFunction , final R defaultValue ) { final R value = map != null && getFunction != null ? getFunction . apply ( map , key ) : null ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
R value = map != null && getFunction != null ? getFunction . apply ( map , key ) : null ; MST[rv.ROR5Mutator]MSP[] if ( value == null ) { value = defaultFunction != null ? defaultFunction . apply ( key ) : null ; }
return map == null ? Collections . <K , V > emptyMap () : map ; MST[NegateConditionalsMutator]MSP[] } public static < K , V > IterableMap < K , V > fixedSizeMap ( final Map < K , V > map ) { return FixedSizeMap . fixedSizeMap ( map ) ;
public static < K , V > V getObject ( final Map < ? super K , V > map , final K key ) { if ( map != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return map . get ( key ) ; } return null ; }
return map == null ? Collections . <K , V > emptyMap () : map ; MST[NullReturnValsMutator]MSP[] } public static < K , V > IterableMap < K , V > fixedSizeMap ( final Map < K , V > map ) { return FixedSizeMap . fixedSizeMap ( map ) ;
out . put ( entry . getValue () , entry . getKey () ) ; } return out ; } public static boolean isEmpty ( final Map < ? , ? > map ) { return map == null || map . isEmpty () ; MST[ReturnValsMutator]MSP[] }
public static < K > double getDoubleValue ( final Map < ? super K , ? > map , final K key ) { return applyDefaultValue ( map , key , MapUtils :: getDouble , 0d ) . doubleValue () ; MST[rv.CRCR6Mutator]MSP[] }
final Object key = entry . getKey () ; final Object value = entry . getValue () ; answer . put ( key , value ) ; } } return answer ; MST[ReturnValsMutator]MSP[] }
public static < K , V > IterableSortedMap < K , V > iterableSortedMap ( final SortedMap < K , V > sortedMap ) { Objects . requireNonNull ( sortedMap , lr_2 ) ; return sortedMap instanceof IterableSortedMap ? ( IterableSortedMap < K , V > ) sortedMap MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
return PredicatedMap . predicatedMap ( map , keyPred , valuePred ) ; MST[ReturnValsMutator]MSP[] } public static < K , V > SortedMap < K , V > predicatedSortedMap ( final SortedMap < K , V > map ,
public static < K > long getLongValue ( final Map < ? super K , ? > map , final K key ) { return applyDefaultValue ( map , key , MapUtils :: getLong , 0L ) . longValue () ; MST[ReturnValsMutator]MSP[] }
return applyDefaultValue ( map , key , MapUtils :: getMap , defaultValue ) ; MST[ReturnValsMutator]MSP[] } public static < K > Number getNumber ( final Map < ? super K , ? > map , final K key ) { if ( map != null ) {
} else if ( obj instanceof Object [] ) { MST[rv.ROR1Mutator]MSP[] for ( int i = 0 ; i < array . length ; i ++ ) { final Object [] sub = ( Object [] ) array [ i ] ;
for ( final Map . Entry < ? , ? > entry : map . entrySet () ) { final Object childKey = entry . getKey () ; final Object childValue = entry . getValue () ; MST[NonVoidMethodCallMutator]MSP[]
final Number answer = getNumber ( map , key ) ; if ( answer == null ) { return null ; } if ( answer instanceof Byte ) { MST[rv.ROR2Mutator]MSP[] return ( Byte ) answer ; } return Byte . valueOf ( answer . byteValue () ) ; }
final Object answer = map . get ( key ) ; if ( answer != null ) { if ( answer instanceof Number ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return ( Number ) answer ; } if ( answer instanceof String ) { try { final String text = ( String ) answer ;
} else if ( obj instanceof Object [] ) { for ( int i = 0 ; i < array . length ; i ++ ) { MST[rv.CRCR1Mutator]MSP[] final Object [] sub = ( Object [] ) array [ i ] ;
if ( sub == null || sub . length < 2 ) { MST[rv.ROR4Mutator]MSP[] throw new IllegalArgumentException ( lr_4 + i ) ; } map . put ( ( K ) sub [ 0 ] , ( V ) sub [ 1 ] ) ; } } else {
if ( array == null || array . length == 0 ) { MST[rv.ROR3Mutator]MSP[] return map ; } final Object obj = array [ 0 ] ; if ( obj instanceof Map . Entry ) { for ( final Object element : array ) {
verbosePrintInternal ( out , label , map , new ArrayDeque < Map < ? , ? > > () , true ) ; MST[rv.CRCR4Mutator]MSP[] } public static < K , V > Map < K , V > emptyIfNull ( final Map < K , V > map ) {
if ( sub == null || sub . length < 2 ) { throw new IllegalArgumentException ( lr_4 + i ) ; MST[experimental.NakedReceiverMutator]MSP[] } map . put ( ( K ) sub [ 0 ] , ( V ) sub [ 1 ] ) ; } } else {
return applyDefaultFunction ( map , key , MapUtils :: getFloat , defaultFunction , 0f ) . floatValue () ; MST[NonVoidMethodCallMutator]MSP[] } public static < K > Integer getInteger ( final Map < ? super K , ? > map , final K key ) {
if ( answer instanceof Boolean ) { return ( Boolean ) answer ; } if ( answer instanceof String ) { return Boolean . valueOf ( ( String ) answer ) ; } if ( answer instanceof Number ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] final Number n = ( Number ) answer ;
for ( int i = 0 ; i < array . length - 1 ; ) { MST[rv.CRCR5Mutator]MSP[] map . put ( ( K ) array [ i ++ ] , ( V ) array [ i ++ ] ) ; } } return map ; }
R value = map != null && getFunction != null ? getFunction . apply ( map , key ) : null ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] if ( value == null ) { value = defaultFunction != null ? defaultFunction . apply ( key ) : null ; }
return applyDefaultFunction ( map , key , MapUtils :: getInteger , defaultFunction , 0 ) . byteValue () ; MST[ReturnValsMutator]MSP[] } public static < K > int getIntValue ( final Map < ? super K , ? > map , final K key , final int defaultValue ) {
out . print ( lr_10 + ( lineage . size () - 1 - lineageIndex - 1 ) + lr_11 ) ; MST[NonVoidMethodCallMutator]MSP[] } if ( debug && childValue != null ) { out . print ( ' ' ) ;
return applyDefaultFunction ( map , key , MapUtils :: getBoolean , defaultFunction , false ) . booleanValue () ; MST[NonVoidMethodCallMutator]MSP[] } public static < K > Byte getByte ( final Map < ? super K , ? > map , final K key ) {
final Number answer = getNumber ( map , key ) ; if ( answer == null ) { return null ; } if ( answer instanceof Integer ) { MST[rv.ROR3Mutator]MSP[] return ( Integer ) answer ; } return Integer . valueOf ( answer . intValue () ) ; }
return value == null ? defaultValue : value ; MST[rv.ROR5Mutator]MSP[] } public static void debugPrint ( final PrintStream out , final Object label , final Map < ? , ? > map ) {
if ( map == null ) { MST[rv.ROR5Mutator]MSP[] if ( label != null ) { out . print ( label ) ; out . print ( lr_6 ) ; } out . println ( lr_7 ) ; return; } if ( label != null ) {
return n . intValue () != 0 ? Boolean . TRUE : Boolean . FALSE ; MST[BooleanTrueReturnValsMutator]MSP[] } } } return null ; }
public static < K , V > V getObject ( final Map < K , V > map , final K key , final V defaultValue ) { if ( map != null ) { MST[NegateConditionalsMutator]MSP[] final V answer = map . get ( key ) ;
