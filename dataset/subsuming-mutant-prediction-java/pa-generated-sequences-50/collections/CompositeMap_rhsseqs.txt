return size ; } @Override public Collection < V > values () { final CompositeCollection < V > values = new CompositeCollection <> () ; for ( int i = composite . length - 1 ; i >= 0 ; -- i ) { MST[NegateConditionalsMutator]MSP[N]
final Map < K , V > [] temp = new Map [ size - 1 ] ; System . arraycopy ( this . composite , 0 , temp , 0 , i ) ; MST[rv.UOI4Mutator]MSP[N]
return size ; } @Override public Collection < V > values () { final CompositeCollection < V > values = new CompositeCollection <> () ; for ( int i = composite . length - 1 ; i >= 0 ; -- i ) { MST[InlineConstantMutator]MSP[N]
} return true ; } @Override public Set < K > keySet () { final CompositeSet < K > keys = new CompositeSet <> () ; for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.UOI4Mutator]MSP[N]
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { if ( this . composite [ i ] . containsKey ( key ) ) { MST[rv.UOI4Mutator]MSP[N] return this . composite [ i ] . remove ( key ) ; }
} return null ; } @Override public int size () { int size = 0 ; for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { size += this . composite [ i ] . size () ; MST[rv.AOR3Mutator]MSP[N] }
final Map < ? , ? > map = ( Map < ? , ? > ) obj ; return this . entrySet () . equals ( map . entrySet () ) ; } return false ; MST[rv.CRCR6Mutator]MSP[N] } @Override public int hashCode () { int code = 0 ;
} return this . mutator . put ( this , this . composite , key , value ) ; MST[ReturnValsMutator]MSP[N] } @Override public void putAll ( final Map < ? extends K , ? extends V > map ) { if ( this . mutator == null ) {
System . arraycopy ( this . composite , i + 1 , temp , i , size - i - 1 ) ; MST[rv.UOI3Mutator]MSP[N] this . composite = temp ; return map ; } } return null ; } @Override public void clear () {
for ( final Map . Entry < K , V > entry : entrySet () ) { code += entry . hashCode () ; MST[rv.UOI2Mutator]MSP[N] } return code ; }
} return null ; } @Override public boolean isEmpty () { for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { if ( ! this . composite [ i ] . isEmpty () ) { MST[rv.UOI3Mutator]MSP[N] return false ; }
for ( int i = composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.CRCR6Mutator]MSP[N] entries . addComposited ( composite [ i ] . entrySet () ) ; } return entries ; } @Override public V get ( final Object key ) {
for ( final Map . Entry < K , V > entry : entrySet () ) { code += entry . hashCode () ; MST[NonVoidMethodCallMutator]MSP[N] } return code ; }
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.CRCR2Mutator]MSP[N] this . composite [ i ] . clear () ; } } @Override public boolean containsKey ( final Object key ) {
} return null ; } @Override public int size () { int size = 0 ; for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.AOD2Mutator]MSP[N] size += this . composite [ i ] . size () ; }
keys . addComposited ( this . composite [ i ] . keySet () ) ; MST[rv.ABSMutator]MSP[S] } return keys ; } @Override public V put ( final K key , final V value ) { if ( this . mutator == null ) { throw new UnsupportedOperationException ( lr_3 ) ;
for ( int i = composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.UOI3Mutator]MSP[N] entries . addComposited ( composite [ i ] . entrySet () ) ; } return entries ; } @Override public V get ( final Object key ) {
} return null ; } @Override public int size () { int size = 0 ; for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.CRCR3Mutator]MSP[N] size += this . composite [ i ] . size () ; }
final int size = this . composite . length ; for ( int i = 0 ; i < size ; ++ i ) { MST[rv.ABSMutator]MSP[N] if ( this . composite [ i ] . equals ( map ) ) {
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { if ( this . composite [ i ] . containsKey ( key ) ) { return this . composite [ i ] . get ( key ) ; MST[ArgumentPropagationMutator]MSP[N] }
System . arraycopy ( this . composite , i + 1 , temp , i , size - i - 1 ) ; MST[rv.CRCR6Mutator]MSP[N] this . composite = temp ; return map ; } } return null ; } @Override public void clear () {
keys . addComposited ( this . composite [ i ] . keySet () ) ; MST[NonVoidMethodCallMutator]MSP[N] } return keys ; } @Override public V put ( final K key , final V value ) { if ( this . mutator == null ) { throw new UnsupportedOperationException ( lr_3 ) ;
final Map < K , V > [] temp = new Map [ this . composite . length + 1 ] ; MST[rv.CRCR6Mutator]MSP[N] System . arraycopy ( this . composite , 0 , temp , 0 , this . composite . length ) ;
public boolean containsValue ( final Object value ) { for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.ROR1Mutator]MSP[N] if ( this . composite [ i ] . containsValue ( value ) ) { return true ; } }
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.ROR1Mutator]MSP[N] if ( this . composite [ i ] . containsKey ( key ) ) { return true ; } } return false ; } @Override
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.AOD1Mutator]MSP[N] this . composite [ i ] . clear () ; } } @Override public boolean containsKey ( final Object key ) {
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[ConditionalsBoundaryMutator]MSP[N] if ( this . composite [ i ] . containsKey ( key ) ) { return this . composite [ i ] . remove ( key ) ; }
final int size = this . composite . length ; for ( int i = 0 ; i < size ; ++ i ) { if ( this . composite [ i ] . equals ( map ) ) { MST[rv.ROR1Mutator]MSP[S]
return size ; } @Override public Collection < V > values () { final CompositeCollection < V > values = new CompositeCollection <> () ; for ( int i = composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.ROR5Mutator]MSP[S]
} return null ; } @Override public int size () { int size = 0 ; for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.ROR1Mutator]MSP[N] size += this . composite [ i ] . size () ; }
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.ROR2Mutator]MSP[N] if ( this . composite [ i ] . containsKey ( key ) ) { return this . composite [ i ] . get ( key ) ; }
} return null ; } @Override public int size () { int size = 0 ; for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { size += this . composite [ i ] . size () ; MST[rv.AOD1Mutator]MSP[N] }
final int size = this . composite . length ; for ( int i = 0 ; i < size ; ++ i ) { MST[rv.CRCR5Mutator]MSP[S] if ( this . composite [ i ] . equals ( map ) ) {
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.AOD2Mutator]MSP[N] if ( this . composite [ i ] . containsKey ( key ) ) { return true ; } } return false ; } @Override
} return null ; } @Override public int size () { int size = 0 ; MST[rv.CRCR5Mutator]MSP[N] for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { size += this . composite [ i ] . size () ; }
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[ConditionalsBoundaryMutator]MSP[S] this . composite [ i ] . clear () ; } } @Override public boolean containsKey ( final Object key ) {
final Map < K , V > [] temp = new Map [ size - 1 ] ; MST[rv.CRCR5Mutator]MSP[N] System . arraycopy ( this . composite , 0 , temp , 0 , i ) ;
public boolean containsValue ( final Object value ) { for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.AOD2Mutator]MSP[N] if ( this . composite [ i ] . containsValue ( value ) ) { return true ; } }
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[InlineConstantMutator]MSP[N] this . composite [ i ] . clear () ; } } @Override public boolean containsKey ( final Object key ) {
return size ; } @Override public Collection < V > values () { final CompositeCollection < V > values = new CompositeCollection <> () ; for ( int i = composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.UOI4Mutator]MSP[N]
if ( intersect . size () != 0 ) { MST[rv.ROR1Mutator]MSP[N] if ( this . mutator == null ) { throw new IllegalArgumentException ( lr_2 ) ; } this . mutator . resolveCollision ( this , this . composite [ i ] , map , intersect ) ; } }
values . addComposited ( composite [ i ] . values () ) ; MST[rv.ABSMutator]MSP[S] } return values ; } @Override public boolean equals ( final Object obj ) { if ( obj instanceof Map ) {
System . arraycopy ( this . composite , i + 1 , temp , i , size - i - 1 ) ; MST[rv.UOI3Mutator]MSP[N] this . composite = temp ; return map ; } } return null ; } @Override public void clear () {
public boolean containsValue ( final Object value ) { for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.CRCR6Mutator]MSP[N] if ( this . composite [ i ] . containsValue ( value ) ) { return true ; } }
System . arraycopy ( this . composite , i + 1 , temp , i , size - i - 1 ) ; MST[rv.UOI1Mutator]MSP[N] this . composite = temp ; return map ; } } return null ; } @Override public void clear () {
System . arraycopy ( this . composite , i + 1 , temp , i , size - i - 1 ) ; MST[rv.AOR2Mutator]MSP[N] this . composite = temp ; return map ; } } return null ; } @Override public void clear () {
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { if ( this . composite [ i ] . containsKey ( key ) ) { return this . composite [ i ] . remove ( key ) ; MST[rv.ABSMutator]MSP[S] }
keys . addComposited ( this . composite [ i ] . keySet () ) ; } return keys ; } @Override public V put ( final K key , final V value ) { if ( this . mutator == null ) { MST[NegateConditionalsMutator]MSP[N] throw new UnsupportedOperationException ( lr_3 ) ;
for ( final Map . Entry < K , V > entry : entrySet () ) { code += entry . hashCode () ; MST[rv.AOD2Mutator]MSP[S] } return code ; }
keys . addComposited ( this . composite [ i ] . keySet () ) ; } return keys ; } @Override public V put ( final K key , final V value ) { if ( this . mutator == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] throw new UnsupportedOperationException ( lr_3 ) ;
final Map < K , V > [] temp = new Map [ size - 1 ] ; MST[rv.CRCR2Mutator]MSP[N] System . arraycopy ( this . composite , 0 , temp , 0 , i ) ;
public void setMutator ( final MapMutator < K , V > mutator ) { this . mutator = mutator ; } @SuppressWarnings ( lr_1 ) public synchronized void addComposited ( final Map < K , V > map ) throws IllegalArgumentException { if ( map != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
for ( int i = composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.ROR4Mutator]MSP[N] entries . addComposited ( composite [ i ] . entrySet () ) ; } return entries ; } @Override public V get ( final Object key ) {
final Map < K , V > [] temp = new Map [ size - 1 ] ; MST[rv.AOD1Mutator]MSP[N] System . arraycopy ( this . composite , 0 , temp , 0 , i ) ;
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { if ( this . composite [ i ] . containsKey ( key ) ) { return true ; } } return false ; MST[rv.CRCR6Mutator]MSP[N] } @Override
return size ; } @Override public Collection < V > values () { final CompositeCollection < V > values = new CompositeCollection <> () ; for ( int i = composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.AOD1Mutator]MSP[N]
for ( int i = composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.CRCR4Mutator]MSP[N] final Collection < K > intersect = CollectionUtils . intersection ( this . composite [ i ] . keySet () , map . keySet () ) ;
final Map < K , V > [] temp = new Map [ this . composite . length + 1 ] ; System . arraycopy ( this . composite , 0 , temp , 0 , this . composite . length ) ; MST[rv.CRCR5Mutator]MSP[N]
final Map < ? , ? > map = ( Map < ? , ? > ) obj ; return this . entrySet () . equals ( map . entrySet () ) ; MST[ReturnValsMutator]MSP[N] } return false ; } @Override public int hashCode () { int code = 0 ;
final Map < K , V > [] temp = new Map [ size - 1 ] ; MST[rv.ABSMutator]MSP[N] System . arraycopy ( this . composite , 0 , temp , 0 , i ) ;
} return this . mutator . put ( this , this . composite , key , value ) ; MST[NullReturnValsMutator]MSP[S] } @Override public void putAll ( final Map < ? extends K , ? extends V > map ) { if ( this . mutator == null ) {
for ( int i = composite . length - 1 ; i >= 0 ; -- i ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] entries . addComposited ( composite [ i ] . entrySet () ) ; } return entries ; } @Override public V get ( final Object key ) {
keys . addComposited ( this . composite [ i ] . keySet () ) ; MST[rv.UOI2Mutator]MSP[N] } return keys ; } @Override public V put ( final K key , final V value ) { if ( this . mutator == null ) { throw new UnsupportedOperationException ( lr_3 ) ;
for ( int i = composite . length - 1 ; i >= 0 ; -- i ) { final Collection < K > intersect = CollectionUtils . intersection ( this . composite [ i ] . keySet () , map . keySet () ) ; MST[NonVoidMethodCallMutator]MSP[N]
for ( int i = composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.AOR2Mutator]MSP[N] entries . addComposited ( composite [ i ] . entrySet () ) ; } return entries ; } @Override public V get ( final Object key ) {
} return true ; } @Override public Set < K > keySet () { final CompositeSet < K > keys = new CompositeSet <> () ; for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.ROR5Mutator]MSP[N]
} return true ; } @Override public Set < K > keySet () { final CompositeSet < K > keys = new CompositeSet <> () ; for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.ROR2Mutator]MSP[N]
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.ROR5Mutator]MSP[S] if ( this . composite [ i ] . containsKey ( key ) ) { return this . composite [ i ] . get ( key ) ; }
} return true ; MST[rv.CRCR3Mutator]MSP[N] } @Override public Set < K > keySet () { final CompositeSet < K > keys = new CompositeSet <> () ; for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) {
for ( int i = composite . length - 1 ; i >= 0 ; -- i ) { MST[NegateConditionalsMutator]MSP[N] final Collection < K > intersect = CollectionUtils . intersection ( this . composite [ i ] . keySet () , map . keySet () ) ;
System . arraycopy ( this . composite , i + 1 , temp , i , size - i - 1 ) ; MST[rv.AOR3Mutator]MSP[N] this . composite = temp ; return map ; } } return null ; } @Override public void clear () {
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.ABSMutator]MSP[N] if ( this . composite [ i ] . containsKey ( key ) ) { return this . composite [ i ] . remove ( key ) ; }
if ( intersect . size () != 0 ) { if ( this . mutator == null ) { throw new IllegalArgumentException ( lr_2 ) ; MST[ConstructorCallMutator]MSP[S] } this . mutator . resolveCollision ( this , this . composite [ i ] , map , intersect ) ; } }
temp [ temp . length - 1 ] = map ; MST[rv.AOD1Mutator]MSP[N] this . composite = temp ; } } @SuppressWarnings ( lr_1 ) public synchronized Map < K , V > removeComposited ( final Map < K , V > map ) {
for ( int i = composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.UOI4Mutator]MSP[N] final Collection < K > intersect = CollectionUtils . intersection ( this . composite [ i ] . keySet () , map . keySet () ) ;
for ( int i = composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.ROR1Mutator]MSP[N] entries . addComposited ( composite [ i ] . entrySet () ) ; } return entries ; } @Override public V get ( final Object key ) {
} return true ; } @Override public Set < K > keySet () { final CompositeSet < K > keys = new CompositeSet <> () ; for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.CRCR2Mutator]MSP[N]
} return true ; } @Override public Set < K > keySet () { final CompositeSet < K > keys = new CompositeSet <> () ; for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.AOR3Mutator]MSP[N]
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { if ( this . composite [ i ] . containsKey ( key ) ) { MST[rv.ROR1Mutator]MSP[S] return this . composite [ i ] . remove ( key ) ; }
temp [ temp . length - 1 ] = map ; MST[InlineConstantMutator]MSP[N] this . composite = temp ; } } @SuppressWarnings ( lr_1 ) public synchronized Map < K , V > removeComposited ( final Map < K , V > map ) {
final int size = this . composite . length ; for ( int i = 0 ; i < size ; ++ i ) { if ( this . composite [ i ] . equals ( map ) ) { MST[rv.UOI4Mutator]MSP[N]
public boolean containsValue ( final Object value ) { for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { if ( this . composite [ i ] . containsValue ( value ) ) { MST[rv.ABSMutator]MSP[S] return true ; } }
public boolean containsValue ( final Object value ) { for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.ROR4Mutator]MSP[N] if ( this . composite [ i ] . containsValue ( value ) ) { return true ; } }
final int size = this . composite . length ; for ( int i = 0 ; i < size ; ++ i ) { MST[rv.UOI2Mutator]MSP[N] if ( this . composite [ i ] . equals ( map ) ) {
final Map < K , V > [] temp = new Map [ size - 1 ] ; System . arraycopy ( this . composite , 0 , temp , 0 , i ) ; MST[rv.UOI1Mutator]MSP[N]
final Map < ? , ? > map = ( Map < ? , ? > ) obj ; return this . entrySet () . equals ( map . entrySet () ) ; } return false ; MST[rv.CRCR1Mutator]MSP[N] } @Override public int hashCode () { int code = 0 ;
} return null ; } @Override public int size () { int size = 0 ; for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { size += this . composite [ i ] . size () ; MST[rv.UOI2Mutator]MSP[N] }
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { if ( this . composite [ i ] . containsKey ( key ) ) { MST[rv.ROR5Mutator]MSP[N] return this . composite [ i ] . get ( key ) ; }
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.UOI2Mutator]MSP[N] this . composite [ i ] . clear () ; } } @Override public boolean containsKey ( final Object key ) {
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { if ( this . composite [ i ] . containsKey ( key ) ) { MST[rv.ROR3Mutator]MSP[N] return this . composite [ i ] . get ( key ) ; }
for ( int i = composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.AOR3Mutator]MSP[N] final Collection < K > intersect = CollectionUtils . intersection ( this . composite [ i ] . keySet () , map . keySet () ) ;
final Map < K , V > [] temp = new Map [ size - 1 ] ; MST[InlineConstantMutator]MSP[N] System . arraycopy ( this . composite , 0 , temp , 0 , i ) ;
} return true ; } @Override public Set < K > keySet () { final CompositeSet < K > keys = new CompositeSet <> () ; for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.CRCR4Mutator]MSP[N]
final int size = this . composite . length ; for ( int i = 0 ; i < size ; ++ i ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] if ( this . composite [ i ] . equals ( map ) ) {
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.AOR1Mutator]MSP[N] if ( this . composite [ i ] . containsKey ( key ) ) { return this . composite [ i ] . remove ( key ) ; }
} return this . mutator . put ( this , this . composite , key , value ) ; } @Override public void putAll ( final Map < ? extends K , ? extends V > map ) { if ( this . mutator == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S]
System . arraycopy ( this . composite , i + 1 , temp , i , size - i - 1 ) ; MST[rv.AOD1Mutator]MSP[S] this . composite = temp ; return map ; } } return null ; } @Override public void clear () {
for ( final Map . Entry < K , V > entry : entrySet () ) { code += entry . hashCode () ; } return code ; MST[PrimitiveReturnsMutator]MSP[N] }
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { if ( this . composite [ i ] . containsKey ( key ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] return this . composite [ i ] . get ( key ) ; }
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[NegateConditionalsMutator]MSP[N] if ( this . composite [ i ] . containsKey ( key ) ) { return this . composite [ i ] . remove ( key ) ; }
System . arraycopy ( this . composite , i + 1 , temp , i , size - i - 1 ) ; MST[rv.ABSMutator]MSP[N] this . composite = temp ; return map ; } } return null ; } @Override public void clear () {
final int size = this . composite . length ; for ( int i = 0 ; i < size ; ++ i ) { MST[ConditionalsBoundaryMutator]MSP[S] if ( this . composite [ i ] . equals ( map ) ) {
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { if ( this . composite [ i ] . containsKey ( key ) ) { return true ; MST[rv.CRCR2Mutator]MSP[N] } } return false ; } @Override
final Map < K , V > [] temp = new Map [ size - 1 ] ; MST[rv.UOI2Mutator]MSP[N] System . arraycopy ( this . composite , 0 , temp , 0 , i ) ;
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { if ( this . composite [ i ] . containsKey ( key ) ) { MST[rv.ROR2Mutator]MSP[N] return true ; } } return false ; } @Override
public boolean containsValue ( final Object value ) { for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { if ( this . composite [ i ] . containsValue ( value ) ) { MST[rv.UOI2Mutator]MSP[N] return true ; } }
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[InlineConstantMutator]MSP[N] if ( this . composite [ i ] . containsKey ( key ) ) { return this . composite [ i ] . remove ( key ) ; }
} return null ; } @Override public boolean isEmpty () { for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { if ( ! this . composite [ i ] . isEmpty () ) { return false ; MST[rv.CRCR6Mutator]MSP[N] }
final Map < K , V > [] temp = new Map [ this . composite . length + 1 ] ; System . arraycopy ( this . composite , 0 , temp , 0 , this . composite . length ) ; MST[rv.CRCR5Mutator]MSP[N]
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { if ( this . composite [ i ] . containsKey ( key ) ) { MST[rv.UOI2Mutator]MSP[N] return true ; } } return false ; } @Override
final int size = this . composite . length ; for ( int i = 0 ; i < size ; ++ i ) { if ( this . composite [ i ] . equals ( map ) ) { MST[rv.ROR4Mutator]MSP[N]
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.ROR5Mutator]MSP[N] this . composite [ i ] . clear () ; } } @Override public boolean containsKey ( final Object key ) {
for ( int i = composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.AOD1Mutator]MSP[N] final Collection < K > intersect = CollectionUtils . intersection ( this . composite [ i ] . keySet () , map . keySet () ) ;
for ( int i = composite . length - 1 ; i >= 0 ; -- i ) { final Collection < K > intersect = CollectionUtils . intersection ( this . composite [ i ] . keySet () , map . keySet () ) ; MST[rv.UOI3Mutator]MSP[N]
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.AOR3Mutator]MSP[N] if ( this . composite [ i ] . containsKey ( key ) ) { return this . composite [ i ] . get ( key ) ; }
System . arraycopy ( this . composite , i + 1 , temp , i , size - i - 1 ) ; MST[rv.UOI4Mutator]MSP[N] this . composite = temp ; return map ; } } return null ; } @Override public void clear () {
} return true ; } @Override public Set < K > keySet () { final CompositeSet < K > keys = new CompositeSet <> () ; for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[ConditionalsBoundaryMutator]MSP[N]
values . addComposited ( composite [ i ] . values () ) ; } return values ; } @Override public boolean equals ( final Object obj ) { if ( obj instanceof Map ) { MST[rv.ROR2Mutator]MSP[N]
for ( int i = composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.UOI1Mutator]MSP[N] final Collection < K > intersect = CollectionUtils . intersection ( this . composite [ i ] . keySet () , map . keySet () ) ;
} return this . mutator . put ( this , this . composite , key , value ) ; } @Override public void putAll ( final Map < ? extends K , ? extends V > map ) { if ( this . mutator == null ) { MST[NegateConditionalsMutator]MSP[S]
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[InlineConstantMutator]MSP[N] if ( this . composite [ i ] . containsKey ( key ) ) { return this . composite [ i ] . get ( key ) ; }
} return null ; } @Override public boolean isEmpty () { for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.UOI1Mutator]MSP[N] if ( ! this . composite [ i ] . isEmpty () ) { return false ; }
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { if ( this . composite [ i ] . containsKey ( key ) ) { MST[rv.ROR3Mutator]MSP[N] return this . composite [ i ] . remove ( key ) ; }
final Map < K , V > [] temp = new Map [ size - 1 ] ; MST[rv.AOR3Mutator]MSP[N] System . arraycopy ( this . composite , 0 , temp , 0 , i ) ;
for ( int i = composite . length - 1 ; i >= 0 ; -- i ) { MST[IncrementsMutator]MSP[N] final Collection < K > intersect = CollectionUtils . intersection ( this . composite [ i ] . keySet () , map . keySet () ) ;
return size ; MST[rv.UOI2Mutator]MSP[N] } @Override public Collection < V > values () { final CompositeCollection < V > values = new CompositeCollection <> () ; for ( int i = composite . length - 1 ; i >= 0 ; -- i ) {
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] if ( this . composite [ i ] . containsKey ( key ) ) { return true ; } } return false ; } @Override
return size ; } @Override public Collection < V > values () { final CompositeCollection < V > values = new CompositeCollection <> () ; for ( int i = composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.CRCR5Mutator]MSP[N]
for ( int i = composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.AOR4Mutator]MSP[S] entries . addComposited ( composite [ i ] . entrySet () ) ; } return entries ; } @Override public V get ( final Object key ) {
} return null ; } @Override public int size () { int size = 0 ; for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.CRCR6Mutator]MSP[N] size += this . composite [ i ] . size () ; }
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { if ( this . composite [ i ] . containsKey ( key ) ) { MST[rv.ABSMutator]MSP[N] return true ; } } return false ; } @Override
final Map < K , V > [] temp = new Map [ size - 1 ] ; System . arraycopy ( this . composite , 0 , temp , 0 , i ) ; MST[rv.CRCR1Mutator]MSP[N]
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.ROR4Mutator]MSP[N] if ( this . composite [ i ] . containsKey ( key ) ) { return true ; } } return false ; } @Override
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { if ( this . composite [ i ] . containsKey ( key ) ) { MST[NonVoidMethodCallMutator]MSP[N] return this . composite [ i ] . get ( key ) ; }
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.UOI2Mutator]MSP[N] if ( this . composite [ i ] . containsKey ( key ) ) { return this . composite [ i ] . remove ( key ) ; }
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { this . composite [ i ] . clear () ; MST[rv.UOI4Mutator]MSP[N] } } @Override public boolean containsKey ( final Object key ) {
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.CRCR4Mutator]MSP[N] if ( this . composite [ i ] . containsKey ( key ) ) { return this . composite [ i ] . get ( key ) ; }
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[NegateConditionalsMutator]MSP[N] this . composite [ i ] . clear () ; } } @Override public boolean containsKey ( final Object key ) {
} return true ; } @Override public Set < K > keySet () { final CompositeSet < K > keys = new CompositeSet <> () ; for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[InlineConstantMutator]MSP[N]
if ( intersect . size () != 0 ) { MST[rv.ROR3Mutator]MSP[N] if ( this . mutator == null ) { throw new IllegalArgumentException ( lr_2 ) ; } this . mutator . resolveCollision ( this , this . composite [ i ] , map , intersect ) ; } }
final Map < K , V > [] temp = new Map [ this . composite . length + 1 ] ; MST[MathMutator]MSP[N] System . arraycopy ( this . composite , 0 , temp , 0 , this . composite . length ) ;
final Map < K , V > [] temp = new Map [ this . composite . length + 1 ] ; MST[rv.AOR2Mutator]MSP[N] System . arraycopy ( this . composite , 0 , temp , 0 , this . composite . length ) ;
values . addComposited ( composite [ i ] . values () ) ; MST[NonVoidMethodCallMutator]MSP[N] } return values ; } @Override public boolean equals ( final Object obj ) { if ( obj instanceof Map ) {
System . arraycopy ( this . composite , i + 1 , temp , i , size - i - 1 ) ; MST[rv.UOI3Mutator]MSP[N] this . composite = temp ; return map ; } } return null ; } @Override public void clear () {
for ( int i = composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.ROR2Mutator]MSP[N] final Collection < K > intersect = CollectionUtils . intersection ( this . composite [ i ] . keySet () , map . keySet () ) ;
temp [ temp . length - 1 ] = map ; MST[rv.AOR3Mutator]MSP[N] this . composite = temp ; } } @SuppressWarnings ( lr_1 ) public synchronized Map < K , V > removeComposited ( final Map < K , V > map ) {
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.AOR4Mutator]MSP[N] if ( this . composite [ i ] . containsKey ( key ) ) { return true ; } } return false ; } @Override
return size ; } @Override public Collection < V > values () { final CompositeCollection < V > values = new CompositeCollection <> () ; for ( int i = composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.CRCR4Mutator]MSP[N]
} return null ; } @Override public boolean isEmpty () { for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.CRCR6Mutator]MSP[N] if ( ! this . composite [ i ] . isEmpty () ) { return false ; }
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { if ( this . composite [ i ] . containsKey ( key ) ) { return this . composite [ i ] . get ( key ) ; MST[rv.UOI4Mutator]MSP[N] }
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] if ( this . composite [ i ] . containsKey ( key ) ) { return this . composite [ i ] . remove ( key ) ; }
} return null ; } @Override public int size () { int size = 0 ; for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { size += this . composite [ i ] . size () ; MST[rv.UOI3Mutator]MSP[N] }
final int size = this . composite . length ; for ( int i = 0 ; i < size ; ++ i ) { if ( this . composite [ i ] . equals ( map ) ) { MST[rv.ROR3Mutator]MSP[N]
public boolean containsValue ( final Object value ) { for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.AOR4Mutator]MSP[S] if ( this . composite [ i ] . containsValue ( value ) ) { return true ; } }
} return null ; } @Override public boolean isEmpty () { for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { if ( ! this . composite [ i ] . isEmpty () ) { return false ; MST[rv.CRCR1Mutator]MSP[N] }
temp [ temp . length - 1 ] = map ; MST[rv.CRCR4Mutator]MSP[N] this . composite = temp ; } } @SuppressWarnings ( lr_1 ) public synchronized Map < K , V > removeComposited ( final Map < K , V > map ) {
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[S] this . composite [ i ] . clear () ; } } @Override public boolean containsKey ( final Object key ) {
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.AOR2Mutator]MSP[N] if ( this . composite [ i ] . containsKey ( key ) ) { return this . composite [ i ] . get ( key ) ; }
return size ; } @Override public Collection < V > values () { final CompositeCollection < V > values = new CompositeCollection <> () ; for ( int i = composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.ROR2Mutator]MSP[N]
for ( final Map . Entry < K , V > entry : entrySet () ) { code += entry . hashCode () ; MST[rv.AOR4Mutator]MSP[N] } return code ; }
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { if ( this . composite [ i ] . containsKey ( key ) ) { MST[NegateConditionalsMutator]MSP[N] return this . composite [ i ] . get ( key ) ; }
} return null ; } @Override public boolean isEmpty () { for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] if ( ! this . composite [ i ] . isEmpty () ) { return false ; }
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.ROR5Mutator]MSP[N] if ( this . composite [ i ] . containsKey ( key ) ) { return this . composite [ i ] . remove ( key ) ; }
for ( final Map . Entry < K , V > entry : entrySet () ) { code += entry . hashCode () ; } return code ; MST[rv.UOI2Mutator]MSP[N] }
for ( final Map . Entry < K , V > entry : entrySet () ) { code += entry . hashCode () ; MST[rv.ABSMutator]MSP[S] } return code ; }
} return null ; } @Override public int size () { int size = 0 ; for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.ROR3Mutator]MSP[N] size += this . composite [ i ] . size () ; }
values . addComposited ( composite [ i ] . values () ) ; MST[rv.UOI2Mutator]MSP[N] } return values ; } @Override public boolean equals ( final Object obj ) { if ( obj instanceof Map ) {
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.CRCR6Mutator]MSP[N] if ( this . composite [ i ] . containsKey ( key ) ) { return true ; } } return false ; } @Override
} return null ; } @Override public boolean isEmpty () { for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.ROR4Mutator]MSP[N] if ( ! this . composite [ i ] . isEmpty () ) { return false ; }
} return null ; } @Override public boolean isEmpty () { for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { if ( ! this . composite [ i ] . isEmpty () ) { MST[rv.ROR1Mutator]MSP[N] return false ; }
final int size = this . composite . length ; for ( int i = 0 ; i < size ; ++ i ) { MST[rv.CRCR3Mutator]MSP[N] if ( this . composite [ i ] . equals ( map ) ) {
} return null ; } @Override public int size () { int size = 0 ; for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.AOR4Mutator]MSP[N] size += this . composite [ i ] . size () ; }
final int size = this . composite . length ; for ( int i = 0 ; i < size ; ++ i ) { MST[InlineConstantMutator]MSP[S] if ( this . composite [ i ] . equals ( map ) ) {
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.CRCR2Mutator]MSP[N] if ( this . composite [ i ] . containsKey ( key ) ) { return this . composite [ i ] . remove ( key ) ; }
return size ; } @Override public Collection < V > values () { final CompositeCollection < V > values = new CompositeCollection <> () ; for ( int i = composite . length - 1 ; i >= 0 ; -- i ) { MST[IncrementsMutator]MSP[N]
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.UOI4Mutator]MSP[N] if ( this . composite [ i ] . containsKey ( key ) ) { return this . composite [ i ] . get ( key ) ; }
return size ; } @Override public Collection < V > values () { final CompositeCollection < V > values = new CompositeCollection <> () ; for ( int i = composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.AOR3Mutator]MSP[N]
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { if ( this . composite [ i ] . containsKey ( key ) ) { MST[rv.ROR1Mutator]MSP[N] return true ; } } return false ; } @Override
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { if ( this . composite [ i ] . containsKey ( key ) ) { return this . composite [ i ] . remove ( key ) ; MST[rv.UOI2Mutator]MSP[N] }
} return null ; } @Override public int size () { int size = 0 ; MST[InlineConstantMutator]MSP[N] for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { size += this . composite [ i ] . size () ; }
final Map < K , V > [] temp = new Map [ size - 1 ] ; System . arraycopy ( this . composite , 0 , temp , 0 , i ) ; MST[rv.CRCR1Mutator]MSP[S]
final Map < K , V > [] temp = new Map [ this . composite . length + 1 ] ; MST[rv.CRCR3Mutator]MSP[N] System . arraycopy ( this . composite , 0 , temp , 0 , this . composite . length ) ;
final int size = this . composite . length ; for ( int i = 0 ; i < size ; ++ i ) { MST[rv.UOI3Mutator]MSP[N] if ( this . composite [ i ] . equals ( map ) ) {
if ( intersect . size () != 0 ) { if ( this . mutator == null ) { MST[NegateConditionalsMutator]MSP[N] throw new IllegalArgumentException ( lr_2 ) ; } this . mutator . resolveCollision ( this , this . composite [ i ] , map , intersect ) ; } }
} return null ; } @Override public int size () { int size = 0 ; for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.UOI2Mutator]MSP[N] size += this . composite [ i ] . size () ; }
public boolean containsValue ( final Object value ) { for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { if ( this . composite [ i ] . containsValue ( value ) ) { MST[rv.ROR1Mutator]MSP[N] return true ; } }
final Map < K , V > [] temp = new Map [ size - 1 ] ; System . arraycopy ( this . composite , 0 , temp , 0 , i ) ; MST[rv.UOI2Mutator]MSP[N]
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { if ( this . composite [ i ] . containsKey ( key ) ) { return this . composite [ i ] . remove ( key ) ; MST[ArgumentPropagationMutator]MSP[N] }
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.UOI1Mutator]MSP[N] this . composite [ i ] . clear () ; } } @Override public boolean containsKey ( final Object key ) {
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { if ( this . composite [ i ] . containsKey ( key ) ) { MST[rv.UOI2Mutator]MSP[N] return this . composite [ i ] . remove ( key ) ; }
public boolean containsValue ( final Object value ) { for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { if ( this . composite [ i ] . containsValue ( value ) ) { return true ; MST[rv.CRCR5Mutator]MSP[N] } }
System . arraycopy ( this . composite , i + 1 , temp , i , size - i - 1 ) ; MST[rv.UOI1Mutator]MSP[N] this . composite = temp ; return map ; } } return null ; } @Override public void clear () {
for ( int i = composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.AOR2Mutator]MSP[N] final Collection < K > intersect = CollectionUtils . intersection ( this . composite [ i ] . keySet () , map . keySet () ) ;
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.AOR4Mutator]MSP[N] if ( this . composite [ i ] . containsKey ( key ) ) { return this . composite [ i ] . remove ( key ) ; }
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { if ( this . composite [ i ] . containsKey ( key ) ) { MST[rv.ROR4Mutator]MSP[N] return this . composite [ i ] . remove ( key ) ; }
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.CRCR4Mutator]MSP[N] this . composite [ i ] . clear () ; } } @Override public boolean containsKey ( final Object key ) {
final Map < K , V > [] temp = new Map [ size - 1 ] ; MST[rv.AOR4Mutator]MSP[N] System . arraycopy ( this . composite , 0 , temp , 0 , i ) ;
final Map < K , V > [] temp = new Map [ size - 1 ] ; System . arraycopy ( this . composite , 0 , temp , 0 , i ) ; MST[rv.CRCR6Mutator]MSP[N]
public boolean containsValue ( final Object value ) { for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.ROR3Mutator]MSP[N] if ( this . composite [ i ] . containsValue ( value ) ) { return true ; } }
for ( int i = composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.UOI1Mutator]MSP[N] entries . addComposited ( composite [ i ] . entrySet () ) ; } return entries ; } @Override public V get ( final Object key ) {
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[MathMutator]MSP[N] if ( this . composite [ i ] . containsKey ( key ) ) { return this . composite [ i ] . remove ( key ) ; }
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.ROR3Mutator]MSP[N] if ( this . composite [ i ] . containsKey ( key ) ) { return true ; } } return false ; } @Override
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { if ( this . composite [ i ] . containsKey ( key ) ) { return true ; MST[ReturnValsMutator]MSP[N] } } return false ; } @Override
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { if ( this . composite [ i ] . containsKey ( key ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return true ; } } return false ; } @Override
} return null ; } @Override public boolean isEmpty () { for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.AOR3Mutator]MSP[N] if ( ! this . composite [ i ] . isEmpty () ) { return false ; }
keys . addComposited ( this . composite [ i ] . keySet () ) ; MST[rv.UOI4Mutator]MSP[N] } return keys ; } @Override public V put ( final K key , final V value ) { if ( this . mutator == null ) { throw new UnsupportedOperationException ( lr_3 ) ;
} return null ; } @Override public boolean isEmpty () { for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { if ( ! this . composite [ i ] . isEmpty () ) { return false ; MST[BooleanTrueReturnValsMutator]MSP[N] }
values . addComposited ( composite [ i ] . values () ) ; } return values ; } @Override public boolean equals ( final Object obj ) { if ( obj instanceof Map ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { if ( this . composite [ i ] . containsKey ( key ) ) { return this . composite [ i ] . get ( key ) ; MST[rv.UOI2Mutator]MSP[N] }
} return true ; MST[ReturnValsMutator]MSP[N] } @Override public Set < K > keySet () { final CompositeSet < K > keys = new CompositeSet <> () ; for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) {
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.CRCR5Mutator]MSP[N] if ( this . composite [ i ] . containsKey ( key ) ) { return true ; } } return false ; } @Override
System . arraycopy ( this . composite , i + 1 , temp , i , size - i - 1 ) ; MST[rv.CRCR6Mutator]MSP[N] this . composite = temp ; return map ; } } return null ; } @Override public void clear () {
System . arraycopy ( this . composite , i + 1 , temp , i , size - i - 1 ) ; MST[rv.CRCR2Mutator]MSP[N] this . composite = temp ; return map ; } } return null ; } @Override public void clear () {
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { if ( this . composite [ i ] . containsKey ( key ) ) { MST[rv.UOI4Mutator]MSP[N] return this . composite [ i ] . get ( key ) ; }
final Map < K , V > [] temp = new Map [ size - 1 ] ; MST[rv.UOI3Mutator]MSP[N] System . arraycopy ( this . composite , 0 , temp , 0 , i ) ;
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.AOR1Mutator]MSP[N] this . composite [ i ] . clear () ; } } @Override public boolean containsKey ( final Object key ) {
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] if ( this . composite [ i ] . containsKey ( key ) ) { return this . composite [ i ] . get ( key ) ; }
final Map < ? , ? > map = ( Map < ? , ? > ) obj ; return this . entrySet () . equals ( map . entrySet () ) ; MST[NonVoidMethodCallMutator]MSP[N] } return false ; } @Override public int hashCode () { int code = 0 ;
public boolean containsValue ( final Object value ) { for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { if ( this . composite [ i ] . containsValue ( value ) ) { MST[rv.ROR5Mutator]MSP[N] return true ; } }
public void setMutator ( final MapMutator < K , V > mutator ) { this . mutator = mutator ; } @SuppressWarnings ( lr_1 ) public synchronized void addComposited ( final Map < K , V > map ) throws IllegalArgumentException { if ( map != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
final int size = this . composite . length ; for ( int i = 0 ; i < size ; ++ i ) { MST[rv.ROR5Mutator]MSP[N] if ( this . composite [ i ] . equals ( map ) ) {
final int size = this . composite . length ; for ( int i = 0 ; i < size ; ++ i ) { MST[rv.ROR1Mutator]MSP[N] if ( this . composite [ i ] . equals ( map ) ) {
System . arraycopy ( this . composite , i + 1 , temp , i , size - i - 1 ) ; MST[rv.UOI4Mutator]MSP[N] this . composite = temp ; return map ; } } return null ; } @Override public void clear () {
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.CRCR5Mutator]MSP[N] if ( this . composite [ i ] . containsKey ( key ) ) { return this . composite [ i ] . get ( key ) ; }
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.CRCR2Mutator]MSP[N] if ( this . composite [ i ] . containsKey ( key ) ) { return this . composite [ i ] . get ( key ) ; }
} return null ; } @Override public boolean isEmpty () { for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.AOD1Mutator]MSP[N] if ( ! this . composite [ i ] . isEmpty () ) { return false ; }
System . arraycopy ( this . composite , i + 1 , temp , i , size - i - 1 ) ; MST[MathMutator]MSP[S] this . composite = temp ; return map ; } } return null ; } @Override public void clear () {
return size ; } @Override public Collection < V > values () { final CompositeCollection < V > values = new CompositeCollection <> () ; MST[ConstructorCallMutator]MSP[N] for ( int i = composite . length - 1 ; i >= 0 ; -- i ) {
return size ; } @Override public Collection < V > values () { final CompositeCollection < V > values = new CompositeCollection <> () ; for ( int i = composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.UOI1Mutator]MSP[N]
} return this . mutator . put ( this , this . composite , key , value ) ; MST[NonVoidMethodCallMutator]MSP[N] } @Override public void putAll ( final Map < ? extends K , ? extends V > map ) { if ( this . mutator == null ) {
final Map < ? , ? > map = ( Map < ? , ? > ) obj ; return this . entrySet () . equals ( map . entrySet () ) ; } return false ; } @Override public int hashCode () { int code = 0 ; MST[rv.CRCR3Mutator]MSP[N]
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { this . composite [ i ] . clear () ; MST[rv.UOI3Mutator]MSP[N] } } @Override public boolean containsKey ( final Object key ) {
public boolean containsValue ( final Object value ) { for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.CRCR4Mutator]MSP[N] if ( this . composite [ i ] . containsValue ( value ) ) { return true ; } }
System . arraycopy ( this . composite , i + 1 , temp , i , size - i - 1 ) ; MST[rv.AOD1Mutator]MSP[N] this . composite = temp ; return map ; } } return null ; } @Override public void clear () {
for ( int i = composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.ABSMutator]MSP[N] final Collection < K > intersect = CollectionUtils . intersection ( this . composite [ i ] . keySet () , map . keySet () ) ;
for ( int i = composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.ROR4Mutator]MSP[N] final Collection < K > intersect = CollectionUtils . intersection ( this . composite [ i ] . keySet () , map . keySet () ) ;
final int size = this . composite . length ; for ( int i = 0 ; i < size ; ++ i ) { MST[rv.UOI4Mutator]MSP[N] if ( this . composite [ i ] . equals ( map ) ) {
final int size = this . composite . length ; for ( int i = 0 ; i < size ; ++ i ) { MST[NegateConditionalsMutator]MSP[N] if ( this . composite [ i ] . equals ( map ) ) {
} return null ; } @Override public int size () { int size = 0 ; for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[IncrementsMutator]MSP[N] size += this . composite [ i ] . size () ; }
for ( int i = composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.ABSMutator]MSP[N] entries . addComposited ( composite [ i ] . entrySet () ) ; } return entries ; } @Override public V get ( final Object key ) {
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.AOD2Mutator]MSP[N] if ( this . composite [ i ] . containsKey ( key ) ) { return this . composite [ i ] . remove ( key ) ; }
} return null ; MST[ReturnValsMutator]MSP[N] } @Override public boolean isEmpty () { for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { if ( ! this . composite [ i ] . isEmpty () ) { return false ; }
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.CRCR3Mutator]MSP[N] if ( this . composite [ i ] . containsKey ( key ) ) { return this . composite [ i ] . remove ( key ) ; }
public void setMutator ( final MapMutator < K , V > mutator ) { this . mutator = mutator ; } @SuppressWarnings ( lr_1 ) public synchronized void addComposited ( final Map < K , V > map ) throws IllegalArgumentException { if ( map != null ) { MST[rv.ROR5Mutator]MSP[N]
} return null ; } @Override public boolean isEmpty () { for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.CRCR2Mutator]MSP[N] if ( ! this . composite [ i ] . isEmpty () ) { return false ; }
public boolean containsValue ( final Object value ) { for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.UOI2Mutator]MSP[N] if ( this . composite [ i ] . containsValue ( value ) ) { return true ; } }
for ( int i = composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.CRCR6Mutator]MSP[N] final Collection < K > intersect = CollectionUtils . intersection ( this . composite [ i ] . keySet () , map . keySet () ) ;
public boolean containsValue ( final Object value ) { for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { if ( this . composite [ i ] . containsValue ( value ) ) { MST[NegateConditionalsMutator]MSP[N] return true ; } }
final int size = this . composite . length ; for ( int i = 0 ; i < size ; ++ i ) { if ( this . composite [ i ] . equals ( map ) ) { MST[NonVoidMethodCallMutator]MSP[N]
return false ; } @Override public Set < Map . Entry < K , V > > entrySet () { final CompositeSet < Map . Entry < K , V > > entries = new CompositeSet <> () ; MST[ConstructorCallMutator]MSP[N]
return size ; } @Override public Collection < V > values () { final CompositeCollection < V > values = new CompositeCollection <> () ; for ( int i = composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.ABSMutator]MSP[N]
for ( final Map . Entry < K , V > entry : entrySet () ) { code += entry . hashCode () ; } return code ; MST[rv.UOI3Mutator]MSP[N] }
final int size = this . composite . length ; for ( int i = 0 ; i < size ; ++ i ) { MST[IncrementsMutator]MSP[N] if ( this . composite [ i ] . equals ( map ) ) {
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { if ( this . composite [ i ] . containsKey ( key ) ) { return this . composite [ i ] . remove ( key ) ; MST[NullReturnValsMutator]MSP[S] }
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.ROR1Mutator]MSP[N] if ( this . composite [ i ] . containsKey ( key ) ) { return this . composite [ i ] . remove ( key ) ; }
} return true ; MST[rv.CRCR6Mutator]MSP[N] } @Override public Set < K > keySet () { final CompositeSet < K > keys = new CompositeSet <> () ; for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) {
} return null ; } @Override public boolean isEmpty () { for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.ROR5Mutator]MSP[N] if ( ! this . composite [ i ] . isEmpty () ) { return false ; }
System . arraycopy ( this . composite , i + 1 , temp , i , size - i - 1 ) ; MST[rv.ABSMutator]MSP[S] this . composite = temp ; return map ; } } return null ; } @Override public void clear () {
for ( int i = composite . length - 1 ; i >= 0 ; -- i ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] final Collection < K > intersect = CollectionUtils . intersection ( this . composite [ i ] . keySet () , map . keySet () ) ;
System . arraycopy ( this . composite , i + 1 , temp , i , size - i - 1 ) ; MST[rv.CRCR3Mutator]MSP[S] this . composite = temp ; return map ; } } return null ; } @Override public void clear () {
final Map < K , V > [] temp = new Map [ size - 1 ] ; MST[rv.AOR1Mutator]MSP[N] System . arraycopy ( this . composite , 0 , temp , 0 , i ) ;
final Map < K , V > [] temp = new Map [ this . composite . length + 1 ] ; System . arraycopy ( this . composite , 0 , temp , 0 , this . composite . length ) ; MST[VoidMethodCallMutator]MSP[N]
} return null ; } @Override public boolean isEmpty () { for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[ConditionalsBoundaryMutator]MSP[N] if ( ! this . composite [ i ] . isEmpty () ) { return false ; }
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[ConditionalsBoundaryMutator]MSP[N] if ( this . composite [ i ] . containsKey ( key ) ) { return this . composite [ i ] . get ( key ) ; }
} return null ; } @Override public int size () { int size = 0 ; for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.CRCR4Mutator]MSP[N] size += this . composite [ i ] . size () ; }
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { if ( this . composite [ i ] . containsKey ( key ) ) { return true ; } } return false ; MST[rv.CRCR3Mutator]MSP[N] } @Override
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.UOI4Mutator]MSP[S] this . composite [ i ] . clear () ; } } @Override public boolean containsKey ( final Object key ) {
} return null ; } @Override public int size () { int size = 0 ; for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { size += this . composite [ i ] . size () ; MST[rv.UOI4Mutator]MSP[N] }
final Map < ? , ? > map = ( Map < ? , ? > ) obj ; return this . entrySet () . equals ( map . entrySet () ) ; } return false ; MST[rv.CRCR3Mutator]MSP[N] } @Override public int hashCode () { int code = 0 ;
return size ; MST[PrimitiveReturnsMutator]MSP[N] } @Override public Collection < V > values () { final CompositeCollection < V > values = new CompositeCollection <> () ; for ( int i = composite . length - 1 ; i >= 0 ; -- i ) {
return size ; } @Override public Collection < V > values () { final CompositeCollection < V > values = new CompositeCollection <> () ; for ( int i = composite . length - 1 ; i >= 0 ; -- i ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N]
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { if ( this . composite [ i ] . containsKey ( key ) ) { MST[rv.ROR1Mutator]MSP[S] return this . composite [ i ] . get ( key ) ; }
} return true ; } @Override public Set < K > keySet () { final CompositeSet < K > keys = new CompositeSet <> () ; for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.UOI1Mutator]MSP[N]
return size ; } @Override public Collection < V > values () { final CompositeCollection < V > values = new CompositeCollection <> () ; for ( int i = composite . length - 1 ; i >= 0 ; -- i ) { MST[MathMutator]MSP[N]
} return true ; } @Override public Set < K > keySet () { final CompositeSet < K > keys = new CompositeSet <> () ; for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.CRCR6Mutator]MSP[N]
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { this . composite [ i ] . clear () ; MST[VoidMethodCallMutator]MSP[S] } } @Override public boolean containsKey ( final Object key ) {
for ( int i = composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.CRCR3Mutator]MSP[N] entries . addComposited ( composite [ i ] . entrySet () ) ; } return entries ; } @Override public V get ( final Object key ) {
for ( final Map . Entry < K , V > entry : entrySet () ) { code += entry . hashCode () ; } return code ; MST[rv.ABSMutator]MSP[N] }
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[NegateConditionalsMutator]MSP[N] if ( this . composite [ i ] . containsKey ( key ) ) { return this . composite [ i ] . get ( key ) ; }
} return true ; } @Override public Set < K > keySet () { final CompositeSet < K > keys = new CompositeSet <> () ; for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.AOD1Mutator]MSP[N]
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { if ( this . composite [ i ] . containsKey ( key ) ) { return true ; MST[rv.CRCR4Mutator]MSP[N] } } return false ; } @Override
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { if ( this . composite [ i ] . containsKey ( key ) ) { MST[rv.ROR4Mutator]MSP[N] return true ; } } return false ; } @Override
for ( int i = composite . length - 1 ; i >= 0 ; -- i ) { entries . addComposited ( composite [ i ] . entrySet () ) ; MST[rv.UOI4Mutator]MSP[N] } return entries ; } @Override public V get ( final Object key ) {
public boolean containsValue ( final Object value ) { for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[IncrementsMutator]MSP[N] if ( this . composite [ i ] . containsValue ( value ) ) { return true ; } }
} return null ; } @Override public int size () { int size = 0 ; for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { size += this . composite [ i ] . size () ; MST[MathMutator]MSP[N] }
public boolean containsValue ( final Object value ) { for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { if ( this . composite [ i ] . containsValue ( value ) ) { MST[rv.UOI4Mutator]MSP[N] return true ; } }
} return null ; } @Override public int size () { int size = 0 ; MST[rv.CRCR6Mutator]MSP[N] for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { size += this . composite [ i ] . size () ; }
} return null ; } @Override public int size () { int size = 0 ; for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] size += this . composite [ i ] . size () ; }
for ( int i = composite . length - 1 ; i >= 0 ; -- i ) { MST[MathMutator]MSP[N] entries . addComposited ( composite [ i ] . entrySet () ) ; } return entries ; } @Override public V get ( final Object key ) {
final Map < K , V > [] temp = new Map [ this . composite . length + 1 ] ; MST[rv.AOD2Mutator]MSP[N] System . arraycopy ( this . composite , 0 , temp , 0 , this . composite . length ) ;
values . addComposited ( composite [ i ] . values () ) ; MST[rv.UOI4Mutator]MSP[N] } return values ; } @Override public boolean equals ( final Object obj ) { if ( obj instanceof Map ) {
temp [ temp . length - 1 ] = map ; MST[rv.CRCR6Mutator]MSP[N] this . composite = temp ; } } @SuppressWarnings ( lr_1 ) public synchronized Map < K , V > removeComposited ( final Map < K , V > map ) {
} return true ; } @Override public Set < K > keySet () { final CompositeSet < K > keys = new CompositeSet <> () ; for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.ROR4Mutator]MSP[N]
return size ; } @Override public Collection < V > values () { final CompositeCollection < V > values = new CompositeCollection <> () ; for ( int i = composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.ROR4Mutator]MSP[N]
} return null ; } @Override public boolean isEmpty () { for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { if ( ! this . composite [ i ] . isEmpty () ) { MST[NonVoidMethodCallMutator]MSP[N] return false ; }
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.ROR3Mutator]MSP[N] if ( this . composite [ i ] . containsKey ( key ) ) { return this . composite [ i ] . remove ( key ) ; }
} return null ; } @Override public boolean isEmpty () { for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.ROR2Mutator]MSP[N] if ( ! this . composite [ i ] . isEmpty () ) { return false ; }
throw new UnsupportedOperationException ( lr_3 ) ; MST[ConstructorCallMutator]MSP[S] } this . mutator . putAll ( this , this . composite , map ) ; } @Override public V remove ( final Object key ) {
System . arraycopy ( this . composite , i + 1 , temp , i , size - i - 1 ) ; MST[rv.AOR3Mutator]MSP[N] this . composite = temp ; return map ; } } return null ; } @Override public void clear () {
public boolean containsValue ( final Object value ) { for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] if ( this . composite [ i ] . containsValue ( value ) ) { return true ; } }
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.ROR3Mutator]MSP[N] if ( this . composite [ i ] . containsKey ( key ) ) { return this . composite [ i ] . get ( key ) ; }
System . arraycopy ( this . composite , i + 1 , temp , i , size - i - 1 ) ; MST[rv.AOR1Mutator]MSP[S] this . composite = temp ; return map ; } } return null ; } @Override public void clear () {
for ( final Map . Entry < K , V > entry : entrySet () ) { code += entry . hashCode () ; MST[rv.AOR2Mutator]MSP[N] } return code ; }
for ( int i = composite . length - 1 ; i >= 0 ; -- i ) { MST[InlineConstantMutator]MSP[N] final Collection < K > intersect = CollectionUtils . intersection ( this . composite [ i ] . keySet () , map . keySet () ) ;
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { if ( this . composite [ i ] . containsKey ( key ) ) { return true ; } } return false ; MST[rv.CRCR1Mutator]MSP[N] } @Override
temp [ temp . length - 1 ] = map ; this . composite = temp ; MST[experimental.MemberVariableMutator]MSP[N] } } @SuppressWarnings ( lr_1 ) public synchronized Map < K , V > removeComposited ( final Map < K , V > map ) {
} return null ; } @Override public int size () { int size = 0 ; for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.CRCR2Mutator]MSP[N] size += this . composite [ i ] . size () ; }
final int size = this . composite . length ; for ( int i = 0 ; i < size ; ++ i ) { MST[rv.UOI1Mutator]MSP[N] if ( this . composite [ i ] . equals ( map ) ) {
final Map < K , V > [] temp = new Map [ this . composite . length + 1 ] ; MST[rv.CRCR5Mutator]MSP[N] System . arraycopy ( this . composite , 0 , temp , 0 , this . composite . length ) ;
keys . addComposited ( this . composite [ i ] . keySet () ) ; } return keys ; } @Override public V put ( final K key , final V value ) { if ( this . mutator == null ) { throw new UnsupportedOperationException ( lr_3 ) ; MST[ConstructorCallMutator]MSP[S]
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.UOI3Mutator]MSP[N] if ( this . composite [ i ] . containsKey ( key ) ) { return true ; } } return false ; } @Override
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.AOD2Mutator]MSP[S] if ( this . composite [ i ] . containsKey ( key ) ) { return this . composite [ i ] . get ( key ) ; }
} return null ; MST[ReturnValsMutator]MSP[N] } @Override public int size () { int size = 0 ; for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { size += this . composite [ i ] . size () ; }
final Map < K , V > [] temp = new Map [ this . composite . length + 1 ] ; MST[rv.AOR4Mutator]MSP[N] System . arraycopy ( this . composite , 0 , temp , 0 , this . composite . length ) ;
final Map < ? , ? > map = ( Map < ? , ? > ) obj ; return this . entrySet () . equals ( map . entrySet () ) ; } return false ; } @Override public int hashCode () { int code = 0 ; MST[rv.CRCR6Mutator]MSP[N]
if ( intersect . size () != 0 ) { MST[rv.ROR5Mutator]MSP[N] if ( this . mutator == null ) { throw new IllegalArgumentException ( lr_2 ) ; } this . mutator . resolveCollision ( this , this . composite [ i ] , map , intersect ) ; } }
} return true ; } @Override public Set < K > keySet () { final CompositeSet < K > keys = new CompositeSet <> () ; for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N]
public boolean containsValue ( final Object value ) { for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { if ( this . composite [ i ] . containsValue ( value ) ) { return true ; MST[InlineConstantMutator]MSP[N] } }
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.UOI2Mutator]MSP[N] if ( this . composite [ i ] . containsKey ( key ) ) { return this . composite [ i ] . get ( key ) ; }
public void setMutator ( final MapMutator < K , V > mutator ) { this . mutator = mutator ; MST[experimental.MemberVariableMutator]MSP[N] } @SuppressWarnings ( lr_1 ) public synchronized void addComposited ( final Map < K , V > map ) throws IllegalArgumentException { if ( map != null ) {
System . arraycopy ( this . composite , i + 1 , temp , i , size - i - 1 ) ; MST[rv.UOI1Mutator]MSP[N] this . composite = temp ; return map ; } } return null ; } @Override public void clear () {
if ( intersect . size () != 0 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] if ( this . mutator == null ) { throw new IllegalArgumentException ( lr_2 ) ; } this . mutator . resolveCollision ( this , this . composite [ i ] , map , intersect ) ; } }
public boolean containsValue ( final Object value ) { for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.CRCR2Mutator]MSP[N] if ( this . composite [ i ] . containsValue ( value ) ) { return true ; } }
} return null ; } @Override public int size () { int size = 0 ; for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.AOR1Mutator]MSP[N] size += this . composite [ i ] . size () ; }
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { if ( this . composite [ i ] . containsKey ( key ) ) { MST[NonVoidMethodCallMutator]MSP[N] return this . composite [ i ] . remove ( key ) ; }
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.AOR2Mutator]MSP[N] if ( this . composite [ i ] . containsKey ( key ) ) { return true ; } } return false ; } @Override
} return null ; } @Override public boolean isEmpty () { for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.UOI4Mutator]MSP[N] if ( ! this . composite [ i ] . isEmpty () ) { return false ; }
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[MathMutator]MSP[N] if ( this . composite [ i ] . containsKey ( key ) ) { return true ; } } return false ; } @Override
final Map < ? , ? > map = ( Map < ? , ? > ) obj ; return this . entrySet () . equals ( map . entrySet () ) ; } return false ; MST[InlineConstantMutator]MSP[N] } @Override public int hashCode () { int code = 0 ;
} return null ; } @Override public boolean isEmpty () { for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.CRCR4Mutator]MSP[N] if ( ! this . composite [ i ] . isEmpty () ) { return false ; }
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.CRCR5Mutator]MSP[N] if ( this . composite [ i ] . containsKey ( key ) ) { return this . composite [ i ] . remove ( key ) ; }
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { if ( this . composite [ i ] . containsKey ( key ) ) { return this . composite [ i ] . get ( key ) ; MST[NonVoidMethodCallMutator]MSP[N] }
} return null ; } @Override public int size () { int size = 0 ; for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[ConditionalsBoundaryMutator]MSP[N] size += this . composite [ i ] . size () ; }
for ( final Map . Entry < K , V > entry : entrySet () ) { code += entry . hashCode () ; MST[MathMutator]MSP[N] } return code ; }
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.CRCR3Mutator]MSP[N] if ( this . composite [ i ] . containsKey ( key ) ) { return true ; } } return false ; } @Override
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.ROR2Mutator]MSP[N] this . composite [ i ] . clear () ; } } @Override public boolean containsKey ( final Object key ) {
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[InlineConstantMutator]MSP[N] if ( this . composite [ i ] . containsKey ( key ) ) { return true ; } } return false ; } @Override
} return null ; } @Override public boolean isEmpty () { for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { if ( ! this . composite [ i ] . isEmpty () ) { MST[rv.ROR4Mutator]MSP[N] return false ; }
for ( final Map . Entry < K , V > entry : entrySet () ) { code += entry . hashCode () ; } return code ; MST[ReturnValsMutator]MSP[N] }
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { if ( this . composite [ i ] . containsKey ( key ) ) { return true ; MST[BooleanFalseReturnValsMutator]MSP[N] } } return false ; } @Override
values . addComposited ( composite [ i ] . values () ) ; } return values ; } @Override public boolean equals ( final Object obj ) { if ( obj instanceof Map ) { MST[rv.ROR4Mutator]MSP[N]
System . arraycopy ( this . composite , i + 1 , temp , i , size - i - 1 ) ; MST[rv.UOI2Mutator]MSP[N] this . composite = temp ; return map ; } } return null ; } @Override public void clear () {
for ( int i = composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.UOI3Mutator]MSP[N] final Collection < K > intersect = CollectionUtils . intersection ( this . composite [ i ] . keySet () , map . keySet () ) ;
public boolean containsValue ( final Object value ) { for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[ConditionalsBoundaryMutator]MSP[N] if ( this . composite [ i ] . containsValue ( value ) ) { return true ; } }
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.AOR3Mutator]MSP[N] this . composite [ i ] . clear () ; } } @Override public boolean containsKey ( final Object key ) {
System . arraycopy ( this . composite , i + 1 , temp , i , size - i - 1 ) ; MST[rv.CRCR4Mutator]MSP[N] this . composite = temp ; return map ; } } return null ; } @Override public void clear () {
final Map < ? , ? > map = ( Map < ? , ? > ) obj ; return this . entrySet () . equals ( map . entrySet () ) ; } return false ; } @Override public int hashCode () { int code = 0 ; MST[rv.CRCR1Mutator]MSP[N]
final Map < K , V > [] temp = new Map [ size - 1 ] ; MST[rv.AOD2Mutator]MSP[N] System . arraycopy ( this . composite , 0 , temp , 0 , i ) ;
public boolean containsValue ( final Object value ) { for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.AOR1Mutator]MSP[N] if ( this . composite [ i ] . containsValue ( value ) ) { return true ; } }
return size ; MST[rv.UOI4Mutator]MSP[N] } @Override public Collection < V > values () { final CompositeCollection < V > values = new CompositeCollection <> () ; for ( int i = composite . length - 1 ; i >= 0 ; -- i ) {
public boolean containsValue ( final Object value ) { for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { if ( this . composite [ i ] . containsValue ( value ) ) { MST[rv.ROR3Mutator]MSP[N] return true ; } }
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.ABSMutator]MSP[N] if ( this . composite [ i ] . containsKey ( key ) ) { return true ; } } return false ; } @Override
final int size = this . composite . length ; for ( int i = 0 ; i < size ; ++ i ) { MST[rv.ROR3Mutator]MSP[S] if ( this . composite [ i ] . equals ( map ) ) {
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.UOI3Mutator]MSP[N] this . composite [ i ] . clear () ; } } @Override public boolean containsKey ( final Object key ) {
} return null ; } @Override public int size () { int size = 0 ; for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { size += this . composite [ i ] . size () ; MST[rv.UOI1Mutator]MSP[N] }
final Map < K , V > [] temp = new Map [ size - 1 ] ; MST[rv.UOI1Mutator]MSP[N] System . arraycopy ( this . composite , 0 , temp , 0 , i ) ;
System . arraycopy ( this . composite , i + 1 , temp , i , size - i - 1 ) ; MST[VoidMethodCallMutator]MSP[S] this . composite = temp ; return map ; } } return null ; } @Override public void clear () {
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { if ( this . composite [ i ] . containsKey ( key ) ) { MST[rv.ROR4Mutator]MSP[N] return this . composite [ i ] . get ( key ) ; }
for ( int i = composite . length - 1 ; i >= 0 ; -- i ) { final Collection < K > intersect = CollectionUtils . intersection ( this . composite [ i ] . keySet () , map . keySet () ) ; MST[NonVoidMethodCallMutator]MSP[N]
public boolean containsValue ( final Object value ) { for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { if ( this . composite [ i ] . containsValue ( value ) ) { return true ; MST[rv.CRCR3Mutator]MSP[N] } }
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { if ( this . composite [ i ] . containsKey ( key ) ) { MST[rv.UOI2Mutator]MSP[N] return this . composite [ i ] . get ( key ) ; }
for ( int i = composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.AOR4Mutator]MSP[N] final Collection < K > intersect = CollectionUtils . intersection ( this . composite [ i ] . keySet () , map . keySet () ) ;
} return null ; } @Override public int size () { int size = 0 ; for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { size += this . composite [ i ] . size () ; MST[rv.ABSMutator]MSP[S] }
} return null ; } @Override public boolean isEmpty () { for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { if ( ! this . composite [ i ] . isEmpty () ) { MST[NegateConditionalsMutator]MSP[N] return false ; }
} return null ; } @Override public int size () { int size = 0 ; for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.UOI4Mutator]MSP[N] size += this . composite [ i ] . size () ; }
for ( int i = composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.CRCR2Mutator]MSP[N] entries . addComposited ( composite [ i ] . entrySet () ) ; } return entries ; } @Override public V get ( final Object key ) {
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.AOR2Mutator]MSP[N] if ( this . composite [ i ] . containsKey ( key ) ) { return this . composite [ i ] . remove ( key ) ; }
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] if ( this . composite [ i ] . containsKey ( key ) ) { return this . composite [ i ] . remove ( key ) ; }
for ( int i = composite . length - 1 ; i >= 0 ; -- i ) { final Collection < K > intersect = CollectionUtils . intersection ( this . composite [ i ] . keySet () , map . keySet () ) ; MST[rv.ABSMutator]MSP[N]
} return true ; } @Override public Set < K > keySet () { final CompositeSet < K > keys = new CompositeSet <> () ; for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.AOD2Mutator]MSP[N]
final Map < K , V > [] temp = new Map [ size - 1 ] ; MST[rv.AOR2Mutator]MSP[N] System . arraycopy ( this . composite , 0 , temp , 0 , i ) ;
System . arraycopy ( this . composite , i + 1 , temp , i , size - i - 1 ) ; MST[rv.CRCR2Mutator]MSP[N] this . composite = temp ; return map ; } } return null ; } @Override public void clear () {
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { if ( this . composite [ i ] . containsKey ( key ) ) { return this . composite [ i ] . get ( key ) ; MST[ReturnValsMutator]MSP[N] }
System . arraycopy ( this . composite , i + 1 , temp , i , size - i - 1 ) ; MST[rv.AOD1Mutator]MSP[N] this . composite = temp ; return map ; } } return null ; } @Override public void clear () {
System . arraycopy ( this . composite , i + 1 , temp , i , size - i - 1 ) ; MST[rv.AOD2Mutator]MSP[N] this . composite = temp ; return map ; } } return null ; } @Override public void clear () {
public boolean containsValue ( final Object value ) { for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[InlineConstantMutator]MSP[N] if ( this . composite [ i ] . containsValue ( value ) ) { return true ; } }
} return null ; } @Override public int size () { int size = 0 ; for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { size += this . composite [ i ] . size () ; MST[NonVoidMethodCallMutator]MSP[N] }
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { if ( this . composite [ i ] . containsKey ( key ) ) { MST[rv.ROR2Mutator]MSP[N] return this . composite [ i ] . remove ( key ) ; }
} return this . mutator . put ( this , this . composite , key , value ) ; MST[ArgumentPropagationMutator]MSP[N] } @Override public void putAll ( final Map < ? extends K , ? extends V > map ) { if ( this . mutator == null ) {
} return true ; } @Override public Set < K > keySet () { final CompositeSet < K > keys = new CompositeSet <> () ; for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.CRCR3Mutator]MSP[N]
} return true ; } @Override public Set < K > keySet () { final CompositeSet < K > keys = new CompositeSet <> () ; for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.ROR1Mutator]MSP[N]
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.CRCR6Mutator]MSP[N] this . composite [ i ] . clear () ; } } @Override public boolean containsKey ( final Object key ) {
for ( int i = composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.AOR3Mutator]MSP[N] entries . addComposited ( composite [ i ] . entrySet () ) ; } return entries ; } @Override public V get ( final Object key ) {
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.UOI4Mutator]MSP[N] if ( this . composite [ i ] . containsKey ( key ) ) { return true ; } } return false ; } @Override
if ( intersect . size () != 0 ) { if ( this . mutator == null ) { throw new IllegalArgumentException ( lr_2 ) ; } this . mutator . resolveCollision ( this , this . composite [ i ] , map , intersect ) ; MST[rv.ABSMutator]MSP[N] } }
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.ROR5Mutator]MSP[N] if ( this . composite [ i ] . containsKey ( key ) ) { return true ; } } return false ; } @Override
public boolean containsValue ( final Object value ) { for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.ROR5Mutator]MSP[N] if ( this . composite [ i ] . containsValue ( value ) ) { return true ; } }
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[NegateConditionalsMutator]MSP[N] if ( this . composite [ i ] . containsKey ( key ) ) { return true ; } } return false ; } @Override
} return null ; } @Override public int size () { int size = 0 ; for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { size += this . composite [ i ] . size () ; MST[rv.UOI2Mutator]MSP[N] }
System . arraycopy ( this . composite , i + 1 , temp , i , size - i - 1 ) ; MST[MathMutator]MSP[S] this . composite = temp ; return map ; } } return null ; } @Override public void clear () {
} return null ; } @Override public int size () { int size = 0 ; for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.ROR5Mutator]MSP[N] size += this . composite [ i ] . size () ; }
values . addComposited ( composite [ i ] . values () ) ; } return values ; } @Override public boolean equals ( final Object obj ) { if ( obj instanceof Map ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
for ( int i = composite . length - 1 ; i >= 0 ; -- i ) { MST[InlineConstantMutator]MSP[N] entries . addComposited ( composite [ i ] . entrySet () ) ; } return entries ; } @Override public V get ( final Object key ) {
return size ; } @Override public Collection < V > values () { final CompositeCollection < V > values = new CompositeCollection <> () ; for ( int i = composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.ROR1Mutator]MSP[N]
temp [ temp . length - 1 ] = map ; MST[rv.AOD2Mutator]MSP[N] this . composite = temp ; } } @SuppressWarnings ( lr_1 ) public synchronized Map < K , V > removeComposited ( final Map < K , V > map ) {
System . arraycopy ( this . composite , i + 1 , temp , i , size - i - 1 ) ; MST[rv.ABSMutator]MSP[S] this . composite = temp ; return map ; } } return null ; } @Override public void clear () {
System . arraycopy ( this . composite , i + 1 , temp , i , size - i - 1 ) ; MST[rv.AOR4Mutator]MSP[N] this . composite = temp ; return map ; } } return null ; } @Override public void clear () {
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.ROR4Mutator]MSP[N] this . composite [ i ] . clear () ; } } @Override public boolean containsKey ( final Object key ) {
for ( final Map . Entry < K , V > entry : entrySet () ) { MST[NonVoidMethodCallMutator]MSP[N] code += entry . hashCode () ; } return code ; }
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.ROR4Mutator]MSP[N] if ( this . composite [ i ] . containsKey ( key ) ) { return this . composite [ i ] . remove ( key ) ; }
} return null ; } @Override public boolean isEmpty () { for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.ABSMutator]MSP[N] if ( ! this . composite [ i ] . isEmpty () ) { return false ; }
for ( final Map . Entry < K , V > entry : entrySet () ) { code += entry . hashCode () ; } return code ; MST[rv.UOI1Mutator]MSP[N] }
} return null ; } @Override public boolean isEmpty () { for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.ROR3Mutator]MSP[N] if ( ! this . composite [ i ] . isEmpty () ) { return false ; }
for ( final Map . Entry < K , V > entry : entrySet () ) { code += entry . hashCode () ; MST[rv.AOR3Mutator]MSP[N] } return code ; }
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.AOR4Mutator]MSP[N] if ( this . composite [ i ] . containsKey ( key ) ) { return this . composite [ i ] . get ( key ) ; }
values . addComposited ( composite [ i ] . values () ) ; } return values ; } @Override public boolean equals ( final Object obj ) { if ( obj instanceof Map ) { MST[rv.ROR3Mutator]MSP[N]
final int size = this . composite . length ; for ( int i = 0 ; i < size ; ++ i ) { MST[rv.CRCR1Mutator]MSP[S] if ( this . composite [ i ] . equals ( map ) ) {
} return null ; } @Override public boolean isEmpty () { for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { if ( ! this . composite [ i ] . isEmpty () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return false ; }
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { if ( this . composite [ i ] . containsKey ( key ) ) { return true ; MST[rv.CRCR3Mutator]MSP[N] } } return false ; } @Override
for ( int i = composite . length - 1 ; i >= 0 ; -- i ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] entries . addComposited ( composite [ i ] . entrySet () ) ; } return entries ; } @Override public V get ( final Object key ) {
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[MathMutator]MSP[N] if ( this . composite [ i ] . containsKey ( key ) ) { return this . composite [ i ] . get ( key ) ; }
for ( int i = composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.AOD1Mutator]MSP[N] entries . addComposited ( composite [ i ] . entrySet () ) ; } return entries ; } @Override public V get ( final Object key ) {
for ( int i = composite . length - 1 ; i >= 0 ; -- i ) { MST[MathMutator]MSP[N] final Collection < K > intersect = CollectionUtils . intersection ( this . composite [ i ] . keySet () , map . keySet () ) ;
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { if ( this . composite [ i ] . containsKey ( key ) ) { MST[rv.ROR3Mutator]MSP[N] return true ; } } return false ; } @Override
} return null ; } @Override public int size () { int size = 0 ; MST[rv.CRCR1Mutator]MSP[N] for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { size += this . composite [ i ] . size () ; }
final int size = this . composite . length ; for ( int i = 0 ; i < size ; ++ i ) { MST[rv.ABSMutator]MSP[S] if ( this . composite [ i ] . equals ( map ) ) {
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { if ( this . composite [ i ] . containsKey ( key ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return true ; } } return false ; } @Override
public boolean containsValue ( final Object value ) { for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.AOR3Mutator]MSP[N] if ( this . composite [ i ] . containsValue ( value ) ) { return true ; } }
final Map < K , V > [] temp = new Map [ size - 1 ] ; System . arraycopy ( this . composite , 0 , temp , 0 , i ) ; MST[rv.CRCR3Mutator]MSP[N]
for ( int i = composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.CRCR3Mutator]MSP[N] final Collection < K > intersect = CollectionUtils . intersection ( this . composite [ i ] . keySet () , map . keySet () ) ;
return size ; } @Override public Collection < V > values () { final CompositeCollection < V > values = new CompositeCollection <> () ; for ( int i = composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.UOI3Mutator]MSP[N]
for ( int i = composite . length - 1 ; i >= 0 ; -- i ) { final Collection < K > intersect = CollectionUtils . intersection ( this . composite [ i ] . keySet () , map . keySet () ) ; MST[NonVoidMethodCallMutator]MSP[N]
final Map < ? , ? > map = ( Map < ? , ? > ) obj ; return this . entrySet () . equals ( map . entrySet () ) ; } return false ; } @Override public int hashCode () { int code = 0 ; MST[rv.CRCR5Mutator]MSP[N]
public boolean containsValue ( final Object value ) { for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { if ( this . composite [ i ] . containsValue ( value ) ) { MST[NonVoidMethodCallMutator]MSP[N] return true ; } }
if ( intersect . size () != 0 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] if ( this . mutator == null ) { throw new IllegalArgumentException ( lr_2 ) ; } this . mutator . resolveCollision ( this , this . composite [ i ] , map , intersect ) ; } }
final Map < K , V > [] temp = new Map [ this . composite . length + 1 ] ; MST[rv.AOR3Mutator]MSP[N] System . arraycopy ( this . composite , 0 , temp , 0 , this . composite . length ) ;
System . arraycopy ( this . composite , i + 1 , temp , i , size - i - 1 ) ; MST[rv.UOI2Mutator]MSP[N] this . composite = temp ; return map ; } } return null ; } @Override public void clear () {
} return null ; } @Override public int size () { int size = 0 ; for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[NegateConditionalsMutator]MSP[N] size += this . composite [ i ] . size () ; }
} return null ; } @Override public int size () { int size = 0 ; for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.AOR3Mutator]MSP[N] size += this . composite [ i ] . size () ; }
for ( int i = composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.ROR1Mutator]MSP[S] final Collection < K > intersect = CollectionUtils . intersection ( this . composite [ i ] . keySet () , map . keySet () ) ;
public boolean containsValue ( final Object value ) { for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.UOI4Mutator]MSP[N] if ( this . composite [ i ] . containsValue ( value ) ) { return true ; } }
return false ; MST[ReturnValsMutator]MSP[N] } @Override public Set < Map . Entry < K , V > > entrySet () { final CompositeSet < Map . Entry < K , V > > entries = new CompositeSet <> () ;
System . arraycopy ( this . composite , i + 1 , temp , i , size - i - 1 ) ; MST[rv.CRCR3Mutator]MSP[N] this . composite = temp ; return map ; } } return null ; } @Override public void clear () {
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { if ( this . composite [ i ] . containsKey ( key ) ) { MST[NonVoidMethodCallMutator]MSP[N] return true ; } } return false ; } @Override
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.AOR2Mutator]MSP[N] this . composite [ i ] . clear () ; } } @Override public boolean containsKey ( final Object key ) {
for ( int i = composite . length - 1 ; i >= 0 ; -- i ) { MST[NegateConditionalsMutator]MSP[N] entries . addComposited ( composite [ i ] . entrySet () ) ; } return entries ; } @Override public V get ( final Object key ) {
return size ; } @Override public Collection < V > values () { final CompositeCollection < V > values = new CompositeCollection <> () ; for ( int i = composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.CRCR6Mutator]MSP[N]
final int size = this . composite . length ; for ( int i = 0 ; i < size ; ++ i ) { if ( this . composite [ i ] . equals ( map ) ) { MST[rv.ROR5Mutator]MSP[N]
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { if ( this . composite [ i ] . containsKey ( key ) ) { return true ; } } return false ; MST[ReturnValsMutator]MSP[N] } @Override
final int size = this . composite . length ; for ( int i = 0 ; i < size ; ++ i ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[S] if ( this . composite [ i ] . equals ( map ) ) {
final int size = this . composite . length ; for ( int i = 0 ; i < size ; ++ i ) { MST[rv.UOI2Mutator]MSP[N] if ( this . composite [ i ] . equals ( map ) ) {
} return null ; } @Override public boolean isEmpty () { for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { if ( ! this . composite [ i ] . isEmpty () ) { return false ; MST[rv.CRCR5Mutator]MSP[N] }
final Map < K , V > [] temp = new Map [ this . composite . length + 1 ] ; MST[rv.CRCR2Mutator]MSP[N] System . arraycopy ( this . composite , 0 , temp , 0 , this . composite . length ) ;
System . arraycopy ( this . composite , i + 1 , temp , i , size - i - 1 ) ; MST[MathMutator]MSP[N] this . composite = temp ; return map ; } } return null ; } @Override public void clear () {
if ( intersect . size () != 0 ) { MST[NegateConditionalsMutator]MSP[N] if ( this . mutator == null ) { throw new IllegalArgumentException ( lr_2 ) ; } this . mutator . resolveCollision ( this , this . composite [ i ] , map , intersect ) ; } }
final int size = this . composite . length ; for ( int i = 0 ; i < size ; ++ i ) { if ( this . composite [ i ] . equals ( map ) ) { MST[rv.ROR2Mutator]MSP[N]
System . arraycopy ( this . composite , i + 1 , temp , i , size - i - 1 ) ; MST[rv.AOR1Mutator]MSP[N] this . composite = temp ; return map ; } } return null ; } @Override public void clear () {
} return null ; } @Override public boolean isEmpty () { for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.AOR1Mutator]MSP[N] if ( ! this . composite [ i ] . isEmpty () ) { return false ; }
for ( int i = composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.AOD2Mutator]MSP[N] final Collection < K > intersect = CollectionUtils . intersection ( this . composite [ i ] . keySet () , map . keySet () ) ;
} return true ; MST[InlineConstantMutator]MSP[N] } @Override public Set < K > keySet () { final CompositeSet < K > keys = new CompositeSet <> () ; for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) {
temp [ temp . length - 1 ] = map ; MST[rv.CRCR3Mutator]MSP[N] this . composite = temp ; } } @SuppressWarnings ( lr_1 ) public synchronized Map < K , V > removeComposited ( final Map < K , V > map ) {
} return null ; } @Override public boolean isEmpty () { for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { if ( ! this . composite [ i ] . isEmpty () ) { MST[rv.ROR5Mutator]MSP[N] return false ; }
System . arraycopy ( this . composite , i + 1 , temp , i , size - i - 1 ) ; MST[rv.AOR4Mutator]MSP[S] this . composite = temp ; return map ; } } return null ; } @Override public void clear () {
} return null ; } @Override public boolean isEmpty () { for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { if ( ! this . composite [ i ] . isEmpty () ) { return false ; MST[ReturnValsMutator]MSP[N] }
if ( intersect . size () != 0 ) { if ( this . mutator == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] throw new IllegalArgumentException ( lr_2 ) ; } this . mutator . resolveCollision ( this , this . composite [ i ] , map , intersect ) ; } }
System . arraycopy ( this . composite , i + 1 , temp , i , size - i - 1 ) ; MST[rv.UOI3Mutator]MSP[N] this . composite = temp ; return map ; } } return null ; } @Override public void clear () {
final Map < K , V > [] temp = new Map [ size - 1 ] ; System . arraycopy ( this . composite , 0 , temp , 0 , i ) ; MST[VoidMethodCallMutator]MSP[S]
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.CRCR2Mutator]MSP[N] if ( this . composite [ i ] . containsKey ( key ) ) { return true ; } } return false ; } @Override
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.AOR1Mutator]MSP[N] if ( this . composite [ i ] . containsKey ( key ) ) { return this . composite [ i ] . get ( key ) ; }
for ( int i = composite . length - 1 ; i >= 0 ; -- i ) { entries . addComposited ( composite [ i ] . entrySet () ) ; MST[rv.ABSMutator]MSP[S] } return entries ; } @Override public V get ( final Object key ) {
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.AOR3Mutator]MSP[N] if ( this . composite [ i ] . containsKey ( key ) ) { return true ; } } return false ; } @Override
temp [ temp . length - 1 ] = map ; MST[rv.AOR4Mutator]MSP[N] this . composite = temp ; } } @SuppressWarnings ( lr_1 ) public synchronized Map < K , V > removeComposited ( final Map < K , V > map ) {
public boolean containsValue ( final Object value ) { for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[NegateConditionalsMutator]MSP[N] if ( this . composite [ i ] . containsValue ( value ) ) { return true ; } }
return size ; } @Override public Collection < V > values () { final CompositeCollection < V > values = new CompositeCollection <> () ; for ( int i = composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.CRCR3Mutator]MSP[N]
return false ; MST[rv.CRCR5Mutator]MSP[N] } @Override public Set < Map . Entry < K , V > > entrySet () { final CompositeSet < Map . Entry < K , V > > entries = new CompositeSet <> () ;
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.CRCR6Mutator]MSP[N] if ( this . composite [ i ] . containsKey ( key ) ) { return this . composite [ i ] . remove ( key ) ; }
} return null ; } @Override public boolean isEmpty () { for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.CRCR5Mutator]MSP[N] if ( ! this . composite [ i ] . isEmpty () ) { return false ; }
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { if ( this . composite [ i ] . containsKey ( key ) ) { return true ; } } return false ; MST[InlineConstantMutator]MSP[N] } @Override
temp [ temp . length - 1 ] = map ; MST[MathMutator]MSP[N] this . composite = temp ; } } @SuppressWarnings ( lr_1 ) public synchronized Map < K , V > removeComposited ( final Map < K , V > map ) {
final Map < K , V > [] temp = new Map [ size - 1 ] ; System . arraycopy ( this . composite , 0 , temp , 0 , i ) ; MST[rv.CRCR3Mutator]MSP[N]
for ( int i = composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.UOI4Mutator]MSP[N] entries . addComposited ( composite [ i ] . entrySet () ) ; } return entries ; } @Override public V get ( final Object key ) {
System . arraycopy ( this . composite , i + 1 , temp , i , size - i - 1 ) ; MST[InlineConstantMutator]MSP[N] this . composite = temp ; return map ; } } return null ; } @Override public void clear () {
} return null ; } @Override public int size () { int size = 0 ; for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.UOI1Mutator]MSP[N] size += this . composite [ i ] . size () ; }
final Map < ? , ? > map = ( Map < ? , ? > ) obj ; return this . entrySet () . equals ( map . entrySet () ) ; } return false ; MST[rv.CRCR5Mutator]MSP[N] } @Override public int hashCode () { int code = 0 ;
return false ; MST[InlineConstantMutator]MSP[N] } @Override public Set < Map . Entry < K , V > > entrySet () { final CompositeSet < Map . Entry < K , V > > entries = new CompositeSet <> () ;
public boolean containsValue ( final Object value ) { for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { if ( this . composite [ i ] . containsValue ( value ) ) { return true ; MST[rv.CRCR6Mutator]MSP[N] } }
} return true ; } @Override public Set < K > keySet () { final CompositeSet < K > keys = new CompositeSet <> () ; for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.UOI3Mutator]MSP[N]
} return null ; } @Override public int size () { int size = 0 ; for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { size += this . composite [ i ] . size () ; MST[rv.AOR2Mutator]MSP[N] }
values . addComposited ( composite [ i ] . values () ) ; } return values ; MST[ReturnValsMutator]MSP[N] } @Override public boolean equals ( final Object obj ) { if ( obj instanceof Map ) {
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { if ( this . composite [ i ] . containsKey ( key ) ) { return this . composite [ i ] . get ( key ) ; MST[NullReturnValsMutator]MSP[N] }
final Map < ? , ? > map = ( Map < ? , ? > ) obj ; return this . entrySet () . equals ( map . entrySet () ) ; } return false ; } @Override public int hashCode () { int code = 0 ; MST[InlineConstantMutator]MSP[N]
System . arraycopy ( this . composite , i + 1 , temp , i , size - i - 1 ) ; this . composite = temp ; return map ; MST[ReturnValsMutator]MSP[S] } } return null ; } @Override public void clear () {
System . arraycopy ( this . composite , i + 1 , temp , i , size - i - 1 ) ; MST[rv.UOI4Mutator]MSP[N] this . composite = temp ; return map ; } } return null ; } @Override public void clear () {
for ( final Map . Entry < K , V > entry : entrySet () ) { code += entry . hashCode () ; MST[rv.UOI3Mutator]MSP[N] } return code ; }
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { if ( this . composite [ i ] . containsKey ( key ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] return this . composite [ i ] . remove ( key ) ; }
final Map < ? , ? > map = ( Map < ? , ? > ) obj ; return this . entrySet () . equals ( map . entrySet () ) ; } return false ; MST[ReturnValsMutator]MSP[N] } @Override public int hashCode () { int code = 0 ;
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] if ( this . composite [ i ] . containsKey ( key ) ) { return true ; } } return false ; } @Override
} return null ; } @Override public boolean isEmpty () { for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { if ( ! this . composite [ i ] . isEmpty () ) { MST[rv.UOI4Mutator]MSP[N] return false ; }
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { if ( this . composite [ i ] . containsKey ( key ) ) { return true ; MST[rv.CRCR6Mutator]MSP[N] } } return false ; } @Override
return size ; } @Override public Collection < V > values () { final CompositeCollection < V > values = new CompositeCollection <> () ; for ( int i = composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.AOR2Mutator]MSP[N]
return size ; } @Override public Collection < V > values () { final CompositeCollection < V > values = new CompositeCollection <> () ; for ( int i = composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.AOR4Mutator]MSP[S]
} return null ; } @Override public int size () { int size = 0 ; for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { size += this . composite [ i ] . size () ; MST[rv.AOR4Mutator]MSP[N] }
final Map < ? , ? > map = ( Map < ? , ? > ) obj ; return this . entrySet () . equals ( map . entrySet () ) ; MST[BooleanFalseReturnValsMutator]MSP[N] } return false ; } @Override public int hashCode () { int code = 0 ;
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { if ( this . composite [ i ] . containsKey ( key ) ) { return this . composite [ i ] . remove ( key ) ; MST[rv.UOI3Mutator]MSP[N] }
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { if ( this . composite [ i ] . containsKey ( key ) ) { return this . composite [ i ] . remove ( key ) ; MST[rv.UOI1Mutator]MSP[N] }
for ( int i = composite . length - 1 ; i >= 0 ; -- i ) { entries . addComposited ( composite [ i ] . entrySet () ) ; MST[rv.UOI2Mutator]MSP[S] } return entries ; } @Override public V get ( final Object key ) {
final Map < ? , ? > map = ( Map < ? , ? > ) obj ; return this . entrySet () . equals ( map . entrySet () ) ; } return false ; MST[BooleanTrueReturnValsMutator]MSP[N] } @Override public int hashCode () { int code = 0 ;
final int size = this . composite . length ; for ( int i = 0 ; i < size ; ++ i ) { MST[rv.UOI3Mutator]MSP[N] if ( this . composite [ i ] . equals ( map ) ) {
if ( intersect . size () != 0 ) { if ( this . mutator == null ) { throw new IllegalArgumentException ( lr_2 ) ; } this . mutator . resolveCollision ( this , this . composite [ i ] , map , intersect ) ; MST[VoidMethodCallMutator]MSP[S] } }
} return null ; } @Override public boolean isEmpty () { for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.AOR4Mutator]MSP[S] if ( ! this . composite [ i ] . isEmpty () ) { return false ; }
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.ABSMutator]MSP[N] if ( this . composite [ i ] . containsKey ( key ) ) { return this . composite [ i ] . get ( key ) ; }
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { this . composite [ i ] . clear () ; MST[rv.ABSMutator]MSP[S] } } @Override public boolean containsKey ( final Object key ) {
} return true ; MST[rv.CRCR4Mutator]MSP[N] } @Override public Set < K > keySet () { final CompositeSet < K > keys = new CompositeSet <> () ; for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) {
} return null ; } @Override public int size () { int size = 0 ; for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.ROR2Mutator]MSP[N] size += this . composite [ i ] . size () ; }
} return null ; } @Override public boolean isEmpty () { for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { if ( ! this . composite [ i ] . isEmpty () ) { MST[rv.ROR2Mutator]MSP[N] return false ; }
System . arraycopy ( this . composite , i + 1 , temp , i , size - i - 1 ) ; MST[rv.ABSMutator]MSP[S] this . composite = temp ; return map ; } } return null ; } @Override public void clear () {
temp [ temp . length - 1 ] = map ; MST[rv.AOR2Mutator]MSP[N] this . composite = temp ; } } @SuppressWarnings ( lr_1 ) public synchronized Map < K , V > removeComposited ( final Map < K , V > map ) {
throw new UnsupportedOperationException ( lr_3 ) ; } this . mutator . putAll ( this , this . composite , map ) ; MST[VoidMethodCallMutator]MSP[N] } @Override public V remove ( final Object key ) {
System . arraycopy ( this . composite , i + 1 , temp , i , size - i - 1 ) ; MST[rv.CRCR5Mutator]MSP[N] this . composite = temp ; return map ; } } return null ; } @Override public void clear () {
for ( int i = composite . length - 1 ; i >= 0 ; -- i ) { entries . addComposited ( composite [ i ] . entrySet () ) ; MST[NonVoidMethodCallMutator]MSP[N] } return entries ; } @Override public V get ( final Object key ) {
} return true ; } @Override public Set < K > keySet () { final CompositeSet < K > keys = new CompositeSet <> () ; for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.AOR1Mutator]MSP[N]
final int size = this . composite . length ; for ( int i = 0 ; i < size ; ++ i ) { if ( this . composite [ i ] . equals ( map ) ) { MST[NegateConditionalsMutator]MSP[N]
public boolean containsValue ( final Object value ) { for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.ROR2Mutator]MSP[N] if ( this . composite [ i ] . containsValue ( value ) ) { return true ; } }
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { if ( this . composite [ i ] . containsKey ( key ) ) { return this . composite [ i ] . get ( key ) ; MST[rv.UOI3Mutator]MSP[N] }
} return null ; } @Override public boolean isEmpty () { for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] if ( ! this . composite [ i ] . isEmpty () ) { return false ; }
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[IncrementsMutator]MSP[N] if ( this . composite [ i ] . containsKey ( key ) ) { return this . composite [ i ] . remove ( key ) ; }
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { if ( this . composite [ i ] . containsKey ( key ) ) { return true ; } } return false ; MST[rv.CRCR5Mutator]MSP[N] } @Override
keys . addComposited ( this . composite [ i ] . keySet () ) ; MST[VoidMethodCallMutator]MSP[N] } return keys ; } @Override public V put ( final K key , final V value ) { if ( this . mutator == null ) { throw new UnsupportedOperationException ( lr_3 ) ;
public boolean containsValue ( final Object value ) { for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.UOI1Mutator]MSP[N] if ( this . composite [ i ] . containsValue ( value ) ) { return true ; } }
final Map < K , V > [] temp = new Map [ this . composite . length + 1 ] ; System . arraycopy ( this . composite , 0 , temp , 0 , this . composite . length ) ; MST[rv.CRCR1Mutator]MSP[N]
for ( int i = composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.ROR3Mutator]MSP[N] entries . addComposited ( composite [ i ] . entrySet () ) ; } return entries ; } @Override public V get ( final Object key ) {
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { if ( this . composite [ i ] . containsKey ( key ) ) { return this . composite [ i ] . remove ( key ) ; MST[NonVoidMethodCallMutator]MSP[N] }
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.AOD2Mutator]MSP[N] this . composite [ i ] . clear () ; } } @Override public boolean containsKey ( final Object key ) {
} return true ; MST[BooleanFalseReturnValsMutator]MSP[N] } @Override public Set < K > keySet () { final CompositeSet < K > keys = new CompositeSet <> () ; for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) {
public boolean containsValue ( final Object value ) { for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.AOD1Mutator]MSP[N] if ( this . composite [ i ] . containsValue ( value ) ) { return true ; } }
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { if ( this . composite [ i ] . containsKey ( key ) ) { return this . composite [ i ] . get ( key ) ; MST[rv.ABSMutator]MSP[S] }
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.UOI3Mutator]MSP[N] if ( this . composite [ i ] . containsKey ( key ) ) { return this . composite [ i ] . remove ( key ) ; }
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.CRCR3Mutator]MSP[N] if ( this . composite [ i ] . containsKey ( key ) ) { return this . composite [ i ] . get ( key ) ; }
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] this . composite [ i ] . clear () ; } } @Override public boolean containsKey ( final Object key ) {
} return null ; } @Override public boolean isEmpty () { for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.AOD2Mutator]MSP[N] if ( ! this . composite [ i ] . isEmpty () ) { return false ; }
final Map < K , V > [] temp = new Map [ size - 1 ] ; MST[rv.CRCR4Mutator]MSP[N] System . arraycopy ( this . composite , 0 , temp , 0 , i ) ;
if ( intersect . size () != 0 ) { MST[rv.ROR2Mutator]MSP[N] if ( this . mutator == null ) { throw new IllegalArgumentException ( lr_2 ) ; } this . mutator . resolveCollision ( this , this . composite [ i ] , map , intersect ) ; } }
final Map < K , V > [] temp = new Map [ this . composite . length + 1 ] ; MST[rv.AOR1Mutator]MSP[N] System . arraycopy ( this . composite , 0 , temp , 0 , this . composite . length ) ;
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { if ( this . composite [ i ] . containsKey ( key ) ) { return true ; } } return false ; MST[BooleanTrueReturnValsMutator]MSP[N] } @Override
System . arraycopy ( this . composite , i + 1 , temp , i , size - i - 1 ) ; MST[rv.AOD2Mutator]MSP[N] this . composite = temp ; return map ; } } return null ; } @Override public void clear () {
System . arraycopy ( this . composite , i + 1 , temp , i , size - i - 1 ) ; MST[rv.UOI4Mutator]MSP[N] this . composite = temp ; return map ; } } return null ; } @Override public void clear () {
public boolean containsValue ( final Object value ) { for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.CRCR5Mutator]MSP[N] if ( this . composite [ i ] . containsValue ( value ) ) { return true ; } }
for ( int i = composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.ROR3Mutator]MSP[N] final Collection < K > intersect = CollectionUtils . intersection ( this . composite [ i ] . keySet () , map . keySet () ) ;
System . arraycopy ( this . composite , i + 1 , temp , i , size - i - 1 ) ; MST[rv.AOR3Mutator]MSP[N] this . composite = temp ; return map ; } } return null ; } @Override public void clear () {
} return null ; } @Override public boolean isEmpty () { for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.UOI2Mutator]MSP[N] if ( ! this . composite [ i ] . isEmpty () ) { return false ; }
values . addComposited ( composite [ i ] . values () ) ; } return values ; } @Override public boolean equals ( final Object obj ) { if ( obj instanceof Map ) { MST[rv.ROR1Mutator]MSP[N]
for ( int i = composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.ROR2Mutator]MSP[N] entries . addComposited ( composite [ i ] . entrySet () ) ; } return entries ; } @Override public V get ( final Object key ) {
} return true ; } @Override public Set < K > keySet () { final CompositeSet < K > keys = new CompositeSet <> () ; for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.AOR2Mutator]MSP[N]
final Map < ? , ? > map = ( Map < ? , ? > ) obj ; return this . entrySet () . equals ( map . entrySet () ) ; MST[NonVoidMethodCallMutator]MSP[N] } return false ; } @Override public int hashCode () { int code = 0 ;
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.AOD1Mutator]MSP[N] if ( this . composite [ i ] . containsKey ( key ) ) { return true ; } } return false ; } @Override
final Map < K , V > [] temp = new Map [ size - 1 ] ; System . arraycopy ( this . composite , 0 , temp , 0 , i ) ; MST[rv.CRCR6Mutator]MSP[N]
return size ; MST[rv.UOI1Mutator]MSP[N] } @Override public Collection < V > values () { final CompositeCollection < V > values = new CompositeCollection <> () ; for ( int i = composite . length - 1 ; i >= 0 ; -- i ) {
for ( int i = composite . length - 1 ; i >= 0 ; -- i ) { MST[IncrementsMutator]MSP[N] entries . addComposited ( composite [ i ] . entrySet () ) ; } return entries ; } @Override public V get ( final Object key ) {
} return true ; } @Override public Set < K > keySet () { final CompositeSet < K > keys = new CompositeSet <> () ; for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[MathMutator]MSP[N]
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { if ( this . composite [ i ] . containsKey ( key ) ) { MST[rv.UOI3Mutator]MSP[N] return true ; } } return false ; } @Override
final Map < K , V > [] temp = new Map [ this . composite . length + 1 ] ; System . arraycopy ( this . composite , 0 , temp , 0 , this . composite . length ) ; MST[rv.CRCR6Mutator]MSP[N]
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.ROR1Mutator]MSP[N] if ( this . composite [ i ] . containsKey ( key ) ) { return this . composite [ i ] . get ( key ) ; }
} return true ; } @Override public Set < K > keySet () { final CompositeSet < K > keys = new CompositeSet <> () ; for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.ABSMutator]MSP[N]
} return null ; } @Override public boolean isEmpty () { for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { if ( ! this . composite [ i ] . isEmpty () ) { MST[rv.ABSMutator]MSP[S] return false ; }
for ( int i = composite . length - 1 ; i >= 0 ; -- i ) { final Collection < K > intersect = CollectionUtils . intersection ( this . composite [ i ] . keySet () , map . keySet () ) ; MST[rv.UOI2Mutator]MSP[S]
public void setMutator ( final MapMutator < K , V > mutator ) { this . mutator = mutator ; } @SuppressWarnings ( lr_1 ) public synchronized void addComposited ( final Map < K , V > map ) throws IllegalArgumentException { if ( map != null ) { MST[NegateConditionalsMutator]MSP[N]
for ( int i = composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.CRCR5Mutator]MSP[N] entries . addComposited ( composite [ i ] . entrySet () ) ; } return entries ; } @Override public V get ( final Object key ) {
} return null ; } @Override public boolean isEmpty () { for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[NegateConditionalsMutator]MSP[N] if ( ! this . composite [ i ] . isEmpty () ) { return false ; }
final Map < K , V > [] temp = new Map [ this . composite . length + 1 ] ; MST[InlineConstantMutator]MSP[N] System . arraycopy ( this . composite , 0 , temp , 0 , this . composite . length ) ;
final int size = this . composite . length ; for ( int i = 0 ; i < size ; ++ i ) { if ( this . composite [ i ] . equals ( map ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S]
} return null ; } @Override public int size () { int size = 0 ; for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.AOD1Mutator]MSP[N] size += this . composite [ i ] . size () ; }
for ( final Map . Entry < K , V > entry : entrySet () ) { code += entry . hashCode () ; MST[rv.AOD1Mutator]MSP[N] } return code ; }
if ( intersect . size () != 0 ) { if ( this . mutator == null ) { throw new IllegalArgumentException ( lr_2 ) ; } this . mutator . resolveCollision ( this , this . composite [ i ] , map , intersect ) ; MST[rv.UOI2Mutator]MSP[N] } }
keys . addComposited ( this . composite [ i ] . keySet () ) ; } return keys ; MST[ReturnValsMutator]MSP[N] } @Override public V put ( final K key , final V value ) { if ( this . mutator == null ) { throw new UnsupportedOperationException ( lr_3 ) ;
public boolean containsValue ( final Object value ) { for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { if ( this . composite [ i ] . containsValue ( value ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return true ; } }
final Map < K , V > [] temp = new Map [ this . composite . length + 1 ] ; System . arraycopy ( this . composite , 0 , temp , 0 , this . composite . length ) ; MST[rv.CRCR1Mutator]MSP[N]
for ( int i = composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.CRCR5Mutator]MSP[N] final Collection < K > intersect = CollectionUtils . intersection ( this . composite [ i ] . keySet () , map . keySet () ) ;
} return null ; } @Override public int size () { int size = 0 ; MST[rv.CRCR3Mutator]MSP[N] for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { size += this . composite [ i ] . size () ; }
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.UOI1Mutator]MSP[N] if ( this . composite [ i ] . containsKey ( key ) ) { return true ; } } return false ; } @Override
System . arraycopy ( this . composite , i + 1 , temp , i , size - i - 1 ) ; this . composite = temp ; MST[experimental.MemberVariableMutator]MSP[S] return map ; } } return null ; } @Override public void clear () {
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { if ( this . composite [ i ] . containsKey ( key ) ) { MST[rv.ROR2Mutator]MSP[N] return this . composite [ i ] . get ( key ) ; }
} return true ; } @Override public Set < K > keySet () { final CompositeSet < K > keys = new CompositeSet <> () ; for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.UOI2Mutator]MSP[N]
for ( final Map . Entry < K , V > entry : entrySet () ) { code += entry . hashCode () ; MST[rv.UOI4Mutator]MSP[N] } return code ; }
} return null ; } @Override public int size () { int size = 0 ; for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { size += this . composite [ i ] . size () ; MST[rv.UOI3Mutator]MSP[N] }
} return true ; } @Override public Set < K > keySet () { final CompositeSet < K > keys = new CompositeSet <> () ; MST[ConstructorCallMutator]MSP[N] for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) {
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { if ( this . composite [ i ] . containsKey ( key ) ) { return this . composite [ i ] . remove ( key ) ; MST[ReturnValsMutator]MSP[S] }
} return null ; } @Override public int size () { int size = 0 ; for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { size += this . composite [ i ] . size () ; MST[rv.AOR1Mutator]MSP[N] }
} return null ; } @Override public boolean isEmpty () { for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { if ( ! this . composite [ i ] . isEmpty () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return false ; }
} return true ; } @Override public Set < K > keySet () { final CompositeSet < K > keys = new CompositeSet <> () ; for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.CRCR5Mutator]MSP[N]
values . addComposited ( composite [ i ] . values () ) ; } return values ; } @Override public boolean equals ( final Object obj ) { if ( obj instanceof Map ) { MST[NegateConditionalsMutator]MSP[N]
values . addComposited ( composite [ i ] . values () ) ; MST[VoidMethodCallMutator]MSP[N] } return values ; } @Override public boolean equals ( final Object obj ) { if ( obj instanceof Map ) {
final Map < K , V > [] temp = new Map [ size - 1 ] ; MST[MathMutator]MSP[N] System . arraycopy ( this . composite , 0 , temp , 0 , i ) ;
for ( int i = composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.CRCR4Mutator]MSP[N] entries . addComposited ( composite [ i ] . entrySet () ) ; } return entries ; } @Override public V get ( final Object key ) {
System . arraycopy ( this . composite , i + 1 , temp , i , size - i - 1 ) ; MST[rv.CRCR4Mutator]MSP[S] this . composite = temp ; return map ; } } return null ; } @Override public void clear () {
final Map < ? , ? > map = ( Map < ? , ? > ) obj ; return this . entrySet () . equals ( map . entrySet () ) ; MST[NonVoidMethodCallMutator]MSP[N] } return false ; } @Override public int hashCode () { int code = 0 ;
public boolean containsValue ( final Object value ) { for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { if ( this . composite [ i ] . containsValue ( value ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return true ; } }
public boolean containsValue ( final Object value ) { for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { if ( this . composite [ i ] . containsValue ( value ) ) { return true ; MST[ReturnValsMutator]MSP[N] } }
} return null ; } @Override public int size () { int size = 0 ; for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.CRCR5Mutator]MSP[N] size += this . composite [ i ] . size () ; }
if ( intersect . size () != 0 ) { MST[NonVoidMethodCallMutator]MSP[N] if ( this . mutator == null ) { throw new IllegalArgumentException ( lr_2 ) ; } this . mutator . resolveCollision ( this , this . composite [ i ] , map , intersect ) ; } }
keys . addComposited ( this . composite [ i ] . keySet () ) ; } return keys ; MST[EmptyObjectReturnValsMutator]MSP[N] } @Override public V put ( final K key , final V value ) { if ( this . mutator == null ) { throw new UnsupportedOperationException ( lr_3 ) ;
final Map < K , V > [] temp = new Map [ this . composite . length + 1 ] ; MST[rv.CRCR4Mutator]MSP[N] System . arraycopy ( this . composite , 0 , temp , 0 , this . composite . length ) ;
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.UOI2Mutator]MSP[N] if ( this . composite [ i ] . containsKey ( key ) ) { return true ; } } return false ; } @Override
final Map < K , V > [] temp = new Map [ this . composite . length + 1 ] ; System . arraycopy ( this . composite , 0 , temp , 0 , this . composite . length ) ; MST[rv.CRCR6Mutator]MSP[N]
for ( int i = composite . length - 1 ; i >= 0 ; -- i ) { entries . addComposited ( composite [ i ] . entrySet () ) ; MST[VoidMethodCallMutator]MSP[N] } return entries ; } @Override public V get ( final Object key ) {
if ( intersect . size () != 0 ) { if ( this . mutator == null ) { MST[rv.ROR5Mutator]MSP[N] throw new IllegalArgumentException ( lr_2 ) ; } this . mutator . resolveCollision ( this , this . composite [ i ] , map , intersect ) ; } }
} return null ; } @Override public boolean isEmpty () { for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { if ( ! this . composite [ i ] . isEmpty () ) { return false ; MST[rv.CRCR3Mutator]MSP[N] }
} return true ; } @Override public Set < K > keySet () { final CompositeSet < K > keys = new CompositeSet <> () ; for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.ROR3Mutator]MSP[N]
temp [ temp . length - 1 ] = map ; MST[rv.CRCR5Mutator]MSP[N] this . composite = temp ; } } @SuppressWarnings ( lr_1 ) public synchronized Map < K , V > removeComposited ( final Map < K , V > map ) {
} return null ; } @Override public boolean isEmpty () { for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { if ( ! this . composite [ i ] . isEmpty () ) { MST[rv.ROR3Mutator]MSP[N] return false ; }
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { if ( this . composite [ i ] . containsKey ( key ) ) { MST[rv.ABSMutator]MSP[N] return this . composite [ i ] . remove ( key ) ; }
for ( int i = composite . length - 1 ; i >= 0 ; -- i ) { final Collection < K > intersect = CollectionUtils . intersection ( this . composite [ i ] . keySet () , map . keySet () ) ; MST[rv.UOI4Mutator]MSP[N]
} return true ; MST[rv.CRCR5Mutator]MSP[N] } @Override public Set < K > keySet () { final CompositeSet < K > keys = new CompositeSet <> () ; for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) {
if ( intersect . size () != 0 ) { if ( this . mutator == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] throw new IllegalArgumentException ( lr_2 ) ; } this . mutator . resolveCollision ( this , this . composite [ i ] , map , intersect ) ; } }
System . arraycopy ( this . composite , i + 1 , temp , i , size - i - 1 ) ; MST[rv.AOR2Mutator]MSP[N] this . composite = temp ; return map ; } } return null ; } @Override public void clear () {
System . arraycopy ( this . composite , i + 1 , temp , i , size - i - 1 ) ; MST[rv.UOI1Mutator]MSP[N] this . composite = temp ; return map ; } } return null ; } @Override public void clear () {
for ( int i = composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.UOI2Mutator]MSP[N] final Collection < K > intersect = CollectionUtils . intersection ( this . composite [ i ] . keySet () , map . keySet () ) ;
} return null ; } @Override public int size () { int size = 0 ; for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.ABSMutator]MSP[N] size += this . composite [ i ] . size () ; }
} return null ; } @Override public boolean isEmpty () { for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[InlineConstantMutator]MSP[N] if ( ! this . composite [ i ] . isEmpty () ) { return false ; }
return size ; } @Override public Collection < V > values () { final CompositeCollection < V > values = new CompositeCollection <> () ; for ( int i = composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.AOR1Mutator]MSP[N]
final Map < K , V > [] temp = new Map [ size - 1 ] ; MST[rv.CRCR3Mutator]MSP[N] System . arraycopy ( this . composite , 0 , temp , 0 , i ) ;
if ( intersect . size () != 0 ) { if ( this . mutator == null ) { throw new IllegalArgumentException ( lr_2 ) ; } this . mutator . resolveCollision ( this , this . composite [ i ] , map , intersect ) ; MST[rv.UOI4Mutator]MSP[S] } }
return false ; MST[rv.CRCR3Mutator]MSP[N] } @Override public Set < Map . Entry < K , V > > entrySet () { final CompositeSet < Map . Entry < K , V > > entries = new CompositeSet <> () ;
public boolean containsValue ( final Object value ) { for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.ABSMutator]MSP[N] if ( this . composite [ i ] . containsValue ( value ) ) { return true ; } }
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { if ( this . composite [ i ] . containsKey ( key ) ) { return this . composite [ i ] . remove ( key ) ; MST[rv.UOI4Mutator]MSP[N] }
public boolean containsValue ( final Object value ) { for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { if ( this . composite [ i ] . containsValue ( value ) ) { MST[rv.UOI3Mutator]MSP[N] return true ; } }
for ( int i = composite . length - 1 ; i >= 0 ; -- i ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] final Collection < K > intersect = CollectionUtils . intersection ( this . composite [ i ] . keySet () , map . keySet () ) ;
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.AOR1Mutator]MSP[N] if ( this . composite [ i ] . containsKey ( key ) ) { return true ; } } return false ; } @Override
} return null ; } @Override public boolean isEmpty () { for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.CRCR3Mutator]MSP[N] if ( ! this . composite [ i ] . isEmpty () ) { return false ; }
final Map < ? , ? > map = ( Map < ? , ? > ) obj ; return this . entrySet () . equals ( map . entrySet () ) ; MST[BooleanTrueReturnValsMutator]MSP[N] } return false ; } @Override public int hashCode () { int code = 0 ;
for ( int i = composite . length - 1 ; i >= 0 ; -- i ) { entries . addComposited ( composite [ i ] . entrySet () ) ; MST[rv.UOI3Mutator]MSP[N] } return entries ; } @Override public V get ( final Object key ) {
final Map < K , V > [] temp = new Map [ this . composite . length + 1 ] ; System . arraycopy ( this . composite , 0 , temp , 0 , this . composite . length ) ; MST[InlineConstantMutator]MSP[N]
final int size = this . composite . length ; for ( int i = 0 ; i < size ; ++ i ) { MST[rv.UOI4Mutator]MSP[N] if ( this . composite [ i ] . equals ( map ) ) {
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.UOI4Mutator]MSP[N] if ( this . composite [ i ] . containsKey ( key ) ) { return this . composite [ i ] . remove ( key ) ; }
keys . addComposited ( this . composite [ i ] . keySet () ) ; } return keys ; } @Override public V put ( final K key , final V value ) { if ( this . mutator == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] throw new UnsupportedOperationException ( lr_3 ) ;
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.AOD1Mutator]MSP[N] if ( this . composite [ i ] . containsKey ( key ) ) { return this . composite [ i ] . get ( key ) ; }
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.UOI1Mutator]MSP[N] if ( this . composite [ i ] . containsKey ( key ) ) { return this . composite [ i ] . remove ( key ) ; }
final Map < K , V > [] temp = new Map [ size - 1 ] ; System . arraycopy ( this . composite , 0 , temp , 0 , i ) ; MST[InlineConstantMutator]MSP[N]
if ( intersect . size () != 0 ) { MST[rv.ROR4Mutator]MSP[N] if ( this . mutator == null ) { throw new IllegalArgumentException ( lr_2 ) ; } this . mutator . resolveCollision ( this , this . composite [ i ] , map , intersect ) ; } }
} return null ; } @Override public int size () { int size = 0 ; for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] size += this . composite [ i ] . size () ; }
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.UOI3Mutator]MSP[N] if ( this . composite [ i ] . containsKey ( key ) ) { return this . composite [ i ] . get ( key ) ; }
return false ; MST[BooleanTrueReturnValsMutator]MSP[N] } @Override public Set < Map . Entry < K , V > > entrySet () { final CompositeSet < Map . Entry < K , V > > entries = new CompositeSet <> () ;
} return null ; } @Override public int size () { int size = 0 ; for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.AOR2Mutator]MSP[N] size += this . composite [ i ] . size () ; }
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[MathMutator]MSP[N] this . composite [ i ] . clear () ; } } @Override public boolean containsKey ( final Object key ) {
System . arraycopy ( this . composite , i + 1 , temp , i , size - i - 1 ) ; MST[rv.AOR1Mutator]MSP[S] this . composite = temp ; return map ; } } return null ; } @Override public void clear () {
System . arraycopy ( this . composite , i + 1 , temp , i , size - i - 1 ) ; MST[rv.AOR4Mutator]MSP[N] this . composite = temp ; return map ; } } return null ; } @Override public void clear () {
System . arraycopy ( this . composite , i + 1 , temp , i , size - i - 1 ) ; MST[rv.CRCR5Mutator]MSP[N] this . composite = temp ; return map ; } } return null ; } @Override public void clear () {
temp [ temp . length - 1 ] = map ; MST[rv.AOR1Mutator]MSP[N] this . composite = temp ; } } @SuppressWarnings ( lr_1 ) public synchronized Map < K , V > removeComposited ( final Map < K , V > map ) {
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.AOR4Mutator]MSP[S] this . composite [ i ] . clear () ; } } @Override public boolean containsKey ( final Object key ) {
final int size = this . composite . length ; for ( int i = 0 ; i < size ; ++ i ) { if ( this . composite [ i ] . equals ( map ) ) { MST[rv.UOI1Mutator]MSP[N]
return size ; MST[rv.UOI3Mutator]MSP[N] } @Override public Collection < V > values () { final CompositeCollection < V > values = new CompositeCollection <> () ; for ( int i = composite . length - 1 ; i >= 0 ; -- i ) {
} return null ; } @Override public boolean isEmpty () { for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { if ( ! this . composite [ i ] . isEmpty () ) { return false ; MST[InlineConstantMutator]MSP[N] }
for ( int i = composite . length - 1 ; i >= 0 ; -- i ) { entries . addComposited ( composite [ i ] . entrySet () ) ; } return entries ; MST[ReturnValsMutator]MSP[N] } @Override public V get ( final Object key ) {
final int size = this . composite . length ; for ( int i = 0 ; i < size ; ++ i ) { if ( this . composite [ i ] . equals ( map ) ) { MST[rv.ABSMutator]MSP[S]
} return null ; } @Override public int size () { int size = 0 ; for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { size += this . composite [ i ] . size () ; MST[rv.UOI4Mutator]MSP[N] }
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { if ( this . composite [ i ] . containsKey ( key ) ) { MST[rv.UOI4Mutator]MSP[N] return true ; } } return false ; } @Override
values . addComposited ( composite [ i ] . values () ) ; MST[rv.UOI3Mutator]MSP[N] } return values ; } @Override public boolean equals ( final Object obj ) { if ( obj instanceof Map ) {
} return true ; } @Override public Set < K > keySet () { final CompositeSet < K > keys = new CompositeSet <> () ; for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N]
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { if ( this . composite [ i ] . containsKey ( key ) ) { MST[rv.ROR5Mutator]MSP[N] return true ; } } return false ; } @Override
return size ; } @Override public Collection < V > values () { final CompositeCollection < V > values = new CompositeCollection <> () ; for ( int i = composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.ROR3Mutator]MSP[N]
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.ABSMutator]MSP[N] this . composite [ i ] . clear () ; } } @Override public boolean containsKey ( final Object key ) {
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.ROR3Mutator]MSP[N] this . composite [ i ] . clear () ; } } @Override public boolean containsKey ( final Object key ) {
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { if ( this . composite [ i ] . containsKey ( key ) ) { MST[NegateConditionalsMutator]MSP[N] return this . composite [ i ] . remove ( key ) ; }
} return null ; } @Override public int size () { int size = 0 ; for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.ROR4Mutator]MSP[N] size += this . composite [ i ] . size () ; }
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { if ( this . composite [ i ] . containsKey ( key ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return this . composite [ i ] . get ( key ) ; }
values . addComposited ( composite [ i ] . values () ) ; } return values ; } @Override public boolean equals ( final Object obj ) { if ( obj instanceof Map ) { MST[rv.ROR5Mutator]MSP[N]
System . arraycopy ( this . composite , i + 1 , temp , i , size - i - 1 ) ; this . composite = temp ; return map ; MST[NullReturnValsMutator]MSP[S] } } return null ; } @Override public void clear () {
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { if ( this . composite [ i ] . containsKey ( key ) ) { return true ; MST[rv.CRCR5Mutator]MSP[N] } } return false ; } @Override
} return null ; } @Override public boolean isEmpty () { for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.UOI3Mutator]MSP[N] if ( ! this . composite [ i ] . isEmpty () ) { return false ; }
} return true ; } @Override public Set < K > keySet () { final CompositeSet < K > keys = new CompositeSet <> () ; for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[IncrementsMutator]MSP[N]
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.CRCR3Mutator]MSP[N] this . composite [ i ] . clear () ; } } @Override public boolean containsKey ( final Object key ) {
final Map < K , V > [] temp = new Map [ size - 1 ] ; System . arraycopy ( this . composite , 0 , temp , 0 , i ) ; MST[rv.CRCR5Mutator]MSP[S]
public boolean containsValue ( final Object value ) { for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] if ( this . composite [ i ] . containsValue ( value ) ) { return true ; } }
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.ROR2Mutator]MSP[N] if ( this . composite [ i ] . containsKey ( key ) ) { return true ; } } return false ; } @Override
public boolean containsValue ( final Object value ) { for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { if ( this . composite [ i ] . containsValue ( value ) ) { return true ; MST[BooleanFalseReturnValsMutator]MSP[N] } }
final Map < K , V > [] temp = new Map [ size - 1 ] ; System . arraycopy ( this . composite , 0 , temp , 0 , i ) ; MST[rv.UOI3Mutator]MSP[N]
public boolean containsValue ( final Object value ) { for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { if ( this . composite [ i ] . containsValue ( value ) ) { MST[rv.ROR2Mutator]MSP[N] return true ; } }
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[ConditionalsBoundaryMutator]MSP[N] if ( this . composite [ i ] . containsKey ( key ) ) { return true ; } } return false ; } @Override
} return this . mutator . put ( this , this . composite , key , value ) ; } @Override public void putAll ( final Map < ? extends K , ? extends V > map ) { if ( this . mutator == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S]
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { if ( this . composite [ i ] . containsKey ( key ) ) { MST[rv.UOI3Mutator]MSP[N] return this . composite [ i ] . remove ( key ) ; }
final Map < K , V > [] temp = new Map [ size - 1 ] ; System . arraycopy ( this . composite , 0 , temp , 0 , i ) ; MST[InlineConstantMutator]MSP[S]
public boolean containsValue ( final Object value ) { for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { if ( this . composite [ i ] . containsValue ( value ) ) { return true ; MST[rv.CRCR4Mutator]MSP[N] } }
public boolean containsValue ( final Object value ) { for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { if ( this . composite [ i ] . containsValue ( value ) ) { return true ; MST[rv.CRCR2Mutator]MSP[N] } }
for ( int i = composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.AOR1Mutator]MSP[N] final Collection < K > intersect = CollectionUtils . intersection ( this . composite [ i ] . keySet () , map . keySet () ) ;
for ( final Map . Entry < K , V > entry : entrySet () ) { code += entry . hashCode () ; MST[rv.UOI1Mutator]MSP[N] } return code ; }
} return null ; } @Override public boolean isEmpty () { for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[IncrementsMutator]MSP[N] if ( ! this . composite [ i ] . isEmpty () ) { return false ; }
System . arraycopy ( this . composite , i + 1 , temp , i , size - i - 1 ) ; MST[rv.UOI2Mutator]MSP[N] this . composite = temp ; return map ; } } return null ; } @Override public void clear () {
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.AOR3Mutator]MSP[N] if ( this . composite [ i ] . containsKey ( key ) ) { return this . composite [ i ] . remove ( key ) ; }
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { if ( this . composite [ i ] . containsKey ( key ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return this . composite [ i ] . remove ( key ) ; }
} return null ; } @Override public int size () { int size = 0 ; for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.UOI3Mutator]MSP[N] size += this . composite [ i ] . size () ; }
} return null ; } @Override public boolean isEmpty () { for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { if ( ! this . composite [ i ] . isEmpty () ) { MST[rv.UOI2Mutator]MSP[S] return false ; }
for ( int i = composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.AOD2Mutator]MSP[N] entries . addComposited ( composite [ i ] . entrySet () ) ; } return entries ; } @Override public V get ( final Object key ) {
return size ; MST[rv.ABSMutator]MSP[N] } @Override public Collection < V > values () { final CompositeCollection < V > values = new CompositeCollection <> () ; for ( int i = composite . length - 1 ; i >= 0 ; -- i ) {
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.ROR1Mutator]MSP[S] this . composite [ i ] . clear () ; } } @Override public boolean containsKey ( final Object key ) {
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { if ( this . composite [ i ] . containsKey ( key ) ) { MST[rv.UOI3Mutator]MSP[N] return this . composite [ i ] . get ( key ) ; }
final Map < K , V > [] temp = new Map [ size - 1 ] ; MST[rv.UOI4Mutator]MSP[N] System . arraycopy ( this . composite , 0 , temp , 0 , i ) ;
public boolean containsValue ( final Object value ) { for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[MathMutator]MSP[N] if ( this . composite [ i ] . containsValue ( value ) ) { return true ; } }
public boolean containsValue ( final Object value ) { for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { if ( this . composite [ i ] . containsValue ( value ) ) { MST[rv.ROR4Mutator]MSP[N] return true ; } }
public boolean containsValue ( final Object value ) { for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.AOR2Mutator]MSP[N] if ( this . composite [ i ] . containsValue ( value ) ) { return true ; } }
final int size = this . composite . length ; for ( int i = 0 ; i < size ; ++ i ) { MST[rv.UOI1Mutator]MSP[N] if ( this . composite [ i ] . equals ( map ) ) {
System . arraycopy ( this . composite , i + 1 , temp , i , size - i - 1 ) ; MST[InlineConstantMutator]MSP[N] this . composite = temp ; return map ; } } return null ; } @Override public void clear () {
final int size = this . composite . length ; for ( int i = 0 ; i < size ; ++ i ) { MST[rv.ROR4Mutator]MSP[N] if ( this . composite [ i ] . equals ( map ) ) {
} return this . mutator . put ( this , this . composite , key , value ) ; } @Override public void putAll ( final Map < ? extends K , ? extends V > map ) { if ( this . mutator == null ) { MST[rv.ROR5Mutator]MSP[S]
for ( int i = composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.CRCR2Mutator]MSP[N] final Collection < K > intersect = CollectionUtils . intersection ( this . composite [ i ] . keySet () , map . keySet () ) ;
final int size = this . composite . length ; for ( int i = 0 ; i < size ; ++ i ) { MST[rv.ROR2Mutator]MSP[N] if ( this . composite [ i ] . equals ( map ) ) {
keys . addComposited ( this . composite [ i ] . keySet () ) ; MST[rv.UOI3Mutator]MSP[N] } return keys ; } @Override public V put ( final K key , final V value ) { if ( this . mutator == null ) { throw new UnsupportedOperationException ( lr_3 ) ;
final Map < K , V > [] temp = new Map [ this . composite . length + 1 ] ; System . arraycopy ( this . composite , 0 , temp , 0 , this . composite . length ) ; MST[rv.CRCR3Mutator]MSP[N]
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { if ( this . composite [ i ] . containsKey ( key ) ) { return true ; MST[InlineConstantMutator]MSP[N] } } return false ; } @Override
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.CRCR4Mutator]MSP[N] if ( this . composite [ i ] . containsKey ( key ) ) { return true ; } } return false ; } @Override
for ( final Map . Entry < K , V > entry : entrySet () ) { code += entry . hashCode () ; } return code ; MST[rv.UOI4Mutator]MSP[N] }
} return null ; } @Override public boolean isEmpty () { for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[MathMutator]MSP[N] if ( ! this . composite [ i ] . isEmpty () ) { return false ; }
} return null ; } @Override public int size () { int size = 0 ; for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { size += this . composite [ i ] . size () ; MST[rv.ABSMutator]MSP[N] }
final int size = this . composite . length ; for ( int i = 0 ; i < size ; ++ i ) { MST[rv.CRCR6Mutator]MSP[N] if ( this . composite [ i ] . equals ( map ) ) {
} return null ; } @Override public int size () { int size = 0 ; for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { size += this . composite [ i ] . size () ; MST[rv.AOD2Mutator]MSP[N] }
System . arraycopy ( this . composite , i + 1 , temp , i , size - i - 1 ) ; MST[rv.AOD2Mutator]MSP[N] this . composite = temp ; return map ; } } return null ; } @Override public void clear () {
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.AOD1Mutator]MSP[N] if ( this . composite [ i ] . containsKey ( key ) ) { return this . composite [ i ] . remove ( key ) ; }
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.CRCR4Mutator]MSP[N] if ( this . composite [ i ] . containsKey ( key ) ) { return this . composite [ i ] . remove ( key ) ; }
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[IncrementsMutator]MSP[N] this . composite [ i ] . clear () ; } } @Override public boolean containsKey ( final Object key ) {
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.CRCR5Mutator]MSP[S] this . composite [ i ] . clear () ; } } @Override public boolean containsKey ( final Object key ) {
for ( int i = composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.UOI2Mutator]MSP[N] entries . addComposited ( composite [ i ] . entrySet () ) ; } return entries ; } @Override public V get ( final Object key ) {
return size ; } @Override public Collection < V > values () { final CompositeCollection < V > values = new CompositeCollection <> () ; for ( int i = composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.AOD2Mutator]MSP[N]
final Map < K , V > [] temp = new Map [ size - 1 ] ; System . arraycopy ( this . composite , 0 , temp , 0 , i ) ; MST[rv.CRCR5Mutator]MSP[N]
return size ; } @Override public Collection < V > values () { final CompositeCollection < V > values = new CompositeCollection <> () ; for ( int i = composite . length - 1 ; i >= 0 ; -- i ) { MST[ConditionalsBoundaryMutator]MSP[N]
} return true ; } @Override public Set < K > keySet () { final CompositeSet < K > keys = new CompositeSet <> () ; for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[NegateConditionalsMutator]MSP[N]
return size ; } @Override public Collection < V > values () { final CompositeCollection < V > values = new CompositeCollection <> () ; for ( int i = composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.UOI2Mutator]MSP[N]
System . arraycopy ( this . composite , i + 1 , temp , i , size - i - 1 ) ; this . composite = temp ; return map ; } } return null ; MST[ReturnValsMutator]MSP[S] } @Override public void clear () {
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.CRCR6Mutator]MSP[N] if ( this . composite [ i ] . containsKey ( key ) ) { return this . composite [ i ] . get ( key ) ; }
final Map < K , V > [] temp = new Map [ size - 1 ] ; MST[rv.CRCR6Mutator]MSP[N] System . arraycopy ( this . composite , 0 , temp , 0 , i ) ;
for ( int i = composite . length - 1 ; i >= 0 ; -- i ) { MST[ConditionalsBoundaryMutator]MSP[N] entries . addComposited ( composite [ i ] . entrySet () ) ; } return entries ; } @Override public V get ( final Object key ) {
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.UOI1Mutator]MSP[N] if ( this . composite [ i ] . containsKey ( key ) ) { return this . composite [ i ] . get ( key ) ; }
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { this . composite [ i ] . clear () ; MST[rv.UOI2Mutator]MSP[N] } } @Override public boolean containsKey ( final Object key ) {
values . addComposited ( composite [ i ] . values () ) ; } return values ; MST[EmptyObjectReturnValsMutator]MSP[N] } @Override public boolean equals ( final Object obj ) { if ( obj instanceof Map ) {
System . arraycopy ( this . composite , i + 1 , temp , i , size - i - 1 ) ; MST[rv.UOI2Mutator]MSP[N] this . composite = temp ; return map ; } } return null ; } @Override public void clear () {
public boolean containsValue ( final Object value ) { for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.CRCR3Mutator]MSP[N] if ( this . composite [ i ] . containsValue ( value ) ) { return true ; } }
for ( int i = composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.ROR5Mutator]MSP[N] final Collection < K > intersect = CollectionUtils . intersection ( this . composite [ i ] . keySet () , map . keySet () ) ;
} return true ; } @Override public Set < K > keySet () { final CompositeSet < K > keys = new CompositeSet <> () ; for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.AOR4Mutator]MSP[S]
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[IncrementsMutator]MSP[N] if ( this . composite [ i ] . containsKey ( key ) ) { return true ; } } return false ; } @Override
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[IncrementsMutator]MSP[N] if ( this . composite [ i ] . containsKey ( key ) ) { return this . composite [ i ] . get ( key ) ; }
return size ; } @Override public Collection < V > values () { final CompositeCollection < V > values = new CompositeCollection <> () ; for ( int i = composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.CRCR2Mutator]MSP[N]
} return null ; } @Override public int size () { int size = 0 ; for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[MathMutator]MSP[N] size += this . composite [ i ] . size () ; }
temp [ temp . length - 1 ] = map ; MST[rv.CRCR2Mutator]MSP[N] this . composite = temp ; } } @SuppressWarnings ( lr_1 ) public synchronized Map < K , V > removeComposited ( final Map < K , V > map ) {
return false ; MST[rv.CRCR6Mutator]MSP[N] } @Override public Set < Map . Entry < K , V > > entrySet () { final CompositeSet < Map . Entry < K , V > > entries = new CompositeSet <> () ;
final int size = this . composite . length ; for ( int i = 0 ; i < size ; ++ i ) { if ( this . composite [ i ] . equals ( map ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
final int size = this . composite . length ; for ( int i = 0 ; i < size ; ++ i ) { if ( this . composite [ i ] . equals ( map ) ) { MST[rv.UOI3Mutator]MSP[N]
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { if ( this . composite [ i ] . containsKey ( key ) ) { MST[NegateConditionalsMutator]MSP[N] return true ; } } return false ; } @Override
} return null ; } @Override public int size () { int size = 0 ; for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[InlineConstantMutator]MSP[N] size += this . composite [ i ] . size () ; }
final Map < K , V > [] temp = new Map [ this . composite . length + 1 ] ; MST[rv.AOD1Mutator]MSP[N] System . arraycopy ( this . composite , 0 , temp , 0 , this . composite . length ) ;
final Map < K , V > [] temp = new Map [ this . composite . length + 1 ] ; System . arraycopy ( this . composite , 0 , temp , 0 , this . composite . length ) ; MST[rv.CRCR3Mutator]MSP[N]
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { if ( this . composite [ i ] . containsKey ( key ) ) { return this . composite [ i ] . get ( key ) ; MST[rv.UOI1Mutator]MSP[N] }
final Map < K , V > [] temp = new Map [ size - 1 ] ; System . arraycopy ( this . composite , 0 , temp , 0 , i ) ; MST[rv.ABSMutator]MSP[S]
for ( int i = composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.AOR1Mutator]MSP[N] entries . addComposited ( composite [ i ] . entrySet () ) ; } return entries ; } @Override public V get ( final Object key ) {
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { if ( this . composite [ i ] . containsKey ( key ) ) { MST[rv.ABSMutator]MSP[N] return this . composite [ i ] . get ( key ) ; }
} return null ; } @Override public boolean isEmpty () { for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.AOR2Mutator]MSP[N] if ( ! this . composite [ i ] . isEmpty () ) { return false ; }
return size ; } @Override public Collection < V > values () { final CompositeCollection < V > values = new CompositeCollection <> () ; for ( int i = composite . length - 1 ; i >= 0 ; -- i ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N]
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.ROR2Mutator]MSP[N] if ( this . composite [ i ] . containsKey ( key ) ) { return this . composite [ i ] . remove ( key ) ; }
} return null ; } @Override public boolean isEmpty () { for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.ROR1Mutator]MSP[N] if ( ! this . composite [ i ] . isEmpty () ) { return false ; }
} return true ; MST[rv.CRCR2Mutator]MSP[N] } @Override public Set < K > keySet () { final CompositeSet < K > keys = new CompositeSet <> () ; for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) {
return size ; MST[ReturnValsMutator]MSP[N] } @Override public Collection < V > values () { final CompositeCollection < V > values = new CompositeCollection <> () ; for ( int i = composite . length - 1 ; i >= 0 ; -- i ) {
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.ROR4Mutator]MSP[N] if ( this . composite [ i ] . containsKey ( key ) ) { return this . composite [ i ] . get ( key ) ; }
System . arraycopy ( this . composite , i + 1 , temp , i , size - i - 1 ) ; MST[rv.AOR2Mutator]MSP[N] this . composite = temp ; return map ; } } return null ; } @Override public void clear () {
for ( final Map . Entry < K , V > entry : entrySet () ) { code += entry . hashCode () ; MST[rv.AOR1Mutator]MSP[N] } return code ; }
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] if ( this . composite [ i ] . containsKey ( key ) ) { return this . composite [ i ] . get ( key ) ; }
keys . addComposited ( this . composite [ i ] . keySet () ) ; } return keys ; } @Override public V put ( final K key , final V value ) { if ( this . mutator == null ) { MST[rv.ROR5Mutator]MSP[N] throw new UnsupportedOperationException ( lr_3 ) ;
public boolean containsValue ( final Object value ) { for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.UOI3Mutator]MSP[N] if ( this . composite [ i ] . containsValue ( value ) ) { return true ; } }
for ( int i = composite . length - 1 ; i >= 0 ; -- i ) { MST[ConditionalsBoundaryMutator]MSP[S] final Collection < K > intersect = CollectionUtils . intersection ( this . composite [ i ] . keySet () , map . keySet () ) ;
for ( int i = composite . length - 1 ; i >= 0 ; -- i ) { entries . addComposited ( composite [ i ] . entrySet () ) ; } return entries ; MST[EmptyObjectReturnValsMutator]MSP[N] } @Override public V get ( final Object key ) {
for ( int i = this . composite . length - 1 ; i >= 0 ; -- i ) { if ( this . composite [ i ] . containsKey ( key ) ) { MST[rv.ROR5Mutator]MSP[N] return this . composite [ i ] . remove ( key ) ; }
return false ; MST[rv.CRCR1Mutator]MSP[N] } @Override public Set < Map . Entry < K , V > > entrySet () { final CompositeSet < Map . Entry < K , V > > entries = new CompositeSet <> () ;
for ( int i = composite . length - 1 ; i >= 0 ; -- i ) { MST[rv.ROR5Mutator]MSP[N] entries . addComposited ( composite [ i ] . entrySet () ) ; } return entries ; } @Override public V get ( final Object key ) {
final Map < K , V > [] temp = new Map [ this . composite . length + 1 ] ; System . arraycopy ( this . composite , 0 , temp , 0 , this . composite . length ) ; MST[InlineConstantMutator]MSP[N]
