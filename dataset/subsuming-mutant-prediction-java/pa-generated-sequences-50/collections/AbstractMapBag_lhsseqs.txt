final Object [] result = new Object [ size () ] ; int i = 0 ; final Iterator < E > it = map . keySet () . iterator () ; while ( it . hasNext () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] final E current = it . next () ;
modCount ++ ; if ( nCopies < mut . value ) { mut . value -= nCopies ; size -= nCopies ; MST[rv.UOI3Mutator]MSP[] } else { map . remove ( object ) ; size -= mut . value ; } return true ; } @Override
int i = 0 ; final Iterator < E > it = map . keySet () . iterator () ; while ( it . hasNext () ) { MST[NegateConditionalsMutator]MSP[] final E current = it . next () ;
final boolean added = add ( i . next () ) ; changed = changed || added ; } return changed ; } @Override public void clear () { modCount ++ ; MST[rv.UOI3Mutator]MSP[] map . clear () ; size = 0 ; } @Override
final MutableInteger mut = map . get ( object ) ; size += nCopies ; if ( mut == null ) { map . put ( object , new MutableInteger ( nCopies ) ) ; return true ; } mut . value += nCopies ; MST[rv.UOI2Mutator]MSP[] return false ; }
modCount ++ ; if ( nCopies < mut . value ) { mut . value -= nCopies ; size -= nCopies ; } else { map . remove ( object ) ; size -= mut . value ; } return true ; MST[ReturnValsMutator]MSP[] } @Override
final int entrySize = in . readInt () ; for ( int i = 0 ; i < entrySize ; i ++ ) { MST[rv.CRCR3Mutator]MSP[] @SuppressWarnings ( lr_1 ) final E obj = ( E ) in . readObject () ; final int count = in . readInt () ;
modCount ++ ; if ( nCopies < mut . value ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] mut . value -= nCopies ; size -= nCopies ; } else { map . remove ( object ) ; size -= mut . value ; } return true ; } @Override
buf . append ( '[' ) ; final Iterator < E > it = uniqueSet () . iterator () ; MST[NonVoidMethodCallMutator]MSP[] while ( it . hasNext () ) { final Object current = it . next () ; final int count = getCount ( current ) ;
array [ i ++ ] = null ; MST[rv.UOI1Mutator]MSP[] } return array ; } @Override public Set < E > uniqueSet () { if ( uniqueSet == null ) { uniqueSet = UnmodifiableSet . <E > unmodifiableSet ( map . keySet () ) ; } return uniqueSet ; }
modCount ++ ; if ( nCopies < mut . value ) { mut . value -= nCopies ; size -= nCopies ; } else { map . remove ( object ) ; size -= mut . value ; MST[rv.UOI3Mutator]MSP[] } return true ; } @Override
for ( int index = getCount ( current ) ; index > 0 ; index -- ) { @SuppressWarnings ( lr_1 ) final T unchecked = ( T ) current ; array [ i ++ ] = unchecked ; } } while ( i < array . length ) { MST[rv.ROR3Mutator]MSP[]
modCount ++ ; if ( nCopies < mut . value ) { mut . value -= nCopies ; size -= nCopies ; MST[experimental.MemberVariableMutator]MSP[] } else { map . remove ( object ) ; size -= mut . value ; } return true ; } @Override
canRemove = false ; } @Override public boolean add ( final E object ) { return add ( object , 1 ) ; } @Override public boolean add ( final E object , final int nCopies ) { modCount ++ ; MST[rv.CRCR2Mutator]MSP[] if ( nCopies > 0 ) {
protected void doWriteObject ( final ObjectOutputStream out ) throws IOException { out . writeInt ( map . size () ) ; MST[NonVoidMethodCallMutator]MSP[] for ( final Entry < E , MutableInteger > entry : map . entrySet () ) { out . writeObject ( entry . getKey () ) ;
modCount ++ ; if ( nCopies < mut . value ) { mut . value -= nCopies ; size -= nCopies ; MST[MathMutator]MSP[] } else { map . remove ( object ) ; size -= mut . value ; } return true ; } @Override
if ( other . getCount ( element ) != getCount ( element ) ) { return false ; } } return true ; MST[rv.CRCR4Mutator]MSP[] } @Override public int hashCode () { int total = 0 ;
final int size = size () ; if ( array . length < size ) { MST[rv.UOI2Mutator]MSP[] @SuppressWarnings ( lr_1 ) final T [] unchecked = ( T [] ) Array . newInstance ( array . getClass () . getComponentType () , size ) ; array = unchecked ; }
for ( int index = getCount ( current ) ; index > 0 ; index -- ) { result [ i ++ ] = current ; MST[IncrementsMutator]MSP[] } } return result ; } @Override public < T > T [] toArray ( T [] array ) {
for ( int index = getCount ( current ) ; index > 0 ; index -- ) { MST[rv.UOI2Mutator]MSP[] @SuppressWarnings ( lr_1 ) final T unchecked = ( T ) current ; array [ i ++ ] = unchecked ; } } while ( i < array . length ) {
buf . append ( count ) ; buf . append ( ':' ) ; buf . append ( current ) ; MST[NonVoidMethodCallMutator]MSP[] if ( it . hasNext () ) { buf . append ( ',' ) ; } } buf . append ( ']' ) ;
modCount ++ ; if ( nCopies < mut . value ) { mut . value -= nCopies ; size -= nCopies ; } else { map . remove ( object ) ; size -= mut . value ; MST[rv.ABSMutator]MSP[] } return true ; } @Override
map . put ( obj , new MutableInteger ( count ) ) ; size += count ; MST[rv.AOR2Mutator]MSP[] } } @Override public boolean equals ( final Object object ) { if ( object == this ) { return true ; } if ( object instanceof Bag == false ) {
canRemove = false ; } @Override public boolean add ( final E object ) { return add ( object , 1 ) ; MST[NonVoidMethodCallMutator]MSP[] } @Override public boolean add ( final E object , final int nCopies ) { modCount ++ ; if ( nCopies > 0 ) {
final boolean added = add ( i . next () ) ; changed = changed || added ; MST[rv.CRCR6Mutator]MSP[] } return changed ; } @Override public void clear () { modCount ++ ; map . clear () ; size = 0 ; } @Override
map . put ( obj , new MutableInteger ( count ) ) ; size += count ; MST[rv.UOI2Mutator]MSP[] } } @Override public boolean equals ( final Object object ) { if ( object == this ) { return true ; } if ( object instanceof Bag == false ) {
modCount ++ ; MST[rv.CRCR2Mutator]MSP[] if ( nCopies < mut . value ) { mut . value -= nCopies ; size -= nCopies ; } else { map . remove ( object ) ; size -= mut . value ; } return true ; } @Override
total += ( element == null ? 0 : element . hashCode () ) ^ count . value ; } return total ; MST[rv.UOI1Mutator]MSP[] } @Override public String toString () { if ( size () == 0 ) { return lr_2 ; } final StringBuilder buf = new StringBuilder () ;
final boolean added = add ( i . next () ) ; changed = changed || added ; MST[rv.ABSMutator]MSP[] } return changed ; } @Override public void clear () { modCount ++ ; map . clear () ; size = 0 ; } @Override
canRemove = false ; } @Override public boolean add ( final E object ) { return add ( object , 1 ) ; MST[InlineConstantMutator]MSP[] } @Override public boolean add ( final E object , final int nCopies ) { modCount ++ ; if ( nCopies > 0 ) {
canRemove = false ; } @Override public boolean add ( final E object ) { return add ( object , 1 ) ; MST[rv.CRCR3Mutator]MSP[] } @Override public boolean add ( final E object , final int nCopies ) { modCount ++ ; if ( nCopies > 0 ) {
for ( int index = getCount ( current ) ; index > 0 ; index -- ) { MST[rv.ROR4Mutator]MSP[] result [ i ++ ] = current ; } } return result ; } @Override public < T > T [] toArray ( T [] array ) {
map . put ( obj , new MutableInteger ( count ) ) ; size += count ; } } @Override public boolean equals ( final Object object ) { if ( object == this ) { return true ; MST[InlineConstantMutator]MSP[] } if ( object instanceof Bag == false ) {
final MutableInteger mut = map . get ( object ) ; size += nCopies ; if ( mut == null ) { map . put ( object , new MutableInteger ( nCopies ) ) ; return true ; MST[ReturnValsMutator]MSP[] } mut . value += nCopies ; return false ; }
for ( int index = getCount ( current ) ; index > 0 ; index -- ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[] result [ i ++ ] = current ; } } return result ; } @Override public < T > T [] toArray ( T [] array ) {
for ( int index = getCount ( current ) ; index > 0 ; index -- ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] @SuppressWarnings ( lr_1 ) final T unchecked = ( T ) current ; array [ i ++ ] = unchecked ; } } while ( i < array . length ) {
array [ i ++ ] = null ; } return array ; MST[ReturnValsMutator]MSP[] } @Override public Set < E > uniqueSet () { if ( uniqueSet == null ) { uniqueSet = UnmodifiableSet . <E > unmodifiableSet ( map . keySet () ) ; } return uniqueSet ; }
final int entrySize = in . readInt () ; for ( int i = 0 ; i < entrySize ; i ++ ) { MST[rv.UOI4Mutator]MSP[] @SuppressWarnings ( lr_1 ) final E obj = ( E ) in . readObject () ; final int count = in . readInt () ;
protected Map < E , MutableInteger > getMap () { return map ; } @Override public int size () { return size ; MST[ReturnValsMutator]MSP[] } @Override public boolean isEmpty () { return map . isEmpty () ; } @Override public int getCount ( final Object object ) {
final boolean added = add ( i . next () ) ; changed = changed || added ; MST[rv.UOI3Mutator]MSP[] } return changed ; } @Override public void clear () { modCount ++ ; map . clear () ; size = 0 ; } @Override
final Object [] result = new Object [ size () ] ; int i = 0 ; final Iterator < E > it = map . keySet () . iterator () ; while ( it . hasNext () ) { MST[rv.ROR4Mutator]MSP[] final E current = it . next () ;
final int size = size () ; if ( array . length < size ) { MST[ConditionalsBoundaryMutator]MSP[] @SuppressWarnings ( lr_1 ) final T [] unchecked = ( T [] ) Array . newInstance ( array . getClass () . getComponentType () , size ) ; array = unchecked ; }
modCount ++ ; if ( nCopies < mut . value ) { MST[rv.UOI2Mutator]MSP[] mut . value -= nCopies ; size -= nCopies ; } else { map . remove ( object ) ; size -= mut . value ; } return true ; } @Override
final int entrySize = in . readInt () ; for ( int i = 0 ; i < entrySize ; i ++ ) { MST[rv.ROR1Mutator]MSP[] @SuppressWarnings ( lr_1 ) final E obj = ( E ) in . readObject () ; final int count = in . readInt () ;
canRemove = false ; } @Override public boolean add ( final E object ) { return add ( object , 1 ) ; } @Override public boolean add ( final E object , final int nCopies ) { modCount ++ ; if ( nCopies > 0 ) { MST[ConditionalsBoundaryMutator]MSP[]
final boolean added = add ( i . next () ) ; changed = changed || added ; } return changed ; MST[rv.UOI4Mutator]MSP[] } @Override public void clear () { modCount ++ ; map . clear () ; size = 0 ; } @Override
} @Override public boolean remove ( final Object object , final int nCopies ) { final MutableInteger mut = map . get ( object ) ; if ( mut == null ) { return false ; } if ( nCopies <= 0 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] return false ; }
modCount ++ ; if ( nCopies < mut . value ) { mut . value -= nCopies ; size -= nCopies ; MST[rv.AOR2Mutator]MSP[] } else { map . remove ( object ) ; size -= mut . value ; } return true ; } @Override
canRemove = false ; } @Override public boolean add ( final E object ) { return add ( object , 1 ) ; } @Override public boolean add ( final E object , final int nCopies ) { modCount ++ ; MST[rv.AOR1Mutator]MSP[] if ( nCopies > 0 ) {
final MutableInteger mut = map . get ( object ) ; size += nCopies ; if ( mut == null ) { map . put ( object , new MutableInteger ( nCopies ) ) ; return true ; } mut . value += nCopies ; MST[rv.UOI1Mutator]MSP[] return false ; }
final MutableInteger count = map . get ( object ) ; MST[NonVoidMethodCallMutator]MSP[] if ( count != null ) { return count . value ; } return 0 ; } @Override public boolean contains ( final Object object ) { return map . containsKey ( object ) ; } @Override
modCount ++ ; if ( nCopies < mut . value ) { mut . value -= nCopies ; size -= nCopies ; } else { map . remove ( object ) ; size -= mut . value ; MST[rv.UOI3Mutator]MSP[] } return true ; } @Override
final int size = size () ; if ( array . length < size ) { MST[rv.ROR5Mutator]MSP[] @SuppressWarnings ( lr_1 ) final T [] unchecked = ( T [] ) Array . newInstance ( array . getClass () . getComponentType () , size ) ; array = unchecked ; }
return false ; } @Override public boolean addAll ( final Collection < ? extends E > coll ) { boolean changed = false ; final Iterator < ? extends E > i = coll . iterator () ; MST[NonVoidMethodCallMutator]MSP[] while ( i . hasNext () ) {
} @Override public boolean remove ( final Object object , final int nCopies ) { final MutableInteger mut = map . get ( object ) ; if ( mut == null ) { return false ; } if ( nCopies <= 0 ) { MST[rv.UOI2Mutator]MSP[] return false ; }
protected Map < E , MutableInteger > getMap () { return map ; } @Override public int size () { return size ; MST[PrimitiveReturnsMutator]MSP[] } @Override public boolean isEmpty () { return map . isEmpty () ; } @Override public int getCount ( final Object object ) {
out . writeInt ( entry . getValue () . value ) ; } } protected void doReadObject ( final Map < E , MutableInteger > map , final ObjectInputStream in ) throws IOException , ClassNotFoundException { this . map = map ; MST[experimental.MemberVariableMutator]MSP[]
final MutableInteger mut = map . get ( object ) ; size += nCopies ; MST[rv.UOI4Mutator]MSP[] if ( mut == null ) { map . put ( object , new MutableInteger ( nCopies ) ) ; return true ; } mut . value += nCopies ; return false ; }
out . writeInt ( entry . getValue () . value ) ; MST[rv.UOI1Mutator]MSP[] } } protected void doReadObject ( final Map < E , MutableInteger > map , final ObjectInputStream in ) throws IOException , ClassNotFoundException { this . map = map ;
final boolean changed = remove ( i . next () , 1 ) ; result = result || changed ; } } return result ; } @Override public boolean retainAll ( final Collection < ? > coll ) { if ( coll instanceof Bag ) { MST[rv.ROR3Mutator]MSP[]
final int entrySize = in . readInt () ; for ( int i = 0 ; i < entrySize ; i ++ ) { MST[IncrementsMutator]MSP[] @SuppressWarnings ( lr_1 ) final E obj = ( E ) in . readObject () ; final int count = in . readInt () ;
modCount ++ ; if ( nCopies < mut . value ) { mut . value -= nCopies ; MST[rv.AOD1Mutator]MSP[] size -= nCopies ; } else { map . remove ( object ) ; size -= mut . value ; } return true ; } @Override
modCount ++ ; if ( nCopies < mut . value ) { mut . value -= nCopies ; size -= nCopies ; } else { map . remove ( object ) ; MST[NonVoidMethodCallMutator]MSP[] size -= mut . value ; } return true ; } @Override
buf . append ( count ) ; buf . append ( ':' ) ; MST[NonVoidMethodCallMutator]MSP[] buf . append ( current ) ; if ( it . hasNext () ) { buf . append ( ',' ) ; } } buf . append ( ']' ) ;
canRemove = false ; } @Override public boolean add ( final E object ) { return add ( object , 1 ) ; } @Override public boolean add ( final E object , final int nCopies ) { modCount ++ ; MST[rv.UOI3Mutator]MSP[] if ( nCopies > 0 ) {
int i = 0 ; final Iterator < E > it = map . keySet () . iterator () ; while ( it . hasNext () ) { MST[rv.ROR2Mutator]MSP[] final E current = it . next () ;
modCount ++ ; if ( nCopies < mut . value ) { mut . value -= nCopies ; size -= nCopies ; } else { map . remove ( object ) ; size -= mut . value ; } return true ; MST[rv.CRCR2Mutator]MSP[] } @Override
final MutableInteger mut = map . get ( object ) ; size += nCopies ; if ( mut == null ) { map . put ( object , new MutableInteger ( nCopies ) ) ; return true ; } mut . value += nCopies ; MST[rv.UOI3Mutator]MSP[] return false ; }
modCount ++ ; if ( nCopies < mut . value ) { mut . value -= nCopies ; size -= nCopies ; } else { map . remove ( object ) ; size -= mut . value ; MST[rv.AOR1Mutator]MSP[] } return true ; } @Override
canRemove = false ; } @Override public boolean add ( final E object ) { return add ( object , 1 ) ; } @Override public boolean add ( final E object , final int nCopies ) { modCount ++ ; MST[rv.AOR4Mutator]MSP[] if ( nCopies > 0 ) {
final boolean added = add ( i . next () ) ; changed = changed || added ; } return changed ; } @Override public void clear () { modCount ++ ; MST[rv.UOI2Mutator]MSP[] map . clear () ; size = 0 ; } @Override
for ( int index = getCount ( current ) ; index > 0 ; index -- ) { @SuppressWarnings ( lr_1 ) final T unchecked = ( T ) current ; array [ i ++ ] = unchecked ; } } while ( i < array . length ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[]
modCount ++ ; if ( nCopies < mut . value ) { mut . value -= nCopies ; size -= nCopies ; } else { map . remove ( object ) ; size -= mut . value ; MST[rv.UOI4Mutator]MSP[] } return true ; } @Override
if ( other . getCount ( element ) != getCount ( element ) ) { MST[NegateConditionalsMutator]MSP[] return false ; } } return true ; } @Override public int hashCode () { int total = 0 ;
buf . append ( count ) ; buf . append ( ':' ) ; buf . append ( current ) ; if ( it . hasNext () ) { buf . append ( ',' ) ; MST[InlineConstantMutator]MSP[] } } buf . append ( ']' ) ;
if ( other . getCount ( element ) != getCount ( element ) ) { return false ; } } return true ; MST[rv.CRCR3Mutator]MSP[] } @Override public int hashCode () { int total = 0 ;
final int size = size () ; if ( array . length < size ) { MST[rv.ROR2Mutator]MSP[] @SuppressWarnings ( lr_1 ) final T [] unchecked = ( T [] ) Array . newInstance ( array . getClass () . getComponentType () , size ) ; array = unchecked ; }
final boolean added = add ( i . next () ) ; changed = changed || added ; MST[rv.ABSMutator]MSP[] } return changed ; } @Override public void clear () { modCount ++ ; map . clear () ; size = 0 ; } @Override
canRemove = false ; } @Override public boolean add ( final E object ) { return add ( object , 1 ) ; } @Override public boolean add ( final E object , final int nCopies ) { modCount ++ ; MST[MathMutator]MSP[] if ( nCopies > 0 ) {
final boolean added = add ( i . next () ) ; changed = changed || added ; } return changed ; } @Override public void clear () { modCount ++ ; map . clear () ; size = 0 ; MST[rv.CRCR5Mutator]MSP[] } @Override
final int size = size () ; if ( array . length < size ) { MST[rv.UOI1Mutator]MSP[] @SuppressWarnings ( lr_1 ) final T [] unchecked = ( T [] ) Array . newInstance ( array . getClass () . getComponentType () , size ) ; array = unchecked ; }
for ( int index = getCount ( current ) ; index > 0 ; index -- ) { @SuppressWarnings ( lr_1 ) final T unchecked = ( T ) current ; array [ i ++ ] = unchecked ; } } while ( i < array . length ) { MST[ConditionalsBoundaryMutator]MSP[]
final boolean added = add ( i . next () ) ; changed = changed || added ; } return changed ; } @Override public void clear () { modCount ++ ; MST[rv.AOD1Mutator]MSP[] map . clear () ; size = 0 ; } @Override
if ( other . getCount ( element ) != getCount ( element ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return false ; } } return true ; } @Override public int hashCode () { int total = 0 ;
modCount ++ ; if ( nCopies < mut . value ) { mut . value -= nCopies ; MST[rv.AOR3Mutator]MSP[] size -= nCopies ; } else { map . remove ( object ) ; size -= mut . value ; } return true ; } @Override
return false ; MST[rv.CRCR6Mutator]MSP[] } @Override public boolean addAll ( final Collection < ? extends E > coll ) { boolean changed = false ; final Iterator < ? extends E > i = coll . iterator () ; while ( i . hasNext () ) {
final boolean added = add ( i . next () ) ; changed = changed || added ; } return changed ; } @Override public void clear () { modCount ++ ; MST[rv.CRCR2Mutator]MSP[] map . clear () ; size = 0 ; } @Override
final boolean added = add ( i . next () ) ; changed = changed || added ; MST[rv.UOI2Mutator]MSP[] } return changed ; } @Override public void clear () { modCount ++ ; map . clear () ; size = 0 ; } @Override
if ( other . getCount ( element ) != getCount ( element ) ) { MST[rv.ROR5Mutator]MSP[] return false ; } } return true ; } @Override public int hashCode () { int total = 0 ;
final boolean added = add ( i . next () ) ; changed = changed || added ; } return changed ; MST[rv.UOI3Mutator]MSP[] } @Override public void clear () { modCount ++ ; map . clear () ; size = 0 ; } @Override
modCount ++ ; if ( nCopies < mut . value ) { mut . value -= nCopies ; size -= nCopies ; MST[rv.UOI4Mutator]MSP[] } else { map . remove ( object ) ; size -= mut . value ; } return true ; } @Override
protected Map < E , MutableInteger > getMap () { return map ; } @Override public int size () { return size ; MST[rv.ABSMutator]MSP[] } @Override public boolean isEmpty () { return map . isEmpty () ; } @Override public int getCount ( final Object object ) {
final boolean added = add ( i . next () ) ; changed = changed || added ; } return changed ; } @Override public void clear () { modCount ++ ; MST[InlineConstantMutator]MSP[] map . clear () ; size = 0 ; } @Override
for ( int index = getCount ( current ) ; index > 0 ; index -- ) { result [ i ++ ] = current ; MST[rv.ABSMutator]MSP[] } } return result ; } @Override public < T > T [] toArray ( T [] array ) {
final int size = size () ; if ( array . length < size ) { @SuppressWarnings ( lr_1 ) final T [] unchecked = ( T [] ) Array . newInstance ( array . getClass () . getComponentType () , size ) ; MST[NonVoidMethodCallMutator]MSP[] array = unchecked ; }
final boolean added = add ( i . next () ) ; changed = changed || added ; MST[rv.ROR3Mutator]MSP[] } return changed ; } @Override public void clear () { modCount ++ ; map . clear () ; size = 0 ; } @Override
final boolean added = add ( i . next () ) ; changed = changed || added ; } return changed ; } @Override public void clear () { modCount ++ ; MST[rv.AOR3Mutator]MSP[] map . clear () ; size = 0 ; } @Override
final boolean added = add ( i . next () ) ; changed = changed || added ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] } return changed ; } @Override public void clear () { modCount ++ ; map . clear () ; size = 0 ; } @Override
map . put ( obj , new MutableInteger ( count ) ) ; size += count ; MST[MathMutator]MSP[] } } @Override public boolean equals ( final Object object ) { if ( object == this ) { return true ; } if ( object instanceof Bag == false ) {
final Object [] result = new Object [ size () ] ; int i = 0 ; final Iterator < E > it = map . keySet () . iterator () ; while ( it . hasNext () ) { MST[rv.ROR2Mutator]MSP[] final E current = it . next () ;
buf . append ( count ) ; buf . append ( ':' ) ; buf . append ( current ) ; if ( it . hasNext () ) { buf . append ( ',' ) ; } } buf . append ( ']' ) ; MST[rv.CRCR5Mutator]MSP[]
} @Override public boolean remove ( final Object object , final int nCopies ) { final MutableInteger mut = map . get ( object ) ; if ( mut == null ) { return false ; } if ( nCopies <= 0 ) { MST[rv.ROR1Mutator]MSP[] return false ; }
modCount ++ ; MST[rv.AOD2Mutator]MSP[] if ( nCopies < mut . value ) { mut . value -= nCopies ; size -= nCopies ; } else { map . remove ( object ) ; size -= mut . value ; } return true ; } @Override
final Object [] result = new Object [ size () ] ; int i = 0 ; MST[rv.CRCR5Mutator]MSP[] final Iterator < E > it = map . keySet () . iterator () ; while ( it . hasNext () ) { final E current = it . next () ;
for ( int index = getCount ( current ) ; index > 0 ; index -- ) { MST[rv.UOI1Mutator]MSP[] @SuppressWarnings ( lr_1 ) final T unchecked = ( T ) current ; array [ i ++ ] = unchecked ; } } while ( i < array . length ) {
final int entrySize = in . readInt () ; MST[NonVoidMethodCallMutator]MSP[] for ( int i = 0 ; i < entrySize ; i ++ ) { @SuppressWarnings ( lr_1 ) final E obj = ( E ) in . readObject () ; final int count = in . readInt () ;
map . put ( obj , new MutableInteger ( count ) ) ; size += count ; MST[rv.AOR1Mutator]MSP[] } } @Override public boolean equals ( final Object object ) { if ( object == this ) { return true ; } if ( object instanceof Bag == false ) {
map . put ( obj , new MutableInteger ( count ) ) ; size += count ; MST[rv.AOR4Mutator]MSP[] } } @Override public boolean equals ( final Object object ) { if ( object == this ) { return true ; } if ( object instanceof Bag == false ) {
canRemove = false ; } @Override public boolean add ( final E object ) { return add ( object , 1 ) ; } @Override public boolean add ( final E object , final int nCopies ) { modCount ++ ; MST[rv.AOD2Mutator]MSP[] if ( nCopies > 0 ) {
map . put ( obj , new MutableInteger ( count ) ) ; MST[rv.UOI1Mutator]MSP[] size += count ; } } @Override public boolean equals ( final Object object ) { if ( object == this ) { return true ; } if ( object instanceof Bag == false ) {
} @Override public boolean remove ( final Object object , final int nCopies ) { final MutableInteger mut = map . get ( object ) ; if ( mut == null ) { return false ; MST[rv.CRCR3Mutator]MSP[] } if ( nCopies <= 0 ) { return false ; }
} @Override public boolean remove ( final Object object , final int nCopies ) { final MutableInteger mut = map . get ( object ) ; if ( mut == null ) { return false ; MST[rv.CRCR6Mutator]MSP[] } if ( nCopies <= 0 ) { return false ; }
} @Override public boolean remove ( final Object object , final int nCopies ) { final MutableInteger mut = map . get ( object ) ; if ( mut == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return false ; } if ( nCopies <= 0 ) { return false ; }
for ( int index = getCount ( current ) ; index > 0 ; index -- ) { @SuppressWarnings ( lr_1 ) final T unchecked = ( T ) current ; array [ i ++ ] = unchecked ; } } while ( i < array . length ) { MST[rv.ABSMutator]MSP[]
modCount ++ ; MST[rv.CRCR6Mutator]MSP[] if ( nCopies < mut . value ) { mut . value -= nCopies ; size -= nCopies ; } else { map . remove ( object ) ; size -= mut . value ; } return true ; } @Override
modCount ++ ; if ( nCopies < mut . value ) { mut . value -= nCopies ; size -= nCopies ; } else { map . remove ( object ) ; size -= mut . value ; MST[rv.UOI4Mutator]MSP[] } return true ; } @Override
map . put ( obj , new MutableInteger ( count ) ) ; size += count ; MST[rv.UOI3Mutator]MSP[] } } @Override public boolean equals ( final Object object ) { if ( object == this ) { return true ; } if ( object instanceof Bag == false ) {
map . put ( obj , new MutableInteger ( count ) ) ; size += count ; MST[rv.UOI4Mutator]MSP[] } } @Override public boolean equals ( final Object object ) { if ( object == this ) { return true ; } if ( object instanceof Bag == false ) {
modCount ++ ; MST[rv.AOR4Mutator]MSP[] if ( nCopies < mut . value ) { mut . value -= nCopies ; size -= nCopies ; } else { map . remove ( object ) ; size -= mut . value ; } return true ; } @Override
for ( int index = getCount ( current ) ; index > 0 ; index -- ) { @SuppressWarnings ( lr_1 ) final T unchecked = ( T ) current ; array [ i ++ ] = unchecked ; } } while ( i < array . length ) { MST[NegateConditionalsMutator]MSP[]
canRemove = false ; } @Override public boolean add ( final E object ) { return add ( object , 1 ) ; MST[rv.CRCR5Mutator]MSP[] } @Override public boolean add ( final E object , final int nCopies ) { modCount ++ ; if ( nCopies > 0 ) {
int i = 0 ; MST[InlineConstantMutator]MSP[] final Iterator < E > it = map . keySet () . iterator () ; while ( it . hasNext () ) { final E current = it . next () ;
for ( int index = getCount ( current ) ; index > 0 ; index -- ) { result [ i ++ ] = current ; MST[rv.UOI2Mutator]MSP[] } } return result ; } @Override public < T > T [] toArray ( T [] array ) {
for ( int index = getCount ( current ) ; index > 0 ; index -- ) { MST[rv.ROR2Mutator]MSP[] result [ i ++ ] = current ; } } return result ; } @Override public < T > T [] toArray ( T [] array ) {
} @Override public boolean remove ( final Object object , final int nCopies ) { final MutableInteger mut = map . get ( object ) ; if ( mut == null ) { return false ; } if ( nCopies <= 0 ) { MST[rv.UOI3Mutator]MSP[] return false ; }
final MutableInteger mut = map . get ( object ) ; size += nCopies ; if ( mut == null ) { map . put ( object , new MutableInteger ( nCopies ) ) ; return true ; } mut . value += nCopies ; return false ; MST[rv.CRCR5Mutator]MSP[] }
final boolean added = add ( i . next () ) ; changed = changed || added ; } return changed ; } @Override public void clear () { modCount ++ ; map . clear () ; size = 0 ; MST[experimental.MemberVariableMutator]MSP[] } @Override
public boolean removeAll ( final Collection < ? > coll ) { boolean result = false ; MST[InlineConstantMutator]MSP[] if ( coll != null ) { final Iterator < ? > i = coll . iterator () ; while ( i . hasNext () ) {
final int size = size () ; if ( array . length < size ) { @SuppressWarnings ( lr_1 ) final T [] unchecked = ( T [] ) Array . newInstance ( array . getClass () . getComponentType () , size ) ; MST[experimental.NakedReceiverMutator]MSP[] array = unchecked ; }
buf . append ( count ) ; buf . append ( ':' ) ; buf . append ( current ) ; if ( it . hasNext () ) { MST[rv.ROR3Mutator]MSP[] buf . append ( ',' ) ; } } buf . append ( ']' ) ;
final boolean added = add ( i . next () ) ; changed = changed || added ; MST[rv.UOI2Mutator]MSP[] } return changed ; } @Override public void clear () { modCount ++ ; map . clear () ; size = 0 ; } @Override
final boolean changed = remove ( i . next () , 1 ) ; result = result || changed ; } } return result ; MST[BooleanTrueReturnValsMutator]MSP[] } @Override public boolean retainAll ( final Collection < ? > coll ) { if ( coll instanceof Bag ) {
for ( final Entry < E , MutableInteger > entry : map . entrySet () ) { MST[NonVoidMethodCallMutator]MSP[] final E element = entry . getKey () ; final MutableInteger count = entry . getValue () ;
final boolean changed = remove ( i . next () , 1 ) ; result = result || changed ; } } return result ; } @Override public boolean retainAll ( final Collection < ? > coll ) { if ( coll instanceof Bag ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
buf . append ( count ) ; buf . append ( ':' ) ; buf . append ( current ) ; if ( it . hasNext () ) { buf . append ( ',' ) ; MST[NonVoidMethodCallMutator]MSP[] } } buf . append ( ']' ) ;
modCount ++ ; MST[MathMutator]MSP[] if ( nCopies < mut . value ) { mut . value -= nCopies ; size -= nCopies ; } else { map . remove ( object ) ; size -= mut . value ; } return true ; } @Override
buf . append ( count ) ; buf . append ( ':' ) ; MST[InlineConstantMutator]MSP[] buf . append ( current ) ; if ( it . hasNext () ) { buf . append ( ',' ) ; } } buf . append ( ']' ) ;
final int size = size () ; if ( array . length < size ) { @SuppressWarnings ( lr_1 ) final T [] unchecked = ( T [] ) Array . newInstance ( array . getClass () . getComponentType () , size ) ; MST[rv.ABSMutator]MSP[] array = unchecked ; }
modCount ++ ; MST[rv.CRCR3Mutator]MSP[] if ( nCopies < mut . value ) { mut . value -= nCopies ; size -= nCopies ; } else { map . remove ( object ) ; size -= mut . value ; } return true ; } @Override
array [ i ++ ] = null ; } return array ; } @Override public Set < E > uniqueSet () { if ( uniqueSet == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] uniqueSet = UnmodifiableSet . <E > unmodifiableSet ( map . keySet () ) ; } return uniqueSet ; }
total += ( element == null ? 0 : element . hashCode () ) ^ count . value ; } return total ; MST[rv.UOI2Mutator]MSP[] } @Override public String toString () { if ( size () == 0 ) { return lr_2 ; } final StringBuilder buf = new StringBuilder () ;
final MutableInteger mut = map . get ( object ) ; size += nCopies ; if ( mut == null ) { map . put ( object , new MutableInteger ( nCopies ) ) ; return true ; } mut . value += nCopies ; return false ; MST[ReturnValsMutator]MSP[] }
map . put ( obj , new MutableInteger ( count ) ) ; size += count ; } } @Override public boolean equals ( final Object object ) { if ( object == this ) { return true ; MST[rv.CRCR2Mutator]MSP[] } if ( object instanceof Bag == false ) {
final boolean added = add ( i . next () ) ; changed = changed || added ; } return changed ; } @Override public void clear () { modCount ++ ; MST[rv.ABSMutator]MSP[] map . clear () ; size = 0 ; } @Override
for ( int index = getCount ( current ) ; index > 0 ; index -- ) { @SuppressWarnings ( lr_1 ) final T unchecked = ( T ) current ; array [ i ++ ] = unchecked ; MST[rv.ABSMutator]MSP[] } } while ( i < array . length ) {
for ( int index = getCount ( current ) ; index > 0 ; index -- ) { MST[rv.ROR5Mutator]MSP[] result [ i ++ ] = current ; } } return result ; } @Override public < T > T [] toArray ( T [] array ) {
buf . append ( count ) ; buf . append ( ':' ) ; buf . append ( current ) ; if ( it . hasNext () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] buf . append ( ',' ) ; } } buf . append ( ']' ) ;
final int entrySize = in . readInt () ; for ( int i = 0 ; i < entrySize ; i ++ ) { MST[rv.UOI2Mutator]MSP[] @SuppressWarnings ( lr_1 ) final E obj = ( E ) in . readObject () ; final int count = in . readInt () ;
final int size = size () ; if ( array . length < size ) { MST[rv.UOI4Mutator]MSP[] @SuppressWarnings ( lr_1 ) final T [] unchecked = ( T [] ) Array . newInstance ( array . getClass () . getComponentType () , size ) ; array = unchecked ; }
out . writeInt ( entry . getValue () . value ) ; MST[rv.UOI4Mutator]MSP[] } } protected void doReadObject ( final Map < E , MutableInteger > map , final ObjectInputStream in ) throws IOException , ClassNotFoundException { this . map = map ;
final boolean changed = remove ( i . next () , 1 ) ; result = result || changed ; } } return result ; MST[rv.UOI1Mutator]MSP[] } @Override public boolean retainAll ( final Collection < ? > coll ) { if ( coll instanceof Bag ) {
final MutableInteger count = map . get ( object ) ; if ( count != null ) { return count . value ; } return 0 ; } @Override public boolean contains ( final Object object ) { return map . containsKey ( object ) ; MST[ReturnValsMutator]MSP[] } @Override
final MutableInteger count = map . get ( object ) ; if ( count != null ) { return count . value ; } return 0 ; } @Override public boolean contains ( final Object object ) { return map . containsKey ( object ) ; MST[BooleanTrueReturnValsMutator]MSP[] } @Override
final MutableInteger mut = map . get ( object ) ; size += nCopies ; if ( mut == null ) { map . put ( object , new MutableInteger ( nCopies ) ) ; return true ; } mut . value += nCopies ; MST[rv.AOR3Mutator]MSP[] return false ; }
int i = 0 ; final Iterator < E > it = map . keySet () . iterator () ; MST[NonVoidMethodCallMutator]MSP[] while ( it . hasNext () ) { final E current = it . next () ;
buf . append ( count ) ; buf . append ( ':' ) ; buf . append ( current ) ; if ( it . hasNext () ) { buf . append ( ',' ) ; } } buf . append ( ']' ) ; MST[NonVoidMethodCallMutator]MSP[]
final MutableInteger count = map . get ( object ) ; if ( count != null ) { return count . value ; MST[ReturnValsMutator]MSP[] } return 0 ; } @Override public boolean contains ( final Object object ) { return map . containsKey ( object ) ; } @Override
final MutableInteger mut = map . get ( object ) ; size += nCopies ; if ( mut == null ) { map . put ( object , new MutableInteger ( nCopies ) ) ; return true ; } mut . value += nCopies ; MST[rv.UOI4Mutator]MSP[] return false ; }
buf . append ( count ) ; buf . append ( ':' ) ; buf . append ( current ) ; if ( it . hasNext () ) { buf . append ( ',' ) ; } } buf . append ( ']' ) ; MST[rv.CRCR2Mutator]MSP[]
total += ( element == null ? 0 : element . hashCode () ) ^ count . value ; } return total ; MST[rv.ABSMutator]MSP[] } @Override public String toString () { if ( size () == 0 ) { return lr_2 ; } final StringBuilder buf = new StringBuilder () ;
for ( int index = getCount ( current ) ; index > 0 ; index -- ) { MST[NonVoidMethodCallMutator]MSP[] result [ i ++ ] = current ; } } return result ; } @Override public < T > T [] toArray ( T [] array ) {
for ( int index = getCount ( current ) ; index > 0 ; index -- ) { result [ i ++ ] = current ; MST[experimental.RemoveIncrementsMutator]MSP[] } } return result ; } @Override public < T > T [] toArray ( T [] array ) {
int i = 0 ; final Iterator < E > it = map . keySet () . iterator () ; while ( it . hasNext () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] final E current = it . next () ;
total += ( element == null ? 0 : element . hashCode () ) ^ count . value ; } return total ; MST[PrimitiveReturnsMutator]MSP[] } @Override public String toString () { if ( size () == 0 ) { return lr_2 ; } final StringBuilder buf = new StringBuilder () ;
final int size = size () ; MST[NonVoidMethodCallMutator]MSP[] if ( array . length < size ) { @SuppressWarnings ( lr_1 ) final T [] unchecked = ( T [] ) Array . newInstance ( array . getClass () . getComponentType () , size ) ; array = unchecked ; }
return false ; } @Override public boolean addAll ( final Collection < ? extends E > coll ) { boolean changed = false ; final Iterator < ? extends E > i = coll . iterator () ; while ( i . hasNext () ) { MST[rv.ROR3Mutator]MSP[]
final boolean changed = remove ( i . next () , 1 ) ; result = result || changed ; } } return result ; MST[ReturnValsMutator]MSP[] } @Override public boolean retainAll ( final Collection < ? > coll ) { if ( coll instanceof Bag ) {
return false ; } @Override public boolean addAll ( final Collection < ? extends E > coll ) { boolean changed = false ; final Iterator < ? extends E > i = coll . iterator () ; while ( i . hasNext () ) { MST[rv.ROR5Mutator]MSP[]
for ( int index = getCount ( current ) ; index > 0 ; index -- ) { @SuppressWarnings ( lr_1 ) final T unchecked = ( T ) current ; array [ i ++ ] = unchecked ; MST[rv.UOI2Mutator]MSP[] } } while ( i < array . length ) {
array [ i ++ ] = null ; } return array ; } @Override public Set < E > uniqueSet () { if ( uniqueSet == null ) { MST[rv.ROR5Mutator]MSP[] uniqueSet = UnmodifiableSet . <E > unmodifiableSet ( map . keySet () ) ; } return uniqueSet ; }
if ( other . getCount ( element ) != getCount ( element ) ) { MST[rv.ROR2Mutator]MSP[] return false ; } } return true ; } @Override public int hashCode () { int total = 0 ;
buf . append ( count ) ; buf . append ( ':' ) ; buf . append ( current ) ; if ( it . hasNext () ) { MST[NonVoidMethodCallMutator]MSP[] buf . append ( ',' ) ; } } buf . append ( ']' ) ;
final MutableInteger mut = map . get ( object ) ; size += nCopies ; if ( mut == null ) { map . put ( object , new MutableInteger ( nCopies ) ) ; return true ; } mut . value += nCopies ; MST[rv.AOD1Mutator]MSP[] return false ; }
buf . append ( count ) ; buf . append ( ':' ) ; MST[rv.CRCR5Mutator]MSP[] buf . append ( current ) ; if ( it . hasNext () ) { buf . append ( ',' ) ; } } buf . append ( ']' ) ;
final MutableInteger mut = map . get ( object ) ; size += nCopies ; if ( mut == null ) { map . put ( object , new MutableInteger ( nCopies ) ) ; return true ; MST[rv.CRCR2Mutator]MSP[] } mut . value += nCopies ; return false ; }
return false ; } @Override public boolean addAll ( final Collection < ? extends E > coll ) { boolean changed = false ; final Iterator < ? extends E > i = coll . iterator () ; while ( i . hasNext () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
total += ( element == null ? 0 : element . hashCode () ) ^ count . value ; } return total ; } @Override public String toString () { if ( size () == 0 ) { MST[rv.ROR4Mutator]MSP[] return lr_2 ; } final StringBuilder buf = new StringBuilder () ;
final int entrySize = in . readInt () ; for ( int i = 0 ; i < entrySize ; i ++ ) { MST[rv.ROR3Mutator]MSP[] @SuppressWarnings ( lr_1 ) final E obj = ( E ) in . readObject () ; final int count = in . readInt () ;
buf . append ( '[' ) ; MST[rv.CRCR3Mutator]MSP[] final Iterator < E > it = uniqueSet () . iterator () ; while ( it . hasNext () ) { final Object current = it . next () ; final int count = getCount ( current ) ;
final MutableInteger mut = map . get ( object ) ; size += nCopies ; if ( mut == null ) { map . put ( object , new MutableInteger ( nCopies ) ) ; return true ; MST[InlineConstantMutator]MSP[] } mut . value += nCopies ; return false ; }
buf . append ( '[' ) ; final Iterator < E > it = uniqueSet () . iterator () ; while ( it . hasNext () ) { MST[rv.ROR3Mutator]MSP[] final Object current = it . next () ; final int count = getCount ( current ) ;
return false ; } @Override public boolean addAll ( final Collection < ? extends E > coll ) { boolean changed = false ; final Iterator < ? extends E > i = coll . iterator () ; while ( i . hasNext () ) { MST[NonVoidMethodCallMutator]MSP[]
for ( int index = getCount ( current ) ; index > 0 ; index -- ) { MST[rv.UOI4Mutator]MSP[] @SuppressWarnings ( lr_1 ) final T unchecked = ( T ) current ; array [ i ++ ] = unchecked ; } } while ( i < array . length ) {
buf . append ( count ) ; MST[NonVoidMethodCallMutator]MSP[] buf . append ( ':' ) ; buf . append ( current ) ; if ( it . hasNext () ) { buf . append ( ',' ) ; } } buf . append ( ']' ) ;
modCount ++ ; if ( nCopies < mut . value ) { mut . value -= nCopies ; size -= nCopies ; } else { map . remove ( object ) ; size -= mut . value ; MST[rv.UOI1Mutator]MSP[] } return true ; } @Override
modCount ++ ; if ( nCopies < mut . value ) { mut . value -= nCopies ; size -= nCopies ; } else { map . remove ( object ) ; MST[ArgumentPropagationMutator]MSP[] size -= mut . value ; } return true ; } @Override
total += ( element == null ? 0 : element . hashCode () ) ^ count . value ; } return total ; MST[rv.UOI4Mutator]MSP[] } @Override public String toString () { if ( size () == 0 ) { return lr_2 ; } final StringBuilder buf = new StringBuilder () ;
total += ( element == null ? 0 : element . hashCode () ) ^ count . value ; } return total ; } @Override public String toString () { if ( size () == 0 ) { return lr_2 ; } final StringBuilder buf = new StringBuilder () ; MST[ConstructorCallMutator]MSP[]
return false ; } @Override public boolean addAll ( final Collection < ? extends E > coll ) { boolean changed = false ; final Iterator < ? extends E > i = coll . iterator () ; while ( i . hasNext () ) { MST[NegateConditionalsMutator]MSP[]
final boolean added = add ( i . next () ) ; changed = changed || added ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] } return changed ; } @Override public void clear () { modCount ++ ; map . clear () ; size = 0 ; } @Override
for ( int index = getCount ( current ) ; index > 0 ; index -- ) { @SuppressWarnings ( lr_1 ) final T unchecked = ( T ) current ; array [ i ++ ] = unchecked ; } } while ( i < array . length ) { MST[rv.UOI2Mutator]MSP[]
modCount ++ ; if ( nCopies < mut . value ) { mut . value -= nCopies ; size -= nCopies ; } else { map . remove ( object ) ; size -= mut . value ; MST[rv.AOD2Mutator]MSP[] } return true ; } @Override
modCount ++ ; if ( nCopies < mut . value ) { mut . value -= nCopies ; size -= nCopies ; } else { map . remove ( object ) ; size -= mut . value ; } return true ; MST[InlineConstantMutator]MSP[] } @Override
map . put ( obj , new MutableInteger ( count ) ) ; size += count ; } } @Override public boolean equals ( final Object object ) { if ( object == this ) { return true ; } if ( object instanceof Bag == false ) { MST[rv.ROR4Mutator]MSP[]
return false ; } @Override public boolean addAll ( final Collection < ? extends E > coll ) { boolean changed = false ; MST[rv.CRCR5Mutator]MSP[] final Iterator < ? extends E > i = coll . iterator () ; while ( i . hasNext () ) {
array [ i ++ ] = null ; } return array ; } @Override public Set < E > uniqueSet () { if ( uniqueSet == null ) { MST[NegateConditionalsMutator]MSP[] uniqueSet = UnmodifiableSet . <E > unmodifiableSet ( map . keySet () ) ; } return uniqueSet ; }
buf . append ( count ) ; MST[rv.UOI1Mutator]MSP[] buf . append ( ':' ) ; buf . append ( current ) ; if ( it . hasNext () ) { buf . append ( ',' ) ; } } buf . append ( ']' ) ;
protected Map < E , MutableInteger > getMap () { return map ; } @Override public int size () { return size ; MST[rv.UOI2Mutator]MSP[] } @Override public boolean isEmpty () { return map . isEmpty () ; } @Override public int getCount ( final Object object ) {
return buf . toString () ; MST[ReturnValsMutator]MSP[] }
final int size = size () ; if ( array . length < size ) { @SuppressWarnings ( lr_1 ) final T [] unchecked = ( T [] ) Array . newInstance ( array . getClass () . getComponentType () , size ) ; MST[rv.UOI2Mutator]MSP[] array = unchecked ; }
canRemove = false ; } @Override public boolean add ( final E object ) { return add ( object , 1 ) ; } @Override public boolean add ( final E object , final int nCopies ) { modCount ++ ; MST[rv.CRCR5Mutator]MSP[] if ( nCopies > 0 ) {
buf . append ( count ) ; buf . append ( ':' ) ; buf . append ( current ) ; if ( it . hasNext () ) { buf . append ( ',' ) ; MST[rv.CRCR5Mutator]MSP[] } } buf . append ( ']' ) ;
buf . append ( '[' ) ; MST[rv.CRCR4Mutator]MSP[] final Iterator < E > it = uniqueSet () . iterator () ; while ( it . hasNext () ) { final Object current = it . next () ; final int count = getCount ( current ) ;
total += ( element == null ? 0 : element . hashCode () ) ^ count . value ; } return total ; } @Override public String toString () { if ( size () == 0 ) { return lr_2 ; MST[ReturnValsMutator]MSP[] } final StringBuilder buf = new StringBuilder () ;
canRemove = false ; } @Override public boolean add ( final E object ) { return add ( object , 1 ) ; } @Override public boolean add ( final E object , final int nCopies ) { modCount ++ ; if ( nCopies > 0 ) { MST[rv.ROR3Mutator]MSP[]
modCount ++ ; MST[rv.UOI3Mutator]MSP[] if ( nCopies < mut . value ) { mut . value -= nCopies ; size -= nCopies ; } else { map . remove ( object ) ; size -= mut . value ; } return true ; } @Override
for ( int index = getCount ( current ) ; index > 0 ; index -- ) { MST[rv.ROR2Mutator]MSP[] @SuppressWarnings ( lr_1 ) final T unchecked = ( T ) current ; array [ i ++ ] = unchecked ; } } while ( i < array . length ) {
protected void doWriteObject ( final ObjectOutputStream out ) throws IOException { out . writeInt ( map . size () ) ; for ( final Entry < E , MutableInteger > entry : map . entrySet () ) { out . writeObject ( entry . getKey () ) ; MST[NonVoidMethodCallMutator]MSP[]
if ( other . getCount ( element ) != getCount ( element ) ) { MST[rv.ROR3Mutator]MSP[] return false ; } } return true ; } @Override public int hashCode () { int total = 0 ;
if ( other . getCount ( element ) != getCount ( element ) ) { return false ; } } return true ; } @Override public int hashCode () { int total = 0 ; MST[rv.CRCR3Mutator]MSP[]
final int entrySize = in . readInt () ; for ( int i = 0 ; i < entrySize ; i ++ ) { MST[rv.UOI1Mutator]MSP[] @SuppressWarnings ( lr_1 ) final E obj = ( E ) in . readObject () ; final int count = in . readInt () ;
total += ( element == null ? 0 : element . hashCode () ) ^ count . value ; } return total ; } @Override public String toString () { if ( size () == 0 ) { MST[rv.ROR5Mutator]MSP[] return lr_2 ; } final StringBuilder buf = new StringBuilder () ;
modCount ++ ; if ( nCopies < mut . value ) { mut . value -= nCopies ; MST[rv.UOI2Mutator]MSP[] size -= nCopies ; } else { map . remove ( object ) ; size -= mut . value ; } return true ; } @Override
map . put ( obj , new MutableInteger ( count ) ) ; size += count ; MST[rv.AOD2Mutator]MSP[] } } @Override public boolean equals ( final Object object ) { if ( object == this ) { return true ; } if ( object instanceof Bag == false ) {
final MutableInteger count = map . get ( object ) ; if ( count != null ) { return count . value ; } return 0 ; MST[rv.CRCR6Mutator]MSP[] } @Override public boolean contains ( final Object object ) { return map . containsKey ( object ) ; } @Override
final boolean added = add ( i . next () ) ; changed = changed || added ; } return changed ; MST[rv.UOI1Mutator]MSP[] } @Override public void clear () { modCount ++ ; map . clear () ; size = 0 ; } @Override
protected Map < E , MutableInteger > getMap () { return map ; } @Override public int size () { return size ; } @Override public boolean isEmpty () { return map . isEmpty () ; MST[ReturnValsMutator]MSP[] } @Override public int getCount ( final Object object ) {
final boolean added = add ( i . next () ) ; changed = changed || added ; } return changed ; } @Override public void clear () { modCount ++ ; map . clear () ; MST[VoidMethodCallMutator]MSP[] size = 0 ; } @Override
return false ; } final Bag < ? > other = ( Bag < ? > ) object ; if ( other . size () != size () ) { MST[rv.ROR4Mutator]MSP[] return false ; } for ( final E element : map . keySet () ) {
final boolean added = add ( i . next () ) ; changed = changed || added ; MST[rv.ROR3Mutator]MSP[] } return changed ; } @Override public void clear () { modCount ++ ; map . clear () ; size = 0 ; } @Override
for ( int index = getCount ( current ) ; index > 0 ; index -- ) { @SuppressWarnings ( lr_1 ) final T unchecked = ( T ) current ; array [ i ++ ] = unchecked ; } } while ( i < array . length ) { MST[rv.ROR5Mutator]MSP[]
final boolean changed = remove ( i . next () , 1 ) ; result = result || changed ; } } return result ; } @Override public boolean retainAll ( final Collection < ? > coll ) { if ( coll instanceof Bag ) { MST[NegateConditionalsMutator]MSP[]
final MutableInteger mut = map . get ( object ) ; size += nCopies ; if ( mut == null ) { MST[NegateConditionalsMutator]MSP[] map . put ( object , new MutableInteger ( nCopies ) ) ; return true ; } mut . value += nCopies ; return false ; }
final Object [] result = new Object [ size () ] ; int i = 0 ; final Iterator < E > it = map . keySet () . iterator () ; MST[NonVoidMethodCallMutator]MSP[] while ( it . hasNext () ) { final E current = it . next () ;
if ( other . getCount ( element ) != getCount ( element ) ) { return false ; } } return true ; MST[rv.CRCR6Mutator]MSP[] } @Override public int hashCode () { int total = 0 ;
return false ; MST[rv.CRCR3Mutator]MSP[] } @Override public boolean addAll ( final Collection < ? extends E > coll ) { boolean changed = false ; final Iterator < ? extends E > i = coll . iterator () ; while ( i . hasNext () ) {
final boolean added = add ( i . next () ) ; changed = changed || added ; MST[rv.CRCR3Mutator]MSP[] } return changed ; } @Override public void clear () { modCount ++ ; map . clear () ; size = 0 ; } @Override
for ( int index = getCount ( current ) ; index > 0 ; index -- ) { MST[rv.UOI4Mutator]MSP[] result [ i ++ ] = current ; } } return result ; } @Override public < T > T [] toArray ( T [] array ) {
buf . append ( count ) ; buf . append ( ':' ) ; buf . append ( current ) ; if ( it . hasNext () ) { buf . append ( ',' ) ; } } buf . append ( ']' ) ; MST[InlineConstantMutator]MSP[]
modCount ++ ; if ( nCopies < mut . value ) { mut . value -= nCopies ; size -= nCopies ; MST[rv.AOD1Mutator]MSP[] } else { map . remove ( object ) ; size -= mut . value ; } return true ; } @Override
final int size = size () ; if ( array . length < size ) { MST[rv.UOI3Mutator]MSP[] @SuppressWarnings ( lr_1 ) final T [] unchecked = ( T [] ) Array . newInstance ( array . getClass () . getComponentType () , size ) ; array = unchecked ; }
canRemove = false ; } @Override public boolean add ( final E object ) { return add ( object , 1 ) ; } @Override public boolean add ( final E object , final int nCopies ) { modCount ++ ; MST[experimental.MemberVariableMutator]MSP[] if ( nCopies > 0 ) {
final MutableInteger mut = map . get ( object ) ; size += nCopies ; MST[rv.UOI2Mutator]MSP[] if ( mut == null ) { map . put ( object , new MutableInteger ( nCopies ) ) ; return true ; } mut . value += nCopies ; return false ; }
int i = 0 ; final Iterator < E > it = map . keySet () . iterator () ; while ( it . hasNext () ) { MST[rv.ROR4Mutator]MSP[] final E current = it . next () ;
canRemove = false ; } @Override public boolean add ( final E object ) { return add ( object , 1 ) ; } @Override public boolean add ( final E object , final int nCopies ) { modCount ++ ; if ( nCopies > 0 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[]
modCount ++ ; if ( nCopies < mut . value ) { mut . value -= nCopies ; MST[rv.UOI4Mutator]MSP[] size -= nCopies ; } else { map . remove ( object ) ; size -= mut . value ; } return true ; } @Override
modCount ++ ; if ( nCopies < mut . value ) { mut . value -= nCopies ; size -= nCopies ; MST[rv.ABSMutator]MSP[] } else { map . remove ( object ) ; size -= mut . value ; } return true ; } @Override
canRemove = false ; } @Override public boolean add ( final E object ) { return add ( object , 1 ) ; } @Override public boolean add ( final E object , final int nCopies ) { modCount ++ ; MST[rv.UOI1Mutator]MSP[] if ( nCopies > 0 ) {
final boolean changed = remove ( i . next () , 1 ) ; result = result || changed ; } } return result ; } @Override public boolean retainAll ( final Collection < ? > coll ) { if ( coll instanceof Bag ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
canRemove = false ; } @Override public boolean add ( final E object ) { return add ( object , 1 ) ; } @Override public boolean add ( final E object , final int nCopies ) { modCount ++ ; MST[rv.AOR2Mutator]MSP[] if ( nCopies > 0 ) {
final boolean added = add ( i . next () ) ; changed = changed || added ; } return changed ; } @Override public void clear () { modCount ++ ; MST[rv.UOI4Mutator]MSP[] map . clear () ; size = 0 ; } @Override
final MutableInteger mut = map . get ( object ) ; size += nCopies ; if ( mut == null ) { map . put ( object , new MutableInteger ( nCopies ) ) ; return true ; } mut . value += nCopies ; return false ; MST[InlineConstantMutator]MSP[] }
buf . append ( '[' ) ; final Iterator < E > it = uniqueSet () . iterator () ; while ( it . hasNext () ) { MST[rv.ROR4Mutator]MSP[] final Object current = it . next () ; final int count = getCount ( current ) ;
final MutableInteger mut = map . get ( object ) ; size += nCopies ; if ( mut == null ) { map . put ( object , new MutableInteger ( nCopies ) ) ; return true ; } mut . value += nCopies ; MST[rv.UOI1Mutator]MSP[] return false ; }
modCount ++ ; if ( nCopies < mut . value ) { mut . value -= nCopies ; size -= nCopies ; } else { map . remove ( object ) ; size -= mut . value ; MST[rv.UOI2Mutator]MSP[] } return true ; } @Override
for ( int index = getCount ( current ) ; index > 0 ; index -- ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[] @SuppressWarnings ( lr_1 ) final T unchecked = ( T ) current ; array [ i ++ ] = unchecked ; } } while ( i < array . length ) {
for ( int index = getCount ( current ) ; index > 0 ; index -- ) { @SuppressWarnings ( lr_1 ) final T unchecked = ( T ) current ; array [ i ++ ] = unchecked ; } } while ( i < array . length ) { MST[rv.ROR2Mutator]MSP[]
for ( int index = getCount ( current ) ; index > 0 ; index -- ) { MST[IncrementsMutator]MSP[] result [ i ++ ] = current ; } } return result ; } @Override public < T > T [] toArray ( T [] array ) {
final int size = size () ; if ( array . length < size ) { MST[rv.ROR4Mutator]MSP[] @SuppressWarnings ( lr_1 ) final T [] unchecked = ( T [] ) Array . newInstance ( array . getClass () . getComponentType () , size ) ; array = unchecked ; }
if ( other . getCount ( element ) != getCount ( element ) ) { return false ; } } return true ; MST[rv.CRCR5Mutator]MSP[] } @Override public int hashCode () { int total = 0 ;
protected void doWriteObject ( final ObjectOutputStream out ) throws IOException { out . writeInt ( map . size () ) ; MST[VoidMethodCallMutator]MSP[] for ( final Entry < E , MutableInteger > entry : map . entrySet () ) { out . writeObject ( entry . getKey () ) ;
final int entrySize = in . readInt () ; for ( int i = 0 ; i < entrySize ; i ++ ) { MST[rv.CRCR6Mutator]MSP[] @SuppressWarnings ( lr_1 ) final E obj = ( E ) in . readObject () ; final int count = in . readInt () ;
array [ i ++ ] = null ; } return array ; MST[NullReturnValsMutator]MSP[] } @Override public Set < E > uniqueSet () { if ( uniqueSet == null ) { uniqueSet = UnmodifiableSet . <E > unmodifiableSet ( map . keySet () ) ; } return uniqueSet ; }
total += ( element == null ? 0 : element . hashCode () ) ^ count . value ; } return total ; } @Override public String toString () { if ( size () == 0 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return lr_2 ; } final StringBuilder buf = new StringBuilder () ;
final boolean changed = remove ( i . next () , 1 ) ; result = result || changed ; } } return result ; } @Override public boolean retainAll ( final Collection < ? > coll ) { if ( coll instanceof Bag ) { MST[rv.ROR5Mutator]MSP[]
final boolean added = add ( i . next () ) ; changed = changed || added ; MST[NegateConditionalsMutator]MSP[] } return changed ; } @Override public void clear () { modCount ++ ; map . clear () ; size = 0 ; } @Override
final int entrySize = in . readInt () ; for ( int i = 0 ; i < entrySize ; i ++ ) { MST[rv.UOI3Mutator]MSP[] @SuppressWarnings ( lr_1 ) final E obj = ( E ) in . readObject () ; final int count = in . readInt () ;
final boolean added = add ( i . next () ) ; changed = changed || added ; } return changed ; MST[ReturnValsMutator]MSP[] } @Override public void clear () { modCount ++ ; map . clear () ; size = 0 ; } @Override
for ( int index = getCount ( current ) ; index > 0 ; index -- ) { MST[rv.ROR4Mutator]MSP[] @SuppressWarnings ( lr_1 ) final T unchecked = ( T ) current ; array [ i ++ ] = unchecked ; } } while ( i < array . length ) {
final MutableInteger mut = map . get ( object ) ; size += nCopies ; if ( mut == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] map . put ( object , new MutableInteger ( nCopies ) ) ; return true ; } mut . value += nCopies ; return false ; }
buf . append ( count ) ; buf . append ( ':' ) ; MST[rv.CRCR4Mutator]MSP[] buf . append ( current ) ; if ( it . hasNext () ) { buf . append ( ',' ) ; } } buf . append ( ']' ) ;
final MutableInteger mut = map . get ( object ) ; size += nCopies ; if ( mut == null ) { map . put ( object , new MutableInteger ( nCopies ) ) ; return true ; MST[rv.CRCR3Mutator]MSP[] } mut . value += nCopies ; return false ; }
total += ( element == null ? 0 : element . hashCode () ) ^ count . value ; } return total ; MST[ReturnValsMutator]MSP[] } @Override public String toString () { if ( size () == 0 ) { return lr_2 ; } final StringBuilder buf = new StringBuilder () ;
final boolean added = add ( i . next () ) ; changed = changed || added ; MST[rv.UOI4Mutator]MSP[] } return changed ; } @Override public void clear () { modCount ++ ; map . clear () ; size = 0 ; } @Override
final int entrySize = in . readInt () ; for ( int i = 0 ; i < entrySize ; i ++ ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] @SuppressWarnings ( lr_1 ) final E obj = ( E ) in . readObject () ; final int count = in . readInt () ;
final MutableInteger count = map . get ( object ) ; if ( count != null ) { return count . value ; } return 0 ; MST[rv.CRCR1Mutator]MSP[] } @Override public boolean contains ( final Object object ) { return map . containsKey ( object ) ; } @Override
modCount ++ ; if ( nCopies < mut . value ) { mut . value -= nCopies ; size -= nCopies ; MST[rv.AOR3Mutator]MSP[] } else { map . remove ( object ) ; size -= mut . value ; } return true ; } @Override
final MutableInteger count = map . get ( object ) ; if ( count != null ) { return count . value ; } return 0 ; MST[rv.CRCR5Mutator]MSP[] } @Override public boolean contains ( final Object object ) { return map . containsKey ( object ) ; } @Override
map . put ( obj , new MutableInteger ( count ) ) ; size += count ; MST[rv.AOD1Mutator]MSP[] } } @Override public boolean equals ( final Object object ) { if ( object == this ) { return true ; } if ( object instanceof Bag == false ) {
final boolean added = add ( i . next () ) ; changed = changed || added ; MST[rv.CRCR5Mutator]MSP[] } return changed ; } @Override public void clear () { modCount ++ ; map . clear () ; size = 0 ; } @Override
modCount ++ ; if ( nCopies < mut . value ) { MST[rv.ABSMutator]MSP[] mut . value -= nCopies ; size -= nCopies ; } else { map . remove ( object ) ; size -= mut . value ; } return true ; } @Override
map . put ( obj , new MutableInteger ( count ) ) ; size += count ; } } @Override public boolean equals ( final Object object ) { if ( object == this ) { return true ; MST[ReturnValsMutator]MSP[] } if ( object instanceof Bag == false ) {
final boolean added = add ( i . next () ) ; changed = changed || added ; MST[rv.ROR5Mutator]MSP[] } return changed ; } @Override public void clear () { modCount ++ ; map . clear () ; size = 0 ; } @Override
for ( int index = getCount ( current ) ; index > 0 ; index -- ) { MST[rv.UOI2Mutator]MSP[] result [ i ++ ] = current ; } } return result ; } @Override public < T > T [] toArray ( T [] array ) {
buf . append ( count ) ; buf . append ( ':' ) ; buf . append ( current ) ; if ( it . hasNext () ) { buf . append ( ',' ) ; MST[rv.CRCR4Mutator]MSP[] } } buf . append ( ']' ) ;
final MutableInteger mut = map . get ( object ) ; size += nCopies ; MST[rv.AOR3Mutator]MSP[] if ( mut == null ) { map . put ( object , new MutableInteger ( nCopies ) ) ; return true ; } mut . value += nCopies ; return false ; }
for ( int index = getCount ( current ) ; index > 0 ; index -- ) { MST[rv.ROR3Mutator]MSP[] result [ i ++ ] = current ; } } return result ; } @Override public < T > T [] toArray ( T [] array ) {
public boolean removeAll ( final Collection < ? > coll ) { boolean result = false ; MST[rv.CRCR1Mutator]MSP[] if ( coll != null ) { final Iterator < ? > i = coll . iterator () ; while ( i . hasNext () ) {
return false ; } @Override public boolean addAll ( final Collection < ? extends E > coll ) { boolean changed = false ; final Iterator < ? extends E > i = coll . iterator () ; while ( i . hasNext () ) { MST[rv.ROR2Mutator]MSP[]
return false ; } final Bag < ? > other = ( Bag < ? > ) object ; if ( other . size () != size () ) { MST[NonVoidMethodCallMutator]MSP[] return false ; } for ( final E element : map . keySet () ) {
} @Override public boolean remove ( final Object object , final int nCopies ) { final MutableInteger mut = map . get ( object ) ; if ( mut == null ) { return false ; } if ( nCopies <= 0 ) { MST[rv.UOI1Mutator]MSP[] return false ; }
canRemove = false ; } @Override public boolean add ( final E object ) { return add ( object , 1 ) ; } @Override public boolean add ( final E object , final int nCopies ) { modCount ++ ; MST[rv.CRCR6Mutator]MSP[] if ( nCopies > 0 ) {
map . put ( obj , new MutableInteger ( count ) ) ; size += count ; MST[rv.AOR3Mutator]MSP[] } } @Override public boolean equals ( final Object object ) { if ( object == this ) { return true ; } if ( object instanceof Bag == false ) {
final MutableInteger count = map . get ( object ) ; MST[ArgumentPropagationMutator]MSP[] if ( count != null ) { return count . value ; } return 0 ; } @Override public boolean contains ( final Object object ) { return map . containsKey ( object ) ; } @Override
final Object [] result = new Object [ size () ] ; int i = 0 ; MST[rv.CRCR3Mutator]MSP[] final Iterator < E > it = map . keySet () . iterator () ; while ( it . hasNext () ) { final E current = it . next () ;
for ( int index = getCount ( current ) ; index > 0 ; index -- ) { MST[ConditionalsBoundaryMutator]MSP[] result [ i ++ ] = current ; } } return result ; } @Override public < T > T [] toArray ( T [] array ) {
map . put ( obj , new MutableInteger ( count ) ) ; MST[rv.UOI3Mutator]MSP[] size += count ; } } @Override public boolean equals ( final Object object ) { if ( object == this ) { return true ; } if ( object instanceof Bag == false ) {
map . put ( obj , new MutableInteger ( count ) ) ; size += count ; } } @Override public boolean equals ( final Object object ) { if ( object == this ) { return true ; } if ( object instanceof Bag == false ) { MST[rv.ROR3Mutator]MSP[]
for ( int index = getCount ( current ) ; index > 0 ; index -- ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] result [ i ++ ] = current ; } } return result ; } @Override public < T > T [] toArray ( T [] array ) {
array [ i ++ ] = null ; } return array ; } @Override public Set < E > uniqueSet () { if ( uniqueSet == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] uniqueSet = UnmodifiableSet . <E > unmodifiableSet ( map . keySet () ) ; } return uniqueSet ; }
buf . append ( '[' ) ; final Iterator < E > it = uniqueSet () . iterator () ; while ( it . hasNext () ) { MST[NonVoidMethodCallMutator]MSP[] final Object current = it . next () ; final int count = getCount ( current ) ;
return false ; MST[BooleanTrueReturnValsMutator]MSP[] } final Bag < ? > other = ( Bag < ? > ) object ; if ( other . size () != size () ) { return false ; } for ( final E element : map . keySet () ) {
return false ; } final Bag < ? > other = ( Bag < ? > ) object ; if ( other . size () != size () ) { MST[rv.ROR3Mutator]MSP[] return false ; } for ( final E element : map . keySet () ) {
final boolean added = add ( i . next () ) ; changed = changed || added ; MST[rv.ROR2Mutator]MSP[] } return changed ; } @Override public void clear () { modCount ++ ; map . clear () ; size = 0 ; } @Override
return false ; } @Override public boolean addAll ( final Collection < ? extends E > coll ) { boolean changed = false ; final Iterator < ? extends E > i = coll . iterator () ; while ( i . hasNext () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
final MutableInteger mut = map . get ( object ) ; size += nCopies ; MST[rv.AOD1Mutator]MSP[] if ( mut == null ) { map . put ( object , new MutableInteger ( nCopies ) ) ; return true ; } mut . value += nCopies ; return false ; }
return false ; MST[rv.CRCR3Mutator]MSP[] } final Bag < ? > other = ( Bag < ? > ) object ; if ( other . size () != size () ) { return false ; } for ( final E element : map . keySet () ) {
final MutableInteger mut = map . get ( object ) ; MST[ArgumentPropagationMutator]MSP[] size += nCopies ; if ( mut == null ) { map . put ( object , new MutableInteger ( nCopies ) ) ; return true ; } mut . value += nCopies ; return false ; }
modCount ++ ; if ( nCopies < mut . value ) { mut . value -= nCopies ; size -= nCopies ; } else { map . remove ( object ) ; size -= mut . value ; MST[rv.UOI2Mutator]MSP[] } return true ; } @Override
for ( int index = getCount ( current ) ; index > 0 ; index -- ) { @SuppressWarnings ( lr_1 ) final T unchecked = ( T ) current ; array [ i ++ ] = unchecked ; } } while ( i < array . length ) { MST[rv.UOI1Mutator]MSP[]
final MutableInteger mut = map . get ( object ) ; size += nCopies ; MST[rv.ABSMutator]MSP[] if ( mut == null ) { map . put ( object , new MutableInteger ( nCopies ) ) ; return true ; } mut . value += nCopies ; return false ; }
for ( int index = getCount ( current ) ; index > 0 ; index -- ) { MST[rv.UOI3Mutator]MSP[] @SuppressWarnings ( lr_1 ) final T unchecked = ( T ) current ; array [ i ++ ] = unchecked ; } } while ( i < array . length ) {
modCount ++ ; MST[rv.AOR2Mutator]MSP[] if ( nCopies < mut . value ) { mut . value -= nCopies ; size -= nCopies ; } else { map . remove ( object ) ; size -= mut . value ; } return true ; } @Override
final boolean added = add ( i . next () ) ; changed = changed || added ; MST[NegateConditionalsMutator]MSP[] } return changed ; } @Override public void clear () { modCount ++ ; map . clear () ; size = 0 ; } @Override
final boolean added = add ( i . next () ) ; changed = changed || added ; MST[rv.CRCR2Mutator]MSP[] } return changed ; } @Override public void clear () { modCount ++ ; map . clear () ; size = 0 ; } @Override
} @Override public boolean remove ( final Object object , final int nCopies ) { final MutableInteger mut = map . get ( object ) ; if ( mut == null ) { return false ; } if ( nCopies <= 0 ) { MST[rv.ABSMutator]MSP[] return false ; }
final MutableInteger mut = map . get ( object ) ; size += nCopies ; if ( mut == null ) { MST[rv.ROR5Mutator]MSP[] map . put ( object , new MutableInteger ( nCopies ) ) ; return true ; } mut . value += nCopies ; return false ; }
final int size = size () ; if ( array . length < size ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[] @SuppressWarnings ( lr_1 ) final T [] unchecked = ( T [] ) Array . newInstance ( array . getClass () . getComponentType () , size ) ; array = unchecked ; }
final MutableInteger mut = map . get ( object ) ; size += nCopies ; if ( mut == null ) { map . put ( object , new MutableInteger ( nCopies ) ) ; return true ; } mut . value += nCopies ; return false ; MST[rv.CRCR3Mutator]MSP[] }
final Object [] result = new Object [ size () ] ; MST[NonVoidMethodCallMutator]MSP[] int i = 0 ; final Iterator < E > it = map . keySet () . iterator () ; while ( it . hasNext () ) { final E current = it . next () ;
for ( int index = getCount ( current ) ; index > 0 ; index -- ) { MST[rv.ABSMutator]MSP[] @SuppressWarnings ( lr_1 ) final T unchecked = ( T ) current ; array [ i ++ ] = unchecked ; } } while ( i < array . length ) {
for ( int index = getCount ( current ) ; index > 0 ; index -- ) { @SuppressWarnings ( lr_1 ) final T unchecked = ( T ) current ; array [ i ++ ] = unchecked ; MST[rv.UOI1Mutator]MSP[] } } while ( i < array . length ) {
final int entrySize = in . readInt () ; for ( int i = 0 ; i < entrySize ; i ++ ) { MST[ConditionalsBoundaryMutator]MSP[] @SuppressWarnings ( lr_1 ) final E obj = ( E ) in . readObject () ; final int count = in . readInt () ;
canRemove = false ; } @Override public boolean add ( final E object ) { return add ( object , 1 ) ; } @Override public boolean add ( final E object , final int nCopies ) { modCount ++ ; if ( nCopies > 0 ) { MST[rv.ROR4Mutator]MSP[]
modCount ++ ; MST[rv.UOI4Mutator]MSP[] if ( nCopies < mut . value ) { mut . value -= nCopies ; size -= nCopies ; } else { map . remove ( object ) ; size -= mut . value ; } return true ; } @Override
for ( int index = getCount ( current ) ; index > 0 ; index -- ) { MST[NonVoidMethodCallMutator]MSP[] @SuppressWarnings ( lr_1 ) final T unchecked = ( T ) current ; array [ i ++ ] = unchecked ; } } while ( i < array . length ) {
modCount ++ ; if ( nCopies < mut . value ) { mut . value -= nCopies ; MST[rv.AOR1Mutator]MSP[] size -= nCopies ; } else { map . remove ( object ) ; size -= mut . value ; } return true ; } @Override
final Object [] result = new Object [ size () ] ; int i = 0 ; final Iterator < E > it = map . keySet () . iterator () ; while ( it . hasNext () ) { MST[rv.ROR3Mutator]MSP[] final E current = it . next () ;
final int entrySize = in . readInt () ; for ( int i = 0 ; i < entrySize ; i ++ ) { MST[rv.ROR5Mutator]MSP[] @SuppressWarnings ( lr_1 ) final E obj = ( E ) in . readObject () ; final int count = in . readInt () ;
final boolean added = add ( i . next () ) ; changed = changed || added ; MST[rv.UOI4Mutator]MSP[] } return changed ; } @Override public void clear () { modCount ++ ; map . clear () ; size = 0 ; } @Override
final Object [] result = new Object [ size () ] ; int i = 0 ; final Iterator < E > it = map . keySet () . iterator () ; while ( it . hasNext () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] final E current = it . next () ;
modCount ++ ; MST[experimental.MemberVariableMutator]MSP[] if ( nCopies < mut . value ) { mut . value -= nCopies ; size -= nCopies ; } else { map . remove ( object ) ; size -= mut . value ; } return true ; } @Override
modCount ++ ; if ( nCopies < mut . value ) { mut . value -= nCopies ; size -= nCopies ; MST[rv.UOI1Mutator]MSP[] } else { map . remove ( object ) ; size -= mut . value ; } return true ; } @Override
map . put ( obj , new MutableInteger ( count ) ) ; size += count ; MST[rv.UOI1Mutator]MSP[] } } @Override public boolean equals ( final Object object ) { if ( object == this ) { return true ; } if ( object instanceof Bag == false ) {
return false ; } final Bag < ? > other = ( Bag < ? > ) object ; if ( other . size () != size () ) { MST[NonVoidMethodCallMutator]MSP[] return false ; } for ( final E element : map . keySet () ) {
modCount ++ ; if ( nCopies < mut . value ) { mut . value -= nCopies ; size -= nCopies ; } else { map . remove ( object ) ; size -= mut . value ; MST[MathMutator]MSP[] } return true ; } @Override
modCount ++ ; if ( nCopies < mut . value ) { MST[rv.ROR4Mutator]MSP[] mut . value -= nCopies ; size -= nCopies ; } else { map . remove ( object ) ; size -= mut . value ; } return true ; } @Override
modCount ++ ; if ( nCopies < mut . value ) { mut . value -= nCopies ; size -= nCopies ; } else { map . remove ( object ) ; size -= mut . value ; MST[rv.AOR4Mutator]MSP[] } return true ; } @Override
for ( int index = getCount ( current ) ; index > 0 ; index -- ) { @SuppressWarnings ( lr_1 ) final T unchecked = ( T ) current ; array [ i ++ ] = unchecked ; MST[IncrementsMutator]MSP[] } } while ( i < array . length ) {
} @Override public boolean remove ( final Object object , final int nCopies ) { final MutableInteger mut = map . get ( object ) ; if ( mut == null ) { return false ; MST[ReturnValsMutator]MSP[] } if ( nCopies <= 0 ) { return false ; }
final boolean added = add ( i . next () ) ; changed = changed || added ; } return changed ; } @Override public void clear () { modCount ++ ; MST[rv.AOR1Mutator]MSP[] map . clear () ; size = 0 ; } @Override
map . put ( obj , new MutableInteger ( count ) ) ; size += count ; MST[rv.ABSMutator]MSP[] } } @Override public boolean equals ( final Object object ) { if ( object == this ) { return true ; } if ( object instanceof Bag == false ) {
final int size = size () ; if ( array . length < size ) { @SuppressWarnings ( lr_1 ) final T [] unchecked = ( T [] ) Array . newInstance ( array . getClass () . getComponentType () , size ) ; MST[rv.UOI1Mutator]MSP[] array = unchecked ; }
final int size = size () ; if ( array . length < size ) { MST[rv.ROR1Mutator]MSP[] @SuppressWarnings ( lr_1 ) final T [] unchecked = ( T [] ) Array . newInstance ( array . getClass () . getComponentType () , size ) ; array = unchecked ; }
canRemove = false ; } @Override public boolean add ( final E object ) { return add ( object , 1 ) ; MST[rv.CRCR2Mutator]MSP[] } @Override public boolean add ( final E object , final int nCopies ) { modCount ++ ; if ( nCopies > 0 ) {
final Object [] result = new Object [ size () ] ; int i = 0 ; final Iterator < E > it = map . keySet () . iterator () ; while ( it . hasNext () ) { MST[NegateConditionalsMutator]MSP[] final E current = it . next () ;
final int entrySize = in . readInt () ; for ( int i = 0 ; i < entrySize ; i ++ ) { MST[rv.UOI4Mutator]MSP[] @SuppressWarnings ( lr_1 ) final E obj = ( E ) in . readObject () ; final int count = in . readInt () ;
modCount ++ ; if ( nCopies < mut . value ) { mut . value -= nCopies ; size -= nCopies ; } else { map . remove ( object ) ; size -= mut . value ; MST[experimental.MemberVariableMutator]MSP[] } return true ; } @Override
final boolean changed = remove ( i . next () , 1 ) ; result = result || changed ; } } return result ; } @Override public boolean retainAll ( final Collection < ? > coll ) { if ( coll instanceof Bag ) { MST[rv.ROR2Mutator]MSP[]
out . writeInt ( entry . getValue () . value ) ; MST[rv.UOI2Mutator]MSP[] } } protected void doReadObject ( final Map < E , MutableInteger > map , final ObjectInputStream in ) throws IOException , ClassNotFoundException { this . map = map ;
final int entrySize = in . readInt () ; for ( int i = 0 ; i < entrySize ; i ++ ) { MST[rv.ABSMutator]MSP[] @SuppressWarnings ( lr_1 ) final E obj = ( E ) in . readObject () ; final int count = in . readInt () ;
map . put ( obj , new MutableInteger ( count ) ) ; size += count ; } } @Override public boolean equals ( final Object object ) { if ( object == this ) { return true ; MST[BooleanFalseReturnValsMutator]MSP[] } if ( object instanceof Bag == false ) {
final MutableInteger count = map . get ( object ) ; if ( count != null ) { return count . value ; } return 0 ; MST[InlineConstantMutator]MSP[] } @Override public boolean contains ( final Object object ) { return map . containsKey ( object ) ; } @Override
modCount ++ ; if ( nCopies < mut . value ) { mut . value -= nCopies ; MST[rv.UOI1Mutator]MSP[] size -= nCopies ; } else { map . remove ( object ) ; size -= mut . value ; } return true ; } @Override
modCount ++ ; if ( nCopies < mut . value ) { mut . value -= nCopies ; size -= nCopies ; MST[rv.UOI3Mutator]MSP[] } else { map . remove ( object ) ; size -= mut . value ; } return true ; } @Override
modCount ++ ; if ( nCopies < mut . value ) { mut . value -= nCopies ; size -= nCopies ; } else { map . remove ( object ) ; size -= mut . value ; } return true ; MST[rv.CRCR5Mutator]MSP[] } @Override
} @Override public boolean remove ( final Object object , final int nCopies ) { final MutableInteger mut = map . get ( object ) ; MST[ArgumentPropagationMutator]MSP[] if ( mut == null ) { return false ; } if ( nCopies <= 0 ) { return false ; }
final MutableInteger mut = map . get ( object ) ; size += nCopies ; if ( mut == null ) { map . put ( object , new MutableInteger ( nCopies ) ) ; return true ; } mut . value += nCopies ; MST[rv.UOI2Mutator]MSP[] return false ; }
final int entrySize = in . readInt () ; for ( int i = 0 ; i < entrySize ; i ++ ) { @SuppressWarnings ( lr_1 ) final E obj = ( E ) in . readObject () ; final int count = in . readInt () ; MST[NonVoidMethodCallMutator]MSP[]
buf . append ( '[' ) ; final Iterator < E > it = uniqueSet () . iterator () ; MST[NonVoidMethodCallMutator]MSP[] while ( it . hasNext () ) { final Object current = it . next () ; final int count = getCount ( current ) ;
final boolean added = add ( i . next () ) ; changed = changed || added ; } return changed ; MST[BooleanFalseReturnValsMutator]MSP[] } @Override public void clear () { modCount ++ ; map . clear () ; size = 0 ; } @Override
} @Override public boolean remove ( final Object object , final int nCopies ) { final MutableInteger mut = map . get ( object ) ; if ( mut == null ) { return false ; } if ( nCopies <= 0 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[] return false ; }
final int size = size () ; if ( array . length < size ) { MST[rv.ABSMutator]MSP[] @SuppressWarnings ( lr_1 ) final T [] unchecked = ( T [] ) Array . newInstance ( array . getClass () . getComponentType () , size ) ; array = unchecked ; }
final boolean changed = remove ( i . next () , 1 ) ; result = result || changed ; } } return result ; MST[rv.UOI3Mutator]MSP[] } @Override public boolean retainAll ( final Collection < ? > coll ) { if ( coll instanceof Bag ) {
canRemove = false ; } @Override public boolean add ( final E object ) { return add ( object , 1 ) ; } @Override public boolean add ( final E object , final int nCopies ) { modCount ++ ; MST[InlineConstantMutator]MSP[] if ( nCopies > 0 ) {
return false ; } final Bag < ? > other = ( Bag < ? > ) object ; if ( other . size () != size () ) { return false ; } for ( final E element : map . keySet () ) { MST[NonVoidMethodCallMutator]MSP[]
final Object [] result = new Object [ size () ] ; int i = 0 ; MST[InlineConstantMutator]MSP[] final Iterator < E > it = map . keySet () . iterator () ; while ( it . hasNext () ) { final E current = it . next () ;
protected Map < E , MutableInteger > getMap () { return map ; MST[ReturnValsMutator]MSP[] } @Override public int size () { return size ; } @Override public boolean isEmpty () { return map . isEmpty () ; } @Override public int getCount ( final Object object ) {
for ( int index = getCount ( current ) ; index > 0 ; index -- ) { @SuppressWarnings ( lr_1 ) final T unchecked = ( T ) current ; array [ i ++ ] = unchecked ; MST[rv.UOI4Mutator]MSP[] } } while ( i < array . length ) {
buf . append ( count ) ; buf . append ( ':' ) ; buf . append ( current ) ; if ( it . hasNext () ) { MST[rv.ROR1Mutator]MSP[] buf . append ( ',' ) ; } } buf . append ( ']' ) ;
canRemove = false ; } @Override public boolean add ( final E object ) { return add ( object , 1 ) ; } @Override public boolean add ( final E object , final int nCopies ) { modCount ++ ; if ( nCopies > 0 ) { MST[rv.ABSMutator]MSP[]
canRemove = false ; } @Override public boolean add ( final E object ) { return add ( object , 1 ) ; } @Override public boolean add ( final E object , final int nCopies ) { modCount ++ ; if ( nCopies > 0 ) { MST[rv.ROR1Mutator]MSP[]
final Object [] result = new Object [ size () ] ; int i = 0 ; final Iterator < E > it = map . keySet () . iterator () ; while ( it . hasNext () ) { MST[rv.ROR5Mutator]MSP[] final E current = it . next () ;
final int size = size () ; if ( array . length < size ) { @SuppressWarnings ( lr_1 ) final T [] unchecked = ( T [] ) Array . newInstance ( array . getClass () . getComponentType () , size ) ; MST[rv.UOI4Mutator]MSP[] array = unchecked ; }
if ( other . getCount ( element ) != getCount ( element ) ) { return false ; } } return true ; } @Override public int hashCode () { int total = 0 ; MST[rv.CRCR1Mutator]MSP[]
return false ; MST[BooleanTrueReturnValsMutator]MSP[] } @Override public boolean addAll ( final Collection < ? extends E > coll ) { boolean changed = false ; final Iterator < ? extends E > i = coll . iterator () ; while ( i . hasNext () ) {
modCount ++ ; if ( nCopies < mut . value ) { MST[rv.UOI3Mutator]MSP[] mut . value -= nCopies ; size -= nCopies ; } else { map . remove ( object ) ; size -= mut . value ; } return true ; } @Override
return false ; MST[rv.CRCR6Mutator]MSP[] } final Bag < ? > other = ( Bag < ? > ) object ; if ( other . size () != size () ) { return false ; } for ( final E element : map . keySet () ) {
modCount ++ ; if ( nCopies < mut . value ) { mut . value -= nCopies ; size -= nCopies ; } else { map . remove ( object ) ; size -= mut . value ; MST[rv.AOR2Mutator]MSP[] } return true ; } @Override
map . put ( obj , new MutableInteger ( count ) ) ; size += count ; MST[rv.UOI3Mutator]MSP[] } } @Override public boolean equals ( final Object object ) { if ( object == this ) { return true ; } if ( object instanceof Bag == false ) {
if ( getCount ( current ) < other . getCount ( current ) ) { return false ; } } return true ; } @Override public Iterator < E > iterator () { return new BagIterator <> ( this ) ; MST[NullReturnValsMutator]MSP[] } @Override public boolean hasNext () {
canRemove = false ; } @Override public boolean add ( final E object ) { return add ( object , 1 ) ; MST[rv.CRCR4Mutator]MSP[] } @Override public boolean add ( final E object , final int nCopies ) { modCount ++ ; if ( nCopies > 0 ) {
return false ; MST[rv.CRCR1Mutator]MSP[] } @Override public boolean addAll ( final Collection < ? extends E > coll ) { boolean changed = false ; final Iterator < ? extends E > i = coll . iterator () ; while ( i . hasNext () ) {
modCount ++ ; MST[rv.UOI1Mutator]MSP[] if ( nCopies < mut . value ) { mut . value -= nCopies ; size -= nCopies ; } else { map . remove ( object ) ; size -= mut . value ; } return true ; } @Override
map . put ( obj , new MutableInteger ( count ) ) ; size += count ; } } @Override public boolean equals ( final Object object ) { if ( object == this ) { return true ; MST[rv.CRCR4Mutator]MSP[] } if ( object instanceof Bag == false ) {
if ( other . getCount ( element ) != getCount ( element ) ) { MST[NonVoidMethodCallMutator]MSP[] return false ; } } return true ; } @Override public int hashCode () { int total = 0 ;
canRemove = false ; } @Override public boolean add ( final E object ) { return add ( object , 1 ) ; } @Override public boolean add ( final E object , final int nCopies ) { modCount ++ ; if ( nCopies > 0 ) { MST[rv.UOI3Mutator]MSP[]
int i = 0 ; final Iterator < E > it = map . keySet () . iterator () ; while ( it . hasNext () ) { MST[NonVoidMethodCallMutator]MSP[] final E current = it . next () ;
for ( int index = getCount ( current ) ; index > 0 ; index -- ) { @SuppressWarnings ( lr_1 ) final T unchecked = ( T ) current ; array [ i ++ ] = unchecked ; } } while ( i < array . length ) { MST[rv.UOI4Mutator]MSP[]
map . put ( obj , new MutableInteger ( count ) ) ; size += count ; } } @Override public boolean equals ( final Object object ) { if ( object == this ) { return true ; } if ( object instanceof Bag == false ) { MST[rv.ROR1Mutator]MSP[]
array [ i ++ ] = null ; } return array ; } @Override public Set < E > uniqueSet () { if ( uniqueSet == null ) { uniqueSet = UnmodifiableSet . <E > unmodifiableSet ( map . keySet () ) ; } return uniqueSet ; MST[ReturnValsMutator]MSP[] }
} @Override public boolean remove ( final Object object , final int nCopies ) { final MutableInteger mut = map . get ( object ) ; if ( mut == null ) { return false ; MST[rv.CRCR1Mutator]MSP[] } if ( nCopies <= 0 ) { return false ; }
return false ; } final Bag < ? > other = ( Bag < ? > ) object ; if ( other . size () != size () ) { MST[rv.ROR1Mutator]MSP[] return false ; } for ( final E element : map . keySet () ) {
map . put ( obj , new MutableInteger ( count ) ) ; MST[ConstructorCallMutator]MSP[] size += count ; } } @Override public boolean equals ( final Object object ) { if ( object == this ) { return true ; } if ( object instanceof Bag == false ) {
return false ; MST[rv.CRCR1Mutator]MSP[] } final Bag < ? > other = ( Bag < ? > ) object ; if ( other . size () != size () ) { return false ; } for ( final E element : map . keySet () ) {
return false ; MST[ReturnValsMutator]MSP[] } @Override public boolean addAll ( final Collection < ? extends E > coll ) { boolean changed = false ; final Iterator < ? extends E > i = coll . iterator () ; while ( i . hasNext () ) {
canRemove = false ; } @Override public boolean add ( final E object ) { return add ( object , 1 ) ; } @Override public boolean add ( final E object , final int nCopies ) { modCount ++ ; MST[rv.CRCR3Mutator]MSP[] if ( nCopies > 0 ) {
array [ i ++ ] = null ; } return array ; } @Override public Set < E > uniqueSet () { if ( uniqueSet == null ) { uniqueSet = UnmodifiableSet . <E > unmodifiableSet ( map . keySet () ) ; MST[NonVoidMethodCallMutator]MSP[] } return uniqueSet ; }
for ( int index = getCount ( current ) ; index > 0 ; index -- ) { MST[NegateConditionalsMutator]MSP[] result [ i ++ ] = current ; } } return result ; } @Override public < T > T [] toArray ( T [] array ) {
buf . append ( '[' ) ; MST[experimental.NakedReceiverMutator]MSP[] final Iterator < E > it = uniqueSet () . iterator () ; while ( it . hasNext () ) { final Object current = it . next () ; final int count = getCount ( current ) ;
buf . append ( '[' ) ; MST[rv.CRCR6Mutator]MSP[] final Iterator < E > it = uniqueSet () . iterator () ; while ( it . hasNext () ) { final Object current = it . next () ; final int count = getCount ( current ) ;
if ( other . getCount ( element ) != getCount ( element ) ) { return false ; } } return true ; MST[InlineConstantMutator]MSP[] } @Override public int hashCode () { int total = 0 ;
} @Override public boolean remove ( final Object object , final int nCopies ) { final MutableInteger mut = map . get ( object ) ; if ( mut == null ) { return false ; } if ( nCopies <= 0 ) { MST[rv.ROR4Mutator]MSP[] return false ; }
total += ( element == null ? 0 : element . hashCode () ) ^ count . value ; } return total ; } @Override public String toString () { if ( size () == 0 ) { MST[rv.ROR2Mutator]MSP[] return lr_2 ; } final StringBuilder buf = new StringBuilder () ;
final boolean added = add ( i . next () ) ; changed = changed || added ; } return changed ; } @Override public void clear () { modCount ++ ; MST[rv.CRCR4Mutator]MSP[] map . clear () ; size = 0 ; } @Override
final boolean changed = remove ( i . next () , 1 ) ; result = result || changed ; } } return result ; MST[BooleanFalseReturnValsMutator]MSP[] } @Override public boolean retainAll ( final Collection < ? > coll ) { if ( coll instanceof Bag ) {
final MutableInteger mut = map . get ( object ) ; size += nCopies ; MST[rv.UOI3Mutator]MSP[] if ( mut == null ) { map . put ( object , new MutableInteger ( nCopies ) ) ; return true ; } mut . value += nCopies ; return false ; }
buf . append ( count ) ; buf . append ( ':' ) ; MST[rv.CRCR2Mutator]MSP[] buf . append ( current ) ; if ( it . hasNext () ) { buf . append ( ',' ) ; } } buf . append ( ']' ) ;
final boolean added = add ( i . next () ) ; changed = changed || added ; } return changed ; MST[BooleanTrueReturnValsMutator]MSP[] } @Override public void clear () { modCount ++ ; map . clear () ; size = 0 ; } @Override
modCount ++ ; if ( nCopies < mut . value ) { MST[rv.UOI3Mutator]MSP[] mut . value -= nCopies ; size -= nCopies ; } else { map . remove ( object ) ; size -= mut . value ; } return true ; } @Override
if ( other . getCount ( element ) != getCount ( element ) ) { return false ; } } return true ; } @Override public int hashCode () { int total = 0 ; MST[rv.CRCR6Mutator]MSP[]
final MutableInteger count = map . get ( object ) ; if ( count != null ) { return count . value ; } return 0 ; MST[rv.CRCR3Mutator]MSP[] } @Override public boolean contains ( final Object object ) { return map . containsKey ( object ) ; } @Override
protected Map < E , MutableInteger > getMap () { return map ; } @Override public int size () { return size ; MST[rv.UOI4Mutator]MSP[] } @Override public boolean isEmpty () { return map . isEmpty () ; } @Override public int getCount ( final Object object ) {
for ( int index = getCount ( current ) ; index > 0 ; index -- ) { @SuppressWarnings ( lr_1 ) final T unchecked = ( T ) current ; array [ i ++ ] = unchecked ; MST[experimental.RemoveIncrementsMutator]MSP[] } } while ( i < array . length ) {
final boolean added = add ( i . next () ) ; changed = changed || added ; } return changed ; MST[rv.ABSMutator]MSP[] } @Override public void clear () { modCount ++ ; map . clear () ; size = 0 ; } @Override
out . writeInt ( entry . getValue () . value ) ; MST[VoidMethodCallMutator]MSP[] } } protected void doReadObject ( final Map < E , MutableInteger > map , final ObjectInputStream in ) throws IOException , ClassNotFoundException { this . map = map ;
modCount ++ ; if ( nCopies < mut . value ) { mut . value -= nCopies ; size -= nCopies ; MST[rv.UOI2Mutator]MSP[] } else { map . remove ( object ) ; size -= mut . value ; } return true ; } @Override
buf . append ( '[' ) ; MST[rv.CRCR1Mutator]MSP[] final Iterator < E > it = uniqueSet () . iterator () ; while ( it . hasNext () ) { final Object current = it . next () ; final int count = getCount ( current ) ;
buf . append ( '[' ) ; final Iterator < E > it = uniqueSet () . iterator () ; while ( it . hasNext () ) { MST[rv.ROR1Mutator]MSP[] final Object current = it . next () ; final int count = getCount ( current ) ;
map . put ( obj , new MutableInteger ( count ) ) ; size += count ; MST[rv.UOI2Mutator]MSP[] } } @Override public boolean equals ( final Object object ) { if ( object == this ) { return true ; } if ( object instanceof Bag == false ) {
final boolean added = add ( i . next () ) ; changed = changed || added ; MST[rv.ROR5Mutator]MSP[] } return changed ; } @Override public void clear () { modCount ++ ; map . clear () ; size = 0 ; } @Override
final MutableInteger mut = map . get ( object ) ; size += nCopies ; if ( mut == null ) { map . put ( object , new MutableInteger ( nCopies ) ) ; return true ; MST[rv.CRCR5Mutator]MSP[] } mut . value += nCopies ; return false ; }
modCount ++ ; if ( nCopies < mut . value ) { mut . value -= nCopies ; MST[rv.AOD2Mutator]MSP[] size -= nCopies ; } else { map . remove ( object ) ; size -= mut . value ; } return true ; } @Override
array [ i ++ ] = null ; } return array ; } @Override public Set < E > uniqueSet () { if ( uniqueSet == null ) { uniqueSet = UnmodifiableSet . <E > unmodifiableSet ( map . keySet () ) ; MST[experimental.MemberVariableMutator]MSP[] } return uniqueSet ; }
final MutableInteger mut = map . get ( object ) ; size += nCopies ; if ( mut == null ) { map . put ( object , new MutableInteger ( nCopies ) ) ; MST[rv.UOI2Mutator]MSP[] return true ; } mut . value += nCopies ; return false ; }
buf . append ( count ) ; buf . append ( ':' ) ; buf . append ( current ) ; if ( it . hasNext () ) { buf . append ( ',' ) ; MST[rv.CRCR2Mutator]MSP[] } } buf . append ( ']' ) ;
map . put ( obj , new MutableInteger ( count ) ) ; size += count ; } } @Override public boolean equals ( final Object object ) { if ( object == this ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return true ; } if ( object instanceof Bag == false ) {
if ( other . getCount ( element ) != getCount ( element ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return false ; } } return true ; } @Override public int hashCode () { int total = 0 ;
for ( int index = getCount ( current ) ; index > 0 ; index -- ) { result [ i ++ ] = current ; MST[rv.UOI3Mutator]MSP[] } } return result ; } @Override public < T > T [] toArray ( T [] array ) {
buf . append ( count ) ; MST[rv.UOI4Mutator]MSP[] buf . append ( ':' ) ; buf . append ( current ) ; if ( it . hasNext () ) { buf . append ( ',' ) ; } } buf . append ( ']' ) ;
final boolean added = add ( i . next () ) ; changed = changed || added ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] } return changed ; } @Override public void clear () { modCount ++ ; map . clear () ; size = 0 ; } @Override
buf . append ( '[' ) ; final Iterator < E > it = uniqueSet () . iterator () ; while ( it . hasNext () ) { final Object current = it . next () ; final int count = getCount ( current ) ; MST[NonVoidMethodCallMutator]MSP[]
return itemCount > 0 || entryIterator . hasNext () ; MST[rv.ROR1Mutator]MSP[] } @Override public E next () { if ( parent . modCount != mods ) { throw new ConcurrentModificationException () ; } if ( itemCount == 0 ) { current = entryIterator . next () ;
return itemCount > 0 || entryIterator . hasNext () ; } @Override public E next () { if ( parent . modCount != mods ) { throw new ConcurrentModificationException () ; } if ( itemCount == 0 ) { current = entryIterator . next () ; MST[NonVoidMethodCallMutator]MSP[]
return itemCount > 0 || entryIterator . hasNext () ; MST[rv.ROR2Mutator]MSP[] } @Override public E next () { if ( parent . modCount != mods ) { throw new ConcurrentModificationException () ; } if ( itemCount == 0 ) { current = entryIterator . next () ;
return itemCount > 0 || entryIterator . hasNext () ; } @Override public E next () { if ( parent . modCount != mods ) { throw new ConcurrentModificationException () ; } if ( itemCount == 0 ) { current = entryIterator . next () ; MST[experimental.MemberVariableMutator]MSP[]
if ( canRemove == false ) { throw new IllegalStateException () ; } final MutableInteger mut = current . getValue () ; if ( mut . value > 1 ) { MST[rv.CRCR5Mutator]MSP[] mut . value -- ; } else { entryIterator . remove () ; } parent . size -- ;
return itemCount > 0 || entryIterator . hasNext () ; MST[rv.ROR2Mutator]MSP[] } @Override public E next () { if ( parent . modCount != mods ) { throw new ConcurrentModificationException () ; } if ( itemCount == 0 ) { current = entryIterator . next () ;
return itemCount > 0 || entryIterator . hasNext () ; MST[rv.ROR5Mutator]MSP[] } @Override public E next () { if ( parent . modCount != mods ) { throw new ConcurrentModificationException () ; } if ( itemCount == 0 ) { current = entryIterator . next () ;
return itemCount > 0 || entryIterator . hasNext () ; MST[rv.ROR3Mutator]MSP[] } @Override public E next () { if ( parent . modCount != mods ) { throw new ConcurrentModificationException () ; } if ( itemCount == 0 ) { current = entryIterator . next () ;
return itemCount > 0 || entryIterator . hasNext () ; MST[rv.ROR1Mutator]MSP[] } @Override public E next () { if ( parent . modCount != mods ) { throw new ConcurrentModificationException () ; } if ( itemCount == 0 ) { current = entryIterator . next () ;
return itemCount > 0 || entryIterator . hasNext () ; MST[rv.ROR4Mutator]MSP[] } @Override public E next () { if ( parent . modCount != mods ) { throw new ConcurrentModificationException () ; } if ( itemCount == 0 ) { current = entryIterator . next () ;
itemCount = current . getValue () . value ; } canRemove = true ; itemCount -- ; return current . getKey () ; } @Override public void remove () { if ( parent . modCount != mods ) { MST[rv.UOI4Mutator]MSP[] throw new ConcurrentModificationException () ; }
itemCount = current . getValue () . value ; MST[NonVoidMethodCallMutator]MSP[] } canRemove = true ; itemCount -- ; return current . getKey () ; } @Override public void remove () { if ( parent . modCount != mods ) { throw new ConcurrentModificationException () ; }
itemCount = current . getValue () . value ; } canRemove = true ; itemCount -- ; return current . getKey () ; } @Override public void remove () { if ( parent . modCount != mods ) { MST[rv.UOI3Mutator]MSP[] throw new ConcurrentModificationException () ; }
return itemCount > 0 || entryIterator . hasNext () ; MST[rv.ROR5Mutator]MSP[] } @Override public E next () { if ( parent . modCount != mods ) { throw new ConcurrentModificationException () ; } if ( itemCount == 0 ) { current = entryIterator . next () ;
return itemCount > 0 || entryIterator . hasNext () ; MST[rv.ROR3Mutator]MSP[] } @Override public E next () { if ( parent . modCount != mods ) { throw new ConcurrentModificationException () ; } if ( itemCount == 0 ) { current = entryIterator . next () ;
return itemCount > 0 || entryIterator . hasNext () ; MST[rv.ROR4Mutator]MSP[] } @Override public E next () { if ( parent . modCount != mods ) { throw new ConcurrentModificationException () ; } if ( itemCount == 0 ) { current = entryIterator . next () ;
if ( canRemove == false ) { throw new IllegalStateException () ; } final MutableInteger mut = current . getValue () ; if ( mut . value > 1 ) { MST[rv.ROR3Mutator]MSP[] mut . value -- ; } else { entryIterator . remove () ; } parent . size -- ;
if ( canRemove == false ) { throw new IllegalStateException () ; } final MutableInteger mut = current . getValue () ; if ( mut . value > 1 ) { MST[rv.ROR4Mutator]MSP[] mut . value -- ; } else { entryIterator . remove () ; } parent . size -- ;
itemCount = current . getValue () . value ; } canRemove = true ; itemCount -- ; return current . getKey () ; } @Override public void remove () { if ( parent . modCount != mods ) { MST[rv.UOI2Mutator]MSP[] throw new ConcurrentModificationException () ; }
itemCount = current . getValue () . value ; } canRemove = true ; MST[InlineConstantMutator]MSP[] itemCount -- ; return current . getKey () ; } @Override public void remove () { if ( parent . modCount != mods ) { throw new ConcurrentModificationException () ; }
return itemCount > 0 || entryIterator . hasNext () ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] } @Override public E next () { if ( parent . modCount != mods ) { throw new ConcurrentModificationException () ; } if ( itemCount == 0 ) { current = entryIterator . next () ;
return itemCount > 0 || entryIterator . hasNext () ; MST[rv.ABSMutator]MSP[] } @Override public E next () { if ( parent . modCount != mods ) { throw new ConcurrentModificationException () ; } if ( itemCount == 0 ) { current = entryIterator . next () ;
if ( canRemove == false ) { throw new IllegalStateException () ; } final MutableInteger mut = current . getValue () ; if ( mut . value > 1 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] mut . value -- ; } else { entryIterator . remove () ; } parent . size -- ;
return itemCount > 0 || entryIterator . hasNext () ; } @Override public E next () { if ( parent . modCount != mods ) { throw new ConcurrentModificationException () ; } if ( itemCount == 0 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] current = entryIterator . next () ;
return itemCount > 0 || entryIterator . hasNext () ; } @Override public E next () { if ( parent . modCount != mods ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] throw new ConcurrentModificationException () ; } if ( itemCount == 0 ) { current = entryIterator . next () ;
return itemCount > 0 || entryIterator . hasNext () ; } @Override public E next () { if ( parent . modCount != mods ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] throw new ConcurrentModificationException () ; } if ( itemCount == 0 ) { current = entryIterator . next () ;
return itemCount > 0 || entryIterator . hasNext () ; } @Override public E next () { if ( parent . modCount != mods ) { throw new ConcurrentModificationException () ; } if ( itemCount == 0 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] current = entryIterator . next () ;
return itemCount > 0 || entryIterator . hasNext () ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] } @Override public E next () { if ( parent . modCount != mods ) { throw new ConcurrentModificationException () ; } if ( itemCount == 0 ) { current = entryIterator . next () ;
return itemCount > 0 || entryIterator . hasNext () ; } @Override public E next () { if ( parent . modCount != mods ) { MST[NegateConditionalsMutator]MSP[] throw new ConcurrentModificationException () ; } if ( itemCount == 0 ) { current = entryIterator . next () ;
return itemCount > 0 || entryIterator . hasNext () ; } @Override public E next () { if ( parent . modCount != mods ) { MST[rv.ABSMutator]MSP[] throw new ConcurrentModificationException () ; } if ( itemCount == 0 ) { current = entryIterator . next () ;
return itemCount > 0 || entryIterator . hasNext () ; } @Override public E next () { if ( parent . modCount != mods ) { throw new ConcurrentModificationException () ; } if ( itemCount == 0 ) { MST[NegateConditionalsMutator]MSP[] current = entryIterator . next () ;
itemCount = current . getValue () . value ; } canRemove = true ; itemCount -- ; return current . getKey () ; } @Override public void remove () { if ( parent . modCount != mods ) { MST[rv.ROR3Mutator]MSP[] throw new ConcurrentModificationException () ; }
return itemCount > 0 || entryIterator . hasNext () ; MST[rv.UOI4Mutator]MSP[] } @Override public E next () { if ( parent . modCount != mods ) { throw new ConcurrentModificationException () ; } if ( itemCount == 0 ) { current = entryIterator . next () ;
itemCount = current . getValue () . value ; } canRemove = true ; itemCount -- ; return current . getKey () ; } @Override public void remove () { if ( parent . modCount != mods ) { MST[rv.ROR1Mutator]MSP[] throw new ConcurrentModificationException () ; }
if ( canRemove == false ) { throw new IllegalStateException () ; } final MutableInteger mut = current . getValue () ; if ( mut . value > 1 ) { mut . value -- ; } else { entryIterator . remove () ; } parent . size -- ; MST[NonVoidMethodCallMutator]MSP[]
return itemCount > 0 || entryIterator . hasNext () ; } @Override public E next () { if ( parent . modCount != mods ) { MST[rv.ROR2Mutator]MSP[] throw new ConcurrentModificationException () ; } if ( itemCount == 0 ) { current = entryIterator . next () ;
return itemCount > 0 || entryIterator . hasNext () ; } @Override public E next () { if ( parent . modCount != mods ) { MST[rv.ROR4Mutator]MSP[] throw new ConcurrentModificationException () ; } if ( itemCount == 0 ) { current = entryIterator . next () ;
return itemCount > 0 || entryIterator . hasNext () ; MST[rv.CRCR5Mutator]MSP[] } @Override public E next () { if ( parent . modCount != mods ) { throw new ConcurrentModificationException () ; } if ( itemCount == 0 ) { current = entryIterator . next () ;
return itemCount > 0 || entryIterator . hasNext () ; } @Override public E next () { if ( parent . modCount != mods ) { throw new ConcurrentModificationException () ; } if ( itemCount == 0 ) { MST[rv.ROR4Mutator]MSP[] current = entryIterator . next () ;
itemCount = current . getValue () . value ; } canRemove = true ; itemCount -- ; return current . getKey () ; } @Override public void remove () { if ( parent . modCount != mods ) { MST[rv.ROR5Mutator]MSP[] throw new ConcurrentModificationException () ; }
return itemCount > 0 || entryIterator . hasNext () ; } @Override public E next () { if ( parent . modCount != mods ) { throw new ConcurrentModificationException () ; } if ( itemCount == 0 ) { MST[rv.ABSMutator]MSP[] current = entryIterator . next () ;
return itemCount > 0 || entryIterator . hasNext () ; } @Override public E next () { if ( parent . modCount != mods ) { MST[NonVoidMethodCallMutator]MSP[] throw new ConcurrentModificationException () ; } if ( itemCount == 0 ) { current = entryIterator . next () ;
if ( canRemove == false ) { MST[rv.ROR1Mutator]MSP[] throw new IllegalStateException () ; } final MutableInteger mut = current . getValue () ; if ( mut . value > 1 ) { mut . value -- ; } else { entryIterator . remove () ; } parent . size -- ;
canRemove = false ; MST[experimental.MemberVariableMutator]MSP[] } @Override public boolean add ( final E object ) { return add ( object , 1 ) ; } @Override public boolean add ( final E object , final int nCopies ) { modCount ++ ; if ( nCopies > 0 ) {
return itemCount > 0 || entryIterator . hasNext () ; MST[rv.CRCR3Mutator]MSP[] } @Override public E next () { if ( parent . modCount != mods ) { throw new ConcurrentModificationException () ; } if ( itemCount == 0 ) { current = entryIterator . next () ;
return itemCount > 0 || entryIterator . hasNext () ; MST[rv.CRCR1Mutator]MSP[] } @Override public E next () { if ( parent . modCount != mods ) { throw new ConcurrentModificationException () ; } if ( itemCount == 0 ) { current = entryIterator . next () ;
return itemCount > 0 || entryIterator . hasNext () ; } @Override public E next () { if ( parent . modCount != mods ) { throw new ConcurrentModificationException () ; } if ( itemCount == 0 ) { MST[rv.ROR2Mutator]MSP[] current = entryIterator . next () ;
return itemCount > 0 || entryIterator . hasNext () ; MST[rv.CRCR5Mutator]MSP[] } @Override public E next () { if ( parent . modCount != mods ) { throw new ConcurrentModificationException () ; } if ( itemCount == 0 ) { current = entryIterator . next () ;
return itemCount > 0 || entryIterator . hasNext () ; MST[rv.CRCR3Mutator]MSP[] } @Override public E next () { if ( parent . modCount != mods ) { throw new ConcurrentModificationException () ; } if ( itemCount == 0 ) { current = entryIterator . next () ;
if ( canRemove == false ) { MST[rv.ROR5Mutator]MSP[] throw new IllegalStateException () ; } final MutableInteger mut = current . getValue () ; if ( mut . value > 1 ) { mut . value -- ; } else { entryIterator . remove () ; } parent . size -- ;
if ( canRemove == false ) { MST[rv.ROR3Mutator]MSP[] throw new IllegalStateException () ; } final MutableInteger mut = current . getValue () ; if ( mut . value > 1 ) { mut . value -- ; } else { entryIterator . remove () ; } parent . size -- ;
if ( canRemove == false ) { throw new IllegalStateException () ; } final MutableInteger mut = current . getValue () ; if ( mut . value > 1 ) { MST[rv.ABSMutator]MSP[] mut . value -- ; } else { entryIterator . remove () ; } parent . size -- ;
return itemCount > 0 || entryIterator . hasNext () ; MST[NegateConditionalsMutator]MSP[] } @Override public E next () { if ( parent . modCount != mods ) { throw new ConcurrentModificationException () ; } if ( itemCount == 0 ) { current = entryIterator . next () ;
if ( canRemove == false ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] throw new IllegalStateException () ; } final MutableInteger mut = current . getValue () ; if ( mut . value > 1 ) { mut . value -- ; } else { entryIterator . remove () ; } parent . size -- ;
itemCount = current . getValue () . value ; } canRemove = true ; itemCount -- ; MST[rv.AOR4Mutator]MSP[] return current . getKey () ; } @Override public void remove () { if ( parent . modCount != mods ) { throw new ConcurrentModificationException () ; }
itemCount = current . getValue () . value ; } canRemove = true ; itemCount -- ; return current . getKey () ; MST[ReturnValsMutator]MSP[] } @Override public void remove () { if ( parent . modCount != mods ) { throw new ConcurrentModificationException () ; }
return itemCount > 0 || entryIterator . hasNext () ; MST[rv.UOI3Mutator]MSP[] } @Override public E next () { if ( parent . modCount != mods ) { throw new ConcurrentModificationException () ; } if ( itemCount == 0 ) { current = entryIterator . next () ;
itemCount = current . getValue () . value ; } canRemove = true ; MST[experimental.MemberVariableMutator]MSP[] itemCount -- ; return current . getKey () ; } @Override public void remove () { if ( parent . modCount != mods ) { throw new ConcurrentModificationException () ; }
if ( canRemove == false ) { throw new IllegalStateException () ; } final MutableInteger mut = current . getValue () ; if ( mut . value > 1 ) { mut . value -- ; MST[rv.UOI1Mutator]MSP[] } else { entryIterator . remove () ; } parent . size -- ;
if ( canRemove == false ) { throw new IllegalStateException () ; } final MutableInteger mut = current . getValue () ; if ( mut . value > 1 ) { mut . value -- ; MST[rv.UOI2Mutator]MSP[] } else { entryIterator . remove () ; } parent . size -- ;
itemCount = current . getValue () . value ; } canRemove = true ; itemCount -- ; return current . getKey () ; } @Override public void remove () { if ( parent . modCount != mods ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] throw new ConcurrentModificationException () ; }
if ( canRemove == false ) { throw new IllegalStateException () ; } final MutableInteger mut = current . getValue () ; if ( mut . value > 1 ) { mut . value -- ; MST[rv.AOR1Mutator]MSP[] } else { entryIterator . remove () ; } parent . size -- ;
canRemove = false ; MST[rv.CRCR5Mutator]MSP[] } @Override public boolean add ( final E object ) { return add ( object , 1 ) ; } @Override public boolean add ( final E object , final int nCopies ) { modCount ++ ; if ( nCopies > 0 ) {
itemCount = current . getValue () . value ; } canRemove = true ; itemCount -- ; return current . getKey () ; } @Override public void remove () { if ( parent . modCount != mods ) { MST[NonVoidMethodCallMutator]MSP[] throw new ConcurrentModificationException () ; }
itemCount = current . getValue () . value ; } canRemove = true ; MST[rv.CRCR2Mutator]MSP[] itemCount -- ; return current . getKey () ; } @Override public void remove () { if ( parent . modCount != mods ) { throw new ConcurrentModificationException () ; }
if ( canRemove == false ) { MST[NegateConditionalsMutator]MSP[] throw new IllegalStateException () ; } final MutableInteger mut = current . getValue () ; if ( mut . value > 1 ) { mut . value -- ; } else { entryIterator . remove () ; } parent . size -- ;
if ( canRemove == false ) { throw new IllegalStateException () ; } final MutableInteger mut = current . getValue () ; if ( mut . value > 1 ) { MST[rv.UOI4Mutator]MSP[] mut . value -- ; } else { entryIterator . remove () ; } parent . size -- ;
itemCount = current . getValue () . value ; } canRemove = true ; itemCount -- ; return current . getKey () ; } @Override public void remove () { if ( parent . modCount != mods ) { MST[rv.ROR4Mutator]MSP[] throw new ConcurrentModificationException () ; }
canRemove = false ; MST[rv.CRCR1Mutator]MSP[] } @Override public boolean add ( final E object ) { return add ( object , 1 ) ; } @Override public boolean add ( final E object , final int nCopies ) { modCount ++ ; if ( nCopies > 0 ) {
return itemCount > 0 || entryIterator . hasNext () ; MST[RemoveConditionalMutator_ORDER_IF]MSP[] } @Override public E next () { if ( parent . modCount != mods ) { throw new ConcurrentModificationException () ; } if ( itemCount == 0 ) { current = entryIterator . next () ;
return itemCount > 0 || entryIterator . hasNext () ; } @Override public E next () { if ( parent . modCount != mods ) { MST[rv.ROR1Mutator]MSP[] throw new ConcurrentModificationException () ; } if ( itemCount == 0 ) { current = entryIterator . next () ;
return itemCount > 0 || entryIterator . hasNext () ; } @Override public E next () { if ( parent . modCount != mods ) { MST[rv.UOI4Mutator]MSP[] throw new ConcurrentModificationException () ; } if ( itemCount == 0 ) { current = entryIterator . next () ;
return itemCount > 0 || entryIterator . hasNext () ; } @Override public E next () { if ( parent . modCount != mods ) { MST[rv.ROR5Mutator]MSP[] throw new ConcurrentModificationException () ; } if ( itemCount == 0 ) { current = entryIterator . next () ;
return itemCount > 0 || entryIterator . hasNext () ; MST[rv.CRCR4Mutator]MSP[] } @Override public E next () { if ( parent . modCount != mods ) { throw new ConcurrentModificationException () ; } if ( itemCount == 0 ) { current = entryIterator . next () ;
if ( canRemove == false ) { throw new IllegalStateException () ; } final MutableInteger mut = current . getValue () ; if ( mut . value > 1 ) { mut . value -- ; MST[rv.AOD2Mutator]MSP[] } else { entryIterator . remove () ; } parent . size -- ;
return itemCount > 0 || entryIterator . hasNext () ; MST[NegateConditionalsMutator]MSP[] } @Override public E next () { if ( parent . modCount != mods ) { throw new ConcurrentModificationException () ; } if ( itemCount == 0 ) { current = entryIterator . next () ;
return itemCount > 0 || entryIterator . hasNext () ; } @Override public E next () { if ( parent . modCount != mods ) { throw new ConcurrentModificationException () ; } if ( itemCount == 0 ) { MST[rv.ROR5Mutator]MSP[] current = entryIterator . next () ;
itemCount = current . getValue () . value ; } canRemove = true ; MST[rv.CRCR6Mutator]MSP[] itemCount -- ; return current . getKey () ; } @Override public void remove () { if ( parent . modCount != mods ) { throw new ConcurrentModificationException () ; }
return itemCount > 0 || entryIterator . hasNext () ; } @Override public E next () { if ( parent . modCount != mods ) { throw new ConcurrentModificationException () ; } if ( itemCount == 0 ) { MST[rv.UOI4Mutator]MSP[] current = entryIterator . next () ;
return itemCount > 0 || entryIterator . hasNext () ; } @Override public E next () { if ( parent . modCount != mods ) { throw new ConcurrentModificationException () ; } if ( itemCount == 0 ) { MST[rv.ROR1Mutator]MSP[] current = entryIterator . next () ;
return itemCount > 0 || entryIterator . hasNext () ; MST[ConditionalsBoundaryMutator]MSP[] } @Override public E next () { if ( parent . modCount != mods ) { throw new ConcurrentModificationException () ; } if ( itemCount == 0 ) { current = entryIterator . next () ;
if ( canRemove == false ) { MST[rv.ROR4Mutator]MSP[] throw new IllegalStateException () ; } final MutableInteger mut = current . getValue () ; if ( mut . value > 1 ) { mut . value -- ; } else { entryIterator . remove () ; } parent . size -- ;
itemCount = current . getValue () . value ; } canRemove = true ; itemCount -- ; return current . getKey () ; } @Override public void remove () { if ( parent . modCount != mods ) { MST[NegateConditionalsMutator]MSP[] throw new ConcurrentModificationException () ; }
return itemCount > 0 || entryIterator . hasNext () ; MST[NonVoidMethodCallMutator]MSP[] } @Override public E next () { if ( parent . modCount != mods ) { throw new ConcurrentModificationException () ; } if ( itemCount == 0 ) { current = entryIterator . next () ;
return itemCount > 0 || entryIterator . hasNext () ; } @Override public E next () { if ( parent . modCount != mods ) { MST[rv.UOI1Mutator]MSP[] throw new ConcurrentModificationException () ; } if ( itemCount == 0 ) { current = entryIterator . next () ;
itemCount = current . getValue () . value ; } canRemove = true ; itemCount -- ; return current . getKey () ; MST[NonVoidMethodCallMutator]MSP[] } @Override public void remove () { if ( parent . modCount != mods ) { throw new ConcurrentModificationException () ; }
if ( canRemove == false ) { throw new IllegalStateException () ; } final MutableInteger mut = current . getValue () ; if ( mut . value > 1 ) { mut . value -- ; MST[rv.AOR2Mutator]MSP[] } else { entryIterator . remove () ; } parent . size -- ;
itemCount = current . getValue () . value ; } canRemove = true ; MST[rv.CRCR3Mutator]MSP[] itemCount -- ; return current . getKey () ; } @Override public void remove () { if ( parent . modCount != mods ) { throw new ConcurrentModificationException () ; }
return itemCount > 0 || entryIterator . hasNext () ; MST[BooleanTrueReturnValsMutator]MSP[] } @Override public E next () { if ( parent . modCount != mods ) { throw new ConcurrentModificationException () ; } if ( itemCount == 0 ) { current = entryIterator . next () ;
if ( canRemove == false ) { throw new IllegalStateException () ; } final MutableInteger mut = current . getValue () ; if ( mut . value > 1 ) { MST[rv.UOI3Mutator]MSP[] mut . value -- ; } else { entryIterator . remove () ; } parent . size -- ;
canRemove = false ; MST[rv.CRCR6Mutator]MSP[] } @Override public boolean add ( final E object ) { return add ( object , 1 ) ; } @Override public boolean add ( final E object , final int nCopies ) { modCount ++ ; if ( nCopies > 0 ) {
return itemCount > 0 || entryIterator . hasNext () ; } @Override public E next () { if ( parent . modCount != mods ) { MST[rv.UOI3Mutator]MSP[] throw new ConcurrentModificationException () ; } if ( itemCount == 0 ) { current = entryIterator . next () ;
if ( canRemove == false ) { throw new IllegalStateException () ; } final MutableInteger mut = current . getValue () ; if ( mut . value > 1 ) { MST[rv.UOI1Mutator]MSP[] mut . value -- ; } else { entryIterator . remove () ; } parent . size -- ;
itemCount = current . getValue () . value ; } canRemove = true ; itemCount -- ; return current . getKey () ; MST[NullReturnValsMutator]MSP[] } @Override public void remove () { if ( parent . modCount != mods ) { throw new ConcurrentModificationException () ; }
if ( canRemove == false ) { throw new IllegalStateException () ; } final MutableInteger mut = current . getValue () ; if ( mut . value > 1 ) { mut . value -- ; MST[rv.AOD1Mutator]MSP[] } else { entryIterator . remove () ; } parent . size -- ;
return itemCount > 0 || entryIterator . hasNext () ; MST[InlineConstantMutator]MSP[] } @Override public E next () { if ( parent . modCount != mods ) { throw new ConcurrentModificationException () ; } if ( itemCount == 0 ) { current = entryIterator . next () ;
itemCount = current . getValue () . value ; } canRemove = true ; MST[rv.CRCR5Mutator]MSP[] itemCount -- ; return current . getKey () ; } @Override public void remove () { if ( parent . modCount != mods ) { throw new ConcurrentModificationException () ; }
return itemCount > 0 || entryIterator . hasNext () ; MST[InlineConstantMutator]MSP[] } @Override public E next () { if ( parent . modCount != mods ) { throw new ConcurrentModificationException () ; } if ( itemCount == 0 ) { current = entryIterator . next () ;
return itemCount > 0 || entryIterator . hasNext () ; } @Override public E next () { if ( parent . modCount != mods ) { throw new ConcurrentModificationException () ; } if ( itemCount == 0 ) { MST[rv.UOI3Mutator]MSP[] current = entryIterator . next () ;
if ( canRemove == false ) { throw new IllegalStateException () ; } final MutableInteger mut = current . getValue () ; if ( mut . value > 1 ) { mut . value -- ; MST[rv.CRCR6Mutator]MSP[] } else { entryIterator . remove () ; } parent . size -- ;
if ( canRemove == false ) { throw new IllegalStateException () ; } final MutableInteger mut = current . getValue () ; if ( mut . value > 1 ) { mut . value -- ; MST[rv.CRCR2Mutator]MSP[] } else { entryIterator . remove () ; } parent . size -- ;
if ( canRemove == false ) { throw new IllegalStateException () ; } final MutableInteger mut = current . getValue () ; if ( mut . value > 1 ) { mut . value -- ; MST[rv.CRCR4Mutator]MSP[] } else { entryIterator . remove () ; } parent . size -- ;
itemCount = current . getValue () . value ; } canRemove = true ; itemCount -- ; MST[rv.UOI2Mutator]MSP[] return current . getKey () ; } @Override public void remove () { if ( parent . modCount != mods ) { throw new ConcurrentModificationException () ; }
if ( canRemove == false ) { throw new IllegalStateException () ; } final MutableInteger mut = current . getValue () ; MST[NonVoidMethodCallMutator]MSP[] if ( mut . value > 1 ) { mut . value -- ; } else { entryIterator . remove () ; } parent . size -- ;
if ( canRemove == false ) { throw new IllegalStateException () ; } final MutableInteger mut = current . getValue () ; if ( mut . value > 1 ) { mut . value -- ; MST[experimental.MemberVariableMutator]MSP[] } else { entryIterator . remove () ; } parent . size -- ;
canRemove = false ; MST[InlineConstantMutator]MSP[] } @Override public boolean add ( final E object ) { return add ( object , 1 ) ; } @Override public boolean add ( final E object , final int nCopies ) { modCount ++ ; if ( nCopies > 0 ) {
return itemCount > 0 || entryIterator . hasNext () ; MST[rv.UOI2Mutator]MSP[] } @Override public E next () { if ( parent . modCount != mods ) { throw new ConcurrentModificationException () ; } if ( itemCount == 0 ) { current = entryIterator . next () ;
if ( canRemove == false ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] throw new IllegalStateException () ; } final MutableInteger mut = current . getValue () ; if ( mut . value > 1 ) { mut . value -- ; } else { entryIterator . remove () ; } parent . size -- ;
if ( canRemove == false ) { throw new IllegalStateException () ; } final MutableInteger mut = current . getValue () ; if ( mut . value > 1 ) { mut . value -- ; MST[rv.UOI3Mutator]MSP[] } else { entryIterator . remove () ; } parent . size -- ;
return itemCount > 0 || entryIterator . hasNext () ; MST[rv.UOI1Mutator]MSP[] } @Override public E next () { if ( parent . modCount != mods ) { throw new ConcurrentModificationException () ; } if ( itemCount == 0 ) { current = entryIterator . next () ;
itemCount = current . getValue () . value ; } canRemove = true ; itemCount -- ; MST[rv.UOI1Mutator]MSP[] return current . getKey () ; } @Override public void remove () { if ( parent . modCount != mods ) { throw new ConcurrentModificationException () ; }
if ( canRemove == false ) { throw new IllegalStateException () ; } final MutableInteger mut = current . getValue () ; if ( mut . value > 1 ) { mut . value -- ; } else { entryIterator . remove () ; MST[VoidMethodCallMutator]MSP[] } parent . size -- ;
itemCount = current . getValue () . value ; } canRemove = true ; itemCount -- ; return current . getKey () ; } @Override public void remove () { if ( parent . modCount != mods ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] throw new ConcurrentModificationException () ; }
return itemCount > 0 || entryIterator . hasNext () ; MST[ReturnValsMutator]MSP[] } @Override public E next () { if ( parent . modCount != mods ) { throw new ConcurrentModificationException () ; } if ( itemCount == 0 ) { current = entryIterator . next () ;
canRemove = false ; MST[rv.CRCR3Mutator]MSP[] } @Override public boolean add ( final E object ) { return add ( object , 1 ) ; } @Override public boolean add ( final E object , final int nCopies ) { modCount ++ ; if ( nCopies > 0 ) {
if ( canRemove == false ) { throw new IllegalStateException () ; MST[ConstructorCallMutator]MSP[] } final MutableInteger mut = current . getValue () ; if ( mut . value > 1 ) { mut . value -- ; } else { entryIterator . remove () ; } parent . size -- ;
if ( canRemove == false ) { throw new IllegalStateException () ; } final MutableInteger mut = current . getValue () ; if ( mut . value > 1 ) { mut . value -- ; MST[rv.AOR3Mutator]MSP[] } else { entryIterator . remove () ; } parent . size -- ;
itemCount = current . getValue () . value ; } canRemove = true ; itemCount -- ; return current . getKey () ; } @Override public void remove () { if ( parent . modCount != mods ) { MST[rv.ROR2Mutator]MSP[] throw new ConcurrentModificationException () ; }
return itemCount > 0 || entryIterator . hasNext () ; } @Override public E next () { if ( parent . modCount != mods ) { MST[rv.UOI2Mutator]MSP[] throw new ConcurrentModificationException () ; } if ( itemCount == 0 ) { current = entryIterator . next () ;
itemCount = current . getValue () . value ; } canRemove = true ; itemCount -- ; return current . getKey () ; } @Override public void remove () { if ( parent . modCount != mods ) { MST[rv.ABSMutator]MSP[] throw new ConcurrentModificationException () ; }
if ( canRemove == false ) { throw new IllegalStateException () ; } final MutableInteger mut = current . getValue () ; if ( mut . value > 1 ) { mut . value -- ; MST[MathMutator]MSP[] } else { entryIterator . remove () ; } parent . size -- ;
return itemCount > 0 || entryIterator . hasNext () ; } @Override public E next () { if ( parent . modCount != mods ) { MST[rv.ROR3Mutator]MSP[] throw new ConcurrentModificationException () ; } if ( itemCount == 0 ) { current = entryIterator . next () ;
return itemCount > 0 || entryIterator . hasNext () ; MST[rv.CRCR6Mutator]MSP[] } @Override public E next () { if ( parent . modCount != mods ) { throw new ConcurrentModificationException () ; } if ( itemCount == 0 ) { current = entryIterator . next () ;
itemCount = current . getValue () . value ; } canRemove = true ; itemCount -- ; return current . getKey () ; } @Override public void remove () { if ( parent . modCount != mods ) { MST[rv.UOI1Mutator]MSP[] throw new ConcurrentModificationException () ; }
if ( canRemove == false ) { throw new IllegalStateException () ; } final MutableInteger mut = current . getValue () ; if ( mut . value > 1 ) { mut . value -- ; MST[InlineConstantMutator]MSP[] } else { entryIterator . remove () ; } parent . size -- ;
itemCount = current . getValue () . value ; } canRemove = true ; MST[rv.CRCR4Mutator]MSP[] itemCount -- ; return current . getKey () ; } @Override public void remove () { if ( parent . modCount != mods ) { throw new ConcurrentModificationException () ; }
return itemCount > 0 || entryIterator . hasNext () ; } @Override public E next () { if ( parent . modCount != mods ) { throw new ConcurrentModificationException () ; } if ( itemCount == 0 ) { MST[rv.ROR3Mutator]MSP[] current = entryIterator . next () ;
return itemCount > 0 || entryIterator . hasNext () ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] } @Override public E next () { if ( parent . modCount != mods ) { throw new ConcurrentModificationException () ; } if ( itemCount == 0 ) { current = entryIterator . next () ;
return itemCount > 0 || entryIterator . hasNext () ; MST[rv.CRCR2Mutator]MSP[] } @Override public E next () { if ( parent . modCount != mods ) { throw new ConcurrentModificationException () ; } if ( itemCount == 0 ) { current = entryIterator . next () ;
return itemCount > 0 || entryIterator . hasNext () ; MST[rv.CRCR6Mutator]MSP[] } @Override public E next () { if ( parent . modCount != mods ) { throw new ConcurrentModificationException () ; } if ( itemCount == 0 ) { current = entryIterator . next () ;
if ( canRemove == false ) { MST[rv.ROR2Mutator]MSP[] throw new IllegalStateException () ; } final MutableInteger mut = current . getValue () ; if ( mut . value > 1 ) { mut . value -- ; } else { entryIterator . remove () ; } parent . size -- ;
if ( canRemove == false ) { throw new IllegalStateException () ; } final MutableInteger mut = current . getValue () ; if ( mut . value > 1 ) { mut . value -- ; MST[rv.CRCR3Mutator]MSP[] } else { entryIterator . remove () ; } parent . size -- ;
array [ i ++ ] = null ; } return array ; } @Override public Set < E > uniqueSet () { if ( uniqueSet == null ) { uniqueSet = UnmodifiableSet . <E > unmodifiableSet ( map . keySet () ) ; } return uniqueSet ; MST[EmptyObjectReturnValsMutator]MSP[] }
} @Override public boolean remove ( final Object object , final int nCopies ) { final MutableInteger mut = map . get ( object ) ; if ( mut == null ) { return false ; } if ( nCopies <= 0 ) { MST[NegateConditionalsMutator]MSP[] return false ; }
return buf . toString () ; MST[EmptyObjectReturnValsMutator]MSP[] }
final int entrySize = in . readInt () ; for ( int i = 0 ; i < entrySize ; i ++ ) { MST[rv.UOI1Mutator]MSP[] @SuppressWarnings ( lr_1 ) final E obj = ( E ) in . readObject () ; final int count = in . readInt () ;
final boolean changed = remove ( i . next () , 1 ) ; result = result || changed ; } } return result ; MST[rv.UOI2Mutator]MSP[] } @Override public boolean retainAll ( final Collection < ? > coll ) { if ( coll instanceof Bag ) {
} @Override public boolean remove ( final Object object , final int nCopies ) { final MutableInteger mut = map . get ( object ) ; if ( mut == null ) { return false ; MST[InlineConstantMutator]MSP[] } if ( nCopies <= 0 ) { return false ; }
total += ( element == null ? 0 : element . hashCode () ) ^ count . value ; } return total ; } @Override public String toString () { if ( size () == 0 ) { return lr_2 ; MST[EmptyObjectReturnValsMutator]MSP[] } final StringBuilder buf = new StringBuilder () ;
modCount ++ ; if ( nCopies < mut . value ) { mut . value -= nCopies ; MST[rv.UOI2Mutator]MSP[] size -= nCopies ; } else { map . remove ( object ) ; size -= mut . value ; } return true ; } @Override
final int entrySize = in . readInt () ; for ( int i = 0 ; i < entrySize ; i ++ ) { @SuppressWarnings ( lr_1 ) final E obj = ( E ) in . readObject () ; MST[NonVoidMethodCallMutator]MSP[] final int count = in . readInt () ;
public boolean removeAll ( final Collection < ? > coll ) { boolean result = false ; if ( coll != null ) { MST[NegateConditionalsMutator]MSP[] final Iterator < ? > i = coll . iterator () ; while ( i . hasNext () ) {
modCount ++ ; if ( nCopies < mut . value ) { mut . value -= nCopies ; size -= nCopies ; MST[rv.UOI4Mutator]MSP[] } else { map . remove ( object ) ; size -= mut . value ; } return true ; } @Override
modCount ++ ; if ( nCopies < mut . value ) { mut . value -= nCopies ; size -= nCopies ; } else { map . remove ( object ) ; size -= mut . value ; } return true ; MST[rv.CRCR6Mutator]MSP[] } @Override
modCount ++ ; if ( nCopies < mut . value ) { mut . value -= nCopies ; MST[rv.ABSMutator]MSP[] size -= nCopies ; } else { map . remove ( object ) ; size -= mut . value ; } return true ; } @Override
final int size = size () ; if ( array . length < size ) { @SuppressWarnings ( lr_1 ) final T [] unchecked = ( T [] ) Array . newInstance ( array . getClass () . getComponentType () , size ) ; MST[NonVoidMethodCallMutator]MSP[] array = unchecked ; }
buf . append ( '[' ) ; final Iterator < E > it = uniqueSet () . iterator () ; while ( it . hasNext () ) { MST[rv.ROR2Mutator]MSP[] final Object current = it . next () ; final int count = getCount ( current ) ;
if ( getCount ( current ) < other . getCount ( current ) ) { return false ; } } return true ; } @Override public Iterator < E > iterator () { return new BagIterator <> ( this ) ; MST[ConstructorCallMutator]MSP[] } @Override public boolean hasNext () {
for ( int index = getCount ( current ) ; index > 0 ; index -- ) { @SuppressWarnings ( lr_1 ) final T unchecked = ( T ) current ; array [ i ++ ] = unchecked ; } } while ( i < array . length ) { MST[rv.ROR4Mutator]MSP[]
canRemove = false ; } @Override public boolean add ( final E object ) { return add ( object , 1 ) ; MST[ReturnValsMutator]MSP[] } @Override public boolean add ( final E object , final int nCopies ) { modCount ++ ; if ( nCopies > 0 ) {
final boolean added = add ( i . next () ) ; changed = changed || added ; } return changed ; } @Override public void clear () { modCount ++ ; map . clear () ; size = 0 ; MST[rv.CRCR1Mutator]MSP[] } @Override
array [ i ++ ] = null ; } return array ; } @Override public Set < E > uniqueSet () { if ( uniqueSet == null ) { uniqueSet = UnmodifiableSet . <E > unmodifiableSet ( map . keySet () ) ; MST[ArgumentPropagationMutator]MSP[] } return uniqueSet ; }
map . put ( obj , new MutableInteger ( count ) ) ; size += count ; } } @Override public boolean equals ( final Object object ) { if ( object == this ) { return true ; MST[rv.CRCR3Mutator]MSP[] } if ( object instanceof Bag == false ) {
final MutableInteger mut = map . get ( object ) ; MST[NonVoidMethodCallMutator]MSP[] size += nCopies ; if ( mut == null ) { map . put ( object , new MutableInteger ( nCopies ) ) ; return true ; } mut . value += nCopies ; return false ; }
public boolean removeAll ( final Collection < ? > coll ) { boolean result = false ; if ( coll != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] final Iterator < ? > i = coll . iterator () ; while ( i . hasNext () ) {
for ( int index = getCount ( current ) ; index > 0 ; index -- ) { result [ i ++ ] = current ; } } return result ; MST[ReturnValsMutator]MSP[] } @Override public < T > T [] toArray ( T [] array ) {
if ( other . getCount ( element ) != getCount ( element ) ) { MST[rv.ROR1Mutator]MSP[] return false ; } } return true ; } @Override public int hashCode () { int total = 0 ;
modCount ++ ; MST[rv.UOI2Mutator]MSP[] if ( nCopies < mut . value ) { mut . value -= nCopies ; size -= nCopies ; } else { map . remove ( object ) ; size -= mut . value ; } return true ; } @Override
canRemove = false ; } @Override public boolean add ( final E object ) { return add ( object , 1 ) ; } @Override public boolean add ( final E object , final int nCopies ) { modCount ++ ; if ( nCopies > 0 ) { MST[rv.ROR2Mutator]MSP[]
final boolean added = add ( i . next () ) ; changed = changed || added ; } return changed ; } @Override public void clear () { modCount ++ ; MST[rv.CRCR6Mutator]MSP[] map . clear () ; size = 0 ; } @Override
final int size = size () ; if ( array . length < size ) { @SuppressWarnings ( lr_1 ) final T [] unchecked = ( T [] ) Array . newInstance ( array . getClass () . getComponentType () , size ) ; MST[rv.UOI3Mutator]MSP[] array = unchecked ; }
total += ( element == null ? 0 : element . hashCode () ) ^ count . value ; } return total ; } @Override public String toString () { if ( size () == 0 ) { MST[rv.ROR3Mutator]MSP[] return lr_2 ; } final StringBuilder buf = new StringBuilder () ;
buf . append ( count ) ; buf . append ( ':' ) ; buf . append ( current ) ; if ( it . hasNext () ) { MST[rv.ROR2Mutator]MSP[] buf . append ( ',' ) ; } } buf . append ( ']' ) ;
modCount ++ ; if ( nCopies < mut . value ) { MST[rv.UOI4Mutator]MSP[] mut . value -= nCopies ; size -= nCopies ; } else { map . remove ( object ) ; size -= mut . value ; } return true ; } @Override
public boolean removeAll ( final Collection < ? > coll ) { boolean result = false ; if ( coll != null ) { MST[rv.ROR5Mutator]MSP[] final Iterator < ? > i = coll . iterator () ; while ( i . hasNext () ) {
final int entrySize = in . readInt () ; for ( int i = 0 ; i < entrySize ; i ++ ) { MST[rv.ROR2Mutator]MSP[] @SuppressWarnings ( lr_1 ) final E obj = ( E ) in . readObject () ; final int count = in . readInt () ;
buf . append ( count ) ; buf . append ( ':' ) ; MST[experimental.NakedReceiverMutator]MSP[] buf . append ( current ) ; if ( it . hasNext () ) { buf . append ( ',' ) ; } } buf . append ( ']' ) ;
final MutableInteger mut = map . get ( object ) ; size += nCopies ; if ( mut == null ) { map . put ( object , new MutableInteger ( nCopies ) ) ; return true ; } mut . value += nCopies ; MST[rv.UOI3Mutator]MSP[] return false ; }
buf . append ( count ) ; buf . append ( ':' ) ; buf . append ( current ) ; if ( it . hasNext () ) { buf . append ( ',' ) ; } } buf . append ( ']' ) ; MST[rv.CRCR1Mutator]MSP[]
return false ; } final Bag < ? > other = ( Bag < ? > ) object ; if ( other . size () != size () ) { MST[rv.ROR2Mutator]MSP[] return false ; } for ( final E element : map . keySet () ) {
final MutableInteger count = map . get ( object ) ; if ( count != null ) { return count . value ; MST[rv.ABSMutator]MSP[] } return 0 ; } @Override public boolean contains ( final Object object ) { return map . containsKey ( object ) ; } @Override
modCount ++ ; MST[rv.ABSMutator]MSP[] if ( nCopies < mut . value ) { mut . value -= nCopies ; size -= nCopies ; } else { map . remove ( object ) ; size -= mut . value ; } return true ; } @Override
for ( int index = getCount ( current ) ; index > 0 ; index -- ) { MST[experimental.RemoveIncrementsMutator]MSP[] result [ i ++ ] = current ; } } return result ; } @Override public < T > T [] toArray ( T [] array ) {
array [ i ++ ] = null ; MST[IncrementsMutator]MSP[] } return array ; } @Override public Set < E > uniqueSet () { if ( uniqueSet == null ) { uniqueSet = UnmodifiableSet . <E > unmodifiableSet ( map . keySet () ) ; } return uniqueSet ; }
buf . append ( count ) ; buf . append ( ':' ) ; buf . append ( current ) ; if ( it . hasNext () ) { buf . append ( ',' ) ; MST[experimental.NakedReceiverMutator]MSP[] } } buf . append ( ']' ) ;
for ( int index = getCount ( current ) ; index > 0 ; index -- ) { result [ i ++ ] = current ; MST[rv.UOI1Mutator]MSP[] } } return result ; } @Override public < T > T [] toArray ( T [] array ) {
} @Override public boolean remove ( final Object object , final int nCopies ) { final MutableInteger mut = map . get ( object ) ; if ( mut == null ) { return false ; } if ( nCopies <= 0 ) { MST[rv.UOI4Mutator]MSP[] return false ; }
for ( int index = getCount ( current ) ; index > 0 ; index -- ) { @SuppressWarnings ( lr_1 ) final T unchecked = ( T ) current ; array [ i ++ ] = unchecked ; MST[rv.UOI3Mutator]MSP[] } } while ( i < array . length ) {
} @Override public boolean remove ( final Object object , final int nCopies ) { final MutableInteger mut = map . get ( object ) ; if ( mut == null ) { return false ; } if ( nCopies <= 0 ) { MST[rv.ROR5Mutator]MSP[] return false ; }
total += ( element == null ? 0 : element . hashCode () ) ^ count . value ; } return total ; } @Override public String toString () { if ( size () == 0 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return lr_2 ; } final StringBuilder buf = new StringBuilder () ;
for ( int index = getCount ( current ) ; index > 0 ; index -- ) { @SuppressWarnings ( lr_1 ) final T unchecked = ( T ) current ; array [ i ++ ] = unchecked ; } } while ( i < array . length ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[]
map . put ( obj , new MutableInteger ( count ) ) ; size += count ; } } @Override public boolean equals ( final Object object ) { if ( object == this ) { return true ; } if ( object instanceof Bag == false ) { MST[rv.ROR5Mutator]MSP[]
for ( int index = getCount ( current ) ; index > 0 ; index -- ) { @SuppressWarnings ( lr_1 ) final T unchecked = ( T ) current ; array [ i ++ ] = unchecked ; } } while ( i < array . length ) { MST[rv.UOI3Mutator]MSP[]
return false ; } @Override public boolean addAll ( final Collection < ? extends E > coll ) { boolean changed = false ; MST[rv.CRCR1Mutator]MSP[] final Iterator < ? extends E > i = coll . iterator () ; while ( i . hasNext () ) {
canRemove = false ; } @Override public boolean add ( final E object ) { return add ( object , 1 ) ; } @Override public boolean add ( final E object , final int nCopies ) { modCount ++ ; if ( nCopies > 0 ) { MST[rv.UOI4Mutator]MSP[]
map . put ( obj , new MutableInteger ( count ) ) ; size += count ; } } @Override public boolean equals ( final Object object ) { if ( object == this ) { return true ; } if ( object instanceof Bag == false ) { MST[rv.ROR2Mutator]MSP[]
map . put ( obj , new MutableInteger ( count ) ) ; MST[rv.ABSMutator]MSP[] size += count ; } } @Override public boolean equals ( final Object object ) { if ( object == this ) { return true ; } if ( object instanceof Bag == false ) {
buf . append ( '[' ) ; MST[rv.CRCR2Mutator]MSP[] final Iterator < E > it = uniqueSet () . iterator () ; while ( it . hasNext () ) { final Object current = it . next () ; final int count = getCount ( current ) ;
final boolean added = add ( i . next () ) ; changed = changed || added ; MST[rv.CRCR4Mutator]MSP[] } return changed ; } @Override public void clear () { modCount ++ ; map . clear () ; size = 0 ; } @Override
return false ; MST[rv.CRCR5Mutator]MSP[] } final Bag < ? > other = ( Bag < ? > ) object ; if ( other . size () != size () ) { return false ; } for ( final E element : map . keySet () ) {
final boolean added = add ( i . next () ) ; changed = changed || added ; MST[rv.ROR4Mutator]MSP[] } return changed ; } @Override public void clear () { modCount ++ ; map . clear () ; size = 0 ; } @Override
final MutableInteger mut = map . get ( object ) ; size += nCopies ; if ( mut == null ) { map . put ( object , new MutableInteger ( nCopies ) ) ; return true ; MST[rv.CRCR6Mutator]MSP[] } mut . value += nCopies ; return false ; }
buf . append ( count ) ; buf . append ( ':' ) ; buf . append ( current ) ; if ( it . hasNext () ) { buf . append ( ',' ) ; MST[rv.CRCR3Mutator]MSP[] } } buf . append ( ']' ) ;
final MutableInteger mut = map . get ( object ) ; size += nCopies ; if ( mut == null ) { map . put ( object , new MutableInteger ( nCopies ) ) ; MST[rv.UOI3Mutator]MSP[] return true ; } mut . value += nCopies ; return false ; }
return false ; } final Bag < ? > other = ( Bag < ? > ) object ; if ( other . size () != size () ) { MST[rv.ROR5Mutator]MSP[] return false ; } for ( final E element : map . keySet () ) {
modCount ++ ; MST[rv.AOD1Mutator]MSP[] if ( nCopies < mut . value ) { mut . value -= nCopies ; size -= nCopies ; } else { map . remove ( object ) ; size -= mut . value ; } return true ; } @Override
public boolean removeAll ( final Collection < ? > coll ) { boolean result = false ; MST[rv.CRCR6Mutator]MSP[] if ( coll != null ) { final Iterator < ? > i = coll . iterator () ; while ( i . hasNext () ) {
final MutableInteger mut = map . get ( object ) ; size += nCopies ; if ( mut == null ) { map . put ( object , new MutableInteger ( nCopies ) ) ; return true ; } mut . value += nCopies ; MST[rv.AOD2Mutator]MSP[] return false ; }
modCount ++ ; MST[InlineConstantMutator]MSP[] if ( nCopies < mut . value ) { mut . value -= nCopies ; size -= nCopies ; } else { map . remove ( object ) ; size -= mut . value ; } return true ; } @Override
final boolean changed = remove ( i . next () , 1 ) ; result = result || changed ; } } return result ; MST[rv.ABSMutator]MSP[] } @Override public boolean retainAll ( final Collection < ? > coll ) { if ( coll instanceof Bag ) {
buf . append ( count ) ; buf . append ( ':' ) ; MST[rv.CRCR3Mutator]MSP[] buf . append ( current ) ; if ( it . hasNext () ) { buf . append ( ',' ) ; } } buf . append ( ']' ) ;
buf . append ( count ) ; buf . append ( ':' ) ; MST[rv.CRCR6Mutator]MSP[] buf . append ( current ) ; if ( it . hasNext () ) { buf . append ( ',' ) ; } } buf . append ( ']' ) ;
final MutableInteger mut = map . get ( object ) ; size += nCopies ; if ( mut == null ) { map . put ( object , new MutableInteger ( nCopies ) ) ; MST[ArgumentPropagationMutator]MSP[] return true ; } mut . value += nCopies ; return false ; }
final boolean added = add ( i . next () ) ; changed = changed || added ; MST[rv.UOI1Mutator]MSP[] } return changed ; } @Override public void clear () { modCount ++ ; map . clear () ; size = 0 ; } @Override
out . writeInt ( entry . getValue () . value ) ; MST[rv.ABSMutator]MSP[] } } protected void doReadObject ( final Map < E , MutableInteger > map , final ObjectInputStream in ) throws IOException , ClassNotFoundException { this . map = map ;
modCount ++ ; if ( nCopies < mut . value ) { MST[rv.UOI4Mutator]MSP[] mut . value -= nCopies ; size -= nCopies ; } else { map . remove ( object ) ; size -= mut . value ; } return true ; } @Override
final MutableInteger mut = map . get ( object ) ; size += nCopies ; if ( mut == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] map . put ( object , new MutableInteger ( nCopies ) ) ; return true ; } mut . value += nCopies ; return false ; }
protected Map < E , MutableInteger > getMap () { return map ; } @Override public int size () { return size ; } @Override public boolean isEmpty () { return map . isEmpty () ; MST[BooleanFalseReturnValsMutator]MSP[] } @Override public int getCount ( final Object object ) {
if ( other . getCount ( element ) != getCount ( element ) ) { MST[rv.ROR4Mutator]MSP[] return false ; } } return true ; } @Override public int hashCode () { int total = 0 ;
return false ; MST[ReturnValsMutator]MSP[] } final Bag < ? > other = ( Bag < ? > ) object ; if ( other . size () != size () ) { return false ; } for ( final E element : map . keySet () ) {
modCount ++ ; if ( nCopies < mut . value ) { mut . value -= nCopies ; size -= nCopies ; MST[rv.AOR1Mutator]MSP[] } else { map . remove ( object ) ; size -= mut . value ; } return true ; } @Override
public boolean removeAll ( final Collection < ? > coll ) { boolean result = false ; MST[rv.CRCR3Mutator]MSP[] if ( coll != null ) { final Iterator < ? > i = coll . iterator () ; while ( i . hasNext () ) {
final MutableInteger count = map . get ( object ) ; if ( count != null ) { return count . value ; } return 0 ; } @Override public boolean contains ( final Object object ) { return map . containsKey ( object ) ; MST[NonVoidMethodCallMutator]MSP[] } @Override
modCount ++ ; if ( nCopies < mut . value ) { mut . value -= nCopies ; MST[rv.UOI1Mutator]MSP[] size -= nCopies ; } else { map . remove ( object ) ; size -= mut . value ; } return true ; } @Override
return buf . toString () ; MST[NonVoidMethodCallMutator]MSP[] }
buf . append ( '[' ) ; final Iterator < E > it = uniqueSet () . iterator () ; while ( it . hasNext () ) { MST[rv.ROR5Mutator]MSP[] final Object current = it . next () ; final int count = getCount ( current ) ;
final boolean added = add ( i . next () ) ; changed = changed || added ; } return changed ; } @Override public void clear () { modCount ++ ; MST[rv.UOI1Mutator]MSP[] map . clear () ; size = 0 ; } @Override
for ( int index = getCount ( current ) ; index > 0 ; index -- ) { @SuppressWarnings ( lr_1 ) final T unchecked = ( T ) current ; array [ i ++ ] = unchecked ; } } while ( i < array . length ) { MST[rv.ROR1Mutator]MSP[]
canRemove = false ; } @Override public boolean add ( final E object ) { return add ( object , 1 ) ; } @Override public boolean add ( final E object , final int nCopies ) { modCount ++ ; MST[rv.CRCR4Mutator]MSP[] if ( nCopies > 0 ) {
if ( other . getCount ( element ) != getCount ( element ) ) { return false ; } } return true ; MST[rv.CRCR2Mutator]MSP[] } @Override public int hashCode () { int total = 0 ;
final MutableInteger mut = map . get ( object ) ; size += nCopies ; MST[rv.AOR1Mutator]MSP[] if ( mut == null ) { map . put ( object , new MutableInteger ( nCopies ) ) ; return true ; } mut . value += nCopies ; return false ; }
buf . append ( '[' ) ; MST[rv.CRCR5Mutator]MSP[] final Iterator < E > it = uniqueSet () . iterator () ; while ( it . hasNext () ) { final Object current = it . next () ; final int count = getCount ( current ) ;
buf . append ( count ) ; buf . append ( ':' ) ; buf . append ( current ) ; if ( it . hasNext () ) { buf . append ( ',' ) ; MST[rv.CRCR6Mutator]MSP[] } } buf . append ( ']' ) ;
int i = 0 ; MST[rv.CRCR6Mutator]MSP[] final Iterator < E > it = map . keySet () . iterator () ; while ( it . hasNext () ) { final E current = it . next () ;
return false ; MST[InlineConstantMutator]MSP[] } final Bag < ? > other = ( Bag < ? > ) object ; if ( other . size () != size () ) { return false ; } for ( final E element : map . keySet () ) {
final MutableInteger count = map . get ( object ) ; if ( count != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return count . value ; } return 0 ; } @Override public boolean contains ( final Object object ) { return map . containsKey ( object ) ; } @Override
buf . append ( '[' ) ; final Iterator < E > it = uniqueSet () . iterator () ; while ( it . hasNext () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] final Object current = it . next () ; final int count = getCount ( current ) ;
final boolean added = add ( i . next () ) ; changed = changed || added ; MST[InlineConstantMutator]MSP[] } return changed ; } @Override public void clear () { modCount ++ ; map . clear () ; size = 0 ; } @Override
modCount ++ ; if ( nCopies < mut . value ) { mut . value -= nCopies ; size -= nCopies ; MST[rv.AOD2Mutator]MSP[] } else { map . remove ( object ) ; size -= mut . value ; } return true ; } @Override
map . put ( obj , new MutableInteger ( count ) ) ; MST[ArgumentPropagationMutator]MSP[] size += count ; } } @Override public boolean equals ( final Object object ) { if ( object == this ) { return true ; } if ( object instanceof Bag == false ) {
canRemove = false ; } @Override public boolean add ( final E object ) { return add ( object , 1 ) ; } @Override public boolean add ( final E object , final int nCopies ) { modCount ++ ; MST[rv.UOI4Mutator]MSP[] if ( nCopies > 0 ) {
modCount ++ ; if ( nCopies < mut . value ) { mut . value -= nCopies ; size -= nCopies ; } else { map . remove ( object ) ; size -= mut . value ; } return true ; MST[rv.CRCR3Mutator]MSP[] } @Override
final MutableInteger count = map . get ( object ) ; if ( count != null ) { MST[rv.ROR5Mutator]MSP[] return count . value ; } return 0 ; } @Override public boolean contains ( final Object object ) { return map . containsKey ( object ) ; } @Override
int i = 0 ; final Iterator < E > it = map . keySet () . iterator () ; while ( it . hasNext () ) { MST[rv.ROR1Mutator]MSP[] final E current = it . next () ;
int i = 0 ; final Iterator < E > it = map . keySet () . iterator () ; while ( it . hasNext () ) { MST[rv.ROR3Mutator]MSP[] final E current = it . next () ;
canRemove = false ; } @Override public boolean add ( final E object ) { return add ( object , 1 ) ; } @Override public boolean add ( final E object , final int nCopies ) { modCount ++ ; if ( nCopies > 0 ) { MST[NegateConditionalsMutator]MSP[]
final boolean added = add ( i . next () ) ; changed = changed || added ; MST[rv.ROR2Mutator]MSP[] } return changed ; } @Override public void clear () { modCount ++ ; map . clear () ; size = 0 ; } @Override
final MutableInteger mut = map . get ( object ) ; size += nCopies ; MST[rv.AOR4Mutator]MSP[] if ( mut == null ) { map . put ( object , new MutableInteger ( nCopies ) ) ; return true ; } mut . value += nCopies ; return false ; }
final boolean added = add ( i . next () ) ; changed = changed || added ; } return changed ; } @Override public void clear () { modCount ++ ; MST[rv.AOR4Mutator]MSP[] map . clear () ; size = 0 ; } @Override
final MutableInteger mut = map . get ( object ) ; size += nCopies ; MST[rv.UOI1Mutator]MSP[] if ( mut == null ) { map . put ( object , new MutableInteger ( nCopies ) ) ; return true ; } mut . value += nCopies ; return false ; }
int i = 0 ; MST[rv.CRCR1Mutator]MSP[] final Iterator < E > it = map . keySet () . iterator () ; while ( it . hasNext () ) { final E current = it . next () ;
buf . append ( count ) ; buf . append ( ':' ) ; buf . append ( current ) ; if ( it . hasNext () ) { buf . append ( ',' ) ; } } buf . append ( ']' ) ; MST[rv.CRCR4Mutator]MSP[]
for ( int index = getCount ( current ) ; index > 0 ; index -- ) { MST[rv.UOI3Mutator]MSP[] result [ i ++ ] = current ; } } return result ; } @Override public < T > T [] toArray ( T [] array ) {
int i = 0 ; MST[rv.CRCR3Mutator]MSP[] final Iterator < E > it = map . keySet () . iterator () ; while ( it . hasNext () ) { final E current = it . next () ;
buf . append ( '[' ) ; MST[InlineConstantMutator]MSP[] final Iterator < E > it = uniqueSet () . iterator () ; while ( it . hasNext () ) { final Object current = it . next () ; final int count = getCount ( current ) ;
final int entrySize = in . readInt () ; for ( int i = 0 ; i < entrySize ; i ++ ) { MST[rv.UOI2Mutator]MSP[] @SuppressWarnings ( lr_1 ) final E obj = ( E ) in . readObject () ; final int count = in . readInt () ;
for ( int index = getCount ( current ) ; index > 0 ; index -- ) { MST[rv.ROR1Mutator]MSP[] @SuppressWarnings ( lr_1 ) final T unchecked = ( T ) current ; array [ i ++ ] = unchecked ; } } while ( i < array . length ) {
buf . append ( count ) ; buf . append ( ':' ) ; buf . append ( current ) ; if ( it . hasNext () ) { MST[rv.ROR5Mutator]MSP[] buf . append ( ',' ) ; } } buf . append ( ']' ) ;
modCount ++ ; if ( nCopies < mut . value ) { mut . value -= nCopies ; MST[MathMutator]MSP[] size -= nCopies ; } else { map . remove ( object ) ; size -= mut . value ; } return true ; } @Override
final boolean added = add ( i . next () ) ; changed = changed || added ; MST[rv.UOI1Mutator]MSP[] } return changed ; } @Override public void clear () { modCount ++ ; map . clear () ; size = 0 ; } @Override
modCount ++ ; if ( nCopies < mut . value ) { mut . value -= nCopies ; MST[rv.UOI3Mutator]MSP[] size -= nCopies ; } else { map . remove ( object ) ; size -= mut . value ; } return true ; } @Override
int i = 0 ; final Iterator < E > it = map . keySet () . iterator () ; MST[NonVoidMethodCallMutator]MSP[] while ( it . hasNext () ) { final E current = it . next () ;
return false ; } final Bag < ? > other = ( Bag < ? > ) object ; if ( other . size () != size () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return false ; } for ( final E element : map . keySet () ) {
final boolean added = add ( i . next () ) ; changed = changed || added ; } return changed ; MST[rv.UOI2Mutator]MSP[] } @Override public void clear () { modCount ++ ; map . clear () ; size = 0 ; } @Override
modCount ++ ; if ( nCopies < mut . value ) { mut . value -= nCopies ; size -= nCopies ; MST[rv.AOR4Mutator]MSP[] } else { map . remove ( object ) ; size -= mut . value ; } return true ; } @Override
canRemove = false ; } @Override public boolean add ( final E object ) { return add ( object , 1 ) ; } @Override public boolean add ( final E object , final int nCopies ) { modCount ++ ; MST[rv.AOR3Mutator]MSP[] if ( nCopies > 0 ) {
buf . append ( count ) ; MST[rv.UOI2Mutator]MSP[] buf . append ( ':' ) ; buf . append ( current ) ; if ( it . hasNext () ) { buf . append ( ',' ) ; } } buf . append ( ']' ) ;
protected Map < E , MutableInteger > getMap () { return map ; } @Override public int size () { return size ; MST[rv.UOI1Mutator]MSP[] } @Override public boolean isEmpty () { return map . isEmpty () ; } @Override public int getCount ( final Object object ) {
modCount ++ ; if ( nCopies < mut . value ) { mut . value -= nCopies ; MST[experimental.MemberVariableMutator]MSP[] size -= nCopies ; } else { map . remove ( object ) ; size -= mut . value ; } return true ; } @Override
map . put ( obj , new MutableInteger ( count ) ) ; size += count ; MST[rv.UOI4Mutator]MSP[] } } @Override public boolean equals ( final Object object ) { if ( object == this ) { return true ; } if ( object instanceof Bag == false ) {
final MutableInteger mut = map . get ( object ) ; size += nCopies ; if ( mut == null ) { map . put ( object , new MutableInteger ( nCopies ) ) ; MST[ConstructorCallMutator]MSP[] return true ; } mut . value += nCopies ; return false ; }
modCount ++ ; if ( nCopies < mut . value ) { MST[rv.ROR2Mutator]MSP[] mut . value -= nCopies ; size -= nCopies ; } else { map . remove ( object ) ; size -= mut . value ; } return true ; } @Override
modCount ++ ; if ( nCopies < mut . value ) { MST[rv.UOI1Mutator]MSP[] mut . value -= nCopies ; size -= nCopies ; } else { map . remove ( object ) ; size -= mut . value ; } return true ; } @Override
} @Override public boolean remove ( final Object object , final int nCopies ) { final MutableInteger mut = map . get ( object ) ; if ( mut == null ) { return false ; MST[BooleanTrueReturnValsMutator]MSP[] } if ( nCopies <= 0 ) { return false ; }
final int size = size () ; if ( array . length < size ) { MST[rv.ROR3Mutator]MSP[] @SuppressWarnings ( lr_1 ) final T [] unchecked = ( T [] ) Array . newInstance ( array . getClass () . getComponentType () , size ) ; array = unchecked ; }
for ( int index = getCount ( current ) ; index > 0 ; index -- ) { result [ i ++ ] = current ; } } return result ; MST[NullReturnValsMutator]MSP[] } @Override public < T > T [] toArray ( T [] array ) {
final MutableInteger mut = map . get ( object ) ; size += nCopies ; if ( mut == null ) { map . put ( object , new MutableInteger ( nCopies ) ) ; return true ; } mut . value += nCopies ; return false ; MST[rv.CRCR6Mutator]MSP[] }
canRemove = false ; } @Override public boolean add ( final E object ) { return add ( object , 1 ) ; } @Override public boolean add ( final E object , final int nCopies ) { modCount ++ ; if ( nCopies > 0 ) { MST[rv.UOI1Mutator]MSP[]
map . put ( obj , new MutableInteger ( count ) ) ; size += count ; } } @Override public boolean equals ( final Object object ) { if ( object == this ) { return true ; } if ( object instanceof Bag == false ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
final Object [] result = new Object [ size () ] ; int i = 0 ; final Iterator < E > it = map . keySet () . iterator () ; MST[NonVoidMethodCallMutator]MSP[] while ( it . hasNext () ) { final E current = it . next () ;
final Object [] result = new Object [ size () ] ; int i = 0 ; MST[rv.CRCR6Mutator]MSP[] final Iterator < E > it = map . keySet () . iterator () ; while ( it . hasNext () ) { final E current = it . next () ;
final int entrySize = in . readInt () ; for ( int i = 0 ; i < entrySize ; i ++ ) { MST[NegateConditionalsMutator]MSP[] @SuppressWarnings ( lr_1 ) final E obj = ( E ) in . readObject () ; final int count = in . readInt () ;
final int entrySize = in . readInt () ; for ( int i = 0 ; i < entrySize ; i ++ ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[] @SuppressWarnings ( lr_1 ) final E obj = ( E ) in . readObject () ; final int count = in . readInt () ;
map . put ( obj , new MutableInteger ( count ) ) ; MST[rv.UOI2Mutator]MSP[] size += count ; } } @Override public boolean equals ( final Object object ) { if ( object == this ) { return true ; } if ( object instanceof Bag == false ) {
canRemove = false ; } @Override public boolean add ( final E object ) { return add ( object , 1 ) ; } @Override public boolean add ( final E object , final int nCopies ) { modCount ++ ; MST[rv.AOD1Mutator]MSP[] if ( nCopies > 0 ) {
buf . append ( '[' ) ; MST[NonVoidMethodCallMutator]MSP[] final Iterator < E > it = uniqueSet () . iterator () ; while ( it . hasNext () ) { final Object current = it . next () ; final int count = getCount ( current ) ;
if ( other . getCount ( element ) != getCount ( element ) ) { return false ; } } return true ; } @Override public int hashCode () { int total = 0 ; MST[InlineConstantMutator]MSP[]
modCount ++ ; MST[rv.CRCR4Mutator]MSP[] if ( nCopies < mut . value ) { mut . value -= nCopies ; size -= nCopies ; } else { map . remove ( object ) ; size -= mut . value ; } return true ; } @Override
final int size = size () ; if ( array . length < size ) { @SuppressWarnings ( lr_1 ) final T [] unchecked = ( T [] ) Array . newInstance ( array . getClass () . getComponentType () , size ) ; MST[NonVoidMethodCallMutator]MSP[] array = unchecked ; }
buf . append ( count ) ; buf . append ( ':' ) ; buf . append ( current ) ; MST[experimental.NakedReceiverMutator]MSP[] if ( it . hasNext () ) { buf . append ( ',' ) ; } } buf . append ( ']' ) ;
protected void doWriteObject ( final ObjectOutputStream out ) throws IOException { out . writeInt ( map . size () ) ; for ( final Entry < E , MutableInteger > entry : map . entrySet () ) { out . writeObject ( entry . getKey () ) ; MST[VoidMethodCallMutator]MSP[]
protected Map < E , MutableInteger > getMap () { return map ; } @Override public int size () { return size ; } @Override public boolean isEmpty () { return map . isEmpty () ; MST[BooleanTrueReturnValsMutator]MSP[] } @Override public int getCount ( final Object object ) {
for ( int index = getCount ( current ) ; index > 0 ; index -- ) { MST[IncrementsMutator]MSP[] @SuppressWarnings ( lr_1 ) final T unchecked = ( T ) current ; array [ i ++ ] = unchecked ; } } while ( i < array . length ) {
map . put ( obj , new MutableInteger ( count ) ) ; MST[NonVoidMethodCallMutator]MSP[] size += count ; } } @Override public boolean equals ( final Object object ) { if ( object == this ) { return true ; } if ( object instanceof Bag == false ) {
final Object [] result = new Object [ size () ] ; int i = 0 ; MST[rv.CRCR1Mutator]MSP[] final Iterator < E > it = map . keySet () . iterator () ; while ( it . hasNext () ) { final E current = it . next () ;
final Object [] result = new Object [ size () ] ; int i = 0 ; final Iterator < E > it = map . keySet () . iterator () ; while ( it . hasNext () ) { MST[rv.ROR1Mutator]MSP[] final E current = it . next () ;
total += ( element == null ? 0 : element . hashCode () ) ^ count . value ; } return total ; MST[rv.UOI3Mutator]MSP[] } @Override public String toString () { if ( size () == 0 ) { return lr_2 ; } final StringBuilder buf = new StringBuilder () ;
buf . append ( count ) ; buf . append ( ':' ) ; buf . append ( current ) ; if ( it . hasNext () ) { MST[NegateConditionalsMutator]MSP[] buf . append ( ',' ) ; } } buf . append ( ']' ) ;
for ( int index = getCount ( current ) ; index > 0 ; index -- ) { MST[rv.ABSMutator]MSP[] result [ i ++ ] = current ; } } return result ; } @Override public < T > T [] toArray ( T [] array ) {
} @Override public boolean remove ( final Object object , final int nCopies ) { final MutableInteger mut = map . get ( object ) ; if ( mut == null ) { return false ; } if ( nCopies <= 0 ) { MST[rv.ROR2Mutator]MSP[] return false ; }
final MutableInteger mut = map . get ( object ) ; size += nCopies ; if ( mut == null ) { map . put ( object , new MutableInteger ( nCopies ) ) ; return true ; } mut . value += nCopies ; return false ; MST[rv.CRCR1Mutator]MSP[] }
total += ( element == null ? 0 : element . hashCode () ) ^ count . value ; } return total ; } @Override public String toString () { if ( size () == 0 ) { MST[NonVoidMethodCallMutator]MSP[] return lr_2 ; } final StringBuilder buf = new StringBuilder () ;
modCount ++ ; if ( nCopies < mut . value ) { mut . value -= nCopies ; MST[rv.AOR2Mutator]MSP[] size -= nCopies ; } else { map . remove ( object ) ; size -= mut . value ; } return true ; } @Override
final MutableInteger count = map . get ( object ) ; if ( count != null ) { return count . value ; MST[PrimitiveReturnsMutator]MSP[] } return 0 ; } @Override public boolean contains ( final Object object ) { return map . containsKey ( object ) ; } @Override
} @Override public boolean remove ( final Object object , final int nCopies ) { final MutableInteger mut = map . get ( object ) ; if ( mut == null ) { MST[NegateConditionalsMutator]MSP[] return false ; } if ( nCopies <= 0 ) { return false ; }
buf . append ( count ) ; buf . append ( ':' ) ; buf . append ( current ) ; if ( it . hasNext () ) { MST[rv.ROR4Mutator]MSP[] buf . append ( ',' ) ; } } buf . append ( ']' ) ;
array [ i ++ ] = null ; MST[rv.UOI4Mutator]MSP[] } return array ; } @Override public Set < E > uniqueSet () { if ( uniqueSet == null ) { uniqueSet = UnmodifiableSet . <E > unmodifiableSet ( map . keySet () ) ; } return uniqueSet ; }
buf . append ( '[' ) ; final Iterator < E > it = uniqueSet () . iterator () ; while ( it . hasNext () ) { MST[NegateConditionalsMutator]MSP[] final Object current = it . next () ; final int count = getCount ( current ) ;
final MutableInteger count = map . get ( object ) ; if ( count != null ) { MST[NegateConditionalsMutator]MSP[] return count . value ; } return 0 ; } @Override public boolean contains ( final Object object ) { return map . containsKey ( object ) ; } @Override
final int entrySize = in . readInt () ; for ( int i = 0 ; i < entrySize ; i ++ ) { MST[rv.ROR4Mutator]MSP[] @SuppressWarnings ( lr_1 ) final E obj = ( E ) in . readObject () ; final int count = in . readInt () ;
canRemove = false ; } @Override public boolean add ( final E object ) { return add ( object , 1 ) ; } @Override public boolean add ( final E object , final int nCopies ) { modCount ++ ; MST[rv.ABSMutator]MSP[] if ( nCopies > 0 ) {
map . put ( obj , new MutableInteger ( count ) ) ; size += count ; } } @Override public boolean equals ( final Object object ) { if ( object == this ) { return true ; } if ( object instanceof Bag == false ) { MST[NegateConditionalsMutator]MSP[]
final MutableInteger mut = map . get ( object ) ; size += nCopies ; if ( mut == null ) { map . put ( object , new MutableInteger ( nCopies ) ) ; return true ; } mut . value += nCopies ; MST[rv.UOI4Mutator]MSP[] return false ; }
for ( int index = getCount ( current ) ; index > 0 ; index -- ) { MST[rv.ROR1Mutator]MSP[] result [ i ++ ] = current ; } } return result ; } @Override public < T > T [] toArray ( T [] array ) {
final int entrySize = in . readInt () ; for ( int i = 0 ; i < entrySize ; i ++ ) { MST[rv.CRCR1Mutator]MSP[] @SuppressWarnings ( lr_1 ) final E obj = ( E ) in . readObject () ; final int count = in . readInt () ;
final MutableInteger mut = map . get ( object ) ; size += nCopies ; MST[rv.AOD2Mutator]MSP[] if ( mut == null ) { map . put ( object , new MutableInteger ( nCopies ) ) ; return true ; } mut . value += nCopies ; return false ; }
return false ; } final Bag < ? > other = ( Bag < ? > ) object ; if ( other . size () != size () ) { MST[NegateConditionalsMutator]MSP[] return false ; } for ( final E element : map . keySet () ) {
canRemove = false ; } @Override public boolean add ( final E object ) { return add ( object , 1 ) ; MST[rv.CRCR6Mutator]MSP[] } @Override public boolean add ( final E object , final int nCopies ) { modCount ++ ; if ( nCopies > 0 ) {
modCount ++ ; MST[rv.AOR3Mutator]MSP[] if ( nCopies < mut . value ) { mut . value -= nCopies ; size -= nCopies ; } else { map . remove ( object ) ; size -= mut . value ; } return true ; } @Override
final boolean changed = remove ( i . next () , 1 ) ; result = result || changed ; } } return result ; } @Override public boolean retainAll ( final Collection < ? > coll ) { if ( coll instanceof Bag ) { MST[rv.ROR4Mutator]MSP[]
map . put ( obj , new MutableInteger ( count ) ) ; size += count ; } } @Override public boolean equals ( final Object object ) { if ( object == this ) { return true ; MST[rv.CRCR6Mutator]MSP[] } if ( object instanceof Bag == false ) {
protected void doWriteObject ( final ObjectOutputStream out ) throws IOException { out . writeInt ( map . size () ) ; for ( final Entry < E , MutableInteger > entry : map . entrySet () ) { MST[NonVoidMethodCallMutator]MSP[] out . writeObject ( entry . getKey () ) ;
return false ; } @Override public boolean addAll ( final Collection < ? extends E > coll ) { boolean changed = false ; final Iterator < ? extends E > i = coll . iterator () ; while ( i . hasNext () ) { MST[rv.ROR4Mutator]MSP[]
buf . append ( count ) ; buf . append ( ':' ) ; buf . append ( current ) ; if ( it . hasNext () ) { buf . append ( ',' ) ; } } buf . append ( ']' ) ; MST[rv.CRCR3Mutator]MSP[]
return false ; MST[InlineConstantMutator]MSP[] } @Override public boolean addAll ( final Collection < ? extends E > coll ) { boolean changed = false ; final Iterator < ? extends E > i = coll . iterator () ; while ( i . hasNext () ) {
final boolean added = add ( i . next () ) ; changed = changed || added ; } return changed ; } @Override public void clear () { modCount ++ ; MST[rv.AOD2Mutator]MSP[] map . clear () ; size = 0 ; } @Override
final boolean added = add ( i . next () ) ; changed = changed || added ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] } return changed ; } @Override public void clear () { modCount ++ ; map . clear () ; size = 0 ; } @Override
final int entrySize = in . readInt () ; for ( int i = 0 ; i < entrySize ; i ++ ) { MST[rv.UOI3Mutator]MSP[] @SuppressWarnings ( lr_1 ) final E obj = ( E ) in . readObject () ; final int count = in . readInt () ;
final boolean changed = remove ( i . next () , 1 ) ; result = result || changed ; } } return result ; } @Override public boolean retainAll ( final Collection < ? > coll ) { if ( coll instanceof Bag ) { MST[rv.ROR1Mutator]MSP[]
modCount ++ ; if ( nCopies < mut . value ) { mut . value -= nCopies ; size -= nCopies ; } else { map . remove ( object ) ; size -= mut . value ; } return true ; MST[BooleanFalseReturnValsMutator]MSP[] } @Override
out . writeInt ( entry . getValue () . value ) ; MST[rv.UOI3Mutator]MSP[] } } protected void doReadObject ( final Map < E , MutableInteger > map , final ObjectInputStream in ) throws IOException , ClassNotFoundException { this . map = map ;
modCount ++ ; if ( nCopies < mut . value ) { mut . value -= nCopies ; size -= nCopies ; } else { map . remove ( object ) ; size -= mut . value ; MST[rv.ABSMutator]MSP[] } return true ; } @Override
protected Map < E , MutableInteger > getMap () { return map ; MST[NullReturnValsMutator]MSP[] } @Override public int size () { return size ; } @Override public boolean isEmpty () { return map . isEmpty () ; } @Override public int getCount ( final Object object ) {
if ( getCount ( current ) < other . getCount ( current ) ) { return false ; } } return true ; } @Override public Iterator < E > iterator () { return new BagIterator <> ( this ) ; MST[ReturnValsMutator]MSP[] } @Override public boolean hasNext () {
final MutableInteger mut = map . get ( object ) ; size += nCopies ; if ( mut == null ) { map . put ( object , new MutableInteger ( nCopies ) ) ; return true ; } mut . value += nCopies ; MST[rv.AOR2Mutator]MSP[] return false ; }
return false ; } @Override public boolean addAll ( final Collection < ? extends E > coll ) { boolean changed = false ; MST[InlineConstantMutator]MSP[] final Iterator < ? extends E > i = coll . iterator () ; while ( i . hasNext () ) {
map . put ( obj , new MutableInteger ( count ) ) ; size += count ; } } @Override public boolean equals ( final Object object ) { if ( object == this ) { MST[rv.ROR5Mutator]MSP[] return true ; } if ( object instanceof Bag == false ) {
modCount ++ ; if ( nCopies < mut . value ) { mut . value -= nCopies ; size -= nCopies ; MST[rv.UOI2Mutator]MSP[] } else { map . remove ( object ) ; size -= mut . value ; } return true ; } @Override
modCount ++ ; if ( nCopies < mut . value ) { mut . value -= nCopies ; size -= nCopies ; } else { map . remove ( object ) ; size -= mut . value ; } return true ; MST[rv.CRCR4Mutator]MSP[] } @Override
final MutableInteger count = map . get ( object ) ; if ( count != null ) { return count . value ; } return 0 ; } @Override public boolean contains ( final Object object ) { return map . containsKey ( object ) ; MST[BooleanFalseReturnValsMutator]MSP[] } @Override
final MutableInteger mut = map . get ( object ) ; size += nCopies ; if ( mut == null ) { map . put ( object , new MutableInteger ( nCopies ) ) ; MST[NonVoidMethodCallMutator]MSP[] return true ; } mut . value += nCopies ; return false ; }
modCount ++ ; if ( nCopies < mut . value ) { mut . value -= nCopies ; size -= nCopies ; } else { map . remove ( object ) ; size -= mut . value ; MST[rv.AOR3Mutator]MSP[] } return true ; } @Override
map . put ( obj , new MutableInteger ( count ) ) ; size += count ; } } @Override public boolean equals ( final Object object ) { if ( object == this ) { return true ; MST[rv.CRCR5Mutator]MSP[] } if ( object instanceof Bag == false ) {
total += ( element == null ? 0 : element . hashCode () ) ^ count . value ; } return total ; } @Override public String toString () { if ( size () == 0 ) { MST[NegateConditionalsMutator]MSP[] return lr_2 ; } final StringBuilder buf = new StringBuilder () ;
final boolean added = add ( i . next () ) ; changed = changed || added ; } return changed ; } @Override public void clear () { modCount ++ ; map . clear () ; size = 0 ; MST[rv.CRCR3Mutator]MSP[] } @Override
} @Override public boolean remove ( final Object object , final int nCopies ) { final MutableInteger mut = map . get ( object ) ; MST[NonVoidMethodCallMutator]MSP[] if ( mut == null ) { return false ; } if ( nCopies <= 0 ) { return false ; }
canRemove = false ; } @Override public boolean add ( final E object ) { return add ( object , 1 ) ; } @Override public boolean add ( final E object , final int nCopies ) { modCount ++ ; if ( nCopies > 0 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[]
modCount ++ ; MST[rv.AOR1Mutator]MSP[] if ( nCopies < mut . value ) { mut . value -= nCopies ; size -= nCopies ; } else { map . remove ( object ) ; size -= mut . value ; } return true ; } @Override
map . put ( obj , new MutableInteger ( count ) ) ; size += count ; } } @Override public boolean equals ( final Object object ) { if ( object == this ) { MST[NegateConditionalsMutator]MSP[] return true ; } if ( object instanceof Bag == false ) {
final int size = size () ; if ( array . length < size ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] @SuppressWarnings ( lr_1 ) final T [] unchecked = ( T [] ) Array . newInstance ( array . getClass () . getComponentType () , size ) ; array = unchecked ; }
protected Map < E , MutableInteger > getMap () { return map ; } @Override public int size () { return size ; } @Override public boolean isEmpty () { return map . isEmpty () ; MST[NonVoidMethodCallMutator]MSP[] } @Override public int getCount ( final Object object ) {
for ( int index = getCount ( current ) ; index > 0 ; index -- ) { MST[ConditionalsBoundaryMutator]MSP[] @SuppressWarnings ( lr_1 ) final T unchecked = ( T ) current ; array [ i ++ ] = unchecked ; } } while ( i < array . length ) {
final MutableInteger mut = map . get ( object ) ; size += nCopies ; if ( mut == null ) { map . put ( object , new MutableInteger ( nCopies ) ) ; return true ; } mut . value += nCopies ; MST[experimental.MemberVariableMutator]MSP[] return false ; }
final MutableInteger count = map . get ( object ) ; if ( count != null ) { return count . value ; } return 0 ; MST[ReturnValsMutator]MSP[] } @Override public boolean contains ( final Object object ) { return map . containsKey ( object ) ; } @Override
out . writeInt ( entry . getValue () . value ) ; MST[NonVoidMethodCallMutator]MSP[] } } protected void doReadObject ( final Map < E , MutableInteger > map , final ObjectInputStream in ) throws IOException , ClassNotFoundException { this . map = map ;
if ( other . getCount ( element ) != getCount ( element ) ) { return false ; } } return true ; MST[ReturnValsMutator]MSP[] } @Override public int hashCode () { int total = 0 ;
final boolean added = add ( i . next () ) ; changed = changed || added ; MST[rv.ROR1Mutator]MSP[] } return changed ; } @Override public void clear () { modCount ++ ; map . clear () ; size = 0 ; } @Override
modCount ++ ; MST[rv.CRCR5Mutator]MSP[] if ( nCopies < mut . value ) { mut . value -= nCopies ; size -= nCopies ; } else { map . remove ( object ) ; size -= mut . value ; } return true ; } @Override
array [ i ++ ] = null ; MST[rv.ABSMutator]MSP[] } return array ; } @Override public Set < E > uniqueSet () { if ( uniqueSet == null ) { uniqueSet = UnmodifiableSet . <E > unmodifiableSet ( map . keySet () ) ; } return uniqueSet ; }
final Object [] result = new Object [ size () ] ; int i = 0 ; final Iterator < E > it = map . keySet () . iterator () ; while ( it . hasNext () ) { MST[NonVoidMethodCallMutator]MSP[] final E current = it . next () ;
array [ i ++ ] = null ; } return array ; } @Override public Set < E > uniqueSet () { if ( uniqueSet == null ) { uniqueSet = UnmodifiableSet . <E > unmodifiableSet ( map . keySet () ) ; MST[NonVoidMethodCallMutator]MSP[] } return uniqueSet ; }
map . put ( obj , new MutableInteger ( count ) ) ; size += count ; MST[experimental.MemberVariableMutator]MSP[] } } @Override public boolean equals ( final Object object ) { if ( object == this ) { return true ; } if ( object instanceof Bag == false ) {
public boolean removeAll ( final Collection < ? > coll ) { boolean result = false ; MST[rv.CRCR5Mutator]MSP[] if ( coll != null ) { final Iterator < ? > i = coll . iterator () ; while ( i . hasNext () ) {
final MutableInteger mut = map . get ( object ) ; size += nCopies ; if ( mut == null ) { map . put ( object , new MutableInteger ( nCopies ) ) ; return true ; } mut . value += nCopies ; return false ; MST[BooleanTrueReturnValsMutator]MSP[] }
} @Override public boolean remove ( final Object object , final int nCopies ) { final MutableInteger mut = map . get ( object ) ; if ( mut == null ) { MST[rv.ROR5Mutator]MSP[] return false ; } if ( nCopies <= 0 ) { return false ; }
final int entrySize = in . readInt () ; for ( int i = 0 ; i < entrySize ; i ++ ) { MST[InlineConstantMutator]MSP[] @SuppressWarnings ( lr_1 ) final E obj = ( E ) in . readObject () ; final int count = in . readInt () ;
map . put ( obj , new MutableInteger ( count ) ) ; MST[rv.UOI4Mutator]MSP[] size += count ; } } @Override public boolean equals ( final Object object ) { if ( object == this ) { return true ; } if ( object instanceof Bag == false ) {
return false ; } @Override public boolean addAll ( final Collection < ? extends E > coll ) { boolean changed = false ; MST[rv.CRCR3Mutator]MSP[] final Iterator < ? extends E > i = coll . iterator () ; while ( i . hasNext () ) {
modCount ++ ; if ( nCopies < mut . value ) { mut . value -= nCopies ; size -= nCopies ; } else { map . remove ( object ) ; size -= mut . value ; MST[rv.AOD1Mutator]MSP[] } return true ; } @Override
map . put ( obj , new MutableInteger ( count ) ) ; size += count ; } } @Override public boolean equals ( final Object object ) { if ( object == this ) { return true ; } if ( object instanceof Bag == false ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
return false ; } @Override public boolean addAll ( final Collection < ? extends E > coll ) { boolean changed = false ; MST[rv.CRCR6Mutator]MSP[] final Iterator < ? extends E > i = coll . iterator () ; while ( i . hasNext () ) {
} @Override public boolean remove ( final Object object , final int nCopies ) { final MutableInteger mut = map . get ( object ) ; if ( mut == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return false ; } if ( nCopies <= 0 ) { return false ; }
} @Override public boolean remove ( final Object object , final int nCopies ) { final MutableInteger mut = map . get ( object ) ; if ( mut == null ) { return false ; MST[rv.CRCR5Mutator]MSP[] } if ( nCopies <= 0 ) { return false ; }
map . put ( obj , new MutableInteger ( count ) ) ; size += count ; MST[rv.UOI1Mutator]MSP[] } } @Override public boolean equals ( final Object object ) { if ( object == this ) { return true ; } if ( object instanceof Bag == false ) {
buf . append ( count ) ; MST[rv.UOI3Mutator]MSP[] buf . append ( ':' ) ; buf . append ( current ) ; if ( it . hasNext () ) { buf . append ( ',' ) ; } } buf . append ( ']' ) ;
map . put ( obj , new MutableInteger ( count ) ) ; size += count ; MST[rv.ABSMutator]MSP[] } } @Override public boolean equals ( final Object object ) { if ( object == this ) { return true ; } if ( object instanceof Bag == false ) {
final boolean added = add ( i . next () ) ; MST[NonVoidMethodCallMutator]MSP[] changed = changed || added ; } return changed ; } @Override public void clear () { modCount ++ ; map . clear () ; size = 0 ; } @Override
buf . append ( count ) ; buf . append ( ':' ) ; buf . append ( current ) ; if ( it . hasNext () ) { buf . append ( ',' ) ; MST[rv.CRCR1Mutator]MSP[] } } buf . append ( ']' ) ;
final boolean added = add ( i . next () ) ; changed = changed || added ; } return changed ; } @Override public void clear () { modCount ++ ; map . clear () ; size = 0 ; MST[InlineConstantMutator]MSP[] } @Override
for ( int index = getCount ( current ) ; index > 0 ; index -- ) { result [ i ++ ] = current ; MST[rv.UOI4Mutator]MSP[] } } return result ; } @Override public < T > T [] toArray ( T [] array ) {
final int size = size () ; if ( array . length < size ) { MST[NegateConditionalsMutator]MSP[] @SuppressWarnings ( lr_1 ) final T [] unchecked = ( T [] ) Array . newInstance ( array . getClass () . getComponentType () , size ) ; array = unchecked ; }
buf . append ( count ) ; buf . append ( ':' ) ; buf . append ( current ) ; if ( it . hasNext () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] buf . append ( ',' ) ; } } buf . append ( ']' ) ;
final MutableInteger mut = map . get ( object ) ; size += nCopies ; if ( mut == null ) { map . put ( object , new MutableInteger ( nCopies ) ) ; MST[rv.UOI1Mutator]MSP[] return true ; } mut . value += nCopies ; return false ; }
for ( int index = getCount ( current ) ; index > 0 ; index -- ) { MST[rv.ROR3Mutator]MSP[] @SuppressWarnings ( lr_1 ) final T unchecked = ( T ) current ; array [ i ++ ] = unchecked ; } } while ( i < array . length ) {
return retainAll ( ( Bag < ? > ) coll ) ; } return retainAll ( new HashBag <> ( coll ) ) ; MST[ConstructorCallMutator]MSP[] } boolean retainAll ( final Bag < ? > other ) { boolean result = false ;
return false ; } final Bag < ? > other = ( Bag < ? > ) object ; if ( other . size () != size () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return false ; } for ( final E element : map . keySet () ) {
final MutableInteger mut = map . get ( object ) ; size += nCopies ; if ( mut == null ) { map . put ( object , new MutableInteger ( nCopies ) ) ; return true ; MST[rv.CRCR4Mutator]MSP[] } mut . value += nCopies ; return false ; }
final boolean added = add ( i . next () ) ; changed = changed || added ; } return changed ; } @Override public void clear () { modCount ++ ; MST[rv.CRCR5Mutator]MSP[] map . clear () ; size = 0 ; } @Override
total += ( element == null ? 0 : element . hashCode () ) ^ count . value ; } return total ; } @Override public String toString () { if ( size () == 0 ) { MST[rv.ROR1Mutator]MSP[] return lr_2 ; } final StringBuilder buf = new StringBuilder () ;
public boolean removeAll ( final Collection < ? > coll ) { boolean result = false ; if ( coll != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] final Iterator < ? > i = coll . iterator () ; while ( i . hasNext () ) {
array [ i ++ ] = null ; MST[rv.UOI3Mutator]MSP[] } return array ; } @Override public Set < E > uniqueSet () { if ( uniqueSet == null ) { uniqueSet = UnmodifiableSet . <E > unmodifiableSet ( map . keySet () ) ; } return uniqueSet ; }
final MutableInteger mut = map . get ( object ) ; size += nCopies ; if ( mut == null ) { map . put ( object , new MutableInteger ( nCopies ) ) ; return true ; MST[BooleanFalseReturnValsMutator]MSP[] } mut . value += nCopies ; return false ; }
protected Map < E , MutableInteger > getMap () { return map ; } @Override public int size () { return size ; MST[rv.UOI3Mutator]MSP[] } @Override public boolean isEmpty () { return map . isEmpty () ; } @Override public int getCount ( final Object object ) {
modCount ++ ; if ( nCopies < mut . value ) { mut . value -= nCopies ; size -= nCopies ; MST[rv.ABSMutator]MSP[] } else { map . remove ( object ) ; size -= mut . value ; } return true ; } @Override
buf . append ( count ) ; MST[experimental.NakedReceiverMutator]MSP[] buf . append ( ':' ) ; buf . append ( current ) ; if ( it . hasNext () ) { buf . append ( ',' ) ; } } buf . append ( ']' ) ;
modCount ++ ; if ( nCopies < mut . value ) { mut . value -= nCopies ; size -= nCopies ; MST[rv.UOI1Mutator]MSP[] } else { map . remove ( object ) ; size -= mut . value ; } return true ; } @Override
for ( int index = getCount ( current ) ; index > 0 ; index -- ) { MST[experimental.RemoveIncrementsMutator]MSP[] @SuppressWarnings ( lr_1 ) final T unchecked = ( T ) current ; array [ i ++ ] = unchecked ; } } while ( i < array . length ) {
final boolean added = add ( i . next () ) ; changed = changed || added ; MST[rv.ROR1Mutator]MSP[] } return changed ; } @Override public void clear () { modCount ++ ; map . clear () ; size = 0 ; } @Override
canRemove = false ; } @Override public boolean add ( final E object ) { return add ( object , 1 ) ; MST[BooleanTrueReturnValsMutator]MSP[] } @Override public boolean add ( final E object , final int nCopies ) { modCount ++ ; if ( nCopies > 0 ) {
modCount ++ ; if ( nCopies < mut . value ) { mut . value -= nCopies ; size -= nCopies ; } else { map . remove ( object ) ; size -= mut . value ; MST[rv.UOI1Mutator]MSP[] } return true ; } @Override
final boolean changed = remove ( i . next () , 1 ) ; result = result || changed ; } } return result ; MST[rv.UOI4Mutator]MSP[] } @Override public boolean retainAll ( final Collection < ? > coll ) { if ( coll instanceof Bag ) {
final MutableInteger mut = map . get ( object ) ; size += nCopies ; MST[rv.ABSMutator]MSP[] if ( mut == null ) { map . put ( object , new MutableInteger ( nCopies ) ) ; return true ; } mut . value += nCopies ; return false ; }
final int entrySize = in . readInt () ; for ( int i = 0 ; i < entrySize ; i ++ ) { MST[rv.CRCR5Mutator]MSP[] @SuppressWarnings ( lr_1 ) final E obj = ( E ) in . readObject () ; final int count = in . readInt () ;
final MutableInteger mut = map . get ( object ) ; size += nCopies ; MST[rv.UOI1Mutator]MSP[] if ( mut == null ) { map . put ( object , new MutableInteger ( nCopies ) ) ; return true ; } mut . value += nCopies ; return false ; }
} @Override public boolean remove ( final Object object , final int nCopies ) { final MutableInteger mut = map . get ( object ) ; if ( mut == null ) { return false ; } if ( nCopies <= 0 ) { MST[rv.ROR3Mutator]MSP[] return false ; }
final boolean added = add ( i . next () ) ; changed = changed || added ; } return changed ; } @Override public void clear () { modCount ++ ; map . clear () ; size = 0 ; MST[rv.CRCR6Mutator]MSP[] } @Override
final MutableInteger mut = map . get ( object ) ; size += nCopies ; MST[rv.UOI3Mutator]MSP[] if ( mut == null ) { map . put ( object , new MutableInteger ( nCopies ) ) ; return true ; } mut . value += nCopies ; return false ; }
final MutableInteger mut = map . get ( object ) ; size += nCopies ; MST[MathMutator]MSP[] if ( mut == null ) { map . put ( object , new MutableInteger ( nCopies ) ) ; return true ; } mut . value += nCopies ; return false ; }
canRemove = false ; } @Override public boolean add ( final E object ) { return add ( object , 1 ) ; MST[BooleanFalseReturnValsMutator]MSP[] } @Override public boolean add ( final E object , final int nCopies ) { modCount ++ ; if ( nCopies > 0 ) {
for ( int index = getCount ( current ) ; index > 0 ; index -- ) { MST[NegateConditionalsMutator]MSP[] @SuppressWarnings ( lr_1 ) final T unchecked = ( T ) current ; array [ i ++ ] = unchecked ; } } while ( i < array . length ) {
if ( other . getCount ( element ) != getCount ( element ) ) { return false ; } } return true ; MST[BooleanFalseReturnValsMutator]MSP[] } @Override public int hashCode () { int total = 0 ;
int i = 0 ; final Iterator < E > it = map . keySet () . iterator () ; while ( it . hasNext () ) { MST[rv.ROR5Mutator]MSP[] final E current = it . next () ;
buf . append ( '[' ) ; final Iterator < E > it = uniqueSet () . iterator () ; while ( it . hasNext () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] final Object current = it . next () ; final int count = getCount ( current ) ;
final MutableInteger count = map . get ( object ) ; if ( count != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return count . value ; } return 0 ; } @Override public boolean contains ( final Object object ) { return map . containsKey ( object ) ; } @Override
canRemove = false ; } @Override public boolean add ( final E object ) { return add ( object , 1 ) ; } @Override public boolean add ( final E object , final int nCopies ) { modCount ++ ; MST[rv.UOI2Mutator]MSP[] if ( nCopies > 0 ) {
final boolean added = add ( i . next () ) ; changed = changed || added ; } return changed ; } @Override public void clear () { modCount ++ ; MST[MathMutator]MSP[] map . clear () ; size = 0 ; } @Override
final MutableInteger mut = map . get ( object ) ; size += nCopies ; MST[experimental.MemberVariableMutator]MSP[] if ( mut == null ) { map . put ( object , new MutableInteger ( nCopies ) ) ; return true ; } mut . value += nCopies ; return false ; }
for ( int index = getCount ( current ) ; index > 0 ; index -- ) { MST[rv.UOI1Mutator]MSP[] result [ i ++ ] = current ; } } return result ; } @Override public < T > T [] toArray ( T [] array ) {
int i = 0 ; MST[rv.CRCR5Mutator]MSP[] final Iterator < E > it = map . keySet () . iterator () ; while ( it . hasNext () ) { final E current = it . next () ;
final boolean added = add ( i . next () ) ; changed = changed || added ; MST[rv.ROR4Mutator]MSP[] } return changed ; } @Override public void clear () { modCount ++ ; map . clear () ; size = 0 ; } @Override
final boolean added = add ( i . next () ) ; changed = changed || added ; } return changed ; } @Override public void clear () { modCount ++ ; MST[rv.AOR2Mutator]MSP[] map . clear () ; size = 0 ; } @Override
buf . append ( count ) ; buf . append ( ':' ) ; buf . append ( current ) ; if ( it . hasNext () ) { buf . append ( ',' ) ; } } buf . append ( ']' ) ; MST[rv.CRCR6Mutator]MSP[]
final MutableInteger mut = map . get ( object ) ; size += nCopies ; MST[rv.AOR2Mutator]MSP[] if ( mut == null ) { map . put ( object , new MutableInteger ( nCopies ) ) ; return true ; } mut . value += nCopies ; return false ; }
buf . append ( count ) ; MST[rv.ABSMutator]MSP[] buf . append ( ':' ) ; buf . append ( current ) ; if ( it . hasNext () ) { buf . append ( ',' ) ; } } buf . append ( ']' ) ;
return false ; } @Override public boolean addAll ( final Collection < ? extends E > coll ) { boolean changed = false ; final Iterator < ? extends E > i = coll . iterator () ; while ( i . hasNext () ) { MST[rv.ROR1Mutator]MSP[]
buf . append ( count ) ; buf . append ( ':' ) ; buf . append ( current ) ; if ( it . hasNext () ) { buf . append ( ',' ) ; } } buf . append ( ']' ) ; MST[experimental.NakedReceiverMutator]MSP[]
final boolean added = add ( i . next () ) ; changed = changed || added ; } return changed ; } @Override public void clear () { modCount ++ ; MST[rv.CRCR3Mutator]MSP[] map . clear () ; size = 0 ; } @Override
canRemove = false ; } @Override public boolean add ( final E object ) { return add ( object , 1 ) ; } @Override public boolean add ( final E object , final int nCopies ) { modCount ++ ; if ( nCopies > 0 ) { MST[rv.ROR5Mutator]MSP[]
if ( other . getCount ( element ) != getCount ( element ) ) { MST[NonVoidMethodCallMutator]MSP[] return false ; } } return true ; } @Override public int hashCode () { int total = 0 ;
return false ; MST[rv.CRCR5Mutator]MSP[] } @Override public boolean addAll ( final Collection < ? extends E > coll ) { boolean changed = false ; final Iterator < ? extends E > i = coll . iterator () ; while ( i . hasNext () ) {
for ( int index = getCount ( current ) ; index > 0 ; index -- ) { MST[rv.ROR5Mutator]MSP[] @SuppressWarnings ( lr_1 ) final T unchecked = ( T ) current ; array [ i ++ ] = unchecked ; } } while ( i < array . length ) {
buf . append ( count ) ; buf . append ( ':' ) ; MST[rv.CRCR1Mutator]MSP[] buf . append ( current ) ; if ( it . hasNext () ) { buf . append ( ',' ) ; } } buf . append ( ']' ) ;
final boolean added = add ( i . next () ) ; changed = changed || added ; MST[rv.UOI3Mutator]MSP[] } return changed ; } @Override public void clear () { modCount ++ ; map . clear () ; size = 0 ; } @Override
} @Override public boolean remove ( final Object object , final int nCopies ) { final MutableInteger mut = map . get ( object ) ; if ( mut == null ) { return false ; } if ( nCopies <= 0 ) { MST[ConditionalsBoundaryMutator]MSP[] return false ; }
final int entrySize = in . readInt () ; for ( int i = 0 ; i < entrySize ; i ++ ) { MST[rv.ABSMutator]MSP[] @SuppressWarnings ( lr_1 ) final E obj = ( E ) in . readObject () ; final int count = in . readInt () ;
if ( other . getCount ( element ) != getCount ( element ) ) { return false ; } } return true ; } @Override public int hashCode () { int total = 0 ; MST[rv.CRCR5Mutator]MSP[]
int i = 0 ; final Iterator < E > it = map . keySet () . iterator () ; while ( it . hasNext () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] final E current = it . next () ;
final boolean added = add ( i . next () ) ; changed = changed || added ; } return changed ; } @Override public void clear () { modCount ++ ; MST[experimental.MemberVariableMutator]MSP[] map . clear () ; size = 0 ; } @Override
