final Collection < C > coll = ( Collection < C > ) index . get ( key ) ; return coll == null ? null : coll . iterator () . next () ; MST[NonVoidMethodCallMutator]MSP[S] } @SuppressWarnings ( lr_1 )
boolean changed = false ; for ( final C c : coll ) { changed |= add ( c ) ; } return changed ; MST[BooleanTrueReturnValsMutator]MSP[S] } @Override public void clear () { super . clear () ; index . clear () ; } @SuppressWarnings ( lr_1 ) @Override
addToIndex ( c ) ; } } @SuppressWarnings ( lr_1 ) @Override public boolean remove ( final Object object ) { final boolean removed = super . remove ( object ) ; if ( removed ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] removeFromIndex ( ( C ) object ) ; } return removed ; }
addToIndex ( c ) ; } } @SuppressWarnings ( lr_1 ) @Override public boolean remove ( final Object object ) { final boolean removed = super . remove ( object ) ; if ( removed ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] removeFromIndex ( ( C ) object ) ; } return removed ; }
public boolean removeAll ( final Collection < ? > coll ) { boolean changed = false ; for ( final Object o : coll ) { changed |= remove ( o ) ; } return changed ; MST[rv.UOI1Mutator]MSP[N] } @Override
public boolean removeAll ( final Collection < ? > coll ) { boolean changed = false ; for ( final Object o : coll ) { changed |= remove ( o ) ; } return changed ; MST[rv.UOI3Mutator]MSP[N] } @Override
if ( ! contains ( o ) ) { return false ; MST[rv.CRCR1Mutator]MSP[S] } } return true ; } public C get ( final K key ) { @SuppressWarnings ( lr_1 )
public static < K , C > IndexedCollection < K , C > uniqueIndexedCollection ( final Collection < C > coll , final Transformer < C , K > keyTransformer ) { return new IndexedCollection <> ( coll , keyTransformer , MST[ConstructorCallMutator]MSP[S]
if ( ! contains ( o ) ) { return false ; MST[rv.CRCR3Mutator]MSP[S] } } return true ; } public C get ( final K key ) { @SuppressWarnings ( lr_1 )
while ( it . hasNext () ) { MST[rv.ROR1Mutator]MSP[N] if ( filter . test ( it . next () ) ) { it . remove () ; changed = true ; } } if ( changed ) { reindex () ; } return changed ; } @Override
public boolean removeAll ( final Collection < ? > coll ) { boolean changed = false ; MST[rv.CRCR6Mutator]MSP[N] for ( final Object o : coll ) { changed |= remove ( o ) ; } return changed ; } @Override
boolean changed = false ; for ( final C c : coll ) { changed |= add ( c ) ; MST[rv.UOI4Mutator]MSP[N] } return changed ; } @Override public void clear () { super . clear () ; index . clear () ; } @SuppressWarnings ( lr_1 ) @Override
boolean changed = false ; for ( final C c : coll ) { changed |= add ( c ) ; } return changed ; MST[ReturnValsMutator]MSP[N] } @Override public void clear () { super . clear () ; index . clear () ; } @SuppressWarnings ( lr_1 ) @Override
boolean changed = false ; for ( final C c : coll ) { changed |= add ( c ) ; MST[rv.UOI2Mutator]MSP[N] } return changed ; } @Override public void clear () { super . clear () ; index . clear () ; } @SuppressWarnings ( lr_1 ) @Override
while ( it . hasNext () ) { if ( filter . test ( it . next () ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] it . remove () ; changed = true ; } } if ( changed ) { reindex () ; } return changed ; } @Override
if ( ! contains ( o ) ) { return false ; MST[ReturnValsMutator]MSP[S] } } return true ; } public C get ( final K key ) { @SuppressWarnings ( lr_1 )
public boolean add ( final C object ) { final boolean added = super . add ( object ) ; if ( added ) { MST[rv.ROR4Mutator]MSP[N] addToIndex ( object ) ; } return added ; } @Override public boolean addAll ( final Collection < ? extends C > coll ) {
boolean changed = false ; MST[rv.CRCR6Mutator]MSP[S] for ( final C c : coll ) { changed |= add ( c ) ; } return changed ; } @Override public void clear () { super . clear () ; index . clear () ; } @SuppressWarnings ( lr_1 ) @Override
while ( it . hasNext () ) { MST[rv.ROR5Mutator]MSP[N] if ( filter . test ( it . next () ) ) { it . remove () ; changed = true ; } } if ( changed ) { reindex () ; } return changed ; } @Override
while ( it . hasNext () ) { if ( filter . test ( it . next () ) ) { MST[NegateConditionalsMutator]MSP[N] it . remove () ; changed = true ; } } if ( changed ) { reindex () ; } return changed ; } @Override
public boolean add ( final C object ) { final boolean added = super . add ( object ) ; if ( added ) { MST[rv.UOI1Mutator]MSP[N] addToIndex ( object ) ; } return added ; } @Override public boolean addAll ( final Collection < ? extends C > coll ) {
boolean changed = false ; for ( final C c : coll ) { changed |= add ( c ) ; } return changed ; MST[rv.UOI3Mutator]MSP[N] } @Override public void clear () { super . clear () ; index . clear () ; } @SuppressWarnings ( lr_1 ) @Override
public boolean add ( final C object ) { final boolean added = super . add ( object ) ; if ( added ) { MST[rv.ROR2Mutator]MSP[N] addToIndex ( object ) ; } return added ; } @Override public boolean addAll ( final Collection < ? extends C > coll ) {
final K key = keyTransformer . transform ( object ) ; if ( uniqueIndex && index . containsKey ( key ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] throw new IllegalArgumentException ( lr_2 ) ; } index . put ( key , object ) ; } private void removeFromIndex ( final C object ) {
while ( it . hasNext () ) { MST[rv.ROR3Mutator]MSP[N] if ( filter . test ( it . next () ) ) { it . remove () ; changed = true ; } } if ( changed ) { reindex () ; } return changed ; } @Override
@Override public boolean removeIf ( final Predicate < ? super C > filter ) { if ( Objects . isNull ( filter ) ) { MST[rv.ROR2Mutator]MSP[N] return false ; } boolean changed = false ; final Iterator < C > it = iterator () ;
if ( ! contains ( o ) ) { return false ; MST[rv.CRCR5Mutator]MSP[S] } } return true ; } public C get ( final K key ) { @SuppressWarnings ( lr_1 )
while ( it . hasNext () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] if ( filter . test ( it . next () ) ) { it . remove () ; changed = true ; } } if ( changed ) { reindex () ; } return changed ; } @Override
while ( it . hasNext () ) { if ( filter . test ( it . next () ) ) { it . remove () ; changed = true ; } } if ( changed ) { MST[rv.UOI3Mutator]MSP[N] reindex () ; } return changed ; } @Override
addToIndex ( c ) ; } } @SuppressWarnings ( lr_1 ) @Override public boolean remove ( final Object object ) { final boolean removed = super . remove ( object ) ; if ( removed ) { MST[NegateConditionalsMutator]MSP[S] removeFromIndex ( ( C ) object ) ; } return removed ; }
final K key = keyTransformer . transform ( object ) ; if ( uniqueIndex && index . containsKey ( key ) ) { MST[rv.ROR2Mutator]MSP[N] throw new IllegalArgumentException ( lr_2 ) ; } index . put ( key , object ) ; } private void removeFromIndex ( final C object ) {
final K key = keyTransformer . transform ( object ) ; if ( uniqueIndex && index . containsKey ( key ) ) { MST[rv.ROR4Mutator]MSP[S] throw new IllegalArgumentException ( lr_2 ) ; } index . put ( key , object ) ; } private void removeFromIndex ( final C object ) {
final K key = keyTransformer . transform ( object ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( uniqueIndex && index . containsKey ( key ) ) { throw new IllegalArgumentException ( lr_2 ) ; } index . put ( key , object ) ; } private void removeFromIndex ( final C object ) {
public boolean add ( final C object ) { final boolean added = super . add ( object ) ; if ( added ) { MST[rv.UOI3Mutator]MSP[N] addToIndex ( object ) ; } return added ; } @Override public boolean addAll ( final Collection < ? extends C > coll ) {
final Collection < C > coll = ( Collection < C > ) index . get ( key ) ; return coll == null ? null : coll . iterator () . next () ; MST[ReturnValsMutator]MSP[S] } @SuppressWarnings ( lr_1 )
public static < K , C > IndexedCollection < K , C > uniqueIndexedCollection ( final Collection < C > coll , final Transformer < C , K > keyTransformer ) { return new IndexedCollection <> ( coll , keyTransformer , MST[ReturnValsMutator]MSP[S]
while ( it . hasNext () ) { if ( filter . test ( it . next () ) ) { it . remove () ; changed = true ; } } if ( changed ) { MST[rv.UOI1Mutator]MSP[N] reindex () ; } return changed ; } @Override
if ( ! contains ( o ) ) { return false ; MST[BooleanTrueReturnValsMutator]MSP[S] } } return true ; } public C get ( final K key ) { @SuppressWarnings ( lr_1 )
public boolean removeAll ( final Collection < ? > coll ) { boolean changed = false ; for ( final Object o : coll ) { changed |= remove ( o ) ; } return changed ; MST[ReturnValsMutator]MSP[N] } @Override
addToIndex ( c ) ; } } @SuppressWarnings ( lr_1 ) @Override public boolean remove ( final Object object ) { final boolean removed = super . remove ( object ) ; if ( removed ) { MST[rv.ABSMutator]MSP[N] removeFromIndex ( ( C ) object ) ; } return removed ; }
@Override public boolean removeIf ( final Predicate < ? super C > filter ) { if ( Objects . isNull ( filter ) ) { return false ; MST[rv.CRCR6Mutator]MSP[S] } boolean changed = false ; final Iterator < C > it = iterator () ;
while ( it . hasNext () ) { if ( filter . test ( it . next () ) ) { it . remove () ; changed = true ; MST[rv.CRCR6Mutator]MSP[N] } } if ( changed ) { reindex () ; } return changed ; } @Override
final Collection < C > coll = ( Collection < C > ) index . get ( key ) ; return coll == null ? null : coll . iterator () . next () ; MST[NonVoidMethodCallMutator]MSP[S] } @SuppressWarnings ( lr_1 )
public boolean contains ( final Object object ) { return index . containsKey ( keyTransformer . transform ( ( C ) object ) ) ; MST[BooleanFalseReturnValsMutator]MSP[N] } @Override public boolean containsAll ( final Collection < ? > coll ) { for ( final Object o : coll ) {
while ( it . hasNext () ) { if ( filter . test ( it . next () ) ) { it . remove () ; changed = true ; } } if ( changed ) { reindex () ; } return changed ; MST[rv.UOI3Mutator]MSP[N] } @Override
final K key = keyTransformer . transform ( object ) ; if ( uniqueIndex && index . containsKey ( key ) ) { throw new IllegalArgumentException ( lr_2 ) ; } index . put ( key , object ) ; MST[ArgumentPropagationMutator]MSP[N] } private void removeFromIndex ( final C object ) {
public boolean retainAll ( final Collection < ? > coll ) { final boolean changed = super . retainAll ( coll ) ; if ( changed ) { reindex () ; } return changed ; MST[ReturnValsMutator]MSP[N] } private void addToIndex ( final C object ) {
if ( ! contains ( o ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] return false ; } } return true ; } public C get ( final K key ) { @SuppressWarnings ( lr_1 )
MultiValueMap . <K , C > multiValueMap ( new HashMap < K , Collection < C > > () ) , MST[rv.CRCR6Mutator]MSP[S] true ) ; } public static < K , C > IndexedCollection < K , C > nonUniqueIndexedCollection ( final Collection < C > coll ,
final K key = keyTransformer . transform ( object ) ; if ( uniqueIndex && index . containsKey ( key ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] throw new IllegalArgumentException ( lr_2 ) ; } index . put ( key , object ) ; } private void removeFromIndex ( final C object ) {
MultiValueMap . <K , C > multiValueMap ( new HashMap < K , Collection < C > > () ) , MST[rv.CRCR2Mutator]MSP[S] true ) ; } public static < K , C > IndexedCollection < K , C > nonUniqueIndexedCollection ( final Collection < C > coll ,
boolean changed = false ; for ( final C c : coll ) { changed |= add ( c ) ; MST[NonVoidMethodCallMutator]MSP[N] } return changed ; } @Override public void clear () { super . clear () ; index . clear () ; } @SuppressWarnings ( lr_1 ) @Override
public boolean retainAll ( final Collection < ? > coll ) { final boolean changed = super . retainAll ( coll ) ; if ( changed ) { reindex () ; } return changed ; MST[rv.UOI3Mutator]MSP[N] } private void addToIndex ( final C object ) {
if ( ! contains ( o ) ) { return false ; } } return true ; MST[rv.CRCR5Mutator]MSP[S] } public C get ( final K key ) { @SuppressWarnings ( lr_1 )
if ( ! contains ( o ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] return false ; } } return true ; } public C get ( final K key ) { @SuppressWarnings ( lr_1 )
while ( it . hasNext () ) { if ( filter . test ( it . next () ) ) { it . remove () ; changed = true ; MST[rv.CRCR2Mutator]MSP[N] } } if ( changed ) { reindex () ; } return changed ; } @Override
final K key = keyTransformer . transform ( object ) ; if ( uniqueIndex && index . containsKey ( key ) ) { throw new IllegalArgumentException ( lr_2 ) ; } index . put ( key , object ) ; MST[NonVoidMethodCallMutator]MSP[N] } private void removeFromIndex ( final C object ) {
public boolean contains ( final Object object ) { return index . containsKey ( keyTransformer . transform ( ( C ) object ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } @Override public boolean containsAll ( final Collection < ? > coll ) { for ( final Object o : coll ) {
public boolean removeAll ( final Collection < ? > coll ) { boolean changed = false ; for ( final Object o : coll ) { changed |= remove ( o ) ; } return changed ; MST[BooleanTrueReturnValsMutator]MSP[N] } @Override
addToIndex ( c ) ; } } @SuppressWarnings ( lr_1 ) @Override public boolean remove ( final Object object ) { final boolean removed = super . remove ( object ) ; if ( removed ) { MST[rv.ROR1Mutator]MSP[N] removeFromIndex ( ( C ) object ) ; } return removed ; }
while ( it . hasNext () ) { if ( filter . test ( it . next () ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] it . remove () ; changed = true ; } } if ( changed ) { reindex () ; } return changed ; } @Override
while ( it . hasNext () ) { if ( filter . test ( it . next () ) ) { it . remove () ; changed = true ; } } if ( changed ) { reindex () ; } return changed ; MST[ReturnValsMutator]MSP[N] } @Override
final Transformer < C , K > keyTransformer ) { return new IndexedCollection <> ( coll , keyTransformer , MultiValueMap . <K , C > multiValueMap ( new HashMap < K , Collection < C > > () ) , MST[rv.CRCR6Mutator]MSP[N] false ) ; } @Override
if ( ! contains ( o ) ) { MST[rv.ROR3Mutator]MSP[N] return false ; } } return true ; } public C get ( final K key ) { @SuppressWarnings ( lr_1 )
addToIndex ( c ) ; } } @SuppressWarnings ( lr_1 ) @Override public boolean remove ( final Object object ) { final boolean removed = super . remove ( object ) ; if ( removed ) { removeFromIndex ( ( C ) object ) ; } return removed ; MST[rv.UOI2Mutator]MSP[N] }
final Transformer < C , K > keyTransformer ) { return new IndexedCollection <> ( coll , keyTransformer , MST[NullReturnValsMutator]MSP[N] MultiValueMap . <K , C > multiValueMap ( new HashMap < K , Collection < C > > () ) , false ) ; } @Override
while ( it . hasNext () ) { if ( filter . test ( it . next () ) ) { MST[rv.ROR3Mutator]MSP[N] it . remove () ; changed = true ; } } if ( changed ) { reindex () ; } return changed ; } @Override
while ( it . hasNext () ) { MST[NonVoidMethodCallMutator]MSP[N] if ( filter . test ( it . next () ) ) { it . remove () ; changed = true ; } } if ( changed ) { reindex () ; } return changed ; } @Override
final Collection < C > coll = ( Collection < C > ) index . get ( key ) ; MST[ArgumentPropagationMutator]MSP[S] return coll == null ? null : coll . iterator () . next () ; } @SuppressWarnings ( lr_1 )
addToIndex ( c ) ; } } @SuppressWarnings ( lr_1 ) @Override public boolean remove ( final Object object ) { final boolean removed = super . remove ( object ) ; if ( removed ) { MST[rv.UOI4Mutator]MSP[N] removeFromIndex ( ( C ) object ) ; } return removed ; }
addToIndex ( c ) ; } } @SuppressWarnings ( lr_1 ) @Override public boolean remove ( final Object object ) { final boolean removed = super . remove ( object ) ; if ( removed ) { MST[rv.ROR5Mutator]MSP[S] removeFromIndex ( ( C ) object ) ; } return removed ; }
public boolean removeAll ( final Collection < ? > coll ) { boolean changed = false ; for ( final Object o : coll ) { changed |= remove ( o ) ; MST[rv.UOI4Mutator]MSP[S] } return changed ; } @Override
public boolean retainAll ( final Collection < ? > coll ) { final boolean changed = super . retainAll ( coll ) ; if ( changed ) { MST[rv.UOI3Mutator]MSP[N] reindex () ; } return changed ; } private void addToIndex ( final C object ) {
public boolean add ( final C object ) { final boolean added = super . add ( object ) ; if ( added ) { addToIndex ( object ) ; } return added ; MST[ReturnValsMutator]MSP[N] } @Override public boolean addAll ( final Collection < ? extends C > coll ) {
public boolean add ( final C object ) { final boolean added = super . add ( object ) ; if ( added ) { addToIndex ( object ) ; } return added ; MST[BooleanTrueReturnValsMutator]MSP[N] } @Override public boolean addAll ( final Collection < ? extends C > coll ) {
public boolean retainAll ( final Collection < ? > coll ) { final boolean changed = super . retainAll ( coll ) ; if ( changed ) { MST[rv.UOI1Mutator]MSP[N] reindex () ; } return changed ; } private void addToIndex ( final C object ) {
MultiValueMap . <K , C > multiValueMap ( new HashMap < K , Collection < C > > () ) , MST[NonVoidMethodCallMutator]MSP[S] true ) ; } public static < K , C > IndexedCollection < K , C > nonUniqueIndexedCollection ( final Collection < C > coll ,
if ( ! contains ( o ) ) { MST[NegateConditionalsMutator]MSP[N] return false ; } } return true ; } public C get ( final K key ) { @SuppressWarnings ( lr_1 )
final Transformer < C , K > keyTransformer ) { return new IndexedCollection <> ( coll , keyTransformer , MultiValueMap . <K , C > multiValueMap ( new HashMap < K , Collection < C > > () ) , MST[InlineConstantMutator]MSP[N] false ) ; } @Override
while ( it . hasNext () ) { if ( filter . test ( it . next () ) ) { it . remove () ; changed = true ; } } if ( changed ) { reindex () ; } return changed ; MST[BooleanTrueReturnValsMutator]MSP[N] } @Override
public boolean removeAll ( final Collection < ? > coll ) { boolean changed = false ; for ( final Object o : coll ) { changed |= remove ( o ) ; MST[MathMutator]MSP[N] } return changed ; } @Override
public boolean removeAll ( final Collection < ? > coll ) { boolean changed = false ; for ( final Object o : coll ) { changed |= remove ( o ) ; MST[rv.OBBN1Mutator]MSP[N] } return changed ; } @Override
final Collection < C > coll = ( Collection < C > ) index . get ( key ) ; return coll == null ? null : coll . iterator () . next () ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] } @SuppressWarnings ( lr_1 )
addToIndex ( c ) ; MST[VoidMethodCallMutator]MSP[N] } } @SuppressWarnings ( lr_1 ) @Override public boolean remove ( final Object object ) { final boolean removed = super . remove ( object ) ; if ( removed ) { removeFromIndex ( ( C ) object ) ; } return removed ; }
public boolean removeAll ( final Collection < ? > coll ) { boolean changed = false ; for ( final Object o : coll ) { changed |= remove ( o ) ; MST[rv.OBBN3Mutator]MSP[N] } return changed ; } @Override
public boolean retainAll ( final Collection < ? > coll ) { final boolean changed = super . retainAll ( coll ) ; if ( changed ) { MST[rv.ABSMutator]MSP[N] reindex () ; } return changed ; } private void addToIndex ( final C object ) {
boolean changed = false ; for ( final C c : coll ) { changed |= add ( c ) ; MST[rv.OBBN3Mutator]MSP[N] } return changed ; } @Override public void clear () { super . clear () ; index . clear () ; } @SuppressWarnings ( lr_1 ) @Override
boolean changed = false ; for ( final C c : coll ) { changed |= add ( c ) ; MST[rv.OBBN1Mutator]MSP[S] } return changed ; } @Override public void clear () { super . clear () ; index . clear () ; } @SuppressWarnings ( lr_1 ) @Override
if ( ! contains ( o ) ) { return false ; } } return true ; MST[BooleanFalseReturnValsMutator]MSP[S] } public C get ( final K key ) { @SuppressWarnings ( lr_1 )
final K key = keyTransformer . transform ( object ) ; if ( uniqueIndex && index . containsKey ( key ) ) { MST[rv.ROR1Mutator]MSP[N] throw new IllegalArgumentException ( lr_2 ) ; } index . put ( key , object ) ; } private void removeFromIndex ( final C object ) {
while ( it . hasNext () ) { if ( filter . test ( it . next () ) ) { it . remove () ; changed = true ; } } if ( changed ) { reindex () ; } return changed ; MST[rv.UOI4Mutator]MSP[N] } @Override
@Override public boolean removeIf ( final Predicate < ? super C > filter ) { if ( Objects . isNull ( filter ) ) { return false ; } boolean changed = false ; MST[rv.CRCR5Mutator]MSP[N] final Iterator < C > it = iterator () ;
public boolean add ( final C object ) { final boolean added = super . add ( object ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( added ) { addToIndex ( object ) ; } return added ; } @Override public boolean addAll ( final Collection < ? extends C > coll ) {
public boolean add ( final C object ) { final boolean added = super . add ( object ) ; if ( added ) { addToIndex ( object ) ; } return added ; MST[rv.UOI1Mutator]MSP[N] } @Override public boolean addAll ( final Collection < ? extends C > coll ) {
public boolean add ( final C object ) { final boolean added = super . add ( object ) ; if ( added ) { addToIndex ( object ) ; } return added ; MST[rv.ABSMutator]MSP[N] } @Override public boolean addAll ( final Collection < ? extends C > coll ) {
public boolean add ( final C object ) { final boolean added = super . add ( object ) ; if ( added ) { addToIndex ( object ) ; MST[VoidMethodCallMutator]MSP[N] } return added ; } @Override public boolean addAll ( final Collection < ? extends C > coll ) {
public boolean removeAll ( final Collection < ? > coll ) { boolean changed = false ; for ( final Object o : coll ) { changed |= remove ( o ) ; MST[rv.ABSMutator]MSP[N] } return changed ; } @Override
public boolean add ( final C object ) { final boolean added = super . add ( object ) ; if ( added ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] addToIndex ( object ) ; } return added ; } @Override public boolean addAll ( final Collection < ? extends C > coll ) {
public boolean retainAll ( final Collection < ? > coll ) { final boolean changed = super . retainAll ( coll ) ; if ( changed ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] reindex () ; } return changed ; } private void addToIndex ( final C object ) {
while ( it . hasNext () ) { if ( filter . test ( it . next () ) ) { it . remove () ; changed = true ; } } if ( changed ) { MST[rv.ABSMutator]MSP[N] reindex () ; } return changed ; } @Override
public boolean retainAll ( final Collection < ? > coll ) { final boolean changed = super . retainAll ( coll ) ; if ( changed ) { reindex () ; MST[VoidMethodCallMutator]MSP[N] } return changed ; } private void addToIndex ( final C object ) {
while ( it . hasNext () ) { if ( filter . test ( it . next () ) ) { it . remove () ; changed = true ; } } if ( changed ) { reindex () ; } return changed ; MST[rv.UOI1Mutator]MSP[N] } @Override
while ( it . hasNext () ) { if ( filter . test ( it . next () ) ) { MST[rv.ROR1Mutator]MSP[N] it . remove () ; changed = true ; } } if ( changed ) { reindex () ; } return changed ; } @Override
MultiValueMap . <K , C > multiValueMap ( new HashMap < K , Collection < C > > () ) , MST[rv.CRCR4Mutator]MSP[N] true ) ; } public static < K , C > IndexedCollection < K , C > nonUniqueIndexedCollection ( final Collection < C > coll ,
public boolean add ( final C object ) { final boolean added = super . add ( object ) ; if ( added ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] addToIndex ( object ) ; } return added ; } @Override public boolean addAll ( final Collection < ? extends C > coll ) {
final Collection < C > coll = ( Collection < C > ) index . get ( key ) ; return coll == null ? null : coll . iterator () . next () ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] } @SuppressWarnings ( lr_1 )
public boolean retainAll ( final Collection < ? > coll ) { final boolean changed = super . retainAll ( coll ) ; if ( changed ) { reindex () ; } return changed ; MST[BooleanTrueReturnValsMutator]MSP[S] } private void addToIndex ( final C object ) {
@Override public boolean removeIf ( final Predicate < ? super C > filter ) { if ( Objects . isNull ( filter ) ) { MST[rv.ROR3Mutator]MSP[N] return false ; } boolean changed = false ; final Iterator < C > it = iterator () ;
public boolean retainAll ( final Collection < ? > coll ) { final boolean changed = super . retainAll ( coll ) ; if ( changed ) { reindex () ; } return changed ; MST[rv.UOI1Mutator]MSP[N] } private void addToIndex ( final C object ) {
while ( it . hasNext () ) { if ( filter . test ( it . next () ) ) { it . remove () ; changed = true ; } } if ( changed ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] reindex () ; } return changed ; } @Override
addToIndex ( c ) ; } } @SuppressWarnings ( lr_1 ) @Override public boolean remove ( final Object object ) { final boolean removed = super . remove ( object ) ; if ( removed ) { removeFromIndex ( ( C ) object ) ; } return removed ; MST[BooleanFalseReturnValsMutator]MSP[N] }
if ( ! contains ( o ) ) { return false ; } } return true ; MST[rv.CRCR4Mutator]MSP[N] } public C get ( final K key ) { @SuppressWarnings ( lr_1 )
while ( it . hasNext () ) { if ( filter . test ( it . next () ) ) { it . remove () ; changed = true ; MST[rv.CRCR5Mutator]MSP[N] } } if ( changed ) { reindex () ; } return changed ; } @Override
index . remove ( keyTransformer . transform ( object ) ) ; MST[ArgumentPropagationMutator]MSP[S] }
if ( ! contains ( o ) ) { MST[rv.ROR1Mutator]MSP[S] return false ; } } return true ; } public C get ( final K key ) { @SuppressWarnings ( lr_1 )
boolean changed = false ; for ( final C c : coll ) { changed |= add ( c ) ; MST[rv.UOI1Mutator]MSP[N] } return changed ; } @Override public void clear () { super . clear () ; index . clear () ; } @SuppressWarnings ( lr_1 ) @Override
while ( it . hasNext () ) { MST[NegateConditionalsMutator]MSP[N] if ( filter . test ( it . next () ) ) { it . remove () ; changed = true ; } } if ( changed ) { reindex () ; } return changed ; } @Override
while ( it . hasNext () ) { if ( filter . test ( it . next () ) ) { it . remove () ; changed = true ; } } if ( changed ) { reindex () ; MST[VoidMethodCallMutator]MSP[S] } return changed ; } @Override
public boolean retainAll ( final Collection < ? > coll ) { final boolean changed = super . retainAll ( coll ) ; if ( changed ) { reindex () ; } return changed ; MST[rv.ABSMutator]MSP[N] } private void addToIndex ( final C object ) {
boolean changed = false ; for ( final C c : coll ) { changed |= add ( c ) ; MST[rv.ABSMutator]MSP[N] } return changed ; } @Override public void clear () { super . clear () ; index . clear () ; } @SuppressWarnings ( lr_1 ) @Override
public boolean add ( final C object ) { final boolean added = super . add ( object ) ; if ( added ) { MST[rv.ROR3Mutator]MSP[N] addToIndex ( object ) ; } return added ; } @Override public boolean addAll ( final Collection < ? extends C > coll ) {
boolean changed = false ; for ( final C c : coll ) { changed |= add ( c ) ; } return changed ; MST[rv.UOI2Mutator]MSP[N] } @Override public void clear () { super . clear () ; index . clear () ; } @SuppressWarnings ( lr_1 ) @Override
@Override public boolean removeIf ( final Predicate < ? super C > filter ) { if ( Objects . isNull ( filter ) ) { return false ; } boolean changed = false ; final Iterator < C > it = iterator () ; MST[NonVoidMethodCallMutator]MSP[N]
final Transformer < C , K > keyTransformer ) { return new IndexedCollection <> ( coll , keyTransformer , MST[ConstructorCallMutator]MSP[N] MultiValueMap . <K , C > multiValueMap ( new HashMap < K , Collection < C > > () ) , false ) ; } @Override
while ( it . hasNext () ) { MST[rv.ROR4Mutator]MSP[N] if ( filter . test ( it . next () ) ) { it . remove () ; changed = true ; } } if ( changed ) { reindex () ; } return changed ; } @Override
public boolean retainAll ( final Collection < ? > coll ) { final boolean changed = super . retainAll ( coll ) ; if ( changed ) { MST[rv.ROR3Mutator]MSP[N] reindex () ; } return changed ; } private void addToIndex ( final C object ) {
while ( it . hasNext () ) { if ( filter . test ( it . next () ) ) { it . remove () ; changed = true ; } } if ( changed ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] reindex () ; } return changed ; } @Override
public Collection < C > values ( final K key ) { return ( Collection < C > ) index . get ( key ) ; MST[EmptyObjectReturnValsMutator]MSP[N] } public void reindex () { index . clear () ; for ( final C c : decorated () ) {
public Collection < C > values ( final K key ) { return ( Collection < C > ) index . get ( key ) ; } public void reindex () { index . clear () ; for ( final C c : decorated () ) { MST[NonVoidMethodCallMutator]MSP[N]
addToIndex ( c ) ; } } @SuppressWarnings ( lr_1 ) @Override public boolean remove ( final Object object ) { final boolean removed = super . remove ( object ) ; if ( removed ) { MST[rv.UOI2Mutator]MSP[N] removeFromIndex ( ( C ) object ) ; } return removed ; }
boolean changed = false ; for ( final C c : coll ) { changed |= add ( c ) ; MST[MathMutator]MSP[S] } return changed ; } @Override public void clear () { super . clear () ; index . clear () ; } @SuppressWarnings ( lr_1 ) @Override
final K key = keyTransformer . transform ( object ) ; if ( uniqueIndex && index . containsKey ( key ) ) { MST[rv.ROR3Mutator]MSP[S] throw new IllegalArgumentException ( lr_2 ) ; } index . put ( key , object ) ; } private void removeFromIndex ( final C object ) {
@Override public boolean removeIf ( final Predicate < ? super C > filter ) { if ( Objects . isNull ( filter ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return false ; } boolean changed = false ; final Iterator < C > it = iterator () ;
final K key = keyTransformer . transform ( object ) ; if ( uniqueIndex && index . containsKey ( key ) ) { throw new IllegalArgumentException ( lr_2 ) ; MST[ConstructorCallMutator]MSP[S] } index . put ( key , object ) ; } private void removeFromIndex ( final C object ) {
@Override public boolean removeIf ( final Predicate < ? super C > filter ) { if ( Objects . isNull ( filter ) ) { return false ; MST[rv.CRCR3Mutator]MSP[S] } boolean changed = false ; final Iterator < C > it = iterator () ;
final K key = keyTransformer . transform ( object ) ; if ( uniqueIndex && index . containsKey ( key ) ) { MST[rv.ROR4Mutator]MSP[S] throw new IllegalArgumentException ( lr_2 ) ; } index . put ( key , object ) ; } private void removeFromIndex ( final C object ) {
@Override public boolean removeIf ( final Predicate < ? super C > filter ) { if ( Objects . isNull ( filter ) ) { return false ; MST[InlineConstantMutator]MSP[S] } boolean changed = false ; final Iterator < C > it = iterator () ;
while ( it . hasNext () ) { if ( filter . test ( it . next () ) ) { it . remove () ; changed = true ; } } if ( changed ) { reindex () ; } return changed ; MST[rv.ABSMutator]MSP[N] } @Override
final K key = keyTransformer . transform ( object ) ; if ( uniqueIndex && index . containsKey ( key ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] throw new IllegalArgumentException ( lr_2 ) ; } index . put ( key , object ) ; } private void removeFromIndex ( final C object ) {
public boolean add ( final C object ) { final boolean added = super . add ( object ) ; if ( added ) { addToIndex ( object ) ; } return added ; MST[rv.UOI4Mutator]MSP[N] } @Override public boolean addAll ( final Collection < ? extends C > coll ) {
public boolean retainAll ( final Collection < ? > coll ) { final boolean changed = super . retainAll ( coll ) ; if ( changed ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] reindex () ; } return changed ; } private void addToIndex ( final C object ) {
while ( it . hasNext () ) { if ( filter . test ( it . next () ) ) { it . remove () ; changed = true ; } } if ( changed ) { MST[rv.ROR3Mutator]MSP[S] reindex () ; } return changed ; } @Override
final K key = keyTransformer . transform ( object ) ; if ( uniqueIndex && index . containsKey ( key ) ) { MST[NegateConditionalsMutator]MSP[N] throw new IllegalArgumentException ( lr_2 ) ; } index . put ( key , object ) ; } private void removeFromIndex ( final C object ) {
final K key = keyTransformer . transform ( object ) ; if ( uniqueIndex && index . containsKey ( key ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] throw new IllegalArgumentException ( lr_2 ) ; } index . put ( key , object ) ; } private void removeFromIndex ( final C object ) {
public boolean removeAll ( final Collection < ? > coll ) { boolean changed = false ; MST[rv.CRCR1Mutator]MSP[N] for ( final Object o : coll ) { changed |= remove ( o ) ; } return changed ; } @Override
final K key = keyTransformer . transform ( object ) ; if ( uniqueIndex && index . containsKey ( key ) ) { MST[rv.ROR5Mutator]MSP[S] throw new IllegalArgumentException ( lr_2 ) ; } index . put ( key , object ) ; } private void removeFromIndex ( final C object ) {
public boolean removeAll ( final Collection < ? > coll ) { boolean changed = false ; for ( final Object o : coll ) { changed |= remove ( o ) ; } return changed ; MST[rv.UOI4Mutator]MSP[N] } @Override
public boolean removeAll ( final Collection < ? > coll ) { boolean changed = false ; for ( final Object o : coll ) { changed |= remove ( o ) ; } return changed ; MST[rv.UOI2Mutator]MSP[N] } @Override
boolean changed = false ; for ( final C c : coll ) { changed |= add ( c ) ; } return changed ; MST[rv.ABSMutator]MSP[N] } @Override public void clear () { super . clear () ; index . clear () ; } @SuppressWarnings ( lr_1 ) @Override
public boolean removeAll ( final Collection < ? > coll ) { boolean changed = false ; MST[rv.CRCR5Mutator]MSP[N] for ( final Object o : coll ) { changed |= remove ( o ) ; } return changed ; } @Override
while ( it . hasNext () ) { MST[rv.ROR2Mutator]MSP[N] if ( filter . test ( it . next () ) ) { it . remove () ; changed = true ; } } if ( changed ) { reindex () ; } return changed ; } @Override
public boolean removeAll ( final Collection < ? > coll ) { boolean changed = false ; MST[rv.CRCR3Mutator]MSP[N] for ( final Object o : coll ) { changed |= remove ( o ) ; } return changed ; } @Override
index . remove ( keyTransformer . transform ( object ) ) ; MST[ArgumentPropagationMutator]MSP[S] }
boolean changed = false ; for ( final C c : coll ) { changed |= add ( c ) ; MST[rv.UOI3Mutator]MSP[N] } return changed ; } @Override public void clear () { super . clear () ; index . clear () ; } @SuppressWarnings ( lr_1 ) @Override
boolean changed = false ; for ( final C c : coll ) { changed |= add ( c ) ; } return changed ; } @Override public void clear () { super . clear () ; MST[VoidMethodCallMutator]MSP[S] index . clear () ; } @SuppressWarnings ( lr_1 ) @Override
addToIndex ( c ) ; } } @SuppressWarnings ( lr_1 ) @Override public boolean remove ( final Object object ) { final boolean removed = super . remove ( object ) ; if ( removed ) { removeFromIndex ( ( C ) object ) ; } return removed ; MST[rv.UOI1Mutator]MSP[N] }
public boolean add ( final C object ) { final boolean added = super . add ( object ) ; if ( added ) { MST[rv.ABSMutator]MSP[N] addToIndex ( object ) ; } return added ; } @Override public boolean addAll ( final Collection < ? extends C > coll ) {
public boolean contains ( final Object object ) { return index . containsKey ( keyTransformer . transform ( ( C ) object ) ) ; MST[ArgumentPropagationMutator]MSP[N] } @Override public boolean containsAll ( final Collection < ? > coll ) { for ( final Object o : coll ) {
addToIndex ( c ) ; } } @SuppressWarnings ( lr_1 ) @Override public boolean remove ( final Object object ) { final boolean removed = super . remove ( object ) ; if ( removed ) { MST[rv.ROR2Mutator]MSP[N] removeFromIndex ( ( C ) object ) ; } return removed ; }
if ( ! contains ( o ) ) { MST[rv.ROR2Mutator]MSP[N] return false ; } } return true ; } public C get ( final K key ) { @SuppressWarnings ( lr_1 )
if ( ! contains ( o ) ) { MST[rv.ROR4Mutator]MSP[S] return false ; } } return true ; } public C get ( final K key ) { @SuppressWarnings ( lr_1 )
addToIndex ( c ) ; } } @SuppressWarnings ( lr_1 ) @Override public boolean remove ( final Object object ) { final boolean removed = super . remove ( object ) ; if ( removed ) { removeFromIndex ( ( C ) object ) ; } return removed ; MST[rv.UOI3Mutator]MSP[N] }
public boolean retainAll ( final Collection < ? > coll ) { final boolean changed = super . retainAll ( coll ) ; MST[NonVoidMethodCallMutator]MSP[S] if ( changed ) { reindex () ; } return changed ; } private void addToIndex ( final C object ) {
final Collection < C > coll = ( Collection < C > ) index . get ( key ) ; return coll == null ? null : coll . iterator () . next () ; MST[NegateConditionalsMutator]MSP[S] } @SuppressWarnings ( lr_1 )
final Transformer < C , K > keyTransformer ) { return new IndexedCollection <> ( coll , keyTransformer , MultiValueMap . <K , C > multiValueMap ( new HashMap < K , Collection < C > > () ) , MST[NonVoidMethodCallMutator]MSP[N] false ) ; } @Override
final Transformer < C , K > keyTransformer ) { return new IndexedCollection <> ( coll , keyTransformer , MultiValueMap . <K , C > multiValueMap ( new HashMap < K , Collection < C > > () ) , MST[ConstructorCallMutator]MSP[N] false ) ; } @Override
final Transformer < C , K > keyTransformer ) { return new IndexedCollection <> ( coll , keyTransformer , MultiValueMap . <K , C > multiValueMap ( new HashMap < K , Collection < C > > () ) , MST[rv.CRCR5Mutator]MSP[N] false ) ; } @Override
while ( it . hasNext () ) { if ( filter . test ( it . next () ) ) { MST[rv.ROR4Mutator]MSP[N] it . remove () ; changed = true ; } } if ( changed ) { reindex () ; } return changed ; } @Override
final Transformer < C , K > keyTransformer ) { return new IndexedCollection <> ( coll , keyTransformer , MultiValueMap . <K , C > multiValueMap ( new HashMap < K , Collection < C > > () ) , MST[rv.CRCR3Mutator]MSP[N] false ) ; } @Override
@Override public boolean removeIf ( final Predicate < ? super C > filter ) { if ( Objects . isNull ( filter ) ) { return false ; MST[ReturnValsMutator]MSP[S] } boolean changed = false ; final Iterator < C > it = iterator () ;
while ( it . hasNext () ) { if ( filter . test ( it . next () ) ) { MST[rv.ROR2Mutator]MSP[N] it . remove () ; changed = true ; } } if ( changed ) { reindex () ; } return changed ; } @Override
public boolean removeAll ( final Collection < ? > coll ) { boolean changed = false ; for ( final Object o : coll ) { changed |= remove ( o ) ; MST[rv.UOI3Mutator]MSP[S] } return changed ; } @Override
public boolean removeAll ( final Collection < ? > coll ) { boolean changed = false ; for ( final Object o : coll ) { changed |= remove ( o ) ; MST[rv.UOI1Mutator]MSP[N] } return changed ; } @Override
public boolean retainAll ( final Collection < ? > coll ) { final boolean changed = super . retainAll ( coll ) ; if ( changed ) { MST[NegateConditionalsMutator]MSP[N] reindex () ; } return changed ; } private void addToIndex ( final C object ) {
public boolean contains ( final Object object ) { return index . containsKey ( keyTransformer . transform ( ( C ) object ) ) ; MST[ReturnValsMutator]MSP[N] } @Override public boolean containsAll ( final Collection < ? > coll ) { for ( final Object o : coll ) {
addToIndex ( c ) ; } } @SuppressWarnings ( lr_1 ) @Override public boolean remove ( final Object object ) { final boolean removed = super . remove ( object ) ; if ( removed ) { MST[rv.ROR4Mutator]MSP[S] removeFromIndex ( ( C ) object ) ; } return removed ; }
@Override public boolean removeIf ( final Predicate < ? super C > filter ) { if ( Objects . isNull ( filter ) ) { return false ; } boolean changed = false ; MST[InlineConstantMutator]MSP[N] final Iterator < C > it = iterator () ;
@Override public boolean removeIf ( final Predicate < ? super C > filter ) { if ( Objects . isNull ( filter ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return false ; } boolean changed = false ; final Iterator < C > it = iterator () ;
MultiValueMap . <K , C > multiValueMap ( new HashMap < K , Collection < C > > () ) , MST[ConstructorCallMutator]MSP[S] true ) ; } public static < K , C > IndexedCollection < K , C > nonUniqueIndexedCollection ( final Collection < C > coll ,
final Collection < C > coll = ( Collection < C > ) index . get ( key ) ; return coll == null ? null : coll . iterator () . next () ; MST[NullReturnValsMutator]MSP[S] } @SuppressWarnings ( lr_1 )
public boolean removeAll ( final Collection < ? > coll ) { boolean changed = false ; for ( final Object o : coll ) { changed |= remove ( o ) ; } return changed ; MST[rv.ABSMutator]MSP[N] } @Override
final Transformer < C , K > keyTransformer ) { return new IndexedCollection <> ( coll , keyTransformer , MultiValueMap . <K , C > multiValueMap ( new HashMap < K , Collection < C > > () ) , MST[rv.CRCR1Mutator]MSP[N] false ) ; } @Override
MultiValueMap . <K , C > multiValueMap ( new HashMap < K , Collection < C > > () ) , MST[rv.CRCR5Mutator]MSP[S] true ) ; } public static < K , C > IndexedCollection < K , C > nonUniqueIndexedCollection ( final Collection < C > coll ,
if ( ! contains ( o ) ) { return false ; } } return true ; MST[rv.CRCR6Mutator]MSP[S] } public C get ( final K key ) { @SuppressWarnings ( lr_1 )
@Override public boolean removeIf ( final Predicate < ? super C > filter ) { if ( Objects . isNull ( filter ) ) { MST[rv.ROR5Mutator]MSP[N] return false ; } boolean changed = false ; final Iterator < C > it = iterator () ;
public boolean retainAll ( final Collection < ? > coll ) { final boolean changed = super . retainAll ( coll ) ; if ( changed ) { MST[rv.ROR5Mutator]MSP[N] reindex () ; } return changed ; } private void addToIndex ( final C object ) {
public boolean retainAll ( final Collection < ? > coll ) { final boolean changed = super . retainAll ( coll ) ; if ( changed ) { reindex () ; } return changed ; MST[rv.UOI4Mutator]MSP[N] } private void addToIndex ( final C object ) {
public boolean contains ( final Object object ) { return index . containsKey ( keyTransformer . transform ( ( C ) object ) ) ; MST[BooleanTrueReturnValsMutator]MSP[N] } @Override public boolean containsAll ( final Collection < ? > coll ) { for ( final Object o : coll ) {
public Collection < C > values ( final K key ) { return ( Collection < C > ) index . get ( key ) ; MST[ReturnValsMutator]MSP[S] } public void reindex () { index . clear () ; for ( final C c : decorated () ) {
if ( ! contains ( o ) ) { return false ; } } return true ; MST[rv.CRCR2Mutator]MSP[S] } public C get ( final K key ) { @SuppressWarnings ( lr_1 )
while ( it . hasNext () ) { if ( filter . test ( it . next () ) ) { it . remove () ; changed = true ; MST[InlineConstantMutator]MSP[N] } } if ( changed ) { reindex () ; } return changed ; } @Override
@Override public boolean removeIf ( final Predicate < ? super C > filter ) { if ( Objects . isNull ( filter ) ) { MST[NonVoidMethodCallMutator]MSP[N] return false ; } boolean changed = false ; final Iterator < C > it = iterator () ;
while ( it . hasNext () ) { if ( filter . test ( it . next () ) ) { it . remove () ; changed = true ; MST[rv.CRCR3Mutator]MSP[N] } } if ( changed ) { reindex () ; } return changed ; } @Override
public boolean removeAll ( final Collection < ? > coll ) { boolean changed = false ; for ( final Object o : coll ) { changed |= remove ( o ) ; } return changed ; MST[BooleanFalseReturnValsMutator]MSP[N] } @Override
public boolean add ( final C object ) { final boolean added = super . add ( object ) ; if ( added ) { addToIndex ( object ) ; } return added ; MST[rv.UOI2Mutator]MSP[N] } @Override public boolean addAll ( final Collection < ? extends C > coll ) {
boolean changed = false ; MST[rv.CRCR5Mutator]MSP[S] for ( final C c : coll ) { changed |= add ( c ) ; } return changed ; } @Override public void clear () { super . clear () ; index . clear () ; } @SuppressWarnings ( lr_1 ) @Override
boolean changed = false ; for ( final C c : coll ) { changed |= add ( c ) ; } return changed ; MST[rv.UOI4Mutator]MSP[N] } @Override public void clear () { super . clear () ; index . clear () ; } @SuppressWarnings ( lr_1 ) @Override
public boolean add ( final C object ) { final boolean added = super . add ( object ) ; if ( added ) { MST[rv.ROR5Mutator]MSP[N] addToIndex ( object ) ; } return added ; } @Override public boolean addAll ( final Collection < ? extends C > coll ) {
public boolean retainAll ( final Collection < ? > coll ) { final boolean changed = super . retainAll ( coll ) ; if ( changed ) { reindex () ; } return changed ; MST[BooleanFalseReturnValsMutator]MSP[S] } private void addToIndex ( final C object ) {
public boolean add ( final C object ) { final boolean added = super . add ( object ) ; if ( added ) { MST[rv.ROR1Mutator]MSP[N] addToIndex ( object ) ; } return added ; } @Override public boolean addAll ( final Collection < ? extends C > coll ) {
@Override public boolean removeIf ( final Predicate < ? super C > filter ) { if ( Objects . isNull ( filter ) ) { MST[rv.ROR1Mutator]MSP[N] return false ; } boolean changed = false ; final Iterator < C > it = iterator () ;
@Override public boolean removeIf ( final Predicate < ? super C > filter ) { if ( Objects . isNull ( filter ) ) { return false ; MST[BooleanTrueReturnValsMutator]MSP[S] } boolean changed = false ; final Iterator < C > it = iterator () ;
if ( ! contains ( o ) ) { return false ; MST[rv.CRCR6Mutator]MSP[S] } } return true ; } public C get ( final K key ) { @SuppressWarnings ( lr_1 )
boolean changed = false ; MST[rv.CRCR1Mutator]MSP[S] for ( final C c : coll ) { changed |= add ( c ) ; } return changed ; } @Override public void clear () { super . clear () ; index . clear () ; } @SuppressWarnings ( lr_1 ) @Override
public boolean retainAll ( final Collection < ? > coll ) { final boolean changed = super . retainAll ( coll ) ; if ( changed ) { MST[rv.ROR1Mutator]MSP[N] reindex () ; } return changed ; } private void addToIndex ( final C object ) {
final Collection < C > coll = ( Collection < C > ) index . get ( key ) ; return coll == null ? null : coll . iterator () . next () ; MST[rv.ROR5Mutator]MSP[S] } @SuppressWarnings ( lr_1 )
public static < K , C > IndexedCollection < K , C > uniqueIndexedCollection ( final Collection < C > coll , final Transformer < C , K > keyTransformer ) { return new IndexedCollection <> ( coll , keyTransformer , MST[NullReturnValsMutator]MSP[S]
final K key = keyTransformer . transform ( object ) ; if ( uniqueIndex && index . containsKey ( key ) ) { MST[rv.ROR1Mutator]MSP[S] throw new IllegalArgumentException ( lr_2 ) ; } index . put ( key , object ) ; } private void removeFromIndex ( final C object ) {
final K key = keyTransformer . transform ( object ) ; if ( uniqueIndex && index . containsKey ( key ) ) { MST[rv.ROR2Mutator]MSP[N] throw new IllegalArgumentException ( lr_2 ) ; } index . put ( key , object ) ; } private void removeFromIndex ( final C object ) {
while ( it . hasNext () ) { if ( filter . test ( it . next () ) ) { it . remove () ; MST[VoidMethodCallMutator]MSP[N] changed = true ; } } if ( changed ) { reindex () ; } return changed ; } @Override
public boolean add ( final C object ) { final boolean added = super . add ( object ) ; if ( added ) { MST[rv.UOI4Mutator]MSP[N] addToIndex ( object ) ; } return added ; } @Override public boolean addAll ( final Collection < ? extends C > coll ) {
boolean changed = false ; for ( final C c : coll ) { changed |= add ( c ) ; } return changed ; MST[BooleanFalseReturnValsMutator]MSP[S] } @Override public void clear () { super . clear () ; index . clear () ; } @SuppressWarnings ( lr_1 ) @Override
public Collection < C > values ( final K key ) { return ( Collection < C > ) index . get ( key ) ; MST[NonVoidMethodCallMutator]MSP[S] } public void reindex () { index . clear () ; for ( final C c : decorated () ) {
@Override public boolean removeIf ( final Predicate < ? super C > filter ) { if ( Objects . isNull ( filter ) ) { return false ; MST[rv.CRCR1Mutator]MSP[S] } boolean changed = false ; final Iterator < C > it = iterator () ;
while ( it . hasNext () ) { if ( filter . test ( it . next () ) ) { it . remove () ; changed = true ; } } if ( changed ) { MST[rv.UOI4Mutator]MSP[N] reindex () ; } return changed ; } @Override
final Collection < C > coll = ( Collection < C > ) index . get ( key ) ; MST[NonVoidMethodCallMutator]MSP[S] return coll == null ? null : coll . iterator () . next () ; } @SuppressWarnings ( lr_1 )
@Override public boolean removeIf ( final Predicate < ? super C > filter ) { if ( Objects . isNull ( filter ) ) { return false ; MST[rv.CRCR5Mutator]MSP[S] } boolean changed = false ; final Iterator < C > it = iterator () ;
while ( it . hasNext () ) { if ( filter . test ( it . next () ) ) { it . remove () ; changed = true ; } } if ( changed ) { MST[rv.ROR5Mutator]MSP[S] reindex () ; } return changed ; } @Override
while ( it . hasNext () ) { if ( filter . test ( it . next () ) ) { it . remove () ; changed = true ; } } if ( changed ) { MST[rv.ROR1Mutator]MSP[N] reindex () ; } return changed ; } @Override
public Collection < C > values ( final K key ) { return ( Collection < C > ) index . get ( key ) ; MST[ArgumentPropagationMutator]MSP[S] } public void reindex () { index . clear () ; for ( final C c : decorated () ) {
boolean changed = false ; MST[InlineConstantMutator]MSP[S] for ( final C c : coll ) { changed |= add ( c ) ; } return changed ; } @Override public void clear () { super . clear () ; index . clear () ; } @SuppressWarnings ( lr_1 ) @Override
@Override public boolean removeIf ( final Predicate < ? super C > filter ) { if ( Objects . isNull ( filter ) ) { MST[NegateConditionalsMutator]MSP[N] return false ; } boolean changed = false ; final Iterator < C > it = iterator () ;
public boolean retainAll ( final Collection < ? > coll ) { final boolean changed = super . retainAll ( coll ) ; if ( changed ) { MST[rv.UOI4Mutator]MSP[N] reindex () ; } return changed ; } private void addToIndex ( final C object ) {
public boolean retainAll ( final Collection < ? > coll ) { final boolean changed = super . retainAll ( coll ) ; if ( changed ) { MST[rv.UOI2Mutator]MSP[N] reindex () ; } return changed ; } private void addToIndex ( final C object ) {
public boolean add ( final C object ) { final boolean added = super . add ( object ) ; if ( added ) { addToIndex ( object ) ; } return added ; MST[BooleanFalseReturnValsMutator]MSP[N] } @Override public boolean addAll ( final Collection < ? extends C > coll ) {
public boolean removeAll ( final Collection < ? > coll ) { boolean changed = false ; for ( final Object o : coll ) { changed |= remove ( o ) ; MST[NonVoidMethodCallMutator]MSP[N] } return changed ; } @Override
while ( it . hasNext () ) { if ( filter . test ( it . next () ) ) { it . remove () ; changed = true ; } } if ( changed ) { reindex () ; } return changed ; MST[BooleanFalseReturnValsMutator]MSP[N] } @Override
public boolean contains ( final Object object ) { return index . containsKey ( keyTransformer . transform ( ( C ) object ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } @Override public boolean containsAll ( final Collection < ? > coll ) { for ( final Object o : coll ) {
if ( ! contains ( o ) ) { MST[NonVoidMethodCallMutator]MSP[S] return false ; } } return true ; } public C get ( final K key ) { @SuppressWarnings ( lr_1 )
public boolean add ( final C object ) { final boolean added = super . add ( object ) ; if ( added ) { addToIndex ( object ) ; } return added ; MST[rv.UOI3Mutator]MSP[N] } @Override public boolean addAll ( final Collection < ? extends C > coll ) {
addToIndex ( c ) ; } } @SuppressWarnings ( lr_1 ) @Override public boolean remove ( final Object object ) { final boolean removed = super . remove ( object ) ; if ( removed ) { removeFromIndex ( ( C ) object ) ; } return removed ; MST[rv.ABSMutator]MSP[N] }
index . remove ( keyTransformer . transform ( object ) ) ; MST[NonVoidMethodCallMutator]MSP[S] }
addToIndex ( c ) ; } } @SuppressWarnings ( lr_1 ) @Override public boolean remove ( final Object object ) { final boolean removed = super . remove ( object ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( removed ) { removeFromIndex ( ( C ) object ) ; } return removed ; }
public boolean add ( final C object ) { final boolean added = super . add ( object ) ; if ( added ) { MST[NegateConditionalsMutator]MSP[N] addToIndex ( object ) ; } return added ; } @Override public boolean addAll ( final Collection < ? extends C > coll ) {
public boolean retainAll ( final Collection < ? > coll ) { final boolean changed = super . retainAll ( coll ) ; if ( changed ) { MST[rv.ROR2Mutator]MSP[N] reindex () ; } return changed ; } private void addToIndex ( final C object ) {
final K key = keyTransformer . transform ( object ) ; MST[ArgumentPropagationMutator]MSP[N] if ( uniqueIndex && index . containsKey ( key ) ) { throw new IllegalArgumentException ( lr_2 ) ; } index . put ( key , object ) ; } private void removeFromIndex ( final C object ) {
final K key = keyTransformer . transform ( object ) ; if ( uniqueIndex && index . containsKey ( key ) ) { MST[NonVoidMethodCallMutator]MSP[S] throw new IllegalArgumentException ( lr_2 ) ; } index . put ( key , object ) ; } private void removeFromIndex ( final C object ) {
public boolean retainAll ( final Collection < ? > coll ) { final boolean changed = super . retainAll ( coll ) ; if ( changed ) { MST[rv.ROR4Mutator]MSP[N] reindex () ; } return changed ; } private void addToIndex ( final C object ) {
if ( ! contains ( o ) ) { return false ; MST[InlineConstantMutator]MSP[S] } } return true ; } public C get ( final K key ) { @SuppressWarnings ( lr_1 )
addToIndex ( c ) ; } } @SuppressWarnings ( lr_1 ) @Override public boolean remove ( final Object object ) { final boolean removed = super . remove ( object ) ; if ( removed ) { MST[rv.UOI3Mutator]MSP[N] removeFromIndex ( ( C ) object ) ; } return removed ; }
@Override public boolean removeIf ( final Predicate < ? super C > filter ) { if ( Objects . isNull ( filter ) ) { return false ; } boolean changed = false ; MST[rv.CRCR1Mutator]MSP[N] final Iterator < C > it = iterator () ;
@Override public boolean removeIf ( final Predicate < ? super C > filter ) { if ( Objects . isNull ( filter ) ) { return false ; } boolean changed = false ; MST[rv.CRCR3Mutator]MSP[N] final Iterator < C > it = iterator () ;
while ( it . hasNext () ) { if ( filter . test ( it . next () ) ) { MST[NonVoidMethodCallMutator]MSP[N] it . remove () ; changed = true ; } } if ( changed ) { reindex () ; } return changed ; } @Override
final K key = keyTransformer . transform ( object ) ; if ( uniqueIndex && index . containsKey ( key ) ) { MST[rv.ROR3Mutator]MSP[N] throw new IllegalArgumentException ( lr_2 ) ; } index . put ( key , object ) ; } private void removeFromIndex ( final C object ) {
while ( it . hasNext () ) { if ( filter . test ( it . next () ) ) { it . remove () ; changed = true ; } } if ( changed ) { MST[NegateConditionalsMutator]MSP[S] reindex () ; } return changed ; } @Override
final Transformer < C , K > keyTransformer ) { return new IndexedCollection <> ( coll , keyTransformer , MST[ReturnValsMutator]MSP[N] MultiValueMap . <K , C > multiValueMap ( new HashMap < K , Collection < C > > () ) , false ) ; } @Override
addToIndex ( c ) ; } } @SuppressWarnings ( lr_1 ) @Override public boolean remove ( final Object object ) { final boolean removed = super . remove ( object ) ; if ( removed ) { MST[rv.UOI1Mutator]MSP[N] removeFromIndex ( ( C ) object ) ; } return removed ; }
addToIndex ( c ) ; } } @SuppressWarnings ( lr_1 ) @Override public boolean remove ( final Object object ) { final boolean removed = super . remove ( object ) ; if ( removed ) { removeFromIndex ( ( C ) object ) ; } return removed ; MST[ReturnValsMutator]MSP[N] }
while ( it . hasNext () ) { if ( filter . test ( it . next () ) ) { it . remove () ; changed = true ; } } if ( changed ) { MST[rv.ROR2Mutator]MSP[N] reindex () ; } return changed ; } @Override
while ( it . hasNext () ) { if ( filter . test ( it . next () ) ) { it . remove () ; changed = true ; } } if ( changed ) { MST[rv.ROR4Mutator]MSP[S] reindex () ; } return changed ; } @Override
final K key = keyTransformer . transform ( object ) ; if ( uniqueIndex && index . containsKey ( key ) ) { MST[NegateConditionalsMutator]MSP[S] throw new IllegalArgumentException ( lr_2 ) ; } index . put ( key , object ) ; } private void removeFromIndex ( final C object ) {
final K key = keyTransformer . transform ( object ) ; if ( uniqueIndex && index . containsKey ( key ) ) { MST[rv.ROR5Mutator]MSP[N] throw new IllegalArgumentException ( lr_2 ) ; } index . put ( key , object ) ; } private void removeFromIndex ( final C object ) {
if ( ! contains ( o ) ) { return false ; } } return true ; MST[ReturnValsMutator]MSP[S] } public C get ( final K key ) { @SuppressWarnings ( lr_1 )
while ( it . hasNext () ) { if ( filter . test ( it . next () ) ) { it . remove () ; changed = true ; } } if ( changed ) { reindex () ; } return changed ; MST[rv.UOI2Mutator]MSP[N] } @Override
addToIndex ( c ) ; } } @SuppressWarnings ( lr_1 ) @Override public boolean remove ( final Object object ) { final boolean removed = super . remove ( object ) ; if ( removed ) { removeFromIndex ( ( C ) object ) ; MST[VoidMethodCallMutator]MSP[S] } return removed ; }
MultiValueMap . <K , C > multiValueMap ( new HashMap < K , Collection < C > > () ) , MST[rv.CRCR3Mutator]MSP[N] true ) ; } public static < K , C > IndexedCollection < K , C > nonUniqueIndexedCollection ( final Collection < C > coll ,
MultiValueMap . <K , C > multiValueMap ( new HashMap < K , Collection < C > > () ) , MST[InlineConstantMutator]MSP[S] true ) ; } public static < K , C > IndexedCollection < K , C > nonUniqueIndexedCollection ( final Collection < C > coll ,
@Override public boolean removeIf ( final Predicate < ? super C > filter ) { if ( Objects . isNull ( filter ) ) { MST[rv.ROR4Mutator]MSP[N] return false ; } boolean changed = false ; final Iterator < C > it = iterator () ;
public boolean retainAll ( final Collection < ? > coll ) { final boolean changed = super . retainAll ( coll ) ; if ( changed ) { reindex () ; } return changed ; MST[rv.UOI2Mutator]MSP[N] } private void addToIndex ( final C object ) {
boolean changed = false ; for ( final C c : coll ) { changed |= add ( c ) ; } return changed ; MST[rv.UOI1Mutator]MSP[N] } @Override public void clear () { super . clear () ; index . clear () ; } @SuppressWarnings ( lr_1 ) @Override
public Collection < C > values ( final K key ) { return ( Collection < C > ) index . get ( key ) ; } public void reindex () { index . clear () ; MST[VoidMethodCallMutator]MSP[N] for ( final C c : decorated () ) {
boolean changed = false ; for ( final C c : coll ) { changed |= add ( c ) ; } return changed ; } @Override public void clear () { super . clear () ; index . clear () ; MST[VoidMethodCallMutator]MSP[N] } @SuppressWarnings ( lr_1 ) @Override
if ( ! contains ( o ) ) { return false ; } } return true ; MST[rv.CRCR3Mutator]MSP[N] } public C get ( final K key ) { @SuppressWarnings ( lr_1 )
while ( it . hasNext () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] if ( filter . test ( it . next () ) ) { it . remove () ; changed = true ; } } if ( changed ) { reindex () ; } return changed ; } @Override
while ( it . hasNext () ) { if ( filter . test ( it . next () ) ) { it . remove () ; changed = true ; MST[rv.CRCR4Mutator]MSP[N] } } if ( changed ) { reindex () ; } return changed ; } @Override
addToIndex ( c ) ; } } @SuppressWarnings ( lr_1 ) @Override public boolean remove ( final Object object ) { final boolean removed = super . remove ( object ) ; if ( removed ) { removeFromIndex ( ( C ) object ) ; } return removed ; MST[BooleanTrueReturnValsMutator]MSP[N] }
addToIndex ( c ) ; } } @SuppressWarnings ( lr_1 ) @Override public boolean remove ( final Object object ) { final boolean removed = super . remove ( object ) ; if ( removed ) { MST[rv.ROR3Mutator]MSP[S] removeFromIndex ( ( C ) object ) ; } return removed ; }
public boolean removeAll ( final Collection < ? > coll ) { boolean changed = false ; for ( final Object o : coll ) { changed |= remove ( o ) ; MST[rv.OBBN2Mutator]MSP[N] } return changed ; } @Override
index . remove ( keyTransformer . transform ( object ) ) ; MST[NonVoidMethodCallMutator]MSP[S] }
public boolean add ( final C object ) { final boolean added = super . add ( object ) ; if ( added ) { MST[rv.UOI2Mutator]MSP[N] addToIndex ( object ) ; } return added ; } @Override public boolean addAll ( final Collection < ? extends C > coll ) {
if ( ! contains ( o ) ) { return false ; } } return true ; MST[InlineConstantMutator]MSP[S] } public C get ( final K key ) { @SuppressWarnings ( lr_1 )
addToIndex ( c ) ; } } @SuppressWarnings ( lr_1 ) @Override public boolean remove ( final Object object ) { final boolean removed = super . remove ( object ) ; if ( removed ) { removeFromIndex ( ( C ) object ) ; } return removed ; MST[rv.UOI4Mutator]MSP[N] }
if ( ! contains ( o ) ) { MST[rv.ROR5Mutator]MSP[N] return false ; } } return true ; } public C get ( final K key ) { @SuppressWarnings ( lr_1 )
public boolean removeAll ( final Collection < ? > coll ) { boolean changed = false ; MST[InlineConstantMutator]MSP[N] for ( final Object o : coll ) { changed |= remove ( o ) ; } return changed ; } @Override
boolean changed = false ; MST[rv.CRCR3Mutator]MSP[S] for ( final C c : coll ) { changed |= add ( c ) ; } return changed ; } @Override public void clear () { super . clear () ; index . clear () ; } @SuppressWarnings ( lr_1 ) @Override
while ( it . hasNext () ) { if ( filter . test ( it . next () ) ) { MST[rv.ROR5Mutator]MSP[N] it . remove () ; changed = true ; } } if ( changed ) { reindex () ; } return changed ; } @Override
boolean changed = false ; for ( final C c : coll ) { changed |= add ( c ) ; MST[rv.OBBN2Mutator]MSP[S] } return changed ; } @Override public void clear () { super . clear () ; index . clear () ; } @SuppressWarnings ( lr_1 ) @Override
public boolean removeAll ( final Collection < ? > coll ) { boolean changed = false ; for ( final Object o : coll ) { changed |= remove ( o ) ; MST[rv.UOI2Mutator]MSP[N] } return changed ; } @Override
@Override public boolean removeIf ( final Predicate < ? super C > filter ) { if ( Objects . isNull ( filter ) ) { return false ; } boolean changed = false ; MST[rv.CRCR6Mutator]MSP[N] final Iterator < C > it = iterator () ;
while ( it . hasNext () ) { if ( filter . test ( it . next () ) ) { it . remove () ; changed = true ; } } if ( changed ) { MST[rv.UOI2Mutator]MSP[N] reindex () ; } return changed ; } @Override
