final Collection < V > coll = super . values () ; return UnmodifiableCollection . unmodifiableCollection ( coll ) ; MST[ArgumentPropagationMutator]MSP[N] }
return UnmodifiableEntrySet . unmodifiableEntrySet ( set ) ; } @Override public Set < K > keySet () { final Set < K > set = super . keySet () ; return UnmodifiableSet . unmodifiableSet ( set ) ; MST[ArgumentPropagationMutator]MSP[N] } @Override public Collection < V > values () {
final Map < K , V > tmpMap = ( Map < K , V > ) map ; return tmpMap ; } return new UnmodifiableMap <> ( map ) ; } private void writeObject ( final ObjectOutputStream out ) throws IOException { out . defaultWriteObject () ; MST[VoidMethodCallMutator]MSP[N]
public static < K , V > Map < K , V > unmodifiableMap ( final Map < ? extends K , ? extends V > map ) { if ( map instanceof Unmodifiable ) { MST[rv.ROR1Mutator]MSP[N] @SuppressWarnings ( lr_1 )
final Collection < V > coll = super . values () ; return UnmodifiableCollection . unmodifiableCollection ( coll ) ; MST[ReturnValsMutator]MSP[N] }
public static < K , V > Map < K , V > unmodifiableMap ( final Map < ? extends K , ? extends V > map ) { if ( map instanceof Unmodifiable ) { MST[rv.ROR3Mutator]MSP[N] @SuppressWarnings ( lr_1 )
public static < K , V > Map < K , V > unmodifiableMap ( final Map < ? extends K , ? extends V > map ) { if ( map instanceof Unmodifiable ) { MST[rv.ROR4Mutator]MSP[S] @SuppressWarnings ( lr_1 )
public static < K , V > Map < K , V > unmodifiableMap ( final Map < ? extends K , ? extends V > map ) { if ( map instanceof Unmodifiable ) { MST[rv.ROR5Mutator]MSP[N] @SuppressWarnings ( lr_1 )
public static < K , V > Map < K , V > unmodifiableMap ( final Map < ? extends K , ? extends V > map ) { if ( map instanceof Unmodifiable ) { MST[rv.ROR2Mutator]MSP[N] @SuppressWarnings ( lr_1 )
return UnmodifiableMapIterator . unmodifiableMapIterator ( it ) ; } @Override public Set < Map . Entry < K , V > > entrySet () { final Set < Map . Entry < K , V > > set = super . entrySet () ; MST[NonVoidMethodCallMutator]MSP[N]
return UnmodifiableEntrySet . unmodifiableEntrySet ( set ) ; } @Override public Set < K > keySet () { final Set < K > set = super . keySet () ; MST[NonVoidMethodCallMutator]MSP[N] return UnmodifiableSet . unmodifiableSet ( set ) ; } @Override public Collection < V > values () {
return UnmodifiableEntrySet . unmodifiableEntrySet ( set ) ; } @Override public Set < K > keySet () { final Set < K > set = super . keySet () ; return UnmodifiableSet . unmodifiableSet ( set ) ; MST[EmptyObjectReturnValsMutator]MSP[N] } @Override public Collection < V > values () {
final Map < K , V > tmpMap = ( Map < K , V > ) map ; return tmpMap ; MST[ReturnValsMutator]MSP[S] } return new UnmodifiableMap <> ( map ) ; } private void writeObject ( final ObjectOutputStream out ) throws IOException { out . defaultWriteObject () ;
public void clear () { throw new UnsupportedOperationException () ; MST[ConstructorCallMutator]MSP[S] } @Override public V put ( final K key , final V value ) { throw new UnsupportedOperationException () ; } @Override public void putAll ( final Map < ? extends K , ? extends V > mapToCopy ) {
final Collection < V > coll = super . values () ; return UnmodifiableCollection . unmodifiableCollection ( coll ) ; MST[NonVoidMethodCallMutator]MSP[N] }
out . writeObject ( map ) ; } @SuppressWarnings ( lr_1 ) private void readObject ( final ObjectInputStream in ) throws IOException , ClassNotFoundException { in . defaultReadObject () ; map = ( Map < K , V > ) in . readObject () ; MST[NonVoidMethodCallMutator]MSP[S] } @Override
final Map < K , V > tmpMap = ( Map < K , V > ) map ; return tmpMap ; } return new UnmodifiableMap <> ( map ) ; MST[ReturnValsMutator]MSP[N] } private void writeObject ( final ObjectOutputStream out ) throws IOException { out . defaultWriteObject () ;
return UnmodifiableEntrySet . unmodifiableEntrySet ( set ) ; MST[ReturnValsMutator]MSP[N] } @Override public Set < K > keySet () { final Set < K > set = super . keySet () ; return UnmodifiableSet . unmodifiableSet ( set ) ; } @Override public Collection < V > values () {
final Map < K , V > tmpMap = ( Map < K , V > ) map ; return tmpMap ; } return new UnmodifiableMap <> ( map ) ; MST[ConstructorCallMutator]MSP[N] } private void writeObject ( final ObjectOutputStream out ) throws IOException { out . defaultWriteObject () ;
throw new UnsupportedOperationException () ; MST[ConstructorCallMutator]MSP[S] } @Override public V remove ( final Object key ) { throw new UnsupportedOperationException () ; } @Override public MapIterator < K , V > mapIterator () { if ( map instanceof IterableMap ) {
return UnmodifiableEntrySet . unmodifiableEntrySet ( set ) ; MST[ArgumentPropagationMutator]MSP[N] } @Override public Set < K > keySet () { final Set < K > set = super . keySet () ; return UnmodifiableSet . unmodifiableSet ( set ) ; } @Override public Collection < V > values () {
final Map < K , V > tmpMap = ( Map < K , V > ) map ; return tmpMap ; } return new UnmodifiableMap <> ( map ) ; MST[NullReturnValsMutator]MSP[N] } private void writeObject ( final ObjectOutputStream out ) throws IOException { out . defaultWriteObject () ;
return UnmodifiableEntrySet . unmodifiableEntrySet ( set ) ; MST[NonVoidMethodCallMutator]MSP[N] } @Override public Set < K > keySet () { final Set < K > set = super . keySet () ; return UnmodifiableSet . unmodifiableSet ( set ) ; } @Override public Collection < V > values () {
public void clear () { throw new UnsupportedOperationException () ; } @Override public V put ( final K key , final V value ) { throw new UnsupportedOperationException () ; MST[ConstructorCallMutator]MSP[S] } @Override public void putAll ( final Map < ? extends K , ? extends V > mapToCopy ) {
public static < K , V > Map < K , V > unmodifiableMap ( final Map < ? extends K , ? extends V > map ) { if ( map instanceof Unmodifiable ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] @SuppressWarnings ( lr_1 )
final Map < K , V > tmpMap = ( Map < K , V > ) map ; return tmpMap ; MST[NullReturnValsMutator]MSP[S] } return new UnmodifiableMap <> ( map ) ; } private void writeObject ( final ObjectOutputStream out ) throws IOException { out . defaultWriteObject () ;
return UnmodifiableEntrySet . unmodifiableEntrySet ( set ) ; MST[EmptyObjectReturnValsMutator]MSP[S] } @Override public Set < K > keySet () { final Set < K > set = super . keySet () ; return UnmodifiableSet . unmodifiableSet ( set ) ; } @Override public Collection < V > values () {
out . writeObject ( map ) ; } @SuppressWarnings ( lr_1 ) private void readObject ( final ObjectInputStream in ) throws IOException , ClassNotFoundException { in . defaultReadObject () ; map = ( Map < K , V > ) in . readObject () ; MST[experimental.MemberVariableMutator]MSP[S] } @Override
public static < K , V > Map < K , V > unmodifiableMap ( final Map < ? extends K , ? extends V > map ) { if ( map instanceof Unmodifiable ) { MST[NegateConditionalsMutator]MSP[N] @SuppressWarnings ( lr_1 )
return UnmodifiableEntrySet . unmodifiableEntrySet ( set ) ; } @Override public Set < K > keySet () { final Set < K > set = super . keySet () ; return UnmodifiableSet . unmodifiableSet ( set ) ; MST[NonVoidMethodCallMutator]MSP[N] } @Override public Collection < V > values () {
throw new UnsupportedOperationException () ; } @Override public V remove ( final Object key ) { throw new UnsupportedOperationException () ; MST[ConstructorCallMutator]MSP[S] } @Override public MapIterator < K , V > mapIterator () { if ( map instanceof IterableMap ) {
public static < K , V > Map < K , V > unmodifiableMap ( final Map < ? extends K , ? extends V > map ) { if ( map instanceof Unmodifiable ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] @SuppressWarnings ( lr_1 )
return UnmodifiableEntrySet . unmodifiableEntrySet ( set ) ; } @Override public Set < K > keySet () { final Set < K > set = super . keySet () ; return UnmodifiableSet . unmodifiableSet ( set ) ; MST[ReturnValsMutator]MSP[N] } @Override public Collection < V > values () {
out . writeObject ( map ) ; } @SuppressWarnings ( lr_1 ) private void readObject ( final ObjectInputStream in ) throws IOException , ClassNotFoundException { in . defaultReadObject () ; MST[VoidMethodCallMutator]MSP[N] map = ( Map < K , V > ) in . readObject () ; } @Override
out . writeObject ( map ) ; MST[VoidMethodCallMutator]MSP[S] } @SuppressWarnings ( lr_1 ) private void readObject ( final ObjectInputStream in ) throws IOException , ClassNotFoundException { in . defaultReadObject () ; map = ( Map < K , V > ) in . readObject () ; } @Override
final Collection < V > coll = super . values () ; MST[NonVoidMethodCallMutator]MSP[N] return UnmodifiableCollection . unmodifiableCollection ( coll ) ; }
final Collection < V > coll = super . values () ; return UnmodifiableCollection . unmodifiableCollection ( coll ) ; MST[EmptyObjectReturnValsMutator]MSP[S] }
