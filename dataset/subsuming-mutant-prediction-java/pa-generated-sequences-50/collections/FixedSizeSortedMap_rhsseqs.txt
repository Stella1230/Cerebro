if ( CollectionUtils . isSubCollection ( mapToCopy . keySet () , keySet () ) ) { MST[NonVoidMethodCallMutator]MSP[S] throw new IllegalArgumentException ( lr_2 ) ; } map . putAll ( mapToCopy ) ; } @Override public void clear () { throw new UnsupportedOperationException ( lr_3 ) ; } @Override
public Set < K > keySet () { return UnmodifiableSet . unmodifiableSet ( map . keySet () ) ; MST[EmptyObjectReturnValsMutator]MSP[S] } @Override public Collection < V > values () { return UnmodifiableCollection . unmodifiableCollection ( map . values () ) ; } @Override
public Set < K > keySet () { return UnmodifiableSet . unmodifiableSet ( map . keySet () ) ; } @Override public Collection < V > values () { return UnmodifiableCollection . unmodifiableCollection ( map . values () ) ; MST[EmptyObjectReturnValsMutator]MSP[S] } @Override
public static < K , V > FixedSizeSortedMap < K , V > fixedSizeSortedMap ( final SortedMap < K , V > map ) { return new FixedSizeSortedMap <> ( map ) ; MST[ReturnValsMutator]MSP[S] } protected SortedMap < K , V > getSortedMap () {
if ( map . containsKey ( key ) == false ) { MST[NonVoidMethodCallMutator]MSP[N] throw new IllegalArgumentException ( lr_2 ) ; } return map . put ( key , value ) ; } @Override public void putAll ( final Map < ? extends K , ? extends V > mapToCopy ) {
if ( CollectionUtils . isSubCollection ( mapToCopy . keySet () , keySet () ) ) { MST[NonVoidMethodCallMutator]MSP[S] throw new IllegalArgumentException ( lr_2 ) ; } map . putAll ( mapToCopy ) ; } @Override public void clear () { throw new UnsupportedOperationException ( lr_3 ) ; } @Override
public V remove ( final Object key ) { throw new UnsupportedOperationException ( lr_3 ) ; MST[ConstructorCallMutator]MSP[S] } @Override public Set < Map . Entry < K , V > > entrySet () { return UnmodifiableSet . unmodifiableSet ( map . entrySet () ) ; } @Override
public Set < K > keySet () { return UnmodifiableSet . unmodifiableSet ( map . keySet () ) ; } @Override public Collection < V > values () { return UnmodifiableCollection . unmodifiableCollection ( map . values () ) ; MST[ArgumentPropagationMutator]MSP[S] } @Override
public Set < K > keySet () { return UnmodifiableSet . unmodifiableSet ( map . keySet () ) ; } @Override public Collection < V > values () { return UnmodifiableCollection . unmodifiableCollection ( map . values () ) ; MST[NonVoidMethodCallMutator]MSP[S] } @Override
public boolean isFull () { return true ; MST[ReturnValsMutator]MSP[N] } @Override public int maxSize () { return size () ; }
return new FixedSizeSortedMap <> ( getSortedMap () . headMap ( toKey ) ) ; MST[NonVoidMethodCallMutator]MSP[S] } @Override public SortedMap < K , V > tailMap ( final K fromKey ) { return new FixedSizeSortedMap <> ( getSortedMap () . tailMap ( fromKey ) ) ; } @Override
public Set < K > keySet () { return UnmodifiableSet . unmodifiableSet ( map . keySet () ) ; MST[ReturnValsMutator]MSP[S] } @Override public Collection < V > values () { return UnmodifiableCollection . unmodifiableCollection ( map . values () ) ; } @Override
return new FixedSizeSortedMap <> ( getSortedMap () . headMap ( toKey ) ) ; } @Override public SortedMap < K , V > tailMap ( final K fromKey ) { return new FixedSizeSortedMap <> ( getSortedMap () . tailMap ( fromKey ) ) ; MST[NullReturnValsMutator]MSP[S] } @Override
public boolean isFull () { return true ; MST[rv.CRCR2Mutator]MSP[N] } @Override public int maxSize () { return size () ; }
public boolean isFull () { return true ; } @Override public int maxSize () { return size () ; MST[ReturnValsMutator]MSP[N] }
return ( SortedMap < K , V > ) map ; MST[NullReturnValsMutator]MSP[S] } private void writeObject ( final ObjectOutputStream out ) throws IOException { out . defaultWriteObject () ; out . writeObject ( map ) ; } @SuppressWarnings ( lr_1 )
return new FixedSizeSortedMap <> ( getSortedMap () . headMap ( toKey ) ) ; } @Override public SortedMap < K , V > tailMap ( final K fromKey ) { return new FixedSizeSortedMap <> ( getSortedMap () . tailMap ( fromKey ) ) ; MST[ConstructorCallMutator]MSP[S] } @Override
if ( CollectionUtils . isSubCollection ( mapToCopy . keySet () , keySet () ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] throw new IllegalArgumentException ( lr_2 ) ; } map . putAll ( mapToCopy ) ; } @Override public void clear () { throw new UnsupportedOperationException ( lr_3 ) ; } @Override
return new FixedSizeSortedMap <> ( getSortedMap () . headMap ( toKey ) ) ; } @Override public SortedMap < K , V > tailMap ( final K fromKey ) { return new FixedSizeSortedMap <> ( getSortedMap () . tailMap ( fromKey ) ) ; MST[NonVoidMethodCallMutator]MSP[S] } @Override
public boolean isFull () { return true ; MST[rv.CRCR4Mutator]MSP[S] } @Override public int maxSize () { return size () ; }
public boolean isFull () { return true ; MST[rv.CRCR6Mutator]MSP[N] } @Override public int maxSize () { return size () ; }
if ( CollectionUtils . isSubCollection ( mapToCopy . keySet () , keySet () ) ) { MST[NegateConditionalsMutator]MSP[N] throw new IllegalArgumentException ( lr_2 ) ; } map . putAll ( mapToCopy ) ; } @Override public void clear () { throw new UnsupportedOperationException ( lr_3 ) ; } @Override
return new FixedSizeSortedMap <> ( getSortedMap () . headMap ( toKey ) ) ; } @Override public SortedMap < K , V > tailMap ( final K fromKey ) { return new FixedSizeSortedMap <> ( getSortedMap () . tailMap ( fromKey ) ) ; MST[experimental.NakedReceiverMutator]MSP[S] } @Override
public V remove ( final Object key ) { throw new UnsupportedOperationException ( lr_3 ) ; } @Override public Set < Map . Entry < K , V > > entrySet () { return UnmodifiableSet . unmodifiableSet ( map . entrySet () ) ; MST[EmptyObjectReturnValsMutator]MSP[S] } @Override
if ( CollectionUtils . isSubCollection ( mapToCopy . keySet () , keySet () ) ) { throw new IllegalArgumentException ( lr_2 ) ; } map . putAll ( mapToCopy ) ; } @Override public void clear () { throw new UnsupportedOperationException ( lr_3 ) ; MST[ConstructorCallMutator]MSP[S] } @Override
public Set < K > keySet () { return UnmodifiableSet . unmodifiableSet ( map . keySet () ) ; MST[ArgumentPropagationMutator]MSP[S] } @Override public Collection < V > values () { return UnmodifiableCollection . unmodifiableCollection ( map . values () ) ; } @Override
return new FixedSizeSortedMap <> ( getSortedMap () . headMap ( toKey ) ) ; } @Override public SortedMap < K , V > tailMap ( final K fromKey ) { return new FixedSizeSortedMap <> ( getSortedMap () . tailMap ( fromKey ) ) ; MST[NonVoidMethodCallMutator]MSP[S] } @Override
public Set < K > keySet () { return UnmodifiableSet . unmodifiableSet ( map . keySet () ) ; MST[NonVoidMethodCallMutator]MSP[S] } @Override public Collection < V > values () { return UnmodifiableCollection . unmodifiableCollection ( map . values () ) ; } @Override
public boolean isFull () { return true ; MST[BooleanFalseReturnValsMutator]MSP[N] } @Override public int maxSize () { return size () ; }
return new FixedSizeSortedMap <> ( getSortedMap () . headMap ( toKey ) ) ; MST[ReturnValsMutator]MSP[S] } @Override public SortedMap < K , V > tailMap ( final K fromKey ) { return new FixedSizeSortedMap <> ( getSortedMap () . tailMap ( fromKey ) ) ; } @Override
public SortedMap < K , V > subMap ( final K fromKey , final K toKey ) { return new FixedSizeSortedMap <> ( getSortedMap () . subMap ( fromKey , toKey ) ) ; MST[NonVoidMethodCallMutator]MSP[S] } @Override public SortedMap < K , V > headMap ( final K toKey ) {
return new FixedSizeSortedMap <> ( getSortedMap () . headMap ( toKey ) ) ; MST[ConstructorCallMutator]MSP[S] } @Override public SortedMap < K , V > tailMap ( final K fromKey ) { return new FixedSizeSortedMap <> ( getSortedMap () . tailMap ( fromKey ) ) ; } @Override
public static < K , V > FixedSizeSortedMap < K , V > fixedSizeSortedMap ( final SortedMap < K , V > map ) { return new FixedSizeSortedMap <> ( map ) ; MST[NullReturnValsMutator]MSP[S] } protected SortedMap < K , V > getSortedMap () {
public Set < K > keySet () { return UnmodifiableSet . unmodifiableSet ( map . keySet () ) ; } @Override public Collection < V > values () { return UnmodifiableCollection . unmodifiableCollection ( map . values () ) ; MST[ReturnValsMutator]MSP[N] } @Override
public V remove ( final Object key ) { throw new UnsupportedOperationException ( lr_3 ) ; } @Override public Set < Map . Entry < K , V > > entrySet () { return UnmodifiableSet . unmodifiableSet ( map . entrySet () ) ; MST[NonVoidMethodCallMutator]MSP[S] } @Override
if ( CollectionUtils . isSubCollection ( mapToCopy . keySet () , keySet () ) ) { MST[NonVoidMethodCallMutator]MSP[N] throw new IllegalArgumentException ( lr_2 ) ; } map . putAll ( mapToCopy ) ; } @Override public void clear () { throw new UnsupportedOperationException ( lr_3 ) ; } @Override
public boolean isFull () { return true ; MST[InlineConstantMutator]MSP[N] } @Override public int maxSize () { return size () ; }
if ( CollectionUtils . isSubCollection ( mapToCopy . keySet () , keySet () ) ) { MST[rv.ROR1Mutator]MSP[S] throw new IllegalArgumentException ( lr_2 ) ; } map . putAll ( mapToCopy ) ; } @Override public void clear () { throw new UnsupportedOperationException ( lr_3 ) ; } @Override
public V remove ( final Object key ) { throw new UnsupportedOperationException ( lr_3 ) ; } @Override public Set < Map . Entry < K , V > > entrySet () { return UnmodifiableSet . unmodifiableSet ( map . entrySet () ) ; MST[ArgumentPropagationMutator]MSP[S] } @Override
if ( CollectionUtils . isSubCollection ( mapToCopy . keySet () , keySet () ) ) { MST[rv.ROR2Mutator]MSP[S] throw new IllegalArgumentException ( lr_2 ) ; } map . putAll ( mapToCopy ) ; } @Override public void clear () { throw new UnsupportedOperationException ( lr_3 ) ; } @Override
if ( CollectionUtils . isSubCollection ( mapToCopy . keySet () , keySet () ) ) { throw new IllegalArgumentException ( lr_2 ) ; MST[ConstructorCallMutator]MSP[S] } map . putAll ( mapToCopy ) ; } @Override public void clear () { throw new UnsupportedOperationException ( lr_3 ) ; } @Override
if ( CollectionUtils . isSubCollection ( mapToCopy . keySet () , keySet () ) ) { MST[rv.ROR4Mutator]MSP[N] throw new IllegalArgumentException ( lr_2 ) ; } map . putAll ( mapToCopy ) ; } @Override public void clear () { throw new UnsupportedOperationException ( lr_3 ) ; } @Override
return new FixedSizeSortedMap <> ( getSortedMap () . headMap ( toKey ) ) ; MST[experimental.NakedReceiverMutator]MSP[S] } @Override public SortedMap < K , V > tailMap ( final K fromKey ) { return new FixedSizeSortedMap <> ( getSortedMap () . tailMap ( fromKey ) ) ; } @Override
if ( CollectionUtils . isSubCollection ( mapToCopy . keySet () , keySet () ) ) { MST[rv.ROR5Mutator]MSP[N] throw new IllegalArgumentException ( lr_2 ) ; } map . putAll ( mapToCopy ) ; } @Override public void clear () { throw new UnsupportedOperationException ( lr_3 ) ; } @Override
if ( CollectionUtils . isSubCollection ( mapToCopy . keySet () , keySet () ) ) { MST[rv.ROR3Mutator]MSP[N] throw new IllegalArgumentException ( lr_2 ) ; } map . putAll ( mapToCopy ) ; } @Override public void clear () { throw new UnsupportedOperationException ( lr_3 ) ; } @Override
public SortedMap < K , V > subMap ( final K fromKey , final K toKey ) { return new FixedSizeSortedMap <> ( getSortedMap () . subMap ( fromKey , toKey ) ) ; MST[NullReturnValsMutator]MSP[S] } @Override public SortedMap < K , V > headMap ( final K toKey ) {
public V remove ( final Object key ) { throw new UnsupportedOperationException ( lr_3 ) ; } @Override public Set < Map . Entry < K , V > > entrySet () { return UnmodifiableSet . unmodifiableSet ( map . entrySet () ) ; MST[ReturnValsMutator]MSP[S] } @Override
public Set < K > keySet () { return UnmodifiableSet . unmodifiableSet ( map . keySet () ) ; } @Override public Collection < V > values () { return UnmodifiableCollection . unmodifiableCollection ( map . values () ) ; MST[NonVoidMethodCallMutator]MSP[N] } @Override
public SortedMap < K , V > subMap ( final K fromKey , final K toKey ) { return new FixedSizeSortedMap <> ( getSortedMap () . subMap ( fromKey , toKey ) ) ; MST[ConstructorCallMutator]MSP[S] } @Override public SortedMap < K , V > headMap ( final K toKey ) {
public SortedMap < K , V > subMap ( final K fromKey , final K toKey ) { return new FixedSizeSortedMap <> ( getSortedMap () . subMap ( fromKey , toKey ) ) ; MST[experimental.NakedReceiverMutator]MSP[S] } @Override public SortedMap < K , V > headMap ( final K toKey ) {
return ( SortedMap < K , V > ) map ; MST[ReturnValsMutator]MSP[S] } private void writeObject ( final ObjectOutputStream out ) throws IOException { out . defaultWriteObject () ; out . writeObject ( map ) ; } @SuppressWarnings ( lr_1 )
return new FixedSizeSortedMap <> ( getSortedMap () . headMap ( toKey ) ) ; } @Override public SortedMap < K , V > tailMap ( final K fromKey ) { return new FixedSizeSortedMap <> ( getSortedMap () . tailMap ( fromKey ) ) ; MST[ReturnValsMutator]MSP[S] } @Override
return new FixedSizeSortedMap <> ( getSortedMap () . headMap ( toKey ) ) ; MST[NonVoidMethodCallMutator]MSP[S] } @Override public SortedMap < K , V > tailMap ( final K fromKey ) { return new FixedSizeSortedMap <> ( getSortedMap () . tailMap ( fromKey ) ) ; } @Override
public boolean isFull () { return true ; } @Override public int maxSize () { return size () ; MST[PrimitiveReturnsMutator]MSP[N] }
public SortedMap < K , V > subMap ( final K fromKey , final K toKey ) { return new FixedSizeSortedMap <> ( getSortedMap () . subMap ( fromKey , toKey ) ) ; MST[ReturnValsMutator]MSP[S] } @Override public SortedMap < K , V > headMap ( final K toKey ) {
public boolean isFull () { return true ; MST[rv.CRCR5Mutator]MSP[N] } @Override public int maxSize () { return size () ; }
public boolean isFull () { return true ; MST[rv.CRCR3Mutator]MSP[S] } @Override public int maxSize () { return size () ; }
public boolean isFull () { return true ; } @Override public int maxSize () { return size () ; MST[NonVoidMethodCallMutator]MSP[N] }
return new FixedSizeSortedMap <> ( getSortedMap () . headMap ( toKey ) ) ; MST[NullReturnValsMutator]MSP[S] } @Override public SortedMap < K , V > tailMap ( final K fromKey ) { return new FixedSizeSortedMap <> ( getSortedMap () . tailMap ( fromKey ) ) ; } @Override
public Set < K > keySet () { return UnmodifiableSet . unmodifiableSet ( map . keySet () ) ; MST[NonVoidMethodCallMutator]MSP[S] } @Override public Collection < V > values () { return UnmodifiableCollection . unmodifiableCollection ( map . values () ) ; } @Override
if ( CollectionUtils . isSubCollection ( mapToCopy . keySet () , keySet () ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] throw new IllegalArgumentException ( lr_2 ) ; } map . putAll ( mapToCopy ) ; } @Override public void clear () { throw new UnsupportedOperationException ( lr_3 ) ; } @Override
public static < K , V > FixedSizeSortedMap < K , V > fixedSizeSortedMap ( final SortedMap < K , V > map ) { return new FixedSizeSortedMap <> ( map ) ; MST[ConstructorCallMutator]MSP[S] } protected SortedMap < K , V > getSortedMap () {
public SortedMap < K , V > subMap ( final K fromKey , final K toKey ) { return new FixedSizeSortedMap <> ( getSortedMap () . subMap ( fromKey , toKey ) ) ; MST[NonVoidMethodCallMutator]MSP[S] } @Override public SortedMap < K , V > headMap ( final K toKey ) {
public V remove ( final Object key ) { throw new UnsupportedOperationException ( lr_3 ) ; } @Override public Set < Map . Entry < K , V > > entrySet () { return UnmodifiableSet . unmodifiableSet ( map . entrySet () ) ; MST[NonVoidMethodCallMutator]MSP[S] } @Override
