} @Override public boolean hasNext () { return nextIndex < parent . size ; } @Override public K next () { if ( hasNext () == false ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } canRemove = true ; MST[rv.CRCR5Mutator]MSP[S] nextIndex ++ ; return getKey () ;
} @Override public boolean hasNext () { return nextIndex < parent . size ; } @Override public K next () { if ( hasNext () == false ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } canRemove = true ; MST[rv.CRCR3Mutator]MSP[N] nextIndex ++ ; return getKey () ;
} @Override public boolean hasNext () { return nextIndex < parent . size ; } @Override public K next () { if ( hasNext () == false ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } canRemove = true ; nextIndex ++ ; return getKey () ;
throw new IllegalStateException ( lr_1 + nextIndex ) ; } return old ; } @Override public void reset () { nextIndex = 0 ; MST[rv.CRCR6Mutator]MSP[S] canRemove = false ; } @Override public String toString () { if ( canRemove ) {
} @Override public boolean hasNext () { return nextIndex < parent . size ; } @Override public K next () { if ( hasNext () == false ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } canRemove = true ; nextIndex ++ ; return getKey () ;
} @Override public boolean hasNext () { return nextIndex < parent . size ; } @Override public K next () { if ( hasNext () == false ) { MST[NegateConditionalsMutator]MSP[N] throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } canRemove = true ; nextIndex ++ ; return getKey () ;
} @Override public void remove () { if ( canRemove == false ) { MST[rv.ROR1Mutator]MSP[N] throw new IllegalStateException ( AbstractHashedMap . REMOVE_INVALID ) ; } parent . remove ( getKey () ) ; nextIndex -- ; canRemove = false ; } @Override public K getKey () {
} @Override public boolean hasNext () { return nextIndex < parent . size ; MST[rv.CRCR1Mutator]MSP[N] } @Override public K next () { if ( hasNext () == false ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } canRemove = true ; nextIndex ++ ; return getKey () ;
} @Override public void remove () { if ( canRemove == false ) { MST[rv.ROR3Mutator]MSP[N] throw new IllegalStateException ( AbstractHashedMap . REMOVE_INVALID ) ; } parent . remove ( getKey () ) ; nextIndex -- ; canRemove = false ; } @Override public K getKey () {
} @Override MST[experimental.MemberVariableMutator]MSP[N] public boolean hasNext () { return nextIndex < parent . size ; } @Override public K next () { if ( hasNext () == false ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } canRemove = true ; nextIndex ++ ; return getKey () ;
} @Override public boolean hasNext () { return nextIndex < parent . size ; MST[rv.CRCR5Mutator]MSP[N] } @Override public K next () { if ( hasNext () == false ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } canRemove = true ; nextIndex ++ ; return getKey () ;
} @Override public boolean hasNext () { return nextIndex < parent . size ; MST[rv.CRCR3Mutator]MSP[N] } @Override public K next () { if ( hasNext () == false ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } canRemove = true ; nextIndex ++ ; return getKey () ;
if ( canRemove == false ) { throw new IllegalStateException ( AbstractHashedMap . GETKEY_INVALID ) ; } switch ( nextIndex ) { case 3 : return parent . key3 ; case 2 : return parent . key2 ; case 1 : return parent . key1 ; MST[NonVoidMethodCallMutator]MSP[N] }
} @Override public void remove () { if ( canRemove == false ) { MST[rv.ROR5Mutator]MSP[N] throw new IllegalStateException ( AbstractHashedMap . REMOVE_INVALID ) ; } parent . remove ( getKey () ) ; nextIndex -- ; canRemove = false ; } @Override public K getKey () {
} @Override public boolean hasNext () { return nextIndex < parent . size ; MST[NegateConditionalsMutator]MSP[N] } @Override public K next () { if ( hasNext () == false ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } canRemove = true ; nextIndex ++ ; return getKey () ;
} @Override public boolean hasNext () { return nextIndex < parent . size ; } @Override public K next () { if ( hasNext () == false ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } canRemove = true ; nextIndex ++ ; return getKey () ; MST[NonVoidMethodCallMutator]MSP[N]
} @Override public boolean hasNext () { return nextIndex < parent . size ; } @Override public K next () { if ( hasNext () == false ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } canRemove = true ; nextIndex ++ ; MST[rv.CRCR3Mutator]MSP[S] return getKey () ;
if ( canRemove == false ) { throw new IllegalStateException ( AbstractHashedMap . GETKEY_INVALID ) ; } switch ( nextIndex ) { MST[rv.UOI1Mutator]MSP[N] case 3 : return parent . key3 ; case 2 : return parent . key2 ; case 1 : return parent . key1 ; }
throw new IllegalStateException ( lr_1 + nextIndex ) ; } return old ; } @Override public void reset () { nextIndex = 0 ; canRemove = false ; } @Override public String toString () { if ( canRemove ) { MST[rv.ROR1Mutator]MSP[S]
throw new IllegalStateException ( lr_1 + nextIndex ) ; } @Override public V getValue () { if ( canRemove == false ) { MST[rv.ROR2Mutator]MSP[N] throw new IllegalStateException ( AbstractHashedMap . GETVALUE_INVALID ) ; } switch ( nextIndex ) { case 3 : return parent . value3 ; case 2 :
} @Override public boolean hasNext () { return nextIndex < parent . size ; } @Override public K next () { if ( hasNext () == false ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } canRemove = true ; nextIndex ++ ; MST[InlineConstantMutator]MSP[S] return getKey () ;
throw new IllegalStateException ( lr_1 + nextIndex ) ; } return old ; } @Override public void reset () { nextIndex = 0 ; canRemove = false ; } @Override public String toString () { if ( canRemove ) { MST[rv.ROR5Mutator]MSP[S]
} @Override public void remove () { if ( canRemove == false ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] throw new IllegalStateException ( AbstractHashedMap . REMOVE_INVALID ) ; } parent . remove ( getKey () ) ; nextIndex -- ; canRemove = false ; } @Override public K getKey () {
if ( canRemove == false ) { MST[rv.ROR3Mutator]MSP[N] throw new IllegalStateException ( AbstractHashedMap . GETKEY_INVALID ) ; } switch ( nextIndex ) { case 3 : return parent . key3 ; case 2 : return parent . key2 ; case 1 : return parent . key1 ; }
throw new IllegalStateException ( lr_1 + nextIndex ) ; } return old ; } @Override public void reset () { nextIndex = 0 ; canRemove = false ; MST[rv.CRCR5Mutator]MSP[N] } @Override public String toString () { if ( canRemove ) {
} @Override public boolean hasNext () { return nextIndex < parent . size ; } @Override public K next () { if ( hasNext () == false ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; MST[ConstructorCallMutator]MSP[S] } canRemove = true ; nextIndex ++ ; return getKey () ;
throw new IllegalStateException ( lr_1 + nextIndex ) ; } return old ; } @Override public void reset () { nextIndex = 0 ; canRemove = false ; MST[rv.CRCR1Mutator]MSP[N] } @Override public String toString () { if ( canRemove ) {
} @Override public boolean hasNext () { return nextIndex < parent . size ; MST[ReturnValsMutator]MSP[N] } @Override public K next () { if ( hasNext () == false ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } canRemove = true ; nextIndex ++ ; return getKey () ;
} @Override public boolean hasNext () { return nextIndex < parent . size ; } @Override public K next () { if ( hasNext () == false ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } canRemove = true ; nextIndex ++ ; MST[rv.AOR3Mutator]MSP[S] return getKey () ;
if ( canRemove == false ) { throw new IllegalStateException ( AbstractHashedMap . GETKEY_INVALID ) ; } switch ( nextIndex ) { case 3 : return parent . key3 ; case 2 : return parent . key2 ; MST[ReturnValsMutator]MSP[N] case 1 : return parent . key1 ; }
} @Override public boolean hasNext () { return nextIndex < parent . size ; } @Override public K next () { if ( hasNext () == false ) { MST[rv.ROR3Mutator]MSP[N] throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } canRemove = true ; nextIndex ++ ; return getKey () ;
} @Override public boolean hasNext () { return nextIndex < parent . size ; MST[rv.CRCR2Mutator]MSP[N] } @Override public K next () { if ( hasNext () == false ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } canRemove = true ; nextIndex ++ ; return getKey () ;
} @Override public boolean hasNext () { return nextIndex < parent . size ; MST[rv.CRCR6Mutator]MSP[N] } @Override public K next () { if ( hasNext () == false ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } canRemove = true ; nextIndex ++ ; return getKey () ;
if ( canRemove == false ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] throw new IllegalStateException ( AbstractHashedMap . GETKEY_INVALID ) ; } switch ( nextIndex ) { case 3 : return parent . key3 ; case 2 : return parent . key2 ; case 1 : return parent . key1 ; }
} @Override public boolean hasNext () { return nextIndex < parent . size ; MST[rv.ROR3Mutator]MSP[N] } @Override public K next () { if ( hasNext () == false ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } canRemove = true ; nextIndex ++ ; return getKey () ;
if ( canRemove == false ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] throw new IllegalStateException ( AbstractHashedMap . GETKEY_INVALID ) ; } switch ( nextIndex ) { case 3 : return parent . key3 ; case 2 : return parent . key2 ; case 1 : return parent . key1 ; }
throw new IllegalStateException ( lr_1 + nextIndex ) ; } @Override public V getValue () { if ( canRemove == false ) { MST[NegateConditionalsMutator]MSP[N] throw new IllegalStateException ( AbstractHashedMap . GETVALUE_INVALID ) ; } switch ( nextIndex ) { case 3 : return parent . value3 ; case 2 :
} @Override public void remove () { if ( canRemove == false ) { MST[NegateConditionalsMutator]MSP[N] throw new IllegalStateException ( AbstractHashedMap . REMOVE_INVALID ) ; } parent . remove ( getKey () ) ; nextIndex -- ; canRemove = false ; } @Override public K getKey () {
} @Override public boolean hasNext () { return nextIndex < parent . size ; MST[rv.UOI3Mutator]MSP[S] } @Override public K next () { if ( hasNext () == false ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } canRemove = true ; nextIndex ++ ; return getKey () ;
} @Override public boolean hasNext () { return nextIndex < parent . size ; MST[rv.UOI2Mutator]MSP[S] } @Override public K next () { if ( hasNext () == false ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } canRemove = true ; nextIndex ++ ; return getKey () ;
} @Override public boolean hasNext () { return nextIndex < parent . size ; MST[rv.ROR1Mutator]MSP[N] } @Override public K next () { if ( hasNext () == false ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } canRemove = true ; nextIndex ++ ; return getKey () ;
} @Override public boolean hasNext () { return nextIndex < parent . size ; } @Override public K next () { if ( hasNext () == false ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } canRemove = true ; MST[InlineConstantMutator]MSP[S] nextIndex ++ ; return getKey () ;
} @Override public boolean hasNext () { return nextIndex < parent . size ; } @Override public K next () { if ( hasNext () == false ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } canRemove = true ; nextIndex ++ ; MST[rv.AOR4Mutator]MSP[S] return getKey () ;
if ( canRemove == false ) { throw new IllegalStateException ( AbstractHashedMap . GETKEY_INVALID ) ; } switch ( nextIndex ) { MST[rv.UOI4Mutator]MSP[S] case 3 : return parent . key3 ; case 2 : return parent . key2 ; case 1 : return parent . key1 ; }
} @Override public boolean hasNext () { return nextIndex < parent . size ; MST[BooleanTrueReturnValsMutator]MSP[N] } @Override public K next () { if ( hasNext () == false ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } canRemove = true ; nextIndex ++ ; return getKey () ;
} @Override public boolean hasNext () { return nextIndex < parent . size ; } @Override public K next () { if ( hasNext () == false ) { MST[NonVoidMethodCallMutator]MSP[S] throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } canRemove = true ; nextIndex ++ ; return getKey () ;
} @Override public boolean hasNext () { return nextIndex < parent . size ; } @Override public K next () { if ( hasNext () == false ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } canRemove = true ; nextIndex ++ ; MST[rv.AOD1Mutator]MSP[S] return getKey () ;
throw new IllegalStateException ( lr_1 + nextIndex ) ; } return old ; } @Override public void reset () { nextIndex = 0 ; MST[experimental.MemberVariableMutator]MSP[N] canRemove = false ; } @Override public String toString () { if ( canRemove ) {
} @Override public boolean hasNext () { return nextIndex < parent . size ; } @Override public K next () { if ( hasNext () == false ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } canRemove = true ; nextIndex ++ ; MST[rv.UOI4Mutator]MSP[S] return getKey () ;
return parent . value2 ; case 1 : return parent . value1 ; } throw new IllegalStateException ( lr_1 + nextIndex ) ; } @Override public V setValue ( final V value ) { if ( canRemove == false ) { MST[rv.ROR5Mutator]MSP[N] throw new IllegalStateException ( AbstractHashedMap . SETVALUE_INVALID ) ;
} @Override public boolean hasNext () { return nextIndex < parent . size ; MST[InlineConstantMutator]MSP[N] } @Override public K next () { if ( hasNext () == false ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } canRemove = true ; nextIndex ++ ; return getKey () ;
} @Override public boolean hasNext () { return nextIndex < parent . size ; } @Override public K next () { if ( hasNext () == false ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } canRemove = true ; nextIndex ++ ; MST[rv.CRCR5Mutator]MSP[S] return getKey () ;
throw new IllegalStateException ( lr_1 + nextIndex ) ; } return old ; } @Override public void reset () { nextIndex = 0 ; canRemove = false ; } @Override public String toString () { if ( canRemove ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S]
throw new IllegalStateException ( lr_1 + nextIndex ) ; } @Override public V getValue () { if ( canRemove == false ) { MST[rv.ROR4Mutator]MSP[N] throw new IllegalStateException ( AbstractHashedMap . GETVALUE_INVALID ) ; } switch ( nextIndex ) { case 3 : return parent . value3 ; case 2 :
throw new IllegalStateException ( lr_1 + nextIndex ) ; } return old ; } @Override public void reset () { nextIndex = 0 ; canRemove = false ; } @Override public String toString () { if ( canRemove ) { MST[rv.ROR3Mutator]MSP[S]
throw new IllegalStateException ( lr_1 + nextIndex ) ; } return old ; } @Override public void reset () { nextIndex = 0 ; canRemove = false ; } @Override public String toString () { if ( canRemove ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
if ( canRemove == false ) { MST[rv.ROR5Mutator]MSP[S] throw new IllegalStateException ( AbstractHashedMap . GETKEY_INVALID ) ; } switch ( nextIndex ) { case 3 : return parent . key3 ; case 2 : return parent . key2 ; case 1 : return parent . key1 ; }
throw new IllegalStateException ( lr_1 + nextIndex ) ; } @Override public V getValue () { if ( canRemove == false ) { MST[rv.ROR1Mutator]MSP[N] throw new IllegalStateException ( AbstractHashedMap . GETVALUE_INVALID ) ; } switch ( nextIndex ) { case 3 : return parent . value3 ; case 2 :
if ( canRemove == false ) { throw new IllegalStateException ( AbstractHashedMap . GETKEY_INVALID ) ; } switch ( nextIndex ) { case 3 : return parent . key3 ; MST[ReturnValsMutator]MSP[N] case 2 : return parent . key2 ; case 1 : return parent . key1 ; }
} @Override public boolean hasNext () { return nextIndex < parent . size ; } @Override public K next () { if ( hasNext () == false ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } canRemove = true ; nextIndex ++ ; MST[rv.AOR1Mutator]MSP[S] return getKey () ;
throw new IllegalStateException ( lr_1 + nextIndex ) ; } return old ; } @Override public void reset () { nextIndex = 0 ; MST[InlineConstantMutator]MSP[N] canRemove = false ; } @Override public String toString () { if ( canRemove ) {
} @Override public boolean hasNext () { return nextIndex < parent . size ; } @Override public K next () { if ( hasNext () == false ) { MST[rv.ROR5Mutator]MSP[N] throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } canRemove = true ; nextIndex ++ ; return getKey () ;
} @Override public boolean hasNext () { return nextIndex < parent . size ; } @Override public K next () { if ( hasNext () == false ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } canRemove = true ; nextIndex ++ ; MST[rv.UOI1Mutator]MSP[N] return getKey () ;
} @Override public void remove () { if ( canRemove == false ) { MST[rv.ROR4Mutator]MSP[N] throw new IllegalStateException ( AbstractHashedMap . REMOVE_INVALID ) ; } parent . remove ( getKey () ) ; nextIndex -- ; canRemove = false ; } @Override public K getKey () {
} @Override public boolean hasNext () { return nextIndex < parent . size ; } @Override public K next () { if ( hasNext () == false ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } canRemove = true ; nextIndex ++ ; MST[rv.ABSMutator]MSP[S] return getKey () ;
return parent . value2 ; case 1 : return parent . value1 ; } throw new IllegalStateException ( lr_1 + nextIndex ) ; } @Override public V setValue ( final V value ) { if ( canRemove == false ) { MST[rv.ROR2Mutator]MSP[N] throw new IllegalStateException ( AbstractHashedMap . SETVALUE_INVALID ) ;
return lr_2 + getKey () + lr_3 + getValue () + lr_4 ; } return lr_5 ; MST[EmptyObjectReturnValsMutator]MSP[S] } @Override public Set < Map . Entry < K , V > > entrySet () { if ( delegateMap != null ) { return delegateMap . entrySet () ; }
} @Override public boolean hasNext () { return nextIndex < parent . size ; } @Override public K next () { if ( hasNext () == false ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } canRemove = true ; MST[rv.CRCR6Mutator]MSP[S] nextIndex ++ ; return getKey () ;
throw new IllegalStateException ( lr_1 + nextIndex ) ; } return old ; } @Override public void reset () { nextIndex = 0 ; MST[rv.CRCR3Mutator]MSP[S] canRemove = false ; } @Override public String toString () { if ( canRemove ) {
throw new IllegalStateException ( lr_1 + nextIndex ) ; } return old ; } @Override public void reset () { nextIndex = 0 ; MST[rv.CRCR1Mutator]MSP[N] canRemove = false ; } @Override public String toString () { if ( canRemove ) {
} @Override public boolean hasNext () { return nextIndex < parent . size ; } @Override public K next () { if ( hasNext () == false ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } canRemove = true ; MST[rv.CRCR4Mutator]MSP[N] nextIndex ++ ; return getKey () ;
return lr_2 + getKey () + lr_3 + getValue () + lr_4 ; } return lr_5 ; MST[ReturnValsMutator]MSP[S] } @Override public Set < Map . Entry < K , V > > entrySet () { if ( delegateMap != null ) { return delegateMap . entrySet () ; }
return parent . value2 ; case 1 : return parent . value1 ; } throw new IllegalStateException ( lr_1 + nextIndex ) ; } @Override public V setValue ( final V value ) { if ( canRemove == false ) { throw new IllegalStateException ( AbstractHashedMap . SETVALUE_INVALID ) ; MST[ConstructorCallMutator]MSP[S]
throw new IllegalStateException ( lr_1 + nextIndex ) ; } return old ; } @Override public void reset () { nextIndex = 0 ; MST[rv.CRCR5Mutator]MSP[N] canRemove = false ; } @Override public String toString () { if ( canRemove ) {
} @Override public boolean hasNext () { return nextIndex < parent . size ; MST[NonVoidMethodCallMutator]MSP[N] } @Override public K next () { if ( hasNext () == false ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } canRemove = true ; nextIndex ++ ; return getKey () ;
} @Override public boolean hasNext () { return nextIndex < parent . size ; } @Override public K next () { if ( hasNext () == false ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } canRemove = true ; MST[rv.CRCR2Mutator]MSP[S] nextIndex ++ ; return getKey () ;
if ( canRemove == false ) { throw new IllegalStateException ( AbstractHashedMap . GETKEY_INVALID ) ; } switch ( nextIndex ) { case 3 : return parent . key3 ; MST[NullReturnValsMutator]MSP[N] case 2 : return parent . key2 ; case 1 : return parent . key1 ; }
throw new IllegalStateException ( lr_1 + nextIndex ) ; } return old ; } @Override public void reset () { nextIndex = 0 ; canRemove = false ; MST[InlineConstantMutator]MSP[N] } @Override public String toString () { if ( canRemove ) {
} @Override public boolean hasNext () { return nextIndex < parent . size ; } @Override public K next () { if ( hasNext () == false ) { MST[rv.ROR4Mutator]MSP[S] throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } canRemove = true ; nextIndex ++ ; return getKey () ;
} @Override public boolean hasNext () { return nextIndex < parent . size ; } @Override public K next () { if ( hasNext () == false ) { MST[rv.ROR2Mutator]MSP[N] throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } canRemove = true ; nextIndex ++ ; return getKey () ;
} @Override public boolean hasNext () { return nextIndex < parent . size ; MST[rv.CRCR5Mutator]MSP[N] } @Override public K next () { if ( hasNext () == false ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } canRemove = true ; nextIndex ++ ; return getKey () ;
} @Override public boolean hasNext () { return nextIndex < parent . size ; MST[rv.CRCR3Mutator]MSP[N] } @Override public K next () { if ( hasNext () == false ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } canRemove = true ; nextIndex ++ ; return getKey () ;
if ( canRemove == false ) { throw new IllegalStateException ( AbstractHashedMap . GETKEY_INVALID ) ; MST[ConstructorCallMutator]MSP[S] } switch ( nextIndex ) { case 3 : return parent . key3 ; case 2 : return parent . key2 ; case 1 : return parent . key1 ; }
} @Override public boolean hasNext () { return nextIndex < parent . size ; } @Override public K next () { if ( hasNext () == false ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } canRemove = true ; nextIndex ++ ; return getKey () ; MST[ReturnValsMutator]MSP[S]
return parent . value2 ; case 1 : return parent . value1 ; } throw new IllegalStateException ( lr_1 + nextIndex ) ; } @Override public V setValue ( final V value ) { if ( canRemove == false ) { MST[NegateConditionalsMutator]MSP[N] throw new IllegalStateException ( AbstractHashedMap . SETVALUE_INVALID ) ;
throw new IllegalStateException ( lr_1 + nextIndex ) ; } @Override public V getValue () { if ( canRemove == false ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] throw new IllegalStateException ( AbstractHashedMap . GETVALUE_INVALID ) ; } switch ( nextIndex ) { case 3 : return parent . value3 ; case 2 :
} @Override public boolean hasNext () { return nextIndex < parent . size ; } @Override public K next () { if ( hasNext () == false ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } canRemove = true ; nextIndex ++ ; MST[experimental.MemberVariableMutator]MSP[S] return getKey () ;
if ( canRemove == false ) { throw new IllegalStateException ( AbstractHashedMap . GETKEY_INVALID ) ; } switch ( nextIndex ) { case 3 : return parent . key3 ; MST[NonVoidMethodCallMutator]MSP[N] case 2 : return parent . key2 ; case 1 : return parent . key1 ; }
} @Override public boolean hasNext () { return nextIndex < parent . size ; } @Override public K next () { if ( hasNext () == false ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } canRemove = true ; nextIndex ++ ; MST[rv.CRCR6Mutator]MSP[S] return getKey () ;
} @Override public boolean hasNext () { return nextIndex < parent . size ; } @Override public K next () { if ( hasNext () == false ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } canRemove = true ; MST[experimental.MemberVariableMutator]MSP[S] nextIndex ++ ; return getKey () ;
} @Override public boolean hasNext () { return nextIndex < parent . size ; } @Override public K next () { if ( hasNext () == false ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } canRemove = true ; nextIndex ++ ; MST[rv.CRCR2Mutator]MSP[S] return getKey () ;
throw new IllegalStateException ( lr_1 + nextIndex ) ; } @Override public V getValue () { if ( canRemove == false ) { MST[rv.ROR3Mutator]MSP[N] throw new IllegalStateException ( AbstractHashedMap . GETVALUE_INVALID ) ; } switch ( nextIndex ) { case 3 : return parent . value3 ; case 2 :
throw new IllegalStateException ( lr_1 + nextIndex ) ; } return old ; } @Override public void reset () { nextIndex = 0 ; canRemove = false ; } @Override public String toString () { if ( canRemove ) { MST[rv.ROR4Mutator]MSP[N]
} @Override public boolean hasNext () { return nextIndex < parent . size ; MST[RemoveConditionalMutator_ORDER_IF]MSP[N] } @Override public K next () { if ( hasNext () == false ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } canRemove = true ; nextIndex ++ ; return getKey () ;
if ( canRemove == false ) { throw new IllegalStateException ( AbstractHashedMap . GETKEY_INVALID ) ; } switch ( nextIndex ) { case 3 : return parent . key3 ; case 2 : return parent . key2 ; MST[NullReturnValsMutator]MSP[N] case 1 : return parent . key1 ; }
} @Override public boolean hasNext () { return nextIndex < parent . size ; } @Override public K next () { if ( hasNext () == false ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } canRemove = true ; nextIndex ++ ; MST[MathMutator]MSP[S] return getKey () ;
if ( canRemove == false ) { MST[rv.ROR2Mutator]MSP[S] throw new IllegalStateException ( AbstractHashedMap . GETKEY_INVALID ) ; } switch ( nextIndex ) { case 3 : return parent . key3 ; case 2 : return parent . key2 ; case 1 : return parent . key1 ; }
} @Override MST[rv.CRCR1Mutator]MSP[S] public boolean hasNext () { return nextIndex < parent . size ; } @Override public K next () { if ( hasNext () == false ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } canRemove = true ; nextIndex ++ ; return getKey () ;
} @Override public void remove () { if ( canRemove == false ) { MST[rv.ROR2Mutator]MSP[N] throw new IllegalStateException ( AbstractHashedMap . REMOVE_INVALID ) ; } parent . remove ( getKey () ) ; nextIndex -- ; canRemove = false ; } @Override public K getKey () {
} @Override public boolean hasNext () { return nextIndex < parent . size ; MST[rv.CRCR6Mutator]MSP[N] } @Override public K next () { if ( hasNext () == false ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } canRemove = true ; nextIndex ++ ; return getKey () ;
} @Override public boolean hasNext () { return nextIndex < parent . size ; } @Override public K next () { if ( hasNext () == false ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } canRemove = true ; nextIndex ++ ; MST[rv.UOI3Mutator]MSP[S] return getKey () ;
} @Override MST[rv.CRCR5Mutator]MSP[S] public boolean hasNext () { return nextIndex < parent . size ; } @Override public K next () { if ( hasNext () == false ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } canRemove = true ; nextIndex ++ ; return getKey () ;
} @Override public boolean hasNext () { return nextIndex < parent . size ; MST[ConditionalsBoundaryMutator]MSP[N] } @Override public K next () { if ( hasNext () == false ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } canRemove = true ; nextIndex ++ ; return getKey () ;
return parent . value2 ; case 1 : return parent . value1 ; } throw new IllegalStateException ( lr_1 + nextIndex ) ; } @Override public V setValue ( final V value ) { if ( canRemove == false ) { MST[rv.ROR4Mutator]MSP[N] throw new IllegalStateException ( AbstractHashedMap . SETVALUE_INVALID ) ;
} @Override public boolean hasNext () { return nextIndex < parent . size ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] } @Override public K next () { if ( hasNext () == false ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } canRemove = true ; nextIndex ++ ; return getKey () ;
if ( canRemove == false ) { throw new IllegalStateException ( AbstractHashedMap . GETKEY_INVALID ) ; } switch ( nextIndex ) { MST[experimental.RemoveSwitchMutator_0]MSP[S] case 3 : return parent . key3 ; case 2 : return parent . key2 ; case 1 : return parent . key1 ; }
} @Override public boolean hasNext () { return nextIndex < parent . size ; MST[rv.ROR4Mutator]MSP[N] } @Override public K next () { if ( hasNext () == false ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } canRemove = true ; nextIndex ++ ; return getKey () ;
if ( canRemove == false ) { throw new IllegalStateException ( AbstractHashedMap . GETKEY_INVALID ) ; } switch ( nextIndex ) { MST[experimental.RemoveSwitchMutator_1]MSP[S] case 3 : return parent . key3 ; case 2 : return parent . key2 ; case 1 : return parent . key1 ; }
if ( canRemove == false ) { throw new IllegalStateException ( AbstractHashedMap . GETKEY_INVALID ) ; } switch ( nextIndex ) { MST[experimental.RemoveSwitchMutator_2]MSP[S] case 3 : return parent . key3 ; case 2 : return parent . key2 ; case 1 : return parent . key1 ; }
return parent . value2 ; case 1 : return parent . value1 ; } throw new IllegalStateException ( lr_1 + nextIndex ) ; } @Override public V setValue ( final V value ) { if ( canRemove == false ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] throw new IllegalStateException ( AbstractHashedMap . SETVALUE_INVALID ) ;
throw new IllegalStateException ( lr_1 + nextIndex ) ; } return old ; } @Override public void reset () { nextIndex = 0 ; canRemove = false ; MST[experimental.MemberVariableMutator]MSP[N] } @Override public String toString () { if ( canRemove ) {
} @Override public boolean hasNext () { return nextIndex < parent . size ; MST[rv.UOI4Mutator]MSP[N] } @Override public K next () { if ( hasNext () == false ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } canRemove = true ; nextIndex ++ ; return getKey () ;
} @Override public boolean hasNext () { return nextIndex < parent . size ; MST[rv.UOI1Mutator]MSP[S] } @Override public K next () { if ( hasNext () == false ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } canRemove = true ; nextIndex ++ ; return getKey () ;
if ( canRemove == false ) { throw new IllegalStateException ( AbstractHashedMap . GETKEY_INVALID ) ; } switch ( nextIndex ) { MST[rv.ABSMutator]MSP[S] case 3 : return parent . key3 ; case 2 : return parent . key2 ; case 1 : return parent . key1 ; }
} @Override public boolean hasNext () { return nextIndex < parent . size ; MST[rv.ROR2Mutator]MSP[N] } @Override public K next () { if ( hasNext () == false ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } canRemove = true ; nextIndex ++ ; return getKey () ;
} @Override public boolean hasNext () { return nextIndex < parent . size ; MST[rv.ROR5Mutator]MSP[N] } @Override public K next () { if ( hasNext () == false ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } canRemove = true ; nextIndex ++ ; return getKey () ;
throw new IllegalStateException ( lr_1 + nextIndex ) ; } return old ; } @Override public void reset () { nextIndex = 0 ; canRemove = false ; } @Override public String toString () { if ( canRemove ) { MST[NegateConditionalsMutator]MSP[S]
} @Override public boolean hasNext () { return nextIndex < parent . size ; } @Override public K next () { if ( hasNext () == false ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } canRemove = true ; nextIndex ++ ; MST[rv.AOR2Mutator]MSP[S] return getKey () ;
return parent . value2 ; case 1 : return parent . value1 ; } throw new IllegalStateException ( lr_1 + nextIndex ) ; } @Override public V setValue ( final V value ) { if ( canRemove == false ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] throw new IllegalStateException ( AbstractHashedMap . SETVALUE_INVALID ) ;
if ( canRemove == false ) { throw new IllegalStateException ( AbstractHashedMap . GETKEY_INVALID ) ; } switch ( nextIndex ) { case 3 : return parent . key3 ; case 2 : return parent . key2 ; case 1 : return parent . key1 ; MST[ReturnValsMutator]MSP[S] }
throw new IllegalStateException ( lr_1 + nextIndex ) ; } @Override public V getValue () { if ( canRemove == false ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] throw new IllegalStateException ( AbstractHashedMap . GETVALUE_INVALID ) ; } switch ( nextIndex ) { case 3 : return parent . value3 ; case 2 :
return parent . value2 ; case 1 : return parent . value1 ; } throw new IllegalStateException ( lr_1 + nextIndex ) ; } @Override public V setValue ( final V value ) { if ( canRemove == false ) { MST[rv.ROR1Mutator]MSP[N] throw new IllegalStateException ( AbstractHashedMap . SETVALUE_INVALID ) ;
} @Override public boolean hasNext () { return nextIndex < parent . size ; } @Override public K next () { if ( hasNext () == false ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } canRemove = true ; nextIndex ++ ; MST[rv.UOI2Mutator]MSP[N] return getKey () ;
} @Override MST[rv.CRCR6Mutator]MSP[S] public boolean hasNext () { return nextIndex < parent . size ; } @Override public K next () { if ( hasNext () == false ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } canRemove = true ; nextIndex ++ ; return getKey () ;
throw new IllegalStateException ( lr_1 + nextIndex ) ; } @Override public V getValue () { if ( canRemove == false ) { throw new IllegalStateException ( AbstractHashedMap . GETVALUE_INVALID ) ; MST[ConstructorCallMutator]MSP[S] } switch ( nextIndex ) { case 3 : return parent . value3 ; case 2 :
} @Override public boolean hasNext () { return nextIndex < parent . size ; MST[InlineConstantMutator]MSP[N] } @Override public K next () { if ( hasNext () == false ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } canRemove = true ; nextIndex ++ ; return getKey () ;
return parent . value2 ; case 1 : return parent . value1 ; } throw new IllegalStateException ( lr_1 + nextIndex ) ; } @Override public V setValue ( final V value ) { if ( canRemove == false ) { MST[rv.ROR3Mutator]MSP[N] throw new IllegalStateException ( AbstractHashedMap . SETVALUE_INVALID ) ;
throw new IllegalStateException ( lr_1 + nextIndex ) ; } return old ; } @Override public void reset () { nextIndex = 0 ; canRemove = false ; MST[rv.CRCR3Mutator]MSP[N] } @Override public String toString () { if ( canRemove ) {
} @Override public boolean hasNext () { return nextIndex < parent . size ; MST[rv.ABSMutator]MSP[S] } @Override public K next () { if ( hasNext () == false ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } canRemove = true ; nextIndex ++ ; return getKey () ;
} @Override public boolean hasNext () { return nextIndex < parent . size ; } @Override public K next () { if ( hasNext () == false ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } canRemove = true ; nextIndex ++ ; MST[rv.CRCR4Mutator]MSP[S] return getKey () ;
if ( canRemove == false ) { MST[rv.ROR1Mutator]MSP[S] throw new IllegalStateException ( AbstractHashedMap . GETKEY_INVALID ) ; } switch ( nextIndex ) { case 3 : return parent . key3 ; case 2 : return parent . key2 ; case 1 : return parent . key1 ; }
throw new IllegalStateException ( lr_1 + nextIndex ) ; } @Override public V getValue () { if ( canRemove == false ) { MST[rv.ROR5Mutator]MSP[N] throw new IllegalStateException ( AbstractHashedMap . GETVALUE_INVALID ) ; } switch ( nextIndex ) { case 3 : return parent . value3 ; case 2 :
throw new IllegalStateException ( lr_1 + nextIndex ) ; } return old ; } @Override public void reset () { nextIndex = 0 ; canRemove = false ; } @Override public String toString () { if ( canRemove ) { MST[rv.ROR2Mutator]MSP[N]
if ( canRemove == false ) { throw new IllegalStateException ( AbstractHashedMap . GETKEY_INVALID ) ; } switch ( nextIndex ) { MST[experimental.SwitchMutator]MSP[S] case 3 : return parent . key3 ; case 2 : return parent . key2 ; case 1 : return parent . key1 ; }
if ( canRemove == false ) { throw new IllegalStateException ( AbstractHashedMap . GETKEY_INVALID ) ; } switch ( nextIndex ) { MST[rv.UOI3Mutator]MSP[S] case 3 : return parent . key3 ; case 2 : return parent . key2 ; case 1 : return parent . key1 ; }
} @Override public void remove () { if ( canRemove == false ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] throw new IllegalStateException ( AbstractHashedMap . REMOVE_INVALID ) ; } parent . remove ( getKey () ) ; nextIndex -- ; canRemove = false ; } @Override public K getKey () {
} @Override public void remove () { if ( canRemove == false ) { throw new IllegalStateException ( AbstractHashedMap . REMOVE_INVALID ) ; MST[ConstructorCallMutator]MSP[S] } parent . remove ( getKey () ) ; nextIndex -- ; canRemove = false ; } @Override public K getKey () {
if ( canRemove == false ) { MST[rv.ROR4Mutator]MSP[N] throw new IllegalStateException ( AbstractHashedMap . GETKEY_INVALID ) ; } switch ( nextIndex ) { case 3 : return parent . key3 ; case 2 : return parent . key2 ; case 1 : return parent . key1 ; }
throw new IllegalStateException ( lr_1 + nextIndex ) ; } return old ; } @Override public void reset () { nextIndex = 0 ; canRemove = false ; MST[rv.CRCR6Mutator]MSP[N] } @Override public String toString () { if ( canRemove ) {
if ( canRemove == false ) { MST[NegateConditionalsMutator]MSP[S] throw new IllegalStateException ( AbstractHashedMap . GETKEY_INVALID ) ; } switch ( nextIndex ) { case 3 : return parent . key3 ; case 2 : return parent . key2 ; case 1 : return parent . key1 ; }
if ( canRemove == false ) { throw new IllegalStateException ( AbstractHashedMap . GETKEY_INVALID ) ; } switch ( nextIndex ) { case 3 : return parent . key3 ; case 2 : return parent . key2 ; case 1 : return parent . key1 ; MST[NullReturnValsMutator]MSP[N] }
} @Override MST[rv.CRCR3Mutator]MSP[S] public boolean hasNext () { return nextIndex < parent . size ; } @Override public K next () { if ( hasNext () == false ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } canRemove = true ; nextIndex ++ ; return getKey () ;
} @Override public boolean hasNext () { return nextIndex < parent . size ; MST[rv.CRCR4Mutator]MSP[N] } @Override public K next () { if ( hasNext () == false ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } canRemove = true ; nextIndex ++ ; return getKey () ;
} @Override public boolean hasNext () { return nextIndex < parent . size ; } @Override public K next () { if ( hasNext () == false ) { MST[rv.ROR1Mutator]MSP[S] throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } canRemove = true ; nextIndex ++ ; return getKey () ;
} @Override public boolean hasNext () { return nextIndex < parent . size ; } @Override public K next () { if ( hasNext () == false ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } canRemove = true ; nextIndex ++ ; return getKey () ; MST[NullReturnValsMutator]MSP[N]
} @Override MST[InlineConstantMutator]MSP[S] public boolean hasNext () { return nextIndex < parent . size ; } @Override public K next () { if ( hasNext () == false ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } canRemove = true ; nextIndex ++ ; return getKey () ;
if ( canRemove == false ) { throw new IllegalStateException ( AbstractHashedMap . GETKEY_INVALID ) ; } switch ( nextIndex ) { case 3 : return parent . key3 ; case 2 : return parent . key2 ; MST[NonVoidMethodCallMutator]MSP[N] case 1 : return parent . key1 ; }
return parent . delegateMap . entrySet () . iterator () ; } if ( parent . size () == 0 ) { MST[rv.ROR2Mutator]MSP[N] return EmptyIterator . < Map . Entry < K , V > > emptyIterator () ; } return new EntrySetIterator <> ( parent ) ; }
return parent . delegateMap . entrySet () . iterator () ; } if ( parent . size () == 0 ) { MST[rv.ROR1Mutator]MSP[N] return EmptyIterator . < Map . Entry < K , V > > emptyIterator () ; } return new EntrySetIterator <> ( parent ) ; }
return parent . delegateMap . entrySet () . iterator () ; } if ( parent . size () == 0 ) { MST[rv.ROR4Mutator]MSP[N] return EmptyIterator . < Map . Entry < K , V > > emptyIterator () ; } return new EntrySetIterator <> ( parent ) ; }
return parent . delegateMap . entrySet () . iterator () ; } if ( parent . size () == 0 ) { MST[rv.ROR3Mutator]MSP[N] return EmptyIterator . < Map . Entry < K , V > > emptyIterator () ; } return new EntrySetIterator <> ( parent ) ; }
return parent . delegateMap . entrySet () . iterator () ; } if ( parent . size () == 0 ) { MST[rv.ROR5Mutator]MSP[N] return EmptyIterator . < Map . Entry < K , V > > emptyIterator () ; } return new EntrySetIterator <> ( parent ) ; }
final boolean result = parent . containsKey ( key ) ; parent . remove ( key ) ; return result ; MST[rv.UOI1Mutator]MSP[N] } @Override public Iterator < Map . Entry < K , V > > iterator () { if ( parent . delegateMap != null ) {
return parent . delegateMap . entrySet () . iterator () ; } if ( parent . size () == 0 ) { return EmptyIterator . < Map . Entry < K , V > > emptyIterator () ; } return new EntrySetIterator <> ( parent ) ; MST[ConstructorCallMutator]MSP[S] }
return parent . delegateMap . entrySet () . iterator () ; } if ( parent . size () == 0 ) { return EmptyIterator . < Map . Entry < K , V > > emptyIterator () ; } return new EntrySetIterator <> ( parent ) ; MST[ReturnValsMutator]MSP[S] }
return new EntrySet <> ( this ) ; } @Override public int size () { return parent . size () ; MST[ReturnValsMutator]MSP[S] } @Override public void clear () { parent . clear () ; } @Override public boolean remove ( final Object obj ) {
final boolean result = parent . containsKey ( key ) ; parent . remove ( key ) ; return result ; MST[rv.UOI3Mutator]MSP[S] } @Override public Iterator < Map . Entry < K , V > > iterator () { if ( parent . delegateMap != null ) {
final boolean result = parent . containsKey ( key ) ; parent . remove ( key ) ; return result ; MST[rv.UOI2Mutator]MSP[N] } @Override public Iterator < Map . Entry < K , V > > iterator () { if ( parent . delegateMap != null ) {
final boolean result = parent . containsKey ( key ) ; parent . remove ( key ) ; return result ; } @Override public Iterator < Map . Entry < K , V > > iterator () { if ( parent . delegateMap != null ) { MST[NegateConditionalsMutator]MSP[S]
final boolean result = parent . containsKey ( key ) ; MST[NonVoidMethodCallMutator]MSP[N] parent . remove ( key ) ; return result ; } @Override public Iterator < Map . Entry < K , V > > iterator () { if ( parent . delegateMap != null ) {
return parent . delegateMap . entrySet () . iterator () ; } if ( parent . size () == 0 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return EmptyIterator . < Map . Entry < K , V > > emptyIterator () ; } return new EntrySetIterator <> ( parent ) ; }
return parent . delegateMap . entrySet () . iterator () ; } if ( parent . size () == 0 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return EmptyIterator . < Map . Entry < K , V > > emptyIterator () ; } return new EntrySetIterator <> ( parent ) ; }
if ( obj instanceof Map . Entry == false ) { return false ; MST[BooleanTrueReturnValsMutator]MSP[S] } final Map . Entry < ? , ? > entry = ( Map . Entry < ? , ? > ) obj ; final Object key = entry . getKey () ;
return parent . delegateMap . entrySet () . iterator () ; } if ( parent . size () == 0 ) { return EmptyIterator . < Map . Entry < K , V > > emptyIterator () ; } return new EntrySetIterator <> ( parent ) ; MST[NullReturnValsMutator]MSP[S] }
if ( obj instanceof Map . Entry == false ) { MST[rv.ROR2Mutator]MSP[S] return false ; } final Map . Entry < ? , ? > entry = ( Map . Entry < ? , ? > ) obj ; final Object key = entry . getKey () ;
final boolean result = parent . containsKey ( key ) ; parent . remove ( key ) ; MST[ArgumentPropagationMutator]MSP[N] return result ; } @Override public Iterator < Map . Entry < K , V > > iterator () { if ( parent . delegateMap != null ) {
final boolean result = parent . containsKey ( key ) ; parent . remove ( key ) ; return result ; } @Override public Iterator < Map . Entry < K , V > > iterator () { if ( parent . delegateMap != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S]
return new EntrySet <> ( this ) ; } @Override public int size () { return parent . size () ; MST[PrimitiveReturnsMutator]MSP[N] } @Override public void clear () { parent . clear () ; } @Override public boolean remove ( final Object obj ) {
if ( obj instanceof Map . Entry == false ) { return false ; MST[rv.CRCR6Mutator]MSP[S] } final Map . Entry < ? , ? > entry = ( Map . Entry < ? , ? > ) obj ; final Object key = entry . getKey () ;
if ( obj instanceof Map . Entry == false ) { MST[rv.ROR4Mutator]MSP[S] return false ; } final Map . Entry < ? , ? > entry = ( Map . Entry < ? , ? > ) obj ; final Object key = entry . getKey () ;
return parent . delegateMap . entrySet () . iterator () ; } if ( parent . size () == 0 ) { MST[NonVoidMethodCallMutator]MSP[N] return EmptyIterator . < Map . Entry < K , V > > emptyIterator () ; } return new EntrySetIterator <> ( parent ) ; }
final boolean result = parent . containsKey ( key ) ; parent . remove ( key ) ; return result ; MST[BooleanTrueReturnValsMutator]MSP[S] } @Override public Iterator < Map . Entry < K , V > > iterator () { if ( parent . delegateMap != null ) {
return parent . delegateMap . entrySet () . iterator () ; } if ( parent . size () == 0 ) { return EmptyIterator . < Map . Entry < K , V > > emptyIterator () ; MST[NonVoidMethodCallMutator]MSP[N] } return new EntrySetIterator <> ( parent ) ; }
return new EntrySet <> ( this ) ; } @Override public int size () { return parent . size () ; MST[NonVoidMethodCallMutator]MSP[N] } @Override public void clear () { parent . clear () ; } @Override public boolean remove ( final Object obj ) {
if ( obj instanceof Map . Entry == false ) { MST[NegateConditionalsMutator]MSP[S] return false ; } final Map . Entry < ? , ? > entry = ( Map . Entry < ? , ? > ) obj ; final Object key = entry . getKey () ;
if ( obj instanceof Map . Entry == false ) { return false ; MST[ReturnValsMutator]MSP[S] } final Map . Entry < ? , ? > entry = ( Map . Entry < ? , ? > ) obj ; final Object key = entry . getKey () ;
return parent . delegateMap . entrySet () . iterator () ; } if ( parent . size () == 0 ) { MST[NegateConditionalsMutator]MSP[N] return EmptyIterator . < Map . Entry < K , V > > emptyIterator () ; } return new EntrySetIterator <> ( parent ) ; }
final boolean result = parent . containsKey ( key ) ; parent . remove ( key ) ; return result ; MST[BooleanFalseReturnValsMutator]MSP[N] } @Override public Iterator < Map . Entry < K , V > > iterator () { if ( parent . delegateMap != null ) {
final boolean result = parent . containsKey ( key ) ; parent . remove ( key ) ; return result ; } @Override public Iterator < Map . Entry < K , V > > iterator () { if ( parent . delegateMap != null ) { MST[NonVoidMethodCallMutator]MSP[N]
if ( obj instanceof Map . Entry == false ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return false ; } final Map . Entry < ? , ? > entry = ( Map . Entry < ? , ? > ) obj ; final Object key = entry . getKey () ;
if ( obj instanceof Map . Entry == false ) { return false ; MST[InlineConstantMutator]MSP[S] } final Map . Entry < ? , ? > entry = ( Map . Entry < ? , ? > ) obj ; final Object key = entry . getKey () ;
final boolean result = parent . containsKey ( key ) ; parent . remove ( key ) ; MST[NonVoidMethodCallMutator]MSP[N] return result ; } @Override public Iterator < Map . Entry < K , V > > iterator () { if ( parent . delegateMap != null ) {
final boolean result = parent . containsKey ( key ) ; parent . remove ( key ) ; return result ; MST[ReturnValsMutator]MSP[S] } @Override public Iterator < Map . Entry < K , V > > iterator () { if ( parent . delegateMap != null ) {
final boolean result = parent . containsKey ( key ) ; parent . remove ( key ) ; return result ; } @Override public Iterator < Map . Entry < K , V > > iterator () { if ( parent . delegateMap != null ) { MST[rv.ROR5Mutator]MSP[S]
final boolean result = parent . containsKey ( key ) ; parent . remove ( key ) ; return result ; MST[rv.ABSMutator]MSP[N] } @Override public Iterator < Map . Entry < K , V > > iterator () { if ( parent . delegateMap != null ) {
return parent . delegateMap . entrySet () . iterator () ; } if ( parent . size () == 0 ) { return EmptyIterator . < Map . Entry < K , V > > emptyIterator () ; MST[ReturnValsMutator]MSP[N] } return new EntrySetIterator <> ( parent ) ; }
if ( obj instanceof Map . Entry == false ) { return false ; } final Map . Entry < ? , ? > entry = ( Map . Entry < ? , ? > ) obj ; final Object key = entry . getKey () ; MST[NonVoidMethodCallMutator]MSP[N]
return parent . delegateMap . entrySet () . iterator () ; } if ( parent . size () == 0 ) { return EmptyIterator . < Map . Entry < K , V > > emptyIterator () ; MST[NullReturnValsMutator]MSP[N] } return new EntrySetIterator <> ( parent ) ; }
if ( obj instanceof Map . Entry == false ) { MST[rv.ROR1Mutator]MSP[N] return false ; } final Map . Entry < ? , ? > entry = ( Map . Entry < ? , ? > ) obj ; final Object key = entry . getKey () ;
if ( obj instanceof Map . Entry == false ) { MST[rv.ROR3Mutator]MSP[N] return false ; } final Map . Entry < ? , ? > entry = ( Map . Entry < ? , ? > ) obj ; final Object key = entry . getKey () ;
final boolean result = parent . containsKey ( key ) ; parent . remove ( key ) ; return result ; MST[rv.UOI4Mutator]MSP[S] } @Override public Iterator < Map . Entry < K , V > > iterator () { if ( parent . delegateMap != null ) {
final boolean result = parent . containsKey ( key ) ; parent . remove ( key ) ; return result ; } @Override public Iterator < Map . Entry < K , V > > iterator () { if ( parent . delegateMap != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
if ( obj instanceof Map . Entry == false ) { return false ; MST[rv.CRCR3Mutator]MSP[S] } final Map . Entry < ? , ? > entry = ( Map . Entry < ? , ? > ) obj ; final Object key = entry . getKey () ;
if ( obj instanceof Map . Entry == false ) { return false ; MST[rv.CRCR5Mutator]MSP[S] } final Map . Entry < ? , ? > entry = ( Map . Entry < ? , ? > ) obj ; final Object key = entry . getKey () ;
return new EntrySet <> ( this ) ; } @Override public int size () { return parent . size () ; } @Override public void clear () { parent . clear () ; MST[VoidMethodCallMutator]MSP[N] } @Override public boolean remove ( final Object obj ) {
if ( obj instanceof Map . Entry == false ) { return false ; MST[rv.CRCR1Mutator]MSP[S] } final Map . Entry < ? , ? > entry = ( Map . Entry < ? , ? > ) obj ; final Object key = entry . getKey () ;
if ( obj instanceof Map . Entry == false ) { MST[rv.ROR5Mutator]MSP[S] return false ; } final Map . Entry < ? , ? > entry = ( Map . Entry < ? , ? > ) obj ; final Object key = entry . getKey () ;
if ( obj instanceof Map . Entry == false ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] return false ; } final Map . Entry < ? , ? > entry = ( Map . Entry < ? , ? > ) obj ; final Object key = entry . getKey () ;
return old ; } case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[NonVoidMethodCallMutator]MSP[S] final V old = value2 ; value2 = value ; return old ; } case 1 :
} else { if ( size > 0 ) { MST[rv.UOI2Mutator]MSP[N] final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { final V old = value3 ;
return value3 ; } case 2 : if ( key2 == null ) { return value2 ; } case 1 : if ( key1 == null ) { return value1 ; MST[NullReturnValsMutator]MSP[S] } } } else { if ( size > 0 ) {
key1 = key3 ; value1 = value3 ; hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } return null ; case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.ROR1Mutator]MSP[S]
return; } if ( size < 4 ) { for ( final Map . Entry < ? extends K , ? extends V > entry : map . entrySet () ) { put ( entry . getKey () , entry . getValue () ) ; MST[NonVoidMethodCallMutator]MSP[N] } } else {
key1 = key2 ; value1 = value2 ; hash2 = 0 ; MST[rv.CRCR5Mutator]MSP[S] key2 = null ; value2 = null ; size = 1 ; return old ; } return null ; case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) {
public MapIterator < K , V > mapIterator () { if ( delegateMap != null ) { return delegateMap . mapIterator () ; } if ( size == 0 ) { return EmptyMapIterator . <K , V > emptyMapIterator () ; } return new FlatMapIterator <> ( this ) ; MST[ReturnValsMutator]MSP[S]
if ( size != other . size () ) { return false ; } if ( size > 0 ) { MST[ConditionalsBoundaryMutator]MSP[S] Object otherValue = null ; switch ( size ) { case 3 : if ( other . containsKey ( key3 ) == false ) { return false ; }
return null ; case 2 : hash3 = key == null ? 0 : key . hashCode () ; MST[experimental.MemberVariableMutator]MSP[N] key3 = key ; value3 = value ; break; case 1 : hash2 = key == null ? 0 : key . hashCode () ; key2 = key ;
value2 = null ; size = 1 ; MST[rv.CRCR4Mutator]MSP[S] return old ; } if ( key1 == null ) { final V old = value1 ; hash1 = hash2 ; key1 = key2 ; value1 = value2 ; hash2 = 0 ; key2 = null ; value2 = null ;
hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.UOI4Mutator]MSP[N] final V old = value2 ; hash2 = hash3 ; key2 = key3 ;
public MapIterator < K , V > mapIterator () { if ( delegateMap != null ) { return delegateMap . mapIterator () ; } if ( size == 0 ) { MST[rv.ABSMutator]MSP[S] return EmptyMapIterator . <K , V > emptyMapIterator () ; } return new FlatMapIterator <> ( this ) ;
final V old = value3 ; hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; MST[ReturnValsMutator]MSP[S] } if ( key2 == null ) { final V old = value2 ; hash2 = hash3 ; key2 = key3 ;
public Flat3Map < K , V > clone () { try { final Flat3Map < K , V > cloned = ( Flat3Map < K , V > ) super . clone () ; MST[experimental.NakedReceiverMutator]MSP[N] if ( cloned . delegateMap != null ) {
buf . append ( value2 == this ? lr_9 : value2 ) ; buf . append ( ',' ) ; case 1 : buf . append ( key1 == this ? lr_9 : key1 ) ; MST[experimental.NakedReceiverMutator]MSP[N] buf . append ( '=' ) ;
if ( delegateMap != null ) { return delegateMap . remove ( key ) ; } if ( size == 0 ) { return null ; } if ( key == null ) { switch ( size ) { case 3 : if ( key3 == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
return lr_2 + getKey () + lr_3 + getValue () + lr_4 ; } return lr_5 ; } @Override public Set < Map . Entry < K , V > > entrySet () { if ( delegateMap != null ) { return delegateMap . entrySet () ; MST[EmptyObjectReturnValsMutator]MSP[S] }
if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[rv.ROR4Mutator]MSP[S] final V old = value3 ; value3 = value ;
} if ( delegateMap != null ) { return delegateMap . equals ( obj ) ; } if ( obj instanceof Map == false ) { return false ; MST[rv.CRCR1Mutator]MSP[N] } final Map < ? , ? > other = ( Map < ? , ? > ) obj ;
hash3 = 0 ; MST[InlineConstantMutator]MSP[S] key3 = null ; value3 = null ; size = 2 ; return old ; } return null ; case 2 : if ( key2 == null ) { final V old = value2 ; hash2 = 0 ; key2 = null ;
final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[rv.ROR1Mutator]MSP[S] return value3 ; } case 2 :
hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; MST[rv.CRCR2Mutator]MSP[N] return old ; } return null ; case 2 : if ( key2 == null ) { final V old = value2 ; hash2 = 0 ; key2 = null ;
final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { return value3 ; MST[ReturnValsMutator]MSP[N] } case 2 :
if ( size != other . size () ) { return false ; } if ( size > 0 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[S] Object otherValue = null ; switch ( size ) { case 3 : if ( other . containsKey ( key3 ) == false ) { return false ; }
if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.UOI3Mutator]MSP[N] final V old = value1 ; value1 = value ; return old ; } } } } switch ( size ) { default: convertToMap () ; delegateMap . put ( key , value ) ;
public void putAll ( final Map < ? extends K , ? extends V > map ) { final int size = map . size () ; if ( size == 0 ) { MST[rv.ROR4Mutator]MSP[S] return; } if ( delegateMap != null ) { delegateMap . putAll ( map ) ;
} else { if ( size > 0 ) { MST[rv.ABSMutator]MSP[N] final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { final V old = value3 ;
if ( hash2 == hashCode && key . equals ( key2 ) ) { return value2 ; MST[ReturnValsMutator]MSP[N] } case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { return value1 ; } } } } return null ; } @Override
if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] final V old = value1 ; value1 = value ; return old ; } } } } switch ( size ) { default: convertToMap () ; delegateMap . put ( key , value ) ;
public int size () { if ( delegateMap != null ) { return delegateMap . size () ; } return size ; MST[ReturnValsMutator]MSP[N] } @Override public boolean isEmpty () { return size () == 0 ; } @Override public boolean containsKey ( final Object key ) {
if ( hash2 == hashCode && key . equals ( key2 ) ) { return value2 ; } case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.ROR1Mutator]MSP[N] return value1 ; } } } } return null ; } @Override
if ( delegateMap != null ) { return delegateMap . hashCode () ; } int total = 0 ; switch ( size ) { case 3 : total += hash3 ^ ( value3 == null ? 0 : value3 . hashCode () ) ; MST[MathMutator]MSP[S] case 2 :
if ( delegateMap != null ) { return delegateMap . remove ( key ) ; } if ( size == 0 ) { MST[rv.UOI1Mutator]MSP[N] return null ; } if ( key == null ) { switch ( size ) { case 3 : if ( key3 == null ) {
if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.ROR1Mutator]MSP[N] return value2 ; } case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { return value1 ; } } } } return null ; } @Override
final V old = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; MST[rv.CRCR6Mutator]MSP[N] return old ; } if ( hash1 == hashCode && key . equals ( key1 ) ) { final V old = value1 ; hash1 = hash2 ;
return lr_2 + getKey () + lr_3 + getValue () + lr_4 ; } return lr_5 ; } @Override public Set < Map . Entry < K , V > > entrySet () { if ( delegateMap != null ) { return delegateMap . entrySet () ; MST[NonVoidMethodCallMutator]MSP[S] }
if ( hash1 == hashCode && key . equals ( key1 ) ) { final V old = value1 ; value1 = value ; return old ; MST[NullReturnValsMutator]MSP[S] } } } } switch ( size ) { default: convertToMap () ; delegateMap . put ( key , value ) ;
hash3 = 0 ; MST[rv.CRCR6Mutator]MSP[S] key3 = null ; value3 = null ; size = 2 ; return old ; } if ( hash2 == hashCode && key . equals ( key2 ) ) { final V old = value2 ; hash2 = hash3 ; key2 = key3 ;
delegateMap . put ( key2 , value2 ) ; case 1 : delegateMap . put ( key1 , value1 ) ; case 0 : break; default: throw new IllegalStateException ( lr_1 + size ) ; } size = 0 ; MST[rv.CRCR1Mutator]MSP[S] hash1 = hash2 = hash3 = 0 ;
if ( delegateMap != null ) { return delegateMap . remove ( key ) ; } if ( size == 0 ) { MST[rv.ROR2Mutator]MSP[N] return null ; } if ( key == null ) { switch ( size ) { case 3 : if ( key3 == null ) {
value2 = value ; break; case 0 : hash1 = key == null ? 0 : key . hashCode () ; key1 = key ; value1 = value ; break; } size ++ ; return null ; MST[ReturnValsMutator]MSP[S] } @Override
hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } if ( hash2 == hashCode && key . equals ( key2 ) ) { final V old = value2 ; hash2 = hash3 ; MST[rv.UOI4Mutator]MSP[S] key2 = key3 ;
@Override public V get ( final Object key ) { if ( delegateMap != null ) { return delegateMap . get ( key ) ; } if ( key == null ) { switch ( size ) { case 3 : if ( key3 == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S]
total += hash2 ^ ( value2 == null ? 0 : value2 . hashCode () ) ; case 1 : total += hash1 ^ ( value1 == null ? 0 : value1 . hashCode () ) ; MST[rv.AOR2Mutator]MSP[S] case 0 : break; default:
total += hash2 ^ ( value2 == null ? 0 : value2 . hashCode () ) ; MST[rv.ABSMutator]MSP[S] case 1 : total += hash1 ^ ( value1 == null ? 0 : value1 . hashCode () ) ; case 0 : break; default:
hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.ROR1Mutator]MSP[S] final V old = value2 ; hash2 = hash3 ; key2 = key3 ;
return value3 ; } case 2 : if ( key2 == null ) { return value2 ; } case 1 : if ( key1 == null ) { return value1 ; } } } else { if ( size > 0 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N]
} else { if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] final V old = value3 ;
return value3 ; } case 2 : if ( key2 == null ) { return value2 ; MST[ReturnValsMutator]MSP[S] } case 1 : if ( key1 == null ) { return value1 ; } } } else { if ( size > 0 ) {
if ( value1 == null ) { return true ; MST[rv.CRCR6Mutator]MSP[N] } } } else { switch ( size ) { case 3 : if ( value . equals ( value3 ) ) { return true ; } case 2 : if ( value . equals ( value2 ) ) {
final StringBuilder buf = new StringBuilder ( 128 ) ; buf . append ( '{' ) ; MST[rv.CRCR1Mutator]MSP[N] switch ( size ) { case 3 : buf . append ( key3 == this ? lr_9 : key3 ) ; buf . append ( '=' ) ;
if ( hash2 == hashCode && key . equals ( key2 ) ) { return value2 ; } case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { return value1 ; MST[ReturnValsMutator]MSP[N] } } } } return null ; } @Override
return value3 ; } case 2 : if ( key2 == null ) { return value2 ; } case 1 : if ( key1 == null ) { return value1 ; } } } else { if ( size > 0 ) { MST[ConditionalsBoundaryMutator]MSP[S]
if ( delegateMap != null ) { return delegateMap . containsKey ( key ) ; } if ( key == null ) { switch ( size ) { case 3 : if ( key3 == null ) { return true ; MST[InlineConstantMutator]MSP[N] } case 2 :
if ( delegateMap != null ) { return delegateMap . remove ( key ) ; } if ( size == 0 ) { return null ; } if ( key == null ) { MST[NegateConditionalsMutator]MSP[N] switch ( size ) { case 3 : if ( key3 == null ) {
return; } if ( size < 4 ) { MST[rv.ROR2Mutator]MSP[N] for ( final Map . Entry < ? extends K , ? extends V > entry : map . entrySet () ) { put ( entry . getKey () , entry . getValue () ) ; } } else {
final StringBuilder buf = new StringBuilder ( 128 ) ; buf . append ( '{' ) ; switch ( size ) { case 3 : buf . append ( key3 == this ? lr_9 : key3 ) ; buf . append ( '=' ) ; MST[rv.CRCR5Mutator]MSP[S]
public MapIterator < K , V > mapIterator () { if ( delegateMap != null ) { return delegateMap . mapIterator () ; } if ( size == 0 ) { return EmptyMapIterator . <K , V > emptyMapIterator () ; MST[NonVoidMethodCallMutator]MSP[S] } return new FlatMapIterator <> ( this ) ;
if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.UOI1Mutator]MSP[S] return true ; } } } } return false ; } @Override public boolean containsValue ( final Object value ) { if ( delegateMap != null ) { return delegateMap . containsValue ( value ) ;
throw new IllegalStateException ( lr_1 + size ) ; } return total ; } @Override public String toString () { if ( delegateMap != null ) { return delegateMap . toString () ; } if ( size == 0 ) { return lr_8 ; MST[EmptyObjectReturnValsMutator]MSP[N] }
} else { if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { MST[rv.UOI4Mutator]MSP[N] case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { final V old = value3 ;
value2 = value ; break; case 0 : hash1 = key == null ? 0 : key . hashCode () ; MST[NonVoidMethodCallMutator]MSP[N] key1 = key ; value1 = value ; break; } size ++ ; return null ; } @Override
} else { if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[rv.ABSMutator]MSP[N] final V old = value3 ;
size = 1 ; return old ; } return null ; case 1 : if ( key1 == null ) { final V old = value1 ; hash1 = 0 ; MST[rv.CRCR3Mutator]MSP[S] key1 = null ; value1 = null ; size = 0 ; return old ; } }
if ( size != other . size () ) { MST[rv.UOI3Mutator]MSP[N] return false ; } if ( size > 0 ) { Object otherValue = null ; switch ( size ) { case 3 : if ( other . containsKey ( key3 ) == false ) { return false ; }
delegateMap . put ( key2 , value2 ) ; case 1 : delegateMap . put ( key1 , value1 ) ; MST[NonVoidMethodCallMutator]MSP[N] case 0 : break; default: throw new IllegalStateException ( lr_1 + size ) ; } size = 0 ; hash1 = hash2 = hash3 = 0 ;
key1 = key2 = key3 = null ; MST[experimental.MemberVariableMutator]MSP[S] value1 = value2 = value3 = null ; } protected AbstractHashedMap < K , V > createDelegateMap () { return new HashedMap <> () ; } @Override public V remove ( final Object key ) {
} else { if ( size > 0 ) { MST[rv.ROR3Mutator]MSP[N] final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { final V old = value3 ;
if ( key2 == null ) { return true ; } case 1 : if ( key1 == null ) { return true ; } } } else { if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { MST[rv.UOI4Mutator]MSP[N]
return delegateMap . put ( key , value ) ; } if ( key == null ) { MST[NegateConditionalsMutator]MSP[N] switch ( size ) { case 3 : if ( key3 == null ) { final V old = value3 ; value3 = value ; return old ; } case 2 :
value2 = value3 ; hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; MST[ReturnValsMutator]MSP[S] } if ( hash1 == hashCode && key . equals ( key1 ) ) { final V old = value1 ; hash1 = hash3 ;
key1 = key2 ; value1 = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; return old ; } return null ; case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.ROR2Mutator]MSP[S]
public MapIterator < K , V > mapIterator () { if ( delegateMap != null ) { return delegateMap . mapIterator () ; } if ( size == 0 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] return EmptyMapIterator . <K , V > emptyMapIterator () ; } return new FlatMapIterator <> ( this ) ;
if ( hash1 == hashCode && key . equals ( key1 ) ) { return true ; } } } } return false ; } @Override public boolean containsValue ( final Object value ) { if ( delegateMap != null ) { return delegateMap . containsValue ( value ) ; MST[BooleanFalseReturnValsMutator]MSP[S]
if ( size != other . size () ) { return false ; } if ( size > 0 ) { MST[NegateConditionalsMutator]MSP[S] Object otherValue = null ; switch ( size ) { case 3 : if ( other . containsKey ( key3 ) == false ) { return false ; }
public MapIterator < K , V > mapIterator () { if ( delegateMap != null ) { return delegateMap . mapIterator () ; } if ( size == 0 ) { MST[rv.ROR3Mutator]MSP[S] return EmptyMapIterator . <K , V > emptyMapIterator () ; } return new FlatMapIterator <> ( this ) ;
buf . append ( value2 == this ? lr_9 : value2 ) ; buf . append ( ',' ) ; case 1 : buf . append ( key1 == this ? lr_9 : key1 ) ; MST[rv.ROR5Mutator]MSP[N] buf . append ( '=' ) ;
final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[rv.ROR4Mutator]MSP[N] return value3 ; } case 2 :
return null ; case 2 : hash3 = key == null ? 0 : key . hashCode () ; key3 = key ; value3 = value ; break; case 1 : hash2 = key == null ? 0 : key . hashCode () ; MST[InlineConstantMutator]MSP[S] key2 = key ;
hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; MST[rv.CRCR1Mutator]MSP[N] return old ; } if ( hash2 == hashCode && key . equals ( key2 ) ) { final V old = value2 ; hash2 = hash3 ; key2 = key3 ;
if ( size > 0 ) { MST[rv.ROR4Mutator]MSP[S] final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { final V old = value3 ; value3 = value ;
if ( size != other . size () ) { return false ; MST[rv.CRCR1Mutator]MSP[N] } if ( size > 0 ) { Object otherValue = null ; switch ( size ) { case 3 : if ( other . containsKey ( key3 ) == false ) { return false ; }
} else { if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { MST[rv.UOI1Mutator]MSP[N] case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { final V old = value3 ;
} else { if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[rv.ROR3Mutator]MSP[S] final V old = value3 ;
if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] final V old = value3 ; value3 = value ;
key1 = key3 ; value1 = value3 ; hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } return null ; case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.ROR4Mutator]MSP[N]
size = 1 ; return old ; } return null ; case 1 : if ( key1 == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] final V old = value1 ; hash1 = 0 ; key1 = null ; value1 = null ; size = 0 ; return old ; } }
final V old = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; return old ; } if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] final V old = value1 ; hash1 = hash2 ;
if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.ROR1Mutator]MSP[S] return true ; } } } } return false ; } @Override public boolean containsValue ( final Object value ) { if ( delegateMap != null ) { return delegateMap . containsValue ( value ) ;
if ( key2 == null ) { return true ; } case 1 : if ( key1 == null ) { return true ; } } } else { if ( size > 0 ) { MST[rv.ROR3Mutator]MSP[N] final int hashCode = key . hashCode () ; switch ( size ) {
public int size () { if ( delegateMap != null ) { return delegateMap . size () ; } return size ; } @Override public boolean isEmpty () { return size () == 0 ; MST[rv.ROR1Mutator]MSP[N] } @Override public boolean containsKey ( final Object key ) {
hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.UOI1Mutator]MSP[S] final V old = value2 ; hash2 = hash3 ; key2 = key3 ;
if ( hash1 == hashCode && key . equals ( key1 ) ) { return true ; } } } } return false ; } @Override public boolean containsValue ( final Object value ) { if ( delegateMap != null ) { MST[rv.ROR5Mutator]MSP[S] return delegateMap . containsValue ( value ) ;
if ( key2 == null ) { final V old = value2 ; value2 = value ; return old ; } case 1 : if ( key1 == null ) { MST[rv.ROR5Mutator]MSP[N] final V old = value1 ; value1 = value ; return old ; } } } else {
return null ; MST[ReturnValsMutator]MSP[S] case 2 : hash3 = key == null ? 0 : key . hashCode () ; key3 = key ; value3 = value ; break; case 1 : hash2 = key == null ? 0 : key . hashCode () ; key2 = key ;
final V old = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; return old ; } if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.ROR2Mutator]MSP[S] final V old = value1 ; hash1 = hash2 ;
key1 = key2 = key3 = null ; value1 = value2 = value3 = null ; } protected AbstractHashedMap < K , V > createDelegateMap () { return new HashedMap <> () ; MST[ReturnValsMutator]MSP[S] } @Override public V remove ( final Object key ) {
if ( size != other . size () ) { return false ; } if ( size > 0 ) { MST[rv.ROR5Mutator]MSP[S] Object otherValue = null ; switch ( size ) { case 3 : if ( other . containsKey ( key3 ) == false ) { return false ; }
final StringBuilder buf = new StringBuilder ( 128 ) ; MST[ConstructorCallMutator]MSP[S] buf . append ( '{' ) ; switch ( size ) { case 3 : buf . append ( key3 == this ? lr_9 : key3 ) ; buf . append ( '=' ) ;
if ( delegateMap != null ) { return delegateMap . remove ( key ) ; } if ( size == 0 ) { MST[rv.ROR5Mutator]MSP[N] return null ; } if ( key == null ) { switch ( size ) { case 3 : if ( key3 == null ) {
if ( hash2 == hashCode && key . equals ( key2 ) ) { return value2 ; } case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.UOI4Mutator]MSP[N] return value1 ; } } } } return null ; } @Override
if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.ROR4Mutator]MSP[N] return value2 ; } case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { return value1 ; } } } } return null ; } @Override
key1 = key2 ; value1 = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; MST[experimental.MemberVariableMutator]MSP[N] return old ; } return null ; case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) {
buf . append ( value3 == this ? lr_9 : value3 ) ; buf . append ( ',' ) ; case 2 : buf . append ( key2 == this ? lr_9 : key2 ) ; buf . append ( '=' ) ; MST[rv.CRCR5Mutator]MSP[N]
case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { return true ; } case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] return true ; } case 1 :
final V old = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; return old ; } if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.ABSMutator]MSP[N] final V old = value1 ; hash1 = hash2 ;
key1 = key2 = key3 = null ; value1 = value2 = value3 = null ; } protected AbstractHashedMap < K , V > createDelegateMap () { return new HashedMap <> () ; MST[ConstructorCallMutator]MSP[S] } @Override public V remove ( final Object key ) {
if ( delegateMap != null ) { return delegateMap . remove ( key ) ; } if ( size == 0 ) { MST[rv.UOI4Mutator]MSP[N] return null ; } if ( key == null ) { switch ( size ) { case 3 : if ( key3 == null ) {
hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } if ( hash2 == hashCode && key . equals ( key2 ) ) { final V old = value2 ; hash2 = hash3 ; MST[rv.UOI1Mutator]MSP[S] key2 = key3 ;
final V old = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; return old ; MST[NullReturnValsMutator]MSP[S] } if ( hash1 == hashCode && key . equals ( key1 ) ) { final V old = value1 ; hash1 = hash2 ;
delegateMap . clear () ; delegateMap = null ; } else { size = 0 ; hash1 = hash2 = hash3 = 0 ; MST[rv.CRCR3Mutator]MSP[S] key1 = key2 = key3 = null ; value1 = value2 = value3 = null ; } } @Override
if ( value1 == null ) { return true ; } } } else { switch ( size ) { case 3 : if ( value . equals ( value3 ) ) { return true ; } case 2 : if ( value . equals ( value2 ) ) { MST[rv.ROR2Mutator]MSP[S]
value2 = value ; break; case 0 : hash1 = key == null ? 0 : key . hashCode () ; MST[rv.CRCR5Mutator]MSP[S] key1 = key ; value1 = value ; break; } size ++ ; return null ; } @Override
hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.UOI3Mutator]MSP[N] final V old = value2 ; hash2 = hash3 ; key2 = key3 ;
total += hash2 ^ ( value2 == null ? 0 : value2 . hashCode () ) ; case 1 : total += hash1 ^ ( value1 == null ? 0 : value1 . hashCode () ) ; MST[rv.ROR5Mutator]MSP[S] case 0 : break; default:
if ( hash2 == hashCode && key . equals ( key2 ) ) { return value2 ; } case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.ROR4Mutator]MSP[N] return value1 ; } } } } return null ; } @Override
return true ; } case 1 : if ( value . equals ( value1 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] return true ; } } } return false ; } @Override public V put ( final K key , final V value ) { if ( delegateMap != null ) {
if ( size != other . size () ) { return false ; } if ( size > 0 ) { MST[rv.UOI4Mutator]MSP[S] Object otherValue = null ; switch ( size ) { case 3 : if ( other . containsKey ( key3 ) == false ) { return false ; }
case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[rv.ROR3Mutator]MSP[S] return true ; } case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { return true ; } case 1 :
if ( delegateMap != null ) { return delegateMap . containsKey ( key ) ; } if ( key == null ) { switch ( size ) { MST[rv.UOI2Mutator]MSP[N] case 3 : if ( key3 == null ) { return true ; } case 2 :
if ( delegateMap != null ) { return delegateMap . containsKey ( key ) ; } if ( key == null ) { switch ( size ) { MST[rv.ABSMutator]MSP[N] case 3 : if ( key3 == null ) { return true ; } case 2 :
final V old = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; MST[experimental.MemberVariableMutator]MSP[S] size = 1 ; return old ; } if ( hash1 == hashCode && key . equals ( key1 ) ) { final V old = value1 ; hash1 = hash2 ;
if ( delegateMap != null ) { return delegateMap . remove ( key ) ; } if ( size == 0 ) { return null ; } if ( key == null ) { switch ( size ) { MST[rv.UOI3Mutator]MSP[N] case 3 : if ( key3 == null ) {
final V old = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; return old ; } if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.UOI2Mutator]MSP[S] final V old = value1 ; hash1 = hash2 ;
return false ; } otherValue = other . get ( key1 ) ; if ( value1 == null ? otherValue != null : ! value1 . equals ( otherValue ) ) { return false ; } } } return true ; MST[rv.CRCR5Mutator]MSP[N] } @Override public int hashCode () {
return; } if ( size < 4 ) { MST[rv.ROR5Mutator]MSP[N] for ( final Map . Entry < ? extends K , ? extends V > entry : map . entrySet () ) { put ( entry . getKey () , entry . getValue () ) ; } } else {
public Set < K > keySet () { if ( delegateMap != null ) { return delegateMap . keySet () ; } return new KeySet <> ( this ) ; MST[EmptyObjectReturnValsMutator]MSP[N] } @Override public int size () { return parent . size () ; } @Override public void clear () {
if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.UOI4Mutator]MSP[N] return true ; } } } } return false ; } @Override public boolean containsValue ( final Object value ) { if ( delegateMap != null ) { return delegateMap . containsValue ( value ) ;
buf . append ( value2 == this ? lr_9 : value2 ) ; buf . append ( ',' ) ; MST[InlineConstantMutator]MSP[N] case 1 : buf . append ( key1 == this ? lr_9 : key1 ) ; buf . append ( '=' ) ;
hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; MST[rv.CRCR5Mutator]MSP[N] return old ; } return null ; case 2 : if ( key2 == null ) { final V old = value2 ; hash2 = 0 ; key2 = null ;
if ( delegateMap != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return delegateMap . containsKey ( key ) ; } if ( key == null ) { switch ( size ) { case 3 : if ( key3 == null ) { return true ; } case 2 :
hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.ROR4Mutator]MSP[N] final V old = value2 ; hash2 = hash3 ; key2 = key3 ;
if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.UOI2Mutator]MSP[S] final V old = value1 ; value1 = value ; return old ; } } } } switch ( size ) { default: convertToMap () ; delegateMap . put ( key , value ) ;
public int size () { if ( delegateMap != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] return delegateMap . size () ; } return size ; } @Override public boolean isEmpty () { return size () == 0 ; } @Override public boolean containsKey ( final Object key ) {
return delegateMap . put ( key , value ) ; } if ( key == null ) { MST[rv.ROR5Mutator]MSP[N] switch ( size ) { case 3 : if ( key3 == null ) { final V old = value3 ; value3 = value ; return old ; } case 2 :
return true ; } case 1 : if ( value . equals ( value1 ) ) { return true ; } } } return false ; MST[InlineConstantMutator]MSP[N] } @Override public V put ( final K key , final V value ) { if ( delegateMap != null ) {
return old ; } case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.ROR3Mutator]MSP[N] final V old = value2 ; value2 = value ; return old ; } case 1 :
value2 = value ; break; case 0 : hash1 = key == null ? 0 : key . hashCode () ; key1 = key ; value1 = value ; break; } size ++ ; MST[rv.UOI1Mutator]MSP[S] return null ; } @Override
final V old = value1 ; hash1 = 0 ; key1 = null ; value1 = null ; size = 0 ; MST[InlineConstantMutator]MSP[N] return old ; } } } } return null ; } @Override public void clear () { if ( delegateMap != null ) {
delegateMap . clear () ; delegateMap = null ; } else { size = 0 ; hash1 = hash2 = hash3 = 0 ; MST[experimental.MemberVariableMutator]MSP[S] key1 = key2 = key3 = null ; value1 = value2 = value3 = null ; } } @Override
if ( hash1 == hashCode && key . equals ( key1 ) ) { return true ; } } } } return false ; MST[rv.CRCR5Mutator]MSP[N] } @Override public boolean containsValue ( final Object value ) { if ( delegateMap != null ) { return delegateMap . containsValue ( value ) ;
public int size () { if ( delegateMap != null ) { return delegateMap . size () ; } return size ; } @Override public boolean isEmpty () { return size () == 0 ; MST[rv.CRCR1Mutator]MSP[N] } @Override public boolean containsKey ( final Object key ) {
return; } if ( size < 4 ) { MST[rv.ABSMutator]MSP[S] for ( final Map . Entry < ? extends K , ? extends V > entry : map . entrySet () ) { put ( entry . getKey () , entry . getValue () ) ; } } else {
delegateMap . clear () ; delegateMap = null ; } else { size = 0 ; MST[rv.CRCR5Mutator]MSP[N] hash1 = hash2 = hash3 = 0 ; key1 = key2 = key3 = null ; value1 = value2 = value3 = null ; } } @Override
total += hash2 ^ ( value2 == null ? 0 : value2 . hashCode () ) ; case 1 : total += hash1 ^ ( value1 == null ? 0 : value1 . hashCode () ) ; MST[rv.UOI2Mutator]MSP[S] case 0 : break; default:
convertToMap () ; delegateMap . putAll ( map ) ; } } private void convertToMap () { delegateMap = createDelegateMap () ; switch ( size ) { MST[rv.UOI1Mutator]MSP[S] case 3 : delegateMap . put ( key3 , value3 ) ; case 2 :
total += hash2 ^ ( value2 == null ? 0 : value2 . hashCode () ) ; case 1 : total += hash1 ^ ( value1 == null ? 0 : value1 . hashCode () ) ; MST[NegateConditionalsMutator]MSP[S] case 0 : break; default:
if ( value1 == null ) { return true ; MST[rv.CRCR3Mutator]MSP[S] } } } else { switch ( size ) { case 3 : if ( value . equals ( value3 ) ) { return true ; } case 2 : if ( value . equals ( value2 ) ) {
if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[NonVoidMethodCallMutator]MSP[S] final V old = value3 ; value3 = value ;
final V old = value2 ; hash2 = 0 ; MST[rv.CRCR1Mutator]MSP[S] key2 = null ; value2 = null ; size = 1 ; return old ; } if ( hash1 == hashCode && key . equals ( key1 ) ) { final V old = value1 ; hash1 = hash2 ;
key1 = key2 ; value1 = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; MST[rv.CRCR3Mutator]MSP[N] return old ; } return null ; case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) {
key1 = key2 ; value1 = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; return old ; } return null ; case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.UOI2Mutator]MSP[S]
return value3 ; } case 2 : if ( key2 == null ) { return value2 ; } case 1 : if ( key1 == null ) { return value1 ; } } } else { if ( size > 0 ) { MST[rv.UOI4Mutator]MSP[N]
if ( size > 0 ) { final int hashCode = key . hashCode () ; MST[NonVoidMethodCallMutator]MSP[S] switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { final V old = value3 ; value3 = value ;
if ( hash1 == hashCode && key . equals ( key1 ) ) { return true ; } } } } return false ; } @Override public boolean containsValue ( final Object value ) { if ( delegateMap != null ) { MST[NegateConditionalsMutator]MSP[S] return delegateMap . containsValue ( value ) ;
value2 = value3 ; hash3 = 0 ; MST[rv.CRCR3Mutator]MSP[S] key3 = null ; value3 = null ; size = 2 ; return old ; } if ( hash1 == hashCode && key . equals ( key1 ) ) { final V old = value1 ; hash1 = hash3 ;
final V old = value3 ; hash3 = 0 ; MST[rv.CRCR3Mutator]MSP[S] key3 = null ; value3 = null ; size = 2 ; return old ; } if ( key2 == null ) { final V old = value2 ; hash2 = hash3 ; key2 = key3 ;
return true ; MST[InlineConstantMutator]MSP[N] } case 1 : if ( value . equals ( value1 ) ) { return true ; } } } return false ; } @Override public V put ( final K key , final V value ) { if ( delegateMap != null ) {
if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.ROR4Mutator]MSP[N] return true ; } } } } return false ; } @Override public boolean containsValue ( final Object value ) { if ( delegateMap != null ) { return delegateMap . containsValue ( value ) ;
if ( delegateMap != null ) { return delegateMap . hashCode () ; } int total = 0 ; switch ( size ) { case 3 : total += hash3 ^ ( value3 == null ? 0 : value3 . hashCode () ) ; MST[rv.CRCR1Mutator]MSP[S] case 2 :
final V old = value3 ; hash3 = 0 ; MST[experimental.MemberVariableMutator]MSP[S] key3 = null ; value3 = null ; size = 2 ; return old ; } if ( key2 == null ) { final V old = value2 ; hash2 = hash3 ; key2 = key3 ;
if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.UOI4Mutator]MSP[N] return value2 ; } case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { return value1 ; } } } } return null ; } @Override
return delegateMap . put ( key , value ) ; } if ( key == null ) { switch ( size ) { case 3 : if ( key3 == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] final V old = value3 ; value3 = value ; return old ; } case 2 :
throw new IllegalStateException ( lr_1 + size ) ; } return total ; } @Override public String toString () { if ( delegateMap != null ) { return delegateMap . toString () ; } if ( size == 0 ) { MST[rv.ROR3Mutator]MSP[S] return lr_8 ; }
buf . append ( value1 == this ? lr_9 : value1 ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] break; default: throw new IllegalStateException ( lr_1 + size ) ; } buf . append ( '}' ) ; return buf . toString () ; }
value2 = null ; size = 1 ; MST[InlineConstantMutator]MSP[S] return old ; } if ( key1 == null ) { final V old = value1 ; hash1 = hash2 ; key1 = key2 ; value1 = value2 ; hash2 = 0 ; key2 = null ; value2 = null ;
buf . append ( value2 == this ? lr_9 : value2 ) ; buf . append ( ',' ) ; case 1 : buf . append ( key1 == this ? lr_9 : key1 ) ; buf . append ( '=' ) ; MST[rv.CRCR5Mutator]MSP[N]
return false ; } otherValue = other . get ( key1 ) ; if ( value1 == null ? otherValue != null : ! value1 . equals ( otherValue ) ) { return false ; } } } return true ; MST[ReturnValsMutator]MSP[N] } @Override public int hashCode () {
value2 = value3 ; hash3 = 0 ; MST[experimental.MemberVariableMutator]MSP[S] key3 = null ; value3 = null ; size = 2 ; return old ; } if ( hash1 == hashCode && key . equals ( key1 ) ) { final V old = value1 ; hash1 = hash3 ;
if ( hash1 == hashCode && key . equals ( key1 ) ) { return true ; } } } } return false ; MST[ReturnValsMutator]MSP[N] } @Override public boolean containsValue ( final Object value ) { if ( delegateMap != null ) { return delegateMap . containsValue ( value ) ;
if ( delegateMap != null ) { return delegateMap . hashCode () ; } int total = 0 ; switch ( size ) { case 3 : total += hash3 ^ ( value3 == null ? 0 : value3 . hashCode () ) ; MST[rv.ABSMutator]MSP[S] case 2 :
buf . append ( value3 == this ? lr_9 : value3 ) ; buf . append ( ',' ) ; MST[InlineConstantMutator]MSP[S] case 2 : buf . append ( key2 == this ? lr_9 : key2 ) ; buf . append ( '=' ) ;
if ( delegateMap != null ) { return delegateMap . hashCode () ; } int total = 0 ; switch ( size ) { case 3 : total += hash3 ^ ( value3 == null ? 0 : value3 . hashCode () ) ; MST[rv.UOI3Mutator]MSP[S] case 2 :
hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } if ( hash2 == hashCode && key . equals ( key2 ) ) { final V old = value2 ; hash2 = hash3 ; MST[experimental.MemberVariableMutator]MSP[S] key2 = key3 ;
if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] final V old = value1 ; value1 = value ; return old ; } } } } switch ( size ) { default: convertToMap () ; delegateMap . put ( key , value ) ;
if ( value1 == null ) { return true ; } } } else { switch ( size ) { case 3 : if ( value . equals ( value3 ) ) { MST[NegateConditionalsMutator]MSP[N] return true ; } case 2 : if ( value . equals ( value2 ) ) {
if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { MST[rv.ABSMutator]MSP[S] case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { final V old = value3 ; value3 = value ;
throw new IllegalStateException ( lr_1 + size ) ; } return total ; MST[rv.ABSMutator]MSP[S] } @Override public String toString () { if ( delegateMap != null ) { return delegateMap . toString () ; } if ( size == 0 ) { return lr_8 ; }
final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[rv.UOI4Mutator]MSP[N] return value3 ; } case 2 :
return new EntrySet <> ( this ) ; MST[ReturnValsMutator]MSP[S] } @Override public int size () { return parent . size () ; } @Override public void clear () { parent . clear () ; } @Override public boolean remove ( final Object obj ) {
return; } if ( size < 4 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[S] for ( final Map . Entry < ? extends K , ? extends V > entry : map . entrySet () ) { put ( entry . getKey () , entry . getValue () ) ; } } else {
} if ( value == null ) { switch ( size ) { MST[rv.UOI1Mutator]MSP[N] case 3 : if ( value3 == null ) { return true ; } case 2 : if ( value2 == null ) { return true ; } case 1 :
hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } return null ; case 2 : if ( key2 == null ) { MST[rv.ROR5Mutator]MSP[S] final V old = value2 ; hash2 = 0 ; key2 = null ;
final StringBuilder buf = new StringBuilder ( 128 ) ; MST[rv.CRCR2Mutator]MSP[S] buf . append ( '{' ) ; switch ( size ) { case 3 : buf . append ( key3 == this ? lr_9 : key3 ) ; buf . append ( '=' ) ;
if ( hash2 == hashCode && key . equals ( key2 ) ) { return value2 ; } case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.ROR2Mutator]MSP[N] return value1 ; } } } } return null ; } @Override
public int size () { if ( delegateMap != null ) { return delegateMap . size () ; } return size ; } @Override public boolean isEmpty () { return size () == 0 ; MST[rv.ROR4Mutator]MSP[N] } @Override public boolean containsKey ( final Object key ) {
buf . append ( value3 == this ? lr_9 : value3 ) ; buf . append ( ',' ) ; case 2 : buf . append ( key2 == this ? lr_9 : key2 ) ; buf . append ( '=' ) ; MST[NonVoidMethodCallMutator]MSP[N]
return null ; case 2 : hash3 = key == null ? 0 : key . hashCode () ; MST[rv.CRCR6Mutator]MSP[S] key3 = key ; value3 = value ; break; case 1 : hash2 = key == null ? 0 : key . hashCode () ; key2 = key ;
hash3 = 0 ; key3 = null ; MST[experimental.MemberVariableMutator]MSP[S] value3 = null ; size = 2 ; return old ; } return null ; case 2 : if ( key2 == null ) { final V old = value2 ; hash2 = 0 ; key2 = null ;
public Set < K > keySet () { if ( delegateMap != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] return delegateMap . keySet () ; } return new KeySet <> ( this ) ; } @Override public int size () { return parent . size () ; } @Override public void clear () {
if ( size != other . size () ) { MST[NonVoidMethodCallMutator]MSP[N] return false ; } if ( size > 0 ) { Object otherValue = null ; switch ( size ) { case 3 : if ( other . containsKey ( key3 ) == false ) { return false ; }
key1 = key2 ; value1 = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; return old ; } return null ; case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[NegateConditionalsMutator]MSP[N]
final V old = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; return old ; } if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.ROR5Mutator]MSP[N] final V old = value1 ; hash1 = hash2 ;
value2 = value ; break; case 0 : hash1 = key == null ? 0 : key . hashCode () ; key1 = key ; value1 = value ; break; } size ++ ; MST[rv.CRCR6Mutator]MSP[N] return null ; } @Override
buf . append ( value2 == this ? lr_9 : value2 ) ; MST[NonVoidMethodCallMutator]MSP[S] buf . append ( ',' ) ; case 1 : buf . append ( key1 == this ? lr_9 : key1 ) ; buf . append ( '=' ) ;
value2 = value3 ; hash3 = 0 ; MST[InlineConstantMutator]MSP[S] key3 = null ; value3 = null ; size = 2 ; return old ; } if ( hash1 == hashCode && key . equals ( key1 ) ) { final V old = value1 ; hash1 = hash3 ;
public int size () { if ( delegateMap != null ) { return delegateMap . size () ; MST[PrimitiveReturnsMutator]MSP[N] } return size ; } @Override public boolean isEmpty () { return size () == 0 ; } @Override public boolean containsKey ( final Object key ) {
if ( value1 == null ) { MST[NegateConditionalsMutator]MSP[N] return true ; } } } else { switch ( size ) { case 3 : if ( value . equals ( value3 ) ) { return true ; } case 2 : if ( value . equals ( value2 ) ) {
size = 1 ; return old ; } return null ; case 1 : if ( key1 == null ) { final V old = value1 ; hash1 = 0 ; key1 = null ; value1 = null ; size = 0 ; MST[rv.CRCR1Mutator]MSP[S] return old ; } }
if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] final V old = value1 ; value1 = value ; return old ; } } } } switch ( size ) { default: convertToMap () ; delegateMap . put ( key , value ) ;
public int size () { if ( delegateMap != null ) { return delegateMap . size () ; } return size ; MST[rv.UOI3Mutator]MSP[N] } @Override public boolean isEmpty () { return size () == 0 ; } @Override public boolean containsKey ( final Object key ) {
total += hash2 ^ ( value2 == null ? 0 : value2 . hashCode () ) ; MST[rv.UOI3Mutator]MSP[S] case 1 : total += hash1 ^ ( value1 == null ? 0 : value1 . hashCode () ) ; case 0 : break; default:
if ( delegateMap != null ) { return delegateMap . containsKey ( key ) ; } if ( key == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] switch ( size ) { case 3 : if ( key3 == null ) { return true ; } case 2 :
delegateMap . put ( key2 , value2 ) ; case 1 : delegateMap . put ( key1 , value1 ) ; case 0 : break; default: throw new IllegalStateException ( lr_1 + size ) ; } size = 0 ; hash1 = hash2 = hash3 = 0 ; MST[experimental.MemberVariableMutator]MSP[S]
final V old = value3 ; hash3 = 0 ; MST[InlineConstantMutator]MSP[S] key3 = null ; value3 = null ; size = 2 ; return old ; } if ( key2 == null ) { final V old = value2 ; hash2 = hash3 ; key2 = key3 ;
value2 = value ; break; case 0 : hash1 = key == null ? 0 : key . hashCode () ; key1 = key ; value1 = value ; break; } size ++ ; MST[rv.AOD1Mutator]MSP[N] return null ; } @Override
total += hash2 ^ ( value2 == null ? 0 : value2 . hashCode () ) ; case 1 : total += hash1 ^ ( value1 == null ? 0 : value1 . hashCode () ) ; MST[MathMutator]MSP[S] case 0 : break; default:
} else { if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] final V old = value3 ;
@Override public V get ( final Object key ) { if ( delegateMap != null ) { return delegateMap . get ( key ) ; } if ( key == null ) { switch ( size ) { case 3 : if ( key3 == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; MST[rv.CRCR4Mutator]MSP[N] return old ; } if ( hash2 == hashCode && key . equals ( key2 ) ) { final V old = value2 ; hash2 = hash3 ; key2 = key3 ;
if ( value1 == null ) { return true ; } } } else { switch ( size ) { case 3 : if ( value . equals ( value3 ) ) { MST[rv.ROR2Mutator]MSP[S] return true ; } case 2 : if ( value . equals ( value2 ) ) {
return old ; } case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.ROR4Mutator]MSP[S] final V old = value2 ; value2 = value ; return old ; } case 1 :
public MapIterator < K , V > mapIterator () { if ( delegateMap != null ) { return delegateMap . mapIterator () ; } if ( size == 0 ) { return EmptyMapIterator . <K , V > emptyMapIterator () ; } return new FlatMapIterator <> ( this ) ; MST[ConstructorCallMutator]MSP[S]
if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.UOI1Mutator]MSP[N] return value2 ; } case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { return value1 ; } } } } return null ; } @Override
hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; MST[ReturnValsMutator]MSP[S] } if ( hash2 == hashCode && key . equals ( key2 ) ) { final V old = value2 ; hash2 = hash3 ; key2 = key3 ;
key1 = key3 ; value1 = value3 ; hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } return null ; case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.UOI4Mutator]MSP[N]
if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] return true ; } } } } return false ; } @Override public boolean containsValue ( final Object value ) { if ( delegateMap != null ) { return delegateMap . containsValue ( value ) ;
buf . append ( value1 == this ? lr_9 : value1 ) ; MST[NonVoidMethodCallMutator]MSP[S] break; default: throw new IllegalStateException ( lr_1 + size ) ; } buf . append ( '}' ) ; return buf . toString () ; }
if ( key2 == null ) { return true ; MST[rv.CRCR2Mutator]MSP[N] } case 1 : if ( key1 == null ) { return true ; } } } else { if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) {
key1 = key2 ; value1 = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; MST[InlineConstantMutator]MSP[N] return old ; } return null ; case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) {
if ( hash2 == hashCode && key . equals ( key2 ) ) { return value2 ; } case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.UOI1Mutator]MSP[S] return value1 ; } } } } return null ; } @Override
if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.ROR2Mutator]MSP[N] return value2 ; } case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { return value1 ; } } } } return null ; } @Override
delegateMap . clear () ; delegateMap = null ; } else { size = 0 ; hash1 = hash2 = hash3 = 0 ; MST[InlineConstantMutator]MSP[S] key1 = key2 = key3 = null ; value1 = value2 = value3 = null ; } } @Override
return old ; } case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.UOI3Mutator]MSP[S] final V old = value2 ; value2 = value ; return old ; } case 1 :
return true ; } case 1 : if ( value . equals ( value1 ) ) { return true ; } } } return false ; MST[rv.CRCR1Mutator]MSP[N] } @Override public V put ( final K key , final V value ) { if ( delegateMap != null ) {
if ( delegateMap != null ) { return delegateMap . hashCode () ; } int total = 0 ; MST[rv.CRCR3Mutator]MSP[S] switch ( size ) { case 3 : total += hash3 ^ ( value3 == null ? 0 : value3 . hashCode () ) ; case 2 :
if ( key2 == null ) { return true ; } case 1 : if ( key1 == null ) { return true ; } } } else { if ( size > 0 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[S] final int hashCode = key . hashCode () ; switch ( size ) {
return null ; case 2 : hash3 = key == null ? 0 : key . hashCode () ; key3 = key ; value3 = value ; break; case 1 : hash2 = key == null ? 0 : key . hashCode () ; MST[rv.CRCR1Mutator]MSP[S] key2 = key ;
if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.UOI3Mutator]MSP[N] return true ; } } } } return false ; } @Override public boolean containsValue ( final Object value ) { if ( delegateMap != null ) { return delegateMap . containsValue ( value ) ;
if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.ROR4Mutator]MSP[N] return true ; } } } } return false ; } @Override public boolean containsValue ( final Object value ) { if ( delegateMap != null ) { return delegateMap . containsValue ( value ) ;
if ( delegateMap != null ) { return delegateMap . remove ( key ) ; } if ( size == 0 ) { return null ; } if ( key == null ) { switch ( size ) { case 3 : if ( key3 == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S]
value2 = value3 ; hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } if ( key1 == null ) { final V old = value1 ; hash1 = hash3 ; MST[rv.UOI4Mutator]MSP[S] key1 = key3 ; value1 = value3 ;
buf . append ( value2 == this ? lr_9 : value2 ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] buf . append ( ',' ) ; case 1 : buf . append ( key1 == this ? lr_9 : key1 ) ; buf . append ( '=' ) ;
public Collection < V > values () { if ( delegateMap != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] return delegateMap . values () ; } return new Values <> ( this ) ; } @Override public int size () { return parent . size () ; } @Override public void clear () {
if ( hash1 == hashCode && key . equals ( key1 ) ) { final V old = value1 ; value1 = value ; return old ; } } } } switch ( size ) { default: convertToMap () ; delegateMap . put ( key , value ) ; MST[NonVoidMethodCallMutator]MSP[N]
buf . append ( value2 == this ? lr_9 : value2 ) ; buf . append ( ',' ) ; case 1 : buf . append ( key1 == this ? lr_9 : key1 ) ; buf . append ( '=' ) ; MST[NonVoidMethodCallMutator]MSP[N]
} else { if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] final V old = value3 ;
public int size () { if ( delegateMap != null ) { return delegateMap . size () ; } return size ; } @Override public boolean isEmpty () { return size () == 0 ; MST[rv.CRCR4Mutator]MSP[S] } @Override public boolean containsKey ( final Object key ) {
return value3 ; } case 2 : if ( key2 == null ) { return value2 ; } case 1 : if ( key1 == null ) { return value1 ; } } } else { if ( size > 0 ) { MST[rv.ROR2Mutator]MSP[N]
if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[rv.UOI4Mutator]MSP[S] final V old = value3 ; value3 = value ;
key1 = key3 ; value1 = value3 ; hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } return null ; case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.UOI1Mutator]MSP[N]
size = 1 ; return old ; } return null ; case 1 : if ( key1 == null ) { final V old = value1 ; hash1 = 0 ; MST[experimental.MemberVariableMutator]MSP[S] key1 = null ; value1 = null ; size = 0 ; return old ; } }
throw new IllegalStateException ( lr_1 + size ) ; } return total ; } @Override public String toString () { if ( delegateMap != null ) { MST[rv.ROR5Mutator]MSP[S] return delegateMap . toString () ; } if ( size == 0 ) { return lr_8 ; }
case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { return true ; } case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.UOI3Mutator]MSP[S] return true ; } case 1 :
key1 = key2 ; value1 = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; return old ; } return null ; case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.ABSMutator]MSP[N]
if ( size > 0 ) { MST[rv.ROR1Mutator]MSP[S] final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { final V old = value3 ; value3 = value ;
} else { if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { MST[experimental.SwitchMutator]MSP[N] case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { final V old = value3 ;
size = 1 ; return old ; } return null ; case 1 : if ( key1 == null ) { final V old = value1 ; hash1 = 0 ; MST[rv.CRCR6Mutator]MSP[S] key1 = null ; value1 = null ; size = 0 ; return old ; } }
final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[rv.ROR2Mutator]MSP[N] return value3 ; } case 2 :
return null ; case 2 : hash3 = key == null ? 0 : key . hashCode () ; key3 = key ; value3 = value ; break; case 1 : hash2 = key == null ? 0 : key . hashCode () ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] key2 = key ;
cloned . delegateMap = cloned . delegateMap . clone () ; } return cloned ; MST[NullReturnValsMutator]MSP[S] } catch ( final CloneNotSupportedException ex ) { throw new InternalError () ; } } @Override public boolean equals ( final Object obj ) { if ( obj == this ) { return true ;
key1 = key3 ; value1 = value3 ; hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } return null ; case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.ROR1Mutator]MSP[S]
key1 = key2 ; value1 = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; return old ; } return null ; case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] final V old = value3 ; value3 = value ;
return value3 ; } case 2 : if ( key2 == null ) { return value2 ; } case 1 : if ( key1 == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] return value1 ; } } } else { if ( size > 0 ) {
if ( value1 == null ) { return true ; } } } else { switch ( size ) { case 3 : if ( value . equals ( value3 ) ) { MST[rv.ROR5Mutator]MSP[N] return true ; } case 2 : if ( value . equals ( value2 ) ) {
return; } if ( size < 4 ) { MST[rv.UOI2Mutator]MSP[S] for ( final Map . Entry < ? extends K , ? extends V > entry : map . entrySet () ) { put ( entry . getKey () , entry . getValue () ) ; } } else {
if ( delegateMap != null ) { return delegateMap . containsKey ( key ) ; } if ( key == null ) { switch ( size ) { case 3 : if ( key3 == null ) { return true ; MST[rv.CRCR3Mutator]MSP[S] } case 2 :
buf . append ( value1 == this ? lr_9 : value1 ) ; break; default: throw new IllegalStateException ( lr_1 + size ) ; } buf . append ( '}' ) ; MST[rv.CRCR4Mutator]MSP[N] return buf . toString () ; }
buf . append ( value2 == this ? lr_9 : value2 ) ; buf . append ( ',' ) ; case 1 : buf . append ( key1 == this ? lr_9 : key1 ) ; buf . append ( '=' ) ; MST[rv.CRCR1Mutator]MSP[N]
if ( hash1 == hashCode && key . equals ( key1 ) ) { return true ; MST[rv.CRCR5Mutator]MSP[N] } } } } return false ; } @Override public boolean containsValue ( final Object value ) { if ( delegateMap != null ) { return delegateMap . containsValue ( value ) ;
return true ; MST[BooleanFalseReturnValsMutator]MSP[N] } case 1 : if ( value . equals ( value1 ) ) { return true ; } } } return false ; } @Override public V put ( final K key , final V value ) { if ( delegateMap != null ) {
if ( delegateMap != null ) { return delegateMap . containsKey ( key ) ; MST[BooleanTrueReturnValsMutator]MSP[S] } if ( key == null ) { switch ( size ) { case 3 : if ( key3 == null ) { return true ; } case 2 :
if ( hash1 == hashCode && key . equals ( key1 ) ) { final V old = value1 ; value1 = value ; return old ; } } } } switch ( size ) { MST[rv.UOI3Mutator]MSP[N] default: convertToMap () ; delegateMap . put ( key , value ) ;
final V old = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; return old ; } if ( hash1 == hashCode && key . equals ( key1 ) ) { final V old = value1 ; hash1 = hash2 ; MST[rv.ABSMutator]MSP[S]
key1 = key2 ; value1 = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; return old ; } return null ; case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.ROR5Mutator]MSP[N]
if ( delegateMap != null ) { return delegateMap . remove ( key ) ; MST[NonVoidMethodCallMutator]MSP[N] } if ( size == 0 ) { return null ; } if ( key == null ) { switch ( size ) { case 3 : if ( key3 == null ) {
} else { if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[rv.ROR2Mutator]MSP[S] final V old = value3 ;
public Flat3Map < K , V > clone () { try { final Flat3Map < K , V > cloned = ( Flat3Map < K , V > ) super . clone () ; if ( cloned . delegateMap != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S]
final V old = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; return old ; } if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.ABSMutator]MSP[N] final V old = value1 ; hash1 = hash2 ;
buf . append ( value3 == this ? lr_9 : value3 ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] buf . append ( ',' ) ; case 2 : buf . append ( key2 == this ? lr_9 : key2 ) ; buf . append ( '=' ) ;
value2 = value ; MST[experimental.MemberVariableMutator]MSP[N] break; case 0 : hash1 = key == null ? 0 : key . hashCode () ; key1 = key ; value1 = value ; break; } size ++ ; return null ; } @Override
value2 = value ; break; case 0 : hash1 = key == null ? 0 : key . hashCode () ; key1 = key ; value1 = value ; break; } size ++ ; MST[rv.AOR3Mutator]MSP[N] return null ; } @Override
return null ; case 2 : hash3 = key == null ? 0 : key . hashCode () ; MST[NonVoidMethodCallMutator]MSP[N] key3 = key ; value3 = value ; break; case 1 : hash2 = key == null ? 0 : key . hashCode () ; key2 = key ;
if ( delegateMap != null ) { MST[rv.ROR5Mutator]MSP[N] return delegateMap . remove ( key ) ; } if ( size == 0 ) { return null ; } if ( key == null ) { switch ( size ) { case 3 : if ( key3 == null ) {
final int hashCode = key . hashCode () ; switch ( size ) { MST[rv.UOI3Mutator]MSP[N] case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { return value3 ; } case 2 :
if ( key2 == null ) { return true ; } case 1 : if ( key1 == null ) { return true ; } } } else { if ( size > 0 ) { MST[rv.ABSMutator]MSP[N] final int hashCode = key . hashCode () ; switch ( size ) {
return true ; MST[rv.CRCR4Mutator]MSP[S] } case 1 : if ( value . equals ( value1 ) ) { return true ; } } } return false ; } @Override public V put ( final K key , final V value ) { if ( delegateMap != null ) {
if ( delegateMap != null ) { return delegateMap . remove ( key ) ; } if ( size == 0 ) { MST[NegateConditionalsMutator]MSP[N] return null ; } if ( key == null ) { switch ( size ) { case 3 : if ( key3 == null ) {
final int hashCode = key . hashCode () ; switch ( size ) { MST[rv.ABSMutator]MSP[N] case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { return value3 ; } case 2 :
if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { MST[rv.UOI2Mutator]MSP[N] case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { final V old = value3 ; value3 = value ;
final StringBuilder buf = new StringBuilder ( 128 ) ; buf . append ( '{' ) ; switch ( size ) { case 3 : buf . append ( key3 == this ? lr_9 : key3 ) ; MST[rv.ROR5Mutator]MSP[S] buf . append ( '=' ) ;
total += hash2 ^ ( value2 == null ? 0 : value2 . hashCode () ) ; MST[MathMutator]MSP[S] case 1 : total += hash1 ^ ( value1 == null ? 0 : value1 . hashCode () ) ; case 0 : break; default:
size = 1 ; return old ; } return null ; case 1 : if ( key1 == null ) { final V old = value1 ; hash1 = 0 ; key1 = null ; value1 = null ; size = 0 ; return old ; MST[ReturnValsMutator]MSP[S] } }
return value3 ; } case 2 : if ( key2 == null ) { return value2 ; } case 1 : if ( key1 == null ) { MST[rv.ROR5Mutator]MSP[N] return value1 ; } } } else { if ( size > 0 ) {
} if ( value == null ) { switch ( size ) { MST[rv.UOI4Mutator]MSP[N] case 3 : if ( value3 == null ) { return true ; } case 2 : if ( value2 == null ) { return true ; } case 1 :
total += hash2 ^ ( value2 == null ? 0 : value2 . hashCode () ) ; case 1 : total += hash1 ^ ( value1 == null ? 0 : value1 . hashCode () ) ; MST[rv.UOI3Mutator]MSP[S] case 0 : break; default:
case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { return true ; } case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.UOI2Mutator]MSP[S] return true ; } case 1 :
case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[rv.ABSMutator]MSP[S] return true ; } case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { return true ; } case 1 :
size = 1 ; return old ; } return null ; case 1 : if ( key1 == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] final V old = value1 ; hash1 = 0 ; key1 = null ; value1 = null ; size = 0 ; return old ; } }
final V old = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; return old ; } if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] final V old = value1 ; hash1 = hash2 ;
public void putAll ( final Map < ? extends K , ? extends V > map ) { final int size = map . size () ; if ( size == 0 ) { return; } if ( delegateMap != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] delegateMap . putAll ( map ) ;
convertToMap () ; delegateMap . putAll ( map ) ; } } private void convertToMap () { delegateMap = createDelegateMap () ; switch ( size ) { case 3 : delegateMap . put ( key3 , value3 ) ; MST[NonVoidMethodCallMutator]MSP[N] case 2 :
buf . append ( value3 == this ? lr_9 : value3 ) ; buf . append ( ',' ) ; case 2 : buf . append ( key2 == this ? lr_9 : key2 ) ; MST[NegateConditionalsMutator]MSP[N] buf . append ( '=' ) ;
public void putAll ( final Map < ? extends K , ? extends V > map ) { final int size = map . size () ; if ( size == 0 ) { MST[rv.ROR1Mutator]MSP[N] return; } if ( delegateMap != null ) { delegateMap . putAll ( map ) ;
convertToMap () ; delegateMap . putAll ( map ) ; } } private void convertToMap () { delegateMap = createDelegateMap () ; switch ( size ) { MST[experimental.SwitchMutator]MSP[S] case 3 : delegateMap . put ( key3 , value3 ) ; case 2 :
final V old = value1 ; hash1 = 0 ; MST[rv.CRCR5Mutator]MSP[S] key1 = null ; value1 = null ; size = 0 ; return old ; } } } } return null ; } @Override public void clear () { if ( delegateMap != null ) {
final StringBuilder buf = new StringBuilder ( 128 ) ; buf . append ( '{' ) ; switch ( size ) { case 3 : buf . append ( key3 == this ? lr_9 : key3 ) ; MST[NegateConditionalsMutator]MSP[S] buf . append ( '=' ) ;
final V old = value3 ; hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } if ( key2 == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] final V old = value2 ; hash2 = hash3 ; key2 = key3 ;
buf . append ( value1 == this ? lr_9 : value1 ) ; break; default: throw new IllegalStateException ( lr_1 + size ) ; } buf . append ( '}' ) ; MST[rv.CRCR1Mutator]MSP[N] return buf . toString () ; }
return true ; } case 1 : if ( value . equals ( value1 ) ) { MST[rv.ROR3Mutator]MSP[N] return true ; } } } return false ; } @Override public V put ( final K key , final V value ) { if ( delegateMap != null ) {
delegateMap . clear () ; delegateMap = null ; } else { size = 0 ; hash1 = hash2 = hash3 = 0 ; key1 = key2 = key3 = null ; value1 = value2 = value3 = null ; MST[experimental.MemberVariableMutator]MSP[S] } } @Override
throw new IllegalStateException ( lr_1 + size ) ; } return total ; } @Override public String toString () { if ( delegateMap != null ) { return delegateMap . toString () ; } if ( size == 0 ) { MST[rv.ABSMutator]MSP[S] return lr_8 ; }
total += hash2 ^ ( value2 == null ? 0 : value2 . hashCode () ) ; case 1 : total += hash1 ^ ( value1 == null ? 0 : value1 . hashCode () ) ; MST[rv.ABSMutator]MSP[S] case 0 : break; default:
if ( hash1 == hashCode && key . equals ( key1 ) ) { return true ; MST[rv.CRCR2Mutator]MSP[N] } } } } return false ; } @Override public boolean containsValue ( final Object value ) { if ( delegateMap != null ) { return delegateMap . containsValue ( value ) ;
cloned . delegateMap = cloned . delegateMap . clone () ; } return cloned ; } catch ( final CloneNotSupportedException ex ) { throw new InternalError () ; } } @Override public boolean equals ( final Object obj ) { if ( obj == this ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return true ;
case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { return true ; } case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] return true ; } case 1 :
return old ; } case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] final V old = value2 ; value2 = value ; return old ; } case 1 :
if ( delegateMap != null ) { return delegateMap . containsKey ( key ) ; } if ( key == null ) { switch ( size ) { case 3 : if ( key3 == null ) { MST[NegateConditionalsMutator]MSP[N] return true ; } case 2 :
if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[rv.ROR1Mutator]MSP[S] final V old = value3 ; value3 = value ;
if ( key2 == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return true ; } case 1 : if ( key1 == null ) { return true ; } } } else { if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) {
if ( hash2 == hashCode && key . equals ( key2 ) ) { return value2 ; } case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.UOI2Mutator]MSP[N] return value1 ; } } } } return null ; } @Override
if ( delegateMap != null ) { return delegateMap . containsKey ( key ) ; } if ( key == null ) { switch ( size ) { case 3 : if ( key3 == null ) { MST[rv.ROR5Mutator]MSP[N] return true ; } case 2 :
final V old = value3 ; hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; MST[rv.CRCR1Mutator]MSP[N] return old ; } if ( key2 == null ) { final V old = value2 ; hash2 = hash3 ; key2 = key3 ;
delegateMap . put ( key2 , value2 ) ; case 1 : delegateMap . put ( key1 , value1 ) ; case 0 : break; default: throw new IllegalStateException ( lr_1 + size ) ; } size = 0 ; hash1 = hash2 = hash3 = 0 ; MST[rv.CRCR6Mutator]MSP[S]
final V old = value3 ; hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } if ( key2 == null ) { MST[NegateConditionalsMutator]MSP[S] final V old = value2 ; hash2 = hash3 ; key2 = key3 ;
if ( delegateMap != null ) { return delegateMap . hashCode () ; } int total = 0 ; MST[InlineConstantMutator]MSP[S] switch ( size ) { case 3 : total += hash3 ^ ( value3 == null ? 0 : value3 . hashCode () ) ; case 2 :
value2 = value3 ; hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; MST[rv.CRCR1Mutator]MSP[N] return old ; } if ( hash1 == hashCode && key . equals ( key1 ) ) { final V old = value1 ; hash1 = hash3 ;
buf . append ( value3 == this ? lr_9 : value3 ) ; buf . append ( ',' ) ; case 2 : buf . append ( key2 == this ? lr_9 : key2 ) ; MST[rv.ROR5Mutator]MSP[N] buf . append ( '=' ) ;
final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[rv.UOI1Mutator]MSP[S] return value3 ; } case 2 :
value2 = value ; break; case 0 : hash1 = key == null ? 0 : key . hashCode () ; key1 = key ; value1 = value ; break; } size ++ ; MST[rv.UOI4Mutator]MSP[N] return null ; } @Override
cloned . delegateMap = cloned . delegateMap . clone () ; } return cloned ; } catch ( final CloneNotSupportedException ex ) { throw new InternalError () ; } } @Override public boolean equals ( final Object obj ) { if ( obj == this ) { return true ; MST[rv.CRCR2Mutator]MSP[N]
return lr_2 + getKey () + lr_3 + getValue () + lr_4 ; } return lr_5 ; } @Override public Set < Map . Entry < K , V > > entrySet () { if ( delegateMap != null ) { return delegateMap . entrySet () ; MST[ReturnValsMutator]MSP[S] }
delegateMap . clear () ; delegateMap = null ; } else { size = 0 ; hash1 = hash2 = hash3 = 0 ; key1 = key2 = key3 = null ; MST[experimental.MemberVariableMutator]MSP[S] value1 = value2 = value3 = null ; } } @Override
return value3 ; } case 2 : if ( key2 == null ) { return value2 ; } case 1 : if ( key1 == null ) { return value1 ; } } } else { if ( size > 0 ) { MST[rv.ROR4Mutator]MSP[S]
final V old = value1 ; hash1 = 0 ; key1 = null ; value1 = null ; size = 0 ; return old ; } } } } return null ; } @Override public void clear () { if ( delegateMap != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S]
hash3 = 0 ; MST[rv.CRCR3Mutator]MSP[S] key3 = null ; value3 = null ; size = 2 ; return old ; } return null ; case 2 : if ( key2 == null ) { final V old = value2 ; hash2 = 0 ; key2 = null ;
if ( delegateMap != null ) { return delegateMap . remove ( key ) ; MST[ReturnValsMutator]MSP[S] } if ( size == 0 ) { return null ; } if ( key == null ) { switch ( size ) { case 3 : if ( key3 == null ) {
key1 = key3 ; value1 = value3 ; hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } return null ; case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.UOI3Mutator]MSP[N]
} else { if ( size > 0 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[S] final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { final V old = value3 ;
buf . append ( value3 == this ? lr_9 : value3 ) ; buf . append ( ',' ) ; case 2 : buf . append ( key2 == this ? lr_9 : key2 ) ; MST[experimental.NakedReceiverMutator]MSP[S] buf . append ( '=' ) ;
public void putAll ( final Map < ? extends K , ? extends V > map ) { final int size = map . size () ; if ( size == 0 ) { MST[rv.UOI3Mutator]MSP[S] return; } if ( delegateMap != null ) { delegateMap . putAll ( map ) ;
final StringBuilder buf = new StringBuilder ( 128 ) ; buf . append ( '{' ) ; MST[rv.CRCR4Mutator]MSP[N] switch ( size ) { case 3 : buf . append ( key3 == this ? lr_9 : key3 ) ; buf . append ( '=' ) ;
public int size () { if ( delegateMap != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return delegateMap . size () ; } return size ; } @Override public boolean isEmpty () { return size () == 0 ; } @Override public boolean containsKey ( final Object key ) {
final V old = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; MST[experimental.MemberVariableMutator]MSP[N] return old ; } if ( hash1 == hashCode && key . equals ( key1 ) ) { final V old = value1 ; hash1 = hash2 ;
return value3 ; } case 2 : if ( key2 == null ) { return value2 ; } case 1 : if ( key1 == null ) { MST[NegateConditionalsMutator]MSP[N] return value1 ; } } } else { if ( size > 0 ) {
buf . append ( value2 == this ? lr_9 : value2 ) ; buf . append ( ',' ) ; case 1 : buf . append ( key1 == this ? lr_9 : key1 ) ; MST[NegateConditionalsMutator]MSP[N] buf . append ( '=' ) ;
return old ; } case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] final V old = value2 ; value2 = value ; return old ; } case 1 :
return delegateMap . put ( key , value ) ; } if ( key == null ) { switch ( size ) { case 3 : if ( key3 == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] final V old = value3 ; value3 = value ; return old ; } case 2 :
if ( size != other . size () ) { return false ; MST[ReturnValsMutator]MSP[N] } if ( size > 0 ) { Object otherValue = null ; switch ( size ) { case 3 : if ( other . containsKey ( key3 ) == false ) { return false ; }
if ( key2 == null ) { return true ; } case 1 : if ( key1 == null ) { return true ; MST[ReturnValsMutator]MSP[N] } } } else { if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) {
total += hash2 ^ ( value2 == null ? 0 : value2 . hashCode () ) ; case 1 : total += hash1 ^ ( value1 == null ? 0 : value1 . hashCode () ) ; MST[rv.CRCR1Mutator]MSP[S] case 0 : break; default:
final V old = value3 ; hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } if ( key2 == null ) { MST[rv.ROR5Mutator]MSP[S] final V old = value2 ; hash2 = hash3 ; key2 = key3 ;
buf . append ( value3 == this ? lr_9 : value3 ) ; MST[NonVoidMethodCallMutator]MSP[S] buf . append ( ',' ) ; case 2 : buf . append ( key2 == this ? lr_9 : key2 ) ; buf . append ( '=' ) ;
final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[rv.ROR4Mutator]MSP[N] return value3 ; } case 2 :
hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } return null ; case 2 : if ( key2 == null ) { MST[NegateConditionalsMutator]MSP[S] final V old = value2 ; hash2 = 0 ; key2 = null ;
public void putAll ( final Map < ? extends K , ? extends V > map ) { final int size = map . size () ; MST[NonVoidMethodCallMutator]MSP[N] if ( size == 0 ) { return; } if ( delegateMap != null ) { delegateMap . putAll ( map ) ;
if ( delegateMap != null ) { MST[NegateConditionalsMutator]MSP[N] return delegateMap . remove ( key ) ; } if ( size == 0 ) { return null ; } if ( key == null ) { switch ( size ) { case 3 : if ( key3 == null ) {
throw new IllegalStateException ( lr_1 + size ) ; } return total ; } @Override public String toString () { if ( delegateMap != null ) { return delegateMap . toString () ; } if ( size == 0 ) { return lr_8 ; MST[ReturnValsMutator]MSP[N] }
if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[rv.UOI3Mutator]MSP[S] final V old = value3 ; value3 = value ;
case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[rv.UOI2Mutator]MSP[S] return true ; } case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { return true ; } case 1 :
key1 = key3 ; value1 = value3 ; hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } return null ; case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.UOI2Mutator]MSP[S]
convertToMap () ; delegateMap . putAll ( map ) ; } } private void convertToMap () { delegateMap = createDelegateMap () ; switch ( size ) { MST[rv.ABSMutator]MSP[S] case 3 : delegateMap . put ( key3 , value3 ) ; case 2 :
final V old = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; return old ; } if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[NegateConditionalsMutator]MSP[N] final V old = value1 ; hash1 = hash2 ;
public MapIterator < K , V > mapIterator () { if ( delegateMap != null ) { return delegateMap . mapIterator () ; } if ( size == 0 ) { MST[rv.UOI2Mutator]MSP[N] return EmptyMapIterator . <K , V > emptyMapIterator () ; } return new FlatMapIterator <> ( this ) ;
if ( delegateMap != null ) { return delegateMap . hashCode () ; } int total = 0 ; switch ( size ) { case 3 : total += hash3 ^ ( value3 == null ? 0 : value3 . hashCode () ) ; MST[rv.UOI1Mutator]MSP[S] case 2 :
key1 = key2 ; value1 = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; MST[rv.CRCR6Mutator]MSP[N] return old ; } return null ; case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) {
if ( value1 == null ) { MST[rv.ROR5Mutator]MSP[N] return true ; } } } else { switch ( size ) { case 3 : if ( value . equals ( value3 ) ) { return true ; } case 2 : if ( value . equals ( value2 ) ) {
if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.ROR4Mutator]MSP[N] return value2 ; } case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { return value1 ; } } } } return null ; } @Override
final StringBuilder buf = new StringBuilder ( 128 ) ; buf . append ( '{' ) ; switch ( size ) { case 3 : buf . append ( key3 == this ? lr_9 : key3 ) ; buf . append ( '=' ) ; MST[NonVoidMethodCallMutator]MSP[S]
key1 = key2 ; value1 = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; return old ; } return null ; case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.ROR2Mutator]MSP[N]
if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.ROR3Mutator]MSP[N] final V old = value1 ; value1 = value ; return old ; } } } } switch ( size ) { default: convertToMap () ; delegateMap . put ( key , value ) ;
return value3 ; } case 2 : if ( key2 == null ) { return value2 ; } case 1 : if ( key1 == null ) { return value1 ; } } } else { if ( size > 0 ) { MST[rv.UOI1Mutator]MSP[N]
value2 = value3 ; hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } if ( key1 == null ) { final V old = value1 ; hash1 = hash3 ; MST[rv.UOI2Mutator]MSP[S] key1 = key3 ; value1 = value3 ;
throw new IllegalStateException ( lr_1 + size ) ; } return total ; MST[rv.UOI1Mutator]MSP[S] } @Override public String toString () { if ( delegateMap != null ) { return delegateMap . toString () ; } if ( size == 0 ) { return lr_8 ; }
final V old = value3 ; hash3 = 0 ; MST[rv.CRCR6Mutator]MSP[S] key3 = null ; value3 = null ; size = 2 ; return old ; } if ( key2 == null ) { final V old = value2 ; hash2 = hash3 ; key2 = key3 ;
value2 = value3 ; hash3 = 0 ; MST[rv.CRCR6Mutator]MSP[S] key3 = null ; value3 = null ; size = 2 ; return old ; } if ( hash1 == hashCode && key . equals ( key1 ) ) { final V old = value1 ; hash1 = hash3 ;
final StringBuilder buf = new StringBuilder ( 128 ) ; buf . append ( '{' ) ; switch ( size ) { case 3 : buf . append ( key3 == this ? lr_9 : key3 ) ; MST[experimental.NakedReceiverMutator]MSP[S] buf . append ( '=' ) ;
if ( size > 0 ) { MST[rv.UOI3Mutator]MSP[N] final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { final V old = value3 ; value3 = value ;
delegateMap . put ( key2 , value2 ) ; case 1 : delegateMap . put ( key1 , value1 ) ; case 0 : break; default: throw new IllegalStateException ( lr_1 + size ) ; } size = 0 ; MST[InlineConstantMutator]MSP[S] hash1 = hash2 = hash3 = 0 ;
} if ( value == null ) { switch ( size ) { MST[rv.UOI3Mutator]MSP[N] case 3 : if ( value3 == null ) { return true ; } case 2 : if ( value2 == null ) { return true ; } case 1 :
value2 = null ; size = 1 ; return old ; MST[ReturnValsMutator]MSP[S] } if ( key1 == null ) { final V old = value1 ; hash1 = hash2 ; key1 = key2 ; value1 = value2 ; hash2 = 0 ; key2 = null ; value2 = null ;
final V old = value2 ; hash2 = 0 ; MST[InlineConstantMutator]MSP[S] key2 = null ; value2 = null ; size = 1 ; return old ; } if ( hash1 == hashCode && key . equals ( key1 ) ) { final V old = value1 ; hash1 = hash2 ;
if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.ROR2Mutator]MSP[N] return true ; } } } } return false ; } @Override public boolean containsValue ( final Object value ) { if ( delegateMap != null ) { return delegateMap . containsValue ( value ) ;
@Override public V get ( final Object key ) { if ( delegateMap != null ) { MST[rv.ROR5Mutator]MSP[S] return delegateMap . get ( key ) ; } if ( key == null ) { switch ( size ) { case 3 : if ( key3 == null ) {
key1 = key2 ; value1 = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; return old ; } return null ; case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
value2 = value3 ; hash3 = 0 ; key3 = null ; MST[experimental.MemberVariableMutator]MSP[S] value3 = null ; size = 2 ; return old ; } if ( hash1 == hashCode && key . equals ( key1 ) ) { final V old = value1 ; hash1 = hash3 ;
if ( key2 == null ) { return true ; } case 1 : if ( key1 == null ) { return true ; } } } else { if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { MST[experimental.SwitchMutator]MSP[N]
if ( delegateMap != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return delegateMap . remove ( key ) ; } if ( size == 0 ) { return null ; } if ( key == null ) { switch ( size ) { case 3 : if ( key3 == null ) {
key1 = key3 ; value1 = value3 ; hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } return null ; case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S]
hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } return null ; case 2 : if ( key2 == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] final V old = value2 ; hash2 = 0 ; key2 = null ;
if ( key2 == null ) { MST[rv.ROR5Mutator]MSP[N] final V old = value2 ; value2 = value ; return old ; } case 1 : if ( key1 == null ) { final V old = value1 ; value1 = value ; return old ; } } } else {
if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[rv.ROR1Mutator]MSP[S] final V old = value3 ; value3 = value ;
final V old = value1 ; hash1 = 0 ; key1 = null ; value1 = null ; size = 0 ; return old ; MST[ReturnValsMutator]MSP[S] } } } } return null ; } @Override public void clear () { if ( delegateMap != null ) {
public Flat3Map < K , V > clone () { try { final Flat3Map < K , V > cloned = ( Flat3Map < K , V > ) super . clone () ; if ( cloned . delegateMap != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S]
if ( delegateMap != null ) { return delegateMap . hashCode () ; } int total = 0 ; switch ( size ) { case 3 : total += hash3 ^ ( value3 == null ? 0 : value3 . hashCode () ) ; MST[rv.UOI4Mutator]MSP[S] case 2 :
return old ; } case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.UOI1Mutator]MSP[N] final V old = value2 ; value2 = value ; return old ; } case 1 :
final V old = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; return old ; } if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.ROR2Mutator]MSP[N] final V old = value1 ; hash1 = hash2 ;
final V old = value3 ; hash3 = 0 ; key3 = null ; MST[experimental.MemberVariableMutator]MSP[S] value3 = null ; size = 2 ; return old ; } if ( key2 == null ) { final V old = value2 ; hash2 = hash3 ; key2 = key3 ;
buf . append ( value2 == this ? lr_9 : value2 ) ; buf . append ( ',' ) ; MST[rv.CRCR6Mutator]MSP[N] case 1 : buf . append ( key1 == this ? lr_9 : key1 ) ; buf . append ( '=' ) ;
buf . append ( value1 == this ? lr_9 : value1 ) ; break; default: throw new IllegalStateException ( lr_1 + size ) ; } buf . append ( '}' ) ; MST[NonVoidMethodCallMutator]MSP[N] return buf . toString () ; }
final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[rv.ROR5Mutator]MSP[N] return value3 ; } case 2 :
throw new IllegalStateException ( lr_1 + size ) ; } return total ; MST[rv.UOI4Mutator]MSP[S] } @Override public String toString () { if ( delegateMap != null ) { return delegateMap . toString () ; } if ( size == 0 ) { return lr_8 ; }
if ( hash1 == hashCode && key . equals ( key1 ) ) { final V old = value1 ; value1 = value ; return old ; } } } } switch ( size ) { default: convertToMap () ; delegateMap . put ( key , value ) ; MST[ArgumentPropagationMutator]MSP[N]
return false ; } otherValue = other . get ( key1 ) ; if ( value1 == null ? otherValue != null : ! value1 . equals ( otherValue ) ) { return false ; } } } return true ; MST[BooleanFalseReturnValsMutator]MSP[N] } @Override public int hashCode () {
buf . append ( value3 == this ? lr_9 : value3 ) ; buf . append ( ',' ) ; MST[rv.CRCR6Mutator]MSP[S] case 2 : buf . append ( key2 == this ? lr_9 : key2 ) ; buf . append ( '=' ) ;
hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; MST[rv.CRCR6Mutator]MSP[N] return old ; } return null ; case 2 : if ( key2 == null ) { final V old = value2 ; hash2 = 0 ; key2 = null ;
key1 = key3 ; value1 = value3 ; hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } return null ; case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.ROR4Mutator]MSP[N]
if ( size != other . size () ) { MST[rv.UOI4Mutator]MSP[N] return false ; } if ( size > 0 ) { Object otherValue = null ; switch ( size ) { case 3 : if ( other . containsKey ( key3 ) == false ) { return false ; }
hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.ROR3Mutator]MSP[N] final V old = value2 ; hash2 = hash3 ; key2 = key3 ;
return; } if ( size < 4 ) { MST[rv.UOI4Mutator]MSP[S] for ( final Map . Entry < ? extends K , ? extends V > entry : map . entrySet () ) { put ( entry . getKey () , entry . getValue () ) ; } } else {
final V old = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; return old ; } if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] final V old = value1 ; hash1 = hash2 ;
delegateMap . put ( key2 , value2 ) ; case 1 : delegateMap . put ( key1 , value1 ) ; case 0 : break; default: throw new IllegalStateException ( lr_1 + size ) ; } size = 0 ; hash1 = hash2 = hash3 = 0 ; MST[rv.CRCR3Mutator]MSP[S]
hash3 = 0 ; MST[experimental.MemberVariableMutator]MSP[S] key3 = null ; value3 = null ; size = 2 ; return old ; } if ( hash2 == hashCode && key . equals ( key2 ) ) { final V old = value2 ; hash2 = hash3 ; key2 = key3 ;
return true ; } case 1 : if ( value . equals ( value1 ) ) { MST[rv.ROR2Mutator]MSP[S] return true ; } } } return false ; } @Override public V put ( final K key , final V value ) { if ( delegateMap != null ) {
if ( hash2 == hashCode && key . equals ( key2 ) ) { return value2 ; } case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.ROR5Mutator]MSP[N] return value1 ; } } } } return null ; } @Override
public Collection < V > values () { if ( delegateMap != null ) { return delegateMap . values () ; } return new Values <> ( this ) ; MST[ReturnValsMutator]MSP[N] } @Override public int size () { return parent . size () ; } @Override public void clear () {
if ( value1 == null ) { return true ; MST[InlineConstantMutator]MSP[N] } } } else { switch ( size ) { case 3 : if ( value . equals ( value3 ) ) { return true ; } case 2 : if ( value . equals ( value2 ) ) {
if ( size > 0 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[S] final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { final V old = value3 ; value3 = value ;
buf . append ( value2 == this ? lr_9 : value2 ) ; buf . append ( ',' ) ; case 1 : buf . append ( key1 == this ? lr_9 : key1 ) ; buf . append ( '=' ) ; MST[rv.CRCR4Mutator]MSP[N]
return value3 ; } case 2 : if ( key2 == null ) { return value2 ; } case 1 : if ( key1 == null ) { return value1 ; } } } else { if ( size > 0 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[S]
if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.ROR5Mutator]MSP[N] return value2 ; } case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { return value1 ; } } } } return null ; } @Override
delegateMap . put ( key2 , value2 ) ; case 1 : delegateMap . put ( key1 , value1 ) ; case 0 : break; default: throw new IllegalStateException ( lr_1 + size ) ; } size = 0 ; MST[rv.CRCR5Mutator]MSP[S] hash1 = hash2 = hash3 = 0 ;
final StringBuilder buf = new StringBuilder ( 128 ) ; buf . append ( '{' ) ; switch ( size ) { MST[experimental.SwitchMutator]MSP[S] case 3 : buf . append ( key3 == this ? lr_9 : key3 ) ; buf . append ( '=' ) ;
public int size () { if ( delegateMap != null ) { return delegateMap . size () ; } return size ; } @Override public boolean isEmpty () { return size () == 0 ; MST[InlineConstantMutator]MSP[N] } @Override public boolean containsKey ( final Object key ) {
if ( key2 == null ) { MST[NegateConditionalsMutator]MSP[N] final V old = value2 ; value2 = value ; return old ; } case 1 : if ( key1 == null ) { final V old = value1 ; value1 = value ; return old ; } } } else {
if ( delegateMap != null ) { return delegateMap . containsKey ( key ) ; MST[ReturnValsMutator]MSP[N] } if ( key == null ) { switch ( size ) { case 3 : if ( key3 == null ) { return true ; } case 2 :
} else { if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[rv.ABSMutator]MSP[N] final V old = value3 ;
public int size () { if ( delegateMap != null ) { return delegateMap . size () ; } return size ; } @Override public boolean isEmpty () { return size () == 0 ; MST[BooleanTrueReturnValsMutator]MSP[N] } @Override public boolean containsKey ( final Object key ) {
} else { if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[NegateConditionalsMutator]MSP[N] final V old = value3 ;
return delegateMap . put ( key , value ) ; } if ( key == null ) { switch ( size ) { MST[rv.UOI1Mutator]MSP[N] case 3 : if ( key3 == null ) { final V old = value3 ; value3 = value ; return old ; } case 2 :
throw new IllegalStateException ( lr_1 + size ) ; } return total ; } @Override public String toString () { if ( delegateMap != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] return delegateMap . toString () ; } if ( size == 0 ) { return lr_8 ; }
if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.UOI3Mutator]MSP[S] final V old = value1 ; value1 = value ; return old ; } } } } switch ( size ) { default: convertToMap () ; delegateMap . put ( key , value ) ;
return old ; } case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.ROR4Mutator]MSP[S] final V old = value2 ; value2 = value ; return old ; } case 1 :
key1 = key2 = key3 = null ; MST[experimental.MemberVariableMutator]MSP[S] value1 = value2 = value3 = null ; } protected AbstractHashedMap < K , V > createDelegateMap () { return new HashedMap <> () ; } @Override public V remove ( final Object key ) {
hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] final V old = value2 ; hash2 = hash3 ; key2 = key3 ;
public void putAll ( final Map < ? extends K , ? extends V > map ) { final int size = map . size () ; if ( size == 0 ) { MST[rv.UOI2Mutator]MSP[S] return; } if ( delegateMap != null ) { delegateMap . putAll ( map ) ;
public MapIterator < K , V > mapIterator () { if ( delegateMap != null ) { MST[NegateConditionalsMutator]MSP[S] return delegateMap . mapIterator () ; } if ( size == 0 ) { return EmptyMapIterator . <K , V > emptyMapIterator () ; } return new FlatMapIterator <> ( this ) ;
delegateMap . clear () ; delegateMap = null ; } else { size = 0 ; MST[rv.CRCR6Mutator]MSP[N] hash1 = hash2 = hash3 = 0 ; key1 = key2 = key3 = null ; value1 = value2 = value3 = null ; } } @Override
if ( hash2 == hashCode && key . equals ( key2 ) ) { return value2 ; } case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[NegateConditionalsMutator]MSP[N] return value1 ; } } } } return null ; } @Override
return value3 ; } case 2 : if ( key2 == null ) { MST[rv.ROR5Mutator]MSP[N] return value2 ; } case 1 : if ( key1 == null ) { return value1 ; } } } else { if ( size > 0 ) {
} else { if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[rv.ROR5Mutator]MSP[N] final V old = value3 ;
case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { return true ; } case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.UOI1Mutator]MSP[S] return true ; } case 1 :
public int size () { if ( delegateMap != null ) { return delegateMap . size () ; } return size ; MST[rv.ABSMutator]MSP[N] } @Override public boolean isEmpty () { return size () == 0 ; } @Override public boolean containsKey ( final Object key ) {
if ( key2 == null ) { MST[NegateConditionalsMutator]MSP[N] return true ; } case 1 : if ( key1 == null ) { return true ; } } } else { if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) {
if ( hash1 == hashCode && key . equals ( key1 ) ) { return true ; } } } } return false ; MST[rv.CRCR1Mutator]MSP[N] } @Override public boolean containsValue ( final Object value ) { if ( delegateMap != null ) { return delegateMap . containsValue ( value ) ;
return; } if ( size < 4 ) { MST[rv.CRCR1Mutator]MSP[N] for ( final Map . Entry < ? extends K , ? extends V > entry : map . entrySet () ) { put ( entry . getKey () , entry . getValue () ) ; } } else {
key1 = key2 ; value1 = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; return old ; } return null ; case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.UOI4Mutator]MSP[N]
if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[NegateConditionalsMutator]MSP[N] return value2 ; } case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { return value1 ; } } } } return null ; } @Override
if ( delegateMap != null ) { return delegateMap . hashCode () ; } int total = 0 ; switch ( size ) { MST[rv.UOI3Mutator]MSP[N] case 3 : total += hash3 ^ ( value3 == null ? 0 : value3 . hashCode () ) ; case 2 :
size = 1 ; return old ; } return null ; case 1 : if ( key1 == null ) { final V old = value1 ; hash1 = 0 ; key1 = null ; value1 = null ; size = 0 ; MST[InlineConstantMutator]MSP[S] return old ; } }
public Set < K > keySet () { if ( delegateMap != null ) { return delegateMap . keySet () ; } return new KeySet <> ( this ) ; MST[ReturnValsMutator]MSP[S] } @Override public int size () { return parent . size () ; } @Override public void clear () {
total += hash2 ^ ( value2 == null ? 0 : value2 . hashCode () ) ; MST[rv.UOI1Mutator]MSP[S] case 1 : total += hash1 ^ ( value1 == null ? 0 : value1 . hashCode () ) ; case 0 : break; default:
@Override public V get ( final Object key ) { if ( delegateMap != null ) { return delegateMap . get ( key ) ; MST[ArgumentPropagationMutator]MSP[S] } if ( key == null ) { switch ( size ) { case 3 : if ( key3 == null ) {
final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[rv.UOI3Mutator]MSP[N] return value3 ; } case 2 :
} if ( value == null ) { switch ( size ) { case 3 : if ( value3 == null ) { return true ; } case 2 : if ( value2 == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return true ; } case 1 :
hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.UOI1Mutator]MSP[S] final V old = value2 ; hash2 = hash3 ; key2 = key3 ;
@Override public V get ( final Object key ) { if ( delegateMap != null ) { MST[NegateConditionalsMutator]MSP[S] return delegateMap . get ( key ) ; } if ( key == null ) { switch ( size ) { case 3 : if ( key3 == null ) {
if ( delegateMap != null ) { return delegateMap . containsKey ( key ) ; } if ( key == null ) { switch ( size ) { case 3 : if ( key3 == null ) { return true ; MST[rv.CRCR6Mutator]MSP[N] } case 2 :
if ( hash1 == hashCode && key . equals ( key1 ) ) { final V old = value1 ; value1 = value ; return old ; } } } } switch ( size ) { default: convertToMap () ; MST[VoidMethodCallMutator]MSP[S] delegateMap . put ( key , value ) ;
return false ; } otherValue = other . get ( key1 ) ; if ( value1 == null ? otherValue != null : ! value1 . equals ( otherValue ) ) { return false ; } } } return true ; MST[rv.CRCR4Mutator]MSP[S] } @Override public int hashCode () {
if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.UOI3Mutator]MSP[N] return value2 ; } case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { return value1 ; } } } } return null ; } @Override
return true ; } case 1 : if ( value . equals ( value1 ) ) { MST[rv.ROR5Mutator]MSP[N] return true ; } } } return false ; } @Override public V put ( final K key , final V value ) { if ( delegateMap != null ) {
if ( key2 == null ) { return true ; } case 1 : if ( key1 == null ) { return true ; } } } else { if ( size > 0 ) { final int hashCode = key . hashCode () ; MST[NonVoidMethodCallMutator]MSP[N] switch ( size ) {
if ( delegateMap != null ) { return delegateMap . hashCode () ; } int total = 0 ; switch ( size ) { case 3 : total += hash3 ^ ( value3 == null ? 0 : value3 . hashCode () ) ; MST[rv.CRCR5Mutator]MSP[S] case 2 :
delegateMap . clear () ; delegateMap = null ; } else { size = 0 ; hash1 = hash2 = hash3 = 0 ; MST[rv.CRCR1Mutator]MSP[S] key1 = key2 = key3 = null ; value1 = value2 = value3 = null ; } } @Override
total += hash2 ^ ( value2 == null ? 0 : value2 . hashCode () ) ; case 1 : total += hash1 ^ ( value1 == null ? 0 : value1 . hashCode () ) ; MST[rv.AOD1Mutator]MSP[S] case 0 : break; default:
if ( hash2 == hashCode && key . equals ( key2 ) ) { return value2 ; } case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.UOI3Mutator]MSP[N] return value1 ; } } } } return null ; } @Override
buf . append ( value3 == this ? lr_9 : value3 ) ; buf . append ( ',' ) ; case 2 : buf . append ( key2 == this ? lr_9 : key2 ) ; buf . append ( '=' ) ; MST[rv.CRCR4Mutator]MSP[N]
final V old = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; return old ; } if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.UOI4Mutator]MSP[N] final V old = value1 ; hash1 = hash2 ;
if ( delegateMap != null ) { return delegateMap . remove ( key ) ; } if ( size == 0 ) { return null ; } if ( key == null ) { switch ( size ) { MST[rv.UOI1Mutator]MSP[N] case 3 : if ( key3 == null ) {
if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.UOI1Mutator]MSP[S] return true ; } } } } return false ; } @Override public boolean containsValue ( final Object value ) { if ( delegateMap != null ) { return delegateMap . containsValue ( value ) ;
hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[NonVoidMethodCallMutator]MSP[N] final V old = value2 ; hash2 = hash3 ; key2 = key3 ;
final StringBuilder buf = new StringBuilder ( 128 ) ; buf . append ( '{' ) ; MST[NonVoidMethodCallMutator]MSP[N] switch ( size ) { case 3 : buf . append ( key3 == this ? lr_9 : key3 ) ; buf . append ( '=' ) ;
if ( delegateMap != null ) { return delegateMap . hashCode () ; } int total = 0 ; switch ( size ) { case 3 : total += hash3 ^ ( value3 == null ? 0 : value3 . hashCode () ) ; MST[rv.AOR1Mutator]MSP[S] case 2 :
return null ; case 2 : hash3 = key == null ? 0 : key . hashCode () ; key3 = key ; value3 = value ; break; case 1 : hash2 = key == null ? 0 : key . hashCode () ; MST[rv.CRCR3Mutator]MSP[S] key2 = key ;
final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[NegateConditionalsMutator]MSP[N] return value3 ; } case 2 :
if ( key2 == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] final V old = value2 ; value2 = value ; return old ; } case 1 : if ( key1 == null ) { final V old = value1 ; value1 = value ; return old ; } } } else {
if ( size > 0 ) { MST[NegateConditionalsMutator]MSP[S] final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { final V old = value3 ; value3 = value ;
value2 = value ; break; case 0 : hash1 = key == null ? 0 : key . hashCode () ; key1 = key ; MST[experimental.MemberVariableMutator]MSP[N] value1 = value ; break; } size ++ ; return null ; } @Override
hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.UOI3Mutator]MSP[N] final V old = value2 ; hash2 = hash3 ; key2 = key3 ;
if ( hash2 == hashCode && key . equals ( key2 ) ) { return value2 ; } case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.ROR1Mutator]MSP[S] return value1 ; } } } } return null ; } @Override
public MapIterator < K , V > mapIterator () { if ( delegateMap != null ) { return delegateMap . mapIterator () ; } if ( size == 0 ) { MST[rv.ROR2Mutator]MSP[S] return EmptyMapIterator . <K , V > emptyMapIterator () ; } return new FlatMapIterator <> ( this ) ;
case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { return true ; } case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.ROR1Mutator]MSP[S] return true ; } case 1 :
final StringBuilder buf = new StringBuilder ( 128 ) ; MST[rv.CRCR5Mutator]MSP[S] buf . append ( '{' ) ; switch ( size ) { case 3 : buf . append ( key3 == this ? lr_9 : key3 ) ; buf . append ( '=' ) ;
if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] return true ; } } } } return false ; } @Override public boolean containsValue ( final Object value ) { if ( delegateMap != null ) { return delegateMap . containsValue ( value ) ;
buf . append ( value3 == this ? lr_9 : value3 ) ; MST[NegateConditionalsMutator]MSP[S] buf . append ( ',' ) ; case 2 : buf . append ( key2 == this ? lr_9 : key2 ) ; buf . append ( '=' ) ;
if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.ROR1Mutator]MSP[S] return value2 ; } case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { return value1 ; } } } } return null ; } @Override
buf . append ( value3 == this ? lr_9 : value3 ) ; buf . append ( ',' ) ; case 2 : buf . append ( key2 == this ? lr_9 : key2 ) ; buf . append ( '=' ) ; MST[rv.CRCR1Mutator]MSP[N]
cloned . delegateMap = cloned . delegateMap . clone () ; } return cloned ; } catch ( final CloneNotSupportedException ex ) { throw new InternalError () ; } } @Override public boolean equals ( final Object obj ) { if ( obj == this ) { MST[NegateConditionalsMutator]MSP[N] return true ;
final V old = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; return old ; } if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[NegateConditionalsMutator]MSP[N] final V old = value1 ; hash1 = hash2 ;
if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[NegateConditionalsMutator]MSP[S] final V old = value3 ; value3 = value ;
@Override public V get ( final Object key ) { if ( delegateMap != null ) { return delegateMap . get ( key ) ; MST[NonVoidMethodCallMutator]MSP[S] } if ( key == null ) { switch ( size ) { case 3 : if ( key3 == null ) {
final int hashCode = key . hashCode () ; switch ( size ) { MST[rv.UOI2Mutator]MSP[N] case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { return value3 ; } case 2 :
if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] final V old = value3 ; value3 = value ;
total += hash2 ^ ( value2 == null ? 0 : value2 . hashCode () ) ; case 1 : total += hash1 ^ ( value1 == null ? 0 : value1 . hashCode () ) ; MST[InlineConstantMutator]MSP[S] case 0 : break; default:
if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.UOI4Mutator]MSP[N] return true ; } } } } return false ; } @Override public boolean containsValue ( final Object value ) { if ( delegateMap != null ) { return delegateMap . containsValue ( value ) ;
if ( delegateMap != null ) { return delegateMap . remove ( key ) ; } if ( size == 0 ) { MST[rv.ROR1Mutator]MSP[N] return null ; } if ( key == null ) { switch ( size ) { case 3 : if ( key3 == null ) {
size = 1 ; return old ; } return null ; case 1 : if ( key1 == null ) { MST[NegateConditionalsMutator]MSP[N] final V old = value1 ; hash1 = 0 ; key1 = null ; value1 = null ; size = 0 ; return old ; } }
hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } if ( hash2 == hashCode && key . equals ( key2 ) ) { final V old = value2 ; hash2 = hash3 ; MST[rv.UOI3Mutator]MSP[S] key2 = key3 ;
if ( delegateMap != null ) { return delegateMap . remove ( key ) ; } if ( size == 0 ) { MST[rv.UOI2Mutator]MSP[N] return null ; } if ( key == null ) { switch ( size ) { case 3 : if ( key3 == null ) {
return null ; case 2 : hash3 = key == null ? 0 : key . hashCode () ; key3 = key ; value3 = value ; break; case 1 : hash2 = key == null ? 0 : key . hashCode () ; MST[rv.CRCR6Mutator]MSP[S] key2 = key ;
hash3 = 0 ; key3 = null ; value3 = null ; MST[experimental.MemberVariableMutator]MSP[S] size = 2 ; return old ; } return null ; case 2 : if ( key2 == null ) { final V old = value2 ; hash2 = 0 ; key2 = null ;
if ( delegateMap != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] return delegateMap . hashCode () ; } int total = 0 ; switch ( size ) { case 3 : total += hash3 ^ ( value3 == null ? 0 : value3 . hashCode () ) ; case 2 :
buf . append ( value2 == this ? lr_9 : value2 ) ; buf . append ( ',' ) ; MST[rv.CRCR3Mutator]MSP[N] case 1 : buf . append ( key1 == this ? lr_9 : key1 ) ; buf . append ( '=' ) ;
if ( key2 == null ) { return true ; } case 1 : if ( key1 == null ) { return true ; MST[BooleanFalseReturnValsMutator]MSP[N] } } } else { if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) {
} else { if ( size > 0 ) { MST[rv.ROR2Mutator]MSP[N] final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { final V old = value3 ;
if ( key2 == null ) { return true ; } case 1 : if ( key1 == null ) { return true ; MST[rv.CRCR4Mutator]MSP[S] } } } else { if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) {
value2 = value ; break; case 0 : hash1 = key == null ? 0 : key . hashCode () ; MST[rv.CRCR1Mutator]MSP[S] key1 = key ; value1 = value ; break; } size ++ ; return null ; } @Override
if ( hash2 == hashCode && key . equals ( key2 ) ) { return value2 ; } case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.ABSMutator]MSP[N] return value1 ; } } } } return null ; } @Override
key1 = key2 ; value1 = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; MST[rv.CRCR4Mutator]MSP[N] return old ; } return null ; case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) {
return; } if ( size < 4 ) { MST[rv.CRCR4Mutator]MSP[N] for ( final Map . Entry < ? extends K , ? extends V > entry : map . entrySet () ) { put ( entry . getKey () , entry . getValue () ) ; } } else {
delegateMap . put ( key2 , value2 ) ; MST[ArgumentPropagationMutator]MSP[N] case 1 : delegateMap . put ( key1 , value1 ) ; case 0 : break; default: throw new IllegalStateException ( lr_1 + size ) ; } size = 0 ; hash1 = hash2 = hash3 = 0 ;
if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[rv.ROR4Mutator]MSP[S] final V old = value3 ; value3 = value ;
return delegateMap . put ( key , value ) ; } if ( key == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] switch ( size ) { case 3 : if ( key3 == null ) { final V old = value3 ; value3 = value ; return old ; } case 2 :
buf . append ( value3 == this ? lr_9 : value3 ) ; MST[rv.ROR5Mutator]MSP[S] buf . append ( ',' ) ; case 2 : buf . append ( key2 == this ? lr_9 : key2 ) ; buf . append ( '=' ) ;
case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { return true ; } case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.UOI4Mutator]MSP[S] return true ; } case 1 :
key1 = key2 ; value1 = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; return old ; } return null ; case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[NegateConditionalsMutator]MSP[N]
return old ; } case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.UOI4Mutator]MSP[N] final V old = value2 ; value2 = value ; return old ; } case 1 :
return value3 ; } case 2 : if ( key2 == null ) { return value2 ; } case 1 : if ( key1 == null ) { return value1 ; } } } else { if ( size > 0 ) { MST[rv.UOI3Mutator]MSP[N]
} if ( value == null ) { switch ( size ) { case 3 : if ( value3 == null ) { return true ; } case 2 : if ( value2 == null ) { MST[rv.ROR5Mutator]MSP[N] return true ; } case 1 :
return value3 ; } case 2 : if ( key2 == null ) { MST[NegateConditionalsMutator]MSP[N] return value2 ; } case 1 : if ( key1 == null ) { return value1 ; } } } else { if ( size > 0 ) {
if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[rv.UOI1Mutator]MSP[S] final V old = value3 ; value3 = value ;
public void putAll ( final Map < ? extends K , ? extends V > map ) { final int size = map . size () ; if ( size == 0 ) { return; } if ( delegateMap != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] delegateMap . putAll ( map ) ;
return; } if ( size < 4 ) { MST[rv.ROR1Mutator]MSP[N] for ( final Map . Entry < ? extends K , ? extends V > entry : map . entrySet () ) { put ( entry . getKey () , entry . getValue () ) ; } } else {
throw new IllegalStateException ( lr_1 + size ) ; } return total ; MST[ReturnValsMutator]MSP[S] } @Override public String toString () { if ( delegateMap != null ) { return delegateMap . toString () ; } if ( size == 0 ) { return lr_8 ; }
} else { if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { MST[rv.UOI3Mutator]MSP[N] case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { final V old = value3 ;
hash3 = 0 ; MST[rv.CRCR1Mutator]MSP[S] key3 = null ; value3 = null ; size = 2 ; return old ; } return null ; case 2 : if ( key2 == null ) { final V old = value2 ; hash2 = 0 ; key2 = null ;
cloned . delegateMap = cloned . delegateMap . clone () ; } return cloned ; } catch ( final CloneNotSupportedException ex ) { throw new InternalError () ; } } @Override public boolean equals ( final Object obj ) { if ( obj == this ) { return true ; MST[ReturnValsMutator]MSP[N]
final V old = value1 ; hash1 = 0 ; MST[experimental.MemberVariableMutator]MSP[S] key1 = null ; value1 = null ; size = 0 ; return old ; } } } } return null ; } @Override public void clear () { if ( delegateMap != null ) {
final V old = value1 ; hash1 = 0 ; key1 = null ; value1 = null ; size = 0 ; return old ; } } } } return null ; } @Override public void clear () { if ( delegateMap != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S]
if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.UOI4Mutator]MSP[N] return value2 ; } case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { return value1 ; } } } } return null ; } @Override
return value3 ; } case 2 : if ( key2 == null ) { return value2 ; } case 1 : if ( key1 == null ) { return value1 ; } } } else { if ( size > 0 ) { MST[rv.ROR1Mutator]MSP[S]
public int size () { if ( delegateMap != null ) { return delegateMap . size () ; } return size ; } @Override public boolean isEmpty () { return size () == 0 ; MST[rv.CRCR5Mutator]MSP[N] } @Override public boolean containsKey ( final Object key ) {
buf . append ( value2 == this ? lr_9 : value2 ) ; MST[NegateConditionalsMutator]MSP[N] buf . append ( ',' ) ; case 1 : buf . append ( key1 == this ? lr_9 : key1 ) ; buf . append ( '=' ) ;
} if ( value == null ) { switch ( size ) { case 3 : if ( value3 == null ) { return true ; } case 2 : if ( value2 == null ) { MST[NegateConditionalsMutator]MSP[N] return true ; } case 1 :
if ( delegateMap != null ) { return delegateMap . containsKey ( key ) ; } if ( key == null ) { MST[NegateConditionalsMutator]MSP[N] switch ( size ) { case 3 : if ( key3 == null ) { return true ; } case 2 :
return true ; } case 1 : if ( value . equals ( value1 ) ) { return true ; } } } return false ; } @Override public V put ( final K key , final V value ) { if ( delegateMap != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S]
return null ; case 2 : hash3 = key == null ? 0 : key . hashCode () ; key3 = key ; value3 = value ; MST[experimental.MemberVariableMutator]MSP[N] break; case 1 : hash2 = key == null ? 0 : key . hashCode () ; key2 = key ;
cloned . delegateMap = cloned . delegateMap . clone () ; } return cloned ; } catch ( final CloneNotSupportedException ex ) { throw new InternalError () ; } } @Override public boolean equals ( final Object obj ) { if ( obj == this ) { return true ; MST[rv.CRCR5Mutator]MSP[N]
value2 = value ; break; case 0 : hash1 = key == null ? 0 : key . hashCode () ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] key1 = key ; value1 = value ; break; } size ++ ; return null ; } @Override
total += hash2 ^ ( value2 == null ? 0 : value2 . hashCode () ) ; case 1 : total += hash1 ^ ( value1 == null ? 0 : value1 . hashCode () ) ; MST[rv.UOI1Mutator]MSP[S] case 0 : break; default:
key1 = key2 ; value1 = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; return old ; } return null ; case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.ROR5Mutator]MSP[N]
hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } return null ; case 2 : if ( key2 == null ) { final V old = value2 ; hash2 = 0 ; MST[rv.CRCR3Mutator]MSP[S] key2 = null ;
} else { if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[rv.ROR2Mutator]MSP[N] final V old = value3 ;
if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.ABSMutator]MSP[N] return value2 ; } case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { return value1 ; } } } } return null ; } @Override
buf . append ( value3 == this ? lr_9 : value3 ) ; MST[experimental.NakedReceiverMutator]MSP[S] buf . append ( ',' ) ; case 2 : buf . append ( key2 == this ? lr_9 : key2 ) ; buf . append ( '=' ) ;
final StringBuilder buf = new StringBuilder ( 128 ) ; buf . append ( '{' ) ; switch ( size ) { case 3 : buf . append ( key3 == this ? lr_9 : key3 ) ; buf . append ( '=' ) ; MST[rv.CRCR1Mutator]MSP[S]
if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[NegateConditionalsMutator]MSP[N] return true ; } } } } return false ; } @Override public boolean containsValue ( final Object value ) { if ( delegateMap != null ) { return delegateMap . containsValue ( value ) ;
final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[rv.UOI4Mutator]MSP[S] return value3 ; } case 2 :
delegateMap . put ( key2 , value2 ) ; case 1 : delegateMap . put ( key1 , value1 ) ; case 0 : break; default: throw new IllegalStateException ( lr_1 + size ) ; } size = 0 ; hash1 = hash2 = hash3 = 0 ; MST[experimental.MemberVariableMutator]MSP[S]
return delegateMap . put ( key , value ) ; } if ( key == null ) { switch ( size ) { MST[rv.UOI4Mutator]MSP[N] case 3 : if ( key3 == null ) { final V old = value3 ; value3 = value ; return old ; } case 2 :
} else { if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { MST[rv.UOI2Mutator]MSP[N] case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { final V old = value3 ;
if ( key2 == null ) { return true ; MST[rv.CRCR5Mutator]MSP[N] } case 1 : if ( key1 == null ) { return true ; } } } else { if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) {
value2 = value3 ; hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } if ( key1 == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] final V old = value1 ; hash1 = hash3 ; key1 = key3 ; value1 = value3 ;
if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.UOI1Mutator]MSP[N] final V old = value1 ; value1 = value ; return old ; } } } } switch ( size ) { default: convertToMap () ; delegateMap . put ( key , value ) ;
if ( delegateMap != null ) { return delegateMap . remove ( key ) ; } if ( size == 0 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] return null ; } if ( key == null ) { switch ( size ) { case 3 : if ( key3 == null ) {
final V old = value1 ; hash1 = 0 ; MST[rv.CRCR3Mutator]MSP[S] key1 = null ; value1 = null ; size = 0 ; return old ; } } } } return null ; } @Override public void clear () { if ( delegateMap != null ) {
public void putAll ( final Map < ? extends K , ? extends V > map ) { final int size = map . size () ; if ( size == 0 ) { MST[rv.ROR3Mutator]MSP[S] return; } if ( delegateMap != null ) { delegateMap . putAll ( map ) ;
hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; MST[rv.CRCR5Mutator]MSP[N] return old ; } if ( hash2 == hashCode && key . equals ( key2 ) ) { final V old = value2 ; hash2 = hash3 ; key2 = key3 ;
return old ; } case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.ROR1Mutator]MSP[S] final V old = value2 ; value2 = value ; return old ; } case 1 :
if ( value1 == null ) { return true ; } } } else { switch ( size ) { case 3 : if ( value . equals ( value3 ) ) { MST[rv.ROR4Mutator]MSP[S] return true ; } case 2 : if ( value . equals ( value2 ) ) {
size = 1 ; return old ; } return null ; case 1 : if ( key1 == null ) { final V old = value1 ; hash1 = 0 ; key1 = null ; MST[experimental.MemberVariableMutator]MSP[S] value1 = null ; size = 0 ; return old ; } }
final V old = value3 ; hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; MST[InlineConstantMutator]MSP[N] return old ; } if ( key2 == null ) { final V old = value2 ; hash2 = hash3 ; key2 = key3 ;
delegateMap . clear () ; delegateMap = null ; } else { size = 0 ; hash1 = hash2 = hash3 = 0 ; MST[experimental.MemberVariableMutator]MSP[S] key1 = key2 = key3 = null ; value1 = value2 = value3 = null ; } } @Override
if ( key2 == null ) { final V old = value2 ; value2 = value ; return old ; } case 1 : if ( key1 == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] final V old = value1 ; value1 = value ; return old ; } } } else {
if ( key2 == null ) { return true ; MST[ReturnValsMutator]MSP[N] } case 1 : if ( key1 == null ) { return true ; } } } else { if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) {
key1 = key2 ; value1 = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; return old ; } return null ; case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.ROR1Mutator]MSP[S]
if ( hash2 == hashCode && key . equals ( key2 ) ) { return value2 ; } case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.UOI4Mutator]MSP[N] return value1 ; } } } } return null ; } @Override
buf . append ( value3 == this ? lr_9 : value3 ) ; buf . append ( ',' ) ; MST[rv.CRCR3Mutator]MSP[S] case 2 : buf . append ( key2 == this ? lr_9 : key2 ) ; buf . append ( '=' ) ;
if ( delegateMap != null ) { return delegateMap . containsKey ( key ) ; } if ( key == null ) { switch ( size ) { MST[rv.UOI3Mutator]MSP[N] case 3 : if ( key3 == null ) { return true ; } case 2 :
total += hash2 ^ ( value2 == null ? 0 : value2 . hashCode () ) ; MST[rv.AOD1Mutator]MSP[S] case 1 : total += hash1 ^ ( value1 == null ? 0 : value1 . hashCode () ) ; case 0 : break; default:
size = 1 ; return old ; } return null ; case 1 : if ( key1 == null ) { MST[rv.ROR5Mutator]MSP[N] final V old = value1 ; hash1 = 0 ; key1 = null ; value1 = null ; size = 0 ; return old ; } }
final V old = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; return old ; } if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.ROR5Mutator]MSP[N] final V old = value1 ; hash1 = hash2 ;
hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } return null ; case 2 : if ( key2 == null ) { final V old = value2 ; hash2 = 0 ; MST[experimental.MemberVariableMutator]MSP[S] key2 = null ;
cloned . delegateMap = cloned . delegateMap . clone () ; } return cloned ; } catch ( final CloneNotSupportedException ex ) { throw new InternalError () ; } } @Override public boolean equals ( final Object obj ) { if ( obj == this ) { MST[rv.ROR5Mutator]MSP[N] return true ;
if ( key2 == null ) { MST[rv.ROR5Mutator]MSP[N] return true ; } case 1 : if ( key1 == null ) { return true ; } } } else { if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) {
if ( delegateMap != null ) { return delegateMap . hashCode () ; } int total = 0 ; MST[rv.CRCR1Mutator]MSP[S] switch ( size ) { case 3 : total += hash3 ^ ( value3 == null ? 0 : value3 . hashCode () ) ; case 2 :
final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[rv.ROR1Mutator]MSP[S] return value3 ; } case 2 :
if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.ROR4Mutator]MSP[S] final V old = value1 ; value1 = value ; return old ; } } } } switch ( size ) { default: convertToMap () ; delegateMap . put ( key , value ) ;
public MapIterator < K , V > mapIterator () { if ( delegateMap != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] return delegateMap . mapIterator () ; } if ( size == 0 ) { return EmptyMapIterator . <K , V > emptyMapIterator () ; } return new FlatMapIterator <> ( this ) ;
hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } if ( hash2 == hashCode && key . equals ( key2 ) ) { final V old = value2 ; hash2 = hash3 ; MST[rv.UOI2Mutator]MSP[S] key2 = key3 ;
final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[rv.ABSMutator]MSP[N] return value3 ; } case 2 :
if ( delegateMap != null ) { return delegateMap . remove ( key ) ; } if ( size == 0 ) { MST[rv.UOI3Mutator]MSP[N] return null ; } if ( key == null ) { switch ( size ) { case 3 : if ( key3 == null ) {
value2 = value3 ; hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; MST[InlineConstantMutator]MSP[N] return old ; } if ( hash1 == hashCode && key . equals ( key1 ) ) { final V old = value1 ; hash1 = hash3 ;
} if ( value == null ) { MST[rv.ROR5Mutator]MSP[N] switch ( size ) { case 3 : if ( value3 == null ) { return true ; } case 2 : if ( value2 == null ) { return true ; } case 1 :
size = 1 ; return old ; } return null ; case 1 : if ( key1 == null ) { final V old = value1 ; hash1 = 0 ; key1 = null ; value1 = null ; size = 0 ; MST[rv.CRCR5Mutator]MSP[S] return old ; } }
hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.UOI2Mutator]MSP[S] final V old = value2 ; hash2 = hash3 ; key2 = key3 ;
if ( key2 == null ) { return true ; } case 1 : if ( key1 == null ) { return true ; } } } else { if ( size > 0 ) { MST[ConditionalsBoundaryMutator]MSP[S] final int hashCode = key . hashCode () ; switch ( size ) {
if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { MST[rv.UOI3Mutator]MSP[N] case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { final V old = value3 ; value3 = value ;
} else { if ( size > 0 ) { MST[rv.UOI4Mutator]MSP[N] final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { final V old = value3 ;
if ( value1 == null ) { return true ; } } } else { switch ( size ) { case 3 : if ( value . equals ( value3 ) ) { return true ; } case 2 : if ( value . equals ( value2 ) ) { MST[NegateConditionalsMutator]MSP[N]
key1 = key3 ; value1 = value3 ; hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } return null ; case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.ROR3Mutator]MSP[N]
if ( delegateMap != null ) { return delegateMap . remove ( key ) ; } if ( size == 0 ) { return null ; } if ( key == null ) { switch ( size ) { case 3 : if ( key3 == null ) { MST[rv.ROR5Mutator]MSP[N]
final V old = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; return old ; } if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.ROR1Mutator]MSP[S] final V old = value1 ; hash1 = hash2 ;
value2 = value ; break; case 0 : hash1 = key == null ? 0 : key . hashCode () ; key1 = key ; value1 = value ; break; } size ++ ; MST[rv.CRCR2Mutator]MSP[N] return null ; } @Override
if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[rv.ROR2Mutator]MSP[S] final V old = value3 ; value3 = value ;
final V old = value3 ; hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; MST[rv.CRCR2Mutator]MSP[N] return old ; } if ( key2 == null ) { final V old = value2 ; hash2 = hash3 ; key2 = key3 ;
if ( key2 == null ) { return true ; MST[InlineConstantMutator]MSP[N] } case 1 : if ( key1 == null ) { return true ; } } } else { if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) {
return true ; } case 1 : if ( value . equals ( value1 ) ) { MST[NonVoidMethodCallMutator]MSP[S] return true ; } } } return false ; } @Override public V put ( final K key , final V value ) { if ( delegateMap != null ) {
if ( hash1 == hashCode && key . equals ( key1 ) ) { return true ; MST[ReturnValsMutator]MSP[N] } } } } return false ; } @Override public boolean containsValue ( final Object value ) { if ( delegateMap != null ) { return delegateMap . containsValue ( value ) ;
} if ( delegateMap != null ) { return delegateMap . equals ( obj ) ; } if ( obj instanceof Map == false ) { return false ; MST[rv.CRCR3Mutator]MSP[N] } final Map < ? , ? > other = ( Map < ? , ? > ) obj ;
if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.ROR4Mutator]MSP[S] final V old = value1 ; value1 = value ; return old ; } } } } switch ( size ) { default: convertToMap () ; delegateMap . put ( key , value ) ;
key1 = key2 ; value1 = value2 ; MST[experimental.MemberVariableMutator]MSP[S] hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; return old ; } return null ; case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) {
if ( delegateMap != null ) { return delegateMap . hashCode () ; } int total = 0 ; switch ( size ) { case 3 : total += hash3 ^ ( value3 == null ? 0 : value3 . hashCode () ) ; MST[rv.AOR2Mutator]MSP[S] case 2 :
value2 = value3 ; hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; MST[rv.CRCR2Mutator]MSP[N] return old ; } if ( hash1 == hashCode && key . equals ( key1 ) ) { final V old = value1 ; hash1 = hash3 ;
final V old = value1 ; hash1 = 0 ; MST[rv.CRCR6Mutator]MSP[S] key1 = null ; value1 = null ; size = 0 ; return old ; } } } } return null ; } @Override public void clear () { if ( delegateMap != null ) {
if ( key2 == null ) { return true ; } case 1 : if ( key1 == null ) { return true ; } } } else { if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { MST[rv.UOI1Mutator]MSP[N]
} else { if ( size > 0 ) { MST[rv.ROR5Mutator]MSP[N] final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { final V old = value3 ;
value2 = value ; break; case 0 : hash1 = key == null ? 0 : key . hashCode () ; MST[experimental.MemberVariableMutator]MSP[N] key1 = key ; value1 = value ; break; } size ++ ; return null ; } @Override
public Set < K > keySet () { if ( delegateMap != null ) { MST[NegateConditionalsMutator]MSP[S] return delegateMap . keySet () ; } return new KeySet <> ( this ) ; } @Override public int size () { return parent . size () ; } @Override public void clear () {
if ( hash1 == hashCode && key . equals ( key1 ) ) { return true ; } } } } return false ; } @Override public boolean containsValue ( final Object value ) { if ( delegateMap != null ) { return delegateMap . containsValue ( value ) ; MST[BooleanTrueReturnValsMutator]MSP[S]
public Collection < V > values () { if ( delegateMap != null ) { return delegateMap . values () ; } return new Values <> ( this ) ; MST[EmptyObjectReturnValsMutator]MSP[S] } @Override public int size () { return parent . size () ; } @Override public void clear () {
if ( size != other . size () ) { return false ; } if ( size > 0 ) { MST[rv.UOI1Mutator]MSP[S] Object otherValue = null ; switch ( size ) { case 3 : if ( other . containsKey ( key3 ) == false ) { return false ; }
case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[rv.UOI3Mutator]MSP[S] return true ; } case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { return true ; } case 1 :
if ( hash1 == hashCode && key . equals ( key1 ) ) { final V old = value1 ; value1 = value ; return old ; } } } } switch ( size ) { MST[rv.UOI4Mutator]MSP[S] default: convertToMap () ; delegateMap . put ( key , value ) ;
if ( hash1 == hashCode && key . equals ( key1 ) ) { return true ; } } } } return false ; } @Override public boolean containsValue ( final Object value ) { if ( delegateMap != null ) { return delegateMap . containsValue ( value ) ; MST[NonVoidMethodCallMutator]MSP[S]
if ( size != other . size () ) { return false ; } if ( size > 0 ) { MST[rv.ROR2Mutator]MSP[S] Object otherValue = null ; switch ( size ) { case 3 : if ( other . containsKey ( key3 ) == false ) { return false ; }
return true ; } case 1 : if ( value . equals ( value1 ) ) { return true ; } } } return false ; MST[rv.CRCR5Mutator]MSP[N] } @Override public V put ( final K key , final V value ) { if ( delegateMap != null ) {
case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { return true ; } case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.UOI3Mutator]MSP[S] return true ; } case 1 :
return null ; case 2 : hash3 = key == null ? 0 : key . hashCode () ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] key3 = key ; value3 = value ; break; case 1 : hash2 = key == null ? 0 : key . hashCode () ; key2 = key ;
case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { return true ; } case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.ROR4Mutator]MSP[S] return true ; } case 1 :
value2 = value3 ; hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } if ( key1 == null ) { final V old = value1 ; hash1 = hash3 ; key1 = key3 ; MST[experimental.MemberVariableMutator]MSP[S] value1 = value3 ;
if ( delegateMap != null ) { return delegateMap . hashCode () ; } int total = 0 ; switch ( size ) { case 3 : total += hash3 ^ ( value3 == null ? 0 : value3 . hashCode () ) ; MST[rv.ABSMutator]MSP[S] case 2 :
value2 = value ; break; case 0 : hash1 = key == null ? 0 : key . hashCode () ; key1 = key ; value1 = value ; break; } size ++ ; MST[rv.ABSMutator]MSP[N] return null ; } @Override
public Set < K > keySet () { if ( delegateMap != null ) { MST[rv.ROR5Mutator]MSP[S] return delegateMap . keySet () ; } return new KeySet <> ( this ) ; } @Override public int size () { return parent . size () ; } @Override public void clear () {
if ( size != other . size () ) { return false ; MST[rv.CRCR3Mutator]MSP[N] } if ( size > 0 ) { Object otherValue = null ; switch ( size ) { case 3 : if ( other . containsKey ( key3 ) == false ) { return false ; }
} else { if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[rv.ROR5Mutator]MSP[N] final V old = value3 ;
} else { if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[rv.UOI4Mutator]MSP[N] final V old = value3 ;
if ( size > 0 ) { MST[rv.ROR2Mutator]MSP[S] final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { final V old = value3 ; value3 = value ;
throw new IllegalStateException ( lr_1 + size ) ; } return total ; MST[PrimitiveReturnsMutator]MSP[S] } @Override public String toString () { if ( delegateMap != null ) { return delegateMap . toString () ; } if ( size == 0 ) { return lr_8 ; }
return old ; } case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.ROR1Mutator]MSP[N] final V old = value2 ; value2 = value ; return old ; } case 1 :
hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.ABSMutator]MSP[N] final V old = value2 ; hash2 = hash3 ; key2 = key3 ;
key1 = key3 ; value1 = value3 ; hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } return null ; case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[NonVoidMethodCallMutator]MSP[N]
public int size () { if ( delegateMap != null ) { return delegateMap . size () ; } return size ; } @Override public boolean isEmpty () { return size () == 0 ; MST[rv.CRCR5Mutator]MSP[N] } @Override public boolean containsKey ( final Object key ) {
if ( delegateMap != null ) { return delegateMap . hashCode () ; } int total = 0 ; switch ( size ) { case 3 : total += hash3 ^ ( value3 == null ? 0 : value3 . hashCode () ) ; MST[rv.AOD1Mutator]MSP[S] case 2 :
hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.ROR3Mutator]MSP[S] final V old = value2 ; hash2 = hash3 ; key2 = key3 ;
return value3 ; } case 2 : if ( key2 == null ) { return value2 ; } case 1 : if ( key1 == null ) { return value1 ; } } } else { if ( size > 0 ) { MST[rv.ROR5Mutator]MSP[N]
if ( delegateMap != null ) { return delegateMap . remove ( key ) ; } if ( size == 0 ) { return null ; } if ( key == null ) { switch ( size ) { MST[rv.ABSMutator]MSP[N] case 3 : if ( key3 == null ) {
if ( size != other . size () ) { MST[rv.ROR3Mutator]MSP[N] return false ; } if ( size > 0 ) { Object otherValue = null ; switch ( size ) { case 3 : if ( other . containsKey ( key3 ) == false ) { return false ; }
public Collection < V > values () { if ( delegateMap != null ) { MST[rv.ROR5Mutator]MSP[S] return delegateMap . values () ; } return new Values <> ( this ) ; } @Override public int size () { return parent . size () ; } @Override public void clear () {
final StringBuilder buf = new StringBuilder ( 128 ) ; buf . append ( '{' ) ; MST[rv.CRCR3Mutator]MSP[N] switch ( size ) { case 3 : buf . append ( key3 == this ? lr_9 : key3 ) ; buf . append ( '=' ) ;
hash3 = 0 ; key3 = null ; MST[experimental.MemberVariableMutator]MSP[S] value3 = null ; size = 2 ; return old ; } if ( hash2 == hashCode && key . equals ( key2 ) ) { final V old = value2 ; hash2 = hash3 ; key2 = key3 ;
if ( value1 == null ) { return true ; MST[rv.CRCR4Mutator]MSP[S] } } } else { switch ( size ) { case 3 : if ( value . equals ( value3 ) ) { return true ; } case 2 : if ( value . equals ( value2 ) ) {
final V old = value2 ; hash2 = 0 ; MST[rv.CRCR5Mutator]MSP[S] key2 = null ; value2 = null ; size = 1 ; return old ; } if ( hash1 == hashCode && key . equals ( key1 ) ) { final V old = value1 ; hash1 = hash2 ;
} if ( delegateMap != null ) { return delegateMap . equals ( obj ) ; } if ( obj instanceof Map == false ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] return false ; } final Map < ? , ? > other = ( Map < ? , ? > ) obj ;
total += hash2 ^ ( value2 == null ? 0 : value2 . hashCode () ) ; case 1 : total += hash1 ^ ( value1 == null ? 0 : value1 . hashCode () ) ; MST[rv.CRCR5Mutator]MSP[S] case 0 : break; default:
return delegateMap . put ( key , value ) ; } if ( key == null ) { switch ( size ) { MST[experimental.SwitchMutator]MSP[N] case 3 : if ( key3 == null ) { final V old = value3 ; value3 = value ; return old ; } case 2 :
key1 = key2 ; value1 = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; return old ; MST[NullReturnValsMutator]MSP[S] } return null ; case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) {
if ( hash1 == hashCode && key . equals ( key1 ) ) { final V old = value1 ; value1 = value ; MST[experimental.MemberVariableMutator]MSP[S] return old ; } } } } switch ( size ) { default: convertToMap () ; delegateMap . put ( key , value ) ;
if ( delegateMap != null ) { return delegateMap . hashCode () ; } int total = 0 ; switch ( size ) { case 3 : total += hash3 ^ ( value3 == null ? 0 : value3 . hashCode () ) ; MST[rv.UOI2Mutator]MSP[S] case 2 :
return null ; case 2 : hash3 = key == null ? 0 : key . hashCode () ; key3 = key ; value3 = value ; break; case 1 : hash2 = key == null ? 0 : key . hashCode () ; MST[NegateConditionalsMutator]MSP[N] key2 = key ;
if ( size > 0 ) { MST[rv.UOI4Mutator]MSP[N] final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { final V old = value3 ; value3 = value ;
} if ( delegateMap != null ) { return delegateMap . equals ( obj ) ; } if ( obj instanceof Map == false ) { MST[rv.ROR3Mutator]MSP[S] return false ; } final Map < ? , ? > other = ( Map < ? , ? > ) obj ;
key1 = key2 = key3 = null ; value1 = value2 = value3 = null ; MST[experimental.MemberVariableMutator]MSP[S] } protected AbstractHashedMap < K , V > createDelegateMap () { return new HashedMap <> () ; } @Override public V remove ( final Object key ) {
final StringBuilder buf = new StringBuilder ( 128 ) ; buf . append ( '{' ) ; switch ( size ) { MST[rv.UOI1Mutator]MSP[N] case 3 : buf . append ( key3 == this ? lr_9 : key3 ) ; buf . append ( '=' ) ;
final StringBuilder buf = new StringBuilder ( 128 ) ; buf . append ( '{' ) ; switch ( size ) { MST[rv.UOI4Mutator]MSP[N] case 3 : buf . append ( key3 == this ? lr_9 : key3 ) ; buf . append ( '=' ) ;
return; } if ( size < 4 ) { MST[InlineConstantMutator]MSP[S] for ( final Map . Entry < ? extends K , ? extends V > entry : map . entrySet () ) { put ( entry . getKey () , entry . getValue () ) ; } } else {
if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.ABSMutator]MSP[N] return true ; } } } } return false ; } @Override public boolean containsValue ( final Object value ) { if ( delegateMap != null ) { return delegateMap . containsValue ( value ) ;
} if ( value == null ) { MST[NegateConditionalsMutator]MSP[N] switch ( size ) { case 3 : if ( value3 == null ) { return true ; } case 2 : if ( value2 == null ) { return true ; } case 1 :
if ( delegateMap != null ) { return delegateMap . remove ( key ) ; } if ( size == 0 ) { return null ; } if ( key == null ) { switch ( size ) { MST[experimental.SwitchMutator]MSP[N] case 3 : if ( key3 == null ) {
return old ; } case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.ROR5Mutator]MSP[S] final V old = value2 ; value2 = value ; return old ; } case 1 :
total += hash2 ^ ( value2 == null ? 0 : value2 . hashCode () ) ; case 1 : total += hash1 ^ ( value1 == null ? 0 : value1 . hashCode () ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] case 0 : break; default:
public int size () { if ( delegateMap != null ) { return delegateMap . size () ; MST[ReturnValsMutator]MSP[N] } return size ; } @Override public boolean isEmpty () { return size () == 0 ; } @Override public boolean containsKey ( final Object key ) {
return null ; case 2 : hash3 = key == null ? 0 : key . hashCode () ; key3 = key ; MST[experimental.MemberVariableMutator]MSP[N] value3 = value ; break; case 1 : hash2 = key == null ? 0 : key . hashCode () ; key2 = key ;
delegateMap . clear () ; delegateMap = null ; } else { size = 0 ; hash1 = hash2 = hash3 = 0 ; key1 = key2 = key3 = null ; MST[experimental.MemberVariableMutator]MSP[S] value1 = value2 = value3 = null ; } } @Override
if ( value1 == null ) { return true ; } } } else { switch ( size ) { MST[rv.UOI3Mutator]MSP[N] case 3 : if ( value . equals ( value3 ) ) { return true ; } case 2 : if ( value . equals ( value2 ) ) {
if ( delegateMap != null ) { return delegateMap . remove ( key ) ; } if ( size == 0 ) { MST[rv.ROR4Mutator]MSP[S] return null ; } if ( key == null ) { switch ( size ) { case 3 : if ( key3 == null ) {
return new EntrySet <> ( this ) ; MST[ConstructorCallMutator]MSP[S] } @Override public int size () { return parent . size () ; } @Override public void clear () { parent . clear () ; } @Override public boolean remove ( final Object obj ) {
public MapIterator < K , V > mapIterator () { if ( delegateMap != null ) { return delegateMap . mapIterator () ; } if ( size == 0 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] return EmptyMapIterator . <K , V > emptyMapIterator () ; } return new FlatMapIterator <> ( this ) ;
return; } if ( size < 4 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] for ( final Map . Entry < ? extends K , ? extends V > entry : map . entrySet () ) { put ( entry . getKey () , entry . getValue () ) ; } } else {
total += hash2 ^ ( value2 == null ? 0 : value2 . hashCode () ) ; MST[rv.UOI4Mutator]MSP[S] case 1 : total += hash1 ^ ( value1 == null ? 0 : value1 . hashCode () ) ; case 0 : break; default:
if ( value1 == null ) { return true ; MST[BooleanFalseReturnValsMutator]MSP[N] } } } else { switch ( size ) { case 3 : if ( value . equals ( value3 ) ) { return true ; } case 2 : if ( value . equals ( value2 ) ) {
buf . append ( value1 == this ? lr_9 : value1 ) ; break; default: throw new IllegalStateException ( lr_1 + size ) ; } buf . append ( '}' ) ; return buf . toString () ; MST[NonVoidMethodCallMutator]MSP[N] }
final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[rv.ROR5Mutator]MSP[N] return value3 ; } case 2 :
final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[NegateConditionalsMutator]MSP[N] return value3 ; } case 2 :
@Override public V get ( final Object key ) { if ( delegateMap != null ) { return delegateMap . get ( key ) ; } if ( key == null ) { switch ( size ) { MST[rv.UOI3Mutator]MSP[N] case 3 : if ( key3 == null ) {
hash3 = 0 ; MST[rv.CRCR3Mutator]MSP[S] key3 = null ; value3 = null ; size = 2 ; return old ; } if ( hash2 == hashCode && key . equals ( key2 ) ) { final V old = value2 ; hash2 = hash3 ; key2 = key3 ;
final int hashCode = key . hashCode () ; switch ( size ) { MST[experimental.RemoveSwitchMutator_2]MSP[N] case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { return value3 ; } case 2 :
final int hashCode = key . hashCode () ; switch ( size ) { MST[experimental.RemoveSwitchMutator_1]MSP[N] case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { return value3 ; } case 2 :
return; } if ( size < 4 ) { MST[NegateConditionalsMutator]MSP[N] for ( final Map . Entry < ? extends K , ? extends V > entry : map . entrySet () ) { put ( entry . getKey () , entry . getValue () ) ; } } else {
final int hashCode = key . hashCode () ; switch ( size ) { MST[experimental.RemoveSwitchMutator_0]MSP[N] case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { return value3 ; } case 2 :
public int size () { if ( delegateMap != null ) { return delegateMap . size () ; } return size ; } @Override public boolean isEmpty () { return size () == 0 ; MST[rv.ROR3Mutator]MSP[S] } @Override public boolean containsKey ( final Object key ) {
case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[rv.UOI2Mutator]MSP[S] return true ; } case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { return true ; } case 1 :
final V old = value1 ; hash1 = 0 ; key1 = null ; value1 = null ; size = 0 ; MST[rv.CRCR1Mutator]MSP[N] return old ; } } } } return null ; } @Override public void clear () { if ( delegateMap != null ) {
final V old = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; return old ; } if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.ROR4Mutator]MSP[N] final V old = value1 ; hash1 = hash2 ;
if ( hash2 == hashCode && key . equals ( key2 ) ) { return value2 ; } case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.ROR5Mutator]MSP[N] return value1 ; } } } } return null ; } @Override
key1 = key3 ; value1 = value3 ; hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } return null ; case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
return null ; case 2 : hash3 = key == null ? 0 : key . hashCode () ; MST[rv.CRCR5Mutator]MSP[S] key3 = key ; value3 = value ; break; case 1 : hash2 = key == null ? 0 : key . hashCode () ; key2 = key ;
cloned . delegateMap = cloned . delegateMap . clone () ; } return cloned ; } catch ( final CloneNotSupportedException ex ) { throw new InternalError () ; } } @Override public boolean equals ( final Object obj ) { if ( obj == this ) { return true ; MST[InlineConstantMutator]MSP[N]
if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { MST[experimental.RemoveSwitchMutator_1]MSP[S] case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { final V old = value3 ; value3 = value ;
if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { MST[experimental.RemoveSwitchMutator_2]MSP[S] case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { final V old = value3 ; value3 = value ;
public MapIterator < K , V > mapIterator () { if ( delegateMap != null ) { return delegateMap . mapIterator () ; } if ( size == 0 ) { MST[rv.UOI1Mutator]MSP[N] return EmptyMapIterator . <K , V > emptyMapIterator () ; } return new FlatMapIterator <> ( this ) ;
if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { MST[experimental.RemoveSwitchMutator_0]MSP[S] case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { final V old = value3 ; value3 = value ;
convertToMap () ; delegateMap . putAll ( map ) ; } } private void convertToMap () { delegateMap = createDelegateMap () ; MST[NonVoidMethodCallMutator]MSP[S] switch ( size ) { case 3 : delegateMap . put ( key3 , value3 ) ; case 2 :
public void putAll ( final Map < ? extends K , ? extends V > map ) { final int size = map . size () ; if ( size == 0 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] return; } if ( delegateMap != null ) { delegateMap . putAll ( map ) ;
return value3 ; } case 2 : if ( key2 == null ) { return value2 ; } case 1 : if ( key1 == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return value1 ; } } } else { if ( size > 0 ) {
final V old = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; MST[rv.CRCR3Mutator]MSP[N] return old ; } if ( hash1 == hashCode && key . equals ( key1 ) ) { final V old = value1 ; hash1 = hash2 ;
if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.ROR5Mutator]MSP[N] return value2 ; } case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { return value1 ; } } } } return null ; } @Override
throw new IllegalStateException ( lr_1 + size ) ; } return total ; } @Override public String toString () { if ( delegateMap != null ) { return delegateMap . toString () ; } if ( size == 0 ) { MST[rv.UOI2Mutator]MSP[N] return lr_8 ; }
if ( hash2 == hashCode && key . equals ( key2 ) ) { return value2 ; MST[NullReturnValsMutator]MSP[N] } case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { return value1 ; } } } } return null ; } @Override
value2 = value3 ; hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } if ( key1 == null ) { final V old = value1 ; hash1 = hash3 ; MST[rv.UOI3Mutator]MSP[S] key1 = key3 ; value1 = value3 ;
if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.ROR5Mutator]MSP[N] return true ; } } } } return false ; } @Override public boolean containsValue ( final Object value ) { if ( delegateMap != null ) { return delegateMap . containsValue ( value ) ;
@Override public V get ( final Object key ) { if ( delegateMap != null ) { return delegateMap . get ( key ) ; } if ( key == null ) { MST[rv.ROR5Mutator]MSP[N] switch ( size ) { case 3 : if ( key3 == null ) {
if ( hash2 == hashCode && key . equals ( key2 ) ) { return value2 ; } case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { return value1 ; MST[NullReturnValsMutator]MSP[N] } } } } return null ; } @Override
value2 = value3 ; hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; MST[rv.CRCR5Mutator]MSP[N] return old ; } if ( hash1 == hashCode && key . equals ( key1 ) ) { final V old = value1 ; hash1 = hash3 ;
return lr_2 + getKey () + lr_3 + getValue () + lr_4 ; } return lr_5 ; } @Override public Set < Map . Entry < K , V > > entrySet () { if ( delegateMap != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] return delegateMap . entrySet () ; }
} else { if ( size > 0 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { final V old = value3 ;
case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] return true ; } case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { return true ; } case 1 :
return true ; } case 1 : if ( value . equals ( value1 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return true ; } } } return false ; } @Override public V put ( final K key , final V value ) { if ( delegateMap != null ) {
if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[rv.UOI4Mutator]MSP[S] final V old = value3 ; value3 = value ;
return; } if ( size < 4 ) { MST[rv.UOI1Mutator]MSP[S] for ( final Map . Entry < ? extends K , ? extends V > entry : map . entrySet () ) { put ( entry . getKey () , entry . getValue () ) ; } } else {
return value3 ; } case 2 : if ( key2 == null ) { return value2 ; } case 1 : if ( key1 == null ) { return value1 ; } } } else { if ( size > 0 ) { MST[NegateConditionalsMutator]MSP[N]
value2 = value3 ; hash3 = 0 ; key3 = null ; value3 = null ; MST[experimental.MemberVariableMutator]MSP[S] size = 2 ; return old ; } if ( hash1 == hashCode && key . equals ( key1 ) ) { final V old = value1 ; hash1 = hash3 ;
total += hash2 ^ ( value2 == null ? 0 : value2 . hashCode () ) ; MST[rv.AOR2Mutator]MSP[S] case 1 : total += hash1 ^ ( value1 == null ? 0 : value1 . hashCode () ) ; case 0 : break; default:
key1 = key3 ; value1 = value3 ; hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } return null ; case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.UOI3Mutator]MSP[N]
key1 = key2 ; value1 = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; return old ; } return null ; case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.ROR4Mutator]MSP[N]
public MapIterator < K , V > mapIterator () { if ( delegateMap != null ) { MST[rv.ROR5Mutator]MSP[S] return delegateMap . mapIterator () ; } if ( size == 0 ) { return EmptyMapIterator . <K , V > emptyMapIterator () ; } return new FlatMapIterator <> ( this ) ;
if ( delegateMap != null ) { return delegateMap . hashCode () ; } int total = 0 ; switch ( size ) { case 3 : total += hash3 ^ ( value3 == null ? 0 : value3 . hashCode () ) ; MST[InlineConstantMutator]MSP[S] case 2 :
final V old = value3 ; hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; MST[rv.CRCR5Mutator]MSP[N] return old ; } if ( key2 == null ) { final V old = value2 ; hash2 = hash3 ; key2 = key3 ;
public int size () { if ( delegateMap != null ) { return delegateMap . size () ; } return size ; } @Override public boolean isEmpty () { return size () == 0 ; MST[InlineConstantMutator]MSP[N] } @Override public boolean containsKey ( final Object key ) {
if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[rv.ABSMutator]MSP[S] final V old = value3 ; value3 = value ;
value2 = value ; break; case 0 : hash1 = key == null ? 0 : key . hashCode () ; key1 = key ; value1 = value ; break; } size ++ ; MST[rv.CRCR5Mutator]MSP[N] return null ; } @Override
if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[rv.ROR5Mutator]MSP[S] final V old = value3 ; value3 = value ;
if ( size != other . size () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return false ; } if ( size > 0 ) { Object otherValue = null ; switch ( size ) { case 3 : if ( other . containsKey ( key3 ) == false ) { return false ; }
} else { if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[rv.UOI1Mutator]MSP[S] final V old = value3 ;
if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[NegateConditionalsMutator]MSP[N] return true ; } } } } return false ; } @Override public boolean containsValue ( final Object value ) { if ( delegateMap != null ) { return delegateMap . containsValue ( value ) ;
final StringBuilder buf = new StringBuilder ( 128 ) ; buf . append ( '{' ) ; switch ( size ) { case 3 : buf . append ( key3 == this ? lr_9 : key3 ) ; buf . append ( '=' ) ; MST[rv.CRCR4Mutator]MSP[S]
return value3 ; } case 2 : if ( key2 == null ) { return value2 ; MST[NullReturnValsMutator]MSP[S] } case 1 : if ( key1 == null ) { return value1 ; } } } else { if ( size > 0 ) {
hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; MST[InlineConstantMutator]MSP[N] return old ; } if ( hash2 == hashCode && key . equals ( key2 ) ) { final V old = value2 ; hash2 = hash3 ; key2 = key3 ;
value2 = value ; break; case 0 : hash1 = key == null ? 0 : key . hashCode () ; key1 = key ; value1 = value ; break; } size ++ ; MST[rv.AOD2Mutator]MSP[N] return null ; } @Override
final V old = value3 ; hash3 = 0 ; key3 = null ; value3 = null ; MST[experimental.MemberVariableMutator]MSP[S] size = 2 ; return old ; } if ( key2 == null ) { final V old = value2 ; hash2 = hash3 ; key2 = key3 ;
hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; MST[experimental.MemberVariableMutator]MSP[N] return old ; } return null ; case 2 : if ( key2 == null ) { final V old = value2 ; hash2 = 0 ; key2 = null ;
} else { if ( size > 0 ) { MST[NegateConditionalsMutator]MSP[N] final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { final V old = value3 ;
if ( value1 == null ) { return true ; MST[ReturnValsMutator]MSP[N] } } } else { switch ( size ) { case 3 : if ( value . equals ( value3 ) ) { return true ; } case 2 : if ( value . equals ( value2 ) ) {
if ( delegateMap != null ) { return delegateMap . remove ( key ) ; MST[ArgumentPropagationMutator]MSP[N] } if ( size == 0 ) { return null ; } if ( key == null ) { switch ( size ) { case 3 : if ( key3 == null ) {
delegateMap . clear () ; delegateMap = null ; } else { size = 0 ; MST[rv.CRCR3Mutator]MSP[N] hash1 = hash2 = hash3 = 0 ; key1 = key2 = key3 = null ; value1 = value2 = value3 = null ; } } @Override
if ( key2 == null ) { final V old = value2 ; value2 = value ; return old ; MST[ReturnValsMutator]MSP[S] } case 1 : if ( key1 == null ) { final V old = value1 ; value1 = value ; return old ; } } } else {
final StringBuilder buf = new StringBuilder ( 128 ) ; MST[InlineConstantMutator]MSP[S] buf . append ( '{' ) ; switch ( size ) { case 3 : buf . append ( key3 == this ? lr_9 : key3 ) ; buf . append ( '=' ) ;
if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.UOI1Mutator]MSP[N] return value2 ; } case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { return value1 ; } } } } return null ; } @Override
throw new IllegalStateException ( lr_1 + size ) ; } return total ; } @Override public String toString () { if ( delegateMap != null ) { return delegateMap . toString () ; } if ( size == 0 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] return lr_8 ; }
return null ; case 2 : hash3 = key == null ? 0 : key . hashCode () ; key3 = key ; value3 = value ; break; case 1 : hash2 = key == null ? 0 : key . hashCode () ; MST[rv.ROR5Mutator]MSP[N] key2 = key ;
convertToMap () ; delegateMap . putAll ( map ) ; } } private void convertToMap () { delegateMap = createDelegateMap () ; switch ( size ) { MST[rv.UOI4Mutator]MSP[N] case 3 : delegateMap . put ( key3 , value3 ) ; case 2 :
return old ; } case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[NegateConditionalsMutator]MSP[S] final V old = value2 ; value2 = value ; return old ; } case 1 :
key1 = key3 ; value1 = value3 ; hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } return null ; case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.UOI2Mutator]MSP[N]
hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } return null ; case 2 : if ( key2 == null ) { final V old = value2 ; hash2 = 0 ; MST[rv.CRCR6Mutator]MSP[S] key2 = null ;
total += hash2 ^ ( value2 == null ? 0 : value2 . hashCode () ) ; case 1 : total += hash1 ^ ( value1 == null ? 0 : value1 . hashCode () ) ; MST[rv.UOI4Mutator]MSP[S] case 0 : break; default:
if ( hash2 == hashCode && key . equals ( key2 ) ) { return value2 ; } case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[NegateConditionalsMutator]MSP[N] return value1 ; } } } } return null ; } @Override
delegateMap . put ( key2 , value2 ) ; case 1 : delegateMap . put ( key1 , value1 ) ; case 0 : break; default: throw new IllegalStateException ( lr_1 + size ) ; } size = 0 ; MST[experimental.MemberVariableMutator]MSP[S] hash1 = hash2 = hash3 = 0 ;
} else { if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { MST[experimental.RemoveSwitchMutator_1]MSP[N] case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { final V old = value3 ;
if ( hash2 == hashCode && key . equals ( key2 ) ) { return value2 ; } case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.UOI1Mutator]MSP[N] return value1 ; } } } } return null ; } @Override
} else { if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { MST[experimental.RemoveSwitchMutator_2]MSP[N] case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { final V old = value3 ;
} else { if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[rv.ROR1Mutator]MSP[S] final V old = value3 ;
} else { if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { MST[experimental.RemoveSwitchMutator_0]MSP[N] case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { final V old = value3 ;
if ( delegateMap != null ) { return delegateMap . containsKey ( key ) ; } if ( key == null ) { switch ( size ) { MST[experimental.RemoveSwitchMutator_2]MSP[N] case 3 : if ( key3 == null ) { return true ; } case 2 :
if ( delegateMap != null ) { return delegateMap . containsKey ( key ) ; } if ( key == null ) { switch ( size ) { MST[experimental.RemoveSwitchMutator_0]MSP[N] case 3 : if ( key3 == null ) { return true ; } case 2 :
if ( delegateMap != null ) { return delegateMap . containsKey ( key ) ; } if ( key == null ) { switch ( size ) { MST[experimental.RemoveSwitchMutator_1]MSP[N] case 3 : if ( key3 == null ) { return true ; } case 2 :
} else { if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[NegateConditionalsMutator]MSP[N] final V old = value3 ;
if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.ROR1Mutator]MSP[S] final V old = value1 ; value1 = value ; return old ; } } } } switch ( size ) { default: convertToMap () ; delegateMap . put ( key , value ) ;
if ( size > 0 ) { MST[rv.ROR5Mutator]MSP[S] final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { final V old = value3 ; value3 = value ;
return true ; MST[rv.CRCR5Mutator]MSP[N] } case 1 : if ( value . equals ( value1 ) ) { return true ; } } } return false ; } @Override public V put ( final K key , final V value ) { if ( delegateMap != null ) {
@Override public V get ( final Object key ) { if ( delegateMap != null ) { return delegateMap . get ( key ) ; } if ( key == null ) { MST[NegateConditionalsMutator]MSP[N] switch ( size ) { case 3 : if ( key3 == null ) {
final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[rv.UOI1Mutator]MSP[S] return value3 ; } case 2 :
if ( value1 == null ) { return true ; } } } else { switch ( size ) { case 3 : if ( value . equals ( value3 ) ) { return true ; } case 2 : if ( value . equals ( value2 ) ) { MST[rv.ROR5Mutator]MSP[N]
if ( value1 == null ) { return true ; } } } else { switch ( size ) { case 3 : if ( value . equals ( value3 ) ) { MST[rv.ROR1Mutator]MSP[N] return true ; } case 2 : if ( value . equals ( value2 ) ) {
if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.UOI4Mutator]MSP[N] final V old = value1 ; value1 = value ; return old ; } } } } switch ( size ) { default: convertToMap () ; delegateMap . put ( key , value ) ;
if ( key2 == null ) { return true ; } case 1 : if ( key1 == null ) { return true ; } } } else { if ( size > 0 ) { MST[rv.UOI2Mutator]MSP[N] final int hashCode = key . hashCode () ; switch ( size ) {
public Collection < V > values () { if ( delegateMap != null ) { MST[NegateConditionalsMutator]MSP[S] return delegateMap . values () ; } return new Values <> ( this ) ; } @Override public int size () { return parent . size () ; } @Override public void clear () {
if ( delegateMap != null ) { return delegateMap . remove ( key ) ; } if ( size == 0 ) { return null ; } if ( key == null ) { switch ( size ) { case 3 : if ( key3 == null ) { MST[NegateConditionalsMutator]MSP[N]
hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] final V old = value2 ; hash2 = hash3 ; key2 = key3 ;
final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { return value3 ; MST[NullReturnValsMutator]MSP[N] } case 2 :
convertToMap () ; delegateMap . putAll ( map ) ; } } private void convertToMap () { delegateMap = createDelegateMap () ; MST[experimental.MemberVariableMutator]MSP[S] switch ( size ) { case 3 : delegateMap . put ( key3 , value3 ) ; case 2 :
value2 = value ; break; case 0 : hash1 = key == null ? 0 : key . hashCode () ; MST[InlineConstantMutator]MSP[S] key1 = key ; value1 = value ; break; } size ++ ; return null ; } @Override
if ( key2 == null ) { return true ; } case 1 : if ( key1 == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return true ; } } } else { if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) {
} if ( delegateMap != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] return delegateMap . equals ( obj ) ; } if ( obj instanceof Map == false ) { return false ; } final Map < ? , ? > other = ( Map < ? , ? > ) obj ;
if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[NegateConditionalsMutator]MSP[N] return value2 ; } case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { return value1 ; } } } } return null ; } @Override
public int size () { if ( delegateMap != null ) { return delegateMap . size () ; } return size ; MST[rv.UOI2Mutator]MSP[N] } @Override public boolean isEmpty () { return size () == 0 ; } @Override public boolean containsKey ( final Object key ) {
total += hash2 ^ ( value2 == null ? 0 : value2 . hashCode () ) ; MST[rv.UOI2Mutator]MSP[S] case 1 : total += hash1 ^ ( value1 == null ? 0 : value1 . hashCode () ) ; case 0 : break; default:
if ( delegateMap != null ) { return delegateMap . remove ( key ) ; } if ( size == 0 ) { return null ; } if ( key == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] switch ( size ) { case 3 : if ( key3 == null ) {
total += hash2 ^ ( value2 == null ? 0 : value2 . hashCode () ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] case 1 : total += hash1 ^ ( value1 == null ? 0 : value1 . hashCode () ) ; case 0 : break; default:
if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.ROR1Mutator]MSP[S] return true ; } } } } return false ; } @Override public boolean containsValue ( final Object value ) { if ( delegateMap != null ) { return delegateMap . containsValue ( value ) ;
size = 1 ; return old ; } return null ; case 1 : if ( key1 == null ) { final V old = value1 ; hash1 = 0 ; key1 = null ; value1 = null ; MST[experimental.MemberVariableMutator]MSP[S] size = 0 ; return old ; } }
case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { return true ; } case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.ROR2Mutator]MSP[S] return true ; } case 1 :
total += hash2 ^ ( value2 == null ? 0 : value2 . hashCode () ) ; case 1 : total += hash1 ^ ( value1 == null ? 0 : value1 . hashCode () ) ; MST[rv.UOI2Mutator]MSP[S] case 0 : break; default:
final StringBuilder buf = new StringBuilder ( 128 ) ; MST[rv.CRCR4Mutator]MSP[S] buf . append ( '{' ) ; switch ( size ) { case 3 : buf . append ( key3 == this ? lr_9 : key3 ) ; buf . append ( '=' ) ;
if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[rv.ROR5Mutator]MSP[S] final V old = value3 ; value3 = value ;
value2 = value ; break; case 0 : hash1 = key == null ? 0 : key . hashCode () ; key1 = key ; value1 = value ; break; } size ++ ; MST[rv.CRCR4Mutator]MSP[N] return null ; } @Override
delegateMap . clear () ; delegateMap = null ; } else { size = 0 ; MST[InlineConstantMutator]MSP[N] hash1 = hash2 = hash3 = 0 ; key1 = key2 = key3 = null ; value1 = value2 = value3 = null ; } } @Override
hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } return null ; case 2 : if ( key2 == null ) { final V old = value2 ; hash2 = 0 ; key2 = null ; MST[experimental.MemberVariableMutator]MSP[S]
public int size () { if ( delegateMap != null ) { return delegateMap . size () ; } return size ; MST[rv.UOI1Mutator]MSP[N] } @Override public boolean isEmpty () { return size () == 0 ; } @Override public boolean containsKey ( final Object key ) {
buf . append ( value1 == this ? lr_9 : value1 ) ; break; default: throw new IllegalStateException ( lr_1 + size ) ; } buf . append ( '}' ) ; MST[experimental.NakedReceiverMutator]MSP[N] return buf . toString () ; }
size = 1 ; return old ; } return null ; case 1 : if ( key1 == null ) { final V old = value1 ; hash1 = 0 ; key1 = null ; value1 = null ; size = 0 ; MST[rv.CRCR3Mutator]MSP[S] return old ; } }
buf . append ( value3 == this ? lr_9 : value3 ) ; buf . append ( ',' ) ; MST[NonVoidMethodCallMutator]MSP[S] case 2 : buf . append ( key2 == this ? lr_9 : key2 ) ; buf . append ( '=' ) ;
if ( value1 == null ) { return true ; } } } else { switch ( size ) { case 3 : if ( value . equals ( value3 ) ) { MST[NonVoidMethodCallMutator]MSP[S] return true ; } case 2 : if ( value . equals ( value2 ) ) {
if ( value1 == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return true ; } } } else { switch ( size ) { case 3 : if ( value . equals ( value3 ) ) { return true ; } case 2 : if ( value . equals ( value2 ) ) {
return delegateMap . put ( key , value ) ; } if ( key == null ) { switch ( size ) { MST[rv.ABSMutator]MSP[N] case 3 : if ( key3 == null ) { final V old = value3 ; value3 = value ; return old ; } case 2 :
} if ( delegateMap != null ) { return delegateMap . equals ( obj ) ; } if ( obj instanceof Map == false ) { MST[rv.ROR1Mutator]MSP[N] return false ; } final Map < ? , ? > other = ( Map < ? , ? > ) obj ;
buf . append ( value1 == this ? lr_9 : value1 ) ; break; default: throw new IllegalStateException ( lr_1 + size ) ; } buf . append ( '}' ) ; MST[rv.CRCR6Mutator]MSP[N] return buf . toString () ; }
return delegateMap . put ( key , value ) ; } if ( key == null ) { switch ( size ) { MST[experimental.RemoveSwitchMutator_1]MSP[N] case 3 : if ( key3 == null ) { final V old = value3 ; value3 = value ; return old ; } case 2 :
return delegateMap . put ( key , value ) ; } if ( key == null ) { switch ( size ) { MST[experimental.RemoveSwitchMutator_0]MSP[S] case 3 : if ( key3 == null ) { final V old = value3 ; value3 = value ; return old ; } case 2 :
return delegateMap . put ( key , value ) ; } if ( key == null ) { switch ( size ) { MST[experimental.RemoveSwitchMutator_2]MSP[S] case 3 : if ( key3 == null ) { final V old = value3 ; value3 = value ; return old ; } case 2 :
size = 1 ; return old ; } return null ; case 1 : if ( key1 == null ) { final V old = value1 ; hash1 = 0 ; key1 = null ; value1 = null ; size = 0 ; return old ; MST[NullReturnValsMutator]MSP[S] } }
buf . append ( value3 == this ? lr_9 : value3 ) ; buf . append ( ',' ) ; MST[rv.CRCR2Mutator]MSP[S] case 2 : buf . append ( key2 == this ? lr_9 : key2 ) ; buf . append ( '=' ) ;
hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } if ( hash2 == hashCode && key . equals ( key2 ) ) { final V old = value2 ; hash2 = hash3 ; key2 = key3 ; MST[experimental.MemberVariableMutator]MSP[S]
buf . append ( value2 == this ? lr_9 : value2 ) ; buf . append ( ',' ) ; case 1 : buf . append ( key1 == this ? lr_9 : key1 ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] buf . append ( '=' ) ;
if ( delegateMap != null ) { return delegateMap . hashCode () ; } int total = 0 ; switch ( size ) { MST[rv.UOI2Mutator]MSP[N] case 3 : total += hash3 ^ ( value3 == null ? 0 : value3 . hashCode () ) ; case 2 :
key1 = key2 ; value1 = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; return old ; } return null ; case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.UOI4Mutator]MSP[N]
if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[NegateConditionalsMutator]MSP[S] final V old = value3 ; value3 = value ;
return true ; } case 1 : if ( value . equals ( value1 ) ) { return true ; } } } return false ; MST[BooleanTrueReturnValsMutator]MSP[N] } @Override public V put ( final K key , final V value ) { if ( delegateMap != null ) {
final int hashCode = key . hashCode () ; switch ( size ) { MST[rv.UOI1Mutator]MSP[N] case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { return value3 ; } case 2 :
final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[rv.UOI2Mutator]MSP[S] return value3 ; } case 2 :
public int size () { if ( delegateMap != null ) { return delegateMap . size () ; } return size ; } @Override public boolean isEmpty () { return size () == 0 ; MST[rv.CRCR6Mutator]MSP[N] } @Override public boolean containsKey ( final Object key ) {
if ( delegateMap != null ) { MST[NegateConditionalsMutator]MSP[N] return delegateMap . containsKey ( key ) ; } if ( key == null ) { switch ( size ) { case 3 : if ( key3 == null ) { return true ; } case 2 :
if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.UOI3Mutator]MSP[N] return value2 ; } case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { return value1 ; } } } } return null ; } @Override
if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[rv.UOI2Mutator]MSP[S] final V old = value3 ; value3 = value ;
convertToMap () ; delegateMap . putAll ( map ) ; } } private void convertToMap () { delegateMap = createDelegateMap () ; switch ( size ) { MST[rv.UOI3Mutator]MSP[S] case 3 : delegateMap . put ( key3 , value3 ) ; case 2 :
buf . append ( value3 == this ? lr_9 : value3 ) ; buf . append ( ',' ) ; case 2 : buf . append ( key2 == this ? lr_9 : key2 ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] buf . append ( '=' ) ;
final StringBuilder buf = new StringBuilder ( 128 ) ; buf . append ( '{' ) ; MST[rv.CRCR6Mutator]MSP[N] switch ( size ) { case 3 : buf . append ( key3 == this ? lr_9 : key3 ) ; buf . append ( '=' ) ;
final V old = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; return old ; } if ( hash1 == hashCode && key . equals ( key1 ) ) { final V old = value1 ; hash1 = hash2 ; MST[rv.UOI4Mutator]MSP[S]
if ( delegateMap != null ) { return delegateMap . hashCode () ; } int total = 0 ; switch ( size ) { MST[experimental.RemoveSwitchMutator_0]MSP[S] case 3 : total += hash3 ^ ( value3 == null ? 0 : value3 . hashCode () ) ; case 2 :
if ( size != other . size () ) { MST[rv.ROR1Mutator]MSP[N] return false ; } if ( size > 0 ) { Object otherValue = null ; switch ( size ) { case 3 : if ( other . containsKey ( key3 ) == false ) { return false ; }
final V old = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; return old ; } if ( hash1 == hashCode && key . equals ( key1 ) ) { final V old = value1 ; hash1 = hash2 ; MST[rv.UOI1Mutator]MSP[S]
if ( delegateMap != null ) { return delegateMap . hashCode () ; } int total = 0 ; switch ( size ) { MST[experimental.RemoveSwitchMutator_1]MSP[S] case 3 : total += hash3 ^ ( value3 == null ? 0 : value3 . hashCode () ) ; case 2 :
cloned . delegateMap = cloned . delegateMap . clone () ; } return cloned ; } catch ( final CloneNotSupportedException ex ) { throw new InternalError () ; } } @Override public boolean equals ( final Object obj ) { if ( obj == this ) { return true ; MST[rv.CRCR4Mutator]MSP[S]
if ( delegateMap != null ) { return delegateMap . hashCode () ; } int total = 0 ; switch ( size ) { MST[experimental.RemoveSwitchMutator_2]MSP[S] case 3 : total += hash3 ^ ( value3 == null ? 0 : value3 . hashCode () ) ; case 2 :
return delegateMap . put ( key , value ) ; } if ( key == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] switch ( size ) { case 3 : if ( key3 == null ) { final V old = value3 ; value3 = value ; return old ; } case 2 :
if ( delegateMap != null ) { return delegateMap . hashCode () ; } int total = 0 ; switch ( size ) { MST[experimental.RemoveSwitchMutator_3]MSP[S] case 3 : total += hash3 ^ ( value3 == null ? 0 : value3 . hashCode () ) ; case 2 :
key1 = key2 ; value1 = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; MST[rv.CRCR5Mutator]MSP[N] return old ; } return null ; case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) {
if ( size != other . size () ) { return false ; MST[rv.CRCR6Mutator]MSP[N] } if ( size > 0 ) { Object otherValue = null ; switch ( size ) { case 3 : if ( other . containsKey ( key3 ) == false ) { return false ; }
if ( hash2 == hashCode && key . equals ( key2 ) ) { return value2 ; } case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.UOI3Mutator]MSP[N] return value1 ; } } } } return null ; } @Override
total += hash2 ^ ( value2 == null ? 0 : value2 . hashCode () ) ; case 1 : total += hash1 ^ ( value1 == null ? 0 : value1 . hashCode () ) ; MST[rv.CRCR3Mutator]MSP[S] case 0 : break; default:
key1 = key2 ; value1 = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; return old ; } return null ; case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.ROR1Mutator]MSP[S]
if ( delegateMap != null ) { return delegateMap . remove ( key ) ; MST[NullReturnValsMutator]MSP[S] } if ( size == 0 ) { return null ; } if ( key == null ) { switch ( size ) { case 3 : if ( key3 == null ) {
@Override public V get ( final Object key ) { if ( delegateMap != null ) { return delegateMap . get ( key ) ; MST[ReturnValsMutator]MSP[S] } if ( key == null ) { switch ( size ) { case 3 : if ( key3 == null ) {
final V old = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; return old ; } if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.UOI4Mutator]MSP[N] final V old = value1 ; hash1 = hash2 ;
return value3 ; } case 2 : if ( key2 == null ) { return value2 ; } case 1 : if ( key1 == null ) { return value1 ; } } } else { if ( size > 0 ) { MST[rv.UOI2Mutator]MSP[N]
buf . append ( value2 == this ? lr_9 : value2 ) ; buf . append ( ',' ) ; MST[NonVoidMethodCallMutator]MSP[N] case 1 : buf . append ( key1 == this ? lr_9 : key1 ) ; buf . append ( '=' ) ;
value2 = value3 ; hash3 = 0 ; MST[rv.CRCR5Mutator]MSP[S] key3 = null ; value3 = null ; size = 2 ; return old ; } if ( hash1 == hashCode && key . equals ( key1 ) ) { final V old = value1 ; hash1 = hash3 ;
if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.ROR5Mutator]MSP[S] final V old = value1 ; value1 = value ; return old ; } } } } switch ( size ) { default: convertToMap () ; delegateMap . put ( key , value ) ;
final V old = value3 ; hash3 = 0 ; MST[rv.CRCR5Mutator]MSP[S] key3 = null ; value3 = null ; size = 2 ; return old ; } if ( key2 == null ) { final V old = value2 ; hash2 = hash3 ; key2 = key3 ;
if ( key2 == null ) { return true ; MST[rv.CRCR4Mutator]MSP[S] } case 1 : if ( key1 == null ) { return true ; } } } else { if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) {
final V old = value1 ; hash1 = 0 ; key1 = null ; MST[experimental.MemberVariableMutator]MSP[S] value1 = null ; size = 0 ; return old ; } } } } return null ; } @Override public void clear () { if ( delegateMap != null ) {
total += hash2 ^ ( value2 == null ? 0 : value2 . hashCode () ) ; case 1 : total += hash1 ^ ( value1 == null ? 0 : value1 . hashCode () ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] case 0 : break; default:
public MapIterator < K , V > mapIterator () { if ( delegateMap != null ) { return delegateMap . mapIterator () ; } if ( size == 0 ) { return EmptyMapIterator . <K , V > emptyMapIterator () ; } return new FlatMapIterator <> ( this ) ; MST[NullReturnValsMutator]MSP[S]
key1 = key3 ; value1 = value3 ; hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } return null ; case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.ABSMutator]MSP[N]
hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; MST[rv.CRCR6Mutator]MSP[N] return old ; } if ( hash2 == hashCode && key . equals ( key2 ) ) { final V old = value2 ; hash2 = hash3 ; key2 = key3 ;
return old ; } case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.ROR2Mutator]MSP[S] final V old = value2 ; value2 = value ; return old ; } case 1 :
hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.ROR2Mutator]MSP[S] final V old = value2 ; hash2 = hash3 ; key2 = key3 ;
delegateMap . clear () ; delegateMap = null ; } else { size = 0 ; hash1 = hash2 = hash3 = 0 ; key1 = key2 = key3 = null ; value1 = value2 = value3 = null ; MST[experimental.MemberVariableMutator]MSP[S] } } @Override
if ( size != other . size () ) { return false ; } if ( size > 0 ) { MST[rv.UOI2Mutator]MSP[S] Object otherValue = null ; switch ( size ) { case 3 : if ( other . containsKey ( key3 ) == false ) { return false ; }
case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[rv.UOI1Mutator]MSP[S] return true ; } case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { return true ; } case 1 :
} else { if ( size > 0 ) { MST[ConditionalsBoundaryMutator]MSP[S] final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { final V old = value3 ;
if ( delegateMap != null ) { return delegateMap . containsKey ( key ) ; } if ( key == null ) { switch ( size ) { MST[rv.UOI4Mutator]MSP[N] case 3 : if ( key3 == null ) { return true ; } case 2 :
case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { return true ; } case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.UOI1Mutator]MSP[S] return true ; } case 1 :
if ( delegateMap != null ) { return delegateMap . hashCode () ; } int total = 0 ; MST[rv.CRCR5Mutator]MSP[S] switch ( size ) { case 3 : total += hash3 ^ ( value3 == null ? 0 : value3 . hashCode () ) ; case 2 :
final V old = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; return old ; } if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.ROR1Mutator]MSP[S] final V old = value1 ; hash1 = hash2 ;
if ( delegateMap != null ) { return delegateMap . containsKey ( key ) ; } if ( key == null ) { switch ( size ) { case 3 : if ( key3 == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] return true ; } case 2 :
final V old = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; return old ; } if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.UOI1Mutator]MSP[S] final V old = value1 ; hash1 = hash2 ;
if ( size > 0 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[S] final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { final V old = value3 ; value3 = value ;
} if ( delegateMap != null ) { return delegateMap . equals ( obj ) ; } if ( obj instanceof Map == false ) { return false ; MST[rv.CRCR6Mutator]MSP[N] } final Map < ? , ? > other = ( Map < ? , ? > ) obj ;
cloned . delegateMap = cloned . delegateMap . clone () ; } return cloned ; } catch ( final CloneNotSupportedException ex ) { throw new InternalError () ; } } @Override public boolean equals ( final Object obj ) { if ( obj == this ) { return true ; MST[BooleanFalseReturnValsMutator]MSP[N]
if ( key2 == null ) { return true ; MST[BooleanFalseReturnValsMutator]MSP[N] } case 1 : if ( key1 == null ) { return true ; } } } else { if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) {
if ( delegateMap != null ) { return delegateMap . remove ( key ) ; } if ( size == 0 ) { return null ; MST[ReturnValsMutator]MSP[S] } if ( key == null ) { switch ( size ) { case 3 : if ( key3 == null ) {
final StringBuilder buf = new StringBuilder ( 128 ) ; buf . append ( '{' ) ; switch ( size ) { case 3 : buf . append ( key3 == this ? lr_9 : key3 ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] buf . append ( '=' ) ;
} if ( value == null ) { switch ( size ) { MST[rv.UOI2Mutator]MSP[N] case 3 : if ( value3 == null ) { return true ; } case 2 : if ( value2 == null ) { return true ; } case 1 :
final V old = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; return old ; } if ( hash1 == hashCode && key . equals ( key1 ) ) { final V old = value1 ; hash1 = hash2 ; MST[experimental.MemberVariableMutator]MSP[S]
hash3 = 0 ; MST[rv.CRCR1Mutator]MSP[S] key3 = null ; value3 = null ; size = 2 ; return old ; } if ( hash2 == hashCode && key . equals ( key2 ) ) { final V old = value2 ; hash2 = hash3 ; key2 = key3 ;
size = 1 ; return old ; } return null ; case 1 : if ( key1 == null ) { final V old = value1 ; hash1 = 0 ; key1 = null ; value1 = null ; size = 0 ; MST[rv.CRCR6Mutator]MSP[S] return old ; } }
return old ; } case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.ABSMutator]MSP[S] final V old = value2 ; value2 = value ; return old ; } case 1 :
if ( delegateMap != null ) { return delegateMap . hashCode () ; } int total = 0 ; switch ( size ) { case 3 : total += hash3 ^ ( value3 == null ? 0 : value3 . hashCode () ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] case 2 :
public void putAll ( final Map < ? extends K , ? extends V > map ) { final int size = map . size () ; if ( size == 0 ) { return; } if ( delegateMap != null ) { MST[rv.ROR5Mutator]MSP[S] delegateMap . putAll ( map ) ;
if ( size != other . size () ) { return false ; } if ( size > 0 ) { MST[rv.ABSMutator]MSP[S] Object otherValue = null ; switch ( size ) { case 3 : if ( other . containsKey ( key3 ) == false ) { return false ; }
if ( hash2 == hashCode && key . equals ( key2 ) ) { return value2 ; } case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.ABSMutator]MSP[N] return value1 ; } } } } return null ; } @Override
final StringBuilder buf = new StringBuilder ( 128 ) ; MST[rv.CRCR1Mutator]MSP[S] buf . append ( '{' ) ; switch ( size ) { case 3 : buf . append ( key3 == this ? lr_9 : key3 ) ; buf . append ( '=' ) ;
buf . append ( value1 == this ? lr_9 : value1 ) ; break; default: throw new IllegalStateException ( lr_1 + size ) ; } buf . append ( '}' ) ; return buf . toString () ; MST[EmptyObjectReturnValsMutator]MSP[N] }
delegateMap . put ( key2 , value2 ) ; case 1 : delegateMap . put ( key1 , value1 ) ; case 0 : break; default: throw new IllegalStateException ( lr_1 + size ) ; } size = 0 ; MST[rv.CRCR6Mutator]MSP[S] hash1 = hash2 = hash3 = 0 ;
@Override public V get ( final Object key ) { if ( delegateMap != null ) { return delegateMap . get ( key ) ; } if ( key == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] switch ( size ) { case 3 : if ( key3 == null ) {
case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { return true ; } case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.UOI4Mutator]MSP[S] return true ; } case 1 :
if ( hash1 == hashCode && key . equals ( key1 ) ) { return true ; } } } } return false ; } @Override public boolean containsValue ( final Object value ) { if ( delegateMap != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] return delegateMap . containsValue ( value ) ;
return old ; } case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.UOI4Mutator]MSP[S] final V old = value2 ; value2 = value ; return old ; } case 1 :
key1 = key2 ; value1 = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; return old ; } return null ; case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.UOI1Mutator]MSP[S]
key1 = key3 ; value1 = value3 ; hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } return null ; case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S]
if ( key2 == null ) { return true ; } case 1 : if ( key1 == null ) { return true ; } } } else { if ( size > 0 ) { MST[rv.ROR1Mutator]MSP[S] final int hashCode = key . hashCode () ; switch ( size ) {
if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return value2 ; } case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { return value1 ; } } } } return null ; } @Override
if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.ROR3Mutator]MSP[S] return true ; } } } } return false ; } @Override public boolean containsValue ( final Object value ) { if ( delegateMap != null ) { return delegateMap . containsValue ( value ) ;
total += hash2 ^ ( value2 == null ? 0 : value2 . hashCode () ) ; MST[rv.ABSMutator]MSP[S] case 1 : total += hash1 ^ ( value1 == null ? 0 : value1 . hashCode () ) ; case 0 : break; default:
final StringBuilder buf = new StringBuilder ( 128 ) ; buf . append ( '{' ) ; switch ( size ) { MST[rv.ABSMutator]MSP[S] case 3 : buf . append ( key3 == this ? lr_9 : key3 ) ; buf . append ( '=' ) ;
final StringBuilder buf = new StringBuilder ( 128 ) ; buf . append ( '{' ) ; switch ( size ) { MST[rv.UOI2Mutator]MSP[N] case 3 : buf . append ( key3 == this ? lr_9 : key3 ) ; buf . append ( '=' ) ;
key1 = key3 ; value1 = value3 ; hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } return null ; case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.ROR3Mutator]MSP[S]
public int size () { if ( delegateMap != null ) { MST[NegateConditionalsMutator]MSP[N] return delegateMap . size () ; } return size ; } @Override public boolean isEmpty () { return size () == 0 ; } @Override public boolean containsKey ( final Object key ) {
if ( value1 == null ) { return true ; } } } else { switch ( size ) { case 3 : if ( value . equals ( value3 ) ) { MST[rv.ROR3Mutator]MSP[N] return true ; } case 2 : if ( value . equals ( value2 ) ) {
if ( key2 == null ) { return true ; } case 1 : if ( key1 == null ) { return true ; } } } else { if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { MST[rv.UOI2Mutator]MSP[N]
if ( value1 == null ) { return true ; } } } else { switch ( size ) { MST[experimental.RemoveSwitchMutator_0]MSP[S] case 3 : if ( value . equals ( value3 ) ) { return true ; } case 2 : if ( value . equals ( value2 ) ) {
if ( value1 == null ) { return true ; } } } else { switch ( size ) { MST[experimental.RemoveSwitchMutator_1]MSP[N] case 3 : if ( value . equals ( value3 ) ) { return true ; } case 2 : if ( value . equals ( value2 ) ) {
if ( value1 == null ) { return true ; } } } else { switch ( size ) { MST[experimental.RemoveSwitchMutator_2]MSP[S] case 3 : if ( value . equals ( value3 ) ) { return true ; } case 2 : if ( value . equals ( value2 ) ) {
if ( hash1 == hashCode && key . equals ( key1 ) ) { return true ; MST[InlineConstantMutator]MSP[N] } } } } return false ; } @Override public boolean containsValue ( final Object value ) { if ( delegateMap != null ) { return delegateMap . containsValue ( value ) ;
final StringBuilder buf = new StringBuilder ( 128 ) ; buf . append ( '{' ) ; MST[experimental.NakedReceiverMutator]MSP[N] switch ( size ) { case 3 : buf . append ( key3 == this ? lr_9 : key3 ) ; buf . append ( '=' ) ;
case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[rv.UOI4Mutator]MSP[S] return true ; } case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { return true ; } case 1 :
buf . append ( value1 == this ? lr_9 : value1 ) ; break; default: throw new IllegalStateException ( lr_1 + size ) ; } buf . append ( '}' ) ; return buf . toString () ; MST[ReturnValsMutator]MSP[N] }
total += hash2 ^ ( value2 == null ? 0 : value2 . hashCode () ) ; case 1 : total += hash1 ^ ( value1 == null ? 0 : value1 . hashCode () ) ; MST[rv.AOD2Mutator]MSP[S] case 0 : break; default:
if ( delegateMap != null ) { return delegateMap . hashCode () ; } int total = 0 ; switch ( size ) { case 3 : total += hash3 ^ ( value3 == null ? 0 : value3 . hashCode () ) ; MST[rv.UOI3Mutator]MSP[S] case 2 :
if ( value1 == null ) { return true ; } } } else { switch ( size ) { case 3 : if ( value . equals ( value3 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return true ; } case 2 : if ( value . equals ( value2 ) ) {
} else { if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[rv.ROR4Mutator]MSP[N] final V old = value3 ;
if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.ROR1Mutator]MSP[N] final V old = value1 ; value1 = value ; return old ; } } } } switch ( size ) { default: convertToMap () ; delegateMap . put ( key , value ) ;
return null ; case 2 : hash3 = key == null ? 0 : key . hashCode () ; key3 = key ; value3 = value ; break; case 1 : hash2 = key == null ? 0 : key . hashCode () ; MST[experimental.MemberVariableMutator]MSP[N] key2 = key ;
final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return value3 ; } case 2 :
key1 = key2 ; value1 = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; return old ; } return null ; case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.UOI3Mutator]MSP[N]
if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.ABSMutator]MSP[N] return value2 ; } case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { return value1 ; } } } } return null ; } @Override
key1 = key2 ; value1 = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; return old ; MST[ReturnValsMutator]MSP[S] } return null ; case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) {
if ( key2 == null ) { return true ; } case 1 : if ( key1 == null ) { return true ; } } } else { if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { MST[rv.ABSMutator]MSP[N]
key1 = key2 ; value1 = value2 ; hash2 = 0 ; MST[experimental.MemberVariableMutator]MSP[S] key2 = null ; value2 = null ; size = 1 ; return old ; } return null ; case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) {
throw new IllegalStateException ( lr_1 + size ) ; } return total ; MST[rv.UOI3Mutator]MSP[S] } @Override public String toString () { if ( delegateMap != null ) { return delegateMap . toString () ; } if ( size == 0 ) { return lr_8 ; }
return true ; MST[rv.CRCR2Mutator]MSP[N] } case 1 : if ( value . equals ( value1 ) ) { return true ; } } } return false ; } @Override public V put ( final K key , final V value ) { if ( delegateMap != null ) {
public int size () { if ( delegateMap != null ) { return delegateMap . size () ; } return size ; MST[rv.UOI4Mutator]MSP[N] } @Override public boolean isEmpty () { return size () == 0 ; } @Override public boolean containsKey ( final Object key ) {
final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[rv.UOI3Mutator]MSP[S] return value3 ; } case 2 :
if ( delegateMap != null ) { return delegateMap . hashCode () ; } int total = 0 ; switch ( size ) { case 3 : total += hash3 ^ ( value3 == null ? 0 : value3 . hashCode () ) ; MST[rv.AOR3Mutator]MSP[S] case 2 :
if ( size > 0 ) { MST[rv.UOI1Mutator]MSP[N] final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { final V old = value3 ; value3 = value ;
if ( value1 == null ) { return true ; } } } else { switch ( size ) { MST[rv.ABSMutator]MSP[N] case 3 : if ( value . equals ( value3 ) ) { return true ; } case 2 : if ( value . equals ( value2 ) ) {
return delegateMap . put ( key , value ) ; } if ( key == null ) { switch ( size ) { case 3 : if ( key3 == null ) { MST[NegateConditionalsMutator]MSP[S] final V old = value3 ; value3 = value ; return old ; } case 2 :
delegateMap . put ( key2 , value2 ) ; MST[NonVoidMethodCallMutator]MSP[N] case 1 : delegateMap . put ( key1 , value1 ) ; case 0 : break; default: throw new IllegalStateException ( lr_1 + size ) ; } size = 0 ; hash1 = hash2 = hash3 = 0 ;
value2 = value ; break; case 0 : hash1 = key == null ? 0 : key . hashCode () ; key1 = key ; value1 = value ; break; } size ++ ; MST[InlineConstantMutator]MSP[N] return null ; } @Override
value2 = value ; break; case 0 : hash1 = key == null ? 0 : key . hashCode () ; key1 = key ; value1 = value ; break; } size ++ ; MST[rv.UOI2Mutator]MSP[S] return null ; } @Override
public int size () { if ( delegateMap != null ) { return delegateMap . size () ; } return size ; } @Override public boolean isEmpty () { return size () == 0 ; MST[rv.CRCR6Mutator]MSP[N] } @Override public boolean containsKey ( final Object key ) {
if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.UOI1Mutator]MSP[S] final V old = value1 ; value1 = value ; return old ; } } } } switch ( size ) { default: convertToMap () ; delegateMap . put ( key , value ) ;
return value3 ; } case 2 : if ( key2 == null ) { return value2 ; } case 1 : if ( key1 == null ) { return value1 ; } } } else { if ( size > 0 ) { MST[rv.ABSMutator]MSP[N]
public void putAll ( final Map < ? extends K , ? extends V > map ) { final int size = map . size () ; if ( size == 0 ) { MST[rv.UOI1Mutator]MSP[S] return; } if ( delegateMap != null ) { delegateMap . putAll ( map ) ;
hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; MST[NullReturnValsMutator]MSP[S] } if ( hash2 == hashCode && key . equals ( key2 ) ) { final V old = value2 ; hash2 = hash3 ; key2 = key3 ;
value2 = value3 ; hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; MST[experimental.MemberVariableMutator]MSP[N] return old ; } if ( hash1 == hashCode && key . equals ( key1 ) ) { final V old = value1 ; hash1 = hash3 ;
return null ; case 2 : hash3 = key == null ? 0 : key . hashCode () ; MST[InlineConstantMutator]MSP[S] key3 = key ; value3 = value ; break; case 1 : hash2 = key == null ? 0 : key . hashCode () ; key2 = key ;
return null ; case 2 : hash3 = key == null ? 0 : key . hashCode () ; key3 = key ; value3 = value ; break; case 1 : hash2 = key == null ? 0 : key . hashCode () ; MST[NonVoidMethodCallMutator]MSP[N] key2 = key ;
final V old = value2 ; hash2 = 0 ; MST[rv.CRCR6Mutator]MSP[S] key2 = null ; value2 = null ; size = 1 ; return old ; } if ( hash1 == hashCode && key . equals ( key1 ) ) { final V old = value1 ; hash1 = hash2 ;
value2 = value ; break; case 0 : hash1 = key == null ? 0 : key . hashCode () ; key1 = key ; value1 = value ; break; } size ++ ; MST[experimental.MemberVariableMutator]MSP[N] return null ; } @Override
return; } if ( size < 4 ) { MST[rv.CRCR5Mutator]MSP[S] for ( final Map . Entry < ? extends K , ? extends V > entry : map . entrySet () ) { put ( entry . getKey () , entry . getValue () ) ; } } else {
if ( delegateMap != null ) { return delegateMap . remove ( key ) ; } if ( size == 0 ) { return null ; } if ( key == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] switch ( size ) { case 3 : if ( key3 == null ) {
final V old = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; return old ; } if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.UOI3Mutator]MSP[N] final V old = value1 ; hash1 = hash2 ;
if ( delegateMap != null ) { return delegateMap . remove ( key ) ; } if ( size == 0 ) { return null ; } if ( key == null ) { switch ( size ) { MST[rv.UOI2Mutator]MSP[N] case 3 : if ( key3 == null ) {
if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[rv.UOI1Mutator]MSP[S] final V old = value3 ; value3 = value ;
value2 = value ; break; case 0 : hash1 = key == null ? 0 : key . hashCode () ; key1 = key ; value1 = value ; break; } size ++ ; MST[rv.AOR2Mutator]MSP[N] return null ; } @Override
delegateMap . put ( key2 , value2 ) ; case 1 : delegateMap . put ( key1 , value1 ) ; case 0 : break; default: throw new IllegalStateException ( lr_1 + size ) ; } size = 0 ; hash1 = hash2 = hash3 = 0 ; MST[InlineConstantMutator]MSP[S]
final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[rv.ABSMutator]MSP[N] return value3 ; } case 2 :
final V old = value3 ; hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; MST[experimental.MemberVariableMutator]MSP[N] return old ; } if ( key2 == null ) { final V old = value2 ; hash2 = hash3 ; key2 = key3 ;
public int size () { if ( delegateMap != null ) { return delegateMap . size () ; MST[NonVoidMethodCallMutator]MSP[N] } return size ; } @Override public boolean isEmpty () { return size () == 0 ; } @Override public boolean containsKey ( final Object key ) {
value2 = value3 ; hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; MST[rv.CRCR3Mutator]MSP[N] return old ; } if ( hash1 == hashCode && key . equals ( key1 ) ) { final V old = value1 ; hash1 = hash3 ;
return; } if ( size < 4 ) { MST[rv.UOI3Mutator]MSP[S] for ( final Map . Entry < ? extends K , ? extends V > entry : map . entrySet () ) { put ( entry . getKey () , entry . getValue () ) ; } } else {
hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.UOI2Mutator]MSP[S] final V old = value2 ; hash2 = hash3 ; key2 = key3 ;
buf . append ( value2 == this ? lr_9 : value2 ) ; buf . append ( ',' ) ; MST[rv.CRCR2Mutator]MSP[N] case 1 : buf . append ( key1 == this ? lr_9 : key1 ) ; buf . append ( '=' ) ;
if ( hash1 == hashCode && key . equals ( key1 ) ) { return true ; MST[BooleanFalseReturnValsMutator]MSP[N] } } } } return false ; } @Override public boolean containsValue ( final Object value ) { if ( delegateMap != null ) { return delegateMap . containsValue ( value ) ;
hash3 = 0 ; key3 = null ; value3 = null ; MST[experimental.MemberVariableMutator]MSP[S] size = 2 ; return old ; } if ( hash2 == hashCode && key . equals ( key2 ) ) { final V old = value2 ; hash2 = hash3 ; key2 = key3 ;
if ( delegateMap != null ) { MST[rv.ROR5Mutator]MSP[N] return delegateMap . containsKey ( key ) ; } if ( key == null ) { switch ( size ) { case 3 : if ( key3 == null ) { return true ; } case 2 :
if ( delegateMap != null ) { return delegateMap . containsKey ( key ) ; } if ( key == null ) { switch ( size ) { case 3 : if ( key3 == null ) { return true ; MST[rv.CRCR2Mutator]MSP[N] } case 2 :
buf . append ( value1 == this ? lr_9 : value1 ) ; break; default: throw new IllegalStateException ( lr_1 + size ) ; } buf . append ( '}' ) ; MST[rv.CRCR3Mutator]MSP[N] return buf . toString () ; }
if ( hash2 == hashCode && key . equals ( key2 ) ) { return value2 ; } case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.ROR3Mutator]MSP[N] return value1 ; } } } } return null ; } @Override
public int size () { if ( delegateMap != null ) { return delegateMap . size () ; } return size ; } @Override public boolean isEmpty () { return size () == 0 ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } @Override public boolean containsKey ( final Object key ) {
if ( key2 == null ) { return true ; } case 1 : if ( key1 == null ) { return true ; MST[rv.CRCR3Mutator]MSP[S] } } } else { if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) {
return true ; } case 1 : if ( value . equals ( value1 ) ) { MST[rv.ROR1Mutator]MSP[N] return true ; } } } return false ; } @Override public V put ( final K key , final V value ) { if ( delegateMap != null ) {
if ( hash1 == hashCode && key . equals ( key1 ) ) { return true ; MST[rv.CRCR4Mutator]MSP[S] } } } } return false ; } @Override public boolean containsValue ( final Object value ) { if ( delegateMap != null ) { return delegateMap . containsValue ( value ) ;
if ( delegateMap != null ) { return delegateMap . hashCode () ; } int total = 0 ; switch ( size ) { case 3 : total += hash3 ^ ( value3 == null ? 0 : value3 . hashCode () ) ; MST[rv.CRCR6Mutator]MSP[S] case 2 :
if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.ROR3Mutator]MSP[N] return value2 ; } case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { return value1 ; } } } } return null ; } @Override
final V old = value1 ; hash1 = 0 ; key1 = null ; value1 = null ; size = 0 ; return old ; } } } } return null ; MST[ReturnValsMutator]MSP[S] } @Override public void clear () { if ( delegateMap != null ) {
key1 = key2 = key3 = null ; value1 = value2 = value3 = null ; } protected AbstractHashedMap < K , V > createDelegateMap () { return new HashedMap <> () ; MST[NullReturnValsMutator]MSP[S] } @Override public V remove ( final Object key ) {
final V old = value3 ; hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; MST[rv.CRCR3Mutator]MSP[N] return old ; } if ( key2 == null ) { final V old = value2 ; hash2 = hash3 ; key2 = key3 ;
return value3 ; MST[ReturnValsMutator]MSP[S] } case 2 : if ( key2 == null ) { return value2 ; } case 1 : if ( key1 == null ) { return value1 ; } } } else { if ( size > 0 ) {
if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[NegateConditionalsMutator]MSP[S] final V old = value1 ; value1 = value ; return old ; } } } } switch ( size ) { default: convertToMap () ; delegateMap . put ( key , value ) ;
final V old = value1 ; hash1 = 0 ; MST[InlineConstantMutator]MSP[S] key1 = null ; value1 = null ; size = 0 ; return old ; } } } } return null ; } @Override public void clear () { if ( delegateMap != null ) {
hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[NegateConditionalsMutator]MSP[N] final V old = value2 ; hash2 = hash3 ; key2 = key3 ;
@Override public V get ( final Object key ) { if ( delegateMap != null ) { return delegateMap . get ( key ) ; } if ( key == null ) { switch ( size ) { MST[rv.UOI2Mutator]MSP[N] case 3 : if ( key3 == null ) {
delegateMap . clear () ; delegateMap = null ; } else { size = 0 ; hash1 = hash2 = hash3 = 0 ; key1 = key2 = key3 = null ; MST[experimental.MemberVariableMutator]MSP[S] value1 = value2 = value3 = null ; } } @Override
if ( key2 == null ) { return true ; } case 1 : if ( key1 == null ) { return true ; } } } else { if ( size > 0 ) { MST[rv.ROR4Mutator]MSP[S] final int hashCode = key . hashCode () ; switch ( size ) {
buf . append ( value3 == this ? lr_9 : value3 ) ; buf . append ( ',' ) ; case 2 : buf . append ( key2 == this ? lr_9 : key2 ) ; buf . append ( '=' ) ; MST[experimental.NakedReceiverMutator]MSP[N]
if ( size != other . size () ) { MST[rv.ABSMutator]MSP[S] return false ; } if ( size > 0 ) { Object otherValue = null ; switch ( size ) { case 3 : if ( other . containsKey ( key3 ) == false ) { return false ; }
value2 = null ; size = 1 ; MST[rv.CRCR2Mutator]MSP[S] return old ; } if ( key1 == null ) { final V old = value1 ; hash1 = hash2 ; key1 = key2 ; value1 = value2 ; hash2 = 0 ; key2 = null ; value2 = null ;
case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[rv.UOI3Mutator]MSP[S] return true ; } case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { return true ; } case 1 :
key1 = key2 ; value1 = value2 ; hash2 = 0 ; MST[rv.CRCR3Mutator]MSP[S] key2 = null ; value2 = null ; size = 1 ; return old ; } return null ; case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) {
if ( hash1 == hashCode && key . equals ( key1 ) ) { return true ; } } } } return false ; MST[InlineConstantMutator]MSP[N] } @Override public boolean containsValue ( final Object value ) { if ( delegateMap != null ) { return delegateMap . containsValue ( value ) ;
public int size () { if ( delegateMap != null ) { return delegateMap . size () ; } return size ; } @Override public boolean isEmpty () { return size () == 0 ; MST[ReturnValsMutator]MSP[N] } @Override public boolean containsKey ( final Object key ) {
final V old = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; return old ; } if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.ROR4Mutator]MSP[N] final V old = value1 ; hash1 = hash2 ;
@Override public V get ( final Object key ) { if ( delegateMap != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] return delegateMap . get ( key ) ; } if ( key == null ) { switch ( size ) { case 3 : if ( key3 == null ) {
final V old = value3 ; hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; MST[rv.CRCR6Mutator]MSP[N] return old ; } if ( key2 == null ) { final V old = value2 ; hash2 = hash3 ; key2 = key3 ;
return false ; } otherValue = other . get ( key1 ) ; if ( value1 == null ? otherValue != null : ! value1 . equals ( otherValue ) ) { return false ; } } } return true ; MST[rv.CRCR6Mutator]MSP[N] } @Override public int hashCode () {
} else { if ( size > 0 ) { MST[rv.ROR1Mutator]MSP[S] final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { final V old = value3 ;
final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return value3 ; } case 2 :
total += hash2 ^ ( value2 == null ? 0 : value2 . hashCode () ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] case 1 : total += hash1 ^ ( value1 == null ? 0 : value1 . hashCode () ) ; case 0 : break; default:
final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[rv.ROR3Mutator]MSP[N] return value3 ; } case 2 :
} else { if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[rv.UOI4Mutator]MSP[N] final V old = value3 ;
key1 = key2 ; value1 = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; return old ; } return null ; MST[ReturnValsMutator]MSP[S] case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) {
buf . append ( value2 == this ? lr_9 : value2 ) ; MST[experimental.NakedReceiverMutator]MSP[S] buf . append ( ',' ) ; case 1 : buf . append ( key1 == this ? lr_9 : key1 ) ; buf . append ( '=' ) ;
} if ( value == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] switch ( size ) { case 3 : if ( value3 == null ) { return true ; } case 2 : if ( value2 == null ) { return true ; } case 1 :
final StringBuilder buf = new StringBuilder ( 128 ) ; buf . append ( '{' ) ; switch ( size ) { case 3 : buf . append ( key3 == this ? lr_9 : key3 ) ; buf . append ( '=' ) ; MST[InlineConstantMutator]MSP[S]
size = 1 ; return old ; } return null ; case 1 : if ( key1 == null ) { final V old = value1 ; hash1 = 0 ; MST[rv.CRCR1Mutator]MSP[S] key1 = null ; value1 = null ; size = 0 ; return old ; } }
if ( key2 == null ) { final V old = value2 ; value2 = value ; return old ; } case 1 : if ( key1 == null ) { final V old = value1 ; value1 = value ; MST[experimental.MemberVariableMutator]MSP[S] return old ; } } } else {
if ( key2 == null ) { return true ; } case 1 : if ( key1 == null ) { return true ; } } } else { if ( size > 0 ) { MST[rv.UOI3Mutator]MSP[S] final int hashCode = key . hashCode () ; switch ( size ) {
hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.ABSMutator]MSP[N] final V old = value2 ; hash2 = hash3 ; key2 = key3 ;
buf . append ( value1 == this ? lr_9 : value1 ) ; MST[rv.ROR5Mutator]MSP[N] break; default: throw new IllegalStateException ( lr_1 + size ) ; } buf . append ( '}' ) ; return buf . toString () ; }
value2 = value3 ; hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } if ( key1 == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] final V old = value1 ; hash1 = hash3 ; key1 = key3 ; value1 = value3 ;
total += hash2 ^ ( value2 == null ? 0 : value2 . hashCode () ) ; MST[rv.AOR3Mutator]MSP[S] case 1 : total += hash1 ^ ( value1 == null ? 0 : value1 . hashCode () ) ; case 0 : break; default:
case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[rv.ROR4Mutator]MSP[S] return true ; } case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { return true ; } case 1 :
buf . append ( value2 == this ? lr_9 : value2 ) ; buf . append ( ',' ) ; case 1 : buf . append ( key1 == this ? lr_9 : key1 ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] buf . append ( '=' ) ;
key1 = key3 ; value1 = value3 ; hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } return null ; case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
} else { if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[rv.ROR1Mutator]MSP[S] final V old = value3 ;
total += hash2 ^ ( value2 == null ? 0 : value2 . hashCode () ) ; case 1 : total += hash1 ^ ( value1 == null ? 0 : value1 . hashCode () ) ; MST[rv.CRCR6Mutator]MSP[S] case 0 : break; default:
key1 = key2 ; value1 = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; return old ; } return null ; case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.ROR4Mutator]MSP[N]
public MapIterator < K , V > mapIterator () { if ( delegateMap != null ) { return delegateMap . mapIterator () ; } if ( size == 0 ) { MST[rv.UOI4Mutator]MSP[N] return EmptyMapIterator . <K , V > emptyMapIterator () ; } return new FlatMapIterator <> ( this ) ;
@Override public V get ( final Object key ) { if ( delegateMap != null ) { return delegateMap . get ( key ) ; } if ( key == null ) { switch ( size ) { MST[experimental.RemoveSwitchMutator_2]MSP[S] case 3 : if ( key3 == null ) {
@Override public V get ( final Object key ) { if ( delegateMap != null ) { return delegateMap . get ( key ) ; } if ( key == null ) { switch ( size ) { MST[experimental.RemoveSwitchMutator_0]MSP[S] case 3 : if ( key3 == null ) {
public MapIterator < K , V > mapIterator () { if ( delegateMap != null ) { return delegateMap . mapIterator () ; } if ( size == 0 ) { MST[rv.ROR5Mutator]MSP[S] return EmptyMapIterator . <K , V > emptyMapIterator () ; } return new FlatMapIterator <> ( this ) ;
buf . append ( value3 == this ? lr_9 : value3 ) ; buf . append ( ',' ) ; case 2 : buf . append ( key2 == this ? lr_9 : key2 ) ; buf . append ( '=' ) ; MST[rv.CRCR6Mutator]MSP[N]
@Override public V get ( final Object key ) { if ( delegateMap != null ) { return delegateMap . get ( key ) ; } if ( key == null ) { switch ( size ) { MST[experimental.RemoveSwitchMutator_1]MSP[S] case 3 : if ( key3 == null ) {
if ( value1 == null ) { return true ; } } } else { switch ( size ) { case 3 : if ( value . equals ( value3 ) ) { return true ; } case 2 : if ( value . equals ( value2 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
final StringBuilder buf = new StringBuilder ( 128 ) ; buf . append ( '{' ) ; switch ( size ) { case 3 : buf . append ( key3 == this ? lr_9 : key3 ) ; buf . append ( '=' ) ; MST[experimental.NakedReceiverMutator]MSP[S]
buf . append ( value1 == this ? lr_9 : value1 ) ; MST[NegateConditionalsMutator]MSP[N] break; default: throw new IllegalStateException ( lr_1 + size ) ; } buf . append ( '}' ) ; return buf . toString () ; }
total += hash2 ^ ( value2 == null ? 0 : value2 . hashCode () ) ; case 1 : total += hash1 ^ ( value1 == null ? 0 : value1 . hashCode () ) ; MST[rv.AOR1Mutator]MSP[S] case 0 : break; default:
hash3 = 0 ; MST[rv.CRCR5Mutator]MSP[S] key3 = null ; value3 = null ; size = 2 ; return old ; } return null ; case 2 : if ( key2 == null ) { final V old = value2 ; hash2 = 0 ; key2 = null ;
key1 = key2 ; value1 = value2 ; hash2 = 0 ; MST[InlineConstantMutator]MSP[S] key2 = null ; value2 = null ; size = 1 ; return old ; } return null ; case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) {
public int size () { if ( delegateMap != null ) { return delegateMap . size () ; } return size ; } @Override public boolean isEmpty () { return size () == 0 ; MST[NonVoidMethodCallMutator]MSP[N] } @Override public boolean containsKey ( final Object key ) {
public int size () { if ( delegateMap != null ) { MST[rv.ROR5Mutator]MSP[N] return delegateMap . size () ; } return size ; } @Override public boolean isEmpty () { return size () == 0 ; } @Override public boolean containsKey ( final Object key ) {
if ( size != other . size () ) { MST[rv.ROR4Mutator]MSP[S] return false ; } if ( size > 0 ) { Object otherValue = null ; switch ( size ) { case 3 : if ( other . containsKey ( key3 ) == false ) { return false ; }
buf . append ( value2 == this ? lr_9 : value2 ) ; buf . append ( ',' ) ; case 1 : buf . append ( key1 == this ? lr_9 : key1 ) ; buf . append ( '=' ) ; MST[experimental.NakedReceiverMutator]MSP[N]
if ( hash1 == hashCode && key . equals ( key1 ) ) { final V old = value1 ; value1 = value ; return old ; } } } } switch ( size ) { MST[experimental.SwitchMutator]MSP[N] default: convertToMap () ; delegateMap . put ( key , value ) ;
hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] final V old = value2 ; hash2 = hash3 ; key2 = key3 ;
final int hashCode = key . hashCode () ; switch ( size ) { MST[experimental.SwitchMutator]MSP[N] case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { return value3 ; } case 2 :
total += hash2 ^ ( value2 == null ? 0 : value2 . hashCode () ) ; MST[rv.AOD2Mutator]MSP[S] case 1 : total += hash1 ^ ( value1 == null ? 0 : value1 . hashCode () ) ; case 0 : break; default:
throw new IllegalStateException ( lr_1 + size ) ; } return total ; } @Override public String toString () { if ( delegateMap != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] return delegateMap . toString () ; } if ( size == 0 ) { return lr_8 ; }
return; } if ( size < 4 ) { MST[rv.ROR4Mutator]MSP[S] for ( final Map . Entry < ? extends K , ? extends V > entry : map . entrySet () ) { put ( entry . getKey () , entry . getValue () ) ; } } else {
hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } if ( hash2 == hashCode && key . equals ( key2 ) ) { final V old = value2 ; hash2 = hash3 ; MST[rv.ABSMutator]MSP[S] key2 = key3 ;
if ( value1 == null ) { return true ; } } } else { switch ( size ) { case 3 : if ( value . equals ( value3 ) ) { return true ; } case 2 : if ( value . equals ( value2 ) ) { MST[rv.ROR4Mutator]MSP[N]
buf . append ( value1 == this ? lr_9 : value1 ) ; MST[experimental.NakedReceiverMutator]MSP[S] break; default: throw new IllegalStateException ( lr_1 + size ) ; } buf . append ( '}' ) ; return buf . toString () ; }
hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.ROR5Mutator]MSP[N] final V old = value2 ; hash2 = hash3 ; key2 = key3 ;
return lr_2 + getKey () + lr_3 + getValue () + lr_4 ; } return lr_5 ; } @Override public Set < Map . Entry < K , V > > entrySet () { if ( delegateMap != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] return delegateMap . entrySet () ; }
delegateMap . put ( key2 , value2 ) ; case 1 : delegateMap . put ( key1 , value1 ) ; case 0 : break; default: throw new IllegalStateException ( lr_1 + size ) ; } size = 0 ; hash1 = hash2 = hash3 = 0 ; MST[rv.CRCR1Mutator]MSP[S]
throw new IllegalStateException ( lr_1 + size ) ; } return total ; } @Override public String toString () { if ( delegateMap != null ) { return delegateMap . toString () ; } if ( size == 0 ) { MST[rv.ROR4Mutator]MSP[S] return lr_8 ; }
return old ; } case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[NegateConditionalsMutator]MSP[N] final V old = value2 ; value2 = value ; return old ; } case 1 :
if ( value1 == null ) { return true ; } } } else { switch ( size ) { case 3 : if ( value . equals ( value3 ) ) { return true ; } case 2 : if ( value . equals ( value2 ) ) { MST[rv.ROR1Mutator]MSP[N]
buf . append ( value2 == this ? lr_9 : value2 ) ; MST[rv.ROR5Mutator]MSP[N] buf . append ( ',' ) ; case 1 : buf . append ( key1 == this ? lr_9 : key1 ) ; buf . append ( '=' ) ;
if ( delegateMap != null ) { return delegateMap . containsKey ( key ) ; } if ( key == null ) { MST[rv.ROR5Mutator]MSP[N] switch ( size ) { case 3 : if ( key3 == null ) { return true ; } case 2 :
case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { return true ; } case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.ABSMutator]MSP[S] return true ; } case 1 :
buf . append ( value2 == this ? lr_9 : value2 ) ; buf . append ( ',' ) ; case 1 : buf . append ( key1 == this ? lr_9 : key1 ) ; buf . append ( '=' ) ; MST[rv.CRCR6Mutator]MSP[N]
public MapIterator < K , V > mapIterator () { if ( delegateMap != null ) { return delegateMap . mapIterator () ; } if ( size == 0 ) { return EmptyMapIterator . <K , V > emptyMapIterator () ; MST[NullReturnValsMutator]MSP[S] } return new FlatMapIterator <> ( this ) ;
if ( delegateMap != null ) { MST[rv.ROR5Mutator]MSP[S] return delegateMap . hashCode () ; } int total = 0 ; switch ( size ) { case 3 : total += hash3 ^ ( value3 == null ? 0 : value3 . hashCode () ) ; case 2 :
case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[rv.ROR1Mutator]MSP[S] return true ; } case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { return true ; } case 1 :
final V old = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; MST[rv.CRCR4Mutator]MSP[N] return old ; } if ( hash1 == hashCode && key . equals ( key1 ) ) { final V old = value1 ; hash1 = hash2 ;
return old ; } case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.UOI2Mutator]MSP[N] final V old = value2 ; value2 = value ; return old ; } case 1 :
buf . append ( value3 == this ? lr_9 : value3 ) ; buf . append ( ',' ) ; case 2 : buf . append ( key2 == this ? lr_9 : key2 ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] buf . append ( '=' ) ;
} else { if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { MST[rv.ABSMutator]MSP[N] case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { final V old = value3 ;
final V old = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; return old ; MST[ReturnValsMutator]MSP[S] } if ( hash1 == hashCode && key . equals ( key1 ) ) { final V old = value1 ; hash1 = hash2 ;
if ( hash1 == hashCode && key . equals ( key1 ) ) { return true ; } } } } return false ; } @Override public boolean containsValue ( final Object value ) { if ( delegateMap != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] return delegateMap . containsValue ( value ) ;
if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.ROR5Mutator]MSP[N] return true ; } } } } return false ; } @Override public boolean containsValue ( final Object value ) { if ( delegateMap != null ) { return delegateMap . containsValue ( value ) ;
if ( delegateMap != null ) { return delegateMap . containsKey ( key ) ; } if ( key == null ) { switch ( size ) { case 3 : if ( key3 == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return true ; } case 2 :
if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.ABSMutator]MSP[N] return true ; } } } } return false ; } @Override public boolean containsValue ( final Object value ) { if ( delegateMap != null ) { return delegateMap . containsValue ( value ) ;
@Override public V get ( final Object key ) { if ( delegateMap != null ) { return delegateMap . get ( key ) ; } if ( key == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] switch ( size ) { case 3 : if ( key3 == null ) {
key1 = key3 ; value1 = value3 ; hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } return null ; case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.ROR2Mutator]MSP[S]
} else { if ( size > 0 ) { MST[rv.UOI3Mutator]MSP[N] final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { final V old = value3 ;
} else { if ( size > 0 ) { MST[rv.UOI1Mutator]MSP[N] final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { final V old = value3 ;
key1 = key2 ; value1 = value2 ; hash2 = 0 ; MST[rv.CRCR6Mutator]MSP[S] key2 = null ; value2 = null ; size = 1 ; return old ; } return null ; case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) {
final V old = value1 ; hash1 = 0 ; key1 = null ; value1 = null ; size = 0 ; MST[rv.CRCR5Mutator]MSP[N] return old ; } } } } return null ; } @Override public void clear () { if ( delegateMap != null ) {
if ( delegateMap != null ) { return delegateMap . hashCode () ; } int total = 0 ; switch ( size ) { case 3 : total += hash3 ^ ( value3 == null ? 0 : value3 . hashCode () ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] case 2 :
return true ; } case 1 : if ( value . equals ( value1 ) ) { MST[NegateConditionalsMutator]MSP[N] return true ; } } } return false ; } @Override public V put ( final K key , final V value ) { if ( delegateMap != null ) {
return null ; case 2 : hash3 = key == null ? 0 : key . hashCode () ; MST[rv.CRCR1Mutator]MSP[S] key3 = key ; value3 = value ; break; case 1 : hash2 = key == null ? 0 : key . hashCode () ; key2 = key ;
public int size () { if ( delegateMap != null ) { return delegateMap . size () ; } return size ; } @Override public boolean isEmpty () { return size () == 0 ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } @Override public boolean containsKey ( final Object key ) {
buf . append ( value3 == this ? lr_9 : value3 ) ; buf . append ( ',' ) ; case 2 : buf . append ( key2 == this ? lr_9 : key2 ) ; buf . append ( '=' ) ; MST[rv.CRCR3Mutator]MSP[N]
return true ; } case 1 : if ( value . equals ( value1 ) ) { return true ; } } } return false ; MST[rv.CRCR6Mutator]MSP[N] } @Override public V put ( final K key , final V value ) { if ( delegateMap != null ) {
case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { return true ; } case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.ROR5Mutator]MSP[S] return true ; } case 1 :
if ( size != other . size () ) { return false ; } if ( size > 0 ) { MST[rv.ROR3Mutator]MSP[S] Object otherValue = null ; switch ( size ) { case 3 : if ( other . containsKey ( key3 ) == false ) { return false ; }
if ( hash2 == hashCode && key . equals ( key2 ) ) { return value2 ; } case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] return value1 ; } } } } return null ; } @Override
} if ( value == null ) { switch ( size ) { MST[experimental.RemoveSwitchMutator_2]MSP[S] case 3 : if ( value3 == null ) { return true ; } case 2 : if ( value2 == null ) { return true ; } case 1 :
value2 = null ; size = 1 ; MST[rv.CRCR5Mutator]MSP[S] return old ; } if ( key1 == null ) { final V old = value1 ; hash1 = hash2 ; key1 = key2 ; value1 = value2 ; hash2 = 0 ; key2 = null ; value2 = null ;
if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[rv.ABSMutator]MSP[S] final V old = value3 ; value3 = value ;
if ( delegateMap != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] return delegateMap . hashCode () ; } int total = 0 ; switch ( size ) { case 3 : total += hash3 ^ ( value3 == null ? 0 : value3 . hashCode () ) ; case 2 :
} if ( value == null ) { switch ( size ) { MST[experimental.RemoveSwitchMutator_0]MSP[N] case 3 : if ( value3 == null ) { return true ; } case 2 : if ( value2 == null ) { return true ; } case 1 :
} else { if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[rv.UOI1Mutator]MSP[N] final V old = value3 ;
} else { if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[rv.UOI3Mutator]MSP[N] final V old = value3 ;
} if ( value == null ) { switch ( size ) { MST[experimental.RemoveSwitchMutator_1]MSP[S] case 3 : if ( value3 == null ) { return true ; } case 2 : if ( value2 == null ) { return true ; } case 1 :
value2 = null ; size = 1 ; return old ; MST[NullReturnValsMutator]MSP[S] } if ( key1 == null ) { final V old = value1 ; hash1 = hash2 ; key1 = key2 ; value1 = value2 ; hash2 = 0 ; key2 = null ; value2 = null ;
return delegateMap . put ( key , value ) ; } if ( key == null ) { switch ( size ) { case 3 : if ( key3 == null ) { MST[rv.ROR5Mutator]MSP[S] final V old = value3 ; value3 = value ; return old ; } case 2 :
if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[NegateConditionalsMutator]MSP[N] final V old = value1 ; value1 = value ; return old ; } } } } switch ( size ) { default: convertToMap () ; delegateMap . put ( key , value ) ;
if ( value1 == null ) { return true ; } } } else { switch ( size ) { case 3 : if ( value . equals ( value3 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] return true ; } case 2 : if ( value . equals ( value2 ) ) {
if ( delegateMap != null ) { return delegateMap . remove ( key ) ; } if ( size == 0 ) { MST[rv.ROR3Mutator]MSP[S] return null ; } if ( key == null ) { switch ( size ) { case 3 : if ( key3 == null ) {
final V old = value1 ; hash1 = 0 ; key1 = null ; value1 = null ; MST[experimental.MemberVariableMutator]MSP[S] size = 0 ; return old ; } } } } return null ; } @Override public void clear () { if ( delegateMap != null ) {
if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.ROR2Mutator]MSP[S] return true ; } } } } return false ; } @Override public boolean containsValue ( final Object value ) { if ( delegateMap != null ) { return delegateMap . containsValue ( value ) ;
} if ( delegateMap != null ) { return delegateMap . equals ( obj ) ; } if ( obj instanceof Map == false ) { MST[rv.ROR4Mutator]MSP[S] return false ; } final Map < ? , ? > other = ( Map < ? , ? > ) obj ;
if ( delegateMap != null ) { return delegateMap . hashCode () ; } int total = 0 ; switch ( size ) { MST[experimental.SwitchMutator]MSP[S] case 3 : total += hash3 ^ ( value3 == null ? 0 : value3 . hashCode () ) ; case 2 :
buf . append ( value3 == this ? lr_9 : value3 ) ; buf . append ( ',' ) ; MST[rv.CRCR5Mutator]MSP[S] case 2 : buf . append ( key2 == this ? lr_9 : key2 ) ; buf . append ( '=' ) ;
size = 1 ; return old ; } return null ; case 1 : if ( key1 == null ) { final V old = value1 ; hash1 = 0 ; key1 = null ; value1 = null ; size = 0 ; MST[experimental.MemberVariableMutator]MSP[S] return old ; } }
throw new IllegalStateException ( lr_1 + size ) ; } return total ; } @Override public String toString () { if ( delegateMap != null ) { return delegateMap . toString () ; } if ( size == 0 ) { MST[rv.ROR1Mutator]MSP[N] return lr_8 ; }
final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] return value3 ; } case 2 :
if ( key2 == null ) { final V old = value2 ; value2 = value ; return old ; MST[NullReturnValsMutator]MSP[S] } case 1 : if ( key1 == null ) { final V old = value1 ; value1 = value ; return old ; } } } else {
if ( delegateMap != null ) { return delegateMap . containsKey ( key ) ; } if ( key == null ) { switch ( size ) { case 3 : if ( key3 == null ) { return true ; MST[rv.CRCR5Mutator]MSP[N] } case 2 :
buf . append ( value2 == this ? lr_9 : value2 ) ; buf . append ( ',' ) ; case 1 : buf . append ( key1 == this ? lr_9 : key1 ) ; buf . append ( '=' ) ; MST[InlineConstantMutator]MSP[N]
final V old = value1 ; hash1 = 0 ; key1 = null ; value1 = null ; size = 0 ; return old ; MST[NullReturnValsMutator]MSP[S] } } } } return null ; } @Override public void clear () { if ( delegateMap != null ) {
buf . append ( value2 == this ? lr_9 : value2 ) ; buf . append ( ',' ) ; case 1 : buf . append ( key1 == this ? lr_9 : key1 ) ; buf . append ( '=' ) ; MST[rv.CRCR3Mutator]MSP[N]
return value3 ; } case 2 : if ( key2 == null ) { return value2 ; } case 1 : if ( key1 == null ) { return value1 ; MST[ReturnValsMutator]MSP[S] } } } else { if ( size > 0 ) {
if ( size != other . size () ) { MST[rv.UOI1Mutator]MSP[N] return false ; } if ( size > 0 ) { Object otherValue = null ; switch ( size ) { case 3 : if ( other . containsKey ( key3 ) == false ) { return false ; }
if ( value1 == null ) { return true ; } } } else { switch ( size ) { case 3 : if ( value . equals ( value3 ) ) { return true ; } case 2 : if ( value . equals ( value2 ) ) { MST[NonVoidMethodCallMutator]MSP[N]
if ( hash1 == hashCode && key . equals ( key1 ) ) { final V old = value1 ; value1 = value ; return old ; } } } } switch ( size ) { MST[rv.UOI1Mutator]MSP[N] default: convertToMap () ; delegateMap . put ( key , value ) ;
if ( delegateMap != null ) { return delegateMap . hashCode () ; } int total = 0 ; switch ( size ) { case 3 : total += hash3 ^ ( value3 == null ? 0 : value3 . hashCode () ) ; MST[rv.UOI1Mutator]MSP[S] case 2 :
case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { return true ; } case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[NegateConditionalsMutator]MSP[S] return true ; } case 1 :
value2 = null ; MST[experimental.MemberVariableMutator]MSP[S] size = 1 ; return old ; } if ( key1 == null ) { final V old = value1 ; hash1 = hash2 ; key1 = key2 ; value1 = value2 ; hash2 = 0 ; key2 = null ; value2 = null ;
if ( delegateMap != null ) { return delegateMap . containsKey ( key ) ; MST[BooleanFalseReturnValsMutator]MSP[N] } if ( key == null ) { switch ( size ) { case 3 : if ( key3 == null ) { return true ; } case 2 :
return true ; MST[rv.CRCR6Mutator]MSP[N] } case 1 : if ( value . equals ( value1 ) ) { return true ; } } } return false ; } @Override public V put ( final K key , final V value ) { if ( delegateMap != null ) {
delegateMap . clear () ; delegateMap = null ; } else { size = 0 ; MST[experimental.MemberVariableMutator]MSP[S] hash1 = hash2 = hash3 = 0 ; key1 = key2 = key3 = null ; value1 = value2 = value3 = null ; } } @Override
final StringBuilder buf = new StringBuilder ( 128 ) ; buf . append ( '{' ) ; switch ( size ) { case 3 : buf . append ( key3 == this ? lr_9 : key3 ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] buf . append ( '=' ) ;
if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.ROR2Mutator]MSP[S] final V old = value1 ; value1 = value ; return old ; } } } } switch ( size ) { default: convertToMap () ; delegateMap . put ( key , value ) ;
if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] return value2 ; } case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { return value1 ; } } } } return null ; } @Override
if ( size > 0 ) { MST[rv.ABSMutator]MSP[S] final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { final V old = value3 ; value3 = value ;
if ( delegateMap != null ) { return delegateMap . remove ( key ) ; } if ( size == 0 ) { return null ; } if ( key == null ) { switch ( size ) { MST[experimental.RemoveSwitchMutator_2]MSP[N] case 3 : if ( key3 == null ) {
total += hash2 ^ ( value2 == null ? 0 : value2 . hashCode () ) ; case 1 : total += hash1 ^ ( value1 == null ? 0 : value1 . hashCode () ) ; MST[rv.AOR3Mutator]MSP[S] case 0 : break; default:
return delegateMap . put ( key , value ) ; } if ( key == null ) { switch ( size ) { MST[rv.UOI2Mutator]MSP[N] case 3 : if ( key3 == null ) { final V old = value3 ; value3 = value ; return old ; } case 2 :
return value3 ; } case 2 : if ( key2 == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] return value2 ; } case 1 : if ( key1 == null ) { return value1 ; } } } else { if ( size > 0 ) {
key1 = key2 = key3 = null ; value1 = value2 = value3 = null ; MST[experimental.MemberVariableMutator]MSP[S] } protected AbstractHashedMap < K , V > createDelegateMap () { return new HashedMap <> () ; } @Override public V remove ( final Object key ) {
if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.UOI4Mutator]MSP[S] final V old = value1 ; value1 = value ; return old ; } } } } switch ( size ) { default: convertToMap () ; delegateMap . put ( key , value ) ;
public int size () { if ( delegateMap != null ) { return delegateMap . size () ; } return size ; } @Override public boolean isEmpty () { return size () == 0 ; MST[rv.CRCR2Mutator]MSP[N] } @Override public boolean containsKey ( final Object key ) {
if ( delegateMap != null ) { return delegateMap . hashCode () ; } int total = 0 ; switch ( size ) { case 3 : total += hash3 ^ ( value3 == null ? 0 : value3 . hashCode () ) ; MST[rv.AOD2Mutator]MSP[S] case 2 :
return old ; } case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.ROR5Mutator]MSP[N] final V old = value2 ; value2 = value ; return old ; } case 1 :
hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.ROR2Mutator]MSP[N] final V old = value2 ; hash2 = hash3 ; key2 = key3 ;
value2 = value3 ; hash3 = 0 ; MST[rv.CRCR1Mutator]MSP[S] key3 = null ; value3 = null ; size = 2 ; return old ; } if ( hash1 == hashCode && key . equals ( key1 ) ) { final V old = value1 ; hash1 = hash3 ;
if ( hash2 == hashCode && key . equals ( key2 ) ) { return value2 ; } case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return value1 ; } } } } return null ; } @Override
return; } if ( size < 4 ) { for ( final Map . Entry < ? extends K , ? extends V > entry : map . entrySet () ) { put ( entry . getKey () , entry . getValue () ) ; MST[ArgumentPropagationMutator]MSP[N] } } else {
if ( delegateMap != null ) { return delegateMap . containsKey ( key ) ; MST[NonVoidMethodCallMutator]MSP[N] } if ( key == null ) { switch ( size ) { case 3 : if ( key3 == null ) { return true ; } case 2 :
if ( value1 == null ) { return true ; MST[rv.CRCR5Mutator]MSP[N] } } } else { switch ( size ) { case 3 : if ( value . equals ( value3 ) ) { return true ; } case 2 : if ( value . equals ( value2 ) ) {
public MapIterator < K , V > mapIterator () { if ( delegateMap != null ) { return delegateMap . mapIterator () ; } if ( size == 0 ) { MST[NegateConditionalsMutator]MSP[S] return EmptyMapIterator . <K , V > emptyMapIterator () ; } return new FlatMapIterator <> ( this ) ;
if ( delegateMap != null ) { return delegateMap . hashCode () ; } int total = 0 ; switch ( size ) { MST[rv.ABSMutator]MSP[S] case 3 : total += hash3 ^ ( value3 == null ? 0 : value3 . hashCode () ) ; case 2 :
value2 = value ; break; case 0 : hash1 = key == null ? 0 : key . hashCode () ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] key1 = key ; value1 = value ; break; } size ++ ; return null ; } @Override
return true ; } case 1 : if ( value . equals ( value1 ) ) { return true ; } } } return false ; } @Override public V put ( final K key , final V value ) { if ( delegateMap != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S]
convertToMap () ; MST[VoidMethodCallMutator]MSP[S] delegateMap . putAll ( map ) ; } } private void convertToMap () { delegateMap = createDelegateMap () ; switch ( size ) { case 3 : delegateMap . put ( key3 , value3 ) ; case 2 :
delegateMap . put ( key2 , value2 ) ; case 1 : delegateMap . put ( key1 , value1 ) ; MST[ArgumentPropagationMutator]MSP[N] case 0 : break; default: throw new IllegalStateException ( lr_1 + size ) ; } size = 0 ; hash1 = hash2 = hash3 = 0 ;
if ( hash1 == hashCode && key . equals ( key1 ) ) { return true ; } } } } return false ; MST[rv.CRCR3Mutator]MSP[N] } @Override public boolean containsValue ( final Object value ) { if ( delegateMap != null ) { return delegateMap . containsValue ( value ) ;
key1 = key2 ; value1 = value2 ; hash2 = 0 ; key2 = null ; MST[experimental.MemberVariableMutator]MSP[S] value2 = null ; size = 1 ; return old ; } return null ; case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) {
final StringBuilder buf = new StringBuilder ( 128 ) ; buf . append ( '{' ) ; switch ( size ) { case 3 : buf . append ( key3 == this ? lr_9 : key3 ) ; buf . append ( '=' ) ; MST[rv.CRCR3Mutator]MSP[S]
total += hash2 ^ ( value2 == null ? 0 : value2 . hashCode () ) ; MST[rv.UOI3Mutator]MSP[S] case 1 : total += hash1 ^ ( value1 == null ? 0 : value1 . hashCode () ) ; case 0 : break; default:
hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; MST[rv.CRCR2Mutator]MSP[N] return old ; } if ( hash2 == hashCode && key . equals ( key2 ) ) { final V old = value2 ; hash2 = hash3 ; key2 = key3 ;
final V old = value3 ; hash3 = 0 ; MST[rv.CRCR1Mutator]MSP[S] key3 = null ; value3 = null ; size = 2 ; return old ; } if ( key2 == null ) { final V old = value2 ; hash2 = hash3 ; key2 = key3 ;
if ( value1 == null ) { return true ; } } } else { switch ( size ) { MST[rv.UOI2Mutator]MSP[N] case 3 : if ( value . equals ( value3 ) ) { return true ; } case 2 : if ( value . equals ( value2 ) ) {
} else { if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[rv.ROR4Mutator]MSP[N] final V old = value3 ;
value2 = value3 ; hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; MST[rv.CRCR6Mutator]MSP[N] return old ; } if ( hash1 == hashCode && key . equals ( key1 ) ) { final V old = value1 ; hash1 = hash3 ;
if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.ABSMutator]MSP[S] final V old = value1 ; value1 = value ; return old ; } } } } switch ( size ) { default: convertToMap () ; delegateMap . put ( key , value ) ;
if ( delegateMap != null ) { return delegateMap . remove ( key ) ; } if ( size == 0 ) { return null ; } if ( key == null ) { switch ( size ) { MST[experimental.RemoveSwitchMutator_0]MSP[S] case 3 : if ( key3 == null ) {
if ( delegateMap != null ) { return delegateMap . remove ( key ) ; } if ( size == 0 ) { return null ; } if ( key == null ) { switch ( size ) { MST[experimental.RemoveSwitchMutator_1]MSP[S] case 3 : if ( key3 == null ) {
buf . append ( value3 == this ? lr_9 : value3 ) ; buf . append ( ',' ) ; case 2 : buf . append ( key2 == this ? lr_9 : key2 ) ; buf . append ( '=' ) ; MST[InlineConstantMutator]MSP[N]
public void putAll ( final Map < ? extends K , ? extends V > map ) { final int size = map . size () ; if ( size == 0 ) { MST[rv.ABSMutator]MSP[S] return; } if ( delegateMap != null ) { delegateMap . putAll ( map ) ;
if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return value2 ; } case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { return value1 ; } } } } return null ; } @Override
} else { if ( size > 0 ) { MST[rv.ROR4Mutator]MSP[S] final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { final V old = value3 ;
return true ; } case 1 : if ( value . equals ( value1 ) ) { return true ; } } } return false ; MST[ReturnValsMutator]MSP[N] } @Override public V put ( final K key , final V value ) { if ( delegateMap != null ) {
return false ; } otherValue = other . get ( key1 ) ; if ( value1 == null ? otherValue != null : ! value1 . equals ( otherValue ) ) { return false ; } } } return true ; MST[rv.CRCR3Mutator]MSP[S] } @Override public int hashCode () {
total += hash2 ^ ( value2 == null ? 0 : value2 . hashCode () ) ; case 1 : total += hash1 ^ ( value1 == null ? 0 : value1 . hashCode () ) ; MST[rv.ABSMutator]MSP[S] case 0 : break; default:
value2 = value ; break; case 0 : hash1 = key == null ? 0 : key . hashCode () ; key1 = key ; value1 = value ; MST[experimental.MemberVariableMutator]MSP[N] break; } size ++ ; return null ; } @Override
total += hash2 ^ ( value2 == null ? 0 : value2 . hashCode () ) ; MST[rv.AOR1Mutator]MSP[S] case 1 : total += hash1 ^ ( value1 == null ? 0 : value1 . hashCode () ) ; case 0 : break; default:
if ( key2 == null ) { return true ; } case 1 : if ( key1 == null ) { return true ; MST[rv.CRCR6Mutator]MSP[N] } } } else { if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) {
delegateMap . clear () ; delegateMap = null ; } else { size = 0 ; hash1 = hash2 = hash3 = 0 ; MST[rv.CRCR5Mutator]MSP[S] key1 = key2 = key3 = null ; value1 = value2 = value3 = null ; } } @Override
} if ( delegateMap != null ) { return delegateMap . equals ( obj ) ; } if ( obj instanceof Map == false ) { return false ; MST[BooleanTrueReturnValsMutator]MSP[N] } final Map < ? , ? > other = ( Map < ? , ? > ) obj ;
return true ; MST[ReturnValsMutator]MSP[N] } case 1 : if ( value . equals ( value1 ) ) { return true ; } } } return false ; } @Override public V put ( final K key , final V value ) { if ( delegateMap != null ) {
if ( key2 == null ) { final V old = value2 ; value2 = value ; return old ; } case 1 : if ( key1 == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] final V old = value1 ; value1 = value ; return old ; } } } else {
if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[rv.ROR2Mutator]MSP[S] final V old = value3 ; value3 = value ;
return; } if ( size < 4 ) { MST[rv.CRCR2Mutator]MSP[N] for ( final Map . Entry < ? extends K , ? extends V > entry : map . entrySet () ) { put ( entry . getKey () , entry . getValue () ) ; } } else {
return old ; } case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.UOI1Mutator]MSP[S] final V old = value2 ; value2 = value ; return old ; } case 1 :
throw new IllegalStateException ( lr_1 + size ) ; } return total ; } @Override public String toString () { if ( delegateMap != null ) { return delegateMap . toString () ; } if ( size == 0 ) { MST[rv.UOI3Mutator]MSP[N] return lr_8 ; }
if ( size != other . size () ) { return false ; MST[BooleanTrueReturnValsMutator]MSP[N] } if ( size > 0 ) { Object otherValue = null ; switch ( size ) { case 3 : if ( other . containsKey ( key3 ) == false ) { return false ; }
return; } if ( size < 4 ) { for ( final Map . Entry < ? extends K , ? extends V > entry : map . entrySet () ) { put ( entry . getKey () , entry . getValue () ) ; MST[NonVoidMethodCallMutator]MSP[N] } } else {
return false ; } otherValue = other . get ( key1 ) ; if ( value1 == null ? otherValue != null : ! value1 . equals ( otherValue ) ) { return false ; } } } return true ; MST[InlineConstantMutator]MSP[N] } @Override public int hashCode () {
final V old = value2 ; hash2 = 0 ; MST[experimental.MemberVariableMutator]MSP[S] key2 = null ; value2 = null ; size = 1 ; return old ; } if ( hash1 == hashCode && key . equals ( key1 ) ) { final V old = value1 ; hash1 = hash2 ;
buf . append ( value2 == this ? lr_9 : value2 ) ; buf . append ( ',' ) ; MST[rv.CRCR5Mutator]MSP[N] case 1 : buf . append ( key1 == this ? lr_9 : key1 ) ; buf . append ( '=' ) ;
if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.UOI2Mutator]MSP[S] return true ; } } } } return false ; } @Override public boolean containsValue ( final Object value ) { if ( delegateMap != null ) { return delegateMap . containsValue ( value ) ;
delegateMap . put ( key2 , value2 ) ; case 1 : delegateMap . put ( key1 , value1 ) ; case 0 : break; default: throw new IllegalStateException ( lr_1 + size ) ; } size = 0 ; MST[rv.CRCR3Mutator]MSP[S] hash1 = hash2 = hash3 = 0 ;
hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; MST[rv.CRCR3Mutator]MSP[N] return old ; } return null ; case 2 : if ( key2 == null ) { final V old = value2 ; hash2 = 0 ; key2 = null ;
hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; MST[InlineConstantMutator]MSP[N] return old ; } return null ; case 2 : if ( key2 == null ) { final V old = value2 ; hash2 = 0 ; key2 = null ;
@Override public V get ( final Object key ) { if ( delegateMap != null ) { return delegateMap . get ( key ) ; } if ( key == null ) { switch ( size ) { MST[rv.UOI4Mutator]MSP[N] case 3 : if ( key3 == null ) {
buf . append ( value2 == this ? lr_9 : value2 ) ; buf . append ( ',' ) ; case 1 : buf . append ( key1 == this ? lr_9 : key1 ) ; MST[NonVoidMethodCallMutator]MSP[N] buf . append ( '=' ) ;
hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; MST[experimental.MemberVariableMutator]MSP[N] return old ; } if ( hash2 == hashCode && key . equals ( key2 ) ) { final V old = value2 ; hash2 = hash3 ; key2 = key3 ;
public int size () { if ( delegateMap != null ) { return delegateMap . size () ; } return size ; } @Override public boolean isEmpty () { return size () == 0 ; MST[rv.ROR2Mutator]MSP[N] } @Override public boolean containsKey ( final Object key ) {
value2 = value3 ; hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } if ( key1 == null ) { MST[NegateConditionalsMutator]MSP[N] final V old = value1 ; hash1 = hash3 ; key1 = key3 ; value1 = value3 ;
final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] return value3 ; } case 2 :
key1 = key3 ; value1 = value3 ; hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } return null ; case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.ROR5Mutator]MSP[N]
case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[rv.UOI1Mutator]MSP[S] return true ; } case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { return true ; } case 1 :
public Set < K > keySet () { if ( delegateMap != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] return delegateMap . keySet () ; } return new KeySet <> ( this ) ; } @Override public int size () { return parent . size () ; } @Override public void clear () {
final V old = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; return old ; } if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.ROR3Mutator]MSP[N] final V old = value1 ; hash1 = hash2 ;
if ( hash2 == hashCode && key . equals ( key2 ) ) { return value2 ; } case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.ROR4Mutator]MSP[N] return value1 ; } } } } return null ; } @Override
key1 = key2 ; value1 = value2 ; hash2 = 0 ; MST[rv.CRCR1Mutator]MSP[S] key2 = null ; value2 = null ; size = 1 ; return old ; } return null ; case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) {
if ( delegateMap != null ) { return delegateMap . containsKey ( key ) ; } if ( key == null ) { switch ( size ) { MST[experimental.SwitchMutator]MSP[N] case 3 : if ( key3 == null ) { return true ; } case 2 :
@Override public V get ( final Object key ) { if ( delegateMap != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] return delegateMap . get ( key ) ; } if ( key == null ) { switch ( size ) { case 3 : if ( key3 == null ) {
if ( delegateMap != null ) { return delegateMap . hashCode () ; } int total = 0 ; switch ( size ) { case 3 : total += hash3 ^ ( value3 == null ? 0 : value3 . hashCode () ) ; MST[MathMutator]MSP[S] case 2 :
case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[rv.ROR2Mutator]MSP[S] return true ; } case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { return true ; } case 1 :
if ( value1 == null ) { return true ; } } } else { switch ( size ) { case 3 : if ( value . equals ( value3 ) ) { return true ; } case 2 : if ( value . equals ( value2 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
buf . append ( value3 == this ? lr_9 : value3 ) ; buf . append ( ',' ) ; MST[experimental.NakedReceiverMutator]MSP[S] case 2 : buf . append ( key2 == this ? lr_9 : key2 ) ; buf . append ( '=' ) ;
final V old = value3 ; hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; MST[rv.CRCR4Mutator]MSP[N] return old ; } if ( key2 == null ) { final V old = value2 ; hash2 = hash3 ; key2 = key3 ;
buf . append ( value1 == this ? lr_9 : value1 ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] break; default: throw new IllegalStateException ( lr_1 + size ) ; } buf . append ( '}' ) ; return buf . toString () ; }
if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.ROR2Mutator]MSP[S] final V old = value1 ; value1 = value ; return old ; } } } } switch ( size ) { default: convertToMap () ; delegateMap . put ( key , value ) ;
convertToMap () ; delegateMap . putAll ( map ) ; } } private void convertToMap () { delegateMap = createDelegateMap () ; switch ( size ) { case 3 : delegateMap . put ( key3 , value3 ) ; MST[ArgumentPropagationMutator]MSP[N] case 2 :
} else { if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[rv.UOI2Mutator]MSP[S] final V old = value3 ;
public Flat3Map < K , V > clone () { try { final Flat3Map < K , V > cloned = ( Flat3Map < K , V > ) super . clone () ; if ( cloned . delegateMap != null ) { MST[NegateConditionalsMutator]MSP[S]
} if ( delegateMap != null ) { return delegateMap . equals ( obj ) ; } if ( obj instanceof Map == false ) { return false ; MST[rv.CRCR5Mutator]MSP[N] } final Map < ? , ? > other = ( Map < ? , ? > ) obj ;
return null ; case 2 : hash3 = key == null ? 0 : key . hashCode () ; key3 = key ; value3 = value ; break; case 1 : hash2 = key == null ? 0 : key . hashCode () ; key2 = key ; MST[experimental.MemberVariableMutator]MSP[N]
total += hash2 ^ ( value2 == null ? 0 : value2 . hashCode () ) ; MST[rv.UOI1Mutator]MSP[S] case 1 : total += hash1 ^ ( value1 == null ? 0 : value1 . hashCode () ) ; case 0 : break; default:
if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return value2 ; } case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { return value1 ; } } } } return null ; } @Override
if ( delegateMap != null ) { return delegateMap . hashCode () ; } int total = 0 ; switch ( size ) { case 3 : total += hash3 ^ ( value3 == null ? 0 : value3 . hashCode () ) ; MST[rv.AOR4Mutator]MSP[S] case 2 :
value2 = value ; break; case 0 : hash1 = key == null ? 0 : key . hashCode () ; MST[rv.CRCR6Mutator]MSP[S] key1 = key ; value1 = value ; break; } size ++ ; return null ; } @Override
} if ( delegateMap != null ) { return delegateMap . equals ( obj ) ; } if ( obj instanceof Map == false ) { MST[rv.ROR5Mutator]MSP[N] return false ; } final Map < ? , ? > other = ( Map < ? , ? > ) obj ;
if ( value1 == null ) { return true ; } } } else { switch ( size ) { case 3 : if ( value . equals ( value3 ) ) { return true ; } case 2 : if ( value . equals ( value2 ) ) { MST[rv.ROR3Mutator]MSP[N]
final StringBuilder buf = new StringBuilder ( 128 ) ; buf . append ( '{' ) ; switch ( size ) { MST[rv.UOI3Mutator]MSP[N] case 3 : buf . append ( key3 == this ? lr_9 : key3 ) ; buf . append ( '=' ) ;
if ( delegateMap != null ) { return delegateMap . containsKey ( key ) ; } if ( key == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] switch ( size ) { case 3 : if ( key3 == null ) { return true ; } case 2 :
return; } if ( size < 4 ) { for ( final Map . Entry < ? extends K , ? extends V > entry : map . entrySet () ) { put ( entry . getKey () , entry . getValue () ) ; MST[NonVoidMethodCallMutator]MSP[N] } } else {
hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.UOI4Mutator]MSP[N] final V old = value2 ; hash2 = hash3 ; key2 = key3 ;
if ( hash1 == hashCode && key . equals ( key1 ) ) { final V old = value1 ; value1 = value ; return old ; } } } } switch ( size ) { MST[experimental.RemoveSwitchMutator_2]MSP[S] default: convertToMap () ; delegateMap . put ( key , value ) ;
throw new IllegalStateException ( lr_1 + size ) ; } return total ; } @Override public String toString () { if ( delegateMap != null ) { return delegateMap . toString () ; } if ( size == 0 ) { MST[rv.ROR2Mutator]MSP[N] return lr_8 ; }
if ( hash1 == hashCode && key . equals ( key1 ) ) { final V old = value1 ; value1 = value ; return old ; } } } } switch ( size ) { MST[experimental.RemoveSwitchMutator_1]MSP[N] default: convertToMap () ; delegateMap . put ( key , value ) ;
buf . append ( value1 == this ? lr_9 : value1 ) ; break; default: throw new IllegalStateException ( lr_1 + size ) ; } buf . append ( '}' ) ; MST[rv.CRCR2Mutator]MSP[N] return buf . toString () ; }
if ( hash1 == hashCode && key . equals ( key1 ) ) { return true ; MST[rv.CRCR3Mutator]MSP[S] } } } } return false ; } @Override public boolean containsValue ( final Object value ) { if ( delegateMap != null ) { return delegateMap . containsValue ( value ) ;
if ( key2 == null ) { final V old = value2 ; value2 = value ; return old ; } case 1 : if ( key1 == null ) { final V old = value1 ; value1 = value ; return old ; MST[NullReturnValsMutator]MSP[S] } } } else {
key1 = key2 ; value1 = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; return old ; } return null ; case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.ROR3Mutator]MSP[N]
if ( hash1 == hashCode && key . equals ( key1 ) ) { final V old = value1 ; value1 = value ; return old ; } } } } switch ( size ) { MST[rv.ABSMutator]MSP[N] default: convertToMap () ; delegateMap . put ( key , value ) ;
hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] final V old = value2 ; hash2 = hash3 ; key2 = key3 ;
final V old = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; MST[rv.CRCR2Mutator]MSP[N] return old ; } if ( hash1 == hashCode && key . equals ( key1 ) ) { final V old = value1 ; hash1 = hash2 ;
if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return true ; } } } } return false ; } @Override public boolean containsValue ( final Object value ) { if ( delegateMap != null ) { return delegateMap . containsValue ( value ) ;
throw new IllegalStateException ( lr_1 + size ) ; } return total ; } @Override public String toString () { if ( delegateMap != null ) { return delegateMap . toString () ; } if ( size == 0 ) { MST[rv.UOI1Mutator]MSP[N] return lr_8 ; }
if ( hash1 == hashCode && key . equals ( key1 ) ) { final V old = value1 ; value1 = value ; return old ; } } } } switch ( size ) { MST[experimental.RemoveSwitchMutator_0]MSP[N] default: convertToMap () ; delegateMap . put ( key , value ) ;
value2 = value ; break; case 0 : hash1 = key == null ? 0 : key . hashCode () ; key1 = key ; value1 = value ; break; } size ++ ; MST[rv.AOR1Mutator]MSP[N] return null ; } @Override
key1 = key2 = key3 = null ; MST[experimental.MemberVariableMutator]MSP[S] value1 = value2 = value3 = null ; } protected AbstractHashedMap < K , V > createDelegateMap () { return new HashedMap <> () ; } @Override public V remove ( final Object key ) {
if ( value1 == null ) { return true ; } } } else { switch ( size ) { MST[rv.UOI1Mutator]MSP[N] case 3 : if ( value . equals ( value3 ) ) { return true ; } case 2 : if ( value . equals ( value2 ) ) {
public Flat3Map < K , V > clone () { try { final Flat3Map < K , V > cloned = ( Flat3Map < K , V > ) super . clone () ; if ( cloned . delegateMap != null ) { MST[rv.ROR5Mutator]MSP[S]
} if ( delegateMap != null ) { return delegateMap . equals ( obj ) ; } if ( obj instanceof Map == false ) { return false ; MST[ReturnValsMutator]MSP[N] } final Map < ? , ? > other = ( Map < ? , ? > ) obj ;
if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.ROR3Mutator]MSP[N] return true ; } } } } return false ; } @Override public boolean containsValue ( final Object value ) { if ( delegateMap != null ) { return delegateMap . containsValue ( value ) ;
if ( size > 0 ) { MST[rv.UOI2Mutator]MSP[N] final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { final V old = value3 ; value3 = value ;
if ( size != other . size () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return false ; } if ( size > 0 ) { Object otherValue = null ; switch ( size ) { case 3 : if ( other . containsKey ( key3 ) == false ) { return false ; }
value2 = value ; break; case 0 : hash1 = key == null ? 0 : key . hashCode () ; key1 = key ; value1 = value ; break; } size ++ ; MST[rv.UOI3Mutator]MSP[N] return null ; } @Override
return null ; case 2 : hash3 = key == null ? 0 : key . hashCode () ; MST[rv.ROR5Mutator]MSP[N] key3 = key ; value3 = value ; break; case 1 : hash2 = key == null ? 0 : key . hashCode () ; key2 = key ;
final V old = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; return old ; } if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[NonVoidMethodCallMutator]MSP[N] final V old = value1 ; hash1 = hash2 ;
if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.UOI2Mutator]MSP[N] return value2 ; } case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { return value1 ; } } } } return null ; } @Override
value2 = value3 ; hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } if ( key1 == null ) { final V old = value1 ; hash1 = hash3 ; key1 = key3 ; value1 = value3 ; MST[experimental.MemberVariableMutator]MSP[S]
convertToMap () ; delegateMap . putAll ( map ) ; } } private void convertToMap () { delegateMap = createDelegateMap () ; switch ( size ) { MST[experimental.RemoveSwitchMutator_2]MSP[S] case 3 : delegateMap . put ( key3 , value3 ) ; case 2 :
convertToMap () ; delegateMap . putAll ( map ) ; } } private void convertToMap () { delegateMap = createDelegateMap () ; switch ( size ) { MST[experimental.RemoveSwitchMutator_1]MSP[S] case 3 : delegateMap . put ( key3 , value3 ) ; case 2 :
convertToMap () ; delegateMap . putAll ( map ) ; } } private void convertToMap () { delegateMap = createDelegateMap () ; switch ( size ) { MST[experimental.RemoveSwitchMutator_3]MSP[S] case 3 : delegateMap . put ( key3 , value3 ) ; case 2 :
convertToMap () ; delegateMap . putAll ( map ) ; } } private void convertToMap () { delegateMap = createDelegateMap () ; switch ( size ) { MST[rv.UOI2Mutator]MSP[S] case 3 : delegateMap . put ( key3 , value3 ) ; case 2 :
key1 = key3 ; value1 = value3 ; hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } return null ; case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.ABSMutator]MSP[N]
total += hash2 ^ ( value2 == null ? 0 : value2 . hashCode () ) ; case 1 : total += hash1 ^ ( value1 == null ? 0 : value1 . hashCode () ) ; MST[rv.UOI3Mutator]MSP[S] case 0 : break; default:
hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } return null ; case 2 : if ( key2 == null ) { final V old = value2 ; hash2 = 0 ; MST[rv.CRCR5Mutator]MSP[S] key2 = null ;
value2 = value3 ; hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } if ( key1 == null ) { final V old = value1 ; hash1 = hash3 ; MST[rv.ABSMutator]MSP[S] key1 = key3 ; value1 = value3 ;
if ( delegateMap != null ) { return delegateMap . hashCode () ; } int total = 0 ; switch ( size ) { case 3 : total += hash3 ^ ( value3 == null ? 0 : value3 . hashCode () ) ; MST[rv.UOI4Mutator]MSP[S] case 2 :
if ( key2 == null ) { final V old = value2 ; value2 = value ; return old ; } case 1 : if ( key1 == null ) { final V old = value1 ; value1 = value ; return old ; MST[ReturnValsMutator]MSP[S] } } } else {
if ( delegateMap != null ) { return delegateMap . remove ( key ) ; } if ( size == 0 ) { return null ; } if ( key == null ) { switch ( size ) { MST[rv.UOI4Mutator]MSP[N] case 3 : if ( key3 == null ) {
final V old = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; return old ; } if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.UOI1Mutator]MSP[S] final V old = value1 ; hash1 = hash2 ;
public int size () { if ( delegateMap != null ) { return delegateMap . size () ; } return size ; MST[PrimitiveReturnsMutator]MSP[N] } @Override public boolean isEmpty () { return size () == 0 ; } @Override public boolean containsKey ( final Object key ) {
buf . append ( value2 == this ? lr_9 : value2 ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] buf . append ( ',' ) ; case 1 : buf . append ( key1 == this ? lr_9 : key1 ) ; buf . append ( '=' ) ;
buf . append ( value2 == this ? lr_9 : value2 ) ; buf . append ( ',' ) ; MST[experimental.NakedReceiverMutator]MSP[N] case 1 : buf . append ( key1 == this ? lr_9 : key1 ) ; buf . append ( '=' ) ;
final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[rv.UOI2Mutator]MSP[S] return value3 ; } case 2 :
value2 = value3 ; hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; MST[rv.CRCR4Mutator]MSP[N] return old ; } if ( hash1 == hashCode && key . equals ( key1 ) ) { final V old = value1 ; hash1 = hash3 ;
buf . append ( value3 == this ? lr_9 : value3 ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] buf . append ( ',' ) ; case 2 : buf . append ( key2 == this ? lr_9 : key2 ) ; buf . append ( '=' ) ;
if ( key2 == null ) { return true ; } case 1 : if ( key1 == null ) { return true ; } } } else { if ( size > 0 ) { MST[rv.UOI1Mutator]MSP[S] final int hashCode = key . hashCode () ; switch ( size ) {
if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[NonVoidMethodCallMutator]MSP[N] return true ; } } } } return false ; } @Override public boolean containsValue ( final Object value ) { if ( delegateMap != null ) { return delegateMap . containsValue ( value ) ;
buf . append ( value2 == this ? lr_9 : value2 ) ; buf . append ( ',' ) ; MST[rv.CRCR1Mutator]MSP[N] case 1 : buf . append ( key1 == this ? lr_9 : key1 ) ; buf . append ( '=' ) ;
value2 = value3 ; hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } if ( key1 == null ) { MST[rv.ROR5Mutator]MSP[N] final V old = value1 ; hash1 = hash3 ; key1 = key3 ; value1 = value3 ;
if ( key2 == null ) { return true ; } case 1 : if ( key1 == null ) { return true ; MST[rv.CRCR2Mutator]MSP[N] } } } else { if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) {
if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[rv.UOI2Mutator]MSP[S] final V old = value3 ; value3 = value ;
key1 = key2 ; value1 = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; return old ; } return null ; case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[NonVoidMethodCallMutator]MSP[N]
if ( hash2 == hashCode && key . equals ( key2 ) ) { return value2 ; } case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.ROR2Mutator]MSP[S] return value1 ; } } } } return null ; } @Override
} if ( value == null ) { switch ( size ) { MST[experimental.SwitchMutator]MSP[N] case 3 : if ( value3 == null ) { return true ; } case 2 : if ( value2 == null ) { return true ; } case 1 :
if ( size != other . size () ) { return false ; } if ( size > 0 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[S] Object otherValue = null ; switch ( size ) { case 3 : if ( other . containsKey ( key3 ) == false ) { return false ; }
size = 1 ; return old ; } return null ; case 1 : if ( key1 == null ) { final V old = value1 ; hash1 = 0 ; MST[InlineConstantMutator]MSP[S] key1 = null ; value1 = null ; size = 0 ; return old ; } }
if ( size != other . size () ) { return false ; } if ( size > 0 ) { MST[rv.ROR4Mutator]MSP[S] Object otherValue = null ; switch ( size ) { case 3 : if ( other . containsKey ( key3 ) == false ) { return false ; }
convertToMap () ; delegateMap . putAll ( map ) ; } } private void convertToMap () { delegateMap = createDelegateMap () ; switch ( size ) { MST[experimental.RemoveSwitchMutator_0]MSP[S] case 3 : delegateMap . put ( key3 , value3 ) ; case 2 :
key1 = key2 ; value1 = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; return old ; } return null ; case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.UOI1Mutator]MSP[S]
key1 = key2 ; value1 = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; return old ; } return null ; case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S]
public Collection < V > values () { if ( delegateMap != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] return delegateMap . values () ; } return new Values <> ( this ) ; } @Override public int size () { return parent . size () ; } @Override public void clear () {
} if ( delegateMap != null ) { return delegateMap . equals ( obj ) ; } if ( obj instanceof Map == false ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return false ; } final Map < ? , ? > other = ( Map < ? , ? > ) obj ;
if ( delegateMap != null ) { MST[NegateConditionalsMutator]MSP[S] return delegateMap . hashCode () ; } int total = 0 ; switch ( size ) { case 3 : total += hash3 ^ ( value3 == null ? 0 : value3 . hashCode () ) ; case 2 :
if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { MST[rv.UOI4Mutator]MSP[N] case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { final V old = value3 ; value3 = value ;
hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; MST[NullReturnValsMutator]MSP[S] } return null ; case 2 : if ( key2 == null ) { final V old = value2 ; hash2 = 0 ; key2 = null ;
public void putAll ( final Map < ? extends K , ? extends V > map ) { final int size = map . size () ; if ( size == 0 ) { MST[NegateConditionalsMutator]MSP[N] return; } if ( delegateMap != null ) { delegateMap . putAll ( map ) ;
public int size () { if ( delegateMap != null ) { return delegateMap . size () ; } return size ; } @Override public boolean isEmpty () { return size () == 0 ; MST[rv.ROR5Mutator]MSP[N] } @Override public boolean containsKey ( final Object key ) {
value2 = null ; size = 1 ; MST[rv.CRCR3Mutator]MSP[S] return old ; } if ( key1 == null ) { final V old = value1 ; hash1 = hash2 ; key1 = key2 ; value1 = value2 ; hash2 = 0 ; key2 = null ; value2 = null ;
case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[rv.UOI4Mutator]MSP[S] return true ; } case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { return true ; } case 1 :
final V old = value1 ; hash1 = 0 ; key1 = null ; value1 = null ; size = 0 ; MST[rv.CRCR3Mutator]MSP[N] return old ; } } } } return null ; } @Override public void clear () { if ( delegateMap != null ) {
total += hash2 ^ ( value2 == null ? 0 : value2 . hashCode () ) ; case 1 : total += hash1 ^ ( value1 == null ? 0 : value1 . hashCode () ) ; MST[rv.UOI1Mutator]MSP[S] case 0 : break; default:
final StringBuilder buf = new StringBuilder ( 128 ) ; buf . append ( '{' ) ; MST[InlineConstantMutator]MSP[N] switch ( size ) { case 3 : buf . append ( key3 == this ? lr_9 : key3 ) ; buf . append ( '=' ) ;
return null ; case 2 : hash3 = key == null ? 0 : key . hashCode () ; MST[rv.CRCR3Mutator]MSP[S] key3 = key ; value3 = value ; break; case 1 : hash2 = key == null ? 0 : key . hashCode () ; key2 = key ;
if ( size != other . size () ) { return false ; } if ( size > 0 ) { MST[rv.ROR1Mutator]MSP[S] Object otherValue = null ; switch ( size ) { case 3 : if ( other . containsKey ( key3 ) == false ) { return false ; }
convertToMap () ; delegateMap . putAll ( map ) ; MST[VoidMethodCallMutator]MSP[S] } } private void convertToMap () { delegateMap = createDelegateMap () ; switch ( size ) { case 3 : delegateMap . put ( key3 , value3 ) ; case 2 :
if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.ROR2Mutator]MSP[S] return value2 ; } case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { return value1 ; } } } } return null ; } @Override
} if ( delegateMap != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] return delegateMap . equals ( obj ) ; } if ( obj instanceof Map == false ) { return false ; } final Map < ? , ? > other = ( Map < ? , ? > ) obj ;
case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { return true ; } case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.ROR3Mutator]MSP[S] return true ; } case 1 :
key1 = key2 ; value1 = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; return old ; } return null ; case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.UOI3Mutator]MSP[N]
final V old = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; MST[rv.CRCR5Mutator]MSP[N] return old ; } if ( hash1 == hashCode && key . equals ( key1 ) ) { final V old = value1 ; hash1 = hash2 ;
hash3 = 0 ; MST[rv.CRCR5Mutator]MSP[S] key3 = null ; value3 = null ; size = 2 ; return old ; } if ( hash2 == hashCode && key . equals ( key2 ) ) { final V old = value2 ; hash2 = hash3 ; key2 = key3 ;
@Override public V get ( final Object key ) { if ( delegateMap != null ) { return delegateMap . get ( key ) ; } if ( key == null ) { switch ( size ) { MST[rv.UOI1Mutator]MSP[N] case 3 : if ( key3 == null ) {
case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] return true ; } case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { return true ; } case 1 :
if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.UOI2Mutator]MSP[N] final V old = value1 ; value1 = value ; return old ; } } } } switch ( size ) { default: convertToMap () ; delegateMap . put ( key , value ) ;
if ( key2 == null ) { return true ; } case 1 : if ( key1 == null ) { return true ; } } } else { if ( size > 0 ) { MST[rv.UOI4Mutator]MSP[N] final int hashCode = key . hashCode () ; switch ( size ) {
delegateMap . clear () ; delegateMap = null ; } else { size = 0 ; hash1 = hash2 = hash3 = 0 ; MST[experimental.MemberVariableMutator]MSP[S] key1 = key2 = key3 = null ; value1 = value2 = value3 = null ; } } @Override
} if ( delegateMap != null ) { return delegateMap . equals ( obj ) ; } if ( obj instanceof Map == false ) { return false ; MST[InlineConstantMutator]MSP[N] } final Map < ? , ? > other = ( Map < ? , ? > ) obj ;
hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[NegateConditionalsMutator]MSP[N] final V old = value2 ; hash2 = hash3 ; key2 = key3 ;
final StringBuilder buf = new StringBuilder ( 128 ) ; buf . append ( '{' ) ; switch ( size ) { case 3 : buf . append ( key3 == this ? lr_9 : key3 ) ; MST[NonVoidMethodCallMutator]MSP[S] buf . append ( '=' ) ;
final V old = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; return old ; } if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.UOI3Mutator]MSP[N] final V old = value1 ; hash1 = hash2 ;
if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.ROR5Mutator]MSP[N] final V old = value1 ; value1 = value ; return old ; } } } } switch ( size ) { default: convertToMap () ; delegateMap . put ( key , value ) ;
hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; MST[rv.CRCR1Mutator]MSP[N] return old ; } return null ; case 2 : if ( key2 == null ) { final V old = value2 ; hash2 = 0 ; key2 = null ;
final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[rv.ROR2Mutator]MSP[S] return value3 ; } case 2 :
total += hash2 ^ ( value2 == null ? 0 : value2 . hashCode () ) ; MST[rv.UOI4Mutator]MSP[S] case 1 : total += hash1 ^ ( value1 == null ? 0 : value1 . hashCode () ) ; case 0 : break; default:
if ( size != other . size () ) { return false ; MST[InlineConstantMutator]MSP[N] } if ( size > 0 ) { Object otherValue = null ; switch ( size ) { case 3 : if ( other . containsKey ( key3 ) == false ) { return false ; }
if ( delegateMap != null ) { return delegateMap . remove ( key ) ; } if ( size == 0 ) { MST[rv.ABSMutator]MSP[S] return null ; } if ( key == null ) { switch ( size ) { case 3 : if ( key3 == null ) {
hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.ROR5Mutator]MSP[N] final V old = value2 ; hash2 = hash3 ; key2 = key3 ;
return old ; } case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.ROR2Mutator]MSP[S] final V old = value2 ; value2 = value ; return old ; } case 1 :
if ( key2 == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return true ; } case 1 : if ( key1 == null ) { return true ; } } } else { if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) {
if ( hash1 == hashCode && key . equals ( key1 ) ) { return true ; } } } } return false ; MST[rv.CRCR6Mutator]MSP[N] } @Override public boolean containsValue ( final Object value ) { if ( delegateMap != null ) { return delegateMap . containsValue ( value ) ;
buf . append ( value3 == this ? lr_9 : value3 ) ; buf . append ( ',' ) ; case 2 : buf . append ( key2 == this ? lr_9 : key2 ) ; MST[NonVoidMethodCallMutator]MSP[S] buf . append ( '=' ) ;
if ( hash1 == hashCode && key . equals ( key1 ) ) { return true ; } } } } return false ; MST[BooleanTrueReturnValsMutator]MSP[N] } @Override public boolean containsValue ( final Object value ) { if ( delegateMap != null ) { return delegateMap . containsValue ( value ) ;
final StringBuilder buf = new StringBuilder ( 128 ) ; buf . append ( '{' ) ; MST[rv.CRCR2Mutator]MSP[N] switch ( size ) { case 3 : buf . append ( key3 == this ? lr_9 : key3 ) ; buf . append ( '=' ) ;
value2 = value ; break; case 0 : hash1 = key == null ? 0 : key . hashCode () ; key1 = key ; value1 = value ; break; } size ++ ; MST[MathMutator]MSP[N] return null ; } @Override
final V old = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; return old ; } if ( hash1 == hashCode && key . equals ( key1 ) ) { final V old = value1 ; hash1 = hash2 ; MST[rv.UOI3Mutator]MSP[S]
return null ; case 2 : hash3 = key == null ? 0 : key . hashCode () ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] key3 = key ; value3 = value ; break; case 1 : hash2 = key == null ? 0 : key . hashCode () ; key2 = key ;
final V old = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; return old ; } if ( hash1 == hashCode && key . equals ( key1 ) ) { final V old = value1 ; hash1 = hash2 ; MST[rv.UOI2Mutator]MSP[S]
if ( size != other . size () ) { MST[rv.ROR2Mutator]MSP[N] return false ; } if ( size > 0 ) { Object otherValue = null ; switch ( size ) { case 3 : if ( other . containsKey ( key3 ) == false ) { return false ; }
return old ; } case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] final V old = value2 ; value2 = value ; return old ; } case 1 :
if ( value1 == null ) { return true ; MST[rv.CRCR2Mutator]MSP[N] } } } else { switch ( size ) { case 3 : if ( value . equals ( value3 ) ) { return true ; } case 2 : if ( value . equals ( value2 ) ) {
} else { if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[rv.ROR3Mutator]MSP[N] final V old = value3 ;
throw new IllegalStateException ( lr_1 + size ) ; } return total ; } @Override public String toString () { if ( delegateMap != null ) { return delegateMap . toString () ; } if ( size == 0 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return lr_8 ; }
throw new IllegalStateException ( lr_1 + size ) ; } return total ; } @Override public String toString () { if ( delegateMap != null ) { MST[NegateConditionalsMutator]MSP[S] return delegateMap . toString () ; } if ( size == 0 ) { return lr_8 ; }
if ( value1 == null ) { return true ; } } } else { switch ( size ) { MST[rv.UOI4Mutator]MSP[N] case 3 : if ( value . equals ( value3 ) ) { return true ; } case 2 : if ( value . equals ( value2 ) ) {
final V old = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; return old ; } if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.UOI2Mutator]MSP[S] final V old = value1 ; hash1 = hash2 ;
if ( delegateMap != null ) { return delegateMap . hashCode () ; } int total = 0 ; switch ( size ) { MST[rv.UOI1Mutator]MSP[N] case 3 : total += hash3 ^ ( value3 == null ? 0 : value3 . hashCode () ) ; case 2 :
if ( delegateMap != null ) { return delegateMap . hashCode () ; } int total = 0 ; MST[rv.CRCR6Mutator]MSP[S] switch ( size ) { case 3 : total += hash3 ^ ( value3 == null ? 0 : value3 . hashCode () ) ; case 2 :
return true ; MST[rv.CRCR3Mutator]MSP[S] } case 1 : if ( value . equals ( value1 ) ) { return true ; } } } return false ; } @Override public V put ( final K key , final V value ) { if ( delegateMap != null ) {
if ( size > 0 ) { MST[rv.ROR3Mutator]MSP[S] final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { final V old = value3 ; value3 = value ;
return value3 ; MST[NullReturnValsMutator]MSP[S] } case 2 : if ( key2 == null ) { return value2 ; } case 1 : if ( key1 == null ) { return value1 ; } } } else { if ( size > 0 ) {
key1 = key3 ; value1 = value3 ; hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } return null ; case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.ROR2Mutator]MSP[N]
} if ( delegateMap != null ) { return delegateMap . equals ( obj ) ; } if ( obj instanceof Map == false ) { MST[rv.ROR2Mutator]MSP[N] return false ; } final Map < ? , ? > other = ( Map < ? , ? > ) obj ;
} else { if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] final V old = value3 ;
if ( key2 == null ) { return true ; } case 1 : if ( key1 == null ) { return true ; } } } else { if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { MST[rv.UOI3Mutator]MSP[N]
return null ; case 2 : hash3 = key == null ? 0 : key . hashCode () ; MST[NegateConditionalsMutator]MSP[N] key3 = key ; value3 = value ; break; case 1 : hash2 = key == null ? 0 : key . hashCode () ; key2 = key ;
hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.ROR1Mutator]MSP[S] final V old = value2 ; hash2 = hash3 ; key2 = key3 ;
if ( key2 == null ) { return true ; } case 1 : if ( key1 == null ) { return true ; MST[InlineConstantMutator]MSP[N] } } } else { if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) {
if ( size != other . size () ) { return false ; } if ( size > 0 ) { MST[rv.UOI3Mutator]MSP[N] Object otherValue = null ; switch ( size ) { case 3 : if ( other . containsKey ( key3 ) == false ) { return false ; }
if ( hash2 == hashCode && key . equals ( key2 ) ) { return value2 ; } case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { return value1 ; } } } } return null ; MST[ReturnValsMutator]MSP[S] } @Override
return old ; } case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.ABSMutator]MSP[S] final V old = value2 ; value2 = value ; return old ; } case 1 :
key1 = key3 ; value1 = value3 ; hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } return null ; case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[NegateConditionalsMutator]MSP[N]
if ( key2 == null ) { return true ; } case 1 : if ( key1 == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return true ; } } } else { if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) {
value2 = value ; break; case 0 : hash1 = key == null ? 0 : key . hashCode () ; key1 = key ; value1 = value ; break; } size ++ ; MST[rv.CRCR3Mutator]MSP[N] return null ; } @Override
if ( hash2 == hashCode && key . equals ( key2 ) ) { return value2 ; } case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return value1 ; } } } } return null ; } @Override
return true ; } case 1 : if ( value . equals ( value1 ) ) { return true ; } } } return false ; MST[rv.CRCR3Mutator]MSP[N] } @Override public V put ( final K key , final V value ) { if ( delegateMap != null ) {
key1 = key2 ; value1 = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; return old ; } return null ; case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.UOI2Mutator]MSP[S]
total += hash2 ^ ( value2 == null ? 0 : value2 . hashCode () ) ; MST[rv.AOR4Mutator]MSP[S] case 1 : total += hash1 ^ ( value1 == null ? 0 : value1 . hashCode () ) ; case 0 : break; default:
buf . append ( value1 == this ? lr_9 : value1 ) ; break; default: throw new IllegalStateException ( lr_1 + size ) ; } buf . append ( '}' ) ; MST[InlineConstantMutator]MSP[N] return buf . toString () ; }
if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[rv.ROR3Mutator]MSP[S] final V old = value3 ; value3 = value ;
@Override public V get ( final Object key ) { if ( delegateMap != null ) { return delegateMap . get ( key ) ; } if ( key == null ) { switch ( size ) { case 3 : if ( key3 == null ) { MST[rv.ROR5Mutator]MSP[N]
hash3 = 0 ; MST[rv.CRCR6Mutator]MSP[S] key3 = null ; value3 = null ; size = 2 ; return old ; } return null ; case 2 : if ( key2 == null ) { final V old = value2 ; hash2 = 0 ; key2 = null ;
if ( key2 == null ) { return true ; } case 1 : if ( key1 == null ) { return true ; } } } else { if ( size > 0 ) { MST[rv.ROR2Mutator]MSP[N] final int hashCode = key . hashCode () ; switch ( size ) {
if ( hash1 == hashCode && key . equals ( key1 ) ) { return true ; } } } } return false ; } @Override public boolean containsValue ( final Object value ) { if ( delegateMap != null ) { return delegateMap . containsValue ( value ) ; MST[ReturnValsMutator]MSP[S]
final StringBuilder buf = new StringBuilder ( 128 ) ; buf . append ( '{' ) ; switch ( size ) { case 3 : buf . append ( key3 == this ? lr_9 : key3 ) ; buf . append ( '=' ) ; MST[rv.CRCR6Mutator]MSP[S]
public void putAll ( final Map < ? extends K , ? extends V > map ) { final int size = map . size () ; if ( size == 0 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return; } if ( delegateMap != null ) { delegateMap . putAll ( map ) ;
return value3 ; } case 2 : if ( key2 == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return value2 ; } case 1 : if ( key1 == null ) { return value1 ; } } } else { if ( size > 0 ) {
total += hash2 ^ ( value2 == null ? 0 : value2 . hashCode () ) ; case 1 : total += hash1 ^ ( value1 == null ? 0 : value1 . hashCode () ) ; MST[rv.UOI4Mutator]MSP[S] case 0 : break; default:
hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } return null ; case 2 : if ( key2 == null ) { final V old = value2 ; hash2 = 0 ; MST[InlineConstantMutator]MSP[S] key2 = null ;
total += hash2 ^ ( value2 == null ? 0 : value2 . hashCode () ) ; MST[rv.ROR5Mutator]MSP[S] case 1 : total += hash1 ^ ( value1 == null ? 0 : value1 . hashCode () ) ; case 0 : break; default:
public MapIterator < K , V > mapIterator () { if ( delegateMap != null ) { return delegateMap . mapIterator () ; } if ( size == 0 ) { MST[rv.ROR1Mutator]MSP[S] return EmptyMapIterator . <K , V > emptyMapIterator () ; } return new FlatMapIterator <> ( this ) ;
hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } return null ; case 2 : if ( key2 == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] final V old = value2 ; hash2 = 0 ; key2 = null ;
final V old = value1 ; hash1 = 0 ; key1 = null ; value1 = null ; size = 0 ; MST[rv.CRCR6Mutator]MSP[N] return old ; } } } } return null ; } @Override public void clear () { if ( delegateMap != null ) {
public MapIterator < K , V > mapIterator () { if ( delegateMap != null ) { return delegateMap . mapIterator () ; } if ( size == 0 ) { return EmptyMapIterator . <K , V > emptyMapIterator () ; MST[ReturnValsMutator]MSP[S] } return new FlatMapIterator <> ( this ) ;
final StringBuilder buf = new StringBuilder ( 128 ) ; MST[rv.CRCR6Mutator]MSP[S] buf . append ( '{' ) ; switch ( size ) { case 3 : buf . append ( key3 == this ? lr_9 : key3 ) ; buf . append ( '=' ) ;
if ( key2 == null ) { return true ; } case 1 : if ( key1 == null ) { return true ; } } } else { if ( size > 0 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] final int hashCode = key . hashCode () ; switch ( size ) {
if ( delegateMap != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] return delegateMap . remove ( key ) ; } if ( size == 0 ) { return null ; } if ( key == null ) { switch ( size ) { case 3 : if ( key3 == null ) {
if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[rv.ROR3Mutator]MSP[S] final V old = value3 ; value3 = value ;
return new EntrySet <> ( this ) ; MST[EmptyObjectReturnValsMutator]MSP[N] } @Override public int size () { return parent . size () ; } @Override public void clear () { parent . clear () ; } @Override public boolean remove ( final Object obj ) {
if ( delegateMap != null ) { return delegateMap . hashCode () ; } int total = 0 ; switch ( size ) { case 3 : total += hash3 ^ ( value3 == null ? 0 : value3 . hashCode () ) ; MST[rv.UOI2Mutator]MSP[S] case 2 :
hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; MST[ReturnValsMutator]MSP[S] } return null ; case 2 : if ( key2 == null ) { final V old = value2 ; hash2 = 0 ; key2 = null ;
public Set < K > keySet () { if ( delegateMap != null ) { return delegateMap . keySet () ; } return new KeySet <> ( this ) ; MST[ConstructorCallMutator]MSP[S] } @Override public int size () { return parent . size () ; } @Override public void clear () {
return old ; } case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.UOI3Mutator]MSP[N] final V old = value2 ; value2 = value ; return old ; } case 1 :
final V old = value2 ; hash2 = 0 ; key2 = null ; MST[experimental.MemberVariableMutator]MSP[S] value2 = null ; size = 1 ; return old ; } if ( hash1 == hashCode && key . equals ( key1 ) ) { final V old = value1 ; hash1 = hash2 ;
delegateMap . put ( key2 , value2 ) ; case 1 : delegateMap . put ( key1 , value1 ) ; case 0 : break; default: throw new IllegalStateException ( lr_1 + size ) ; } size = 0 ; hash1 = hash2 = hash3 = 0 ; MST[rv.CRCR5Mutator]MSP[S]
@Override public V get ( final Object key ) { if ( delegateMap != null ) { return delegateMap . get ( key ) ; } if ( key == null ) { switch ( size ) { MST[rv.ABSMutator]MSP[S] case 3 : if ( key3 == null ) {
if ( key2 == null ) { return true ; } case 1 : if ( key1 == null ) { MST[NegateConditionalsMutator]MSP[N] return true ; } } } else { if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) {
if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { MST[experimental.SwitchMutator]MSP[S] case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { final V old = value3 ; value3 = value ;
buf . append ( value2 == this ? lr_9 : value2 ) ; buf . append ( ',' ) ; MST[rv.CRCR4Mutator]MSP[N] case 1 : buf . append ( key1 == this ? lr_9 : key1 ) ; buf . append ( '=' ) ;
@Override public V get ( final Object key ) { if ( delegateMap != null ) { return delegateMap . get ( key ) ; } if ( key == null ) { switch ( size ) { case 3 : if ( key3 == null ) { MST[NegateConditionalsMutator]MSP[N]
throw new IllegalStateException ( lr_1 + size ) ; } return total ; MST[rv.UOI2Mutator]MSP[S] } @Override public String toString () { if ( delegateMap != null ) { return delegateMap . toString () ; } if ( size == 0 ) { return lr_8 ; }
key1 = key2 ; value1 = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; return old ; } return null ; case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S]
hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; MST[rv.CRCR4Mutator]MSP[N] return old ; } return null ; case 2 : if ( key2 == null ) { final V old = value2 ; hash2 = 0 ; key2 = null ;
if ( key2 == null ) { return true ; MST[rv.CRCR6Mutator]MSP[N] } case 1 : if ( key1 == null ) { return true ; } } } else { if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) {
if ( delegateMap != null ) { return delegateMap . containsKey ( key ) ; } if ( key == null ) { switch ( size ) { case 3 : if ( key3 == null ) { return true ; MST[rv.CRCR4Mutator]MSP[S] } case 2 :
if ( value1 == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return true ; } } } else { switch ( size ) { case 3 : if ( value . equals ( value3 ) ) { return true ; } case 2 : if ( value . equals ( value2 ) ) {
return false ; } otherValue = other . get ( key1 ) ; if ( value1 == null ? otherValue != null : ! value1 . equals ( otherValue ) ) { return false ; } } } return true ; MST[rv.CRCR2Mutator]MSP[N] } @Override public int hashCode () {
return; } if ( size < 4 ) { MST[ConditionalsBoundaryMutator]MSP[S] for ( final Map . Entry < ? extends K , ? extends V > entry : map . entrySet () ) { put ( entry . getKey () , entry . getValue () ) ; } } else {
value2 = null ; size = 1 ; MST[experimental.MemberVariableMutator]MSP[S] return old ; } if ( key1 == null ) { final V old = value1 ; hash1 = hash2 ; key1 = key2 ; value1 = value2 ; hash2 = 0 ; key2 = null ; value2 = null ;
if ( key2 == null ) { return true ; } case 1 : if ( key1 == null ) { return true ; MST[rv.CRCR5Mutator]MSP[N] } } } else { if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) {
if ( delegateMap != null ) { return delegateMap . hashCode () ; } int total = 0 ; switch ( size ) { case 3 : total += hash3 ^ ( value3 == null ? 0 : value3 . hashCode () ) ; MST[rv.CRCR3Mutator]MSP[S] case 2 :
if ( delegateMap != null ) { return delegateMap . containsKey ( key ) ; } if ( key == null ) { switch ( size ) { MST[rv.UOI1Mutator]MSP[N] case 3 : if ( key3 == null ) { return true ; } case 2 :
cloned . delegateMap = cloned . delegateMap . clone () ; } return cloned ; MST[ReturnValsMutator]MSP[S] } catch ( final CloneNotSupportedException ex ) { throw new InternalError () ; } } @Override public boolean equals ( final Object obj ) { if ( obj == this ) { return true ;
buf . append ( value3 == this ? lr_9 : value3 ) ; buf . append ( ',' ) ; case 2 : buf . append ( key2 == this ? lr_9 : key2 ) ; buf . append ( '=' ) ; MST[rv.CRCR2Mutator]MSP[N]
value2 = null ; size = 1 ; MST[rv.CRCR6Mutator]MSP[S] return old ; } if ( key1 == null ) { final V old = value1 ; hash1 = hash2 ; key1 = key2 ; value1 = value2 ; hash2 = 0 ; key2 = null ; value2 = null ;
if ( delegateMap != null ) { return delegateMap . containsKey ( key ) ; } if ( key == null ) { switch ( size ) { case 3 : if ( key3 == null ) { return true ; MST[BooleanFalseReturnValsMutator]MSP[N] } case 2 :
if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.ABSMutator]MSP[S] final V old = value1 ; value1 = value ; return old ; } } } } switch ( size ) { default: convertToMap () ; delegateMap . put ( key , value ) ;
final V old = value1 ; hash1 = 0 ; key1 = null ; value1 = null ; size = 0 ; MST[experimental.MemberVariableMutator]MSP[N] return old ; } } } } return null ; } @Override public void clear () { if ( delegateMap != null ) {
return null ; case 2 : hash3 = key == null ? 0 : key . hashCode () ; key3 = key ; value3 = value ; break; case 1 : hash2 = key == null ? 0 : key . hashCode () ; MST[rv.CRCR5Mutator]MSP[S] key2 = key ;
final V old = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; return old ; } if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] final V old = value1 ; hash1 = hash2 ;
if ( key2 == null ) { return true ; } case 1 : if ( key1 == null ) { MST[rv.ROR5Mutator]MSP[N] return true ; } } } else { if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) {
size = 1 ; return old ; } return null ; case 1 : if ( key1 == null ) { final V old = value1 ; hash1 = 0 ; MST[rv.CRCR5Mutator]MSP[S] key1 = null ; value1 = null ; size = 0 ; return old ; } }
delegateMap . put ( key2 , value2 ) ; case 1 : delegateMap . put ( key1 , value1 ) ; case 0 : break; default: throw new IllegalStateException ( lr_1 + size ) ; } size = 0 ; hash1 = hash2 = hash3 = 0 ; MST[experimental.MemberVariableMutator]MSP[S]
delegateMap . clear () ; delegateMap = null ; } else { size = 0 ; MST[rv.CRCR1Mutator]MSP[N] hash1 = hash2 = hash3 = 0 ; key1 = key2 = key3 = null ; value1 = value2 = value3 = null ; } } @Override
total += hash2 ^ ( value2 == null ? 0 : value2 . hashCode () ) ; case 1 : total += hash1 ^ ( value1 == null ? 0 : value1 . hashCode () ) ; MST[rv.AOR4Mutator]MSP[S] case 0 : break; default:
public int size () { if ( delegateMap != null ) { return delegateMap . size () ; } return size ; } @Override public boolean isEmpty () { return size () == 0 ; MST[rv.CRCR3Mutator]MSP[S] } @Override public boolean containsKey ( final Object key ) {
@Override public V get ( final Object key ) { if ( delegateMap != null ) { return delegateMap . get ( key ) ; MST[NullReturnValsMutator]MSP[S] } if ( key == null ) { switch ( size ) { case 3 : if ( key3 == null ) {
case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[NegateConditionalsMutator]MSP[S] return true ; } case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { return true ; } case 1 :
total += hash2 ^ ( value2 == null ? 0 : value2 . hashCode () ) ; MST[NonVoidMethodCallMutator]MSP[S] case 1 : total += hash1 ^ ( value1 == null ? 0 : value1 . hashCode () ) ; case 0 : break; default:
key1 = key3 ; value1 = value3 ; hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } return null ; case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.UOI4Mutator]MSP[N]
cloned . delegateMap = cloned . delegateMap . clone () ; } return cloned ; } catch ( final CloneNotSupportedException ex ) { throw new InternalError () ; } } @Override public boolean equals ( final Object obj ) { if ( obj == this ) { return true ; MST[rv.CRCR6Mutator]MSP[N]
return old ; } case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] final V old = value2 ; value2 = value ; return old ; } case 1 :
value2 = value3 ; MST[experimental.MemberVariableMutator]MSP[S] hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } if ( hash1 == hashCode && key . equals ( key1 ) ) { final V old = value1 ; hash1 = hash3 ;
if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[NonVoidMethodCallMutator]MSP[N] return value2 ; } case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { return value1 ; } } } } return null ; } @Override
final V old = value1 ; hash1 = 0 ; key1 = null ; value1 = null ; size = 0 ; return old ; } } } } return null ; } @Override public void clear () { if ( delegateMap != null ) { MST[rv.ROR5Mutator]MSP[S]
key1 = key2 ; value1 = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; return old ; } return null ; case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.ROR3Mutator]MSP[S]
public Collection < V > values () { if ( delegateMap != null ) { return delegateMap . values () ; } return new Values <> ( this ) ; MST[ConstructorCallMutator]MSP[N] } @Override public int size () { return parent . size () ; } @Override public void clear () {
if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[NonVoidMethodCallMutator]MSP[S] final V old = value1 ; value1 = value ; return old ; } } } } switch ( size ) { default: convertToMap () ; delegateMap . put ( key , value ) ;
return; } if ( size < 4 ) { MST[rv.CRCR3Mutator]MSP[N] for ( final Map . Entry < ? extends K , ? extends V > entry : map . entrySet () ) { put ( entry . getKey () , entry . getValue () ) ; } } else {
value2 = value ; break; case 0 : hash1 = key == null ? 0 : key . hashCode () ; MST[rv.ROR5Mutator]MSP[N] key1 = key ; value1 = value ; break; } size ++ ; return null ; } @Override
if ( value1 == null ) { return true ; } } } else { switch ( size ) { MST[experimental.SwitchMutator]MSP[N] case 3 : if ( value . equals ( value3 ) ) { return true ; } case 2 : if ( value . equals ( value2 ) ) {
total += hash2 ^ ( value2 == null ? 0 : value2 . hashCode () ) ; MST[NegateConditionalsMutator]MSP[S] case 1 : total += hash1 ^ ( value1 == null ? 0 : value1 . hashCode () ) ; case 0 : break; default:
} if ( delegateMap != null ) { MST[NegateConditionalsMutator]MSP[S] return delegateMap . equals ( obj ) ; } if ( obj instanceof Map == false ) { return false ; } final Map < ? , ? > other = ( Map < ? , ? > ) obj ;
if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.UOI3Mutator]MSP[N] return true ; } } } } return false ; } @Override public boolean containsValue ( final Object value ) { if ( delegateMap != null ) { return delegateMap . containsValue ( value ) ;
if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.ROR3Mutator]MSP[S] final V old = value1 ; value1 = value ; return old ; } } } } switch ( size ) { default: convertToMap () ; delegateMap . put ( key , value ) ;
if ( key2 == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] final V old = value2 ; value2 = value ; return old ; } case 1 : if ( key1 == null ) { final V old = value1 ; value1 = value ; return old ; } } } else {
public void putAll ( final Map < ? extends K , ? extends V > map ) { final int size = map . size () ; if ( size == 0 ) { MST[rv.ROR2Mutator]MSP[N] return; } if ( delegateMap != null ) { delegateMap . putAll ( map ) ;
if ( hash2 == hashCode && key . equals ( key2 ) ) { return value2 ; } case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return value1 ; } } } } return null ; } @Override
if ( hash2 == hashCode && key . equals ( key2 ) ) { return value2 ; } case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[NonVoidMethodCallMutator]MSP[N] return value1 ; } } } } return null ; } @Override
return true ; } case 1 : if ( value . equals ( value1 ) ) { return true ; } } } return false ; } @Override public V put ( final K key , final V value ) { if ( delegateMap != null ) { MST[rv.ROR5Mutator]MSP[S]
} if ( value == null ) { switch ( size ) { MST[rv.ABSMutator]MSP[N] case 3 : if ( value3 == null ) { return true ; } case 2 : if ( value2 == null ) { return true ; } case 1 :
key1 = key3 ; value1 = value3 ; hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } return null ; case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.UOI1Mutator]MSP[S]
final V old = value3 ; hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } if ( key2 == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] final V old = value2 ; hash2 = hash3 ; key2 = key3 ;
} if ( value == null ) { switch ( size ) { case 3 : if ( value3 == null ) { return true ; } case 2 : if ( value2 == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] return true ; } case 1 :
buf . append ( value3 == this ? lr_9 : value3 ) ; buf . append ( ',' ) ; MST[rv.CRCR4Mutator]MSP[S] case 2 : buf . append ( key2 == this ? lr_9 : key2 ) ; buf . append ( '=' ) ;
public int size () { if ( delegateMap != null ) { return delegateMap . size () ; } return size ; } @Override public boolean isEmpty () { return size () == 0 ; MST[NegateConditionalsMutator]MSP[N] } @Override public boolean containsKey ( final Object key ) {
delegateMap . clear () ; delegateMap = null ; } else { size = 0 ; hash1 = hash2 = hash3 = 0 ; MST[rv.CRCR6Mutator]MSP[S] key1 = key2 = key3 = null ; value1 = value2 = value3 = null ; } } @Override
return; } if ( size < 4 ) { MST[rv.CRCR6Mutator]MSP[S] for ( final Map . Entry < ? extends K , ? extends V > entry : map . entrySet () ) { put ( entry . getKey () , entry . getValue () ) ; } } else {
key1 = key2 ; value1 = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; MST[rv.CRCR2Mutator]MSP[N] return old ; } return null ; case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) {
throw new IllegalStateException ( lr_1 + size ) ; } return total ; } @Override public String toString () { if ( delegateMap != null ) { return delegateMap . toString () ; } if ( size == 0 ) { MST[NegateConditionalsMutator]MSP[N] return lr_8 ; }
case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[rv.ABSMutator]MSP[S] return true ; } case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { return true ; } case 1 :
key1 = key2 ; value1 = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; MST[experimental.MemberVariableMutator]MSP[S] size = 1 ; return old ; } return null ; case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) {
} else { if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[NonVoidMethodCallMutator]MSP[N] final V old = value3 ;
key1 = key2 ; value1 = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; return old ; } return null ; case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.ABSMutator]MSP[N]
final StringBuilder buf = new StringBuilder ( 128 ) ; buf . append ( '{' ) ; switch ( size ) { case 3 : buf . append ( key3 == this ? lr_9 : key3 ) ; buf . append ( '=' ) ; MST[rv.CRCR2Mutator]MSP[S]
total += hash2 ^ ( value2 == null ? 0 : value2 . hashCode () ) ; case 1 : total += hash1 ^ ( value1 == null ? 0 : value1 . hashCode () ) ; MST[MathMutator]MSP[S] case 0 : break; default:
return delegateMap . put ( key , value ) ; } if ( key == null ) { switch ( size ) { MST[rv.UOI3Mutator]MSP[N] case 3 : if ( key3 == null ) { final V old = value3 ; value3 = value ; return old ; } case 2 :
} else { if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[rv.UOI3Mutator]MSP[N] final V old = value3 ;
if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] final V old = value1 ; value1 = value ; return old ; } } } } switch ( size ) { default: convertToMap () ; delegateMap . put ( key , value ) ;
if ( key2 == null ) { return true ; } case 1 : if ( key1 == null ) { return true ; } } } else { if ( size > 0 ) { MST[rv.ROR5Mutator]MSP[N] final int hashCode = key . hashCode () ; switch ( size ) {
value2 = value3 ; hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; MST[NullReturnValsMutator]MSP[S] } if ( hash1 == hashCode && key . equals ( key1 ) ) { final V old = value1 ; hash1 = hash3 ;
delegateMap . clear () ; delegateMap = null ; } else { size = 0 ; hash1 = hash2 = hash3 = 0 ; key1 = key2 = key3 = null ; value1 = value2 = value3 = null ; MST[experimental.MemberVariableMutator]MSP[S] } } @Override
key1 = key3 ; value1 = value3 ; hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } return null ; case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[NegateConditionalsMutator]MSP[N]
if ( hash2 == hashCode && key . equals ( key2 ) ) { return value2 ; } case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.ROR3Mutator]MSP[S] return value1 ; } } } } return null ; } @Override
case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { return true ; } case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.ABSMutator]MSP[S] return true ; } case 1 :
final StringBuilder buf = new StringBuilder ( 128 ) ; MST[rv.CRCR3Mutator]MSP[S] buf . append ( '{' ) ; switch ( size ) { case 3 : buf . append ( key3 == this ? lr_9 : key3 ) ; buf . append ( '=' ) ;
if ( hash2 == hashCode && key . equals ( key2 ) ) { return value2 ; } case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.UOI2Mutator]MSP[S] return value1 ; } } } } return null ; } @Override
final V old = value3 ; hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; MST[NullReturnValsMutator]MSP[S] } if ( key2 == null ) { final V old = value2 ; hash2 = hash3 ; key2 = key3 ;
public MapIterator < K , V > mapIterator () { if ( delegateMap != null ) { return delegateMap . mapIterator () ; } if ( size == 0 ) { MST[rv.UOI3Mutator]MSP[N] return EmptyMapIterator . <K , V > emptyMapIterator () ; } return new FlatMapIterator <> ( this ) ;
if ( delegateMap != null ) { return delegateMap . hashCode () ; } int total = 0 ; switch ( size ) { case 3 : total += hash3 ^ ( value3 == null ? 0 : value3 . hashCode () ) ; MST[rv.ROR5Mutator]MSP[S] case 2 :
if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.ROR3Mutator]MSP[S] return value2 ; } case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { return value1 ; } } } } return null ; } @Override
if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return true ; } } } } return false ; } @Override public boolean containsValue ( final Object value ) { if ( delegateMap != null ) { return delegateMap . containsValue ( value ) ;
return old ; } case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.UOI2Mutator]MSP[S] final V old = value2 ; value2 = value ; return old ; } case 1 :
public MapIterator < K , V > mapIterator () { if ( delegateMap != null ) { return delegateMap . mapIterator () ; } if ( size == 0 ) { MST[rv.ROR4Mutator]MSP[S] return EmptyMapIterator . <K , V > emptyMapIterator () ; } return new FlatMapIterator <> ( this ) ;
throw new IllegalStateException ( lr_1 + size ) ; } return total ; } @Override public String toString () { if ( delegateMap != null ) { return delegateMap . toString () ; } if ( size == 0 ) { MST[rv.UOI4Mutator]MSP[N] return lr_8 ; }
value2 = value3 ; hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } if ( key1 == null ) { final V old = value1 ; hash1 = hash3 ; MST[rv.UOI1Mutator]MSP[S] key1 = key3 ; value1 = value3 ;
final int hashCode = key . hashCode () ; switch ( size ) { MST[rv.UOI4Mutator]MSP[N] case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { return value3 ; } case 2 :
if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.UOI2Mutator]MSP[S] return true ; } } } } return false ; } @Override public boolean containsValue ( final Object value ) { if ( delegateMap != null ) { return delegateMap . containsValue ( value ) ;
return lr_2 + getKey () + lr_3 + getValue () + lr_4 ; } return lr_5 ; } @Override public Set < Map . Entry < K , V > > entrySet () { if ( delegateMap != null ) { MST[rv.ROR5Mutator]MSP[S] return delegateMap . entrySet () ; }
final int hashCode = key . hashCode () ; MST[NonVoidMethodCallMutator]MSP[N] switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { return value3 ; } case 2 :
} else { if ( size > 0 ) { final int hashCode = key . hashCode () ; MST[NonVoidMethodCallMutator]MSP[N] switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { final V old = value3 ;
key1 = key2 = key3 = null ; value1 = value2 = value3 = null ; MST[experimental.MemberVariableMutator]MSP[S] } protected AbstractHashedMap < K , V > createDelegateMap () { return new HashedMap <> () ; } @Override public V remove ( final Object key ) {
if ( delegateMap != null ) { return delegateMap . containsKey ( key ) ; } if ( key == null ) { switch ( size ) { case 3 : if ( key3 == null ) { return true ; MST[ReturnValsMutator]MSP[N] } case 2 :
if ( key2 == null ) { return true ; MST[rv.CRCR3Mutator]MSP[S] } case 1 : if ( key1 == null ) { return true ; } } } else { if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) {
if ( delegateMap != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] return delegateMap . containsKey ( key ) ; } if ( key == null ) { switch ( size ) { case 3 : if ( key3 == null ) { return true ; } case 2 :
public void putAll ( final Map < ? extends K , ? extends V > map ) { final int size = map . size () ; if ( size == 0 ) { return; } if ( delegateMap != null ) { MST[NegateConditionalsMutator]MSP[S] delegateMap . putAll ( map ) ;
final V old = value1 ; hash1 = 0 ; MST[rv.CRCR1Mutator]MSP[S] key1 = null ; value1 = null ; size = 0 ; return old ; } } } } return null ; } @Override public void clear () { if ( delegateMap != null ) {
public void putAll ( final Map < ? extends K , ? extends V > map ) { final int size = map . size () ; if ( size == 0 ) { MST[rv.ROR5Mutator]MSP[N] return; } if ( delegateMap != null ) { delegateMap . putAll ( map ) ;
if ( size != other . size () ) { MST[NegateConditionalsMutator]MSP[N] return false ; } if ( size > 0 ) { Object otherValue = null ; switch ( size ) { case 3 : if ( other . containsKey ( key3 ) == false ) { return false ; }
hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.ROR4Mutator]MSP[N] final V old = value2 ; hash2 = hash3 ; key2 = key3 ;
if ( hash1 == hashCode && key . equals ( key1 ) ) { final V old = value1 ; value1 = value ; return old ; MST[ReturnValsMutator]MSP[S] } } } } switch ( size ) { default: convertToMap () ; delegateMap . put ( key , value ) ;
return old ; } case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.ROR3Mutator]MSP[S] final V old = value2 ; value2 = value ; return old ; } case 1 :
buf . append ( value1 == this ? lr_9 : value1 ) ; break; default: throw new IllegalStateException ( lr_1 + size ) ; } buf . append ( '}' ) ; MST[rv.CRCR5Mutator]MSP[N] return buf . toString () ; }
final V old = value1 ; hash1 = 0 ; key1 = null ; value1 = null ; size = 0 ; return old ; } } } } return null ; } @Override public void clear () { if ( delegateMap != null ) { MST[NegateConditionalsMutator]MSP[S]
if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.UOI2Mutator]MSP[N] return value2 ; } case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) { return value1 ; } } } } return null ; } @Override
if ( hash1 == hashCode && key . equals ( key1 ) ) { return true ; MST[rv.CRCR6Mutator]MSP[N] } } } } return false ; } @Override public boolean containsValue ( final Object value ) { if ( delegateMap != null ) { return delegateMap . containsValue ( value ) ;
hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } return null ; case 2 : if ( key2 == null ) { final V old = value2 ; hash2 = 0 ; MST[rv.CRCR1Mutator]MSP[S] key2 = null ;
if ( key2 == null ) { final V old = value2 ; value2 = value ; return old ; } case 1 : if ( key1 == null ) { MST[NegateConditionalsMutator]MSP[N] final V old = value1 ; value1 = value ; return old ; } } } else {
buf . append ( value3 == this ? lr_9 : value3 ) ; buf . append ( ',' ) ; MST[rv.CRCR1Mutator]MSP[S] case 2 : buf . append ( key2 == this ? lr_9 : key2 ) ; buf . append ( '=' ) ;
final V old = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; return old ; } if ( hash1 == hashCode && key . equals ( key1 ) ) { MST[rv.ROR3Mutator]MSP[S] final V old = value1 ; hash1 = hash2 ;
if ( delegateMap != null ) { return delegateMap . remove ( key ) ; } if ( size == 0 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return null ; } if ( key == null ) { switch ( size ) { case 3 : if ( key3 == null ) {
if ( delegateMap != null ) { return delegateMap . remove ( key ) ; } if ( size == 0 ) { return null ; } if ( key == null ) { MST[rv.ROR5Mutator]MSP[N] switch ( size ) { case 3 : if ( key3 == null ) {
final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[NonVoidMethodCallMutator]MSP[N] return value3 ; } case 2 :
if ( key2 == null ) { final V old = value2 ; value2 = value ; MST[experimental.MemberVariableMutator]MSP[S] return old ; } case 1 : if ( key1 == null ) { final V old = value1 ; value1 = value ; return old ; } } } else {
} if ( delegateMap != null ) { MST[rv.ROR5Mutator]MSP[S] return delegateMap . equals ( obj ) ; } if ( obj instanceof Map == false ) { return false ; } final Map < ? , ? > other = ( Map < ? , ? > ) obj ;
total += hash2 ^ ( value2 == null ? 0 : value2 . hashCode () ) ; MST[rv.UOI2Mutator]MSP[S] case 1 : total += hash1 ^ ( value1 == null ? 0 : value1 . hashCode () ) ; case 0 : break; default:
hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; MST[rv.CRCR3Mutator]MSP[N] return old ; } if ( hash2 == hashCode && key . equals ( key2 ) ) { final V old = value2 ; hash2 = hash3 ; key2 = key3 ;
} if ( delegateMap != null ) { return delegateMap . equals ( obj ) ; } if ( obj instanceof Map == false ) { MST[NegateConditionalsMutator]MSP[N] return false ; } final Map < ? , ? > other = ( Map < ? , ? > ) obj ;
return null ; case 2 : hash3 = key == null ? 0 : key . hashCode () ; key3 = key ; value3 = value ; break; case 1 : hash2 = key == null ? 0 : key . hashCode () ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] key2 = key ;
final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[rv.ROR3Mutator]MSP[S] return value3 ; } case 2 :
return lr_2 + getKey () + lr_3 + getValue () + lr_4 ; } return lr_5 ; } @Override public Set < Map . Entry < K , V > > entrySet () { if ( delegateMap != null ) { MST[NegateConditionalsMutator]MSP[S] return delegateMap . entrySet () ; }
if ( key2 == null ) { return true ; } case 1 : if ( key1 == null ) { return true ; } } } else { if ( size > 0 ) { MST[NegateConditionalsMutator]MSP[N] final int hashCode = key . hashCode () ; switch ( size ) {
cloned . delegateMap = cloned . delegateMap . clone () ; } return cloned ; } catch ( final CloneNotSupportedException ex ) { throw new InternalError () ; } } @Override public boolean equals ( final Object obj ) { if ( obj == this ) { return true ; MST[rv.CRCR3Mutator]MSP[S]
key1 = key2 ; MST[experimental.MemberVariableMutator]MSP[S] value1 = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; return old ; } return null ; case 1 : if ( hash1 == hashCode && key . equals ( key1 ) ) {
return value3 ; } case 2 : if ( key2 == null ) { return value2 ; } case 1 : if ( key1 == null ) { return value1 ; } } } else { if ( size > 0 ) { MST[rv.ROR3Mutator]MSP[N]
public int size () { if ( delegateMap != null ) { return delegateMap . size () ; } return size ; } @Override public boolean isEmpty () { return size () == 0 ; MST[rv.CRCR3Mutator]MSP[N] } @Override public boolean containsKey ( final Object key ) {
if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[rv.UOI3Mutator]MSP[S] final V old = value3 ; value3 = value ;
public void putAll ( final Map < ? extends K , ? extends V > map ) { final int size = map . size () ; if ( size == 0 ) { MST[rv.UOI4Mutator]MSP[N] return; } if ( delegateMap != null ) { delegateMap . putAll ( map ) ;
if ( size != other . size () ) { MST[rv.ROR5Mutator]MSP[N] return false ; } if ( size > 0 ) { Object otherValue = null ; switch ( size ) { case 3 : if ( other . containsKey ( key3 ) == false ) { return false ; }
value2 = value ; break; case 0 : hash1 = key == null ? 0 : key . hashCode () ; MST[NegateConditionalsMutator]MSP[N] key1 = key ; value1 = value ; break; } size ++ ; return null ; } @Override
final StringBuilder buf = new StringBuilder ( 128 ) ; buf . append ( '{' ) ; MST[rv.CRCR5Mutator]MSP[N] switch ( size ) { case 3 : buf . append ( key3 == this ? lr_9 : key3 ) ; buf . append ( '=' ) ;
return true ; } case 1 : if ( value . equals ( value1 ) ) { return true ; } } } return false ; } @Override public V put ( final K key , final V value ) { if ( delegateMap != null ) { MST[NegateConditionalsMutator]MSP[S]
final V old = value2 ; hash2 = 0 ; MST[rv.CRCR3Mutator]MSP[S] key2 = null ; value2 = null ; size = 1 ; return old ; } if ( hash1 == hashCode && key . equals ( key1 ) ) { final V old = value1 ; hash1 = hash2 ;
value2 = value ; break; case 0 : hash1 = key == null ? 0 : key . hashCode () ; key1 = key ; value1 = value ; break; } size ++ ; MST[rv.AOR4Mutator]MSP[N] return null ; } @Override
hash3 = 0 ; MST[InlineConstantMutator]MSP[S] key3 = null ; value3 = null ; size = 2 ; return old ; } if ( hash2 == hashCode && key . equals ( key2 ) ) { final V old = value2 ; hash2 = hash3 ; key2 = key3 ;
total += hash2 ^ ( value2 == null ? 0 : value2 . hashCode () ) ; case 1 : total += hash1 ^ ( value1 == null ? 0 : value1 . hashCode () ) ; MST[NonVoidMethodCallMutator]MSP[S] case 0 : break; default:
throw new IllegalStateException ( lr_1 + size ) ; } return total ; } @Override public String toString () { if ( delegateMap != null ) { return delegateMap . toString () ; } if ( size == 0 ) { MST[rv.ROR5Mutator]MSP[N] return lr_8 ; }
if ( key2 == null ) { return true ; } case 1 : if ( key1 == null ) { return true ; } } } else { if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { MST[experimental.RemoveSwitchMutator_2]MSP[S]
if ( key2 == null ) { return true ; } case 1 : if ( key1 == null ) { return true ; } } } else { if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { MST[experimental.RemoveSwitchMutator_1]MSP[S]
if ( key2 == null ) { return true ; } case 1 : if ( key1 == null ) { return true ; } } } else { if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { MST[experimental.RemoveSwitchMutator_0]MSP[N]
public Flat3Map < K , V > clone () { try { final Flat3Map < K , V > cloned = ( Flat3Map < K , V > ) super . clone () ; MST[NonVoidMethodCallMutator]MSP[S] if ( cloned . delegateMap != null ) {
value2 = value ; break; case 0 : hash1 = key == null ? 0 : key . hashCode () ; MST[rv.CRCR3Mutator]MSP[S] key1 = key ; value1 = value ; break; } size ++ ; return null ; } @Override
if ( size != other . size () ) { MST[rv.UOI2Mutator]MSP[S] return false ; } if ( size > 0 ) { Object otherValue = null ; switch ( size ) { case 3 : if ( other . containsKey ( key3 ) == false ) { return false ; }
key1 = key3 ; value1 = value3 ; hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } return null ; case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.ROR5Mutator]MSP[N]
if ( size > 0 ) { MST[ConditionalsBoundaryMutator]MSP[S] final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { final V old = value3 ; value3 = value ;
public MapIterator < K , V > mapIterator () { if ( delegateMap != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] return delegateMap . mapIterator () ; } if ( size == 0 ) { return EmptyMapIterator . <K , V > emptyMapIterator () ; } return new FlatMapIterator <> ( this ) ;
return true ; } case 1 : if ( value . equals ( value1 ) ) { MST[rv.ROR4Mutator]MSP[S] return true ; } } } return false ; } @Override public V put ( final K key , final V value ) { if ( delegateMap != null ) {
total += hash2 ^ ( value2 == null ? 0 : value2 . hashCode () ) ; MST[MathMutator]MSP[S] case 1 : total += hash1 ^ ( value1 == null ? 0 : value1 . hashCode () ) ; case 0 : break; default:
buf . append ( value2 == this ? lr_9 : value2 ) ; buf . append ( ',' ) ; case 1 : buf . append ( key1 == this ? lr_9 : key1 ) ; buf . append ( '=' ) ; MST[rv.CRCR2Mutator]MSP[N]
case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[rv.ROR5Mutator]MSP[S] return true ; } case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { return true ; } case 1 :
final V old = value2 ; hash2 = 0 ; key2 = null ; value2 = null ; size = 1 ; MST[InlineConstantMutator]MSP[N] return old ; } if ( hash1 == hashCode && key . equals ( key1 ) ) { final V old = value1 ; hash1 = hash2 ;
if ( hash1 == hashCode && key . equals ( key1 ) ) { final V old = value1 ; value1 = value ; return old ; } } } } switch ( size ) { MST[rv.UOI2Mutator]MSP[N] default: convertToMap () ; delegateMap . put ( key , value ) ;
hash3 = 0 ; MST[experimental.MemberVariableMutator]MSP[S] key3 = null ; value3 = null ; size = 2 ; return old ; } return null ; case 2 : if ( key2 == null ) { final V old = value2 ; hash2 = 0 ; key2 = null ;
if ( size != other . size () ) { return false ; MST[rv.CRCR5Mutator]MSP[N] } if ( size > 0 ) { Object otherValue = null ; switch ( size ) { case 3 : if ( other . containsKey ( key3 ) == false ) { return false ; }
return; } if ( size < 4 ) { for ( final Map . Entry < ? extends K , ? extends V > entry : map . entrySet () ) { MST[NonVoidMethodCallMutator]MSP[S] put ( entry . getKey () , entry . getValue () ) ; } } else {
} if ( value == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] switch ( size ) { case 3 : if ( value3 == null ) { return true ; } case 2 : if ( value2 == null ) { return true ; } case 1 :
case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { return true ; } case 2 : if ( hash2 == hashCode && key . equals ( key2 ) ) { MST[rv.UOI2Mutator]MSP[S] return true ; } case 1 :
if ( delegateMap != null ) { return delegateMap . hashCode () ; } int total = 0 ; switch ( size ) { MST[rv.UOI4Mutator]MSP[N] case 3 : total += hash3 ^ ( value3 == null ? 0 : value3 . hashCode () ) ; case 2 :
return; } if ( size < 4 ) { MST[rv.ROR3Mutator]MSP[S] for ( final Map . Entry < ? extends K , ? extends V > entry : map . entrySet () ) { put ( entry . getKey () , entry . getValue () ) ; } } else {
value2 = value3 ; hash3 = 0 ; key3 = null ; value3 = null ; size = 2 ; return old ; } if ( key1 == null ) { final V old = value1 ; hash1 = hash3 ; MST[experimental.MemberVariableMutator]MSP[S] key1 = key3 ; value1 = value3 ;
if ( delegateMap != null ) { return delegateMap . hashCode () ; } int total = 0 ; switch ( size ) { case 3 : total += hash3 ^ ( value3 == null ? 0 : value3 . hashCode () ) ; MST[NegateConditionalsMutator]MSP[S] case 2 :
} else { if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[rv.UOI2Mutator]MSP[N] final V old = value3 ;
@Override public V get ( final Object key ) { if ( delegateMap != null ) { return delegateMap . get ( key ) ; } if ( key == null ) { switch ( size ) { MST[experimental.SwitchMutator]MSP[S] case 3 : if ( key3 == null ) {
if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { MST[rv.UOI1Mutator]MSP[N] case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { final V old = value3 ; value3 = value ;
final StringBuilder buf = new StringBuilder ( 128 ) ; buf . append ( '{' ) ; switch ( size ) { MST[experimental.RemoveSwitchMutator_1]MSP[S] case 3 : buf . append ( key3 == this ? lr_9 : key3 ) ; buf . append ( '=' ) ;
final StringBuilder buf = new StringBuilder ( 128 ) ; buf . append ( '{' ) ; switch ( size ) { MST[experimental.RemoveSwitchMutator_0]MSP[S] case 3 : buf . append ( key3 == this ? lr_9 : key3 ) ; buf . append ( '=' ) ;
final StringBuilder buf = new StringBuilder ( 128 ) ; buf . append ( '{' ) ; switch ( size ) { MST[experimental.RemoveSwitchMutator_2]MSP[S] case 3 : buf . append ( key3 == this ? lr_9 : key3 ) ; buf . append ( '=' ) ;
if ( size > 0 ) { final int hashCode = key . hashCode () ; switch ( size ) { case 3 : if ( hash3 == hashCode && key . equals ( key3 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] final V old = value3 ; value3 = value ;
if ( parent . size () == 0 ) { MST[rv.ROR4Mutator]MSP[N] return EmptyIterator . <K > emptyIterator () ; } return new KeySetIterator <> ( parent ) ; } @Override public K next () { return nextEntry () . getKey () ; } @Override
if ( parent . size () == 0 ) { MST[rv.ROR5Mutator]MSP[N] return EmptyIterator . <K > emptyIterator () ; } return new KeySetIterator <> ( parent ) ; } @Override public K next () { return nextEntry () . getKey () ; } @Override
if ( parent . size () == 0 ) { MST[NegateConditionalsMutator]MSP[N] return EmptyIterator . <K > emptyIterator () ; } return new KeySetIterator <> ( parent ) ; } @Override public K next () { return nextEntry () . getKey () ; } @Override
parent . clear () ; } @Override public boolean contains ( final Object key ) { return parent . containsKey ( key ) ; MST[NonVoidMethodCallMutator]MSP[S] } @Override public boolean remove ( final Object key ) { final boolean result = parent . containsKey ( key ) ;
if ( parent . size () == 0 ) { MST[rv.ROR1Mutator]MSP[N] return EmptyIterator . <K > emptyIterator () ; } return new KeySetIterator <> ( parent ) ; } @Override public K next () { return nextEntry () . getKey () ; } @Override
parent . clear () ; } @Override public boolean contains ( final Object key ) { return parent . containsKey ( key ) ; MST[ReturnValsMutator]MSP[N] } @Override public boolean remove ( final Object key ) { final boolean result = parent . containsKey ( key ) ;
parent . remove ( key ) ; return result ; } @Override public Iterator < K > iterator () { if ( parent . delegateMap != null ) { MST[NonVoidMethodCallMutator]MSP[N] return parent . delegateMap . keySet () . iterator () ; }
parent . clear () ; } @Override public boolean contains ( final Object key ) { return parent . containsKey ( key ) ; MST[BooleanTrueReturnValsMutator]MSP[S] } @Override public boolean remove ( final Object key ) { final boolean result = parent . containsKey ( key ) ;
if ( parent . size () == 0 ) { MST[rv.ROR2Mutator]MSP[N] return EmptyIterator . <K > emptyIterator () ; } return new KeySetIterator <> ( parent ) ; } @Override public K next () { return nextEntry () . getKey () ; } @Override
if ( parent . size () == 0 ) { MST[rv.ROR3Mutator]MSP[N] return EmptyIterator . <K > emptyIterator () ; } return new KeySetIterator <> ( parent ) ; } @Override public K next () { return nextEntry () . getKey () ; } @Override
parent . clear () ; } @Override public boolean contains ( final Object key ) { return parent . containsKey ( key ) ; MST[BooleanFalseReturnValsMutator]MSP[S] } @Override public boolean remove ( final Object key ) { final boolean result = parent . containsKey ( key ) ;
public Set < K > keySet () { if ( delegateMap != null ) { return delegateMap . keySet () ; } return new KeySet <> ( this ) ; } @Override public int size () { return parent . size () ; MST[PrimitiveReturnsMutator]MSP[S] } @Override public void clear () {
parent . remove ( key ) ; return result ; MST[ReturnValsMutator]MSP[S] } @Override public Iterator < K > iterator () { if ( parent . delegateMap != null ) { return parent . delegateMap . keySet () . iterator () ; }
if ( parent . size () == 0 ) { MST[NonVoidMethodCallMutator]MSP[N] return EmptyIterator . <K > emptyIterator () ; } return new KeySetIterator <> ( parent ) ; } @Override public K next () { return nextEntry () . getKey () ; } @Override
public Set < K > keySet () { if ( delegateMap != null ) { return delegateMap . keySet () ; } return new KeySet <> ( this ) ; } @Override public int size () { return parent . size () ; MST[NonVoidMethodCallMutator]MSP[S] } @Override public void clear () {
if ( parent . size () == 0 ) { return EmptyIterator . <K > emptyIterator () ; MST[NonVoidMethodCallMutator]MSP[N] } return new KeySetIterator <> ( parent ) ; } @Override public K next () { return nextEntry () . getKey () ; } @Override
parent . remove ( key ) ; return result ; MST[BooleanFalseReturnValsMutator]MSP[N] } @Override public Iterator < K > iterator () { if ( parent . delegateMap != null ) { return parent . delegateMap . keySet () . iterator () ; }
parent . remove ( key ) ; return result ; } @Override public Iterator < K > iterator () { if ( parent . delegateMap != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] return parent . delegateMap . keySet () . iterator () ; }
if ( parent . size () == 0 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return EmptyIterator . <K > emptyIterator () ; } return new KeySetIterator <> ( parent ) ; } @Override public K next () { return nextEntry () . getKey () ; } @Override
parent . remove ( key ) ; MST[NonVoidMethodCallMutator]MSP[N] return result ; } @Override public Iterator < K > iterator () { if ( parent . delegateMap != null ) { return parent . delegateMap . keySet () . iterator () ; }
if ( parent . size () == 0 ) { return EmptyIterator . <K > emptyIterator () ; MST[ReturnValsMutator]MSP[N] } return new KeySetIterator <> ( parent ) ; } @Override public K next () { return nextEntry () . getKey () ; } @Override
parent . clear () ; } @Override public boolean contains ( final Object key ) { return parent . containsKey ( key ) ; } @Override public boolean remove ( final Object key ) { final boolean result = parent . containsKey ( key ) ; MST[NonVoidMethodCallMutator]MSP[N]
parent . remove ( key ) ; return result ; MST[rv.ABSMutator]MSP[N] } @Override public Iterator < K > iterator () { if ( parent . delegateMap != null ) { return parent . delegateMap . keySet () . iterator () ; }
if ( parent . size () == 0 ) { return EmptyIterator . <K > emptyIterator () ; } return new KeySetIterator <> ( parent ) ; MST[NullReturnValsMutator]MSP[N] } @Override public K next () { return nextEntry () . getKey () ; } @Override
parent . clear () ; MST[VoidMethodCallMutator]MSP[N] } @Override public boolean contains ( final Object key ) { return parent . containsKey ( key ) ; } @Override public boolean remove ( final Object key ) { final boolean result = parent . containsKey ( key ) ;
if ( parent . size () == 0 ) { return EmptyIterator . <K > emptyIterator () ; } return new KeySetIterator <> ( parent ) ; MST[ReturnValsMutator]MSP[N] } @Override public K next () { return nextEntry () . getKey () ; } @Override
parent . remove ( key ) ; return result ; } @Override public Iterator < K > iterator () { if ( parent . delegateMap != null ) { MST[rv.ROR5Mutator]MSP[S] return parent . delegateMap . keySet () . iterator () ; }
if ( parent . size () == 0 ) { return EmptyIterator . <K > emptyIterator () ; MST[NullReturnValsMutator]MSP[N] } return new KeySetIterator <> ( parent ) ; } @Override public K next () { return nextEntry () . getKey () ; } @Override
public Set < K > keySet () { if ( delegateMap != null ) { return delegateMap . keySet () ; } return new KeySet <> ( this ) ; } @Override public int size () { return parent . size () ; MST[ReturnValsMutator]MSP[N] } @Override public void clear () {
parent . remove ( key ) ; return result ; } @Override public Iterator < K > iterator () { if ( parent . delegateMap != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return parent . delegateMap . keySet () . iterator () ; }
if ( parent . size () == 0 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return EmptyIterator . <K > emptyIterator () ; } return new KeySetIterator <> ( parent ) ; } @Override public K next () { return nextEntry () . getKey () ; } @Override
parent . remove ( key ) ; return result ; MST[BooleanTrueReturnValsMutator]MSP[S] } @Override public Iterator < K > iterator () { if ( parent . delegateMap != null ) { return parent . delegateMap . keySet () . iterator () ; }
parent . remove ( key ) ; return result ; MST[rv.UOI4Mutator]MSP[S] } @Override public Iterator < K > iterator () { if ( parent . delegateMap != null ) { return parent . delegateMap . keySet () . iterator () ; }
parent . remove ( key ) ; return result ; MST[rv.UOI3Mutator]MSP[S] } @Override public Iterator < K > iterator () { if ( parent . delegateMap != null ) { return parent . delegateMap . keySet () . iterator () ; }
parent . remove ( key ) ; return result ; MST[rv.UOI2Mutator]MSP[N] } @Override public Iterator < K > iterator () { if ( parent . delegateMap != null ) { return parent . delegateMap . keySet () . iterator () ; }
parent . remove ( key ) ; return result ; MST[rv.UOI1Mutator]MSP[N] } @Override public Iterator < K > iterator () { if ( parent . delegateMap != null ) { return parent . delegateMap . keySet () . iterator () ; }
parent . remove ( key ) ; return result ; } @Override public Iterator < K > iterator () { if ( parent . delegateMap != null ) { MST[NegateConditionalsMutator]MSP[S] return parent . delegateMap . keySet () . iterator () ; }
if ( parent . size () == 0 ) { return EmptyIterator . <K > emptyIterator () ; } return new KeySetIterator <> ( parent ) ; MST[ConstructorCallMutator]MSP[N] } @Override public K next () { return nextEntry () . getKey () ; } @Override
parent . remove ( key ) ; MST[ArgumentPropagationMutator]MSP[N] return result ; } @Override public Iterator < K > iterator () { if ( parent . delegateMap != null ) { return parent . delegateMap . keySet () . iterator () ; }
return getKey () + lr_3 + getValue () ; } return lr_6 ; } public boolean hasNext () { return nextIndex < parent . size ; MST[InlineConstantMutator]MSP[N] } public Map . Entry < K , V > nextEntry () { if ( ! hasNext () ) {
throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } currentEntry = new FlatMapEntry <> ( parent , ++ nextIndex ) ; MST[rv.ABSMutator]MSP[S] return currentEntry ; } public void remove () { if ( currentEntry == null ) { throw new IllegalStateException ( AbstractHashedMap . REMOVE_INVALID ) ; }
return getKey () + lr_3 + getValue () ; } return lr_6 ; } public boolean hasNext () { return nextIndex < parent . size ; MST[rv.ROR5Mutator]MSP[N] } public Map . Entry < K , V > nextEntry () { if ( ! hasNext () ) {
return getKey () + lr_3 + getValue () ; } return lr_6 ; } public boolean hasNext () { return nextIndex < parent . size ; MST[rv.UOI1Mutator]MSP[N] } public Map . Entry < K , V > nextEntry () { if ( ! hasNext () ) {
parent . remove ( currentEntry . getKey () ) ; currentEntry . setRemoved ( true ) ; nextIndex -- ; MST[rv.CRCR6Mutator]MSP[N] currentEntry = null ; } @Override public Map . Entry < K , V > next () { return nextEntry () ; } @Override
return getKey () + lr_3 + getValue () ; } return lr_6 ; } public boolean hasNext () { return nextIndex < parent . size ; MST[InlineConstantMutator]MSP[N] } public Map . Entry < K , V > nextEntry () { if ( ! hasNext () ) {
return getKey () + lr_3 + getValue () ; } return lr_6 ; } public boolean hasNext () { return nextIndex < parent . size ; MST[rv.ROR4Mutator]MSP[N] } public Map . Entry < K , V > nextEntry () { if ( ! hasNext () ) {
throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } currentEntry = new FlatMapEntry <> ( parent , ++ nextIndex ) ; MST[ConstructorCallMutator]MSP[S] return currentEntry ; } public void remove () { if ( currentEntry == null ) { throw new IllegalStateException ( AbstractHashedMap . REMOVE_INVALID ) ; }
parent . remove ( currentEntry . getKey () ) ; currentEntry . setRemoved ( true ) ; nextIndex -- ; MST[rv.CRCR5Mutator]MSP[S] currentEntry = null ; } @Override public Map . Entry < K , V > next () { return nextEntry () ; } @Override
return getKey () + lr_3 + getValue () ; } return lr_6 ; } public boolean hasNext () { return nextIndex < parent . size ; MST[rv.UOI3Mutator]MSP[N] } public Map . Entry < K , V > nextEntry () { if ( ! hasNext () ) {
parent . remove ( currentEntry . getKey () ) ; currentEntry . setRemoved ( true ) ; nextIndex -- ; MST[rv.CRCR4Mutator]MSP[N] currentEntry = null ; } @Override public Map . Entry < K , V > next () { return nextEntry () ; } @Override
return getKey () + lr_3 + getValue () ; } return lr_6 ; } public boolean hasNext () { return nextIndex < parent . size ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] } public Map . Entry < K , V > nextEntry () { if ( ! hasNext () ) {
return getKey () + lr_3 + getValue () ; } return lr_6 ; } public boolean hasNext () { return nextIndex < parent . size ; MST[rv.UOI2Mutator]MSP[S] } public Map . Entry < K , V > nextEntry () { if ( ! hasNext () ) {
return getKey () + lr_3 + getValue () ; } return lr_6 ; } public boolean hasNext () { return nextIndex < parent . size ; MST[rv.UOI4Mutator]MSP[N] } public Map . Entry < K , V > nextEntry () { if ( ! hasNext () ) {
throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } currentEntry = new FlatMapEntry <> ( parent , ++ nextIndex ) ; MST[experimental.MemberVariableMutator]MSP[S] return currentEntry ; } public void remove () { if ( currentEntry == null ) { throw new IllegalStateException ( AbstractHashedMap . REMOVE_INVALID ) ; }
parent . remove ( currentEntry . getKey () ) ; currentEntry . setRemoved ( true ) ; nextIndex -- ; MST[rv.AOD1Mutator]MSP[N] currentEntry = null ; } @Override public Map . Entry < K , V > next () { return nextEntry () ; } @Override
parent . remove ( currentEntry . getKey () ) ; currentEntry . setRemoved ( true ) ; nextIndex -- ; MST[rv.AOD2Mutator]MSP[N] currentEntry = null ; } @Override public Map . Entry < K , V > next () { return nextEntry () ; } @Override
parent . remove ( currentEntry . getKey () ) ; MST[NonVoidMethodCallMutator]MSP[S] currentEntry . setRemoved ( true ) ; nextIndex -- ; currentEntry = null ; } @Override public Map . Entry < K , V > next () { return nextEntry () ; } @Override
parent . remove ( currentEntry . getKey () ) ; currentEntry . setRemoved ( true ) ; nextIndex -- ; MST[rv.CRCR3Mutator]MSP[N] currentEntry = null ; } @Override public Map . Entry < K , V > next () { return nextEntry () ; } @Override
parent . remove ( currentEntry . getKey () ) ; currentEntry . setRemoved ( true ) ; nextIndex -- ; MST[rv.CRCR2Mutator]MSP[N] currentEntry = null ; } @Override public Map . Entry < K , V > next () { return nextEntry () ; } @Override
return getKey () + lr_3 + getValue () ; } return lr_6 ; } public boolean hasNext () { return nextIndex < parent . size ; MST[ConditionalsBoundaryMutator]MSP[N] } public Map . Entry < K , V > nextEntry () { if ( ! hasNext () ) {
return getKey () + lr_3 + getValue () ; } return lr_6 ; } public boolean hasNext () { return nextIndex < parent . size ; MST[BooleanTrueReturnValsMutator]MSP[N] } public Map . Entry < K , V > nextEntry () { if ( ! hasNext () ) {
throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } currentEntry = new FlatMapEntry <> ( parent , ++ nextIndex ) ; MST[rv.AOR3Mutator]MSP[S] return currentEntry ; } public void remove () { if ( currentEntry == null ) { throw new IllegalStateException ( AbstractHashedMap . REMOVE_INVALID ) ; }
throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } currentEntry = new FlatMapEntry <> ( parent , ++ nextIndex ) ; return currentEntry ; } public void remove () { if ( currentEntry == null ) { throw new IllegalStateException ( AbstractHashedMap . REMOVE_INVALID ) ; MST[ConstructorCallMutator]MSP[S] }
return getKey () + lr_3 + getValue () ; } return lr_6 ; } public boolean hasNext () { return nextIndex < parent . size ; MST[ReturnValsMutator]MSP[N] } public Map . Entry < K , V > nextEntry () { if ( ! hasNext () ) {
throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } currentEntry = new FlatMapEntry <> ( parent , ++ nextIndex ) ; MST[rv.AOD2Mutator]MSP[N] return currentEntry ; } public void remove () { if ( currentEntry == null ) { throw new IllegalStateException ( AbstractHashedMap . REMOVE_INVALID ) ; }
return getKey () + lr_3 + getValue () ; } return lr_6 ; } public boolean hasNext () { return nextIndex < parent . size ; MST[rv.ROR2Mutator]MSP[N] } public Map . Entry < K , V > nextEntry () { if ( ! hasNext () ) {
throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } currentEntry = new FlatMapEntry <> ( parent , ++ nextIndex ) ; MST[rv.UOI1Mutator]MSP[N] return currentEntry ; } public void remove () { if ( currentEntry == null ) { throw new IllegalStateException ( AbstractHashedMap . REMOVE_INVALID ) ; }
throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } currentEntry = new FlatMapEntry <> ( parent , ++ nextIndex ) ; MST[rv.AOR1Mutator]MSP[S] return currentEntry ; } public void remove () { if ( currentEntry == null ) { throw new IllegalStateException ( AbstractHashedMap . REMOVE_INVALID ) ; }
throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } currentEntry = new FlatMapEntry <> ( parent , ++ nextIndex ) ; return currentEntry ; } public void remove () { if ( currentEntry == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] throw new IllegalStateException ( AbstractHashedMap . REMOVE_INVALID ) ; }
throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } currentEntry = new FlatMapEntry <> ( parent , ++ nextIndex ) ; MST[rv.UOI3Mutator]MSP[N] return currentEntry ; } public void remove () { if ( currentEntry == null ) { throw new IllegalStateException ( AbstractHashedMap . REMOVE_INVALID ) ; }
parent . remove ( currentEntry . getKey () ) ; currentEntry . setRemoved ( true ) ; nextIndex -- ; currentEntry = null ; MST[experimental.MemberVariableMutator]MSP[N] } @Override public Map . Entry < K , V > next () { return nextEntry () ; } @Override
parent . remove ( currentEntry . getKey () ) ; MST[NonVoidMethodCallMutator]MSP[S] currentEntry . setRemoved ( true ) ; nextIndex -- ; currentEntry = null ; } @Override public Map . Entry < K , V > next () { return nextEntry () ; } @Override
parent . remove ( currentEntry . getKey () ) ; currentEntry . setRemoved ( true ) ; nextIndex -- ; MST[rv.ABSMutator]MSP[S] currentEntry = null ; } @Override public Map . Entry < K , V > next () { return nextEntry () ; } @Override
parent . remove ( currentEntry . getKey () ) ; currentEntry . setRemoved ( true ) ; MST[rv.CRCR3Mutator]MSP[N] nextIndex -- ; currentEntry = null ; } @Override public Map . Entry < K , V > next () { return nextEntry () ; } @Override
return getKey () + lr_3 + getValue () ; } return lr_6 ; } public boolean hasNext () { return nextIndex < parent . size ; MST[NegateConditionalsMutator]MSP[N] } public Map . Entry < K , V > nextEntry () { if ( ! hasNext () ) {
parent . remove ( currentEntry . getKey () ) ; currentEntry . setRemoved ( true ) ; MST[rv.CRCR4Mutator]MSP[N] nextIndex -- ; currentEntry = null ; } @Override public Map . Entry < K , V > next () { return nextEntry () ; } @Override
throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } currentEntry = new FlatMapEntry <> ( parent , ++ nextIndex ) ; MST[rv.CRCR2Mutator]MSP[S] return currentEntry ; } public void remove () { if ( currentEntry == null ) { throw new IllegalStateException ( AbstractHashedMap . REMOVE_INVALID ) ; }
return getKey () + lr_3 + getValue () ; } return lr_6 ; } public boolean hasNext () { return nextIndex < parent . size ; } public Map . Entry < K , V > nextEntry () { if ( ! hasNext () ) { MST[rv.ROR2Mutator]MSP[N]
return getKey () + lr_3 + getValue () ; } return lr_6 ; } public boolean hasNext () { return nextIndex < parent . size ; } public Map . Entry < K , V > nextEntry () { if ( ! hasNext () ) { MST[rv.ROR1Mutator]MSP[S]
throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } currentEntry = new FlatMapEntry <> ( parent , ++ nextIndex ) ; MST[rv.CRCR5Mutator]MSP[N] return currentEntry ; } public void remove () { if ( currentEntry == null ) { throw new IllegalStateException ( AbstractHashedMap . REMOVE_INVALID ) ; }
throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } currentEntry = new FlatMapEntry <> ( parent , ++ nextIndex ) ; MST[rv.CRCR6Mutator]MSP[S] return currentEntry ; } public void remove () { if ( currentEntry == null ) { throw new IllegalStateException ( AbstractHashedMap . REMOVE_INVALID ) ; }
return getKey () + lr_3 + getValue () ; } return lr_6 ; } public boolean hasNext () { return nextIndex < parent . size ; MST[rv.CRCR3Mutator]MSP[N] } public Map . Entry < K , V > nextEntry () { if ( ! hasNext () ) {
parent . remove ( currentEntry . getKey () ) ; currentEntry . setRemoved ( true ) ; MST[InlineConstantMutator]MSP[N] nextIndex -- ; currentEntry = null ; } @Override public Map . Entry < K , V > next () { return nextEntry () ; } @Override
parent . remove ( currentEntry . getKey () ) ; MST[ArgumentPropagationMutator]MSP[S] currentEntry . setRemoved ( true ) ; nextIndex -- ; currentEntry = null ; } @Override public Map . Entry < K , V > next () { return nextEntry () ; } @Override
parent . remove ( currentEntry . getKey () ) ; currentEntry . setRemoved ( true ) ; nextIndex -- ; MST[rv.AOR1Mutator]MSP[N] currentEntry = null ; } @Override public Map . Entry < K , V > next () { return nextEntry () ; } @Override
return getKey () + lr_3 + getValue () ; } return lr_6 ; } public boolean hasNext () { return nextIndex < parent . size ; } public Map . Entry < K , V > nextEntry () { if ( ! hasNext () ) { MST[NonVoidMethodCallMutator]MSP[S]
return getKey () + lr_3 + getValue () ; } return lr_6 ; } public boolean hasNext () { return nextIndex < parent . size ; MST[rv.ROR1Mutator]MSP[N] } public Map . Entry < K , V > nextEntry () { if ( ! hasNext () ) {
throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } currentEntry = new FlatMapEntry <> ( parent , ++ nextIndex ) ; return currentEntry ; } public void remove () { if ( currentEntry == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] throw new IllegalStateException ( AbstractHashedMap . REMOVE_INVALID ) ; }
throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } currentEntry = new FlatMapEntry <> ( parent , ++ nextIndex ) ; MST[rv.UOI2Mutator]MSP[N] return currentEntry ; } public void remove () { if ( currentEntry == null ) { throw new IllegalStateException ( AbstractHashedMap . REMOVE_INVALID ) ; }
throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } currentEntry = new FlatMapEntry <> ( parent , ++ nextIndex ) ; MST[rv.AOR2Mutator]MSP[S] return currentEntry ; } public void remove () { if ( currentEntry == null ) { throw new IllegalStateException ( AbstractHashedMap . REMOVE_INVALID ) ; }
parent . remove ( currentEntry . getKey () ) ; currentEntry . setRemoved ( true ) ; nextIndex -- ; MST[experimental.MemberVariableMutator]MSP[N] currentEntry = null ; } @Override public Map . Entry < K , V > next () { return nextEntry () ; } @Override
parent . remove ( currentEntry . getKey () ) ; currentEntry . setRemoved ( true ) ; nextIndex -- ; MST[rv.UOI1Mutator]MSP[N] currentEntry = null ; } @Override public Map . Entry < K , V > next () { return nextEntry () ; } @Override
parent . remove ( currentEntry . getKey () ) ; currentEntry . setRemoved ( true ) ; nextIndex -- ; MST[rv.UOI2Mutator]MSP[N] currentEntry = null ; } @Override public Map . Entry < K , V > next () { return nextEntry () ; } @Override
throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } currentEntry = new FlatMapEntry <> ( parent , ++ nextIndex ) ; MST[experimental.MemberVariableMutator]MSP[S] return currentEntry ; } public void remove () { if ( currentEntry == null ) { throw new IllegalStateException ( AbstractHashedMap . REMOVE_INVALID ) ; }
return getKey () + lr_3 + getValue () ; } return lr_6 ; } public boolean hasNext () { return nextIndex < parent . size ; MST[rv.CRCR5Mutator]MSP[N] } public Map . Entry < K , V > nextEntry () { if ( ! hasNext () ) {
return getKey () + lr_3 + getValue () ; } return lr_6 ; } public boolean hasNext () { return nextIndex < parent . size ; MST[rv.CRCR6Mutator]MSP[N] } public Map . Entry < K , V > nextEntry () { if ( ! hasNext () ) {
return getKey () + lr_3 + getValue () ; } return lr_6 ; } public boolean hasNext () { return nextIndex < parent . size ; } public Map . Entry < K , V > nextEntry () { if ( ! hasNext () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
return getKey () + lr_3 + getValue () ; } return lr_6 ; } public boolean hasNext () { return nextIndex < parent . size ; MST[rv.CRCR5Mutator]MSP[N] } public Map . Entry < K , V > nextEntry () { if ( ! hasNext () ) {
return getKey () + lr_3 + getValue () ; } return lr_6 ; } public boolean hasNext () { return nextIndex < parent . size ; MST[rv.CRCR6Mutator]MSP[N] } public Map . Entry < K , V > nextEntry () { if ( ! hasNext () ) {
return getKey () + lr_3 + getValue () ; } return lr_6 ; } public boolean hasNext () { return nextIndex < parent . size ; MST[rv.CRCR3Mutator]MSP[N] } public Map . Entry < K , V > nextEntry () { if ( ! hasNext () ) {
return getKey () + lr_3 + getValue () ; } return lr_6 ; } public boolean hasNext () { return nextIndex < parent . size ; MST[rv.CRCR2Mutator]MSP[N] } public Map . Entry < K , V > nextEntry () { if ( ! hasNext () ) {
return getKey () + lr_3 + getValue () ; } return lr_6 ; } public boolean hasNext () { return nextIndex < parent . size ; MST[rv.CRCR4Mutator]MSP[N] } public Map . Entry < K , V > nextEntry () { if ( ! hasNext () ) {
throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } currentEntry = new FlatMapEntry <> ( parent , ++ nextIndex ) ; return currentEntry ; MST[ReturnValsMutator]MSP[S] } public void remove () { if ( currentEntry == null ) { throw new IllegalStateException ( AbstractHashedMap . REMOVE_INVALID ) ; }
parent . remove ( currentEntry . getKey () ) ; currentEntry . setRemoved ( true ) ; nextIndex -- ; MST[MathMutator]MSP[N] currentEntry = null ; } @Override public Map . Entry < K , V > next () { return nextEntry () ; } @Override
parent . remove ( currentEntry . getKey () ) ; currentEntry . setRemoved ( true ) ; MST[VoidMethodCallMutator]MSP[N] nextIndex -- ; currentEntry = null ; } @Override public Map . Entry < K , V > next () { return nextEntry () ; } @Override
return getKey () + lr_3 + getValue () ; } return lr_6 ; } public boolean hasNext () { return nextIndex < parent . size ; } public Map . Entry < K , V > nextEntry () { if ( ! hasNext () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S]
throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } currentEntry = new FlatMapEntry <> ( parent , ++ nextIndex ) ; return currentEntry ; } public void remove () { if ( currentEntry == null ) { MST[rv.ROR5Mutator]MSP[S] throw new IllegalStateException ( AbstractHashedMap . REMOVE_INVALID ) ; }
return getKey () + lr_3 + getValue () ; } return lr_6 ; } public boolean hasNext () { MST[experimental.MemberVariableMutator]MSP[N] return nextIndex < parent . size ; } public Map . Entry < K , V > nextEntry () { if ( ! hasNext () ) {
return getKey () + lr_3 + getValue () ; } return lr_6 ; } public boolean hasNext () { return nextIndex < parent . size ; } public Map . Entry < K , V > nextEntry () { if ( ! hasNext () ) { MST[rv.ROR5Mutator]MSP[N]
parent . remove ( currentEntry . getKey () ) ; currentEntry . setRemoved ( true ) ; nextIndex -- ; MST[rv.UOI4Mutator]MSP[S] currentEntry = null ; } @Override public Map . Entry < K , V > next () { return nextEntry () ; } @Override
parent . remove ( currentEntry . getKey () ) ; currentEntry . setRemoved ( true ) ; nextIndex -- ; MST[InlineConstantMutator]MSP[N] currentEntry = null ; } @Override public Map . Entry < K , V > next () { return nextEntry () ; } @Override
parent . remove ( currentEntry . getKey () ) ; currentEntry . setRemoved ( true ) ; nextIndex -- ; MST[rv.AOR4Mutator]MSP[N] currentEntry = null ; } @Override public Map . Entry < K , V > next () { return nextEntry () ; } @Override
parent . remove ( currentEntry . getKey () ) ; currentEntry . setRemoved ( true ) ; nextIndex -- ; MST[rv.AOR2Mutator]MSP[N] currentEntry = null ; } @Override public Map . Entry < K , V > next () { return nextEntry () ; } @Override
return getKey () + lr_3 + getValue () ; } return lr_6 ; } public boolean hasNext () { return nextIndex < parent . size ; MST[RemoveConditionalMutator_ORDER_IF]MSP[N] } public Map . Entry < K , V > nextEntry () { if ( ! hasNext () ) {
return getKey () + lr_3 + getValue () ; } return lr_6 ; } public boolean hasNext () { return nextIndex < parent . size ; MST[NonVoidMethodCallMutator]MSP[N] } public Map . Entry < K , V > nextEntry () { if ( ! hasNext () ) {
parent . remove ( currentEntry . getKey () ) ; currentEntry . setRemoved ( true ) ; MST[rv.CRCR5Mutator]MSP[N] nextIndex -- ; currentEntry = null ; } @Override public Map . Entry < K , V > next () { return nextEntry () ; } @Override
return getKey () + lr_3 + getValue () ; } return lr_6 ; } public boolean hasNext () { return nextIndex < parent . size ; MST[rv.ABSMutator]MSP[S] } public Map . Entry < K , V > nextEntry () { if ( ! hasNext () ) {
parent . remove ( currentEntry . getKey () ) ; currentEntry . setRemoved ( true ) ; MST[rv.CRCR2Mutator]MSP[N] nextIndex -- ; currentEntry = null ; } @Override public Map . Entry < K , V > next () { return nextEntry () ; } @Override
parent . remove ( currentEntry . getKey () ) ; currentEntry . setRemoved ( true ) ; MST[rv.CRCR6Mutator]MSP[N] nextIndex -- ; currentEntry = null ; } @Override public Map . Entry < K , V > next () { return nextEntry () ; } @Override
throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } currentEntry = new FlatMapEntry <> ( parent , ++ nextIndex ) ; MST[rv.CRCR3Mutator]MSP[S] return currentEntry ; } public void remove () { if ( currentEntry == null ) { throw new IllegalStateException ( AbstractHashedMap . REMOVE_INVALID ) ; }
throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } currentEntry = new FlatMapEntry <> ( parent , ++ nextIndex ) ; MST[rv.CRCR4Mutator]MSP[S] return currentEntry ; } public void remove () { if ( currentEntry == null ) { throw new IllegalStateException ( AbstractHashedMap . REMOVE_INVALID ) ; }
return getKey () + lr_3 + getValue () ; } return lr_6 ; } public boolean hasNext () { return nextIndex < parent . size ; } public Map . Entry < K , V > nextEntry () { if ( ! hasNext () ) { MST[rv.ROR3Mutator]MSP[N]
throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; MST[ConstructorCallMutator]MSP[S] } currentEntry = new FlatMapEntry <> ( parent , ++ nextIndex ) ; return currentEntry ; } public void remove () { if ( currentEntry == null ) { throw new IllegalStateException ( AbstractHashedMap . REMOVE_INVALID ) ; }
throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } currentEntry = new FlatMapEntry <> ( parent , ++ nextIndex ) ; MST[InlineConstantMutator]MSP[S] return currentEntry ; } public void remove () { if ( currentEntry == null ) { throw new IllegalStateException ( AbstractHashedMap . REMOVE_INVALID ) ; }
return getKey () + lr_3 + getValue () ; } return lr_6 ; } public boolean hasNext () { return nextIndex < parent . size ; MST[rv.CRCR1Mutator]MSP[N] } public Map . Entry < K , V > nextEntry () { if ( ! hasNext () ) {
return getKey () + lr_3 + getValue () ; } return lr_6 ; } public boolean hasNext () { return nextIndex < parent . size ; } public Map . Entry < K , V > nextEntry () { if ( ! hasNext () ) { MST[NegateConditionalsMutator]MSP[N]
return getKey () + lr_3 + getValue () ; } return lr_6 ; } public boolean hasNext () { return nextIndex < parent . size ; } public Map . Entry < K , V > nextEntry () { if ( ! hasNext () ) { MST[rv.ROR4Mutator]MSP[N]
throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } currentEntry = new FlatMapEntry <> ( parent , ++ nextIndex ) ; MST[MathMutator]MSP[S] return currentEntry ; } public void remove () { if ( currentEntry == null ) { throw new IllegalStateException ( AbstractHashedMap . REMOVE_INVALID ) ; }
throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } currentEntry = new FlatMapEntry <> ( parent , ++ nextIndex ) ; MST[rv.AOD1Mutator]MSP[S] return currentEntry ; } public void remove () { if ( currentEntry == null ) { throw new IllegalStateException ( AbstractHashedMap . REMOVE_INVALID ) ; }
parent . remove ( currentEntry . getKey () ) ; currentEntry . setRemoved ( true ) ; nextIndex -- ; MST[rv.UOI3Mutator]MSP[N] currentEntry = null ; } @Override public Map . Entry < K , V > next () { return nextEntry () ; } @Override
parent . remove ( currentEntry . getKey () ) ; currentEntry . setRemoved ( true ) ; nextIndex -- ; MST[rv.AOR3Mutator]MSP[N] currentEntry = null ; } @Override public Map . Entry < K , V > next () { return nextEntry () ; } @Override
throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } currentEntry = new FlatMapEntry <> ( parent , ++ nextIndex ) ; MST[rv.UOI4Mutator]MSP[S] return currentEntry ; } public void remove () { if ( currentEntry == null ) { throw new IllegalStateException ( AbstractHashedMap . REMOVE_INVALID ) ; }
throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } currentEntry = new FlatMapEntry <> ( parent , ++ nextIndex ) ; return currentEntry ; } public void remove () { if ( currentEntry == null ) { MST[NegateConditionalsMutator]MSP[S] throw new IllegalStateException ( AbstractHashedMap . REMOVE_INVALID ) ; }
throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } currentEntry = new FlatMapEntry <> ( parent , ++ nextIndex ) ; return currentEntry ; MST[NullReturnValsMutator]MSP[S] } public void remove () { if ( currentEntry == null ) { throw new IllegalStateException ( AbstractHashedMap . REMOVE_INVALID ) ; }
return getKey () + lr_3 + getValue () ; } return lr_6 ; } public boolean hasNext () { return nextIndex < parent . size ; MST[rv.ROR3Mutator]MSP[N] } public Map . Entry < K , V > nextEntry () { if ( ! hasNext () ) {
throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } currentEntry = new FlatMapEntry <> ( parent , ++ nextIndex ) ; MST[rv.AOR4Mutator]MSP[S] return currentEntry ; } public void remove () { if ( currentEntry == null ) { throw new IllegalStateException ( AbstractHashedMap . REMOVE_INVALID ) ; }
parent . remove ( currentEntry . getKey () ) ; currentEntry . setRemoved ( true ) ; nextIndex -- ; currentEntry = null ; } @Override public Map . Entry < K , V > next () { return nextEntry () ; MST[ReturnValsMutator]MSP[S] } @Override
parent . remove ( currentEntry . getKey () ) ; currentEntry . setRemoved ( true ) ; nextIndex -- ; currentEntry = null ; } @Override public Map . Entry < K , V > next () { return nextEntry () ; MST[NullReturnValsMutator]MSP[S] } @Override
parent . remove ( currentEntry . getKey () ) ; currentEntry . setRemoved ( true ) ; nextIndex -- ; currentEntry = null ; } @Override public Map . Entry < K , V > next () { return nextEntry () ; MST[NonVoidMethodCallMutator]MSP[S] } @Override
return nextEntry () . getValue () ; MST[NonVoidMethodCallMutator]MSP[S] } private void writeObject ( final ObjectOutputStream out ) throws IOException { out . defaultWriteObject () ; out . writeInt ( size () ) ;
if ( parent . size () == 0 ) { return EmptyIterator . <K > emptyIterator () ; } return new KeySetIterator <> ( parent ) ; } @Override public K next () { return nextEntry () . getKey () ; MST[NonVoidMethodCallMutator]MSP[S] } @Override
if ( obj instanceof Map . Entry == false ) { return false ; } final Map . Entry < ? , ? > other = ( Map . Entry < ? , ? > ) obj ; final Object key = getKey () ; MST[NonVoidMethodCallMutator]MSP[N]
return getKey () + lr_3 + getValue () ; MST[experimental.NakedReceiverMutator]MSP[S] } return lr_6 ; } public boolean hasNext () { return nextIndex < parent . size ; } public Map . Entry < K , V > nextEntry () { if ( ! hasNext () ) {
void setRemoved ( final boolean flag ) { this . removed = flag ; MST[experimental.MemberVariableMutator]MSP[N] } @Override public K getKey () { if ( removed ) { throw new IllegalStateException ( AbstractHashedMap . GETKEY_INVALID ) ; } switch ( index ) { case 3 : return parent . key3 ;
void setRemoved ( final boolean flag ) { this . removed = flag ; } @Override public K getKey () { if ( removed ) { throw new IllegalStateException ( AbstractHashedMap . GETKEY_INVALID ) ; } switch ( index ) { case 3 : return parent . key3 ; MST[ReturnValsMutator]MSP[N]
case 2 : return parent . key2 ; case 1 : return parent . key1 ; } throw new IllegalStateException ( lr_1 + index ) ; } @Override public V getValue () { if ( removed ) { MST[rv.ROR2Mutator]MSP[N] throw new IllegalStateException ( AbstractHashedMap . GETVALUE_INVALID ) ; }
case 2 : return parent . key2 ; case 1 : return parent . key1 ; } throw new IllegalStateException ( lr_1 + index ) ; } @Override public V getValue () { if ( removed ) { MST[rv.ROR4Mutator]MSP[N] throw new IllegalStateException ( AbstractHashedMap . GETVALUE_INVALID ) ; }
final Object value = getValue () ; return ( key == null ? 0 : key . hashCode () ) ^ ( value == null ? 0 : value . hashCode () ) ; } @Override public String toString () { if ( ! removed ) { MST[rv.ROR3Mutator]MSP[N]
final Object value = getValue () ; return ( key == null ? 0 : key . hashCode () ) ^ ( value == null ? 0 : value . hashCode () ) ; } @Override public String toString () { if ( ! removed ) { MST[rv.ROR1Mutator]MSP[N]
case 2 : return parent . key2 ; case 1 : return parent . key1 ; } throw new IllegalStateException ( lr_1 + index ) ; MST[rv.ABSMutator]MSP[N] } @Override public V getValue () { if ( removed ) { throw new IllegalStateException ( AbstractHashedMap . GETVALUE_INVALID ) ; }
final Object value = getValue () ; return ( key == null ? 0 : key . hashCode () ) ^ ( value == null ? 0 : value . hashCode () ) ; } @Override public String toString () { if ( ! removed ) { MST[rv.ROR5Mutator]MSP[N]
parent . value1 = value ; break; default: throw new IllegalStateException ( lr_1 + index ) ; } return old ; MST[NullReturnValsMutator]MSP[N] } @Override public boolean equals ( final Object obj ) { if ( removed ) { return false ; }
return getKey () + lr_3 + getValue () ; MST[NonVoidMethodCallMutator]MSP[S] } return lr_6 ; } public boolean hasNext () { return nextIndex < parent . size ; } public Map . Entry < K , V > nextEntry () { if ( ! hasNext () ) {
if ( obj instanceof Map . Entry == false ) { MST[rv.ROR4Mutator]MSP[S] return false ; } final Map . Entry < ? , ? > other = ( Map . Entry < ? , ? > ) obj ; final Object key = getKey () ;
if ( obj instanceof Map . Entry == false ) { MST[rv.ROR2Mutator]MSP[N] return false ; } final Map . Entry < ? , ? > other = ( Map . Entry < ? , ? > ) obj ; final Object key = getKey () ;
void setRemoved ( final boolean flag ) { this . removed = flag ; } @Override public K getKey () { if ( removed ) { MST[rv.ROR1Mutator]MSP[S] throw new IllegalStateException ( AbstractHashedMap . GETKEY_INVALID ) ; } switch ( index ) { case 3 : return parent . key3 ;
switch ( index ) { MST[experimental.RemoveSwitchMutator_2]MSP[S] case 3 : return parent . value3 ; case 2 : return parent . value2 ; case 1 : return parent . value1 ; } throw new IllegalStateException ( lr_1 + index ) ; } @Override public V setValue ( final V value ) {
final Object value = getValue () ; return ( key == null ? 0 : key . hashCode () ) ^ ( value == null ? 0 : value . hashCode () ) ; } @Override public String toString () { if ( ! removed ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
switch ( index ) { MST[experimental.RemoveSwitchMutator_1]MSP[S] case 3 : return parent . value3 ; case 2 : return parent . value2 ; case 1 : return parent . value1 ; } throw new IllegalStateException ( lr_1 + index ) ; } @Override public V setValue ( final V value ) {
switch ( index ) { MST[experimental.RemoveSwitchMutator_0]MSP[S] case 3 : return parent . value3 ; case 2 : return parent . value2 ; case 1 : return parent . value1 ; } throw new IllegalStateException ( lr_1 + index ) ; } @Override public V setValue ( final V value ) {
parent . value1 = value ; break; default: throw new IllegalStateException ( lr_1 + index ) ; } return old ; } @Override public boolean equals ( final Object obj ) { if ( removed ) { return false ; MST[BooleanTrueReturnValsMutator]MSP[S] }
if ( obj instanceof Map . Entry == false ) { return false ; MST[rv.CRCR6Mutator]MSP[S] } final Map . Entry < ? , ? > other = ( Map . Entry < ? , ? > ) obj ; final Object key = getKey () ;
parent . value1 = value ; break; default: throw new IllegalStateException ( lr_1 + index ) ; } return old ; } @Override public boolean equals ( final Object obj ) { if ( removed ) { return false ; MST[ReturnValsMutator]MSP[S] }
void setRemoved ( final boolean flag ) { this . removed = flag ; } @Override public K getKey () { if ( removed ) { throw new IllegalStateException ( AbstractHashedMap . GETKEY_INVALID ) ; } switch ( index ) { MST[rv.UOI3Mutator]MSP[N] case 3 : return parent . key3 ;
parent . value1 = value ; break; default: throw new IllegalStateException ( lr_1 + index ) ; } return old ; } @Override public boolean equals ( final Object obj ) { if ( removed ) { return false ; MST[rv.CRCR5Mutator]MSP[S] }
case 2 : return parent . key2 ; case 1 : return parent . key1 ; } throw new IllegalStateException ( lr_1 + index ) ; MST[NonVoidMethodCallMutator]MSP[N] } @Override public V getValue () { if ( removed ) { throw new IllegalStateException ( AbstractHashedMap . GETVALUE_INVALID ) ; }
parent . value1 = value ; break; default: throw new IllegalStateException ( lr_1 + index ) ; } return old ; } @Override public boolean equals ( final Object obj ) { if ( removed ) { return false ; MST[rv.CRCR1Mutator]MSP[S] }
void setRemoved ( final boolean flag ) { this . removed = flag ; } @Override public K getKey () { if ( removed ) { MST[rv.ROR5Mutator]MSP[S] throw new IllegalStateException ( AbstractHashedMap . GETKEY_INVALID ) ; } switch ( index ) { case 3 : return parent . key3 ;
switch ( index ) { MST[rv.UOI4Mutator]MSP[S] case 3 : return parent . value3 ; case 2 : return parent . value2 ; case 1 : return parent . value1 ; } throw new IllegalStateException ( lr_1 + index ) ; } @Override public V setValue ( final V value ) {
if ( removed ) { MST[rv.ROR3Mutator]MSP[S] throw new IllegalStateException ( AbstractHashedMap . SETVALUE_INVALID ) ; } final V old = getValue () ; switch ( index ) { case 3 : parent . value3 = value ; break; case 2 : parent . value2 = value ; break; case 1 :
parent . value1 = value ; break; default: throw new IllegalStateException ( lr_1 + index ) ; } return old ; } @Override public boolean equals ( final Object obj ) { if ( removed ) { MST[rv.ROR1Mutator]MSP[S] return false ; }
parent . value1 = value ; break; default: throw new IllegalStateException ( lr_1 + index ) ; } return old ; } @Override public boolean equals ( final Object obj ) { if ( removed ) { MST[rv.ROR5Mutator]MSP[S] return false ; }
switch ( index ) { case 3 : return parent . value3 ; case 2 : return parent . value2 ; case 1 : return parent . value1 ; } throw new IllegalStateException ( lr_1 + index ) ; MST[NonVoidMethodCallMutator]MSP[S] } @Override public V setValue ( final V value ) {
switch ( index ) { case 3 : return parent . value3 ; case 2 : return parent . value2 ; case 1 : return parent . value1 ; MST[ReturnValsMutator]MSP[N] } throw new IllegalStateException ( lr_1 + index ) ; } @Override public V setValue ( final V value ) {
void setRemoved ( final boolean flag ) { this . removed = flag ; MST[rv.ABSMutator]MSP[N] } @Override public K getKey () { if ( removed ) { throw new IllegalStateException ( AbstractHashedMap . GETKEY_INVALID ) ; } switch ( index ) { case 3 : return parent . key3 ;
case 2 : return parent . key2 ; case 1 : return parent . key1 ; } throw new IllegalStateException ( lr_1 + index ) ; MST[rv.UOI2Mutator]MSP[N] } @Override public V getValue () { if ( removed ) { throw new IllegalStateException ( AbstractHashedMap . GETVALUE_INVALID ) ; }
switch ( index ) { case 3 : return parent . value3 ; case 2 : return parent . value2 ; case 1 : return parent . value1 ; } throw new IllegalStateException ( lr_1 + index ) ; MST[ConstructorCallMutator]MSP[S] } @Override public V setValue ( final V value ) {
case 2 : return parent . key2 ; case 1 : return parent . key1 ; MST[ReturnValsMutator]MSP[S] } throw new IllegalStateException ( lr_1 + index ) ; } @Override public V getValue () { if ( removed ) { throw new IllegalStateException ( AbstractHashedMap . GETVALUE_INVALID ) ; }
switch ( index ) { case 3 : return parent . value3 ; MST[NonVoidMethodCallMutator]MSP[N] case 2 : return parent . value2 ; case 1 : return parent . value1 ; } throw new IllegalStateException ( lr_1 + index ) ; } @Override public V setValue ( final V value ) {
parent . value1 = value ; break; default: throw new IllegalStateException ( lr_1 + index ) ; } return old ; } @Override public boolean equals ( final Object obj ) { if ( removed ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return false ; }
if ( removed ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] throw new IllegalStateException ( AbstractHashedMap . SETVALUE_INVALID ) ; } final V old = getValue () ; switch ( index ) { case 3 : parent . value3 = value ; break; case 2 : parent . value2 = value ; break; case 1 :
void setRemoved ( final boolean flag ) { this . removed = flag ; } @Override public K getKey () { if ( removed ) { throw new IllegalStateException ( AbstractHashedMap . GETKEY_INVALID ) ; } switch ( index ) { MST[rv.ABSMutator]MSP[S] case 3 : return parent . key3 ;
switch ( index ) { case 3 : return parent . value3 ; case 2 : return parent . value2 ; case 1 : return parent . value1 ; } throw new IllegalStateException ( lr_1 + index ) ; MST[rv.UOI2Mutator]MSP[N] } @Override public V setValue ( final V value ) {
switch ( index ) { case 3 : return parent . value3 ; case 2 : return parent . value2 ; case 1 : return parent . value1 ; } throw new IllegalStateException ( lr_1 + index ) ; MST[rv.UOI3Mutator]MSP[N] } @Override public V setValue ( final V value ) {
switch ( index ) { case 3 : return parent . value3 ; case 2 : return parent . value2 ; case 1 : return parent . value1 ; } throw new IllegalStateException ( lr_1 + index ) ; MST[experimental.NakedReceiverMutator]MSP[N] } @Override public V setValue ( final V value ) {
void setRemoved ( final boolean flag ) { this . removed = flag ; } @Override public K getKey () { if ( removed ) { MST[NegateConditionalsMutator]MSP[S] throw new IllegalStateException ( AbstractHashedMap . GETKEY_INVALID ) ; } switch ( index ) { case 3 : return parent . key3 ;
return getKey () + lr_3 + getValue () ; MST[experimental.NakedReceiverMutator]MSP[S] } return lr_6 ; } public boolean hasNext () { return nextIndex < parent . size ; } public Map . Entry < K , V > nextEntry () { if ( ! hasNext () ) {
switch ( index ) { case 3 : return parent . value3 ; case 2 : return parent . value2 ; MST[NullReturnValsMutator]MSP[N] case 1 : return parent . value1 ; } throw new IllegalStateException ( lr_1 + index ) ; } @Override public V setValue ( final V value ) {
( value == null ? other . getValue () == null : value . equals ( other . getValue () ) ) ; } @Override public int hashCode () { if ( removed ) { MST[rv.ROR4Mutator]MSP[N] return 0 ; } final Object key = getKey () ;
( value == null ? other . getValue () == null : value . equals ( other . getValue () ) ) ; } @Override public int hashCode () { if ( removed ) { MST[rv.ROR2Mutator]MSP[N] return 0 ; } final Object key = getKey () ;
( value == null ? other . getValue () == null : value . equals ( other . getValue () ) ) ; } @Override public int hashCode () { if ( removed ) { MST[rv.ROR5Mutator]MSP[S] return 0 ; } final Object key = getKey () ;
parent . value1 = value ; break; default: throw new IllegalStateException ( lr_1 + index ) ; } return old ; } @Override public boolean equals ( final Object obj ) { if ( removed ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] return false ; }
case 2 : return parent . key2 ; case 1 : return parent . key1 ; } throw new IllegalStateException ( lr_1 + index ) ; MST[ConstructorCallMutator]MSP[S] } @Override public V getValue () { if ( removed ) { throw new IllegalStateException ( AbstractHashedMap . GETVALUE_INVALID ) ; }
case 2 : return parent . key2 ; MST[NonVoidMethodCallMutator]MSP[N] case 1 : return parent . key1 ; } throw new IllegalStateException ( lr_1 + index ) ; } @Override public V getValue () { if ( removed ) { throw new IllegalStateException ( AbstractHashedMap . GETVALUE_INVALID ) ; }
( value == null ? other . getValue () == null : value . equals ( other . getValue () ) ) ; } @Override public int hashCode () { if ( removed ) { return 0 ; } final Object key = getKey () ; MST[NonVoidMethodCallMutator]MSP[N]
case 2 : return parent . key2 ; case 1 : return parent . key1 ; MST[NullReturnValsMutator]MSP[S] } throw new IllegalStateException ( lr_1 + index ) ; } @Override public V getValue () { if ( removed ) { throw new IllegalStateException ( AbstractHashedMap . GETVALUE_INVALID ) ; }
switch ( index ) { case 3 : return parent . value3 ; case 2 : return parent . value2 ; case 1 : return parent . value1 ; } throw new IllegalStateException ( lr_1 + index ) ; MST[NonVoidMethodCallMutator]MSP[S] } @Override public V setValue ( final V value ) {
case 2 : return parent . key2 ; case 1 : return parent . key1 ; } throw new IllegalStateException ( lr_1 + index ) ; MST[rv.UOI1Mutator]MSP[N] } @Override public V getValue () { if ( removed ) { throw new IllegalStateException ( AbstractHashedMap . GETVALUE_INVALID ) ; }
if ( removed ) { MST[NegateConditionalsMutator]MSP[S] throw new IllegalStateException ( AbstractHashedMap . SETVALUE_INVALID ) ; } final V old = getValue () ; switch ( index ) { case 3 : parent . value3 = value ; break; case 2 : parent . value2 = value ; break; case 1 :
if ( removed ) { MST[rv.ROR4Mutator]MSP[N] throw new IllegalStateException ( AbstractHashedMap . SETVALUE_INVALID ) ; } final V old = getValue () ; switch ( index ) { case 3 : parent . value3 = value ; break; case 2 : parent . value2 = value ; break; case 1 :
return getKey () + lr_3 + getValue () ; MST[NonVoidMethodCallMutator]MSP[S] } return lr_6 ; } public boolean hasNext () { return nextIndex < parent . size ; } public Map . Entry < K , V > nextEntry () { if ( ! hasNext () ) {
void setRemoved ( final boolean flag ) { this . removed = flag ; } @Override public K getKey () { if ( removed ) { throw new IllegalStateException ( AbstractHashedMap . GETKEY_INVALID ) ; } switch ( index ) { MST[rv.UOI1Mutator]MSP[N] case 3 : return parent . key3 ;
case 2 : return parent . key2 ; case 1 : return parent . key1 ; } throw new IllegalStateException ( lr_1 + index ) ; } @Override public V getValue () { if ( removed ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] throw new IllegalStateException ( AbstractHashedMap . GETVALUE_INVALID ) ; }
if ( obj instanceof Map . Entry == false ) { return false ; MST[rv.CRCR1Mutator]MSP[S] } final Map . Entry < ? , ? > other = ( Map . Entry < ? , ? > ) obj ; final Object key = getKey () ;
switch ( index ) { case 3 : return parent . value3 ; case 2 : return parent . value2 ; MST[ReturnValsMutator]MSP[N] case 1 : return parent . value1 ; } throw new IllegalStateException ( lr_1 + index ) ; } @Override public V setValue ( final V value ) {
void setRemoved ( final boolean flag ) { this . removed = flag ; } @Override public K getKey () { if ( removed ) { MST[rv.ROR4Mutator]MSP[N] throw new IllegalStateException ( AbstractHashedMap . GETKEY_INVALID ) ; } switch ( index ) { case 3 : return parent . key3 ;
parent . value1 = value ; break; default: throw new IllegalStateException ( lr_1 + index ) ; } return old ; } @Override public boolean equals ( final Object obj ) { if ( removed ) { return false ; MST[rv.CRCR3Mutator]MSP[S] }
parent . value1 = value ; break; default: throw new IllegalStateException ( lr_1 + index ) ; } return old ; } @Override public boolean equals ( final Object obj ) { if ( removed ) { return false ; MST[rv.CRCR6Mutator]MSP[S] }
switch ( index ) { case 3 : return parent . value3 ; MST[NullReturnValsMutator]MSP[N] case 2 : return parent . value2 ; case 1 : return parent . value1 ; } throw new IllegalStateException ( lr_1 + index ) ; } @Override public V setValue ( final V value ) {
if ( removed ) { MST[rv.ROR1Mutator]MSP[S] throw new IllegalStateException ( AbstractHashedMap . SETVALUE_INVALID ) ; } final V old = getValue () ; switch ( index ) { case 3 : parent . value3 = value ; break; case 2 : parent . value2 = value ; break; case 1 :
final Object value = getValue () ; return ( key == null ? 0 : key . hashCode () ) ^ ( value == null ? 0 : value . hashCode () ) ; } @Override public String toString () { if ( ! removed ) { MST[rv.ROR2Mutator]MSP[N]
void setRemoved ( final boolean flag ) { this . removed = flag ; MST[rv.UOI3Mutator]MSP[N] } @Override public K getKey () { if ( removed ) { throw new IllegalStateException ( AbstractHashedMap . GETKEY_INVALID ) ; } switch ( index ) { case 3 : return parent . key3 ;
case 2 : return parent . key2 ; case 1 : return parent . key1 ; MST[NonVoidMethodCallMutator]MSP[S] } throw new IllegalStateException ( lr_1 + index ) ; } @Override public V getValue () { if ( removed ) { throw new IllegalStateException ( AbstractHashedMap . GETVALUE_INVALID ) ; }
switch ( index ) { MST[rv.UOI2Mutator]MSP[S] case 3 : return parent . value3 ; case 2 : return parent . value2 ; case 1 : return parent . value1 ; } throw new IllegalStateException ( lr_1 + index ) ; } @Override public V setValue ( final V value ) {
if ( removed ) { throw new IllegalStateException ( AbstractHashedMap . SETVALUE_INVALID ) ; } final V old = getValue () ; switch ( index ) { MST[rv.UOI2Mutator]MSP[N] case 3 : parent . value3 = value ; break; case 2 : parent . value2 = value ; break; case 1 :
parent . value1 = value ; break; default: throw new IllegalStateException ( lr_1 + index ) ; } return old ; } @Override public boolean equals ( final Object obj ) { if ( removed ) { MST[rv.ROR3Mutator]MSP[S] return false ; }
void setRemoved ( final boolean flag ) { this . removed = flag ; } @Override public K getKey () { if ( removed ) { throw new IllegalStateException ( AbstractHashedMap . GETKEY_INVALID ) ; } switch ( index ) { MST[experimental.SwitchMutator]MSP[S] case 3 : return parent . key3 ;
case 2 : return parent . key2 ; case 1 : return parent . key1 ; } throw new IllegalStateException ( lr_1 + index ) ; MST[rv.UOI4Mutator]MSP[N] } @Override public V getValue () { if ( removed ) { throw new IllegalStateException ( AbstractHashedMap . GETVALUE_INVALID ) ; }
case 2 : return parent . key2 ; case 1 : return parent . key1 ; } throw new IllegalStateException ( lr_1 + index ) ; MST[experimental.NakedReceiverMutator]MSP[N] } @Override public V getValue () { if ( removed ) { throw new IllegalStateException ( AbstractHashedMap . GETVALUE_INVALID ) ; }
parent . value1 = value ; MST[ArgumentPropagationMutator]MSP[N] break; default: throw new IllegalStateException ( lr_1 + index ) ; } return old ; } @Override public boolean equals ( final Object obj ) { if ( removed ) { return false ; }
if ( obj instanceof Map . Entry == false ) { MST[rv.ROR1Mutator]MSP[S] return false ; } final Map . Entry < ? , ? > other = ( Map . Entry < ? , ? > ) obj ; final Object key = getKey () ;
return getKey () + lr_3 + getValue () ; MST[NonVoidMethodCallMutator]MSP[N] } return lr_6 ; } public boolean hasNext () { return nextIndex < parent . size ; } public Map . Entry < K , V > nextEntry () { if ( ! hasNext () ) {
if ( obj instanceof Map . Entry == false ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] return false ; } final Map . Entry < ? , ? > other = ( Map . Entry < ? , ? > ) obj ; final Object key = getKey () ;
if ( removed ) { throw new IllegalStateException ( AbstractHashedMap . SETVALUE_INVALID ) ; } final V old = getValue () ; switch ( index ) { case 3 : parent . value3 = value ; break; case 2 : parent . value2 = value ; MST[NonVoidMethodCallMutator]MSP[N] break; case 1 :
switch ( index ) { case 3 : return parent . value3 ; MST[ReturnValsMutator]MSP[N] case 2 : return parent . value2 ; case 1 : return parent . value1 ; } throw new IllegalStateException ( lr_1 + index ) ; } @Override public V setValue ( final V value ) {
if ( removed ) { throw new IllegalStateException ( AbstractHashedMap . SETVALUE_INVALID ) ; } final V old = getValue () ; MST[NonVoidMethodCallMutator]MSP[N] switch ( index ) { case 3 : parent . value3 = value ; break; case 2 : parent . value2 = value ; break; case 1 :
switch ( index ) { MST[experimental.SwitchMutator]MSP[N] case 3 : return parent . value3 ; case 2 : return parent . value2 ; case 1 : return parent . value1 ; } throw new IllegalStateException ( lr_1 + index ) ; } @Override public V setValue ( final V value ) {
case 2 : return parent . key2 ; case 1 : return parent . key1 ; } throw new IllegalStateException ( lr_1 + index ) ; } @Override public V getValue () { if ( removed ) { MST[rv.ROR1Mutator]MSP[S] throw new IllegalStateException ( AbstractHashedMap . GETVALUE_INVALID ) ; }
parent . value1 = value ; break; default: throw new IllegalStateException ( lr_1 + index ) ; } return old ; } @Override public boolean equals ( final Object obj ) { if ( removed ) { return false ; MST[InlineConstantMutator]MSP[S] }
void setRemoved ( final boolean flag ) { this . removed = flag ; } @Override public K getKey () { if ( removed ) { throw new IllegalStateException ( AbstractHashedMap . GETKEY_INVALID ) ; } switch ( index ) { case 3 : return parent . key3 ; MST[NullReturnValsMutator]MSP[N]
case 2 : return parent . key2 ; case 1 : return parent . key1 ; } throw new IllegalStateException ( lr_1 + index ) ; } @Override public V getValue () { if ( removed ) { MST[rv.ROR3Mutator]MSP[S] throw new IllegalStateException ( AbstractHashedMap . GETVALUE_INVALID ) ; }
if ( obj instanceof Map . Entry == false ) { MST[NegateConditionalsMutator]MSP[N] return false ; } final Map . Entry < ? , ? > other = ( Map . Entry < ? , ? > ) obj ; final Object key = getKey () ;
switch ( index ) { MST[rv.UOI3Mutator]MSP[N] case 3 : return parent . value3 ; case 2 : return parent . value2 ; case 1 : return parent . value1 ; } throw new IllegalStateException ( lr_1 + index ) ; } @Override public V setValue ( final V value ) {
switch ( index ) { MST[rv.UOI1Mutator]MSP[S] case 3 : return parent . value3 ; case 2 : return parent . value2 ; case 1 : return parent . value1 ; } throw new IllegalStateException ( lr_1 + index ) ; } @Override public V setValue ( final V value ) {
if ( obj instanceof Map . Entry == false ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] return false ; } final Map . Entry < ? , ? > other = ( Map . Entry < ? , ? > ) obj ; final Object key = getKey () ;
if ( removed ) { throw new IllegalStateException ( AbstractHashedMap . SETVALUE_INVALID ) ; } final V old = getValue () ; switch ( index ) { MST[rv.ABSMutator]MSP[S] case 3 : parent . value3 = value ; break; case 2 : parent . value2 = value ; break; case 1 :
case 2 : return parent . key2 ; case 1 : return parent . key1 ; } throw new IllegalStateException ( lr_1 + index ) ; } @Override public V getValue () { if ( removed ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] throw new IllegalStateException ( AbstractHashedMap . GETVALUE_INVALID ) ; }
return getKey () + lr_3 + getValue () ; MST[NonVoidMethodCallMutator]MSP[N] } return lr_6 ; } public boolean hasNext () { return nextIndex < parent . size ; } public Map . Entry < K , V > nextEntry () { if ( ! hasNext () ) {
switch ( index ) { case 3 : return parent . value3 ; case 2 : return parent . value2 ; MST[NonVoidMethodCallMutator]MSP[N] case 1 : return parent . value1 ; } throw new IllegalStateException ( lr_1 + index ) ; } @Override public V setValue ( final V value ) {
( value == null ? other . getValue () == null : value . equals ( other . getValue () ) ) ; } @Override public int hashCode () { if ( removed ) { MST[NegateConditionalsMutator]MSP[S] return 0 ; } final Object key = getKey () ;
if ( obj instanceof Map . Entry == false ) { return false ; MST[rv.CRCR3Mutator]MSP[S] } final Map . Entry < ? , ? > other = ( Map . Entry < ? , ? > ) obj ; final Object key = getKey () ;
return getKey () + lr_3 + getValue () ; MST[ReturnValsMutator]MSP[S] } return lr_6 ; } public boolean hasNext () { return nextIndex < parent . size ; } public Map . Entry < K , V > nextEntry () { if ( ! hasNext () ) {
void setRemoved ( final boolean flag ) { this . removed = flag ; } @Override public K getKey () { if ( removed ) { throw new IllegalStateException ( AbstractHashedMap . GETKEY_INVALID ) ; } switch ( index ) { MST[rv.UOI4Mutator]MSP[S] case 3 : return parent . key3 ;
switch ( index ) { case 3 : return parent . value3 ; case 2 : return parent . value2 ; case 1 : return parent . value1 ; MST[NullReturnValsMutator]MSP[S] } throw new IllegalStateException ( lr_1 + index ) ; } @Override public V setValue ( final V value ) {
case 2 : return parent . key2 ; case 1 : return parent . key1 ; } throw new IllegalStateException ( lr_1 + index ) ; MST[NonVoidMethodCallMutator]MSP[S] } @Override public V getValue () { if ( removed ) { throw new IllegalStateException ( AbstractHashedMap . GETVALUE_INVALID ) ; }
void setRemoved ( final boolean flag ) { this . removed = flag ; } @Override public K getKey () { if ( removed ) { MST[rv.ROR2Mutator]MSP[N] throw new IllegalStateException ( AbstractHashedMap . GETKEY_INVALID ) ; } switch ( index ) { case 3 : return parent . key3 ;
case 2 : return parent . key2 ; case 1 : return parent . key1 ; } throw new IllegalStateException ( lr_1 + index ) ; } @Override public V getValue () { if ( removed ) { MST[rv.ROR5Mutator]MSP[S] throw new IllegalStateException ( AbstractHashedMap . GETVALUE_INVALID ) ; }
if ( obj instanceof Map . Entry == false ) { return false ; MST[InlineConstantMutator]MSP[S] } final Map . Entry < ? , ? > other = ( Map . Entry < ? , ? > ) obj ; final Object key = getKey () ;
case 2 : return parent . key2 ; MST[NullReturnValsMutator]MSP[N] case 1 : return parent . key1 ; } throw new IllegalStateException ( lr_1 + index ) ; } @Override public V getValue () { if ( removed ) { throw new IllegalStateException ( AbstractHashedMap . GETVALUE_INVALID ) ; }
void setRemoved ( final boolean flag ) { this . removed = flag ; MST[rv.UOI1Mutator]MSP[N] } @Override public K getKey () { if ( removed ) { throw new IllegalStateException ( AbstractHashedMap . GETKEY_INVALID ) ; } switch ( index ) { case 3 : return parent . key3 ;
final Object value = getValue () ; return ( key == null ? 0 : key . hashCode () ) ^ ( value == null ? 0 : value . hashCode () ) ; } @Override public String toString () { if ( ! removed ) { MST[rv.ROR4Mutator]MSP[N]
case 2 : return parent . key2 ; case 1 : return parent . key1 ; } throw new IllegalStateException ( lr_1 + index ) ; MST[ConstructorCallMutator]MSP[S] } @Override public V getValue () { if ( removed ) { throw new IllegalStateException ( AbstractHashedMap . GETVALUE_INVALID ) ; }
if ( removed ) { throw new IllegalStateException ( AbstractHashedMap . SETVALUE_INVALID ) ; } final V old = getValue () ; switch ( index ) { MST[rv.UOI4Mutator]MSP[S] case 3 : parent . value3 = value ; break; case 2 : parent . value2 = value ; break; case 1 :
if ( removed ) { throw new IllegalStateException ( AbstractHashedMap . SETVALUE_INVALID ) ; MST[ConstructorCallMutator]MSP[S] } final V old = getValue () ; switch ( index ) { case 3 : parent . value3 = value ; break; case 2 : parent . value2 = value ; break; case 1 :
if ( removed ) { throw new IllegalStateException ( AbstractHashedMap . SETVALUE_INVALID ) ; } final V old = getValue () ; switch ( index ) { MST[experimental.RemoveSwitchMutator_2]MSP[N] case 3 : parent . value3 = value ; break; case 2 : parent . value2 = value ; break; case 1 :
if ( removed ) { throw new IllegalStateException ( AbstractHashedMap . SETVALUE_INVALID ) ; } final V old = getValue () ; switch ( index ) { MST[experimental.RemoveSwitchMutator_1]MSP[S] case 3 : parent . value3 = value ; break; case 2 : parent . value2 = value ; break; case 1 :
if ( removed ) { throw new IllegalStateException ( AbstractHashedMap . SETVALUE_INVALID ) ; } final V old = getValue () ; switch ( index ) { MST[experimental.RemoveSwitchMutator_0]MSP[S] case 3 : parent . value3 = value ; break; case 2 : parent . value2 = value ; break; case 1 :
void setRemoved ( final boolean flag ) { this . removed = flag ; } @Override public K getKey () { if ( removed ) { throw new IllegalStateException ( AbstractHashedMap . GETKEY_INVALID ) ; } switch ( index ) { case 3 : return parent . key3 ; MST[NonVoidMethodCallMutator]MSP[N]
if ( obj instanceof Map . Entry == false ) { MST[rv.ROR3Mutator]MSP[N] return false ; } final Map . Entry < ? , ? > other = ( Map . Entry < ? , ? > ) obj ; final Object key = getKey () ;
parent . value1 = value ; break; default: throw new IllegalStateException ( lr_1 + index ) ; } return old ; MST[ReturnValsMutator]MSP[N] } @Override public boolean equals ( final Object obj ) { if ( removed ) { return false ; }
return getKey () + lr_3 + getValue () ; MST[NonVoidMethodCallMutator]MSP[S] } return lr_6 ; } public boolean hasNext () { return nextIndex < parent . size ; } public Map . Entry < K , V > nextEntry () { if ( ! hasNext () ) {
switch ( index ) { case 3 : return parent . value3 ; case 2 : return parent . value2 ; case 1 : return parent . value1 ; } throw new IllegalStateException ( lr_1 + index ) ; MST[rv.UOI4Mutator]MSP[N] } @Override public V setValue ( final V value ) {
switch ( index ) { case 3 : return parent . value3 ; case 2 : return parent . value2 ; case 1 : return parent . value1 ; } throw new IllegalStateException ( lr_1 + index ) ; MST[ConstructorCallMutator]MSP[S] } @Override public V setValue ( final V value ) {
if ( removed ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] throw new IllegalStateException ( AbstractHashedMap . SETVALUE_INVALID ) ; } final V old = getValue () ; switch ( index ) { case 3 : parent . value3 = value ; break; case 2 : parent . value2 = value ; break; case 1 :
switch ( index ) { case 3 : return parent . value3 ; case 2 : return parent . value2 ; case 1 : return parent . value1 ; } throw new IllegalStateException ( lr_1 + index ) ; MST[rv.UOI1Mutator]MSP[N] } @Override public V setValue ( final V value ) {
( value == null ? other . getValue () == null : value . equals ( other . getValue () ) ) ; } @Override public int hashCode () { if ( removed ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] return 0 ; } final Object key = getKey () ;
case 2 : return parent . key2 ; case 1 : return parent . key1 ; } throw new IllegalStateException ( lr_1 + index ) ; MST[NonVoidMethodCallMutator]MSP[S] } @Override public V getValue () { if ( removed ) { throw new IllegalStateException ( AbstractHashedMap . GETVALUE_INVALID ) ; }
void setRemoved ( final boolean flag ) { this . removed = flag ; } @Override public K getKey () { if ( removed ) { throw new IllegalStateException ( AbstractHashedMap . GETKEY_INVALID ) ; } switch ( index ) { MST[experimental.RemoveSwitchMutator_1]MSP[S] case 3 : return parent . key3 ;
void setRemoved ( final boolean flag ) { this . removed = flag ; } @Override public K getKey () { if ( removed ) { throw new IllegalStateException ( AbstractHashedMap . GETKEY_INVALID ) ; } switch ( index ) { MST[experimental.RemoveSwitchMutator_0]MSP[S] case 3 : return parent . key3 ;
if ( removed ) { throw new IllegalStateException ( AbstractHashedMap . SETVALUE_INVALID ) ; } final V old = getValue () ; switch ( index ) { MST[experimental.SwitchMutator]MSP[S] case 3 : parent . value3 = value ; break; case 2 : parent . value2 = value ; break; case 1 :
( value == null ? other . getValue () == null : value . equals ( other . getValue () ) ) ; } @Override public int hashCode () { if ( removed ) { MST[rv.ROR3Mutator]MSP[S] return 0 ; } final Object key = getKey () ;
( value == null ? other . getValue () == null : value . equals ( other . getValue () ) ) ; } @Override public int hashCode () { if ( removed ) { MST[rv.ROR1Mutator]MSP[S] return 0 ; } final Object key = getKey () ;
void setRemoved ( final boolean flag ) { this . removed = flag ; } @Override public K getKey () { if ( removed ) { throw new IllegalStateException ( AbstractHashedMap . GETKEY_INVALID ) ; } switch ( index ) { MST[experimental.RemoveSwitchMutator_2]MSP[S] case 3 : return parent . key3 ;
final Object value = getValue () ; return ( key == null ? 0 : key . hashCode () ) ^ ( value == null ? 0 : value . hashCode () ) ; } @Override public String toString () { if ( ! removed ) { MST[NegateConditionalsMutator]MSP[N]
if ( removed ) { throw new IllegalStateException ( AbstractHashedMap . SETVALUE_INVALID ) ; } final V old = getValue () ; switch ( index ) { MST[rv.UOI3Mutator]MSP[N] case 3 : parent . value3 = value ; break; case 2 : parent . value2 = value ; break; case 1 :
void setRemoved ( final boolean flag ) { this . removed = flag ; MST[rv.UOI2Mutator]MSP[N] } @Override public K getKey () { if ( removed ) { throw new IllegalStateException ( AbstractHashedMap . GETKEY_INVALID ) ; } switch ( index ) { case 3 : return parent . key3 ;
if ( removed ) { MST[rv.ROR2Mutator]MSP[N] throw new IllegalStateException ( AbstractHashedMap . SETVALUE_INVALID ) ; } final V old = getValue () ; switch ( index ) { case 3 : parent . value3 = value ; break; case 2 : parent . value2 = value ; break; case 1 :
return getKey () + lr_3 + getValue () ; MST[ConstructorCallMutator]MSP[S] } return lr_6 ; } public boolean hasNext () { return nextIndex < parent . size ; } public Map . Entry < K , V > nextEntry () { if ( ! hasNext () ) {
if ( removed ) { throw new IllegalStateException ( AbstractHashedMap . SETVALUE_INVALID ) ; } final V old = getValue () ; switch ( index ) { case 3 : parent . value3 = value ; break; case 2 : parent . value2 = value ; MST[ArgumentPropagationMutator]MSP[N] break; case 1 :
void setRemoved ( final boolean flag ) { this . removed = flag ; MST[rv.UOI4Mutator]MSP[N] } @Override public K getKey () { if ( removed ) { throw new IllegalStateException ( AbstractHashedMap . GETKEY_INVALID ) ; } switch ( index ) { case 3 : return parent . key3 ;
if ( removed ) { throw new IllegalStateException ( AbstractHashedMap . SETVALUE_INVALID ) ; } final V old = getValue () ; switch ( index ) { MST[rv.UOI1Mutator]MSP[N] case 3 : parent . value3 = value ; break; case 2 : parent . value2 = value ; break; case 1 :
switch ( index ) { case 3 : return parent . value3 ; case 2 : return parent . value2 ; case 1 : return parent . value1 ; } throw new IllegalStateException ( lr_1 + index ) ; MST[NonVoidMethodCallMutator]MSP[N] } @Override public V setValue ( final V value ) {
parent . value1 = value ; break; default: throw new IllegalStateException ( lr_1 + index ) ; } return old ; } @Override public boolean equals ( final Object obj ) { if ( removed ) { MST[rv.ROR4Mutator]MSP[N] return false ; }
parent . value1 = value ; break; default: throw new IllegalStateException ( lr_1 + index ) ; } return old ; } @Override public boolean equals ( final Object obj ) { if ( removed ) { MST[rv.ROR2Mutator]MSP[N] return false ; }
void setRemoved ( final boolean flag ) { this . removed = flag ; } @Override public K getKey () { if ( removed ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] throw new IllegalStateException ( AbstractHashedMap . GETKEY_INVALID ) ; } switch ( index ) { case 3 : return parent . key3 ;
case 2 : return parent . key2 ; case 1 : return parent . key1 ; } throw new IllegalStateException ( lr_1 + index ) ; } @Override public V getValue () { if ( removed ) { MST[NegateConditionalsMutator]MSP[S] throw new IllegalStateException ( AbstractHashedMap . GETVALUE_INVALID ) ; }
( value == null ? other . getValue () == null : value . equals ( other . getValue () ) ) ; } @Override public int hashCode () { if ( removed ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return 0 ; } final Object key = getKey () ;
case 2 : return parent . key2 ; case 1 : return parent . key1 ; } throw new IllegalStateException ( lr_1 + index ) ; MST[experimental.NakedReceiverMutator]MSP[N] } @Override public V getValue () { if ( removed ) { throw new IllegalStateException ( AbstractHashedMap . GETVALUE_INVALID ) ; }
parent . value1 = value ; break; default: throw new IllegalStateException ( lr_1 + index ) ; } return old ; } @Override public boolean equals ( final Object obj ) { if ( removed ) { MST[NegateConditionalsMutator]MSP[S] return false ; }
case 2 : return parent . key2 ; case 1 : return parent . key1 ; } throw new IllegalStateException ( lr_1 + index ) ; MST[rv.UOI3Mutator]MSP[N] } @Override public V getValue () { if ( removed ) { throw new IllegalStateException ( AbstractHashedMap . GETVALUE_INVALID ) ; }
switch ( index ) { case 3 : return parent . value3 ; case 2 : return parent . value2 ; case 1 : return parent . value1 ; } throw new IllegalStateException ( lr_1 + index ) ; MST[rv.ABSMutator]MSP[N] } @Override public V setValue ( final V value ) {
return getKey () + lr_3 + getValue () ; MST[NonVoidMethodCallMutator]MSP[S] } return lr_6 ; } public boolean hasNext () { return nextIndex < parent . size ; } public Map . Entry < K , V > nextEntry () { if ( ! hasNext () ) {
if ( obj instanceof Map . Entry == false ) { return false ; MST[BooleanTrueReturnValsMutator]MSP[S] } final Map . Entry < ? , ? > other = ( Map . Entry < ? , ? > ) obj ; final Object key = getKey () ;
if ( obj instanceof Map . Entry == false ) { return false ; MST[ReturnValsMutator]MSP[S] } final Map . Entry < ? , ? > other = ( Map . Entry < ? , ? > ) obj ; final Object key = getKey () ;
final Object value = getValue () ; return ( key == null ? 0 : key . hashCode () ) ^ ( value == null ? 0 : value . hashCode () ) ; } @Override public String toString () { if ( ! removed ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
switch ( index ) { case 3 : return parent . value3 ; case 2 : return parent . value2 ; case 1 : return parent . value1 ; } throw new IllegalStateException ( lr_1 + index ) ; MST[experimental.NakedReceiverMutator]MSP[N] } @Override public V setValue ( final V value ) {
if ( obj instanceof Map . Entry == false ) { return false ; MST[rv.CRCR5Mutator]MSP[S] } final Map . Entry < ? , ? > other = ( Map . Entry < ? , ? > ) obj ; final Object key = getKey () ;
void setRemoved ( final boolean flag ) { this . removed = flag ; } @Override public K getKey () { if ( removed ) { throw new IllegalStateException ( AbstractHashedMap . GETKEY_INVALID ) ; MST[ConstructorCallMutator]MSP[S] } switch ( index ) { case 3 : return parent . key3 ;
void setRemoved ( final boolean flag ) { this . removed = flag ; } @Override public K getKey () { if ( removed ) { throw new IllegalStateException ( AbstractHashedMap . GETKEY_INVALID ) ; } switch ( index ) { MST[rv.UOI2Mutator]MSP[S] case 3 : return parent . key3 ;
switch ( index ) { MST[rv.ABSMutator]MSP[S] case 3 : return parent . value3 ; case 2 : return parent . value2 ; case 1 : return parent . value1 ; } throw new IllegalStateException ( lr_1 + index ) ; } @Override public V setValue ( final V value ) {
case 2 : return parent . key2 ; MST[ReturnValsMutator]MSP[S] case 1 : return parent . key1 ; } throw new IllegalStateException ( lr_1 + index ) ; } @Override public V getValue () { if ( removed ) { throw new IllegalStateException ( AbstractHashedMap . GETVALUE_INVALID ) ; }
return getKey () + lr_3 + getValue () ; MST[experimental.NakedReceiverMutator]MSP[S] } return lr_6 ; } public boolean hasNext () { return nextIndex < parent . size ; } public Map . Entry < K , V > nextEntry () { if ( ! hasNext () ) {
void setRemoved ( final boolean flag ) { this . removed = flag ; } @Override public K getKey () { if ( removed ) { MST[rv.ROR3Mutator]MSP[S] throw new IllegalStateException ( AbstractHashedMap . GETKEY_INVALID ) ; } switch ( index ) { case 3 : return parent . key3 ;
return getKey () + lr_3 + getValue () ; MST[EmptyObjectReturnValsMutator]MSP[S] } return lr_6 ; } public boolean hasNext () { return nextIndex < parent . size ; } public Map . Entry < K , V > nextEntry () { if ( ! hasNext () ) {
void setRemoved ( final boolean flag ) { this . removed = flag ; } @Override public K getKey () { if ( removed ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] throw new IllegalStateException ( AbstractHashedMap . GETKEY_INVALID ) ; } switch ( index ) { case 3 : return parent . key3 ;
parent . value1 = value ; MST[NonVoidMethodCallMutator]MSP[N] break; default: throw new IllegalStateException ( lr_1 + index ) ; } return old ; } @Override public boolean equals ( final Object obj ) { if ( removed ) { return false ; }
switch ( index ) { case 3 : return parent . value3 ; case 2 : return parent . value2 ; case 1 : return parent . value1 ; MST[NonVoidMethodCallMutator]MSP[S] } throw new IllegalStateException ( lr_1 + index ) ; } @Override public V setValue ( final V value ) {
if ( removed ) { MST[rv.ROR5Mutator]MSP[S] throw new IllegalStateException ( AbstractHashedMap . SETVALUE_INVALID ) ; } final V old = getValue () ; switch ( index ) { case 3 : parent . value3 = value ; break; case 2 : parent . value2 = value ; break; case 1 :
if ( obj instanceof Map . Entry == false ) { MST[rv.ROR5Mutator]MSP[N] return false ; } final Map . Entry < ? , ? > other = ( Map . Entry < ? , ? > ) obj ; final Object key = getKey () ;
return parent . delegateMap . values () . iterator () ; } if ( parent . size () == 0 ) { MST[rv.ROR5Mutator]MSP[N] return EmptyIterator . <V > emptyIterator () ; } return new ValuesIterator <> ( parent ) ; } @Override public V next () {
return parent . delegateMap . values () . iterator () ; } if ( parent . size () == 0 ) { MST[rv.ROR4Mutator]MSP[N] return EmptyIterator . <V > emptyIterator () ; } return new ValuesIterator <> ( parent ) ; } @Override public V next () {
public Collection < V > values () { if ( delegateMap != null ) { return delegateMap . values () ; } return new Values <> ( this ) ; } @Override public int size () { return parent . size () ; MST[NonVoidMethodCallMutator]MSP[N] } @Override public void clear () {
return parent . delegateMap . values () . iterator () ; } if ( parent . size () == 0 ) { MST[rv.ROR1Mutator]MSP[N] return EmptyIterator . <V > emptyIterator () ; } return new ValuesIterator <> ( parent ) ; } @Override public V next () {
parent . clear () ; } @Override public boolean contains ( final Object value ) { return parent . containsValue ( value ) ; MST[NonVoidMethodCallMutator]MSP[N] } @Override public Iterator < V > iterator () { if ( parent . delegateMap != null ) {
return parent . delegateMap . values () . iterator () ; } if ( parent . size () == 0 ) { MST[rv.ROR2Mutator]MSP[N] return EmptyIterator . <V > emptyIterator () ; } return new ValuesIterator <> ( parent ) ; } @Override public V next () {
return parent . delegateMap . values () . iterator () ; } if ( parent . size () == 0 ) { MST[NegateConditionalsMutator]MSP[N] return EmptyIterator . <V > emptyIterator () ; } return new ValuesIterator <> ( parent ) ; } @Override public V next () {
parent . clear () ; } @Override public boolean contains ( final Object value ) { return parent . containsValue ( value ) ; } @Override public Iterator < V > iterator () { if ( parent . delegateMap != null ) { MST[NonVoidMethodCallMutator]MSP[N]
parent . clear () ; } @Override public boolean contains ( final Object value ) { return parent . containsValue ( value ) ; MST[BooleanTrueReturnValsMutator]MSP[S] } @Override public Iterator < V > iterator () { if ( parent . delegateMap != null ) {
parent . clear () ; } @Override public boolean contains ( final Object value ) { return parent . containsValue ( value ) ; MST[ReturnValsMutator]MSP[S] } @Override public Iterator < V > iterator () { if ( parent . delegateMap != null ) {
return parent . delegateMap . values () . iterator () ; } if ( parent . size () == 0 ) { MST[rv.ROR3Mutator]MSP[N] return EmptyIterator . <V > emptyIterator () ; } return new ValuesIterator <> ( parent ) ; } @Override public V next () {
parent . clear () ; } @Override public boolean contains ( final Object value ) { return parent . containsValue ( value ) ; MST[BooleanFalseReturnValsMutator]MSP[N] } @Override public Iterator < V > iterator () { if ( parent . delegateMap != null ) {
public Collection < V > values () { if ( delegateMap != null ) { return delegateMap . values () ; } return new Values <> ( this ) ; } @Override public int size () { return parent . size () ; MST[PrimitiveReturnsMutator]MSP[N] } @Override public void clear () {
return parent . delegateMap . values () . iterator () ; } if ( parent . size () == 0 ) { MST[NonVoidMethodCallMutator]MSP[N] return EmptyIterator . <V > emptyIterator () ; } return new ValuesIterator <> ( parent ) ; } @Override public V next () {
return parent . delegateMap . values () . iterator () ; } if ( parent . size () == 0 ) { return EmptyIterator . <V > emptyIterator () ; MST[NonVoidMethodCallMutator]MSP[N] } return new ValuesIterator <> ( parent ) ; } @Override public V next () {
return parent . delegateMap . values () . iterator () ; } if ( parent . size () == 0 ) { return EmptyIterator . <V > emptyIterator () ; MST[ReturnValsMutator]MSP[N] } return new ValuesIterator <> ( parent ) ; } @Override public V next () {
parent . clear () ; } @Override public boolean contains ( final Object value ) { return parent . containsValue ( value ) ; } @Override public Iterator < V > iterator () { if ( parent . delegateMap != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S]
return parent . delegateMap . values () . iterator () ; } if ( parent . size () == 0 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return EmptyIterator . <V > emptyIterator () ; } return new ValuesIterator <> ( parent ) ; } @Override public V next () {
parent . clear () ; MST[VoidMethodCallMutator]MSP[N] } @Override public boolean contains ( final Object value ) { return parent . containsValue ( value ) ; } @Override public Iterator < V > iterator () { if ( parent . delegateMap != null ) {
public Collection < V > values () { if ( delegateMap != null ) { return delegateMap . values () ; } return new Values <> ( this ) ; } @Override public int size () { return parent . size () ; MST[ReturnValsMutator]MSP[N] } @Override public void clear () {
parent . clear () ; } @Override public boolean contains ( final Object value ) { return parent . containsValue ( value ) ; } @Override public Iterator < V > iterator () { if ( parent . delegateMap != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
parent . clear () ; } @Override public boolean contains ( final Object value ) { return parent . containsValue ( value ) ; } @Override public Iterator < V > iterator () { if ( parent . delegateMap != null ) { MST[rv.ROR5Mutator]MSP[S]
return parent . delegateMap . values () . iterator () ; } if ( parent . size () == 0 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return EmptyIterator . <V > emptyIterator () ; } return new ValuesIterator <> ( parent ) ; } @Override public V next () {
return parent . delegateMap . values () . iterator () ; } if ( parent . size () == 0 ) { return EmptyIterator . <V > emptyIterator () ; MST[NullReturnValsMutator]MSP[N] } return new ValuesIterator <> ( parent ) ; } @Override public V next () {
parent . clear () ; } @Override public boolean contains ( final Object value ) { return parent . containsValue ( value ) ; } @Override public Iterator < V > iterator () { if ( parent . delegateMap != null ) { MST[NegateConditionalsMutator]MSP[S]
