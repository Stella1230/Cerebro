final Predicate < E > [] preds = new Predicate [ size ] ; int i = 0 ; MST[rv.CRCR1Mutator]MSP[S] for ( final Map . Entry < Predicate < E > , Closure < E > > entry : predicatesAndClosures . entrySet () ) {
preds [ i ] = entry . getKey () ; closures [ i ] = entry . getValue () ; MST[rv.ABSMutator]MSP[S] i ++ ; } return new SwitchClosure <> ( false , preds , closures , defaultClosure ) ; } @Override public void execute ( final E input ) {
return ( Closure < E > ) ( defaultClosure == null ? NOPClosure . <E > nopClosure () : defaultClosure ) ; MST[NegateConditionalsMutator]MSP[N] } return new SwitchClosure <> ( predicates , closures , defaultClosure ) ; } @SuppressWarnings ( lr_1 )
for ( int i = 0 ; i < iPredicates . length ; i ++ ) { MST[rv.CRCR1Mutator]MSP[S] if ( iPredicates [ i ] . evaluate ( input ) == true ) { iClosures [ i ] . execute ( input ) ; return; } }
FunctorUtils . validate ( predicates ) ; FunctorUtils . validate ( closures ) ; if ( predicates . length != closures . length ) { throw new IllegalArgumentException ( lr_2 ) ; } if ( predicates . length == 0 ) { MST[NegateConditionalsMutator]MSP[N]
public static < E > Closure < E > switchClosure ( final Map < Predicate < E > , Closure < E > > predicatesAndClosures ) { Objects . requireNonNull ( predicatesAndClosures , lr_3 ) ; MST[NonVoidMethodCallMutator]MSP[N]
preds [ i ] = entry . getKey () ; MST[NonVoidMethodCallMutator]MSP[S] closures [ i ] = entry . getValue () ; i ++ ; } return new SwitchClosure <> ( false , preds , closures , defaultClosure ) ; } @Override public void execute ( final E input ) {
final Predicate < E > [] preds = new Predicate [ size ] ; int i = 0 ; MST[rv.CRCR3Mutator]MSP[S] for ( final Map . Entry < Predicate < E > , Closure < E > > entry : predicatesAndClosures . entrySet () ) {
final Predicate < E > [] preds = new Predicate [ size ] ; int i = 0 ; MST[rv.CRCR5Mutator]MSP[S] for ( final Map . Entry < Predicate < E > , Closure < E > > entry : predicatesAndClosures . entrySet () ) {
FunctorUtils . validate ( predicates ) ; MST[VoidMethodCallMutator]MSP[N] FunctorUtils . validate ( closures ) ; if ( predicates . length != closures . length ) { throw new IllegalArgumentException ( lr_2 ) ; } if ( predicates . length == 0 ) {
iDefault . execute ( input ) ; MST[VoidMethodCallMutator]MSP[N] } public Predicate < ? super E > [] getPredicates () { return FunctorUtils . <E > copy ( iPredicates ) ; } public Closure < ? super E > [] getClosures () {
FunctorUtils . validate ( predicates ) ; FunctorUtils . validate ( closures ) ; MST[VoidMethodCallMutator]MSP[N] if ( predicates . length != closures . length ) { throw new IllegalArgumentException ( lr_2 ) ; } if ( predicates . length == 0 ) {
FunctorUtils . validate ( predicates ) ; FunctorUtils . validate ( closures ) ; if ( predicates . length != closures . length ) { throw new IllegalArgumentException ( lr_2 ) ; MST[ConstructorCallMutator]MSP[S] } if ( predicates . length == 0 ) {
for ( int i = 0 ; i < iPredicates . length ; i ++ ) { MST[rv.ABSMutator]MSP[N] if ( iPredicates [ i ] . evaluate ( input ) == true ) { iClosures [ i ] . execute ( input ) ; return; } }
preds [ i ] = entry . getKey () ; MST[rv.ABSMutator]MSP[S] closures [ i ] = entry . getValue () ; i ++ ; } return new SwitchClosure <> ( false , preds , closures , defaultClosure ) ; } @Override public void execute ( final E input ) {
preds [ i ] = entry . getKey () ; closures [ i ] = entry . getValue () ; i ++ ; } return new SwitchClosure <> ( false , preds , closures , defaultClosure ) ; MST[rv.CRCR6Mutator]MSP[N] } @Override public void execute ( final E input ) {
preds [ i ] = entry . getKey () ; closures [ i ] = entry . getValue () ; i ++ ; } return new SwitchClosure <> ( false , preds , closures , defaultClosure ) ; MST[rv.CRCR5Mutator]MSP[N] } @Override public void execute ( final E input ) {
FunctorUtils . validate ( predicates ) ; FunctorUtils . validate ( closures ) ; if ( predicates . length != closures . length ) { throw new IllegalArgumentException ( lr_2 ) ; } if ( predicates . length == 0 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
for ( int i = 0 ; i < iPredicates . length ; i ++ ) { MST[rv.UOI3Mutator]MSP[S] if ( iPredicates [ i ] . evaluate ( input ) == true ) { iClosures [ i ] . execute ( input ) ; return; } }
for ( int i = 0 ; i < iPredicates . length ; i ++ ) { MST[ConditionalsBoundaryMutator]MSP[N] if ( iPredicates [ i ] . evaluate ( input ) == true ) { iClosures [ i ] . execute ( input ) ; return; } }
for ( int i = 0 ; i < iPredicates . length ; i ++ ) { MST[rv.UOI1Mutator]MSP[S] if ( iPredicates [ i ] . evaluate ( input ) == true ) { iClosures [ i ] . execute ( input ) ; return; } }
for ( int i = 0 ; i < iPredicates . length ; i ++ ) { MST[rv.ROR5Mutator]MSP[N] if ( iPredicates [ i ] . evaluate ( input ) == true ) { iClosures [ i ] . execute ( input ) ; return; } }
return ( Closure < E > ) ( defaultClosure == null ? NOPClosure . <E > nopClosure () : defaultClosure ) ; MST[NullReturnValsMutator]MSP[N] } final Closure < E > [] closures = new Closure [ size ] ;
for ( int i = 0 ; i < iPredicates . length ; i ++ ) { MST[rv.ROR3Mutator]MSP[N] if ( iPredicates [ i ] . evaluate ( input ) == true ) { iClosures [ i ] . execute ( input ) ; return; } }
for ( int i = 0 ; i < iPredicates . length ; i ++ ) { if ( iPredicates [ i ] . evaluate ( input ) == true ) { MST[rv.UOI4Mutator]MSP[N] iClosures [ i ] . execute ( input ) ; return; } }
return ( Closure < E > ) ( defaultClosure == null ? NOPClosure . <E > nopClosure () : defaultClosure ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } return new SwitchClosure <> ( predicates , closures , defaultClosure ) ; } @SuppressWarnings ( lr_1 )
for ( int i = 0 ; i < iPredicates . length ; i ++ ) { MST[rv.CRCR5Mutator]MSP[S] if ( iPredicates [ i ] . evaluate ( input ) == true ) { iClosures [ i ] . execute ( input ) ; return; } }
final Predicate < E > [] preds = new Predicate [ size ] ; int i = 0 ; MST[rv.CRCR6Mutator]MSP[S] for ( final Map . Entry < Predicate < E > , Closure < E > > entry : predicatesAndClosures . entrySet () ) {
for ( int i = 0 ; i < iPredicates . length ; i ++ ) { MST[rv.CRCR3Mutator]MSP[N] if ( iPredicates [ i ] . evaluate ( input ) == true ) { iClosures [ i ] . execute ( input ) ; return; } }
for ( int i = 0 ; i < iPredicates . length ; i ++ ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] if ( iPredicates [ i ] . evaluate ( input ) == true ) { iClosures [ i ] . execute ( input ) ; return; } }
return ( Closure < E > ) ( defaultClosure == null ? NOPClosure . <E > nopClosure () : defaultClosure ) ; } return new SwitchClosure <> ( predicates , closures , defaultClosure ) ; MST[NullReturnValsMutator]MSP[N] } @SuppressWarnings ( lr_1 )
FunctorUtils . validate ( predicates ) ; FunctorUtils . validate ( closures ) ; if ( predicates . length != closures . length ) { throw new IllegalArgumentException ( lr_2 ) ; } if ( predicates . length == 0 ) { MST[rv.ROR5Mutator]MSP[N]
final Closure < ? super E > defaultClosure = predicatesAndClosures . remove ( null ) ; final int size = predicatesAndClosures . size () ; if ( size == 0 ) { MST[rv.UOI3Mutator]MSP[N]
for ( int i = 0 ; i < iPredicates . length ; i ++ ) { if ( iPredicates [ i ] . evaluate ( input ) == true ) { MST[rv.CRCR6Mutator]MSP[N] iClosures [ i ] . execute ( input ) ; return; } }
for ( int i = 0 ; i < iPredicates . length ; i ++ ) { if ( iPredicates [ i ] . evaluate ( input ) == true ) { MST[rv.CRCR5Mutator]MSP[N] iClosures [ i ] . execute ( input ) ; return; } }
preds [ i ] = entry . getKey () ; closures [ i ] = entry . getValue () ; MST[rv.UOI1Mutator]MSP[S] i ++ ; } return new SwitchClosure <> ( false , preds , closures , defaultClosure ) ; } @Override public void execute ( final E input ) {
for ( int i = 0 ; i < iPredicates . length ; i ++ ) { if ( iPredicates [ i ] . evaluate ( input ) == true ) { MST[rv.ROR1Mutator]MSP[N] iClosures [ i ] . execute ( input ) ; return; } }
for ( int i = 0 ; i < iPredicates . length ; i ++ ) { if ( iPredicates [ i ] . evaluate ( input ) == true ) { MST[rv.ROR2Mutator]MSP[N] iClosures [ i ] . execute ( input ) ; return; } }
preds [ i ] = entry . getKey () ; closures [ i ] = entry . getValue () ; MST[rv.UOI4Mutator]MSP[S] i ++ ; } return new SwitchClosure <> ( false , preds , closures , defaultClosure ) ; } @Override public void execute ( final E input ) {
final Closure < ? super E > defaultClosure = predicatesAndClosures . remove ( null ) ; final int size = predicatesAndClosures . size () ; if ( size == 0 ) { MST[NegateConditionalsMutator]MSP[S]
final Closure < ? super E > defaultClosure = predicatesAndClosures . remove ( null ) ; final int size = predicatesAndClosures . size () ; if ( size == 0 ) { MST[rv.UOI2Mutator]MSP[S]
return ( Closure < E > ) ( defaultClosure == null ? NOPClosure . <E > nopClosure () : defaultClosure ) ; MST[ReturnValsMutator]MSP[N] } final Closure < E > [] closures = new Closure [ size ] ;
return ( Closure < E > ) ( defaultClosure == null ? NOPClosure . <E > nopClosure () : defaultClosure ) ; MST[NegateConditionalsMutator]MSP[N] } final Closure < E > [] closures = new Closure [ size ] ;
preds [ i ] = entry . getKey () ; MST[rv.UOI4Mutator]MSP[S] closures [ i ] = entry . getValue () ; i ++ ; } return new SwitchClosure <> ( false , preds , closures , defaultClosure ) ; } @Override public void execute ( final E input ) {
for ( int i = 0 ; i < iPredicates . length ; i ++ ) { if ( iPredicates [ i ] . evaluate ( input ) == true ) { MST[rv.ABSMutator]MSP[N] iClosures [ i ] . execute ( input ) ; return; } }
FunctorUtils . validate ( predicates ) ; FunctorUtils . validate ( closures ) ; if ( predicates . length != closures . length ) { throw new IllegalArgumentException ( lr_2 ) ; } if ( predicates . length == 0 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
for ( int i = 0 ; i < iPredicates . length ; i ++ ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] if ( iPredicates [ i ] . evaluate ( input ) == true ) { iClosures [ i ] . execute ( input ) ; return; } }
return ( Closure < E > ) ( defaultClosure == null ? NOPClosure . <E > nopClosure () : defaultClosure ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } return new SwitchClosure <> ( predicates , closures , defaultClosure ) ; } @SuppressWarnings ( lr_1 )
for ( int i = 0 ; i < iPredicates . length ; i ++ ) { if ( iPredicates [ i ] . evaluate ( input ) == true ) { MST[rv.CRCR2Mutator]MSP[N] iClosures [ i ] . execute ( input ) ; return; } }
FunctorUtils . validate ( predicates ) ; FunctorUtils . validate ( closures ) ; if ( predicates . length != closures . length ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] throw new IllegalArgumentException ( lr_2 ) ; } if ( predicates . length == 0 ) {
preds [ i ] = entry . getKey () ; MST[rv.UOI1Mutator]MSP[S] closures [ i ] = entry . getValue () ; i ++ ; } return new SwitchClosure <> ( false , preds , closures , defaultClosure ) ; } @Override public void execute ( final E input ) {
preds [ i ] = entry . getKey () ; closures [ i ] = entry . getValue () ; i ++ ; } return new SwitchClosure <> ( false , preds , closures , defaultClosure ) ; MST[rv.CRCR1Mutator]MSP[N] } @Override public void execute ( final E input ) {
for ( int i = 0 ; i < iPredicates . length ; i ++ ) { if ( iPredicates [ i ] . evaluate ( input ) == true ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] iClosures [ i ] . execute ( input ) ; return; } }
for ( int i = 0 ; i < iPredicates . length ; i ++ ) { MST[NegateConditionalsMutator]MSP[N] if ( iPredicates [ i ] . evaluate ( input ) == true ) { iClosures [ i ] . execute ( input ) ; return; } }
FunctorUtils . validate ( predicates ) ; FunctorUtils . validate ( closures ) ; if ( predicates . length != closures . length ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] throw new IllegalArgumentException ( lr_2 ) ; } if ( predicates . length == 0 ) {
final Predicate < E > [] preds = new Predicate [ size ] ; MST[rv.ABSMutator]MSP[S] int i = 0 ; for ( final Map . Entry < Predicate < E > , Closure < E > > entry : predicatesAndClosures . entrySet () ) {
final Predicate < E > [] preds = new Predicate [ size ] ; MST[rv.UOI1Mutator]MSP[N] int i = 0 ; for ( final Map . Entry < Predicate < E > , Closure < E > > entry : predicatesAndClosures . entrySet () ) {
for ( int i = 0 ; i < iPredicates . length ; i ++ ) { MST[rv.UOI2Mutator]MSP[N] if ( iPredicates [ i ] . evaluate ( input ) == true ) { iClosures [ i ] . execute ( input ) ; return; } }
for ( int i = 0 ; i < iPredicates . length ; i ++ ) { if ( iPredicates [ i ] . evaluate ( input ) == true ) { MST[rv.UOI1Mutator]MSP[N] iClosures [ i ] . execute ( input ) ; return; } }
final Closure < ? super E > defaultClosure = predicatesAndClosures . remove ( null ) ; MST[ArgumentPropagationMutator]MSP[S] final int size = predicatesAndClosures . size () ; if ( size == 0 ) {
for ( int i = 0 ; i < iPredicates . length ; i ++ ) { MST[rv.ROR4Mutator]MSP[N] if ( iPredicates [ i ] . evaluate ( input ) == true ) { iClosures [ i ] . execute ( input ) ; return; } }
for ( int i = 0 ; i < iPredicates . length ; i ++ ) { MST[rv.CRCR6Mutator]MSP[N] if ( iPredicates [ i ] . evaluate ( input ) == true ) { iClosures [ i ] . execute ( input ) ; return; } }
final Closure < ? super E > defaultClosure = predicatesAndClosures . remove ( null ) ; final int size = predicatesAndClosures . size () ; if ( size == 0 ) { MST[rv.ROR4Mutator]MSP[S]
for ( int i = 0 ; i < iPredicates . length ; i ++ ) { if ( iPredicates [ i ] . evaluate ( input ) == true ) { iClosures [ i ] . execute ( input ) ; MST[rv.UOI3Mutator]MSP[N] return; } }
return ( Closure < E > ) ( defaultClosure == null ? NOPClosure . <E > nopClosure () : defaultClosure ) ; } return new SwitchClosure <> ( predicates , closures , defaultClosure ) ; MST[ConstructorCallMutator]MSP[N] } @SuppressWarnings ( lr_1 )
FunctorUtils . validate ( predicates ) ; FunctorUtils . validate ( closures ) ; if ( predicates . length != closures . length ) { throw new IllegalArgumentException ( lr_2 ) ; } if ( predicates . length == 0 ) { MST[rv.ROR2Mutator]MSP[N]
return ( Closure < E > ) ( defaultClosure == null ? NOPClosure . <E > nopClosure () : defaultClosure ) ; } final Closure < E > [] closures = new Closure [ size ] ; MST[rv.UOI2Mutator]MSP[S]
return ( Closure < E > ) ( defaultClosure == null ? NOPClosure . <E > nopClosure () : defaultClosure ) ; MST[NonVoidMethodCallMutator]MSP[N] } final Closure < E > [] closures = new Closure [ size ] ;
return ( Closure < E > ) ( defaultClosure == null ? NOPClosure . <E > nopClosure () : defaultClosure ) ; } return new SwitchClosure <> ( predicates , closures , defaultClosure ) ; MST[ReturnValsMutator]MSP[N] } @SuppressWarnings ( lr_1 )
return ( Closure < E > ) ( defaultClosure == null ? NOPClosure . <E > nopClosure () : defaultClosure ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } final Closure < E > [] closures = new Closure [ size ] ;
FunctorUtils . validate ( predicates ) ; FunctorUtils . validate ( closures ) ; if ( predicates . length != closures . length ) { MST[rv.ROR3Mutator]MSP[N] throw new IllegalArgumentException ( lr_2 ) ; } if ( predicates . length == 0 ) {
FunctorUtils . validate ( predicates ) ; FunctorUtils . validate ( closures ) ; if ( predicates . length != closures . length ) { MST[rv.ROR2Mutator]MSP[S] throw new IllegalArgumentException ( lr_2 ) ; } if ( predicates . length == 0 ) {
final Closure < ? super E > defaultClosure = predicatesAndClosures . remove ( null ) ; final int size = predicatesAndClosures . size () ; if ( size == 0 ) { MST[rv.ROR5Mutator]MSP[S]
FunctorUtils . validate ( predicates ) ; FunctorUtils . validate ( closures ) ; if ( predicates . length != closures . length ) { MST[rv.ROR1Mutator]MSP[N] throw new IllegalArgumentException ( lr_2 ) ; } if ( predicates . length == 0 ) {
final Closure < ? super E > defaultClosure = predicatesAndClosures . remove ( null ) ; MST[NonVoidMethodCallMutator]MSP[S] final int size = predicatesAndClosures . size () ; if ( size == 0 ) {
FunctorUtils . validate ( predicates ) ; FunctorUtils . validate ( closures ) ; if ( predicates . length != closures . length ) { MST[rv.ROR4Mutator]MSP[N] throw new IllegalArgumentException ( lr_2 ) ; } if ( predicates . length == 0 ) {
FunctorUtils . validate ( predicates ) ; FunctorUtils . validate ( closures ) ; if ( predicates . length != closures . length ) { MST[rv.ROR5Mutator]MSP[N] throw new IllegalArgumentException ( lr_2 ) ; } if ( predicates . length == 0 ) {
final Closure < ? super E > defaultClosure = predicatesAndClosures . remove ( null ) ; final int size = predicatesAndClosures . size () ; if ( size == 0 ) { MST[rv.ABSMutator]MSP[N]
final Closure < ? super E > defaultClosure = predicatesAndClosures . remove ( null ) ; final int size = predicatesAndClosures . size () ; if ( size == 0 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S]
for ( int i = 0 ; i < iPredicates . length ; i ++ ) { if ( iPredicates [ i ] . evaluate ( input ) == true ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] iClosures [ i ] . execute ( input ) ; return; } }
return ( Closure < E > ) ( defaultClosure == null ? NOPClosure . <E > nopClosure () : defaultClosure ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } final Closure < E > [] closures = new Closure [ size ] ;
preds [ i ] = entry . getKey () ; closures [ i ] = entry . getValue () ; i ++ ; } return new SwitchClosure <> ( false , preds , closures , defaultClosure ) ; MST[InlineConstantMutator]MSP[N] } @Override public void execute ( final E input ) {
final Closure < ? super E > defaultClosure = predicatesAndClosures . remove ( null ) ; final int size = predicatesAndClosures . size () ; if ( size == 0 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S]
for ( int i = 0 ; i < iPredicates . length ; i ++ ) { if ( iPredicates [ i ] . evaluate ( input ) == true ) { iClosures [ i ] . execute ( input ) ; MST[VoidMethodCallMutator]MSP[N] return; } }
return ( Closure < E > ) ( defaultClosure == null ? NOPClosure . <E > nopClosure () : defaultClosure ) ; MST[NullReturnValsMutator]MSP[N] } return new SwitchClosure <> ( predicates , closures , defaultClosure ) ; } @SuppressWarnings ( lr_1 )
final Predicate < E > [] preds = new Predicate [ size ] ; MST[rv.UOI2Mutator]MSP[N] int i = 0 ; for ( final Map . Entry < Predicate < E > , Closure < E > > entry : predicatesAndClosures . entrySet () ) {
final Closure < ? super E > defaultClosure = predicatesAndClosures . remove ( null ) ; final int size = predicatesAndClosures . size () ; if ( size == 0 ) { MST[rv.ROR1Mutator]MSP[S]
preds [ i ] = entry . getKey () ; closures [ i ] = entry . getValue () ; i ++ ; } return new SwitchClosure <> ( false , preds , closures , defaultClosure ) ; MST[NullReturnValsMutator]MSP[S] } @Override public void execute ( final E input ) {
final Closure < ? super E > defaultClosure = predicatesAndClosures . remove ( null ) ; final int size = predicatesAndClosures . size () ; if ( size == 0 ) { MST[rv.ROR3Mutator]MSP[N]
return ( Closure < E > ) ( defaultClosure == null ? NOPClosure . <E > nopClosure () : defaultClosure ) ; } final Closure < E > [] closures = new Closure [ size ] ; MST[rv.UOI3Mutator]MSP[S]
for ( int i = 0 ; i < iPredicates . length ; i ++ ) { if ( iPredicates [ i ] . evaluate ( input ) == true ) { iClosures [ i ] . execute ( input ) ; MST[rv.UOI4Mutator]MSP[N] return; } }
for ( int i = 0 ; i < iPredicates . length ; i ++ ) { if ( iPredicates [ i ] . evaluate ( input ) == true ) { iClosures [ i ] . execute ( input ) ; MST[rv.UOI2Mutator]MSP[N] return; } }
final Predicate < E > [] preds = new Predicate [ size ] ; MST[rv.UOI4Mutator]MSP[S] int i = 0 ; for ( final Map . Entry < Predicate < E > , Closure < E > > entry : predicatesAndClosures . entrySet () ) {
for ( int i = 0 ; i < iPredicates . length ; i ++ ) { if ( iPredicates [ i ] . evaluate ( input ) == true ) { MST[rv.ROR3Mutator]MSP[N] iClosures [ i ] . execute ( input ) ; return; } }
for ( int i = 0 ; i < iPredicates . length ; i ++ ) { if ( iPredicates [ i ] . evaluate ( input ) == true ) { MST[rv.ROR5Mutator]MSP[N] iClosures [ i ] . execute ( input ) ; return; } }
return ( Closure < E > ) ( defaultClosure == null ? NOPClosure . <E > nopClosure () : defaultClosure ) ; MST[rv.ROR5Mutator]MSP[N] } final Closure < E > [] closures = new Closure [ size ] ;
return ( Closure < E > ) ( defaultClosure == null ? NOPClosure . <E > nopClosure () : defaultClosure ) ; } final Closure < E > [] closures = new Closure [ size ] ; MST[rv.UOI1Mutator]MSP[S]
FunctorUtils . validate ( predicates ) ; FunctorUtils . validate ( closures ) ; if ( predicates . length != closures . length ) { throw new IllegalArgumentException ( lr_2 ) ; } if ( predicates . length == 0 ) { MST[rv.ROR1Mutator]MSP[N]
for ( int i = 0 ; i < iPredicates . length ; i ++ ) { MST[InlineConstantMutator]MSP[S] if ( iPredicates [ i ] . evaluate ( input ) == true ) { iClosures [ i ] . execute ( input ) ; return; } }
return ( Closure < E > ) ( defaultClosure == null ? NOPClosure . <E > nopClosure () : defaultClosure ) ; MST[rv.ROR5Mutator]MSP[N] } return new SwitchClosure <> ( predicates , closures , defaultClosure ) ; } @SuppressWarnings ( lr_1 )
for ( int i = 0 ; i < iPredicates . length ; i ++ ) { if ( iPredicates [ i ] . evaluate ( input ) == true ) { MST[NonVoidMethodCallMutator]MSP[N] iClosures [ i ] . execute ( input ) ; return; } }
return ( Closure < E > ) ( defaultClosure == null ? NOPClosure . <E > nopClosure () : defaultClosure ) ; } final Closure < E > [] closures = new Closure [ size ] ; MST[rv.ABSMutator]MSP[S]
final Closure < ? super E > defaultClosure = predicatesAndClosures . remove ( null ) ; final int size = predicatesAndClosures . size () ; if ( size == 0 ) { MST[rv.UOI4Mutator]MSP[N]
FunctorUtils . validate ( predicates ) ; FunctorUtils . validate ( closures ) ; if ( predicates . length != closures . length ) { throw new IllegalArgumentException ( lr_2 ) ; } if ( predicates . length == 0 ) { MST[rv.ROR4Mutator]MSP[N]
for ( int i = 0 ; i < iPredicates . length ; i ++ ) { if ( iPredicates [ i ] . evaluate ( input ) == true ) { MST[rv.CRCR4Mutator]MSP[N] iClosures [ i ] . execute ( input ) ; return; } }
FunctorUtils . validate ( predicates ) ; FunctorUtils . validate ( closures ) ; if ( predicates . length != closures . length ) { throw new IllegalArgumentException ( lr_2 ) ; } if ( predicates . length == 0 ) { MST[rv.ROR3Mutator]MSP[N]
preds [ i ] = entry . getKey () ; closures [ i ] = entry . getValue () ; MST[rv.UOI2Mutator]MSP[S] i ++ ; } return new SwitchClosure <> ( false , preds , closures , defaultClosure ) ; } @Override public void execute ( final E input ) {
for ( int i = 0 ; i < iPredicates . length ; i ++ ) { if ( iPredicates [ i ] . evaluate ( input ) == true ) { iClosures [ i ] . execute ( input ) ; MST[rv.ABSMutator]MSP[N] return; } }
final Closure < ? super E > defaultClosure = predicatesAndClosures . remove ( null ) ; final int size = predicatesAndClosures . size () ; if ( size == 0 ) { MST[rv.UOI1Mutator]MSP[S]
preds [ i ] = entry . getKey () ; closures [ i ] = entry . getValue () ; MST[rv.UOI3Mutator]MSP[S] i ++ ; } return new SwitchClosure <> ( false , preds , closures , defaultClosure ) ; } @Override public void execute ( final E input ) {
preds [ i ] = entry . getKey () ; closures [ i ] = entry . getValue () ; i ++ ; } return new SwitchClosure <> ( false , preds , closures , defaultClosure ) ; MST[ReturnValsMutator]MSP[S] } @Override public void execute ( final E input ) {
preds [ i ] = entry . getKey () ; MST[rv.UOI3Mutator]MSP[S] closures [ i ] = entry . getValue () ; i ++ ; } return new SwitchClosure <> ( false , preds , closures , defaultClosure ) ; } @Override public void execute ( final E input ) {
preds [ i ] = entry . getKey () ; closures [ i ] = entry . getValue () ; i ++ ; } return new SwitchClosure <> ( false , preds , closures , defaultClosure ) ; MST[ConstructorCallMutator]MSP[S] } @Override public void execute ( final E input ) {
for ( int i = 0 ; i < iPredicates . length ; i ++ ) { MST[rv.ROR2Mutator]MSP[N] if ( iPredicates [ i ] . evaluate ( input ) == true ) { iClosures [ i ] . execute ( input ) ; return; } }
for ( int i = 0 ; i < iPredicates . length ; i ++ ) { MST[rv.ROR1Mutator]MSP[N] if ( iPredicates [ i ] . evaluate ( input ) == true ) { iClosures [ i ] . execute ( input ) ; return; } }
FunctorUtils . validate ( predicates ) ; FunctorUtils . validate ( closures ) ; if ( predicates . length != closures . length ) { MST[NegateConditionalsMutator]MSP[N] throw new IllegalArgumentException ( lr_2 ) ; } if ( predicates . length == 0 ) {
final Predicate < E > [] preds = new Predicate [ size ] ; int i = 0 ; for ( final Map . Entry < Predicate < E > , Closure < E > > entry : predicatesAndClosures . entrySet () ) { MST[NonVoidMethodCallMutator]MSP[S]
for ( int i = 0 ; i < iPredicates . length ; i ++ ) { if ( iPredicates [ i ] . evaluate ( input ) == true ) { MST[rv.CRCR3Mutator]MSP[N] iClosures [ i ] . execute ( input ) ; return; } }
preds [ i ] = entry . getKey () ; closures [ i ] = entry . getValue () ; i ++ ; } return new SwitchClosure <> ( false , preds , closures , defaultClosure ) ; MST[rv.CRCR3Mutator]MSP[N] } @Override public void execute ( final E input ) {
preds [ i ] = entry . getKey () ; MST[rv.UOI2Mutator]MSP[S] closures [ i ] = entry . getValue () ; i ++ ; } return new SwitchClosure <> ( false , preds , closures , defaultClosure ) ; } @Override public void execute ( final E input ) {
preds [ i ] = entry . getKey () ; closures [ i ] = entry . getValue () ; i ++ ; MST[experimental.RemoveIncrementsMutator]MSP[S] } return new SwitchClosure <> ( false , preds , closures , defaultClosure ) ; } @Override public void execute ( final E input ) {
for ( int i = 0 ; i < iPredicates . length ; i ++ ) { MST[rv.UOI4Mutator]MSP[N] if ( iPredicates [ i ] . evaluate ( input ) == true ) { iClosures [ i ] . execute ( input ) ; return; } }
preds [ i ] = entry . getKey () ; closures [ i ] = entry . getValue () ; i ++ ; MST[IncrementsMutator]MSP[S] } return new SwitchClosure <> ( false , preds , closures , defaultClosure ) ; } @Override public void execute ( final E input ) {
return ( Closure < E > ) ( defaultClosure == null ? NOPClosure . <E > nopClosure () : defaultClosure ) ; MST[ReturnValsMutator]MSP[N] } return new SwitchClosure <> ( predicates , closures , defaultClosure ) ; } @SuppressWarnings ( lr_1 )
final Predicate < E > [] preds = new Predicate [ size ] ; MST[rv.UOI3Mutator]MSP[S] int i = 0 ; for ( final Map . Entry < Predicate < E > , Closure < E > > entry : predicatesAndClosures . entrySet () ) {
for ( int i = 0 ; i < iPredicates . length ; i ++ ) { if ( iPredicates [ i ] . evaluate ( input ) == true ) { MST[InlineConstantMutator]MSP[N] iClosures [ i ] . execute ( input ) ; return; } }
public static < E > Closure < E > switchClosure ( final Map < Predicate < E > , Closure < E > > predicatesAndClosures ) { Objects . requireNonNull ( predicatesAndClosures , lr_3 ) ; MST[ArgumentPropagationMutator]MSP[N]
for ( int i = 0 ; i < iPredicates . length ; i ++ ) { if ( iPredicates [ i ] . evaluate ( input ) == true ) { MST[NegateConditionalsMutator]MSP[N] iClosures [ i ] . execute ( input ) ; return; } }
final Predicate < E > [] preds = new Predicate [ size ] ; int i = 0 ; MST[InlineConstantMutator]MSP[S] for ( final Map . Entry < Predicate < E > , Closure < E > > entry : predicatesAndClosures . entrySet () ) {
for ( int i = 0 ; i < iPredicates . length ; i ++ ) { if ( iPredicates [ i ] . evaluate ( input ) == true ) { MST[rv.UOI3Mutator]MSP[S] iClosures [ i ] . execute ( input ) ; return; } }
return ( Closure < E > ) ( defaultClosure == null ? NOPClosure . <E > nopClosure () : defaultClosure ) ; MST[NonVoidMethodCallMutator]MSP[N] } return new SwitchClosure <> ( predicates , closures , defaultClosure ) ; } @SuppressWarnings ( lr_1 )
final Closure < ? super E > defaultClosure = predicatesAndClosures . remove ( null ) ; final int size = predicatesAndClosures . size () ; if ( size == 0 ) { MST[rv.ROR2Mutator]MSP[S]
preds [ i ] = entry . getKey () ; closures [ i ] = entry . getValue () ; MST[NonVoidMethodCallMutator]MSP[S] i ++ ; } return new SwitchClosure <> ( false , preds , closures , defaultClosure ) ; } @Override public void execute ( final E input ) {
return ( Closure < E > ) ( defaultClosure == null ? NOPClosure . <E > nopClosure () : defaultClosure ) ; } final Closure < E > [] closures = new Closure [ size ] ; MST[rv.UOI4Mutator]MSP[S]
for ( int i = 0 ; i < iPredicates . length ; i ++ ) { if ( iPredicates [ i ] . evaluate ( input ) == true ) { iClosures [ i ] . execute ( input ) ; MST[rv.UOI1Mutator]MSP[N] return; } }
for ( int i = 0 ; i < iPredicates . length ; i ++ ) { if ( iPredicates [ i ] . evaluate ( input ) == true ) { MST[rv.ROR4Mutator]MSP[N] iClosures [ i ] . execute ( input ) ; return; } }
final Closure < ? super E > defaultClosure = predicatesAndClosures . remove ( null ) ; final int size = predicatesAndClosures . size () ; MST[NonVoidMethodCallMutator]MSP[S] if ( size == 0 ) {
