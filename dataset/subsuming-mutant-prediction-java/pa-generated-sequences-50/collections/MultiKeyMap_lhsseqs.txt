final int hashCode = hash ( key1 , key2 , key3 ) ; final int index = decorated () . hashIndex ( hashCode , decorated () . data . length ) ; MST[NonVoidMethodCallMutator]MSP[]
protected boolean isEqualKey ( final AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry , final Object key1 , final Object key2 ) { final MultiKey < ? extends K > multi = entry . getKey () ; return MST[ReturnValsMutator]MSP[]
AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > previous = null ; while ( entry != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 , key4 ) ) {
AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ index ] ; MST[rv.ABSMutator]MSP[] while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 ) ) {
final MultiKey < ? extends K > multi = entry . getKey () ; return multi . size () == 3 && MST[rv.CRCR4Mutator]MSP[] ( key1 == multi . getKey ( 0 ) || key1 != null && key1 . equals ( multi . getKey ( 0 ) ) ) &&
final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 3 && ( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) && MST[NonVoidMethodCallMutator]MSP[]
( key3 == multi . getKey ( 2 ) || key3 != null && key3 . equals ( multi . getKey ( 2 ) ) ) ; MST[rv.CRCR6Mutator]MSP[] } public V get ( final Object key1 , final Object key2 , final Object key3 , final Object key4 ) {
decorated () . data [ decorated () . hashIndex ( hashCode , decorated () . data . length ) ] ; MST[rv.UOI3Mutator]MSP[] while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 , key4 ) ) {
h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; MST[rv.CRCR1Mutator]MSP[] return h ; }
( key1 == multi . getKey ( 0 ) || key1 != null && key1 . equals ( multi . getKey ( 0 ) ) ) && MST[rv.CRCR6Mutator]MSP[]
final MapIterator < MultiKey < ? extends K > , V > it = mapIterator () ; while ( it . hasNext () ) { MST[rv.ROR1Mutator]MSP[] final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 1 &&
( key3 == null ? multi . getKey ( 2 ) == null : key3 . equals ( multi . getKey ( 2 ) ) ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] it . remove () ; modified = true ; } } return modified ; }
final MapIterator < MultiKey < ? extends K > , V > it = mapIterator () ; while ( it . hasNext () ) { final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 1 && MST[rv.CRCR3Mutator]MSP[]
( key3 == null ? multi . getKey ( 2 ) == null : key3 . equals ( multi . getKey ( 2 ) ) ) ) { MST[rv.ROR3Mutator]MSP[] it . remove () ; modified = true ; } } return modified ; }
h ^= key2 . hashCode () ; } if ( key3 != null ) { h ^= key3 . hashCode () ; } if ( key4 != null ) { h ^= key4 . hashCode () ; } h += ~ ( h << 9 ) ; MST[InlineConstantMutator]MSP[]
h += h << 4 ; h ^= h >>> 10 ; return h ; MST[rv.UOI3Mutator]MSP[] } protected boolean isEqualKey ( final AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry , final Object key1 , final Object key2 , final Object key3 ) {
public V put ( final K key1 , final K key2 , final V value ) { final int hashCode = hash ( key1 , key2 ) ; final int index = decorated () . hashIndex ( hashCode , decorated () . data . length ) ; MST[NonVoidMethodCallMutator]MSP[]
decorated () . data [ decorated () . hashIndex ( hashCode , decorated () . data . length ) ] ; while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 , key4 ) ) { MST[rv.UOI3Mutator]MSP[]
( key2 == null ? multi . getKey ( 1 ) == null : key2 . equals ( multi . getKey ( 1 ) ) ) ) { it . remove () ; modified = true ; MST[InlineConstantMutator]MSP[] } } return modified ; }
AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ index ] ; AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > previous = null ; while ( entry != null ) { MST[rv.ROR5Mutator]MSP[]
( key3 == null ? multi . getKey ( 2 ) == null : key3 . equals ( multi . getKey ( 2 ) ) ) ) { it . remove () ; modified = true ; MST[rv.CRCR4Mutator]MSP[] } } return modified ; }
while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 ) ) { MST[rv.UOI2Mutator]MSP[] return true ; } entry = entry . next ; } return false ; }
AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > previous = null ; while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 , key4 ) ) { MST[rv.ROR2Mutator]MSP[]
( key3 == multi . getKey ( 2 ) || key3 != null && key3 . equals ( multi . getKey ( 2 ) ) ) && MST[rv.CRCR6Mutator]MSP[]
AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ decorated () . hashIndex ( hashCode , decorated () . data . length ) ] ; while ( entry != null ) { MST[rv.ROR5Mutator]MSP[]
final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 2 && MST[rv.ROR4Mutator]MSP[] ( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) &&
while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 ) ) { MST[rv.ROR1Mutator]MSP[] return true ; } entry = entry . next ; } return false ; }
decorated () . addMapping ( index , hashCode , new MultiKey <> ( key1 , key2 , key3 ) , value ) ; MST[rv.UOI4Mutator]MSP[] return null ; } public V removeMultiKey ( final Object key1 , final Object key2 , final Object key3 ) {
protected int hash ( final Object key1 , final Object key2 , final Object key3 , final Object key4 ) { int h = 0 ; if ( key1 != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] h ^= key1 . hashCode () ; } if ( key2 != null ) {
return true ; } entry = entry . next ; } return false ; MST[InlineConstantMutator]MSP[] } public V put ( final K key1 , final K key2 , final K key3 , final V value ) { final int hashCode = hash ( key1 , key2 , key3 ) ;
if ( key2 != null ) { h ^= key2 . hashCode () ; } if ( key3 != null ) { h ^= key3 . hashCode () ; } h += ~ ( h << 9 ) ; h ^= h >>> 14 ; MST[rv.UOI1Mutator]MSP[]
decorated () . data [ decorated () . hashIndex ( hashCode , decorated () . data . length ) ] ; while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 , key4 ) ) { MST[rv.ROR4Mutator]MSP[]
h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; MST[rv.AOR4Mutator]MSP[] h ^= h >>> 10 ; return h ; }
while ( it . hasNext () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 4 &&
final MapIterator < MultiKey < ? extends K > , V > it = mapIterator () ; while ( it . hasNext () ) { final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 1 && MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
final MapIterator < MultiKey < ? extends K > , V > it = mapIterator () ; while ( it . hasNext () ) { final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 1 && MST[ConditionalsBoundaryMutator]MSP[]
final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 3 && ( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) && MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
h ^= h >>> 14 ; MST[rv.CRCR4Mutator]MSP[] h += h << 4 ; h ^= h >>> 10 ; return h ; } protected boolean isEqualKey ( final AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry ,
( key2 == multi . getKey ( 1 ) || key2 != null && key2 . equals ( multi . getKey ( 1 ) ) ) && MST[rv.CRCR6Mutator]MSP[]
h ^= key2 . hashCode () ; } if ( key3 != null ) { h ^= key3 . hashCode () ; } if ( key4 != null ) { h ^= key4 . hashCode () ; } h += ~ ( h << 9 ) ; MST[rv.CRCR2Mutator]MSP[]
while ( it . hasNext () ) { MST[rv.ROR3Mutator]MSP[] final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 4 &&
if ( key5 != null ) { h ^= key5 . hashCode () ; } h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; MST[rv.CRCR3Mutator]MSP[] h ^= h >>> 10 ; return h ; }
protected int hash ( final Object key1 , final Object key2 , final Object key3 , final Object key4 ) { int h = 0 ; if ( key1 != null ) { h ^= key1 . hashCode () ; MST[rv.UOI2Mutator]MSP[] } if ( key2 != null ) {
AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ index ] ; MST[rv.UOI2Mutator]MSP[] AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > previous = null ; while ( entry != null ) {
h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; MST[rv.UOI3Mutator]MSP[] h ^= h >>> 10 ; return h ; }
final int index = decorated () . hashIndex ( hashCode , decorated () . data . length ) ; MST[NonVoidMethodCallMutator]MSP[] AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ index ] ; while ( entry != null ) {
if ( key5 != null ) { h ^= key5 . hashCode () ; } h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; return h ; MST[rv.UOI3Mutator]MSP[] }
if ( key2 != null ) { h ^= key2 . hashCode () ; } if ( key3 != null ) { h ^= key3 . hashCode () ; } if ( key4 != null ) { h ^= key4 . hashCode () ; MST[rv.ABSMutator]MSP[] }
final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 3 && MST[rv.CRCR4Mutator]MSP[] ( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) &&
( key2 == multi . getKey ( 1 ) || key2 != null && key2 . equals ( multi . getKey ( 1 ) ) ) ; MST[rv.ROR5Mutator]MSP[] } public V get ( final Object key1 , final Object key2 , final Object key3 ) {
if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 , key4 ) ) { final V oldValue = entry . getValue () ; decorated () . updateEntry ( entry , value ) ; return oldValue ; MST[NullReturnValsMutator]MSP[] }
final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 3 && MST[rv.CRCR1Mutator]MSP[] ( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) &&
if ( key5 != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] h ^= key5 . hashCode () ; } h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; return h ; }
multi . size () == 2 && MST[rv.CRCR2Mutator]MSP[] ( key1 == multi . getKey ( 0 ) || key1 != null && key1 . equals ( multi . getKey ( 0 ) ) ) &&
( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) ) { MST[NegateConditionalsMutator]MSP[] it . remove () ; modified = true ; } } return modified ; }
return ( MultiKeyMap < K , V > ) super . clone () ; MST[experimental.NakedReceiverMutator]MSP[] } catch ( final CloneNotSupportedException e ) { throw new InternalError () ; } } @Override public V put ( final MultiKey < ? extends K > key , final V value ) {
AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ decorated () . hashIndex ( hashCode , decorated () . data . length ) ] ; while ( entry != null ) { MST[NegateConditionalsMutator]MSP[]
if ( key2 != null ) { h ^= key2 . hashCode () ; } if ( key3 != null ) { h ^= key3 . hashCode () ; } h += ~ ( h << 9 ) ; MST[rv.UOI2Mutator]MSP[] h ^= h >>> 14 ;
( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) && MST[rv.CRCR6Mutator]MSP[]
if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 ) ) { MST[NegateConditionalsMutator]MSP[] final V oldValue = entry . getValue () ; decorated () . removeMapping ( entry , index , previous ) ; return oldValue ; } previous = entry ;
final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 2 && ( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) && MST[rv.ROR4Mutator]MSP[]
decorated () . data [ decorated () . hashIndex ( hashCode , decorated () . data . length ) ] ; MST[NonVoidMethodCallMutator]MSP[] while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 ) ) {
if ( key2 != null ) { h ^= key2 . hashCode () ; MST[MathMutator]MSP[] } if ( key3 != null ) { h ^= key3 . hashCode () ; } if ( key4 != null ) { h ^= key4 . hashCode () ; }
h ^= key2 . hashCode () ; } if ( key3 != null ) { h ^= key3 . hashCode () ; } if ( key4 != null ) { h ^= key4 . hashCode () ; MST[rv.UOI4Mutator]MSP[] } h += ~ ( h << 9 ) ;
final int index = decorated () . hashIndex ( hashCode , decorated () . data . length ) ; AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ index ] ; while ( entry != null ) { MST[rv.ROR5Mutator]MSP[]
h ^= h >>> 14 ; MST[rv.CRCR1Mutator]MSP[] h += h << 4 ; h ^= h >>> 10 ; return h ; } protected boolean isEqualKey ( final AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry ,
h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; return h ; MST[rv.UOI1Mutator]MSP[] } protected boolean isEqualKey ( final AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry ,
multi . size () == 2 && ( key1 == multi . getKey ( 0 ) || key1 != null && key1 . equals ( multi . getKey ( 0 ) ) ) && MST[rv.ROR5Mutator]MSP[]
final Object key1 , final Object key2 , final Object key3 , final Object key4 ) { final MultiKey < ? extends K > multi = entry . getKey () ; return multi . size () == 4 && MST[rv.ROR1Mutator]MSP[]
return true ; } entry = entry . next ; } return false ; MST[rv.CRCR3Mutator]MSP[] } public V put ( final K key1 , final K key2 , final K key3 , final K key4 , final V value ) {
if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 , key4 ) ) { final V oldValue = entry . getValue () ; decorated () . updateEntry ( entry , value ) ; MST[NonVoidMethodCallMutator]MSP[] return oldValue ; }
h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; MST[rv.UOI4Mutator]MSP[] return h ; } protected boolean isEqualKey ( final AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry ,
AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ index ] ; while ( entry != null ) { MST[NegateConditionalsMutator]MSP[] if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 ) ) {
return decorated () . mapIterator () ; MST[NullReturnValsMutator]MSP[] } @Override protected AbstractHashedMap < MultiKey < ? extends K > , V > decorated () { return ( AbstractHashedMap < MultiKey < ? extends K > , V > ) super . decorated () ; }
h ^= key2 . hashCode () ; } if ( key3 != null ) { h ^= key3 . hashCode () ; } if ( key4 != null ) { h ^= key4 . hashCode () ; } h += ~ ( h << 9 ) ; MST[rv.AOD2Mutator]MSP[]
final int index = decorated () . hashIndex ( hashCode , decorated () . data . length ) ; MST[NonVoidMethodCallMutator]MSP[] AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ index ] ;
if ( key2 != null ) { h ^= key2 . hashCode () ; MST[rv.ABSMutator]MSP[] } if ( key3 != null ) { h ^= key3 . hashCode () ; } h += ~ ( h << 9 ) ; h ^= h >>> 14 ;
AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ decorated () . hashIndex ( hashCode , decorated () . data . length ) ] ; MST[rv.UOI3Mutator]MSP[] while ( entry != null ) {
h ^= key2 . hashCode () ; } if ( key3 != null ) { h ^= key3 . hashCode () ; } if ( key4 != null ) { h ^= key4 . hashCode () ; } h += ~ ( h << 9 ) ; MST[rv.UOI1Mutator]MSP[]
final Object key1 , final Object key2 , final Object key3 , final Object key4 ) { final MultiKey < ? extends K > multi = entry . getKey () ; return multi . size () == 4 && MST[rv.CRCR6Mutator]MSP[]
if ( key2 != null ) { h ^= key2 . hashCode () ; MST[rv.UOI4Mutator]MSP[] } if ( key3 != null ) { h ^= key3 . hashCode () ; } if ( key4 != null ) { h ^= key4 . hashCode () ; }
if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 , key4 ) ) { MST[rv.ROR1Mutator]MSP[] final V oldValue = entry . getValue () ; decorated () . updateEntry ( entry , value ) ; return oldValue ; }
AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > previous = null ; while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 , key4 ) ) { MST[NegateConditionalsMutator]MSP[]
AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ decorated () . hashIndex ( hashCode , decorated () . data . length ) ] ; MST[NonVoidMethodCallMutator]MSP[] while ( entry != null ) {
h ^= key2 . hashCode () ; } if ( key3 != null ) { h ^= key3 . hashCode () ; } if ( key4 != null ) { h ^= key4 . hashCode () ; MST[MathMutator]MSP[] } h += ~ ( h << 9 ) ;
if ( key2 != null ) { h ^= key2 . hashCode () ; } if ( key3 != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] h ^= key3 . hashCode () ; } h += ~ ( h << 9 ) ; h ^= h >>> 14 ;
if ( key5 != null ) { h ^= key5 . hashCode () ; } h += ~ ( h << 9 ) ; MST[MathMutator]MSP[] h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; return h ; }
final int index = decorated () . hashIndex ( hashCode , decorated () . data . length ) ; AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ index ] ; while ( entry != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 , key4 ) ) { MST[rv.ROR4Mutator]MSP[] final V oldValue = entry . getValue () ; decorated () . updateEntry ( entry , value ) ; return oldValue ; }
multi . size () == 2 && ( key1 == multi . getKey ( 0 ) || key1 != null && key1 . equals ( multi . getKey ( 0 ) ) ) && MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
final int hashCode = hash ( key1 , key2 ) ; AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ decorated () . hashIndex ( hashCode , decorated () . data . length ) ] ; MST[NonVoidMethodCallMutator]MSP[]
if ( key5 != null ) { h ^= key5 . hashCode () ; } h += ~ ( h << 9 ) ; h ^= h >>> 14 ; MST[rv.UOI1Mutator]MSP[] h += h << 4 ; h ^= h >>> 10 ; return h ; }
AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ index ] ; MST[rv.UOI2Mutator]MSP[] while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 ) ) {
( key2 == null ? multi . getKey ( 1 ) == null : key2 . equals ( multi . getKey ( 1 ) ) ) && MST[rv.CRCR4Mutator]MSP[]
final int index = decorated () . hashIndex ( hashCode , decorated () . data . length ) ; MST[rv.UOI2Mutator]MSP[] AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ index ] ;
final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 2 && ( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) && MST[rv.ROR1Mutator]MSP[]
protected int hash ( final Object key1 , final Object key2 , final Object key3 , final Object key4 ) { int h = 0 ; MST[rv.CRCR1Mutator]MSP[] if ( key1 != null ) { h ^= key1 . hashCode () ; } if ( key2 != null ) {
AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ decorated () . hashIndex ( hashCode , decorated () . data . length ) ] ; MST[NonVoidMethodCallMutator]MSP[] while ( entry != null ) {
return true ; } entry = entry . next ; } return false ; MST[rv.CRCR6Mutator]MSP[] } public V put ( final K key1 , final K key2 , final K key3 , final K key4 , final V value ) {
( key2 == multi . getKey ( 1 ) || key2 != null && key2 . equals ( multi . getKey ( 1 ) ) ) ; MST[InlineConstantMutator]MSP[] } public V get ( final Object key1 , final Object key2 , final Object key3 ) {
if ( key5 != null ) { h ^= key5 . hashCode () ; } h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; MST[rv.ABSMutator]MSP[] return h ; }
while ( it . hasNext () ) { MST[NonVoidMethodCallMutator]MSP[] final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 4 &&
while ( it . hasNext () ) { final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 4 && MST[rv.ROR5Mutator]MSP[]
entry = entry . next ; } decorated () . addMapping ( index , hashCode , new MultiKey <> ( key1 , key2 , key3 , key4 ) , value ) ; MST[rv.UOI3Mutator]MSP[] return null ; }
h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; MST[MathMutator]MSP[] return h ; } protected boolean isEqualKey ( final AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry ,
public boolean removeAll ( final Object key1 , final Object key2 ) { boolean modified = false ; MST[InlineConstantMutator]MSP[] final MapIterator < MultiKey < ? extends K > , V > it = mapIterator () ; while ( it . hasNext () ) {
h += h << 4 ; MST[rv.ABSMutator]MSP[] h ^= h >>> 10 ; return h ; } protected boolean isEqualKey ( final AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry , final Object key1 , final Object key2 , final Object key3 ) {
h ^= h >>> 14 ; h += h << 4 ; MST[rv.UOI3Mutator]MSP[] h ^= h >>> 10 ; return h ; } protected boolean isEqualKey ( final AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry ,
if ( key2 != null ) { h ^= key2 . hashCode () ; } if ( key3 != null ) { h ^= key3 . hashCode () ; } h += ~ ( h << 9 ) ; MST[rv.CRCR4Mutator]MSP[] h ^= h >>> 14 ;
decorated () . addMapping ( index , hashCode , new MultiKey <> ( key1 , key2 ) , value ) ; MST[NonVoidMethodCallMutator]MSP[] return null ; } public V removeMultiKey ( final Object key1 , final Object key2 ) { final int hashCode = hash ( key1 , key2 ) ;
( key4 == null ? multi . getKey ( 3 ) == null : key4 . equals ( multi . getKey ( 3 ) ) ) ) { it . remove () ; modified = true ; } } return modified ; MST[rv.UOI4Mutator]MSP[] }
h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; MST[rv.ABSMutator]MSP[] h ^= h >>> 10 ; return h ; }
( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) ) { MST[rv.ROR5Mutator]MSP[] it . remove () ; modified = true ; } } return modified ; }
final MultiKey < ? extends K > multi = it . next () ; MST[NonVoidMethodCallMutator]MSP[] if ( multi . size () >= 2 && ( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) &&
h += h << 4 ; h ^= h >>> 10 ; MST[rv.UOI2Mutator]MSP[] return h ; } protected boolean isEqualKey ( final AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry , final Object key1 , final Object key2 , final Object key3 ) {
( key3 == multi . getKey ( 2 ) || key3 != null && key3 . equals ( multi . getKey ( 2 ) ) ) && MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 ) ) { return true ; } entry = entry . next ; } return false ; MST[rv.CRCR3Mutator]MSP[] }
final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 2 && MST[rv.ROR1Mutator]MSP[] ( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) &&
if ( key5 != null ) { h ^= key5 . hashCode () ; } h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; MST[rv.AOR3Mutator]MSP[] h ^= h >>> 10 ; return h ; }
checkKey ( key ) ; return super . put ( key , value ) ; MST[NonVoidMethodCallMutator]MSP[] } @Override public void putAll ( final Map < ? extends MultiKey < ? extends K > , ? extends V > mapToCopy ) {
final int index = decorated () . hashIndex ( hashCode , decorated () . data . length ) ; AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ index ] ; MST[rv.UOI2Mutator]MSP[] while ( entry != null ) {
if ( key5 != null ) { h ^= key5 . hashCode () ; } h += ~ ( h << 9 ) ; h ^= h >>> 14 ; MST[rv.UOI4Mutator]MSP[] h += h << 4 ; h ^= h >>> 10 ; return h ; }
if ( key5 != null ) { h ^= key5 . hashCode () ; } h += ~ ( h << 9 ) ; h ^= h >>> 14 ; MST[rv.ABSMutator]MSP[] h += h << 4 ; h ^= h >>> 10 ; return h ; }
h += ~ ( h << 9 ) ; h ^= h >>> 14 ; MST[InlineConstantMutator]MSP[] h += h << 4 ; h ^= h >>> 10 ; return h ; }
h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; return h ; MST[PrimitiveReturnsMutator]MSP[] }
final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 2 && MST[rv.CRCR2Mutator]MSP[] ( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) &&
decorated () . data [ decorated () . hashIndex ( hashCode , decorated () . data . length ) ] ; while ( entry != null ) { MST[rv.ROR5Mutator]MSP[] if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 ) ) {
( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) && MST[rv.CRCR3Mutator]MSP[]
h ^= key2 . hashCode () ; } if ( key3 != null ) { h ^= key3 . hashCode () ; } if ( key4 != null ) { h ^= key4 . hashCode () ; } h += ~ ( h << 9 ) ; MST[rv.CRCR5Mutator]MSP[]
AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ decorated () . hashIndex ( hashCode , decorated () . data . length ) ] ; MST[rv.UOI2Mutator]MSP[] while ( entry != null ) {
( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) && MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
if ( key2 != null ) { h ^= key2 . hashCode () ; } if ( key3 != null ) { h ^= key3 . hashCode () ; MST[rv.UOI1Mutator]MSP[] } if ( key4 != null ) { h ^= key4 . hashCode () ; }
( key2 == null ? multi . getKey ( 1 ) == null : key2 . equals ( multi . getKey ( 1 ) ) ) ) { MST[NonVoidMethodCallMutator]MSP[] it . remove () ; modified = true ; } } return modified ; }
if ( key5 != null ) { h ^= key5 . hashCode () ; } h += ~ ( h << 9 ) ; h ^= h >>> 14 ; MST[rv.CRCR6Mutator]MSP[] h += h << 4 ; h ^= h >>> 10 ; return h ; }
final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 3 && MST[InlineConstantMutator]MSP[] ( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) &&
if ( key5 != null ) { h ^= key5 . hashCode () ; } h += ~ ( h << 9 ) ; MST[rv.CRCR4Mutator]MSP[] h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; return h ; }
h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; MST[rv.UOI1Mutator]MSP[] return h ; } protected boolean isEqualKey ( final AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry ,
decorated () . addMapping ( index , hashCode , new MultiKey <> ( key1 , key2 , key3 ) , value ) ; MST[rv.UOI1Mutator]MSP[] return null ; } public V removeMultiKey ( final Object key1 , final Object key2 , final Object key3 ) {
final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 3 && ( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) && MST[rv.ROR3Mutator]MSP[]
public boolean removeAll ( final Object key1 , final Object key2 , final Object key3 , final Object key4 ) { boolean modified = false ; MST[rv.CRCR6Mutator]MSP[] final MapIterator < MultiKey < ? extends K > , V > it = mapIterator () ;
h += ~ ( h << 9 ) ; MST[rv.UOI3Mutator]MSP[] h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; return h ; }
( key2 == null ? multi . getKey ( 1 ) == null : key2 . equals ( multi . getKey ( 1 ) ) ) ) { it . remove () ; modified = true ; } } return modified ; MST[rv.UOI1Mutator]MSP[] }
AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ decorated () . hashIndex ( hashCode , decorated () . data . length ) ] ; MST[NonVoidMethodCallMutator]MSP[] while ( entry != null ) {
while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 ) ) { MST[rv.ROR4Mutator]MSP[] return true ; } entry = entry . next ; } return false ; }
AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > previous = null ; while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 , key4 ) ) { MST[rv.UOI4Mutator]MSP[]
if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 ) ) { MST[rv.ROR5Mutator]MSP[] final V oldValue = entry . getValue () ; decorated () . removeMapping ( entry , index , previous ) ; return oldValue ; } previous = entry ;
decorated () . data [ decorated () . hashIndex ( hashCode , decorated () . data . length ) ] ; MST[NonVoidMethodCallMutator]MSP[] while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 ) ) {
final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 2 && ( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) && MST[InlineConstantMutator]MSP[]
h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; MST[rv.CRCR4Mutator]MSP[] return h ; }
( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) ) { MST[NegateConditionalsMutator]MSP[] it . remove () ; modified = true ; } } return modified ; }
if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 ) ) { MST[rv.ROR4Mutator]MSP[] final V oldValue = entry . getValue () ; decorated () . removeMapping ( entry , index , previous ) ; return oldValue ; } previous = entry ;
h ^= key2 . hashCode () ; } if ( key3 != null ) { h ^= key3 . hashCode () ; MST[NonVoidMethodCallMutator]MSP[] } if ( key4 != null ) { h ^= key4 . hashCode () ; } h += ~ ( h << 9 ) ;
if ( key2 != null ) { h ^= key2 . hashCode () ; } if ( key3 != null ) { h ^= key3 . hashCode () ; } h += ~ ( h << 9 ) ; h ^= h >>> 14 ; MST[rv.UOI2Mutator]MSP[]
final int hashCode = hash ( key1 , key2 , key3 , key4 ) ; final int index = decorated () . hashIndex ( hashCode , decorated () . data . length ) ; MST[rv.ABSMutator]MSP[]
final MapIterator < MultiKey < ? extends K > , V > it = mapIterator () ; while ( it . hasNext () ) { MST[rv.ROR4Mutator]MSP[] final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 1 &&
( key2 == multi . getKey ( 1 ) || key2 != null && key2 . equals ( multi . getKey ( 1 ) ) ) ; MST[rv.CRCR1Mutator]MSP[] } public V get ( final Object key1 , final Object key2 , final Object key3 ) {
final int hashCode = hash ( key1 , key2 , key3 ) ; AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ decorated () . hashIndex ( hashCode , decorated () . data . length ) ] ; MST[rv.ABSMutator]MSP[]
final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 3 && MST[rv.ROR3Mutator]MSP[] ( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) &&
( key3 == null ? multi . getKey ( 2 ) == null : key3 . equals ( multi . getKey ( 2 ) ) ) ) { MST[NonVoidMethodCallMutator]MSP[] it . remove () ; modified = true ; } } return modified ; }
if ( key2 != null ) { h ^= key2 . hashCode () ; } if ( key3 != null ) { h ^= key3 . hashCode () ; } h += ~ ( h << 9 ) ; h ^= h >>> 14 ; MST[rv.CRCR3Mutator]MSP[]
while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 ) ) { MST[rv.ABSMutator]MSP[] return true ; } entry = entry . next ; } return false ; }
h ^= key2 . hashCode () ; MST[rv.UOI3Mutator]MSP[] } if ( key3 != null ) { h ^= key3 . hashCode () ; } if ( key4 != null ) { h ^= key4 . hashCode () ; } h += ~ ( h << 9 ) ;
if ( key2 != null ) { h ^= key2 . hashCode () ; MST[rv.UOI2Mutator]MSP[] } if ( key3 != null ) { h ^= key3 . hashCode () ; } h += ~ ( h << 9 ) ; h ^= h >>> 14 ;
if ( key5 != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] h ^= key5 . hashCode () ; } h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; return h ; }
( key2 == null ? multi . getKey ( 1 ) == null : key2 . equals ( multi . getKey ( 1 ) ) ) ) { MST[rv.CRCR2Mutator]MSP[] it . remove () ; modified = true ; } } return modified ; }
protected int hash ( final Object key1 , final Object key2 ) { int h = 0 ; if ( key1 != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] h ^= key1 . hashCode () ; } if ( key2 != null ) { h ^= key2 . hashCode () ; }
if ( key5 != null ) { h ^= key5 . hashCode () ; } h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; MST[rv.UOI2Mutator]MSP[] h ^= h >>> 10 ; return h ; }
h ^= key2 . hashCode () ; } if ( key3 != null ) { h ^= key3 . hashCode () ; } if ( key4 != null ) { h ^= key4 . hashCode () ; } h += ~ ( h << 9 ) ; MST[rv.AOR4Mutator]MSP[]
AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > previous = null ; while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 , key4 ) ) { MST[rv.ROR5Mutator]MSP[]
entry = entry . next ; } decorated () . addMapping ( index , hashCode , new MultiKey <> ( key1 , key2 , key3 , key4 , key5 ) , value ) ; MST[rv.UOI2Mutator]MSP[] return null ; }
h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; MST[rv.AOD2Mutator]MSP[] h ^= h >>> 10 ; return h ; }
( key3 == null ? multi . getKey ( 2 ) == null : key3 . equals ( multi . getKey ( 2 ) ) ) ) { MST[rv.CRCR3Mutator]MSP[] it . remove () ; modified = true ; } } return modified ; }
if ( key5 != null ) { h ^= key5 . hashCode () ; } h += ~ ( h << 9 ) ; MST[rv.UOI2Mutator]MSP[] h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; return h ; }
final int index = decorated () . hashIndex ( hashCode , decorated () . data . length ) ; MST[NonVoidMethodCallMutator]MSP[] AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ index ] ; while ( entry != null ) {
while ( it . hasNext () ) { final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 4 && MST[rv.CRCR2Mutator]MSP[]
public boolean removeAll ( final Object key1 , final Object key2 , final Object key3 ) { boolean modified = false ; final MapIterator < MultiKey < ? extends K > , V > it = mapIterator () ; while ( it . hasNext () ) { MST[rv.ROR5Mutator]MSP[]
AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ index ] ; MST[rv.UOI2Mutator]MSP[] while ( entry != null ) {
( key2 == multi . getKey ( 1 ) || key2 != null && key2 . equals ( multi . getKey ( 1 ) ) ) ; MST[rv.CRCR4Mutator]MSP[] } public V get ( final Object key1 , final Object key2 , final Object key3 ) {
if ( key2 != null ) { h ^= key2 . hashCode () ; } if ( key3 != null ) { h ^= key3 . hashCode () ; } h += ~ ( h << 9 ) ; MST[rv.UOI3Mutator]MSP[] h ^= h >>> 14 ;
final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 3 && ( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) && MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
decorated () . data [ decorated () . hashIndex ( hashCode , decorated () . data . length ) ] ; while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 , key4 ) ) { MST[rv.ROR1Mutator]MSP[]
multi . size () == 2 && MST[rv.ROR4Mutator]MSP[] ( key1 == multi . getKey ( 0 ) || key1 != null && key1 . equals ( multi . getKey ( 0 ) ) ) &&
h += h << 4 ; MST[rv.CRCR6Mutator]MSP[] h ^= h >>> 10 ; return h ; } protected boolean isEqualKey ( final AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry , final Object key1 , final Object key2 , final Object key3 ) {
public boolean removeAll ( final Object key1 , final Object key2 ) { boolean modified = false ; final MapIterator < MultiKey < ? extends K > , V > it = mapIterator () ; while ( it . hasNext () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
protected int hash ( final Object key1 , final Object key2 , final Object key3 , final Object key4 ) { int h = 0 ; if ( key1 != null ) { h ^= key1 . hashCode () ; } if ( key2 != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
while ( it . hasNext () ) { final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 4 && MST[NegateConditionalsMutator]MSP[]
( key3 == multi . getKey ( 2 ) || key3 != null && key3 . equals ( multi . getKey ( 2 ) ) ) && MST[NonVoidMethodCallMutator]MSP[]
if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] final V oldValue = entry . getValue () ; decorated () . removeMapping ( entry , index , previous ) ; return oldValue ; } previous = entry ;
final MultiKey < ? extends K > multi = entry . getKey () ; return multi . size () == 3 && MST[NonVoidMethodCallMutator]MSP[] ( key1 == multi . getKey ( 0 ) || key1 != null && key1 . equals ( multi . getKey ( 0 ) ) ) &&
public boolean removeAll ( final Object key1 , final Object key2 , final Object key3 ) { boolean modified = false ; MST[rv.CRCR5Mutator]MSP[] final MapIterator < MultiKey < ? extends K > , V > it = mapIterator () ; while ( it . hasNext () ) {
final int index = decorated () . hashIndex ( hashCode , decorated () . data . length ) ; AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ index ] ; MST[rv.UOI3Mutator]MSP[]
if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 , key4 , key5 ) ) { return true ; } entry = entry . next ; } return false ; MST[rv.CRCR6Mutator]MSP[] }
( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) ) { MST[rv.ROR2Mutator]MSP[] it . remove () ; modified = true ; } } return modified ; }
protected int hash ( final Object key1 , final Object key2 , final Object key3 , final Object key4 ) { int h = 0 ; if ( key1 != null ) { h ^= key1 . hashCode () ; MST[rv.ABSMutator]MSP[] } if ( key2 != null ) {
h += ~ ( h << 9 ) ; h ^= h >>> 14 ; MST[rv.UOI2Mutator]MSP[] h += h << 4 ; h ^= h >>> 10 ; return h ; }
h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; MST[rv.CRCR2Mutator]MSP[] return h ; } protected boolean isEqualKey ( final AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry ,
if ( key5 != null ) { h ^= key5 . hashCode () ; } h += ~ ( h << 9 ) ; MST[InlineConstantMutator]MSP[] h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; return h ; }
final MapIterator < MultiKey < ? extends K > , V > it = mapIterator () ; while ( it . hasNext () ) { final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 1 && MST[rv.ROR2Mutator]MSP[]
decorated () . data [ decorated () . hashIndex ( hashCode , decorated () . data . length ) ] ; MST[NonVoidMethodCallMutator]MSP[] while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 , key4 ) ) {
( key4 == multi . getKey ( 3 ) || key4 != null && key4 . equals ( multi . getKey ( 3 ) ) ) ; MST[rv.CRCR1Mutator]MSP[] }
if ( key2 != null ) { MST[NegateConditionalsMutator]MSP[] h ^= key2 . hashCode () ; } if ( key3 != null ) { h ^= key3 . hashCode () ; } if ( key4 != null ) { h ^= key4 . hashCode () ; }
( key2 == null ? multi . getKey ( 1 ) == null : key2 . equals ( multi . getKey ( 1 ) ) ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] it . remove () ; modified = true ; } } return modified ; }
entry = entry . next ; } decorated () . addMapping ( index , hashCode , new MultiKey <> ( key1 , key2 , key3 , key4 , key5 ) , value ) ; MST[ConstructorCallMutator]MSP[] return null ; }
h += h << 4 ; h ^= h >>> 10 ; MST[InlineConstantMutator]MSP[] return h ; } protected boolean isEqualKey ( final AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry , final Object key1 , final Object key2 , final Object key3 ) {
final MapIterator < MultiKey < ? extends K > , V > it = mapIterator () ; while ( it . hasNext () ) { final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 1 && MST[rv.CRCR6Mutator]MSP[]
h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; return h ; MST[rv.UOI4Mutator]MSP[] }
if ( key2 != null ) { h ^= key2 . hashCode () ; } if ( key3 != null ) { h ^= key3 . hashCode () ; } h += ~ ( h << 9 ) ; MST[rv.ABSMutator]MSP[] h ^= h >>> 14 ;
h += ~ ( h << 9 ) ; MST[rv.CRCR6Mutator]MSP[] h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; return h ; }
decorated () . data [ decorated () . hashIndex ( hashCode , decorated () . data . length ) ] ; MST[NonVoidMethodCallMutator]MSP[] while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 , key4 ) ) {
if ( key2 != null ) { h ^= key2 . hashCode () ; } if ( key3 != null ) { h ^= key3 . hashCode () ; } h += ~ ( h << 9 ) ; MST[rv.CRCR1Mutator]MSP[] h ^= h >>> 14 ;
decorated () . data [ decorated () . hashIndex ( hashCode , decorated () . data . length ) ] ; while ( entry != null ) { MST[rv.ROR5Mutator]MSP[] if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 , key4 ) ) {
entry = entry . next ; } return null ; } protected int hash ( final Object key1 , final Object key2 , final Object key3 ) { int h = 0 ; if ( key1 != null ) { MST[NegateConditionalsMutator]MSP[] h ^= key1 . hashCode () ; }
final int hashCode = hash ( key1 , key2 , key3 , key4 ) ; MST[NonVoidMethodCallMutator]MSP[] AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry =
final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 2 && ( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) && MST[rv.CRCR3Mutator]MSP[]
h += h << 4 ; h ^= h >>> 10 ; return h ; MST[ReturnValsMutator]MSP[] } protected boolean isEqualKey ( final AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry , final Object key1 , final Object key2 , final Object key3 ) {
( key1 == multi . getKey ( 0 ) || key1 != null && key1 . equals ( multi . getKey ( 0 ) ) ) && MST[NonVoidMethodCallMutator]MSP[]
( key2 == null ? multi . getKey ( 1 ) == null : key2 . equals ( multi . getKey ( 1 ) ) ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] it . remove () ; modified = true ; } } return modified ; }
( key2 == null ? multi . getKey ( 1 ) == null : key2 . equals ( multi . getKey ( 1 ) ) ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] it . remove () ; modified = true ; } } return modified ; }
( key1 == multi . getKey ( 0 ) || key1 != null && key1 . equals ( multi . getKey ( 0 ) ) ) && MST[rv.CRCR6Mutator]MSP[]
decorated () . data [ decorated () . hashIndex ( hashCode , decorated () . data . length ) ] ; while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 , key4 ) ) { MST[rv.UOI1Mutator]MSP[]
final MultiKey < ? extends K > multi = entry . getKey () ; return multi . size () == 3 && MST[rv.ROR3Mutator]MSP[] ( key1 == multi . getKey ( 0 ) || key1 != null && key1 . equals ( multi . getKey ( 0 ) ) ) &&
h ^= h >>> 14 ; MST[InlineConstantMutator]MSP[] h += h << 4 ; h ^= h >>> 10 ; return h ; } protected boolean isEqualKey ( final AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry ,
while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 ) ) { return true ; MST[rv.CRCR3Mutator]MSP[] } entry = entry . next ; } return false ; }
final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 3 && ( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) && MST[rv.CRCR6Mutator]MSP[]
AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > previous = null ; while ( entry != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 , key4 ) ) {
final int hashCode = hash ( key1 , key2 , key3 , key4 ) ; final int index = decorated () . hashIndex ( hashCode , decorated () . data . length ) ; MST[NonVoidMethodCallMutator]MSP[]
final MapIterator < MultiKey < ? extends K > , V > it = mapIterator () ; while ( it . hasNext () ) { final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 1 && MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 2 && ( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) && MST[rv.CRCR1Mutator]MSP[]
( key3 == multi . getKey ( 2 ) || key3 != null && key3 . equals ( multi . getKey ( 2 ) ) ) && MST[rv.CRCR6Mutator]MSP[]
( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) ) { MST[rv.CRCR1Mutator]MSP[] it . remove () ; modified = true ; } } return modified ; }
( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) && MST[InlineConstantMutator]MSP[]
while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 ) ) { MST[rv.ROR2Mutator]MSP[] return true ; } entry = entry . next ; } return false ; }
for ( final MultiKey < ? extends K > key : mapToCopy . keySet () ) { checkKey ( key ) ; MST[VoidMethodCallMutator]MSP[] } super . putAll ( mapToCopy ) ; } @Override public MapIterator < MultiKey < ? extends K > , V > mapIterator () {
if ( key5 != null ) { h ^= key5 . hashCode () ; } h += ~ ( h << 9 ) ; h ^= h >>> 14 ; MST[rv.CRCR3Mutator]MSP[] h += h << 4 ; h ^= h >>> 10 ; return h ; }
( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) && MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) ) { MST[rv.CRCR5Mutator]MSP[] it . remove () ; modified = true ; } } return modified ; }
if ( key5 != null ) { h ^= key5 . hashCode () ; } h += ~ ( h << 9 ) ; MST[rv.CRCR1Mutator]MSP[] h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; return h ; }
( key3 == null ? multi . getKey ( 2 ) == null : key3 . equals ( multi . getKey ( 2 ) ) ) ) { it . remove () ; modified = true ; } } return modified ; MST[rv.UOI4Mutator]MSP[] }
public boolean removeAll ( final Object key1 , final Object key2 ) { boolean modified = false ; final MapIterator < MultiKey < ? extends K > , V > it = mapIterator () ; while ( it . hasNext () ) { MST[rv.ROR3Mutator]MSP[]
if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 ) ) { MST[rv.UOI3Mutator]MSP[] final V oldValue = entry . getValue () ; decorated () . removeMapping ( entry , index , previous ) ; return oldValue ; } previous = entry ;
protected int hash ( final Object key1 , final Object key2 ) { int h = 0 ; if ( key1 != null ) { h ^= key1 . hashCode () ; } if ( key2 != null ) { h ^= key2 . hashCode () ; MST[NonVoidMethodCallMutator]MSP[] }
decorated () . data [ decorated () . hashIndex ( hashCode , decorated () . data . length ) ] ; MST[rv.ABSMutator]MSP[] while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 ) ) {
if ( key2 != null ) { h ^= key2 . hashCode () ; MST[rv.UOI1Mutator]MSP[] } if ( key3 != null ) { h ^= key3 . hashCode () ; } if ( key4 != null ) { h ^= key4 . hashCode () ; }
AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > previous = null ; while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 , key4 ) ) { MST[rv.UOI1Mutator]MSP[]
final Object key1 , final Object key2 , final Object key3 , final Object key4 ) { final MultiKey < ? extends K > multi = entry . getKey () ; return multi . size () == 4 && MST[rv.CRCR3Mutator]MSP[]
protected int hash ( final Object key1 , final Object key2 , final Object key3 , final Object key4 , final Object key5 ) { int h = 0 ; if ( key1 != null ) { h ^= key1 . hashCode () ; MST[MathMutator]MSP[] }
decorated () . addMapping ( index , hashCode , new MultiKey <> ( key1 , key2 ) , value ) ; MST[rv.UOI4Mutator]MSP[] return null ; } public V removeMultiKey ( final Object key1 , final Object key2 ) { final int hashCode = hash ( key1 , key2 ) ;
( key2 == null ? multi . getKey ( 1 ) == null : key2 . equals ( multi . getKey ( 1 ) ) ) && MST[NegateConditionalsMutator]MSP[]
h += h << 4 ; h ^= h >>> 10 ; MST[rv.UOI3Mutator]MSP[] return h ; } protected boolean isEqualKey ( final AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry , final Object key1 , final Object key2 , final Object key3 ) {
h ^= h >>> 14 ; MST[rv.ABSMutator]MSP[] h += h << 4 ; h ^= h >>> 10 ; return h ; } protected boolean isEqualKey ( final AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry ,
AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > previous = null ; while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 , key4 ) ) { MST[rv.ROR2Mutator]MSP[]
decorated () . data [ decorated () . hashIndex ( hashCode , decorated () . data . length ) ] ; while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 , key4 ) ) { MST[rv.ROR4Mutator]MSP[]
AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ decorated () . hashIndex ( hashCode , decorated () . data . length ) ] ; while ( entry != null ) { MST[rv.ROR5Mutator]MSP[]
h ^= h >>> 14 ; h += h << 4 ; MST[rv.CRCR4Mutator]MSP[] h ^= h >>> 10 ; return h ; } protected boolean isEqualKey ( final AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry ,
( key2 == null ? multi . getKey ( 1 ) == null : key2 . equals ( multi . getKey ( 1 ) ) ) && MST[rv.ROR5Mutator]MSP[]
protected int hash ( final Object key1 , final Object key2 , final Object key3 , final Object key4 ) { int h = 0 ; MST[InlineConstantMutator]MSP[] if ( key1 != null ) { h ^= key1 . hashCode () ; } if ( key2 != null ) {
entry = entry . next ; } decorated () . addMapping ( index , hashCode , new MultiKey <> ( key1 , key2 , key3 , key4 ) , value ) ; return null ; MST[ReturnValsMutator]MSP[] }
AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > previous = null ; while ( entry != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 ) ) {
if ( key2 != null ) { h ^= key2 . hashCode () ; } if ( key3 != null ) { h ^= key3 . hashCode () ; } h += ~ ( h << 9 ) ; MST[rv.AOD1Mutator]MSP[] h ^= h >>> 14 ;
final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 3 && MST[RemoveConditionalMutator_ORDER_IF]MSP[] ( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) &&
( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) ) { it . remove () ; modified = true ; MST[rv.CRCR3Mutator]MSP[] } } return modified ; }
( key2 == null ? multi . getKey ( 1 ) == null : key2 . equals ( multi . getKey ( 1 ) ) ) ) { MST[rv.CRCR5Mutator]MSP[] it . remove () ; modified = true ; } } return modified ; }
if ( key2 != null ) { h ^= key2 . hashCode () ; } if ( key3 != null ) { h ^= key3 . hashCode () ; } h += ~ ( h << 9 ) ; MST[rv.AOR3Mutator]MSP[] h ^= h >>> 14 ;
h += ~ ( h << 9 ) ; MST[rv.AOD1Mutator]MSP[] h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; return h ; }
h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; MST[rv.UOI3Mutator]MSP[] return h ; }
final int hashCode = hash ( key1 , key2 , key3 ) ; final int index = decorated () . hashIndex ( hashCode , decorated () . data . length ) ; MST[rv.UOI1Mutator]MSP[]
if ( key2 != null ) { h ^= key2 . hashCode () ; } if ( key3 != null ) { h ^= key3 . hashCode () ; } h += ~ ( h << 9 ) ; MST[rv.CRCR5Mutator]MSP[] h ^= h >>> 14 ;
( key3 == null ? multi . getKey ( 2 ) == null : key3 . equals ( multi . getKey ( 2 ) ) ) ) { it . remove () ; modified = true ; } } return modified ; MST[BooleanFalseReturnValsMutator]MSP[] }
if ( key2 != null ) { MST[rv.ROR5Mutator]MSP[] h ^= key2 . hashCode () ; } if ( key3 != null ) { h ^= key3 . hashCode () ; } if ( key4 != null ) { h ^= key4 . hashCode () ; }
final int index = decorated () . hashIndex ( hashCode , decorated () . data . length ) ; MST[rv.UOI3Mutator]MSP[] AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ index ] ; while ( entry != null ) {
multi . size () == 2 && MST[RemoveConditionalMutator_EQUAL_IF]MSP[] ( key1 == multi . getKey ( 0 ) || key1 != null && key1 . equals ( multi . getKey ( 0 ) ) ) &&
multi . size () == 2 && MST[rv.CRCR5Mutator]MSP[] ( key1 == multi . getKey ( 0 ) || key1 != null && key1 . equals ( multi . getKey ( 0 ) ) ) &&
if ( key2 != null ) { h ^= key2 . hashCode () ; MST[NonVoidMethodCallMutator]MSP[] } if ( key3 != null ) { h ^= key3 . hashCode () ; } if ( key4 != null ) { h ^= key4 . hashCode () ; }
if ( key5 != null ) { h ^= key5 . hashCode () ; } h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; MST[rv.UOI3Mutator]MSP[] return h ; }
if ( key2 != null ) { h ^= key2 . hashCode () ; } if ( key3 != null ) { h ^= key3 . hashCode () ; } if ( key4 != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] h ^= key4 . hashCode () ; }
h ^= key2 . hashCode () ; } if ( key3 != null ) { h ^= key3 . hashCode () ; } if ( key4 != null ) { h ^= key4 . hashCode () ; } h += ~ ( h << 9 ) ; MST[MathMutator]MSP[]
entry = entry . next ; } decorated () . addMapping ( index , hashCode , new MultiKey <> ( key1 , key2 , key3 , key4 , key5 ) , value ) ; MST[rv.ABSMutator]MSP[] return null ; }
final MultiKey < ? extends K > multi = entry . getKey () ; return multi . size () == 3 && MST[InlineConstantMutator]MSP[] ( key1 == multi . getKey ( 0 ) || key1 != null && key1 . equals ( multi . getKey ( 0 ) ) ) &&
AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ decorated () . hashIndex ( hashCode , decorated () . data . length ) ] ; while ( entry != null ) { MST[NegateConditionalsMutator]MSP[]
final Object key1 , final Object key2 , final Object key3 , final Object key4 ) { final MultiKey < ? extends K > multi = entry . getKey () ; return multi . size () == 4 && MST[rv.CRCR3Mutator]MSP[]
( key2 == null ? multi . getKey ( 1 ) == null : key2 . equals ( multi . getKey ( 1 ) ) ) && MST[NegateConditionalsMutator]MSP[]
decorated () . addMapping ( index , hashCode , new MultiKey <> ( key1 , key2 , key3 ) , value ) ; MST[rv.UOI2Mutator]MSP[] return null ; } public V removeMultiKey ( final Object key1 , final Object key2 , final Object key3 ) {
public boolean removeAll ( final Object key1 , final Object key2 ) { boolean modified = false ; MST[rv.CRCR3Mutator]MSP[] final MapIterator < MultiKey < ? extends K > , V > it = mapIterator () ; while ( it . hasNext () ) {
h += h << 4 ; h ^= h >>> 10 ; MST[rv.CRCR4Mutator]MSP[] return h ; } protected boolean isEqualKey ( final AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry , final Object key1 , final Object key2 , final Object key3 ) {
final int index = decorated () . hashIndex ( hashCode , decorated () . data . length ) ; MST[rv.UOI3Mutator]MSP[] AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ index ] ;
final int index = decorated () . hashIndex ( hashCode , decorated () . data . length ) ; MST[rv.ABSMutator]MSP[] AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ index ] ;
h ^= key2 . hashCode () ; } if ( key3 != null ) { h ^= key3 . hashCode () ; } if ( key4 != null ) { h ^= key4 . hashCode () ; } h += ~ ( h << 9 ) ; MST[rv.CRCR1Mutator]MSP[]
h += ~ ( h << 9 ) ; MST[rv.CRCR1Mutator]MSP[] h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; return h ; }
final MapIterator < MultiKey < ? extends K > , V > it = mapIterator () ; while ( it . hasNext () ) { final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 1 && MST[rv.CRCR6Mutator]MSP[]
final int hashCode = hash ( key1 , key2 , key3 , key4 ) ; final int index = decorated () . hashIndex ( hashCode , decorated () . data . length ) ; MST[rv.UOI2Mutator]MSP[]
final int hashCode = hash ( key1 , key2 , key3 ) ; AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ decorated () . hashIndex ( hashCode , decorated () . data . length ) ] ; MST[NonVoidMethodCallMutator]MSP[]
h ^= h >>> 14 ; h += h << 4 ; MST[rv.UOI4Mutator]MSP[] h ^= h >>> 10 ; return h ; } protected boolean isEqualKey ( final AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry ,
protected int hash ( final Object key1 , final Object key2 , final Object key3 , final Object key4 ) { int h = 0 ; if ( key1 != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] h ^= key1 . hashCode () ; } if ( key2 != null ) {
while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 ) ) { return true ; } entry = entry . next ; } return false ; MST[InlineConstantMutator]MSP[] }
entry = entry . next ; } decorated () . addMapping ( index , hashCode , new MultiKey <> ( key1 , key2 , key3 , key4 , key5 ) , value ) ; MST[VoidMethodCallMutator]MSP[] return null ; }
final int index = decorated () . hashIndex ( hashCode , decorated () . data . length ) ; AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ index ] ; while ( entry != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 3 && ( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) && MST[NonVoidMethodCallMutator]MSP[]
public V put ( final K key1 , final K key2 , final V value ) { final int hashCode = hash ( key1 , key2 ) ; final int index = decorated () . hashIndex ( hashCode , decorated () . data . length ) ; MST[rv.UOI1Mutator]MSP[]
public boolean removeAll ( final Object key1 , final Object key2 ) { boolean modified = false ; final MapIterator < MultiKey < ? extends K > , V > it = mapIterator () ; while ( it . hasNext () ) { MST[NonVoidMethodCallMutator]MSP[]
protected int hash ( final Object key1 , final Object key2 ) { int h = 0 ; MST[rv.CRCR5Mutator]MSP[] if ( key1 != null ) { h ^= key1 . hashCode () ; } if ( key2 != null ) { h ^= key2 . hashCode () ; }
while ( entry != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 ) ) { return true ; } entry = entry . next ; } return false ; }
h ^= key2 . hashCode () ; } if ( key3 != null ) { h ^= key3 . hashCode () ; } if ( key4 != null ) { h ^= key4 . hashCode () ; } h += ~ ( h << 9 ) ; MST[rv.UOI4Mutator]MSP[]
final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 2 && MST[rv.CRCR5Mutator]MSP[] ( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) &&
if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 , key4 ) ) { MST[rv.UOI4Mutator]MSP[] final V oldValue = entry . getValue () ; decorated () . updateEntry ( entry , value ) ; return oldValue ; }
if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 , key4 ) ) { MST[NegateConditionalsMutator]MSP[] final V oldValue = entry . getValue () ; decorated () . updateEntry ( entry , value ) ; return oldValue ; }
h ^= h >>> 14 ; h += h << 4 ; MST[rv.AOR2Mutator]MSP[] h ^= h >>> 10 ; return h ; } protected boolean isEqualKey ( final AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry ,
( key1 == multi . getKey ( 0 ) || key1 != null && key1 . equals ( multi . getKey ( 0 ) ) ) && MST[rv.ROR3Mutator]MSP[]
( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) ) { it . remove () ; modified = true ; } } return modified ; MST[ReturnValsMutator]MSP[] }
h ^= key2 . hashCode () ; } if ( key3 != null ) { h ^= key3 . hashCode () ; } if ( key4 != null ) { h ^= key4 . hashCode () ; MST[rv.UOI1Mutator]MSP[] } h += ~ ( h << 9 ) ;
( key4 == multi . getKey ( 3 ) || key4 != null && key4 . equals ( multi . getKey ( 3 ) ) ) ; MST[rv.CRCR5Mutator]MSP[] }
final int hashCode = hash ( key1 , key2 , key3 ) ; final int index = decorated () . hashIndex ( hashCode , decorated () . data . length ) ; MST[rv.UOI4Mutator]MSP[]
if ( key5 != null ) { h ^= key5 . hashCode () ; } h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; MST[rv.AOD1Mutator]MSP[] h ^= h >>> 10 ; return h ; }
entry = entry . next ; } return null ; } protected int hash ( final Object key1 , final Object key2 , final Object key3 ) { int h = 0 ; MST[rv.CRCR6Mutator]MSP[] if ( key1 != null ) { h ^= key1 . hashCode () ; }
h += ~ ( h << 9 ) ; h ^= h >>> 14 ; MST[rv.ABSMutator]MSP[] h += h << 4 ; h ^= h >>> 10 ; return h ; }
h += h << 4 ; h ^= h >>> 10 ; MST[rv.ABSMutator]MSP[] return h ; } protected boolean isEqualKey ( final AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry , final Object key1 , final Object key2 , final Object key3 ) {
decorated () . data [ decorated () . hashIndex ( hashCode , decorated () . data . length ) ] ; MST[rv.UOI3Mutator]MSP[] while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 ) ) {
( key2 == multi . getKey ( 1 ) || key2 != null && key2 . equals ( multi . getKey ( 1 ) ) ) && MST[rv.CRCR3Mutator]MSP[]
AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ decorated () . hashIndex ( hashCode , decorated () . data . length ) ] ; MST[NonVoidMethodCallMutator]MSP[] while ( entry != null ) {
( key3 == multi . getKey ( 2 ) || key3 != null && key3 . equals ( multi . getKey ( 2 ) ) ) ; MST[rv.CRCR3Mutator]MSP[] } public V get ( final Object key1 , final Object key2 , final Object key3 , final Object key4 ) {
if ( key5 != null ) { h ^= key5 . hashCode () ; } h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; MST[rv.ABSMutator]MSP[] h ^= h >>> 10 ; return h ; }
final MultiKey < ? extends K > multi = entry . getKey () ; return multi . size () == 3 && MST[rv.CRCR1Mutator]MSP[] ( key1 == multi . getKey ( 0 ) || key1 != null && key1 . equals ( multi . getKey ( 0 ) ) ) &&
h ^= h >>> 14 ; MST[rv.UOI3Mutator]MSP[] h += h << 4 ; h ^= h >>> 10 ; return h ; } protected boolean isEqualKey ( final AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry ,
final int index = decorated () . hashIndex ( hashCode , decorated () . data . length ) ; AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ index ] ; MST[rv.ABSMutator]MSP[] while ( entry != null ) {
h += h << 4 ; MST[rv.UOI2Mutator]MSP[] h ^= h >>> 10 ; return h ; } protected boolean isEqualKey ( final AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry , final Object key1 , final Object key2 , final Object key3 ) {
final int index = decorated () . hashIndex ( hashCode , decorated () . data . length ) ; MST[rv.UOI1Mutator]MSP[] AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ index ] ; while ( entry != null ) {
decorated () . addMapping ( index , hashCode , new MultiKey <> ( key1 , key2 , key3 ) , value ) ; MST[NonVoidMethodCallMutator]MSP[] return null ; } public V removeMultiKey ( final Object key1 , final Object key2 , final Object key3 ) {
final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 2 && ( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) && MST[rv.CRCR6Mutator]MSP[]
multi . size () == 2 && ( key1 == multi . getKey ( 0 ) || key1 != null && key1 . equals ( multi . getKey ( 0 ) ) ) && MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
final MapIterator < MultiKey < ? extends K > , V > it = mapIterator () ; while ( it . hasNext () ) { final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 1 && MST[rv.ROR5Mutator]MSP[]
final int index = decorated () . hashIndex ( hashCode , decorated () . data . length ) ; MST[rv.ABSMutator]MSP[] AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ index ] ;
if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 , key4 ) ) { MST[rv.ROR1Mutator]MSP[] final V oldValue = entry . getValue () ; decorated () . updateEntry ( entry , value ) ; return oldValue ; }
( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) && MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
decorated () . data [ decorated () . hashIndex ( hashCode , decorated () . data . length ) ] ; MST[NonVoidMethodCallMutator]MSP[] while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 , key4 ) ) {
if ( key5 != null ) { h ^= key5 . hashCode () ; } h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; MST[rv.CRCR4Mutator]MSP[] return h ; }
h += ~ ( h << 9 ) ; MST[InlineConstantMutator]MSP[] h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; return h ; }
if ( key5 != null ) { h ^= key5 . hashCode () ; } h += ~ ( h << 9 ) ; MST[rv.UOI3Mutator]MSP[] h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; return h ; }
h ^= h >>> 14 ; h += h << 4 ; MST[rv.UOI1Mutator]MSP[] h ^= h >>> 10 ; return h ; } protected boolean isEqualKey ( final AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry ,
final int hashCode = hash ( key1 , key2 , key3 ) ; AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ decorated () . hashIndex ( hashCode , decorated () . data . length ) ] ; MST[rv.UOI2Mutator]MSP[]
( key3 == multi . getKey ( 2 ) || key3 != null && key3 . equals ( multi . getKey ( 2 ) ) ) && MST[rv.ROR3Mutator]MSP[]
if ( key2 != null ) { h ^= key2 . hashCode () ; } if ( key3 != null ) { h ^= key3 . hashCode () ; } if ( key4 != null ) { h ^= key4 . hashCode () ; MST[rv.UOI2Mutator]MSP[] }
decorated () . data [ decorated () . hashIndex ( hashCode , decorated () . data . length ) ] ; MST[rv.UOI3Mutator]MSP[] while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 , key4 ) ) {
( key2 == null ? multi . getKey ( 1 ) == null : key2 . equals ( multi . getKey ( 1 ) ) ) ) { MST[NonVoidMethodCallMutator]MSP[] it . remove () ; modified = true ; } } return modified ; }
if ( key5 != null ) { h ^= key5 . hashCode () ; } h += ~ ( h << 9 ) ; MST[rv.CRCR6Mutator]MSP[] h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; return h ; }
final int hashCode = hash ( key1 , key2 ) ; AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ decorated () . hashIndex ( hashCode , decorated () . data . length ) ] ; MST[ArgumentPropagationMutator]MSP[]
final int index = decorated () . hashIndex ( hashCode , decorated () . data . length ) ; MST[rv.ABSMutator]MSP[] AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ index ] ; while ( entry != null ) {
entry = entry . next ; } decorated () . addMapping ( index , hashCode , new MultiKey <> ( key1 , key2 , key3 , key4 , key5 ) , value ) ; MST[rv.UOI1Mutator]MSP[] return null ; }
h += ~ ( h << 9 ) ; MST[rv.AOR3Mutator]MSP[] h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; return h ; }
protected int hash ( final Object key1 , final Object key2 ) { int h = 0 ; if ( key1 != null ) { h ^= key1 . hashCode () ; } if ( key2 != null ) { h ^= key2 . hashCode () ; MST[rv.UOI3Mutator]MSP[] }
decorated () . addMapping ( index , hashCode , new MultiKey <> ( key1 , key2 ) , value ) ; MST[rv.UOI1Mutator]MSP[] return null ; } public V removeMultiKey ( final Object key1 , final Object key2 ) { final int hashCode = hash ( key1 , key2 ) ;
if ( key2 != null ) { h ^= key2 . hashCode () ; } if ( key3 != null ) { h ^= key3 . hashCode () ; } h += ~ ( h << 9 ) ; MST[InlineConstantMutator]MSP[] h ^= h >>> 14 ;
( key2 == null ? multi . getKey ( 1 ) == null : key2 . equals ( multi . getKey ( 1 ) ) ) ) { it . remove () ; modified = true ; MST[rv.CRCR3Mutator]MSP[] } } return modified ; }
final int index = decorated () . hashIndex ( hashCode , decorated () . data . length ) ; AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ index ] ; while ( entry != null ) { MST[NegateConditionalsMutator]MSP[]
( key2 == null ? multi . getKey ( 1 ) == null : key2 . equals ( multi . getKey ( 1 ) ) ) && MST[rv.ROR1Mutator]MSP[]
h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; MST[rv.CRCR4Mutator]MSP[] h ^= h >>> 10 ; return h ; }
final MapIterator < MultiKey < ? extends K > , V > it = mapIterator () ; while ( it . hasNext () ) { final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 1 && MST[NegateConditionalsMutator]MSP[]
( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) ) { it . remove () ; modified = true ; } } return modified ; MST[BooleanTrueReturnValsMutator]MSP[] }
( key1 == multi . getKey ( 0 ) || key1 != null && key1 . equals ( multi . getKey ( 0 ) ) ) && MST[rv.CRCR3Mutator]MSP[]
( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) && MST[rv.CRCR3Mutator]MSP[]
final Object key1 , final Object key2 , final Object key3 , final Object key4 ) { final MultiKey < ? extends K > multi = entry . getKey () ; return MST[ReturnValsMutator]MSP[] multi . size () == 4 &&
( key4 == multi . getKey ( 3 ) || key4 != null && key4 . equals ( multi . getKey ( 3 ) ) ) ; MST[InlineConstantMutator]MSP[] }
AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ index ] ; while ( entry != null ) { MST[rv.ROR5Mutator]MSP[] if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 ) ) {
while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 ) ) { return entry . getValue () ; } entry = entry . next ; } return null ; MST[ReturnValsMutator]MSP[] }
( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) ) { it . remove () ; modified = true ; MST[rv.CRCR6Mutator]MSP[] } } return modified ; }
if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 , key4 ) ) { final V oldValue = entry . getValue () ; MST[NonVoidMethodCallMutator]MSP[] decorated () . updateEntry ( entry , value ) ; return oldValue ; }
( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) ) { MST[NonVoidMethodCallMutator]MSP[] it . remove () ; modified = true ; } } return modified ; }
protected int hash ( final Object key1 , final Object key2 ) { int h = 0 ; if ( key1 != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] h ^= key1 . hashCode () ; } if ( key2 != null ) { h ^= key2 . hashCode () ; }
while ( it . hasNext () ) { final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 4 && MST[rv.CRCR5Mutator]MSP[]
protected int hash ( final Object key1 , final Object key2 , final Object key3 , final Object key4 , final Object key5 ) { int h = 0 ; MST[rv.CRCR6Mutator]MSP[] if ( key1 != null ) { h ^= key1 . hashCode () ; }
h ^= key2 . hashCode () ; } if ( key3 != null ) { h ^= key3 . hashCode () ; } if ( key4 != null ) { h ^= key4 . hashCode () ; MST[NonVoidMethodCallMutator]MSP[] } h += ~ ( h << 9 ) ;
while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 ) ) { MST[rv.UOI1Mutator]MSP[] return true ; } entry = entry . next ; } return false ; }
AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ index ] ; AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > previous = null ; while ( entry != null ) { MST[NegateConditionalsMutator]MSP[]
if ( key2 != null ) { h ^= key2 . hashCode () ; } if ( key3 != null ) { h ^= key3 . hashCode () ; MST[rv.ABSMutator]MSP[] } if ( key4 != null ) { h ^= key4 . hashCode () ; }
( key3 == null ? multi . getKey ( 2 ) == null : key3 . equals ( multi . getKey ( 2 ) ) ) ) { MST[rv.CRCR6Mutator]MSP[] it . remove () ; modified = true ; } } return modified ; }
h += ~ ( h << 9 ) ; MST[MathMutator]MSP[] h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; return h ; }
if ( key5 != null ) { h ^= key5 . hashCode () ; } h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; return h ; MST[ReturnValsMutator]MSP[] }
if ( key2 != null ) { h ^= key2 . hashCode () ; } if ( key3 != null ) { h ^= key3 . hashCode () ; MST[rv.ABSMutator]MSP[] } h += ~ ( h << 9 ) ; h ^= h >>> 14 ;
final int hashCode = hash ( key1 , key2 ) ; AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ decorated () . hashIndex ( hashCode , decorated () . data . length ) ] ; MST[rv.UOI1Mutator]MSP[]
final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 2 && ( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) && MST[InlineConstantMutator]MSP[]
( key2 == null ? multi . getKey ( 1 ) == null : key2 . equals ( multi . getKey ( 1 ) ) ) && MST[NonVoidMethodCallMutator]MSP[]
decorated () . data [ decorated () . hashIndex ( hashCode , decorated () . data . length ) ] ; MST[rv.ABSMutator]MSP[] while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 , key4 ) ) {
public boolean removeAll ( final Object key1 , final Object key2 ) { boolean modified = false ; MST[rv.CRCR1Mutator]MSP[] final MapIterator < MultiKey < ? extends K > , V > it = mapIterator () ; while ( it . hasNext () ) {
if ( key2 != null ) { h ^= key2 . hashCode () ; } if ( key3 != null ) { h ^= key3 . hashCode () ; MST[rv.UOI3Mutator]MSP[] } h += ~ ( h << 9 ) ; h ^= h >>> 14 ;
final MapIterator < MultiKey < ? extends K > , V > it = mapIterator () ; while ( it . hasNext () ) { final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 1 && MST[InlineConstantMutator]MSP[]
h ^= key2 . hashCode () ; } if ( key3 != null ) { h ^= key3 . hashCode () ; MST[rv.UOI4Mutator]MSP[] } if ( key4 != null ) { h ^= key4 . hashCode () ; } h += ~ ( h << 9 ) ;
h += h << 4 ; h ^= h >>> 10 ; MST[rv.CRCR6Mutator]MSP[] return h ; } protected boolean isEqualKey ( final AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry , final Object key1 , final Object key2 , final Object key3 ) {
( key4 == multi . getKey ( 3 ) || key4 != null && key4 . equals ( multi . getKey ( 3 ) ) ) ; MST[NonVoidMethodCallMutator]MSP[] }
( key3 == null ? multi . getKey ( 2 ) == null : key3 . equals ( multi . getKey ( 2 ) ) ) ) { it . remove () ; modified = true ; } } return modified ; MST[rv.UOI1Mutator]MSP[] }
final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 2 && MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] ( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) &&
h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; MST[rv.UOI2Mutator]MSP[] h ^= h >>> 10 ; return h ; }
final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 2 && ( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) && MST[rv.CRCR3Mutator]MSP[]
public boolean removeAll ( final Object key1 , final Object key2 , final Object key3 , final Object key4 ) { boolean modified = false ; MST[rv.CRCR3Mutator]MSP[] final MapIterator < MultiKey < ? extends K > , V > it = mapIterator () ;
( key2 == multi . getKey ( 1 ) || key2 != null && key2 . equals ( multi . getKey ( 1 ) ) ) ; MST[NegateConditionalsMutator]MSP[] } public V get ( final Object key1 , final Object key2 , final Object key3 ) {
( key3 == multi . getKey ( 2 ) || key3 != null && key3 . equals ( multi . getKey ( 2 ) ) ) && MST[NonVoidMethodCallMutator]MSP[]
final Object key1 , final Object key2 , final Object key3 , final Object key4 ) { final MultiKey < ? extends K > multi = entry . getKey () ; return multi . size () == 4 && MST[rv.CRCR6Mutator]MSP[]
if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 , key4 , key5 ) ) { return true ; } entry = entry . next ; } return false ; MST[rv.CRCR3Mutator]MSP[] }
( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) ) { MST[rv.ROR5Mutator]MSP[] it . remove () ; modified = true ; } } return modified ; }
( key3 == multi . getKey ( 2 ) || key3 != null && key3 . equals ( multi . getKey ( 2 ) ) ) && MST[rv.CRCR3Mutator]MSP[]
public boolean removeAll ( final Object key1 , final Object key2 ) { boolean modified = false ; final MapIterator < MultiKey < ? extends K > , V > it = mapIterator () ; while ( it . hasNext () ) { MST[rv.ROR1Mutator]MSP[]
AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ index ] ; MST[rv.ABSMutator]MSP[] AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > previous = null ; while ( entry != null ) {
decorated () . data [ decorated () . hashIndex ( hashCode , decorated () . data . length ) ] ; while ( entry != null ) { MST[NegateConditionalsMutator]MSP[] if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 , key4 ) ) {
if ( key2 != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] h ^= key2 . hashCode () ; } if ( key3 != null ) { h ^= key3 . hashCode () ; } h += ~ ( h << 9 ) ; h ^= h >>> 14 ;
final int index = decorated () . hashIndex ( hashCode , decorated () . data . length ) ; MST[rv.ABSMutator]MSP[] AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ index ] ;
if ( key5 != null ) { h ^= key5 . hashCode () ; } h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; MST[rv.UOI2Mutator]MSP[] return h ; }
multi . size () == 2 && ( key1 == multi . getKey ( 0 ) || key1 != null && key1 . equals ( multi . getKey ( 0 ) ) ) && MST[rv.CRCR2Mutator]MSP[]
final int index = decorated () . hashIndex ( hashCode , decorated () . data . length ) ; AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ index ] ; MST[rv.UOI2Mutator]MSP[]
public boolean removeAll ( final Object key1 , final Object key2 , final Object key3 , final Object key4 ) { boolean modified = false ; MST[InlineConstantMutator]MSP[] final MapIterator < MultiKey < ? extends K > , V > it = mapIterator () ;
final MapIterator < MultiKey < ? extends K > , V > it = mapIterator () ; while ( it . hasNext () ) { final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 1 && MST[RemoveConditionalMutator_ORDER_ELSE]MSP[]
h ^= key2 . hashCode () ; } if ( key3 != null ) { h ^= key3 . hashCode () ; } if ( key4 != null ) { h ^= key4 . hashCode () ; } h += ~ ( h << 9 ) ; MST[rv.AOR1Mutator]MSP[]
final Object key1 , final Object key2 , final Object key3 , final Object key4 ) { final MultiKey < ? extends K > multi = entry . getKey () ; return MST[BooleanTrueReturnValsMutator]MSP[] multi . size () == 4 &&
( key5 == multi . getKey ( 4 ) || key5 != null && key5 . equals ( multi . getKey ( 4 ) ) ) ; } public boolean removeAll ( final Object key1 ) { boolean modified = false ; MST[rv.CRCR1Mutator]MSP[]
final int index = decorated () . hashIndex ( hashCode , decorated () . data . length ) ; AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ index ] ; MST[rv.UOI2Mutator]MSP[]
public V put ( final K key1 , final K key2 , final V value ) { final int hashCode = hash ( key1 , key2 ) ; final int index = decorated () . hashIndex ( hashCode , decorated () . data . length ) ; MST[ArgumentPropagationMutator]MSP[]
if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 , key4 ) ) { MST[rv.UOI3Mutator]MSP[] final V oldValue = entry . getValue () ; decorated () . updateEntry ( entry , value ) ; return oldValue ; }
h ^= h >>> 14 ; h += h << 4 ; MST[rv.CRCR2Mutator]MSP[] h ^= h >>> 10 ; return h ; } protected boolean isEqualKey ( final AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry ,
if ( key5 != null ) { h ^= key5 . hashCode () ; } h += ~ ( h << 9 ) ; h ^= h >>> 14 ; MST[rv.UOI2Mutator]MSP[] h += h << 4 ; h ^= h >>> 10 ; return h ; }
while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 ) ) { return true ; MST[rv.CRCR6Mutator]MSP[] } entry = entry . next ; } return false ; }
return true ; } entry = entry . next ; } return false ; MST[rv.CRCR1Mutator]MSP[] } public V put ( final K key1 , final K key2 , final K key3 , final V value ) { final int hashCode = hash ( key1 , key2 , key3 ) ;
( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) ) { it . remove () ; modified = true ; } } return modified ; MST[rv.UOI3Mutator]MSP[] }
public boolean removeAll ( final Object key1 , final Object key2 , final Object key3 ) { boolean modified = false ; final MapIterator < MultiKey < ? extends K > , V > it = mapIterator () ; while ( it . hasNext () ) { MST[rv.ROR2Mutator]MSP[]
multi . size () == 2 && ( key1 == multi . getKey ( 0 ) || key1 != null && key1 . equals ( multi . getKey ( 0 ) ) ) && MST[NegateConditionalsMutator]MSP[]
return true ; } entry = entry . next ; } return false ; MST[rv.CRCR6Mutator]MSP[] } public V put ( final K key1 , final K key2 , final K key3 , final V value ) { final int hashCode = hash ( key1 , key2 , key3 ) ;
h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; MST[rv.UOI4Mutator]MSP[] return h ; } protected boolean isEqualKey ( final AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry ,
( key2 == null ? multi . getKey ( 1 ) == null : key2 . equals ( multi . getKey ( 1 ) ) ) ) { MST[rv.ROR5Mutator]MSP[] it . remove () ; modified = true ; } } return modified ; }
if ( key2 != null ) { h ^= key2 . hashCode () ; } if ( key3 != null ) { h ^= key3 . hashCode () ; } h += ~ ( h << 9 ) ; MST[rv.CRCR3Mutator]MSP[] h ^= h >>> 14 ;
h ^= h >>> 14 ; h += h << 4 ; MST[InlineConstantMutator]MSP[] h ^= h >>> 10 ; return h ; } protected boolean isEqualKey ( final AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry ,
( key4 == null ? multi . getKey ( 3 ) == null : key4 . equals ( multi . getKey ( 3 ) ) ) ) { it . remove () ; modified = true ; } } return modified ; MST[rv.UOI3Mutator]MSP[] }
final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 2 && MST[NegateConditionalsMutator]MSP[] ( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) &&
entry = entry . next ; } return null ; } protected int hash ( final Object key1 , final Object key2 , final Object key3 ) { int h = 0 ; if ( key1 != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] h ^= key1 . hashCode () ; }
( key4 == multi . getKey ( 3 ) || key4 != null && key4 . equals ( multi . getKey ( 3 ) ) ) ; MST[rv.CRCR2Mutator]MSP[] }
h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; MST[rv.CRCR3Mutator]MSP[] h ^= h >>> 10 ; return h ; }
decorated () . addMapping ( index , hashCode , new MultiKey <> ( key1 , key2 ) , value ) ; MST[ConstructorCallMutator]MSP[] return null ; } public V removeMultiKey ( final Object key1 , final Object key2 ) { final int hashCode = hash ( key1 , key2 ) ;
protected int hash ( final Object key1 , final Object key2 ) { int h = 0 ; if ( key1 != null ) { h ^= key1 . hashCode () ; } if ( key2 != null ) { h ^= key2 . hashCode () ; MST[rv.UOI4Mutator]MSP[] }
( key2 == null ? multi . getKey ( 1 ) == null : key2 . equals ( multi . getKey ( 1 ) ) ) && MST[rv.CRCR5Mutator]MSP[]
final MultiKey < ? extends K > multi = entry . getKey () ; return multi . size () == 3 && MST[rv.ROR5Mutator]MSP[] ( key1 == multi . getKey ( 0 ) || key1 != null && key1 . equals ( multi . getKey ( 0 ) ) ) &&
return true ; } entry = entry . next ; } return false ; MST[InlineConstantMutator]MSP[] } public V put ( final K key1 , final K key2 , final K key3 , final K key4 , final V value ) {
while ( entry != null ) { MST[rv.ROR5Mutator]MSP[] if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 ) ) { return entry . getValue () ; } entry = entry . next ; } return null ; }
h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; MST[MathMutator]MSP[] h ^= h >>> 10 ; return h ; }
if ( key2 != null ) { h ^= key2 . hashCode () ; } if ( key3 != null ) { h ^= key3 . hashCode () ; MST[rv.UOI2Mutator]MSP[] } if ( key4 != null ) { h ^= key4 . hashCode () ; }
h ^= h >>> 14 ; h += h << 4 ; MST[rv.ABSMutator]MSP[] h ^= h >>> 10 ; return h ; } protected boolean isEqualKey ( final AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry ,
public boolean removeAll ( final Object key1 , final Object key2 , final Object key3 ) { boolean modified = false ; MST[rv.CRCR3Mutator]MSP[] final MapIterator < MultiKey < ? extends K > , V > it = mapIterator () ; while ( it . hasNext () ) {
if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 , key4 , key5 ) ) { return true ; } entry = entry . next ; } return false ; MST[ReturnValsMutator]MSP[] }
( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) && MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
if ( key2 != null ) { h ^= key2 . hashCode () ; } if ( key3 != null ) { h ^= key3 . hashCode () ; } h += ~ ( h << 9 ) ; MST[MathMutator]MSP[] h ^= h >>> 14 ;
AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ decorated () . hashIndex ( hashCode , decorated () . data . length ) ] ; MST[rv.UOI2Mutator]MSP[] while ( entry != null ) {
decorated () . data [ decorated () . hashIndex ( hashCode , decorated () . data . length ) ] ; while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 , key4 ) ) { MST[NegateConditionalsMutator]MSP[]
h += h << 4 ; MST[rv.UOI3Mutator]MSP[] h ^= h >>> 10 ; return h ; } protected boolean isEqualKey ( final AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry , final Object key1 , final Object key2 , final Object key3 ) {
( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) ) { MST[rv.ROR4Mutator]MSP[] it . remove () ; modified = true ; } } return modified ; }
final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 2 && MST[rv.ROR5Mutator]MSP[] ( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) &&
decorated () . addMapping ( index , hashCode , new MultiKey <> ( key1 , key2 ) , value ) ; MST[rv.ABSMutator]MSP[] return null ; } public V removeMultiKey ( final Object key1 , final Object key2 ) { final int hashCode = hash ( key1 , key2 ) ;
if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 , key4 ) ) { final V oldValue = entry . getValue () ; decorated () . updateEntry ( entry , value ) ; MST[VoidMethodCallMutator]MSP[] return oldValue ; }
protected int hash ( final Object key1 , final Object key2 ) { int h = 0 ; if ( key1 != null ) { h ^= key1 . hashCode () ; } if ( key2 != null ) { MST[NegateConditionalsMutator]MSP[] h ^= key2 . hashCode () ; }
while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 ) ) { return true ; MST[ReturnValsMutator]MSP[] } entry = entry . next ; } return false ; }
final MultiKey < ? extends K > multi = entry . getKey () ; return multi . size () == 3 && MST[RemoveConditionalMutator_EQUAL_IF]MSP[] ( key1 == multi . getKey ( 0 ) || key1 != null && key1 . equals ( multi . getKey ( 0 ) ) ) &&
if ( key2 != null ) { h ^= key2 . hashCode () ; } if ( key3 != null ) { h ^= key3 . hashCode () ; } h += ~ ( h << 9 ) ; MST[rv.UOI3Mutator]MSP[] h ^= h >>> 14 ;
final MapIterator < MultiKey < ? extends K > , V > it = mapIterator () ; while ( it . hasNext () ) { final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 1 && MST[rv.ROR4Mutator]MSP[]
protected int hash ( final Object key1 , final Object key2 , final Object key3 , final Object key4 , final Object key5 ) { int h = 0 ; if ( key1 != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] h ^= key1 . hashCode () ; }
checkKey ( key ) ; return super . put ( key , value ) ; MST[ReturnValsMutator]MSP[] } @Override public void putAll ( final Map < ? extends MultiKey < ? extends K > , ? extends V > mapToCopy ) {
decorated () . addMapping ( index , hashCode , new MultiKey <> ( key1 , key2 ) , value ) ; MST[VoidMethodCallMutator]MSP[] return null ; } public V removeMultiKey ( final Object key1 , final Object key2 ) { final int hashCode = hash ( key1 , key2 ) ;
( key1 == multi . getKey ( 0 ) || key1 != null && key1 . equals ( multi . getKey ( 0 ) ) ) && MST[rv.ROR5Mutator]MSP[]
final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 2 && MST[rv.CRCR3Mutator]MSP[] ( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) &&
h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; return h ; MST[rv.UOI2Mutator]MSP[] } protected boolean isEqualKey ( final AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry ,
final int hashCode = hash ( key1 , key2 , key3 , key4 ) ; final int index = decorated () . hashIndex ( hashCode , decorated () . data . length ) ; MST[rv.UOI1Mutator]MSP[]
( key2 == null ? multi . getKey ( 1 ) == null : key2 . equals ( multi . getKey ( 1 ) ) ) ) { MST[NegateConditionalsMutator]MSP[] it . remove () ; modified = true ; } } return modified ; }
h ^= key2 . hashCode () ; } if ( key3 != null ) { h ^= key3 . hashCode () ; } if ( key4 != null ) { h ^= key4 . hashCode () ; } h += ~ ( h << 9 ) ; MST[rv.CRCR6Mutator]MSP[]
entry = entry . next ; } return null ; } protected int hash ( final Object key1 , final Object key2 , final Object key3 ) { int h = 0 ; if ( key1 != null ) { h ^= key1 . hashCode () ; MST[rv.UOI2Mutator]MSP[] }
protected int hash ( final Object key1 , final Object key2 , final Object key3 , final Object key4 ) { int h = 0 ; if ( key1 != null ) { h ^= key1 . hashCode () ; MST[rv.UOI3Mutator]MSP[] } if ( key2 != null ) {
final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 3 && MST[rv.ROR2Mutator]MSP[] ( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) &&
( key1 == multi . getKey ( 0 ) || key1 != null && key1 . equals ( multi . getKey ( 0 ) ) ) && MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 3 && MST[rv.ROR5Mutator]MSP[] ( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) &&
if ( key2 != null ) { h ^= key2 . hashCode () ; } if ( key3 != null ) { h ^= key3 . hashCode () ; } h += ~ ( h << 9 ) ; h ^= h >>> 14 ; MST[rv.CRCR2Mutator]MSP[]
while ( entry != null ) { MST[NegateConditionalsMutator]MSP[] if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 ) ) { return entry . getValue () ; } entry = entry . next ; } return null ; }
if ( key5 != null ) { h ^= key5 . hashCode () ; } h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; MST[rv.UOI3Mutator]MSP[] h ^= h >>> 10 ; return h ; }
( key5 == multi . getKey ( 4 ) || key5 != null && key5 . equals ( multi . getKey ( 4 ) ) ) ; } public boolean removeAll ( final Object key1 ) { boolean modified = false ; MST[rv.CRCR5Mutator]MSP[]
( key2 == null ? multi . getKey ( 1 ) == null : key2 . equals ( multi . getKey ( 1 ) ) ) ) { MST[rv.CRCR3Mutator]MSP[] it . remove () ; modified = true ; } } return modified ; }
( key2 == null ? multi . getKey ( 1 ) == null : key2 . equals ( multi . getKey ( 1 ) ) ) ) { it . remove () ; modified = true ; } } return modified ; MST[BooleanFalseReturnValsMutator]MSP[] }
h ^= key2 . hashCode () ; } if ( key3 != null ) { h ^= key3 . hashCode () ; } if ( key4 != null ) { h ^= key4 . hashCode () ; } h += ~ ( h << 9 ) ; MST[rv.UOI1Mutator]MSP[]
final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 2 && ( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) && MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > previous = null ; while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 , key4 ) ) { MST[rv.ROR4Mutator]MSP[]
decorated () . addMapping ( index , hashCode , new MultiKey <> ( key1 , key2 ) , value ) ; MST[rv.UOI2Mutator]MSP[] return null ; } public V removeMultiKey ( final Object key1 , final Object key2 ) { final int hashCode = hash ( key1 , key2 ) ;
public V removeMultiKey ( final Object key1 , final Object key2 , final Object key3 , final Object key4 , final Object key5 ) { final int hashCode = hash ( key1 , key2 , key3 , key4 , key5 ) ; MST[NonVoidMethodCallMutator]MSP[]
h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; MST[rv.CRCR1Mutator]MSP[] return h ; } protected boolean isEqualKey ( final AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry ,
AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > previous = null ; while ( entry != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 ) ) {
decorated () . addMapping ( index , hashCode , new MultiKey <> ( key1 , key2 , key3 ) , value ) ; MST[rv.UOI4Mutator]MSP[] return null ; } public V removeMultiKey ( final Object key1 , final Object key2 , final Object key3 ) {
throw new IllegalArgumentException ( lr_2 ) ; } return new MultiKeyMap <> ( map ) ; } public V get ( final Object key1 , final Object key2 ) { final int hashCode = hash ( key1 , key2 ) ; MST[NonVoidMethodCallMutator]MSP[]
decorated () . data [ decorated () . hashIndex ( hashCode , decorated () . data . length ) ] ; while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 , key4 ) ) { MST[rv.ROR5Mutator]MSP[]
if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 , key4 ) ) { MST[rv.UOI2Mutator]MSP[] final V oldValue = entry . getValue () ; decorated () . updateEntry ( entry , value ) ; return oldValue ; }
while ( entry != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 ) ) { return true ; } entry = entry . next ; } return false ; }
final int hashCode = hash ( key1 , key2 , key3 ) ; final int index = decorated () . hashIndex ( hashCode , decorated () . data . length ) ; MST[rv.ABSMutator]MSP[]
h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; MST[rv.UOI3Mutator]MSP[] h ^= h >>> 10 ; return h ; }
if ( key5 != null ) { h ^= key5 . hashCode () ; } h += ~ ( h << 9 ) ; h ^= h >>> 14 ; MST[rv.CRCR5Mutator]MSP[] h += h << 4 ; h ^= h >>> 10 ; return h ; }
h ^= key2 . hashCode () ; } if ( key3 != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] h ^= key3 . hashCode () ; } if ( key4 != null ) { h ^= key4 . hashCode () ; } h += ~ ( h << 9 ) ;
final int index = decorated () . hashIndex ( hashCode , decorated () . data . length ) ; MST[ArgumentPropagationMutator]MSP[] AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ index ] ; while ( entry != null ) {
final int index = decorated () . hashIndex ( hashCode , decorated () . data . length ) ; MST[ArgumentPropagationMutator]MSP[] AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ index ] ;
final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 2 && MST[rv.CRCR1Mutator]MSP[] ( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) &&
( key2 == null ? multi . getKey ( 1 ) == null : key2 . equals ( multi . getKey ( 1 ) ) ) && MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
( key4 == multi . getKey ( 3 ) || key4 != null && key4 . equals ( multi . getKey ( 3 ) ) ) ; MST[NegateConditionalsMutator]MSP[] }
h ^= h >>> 14 ; MST[rv.UOI4Mutator]MSP[] h += h << 4 ; h ^= h >>> 10 ; return h ; } protected boolean isEqualKey ( final AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry ,
final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 3 && ( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) && MST[rv.ROR2Mutator]MSP[]
final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 3 && ( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) && MST[rv.ROR5Mutator]MSP[]
( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) ) { MST[rv.ROR1Mutator]MSP[] it . remove () ; modified = true ; } } return modified ; }
while ( entry != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 ) ) { return entry . getValue () ; } entry = entry . next ; } return null ; }
( key3 == multi . getKey ( 2 ) || key3 != null && key3 . equals ( multi . getKey ( 2 ) ) ) ; MST[InlineConstantMutator]MSP[] } public V get ( final Object key1 , final Object key2 , final Object key3 , final Object key4 ) {
final int index = decorated () . hashIndex ( hashCode , decorated () . data . length ) ; AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ index ] ; MST[rv.UOI3Mutator]MSP[] while ( entry != null ) {
protected int hash ( final Object key1 , final Object key2 , final Object key3 , final Object key4 , final Object key5 ) { int h = 0 ; if ( key1 != null ) { MST[NegateConditionalsMutator]MSP[] h ^= key1 . hashCode () ; }
if ( key5 != null ) { h ^= key5 . hashCode () ; } h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; return h ; MST[PrimitiveReturnsMutator]MSP[] }
decorated () . data [ decorated () . hashIndex ( hashCode , decorated () . data . length ) ] ; while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 , key4 ) ) { MST[rv.ROR2Mutator]MSP[]
if ( key5 != null ) { h ^= key5 . hashCode () ; } h += ~ ( h << 9 ) ; MST[rv.UOI3Mutator]MSP[] h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; return h ; }
protected int hash ( final Object key1 , final Object key2 ) { int h = 0 ; if ( key1 != null ) { h ^= key1 . hashCode () ; } if ( key2 != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] h ^= key2 . hashCode () ; }
h ^= key2 . hashCode () ; MST[rv.ABSMutator]MSP[] } if ( key3 != null ) { h ^= key3 . hashCode () ; } if ( key4 != null ) { h ^= key4 . hashCode () ; } h += ~ ( h << 9 ) ;
if ( key5 != null ) { h ^= key5 . hashCode () ; } h += ~ ( h << 9 ) ; h ^= h >>> 14 ; MST[rv.ABSMutator]MSP[] h += h << 4 ; h ^= h >>> 10 ; return h ; }
( key2 == multi . getKey ( 1 ) || key2 != null && key2 . equals ( multi . getKey ( 1 ) ) ) ; MST[rv.CRCR3Mutator]MSP[] } public V get ( final Object key1 , final Object key2 , final Object key3 ) {
final MultiKey < ? extends K > multi = entry . getKey () ; return multi . size () == 3 && MST[NegateConditionalsMutator]MSP[] ( key1 == multi . getKey ( 0 ) || key1 != null && key1 . equals ( multi . getKey ( 0 ) ) ) &&
if ( key2 != null ) { MST[NegateConditionalsMutator]MSP[] h ^= key2 . hashCode () ; } if ( key3 != null ) { h ^= key3 . hashCode () ; } h += ~ ( h << 9 ) ; h ^= h >>> 14 ;
final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 3 && ( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) && MST[NegateConditionalsMutator]MSP[]
h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; MST[rv.UOI1Mutator]MSP[] return h ; } protected boolean isEqualKey ( final AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry ,
final int hashCode = hash ( key1 , key2 , key3 , key4 ) ; final int index = decorated () . hashIndex ( hashCode , decorated () . data . length ) ; MST[ArgumentPropagationMutator]MSP[]
final MultiKey < ? extends K > multi = entry . getKey () ; return multi . size () == 3 && MST[rv.CRCR5Mutator]MSP[] ( key1 == multi . getKey ( 0 ) || key1 != null && key1 . equals ( multi . getKey ( 0 ) ) ) &&
AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > previous = null ; while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 , key4 ) ) { MST[rv.UOI4Mutator]MSP[]
public V put ( final K key1 , final K key2 , final V value ) { final int hashCode = hash ( key1 , key2 ) ; final int index = decorated () . hashIndex ( hashCode , decorated () . data . length ) ; MST[rv.ABSMutator]MSP[]
public boolean containsKey ( final Object key1 , final Object key2 , final Object key3 ) { final int hashCode = hash ( key1 , key2 , key3 ) ; MST[NonVoidMethodCallMutator]MSP[] AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry =
( key3 == multi . getKey ( 2 ) || key3 != null && key3 . equals ( multi . getKey ( 2 ) ) ) && MST[NegateConditionalsMutator]MSP[]
h += h << 4 ; h ^= h >>> 10 ; return h ; MST[rv.ABSMutator]MSP[] } protected boolean isEqualKey ( final AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry , final Object key1 , final Object key2 , final Object key3 ) {
( key4 == multi . getKey ( 3 ) || key4 != null && key4 . equals ( multi . getKey ( 3 ) ) ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] }
( key5 == multi . getKey ( 4 ) || key5 != null && key5 . equals ( multi . getKey ( 4 ) ) ) ; } public boolean removeAll ( final Object key1 ) { boolean modified = false ; MST[InlineConstantMutator]MSP[]
final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 2 && ( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) && MST[rv.CRCR4Mutator]MSP[]
while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 ) ) { return true ; } entry = entry . next ; } return false ; MST[rv.CRCR1Mutator]MSP[] }
final MapIterator < MultiKey < ? extends K > , V > it = mapIterator () ; while ( it . hasNext () ) { final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 1 && MST[rv.ROR1Mutator]MSP[]
final MapIterator < MultiKey < ? extends K > , V > it = mapIterator () ; while ( it . hasNext () ) { final MultiKey < ? extends K > multi = it . next () ; MST[NonVoidMethodCallMutator]MSP[] if ( multi . size () >= 1 &&
final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 2 && MST[rv.CRCR6Mutator]MSP[] ( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) &&
if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 , key4 ) ) { MST[rv.ROR3Mutator]MSP[] final V oldValue = entry . getValue () ; decorated () . updateEntry ( entry , value ) ; return oldValue ; }
if ( key2 != null ) { h ^= key2 . hashCode () ; } if ( key3 != null ) { h ^= key3 . hashCode () ; } h += ~ ( h << 9 ) ; h ^= h >>> 14 ; MST[rv.UOI2Mutator]MSP[]
( key3 == multi . getKey ( 2 ) || key3 != null && key3 . equals ( multi . getKey ( 2 ) ) ) && MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ index ] ; MST[rv.UOI3Mutator]MSP[] while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 ) ) {
if ( key5 != null ) { h ^= key5 . hashCode () ; MST[rv.UOI3Mutator]MSP[] } h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; return h ; }
multi . size () == 2 && MST[NegateConditionalsMutator]MSP[] ( key1 == multi . getKey ( 0 ) || key1 != null && key1 . equals ( multi . getKey ( 0 ) ) ) &&
if ( key5 != null ) { h ^= key5 . hashCode () ; } h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; MST[rv.CRCR6Mutator]MSP[] return h ; }
( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) && MST[rv.CRCR1Mutator]MSP[]
final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 3 && ( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) && MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
final int hashCode = hash ( key1 , key2 , key3 , key4 ) ; final int index = decorated () . hashIndex ( hashCode , decorated () . data . length ) ; MST[rv.UOI4Mutator]MSP[]
if ( key5 != null ) { h ^= key5 . hashCode () ; } h += ~ ( h << 9 ) ; h ^= h >>> 14 ; MST[rv.CRCR2Mutator]MSP[] h += h << 4 ; h ^= h >>> 10 ; return h ; }
public boolean containsKey ( final Object key1 , final Object key2 , final Object key3 , final Object key4 , final Object key5 ) { final int hashCode = hash ( key1 , key2 , key3 , key4 , key5 ) ; MST[NonVoidMethodCallMutator]MSP[]
h += h << 4 ; MST[rv.AOD2Mutator]MSP[] h ^= h >>> 10 ; return h ; } protected boolean isEqualKey ( final AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry , final Object key1 , final Object key2 , final Object key3 ) {
( key2 == null ? multi . getKey ( 1 ) == null : key2 . equals ( multi . getKey ( 1 ) ) ) && MST[rv.CRCR2Mutator]MSP[]
decorated () . data [ decorated () . hashIndex ( hashCode , decorated () . data . length ) ] ; MST[NonVoidMethodCallMutator]MSP[] while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 , key4 ) ) {
public boolean removeAll ( final Object key1 , final Object key2 , final Object key3 ) { boolean modified = false ; MST[rv.CRCR6Mutator]MSP[] final MapIterator < MultiKey < ? extends K > , V > it = mapIterator () ; while ( it . hasNext () ) {
final int hashCode = hash ( key1 , key2 , key3 ) ; final int index = decorated () . hashIndex ( hashCode , decorated () . data . length ) ; MST[ArgumentPropagationMutator]MSP[]
( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) && MST[rv.ROR3Mutator]MSP[]
final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 2 && MST[rv.ROR3Mutator]MSP[] ( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) &&
h ^= h >>> 14 ; MST[rv.UOI1Mutator]MSP[] h += h << 4 ; h ^= h >>> 10 ; return h ; } protected boolean isEqualKey ( final AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry ,
AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > previous = null ; while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 , key4 ) ) { MST[rv.ROR1Mutator]MSP[]
AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > previous = null ; while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 , key4 ) ) { MST[rv.ABSMutator]MSP[]
h += h << 4 ; h ^= h >>> 10 ; return h ; MST[PrimitiveReturnsMutator]MSP[] } protected boolean isEqualKey ( final AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry , final Object key1 , final Object key2 , final Object key3 ) {
protected int hash ( final Object key1 , final Object key2 ) { int h = 0 ; if ( key1 != null ) { h ^= key1 . hashCode () ; MST[NonVoidMethodCallMutator]MSP[] } if ( key2 != null ) { h ^= key2 . hashCode () ; }
h ^= h >>> 14 ; h += h << 4 ; MST[rv.AOR4Mutator]MSP[] h ^= h >>> 10 ; return h ; } protected boolean isEqualKey ( final AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry ,
return true ; } entry = entry . next ; } return false ; MST[ReturnValsMutator]MSP[] } public V put ( final K key1 , final K key2 , final K key3 , final K key4 , final V value ) {
( key1 == multi . getKey ( 0 ) || key1 != null && key1 . equals ( multi . getKey ( 0 ) ) ) && MST[rv.CRCR3Mutator]MSP[]
final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 2 && ( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) && MST[rv.ROR3Mutator]MSP[]
for ( final MultiKey < ? extends K > key : mapToCopy . keySet () ) { MST[NonVoidMethodCallMutator]MSP[] checkKey ( key ) ; } super . putAll ( mapToCopy ) ; } @Override public MapIterator < MultiKey < ? extends K > , V > mapIterator () {
final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 3 && MST[NegateConditionalsMutator]MSP[] ( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) &&
multi . size () == 2 && MST[rv.ROR5Mutator]MSP[] ( key1 == multi . getKey ( 0 ) || key1 != null && key1 . equals ( multi . getKey ( 0 ) ) ) &&
final MapIterator < MultiKey < ? extends K > , V > it = mapIterator () ; while ( it . hasNext () ) { final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 1 && MST[rv.CRCR3Mutator]MSP[]
while ( it . hasNext () ) { final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 4 && MST[rv.ROR3Mutator]MSP[]
h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; MST[rv.UOI4Mutator]MSP[] h ^= h >>> 10 ; return h ; }
final int hashCode = hash ( key1 , key2 , key3 ) ; final int index = decorated () . hashIndex ( hashCode , decorated () . data . length ) ; MST[rv.UOI2Mutator]MSP[]
h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; MST[rv.UOI1Mutator]MSP[] return h ; }
if ( key2 != null ) { h ^= key2 . hashCode () ; } if ( key3 != null ) { h ^= key3 . hashCode () ; } h += ~ ( h << 9 ) ; MST[rv.CRCR6Mutator]MSP[] h ^= h >>> 14 ;
h += ~ ( h << 9 ) ; MST[rv.AOD2Mutator]MSP[] h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; return h ; }
if ( key2 != null ) { h ^= key2 . hashCode () ; } if ( key3 != null ) { h ^= key3 . hashCode () ; MST[NonVoidMethodCallMutator]MSP[] } if ( key4 != null ) { h ^= key4 . hashCode () ; }
if ( key5 != null ) { h ^= key5 . hashCode () ; } h += ~ ( h << 9 ) ; MST[MathMutator]MSP[] h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; return h ; }
while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 ) ) { MST[rv.UOI4Mutator]MSP[] return true ; } entry = entry . next ; } return false ; }
final int index = decorated () . hashIndex ( hashCode , decorated () . data . length ) ; MST[rv.UOI2Mutator]MSP[] AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ index ] ; while ( entry != null ) {
final int index = decorated () . hashIndex ( hashCode , decorated () . data . length ) ; AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ index ] ; MST[NonVoidMethodCallMutator]MSP[]
final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 3 && MST[rv.CRCR2Mutator]MSP[] ( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) &&
protected int hash ( final Object key1 , final Object key2 ) { int h = 0 ; if ( key1 != null ) { h ^= key1 . hashCode () ; } if ( key2 != null ) { h ^= key2 . hashCode () ; MST[MathMutator]MSP[] }
multi . size () == 2 && MST[rv.CRCR5Mutator]MSP[] ( key1 == multi . getKey ( 0 ) || key1 != null && key1 . equals ( multi . getKey ( 0 ) ) ) &&
final int index = decorated () . hashIndex ( hashCode , decorated () . data . length ) ; MST[rv.UOI1Mutator]MSP[] AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ index ] ;
AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ decorated () . hashIndex ( hashCode , decorated () . data . length ) ] ; MST[NonVoidMethodCallMutator]MSP[] while ( entry != null ) {
h ^= key2 . hashCode () ; } if ( key3 != null ) { h ^= key3 . hashCode () ; } if ( key4 != null ) { h ^= key4 . hashCode () ; } h += ~ ( h << 9 ) ; MST[rv.AOR3Mutator]MSP[]
entry = entry . next ; } decorated () . addMapping ( index , hashCode , new MultiKey <> ( key1 , key2 , key3 , key4 , key5 ) , value ) ; MST[rv.UOI3Mutator]MSP[] return null ; }
final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 2 && ( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) && MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ decorated () . hashIndex ( hashCode , decorated () . data . length ) ] ; MST[NonVoidMethodCallMutator]MSP[] while ( entry != null ) {
protected int hash ( final Object key1 , final Object key2 , final Object key3 , final Object key4 , final Object key5 ) { int h = 0 ; if ( key1 != null ) { h ^= key1 . hashCode () ; MST[rv.UOI4Mutator]MSP[] }
( key2 == null ? multi . getKey ( 1 ) == null : key2 . equals ( multi . getKey ( 1 ) ) ) && MST[rv.ROR4Mutator]MSP[]
multi . size () == 2 && ( key1 == multi . getKey ( 0 ) || key1 != null && key1 . equals ( multi . getKey ( 0 ) ) ) && MST[rv.CRCR5Mutator]MSP[]
protected int hash ( final Object key1 , final Object key2 , final Object key3 , final Object key4 , final Object key5 ) { int h = 0 ; if ( key1 != null ) { MST[rv.ROR5Mutator]MSP[] h ^= key1 . hashCode () ; }
h ^= h >>> 14 ; h += h << 4 ; MST[rv.CRCR5Mutator]MSP[] h ^= h >>> 10 ; return h ; } protected boolean isEqualKey ( final AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry ,
final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 2 && ( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) && MST[rv.ROR2Mutator]MSP[]
( key1 == multi . getKey ( 0 ) || key1 != null && key1 . equals ( multi . getKey ( 0 ) ) ) && MST[NegateConditionalsMutator]MSP[]
( key2 == null ? multi . getKey ( 1 ) == null : key2 . equals ( multi . getKey ( 1 ) ) ) && MST[InlineConstantMutator]MSP[]
return true ; } entry = entry . next ; } return false ; MST[rv.CRCR5Mutator]MSP[] } public V put ( final K key1 , final K key2 , final K key3 , final K key4 , final V value ) {
return entry . getValue () ; } entry = entry . next ; } return null ; MST[ReturnValsMutator]MSP[] } public boolean containsKey ( final Object key1 , final Object key2 , final Object key3 , final Object key4 ) {
if ( key2 != null ) { h ^= key2 . hashCode () ; } if ( key3 != null ) { h ^= key3 . hashCode () ; } h += ~ ( h << 9 ) ; MST[rv.ABSMutator]MSP[] h ^= h >>> 14 ;
final int index = decorated () . hashIndex ( hashCode , decorated () . data . length ) ; MST[NonVoidMethodCallMutator]MSP[] AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ index ] ; while ( entry != null ) {
( key3 == null ? multi . getKey ( 2 ) == null : key3 . equals ( multi . getKey ( 2 ) ) ) ) { MST[NonVoidMethodCallMutator]MSP[] it . remove () ; modified = true ; } } return modified ; }
h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; MST[MathMutator]MSP[] return h ; }
protected int hash ( final Object key1 , final Object key2 , final Object key3 , final Object key4 ) { int h = 0 ; if ( key1 != null ) { MST[rv.ROR5Mutator]MSP[] h ^= key1 . hashCode () ; } if ( key2 != null ) {
h += h << 4 ; h ^= h >>> 10 ; return h ; MST[rv.UOI4Mutator]MSP[] } protected boolean isEqualKey ( final AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry , final Object key1 , final Object key2 , final Object key3 ) {
if ( key5 != null ) { h ^= key5 . hashCode () ; } h += ~ ( h << 9 ) ; MST[rv.CRCR3Mutator]MSP[] h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; return h ; }
( key3 == multi . getKey ( 2 ) || key3 != null && key3 . equals ( multi . getKey ( 2 ) ) ) && MST[rv.ROR5Mutator]MSP[]
( key3 == multi . getKey ( 2 ) || key3 != null && key3 . equals ( multi . getKey ( 2 ) ) ) && MST[rv.CRCR3Mutator]MSP[]
final int hashCode = hash ( key1 , key2 , key3 , key4 ) ; MST[NonVoidMethodCallMutator]MSP[] AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry =
if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 ) ) { MST[rv.UOI1Mutator]MSP[] final V oldValue = entry . getValue () ; decorated () . removeMapping ( entry , index , previous ) ; return oldValue ; } previous = entry ;
h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; MST[rv.CRCR6Mutator]MSP[] h ^= h >>> 10 ; return h ; }
final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 3 && ( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) && MST[rv.ROR5Mutator]MSP[]
( key3 == null ? multi . getKey ( 2 ) == null : key3 . equals ( multi . getKey ( 2 ) ) ) ) { it . remove () ; modified = true ; MST[rv.CRCR2Mutator]MSP[] } } return modified ; }
h ^= key2 . hashCode () ; } if ( key3 != null ) { h ^= key3 . hashCode () ; } if ( key4 != null ) { h ^= key4 . hashCode () ; } h += ~ ( h << 9 ) ; MST[rv.UOI2Mutator]MSP[]
if ( key5 != null ) { h ^= key5 . hashCode () ; } h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; MST[rv.UOI2Mutator]MSP[] h ^= h >>> 10 ; return h ; }
protected int hash ( final Object key1 , final Object key2 ) { int h = 0 ; MST[rv.CRCR1Mutator]MSP[] if ( key1 != null ) { h ^= key1 . hashCode () ; } if ( key2 != null ) { h ^= key2 . hashCode () ; }
AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > previous = null ; while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 , key4 ) ) { MST[rv.UOI3Mutator]MSP[]
final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 2 && MST[rv.ROR2Mutator]MSP[] ( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) &&
final int hashCode = hash ( key1 , key2 ) ; AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ decorated () . hashIndex ( hashCode , decorated () . data . length ) ] ; MST[rv.UOI4Mutator]MSP[]
final int index = decorated () . hashIndex ( hashCode , decorated () . data . length ) ; MST[NonVoidMethodCallMutator]MSP[] AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ index ] ;
h += ~ ( h << 9 ) ; MST[rv.UOI4Mutator]MSP[] h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; return h ; }
( key4 == multi . getKey ( 3 ) || key4 != null && key4 . equals ( multi . getKey ( 3 ) ) ) ; MST[rv.CRCR5Mutator]MSP[] }
protected int hash ( final Object key1 , final Object key2 ) { int h = 0 ; if ( key1 != null ) { h ^= key1 . hashCode () ; } if ( key2 != null ) { h ^= key2 . hashCode () ; MST[rv.UOI1Mutator]MSP[] }
AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > previous = null ; while ( entry != null ) { MST[rv.ROR5Mutator]MSP[] if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 , key4 , key5 ) ) {
h += h << 4 ; h ^= h >>> 10 ; MST[MathMutator]MSP[] return h ; } protected boolean isEqualKey ( final AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry , final Object key1 , final Object key2 , final Object key3 ) {
h += h << 4 ; h ^= h >>> 10 ; MST[rv.CRCR3Mutator]MSP[] return h ; } protected boolean isEqualKey ( final AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry , final Object key1 , final Object key2 , final Object key3 ) {
h ^= key2 . hashCode () ; } if ( key3 != null ) { h ^= key3 . hashCode () ; MST[rv.UOI1Mutator]MSP[] } if ( key4 != null ) { h ^= key4 . hashCode () ; } h += ~ ( h << 9 ) ;
while ( it . hasNext () ) { MST[rv.ROR5Mutator]MSP[] final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 4 &&
decorated () . data [ decorated () . hashIndex ( hashCode , decorated () . data . length ) ] ; while ( entry != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 , key4 ) ) {
h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; MST[InlineConstantMutator]MSP[] return h ; } protected boolean isEqualKey ( final AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry ,
( key3 == multi . getKey ( 2 ) || key3 != null && key3 . equals ( multi . getKey ( 2 ) ) ) && MST[NonVoidMethodCallMutator]MSP[]
h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; MST[MathMutator]MSP[] return h ; }
( key2 == multi . getKey ( 1 ) || key2 != null && key2 . equals ( multi . getKey ( 1 ) ) ) && MST[rv.CRCR4Mutator]MSP[]
h ^= h >>> 14 ; h += h << 4 ; MST[rv.UOI4Mutator]MSP[] h ^= h >>> 10 ; return h ; } protected boolean isEqualKey ( final AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry ,
decorated () . data [ decorated () . hashIndex ( hashCode , decorated () . data . length ) ] ; MST[rv.UOI2Mutator]MSP[] while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 ) ) {
final MultiKey < ? extends K > multi = entry . getKey () ; return multi . size () == 3 && MST[rv.CRCR2Mutator]MSP[] ( key1 == multi . getKey ( 0 ) || key1 != null && key1 . equals ( multi . getKey ( 0 ) ) ) &&
final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 3 && MST[InlineConstantMutator]MSP[] ( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) &&
( key4 == null ? multi . getKey ( 3 ) == null : key4 . equals ( multi . getKey ( 3 ) ) ) ) { it . remove () ; modified = true ; } } return modified ; MST[ReturnValsMutator]MSP[] }
AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > previous = null ; while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 , key4 ) ) { MST[rv.UOI1Mutator]MSP[]
final int index = decorated () . hashIndex ( hashCode , decorated () . data . length ) ; MST[rv.UOI2Mutator]MSP[] AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ index ] ; while ( entry != null ) {
final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 3 && ( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) && MST[NonVoidMethodCallMutator]MSP[]
( key2 == multi . getKey ( 1 ) || key2 != null && key2 . equals ( multi . getKey ( 1 ) ) ) ; MST[NonVoidMethodCallMutator]MSP[] } public V get ( final Object key1 , final Object key2 , final Object key3 ) {
h += h << 4 ; h ^= h >>> 10 ; MST[rv.UOI3Mutator]MSP[] return h ; } protected boolean isEqualKey ( final AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry , final Object key1 , final Object key2 , final Object key3 ) {
h ^= h >>> 14 ; MST[rv.ABSMutator]MSP[] h += h << 4 ; h ^= h >>> 10 ; return h ; } protected boolean isEqualKey ( final AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry ,
protected int hash ( final Object key1 , final Object key2 , final Object key3 , final Object key4 ) { int h = 0 ; if ( key1 != null ) { MST[NegateConditionalsMutator]MSP[] h ^= key1 . hashCode () ; } if ( key2 != null ) {
final int index = decorated () . hashIndex ( hashCode , decorated () . data . length ) ; MST[rv.ABSMutator]MSP[] AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ index ] ; while ( entry != null ) {
h += ~ ( h << 9 ) ; MST[rv.UOI4Mutator]MSP[] h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; return h ; }
( key2 == null ? multi . getKey ( 1 ) == null : key2 . equals ( multi . getKey ( 1 ) ) ) ) { it . remove () ; modified = true ; MST[rv.CRCR4Mutator]MSP[] } } return modified ; }
if ( key2 != null ) { h ^= key2 . hashCode () ; } if ( key3 != null ) { h ^= key3 . hashCode () ; } h += ~ ( h << 9 ) ; h ^= h >>> 14 ; MST[rv.UOI3Mutator]MSP[]
h += ~ ( h << 9 ) ; h ^= h >>> 14 ; MST[rv.CRCR3Mutator]MSP[] h += h << 4 ; h ^= h >>> 10 ; return h ; }
AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ decorated () . hashIndex ( hashCode , decorated () . data . length ) ] ; MST[NonVoidMethodCallMutator]MSP[] while ( entry != null ) {
( key2 == null ? multi . getKey ( 1 ) == null : key2 . equals ( multi . getKey ( 1 ) ) ) ) { MST[NegateConditionalsMutator]MSP[] it . remove () ; modified = true ; } } return modified ; }
final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 2 && MST[InlineConstantMutator]MSP[] ( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) &&
h += ~ ( h << 9 ) ; h ^= h >>> 14 ; MST[MathMutator]MSP[] h += h << 4 ; h ^= h >>> 10 ; return h ; }
( key1 == multi . getKey ( 0 ) || key1 != null && key1 . equals ( multi . getKey ( 0 ) ) ) && MST[rv.CRCR4Mutator]MSP[]
entry = entry . next ; } decorated () . addMapping ( index , hashCode , new MultiKey <> ( key1 , key2 , key3 , key4 ) , value ) ; MST[rv.UOI2Mutator]MSP[] return null ; }
( key2 == null ? multi . getKey ( 1 ) == null : key2 . equals ( multi . getKey ( 1 ) ) ) ) { it . remove () ; modified = true ; } } return modified ; MST[rv.UOI2Mutator]MSP[] }
if ( key2 != null ) { h ^= key2 . hashCode () ; } if ( key3 != null ) { h ^= key3 . hashCode () ; MST[MathMutator]MSP[] } h += ~ ( h << 9 ) ; h ^= h >>> 14 ;
multi . size () == 2 && ( key1 == multi . getKey ( 0 ) || key1 != null && key1 . equals ( multi . getKey ( 0 ) ) ) && MST[NonVoidMethodCallMutator]MSP[]
final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 3 && MST[NonVoidMethodCallMutator]MSP[] ( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) &&
h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; MST[rv.UOI2Mutator]MSP[] return h ; } protected boolean isEqualKey ( final AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry ,
h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; MST[rv.ABSMutator]MSP[] return h ; } protected boolean isEqualKey ( final AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry ,
decorated () . addMapping ( index , hashCode , new MultiKey <> ( key1 , key2 , key3 ) , value ) ; MST[rv.ABSMutator]MSP[] return null ; } public V removeMultiKey ( final Object key1 , final Object key2 , final Object key3 ) {
entry = entry . next ; } decorated () . addMapping ( index , hashCode , new MultiKey <> ( key1 , key2 , key3 , key4 , key5 ) , value ) ; MST[rv.UOI2Mutator]MSP[] return null ; }
( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) && MST[NonVoidMethodCallMutator]MSP[]
if ( key5 != null ) { h ^= key5 . hashCode () ; } h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; MST[rv.UOI3Mutator]MSP[] return h ; }
entry = entry . next ; } decorated () . addMapping ( index , hashCode , new MultiKey <> ( key1 , key2 , key3 , key4 , key5 ) , value ) ; MST[rv.ABSMutator]MSP[] return null ; }
protected void checkKey ( final MultiKey < ? > key ) { Objects . requireNonNull ( key , lr_3 ) ; MST[NonVoidMethodCallMutator]MSP[] } @SuppressWarnings ( lr_4 ) @Override public MultiKeyMap < K , V > clone () { try {
decorated () . addMapping ( index , hashCode , new MultiKey <> ( key1 , key2 ) , value ) ; MST[rv.UOI4Mutator]MSP[] return null ; } public V removeMultiKey ( final Object key1 , final Object key2 ) { final int hashCode = hash ( key1 , key2 ) ;
( key3 == null ? multi . getKey ( 2 ) == null : key3 . equals ( multi . getKey ( 2 ) ) ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] it . remove () ; modified = true ; } } return modified ; }
final int index = decorated () . hashIndex ( hashCode , decorated () . data . length ) ; MST[NonVoidMethodCallMutator]MSP[] AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ index ] ;
decorated () . data [ decorated () . hashIndex ( hashCode , decorated () . data . length ) ] ; while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 , key4 ) ) { MST[NegateConditionalsMutator]MSP[]
( key1 == multi . getKey ( 0 ) || key1 != null && key1 . equals ( multi . getKey ( 0 ) ) ) && MST[NonVoidMethodCallMutator]MSP[]
public boolean removeAll ( final Object key1 , final Object key2 , final Object key3 ) { boolean modified = false ; final MapIterator < MultiKey < ? extends K > , V > it = mapIterator () ; while ( it . hasNext () ) { MST[NegateConditionalsMutator]MSP[]
if ( key5 != null ) { h ^= key5 . hashCode () ; } h += ~ ( h << 9 ) ; MST[rv.AOR2Mutator]MSP[] h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; return h ; }
if ( key5 != null ) { h ^= key5 . hashCode () ; } h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; MST[MathMutator]MSP[] return h ; }
if ( key5 != null ) { h ^= key5 . hashCode () ; } h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; MST[rv.CRCR3Mutator]MSP[] return h ; }
AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ index ] ; while ( entry != null ) { MST[NegateConditionalsMutator]MSP[]
if ( key2 != null ) { h ^= key2 . hashCode () ; } if ( key3 != null ) { h ^= key3 . hashCode () ; } h += ~ ( h << 9 ) ; MST[rv.UOI4Mutator]MSP[] h ^= h >>> 14 ;
final Object key1 , final Object key2 , final Object key3 , final Object key4 ) { final MultiKey < ? extends K > multi = entry . getKey () ; return multi . size () == 4 && MST[rv.ROR4Mutator]MSP[]
( key1 == multi . getKey ( 0 ) || key1 != null && key1 . equals ( multi . getKey ( 0 ) ) ) && MST[rv.ROR5Mutator]MSP[]
public boolean removeAll ( final Object key1 , final Object key2 , final Object key3 ) { boolean modified = false ; final MapIterator < MultiKey < ? extends K > , V > it = mapIterator () ; MST[NonVoidMethodCallMutator]MSP[] while ( it . hasNext () ) {
protected int hash ( final Object key1 , final Object key2 ) { int h = 0 ; if ( key1 != null ) { h ^= key1 . hashCode () ; MST[rv.UOI3Mutator]MSP[] } if ( key2 != null ) { h ^= key2 . hashCode () ; }
AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ index ] ; MST[rv.ABSMutator]MSP[] while ( entry != null ) {
h ^= key2 . hashCode () ; } if ( key3 != null ) { h ^= key3 . hashCode () ; } if ( key4 != null ) { h ^= key4 . hashCode () ; } h += ~ ( h << 9 ) ; MST[rv.CRCR4Mutator]MSP[]
( key2 == null ? multi . getKey ( 1 ) == null : key2 . equals ( multi . getKey ( 1 ) ) ) ) { MST[rv.ROR5Mutator]MSP[] it . remove () ; modified = true ; } } return modified ; }
if ( key5 != null ) { h ^= key5 . hashCode () ; } h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; return h ; MST[rv.UOI1Mutator]MSP[] }
final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 3 && MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] ( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) &&
if ( key5 != null ) { h ^= key5 . hashCode () ; } h += ~ ( h << 9 ) ; MST[rv.AOD1Mutator]MSP[] h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; return h ; }
multi . size () == 2 && MST[rv.ROR1Mutator]MSP[] ( key1 == multi . getKey ( 0 ) || key1 != null && key1 . equals ( multi . getKey ( 0 ) ) ) &&
AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ decorated () . hashIndex ( hashCode , decorated () . data . length ) ] ; while ( entry != null ) { MST[NegateConditionalsMutator]MSP[]
h ^= key2 . hashCode () ; MST[rv.UOI4Mutator]MSP[] } if ( key3 != null ) { h ^= key3 . hashCode () ; } if ( key4 != null ) { h ^= key4 . hashCode () ; } h += ~ ( h << 9 ) ;
public boolean removeAll ( final Object key1 , final Object key2 , final Object key3 ) { boolean modified = false ; final MapIterator < MultiKey < ? extends K > , V > it = mapIterator () ; while ( it . hasNext () ) { MST[rv.ROR1Mutator]MSP[]
( key2 == null ? multi . getKey ( 1 ) == null : key2 . equals ( multi . getKey ( 1 ) ) ) ) { MST[rv.CRCR6Mutator]MSP[] it . remove () ; modified = true ; } } return modified ; }
if ( key2 != null ) { h ^= key2 . hashCode () ; MST[rv.ABSMutator]MSP[] } if ( key3 != null ) { h ^= key3 . hashCode () ; } if ( key4 != null ) { h ^= key4 . hashCode () ; }
if ( key2 != null ) { h ^= key2 . hashCode () ; MST[rv.UOI3Mutator]MSP[] } if ( key3 != null ) { h ^= key3 . hashCode () ; } h += ~ ( h << 9 ) ; h ^= h >>> 14 ;
if ( key2 != null ) { h ^= key2 . hashCode () ; } if ( key3 != null ) { h ^= key3 . hashCode () ; } h += ~ ( h << 9 ) ; MST[rv.CRCR2Mutator]MSP[] h ^= h >>> 14 ;
while ( it . hasNext () ) { final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 4 && MST[rv.CRCR6Mutator]MSP[]
multi . size () == 2 && MST[rv.CRCR1Mutator]MSP[] ( key1 == multi . getKey ( 0 ) || key1 != null && key1 . equals ( multi . getKey ( 0 ) ) ) &&
if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 ) ) { MST[rv.UOI3Mutator]MSP[] final V oldValue = entry . getValue () ; decorated () . removeMapping ( entry , index , previous ) ; return oldValue ; } previous = entry ;
protected int hash ( final Object key1 , final Object key2 ) { int h = 0 ; if ( key1 != null ) { h ^= key1 . hashCode () ; MST[MathMutator]MSP[] } if ( key2 != null ) { h ^= key2 . hashCode () ; }
AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ decorated () . hashIndex ( hashCode , decorated () . data . length ) ] ; MST[rv.UOI3Mutator]MSP[] while ( entry != null ) {
decorated () . addMapping ( index , hashCode , new MultiKey <> ( key1 , key2 , key3 ) , value ) ; MST[rv.UOI1Mutator]MSP[] return null ; } public V removeMultiKey ( final Object key1 , final Object key2 , final Object key3 ) {
final int hashCode = hash ( key1 , key2 , key3 ) ; final int index = decorated () . hashIndex ( hashCode , decorated () . data . length ) ; MST[NonVoidMethodCallMutator]MSP[]
h += h << 4 ; MST[rv.AOR3Mutator]MSP[] h ^= h >>> 10 ; return h ; } protected boolean isEqualKey ( final AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry , final Object key1 , final Object key2 , final Object key3 ) {
h += ~ ( h << 9 ) ; h ^= h >>> 14 ; MST[rv.UOI3Mutator]MSP[] h += h << 4 ; h ^= h >>> 10 ; return h ; }
multi . size () == 2 && MST[rv.CRCR4Mutator]MSP[] ( key1 == multi . getKey ( 0 ) || key1 != null && key1 . equals ( multi . getKey ( 0 ) ) ) &&
AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ index ] ; while ( entry != null ) { MST[rv.ROR5Mutator]MSP[]
if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 ) ) { MST[rv.ROR2Mutator]MSP[] final V oldValue = entry . getValue () ; decorated () . removeMapping ( entry , index , previous ) ; return oldValue ; } previous = entry ;
decorated () . data [ decorated () . hashIndex ( hashCode , decorated () . data . length ) ] ; while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 , key4 ) ) { MST[rv.ROR5Mutator]MSP[]
( key2 == multi . getKey ( 1 ) || key2 != null && key2 . equals ( multi . getKey ( 1 ) ) ) ; MST[rv.CRCR6Mutator]MSP[] } public V get ( final Object key1 , final Object key2 , final Object key3 ) {
while ( it . hasNext () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 4 &&
final int index = decorated () . hashIndex ( hashCode , decorated () . data . length ) ; AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ index ] ; MST[rv.ABSMutator]MSP[]
h ^= h >>> 14 ; h += h << 4 ; MST[rv.CRCR1Mutator]MSP[] h ^= h >>> 10 ; return h ; } protected boolean isEqualKey ( final AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry ,
if ( key5 != null ) { h ^= key5 . hashCode () ; } h += ~ ( h << 9 ) ; h ^= h >>> 14 ; MST[rv.UOI3Mutator]MSP[] h += h << 4 ; h ^= h >>> 10 ; return h ; }
final int index = decorated () . hashIndex ( hashCode , decorated () . data . length ) ; AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ index ] ; MST[rv.UOI1Mutator]MSP[]
AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > previous = null ; while ( entry != null ) { MST[NegateConditionalsMutator]MSP[] if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 , key4 , key5 ) ) {
return true ; } entry = entry . next ; } return false ; MST[rv.CRCR1Mutator]MSP[] } public V put ( final K key1 , final K key2 , final K key3 , final K key4 , final V value ) {
entry = entry . next ; } return null ; } protected int hash ( final Object key1 , final Object key2 , final Object key3 ) { int h = 0 ; MST[rv.CRCR3Mutator]MSP[] if ( key1 != null ) { h ^= key1 . hashCode () ; }
( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) && MST[rv.CRCR4Mutator]MSP[]
final int index = decorated () . hashIndex ( hashCode , decorated () . data . length ) ; AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ index ] ; MST[rv.UOI3Mutator]MSP[]
( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) ) { it . remove () ; modified = true ; } } return modified ; MST[rv.UOI2Mutator]MSP[] }
final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 3 && ( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) && MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
decorated () . data [ decorated () . hashIndex ( hashCode , decorated () . data . length ) ] ; MST[rv.UOI2Mutator]MSP[] while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 , key4 ) ) {
public V put ( final K key1 , final K key2 , final V value ) { final int hashCode = hash ( key1 , key2 ) ; final int index = decorated () . hashIndex ( hashCode , decorated () . data . length ) ; MST[NonVoidMethodCallMutator]MSP[]
h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; MST[rv.UOI3Mutator]MSP[] return h ; }
final int hashCode = hash ( key1 , key2 , key3 ) ; AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ decorated () . hashIndex ( hashCode , decorated () . data . length ) ] ; MST[rv.UOI3Mutator]MSP[]
if ( key5 != null ) { h ^= key5 . hashCode () ; } h += ~ ( h << 9 ) ; MST[rv.CRCR5Mutator]MSP[] h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; return h ; }
if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 , key4 ) ) { MST[rv.ROR4Mutator]MSP[] final V oldValue = entry . getValue () ; decorated () . updateEntry ( entry , value ) ; return oldValue ; }
( key3 == null ? multi . getKey ( 2 ) == null : key3 . equals ( multi . getKey ( 2 ) ) ) ) { it . remove () ; modified = true ; MST[InlineConstantMutator]MSP[] } } return modified ; }
( key3 == multi . getKey ( 2 ) || key3 != null && key3 . equals ( multi . getKey ( 2 ) ) ) && MST[rv.CRCR4Mutator]MSP[]
while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 ) ) { MST[rv.ROR5Mutator]MSP[] return true ; } entry = entry . next ; } return false ; }
AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > previous = null ; while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 , key4 ) ) { MST[NegateConditionalsMutator]MSP[]
final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 3 && ( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) && MST[rv.CRCR3Mutator]MSP[]
AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ decorated () . hashIndex ( hashCode , decorated () . data . length ) ] ; MST[rv.ABSMutator]MSP[] while ( entry != null ) {
entry = entry . next ; } decorated () . addMapping ( index , hashCode , new MultiKey <> ( key1 , key2 , key3 , key4 ) , value ) ; MST[rv.ABSMutator]MSP[] return null ; }
h += ~ ( h << 9 ) ; MST[rv.CRCR4Mutator]MSP[] h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; return h ; }
h += ~ ( h << 9 ) ; MST[rv.CRCR2Mutator]MSP[] h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; return h ; }
h ^= h >>> 14 ; h += h << 4 ; MST[rv.UOI1Mutator]MSP[] h ^= h >>> 10 ; return h ; } protected boolean isEqualKey ( final AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry ,
( key4 == multi . getKey ( 3 ) || key4 != null && key4 . equals ( multi . getKey ( 3 ) ) ) ; MST[rv.ROR5Mutator]MSP[] }
decorated () . data [ decorated () . hashIndex ( hashCode , decorated () . data . length ) ] ; while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 , key4 ) ) { MST[rv.UOI4Mutator]MSP[]
while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 ) ) { MST[NegateConditionalsMutator]MSP[] return true ; } entry = entry . next ; } return false ; }
h += ~ ( h << 9 ) ; MST[rv.UOI1Mutator]MSP[] h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; return h ; }
while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 ) ) { return true ; } entry = entry . next ; } return false ; MST[ReturnValsMutator]MSP[] }
multi . size () == 2 && MST[InlineConstantMutator]MSP[] ( key1 == multi . getKey ( 0 ) || key1 != null && key1 . equals ( multi . getKey ( 0 ) ) ) &&
( key3 == multi . getKey ( 2 ) || key3 != null && key3 . equals ( multi . getKey ( 2 ) ) ) && MST[NegateConditionalsMutator]MSP[]
decorated () . addMapping ( index , hashCode , new MultiKey <> ( key1 , key2 ) , value ) ; MST[rv.UOI1Mutator]MSP[] return null ; } public V removeMultiKey ( final Object key1 , final Object key2 ) { final int hashCode = hash ( key1 , key2 ) ;
( key3 == multi . getKey ( 2 ) || key3 != null && key3 . equals ( multi . getKey ( 2 ) ) ) && MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 3 && MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] ( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) &&
final int index = decorated () . hashIndex ( hashCode , decorated () . data . length ) ; AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ index ] ; MST[NonVoidMethodCallMutator]MSP[]
h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; MST[rv.AOR3Mutator]MSP[] h ^= h >>> 10 ; return h ; }
final int index = decorated () . hashIndex ( hashCode , decorated () . data . length ) ; MST[NonVoidMethodCallMutator]MSP[] AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ index ] ; while ( entry != null ) {
if ( key5 != null ) { h ^= key5 . hashCode () ; } h += ~ ( h << 9 ) ; h ^= h >>> 14 ; MST[rv.UOI2Mutator]MSP[] h += h << 4 ; h ^= h >>> 10 ; return h ; }
final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 2 && ( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) && MST[NonVoidMethodCallMutator]MSP[]
if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 , key4 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] final V oldValue = entry . getValue () ; decorated () . updateEntry ( entry , value ) ; return oldValue ; }
decorated () . data [ decorated () . hashIndex ( hashCode , decorated () . data . length ) ] ; while ( entry != null ) { MST[rv.ROR5Mutator]MSP[] if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 , key4 ) ) {
if ( key5 != null ) { h ^= key5 . hashCode () ; } h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; MST[rv.CRCR6Mutator]MSP[] h ^= h >>> 10 ; return h ; }
if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 ) ) { MST[rv.UOI4Mutator]MSP[] final V oldValue = entry . getValue () ; decorated () . removeMapping ( entry , index , previous ) ; return oldValue ; } previous = entry ;
( key3 == null ? multi . getKey ( 2 ) == null : key3 . equals ( multi . getKey ( 2 ) ) ) ) { it . remove () ; modified = true ; MST[rv.CRCR5Mutator]MSP[] } } return modified ; }
if ( key5 != null ) { h ^= key5 . hashCode () ; } h += ~ ( h << 9 ) ; MST[rv.CRCR2Mutator]MSP[] h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; return h ; }
entry = entry . next ; } return null ; } protected int hash ( final Object key1 , final Object key2 , final Object key3 ) { int h = 0 ; if ( key1 != null ) { h ^= key1 . hashCode () ; MST[NonVoidMethodCallMutator]MSP[] }
multi . size () == 2 && ( key1 == multi . getKey ( 0 ) || key1 != null && key1 . equals ( multi . getKey ( 0 ) ) ) && MST[InlineConstantMutator]MSP[]
( key2 == null ? multi . getKey ( 1 ) == null : key2 . equals ( multi . getKey ( 1 ) ) ) && MST[rv.ROR5Mutator]MSP[]
( key4 == null ? multi . getKey ( 3 ) == null : key4 . equals ( multi . getKey ( 3 ) ) ) ) { it . remove () ; modified = true ; } } return modified ; MST[BooleanFalseReturnValsMutator]MSP[] }
protected int hash ( final Object key1 , final Object key2 , final Object key3 , final Object key4 , final Object key5 ) { int h = 0 ; if ( key1 != null ) { h ^= key1 . hashCode () ; MST[rv.UOI1Mutator]MSP[] }
( key2 == multi . getKey ( 1 ) || key2 != null && key2 . equals ( multi . getKey ( 1 ) ) ) && MST[NegateConditionalsMutator]MSP[]
h ^= key2 . hashCode () ; } if ( key3 != null ) { h ^= key3 . hashCode () ; } if ( key4 != null ) { h ^= key4 . hashCode () ; } h += ~ ( h << 9 ) ; MST[MathMutator]MSP[]
decorated () . data [ decorated () . hashIndex ( hashCode , decorated () . data . length ) ] ; while ( entry != null ) { MST[NegateConditionalsMutator]MSP[] if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 ) ) {
final MultiKey < ? extends K > multi = entry . getKey () ; return multi . size () == 3 && MST[rv.ROR2Mutator]MSP[] ( key1 == multi . getKey ( 0 ) || key1 != null && key1 . equals ( multi . getKey ( 0 ) ) ) &&
final MapIterator < MultiKey < ? extends K > , V > it = mapIterator () ; while ( it . hasNext () ) { final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 1 && MST[rv.CRCR4Mutator]MSP[]
( key1 == multi . getKey ( 0 ) || key1 != null && key1 . equals ( multi . getKey ( 0 ) ) ) && MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
( key3 == null ? multi . getKey ( 2 ) == null : key3 . equals ( multi . getKey ( 2 ) ) ) ) { MST[rv.ROR2Mutator]MSP[] it . remove () ; modified = true ; } } return modified ; }
h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; MST[rv.UOI4Mutator]MSP[] return h ; }
if ( key2 != null ) { h ^= key2 . hashCode () ; } if ( key3 != null ) { h ^= key3 . hashCode () ; } h += ~ ( h << 9 ) ; h ^= h >>> 14 ; MST[rv.CRCR6Mutator]MSP[]
if ( key5 != null ) { h ^= key5 . hashCode () ; } h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; return h ; MST[rv.UOI4Mutator]MSP[] }
final MapIterator < MultiKey < ? extends K > , V > it = mapIterator () ; while ( it . hasNext () ) { final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 1 && MST[RemoveConditionalMutator_ORDER_IF]MSP[]
if ( key5 != null ) { h ^= key5 . hashCode () ; MST[MathMutator]MSP[] } h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; return h ; }
if ( key5 != null ) { h ^= key5 . hashCode () ; } h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; MST[rv.AOD2Mutator]MSP[] h ^= h >>> 10 ; return h ; }
final int index = decorated () . hashIndex ( hashCode , decorated () . data . length ) ; MST[rv.UOI4Mutator]MSP[] AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ index ] ;
( key3 == multi . getKey ( 2 ) || key3 != null && key3 . equals ( multi . getKey ( 2 ) ) ) && MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] final V oldValue = entry . getValue () ; decorated () . removeMapping ( entry , index , previous ) ; return oldValue ; } previous = entry ;
final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 3 && MST[rv.CRCR5Mutator]MSP[] ( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) &&
final int index = decorated () . hashIndex ( hashCode , decorated () . data . length ) ; AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ index ] ; MST[rv.UOI3Mutator]MSP[] while ( entry != null ) {
protected int hash ( final Object key1 , final Object key2 , final Object key3 , final Object key4 , final Object key5 ) { int h = 0 ; MST[rv.CRCR5Mutator]MSP[] if ( key1 != null ) { h ^= key1 . hashCode () ; }
multi . size () == 2 && MST[rv.CRCR1Mutator]MSP[] ( key1 == multi . getKey ( 0 ) || key1 != null && key1 . equals ( multi . getKey ( 0 ) ) ) &&
( key2 == null ? multi . getKey ( 1 ) == null : key2 . equals ( multi . getKey ( 1 ) ) ) && MST[NegateConditionalsMutator]MSP[]
decorated () . addMapping ( index , hashCode , new MultiKey <> ( key1 , key2 ) , value ) ; return null ; MST[ReturnValsMutator]MSP[] } public V removeMultiKey ( final Object key1 , final Object key2 ) { final int hashCode = hash ( key1 , key2 ) ;
final int index = decorated () . hashIndex ( hashCode , decorated () . data . length ) ; AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ index ] ; while ( entry != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
if ( key2 != null ) { h ^= key2 . hashCode () ; } if ( key3 != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] h ^= key3 . hashCode () ; } if ( key4 != null ) { h ^= key4 . hashCode () ; }
decorated () . data [ decorated () . hashIndex ( hashCode , decorated () . data . length ) ] ; while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 , key4 ) ) { MST[rv.ROR1Mutator]MSP[]
if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 ) ) { MST[rv.ROR1Mutator]MSP[] final V oldValue = entry . getValue () ; decorated () . removeMapping ( entry , index , previous ) ; return oldValue ; } previous = entry ;
AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > previous = null ; while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 , key4 ) ) { MST[rv.ROR5Mutator]MSP[]
if ( key2 != null ) { h ^= key2 . hashCode () ; } if ( key3 != null ) { h ^= key3 . hashCode () ; } h += ~ ( h << 9 ) ; MST[rv.UOI1Mutator]MSP[] h ^= h >>> 14 ;
h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; MST[rv.CRCR5Mutator]MSP[] return h ; } protected boolean isEqualKey ( final AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry ,
( key2 == multi . getKey ( 1 ) || key2 != null && key2 . equals ( multi . getKey ( 1 ) ) ) && MST[rv.ROR5Mutator]MSP[]
protected int hash ( final Object key1 , final Object key2 ) { int h = 0 ; if ( key1 != null ) { h ^= key1 . hashCode () ; } if ( key2 != null ) { MST[rv.ROR5Mutator]MSP[] h ^= key2 . hashCode () ; }
( key1 == multi . getKey ( 0 ) || key1 != null && key1 . equals ( multi . getKey ( 0 ) ) ) && MST[rv.ROR2Mutator]MSP[]
final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 2 && MST[rv.CRCR5Mutator]MSP[] ( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) &&
while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return true ; } entry = entry . next ; } return false ; }
if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 , key4 ) ) { MST[rv.UOI3Mutator]MSP[] final V oldValue = entry . getValue () ; decorated () . updateEntry ( entry , value ) ; return oldValue ; }
h ^= key2 . hashCode () ; } if ( key3 != null ) { h ^= key3 . hashCode () ; } if ( key4 != null ) { h ^= key4 . hashCode () ; MST[rv.UOI2Mutator]MSP[] } h += ~ ( h << 9 ) ;
final MultiKey < ? extends K > multi = entry . getKey () ; MST[NonVoidMethodCallMutator]MSP[] return multi . size () == 3 && ( key1 == multi . getKey ( 0 ) || key1 != null && key1 . equals ( multi . getKey ( 0 ) ) ) &&
final MapIterator < MultiKey < ? extends K > , V > it = mapIterator () ; while ( it . hasNext () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 1 &&
h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; return h ; MST[rv.UOI1Mutator]MSP[] }
final int hashCode = hash ( key1 , key2 , key3 ) ; AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ decorated () . hashIndex ( hashCode , decorated () . data . length ) ] ; MST[NonVoidMethodCallMutator]MSP[]
( key1 == multi . getKey ( 0 ) || key1 != null && key1 . equals ( multi . getKey ( 0 ) ) ) && MST[NegateConditionalsMutator]MSP[]
while ( it . hasNext () ) { MST[rv.ROR2Mutator]MSP[] final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 4 &&
h += h << 4 ; h ^= h >>> 10 ; return h ; MST[rv.UOI1Mutator]MSP[] } protected boolean isEqualKey ( final AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry , final Object key1 , final Object key2 , final Object key3 ) {
h += ~ ( h << 9 ) ; h ^= h >>> 14 ; MST[rv.CRCR6Mutator]MSP[] h += h << 4 ; h ^= h >>> 10 ; return h ; }
final int index = decorated () . hashIndex ( hashCode , decorated () . data . length ) ; AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ index ] ; MST[NonVoidMethodCallMutator]MSP[] while ( entry != null ) {
final V oldValue = entry . getValue () ; decorated () . removeMapping ( entry , index , previous ) ; return oldValue ; } previous = entry ; entry = entry . next ; } return null ; MST[ReturnValsMutator]MSP[] }
( key3 == multi . getKey ( 2 ) || key3 != null && key3 . equals ( multi . getKey ( 2 ) ) ) && MST[rv.ROR2Mutator]MSP[]
if ( key2 != null ) { h ^= key2 . hashCode () ; } if ( key3 != null ) { h ^= key3 . hashCode () ; } if ( key4 != null ) { h ^= key4 . hashCode () ; MST[rv.UOI3Mutator]MSP[] }
h += h << 4 ; h ^= h >>> 10 ; MST[rv.UOI4Mutator]MSP[] return h ; } protected boolean isEqualKey ( final AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry , final Object key1 , final Object key2 , final Object key3 ) {
h ^= h >>> 14 ; h += h << 4 ; MST[rv.AOR1Mutator]MSP[] h ^= h >>> 10 ; return h ; } protected boolean isEqualKey ( final AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry ,
( key3 == multi . getKey ( 2 ) || key3 != null && key3 . equals ( multi . getKey ( 2 ) ) ) && MST[rv.ROR5Mutator]MSP[]
while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 ) ) { MST[rv.UOI1Mutator]MSP[] return true ; } entry = entry . next ; } return false ; }
h += ~ ( h << 9 ) ; MST[rv.AOR2Mutator]MSP[] h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; return h ; }
AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ decorated () . hashIndex ( hashCode , decorated () . data . length ) ] ; while ( entry != null ) { MST[rv.ROR5Mutator]MSP[]
h ^= key2 . hashCode () ; } if ( key3 != null ) { h ^= key3 . hashCode () ; MST[rv.ABSMutator]MSP[] } if ( key4 != null ) { h ^= key4 . hashCode () ; } h += ~ ( h << 9 ) ;
( key3 == null ? multi . getKey ( 2 ) == null : key3 . equals ( multi . getKey ( 2 ) ) ) ) { it . remove () ; MST[VoidMethodCallMutator]MSP[] modified = true ; } } return modified ; }
public V put ( final K key1 , final K key2 , final V value ) { final int hashCode = hash ( key1 , key2 ) ; final int index = decorated () . hashIndex ( hashCode , decorated () . data . length ) ; MST[rv.UOI2Mutator]MSP[]
h += h << 4 ; MST[MathMutator]MSP[] h ^= h >>> 10 ; return h ; } protected boolean isEqualKey ( final AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry , final Object key1 , final Object key2 , final Object key3 ) {
final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 3 && MST[rv.CRCR1Mutator]MSP[] ( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) &&
( key2 == multi . getKey ( 1 ) || key2 != null && key2 . equals ( multi . getKey ( 1 ) ) ) ; MST[rv.CRCR3Mutator]MSP[] } public V get ( final Object key1 , final Object key2 , final Object key3 ) {
if ( key2 != null ) { h ^= key2 . hashCode () ; } if ( key3 != null ) { h ^= key3 . hashCode () ; } h += ~ ( h << 9 ) ; MST[rv.AOR2Mutator]MSP[] h ^= h >>> 14 ;
decorated () . data [ decorated () . hashIndex ( hashCode , decorated () . data . length ) ] ; while ( entry != null ) { MST[NegateConditionalsMutator]MSP[] if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 , key4 ) ) {
final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 3 && ( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) && MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
if ( key5 != null ) { h ^= key5 . hashCode () ; } h += ~ ( h << 9 ) ; MST[rv.UOI4Mutator]MSP[] h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; return h ; }
final int index = decorated () . hashIndex ( hashCode , decorated () . data . length ) ; MST[rv.UOI2Mutator]MSP[] AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ index ] ;
protected int hash ( final Object key1 , final Object key2 , final Object key3 , final Object key4 ) { int h = 0 ; if ( key1 != null ) { h ^= key1 . hashCode () ; MST[MathMutator]MSP[] } if ( key2 != null ) {
h += h << 4 ; MST[rv.CRCR3Mutator]MSP[] h ^= h >>> 10 ; return h ; } protected boolean isEqualKey ( final AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry , final Object key1 , final Object key2 , final Object key3 ) {
decorated () . data [ decorated () . hashIndex ( hashCode , decorated () . data . length ) ] ; MST[rv.UOI4Mutator]MSP[] while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 ) ) {
h ^= h >>> 14 ; h += h << 4 ; MST[rv.ABSMutator]MSP[] h ^= h >>> 10 ; return h ; } protected boolean isEqualKey ( final AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry ,
( key2 == null ? multi . getKey ( 1 ) == null : key2 . equals ( multi . getKey ( 1 ) ) ) ) { MST[rv.ROR1Mutator]MSP[] it . remove () ; modified = true ; } } return modified ; }
final MultiKey < ? extends K > multi = entry . getKey () ; return multi . size () == 3 && MST[rv.ROR1Mutator]MSP[] ( key1 == multi . getKey ( 0 ) || key1 != null && key1 . equals ( multi . getKey ( 0 ) ) ) &&
h ^= h >>> 14 ; MST[rv.UOI4Mutator]MSP[] h += h << 4 ; h ^= h >>> 10 ; return h ; } protected boolean isEqualKey ( final AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry ,
h += h << 4 ; MST[rv.UOI3Mutator]MSP[] h ^= h >>> 10 ; return h ; } protected boolean isEqualKey ( final AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry , final Object key1 , final Object key2 , final Object key3 ) {
( key4 == multi . getKey ( 3 ) || key4 != null && key4 . equals ( multi . getKey ( 3 ) ) ) ; MST[rv.CRCR6Mutator]MSP[] }
h += ~ ( h << 9 ) ; MST[rv.UOI2Mutator]MSP[] h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; return h ; }
multi . size () == 2 && MST[InlineConstantMutator]MSP[] ( key1 == multi . getKey ( 0 ) || key1 != null && key1 . equals ( multi . getKey ( 0 ) ) ) &&
decorated () . addMapping ( index , hashCode , new MultiKey <> ( key1 , key2 ) , value ) ; MST[rv.ABSMutator]MSP[] return null ; } public V removeMultiKey ( final Object key1 , final Object key2 ) { final int hashCode = hash ( key1 , key2 ) ;
AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > previous = null ; while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 , key4 ) ) { MST[rv.UOI3Mutator]MSP[]
final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 2 && ( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) && MST[rv.CRCR5Mutator]MSP[]
public V put ( final K key1 , final K key2 , final V value ) { final int hashCode = hash ( key1 , key2 ) ; final int index = decorated () . hashIndex ( hashCode , decorated () . data . length ) ; MST[rv.UOI3Mutator]MSP[]
( key2 == null ? multi . getKey ( 1 ) == null : key2 . equals ( multi . getKey ( 1 ) ) ) ) { it . remove () ; modified = true ; MST[rv.CRCR2Mutator]MSP[] } } return modified ; }
h += ~ ( h << 9 ) ; MST[MathMutator]MSP[] h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; return h ; }
if ( key2 != null ) { h ^= key2 . hashCode () ; } if ( key3 != null ) { MST[NegateConditionalsMutator]MSP[] h ^= key3 . hashCode () ; } h += ~ ( h << 9 ) ; h ^= h >>> 14 ;
h += ~ ( h << 9 ) ; h ^= h >>> 14 ; MST[rv.CRCR5Mutator]MSP[] h += h << 4 ; h ^= h >>> 10 ; return h ; }
final Object key1 , final Object key2 , final Object key3 , final Object key4 ) { final MultiKey < ? extends K > multi = entry . getKey () ; MST[NonVoidMethodCallMutator]MSP[] return multi . size () == 4 &&
multi . size () == 2 && MST[NonVoidMethodCallMutator]MSP[] ( key1 == multi . getKey ( 0 ) || key1 != null && key1 . equals ( multi . getKey ( 0 ) ) ) &&
final int hashCode = hash ( key1 , key2 , key3 ) ; MST[NonVoidMethodCallMutator]MSP[] AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ decorated () . hashIndex ( hashCode , decorated () . data . length ) ] ;
h ^= h >>> 14 ; h += h << 4 ; MST[rv.UOI2Mutator]MSP[] h ^= h >>> 10 ; return h ; } protected boolean isEqualKey ( final AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry ,
h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; MST[rv.UOI1Mutator]MSP[] return h ; }
decorated () . data [ decorated () . hashIndex ( hashCode , decorated () . data . length ) ] ; MST[rv.UOI4Mutator]MSP[] while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 , key4 ) ) {
AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ index ] ; AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > previous = null ; while ( entry != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
multi . size () == 2 && ( key1 == multi . getKey ( 0 ) || key1 != null && key1 . equals ( multi . getKey ( 0 ) ) ) && MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
if ( key5 != null ) { h ^= key5 . hashCode () ; } h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; MST[rv.UOI3Mutator]MSP[] h ^= h >>> 10 ; return h ; }
public boolean removeAll ( final Object key1 , final Object key2 ) { boolean modified = false ; final MapIterator < MultiKey < ? extends K > , V > it = mapIterator () ; MST[NonVoidMethodCallMutator]MSP[] while ( it . hasNext () ) {
if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 , key4 , key5 ) ) { return true ; } entry = entry . next ; } return false ; MST[rv.CRCR1Mutator]MSP[] }
( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) && MST[rv.ROR2Mutator]MSP[]
protected int hash ( final Object key1 , final Object key2 ) { int h = 0 ; MST[rv.CRCR3Mutator]MSP[] if ( key1 != null ) { h ^= key1 . hashCode () ; } if ( key2 != null ) { h ^= key2 . hashCode () ; }
( key4 == multi . getKey ( 3 ) || key4 != null && key4 . equals ( multi . getKey ( 3 ) ) ) ; MST[rv.CRCR3Mutator]MSP[] }
multi . size () == 2 && ( key1 == multi . getKey ( 0 ) || key1 != null && key1 . equals ( multi . getKey ( 0 ) ) ) && MST[rv.CRCR4Mutator]MSP[]
( key1 == multi . getKey ( 0 ) || key1 != null && key1 . equals ( multi . getKey ( 0 ) ) ) && MST[rv.ROR1Mutator]MSP[]
if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 , key4 ) ) { MST[rv.UOI2Mutator]MSP[] final V oldValue = entry . getValue () ; decorated () . updateEntry ( entry , value ) ; return oldValue ; }
if ( key5 != null ) { h ^= key5 . hashCode () ; } h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; MST[MathMutator]MSP[] h ^= h >>> 10 ; return h ; }
if ( key2 != null ) { h ^= key2 . hashCode () ; } if ( key3 != null ) { h ^= key3 . hashCode () ; MST[rv.UOI4Mutator]MSP[] } h += ~ ( h << 9 ) ; h ^= h >>> 14 ;
h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; return h ; MST[rv.UOI2Mutator]MSP[] }
h += h << 4 ; h ^= h >>> 10 ; MST[rv.CRCR5Mutator]MSP[] return h ; } protected boolean isEqualKey ( final AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry , final Object key1 , final Object key2 , final Object key3 ) {
decorated () . data [ decorated () . hashIndex ( hashCode , decorated () . data . length ) ] ; MST[ArgumentPropagationMutator]MSP[] while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 ) ) {
if ( key2 != null ) { h ^= key2 . hashCode () ; } if ( key3 != null ) { MST[rv.ROR5Mutator]MSP[] h ^= key3 . hashCode () ; } h += ~ ( h << 9 ) ; h ^= h >>> 14 ;
final int index = decorated () . hashIndex ( hashCode , decorated () . data . length ) ; MST[rv.UOI4Mutator]MSP[] AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ index ] ;
h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; MST[MathMutator]MSP[] h ^= h >>> 10 ; return h ; }
while ( it . hasNext () ) { final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 4 && MST[rv.ROR5Mutator]MSP[]
( key2 == null ? multi . getKey ( 1 ) == null : key2 . equals ( multi . getKey ( 1 ) ) ) && MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
decorated () . data [ decorated () . hashIndex ( hashCode , decorated () . data . length ) ] ; MST[ArgumentPropagationMutator]MSP[] while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 , key4 ) ) {
while ( it . hasNext () ) { final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 4 && MST[rv.ROR2Mutator]MSP[]
if ( key2 != null ) { h ^= key2 . hashCode () ; } if ( key3 != null ) { h ^= key3 . hashCode () ; } h += ~ ( h << 9 ) ; MST[rv.CRCR4Mutator]MSP[] h ^= h >>> 14 ;
h ^= h >>> 14 ; h += h << 4 ; MST[rv.CRCR6Mutator]MSP[] h ^= h >>> 10 ; return h ; } protected boolean isEqualKey ( final AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry ,
entry = entry . next ; } decorated () . addMapping ( index , hashCode , new MultiKey <> ( key1 , key2 , key3 , key4 , key5 ) , value ) ; MST[rv.UOI4Mutator]MSP[] return null ; }
AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ index ] ; while ( entry != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 ) ) {
AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ decorated () . hashIndex ( hashCode , decorated () . data . length ) ] ; MST[rv.UOI1Mutator]MSP[] while ( entry != null ) {
while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 ) ) { MST[rv.UOI3Mutator]MSP[] return true ; } entry = entry . next ; } return false ; }
decorated () . data [ decorated () . hashIndex ( hashCode , decorated () . data . length ) ] ; MST[NonVoidMethodCallMutator]MSP[] while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 , key4 ) ) {
if ( key5 != null ) { h ^= key5 . hashCode () ; } h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; MST[rv.UOI1Mutator]MSP[] return h ; }
final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 2 && MST[RemoveConditionalMutator_ORDER_IF]MSP[] ( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) &&
final Object key1 , final Object key2 , final Object key3 , final Object key4 ) { final MultiKey < ? extends K > multi = entry . getKey () ; return multi . size () == 4 && MST[rv.CRCR1Mutator]MSP[]
final int index = decorated () . hashIndex ( hashCode , decorated () . data . length ) ; AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ index ] ; MST[rv.UOI1Mutator]MSP[]
final int hashCode = hash ( key1 , key2 ) ; AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ decorated () . hashIndex ( hashCode , decorated () . data . length ) ] ; MST[rv.UOI3Mutator]MSP[]
h ^= h >>> 14 ; h += h << 4 ; MST[rv.CRCR3Mutator]MSP[] h ^= h >>> 10 ; return h ; } protected boolean isEqualKey ( final AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry ,
if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 , key4 ) ) { MST[rv.ABSMutator]MSP[] final V oldValue = entry . getValue () ; decorated () . updateEntry ( entry , value ) ; return oldValue ; }
( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] it . remove () ; modified = true ; } } return modified ; }
public boolean removeAll ( final Object key1 , final Object key2 ) { boolean modified = false ; MST[rv.CRCR5Mutator]MSP[] final MapIterator < MultiKey < ? extends K > , V > it = mapIterator () ; while ( it . hasNext () ) {
final int index = decorated () . hashIndex ( hashCode , decorated () . data . length ) ; AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ index ] ; MST[NonVoidMethodCallMutator]MSP[]
if ( key5 != null ) { MST[NegateConditionalsMutator]MSP[] h ^= key5 . hashCode () ; } h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; return h ; }
if ( key2 != null ) { h ^= key2 . hashCode () ; } if ( key3 != null ) { h ^= key3 . hashCode () ; } h += ~ ( h << 9 ) ; MST[rv.AOR1Mutator]MSP[] h ^= h >>> 14 ;
protected int hash ( final Object key1 , final Object key2 , final Object key3 , final Object key4 ) { int h = 0 ; if ( key1 != null ) { h ^= key1 . hashCode () ; } if ( key2 != null ) { MST[rv.ROR5Mutator]MSP[]
if ( key2 != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] h ^= key2 . hashCode () ; } if ( key3 != null ) { h ^= key3 . hashCode () ; } if ( key4 != null ) { h ^= key4 . hashCode () ; }
h += h << 4 ; h ^= h >>> 10 ; MST[rv.CRCR2Mutator]MSP[] return h ; } protected boolean isEqualKey ( final AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry , final Object key1 , final Object key2 , final Object key3 ) {
h ^= key2 . hashCode () ; } if ( key3 != null ) { h ^= key3 . hashCode () ; } if ( key4 != null ) { h ^= key4 . hashCode () ; } h += ~ ( h << 9 ) ; MST[InlineConstantMutator]MSP[]
if ( key2 != null ) { h ^= key2 . hashCode () ; } if ( key3 != null ) { h ^= key3 . hashCode () ; } if ( key4 != null ) { h ^= key4 . hashCode () ; MST[NonVoidMethodCallMutator]MSP[] }
final int index = decorated () . hashIndex ( hashCode , decorated () . data . length ) ; MST[rv.UOI1Mutator]MSP[] AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ index ] ;
( key2 == multi . getKey ( 1 ) || key2 != null && key2 . equals ( multi . getKey ( 1 ) ) ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] } public V get ( final Object key1 , final Object key2 , final Object key3 ) {
protected int hash ( final Object key1 , final Object key2 ) { int h = 0 ; if ( key1 != null ) { MST[rv.ROR5Mutator]MSP[] h ^= key1 . hashCode () ; } if ( key2 != null ) { h ^= key2 . hashCode () ; }
AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ decorated () . hashIndex ( hashCode , decorated () . data . length ) ] ; MST[NonVoidMethodCallMutator]MSP[] while ( entry != null ) {
entry = entry . next ; } decorated () . addMapping ( index , hashCode , new MultiKey <> ( key1 , key2 , key3 , key4 ) , value ) ; MST[rv.UOI4Mutator]MSP[] return null ; }
final MultiKey < ? extends K > multi = it . next () ; MST[NonVoidMethodCallMutator]MSP[] if ( multi . size () >= 3 && ( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) &&
entry = entry . next ; } decorated () . addMapping ( index , hashCode , new MultiKey <> ( key1 , key2 , key3 , key4 ) , value ) ; MST[rv.UOI1Mutator]MSP[] return null ; }
if ( key5 != null ) { h ^= key5 . hashCode () ; } h += ~ ( h << 9 ) ; MST[rv.AOR4Mutator]MSP[] h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; return h ; }
if ( key5 != null ) { h ^= key5 . hashCode () ; } h += ~ ( h << 9 ) ; MST[rv.CRCR2Mutator]MSP[] h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; return h ; }
( key3 == multi . getKey ( 2 ) || key3 != null && key3 . equals ( multi . getKey ( 2 ) ) ) && MST[rv.ROR1Mutator]MSP[]
( key3 == multi . getKey ( 2 ) || key3 != null && key3 . equals ( multi . getKey ( 2 ) ) ) && MST[rv.CRCR4Mutator]MSP[]
if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 ) ) { MST[rv.UOI2Mutator]MSP[] final V oldValue = entry . getValue () ; decorated () . removeMapping ( entry , index , previous ) ; return oldValue ; } previous = entry ;
h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; return h ; MST[ReturnValsMutator]MSP[] } protected boolean isEqualKey ( final AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry ,
( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) && MST[rv.ROR5Mutator]MSP[]
h ^= key2 . hashCode () ; } if ( key3 != null ) { h ^= key3 . hashCode () ; } if ( key4 != null ) { h ^= key4 . hashCode () ; } h += ~ ( h << 9 ) ; MST[rv.ABSMutator]MSP[]
public boolean removeAll ( final Object key1 , final Object key2 ) { boolean modified = false ; final MapIterator < MultiKey < ? extends K > , V > it = mapIterator () ; while ( it . hasNext () ) { MST[rv.ROR2Mutator]MSP[]
public boolean removeAll ( final Object key1 , final Object key2 ) { boolean modified = false ; final MapIterator < MultiKey < ? extends K > , V > it = mapIterator () ; while ( it . hasNext () ) { MST[rv.ROR5Mutator]MSP[]
if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 , key4 ) ) { final V oldValue = entry . getValue () ; decorated () . updateEntry ( entry , value ) ; return oldValue ; MST[ReturnValsMutator]MSP[] }
if ( key2 != null ) { h ^= key2 . hashCode () ; } if ( key3 != null ) { h ^= key3 . hashCode () ; MST[rv.UOI3Mutator]MSP[] } if ( key4 != null ) { h ^= key4 . hashCode () ; }
decorated () . addMapping ( index , hashCode , new MultiKey <> ( key1 , key2 ) , value ) ; MST[rv.UOI2Mutator]MSP[] return null ; } public V removeMultiKey ( final Object key1 , final Object key2 ) { final int hashCode = hash ( key1 , key2 ) ;
AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ index ] ; MST[NonVoidMethodCallMutator]MSP[] while ( entry != null ) {
( key2 == null ? multi . getKey ( 1 ) == null : key2 . equals ( multi . getKey ( 1 ) ) ) && MST[rv.ROR3Mutator]MSP[]
final MapIterator < MultiKey < ? extends K > , V > it = mapIterator () ; while ( it . hasNext () ) { final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 1 && MST[NegateConditionalsMutator]MSP[]
if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 ) ) { MST[rv.ROR2Mutator]MSP[] final V oldValue = entry . getValue () ; decorated () . removeMapping ( entry , index , previous ) ; return oldValue ; } previous = entry ;
final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 3 && MST[rv.CRCR5Mutator]MSP[] ( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) &&
final int index = decorated () . hashIndex ( hashCode , decorated () . data . length ) ; AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ index ] ; MST[NonVoidMethodCallMutator]MSP[] while ( entry != null ) {
h ^= key2 . hashCode () ; MST[rv.UOI1Mutator]MSP[] } if ( key3 != null ) { h ^= key3 . hashCode () ; } if ( key4 != null ) { h ^= key4 . hashCode () ; } h += ~ ( h << 9 ) ;
h += ~ ( h << 9 ) ; h ^= h >>> 14 ; MST[rv.CRCR2Mutator]MSP[] h += h << 4 ; h ^= h >>> 10 ; return h ; }
if ( key5 != null ) { h ^= key5 . hashCode () ; } h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; MST[rv.CRCR5Mutator]MSP[] return h ; }
final MapIterator < MultiKey < ? extends K > , V > it = mapIterator () ; while ( it . hasNext () ) { final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 1 && MST[rv.CRCR1Mutator]MSP[]
protected int hash ( final Object key1 , final Object key2 ) { int h = 0 ; if ( key1 != null ) { h ^= key1 . hashCode () ; MST[rv.UOI1Mutator]MSP[] } if ( key2 != null ) { h ^= key2 . hashCode () ; }
( key2 == multi . getKey ( 1 ) || key2 != null && key2 . equals ( multi . getKey ( 1 ) ) ) && MST[rv.CRCR1Mutator]MSP[]
AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ index ] ; MST[NonVoidMethodCallMutator]MSP[] while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 ) ) {
return true ; } entry = entry . next ; } return false ; MST[rv.CRCR5Mutator]MSP[] } public V put ( final K key1 , final K key2 , final K key3 , final V value ) { final int hashCode = hash ( key1 , key2 , key3 ) ;
( key3 == multi . getKey ( 2 ) || key3 != null && key3 . equals ( multi . getKey ( 2 ) ) ) ; MST[rv.CRCR1Mutator]MSP[] } public V get ( final Object key1 , final Object key2 , final Object key3 , final Object key4 ) {
( key2 == null ? multi . getKey ( 1 ) == null : key2 . equals ( multi . getKey ( 1 ) ) ) ) { MST[rv.ROR4Mutator]MSP[] it . remove () ; modified = true ; } } return modified ; }
decorated () . data [ decorated () . hashIndex ( hashCode , decorated () . data . length ) ] ; while ( entry != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 ) ) {
return decorated () . mapIterator () ; MST[NonVoidMethodCallMutator]MSP[] } @Override protected AbstractHashedMap < MultiKey < ? extends K > , V > decorated () { return ( AbstractHashedMap < MultiKey < ? extends K > , V > ) super . decorated () ; }
decorated () . data [ decorated () . hashIndex ( hashCode , decorated () . data . length ) ] ; MST[rv.UOI1Mutator]MSP[] while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 ) ) {
protected int hash ( final Object key1 , final Object key2 , final Object key3 , final Object key4 ) { int h = 0 ; if ( key1 != null ) { h ^= key1 . hashCode () ; } if ( key2 != null ) { MST[NegateConditionalsMutator]MSP[]
( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) && MST[NegateConditionalsMutator]MSP[]
decorated () . data [ decorated () . hashIndex ( hashCode , decorated () . data . length ) ] ; while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 , key4 ) ) { MST[rv.UOI2Mutator]MSP[]
entry = entry . next ; } decorated () . addMapping ( index , hashCode , new MultiKey <> ( key1 , key2 , key3 , key4 ) , value ) ; MST[ConstructorCallMutator]MSP[] return null ; }
return true ; } entry = entry . next ; } return false ; MST[BooleanTrueReturnValsMutator]MSP[] } public V put ( final K key1 , final K key2 , final K key3 , final V value ) { final int hashCode = hash ( key1 , key2 , key3 ) ;
h ^= h >>> 14 ; MST[rv.UOI1Mutator]MSP[] h += h << 4 ; h ^= h >>> 10 ; return h ; } protected boolean isEqualKey ( final AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry ,
final int index = decorated () . hashIndex ( hashCode , decorated () . data . length ) ; MST[rv.UOI3Mutator]MSP[] AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ index ] ; while ( entry != null ) {
final MapIterator < MultiKey < ? extends K > , V > it = mapIterator () ; while ( it . hasNext () ) { final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 1 && MST[rv.ROR3Mutator]MSP[]
final int index = decorated () . hashIndex ( hashCode , decorated () . data . length ) ; MST[NonVoidMethodCallMutator]MSP[] AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ index ] ;
if ( key5 != null ) { h ^= key5 . hashCode () ; } h += ~ ( h << 9 ) ; MST[rv.UOI1Mutator]MSP[] h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; return h ; }
( key4 == null ? multi . getKey ( 3 ) == null : key4 . equals ( multi . getKey ( 3 ) ) ) ) { it . remove () ; modified = true ; } } return modified ; MST[rv.ABSMutator]MSP[] }
( key4 == multi . getKey ( 3 ) || key4 != null && key4 . equals ( multi . getKey ( 3 ) ) ) ; MST[rv.CRCR6Mutator]MSP[] }
final Object key1 , final Object key2 , final Object key3 , final Object key4 ) { final MultiKey < ? extends K > multi = entry . getKey () ; return multi . size () == 4 && MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
( key2 == null ? multi . getKey ( 1 ) == null : key2 . equals ( multi . getKey ( 1 ) ) ) && MST[NonVoidMethodCallMutator]MSP[]
if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 , key4 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] final V oldValue = entry . getValue () ; decorated () . updateEntry ( entry , value ) ; return oldValue ; }
if ( key5 != null ) { h ^= key5 . hashCode () ; } h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; MST[rv.CRCR2Mutator]MSP[] return h ; }
while ( it . hasNext () ) { final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 4 && MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
while ( it . hasNext () ) { final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 4 && MST[NegateConditionalsMutator]MSP[]
if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 ) ) { MST[NonVoidMethodCallMutator]MSP[] final V oldValue = entry . getValue () ; decorated () . removeMapping ( entry , index , previous ) ; return oldValue ; } previous = entry ;
if ( key2 != null ) { h ^= key2 . hashCode () ; } if ( key3 != null ) { h ^= key3 . hashCode () ; } h += ~ ( h << 9 ) ; MST[rv.AOD2Mutator]MSP[] h ^= h >>> 14 ;
h += ~ ( h << 9 ) ; MST[rv.CRCR6Mutator]MSP[] h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; return h ; }
return decorated () . mapIterator () ; } @Override protected AbstractHashedMap < MultiKey < ? extends K > , V > decorated () { return ( AbstractHashedMap < MultiKey < ? extends K > , V > ) super . decorated () ; MST[NonVoidMethodCallMutator]MSP[] }
final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 2 && ( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) && MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
if ( key2 != null ) { h ^= key2 . hashCode () ; MST[MathMutator]MSP[] } if ( key3 != null ) { h ^= key3 . hashCode () ; } h += ~ ( h << 9 ) ; h ^= h >>> 14 ;
while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 ) ) { return true ; MST[BooleanFalseReturnValsMutator]MSP[] } entry = entry . next ; } return false ; }
h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; MST[rv.UOI4Mutator]MSP[] h ^= h >>> 10 ; return h ; }
( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) ) { MST[rv.CRCR6Mutator]MSP[] it . remove () ; modified = true ; } } return modified ; }
( key3 == null ? multi . getKey ( 2 ) == null : key3 . equals ( multi . getKey ( 2 ) ) ) ) { it . remove () ; modified = true ; } } return modified ; MST[rv.UOI3Mutator]MSP[] }
( key3 == multi . getKey ( 2 ) || key3 != null && key3 . equals ( multi . getKey ( 2 ) ) ) && MST[rv.CRCR1Mutator]MSP[]
while ( entry != null ) { MST[rv.ROR5Mutator]MSP[] if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 ) ) { return true ; } entry = entry . next ; } return false ; }
AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ decorated () . hashIndex ( hashCode , decorated () . data . length ) ] ; MST[rv.UOI1Mutator]MSP[] while ( entry != null ) {
if ( key2 != null ) { h ^= key2 . hashCode () ; MST[rv.UOI2Mutator]MSP[] } if ( key3 != null ) { h ^= key3 . hashCode () ; } if ( key4 != null ) { h ^= key4 . hashCode () ; }
( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) ) { MST[rv.ROR3Mutator]MSP[] it . remove () ; modified = true ; } } return modified ; }
final Object key1 , final Object key2 , final Object key3 , final Object key4 ) { final MultiKey < ? extends K > multi = entry . getKey () ; return multi . size () == 4 && MST[rv.CRCR4Mutator]MSP[]
AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ decorated () . hashIndex ( hashCode , decorated () . data . length ) ] ; MST[NonVoidMethodCallMutator]MSP[] while ( entry != null ) {
h ^= h >>> 14 ; h += h << 4 ; MST[rv.AOD1Mutator]MSP[] h ^= h >>> 10 ; return h ; } protected boolean isEqualKey ( final AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry ,
final int index = decorated () . hashIndex ( hashCode , decorated () . data . length ) ; MST[ArgumentPropagationMutator]MSP[] AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ index ] ; while ( entry != null ) {
if ( key5 != null ) { h ^= key5 . hashCode () ; } h += ~ ( h << 9 ) ; MST[InlineConstantMutator]MSP[] h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; return h ; }
final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 3 && ( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) && MST[rv.CRCR1Mutator]MSP[]
final int index = decorated () . hashIndex ( hashCode , decorated () . data . length ) ; AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ index ] ; MST[rv.UOI4Mutator]MSP[]
( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) ) { it . remove () ; MST[VoidMethodCallMutator]MSP[] modified = true ; } } return modified ; }
while ( it . hasNext () ) { final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 4 && MST[rv.CRCR3Mutator]MSP[]
while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 ) ) { return true ; MST[rv.CRCR4Mutator]MSP[] } entry = entry . next ; } return false ; }
AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ index ] ; MST[rv.UOI1Mutator]MSP[] while ( entry != null ) {
AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ decorated () . hashIndex ( hashCode , decorated () . data . length ) ] ; MST[NonVoidMethodCallMutator]MSP[] while ( entry != null ) {
public boolean removeAll ( final Object key1 , final Object key2 , final Object key3 ) { boolean modified = false ; final MapIterator < MultiKey < ? extends K > , V > it = mapIterator () ; while ( it . hasNext () ) { MST[rv.ROR4Mutator]MSP[]
h ^= h >>> 14 ; MST[MathMutator]MSP[] h += h << 4 ; h ^= h >>> 10 ; return h ; } protected boolean isEqualKey ( final AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry ,
protected int hash ( final Object key1 , final Object key2 , final Object key3 , final Object key4 , final Object key5 ) { int h = 0 ; if ( key1 != null ) { h ^= key1 . hashCode () ; MST[rv.ABSMutator]MSP[] }
protected int hash ( final Object key1 , final Object key2 ) { int h = 0 ; if ( key1 != null ) { MST[NegateConditionalsMutator]MSP[] h ^= key1 . hashCode () ; } if ( key2 != null ) { h ^= key2 . hashCode () ; }
if ( key2 != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] h ^= key2 . hashCode () ; } if ( key3 != null ) { h ^= key3 . hashCode () ; } if ( key4 != null ) { h ^= key4 . hashCode () ; }
entry = entry . next ; } decorated () . addMapping ( index , hashCode , new MultiKey <> ( key1 , key2 , key3 , key4 ) , value ) ; MST[NonVoidMethodCallMutator]MSP[] return null ; }
( key3 == null ? multi . getKey ( 2 ) == null : key3 . equals ( multi . getKey ( 2 ) ) ) ) { it . remove () ; modified = true ; } } return modified ; MST[ReturnValsMutator]MSP[] }
if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] final V oldValue = entry . getValue () ; decorated () . removeMapping ( entry , index , previous ) ; return oldValue ; } previous = entry ;
decorated () . data [ decorated () . hashIndex ( hashCode , decorated () . data . length ) ] ; while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 , key4 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
public V removeMultiKey ( final Object key1 , final Object key2 , final Object key3 , final Object key4 ) { final int hashCode = hash ( key1 , key2 , key3 , key4 ) ; MST[NonVoidMethodCallMutator]MSP[]
( key1 == multi . getKey ( 0 ) || key1 != null && key1 . equals ( multi . getKey ( 0 ) ) ) && MST[InlineConstantMutator]MSP[]
( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) ) { it . remove () ; modified = true ; MST[rv.CRCR4Mutator]MSP[] } } return modified ; }
if ( key2 != null ) { h ^= key2 . hashCode () ; } if ( key3 != null ) { h ^= key3 . hashCode () ; } h += ~ ( h << 9 ) ; MST[rv.AOR4Mutator]MSP[] h ^= h >>> 14 ;
protected int hash ( final Object key1 , final Object key2 , final Object key3 , final Object key4 ) { int h = 0 ; if ( key1 != null ) { h ^= key1 . hashCode () ; MST[rv.UOI4Mutator]MSP[] } if ( key2 != null ) {
h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; MST[rv.UOI2Mutator]MSP[] return h ; }
AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ decorated () . hashIndex ( hashCode , decorated () . data . length ) ] ; MST[ArgumentPropagationMutator]MSP[] while ( entry != null ) {
AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > previous = null ; while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 , key4 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
public boolean removeAll ( final Object key1 , final Object key2 ) { boolean modified = false ; final MapIterator < MultiKey < ? extends K > , V > it = mapIterator () ; while ( it . hasNext () ) { MST[NegateConditionalsMutator]MSP[]
final int hashCode = hash ( key1 , key2 , key3 ) ; final int index = decorated () . hashIndex ( hashCode , decorated () . data . length ) ; MST[rv.UOI3Mutator]MSP[]
if ( key2 != null ) { h ^= key2 . hashCode () ; } if ( key3 != null ) { h ^= key3 . hashCode () ; } h += ~ ( h << 9 ) ; MST[rv.CRCR1Mutator]MSP[] h ^= h >>> 14 ;
if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 ) ) { MST[rv.UOI1Mutator]MSP[] final V oldValue = entry . getValue () ; decorated () . removeMapping ( entry , index , previous ) ; return oldValue ; } previous = entry ;
final int index = decorated () . hashIndex ( hashCode , decorated () . data . length ) ; MST[rv.UOI1Mutator]MSP[] AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ index ] ; while ( entry != null ) {
h ^= key2 . hashCode () ; } if ( key3 != null ) { h ^= key3 . hashCode () ; } if ( key4 != null ) { h ^= key4 . hashCode () ; } h += ~ ( h << 9 ) ; MST[rv.UOI2Mutator]MSP[]
entry = entry . next ; } return null ; } protected int hash ( final Object key1 , final Object key2 , final Object key3 ) { int h = 0 ; if ( key1 != null ) { h ^= key1 . hashCode () ; MST[rv.UOI3Mutator]MSP[] }
h += ~ ( h << 9 ) ; h ^= h >>> 14 ; MST[rv.UOI1Mutator]MSP[] h += h << 4 ; h ^= h >>> 10 ; return h ; }
( key2 == null ? multi . getKey ( 1 ) == null : key2 . equals ( multi . getKey ( 1 ) ) ) && MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
if ( key5 != null ) { h ^= key5 . hashCode () ; } h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; MST[rv.UOI4Mutator]MSP[] return h ; }
( key3 == null ? multi . getKey ( 2 ) == null : key3 . equals ( multi . getKey ( 2 ) ) ) ) { MST[rv.CRCR4Mutator]MSP[] it . remove () ; modified = true ; } } return modified ; }
( key3 == null ? multi . getKey ( 2 ) == null : key3 . equals ( multi . getKey ( 2 ) ) ) ) { it . remove () ; modified = true ; } } return modified ; MST[BooleanTrueReturnValsMutator]MSP[] }
AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > previous = null ; while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 , key4 ) ) { MST[rv.ABSMutator]MSP[]
h ^= h >>> 14 ; h += h << 4 ; MST[rv.AOR3Mutator]MSP[] h ^= h >>> 10 ; return h ; } protected boolean isEqualKey ( final AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry ,
( key2 == multi . getKey ( 1 ) || key2 != null && key2 . equals ( multi . getKey ( 1 ) ) ) ; MST[rv.CRCR6Mutator]MSP[] } public V get ( final Object key1 , final Object key2 , final Object key3 ) {
AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ decorated () . hashIndex ( hashCode , decorated () . data . length ) ] ; while ( entry != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
( key1 == multi . getKey ( 0 ) || key1 != null && key1 . equals ( multi . getKey ( 0 ) ) ) && MST[rv.ROR4Mutator]MSP[]
AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > previous = null ; while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 , key4 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 2 && MST[rv.CRCR3Mutator]MSP[] ( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) &&
h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; return h ; MST[rv.ABSMutator]MSP[] }
h += h << 4 ; h ^= h >>> 10 ; MST[MathMutator]MSP[] return h ; } protected boolean isEqualKey ( final AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry , final Object key1 , final Object key2 , final Object key3 ) {
if ( key2 != null ) { h ^= key2 . hashCode () ; } if ( key3 != null ) { h ^= key3 . hashCode () ; } h += ~ ( h << 9 ) ; MST[rv.UOI4Mutator]MSP[] h ^= h >>> 14 ;
h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; return h ; MST[rv.UOI3Mutator]MSP[] } protected boolean isEqualKey ( final AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry ,
if ( key2 != null ) { h ^= key2 . hashCode () ; MST[NonVoidMethodCallMutator]MSP[] } if ( key3 != null ) { h ^= key3 . hashCode () ; } h += ~ ( h << 9 ) ; h ^= h >>> 14 ;
h ^= key2 . hashCode () ; } if ( key3 != null ) { h ^= key3 . hashCode () ; } if ( key4 != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] h ^= key4 . hashCode () ; } h += ~ ( h << 9 ) ;
if ( key2 != null ) { h ^= key2 . hashCode () ; } if ( key3 != null ) { h ^= key3 . hashCode () ; MST[rv.UOI1Mutator]MSP[] } h += ~ ( h << 9 ) ; h ^= h >>> 14 ;
h ^= key2 . hashCode () ; } if ( key3 != null ) { h ^= key3 . hashCode () ; } if ( key4 != null ) { h ^= key4 . hashCode () ; } h += ~ ( h << 9 ) ; MST[rv.CRCR5Mutator]MSP[]
while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 ) ) { MST[rv.ROR1Mutator]MSP[] return true ; } entry = entry . next ; } return false ; }
final int hashCode = hash ( key1 , key2 , key3 , key4 ) ; final int index = decorated () . hashIndex ( hashCode , decorated () . data . length ) ; MST[rv.UOI3Mutator]MSP[]
if ( key5 != null ) { h ^= key5 . hashCode () ; } h += ~ ( h << 9 ) ; h ^= h >>> 14 ; MST[rv.CRCR1Mutator]MSP[] h += h << 4 ; h ^= h >>> 10 ; return h ; }
AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ decorated () . hashIndex ( hashCode , decorated () . data . length ) ] ; MST[ArgumentPropagationMutator]MSP[] while ( entry != null ) {
if ( key5 != null ) { h ^= key5 . hashCode () ; } h += ~ ( h << 9 ) ; MST[rv.CRCR4Mutator]MSP[] h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; return h ; }
h += ~ ( h << 9 ) ; MST[rv.ABSMutator]MSP[] h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; return h ; }
decorated () . data [ decorated () . hashIndex ( hashCode , decorated () . data . length ) ] ; MST[rv.UOI1Mutator]MSP[] while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 , key4 ) ) {
checkKey ( key ) ; return super . put ( key , value ) ; MST[ArgumentPropagationMutator]MSP[] } @Override public void putAll ( final Map < ? extends MultiKey < ? extends K > , ? extends V > mapToCopy ) {
while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 ) ) { MST[rv.UOI4Mutator]MSP[] return true ; } entry = entry . next ; } return false ; }
h += h << 4 ; MST[rv.UOI4Mutator]MSP[] h ^= h >>> 10 ; return h ; } protected boolean isEqualKey ( final AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry , final Object key1 , final Object key2 , final Object key3 ) {
protected int hash ( final Object key1 , final Object key2 , final Object key3 , final Object key4 , final Object key5 ) { int h = 0 ; MST[InlineConstantMutator]MSP[] if ( key1 != null ) { h ^= key1 . hashCode () ; }
entry = entry . next ; } decorated () . addMapping ( index , hashCode , new MultiKey <> ( key1 , key2 , key3 , key4 , key5 ) , value ) ; MST[rv.UOI3Mutator]MSP[] return null ; }
protected int hash ( final Object key1 , final Object key2 ) { int h = 0 ; MST[rv.CRCR6Mutator]MSP[] if ( key1 != null ) { h ^= key1 . hashCode () ; } if ( key2 != null ) { h ^= key2 . hashCode () ; }
while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 ) ) { MST[rv.ROR3Mutator]MSP[] return true ; } entry = entry . next ; } return false ; }
h += h << 4 ; h ^= h >>> 10 ; MST[rv.UOI1Mutator]MSP[] return h ; } protected boolean isEqualKey ( final AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry , final Object key1 , final Object key2 , final Object key3 ) {
( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) && MST[rv.ROR5Mutator]MSP[]
decorated () . addMapping ( index , hashCode , new MultiKey <> ( key1 , key2 ) , value ) ; MST[rv.UOI3Mutator]MSP[] return null ; } public V removeMultiKey ( final Object key1 , final Object key2 ) { final int hashCode = hash ( key1 , key2 ) ;
if ( key2 != null ) { h ^= key2 . hashCode () ; } if ( key3 != null ) { h ^= key3 . hashCode () ; } h += ~ ( h << 9 ) ; h ^= h >>> 14 ; MST[MathMutator]MSP[]
( key3 == multi . getKey ( 2 ) || key3 != null && key3 . equals ( multi . getKey ( 2 ) ) ) && MST[InlineConstantMutator]MSP[]
final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 2 && ( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) && MST[NonVoidMethodCallMutator]MSP[]
if ( key5 != null ) { h ^= key5 . hashCode () ; MST[rv.UOI4Mutator]MSP[] } h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; return h ; }
final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 2 && MST[rv.CRCR1Mutator]MSP[] ( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) &&
( key2 == null ? multi . getKey ( 1 ) == null : key2 . equals ( multi . getKey ( 1 ) ) ) ) { it . remove () ; modified = true ; MST[rv.CRCR5Mutator]MSP[] } } return modified ; }
if ( key5 != null ) { MST[rv.ROR5Mutator]MSP[] h ^= key5 . hashCode () ; } h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; return h ; }
entry = entry . next ; } decorated () . addMapping ( index , hashCode , new MultiKey <> ( key1 , key2 , key3 , key4 ) , value ) ; MST[rv.UOI2Mutator]MSP[] return null ; }
final MultiKey < ? extends K > multi = entry . getKey () ; return multi . size () == 3 && MST[rv.CRCR6Mutator]MSP[] ( key1 == multi . getKey ( 0 ) || key1 != null && key1 . equals ( multi . getKey ( 0 ) ) ) &&
h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; MST[rv.UOI2Mutator]MSP[] return h ; } protected boolean isEqualKey ( final AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry ,
final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 3 && ( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) && MST[NegateConditionalsMutator]MSP[]
if ( key2 != null ) { h ^= key2 . hashCode () ; } if ( key3 != null ) { h ^= key3 . hashCode () ; } h += ~ ( h << 9 ) ; MST[rv.CRCR5Mutator]MSP[] h ^= h >>> 14 ;
h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; MST[rv.ABSMutator]MSP[] return h ; } protected boolean isEqualKey ( final AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry ,
if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 ) ) { MST[NegateConditionalsMutator]MSP[] final V oldValue = entry . getValue () ; decorated () . removeMapping ( entry , index , previous ) ; return oldValue ; } previous = entry ;
decorated () . addMapping ( index , hashCode , new MultiKey <> ( key1 , key2 , key3 ) , value ) ; MST[rv.ABSMutator]MSP[] return null ; } public V removeMultiKey ( final Object key1 , final Object key2 , final Object key3 ) {
while ( it . hasNext () ) { final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 4 && MST[InlineConstantMutator]MSP[]
AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > previous = null ; while ( entry != null ) { MST[rv.ROR5Mutator]MSP[] if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 , key4 ) ) {
( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) && MST[NonVoidMethodCallMutator]MSP[]
h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; MST[rv.CRCR3Mutator]MSP[] return h ; }
public V get ( final Object key1 , final Object key2 , final Object key3 , final Object key4 , final Object key5 ) { final int hashCode = hash ( key1 , key2 , key3 , key4 , key5 ) ; MST[NonVoidMethodCallMutator]MSP[]
AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > previous = null ; while ( entry != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 , key4 , key5 ) ) {
decorated () . data [ decorated () . hashIndex ( hashCode , decorated () . data . length ) ] ; MST[NonVoidMethodCallMutator]MSP[] while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 ) ) {
entry = entry . next ; } decorated () . addMapping ( index , hashCode , new MultiKey <> ( key1 , key2 , key3 , key4 ) , value ) ; MST[rv.ABSMutator]MSP[] return null ; }
if ( key5 != null ) { h ^= key5 . hashCode () ; } h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; MST[MathMutator]MSP[] return h ; }
final MapIterator < MultiKey < ? extends K > , V > it = mapIterator () ; while ( it . hasNext () ) { MST[rv.ROR3Mutator]MSP[] final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 1 &&
while ( it . hasNext () ) { MST[NegateConditionalsMutator]MSP[] final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 4 &&
final MapIterator < MultiKey < ? extends K > , V > it = mapIterator () ; while ( it . hasNext () ) { final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 1 && MST[rv.CRCR5Mutator]MSP[]
h += ~ ( h << 9 ) ; MST[rv.CRCR1Mutator]MSP[] h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; return h ; }
h += ~ ( h << 9 ) ; MST[rv.CRCR5Mutator]MSP[] h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; return h ; }
( key3 == null ? multi . getKey ( 2 ) == null : key3 . equals ( multi . getKey ( 2 ) ) ) ) { MST[rv.ROR1Mutator]MSP[] it . remove () ; modified = true ; } } return modified ; }
( key3 == null ? multi . getKey ( 2 ) == null : key3 . equals ( multi . getKey ( 2 ) ) ) ) { MST[rv.ROR5Mutator]MSP[] it . remove () ; modified = true ; } } return modified ; }
( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) ) { it . remove () ; modified = true ; } } return modified ; MST[rv.ABSMutator]MSP[] }
public boolean removeAll ( final Object key1 , final Object key2 , final Object key3 , final Object key4 ) { boolean modified = false ; MST[rv.CRCR1Mutator]MSP[] final MapIterator < MultiKey < ? extends K > , V > it = mapIterator () ;
h ^= key2 . hashCode () ; } if ( key3 != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] h ^= key3 . hashCode () ; } if ( key4 != null ) { h ^= key4 . hashCode () ; } h += ~ ( h << 9 ) ;
AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > previous = null ; while ( entry != null ) { MST[NegateConditionalsMutator]MSP[] if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 , key4 ) ) {
final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 3 && ( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) && MST[rv.ROR4Mutator]MSP[]
final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 2 && ( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) && MST[rv.CRCR5Mutator]MSP[]
public boolean removeAll ( final Object key1 , final Object key2 , final Object key3 , final Object key4 ) { boolean modified = false ; MST[rv.CRCR5Mutator]MSP[] final MapIterator < MultiKey < ? extends K > , V > it = mapIterator () ;
final Object key1 , final Object key2 , final Object key3 , final Object key4 ) { final MultiKey < ? extends K > multi = entry . getKey () ; return multi . size () == 4 && MST[InlineConstantMutator]MSP[]
h ^= h >>> 14 ; MST[rv.UOI2Mutator]MSP[] h += h << 4 ; h ^= h >>> 10 ; return h ; } protected boolean isEqualKey ( final AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry ,
if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 , key4 ) ) { MST[rv.UOI1Mutator]MSP[] final V oldValue = entry . getValue () ; decorated () . updateEntry ( entry , value ) ; return oldValue ; }
AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ index ] ; while ( entry != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 ) ) {
if ( key5 != null ) { h ^= key5 . hashCode () ; } h += ~ ( h << 9 ) ; h ^= h >>> 14 ; MST[MathMutator]MSP[] h += h << 4 ; h ^= h >>> 10 ; return h ; }
if ( key5 != null ) { h ^= key5 . hashCode () ; } h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; MST[rv.AOR2Mutator]MSP[] h ^= h >>> 10 ; return h ; }
h ^= key2 . hashCode () ; } if ( key3 != null ) { h ^= key3 . hashCode () ; } if ( key4 != null ) { h ^= key4 . hashCode () ; } h += ~ ( h << 9 ) ; MST[rv.UOI3Mutator]MSP[]
final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 2 && MST[rv.CRCR6Mutator]MSP[] ( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) &&
if ( key5 != null ) { h ^= key5 . hashCode () ; } h += ~ ( h << 9 ) ; h ^= h >>> 14 ; MST[rv.UOI3Mutator]MSP[] h += h << 4 ; h ^= h >>> 10 ; return h ; }
protected int hash ( final Object key1 , final Object key2 , final Object key3 , final Object key4 ) { int h = 0 ; MST[rv.CRCR3Mutator]MSP[] if ( key1 != null ) { h ^= key1 . hashCode () ; } if ( key2 != null ) {
if ( key2 != null ) { h ^= key2 . hashCode () ; } if ( key3 != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] h ^= key3 . hashCode () ; } if ( key4 != null ) { h ^= key4 . hashCode () ; }
h += ~ ( h << 9 ) ; h ^= h >>> 14 ; MST[MathMutator]MSP[] h += h << 4 ; h ^= h >>> 10 ; return h ; }
final int index = decorated () . hashIndex ( hashCode , decorated () . data . length ) ; AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ index ] ; MST[rv.UOI4Mutator]MSP[]
( key2 == multi . getKey ( 1 ) || key2 != null && key2 . equals ( multi . getKey ( 1 ) ) ) ; MST[rv.CRCR5Mutator]MSP[] } public V get ( final Object key1 , final Object key2 , final Object key3 ) {
protected boolean isEqualKey ( final AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry , final Object key1 , final Object key2 ) { final MultiKey < ? extends K > multi = entry . getKey () ; MST[NonVoidMethodCallMutator]MSP[] return
final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 3 && MST[rv.ROR4Mutator]MSP[] ( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) &&
AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ index ] ; MST[rv.UOI3Mutator]MSP[] AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > previous = null ; while ( entry != null ) {
protected int hash ( final Object key1 , final Object key2 , final Object key3 , final Object key4 , final Object key5 ) { int h = 0 ; MST[rv.CRCR1Mutator]MSP[] if ( key1 != null ) { h ^= key1 . hashCode () ; }
while ( it . hasNext () ) { final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 4 && MST[RemoveConditionalMutator_ORDER_ELSE]MSP[]
if ( key2 != null ) { h ^= key2 . hashCode () ; } if ( key3 != null ) { h ^= key3 . hashCode () ; } if ( key4 != null ) { h ^= key4 . hashCode () ; MST[MathMutator]MSP[] }
return decorated () . mapIterator () ; MST[ReturnValsMutator]MSP[] } @Override protected AbstractHashedMap < MultiKey < ? extends K > , V > decorated () { return ( AbstractHashedMap < MultiKey < ? extends K > , V > ) super . decorated () ; }
final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 3 && MST[rv.CRCR6Mutator]MSP[] ( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) &&
if ( key2 != null ) { h ^= key2 . hashCode () ; MST[rv.UOI4Mutator]MSP[] } if ( key3 != null ) { h ^= key3 . hashCode () ; } h += ~ ( h << 9 ) ; h ^= h >>> 14 ;
( key1 == multi . getKey ( 0 ) || key1 != null && key1 . equals ( multi . getKey ( 0 ) ) ) && MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 3 && ( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) && MST[rv.ROR5Mutator]MSP[]
if ( key5 != null ) { h ^= key5 . hashCode () ; } h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; MST[rv.UOI1Mutator]MSP[] h ^= h >>> 10 ; return h ; }
( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] it . remove () ; modified = true ; } } return modified ; }
AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ decorated () . hashIndex ( hashCode , decorated () . data . length ) ] ; MST[rv.UOI4Mutator]MSP[] while ( entry != null ) {
final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 2 && ( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) && MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
( key5 == multi . getKey ( 4 ) || key5 != null && key5 . equals ( multi . getKey ( 4 ) ) ) ; } public boolean removeAll ( final Object key1 ) { boolean modified = false ; MST[rv.CRCR3Mutator]MSP[]
final int index = decorated () . hashIndex ( hashCode , decorated () . data . length ) ; AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ index ] ; MST[rv.UOI2Mutator]MSP[] while ( entry != null ) {
h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; MST[rv.CRCR6Mutator]MSP[] return h ; } protected boolean isEqualKey ( final AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry ,
multi . size () == 2 && ( key1 == multi . getKey ( 0 ) || key1 != null && key1 . equals ( multi . getKey ( 0 ) ) ) && MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
if ( key2 != null ) { h ^= key2 . hashCode () ; } if ( key3 != null ) { h ^= key3 . hashCode () ; MST[NonVoidMethodCallMutator]MSP[] } h += ~ ( h << 9 ) ; h ^= h >>> 14 ;
final int index = decorated () . hashIndex ( hashCode , decorated () . data . length ) ; MST[NonVoidMethodCallMutator]MSP[] AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ index ] ;
if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 ) ) { MST[rv.ROR5Mutator]MSP[] final V oldValue = entry . getValue () ; decorated () . removeMapping ( entry , index , previous ) ; return oldValue ; } previous = entry ;
h ^= h >>> 14 ; MST[rv.CRCR3Mutator]MSP[] h += h << 4 ; h ^= h >>> 10 ; return h ; } protected boolean isEqualKey ( final AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry ,
AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ decorated () . hashIndex ( hashCode , decorated () . data . length ) ] ; while ( entry != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
while ( it . hasNext () ) { final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 4 && MST[ConditionalsBoundaryMutator]MSP[]
final Object key1 , final Object key2 , final Object key3 , final Object key4 ) { final MultiKey < ? extends K > multi = entry . getKey () ; return multi . size () == 4 && MST[rv.ROR3Mutator]MSP[]
h ^= key2 . hashCode () ; } if ( key3 != null ) { h ^= key3 . hashCode () ; MST[rv.UOI2Mutator]MSP[] } if ( key4 != null ) { h ^= key4 . hashCode () ; } h += ~ ( h << 9 ) ;
decorated () . data [ decorated () . hashIndex ( hashCode , decorated () . data . length ) ] ; MST[NonVoidMethodCallMutator]MSP[] while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 , key4 ) ) {
h += h << 4 ; MST[rv.CRCR2Mutator]MSP[] h ^= h >>> 10 ; return h ; } protected boolean isEqualKey ( final AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry , final Object key1 , final Object key2 , final Object key3 ) {
public boolean removeAll ( final Object key1 , final Object key2 , final Object key3 , final Object key4 ) { boolean modified = false ; final MapIterator < MultiKey < ? extends K > , V > it = mapIterator () ; MST[NonVoidMethodCallMutator]MSP[]
h ^= key2 . hashCode () ; MST[MathMutator]MSP[] } if ( key3 != null ) { h ^= key3 . hashCode () ; } if ( key4 != null ) { h ^= key4 . hashCode () ; } h += ~ ( h << 9 ) ;
while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 ) ) { MST[NonVoidMethodCallMutator]MSP[] return true ; } entry = entry . next ; } return false ; }
( key2 == null ? multi . getKey ( 1 ) == null : key2 . equals ( multi . getKey ( 1 ) ) ) ) { it . remove () ; modified = true ; } } return modified ; MST[rv.UOI3Mutator]MSP[] }
while ( it . hasNext () ) { final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 4 && MST[NonVoidMethodCallMutator]MSP[]
( key3 == null ? multi . getKey ( 2 ) == null : key3 . equals ( multi . getKey ( 2 ) ) ) ) { it . remove () ; modified = true ; MST[rv.CRCR6Mutator]MSP[] } } return modified ; }
if ( key2 != null ) { h ^= key2 . hashCode () ; } if ( key3 != null ) { h ^= key3 . hashCode () ; } if ( key4 != null ) { h ^= key4 . hashCode () ; MST[rv.UOI4Mutator]MSP[] }
final int index = decorated () . hashIndex ( hashCode , decorated () . data . length ) ; AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ index ] ; MST[rv.UOI2Mutator]MSP[]
final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 2 && ( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) && MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ index ] ; AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > previous = null ; while ( entry != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
h += ~ ( h << 9 ) ; h ^= h >>> 14 ; MST[rv.UOI3Mutator]MSP[] h += h << 4 ; h ^= h >>> 10 ; return h ; }
public boolean removeAll ( final Object key1 , final Object key2 , final Object key3 ) { boolean modified = false ; final MapIterator < MultiKey < ? extends K > , V > it = mapIterator () ; while ( it . hasNext () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > previous = null ; while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 , key4 ) ) { MST[rv.ROR4Mutator]MSP[]
( key1 == multi . getKey ( 0 ) || key1 != null && key1 . equals ( multi . getKey ( 0 ) ) ) && MST[rv.CRCR1Mutator]MSP[]
final int index = decorated () . hashIndex ( hashCode , decorated () . data . length ) ; MST[NonVoidMethodCallMutator]MSP[] AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ index ] ; while ( entry != null ) {
final MapIterator < MultiKey < ? extends K > , V > it = mapIterator () ; while ( it . hasNext () ) { MST[NonVoidMethodCallMutator]MSP[] final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 1 &&
h ^= key2 . hashCode () ; } if ( key3 != null ) { h ^= key3 . hashCode () ; } if ( key4 != null ) { h ^= key4 . hashCode () ; MST[rv.ABSMutator]MSP[] } h += ~ ( h << 9 ) ;
if ( key2 != null ) { h ^= key2 . hashCode () ; } if ( key3 != null ) { h ^= key3 . hashCode () ; } h += ~ ( h << 9 ) ; h ^= h >>> 14 ; MST[rv.UOI3Mutator]MSP[]
decorated () . data [ decorated () . hashIndex ( hashCode , decorated () . data . length ) ] ; while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 , key4 ) ) { MST[rv.ROR2Mutator]MSP[]
h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; MST[rv.CRCR2Mutator]MSP[] h ^= h >>> 10 ; return h ; }
( key2 == multi . getKey ( 1 ) || key2 != null && key2 . equals ( multi . getKey ( 1 ) ) ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] } public V get ( final Object key1 , final Object key2 , final Object key3 ) {
return ( MultiKeyMap < K , V > ) super . clone () ; MST[ReturnValsMutator]MSP[] } catch ( final CloneNotSupportedException e ) { throw new InternalError () ; } } @Override public V put ( final MultiKey < ? extends K > key , final V value ) {
( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] it . remove () ; modified = true ; } } return modified ; }
( key3 == null ? multi . getKey ( 2 ) == null : key3 . equals ( multi . getKey ( 2 ) ) ) ) { MST[NegateConditionalsMutator]MSP[] it . remove () ; modified = true ; } } return modified ; }
decorated () . data [ decorated () . hashIndex ( hashCode , decorated () . data . length ) ] ; while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 , key4 ) ) { MST[NonVoidMethodCallMutator]MSP[]
( key2 == multi . getKey ( 1 ) || key2 != null && key2 . equals ( multi . getKey ( 1 ) ) ) && MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
while ( it . hasNext () ) { MST[rv.ROR1Mutator]MSP[] final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 4 &&
AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ decorated () . hashIndex ( hashCode , decorated () . data . length ) ] ; MST[rv.UOI1Mutator]MSP[] while ( entry != null ) {
if ( key5 != null ) { h ^= key5 . hashCode () ; } h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; MST[rv.CRCR5Mutator]MSP[] h ^= h >>> 10 ; return h ; }
protected void checkKey ( final MultiKey < ? > key ) { Objects . requireNonNull ( key , lr_3 ) ; MST[ArgumentPropagationMutator]MSP[] } @SuppressWarnings ( lr_4 ) @Override public MultiKeyMap < K , V > clone () { try {
final int index = decorated () . hashIndex ( hashCode , decorated () . data . length ) ; MST[ArgumentPropagationMutator]MSP[] AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ index ] ;
public V put ( final K key1 , final K key2 , final V value ) { final int hashCode = hash ( key1 , key2 ) ; final int index = decorated () . hashIndex ( hashCode , decorated () . data . length ) ; MST[NonVoidMethodCallMutator]MSP[]
h += h << 4 ; h ^= h >>> 10 ; MST[rv.UOI4Mutator]MSP[] return h ; } protected boolean isEqualKey ( final AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry , final Object key1 , final Object key2 , final Object key3 ) {
( key2 == null ? multi . getKey ( 1 ) == null : key2 . equals ( multi . getKey ( 1 ) ) ) ) { MST[InlineConstantMutator]MSP[] it . remove () ; modified = true ; } } return modified ; }
( key3 == multi . getKey ( 2 ) || key3 != null && key3 . equals ( multi . getKey ( 2 ) ) ) ; MST[rv.CRCR5Mutator]MSP[] } public V get ( final Object key1 , final Object key2 , final Object key3 , final Object key4 ) {
( key4 == null ? multi . getKey ( 3 ) == null : key4 . equals ( multi . getKey ( 3 ) ) ) ) { it . remove () ; modified = true ; } } return modified ; MST[rv.UOI2Mutator]MSP[] }
protected int hash ( final Object key1 , final Object key2 ) { int h = 0 ; MST[InlineConstantMutator]MSP[] if ( key1 != null ) { h ^= key1 . hashCode () ; } if ( key2 != null ) { h ^= key2 . hashCode () ; }
decorated () . data [ decorated () . hashIndex ( hashCode , decorated () . data . length ) ] ; while ( entry != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 ) ) {
decorated () . data [ decorated () . hashIndex ( hashCode , decorated () . data . length ) ] ; MST[rv.UOI4Mutator]MSP[] while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 , key4 ) ) {
while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 ) ) { return true ; } entry = entry . next ; } return false ; MST[rv.CRCR5Mutator]MSP[] }
decorated () . addMapping ( index , hashCode , new MultiKey <> ( key1 , key2 , key3 ) , value ) ; MST[rv.UOI3Mutator]MSP[] return null ; } public V removeMultiKey ( final Object key1 , final Object key2 , final Object key3 ) {
decorated () . data [ decorated () . hashIndex ( hashCode , decorated () . data . length ) ] ; while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 , key4 ) ) { MST[rv.ABSMutator]MSP[]
h ^= key2 . hashCode () ; } if ( key3 != null ) { h ^= key3 . hashCode () ; } if ( key4 != null ) { h ^= key4 . hashCode () ; } h += ~ ( h << 9 ) ; MST[MathMutator]MSP[]
return true ; } entry = entry . next ; } return false ; MST[ReturnValsMutator]MSP[] } public V put ( final K key1 , final K key2 , final K key3 , final V value ) { final int hashCode = hash ( key1 , key2 , key3 ) ;
if ( key5 != null ) { h ^= key5 . hashCode () ; } h += ~ ( h << 9 ) ; MST[rv.AOR1Mutator]MSP[] h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; return h ; }
protected int hash ( final Object key1 , final Object key2 ) { int h = 0 ; if ( key1 != null ) { h ^= key1 . hashCode () ; MST[rv.UOI4Mutator]MSP[] } if ( key2 != null ) { h ^= key2 . hashCode () ; }
if ( key5 != null ) { h ^= key5 . hashCode () ; MST[rv.UOI1Mutator]MSP[] } h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; return h ; }
decorated () . addMapping ( index , hashCode , new MultiKey <> ( key1 , key2 ) , value ) ; return null ; } public V removeMultiKey ( final Object key1 , final Object key2 ) { final int hashCode = hash ( key1 , key2 ) ; MST[NonVoidMethodCallMutator]MSP[]
AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ decorated () . hashIndex ( hashCode , decorated () . data . length ) ] ; MST[rv.UOI4Mutator]MSP[] while ( entry != null ) {
if ( key5 != null ) { h ^= key5 . hashCode () ; } h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; MST[rv.CRCR2Mutator]MSP[] h ^= h >>> 10 ; return h ; }
h ^= key2 . hashCode () ; } if ( key3 != null ) { h ^= key3 . hashCode () ; } if ( key4 != null ) { h ^= key4 . hashCode () ; } h += ~ ( h << 9 ) ; MST[rv.CRCR1Mutator]MSP[]
( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) && MST[rv.CRCR5Mutator]MSP[]
h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; MST[rv.UOI4Mutator]MSP[] return h ; }
final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 3 && ( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) && MST[NegateConditionalsMutator]MSP[]
multi . size () == 2 && ( key1 == multi . getKey ( 0 ) || key1 != null && key1 . equals ( multi . getKey ( 0 ) ) ) && MST[rv.ROR5Mutator]MSP[]
final V oldValue = entry . getValue () ; decorated () . removeMapping ( entry , index , previous ) ; return oldValue ; } previous = entry ; entry = entry . next ; } return null ; MST[ReturnValsMutator]MSP[] }
h += h << 4 ; h ^= h >>> 10 ; return h ; MST[rv.UOI2Mutator]MSP[] } protected boolean isEqualKey ( final AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry , final Object key1 , final Object key2 , final Object key3 ) {
( key3 == multi . getKey ( 2 ) || key3 != null && key3 . equals ( multi . getKey ( 2 ) ) ) && MST[rv.CRCR1Mutator]MSP[]
h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; MST[rv.ABSMutator]MSP[] return h ; }
if ( key2 != null ) { MST[rv.ROR5Mutator]MSP[] h ^= key2 . hashCode () ; } if ( key3 != null ) { h ^= key3 . hashCode () ; } h += ~ ( h << 9 ) ; h ^= h >>> 14 ;
if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 , key4 ) ) { MST[rv.ROR3Mutator]MSP[] final V oldValue = entry . getValue () ; decorated () . updateEntry ( entry , value ) ; return oldValue ; }
AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ index ] ; MST[NonVoidMethodCallMutator]MSP[] AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > previous = null ; while ( entry != null ) {
decorated () . data [ decorated () . hashIndex ( hashCode , decorated () . data . length ) ] ; while ( entry != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 , key4 ) ) {
AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > previous = null ; while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 , key4 ) ) { MST[rv.ROR1Mutator]MSP[]
if ( key5 != null ) { h ^= key5 . hashCode () ; } h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; return h ; MST[rv.ABSMutator]MSP[] }
final Object key1 , final Object key2 , final Object key3 , final Object key4 ) { final MultiKey < ? extends K > multi = entry . getKey () ; return multi . size () == 4 && MST[InlineConstantMutator]MSP[]
( key4 == multi . getKey ( 3 ) || key4 != null && key4 . equals ( multi . getKey ( 3 ) ) ) ; MST[rv.CRCR3Mutator]MSP[] }
final int hashCode = hash ( key1 , key2 ) ; MST[NonVoidMethodCallMutator]MSP[] AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ decorated () . hashIndex ( hashCode , decorated () . data . length ) ] ;
if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 , key4 ) ) { MST[rv.ABSMutator]MSP[] final V oldValue = entry . getValue () ; decorated () . updateEntry ( entry , value ) ; return oldValue ; }
if ( key5 != null ) { h ^= key5 . hashCode () ; } h += ~ ( h << 9 ) ; h ^= h >>> 14 ; MST[InlineConstantMutator]MSP[] h += h << 4 ; h ^= h >>> 10 ; return h ; }
( key2 == null ? multi . getKey ( 1 ) == null : key2 . equals ( multi . getKey ( 1 ) ) ) && MST[rv.CRCR6Mutator]MSP[]
AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > previous = null ; while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 , key4 ) ) { MST[NonVoidMethodCallMutator]MSP[]
if ( key2 != null ) { h ^= key2 . hashCode () ; } if ( key3 != null ) { h ^= key3 . hashCode () ; } h += ~ ( h << 9 ) ; h ^= h >>> 14 ; MST[rv.ABSMutator]MSP[]
protected int hash ( final Object key1 , final Object key2 , final Object key3 , final Object key4 ) { int h = 0 ; if ( key1 != null ) { h ^= key1 . hashCode () ; MST[NonVoidMethodCallMutator]MSP[] } if ( key2 != null ) {
multi . size () == 2 && ( key1 == multi . getKey ( 0 ) || key1 != null && key1 . equals ( multi . getKey ( 0 ) ) ) && MST[NegateConditionalsMutator]MSP[]
while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return true ; } entry = entry . next ; } return false ; }
h ^= h >>> 14 ; h += h << 4 ; MST[MathMutator]MSP[] h ^= h >>> 10 ; return h ; } protected boolean isEqualKey ( final AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry ,
final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 2 && MST[InlineConstantMutator]MSP[] ( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) &&
protected int hash ( final Object key1 , final Object key2 , final Object key3 , final Object key4 ) { int h = 0 ; if ( key1 != null ) { h ^= key1 . hashCode () ; MST[rv.UOI1Mutator]MSP[] } if ( key2 != null ) {
h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; MST[rv.UOI1Mutator]MSP[] h ^= h >>> 10 ; return h ; }
AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ decorated () . hashIndex ( hashCode , decorated () . data . length ) ] ; while ( entry != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 ) ) { MST[rv.UOI4Mutator]MSP[] final V oldValue = entry . getValue () ; decorated () . removeMapping ( entry , index , previous ) ; return oldValue ; } previous = entry ;
final int index = decorated () . hashIndex ( hashCode , decorated () . data . length ) ; MST[NonVoidMethodCallMutator]MSP[] AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ index ] ;
( key1 == multi . getKey ( 0 ) || key1 != null && key1 . equals ( multi . getKey ( 0 ) ) ) && MST[InlineConstantMutator]MSP[]
AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ decorated () . hashIndex ( hashCode , decorated () . data . length ) ] ; MST[rv.ABSMutator]MSP[] while ( entry != null ) {
h += ~ ( h << 9 ) ; h ^= h >>> 14 ; MST[rv.UOI4Mutator]MSP[] h += h << 4 ; h ^= h >>> 10 ; return h ; }
( key2 == null ? multi . getKey ( 1 ) == null : key2 . equals ( multi . getKey ( 1 ) ) ) ) { it . remove () ; modified = true ; } } return modified ; MST[rv.ABSMutator]MSP[] }
final int hashCode = hash ( key1 , key2 ) ; AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ decorated () . hashIndex ( hashCode , decorated () . data . length ) ] ; MST[NonVoidMethodCallMutator]MSP[]
decorated () . data [ decorated () . hashIndex ( hashCode , decorated () . data . length ) ] ; while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 , key4 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
final int index = decorated () . hashIndex ( hashCode , decorated () . data . length ) ; MST[ArgumentPropagationMutator]MSP[] AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ index ] ;
( key5 == multi . getKey ( 4 ) || key5 != null && key5 . equals ( multi . getKey ( 4 ) ) ) ; } public boolean removeAll ( final Object key1 ) { boolean modified = false ; MST[rv.CRCR6Mutator]MSP[]
if ( key5 != null ) { h ^= key5 . hashCode () ; } h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; MST[rv.UOI4Mutator]MSP[] h ^= h >>> 10 ; return h ; }
if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 ) ) { MST[rv.ABSMutator]MSP[] final V oldValue = entry . getValue () ; decorated () . removeMapping ( entry , index , previous ) ; return oldValue ; } previous = entry ;
decorated () . data [ decorated () . hashIndex ( hashCode , decorated () . data . length ) ] ; while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 , key4 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 2 && ( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) && MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
final int index = decorated () . hashIndex ( hashCode , decorated () . data . length ) ; MST[rv.UOI3Mutator]MSP[] AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ index ] ;
if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 , key4 , key5 ) ) { return true ; } entry = entry . next ; } return false ; MST[InlineConstantMutator]MSP[] }
( key3 == null ? multi . getKey ( 2 ) == null : key3 . equals ( multi . getKey ( 2 ) ) ) ) { MST[rv.CRCR1Mutator]MSP[] it . remove () ; modified = true ; } } return modified ; }
( key2 == multi . getKey ( 1 ) || key2 != null && key2 . equals ( multi . getKey ( 1 ) ) ) && MST[InlineConstantMutator]MSP[]
final int hashCode = hash ( key1 , key2 , key3 , key4 ) ; final int index = decorated () . hashIndex ( hashCode , decorated () . data . length ) ; MST[NonVoidMethodCallMutator]MSP[]
final MapIterator < MultiKey < ? extends K > , V > it = mapIterator () ; while ( it . hasNext () ) { final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 1 && MST[rv.ROR5Mutator]MSP[]
final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 2 && MST[NonVoidMethodCallMutator]MSP[] ( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) &&
( key2 == null ? multi . getKey ( 1 ) == null : key2 . equals ( multi . getKey ( 1 ) ) ) ) { it . remove () ; modified = true ; } } return modified ; MST[BooleanTrueReturnValsMutator]MSP[] }
if ( key5 != null ) { h ^= key5 . hashCode () ; MST[NonVoidMethodCallMutator]MSP[] } h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; return h ; }
protected int hash ( final Object key1 , final Object key2 , final Object key3 , final Object key4 , final Object key5 ) { int h = 0 ; if ( key1 != null ) { h ^= key1 . hashCode () ; MST[rv.UOI2Mutator]MSP[] }
h += h << 4 ; MST[MathMutator]MSP[] h ^= h >>> 10 ; return h ; } protected boolean isEqualKey ( final AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry , final Object key1 , final Object key2 , final Object key3 ) {
( key2 == multi . getKey ( 1 ) || key2 != null && key2 . equals ( multi . getKey ( 1 ) ) ) ; MST[rv.CRCR2Mutator]MSP[] } public V get ( final Object key1 , final Object key2 , final Object key3 ) {
final int index = decorated () . hashIndex ( hashCode , decorated () . data . length ) ; MST[rv.UOI3Mutator]MSP[] AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ index ] ;
AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ index ] ; MST[rv.UOI4Mutator]MSP[] while ( entry != null ) {
AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > previous = null ; while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 , key4 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
h ^= h >>> 14 ; MST[rv.CRCR5Mutator]MSP[] h += h << 4 ; h ^= h >>> 10 ; return h ; } protected boolean isEqualKey ( final AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry ,
h += ~ ( h << 9 ) ; MST[InlineConstantMutator]MSP[] h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; return h ; }
if ( key5 != null ) { h ^= key5 . hashCode () ; } h += ~ ( h << 9 ) ; MST[rv.UOI4Mutator]MSP[] h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; return h ; }
final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 3 && MST[rv.ROR1Mutator]MSP[] ( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) &&
multi . size () == 2 && MST[rv.ROR2Mutator]MSP[] ( key1 == multi . getKey ( 0 ) || key1 != null && key1 . equals ( multi . getKey ( 0 ) ) ) &&
if ( key5 != null ) { h ^= key5 . hashCode () ; } h += ~ ( h << 9 ) ; MST[rv.AOD2Mutator]MSP[] h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; return h ; }
h += ~ ( h << 9 ) ; MST[rv.CRCR3Mutator]MSP[] h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; return h ; }
if ( key5 != null ) { h ^= key5 . hashCode () ; } h += ~ ( h << 9 ) ; MST[rv.ABSMutator]MSP[] h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; return h ; }
h ^= key2 . hashCode () ; } if ( key3 != null ) { MST[rv.ROR5Mutator]MSP[] h ^= key3 . hashCode () ; } if ( key4 != null ) { h ^= key4 . hashCode () ; } h += ~ ( h << 9 ) ;
h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; MST[rv.UOI3Mutator]MSP[] return h ; } protected boolean isEqualKey ( final AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry ,
( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) ) { MST[rv.CRCR3Mutator]MSP[] it . remove () ; modified = true ; } } return modified ; }
final MultiKey < ? extends K > multi = entry . getKey () ; return MST[ReturnValsMutator]MSP[] multi . size () == 3 && ( key1 == multi . getKey ( 0 ) || key1 != null && key1 . equals ( multi . getKey ( 0 ) ) ) &&
final MultiKey < ? extends K > multi = entry . getKey () ; return MST[BooleanTrueReturnValsMutator]MSP[] multi . size () == 3 && ( key1 == multi . getKey ( 0 ) || key1 != null && key1 . equals ( multi . getKey ( 0 ) ) ) &&
if ( key2 != null ) { h ^= key2 . hashCode () ; } if ( key3 != null ) { h ^= key3 . hashCode () ; } if ( key4 != null ) { MST[NegateConditionalsMutator]MSP[] h ^= key4 . hashCode () ; }
( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) ) { it . remove () ; modified = true ; } } return modified ; MST[BooleanFalseReturnValsMutator]MSP[] }
decorated () . data [ decorated () . hashIndex ( hashCode , decorated () . data . length ) ] ; while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 , key4 ) ) { MST[rv.UOI4Mutator]MSP[]
if ( key5 != null ) { h ^= key5 . hashCode () ; } h += ~ ( h << 9 ) ; MST[rv.CRCR1Mutator]MSP[] h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; return h ; }
if ( key5 != null ) { h ^= key5 . hashCode () ; } h += ~ ( h << 9 ) ; MST[rv.CRCR6Mutator]MSP[] h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; return h ; }
( key3 == multi . getKey ( 2 ) || key3 != null && key3 . equals ( multi . getKey ( 2 ) ) ) && MST[InlineConstantMutator]MSP[]
h += ~ ( h << 9 ) ; MST[rv.UOI1Mutator]MSP[] h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; return h ; }
h += h << 4 ; MST[rv.UOI1Mutator]MSP[] h ^= h >>> 10 ; return h ; } protected boolean isEqualKey ( final AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry , final Object key1 , final Object key2 , final Object key3 ) {
final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 2 && MST[rv.ROR5Mutator]MSP[] ( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) &&
while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 ) ) { MST[rv.ROR4Mutator]MSP[] return true ; } entry = entry . next ; } return false ; }
h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; MST[rv.CRCR6Mutator]MSP[] return h ; }
return true ; } entry = entry . next ; } return false ; } public V put ( final K key1 , final K key2 , final K key3 , final V value ) { final int hashCode = hash ( key1 , key2 , key3 ) ; MST[NonVoidMethodCallMutator]MSP[]
final Object key1 , final Object key2 , final Object key3 , final Object key4 ) { final MultiKey < ? extends K > multi = entry . getKey () ; return multi . size () == 4 && MST[rv.CRCR1Mutator]MSP[]
if ( key2 != null ) { h ^= key2 . hashCode () ; } if ( key3 != null ) { h ^= key3 . hashCode () ; } h += ~ ( h << 9 ) ; MST[MathMutator]MSP[] h ^= h >>> 14 ;
return decorated () . mapIterator () ; } @Override protected AbstractHashedMap < MultiKey < ? extends K > , V > decorated () { return ( AbstractHashedMap < MultiKey < ? extends K > , V > ) super . decorated () ; MST[NullReturnValsMutator]MSP[] }
( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) ) { MST[InlineConstantMutator]MSP[] it . remove () ; modified = true ; } } return modified ; }
if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 ) ) { MST[rv.ROR3Mutator]MSP[] final V oldValue = entry . getValue () ; decorated () . removeMapping ( entry , index , previous ) ; return oldValue ; } previous = entry ;
h += h << 4 ; MST[rv.AOR2Mutator]MSP[] h ^= h >>> 10 ; return h ; } protected boolean isEqualKey ( final AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry , final Object key1 , final Object key2 , final Object key3 ) {
if ( key2 != null ) { h ^= key2 . hashCode () ; } if ( key3 != null ) { h ^= key3 . hashCode () ; } h += ~ ( h << 9 ) ; MST[InlineConstantMutator]MSP[] h ^= h >>> 14 ;
if ( key2 != null ) { h ^= key2 . hashCode () ; } if ( key3 != null ) { h ^= key3 . hashCode () ; } h += ~ ( h << 9 ) ; MST[rv.UOI1Mutator]MSP[] h ^= h >>> 14 ;
( key2 == null ? multi . getKey ( 1 ) == null : key2 . equals ( multi . getKey ( 1 ) ) ) ) { it . remove () ; modified = true ; } } return modified ; MST[ReturnValsMutator]MSP[] }
final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 3 && ( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) && MST[rv.ROR1Mutator]MSP[]
h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; MST[rv.AOR2Mutator]MSP[] h ^= h >>> 10 ; return h ; }
final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 2 && ( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) && MST[rv.ROR5Mutator]MSP[]
if ( key2 != null ) { h ^= key2 . hashCode () ; } if ( key3 != null ) { h ^= key3 . hashCode () ; } h += ~ ( h << 9 ) ; h ^= h >>> 14 ; MST[rv.UOI4Mutator]MSP[]
AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ index ] ; while ( entry != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 2 && ( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) && MST[NonVoidMethodCallMutator]MSP[]
protected int hash ( final Object key1 , final Object key2 ) { int h = 0 ; if ( key1 != null ) { h ^= key1 . hashCode () ; } if ( key2 != null ) { h ^= key2 . hashCode () ; MST[rv.ABSMutator]MSP[] }
protected int hash ( final Object key1 , final Object key2 , final Object key3 , final Object key4 ) { int h = 0 ; MST[rv.CRCR5Mutator]MSP[] if ( key1 != null ) { h ^= key1 . hashCode () ; } if ( key2 != null ) {
h ^= key2 . hashCode () ; } if ( key3 != null ) { h ^= key3 . hashCode () ; } if ( key4 != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] h ^= key4 . hashCode () ; } h += ~ ( h << 9 ) ;
AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ decorated () . hashIndex ( hashCode , decorated () . data . length ) ] ; while ( entry != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
h ^= h >>> 14 ; h += h << 4 ; MST[rv.UOI2Mutator]MSP[] h ^= h >>> 10 ; return h ; } protected boolean isEqualKey ( final AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry ,
entry = entry . next ; } decorated () . addMapping ( index , hashCode , new MultiKey <> ( key1 , key2 , key3 , key4 ) , value ) ; MST[rv.UOI4Mutator]MSP[] return null ; }
( key2 == multi . getKey ( 1 ) || key2 != null && key2 . equals ( multi . getKey ( 1 ) ) ) && MST[rv.CRCR2Mutator]MSP[]
decorated () . data [ decorated () . hashIndex ( hashCode , decorated () . data . length ) ] ; while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 , key4 ) ) { MST[rv.UOI3Mutator]MSP[]
for ( final MultiKey < ? extends K > key : mapToCopy . keySet () ) { checkKey ( key ) ; } super . putAll ( mapToCopy ) ; MST[VoidMethodCallMutator]MSP[] } @Override public MapIterator < MultiKey < ? extends K > , V > mapIterator () {
decorated () . data [ decorated () . hashIndex ( hashCode , decorated () . data . length ) ] ; while ( entry != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 , key4 ) ) {
h += h << 4 ; h ^= h >>> 10 ; MST[rv.UOI1Mutator]MSP[] return h ; } protected boolean isEqualKey ( final AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry , final Object key1 , final Object key2 , final Object key3 ) {
( key2 == multi . getKey ( 1 ) || key2 != null && key2 . equals ( multi . getKey ( 1 ) ) ) && MST[NonVoidMethodCallMutator]MSP[]
final int index = decorated () . hashIndex ( hashCode , decorated () . data . length ) ; MST[rv.UOI4Mutator]MSP[] AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ index ] ; while ( entry != null ) {
if ( key5 != null ) { h ^= key5 . hashCode () ; } h += ~ ( h << 9 ) ; MST[MathMutator]MSP[] h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; return h ; }
h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; MST[rv.CRCR5Mutator]MSP[] return h ; }
( key1 == multi . getKey ( 0 ) || key1 != null && key1 . equals ( multi . getKey ( 0 ) ) ) && MST[NonVoidMethodCallMutator]MSP[]
if ( key5 != null ) { h ^= key5 . hashCode () ; } h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; MST[MathMutator]MSP[] h ^= h >>> 10 ; return h ; }
if ( key2 != null ) { h ^= key2 . hashCode () ; } if ( key3 != null ) { h ^= key3 . hashCode () ; } h += ~ ( h << 9 ) ; h ^= h >>> 14 ; MST[rv.UOI1Mutator]MSP[]
h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; return h ; MST[PrimitiveReturnsMutator]MSP[] } protected boolean isEqualKey ( final AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry ,
final MapIterator < MultiKey < ? extends K > , V > it = mapIterator () ; while ( it . hasNext () ) { MST[rv.ROR5Mutator]MSP[] final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 1 &&
while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 ) ) { return true ; MST[rv.CRCR5Mutator]MSP[] } entry = entry . next ; } return false ; }
( key2 == null ? multi . getKey ( 1 ) == null : key2 . equals ( multi . getKey ( 1 ) ) ) ) { it . remove () ; modified = true ; MST[rv.CRCR6Mutator]MSP[] } } return modified ; }
entry = entry . next ; } return null ; } protected int hash ( final Object key1 , final Object key2 , final Object key3 ) { int h = 0 ; if ( key1 != null ) { h ^= key1 . hashCode () ; MST[MathMutator]MSP[] }
h += ~ ( h << 9 ) ; h ^= h >>> 14 ; MST[rv.CRCR1Mutator]MSP[] h += h << 4 ; h ^= h >>> 10 ; return h ; }
h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; return h ; MST[rv.ABSMutator]MSP[] } protected boolean isEqualKey ( final AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry ,
( key1 == multi . getKey ( 0 ) || key1 != null && key1 . equals ( multi . getKey ( 0 ) ) ) && MST[rv.CRCR2Mutator]MSP[]
( key4 == null ? multi . getKey ( 3 ) == null : key4 . equals ( multi . getKey ( 3 ) ) ) ) { it . remove () ; modified = true ; } } return modified ; MST[BooleanTrueReturnValsMutator]MSP[] }
final int index = decorated () . hashIndex ( hashCode , decorated () . data . length ) ; AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ index ] ; MST[rv.ABSMutator]MSP[]
final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 2 && MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] ( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) &&
while ( it . hasNext () ) { final MultiKey < ? extends K > multi = it . next () ; MST[NonVoidMethodCallMutator]MSP[] if ( multi . size () >= 4 &&
final int hashCode = hash ( key1 , key2 , key3 ) ; AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ decorated () . hashIndex ( hashCode , decorated () . data . length ) ] ; MST[rv.UOI1Mutator]MSP[]
final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 2 && MST[RemoveConditionalMutator_EQUAL_IF]MSP[] ( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) &&
final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 2 && MST[ConditionalsBoundaryMutator]MSP[] ( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) &&
if ( key2 != null ) { h ^= key2 . hashCode () ; } if ( key3 != null ) { h ^= key3 . hashCode () ; } if ( key4 != null ) { h ^= key4 . hashCode () ; MST[rv.UOI1Mutator]MSP[] }
final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 3 && MST[rv.CRCR6Mutator]MSP[] ( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) &&
( key3 == multi . getKey ( 2 ) || key3 != null && key3 . equals ( multi . getKey ( 2 ) ) ) && MST[rv.CRCR2Mutator]MSP[]
if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 , key4 , key5 ) ) { return true ; } entry = entry . next ; } return false ; MST[rv.CRCR5Mutator]MSP[] }
if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 , key4 ) ) { MST[rv.ROR2Mutator]MSP[] final V oldValue = entry . getValue () ; decorated () . updateEntry ( entry , value ) ; return oldValue ; }
AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > previous = null ; while ( entry != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 , key4 , key5 ) ) {
public boolean removeAll ( final Object key1 , final Object key2 , final Object key3 ) { boolean modified = false ; final MapIterator < MultiKey < ? extends K > , V > it = mapIterator () ; while ( it . hasNext () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
h += ~ ( h << 9 ) ; MST[rv.UOI2Mutator]MSP[] h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; return h ; }
if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] final V oldValue = entry . getValue () ; decorated () . removeMapping ( entry , index , previous ) ; return oldValue ; } previous = entry ;
h += ~ ( h << 9 ) ; h ^= h >>> 14 ; MST[rv.UOI1Mutator]MSP[] h += h << 4 ; h ^= h >>> 10 ; return h ; }
h += ~ ( h << 9 ) ; MST[rv.AOR4Mutator]MSP[] h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; return h ; }
while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 ) ) { MST[rv.ROR5Mutator]MSP[] return true ; } entry = entry . next ; } return false ; }
final MapIterator < MultiKey < ? extends K > , V > it = mapIterator () ; while ( it . hasNext () ) { final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 1 && MST[NonVoidMethodCallMutator]MSP[]
checkKey ( key ) ; MST[VoidMethodCallMutator]MSP[] return super . put ( key , value ) ; } @Override public void putAll ( final Map < ? extends MultiKey < ? extends K > , ? extends V > mapToCopy ) {
h ^= key2 . hashCode () ; } if ( key3 != null ) { h ^= key3 . hashCode () ; } if ( key4 != null ) { h ^= key4 . hashCode () ; MST[rv.UOI3Mutator]MSP[] } h += ~ ( h << 9 ) ;
final int index = decorated () . hashIndex ( hashCode , decorated () . data . length ) ; MST[NonVoidMethodCallMutator]MSP[] AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ index ] ;
if ( key5 != null ) { h ^= key5 . hashCode () ; } h += ~ ( h << 9 ) ; MST[rv.UOI2Mutator]MSP[] h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; return h ; }
h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; MST[rv.CRCR4Mutator]MSP[] return h ; } protected boolean isEqualKey ( final AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry ,
final int hashCode = hash ( key1 , key2 ) ; AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ decorated () . hashIndex ( hashCode , decorated () . data . length ) ] ; MST[rv.UOI2Mutator]MSP[]
final MapIterator < MultiKey < ? extends K > , V > it = mapIterator () ; MST[NonVoidMethodCallMutator]MSP[] while ( it . hasNext () ) { final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 1 &&
h += ~ ( h << 9 ) ; MST[MathMutator]MSP[] h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; return h ; }
final int hashCode = hash ( key1 , key2 , key3 ) ; AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ decorated () . hashIndex ( hashCode , decorated () . data . length ) ] ; MST[NonVoidMethodCallMutator]MSP[]
h += h << 4 ; h ^= h >>> 10 ; MST[rv.CRCR1Mutator]MSP[] return h ; } protected boolean isEqualKey ( final AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry , final Object key1 , final Object key2 , final Object key3 ) {
h ^= key2 . hashCode () ; } if ( key3 != null ) { MST[NegateConditionalsMutator]MSP[] h ^= key3 . hashCode () ; } if ( key4 != null ) { h ^= key4 . hashCode () ; } h += ~ ( h << 9 ) ;
final MapIterator < MultiKey < ? extends K > , V > it = mapIterator () ; while ( it . hasNext () ) { MST[NegateConditionalsMutator]MSP[] final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 1 &&
h ^= key2 . hashCode () ; MST[NonVoidMethodCallMutator]MSP[] } if ( key3 != null ) { h ^= key3 . hashCode () ; } if ( key4 != null ) { h ^= key4 . hashCode () ; } h += ~ ( h << 9 ) ;
( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) && MST[InlineConstantMutator]MSP[]
AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ decorated () . hashIndex ( hashCode , decorated () . data . length ) ] ; MST[rv.UOI3Mutator]MSP[] while ( entry != null ) {
( key3 == null ? multi . getKey ( 2 ) == null : key3 . equals ( multi . getKey ( 2 ) ) ) ) { MST[rv.CRCR5Mutator]MSP[] it . remove () ; modified = true ; } } return modified ; }
h ^= key2 . hashCode () ; } if ( key3 != null ) { h ^= key3 . hashCode () ; } if ( key4 != null ) { h ^= key4 . hashCode () ; } h += ~ ( h << 9 ) ; MST[rv.CRCR6Mutator]MSP[]
if ( key2 != null ) { h ^= key2 . hashCode () ; } if ( key3 != null ) { h ^= key3 . hashCode () ; } h += ~ ( h << 9 ) ; h ^= h >>> 14 ; MST[rv.CRCR5Mutator]MSP[]
( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) ) { it . remove () ; modified = true ; MST[rv.CRCR5Mutator]MSP[] } } return modified ; }
( key4 == multi . getKey ( 3 ) || key4 != null && key4 . equals ( multi . getKey ( 3 ) ) ) ; MST[InlineConstantMutator]MSP[] }
if ( key2 != null ) { h ^= key2 . hashCode () ; } if ( key3 != null ) { h ^= key3 . hashCode () ; } if ( key4 != null ) { MST[rv.ROR5Mutator]MSP[] h ^= key4 . hashCode () ; }
if ( key2 != null ) { h ^= key2 . hashCode () ; MST[rv.UOI1Mutator]MSP[] } if ( key3 != null ) { h ^= key3 . hashCode () ; } h += ~ ( h << 9 ) ; h ^= h >>> 14 ;
public boolean removeAll ( final Object key1 , final Object key2 ) { boolean modified = false ; MST[rv.CRCR6Mutator]MSP[] final MapIterator < MultiKey < ? extends K > , V > it = mapIterator () ; while ( it . hasNext () ) {
final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 2 && MST[NegateConditionalsMutator]MSP[] ( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) &&
if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 ) ) { MST[rv.UOI2Mutator]MSP[] final V oldValue = entry . getValue () ; decorated () . removeMapping ( entry , index , previous ) ; return oldValue ; } previous = entry ;
h ^= key2 . hashCode () ; } if ( key3 != null ) { h ^= key3 . hashCode () ; } if ( key4 != null ) { h ^= key4 . hashCode () ; } h += ~ ( h << 9 ) ; MST[rv.ABSMutator]MSP[]
multi . size () == 2 && MST[rv.CRCR3Mutator]MSP[] ( key1 == multi . getKey ( 0 ) || key1 != null && key1 . equals ( multi . getKey ( 0 ) ) ) &&
( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) ) { it . remove () ; modified = true ; MST[rv.CRCR2Mutator]MSP[] } } return modified ; }
while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 ) ) { MST[NegateConditionalsMutator]MSP[] return true ; } entry = entry . next ; } return false ; }
final int index = decorated () . hashIndex ( hashCode , decorated () . data . length ) ; AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ index ] ; MST[rv.UOI4Mutator]MSP[] while ( entry != null ) {
( key3 == multi . getKey ( 2 ) || key3 != null && key3 . equals ( multi . getKey ( 2 ) ) ) && MST[NegateConditionalsMutator]MSP[]
( key3 == null ? multi . getKey ( 2 ) == null : key3 . equals ( multi . getKey ( 2 ) ) ) ) { MST[rv.CRCR2Mutator]MSP[] it . remove () ; modified = true ; } } return modified ; }
final V oldValue = entry . getValue () ; decorated () . removeMapping ( entry , index , previous ) ; return oldValue ; } previous = entry ; entry = entry . next ; } return null ; MST[ReturnValsMutator]MSP[] }
h += h << 4 ; MST[rv.AOR1Mutator]MSP[] h ^= h >>> 10 ; return h ; } protected boolean isEqualKey ( final AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry , final Object key1 , final Object key2 , final Object key3 ) {
if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 ) ) { MST[rv.ROR4Mutator]MSP[] final V oldValue = entry . getValue () ; decorated () . removeMapping ( entry , index , previous ) ; return oldValue ; } previous = entry ;
final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 2 && ( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) && MST[NegateConditionalsMutator]MSP[]
multi . size () == 2 && ( key1 == multi . getKey ( 0 ) || key1 != null && key1 . equals ( multi . getKey ( 0 ) ) ) && MST[rv.CRCR3Mutator]MSP[]
AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > previous = null ; while ( entry != null ) { MST[NegateConditionalsMutator]MSP[] if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 ) ) {
if ( key5 != null ) { h ^= key5 . hashCode () ; } h += ~ ( h << 9 ) ; h ^= h >>> 14 ; MST[rv.UOI1Mutator]MSP[] h += h << 4 ; h ^= h >>> 10 ; return h ; }
final int index = decorated () . hashIndex ( hashCode , decorated () . data . length ) ; AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ index ] ; MST[rv.UOI3Mutator]MSP[]
while ( it . hasNext () ) { final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 4 && MST[rv.CRCR4Mutator]MSP[]
entry = entry . next ; } return null ; } protected int hash ( final Object key1 , final Object key2 , final Object key3 ) { int h = 0 ; MST[rv.CRCR1Mutator]MSP[] if ( key1 != null ) { h ^= key1 . hashCode () ; }
( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) ) { it . remove () ; modified = true ; } } return modified ; MST[rv.UOI4Mutator]MSP[] }
h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; return h ; MST[rv.UOI3Mutator]MSP[] }
public boolean removeAll ( final Object key1 , final Object key2 , final Object key3 ) { boolean modified = false ; final MapIterator < MultiKey < ? extends K > , V > it = mapIterator () ; while ( it . hasNext () ) { MST[rv.ROR3Mutator]MSP[]
h += h << 4 ; MST[rv.CRCR4Mutator]MSP[] h ^= h >>> 10 ; return h ; } protected boolean isEqualKey ( final AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry , final Object key1 , final Object key2 , final Object key3 ) {
( key3 == null ? multi . getKey ( 2 ) == null : key3 . equals ( multi . getKey ( 2 ) ) ) ) { it . remove () ; modified = true ; } } return modified ; MST[rv.UOI2Mutator]MSP[] }
( key2 == multi . getKey ( 1 ) || key2 != null && key2 . equals ( multi . getKey ( 1 ) ) ) && MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] it . remove () ; modified = true ; } } return modified ; }
final Object key1 , final Object key2 , final Object key3 , final Object key4 ) { final MultiKey < ? extends K > multi = entry . getKey () ; return multi . size () == 4 && MST[rv.CRCR5Mutator]MSP[]
entry = entry . next ; } decorated () . addMapping ( index , hashCode , new MultiKey <> ( key1 , key2 , key3 , key4 , key5 ) , value ) ; MST[rv.UOI4Mutator]MSP[] return null ; }
final Object key1 , final Object key2 , final Object key3 , final Object key4 ) { final MultiKey < ? extends K > multi = entry . getKey () ; return multi . size () == 4 && MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
if ( key5 != null ) { h ^= key5 . hashCode () ; } h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; MST[rv.AOR4Mutator]MSP[] h ^= h >>> 10 ; return h ; }
if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 , key4 , key5 ) ) { return entry . getValue () ; } entry = entry . next ; } return null ; MST[ReturnValsMutator]MSP[] }
while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 ) ) { MST[rv.ROR2Mutator]MSP[] return true ; } entry = entry . next ; } return false ; }
h ^= h >>> 14 ; h += h << 4 ; MST[rv.AOD2Mutator]MSP[] h ^= h >>> 10 ; return h ; } protected boolean isEqualKey ( final AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry ,
if ( key5 != null ) { h ^= key5 . hashCode () ; } h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; MST[rv.UOI1Mutator]MSP[] return h ; }
protected int hash ( final Object key1 , final Object key2 ) { int h = 0 ; if ( key1 != null ) { h ^= key1 . hashCode () ; MST[rv.ABSMutator]MSP[] } if ( key2 != null ) { h ^= key2 . hashCode () ; }
if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 , key4 ) ) { MST[NegateConditionalsMutator]MSP[] final V oldValue = entry . getValue () ; decorated () . updateEntry ( entry , value ) ; return oldValue ; }
public V put ( final K key1 , final K key2 , final K key3 , final K key4 , final K key5 , final V value ) { final int hashCode = hash ( key1 , key2 , key3 , key4 , key5 ) ; MST[NonVoidMethodCallMutator]MSP[]
AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ decorated () . hashIndex ( hashCode , decorated () . data . length ) ] ; MST[rv.ABSMutator]MSP[] while ( entry != null ) {
h += ~ ( h << 9 ) ; MST[rv.AOR1Mutator]MSP[] h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; return h ; }
if ( key2 != null ) { h ^= key2 . hashCode () ; } if ( key3 != null ) { h ^= key3 . hashCode () ; } h += ~ ( h << 9 ) ; MST[rv.UOI2Mutator]MSP[] h ^= h >>> 14 ;
h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; MST[rv.CRCR2Mutator]MSP[] return h ; }
while ( it . hasNext () ) { final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 4 && MST[rv.CRCR1Mutator]MSP[]
final MapIterator < MultiKey < ? extends K > , V > it = mapIterator () ; while ( it . hasNext () ) { MST[rv.ROR2Mutator]MSP[] final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 1 &&
multi . size () == 2 && MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] ( key1 == multi . getKey ( 0 ) || key1 != null && key1 . equals ( multi . getKey ( 0 ) ) ) &&
AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ index ] ; MST[rv.UOI3Mutator]MSP[] while ( entry != null ) {
decorated () . data [ decorated () . hashIndex ( hashCode , decorated () . data . length ) ] ; MST[ArgumentPropagationMutator]MSP[] while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 , key4 ) ) {
final int hashCode = hash ( key1 , key2 , key3 , key4 ) ; MST[NonVoidMethodCallMutator]MSP[] final int index = decorated () . hashIndex ( hashCode , decorated () . data . length ) ;
( key1 == multi . getKey ( 0 ) || key1 != null && key1 . equals ( multi . getKey ( 0 ) ) ) && MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 ) ) { return true ; MST[rv.CRCR2Mutator]MSP[] } entry = entry . next ; } return false ; }
final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 2 && ( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) && MST[rv.ROR5Mutator]MSP[]
( key3 == null ? multi . getKey ( 2 ) == null : key3 . equals ( multi . getKey ( 2 ) ) ) ) { MST[rv.ROR4Mutator]MSP[] it . remove () ; modified = true ; } } return modified ; }
multi . size () == 2 && MST[rv.ROR3Mutator]MSP[] ( key1 == multi . getKey ( 0 ) || key1 != null && key1 . equals ( multi . getKey ( 0 ) ) ) &&
while ( it . hasNext () ) { final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 4 && MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
final MultiKey < ? extends K > multi = entry . getKey () ; return multi . size () == 3 && MST[rv.CRCR3Mutator]MSP[] ( key1 == multi . getKey ( 0 ) || key1 != null && key1 . equals ( multi . getKey ( 0 ) ) ) &&
final Object key1 , final Object key2 , final Object key3 , final Object key4 ) { final MultiKey < ? extends K > multi = entry . getKey () ; return multi . size () == 4 && MST[NegateConditionalsMutator]MSP[]
( key2 == null ? multi . getKey ( 1 ) == null : key2 . equals ( multi . getKey ( 1 ) ) ) ) { MST[rv.ROR2Mutator]MSP[] it . remove () ; modified = true ; } } return modified ; }
entry = entry . next ; } decorated () . addMapping ( index , hashCode , new MultiKey <> ( key1 , key2 , key3 , key4 ) , value ) ; MST[rv.UOI1Mutator]MSP[] return null ; }
final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 3 && MST[rv.ROR5Mutator]MSP[] ( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) &&
( key2 == multi . getKey ( 1 ) || key2 != null && key2 . equals ( multi . getKey ( 1 ) ) ) && MST[rv.CRCR5Mutator]MSP[]
( key1 == multi . getKey ( 0 ) || key1 != null && key1 . equals ( multi . getKey ( 0 ) ) ) && MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
public V put ( final K key1 , final K key2 , final V value ) { final int hashCode = hash ( key1 , key2 ) ; MST[NonVoidMethodCallMutator]MSP[] final int index = decorated () . hashIndex ( hashCode , decorated () . data . length ) ;
if ( key2 != null ) { h ^= key2 . hashCode () ; } if ( key3 != null ) { h ^= key3 . hashCode () ; } h += ~ ( h << 9 ) ; MST[rv.CRCR6Mutator]MSP[] h ^= h >>> 14 ;
h += h << 4 ; MST[rv.UOI4Mutator]MSP[] h ^= h >>> 10 ; return h ; } protected boolean isEqualKey ( final AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry , final Object key1 , final Object key2 , final Object key3 ) {
( key3 == null ? multi . getKey ( 2 ) == null : key3 . equals ( multi . getKey ( 2 ) ) ) ) { MST[InlineConstantMutator]MSP[] it . remove () ; modified = true ; } } return modified ; }
AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > previous = null ; while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 , key4 ) ) { MST[rv.UOI2Mutator]MSP[]
decorated () . data [ decorated () . hashIndex ( hashCode , decorated () . data . length ) ] ; MST[rv.UOI2Mutator]MSP[] while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 , key4 ) ) {
final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 2 && ( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) && MST[rv.ROR5Mutator]MSP[]
decorated () . addMapping ( index , hashCode , new MultiKey <> ( key1 , key2 ) , value ) ; MST[rv.UOI3Mutator]MSP[] return null ; } public V removeMultiKey ( final Object key1 , final Object key2 ) { final int hashCode = hash ( key1 , key2 ) ;
entry = entry . next ; } decorated () . addMapping ( index , hashCode , new MultiKey <> ( key1 , key2 , key3 , key4 , key5 ) , value ) ; MST[NonVoidMethodCallMutator]MSP[] return null ; }
while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return true ; } entry = entry . next ; } return false ; }
final int hashCode = hash ( key1 , key2 ) ; AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ decorated () . hashIndex ( hashCode , decorated () . data . length ) ] ; MST[NonVoidMethodCallMutator]MSP[]
checkKey ( key ) ; return super . put ( key , value ) ; MST[NullReturnValsMutator]MSP[] } @Override public void putAll ( final Map < ? extends MultiKey < ? extends K > , ? extends V > mapToCopy ) {
( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) ) { it . remove () ; modified = true ; MST[InlineConstantMutator]MSP[] } } return modified ; }
decorated () . data [ decorated () . hashIndex ( hashCode , decorated () . data . length ) ] ; while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 , key4 ) ) { MST[rv.UOI2Mutator]MSP[]
if ( key5 != null ) { h ^= key5 . hashCode () ; } h += ~ ( h << 9 ) ; MST[rv.AOR3Mutator]MSP[] h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; return h ; }
h ^= h >>> 14 ; MST[MathMutator]MSP[] h += h << 4 ; h ^= h >>> 10 ; return h ; } protected boolean isEqualKey ( final AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry ,
if ( key5 != null ) { h ^= key5 . hashCode () ; } h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; MST[rv.CRCR4Mutator]MSP[] h ^= h >>> 10 ; return h ; }
protected int hash ( final Object key1 , final Object key2 ) { int h = 0 ; if ( key1 != null ) { h ^= key1 . hashCode () ; MST[rv.UOI2Mutator]MSP[] } if ( key2 != null ) { h ^= key2 . hashCode () ; }
while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 ) ) { return true ; MST[InlineConstantMutator]MSP[] } entry = entry . next ; } return false ; }
h ^= key2 . hashCode () ; } if ( key3 != null ) { h ^= key3 . hashCode () ; } if ( key4 != null ) { h ^= key4 . hashCode () ; } h += ~ ( h << 9 ) ; MST[rv.CRCR3Mutator]MSP[]
if ( key5 != null ) { h ^= key5 . hashCode () ; } h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; MST[rv.ABSMutator]MSP[] return h ; }
entry = entry . next ; } decorated () . addMapping ( index , hashCode , new MultiKey <> ( key1 , key2 , key3 , key4 ) , value ) ; MST[rv.UOI3Mutator]MSP[] return null ; }
h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; MST[MathMutator]MSP[] return h ; } protected boolean isEqualKey ( final AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry ,
while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 ) ) { MST[rv.ABSMutator]MSP[] return true ; } entry = entry . next ; } return false ; }
h += h << 4 ; MST[rv.ABSMutator]MSP[] h ^= h >>> 10 ; return h ; } protected boolean isEqualKey ( final AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry , final Object key1 , final Object key2 , final Object key3 ) {
final int index = decorated () . hashIndex ( hashCode , decorated () . data . length ) ; AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ index ] ; while ( entry != null ) { MST[rv.ROR5Mutator]MSP[]
final int index = decorated () . hashIndex ( hashCode , decorated () . data . length ) ; AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ index ] ; MST[rv.UOI4Mutator]MSP[]
h ^= key2 . hashCode () ; } if ( key3 != null ) { h ^= key3 . hashCode () ; } if ( key4 != null ) { h ^= key4 . hashCode () ; } h += ~ ( h << 9 ) ; MST[rv.AOD1Mutator]MSP[]
final int index = decorated () . hashIndex ( hashCode , decorated () . data . length ) ; AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ index ] ; while ( entry != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
public boolean removeAll ( final Object key1 , final Object key2 ) { boolean modified = false ; final MapIterator < MultiKey < ? extends K > , V > it = mapIterator () ; while ( it . hasNext () ) { MST[rv.ROR4Mutator]MSP[]
while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 ) ) { MST[rv.UOI3Mutator]MSP[] return true ; } entry = entry . next ; } return false ; }
( key3 == multi . getKey ( 2 ) || key3 != null && key3 . equals ( multi . getKey ( 2 ) ) ) && MST[rv.CRCR5Mutator]MSP[]
final int hashCode = hash ( key1 , key2 , key3 ) ; final int index = decorated () . hashIndex ( hashCode , decorated () . data . length ) ; MST[NonVoidMethodCallMutator]MSP[]
h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; MST[rv.ABSMutator]MSP[] h ^= h >>> 10 ; return h ; }
if ( key5 != null ) { h ^= key5 . hashCode () ; } h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; MST[rv.UOI4Mutator]MSP[] return h ; }
h += h << 4 ; h ^= h >>> 10 ; MST[rv.UOI2Mutator]MSP[] return h ; } protected boolean isEqualKey ( final AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry , final Object key1 , final Object key2 , final Object key3 ) {
public V put ( final K key1 , final K key2 , final V value ) { final int hashCode = hash ( key1 , key2 ) ; final int index = decorated () . hashIndex ( hashCode , decorated () . data . length ) ; MST[rv.UOI4Mutator]MSP[]
if ( key5 != null ) { h ^= key5 . hashCode () ; } h += ~ ( h << 9 ) ; MST[rv.UOI1Mutator]MSP[] h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; return h ; }
( key2 == null ? multi . getKey ( 1 ) == null : key2 . equals ( multi . getKey ( 1 ) ) ) && MST[rv.ROR5Mutator]MSP[]
AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ decorated () . hashIndex ( hashCode , decorated () . data . length ) ] ; MST[ArgumentPropagationMutator]MSP[] while ( entry != null ) {
h += ~ ( h << 9 ) ; MST[rv.UOI3Mutator]MSP[] h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; return h ; }
( key2 == null ? multi . getKey ( 1 ) == null : key2 . equals ( multi . getKey ( 1 ) ) ) ) { it . remove () ; MST[VoidMethodCallMutator]MSP[] modified = true ; } } return modified ; }
if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 ) ) { MST[rv.ROR1Mutator]MSP[] final V oldValue = entry . getValue () ; decorated () . removeMapping ( entry , index , previous ) ; return oldValue ; } previous = entry ;
if ( key5 != null ) { h ^= key5 . hashCode () ; } h += ~ ( h << 9 ) ; h ^= h >>> 14 ; MST[rv.UOI4Mutator]MSP[] h += h << 4 ; h ^= h >>> 10 ; return h ; }
( key2 == null ? multi . getKey ( 1 ) == null : key2 . equals ( multi . getKey ( 1 ) ) ) && MST[NonVoidMethodCallMutator]MSP[]
final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 3 && MST[rv.CRCR3Mutator]MSP[] ( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) &&
final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 3 && MST[RemoveConditionalMutator_EQUAL_IF]MSP[] ( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) &&
if ( key5 != null ) { h ^= key5 . hashCode () ; } h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; MST[InlineConstantMutator]MSP[] h ^= h >>> 10 ; return h ; }
( key2 == multi . getKey ( 1 ) || key2 != null && key2 . equals ( multi . getKey ( 1 ) ) ) ; MST[rv.CRCR5Mutator]MSP[] } public V get ( final Object key1 , final Object key2 , final Object key3 ) {
h += ~ ( h << 9 ) ; h ^= h >>> 14 ; MST[rv.CRCR4Mutator]MSP[] h += h << 4 ; h ^= h >>> 10 ; return h ; }
return decorated () . mapIterator () ; MST[NonVoidMethodCallMutator]MSP[] } @Override protected AbstractHashedMap < MultiKey < ? extends K > , V > decorated () { return ( AbstractHashedMap < MultiKey < ? extends K > , V > ) super . decorated () ; }
return true ; } entry = entry . next ; } return false ; MST[rv.CRCR3Mutator]MSP[] } public V put ( final K key1 , final K key2 , final K key3 , final V value ) { final int hashCode = hash ( key1 , key2 , key3 ) ;
if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 , key4 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] final V oldValue = entry . getValue () ; decorated () . updateEntry ( entry , value ) ; return oldValue ; }
AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ index ] ; while ( entry != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ index ] ; MST[rv.UOI1Mutator]MSP[] AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > previous = null ; while ( entry != null ) {
while ( it . hasNext () ) { final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 4 && MST[rv.ROR4Mutator]MSP[]
final int index = decorated () . hashIndex ( hashCode , decorated () . data . length ) ; AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ index ] ; while ( entry != null ) { MST[NegateConditionalsMutator]MSP[]
if ( key5 != null ) { h ^= key5 . hashCode () ; } h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; return h ; MST[rv.UOI2Mutator]MSP[] }
( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) ) { it . remove () ; modified = true ; } } return modified ; MST[rv.UOI1Mutator]MSP[] }
return ( MultiKeyMap < K , V > ) super . clone () ; MST[NonVoidMethodCallMutator]MSP[] } catch ( final CloneNotSupportedException e ) { throw new InternalError () ; } } @Override public V put ( final MultiKey < ? extends K > key , final V value ) {
( key3 == null ? multi . getKey ( 2 ) == null : key3 . equals ( multi . getKey ( 2 ) ) ) ) { it . remove () ; modified = true ; } } return modified ; MST[rv.ABSMutator]MSP[] }
protected int hash ( final Object key1 , final Object key2 , final Object key3 , final Object key4 , final Object key5 ) { int h = 0 ; MST[rv.CRCR3Mutator]MSP[] if ( key1 != null ) { h ^= key1 . hashCode () ; }
h += ~ ( h << 9 ) ; MST[rv.ABSMutator]MSP[] h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; return h ; }
return true ; } entry = entry . next ; } return false ; MST[BooleanTrueReturnValsMutator]MSP[] } public V put ( final K key1 , final K key2 , final K key3 , final K key4 , final V value ) {
h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; return h ; MST[ReturnValsMutator]MSP[] }
( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) ) { MST[NonVoidMethodCallMutator]MSP[] it . remove () ; modified = true ; } } return modified ; }
AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ decorated () . hashIndex ( hashCode , decorated () . data . length ) ] ; MST[rv.UOI2Mutator]MSP[] while ( entry != null ) {
h ^= key2 . hashCode () ; } if ( key3 != null ) { h ^= key3 . hashCode () ; } if ( key4 != null ) { h ^= key4 . hashCode () ; } h += ~ ( h << 9 ) ; MST[rv.UOI3Mutator]MSP[]
multi . size () == 2 && MST[rv.CRCR3Mutator]MSP[] ( key1 == multi . getKey ( 0 ) || key1 != null && key1 . equals ( multi . getKey ( 0 ) ) ) &&
entry = entry . next ; } return null ; } protected int hash ( final Object key1 , final Object key2 , final Object key3 ) { int h = 0 ; if ( key1 != null ) { h ^= key1 . hashCode () ; MST[rv.UOI4Mutator]MSP[] }
decorated () . data [ decorated () . hashIndex ( hashCode , decorated () . data . length ) ] ; while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 , key4 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
h += h << 4 ; MST[rv.AOR4Mutator]MSP[] h ^= h >>> 10 ; return h ; } protected boolean isEqualKey ( final AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry , final Object key1 , final Object key2 , final Object key3 ) {
h += ~ ( h << 9 ) ; h ^= h >>> 14 ; MST[rv.UOI2Mutator]MSP[] h += h << 4 ; h ^= h >>> 10 ; return h ; }
( key3 == multi . getKey ( 2 ) || key3 != null && key3 . equals ( multi . getKey ( 2 ) ) ) && MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
if ( key5 != null ) { h ^= key5 . hashCode () ; MST[rv.ABSMutator]MSP[] } h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; return h ; }
if ( key2 != null ) { h ^= key2 . hashCode () ; } if ( key3 != null ) { h ^= key3 . hashCode () ; } h += ~ ( h << 9 ) ; h ^= h >>> 14 ; MST[MathMutator]MSP[]
AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > previous = null ; while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 , key4 ) ) { MST[rv.ROR3Mutator]MSP[]
if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 ) ) { MST[rv.ROR3Mutator]MSP[] final V oldValue = entry . getValue () ; decorated () . removeMapping ( entry , index , previous ) ; return oldValue ; } previous = entry ;
decorated () . data [ decorated () . hashIndex ( hashCode , decorated () . data . length ) ] ; while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 , key4 ) ) { MST[rv.ROR3Mutator]MSP[]
if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 ) ) { return entry . getValue () ; } entry = entry . next ; } return null ; MST[ReturnValsMutator]MSP[] } public boolean containsKey ( final Object key1 , final Object key2 ) {
final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 2 && ( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) && MST[NegateConditionalsMutator]MSP[]
if ( key2 != null ) { h ^= key2 . hashCode () ; } if ( key3 != null ) { h ^= key3 . hashCode () ; MST[MathMutator]MSP[] } if ( key4 != null ) { h ^= key4 . hashCode () ; }
final int index = decorated () . hashIndex ( hashCode , decorated () . data . length ) ; AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ index ] ; MST[rv.ABSMutator]MSP[]
final int index = decorated () . hashIndex ( hashCode , decorated () . data . length ) ; MST[rv.UOI1Mutator]MSP[] AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ index ] ;
h ^= key2 . hashCode () ; MST[rv.UOI2Mutator]MSP[] } if ( key3 != null ) { h ^= key3 . hashCode () ; } if ( key4 != null ) { h ^= key4 . hashCode () ; } h += ~ ( h << 9 ) ;
AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ decorated () . hashIndex ( hashCode , decorated () . data . length ) ] ; MST[NonVoidMethodCallMutator]MSP[] while ( entry != null ) {
protected int hash ( final Object key1 , final Object key2 , final Object key3 , final Object key4 , final Object key5 ) { int h = 0 ; if ( key1 != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] h ^= key1 . hashCode () ; }
final int hashCode = hash ( key1 , key2 ) ; AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ decorated () . hashIndex ( hashCode , decorated () . data . length ) ] ; MST[rv.ABSMutator]MSP[]
final Object key1 , final Object key2 , final Object key3 , final Object key4 ) { final MultiKey < ? extends K > multi = entry . getKey () ; return multi . size () == 4 && MST[rv.ROR5Mutator]MSP[]
h += ~ ( h << 9 ) ; MST[rv.CRCR5Mutator]MSP[] h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; return h ; }
h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; MST[InlineConstantMutator]MSP[] return h ; }
final MapIterator < MultiKey < ? extends K > , V > it = mapIterator () ; while ( it . hasNext () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 1 &&
if ( key2 != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] h ^= key2 . hashCode () ; } if ( key3 != null ) { h ^= key3 . hashCode () ; } h += ~ ( h << 9 ) ; h ^= h >>> 14 ;
h ^= h >>> 14 ; h += h << 4 ; MST[rv.UOI3Mutator]MSP[] h ^= h >>> 10 ; return h ; } protected boolean isEqualKey ( final AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry ,
h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; MST[rv.UOI2Mutator]MSP[] return h ; }
final int hashCode = hash ( key1 , key2 , key3 ) ; AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ decorated () . hashIndex ( hashCode , decorated () . data . length ) ] ; MST[rv.UOI4Mutator]MSP[]
( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) && MST[rv.ROR4Mutator]MSP[]
if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 , key4 ) ) { MST[rv.ROR5Mutator]MSP[] final V oldValue = entry . getValue () ; decorated () . updateEntry ( entry , value ) ; return oldValue ; }
final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 2 && ( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) && MST[rv.CRCR6Mutator]MSP[]
decorated () . addMapping ( index , hashCode , new MultiKey <> ( key1 , key2 , key3 ) , value ) ; return null ; MST[ReturnValsMutator]MSP[] } public V removeMultiKey ( final Object key1 , final Object key2 , final Object key3 ) {
h ^= key2 . hashCode () ; } if ( key3 != null ) { h ^= key3 . hashCode () ; MST[MathMutator]MSP[] } if ( key4 != null ) { h ^= key4 . hashCode () ; } h += ~ ( h << 9 ) ;
final Object key1 , final Object key2 , final Object key3 , final Object key4 ) { final MultiKey < ? extends K > multi = entry . getKey () ; return multi . size () == 4 && MST[rv.CRCR5Mutator]MSP[]
if ( key2 != null ) { h ^= key2 . hashCode () ; MST[rv.UOI3Mutator]MSP[] } if ( key3 != null ) { h ^= key3 . hashCode () ; } if ( key4 != null ) { h ^= key4 . hashCode () ; }
entry = entry . next ; } return null ; } protected int hash ( final Object key1 , final Object key2 , final Object key3 ) { int h = 0 ; if ( key1 != null ) { h ^= key1 . hashCode () ; MST[rv.ABSMutator]MSP[] }
( key1 == multi . getKey ( 0 ) || key1 != null && key1 . equals ( multi . getKey ( 0 ) ) ) && MST[rv.CRCR5Mutator]MSP[]
( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) && MST[rv.CRCR5Mutator]MSP[]
AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > previous = null ; while ( entry != null ) { MST[rv.ROR5Mutator]MSP[] if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 ) ) {
if ( key2 != null ) { h ^= key2 . hashCode () ; } if ( key3 != null ) { h ^= key3 . hashCode () ; } h += ~ ( h << 9 ) ; h ^= h >>> 14 ; MST[InlineConstantMutator]MSP[]
final int index = decorated () . hashIndex ( hashCode , decorated () . data . length ) ; MST[NonVoidMethodCallMutator]MSP[] AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ index ] ;
( key2 == null ? multi . getKey ( 1 ) == null : key2 . equals ( multi . getKey ( 1 ) ) ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] it . remove () ; modified = true ; } } return modified ; }
decorated () . data [ decorated () . hashIndex ( hashCode , decorated () . data . length ) ] ; while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 , key4 ) ) { MST[rv.UOI1Mutator]MSP[]
while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return true ; } entry = entry . next ; } return false ; }
h ^= h >>> 14 ; MST[rv.CRCR2Mutator]MSP[] h += h << 4 ; h ^= h >>> 10 ; return h ; } protected boolean isEqualKey ( final AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry ,
if ( key5 != null ) { h ^= key5 . hashCode () ; } h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; MST[rv.CRCR1Mutator]MSP[] return h ; }
public boolean removeAll ( final Object key1 , final Object key2 , final Object key3 ) { boolean modified = false ; final MapIterator < MultiKey < ? extends K > , V > it = mapIterator () ; while ( it . hasNext () ) { MST[NonVoidMethodCallMutator]MSP[]
h ^= key2 . hashCode () ; } if ( key3 != null ) { h ^= key3 . hashCode () ; } if ( key4 != null ) { h ^= key4 . hashCode () ; } h += ~ ( h << 9 ) ; MST[rv.CRCR4Mutator]MSP[]
final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 3 && MST[NegateConditionalsMutator]MSP[] ( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) &&
decorated () . data [ decorated () . hashIndex ( hashCode , decorated () . data . length ) ] ; MST[rv.UOI1Mutator]MSP[] while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 , key4 ) ) {
( key2 == null ? multi . getKey ( 1 ) == null : key2 . equals ( multi . getKey ( 1 ) ) ) ) { MST[rv.ROR3Mutator]MSP[] it . remove () ; modified = true ; } } return modified ; }
final int hashCode = hash ( key1 , key2 , key3 ) ; AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ decorated () . hashIndex ( hashCode , decorated () . data . length ) ] ; MST[NonVoidMethodCallMutator]MSP[]
h += h << 4 ; MST[rv.UOI1Mutator]MSP[] h ^= h >>> 10 ; return h ; } protected boolean isEqualKey ( final AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry , final Object key1 , final Object key2 , final Object key3 ) {
( key4 == null ? multi . getKey ( 3 ) == null : key4 . equals ( multi . getKey ( 3 ) ) ) ) { it . remove () ; modified = true ; } } return modified ; MST[rv.UOI1Mutator]MSP[] }
( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) && MST[NegateConditionalsMutator]MSP[]
final int index = decorated () . hashIndex ( hashCode , decorated () . data . length ) ; MST[NonVoidMethodCallMutator]MSP[] AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ index ] ; while ( entry != null ) {
h ^= h >>> 14 ; MST[rv.UOI2Mutator]MSP[] h += h << 4 ; h ^= h >>> 10 ; return h ; } protected boolean isEqualKey ( final AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry ,
entry = entry . next ; } decorated () . addMapping ( index , hashCode , new MultiKey <> ( key1 , key2 , key3 , key4 , key5 ) , value ) ; return null ; MST[ReturnValsMutator]MSP[] }
if ( key5 != null ) { h ^= key5 . hashCode () ; } h += ~ ( h << 9 ) ; h ^= h >>> 14 ; MST[MathMutator]MSP[] h += h << 4 ; h ^= h >>> 10 ; return h ; }
AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ decorated () . hashIndex ( hashCode , decorated () . data . length ) ] ; while ( entry != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
( key4 == multi . getKey ( 3 ) || key4 != null && key4 . equals ( multi . getKey ( 3 ) ) ) ; MST[rv.CRCR4Mutator]MSP[] }
h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; MST[rv.CRCR1Mutator]MSP[] h ^= h >>> 10 ; return h ; }
h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; MST[rv.CRCR5Mutator]MSP[] h ^= h >>> 10 ; return h ; }
protected int hash ( final Object key1 , final Object key2 ) { int h = 0 ; if ( key1 != null ) { h ^= key1 . hashCode () ; } if ( key2 != null ) { h ^= key2 . hashCode () ; MST[rv.UOI2Mutator]MSP[] }
final MultiKey < ? extends K > multi = entry . getKey () ; return multi . size () == 3 && MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] ( key1 == multi . getKey ( 0 ) || key1 != null && key1 . equals ( multi . getKey ( 0 ) ) ) &&
( key2 == null ? multi . getKey ( 1 ) == null : key2 . equals ( multi . getKey ( 1 ) ) ) && MST[rv.CRCR3Mutator]MSP[]
final Object key1 , final Object key2 , final Object key3 , final Object key4 ) { final MultiKey < ? extends K > multi = entry . getKey () ; return multi . size () == 4 && MST[NonVoidMethodCallMutator]MSP[]
while ( it . hasNext () ) { final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 4 && MST[RemoveConditionalMutator_ORDER_IF]MSP[]
protected boolean isEqualKey ( final AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry , final Object key1 , final Object key2 ) { final MultiKey < ? extends K > multi = entry . getKey () ; return MST[BooleanTrueReturnValsMutator]MSP[]
final int index = decorated () . hashIndex ( hashCode , decorated () . data . length ) ; AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ index ] ; MST[rv.ABSMutator]MSP[] while ( entry != null ) {
h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; MST[rv.UOI1Mutator]MSP[] h ^= h >>> 10 ; return h ; }
entry = entry . next ; } return null ; } protected int hash ( final Object key1 , final Object key2 , final Object key3 ) { int h = 0 ; if ( key1 != null ) { MST[rv.ROR5Mutator]MSP[] h ^= key1 . hashCode () ; }
final int index = decorated () . hashIndex ( hashCode , decorated () . data . length ) ; AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ index ] ; MST[rv.UOI1Mutator]MSP[]
( key3 == multi . getKey ( 2 ) || key3 != null && key3 . equals ( multi . getKey ( 2 ) ) ) && MST[rv.CRCR2Mutator]MSP[]
final int index = decorated () . hashIndex ( hashCode , decorated () . data . length ) ; MST[NonVoidMethodCallMutator]MSP[] AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ index ] ;
if ( key5 != null ) { h ^= key5 . hashCode () ; } h += ~ ( h << 9 ) ; MST[rv.CRCR5Mutator]MSP[] h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; return h ; }
h += h << 4 ; MST[rv.AOD1Mutator]MSP[] h ^= h >>> 10 ; return h ; } protected boolean isEqualKey ( final AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry , final Object key1 , final Object key2 , final Object key3 ) {
( key3 == multi . getKey ( 2 ) || key3 != null && key3 . equals ( multi . getKey ( 2 ) ) ) && MST[rv.ROR4Mutator]MSP[]
if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 , key4 , key5 ) ) { return true ; } entry = entry . next ; } return false ; MST[BooleanTrueReturnValsMutator]MSP[] }
while ( entry != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 ) ) { return entry . getValue () ; } entry = entry . next ; } return null ; }
if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 , key4 ) ) { MST[NonVoidMethodCallMutator]MSP[] final V oldValue = entry . getValue () ; decorated () . updateEntry ( entry , value ) ; return oldValue ; }
decorated () . addMapping ( index , hashCode , new MultiKey <> ( key1 , key2 , key3 ) , value ) ; MST[VoidMethodCallMutator]MSP[] return null ; } public V removeMultiKey ( final Object key1 , final Object key2 , final Object key3 ) {
while ( entry != null ) { MST[NegateConditionalsMutator]MSP[] if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 ) ) { return true ; } entry = entry . next ; } return false ; }
AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ index ] ; MST[rv.UOI4Mutator]MSP[] while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 ) ) {
if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 , key4 ) ) { MST[rv.ROR2Mutator]MSP[] final V oldValue = entry . getValue () ; decorated () . updateEntry ( entry , value ) ; return oldValue ; }
final int index = decorated () . hashIndex ( hashCode , decorated () . data . length ) ; AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ index ] ; MST[rv.UOI1Mutator]MSP[] while ( entry != null ) {
public boolean removeAll ( final Object key1 , final Object key2 ) { boolean modified = false ; final MapIterator < MultiKey < ? extends K > , V > it = mapIterator () ; while ( it . hasNext () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
entry = entry . next ; } return null ; MST[ReturnValsMutator]MSP[] } protected int hash ( final Object key1 , final Object key2 , final Object key3 ) { int h = 0 ; if ( key1 != null ) { h ^= key1 . hashCode () ; }
decorated () . data [ decorated () . hashIndex ( hashCode , decorated () . data . length ) ] ; MST[NonVoidMethodCallMutator]MSP[] while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 , key4 ) ) {
final MapIterator < MultiKey < ? extends K > , V > it = mapIterator () ; while ( it . hasNext () ) { final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 1 && MST[InlineConstantMutator]MSP[]
final int hashCode = hash ( key1 , key2 , key3 ) ; AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ decorated () . hashIndex ( hashCode , decorated () . data . length ) ] ; MST[ArgumentPropagationMutator]MSP[]
h += h << 4 ; MST[rv.CRCR5Mutator]MSP[] h ^= h >>> 10 ; return h ; } protected boolean isEqualKey ( final AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry , final Object key1 , final Object key2 , final Object key3 ) {
if ( key5 != null ) { h ^= key5 . hashCode () ; MST[rv.UOI2Mutator]MSP[] } h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; return h ; }
h += h << 4 ; MST[rv.CRCR1Mutator]MSP[] h ^= h >>> 10 ; return h ; } protected boolean isEqualKey ( final AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry , final Object key1 , final Object key2 , final Object key3 ) {
multi . size () == 2 && MST[rv.CRCR6Mutator]MSP[] ( key1 == multi . getKey ( 0 ) || key1 != null && key1 . equals ( multi . getKey ( 0 ) ) ) &&
if ( key2 != null ) { h ^= key2 . hashCode () ; } if ( key3 != null ) { h ^= key3 . hashCode () ; } h += ~ ( h << 9 ) ; h ^= h >>> 14 ; MST[rv.CRCR4Mutator]MSP[]
h ^= h >>> 14 ; MST[rv.CRCR6Mutator]MSP[] h += h << 4 ; h ^= h >>> 10 ; return h ; } protected boolean isEqualKey ( final AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry ,
final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 3 && MST[ConditionalsBoundaryMutator]MSP[] ( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) &&
( key2 == null ? multi . getKey ( 1 ) == null : key2 . equals ( multi . getKey ( 1 ) ) ) ) { MST[NonVoidMethodCallMutator]MSP[] it . remove () ; modified = true ; } } return modified ; }
final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 3 && MST[rv.CRCR3Mutator]MSP[] ( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) &&
( key2 == null ? multi . getKey ( 1 ) == null : key2 . equals ( multi . getKey ( 1 ) ) ) && MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
final int index = decorated () . hashIndex ( hashCode , decorated () . data . length ) ; AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ index ] ; MST[rv.UOI1Mutator]MSP[] while ( entry != null ) {
entry = entry . next ; } decorated () . addMapping ( index , hashCode , new MultiKey <> ( key1 , key2 , key3 , key4 , key5 ) , value ) ; MST[rv.UOI1Mutator]MSP[] return null ; }
final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 2 && ( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) && MST[NegateConditionalsMutator]MSP[]
h ^= key2 . hashCode () ; } if ( key3 != null ) { h ^= key3 . hashCode () ; } if ( key4 != null ) { h ^= key4 . hashCode () ; } h += ~ ( h << 9 ) ; MST[rv.AOR2Mutator]MSP[]
final int index = decorated () . hashIndex ( hashCode , decorated () . data . length ) ; MST[rv.UOI2Mutator]MSP[] AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ index ] ;
h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; MST[rv.AOD1Mutator]MSP[] h ^= h >>> 10 ; return h ; }
h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; MST[rv.CRCR3Mutator]MSP[] return h ; } protected boolean isEqualKey ( final AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry ,
h ^= key2 . hashCode () ; } if ( key3 != null ) { h ^= key3 . hashCode () ; } if ( key4 != null ) { h ^= key4 . hashCode () ; } h += ~ ( h << 9 ) ; MST[rv.UOI4Mutator]MSP[]
if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 , key4 ) ) { MST[rv.UOI4Mutator]MSP[] final V oldValue = entry . getValue () ; decorated () . updateEntry ( entry , value ) ; return oldValue ; }
h ^= key2 . hashCode () ; } if ( key3 != null ) { h ^= key3 . hashCode () ; } if ( key4 != null ) { MST[rv.ROR5Mutator]MSP[] h ^= key4 . hashCode () ; } h += ~ ( h << 9 ) ;
if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 , key4 ) ) { MST[rv.UOI1Mutator]MSP[] final V oldValue = entry . getValue () ; decorated () . updateEntry ( entry , value ) ; return oldValue ; }
entry = entry . next ; } return null ; } protected int hash ( final Object key1 , final Object key2 , final Object key3 ) { int h = 0 ; MST[InlineConstantMutator]MSP[] if ( key1 != null ) { h ^= key1 . hashCode () ; }
protected int hash ( final Object key1 , final Object key2 , final Object key3 , final Object key4 ) { int h = 0 ; MST[rv.CRCR6Mutator]MSP[] if ( key1 != null ) { h ^= key1 . hashCode () ; } if ( key2 != null ) {
protected int hash ( final Object key1 , final Object key2 ) { int h = 0 ; if ( key1 != null ) { h ^= key1 . hashCode () ; } if ( key2 != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] h ^= key2 . hashCode () ; }
while ( it . hasNext () ) { MST[rv.ROR4Mutator]MSP[] final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 4 &&
public boolean removeAll ( final Object key1 , final Object key2 , final Object key3 ) { boolean modified = false ; MST[rv.CRCR1Mutator]MSP[] final MapIterator < MultiKey < ? extends K > , V > it = mapIterator () ; while ( it . hasNext () ) {
final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 3 && ( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) && MST[InlineConstantMutator]MSP[]
( key2 == null ? multi . getKey ( 1 ) == null : key2 . equals ( multi . getKey ( 1 ) ) ) && MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
if ( key2 != null ) { h ^= key2 . hashCode () ; } if ( key3 != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] h ^= key3 . hashCode () ; } h += ~ ( h << 9 ) ; h ^= h >>> 14 ;
decorated () . data [ decorated () . hashIndex ( hashCode , decorated () . data . length ) ] ; while ( entry != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 , key4 ) ) {
( key3 == null ? multi . getKey ( 2 ) == null : key3 . equals ( multi . getKey ( 2 ) ) ) ) { it . remove () ; modified = true ; MST[rv.CRCR3Mutator]MSP[] } } return modified ; }
if ( key5 != null ) { h ^= key5 . hashCode () ; } h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; MST[rv.UOI1Mutator]MSP[] h ^= h >>> 10 ; return h ; }
decorated () . addMapping ( index , hashCode , new MultiKey <> ( key1 , key2 , key3 ) , value ) ; MST[rv.UOI2Mutator]MSP[] return null ; } public V removeMultiKey ( final Object key1 , final Object key2 , final Object key3 ) {
final Object key1 , final Object key2 , final Object key3 , final Object key4 ) { final MultiKey < ? extends K > multi = entry . getKey () ; return multi . size () == 4 && MST[rv.CRCR2Mutator]MSP[]
if ( key2 != null ) { h ^= key2 . hashCode () ; } if ( key3 != null ) { MST[NegateConditionalsMutator]MSP[] h ^= key3 . hashCode () ; } if ( key4 != null ) { h ^= key4 . hashCode () ; }
AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > previous = null ; while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 , key4 ) ) { MST[rv.UOI2Mutator]MSP[]
AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ decorated () . hashIndex ( hashCode , decorated () . data . length ) ] ; MST[NonVoidMethodCallMutator]MSP[] while ( entry != null ) {
protected int hash ( final Object key1 , final Object key2 , final Object key3 , final Object key4 , final Object key5 ) { int h = 0 ; if ( key1 != null ) { h ^= key1 . hashCode () ; MST[rv.UOI3Mutator]MSP[] }
while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 ) ) { return true ; } entry = entry . next ; } return false ; MST[rv.CRCR6Mutator]MSP[] }
entry = entry . next ; } return null ; } protected int hash ( final Object key1 , final Object key2 , final Object key3 ) { int h = 0 ; if ( key1 != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] h ^= key1 . hashCode () ; }
final MultiKey < ? extends K > multi = entry . getKey () ; return multi . size () == 3 && MST[rv.ROR4Mutator]MSP[] ( key1 == multi . getKey ( 0 ) || key1 != null && key1 . equals ( multi . getKey ( 0 ) ) ) &&
final MapIterator < MultiKey < ? extends K > , V > it = mapIterator () ; while ( it . hasNext () ) { final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 1 && MST[rv.CRCR2Mutator]MSP[]
multi . size () == 2 && ( key1 == multi . getKey ( 0 ) || key1 != null && key1 . equals ( multi . getKey ( 0 ) ) ) && MST[rv.CRCR6Mutator]MSP[]
h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; return h ; MST[rv.UOI4Mutator]MSP[] } protected boolean isEqualKey ( final AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry ,
final int hashCode = hash ( key1 , key2 , key3 , key4 ) ; final int index = decorated () . hashIndex ( hashCode , decorated () . data . length ) ; MST[NonVoidMethodCallMutator]MSP[]
( key1 == multi . getKey ( 0 ) || key1 != null && key1 . equals ( multi . getKey ( 0 ) ) ) && MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) && MST[rv.CRCR6Mutator]MSP[]
if ( key2 != null ) { h ^= key2 . hashCode () ; } if ( key3 != null ) { h ^= key3 . hashCode () ; MST[rv.UOI2Mutator]MSP[] } h += ~ ( h << 9 ) ; h ^= h >>> 14 ;
h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; MST[rv.UOI3Mutator]MSP[] return h ; } protected boolean isEqualKey ( final AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry ,
if ( key2 != null ) { h ^= key2 . hashCode () ; } if ( key3 != null ) { h ^= key3 . hashCode () ; } h += ~ ( h << 9 ) ; MST[rv.CRCR2Mutator]MSP[] h ^= h >>> 14 ;
h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; MST[rv.ABSMutator]MSP[] return h ; }
h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; MST[rv.AOR1Mutator]MSP[] h ^= h >>> 10 ; return h ; }
( key3 == multi . getKey ( 2 ) || key3 != null && key3 . equals ( multi . getKey ( 2 ) ) ) && MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
return decorated () . mapIterator () ; } @Override protected AbstractHashedMap < MultiKey < ? extends K > , V > decorated () { return ( AbstractHashedMap < MultiKey < ? extends K > , V > ) super . decorated () ; MST[ReturnValsMutator]MSP[] }
final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 2 && ( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) && MST[rv.CRCR2Mutator]MSP[]
while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 ) ) { return true ; } entry = entry . next ; } return false ; MST[BooleanTrueReturnValsMutator]MSP[] }
final int index = decorated () . hashIndex ( hashCode , decorated () . data . length ) ; AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ index ] ; MST[rv.UOI4Mutator]MSP[] while ( entry != null ) {
if ( key5 != null ) { h ^= key5 . hashCode () ; } h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; MST[rv.AOR1Mutator]MSP[] h ^= h >>> 10 ; return h ; }
if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 , key4 ) ) { MST[rv.ROR5Mutator]MSP[] final V oldValue = entry . getValue () ; decorated () . updateEntry ( entry , value ) ; return oldValue ; }
if ( key2 != null ) { h ^= key2 . hashCode () ; } if ( key3 != null ) { h ^= key3 . hashCode () ; } h += ~ ( h << 9 ) ; h ^= h >>> 14 ; MST[rv.UOI4Mutator]MSP[]
if ( key2 != null ) { h ^= key2 . hashCode () ; } if ( key3 != null ) { h ^= key3 . hashCode () ; } h += ~ ( h << 9 ) ; h ^= h >>> 14 ; MST[rv.ABSMutator]MSP[]
final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 2 && MST[rv.CRCR4Mutator]MSP[] ( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) &&
( key1 == multi . getKey ( 0 ) || key1 != null && key1 . equals ( multi . getKey ( 0 ) ) ) && MST[NegateConditionalsMutator]MSP[]
return ( MultiKeyMap < K , V > ) super . clone () ; MST[NullReturnValsMutator]MSP[] } catch ( final CloneNotSupportedException e ) { throw new InternalError () ; } } @Override public V put ( final MultiKey < ? extends K > key , final V value ) {
h ^= h >>> 14 ; h += h << 4 ; MST[MathMutator]MSP[] h ^= h >>> 10 ; return h ; } protected boolean isEqualKey ( final AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry ,
final int hashCode = hash ( key1 , key2 , key3 ) ; MST[NonVoidMethodCallMutator]MSP[] final int index = decorated () . hashIndex ( hashCode , decorated () . data . length ) ;
h += h << 4 ; h ^= h >>> 10 ; MST[rv.ABSMutator]MSP[] return h ; } protected boolean isEqualKey ( final AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry , final Object key1 , final Object key2 , final Object key3 ) {
( key3 == multi . getKey ( 2 ) || key3 != null && key3 . equals ( multi . getKey ( 2 ) ) ) && MST[rv.CRCR5Mutator]MSP[]
h += ~ ( h << 9 ) ; h ^= h >>> 14 ; MST[rv.ABSMutator]MSP[] h += h << 4 ; h ^= h >>> 10 ; return h ; }
while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 ) ) { MST[rv.ROR3Mutator]MSP[] return true ; } entry = entry . next ; } return false ; }
if ( key5 != null ) { h ^= key5 . hashCode () ; } h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; MST[rv.ABSMutator]MSP[] h ^= h >>> 10 ; return h ; }
h += ~ ( h << 9 ) ; h ^= h >>> 14 ; MST[rv.UOI4Mutator]MSP[] h += h << 4 ; h ^= h >>> 10 ; return h ; }
protected int hash ( final Object key1 , final Object key2 , final Object key3 , final Object key4 ) { int h = 0 ; if ( key1 != null ) { h ^= key1 . hashCode () ; } if ( key2 != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
final int hashCode = hash ( key1 , key2 ) ; AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ decorated () . hashIndex ( hashCode , decorated () . data . length ) ] ; MST[NonVoidMethodCallMutator]MSP[]
( key3 == multi . getKey ( 2 ) || key3 != null && key3 . equals ( multi . getKey ( 2 ) ) ) && MST[rv.ROR5Mutator]MSP[]
if ( key5 != null ) { h ^= key5 . hashCode () ; } h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; MST[rv.UOI4Mutator]MSP[] h ^= h >>> 10 ; return h ; }
h += h << 4 ; MST[rv.UOI2Mutator]MSP[] h ^= h >>> 10 ; return h ; } protected boolean isEqualKey ( final AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry , final Object key1 , final Object key2 , final Object key3 ) {
h ^= key2 . hashCode () ; } if ( key3 != null ) { h ^= key3 . hashCode () ; } if ( key4 != null ) { MST[NegateConditionalsMutator]MSP[] h ^= key4 . hashCode () ; } h += ~ ( h << 9 ) ;
if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 , key4 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] final V oldValue = entry . getValue () ; decorated () . updateEntry ( entry , value ) ; return oldValue ; }
final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 3 && ( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) && MST[rv.CRCR5Mutator]MSP[]
( key4 == multi . getKey ( 3 ) || key4 != null && key4 . equals ( multi . getKey ( 3 ) ) ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] }
AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ decorated () . hashIndex ( hashCode , decorated () . data . length ) ] ; while ( entry != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 3 && ( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) && MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
final int index = decorated () . hashIndex ( hashCode , decorated () . data . length ) ; MST[rv.UOI4Mutator]MSP[] AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ index ] ;
h += ~ ( h << 9 ) ; MST[rv.CRCR2Mutator]MSP[] h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; return h ; }
if ( key5 != null ) { h ^= key5 . hashCode () ; } h += ~ ( h << 9 ) ; MST[rv.ABSMutator]MSP[] h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; return h ; }
h ^= key2 . hashCode () ; } if ( key3 != null ) { h ^= key3 . hashCode () ; MST[rv.UOI3Mutator]MSP[] } if ( key4 != null ) { h ^= key4 . hashCode () ; } h += ~ ( h << 9 ) ;
if ( key5 != null ) { h ^= key5 . hashCode () ; } h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; MST[InlineConstantMutator]MSP[] return h ; }
h += ~ ( h << 9 ) ; MST[rv.CRCR4Mutator]MSP[] h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; return h ; }
if ( key2 != null ) { h ^= key2 . hashCode () ; } if ( key3 != null ) { MST[rv.ROR5Mutator]MSP[] h ^= key3 . hashCode () ; } if ( key4 != null ) { h ^= key4 . hashCode () ; }
entry = entry . next ; } return null ; } protected int hash ( final Object key1 , final Object key2 , final Object key3 ) { int h = 0 ; if ( key1 != null ) { h ^= key1 . hashCode () ; MST[rv.UOI1Mutator]MSP[] }
h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; MST[rv.UOI2Mutator]MSP[] h ^= h >>> 10 ; return h ; }
if ( key2 != null ) { h ^= key2 . hashCode () ; } if ( key3 != null ) { h ^= key3 . hashCode () ; } if ( key4 != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] h ^= key4 . hashCode () ; }
AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > previous = null ; while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 , key4 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
if ( key2 != null ) { h ^= key2 . hashCode () ; } if ( key3 != null ) { h ^= key3 . hashCode () ; } h += ~ ( h << 9 ) ; h ^= h >>> 14 ; MST[rv.CRCR1Mutator]MSP[]
protected int hash ( final Object key1 , final Object key2 , final Object key3 , final Object key4 , final Object key5 ) { int h = 0 ; if ( key1 != null ) { h ^= key1 . hashCode () ; MST[NonVoidMethodCallMutator]MSP[] }
while ( it . hasNext () ) { final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 4 && MST[rv.ROR1Mutator]MSP[]
while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 ) ) { MST[rv.UOI2Mutator]MSP[] return true ; } entry = entry . next ; } return false ; }
( key2 == null ? multi . getKey ( 1 ) == null : key2 . equals ( multi . getKey ( 1 ) ) ) ) { MST[rv.CRCR4Mutator]MSP[] it . remove () ; modified = true ; } } return modified ; }
( key2 == null ? multi . getKey ( 1 ) == null : key2 . equals ( multi . getKey ( 1 ) ) ) && MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
final int index = decorated () . hashIndex ( hashCode , decorated () . data . length ) ; MST[rv.UOI4Mutator]MSP[] AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ index ] ; while ( entry != null ) {
AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ index ] ; MST[rv.UOI4Mutator]MSP[] AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > previous = null ; while ( entry != null ) {
multi . size () == 2 && MST[rv.CRCR6Mutator]MSP[] ( key1 == multi . getKey ( 0 ) || key1 != null && key1 . equals ( multi . getKey ( 0 ) ) ) &&
if ( key5 != null ) { h ^= key5 . hashCode () ; } h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; MST[rv.UOI2Mutator]MSP[] return h ; }
if ( key2 != null ) { h ^= key2 . hashCode () ; } if ( key3 != null ) { h ^= key3 . hashCode () ; } h += ~ ( h << 9 ) ; MST[MathMutator]MSP[] h ^= h >>> 14 ;
decorated () . data [ decorated () . hashIndex ( hashCode , decorated () . data . length ) ] ; while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 , key4 ) ) { MST[rv.ROR3Mutator]MSP[]
( key2 == null ? multi . getKey ( 1 ) == null : key2 . equals ( multi . getKey ( 1 ) ) ) && MST[rv.ROR2Mutator]MSP[]
public boolean removeAll ( final Object key1 , final Object key2 , final Object key3 ) { boolean modified = false ; MST[InlineConstantMutator]MSP[] final MapIterator < MultiKey < ? extends K > , V > it = mapIterator () ; while ( it . hasNext () ) {
decorated () . addMapping ( index , hashCode , new MultiKey <> ( key1 , key2 , key3 ) , value ) ; MST[ConstructorCallMutator]MSP[] return null ; } public V removeMultiKey ( final Object key1 , final Object key2 , final Object key3 ) {
( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) && MST[rv.CRCR2Mutator]MSP[]
entry = entry . next ; } decorated () . addMapping ( index , hashCode , new MultiKey <> ( key1 , key2 , key3 , key4 ) , value ) ; MST[VoidMethodCallMutator]MSP[] return null ; }
entry = entry . next ; } return null ; } protected int hash ( final Object key1 , final Object key2 , final Object key3 ) { int h = 0 ; MST[rv.CRCR5Mutator]MSP[] if ( key1 != null ) { h ^= key1 . hashCode () ; }
if ( key5 != null ) { h ^= key5 . hashCode () ; } h += ~ ( h << 9 ) ; h ^= h >>> 14 ; MST[rv.CRCR4Mutator]MSP[] h += h << 4 ; h ^= h >>> 10 ; return h ; }
( key2 == null ? multi . getKey ( 1 ) == null : key2 . equals ( multi . getKey ( 1 ) ) ) ) { it . remove () ; modified = true ; } } return modified ; MST[rv.UOI4Mutator]MSP[] }
h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; MST[InlineConstantMutator]MSP[] h ^= h >>> 10 ; return h ; }
AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ index ] ; MST[rv.UOI1Mutator]MSP[] while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 ) ) {
( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) ) { MST[NonVoidMethodCallMutator]MSP[] it . remove () ; modified = true ; } } return modified ; }
h ^= h >>> 14 ; MST[rv.UOI3Mutator]MSP[] h += h << 4 ; h ^= h >>> 10 ; return h ; } protected boolean isEqualKey ( final AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry ,
AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry = decorated () . data [ decorated () . hashIndex ( hashCode , decorated () . data . length ) ] ; MST[rv.UOI4Mutator]MSP[] while ( entry != null ) {
decorated () . data [ decorated () . hashIndex ( hashCode , decorated () . data . length ) ] ; MST[NonVoidMethodCallMutator]MSP[] while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 , key4 ) ) {
decorated () . data [ decorated () . hashIndex ( hashCode , decorated () . data . length ) ] ; MST[rv.ABSMutator]MSP[] while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 , key4 ) ) {
if ( key2 != null ) { h ^= key2 . hashCode () ; } if ( key3 != null ) { h ^= key3 . hashCode () ; MST[rv.UOI4Mutator]MSP[] } if ( key4 != null ) { h ^= key4 . hashCode () ; }
( key1 == null ? multi . getKey ( 0 ) == null : key1 . equals ( multi . getKey ( 0 ) ) ) && MST[rv.ROR1Mutator]MSP[]
AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > previous = null ; while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 , key4 ) ) { MST[rv.ROR3Mutator]MSP[]
decorated () . addMapping ( index , hashCode , new MultiKey <> ( key1 , key2 , key3 ) , value ) ; MST[rv.UOI3Mutator]MSP[] return null ; } public V removeMultiKey ( final Object key1 , final Object key2 , final Object key3 ) {
if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 ) ) { MST[rv.ABSMutator]MSP[] final V oldValue = entry . getValue () ; decorated () . removeMapping ( entry , index , previous ) ; return oldValue ; } previous = entry ;
decorated () . data [ decorated () . hashIndex ( hashCode , decorated () . data . length ) ] ; while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 , key4 ) ) { MST[rv.ABSMutator]MSP[]
decorated () . data [ decorated () . hashIndex ( hashCode , decorated () . data . length ) ] ; MST[NonVoidMethodCallMutator]MSP[] while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( entry , key1 , key2 , key3 ) ) {
( key1 == multi . getKey ( 0 ) || key1 != null && key1 . equals ( multi . getKey ( 0 ) ) ) && MST[rv.CRCR5Mutator]MSP[]
final MapIterator < MultiKey < ? extends K > , V > it = mapIterator () ; while ( it . hasNext () ) { final MultiKey < ? extends K > multi = it . next () ; if ( multi . size () >= 1 && MST[rv.CRCR5Mutator]MSP[]
( key2 == multi . getKey ( 1 ) || key2 != null && key2 . equals ( multi . getKey ( 1 ) ) ) ; MST[InlineConstantMutator]MSP[] } public V get ( final Object key1 , final Object key2 , final Object key3 ) {
( key1 == multi . getKey ( 0 ) || key1 != null && key1 . equals ( multi . getKey ( 0 ) ) ) && MST[rv.ROR5Mutator]MSP[]
h += h << 4 ; MST[InlineConstantMutator]MSP[] h ^= h >>> 10 ; return h ; } protected boolean isEqualKey ( final AbstractHashedMap . HashEntry < MultiKey < ? extends K > , V > entry , final Object key1 , final Object key2 , final Object key3 ) {
final Object key1 , final Object key2 , final Object key3 , final Object key4 ) { final MultiKey < ? extends K > multi = entry . getKey () ; return multi . size () == 4 && MST[rv.ROR2Mutator]MSP[]
h ^= key2 . hashCode () ; } if ( key3 != null ) { h ^= key3 . hashCode () ; } if ( key4 != null ) { h ^= key4 . hashCode () ; } h += ~ ( h << 9 ) ; MST[rv.CRCR2Mutator]MSP[]
if ( key5 != null ) { h ^= key5 . hashCode () ; } h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; MST[rv.CRCR1Mutator]MSP[] h ^= h >>> 10 ; return h ; }
