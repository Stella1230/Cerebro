for ( final Collection < E > item : all ) { for ( final E e : item ) { result [ offset ++ ] = e ; } } if ( result . length > size ) { MST[rv.UOI2Mutator]MSP[N] result [ size ] = null ; }
for ( final Collection < E > item : all ) { changed |= item . retainAll ( coll ) ; } return changed ; MST[rv.UOI4Mutator]MSP[S] } @Override public void clear () { for ( final Collection < E > coll : all ) { coll . clear () ; }
result [ i ] = it . next () ; } return result ; } @Override @SuppressWarnings ( lr_1 ) public < T > T [] toArray ( final T [] array ) { final int size = size () ; MST[NonVoidMethodCallMutator]MSP[N] Object [] result = null ;
public boolean removeIf ( final Predicate < ? super E > filter ) { if ( Objects . isNull ( filter ) ) { MST[NonVoidMethodCallMutator]MSP[N] return false ; } boolean changed = false ; for ( final Collection < E > item : all ) {
for ( final Collection < E > item : all ) { changed |= item . retainAll ( coll ) ; MST[rv.UOI1Mutator]MSP[N] } return changed ; } @Override public void clear () { for ( final Collection < E > coll : all ) { coll . clear () ; }
if ( array . length >= size ) { MST[rv.ROR2Mutator]MSP[N] result = array ; } else { result = ( Object [] ) Array . newInstance ( array . getClass () . getComponentType () , size ) ; } int offset = 0 ;
public boolean containsAll ( final Collection < ? > coll ) { if ( coll == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return false ; } for ( final Object item : coll ) { if ( contains ( item ) == false ) { return false ; } } return true ;
for ( final Collection < E > item : all ) { for ( final E e : item ) { result [ offset ++ ] = e ; MST[rv.UOI2Mutator]MSP[S] } } if ( result . length > size ) { result [ size ] = null ; }
public boolean remove ( final Object obj ) { for ( final Set < E > set : getSets () ) { if ( set . contains ( obj ) ) { MST[rv.ROR1Mutator]MSP[N] return set . remove ( obj ) ; } } return false ; } @Override
throw new UnsupportedOperationException ( lr_4 ) ; } getMutator () . resolveCollision ( this , existingSet , set , intersects ) ; if ( CollectionUtils . intersection ( existingSet , set ) . size () > 0 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] throw new IllegalArgumentException ( lr_5 ) ; } } }
public boolean remove ( final Object obj ) { for ( final Set < E > set : getSets () ) { if ( set . contains ( obj ) ) { MST[rv.ROR5Mutator]MSP[N] return set . remove ( obj ) ; } } return false ; } @Override
public boolean containsAll ( final Collection < ? > coll ) { if ( coll == null ) { MST[rv.ROR5Mutator]MSP[N] return false ; } for ( final Object item : coll ) { if ( contains ( item ) == false ) { return false ; } } return true ;
public boolean containsAll ( final Collection < ? > coll ) { if ( coll == null ) { return false ; } for ( final Object item : coll ) { if ( contains ( item ) == false ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] return false ; } } return true ;
for ( final E e : this ) { code += e == null ? 0 : e . hashCode () ; MST[MathMutator]MSP[N] } return code ; }
if ( array . length >= size ) { result = array ; } else { result = ( Object [] ) Array . newInstance ( array . getClass () . getComponentType () , size ) ; } int offset = 0 ; MST[rv.CRCR6Mutator]MSP[N]
@Override public int size () { int size = 0 ; for ( final Set < E > item : all ) { size += item . size () ; MST[rv.UOI1Mutator]MSP[N] } return size ; } @Override public boolean isEmpty () {
throw new UnsupportedOperationException ( lr_4 ) ; } getMutator () . resolveCollision ( this , existingSet , set , intersects ) ; if ( CollectionUtils . intersection ( existingSet , set ) . size () > 0 ) { MST[NonVoidMethodCallMutator]MSP[S] throw new IllegalArgumentException ( lr_5 ) ; } } }
for ( final Collection < E > item : all ) { for ( final E e : item ) { result [ offset ++ ] = e ; } } if ( result . length > size ) { MST[rv.ABSMutator]MSP[S] result [ size ] = null ; }
return ( T [] ) result ; MST[ReturnValsMutator]MSP[N] } @Override public boolean add ( final E obj ) { if ( mutator == null ) { throw new UnsupportedOperationException ( lr_2 ) ; } return mutator . add ( this , all , obj ) ; } @Override
for ( final Set < E > item : all ) { if ( item . isEmpty () == false ) { MST[rv.ROR4Mutator]MSP[N] return false ; } } return true ; } @Override public boolean contains ( final Object obj ) {
for ( final E e : this ) { code += e == null ? 0 : e . hashCode () ; MST[rv.AOR4Mutator]MSP[N] } return code ; }
final Set < ? > set = ( Set < ? > ) obj ; return set . size () == this . size () && set . containsAll ( this ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] } return false ; } @Override public int hashCode () { int code = 0 ;
final Set < ? > set = ( Set < ? > ) obj ; return set . size () == this . size () && set . containsAll ( this ) ; MST[NegateConditionalsMutator]MSP[N] } return false ; } @Override public int hashCode () { int code = 0 ;
return UnmodifiableList . unmodifiableList ( all ) ; } protected SetMutator < E > getMutator () { return mutator ; } @Override public boolean equals ( final Object obj ) { if ( obj instanceof Set ) { MST[rv.ROR2Mutator]MSP[N]
for ( final Set < E > existingSet : getSets () ) { final Collection < E > intersects = CollectionUtils . intersection ( existingSet , set ) ; if ( intersects . size () > 0 ) { MST[NegateConditionalsMutator]MSP[N] if ( this . mutator == null ) {
public boolean containsAll ( final Collection < ? > coll ) { if ( coll == null ) { return false ; } for ( final Object item : coll ) { if ( contains ( item ) == false ) { return false ; } } return true ; MST[ReturnValsMutator]MSP[N]
final Set < ? > set = ( Set < ? > ) obj ; return set . size () == this . size () && set . containsAll ( this ) ; MST[rv.CRCR6Mutator]MSP[N] } return false ; } @Override public int hashCode () { int code = 0 ;
for ( final Collection < E > item : all ) { changed |= item . retainAll ( coll ) ; } return changed ; } @Override public void clear () { for ( final Collection < E > coll : all ) { coll . clear () ; MST[VoidMethodCallMutator]MSP[S] }
public void addComposited ( final Set < E > ... sets ) { if ( sets != null ) { for ( final Set < E > set : sets ) { MST[rv.UOI2Mutator]MSP[N] addComposited ( set ) ; } } }
for ( final Collection < E > item : all ) { for ( final E e : item ) { result [ offset ++ ] = e ; MST[rv.ABSMutator]MSP[N] } } if ( result . length > size ) { result [ size ] = null ; }
public boolean containsAll ( final Collection < ? > coll ) { if ( coll == null ) { return false ; MST[rv.CRCR1Mutator]MSP[S] } for ( final Object item : coll ) { if ( contains ( item ) == false ) { return false ; } } return true ;
public boolean containsAll ( final Collection < ? > coll ) { if ( coll == null ) { return false ; } for ( final Object item : coll ) { if ( contains ( item ) == false ) { MST[rv.ROR3Mutator]MSP[N] return false ; } } return true ;
throw new UnsupportedOperationException ( lr_4 ) ; } getMutator () . resolveCollision ( this , existingSet , set , intersects ) ; if ( CollectionUtils . intersection ( existingSet , set ) . size () > 0 ) { MST[ConditionalsBoundaryMutator]MSP[N] throw new IllegalArgumentException ( lr_5 ) ; } } }
public boolean removeIf ( final Predicate < ? super E > filter ) { if ( Objects . isNull ( filter ) ) { return false ; } boolean changed = false ; MST[rv.CRCR5Mutator]MSP[N] for ( final Collection < E > item : all ) {
final Set < ? > set = ( Set < ? > ) obj ; return set . size () == this . size () && set . containsAll ( this ) ; MST[InlineConstantMutator]MSP[N] } return false ; } @Override public int hashCode () { int code = 0 ;
final Set < ? > set = ( Set < ? > ) obj ; return set . size () == this . size () && set . containsAll ( this ) ; MST[rv.ROR2Mutator]MSP[N] } return false ; } @Override public int hashCode () { int code = 0 ;
public boolean containsAll ( final Collection < ? > coll ) { if ( coll == null ) { return false ; MST[rv.CRCR5Mutator]MSP[S] } for ( final Object item : coll ) { if ( contains ( item ) == false ) { return false ; } } return true ;
for ( final Set < E > existingSet : getSets () ) { final Collection < E > intersects = CollectionUtils . intersection ( existingSet , set ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( intersects . size () > 0 ) { if ( this . mutator == null ) {
for ( final E e : this ) { code += e == null ? 0 : e . hashCode () ; MST[NonVoidMethodCallMutator]MSP[N] } return code ; }
final Set < ? > set = ( Set < ? > ) obj ; return set . size () == this . size () && set . containsAll ( this ) ; MST[rv.ROR1Mutator]MSP[S] } return false ; } @Override public int hashCode () { int code = 0 ;
final Set < ? > set = ( Set < ? > ) obj ; return set . size () == this . size () && set . containsAll ( this ) ; MST[rv.ROR5Mutator]MSP[N] } return false ; } @Override public int hashCode () { int code = 0 ;
for ( final E e : this ) { code += e == null ? 0 : e . hashCode () ; } return code ; MST[rv.UOI1Mutator]MSP[N] }
return ( T [] ) result ; } @Override public boolean add ( final E obj ) { if ( mutator == null ) { throw new UnsupportedOperationException ( lr_2 ) ; } return mutator . add ( this , all , obj ) ; MST[BooleanFalseReturnValsMutator]MSP[S] } @Override
result [ i ] = it . next () ; MST[rv.UOI4Mutator]MSP[N] } return result ; } @Override @SuppressWarnings ( lr_1 ) public < T > T [] toArray ( final T [] array ) { final int size = size () ; Object [] result = null ;
if ( array . length >= size ) { result = array ; } else { result = ( Object [] ) Array . newInstance ( array . getClass () . getComponentType () , size ) ; } int offset = 0 ; MST[InlineConstantMutator]MSP[N]
public boolean removeIf ( final Predicate < ? super E > filter ) { if ( Objects . isNull ( filter ) ) { return false ; } boolean changed = false ; MST[rv.CRCR1Mutator]MSP[N] for ( final Collection < E > item : all ) {
public boolean containsAll ( final Collection < ? > coll ) { if ( coll == null ) { return false ; } for ( final Object item : coll ) { if ( contains ( item ) == false ) { return false ; MST[BooleanTrueReturnValsMutator]MSP[S] } } return true ;
throw new UnsupportedOperationException ( lr_4 ) ; } getMutator () . resolveCollision ( this , existingSet , set , intersects ) ; if ( CollectionUtils . intersection ( existingSet , set ) . size () > 0 ) { MST[rv.ROR4Mutator]MSP[N] throw new IllegalArgumentException ( lr_5 ) ; } } }
public Object [] toArray () { final Object [] result = new Object [ size () ] ; int i = 0 ; for ( final Iterator < E > it = iterator () ; it . hasNext () ; i ++ ) { MST[NonVoidMethodCallMutator]MSP[N]
public boolean remove ( final Object obj ) { for ( final Set < E > set : getSets () ) { if ( set . contains ( obj ) ) { return set . remove ( obj ) ; MST[ReturnValsMutator]MSP[S] } } return false ; } @Override
final Set < ? > set = ( Set < ? > ) obj ; return set . size () == this . size () && set . containsAll ( this ) ; MST[BooleanTrueReturnValsMutator]MSP[N] } return false ; } @Override public int hashCode () { int code = 0 ;
public boolean containsAll ( final Collection < ? > coll ) { if ( coll == null ) { return false ; } for ( final Object item : coll ) { if ( contains ( item ) == false ) { return false ; } } return true ; MST[rv.CRCR5Mutator]MSP[N]
} @Override public boolean addAll ( final Collection < ? extends E > coll ) { if ( mutator == null ) { MST[NegateConditionalsMutator]MSP[N] throw new UnsupportedOperationException ( lr_3 ) ; } return mutator . addAll ( this , all , coll ) ; } @Override
final Set < ? > set = ( Set < ? > ) obj ; return set . size () == this . size () && set . containsAll ( this ) ; } return false ; } @Override public int hashCode () { int code = 0 ; MST[rv.CRCR5Mutator]MSP[N]
throw new UnsupportedOperationException ( lr_4 ) ; } getMutator () . resolveCollision ( this , existingSet , set , intersects ) ; if ( CollectionUtils . intersection ( existingSet , set ) . size () > 0 ) { MST[NonVoidMethodCallMutator]MSP[S] throw new IllegalArgumentException ( lr_5 ) ; } } }
for ( final Collection < E > item : all ) { for ( final E e : item ) { result [ offset ++ ] = e ; } } if ( result . length > size ) { MST[rv.ROR3Mutator]MSP[S] result [ size ] = null ; }
public boolean remove ( final Object obj ) { for ( final Set < E > set : getSets () ) { if ( set . contains ( obj ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return set . remove ( obj ) ; } } return false ; } @Override
for ( final Set < E > existingSet : getSets () ) { final Collection < E > intersects = CollectionUtils . intersection ( existingSet , set ) ; if ( intersects . size () > 0 ) { MST[rv.ROR5Mutator]MSP[N] if ( this . mutator == null ) {
public void addComposited ( final Set < E > ... sets ) { if ( sets != null ) { for ( final Set < E > set : sets ) { MST[rv.UOI3Mutator]MSP[N] addComposited ( set ) ; } } }
public void addComposited ( final Set < E > ... sets ) { if ( sets != null ) { for ( final Set < E > set : sets ) { MST[rv.UOI2Mutator]MSP[S] addComposited ( set ) ; } } }
for ( final Collection < E > item : all ) { changed |= item . retainAll ( coll ) ; } return changed ; MST[BooleanFalseReturnValsMutator]MSP[S] } @Override public void clear () { for ( final Collection < E > coll : all ) { coll . clear () ; }
for ( final Set < E > existingSet : getSets () ) { MST[NonVoidMethodCallMutator]MSP[N] final Collection < E > intersects = CollectionUtils . intersection ( existingSet , set ) ; if ( intersects . size () > 0 ) { if ( this . mutator == null ) {
changed |= item . removeIf ( filter ) ; MST[rv.UOI1Mutator]MSP[N] } return changed ; } @Override public boolean removeAll ( final Collection < ? > coll ) { if ( CollectionUtils . isEmpty ( coll ) ) { return false ; } boolean changed = false ;
for ( final Set < E > item : all ) { if ( item . contains ( obj ) ) { return true ; } } return false ; MST[rv.CRCR3Mutator]MSP[N] } @Override public Iterator < E > iterator () { if ( all . isEmpty () ) {
for ( final Collection < E > item : all ) { changed |= item . removeAll ( coll ) ; } return changed ; MST[BooleanTrueReturnValsMutator]MSP[S] } @Override public boolean retainAll ( final Collection < ? > coll ) { boolean changed = false ;
for ( final E e : this ) { code += e == null ? 0 : e . hashCode () ; MST[rv.CRCR1Mutator]MSP[N] } return code ; }
public boolean removeIf ( final Predicate < ? super E > filter ) { if ( Objects . isNull ( filter ) ) { return false ; MST[rv.CRCR3Mutator]MSP[S] } boolean changed = false ; for ( final Collection < E > item : all ) {
for ( final Set < E > item : all ) { if ( item . contains ( obj ) ) { return true ; } } return false ; MST[BooleanTrueReturnValsMutator]MSP[N] } @Override public Iterator < E > iterator () { if ( all . isEmpty () ) {
public void removeComposited ( final Set < E > set ) { all . remove ( set ) ; } public Set < E > toSet () { return new HashSet <> ( this ) ; MST[ReturnValsMutator]MSP[S] } public List < Set < E > > getSets () {
public boolean removeIf ( final Predicate < ? super E > filter ) { if ( Objects . isNull ( filter ) ) { MST[rv.ROR3Mutator]MSP[S] return false ; } boolean changed = false ; for ( final Collection < E > item : all ) {
public Object [] toArray () { final Object [] result = new Object [ size () ] ; int i = 0 ; for ( final Iterator < E > it = iterator () ; it . hasNext () ; i ++ ) { MST[IncrementsMutator]MSP[N]
@Override public int size () { int size = 0 ; for ( final Set < E > item : all ) { size += item . size () ; } return size ; MST[rv.UOI3Mutator]MSP[N] } @Override public boolean isEmpty () {
changed |= item . removeIf ( filter ) ; } return changed ; MST[BooleanFalseReturnValsMutator]MSP[S] } @Override public boolean removeAll ( final Collection < ? > coll ) { if ( CollectionUtils . isEmpty ( coll ) ) { return false ; } boolean changed = false ;
for ( final Collection < E > item : all ) { changed |= item . removeAll ( coll ) ; MST[rv.UOI4Mutator]MSP[S] } return changed ; } @Override public boolean retainAll ( final Collection < ? > coll ) { boolean changed = false ;
public void addComposited ( final Set < E > ... sets ) { if ( sets != null ) { MST[NegateConditionalsMutator]MSP[N] for ( final Set < E > set : sets ) { addComposited ( set ) ; } } }
@Override public int size () { int size = 0 ; MST[rv.CRCR5Mutator]MSP[N] for ( final Set < E > item : all ) { size += item . size () ; } return size ; } @Override public boolean isEmpty () {
for ( final Set < E > existingSet : getSets () ) { final Collection < E > intersects = CollectionUtils . intersection ( existingSet , set ) ; if ( intersects . size () > 0 ) { MST[ConditionalsBoundaryMutator]MSP[N] if ( this . mutator == null ) {
for ( final Set < E > item : all ) { if ( item . contains ( obj ) ) { MST[rv.ROR2Mutator]MSP[N] return true ; } } return false ; } @Override public Iterator < E > iterator () { if ( all . isEmpty () ) {
changed |= item . removeIf ( filter ) ; MST[NonVoidMethodCallMutator]MSP[S] } return changed ; } @Override public boolean removeAll ( final Collection < ? > coll ) { if ( CollectionUtils . isEmpty ( coll ) ) { return false ; } boolean changed = false ;
changed |= item . removeIf ( filter ) ; } return changed ; } @Override public boolean removeAll ( final Collection < ? > coll ) { if ( CollectionUtils . isEmpty ( coll ) ) { return false ; MST[rv.CRCR6Mutator]MSP[N] } boolean changed = false ;
return UnmodifiableList . unmodifiableList ( all ) ; MST[NonVoidMethodCallMutator]MSP[N] } protected SetMutator < E > getMutator () { return mutator ; } @Override public boolean equals ( final Object obj ) { if ( obj instanceof Set ) {
for ( final Collection < E > item : all ) { for ( final E e : item ) { result [ offset ++ ] = e ; MST[experimental.RemoveIncrementsMutator]MSP[S] } } if ( result . length > size ) { result [ size ] = null ; }
for ( final Collection < E > item : all ) { changed |= item . removeAll ( coll ) ; } return changed ; MST[BooleanFalseReturnValsMutator]MSP[N] } @Override public boolean retainAll ( final Collection < ? > coll ) { boolean changed = false ;
for ( final Set < E > item : all ) { if ( item . isEmpty () == false ) { return false ; } } return true ; MST[InlineConstantMutator]MSP[N] } @Override public boolean contains ( final Object obj ) {
public void addComposited ( final Set < E > ... sets ) { if ( sets != null ) { for ( final Set < E > set : sets ) { MST[rv.ABSMutator]MSP[N] addComposited ( set ) ; } } }
for ( final Set < E > item : all ) { if ( item . contains ( obj ) ) { return true ; MST[ReturnValsMutator]MSP[N] } } return false ; } @Override public Iterator < E > iterator () { if ( all . isEmpty () ) {
final Set < ? > set = ( Set < ? > ) obj ; return set . size () == this . size () && set . containsAll ( this ) ; MST[rv.ROR4Mutator]MSP[N] } return false ; } @Override public int hashCode () { int code = 0 ;
for ( final Collection < E > item : all ) { for ( final E e : item ) { result [ offset ++ ] = e ; } } if ( result . length > size ) { MST[ConditionalsBoundaryMutator]MSP[N] result [ size ] = null ; }
public Object [] toArray () { final Object [] result = new Object [ size () ] ; int i = 0 ; for ( final Iterator < E > it = iterator () ; it . hasNext () ; i ++ ) { MST[rv.ROR3Mutator]MSP[N]
changed |= item . removeIf ( filter ) ; } return changed ; } @Override public boolean removeAll ( final Collection < ? > coll ) { if ( CollectionUtils . isEmpty ( coll ) ) { return false ; MST[InlineConstantMutator]MSP[N] } boolean changed = false ;
if ( array . length >= size ) { MST[rv.UOI4Mutator]MSP[N] result = array ; } else { result = ( Object [] ) Array . newInstance ( array . getClass () . getComponentType () , size ) ; } int offset = 0 ;
@Override public int size () { int size = 0 ; for ( final Set < E > item : all ) { size += item . size () ; MST[rv.AOR2Mutator]MSP[N] } return size ; } @Override public boolean isEmpty () {
public Object [] toArray () { final Object [] result = new Object [ size () ] ; int i = 0 ; MST[rv.CRCR1Mutator]MSP[N] for ( final Iterator < E > it = iterator () ; it . hasNext () ; i ++ ) {
if ( array . length >= size ) { MST[rv.UOI1Mutator]MSP[S] result = array ; } else { result = ( Object [] ) Array . newInstance ( array . getClass () . getComponentType () , size ) ; } int offset = 0 ;
for ( final Set < E > item : all ) { if ( item . contains ( obj ) ) { return true ; } } return false ; } @Override public Iterator < E > iterator () { if ( all . isEmpty () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
public boolean removeIf ( final Predicate < ? super E > filter ) { if ( Objects . isNull ( filter ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return false ; } boolean changed = false ; for ( final Collection < E > item : all ) {
for ( final Set < E > item : all ) { if ( item . contains ( obj ) ) { return true ; } } return false ; } @Override public Iterator < E > iterator () { if ( all . isEmpty () ) { MST[rv.ROR3Mutator]MSP[N]
for ( final Set < E > item : all ) { if ( item . contains ( obj ) ) { return true ; MST[rv.CRCR5Mutator]MSP[N] } } return false ; } @Override public Iterator < E > iterator () { if ( all . isEmpty () ) {
} @Override public boolean addAll ( final Collection < ? extends E > coll ) { if ( mutator == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] throw new UnsupportedOperationException ( lr_3 ) ; } return mutator . addAll ( this , all , coll ) ; } @Override
for ( final Set < E > item : all ) { if ( item . isEmpty () == false ) { return false ; MST[rv.CRCR3Mutator]MSP[N] } } return true ; } @Override public boolean contains ( final Object obj ) {
for ( final Set < E > item : all ) { if ( item . contains ( obj ) ) { MST[rv.ROR5Mutator]MSP[N] return true ; } } return false ; } @Override public Iterator < E > iterator () { if ( all . isEmpty () ) {
public boolean containsAll ( final Collection < ? > coll ) { if ( coll == null ) { MST[NegateConditionalsMutator]MSP[N] return false ; } for ( final Object item : coll ) { if ( contains ( item ) == false ) { return false ; } } return true ;
for ( final Collection < E > item : all ) { changed |= item . removeAll ( coll ) ; } return changed ; MST[rv.UOI3Mutator]MSP[N] } @Override public boolean retainAll ( final Collection < ? > coll ) { boolean changed = false ;
for ( final Set < E > item : all ) { if ( item . isEmpty () == false ) { return false ; } } return true ; MST[rv.CRCR6Mutator]MSP[N] } @Override public boolean contains ( final Object obj ) {
changed |= item . removeIf ( filter ) ; } return changed ; } @Override public boolean removeAll ( final Collection < ? > coll ) { if ( CollectionUtils . isEmpty ( coll ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] return false ; } boolean changed = false ;
public Object [] toArray () { final Object [] result = new Object [ size () ] ; int i = 0 ; for ( final Iterator < E > it = iterator () ; it . hasNext () ; i ++ ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
changed |= item . removeIf ( filter ) ; } return changed ; } @Override public boolean removeAll ( final Collection < ? > coll ) { if ( CollectionUtils . isEmpty ( coll ) ) { return false ; MST[rv.CRCR3Mutator]MSP[N] } boolean changed = false ;
for ( final E e : this ) { code += e == null ? 0 : e . hashCode () ; } return code ; MST[PrimitiveReturnsMutator]MSP[N] }
throw new UnsupportedOperationException ( lr_4 ) ; } getMutator () . resolveCollision ( this , existingSet , set , intersects ) ; if ( CollectionUtils . intersection ( existingSet , set ) . size () > 0 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[S] throw new IllegalArgumentException ( lr_5 ) ; } } }
final Set < ? > set = ( Set < ? > ) obj ; return set . size () == this . size () && set . containsAll ( this ) ; MST[rv.CRCR5Mutator]MSP[N] } return false ; } @Override public int hashCode () { int code = 0 ;
return ( T [] ) result ; } @Override public boolean add ( final E obj ) { if ( mutator == null ) { MST[NegateConditionalsMutator]MSP[N] throw new UnsupportedOperationException ( lr_2 ) ; } return mutator . add ( this , all , obj ) ; } @Override
for ( final Set < E > item : all ) { if ( item . isEmpty () == false ) { MST[rv.ROR3Mutator]MSP[N] return false ; } } return true ; } @Override public boolean contains ( final Object obj ) {
for ( final E e : this ) { code += e == null ? 0 : e . hashCode () ; MST[rv.AOD2Mutator]MSP[N] } return code ; }
public void addComposited ( final Set < E > ... sets ) { if ( sets != null ) { for ( final Set < E > set : sets ) { MST[rv.ABSMutator]MSP[N] addComposited ( set ) ; } } }
changed |= item . removeIf ( filter ) ; } return changed ; } @Override public boolean removeAll ( final Collection < ? > coll ) { if ( CollectionUtils . isEmpty ( coll ) ) { MST[rv.ROR3Mutator]MSP[N] return false ; } boolean changed = false ;
for ( final Collection < E > item : all ) { changed |= item . removeAll ( coll ) ; } return changed ; } @Override public boolean retainAll ( final Collection < ? > coll ) { boolean changed = false ; MST[rv.CRCR5Mutator]MSP[N]
for ( final Collection < E > item : all ) { changed |= item . retainAll ( coll ) ; } return changed ; MST[rv.UOI1Mutator]MSP[N] } @Override public void clear () { for ( final Collection < E > coll : all ) { coll . clear () ; }
public Object [] toArray () { final Object [] result = new Object [ size () ] ; int i = 0 ; for ( final Iterator < E > it = iterator () ; it . hasNext () ; i ++ ) { MST[NonVoidMethodCallMutator]MSP[N]
for ( final Collection < E > item : all ) { for ( final E e : item ) { result [ offset ++ ] = e ; } } if ( result . length > size ) { MST[rv.UOI3Mutator]MSP[S] result [ size ] = null ; }
for ( final Collection < E > item : all ) { changed |= item . retainAll ( coll ) ; } return changed ; MST[rv.UOI3Mutator]MSP[S] } @Override public void clear () { for ( final Collection < E > coll : all ) { coll . clear () ; }
if ( array . length >= size ) { MST[rv.ABSMutator]MSP[N] result = array ; } else { result = ( Object [] ) Array . newInstance ( array . getClass () . getComponentType () , size ) ; } int offset = 0 ;
if ( array . length >= size ) { MST[rv.ROR5Mutator]MSP[N] result = array ; } else { result = ( Object [] ) Array . newInstance ( array . getClass () . getComponentType () , size ) ; } int offset = 0 ;
public boolean containsAll ( final Collection < ? > coll ) { if ( coll == null ) { return false ; } for ( final Object item : coll ) { if ( contains ( item ) == false ) { return false ; } } return true ; MST[BooleanFalseReturnValsMutator]MSP[N]
public boolean remove ( final Object obj ) { for ( final Set < E > set : getSets () ) { if ( set . contains ( obj ) ) { return set . remove ( obj ) ; MST[NonVoidMethodCallMutator]MSP[N] } } return false ; } @Override
for ( final Collection < E > item : all ) { changed |= item . retainAll ( coll ) ; MST[rv.UOI4Mutator]MSP[N] } return changed ; } @Override public void clear () { for ( final Collection < E > coll : all ) { coll . clear () ; }
throw new UnsupportedOperationException ( lr_4 ) ; } getMutator () . resolveCollision ( this , existingSet , set , intersects ) ; MST[VoidMethodCallMutator]MSP[N] if ( CollectionUtils . intersection ( existingSet , set ) . size () > 0 ) { throw new IllegalArgumentException ( lr_5 ) ; } } }
if ( array . length >= size ) { result = array ; } else { result = ( Object [] ) Array . newInstance ( array . getClass () . getComponentType () , size ) ; } int offset = 0 ; MST[rv.CRCR1Mutator]MSP[N]
for ( final Collection < E > item : all ) { for ( final E e : item ) { result [ offset ++ ] = e ; MST[rv.UOI3Mutator]MSP[N] } } if ( result . length > size ) { result [ size ] = null ; }
for ( final Set < E > item : all ) { if ( item . contains ( obj ) ) { return true ; } } return false ; MST[InlineConstantMutator]MSP[N] } @Override public Iterator < E > iterator () { if ( all . isEmpty () ) {
public boolean remove ( final Object obj ) { for ( final Set < E > set : getSets () ) { if ( set . contains ( obj ) ) { MST[rv.ROR4Mutator]MSP[N] return set . remove ( obj ) ; } } return false ; } @Override
} @Override public boolean addAll ( final Collection < ? extends E > coll ) { if ( mutator == null ) { throw new UnsupportedOperationException ( lr_3 ) ; } return mutator . addAll ( this , all , coll ) ; MST[ReturnValsMutator]MSP[S] } @Override
return EmptyIterator . <E > emptyIterator () ; } final IteratorChain < E > chain = new IteratorChain <> () ; MST[ConstructorCallMutator]MSP[N] for ( final Set < E > item : all ) { chain . addIterator ( item . iterator () ) ; } return chain ; } @Override
@Override MST[experimental.MemberVariableMutator]MSP[N] public int size () { int size = 0 ; for ( final Set < E > item : all ) { size += item . size () ; } return size ; } @Override public boolean isEmpty () {
public boolean containsAll ( final Collection < ? > coll ) { if ( coll == null ) { return false ; } for ( final Object item : coll ) { if ( contains ( item ) == false ) { return false ; } } return true ; MST[rv.CRCR2Mutator]MSP[N]
final Set < ? > set = ( Set < ? > ) obj ; return set . size () == this . size () && set . containsAll ( this ) ; } return false ; MST[rv.CRCR5Mutator]MSP[S] } @Override public int hashCode () { int code = 0 ;
public boolean containsAll ( final Collection < ? > coll ) { if ( coll == null ) { return false ; } for ( final Object item : coll ) { if ( contains ( item ) == false ) { return false ; } } return true ; MST[rv.CRCR4Mutator]MSP[N]
changed |= item . removeIf ( filter ) ; } return changed ; } @Override public boolean removeAll ( final Collection < ? > coll ) { if ( CollectionUtils . isEmpty ( coll ) ) { return false ; } boolean changed = false ; MST[rv.CRCR5Mutator]MSP[S]
@Override public int size () { int size = 0 ; for ( final Set < E > item : all ) { size += item . size () ; MST[rv.ABSMutator]MSP[S] } return size ; } @Override public boolean isEmpty () {
for ( final Collection < E > item : all ) { changed |= item . removeAll ( coll ) ; MST[NonVoidMethodCallMutator]MSP[N] } return changed ; } @Override public boolean retainAll ( final Collection < ? > coll ) { boolean changed = false ;
changed |= item . removeIf ( filter ) ; } return changed ; } @Override public boolean removeAll ( final Collection < ? > coll ) { if ( CollectionUtils . isEmpty ( coll ) ) { return false ; } boolean changed = false ; MST[rv.CRCR1Mutator]MSP[S]
for ( final Set < E > item : all ) { if ( item . contains ( obj ) ) { return true ; } } return false ; } @Override public Iterator < E > iterator () { if ( all . isEmpty () ) { MST[NonVoidMethodCallMutator]MSP[N]
final Set < ? > set = ( Set < ? > ) obj ; return set . size () == this . size () && set . containsAll ( this ) ; } return false ; MST[BooleanTrueReturnValsMutator]MSP[S] } @Override public int hashCode () { int code = 0 ;
final Set < ? > set = ( Set < ? > ) obj ; return set . size () == this . size () && set . containsAll ( this ) ; MST[rv.CRCR6Mutator]MSP[N] } return false ; } @Override public int hashCode () { int code = 0 ;
if ( array . length >= size ) { result = array ; } else { result = ( Object [] ) Array . newInstance ( array . getClass () . getComponentType () , size ) ; MST[rv.UOI1Mutator]MSP[N] } int offset = 0 ;
for ( final E e : this ) { code += e == null ? 0 : e . hashCode () ; MST[rv.ABSMutator]MSP[N] } return code ; }
public void addComposited ( final Set < E > ... sets ) { if ( sets != null ) { for ( final Set < E > set : sets ) { MST[rv.UOI4Mutator]MSP[N] addComposited ( set ) ; } } }
for ( final Collection < E > item : all ) { for ( final E e : item ) { result [ offset ++ ] = e ; } } if ( result . length > size ) { MST[rv.ROR2Mutator]MSP[N] result [ size ] = null ; }
for ( final Collection < E > item : all ) { changed |= item . removeAll ( coll ) ; MST[rv.OBBN2Mutator]MSP[N] } return changed ; } @Override public boolean retainAll ( final Collection < ? > coll ) { boolean changed = false ;
final Set < ? > set = ( Set < ? > ) obj ; return set . size () == this . size () && set . containsAll ( this ) ; MST[rv.CRCR2Mutator]MSP[N] } return false ; } @Override public int hashCode () { int code = 0 ;
for ( final Set < E > item : all ) { if ( item . isEmpty () == false ) { return false ; } } return true ; MST[rv.CRCR5Mutator]MSP[N] } @Override public boolean contains ( final Object obj ) {
for ( final E e : this ) { code += e == null ? 0 : e . hashCode () ; MST[rv.ROR5Mutator]MSP[N] } return code ; }
public Object [] toArray () { final Object [] result = new Object [ size () ] ; int i = 0 ; for ( final Iterator < E > it = iterator () ; it . hasNext () ; i ++ ) { MST[rv.ROR1Mutator]MSP[N]
if ( array . length >= size ) { MST[rv.UOI2Mutator]MSP[N] result = array ; } else { result = ( Object [] ) Array . newInstance ( array . getClass () . getComponentType () , size ) ; } int offset = 0 ;
public Object [] toArray () { final Object [] result = new Object [ size () ] ; int i = 0 ; MST[rv.CRCR3Mutator]MSP[N] for ( final Iterator < E > it = iterator () ; it . hasNext () ; i ++ ) {
@Override MST[experimental.MemberVariableMutator]MSP[N] public int size () { int size = 0 ; for ( final Set < E > item : all ) { size += item . size () ; } return size ; } @Override public boolean isEmpty () {
if ( array . length >= size ) { MST[NegateConditionalsMutator]MSP[N] result = array ; } else { result = ( Object [] ) Array . newInstance ( array . getClass () . getComponentType () , size ) ; } int offset = 0 ;
final Set < ? > set = ( Set < ? > ) obj ; return set . size () == this . size () && set . containsAll ( this ) ; MST[NonVoidMethodCallMutator]MSP[S] } return false ; } @Override public int hashCode () { int code = 0 ;
final Set < ? > set = ( Set < ? > ) obj ; return set . size () == this . size () && set . containsAll ( this ) ; MST[rv.ROR1Mutator]MSP[N] } return false ; } @Override public int hashCode () { int code = 0 ;
public boolean containsAll ( final Collection < ? > coll ) { if ( coll == null ) { return false ; } for ( final Object item : coll ) { if ( contains ( item ) == false ) { MST[NonVoidMethodCallMutator]MSP[S] return false ; } } return true ;
public boolean containsAll ( final Collection < ? > coll ) { if ( coll == null ) { return false ; } for ( final Object item : coll ) { if ( contains ( item ) == false ) { return false ; MST[rv.CRCR6Mutator]MSP[S] } } return true ;
changed |= item . removeIf ( filter ) ; } return changed ; } @Override public boolean removeAll ( final Collection < ? > coll ) { if ( CollectionUtils . isEmpty ( coll ) ) { MST[NonVoidMethodCallMutator]MSP[S] return false ; } boolean changed = false ;
@Override public int size () { int size = 0 ; for ( final Set < E > item : all ) { size += item . size () ; MST[rv.AOR3Mutator]MSP[N] } return size ; } @Override public boolean isEmpty () {
public boolean remove ( final Object obj ) { for ( final Set < E > set : getSets () ) { if ( set . contains ( obj ) ) { return set . remove ( obj ) ; } } return false ; MST[InlineConstantMutator]MSP[S] } @Override
for ( final E e : this ) { code += e == null ? 0 : e . hashCode () ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } return code ; }
for ( final Set < E > item : all ) { if ( item . contains ( obj ) ) { return true ; MST[rv.CRCR6Mutator]MSP[N] } } return false ; } @Override public Iterator < E > iterator () { if ( all . isEmpty () ) {
for ( final Set < E > item : all ) { if ( item . contains ( obj ) ) { return true ; } } return false ; } @Override public Iterator < E > iterator () { if ( all . isEmpty () ) { MST[rv.ROR4Mutator]MSP[N]
throw new UnsupportedOperationException ( lr_4 ) ; } getMutator () . resolveCollision ( this , existingSet , set , intersects ) ; if ( CollectionUtils . intersection ( existingSet , set ) . size () > 0 ) { MST[rv.ROR1Mutator]MSP[N] throw new IllegalArgumentException ( lr_5 ) ; } } }
throw new UnsupportedOperationException ( lr_4 ) ; } getMutator () . resolveCollision ( this , existingSet , set , intersects ) ; if ( CollectionUtils . intersection ( existingSet , set ) . size () > 0 ) { MST[rv.ROR5Mutator]MSP[S] throw new IllegalArgumentException ( lr_5 ) ; } } }
changed |= item . removeIf ( filter ) ; MST[MathMutator]MSP[S] } return changed ; } @Override public boolean removeAll ( final Collection < ? > coll ) { if ( CollectionUtils . isEmpty ( coll ) ) { return false ; } boolean changed = false ;
changed |= item . removeIf ( filter ) ; } return changed ; MST[BooleanTrueReturnValsMutator]MSP[N] } @Override public boolean removeAll ( final Collection < ? > coll ) { if ( CollectionUtils . isEmpty ( coll ) ) { return false ; } boolean changed = false ;
} public void setMutator ( final SetMutator < E > mutator ) { this . mutator = mutator ; } public synchronized void addComposited ( final Set < E > set ) { if ( set != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
@Override public int size () { int size = 0 ; MST[rv.CRCR3Mutator]MSP[N] for ( final Set < E > item : all ) { size += item . size () ; } return size ; } @Override public boolean isEmpty () {
for ( final Set < E > item : all ) { if ( item . contains ( obj ) ) { return true ; MST[rv.CRCR2Mutator]MSP[N] } } return false ; } @Override public Iterator < E > iterator () { if ( all . isEmpty () ) {
for ( final E e : this ) { code += e == null ? 0 : e . hashCode () ; MST[rv.UOI4Mutator]MSP[N] } return code ; }
public boolean remove ( final Object obj ) { for ( final Set < E > set : getSets () ) { if ( set . contains ( obj ) ) { return set . remove ( obj ) ; } } return false ; MST[rv.CRCR3Mutator]MSP[S] } @Override
public void addComposited ( final Set < E > ... sets ) { if ( sets != null ) { MST[rv.ROR5Mutator]MSP[N] for ( final Set < E > set : sets ) { addComposited ( set ) ; } } }
return ( T [] ) result ; } @Override public boolean add ( final E obj ) { if ( mutator == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] throw new UnsupportedOperationException ( lr_2 ) ; } return mutator . add ( this , all , obj ) ; } @Override
for ( final Set < E > item : all ) { if ( item . isEmpty () == false ) { return false ; MST[rv.CRCR1Mutator]MSP[N] } } return true ; } @Override public boolean contains ( final Object obj ) {
final Set < ? > set = ( Set < ? > ) obj ; return set . size () == this . size () && set . containsAll ( this ) ; } return false ; MST[ReturnValsMutator]MSP[S] } @Override public int hashCode () { int code = 0 ;
@Override public int size () { int size = 0 ; for ( final Set < E > item : all ) { size += item . size () ; MST[rv.UOI4Mutator]MSP[N] } return size ; } @Override public boolean isEmpty () {
public void removeComposited ( final Set < E > set ) { all . remove ( set ) ; MST[NonVoidMethodCallMutator]MSP[N] } public Set < E > toSet () { return new HashSet <> ( this ) ; } public List < Set < E > > getSets () {
public boolean remove ( final Object obj ) { for ( final Set < E > set : getSets () ) { if ( set . contains ( obj ) ) { return set . remove ( obj ) ; MST[BooleanFalseReturnValsMutator]MSP[S] } } return false ; } @Override
for ( final Set < E > item : all ) { if ( item . isEmpty () == false ) { return false ; } } return true ; MST[ReturnValsMutator]MSP[N] } @Override public boolean contains ( final Object obj ) {
for ( final Set < E > item : all ) { if ( item . isEmpty () == false ) { MST[rv.ROR1Mutator]MSP[N] return false ; } } return true ; } @Override public boolean contains ( final Object obj ) {
for ( final Set < E > existingSet : getSets () ) { final Collection < E > intersects = CollectionUtils . intersection ( existingSet , set ) ; if ( intersects . size () > 0 ) { if ( this . mutator == null ) { MST[NegateConditionalsMutator]MSP[N]
return UnmodifiableList . unmodifiableList ( all ) ; } protected SetMutator < E > getMutator () { return mutator ; } @Override public boolean equals ( final Object obj ) { if ( obj instanceof Set ) { MST[rv.ROR1Mutator]MSP[S]
public void addComposited ( final Set < E > ... sets ) { if ( sets != null ) { for ( final Set < E > set : sets ) { MST[rv.UOI3Mutator]MSP[N] addComposited ( set ) ; } } }
final Set < ? > set = ( Set < ? > ) obj ; return set . size () == this . size () && set . containsAll ( this ) ; MST[rv.CRCR3Mutator]MSP[N] } return false ; } @Override public int hashCode () { int code = 0 ;
if ( array . length >= size ) { result = array ; } else { result = ( Object [] ) Array . newInstance ( array . getClass () . getComponentType () , size ) ; MST[experimental.NakedReceiverMutator]MSP[S] } int offset = 0 ;
@Override public int size () { int size = 0 ; for ( final Set < E > item : all ) { size += item . size () ; MST[rv.AOD1Mutator]MSP[N] } return size ; } @Override public boolean isEmpty () {
for ( final E e : this ) { code += e == null ? 0 : e . hashCode () ; } return code ; MST[rv.ABSMutator]MSP[N] }
public boolean removeIf ( final Predicate < ? super E > filter ) { if ( Objects . isNull ( filter ) ) { return false ; MST[BooleanTrueReturnValsMutator]MSP[S] } boolean changed = false ; for ( final Collection < E > item : all ) {
for ( final E e : this ) { code += e == null ? 0 : e . hashCode () ; MST[rv.CRCR5Mutator]MSP[N] } return code ; }
for ( final Set < E > existingSet : getSets () ) { final Collection < E > intersects = CollectionUtils . intersection ( existingSet , set ) ; if ( intersects . size () > 0 ) { MST[rv.ROR2Mutator]MSP[N] if ( this . mutator == null ) {
for ( final Set < E > existingSet : getSets () ) { final Collection < E > intersects = CollectionUtils . intersection ( existingSet , set ) ; if ( intersects . size () > 0 ) { MST[rv.ROR1Mutator]MSP[N] if ( this . mutator == null ) {
public boolean containsAll ( final Collection < ? > coll ) { if ( coll == null ) { return false ; } for ( final Object item : coll ) { if ( contains ( item ) == false ) { return false ; } } return true ; MST[InlineConstantMutator]MSP[N]
public boolean removeIf ( final Predicate < ? super E > filter ) { if ( Objects . isNull ( filter ) ) { MST[rv.ROR4Mutator]MSP[N] return false ; } boolean changed = false ; for ( final Collection < E > item : all ) {
@Override public int size () { int size = 0 ; for ( final Set < E > item : all ) { size += item . size () ; } return size ; MST[rv.UOI1Mutator]MSP[N] } @Override public boolean isEmpty () {
} public void setMutator ( final SetMutator < E > mutator ) { this . mutator = mutator ; } public synchronized void addComposited ( final Set < E > set ) { if ( set != null ) { MST[NegateConditionalsMutator]MSP[N]
for ( final E e : this ) { code += e == null ? 0 : e . hashCode () ; MST[rv.CRCR6Mutator]MSP[N] } return code ; }
@Override public int size () { int size = 0 ; for ( final Set < E > item : all ) { size += item . size () ; } return size ; MST[rv.UOI2Mutator]MSP[N] } @Override public boolean isEmpty () {
for ( final Collection < E > item : all ) { for ( final E e : item ) { result [ offset ++ ] = e ; MST[IncrementsMutator]MSP[N] } } if ( result . length > size ) { result [ size ] = null ; }
for ( final Collection < E > item : all ) { changed |= item . removeAll ( coll ) ; } return changed ; MST[ReturnValsMutator]MSP[N] } @Override public boolean retainAll ( final Collection < ? > coll ) { boolean changed = false ;
for ( final Collection < E > item : all ) { changed |= item . removeAll ( coll ) ; MST[rv.UOI1Mutator]MSP[N] } return changed ; } @Override public boolean retainAll ( final Collection < ? > coll ) { boolean changed = false ;
for ( final E e : this ) { code += e == null ? 0 : e . hashCode () ; MST[rv.UOI3Mutator]MSP[N] } return code ; }
for ( final Collection < E > item : all ) { changed |= item . removeAll ( coll ) ; } return changed ; MST[rv.UOI4Mutator]MSP[N] } @Override public boolean retainAll ( final Collection < ? > coll ) { boolean changed = false ;
changed |= item . removeIf ( filter ) ; } return changed ; } @Override public boolean removeAll ( final Collection < ? > coll ) { if ( CollectionUtils . isEmpty ( coll ) ) { return false ; MST[BooleanTrueReturnValsMutator]MSP[N] } boolean changed = false ;
result [ i ] = it . next () ; } return result ; MST[ReturnValsMutator]MSP[N] } @Override @SuppressWarnings ( lr_1 ) public < T > T [] toArray ( final T [] array ) { final int size = size () ; Object [] result = null ;
public boolean remove ( final Object obj ) { for ( final Set < E > set : getSets () ) { if ( set . contains ( obj ) ) { return set . remove ( obj ) ; MST[BooleanTrueReturnValsMutator]MSP[N] } } return false ; } @Override
for ( final Collection < E > item : all ) { changed |= item . retainAll ( coll ) ; MST[rv.OBBN1Mutator]MSP[S] } return changed ; } @Override public void clear () { for ( final Collection < E > coll : all ) { coll . clear () ; }
public void addComposited ( final Set < E > ... sets ) { if ( sets != null ) { for ( final Set < E > set : sets ) { MST[rv.UOI3Mutator]MSP[N] addComposited ( set ) ; } } }
return EmptyIterator . <E > emptyIterator () ; } final IteratorChain < E > chain = new IteratorChain <> () ; for ( final Set < E > item : all ) { chain . addIterator ( item . iterator () ) ; } return chain ; MST[ReturnValsMutator]MSP[N] } @Override
public boolean removeIf ( final Predicate < ? super E > filter ) { if ( Objects . isNull ( filter ) ) { return false ; } boolean changed = false ; MST[rv.CRCR6Mutator]MSP[N] for ( final Collection < E > item : all ) {
changed |= item . removeIf ( filter ) ; } return changed ; } @Override public boolean removeAll ( final Collection < ? > coll ) { if ( CollectionUtils . isEmpty ( coll ) ) { MST[rv.ROR4Mutator]MSP[S] return false ; } boolean changed = false ;
for ( final Collection < E > item : all ) { changed |= item . retainAll ( coll ) ; MST[rv.ABSMutator]MSP[N] } return changed ; } @Override public void clear () { for ( final Collection < E > coll : all ) { coll . clear () ; }
public boolean remove ( final Object obj ) { for ( final Set < E > set : getSets () ) { if ( set . contains ( obj ) ) { MST[NegateConditionalsMutator]MSP[N] return set . remove ( obj ) ; } } return false ; } @Override
@Override MST[ConstructorCallMutator]MSP[N] public int size () { int size = 0 ; for ( final Set < E > item : all ) { size += item . size () ; } return size ; } @Override public boolean isEmpty () {
changed |= item . removeIf ( filter ) ; } return changed ; MST[rv.UOI4Mutator]MSP[N] } @Override public boolean removeAll ( final Collection < ? > coll ) { if ( CollectionUtils . isEmpty ( coll ) ) { return false ; } boolean changed = false ;
return UnmodifiableList . unmodifiableList ( all ) ; } protected SetMutator < E > getMutator () { return mutator ; MST[ReturnValsMutator]MSP[N] } @Override public boolean equals ( final Object obj ) { if ( obj instanceof Set ) {
final Set < ? > set = ( Set < ? > ) obj ; return set . size () == this . size () && set . containsAll ( this ) ; MST[NonVoidMethodCallMutator]MSP[N] } return false ; } @Override public int hashCode () { int code = 0 ;
public boolean containsAll ( final Collection < ? > coll ) { if ( coll == null ) { return false ; MST[rv.CRCR3Mutator]MSP[S] } for ( final Object item : coll ) { if ( contains ( item ) == false ) { return false ; } } return true ;
for ( final E e : this ) { code += e == null ? 0 : e . hashCode () ; } return code ; MST[rv.UOI4Mutator]MSP[N] }
throw new UnsupportedOperationException ( lr_4 ) ; } getMutator () . resolveCollision ( this , existingSet , set , intersects ) ; if ( CollectionUtils . intersection ( existingSet , set ) . size () > 0 ) { throw new IllegalArgumentException ( MST[ConstructorCallMutator]MSP[S] lr_5 ) ; } } }
changed |= item . removeIf ( filter ) ; MST[rv.OBBN3Mutator]MSP[N] } return changed ; } @Override public boolean removeAll ( final Collection < ? > coll ) { if ( CollectionUtils . isEmpty ( coll ) ) { return false ; } boolean changed = false ;
result [ i ] = it . next () ; MST[rv.UOI1Mutator]MSP[N] } return result ; } @Override @SuppressWarnings ( lr_1 ) public < T > T [] toArray ( final T [] array ) { final int size = size () ; Object [] result = null ;
public void addComposited ( final Set < E > ... sets ) { if ( sets != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] for ( final Set < E > set : sets ) { addComposited ( set ) ; } } }
public boolean removeIf ( final Predicate < ? super E > filter ) { if ( Objects . isNull ( filter ) ) { MST[NegateConditionalsMutator]MSP[S] return false ; } boolean changed = false ; for ( final Collection < E > item : all ) {
return EmptyIterator . <E > emptyIterator () ; } final IteratorChain < E > chain = new IteratorChain <> () ; for ( final Set < E > item : all ) { chain . addIterator ( item . iterator () ) ; MST[VoidMethodCallMutator]MSP[N] } return chain ; } @Override
public boolean containsAll ( final Collection < ? > coll ) { if ( coll == null ) { return false ; } for ( final Object item : coll ) { if ( contains ( item ) == false ) { return false ; } } return true ; MST[rv.CRCR3Mutator]MSP[N]
for ( final Set < E > existingSet : getSets () ) { final Collection < E > intersects = CollectionUtils . intersection ( existingSet , set ) ; if ( intersects . size () > 0 ) { if ( this . mutator == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S]
for ( final E e : this ) { code += e == null ? 0 : e . hashCode () ; MST[rv.AOR1Mutator]MSP[N] } return code ; }
public boolean containsAll ( final Collection < ? > coll ) { if ( coll == null ) { return false ; } for ( final Object item : coll ) { if ( contains ( item ) == false ) { return false ; MST[ReturnValsMutator]MSP[S] } } return true ;
result [ i ] = it . next () ; } return result ; MST[NullReturnValsMutator]MSP[N] } @Override @SuppressWarnings ( lr_1 ) public < T > T [] toArray ( final T [] array ) { final int size = size () ; Object [] result = null ;
changed |= item . removeIf ( filter ) ; } return changed ; } @Override public boolean removeAll ( final Collection < ? > coll ) { if ( CollectionUtils . isEmpty ( coll ) ) { return false ; } boolean changed = false ; MST[rv.CRCR6Mutator]MSP[S]
if ( array . length >= size ) { result = array ; } else { result = ( Object [] ) Array . newInstance ( array . getClass () . getComponentType () , size ) ; } int offset = 0 ; MST[rv.CRCR5Mutator]MSP[N]
return UnmodifiableList . unmodifiableList ( all ) ; } protected SetMutator < E > getMutator () { return mutator ; MST[NullReturnValsMutator]MSP[S] } @Override public boolean equals ( final Object obj ) { if ( obj instanceof Set ) {
for ( final Set < E > item : all ) { if ( item . contains ( obj ) ) { MST[rv.ROR1Mutator]MSP[N] return true ; } } return false ; } @Override public Iterator < E > iterator () { if ( all . isEmpty () ) {
public boolean containsAll ( final Collection < ? > coll ) { if ( coll == null ) { return false ; MST[InlineConstantMutator]MSP[S] } for ( final Object item : coll ) { if ( contains ( item ) == false ) { return false ; } } return true ;
changed |= item . removeIf ( filter ) ; } return changed ; MST[ReturnValsMutator]MSP[N] } @Override public boolean removeAll ( final Collection < ? > coll ) { if ( CollectionUtils . isEmpty ( coll ) ) { return false ; } boolean changed = false ;
for ( final Collection < E > item : all ) { for ( final E e : item ) { result [ offset ++ ] = e ; } } if ( result . length > size ) { MST[rv.ROR1Mutator]MSP[N] result [ size ] = null ; }
for ( final Collection < E > item : all ) { changed |= item . removeAll ( coll ) ; MST[rv.OBBN3Mutator]MSP[N] } return changed ; } @Override public boolean retainAll ( final Collection < ? > coll ) { boolean changed = false ;
for ( final E e : this ) { code += e == null ? 0 : e . hashCode () ; } return code ; MST[ReturnValsMutator]MSP[N] }
return EmptyIterator . <E > emptyIterator () ; } final IteratorChain < E > chain = new IteratorChain <> () ; for ( final Set < E > item : all ) { chain . addIterator ( item . iterator () ) ; } return chain ; MST[NullReturnValsMutator]MSP[N] } @Override
public void addComposited ( final Set < E > ... sets ) { if ( sets != null ) { for ( final Set < E > set : sets ) { MST[rv.ABSMutator]MSP[N] addComposited ( set ) ; } } }
final Set < ? > set = ( Set < ? > ) obj ; return set . size () == this . size () && set . containsAll ( this ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } return false ; } @Override public int hashCode () { int code = 0 ;
for ( final Collection < E > item : all ) { for ( final E e : item ) { result [ offset ++ ] = e ; } } if ( result . length > size ) { MST[rv.UOI4Mutator]MSP[N] result [ size ] = null ; }
for ( final Collection < E > item : all ) { changed |= item . retainAll ( coll ) ; } return changed ; MST[rv.UOI2Mutator]MSP[N] } @Override public void clear () { for ( final Collection < E > coll : all ) { coll . clear () ; }
result [ i ] = it . next () ; MST[rv.ABSMutator]MSP[N] } return result ; } @Override @SuppressWarnings ( lr_1 ) public < T > T [] toArray ( final T [] array ) { final int size = size () ; Object [] result = null ;
if ( array . length >= size ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] result = array ; } else { result = ( Object [] ) Array . newInstance ( array . getClass () . getComponentType () , size ) ; } int offset = 0 ;
if ( array . length >= size ) { MST[rv.ROR4Mutator]MSP[N] result = array ; } else { result = ( Object [] ) Array . newInstance ( array . getClass () . getComponentType () , size ) ; } int offset = 0 ;
@Override public int size () { int size = 0 ; for ( final Set < E > item : all ) { size += item . size () ; } return size ; MST[PrimitiveReturnsMutator]MSP[N] } @Override public boolean isEmpty () {
for ( final Collection < E > item : all ) { for ( final E e : item ) { result [ offset ++ ] = e ; MST[rv.UOI4Mutator]MSP[N] } } if ( result . length > size ) { result [ size ] = null ; }
for ( final Collection < E > item : all ) { changed |= item . retainAll ( coll ) ; MST[rv.UOI3Mutator]MSP[N] } return changed ; } @Override public void clear () { for ( final Collection < E > coll : all ) { coll . clear () ; }
return UnmodifiableList . unmodifiableList ( all ) ; MST[ArgumentPropagationMutator]MSP[N] } protected SetMutator < E > getMutator () { return mutator ; } @Override public boolean equals ( final Object obj ) { if ( obj instanceof Set ) {
@Override public int size () { int size = 0 ; MST[InlineConstantMutator]MSP[N] for ( final Set < E > item : all ) { size += item . size () ; } return size ; } @Override public boolean isEmpty () {
public boolean containsAll ( final Collection < ? > coll ) { if ( coll == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return false ; } for ( final Object item : coll ) { if ( contains ( item ) == false ) { return false ; } } return true ;
if ( array . length >= size ) { MST[ConditionalsBoundaryMutator]MSP[N] result = array ; } else { result = ( Object [] ) Array . newInstance ( array . getClass () . getComponentType () , size ) ; } int offset = 0 ;
for ( final Set < E > item : all ) { if ( item . contains ( obj ) ) { return true ; } } return false ; } @Override public Iterator < E > iterator () { if ( all . isEmpty () ) { MST[NegateConditionalsMutator]MSP[N]
public boolean remove ( final Object obj ) { for ( final Set < E > set : getSets () ) { if ( set . contains ( obj ) ) { MST[rv.ROR3Mutator]MSP[N] return set . remove ( obj ) ; } } return false ; } @Override
public void removeComposited ( final Set < E > set ) { all . remove ( set ) ; } public Set < E > toSet () { return new HashSet <> ( this ) ; MST[EmptyObjectReturnValsMutator]MSP[S] } public List < Set < E > > getSets () {
return UnmodifiableList . unmodifiableList ( all ) ; MST[ReturnValsMutator]MSP[N] } protected SetMutator < E > getMutator () { return mutator ; } @Override public boolean equals ( final Object obj ) { if ( obj instanceof Set ) {
for ( final Set < E > item : all ) { if ( item . isEmpty () == false ) { return false ; MST[rv.CRCR6Mutator]MSP[N] } } return true ; } @Override public boolean contains ( final Object obj ) {
@Override public int size () { int size = 0 ; for ( final Set < E > item : all ) { size += item . size () ; MST[rv.UOI3Mutator]MSP[N] } return size ; } @Override public boolean isEmpty () {
public boolean remove ( final Object obj ) { for ( final Set < E > set : getSets () ) { if ( set . contains ( obj ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return set . remove ( obj ) ; } } return false ; } @Override
} @Override public boolean addAll ( final Collection < ? extends E > coll ) { if ( mutator == null ) { throw new UnsupportedOperationException ( MST[ConstructorCallMutator]MSP[S] lr_3 ) ; } return mutator . addAll ( this , all , coll ) ; } @Override
if ( array . length >= size ) { result = array ; } else { result = ( Object [] ) Array . newInstance ( array . getClass () . getComponentType () , size ) ; MST[rv.ABSMutator]MSP[N] } int offset = 0 ;
for ( final Set < E > item : all ) { if ( item . isEmpty () == false ) { MST[rv.ROR2Mutator]MSP[N] return false ; } } return true ; } @Override public boolean contains ( final Object obj ) {
for ( final Collection < E > item : all ) { changed |= item . removeAll ( coll ) ; MST[MathMutator]MSP[N] } return changed ; } @Override public boolean retainAll ( final Collection < ? > coll ) { boolean changed = false ;
for ( final E e : this ) { code += e == null ? 0 : e . hashCode () ; MST[rv.AOR2Mutator]MSP[N] } return code ; }
public void addComposited ( final Set < E > ... sets ) { if ( sets != null ) { for ( final Set < E > set : sets ) { MST[rv.UOI4Mutator]MSP[N] addComposited ( set ) ; } } }
for ( final Set < E > item : all ) { if ( item . contains ( obj ) ) { MST[NonVoidMethodCallMutator]MSP[N] return true ; } } return false ; } @Override public Iterator < E > iterator () { if ( all . isEmpty () ) {
public boolean containsAll ( final Collection < ? > coll ) { if ( coll == null ) { return false ; } for ( final Object item : coll ) { if ( contains ( item ) == false ) { MST[rv.ROR5Mutator]MSP[N] return false ; } } return true ;
changed |= item . removeIf ( filter ) ; } return changed ; } @Override public boolean removeAll ( final Collection < ? > coll ) { if ( CollectionUtils . isEmpty ( coll ) ) { MST[NegateConditionalsMutator]MSP[N] return false ; } boolean changed = false ;
return UnmodifiableList . unmodifiableList ( all ) ; } protected SetMutator < E > getMutator () { return mutator ; } @Override public boolean equals ( final Object obj ) { if ( obj instanceof Set ) { MST[rv.ROR4Mutator]MSP[N]
changed |= item . removeIf ( filter ) ; } return changed ; } @Override public boolean removeAll ( final Collection < ? > coll ) { if ( CollectionUtils . isEmpty ( coll ) ) { MST[rv.ROR5Mutator]MSP[N] return false ; } boolean changed = false ;
public Object [] toArray () { final Object [] result = new Object [ size () ] ; int i = 0 ; for ( final Iterator < E > it = iterator () ; it . hasNext () ; i ++ ) { MST[rv.ROR2Mutator]MSP[N]
@Override public int size () { int size = 0 ; for ( final Set < E > item : all ) { size += item . size () ; MST[rv.AOR4Mutator]MSP[N] } return size ; } @Override public boolean isEmpty () {
public Object [] toArray () { final Object [] result = new Object [ size () ] ; int i = 0 ; MST[rv.CRCR6Mutator]MSP[N] for ( final Iterator < E > it = iterator () ; it . hasNext () ; i ++ ) {
changed |= item . removeIf ( filter ) ; } return changed ; MST[rv.UOI2Mutator]MSP[N] } @Override public boolean removeAll ( final Collection < ? > coll ) { if ( CollectionUtils . isEmpty ( coll ) ) { return false ; } boolean changed = false ;
if ( array . length >= size ) { MST[rv.UOI3Mutator]MSP[S] result = array ; } else { result = ( Object [] ) Array . newInstance ( array . getClass () . getComponentType () , size ) ; } int offset = 0 ;
public boolean containsAll ( final Collection < ? > coll ) { if ( coll == null ) { return false ; } for ( final Object item : coll ) { if ( contains ( item ) == false ) { return false ; MST[rv.CRCR5Mutator]MSP[S] } } return true ;
@Override public int size () { int size = 0 ; for ( final Set < E > item : all ) { size += item . size () ; MST[MathMutator]MSP[N] } return size ; } @Override public boolean isEmpty () {
@Override public int size () { int size = 0 ; for ( final Set < E > item : all ) { size += item . size () ; } return size ; MST[rv.ABSMutator]MSP[N] } @Override public boolean isEmpty () {
for ( final Set < E > item : all ) { if ( item . contains ( obj ) ) { return true ; } } return false ; } @Override public Iterator < E > iterator () { if ( all . isEmpty () ) { MST[rv.ROR5Mutator]MSP[N]
final Set < ? > set = ( Set < ? > ) obj ; return set . size () == this . size () && set . containsAll ( this ) ; MST[NonVoidMethodCallMutator]MSP[N] } return false ; } @Override public int hashCode () { int code = 0 ;
if ( array . length >= size ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] result = array ; } else { result = ( Object [] ) Array . newInstance ( array . getClass () . getComponentType () , size ) ; } int offset = 0 ;
changed |= item . removeIf ( filter ) ; MST[rv.OBBN2Mutator]MSP[S] } return changed ; } @Override public boolean removeAll ( final Collection < ? > coll ) { if ( CollectionUtils . isEmpty ( coll ) ) { return false ; } boolean changed = false ;
@Override MST[ConstructorCallMutator]MSP[N] public int size () { int size = 0 ; for ( final Set < E > item : all ) { size += item . size () ; } return size ; } @Override public boolean isEmpty () {
for ( final Set < E > item : all ) { if ( item . contains ( obj ) ) { return true ; MST[rv.CRCR3Mutator]MSP[N] } } return false ; } @Override public Iterator < E > iterator () { if ( all . isEmpty () ) {
if ( array . length >= size ) { result = array ; } else { result = ( Object [] ) Array . newInstance ( array . getClass () . getComponentType () , size ) ; MST[NonVoidMethodCallMutator]MSP[N] } int offset = 0 ;
changed |= item . removeIf ( filter ) ; } return changed ; } @Override public boolean removeAll ( final Collection < ? > coll ) { if ( CollectionUtils . isEmpty ( coll ) ) { return false ; MST[rv.CRCR1Mutator]MSP[N] } boolean changed = false ;
for ( final Set < E > item : all ) { if ( item . isEmpty () == false ) { return false ; } } return true ; MST[BooleanFalseReturnValsMutator]MSP[N] } @Override public boolean contains ( final Object obj ) {
public Object [] toArray () { final Object [] result = new Object [ size () ] ; int i = 0 ; MST[InlineConstantMutator]MSP[N] for ( final Iterator < E > it = iterator () ; it . hasNext () ; i ++ ) {
for ( final Collection < E > item : all ) { changed |= item . removeAll ( coll ) ; } return changed ; } @Override public boolean retainAll ( final Collection < ? > coll ) { boolean changed = false ; MST[InlineConstantMutator]MSP[N]
for ( final Set < E > item : all ) { if ( item . contains ( obj ) ) { return true ; } } return false ; } @Override public Iterator < E > iterator () { if ( all . isEmpty () ) { MST[rv.ROR1Mutator]MSP[N]
changed |= item . removeIf ( filter ) ; } return changed ; MST[rv.ABSMutator]MSP[N] } @Override public boolean removeAll ( final Collection < ? > coll ) { if ( CollectionUtils . isEmpty ( coll ) ) { return false ; } boolean changed = false ;
for ( final Set < E > item : all ) { if ( item . contains ( obj ) ) { MST[rv.ROR3Mutator]MSP[N] return true ; } } return false ; } @Override public Iterator < E > iterator () { if ( all . isEmpty () ) {
for ( final Collection < E > item : all ) { changed |= item . removeAll ( coll ) ; } return changed ; MST[rv.UOI1Mutator]MSP[N] } @Override public boolean retainAll ( final Collection < ? > coll ) { boolean changed = false ;
public boolean containsAll ( final Collection < ? > coll ) { if ( coll == null ) { return false ; } for ( final Object item : coll ) { if ( contains ( item ) == false ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] return false ; } } return true ;
changed |= item . removeIf ( filter ) ; } return changed ; } @Override public boolean removeAll ( final Collection < ? > coll ) { if ( CollectionUtils . isEmpty ( coll ) ) { return false ; MST[rv.CRCR5Mutator]MSP[N] } boolean changed = false ;
if ( array . length >= size ) { result = array ; } else { result = ( Object [] ) Array . newInstance ( array . getClass () . getComponentType () , size ) ; MST[rv.UOI2Mutator]MSP[S] } int offset = 0 ;
for ( final Collection < E > item : all ) { for ( final E e : item ) { result [ offset ++ ] = e ; } } if ( result . length > size ) { result [ size ] = null ; MST[rv.UOI1Mutator]MSP[N] }
for ( final Collection < E > item : all ) { changed |= item . removeAll ( coll ) ; MST[rv.OBBN1Mutator]MSP[N] } return changed ; } @Override public boolean retainAll ( final Collection < ? > coll ) { boolean changed = false ;
for ( final Set < E > item : all ) { if ( item . isEmpty () == false ) { return false ; } } return true ; MST[rv.CRCR4Mutator]MSP[N] } @Override public boolean contains ( final Object obj ) {
final Set < ? > set = ( Set < ? > ) obj ; return set . size () == this . size () && set . containsAll ( this ) ; MST[rv.CRCR3Mutator]MSP[N] } return false ; } @Override public int hashCode () { int code = 0 ;
changed |= item . removeIf ( filter ) ; } return changed ; } @Override public boolean removeAll ( final Collection < ? > coll ) { if ( CollectionUtils . isEmpty ( coll ) ) { MST[rv.ROR1Mutator]MSP[N] return false ; } boolean changed = false ;
public boolean containsAll ( final Collection < ? > coll ) { if ( coll == null ) { return false ; MST[BooleanTrueReturnValsMutator]MSP[S] } for ( final Object item : coll ) { if ( contains ( item ) == false ) { return false ; } } return true ;
for ( final Collection < E > item : all ) { changed |= item . removeAll ( coll ) ; } return changed ; } @Override public boolean retainAll ( final Collection < ? > coll ) { boolean changed = false ; MST[rv.CRCR3Mutator]MSP[N]
for ( final Set < E > item : all ) { if ( item . contains ( obj ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return true ; } } return false ; } @Override public Iterator < E > iterator () { if ( all . isEmpty () ) {
for ( final Set < E > item : all ) { if ( item . isEmpty () == false ) { return false ; MST[InlineConstantMutator]MSP[N] } } return true ; } @Override public boolean contains ( final Object obj ) {
for ( final Set < E > item : all ) { if ( item . contains ( obj ) ) { return true ; } } return false ; MST[rv.CRCR5Mutator]MSP[N] } @Override public Iterator < E > iterator () { if ( all . isEmpty () ) {
@Override public int size () { int size = 0 ; for ( final Set < E > item : all ) { size += item . size () ; MST[rv.AOD2Mutator]MSP[S] } return size ; } @Override public boolean isEmpty () {
for ( final Set < E > item : all ) { if ( item . contains ( obj ) ) { return true ; } } return false ; MST[rv.CRCR6Mutator]MSP[N] } @Override public Iterator < E > iterator () { if ( all . isEmpty () ) {
public boolean remove ( final Object obj ) { for ( final Set < E > set : getSets () ) { MST[NonVoidMethodCallMutator]MSP[N] if ( set . contains ( obj ) ) { return set . remove ( obj ) ; } } return false ; } @Override
for ( final Set < E > item : all ) { if ( item . contains ( obj ) ) { return true ; } } return false ; MST[ReturnValsMutator]MSP[N] } @Override public Iterator < E > iterator () { if ( all . isEmpty () ) {
public boolean removeIf ( final Predicate < ? super E > filter ) { if ( Objects . isNull ( filter ) ) { return false ; MST[rv.CRCR5Mutator]MSP[S] } boolean changed = false ; for ( final Collection < E > item : all ) {
public boolean removeIf ( final Predicate < ? super E > filter ) { if ( Objects . isNull ( filter ) ) { return false ; MST[rv.CRCR6Mutator]MSP[S] } boolean changed = false ; for ( final Collection < E > item : all ) {
return EmptyIterator . <E > emptyIterator () ; MST[ReturnValsMutator]MSP[S] } final IteratorChain < E > chain = new IteratorChain <> () ; for ( final Set < E > item : all ) { chain . addIterator ( item . iterator () ) ; } return chain ; } @Override
public boolean removeIf ( final Predicate < ? super E > filter ) { if ( Objects . isNull ( filter ) ) { MST[rv.ROR5Mutator]MSP[S] return false ; } boolean changed = false ; for ( final Collection < E > item : all ) {
public boolean removeIf ( final Predicate < ? super E > filter ) { if ( Objects . isNull ( filter ) ) { return false ; MST[ReturnValsMutator]MSP[S] } boolean changed = false ; for ( final Collection < E > item : all ) {
public boolean remove ( final Object obj ) { for ( final Set < E > set : getSets () ) { if ( set . contains ( obj ) ) { MST[NonVoidMethodCallMutator]MSP[N] return set . remove ( obj ) ; } } return false ; } @Override
for ( final Collection < E > item : all ) { changed |= item . removeAll ( coll ) ; } return changed ; MST[rv.ABSMutator]MSP[N] } @Override public boolean retainAll ( final Collection < ? > coll ) { boolean changed = false ;
all . add ( set ) ; } } public void addComposited ( final Set < E > set1 , final Set < E > set2 ) { addComposited ( set1 ) ; MST[VoidMethodCallMutator]MSP[S] addComposited ( set2 ) ; }
for ( final Collection < E > item : all ) { changed |= item . removeAll ( coll ) ; MST[rv.UOI2Mutator]MSP[N] } return changed ; } @Override public boolean retainAll ( final Collection < ? > coll ) { boolean changed = false ;
changed |= item . removeIf ( filter ) ; } return changed ; } @Override public boolean removeAll ( final Collection < ? > coll ) { if ( CollectionUtils . isEmpty ( coll ) ) { return false ; MST[ReturnValsMutator]MSP[N] } boolean changed = false ;
public boolean remove ( final Object obj ) { for ( final Set < E > set : getSets () ) { if ( set . contains ( obj ) ) { return set . remove ( obj ) ; } } return false ; MST[rv.CRCR6Mutator]MSP[S] } @Override
public boolean containsAll ( final Collection < ? > coll ) { if ( coll == null ) { return false ; } for ( final Object item : coll ) { if ( contains ( item ) == false ) { return false ; MST[rv.CRCR1Mutator]MSP[S] } } return true ;
final Set < ? > set = ( Set < ? > ) obj ; return set . size () == this . size () && set . containsAll ( this ) ; } return false ; } @Override public int hashCode () { int code = 0 ; MST[rv.CRCR6Mutator]MSP[N]
public boolean removeIf ( final Predicate < ? super E > filter ) { if ( Objects . isNull ( filter ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] return false ; } boolean changed = false ; for ( final Collection < E > item : all ) {
public void addComposited ( final Set < E > ... sets ) { if ( sets != null ) { for ( final Set < E > set : sets ) { MST[rv.UOI1Mutator]MSP[N] addComposited ( set ) ; } } }
} @Override public boolean addAll ( final Collection < ? extends E > coll ) { if ( mutator == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] throw new UnsupportedOperationException ( lr_3 ) ; } return mutator . addAll ( this , all , coll ) ; } @Override
public boolean containsAll ( final Collection < ? > coll ) { if ( coll == null ) { return false ; } for ( final Object item : coll ) { if ( contains ( item ) == false ) { MST[rv.ROR1Mutator]MSP[S] return false ; } } return true ;
changed |= item . removeIf ( filter ) ; MST[rv.UOI4Mutator]MSP[N] } return changed ; } @Override public boolean removeAll ( final Collection < ? > coll ) { if ( CollectionUtils . isEmpty ( coll ) ) { return false ; } boolean changed = false ;
final Set < ? > set = ( Set < ? > ) obj ; return set . size () == this . size () && set . containsAll ( this ) ; } return false ; MST[InlineConstantMutator]MSP[S] } @Override public int hashCode () { int code = 0 ;
public boolean containsAll ( final Collection < ? > coll ) { if ( coll == null ) { return false ; } for ( final Object item : coll ) { if ( contains ( item ) == false ) { MST[rv.ROR4Mutator]MSP[S] return false ; } } return true ;
for ( final Collection < E > item : all ) { changed |= item . retainAll ( coll ) ; } return changed ; MST[rv.ABSMutator]MSP[N] } @Override public void clear () { for ( final Collection < E > coll : all ) { coll . clear () ; }
final Set < ? > set = ( Set < ? > ) obj ; return set . size () == this . size () && set . containsAll ( this ) ; MST[rv.ROR3Mutator]MSP[N] } return false ; } @Override public int hashCode () { int code = 0 ;
changed |= item . removeIf ( filter ) ; } return changed ; MST[rv.UOI3Mutator]MSP[N] } @Override public boolean removeAll ( final Collection < ? > coll ) { if ( CollectionUtils . isEmpty ( coll ) ) { return false ; } boolean changed = false ;
changed |= item . removeIf ( filter ) ; } return changed ; } @Override public boolean removeAll ( final Collection < ? > coll ) { if ( CollectionUtils . isEmpty ( coll ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return false ; } boolean changed = false ;
for ( final Set < E > item : all ) { if ( item . contains ( obj ) ) { return true ; } } return false ; } @Override public Iterator < E > iterator () { if ( all . isEmpty () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
for ( final E e : this ) { code += e == null ? 0 : e . hashCode () ; } return code ; MST[rv.UOI3Mutator]MSP[N] }
return ( T [] ) result ; } @Override public boolean add ( final E obj ) { if ( mutator == null ) { throw new UnsupportedOperationException ( lr_2 ) ; } return mutator . add ( this , all , obj ) ; MST[NonVoidMethodCallMutator]MSP[N] } @Override
throw new UnsupportedOperationException ( lr_4 ) ; } getMutator () . resolveCollision ( this , existingSet , set , intersects ) ; if ( CollectionUtils . intersection ( existingSet , set ) . size () > 0 ) { MST[rv.ROR2Mutator]MSP[S] throw new IllegalArgumentException ( lr_5 ) ; } } }
@Override MST[ConstructorCallMutator]MSP[N] public int size () { int size = 0 ; for ( final Set < E > item : all ) { size += item . size () ; } return size ; } @Override public boolean isEmpty () {
return EmptyIterator . <E > emptyIterator () ; MST[NullReturnValsMutator]MSP[S] } final IteratorChain < E > chain = new IteratorChain <> () ; for ( final Set < E > item : all ) { chain . addIterator ( item . iterator () ) ; } return chain ; } @Override
result [ i ] = it . next () ; MST[rv.UOI2Mutator]MSP[N] } return result ; } @Override @SuppressWarnings ( lr_1 ) public < T > T [] toArray ( final T [] array ) { final int size = size () ; Object [] result = null ;
final Set < ? > set = ( Set < ? > ) obj ; return set . size () == this . size () && set . containsAll ( this ) ; MST[rv.CRCR1Mutator]MSP[N] } return false ; } @Override public int hashCode () { int code = 0 ;
for ( final E e : this ) { code += e == null ? 0 : e . hashCode () ; MST[rv.UOI2Mutator]MSP[N] } return code ; }
if ( array . length >= size ) { result = array ; } else { result = ( Object [] ) Array . newInstance ( array . getClass () . getComponentType () , size ) ; MST[NonVoidMethodCallMutator]MSP[S] } int offset = 0 ;
final Set < ? > set = ( Set < ? > ) obj ; return set . size () == this . size () && set . containsAll ( this ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } return false ; } @Override public int hashCode () { int code = 0 ;
final Set < ? > set = ( Set < ? > ) obj ; return set . size () == this . size () && set . containsAll ( this ) ; } return false ; MST[rv.CRCR6Mutator]MSP[S] } @Override public int hashCode () { int code = 0 ;
public boolean removeIf ( final Predicate < ? super E > filter ) { if ( Objects . isNull ( filter ) ) { return false ; MST[InlineConstantMutator]MSP[S] } boolean changed = false ; for ( final Collection < E > item : all ) {
public boolean remove ( final Object obj ) { for ( final Set < E > set : getSets () ) { if ( set . contains ( obj ) ) { return set . remove ( obj ) ; } } return false ; MST[rv.CRCR1Mutator]MSP[S] } @Override
final Set < ? > set = ( Set < ? > ) obj ; return set . size () == this . size () && set . containsAll ( this ) ; } return false ; } @Override public int hashCode () { int code = 0 ; MST[rv.CRCR3Mutator]MSP[N]
@Override public int size () { int size = 0 ; for ( final Set < E > item : all ) { size += item . size () ; MST[rv.UOI2Mutator]MSP[N] } return size ; } @Override public boolean isEmpty () {
} public void setMutator ( final SetMutator < E > mutator ) { this . mutator = mutator ; } public synchronized void addComposited ( final Set < E > set ) { if ( set != null ) { MST[rv.ROR5Mutator]MSP[N]
public void addComposited ( final Set < E > ... sets ) { if ( sets != null ) { for ( final Set < E > set : sets ) { MST[rv.UOI1Mutator]MSP[N] addComposited ( set ) ; } } }
final Set < ? > set = ( Set < ? > ) obj ; return set . size () == this . size () && set . containsAll ( this ) ; } return false ; } @Override public int hashCode () { int code = 0 ; MST[InlineConstantMutator]MSP[N]
return UnmodifiableList . unmodifiableList ( all ) ; } protected SetMutator < E > getMutator () { return mutator ; } @Override public boolean equals ( final Object obj ) { if ( obj instanceof Set ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
for ( final Set < E > item : all ) { if ( item . isEmpty () == false ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return false ; } } return true ; } @Override public boolean contains ( final Object obj ) {
for ( final Collection < E > item : all ) { for ( final E e : item ) { result [ offset ++ ] = e ; } } if ( result . length > size ) { MST[rv.ROR5Mutator]MSP[N] result [ size ] = null ; }
for ( final Set < E > existingSet : getSets () ) { final Collection < E > intersects = CollectionUtils . intersection ( existingSet , set ) ; if ( intersects . size () > 0 ) { MST[rv.ROR3Mutator]MSP[N] if ( this . mutator == null ) {
for ( final Collection < E > item : all ) { changed |= item . retainAll ( coll ) ; MST[rv.OBBN2Mutator]MSP[S] } return changed ; } @Override public void clear () { for ( final Collection < E > coll : all ) { coll . clear () ; }
} public void setMutator ( final SetMutator < E > mutator ) { this . mutator = mutator ; MST[experimental.MemberVariableMutator]MSP[N] } public synchronized void addComposited ( final Set < E > set ) { if ( set != null ) {
public void addComposited ( final Set < E > ... sets ) { if ( sets != null ) { for ( final Set < E > set : sets ) { MST[rv.UOI4Mutator]MSP[N] addComposited ( set ) ; } } }
return UnmodifiableList . unmodifiableList ( all ) ; } protected SetMutator < E > getMutator () { return mutator ; } @Override public boolean equals ( final Object obj ) { if ( obj instanceof Set ) { MST[rv.ROR3Mutator]MSP[N]
public boolean containsAll ( final Collection < ? > coll ) { if ( coll == null ) { return false ; } for ( final Object item : coll ) { if ( contains ( item ) == false ) { MST[NegateConditionalsMutator]MSP[N] return false ; } } return true ;
for ( final Collection < E > item : all ) { for ( final E e : item ) { result [ offset ++ ] = e ; } } if ( result . length > size ) { MST[rv.UOI1Mutator]MSP[S] result [ size ] = null ; }
final Set < ? > set = ( Set < ? > ) obj ; return set . size () == this . size () && set . containsAll ( this ) ; MST[NegateConditionalsMutator]MSP[N] } return false ; } @Override public int hashCode () { int code = 0 ;
for ( final Set < E > item : all ) { if ( item . isEmpty () == false ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return false ; } } return true ; } @Override public boolean contains ( final Object obj ) {
for ( final Collection < E > item : all ) { changed |= item . retainAll ( coll ) ; MST[rv.UOI2Mutator]MSP[N] } return changed ; } @Override public void clear () { for ( final Collection < E > coll : all ) { coll . clear () ; }
for ( final Set < E > existingSet : getSets () ) { final Collection < E > intersects = CollectionUtils . intersection ( existingSet , set ) ; if ( intersects . size () > 0 ) { MST[NonVoidMethodCallMutator]MSP[N] if ( this . mutator == null ) {
public Object [] toArray () { final Object [] result = new Object [ size () ] ; int i = 0 ; for ( final Iterator < E > it = iterator () ; it . hasNext () ; i ++ ) { MST[NegateConditionalsMutator]MSP[N]
if ( array . length >= size ) { MST[rv.ROR1Mutator]MSP[N] result = array ; } else { result = ( Object [] ) Array . newInstance ( array . getClass () . getComponentType () , size ) ; } int offset = 0 ;
if ( array . length >= size ) { MST[rv.ROR3Mutator]MSP[N] result = array ; } else { result = ( Object [] ) Array . newInstance ( array . getClass () . getComponentType () , size ) ; } int offset = 0 ;
if ( array . length >= size ) { result = array ; } else { result = ( Object [] ) Array . newInstance ( array . getClass () . getComponentType () , size ) ; } int offset = 0 ; MST[rv.CRCR3Mutator]MSP[N]
@Override public int size () { int size = 0 ; for ( final Set < E > item : all ) { size += item . size () ; MST[NonVoidMethodCallMutator]MSP[N] } return size ; } @Override public boolean isEmpty () {
for ( final Collection < E > item : all ) { for ( final E e : item ) { result [ offset ++ ] = e ; MST[rv.UOI1Mutator]MSP[S] } } if ( result . length > size ) { result [ size ] = null ; }
public boolean remove ( final Object obj ) { for ( final Set < E > set : getSets () ) { if ( set . contains ( obj ) ) { MST[rv.ROR2Mutator]MSP[N] return set . remove ( obj ) ; } } return false ; } @Override
throw new UnsupportedOperationException ( lr_4 ) ; } getMutator () . resolveCollision ( this , existingSet , set , intersects ) ; if ( CollectionUtils . intersection ( existingSet , set ) . size () > 0 ) { MST[NegateConditionalsMutator]MSP[S] throw new IllegalArgumentException ( lr_5 ) ; } } }
for ( final E e : this ) { code += e == null ? 0 : e . hashCode () ; MST[InlineConstantMutator]MSP[N] } return code ; }
for ( final Set < E > item : all ) { if ( item . isEmpty () == false ) { return false ; MST[BooleanTrueReturnValsMutator]MSP[N] } } return true ; } @Override public boolean contains ( final Object obj ) {
changed |= item . removeIf ( filter ) ; } return changed ; } @Override public boolean removeAll ( final Collection < ? > coll ) { if ( CollectionUtils . isEmpty ( coll ) ) { return false ; } boolean changed = false ; MST[rv.CRCR3Mutator]MSP[S]
return UnmodifiableList . unmodifiableList ( all ) ; } protected SetMutator < E > getMutator () { return mutator ; } @Override public boolean equals ( final Object obj ) { if ( obj instanceof Set ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S]
final Set < ? > set = ( Set < ? > ) obj ; return set . size () == this . size () && set . containsAll ( this ) ; } return false ; MST[rv.CRCR3Mutator]MSP[S] } @Override public int hashCode () { int code = 0 ;
for ( final Collection < E > item : all ) { changed |= item . retainAll ( coll ) ; } return changed ; MST[ReturnValsMutator]MSP[S] } @Override public void clear () { for ( final Collection < E > coll : all ) { coll . clear () ; }
for ( final Set < E > existingSet : getSets () ) { final Collection < E > intersects = CollectionUtils . intersection ( existingSet , set ) ; if ( intersects . size () > 0 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] if ( this . mutator == null ) {
for ( final Set < E > item : all ) { if ( item . contains ( obj ) ) { return true ; MST[InlineConstantMutator]MSP[N] } } return false ; } @Override public Iterator < E > iterator () { if ( all . isEmpty () ) {
for ( final Collection < E > item : all ) { changed |= item . retainAll ( coll ) ; } return changed ; MST[BooleanTrueReturnValsMutator]MSP[N] } @Override public void clear () { for ( final Collection < E > coll : all ) { coll . clear () ; }
public void addComposited ( final Set < E > ... sets ) { if ( sets != null ) { for ( final Set < E > set : sets ) { addComposited ( set ) ; MST[VoidMethodCallMutator]MSP[N] } } }
final Set < ? > set = ( Set < ? > ) obj ; return set . size () == this . size () && set . containsAll ( this ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } return false ; } @Override public int hashCode () { int code = 0 ;
final Set < ? > set = ( Set < ? > ) obj ; return set . size () == this . size () && set . containsAll ( this ) ; MST[rv.CRCR4Mutator]MSP[N] } return false ; } @Override public int hashCode () { int code = 0 ;
public boolean containsAll ( final Collection < ? > coll ) { if ( coll == null ) { return false ; } for ( final Object item : coll ) { if ( contains ( item ) == false ) { return false ; } } return true ; MST[rv.CRCR6Mutator]MSP[N]
for ( final Collection < E > item : all ) { for ( final E e : item ) { result [ offset ++ ] = e ; } } if ( result . length > size ) { MST[rv.ROR4Mutator]MSP[N] result [ size ] = null ; }
public Object [] toArray () { final Object [] result = new Object [ size () ] ; int i = 0 ; for ( final Iterator < E > it = iterator () ; it . hasNext () ; i ++ ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
for ( final Set < E > item : all ) { if ( item . isEmpty () == false ) { return false ; MST[ReturnValsMutator]MSP[N] } } return true ; } @Override public boolean contains ( final Object obj ) {
for ( final Set < E > item : all ) { if ( item . isEmpty () == false ) { return false ; } } return true ; MST[rv.CRCR3Mutator]MSP[N] } @Override public boolean contains ( final Object obj ) {
for ( final Collection < E > item : all ) { for ( final E e : item ) { result [ offset ++ ] = e ; } } if ( result . length > size ) { result [ size ] = null ; MST[rv.UOI2Mutator]MSP[N] }
for ( final Collection < E > item : all ) { for ( final E e : item ) { result [ offset ++ ] = e ; } } if ( result . length > size ) { result [ size ] = null ; MST[rv.UOI4Mutator]MSP[N] }
for ( final E e : this ) { code += e == null ? 0 : e . hashCode () ; MST[rv.AOD1Mutator]MSP[N] } return code ; }
final Set < ? > set = ( Set < ? > ) obj ; return set . size () == this . size () && set . containsAll ( this ) ; } return false ; MST[rv.CRCR1Mutator]MSP[S] } @Override public int hashCode () { int code = 0 ;
@Override MST[experimental.MemberVariableMutator]MSP[N] public int size () { int size = 0 ; for ( final Set < E > item : all ) { size += item . size () ; } return size ; } @Override public boolean isEmpty () {
if ( array . length >= size ) { result = array ; } else { result = ( Object [] ) Array . newInstance ( array . getClass () . getComponentType () , size ) ; MST[rv.UOI3Mutator]MSP[S] } int offset = 0 ;
return UnmodifiableList . unmodifiableList ( all ) ; } protected SetMutator < E > getMutator () { return mutator ; } @Override public boolean equals ( final Object obj ) { if ( obj instanceof Set ) { MST[NegateConditionalsMutator]MSP[N]
for ( final Set < E > item : all ) { if ( item . isEmpty () == false ) { MST[NegateConditionalsMutator]MSP[N] return false ; } } return true ; } @Override public boolean contains ( final Object obj ) {
if ( array . length >= size ) { result = array ; } else { result = ( Object [] ) Array . newInstance ( array . getClass () . getComponentType () , size ) ; MST[NonVoidMethodCallMutator]MSP[S] } int offset = 0 ;
} @Override public boolean addAll ( final Collection < ? extends E > coll ) { if ( mutator == null ) { throw new UnsupportedOperationException ( lr_3 ) ; } return mutator . addAll ( this , all , coll ) ; MST[BooleanTrueReturnValsMutator]MSP[S] } @Override
for ( final Set < E > existingSet : getSets () ) { final Collection < E > intersects = CollectionUtils . intersection ( existingSet , set ) ; if ( intersects . size () > 0 ) { if ( this . mutator == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
changed |= item . removeIf ( filter ) ; MST[rv.UOI2Mutator]MSP[N] } return changed ; } @Override public boolean removeAll ( final Collection < ? > coll ) { if ( CollectionUtils . isEmpty ( coll ) ) { return false ; } boolean changed = false ;
public boolean containsAll ( final Collection < ? > coll ) { if ( coll == null ) { return false ; } for ( final Object item : coll ) { if ( contains ( item ) == false ) { MST[rv.ROR2Mutator]MSP[N] return false ; } } return true ;
all . add ( set ) ; } } public void addComposited ( final Set < E > set1 , final Set < E > set2 ) { addComposited ( set1 ) ; addComposited ( set2 ) ; MST[VoidMethodCallMutator]MSP[S] }
final Set < ? > set = ( Set < ? > ) obj ; return set . size () == this . size () && set . containsAll ( this ) ; MST[rv.ROR5Mutator]MSP[N] } return false ; } @Override public int hashCode () { int code = 0 ;
public Object [] toArray () { final Object [] result = new Object [ size () ] ; int i = 0 ; for ( final Iterator < E > it = iterator () ; it . hasNext () ; i ++ ) { MST[rv.ROR5Mutator]MSP[N]
final Set < ? > set = ( Set < ? > ) obj ; return set . size () == this . size () && set . containsAll ( this ) ; MST[InlineConstantMutator]MSP[N] } return false ; } @Override public int hashCode () { int code = 0 ;
final Set < ? > set = ( Set < ? > ) obj ; return set . size () == this . size () && set . containsAll ( this ) ; MST[rv.ROR2Mutator]MSP[N] } return false ; } @Override public int hashCode () { int code = 0 ;
for ( final Set < E > existingSet : getSets () ) { final Collection < E > intersects = CollectionUtils . intersection ( existingSet , set ) ; if ( intersects . size () > 0 ) { if ( this . mutator == null ) { MST[rv.ROR5Mutator]MSP[N]
for ( final E e : this ) { code += e == null ? 0 : e . hashCode () ; } return code ; MST[rv.UOI2Mutator]MSP[N] }
for ( final Collection < E > item : all ) { for ( final E e : item ) { result [ offset ++ ] = e ; } } if ( result . length > size ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[S] result [ size ] = null ; }
result [ i ] = it . next () ; MST[rv.UOI3Mutator]MSP[N] } return result ; } @Override @SuppressWarnings ( lr_1 ) public < T > T [] toArray ( final T [] array ) { final int size = size () ; Object [] result = null ;
public boolean containsAll ( final Collection < ? > coll ) { if ( coll == null ) { return false ; MST[rv.CRCR6Mutator]MSP[S] } for ( final Object item : coll ) { if ( contains ( item ) == false ) { return false ; } } return true ;
changed |= item . removeIf ( filter ) ; MST[rv.OBBN1Mutator]MSP[S] } return changed ; } @Override public boolean removeAll ( final Collection < ? > coll ) { if ( CollectionUtils . isEmpty ( coll ) ) { return false ; } boolean changed = false ;
public void removeComposited ( final Set < E > set ) { all . remove ( set ) ; } public Set < E > toSet () { return new HashSet <> ( this ) ; MST[ConstructorCallMutator]MSP[S] } public List < Set < E > > getSets () {
} public void setMutator ( final SetMutator < E > mutator ) { this . mutator = mutator ; } public synchronized void addComposited ( final Set < E > set ) { if ( set != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
return ( T [] ) result ; } @Override public boolean add ( final E obj ) { if ( mutator == null ) { throw new UnsupportedOperationException ( lr_2 ) ; } return mutator . add ( this , all , obj ) ; MST[ReturnValsMutator]MSP[S] } @Override
for ( final E e : this ) { code += e == null ? 0 : e . hashCode () ; MST[NegateConditionalsMutator]MSP[N] } return code ; }
return ( T [] ) result ; MST[NullReturnValsMutator]MSP[N] } @Override public boolean add ( final E obj ) { if ( mutator == null ) { throw new UnsupportedOperationException ( lr_2 ) ; } return mutator . add ( this , all , obj ) ; } @Override
for ( final Set < E > item : all ) { if ( item . isEmpty () == false ) { return false ; MST[rv.CRCR5Mutator]MSP[N] } } return true ; } @Override public boolean contains ( final Object obj ) {
changed |= item . removeIf ( filter ) ; } return changed ; MST[rv.UOI1Mutator]MSP[N] } @Override public boolean removeAll ( final Collection < ? > coll ) { if ( CollectionUtils . isEmpty ( coll ) ) { return false ; } boolean changed = false ;
return UnmodifiableList . unmodifiableList ( all ) ; } protected SetMutator < E > getMutator () { return mutator ; } @Override public boolean equals ( final Object obj ) { if ( obj instanceof Set ) { MST[rv.ROR5Mutator]MSP[N]
for ( final Collection < E > item : all ) { for ( final E e : item ) { result [ offset ++ ] = e ; } } if ( result . length > size ) { result [ size ] = null ; MST[rv.ABSMutator]MSP[N] }
for ( final Set < E > item : all ) { if ( item . isEmpty () == false ) { MST[rv.ROR5Mutator]MSP[N] return false ; } } return true ; } @Override public boolean contains ( final Object obj ) {
for ( final E e : this ) { code += e == null ? 0 : e . hashCode () ; MST[rv.AOR3Mutator]MSP[N] } return code ; }
for ( final Collection < E > item : all ) { changed |= item . retainAll ( coll ) ; MST[NonVoidMethodCallMutator]MSP[S] } return changed ; } @Override public void clear () { for ( final Collection < E > coll : all ) { coll . clear () ; }
all . add ( set ) ; MST[NonVoidMethodCallMutator]MSP[N] } } public void addComposited ( final Set < E > set1 , final Set < E > set2 ) { addComposited ( set1 ) ; addComposited ( set2 ) ; }
changed |= item . removeIf ( filter ) ; MST[rv.ABSMutator]MSP[N] } return changed ; } @Override public boolean removeAll ( final Collection < ? > coll ) { if ( CollectionUtils . isEmpty ( coll ) ) { return false ; } boolean changed = false ;
changed |= item . removeIf ( filter ) ; } return changed ; } @Override public boolean removeAll ( final Collection < ? > coll ) { if ( CollectionUtils . isEmpty ( coll ) ) { return false ; } boolean changed = false ; MST[InlineConstantMutator]MSP[S]
for ( final E e : this ) { code += e == null ? 0 : e . hashCode () ; MST[rv.CRCR3Mutator]MSP[N] } return code ; }
for ( final Set < E > item : all ) { if ( item . contains ( obj ) ) { return true ; } } return false ; MST[rv.CRCR1Mutator]MSP[N] } @Override public Iterator < E > iterator () { if ( all . isEmpty () ) {
return UnmodifiableList . unmodifiableList ( all ) ; MST[EmptyObjectReturnValsMutator]MSP[N] } protected SetMutator < E > getMutator () { return mutator ; } @Override public boolean equals ( final Object obj ) { if ( obj instanceof Set ) {
for ( final Collection < E > item : all ) { for ( final E e : item ) { result [ offset ++ ] = e ; } } if ( result . length > size ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] result [ size ] = null ; }
public boolean removeIf ( final Predicate < ? super E > filter ) { if ( Objects . isNull ( filter ) ) { return false ; MST[rv.CRCR1Mutator]MSP[S] } boolean changed = false ; for ( final Collection < E > item : all ) {
public Object [] toArray () { final Object [] result = new Object [ size () ] ; MST[NonVoidMethodCallMutator]MSP[N] int i = 0 ; for ( final Iterator < E > it = iterator () ; it . hasNext () ; i ++ ) {
for ( final Collection < E > item : all ) { for ( final E e : item ) { result [ offset ++ ] = e ; } } if ( result . length > size ) { MST[NegateConditionalsMutator]MSP[N] result [ size ] = null ; }
for ( final Set < E > item : all ) { if ( item . contains ( obj ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return true ; } } return false ; } @Override public Iterator < E > iterator () { if ( all . isEmpty () ) {
} @Override public boolean addAll ( final Collection < ? extends E > coll ) { if ( mutator == null ) { MST[rv.ROR5Mutator]MSP[N] throw new UnsupportedOperationException ( lr_3 ) ; } return mutator . addAll ( this , all , coll ) ; } @Override
final Set < ? > set = ( Set < ? > ) obj ; return set . size () == this . size () && set . containsAll ( this ) ; } return false ; } @Override public int hashCode () { int code = 0 ; MST[rv.CRCR1Mutator]MSP[N]
throw new UnsupportedOperationException ( lr_4 ) ; } getMutator () . resolveCollision ( this , existingSet , set , intersects ) ; MST[NonVoidMethodCallMutator]MSP[S] if ( CollectionUtils . intersection ( existingSet , set ) . size () > 0 ) { throw new IllegalArgumentException ( lr_5 ) ; } } }
public boolean removeIf ( final Predicate < ? super E > filter ) { if ( Objects . isNull ( filter ) ) { MST[rv.ROR1Mutator]MSP[S] return false ; } boolean changed = false ; for ( final Collection < E > item : all ) {
public boolean removeIf ( final Predicate < ? super E > filter ) { if ( Objects . isNull ( filter ) ) { MST[rv.ROR2Mutator]MSP[N] return false ; } boolean changed = false ; for ( final Collection < E > item : all ) {
for ( final Set < E > existingSet : getSets () ) { final Collection < E > intersects = CollectionUtils . intersection ( existingSet , set ) ; if ( intersects . size () > 0 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] if ( this . mutator == null ) {
@Override public int size () { int size = 0 ; for ( final Set < E > item : all ) { size += item . size () ; } return size ; MST[rv.UOI4Mutator]MSP[N] } @Override public boolean isEmpty () {
public boolean remove ( final Object obj ) { for ( final Set < E > set : getSets () ) { if ( set . contains ( obj ) ) { return set . remove ( obj ) ; } } return false ; MST[ReturnValsMutator]MSP[S] } @Override
for ( final Collection < E > item : all ) { changed |= item . removeAll ( coll ) ; MST[rv.UOI3Mutator]MSP[S] } return changed ; } @Override public boolean retainAll ( final Collection < ? > coll ) { boolean changed = false ;
for ( final Set < E > item : all ) { if ( item . contains ( obj ) ) { MST[rv.ROR4Mutator]MSP[N] return true ; } } return false ; } @Override public Iterator < E > iterator () { if ( all . isEmpty () ) {
for ( final Collection < E > item : all ) { changed |= item . removeAll ( coll ) ; MST[rv.ABSMutator]MSP[N] } return changed ; } @Override public boolean retainAll ( final Collection < ? > coll ) { boolean changed = false ;
for ( final Collection < E > item : all ) { changed |= item . removeAll ( coll ) ; } return changed ; MST[rv.UOI2Mutator]MSP[N] } @Override public boolean retainAll ( final Collection < ? > coll ) { boolean changed = false ;
return ( T [] ) result ; } @Override public boolean add ( final E obj ) { if ( mutator == null ) { throw new UnsupportedOperationException ( lr_2 ) ; } return mutator . add ( this , all , obj ) ; MST[BooleanTrueReturnValsMutator]MSP[N] } @Override
for ( final Collection < E > item : all ) { changed |= item . retainAll ( coll ) ; MST[rv.OBBN3Mutator]MSP[N] } return changed ; } @Override public void clear () { for ( final Collection < E > coll : all ) { coll . clear () ; }
for ( final Set < E > item : all ) { if ( item . contains ( obj ) ) { return true ; } } return false ; } @Override public Iterator < E > iterator () { if ( all . isEmpty () ) { MST[rv.ROR2Mutator]MSP[N]
for ( final Set < E > item : all ) { if ( item . contains ( obj ) ) { MST[NegateConditionalsMutator]MSP[N] return true ; } } return false ; } @Override public Iterator < E > iterator () { if ( all . isEmpty () ) {
return ( T [] ) result ; } @Override public boolean add ( final E obj ) { if ( mutator == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] throw new UnsupportedOperationException ( lr_2 ) ; } return mutator . add ( this , all , obj ) ; } @Override
final Set < ? > set = ( Set < ? > ) obj ; return set . size () == this . size () && set . containsAll ( this ) ; MST[ReturnValsMutator]MSP[N] } return false ; } @Override public int hashCode () { int code = 0 ;
for ( final Set < E > item : all ) { if ( item . isEmpty () == false ) { MST[NonVoidMethodCallMutator]MSP[N] return false ; } } return true ; } @Override public boolean contains ( final Object obj ) {
public boolean removeIf ( final Predicate < ? super E > filter ) { if ( Objects . isNull ( filter ) ) { return false ; } boolean changed = false ; MST[InlineConstantMutator]MSP[N] for ( final Collection < E > item : all ) {
for ( final Set < E > existingSet : getSets () ) { final Collection < E > intersects = CollectionUtils . intersection ( existingSet , set ) ; if ( intersects . size () > 0 ) { MST[rv.ROR4Mutator]MSP[N] if ( this . mutator == null ) {
} @Override public boolean addAll ( final Collection < ? extends E > coll ) { if ( mutator == null ) { throw new UnsupportedOperationException ( lr_3 ) ; } return mutator . addAll ( this , all , coll ) ; MST[NonVoidMethodCallMutator]MSP[N] } @Override
throw new UnsupportedOperationException ( MST[ConstructorCallMutator]MSP[N] lr_4 ) ; } getMutator () . resolveCollision ( this , existingSet , set , intersects ) ; if ( CollectionUtils . intersection ( existingSet , set ) . size () > 0 ) { throw new IllegalArgumentException ( lr_5 ) ; } } }
return ( T [] ) result ; } @Override public boolean add ( final E obj ) { if ( mutator == null ) { MST[rv.ROR5Mutator]MSP[N] throw new UnsupportedOperationException ( lr_2 ) ; } return mutator . add ( this , all , obj ) ; } @Override
changed |= item . removeIf ( filter ) ; } return changed ; } @Override public boolean removeAll ( final Collection < ? > coll ) { if ( CollectionUtils . isEmpty ( coll ) ) { MST[rv.ROR2Mutator]MSP[N] return false ; } boolean changed = false ;
for ( final Collection < E > item : all ) { changed |= item . removeAll ( coll ) ; } return changed ; } @Override public boolean retainAll ( final Collection < ? > coll ) { boolean changed = false ; MST[rv.CRCR6Mutator]MSP[N]
for ( final E e : this ) { code += e == null ? 0 : e . hashCode () ; MST[rv.UOI1Mutator]MSP[N] } return code ; }
changed |= item . removeIf ( filter ) ; MST[rv.UOI3Mutator]MSP[N] } return changed ; } @Override public boolean removeAll ( final Collection < ? > coll ) { if ( CollectionUtils . isEmpty ( coll ) ) { return false ; } boolean changed = false ;
public Object [] toArray () { final Object [] result = new Object [ size () ] ; int i = 0 ; for ( final Iterator < E > it = iterator () ; it . hasNext () ; i ++ ) { MST[rv.ROR4Mutator]MSP[N]
public boolean removeIf ( final Predicate < ? super E > filter ) { if ( Objects . isNull ( filter ) ) { return false ; } boolean changed = false ; MST[rv.CRCR3Mutator]MSP[N] for ( final Collection < E > item : all ) {
@Override public int size () { int size = 0 ; for ( final Set < E > item : all ) { size += item . size () ; } return size ; MST[ReturnValsMutator]MSP[N] } @Override public boolean isEmpty () {
final Set < ? > set = ( Set < ? > ) obj ; return set . size () == this . size () && set . containsAll ( this ) ; MST[rv.ROR4Mutator]MSP[N] } return false ; } @Override public int hashCode () { int code = 0 ;
public Object [] toArray () { final Object [] result = new Object [ size () ] ; int i = 0 ; MST[rv.CRCR5Mutator]MSP[N] for ( final Iterator < E > it = iterator () ; it . hasNext () ; i ++ ) {
return ( T [] ) result ; } @Override public boolean add ( final E obj ) { if ( mutator == null ) { throw new UnsupportedOperationException ( MST[ConstructorCallMutator]MSP[S] lr_2 ) ; } return mutator . add ( this , all , obj ) ; } @Override
final Set < ? > set = ( Set < ? > ) obj ; return set . size () == this . size () && set . containsAll ( this ) ; MST[rv.ROR3Mutator]MSP[N] } return false ; } @Override public int hashCode () { int code = 0 ;
@Override public int size () { int size = 0 ; for ( final Set < E > item : all ) { size += item . size () ; MST[rv.AOR1Mutator]MSP[N] } return size ; } @Override public boolean isEmpty () {
public boolean containsAll ( final Collection < ? > coll ) { if ( coll == null ) { return false ; } for ( final Object item : coll ) { if ( contains ( item ) == false ) { return false ; MST[rv.CRCR3Mutator]MSP[S] } } return true ;
public boolean containsAll ( final Collection < ? > coll ) { if ( coll == null ) { return false ; } for ( final Object item : coll ) { if ( contains ( item ) == false ) { return false ; MST[InlineConstantMutator]MSP[S] } } return true ;
throw new UnsupportedOperationException ( lr_4 ) ; } getMutator () . resolveCollision ( this , existingSet , set , intersects ) ; if ( CollectionUtils . intersection ( existingSet , set ) . size () > 0 ) { MST[rv.ROR3Mutator]MSP[S] throw new IllegalArgumentException ( lr_5 ) ; } } }
public void addComposited ( final Set < E > ... sets ) { if ( sets != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] for ( final Set < E > set : sets ) { addComposited ( set ) ; } } }
for ( final Set < E > item : all ) { if ( item . contains ( obj ) ) { return true ; MST[rv.CRCR4Mutator]MSP[N] } } return false ; } @Override public Iterator < E > iterator () { if ( all . isEmpty () ) {
@Override public int size () { int size = 0 ; MST[rv.CRCR1Mutator]MSP[N] for ( final Set < E > item : all ) { size += item . size () ; } return size ; } @Override public boolean isEmpty () {
public boolean containsAll ( final Collection < ? > coll ) { if ( coll == null ) { return false ; MST[ReturnValsMutator]MSP[S] } for ( final Object item : coll ) { if ( contains ( item ) == false ) { return false ; } } return true ;
@Override public int size () { int size = 0 ; MST[rv.CRCR6Mutator]MSP[N] for ( final Set < E > item : all ) { size += item . size () ; } return size ; } @Override public boolean isEmpty () {
public boolean remove ( final Object obj ) { for ( final Set < E > set : getSets () ) { if ( set . contains ( obj ) ) { return set . remove ( obj ) ; } } return false ; MST[rv.CRCR5Mutator]MSP[S] } @Override
for ( final E e : this ) { code += e == null ? 0 : e . hashCode () ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } return code ; }
for ( final Set < E > item : all ) { if ( item . isEmpty () == false ) { return false ; } } return true ; MST[rv.CRCR2Mutator]MSP[N] } @Override public boolean contains ( final Object obj ) {
public Object [] toArray () { final Object [] result = new Object [ size () ] ; int i = 0 ; for ( final Iterator < E > it = iterator () ; it . hasNext () ; i ++ ) { MST[experimental.RemoveIncrementsMutator]MSP[N]
for ( final Set < E > item : all ) { if ( item . contains ( obj ) ) { return true ; MST[BooleanFalseReturnValsMutator]MSP[N] } } return false ; } @Override public Iterator < E > iterator () { if ( all . isEmpty () ) {
public void addComposited ( final Set < E > ... sets ) { if ( sets != null ) { for ( final Set < E > set : sets ) { MST[rv.UOI1Mutator]MSP[N] addComposited ( set ) ; } } }
for ( final Collection < E > item : all ) { for ( final E e : item ) { result [ offset ++ ] = e ; } } if ( result . length > size ) { result [ size ] = null ; MST[rv.UOI3Mutator]MSP[S] }
} @Override public boolean addAll ( final Collection < ? extends E > coll ) { if ( mutator == null ) { throw new UnsupportedOperationException ( lr_3 ) ; } return mutator . addAll ( this , all , coll ) ; MST[BooleanFalseReturnValsMutator]MSP[S] } @Override
for ( final Collection < E > item : all ) { changed |= item . retainAll ( coll ) ; MST[MathMutator]MSP[S] } return changed ; } @Override public void clear () { for ( final Collection < E > coll : all ) { coll . clear () ; }
if ( array . length >= size ) { result = array ; } else { result = ( Object [] ) Array . newInstance ( array . getClass () . getComponentType () , size ) ; MST[rv.UOI4Mutator]MSP[S] } int offset = 0 ;
public boolean remove ( final Object obj ) { for ( final Set < E > set : getSets () ) { if ( set . contains ( obj ) ) { return set . remove ( obj ) ; } } return false ; MST[BooleanTrueReturnValsMutator]MSP[S] } @Override
final Set < ? > set = ( Set < ? > ) obj ; return set . size () == this . size () && set . containsAll ( this ) ; MST[rv.CRCR5Mutator]MSP[N] } return false ; } @Override public int hashCode () { int code = 0 ;
for ( final Collection < E > item : all ) { changed |= item . removeAll ( coll ) ; } return changed ; } @Override public boolean retainAll ( final Collection < ? > coll ) { boolean changed = false ; MST[rv.CRCR1Mutator]MSP[N]
