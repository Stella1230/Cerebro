if ( ! containsKey ( key ) ) { return EmptyIterator . <V > emptyIterator () ; } return new ValuesIterator ( key ) ; } @Override public V getValue () { MST[NegateConditionalsMutator]MSP[] return input ; } @Override public V setValue ( final V value ) {
if ( ! containsKey ( key ) ) { return EmptyIterator . <V > emptyIterator () ; } return new ValuesIterator ( key ) ; } @Override public V getValue () { MST[rv.ROR2Mutator]MSP[] return input ; } @Override public V setValue ( final V value ) {
if ( ! containsKey ( key ) ) { return EmptyIterator . <V > emptyIterator () ; } return new ValuesIterator ( key ) ; } @Override MST[ReturnValsMutator]MSP[] public V getValue () { return input ; } @Override public V setValue ( final V value ) {
if ( ! containsKey ( key ) ) { return EmptyIterator . <V > emptyIterator () ; } return new ValuesIterator ( key ) ; } @Override public V getValue () { MST[rv.ROR4Mutator]MSP[] return input ; } @Override public V setValue ( final V value ) {
if ( ! containsKey ( key ) ) { return EmptyIterator . <V > emptyIterator () ; } return new ValuesIterator ( key ) ; } @Override public V getValue () { MST[rv.ROR5Mutator]MSP[] return input ; } @Override public V setValue ( final V value ) {
if ( ! containsKey ( key ) ) { return EmptyIterator . <V > emptyIterator () ; } return new ValuesIterator ( key ) ; } @Override public V getValue () { MST[rv.ROR3Mutator]MSP[] return input ; } @Override public V setValue ( final V value ) {
if ( ! containsKey ( key ) ) { return EmptyIterator . <V > emptyIterator () ; } return new ValuesIterator ( key ) ; } @Override public V getValue () { MST[rv.ROR1Mutator]MSP[] return input ; } @Override public V setValue ( final V value ) {
if ( ! containsKey ( key ) ) { return EmptyIterator . <V > emptyIterator () ; } return new ValuesIterator ( key ) ; } @Override public V getValue () { MST[NonVoidMethodCallMutator]MSP[] return input ; } @Override public V setValue ( final V value ) {
if ( ! containsKey ( key ) ) { return EmptyIterator . <V > emptyIterator () ; } return new ValuesIterator ( key ) ; } @Override public V getValue () { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return input ; } @Override public V setValue ( final V value ) {
if ( ! containsKey ( key ) ) { return EmptyIterator . <V > emptyIterator () ; } return new ValuesIterator ( key ) ; } @Override MST[NullReturnValsMutator]MSP[] public V getValue () { return input ; } @Override public V setValue ( final V value ) {
if ( ! containsKey ( key ) ) { return EmptyIterator . <V > emptyIterator () ; } return new ValuesIterator ( key ) ; } @Override MST[ConstructorCallMutator]MSP[] public V getValue () { return input ; } @Override public V setValue ( final V value ) {
throw new UnsupportedOperationException () ; } public int totalSize () { MST[experimental.MemberVariableMutator]MSP[] int total = 0 ; for ( final Object v : decorated () . values () ) { total += CollectionUtils . size ( v ) ; } return total ; }
if ( ! containsKey ( key ) ) { return EmptyIterator . <V > emptyIterator () ; } return new ValuesIterator ( key ) ; } @Override public V getValue () { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return input ; } @Override public V setValue ( final V value ) {
throw new UnsupportedOperationException () ; } public int totalSize () { MST[experimental.MemberVariableMutator]MSP[] int total = 0 ; for ( final Object v : decorated () . values () ) { total += CollectionUtils . size ( v ) ; } return total ; }
iterator . remove () ; if ( values . isEmpty () ) { MultiValueMap . this . remove ( key ) ; } } @Override public boolean hasNext () { return iterator . hasNext () ; MST[NonVoidMethodCallMutator]MSP[] } @Override public V next () { return iterator . next () ; }
iterator . remove () ; if ( values . isEmpty () ) { MultiValueMap . this . remove ( key ) ; } } @Override public boolean hasNext () { return iterator . hasNext () ; MST[BooleanFalseReturnValsMutator]MSP[] } @Override public V next () { return iterator . next () ; }
iterator . remove () ; if ( values . isEmpty () ) { MultiValueMap . this . remove ( key ) ; MST[ArgumentPropagationMutator]MSP[] } } @Override public boolean hasNext () { return iterator . hasNext () ; } @Override public V next () { return iterator . next () ; }
iterator . remove () ; if ( values . isEmpty () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] MultiValueMap . this . remove ( key ) ; } } @Override public boolean hasNext () { return iterator . hasNext () ; } @Override public V next () { return iterator . next () ; }
iterator . remove () ; if ( values . isEmpty () ) { MultiValueMap . this . remove ( key ) ; } } @Override public boolean hasNext () { return iterator . hasNext () ; } @Override public V next () { return iterator . next () ; MST[ReturnValsMutator]MSP[] }
iterator . remove () ; if ( values . isEmpty () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] MultiValueMap . this . remove ( key ) ; } } @Override public boolean hasNext () { return iterator . hasNext () ; } @Override public V next () { return iterator . next () ; }
iterator . remove () ; if ( values . isEmpty () ) { MultiValueMap . this . remove ( key ) ; } } @Override public boolean hasNext () { return iterator . hasNext () ; MST[BooleanTrueReturnValsMutator]MSP[] } @Override public V next () { return iterator . next () ; }
iterator . remove () ; if ( values . isEmpty () ) { MultiValueMap . this . remove ( key ) ; } } @Override public boolean hasNext () { return iterator . hasNext () ; } @Override public V next () { return iterator . next () ; MST[NullReturnValsMutator]MSP[] }
iterator . remove () ; if ( values . isEmpty () ) { MST[NonVoidMethodCallMutator]MSP[] MultiValueMap . this . remove ( key ) ; } } @Override public boolean hasNext () { return iterator . hasNext () ; } @Override public V next () { return iterator . next () ; }
iterator . remove () ; if ( values . isEmpty () ) { MultiValueMap . this . remove ( key ) ; MST[NonVoidMethodCallMutator]MSP[] } } @Override public boolean hasNext () { return iterator . hasNext () ; } @Override public V next () { return iterator . next () ; }
iterator . remove () ; if ( values . isEmpty () ) { MultiValueMap . this . remove ( key ) ; } } @Override public boolean hasNext () { return iterator . hasNext () ; MST[ReturnValsMutator]MSP[] } @Override public V next () { return iterator . next () ; }
iterator . remove () ; if ( values . isEmpty () ) { MST[NegateConditionalsMutator]MSP[] MultiValueMap . this . remove ( key ) ; } } @Override public boolean hasNext () { return iterator . hasNext () ; } @Override public V next () { return iterator . next () ; }
iterator . remove () ; if ( values . isEmpty () ) { MST[rv.ROR3Mutator]MSP[] MultiValueMap . this . remove ( key ) ; } } @Override public boolean hasNext () { return iterator . hasNext () ; } @Override public V next () { return iterator . next () ; }
iterator . remove () ; MST[VoidMethodCallMutator]MSP[] if ( values . isEmpty () ) { MultiValueMap . this . remove ( key ) ; } } @Override public boolean hasNext () { return iterator . hasNext () ; } @Override public V next () { return iterator . next () ; }
iterator . remove () ; if ( values . isEmpty () ) { MST[rv.ROR5Mutator]MSP[] MultiValueMap . this . remove ( key ) ; } } @Override public boolean hasNext () { return iterator . hasNext () ; } @Override public V next () { return iterator . next () ; }
iterator . remove () ; if ( values . isEmpty () ) { MST[rv.ROR4Mutator]MSP[] MultiValueMap . this . remove ( key ) ; } } @Override public boolean hasNext () { return iterator . hasNext () ; } @Override public V next () { return iterator . next () ; }
iterator . remove () ; if ( values . isEmpty () ) { MST[rv.ROR1Mutator]MSP[] MultiValueMap . this . remove ( key ) ; } } @Override public boolean hasNext () { return iterator . hasNext () ; } @Override public V next () { return iterator . next () ; }
iterator . remove () ; if ( values . isEmpty () ) { MST[rv.ROR2Mutator]MSP[] MultiValueMap . this . remove ( key ) ; } } @Override public boolean hasNext () { return iterator . hasNext () ; } @Override public V next () { return iterator . next () ; }
if ( ! containsKey ( key ) ) { return EmptyIterator . <V > emptyIterator () ; } return new ValuesIterator ( key ) ; } @Override MST[experimental.MemberVariableMutator]MSP[] public V getValue () { return input ; } @Override public V setValue ( final V value ) {
if ( ! containsKey ( key ) ) { return EmptyIterator . <V > emptyIterator () ; } return new ValuesIterator ( key ) ; } @Override public V getValue () { return input ; MST[ReturnValsMutator]MSP[] } @Override public V setValue ( final V value ) {
if ( ! containsKey ( key ) ) { return EmptyIterator . <V > emptyIterator () ; } return new ValuesIterator ( key ) ; } @Override public V getValue () { return input ; MST[NullReturnValsMutator]MSP[] } @Override public V setValue ( final V value ) {
if ( ! containsKey ( key ) ) { return EmptyIterator . <V > emptyIterator () ; } return new ValuesIterator ( key ) ; } @Override MST[experimental.MemberVariableMutator]MSP[] public V getValue () { return input ; } @Override public V setValue ( final V value ) {
if ( ! containsKey ( key ) ) { return EmptyIterator . <V > emptyIterator () ; } return new ValuesIterator ( key ) ; } @Override MST[experimental.MemberVariableMutator]MSP[] public V getValue () { return input ; } @Override public V setValue ( final V value ) {
protected Collection < V > createCollection ( final int size ) { return collectionFactory . create () ; } @Override MST[experimental.MemberVariableMutator]MSP[] public Iterator < V > iterator () { final IteratorChain < V > chain = new IteratorChain <> () ; for ( final K k : keySet () ) {
protected Collection < V > createCollection ( final int size ) { return collectionFactory . create () ; } @Override public Iterator < V > iterator () { final IteratorChain < V > chain = new IteratorChain <> () ; MST[ConstructorCallMutator]MSP[] for ( final K k : keySet () ) {
chain . addIterator ( new ValuesIterator ( k ) ) ; } return chain ; } @Override public int size () { return totalSize () ; MST[ReturnValsMutator]MSP[] } @Override public void clear () { MultiValueMap . this . clear () ; } @Override public void remove () {
protected Collection < V > createCollection ( final int size ) { return collectionFactory . create () ; } @Override public Iterator < V > iterator () { final IteratorChain < V > chain = new IteratorChain <> () ; for ( final K k : keySet () ) { MST[NonVoidMethodCallMutator]MSP[]
chain . addIterator ( new ValuesIterator ( k ) ) ; MST[VoidMethodCallMutator]MSP[] } return chain ; } @Override public int size () { return totalSize () ; } @Override public void clear () { MultiValueMap . this . clear () ; } @Override public void remove () {
chain . addIterator ( new ValuesIterator ( k ) ) ; MST[ConstructorCallMutator]MSP[] } return chain ; } @Override public int size () { return totalSize () ; } @Override public void clear () { MultiValueMap . this . clear () ; } @Override public void remove () {
chain . addIterator ( new ValuesIterator ( k ) ) ; } return chain ; MST[NullReturnValsMutator]MSP[] } @Override public int size () { return totalSize () ; } @Override public void clear () { MultiValueMap . this . clear () ; } @Override public void remove () {
chain . addIterator ( new ValuesIterator ( k ) ) ; } return chain ; } @Override public int size () { return totalSize () ; MST[PrimitiveReturnsMutator]MSP[] } @Override public void clear () { MultiValueMap . this . clear () ; } @Override public void remove () {
chain . addIterator ( new ValuesIterator ( k ) ) ; } return chain ; } @Override public int size () { return totalSize () ; MST[NonVoidMethodCallMutator]MSP[] } @Override public void clear () { MultiValueMap . this . clear () ; } @Override public void remove () {
chain . addIterator ( new ValuesIterator ( k ) ) ; } return chain ; MST[ReturnValsMutator]MSP[] } @Override public int size () { return totalSize () ; } @Override public void clear () { MultiValueMap . this . clear () ; } @Override public void remove () {
@Override public T create () { try { return clazz . getDeclaredConstructor () . newInstance () ; MST[ReturnValsMutator]MSP[] } catch ( final Exception ex ) { throw new FunctorException ( lr_3 + clazz , ex ) ; } }
private void readObject ( final ObjectInputStream is ) throws IOException , ClassNotFoundException { is . defaultReadObject () ; if ( clazz != null && ! Collection . class . isAssignableFrom ( clazz ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] throw new UnsupportedOperationException () ; } }
private void readObject ( final ObjectInputStream is ) throws IOException , ClassNotFoundException { is . defaultReadObject () ; if ( clazz != null && ! Collection . class . isAssignableFrom ( clazz ) ) { MST[NegateConditionalsMutator]MSP[] throw new UnsupportedOperationException () ; } }
private void readObject ( final ObjectInputStream is ) throws IOException , ClassNotFoundException { is . defaultReadObject () ; if ( clazz != null && ! Collection . class . isAssignableFrom ( clazz ) ) { MST[rv.ROR5Mutator]MSP[] throw new UnsupportedOperationException () ; } }
private void readObject ( final ObjectInputStream is ) throws IOException , ClassNotFoundException { is . defaultReadObject () ; if ( clazz != null && ! Collection . class . isAssignableFrom ( clazz ) ) { MST[NegateConditionalsMutator]MSP[] throw new UnsupportedOperationException () ; } }
private void readObject ( final ObjectInputStream is ) throws IOException , ClassNotFoundException { is . defaultReadObject () ; if ( clazz != null && ! Collection . class . isAssignableFrom ( clazz ) ) { MST[rv.ROR5Mutator]MSP[] throw new UnsupportedOperationException () ; } }
private void readObject ( final ObjectInputStream is ) throws IOException , ClassNotFoundException { is . defaultReadObject () ; if ( clazz != null && ! Collection . class . isAssignableFrom ( clazz ) ) { MST[rv.ROR3Mutator]MSP[] throw new UnsupportedOperationException () ; } }
private void readObject ( final ObjectInputStream is ) throws IOException , ClassNotFoundException { is . defaultReadObject () ; if ( clazz != null && ! Collection . class . isAssignableFrom ( clazz ) ) { MST[rv.ROR4Mutator]MSP[] throw new UnsupportedOperationException () ; } }
private void readObject ( final ObjectInputStream is ) throws IOException , ClassNotFoundException { is . defaultReadObject () ; if ( clazz != null && ! Collection . class . isAssignableFrom ( clazz ) ) { MST[NonVoidMethodCallMutator]MSP[] throw new UnsupportedOperationException () ; } }
@Override public T create () { try { return clazz . getDeclaredConstructor () . newInstance () ; MST[rv.CRCR6Mutator]MSP[] } catch ( final Exception ex ) { throw new FunctorException ( lr_3 + clazz , ex ) ; } }
@Override public T create () { try { return clazz . getDeclaredConstructor () . newInstance () ; MST[rv.CRCR6Mutator]MSP[] } catch ( final Exception ex ) { throw new FunctorException ( lr_3 + clazz , ex ) ; } }
@Override public T create () { try { return clazz . getDeclaredConstructor () . newInstance () ; MST[NonVoidMethodCallMutator]MSP[] } catch ( final Exception ex ) { throw new FunctorException ( lr_3 + clazz , ex ) ; } }
private void readObject ( final ObjectInputStream is ) throws IOException , ClassNotFoundException { is . defaultReadObject () ; if ( clazz != null && ! Collection . class . isAssignableFrom ( clazz ) ) { MST[rv.ROR2Mutator]MSP[] throw new UnsupportedOperationException () ; } }
private void readObject ( final ObjectInputStream is ) throws IOException , ClassNotFoundException { is . defaultReadObject () ; if ( clazz != null && ! Collection . class . isAssignableFrom ( clazz ) ) { MST[rv.ROR1Mutator]MSP[] throw new UnsupportedOperationException () ; } }
@Override public T create () { try { return clazz . getDeclaredConstructor () . newInstance () ; MST[EmptyObjectReturnValsMutator]MSP[] } catch ( final Exception ex ) { throw new FunctorException ( lr_3 + clazz , ex ) ; } }
@Override public T create () { try { return clazz . getDeclaredConstructor () . newInstance () ; MST[NonVoidMethodCallMutator]MSP[] } catch ( final Exception ex ) { throw new FunctorException ( lr_3 + clazz , ex ) ; } }
private void readObject ( final ObjectInputStream is ) throws IOException , ClassNotFoundException { is . defaultReadObject () ; MST[VoidMethodCallMutator]MSP[] if ( clazz != null && ! Collection . class . isAssignableFrom ( clazz ) ) { throw new UnsupportedOperationException () ; } }
@Override public T create () { try { return clazz . getDeclaredConstructor () . newInstance () ; MST[rv.CRCR3Mutator]MSP[] } catch ( final Exception ex ) { throw new FunctorException ( lr_3 + clazz , ex ) ; } }
@Override public T create () { try { return clazz . getDeclaredConstructor () . newInstance () ; MST[rv.CRCR1Mutator]MSP[] } catch ( final Exception ex ) { throw new FunctorException ( lr_3 + clazz , ex ) ; } }
@Override public T create () { try { return clazz . getDeclaredConstructor () . newInstance () ; MST[InlineConstantMutator]MSP[] } catch ( final Exception ex ) { throw new FunctorException ( lr_3 + clazz , ex ) ; } }
@Override public T create () { try { return clazz . getDeclaredConstructor () . newInstance () ; MST[rv.CRCR1Mutator]MSP[] } catch ( final Exception ex ) { throw new FunctorException ( lr_3 + clazz , ex ) ; } }
@Override public T create () { try { return clazz . getDeclaredConstructor () . newInstance () ; MST[rv.CRCR3Mutator]MSP[] } catch ( final Exception ex ) { throw new FunctorException ( lr_3 + clazz , ex ) ; } }
@Override public T create () { try { return clazz . getDeclaredConstructor () . newInstance () ; MST[rv.CRCR5Mutator]MSP[] } catch ( final Exception ex ) { throw new FunctorException ( lr_3 + clazz , ex ) ; } }
private void readObject ( final ObjectInputStream is ) throws IOException , ClassNotFoundException { is . defaultReadObject () ; if ( clazz != null && ! Collection . class . isAssignableFrom ( clazz ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] throw new UnsupportedOperationException () ; } }
@Override public T create () { try { return clazz . getDeclaredConstructor () . newInstance () ; MST[rv.CRCR5Mutator]MSP[] } catch ( final Exception ex ) { throw new FunctorException ( lr_3 + clazz , ex ) ; } }
private void readObject ( final ObjectInputStream is ) throws IOException , ClassNotFoundException { is . defaultReadObject () ; if ( clazz != null && ! Collection . class . isAssignableFrom ( clazz ) ) { throw new UnsupportedOperationException () ; MST[ConstructorCallMutator]MSP[] } }
private void readObject ( final ObjectInputStream is ) throws IOException , ClassNotFoundException { is . defaultReadObject () ; if ( clazz != null && ! Collection . class . isAssignableFrom ( clazz ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] throw new UnsupportedOperationException () ; } }
@Override public T create () { try { return clazz . getDeclaredConstructor () . newInstance () ; MST[InlineConstantMutator]MSP[] } catch ( final Exception ex ) { throw new FunctorException ( lr_3 + clazz , ex ) ; } }
private void readObject ( final ObjectInputStream is ) throws IOException , ClassNotFoundException { is . defaultReadObject () ; if ( clazz != null && ! Collection . class . isAssignableFrom ( clazz ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] throw new UnsupportedOperationException () ; } }
if ( ! containsKey ( key ) ) { MST[NonVoidMethodCallMutator]MSP[] return EmptyIterator . <V > emptyIterator () ; } return new ValuesIterator ( key ) ; } @Override public V getValue () { return input ; } @Override public V setValue ( final V value ) {
throw new UnsupportedOperationException () ; } public int totalSize () { int total = 0 ; for ( final Object v : decorated () . values () ) { total += CollectionUtils . size ( v ) ; } return total ; MST[rv.UOI3Mutator]MSP[] }
Collection < V > coll = getCollection ( key ) ; if ( coll == null ) { coll = createCollection ( values . size () ) ; coll . addAll ( values ) ; if ( coll . size () > 0 ) { MST[NegateConditionalsMutator]MSP[]
if ( removed == false ) { return false ; } if ( valuesForKey . isEmpty () ) { MST[rv.ROR3Mutator]MSP[] remove ( key ) ; } return true ; } @Override @SuppressWarnings ( lr_1 ) public boolean containsValue ( final Object value ) {
if ( removed == false ) { return false ; } if ( valuesForKey . isEmpty () ) { MST[rv.ROR5Mutator]MSP[] remove ( key ) ; } return true ; } @Override @SuppressWarnings ( lr_1 ) public boolean containsValue ( final Object value ) {
if ( removed == false ) { return false ; } if ( valuesForKey . isEmpty () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] remove ( key ) ; } return true ; } @Override @SuppressWarnings ( lr_1 ) public boolean containsValue ( final Object value ) {
put ( entry . getKey () , entry . getValue () ) ; MST[NonVoidMethodCallMutator]MSP[] } } } @Override public Set < Entry < K , Object > > entrySet () { return super . entrySet () ; } @Override @SuppressWarnings ( lr_1 ) public Collection < Object > values () {
public boolean removeMapping ( final Object key , final Object value ) { final Collection < V > valuesForKey = getCollection ( key ) ; if ( valuesForKey == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return false ; } final boolean removed = valuesForKey . remove ( value ) ;
if ( removed == false ) { return false ; MST[InlineConstantMutator]MSP[] } if ( valuesForKey . isEmpty () ) { remove ( key ) ; } return true ; } @Override @SuppressWarnings ( lr_1 ) public boolean containsValue ( final Object value ) {
decorated () . put ( key , coll ) ; result = true ; } } else { result = coll . addAll ( values ) ; } return result ; MST[rv.ABSMutator]MSP[] } public Iterator < V > iterator ( final Object key ) {
final Collection < V > coll = getCollection ( key ) ; if ( coll == null ) { return false ; MST[rv.CRCR6Mutator]MSP[] } return coll . contains ( value ) ; } @SuppressWarnings ( lr_1 ) public Collection < V > getCollection ( final Object key ) {
public boolean removeMapping ( final Object key , final Object value ) { final Collection < V > valuesForKey = getCollection ( key ) ; if ( valuesForKey == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return false ; } final boolean removed = valuesForKey . remove ( value ) ;
decorated () . put ( key , coll ) ; result = true ; } } else { result = coll . addAll ( values ) ; } return result ; MST[BooleanFalseReturnValsMutator]MSP[] } public Iterator < V > iterator ( final Object key ) {
public boolean removeMapping ( final Object key , final Object value ) { final Collection < V > valuesForKey = getCollection ( key ) ; if ( valuesForKey == null ) { MST[rv.ROR5Mutator]MSP[] return false ; } final boolean removed = valuesForKey . remove ( value ) ;
throw new UnsupportedOperationException () ; } public int totalSize () { int total = 0 ; for ( final Object v : decorated () . values () ) { total += CollectionUtils . size ( v ) ; } return total ; MST[ReturnValsMutator]MSP[] }
throw new UnsupportedOperationException () ; } public int totalSize () { int total = 0 ; for ( final Object v : decorated () . values () ) { total += CollectionUtils . size ( v ) ; MST[rv.AOD2Mutator]MSP[] } return total ; }
if ( ( ( Collection < V > ) entry . getValue () ) . contains ( value ) ) { MST[NonVoidMethodCallMutator]MSP[] return true ; } } } return false ; } @Override @SuppressWarnings ( lr_1 ) public Object put ( final K key , final Object value ) {
if ( removed == false ) { MST[NegateConditionalsMutator]MSP[] return false ; } if ( valuesForKey . isEmpty () ) { remove ( key ) ; } return true ; } @Override @SuppressWarnings ( lr_1 ) public boolean containsValue ( final Object value ) {
putAll ( entry . getKey () , ( Collection < V > ) entry . getValue () ) ; MST[NonVoidMethodCallMutator]MSP[] } } else { for ( final Map . Entry < ? extends K , ? > entry : map . entrySet () ) {
Collection < V > coll = getCollection ( key ) ; if ( coll == null ) { coll = createCollection ( values . size () ) ; coll . addAll ( values ) ; MST[NonVoidMethodCallMutator]MSP[] if ( coll . size () > 0 ) {
throw new UnsupportedOperationException () ; } public int totalSize () { int total = 0 ; for ( final Object v : decorated () . values () ) { total += CollectionUtils . size ( v ) ; } return total ; MST[rv.UOI1Mutator]MSP[] }
public boolean removeMapping ( final Object key , final Object value ) { final Collection < V > valuesForKey = getCollection ( key ) ; if ( valuesForKey == null ) { return false ; } final boolean removed = valuesForKey . remove ( value ) ; MST[NonVoidMethodCallMutator]MSP[]
public boolean removeMapping ( final Object key , final Object value ) { final Collection < V > valuesForKey = getCollection ( key ) ; if ( valuesForKey == null ) { return false ; MST[BooleanTrueReturnValsMutator]MSP[] } final boolean removed = valuesForKey . remove ( value ) ;
if ( ( ( Collection < V > ) entry . getValue () ) . contains ( value ) ) { return true ; MST[ReturnValsMutator]MSP[] } } } return false ; } @Override @SuppressWarnings ( lr_1 ) public Object put ( final K key , final Object value ) {
Collection < V > coll = getCollection ( key ) ; if ( coll == null ) { coll = createCollection ( values . size () ) ; MST[NonVoidMethodCallMutator]MSP[] coll . addAll ( values ) ; if ( coll . size () > 0 ) {
public boolean removeMapping ( final Object key , final Object value ) { final Collection < V > valuesForKey = getCollection ( key ) ; if ( valuesForKey == null ) { return false ; MST[rv.CRCR1Mutator]MSP[] } final boolean removed = valuesForKey . remove ( value ) ;
decorated () . put ( key , coll ) ; result = true ; MST[rv.CRCR3Mutator]MSP[] } } else { result = coll . add ( ( V ) value ) ; } return result ? value : null ; } @Override @SuppressWarnings ( lr_1 )
return coll . size () ; } public boolean putAll ( final K key , final Collection < V > values ) { if ( values == null || values . size () == 0 ) { return false ; } boolean result = false ; MST[rv.CRCR1Mutator]MSP[]
final Factory < C > collectionFactory ) { return new MultiValueMap <> ( map , collectionFactory ) ; MST[NullReturnValsMutator]MSP[] } private void writeObject ( final ObjectOutputStream out ) throws IOException { out . defaultWriteObject () ; out . writeObject ( map ) ; } @SuppressWarnings ( lr_1 )
public boolean removeMapping ( final Object key , final Object value ) { final Collection < V > valuesForKey = getCollection ( key ) ; if ( valuesForKey == null ) { return false ; MST[rv.CRCR5Mutator]MSP[] } final boolean removed = valuesForKey . remove ( value ) ;
return ( Collection < V > ) decorated () . get ( key ) ; } public int size ( final Object key ) { final Collection < V > coll = getCollection ( key ) ; if ( coll == null ) { return 0 ; MST[ReturnValsMutator]MSP[] }
return coll . size () ; } public boolean putAll ( final K key , final Collection < V > values ) { if ( values == null || values . size () == 0 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return false ; } boolean result = false ;
return ( Collection < V > ) decorated () . get ( key ) ; } public int size ( final Object key ) { final Collection < V > coll = getCollection ( key ) ; if ( coll == null ) { return 0 ; MST[rv.CRCR1Mutator]MSP[] }
throw new UnsupportedOperationException () ; } public int totalSize () { int total = 0 ; MST[rv.CRCR6Mutator]MSP[] for ( final Object v : decorated () . values () ) { total += CollectionUtils . size ( v ) ; } return total ; }
if ( ( ( Collection < V > ) entry . getValue () ) . contains ( value ) ) { return true ; MST[rv.CRCR5Mutator]MSP[] } } } return false ; } @Override @SuppressWarnings ( lr_1 ) public Object put ( final K key , final Object value ) {
boolean result = false ; MST[rv.CRCR6Mutator]MSP[] Collection < V > coll = getCollection ( key ) ; if ( coll == null ) { coll = createCollection ( 1 ) ; coll . add ( ( V ) value ) ; if ( coll . size () > 0 ) {
decorated () . put ( key , coll ) ; result = true ; } } else { result = coll . addAll ( values ) ; } return result ; MST[rv.UOI4Mutator]MSP[] } public Iterator < V > iterator ( final Object key ) {
decorated () . put ( key , coll ) ; result = true ; } } else { result = coll . add ( ( V ) value ) ; } return result ? value : null ; MST[rv.UOI2Mutator]MSP[] } @Override @SuppressWarnings ( lr_1 )
return ( Collection < V > ) decorated () . get ( key ) ; } public int size ( final Object key ) { final Collection < V > coll = getCollection ( key ) ; if ( coll == null ) { return 0 ; MST[rv.CRCR5Mutator]MSP[] }
if ( ( ( Collection < V > ) entry . getValue () ) . contains ( value ) ) { MST[rv.ROR1Mutator]MSP[] return true ; } } } return false ; } @Override @SuppressWarnings ( lr_1 ) public Object put ( final K key , final Object value ) {
boolean result = false ; Collection < V > coll = getCollection ( key ) ; if ( coll == null ) { coll = createCollection ( 1 ) ; MST[rv.CRCR3Mutator]MSP[] coll . add ( ( V ) value ) ; if ( coll . size () > 0 ) {
final Collection < V > vs = valuesView ; return ( Collection < Object > ) ( vs != null ? vs : ( valuesView = new Values () ) ) ; MST[ReturnValsMutator]MSP[] } public boolean containsValue ( final Object key , final Object value ) {
throw new UnsupportedOperationException () ; } public int totalSize () { MST[rv.ROR5Mutator]MSP[] int total = 0 ; for ( final Object v : decorated () . values () ) { total += CollectionUtils . size ( v ) ; } return total ; }
decorated () . put ( key , coll ) ; result = true ; } } else { result = coll . addAll ( values ) ; MST[NonVoidMethodCallMutator]MSP[] } return result ; } public Iterator < V > iterator ( final Object key ) {
return coll . size () ; } public boolean putAll ( final K key , final Collection < V > values ) { if ( values == null || values . size () == 0 ) { MST[rv.ROR3Mutator]MSP[] return false ; } boolean result = false ;
if ( ( ( Collection < V > ) entry . getValue () ) . contains ( value ) ) { MST[rv.ROR5Mutator]MSP[] return true ; } } } return false ; } @Override @SuppressWarnings ( lr_1 ) public Object put ( final K key , final Object value ) {
if ( removed == false ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return false ; } if ( valuesForKey . isEmpty () ) { remove ( key ) ; } return true ; } @Override @SuppressWarnings ( lr_1 ) public boolean containsValue ( final Object value ) {
public boolean removeMapping ( final Object key , final Object value ) { final Collection < V > valuesForKey = getCollection ( key ) ; MST[NonVoidMethodCallMutator]MSP[] if ( valuesForKey == null ) { return false ; } final boolean removed = valuesForKey . remove ( value ) ;
return coll . size () ; } public boolean putAll ( final K key , final Collection < V > values ) { if ( values == null || values . size () == 0 ) { return false ; MST[rv.CRCR6Mutator]MSP[] } boolean result = false ;
boolean result = false ; Collection < V > coll = getCollection ( key ) ; if ( coll == null ) { MST[rv.ROR5Mutator]MSP[] coll = createCollection ( 1 ) ; coll . add ( ( V ) value ) ; if ( coll . size () > 0 ) {
return ( Collection < V > ) decorated () . get ( key ) ; MST[NonVoidMethodCallMutator]MSP[] } public int size ( final Object key ) { final Collection < V > coll = getCollection ( key ) ; if ( coll == null ) { return 0 ; }
return coll . size () ; } public boolean putAll ( final K key , final Collection < V > values ) { if ( values == null || values . size () == 0 ) { return false ; } boolean result = false ; MST[rv.CRCR5Mutator]MSP[]
if ( removed == false ) { return false ; } if ( valuesForKey . isEmpty () ) { MST[rv.ROR1Mutator]MSP[] remove ( key ) ; } return true ; } @Override @SuppressWarnings ( lr_1 ) public boolean containsValue ( final Object value ) {
throw new UnsupportedOperationException () ; } public int totalSize () { int total = 0 ; for ( final Object v : decorated () . values () ) { total += CollectionUtils . size ( v ) ; MST[rv.AOR2Mutator]MSP[] } return total ; }
throw new UnsupportedOperationException () ; } public int totalSize () { int total = 0 ; for ( final Object v : decorated () . values () ) { total += CollectionUtils . size ( v ) ; MST[NonVoidMethodCallMutator]MSP[] } return total ; }
if ( removed == false ) { MST[rv.ROR3Mutator]MSP[] return false ; } if ( valuesForKey . isEmpty () ) { remove ( key ) ; } return true ; } @Override @SuppressWarnings ( lr_1 ) public boolean containsValue ( final Object value ) {
return ( Collection < V > ) decorated () . get ( key ) ; } public int size ( final Object key ) { final Collection < V > coll = getCollection ( key ) ; if ( coll == null ) { MST[rv.ROR5Mutator]MSP[] return 0 ; }
return coll . size () ; } public boolean putAll ( final K key , final Collection < V > values ) { if ( values == null || values . size () == 0 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return false ; } boolean result = false ;
boolean result = false ; Collection < V > coll = getCollection ( key ) ; if ( coll == null ) { coll = createCollection ( 1 ) ; coll . add ( ( V ) value ) ; if ( coll . size () > 0 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[]
if ( removed == false ) { MST[rv.ROR1Mutator]MSP[] return false ; } if ( valuesForKey . isEmpty () ) { remove ( key ) ; } return true ; } @Override @SuppressWarnings ( lr_1 ) public boolean containsValue ( final Object value ) {
if ( ( ( Collection < V > ) entry . getValue () ) . contains ( value ) ) { return true ; } } } return false ; MST[rv.CRCR5Mutator]MSP[] } @Override @SuppressWarnings ( lr_1 ) public Object put ( final K key , final Object value ) {
throw new UnsupportedOperationException () ; } public int totalSize () { int total = 0 ; for ( final Object v : decorated () . values () ) { total += CollectionUtils . size ( v ) ; MST[rv.ABSMutator]MSP[] } return total ; }
if ( ( ( Collection < V > ) entry . getValue () ) . contains ( value ) ) { return true ; } } } return false ; MST[BooleanTrueReturnValsMutator]MSP[] } @Override @SuppressWarnings ( lr_1 ) public Object put ( final K key , final Object value ) {
if ( ! containsKey ( key ) ) { MST[rv.ROR3Mutator]MSP[] return EmptyIterator . <V > emptyIterator () ; } return new ValuesIterator ( key ) ; } @Override public V getValue () { return input ; } @Override public V setValue ( final V value ) {
if ( ! containsKey ( key ) ) { MST[rv.ROR2Mutator]MSP[] return EmptyIterator . <V > emptyIterator () ; } return new ValuesIterator ( key ) ; } @Override public V getValue () { return input ; } @Override public V setValue ( final V value ) {
throw new UnsupportedOperationException () ; } public int totalSize () { MST[NullReturnValsMutator]MSP[] int total = 0 ; for ( final Object v : decorated () . values () ) { total += CollectionUtils . size ( v ) ; } return total ; }
if ( removed == false ) { MST[rv.ABSMutator]MSP[] return false ; } if ( valuesForKey . isEmpty () ) { remove ( key ) ; } return true ; } @Override @SuppressWarnings ( lr_1 ) public boolean containsValue ( final Object value ) {
if ( ! containsKey ( key ) ) { MST[rv.ROR5Mutator]MSP[] return EmptyIterator . <V > emptyIterator () ; } return new ValuesIterator ( key ) ; } @Override public V getValue () { return input ; } @Override public V setValue ( final V value ) {
throw new UnsupportedOperationException () ; } public int totalSize () { int total = 0 ; for ( final Object v : decorated () . values () ) { MST[NonVoidMethodCallMutator]MSP[] total += CollectionUtils . size ( v ) ; } return total ; }
if ( removed == false ) { return false ; } if ( valuesForKey . isEmpty () ) { MST[NonVoidMethodCallMutator]MSP[] remove ( key ) ; } return true ; } @Override @SuppressWarnings ( lr_1 ) public boolean containsValue ( final Object value ) {
return coll . size () ; } public boolean putAll ( final K key , final Collection < V > values ) { if ( values == null || values . size () == 0 ) { return false ; MST[BooleanTrueReturnValsMutator]MSP[] } boolean result = false ;
return coll . size () ; } public boolean putAll ( final K key , final Collection < V > values ) { if ( values == null || values . size () == 0 ) { return false ; MST[ReturnValsMutator]MSP[] } boolean result = false ;
final Collection < V > coll = getCollection ( key ) ; MST[NonVoidMethodCallMutator]MSP[] if ( coll == null ) { return false ; } return coll . contains ( value ) ; } @SuppressWarnings ( lr_1 ) public Collection < V > getCollection ( final Object key ) {
final Collection < V > coll = getCollection ( key ) ; if ( coll == null ) { return false ; } return coll . contains ( value ) ; MST[ReturnValsMutator]MSP[] } @SuppressWarnings ( lr_1 ) public Collection < V > getCollection ( final Object key ) {
public void putAll ( final Map < ? extends K , ? > map ) { if ( map instanceof MultiMap ) { MST[rv.ROR1Mutator]MSP[]
decorated () . put ( key , coll ) ; MST[ArgumentPropagationMutator]MSP[] result = true ; } } else { result = coll . addAll ( values ) ; } return result ; } public Iterator < V > iterator ( final Object key ) {
protected Collection < V > createCollection ( final int size ) { return collectionFactory . create () ; MST[ReturnValsMutator]MSP[] } @Override public Iterator < V > iterator () { final IteratorChain < V > chain = new IteratorChain <> () ; for ( final K k : keySet () ) {
public void putAll ( final Map < ? extends K , ? > map ) { if ( map instanceof MultiMap ) { MST[rv.ROR4Mutator]MSP[]
if ( removed == false ) { return false ; MST[rv.CRCR1Mutator]MSP[] } if ( valuesForKey . isEmpty () ) { remove ( key ) ; } return true ; } @Override @SuppressWarnings ( lr_1 ) public boolean containsValue ( final Object value ) {
if ( ( ( Collection < V > ) entry . getValue () ) . contains ( value ) ) { return true ; } } } return false ; MST[ReturnValsMutator]MSP[] } @Override @SuppressWarnings ( lr_1 ) public Object put ( final K key , final Object value ) {
Collection < V > coll = getCollection ( key ) ; if ( coll == null ) { MST[NegateConditionalsMutator]MSP[] coll = createCollection ( values . size () ) ; coll . addAll ( values ) ; if ( coll . size () > 0 ) {
if ( removed == false ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return false ; } if ( valuesForKey . isEmpty () ) { remove ( key ) ; } return true ; } @Override @SuppressWarnings ( lr_1 ) public boolean containsValue ( final Object value ) {
if ( removed == false ) { return false ; MST[rv.CRCR6Mutator]MSP[] } if ( valuesForKey . isEmpty () ) { remove ( key ) ; } return true ; } @Override @SuppressWarnings ( lr_1 ) public boolean containsValue ( final Object value ) {
decorated () . put ( key , coll ) ; result = true ; } } else { result = coll . add ( ( V ) value ) ; } return result ? value : null ; MST[rv.ROR4Mutator]MSP[] } @Override @SuppressWarnings ( lr_1 )
decorated () . put ( key , coll ) ; result = true ; } } else { result = coll . add ( ( V ) value ) ; } return result ? value : null ; MST[rv.ABSMutator]MSP[] } @Override @SuppressWarnings ( lr_1 )
boolean result = false ; Collection < V > coll = getCollection ( key ) ; if ( coll == null ) { coll = createCollection ( 1 ) ; MST[rv.CRCR6Mutator]MSP[] coll . add ( ( V ) value ) ; if ( coll . size () > 0 ) {
decorated () . put ( key , coll ) ; result = true ; } } else { result = coll . add ( ( V ) value ) ; } return result ? value : null ; MST[rv.ROR3Mutator]MSP[] } @Override @SuppressWarnings ( lr_1 )
decorated () . put ( key , coll ) ; result = true ; } } else { result = coll . add ( ( V ) value ) ; } return result ? value : null ; MST[rv.ROR1Mutator]MSP[] } @Override @SuppressWarnings ( lr_1 )
Collection < V > coll = getCollection ( key ) ; if ( coll == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] coll = createCollection ( values . size () ) ; coll . addAll ( values ) ; if ( coll . size () > 0 ) {
boolean result = false ; Collection < V > coll = getCollection ( key ) ; if ( coll == null ) { coll = createCollection ( 1 ) ; coll . add ( ( V ) value ) ; if ( coll . size () > 0 ) { MST[rv.ROR3Mutator]MSP[]
return coll . size () ; } public boolean putAll ( final K key , final Collection < V > values ) { if ( values == null || values . size () == 0 ) { MST[rv.ROR2Mutator]MSP[] return false ; } boolean result = false ;
boolean result = false ; Collection < V > coll = getCollection ( key ) ; if ( coll == null ) { coll = createCollection ( 1 ) ; coll . add ( ( V ) value ) ; MST[NonVoidMethodCallMutator]MSP[] if ( coll . size () > 0 ) {
decorated () . put ( key , coll ) ; result = true ; } } else { result = coll . add ( ( V ) value ) ; } return result ? value : null ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] } @Override @SuppressWarnings ( lr_1 )
if ( ( ( Collection < V > ) entry . getValue () ) . contains ( value ) ) { MST[rv.ROR4Mutator]MSP[] return true ; } } } return false ; } @Override @SuppressWarnings ( lr_1 ) public Object put ( final K key , final Object value ) {
decorated () . put ( key , coll ) ; result = true ; } } else { result = coll . add ( ( V ) value ) ; } return result ? value : null ; MST[ReturnValsMutator]MSP[] } @Override @SuppressWarnings ( lr_1 )
Collection < V > coll = getCollection ( key ) ; if ( coll == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] coll = createCollection ( values . size () ) ; coll . addAll ( values ) ; if ( coll . size () > 0 ) {
private void readObject ( final ObjectInputStream in ) throws IOException , ClassNotFoundException { in . defaultReadObject () ; map = ( Map < K , Object > ) in . readObject () ; MST[experimental.MemberVariableMutator]MSP[] } @Override public void clear () { decorated () . clear () ; } @Override
if ( ! containsKey ( key ) ) { return EmptyIterator . <V > emptyIterator () ; MST[ReturnValsMutator]MSP[] } return new ValuesIterator ( key ) ; } @Override public V getValue () { return input ; } @Override public V setValue ( final V value ) {
if ( ! containsKey ( key ) ) { return EmptyIterator . <V > emptyIterator () ; } return new ValuesIterator ( key ) ; MST[NullReturnValsMutator]MSP[] } @Override public V getValue () { return input ; } @Override public V setValue ( final V value ) {
boolean result = false ; MST[rv.CRCR1Mutator]MSP[] Collection < V > coll = getCollection ( key ) ; if ( coll == null ) { coll = createCollection ( 1 ) ; coll . add ( ( V ) value ) ; if ( coll . size () > 0 ) {
return coll . size () ; } public boolean putAll ( final K key , final Collection < V > values ) { if ( values == null || values . size () == 0 ) { return false ; MST[rv.CRCR5Mutator]MSP[] } boolean result = false ;
if ( removed == false ) { MST[rv.UOI1Mutator]MSP[] return false ; } if ( valuesForKey . isEmpty () ) { remove ( key ) ; } return true ; } @Override @SuppressWarnings ( lr_1 ) public boolean containsValue ( final Object value ) {
throw new UnsupportedOperationException () ; } public int totalSize () { int total = 0 ; for ( final Object v : decorated () . values () ) { total += CollectionUtils . size ( v ) ; MST[rv.UOI4Mutator]MSP[] } return total ; }
return new MultiValueMap <> ( map , new ReflectionFactory <> ( collectionClass ) ) ; MST[NullReturnValsMutator]MSP[] } public static < K , V , C extends Collection < V > > MultiValueMap < K , V > multiValueMap ( final Map < K , ? super C > map ,
putAll ( entry . getKey () , ( Collection < V > ) entry . getValue () ) ; MST[NonVoidMethodCallMutator]MSP[] } } else { for ( final Map . Entry < ? extends K , ? > entry : map . entrySet () ) {
boolean result = false ; Collection < V > coll = getCollection ( key ) ; MST[NonVoidMethodCallMutator]MSP[] if ( coll == null ) { coll = createCollection ( 1 ) ; coll . add ( ( V ) value ) ; if ( coll . size () > 0 ) {
final Collection < V > coll = getCollection ( key ) ; if ( coll == null ) { return false ; } return coll . contains ( value ) ; MST[BooleanTrueReturnValsMutator]MSP[] } @SuppressWarnings ( lr_1 ) public Collection < V > getCollection ( final Object key ) {
private void readObject ( final ObjectInputStream in ) throws IOException , ClassNotFoundException { in . defaultReadObject () ; map = ( Map < K , Object > ) in . readObject () ; MST[NonVoidMethodCallMutator]MSP[] } @Override public void clear () { decorated () . clear () ; } @Override
throw new UnsupportedOperationException () ; } public int totalSize () { int total = 0 ; for ( final Object v : decorated () . values () ) { total += CollectionUtils . size ( v ) ; MST[rv.AOR1Mutator]MSP[] } return total ; }
if ( removed == false ) { MST[rv.ROR4Mutator]MSP[] return false ; } if ( valuesForKey . isEmpty () ) { remove ( key ) ; } return true ; } @Override @SuppressWarnings ( lr_1 ) public boolean containsValue ( final Object value ) {
boolean result = false ; Collection < V > coll = getCollection ( key ) ; if ( coll == null ) { coll = createCollection ( 1 ) ; coll . add ( ( V ) value ) ; if ( coll . size () > 0 ) { MST[rv.ROR1Mutator]MSP[]
return ( Collection < V > ) decorated () . get ( key ) ; } public int size ( final Object key ) { final Collection < V > coll = getCollection ( key ) ; if ( coll == null ) { MST[NegateConditionalsMutator]MSP[] return 0 ; }
return coll . size () ; } public boolean putAll ( final K key , final Collection < V > values ) { if ( values == null || values . size () == 0 ) { return false ; MST[rv.CRCR3Mutator]MSP[] } boolean result = false ;
if ( removed == false ) { return false ; } if ( valuesForKey . isEmpty () ) { MST[NegateConditionalsMutator]MSP[] remove ( key ) ; } return true ; } @Override @SuppressWarnings ( lr_1 ) public boolean containsValue ( final Object value ) {
Collection < V > coll = getCollection ( key ) ; if ( coll == null ) { coll = createCollection ( values . size () ) ; coll . addAll ( values ) ; if ( coll . size () > 0 ) { MST[rv.ROR1Mutator]MSP[]
throw new UnsupportedOperationException () ; } public int totalSize () { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] int total = 0 ; for ( final Object v : decorated () . values () ) { total += CollectionUtils . size ( v ) ; } return total ; }
throw new UnsupportedOperationException () ; } public int totalSize () { int total = 0 ; MST[rv.CRCR1Mutator]MSP[] for ( final Object v : decorated () . values () ) { total += CollectionUtils . size ( v ) ; } return total ; }
throw new UnsupportedOperationException () ; } public int totalSize () { int total = 0 ; for ( final Object v : decorated () . values () ) { MST[NonVoidMethodCallMutator]MSP[] total += CollectionUtils . size ( v ) ; } return total ; }
throw new UnsupportedOperationException () ; } public int totalSize () { int total = 0 ; for ( final Object v : decorated () . values () ) { total += CollectionUtils . size ( v ) ; MST[rv.UOI1Mutator]MSP[] } return total ; }
throw new UnsupportedOperationException () ; } public int totalSize () { MST[ReturnValsMutator]MSP[] int total = 0 ; for ( final Object v : decorated () . values () ) { total += CollectionUtils . size ( v ) ; } return total ; }
put ( entry . getKey () , entry . getValue () ) ; } } } @Override public Set < Entry < K , Object > > entrySet () { return super . entrySet () ; MST[ReturnValsMutator]MSP[] } @Override @SuppressWarnings ( lr_1 ) public Collection < Object > values () {
Collection < V > coll = getCollection ( key ) ; MST[NonVoidMethodCallMutator]MSP[] if ( coll == null ) { coll = createCollection ( values . size () ) ; coll . addAll ( values ) ; if ( coll . size () > 0 ) {
decorated () . put ( key , coll ) ; result = true ; } } else { result = coll . addAll ( values ) ; } return result ; MST[ReturnValsMutator]MSP[] } public Iterator < V > iterator ( final Object key ) {
if ( ( ( Collection < V > ) entry . getValue () ) . contains ( value ) ) { return true ; MST[rv.CRCR2Mutator]MSP[] } } } return false ; } @Override @SuppressWarnings ( lr_1 ) public Object put ( final K key , final Object value ) {
public void putAll ( final Map < ? extends K , ? > map ) { if ( map instanceof MultiMap ) { MST[NegateConditionalsMutator]MSP[]
if ( removed == false ) { return false ; } if ( valuesForKey . isEmpty () ) { remove ( key ) ; MST[ArgumentPropagationMutator]MSP[] } return true ; } @Override @SuppressWarnings ( lr_1 ) public boolean containsValue ( final Object value ) {
return coll . size () ; MST[NonVoidMethodCallMutator]MSP[] } public boolean putAll ( final K key , final Collection < V > values ) { if ( values == null || values . size () == 0 ) { return false ; } boolean result = false ;
decorated () . put ( key , coll ) ; result = true ; } } else { result = coll . add ( ( V ) value ) ; } return result ? value : null ; MST[rv.UOI1Mutator]MSP[] } @Override @SuppressWarnings ( lr_1 )
boolean result = false ; Collection < V > coll = getCollection ( key ) ; if ( coll == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] coll = createCollection ( 1 ) ; coll . add ( ( V ) value ) ; if ( coll . size () > 0 ) {
throw new UnsupportedOperationException () ; } public int totalSize () { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] int total = 0 ; for ( final Object v : decorated () . values () ) { total += CollectionUtils . size ( v ) ; } return total ; }
decorated () . put ( key , coll ) ; result = true ; } } else { result = coll . addAll ( values ) ; } return result ; MST[rv.UOI2Mutator]MSP[] } public Iterator < V > iterator ( final Object key ) {
decorated () . put ( key , coll ) ; MST[ArgumentPropagationMutator]MSP[] result = true ; } } else { result = coll . add ( ( V ) value ) ; } return result ? value : null ; } @Override @SuppressWarnings ( lr_1 )
if ( ( ( Collection < V > ) entry . getValue () ) . contains ( value ) ) { MST[rv.ROR2Mutator]MSP[] return true ; } } } return false ; } @Override @SuppressWarnings ( lr_1 ) public Object put ( final K key , final Object value ) {
final Factory < C > collectionFactory ) { return new MultiValueMap <> ( map , collectionFactory ) ; } private void writeObject ( final ObjectOutputStream out ) throws IOException { out . defaultWriteObject () ; out . writeObject ( map ) ; MST[VoidMethodCallMutator]MSP[] } @SuppressWarnings ( lr_1 )
return coll . size () ; } public boolean putAll ( final K key , final Collection < V > values ) { if ( values == null || values . size () == 0 ) { MST[NonVoidMethodCallMutator]MSP[] return false ; } boolean result = false ;
boolean result = false ; Collection < V > coll = getCollection ( key ) ; if ( coll == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] coll = createCollection ( 1 ) ; coll . add ( ( V ) value ) ; if ( coll . size () > 0 ) {
decorated () . put ( key , coll ) ; result = true ; } } else { result = coll . add ( ( V ) value ) ; MST[NonVoidMethodCallMutator]MSP[] } return result ? value : null ; } @Override @SuppressWarnings ( lr_1 )
decorated () . put ( key , coll ) ; result = true ; } } else { result = coll . add ( ( V ) value ) ; } return result ? value : null ; MST[rv.UOI4Mutator]MSP[] } @Override @SuppressWarnings ( lr_1 )
if ( removed == false ) { return false ; } if ( valuesForKey . isEmpty () ) { remove ( key ) ; } return true ; MST[BooleanFalseReturnValsMutator]MSP[] } @Override @SuppressWarnings ( lr_1 ) public boolean containsValue ( final Object value ) {
final Collection < V > coll = getCollection ( key ) ; if ( coll == null ) { return false ; MST[rv.CRCR3Mutator]MSP[] } return coll . contains ( value ) ; } @SuppressWarnings ( lr_1 ) public Collection < V > getCollection ( final Object key ) {
decorated () . put ( key , coll ) ; result = true ; MST[rv.CRCR4Mutator]MSP[] } } else { result = coll . addAll ( values ) ; } return result ; } public Iterator < V > iterator ( final Object key ) {
throw new UnsupportedOperationException () ; } public int totalSize () { int total = 0 ; for ( final Object v : decorated () . values () ) { total += CollectionUtils . size ( v ) ; MST[rv.AOR4Mutator]MSP[] } return total ; }
if ( ! containsKey ( key ) ) { return EmptyIterator . <V > emptyIterator () ; } return new ValuesIterator ( key ) ; MST[ReturnValsMutator]MSP[] } @Override public V getValue () { return input ; } @Override public V setValue ( final V value ) {
return coll . size () ; } public boolean putAll ( final K key , final Collection < V > values ) { if ( values == null || values . size () == 0 ) { MST[rv.ROR5Mutator]MSP[] return false ; } boolean result = false ;
public boolean removeMapping ( final Object key , final Object value ) { final Collection < V > valuesForKey = getCollection ( key ) ; if ( valuesForKey == null ) { MST[NegateConditionalsMutator]MSP[] return false ; } final boolean removed = valuesForKey . remove ( value ) ;
if ( removed == false ) { return false ; } if ( valuesForKey . isEmpty () ) { remove ( key ) ; } return true ; MST[rv.CRCR4Mutator]MSP[] } @Override @SuppressWarnings ( lr_1 ) public boolean containsValue ( final Object value ) {
throw new UnsupportedOperationException () ; } public int totalSize () { int total = 0 ; for ( final Object v : decorated () . values () ) { total += CollectionUtils . size ( v ) ; MST[rv.AOD1Mutator]MSP[] } return total ; }
return coll . size () ; } public boolean putAll ( final K key , final Collection < V > values ) { if ( values == null || values . size () == 0 ) { MST[NegateConditionalsMutator]MSP[] return false ; } boolean result = false ;
final Collection < V > coll = getCollection ( key ) ; if ( coll == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return false ; } return coll . contains ( value ) ; } @SuppressWarnings ( lr_1 ) public Collection < V > getCollection ( final Object key ) {
throw new UnsupportedOperationException () ; } public int totalSize () { int total = 0 ; for ( final Object v : decorated () . values () ) { total += CollectionUtils . size ( v ) ; MST[MathMutator]MSP[] } return total ; }
Collection < V > coll = getCollection ( key ) ; if ( coll == null ) { coll = createCollection ( values . size () ) ; coll . addAll ( values ) ; if ( coll . size () > 0 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[]
decorated () . put ( key , coll ) ; result = true ; MST[rv.CRCR6Mutator]MSP[] } } else { result = coll . add ( ( V ) value ) ; } return result ? value : null ; } @Override @SuppressWarnings ( lr_1 )
return ( Collection < V > ) decorated () . get ( key ) ; MST[NonVoidMethodCallMutator]MSP[] } public int size ( final Object key ) { final Collection < V > coll = getCollection ( key ) ; if ( coll == null ) { return 0 ; }
if ( removed == false ) { MST[rv.UOI4Mutator]MSP[] return false ; } if ( valuesForKey . isEmpty () ) { remove ( key ) ; } return true ; } @Override @SuppressWarnings ( lr_1 ) public boolean containsValue ( final Object value ) {
Collection < V > coll = getCollection ( key ) ; if ( coll == null ) { coll = createCollection ( values . size () ) ; coll . addAll ( values ) ; if ( coll . size () > 0 ) { MST[rv.ROR4Mutator]MSP[]
final Collection < V > coll = getCollection ( key ) ; if ( coll == null ) { return false ; MST[InlineConstantMutator]MSP[] } return coll . contains ( value ) ; } @SuppressWarnings ( lr_1 ) public Collection < V > getCollection ( final Object key ) {
final Set < Map . Entry < K , Object > > pairs = decorated () . entrySet () ; if ( pairs != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] for ( final Map . Entry < K , Object > entry : pairs ) {
throw new UnsupportedOperationException () ; } public int totalSize () { int total = 0 ; for ( final Object v : decorated () . values () ) { total += CollectionUtils . size ( v ) ; } return total ; MST[rv.UOI4Mutator]MSP[] }
throw new UnsupportedOperationException () ; } public int totalSize () { int total = 0 ; for ( final Object v : decorated () . values () ) { total += CollectionUtils . size ( v ) ; } return total ; MST[rv.UOI2Mutator]MSP[] }
return coll . size () ; MST[PrimitiveReturnsMutator]MSP[] } public boolean putAll ( final K key , final Collection < V > values ) { if ( values == null || values . size () == 0 ) { return false ; } boolean result = false ;
boolean result = false ; Collection < V > coll = getCollection ( key ) ; if ( coll == null ) { coll = createCollection ( 1 ) ; MST[InlineConstantMutator]MSP[] coll . add ( ( V ) value ) ; if ( coll . size () > 0 ) {
final Collection < V > coll = getCollection ( key ) ; if ( coll == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return false ; } return coll . contains ( value ) ; } @SuppressWarnings ( lr_1 ) public Collection < V > getCollection ( final Object key ) {
if ( removed == false ) { return false ; } if ( valuesForKey . isEmpty () ) { MST[rv.ROR4Mutator]MSP[] remove ( key ) ; } return true ; } @Override @SuppressWarnings ( lr_1 ) public boolean containsValue ( final Object value ) {
final Set < Map . Entry < K , Object > > pairs = decorated () . entrySet () ; if ( pairs != null ) { MST[rv.ROR5Mutator]MSP[] for ( final Map . Entry < K , Object > entry : pairs ) {
if ( removed == false ) { return false ; } if ( valuesForKey . isEmpty () ) { remove ( key ) ; MST[NonVoidMethodCallMutator]MSP[] } return true ; } @Override @SuppressWarnings ( lr_1 ) public boolean containsValue ( final Object value ) {
return ( Collection < V > ) decorated () . get ( key ) ; } public int size ( final Object key ) { final Collection < V > coll = getCollection ( key ) ; if ( coll == null ) { return 0 ; MST[InlineConstantMutator]MSP[] }
final Collection < V > coll = getCollection ( key ) ; if ( coll == null ) { MST[rv.ROR5Mutator]MSP[] return false ; } return coll . contains ( value ) ; } @SuppressWarnings ( lr_1 ) public Collection < V > getCollection ( final Object key ) {
final Collection < V > vs = valuesView ; return ( Collection < Object > ) ( vs != null ? vs : ( valuesView = new Values () ) ) ; MST[rv.ROR5Mutator]MSP[] } public boolean containsValue ( final Object key , final Object value ) {
if ( ( ( Collection < V > ) entry . getValue () ) . contains ( value ) ) { return true ; MST[InlineConstantMutator]MSP[] } } } return false ; } @Override @SuppressWarnings ( lr_1 ) public Object put ( final K key , final Object value ) {
return ( Collection < V > ) decorated () . get ( key ) ; } public int size ( final Object key ) { final Collection < V > coll = getCollection ( key ) ; MST[NonVoidMethodCallMutator]MSP[] if ( coll == null ) { return 0 ; }
put ( entry . getKey () , entry . getValue () ) ; } } } @Override public Set < Entry < K , Object > > entrySet () { return super . entrySet () ; MST[EmptyObjectReturnValsMutator]MSP[] } @Override @SuppressWarnings ( lr_1 ) public Collection < Object > values () {
return MultiValueMap . <K , V , ArrayList > multiValueMap ( ( Map < K , ? super Collection > ) map , ArrayList . class ) ; MST[NonVoidMethodCallMutator]MSP[] }
final Collection < V > coll = getCollection ( key ) ; if ( coll == null ) { return false ; MST[ReturnValsMutator]MSP[] } return coll . contains ( value ) ; } @SuppressWarnings ( lr_1 ) public Collection < V > getCollection ( final Object key ) {
decorated () . put ( key , coll ) ; MST[NonVoidMethodCallMutator]MSP[] result = true ; } } else { result = coll . add ( ( V ) value ) ; } return result ? value : null ; } @Override @SuppressWarnings ( lr_1 )
protected Collection < V > createCollection ( final int size ) { return collectionFactory . create () ; MST[EmptyObjectReturnValsMutator]MSP[] } @Override public Iterator < V > iterator () { final IteratorChain < V > chain = new IteratorChain <> () ; for ( final K k : keySet () ) {
decorated () . put ( key , coll ) ; result = true ; MST[InlineConstantMutator]MSP[] } } else { result = coll . add ( ( V ) value ) ; } return result ? value : null ; } @Override @SuppressWarnings ( lr_1 )
final Collection < V > coll = getCollection ( key ) ; if ( coll == null ) { return false ; } return coll . contains ( value ) ; MST[NonVoidMethodCallMutator]MSP[] } @SuppressWarnings ( lr_1 ) public Collection < V > getCollection ( final Object key ) {
final Factory < C > collectionFactory ) { return new MultiValueMap <> ( map , collectionFactory ) ; MST[ReturnValsMutator]MSP[] } private void writeObject ( final ObjectOutputStream out ) throws IOException { out . defaultWriteObject () ; out . writeObject ( map ) ; } @SuppressWarnings ( lr_1 )
final Set < Map . Entry < K , Object > > pairs = decorated () . entrySet () ; if ( pairs != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] for ( final Map . Entry < K , Object > entry : pairs ) {
final Collection < V > vs = valuesView ; return ( Collection < Object > ) ( vs != null ? vs : ( valuesView = new Values () ) ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] } public boolean containsValue ( final Object key , final Object value ) {
return coll . size () ; } public boolean putAll ( final K key , final Collection < V > values ) { if ( values == null || values . size () == 0 ) { return false ; } boolean result = false ; MST[rv.CRCR6Mutator]MSP[]
if ( removed == false ) { return false ; } if ( valuesForKey . isEmpty () ) { MST[rv.ROR2Mutator]MSP[] remove ( key ) ; } return true ; } @Override @SuppressWarnings ( lr_1 ) public boolean containsValue ( final Object value ) {
return coll . size () ; } public boolean putAll ( final K key , final Collection < V > values ) { if ( values == null || values . size () == 0 ) { return false ; MST[InlineConstantMutator]MSP[] } boolean result = false ;
final Factory < C > collectionFactory ) { return new MultiValueMap <> ( map , collectionFactory ) ; MST[ConstructorCallMutator]MSP[] } private void writeObject ( final ObjectOutputStream out ) throws IOException { out . defaultWriteObject () ; out . writeObject ( map ) ; } @SuppressWarnings ( lr_1 )
boolean result = false ; Collection < V > coll = getCollection ( key ) ; if ( coll == null ) { coll = createCollection ( 1 ) ; MST[NonVoidMethodCallMutator]MSP[] coll . add ( ( V ) value ) ; if ( coll . size () > 0 ) {
if ( ! containsKey ( key ) ) { return EmptyIterator . <V > emptyIterator () ; MST[NonVoidMethodCallMutator]MSP[] } return new ValuesIterator ( key ) ; } @Override public V getValue () { return input ; } @Override public V setValue ( final V value ) {
throw new UnsupportedOperationException () ; } public int totalSize () { int total = 0 ; for ( final Object v : decorated () . values () ) { total += CollectionUtils . size ( v ) ; } return total ; MST[rv.ABSMutator]MSP[] }
protected Collection < V > createCollection ( final int size ) { return collectionFactory . create () ; MST[NonVoidMethodCallMutator]MSP[] } @Override public Iterator < V > iterator () { final IteratorChain < V > chain = new IteratorChain <> () ; for ( final K k : keySet () ) {
return new MultiValueMap <> ( map , new ReflectionFactory <> ( collectionClass ) ) ; MST[ReturnValsMutator]MSP[] } public static < K , V , C extends Collection < V > > MultiValueMap < K , V > multiValueMap ( final Map < K , ? super C > map ,
throw new UnsupportedOperationException () ; } public int totalSize () { int total = 0 ; MST[rv.CRCR3Mutator]MSP[] for ( final Object v : decorated () . values () ) { total += CollectionUtils . size ( v ) ; } return total ; }
decorated () . put ( key , coll ) ; result = true ; MST[rv.CRCR4Mutator]MSP[] } } else { result = coll . add ( ( V ) value ) ; } return result ? value : null ; } @Override @SuppressWarnings ( lr_1 )
public boolean removeMapping ( final Object key , final Object value ) { final Collection < V > valuesForKey = getCollection ( key ) ; if ( valuesForKey == null ) { return false ; MST[rv.CRCR6Mutator]MSP[] } final boolean removed = valuesForKey . remove ( value ) ;
boolean result = false ; MST[InlineConstantMutator]MSP[] Collection < V > coll = getCollection ( key ) ; if ( coll == null ) { coll = createCollection ( 1 ) ; coll . add ( ( V ) value ) ; if ( coll . size () > 0 ) {
put ( entry . getKey () , entry . getValue () ) ; } } } @Override public Set < Entry < K , Object > > entrySet () { return super . entrySet () ; MST[NonVoidMethodCallMutator]MSP[] } @Override @SuppressWarnings ( lr_1 ) public Collection < Object > values () {
if ( ( ( Collection < V > ) entry . getValue () ) . contains ( value ) ) { return true ; MST[rv.CRCR4Mutator]MSP[] } } } return false ; } @Override @SuppressWarnings ( lr_1 ) public Object put ( final K key , final Object value ) {
put ( entry . getKey () , entry . getValue () ) ; MST[NonVoidMethodCallMutator]MSP[] } } } @Override public Set < Entry < K , Object > > entrySet () { return super . entrySet () ; } @Override @SuppressWarnings ( lr_1 ) public Collection < Object > values () {
final Collection < V > vs = valuesView ; return ( Collection < Object > ) ( vs != null ? vs : ( valuesView = new Values () ) ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] } public boolean containsValue ( final Object key , final Object value ) {
decorated () . put ( key , coll ) ; result = true ; } } else { result = coll . add ( ( V ) value ) ; } return result ? value : null ; MST[NegateConditionalsMutator]MSP[] } @Override @SuppressWarnings ( lr_1 )
decorated () . put ( key , coll ) ; result = true ; } } else { result = coll . addAll ( values ) ; } return result ; MST[BooleanTrueReturnValsMutator]MSP[] } public Iterator < V > iterator ( final Object key ) {
final Factory < C > collectionFactory ) { return new MultiValueMap <> ( map , collectionFactory ) ; } private void writeObject ( final ObjectOutputStream out ) throws IOException { out . defaultWriteObject () ; MST[VoidMethodCallMutator]MSP[] out . writeObject ( map ) ; } @SuppressWarnings ( lr_1 )
put ( entry . getKey () , entry . getValue () ) ; MST[ArgumentPropagationMutator]MSP[] } } } @Override public Set < Entry < K , Object > > entrySet () { return super . entrySet () ; } @Override @SuppressWarnings ( lr_1 ) public Collection < Object > values () {
decorated () . put ( key , coll ) ; result = true ; } } else { result = coll . addAll ( values ) ; } return result ; MST[rv.UOI1Mutator]MSP[] } public Iterator < V > iterator ( final Object key ) {
if ( ! containsKey ( key ) ) { return EmptyIterator . <V > emptyIterator () ; MST[NullReturnValsMutator]MSP[] } return new ValuesIterator ( key ) ; } @Override public V getValue () { return input ; } @Override public V setValue ( final V value ) {
if ( ! containsKey ( key ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return EmptyIterator . <V > emptyIterator () ; } return new ValuesIterator ( key ) ; } @Override public V getValue () { return input ; } @Override public V setValue ( final V value ) {
Collection < V > coll = getCollection ( key ) ; if ( coll == null ) { coll = createCollection ( values . size () ) ; coll . addAll ( values ) ; if ( coll . size () > 0 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[]
if ( ( ( Collection < V > ) entry . getValue () ) . contains ( value ) ) { MST[NegateConditionalsMutator]MSP[] return true ; } } } return false ; } @Override @SuppressWarnings ( lr_1 ) public Object put ( final K key , final Object value ) {
decorated () . put ( key , coll ) ; result = true ; } } else { result = coll . add ( ( V ) value ) ; } return result ? value : null ; MST[rv.UOI3Mutator]MSP[] } @Override @SuppressWarnings ( lr_1 )
boolean result = false ; Collection < V > coll = getCollection ( key ) ; if ( coll == null ) { coll = createCollection ( 1 ) ; MST[rv.CRCR4Mutator]MSP[] coll . add ( ( V ) value ) ; if ( coll . size () > 0 ) {
return new MultiValueMap <> ( map , new ReflectionFactory <> ( collectionClass ) ) ; MST[ConstructorCallMutator]MSP[] } public static < K , V , C extends Collection < V > > MultiValueMap < K , V > multiValueMap ( final Map < K , ? super C > map ,
boolean result = false ; Collection < V > coll = getCollection ( key ) ; if ( coll == null ) { coll = createCollection ( 1 ) ; coll . add ( ( V ) value ) ; if ( coll . size () > 0 ) { MST[rv.ROR4Mutator]MSP[]
return ( Collection < V > ) decorated () . get ( key ) ; MST[EmptyObjectReturnValsMutator]MSP[] } public int size ( final Object key ) { final Collection < V > coll = getCollection ( key ) ; if ( coll == null ) { return 0 ; }
if ( ( ( Collection < V > ) entry . getValue () ) . contains ( value ) ) { return true ; } } } return false ; MST[InlineConstantMutator]MSP[] } @Override @SuppressWarnings ( lr_1 ) public Object put ( final K key , final Object value ) {
final Collection < V > coll = getCollection ( key ) ; if ( coll == null ) { return false ; MST[rv.CRCR5Mutator]MSP[] } return coll . contains ( value ) ; } @SuppressWarnings ( lr_1 ) public Collection < V > getCollection ( final Object key ) {
final Collection < V > coll = getCollection ( key ) ; if ( coll == null ) { return false ; MST[rv.CRCR1Mutator]MSP[] } return coll . contains ( value ) ; } @SuppressWarnings ( lr_1 ) public Collection < V > getCollection ( final Object key ) {
if ( removed == false ) { return false ; } if ( valuesForKey . isEmpty () ) { remove ( key ) ; } return true ; MST[rv.CRCR2Mutator]MSP[] } @Override @SuppressWarnings ( lr_1 ) public boolean containsValue ( final Object value ) {
if ( removed == false ) { return false ; } if ( valuesForKey . isEmpty () ) { remove ( key ) ; } return true ; MST[rv.CRCR6Mutator]MSP[] } @Override @SuppressWarnings ( lr_1 ) public boolean containsValue ( final Object value ) {
decorated () . put ( key , coll ) ; MST[NonVoidMethodCallMutator]MSP[] result = true ; } } else { result = coll . addAll ( values ) ; } return result ; } public Iterator < V > iterator ( final Object key ) {
boolean result = false ; Collection < V > coll = getCollection ( key ) ; if ( coll == null ) { coll = createCollection ( 1 ) ; coll . add ( ( V ) value ) ; if ( coll . size () > 0 ) { MST[ConditionalsBoundaryMutator]MSP[]
decorated () . put ( key , coll ) ; result = true ; MST[rv.CRCR2Mutator]MSP[] } } else { result = coll . addAll ( values ) ; } return result ; } public Iterator < V > iterator ( final Object key ) {
decorated () . put ( key , coll ) ; result = true ; MST[rv.CRCR6Mutator]MSP[] } } else { result = coll . addAll ( values ) ; } return result ; } public Iterator < V > iterator ( final Object key ) {
final Collection < V > coll = getCollection ( key ) ; if ( coll == null ) { return false ; MST[BooleanTrueReturnValsMutator]MSP[] } return coll . contains ( value ) ; } @SuppressWarnings ( lr_1 ) public Collection < V > getCollection ( final Object key ) {
decorated () . put ( key , coll ) ; result = true ; } } else { result = coll . add ( ( V ) value ) ; } return result ? value : null ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] } @Override @SuppressWarnings ( lr_1 )
final Collection < V > vs = valuesView ; return ( Collection < Object > ) ( vs != null ? vs : ( valuesView = new Values () ) ) ; MST[ConstructorCallMutator]MSP[] } public boolean containsValue ( final Object key , final Object value ) {
if ( ( ( Collection < V > ) entry . getValue () ) . contains ( value ) ) { return true ; MST[BooleanFalseReturnValsMutator]MSP[] } } } return false ; } @Override @SuppressWarnings ( lr_1 ) public Object put ( final K key , final Object value ) {
if ( removed == false ) { MST[rv.UOI2Mutator]MSP[] return false ; } if ( valuesForKey . isEmpty () ) { remove ( key ) ; } return true ; } @Override @SuppressWarnings ( lr_1 ) public boolean containsValue ( final Object value ) {
Collection < V > coll = getCollection ( key ) ; if ( coll == null ) { coll = createCollection ( values . size () ) ; coll . addAll ( values ) ; if ( coll . size () > 0 ) { MST[NonVoidMethodCallMutator]MSP[]
throw new UnsupportedOperationException () ; } public int totalSize () { int total = 0 ; for ( final Object v : decorated () . values () ) { total += CollectionUtils . size ( v ) ; MST[rv.UOI3Mutator]MSP[] } return total ; }
boolean result = false ; Collection < V > coll = getCollection ( key ) ; if ( coll == null ) { coll = createCollection ( 1 ) ; coll . add ( ( V ) value ) ; if ( coll . size () > 0 ) { MST[NegateConditionalsMutator]MSP[]
public void putAll ( final Map < ? extends K , ? > map ) { if ( map instanceof MultiMap ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
Collection < V > coll = getCollection ( key ) ; if ( coll == null ) { coll = createCollection ( values . size () ) ; coll . addAll ( values ) ; if ( coll . size () > 0 ) { MST[rv.ROR2Mutator]MSP[]
if ( ! containsKey ( key ) ) { MST[rv.ROR1Mutator]MSP[] return EmptyIterator . <V > emptyIterator () ; } return new ValuesIterator ( key ) ; } @Override public V getValue () { return input ; } @Override public V setValue ( final V value ) {
if ( removed == false ) { MST[rv.ROR2Mutator]MSP[] return false ; } if ( valuesForKey . isEmpty () ) { remove ( key ) ; } return true ; } @Override @SuppressWarnings ( lr_1 ) public boolean containsValue ( final Object value ) {
if ( ( ( Collection < V > ) entry . getValue () ) . contains ( value ) ) { return true ; } } } return false ; MST[rv.CRCR3Mutator]MSP[] } @Override @SuppressWarnings ( lr_1 ) public Object put ( final K key , final Object value ) {
return coll . size () ; } public boolean putAll ( final K key , final Collection < V > values ) { if ( values == null || values . size () == 0 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return false ; } boolean result = false ;
Collection < V > coll = getCollection ( key ) ; if ( coll == null ) { coll = createCollection ( values . size () ) ; MST[NonVoidMethodCallMutator]MSP[] coll . addAll ( values ) ; if ( coll . size () > 0 ) {
private void readObject ( final ObjectInputStream in ) throws IOException , ClassNotFoundException { in . defaultReadObject () ; MST[VoidMethodCallMutator]MSP[] map = ( Map < K , Object > ) in . readObject () ; } @Override public void clear () { decorated () . clear () ; } @Override
return ( Collection < V > ) decorated () . get ( key ) ; } public int size ( final Object key ) { final Collection < V > coll = getCollection ( key ) ; if ( coll == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return 0 ; }
if ( ( ( Collection < V > ) entry . getValue () ) . contains ( value ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return true ; } } } return false ; } @Override @SuppressWarnings ( lr_1 ) public Object put ( final K key , final Object value ) {
if ( ( ( Collection < V > ) entry . getValue () ) . contains ( value ) ) { return true ; } } } return false ; MST[rv.CRCR6Mutator]MSP[] } @Override @SuppressWarnings ( lr_1 ) public Object put ( final K key , final Object value ) {
if ( ! containsKey ( key ) ) { return EmptyIterator . <V > emptyIterator () ; } return new ValuesIterator ( key ) ; MST[ConstructorCallMutator]MSP[] } @Override public V getValue () { return input ; } @Override public V setValue ( final V value ) {
return MultiValueMap . <K , V , ArrayList > multiValueMap ( ( Map < K , ? super Collection > ) map , ArrayList . class ) ; MST[ReturnValsMutator]MSP[] }
if ( ! containsKey ( key ) ) { MST[rv.ROR4Mutator]MSP[] return EmptyIterator . <V > emptyIterator () ; } return new ValuesIterator ( key ) ; } @Override public V getValue () { return input ; } @Override public V setValue ( final V value ) {
boolean result = false ; Collection < V > coll = getCollection ( key ) ; if ( coll == null ) { MST[NegateConditionalsMutator]MSP[] coll = createCollection ( 1 ) ; coll . add ( ( V ) value ) ; if ( coll . size () > 0 ) {
public void putAll ( final Map < ? extends K , ? > map ) { if ( map instanceof MultiMap ) { MST[rv.ROR5Mutator]MSP[]
return ( Collection < V > ) decorated () . get ( key ) ; } public int size ( final Object key ) { final Collection < V > coll = getCollection ( key ) ; if ( coll == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return 0 ; }
if ( removed == false ) { return false ; MST[BooleanTrueReturnValsMutator]MSP[] } if ( valuesForKey . isEmpty () ) { remove ( key ) ; } return true ; } @Override @SuppressWarnings ( lr_1 ) public boolean containsValue ( final Object value ) {
if ( removed == false ) { return false ; MST[rv.CRCR3Mutator]MSP[] } if ( valuesForKey . isEmpty () ) { remove ( key ) ; } return true ; } @Override @SuppressWarnings ( lr_1 ) public boolean containsValue ( final Object value ) {
private void readObject ( final ObjectInputStream in ) throws IOException , ClassNotFoundException { in . defaultReadObject () ; map = ( Map < K , Object > ) in . readObject () ; } @Override public void clear () { decorated () . clear () ; MST[NonVoidMethodCallMutator]MSP[] } @Override
public void putAll ( final Map < ? extends K , ? > map ) { if ( map instanceof MultiMap ) { MST[rv.ROR3Mutator]MSP[]
public void putAll ( final Map < ? extends K , ? > map ) { if ( map instanceof MultiMap ) { MST[rv.ROR2Mutator]MSP[]
final Set < Map . Entry < K , Object > > pairs = decorated () . entrySet () ; MST[NonVoidMethodCallMutator]MSP[] if ( pairs != null ) { for ( final Map . Entry < K , Object > entry : pairs ) {
if ( removed == false ) { return false ; MST[rv.CRCR5Mutator]MSP[] } if ( valuesForKey . isEmpty () ) { remove ( key ) ; } return true ; } @Override @SuppressWarnings ( lr_1 ) public boolean containsValue ( final Object value ) {
if ( ( ( Collection < V > ) entry . getValue () ) . contains ( value ) ) { return true ; } } } return false ; MST[rv.CRCR1Mutator]MSP[] } @Override @SuppressWarnings ( lr_1 ) public Object put ( final K key , final Object value ) {
for ( final Map . Entry < ? extends K , Object > entry : ( ( MultiMap < ? extends K , V > ) map ) . entrySet () ) { MST[NonVoidMethodCallMutator]MSP[]
decorated () . put ( key , coll ) ; result = true ; } } else { result = coll . add ( ( V ) value ) ; } return result ? value : null ; MST[rv.ROR2Mutator]MSP[] } @Override @SuppressWarnings ( lr_1 )
decorated () . put ( key , coll ) ; result = true ; } } else { result = coll . add ( ( V ) value ) ; } return result ? value : null ; MST[rv.ROR5Mutator]MSP[] } @Override @SuppressWarnings ( lr_1 )
if ( ! containsKey ( key ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return EmptyIterator . <V > emptyIterator () ; } return new ValuesIterator ( key ) ; } @Override public V getValue () { return input ; } @Override public V setValue ( final V value ) {
return coll . size () ; } public boolean putAll ( final K key , final Collection < V > values ) { if ( values == null || values . size () == 0 ) { MST[rv.ROR4Mutator]MSP[] return false ; } boolean result = false ;
decorated () . put ( key , coll ) ; result = true ; MST[rv.CRCR3Mutator]MSP[] } } else { result = coll . addAll ( values ) ; } return result ; } public Iterator < V > iterator ( final Object key ) {
throw new UnsupportedOperationException () ; } public int totalSize () { int total = 0 ; MST[InlineConstantMutator]MSP[] for ( final Object v : decorated () . values () ) { total += CollectionUtils . size ( v ) ; } return total ; }
final Collection < V > vs = valuesView ; return ( Collection < Object > ) ( vs != null ? vs : ( valuesView = new Values () ) ) ; MST[NegateConditionalsMutator]MSP[] } public boolean containsValue ( final Object key , final Object value ) {
throw new UnsupportedOperationException () ; } public int totalSize () { int total = 0 ; for ( final Object v : decorated () . values () ) { total += CollectionUtils . size ( v ) ; MST[rv.AOR3Mutator]MSP[] } return total ; }
boolean result = false ; Collection < V > coll = getCollection ( key ) ; if ( coll == null ) { coll = createCollection ( 1 ) ; coll . add ( ( V ) value ) ; if ( coll . size () > 0 ) { MST[rv.ROR5Mutator]MSP[]
return coll . size () ; } public boolean putAll ( final K key , final Collection < V > values ) { if ( values == null || values . size () == 0 ) { MST[rv.ROR5Mutator]MSP[] return false ; } boolean result = false ;
if ( removed == false ) { return false ; } if ( valuesForKey . isEmpty () ) { remove ( key ) ; } return true ; MST[rv.CRCR3Mutator]MSP[] } @Override @SuppressWarnings ( lr_1 ) public boolean containsValue ( final Object value ) {
if ( removed == false ) { return false ; } if ( valuesForKey . isEmpty () ) { remove ( key ) ; } return true ; MST[rv.CRCR5Mutator]MSP[] } @Override @SuppressWarnings ( lr_1 ) public boolean containsValue ( final Object value ) {
if ( removed == false ) { return false ; MST[ReturnValsMutator]MSP[] } if ( valuesForKey . isEmpty () ) { remove ( key ) ; } return true ; } @Override @SuppressWarnings ( lr_1 ) public boolean containsValue ( final Object value ) {
throw new UnsupportedOperationException () ; } public int totalSize () { MST[NegateConditionalsMutator]MSP[] int total = 0 ; for ( final Object v : decorated () . values () ) { total += CollectionUtils . size ( v ) ; } return total ; }
putAll ( entry . getKey () , ( Collection < V > ) entry . getValue () ) ; MST[NonVoidMethodCallMutator]MSP[] } } else { for ( final Map . Entry < ? extends K , ? > entry : map . entrySet () ) {
return coll . size () ; } public boolean putAll ( final K key , final Collection < V > values ) { if ( values == null || values . size () == 0 ) { MST[NegateConditionalsMutator]MSP[] return false ; } boolean result = false ;
throw new UnsupportedOperationException () ; } public int totalSize () { MST[ConstructorCallMutator]MSP[] int total = 0 ; for ( final Object v : decorated () . values () ) { total += CollectionUtils . size ( v ) ; } return total ; }
return ( Collection < V > ) decorated () . get ( key ) ; } public int size ( final Object key ) { final Collection < V > coll = getCollection ( key ) ; if ( coll == null ) { return 0 ; MST[rv.CRCR6Mutator]MSP[] }
decorated () . put ( key , coll ) ; result = true ; MST[rv.CRCR5Mutator]MSP[] } } else { result = coll . addAll ( values ) ; } return result ; } public Iterator < V > iterator ( final Object key ) {
boolean result = false ; MST[rv.CRCR3Mutator]MSP[] Collection < V > coll = getCollection ( key ) ; if ( coll == null ) { coll = createCollection ( 1 ) ; coll . add ( ( V ) value ) ; if ( coll . size () > 0 ) {
return new MultiValueMap <> ( map , new ReflectionFactory <> ( collectionClass ) ) ; MST[ConstructorCallMutator]MSP[] } public static < K , V , C extends Collection < V > > MultiValueMap < K , V > multiValueMap ( final Map < K , ? super C > map ,
boolean result = false ; MST[rv.CRCR5Mutator]MSP[] Collection < V > coll = getCollection ( key ) ; if ( coll == null ) { coll = createCollection ( 1 ) ; coll . add ( ( V ) value ) ; if ( coll . size () > 0 ) {
decorated () . put ( key , coll ) ; MST[NonVoidMethodCallMutator]MSP[] result = true ; } } else { result = coll . addAll ( values ) ; } return result ; } public Iterator < V > iterator ( final Object key ) {
if ( removed == false ) { MST[rv.UOI3Mutator]MSP[] return false ; } if ( valuesForKey . isEmpty () ) { remove ( key ) ; } return true ; } @Override @SuppressWarnings ( lr_1 ) public boolean containsValue ( final Object value ) {
return coll . size () ; } public boolean putAll ( final K key , final Collection < V > values ) { if ( values == null || values . size () == 0 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return false ; } boolean result = false ;
public void putAll ( final Map < ? extends K , ? > map ) { if ( map instanceof MultiMap ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
throw new UnsupportedOperationException () ; } public int totalSize () { int total = 0 ; for ( final Object v : decorated () . values () ) { total += CollectionUtils . size ( v ) ; MST[rv.UOI2Mutator]MSP[] } return total ; }
throw new UnsupportedOperationException () ; } public int totalSize () { int total = 0 ; for ( final Object v : decorated () . values () ) { total += CollectionUtils . size ( v ) ; } return total ; MST[PrimitiveReturnsMutator]MSP[] }
final Collection < V > vs = valuesView ; return ( Collection < Object > ) ( vs != null ? vs : ( valuesView = new Values () ) ) ; MST[experimental.MemberVariableMutator]MSP[] } public boolean containsValue ( final Object key , final Object value ) {
putAll ( entry . getKey () , ( Collection < V > ) entry . getValue () ) ; } } else { for ( final Map . Entry < ? extends K , ? > entry : map . entrySet () ) { MST[NonVoidMethodCallMutator]MSP[]
return coll . size () ; } public boolean putAll ( final K key , final Collection < V > values ) { if ( values == null || values . size () == 0 ) { return false ; MST[rv.CRCR1Mutator]MSP[] } boolean result = false ;
Collection < V > coll = getCollection ( key ) ; if ( coll == null ) { coll = createCollection ( values . size () ) ; coll . addAll ( values ) ; if ( coll . size () > 0 ) { MST[rv.ROR3Mutator]MSP[]
Collection < V > coll = getCollection ( key ) ; if ( coll == null ) { coll = createCollection ( values . size () ) ; coll . addAll ( values ) ; if ( coll . size () > 0 ) { MST[rv.ROR5Mutator]MSP[]
public boolean removeMapping ( final Object key , final Object value ) { final Collection < V > valuesForKey = getCollection ( key ) ; if ( valuesForKey == null ) { return false ; MST[rv.CRCR3Mutator]MSP[] } final boolean removed = valuesForKey . remove ( value ) ;
if ( removed == false ) { return false ; } if ( valuesForKey . isEmpty () ) { remove ( key ) ; } return true ; MST[InlineConstantMutator]MSP[] } @Override @SuppressWarnings ( lr_1 ) public boolean containsValue ( final Object value ) {
return coll . size () ; MST[ReturnValsMutator]MSP[] } public boolean putAll ( final K key , final Collection < V > values ) { if ( values == null || values . size () == 0 ) { return false ; } boolean result = false ;
decorated () . put ( key , coll ) ; result = true ; MST[InlineConstantMutator]MSP[] } } else { result = coll . addAll ( values ) ; } return result ; } public Iterator < V > iterator ( final Object key ) {
final Collection < V > coll = getCollection ( key ) ; if ( coll == null ) { MST[NegateConditionalsMutator]MSP[] return false ; } return coll . contains ( value ) ; } @SuppressWarnings ( lr_1 ) public Collection < V > getCollection ( final Object key ) {
decorated () . put ( key , coll ) ; result = true ; MST[rv.CRCR2Mutator]MSP[] } } else { result = coll . add ( ( V ) value ) ; } return result ? value : null ; } @Override @SuppressWarnings ( lr_1 )
return coll . size () ; } public boolean putAll ( final K key , final Collection < V > values ) { if ( values == null || values . size () == 0 ) { return false ; } boolean result = false ; MST[rv.CRCR3Mutator]MSP[]
decorated () . put ( key , coll ) ; result = true ; MST[rv.CRCR5Mutator]MSP[] } } else { result = coll . add ( ( V ) value ) ; } return result ? value : null ; } @Override @SuppressWarnings ( lr_1 )
Collection < V > coll = getCollection ( key ) ; if ( coll == null ) { coll = createCollection ( values . size () ) ; coll . addAll ( values ) ; if ( coll . size () > 0 ) { MST[ConditionalsBoundaryMutator]MSP[]
final Set < Map . Entry < K , Object > > pairs = decorated () . entrySet () ; if ( pairs != null ) { MST[NegateConditionalsMutator]MSP[] for ( final Map . Entry < K , Object > entry : pairs ) {
throw new UnsupportedOperationException () ; } public int totalSize () { int total = 0 ; MST[rv.CRCR5Mutator]MSP[] for ( final Object v : decorated () . values () ) { total += CollectionUtils . size ( v ) ; } return total ; }
if ( ( ( Collection < V > ) entry . getValue () ) . contains ( value ) ) { return true ; MST[rv.CRCR6Mutator]MSP[] } } } return false ; } @Override @SuppressWarnings ( lr_1 ) public Object put ( final K key , final Object value ) {
if ( ( ( Collection < V > ) entry . getValue () ) . contains ( value ) ) { return true ; MST[rv.CRCR3Mutator]MSP[] } } } return false ; } @Override @SuppressWarnings ( lr_1 ) public Object put ( final K key , final Object value ) {
Collection < V > coll = getCollection ( key ) ; if ( coll == null ) { MST[rv.ROR5Mutator]MSP[] coll = createCollection ( values . size () ) ; coll . addAll ( values ) ; if ( coll . size () > 0 ) {
private void readObject ( final ObjectInputStream in ) throws IOException , ClassNotFoundException { in . defaultReadObject () ; map = ( Map < K , Object > ) in . readObject () ; } @Override public void clear () { decorated () . clear () ; MST[VoidMethodCallMutator]MSP[] } @Override
decorated () . put ( key , coll ) ; MST[NonVoidMethodCallMutator]MSP[] result = true ; } } else { result = coll . add ( ( V ) value ) ; } return result ? value : null ; } @Override @SuppressWarnings ( lr_1 )
if ( ! containsKey ( key ) ) { MST[NegateConditionalsMutator]MSP[] return EmptyIterator . <V > emptyIterator () ; } return new ValuesIterator ( key ) ; } @Override public V getValue () { return input ; } @Override public V setValue ( final V value ) {
final Set < Map . Entry < K , Object > > pairs = decorated () . entrySet () ; MST[NonVoidMethodCallMutator]MSP[] if ( pairs != null ) { for ( final Map . Entry < K , Object > entry : pairs ) {
return ( Collection < V > ) decorated () . get ( key ) ; } public int size ( final Object key ) { final Collection < V > coll = getCollection ( key ) ; if ( coll == null ) { return 0 ; MST[rv.CRCR3Mutator]MSP[] }
put ( entry . getKey () , entry . getValue () ) ; MST[NonVoidMethodCallMutator]MSP[] } } } @Override public Set < Entry < K , Object > > entrySet () { return super . entrySet () ; } @Override @SuppressWarnings ( lr_1 ) public Collection < Object > values () {
decorated () . put ( key , coll ) ; result = true ; } } else { result = coll . addAll ( values ) ; } return result ; MST[rv.UOI3Mutator]MSP[] } public Iterator < V > iterator ( final Object key ) {
public boolean removeMapping ( final Object key , final Object value ) { final Collection < V > valuesForKey = getCollection ( key ) ; if ( valuesForKey == null ) { return false ; MST[ReturnValsMutator]MSP[] } final boolean removed = valuesForKey . remove ( value ) ;
boolean result = false ; Collection < V > coll = getCollection ( key ) ; if ( coll == null ) { coll = createCollection ( 1 ) ; MST[rv.CRCR2Mutator]MSP[] coll . add ( ( V ) value ) ; if ( coll . size () > 0 ) {
return ( Collection < V > ) decorated () . get ( key ) ; MST[ReturnValsMutator]MSP[] } public int size ( final Object key ) { final Collection < V > coll = getCollection ( key ) ; if ( coll == null ) { return 0 ; }
boolean result = false ; Collection < V > coll = getCollection ( key ) ; if ( coll == null ) { coll = createCollection ( 1 ) ; MST[rv.CRCR5Mutator]MSP[] coll . add ( ( V ) value ) ; if ( coll . size () > 0 ) {
boolean result = false ; Collection < V > coll = getCollection ( key ) ; if ( coll == null ) { coll = createCollection ( 1 ) ; coll . add ( ( V ) value ) ; if ( coll . size () > 0 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[]
boolean result = false ; Collection < V > coll = getCollection ( key ) ; if ( coll == null ) { coll = createCollection ( 1 ) ; coll . add ( ( V ) value ) ; if ( coll . size () > 0 ) { MST[rv.ROR2Mutator]MSP[]
final Collection < V > coll = getCollection ( key ) ; if ( coll == null ) { return false ; } return coll . contains ( value ) ; MST[BooleanFalseReturnValsMutator]MSP[] } @SuppressWarnings ( lr_1 ) public Collection < V > getCollection ( final Object key ) {
return coll . size () ; } public boolean putAll ( final K key , final Collection < V > values ) { if ( values == null || values . size () == 0 ) { MST[rv.ROR1Mutator]MSP[] return false ; } boolean result = false ;
if ( removed == false ) { return false ; } if ( valuesForKey . isEmpty () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] remove ( key ) ; } return true ; } @Override @SuppressWarnings ( lr_1 ) public boolean containsValue ( final Object value ) {
if ( ( ( Collection < V > ) entry . getValue () ) . contains ( value ) ) { MST[rv.ROR3Mutator]MSP[] return true ; } } } return false ; } @Override @SuppressWarnings ( lr_1 ) public Object put ( final K key , final Object value ) {
boolean result = false ; Collection < V > coll = getCollection ( key ) ; if ( coll == null ) { coll = createCollection ( 1 ) ; coll . add ( ( V ) value ) ; if ( coll . size () > 0 ) { MST[NonVoidMethodCallMutator]MSP[]
final Collection < V > vs = valuesView ; return ( Collection < Object > ) ( vs != null ? vs : ( valuesView = new Values () ) ) ; MST[EmptyObjectReturnValsMutator]MSP[] } public boolean containsValue ( final Object key , final Object value ) {
if ( ( ( Collection < V > ) entry . getValue () ) . contains ( value ) ) { MST[NonVoidMethodCallMutator]MSP[] return true ; } } } return false ; } @Override @SuppressWarnings ( lr_1 ) public Object put ( final K key , final Object value ) {
return MultiValueMap . <K , V , ArrayList > multiValueMap ( ( Map < K , ? super Collection > ) map , ArrayList . class ) ; MST[NullReturnValsMutator]MSP[] }
if ( ( ( Collection < V > ) entry . getValue () ) . contains ( value ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return true ; } } } return false ; } @Override @SuppressWarnings ( lr_1 ) public Object put ( final K key , final Object value ) {
public boolean removeMapping ( final Object key , final Object value ) { final Collection < V > valuesForKey = getCollection ( key ) ; if ( valuesForKey == null ) { return false ; MST[InlineConstantMutator]MSP[] } final boolean removed = valuesForKey . remove ( value ) ;
return ( Collection < V > ) decorated () . get ( key ) ; MST[ArgumentPropagationMutator]MSP[] } public int size ( final Object key ) { final Collection < V > coll = getCollection ( key ) ; if ( coll == null ) { return 0 ; }
if ( removed == false ) { return false ; } if ( valuesForKey . isEmpty () ) { remove ( key ) ; } return true ; MST[ReturnValsMutator]MSP[] } @Override @SuppressWarnings ( lr_1 ) public boolean containsValue ( final Object value ) {
if ( removed == false ) { MST[rv.ROR5Mutator]MSP[] return false ; } if ( valuesForKey . isEmpty () ) { remove ( key ) ; } return true ; } @Override @SuppressWarnings ( lr_1 ) public boolean containsValue ( final Object value ) {
return coll . size () ; } public boolean putAll ( final K key , final Collection < V > values ) { if ( values == null || values . size () == 0 ) { return false ; } boolean result = false ; MST[InlineConstantMutator]MSP[]
