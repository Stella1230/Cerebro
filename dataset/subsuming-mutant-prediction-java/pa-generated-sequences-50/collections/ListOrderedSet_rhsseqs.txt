return new OrderedSetIterator <> ( setOrder . listIterator () , decorated () ) ; } @Override public boolean add ( final E object ) { if ( decorated () . add ( object ) ) { setOrder . add ( object ) ; return true ; MST[rv.CRCR2Mutator]MSP[N] } return false ;
public E remove ( final int index ) { final E obj = setOrder . remove ( index ) ; remove ( obj ) ; MST[NonVoidMethodCallMutator]MSP[S] return obj ; } @Override public String toString () { return setOrder . toString () ; } @Override public E next () {
if ( contains ( e ) ) { continue; } decorated () . add ( e ) ; toAdd . add ( e ) ; changed = true ; } if ( changed ) { setOrder . addAll ( index , toAdd ) ; MST[rv.UOI4Mutator]MSP[N] } return changed ; }
if ( contains ( e ) ) { continue; } decorated () . add ( e ) ; toAdd . add ( e ) ; changed = true ; } if ( changed ) { setOrder . addAll ( index , toAdd ) ; MST[rv.UOI2Mutator]MSP[N] } return changed ; }
setOrder . removeIf ( filter ) ; } return result ; MST[BooleanTrueReturnValsMutator]MSP[N] } @Override public boolean removeAll ( final Collection < ? > coll ) { boolean result = false ; for ( final Object name : coll ) { result |= remove ( name ) ; } return result ;
setOrder . removeIf ( filter ) ; } return result ; } @Override public boolean removeAll ( final Collection < ? > coll ) { boolean result = false ; for ( final Object name : coll ) { result |= remove ( name ) ; } return result ; MST[rv.UOI4Mutator]MSP[N]
setOrder . removeIf ( filter ) ; } return result ; } @Override public boolean removeAll ( final Collection < ? > coll ) { boolean result = false ; for ( final Object name : coll ) { result |= remove ( name ) ; } return result ; MST[rv.UOI2Mutator]MSP[N]
setOrder . removeIf ( filter ) ; } return result ; } @Override public boolean removeAll ( final Collection < ? > coll ) { boolean result = false ; MST[rv.CRCR5Mutator]MSP[S] for ( final Object name : coll ) { result |= remove ( name ) ; } return result ;
public static < E > ListOrderedSet < E > listOrderedSet ( final Set < E > set ) { return new ListOrderedSet <> ( set ) ; MST[ReturnValsMutator]MSP[N] } public static < E > ListOrderedSet < E > listOrderedSet ( final List < E > list ) {
public static < E > ListOrderedSet < E > listOrderedSet ( final Set < E > set , final List < E > list ) { Objects . requireNonNull ( set , lr_1 ) ; MST[NonVoidMethodCallMutator]MSP[N] Objects . requireNonNull ( list , lr_2 ) ;
} @Override public boolean retainAll ( final Collection < ? > coll ) { final boolean result = decorated () . retainAll ( coll ) ; if ( result == false ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return false ; } if ( decorated () . isEmpty () ) {
} @Override public boolean addAll ( final Collection < ? extends E > coll ) { boolean result = false ; for ( final E e : coll ) { result |= add ( e ) ; } return result ; MST[BooleanFalseReturnValsMutator]MSP[N] } @Override
setOrder . removeIf ( filter ) ; } return result ; } @Override public boolean removeAll ( final Collection < ? > coll ) { boolean result = false ; MST[rv.CRCR3Mutator]MSP[S] for ( final Object name : coll ) { result |= remove ( name ) ; } return result ;
setOrder . removeIf ( filter ) ; } return result ; } @Override public boolean removeAll ( final Collection < ? > coll ) { boolean result = false ; MST[rv.CRCR1Mutator]MSP[S] for ( final Object name : coll ) { result |= remove ( name ) ; } return result ;
return setOrder . indexOf ( object ) ; } public void add ( final int index , final E object ) { if ( ! contains ( object ) ) { MST[rv.ROR5Mutator]MSP[N] decorated () . add ( object ) ; setOrder . add ( index , object ) ; } }
return setOrder . indexOf ( object ) ; } public void add ( final int index , final E object ) { if ( ! contains ( object ) ) { MST[rv.ROR3Mutator]MSP[N] decorated () . add ( object ) ; setOrder . add ( index , object ) ; } }
setOrder . removeIf ( filter ) ; } return result ; MST[ReturnValsMutator]MSP[N] } @Override public boolean removeAll ( final Collection < ? > coll ) { boolean result = false ; for ( final Object name : coll ) { result |= remove ( name ) ; } return result ;
if ( contains ( e ) ) { continue; } decorated () . add ( e ) ; toAdd . add ( e ) ; changed = true ; } if ( changed ) { setOrder . addAll ( index , toAdd ) ; } return changed ; MST[rv.ABSMutator]MSP[N] }
public boolean remove ( final Object object ) { final boolean result = decorated () . remove ( object ) ; if ( result ) { setOrder . remove ( object ) ; } return result ; MST[BooleanFalseReturnValsMutator]MSP[N] } @Override
public < T > T [] toArray ( final T a [] ) { return setOrder . toArray ( a ) ; MST[NonVoidMethodCallMutator]MSP[N] } public E get ( final int index ) { return setOrder . get ( index ) ; } public int indexOf ( final Object object ) {
Objects . requireNonNull ( list , lr_2 ) ; MST[NonVoidMethodCallMutator]MSP[N] CollectionUtils . filter ( list , UniquePredicate . uniquePredicate () ) ; final Set < E > set = new HashSet <> ( list ) ; return new ListOrderedSet <> ( set , list ) ; }
return new OrderedSetIterator <> ( setOrder . listIterator () , decorated () ) ; } @Override public boolean add ( final E object ) { if ( decorated () . add ( object ) ) { setOrder . add ( object ) ; return true ; MST[rv.CRCR6Mutator]MSP[N] } return false ;
public boolean removeIf ( final Predicate < ? super E > filter ) { if ( Objects . isNull ( filter ) ) { return false ; } final boolean result = decorated () . removeIf ( filter ) ; if ( result ) { MST[rv.ROR3Mutator]MSP[S]
public boolean removeIf ( final Predicate < ? super E > filter ) { if ( Objects . isNull ( filter ) ) { return false ; } final boolean result = decorated () . removeIf ( filter ) ; if ( result ) { MST[rv.UOI4Mutator]MSP[N]
public boolean removeIf ( final Predicate < ? super E > filter ) { if ( Objects . isNull ( filter ) ) { return false ; } final boolean result = decorated () . removeIf ( filter ) ; if ( result ) { MST[rv.ABSMutator]MSP[N]
} @Override public boolean addAll ( final Collection < ? extends E > coll ) { boolean result = false ; for ( final E e : coll ) { result |= add ( e ) ; } return result ; MST[rv.ABSMutator]MSP[N] } @Override
return new OrderedSetIterator <> ( setOrder . listIterator () , decorated () ) ; } @Override public boolean add ( final E object ) { if ( decorated () . add ( object ) ) { setOrder . add ( object ) ; return true ; MST[rv.CRCR4Mutator]MSP[N] } return false ;
public boolean removeIf ( final Predicate < ? super E > filter ) { if ( Objects . isNull ( filter ) ) { return false ; MST[BooleanTrueReturnValsMutator]MSP[S] } final boolean result = decorated () . removeIf ( filter ) ; if ( result ) {
public boolean removeIf ( final Predicate < ? super E > filter ) { if ( Objects . isNull ( filter ) ) { return false ; } final boolean result = decorated () . removeIf ( filter ) ; if ( result ) { MST[rv.ROR1Mutator]MSP[N]
public boolean removeIf ( final Predicate < ? super E > filter ) { if ( Objects . isNull ( filter ) ) { return false ; } final boolean result = decorated () . removeIf ( filter ) ; if ( result ) { MST[rv.ROR5Mutator]MSP[S]
} @Override public boolean retainAll ( final Collection < ? > coll ) { final boolean result = decorated () . retainAll ( coll ) ; if ( result == false ) { return false ; } if ( decorated () . isEmpty () ) { MST[NonVoidMethodCallMutator]MSP[N]
setOrder . clear () ; MST[VoidMethodCallMutator]MSP[S] } else { setOrder . removeIf ( e -> ! decorated () . contains ( e ) ) ; } return result ; } @Override public Object [] toArray () { return setOrder . toArray () ; } @Override
public boolean removeIf ( final Predicate < ? super E > filter ) { if ( Objects . isNull ( filter ) ) { return false ; } final boolean result = decorated () . removeIf ( filter ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( result ) {
return setOrder . indexOf ( object ) ; } public void add ( final int index , final E object ) { if ( ! contains ( object ) ) { decorated () . add ( object ) ; setOrder . add ( index , object ) ; MST[rv.UOI1Mutator]MSP[N] } }
return setOrder . indexOf ( object ) ; } public void add ( final int index , final E object ) { if ( ! contains ( object ) ) { decorated () . add ( object ) ; setOrder . add ( index , object ) ; MST[rv.UOI3Mutator]MSP[N] } }
} @Override public boolean retainAll ( final Collection < ? > coll ) { final boolean result = decorated () . retainAll ( coll ) ; if ( result == false ) { MST[rv.ROR1Mutator]MSP[N] return false ; } if ( decorated () . isEmpty () ) {
public E remove ( final int index ) { final E obj = setOrder . remove ( index ) ; remove ( obj ) ; return obj ; } @Override public String toString () { return setOrder . toString () ; MST[NonVoidMethodCallMutator]MSP[S] } @Override public E next () {
} @Override public boolean retainAll ( final Collection < ? > coll ) { final boolean result = decorated () . retainAll ( coll ) ; if ( result == false ) { MST[rv.ROR3Mutator]MSP[N] return false ; } if ( decorated () . isEmpty () ) {
public boolean remove ( final Object object ) { final boolean result = decorated () . remove ( object ) ; if ( result ) { setOrder . remove ( object ) ; } return result ; MST[rv.UOI4Mutator]MSP[N] } @Override
public boolean remove ( final Object object ) { final boolean result = decorated () . remove ( object ) ; if ( result ) { setOrder . remove ( object ) ; } return result ; MST[rv.UOI2Mutator]MSP[N] } @Override
} @Override public boolean retainAll ( final Collection < ? > coll ) { final boolean result = decorated () . retainAll ( coll ) ; if ( result == false ) { MST[rv.ROR5Mutator]MSP[N] return false ; } if ( decorated () . isEmpty () ) {
setOrder . clear () ; } else { setOrder . removeIf ( e -> ! decorated () . contains ( e ) ) ; MST[rv.ROR1Mutator]MSP[N] } return result ; } @Override public Object [] toArray () { return setOrder . toArray () ; } @Override
} @Override public boolean retainAll ( final Collection < ? > coll ) { final boolean result = decorated () . retainAll ( coll ) ; if ( result == false ) { return false ; MST[rv.CRCR5Mutator]MSP[N] } if ( decorated () . isEmpty () ) {
} @Override public boolean retainAll ( final Collection < ? > coll ) { final boolean result = decorated () . retainAll ( coll ) ; if ( result == false ) { return false ; MST[rv.CRCR1Mutator]MSP[N] } if ( decorated () . isEmpty () ) {
setOrder . removeIf ( filter ) ; } return result ; } @Override public boolean removeAll ( final Collection < ? > coll ) { boolean result = false ; for ( final Object name : coll ) { result |= remove ( name ) ; MST[rv.UOI3Mutator]MSP[S] } return result ;
} @Override public boolean retainAll ( final Collection < ? > coll ) { final boolean result = decorated () . retainAll ( coll ) ; if ( result == false ) { return false ; MST[rv.CRCR3Mutator]MSP[N] } if ( decorated () . isEmpty () ) {
if ( set . size () > 0 || list . size () > 0 ) { throw new IllegalArgumentException ( lr_3 ) ; } return new ListOrderedSet <> ( set , list ) ; MST[NullReturnValsMutator]MSP[S] }
public boolean removeIf ( final Predicate < ? super E > filter ) { if ( Objects . isNull ( filter ) ) { return false ; } final boolean result = decorated () . removeIf ( filter ) ; if ( result ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
} @Override public boolean retainAll ( final Collection < ? > coll ) { final boolean result = decorated () . retainAll ( coll ) ; if ( result == false ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return false ; } if ( decorated () . isEmpty () ) {
setOrder . removeIf ( filter ) ; } return result ; } @Override public boolean removeAll ( final Collection < ? > coll ) { boolean result = false ; for ( final Object name : coll ) { result |= remove ( name ) ; MST[rv.UOI1Mutator]MSP[N] } return result ;
setOrder . removeIf ( filter ) ; } return result ; } @Override public boolean removeAll ( final Collection < ? > coll ) { boolean result = false ; for ( final Object name : coll ) { result |= remove ( name ) ; } return result ; MST[rv.ABSMutator]MSP[N]
public boolean removeIf ( final Predicate < ? super E > filter ) { if ( Objects . isNull ( filter ) ) { return false ; MST[ReturnValsMutator]MSP[S] } final boolean result = decorated () . removeIf ( filter ) ; if ( result ) {
public static < E > ListOrderedSet < E > listOrderedSet ( final Set < E > set ) { return new ListOrderedSet <> ( set ) ; MST[ConstructorCallMutator]MSP[N] } public static < E > ListOrderedSet < E > listOrderedSet ( final List < E > list ) {
return setOrder . indexOf ( object ) ; } public void add ( final int index , final E object ) { if ( ! contains ( object ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] decorated () . add ( object ) ; setOrder . add ( index , object ) ; } }
return new OrderedSetIterator <> ( setOrder . listIterator () , decorated () ) ; } @Override public boolean add ( final E object ) { if ( decorated () . add ( object ) ) { setOrder . add ( object ) ; return true ; } return false ; MST[rv.CRCR5Mutator]MSP[N]
public boolean removeIf ( final Predicate < ? super E > filter ) { if ( Objects . isNull ( filter ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return false ; } final boolean result = decorated () . removeIf ( filter ) ; if ( result ) {
return setOrder . indexOf ( object ) ; } public void add ( final int index , final E object ) { if ( ! contains ( object ) ) { MST[NegateConditionalsMutator]MSP[N] decorated () . add ( object ) ; setOrder . add ( index , object ) ; } }
return new OrderedSetIterator <> ( setOrder . listIterator () , decorated () ) ; } @Override public boolean add ( final E object ) { if ( decorated () . add ( object ) ) { setOrder . add ( object ) ; return true ; } return false ; MST[BooleanTrueReturnValsMutator]MSP[N]
if ( contains ( e ) ) { continue; } decorated () . add ( e ) ; toAdd . add ( e ) ; changed = true ; MST[rv.CRCR5Mutator]MSP[S] } if ( changed ) { setOrder . addAll ( index , toAdd ) ; } return changed ; }
if ( set . size () > 0 || list . size () > 0 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[S] throw new IllegalArgumentException ( lr_3 ) ; } return new ListOrderedSet <> ( set , list ) ; }
return new OrderedSetIterator <> ( setOrder . listIterator () , decorated () ) ; MST[NonVoidMethodCallMutator]MSP[S] } @Override public boolean add ( final E object ) { if ( decorated () . add ( object ) ) { setOrder . add ( object ) ; return true ; } return false ;
public boolean removeIf ( final Predicate < ? super E > filter ) { if ( Objects . isNull ( filter ) ) { return false ; } final boolean result = decorated () . removeIf ( filter ) ; if ( result ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S]
if ( contains ( e ) ) { continue; } decorated () . add ( e ) ; toAdd . add ( e ) ; changed = true ; } if ( changed ) { MST[rv.ROR2Mutator]MSP[N] setOrder . addAll ( index , toAdd ) ; } return changed ; }
public List < E > asList () { return UnmodifiableList . unmodifiableList ( setOrder ) ; } @Override public void clear () { decorated () . clear () ; MST[VoidMethodCallMutator]MSP[N] setOrder . clear () ; } @Override public OrderedIterator < E > iterator () {
setOrder . clear () ; } else { setOrder . removeIf ( e -> ! decorated () . contains ( e ) ) ; MST[rv.ROR5Mutator]MSP[N] } return result ; } @Override public Object [] toArray () { return setOrder . toArray () ; } @Override
setOrder . clear () ; } else { setOrder . removeIf ( e -> ! decorated () . contains ( e ) ) ; } return result ; MST[rv.UOI3Mutator]MSP[N] } @Override public Object [] toArray () { return setOrder . toArray () ; } @Override
return new OrderedSetIterator <> ( setOrder . listIterator () , decorated () ) ; MST[ReturnValsMutator]MSP[N] } @Override public boolean add ( final E object ) { if ( decorated () . add ( object ) ) { setOrder . add ( object ) ; return true ; } return false ;
} @Override public boolean addAll ( final Collection < ? extends E > coll ) { boolean result = false ; MST[rv.CRCR3Mutator]MSP[N] for ( final E e : coll ) { result |= add ( e ) ; } return result ; } @Override
return new OrderedSetIterator <> ( setOrder . listIterator () , decorated () ) ; } @Override public boolean add ( final E object ) { if ( decorated () . add ( object ) ) { setOrder . add ( object ) ; return true ; } return false ; MST[rv.CRCR1Mutator]MSP[N]
if ( contains ( e ) ) { continue; } decorated () . add ( e ) ; toAdd . add ( e ) ; changed = true ; } if ( changed ) { setOrder . addAll ( index , toAdd ) ; } return changed ; MST[rv.UOI4Mutator]MSP[N] }
if ( contains ( e ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] continue; } decorated () . add ( e ) ; toAdd . add ( e ) ; changed = true ; } if ( changed ) { setOrder . addAll ( index , toAdd ) ; } return changed ; }
} @Override public boolean addAll ( final Collection < ? extends E > coll ) { boolean result = false ; for ( final E e : coll ) { result |= add ( e ) ; } return result ; MST[rv.UOI2Mutator]MSP[N] } @Override
} @Override public boolean retainAll ( final Collection < ? > coll ) { final boolean result = decorated () . retainAll ( coll ) ; if ( result == false ) { return false ; MST[BooleanTrueReturnValsMutator]MSP[N] } if ( decorated () . isEmpty () ) {
setOrder . clear () ; } else { setOrder . removeIf ( e -> ! decorated () . contains ( e ) ) ; } return result ; } @Override public Object [] toArray () { return setOrder . toArray () ; MST[ReturnValsMutator]MSP[N] } @Override
if ( contains ( e ) ) { continue; } decorated () . add ( e ) ; toAdd . add ( e ) ; changed = true ; } if ( changed ) { setOrder . addAll ( index , toAdd ) ; MST[NonVoidMethodCallMutator]MSP[N] } return changed ; }
setOrder . clear () ; } else { setOrder . removeIf ( e -> ! decorated () . contains ( e ) ) ; MST[rv.CRCR6Mutator]MSP[N] } return result ; } @Override public Object [] toArray () { return setOrder . toArray () ; } @Override
public boolean removeIf ( final Predicate < ? super E > filter ) { if ( Objects . isNull ( filter ) ) { return false ; } final boolean result = decorated () . removeIf ( filter ) ; if ( result ) { MST[rv.UOI2Mutator]MSP[N]
} @Override public boolean addAll ( final Collection < ? extends E > coll ) { boolean result = false ; for ( final E e : coll ) { result |= add ( e ) ; MST[rv.UOI1Mutator]MSP[N] } return result ; } @Override
public boolean removeIf ( final Predicate < ? super E > filter ) { if ( Objects . isNull ( filter ) ) { MST[rv.ROR3Mutator]MSP[N] return false ; } final boolean result = decorated () . removeIf ( filter ) ; if ( result ) {
setOrder . removeIf ( filter ) ; } return result ; MST[rv.UOI3Mutator]MSP[N] } @Override public boolean removeAll ( final Collection < ? > coll ) { boolean result = false ; for ( final Object name : coll ) { result |= remove ( name ) ; } return result ;
return new OrderedSetIterator <> ( setOrder . listIterator () , decorated () ) ; } @Override public boolean add ( final E object ) { if ( decorated () . add ( object ) ) { MST[rv.ROR2Mutator]MSP[N] setOrder . add ( object ) ; return true ; } return false ;
if ( contains ( e ) ) { continue; } decorated () . add ( e ) ; toAdd . add ( e ) ; changed = true ; } if ( changed ) { setOrder . addAll ( index , toAdd ) ; } return changed ; MST[BooleanFalseReturnValsMutator]MSP[S] }
} @Override public boolean addAll ( final Collection < ? extends E > coll ) { boolean result = false ; for ( final E e : coll ) { result |= add ( e ) ; MST[MathMutator]MSP[N] } return result ; } @Override
setOrder . removeIf ( filter ) ; } return result ; } @Override public boolean removeAll ( final Collection < ? > coll ) { boolean result = false ; for ( final Object name : coll ) { result |= remove ( name ) ; MST[rv.OBBN2Mutator]MSP[S] } return result ;
} @Override public boolean retainAll ( final Collection < ? > coll ) { final boolean result = decorated () . retainAll ( coll ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( result == false ) { return false ; } if ( decorated () . isEmpty () ) {
if ( set . size () > 0 || list . size () > 0 ) { MST[rv.ROR2Mutator]MSP[S] throw new IllegalArgumentException ( lr_3 ) ; } return new ListOrderedSet <> ( set , list ) ; }
return setOrder . indexOf ( object ) ; } public void add ( final int index , final E object ) { if ( ! contains ( object ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] decorated () . add ( object ) ; setOrder . add ( index , object ) ; } }
public boolean addAll ( final int index , final Collection < ? extends E > coll ) { boolean changed = false ; final List < E > toAdd = new ArrayList <> () ; MST[ConstructorCallMutator]MSP[N] for ( final E e : coll ) {
public boolean remove ( final Object object ) { final boolean result = decorated () . remove ( object ) ; if ( result ) { setOrder . remove ( object ) ; } return result ; MST[rv.ABSMutator]MSP[N] } @Override
public boolean removeIf ( final Predicate < ? super E > filter ) { if ( Objects . isNull ( filter ) ) { return false ; MST[rv.CRCR3Mutator]MSP[S] } final boolean result = decorated () . removeIf ( filter ) ; if ( result ) {
if ( set . size () > 0 || list . size () > 0 ) { MST[rv.ROR3Mutator]MSP[S] throw new IllegalArgumentException ( lr_3 ) ; } return new ListOrderedSet <> ( set , list ) ; }
} @Override public boolean retainAll ( final Collection < ? > coll ) { final boolean result = decorated () . retainAll ( coll ) ; if ( result == false ) { MST[rv.ABSMutator]MSP[N] return false ; } if ( decorated () . isEmpty () ) {
public E remove ( final int index ) { final E obj = setOrder . remove ( index ) ; MST[rv.UOI3Mutator]MSP[N] remove ( obj ) ; return obj ; } @Override public String toString () { return setOrder . toString () ; } @Override public E next () {
public boolean remove ( final Object object ) { final boolean result = decorated () . remove ( object ) ; if ( result ) { MST[rv.UOI1Mutator]MSP[N] setOrder . remove ( object ) ; } return result ; } @Override
public boolean remove ( final Object object ) { final boolean result = decorated () . remove ( object ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( result ) { setOrder . remove ( object ) ; } return result ; } @Override
public boolean remove ( final Object object ) { final boolean result = decorated () . remove ( object ) ; if ( result ) { MST[rv.ROR2Mutator]MSP[N] setOrder . remove ( object ) ; } return result ; } @Override
public boolean removeIf ( final Predicate < ? super E > filter ) { if ( Objects . isNull ( filter ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] return false ; } final boolean result = decorated () . removeIf ( filter ) ; if ( result ) {
if ( contains ( e ) ) { continue; } decorated () . add ( e ) ; toAdd . add ( e ) ; changed = true ; } if ( changed ) { MST[rv.UOI1Mutator]MSP[N] setOrder . addAll ( index , toAdd ) ; } return changed ; }
return setOrder . indexOf ( object ) ; } public void add ( final int index , final E object ) { if ( ! contains ( object ) ) { decorated () . add ( object ) ; setOrder . add ( index , object ) ; MST[VoidMethodCallMutator]MSP[N] } }
return new OrderedSetIterator <> ( setOrder . listIterator () , decorated () ) ; MST[NullReturnValsMutator]MSP[N] } @Override public boolean add ( final E object ) { if ( decorated () . add ( object ) ) { setOrder . add ( object ) ; return true ; } return false ;
setOrder . clear () ; } else { setOrder . removeIf ( e -> ! decorated () . contains ( e ) ) ; } return result ; MST[BooleanFalseReturnValsMutator]MSP[N] } @Override public Object [] toArray () { return setOrder . toArray () ; } @Override
setOrder . clear () ; } else { setOrder . removeIf ( e -> ! decorated () . contains ( e ) ) ; MST[NegateConditionalsMutator]MSP[N] } return result ; } @Override public Object [] toArray () { return setOrder . toArray () ; } @Override
if ( contains ( e ) ) { continue; } decorated () . add ( e ) ; toAdd . add ( e ) ; changed = true ; } if ( changed ) { MST[rv.UOI3Mutator]MSP[N] setOrder . addAll ( index , toAdd ) ; } return changed ; }
if ( set . size () > 0 || list . size () > 0 ) { MST[NegateConditionalsMutator]MSP[S] throw new IllegalArgumentException ( lr_3 ) ; } return new ListOrderedSet <> ( set , list ) ; }
if ( set . size () > 0 || list . size () > 0 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] throw new IllegalArgumentException ( lr_3 ) ; } return new ListOrderedSet <> ( set , list ) ; }
public < T > T [] toArray ( final T a [] ) { return setOrder . toArray ( a ) ; MST[ArgumentPropagationMutator]MSP[S] } public E get ( final int index ) { return setOrder . get ( index ) ; } public int indexOf ( final Object object ) {
} @Override public boolean retainAll ( final Collection < ? > coll ) { final boolean result = decorated () . retainAll ( coll ) ; if ( result == false ) { return false ; MST[InlineConstantMutator]MSP[N] } if ( decorated () . isEmpty () ) {
} @Override public boolean addAll ( final Collection < ? extends E > coll ) { boolean result = false ; for ( final E e : coll ) { result |= add ( e ) ; MST[rv.OBBN3Mutator]MSP[N] } return result ; } @Override
return setOrder . indexOf ( object ) ; MST[NonVoidMethodCallMutator]MSP[N] } public void add ( final int index , final E object ) { if ( ! contains ( object ) ) { decorated () . add ( object ) ; setOrder . add ( index , object ) ; } }
Objects . requireNonNull ( list , lr_2 ) ; CollectionUtils . filter ( list , UniquePredicate . uniquePredicate () ) ; final Set < E > set = new HashSet <> ( list ) ; return new ListOrderedSet <> ( set , list ) ; MST[NullReturnValsMutator]MSP[N] }
return setOrder . indexOf ( object ) ; } public void add ( final int index , final E object ) { if ( ! contains ( object ) ) { MST[NonVoidMethodCallMutator]MSP[N] decorated () . add ( object ) ; setOrder . add ( index , object ) ; } }
Objects . requireNonNull ( list , lr_2 ) ; CollectionUtils . filter ( list , UniquePredicate . uniquePredicate () ) ; MST[NonVoidMethodCallMutator]MSP[S] final Set < E > set = new HashSet <> ( list ) ; return new ListOrderedSet <> ( set , list ) ; }
public boolean removeIf ( final Predicate < ? super E > filter ) { if ( Objects . isNull ( filter ) ) { MST[NonVoidMethodCallMutator]MSP[S] return false ; } final boolean result = decorated () . removeIf ( filter ) ; if ( result ) {
} @Override public boolean retainAll ( final Collection < ? > coll ) { final boolean result = decorated () . retainAll ( coll ) ; if ( result == false ) { return false ; } if ( decorated () . isEmpty () ) { MST[rv.ROR4Mutator]MSP[N]
return new OrderedSetIterator <> ( setOrder . listIterator () , decorated () ) ; } @Override public boolean add ( final E object ) { if ( decorated () . add ( object ) ) { MST[rv.ROR1Mutator]MSP[N] setOrder . add ( object ) ; return true ; } return false ;
public static < E > ListOrderedSet < E > listOrderedSet ( final Set < E > set , final List < E > list ) { Objects . requireNonNull ( set , lr_1 ) ; MST[ArgumentPropagationMutator]MSP[N] Objects . requireNonNull ( list , lr_2 ) ;
setOrder . removeIf ( filter ) ; } return result ; } @Override public boolean removeAll ( final Collection < ? > coll ) { boolean result = false ; for ( final Object name : coll ) { result |= remove ( name ) ; MST[rv.OBBN3Mutator]MSP[N] } return result ;
public static < E > ListOrderedSet < E > listOrderedSet ( final Set < E > set , final List < E > list ) { Objects . requireNonNull ( set , lr_1 ) ; Objects . requireNonNull ( list , lr_2 ) ; MST[NonVoidMethodCallMutator]MSP[N]
if ( contains ( e ) ) { MST[rv.ROR1Mutator]MSP[N] continue; } decorated () . add ( e ) ; toAdd . add ( e ) ; changed = true ; } if ( changed ) { setOrder . addAll ( index , toAdd ) ; } return changed ; }
if ( set . size () > 0 || list . size () > 0 ) { MST[NonVoidMethodCallMutator]MSP[S] throw new IllegalArgumentException ( lr_3 ) ; } return new ListOrderedSet <> ( set , list ) ; }
if ( contains ( e ) ) { continue; } decorated () . add ( e ) ; MST[NonVoidMethodCallMutator]MSP[N] toAdd . add ( e ) ; changed = true ; } if ( changed ) { setOrder . addAll ( index , toAdd ) ; } return changed ; }
public < T > T [] toArray ( final T a [] ) { return setOrder . toArray ( a ) ; } public E get ( final int index ) { return setOrder . get ( index ) ; MST[rv.UOI3Mutator]MSP[N] } public int indexOf ( final Object object ) {
public E remove ( final int index ) { final E obj = setOrder . remove ( index ) ; MST[rv.UOI4Mutator]MSP[N] remove ( obj ) ; return obj ; } @Override public String toString () { return setOrder . toString () ; } @Override public E next () {
} @Override public boolean retainAll ( final Collection < ? > coll ) { final boolean result = decorated () . retainAll ( coll ) ; if ( result == false ) { return false ; } if ( decorated () . isEmpty () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
setOrder . clear () ; } else { setOrder . removeIf ( e -> ! decorated () . contains ( e ) ) ; MST[rv.CRCR3Mutator]MSP[N] } return result ; } @Override public Object [] toArray () { return setOrder . toArray () ; } @Override
setOrder . clear () ; } else { setOrder . removeIf ( e -> ! decorated () . contains ( e ) ) ; MST[rv.CRCR5Mutator]MSP[N] } return result ; } @Override public Object [] toArray () { return setOrder . toArray () ; } @Override
public boolean addAll ( final int index , final Collection < ? extends E > coll ) { boolean changed = false ; MST[rv.CRCR3Mutator]MSP[S] final List < E > toAdd = new ArrayList <> () ; for ( final E e : coll ) {
public boolean addAll ( final int index , final Collection < ? extends E > coll ) { boolean changed = false ; MST[rv.CRCR5Mutator]MSP[S] final List < E > toAdd = new ArrayList <> () ; for ( final E e : coll ) {
public E remove ( final int index ) { final E obj = setOrder . remove ( index ) ; remove ( obj ) ; return obj ; MST[ReturnValsMutator]MSP[S] } @Override public String toString () { return setOrder . toString () ; } @Override public E next () {
public static < E > ListOrderedSet < E > listOrderedSet ( final Set < E > set ) { return new ListOrderedSet <> ( set ) ; MST[NullReturnValsMutator]MSP[N] } public static < E > ListOrderedSet < E > listOrderedSet ( final List < E > list ) {
if ( contains ( e ) ) { continue; } decorated () . add ( e ) ; MST[NonVoidMethodCallMutator]MSP[S] toAdd . add ( e ) ; changed = true ; } if ( changed ) { setOrder . addAll ( index , toAdd ) ; } return changed ; }
setOrder . removeIf ( filter ) ; MST[NonVoidMethodCallMutator]MSP[S] } return result ; } @Override public boolean removeAll ( final Collection < ? > coll ) { boolean result = false ; for ( final Object name : coll ) { result |= remove ( name ) ; } return result ;
return new OrderedSetIterator <> ( setOrder . listIterator () , decorated () ) ; } @Override public boolean add ( final E object ) { if ( decorated () . add ( object ) ) { setOrder . add ( object ) ; return true ; } return false ; MST[ReturnValsMutator]MSP[N]
if ( contains ( e ) ) { continue; } decorated () . add ( e ) ; toAdd . add ( e ) ; changed = true ; } if ( changed ) { MST[rv.ROR3Mutator]MSP[N] setOrder . addAll ( index , toAdd ) ; } return changed ; }
if ( contains ( e ) ) { continue; } decorated () . add ( e ) ; toAdd . add ( e ) ; changed = true ; MST[rv.CRCR2Mutator]MSP[N] } if ( changed ) { setOrder . addAll ( index , toAdd ) ; } return changed ; }
setOrder . removeIf ( filter ) ; } return result ; MST[rv.UOI1Mutator]MSP[N] } @Override public boolean removeAll ( final Collection < ? > coll ) { boolean result = false ; for ( final Object name : coll ) { result |= remove ( name ) ; } return result ;
if ( set . size () > 0 || list . size () > 0 ) { throw new IllegalArgumentException ( lr_3 ) ; MST[ConstructorCallMutator]MSP[S] } return new ListOrderedSet <> ( set , list ) ; }
} @Override public boolean addAll ( final Collection < ? extends E > coll ) { boolean result = false ; MST[rv.CRCR1Mutator]MSP[N] for ( final E e : coll ) { result |= add ( e ) ; } return result ; } @Override
} @Override public boolean addAll ( final Collection < ? extends E > coll ) { boolean result = false ; for ( final E e : coll ) { result |= add ( e ) ; } return result ; MST[rv.UOI4Mutator]MSP[N] } @Override
setOrder . clear () ; } else { setOrder . removeIf ( e -> ! decorated () . contains ( e ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } return result ; } @Override public Object [] toArray () { return setOrder . toArray () ; } @Override
return new OrderedSetIterator <> ( setOrder . listIterator () , decorated () ) ; } @Override public boolean add ( final E object ) { if ( decorated () . add ( object ) ) { MST[NegateConditionalsMutator]MSP[N] setOrder . add ( object ) ; return true ; } return false ;
return new OrderedSetIterator <> ( setOrder . listIterator () , decorated () ) ; } @Override public boolean add ( final E object ) { if ( decorated () . add ( object ) ) { setOrder . add ( object ) ; return true ; } return false ; MST[InlineConstantMutator]MSP[N]
if ( contains ( e ) ) { continue; } decorated () . add ( e ) ; toAdd . add ( e ) ; changed = true ; } if ( changed ) { setOrder . addAll ( index , toAdd ) ; } return changed ; MST[rv.UOI2Mutator]MSP[N] }
return new OrderedSetIterator <> ( setOrder . listIterator () , decorated () ) ; } @Override public boolean add ( final E object ) { if ( decorated () . add ( object ) ) { setOrder . add ( object ) ; return true ; } return false ; MST[rv.CRCR3Mutator]MSP[N]
Objects . requireNonNull ( list , lr_2 ) ; CollectionUtils . filter ( list , UniquePredicate . uniquePredicate () ) ; final Set < E > set = new HashSet <> ( list ) ; return new ListOrderedSet <> ( set , list ) ; MST[ReturnValsMutator]MSP[N] }
public boolean remove ( final Object object ) { final boolean result = decorated () . remove ( object ) ; if ( result ) { MST[rv.ROR4Mutator]MSP[S] setOrder . remove ( object ) ; } return result ; } @Override
setOrder . clear () ; } else { setOrder . removeIf ( e -> ! decorated () . contains ( e ) ) ; MST[rv.CRCR4Mutator]MSP[N] } return result ; } @Override public Object [] toArray () { return setOrder . toArray () ; } @Override
return new OrderedSetIterator <> ( setOrder . listIterator () , decorated () ) ; } @Override public boolean add ( final E object ) { if ( decorated () . add ( object ) ) { MST[rv.ROR4Mutator]MSP[N] setOrder . add ( object ) ; return true ; } return false ;
} @Override public boolean addAll ( final Collection < ? extends E > coll ) { boolean result = false ; for ( final E e : coll ) { result |= add ( e ) ; MST[rv.UOI3Mutator]MSP[S] } return result ; } @Override
if ( contains ( e ) ) { MST[NegateConditionalsMutator]MSP[N] continue; } decorated () . add ( e ) ; toAdd . add ( e ) ; changed = true ; } if ( changed ) { setOrder . addAll ( index , toAdd ) ; } return changed ; }
public boolean remove ( final Object object ) { final boolean result = decorated () . remove ( object ) ; if ( result ) { setOrder . remove ( object ) ; } return result ; MST[rv.UOI3Mutator]MSP[N] } @Override
public boolean removeIf ( final Predicate < ? super E > filter ) { if ( Objects . isNull ( filter ) ) { return false ; MST[rv.CRCR5Mutator]MSP[S] } final boolean result = decorated () . removeIf ( filter ) ; if ( result ) {
public boolean remove ( final Object object ) { final boolean result = decorated () . remove ( object ) ; if ( result ) { MST[NegateConditionalsMutator]MSP[S] setOrder . remove ( object ) ; } return result ; } @Override
} @Override public boolean retainAll ( final Collection < ? > coll ) { final boolean result = decorated () . retainAll ( coll ) ; if ( result == false ) { return false ; } if ( decorated () . isEmpty () ) { MST[rv.ROR1Mutator]MSP[N]
if ( contains ( e ) ) { MST[rv.ROR4Mutator]MSP[N] continue; } decorated () . add ( e ) ; toAdd . add ( e ) ; changed = true ; } if ( changed ) { setOrder . addAll ( index , toAdd ) ; } return changed ; }
if ( set . size () > 0 || list . size () > 0 ) { throw new IllegalArgumentException ( lr_3 ) ; } return new ListOrderedSet <> ( set , list ) ; MST[ConstructorCallMutator]MSP[S] }
setOrder . clear () ; } else { setOrder . removeIf ( e -> ! decorated () . contains ( e ) ) ; MST[rv.ROR2Mutator]MSP[N] } return result ; } @Override public Object [] toArray () { return setOrder . toArray () ; } @Override
public boolean removeIf ( final Predicate < ? super E > filter ) { if ( Objects . isNull ( filter ) ) { MST[rv.ROR5Mutator]MSP[N] return false ; } final boolean result = decorated () . removeIf ( filter ) ; if ( result ) {
public List < E > asList () { return UnmodifiableList . unmodifiableList ( setOrder ) ; MST[NonVoidMethodCallMutator]MSP[N] } @Override public void clear () { decorated () . clear () ; setOrder . clear () ; } @Override public OrderedIterator < E > iterator () {
if ( set . size () > 0 || list . size () > 0 ) { MST[rv.ROR4Mutator]MSP[S] throw new IllegalArgumentException ( lr_3 ) ; } return new ListOrderedSet <> ( set , list ) ; }
return new OrderedSetIterator <> ( setOrder . listIterator () , decorated () ) ; } @Override public boolean add ( final E object ) { if ( decorated () . add ( object ) ) { setOrder . add ( object ) ; return true ; MST[BooleanFalseReturnValsMutator]MSP[N] } return false ;
} @Override public boolean retainAll ( final Collection < ? > coll ) { final boolean result = decorated () . retainAll ( coll ) ; if ( result == false ) { MST[rv.UOI3Mutator]MSP[N] return false ; } if ( decorated () . isEmpty () ) {
if ( set . size () > 0 || list . size () > 0 ) { MST[rv.ROR5Mutator]MSP[N] throw new IllegalArgumentException ( lr_3 ) ; } return new ListOrderedSet <> ( set , list ) ; }
public E remove ( final int index ) { final E obj = setOrder . remove ( index ) ; remove ( obj ) ; return obj ; MST[NullReturnValsMutator]MSP[N] } @Override public String toString () { return setOrder . toString () ; } @Override public E next () {
public E remove ( final int index ) { final E obj = setOrder . remove ( index ) ; MST[rv.UOI1Mutator]MSP[N] remove ( obj ) ; return obj ; } @Override public String toString () { return setOrder . toString () ; } @Override public E next () {
public boolean remove ( final Object object ) { final boolean result = decorated () . remove ( object ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( result ) { setOrder . remove ( object ) ; } return result ; } @Override
} @Override public boolean retainAll ( final Collection < ? > coll ) { final boolean result = decorated () . retainAll ( coll ) ; if ( result == false ) { return false ; MST[ReturnValsMutator]MSP[N] } if ( decorated () . isEmpty () ) {
if ( contains ( e ) ) { continue; } decorated () . add ( e ) ; toAdd . add ( e ) ; changed = true ; } if ( changed ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] setOrder . addAll ( index , toAdd ) ; } return changed ; }
public E remove ( final int index ) { final E obj = setOrder . remove ( index ) ; MST[rv.ABSMutator]MSP[S] remove ( obj ) ; return obj ; } @Override public String toString () { return setOrder . toString () ; } @Override public E next () {
if ( contains ( e ) ) { continue; } decorated () . add ( e ) ; toAdd . add ( e ) ; changed = true ; } if ( changed ) { setOrder . addAll ( index , toAdd ) ; MST[rv.UOI3Mutator]MSP[N] } return changed ; }
return new OrderedSetIterator <> ( setOrder . listIterator () , decorated () ) ; } @Override public boolean add ( final E object ) { if ( decorated () . add ( object ) ) { setOrder . add ( object ) ; return true ; MST[rv.CRCR3Mutator]MSP[N] } return false ;
return setOrder . indexOf ( object ) ; MST[ReturnValsMutator]MSP[N] } public void add ( final int index , final E object ) { if ( ! contains ( object ) ) { decorated () . add ( object ) ; setOrder . add ( index , object ) ; } }
public boolean addAll ( final int index , final Collection < ? extends E > coll ) { boolean changed = false ; MST[InlineConstantMutator]MSP[S] final List < E > toAdd = new ArrayList <> () ; for ( final E e : coll ) {
if ( set . size () > 0 || list . size () > 0 ) { MST[ConditionalsBoundaryMutator]MSP[S] throw new IllegalArgumentException ( lr_3 ) ; } return new ListOrderedSet <> ( set , list ) ; }
public boolean remove ( final Object object ) { final boolean result = decorated () . remove ( object ) ; if ( result ) { setOrder . remove ( object ) ; } return result ; MST[ReturnValsMutator]MSP[N] } @Override
return new OrderedSetIterator <> ( setOrder . listIterator () , decorated () ) ; } @Override public boolean add ( final E object ) { if ( decorated () . add ( object ) ) { setOrder . add ( object ) ; return true ; MST[ReturnValsMutator]MSP[N] } return false ;
public boolean remove ( final Object object ) { final boolean result = decorated () . remove ( object ) ; if ( result ) { setOrder . remove ( object ) ; } return result ; MST[BooleanTrueReturnValsMutator]MSP[N] } @Override
setOrder . removeIf ( filter ) ; } return result ; } @Override public boolean removeAll ( final Collection < ? > coll ) { boolean result = false ; for ( final Object name : coll ) { result |= remove ( name ) ; } return result ; MST[rv.UOI1Mutator]MSP[N]
if ( contains ( e ) ) { continue; } decorated () . add ( e ) ; toAdd . add ( e ) ; changed = true ; } if ( changed ) { MST[NegateConditionalsMutator]MSP[N] setOrder . addAll ( index , toAdd ) ; } return changed ; }
setOrder . removeIf ( filter ) ; } return result ; MST[BooleanFalseReturnValsMutator]MSP[N] } @Override public boolean removeAll ( final Collection < ? > coll ) { boolean result = false ; for ( final Object name : coll ) { result |= remove ( name ) ; } return result ;
setOrder . removeIf ( filter ) ; } return result ; } @Override public boolean removeAll ( final Collection < ? > coll ) { boolean result = false ; for ( final Object name : coll ) { result |= remove ( name ) ; } return result ; MST[rv.UOI3Mutator]MSP[N]
} @Override public boolean addAll ( final Collection < ? extends E > coll ) { boolean result = false ; for ( final E e : coll ) { result |= add ( e ) ; } return result ; MST[BooleanTrueReturnValsMutator]MSP[N] } @Override
if ( contains ( e ) ) { continue; } decorated () . add ( e ) ; toAdd . add ( e ) ; changed = true ; } if ( changed ) { setOrder . addAll ( index , toAdd ) ; MST[rv.UOI1Mutator]MSP[N] } return changed ; }
setOrder . removeIf ( filter ) ; } return result ; } @Override public boolean removeAll ( final Collection < ? > coll ) { boolean result = false ; MST[rv.CRCR6Mutator]MSP[S] for ( final Object name : coll ) { result |= remove ( name ) ; } return result ;
} @Override public boolean addAll ( final Collection < ? extends E > coll ) { boolean result = false ; for ( final E e : coll ) { result |= add ( e ) ; } return result ; MST[ReturnValsMutator]MSP[N] } @Override
if ( set . size () > 0 || list . size () > 0 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[S] throw new IllegalArgumentException ( lr_3 ) ; } return new ListOrderedSet <> ( set , list ) ; }
return setOrder . indexOf ( object ) ; } public void add ( final int index , final E object ) { if ( ! contains ( object ) ) { MST[rv.ROR4Mutator]MSP[N] decorated () . add ( object ) ; setOrder . add ( index , object ) ; } }
return setOrder . indexOf ( object ) ; } public void add ( final int index , final E object ) { if ( ! contains ( object ) ) { MST[rv.ROR2Mutator]MSP[N] decorated () . add ( object ) ; setOrder . add ( index , object ) ; } }
setOrder . removeIf ( filter ) ; } return result ; MST[rv.ABSMutator]MSP[N] } @Override public boolean removeAll ( final Collection < ? > coll ) { boolean result = false ; for ( final Object name : coll ) { result |= remove ( name ) ; } return result ;
return new OrderedSetIterator <> ( setOrder . listIterator () , decorated () ) ; } @Override public boolean add ( final E object ) { if ( decorated () . add ( object ) ) { setOrder . add ( object ) ; return true ; MST[rv.CRCR5Mutator]MSP[N] } return false ;
public boolean removeIf ( final Predicate < ? super E > filter ) { if ( Objects . isNull ( filter ) ) { return false ; } final boolean result = decorated () . removeIf ( filter ) ; if ( result ) { MST[rv.ROR4Mutator]MSP[S]
public boolean removeIf ( final Predicate < ? super E > filter ) { if ( Objects . isNull ( filter ) ) { return false ; } final boolean result = decorated () . removeIf ( filter ) ; if ( result ) { MST[rv.UOI3Mutator]MSP[N]
public boolean removeIf ( final Predicate < ? super E > filter ) { if ( Objects . isNull ( filter ) ) { return false ; } final boolean result = decorated () . removeIf ( filter ) ; if ( result ) { MST[rv.ROR2Mutator]MSP[N]
return setOrder . indexOf ( object ) ; } public void add ( final int index , final E object ) { if ( ! contains ( object ) ) { decorated () . add ( object ) ; setOrder . add ( index , object ) ; MST[rv.UOI4Mutator]MSP[N] } }
return setOrder . indexOf ( object ) ; } public void add ( final int index , final E object ) { if ( ! contains ( object ) ) { decorated () . add ( object ) ; setOrder . add ( index , object ) ; MST[rv.UOI2Mutator]MSP[N] } }
public boolean removeIf ( final Predicate < ? super E > filter ) { if ( Objects . isNull ( filter ) ) { return false ; } final boolean result = decorated () . removeIf ( filter ) ; if ( result ) { MST[rv.UOI1Mutator]MSP[N]
public List < E > asList () { return UnmodifiableList . unmodifiableList ( setOrder ) ; MST[ReturnValsMutator]MSP[N] } @Override public void clear () { decorated () . clear () ; setOrder . clear () ; } @Override public OrderedIterator < E > iterator () {
public boolean remove ( final Object object ) { final boolean result = decorated () . remove ( object ) ; if ( result ) { MST[rv.ROR3Mutator]MSP[S] setOrder . remove ( object ) ; } return result ; } @Override
public boolean remove ( final Object object ) { final boolean result = decorated () . remove ( object ) ; if ( result ) { MST[rv.ROR5Mutator]MSP[S] setOrder . remove ( object ) ; } return result ; } @Override
return setOrder . indexOf ( object ) ; } public void add ( final int index , final E object ) { if ( ! contains ( object ) ) { decorated () . add ( object ) ; MST[NonVoidMethodCallMutator]MSP[N] setOrder . add ( index , object ) ; } }
} @Override public boolean addAll ( final Collection < ? extends E > coll ) { boolean result = false ; for ( final E e : coll ) { result |= add ( e ) ; MST[rv.UOI2Mutator]MSP[N] } return result ; } @Override
} @Override public boolean addAll ( final Collection < ? extends E > coll ) { boolean result = false ; for ( final E e : coll ) { result |= add ( e ) ; MST[rv.UOI4Mutator]MSP[S] } return result ; } @Override
} @Override public boolean addAll ( final Collection < ? extends E > coll ) { boolean result = false ; MST[rv.CRCR6Mutator]MSP[N] for ( final E e : coll ) { result |= add ( e ) ; } return result ; } @Override
setOrder . removeIf ( filter ) ; } return result ; MST[rv.UOI4Mutator]MSP[N] } @Override public boolean removeAll ( final Collection < ? > coll ) { boolean result = false ; for ( final Object name : coll ) { result |= remove ( name ) ; } return result ;
setOrder . removeIf ( filter ) ; } return result ; } @Override public boolean removeAll ( final Collection < ? > coll ) { boolean result = false ; for ( final Object name : coll ) { result |= remove ( name ) ; } return result ; MST[BooleanTrueReturnValsMutator]MSP[S]
setOrder . removeIf ( filter ) ; } return result ; } @Override public boolean removeAll ( final Collection < ? > coll ) { boolean result = false ; for ( final Object name : coll ) { result |= remove ( name ) ; } return result ; MST[ReturnValsMutator]MSP[N]
public boolean removeIf ( final Predicate < ? super E > filter ) { if ( Objects . isNull ( filter ) ) { return false ; MST[rv.CRCR6Mutator]MSP[S] } final boolean result = decorated () . removeIf ( filter ) ; if ( result ) {
public boolean removeIf ( final Predicate < ? super E > filter ) { if ( Objects . isNull ( filter ) ) { MST[rv.ROR4Mutator]MSP[S] return false ; } final boolean result = decorated () . removeIf ( filter ) ; if ( result ) {
setOrder . clear () ; } else { setOrder . removeIf ( e -> ! decorated () . contains ( e ) ) ; MST[BooleanTrueReturnValsMutator]MSP[N] } return result ; } @Override public Object [] toArray () { return setOrder . toArray () ; } @Override
public boolean removeIf ( final Predicate < ? super E > filter ) { if ( Objects . isNull ( filter ) ) { MST[rv.ROR2Mutator]MSP[N] return false ; } final boolean result = decorated () . removeIf ( filter ) ; if ( result ) {
} @Override public boolean retainAll ( final Collection < ? > coll ) { final boolean result = decorated () . retainAll ( coll ) ; if ( result == false ) { return false ; } if ( decorated () . isEmpty () ) { MST[NegateConditionalsMutator]MSP[N]
if ( contains ( e ) ) { continue; } decorated () . add ( e ) ; toAdd . add ( e ) ; changed = true ; } if ( changed ) { setOrder . addAll ( index , toAdd ) ; } return changed ; MST[BooleanTrueReturnValsMutator]MSP[S] }
public < T > T [] toArray ( final T a [] ) { return setOrder . toArray ( a ) ; } public E get ( final int index ) { return setOrder . get ( index ) ; MST[NullReturnValsMutator]MSP[N] } public int indexOf ( final Object object ) {
if ( set . size () > 0 || list . size () > 0 ) { MST[rv.ROR4Mutator]MSP[N] throw new IllegalArgumentException ( lr_3 ) ; } return new ListOrderedSet <> ( set , list ) ; }
if ( set . size () > 0 || list . size () > 0 ) { MST[rv.ROR3Mutator]MSP[S] throw new IllegalArgumentException ( lr_3 ) ; } return new ListOrderedSet <> ( set , list ) ; }
public static < E > ListOrderedSet < E > listOrderedSet ( final Set < E > set , final List < E > list ) { Objects . requireNonNull ( set , lr_1 ) ; Objects . requireNonNull ( list , lr_2 ) ; MST[ArgumentPropagationMutator]MSP[N]
public boolean remove ( final Object object ) { final boolean result = decorated () . remove ( object ) ; if ( result ) { MST[rv.UOI4Mutator]MSP[N] setOrder . remove ( object ) ; } return result ; } @Override
if ( set . size () > 0 || list . size () > 0 ) { MST[rv.ROR2Mutator]MSP[N] throw new IllegalArgumentException ( lr_3 ) ; } return new ListOrderedSet <> ( set , list ) ; }
if ( set . size () > 0 || list . size () > 0 ) { MST[rv.ROR1Mutator]MSP[N] throw new IllegalArgumentException ( lr_3 ) ; } return new ListOrderedSet <> ( set , list ) ; }
if ( set . size () > 0 || list . size () > 0 ) { MST[rv.ROR5Mutator]MSP[N] throw new IllegalArgumentException ( lr_3 ) ; } return new ListOrderedSet <> ( set , list ) ; }
if ( contains ( e ) ) { continue; } decorated () . add ( e ) ; toAdd . add ( e ) ; changed = true ; } if ( changed ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] setOrder . addAll ( index , toAdd ) ; } return changed ; }
setOrder . clear () ; } else { setOrder . removeIf ( e -> ! decorated () . contains ( e ) ) ; MST[InlineConstantMutator]MSP[N] } return result ; } @Override public Object [] toArray () { return setOrder . toArray () ; } @Override
public < T > T [] toArray ( final T a [] ) { return setOrder . toArray ( a ) ; } public E get ( final int index ) { return setOrder . get ( index ) ; MST[rv.ABSMutator]MSP[N] } public int indexOf ( final Object object ) {
public boolean remove ( final Object object ) { final boolean result = decorated () . remove ( object ) ; if ( result ) { MST[rv.ROR1Mutator]MSP[N] setOrder . remove ( object ) ; } return result ; } @Override
public boolean remove ( final Object object ) { final boolean result = decorated () . remove ( object ) ; if ( result ) { MST[rv.UOI2Mutator]MSP[N] setOrder . remove ( object ) ; } return result ; } @Override
if ( contains ( e ) ) { continue; } decorated () . add ( e ) ; toAdd . add ( e ) ; MST[NonVoidMethodCallMutator]MSP[N] changed = true ; } if ( changed ) { setOrder . addAll ( index , toAdd ) ; } return changed ; }
} @Override public boolean retainAll ( final Collection < ? > coll ) { final boolean result = decorated () . retainAll ( coll ) ; if ( result == false ) { return false ; } if ( decorated () . isEmpty () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
setOrder . removeIf ( filter ) ; } return result ; } @Override public boolean removeAll ( final Collection < ? > coll ) { boolean result = false ; for ( final Object name : coll ) { result |= remove ( name ) ; MST[rv.ABSMutator]MSP[N] } return result ;
if ( contains ( e ) ) { continue; } decorated () . add ( e ) ; toAdd . add ( e ) ; changed = true ; } if ( changed ) { MST[rv.ABSMutator]MSP[N] setOrder . addAll ( index , toAdd ) ; } return changed ; }
if ( contains ( e ) ) { continue; } decorated () . add ( e ) ; toAdd . add ( e ) ; changed = true ; } if ( changed ) { MST[rv.ROR5Mutator]MSP[N] setOrder . addAll ( index , toAdd ) ; } return changed ; }
public E remove ( final int index ) { final E obj = setOrder . remove ( index ) ; remove ( obj ) ; return obj ; } @Override public String toString () { return setOrder . toString () ; MST[ReturnValsMutator]MSP[S] } @Override public E next () {
public boolean removeIf ( final Predicate < ? super E > filter ) { if ( Objects . isNull ( filter ) ) { return false ; MST[InlineConstantMutator]MSP[S] } final boolean result = decorated () . removeIf ( filter ) ; if ( result ) {
if ( contains ( e ) ) { continue; } decorated () . add ( e ) ; toAdd . add ( e ) ; changed = true ; } if ( changed ) { MST[rv.ROR1Mutator]MSP[S] setOrder . addAll ( index , toAdd ) ; } return changed ; }
if ( contains ( e ) ) { continue; } decorated () . add ( e ) ; toAdd . add ( e ) ; changed = true ; MST[rv.CRCR4Mutator]MSP[N] } if ( changed ) { setOrder . addAll ( index , toAdd ) ; } return changed ; }
setOrder . clear () ; } else { setOrder . removeIf ( e -> ! decorated () . contains ( e ) ) ; MST[rv.ROR4Mutator]MSP[N] } return result ; } @Override public Object [] toArray () { return setOrder . toArray () ; } @Override
public boolean remove ( final Object object ) { final boolean result = decorated () . remove ( object ) ; if ( result ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] setOrder . remove ( object ) ; } return result ; } @Override
setOrder . removeIf ( filter ) ; } return result ; MST[rv.UOI2Mutator]MSP[N] } @Override public boolean removeAll ( final Collection < ? > coll ) { boolean result = false ; for ( final Object name : coll ) { result |= remove ( name ) ; } return result ;
setOrder . clear () ; } else { setOrder . removeIf ( e -> ! decorated () . contains ( e ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } return result ; } @Override public Object [] toArray () { return setOrder . toArray () ; } @Override
setOrder . clear () ; } else { setOrder . removeIf ( e -> ! decorated () . contains ( e ) ) ; } return result ; MST[rv.UOI2Mutator]MSP[N] } @Override public Object [] toArray () { return setOrder . toArray () ; } @Override
if ( contains ( e ) ) { continue; } decorated () . add ( e ) ; toAdd . add ( e ) ; changed = true ; } if ( changed ) { setOrder . addAll ( index , toAdd ) ; } return changed ; MST[rv.UOI3Mutator]MSP[N] }
return new OrderedSetIterator <> ( setOrder . listIterator () , decorated () ) ; } @Override public boolean add ( final E object ) { if ( decorated () . add ( object ) ) { setOrder . add ( object ) ; return true ; } return false ; MST[rv.CRCR6Mutator]MSP[N]
return setOrder . indexOf ( object ) ; } public void add ( final int index , final E object ) { if ( ! contains ( object ) ) { decorated () . add ( object ) ; MST[NonVoidMethodCallMutator]MSP[N] setOrder . add ( index , object ) ; } }
return setOrder . indexOf ( object ) ; } public void add ( final int index , final E object ) { if ( ! contains ( object ) ) { decorated () . add ( object ) ; setOrder . add ( index , object ) ; MST[rv.ABSMutator]MSP[N] } }
Objects . requireNonNull ( list , lr_2 ) ; CollectionUtils . filter ( list , UniquePredicate . uniquePredicate () ) ; MST[NonVoidMethodCallMutator]MSP[S] final Set < E > set = new HashSet <> ( list ) ; return new ListOrderedSet <> ( set , list ) ; }
} @Override public boolean addAll ( final Collection < ? extends E > coll ) { boolean result = false ; for ( final E e : coll ) { result |= add ( e ) ; } return result ; MST[rv.UOI1Mutator]MSP[N] } @Override
public < T > T [] toArray ( final T a [] ) { return setOrder . toArray ( a ) ; } public E get ( final int index ) { return setOrder . get ( index ) ; MST[NonVoidMethodCallMutator]MSP[N] } public int indexOf ( final Object object ) {
setOrder . removeIf ( filter ) ; } return result ; } @Override public boolean removeAll ( final Collection < ? > coll ) { boolean result = false ; MST[InlineConstantMutator]MSP[S] for ( final Object name : coll ) { result |= remove ( name ) ; } return result ;
setOrder . clear () ; } else { setOrder . removeIf ( e -> ! decorated () . contains ( e ) ) ; MST[rv.CRCR6Mutator]MSP[N] } return result ; } @Override public Object [] toArray () { return setOrder . toArray () ; } @Override
} @Override public boolean retainAll ( final Collection < ? > coll ) { final boolean result = decorated () . retainAll ( coll ) ; if ( result == false ) { MST[rv.ROR2Mutator]MSP[N] return false ; } if ( decorated () . isEmpty () ) {
} @Override public boolean retainAll ( final Collection < ? > coll ) { final boolean result = decorated () . retainAll ( coll ) ; if ( result == false ) { return false ; } if ( decorated () . isEmpty () ) { MST[rv.ROR3Mutator]MSP[N]
setOrder . clear () ; } else { setOrder . removeIf ( e -> ! decorated () . contains ( e ) ) ; MST[rv.CRCR2Mutator]MSP[N] } return result ; } @Override public Object [] toArray () { return setOrder . toArray () ; } @Override
public boolean remove ( final Object object ) { final boolean result = decorated () . remove ( object ) ; if ( result ) { MST[rv.ABSMutator]MSP[N] setOrder . remove ( object ) ; } return result ; } @Override
public boolean remove ( final Object object ) { final boolean result = decorated () . remove ( object ) ; if ( result ) { setOrder . remove ( object ) ; } return result ; MST[rv.UOI1Mutator]MSP[N] } @Override
return new OrderedSetIterator <> ( setOrder . listIterator () , decorated () ) ; } @Override public boolean add ( final E object ) { if ( decorated () . add ( object ) ) { MST[NonVoidMethodCallMutator]MSP[N] setOrder . add ( object ) ; return true ; } return false ;
setOrder . removeIf ( filter ) ; } return result ; } @Override public boolean removeAll ( final Collection < ? > coll ) { boolean result = false ; for ( final Object name : coll ) { result |= remove ( name ) ; MST[MathMutator]MSP[S] } return result ;
} @Override public boolean retainAll ( final Collection < ? > coll ) { final boolean result = decorated () . retainAll ( coll ) ; if ( result == false ) { return false ; MST[rv.CRCR6Mutator]MSP[N] } if ( decorated () . isEmpty () ) {
} @Override public boolean addAll ( final Collection < ? extends E > coll ) { boolean result = false ; for ( final E e : coll ) { result |= add ( e ) ; MST[rv.OBBN2Mutator]MSP[N] } return result ; } @Override
if ( contains ( e ) ) { continue; } decorated () . add ( e ) ; toAdd . add ( e ) ; changed = true ; } if ( changed ) { setOrder . addAll ( index , toAdd ) ; } return changed ; MST[ReturnValsMutator]MSP[N] }
} @Override public boolean addAll ( final Collection < ? extends E > coll ) { boolean result = false ; for ( final E e : coll ) { result |= add ( e ) ; MST[rv.ABSMutator]MSP[N] } return result ; } @Override
if ( contains ( e ) ) { MST[NonVoidMethodCallMutator]MSP[N] continue; } decorated () . add ( e ) ; toAdd . add ( e ) ; changed = true ; } if ( changed ) { setOrder . addAll ( index , toAdd ) ; } return changed ; }
if ( contains ( e ) ) { MST[rv.ROR2Mutator]MSP[N] continue; } decorated () . add ( e ) ; toAdd . add ( e ) ; changed = true ; } if ( changed ) { setOrder . addAll ( index , toAdd ) ; } return changed ; }
setOrder . clear () ; } else { setOrder . removeIf ( e -> ! decorated () . contains ( e ) ) ; MST[ReturnValsMutator]MSP[N] } return result ; } @Override public Object [] toArray () { return setOrder . toArray () ; } @Override
setOrder . removeIf ( filter ) ; } return result ; } @Override public boolean removeAll ( final Collection < ? > coll ) { boolean result = false ; for ( final Object name : coll ) { result |= remove ( name ) ; MST[rv.UOI2Mutator]MSP[N] } return result ;
} @Override public boolean retainAll ( final Collection < ? > coll ) { final boolean result = decorated () . retainAll ( coll ) ; if ( result == false ) { MST[rv.UOI1Mutator]MSP[N] return false ; } if ( decorated () . isEmpty () ) {
public boolean addAll ( final int index , final Collection < ? extends E > coll ) { boolean changed = false ; MST[rv.CRCR6Mutator]MSP[S] final List < E > toAdd = new ArrayList <> () ; for ( final E e : coll ) {
if ( set . size () > 0 || list . size () > 0 ) { MST[NonVoidMethodCallMutator]MSP[N] throw new IllegalArgumentException ( lr_3 ) ; } return new ListOrderedSet <> ( set , list ) ; }
public < T > T [] toArray ( final T a [] ) { return setOrder . toArray ( a ) ; } public E get ( final int index ) { return setOrder . get ( index ) ; MST[rv.UOI2Mutator]MSP[N] } public int indexOf ( final Object object ) {
return new OrderedSetIterator <> ( setOrder . listIterator () , decorated () ) ; } @Override public boolean add ( final E object ) { if ( decorated () . add ( object ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] setOrder . add ( object ) ; return true ; } return false ;
Objects . requireNonNull ( list , lr_2 ) ; CollectionUtils . filter ( list , UniquePredicate . uniquePredicate () ) ; final Set < E > set = new HashSet <> ( list ) ; return new ListOrderedSet <> ( set , list ) ; MST[ConstructorCallMutator]MSP[N] }
public List < E > asList () { return UnmodifiableList . unmodifiableList ( setOrder ) ; MST[EmptyObjectReturnValsMutator]MSP[N] } @Override public void clear () { decorated () . clear () ; setOrder . clear () ; } @Override public OrderedIterator < E > iterator () {
public E remove ( final int index ) { final E obj = setOrder . remove ( index ) ; MST[NonVoidMethodCallMutator]MSP[S] remove ( obj ) ; return obj ; } @Override public String toString () { return setOrder . toString () ; } @Override public E next () {
return new OrderedSetIterator <> ( setOrder . listIterator () , decorated () ) ; MST[ConstructorCallMutator]MSP[N] } @Override public boolean add ( final E object ) { if ( decorated () . add ( object ) ) { setOrder . add ( object ) ; return true ; } return false ;
if ( contains ( e ) ) { continue; } decorated () . add ( e ) ; toAdd . add ( e ) ; changed = true ; } if ( changed ) { MST[rv.UOI2Mutator]MSP[N] setOrder . addAll ( index , toAdd ) ; } return changed ; }
if ( contains ( e ) ) { continue; } decorated () . add ( e ) ; toAdd . add ( e ) ; changed = true ; } if ( changed ) { MST[rv.UOI4Mutator]MSP[N] setOrder . addAll ( index , toAdd ) ; } return changed ; }
return new OrderedSetIterator <> ( setOrder . listIterator () , decorated () ) ; } @Override public boolean add ( final E object ) { if ( decorated () . add ( object ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] setOrder . add ( object ) ; return true ; } return false ;
setOrder . clear () ; } else { setOrder . removeIf ( e -> ! decorated () . contains ( e ) ) ; } return result ; MST[ReturnValsMutator]MSP[N] } @Override public Object [] toArray () { return setOrder . toArray () ; } @Override
Objects . requireNonNull ( list , lr_2 ) ; MST[ArgumentPropagationMutator]MSP[N] CollectionUtils . filter ( list , UniquePredicate . uniquePredicate () ) ; final Set < E > set = new HashSet <> ( list ) ; return new ListOrderedSet <> ( set , list ) ; }
setOrder . clear () ; } else { setOrder . removeIf ( e -> ! decorated () . contains ( e ) ) ; } return result ; MST[rv.ABSMutator]MSP[N] } @Override public Object [] toArray () { return setOrder . toArray () ; } @Override
public List < E > asList () { return UnmodifiableList . unmodifiableList ( setOrder ) ; } @Override public void clear () { decorated () . clear () ; setOrder . clear () ; MST[VoidMethodCallMutator]MSP[S] } @Override public OrderedIterator < E > iterator () {
} @Override public boolean addAll ( final Collection < ? extends E > coll ) { boolean result = false ; MST[InlineConstantMutator]MSP[N] for ( final E e : coll ) { result |= add ( e ) ; } return result ; } @Override
public boolean removeIf ( final Predicate < ? super E > filter ) { if ( Objects . isNull ( filter ) ) { return false ; } final boolean result = decorated () . removeIf ( filter ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( result ) {
setOrder . clear () ; } else { setOrder . removeIf ( e -> ! decorated () . contains ( e ) ) ; } return result ; } @Override public Object [] toArray () { return setOrder . toArray () ; MST[NullReturnValsMutator]MSP[N] } @Override
return new OrderedSetIterator <> ( setOrder . listIterator () , decorated () ) ; } @Override public boolean add ( final E object ) { if ( decorated () . add ( object ) ) { MST[rv.ROR5Mutator]MSP[N] setOrder . add ( object ) ; return true ; } return false ;
return new OrderedSetIterator <> ( setOrder . listIterator () , decorated () ) ; } @Override public boolean add ( final E object ) { if ( decorated () . add ( object ) ) { setOrder . add ( object ) ; return true ; MST[InlineConstantMutator]MSP[N] } return false ;
setOrder . clear () ; } else { setOrder . removeIf ( e -> ! decorated () . contains ( e ) ) ; MST[rv.CRCR5Mutator]MSP[N] } return result ; } @Override public Object [] toArray () { return setOrder . toArray () ; } @Override
setOrder . clear () ; } else { setOrder . removeIf ( e -> ! decorated () . contains ( e ) ) ; } return result ; } @Override public Object [] toArray () { return setOrder . toArray () ; MST[NonVoidMethodCallMutator]MSP[N] } @Override
setOrder . clear () ; } else { setOrder . removeIf ( e -> ! decorated () . contains ( e ) ) ; MST[rv.CRCR3Mutator]MSP[N] } return result ; } @Override public Object [] toArray () { return setOrder . toArray () ; } @Override
public boolean removeIf ( final Predicate < ? super E > filter ) { if ( Objects . isNull ( filter ) ) { return false ; } final boolean result = decorated () . removeIf ( filter ) ; if ( result ) { MST[NegateConditionalsMutator]MSP[S]
} @Override public boolean retainAll ( final Collection < ? > coll ) { final boolean result = decorated () . retainAll ( coll ) ; if ( result == false ) { return false ; } if ( decorated () . isEmpty () ) { MST[rv.ROR2Mutator]MSP[N]
if ( contains ( e ) ) { MST[rv.ROR5Mutator]MSP[N] continue; } decorated () . add ( e ) ; toAdd . add ( e ) ; changed = true ; } if ( changed ) { setOrder . addAll ( index , toAdd ) ; } return changed ; }
} @Override public boolean addAll ( final Collection < ? extends E > coll ) { boolean result = false ; for ( final E e : coll ) { result |= add ( e ) ; MST[rv.OBBN1Mutator]MSP[N] } return result ; } @Override
setOrder . removeIf ( filter ) ; } return result ; } @Override public boolean removeAll ( final Collection < ? > coll ) { boolean result = false ; for ( final Object name : coll ) { result |= remove ( name ) ; MST[rv.OBBN1Mutator]MSP[S] } return result ;
return new OrderedSetIterator <> ( setOrder . listIterator () , decorated () ) ; } @Override public boolean add ( final E object ) { if ( decorated () . add ( object ) ) { MST[rv.ROR3Mutator]MSP[N] setOrder . add ( object ) ; return true ; } return false ;
if ( contains ( e ) ) { MST[rv.ROR3Mutator]MSP[N] continue; } decorated () . add ( e ) ; toAdd . add ( e ) ; changed = true ; } if ( changed ) { setOrder . addAll ( index , toAdd ) ; } return changed ; }
} @Override public boolean retainAll ( final Collection < ? > coll ) { final boolean result = decorated () . retainAll ( coll ) ; if ( result == false ) { MST[rv.UOI2Mutator]MSP[N] return false ; } if ( decorated () . isEmpty () ) {
public < T > T [] toArray ( final T a [] ) { return setOrder . toArray ( a ) ; } public E get ( final int index ) { return setOrder . get ( index ) ; MST[rv.UOI1Mutator]MSP[N] } public int indexOf ( final Object object ) {
public boolean removeIf ( final Predicate < ? super E > filter ) { if ( Objects . isNull ( filter ) ) { MST[NegateConditionalsMutator]MSP[N] return false ; } final boolean result = decorated () . removeIf ( filter ) ; if ( result ) {
return new OrderedSetIterator <> ( setOrder . listIterator () , decorated () ) ; } @Override public boolean add ( final E object ) { if ( decorated () . add ( object ) ) { setOrder . add ( object ) ; MST[NonVoidMethodCallMutator]MSP[N] return true ; } return false ;
public boolean remove ( final Object object ) { final boolean result = decorated () . remove ( object ) ; if ( result ) { setOrder . remove ( object ) ; MST[NonVoidMethodCallMutator]MSP[S] } return result ; } @Override
setOrder . clear () ; } else { setOrder . removeIf ( e -> ! decorated () . contains ( e ) ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } return result ; } @Override public Object [] toArray () { return setOrder . toArray () ; } @Override
} @Override public boolean retainAll ( final Collection < ? > coll ) { final boolean result = decorated () . retainAll ( coll ) ; if ( result == false ) { MST[rv.UOI4Mutator]MSP[N] return false ; } if ( decorated () . isEmpty () ) {
public E remove ( final int index ) { final E obj = setOrder . remove ( index ) ; MST[rv.UOI2Mutator]MSP[N] remove ( obj ) ; return obj ; } @Override public String toString () { return setOrder . toString () ; } @Override public E next () {
public boolean addAll ( final int index , final Collection < ? extends E > coll ) { boolean changed = false ; MST[rv.CRCR1Mutator]MSP[S] final List < E > toAdd = new ArrayList <> () ; for ( final E e : coll ) {
setOrder . clear () ; } else { setOrder . removeIf ( e -> ! decorated () . contains ( e ) ) ; MST[rv.CRCR1Mutator]MSP[N] } return result ; } @Override public Object [] toArray () { return setOrder . toArray () ; } @Override
public < T > T [] toArray ( final T a [] ) { return setOrder . toArray ( a ) ; MST[ReturnValsMutator]MSP[N] } public E get ( final int index ) { return setOrder . get ( index ) ; } public int indexOf ( final Object object ) {
if ( set . size () > 0 || list . size () > 0 ) { MST[ConditionalsBoundaryMutator]MSP[S] throw new IllegalArgumentException ( lr_3 ) ; } return new ListOrderedSet <> ( set , list ) ; }
public boolean remove ( final Object object ) { final boolean result = decorated () . remove ( object ) ; if ( result ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] setOrder . remove ( object ) ; } return result ; } @Override
return setOrder . indexOf ( object ) ; MST[PrimitiveReturnsMutator]MSP[N] } public void add ( final int index , final E object ) { if ( ! contains ( object ) ) { decorated () . add ( object ) ; setOrder . add ( index , object ) ; } }
setOrder . clear () ; } else { setOrder . removeIf ( e -> ! decorated () . contains ( e ) ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } return result ; } @Override public Object [] toArray () { return setOrder . toArray () ; } @Override
setOrder . clear () ; } else { setOrder . removeIf ( e -> ! decorated () . contains ( e ) ) ; MST[InlineConstantMutator]MSP[N] } return result ; } @Override public Object [] toArray () { return setOrder . toArray () ; } @Override
if ( set . size () > 0 || list . size () > 0 ) { MST[NegateConditionalsMutator]MSP[N] throw new IllegalArgumentException ( lr_3 ) ; } return new ListOrderedSet <> ( set , list ) ; }
if ( contains ( e ) ) { continue; } decorated () . add ( e ) ; toAdd . add ( e ) ; changed = true ; MST[rv.CRCR6Mutator]MSP[N] } if ( changed ) { setOrder . addAll ( index , toAdd ) ; } return changed ; }
if ( set . size () > 0 || list . size () > 0 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[S] throw new IllegalArgumentException ( lr_3 ) ; } return new ListOrderedSet <> ( set , list ) ; }
setOrder . clear () ; } else { setOrder . removeIf ( e -> ! decorated () . contains ( e ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } return result ; } @Override public Object [] toArray () { return setOrder . toArray () ; } @Override
return new OrderedSetIterator <> ( setOrder . listIterator () , decorated () ) ; MST[NonVoidMethodCallMutator]MSP[N] } @Override public boolean add ( final E object ) { if ( decorated () . add ( object ) ) { setOrder . add ( object ) ; return true ; } return false ;
if ( contains ( e ) ) { continue; } decorated () . add ( e ) ; toAdd . add ( e ) ; changed = true ; } if ( changed ) { setOrder . addAll ( index , toAdd ) ; MST[rv.ABSMutator]MSP[S] } return changed ; }
if ( contains ( e ) ) { continue; } decorated () . add ( e ) ; toAdd . add ( e ) ; changed = true ; } if ( changed ) { MST[rv.ROR4Mutator]MSP[N] setOrder . addAll ( index , toAdd ) ; } return changed ; }
setOrder . clear () ; } else { setOrder . removeIf ( e -> ! decorated () . contains ( e ) ) ; } return result ; MST[rv.UOI1Mutator]MSP[N] } @Override public Object [] toArray () { return setOrder . toArray () ; } @Override
if ( contains ( e ) ) { continue; } decorated () . add ( e ) ; toAdd . add ( e ) ; changed = true ; MST[rv.CRCR3Mutator]MSP[N] } if ( changed ) { setOrder . addAll ( index , toAdd ) ; } return changed ; }
setOrder . removeIf ( filter ) ; } return result ; } @Override public boolean removeAll ( final Collection < ? > coll ) { boolean result = false ; for ( final Object name : coll ) { result |= remove ( name ) ; } return result ; MST[BooleanFalseReturnValsMutator]MSP[S]
setOrder . clear () ; } else { setOrder . removeIf ( e -> ! decorated () . contains ( e ) ) ; MST[rv.ROR3Mutator]MSP[N] } return result ; } @Override public Object [] toArray () { return setOrder . toArray () ; } @Override
if ( contains ( e ) ) { continue; } decorated () . add ( e ) ; toAdd . add ( e ) ; changed = true ; } if ( changed ) { setOrder . addAll ( index , toAdd ) ; } return changed ; MST[rv.UOI1Mutator]MSP[N] }
setOrder . clear () ; } else { setOrder . removeIf ( e -> ! decorated () . contains ( e ) ) ; } return result ; MST[rv.UOI4Mutator]MSP[N] } @Override public Object [] toArray () { return setOrder . toArray () ; } @Override
if ( contains ( e ) ) { continue; } decorated () . add ( e ) ; toAdd . add ( e ) ; changed = true ; MST[InlineConstantMutator]MSP[N] } if ( changed ) { setOrder . addAll ( index , toAdd ) ; } return changed ; }
} @Override public boolean retainAll ( final Collection < ? > coll ) { final boolean result = decorated () . retainAll ( coll ) ; if ( result == false ) { return false ; } if ( decorated () . isEmpty () ) { MST[NonVoidMethodCallMutator]MSP[N]
if ( contains ( e ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] continue; } decorated () . add ( e ) ; toAdd . add ( e ) ; changed = true ; } if ( changed ) { setOrder . addAll ( index , toAdd ) ; } return changed ; }
} @Override public boolean addAll ( final Collection < ? extends E > coll ) { boolean result = false ; for ( final E e : coll ) { result |= add ( e ) ; MST[NonVoidMethodCallMutator]MSP[N] } return result ; } @Override
public List < E > asList () { return UnmodifiableList . unmodifiableList ( setOrder ) ; } @Override public void clear () { decorated () . clear () ; MST[NonVoidMethodCallMutator]MSP[N] setOrder . clear () ; } @Override public OrderedIterator < E > iterator () {
} @Override public boolean addAll ( final Collection < ? extends E > coll ) { boolean result = false ; for ( final E e : coll ) { result |= add ( e ) ; } return result ; MST[rv.UOI3Mutator]MSP[N] } @Override
public E remove ( final int index ) { final E obj = setOrder . remove ( index ) ; remove ( obj ) ; return obj ; } @Override public String toString () { return setOrder . toString () ; MST[EmptyObjectReturnValsMutator]MSP[N] } @Override public E next () {
} @Override public boolean retainAll ( final Collection < ? > coll ) { final boolean result = decorated () . retainAll ( coll ) ; if ( result == false ) { return false ; } if ( decorated () . isEmpty () ) { MST[rv.ROR5Mutator]MSP[N]
} @Override public boolean addAll ( final Collection < ? extends E > coll ) { boolean result = false ; MST[rv.CRCR5Mutator]MSP[N] for ( final E e : coll ) { result |= add ( e ) ; } return result ; } @Override
return new OrderedSetIterator <> ( setOrder . listIterator () , decorated () ) ; } @Override public boolean add ( final E object ) { if ( decorated () . add ( object ) ) { MST[NonVoidMethodCallMutator]MSP[N] setOrder . add ( object ) ; return true ; } return false ;
} @Override public boolean retainAll ( final Collection < ? > coll ) { final boolean result = decorated () . retainAll ( coll ) ; if ( result == false ) { MST[rv.ROR4Mutator]MSP[N] return false ; } if ( decorated () . isEmpty () ) {
} @Override public boolean retainAll ( final Collection < ? > coll ) { final boolean result = decorated () . retainAll ( coll ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( result == false ) { return false ; } if ( decorated () . isEmpty () ) {
return setOrder . indexOf ( object ) ; } public void add ( final int index , final E object ) { if ( ! contains ( object ) ) { MST[rv.ROR1Mutator]MSP[N] decorated () . add ( object ) ; setOrder . add ( index , object ) ; } }
public boolean removeIf ( final Predicate < ? super E > filter ) { if ( Objects . isNull ( filter ) ) { MST[rv.ROR1Mutator]MSP[N] return false ; } final boolean result = decorated () . removeIf ( filter ) ; if ( result ) {
public boolean removeIf ( final Predicate < ? super E > filter ) { if ( Objects . isNull ( filter ) ) { return false ; MST[rv.CRCR1Mutator]MSP[S] } final boolean result = decorated () . removeIf ( filter ) ; if ( result ) {
} @Override public boolean retainAll ( final Collection < ? > coll ) { final boolean result = decorated () . retainAll ( coll ) ; if ( result == false ) { MST[NegateConditionalsMutator]MSP[N] return false ; } if ( decorated () . isEmpty () ) {
public List < E > asList () { return UnmodifiableList . unmodifiableList ( setOrder ) ; MST[ArgumentPropagationMutator]MSP[N] } @Override public void clear () { decorated () . clear () ; setOrder . clear () ; } @Override public OrderedIterator < E > iterator () {
public < T > T [] toArray ( final T a [] ) { return setOrder . toArray ( a ) ; } public E get ( final int index ) { return setOrder . get ( index ) ; MST[ReturnValsMutator]MSP[N] } public int indexOf ( final Object object ) {
setOrder . removeIf ( filter ) ; } return result ; } @Override public boolean removeAll ( final Collection < ? > coll ) { boolean result = false ; for ( final Object name : coll ) { result |= remove ( name ) ; MST[rv.UOI4Mutator]MSP[S] } return result ;
if ( set . size () > 0 || list . size () > 0 ) { MST[rv.ROR1Mutator]MSP[S] throw new IllegalArgumentException ( lr_3 ) ; } return new ListOrderedSet <> ( set , list ) ; }
setOrder . removeIf ( filter ) ; } return result ; } @Override public boolean removeAll ( final Collection < ? > coll ) { boolean result = false ; for ( final Object name : coll ) { result |= remove ( name ) ; MST[NonVoidMethodCallMutator]MSP[S] } return result ;
setOrder . clear () ; } else { setOrder . removeIf ( e -> ! decorated () . contains ( e ) ) ; } return result ; MST[BooleanTrueReturnValsMutator]MSP[N] } @Override public Object [] toArray () { return setOrder . toArray () ; } @Override
public < T > T [] toArray ( final T a [] ) { return setOrder . toArray ( a ) ; MST[NullReturnValsMutator]MSP[N] } public E get ( final int index ) { return setOrder . get ( index ) ; } public int indexOf ( final Object object ) {
if ( set . size () > 0 || list . size () > 0 ) { throw new IllegalArgumentException ( lr_3 ) ; } return new ListOrderedSet <> ( set , list ) ; MST[ReturnValsMutator]MSP[S] }
Objects . requireNonNull ( list , lr_2 ) ; CollectionUtils . filter ( list , UniquePredicate . uniquePredicate () ) ; final Set < E > set = new HashSet <> ( list ) ; MST[ConstructorCallMutator]MSP[N] return new ListOrderedSet <> ( set , list ) ; }
public boolean remove ( final Object object ) { final boolean result = decorated () . remove ( object ) ; if ( result ) { MST[rv.UOI3Mutator]MSP[N] setOrder . remove ( object ) ; } return result ; } @Override
public < T > T [] toArray ( final T a [] ) { return setOrder . toArray ( a ) ; } public E get ( final int index ) { return setOrder . get ( index ) ; MST[rv.UOI4Mutator]MSP[N] } public int indexOf ( final Object object ) {
last = getIterator () . next () ; return last ; MST[ReturnValsMutator]MSP[N] } @Override public void remove () { set . remove ( last ) ; getIterator () . remove () ; last = null ; } @Override public boolean hasPrevious () {
return ( ( ListIterator < E > ) getIterator () ) . hasPrevious () ; MST[ReturnValsMutator]MSP[S] } @Override public E previous () { last = ( ( ListIterator < E > ) getIterator () ) . previous () ; return last ; }
return ( ( ListIterator < E > ) getIterator () ) . hasPrevious () ; MST[NonVoidMethodCallMutator]MSP[N] } @Override public E previous () { last = ( ( ListIterator < E > ) getIterator () ) . previous () ; return last ; }
last = getIterator () . next () ; return last ; } @Override public void remove () { set . remove ( last ) ; MST[NonVoidMethodCallMutator]MSP[S] getIterator () . remove () ; last = null ; } @Override public boolean hasPrevious () {
last = getIterator () . next () ; return last ; } @Override public void remove () { set . remove ( last ) ; getIterator () . remove () ; MST[VoidMethodCallMutator]MSP[S] last = null ; } @Override public boolean hasPrevious () {
return ( ( ListIterator < E > ) getIterator () ) . hasPrevious () ; MST[NonVoidMethodCallMutator]MSP[S] } @Override public E previous () { last = ( ( ListIterator < E > ) getIterator () ) . previous () ; return last ; }
return ( ( ListIterator < E > ) getIterator () ) . hasPrevious () ; MST[BooleanFalseReturnValsMutator]MSP[N] } @Override public E previous () { last = ( ( ListIterator < E > ) getIterator () ) . previous () ; return last ; }
last = getIterator () . next () ; return last ; MST[NullReturnValsMutator]MSP[N] } @Override public void remove () { set . remove ( last ) ; getIterator () . remove () ; last = null ; } @Override public boolean hasPrevious () {
last = getIterator () . next () ; MST[experimental.MemberVariableMutator]MSP[N] return last ; } @Override public void remove () { set . remove ( last ) ; getIterator () . remove () ; last = null ; } @Override public boolean hasPrevious () {
last = getIterator () . next () ; return last ; } @Override public void remove () { set . remove ( last ) ; getIterator () . remove () ; MST[NonVoidMethodCallMutator]MSP[S] last = null ; } @Override public boolean hasPrevious () {
return ( ( ListIterator < E > ) getIterator () ) . hasPrevious () ; MST[BooleanTrueReturnValsMutator]MSP[S] } @Override public E previous () { last = ( ( ListIterator < E > ) getIterator () ) . previous () ; return last ; }
last = getIterator () . next () ; MST[NonVoidMethodCallMutator]MSP[N] return last ; } @Override public void remove () { set . remove ( last ) ; getIterator () . remove () ; last = null ; } @Override public boolean hasPrevious () {
last = getIterator () . next () ; return last ; } @Override public void remove () { set . remove ( last ) ; getIterator () . remove () ; last = null ; MST[experimental.MemberVariableMutator]MSP[N] } @Override public boolean hasPrevious () {
