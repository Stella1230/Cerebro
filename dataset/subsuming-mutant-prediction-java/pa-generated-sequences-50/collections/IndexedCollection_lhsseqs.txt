final Collection < C > coll = ( Collection < C > ) index . get ( key ) ; return coll == null ? null : coll . iterator () . next () ; MST[NonVoidMethodCallMutator]MSP[] } @SuppressWarnings ( lr_1 )
boolean changed = false ; for ( final C c : coll ) { changed |= add ( c ) ; } return changed ; MST[BooleanTrueReturnValsMutator]MSP[] } @Override public void clear () { super . clear () ; index . clear () ; } @SuppressWarnings ( lr_1 ) @Override
addToIndex ( c ) ; } } @SuppressWarnings ( lr_1 ) @Override public boolean remove ( final Object object ) { final boolean removed = super . remove ( object ) ; if ( removed ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] removeFromIndex ( ( C ) object ) ; } return removed ; }
addToIndex ( c ) ; } } @SuppressWarnings ( lr_1 ) @Override public boolean remove ( final Object object ) { final boolean removed = super . remove ( object ) ; if ( removed ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] removeFromIndex ( ( C ) object ) ; } return removed ; }
public boolean removeAll ( final Collection < ? > coll ) { boolean changed = false ; for ( final Object o : coll ) { changed |= remove ( o ) ; } return changed ; MST[rv.UOI1Mutator]MSP[] } @Override
public boolean removeAll ( final Collection < ? > coll ) { boolean changed = false ; for ( final Object o : coll ) { changed |= remove ( o ) ; } return changed ; MST[rv.UOI3Mutator]MSP[] } @Override
if ( ! contains ( o ) ) { return false ; MST[rv.CRCR1Mutator]MSP[] } } return true ; } public C get ( final K key ) { @SuppressWarnings ( lr_1 )
public static < K , C > IndexedCollection < K , C > uniqueIndexedCollection ( final Collection < C > coll , final Transformer < C , K > keyTransformer ) { return new IndexedCollection <> ( coll , keyTransformer , MST[ConstructorCallMutator]MSP[]
if ( ! contains ( o ) ) { return false ; MST[rv.CRCR3Mutator]MSP[] } } return true ; } public C get ( final K key ) { @SuppressWarnings ( lr_1 )
while ( it . hasNext () ) { MST[rv.ROR1Mutator]MSP[] if ( filter . test ( it . next () ) ) { it . remove () ; changed = true ; } } if ( changed ) { reindex () ; } return changed ; } @Override
public boolean removeAll ( final Collection < ? > coll ) { boolean changed = false ; MST[rv.CRCR6Mutator]MSP[] for ( final Object o : coll ) { changed |= remove ( o ) ; } return changed ; } @Override
boolean changed = false ; for ( final C c : coll ) { changed |= add ( c ) ; MST[rv.UOI4Mutator]MSP[] } return changed ; } @Override public void clear () { super . clear () ; index . clear () ; } @SuppressWarnings ( lr_1 ) @Override
boolean changed = false ; for ( final C c : coll ) { changed |= add ( c ) ; } return changed ; MST[ReturnValsMutator]MSP[] } @Override public void clear () { super . clear () ; index . clear () ; } @SuppressWarnings ( lr_1 ) @Override
boolean changed = false ; for ( final C c : coll ) { changed |= add ( c ) ; MST[rv.UOI2Mutator]MSP[] } return changed ; } @Override public void clear () { super . clear () ; index . clear () ; } @SuppressWarnings ( lr_1 ) @Override
while ( it . hasNext () ) { if ( filter . test ( it . next () ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] it . remove () ; changed = true ; } } if ( changed ) { reindex () ; } return changed ; } @Override
if ( ! contains ( o ) ) { return false ; MST[ReturnValsMutator]MSP[] } } return true ; } public C get ( final K key ) { @SuppressWarnings ( lr_1 )
public boolean add ( final C object ) { final boolean added = super . add ( object ) ; if ( added ) { MST[rv.ROR4Mutator]MSP[] addToIndex ( object ) ; } return added ; } @Override public boolean addAll ( final Collection < ? extends C > coll ) {
boolean changed = false ; MST[rv.CRCR6Mutator]MSP[] for ( final C c : coll ) { changed |= add ( c ) ; } return changed ; } @Override public void clear () { super . clear () ; index . clear () ; } @SuppressWarnings ( lr_1 ) @Override
while ( it . hasNext () ) { MST[rv.ROR5Mutator]MSP[] if ( filter . test ( it . next () ) ) { it . remove () ; changed = true ; } } if ( changed ) { reindex () ; } return changed ; } @Override
while ( it . hasNext () ) { if ( filter . test ( it . next () ) ) { MST[NegateConditionalsMutator]MSP[] it . remove () ; changed = true ; } } if ( changed ) { reindex () ; } return changed ; } @Override
public boolean add ( final C object ) { final boolean added = super . add ( object ) ; if ( added ) { MST[rv.UOI1Mutator]MSP[] addToIndex ( object ) ; } return added ; } @Override public boolean addAll ( final Collection < ? extends C > coll ) {
boolean changed = false ; for ( final C c : coll ) { changed |= add ( c ) ; } return changed ; MST[rv.UOI3Mutator]MSP[] } @Override public void clear () { super . clear () ; index . clear () ; } @SuppressWarnings ( lr_1 ) @Override
public boolean add ( final C object ) { final boolean added = super . add ( object ) ; if ( added ) { MST[rv.ROR2Mutator]MSP[] addToIndex ( object ) ; } return added ; } @Override public boolean addAll ( final Collection < ? extends C > coll ) {
final K key = keyTransformer . transform ( object ) ; if ( uniqueIndex && index . containsKey ( key ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] throw new IllegalArgumentException ( lr_2 ) ; } index . put ( key , object ) ; } private void removeFromIndex ( final C object ) {
while ( it . hasNext () ) { MST[rv.ROR3Mutator]MSP[] if ( filter . test ( it . next () ) ) { it . remove () ; changed = true ; } } if ( changed ) { reindex () ; } return changed ; } @Override
@Override public boolean removeIf ( final Predicate < ? super C > filter ) { if ( Objects . isNull ( filter ) ) { MST[rv.ROR2Mutator]MSP[] return false ; } boolean changed = false ; final Iterator < C > it = iterator () ;
if ( ! contains ( o ) ) { return false ; MST[rv.CRCR5Mutator]MSP[] } } return true ; } public C get ( final K key ) { @SuppressWarnings ( lr_1 )
while ( it . hasNext () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] if ( filter . test ( it . next () ) ) { it . remove () ; changed = true ; } } if ( changed ) { reindex () ; } return changed ; } @Override
while ( it . hasNext () ) { if ( filter . test ( it . next () ) ) { it . remove () ; changed = true ; } } if ( changed ) { MST[rv.UOI3Mutator]MSP[] reindex () ; } return changed ; } @Override
addToIndex ( c ) ; } } @SuppressWarnings ( lr_1 ) @Override public boolean remove ( final Object object ) { final boolean removed = super . remove ( object ) ; if ( removed ) { MST[NegateConditionalsMutator]MSP[] removeFromIndex ( ( C ) object ) ; } return removed ; }
final K key = keyTransformer . transform ( object ) ; if ( uniqueIndex && index . containsKey ( key ) ) { MST[rv.ROR2Mutator]MSP[] throw new IllegalArgumentException ( lr_2 ) ; } index . put ( key , object ) ; } private void removeFromIndex ( final C object ) {
final K key = keyTransformer . transform ( object ) ; if ( uniqueIndex && index . containsKey ( key ) ) { MST[rv.ROR4Mutator]MSP[] throw new IllegalArgumentException ( lr_2 ) ; } index . put ( key , object ) ; } private void removeFromIndex ( final C object ) {
final K key = keyTransformer . transform ( object ) ; MST[NonVoidMethodCallMutator]MSP[] if ( uniqueIndex && index . containsKey ( key ) ) { throw new IllegalArgumentException ( lr_2 ) ; } index . put ( key , object ) ; } private void removeFromIndex ( final C object ) {
public boolean add ( final C object ) { final boolean added = super . add ( object ) ; if ( added ) { MST[rv.UOI3Mutator]MSP[] addToIndex ( object ) ; } return added ; } @Override public boolean addAll ( final Collection < ? extends C > coll ) {
final Collection < C > coll = ( Collection < C > ) index . get ( key ) ; return coll == null ? null : coll . iterator () . next () ; MST[ReturnValsMutator]MSP[] } @SuppressWarnings ( lr_1 )
public static < K , C > IndexedCollection < K , C > uniqueIndexedCollection ( final Collection < C > coll , final Transformer < C , K > keyTransformer ) { return new IndexedCollection <> ( coll , keyTransformer , MST[ReturnValsMutator]MSP[]
while ( it . hasNext () ) { if ( filter . test ( it . next () ) ) { it . remove () ; changed = true ; } } if ( changed ) { MST[rv.UOI1Mutator]MSP[] reindex () ; } return changed ; } @Override
if ( ! contains ( o ) ) { return false ; MST[BooleanTrueReturnValsMutator]MSP[] } } return true ; } public C get ( final K key ) { @SuppressWarnings ( lr_1 )
public boolean removeAll ( final Collection < ? > coll ) { boolean changed = false ; for ( final Object o : coll ) { changed |= remove ( o ) ; } return changed ; MST[ReturnValsMutator]MSP[] } @Override
addToIndex ( c ) ; } } @SuppressWarnings ( lr_1 ) @Override public boolean remove ( final Object object ) { final boolean removed = super . remove ( object ) ; if ( removed ) { MST[rv.ABSMutator]MSP[] removeFromIndex ( ( C ) object ) ; } return removed ; }
@Override public boolean removeIf ( final Predicate < ? super C > filter ) { if ( Objects . isNull ( filter ) ) { return false ; MST[rv.CRCR6Mutator]MSP[] } boolean changed = false ; final Iterator < C > it = iterator () ;
while ( it . hasNext () ) { if ( filter . test ( it . next () ) ) { it . remove () ; changed = true ; MST[rv.CRCR6Mutator]MSP[] } } if ( changed ) { reindex () ; } return changed ; } @Override
final Collection < C > coll = ( Collection < C > ) index . get ( key ) ; return coll == null ? null : coll . iterator () . next () ; MST[NonVoidMethodCallMutator]MSP[] } @SuppressWarnings ( lr_1 )
public boolean contains ( final Object object ) { return index . containsKey ( keyTransformer . transform ( ( C ) object ) ) ; MST[BooleanFalseReturnValsMutator]MSP[] } @Override public boolean containsAll ( final Collection < ? > coll ) { for ( final Object o : coll ) {
while ( it . hasNext () ) { if ( filter . test ( it . next () ) ) { it . remove () ; changed = true ; } } if ( changed ) { reindex () ; } return changed ; MST[rv.UOI3Mutator]MSP[] } @Override
final K key = keyTransformer . transform ( object ) ; if ( uniqueIndex && index . containsKey ( key ) ) { throw new IllegalArgumentException ( lr_2 ) ; } index . put ( key , object ) ; MST[ArgumentPropagationMutator]MSP[] } private void removeFromIndex ( final C object ) {
public boolean retainAll ( final Collection < ? > coll ) { final boolean changed = super . retainAll ( coll ) ; if ( changed ) { reindex () ; } return changed ; MST[ReturnValsMutator]MSP[] } private void addToIndex ( final C object ) {
if ( ! contains ( o ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return false ; } } return true ; } public C get ( final K key ) { @SuppressWarnings ( lr_1 )
MultiValueMap . <K , C > multiValueMap ( new HashMap < K , Collection < C > > () ) , MST[rv.CRCR6Mutator]MSP[] true ) ; } public static < K , C > IndexedCollection < K , C > nonUniqueIndexedCollection ( final Collection < C > coll ,
final K key = keyTransformer . transform ( object ) ; if ( uniqueIndex && index . containsKey ( key ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] throw new IllegalArgumentException ( lr_2 ) ; } index . put ( key , object ) ; } private void removeFromIndex ( final C object ) {
MultiValueMap . <K , C > multiValueMap ( new HashMap < K , Collection < C > > () ) , MST[rv.CRCR2Mutator]MSP[] true ) ; } public static < K , C > IndexedCollection < K , C > nonUniqueIndexedCollection ( final Collection < C > coll ,
boolean changed = false ; for ( final C c : coll ) { changed |= add ( c ) ; MST[NonVoidMethodCallMutator]MSP[] } return changed ; } @Override public void clear () { super . clear () ; index . clear () ; } @SuppressWarnings ( lr_1 ) @Override
public boolean retainAll ( final Collection < ? > coll ) { final boolean changed = super . retainAll ( coll ) ; if ( changed ) { reindex () ; } return changed ; MST[rv.UOI3Mutator]MSP[] } private void addToIndex ( final C object ) {
if ( ! contains ( o ) ) { return false ; } } return true ; MST[rv.CRCR5Mutator]MSP[] } public C get ( final K key ) { @SuppressWarnings ( lr_1 )
if ( ! contains ( o ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return false ; } } return true ; } public C get ( final K key ) { @SuppressWarnings ( lr_1 )
while ( it . hasNext () ) { if ( filter . test ( it . next () ) ) { it . remove () ; changed = true ; MST[rv.CRCR2Mutator]MSP[] } } if ( changed ) { reindex () ; } return changed ; } @Override
final K key = keyTransformer . transform ( object ) ; if ( uniqueIndex && index . containsKey ( key ) ) { throw new IllegalArgumentException ( lr_2 ) ; } index . put ( key , object ) ; MST[NonVoidMethodCallMutator]MSP[] } private void removeFromIndex ( final C object ) {
public boolean contains ( final Object object ) { return index . containsKey ( keyTransformer . transform ( ( C ) object ) ) ; MST[NonVoidMethodCallMutator]MSP[] } @Override public boolean containsAll ( final Collection < ? > coll ) { for ( final Object o : coll ) {
public boolean removeAll ( final Collection < ? > coll ) { boolean changed = false ; for ( final Object o : coll ) { changed |= remove ( o ) ; } return changed ; MST[BooleanTrueReturnValsMutator]MSP[] } @Override
addToIndex ( c ) ; } } @SuppressWarnings ( lr_1 ) @Override public boolean remove ( final Object object ) { final boolean removed = super . remove ( object ) ; if ( removed ) { MST[rv.ROR1Mutator]MSP[] removeFromIndex ( ( C ) object ) ; } return removed ; }
while ( it . hasNext () ) { if ( filter . test ( it . next () ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] it . remove () ; changed = true ; } } if ( changed ) { reindex () ; } return changed ; } @Override
while ( it . hasNext () ) { if ( filter . test ( it . next () ) ) { it . remove () ; changed = true ; } } if ( changed ) { reindex () ; } return changed ; MST[ReturnValsMutator]MSP[] } @Override
final Transformer < C , K > keyTransformer ) { return new IndexedCollection <> ( coll , keyTransformer , MultiValueMap . <K , C > multiValueMap ( new HashMap < K , Collection < C > > () ) , MST[rv.CRCR6Mutator]MSP[] false ) ; } @Override
if ( ! contains ( o ) ) { MST[rv.ROR3Mutator]MSP[] return false ; } } return true ; } public C get ( final K key ) { @SuppressWarnings ( lr_1 )
addToIndex ( c ) ; } } @SuppressWarnings ( lr_1 ) @Override public boolean remove ( final Object object ) { final boolean removed = super . remove ( object ) ; if ( removed ) { removeFromIndex ( ( C ) object ) ; } return removed ; MST[rv.UOI2Mutator]MSP[] }
final Transformer < C , K > keyTransformer ) { return new IndexedCollection <> ( coll , keyTransformer , MST[NullReturnValsMutator]MSP[] MultiValueMap . <K , C > multiValueMap ( new HashMap < K , Collection < C > > () ) , false ) ; } @Override
while ( it . hasNext () ) { if ( filter . test ( it . next () ) ) { MST[rv.ROR3Mutator]MSP[] it . remove () ; changed = true ; } } if ( changed ) { reindex () ; } return changed ; } @Override
while ( it . hasNext () ) { MST[NonVoidMethodCallMutator]MSP[] if ( filter . test ( it . next () ) ) { it . remove () ; changed = true ; } } if ( changed ) { reindex () ; } return changed ; } @Override
final Collection < C > coll = ( Collection < C > ) index . get ( key ) ; MST[ArgumentPropagationMutator]MSP[] return coll == null ? null : coll . iterator () . next () ; } @SuppressWarnings ( lr_1 )
addToIndex ( c ) ; } } @SuppressWarnings ( lr_1 ) @Override public boolean remove ( final Object object ) { final boolean removed = super . remove ( object ) ; if ( removed ) { MST[rv.UOI4Mutator]MSP[] removeFromIndex ( ( C ) object ) ; } return removed ; }
addToIndex ( c ) ; } } @SuppressWarnings ( lr_1 ) @Override public boolean remove ( final Object object ) { final boolean removed = super . remove ( object ) ; if ( removed ) { MST[rv.ROR5Mutator]MSP[] removeFromIndex ( ( C ) object ) ; } return removed ; }
public boolean removeAll ( final Collection < ? > coll ) { boolean changed = false ; for ( final Object o : coll ) { changed |= remove ( o ) ; MST[rv.UOI4Mutator]MSP[] } return changed ; } @Override
public boolean retainAll ( final Collection < ? > coll ) { final boolean changed = super . retainAll ( coll ) ; if ( changed ) { MST[rv.UOI3Mutator]MSP[] reindex () ; } return changed ; } private void addToIndex ( final C object ) {
public boolean add ( final C object ) { final boolean added = super . add ( object ) ; if ( added ) { addToIndex ( object ) ; } return added ; MST[ReturnValsMutator]MSP[] } @Override public boolean addAll ( final Collection < ? extends C > coll ) {
public boolean add ( final C object ) { final boolean added = super . add ( object ) ; if ( added ) { addToIndex ( object ) ; } return added ; MST[BooleanTrueReturnValsMutator]MSP[] } @Override public boolean addAll ( final Collection < ? extends C > coll ) {
public boolean retainAll ( final Collection < ? > coll ) { final boolean changed = super . retainAll ( coll ) ; if ( changed ) { MST[rv.UOI1Mutator]MSP[] reindex () ; } return changed ; } private void addToIndex ( final C object ) {
MultiValueMap . <K , C > multiValueMap ( new HashMap < K , Collection < C > > () ) , MST[NonVoidMethodCallMutator]MSP[] true ) ; } public static < K , C > IndexedCollection < K , C > nonUniqueIndexedCollection ( final Collection < C > coll ,
if ( ! contains ( o ) ) { MST[NegateConditionalsMutator]MSP[] return false ; } } return true ; } public C get ( final K key ) { @SuppressWarnings ( lr_1 )
final Transformer < C , K > keyTransformer ) { return new IndexedCollection <> ( coll , keyTransformer , MultiValueMap . <K , C > multiValueMap ( new HashMap < K , Collection < C > > () ) , MST[InlineConstantMutator]MSP[] false ) ; } @Override
while ( it . hasNext () ) { if ( filter . test ( it . next () ) ) { it . remove () ; changed = true ; } } if ( changed ) { reindex () ; } return changed ; MST[BooleanTrueReturnValsMutator]MSP[] } @Override
public boolean removeAll ( final Collection < ? > coll ) { boolean changed = false ; for ( final Object o : coll ) { changed |= remove ( o ) ; MST[MathMutator]MSP[] } return changed ; } @Override
public boolean removeAll ( final Collection < ? > coll ) { boolean changed = false ; for ( final Object o : coll ) { changed |= remove ( o ) ; MST[rv.OBBN1Mutator]MSP[] } return changed ; } @Override
final Collection < C > coll = ( Collection < C > ) index . get ( key ) ; return coll == null ? null : coll . iterator () . next () ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] } @SuppressWarnings ( lr_1 )
addToIndex ( c ) ; MST[VoidMethodCallMutator]MSP[] } } @SuppressWarnings ( lr_1 ) @Override public boolean remove ( final Object object ) { final boolean removed = super . remove ( object ) ; if ( removed ) { removeFromIndex ( ( C ) object ) ; } return removed ; }
public boolean removeAll ( final Collection < ? > coll ) { boolean changed = false ; for ( final Object o : coll ) { changed |= remove ( o ) ; MST[rv.OBBN3Mutator]MSP[] } return changed ; } @Override
public boolean retainAll ( final Collection < ? > coll ) { final boolean changed = super . retainAll ( coll ) ; if ( changed ) { MST[rv.ABSMutator]MSP[] reindex () ; } return changed ; } private void addToIndex ( final C object ) {
boolean changed = false ; for ( final C c : coll ) { changed |= add ( c ) ; MST[rv.OBBN3Mutator]MSP[] } return changed ; } @Override public void clear () { super . clear () ; index . clear () ; } @SuppressWarnings ( lr_1 ) @Override
boolean changed = false ; for ( final C c : coll ) { changed |= add ( c ) ; MST[rv.OBBN1Mutator]MSP[] } return changed ; } @Override public void clear () { super . clear () ; index . clear () ; } @SuppressWarnings ( lr_1 ) @Override
if ( ! contains ( o ) ) { return false ; } } return true ; MST[BooleanFalseReturnValsMutator]MSP[] } public C get ( final K key ) { @SuppressWarnings ( lr_1 )
final K key = keyTransformer . transform ( object ) ; if ( uniqueIndex && index . containsKey ( key ) ) { MST[rv.ROR1Mutator]MSP[] throw new IllegalArgumentException ( lr_2 ) ; } index . put ( key , object ) ; } private void removeFromIndex ( final C object ) {
while ( it . hasNext () ) { if ( filter . test ( it . next () ) ) { it . remove () ; changed = true ; } } if ( changed ) { reindex () ; } return changed ; MST[rv.UOI4Mutator]MSP[] } @Override
@Override public boolean removeIf ( final Predicate < ? super C > filter ) { if ( Objects . isNull ( filter ) ) { return false ; } boolean changed = false ; MST[rv.CRCR5Mutator]MSP[] final Iterator < C > it = iterator () ;
public boolean add ( final C object ) { final boolean added = super . add ( object ) ; MST[NonVoidMethodCallMutator]MSP[] if ( added ) { addToIndex ( object ) ; } return added ; } @Override public boolean addAll ( final Collection < ? extends C > coll ) {
public boolean add ( final C object ) { final boolean added = super . add ( object ) ; if ( added ) { addToIndex ( object ) ; } return added ; MST[rv.UOI1Mutator]MSP[] } @Override public boolean addAll ( final Collection < ? extends C > coll ) {
public boolean add ( final C object ) { final boolean added = super . add ( object ) ; if ( added ) { addToIndex ( object ) ; } return added ; MST[rv.ABSMutator]MSP[] } @Override public boolean addAll ( final Collection < ? extends C > coll ) {
public boolean add ( final C object ) { final boolean added = super . add ( object ) ; if ( added ) { addToIndex ( object ) ; MST[VoidMethodCallMutator]MSP[] } return added ; } @Override public boolean addAll ( final Collection < ? extends C > coll ) {
public boolean removeAll ( final Collection < ? > coll ) { boolean changed = false ; for ( final Object o : coll ) { changed |= remove ( o ) ; MST[rv.ABSMutator]MSP[] } return changed ; } @Override
public boolean add ( final C object ) { final boolean added = super . add ( object ) ; if ( added ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] addToIndex ( object ) ; } return added ; } @Override public boolean addAll ( final Collection < ? extends C > coll ) {
public boolean retainAll ( final Collection < ? > coll ) { final boolean changed = super . retainAll ( coll ) ; if ( changed ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] reindex () ; } return changed ; } private void addToIndex ( final C object ) {
while ( it . hasNext () ) { if ( filter . test ( it . next () ) ) { it . remove () ; changed = true ; } } if ( changed ) { MST[rv.ABSMutator]MSP[] reindex () ; } return changed ; } @Override
public boolean retainAll ( final Collection < ? > coll ) { final boolean changed = super . retainAll ( coll ) ; if ( changed ) { reindex () ; MST[VoidMethodCallMutator]MSP[] } return changed ; } private void addToIndex ( final C object ) {
while ( it . hasNext () ) { if ( filter . test ( it . next () ) ) { it . remove () ; changed = true ; } } if ( changed ) { reindex () ; } return changed ; MST[rv.UOI1Mutator]MSP[] } @Override
while ( it . hasNext () ) { if ( filter . test ( it . next () ) ) { MST[rv.ROR1Mutator]MSP[] it . remove () ; changed = true ; } } if ( changed ) { reindex () ; } return changed ; } @Override
MultiValueMap . <K , C > multiValueMap ( new HashMap < K , Collection < C > > () ) , MST[rv.CRCR4Mutator]MSP[] true ) ; } public static < K , C > IndexedCollection < K , C > nonUniqueIndexedCollection ( final Collection < C > coll ,
public boolean add ( final C object ) { final boolean added = super . add ( object ) ; if ( added ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] addToIndex ( object ) ; } return added ; } @Override public boolean addAll ( final Collection < ? extends C > coll ) {
final Collection < C > coll = ( Collection < C > ) index . get ( key ) ; return coll == null ? null : coll . iterator () . next () ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] } @SuppressWarnings ( lr_1 )
public boolean retainAll ( final Collection < ? > coll ) { final boolean changed = super . retainAll ( coll ) ; if ( changed ) { reindex () ; } return changed ; MST[BooleanTrueReturnValsMutator]MSP[] } private void addToIndex ( final C object ) {
@Override public boolean removeIf ( final Predicate < ? super C > filter ) { if ( Objects . isNull ( filter ) ) { MST[rv.ROR3Mutator]MSP[] return false ; } boolean changed = false ; final Iterator < C > it = iterator () ;
public boolean retainAll ( final Collection < ? > coll ) { final boolean changed = super . retainAll ( coll ) ; if ( changed ) { reindex () ; } return changed ; MST[rv.UOI1Mutator]MSP[] } private void addToIndex ( final C object ) {
while ( it . hasNext () ) { if ( filter . test ( it . next () ) ) { it . remove () ; changed = true ; } } if ( changed ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] reindex () ; } return changed ; } @Override
addToIndex ( c ) ; } } @SuppressWarnings ( lr_1 ) @Override public boolean remove ( final Object object ) { final boolean removed = super . remove ( object ) ; if ( removed ) { removeFromIndex ( ( C ) object ) ; } return removed ; MST[BooleanFalseReturnValsMutator]MSP[] }
if ( ! contains ( o ) ) { return false ; } } return true ; MST[rv.CRCR4Mutator]MSP[] } public C get ( final K key ) { @SuppressWarnings ( lr_1 )
while ( it . hasNext () ) { if ( filter . test ( it . next () ) ) { it . remove () ; changed = true ; MST[rv.CRCR5Mutator]MSP[] } } if ( changed ) { reindex () ; } return changed ; } @Override
index . remove ( keyTransformer . transform ( object ) ) ; MST[ArgumentPropagationMutator]MSP[] }
if ( ! contains ( o ) ) { MST[rv.ROR1Mutator]MSP[] return false ; } } return true ; } public C get ( final K key ) { @SuppressWarnings ( lr_1 )
boolean changed = false ; for ( final C c : coll ) { changed |= add ( c ) ; MST[rv.UOI1Mutator]MSP[] } return changed ; } @Override public void clear () { super . clear () ; index . clear () ; } @SuppressWarnings ( lr_1 ) @Override
while ( it . hasNext () ) { MST[NegateConditionalsMutator]MSP[] if ( filter . test ( it . next () ) ) { it . remove () ; changed = true ; } } if ( changed ) { reindex () ; } return changed ; } @Override
while ( it . hasNext () ) { if ( filter . test ( it . next () ) ) { it . remove () ; changed = true ; } } if ( changed ) { reindex () ; MST[VoidMethodCallMutator]MSP[] } return changed ; } @Override
public boolean retainAll ( final Collection < ? > coll ) { final boolean changed = super . retainAll ( coll ) ; if ( changed ) { reindex () ; } return changed ; MST[rv.ABSMutator]MSP[] } private void addToIndex ( final C object ) {
boolean changed = false ; for ( final C c : coll ) { changed |= add ( c ) ; MST[rv.ABSMutator]MSP[] } return changed ; } @Override public void clear () { super . clear () ; index . clear () ; } @SuppressWarnings ( lr_1 ) @Override
public boolean add ( final C object ) { final boolean added = super . add ( object ) ; if ( added ) { MST[rv.ROR3Mutator]MSP[] addToIndex ( object ) ; } return added ; } @Override public boolean addAll ( final Collection < ? extends C > coll ) {
boolean changed = false ; for ( final C c : coll ) { changed |= add ( c ) ; } return changed ; MST[rv.UOI2Mutator]MSP[] } @Override public void clear () { super . clear () ; index . clear () ; } @SuppressWarnings ( lr_1 ) @Override
@Override public boolean removeIf ( final Predicate < ? super C > filter ) { if ( Objects . isNull ( filter ) ) { return false ; } boolean changed = false ; final Iterator < C > it = iterator () ; MST[NonVoidMethodCallMutator]MSP[]
final Transformer < C , K > keyTransformer ) { return new IndexedCollection <> ( coll , keyTransformer , MST[ConstructorCallMutator]MSP[] MultiValueMap . <K , C > multiValueMap ( new HashMap < K , Collection < C > > () ) , false ) ; } @Override
while ( it . hasNext () ) { MST[rv.ROR4Mutator]MSP[] if ( filter . test ( it . next () ) ) { it . remove () ; changed = true ; } } if ( changed ) { reindex () ; } return changed ; } @Override
public boolean retainAll ( final Collection < ? > coll ) { final boolean changed = super . retainAll ( coll ) ; if ( changed ) { MST[rv.ROR3Mutator]MSP[] reindex () ; } return changed ; } private void addToIndex ( final C object ) {
while ( it . hasNext () ) { if ( filter . test ( it . next () ) ) { it . remove () ; changed = true ; } } if ( changed ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] reindex () ; } return changed ; } @Override
public Collection < C > values ( final K key ) { return ( Collection < C > ) index . get ( key ) ; MST[EmptyObjectReturnValsMutator]MSP[] } public void reindex () { index . clear () ; for ( final C c : decorated () ) {
public Collection < C > values ( final K key ) { return ( Collection < C > ) index . get ( key ) ; } public void reindex () { index . clear () ; for ( final C c : decorated () ) { MST[NonVoidMethodCallMutator]MSP[]
addToIndex ( c ) ; } } @SuppressWarnings ( lr_1 ) @Override public boolean remove ( final Object object ) { final boolean removed = super . remove ( object ) ; if ( removed ) { MST[rv.UOI2Mutator]MSP[] removeFromIndex ( ( C ) object ) ; } return removed ; }
boolean changed = false ; for ( final C c : coll ) { changed |= add ( c ) ; MST[MathMutator]MSP[] } return changed ; } @Override public void clear () { super . clear () ; index . clear () ; } @SuppressWarnings ( lr_1 ) @Override
final K key = keyTransformer . transform ( object ) ; if ( uniqueIndex && index . containsKey ( key ) ) { MST[rv.ROR3Mutator]MSP[] throw new IllegalArgumentException ( lr_2 ) ; } index . put ( key , object ) ; } private void removeFromIndex ( final C object ) {
@Override public boolean removeIf ( final Predicate < ? super C > filter ) { if ( Objects . isNull ( filter ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return false ; } boolean changed = false ; final Iterator < C > it = iterator () ;
final K key = keyTransformer . transform ( object ) ; if ( uniqueIndex && index . containsKey ( key ) ) { throw new IllegalArgumentException ( lr_2 ) ; MST[ConstructorCallMutator]MSP[] } index . put ( key , object ) ; } private void removeFromIndex ( final C object ) {
@Override public boolean removeIf ( final Predicate < ? super C > filter ) { if ( Objects . isNull ( filter ) ) { return false ; MST[rv.CRCR3Mutator]MSP[] } boolean changed = false ; final Iterator < C > it = iterator () ;
final K key = keyTransformer . transform ( object ) ; if ( uniqueIndex && index . containsKey ( key ) ) { MST[rv.ROR4Mutator]MSP[] throw new IllegalArgumentException ( lr_2 ) ; } index . put ( key , object ) ; } private void removeFromIndex ( final C object ) {
@Override public boolean removeIf ( final Predicate < ? super C > filter ) { if ( Objects . isNull ( filter ) ) { return false ; MST[InlineConstantMutator]MSP[] } boolean changed = false ; final Iterator < C > it = iterator () ;
while ( it . hasNext () ) { if ( filter . test ( it . next () ) ) { it . remove () ; changed = true ; } } if ( changed ) { reindex () ; } return changed ; MST[rv.ABSMutator]MSP[] } @Override
final K key = keyTransformer . transform ( object ) ; if ( uniqueIndex && index . containsKey ( key ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] throw new IllegalArgumentException ( lr_2 ) ; } index . put ( key , object ) ; } private void removeFromIndex ( final C object ) {
public boolean add ( final C object ) { final boolean added = super . add ( object ) ; if ( added ) { addToIndex ( object ) ; } return added ; MST[rv.UOI4Mutator]MSP[] } @Override public boolean addAll ( final Collection < ? extends C > coll ) {
public boolean retainAll ( final Collection < ? > coll ) { final boolean changed = super . retainAll ( coll ) ; if ( changed ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] reindex () ; } return changed ; } private void addToIndex ( final C object ) {
while ( it . hasNext () ) { if ( filter . test ( it . next () ) ) { it . remove () ; changed = true ; } } if ( changed ) { MST[rv.ROR3Mutator]MSP[] reindex () ; } return changed ; } @Override
final K key = keyTransformer . transform ( object ) ; if ( uniqueIndex && index . containsKey ( key ) ) { MST[NegateConditionalsMutator]MSP[] throw new IllegalArgumentException ( lr_2 ) ; } index . put ( key , object ) ; } private void removeFromIndex ( final C object ) {
final K key = keyTransformer . transform ( object ) ; if ( uniqueIndex && index . containsKey ( key ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] throw new IllegalArgumentException ( lr_2 ) ; } index . put ( key , object ) ; } private void removeFromIndex ( final C object ) {
public boolean removeAll ( final Collection < ? > coll ) { boolean changed = false ; MST[rv.CRCR1Mutator]MSP[] for ( final Object o : coll ) { changed |= remove ( o ) ; } return changed ; } @Override
final K key = keyTransformer . transform ( object ) ; if ( uniqueIndex && index . containsKey ( key ) ) { MST[rv.ROR5Mutator]MSP[] throw new IllegalArgumentException ( lr_2 ) ; } index . put ( key , object ) ; } private void removeFromIndex ( final C object ) {
public boolean removeAll ( final Collection < ? > coll ) { boolean changed = false ; for ( final Object o : coll ) { changed |= remove ( o ) ; } return changed ; MST[rv.UOI4Mutator]MSP[] } @Override
public boolean removeAll ( final Collection < ? > coll ) { boolean changed = false ; for ( final Object o : coll ) { changed |= remove ( o ) ; } return changed ; MST[rv.UOI2Mutator]MSP[] } @Override
boolean changed = false ; for ( final C c : coll ) { changed |= add ( c ) ; } return changed ; MST[rv.ABSMutator]MSP[] } @Override public void clear () { super . clear () ; index . clear () ; } @SuppressWarnings ( lr_1 ) @Override
public boolean removeAll ( final Collection < ? > coll ) { boolean changed = false ; MST[rv.CRCR5Mutator]MSP[] for ( final Object o : coll ) { changed |= remove ( o ) ; } return changed ; } @Override
while ( it . hasNext () ) { MST[rv.ROR2Mutator]MSP[] if ( filter . test ( it . next () ) ) { it . remove () ; changed = true ; } } if ( changed ) { reindex () ; } return changed ; } @Override
public boolean removeAll ( final Collection < ? > coll ) { boolean changed = false ; MST[rv.CRCR3Mutator]MSP[] for ( final Object o : coll ) { changed |= remove ( o ) ; } return changed ; } @Override
index . remove ( keyTransformer . transform ( object ) ) ; MST[ArgumentPropagationMutator]MSP[] }
boolean changed = false ; for ( final C c : coll ) { changed |= add ( c ) ; MST[rv.UOI3Mutator]MSP[] } return changed ; } @Override public void clear () { super . clear () ; index . clear () ; } @SuppressWarnings ( lr_1 ) @Override
boolean changed = false ; for ( final C c : coll ) { changed |= add ( c ) ; } return changed ; } @Override public void clear () { super . clear () ; MST[VoidMethodCallMutator]MSP[] index . clear () ; } @SuppressWarnings ( lr_1 ) @Override
addToIndex ( c ) ; } } @SuppressWarnings ( lr_1 ) @Override public boolean remove ( final Object object ) { final boolean removed = super . remove ( object ) ; if ( removed ) { removeFromIndex ( ( C ) object ) ; } return removed ; MST[rv.UOI1Mutator]MSP[] }
public boolean add ( final C object ) { final boolean added = super . add ( object ) ; if ( added ) { MST[rv.ABSMutator]MSP[] addToIndex ( object ) ; } return added ; } @Override public boolean addAll ( final Collection < ? extends C > coll ) {
public boolean contains ( final Object object ) { return index . containsKey ( keyTransformer . transform ( ( C ) object ) ) ; MST[ArgumentPropagationMutator]MSP[] } @Override public boolean containsAll ( final Collection < ? > coll ) { for ( final Object o : coll ) {
addToIndex ( c ) ; } } @SuppressWarnings ( lr_1 ) @Override public boolean remove ( final Object object ) { final boolean removed = super . remove ( object ) ; if ( removed ) { MST[rv.ROR2Mutator]MSP[] removeFromIndex ( ( C ) object ) ; } return removed ; }
if ( ! contains ( o ) ) { MST[rv.ROR2Mutator]MSP[] return false ; } } return true ; } public C get ( final K key ) { @SuppressWarnings ( lr_1 )
if ( ! contains ( o ) ) { MST[rv.ROR4Mutator]MSP[] return false ; } } return true ; } public C get ( final K key ) { @SuppressWarnings ( lr_1 )
addToIndex ( c ) ; } } @SuppressWarnings ( lr_1 ) @Override public boolean remove ( final Object object ) { final boolean removed = super . remove ( object ) ; if ( removed ) { removeFromIndex ( ( C ) object ) ; } return removed ; MST[rv.UOI3Mutator]MSP[] }
public boolean retainAll ( final Collection < ? > coll ) { final boolean changed = super . retainAll ( coll ) ; MST[NonVoidMethodCallMutator]MSP[] if ( changed ) { reindex () ; } return changed ; } private void addToIndex ( final C object ) {
final Collection < C > coll = ( Collection < C > ) index . get ( key ) ; return coll == null ? null : coll . iterator () . next () ; MST[NegateConditionalsMutator]MSP[] } @SuppressWarnings ( lr_1 )
final Transformer < C , K > keyTransformer ) { return new IndexedCollection <> ( coll , keyTransformer , MultiValueMap . <K , C > multiValueMap ( new HashMap < K , Collection < C > > () ) , MST[NonVoidMethodCallMutator]MSP[] false ) ; } @Override
final Transformer < C , K > keyTransformer ) { return new IndexedCollection <> ( coll , keyTransformer , MultiValueMap . <K , C > multiValueMap ( new HashMap < K , Collection < C > > () ) , MST[ConstructorCallMutator]MSP[] false ) ; } @Override
final Transformer < C , K > keyTransformer ) { return new IndexedCollection <> ( coll , keyTransformer , MultiValueMap . <K , C > multiValueMap ( new HashMap < K , Collection < C > > () ) , MST[rv.CRCR5Mutator]MSP[] false ) ; } @Override
while ( it . hasNext () ) { if ( filter . test ( it . next () ) ) { MST[rv.ROR4Mutator]MSP[] it . remove () ; changed = true ; } } if ( changed ) { reindex () ; } return changed ; } @Override
final Transformer < C , K > keyTransformer ) { return new IndexedCollection <> ( coll , keyTransformer , MultiValueMap . <K , C > multiValueMap ( new HashMap < K , Collection < C > > () ) , MST[rv.CRCR3Mutator]MSP[] false ) ; } @Override
@Override public boolean removeIf ( final Predicate < ? super C > filter ) { if ( Objects . isNull ( filter ) ) { return false ; MST[ReturnValsMutator]MSP[] } boolean changed = false ; final Iterator < C > it = iterator () ;
while ( it . hasNext () ) { if ( filter . test ( it . next () ) ) { MST[rv.ROR2Mutator]MSP[] it . remove () ; changed = true ; } } if ( changed ) { reindex () ; } return changed ; } @Override
public boolean removeAll ( final Collection < ? > coll ) { boolean changed = false ; for ( final Object o : coll ) { changed |= remove ( o ) ; MST[rv.UOI3Mutator]MSP[] } return changed ; } @Override
public boolean removeAll ( final Collection < ? > coll ) { boolean changed = false ; for ( final Object o : coll ) { changed |= remove ( o ) ; MST[rv.UOI1Mutator]MSP[] } return changed ; } @Override
public boolean retainAll ( final Collection < ? > coll ) { final boolean changed = super . retainAll ( coll ) ; if ( changed ) { MST[NegateConditionalsMutator]MSP[] reindex () ; } return changed ; } private void addToIndex ( final C object ) {
public boolean contains ( final Object object ) { return index . containsKey ( keyTransformer . transform ( ( C ) object ) ) ; MST[ReturnValsMutator]MSP[] } @Override public boolean containsAll ( final Collection < ? > coll ) { for ( final Object o : coll ) {
addToIndex ( c ) ; } } @SuppressWarnings ( lr_1 ) @Override public boolean remove ( final Object object ) { final boolean removed = super . remove ( object ) ; if ( removed ) { MST[rv.ROR4Mutator]MSP[] removeFromIndex ( ( C ) object ) ; } return removed ; }
@Override public boolean removeIf ( final Predicate < ? super C > filter ) { if ( Objects . isNull ( filter ) ) { return false ; } boolean changed = false ; MST[InlineConstantMutator]MSP[] final Iterator < C > it = iterator () ;
@Override public boolean removeIf ( final Predicate < ? super C > filter ) { if ( Objects . isNull ( filter ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return false ; } boolean changed = false ; final Iterator < C > it = iterator () ;
MultiValueMap . <K , C > multiValueMap ( new HashMap < K , Collection < C > > () ) , MST[ConstructorCallMutator]MSP[] true ) ; } public static < K , C > IndexedCollection < K , C > nonUniqueIndexedCollection ( final Collection < C > coll ,
final Collection < C > coll = ( Collection < C > ) index . get ( key ) ; return coll == null ? null : coll . iterator () . next () ; MST[NullReturnValsMutator]MSP[] } @SuppressWarnings ( lr_1 )
public boolean removeAll ( final Collection < ? > coll ) { boolean changed = false ; for ( final Object o : coll ) { changed |= remove ( o ) ; } return changed ; MST[rv.ABSMutator]MSP[] } @Override
final Transformer < C , K > keyTransformer ) { return new IndexedCollection <> ( coll , keyTransformer , MultiValueMap . <K , C > multiValueMap ( new HashMap < K , Collection < C > > () ) , MST[rv.CRCR1Mutator]MSP[] false ) ; } @Override
MultiValueMap . <K , C > multiValueMap ( new HashMap < K , Collection < C > > () ) , MST[rv.CRCR5Mutator]MSP[] true ) ; } public static < K , C > IndexedCollection < K , C > nonUniqueIndexedCollection ( final Collection < C > coll ,
if ( ! contains ( o ) ) { return false ; } } return true ; MST[rv.CRCR6Mutator]MSP[] } public C get ( final K key ) { @SuppressWarnings ( lr_1 )
@Override public boolean removeIf ( final Predicate < ? super C > filter ) { if ( Objects . isNull ( filter ) ) { MST[rv.ROR5Mutator]MSP[] return false ; } boolean changed = false ; final Iterator < C > it = iterator () ;
public boolean retainAll ( final Collection < ? > coll ) { final boolean changed = super . retainAll ( coll ) ; if ( changed ) { MST[rv.ROR5Mutator]MSP[] reindex () ; } return changed ; } private void addToIndex ( final C object ) {
public boolean retainAll ( final Collection < ? > coll ) { final boolean changed = super . retainAll ( coll ) ; if ( changed ) { reindex () ; } return changed ; MST[rv.UOI4Mutator]MSP[] } private void addToIndex ( final C object ) {
public boolean contains ( final Object object ) { return index . containsKey ( keyTransformer . transform ( ( C ) object ) ) ; MST[BooleanTrueReturnValsMutator]MSP[] } @Override public boolean containsAll ( final Collection < ? > coll ) { for ( final Object o : coll ) {
public Collection < C > values ( final K key ) { return ( Collection < C > ) index . get ( key ) ; MST[ReturnValsMutator]MSP[] } public void reindex () { index . clear () ; for ( final C c : decorated () ) {
if ( ! contains ( o ) ) { return false ; } } return true ; MST[rv.CRCR2Mutator]MSP[] } public C get ( final K key ) { @SuppressWarnings ( lr_1 )
while ( it . hasNext () ) { if ( filter . test ( it . next () ) ) { it . remove () ; changed = true ; MST[InlineConstantMutator]MSP[] } } if ( changed ) { reindex () ; } return changed ; } @Override
@Override public boolean removeIf ( final Predicate < ? super C > filter ) { if ( Objects . isNull ( filter ) ) { MST[NonVoidMethodCallMutator]MSP[] return false ; } boolean changed = false ; final Iterator < C > it = iterator () ;
while ( it . hasNext () ) { if ( filter . test ( it . next () ) ) { it . remove () ; changed = true ; MST[rv.CRCR3Mutator]MSP[] } } if ( changed ) { reindex () ; } return changed ; } @Override
public boolean removeAll ( final Collection < ? > coll ) { boolean changed = false ; for ( final Object o : coll ) { changed |= remove ( o ) ; } return changed ; MST[BooleanFalseReturnValsMutator]MSP[] } @Override
public boolean add ( final C object ) { final boolean added = super . add ( object ) ; if ( added ) { addToIndex ( object ) ; } return added ; MST[rv.UOI2Mutator]MSP[] } @Override public boolean addAll ( final Collection < ? extends C > coll ) {
boolean changed = false ; MST[rv.CRCR5Mutator]MSP[] for ( final C c : coll ) { changed |= add ( c ) ; } return changed ; } @Override public void clear () { super . clear () ; index . clear () ; } @SuppressWarnings ( lr_1 ) @Override
boolean changed = false ; for ( final C c : coll ) { changed |= add ( c ) ; } return changed ; MST[rv.UOI4Mutator]MSP[] } @Override public void clear () { super . clear () ; index . clear () ; } @SuppressWarnings ( lr_1 ) @Override
public boolean add ( final C object ) { final boolean added = super . add ( object ) ; if ( added ) { MST[rv.ROR5Mutator]MSP[] addToIndex ( object ) ; } return added ; } @Override public boolean addAll ( final Collection < ? extends C > coll ) {
public boolean retainAll ( final Collection < ? > coll ) { final boolean changed = super . retainAll ( coll ) ; if ( changed ) { reindex () ; } return changed ; MST[BooleanFalseReturnValsMutator]MSP[] } private void addToIndex ( final C object ) {
public boolean add ( final C object ) { final boolean added = super . add ( object ) ; if ( added ) { MST[rv.ROR1Mutator]MSP[] addToIndex ( object ) ; } return added ; } @Override public boolean addAll ( final Collection < ? extends C > coll ) {
@Override public boolean removeIf ( final Predicate < ? super C > filter ) { if ( Objects . isNull ( filter ) ) { MST[rv.ROR1Mutator]MSP[] return false ; } boolean changed = false ; final Iterator < C > it = iterator () ;
@Override public boolean removeIf ( final Predicate < ? super C > filter ) { if ( Objects . isNull ( filter ) ) { return false ; MST[BooleanTrueReturnValsMutator]MSP[] } boolean changed = false ; final Iterator < C > it = iterator () ;
if ( ! contains ( o ) ) { return false ; MST[rv.CRCR6Mutator]MSP[] } } return true ; } public C get ( final K key ) { @SuppressWarnings ( lr_1 )
boolean changed = false ; MST[rv.CRCR1Mutator]MSP[] for ( final C c : coll ) { changed |= add ( c ) ; } return changed ; } @Override public void clear () { super . clear () ; index . clear () ; } @SuppressWarnings ( lr_1 ) @Override
public boolean retainAll ( final Collection < ? > coll ) { final boolean changed = super . retainAll ( coll ) ; if ( changed ) { MST[rv.ROR1Mutator]MSP[] reindex () ; } return changed ; } private void addToIndex ( final C object ) {
final Collection < C > coll = ( Collection < C > ) index . get ( key ) ; return coll == null ? null : coll . iterator () . next () ; MST[rv.ROR5Mutator]MSP[] } @SuppressWarnings ( lr_1 )
public static < K , C > IndexedCollection < K , C > uniqueIndexedCollection ( final Collection < C > coll , final Transformer < C , K > keyTransformer ) { return new IndexedCollection <> ( coll , keyTransformer , MST[NullReturnValsMutator]MSP[]
final K key = keyTransformer . transform ( object ) ; if ( uniqueIndex && index . containsKey ( key ) ) { MST[rv.ROR1Mutator]MSP[] throw new IllegalArgumentException ( lr_2 ) ; } index . put ( key , object ) ; } private void removeFromIndex ( final C object ) {
final K key = keyTransformer . transform ( object ) ; if ( uniqueIndex && index . containsKey ( key ) ) { MST[rv.ROR2Mutator]MSP[] throw new IllegalArgumentException ( lr_2 ) ; } index . put ( key , object ) ; } private void removeFromIndex ( final C object ) {
while ( it . hasNext () ) { if ( filter . test ( it . next () ) ) { it . remove () ; MST[VoidMethodCallMutator]MSP[] changed = true ; } } if ( changed ) { reindex () ; } return changed ; } @Override
public boolean add ( final C object ) { final boolean added = super . add ( object ) ; if ( added ) { MST[rv.UOI4Mutator]MSP[] addToIndex ( object ) ; } return added ; } @Override public boolean addAll ( final Collection < ? extends C > coll ) {
boolean changed = false ; for ( final C c : coll ) { changed |= add ( c ) ; } return changed ; MST[BooleanFalseReturnValsMutator]MSP[] } @Override public void clear () { super . clear () ; index . clear () ; } @SuppressWarnings ( lr_1 ) @Override
public Collection < C > values ( final K key ) { return ( Collection < C > ) index . get ( key ) ; MST[NonVoidMethodCallMutator]MSP[] } public void reindex () { index . clear () ; for ( final C c : decorated () ) {
@Override public boolean removeIf ( final Predicate < ? super C > filter ) { if ( Objects . isNull ( filter ) ) { return false ; MST[rv.CRCR1Mutator]MSP[] } boolean changed = false ; final Iterator < C > it = iterator () ;
while ( it . hasNext () ) { if ( filter . test ( it . next () ) ) { it . remove () ; changed = true ; } } if ( changed ) { MST[rv.UOI4Mutator]MSP[] reindex () ; } return changed ; } @Override
final Collection < C > coll = ( Collection < C > ) index . get ( key ) ; MST[NonVoidMethodCallMutator]MSP[] return coll == null ? null : coll . iterator () . next () ; } @SuppressWarnings ( lr_1 )
@Override public boolean removeIf ( final Predicate < ? super C > filter ) { if ( Objects . isNull ( filter ) ) { return false ; MST[rv.CRCR5Mutator]MSP[] } boolean changed = false ; final Iterator < C > it = iterator () ;
while ( it . hasNext () ) { if ( filter . test ( it . next () ) ) { it . remove () ; changed = true ; } } if ( changed ) { MST[rv.ROR5Mutator]MSP[] reindex () ; } return changed ; } @Override
while ( it . hasNext () ) { if ( filter . test ( it . next () ) ) { it . remove () ; changed = true ; } } if ( changed ) { MST[rv.ROR1Mutator]MSP[] reindex () ; } return changed ; } @Override
public Collection < C > values ( final K key ) { return ( Collection < C > ) index . get ( key ) ; MST[ArgumentPropagationMutator]MSP[] } public void reindex () { index . clear () ; for ( final C c : decorated () ) {
boolean changed = false ; MST[InlineConstantMutator]MSP[] for ( final C c : coll ) { changed |= add ( c ) ; } return changed ; } @Override public void clear () { super . clear () ; index . clear () ; } @SuppressWarnings ( lr_1 ) @Override
@Override public boolean removeIf ( final Predicate < ? super C > filter ) { if ( Objects . isNull ( filter ) ) { MST[NegateConditionalsMutator]MSP[] return false ; } boolean changed = false ; final Iterator < C > it = iterator () ;
public boolean retainAll ( final Collection < ? > coll ) { final boolean changed = super . retainAll ( coll ) ; if ( changed ) { MST[rv.UOI4Mutator]MSP[] reindex () ; } return changed ; } private void addToIndex ( final C object ) {
public boolean retainAll ( final Collection < ? > coll ) { final boolean changed = super . retainAll ( coll ) ; if ( changed ) { MST[rv.UOI2Mutator]MSP[] reindex () ; } return changed ; } private void addToIndex ( final C object ) {
public boolean add ( final C object ) { final boolean added = super . add ( object ) ; if ( added ) { addToIndex ( object ) ; } return added ; MST[BooleanFalseReturnValsMutator]MSP[] } @Override public boolean addAll ( final Collection < ? extends C > coll ) {
public boolean removeAll ( final Collection < ? > coll ) { boolean changed = false ; for ( final Object o : coll ) { changed |= remove ( o ) ; MST[NonVoidMethodCallMutator]MSP[] } return changed ; } @Override
while ( it . hasNext () ) { if ( filter . test ( it . next () ) ) { it . remove () ; changed = true ; } } if ( changed ) { reindex () ; } return changed ; MST[BooleanFalseReturnValsMutator]MSP[] } @Override
public boolean contains ( final Object object ) { return index . containsKey ( keyTransformer . transform ( ( C ) object ) ) ; MST[NonVoidMethodCallMutator]MSP[] } @Override public boolean containsAll ( final Collection < ? > coll ) { for ( final Object o : coll ) {
if ( ! contains ( o ) ) { MST[NonVoidMethodCallMutator]MSP[] return false ; } } return true ; } public C get ( final K key ) { @SuppressWarnings ( lr_1 )
public boolean add ( final C object ) { final boolean added = super . add ( object ) ; if ( added ) { addToIndex ( object ) ; } return added ; MST[rv.UOI3Mutator]MSP[] } @Override public boolean addAll ( final Collection < ? extends C > coll ) {
addToIndex ( c ) ; } } @SuppressWarnings ( lr_1 ) @Override public boolean remove ( final Object object ) { final boolean removed = super . remove ( object ) ; if ( removed ) { removeFromIndex ( ( C ) object ) ; } return removed ; MST[rv.ABSMutator]MSP[] }
index . remove ( keyTransformer . transform ( object ) ) ; MST[NonVoidMethodCallMutator]MSP[] }
addToIndex ( c ) ; } } @SuppressWarnings ( lr_1 ) @Override public boolean remove ( final Object object ) { final boolean removed = super . remove ( object ) ; MST[NonVoidMethodCallMutator]MSP[] if ( removed ) { removeFromIndex ( ( C ) object ) ; } return removed ; }
public boolean add ( final C object ) { final boolean added = super . add ( object ) ; if ( added ) { MST[NegateConditionalsMutator]MSP[] addToIndex ( object ) ; } return added ; } @Override public boolean addAll ( final Collection < ? extends C > coll ) {
public boolean retainAll ( final Collection < ? > coll ) { final boolean changed = super . retainAll ( coll ) ; if ( changed ) { MST[rv.ROR2Mutator]MSP[] reindex () ; } return changed ; } private void addToIndex ( final C object ) {
final K key = keyTransformer . transform ( object ) ; MST[ArgumentPropagationMutator]MSP[] if ( uniqueIndex && index . containsKey ( key ) ) { throw new IllegalArgumentException ( lr_2 ) ; } index . put ( key , object ) ; } private void removeFromIndex ( final C object ) {
final K key = keyTransformer . transform ( object ) ; if ( uniqueIndex && index . containsKey ( key ) ) { MST[NonVoidMethodCallMutator]MSP[] throw new IllegalArgumentException ( lr_2 ) ; } index . put ( key , object ) ; } private void removeFromIndex ( final C object ) {
public boolean retainAll ( final Collection < ? > coll ) { final boolean changed = super . retainAll ( coll ) ; if ( changed ) { MST[rv.ROR4Mutator]MSP[] reindex () ; } return changed ; } private void addToIndex ( final C object ) {
if ( ! contains ( o ) ) { return false ; MST[InlineConstantMutator]MSP[] } } return true ; } public C get ( final K key ) { @SuppressWarnings ( lr_1 )
addToIndex ( c ) ; } } @SuppressWarnings ( lr_1 ) @Override public boolean remove ( final Object object ) { final boolean removed = super . remove ( object ) ; if ( removed ) { MST[rv.UOI3Mutator]MSP[] removeFromIndex ( ( C ) object ) ; } return removed ; }
@Override public boolean removeIf ( final Predicate < ? super C > filter ) { if ( Objects . isNull ( filter ) ) { return false ; } boolean changed = false ; MST[rv.CRCR1Mutator]MSP[] final Iterator < C > it = iterator () ;
@Override public boolean removeIf ( final Predicate < ? super C > filter ) { if ( Objects . isNull ( filter ) ) { return false ; } boolean changed = false ; MST[rv.CRCR3Mutator]MSP[] final Iterator < C > it = iterator () ;
while ( it . hasNext () ) { if ( filter . test ( it . next () ) ) { MST[NonVoidMethodCallMutator]MSP[] it . remove () ; changed = true ; } } if ( changed ) { reindex () ; } return changed ; } @Override
final K key = keyTransformer . transform ( object ) ; if ( uniqueIndex && index . containsKey ( key ) ) { MST[rv.ROR3Mutator]MSP[] throw new IllegalArgumentException ( lr_2 ) ; } index . put ( key , object ) ; } private void removeFromIndex ( final C object ) {
while ( it . hasNext () ) { if ( filter . test ( it . next () ) ) { it . remove () ; changed = true ; } } if ( changed ) { MST[NegateConditionalsMutator]MSP[] reindex () ; } return changed ; } @Override
final Transformer < C , K > keyTransformer ) { return new IndexedCollection <> ( coll , keyTransformer , MST[ReturnValsMutator]MSP[] MultiValueMap . <K , C > multiValueMap ( new HashMap < K , Collection < C > > () ) , false ) ; } @Override
addToIndex ( c ) ; } } @SuppressWarnings ( lr_1 ) @Override public boolean remove ( final Object object ) { final boolean removed = super . remove ( object ) ; if ( removed ) { MST[rv.UOI1Mutator]MSP[] removeFromIndex ( ( C ) object ) ; } return removed ; }
addToIndex ( c ) ; } } @SuppressWarnings ( lr_1 ) @Override public boolean remove ( final Object object ) { final boolean removed = super . remove ( object ) ; if ( removed ) { removeFromIndex ( ( C ) object ) ; } return removed ; MST[ReturnValsMutator]MSP[] }
while ( it . hasNext () ) { if ( filter . test ( it . next () ) ) { it . remove () ; changed = true ; } } if ( changed ) { MST[rv.ROR2Mutator]MSP[] reindex () ; } return changed ; } @Override
while ( it . hasNext () ) { if ( filter . test ( it . next () ) ) { it . remove () ; changed = true ; } } if ( changed ) { MST[rv.ROR4Mutator]MSP[] reindex () ; } return changed ; } @Override
final K key = keyTransformer . transform ( object ) ; if ( uniqueIndex && index . containsKey ( key ) ) { MST[NegateConditionalsMutator]MSP[] throw new IllegalArgumentException ( lr_2 ) ; } index . put ( key , object ) ; } private void removeFromIndex ( final C object ) {
final K key = keyTransformer . transform ( object ) ; if ( uniqueIndex && index . containsKey ( key ) ) { MST[rv.ROR5Mutator]MSP[] throw new IllegalArgumentException ( lr_2 ) ; } index . put ( key , object ) ; } private void removeFromIndex ( final C object ) {
if ( ! contains ( o ) ) { return false ; } } return true ; MST[ReturnValsMutator]MSP[] } public C get ( final K key ) { @SuppressWarnings ( lr_1 )
while ( it . hasNext () ) { if ( filter . test ( it . next () ) ) { it . remove () ; changed = true ; } } if ( changed ) { reindex () ; } return changed ; MST[rv.UOI2Mutator]MSP[] } @Override
addToIndex ( c ) ; } } @SuppressWarnings ( lr_1 ) @Override public boolean remove ( final Object object ) { final boolean removed = super . remove ( object ) ; if ( removed ) { removeFromIndex ( ( C ) object ) ; MST[VoidMethodCallMutator]MSP[] } return removed ; }
MultiValueMap . <K , C > multiValueMap ( new HashMap < K , Collection < C > > () ) , MST[rv.CRCR3Mutator]MSP[] true ) ; } public static < K , C > IndexedCollection < K , C > nonUniqueIndexedCollection ( final Collection < C > coll ,
MultiValueMap . <K , C > multiValueMap ( new HashMap < K , Collection < C > > () ) , MST[InlineConstantMutator]MSP[] true ) ; } public static < K , C > IndexedCollection < K , C > nonUniqueIndexedCollection ( final Collection < C > coll ,
@Override public boolean removeIf ( final Predicate < ? super C > filter ) { if ( Objects . isNull ( filter ) ) { MST[rv.ROR4Mutator]MSP[] return false ; } boolean changed = false ; final Iterator < C > it = iterator () ;
public boolean retainAll ( final Collection < ? > coll ) { final boolean changed = super . retainAll ( coll ) ; if ( changed ) { reindex () ; } return changed ; MST[rv.UOI2Mutator]MSP[] } private void addToIndex ( final C object ) {
boolean changed = false ; for ( final C c : coll ) { changed |= add ( c ) ; } return changed ; MST[rv.UOI1Mutator]MSP[] } @Override public void clear () { super . clear () ; index . clear () ; } @SuppressWarnings ( lr_1 ) @Override
public Collection < C > values ( final K key ) { return ( Collection < C > ) index . get ( key ) ; } public void reindex () { index . clear () ; MST[VoidMethodCallMutator]MSP[] for ( final C c : decorated () ) {
boolean changed = false ; for ( final C c : coll ) { changed |= add ( c ) ; } return changed ; } @Override public void clear () { super . clear () ; index . clear () ; MST[VoidMethodCallMutator]MSP[] } @SuppressWarnings ( lr_1 ) @Override
if ( ! contains ( o ) ) { return false ; } } return true ; MST[rv.CRCR3Mutator]MSP[] } public C get ( final K key ) { @SuppressWarnings ( lr_1 )
while ( it . hasNext () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] if ( filter . test ( it . next () ) ) { it . remove () ; changed = true ; } } if ( changed ) { reindex () ; } return changed ; } @Override
while ( it . hasNext () ) { if ( filter . test ( it . next () ) ) { it . remove () ; changed = true ; MST[rv.CRCR4Mutator]MSP[] } } if ( changed ) { reindex () ; } return changed ; } @Override
addToIndex ( c ) ; } } @SuppressWarnings ( lr_1 ) @Override public boolean remove ( final Object object ) { final boolean removed = super . remove ( object ) ; if ( removed ) { removeFromIndex ( ( C ) object ) ; } return removed ; MST[BooleanTrueReturnValsMutator]MSP[] }
addToIndex ( c ) ; } } @SuppressWarnings ( lr_1 ) @Override public boolean remove ( final Object object ) { final boolean removed = super . remove ( object ) ; if ( removed ) { MST[rv.ROR3Mutator]MSP[] removeFromIndex ( ( C ) object ) ; } return removed ; }
public boolean removeAll ( final Collection < ? > coll ) { boolean changed = false ; for ( final Object o : coll ) { changed |= remove ( o ) ; MST[rv.OBBN2Mutator]MSP[] } return changed ; } @Override
index . remove ( keyTransformer . transform ( object ) ) ; MST[NonVoidMethodCallMutator]MSP[] }
public boolean add ( final C object ) { final boolean added = super . add ( object ) ; if ( added ) { MST[rv.UOI2Mutator]MSP[] addToIndex ( object ) ; } return added ; } @Override public boolean addAll ( final Collection < ? extends C > coll ) {
if ( ! contains ( o ) ) { return false ; } } return true ; MST[InlineConstantMutator]MSP[] } public C get ( final K key ) { @SuppressWarnings ( lr_1 )
addToIndex ( c ) ; } } @SuppressWarnings ( lr_1 ) @Override public boolean remove ( final Object object ) { final boolean removed = super . remove ( object ) ; if ( removed ) { removeFromIndex ( ( C ) object ) ; } return removed ; MST[rv.UOI4Mutator]MSP[] }
if ( ! contains ( o ) ) { MST[rv.ROR5Mutator]MSP[] return false ; } } return true ; } public C get ( final K key ) { @SuppressWarnings ( lr_1 )
public boolean removeAll ( final Collection < ? > coll ) { boolean changed = false ; MST[InlineConstantMutator]MSP[] for ( final Object o : coll ) { changed |= remove ( o ) ; } return changed ; } @Override
boolean changed = false ; MST[rv.CRCR3Mutator]MSP[] for ( final C c : coll ) { changed |= add ( c ) ; } return changed ; } @Override public void clear () { super . clear () ; index . clear () ; } @SuppressWarnings ( lr_1 ) @Override
while ( it . hasNext () ) { if ( filter . test ( it . next () ) ) { MST[rv.ROR5Mutator]MSP[] it . remove () ; changed = true ; } } if ( changed ) { reindex () ; } return changed ; } @Override
boolean changed = false ; for ( final C c : coll ) { changed |= add ( c ) ; MST[rv.OBBN2Mutator]MSP[] } return changed ; } @Override public void clear () { super . clear () ; index . clear () ; } @SuppressWarnings ( lr_1 ) @Override
public boolean removeAll ( final Collection < ? > coll ) { boolean changed = false ; for ( final Object o : coll ) { changed |= remove ( o ) ; MST[rv.UOI2Mutator]MSP[] } return changed ; } @Override
@Override public boolean removeIf ( final Predicate < ? super C > filter ) { if ( Objects . isNull ( filter ) ) { return false ; } boolean changed = false ; MST[rv.CRCR6Mutator]MSP[] final Iterator < C > it = iterator () ;
while ( it . hasNext () ) { if ( filter . test ( it . next () ) ) { it . remove () ; changed = true ; } } if ( changed ) { MST[rv.UOI2Mutator]MSP[] reindex () ; } return changed ; } @Override
