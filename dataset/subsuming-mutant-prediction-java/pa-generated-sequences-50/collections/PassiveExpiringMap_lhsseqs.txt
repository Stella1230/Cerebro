return now + timeToLiveMillis ; } return - 1L ; MST[PrimitiveReturnsMutator]MSP[] } private static long validateAndConvertToMillis ( final long timeToLive , final TimeUnit timeUnit ) { Objects . requireNonNull ( timeUnit , lr_1 ) ; return TimeUnit . MILLISECONDS . convert ( timeToLive , timeUnit ) ; } @Override
@Override public long expirationTime ( final K key , final V value ) { if ( timeToLiveMillis >= 0L ) { final long now = System . currentTimeMillis () ; if ( now > Long . MAX_VALUE - timeToLiveMillis ) { MST[rv.UOI4Mutator]MSP[] return - 1 ; }
return now + timeToLiveMillis ; MST[rv.AOR1Mutator]MSP[] } return - 1L ; } private static long validateAndConvertToMillis ( final long timeToLive , final TimeUnit timeUnit ) { Objects . requireNonNull ( timeUnit , lr_1 ) ; return TimeUnit . MILLISECONDS . convert ( timeToLive , timeUnit ) ; } @Override
@Override public long expirationTime ( final K key , final V value ) { if ( timeToLiveMillis >= 0L ) { MST[rv.ABSMutator]MSP[] final long now = System . currentTimeMillis () ; if ( now > Long . MAX_VALUE - timeToLiveMillis ) { return - 1 ; }
@Override public long expirationTime ( final K key , final V value ) { if ( timeToLiveMillis >= 0L ) { final long now = System . currentTimeMillis () ; if ( now > Long . MAX_VALUE - timeToLiveMillis ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[] return - 1 ; }
return now + timeToLiveMillis ; MST[rv.AOR2Mutator]MSP[] } return - 1L ; } private static long validateAndConvertToMillis ( final long timeToLive , final TimeUnit timeUnit ) { Objects . requireNonNull ( timeUnit , lr_1 ) ; return TimeUnit . MILLISECONDS . convert ( timeToLive , timeUnit ) ; } @Override
return now + timeToLiveMillis ; MST[rv.AOR3Mutator]MSP[] } return - 1L ; } private static long validateAndConvertToMillis ( final long timeToLive , final TimeUnit timeUnit ) { Objects . requireNonNull ( timeUnit , lr_1 ) ; return TimeUnit . MILLISECONDS . convert ( timeToLive , timeUnit ) ; } @Override
return now + timeToLiveMillis ; MST[rv.AOR4Mutator]MSP[] } return - 1L ; } private static long validateAndConvertToMillis ( final long timeToLive , final TimeUnit timeUnit ) { Objects . requireNonNull ( timeUnit , lr_1 ) ; return TimeUnit . MILLISECONDS . convert ( timeToLive , timeUnit ) ; } @Override
@Override public long expirationTime ( final K key , final V value ) { if ( timeToLiveMillis >= 0L ) { final long now = System . currentTimeMillis () ; MST[NonVoidMethodCallMutator]MSP[] if ( now > Long . MAX_VALUE - timeToLiveMillis ) { return - 1 ; }
@Override public long expirationTime ( final K key , final V value ) { if ( timeToLiveMillis >= 0L ) { final long now = System . currentTimeMillis () ; if ( now > Long . MAX_VALUE - timeToLiveMillis ) { MST[rv.UOI1Mutator]MSP[] return - 1 ; }
@Override public long expirationTime ( final K key , final V value ) { if ( timeToLiveMillis >= 0L ) { final long now = System . currentTimeMillis () ; if ( now > Long . MAX_VALUE - timeToLiveMillis ) { MST[NegateConditionalsMutator]MSP[] return - 1 ; }
@Override public long expirationTime ( final K key , final V value ) { if ( timeToLiveMillis >= 0L ) { final long now = System . currentTimeMillis () ; if ( now > Long . MAX_VALUE - timeToLiveMillis ) { MST[rv.UOI2Mutator]MSP[] return - 1 ; }
@Override public long expirationTime ( final K key , final V value ) { if ( timeToLiveMillis >= 0L ) { final long now = System . currentTimeMillis () ; if ( now > Long . MAX_VALUE - timeToLiveMillis ) { MST[rv.UOI3Mutator]MSP[] return - 1 ; }
return now + timeToLiveMillis ; MST[rv.ABSMutator]MSP[] } return - 1L ; } private static long validateAndConvertToMillis ( final long timeToLive , final TimeUnit timeUnit ) { Objects . requireNonNull ( timeUnit , lr_1 ) ; return TimeUnit . MILLISECONDS . convert ( timeToLive , timeUnit ) ; } @Override
@Override public long expirationTime ( final K key , final V value ) { if ( timeToLiveMillis >= 0L ) { final long now = System . currentTimeMillis () ; if ( now > Long . MAX_VALUE - timeToLiveMillis ) { MST[rv.AOD1Mutator]MSP[] return - 1 ; }
@Override public long expirationTime ( final K key , final V value ) { if ( timeToLiveMillis >= 0L ) { MST[rv.CRCR6Mutator]MSP[] final long now = System . currentTimeMillis () ; if ( now > Long . MAX_VALUE - timeToLiveMillis ) { return - 1 ; }
return now + timeToLiveMillis ; MST[MathMutator]MSP[] } return - 1L ; } private static long validateAndConvertToMillis ( final long timeToLive , final TimeUnit timeUnit ) { Objects . requireNonNull ( timeUnit , lr_1 ) ; return TimeUnit . MILLISECONDS . convert ( timeToLive , timeUnit ) ; } @Override
@Override public long expirationTime ( final K key , final V value ) { if ( timeToLiveMillis >= 0L ) { final long now = System . currentTimeMillis () ; if ( now > Long . MAX_VALUE - timeToLiveMillis ) { MST[rv.UOI2Mutator]MSP[] return - 1 ; }
@Override public long expirationTime ( final K key , final V value ) { if ( timeToLiveMillis >= 0L ) { MST[rv.UOI4Mutator]MSP[] final long now = System . currentTimeMillis () ; if ( now > Long . MAX_VALUE - timeToLiveMillis ) { return - 1 ; }
@Override public long expirationTime ( final K key , final V value ) { if ( timeToLiveMillis >= 0L ) { final long now = System . currentTimeMillis () ; if ( now > Long . MAX_VALUE - timeToLiveMillis ) { MST[rv.UOI1Mutator]MSP[] return - 1 ; }
@Override public long expirationTime ( final K key , final V value ) { if ( timeToLiveMillis >= 0L ) { MST[InlineConstantMutator]MSP[] final long now = System . currentTimeMillis () ; if ( now > Long . MAX_VALUE - timeToLiveMillis ) { return - 1 ; }
@Override public long expirationTime ( final K key , final V value ) { if ( timeToLiveMillis >= 0L ) { MST[rv.UOI3Mutator]MSP[] final long now = System . currentTimeMillis () ; if ( now > Long . MAX_VALUE - timeToLiveMillis ) { return - 1 ; }
return now + timeToLiveMillis ; } return - 1L ; MST[rv.CRCR1Mutator]MSP[] } private static long validateAndConvertToMillis ( final long timeToLive , final TimeUnit timeUnit ) { Objects . requireNonNull ( timeUnit , lr_1 ) ; return TimeUnit . MILLISECONDS . convert ( timeToLive , timeUnit ) ; } @Override
@Override public long expirationTime ( final K key , final V value ) { if ( timeToLiveMillis >= 0L ) { final long now = System . currentTimeMillis () ; if ( now > Long . MAX_VALUE - timeToLiveMillis ) { MST[MathMutator]MSP[] return - 1 ; }
@Override public long expirationTime ( final K key , final V value ) { if ( timeToLiveMillis >= 0L ) { final long now = System . currentTimeMillis () ; if ( now > Long . MAX_VALUE - timeToLiveMillis ) { MST[rv.AOR4Mutator]MSP[] return - 1 ; }
@Override public long expirationTime ( final K key , final V value ) { if ( timeToLiveMillis >= 0L ) { final long now = System . currentTimeMillis () ; if ( now > Long . MAX_VALUE - timeToLiveMillis ) { MST[rv.ROR5Mutator]MSP[] return - 1 ; }
return now + timeToLiveMillis ; MST[rv.UOI4Mutator]MSP[] } return - 1L ; } private static long validateAndConvertToMillis ( final long timeToLive , final TimeUnit timeUnit ) { Objects . requireNonNull ( timeUnit , lr_1 ) ; return TimeUnit . MILLISECONDS . convert ( timeToLive , timeUnit ) ; } @Override
return now + timeToLiveMillis ; MST[rv.UOI3Mutator]MSP[] } return - 1L ; } private static long validateAndConvertToMillis ( final long timeToLive , final TimeUnit timeUnit ) { Objects . requireNonNull ( timeUnit , lr_1 ) ; return TimeUnit . MILLISECONDS . convert ( timeToLive , timeUnit ) ; } @Override
return now + timeToLiveMillis ; } return - 1L ; MST[rv.CRCR4Mutator]MSP[] } private static long validateAndConvertToMillis ( final long timeToLive , final TimeUnit timeUnit ) { Objects . requireNonNull ( timeUnit , lr_1 ) ; return TimeUnit . MILLISECONDS . convert ( timeToLive , timeUnit ) ; } @Override
return now + timeToLiveMillis ; } return - 1L ; MST[rv.CRCR5Mutator]MSP[] } private static long validateAndConvertToMillis ( final long timeToLive , final TimeUnit timeUnit ) { Objects . requireNonNull ( timeUnit , lr_1 ) ; return TimeUnit . MILLISECONDS . convert ( timeToLive , timeUnit ) ; } @Override
@Override public long expirationTime ( final K key , final V value ) { if ( timeToLiveMillis >= 0L ) { final long now = System . currentTimeMillis () ; if ( now > Long . MAX_VALUE - timeToLiveMillis ) { MST[rv.AOR3Mutator]MSP[] return - 1 ; }
return now + timeToLiveMillis ; MST[rv.UOI2Mutator]MSP[] } return - 1L ; } private static long validateAndConvertToMillis ( final long timeToLive , final TimeUnit timeUnit ) { Objects . requireNonNull ( timeUnit , lr_1 ) ; return TimeUnit . MILLISECONDS . convert ( timeToLive , timeUnit ) ; } @Override
@Override public long expirationTime ( final K key , final V value ) { if ( timeToLiveMillis >= 0L ) { final long now = System . currentTimeMillis () ; if ( now > Long . MAX_VALUE - timeToLiveMillis ) { MST[rv.ROR2Mutator]MSP[] return - 1 ; }
return now + timeToLiveMillis ; MST[rv.UOI1Mutator]MSP[] } return - 1L ; } private static long validateAndConvertToMillis ( final long timeToLive , final TimeUnit timeUnit ) { Objects . requireNonNull ( timeUnit , lr_1 ) ; return TimeUnit . MILLISECONDS . convert ( timeToLive , timeUnit ) ; } @Override
@Override public long expirationTime ( final K key , final V value ) { if ( timeToLiveMillis >= 0L ) { final long now = System . currentTimeMillis () ; if ( now > Long . MAX_VALUE - timeToLiveMillis ) { MST[rv.ROR1Mutator]MSP[] return - 1 ; }
return now + timeToLiveMillis ; } return - 1L ; MST[ReturnValsMutator]MSP[] } private static long validateAndConvertToMillis ( final long timeToLive , final TimeUnit timeUnit ) { Objects . requireNonNull ( timeUnit , lr_1 ) ; return TimeUnit . MILLISECONDS . convert ( timeToLive , timeUnit ) ; } @Override
@Override public long expirationTime ( final K key , final V value ) { if ( timeToLiveMillis >= 0L ) { final long now = System . currentTimeMillis () ; if ( now > Long . MAX_VALUE - timeToLiveMillis ) { return - 1 ; MST[rv.CRCR5Mutator]MSP[] }
@Override public long expirationTime ( final K key , final V value ) { if ( timeToLiveMillis >= 0L ) { MST[rv.CRCR3Mutator]MSP[] final long now = System . currentTimeMillis () ; if ( now > Long . MAX_VALUE - timeToLiveMillis ) { return - 1 ; }
@Override public long expirationTime ( final K key , final V value ) { if ( timeToLiveMillis >= 0L ) { final long now = System . currentTimeMillis () ; if ( now > Long . MAX_VALUE - timeToLiveMillis ) { return - 1 ; MST[rv.CRCR1Mutator]MSP[] }
@Override public long expirationTime ( final K key , final V value ) { if ( timeToLiveMillis >= 0L ) { final long now = System . currentTimeMillis () ; if ( now > Long . MAX_VALUE - timeToLiveMillis ) { MST[rv.CRCR5Mutator]MSP[] return - 1 ; }
@Override public long expirationTime ( final K key , final V value ) { if ( timeToLiveMillis >= 0L ) { final long now = System . currentTimeMillis () ; if ( now > Long . MAX_VALUE - timeToLiveMillis ) { MST[rv.CRCR1Mutator]MSP[] return - 1 ; }
@Override public long expirationTime ( final K key , final V value ) { if ( timeToLiveMillis >= 0L ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] final long now = System . currentTimeMillis () ; if ( now > Long . MAX_VALUE - timeToLiveMillis ) { return - 1 ; }
@Override public long expirationTime ( final K key , final V value ) { if ( timeToLiveMillis >= 0L ) { MST[rv.ROR2Mutator]MSP[] final long now = System . currentTimeMillis () ; if ( now > Long . MAX_VALUE - timeToLiveMillis ) { return - 1 ; }
@Override public long expirationTime ( final K key , final V value ) { if ( timeToLiveMillis >= 0L ) { MST[rv.ROR3Mutator]MSP[] final long now = System . currentTimeMillis () ; if ( now > Long . MAX_VALUE - timeToLiveMillis ) { return - 1 ; }
@Override public long expirationTime ( final K key , final V value ) { if ( timeToLiveMillis >= 0L ) { MST[rv.ROR1Mutator]MSP[] final long now = System . currentTimeMillis () ; if ( now > Long . MAX_VALUE - timeToLiveMillis ) { return - 1 ; }
@Override public long expirationTime ( final K key , final V value ) { if ( timeToLiveMillis >= 0L ) { MST[rv.ROR5Mutator]MSP[] final long now = System . currentTimeMillis () ; if ( now > Long . MAX_VALUE - timeToLiveMillis ) { return - 1 ; }
@Override public long expirationTime ( final K key , final V value ) { if ( timeToLiveMillis >= 0L ) { MST[rv.ROR4Mutator]MSP[] final long now = System . currentTimeMillis () ; if ( now > Long . MAX_VALUE - timeToLiveMillis ) { return - 1 ; }
@Override public long expirationTime ( final K key , final V value ) { if ( timeToLiveMillis >= 0L ) { final long now = System . currentTimeMillis () ; if ( now > Long . MAX_VALUE - timeToLiveMillis ) { return - 1 ; MST[ReturnValsMutator]MSP[] }
@Override public long expirationTime ( final K key , final V value ) { if ( timeToLiveMillis >= 0L ) { final long now = System . currentTimeMillis () ; if ( now > Long . MAX_VALUE - timeToLiveMillis ) { MST[rv.ABSMutator]MSP[] return - 1 ; }
return now + timeToLiveMillis ; MST[ReturnValsMutator]MSP[] } return - 1L ; } private static long validateAndConvertToMillis ( final long timeToLive , final TimeUnit timeUnit ) { Objects . requireNonNull ( timeUnit , lr_1 ) ; return TimeUnit . MILLISECONDS . convert ( timeToLive , timeUnit ) ; } @Override
@Override public long expirationTime ( final K key , final V value ) { if ( timeToLiveMillis >= 0L ) { final long now = System . currentTimeMillis () ; if ( now > Long . MAX_VALUE - timeToLiveMillis ) { MST[rv.CRCR4Mutator]MSP[] return - 1 ; }
return now + timeToLiveMillis ; MST[rv.ABSMutator]MSP[] } return - 1L ; } private static long validateAndConvertToMillis ( final long timeToLive , final TimeUnit timeUnit ) { Objects . requireNonNull ( timeUnit , lr_1 ) ; return TimeUnit . MILLISECONDS . convert ( timeToLive , timeUnit ) ; } @Override
@Override public long expirationTime ( final K key , final V value ) { if ( timeToLiveMillis >= 0L ) { final long now = System . currentTimeMillis () ; if ( now > Long . MAX_VALUE - timeToLiveMillis ) { return - 1 ; MST[rv.CRCR4Mutator]MSP[] }
@Override public long expirationTime ( final K key , final V value ) { if ( timeToLiveMillis >= 0L ) { final long now = System . currentTimeMillis () ; if ( now > Long . MAX_VALUE - timeToLiveMillis ) { return - 1 ; MST[rv.CRCR6Mutator]MSP[] }
return now + timeToLiveMillis ; } return - 1L ; MST[InlineConstantMutator]MSP[] } private static long validateAndConvertToMillis ( final long timeToLive , final TimeUnit timeUnit ) { Objects . requireNonNull ( timeUnit , lr_1 ) ; return TimeUnit . MILLISECONDS . convert ( timeToLive , timeUnit ) ; } @Override
@Override public long expirationTime ( final K key , final V value ) { if ( timeToLiveMillis >= 0L ) { final long now = System . currentTimeMillis () ; if ( now > Long . MAX_VALUE - timeToLiveMillis ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] return - 1 ; }
@Override public long expirationTime ( final K key , final V value ) { if ( timeToLiveMillis >= 0L ) { final long now = System . currentTimeMillis () ; if ( now > Long . MAX_VALUE - timeToLiveMillis ) { return - 1 ; MST[rv.CRCR2Mutator]MSP[] }
@Override public long expirationTime ( final K key , final V value ) { if ( timeToLiveMillis >= 0L ) { final long now = System . currentTimeMillis () ; if ( now > Long . MAX_VALUE - timeToLiveMillis ) { MST[rv.CRCR2Mutator]MSP[] return - 1 ; }
@Override public long expirationTime ( final K key , final V value ) { if ( timeToLiveMillis >= 0L ) { final long now = System . currentTimeMillis () ; if ( now > Long . MAX_VALUE - timeToLiveMillis ) { MST[rv.CRCR6Mutator]MSP[] return - 1 ; }
@Override public long expirationTime ( final K key , final V value ) { if ( timeToLiveMillis >= 0L ) { MST[rv.UOI1Mutator]MSP[] final long now = System . currentTimeMillis () ; if ( now > Long . MAX_VALUE - timeToLiveMillis ) { return - 1 ; }
@Override public long expirationTime ( final K key , final V value ) { if ( timeToLiveMillis >= 0L ) { final long now = System . currentTimeMillis () ; if ( now > Long . MAX_VALUE - timeToLiveMillis ) { MST[rv.UOI3Mutator]MSP[] return - 1 ; }
@Override public long expirationTime ( final K key , final V value ) { if ( timeToLiveMillis >= 0L ) { MST[NegateConditionalsMutator]MSP[] final long now = System . currentTimeMillis () ; if ( now > Long . MAX_VALUE - timeToLiveMillis ) { return - 1 ; }
@Override public long expirationTime ( final K key , final V value ) { if ( timeToLiveMillis >= 0L ) { final long now = System . currentTimeMillis () ; if ( now > Long . MAX_VALUE - timeToLiveMillis ) { MST[rv.UOI4Mutator]MSP[] return - 1 ; }
@Override public long expirationTime ( final K key , final V value ) { if ( timeToLiveMillis >= 0L ) { final long now = System . currentTimeMillis () ; if ( now > Long . MAX_VALUE - timeToLiveMillis ) { MST[InlineConstantMutator]MSP[] return - 1 ; }
return now + timeToLiveMillis ; } return - 1L ; MST[rv.CRCR2Mutator]MSP[] } private static long validateAndConvertToMillis ( final long timeToLive , final TimeUnit timeUnit ) { Objects . requireNonNull ( timeUnit , lr_1 ) ; return TimeUnit . MILLISECONDS . convert ( timeToLive , timeUnit ) ; } @Override
@Override public long expirationTime ( final K key , final V value ) { if ( timeToLiveMillis >= 0L ) { final long now = System . currentTimeMillis () ; if ( now > Long . MAX_VALUE - timeToLiveMillis ) { MST[ConditionalsBoundaryMutator]MSP[] return - 1 ; }
@Override public long expirationTime ( final K key , final V value ) { if ( timeToLiveMillis >= 0L ) { MST[rv.UOI2Mutator]MSP[] final long now = System . currentTimeMillis () ; if ( now > Long . MAX_VALUE - timeToLiveMillis ) { return - 1 ; }
return now + timeToLiveMillis ; MST[rv.AOD2Mutator]MSP[] } return - 1L ; } private static long validateAndConvertToMillis ( final long timeToLive , final TimeUnit timeUnit ) { Objects . requireNonNull ( timeUnit , lr_1 ) ; return TimeUnit . MILLISECONDS . convert ( timeToLive , timeUnit ) ; } @Override
return now + timeToLiveMillis ; } return - 1L ; MST[rv.CRCR6Mutator]MSP[] } private static long validateAndConvertToMillis ( final long timeToLive , final TimeUnit timeUnit ) { Objects . requireNonNull ( timeUnit , lr_1 ) ; return TimeUnit . MILLISECONDS . convert ( timeToLive , timeUnit ) ; } @Override
@Override public long expirationTime ( final K key , final V value ) { if ( timeToLiveMillis >= 0L ) { final long now = System . currentTimeMillis () ; if ( now > Long . MAX_VALUE - timeToLiveMillis ) { return - 1 ; MST[PrimitiveReturnsMutator]MSP[] }
return now + timeToLiveMillis ; MST[rv.UOI2Mutator]MSP[] } return - 1L ; } private static long validateAndConvertToMillis ( final long timeToLive , final TimeUnit timeUnit ) { Objects . requireNonNull ( timeUnit , lr_1 ) ; return TimeUnit . MILLISECONDS . convert ( timeToLive , timeUnit ) ; } @Override
return now + timeToLiveMillis ; MST[rv.AOD1Mutator]MSP[] } return - 1L ; } private static long validateAndConvertToMillis ( final long timeToLive , final TimeUnit timeUnit ) { Objects . requireNonNull ( timeUnit , lr_1 ) ; return TimeUnit . MILLISECONDS . convert ( timeToLive , timeUnit ) ; } @Override
@Override public long expirationTime ( final K key , final V value ) { if ( timeToLiveMillis >= 0L ) { final long now = System . currentTimeMillis () ; if ( now > Long . MAX_VALUE - timeToLiveMillis ) { MST[rv.AOR2Mutator]MSP[] return - 1 ; }
@Override public long expirationTime ( final K key , final V value ) { if ( timeToLiveMillis >= 0L ) { final long now = System . currentTimeMillis () ; if ( now > Long . MAX_VALUE - timeToLiveMillis ) { MST[rv.ABSMutator]MSP[] return - 1 ; }
return now + timeToLiveMillis ; MST[rv.UOI4Mutator]MSP[] } return - 1L ; } private static long validateAndConvertToMillis ( final long timeToLive , final TimeUnit timeUnit ) { Objects . requireNonNull ( timeUnit , lr_1 ) ; return TimeUnit . MILLISECONDS . convert ( timeToLive , timeUnit ) ; } @Override
return now + timeToLiveMillis ; MST[rv.UOI3Mutator]MSP[] } return - 1L ; } private static long validateAndConvertToMillis ( final long timeToLive , final TimeUnit timeUnit ) { Objects . requireNonNull ( timeUnit , lr_1 ) ; return TimeUnit . MILLISECONDS . convert ( timeToLive , timeUnit ) ; } @Override
@Override public long expirationTime ( final K key , final V value ) { if ( timeToLiveMillis >= 0L ) { final long now = System . currentTimeMillis () ; if ( now > Long . MAX_VALUE - timeToLiveMillis ) { MST[rv.AOR1Mutator]MSP[] return - 1 ; }
@Override public long expirationTime ( final K key , final V value ) { if ( timeToLiveMillis >= 0L ) { final long now = System . currentTimeMillis () ; if ( now > Long . MAX_VALUE - timeToLiveMillis ) { MST[rv.ROR3Mutator]MSP[] return - 1 ; }
return now + timeToLiveMillis ; MST[rv.UOI1Mutator]MSP[] } return - 1L ; } private static long validateAndConvertToMillis ( final long timeToLive , final TimeUnit timeUnit ) { Objects . requireNonNull ( timeUnit , lr_1 ) ; return TimeUnit . MILLISECONDS . convert ( timeToLive , timeUnit ) ; } @Override
return now + timeToLiveMillis ; MST[PrimitiveReturnsMutator]MSP[] } return - 1L ; } private static long validateAndConvertToMillis ( final long timeToLive , final TimeUnit timeUnit ) { Objects . requireNonNull ( timeUnit , lr_1 ) ; return TimeUnit . MILLISECONDS . convert ( timeToLive , timeUnit ) ; } @Override
@Override public long expirationTime ( final K key , final V value ) { if ( timeToLiveMillis >= 0L ) { final long now = System . currentTimeMillis () ; if ( now > Long . MAX_VALUE - timeToLiveMillis ) { MST[rv.ROR4Mutator]MSP[] return - 1 ; }
@Override public long expirationTime ( final K key , final V value ) { if ( timeToLiveMillis >= 0L ) { final long now = System . currentTimeMillis () ; if ( now > Long . MAX_VALUE - timeToLiveMillis ) { MST[rv.CRCR3Mutator]MSP[] return - 1 ; }
@Override public long expirationTime ( final K key , final V value ) { if ( timeToLiveMillis >= 0L ) { MST[rv.CRCR1Mutator]MSP[] final long now = System . currentTimeMillis () ; if ( now > Long . MAX_VALUE - timeToLiveMillis ) { return - 1 ; }
@Override public long expirationTime ( final K key , final V value ) { if ( timeToLiveMillis >= 0L ) { final long now = System . currentTimeMillis () ; if ( now > Long . MAX_VALUE - timeToLiveMillis ) { MST[rv.AOD2Mutator]MSP[] return - 1 ; }
@Override public long expirationTime ( final K key , final V value ) { if ( timeToLiveMillis >= 0L ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[] final long now = System . currentTimeMillis () ; if ( now > Long . MAX_VALUE - timeToLiveMillis ) { return - 1 ; }
@Override public long expirationTime ( final K key , final V value ) { if ( timeToLiveMillis >= 0L ) { MST[rv.CRCR5Mutator]MSP[] final long now = System . currentTimeMillis () ; if ( now > Long . MAX_VALUE - timeToLiveMillis ) { return - 1 ; }
@Override public long expirationTime ( final K key , final V value ) { if ( timeToLiveMillis >= 0L ) { MST[ConditionalsBoundaryMutator]MSP[] final long now = System . currentTimeMillis () ; if ( now > Long . MAX_VALUE - timeToLiveMillis ) { return - 1 ; }
@Override public long expirationTime ( final K key , final V value ) { if ( timeToLiveMillis >= 0L ) { final long now = System . currentTimeMillis () ; if ( now > Long . MAX_VALUE - timeToLiveMillis ) { return - 1 ; MST[InlineConstantMutator]MSP[] }
if ( isExpired ( now , expirationEntry . getValue () ) ) { MST[rv.UOI3Mutator]MSP[] super . remove ( expirationEntry . getKey () ) ; iter . remove () ; } } } private void removeIfExpired ( final Object key , final long now ) {
removeIfExpired ( key , now () ) ; final long expirationTime = expiringPolicy . expirationTime ( key , value ) ; expirationMap . put ( key , Long . valueOf ( expirationTime ) ) ; return super . put ( key , value ) ; MST[ArgumentPropagationMutator]MSP[] } @Override
} @Override public V get ( final Object key ) { removeIfExpired ( key , now () ) ; return super . get ( key ) ; } @Override public boolean isEmpty () { removeAllExpired ( now () ) ; return super . isEmpty () ; MST[BooleanFalseReturnValsMutator]MSP[] }
private boolean isExpired ( final long now , final Long expirationTimeObject ) { if ( expirationTimeObject != null ) { final long expirationTime = expirationTimeObject . longValue () ; return expirationTime >= 0 && now >= expirationTime ; MST[ConditionalsBoundaryMutator]MSP[] } return false ; } @Override
private boolean isExpired ( final long now , final Long expirationTimeObject ) { if ( expirationTimeObject != null ) { final long expirationTime = expirationTimeObject . longValue () ; return expirationTime >= 0 && now >= expirationTime ; MST[InlineConstantMutator]MSP[] } return false ; } @Override
private boolean isExpired ( final long now , final Long expirationTimeObject ) { if ( expirationTimeObject != null ) { final long expirationTime = expirationTimeObject . longValue () ; return expirationTime >= 0 && now >= expirationTime ; MST[rv.ROR5Mutator]MSP[] } return false ; } @Override
final Iterator < Map . Entry < Object , Long > > iter = expirationMap . entrySet () . iterator () ; while ( iter . hasNext () ) { MST[NonVoidMethodCallMutator]MSP[] final Map . Entry < Object , Long > expirationEntry = iter . next () ;
if ( isExpired ( now , expirationEntry . getValue () ) ) { MST[rv.UOI1Mutator]MSP[] super . remove ( expirationEntry . getKey () ) ; iter . remove () ; } } } private void removeIfExpired ( final Object key , final long now ) {
private boolean isExpired ( final long now , final Long expirationTimeObject ) { if ( expirationTimeObject != null ) { final long expirationTime = expirationTimeObject . longValue () ; return expirationTime >= 0 && now >= expirationTime ; } return false ; MST[rv.CRCR6Mutator]MSP[] } @Override
public Set < K > keySet () { removeAllExpired ( now () ) ; return super . keySet () ; } private long now () { return System . currentTimeMillis () ; MST[PrimitiveReturnsMutator]MSP[] } @Override public V put ( final K key , final V value ) {
private boolean isExpired ( final long now , final Long expirationTimeObject ) { if ( expirationTimeObject != null ) { final long expirationTime = expirationTimeObject . longValue () ; return expirationTime >= 0 && now >= expirationTime ; MST[rv.ROR1Mutator]MSP[] } return false ; } @Override
private boolean isExpired ( final long now , final Long expirationTimeObject ) { if ( expirationTimeObject != null ) { final long expirationTime = expirationTimeObject . longValue () ; return expirationTime >= 0 && now >= expirationTime ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] } return false ; } @Override
private boolean isExpired ( final long now , final Long expirationTimeObject ) { if ( expirationTimeObject != null ) { final long expirationTime = expirationTimeObject . longValue () ; return expirationTime >= 0 && now >= expirationTime ; MST[rv.ROR3Mutator]MSP[] } return false ; } @Override
return now + timeToLiveMillis ; } return - 1L ; } private static long validateAndConvertToMillis ( final long timeToLive , final TimeUnit timeUnit ) { Objects . requireNonNull ( timeUnit , lr_1 ) ; return TimeUnit . MILLISECONDS . convert ( timeToLive , timeUnit ) ; MST[rv.ABSMutator]MSP[] } @Override
} @Override public V get ( final Object key ) { removeIfExpired ( key , now () ) ; MST[VoidMethodCallMutator]MSP[] return super . get ( key ) ; } @Override public boolean isEmpty () { removeAllExpired ( now () ) ; return super . isEmpty () ; }
public Set < K > keySet () { removeAllExpired ( now () ) ; return super . keySet () ; MST[ReturnValsMutator]MSP[] } private long now () { return System . currentTimeMillis () ; } @Override public V put ( final K key , final V value ) {
return now + timeToLiveMillis ; } return - 1L ; } private static long validateAndConvertToMillis ( final long timeToLive , final TimeUnit timeUnit ) { Objects . requireNonNull ( timeUnit , lr_1 ) ; return TimeUnit . MILLISECONDS . convert ( timeToLive , timeUnit ) ; MST[NonVoidMethodCallMutator]MSP[] } @Override
final Long expirationTimeObject = expirationMap . get ( key ) ; if ( isExpired ( now , expirationTimeObject ) ) { MST[rv.UOI4Mutator]MSP[] remove ( key ) ; } } @Override public int size () { removeAllExpired ( now () ) ; return super . size () ; }
} @Override public V get ( final Object key ) { removeIfExpired ( key , now () ) ; return super . get ( key ) ; } @Override public boolean isEmpty () { removeAllExpired ( now () ) ; MST[NonVoidMethodCallMutator]MSP[] return super . isEmpty () ; }
removeIfExpired ( key , now () ) ; final long expirationTime = expiringPolicy . expirationTime ( key , value ) ; expirationMap . put ( key , Long . valueOf ( expirationTime ) ) ; MST[rv.UOI3Mutator]MSP[] return super . put ( key , value ) ; } @Override
final Iterator < Map . Entry < Object , Long > > iter = expirationMap . entrySet () . iterator () ; MST[NonVoidMethodCallMutator]MSP[] while ( iter . hasNext () ) { final Map . Entry < Object , Long > expirationEntry = iter . next () ;
removeIfExpired ( key , now () ) ; final long expirationTime = expiringPolicy . expirationTime ( key , value ) ; expirationMap . put ( key , Long . valueOf ( expirationTime ) ) ; MST[ArgumentPropagationMutator]MSP[] return super . put ( key , value ) ; } @Override
public Set < K > keySet () { removeAllExpired ( now () ) ; return super . keySet () ; MST[EmptyObjectReturnValsMutator]MSP[] } private long now () { return System . currentTimeMillis () ; } @Override public V put ( final K key , final V value ) {
private boolean isExpired ( final long now , final Long expirationTimeObject ) { if ( expirationTimeObject != null ) { final long expirationTime = expirationTimeObject . longValue () ; return expirationTime >= 0 && now >= expirationTime ; MST[rv.UOI2Mutator]MSP[] } return false ; } @Override
if ( isExpired ( now , expirationEntry . getValue () ) ) { MST[rv.ROR5Mutator]MSP[] super . remove ( expirationEntry . getKey () ) ; iter . remove () ; } } } private void removeIfExpired ( final Object key , final long now ) {
out . defaultWriteObject () ; out . writeObject ( map ) ; } @Override public Collection < V > values () { removeAllExpired ( now () ) ; return super . values () ; MST[EmptyObjectReturnValsMutator]MSP[] }
public boolean containsValue ( final Object value ) { removeAllExpired ( now () ) ; return super . containsValue ( value ) ; MST[NonVoidMethodCallMutator]MSP[] } @Override public Set < Entry < K , V > > entrySet () { removeAllExpired ( now () ) ; return super . entrySet () ;
private boolean isExpired ( final long now , final Long expirationTimeObject ) { if ( expirationTimeObject != null ) { final long expirationTime = expirationTimeObject . longValue () ; return expirationTime >= 0 && now >= expirationTime ; MST[rv.CRCR3Mutator]MSP[] } return false ; } @Override
} @Override public V get ( final Object key ) { removeIfExpired ( key , now () ) ; return super . get ( key ) ; MST[ArgumentPropagationMutator]MSP[] } @Override public boolean isEmpty () { removeAllExpired ( now () ) ; return super . isEmpty () ; }
private boolean isExpired ( final long now , final Long expirationTimeObject ) { if ( expirationTimeObject != null ) { final long expirationTime = expirationTimeObject . longValue () ; return expirationTime >= 0 && now >= expirationTime ; MST[rv.UOI3Mutator]MSP[] } return false ; } @Override
private boolean isExpired ( final long now , final Long expirationTimeObject ) { if ( expirationTimeObject != null ) { final long expirationTime = expirationTimeObject . longValue () ; return expirationTime >= 0 && now >= expirationTime ; MST[rv.CRCR6Mutator]MSP[] } return false ; } @Override
private boolean isExpired ( final long now , final Long expirationTimeObject ) { if ( expirationTimeObject != null ) { final long expirationTime = expirationTimeObject . longValue () ; return expirationTime >= 0 && now >= expirationTime ; MST[rv.ROR2Mutator]MSP[] } return false ; } @Override
return now + timeToLiveMillis ; } return - 1L ; } private static long validateAndConvertToMillis ( final long timeToLive , final TimeUnit timeUnit ) { Objects . requireNonNull ( timeUnit , lr_1 ) ; MST[NonVoidMethodCallMutator]MSP[] return TimeUnit . MILLISECONDS . convert ( timeToLive , timeUnit ) ; } @Override
if ( isExpired ( now , expirationEntry . getValue () ) ) { MST[rv.ROR1Mutator]MSP[] super . remove ( expirationEntry . getKey () ) ; iter . remove () ; } } } private void removeIfExpired ( final Object key , final long now ) {
final Long expirationTimeObject = expirationMap . get ( key ) ; if ( isExpired ( now , expirationTimeObject ) ) { MST[NonVoidMethodCallMutator]MSP[] remove ( key ) ; } } @Override public int size () { removeAllExpired ( now () ) ; return super . size () ; }
return now + timeToLiveMillis ; } return - 1L ; } private static long validateAndConvertToMillis ( final long timeToLive , final TimeUnit timeUnit ) { Objects . requireNonNull ( timeUnit , lr_1 ) ; return TimeUnit . MILLISECONDS . convert ( timeToLive , timeUnit ) ; MST[rv.UOI4Mutator]MSP[] } @Override
private boolean isExpired ( final long now , final Long expirationTimeObject ) { if ( expirationTimeObject != null ) { final long expirationTime = expirationTimeObject . longValue () ; return expirationTime >= 0 && now >= expirationTime ; MST[BooleanTrueReturnValsMutator]MSP[] } return false ; } @Override
final Long expirationTimeObject = expirationMap . get ( key ) ; MST[NonVoidMethodCallMutator]MSP[] if ( isExpired ( now , expirationTimeObject ) ) { remove ( key ) ; } } @Override public int size () { removeAllExpired ( now () ) ; return super . size () ; }
final Iterator < Map . Entry < Object , Long > > iter = expirationMap . entrySet () . iterator () ; while ( iter . hasNext () ) { MST[rv.ROR5Mutator]MSP[] final Map . Entry < Object , Long > expirationEntry = iter . next () ;
return now + timeToLiveMillis ; } return - 1L ; } private static long validateAndConvertToMillis ( final long timeToLive , final TimeUnit timeUnit ) { Objects . requireNonNull ( timeUnit , lr_1 ) ; MST[ArgumentPropagationMutator]MSP[] return TimeUnit . MILLISECONDS . convert ( timeToLive , timeUnit ) ; } @Override
public void clear () { super . clear () ; expirationMap . clear () ; } @Override public boolean containsKey ( final Object key ) { removeIfExpired ( key , now () ) ; return super . containsKey ( key ) ; MST[ReturnValsMutator]MSP[] } @Override
return now + timeToLiveMillis ; } return - 1L ; } private static long validateAndConvertToMillis ( final long timeToLive , final TimeUnit timeUnit ) { Objects . requireNonNull ( timeUnit , lr_1 ) ; return TimeUnit . MILLISECONDS . convert ( timeToLive , timeUnit ) ; MST[PrimitiveReturnsMutator]MSP[] } @Override
public boolean containsValue ( final Object value ) { removeAllExpired ( now () ) ; return super . containsValue ( value ) ; } @Override public Set < Entry < K , V > > entrySet () { removeAllExpired ( now () ) ; return super . entrySet () ; MST[NonVoidMethodCallMutator]MSP[]
private boolean isExpired ( final long now , final Long expirationTimeObject ) { if ( expirationTimeObject != null ) { final long expirationTime = expirationTimeObject . longValue () ; return expirationTime >= 0 && now >= expirationTime ; MST[rv.UOI3Mutator]MSP[] } return false ; } @Override
final Iterator < Map . Entry < Object , Long > > iter = expirationMap . entrySet () . iterator () ; while ( iter . hasNext () ) { MST[rv.ROR2Mutator]MSP[] final Map . Entry < Object , Long > expirationEntry = iter . next () ;
if ( isExpired ( now , expirationEntry . getValue () ) ) { MST[NegateConditionalsMutator]MSP[] super . remove ( expirationEntry . getKey () ) ; iter . remove () ; } } } private void removeIfExpired ( final Object key , final long now ) {
private boolean isExpired ( final long now , final Long expirationTimeObject ) { if ( expirationTimeObject != null ) { final long expirationTime = expirationTimeObject . longValue () ; return expirationTime >= 0 && now >= expirationTime ; MST[rv.ABSMutator]MSP[] } return false ; } @Override
public boolean containsValue ( final Object value ) { removeAllExpired ( now () ) ; return super . containsValue ( value ) ; } @Override public Set < Entry < K , V > > entrySet () { removeAllExpired ( now () ) ; return super . entrySet () ; MST[EmptyObjectReturnValsMutator]MSP[]
private boolean isExpired ( final long now , final Long expirationTimeObject ) { if ( expirationTimeObject != null ) { final long expirationTime = expirationTimeObject . longValue () ; return expirationTime >= 0 && now >= expirationTime ; MST[rv.CRCR3Mutator]MSP[] } return false ; } @Override
if ( isExpired ( now , expirationEntry . getValue () ) ) { MST[NonVoidMethodCallMutator]MSP[] super . remove ( expirationEntry . getKey () ) ; iter . remove () ; } } } private void removeIfExpired ( final Object key , final long now ) {
private boolean isExpired ( final long now , final Long expirationTimeObject ) { if ( expirationTimeObject != null ) { final long expirationTime = expirationTimeObject . longValue () ; return expirationTime >= 0 && now >= expirationTime ; MST[rv.CRCR5Mutator]MSP[] } return false ; } @Override
private boolean isExpired ( final long now , final Long expirationTimeObject ) { if ( expirationTimeObject != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] final long expirationTime = expirationTimeObject . longValue () ; return expirationTime >= 0 && now >= expirationTime ; } return false ; } @Override
final Long expirationTimeObject = expirationMap . get ( key ) ; if ( isExpired ( now , expirationTimeObject ) ) { MST[rv.ROR1Mutator]MSP[] remove ( key ) ; } } @Override public int size () { removeAllExpired ( now () ) ; return super . size () ; }
public Set < K > keySet () { removeAllExpired ( now () ) ; return super . keySet () ; } private long now () { return System . currentTimeMillis () ; MST[NonVoidMethodCallMutator]MSP[] } @Override public V put ( final K key , final V value ) {
final Long expirationTimeObject = expirationMap . get ( key ) ; if ( isExpired ( now , expirationTimeObject ) ) { remove ( key ) ; } } @Override public int size () { removeAllExpired ( now () ) ; MST[VoidMethodCallMutator]MSP[] return super . size () ; }
private boolean isExpired ( final long now , final Long expirationTimeObject ) { if ( expirationTimeObject != null ) { final long expirationTime = expirationTimeObject . longValue () ; return expirationTime >= 0 && now >= expirationTime ; MST[RemoveConditionalMutator_ORDER_IF]MSP[] } return false ; } @Override
final Long expirationTimeObject = expirationMap . get ( key ) ; if ( isExpired ( now , expirationTimeObject ) ) { MST[rv.UOI1Mutator]MSP[] remove ( key ) ; } } @Override public int size () { removeAllExpired ( now () ) ; return super . size () ; }
private boolean isExpired ( final long now , final Long expirationTimeObject ) { if ( expirationTimeObject != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] final long expirationTime = expirationTimeObject . longValue () ; return expirationTime >= 0 && now >= expirationTime ; } return false ; } @Override
private boolean isExpired ( final long now , final Long expirationTimeObject ) { if ( expirationTimeObject != null ) { final long expirationTime = expirationTimeObject . longValue () ; return expirationTime >= 0 && now >= expirationTime ; MST[rv.UOI4Mutator]MSP[] } return false ; } @Override
public Set < K > keySet () { removeAllExpired ( now () ) ; MST[VoidMethodCallMutator]MSP[] return super . keySet () ; } private long now () { return System . currentTimeMillis () ; } @Override public V put ( final K key , final V value ) {
public void clear () { super . clear () ; MST[VoidMethodCallMutator]MSP[] expirationMap . clear () ; } @Override public boolean containsKey ( final Object key ) { removeIfExpired ( key , now () ) ; return super . containsKey ( key ) ; } @Override
final Long expirationTimeObject = expirationMap . get ( key ) ; if ( isExpired ( now , expirationTimeObject ) ) { remove ( key ) ; } } @Override public int size () { removeAllExpired ( now () ) ; return super . size () ; MST[ReturnValsMutator]MSP[] }
private boolean isExpired ( final long now , final Long expirationTimeObject ) { if ( expirationTimeObject != null ) { final long expirationTime = expirationTimeObject . longValue () ; return expirationTime >= 0 && now >= expirationTime ; MST[rv.CRCR2Mutator]MSP[] } return false ; } @Override
put ( entry . getKey () , entry . getValue () ) ; } } @Override public V remove ( final Object key ) { expirationMap . remove ( key ) ; return super . remove ( key ) ; MST[NonVoidMethodCallMutator]MSP[] } private void removeAllExpired ( final long now ) {
private boolean isExpired ( final long now , final Long expirationTimeObject ) { if ( expirationTimeObject != null ) { final long expirationTime = expirationTimeObject . longValue () ; return expirationTime >= 0 && now >= expirationTime ; MST[NegateConditionalsMutator]MSP[] } return false ; } @Override
public boolean containsValue ( final Object value ) { removeAllExpired ( now () ) ; return super . containsValue ( value ) ; MST[BooleanFalseReturnValsMutator]MSP[] } @Override public Set < Entry < K , V > > entrySet () { removeAllExpired ( now () ) ; return super . entrySet () ;
private boolean isExpired ( final long now , final Long expirationTimeObject ) { if ( expirationTimeObject != null ) { final long expirationTime = expirationTimeObject . longValue () ; return expirationTime >= 0 && now >= expirationTime ; MST[rv.CRCR6Mutator]MSP[] } return false ; } @Override
if ( isExpired ( now , expirationEntry . getValue () ) ) { MST[rv.ROR2Mutator]MSP[] super . remove ( expirationEntry . getKey () ) ; iter . remove () ; } } } private void removeIfExpired ( final Object key , final long now ) {
private boolean isExpired ( final long now , final Long expirationTimeObject ) { if ( expirationTimeObject != null ) { final long expirationTime = expirationTimeObject . longValue () ; return expirationTime >= 0 && now >= expirationTime ; MST[rv.UOI1Mutator]MSP[] } return false ; } @Override
private boolean isExpired ( final long now , final Long expirationTimeObject ) { if ( expirationTimeObject != null ) { final long expirationTime = expirationTimeObject . longValue () ; return expirationTime >= 0 && now >= expirationTime ; MST[rv.CRCR1Mutator]MSP[] } return false ; } @Override
private boolean isExpired ( final long now , final Long expirationTimeObject ) { if ( expirationTimeObject != null ) { final long expirationTime = expirationTimeObject . longValue () ; return expirationTime >= 0 && now >= expirationTime ; } return false ; MST[InlineConstantMutator]MSP[] } @Override
public void clear () { super . clear () ; expirationMap . clear () ; } @Override public boolean containsKey ( final Object key ) { removeIfExpired ( key , now () ) ; MST[VoidMethodCallMutator]MSP[] return super . containsKey ( key ) ; } @Override
if ( isExpired ( now , expirationEntry . getValue () ) ) { MST[rv.ABSMutator]MSP[] super . remove ( expirationEntry . getKey () ) ; iter . remove () ; } } } private void removeIfExpired ( final Object key , final long now ) {
public Set < K > keySet () { removeAllExpired ( now () ) ; MST[NonVoidMethodCallMutator]MSP[] return super . keySet () ; } private long now () { return System . currentTimeMillis () ; } @Override public V put ( final K key , final V value ) {
} @Override public V get ( final Object key ) { removeIfExpired ( key , now () ) ; return super . get ( key ) ; MST[ReturnValsMutator]MSP[] } @Override public boolean isEmpty () { removeAllExpired ( now () ) ; return super . isEmpty () ; }
} @Override public V get ( final Object key ) { removeIfExpired ( key , now () ) ; return super . get ( key ) ; } @Override public boolean isEmpty () { removeAllExpired ( now () ) ; MST[VoidMethodCallMutator]MSP[] return super . isEmpty () ; }
private boolean isExpired ( final long now , final Long expirationTimeObject ) { if ( expirationTimeObject != null ) { final long expirationTime = expirationTimeObject . longValue () ; return expirationTime >= 0 && now >= expirationTime ; MST[rv.CRCR5Mutator]MSP[] } return false ; } @Override
private boolean isExpired ( final long now , final Long expirationTimeObject ) { if ( expirationTimeObject != null ) { final long expirationTime = expirationTimeObject . longValue () ; return expirationTime >= 0 && now >= expirationTime ; MST[rv.ROR4Mutator]MSP[] } return false ; } @Override
return now + timeToLiveMillis ; } return - 1L ; } private static long validateAndConvertToMillis ( final long timeToLive , final TimeUnit timeUnit ) { Objects . requireNonNull ( timeUnit , lr_1 ) ; return TimeUnit . MILLISECONDS . convert ( timeToLive , timeUnit ) ; MST[rv.UOI2Mutator]MSP[] } @Override
private boolean isExpired ( final long now , final Long expirationTimeObject ) { if ( expirationTimeObject != null ) { final long expirationTime = expirationTimeObject . longValue () ; MST[NonVoidMethodCallMutator]MSP[] return expirationTime >= 0 && now >= expirationTime ; } return false ; } @Override
out . defaultWriteObject () ; out . writeObject ( map ) ; } @Override public Collection < V > values () { removeAllExpired ( now () ) ; return super . values () ; MST[NonVoidMethodCallMutator]MSP[] }
public void clear () { super . clear () ; expirationMap . clear () ; } @Override public boolean containsKey ( final Object key ) { removeIfExpired ( key , now () ) ; return super . containsKey ( key ) ; MST[BooleanTrueReturnValsMutator]MSP[] } @Override
} @Override public V get ( final Object key ) { removeIfExpired ( key , now () ) ; MST[NonVoidMethodCallMutator]MSP[] return super . get ( key ) ; } @Override public boolean isEmpty () { removeAllExpired ( now () ) ; return super . isEmpty () ; }
} @Override public V get ( final Object key ) { removeIfExpired ( key , now () ) ; return super . get ( key ) ; } @Override public boolean isEmpty () { removeAllExpired ( now () ) ; return super . isEmpty () ; MST[BooleanTrueReturnValsMutator]MSP[] }
final Long expirationTimeObject = expirationMap . get ( key ) ; if ( isExpired ( now , expirationTimeObject ) ) { MST[rv.ROR4Mutator]MSP[] remove ( key ) ; } } @Override public int size () { removeAllExpired ( now () ) ; return super . size () ; }
final Long expirationTimeObject = expirationMap . get ( key ) ; if ( isExpired ( now , expirationTimeObject ) ) { remove ( key ) ; } } @Override public int size () { removeAllExpired ( now () ) ; MST[NonVoidMethodCallMutator]MSP[] return super . size () ; }
final Long expirationTimeObject = expirationMap . get ( key ) ; if ( isExpired ( now , expirationTimeObject ) ) { MST[NegateConditionalsMutator]MSP[] remove ( key ) ; } } @Override public int size () { removeAllExpired ( now () ) ; return super . size () ; }
final Long expirationTimeObject = expirationMap . get ( key ) ; if ( isExpired ( now , expirationTimeObject ) ) { MST[rv.ABSMutator]MSP[] remove ( key ) ; } } @Override public int size () { removeAllExpired ( now () ) ; return super . size () ; }
if ( isExpired ( now , expirationEntry . getValue () ) ) { MST[rv.UOI4Mutator]MSP[] super . remove ( expirationEntry . getKey () ) ; iter . remove () ; } } } private void removeIfExpired ( final Object key , final long now ) {
private boolean isExpired ( final long now , final Long expirationTimeObject ) { if ( expirationTimeObject != null ) { final long expirationTime = expirationTimeObject . longValue () ; return expirationTime >= 0 && now >= expirationTime ; } return false ; MST[ReturnValsMutator]MSP[] } @Override
public boolean containsValue ( final Object value ) { removeAllExpired ( now () ) ; return super . containsValue ( value ) ; } @Override public Set < Entry < K , V > > entrySet () { removeAllExpired ( now () ) ; return super . entrySet () ; MST[ReturnValsMutator]MSP[]
if ( isExpired ( now , expirationEntry . getValue () ) ) { MST[rv.UOI2Mutator]MSP[] super . remove ( expirationEntry . getKey () ) ; iter . remove () ; } } } private void removeIfExpired ( final Object key , final long now ) {
if ( isExpired ( now , expirationEntry . getValue () ) ) { super . remove ( expirationEntry . getKey () ) ; iter . remove () ; MST[VoidMethodCallMutator]MSP[] } } } private void removeIfExpired ( final Object key , final long now ) {
public void clear () { super . clear () ; expirationMap . clear () ; MST[VoidMethodCallMutator]MSP[] } @Override public boolean containsKey ( final Object key ) { removeIfExpired ( key , now () ) ; return super . containsKey ( key ) ; } @Override
private boolean isExpired ( final long now , final Long expirationTimeObject ) { if ( expirationTimeObject != null ) { final long expirationTime = expirationTimeObject . longValue () ; return expirationTime >= 0 && now >= expirationTime ; } return false ; MST[BooleanTrueReturnValsMutator]MSP[] } @Override
public boolean containsValue ( final Object value ) { removeAllExpired ( now () ) ; return super . containsValue ( value ) ; } @Override public Set < Entry < K , V > > entrySet () { removeAllExpired ( now () ) ; MST[VoidMethodCallMutator]MSP[] return super . entrySet () ;
private boolean isExpired ( final long now , final Long expirationTimeObject ) { if ( expirationTimeObject != null ) { final long expirationTime = expirationTimeObject . longValue () ; return expirationTime >= 0 && now >= expirationTime ; MST[ConditionalsBoundaryMutator]MSP[] } return false ; } @Override
private boolean isExpired ( final long now , final Long expirationTimeObject ) { if ( expirationTimeObject != null ) { final long expirationTime = expirationTimeObject . longValue () ; return expirationTime >= 0 && now >= expirationTime ; } return false ; MST[rv.CRCR3Mutator]MSP[] } @Override
private boolean isExpired ( final long now , final Long expirationTimeObject ) { if ( expirationTimeObject != null ) { final long expirationTime = expirationTimeObject . longValue () ; return expirationTime >= 0 && now >= expirationTime ; } return false ; MST[rv.CRCR5Mutator]MSP[] } @Override
public Set < K > keySet () { removeAllExpired ( now () ) ; return super . keySet () ; } private long now () { return System . currentTimeMillis () ; MST[ReturnValsMutator]MSP[] } @Override public V put ( final K key , final V value ) {
private boolean isExpired ( final long now , final Long expirationTimeObject ) { if ( expirationTimeObject != null ) { final long expirationTime = expirationTimeObject . longValue () ; return expirationTime >= 0 && now >= expirationTime ; } return false ; MST[rv.CRCR1Mutator]MSP[] } @Override
private boolean isExpired ( final long now , final Long expirationTimeObject ) { if ( expirationTimeObject != null ) { final long expirationTime = expirationTimeObject . longValue () ; return expirationTime >= 0 && now >= expirationTime ; MST[rv.ROR1Mutator]MSP[] } return false ; } @Override
removeIfExpired ( key , now () ) ; final long expirationTime = expiringPolicy . expirationTime ( key , value ) ; expirationMap . put ( key , Long . valueOf ( expirationTime ) ) ; return super . put ( key , value ) ; MST[NullReturnValsMutator]MSP[] } @Override
public boolean containsValue ( final Object value ) { removeAllExpired ( now () ) ; MST[VoidMethodCallMutator]MSP[] return super . containsValue ( value ) ; } @Override public Set < Entry < K , V > > entrySet () { removeAllExpired ( now () ) ; return super . entrySet () ;
} @Override public V get ( final Object key ) { removeIfExpired ( key , now () ) ; return super . get ( key ) ; MST[NullReturnValsMutator]MSP[] } @Override public boolean isEmpty () { removeAllExpired ( now () ) ; return super . isEmpty () ; }
final Long expirationTimeObject = expirationMap . get ( key ) ; if ( isExpired ( now , expirationTimeObject ) ) { remove ( key ) ; } } @Override public int size () { removeAllExpired ( now () ) ; return super . size () ; MST[NonVoidMethodCallMutator]MSP[] }
put ( entry . getKey () , entry . getValue () ) ; MST[NonVoidMethodCallMutator]MSP[] } } @Override public V remove ( final Object key ) { expirationMap . remove ( key ) ; return super . remove ( key ) ; } private void removeAllExpired ( final long now ) {
if ( isExpired ( now , expirationEntry . getValue () ) ) { super . remove ( expirationEntry . getKey () ) ; MST[NonVoidMethodCallMutator]MSP[] iter . remove () ; } } } private void removeIfExpired ( final Object key , final long now ) {
public boolean containsValue ( final Object value ) { removeAllExpired ( now () ) ; return super . containsValue ( value ) ; MST[BooleanTrueReturnValsMutator]MSP[] } @Override public Set < Entry < K , V > > entrySet () { removeAllExpired ( now () ) ; return super . entrySet () ;
private boolean isExpired ( final long now , final Long expirationTimeObject ) { if ( expirationTimeObject != null ) { final long expirationTime = expirationTimeObject . longValue () ; return expirationTime >= 0 && now >= expirationTime ; MST[rv.ROR5Mutator]MSP[] } return false ; } @Override
private boolean isExpired ( final long now , final Long expirationTimeObject ) { if ( expirationTimeObject != null ) { final long expirationTime = expirationTimeObject . longValue () ; return expirationTime >= 0 && now >= expirationTime ; MST[rv.ROR3Mutator]MSP[] } return false ; } @Override
removeIfExpired ( key , now () ) ; final long expirationTime = expiringPolicy . expirationTime ( key , value ) ; expirationMap . put ( key , Long . valueOf ( expirationTime ) ) ; MST[NonVoidMethodCallMutator]MSP[] return super . put ( key , value ) ; } @Override
if ( isExpired ( now , expirationEntry . getValue () ) ) { MST[NonVoidMethodCallMutator]MSP[] super . remove ( expirationEntry . getKey () ) ; iter . remove () ; } } } private void removeIfExpired ( final Object key , final long now ) {
private boolean isExpired ( final long now , final Long expirationTimeObject ) { if ( expirationTimeObject != null ) { final long expirationTime = expirationTimeObject . longValue () ; return expirationTime >= 0 && now >= expirationTime ; MST[InlineConstantMutator]MSP[] } return false ; } @Override
private boolean isExpired ( final long now , final Long expirationTimeObject ) { if ( expirationTimeObject != null ) { final long expirationTime = expirationTimeObject . longValue () ; return expirationTime >= 0 && now >= expirationTime ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] } return false ; } @Override
return now + timeToLiveMillis ; } return - 1L ; } private static long validateAndConvertToMillis ( final long timeToLive , final TimeUnit timeUnit ) { Objects . requireNonNull ( timeUnit , lr_1 ) ; return TimeUnit . MILLISECONDS . convert ( timeToLive , timeUnit ) ; MST[ArgumentPropagationMutator]MSP[] } @Override
removeIfExpired ( key , now () ) ; final long expirationTime = expiringPolicy . expirationTime ( key , value ) ; expirationMap . put ( key , Long . valueOf ( expirationTime ) ) ; MST[rv.ABSMutator]MSP[] return super . put ( key , value ) ; } @Override
removeIfExpired ( key , now () ) ; final long expirationTime = expiringPolicy . expirationTime ( key , value ) ; expirationMap . put ( key , Long . valueOf ( expirationTime ) ) ; MST[rv.UOI2Mutator]MSP[] return super . put ( key , value ) ; } @Override
if ( isExpired ( now , expirationEntry . getValue () ) ) { super . remove ( expirationEntry . getKey () ) ; MST[ArgumentPropagationMutator]MSP[] iter . remove () ; } } } private void removeIfExpired ( final Object key , final long now ) {
final Long expirationTimeObject = expirationMap . get ( key ) ; if ( isExpired ( now , expirationTimeObject ) ) { MST[rv.UOI3Mutator]MSP[] remove ( key ) ; } } @Override public int size () { removeAllExpired ( now () ) ; return super . size () ; }
final Iterator < Map . Entry < Object , Long > > iter = expirationMap . entrySet () . iterator () ; while ( iter . hasNext () ) { MST[NegateConditionalsMutator]MSP[] final Map . Entry < Object , Long > expirationEntry = iter . next () ;
put ( entry . getKey () , entry . getValue () ) ; } } @Override public V remove ( final Object key ) { expirationMap . remove ( key ) ; MST[ArgumentPropagationMutator]MSP[] return super . remove ( key ) ; } private void removeAllExpired ( final long now ) {
if ( isExpired ( now , expirationEntry . getValue () ) ) { MST[rv.ROR4Mutator]MSP[] super . remove ( expirationEntry . getKey () ) ; iter . remove () ; } } } private void removeIfExpired ( final Object key , final long now ) {
private boolean isExpired ( final long now , final Long expirationTimeObject ) { if ( expirationTimeObject != null ) { final long expirationTime = expirationTimeObject . longValue () ; return expirationTime >= 0 && now >= expirationTime ; MST[rv.UOI3Mutator]MSP[] } return false ; } @Override
private boolean isExpired ( final long now , final Long expirationTimeObject ) { if ( expirationTimeObject != null ) { final long expirationTime = expirationTimeObject . longValue () ; return expirationTime >= 0 && now >= expirationTime ; MST[rv.UOI2Mutator]MSP[] } return false ; } @Override
private boolean isExpired ( final long now , final Long expirationTimeObject ) { if ( expirationTimeObject != null ) { final long expirationTime = expirationTimeObject . longValue () ; return expirationTime >= 0 && now >= expirationTime ; MST[rv.CRCR4Mutator]MSP[] } return false ; } @Override
private boolean isExpired ( final long now , final Long expirationTimeObject ) { if ( expirationTimeObject != null ) { final long expirationTime = expirationTimeObject . longValue () ; return expirationTime >= 0 && now >= expirationTime ; MST[rv.CRCR3Mutator]MSP[] } return false ; } @Override
out . defaultWriteObject () ; out . writeObject ( map ) ; } @Override public Collection < V > values () { removeAllExpired ( now () ) ; return super . values () ; MST[ReturnValsMutator]MSP[] }
private boolean isExpired ( final long now , final Long expirationTimeObject ) { if ( expirationTimeObject != null ) { MST[rv.ROR5Mutator]MSP[] final long expirationTime = expirationTimeObject . longValue () ; return expirationTime >= 0 && now >= expirationTime ; } return false ; } @Override
if ( isExpired ( now , expirationEntry . getValue () ) ) { super . remove ( expirationEntry . getKey () ) ; MST[NonVoidMethodCallMutator]MSP[] iter . remove () ; } } } private void removeIfExpired ( final Object key , final long now ) {
final Iterator < Map . Entry < Object , Long > > iter = expirationMap . entrySet () . iterator () ; while ( iter . hasNext () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] final Map . Entry < Object , Long > expirationEntry = iter . next () ;
public void clear () { super . clear () ; expirationMap . clear () ; } @Override public boolean containsKey ( final Object key ) { removeIfExpired ( key , now () ) ; MST[NonVoidMethodCallMutator]MSP[] return super . containsKey ( key ) ; } @Override
removeIfExpired ( key , now () ) ; final long expirationTime = expiringPolicy . expirationTime ( key , value ) ; expirationMap . put ( key , Long . valueOf ( expirationTime ) ) ; return super . put ( key , value ) ; MST[NonVoidMethodCallMutator]MSP[] } @Override
put ( entry . getKey () , entry . getValue () ) ; MST[NonVoidMethodCallMutator]MSP[] } } @Override public V remove ( final Object key ) { expirationMap . remove ( key ) ; return super . remove ( key ) ; } private void removeAllExpired ( final long now ) {
private boolean isExpired ( final long now , final Long expirationTimeObject ) { if ( expirationTimeObject != null ) { final long expirationTime = expirationTimeObject . longValue () ; return expirationTime >= 0 && now >= expirationTime ; MST[rv.ROR2Mutator]MSP[] } return false ; } @Override
final Long expirationTimeObject = expirationMap . get ( key ) ; MST[ArgumentPropagationMutator]MSP[] if ( isExpired ( now , expirationTimeObject ) ) { remove ( key ) ; } } @Override public int size () { removeAllExpired ( now () ) ; return super . size () ; }
} @Override public V get ( final Object key ) { removeIfExpired ( key , now () ) ; return super . get ( key ) ; } @Override public boolean isEmpty () { removeAllExpired ( now () ) ; return super . isEmpty () ; MST[ReturnValsMutator]MSP[] }
} @Override public V get ( final Object key ) { removeIfExpired ( key , now () ) ; return super . get ( key ) ; MST[NonVoidMethodCallMutator]MSP[] } @Override public boolean isEmpty () { removeAllExpired ( now () ) ; return super . isEmpty () ; }
removeIfExpired ( key , now () ) ; final long expirationTime = expiringPolicy . expirationTime ( key , value ) ; expirationMap . put ( key , Long . valueOf ( expirationTime ) ) ; MST[NonVoidMethodCallMutator]MSP[] return super . put ( key , value ) ; } @Override
private boolean isExpired ( final long now , final Long expirationTimeObject ) { if ( expirationTimeObject != null ) { final long expirationTime = expirationTimeObject . longValue () ; return expirationTime >= 0 && now >= expirationTime ; MST[InlineConstantMutator]MSP[] } return false ; } @Override
put ( entry . getKey () , entry . getValue () ) ; } } @Override public V remove ( final Object key ) { expirationMap . remove ( key ) ; return super . remove ( key ) ; MST[NullReturnValsMutator]MSP[] } private void removeAllExpired ( final long now ) {
removeIfExpired ( key , now () ) ; final long expirationTime = expiringPolicy . expirationTime ( key , value ) ; MST[NonVoidMethodCallMutator]MSP[] expirationMap . put ( key , Long . valueOf ( expirationTime ) ) ; return super . put ( key , value ) ; } @Override
final Long expirationTimeObject = expirationMap . get ( key ) ; if ( isExpired ( now , expirationTimeObject ) ) { MST[rv.ROR2Mutator]MSP[] remove ( key ) ; } } @Override public int size () { removeAllExpired ( now () ) ; return super . size () ; }
put ( entry . getKey () , entry . getValue () ) ; MST[ArgumentPropagationMutator]MSP[] } } @Override public V remove ( final Object key ) { expirationMap . remove ( key ) ; return super . remove ( key ) ; } private void removeAllExpired ( final long now ) {
removeIfExpired ( key , now () ) ; MST[NonVoidMethodCallMutator]MSP[] final long expirationTime = expiringPolicy . expirationTime ( key , value ) ; expirationMap . put ( key , Long . valueOf ( expirationTime ) ) ; return super . put ( key , value ) ; } @Override
final Iterator < Map . Entry < Object , Long > > iter = expirationMap . entrySet () . iterator () ; while ( iter . hasNext () ) { MST[rv.ROR4Mutator]MSP[] final Map . Entry < Object , Long > expirationEntry = iter . next () ;
final Iterator < Map . Entry < Object , Long > > iter = expirationMap . entrySet () . iterator () ; while ( iter . hasNext () ) { MST[rv.ROR3Mutator]MSP[] final Map . Entry < Object , Long > expirationEntry = iter . next () ;
private boolean isExpired ( final long now , final Long expirationTimeObject ) { if ( expirationTimeObject != null ) { MST[NegateConditionalsMutator]MSP[] final long expirationTime = expirationTimeObject . longValue () ; return expirationTime >= 0 && now >= expirationTime ; } return false ; } @Override
private boolean isExpired ( final long now , final Long expirationTimeObject ) { if ( expirationTimeObject != null ) { final long expirationTime = expirationTimeObject . longValue () ; return expirationTime >= 0 && now >= expirationTime ; MST[rv.UOI4Mutator]MSP[] } return false ; } @Override
final Long expirationTimeObject = expirationMap . get ( key ) ; if ( isExpired ( now , expirationTimeObject ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] remove ( key ) ; } } @Override public int size () { removeAllExpired ( now () ) ; return super . size () ; }
private boolean isExpired ( final long now , final Long expirationTimeObject ) { if ( expirationTimeObject != null ) { final long expirationTime = expirationTimeObject . longValue () ; return expirationTime >= 0 && now >= expirationTime ; MST[rv.UOI2Mutator]MSP[] } return false ; } @Override
private boolean isExpired ( final long now , final Long expirationTimeObject ) { if ( expirationTimeObject != null ) { final long expirationTime = expirationTimeObject . longValue () ; return expirationTime >= 0 && now >= expirationTime ; MST[rv.UOI1Mutator]MSP[] } return false ; } @Override
final Iterator < Map . Entry < Object , Long > > iter = expirationMap . entrySet () . iterator () ; while ( iter . hasNext () ) { MST[rv.ROR1Mutator]MSP[] final Map . Entry < Object , Long > expirationEntry = iter . next () ;
final Iterator < Map . Entry < Object , Long > > iter = expirationMap . entrySet () . iterator () ; MST[NonVoidMethodCallMutator]MSP[] while ( iter . hasNext () ) { final Map . Entry < Object , Long > expirationEntry = iter . next () ;
out . defaultWriteObject () ; out . writeObject ( map ) ; } @Override public Collection < V > values () { removeAllExpired ( now () ) ; MST[NonVoidMethodCallMutator]MSP[] return super . values () ; }
public Set < K > keySet () { removeAllExpired ( now () ) ; return super . keySet () ; MST[NonVoidMethodCallMutator]MSP[] } private long now () { return System . currentTimeMillis () ; } @Override public V put ( final K key , final V value ) {
private boolean isExpired ( final long now , final Long expirationTimeObject ) { if ( expirationTimeObject != null ) { final long expirationTime = expirationTimeObject . longValue () ; return expirationTime >= 0 && now >= expirationTime ; MST[rv.ABSMutator]MSP[] } return false ; } @Override
removeIfExpired ( key , now () ) ; MST[VoidMethodCallMutator]MSP[] final long expirationTime = expiringPolicy . expirationTime ( key , value ) ; expirationMap . put ( key , Long . valueOf ( expirationTime ) ) ; return super . put ( key , value ) ; } @Override
private boolean isExpired ( final long now , final Long expirationTimeObject ) { if ( expirationTimeObject != null ) { final long expirationTime = expirationTimeObject . longValue () ; return expirationTime >= 0 && now >= expirationTime ; MST[rv.CRCR6Mutator]MSP[] } return false ; } @Override
put ( entry . getKey () , entry . getValue () ) ; MST[NonVoidMethodCallMutator]MSP[] } } @Override public V remove ( final Object key ) { expirationMap . remove ( key ) ; return super . remove ( key ) ; } private void removeAllExpired ( final long now ) {
return now + timeToLiveMillis ; } return - 1L ; } private static long validateAndConvertToMillis ( final long timeToLive , final TimeUnit timeUnit ) { Objects . requireNonNull ( timeUnit , lr_1 ) ; return TimeUnit . MILLISECONDS . convert ( timeToLive , timeUnit ) ; MST[rv.UOI1Mutator]MSP[] } @Override
put ( entry . getKey () , entry . getValue () ) ; } } @Override public V remove ( final Object key ) { expirationMap . remove ( key ) ; MST[NonVoidMethodCallMutator]MSP[] return super . remove ( key ) ; } private void removeAllExpired ( final long now ) {
private boolean isExpired ( final long now , final Long expirationTimeObject ) { if ( expirationTimeObject != null ) { final long expirationTime = expirationTimeObject . longValue () ; return expirationTime >= 0 && now >= expirationTime ; MST[rv.CRCR1Mutator]MSP[] } return false ; } @Override
public void clear () { super . clear () ; expirationMap . clear () ; } @Override public boolean containsKey ( final Object key ) { removeIfExpired ( key , now () ) ; return super . containsKey ( key ) ; MST[BooleanFalseReturnValsMutator]MSP[] } @Override
return now + timeToLiveMillis ; } return - 1L ; } private static long validateAndConvertToMillis ( final long timeToLive , final TimeUnit timeUnit ) { Objects . requireNonNull ( timeUnit , lr_1 ) ; return TimeUnit . MILLISECONDS . convert ( timeToLive , timeUnit ) ; MST[rv.UOI3Mutator]MSP[] } @Override
final Iterator < Map . Entry < Object , Long > > iter = expirationMap . entrySet () . iterator () ; while ( iter . hasNext () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] final Map . Entry < Object , Long > expirationEntry = iter . next () ;
final Long expirationTimeObject = expirationMap . get ( key ) ; if ( isExpired ( now , expirationTimeObject ) ) { MST[rv.ROR3Mutator]MSP[] remove ( key ) ; } } @Override public int size () { removeAllExpired ( now () ) ; return super . size () ; }
final Long expirationTimeObject = expirationMap . get ( key ) ; if ( isExpired ( now , expirationTimeObject ) ) { remove ( key ) ; } } @Override public int size () { removeAllExpired ( now () ) ; return super . size () ; MST[PrimitiveReturnsMutator]MSP[] }
final Long expirationTimeObject = expirationMap . get ( key ) ; if ( isExpired ( now , expirationTimeObject ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] remove ( key ) ; } } @Override public int size () { removeAllExpired ( now () ) ; return super . size () ; }
final Long expirationTimeObject = expirationMap . get ( key ) ; if ( isExpired ( now , expirationTimeObject ) ) { MST[rv.ROR5Mutator]MSP[] remove ( key ) ; } } @Override public int size () { removeAllExpired ( now () ) ; return super . size () ; }
removeIfExpired ( key , now () ) ; final long expirationTime = expiringPolicy . expirationTime ( key , value ) ; expirationMap . put ( key , Long . valueOf ( expirationTime ) ) ; MST[rv.UOI1Mutator]MSP[] return super . put ( key , value ) ; } @Override
put ( entry . getKey () , entry . getValue () ) ; } } @Override public V remove ( final Object key ) { expirationMap . remove ( key ) ; return super . remove ( key ) ; MST[ReturnValsMutator]MSP[] } private void removeAllExpired ( final long now ) {
if ( isExpired ( now , expirationEntry . getValue () ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] super . remove ( expirationEntry . getKey () ) ; iter . remove () ; } } } private void removeIfExpired ( final Object key , final long now ) {
removeIfExpired ( key , now () ) ; final long expirationTime = expiringPolicy . expirationTime ( key , value ) ; expirationMap . put ( key , Long . valueOf ( expirationTime ) ) ; MST[rv.UOI4Mutator]MSP[] return super . put ( key , value ) ; } @Override
final Long expirationTimeObject = expirationMap . get ( key ) ; if ( isExpired ( now , expirationTimeObject ) ) { MST[rv.UOI2Mutator]MSP[] remove ( key ) ; } } @Override public int size () { removeAllExpired ( now () ) ; return super . size () ; }
private boolean isExpired ( final long now , final Long expirationTimeObject ) { if ( expirationTimeObject != null ) { final long expirationTime = expirationTimeObject . longValue () ; return expirationTime >= 0 && now >= expirationTime ; MST[RemoveConditionalMutator_ORDER_IF]MSP[] } return false ; } @Override
private boolean isExpired ( final long now , final Long expirationTimeObject ) { if ( expirationTimeObject != null ) { final long expirationTime = expirationTimeObject . longValue () ; return expirationTime >= 0 && now >= expirationTime ; MST[ReturnValsMutator]MSP[] } return false ; } @Override
out . defaultWriteObject () ; out . writeObject ( map ) ; } @Override public Collection < V > values () { removeAllExpired ( now () ) ; MST[VoidMethodCallMutator]MSP[] return super . values () ; }
return now + timeToLiveMillis ; } return - 1L ; } private static long validateAndConvertToMillis ( final long timeToLive , final TimeUnit timeUnit ) { Objects . requireNonNull ( timeUnit , lr_1 ) ; return TimeUnit . MILLISECONDS . convert ( timeToLive , timeUnit ) ; MST[ReturnValsMutator]MSP[] } @Override
private boolean isExpired ( final long now , final Long expirationTimeObject ) { if ( expirationTimeObject != null ) { final long expirationTime = expirationTimeObject . longValue () ; return expirationTime >= 0 && now >= expirationTime ; MST[rv.UOI4Mutator]MSP[] } return false ; } @Override
if ( isExpired ( now , expirationEntry . getValue () ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] super . remove ( expirationEntry . getKey () ) ; iter . remove () ; } } } private void removeIfExpired ( final Object key , final long now ) {
private boolean isExpired ( final long now , final Long expirationTimeObject ) { if ( expirationTimeObject != null ) { final long expirationTime = expirationTimeObject . longValue () ; return expirationTime >= 0 && now >= expirationTime ; MST[rv.UOI1Mutator]MSP[] } return false ; } @Override
private boolean isExpired ( final long now , final Long expirationTimeObject ) { if ( expirationTimeObject != null ) { final long expirationTime = expirationTimeObject . longValue () ; return expirationTime >= 0 && now >= expirationTime ; MST[rv.CRCR5Mutator]MSP[] } return false ; } @Override
put ( entry . getKey () , entry . getValue () ) ; } } @Override public V remove ( final Object key ) { expirationMap . remove ( key ) ; return super . remove ( key ) ; MST[ArgumentPropagationMutator]MSP[] } private void removeAllExpired ( final long now ) {
if ( isExpired ( now , expirationEntry . getValue () ) ) { MST[rv.ROR3Mutator]MSP[] super . remove ( expirationEntry . getKey () ) ; iter . remove () ; } } } private void removeIfExpired ( final Object key , final long now ) {
public boolean containsValue ( final Object value ) { removeAllExpired ( now () ) ; return super . containsValue ( value ) ; } @Override public Set < Entry < K , V > > entrySet () { removeAllExpired ( now () ) ; MST[NonVoidMethodCallMutator]MSP[] return super . entrySet () ;
private boolean isExpired ( final long now , final Long expirationTimeObject ) { if ( expirationTimeObject != null ) { final long expirationTime = expirationTimeObject . longValue () ; return expirationTime >= 0 && now >= expirationTime ; MST[NegateConditionalsMutator]MSP[] } return false ; } @Override
public boolean containsValue ( final Object value ) { removeAllExpired ( now () ) ; MST[NonVoidMethodCallMutator]MSP[] return super . containsValue ( value ) ; } @Override public Set < Entry < K , V > > entrySet () { removeAllExpired ( now () ) ; return super . entrySet () ;
public void putAll ( final Map < ? extends K , ? extends V > mapToCopy ) { for ( final Map . Entry < ? extends K , ? extends V > entry : mapToCopy . entrySet () ) { MST[NonVoidMethodCallMutator]MSP[]
public boolean containsValue ( final Object value ) { removeAllExpired ( now () ) ; return super . containsValue ( value ) ; MST[ReturnValsMutator]MSP[] } @Override public Set < Entry < K , V > > entrySet () { removeAllExpired ( now () ) ; return super . entrySet () ;
private boolean isExpired ( final long now , final Long expirationTimeObject ) { if ( expirationTimeObject != null ) { final long expirationTime = expirationTimeObject . longValue () ; return expirationTime >= 0 && now >= expirationTime ; MST[rv.ABSMutator]MSP[] } return false ; } @Override
public void clear () { super . clear () ; expirationMap . clear () ; } @Override public boolean containsKey ( final Object key ) { removeIfExpired ( key , now () ) ; return super . containsKey ( key ) ; MST[NonVoidMethodCallMutator]MSP[] } @Override
private boolean isExpired ( final long now , final Long expirationTimeObject ) { if ( expirationTimeObject != null ) { final long expirationTime = expirationTimeObject . longValue () ; return expirationTime >= 0 && now >= expirationTime ; MST[rv.ROR4Mutator]MSP[] } return false ; } @Override
} @Override public V get ( final Object key ) { removeIfExpired ( key , now () ) ; return super . get ( key ) ; } @Override public boolean isEmpty () { removeAllExpired ( now () ) ; return super . isEmpty () ; MST[NonVoidMethodCallMutator]MSP[] }
removeIfExpired ( key , now () ) ; final long expirationTime = expiringPolicy . expirationTime ( key , value ) ; expirationMap . put ( key , Long . valueOf ( expirationTime ) ) ; return super . put ( key , value ) ; MST[ReturnValsMutator]MSP[] } @Override
