reuseMapping ( reuse , hashIndex , hashCode , key , value ) ; MST[rv.UOI1Mutator]MSP[] } else { super . addMapping ( hashIndex , hashCode , key , value ) ; } } else { super . addMapping ( hashIndex , hashCode , key , value ) ; } }
loop = loop . next ; } if ( loop == null ) { throw new IllegalStateException ( MST[experimental.NakedReceiverMutator]MSP[] lr_12 + data [ removeIndex ] + lr_13 + previous + lr_6 + key + lr_7 + value + lr_8 + size + lr_9 + maxSize + lr_2 ) ; }
} @Override public boolean isFull () { return size >= maxSize ; MST[rv.UOI4Mutator]MSP[] } @Override public int maxSize () { return maxSize ; } public boolean isScanUntilRemovable () { return scanUntilRemovable ; } @Override public LRUMap < K , V > clone () {
modCount ++ ; removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; MST[rv.ABSMutator]MSP[] } catch ( final NullPointerException ex ) { throw new IllegalStateException (
lr_14 + entry + lr_15 + ( entry == header ) + lr_6 + key + lr_7 + value + lr_8 + size + lr_9 + maxSize + lr_2 ) ; } } protected boolean removeLRU ( final LinkEntry < K , V > entry ) { return true ; MST[rv.CRCR6Mutator]MSP[]
lr_14 + entry + lr_15 + ( entry == header ) + lr_6 + key + lr_7 + value + lr_8 + size + lr_9 + maxSize + lr_2 ) ; } } protected boolean removeLRU ( final LinkEntry < K , V > entry ) { return true ; MST[rv.CRCR2Mutator]MSP[]
lr_4 + header . after + lr_5 + header . before + lr_6 + key + lr_7 + value + lr_8 + size + lr_9 + maxSize + lr_10 ) ; } } else { removeLRUEntry = removeLRU ( reuse ) ; } if ( removeLRUEntry ) { MST[rv.UOI4Mutator]MSP[]
return ( LRUMap < K , V > ) super . clone () ; } private void writeObject ( final ObjectOutputStream out ) throws IOException { out . defaultWriteObject () ; MST[VoidMethodCallMutator]MSP[] doWriteObject ( out ) ; } private void readObject ( final ObjectInputStream in ) throws IOException , ClassNotFoundException {
throw new IllegalStateException ( lr_3 + lr_2 ) ; } } @Override protected void updateEntry ( final HashEntry < K , V > entry , final V newValue ) { moveToMRU ( ( LinkEntry < K , V > ) entry ) ; entry . setValue ( newValue ) ; MST[ArgumentPropagationMutator]MSP[]
} @Override public boolean isFull () { return size >= maxSize ; } @Override public int maxSize () { return maxSize ; MST[rv.UOI4Mutator]MSP[] } public boolean isScanUntilRemovable () { return scanUntilRemovable ; } @Override public LRUMap < K , V > clone () {
protected void reuseMapping ( final LinkEntry < K , V > entry , final int hashIndex , final int hashCode , final K key , final V value ) { try { final int removeIndex = hashIndex ( entry . hashCode , data . length ) ; MST[rv.ABSMutator]MSP[]
} @Override public boolean isFull () { return size >= maxSize ; } @Override public int maxSize () { return maxSize ; } public boolean isScanUntilRemovable () { return scanUntilRemovable ; MST[BooleanTrueReturnValsMutator]MSP[] } @Override public LRUMap < K , V > clone () {
modCount ++ ; removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException ( MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
modCount ++ ; removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException ( MST[NonVoidMethodCallMutator]MSP[]
if ( scanUntilRemovable ) { while ( reuse != header && reuse != null ) { if ( removeLRU ( reuse ) ) { removeLRUEntry = true ; MST[rv.CRCR3Mutator]MSP[] break; } reuse = reuse . after ; } if ( reuse == null ) { throw new IllegalStateException (
modCount ++ ; removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException ( MST[NonVoidMethodCallMutator]MSP[]
modCount ++ ; removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException ( MST[rv.UOI1Mutator]MSP[]
entry . after . before = entry . before ; entry . after = header ; entry . before = header . before ; header . before . after = entry ; header . before = entry ; } else if ( entry == header ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
modCount ++ ; removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException ( MST[rv.UOI2Mutator]MSP[]
modCount ++ ; removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException ( MST[NonVoidMethodCallMutator]MSP[]
final HashEntry < K , V > [] tmp = data ; HashEntry < K , V > loop = tmp [ removeIndex ] ; HashEntry < K , V > previous = null ; while ( loop != entry && loop != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] previous = loop ;
in . defaultReadObject () ; doReadObject ( in ) ; } @Override protected void doWriteObject ( final ObjectOutputStream out ) throws IOException { out . writeInt ( maxSize ) ; MST[VoidMethodCallMutator]MSP[] super . doWriteObject ( out ) ; } @Override
entry . after . before = entry . before ; MST[experimental.MemberVariableMutator]MSP[] entry . after = header ; entry . before = header . before ; header . before . after = entry ; header . before = entry ; } else if ( entry == header ) {
reuseMapping ( reuse , hashIndex , hashCode , key , value ) ; } else { super . addMapping ( hashIndex , hashCode , key , value ) ; } } else { super . addMapping ( hashIndex , hashCode , key , value ) ; MST[rv.UOI3Mutator]MSP[] } }
modCount ++ ; removeEntry ( entry , removeIndex , previous ) ; MST[rv.ABSMutator]MSP[] reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException (
} @Override protected void addMapping ( final int hashIndex , final int hashCode , final K key , final V value ) { if ( isFull () ) { LinkEntry < K , V > reuse = header . after ; boolean removeLRUEntry = false ; MST[rv.CRCR1Mutator]MSP[]
modCount ++ ; MST[rv.AOR1Mutator]MSP[] removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException (
loop = loop . next ; } if ( loop == null ) { throw new IllegalStateException ( MST[rv.UOI1Mutator]MSP[] lr_12 + data [ removeIndex ] + lr_13 + previous + lr_6 + key + lr_7 + value + lr_8 + size + lr_9 + maxSize + lr_2 ) ; }
modCount ++ ; removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException ( MST[rv.ROR5Mutator]MSP[]
if ( entry . after != header ) { modCount ++ ; if ( entry . before == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] throw new IllegalStateException ( lr_1 + lr_2 ) ; } entry . before . after = entry . after ;
modCount ++ ; removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException ( MST[experimental.NakedReceiverMutator]MSP[]
if ( entry . after != header ) { modCount ++ ; MST[rv.UOI2Mutator]MSP[] if ( entry . before == null ) { throw new IllegalStateException ( lr_1 + lr_2 ) ; } entry . before . after = entry . after ;
reuseMapping ( reuse , hashIndex , hashCode , key , value ) ; MST[rv.UOI1Mutator]MSP[] } else { super . addMapping ( hashIndex , hashCode , key , value ) ; } } else { super . addMapping ( hashIndex , hashCode , key , value ) ; } }
} @Override protected void addMapping ( final int hashIndex , final int hashCode , final K key , final V value ) { if ( isFull () ) { LinkEntry < K , V > reuse = header . after ; boolean removeLRUEntry = false ; MST[rv.CRCR5Mutator]MSP[]
if ( entry == null ) { MST[rv.ROR5Mutator]MSP[] return null ; } if ( updateToMRU ) { moveToMRU ( entry ) ; } return entry . getValue () ; } protected void moveToMRU ( final LinkEntry < K , V > entry ) {
lr_4 + header . after + lr_5 + header . before + lr_6 + key + lr_7 + value + lr_8 + size + lr_9 + maxSize + lr_10 ) ; } } else { removeLRUEntry = removeLRU ( reuse ) ; } if ( removeLRUEntry ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
protected void reuseMapping ( final LinkEntry < K , V > entry , final int hashIndex , final int hashCode , final K key , final V value ) { try { final int removeIndex = hashIndex ( entry . hashCode , data . length ) ; MST[rv.UOI2Mutator]MSP[]
if ( entry == null ) { return null ; } if ( updateToMRU ) { MST[rv.UOI2Mutator]MSP[] moveToMRU ( entry ) ; } return entry . getValue () ; } protected void moveToMRU ( final LinkEntry < K , V > entry ) {
modCount ++ ; removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException ( MST[rv.ABSMutator]MSP[]
modCount ++ ; removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException ( MST[experimental.NakedReceiverMutator]MSP[]
if ( scanUntilRemovable ) { while ( reuse != header && reuse != null ) { if ( removeLRU ( reuse ) ) { MST[NonVoidMethodCallMutator]MSP[] removeLRUEntry = true ; break; } reuse = reuse . after ; } if ( reuse == null ) { throw new IllegalStateException (
if ( scanUntilRemovable ) { while ( reuse != header && reuse != null ) { if ( removeLRU ( reuse ) ) { MST[rv.ROR3Mutator]MSP[] removeLRUEntry = true ; break; } reuse = reuse . after ; } if ( reuse == null ) { throw new IllegalStateException (
modCount ++ ; removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException ( MST[rv.CRCR5Mutator]MSP[]
if ( entry == null ) { return null ; } if ( updateToMRU ) { moveToMRU ( entry ) ; MST[VoidMethodCallMutator]MSP[] } return entry . getValue () ; } protected void moveToMRU ( final LinkEntry < K , V > entry ) {
modCount ++ ; removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException ( MST[rv.CRCR1Mutator]MSP[]
modCount ++ ; removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; MST[rv.UOI2Mutator]MSP[] } catch ( final NullPointerException ex ) { throw new IllegalStateException (
if ( entry . after != header ) { modCount ++ ; MST[rv.AOD2Mutator]MSP[] if ( entry . before == null ) { throw new IllegalStateException ( lr_1 + lr_2 ) ; } entry . before . after = entry . after ;
if ( entry == null ) { return null ; MST[ReturnValsMutator]MSP[] } if ( updateToMRU ) { moveToMRU ( entry ) ; } return entry . getValue () ; } protected void moveToMRU ( final LinkEntry < K , V > entry ) {
loop = loop . next ; } if ( loop == null ) { throw new IllegalStateException ( MST[NonVoidMethodCallMutator]MSP[] lr_12 + data [ removeIndex ] + lr_13 + previous + lr_6 + key + lr_7 + value + lr_8 + size + lr_9 + maxSize + lr_2 ) ; }
} @Override public boolean isFull () { return size >= maxSize ; MST[rv.CRCR5Mutator]MSP[] } @Override public int maxSize () { return maxSize ; } public boolean isScanUntilRemovable () { return scanUntilRemovable ; } @Override public LRUMap < K , V > clone () {
modCount ++ ; removeEntry ( entry , removeIndex , previous ) ; MST[rv.UOI2Mutator]MSP[] reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException (
lr_14 + entry + lr_15 + ( entry == header ) + lr_6 + key + lr_7 + value + lr_8 + size + lr_9 + maxSize + lr_2 ) ; } } protected boolean removeLRU ( final LinkEntry < K , V > entry ) { return true ; MST[InlineConstantMutator]MSP[]
if ( scanUntilRemovable ) { while ( reuse != header && reuse != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] if ( removeLRU ( reuse ) ) { removeLRUEntry = true ; break; } reuse = reuse . after ; } if ( reuse == null ) { throw new IllegalStateException (
modCount ++ ; removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException ( MST[NegateConditionalsMutator]MSP[]
if ( entry == null ) { return null ; } if ( updateToMRU ) { moveToMRU ( entry ) ; } return entry . getValue () ; MST[ReturnValsMutator]MSP[] } protected void moveToMRU ( final LinkEntry < K , V > entry ) {
reuseMapping ( reuse , hashIndex , hashCode , key , value ) ; } else { super . addMapping ( hashIndex , hashCode , key , value ) ; } } else { super . addMapping ( hashIndex , hashCode , key , value ) ; MST[rv.UOI3Mutator]MSP[] } }
} @Override protected void addMapping ( final int hashIndex , final int hashCode , final K key , final V value ) { if ( isFull () ) { MST[rv.ROR4Mutator]MSP[] LinkEntry < K , V > reuse = header . after ; boolean removeLRUEntry = false ;
final HashEntry < K , V > [] tmp = data ; HashEntry < K , V > loop = tmp [ removeIndex ] ; MST[rv.UOI1Mutator]MSP[] HashEntry < K , V > previous = null ; while ( loop != entry && loop != null ) { previous = loop ;
loop = loop . next ; } if ( loop == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] throw new IllegalStateException ( lr_12 + data [ removeIndex ] + lr_13 + previous + lr_6 + key + lr_7 + value + lr_8 + size + lr_9 + maxSize + lr_2 ) ; }
return ( LRUMap < K , V > ) super . clone () ; MST[ReturnValsMutator]MSP[] } private void writeObject ( final ObjectOutputStream out ) throws IOException { out . defaultWriteObject () ; doWriteObject ( out ) ; } private void readObject ( final ObjectInputStream in ) throws IOException , ClassNotFoundException {
if ( entry . after != header ) { modCount ++ ; MST[rv.ABSMutator]MSP[] if ( entry . before == null ) { throw new IllegalStateException ( lr_1 + lr_2 ) ; } entry . before . after = entry . after ;
loop = loop . next ; } if ( loop == null ) { throw new IllegalStateException ( MST[experimental.NakedReceiverMutator]MSP[] lr_12 + data [ removeIndex ] + lr_13 + previous + lr_6 + key + lr_7 + value + lr_8 + size + lr_9 + maxSize + lr_2 ) ; }
if ( scanUntilRemovable ) { MST[rv.ROR4Mutator]MSP[] while ( reuse != header && reuse != null ) { if ( removeLRU ( reuse ) ) { removeLRUEntry = true ; break; } reuse = reuse . after ; } if ( reuse == null ) { throw new IllegalStateException (
} @Override public boolean isFull () { return size >= maxSize ; MST[rv.UOI4Mutator]MSP[] } @Override public int maxSize () { return maxSize ; } public boolean isScanUntilRemovable () { return scanUntilRemovable ; } @Override public LRUMap < K , V > clone () {
if ( scanUntilRemovable ) { while ( reuse != header && reuse != null ) { MST[NegateConditionalsMutator]MSP[] if ( removeLRU ( reuse ) ) { removeLRUEntry = true ; break; } reuse = reuse . after ; } if ( reuse == null ) { throw new IllegalStateException (
throw new IllegalStateException ( lr_3 + MST[ConstructorCallMutator]MSP[] lr_2 ) ; } } @Override protected void updateEntry ( final HashEntry < K , V > entry , final V newValue ) { moveToMRU ( ( LinkEntry < K , V > ) entry ) ; entry . setValue ( newValue ) ;
lr_4 + header . after + lr_5 + header . before + lr_6 + key + lr_7 + value + lr_8 + size + lr_9 + maxSize + lr_10 ) ; } } else { removeLRUEntry = removeLRU ( reuse ) ; } if ( removeLRUEntry ) { MST[NegateConditionalsMutator]MSP[]
reuseMapping ( reuse , hashIndex , hashCode , key , value ) ; MST[rv.ABSMutator]MSP[] } else { super . addMapping ( hashIndex , hashCode , key , value ) ; } } else { super . addMapping ( hashIndex , hashCode , key , value ) ; } }
modCount ++ ; removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException ( MST[NonVoidMethodCallMutator]MSP[]
if ( entry . after != header ) { modCount ++ ; MST[rv.AOD1Mutator]MSP[] if ( entry . before == null ) { throw new IllegalStateException ( lr_1 + lr_2 ) ; } entry . before . after = entry . after ;
} @Override public boolean isFull () { return size >= maxSize ; MST[rv.CRCR6Mutator]MSP[] } @Override public int maxSize () { return maxSize ; } public boolean isScanUntilRemovable () { return scanUntilRemovable ; } @Override public LRUMap < K , V > clone () {
if ( entry . after != header ) { modCount ++ ; MST[rv.CRCR6Mutator]MSP[] if ( entry . before == null ) { throw new IllegalStateException ( lr_1 + lr_2 ) ; } entry . before . after = entry . after ;
modCount ++ ; removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException ( MST[NonVoidMethodCallMutator]MSP[]
} @Override public boolean isFull () { return size >= maxSize ; MST[rv.CRCR4Mutator]MSP[] } @Override public int maxSize () { return maxSize ; } public boolean isScanUntilRemovable () { return scanUntilRemovable ; } @Override public LRUMap < K , V > clone () {
final HashEntry < K , V > [] tmp = data ; HashEntry < K , V > loop = tmp [ removeIndex ] ; HashEntry < K , V > previous = null ; while ( loop != entry && loop != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] previous = loop ;
loop = loop . next ; } if ( loop == null ) { throw new IllegalStateException ( MST[experimental.NakedReceiverMutator]MSP[] lr_12 + data [ removeIndex ] + lr_13 + previous + lr_6 + key + lr_7 + value + lr_8 + size + lr_9 + maxSize + lr_2 ) ; }
if ( entry . after != header ) { modCount ++ ; MST[rv.AOR4Mutator]MSP[] if ( entry . before == null ) { throw new IllegalStateException ( lr_1 + lr_2 ) ; } entry . before . after = entry . after ;
reuseMapping ( reuse , hashIndex , hashCode , key , value ) ; } else { super . addMapping ( hashIndex , hashCode , key , value ) ; } } else { super . addMapping ( hashIndex , hashCode , key , value ) ; MST[rv.UOI2Mutator]MSP[] } }
loop = loop . next ; } if ( loop == null ) { throw new IllegalStateException ( MST[NonVoidMethodCallMutator]MSP[] lr_12 + data [ removeIndex ] + lr_13 + previous + lr_6 + key + lr_7 + value + lr_8 + size + lr_9 + maxSize + lr_2 ) ; }
if ( entry . after != header ) { modCount ++ ; if ( entry . before == null ) { MST[NegateConditionalsMutator]MSP[] throw new IllegalStateException ( lr_1 + lr_2 ) ; } entry . before . after = entry . after ;
if ( entry . after != header ) { modCount ++ ; MST[InlineConstantMutator]MSP[] if ( entry . before == null ) { throw new IllegalStateException ( lr_1 + lr_2 ) ; } entry . before . after = entry . after ;
modCount ++ ; removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException ( MST[experimental.NakedReceiverMutator]MSP[]
loop = loop . next ; } if ( loop == null ) { MST[rv.ROR5Mutator]MSP[] throw new IllegalStateException ( lr_12 + data [ removeIndex ] + lr_13 + previous + lr_6 + key + lr_7 + value + lr_8 + size + lr_9 + maxSize + lr_2 ) ; }
@Override public V get ( final Object key ) { return get ( key , true ) ; MST[rv.CRCR2Mutator]MSP[] } public V get ( final Object key , final boolean updateToMRU ) { final LinkEntry < K , V > entry = getEntry ( key ) ;
} @Override public boolean isFull () { return size >= maxSize ; MST[rv.ROR5Mutator]MSP[] } @Override public int maxSize () { return maxSize ; } public boolean isScanUntilRemovable () { return scanUntilRemovable ; } @Override public LRUMap < K , V > clone () {
} @Override public boolean isFull () { return size >= maxSize ; MST[InlineConstantMutator]MSP[] } @Override public int maxSize () { return maxSize ; } public boolean isScanUntilRemovable () { return scanUntilRemovable ; } @Override public LRUMap < K , V > clone () {
} @Override protected void addMapping ( final int hashIndex , final int hashCode , final K key , final V value ) { if ( isFull () ) { MST[NonVoidMethodCallMutator]MSP[] LinkEntry < K , V > reuse = header . after ; boolean removeLRUEntry = false ;
modCount ++ ; MST[rv.CRCR4Mutator]MSP[] removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException (
@Override public V get ( final Object key ) { return get ( key , true ) ; MST[rv.CRCR5Mutator]MSP[] } public V get ( final Object key , final boolean updateToMRU ) { final LinkEntry < K , V > entry = getEntry ( key ) ;
modCount ++ ; removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException ( MST[experimental.NakedReceiverMutator]MSP[]
} @Override public boolean isFull () { return size >= maxSize ; MST[rv.ROR2Mutator]MSP[] } @Override public int maxSize () { return maxSize ; } public boolean isScanUntilRemovable () { return scanUntilRemovable ; } @Override public LRUMap < K , V > clone () {
if ( entry . after != header ) { modCount ++ ; MST[MathMutator]MSP[] if ( entry . before == null ) { throw new IllegalStateException ( lr_1 + lr_2 ) ; } entry . before . after = entry . after ;
modCount ++ ; removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException ( MST[NonVoidMethodCallMutator]MSP[]
if ( scanUntilRemovable ) { while ( reuse != header && reuse != null ) { if ( removeLRU ( reuse ) ) { MST[rv.ROR4Mutator]MSP[] removeLRUEntry = true ; break; } reuse = reuse . after ; } if ( reuse == null ) { throw new IllegalStateException (
modCount ++ ; removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException ( MST[experimental.NakedReceiverMutator]MSP[]
loop = loop . next ; } if ( loop == null ) { throw new IllegalStateException ( MST[ConstructorCallMutator]MSP[] lr_12 + data [ removeIndex ] + lr_13 + previous + lr_6 + key + lr_7 + value + lr_8 + size + lr_9 + maxSize + lr_2 ) ; }
modCount ++ ; removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException ( MST[rv.UOI4Mutator]MSP[]
if ( entry . after != header ) { modCount ++ ; MST[rv.CRCR3Mutator]MSP[] if ( entry . before == null ) { throw new IllegalStateException ( lr_1 + lr_2 ) ; } entry . before . after = entry . after ;
loop = loop . next ; } if ( loop == null ) { throw new IllegalStateException ( MST[NonVoidMethodCallMutator]MSP[] lr_12 + data [ removeIndex ] + lr_13 + previous + lr_6 + key + lr_7 + value + lr_8 + size + lr_9 + maxSize + lr_2 ) ; }
modCount ++ ; removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException ( MST[rv.UOI3Mutator]MSP[]
lr_4 + header . after + lr_5 + header . before + lr_6 + key + lr_7 + value + lr_8 + size + lr_9 + maxSize + lr_10 ) ; } } else { removeLRUEntry = removeLRU ( reuse ) ; } if ( removeLRUEntry ) { MST[rv.ROR1Mutator]MSP[]
if ( scanUntilRemovable ) { while ( reuse != header && reuse != null ) { if ( removeLRU ( reuse ) ) { removeLRUEntry = true ; MST[rv.CRCR4Mutator]MSP[] break; } reuse = reuse . after ; } if ( reuse == null ) { throw new IllegalStateException (
lr_4 + header . after + lr_5 + header . before + lr_6 + key + lr_7 + value + lr_8 + size + lr_9 + maxSize + lr_10 ) ; } } else { removeLRUEntry = removeLRU ( reuse ) ; MST[NonVoidMethodCallMutator]MSP[] } if ( removeLRUEntry ) {
loop = loop . next ; } if ( loop == null ) { throw new IllegalStateException ( MST[rv.UOI4Mutator]MSP[] lr_12 + data [ removeIndex ] + lr_13 + previous + lr_6 + key + lr_7 + value + lr_8 + size + lr_9 + maxSize + lr_2 ) ; }
loop = loop . next ; } if ( loop == null ) { throw new IllegalStateException ( MST[NonVoidMethodCallMutator]MSP[] lr_12 + data [ removeIndex ] + lr_13 + previous + lr_6 + key + lr_7 + value + lr_8 + size + lr_9 + maxSize + lr_2 ) ; }
final HashEntry < K , V > [] tmp = data ; HashEntry < K , V > loop = tmp [ removeIndex ] ; HashEntry < K , V > previous = null ; while ( loop != entry && loop != null ) { MST[rv.ROR5Mutator]MSP[] previous = loop ;
entry . after . before = entry . before ; entry . after = header ; entry . before = header . before ; MST[experimental.MemberVariableMutator]MSP[] header . before . after = entry ; header . before = entry ; } else if ( entry == header ) {
loop = loop . next ; } if ( loop == null ) { throw new IllegalStateException ( MST[ConstructorCallMutator]MSP[] lr_12 + data [ removeIndex ] + lr_13 + previous + lr_6 + key + lr_7 + value + lr_8 + size + lr_9 + maxSize + lr_2 ) ; }
} @Override public boolean isFull () { return size >= maxSize ; MST[rv.UOI1Mutator]MSP[] } @Override public int maxSize () { return maxSize ; } public boolean isScanUntilRemovable () { return scanUntilRemovable ; } @Override public LRUMap < K , V > clone () {
lr_14 + entry + lr_15 + ( entry == header ) + lr_6 + key + lr_7 + value + lr_8 + size + lr_9 + maxSize + lr_2 ) ; } } protected boolean removeLRU ( final LinkEntry < K , V > entry ) { return true ; MST[rv.CRCR3Mutator]MSP[]
lr_4 + header . after + lr_5 + header . before + lr_6 + key + lr_7 + value + lr_8 + size + lr_9 + maxSize + lr_10 ) ; } } else { removeLRUEntry = removeLRU ( reuse ) ; } if ( removeLRUEntry ) { MST[rv.UOI3Mutator]MSP[]
} @Override public boolean isFull () { return size >= maxSize ; } @Override public int maxSize () { return maxSize ; MST[rv.UOI1Mutator]MSP[] } public boolean isScanUntilRemovable () { return scanUntilRemovable ; } @Override public LRUMap < K , V > clone () {
loop = loop . next ; } if ( loop == null ) { throw new IllegalStateException ( MST[experimental.NakedReceiverMutator]MSP[] lr_12 + data [ removeIndex ] + lr_13 + previous + lr_6 + key + lr_7 + value + lr_8 + size + lr_9 + maxSize + lr_2 ) ; }
modCount ++ ; removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException ( MST[NonVoidMethodCallMutator]MSP[]
} @Override public boolean isFull () { return size >= maxSize ; MST[ReturnValsMutator]MSP[] } @Override public int maxSize () { return maxSize ; } public boolean isScanUntilRemovable () { return scanUntilRemovable ; } @Override public LRUMap < K , V > clone () {
reuseMapping ( reuse , hashIndex , hashCode , key , value ) ; MST[rv.UOI4Mutator]MSP[] } else { super . addMapping ( hashIndex , hashCode , key , value ) ; } } else { super . addMapping ( hashIndex , hashCode , key , value ) ; } }
if ( scanUntilRemovable ) { while ( reuse != header && reuse != null ) { if ( removeLRU ( reuse ) ) { removeLRUEntry = true ; break; } reuse = reuse . after ; } if ( reuse == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] throw new IllegalStateException (
loop = loop . next ; } if ( loop == null ) { throw new IllegalStateException ( MST[experimental.NakedReceiverMutator]MSP[] lr_12 + data [ removeIndex ] + lr_13 + previous + lr_6 + key + lr_7 + value + lr_8 + size + lr_9 + maxSize + lr_2 ) ; }
@Override public V get ( final Object key ) { return get ( key , true ) ; MST[ArgumentPropagationMutator]MSP[] } public V get ( final Object key , final boolean updateToMRU ) { final LinkEntry < K , V > entry = getEntry ( key ) ;
modCount ++ ; MST[rv.UOI3Mutator]MSP[] removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException (
if ( scanUntilRemovable ) { while ( reuse != header && reuse != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] if ( removeLRU ( reuse ) ) { removeLRUEntry = true ; break; } reuse = reuse . after ; } if ( reuse == null ) { throw new IllegalStateException (
if ( entry . after != header ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] modCount ++ ; if ( entry . before == null ) { throw new IllegalStateException ( lr_1 + lr_2 ) ; } entry . before . after = entry . after ;
lr_4 + header . after + lr_5 + header . before + lr_6 + key + lr_7 + value + lr_8 + size + lr_9 + maxSize + lr_10 ) ; } } else { removeLRUEntry = removeLRU ( reuse ) ; } if ( removeLRUEntry ) { MST[rv.ROR4Mutator]MSP[]
modCount ++ ; removeEntry ( entry , removeIndex , previous ) ; MST[rv.UOI1Mutator]MSP[] reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException (
modCount ++ ; removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException ( MST[experimental.NakedReceiverMutator]MSP[]
} @Override protected void addMapping ( final int hashIndex , final int hashCode , final K key , final V value ) { if ( isFull () ) { MST[rv.ROR3Mutator]MSP[] LinkEntry < K , V > reuse = header . after ; boolean removeLRUEntry = false ;
} @Override public boolean isFull () { return size >= maxSize ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] } @Override public int maxSize () { return maxSize ; } public boolean isScanUntilRemovable () { return scanUntilRemovable ; } @Override public LRUMap < K , V > clone () {
if ( entry . after != header ) { MST[rv.ROR5Mutator]MSP[] modCount ++ ; if ( entry . before == null ) { throw new IllegalStateException ( lr_1 + lr_2 ) ; } entry . before . after = entry . after ;
} @Override protected void addMapping ( final int hashIndex , final int hashCode , final K key , final V value ) { if ( isFull () ) { LinkEntry < K , V > reuse = header . after ; boolean removeLRUEntry = false ; MST[rv.CRCR6Mutator]MSP[]
modCount ++ ; MST[rv.AOD2Mutator]MSP[] removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException (
if ( scanUntilRemovable ) { while ( reuse != header && reuse != null ) { if ( removeLRU ( reuse ) ) { removeLRUEntry = true ; MST[InlineConstantMutator]MSP[] break; } reuse = reuse . after ; } if ( reuse == null ) { throw new IllegalStateException (
modCount ++ ; MST[rv.CRCR5Mutator]MSP[] removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException (
} @Override public boolean isFull () { return size >= maxSize ; MST[rv.ROR4Mutator]MSP[] } @Override public int maxSize () { return maxSize ; } public boolean isScanUntilRemovable () { return scanUntilRemovable ; } @Override public LRUMap < K , V > clone () {
if ( entry == null ) { return null ; } if ( updateToMRU ) { MST[rv.UOI3Mutator]MSP[] moveToMRU ( entry ) ; } return entry . getValue () ; } protected void moveToMRU ( final LinkEntry < K , V > entry ) {
@Override public V get ( final Object key ) { return get ( key , true ) ; MST[rv.CRCR3Mutator]MSP[] } public V get ( final Object key , final boolean updateToMRU ) { final LinkEntry < K , V > entry = getEntry ( key ) ;
if ( scanUntilRemovable ) { while ( reuse != header && reuse != null ) { if ( removeLRU ( reuse ) ) { MST[rv.ROR2Mutator]MSP[] removeLRUEntry = true ; break; } reuse = reuse . after ; } if ( reuse == null ) { throw new IllegalStateException (
modCount ++ ; removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; MST[rv.UOI3Mutator]MSP[] addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException (
if ( reuse == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] throw new IllegalStateException ( lr_11 + header . after + lr_5 + header . before + lr_6 + key + lr_7 + value + lr_8 + size + lr_9 + maxSize + lr_10 ) ; }
reuseMapping ( reuse , hashIndex , hashCode , key , value ) ; MST[rv.UOI4Mutator]MSP[] } else { super . addMapping ( hashIndex , hashCode , key , value ) ; } } else { super . addMapping ( hashIndex , hashCode , key , value ) ; } }
loop = loop . next ; } if ( loop == null ) { throw new IllegalStateException ( MST[rv.UOI4Mutator]MSP[] lr_12 + data [ removeIndex ] + lr_13 + previous + lr_6 + key + lr_7 + value + lr_8 + size + lr_9 + maxSize + lr_2 ) ; }
modCount ++ ; removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException ( MST[rv.CRCR6Mutator]MSP[]
if ( scanUntilRemovable ) { while ( reuse != header && reuse != null ) { MST[rv.ROR5Mutator]MSP[] if ( removeLRU ( reuse ) ) { removeLRUEntry = true ; break; } reuse = reuse . after ; } if ( reuse == null ) { throw new IllegalStateException (
reuseMapping ( reuse , hashIndex , hashCode , key , value ) ; MST[rv.ABSMutator]MSP[] } else { super . addMapping ( hashIndex , hashCode , key , value ) ; } } else { super . addMapping ( hashIndex , hashCode , key , value ) ; } }
modCount ++ ; removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException ( MST[NonVoidMethodCallMutator]MSP[]
loop = loop . next ; } if ( loop == null ) { throw new IllegalStateException ( MST[NonVoidMethodCallMutator]MSP[] lr_12 + data [ removeIndex ] + lr_13 + previous + lr_6 + key + lr_7 + value + lr_8 + size + lr_9 + maxSize + lr_2 ) ; }
if ( scanUntilRemovable ) { while ( reuse != header && reuse != null ) { if ( removeLRU ( reuse ) ) { removeLRUEntry = true ; MST[rv.CRCR2Mutator]MSP[] break; } reuse = reuse . after ; } if ( reuse == null ) { throw new IllegalStateException (
} @Override public boolean isFull () { return size >= maxSize ; MST[rv.CRCR5Mutator]MSP[] } @Override public int maxSize () { return maxSize ; } public boolean isScanUntilRemovable () { return scanUntilRemovable ; } @Override public LRUMap < K , V > clone () {
@Override public V get ( final Object key ) { return get ( key , true ) ; MST[InlineConstantMutator]MSP[] } public V get ( final Object key , final boolean updateToMRU ) { final LinkEntry < K , V > entry = getEntry ( key ) ;
modCount ++ ; removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException ( MST[rv.UOI1Mutator]MSP[]
if ( scanUntilRemovable ) { while ( reuse != header && reuse != null ) { if ( removeLRU ( reuse ) ) { removeLRUEntry = true ; break; } reuse = reuse . after ; } if ( reuse == null ) { MST[NegateConditionalsMutator]MSP[] throw new IllegalStateException (
in . defaultReadObject () ; doReadObject ( in ) ; } @Override protected void doWriteObject ( final ObjectOutputStream out ) throws IOException { out . writeInt ( maxSize ) ; super . doWriteObject ( out ) ; MST[VoidMethodCallMutator]MSP[] } @Override
loop = loop . next ; } if ( loop == null ) { throw new IllegalStateException ( MST[rv.UOI3Mutator]MSP[] lr_12 + data [ removeIndex ] + lr_13 + previous + lr_6 + key + lr_7 + value + lr_8 + size + lr_9 + maxSize + lr_2 ) ; }
if ( entry . after != header ) { modCount ++ ; if ( entry . before == null ) { throw new IllegalStateException ( lr_1 + MST[ConstructorCallMutator]MSP[] lr_2 ) ; } entry . before . after = entry . after ;
if ( entry . after != header ) { modCount ++ ; MST[rv.UOI1Mutator]MSP[] if ( entry . before == null ) { throw new IllegalStateException ( lr_1 + lr_2 ) ; } entry . before . after = entry . after ;
reuseMapping ( reuse , hashIndex , hashCode , key , value ) ; } else { super . addMapping ( hashIndex , hashCode , key , value ) ; } } else { super . addMapping ( hashIndex , hashCode , key , value ) ; MST[rv.UOI2Mutator]MSP[] } }
if ( entry == null ) { MST[NegateConditionalsMutator]MSP[] return null ; } if ( updateToMRU ) { moveToMRU ( entry ) ; } return entry . getValue () ; } protected void moveToMRU ( final LinkEntry < K , V > entry ) {
} @Override protected void addMapping ( final int hashIndex , final int hashCode , final K key , final V value ) { if ( isFull () ) { MST[NegateConditionalsMutator]MSP[] LinkEntry < K , V > reuse = header . after ; boolean removeLRUEntry = false ;
if ( entry == null ) { return null ; } if ( updateToMRU ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] moveToMRU ( entry ) ; } return entry . getValue () ; } protected void moveToMRU ( final LinkEntry < K , V > entry ) {
if ( scanUntilRemovable ) { MST[rv.ROR3Mutator]MSP[] while ( reuse != header && reuse != null ) { if ( removeLRU ( reuse ) ) { removeLRUEntry = true ; break; } reuse = reuse . after ; } if ( reuse == null ) { throw new IllegalStateException (
} @Override public boolean isFull () { return size >= maxSize ; MST[NegateConditionalsMutator]MSP[] } @Override public int maxSize () { return maxSize ; } public boolean isScanUntilRemovable () { return scanUntilRemovable ; } @Override public LRUMap < K , V > clone () {
@Override public V get ( final Object key ) { return get ( key , true ) ; MST[NonVoidMethodCallMutator]MSP[] } public V get ( final Object key , final boolean updateToMRU ) { final LinkEntry < K , V > entry = getEntry ( key ) ;
} @Override public boolean isFull () { return size >= maxSize ; MST[rv.UOI1Mutator]MSP[] } @Override public int maxSize () { return maxSize ; } public boolean isScanUntilRemovable () { return scanUntilRemovable ; } @Override public LRUMap < K , V > clone () {
loop = loop . next ; } if ( loop == null ) { throw new IllegalStateException ( MST[experimental.NakedReceiverMutator]MSP[] lr_12 + data [ removeIndex ] + lr_13 + previous + lr_6 + key + lr_7 + value + lr_8 + size + lr_9 + maxSize + lr_2 ) ; }
modCount ++ ; removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; MST[rv.UOI4Mutator]MSP[] addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException (
modCount ++ ; removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException ( MST[ConstructorCallMutator]MSP[]
} @Override public boolean isFull () { return size >= maxSize ; MST[RemoveConditionalMutator_ORDER_IF]MSP[] } @Override public int maxSize () { return maxSize ; } public boolean isScanUntilRemovable () { return scanUntilRemovable ; } @Override public LRUMap < K , V > clone () {
modCount ++ ; removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; MST[rv.UOI3Mutator]MSP[] addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException (
loop = loop . next ; } if ( loop == null ) { throw new IllegalStateException ( MST[rv.ABSMutator]MSP[] lr_12 + data [ removeIndex ] + lr_13 + previous + lr_6 + key + lr_7 + value + lr_8 + size + lr_9 + maxSize + lr_2 ) ; }
modCount ++ ; removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException ( MST[NonVoidMethodCallMutator]MSP[]
loop = loop . next ; } if ( loop == null ) { throw new IllegalStateException ( MST[experimental.NakedReceiverMutator]MSP[] lr_12 + data [ removeIndex ] + lr_13 + previous + lr_6 + key + lr_7 + value + lr_8 + size + lr_9 + maxSize + lr_2 ) ; }
if ( entry == null ) { return null ; } if ( updateToMRU ) { moveToMRU ( entry ) ; } return entry . getValue () ; MST[NonVoidMethodCallMutator]MSP[] } protected void moveToMRU ( final LinkEntry < K , V > entry ) {
if ( entry . after != header ) { modCount ++ ; MST[rv.CRCR2Mutator]MSP[] if ( entry . before == null ) { throw new IllegalStateException ( lr_1 + lr_2 ) ; } entry . before . after = entry . after ;
modCount ++ ; removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException ( MST[NonVoidMethodCallMutator]MSP[]
if ( scanUntilRemovable ) { while ( reuse != header && reuse != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] if ( removeLRU ( reuse ) ) { removeLRUEntry = true ; break; } reuse = reuse . after ; } if ( reuse == null ) { throw new IllegalStateException (
modCount ++ ; removeEntry ( entry , removeIndex , previous ) ; MST[VoidMethodCallMutator]MSP[] reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException (
modCount ++ ; removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException ( MST[experimental.NakedReceiverMutator]MSP[]
modCount ++ ; removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException ( MST[NonVoidMethodCallMutator]MSP[]
if ( entry == null ) { return null ; } if ( updateToMRU ) { MST[rv.ABSMutator]MSP[] moveToMRU ( entry ) ; } return entry . getValue () ; } protected void moveToMRU ( final LinkEntry < K , V > entry ) {
loop = loop . next ; } if ( loop == null ) { throw new IllegalStateException ( MST[rv.UOI4Mutator]MSP[] lr_12 + data [ removeIndex ] + lr_13 + previous + lr_6 + key + lr_7 + value + lr_8 + size + lr_9 + maxSize + lr_2 ) ; }
if ( scanUntilRemovable ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] while ( reuse != header && reuse != null ) { if ( removeLRU ( reuse ) ) { removeLRUEntry = true ; break; } reuse = reuse . after ; } if ( reuse == null ) { throw new IllegalStateException (
if ( entry == null ) { return null ; } if ( updateToMRU ) { MST[rv.UOI4Mutator]MSP[] moveToMRU ( entry ) ; } return entry . getValue () ; } protected void moveToMRU ( final LinkEntry < K , V > entry ) {
if ( scanUntilRemovable ) { while ( reuse != header && reuse != null ) { MST[rv.ROR5Mutator]MSP[] if ( removeLRU ( reuse ) ) { removeLRUEntry = true ; break; } reuse = reuse . after ; } if ( reuse == null ) { throw new IllegalStateException (
} @Override public boolean isFull () { return size >= maxSize ; MST[InlineConstantMutator]MSP[] } @Override public int maxSize () { return maxSize ; } public boolean isScanUntilRemovable () { return scanUntilRemovable ; } @Override public LRUMap < K , V > clone () {
loop = loop . next ; } if ( loop == null ) { throw new IllegalStateException ( MST[rv.UOI3Mutator]MSP[] lr_12 + data [ removeIndex ] + lr_13 + previous + lr_6 + key + lr_7 + value + lr_8 + size + lr_9 + maxSize + lr_2 ) ; }
modCount ++ ; MST[rv.AOD1Mutator]MSP[] removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException (
modCount ++ ; removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; MST[rv.ABSMutator]MSP[] addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException (
protected void reuseMapping ( final LinkEntry < K , V > entry , final int hashIndex , final int hashCode , final K key , final V value ) { try { final int removeIndex = hashIndex ( entry . hashCode , data . length ) ; MST[rv.UOI1Mutator]MSP[]
entry . after . before = entry . before ; entry . after = header ; entry . before = header . before ; header . before . after = entry ; header . before = entry ; MST[experimental.MemberVariableMutator]MSP[] } else if ( entry == header ) {
if ( entry == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return null ; } if ( updateToMRU ) { moveToMRU ( entry ) ; } return entry . getValue () ; } protected void moveToMRU ( final LinkEntry < K , V > entry ) {
lr_4 + header . after + lr_5 + header . before + lr_6 + key + lr_7 + value + lr_8 + size + lr_9 + maxSize + lr_10 ) ; } } else { removeLRUEntry = removeLRU ( reuse ) ; } if ( removeLRUEntry ) { MST[rv.ROR5Mutator]MSP[]
loop = loop . next ; } if ( loop == null ) { throw new IllegalStateException ( MST[NonVoidMethodCallMutator]MSP[] lr_12 + data [ removeIndex ] + lr_13 + previous + lr_6 + key + lr_7 + value + lr_8 + size + lr_9 + maxSize + lr_2 ) ; }
modCount ++ ; removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; MST[rv.UOI4Mutator]MSP[] addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException (
modCount ++ ; removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; MST[rv.UOI1Mutator]MSP[] } catch ( final NullPointerException ex ) { throw new IllegalStateException (
loop = loop . next ; } if ( loop == null ) { throw new IllegalStateException ( MST[NonVoidMethodCallMutator]MSP[] lr_12 + data [ removeIndex ] + lr_13 + previous + lr_6 + key + lr_7 + value + lr_8 + size + lr_9 + maxSize + lr_2 ) ; }
} @Override public boolean isFull () { return size >= maxSize ; MST[rv.CRCR3Mutator]MSP[] } @Override public int maxSize () { return maxSize ; } public boolean isScanUntilRemovable () { return scanUntilRemovable ; } @Override public LRUMap < K , V > clone () {
protected void reuseMapping ( final LinkEntry < K , V > entry , final int hashIndex , final int hashCode , final K key , final V value ) { try { final int removeIndex = hashIndex ( entry . hashCode , data . length ) ; MST[NonVoidMethodCallMutator]MSP[]
modCount ++ ; MST[rv.UOI4Mutator]MSP[] removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException (
if ( entry . after != header ) { modCount ++ ; if ( entry . before == null ) { throw new IllegalStateException ( lr_1 + lr_2 ) ; } entry . before . after = entry . after ; MST[experimental.MemberVariableMutator]MSP[]
loop = loop . next ; } if ( loop == null ) { throw new IllegalStateException ( MST[rv.ABSMutator]MSP[] lr_12 + data [ removeIndex ] + lr_13 + previous + lr_6 + key + lr_7 + value + lr_8 + size + lr_9 + maxSize + lr_2 ) ; }
if ( entry == null ) { return null ; } if ( updateToMRU ) { MST[rv.ROR1Mutator]MSP[] moveToMRU ( entry ) ; } return entry . getValue () ; } protected void moveToMRU ( final LinkEntry < K , V > entry ) {
} @Override protected void addMapping ( final int hashIndex , final int hashCode , final K key , final V value ) { if ( isFull () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] LinkEntry < K , V > reuse = header . after ; boolean removeLRUEntry = false ;
if ( entry . after != header ) { modCount ++ ; if ( entry . before == null ) { MST[rv.ROR5Mutator]MSP[] throw new IllegalStateException ( lr_1 + lr_2 ) ; } entry . before . after = entry . after ;
modCount ++ ; MST[rv.AOR4Mutator]MSP[] removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException (
throw new IllegalStateException ( lr_3 + lr_2 ) ; } } @Override protected void updateEntry ( final HashEntry < K , V > entry , final V newValue ) { moveToMRU ( ( LinkEntry < K , V > ) entry ) ; MST[VoidMethodCallMutator]MSP[] entry . setValue ( newValue ) ;
reuseMapping ( reuse , hashIndex , hashCode , key , value ) ; } else { super . addMapping ( hashIndex , hashCode , key , value ) ; } } else { super . addMapping ( hashIndex , hashCode , key , value ) ; MST[rv.UOI1Mutator]MSP[] } }
} @Override public boolean isFull () { return size >= maxSize ; MST[BooleanTrueReturnValsMutator]MSP[] } @Override public int maxSize () { return maxSize ; } public boolean isScanUntilRemovable () { return scanUntilRemovable ; } @Override public LRUMap < K , V > clone () {
reuseMapping ( reuse , hashIndex , hashCode , key , value ) ; } else { super . addMapping ( hashIndex , hashCode , key , value ) ; } } else { super . addMapping ( hashIndex , hashCode , key , value ) ; MST[VoidMethodCallMutator]MSP[] } }
in . defaultReadObject () ; doReadObject ( in ) ; } @Override protected void doWriteObject ( final ObjectOutputStream out ) throws IOException { out . writeInt ( maxSize ) ; MST[rv.UOI1Mutator]MSP[] super . doWriteObject ( out ) ; } @Override
} @Override public boolean isFull () { return size >= maxSize ; MST[rv.UOI2Mutator]MSP[] } @Override public int maxSize () { return maxSize ; } public boolean isScanUntilRemovable () { return scanUntilRemovable ; } @Override public LRUMap < K , V > clone () {
lr_14 + entry + lr_15 + ( entry == header ) + lr_6 + key + lr_7 + value + lr_8 + size + lr_9 + maxSize + lr_2 ) ; } } protected boolean removeLRU ( final LinkEntry < K , V > entry ) { return true ; MST[rv.CRCR4Mutator]MSP[]
} @Override public boolean isFull () { return size >= maxSize ; } @Override public int maxSize () { return maxSize ; MST[rv.UOI2Mutator]MSP[] } public boolean isScanUntilRemovable () { return scanUntilRemovable ; } @Override public LRUMap < K , V > clone () {
entry . after . before = entry . before ; entry . after = header ; entry . before = header . before ; header . before . after = entry ; header . before = entry ; } else if ( entry == header ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
loop = loop . next ; } if ( loop == null ) { throw new IllegalStateException ( MST[experimental.NakedReceiverMutator]MSP[] lr_12 + data [ removeIndex ] + lr_13 + previous + lr_6 + key + lr_7 + value + lr_8 + size + lr_9 + maxSize + lr_2 ) ; }
modCount ++ ; removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException ( MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
lr_4 + header . after + lr_5 + header . before + lr_6 + key + lr_7 + value + lr_8 + size + lr_9 + maxSize + lr_10 ) ; } } else { removeLRUEntry = removeLRU ( reuse ) ; } if ( removeLRUEntry ) { MST[rv.UOI2Mutator]MSP[]
modCount ++ ; removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; MST[rv.ABSMutator]MSP[] addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException (
reuseMapping ( reuse , hashIndex , hashCode , key , value ) ; MST[VoidMethodCallMutator]MSP[] } else { super . addMapping ( hashIndex , hashCode , key , value ) ; } } else { super . addMapping ( hashIndex , hashCode , key , value ) ; } }
modCount ++ ; removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException ( MST[NonVoidMethodCallMutator]MSP[]
return ( LRUMap < K , V > ) super . clone () ; MST[NonVoidMethodCallMutator]MSP[] } private void writeObject ( final ObjectOutputStream out ) throws IOException { out . defaultWriteObject () ; doWriteObject ( out ) ; } private void readObject ( final ObjectInputStream in ) throws IOException , ClassNotFoundException {
modCount ++ ; removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; MST[VoidMethodCallMutator]MSP[] } catch ( final NullPointerException ex ) { throw new IllegalStateException (
reuseMapping ( reuse , hashIndex , hashCode , key , value ) ; MST[rv.UOI3Mutator]MSP[] } else { super . addMapping ( hashIndex , hashCode , key , value ) ; } } else { super . addMapping ( hashIndex , hashCode , key , value ) ; } }
lr_14 + entry + lr_15 + ( entry == header ) + lr_6 + key + lr_7 + value + lr_8 + size + lr_9 + maxSize + lr_2 ) ; } } protected boolean removeLRU ( final LinkEntry < K , V > entry ) { return true ; MST[BooleanFalseReturnValsMutator]MSP[]
modCount ++ ; MST[InlineConstantMutator]MSP[] removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException (
modCount ++ ; removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException ( MST[rv.UOI4Mutator]MSP[]
if ( scanUntilRemovable ) { while ( reuse != header && reuse != null ) { if ( removeLRU ( reuse ) ) { removeLRUEntry = true ; MST[rv.CRCR5Mutator]MSP[] break; } reuse = reuse . after ; } if ( reuse == null ) { throw new IllegalStateException (
modCount ++ ; removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException ( MST[rv.UOI3Mutator]MSP[]
loop = loop . next ; } if ( loop == null ) { throw new IllegalStateException ( MST[rv.UOI3Mutator]MSP[] lr_12 + data [ removeIndex ] + lr_13 + previous + lr_6 + key + lr_7 + value + lr_8 + size + lr_9 + maxSize + lr_2 ) ; }
modCount ++ ; MST[rv.AOR3Mutator]MSP[] removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException (
entry . after . before = entry . before ; entry . after = header ; entry . before = header . before ; header . before . after = entry ; header . before = entry ; } else if ( entry == header ) { MST[rv.ROR5Mutator]MSP[]
reuseMapping ( reuse , hashIndex , hashCode , key , value ) ; } else { super . addMapping ( hashIndex , hashCode , key , value ) ; } } else { super . addMapping ( hashIndex , hashCode , key , value ) ; MST[rv.UOI1Mutator]MSP[] } }
modCount ++ ; MST[rv.ABSMutator]MSP[] removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException (
loop = loop . next ; } if ( loop == null ) { throw new IllegalStateException ( MST[NonVoidMethodCallMutator]MSP[] lr_12 + data [ removeIndex ] + lr_13 + previous + lr_6 + key + lr_7 + value + lr_8 + size + lr_9 + maxSize + lr_2 ) ; }
entry . after . before = entry . before ; entry . after = header ; entry . before = header . before ; header . before . after = entry ; header . before = entry ; } else if ( entry == header ) { MST[NegateConditionalsMutator]MSP[]
loop = loop . next ; } if ( loop == null ) { throw new IllegalStateException ( MST[rv.UOI1Mutator]MSP[] lr_12 + data [ removeIndex ] + lr_13 + previous + lr_6 + key + lr_7 + value + lr_8 + size + lr_9 + maxSize + lr_2 ) ; }
@Override public V get ( final Object key ) { return get ( key , true ) ; MST[NullReturnValsMutator]MSP[] } public V get ( final Object key , final boolean updateToMRU ) { final LinkEntry < K , V > entry = getEntry ( key ) ;
loop = loop . next ; } if ( loop == null ) { throw new IllegalStateException ( MST[experimental.NakedReceiverMutator]MSP[] lr_12 + data [ removeIndex ] + lr_13 + previous + lr_6 + key + lr_7 + value + lr_8 + size + lr_9 + maxSize + lr_2 ) ; }
if ( scanUntilRemovable ) { while ( reuse != header && reuse != null ) { if ( removeLRU ( reuse ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] removeLRUEntry = true ; break; } reuse = reuse . after ; } if ( reuse == null ) { throw new IllegalStateException (
modCount ++ ; MST[rv.CRCR6Mutator]MSP[] removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException (
modCount ++ ; MST[rv.CRCR2Mutator]MSP[] removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException (
@Override public V get ( final Object key ) { return get ( key , true ) ; MST[rv.CRCR4Mutator]MSP[] } public V get ( final Object key , final boolean updateToMRU ) { final LinkEntry < K , V > entry = getEntry ( key ) ;
} @Override public boolean isFull () { return size >= maxSize ; MST[rv.ROR3Mutator]MSP[] } @Override public int maxSize () { return maxSize ; } public boolean isScanUntilRemovable () { return scanUntilRemovable ; } @Override public LRUMap < K , V > clone () {
lr_4 + header . after + lr_5 + header . before + lr_6 + key + lr_7 + value + lr_8 + size + lr_9 + maxSize + lr_10 ) ; } } else { removeLRUEntry = removeLRU ( reuse ) ; } if ( removeLRUEntry ) { MST[rv.ABSMutator]MSP[]
modCount ++ ; removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; MST[rv.UOI2Mutator]MSP[] addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException (
} @Override public boolean isFull () { return size >= maxSize ; MST[rv.ABSMutator]MSP[] } @Override public int maxSize () { return maxSize ; } public boolean isScanUntilRemovable () { return scanUntilRemovable ; } @Override public LRUMap < K , V > clone () {
lr_4 + header . after + lr_5 + header . before + lr_6 + key + lr_7 + value + lr_8 + size + lr_9 + maxSize + lr_10 ) ; } } else { removeLRUEntry = removeLRU ( reuse ) ; } if ( removeLRUEntry ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
modCount ++ ; MST[rv.UOI2Mutator]MSP[] removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException (
if ( entry . after != header ) { modCount ++ ; MST[rv.CRCR5Mutator]MSP[] if ( entry . before == null ) { throw new IllegalStateException ( lr_1 + lr_2 ) ; } entry . before . after = entry . after ;
modCount ++ ; removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException ( MST[experimental.NakedReceiverMutator]MSP[]
loop = loop . next ; } if ( loop == null ) { throw new IllegalStateException ( MST[NonVoidMethodCallMutator]MSP[] lr_12 + data [ removeIndex ] + lr_13 + previous + lr_6 + key + lr_7 + value + lr_8 + size + lr_9 + maxSize + lr_2 ) ; }
lr_4 + header . after + lr_5 + header . before + lr_6 + key + lr_7 + value + lr_8 + size + lr_9 + maxSize + lr_10 ) ; } } else { removeLRUEntry = removeLRU ( reuse ) ; } if ( removeLRUEntry ) { MST[rv.ROR3Mutator]MSP[]
if ( entry . after != header ) { modCount ++ ; MST[rv.AOR1Mutator]MSP[] if ( entry . before == null ) { throw new IllegalStateException ( lr_1 + lr_2 ) ; } entry . before . after = entry . after ;
if ( entry . after != header ) { modCount ++ ; if ( entry . before == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] throw new IllegalStateException ( lr_1 + lr_2 ) ; } entry . before . after = entry . after ;
final HashEntry < K , V > [] tmp = data ; HashEntry < K , V > loop = tmp [ removeIndex ] ; HashEntry < K , V > previous = null ; while ( loop != entry && loop != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] previous = loop ;
loop = loop . next ; } if ( loop == null ) { throw new IllegalStateException ( MST[experimental.NakedReceiverMutator]MSP[] lr_12 + data [ removeIndex ] + lr_13 + previous + lr_6 + key + lr_7 + value + lr_8 + size + lr_9 + maxSize + lr_2 ) ; }
} @Override public boolean isFull () { return size >= maxSize ; } @Override public int maxSize () { return maxSize ; } public boolean isScanUntilRemovable () { return scanUntilRemovable ; MST[ReturnValsMutator]MSP[] } @Override public LRUMap < K , V > clone () {
if ( scanUntilRemovable ) { MST[rv.ROR2Mutator]MSP[] while ( reuse != header && reuse != null ) { if ( removeLRU ( reuse ) ) { removeLRUEntry = true ; break; } reuse = reuse . after ; } if ( reuse == null ) { throw new IllegalStateException (
} @Override public boolean isFull () { return size >= maxSize ; MST[rv.UOI2Mutator]MSP[] } @Override public int maxSize () { return maxSize ; } public boolean isScanUntilRemovable () { return scanUntilRemovable ; } @Override public LRUMap < K , V > clone () {
in . defaultReadObject () ; doReadObject ( in ) ; } @Override protected void doWriteObject ( final ObjectOutputStream out ) throws IOException { out . writeInt ( maxSize ) ; MST[rv.UOI2Mutator]MSP[] super . doWriteObject ( out ) ; } @Override
if ( scanUntilRemovable ) { MST[rv.ROR1Mutator]MSP[] while ( reuse != header && reuse != null ) { if ( removeLRU ( reuse ) ) { removeLRUEntry = true ; break; } reuse = reuse . after ; } if ( reuse == null ) { throw new IllegalStateException (
if ( scanUntilRemovable ) { while ( reuse != header && reuse != null ) { if ( removeLRU ( reuse ) ) { MST[NegateConditionalsMutator]MSP[] removeLRUEntry = true ; break; } reuse = reuse . after ; } if ( reuse == null ) { throw new IllegalStateException (
loop = loop . next ; } if ( loop == null ) { throw new IllegalStateException ( MST[experimental.NakedReceiverMutator]MSP[] lr_12 + data [ removeIndex ] + lr_13 + previous + lr_6 + key + lr_7 + value + lr_8 + size + lr_9 + maxSize + lr_2 ) ; }
if ( entry == null ) { return null ; } if ( updateToMRU ) { MST[rv.ROR5Mutator]MSP[] moveToMRU ( entry ) ; } return entry . getValue () ; } protected void moveToMRU ( final LinkEntry < K , V > entry ) {
modCount ++ ; removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; MST[rv.UOI2Mutator]MSP[] addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException (
modCount ++ ; removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException ( MST[NonVoidMethodCallMutator]MSP[]
} @Override public boolean isFull () { return size >= maxSize ; MST[rv.CRCR2Mutator]MSP[] } @Override public int maxSize () { return maxSize ; } public boolean isScanUntilRemovable () { return scanUntilRemovable ; } @Override public LRUMap < K , V > clone () {
loop = loop . next ; } if ( loop == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] throw new IllegalStateException ( lr_12 + data [ removeIndex ] + lr_13 + previous + lr_6 + key + lr_7 + value + lr_8 + size + lr_9 + maxSize + lr_2 ) ; }
if ( entry == null ) { return null ; } if ( updateToMRU ) { MST[rv.ROR2Mutator]MSP[] moveToMRU ( entry ) ; } return entry . getValue () ; } protected void moveToMRU ( final LinkEntry < K , V > entry ) {
throw new IllegalStateException ( lr_3 + lr_2 ) ; } } @Override protected void updateEntry ( final HashEntry < K , V > entry , final V newValue ) { moveToMRU ( ( LinkEntry < K , V > ) entry ) ; entry . setValue ( newValue ) ; MST[NonVoidMethodCallMutator]MSP[]
if ( entry . after != header ) { modCount ++ ; MST[rv.AOR2Mutator]MSP[] if ( entry . before == null ) { throw new IllegalStateException ( lr_1 + lr_2 ) ; } entry . before . after = entry . after ;
loop = loop . next ; } if ( loop == null ) { throw new IllegalStateException ( MST[rv.UOI2Mutator]MSP[] lr_12 + data [ removeIndex ] + lr_13 + previous + lr_6 + key + lr_7 + value + lr_8 + size + lr_9 + maxSize + lr_2 ) ; }
entry . after . before = entry . before ; entry . after = header ; MST[experimental.MemberVariableMutator]MSP[] entry . before = header . before ; header . before . after = entry ; header . before = entry ; } else if ( entry == header ) {
loop = loop . next ; } if ( loop == null ) { throw new IllegalStateException ( MST[NonVoidMethodCallMutator]MSP[] lr_12 + data [ removeIndex ] + lr_13 + previous + lr_6 + key + lr_7 + value + lr_8 + size + lr_9 + maxSize + lr_2 ) ; }
if ( entry . after != header ) { modCount ++ ; MST[rv.UOI4Mutator]MSP[] if ( entry . before == null ) { throw new IllegalStateException ( lr_1 + lr_2 ) ; } entry . before . after = entry . after ;
reuseMapping ( reuse , hashIndex , hashCode , key , value ) ; MST[rv.UOI3Mutator]MSP[] } else { super . addMapping ( hashIndex , hashCode , key , value ) ; } } else { super . addMapping ( hashIndex , hashCode , key , value ) ; } }
loop = loop . next ; } if ( loop == null ) { throw new IllegalStateException ( MST[rv.UOI2Mutator]MSP[] lr_12 + data [ removeIndex ] + lr_13 + previous + lr_6 + key + lr_7 + value + lr_8 + size + lr_9 + maxSize + lr_2 ) ; }
if ( scanUntilRemovable ) { MST[NegateConditionalsMutator]MSP[] while ( reuse != header && reuse != null ) { if ( removeLRU ( reuse ) ) { removeLRUEntry = true ; break; } reuse = reuse . after ; } if ( reuse == null ) { throw new IllegalStateException (
modCount ++ ; removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException ( MST[rv.CRCR3Mutator]MSP[]
if ( scanUntilRemovable ) { while ( reuse != header && reuse != null ) { if ( removeLRU ( reuse ) ) { MST[rv.ROR1Mutator]MSP[] removeLRUEntry = true ; break; } reuse = reuse . after ; } if ( reuse == null ) { throw new IllegalStateException (
protected void doReadObject ( final ObjectInputStream in ) throws IOException , ClassNotFoundException { maxSize = in . readInt () ; MST[NonVoidMethodCallMutator]MSP[] super . doReadObject ( in ) ; }
if ( entry . after != header ) { modCount ++ ; MST[experimental.MemberVariableMutator]MSP[] if ( entry . before == null ) { throw new IllegalStateException ( lr_1 + lr_2 ) ; } entry . before . after = entry . after ;
loop = loop . next ; } if ( loop == null ) { throw new IllegalStateException ( MST[experimental.NakedReceiverMutator]MSP[] lr_12 + data [ removeIndex ] + lr_13 + previous + lr_6 + key + lr_7 + value + lr_8 + size + lr_9 + maxSize + lr_2 ) ; }
} @Override public boolean isFull () { return size >= maxSize ; MST[rv.CRCR3Mutator]MSP[] } @Override public int maxSize () { return maxSize ; } public boolean isScanUntilRemovable () { return scanUntilRemovable ; } @Override public LRUMap < K , V > clone () {
modCount ++ ; removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException ( MST[experimental.NakedReceiverMutator]MSP[]
if ( reuse == null ) { MST[rv.ROR5Mutator]MSP[] throw new IllegalStateException ( lr_11 + header . after + lr_5 + header . before + lr_6 + key + lr_7 + value + lr_8 + size + lr_9 + maxSize + lr_10 ) ; }
loop = loop . next ; } if ( loop == null ) { throw new IllegalStateException ( MST[NonVoidMethodCallMutator]MSP[] lr_12 + data [ removeIndex ] + lr_13 + previous + lr_6 + key + lr_7 + value + lr_8 + size + lr_9 + maxSize + lr_2 ) ; }
} @Override protected void addMapping ( final int hashIndex , final int hashCode , final K key , final V value ) { if ( isFull () ) { MST[rv.ROR2Mutator]MSP[] LinkEntry < K , V > reuse = header . after ; boolean removeLRUEntry = false ;
final HashEntry < K , V > [] tmp = data ; HashEntry < K , V > loop = tmp [ removeIndex ] ; HashEntry < K , V > previous = null ; while ( loop != entry && loop != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] previous = loop ;
protected void reuseMapping ( final LinkEntry < K , V > entry , final int hashIndex , final int hashCode , final K key , final V value ) { try { final int removeIndex = hashIndex ( entry . hashCode , data . length ) ; MST[ArgumentPropagationMutator]MSP[]
} @Override public boolean isFull () { return size >= maxSize ; MST[rv.UOI3Mutator]MSP[] } @Override public int maxSize () { return maxSize ; } public boolean isScanUntilRemovable () { return scanUntilRemovable ; } @Override public LRUMap < K , V > clone () {
lr_14 + entry + lr_15 + ( entry == header ) + lr_6 + key + lr_7 + value + lr_8 + size + lr_9 + maxSize + lr_2 ) ; } } protected boolean removeLRU ( final LinkEntry < K , V > entry ) { return true ; MST[rv.CRCR5Mutator]MSP[]
reuseMapping ( reuse , hashIndex , hashCode , key , value ) ; MST[rv.UOI2Mutator]MSP[] } else { super . addMapping ( hashIndex , hashCode , key , value ) ; } } else { super . addMapping ( hashIndex , hashCode , key , value ) ; } }
if ( scanUntilRemovable ) { while ( reuse != header && reuse != null ) { MST[NegateConditionalsMutator]MSP[] if ( removeLRU ( reuse ) ) { removeLRUEntry = true ; break; } reuse = reuse . after ; } if ( reuse == null ) { throw new IllegalStateException (
loop = loop . next ; } if ( loop == null ) { throw new IllegalStateException ( MST[experimental.NakedReceiverMutator]MSP[] lr_12 + data [ removeIndex ] + lr_13 + previous + lr_6 + key + lr_7 + value + lr_8 + size + lr_9 + maxSize + lr_2 ) ; }
} @Override public boolean isFull () { return size >= maxSize ; } @Override public int maxSize () { return maxSize ; } public boolean isScanUntilRemovable () { return scanUntilRemovable ; MST[BooleanFalseReturnValsMutator]MSP[] } @Override public LRUMap < K , V > clone () {
if ( scanUntilRemovable ) { while ( reuse != header && reuse != null ) { if ( removeLRU ( reuse ) ) { removeLRUEntry = true ; break; } reuse = reuse . after ; } if ( reuse == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] throw new IllegalStateException (
} @Override public boolean isFull () { return size >= maxSize ; } @Override public int maxSize () { return maxSize ; MST[rv.UOI3Mutator]MSP[] } public boolean isScanUntilRemovable () { return scanUntilRemovable ; } @Override public LRUMap < K , V > clone () {
lr_4 + header . after + lr_5 + header . before + lr_6 + key + lr_7 + value + lr_8 + size + lr_9 + maxSize + lr_10 ) ; } } else { removeLRUEntry = removeLRU ( reuse ) ; } if ( removeLRUEntry ) { MST[rv.UOI1Mutator]MSP[]
@Override public V get ( final Object key ) { return get ( key , true ) ; MST[ReturnValsMutator]MSP[] } public V get ( final Object key , final boolean updateToMRU ) { final LinkEntry < K , V > entry = getEntry ( key ) ;
if ( entry . after != header ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] modCount ++ ; if ( entry . before == null ) { throw new IllegalStateException ( lr_1 + lr_2 ) ; } entry . before . after = entry . after ;
modCount ++ ; MST[MathMutator]MSP[] removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException (
modCount ++ ; removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException ( MST[InlineConstantMutator]MSP[]
if ( entry == null ) { return null ; } if ( updateToMRU ) { moveToMRU ( entry ) ; } return entry . getValue () ; MST[NullReturnValsMutator]MSP[] } protected void moveToMRU ( final LinkEntry < K , V > entry ) {
if ( scanUntilRemovable ) { while ( reuse != header && reuse != null ) { if ( removeLRU ( reuse ) ) { removeLRUEntry = true ; break; } reuse = reuse . after ; } if ( reuse == null ) { MST[rv.ROR5Mutator]MSP[] throw new IllegalStateException (
reuseMapping ( reuse , hashIndex , hashCode , key , value ) ; } else { super . addMapping ( hashIndex , hashCode , key , value ) ; } } else { super . addMapping ( hashIndex , hashCode , key , value ) ; MST[rv.ABSMutator]MSP[] } }
loop = loop . next ; } if ( loop == null ) { throw new IllegalStateException ( MST[rv.ABSMutator]MSP[] lr_12 + data [ removeIndex ] + lr_13 + previous + lr_6 + key + lr_7 + value + lr_8 + size + lr_9 + maxSize + lr_2 ) ; }
modCount ++ ; MST[rv.UOI1Mutator]MSP[] removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException (
lr_4 + header . after + lr_5 + header . before + lr_6 + key + lr_7 + value + lr_8 + size + lr_9 + maxSize + lr_10 ) ; } } else { removeLRUEntry = removeLRU ( reuse ) ; } if ( removeLRUEntry ) { MST[rv.ROR2Mutator]MSP[]
} @Override protected void addMapping ( final int hashIndex , final int hashCode , final K key , final V value ) { if ( isFull () ) { LinkEntry < K , V > reuse = header . after ; boolean removeLRUEntry = false ; MST[InlineConstantMutator]MSP[]
modCount ++ ; removeEntry ( entry , removeIndex , previous ) ; MST[rv.UOI3Mutator]MSP[] reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException (
modCount ++ ; removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException ( MST[rv.ABSMutator]MSP[]
final HashEntry < K , V > [] tmp = data ; HashEntry < K , V > loop = tmp [ removeIndex ] ; MST[rv.UOI4Mutator]MSP[] HashEntry < K , V > previous = null ; while ( loop != entry && loop != null ) { previous = loop ;
} @Override protected void addMapping ( final int hashIndex , final int hashCode , final K key , final V value ) { if ( isFull () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] LinkEntry < K , V > reuse = header . after ; boolean removeLRUEntry = false ;
} @Override protected void addMapping ( final int hashIndex , final int hashCode , final K key , final V value ) { if ( isFull () ) { MST[rv.ROR1Mutator]MSP[] LinkEntry < K , V > reuse = header . after ; boolean removeLRUEntry = false ;
} @Override protected void addMapping ( final int hashIndex , final int hashCode , final K key , final V value ) { if ( isFull () ) { MST[rv.ROR5Mutator]MSP[] LinkEntry < K , V > reuse = header . after ; boolean removeLRUEntry = false ;
final HashEntry < K , V > [] tmp = data ; HashEntry < K , V > loop = tmp [ removeIndex ] ; MST[rv.UOI2Mutator]MSP[] HashEntry < K , V > previous = null ; while ( loop != entry && loop != null ) { previous = loop ;
final HashEntry < K , V > [] tmp = data ; HashEntry < K , V > loop = tmp [ removeIndex ] ; HashEntry < K , V > previous = null ; while ( loop != entry && loop != null ) { MST[NegateConditionalsMutator]MSP[] previous = loop ;
lr_14 + entry + lr_15 + ( entry == header ) + lr_6 + key + lr_7 + value + lr_8 + size + lr_9 + maxSize + lr_2 ) ; } } protected boolean removeLRU ( final LinkEntry < K , V > entry ) { return true ; MST[ReturnValsMutator]MSP[]
entry . after . before = entry . before ; entry . after = header ; entry . before = header . before ; header . before . after = entry ; MST[experimental.MemberVariableMutator]MSP[] header . before = entry ; } else if ( entry == header ) {
if ( entry . after != header ) { MST[NegateConditionalsMutator]MSP[] modCount ++ ; if ( entry . before == null ) { throw new IllegalStateException ( lr_1 + lr_2 ) ; } entry . before . after = entry . after ;
modCount ++ ; removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException ( MST[experimental.NakedReceiverMutator]MSP[]
} @Override public boolean isFull () { return size >= maxSize ; MST[ConditionalsBoundaryMutator]MSP[] } @Override public int maxSize () { return maxSize ; } public boolean isScanUntilRemovable () { return scanUntilRemovable ; } @Override public LRUMap < K , V > clone () {
if ( entry == null ) { return null ; } if ( updateToMRU ) { MST[NegateConditionalsMutator]MSP[] moveToMRU ( entry ) ; } return entry . getValue () ; } protected void moveToMRU ( final LinkEntry < K , V > entry ) {
protected void reuseMapping ( final LinkEntry < K , V > entry , final int hashIndex , final int hashCode , final K key , final V value ) { try { final int removeIndex = hashIndex ( entry . hashCode , data . length ) ; MST[rv.UOI3Mutator]MSP[]
return ( LRUMap < K , V > ) super . clone () ; } private void writeObject ( final ObjectOutputStream out ) throws IOException { out . defaultWriteObject () ; doWriteObject ( out ) ; MST[VoidMethodCallMutator]MSP[] } private void readObject ( final ObjectInputStream in ) throws IOException , ClassNotFoundException {
modCount ++ ; removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException ( MST[experimental.NakedReceiverMutator]MSP[]
modCount ++ ; removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException ( MST[NonVoidMethodCallMutator]MSP[]
} @Override public boolean isFull () { return size >= maxSize ; } @Override public int maxSize () { return maxSize ; MST[ReturnValsMutator]MSP[] } public boolean isScanUntilRemovable () { return scanUntilRemovable ; } @Override public LRUMap < K , V > clone () {
if ( reuse == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] throw new IllegalStateException ( lr_11 + header . after + lr_5 + header . before + lr_6 + key + lr_7 + value + lr_8 + size + lr_9 + maxSize + lr_10 ) ; }
modCount ++ ; removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; MST[rv.UOI3Mutator]MSP[] } catch ( final NullPointerException ex ) { throw new IllegalStateException (
final HashEntry < K , V > [] tmp = data ; HashEntry < K , V > loop = tmp [ removeIndex ] ; MST[rv.ABSMutator]MSP[] HashEntry < K , V > previous = null ; while ( loop != entry && loop != null ) { previous = loop ;
modCount ++ ; removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException ( MST[experimental.NakedReceiverMutator]MSP[]
} @Override public boolean isFull () { return size >= maxSize ; MST[rv.CRCR1Mutator]MSP[] } @Override public int maxSize () { return maxSize ; } public boolean isScanUntilRemovable () { return scanUntilRemovable ; } @Override public LRUMap < K , V > clone () {
loop = loop . next ; } if ( loop == null ) { throw new IllegalStateException ( MST[NonVoidMethodCallMutator]MSP[] lr_12 + data [ removeIndex ] + lr_13 + previous + lr_6 + key + lr_7 + value + lr_8 + size + lr_9 + maxSize + lr_2 ) ; }
if ( scanUntilRemovable ) { while ( reuse != header && reuse != null ) { if ( removeLRU ( reuse ) ) { removeLRUEntry = true ; MST[rv.CRCR6Mutator]MSP[] break; } reuse = reuse . after ; } if ( reuse == null ) { throw new IllegalStateException (
modCount ++ ; removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException ( MST[rv.UOI2Mutator]MSP[]
final HashEntry < K , V > [] tmp = data ; HashEntry < K , V > loop = tmp [ removeIndex ] ; HashEntry < K , V > previous = null ; while ( loop != entry && loop != null ) { MST[rv.ROR5Mutator]MSP[] previous = loop ;
modCount ++ ; MST[rv.AOR2Mutator]MSP[] removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException (
loop = loop . next ; } if ( loop == null ) { throw new IllegalStateException ( MST[NonVoidMethodCallMutator]MSP[] lr_12 + data [ removeIndex ] + lr_13 + previous + lr_6 + key + lr_7 + value + lr_8 + size + lr_9 + maxSize + lr_2 ) ; }
loop = loop . next ; } if ( loop == null ) { throw new IllegalStateException ( MST[rv.UOI2Mutator]MSP[] lr_12 + data [ removeIndex ] + lr_13 + previous + lr_6 + key + lr_7 + value + lr_8 + size + lr_9 + maxSize + lr_2 ) ; }
in . defaultReadObject () ; doReadObject ( in ) ; } @Override protected void doWriteObject ( final ObjectOutputStream out ) throws IOException { out . writeInt ( maxSize ) ; MST[rv.UOI3Mutator]MSP[] super . doWriteObject ( out ) ; } @Override
if ( entry == null ) { return null ; } if ( updateToMRU ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] moveToMRU ( entry ) ; } return entry . getValue () ; } protected void moveToMRU ( final LinkEntry < K , V > entry ) {
} @Override public boolean isFull () { return size >= maxSize ; MST[rv.UOI3Mutator]MSP[] } @Override public int maxSize () { return maxSize ; } public boolean isScanUntilRemovable () { return scanUntilRemovable ; } @Override public LRUMap < K , V > clone () {
if ( scanUntilRemovable ) { MST[rv.ROR5Mutator]MSP[] while ( reuse != header && reuse != null ) { if ( removeLRU ( reuse ) ) { removeLRUEntry = true ; break; } reuse = reuse . after ; } if ( reuse == null ) { throw new IllegalStateException (
loop = loop . next ; } if ( loop == null ) { MST[NegateConditionalsMutator]MSP[] throw new IllegalStateException ( lr_12 + data [ removeIndex ] + lr_13 + previous + lr_6 + key + lr_7 + value + lr_8 + size + lr_9 + maxSize + lr_2 ) ; }
if ( entry == null ) { return null ; } if ( updateToMRU ) { MST[rv.ROR3Mutator]MSP[] moveToMRU ( entry ) ; } return entry . getValue () ; } protected void moveToMRU ( final LinkEntry < K , V > entry ) {
if ( entry == null ) { return null ; } if ( updateToMRU ) { MST[rv.ROR4Mutator]MSP[] moveToMRU ( entry ) ; } return entry . getValue () ; } protected void moveToMRU ( final LinkEntry < K , V > entry ) {
if ( reuse == null ) { MST[NegateConditionalsMutator]MSP[] throw new IllegalStateException ( lr_11 + header . after + lr_5 + header . before + lr_6 + key + lr_7 + value + lr_8 + size + lr_9 + maxSize + lr_10 ) ; }
modCount ++ ; removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; MST[rv.UOI1Mutator]MSP[] addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException (
if ( entry == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return null ; } if ( updateToMRU ) { moveToMRU ( entry ) ; } return entry . getValue () ; } protected void moveToMRU ( final LinkEntry < K , V > entry ) {
if ( entry . after != header ) { modCount ++ ; MST[rv.CRCR4Mutator]MSP[] if ( entry . before == null ) { throw new IllegalStateException ( lr_1 + lr_2 ) ; } entry . before . after = entry . after ;
} @Override public boolean isFull () { return size >= maxSize ; } @Override public int maxSize () { return maxSize ; MST[PrimitiveReturnsMutator]MSP[] } public boolean isScanUntilRemovable () { return scanUntilRemovable ; } @Override public LRUMap < K , V > clone () {
if ( scanUntilRemovable ) { while ( reuse != header && reuse != null ) { if ( removeLRU ( reuse ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] removeLRUEntry = true ; break; } reuse = reuse . after ; } if ( reuse == null ) { throw new IllegalStateException (
} @Override public boolean isFull () { return size >= maxSize ; MST[rv.CRCR6Mutator]MSP[] } @Override public int maxSize () { return maxSize ; } public boolean isScanUntilRemovable () { return scanUntilRemovable ; } @Override public LRUMap < K , V > clone () {
reuseMapping ( reuse , hashIndex , hashCode , key , value ) ; } else { super . addMapping ( hashIndex , hashCode , key , value ) ; } } else { super . addMapping ( hashIndex , hashCode , key , value ) ; MST[rv.UOI4Mutator]MSP[] } }
modCount ++ ; removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException ( MST[ConstructorCallMutator]MSP[]
in . defaultReadObject () ; doReadObject ( in ) ; } @Override protected void doWriteObject ( final ObjectOutputStream out ) throws IOException { out . writeInt ( maxSize ) ; MST[rv.UOI4Mutator]MSP[] super . doWriteObject ( out ) ; } @Override
final HashEntry < K , V > [] tmp = data ; HashEntry < K , V > loop = tmp [ removeIndex ] ; HashEntry < K , V > previous = null ; while ( loop != entry && loop != null ) { MST[NegateConditionalsMutator]MSP[] previous = loop ;
return ( LRUMap < K , V > ) super . clone () ; MST[NullReturnValsMutator]MSP[] } private void writeObject ( final ObjectOutputStream out ) throws IOException { out . defaultWriteObject () ; doWriteObject ( out ) ; } private void readObject ( final ObjectInputStream in ) throws IOException , ClassNotFoundException {
if ( entry . after != header ) { modCount ++ ; MST[rv.UOI3Mutator]MSP[] if ( entry . before == null ) { throw new IllegalStateException ( lr_1 + lr_2 ) ; } entry . before . after = entry . after ;
reuseMapping ( reuse , hashIndex , hashCode , key , value ) ; MST[rv.UOI2Mutator]MSP[] } else { super . addMapping ( hashIndex , hashCode , key , value ) ; } } else { super . addMapping ( hashIndex , hashCode , key , value ) ; } }
} @Override public boolean isFull () { return size >= maxSize ; } @Override public int maxSize () { return maxSize ; MST[rv.ABSMutator]MSP[] } public boolean isScanUntilRemovable () { return scanUntilRemovable ; } @Override public LRUMap < K , V > clone () {
} @Override protected void addMapping ( final int hashIndex , final int hashCode , final K key , final V value ) { if ( isFull () ) { LinkEntry < K , V > reuse = header . after ; boolean removeLRUEntry = false ; MST[rv.CRCR3Mutator]MSP[]
@Override public V get ( final Object key ) { return get ( key , true ) ; } public V get ( final Object key , final boolean updateToMRU ) { final LinkEntry < K , V > entry = getEntry ( key ) ; MST[NonVoidMethodCallMutator]MSP[]
if ( entry == null ) { return null ; } if ( updateToMRU ) { MST[rv.UOI1Mutator]MSP[] moveToMRU ( entry ) ; } return entry . getValue () ; } protected void moveToMRU ( final LinkEntry < K , V > entry ) {
protected void reuseMapping ( final LinkEntry < K , V > entry , final int hashIndex , final int hashCode , final K key , final V value ) { try { final int removeIndex = hashIndex ( entry . hashCode , data . length ) ; MST[rv.UOI4Mutator]MSP[]
modCount ++ ; MST[rv.CRCR3Mutator]MSP[] removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException (
@Override public V get ( final Object key ) { return get ( key , true ) ; MST[rv.CRCR6Mutator]MSP[] } public V get ( final Object key , final boolean updateToMRU ) { final LinkEntry < K , V > entry = getEntry ( key ) ;
} @Override public boolean isFull () { return size >= maxSize ; MST[rv.ROR1Mutator]MSP[] } @Override public int maxSize () { return maxSize ; } public boolean isScanUntilRemovable () { return scanUntilRemovable ; } @Override public LRUMap < K , V > clone () {
modCount ++ ; removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException ( MST[experimental.NakedReceiverMutator]MSP[]
modCount ++ ; removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; MST[rv.UOI1Mutator]MSP[] addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException (
} @Override public boolean isFull () { return size >= maxSize ; MST[rv.ABSMutator]MSP[] } @Override public int maxSize () { return maxSize ; } public boolean isScanUntilRemovable () { return scanUntilRemovable ; } @Override public LRUMap < K , V > clone () {
if ( scanUntilRemovable ) { while ( reuse != header && reuse != null ) { if ( removeLRU ( reuse ) ) { MST[rv.ROR5Mutator]MSP[] removeLRUEntry = true ; break; } reuse = reuse . after ; } if ( reuse == null ) { throw new IllegalStateException (
modCount ++ ; MST[experimental.MemberVariableMutator]MSP[] removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException (
modCount ++ ; removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; MST[rv.UOI4Mutator]MSP[] } catch ( final NullPointerException ex ) { throw new IllegalStateException (
modCount ++ ; removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; MST[VoidMethodCallMutator]MSP[] addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException (
if ( scanUntilRemovable ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] while ( reuse != header && reuse != null ) { if ( removeLRU ( reuse ) ) { removeLRUEntry = true ; break; } reuse = reuse . after ; } if ( reuse == null ) { throw new IllegalStateException (
reuseMapping ( reuse , hashIndex , hashCode , key , value ) ; } else { super . addMapping ( hashIndex , hashCode , key , value ) ; } } else { super . addMapping ( hashIndex , hashCode , key , value ) ; MST[rv.ABSMutator]MSP[] } }
loop = loop . next ; } if ( loop == null ) { throw new IllegalStateException ( MST[NonVoidMethodCallMutator]MSP[] lr_12 + data [ removeIndex ] + lr_13 + previous + lr_6 + key + lr_7 + value + lr_8 + size + lr_9 + maxSize + lr_2 ) ; }
modCount ++ ; removeEntry ( entry , removeIndex , previous ) ; MST[rv.UOI4Mutator]MSP[] reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException (
if ( entry . after != header ) { modCount ++ ; MST[rv.AOR3Mutator]MSP[] if ( entry . before == null ) { throw new IllegalStateException ( lr_1 + lr_2 ) ; } entry . before . after = entry . after ;
reuseMapping ( reuse , hashIndex , hashCode , key , value ) ; } else { super . addMapping ( hashIndex , hashCode , key , value ) ; } } else { super . addMapping ( hashIndex , hashCode , key , value ) ; MST[rv.UOI4Mutator]MSP[] } }
final HashEntry < K , V > [] tmp = data ; HashEntry < K , V > loop = tmp [ removeIndex ] ; MST[rv.UOI3Mutator]MSP[] HashEntry < K , V > previous = null ; while ( loop != entry && loop != null ) { previous = loop ;
loop = loop . next ; } if ( loop == null ) { throw new IllegalStateException ( MST[rv.UOI1Mutator]MSP[] lr_12 + data [ removeIndex ] + lr_13 + previous + lr_6 + key + lr_7 + value + lr_8 + size + lr_9 + maxSize + lr_2 ) ; }
if ( scanUntilRemovable ) { while ( reuse != header && reuse != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] if ( removeLRU ( reuse ) ) { removeLRUEntry = true ; break; } reuse = reuse . after ; } if ( reuse == null ) { throw new IllegalStateException (
in . defaultReadObject () ; doReadObject ( in ) ; } @Override protected void doWriteObject ( final ObjectOutputStream out ) throws IOException { out . writeInt ( maxSize ) ; MST[rv.ABSMutator]MSP[] super . doWriteObject ( out ) ; } @Override
