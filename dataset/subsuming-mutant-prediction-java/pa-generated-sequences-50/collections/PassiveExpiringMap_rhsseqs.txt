return now + timeToLiveMillis ; } return - 1L ; MST[PrimitiveReturnsMutator]MSP[N] } private static long validateAndConvertToMillis ( final long timeToLive , final TimeUnit timeUnit ) { Objects . requireNonNull ( timeUnit , lr_1 ) ; return TimeUnit . MILLISECONDS . convert ( timeToLive , timeUnit ) ; } @Override
@Override public long expirationTime ( final K key , final V value ) { if ( timeToLiveMillis >= 0L ) { final long now = System . currentTimeMillis () ; if ( now > Long . MAX_VALUE - timeToLiveMillis ) { MST[rv.UOI4Mutator]MSP[S] return - 1 ; }
return now + timeToLiveMillis ; MST[rv.AOR1Mutator]MSP[S] } return - 1L ; } private static long validateAndConvertToMillis ( final long timeToLive , final TimeUnit timeUnit ) { Objects . requireNonNull ( timeUnit , lr_1 ) ; return TimeUnit . MILLISECONDS . convert ( timeToLive , timeUnit ) ; } @Override
@Override public long expirationTime ( final K key , final V value ) { if ( timeToLiveMillis >= 0L ) { MST[rv.ABSMutator]MSP[S] final long now = System . currentTimeMillis () ; if ( now > Long . MAX_VALUE - timeToLiveMillis ) { return - 1 ; }
@Override public long expirationTime ( final K key , final V value ) { if ( timeToLiveMillis >= 0L ) { final long now = System . currentTimeMillis () ; if ( now > Long . MAX_VALUE - timeToLiveMillis ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[S] return - 1 ; }
return now + timeToLiveMillis ; MST[rv.AOR2Mutator]MSP[S] } return - 1L ; } private static long validateAndConvertToMillis ( final long timeToLive , final TimeUnit timeUnit ) { Objects . requireNonNull ( timeUnit , lr_1 ) ; return TimeUnit . MILLISECONDS . convert ( timeToLive , timeUnit ) ; } @Override
return now + timeToLiveMillis ; MST[rv.AOR3Mutator]MSP[N] } return - 1L ; } private static long validateAndConvertToMillis ( final long timeToLive , final TimeUnit timeUnit ) { Objects . requireNonNull ( timeUnit , lr_1 ) ; return TimeUnit . MILLISECONDS . convert ( timeToLive , timeUnit ) ; } @Override
return now + timeToLiveMillis ; MST[rv.AOR4Mutator]MSP[N] } return - 1L ; } private static long validateAndConvertToMillis ( final long timeToLive , final TimeUnit timeUnit ) { Objects . requireNonNull ( timeUnit , lr_1 ) ; return TimeUnit . MILLISECONDS . convert ( timeToLive , timeUnit ) ; } @Override
@Override public long expirationTime ( final K key , final V value ) { if ( timeToLiveMillis >= 0L ) { final long now = System . currentTimeMillis () ; MST[NonVoidMethodCallMutator]MSP[N] if ( now > Long . MAX_VALUE - timeToLiveMillis ) { return - 1 ; }
@Override public long expirationTime ( final K key , final V value ) { if ( timeToLiveMillis >= 0L ) { final long now = System . currentTimeMillis () ; if ( now > Long . MAX_VALUE - timeToLiveMillis ) { MST[rv.UOI1Mutator]MSP[S] return - 1 ; }
@Override public long expirationTime ( final K key , final V value ) { if ( timeToLiveMillis >= 0L ) { final long now = System . currentTimeMillis () ; if ( now > Long . MAX_VALUE - timeToLiveMillis ) { MST[NegateConditionalsMutator]MSP[N] return - 1 ; }
@Override public long expirationTime ( final K key , final V value ) { if ( timeToLiveMillis >= 0L ) { final long now = System . currentTimeMillis () ; if ( now > Long . MAX_VALUE - timeToLiveMillis ) { MST[rv.UOI2Mutator]MSP[S] return - 1 ; }
@Override public long expirationTime ( final K key , final V value ) { if ( timeToLiveMillis >= 0L ) { final long now = System . currentTimeMillis () ; if ( now > Long . MAX_VALUE - timeToLiveMillis ) { MST[rv.UOI3Mutator]MSP[S] return - 1 ; }
return now + timeToLiveMillis ; MST[rv.ABSMutator]MSP[S] } return - 1L ; } private static long validateAndConvertToMillis ( final long timeToLive , final TimeUnit timeUnit ) { Objects . requireNonNull ( timeUnit , lr_1 ) ; return TimeUnit . MILLISECONDS . convert ( timeToLive , timeUnit ) ; } @Override
@Override public long expirationTime ( final K key , final V value ) { if ( timeToLiveMillis >= 0L ) { final long now = System . currentTimeMillis () ; if ( now > Long . MAX_VALUE - timeToLiveMillis ) { MST[rv.AOD1Mutator]MSP[N] return - 1 ; }
@Override public long expirationTime ( final K key , final V value ) { if ( timeToLiveMillis >= 0L ) { MST[rv.CRCR6Mutator]MSP[S] final long now = System . currentTimeMillis () ; if ( now > Long . MAX_VALUE - timeToLiveMillis ) { return - 1 ; }
return now + timeToLiveMillis ; MST[MathMutator]MSP[S] } return - 1L ; } private static long validateAndConvertToMillis ( final long timeToLive , final TimeUnit timeUnit ) { Objects . requireNonNull ( timeUnit , lr_1 ) ; return TimeUnit . MILLISECONDS . convert ( timeToLive , timeUnit ) ; } @Override
@Override public long expirationTime ( final K key , final V value ) { if ( timeToLiveMillis >= 0L ) { final long now = System . currentTimeMillis () ; if ( now > Long . MAX_VALUE - timeToLiveMillis ) { MST[rv.UOI2Mutator]MSP[S] return - 1 ; }
@Override public long expirationTime ( final K key , final V value ) { if ( timeToLiveMillis >= 0L ) { MST[rv.UOI4Mutator]MSP[S] final long now = System . currentTimeMillis () ; if ( now > Long . MAX_VALUE - timeToLiveMillis ) { return - 1 ; }
@Override public long expirationTime ( final K key , final V value ) { if ( timeToLiveMillis >= 0L ) { final long now = System . currentTimeMillis () ; if ( now > Long . MAX_VALUE - timeToLiveMillis ) { MST[rv.UOI1Mutator]MSP[S] return - 1 ; }
@Override public long expirationTime ( final K key , final V value ) { if ( timeToLiveMillis >= 0L ) { MST[InlineConstantMutator]MSP[S] final long now = System . currentTimeMillis () ; if ( now > Long . MAX_VALUE - timeToLiveMillis ) { return - 1 ; }
@Override public long expirationTime ( final K key , final V value ) { if ( timeToLiveMillis >= 0L ) { MST[rv.UOI3Mutator]MSP[N] final long now = System . currentTimeMillis () ; if ( now > Long . MAX_VALUE - timeToLiveMillis ) { return - 1 ; }
return now + timeToLiveMillis ; } return - 1L ; MST[rv.CRCR1Mutator]MSP[N] } private static long validateAndConvertToMillis ( final long timeToLive , final TimeUnit timeUnit ) { Objects . requireNonNull ( timeUnit , lr_1 ) ; return TimeUnit . MILLISECONDS . convert ( timeToLive , timeUnit ) ; } @Override
@Override public long expirationTime ( final K key , final V value ) { if ( timeToLiveMillis >= 0L ) { final long now = System . currentTimeMillis () ; if ( now > Long . MAX_VALUE - timeToLiveMillis ) { MST[MathMutator]MSP[S] return - 1 ; }
@Override public long expirationTime ( final K key , final V value ) { if ( timeToLiveMillis >= 0L ) { final long now = System . currentTimeMillis () ; if ( now > Long . MAX_VALUE - timeToLiveMillis ) { MST[rv.AOR4Mutator]MSP[N] return - 1 ; }
@Override public long expirationTime ( final K key , final V value ) { if ( timeToLiveMillis >= 0L ) { final long now = System . currentTimeMillis () ; if ( now > Long . MAX_VALUE - timeToLiveMillis ) { MST[rv.ROR5Mutator]MSP[N] return - 1 ; }
return now + timeToLiveMillis ; MST[rv.UOI4Mutator]MSP[S] } return - 1L ; } private static long validateAndConvertToMillis ( final long timeToLive , final TimeUnit timeUnit ) { Objects . requireNonNull ( timeUnit , lr_1 ) ; return TimeUnit . MILLISECONDS . convert ( timeToLive , timeUnit ) ; } @Override
return now + timeToLiveMillis ; MST[rv.UOI3Mutator]MSP[S] } return - 1L ; } private static long validateAndConvertToMillis ( final long timeToLive , final TimeUnit timeUnit ) { Objects . requireNonNull ( timeUnit , lr_1 ) ; return TimeUnit . MILLISECONDS . convert ( timeToLive , timeUnit ) ; } @Override
return now + timeToLiveMillis ; } return - 1L ; MST[rv.CRCR4Mutator]MSP[N] } private static long validateAndConvertToMillis ( final long timeToLive , final TimeUnit timeUnit ) { Objects . requireNonNull ( timeUnit , lr_1 ) ; return TimeUnit . MILLISECONDS . convert ( timeToLive , timeUnit ) ; } @Override
return now + timeToLiveMillis ; } return - 1L ; MST[rv.CRCR5Mutator]MSP[N] } private static long validateAndConvertToMillis ( final long timeToLive , final TimeUnit timeUnit ) { Objects . requireNonNull ( timeUnit , lr_1 ) ; return TimeUnit . MILLISECONDS . convert ( timeToLive , timeUnit ) ; } @Override
@Override public long expirationTime ( final K key , final V value ) { if ( timeToLiveMillis >= 0L ) { final long now = System . currentTimeMillis () ; if ( now > Long . MAX_VALUE - timeToLiveMillis ) { MST[rv.AOR3Mutator]MSP[N] return - 1 ; }
return now + timeToLiveMillis ; MST[rv.UOI2Mutator]MSP[S] } return - 1L ; } private static long validateAndConvertToMillis ( final long timeToLive , final TimeUnit timeUnit ) { Objects . requireNonNull ( timeUnit , lr_1 ) ; return TimeUnit . MILLISECONDS . convert ( timeToLive , timeUnit ) ; } @Override
@Override public long expirationTime ( final K key , final V value ) { if ( timeToLiveMillis >= 0L ) { final long now = System . currentTimeMillis () ; if ( now > Long . MAX_VALUE - timeToLiveMillis ) { MST[rv.ROR2Mutator]MSP[N] return - 1 ; }
return now + timeToLiveMillis ; MST[rv.UOI1Mutator]MSP[S] } return - 1L ; } private static long validateAndConvertToMillis ( final long timeToLive , final TimeUnit timeUnit ) { Objects . requireNonNull ( timeUnit , lr_1 ) ; return TimeUnit . MILLISECONDS . convert ( timeToLive , timeUnit ) ; } @Override
@Override public long expirationTime ( final K key , final V value ) { if ( timeToLiveMillis >= 0L ) { final long now = System . currentTimeMillis () ; if ( now > Long . MAX_VALUE - timeToLiveMillis ) { MST[rv.ROR1Mutator]MSP[S] return - 1 ; }
return now + timeToLiveMillis ; } return - 1L ; MST[ReturnValsMutator]MSP[N] } private static long validateAndConvertToMillis ( final long timeToLive , final TimeUnit timeUnit ) { Objects . requireNonNull ( timeUnit , lr_1 ) ; return TimeUnit . MILLISECONDS . convert ( timeToLive , timeUnit ) ; } @Override
@Override public long expirationTime ( final K key , final V value ) { if ( timeToLiveMillis >= 0L ) { final long now = System . currentTimeMillis () ; if ( now > Long . MAX_VALUE - timeToLiveMillis ) { return - 1 ; MST[rv.CRCR5Mutator]MSP[N] }
@Override public long expirationTime ( final K key , final V value ) { if ( timeToLiveMillis >= 0L ) { MST[rv.CRCR3Mutator]MSP[S] final long now = System . currentTimeMillis () ; if ( now > Long . MAX_VALUE - timeToLiveMillis ) { return - 1 ; }
@Override public long expirationTime ( final K key , final V value ) { if ( timeToLiveMillis >= 0L ) { final long now = System . currentTimeMillis () ; if ( now > Long . MAX_VALUE - timeToLiveMillis ) { return - 1 ; MST[rv.CRCR1Mutator]MSP[N] }
@Override public long expirationTime ( final K key , final V value ) { if ( timeToLiveMillis >= 0L ) { final long now = System . currentTimeMillis () ; if ( now > Long . MAX_VALUE - timeToLiveMillis ) { MST[rv.CRCR5Mutator]MSP[S] return - 1 ; }
@Override public long expirationTime ( final K key , final V value ) { if ( timeToLiveMillis >= 0L ) { final long now = System . currentTimeMillis () ; if ( now > Long . MAX_VALUE - timeToLiveMillis ) { MST[rv.CRCR1Mutator]MSP[S] return - 1 ; }
@Override public long expirationTime ( final K key , final V value ) { if ( timeToLiveMillis >= 0L ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[S] final long now = System . currentTimeMillis () ; if ( now > Long . MAX_VALUE - timeToLiveMillis ) { return - 1 ; }
@Override public long expirationTime ( final K key , final V value ) { if ( timeToLiveMillis >= 0L ) { MST[rv.ROR2Mutator]MSP[S] final long now = System . currentTimeMillis () ; if ( now > Long . MAX_VALUE - timeToLiveMillis ) { return - 1 ; }
@Override public long expirationTime ( final K key , final V value ) { if ( timeToLiveMillis >= 0L ) { MST[rv.ROR3Mutator]MSP[S] final long now = System . currentTimeMillis () ; if ( now > Long . MAX_VALUE - timeToLiveMillis ) { return - 1 ; }
@Override public long expirationTime ( final K key , final V value ) { if ( timeToLiveMillis >= 0L ) { MST[rv.ROR1Mutator]MSP[S] final long now = System . currentTimeMillis () ; if ( now > Long . MAX_VALUE - timeToLiveMillis ) { return - 1 ; }
@Override public long expirationTime ( final K key , final V value ) { if ( timeToLiveMillis >= 0L ) { MST[rv.ROR5Mutator]MSP[S] final long now = System . currentTimeMillis () ; if ( now > Long . MAX_VALUE - timeToLiveMillis ) { return - 1 ; }
@Override public long expirationTime ( final K key , final V value ) { if ( timeToLiveMillis >= 0L ) { MST[rv.ROR4Mutator]MSP[S] final long now = System . currentTimeMillis () ; if ( now > Long . MAX_VALUE - timeToLiveMillis ) { return - 1 ; }
@Override public long expirationTime ( final K key , final V value ) { if ( timeToLiveMillis >= 0L ) { final long now = System . currentTimeMillis () ; if ( now > Long . MAX_VALUE - timeToLiveMillis ) { return - 1 ; MST[ReturnValsMutator]MSP[N] }
@Override public long expirationTime ( final K key , final V value ) { if ( timeToLiveMillis >= 0L ) { final long now = System . currentTimeMillis () ; if ( now > Long . MAX_VALUE - timeToLiveMillis ) { MST[rv.ABSMutator]MSP[N] return - 1 ; }
return now + timeToLiveMillis ; MST[ReturnValsMutator]MSP[S] } return - 1L ; } private static long validateAndConvertToMillis ( final long timeToLive , final TimeUnit timeUnit ) { Objects . requireNonNull ( timeUnit , lr_1 ) ; return TimeUnit . MILLISECONDS . convert ( timeToLive , timeUnit ) ; } @Override
@Override public long expirationTime ( final K key , final V value ) { if ( timeToLiveMillis >= 0L ) { final long now = System . currentTimeMillis () ; if ( now > Long . MAX_VALUE - timeToLiveMillis ) { MST[rv.CRCR4Mutator]MSP[S] return - 1 ; }
return now + timeToLiveMillis ; MST[rv.ABSMutator]MSP[S] } return - 1L ; } private static long validateAndConvertToMillis ( final long timeToLive , final TimeUnit timeUnit ) { Objects . requireNonNull ( timeUnit , lr_1 ) ; return TimeUnit . MILLISECONDS . convert ( timeToLive , timeUnit ) ; } @Override
@Override public long expirationTime ( final K key , final V value ) { if ( timeToLiveMillis >= 0L ) { final long now = System . currentTimeMillis () ; if ( now > Long . MAX_VALUE - timeToLiveMillis ) { return - 1 ; MST[rv.CRCR4Mutator]MSP[N] }
@Override public long expirationTime ( final K key , final V value ) { if ( timeToLiveMillis >= 0L ) { final long now = System . currentTimeMillis () ; if ( now > Long . MAX_VALUE - timeToLiveMillis ) { return - 1 ; MST[rv.CRCR6Mutator]MSP[N] }
return now + timeToLiveMillis ; } return - 1L ; MST[InlineConstantMutator]MSP[N] } private static long validateAndConvertToMillis ( final long timeToLive , final TimeUnit timeUnit ) { Objects . requireNonNull ( timeUnit , lr_1 ) ; return TimeUnit . MILLISECONDS . convert ( timeToLive , timeUnit ) ; } @Override
@Override public long expirationTime ( final K key , final V value ) { if ( timeToLiveMillis >= 0L ) { final long now = System . currentTimeMillis () ; if ( now > Long . MAX_VALUE - timeToLiveMillis ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] return - 1 ; }
@Override public long expirationTime ( final K key , final V value ) { if ( timeToLiveMillis >= 0L ) { final long now = System . currentTimeMillis () ; if ( now > Long . MAX_VALUE - timeToLiveMillis ) { return - 1 ; MST[rv.CRCR2Mutator]MSP[N] }
@Override public long expirationTime ( final K key , final V value ) { if ( timeToLiveMillis >= 0L ) { final long now = System . currentTimeMillis () ; if ( now > Long . MAX_VALUE - timeToLiveMillis ) { MST[rv.CRCR2Mutator]MSP[S] return - 1 ; }
@Override public long expirationTime ( final K key , final V value ) { if ( timeToLiveMillis >= 0L ) { final long now = System . currentTimeMillis () ; if ( now > Long . MAX_VALUE - timeToLiveMillis ) { MST[rv.CRCR6Mutator]MSP[S] return - 1 ; }
@Override public long expirationTime ( final K key , final V value ) { if ( timeToLiveMillis >= 0L ) { MST[rv.UOI1Mutator]MSP[S] final long now = System . currentTimeMillis () ; if ( now > Long . MAX_VALUE - timeToLiveMillis ) { return - 1 ; }
@Override public long expirationTime ( final K key , final V value ) { if ( timeToLiveMillis >= 0L ) { final long now = System . currentTimeMillis () ; if ( now > Long . MAX_VALUE - timeToLiveMillis ) { MST[rv.UOI3Mutator]MSP[S] return - 1 ; }
@Override public long expirationTime ( final K key , final V value ) { if ( timeToLiveMillis >= 0L ) { MST[NegateConditionalsMutator]MSP[S] final long now = System . currentTimeMillis () ; if ( now > Long . MAX_VALUE - timeToLiveMillis ) { return - 1 ; }
@Override public long expirationTime ( final K key , final V value ) { if ( timeToLiveMillis >= 0L ) { final long now = System . currentTimeMillis () ; if ( now > Long . MAX_VALUE - timeToLiveMillis ) { MST[rv.UOI4Mutator]MSP[S] return - 1 ; }
@Override public long expirationTime ( final K key , final V value ) { if ( timeToLiveMillis >= 0L ) { final long now = System . currentTimeMillis () ; if ( now > Long . MAX_VALUE - timeToLiveMillis ) { MST[InlineConstantMutator]MSP[S] return - 1 ; }
return now + timeToLiveMillis ; } return - 1L ; MST[rv.CRCR2Mutator]MSP[N] } private static long validateAndConvertToMillis ( final long timeToLive , final TimeUnit timeUnit ) { Objects . requireNonNull ( timeUnit , lr_1 ) ; return TimeUnit . MILLISECONDS . convert ( timeToLive , timeUnit ) ; } @Override
@Override public long expirationTime ( final K key , final V value ) { if ( timeToLiveMillis >= 0L ) { final long now = System . currentTimeMillis () ; if ( now > Long . MAX_VALUE - timeToLiveMillis ) { MST[ConditionalsBoundaryMutator]MSP[S] return - 1 ; }
@Override public long expirationTime ( final K key , final V value ) { if ( timeToLiveMillis >= 0L ) { MST[rv.UOI2Mutator]MSP[S] final long now = System . currentTimeMillis () ; if ( now > Long . MAX_VALUE - timeToLiveMillis ) { return - 1 ; }
return now + timeToLiveMillis ; MST[rv.AOD2Mutator]MSP[N] } return - 1L ; } private static long validateAndConvertToMillis ( final long timeToLive , final TimeUnit timeUnit ) { Objects . requireNonNull ( timeUnit , lr_1 ) ; return TimeUnit . MILLISECONDS . convert ( timeToLive , timeUnit ) ; } @Override
return now + timeToLiveMillis ; } return - 1L ; MST[rv.CRCR6Mutator]MSP[N] } private static long validateAndConvertToMillis ( final long timeToLive , final TimeUnit timeUnit ) { Objects . requireNonNull ( timeUnit , lr_1 ) ; return TimeUnit . MILLISECONDS . convert ( timeToLive , timeUnit ) ; } @Override
@Override public long expirationTime ( final K key , final V value ) { if ( timeToLiveMillis >= 0L ) { final long now = System . currentTimeMillis () ; if ( now > Long . MAX_VALUE - timeToLiveMillis ) { return - 1 ; MST[PrimitiveReturnsMutator]MSP[N] }
return now + timeToLiveMillis ; MST[rv.UOI2Mutator]MSP[S] } return - 1L ; } private static long validateAndConvertToMillis ( final long timeToLive , final TimeUnit timeUnit ) { Objects . requireNonNull ( timeUnit , lr_1 ) ; return TimeUnit . MILLISECONDS . convert ( timeToLive , timeUnit ) ; } @Override
return now + timeToLiveMillis ; MST[rv.AOD1Mutator]MSP[S] } return - 1L ; } private static long validateAndConvertToMillis ( final long timeToLive , final TimeUnit timeUnit ) { Objects . requireNonNull ( timeUnit , lr_1 ) ; return TimeUnit . MILLISECONDS . convert ( timeToLive , timeUnit ) ; } @Override
@Override public long expirationTime ( final K key , final V value ) { if ( timeToLiveMillis >= 0L ) { final long now = System . currentTimeMillis () ; if ( now > Long . MAX_VALUE - timeToLiveMillis ) { MST[rv.AOR2Mutator]MSP[S] return - 1 ; }
@Override public long expirationTime ( final K key , final V value ) { if ( timeToLiveMillis >= 0L ) { final long now = System . currentTimeMillis () ; if ( now > Long . MAX_VALUE - timeToLiveMillis ) { MST[rv.ABSMutator]MSP[S] return - 1 ; }
return now + timeToLiveMillis ; MST[rv.UOI4Mutator]MSP[S] } return - 1L ; } private static long validateAndConvertToMillis ( final long timeToLive , final TimeUnit timeUnit ) { Objects . requireNonNull ( timeUnit , lr_1 ) ; return TimeUnit . MILLISECONDS . convert ( timeToLive , timeUnit ) ; } @Override
return now + timeToLiveMillis ; MST[rv.UOI3Mutator]MSP[S] } return - 1L ; } private static long validateAndConvertToMillis ( final long timeToLive , final TimeUnit timeUnit ) { Objects . requireNonNull ( timeUnit , lr_1 ) ; return TimeUnit . MILLISECONDS . convert ( timeToLive , timeUnit ) ; } @Override
@Override public long expirationTime ( final K key , final V value ) { if ( timeToLiveMillis >= 0L ) { final long now = System . currentTimeMillis () ; if ( now > Long . MAX_VALUE - timeToLiveMillis ) { MST[rv.AOR1Mutator]MSP[S] return - 1 ; }
@Override public long expirationTime ( final K key , final V value ) { if ( timeToLiveMillis >= 0L ) { final long now = System . currentTimeMillis () ; if ( now > Long . MAX_VALUE - timeToLiveMillis ) { MST[rv.ROR3Mutator]MSP[N] return - 1 ; }
return now + timeToLiveMillis ; MST[rv.UOI1Mutator]MSP[S] } return - 1L ; } private static long validateAndConvertToMillis ( final long timeToLive , final TimeUnit timeUnit ) { Objects . requireNonNull ( timeUnit , lr_1 ) ; return TimeUnit . MILLISECONDS . convert ( timeToLive , timeUnit ) ; } @Override
return now + timeToLiveMillis ; MST[PrimitiveReturnsMutator]MSP[N] } return - 1L ; } private static long validateAndConvertToMillis ( final long timeToLive , final TimeUnit timeUnit ) { Objects . requireNonNull ( timeUnit , lr_1 ) ; return TimeUnit . MILLISECONDS . convert ( timeToLive , timeUnit ) ; } @Override
@Override public long expirationTime ( final K key , final V value ) { if ( timeToLiveMillis >= 0L ) { final long now = System . currentTimeMillis () ; if ( now > Long . MAX_VALUE - timeToLiveMillis ) { MST[rv.ROR4Mutator]MSP[S] return - 1 ; }
@Override public long expirationTime ( final K key , final V value ) { if ( timeToLiveMillis >= 0L ) { final long now = System . currentTimeMillis () ; if ( now > Long . MAX_VALUE - timeToLiveMillis ) { MST[rv.CRCR3Mutator]MSP[S] return - 1 ; }
@Override public long expirationTime ( final K key , final V value ) { if ( timeToLiveMillis >= 0L ) { MST[rv.CRCR1Mutator]MSP[S] final long now = System . currentTimeMillis () ; if ( now > Long . MAX_VALUE - timeToLiveMillis ) { return - 1 ; }
@Override public long expirationTime ( final K key , final V value ) { if ( timeToLiveMillis >= 0L ) { final long now = System . currentTimeMillis () ; if ( now > Long . MAX_VALUE - timeToLiveMillis ) { MST[rv.AOD2Mutator]MSP[N] return - 1 ; }
@Override public long expirationTime ( final K key , final V value ) { if ( timeToLiveMillis >= 0L ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[S] final long now = System . currentTimeMillis () ; if ( now > Long . MAX_VALUE - timeToLiveMillis ) { return - 1 ; }
@Override public long expirationTime ( final K key , final V value ) { if ( timeToLiveMillis >= 0L ) { MST[rv.CRCR5Mutator]MSP[S] final long now = System . currentTimeMillis () ; if ( now > Long . MAX_VALUE - timeToLiveMillis ) { return - 1 ; }
@Override public long expirationTime ( final K key , final V value ) { if ( timeToLiveMillis >= 0L ) { MST[ConditionalsBoundaryMutator]MSP[S] final long now = System . currentTimeMillis () ; if ( now > Long . MAX_VALUE - timeToLiveMillis ) { return - 1 ; }
@Override public long expirationTime ( final K key , final V value ) { if ( timeToLiveMillis >= 0L ) { final long now = System . currentTimeMillis () ; if ( now > Long . MAX_VALUE - timeToLiveMillis ) { return - 1 ; MST[InlineConstantMutator]MSP[N] }
if ( isExpired ( now , expirationEntry . getValue () ) ) { MST[rv.UOI3Mutator]MSP[S] super . remove ( expirationEntry . getKey () ) ; iter . remove () ; } } } private void removeIfExpired ( final Object key , final long now ) {
removeIfExpired ( key , now () ) ; final long expirationTime = expiringPolicy . expirationTime ( key , value ) ; expirationMap . put ( key , Long . valueOf ( expirationTime ) ) ; return super . put ( key , value ) ; MST[ArgumentPropagationMutator]MSP[N] } @Override
} @Override public V get ( final Object key ) { removeIfExpired ( key , now () ) ; return super . get ( key ) ; } @Override public boolean isEmpty () { removeAllExpired ( now () ) ; return super . isEmpty () ; MST[BooleanFalseReturnValsMutator]MSP[N] }
private boolean isExpired ( final long now , final Long expirationTimeObject ) { if ( expirationTimeObject != null ) { final long expirationTime = expirationTimeObject . longValue () ; return expirationTime >= 0 && now >= expirationTime ; MST[ConditionalsBoundaryMutator]MSP[S] } return false ; } @Override
private boolean isExpired ( final long now , final Long expirationTimeObject ) { if ( expirationTimeObject != null ) { final long expirationTime = expirationTimeObject . longValue () ; return expirationTime >= 0 && now >= expirationTime ; MST[InlineConstantMutator]MSP[N] } return false ; } @Override
private boolean isExpired ( final long now , final Long expirationTimeObject ) { if ( expirationTimeObject != null ) { final long expirationTime = expirationTimeObject . longValue () ; return expirationTime >= 0 && now >= expirationTime ; MST[rv.ROR5Mutator]MSP[N] } return false ; } @Override
final Iterator < Map . Entry < Object , Long > > iter = expirationMap . entrySet () . iterator () ; while ( iter . hasNext () ) { MST[NonVoidMethodCallMutator]MSP[N] final Map . Entry < Object , Long > expirationEntry = iter . next () ;
if ( isExpired ( now , expirationEntry . getValue () ) ) { MST[rv.UOI1Mutator]MSP[S] super . remove ( expirationEntry . getKey () ) ; iter . remove () ; } } } private void removeIfExpired ( final Object key , final long now ) {
private boolean isExpired ( final long now , final Long expirationTimeObject ) { if ( expirationTimeObject != null ) { final long expirationTime = expirationTimeObject . longValue () ; return expirationTime >= 0 && now >= expirationTime ; } return false ; MST[rv.CRCR6Mutator]MSP[S] } @Override
public Set < K > keySet () { removeAllExpired ( now () ) ; return super . keySet () ; } private long now () { return System . currentTimeMillis () ; MST[PrimitiveReturnsMutator]MSP[N] } @Override public V put ( final K key , final V value ) {
private boolean isExpired ( final long now , final Long expirationTimeObject ) { if ( expirationTimeObject != null ) { final long expirationTime = expirationTimeObject . longValue () ; return expirationTime >= 0 && now >= expirationTime ; MST[rv.ROR1Mutator]MSP[S] } return false ; } @Override
private boolean isExpired ( final long now , final Long expirationTimeObject ) { if ( expirationTimeObject != null ) { final long expirationTime = expirationTimeObject . longValue () ; return expirationTime >= 0 && now >= expirationTime ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] } return false ; } @Override
private boolean isExpired ( final long now , final Long expirationTimeObject ) { if ( expirationTimeObject != null ) { final long expirationTime = expirationTimeObject . longValue () ; return expirationTime >= 0 && now >= expirationTime ; MST[rv.ROR3Mutator]MSP[S] } return false ; } @Override
return now + timeToLiveMillis ; } return - 1L ; } private static long validateAndConvertToMillis ( final long timeToLive , final TimeUnit timeUnit ) { Objects . requireNonNull ( timeUnit , lr_1 ) ; return TimeUnit . MILLISECONDS . convert ( timeToLive , timeUnit ) ; MST[rv.ABSMutator]MSP[N] } @Override
} @Override public V get ( final Object key ) { removeIfExpired ( key , now () ) ; MST[VoidMethodCallMutator]MSP[S] return super . get ( key ) ; } @Override public boolean isEmpty () { removeAllExpired ( now () ) ; return super . isEmpty () ; }
public Set < K > keySet () { removeAllExpired ( now () ) ; return super . keySet () ; MST[ReturnValsMutator]MSP[S] } private long now () { return System . currentTimeMillis () ; } @Override public V put ( final K key , final V value ) {
return now + timeToLiveMillis ; } return - 1L ; } private static long validateAndConvertToMillis ( final long timeToLive , final TimeUnit timeUnit ) { Objects . requireNonNull ( timeUnit , lr_1 ) ; return TimeUnit . MILLISECONDS . convert ( timeToLive , timeUnit ) ; MST[NonVoidMethodCallMutator]MSP[N] } @Override
final Long expirationTimeObject = expirationMap . get ( key ) ; if ( isExpired ( now , expirationTimeObject ) ) { MST[rv.UOI4Mutator]MSP[S] remove ( key ) ; } } @Override public int size () { removeAllExpired ( now () ) ; return super . size () ; }
} @Override public V get ( final Object key ) { removeIfExpired ( key , now () ) ; return super . get ( key ) ; } @Override public boolean isEmpty () { removeAllExpired ( now () ) ; MST[NonVoidMethodCallMutator]MSP[S] return super . isEmpty () ; }
removeIfExpired ( key , now () ) ; final long expirationTime = expiringPolicy . expirationTime ( key , value ) ; expirationMap . put ( key , Long . valueOf ( expirationTime ) ) ; MST[rv.UOI3Mutator]MSP[N] return super . put ( key , value ) ; } @Override
final Iterator < Map . Entry < Object , Long > > iter = expirationMap . entrySet () . iterator () ; MST[NonVoidMethodCallMutator]MSP[S] while ( iter . hasNext () ) { final Map . Entry < Object , Long > expirationEntry = iter . next () ;
removeIfExpired ( key , now () ) ; final long expirationTime = expiringPolicy . expirationTime ( key , value ) ; expirationMap . put ( key , Long . valueOf ( expirationTime ) ) ; MST[ArgumentPropagationMutator]MSP[N] return super . put ( key , value ) ; } @Override
public Set < K > keySet () { removeAllExpired ( now () ) ; return super . keySet () ; MST[EmptyObjectReturnValsMutator]MSP[S] } private long now () { return System . currentTimeMillis () ; } @Override public V put ( final K key , final V value ) {
private boolean isExpired ( final long now , final Long expirationTimeObject ) { if ( expirationTimeObject != null ) { final long expirationTime = expirationTimeObject . longValue () ; return expirationTime >= 0 && now >= expirationTime ; MST[rv.UOI2Mutator]MSP[S] } return false ; } @Override
if ( isExpired ( now , expirationEntry . getValue () ) ) { MST[rv.ROR5Mutator]MSP[N] super . remove ( expirationEntry . getKey () ) ; iter . remove () ; } } } private void removeIfExpired ( final Object key , final long now ) {
out . defaultWriteObject () ; out . writeObject ( map ) ; } @Override public Collection < V > values () { removeAllExpired ( now () ) ; return super . values () ; MST[EmptyObjectReturnValsMutator]MSP[S] }
public boolean containsValue ( final Object value ) { removeAllExpired ( now () ) ; return super . containsValue ( value ) ; MST[NonVoidMethodCallMutator]MSP[S] } @Override public Set < Entry < K , V > > entrySet () { removeAllExpired ( now () ) ; return super . entrySet () ;
private boolean isExpired ( final long now , final Long expirationTimeObject ) { if ( expirationTimeObject != null ) { final long expirationTime = expirationTimeObject . longValue () ; return expirationTime >= 0 && now >= expirationTime ; MST[rv.CRCR3Mutator]MSP[S] } return false ; } @Override
} @Override public V get ( final Object key ) { removeIfExpired ( key , now () ) ; return super . get ( key ) ; MST[ArgumentPropagationMutator]MSP[N] } @Override public boolean isEmpty () { removeAllExpired ( now () ) ; return super . isEmpty () ; }
private boolean isExpired ( final long now , final Long expirationTimeObject ) { if ( expirationTimeObject != null ) { final long expirationTime = expirationTimeObject . longValue () ; return expirationTime >= 0 && now >= expirationTime ; MST[rv.UOI3Mutator]MSP[N] } return false ; } @Override
private boolean isExpired ( final long now , final Long expirationTimeObject ) { if ( expirationTimeObject != null ) { final long expirationTime = expirationTimeObject . longValue () ; return expirationTime >= 0 && now >= expirationTime ; MST[rv.CRCR6Mutator]MSP[N] } return false ; } @Override
private boolean isExpired ( final long now , final Long expirationTimeObject ) { if ( expirationTimeObject != null ) { final long expirationTime = expirationTimeObject . longValue () ; return expirationTime >= 0 && now >= expirationTime ; MST[rv.ROR2Mutator]MSP[N] } return false ; } @Override
return now + timeToLiveMillis ; } return - 1L ; } private static long validateAndConvertToMillis ( final long timeToLive , final TimeUnit timeUnit ) { Objects . requireNonNull ( timeUnit , lr_1 ) ; MST[NonVoidMethodCallMutator]MSP[S] return TimeUnit . MILLISECONDS . convert ( timeToLive , timeUnit ) ; } @Override
if ( isExpired ( now , expirationEntry . getValue () ) ) { MST[rv.ROR1Mutator]MSP[S] super . remove ( expirationEntry . getKey () ) ; iter . remove () ; } } } private void removeIfExpired ( final Object key , final long now ) {
final Long expirationTimeObject = expirationMap . get ( key ) ; if ( isExpired ( now , expirationTimeObject ) ) { MST[NonVoidMethodCallMutator]MSP[S] remove ( key ) ; } } @Override public int size () { removeAllExpired ( now () ) ; return super . size () ; }
return now + timeToLiveMillis ; } return - 1L ; } private static long validateAndConvertToMillis ( final long timeToLive , final TimeUnit timeUnit ) { Objects . requireNonNull ( timeUnit , lr_1 ) ; return TimeUnit . MILLISECONDS . convert ( timeToLive , timeUnit ) ; MST[rv.UOI4Mutator]MSP[S] } @Override
private boolean isExpired ( final long now , final Long expirationTimeObject ) { if ( expirationTimeObject != null ) { final long expirationTime = expirationTimeObject . longValue () ; return expirationTime >= 0 && now >= expirationTime ; MST[BooleanTrueReturnValsMutator]MSP[N] } return false ; } @Override
final Long expirationTimeObject = expirationMap . get ( key ) ; MST[NonVoidMethodCallMutator]MSP[S] if ( isExpired ( now , expirationTimeObject ) ) { remove ( key ) ; } } @Override public int size () { removeAllExpired ( now () ) ; return super . size () ; }
final Iterator < Map . Entry < Object , Long > > iter = expirationMap . entrySet () . iterator () ; while ( iter . hasNext () ) { MST[rv.ROR5Mutator]MSP[S] final Map . Entry < Object , Long > expirationEntry = iter . next () ;
return now + timeToLiveMillis ; } return - 1L ; } private static long validateAndConvertToMillis ( final long timeToLive , final TimeUnit timeUnit ) { Objects . requireNonNull ( timeUnit , lr_1 ) ; MST[ArgumentPropagationMutator]MSP[S] return TimeUnit . MILLISECONDS . convert ( timeToLive , timeUnit ) ; } @Override
public void clear () { super . clear () ; expirationMap . clear () ; } @Override public boolean containsKey ( final Object key ) { removeIfExpired ( key , now () ) ; return super . containsKey ( key ) ; MST[ReturnValsMutator]MSP[N] } @Override
return now + timeToLiveMillis ; } return - 1L ; } private static long validateAndConvertToMillis ( final long timeToLive , final TimeUnit timeUnit ) { Objects . requireNonNull ( timeUnit , lr_1 ) ; return TimeUnit . MILLISECONDS . convert ( timeToLive , timeUnit ) ; MST[PrimitiveReturnsMutator]MSP[N] } @Override
public boolean containsValue ( final Object value ) { removeAllExpired ( now () ) ; return super . containsValue ( value ) ; } @Override public Set < Entry < K , V > > entrySet () { removeAllExpired ( now () ) ; return super . entrySet () ; MST[NonVoidMethodCallMutator]MSP[N]
private boolean isExpired ( final long now , final Long expirationTimeObject ) { if ( expirationTimeObject != null ) { final long expirationTime = expirationTimeObject . longValue () ; return expirationTime >= 0 && now >= expirationTime ; MST[rv.UOI3Mutator]MSP[S] } return false ; } @Override
final Iterator < Map . Entry < Object , Long > > iter = expirationMap . entrySet () . iterator () ; while ( iter . hasNext () ) { MST[rv.ROR2Mutator]MSP[S] final Map . Entry < Object , Long > expirationEntry = iter . next () ;
if ( isExpired ( now , expirationEntry . getValue () ) ) { MST[NegateConditionalsMutator]MSP[N] super . remove ( expirationEntry . getKey () ) ; iter . remove () ; } } } private void removeIfExpired ( final Object key , final long now ) {
private boolean isExpired ( final long now , final Long expirationTimeObject ) { if ( expirationTimeObject != null ) { final long expirationTime = expirationTimeObject . longValue () ; return expirationTime >= 0 && now >= expirationTime ; MST[rv.ABSMutator]MSP[S] } return false ; } @Override
public boolean containsValue ( final Object value ) { removeAllExpired ( now () ) ; return super . containsValue ( value ) ; } @Override public Set < Entry < K , V > > entrySet () { removeAllExpired ( now () ) ; return super . entrySet () ; MST[EmptyObjectReturnValsMutator]MSP[S]
private boolean isExpired ( final long now , final Long expirationTimeObject ) { if ( expirationTimeObject != null ) { final long expirationTime = expirationTimeObject . longValue () ; return expirationTime >= 0 && now >= expirationTime ; MST[rv.CRCR3Mutator]MSP[N] } return false ; } @Override
if ( isExpired ( now , expirationEntry . getValue () ) ) { MST[NonVoidMethodCallMutator]MSP[N] super . remove ( expirationEntry . getKey () ) ; iter . remove () ; } } } private void removeIfExpired ( final Object key , final long now ) {
private boolean isExpired ( final long now , final Long expirationTimeObject ) { if ( expirationTimeObject != null ) { final long expirationTime = expirationTimeObject . longValue () ; return expirationTime >= 0 && now >= expirationTime ; MST[rv.CRCR5Mutator]MSP[S] } return false ; } @Override
private boolean isExpired ( final long now , final Long expirationTimeObject ) { if ( expirationTimeObject != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] final long expirationTime = expirationTimeObject . longValue () ; return expirationTime >= 0 && now >= expirationTime ; } return false ; } @Override
final Long expirationTimeObject = expirationMap . get ( key ) ; if ( isExpired ( now , expirationTimeObject ) ) { MST[rv.ROR1Mutator]MSP[N] remove ( key ) ; } } @Override public int size () { removeAllExpired ( now () ) ; return super . size () ; }
public Set < K > keySet () { removeAllExpired ( now () ) ; return super . keySet () ; } private long now () { return System . currentTimeMillis () ; MST[NonVoidMethodCallMutator]MSP[N] } @Override public V put ( final K key , final V value ) {
final Long expirationTimeObject = expirationMap . get ( key ) ; if ( isExpired ( now , expirationTimeObject ) ) { remove ( key ) ; } } @Override public int size () { removeAllExpired ( now () ) ; MST[VoidMethodCallMutator]MSP[S] return super . size () ; }
private boolean isExpired ( final long now , final Long expirationTimeObject ) { if ( expirationTimeObject != null ) { final long expirationTime = expirationTimeObject . longValue () ; return expirationTime >= 0 && now >= expirationTime ; MST[RemoveConditionalMutator_ORDER_IF]MSP[N] } return false ; } @Override
final Long expirationTimeObject = expirationMap . get ( key ) ; if ( isExpired ( now , expirationTimeObject ) ) { MST[rv.UOI1Mutator]MSP[S] remove ( key ) ; } } @Override public int size () { removeAllExpired ( now () ) ; return super . size () ; }
private boolean isExpired ( final long now , final Long expirationTimeObject ) { if ( expirationTimeObject != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] final long expirationTime = expirationTimeObject . longValue () ; return expirationTime >= 0 && now >= expirationTime ; } return false ; } @Override
private boolean isExpired ( final long now , final Long expirationTimeObject ) { if ( expirationTimeObject != null ) { final long expirationTime = expirationTimeObject . longValue () ; return expirationTime >= 0 && now >= expirationTime ; MST[rv.UOI4Mutator]MSP[S] } return false ; } @Override
public Set < K > keySet () { removeAllExpired ( now () ) ; MST[VoidMethodCallMutator]MSP[N] return super . keySet () ; } private long now () { return System . currentTimeMillis () ; } @Override public V put ( final K key , final V value ) {
public void clear () { super . clear () ; MST[VoidMethodCallMutator]MSP[S] expirationMap . clear () ; } @Override public boolean containsKey ( final Object key ) { removeIfExpired ( key , now () ) ; return super . containsKey ( key ) ; } @Override
final Long expirationTimeObject = expirationMap . get ( key ) ; if ( isExpired ( now , expirationTimeObject ) ) { remove ( key ) ; } } @Override public int size () { removeAllExpired ( now () ) ; return super . size () ; MST[ReturnValsMutator]MSP[N] }
private boolean isExpired ( final long now , final Long expirationTimeObject ) { if ( expirationTimeObject != null ) { final long expirationTime = expirationTimeObject . longValue () ; return expirationTime >= 0 && now >= expirationTime ; MST[rv.CRCR2Mutator]MSP[N] } return false ; } @Override
put ( entry . getKey () , entry . getValue () ) ; } } @Override public V remove ( final Object key ) { expirationMap . remove ( key ) ; return super . remove ( key ) ; MST[NonVoidMethodCallMutator]MSP[N] } private void removeAllExpired ( final long now ) {
private boolean isExpired ( final long now , final Long expirationTimeObject ) { if ( expirationTimeObject != null ) { final long expirationTime = expirationTimeObject . longValue () ; return expirationTime >= 0 && now >= expirationTime ; MST[NegateConditionalsMutator]MSP[S] } return false ; } @Override
public boolean containsValue ( final Object value ) { removeAllExpired ( now () ) ; return super . containsValue ( value ) ; MST[BooleanFalseReturnValsMutator]MSP[S] } @Override public Set < Entry < K , V > > entrySet () { removeAllExpired ( now () ) ; return super . entrySet () ;
private boolean isExpired ( final long now , final Long expirationTimeObject ) { if ( expirationTimeObject != null ) { final long expirationTime = expirationTimeObject . longValue () ; return expirationTime >= 0 && now >= expirationTime ; MST[rv.CRCR6Mutator]MSP[N] } return false ; } @Override
if ( isExpired ( now , expirationEntry . getValue () ) ) { MST[rv.ROR2Mutator]MSP[S] super . remove ( expirationEntry . getKey () ) ; iter . remove () ; } } } private void removeIfExpired ( final Object key , final long now ) {
private boolean isExpired ( final long now , final Long expirationTimeObject ) { if ( expirationTimeObject != null ) { final long expirationTime = expirationTimeObject . longValue () ; return expirationTime >= 0 && now >= expirationTime ; MST[rv.UOI1Mutator]MSP[S] } return false ; } @Override
private boolean isExpired ( final long now , final Long expirationTimeObject ) { if ( expirationTimeObject != null ) { final long expirationTime = expirationTimeObject . longValue () ; return expirationTime >= 0 && now >= expirationTime ; MST[rv.CRCR1Mutator]MSP[N] } return false ; } @Override
private boolean isExpired ( final long now , final Long expirationTimeObject ) { if ( expirationTimeObject != null ) { final long expirationTime = expirationTimeObject . longValue () ; return expirationTime >= 0 && now >= expirationTime ; } return false ; MST[InlineConstantMutator]MSP[S] } @Override
public void clear () { super . clear () ; expirationMap . clear () ; } @Override public boolean containsKey ( final Object key ) { removeIfExpired ( key , now () ) ; MST[VoidMethodCallMutator]MSP[S] return super . containsKey ( key ) ; } @Override
if ( isExpired ( now , expirationEntry . getValue () ) ) { MST[rv.ABSMutator]MSP[N] super . remove ( expirationEntry . getKey () ) ; iter . remove () ; } } } private void removeIfExpired ( final Object key , final long now ) {
public Set < K > keySet () { removeAllExpired ( now () ) ; MST[NonVoidMethodCallMutator]MSP[N] return super . keySet () ; } private long now () { return System . currentTimeMillis () ; } @Override public V put ( final K key , final V value ) {
} @Override public V get ( final Object key ) { removeIfExpired ( key , now () ) ; return super . get ( key ) ; MST[ReturnValsMutator]MSP[N] } @Override public boolean isEmpty () { removeAllExpired ( now () ) ; return super . isEmpty () ; }
} @Override public V get ( final Object key ) { removeIfExpired ( key , now () ) ; return super . get ( key ) ; } @Override public boolean isEmpty () { removeAllExpired ( now () ) ; MST[VoidMethodCallMutator]MSP[S] return super . isEmpty () ; }
private boolean isExpired ( final long now , final Long expirationTimeObject ) { if ( expirationTimeObject != null ) { final long expirationTime = expirationTimeObject . longValue () ; return expirationTime >= 0 && now >= expirationTime ; MST[rv.CRCR5Mutator]MSP[N] } return false ; } @Override
private boolean isExpired ( final long now , final Long expirationTimeObject ) { if ( expirationTimeObject != null ) { final long expirationTime = expirationTimeObject . longValue () ; return expirationTime >= 0 && now >= expirationTime ; MST[rv.ROR4Mutator]MSP[N] } return false ; } @Override
return now + timeToLiveMillis ; } return - 1L ; } private static long validateAndConvertToMillis ( final long timeToLive , final TimeUnit timeUnit ) { Objects . requireNonNull ( timeUnit , lr_1 ) ; return TimeUnit . MILLISECONDS . convert ( timeToLive , timeUnit ) ; MST[rv.UOI2Mutator]MSP[S] } @Override
private boolean isExpired ( final long now , final Long expirationTimeObject ) { if ( expirationTimeObject != null ) { final long expirationTime = expirationTimeObject . longValue () ; MST[NonVoidMethodCallMutator]MSP[N] return expirationTime >= 0 && now >= expirationTime ; } return false ; } @Override
out . defaultWriteObject () ; out . writeObject ( map ) ; } @Override public Collection < V > values () { removeAllExpired ( now () ) ; return super . values () ; MST[NonVoidMethodCallMutator]MSP[N] }
public void clear () { super . clear () ; expirationMap . clear () ; } @Override public boolean containsKey ( final Object key ) { removeIfExpired ( key , now () ) ; return super . containsKey ( key ) ; MST[BooleanTrueReturnValsMutator]MSP[N] } @Override
} @Override public V get ( final Object key ) { removeIfExpired ( key , now () ) ; MST[NonVoidMethodCallMutator]MSP[S] return super . get ( key ) ; } @Override public boolean isEmpty () { removeAllExpired ( now () ) ; return super . isEmpty () ; }
} @Override public V get ( final Object key ) { removeIfExpired ( key , now () ) ; return super . get ( key ) ; } @Override public boolean isEmpty () { removeAllExpired ( now () ) ; return super . isEmpty () ; MST[BooleanTrueReturnValsMutator]MSP[N] }
final Long expirationTimeObject = expirationMap . get ( key ) ; if ( isExpired ( now , expirationTimeObject ) ) { MST[rv.ROR4Mutator]MSP[S] remove ( key ) ; } } @Override public int size () { removeAllExpired ( now () ) ; return super . size () ; }
final Long expirationTimeObject = expirationMap . get ( key ) ; if ( isExpired ( now , expirationTimeObject ) ) { remove ( key ) ; } } @Override public int size () { removeAllExpired ( now () ) ; MST[NonVoidMethodCallMutator]MSP[S] return super . size () ; }
final Long expirationTimeObject = expirationMap . get ( key ) ; if ( isExpired ( now , expirationTimeObject ) ) { MST[NegateConditionalsMutator]MSP[N] remove ( key ) ; } } @Override public int size () { removeAllExpired ( now () ) ; return super . size () ; }
final Long expirationTimeObject = expirationMap . get ( key ) ; if ( isExpired ( now , expirationTimeObject ) ) { MST[rv.ABSMutator]MSP[S] remove ( key ) ; } } @Override public int size () { removeAllExpired ( now () ) ; return super . size () ; }
if ( isExpired ( now , expirationEntry . getValue () ) ) { MST[rv.UOI4Mutator]MSP[S] super . remove ( expirationEntry . getKey () ) ; iter . remove () ; } } } private void removeIfExpired ( final Object key , final long now ) {
private boolean isExpired ( final long now , final Long expirationTimeObject ) { if ( expirationTimeObject != null ) { final long expirationTime = expirationTimeObject . longValue () ; return expirationTime >= 0 && now >= expirationTime ; } return false ; MST[ReturnValsMutator]MSP[S] } @Override
public boolean containsValue ( final Object value ) { removeAllExpired ( now () ) ; return super . containsValue ( value ) ; } @Override public Set < Entry < K , V > > entrySet () { removeAllExpired ( now () ) ; return super . entrySet () ; MST[ReturnValsMutator]MSP[N]
if ( isExpired ( now , expirationEntry . getValue () ) ) { MST[rv.UOI2Mutator]MSP[S] super . remove ( expirationEntry . getKey () ) ; iter . remove () ; } } } private void removeIfExpired ( final Object key , final long now ) {
if ( isExpired ( now , expirationEntry . getValue () ) ) { super . remove ( expirationEntry . getKey () ) ; iter . remove () ; MST[VoidMethodCallMutator]MSP[S] } } } private void removeIfExpired ( final Object key , final long now ) {
public void clear () { super . clear () ; expirationMap . clear () ; MST[VoidMethodCallMutator]MSP[S] } @Override public boolean containsKey ( final Object key ) { removeIfExpired ( key , now () ) ; return super . containsKey ( key ) ; } @Override
private boolean isExpired ( final long now , final Long expirationTimeObject ) { if ( expirationTimeObject != null ) { final long expirationTime = expirationTimeObject . longValue () ; return expirationTime >= 0 && now >= expirationTime ; } return false ; MST[BooleanTrueReturnValsMutator]MSP[S] } @Override
public boolean containsValue ( final Object value ) { removeAllExpired ( now () ) ; return super . containsValue ( value ) ; } @Override public Set < Entry < K , V > > entrySet () { removeAllExpired ( now () ) ; MST[VoidMethodCallMutator]MSP[S] return super . entrySet () ;
private boolean isExpired ( final long now , final Long expirationTimeObject ) { if ( expirationTimeObject != null ) { final long expirationTime = expirationTimeObject . longValue () ; return expirationTime >= 0 && now >= expirationTime ; MST[ConditionalsBoundaryMutator]MSP[S] } return false ; } @Override
private boolean isExpired ( final long now , final Long expirationTimeObject ) { if ( expirationTimeObject != null ) { final long expirationTime = expirationTimeObject . longValue () ; return expirationTime >= 0 && now >= expirationTime ; } return false ; MST[rv.CRCR3Mutator]MSP[S] } @Override
private boolean isExpired ( final long now , final Long expirationTimeObject ) { if ( expirationTimeObject != null ) { final long expirationTime = expirationTimeObject . longValue () ; return expirationTime >= 0 && now >= expirationTime ; } return false ; MST[rv.CRCR5Mutator]MSP[S] } @Override
public Set < K > keySet () { removeAllExpired ( now () ) ; return super . keySet () ; } private long now () { return System . currentTimeMillis () ; MST[ReturnValsMutator]MSP[S] } @Override public V put ( final K key , final V value ) {
private boolean isExpired ( final long now , final Long expirationTimeObject ) { if ( expirationTimeObject != null ) { final long expirationTime = expirationTimeObject . longValue () ; return expirationTime >= 0 && now >= expirationTime ; } return false ; MST[rv.CRCR1Mutator]MSP[S] } @Override
private boolean isExpired ( final long now , final Long expirationTimeObject ) { if ( expirationTimeObject != null ) { final long expirationTime = expirationTimeObject . longValue () ; return expirationTime >= 0 && now >= expirationTime ; MST[rv.ROR1Mutator]MSP[S] } return false ; } @Override
removeIfExpired ( key , now () ) ; final long expirationTime = expiringPolicy . expirationTime ( key , value ) ; expirationMap . put ( key , Long . valueOf ( expirationTime ) ) ; return super . put ( key , value ) ; MST[NullReturnValsMutator]MSP[S] } @Override
public boolean containsValue ( final Object value ) { removeAllExpired ( now () ) ; MST[VoidMethodCallMutator]MSP[S] return super . containsValue ( value ) ; } @Override public Set < Entry < K , V > > entrySet () { removeAllExpired ( now () ) ; return super . entrySet () ;
} @Override public V get ( final Object key ) { removeIfExpired ( key , now () ) ; return super . get ( key ) ; MST[NullReturnValsMutator]MSP[N] } @Override public boolean isEmpty () { removeAllExpired ( now () ) ; return super . isEmpty () ; }
final Long expirationTimeObject = expirationMap . get ( key ) ; if ( isExpired ( now , expirationTimeObject ) ) { remove ( key ) ; } } @Override public int size () { removeAllExpired ( now () ) ; return super . size () ; MST[NonVoidMethodCallMutator]MSP[N] }
put ( entry . getKey () , entry . getValue () ) ; MST[NonVoidMethodCallMutator]MSP[S] } } @Override public V remove ( final Object key ) { expirationMap . remove ( key ) ; return super . remove ( key ) ; } private void removeAllExpired ( final long now ) {
if ( isExpired ( now , expirationEntry . getValue () ) ) { super . remove ( expirationEntry . getKey () ) ; MST[NonVoidMethodCallMutator]MSP[N] iter . remove () ; } } } private void removeIfExpired ( final Object key , final long now ) {
public boolean containsValue ( final Object value ) { removeAllExpired ( now () ) ; return super . containsValue ( value ) ; MST[BooleanTrueReturnValsMutator]MSP[N] } @Override public Set < Entry < K , V > > entrySet () { removeAllExpired ( now () ) ; return super . entrySet () ;
private boolean isExpired ( final long now , final Long expirationTimeObject ) { if ( expirationTimeObject != null ) { final long expirationTime = expirationTimeObject . longValue () ; return expirationTime >= 0 && now >= expirationTime ; MST[rv.ROR5Mutator]MSP[N] } return false ; } @Override
private boolean isExpired ( final long now , final Long expirationTimeObject ) { if ( expirationTimeObject != null ) { final long expirationTime = expirationTimeObject . longValue () ; return expirationTime >= 0 && now >= expirationTime ; MST[rv.ROR3Mutator]MSP[N] } return false ; } @Override
removeIfExpired ( key , now () ) ; final long expirationTime = expiringPolicy . expirationTime ( key , value ) ; expirationMap . put ( key , Long . valueOf ( expirationTime ) ) ; MST[NonVoidMethodCallMutator]MSP[N] return super . put ( key , value ) ; } @Override
if ( isExpired ( now , expirationEntry . getValue () ) ) { MST[NonVoidMethodCallMutator]MSP[N] super . remove ( expirationEntry . getKey () ) ; iter . remove () ; } } } private void removeIfExpired ( final Object key , final long now ) {
private boolean isExpired ( final long now , final Long expirationTimeObject ) { if ( expirationTimeObject != null ) { final long expirationTime = expirationTimeObject . longValue () ; return expirationTime >= 0 && now >= expirationTime ; MST[InlineConstantMutator]MSP[S] } return false ; } @Override
private boolean isExpired ( final long now , final Long expirationTimeObject ) { if ( expirationTimeObject != null ) { final long expirationTime = expirationTimeObject . longValue () ; return expirationTime >= 0 && now >= expirationTime ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] } return false ; } @Override
return now + timeToLiveMillis ; } return - 1L ; } private static long validateAndConvertToMillis ( final long timeToLive , final TimeUnit timeUnit ) { Objects . requireNonNull ( timeUnit , lr_1 ) ; return TimeUnit . MILLISECONDS . convert ( timeToLive , timeUnit ) ; MST[ArgumentPropagationMutator]MSP[S] } @Override
removeIfExpired ( key , now () ) ; final long expirationTime = expiringPolicy . expirationTime ( key , value ) ; expirationMap . put ( key , Long . valueOf ( expirationTime ) ) ; MST[rv.ABSMutator]MSP[S] return super . put ( key , value ) ; } @Override
removeIfExpired ( key , now () ) ; final long expirationTime = expiringPolicy . expirationTime ( key , value ) ; expirationMap . put ( key , Long . valueOf ( expirationTime ) ) ; MST[rv.UOI2Mutator]MSP[S] return super . put ( key , value ) ; } @Override
if ( isExpired ( now , expirationEntry . getValue () ) ) { super . remove ( expirationEntry . getKey () ) ; MST[ArgumentPropagationMutator]MSP[N] iter . remove () ; } } } private void removeIfExpired ( final Object key , final long now ) {
final Long expirationTimeObject = expirationMap . get ( key ) ; if ( isExpired ( now , expirationTimeObject ) ) { MST[rv.UOI3Mutator]MSP[S] remove ( key ) ; } } @Override public int size () { removeAllExpired ( now () ) ; return super . size () ; }
final Iterator < Map . Entry < Object , Long > > iter = expirationMap . entrySet () . iterator () ; while ( iter . hasNext () ) { MST[NegateConditionalsMutator]MSP[S] final Map . Entry < Object , Long > expirationEntry = iter . next () ;
put ( entry . getKey () , entry . getValue () ) ; } } @Override public V remove ( final Object key ) { expirationMap . remove ( key ) ; MST[ArgumentPropagationMutator]MSP[S] return super . remove ( key ) ; } private void removeAllExpired ( final long now ) {
if ( isExpired ( now , expirationEntry . getValue () ) ) { MST[rv.ROR4Mutator]MSP[N] super . remove ( expirationEntry . getKey () ) ; iter . remove () ; } } } private void removeIfExpired ( final Object key , final long now ) {
private boolean isExpired ( final long now , final Long expirationTimeObject ) { if ( expirationTimeObject != null ) { final long expirationTime = expirationTimeObject . longValue () ; return expirationTime >= 0 && now >= expirationTime ; MST[rv.UOI3Mutator]MSP[S] } return false ; } @Override
private boolean isExpired ( final long now , final Long expirationTimeObject ) { if ( expirationTimeObject != null ) { final long expirationTime = expirationTimeObject . longValue () ; return expirationTime >= 0 && now >= expirationTime ; MST[rv.UOI2Mutator]MSP[S] } return false ; } @Override
private boolean isExpired ( final long now , final Long expirationTimeObject ) { if ( expirationTimeObject != null ) { final long expirationTime = expirationTimeObject . longValue () ; return expirationTime >= 0 && now >= expirationTime ; MST[rv.CRCR4Mutator]MSP[S] } return false ; } @Override
private boolean isExpired ( final long now , final Long expirationTimeObject ) { if ( expirationTimeObject != null ) { final long expirationTime = expirationTimeObject . longValue () ; return expirationTime >= 0 && now >= expirationTime ; MST[rv.CRCR3Mutator]MSP[N] } return false ; } @Override
out . defaultWriteObject () ; out . writeObject ( map ) ; } @Override public Collection < V > values () { removeAllExpired ( now () ) ; return super . values () ; MST[ReturnValsMutator]MSP[N] }
private boolean isExpired ( final long now , final Long expirationTimeObject ) { if ( expirationTimeObject != null ) { MST[rv.ROR5Mutator]MSP[S] final long expirationTime = expirationTimeObject . longValue () ; return expirationTime >= 0 && now >= expirationTime ; } return false ; } @Override
if ( isExpired ( now , expirationEntry . getValue () ) ) { super . remove ( expirationEntry . getKey () ) ; MST[NonVoidMethodCallMutator]MSP[N] iter . remove () ; } } } private void removeIfExpired ( final Object key , final long now ) {
final Iterator < Map . Entry < Object , Long > > iter = expirationMap . entrySet () . iterator () ; while ( iter . hasNext () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] final Map . Entry < Object , Long > expirationEntry = iter . next () ;
public void clear () { super . clear () ; expirationMap . clear () ; } @Override public boolean containsKey ( final Object key ) { removeIfExpired ( key , now () ) ; MST[NonVoidMethodCallMutator]MSP[S] return super . containsKey ( key ) ; } @Override
removeIfExpired ( key , now () ) ; final long expirationTime = expiringPolicy . expirationTime ( key , value ) ; expirationMap . put ( key , Long . valueOf ( expirationTime ) ) ; return super . put ( key , value ) ; MST[NonVoidMethodCallMutator]MSP[N] } @Override
put ( entry . getKey () , entry . getValue () ) ; MST[NonVoidMethodCallMutator]MSP[S] } } @Override public V remove ( final Object key ) { expirationMap . remove ( key ) ; return super . remove ( key ) ; } private void removeAllExpired ( final long now ) {
private boolean isExpired ( final long now , final Long expirationTimeObject ) { if ( expirationTimeObject != null ) { final long expirationTime = expirationTimeObject . longValue () ; return expirationTime >= 0 && now >= expirationTime ; MST[rv.ROR2Mutator]MSP[S] } return false ; } @Override
final Long expirationTimeObject = expirationMap . get ( key ) ; MST[ArgumentPropagationMutator]MSP[S] if ( isExpired ( now , expirationTimeObject ) ) { remove ( key ) ; } } @Override public int size () { removeAllExpired ( now () ) ; return super . size () ; }
} @Override public V get ( final Object key ) { removeIfExpired ( key , now () ) ; return super . get ( key ) ; } @Override public boolean isEmpty () { removeAllExpired ( now () ) ; return super . isEmpty () ; MST[ReturnValsMutator]MSP[N] }
} @Override public V get ( final Object key ) { removeIfExpired ( key , now () ) ; return super . get ( key ) ; MST[NonVoidMethodCallMutator]MSP[N] } @Override public boolean isEmpty () { removeAllExpired ( now () ) ; return super . isEmpty () ; }
removeIfExpired ( key , now () ) ; final long expirationTime = expiringPolicy . expirationTime ( key , value ) ; expirationMap . put ( key , Long . valueOf ( expirationTime ) ) ; MST[NonVoidMethodCallMutator]MSP[N] return super . put ( key , value ) ; } @Override
private boolean isExpired ( final long now , final Long expirationTimeObject ) { if ( expirationTimeObject != null ) { final long expirationTime = expirationTimeObject . longValue () ; return expirationTime >= 0 && now >= expirationTime ; MST[InlineConstantMutator]MSP[N] } return false ; } @Override
put ( entry . getKey () , entry . getValue () ) ; } } @Override public V remove ( final Object key ) { expirationMap . remove ( key ) ; return super . remove ( key ) ; MST[NullReturnValsMutator]MSP[N] } private void removeAllExpired ( final long now ) {
removeIfExpired ( key , now () ) ; final long expirationTime = expiringPolicy . expirationTime ( key , value ) ; MST[NonVoidMethodCallMutator]MSP[N] expirationMap . put ( key , Long . valueOf ( expirationTime ) ) ; return super . put ( key , value ) ; } @Override
final Long expirationTimeObject = expirationMap . get ( key ) ; if ( isExpired ( now , expirationTimeObject ) ) { MST[rv.ROR2Mutator]MSP[S] remove ( key ) ; } } @Override public int size () { removeAllExpired ( now () ) ; return super . size () ; }
put ( entry . getKey () , entry . getValue () ) ; MST[ArgumentPropagationMutator]MSP[S] } } @Override public V remove ( final Object key ) { expirationMap . remove ( key ) ; return super . remove ( key ) ; } private void removeAllExpired ( final long now ) {
removeIfExpired ( key , now () ) ; MST[NonVoidMethodCallMutator]MSP[S] final long expirationTime = expiringPolicy . expirationTime ( key , value ) ; expirationMap . put ( key , Long . valueOf ( expirationTime ) ) ; return super . put ( key , value ) ; } @Override
final Iterator < Map . Entry < Object , Long > > iter = expirationMap . entrySet () . iterator () ; while ( iter . hasNext () ) { MST[rv.ROR4Mutator]MSP[N] final Map . Entry < Object , Long > expirationEntry = iter . next () ;
final Iterator < Map . Entry < Object , Long > > iter = expirationMap . entrySet () . iterator () ; while ( iter . hasNext () ) { MST[rv.ROR3Mutator]MSP[S] final Map . Entry < Object , Long > expirationEntry = iter . next () ;
private boolean isExpired ( final long now , final Long expirationTimeObject ) { if ( expirationTimeObject != null ) { MST[NegateConditionalsMutator]MSP[S] final long expirationTime = expirationTimeObject . longValue () ; return expirationTime >= 0 && now >= expirationTime ; } return false ; } @Override
private boolean isExpired ( final long now , final Long expirationTimeObject ) { if ( expirationTimeObject != null ) { final long expirationTime = expirationTimeObject . longValue () ; return expirationTime >= 0 && now >= expirationTime ; MST[rv.UOI4Mutator]MSP[S] } return false ; } @Override
final Long expirationTimeObject = expirationMap . get ( key ) ; if ( isExpired ( now , expirationTimeObject ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] remove ( key ) ; } } @Override public int size () { removeAllExpired ( now () ) ; return super . size () ; }
private boolean isExpired ( final long now , final Long expirationTimeObject ) { if ( expirationTimeObject != null ) { final long expirationTime = expirationTimeObject . longValue () ; return expirationTime >= 0 && now >= expirationTime ; MST[rv.UOI2Mutator]MSP[S] } return false ; } @Override
private boolean isExpired ( final long now , final Long expirationTimeObject ) { if ( expirationTimeObject != null ) { final long expirationTime = expirationTimeObject . longValue () ; return expirationTime >= 0 && now >= expirationTime ; MST[rv.UOI1Mutator]MSP[S] } return false ; } @Override
final Iterator < Map . Entry < Object , Long > > iter = expirationMap . entrySet () . iterator () ; while ( iter . hasNext () ) { MST[rv.ROR1Mutator]MSP[S] final Map . Entry < Object , Long > expirationEntry = iter . next () ;
final Iterator < Map . Entry < Object , Long > > iter = expirationMap . entrySet () . iterator () ; MST[NonVoidMethodCallMutator]MSP[S] while ( iter . hasNext () ) { final Map . Entry < Object , Long > expirationEntry = iter . next () ;
out . defaultWriteObject () ; out . writeObject ( map ) ; } @Override public Collection < V > values () { removeAllExpired ( now () ) ; MST[NonVoidMethodCallMutator]MSP[S] return super . values () ; }
public Set < K > keySet () { removeAllExpired ( now () ) ; return super . keySet () ; MST[NonVoidMethodCallMutator]MSP[S] } private long now () { return System . currentTimeMillis () ; } @Override public V put ( final K key , final V value ) {
private boolean isExpired ( final long now , final Long expirationTimeObject ) { if ( expirationTimeObject != null ) { final long expirationTime = expirationTimeObject . longValue () ; return expirationTime >= 0 && now >= expirationTime ; MST[rv.ABSMutator]MSP[S] } return false ; } @Override
removeIfExpired ( key , now () ) ; MST[VoidMethodCallMutator]MSP[S] final long expirationTime = expiringPolicy . expirationTime ( key , value ) ; expirationMap . put ( key , Long . valueOf ( expirationTime ) ) ; return super . put ( key , value ) ; } @Override
private boolean isExpired ( final long now , final Long expirationTimeObject ) { if ( expirationTimeObject != null ) { final long expirationTime = expirationTimeObject . longValue () ; return expirationTime >= 0 && now >= expirationTime ; MST[rv.CRCR6Mutator]MSP[N] } return false ; } @Override
put ( entry . getKey () , entry . getValue () ) ; MST[NonVoidMethodCallMutator]MSP[S] } } @Override public V remove ( final Object key ) { expirationMap . remove ( key ) ; return super . remove ( key ) ; } private void removeAllExpired ( final long now ) {
return now + timeToLiveMillis ; } return - 1L ; } private static long validateAndConvertToMillis ( final long timeToLive , final TimeUnit timeUnit ) { Objects . requireNonNull ( timeUnit , lr_1 ) ; return TimeUnit . MILLISECONDS . convert ( timeToLive , timeUnit ) ; MST[rv.UOI1Mutator]MSP[S] } @Override
put ( entry . getKey () , entry . getValue () ) ; } } @Override public V remove ( final Object key ) { expirationMap . remove ( key ) ; MST[NonVoidMethodCallMutator]MSP[S] return super . remove ( key ) ; } private void removeAllExpired ( final long now ) {
private boolean isExpired ( final long now , final Long expirationTimeObject ) { if ( expirationTimeObject != null ) { final long expirationTime = expirationTimeObject . longValue () ; return expirationTime >= 0 && now >= expirationTime ; MST[rv.CRCR1Mutator]MSP[S] } return false ; } @Override
public void clear () { super . clear () ; expirationMap . clear () ; } @Override public boolean containsKey ( final Object key ) { removeIfExpired ( key , now () ) ; return super . containsKey ( key ) ; MST[BooleanFalseReturnValsMutator]MSP[S] } @Override
return now + timeToLiveMillis ; } return - 1L ; } private static long validateAndConvertToMillis ( final long timeToLive , final TimeUnit timeUnit ) { Objects . requireNonNull ( timeUnit , lr_1 ) ; return TimeUnit . MILLISECONDS . convert ( timeToLive , timeUnit ) ; MST[rv.UOI3Mutator]MSP[N] } @Override
final Iterator < Map . Entry < Object , Long > > iter = expirationMap . entrySet () . iterator () ; while ( iter . hasNext () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] final Map . Entry < Object , Long > expirationEntry = iter . next () ;
final Long expirationTimeObject = expirationMap . get ( key ) ; if ( isExpired ( now , expirationTimeObject ) ) { MST[rv.ROR3Mutator]MSP[N] remove ( key ) ; } } @Override public int size () { removeAllExpired ( now () ) ; return super . size () ; }
final Long expirationTimeObject = expirationMap . get ( key ) ; if ( isExpired ( now , expirationTimeObject ) ) { remove ( key ) ; } } @Override public int size () { removeAllExpired ( now () ) ; return super . size () ; MST[PrimitiveReturnsMutator]MSP[N] }
final Long expirationTimeObject = expirationMap . get ( key ) ; if ( isExpired ( now , expirationTimeObject ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] remove ( key ) ; } } @Override public int size () { removeAllExpired ( now () ) ; return super . size () ; }
final Long expirationTimeObject = expirationMap . get ( key ) ; if ( isExpired ( now , expirationTimeObject ) ) { MST[rv.ROR5Mutator]MSP[N] remove ( key ) ; } } @Override public int size () { removeAllExpired ( now () ) ; return super . size () ; }
removeIfExpired ( key , now () ) ; final long expirationTime = expiringPolicy . expirationTime ( key , value ) ; expirationMap . put ( key , Long . valueOf ( expirationTime ) ) ; MST[rv.UOI1Mutator]MSP[S] return super . put ( key , value ) ; } @Override
put ( entry . getKey () , entry . getValue () ) ; } } @Override public V remove ( final Object key ) { expirationMap . remove ( key ) ; return super . remove ( key ) ; MST[ReturnValsMutator]MSP[N] } private void removeAllExpired ( final long now ) {
if ( isExpired ( now , expirationEntry . getValue () ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] super . remove ( expirationEntry . getKey () ) ; iter . remove () ; } } } private void removeIfExpired ( final Object key , final long now ) {
removeIfExpired ( key , now () ) ; final long expirationTime = expiringPolicy . expirationTime ( key , value ) ; expirationMap . put ( key , Long . valueOf ( expirationTime ) ) ; MST[rv.UOI4Mutator]MSP[S] return super . put ( key , value ) ; } @Override
final Long expirationTimeObject = expirationMap . get ( key ) ; if ( isExpired ( now , expirationTimeObject ) ) { MST[rv.UOI2Mutator]MSP[S] remove ( key ) ; } } @Override public int size () { removeAllExpired ( now () ) ; return super . size () ; }
private boolean isExpired ( final long now , final Long expirationTimeObject ) { if ( expirationTimeObject != null ) { final long expirationTime = expirationTimeObject . longValue () ; return expirationTime >= 0 && now >= expirationTime ; MST[RemoveConditionalMutator_ORDER_IF]MSP[S] } return false ; } @Override
private boolean isExpired ( final long now , final Long expirationTimeObject ) { if ( expirationTimeObject != null ) { final long expirationTime = expirationTimeObject . longValue () ; return expirationTime >= 0 && now >= expirationTime ; MST[ReturnValsMutator]MSP[S] } return false ; } @Override
out . defaultWriteObject () ; out . writeObject ( map ) ; } @Override public Collection < V > values () { removeAllExpired ( now () ) ; MST[VoidMethodCallMutator]MSP[S] return super . values () ; }
return now + timeToLiveMillis ; } return - 1L ; } private static long validateAndConvertToMillis ( final long timeToLive , final TimeUnit timeUnit ) { Objects . requireNonNull ( timeUnit , lr_1 ) ; return TimeUnit . MILLISECONDS . convert ( timeToLive , timeUnit ) ; MST[ReturnValsMutator]MSP[N] } @Override
private boolean isExpired ( final long now , final Long expirationTimeObject ) { if ( expirationTimeObject != null ) { final long expirationTime = expirationTimeObject . longValue () ; return expirationTime >= 0 && now >= expirationTime ; MST[rv.UOI4Mutator]MSP[S] } return false ; } @Override
if ( isExpired ( now , expirationEntry . getValue () ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] super . remove ( expirationEntry . getKey () ) ; iter . remove () ; } } } private void removeIfExpired ( final Object key , final long now ) {
private boolean isExpired ( final long now , final Long expirationTimeObject ) { if ( expirationTimeObject != null ) { final long expirationTime = expirationTimeObject . longValue () ; return expirationTime >= 0 && now >= expirationTime ; MST[rv.UOI1Mutator]MSP[S] } return false ; } @Override
private boolean isExpired ( final long now , final Long expirationTimeObject ) { if ( expirationTimeObject != null ) { final long expirationTime = expirationTimeObject . longValue () ; return expirationTime >= 0 && now >= expirationTime ; MST[rv.CRCR5Mutator]MSP[N] } return false ; } @Override
put ( entry . getKey () , entry . getValue () ) ; } } @Override public V remove ( final Object key ) { expirationMap . remove ( key ) ; return super . remove ( key ) ; MST[ArgumentPropagationMutator]MSP[N] } private void removeAllExpired ( final long now ) {
if ( isExpired ( now , expirationEntry . getValue () ) ) { MST[rv.ROR3Mutator]MSP[N] super . remove ( expirationEntry . getKey () ) ; iter . remove () ; } } } private void removeIfExpired ( final Object key , final long now ) {
public boolean containsValue ( final Object value ) { removeAllExpired ( now () ) ; return super . containsValue ( value ) ; } @Override public Set < Entry < K , V > > entrySet () { removeAllExpired ( now () ) ; MST[NonVoidMethodCallMutator]MSP[S] return super . entrySet () ;
private boolean isExpired ( final long now , final Long expirationTimeObject ) { if ( expirationTimeObject != null ) { final long expirationTime = expirationTimeObject . longValue () ; return expirationTime >= 0 && now >= expirationTime ; MST[NegateConditionalsMutator]MSP[N] } return false ; } @Override
public boolean containsValue ( final Object value ) { removeAllExpired ( now () ) ; MST[NonVoidMethodCallMutator]MSP[S] return super . containsValue ( value ) ; } @Override public Set < Entry < K , V > > entrySet () { removeAllExpired ( now () ) ; return super . entrySet () ;
public void putAll ( final Map < ? extends K , ? extends V > mapToCopy ) { for ( final Map . Entry < ? extends K , ? extends V > entry : mapToCopy . entrySet () ) { MST[NonVoidMethodCallMutator]MSP[N]
public boolean containsValue ( final Object value ) { removeAllExpired ( now () ) ; return super . containsValue ( value ) ; MST[ReturnValsMutator]MSP[N] } @Override public Set < Entry < K , V > > entrySet () { removeAllExpired ( now () ) ; return super . entrySet () ;
private boolean isExpired ( final long now , final Long expirationTimeObject ) { if ( expirationTimeObject != null ) { final long expirationTime = expirationTimeObject . longValue () ; return expirationTime >= 0 && now >= expirationTime ; MST[rv.ABSMutator]MSP[N] } return false ; } @Override
public void clear () { super . clear () ; expirationMap . clear () ; } @Override public boolean containsKey ( final Object key ) { removeIfExpired ( key , now () ) ; return super . containsKey ( key ) ; MST[NonVoidMethodCallMutator]MSP[S] } @Override
private boolean isExpired ( final long now , final Long expirationTimeObject ) { if ( expirationTimeObject != null ) { final long expirationTime = expirationTimeObject . longValue () ; return expirationTime >= 0 && now >= expirationTime ; MST[rv.ROR4Mutator]MSP[S] } return false ; } @Override
} @Override public V get ( final Object key ) { removeIfExpired ( key , now () ) ; return super . get ( key ) ; } @Override public boolean isEmpty () { removeAllExpired ( now () ) ; return super . isEmpty () ; MST[NonVoidMethodCallMutator]MSP[N] }
removeIfExpired ( key , now () ) ; final long expirationTime = expiringPolicy . expirationTime ( key , value ) ; expirationMap . put ( key , Long . valueOf ( expirationTime ) ) ; return super . put ( key , value ) ; MST[ReturnValsMutator]MSP[S] } @Override
