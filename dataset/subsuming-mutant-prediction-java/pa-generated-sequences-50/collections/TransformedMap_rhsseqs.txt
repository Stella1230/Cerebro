final Map < K , V > transformed = decorated . transformMap ( map ) ; decorated . clear () ; MST[VoidMethodCallMutator]MSP[S] decorated . decorated () . putAll ( transformed ) ; } return decorated ; } private void writeObject ( final ObjectOutputStream out ) throws IOException {
out . defaultWriteObject () ; out . writeObject ( map ) ; } @SuppressWarnings ( lr_1 ) private void readObject ( final ObjectInputStream in ) throws IOException , ClassNotFoundException { in . defaultReadObject () ; map = ( Map < K , V > ) in . readObject () ; MST[NonVoidMethodCallMutator]MSP[S]
return ( Map < K , V > ) map ; MST[ReturnValsMutator]MSP[S] } final Map < K , V > result = new LinkedMap <> ( map . size () ) ;
final Transformer < ? super V , ? extends V > valueTransformer ) { final TransformedMap < K , V > decorated = new TransformedMap <> ( map , keyTransformer , valueTransformer ) ; MST[ConstructorCallMutator]MSP[S] if ( map . size () > 0 ) {
protected V checkSetValue ( final V value ) { return valueTransformer . transform ( value ) ; MST[ReturnValsMutator]MSP[S] } @Override protected boolean isSetValueChecking () { return valueTransformer != null ; } @Override public V put ( K key , V value ) { key = transformKey ( key ) ;
protected V checkSetValue ( final V value ) { return valueTransformer . transform ( value ) ; } @Override protected boolean isSetValueChecking () { return valueTransformer != null ; MST[NegateConditionalsMutator]MSP[S] } @Override public V put ( K key , V value ) { key = transformKey ( key ) ;
decorated () . putAll ( mapToCopy ) ; MST[VoidMethodCallMutator]MSP[N] }
for ( final Map . Entry < ? extends K , ? extends V > entry : map . entrySet () ) { result . put ( transformKey ( entry . getKey () ) , transformValue ( entry . getValue () ) ) ; MST[ArgumentPropagationMutator]MSP[N] } return result ; } @Override
decorated () . putAll ( mapToCopy ) ; MST[NonVoidMethodCallMutator]MSP[N] }
} protected K transformKey ( final K object ) { if ( keyTransformer == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return object ; } return keyTransformer . transform ( object ) ; } protected V transformValue ( final V object ) { if ( valueTransformer == null ) { return object ; }
return valueTransformer . transform ( object ) ; MST[NullReturnValsMutator]MSP[N] } @SuppressWarnings ( lr_1 ) protected Map < K , V > transformMap ( final Map < ? extends K , ? extends V > map ) { if ( map . isEmpty () ) {
return valueTransformer . transform ( object ) ; } @SuppressWarnings ( lr_1 ) protected Map < K , V > transformMap ( final Map < ? extends K , ? extends V > map ) { if ( map . isEmpty () ) { MST[rv.ROR2Mutator]MSP[N]
value = transformValue ( value ) ; return decorated () . put ( key , value ) ; MST[NullReturnValsMutator]MSP[S] } @Override public void putAll ( Map < ? extends K , ? extends V > mapToCopy ) { mapToCopy = transformMap ( mapToCopy ) ;
return valueTransformer . transform ( object ) ; } @SuppressWarnings ( lr_1 ) protected Map < K , V > transformMap ( final Map < ? extends K , ? extends V > map ) { if ( map . isEmpty () ) { MST[rv.ROR1Mutator]MSP[N]
return valueTransformer . transform ( object ) ; } @SuppressWarnings ( lr_1 ) protected Map < K , V > transformMap ( final Map < ? extends K , ? extends V > map ) { if ( map . isEmpty () ) { MST[rv.ROR3Mutator]MSP[N]
} protected K transformKey ( final K object ) { if ( keyTransformer == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return object ; } return keyTransformer . transform ( object ) ; } protected V transformValue ( final V object ) { if ( valueTransformer == null ) { return object ; }
return valueTransformer . transform ( object ) ; } @SuppressWarnings ( lr_1 ) protected Map < K , V > transformMap ( final Map < ? extends K , ? extends V > map ) { if ( map . isEmpty () ) { MST[rv.ROR4Mutator]MSP[N]
final Transformer < ? super V , ? extends V > valueTransformer ) { final TransformedMap < K , V > decorated = new TransformedMap <> ( map , keyTransformer , valueTransformer ) ; if ( map . size () > 0 ) { MST[NonVoidMethodCallMutator]MSP[S]
out . defaultWriteObject () ; out . writeObject ( map ) ; } @SuppressWarnings ( lr_1 ) private void readObject ( final ObjectInputStream in ) throws IOException , ClassNotFoundException { in . defaultReadObject () ; MST[VoidMethodCallMutator]MSP[N] map = ( Map < K , V > ) in . readObject () ;
return ( Map < K , V > ) map ; } final Map < K , V > result = new LinkedMap <> ( map . size () ) ; MST[ConstructorCallMutator]MSP[N]
for ( final Map . Entry < ? extends K , ? extends V > entry : map . entrySet () ) { result . put ( transformKey ( entry . getKey () ) , transformValue ( entry . getValue () ) ) ; MST[ArgumentPropagationMutator]MSP[N] } return result ; } @Override
protected V checkSetValue ( final V value ) { return valueTransformer . transform ( value ) ; } @Override protected boolean isSetValueChecking () { return valueTransformer != null ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } @Override public V put ( K key , V value ) { key = transformKey ( key ) ;
value = transformValue ( value ) ; return decorated () . put ( key , value ) ; MST[NonVoidMethodCallMutator]MSP[N] } @Override public void putAll ( Map < ? extends K , ? extends V > mapToCopy ) { mapToCopy = transformMap ( mapToCopy ) ;
protected V checkSetValue ( final V value ) { return valueTransformer . transform ( value ) ; } @Override protected boolean isSetValueChecking () { return valueTransformer != null ; MST[rv.CRCR2Mutator]MSP[S] } @Override public V put ( K key , V value ) { key = transformKey ( key ) ;
for ( final Map . Entry < ? extends K , ? extends V > entry : map . entrySet () ) { MST[NonVoidMethodCallMutator]MSP[N] result . put ( transformKey ( entry . getKey () ) , transformValue ( entry . getValue () ) ) ; } return result ; } @Override
for ( final Map . Entry < ? extends K , ? extends V > entry : map . entrySet () ) { result . put ( transformKey ( entry . getKey () ) , transformValue ( entry . getValue () ) ) ; } return result ; MST[NullReturnValsMutator]MSP[N] } @Override
return valueTransformer . transform ( object ) ; } @SuppressWarnings ( lr_1 ) protected Map < K , V > transformMap ( final Map < ? extends K , ? extends V > map ) { if ( map . isEmpty () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
protected V checkSetValue ( final V value ) { return valueTransformer . transform ( value ) ; } @Override protected boolean isSetValueChecking () { return valueTransformer != null ; MST[rv.CRCR4Mutator]MSP[N] } @Override public V put ( K key , V value ) { key = transformKey ( key ) ;
value = transformValue ( value ) ; MST[ArgumentPropagationMutator]MSP[N] return decorated () . put ( key , value ) ; } @Override public void putAll ( Map < ? extends K , ? extends V > mapToCopy ) { mapToCopy = transformMap ( mapToCopy ) ;
protected V checkSetValue ( final V value ) { return valueTransformer . transform ( value ) ; MST[NullReturnValsMutator]MSP[S] } @Override protected boolean isSetValueChecking () { return valueTransformer != null ; } @Override public V put ( K key , V value ) { key = transformKey ( key ) ;
for ( final Map . Entry < ? extends K , ? extends V > entry : map . entrySet () ) { result . put ( transformKey ( entry . getKey () ) , transformValue ( entry . getValue () ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } return result ; } @Override
return ( Map < K , V > ) map ; MST[NullReturnValsMutator]MSP[S] } final Map < K , V > result = new LinkedMap <> ( map . size () ) ;
out . defaultWriteObject () ; out . writeObject ( map ) ; MST[VoidMethodCallMutator]MSP[S] } @SuppressWarnings ( lr_1 ) private void readObject ( final ObjectInputStream in ) throws IOException , ClassNotFoundException { in . defaultReadObject () ; map = ( Map < K , V > ) in . readObject () ;
protected V checkSetValue ( final V value ) { return valueTransformer . transform ( value ) ; } @Override protected boolean isSetValueChecking () { return valueTransformer != null ; MST[rv.ROR5Mutator]MSP[S] } @Override public V put ( K key , V value ) { key = transformKey ( key ) ;
return valueTransformer . transform ( object ) ; MST[NonVoidMethodCallMutator]MSP[N] } @SuppressWarnings ( lr_1 ) protected Map < K , V > transformMap ( final Map < ? extends K , ? extends V > map ) { if ( map . isEmpty () ) {
final Transformer < ? super V , ? extends V > valueTransformer ) { final TransformedMap < K , V > decorated = new TransformedMap <> ( map , keyTransformer , valueTransformer ) ; if ( map . size () > 0 ) { MST[rv.ROR1Mutator]MSP[N]
value = transformValue ( value ) ; MST[NonVoidMethodCallMutator]MSP[N] return decorated () . put ( key , value ) ; } @Override public void putAll ( Map < ? extends K , ? extends V > mapToCopy ) { mapToCopy = transformMap ( mapToCopy ) ;
final Transformer < ? super V , ? extends V > valueTransformer ) { final TransformedMap < K , V > decorated = new TransformedMap <> ( map , keyTransformer , valueTransformer ) ; if ( map . size () > 0 ) { MST[rv.ROR5Mutator]MSP[S]
protected V checkSetValue ( final V value ) { return valueTransformer . transform ( value ) ; } @Override protected boolean isSetValueChecking () { return valueTransformer != null ; MST[InlineConstantMutator]MSP[S] } @Override public V put ( K key , V value ) { key = transformKey ( key ) ;
return valueTransformer . transform ( object ) ; } @SuppressWarnings ( lr_1 ) protected Map < K , V > transformMap ( final Map < ? extends K , ? extends V > map ) { if ( map . isEmpty () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
protected V checkSetValue ( final V value ) { return valueTransformer . transform ( value ) ; } @Override protected boolean isSetValueChecking () { return valueTransformer != null ; MST[rv.CRCR3Mutator]MSP[N] } @Override public V put ( K key , V value ) { key = transformKey ( key ) ;
value = transformValue ( value ) ; return decorated () . put ( key , value ) ; MST[ArgumentPropagationMutator]MSP[N] } @Override public void putAll ( Map < ? extends K , ? extends V > mapToCopy ) { mapToCopy = transformMap ( mapToCopy ) ;
value = transformValue ( value ) ; return decorated () . put ( key , value ) ; MST[NonVoidMethodCallMutator]MSP[N] } @Override public void putAll ( Map < ? extends K , ? extends V > mapToCopy ) { mapToCopy = transformMap ( mapToCopy ) ;
return valueTransformer . transform ( object ) ; MST[ArgumentPropagationMutator]MSP[N] } @SuppressWarnings ( lr_1 ) protected Map < K , V > transformMap ( final Map < ? extends K , ? extends V > map ) { if ( map . isEmpty () ) {
protected V checkSetValue ( final V value ) { return valueTransformer . transform ( value ) ; } @Override protected boolean isSetValueChecking () { return valueTransformer != null ; MST[BooleanTrueReturnValsMutator]MSP[N] } @Override public V put ( K key , V value ) { key = transformKey ( key ) ;
out . defaultWriteObject () ; out . writeObject ( map ) ; } @SuppressWarnings ( lr_1 ) private void readObject ( final ObjectInputStream in ) throws IOException , ClassNotFoundException { in . defaultReadObject () ; map = ( Map < K , V > ) in . readObject () ; MST[experimental.MemberVariableMutator]MSP[S]
final Transformer < ? super V , ? extends V > valueTransformer ) { return new TransformedMap <> ( map , keyTransformer , valueTransformer ) ; MST[NullReturnValsMutator]MSP[N] }
protected V checkSetValue ( final V value ) { return valueTransformer . transform ( value ) ; MST[NonVoidMethodCallMutator]MSP[S] } @Override protected boolean isSetValueChecking () { return valueTransformer != null ; } @Override public V put ( K key , V value ) { key = transformKey ( key ) ;
final Map < K , V > transformed = decorated . transformMap ( map ) ; decorated . clear () ; decorated . decorated () . putAll ( transformed ) ; } return decorated ; MST[ReturnValsMutator]MSP[S] } private void writeObject ( final ObjectOutputStream out ) throws IOException {
} protected K transformKey ( final K object ) { if ( keyTransformer == null ) { return object ; } return keyTransformer . transform ( object ) ; } protected V transformValue ( final V object ) { if ( valueTransformer == null ) { MST[rv.ROR5Mutator]MSP[N] return object ; }
} protected K transformKey ( final K object ) { if ( keyTransformer == null ) { return object ; } return keyTransformer . transform ( object ) ; } protected V transformValue ( final V object ) { if ( valueTransformer == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return object ; }
for ( final Map . Entry < ? extends K , ? extends V > entry : map . entrySet () ) { result . put ( transformKey ( entry . getKey () ) , transformValue ( entry . getValue () ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } return result ; } @Override
} protected K transformKey ( final K object ) { if ( keyTransformer == null ) { return object ; } return keyTransformer . transform ( object ) ; MST[NullReturnValsMutator]MSP[N] } protected V transformValue ( final V object ) { if ( valueTransformer == null ) { return object ; }
for ( final Map . Entry < ? extends K , ? extends V > entry : map . entrySet () ) { result . put ( transformKey ( entry . getKey () ) , transformValue ( entry . getValue () ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } return result ; } @Override
final Transformer < ? super V , ? extends V > valueTransformer ) { final TransformedMap < K , V > decorated = new TransformedMap <> ( map , keyTransformer , valueTransformer ) ; if ( map . size () > 0 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[S]
final Map < K , V > transformed = decorated . transformMap ( map ) ; decorated . clear () ; decorated . decorated () . putAll ( transformed ) ; MST[NonVoidMethodCallMutator]MSP[S] } return decorated ; } private void writeObject ( final ObjectOutputStream out ) throws IOException {
} protected K transformKey ( final K object ) { if ( keyTransformer == null ) { return object ; MST[NullReturnValsMutator]MSP[N] } return keyTransformer . transform ( object ) ; } protected V transformValue ( final V object ) { if ( valueTransformer == null ) { return object ; }
final Map < K , V > transformed = decorated . transformMap ( map ) ; decorated . clear () ; decorated . decorated () . putAll ( transformed ) ; MST[VoidMethodCallMutator]MSP[S] } return decorated ; } private void writeObject ( final ObjectOutputStream out ) throws IOException {
} protected K transformKey ( final K object ) { if ( keyTransformer == null ) { return object ; } return keyTransformer . transform ( object ) ; } protected V transformValue ( final V object ) { if ( valueTransformer == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] return object ; }
return valueTransformer . transform ( object ) ; } @SuppressWarnings ( lr_1 ) protected Map < K , V > transformMap ( final Map < ? extends K , ? extends V > map ) { if ( map . isEmpty () ) { MST[NegateConditionalsMutator]MSP[N]
final Map < K , V > transformed = decorated . transformMap ( map ) ; MST[NonVoidMethodCallMutator]MSP[S] decorated . clear () ; decorated . decorated () . putAll ( transformed ) ; } return decorated ; } private void writeObject ( final ObjectOutputStream out ) throws IOException {
final Transformer < ? super V , ? extends V > valueTransformer ) { final TransformedMap < K , V > decorated = new TransformedMap <> ( map , keyTransformer , valueTransformer ) ; if ( map . size () > 0 ) { MST[rv.ROR2Mutator]MSP[S]
return valueTransformer . transform ( object ) ; } @SuppressWarnings ( lr_1 ) protected Map < K , V > transformMap ( final Map < ? extends K , ? extends V > map ) { if ( map . isEmpty () ) { MST[NonVoidMethodCallMutator]MSP[N]
final Transformer < ? super V , ? extends V > valueTransformer ) { final TransformedMap < K , V > decorated = new TransformedMap <> ( map , keyTransformer , valueTransformer ) ; if ( map . size () > 0 ) { MST[rv.ROR4Mutator]MSP[N]
} protected K transformKey ( final K object ) { if ( keyTransformer == null ) { return object ; } return keyTransformer . transform ( object ) ; MST[NonVoidMethodCallMutator]MSP[N] } protected V transformValue ( final V object ) { if ( valueTransformer == null ) { return object ; }
final Transformer < ? super V , ? extends V > valueTransformer ) { return new TransformedMap <> ( map , keyTransformer , valueTransformer ) ; MST[ConstructorCallMutator]MSP[N] }
return ( Map < K , V > ) map ; } final Map < K , V > result = new LinkedMap <> ( map . size () ) ; MST[NonVoidMethodCallMutator]MSP[N]
final Transformer < ? super V , ? extends V > valueTransformer ) { final TransformedMap < K , V > decorated = new TransformedMap <> ( map , keyTransformer , valueTransformer ) ; if ( map . size () > 0 ) { MST[NegateConditionalsMutator]MSP[S]
final Transformer < ? super V , ? extends V > valueTransformer ) { final TransformedMap < K , V > decorated = new TransformedMap <> ( map , keyTransformer , valueTransformer ) ; if ( map . size () > 0 ) { MST[ConditionalsBoundaryMutator]MSP[N]
final Transformer < ? super V , ? extends V > valueTransformer ) { return new TransformedMap <> ( map , keyTransformer , valueTransformer ) ; MST[ReturnValsMutator]MSP[N] }
final Map < K , V > transformed = decorated . transformMap ( map ) ; MST[ArgumentPropagationMutator]MSP[S] decorated . clear () ; decorated . decorated () . putAll ( transformed ) ; } return decorated ; } private void writeObject ( final ObjectOutputStream out ) throws IOException {
} protected K transformKey ( final K object ) { if ( keyTransformer == null ) { return object ; } return keyTransformer . transform ( object ) ; } protected V transformValue ( final V object ) { if ( valueTransformer == null ) { MST[NegateConditionalsMutator]MSP[N] return object ; }
} protected K transformKey ( final K object ) { if ( keyTransformer == null ) { return object ; } return keyTransformer . transform ( object ) ; MST[ReturnValsMutator]MSP[N] } protected V transformValue ( final V object ) { if ( valueTransformer == null ) { return object ; }
final Transformer < ? super V , ? extends V > valueTransformer ) { final TransformedMap < K , V > decorated = new TransformedMap <> ( map , keyTransformer , valueTransformer ) ; if ( map . size () > 0 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N]
final Map < K , V > transformed = decorated . transformMap ( map ) ; decorated . clear () ; decorated . decorated () . putAll ( transformed ) ; } return decorated ; MST[NullReturnValsMutator]MSP[S] } private void writeObject ( final ObjectOutputStream out ) throws IOException {
} protected K transformKey ( final K object ) { if ( keyTransformer == null ) { return object ; MST[ReturnValsMutator]MSP[N] } return keyTransformer . transform ( object ) ; } protected V transformValue ( final V object ) { if ( valueTransformer == null ) { return object ; }
for ( final Map . Entry < ? extends K , ? extends V > entry : map . entrySet () ) { result . put ( transformKey ( entry . getKey () ) , transformValue ( entry . getValue () ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } return result ; } @Override
protected V checkSetValue ( final V value ) { return valueTransformer . transform ( value ) ; } @Override protected boolean isSetValueChecking () { return valueTransformer != null ; } @Override public V put ( K key , V value ) { key = transformKey ( key ) ; MST[ArgumentPropagationMutator]MSP[N]
protected V checkSetValue ( final V value ) { return valueTransformer . transform ( value ) ; } @Override protected boolean isSetValueChecking () { return valueTransformer != null ; MST[rv.CRCR5Mutator]MSP[S] } @Override public V put ( K key , V value ) { key = transformKey ( key ) ;
protected V checkSetValue ( final V value ) { return valueTransformer . transform ( value ) ; } @Override protected boolean isSetValueChecking () { return valueTransformer != null ; MST[rv.CRCR6Mutator]MSP[S] } @Override public V put ( K key , V value ) { key = transformKey ( key ) ;
} protected K transformKey ( final K object ) { if ( keyTransformer == null ) { return object ; } return keyTransformer . transform ( object ) ; MST[ArgumentPropagationMutator]MSP[N] } protected V transformValue ( final V object ) { if ( valueTransformer == null ) { return object ; }
for ( final Map . Entry < ? extends K , ? extends V > entry : map . entrySet () ) { result . put ( transformKey ( entry . getKey () ) , transformValue ( entry . getValue () ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } return result ; } @Override
} protected K transformKey ( final K object ) { if ( keyTransformer == null ) { MST[NegateConditionalsMutator]MSP[N] return object ; } return keyTransformer . transform ( object ) ; } protected V transformValue ( final V object ) { if ( valueTransformer == null ) { return object ; }
return valueTransformer . transform ( object ) ; MST[ReturnValsMutator]MSP[N] } @SuppressWarnings ( lr_1 ) protected Map < K , V > transformMap ( final Map < ? extends K , ? extends V > map ) { if ( map . isEmpty () ) {
value = transformValue ( value ) ; return decorated () . put ( key , value ) ; } @Override public void putAll ( Map < ? extends K , ? extends V > mapToCopy ) { mapToCopy = transformMap ( mapToCopy ) ; MST[NonVoidMethodCallMutator]MSP[S]
value = transformValue ( value ) ; return decorated () . put ( key , value ) ; } @Override public void putAll ( Map < ? extends K , ? extends V > mapToCopy ) { mapToCopy = transformMap ( mapToCopy ) ; MST[ArgumentPropagationMutator]MSP[N]
for ( final Map . Entry < ? extends K , ? extends V > entry : map . entrySet () ) { result . put ( transformKey ( entry . getKey () ) , transformValue ( entry . getValue () ) ) ; MST[ArgumentPropagationMutator]MSP[S] } return result ; } @Override
} protected K transformKey ( final K object ) { if ( keyTransformer == null ) { return object ; } return keyTransformer . transform ( object ) ; } protected V transformValue ( final V object ) { if ( valueTransformer == null ) { return object ; MST[ReturnValsMutator]MSP[S] }
protected V checkSetValue ( final V value ) { return valueTransformer . transform ( value ) ; } @Override protected boolean isSetValueChecking () { return valueTransformer != null ; MST[ReturnValsMutator]MSP[S] } @Override public V put ( K key , V value ) { key = transformKey ( key ) ;
return valueTransformer . transform ( object ) ; } @SuppressWarnings ( lr_1 ) protected Map < K , V > transformMap ( final Map < ? extends K , ? extends V > map ) { if ( map . isEmpty () ) { MST[rv.ROR5Mutator]MSP[N]
value = transformValue ( value ) ; return decorated () . put ( key , value ) ; MST[ReturnValsMutator]MSP[N] } @Override public void putAll ( Map < ? extends K , ? extends V > mapToCopy ) { mapToCopy = transformMap ( mapToCopy ) ;
protected V checkSetValue ( final V value ) { return valueTransformer . transform ( value ) ; MST[ArgumentPropagationMutator]MSP[S] } @Override protected boolean isSetValueChecking () { return valueTransformer != null ; } @Override public V put ( K key , V value ) { key = transformKey ( key ) ;
} protected K transformKey ( final K object ) { if ( keyTransformer == null ) { return object ; } return keyTransformer . transform ( object ) ; } protected V transformValue ( final V object ) { if ( valueTransformer == null ) { return object ; MST[NullReturnValsMutator]MSP[S] }
protected V checkSetValue ( final V value ) { return valueTransformer . transform ( value ) ; } @Override protected boolean isSetValueChecking () { return valueTransformer != null ; } @Override public V put ( K key , V value ) { key = transformKey ( key ) ; MST[NonVoidMethodCallMutator]MSP[N]
protected V checkSetValue ( final V value ) { return valueTransformer . transform ( value ) ; } @Override protected boolean isSetValueChecking () { return valueTransformer != null ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] } @Override public V put ( K key , V value ) { key = transformKey ( key ) ;
out . defaultWriteObject () ; MST[VoidMethodCallMutator]MSP[S] out . writeObject ( map ) ; } @SuppressWarnings ( lr_1 ) private void readObject ( final ObjectInputStream in ) throws IOException , ClassNotFoundException { in . defaultReadObject () ; map = ( Map < K , V > ) in . readObject () ;
final Transformer < ? super V , ? extends V > valueTransformer ) { final TransformedMap < K , V > decorated = new TransformedMap <> ( map , keyTransformer , valueTransformer ) ; if ( map . size () > 0 ) { MST[rv.ROR3Mutator]MSP[S]
} protected K transformKey ( final K object ) { if ( keyTransformer == null ) { MST[rv.ROR5Mutator]MSP[N] return object ; } return keyTransformer . transform ( object ) ; } protected V transformValue ( final V object ) { if ( valueTransformer == null ) { return object ; }
for ( final Map . Entry < ? extends K , ? extends V > entry : map . entrySet () ) { result . put ( transformKey ( entry . getKey () ) , transformValue ( entry . getValue () ) ) ; } return result ; MST[ReturnValsMutator]MSP[N] } @Override
