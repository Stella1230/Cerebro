final int pos = indexOf ( object ) ; final E removed = super . set ( index , object ) ; if ( pos != - 1 && pos != index ) { MST[rv.CRCR6Mutator]MSP[N] super . remove ( pos ) ; } set . remove ( removed ) ;
if ( set . contains ( object ) == false ) { MST[rv.ROR2Mutator]MSP[N] set . add ( object ) ; super . add ( index , object ) ; } } @Override public boolean addAll ( final Collection < ? extends E > coll ) {
subSet = new HashSet <> ( list . size () ) ; } else { try { subSet = set . getClass () . getDeclaredConstructor ( set . getClass () ) . newInstance ( set ) ; MST[rv.CRCR2Mutator]MSP[S] } catch ( final InstantiationException | IllegalAccessException | InvocationTargetException
final int pos = indexOf ( object ) ; final E removed = super . set ( index , object ) ; if ( pos != - 1 && pos != index ) { MST[rv.ROR1Mutator]MSP[N] super . remove ( pos ) ; } set . remove ( removed ) ;
if ( set . contains ( object ) == false ) { MST[rv.ROR4Mutator]MSP[N] set . add ( object ) ; super . add ( index , object ) ; } } @Override public boolean addAll ( final Collection < ? extends E > coll ) {
return new SetListListIterator <> ( super . listIterator ( index ) , set ) ; } @Override public List < E > subList ( final int fromIndex , final int toIndex ) { final List < E > superSubList = super . subList ( fromIndex , toIndex ) ; MST[rv.UOI3Mutator]MSP[N]
return new SetListIterator <> ( super . iterator () , set ) ; MST[ReturnValsMutator]MSP[N] } @Override public ListIterator < E > listIterator () { return new SetListListIterator <> ( super . listIterator () , set ) ; } @Override public ListIterator < E > listIterator ( final int index ) {
final int pos = indexOf ( object ) ; final E removed = super . set ( index , object ) ; if ( pos != - 1 && pos != index ) { MST[rv.ROR3Mutator]MSP[N] super . remove ( pos ) ; } set . remove ( removed ) ;
set . add ( object ) ; return removed ; } @Override public boolean remove ( final Object object ) { final boolean result = set . remove ( object ) ; if ( result ) { MST[rv.ROR5Mutator]MSP[S] super . remove ( object ) ; } return result ; } @Override
if ( set . contains ( object ) == false ) { set . add ( object ) ; super . add ( index , object ) ; MST[rv.ABSMutator]MSP[N] } } @Override public boolean addAll ( final Collection < ? extends E > coll ) {
protected Set < E > createSetBasedOnList ( final Set < E > set , final List < E > list ) { Set < E > subSet ; if ( set . getClass () . equals ( HashSet . class ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
subSet = new HashSet <> ( list . size () ) ; } else { try { subSet = set . getClass () . getDeclaredConstructor ( set . getClass () ) . newInstance ( set ) ; MST[rv.CRCR6Mutator]MSP[S] } catch ( final InstantiationException | IllegalAccessException | InvocationTargetException
subSet = new HashSet <> ( list . size () ) ; } else { try { subSet = set . getClass () . getDeclaredConstructor ( set . getClass () ) . newInstance ( set ) ; MST[rv.CRCR4Mutator]MSP[S] } catch ( final InstantiationException | IllegalAccessException | InvocationTargetException
final int pos = indexOf ( object ) ; final E removed = super . set ( index , object ) ; if ( pos != - 1 && pos != index ) { MST[rv.CRCR4Mutator]MSP[N] super . remove ( pos ) ; } set . remove ( removed ) ;
set . add ( object ) ; return removed ; } @Override public boolean remove ( final Object object ) { final boolean result = set . remove ( object ) ; if ( result ) { MST[rv.ROR3Mutator]MSP[S] super . remove ( object ) ; } return result ; } @Override
set . add ( object ) ; return removed ; } @Override public boolean remove ( final Object object ) { final boolean result = set . remove ( object ) ; if ( result ) { MST[rv.ABSMutator]MSP[N] super . remove ( object ) ; } return result ; } @Override
public E remove ( final int index ) { final E result = super . remove ( index ) ; set . remove ( result ) ; return result ; MST[NullReturnValsMutator]MSP[S] } @Override public boolean removeIf ( final Predicate < ? super E > filter ) {
result |= remove ( name ) ; } return result ; MST[ReturnValsMutator]MSP[N] } @Override public boolean retainAll ( final Collection < ? > coll ) { final boolean result = set . retainAll ( coll ) ; if ( result == false ) { return false ; }
result |= remove ( name ) ; } return result ; MST[BooleanTrueReturnValsMutator]MSP[S] } @Override public boolean retainAll ( final Collection < ? > coll ) { final boolean result = set . retainAll ( coll ) ; if ( result == false ) { return false ; }
final int pos = indexOf ( object ) ; final E removed = super . set ( index , object ) ; if ( pos != - 1 && pos != index ) { super . remove ( pos ) ; MST[rv.ABSMutator]MSP[N] } set . remove ( removed ) ;
final int pos = indexOf ( object ) ; final E removed = super . set ( index , object ) ; if ( pos != - 1 && pos != index ) { MST[rv.CRCR2Mutator]MSP[N] super . remove ( pos ) ; } set . remove ( removed ) ;
set . add ( object ) ; return removed ; } @Override public boolean remove ( final Object object ) { final boolean result = set . remove ( object ) ; if ( result ) { MST[rv.ROR1Mutator]MSP[N] super . remove ( object ) ; } return result ; } @Override
final boolean result = super . removeIf ( filter ) ; set . removeIf ( filter ) ; return result ; MST[rv.ABSMutator]MSP[N] } @Override public boolean removeAll ( final Collection < ? > coll ) { boolean result = false ; for ( final Object name : coll ) {
if ( set . add ( e ) ) { temp . add ( e ) ; } } return super . addAll ( index , temp ) ; MST[BooleanFalseReturnValsMutator]MSP[N] } @Override public E set ( final int index , final E object ) {
public boolean contains ( final Object object ) { return set . contains ( object ) ; } @Override public boolean containsAll ( final Collection < ? > coll ) { return set . containsAll ( coll ) ; MST[ReturnValsMutator]MSP[N] } @Override public Iterator < E > iterator () {
protected Set < E > createSetBasedOnList ( final Set < E > set , final List < E > list ) { Set < E > subSet ; if ( set . getClass () . equals ( HashSet . class ) ) { MST[rv.ROR5Mutator]MSP[N]
return new SetListListIterator <> ( super . listIterator ( index ) , set ) ; MST[rv.UOI1Mutator]MSP[N] } @Override public List < E > subList ( final int fromIndex , final int toIndex ) { final List < E > superSubList = super . subList ( fromIndex , toIndex ) ;
if ( set . size () == 0 ) { super . clear () ; } else { super . retainAll ( set ) ; } return result ; } @Override public void clear () { super . clear () ; set . clear () ; MST[VoidMethodCallMutator]MSP[S] } @Override
public boolean add ( final E object ) { final int sizeBefore = size () ; add ( size () , object ) ; return sizeBefore != size () ; MST[rv.ROR4Mutator]MSP[N] } @Override public void add ( final int index , final E object ) {
result |= remove ( name ) ; MST[rv.ABSMutator]MSP[N] } return result ; } @Override public boolean retainAll ( final Collection < ? > coll ) { final boolean result = set . retainAll ( coll ) ; if ( result == false ) { return false ; }
if ( set . size () == 0 ) { super . clear () ; } else { super . retainAll ( set ) ; } return result ; MST[BooleanFalseReturnValsMutator]MSP[N] } @Override public void clear () { super . clear () ; set . clear () ; } @Override
return new SetListListIterator <> ( super . listIterator ( index ) , set ) ; MST[rv.UOI3Mutator]MSP[N] } @Override public List < E > subList ( final int fromIndex , final int toIndex ) { final List < E > superSubList = super . subList ( fromIndex , toIndex ) ;
public boolean add ( final E object ) { final int sizeBefore = size () ; add ( size () , object ) ; return sizeBefore != size () ; MST[rv.ROR2Mutator]MSP[N] } @Override public void add ( final int index , final E object ) {
public boolean contains ( final Object object ) { return set . contains ( object ) ; } @Override public boolean containsAll ( final Collection < ? > coll ) { return set . containsAll ( coll ) ; MST[BooleanTrueReturnValsMutator]MSP[S] } @Override public Iterator < E > iterator () {
final int pos = indexOf ( object ) ; final E removed = super . set ( index , object ) ; if ( pos != - 1 && pos != index ) { MST[rv.ROR5Mutator]MSP[N] super . remove ( pos ) ; } set . remove ( removed ) ;
final int pos = indexOf ( object ) ; final E removed = super . set ( index , object ) ; if ( pos != - 1 && pos != index ) { MST[rv.ABSMutator]MSP[N] super . remove ( pos ) ; } set . remove ( removed ) ;
return new SetListListIterator <> ( super . listIterator ( index ) , set ) ; } @Override public List < E > subList ( final int fromIndex , final int toIndex ) { final List < E > superSubList = super . subList ( fromIndex , toIndex ) ; MST[rv.UOI1Mutator]MSP[N]
public boolean add ( final E object ) { final int sizeBefore = size () ; add ( size () , object ) ; return sizeBefore != size () ; MST[ReturnValsMutator]MSP[N] } @Override public void add ( final int index , final E object ) {
if ( set . add ( e ) ) { MST[NegateConditionalsMutator]MSP[N] temp . add ( e ) ; } } return super . addAll ( index , temp ) ; } @Override public E set ( final int index , final E object ) {
protected Set < E > createSetBasedOnList ( final Set < E > set , final List < E > list ) { Set < E > subSet ; if ( set . getClass () . equals ( HashSet . class ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
set . add ( object ) ; return removed ; } @Override public boolean remove ( final Object object ) { final boolean result = set . remove ( object ) ; if ( result ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] super . remove ( object ) ; } return result ; } @Override
return new SetListListIterator <> ( super . listIterator ( index ) , set ) ; } @Override public List < E > subList ( final int fromIndex , final int toIndex ) { final List < E > superSubList = super . subList ( fromIndex , toIndex ) ; MST[rv.UOI3Mutator]MSP[S]
final int pos = indexOf ( object ) ; final E removed = super . set ( index , object ) ; if ( pos != - 1 && pos != index ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] super . remove ( pos ) ; } set . remove ( removed ) ;
final boolean result = super . removeIf ( filter ) ; set . removeIf ( filter ) ; return result ; MST[BooleanFalseReturnValsMutator]MSP[N] } @Override public boolean removeAll ( final Collection < ? > coll ) { boolean result = false ; for ( final Object name : coll ) {
if ( set . size () == 0 ) { super . clear () ; } else { super . retainAll ( set ) ; MST[NonVoidMethodCallMutator]MSP[S] } return result ; } @Override public void clear () { super . clear () ; set . clear () ; } @Override
public static < E > SetUniqueList < E > setUniqueList ( final List < E > list ) { Objects . requireNonNull ( list , lr_1 ) ; if ( list . isEmpty () ) { MST[NonVoidMethodCallMutator]MSP[N]
if ( set . contains ( object ) == false ) { set . add ( object ) ; super . add ( index , object ) ; MST[rv.UOI2Mutator]MSP[N] } } @Override public boolean addAll ( final Collection < ? extends E > coll ) {
subSet = new HashSet <> ( list . size () ) ; } else { try { subSet = set . getClass () . getDeclaredConstructor ( set . getClass () ) . newInstance ( set ) ; MST[rv.CRCR1Mutator]MSP[S] } catch ( final InstantiationException | IllegalAccessException | InvocationTargetException
subSet = new HashSet <> ( list . size () ) ; } else { try { subSet = set . getClass () . getDeclaredConstructor ( set . getClass () ) . newInstance ( set ) ; MST[rv.CRCR5Mutator]MSP[S] } catch ( final InstantiationException | IllegalAccessException | InvocationTargetException
public boolean add ( final E object ) { final int sizeBefore = size () ; add ( size () , object ) ; return sizeBefore != size () ; MST[rv.UOI4Mutator]MSP[S] } @Override public void add ( final int index , final E object ) {
final int pos = indexOf ( object ) ; final E removed = super . set ( index , object ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( pos != - 1 && pos != index ) { super . remove ( pos ) ; } set . remove ( removed ) ;
public boolean contains ( final Object object ) { return set . contains ( object ) ; MST[BooleanTrueReturnValsMutator]MSP[N] } @Override public boolean containsAll ( final Collection < ? > coll ) { return set . containsAll ( coll ) ; } @Override public Iterator < E > iterator () {
final int pos = indexOf ( object ) ; final E removed = super . set ( index , object ) ; if ( pos != - 1 && pos != index ) { MST[rv.ROR2Mutator]MSP[N] super . remove ( pos ) ; } set . remove ( removed ) ;
final boolean result = super . removeIf ( filter ) ; set . removeIf ( filter ) ; return result ; MST[rv.UOI2Mutator]MSP[N] } @Override public boolean removeAll ( final Collection < ? > coll ) { boolean result = false ; for ( final Object name : coll ) {
| NoSuchMethodException ie ) { subSet = new HashSet <> () ; MST[ConstructorCallMutator]MSP[S] } } return subSet ; } @Override public E next () { last = super . next () ; return last ; } @Override public void remove () { super . remove () ;
public static < E > SetUniqueList < E > setUniqueList ( final List < E > list ) { Objects . requireNonNull ( list , lr_1 ) ; if ( list . isEmpty () ) { MST[rv.ROR5Mutator]MSP[N]
public static < E > SetUniqueList < E > setUniqueList ( final List < E > list ) { Objects . requireNonNull ( list , lr_1 ) ; if ( list . isEmpty () ) { MST[rv.ROR1Mutator]MSP[N]
set . add ( object ) ; return removed ; } @Override public boolean remove ( final Object object ) { final boolean result = set . remove ( object ) ; if ( result ) { MST[rv.UOI2Mutator]MSP[N] super . remove ( object ) ; } return result ; } @Override
final int pos = indexOf ( object ) ; final E removed = super . set ( index , object ) ; if ( pos != - 1 && pos != index ) { super . remove ( pos ) ; MST[rv.UOI4Mutator]MSP[N] } set . remove ( removed ) ;
final SetUniqueList < E > sl = new SetUniqueList <> ( list , new HashSet < E > () ) ; sl . addAll ( temp ) ; return sl ; MST[NullReturnValsMutator]MSP[S] } public Set < E > asSet () { return UnmodifiableSet . unmodifiableSet ( set ) ; } @Override
return addAll ( size () , coll ) ; MST[NonVoidMethodCallMutator]MSP[N] } @Override public boolean addAll ( final int index , final Collection < ? extends E > coll ) { final List < E > temp = new ArrayList <> () ; for ( final E e : coll ) {
return new SetListIterator <> ( super . iterator () , set ) ; MST[NonVoidMethodCallMutator]MSP[N] } @Override public ListIterator < E > listIterator () { return new SetListListIterator <> ( super . listIterator () , set ) ; } @Override public ListIterator < E > listIterator ( final int index ) {
public E remove ( final int index ) { final E result = super . remove ( index ) ; MST[rv.UOI1Mutator]MSP[N] set . remove ( result ) ; return result ; } @Override public boolean removeIf ( final Predicate < ? super E > filter ) {
return new SetUniqueList <> ( list , new HashSet < E > () ) ; } final List < E > temp = new ArrayList <> ( list ) ; list . clear () ; MST[VoidMethodCallMutator]MSP[S]
set . add ( object ) ; return removed ; MST[ReturnValsMutator]MSP[N] } @Override public boolean remove ( final Object object ) { final boolean result = set . remove ( object ) ; if ( result ) { super . remove ( object ) ; } return result ; } @Override
result |= remove ( name ) ; } return result ; MST[rv.UOI3Mutator]MSP[N] } @Override public boolean retainAll ( final Collection < ? > coll ) { final boolean result = set . retainAll ( coll ) ; if ( result == false ) { return false ; }
result |= remove ( name ) ; } return result ; } @Override public boolean retainAll ( final Collection < ? > coll ) { final boolean result = set . retainAll ( coll ) ; if ( result == false ) { MST[rv.ROR2Mutator]MSP[N] return false ; }
if ( set . size () == 0 ) { MST[NegateConditionalsMutator]MSP[S] super . clear () ; } else { super . retainAll ( set ) ; } return result ; } @Override public void clear () { super . clear () ; set . clear () ; } @Override
protected Set < E > createSetBasedOnList ( final Set < E > set , final List < E > list ) { Set < E > subSet ; if ( set . getClass () . equals ( HashSet . class ) ) { MST[rv.ROR1Mutator]MSP[N]
public static < E > SetUniqueList < E > setUniqueList ( final List < E > list ) { Objects . requireNonNull ( list , lr_1 ) ; MST[ArgumentPropagationMutator]MSP[N] if ( list . isEmpty () ) {
if ( set . size () == 0 ) { super . clear () ; } else { super . retainAll ( set ) ; } return result ; MST[rv.ABSMutator]MSP[N] } @Override public void clear () { super . clear () ; set . clear () ; } @Override
final int pos = indexOf ( object ) ; final E removed = super . set ( index , object ) ; if ( pos != - 1 && pos != index ) { MST[rv.UOI4Mutator]MSP[N] super . remove ( pos ) ; } set . remove ( removed ) ;
public boolean add ( final E object ) { final int sizeBefore = size () ; add ( size () , object ) ; return sizeBefore != size () ; MST[rv.CRCR5Mutator]MSP[N] } @Override public void add ( final int index , final E object ) {
result |= remove ( name ) ; MST[rv.UOI2Mutator]MSP[N] } return result ; } @Override public boolean retainAll ( final Collection < ? > coll ) { final boolean result = set . retainAll ( coll ) ; if ( result == false ) { return false ; }
return new SetUniqueList <> ( list , new HashSet < E > () ) ; MST[NullReturnValsMutator]MSP[N] } final List < E > temp = new ArrayList <> ( list ) ; list . clear () ;
if ( set . add ( e ) ) { MST[rv.ROR5Mutator]MSP[N] temp . add ( e ) ; } } return super . addAll ( index , temp ) ; } @Override public E set ( final int index , final E object ) {
final int pos = indexOf ( object ) ; final E removed = super . set ( index , object ) ; if ( pos != - 1 && pos != index ) { MST[NegateConditionalsMutator]MSP[N] super . remove ( pos ) ; } set . remove ( removed ) ;
result |= remove ( name ) ; } return result ; } @Override public boolean retainAll ( final Collection < ? > coll ) { final boolean result = set . retainAll ( coll ) ; if ( result == false ) { return false ; MST[rv.CRCR6Mutator]MSP[S] }
if ( set . add ( e ) ) { MST[rv.ROR1Mutator]MSP[N] temp . add ( e ) ; } } return super . addAll ( index , temp ) ; } @Override public E set ( final int index , final E object ) {
return new SetListListIterator <> ( super . listIterator ( index ) , set ) ; MST[NullReturnValsMutator]MSP[S] } @Override public List < E > subList ( final int fromIndex , final int toIndex ) { final List < E > superSubList = super . subList ( fromIndex , toIndex ) ;
final int pos = indexOf ( object ) ; final E removed = super . set ( index , object ) ; MST[rv.UOI2Mutator]MSP[N] if ( pos != - 1 && pos != index ) { super . remove ( pos ) ; } set . remove ( removed ) ;
set . add ( object ) ; return removed ; } @Override public boolean remove ( final Object object ) { final boolean result = set . remove ( object ) ; if ( result ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] super . remove ( object ) ; } return result ; } @Override
return new SetUniqueList <> ( list , new HashSet < E > () ) ; } final List < E > temp = new ArrayList <> ( list ) ; MST[ConstructorCallMutator]MSP[S] list . clear () ;
public boolean add ( final E object ) { final int sizeBefore = size () ; add ( size () , object ) ; MST[VoidMethodCallMutator]MSP[N] return sizeBefore != size () ; } @Override public void add ( final int index , final E object ) {
return addAll ( size () , coll ) ; } @Override public boolean addAll ( final int index , final Collection < ? extends E > coll ) { final List < E > temp = new ArrayList <> () ; MST[ConstructorCallMutator]MSP[N] for ( final E e : coll ) {
public static < E > SetUniqueList < E > setUniqueList ( final List < E > list ) { Objects . requireNonNull ( list , lr_1 ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( list . isEmpty () ) {
final Set < E > subSet = createSetBasedOnList ( set , superSubList ) ; MST[ArgumentPropagationMutator]MSP[N] return ListUtils . unmodifiableList ( new SetUniqueList <> ( superSubList , subSet ) ) ; }
if ( set . size () == 0 ) { MST[rv.ROR2Mutator]MSP[S] super . clear () ; } else { super . retainAll ( set ) ; } return result ; } @Override public void clear () { super . clear () ; set . clear () ; } @Override
set . add ( object ) ; return removed ; } @Override public boolean remove ( final Object object ) { final boolean result = set . remove ( object ) ; if ( result ) { super . remove ( object ) ; } return result ; MST[rv.UOI1Mutator]MSP[N] } @Override
if ( set . add ( e ) ) { temp . add ( e ) ; } } return super . addAll ( index , temp ) ; MST[rv.UOI4Mutator]MSP[N] } @Override public E set ( final int index , final E object ) {
result |= remove ( name ) ; MST[rv.OBBN1Mutator]MSP[S] } return result ; } @Override public boolean retainAll ( final Collection < ? > coll ) { final boolean result = set . retainAll ( coll ) ; if ( result == false ) { return false ; }
if ( set . size () == 0 ) { MST[rv.ROR5Mutator]MSP[S] super . clear () ; } else { super . retainAll ( set ) ; } return result ; } @Override public void clear () { super . clear () ; set . clear () ; } @Override
result |= remove ( name ) ; MST[MathMutator]MSP[S] } return result ; } @Override public boolean retainAll ( final Collection < ? > coll ) { final boolean result = set . retainAll ( coll ) ; if ( result == false ) { return false ; }
set . add ( object ) ; return removed ; } @Override public boolean remove ( final Object object ) { final boolean result = set . remove ( object ) ; if ( result ) { super . remove ( object ) ; } return result ; MST[rv.UOI4Mutator]MSP[N] } @Override
if ( set . add ( e ) ) { temp . add ( e ) ; } } return super . addAll ( index , temp ) ; MST[NonVoidMethodCallMutator]MSP[N] } @Override public E set ( final int index , final E object ) {
result |= remove ( name ) ; } return result ; } @Override public boolean retainAll ( final Collection < ? > coll ) { final boolean result = set . retainAll ( coll ) ; if ( result == false ) { MST[rv.UOI1Mutator]MSP[N] return false ; }
result |= remove ( name ) ; } return result ; } @Override public boolean retainAll ( final Collection < ? > coll ) { final boolean result = set . retainAll ( coll ) ; if ( result == false ) { MST[rv.UOI2Mutator]MSP[N] return false ; }
result |= remove ( name ) ; } return result ; } @Override public boolean retainAll ( final Collection < ? > coll ) { final boolean result = set . retainAll ( coll ) ; if ( result == false ) { MST[rv.UOI4Mutator]MSP[N] return false ; }
subSet = new HashSet <> ( list . size () ) ; } else { try { subSet = set . getClass () . getDeclaredConstructor ( set . getClass () ) . newInstance ( set ) ; MST[InlineConstantMutator]MSP[S] } catch ( final InstantiationException | IllegalAccessException | InvocationTargetException
public boolean add ( final E object ) { final int sizeBefore = size () ; add ( size () , object ) ; return sizeBefore != size () ; MST[rv.CRCR6Mutator]MSP[N] } @Override public void add ( final int index , final E object ) {
result |= remove ( name ) ; } return result ; } @Override public boolean retainAll ( final Collection < ? > coll ) { final boolean result = set . retainAll ( coll ) ; if ( result == false ) { return false ; MST[rv.CRCR1Mutator]MSP[S] }
final int pos = indexOf ( object ) ; final E removed = super . set ( index , object ) ; if ( pos != - 1 && pos != index ) { MST[InlineConstantMutator]MSP[N] super . remove ( pos ) ; } set . remove ( removed ) ;
final int pos = indexOf ( object ) ; final E removed = super . set ( index , object ) ; MST[ArgumentPropagationMutator]MSP[N] if ( pos != - 1 && pos != index ) { super . remove ( pos ) ; } set . remove ( removed ) ;
set . add ( object ) ; MST[NonVoidMethodCallMutator]MSP[S] return removed ; } @Override public boolean remove ( final Object object ) { final boolean result = set . remove ( object ) ; if ( result ) { super . remove ( object ) ; } return result ; } @Override
final int pos = indexOf ( object ) ; final E removed = super . set ( index , object ) ; if ( pos != - 1 && pos != index ) { MST[rv.UOI3Mutator]MSP[N] super . remove ( pos ) ; } set . remove ( removed ) ;
return new SetListIterator <> ( super . iterator () , set ) ; } @Override public ListIterator < E > listIterator () { return new SetListListIterator <> ( super . listIterator () , set ) ; MST[ReturnValsMutator]MSP[N] } @Override public ListIterator < E > listIterator ( final int index ) {
return new SetListListIterator <> ( super . listIterator ( index ) , set ) ; MST[rv.ABSMutator]MSP[S] } @Override public List < E > subList ( final int fromIndex , final int toIndex ) { final List < E > superSubList = super . subList ( fromIndex , toIndex ) ;
public static < E > SetUniqueList < E > setUniqueList ( final List < E > list ) { Objects . requireNonNull ( list , lr_1 ) ; if ( list . isEmpty () ) { MST[NegateConditionalsMutator]MSP[N]
set . add ( object ) ; return removed ; } @Override public boolean remove ( final Object object ) { final boolean result = set . remove ( object ) ; if ( result ) { super . remove ( object ) ; } return result ; MST[ReturnValsMutator]MSP[N] } @Override
if ( set . add ( e ) ) { MST[rv.ROR4Mutator]MSP[N] temp . add ( e ) ; } } return super . addAll ( index , temp ) ; } @Override public E set ( final int index , final E object ) {
final int pos = indexOf ( object ) ; final E removed = super . set ( index , object ) ; if ( pos != - 1 && pos != index ) { MST[rv.UOI1Mutator]MSP[N] super . remove ( pos ) ; } set . remove ( removed ) ;
public boolean add ( final E object ) { final int sizeBefore = size () ; add ( size () , object ) ; return sizeBefore != size () ; MST[rv.ABSMutator]MSP[N] } @Override public void add ( final int index , final E object ) {
return new SetListListIterator <> ( super . listIterator ( index ) , set ) ; } @Override public List < E > subList ( final int fromIndex , final int toIndex ) { final List < E > superSubList = super . subList ( fromIndex , toIndex ) ; MST[rv.ABSMutator]MSP[S]
if ( set . add ( e ) ) { MST[rv.ROR2Mutator]MSP[N] temp . add ( e ) ; } } return super . addAll ( index , temp ) ; } @Override public E set ( final int index , final E object ) {
return new SetUniqueList <> ( list , new HashSet < E > () ) ; MST[ConstructorCallMutator]MSP[N] } final List < E > temp = new ArrayList <> ( list ) ; list . clear () ;
set . add ( object ) ; return removed ; } @Override public boolean remove ( final Object object ) { final boolean result = set . remove ( object ) ; if ( result ) { MST[rv.UOI3Mutator]MSP[N] super . remove ( object ) ; } return result ; } @Override
public boolean contains ( final Object object ) { return set . contains ( object ) ; MST[ReturnValsMutator]MSP[N] } @Override public boolean containsAll ( final Collection < ? > coll ) { return set . containsAll ( coll ) ; } @Override public Iterator < E > iterator () {
if ( set . contains ( object ) == false ) { set . add ( object ) ; super . add ( index , object ) ; MST[rv.UOI3Mutator]MSP[N] } } @Override public boolean addAll ( final Collection < ? extends E > coll ) {
return new SetListListIterator <> ( super . listIterator ( index ) , set ) ; } @Override public List < E > subList ( final int fromIndex , final int toIndex ) { final List < E > superSubList = super . subList ( fromIndex , toIndex ) ; MST[rv.UOI4Mutator]MSP[N]
public static < E > SetUniqueList < E > setUniqueList ( final List < E > list ) { Objects . requireNonNull ( list , lr_1 ) ; if ( list . isEmpty () ) { MST[rv.ROR4Mutator]MSP[N]
final int pos = indexOf ( object ) ; final E removed = super . set ( index , object ) ; if ( pos != - 1 && pos != index ) { MST[rv.ROR3Mutator]MSP[N] super . remove ( pos ) ; } set . remove ( removed ) ;
final int pos = indexOf ( object ) ; final E removed = super . set ( index , object ) ; if ( pos != - 1 && pos != index ) { super . remove ( pos ) ; MST[rv.UOI2Mutator]MSP[N] } set . remove ( removed ) ;
return addAll ( size () , coll ) ; MST[NonVoidMethodCallMutator]MSP[N] } @Override public boolean addAll ( final int index , final Collection < ? extends E > coll ) { final List < E > temp = new ArrayList <> () ; for ( final E e : coll ) {
public boolean add ( final E object ) { final int sizeBefore = size () ; add ( size () , object ) ; return sizeBefore != size () ; MST[BooleanTrueReturnValsMutator]MSP[S] } @Override public void add ( final int index , final E object ) {
final SetUniqueList < E > sl = new SetUniqueList <> ( list , new HashSet < E > () ) ; sl . addAll ( temp ) ; return sl ; } public Set < E > asSet () { return UnmodifiableSet . unmodifiableSet ( set ) ; MST[ArgumentPropagationMutator]MSP[N] } @Override
if ( set . contains ( object ) == false ) { MST[NegateConditionalsMutator]MSP[N] set . add ( object ) ; super . add ( index , object ) ; } } @Override public boolean addAll ( final Collection < ? extends E > coll ) {
return addAll ( size () , coll ) ; MST[BooleanFalseReturnValsMutator]MSP[S] } @Override public boolean addAll ( final int index , final Collection < ? extends E > coll ) { final List < E > temp = new ArrayList <> () ; for ( final E e : coll ) {
final int pos = indexOf ( object ) ; final E removed = super . set ( index , object ) ; if ( pos != - 1 && pos != index ) { super . remove ( pos ) ; } set . remove ( removed ) ; MST[NonVoidMethodCallMutator]MSP[N]
result |= remove ( name ) ; MST[NonVoidMethodCallMutator]MSP[S] } return result ; } @Override public boolean retainAll ( final Collection < ? > coll ) { final boolean result = set . retainAll ( coll ) ; if ( result == false ) { return false ; }
protected Set < E > createSetBasedOnList ( final Set < E > set , final List < E > list ) { Set < E > subSet ; if ( set . getClass () . equals ( HashSet . class ) ) { MST[NegateConditionalsMutator]MSP[N]
set . add ( object ) ; return removed ; } @Override public boolean remove ( final Object object ) { final boolean result = set . remove ( object ) ; if ( result ) { super . remove ( object ) ; } return result ; MST[rv.ABSMutator]MSP[N] } @Override
public E remove ( final int index ) { final E result = super . remove ( index ) ; MST[rv.UOI2Mutator]MSP[N] set . remove ( result ) ; return result ; } @Override public boolean removeIf ( final Predicate < ? super E > filter ) {
final int pos = indexOf ( object ) ; final E removed = super . set ( index , object ) ; if ( pos != - 1 && pos != index ) { super . remove ( pos ) ; MST[NonVoidMethodCallMutator]MSP[N] } set . remove ( removed ) ;
result |= remove ( name ) ; } return result ; } @Override public boolean retainAll ( final Collection < ? > coll ) { final boolean result = set . retainAll ( coll ) ; if ( result == false ) { MST[rv.ROR1Mutator]MSP[N] return false ; }
result |= remove ( name ) ; } return result ; } @Override public boolean retainAll ( final Collection < ? > coll ) { final boolean result = set . retainAll ( coll ) ; if ( result == false ) { MST[rv.ROR4Mutator]MSP[N] return false ; }
public boolean add ( final E object ) { final int sizeBefore = size () ; add ( size () , object ) ; return sizeBefore != size () ; MST[rv.ROR1Mutator]MSP[N] } @Override public void add ( final int index , final E object ) {
final SetUniqueList < E > sl = new SetUniqueList <> ( list , new HashSet < E > () ) ; sl . addAll ( temp ) ; return sl ; } public Set < E > asSet () { return UnmodifiableSet . unmodifiableSet ( set ) ; MST[EmptyObjectReturnValsMutator]MSP[N] } @Override
return new SetListListIterator <> ( super . listIterator ( index ) , set ) ; MST[rv.UOI4Mutator]MSP[N] } @Override public List < E > subList ( final int fromIndex , final int toIndex ) { final List < E > superSubList = super . subList ( fromIndex , toIndex ) ;
set . add ( object ) ; return removed ; } @Override public boolean remove ( final Object object ) { final boolean result = set . remove ( object ) ; if ( result ) { super . remove ( object ) ; } return result ; MST[BooleanTrueReturnValsMutator]MSP[N] } @Override
if ( set . size () == 0 ) { MST[NonVoidMethodCallMutator]MSP[S] super . clear () ; } else { super . retainAll ( set ) ; } return result ; } @Override public void clear () { super . clear () ; set . clear () ; } @Override
public boolean add ( final E object ) { final int sizeBefore = size () ; add ( size () , object ) ; return sizeBefore != size () ; MST[rv.CRCR3Mutator]MSP[N] } @Override public void add ( final int index , final E object ) {
if ( set . add ( e ) ) { temp . add ( e ) ; } } return super . addAll ( index , temp ) ; MST[rv.UOI2Mutator]MSP[N] } @Override public E set ( final int index , final E object ) {
return new SetListIterator <> ( super . iterator () , set ) ; MST[ConstructorCallMutator]MSP[N] } @Override public ListIterator < E > listIterator () { return new SetListListIterator <> ( super . listIterator () , set ) ; } @Override public ListIterator < E > listIterator ( final int index ) {
final int pos = indexOf ( object ) ; final E removed = super . set ( index , object ) ; if ( pos != - 1 && pos != index ) { MST[rv.UOI3Mutator]MSP[N] super . remove ( pos ) ; } set . remove ( removed ) ;
result |= remove ( name ) ; MST[rv.UOI4Mutator]MSP[S] } return result ; } @Override public boolean retainAll ( final Collection < ? > coll ) { final boolean result = set . retainAll ( coll ) ; if ( result == false ) { return false ; }
if ( set . size () == 0 ) { super . clear () ; } else { super . retainAll ( set ) ; } return result ; } @Override public void clear () { super . clear () ; MST[VoidMethodCallMutator]MSP[N] set . clear () ; } @Override
return new SetListIterator <> ( super . iterator () , set ) ; } @Override public ListIterator < E > listIterator () { return new SetListListIterator <> ( super . listIterator () , set ) ; MST[NullReturnValsMutator]MSP[N] } @Override public ListIterator < E > listIterator ( final int index ) {
return new SetListListIterator <> ( super . listIterator ( index ) , set ) ; } @Override public List < E > subList ( final int fromIndex , final int toIndex ) { final List < E > superSubList = super . subList ( fromIndex , toIndex ) ; MST[rv.ABSMutator]MSP[S]
final int pos = indexOf ( object ) ; final E removed = super . set ( index , object ) ; if ( pos != - 1 && pos != index ) { MST[rv.UOI2Mutator]MSP[N] super . remove ( pos ) ; } set . remove ( removed ) ;
return new SetListListIterator <> ( super . listIterator ( index ) , set ) ; } @Override public List < E > subList ( final int fromIndex , final int toIndex ) { final List < E > superSubList = super . subList ( fromIndex , toIndex ) ; MST[rv.UOI1Mutator]MSP[N]
public boolean add ( final E object ) { final int sizeBefore = size () ; MST[NonVoidMethodCallMutator]MSP[N] add ( size () , object ) ; return sizeBefore != size () ; } @Override public void add ( final int index , final E object ) {
final int pos = indexOf ( object ) ; final E removed = super . set ( index , object ) ; if ( pos != - 1 && pos != index ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] super . remove ( pos ) ; } set . remove ( removed ) ;
if ( set . size () == 0 ) { super . clear () ; } else { super . retainAll ( set ) ; } return result ; MST[rv.UOI3Mutator]MSP[N] } @Override public void clear () { super . clear () ; set . clear () ; } @Override
if ( set . contains ( object ) == false ) { MST[rv.ROR1Mutator]MSP[N] set . add ( object ) ; super . add ( index , object ) ; } } @Override public boolean addAll ( final Collection < ? extends E > coll ) {
if ( set . contains ( object ) == false ) { MST[rv.ROR3Mutator]MSP[N] set . add ( object ) ; super . add ( index , object ) ; } } @Override public boolean addAll ( final Collection < ? extends E > coll ) {
return new SetListListIterator <> ( super . listIterator ( index ) , set ) ; } @Override public List < E > subList ( final int fromIndex , final int toIndex ) { final List < E > superSubList = super . subList ( fromIndex , toIndex ) ; MST[rv.UOI4Mutator]MSP[N]
public boolean add ( final E object ) { final int sizeBefore = size () ; add ( size () , object ) ; return sizeBefore != size () ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] } @Override public void add ( final int index , final E object ) {
public boolean contains ( final Object object ) { return set . contains ( object ) ; } @Override public boolean containsAll ( final Collection < ? > coll ) { return set . containsAll ( coll ) ; MST[BooleanFalseReturnValsMutator]MSP[S] } @Override public Iterator < E > iterator () {
if ( set . add ( e ) ) { temp . add ( e ) ; } } return super . addAll ( index , temp ) ; MST[ReturnValsMutator]MSP[N] } @Override public E set ( final int index , final E object ) {
result |= remove ( name ) ; } return result ; } @Override public boolean retainAll ( final Collection < ? > coll ) { final boolean result = set . retainAll ( coll ) ; if ( result == false ) { MST[NegateConditionalsMutator]MSP[N] return false ; }
subSet = new HashSet <> ( list . size () ) ; } else { try { subSet = set . getClass () . getDeclaredConstructor ( set . getClass () ) . newInstance ( set ) ; MST[rv.CRCR5Mutator]MSP[N] } catch ( final InstantiationException | IllegalAccessException | InvocationTargetException
if ( set . contains ( object ) == false ) { MST[rv.ROR5Mutator]MSP[N] set . add ( object ) ; super . add ( index , object ) ; } } @Override public boolean addAll ( final Collection < ? extends E > coll ) {
final int pos = indexOf ( object ) ; final E removed = super . set ( index , object ) ; if ( pos != - 1 && pos != index ) { MST[rv.ROR2Mutator]MSP[N] super . remove ( pos ) ; } set . remove ( removed ) ;
final int pos = indexOf ( object ) ; final E removed = super . set ( index , object ) ; if ( pos != - 1 && pos != index ) { MST[rv.ROR4Mutator]MSP[N] super . remove ( pos ) ; } set . remove ( removed ) ;
result |= remove ( name ) ; } return result ; MST[BooleanFalseReturnValsMutator]MSP[S] } @Override public boolean retainAll ( final Collection < ? > coll ) { final boolean result = set . retainAll ( coll ) ; if ( result == false ) { return false ; }
public boolean add ( final E object ) { final int sizeBefore = size () ; add ( size () , object ) ; return sizeBefore != size () ; MST[InlineConstantMutator]MSP[N] } @Override public void add ( final int index , final E object ) {
set . add ( object ) ; return removed ; } @Override public boolean remove ( final Object object ) { final boolean result = set . remove ( object ) ; if ( result ) { MST[rv.ROR4Mutator]MSP[S] super . remove ( object ) ; } return result ; } @Override
subSet = new HashSet <> ( list . size () ) ; } else { try { subSet = set . getClass () . getDeclaredConstructor ( set . getClass () ) . newInstance ( set ) ; MST[rv.CRCR3Mutator]MSP[S] } catch ( final InstantiationException | IllegalAccessException | InvocationTargetException
final int pos = indexOf ( object ) ; final E removed = super . set ( index , object ) ; if ( pos != - 1 && pos != index ) { MST[rv.CRCR5Mutator]MSP[N] super . remove ( pos ) ; } set . remove ( removed ) ;
final int pos = indexOf ( object ) ; final E removed = super . set ( index , object ) ; if ( pos != - 1 && pos != index ) { MST[rv.CRCR1Mutator]MSP[N] super . remove ( pos ) ; } set . remove ( removed ) ;
set . add ( object ) ; return removed ; } @Override public boolean remove ( final Object object ) { final boolean result = set . remove ( object ) ; if ( result ) { MST[rv.ROR2Mutator]MSP[N] super . remove ( object ) ; } return result ; } @Override
return new SetListListIterator <> ( super . listIterator ( index ) , set ) ; MST[NonVoidMethodCallMutator]MSP[S] } @Override public List < E > subList ( final int fromIndex , final int toIndex ) { final List < E > superSubList = super . subList ( fromIndex , toIndex ) ;
result |= remove ( name ) ; } return result ; MST[rv.ABSMutator]MSP[N] } @Override public boolean retainAll ( final Collection < ? > coll ) { final boolean result = set . retainAll ( coll ) ; if ( result == false ) { return false ; }
final SetUniqueList < E > sl = new SetUniqueList <> ( list , new HashSet < E > () ) ; MST[ConstructorCallMutator]MSP[S] sl . addAll ( temp ) ; return sl ; } public Set < E > asSet () { return UnmodifiableSet . unmodifiableSet ( set ) ; } @Override
if ( set . add ( e ) ) { temp . add ( e ) ; } } return super . addAll ( index , temp ) ; MST[BooleanTrueReturnValsMutator]MSP[N] } @Override public E set ( final int index , final E object ) {
protected Set < E > createSetBasedOnList ( final Set < E > set , final List < E > list ) { Set < E > subSet ; if ( set . getClass () . equals ( HashSet . class ) ) { MST[rv.ROR4Mutator]MSP[N]
public E remove ( final int index ) { final E result = super . remove ( index ) ; MST[NonVoidMethodCallMutator]MSP[N] set . remove ( result ) ; return result ; } @Override public boolean removeIf ( final Predicate < ? super E > filter ) {
set . add ( object ) ; return removed ; } @Override public boolean remove ( final Object object ) { final boolean result = set . remove ( object ) ; if ( result ) { super . remove ( object ) ; MST[NonVoidMethodCallMutator]MSP[S] } return result ; } @Override
protected Set < E > createSetBasedOnList ( final Set < E > set , final List < E > list ) { Set < E > subSet ; if ( set . getClass () . equals ( HashSet . class ) ) { MST[rv.ROR2Mutator]MSP[N]
final boolean result = super . removeIf ( filter ) ; set . removeIf ( filter ) ; return result ; } @Override public boolean removeAll ( final Collection < ? > coll ) { boolean result = false ; MST[rv.CRCR5Mutator]MSP[S] for ( final Object name : coll ) {
final int pos = indexOf ( object ) ; final E removed = super . set ( index , object ) ; if ( pos != - 1 && pos != index ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] super . remove ( pos ) ; } set . remove ( removed ) ;
if ( set . add ( e ) ) { MST[NonVoidMethodCallMutator]MSP[N] temp . add ( e ) ; } } return super . addAll ( index , temp ) ; } @Override public E set ( final int index , final E object ) {
subSet = new HashSet <> ( list . size () ) ; MST[NonVoidMethodCallMutator]MSP[N] } else { try { subSet = set . getClass () . getDeclaredConstructor ( set . getClass () ) . newInstance ( set ) ; } catch ( final InstantiationException | IllegalAccessException | InvocationTargetException
result |= remove ( name ) ; MST[rv.UOI3Mutator]MSP[S] } return result ; } @Override public boolean retainAll ( final Collection < ? > coll ) { final boolean result = set . retainAll ( coll ) ; if ( result == false ) { return false ; }
result |= remove ( name ) ; MST[rv.UOI1Mutator]MSP[N] } return result ; } @Override public boolean retainAll ( final Collection < ? > coll ) { final boolean result = set . retainAll ( coll ) ; if ( result == false ) { return false ; }
result |= remove ( name ) ; } return result ; } @Override public boolean retainAll ( final Collection < ? > coll ) { final boolean result = set . retainAll ( coll ) ; if ( result == false ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return false ; }
final int pos = indexOf ( object ) ; final E removed = super . set ( index , object ) ; if ( pos != - 1 && pos != index ) { MST[NegateConditionalsMutator]MSP[N] super . remove ( pos ) ; } set . remove ( removed ) ;
public boolean add ( final E object ) { final int sizeBefore = size () ; add ( size () , object ) ; return sizeBefore != size () ; MST[NegateConditionalsMutator]MSP[N] } @Override public void add ( final int index , final E object ) {
public boolean add ( final E object ) { final int sizeBefore = size () ; add ( size () , object ) ; return sizeBefore != size () ; MST[rv.UOI1Mutator]MSP[N] } @Override public void add ( final int index , final E object ) {
public boolean add ( final E object ) { final int sizeBefore = size () ; add ( size () , object ) ; return sizeBefore != size () ; MST[rv.UOI3Mutator]MSP[N] } @Override public void add ( final int index , final E object ) {
final int pos = indexOf ( object ) ; final E removed = super . set ( index , object ) ; MST[rv.UOI1Mutator]MSP[N] if ( pos != - 1 && pos != index ) { super . remove ( pos ) ; } set . remove ( removed ) ;
return new SetListListIterator <> ( super . listIterator ( index ) , set ) ; } @Override public List < E > subList ( final int fromIndex , final int toIndex ) { final List < E > superSubList = super . subList ( fromIndex , toIndex ) ; MST[rv.UOI2Mutator]MSP[N]
return new SetListListIterator <> ( super . listIterator ( index ) , set ) ; MST[ConstructorCallMutator]MSP[S] } @Override public List < E > subList ( final int fromIndex , final int toIndex ) { final List < E > superSubList = super . subList ( fromIndex , toIndex ) ;
final int pos = indexOf ( object ) ; final E removed = super . set ( index , object ) ; MST[rv.UOI3Mutator]MSP[N] if ( pos != - 1 && pos != index ) { super . remove ( pos ) ; } set . remove ( removed ) ;
final Set < E > subSet = createSetBasedOnList ( set , superSubList ) ; return ListUtils . unmodifiableList ( new SetUniqueList <> ( superSubList , subSet ) ) ; MST[ReturnValsMutator]MSP[N] }
if ( set . contains ( object ) == false ) { set . add ( object ) ; super . add ( index , object ) ; MST[rv.UOI1Mutator]MSP[N] } } @Override public boolean addAll ( final Collection < ? extends E > coll ) {
final int pos = indexOf ( object ) ; final E removed = super . set ( index , object ) ; if ( pos != - 1 && pos != index ) { MST[rv.ROR1Mutator]MSP[N] super . remove ( pos ) ; } set . remove ( removed ) ;
result |= remove ( name ) ; } return result ; } @Override public boolean retainAll ( final Collection < ? > coll ) { final boolean result = set . retainAll ( coll ) ; if ( result == false ) { MST[rv.ABSMutator]MSP[N] return false ; }
return new SetListIterator <> ( super . iterator () , set ) ; MST[NullReturnValsMutator]MSP[N] } @Override public ListIterator < E > listIterator () { return new SetListListIterator <> ( super . listIterator () , set ) ; } @Override public ListIterator < E > listIterator ( final int index ) {
return new SetListListIterator <> ( super . listIterator ( index ) , set ) ; MST[ReturnValsMutator]MSP[S] } @Override public List < E > subList ( final int fromIndex , final int toIndex ) { final List < E > superSubList = super . subList ( fromIndex , toIndex ) ;
final int pos = indexOf ( object ) ; final E removed = super . set ( index , object ) ; if ( pos != - 1 && pos != index ) { MST[rv.ABSMutator]MSP[N] super . remove ( pos ) ; } set . remove ( removed ) ;
subSet = new HashSet <> ( list . size () ) ; } else { try { subSet = set . getClass () . getDeclaredConstructor ( set . getClass () ) . newInstance ( set ) ; MST[rv.CRCR6Mutator]MSP[S] } catch ( final InstantiationException | IllegalAccessException | InvocationTargetException
final boolean result = super . removeIf ( filter ) ; MST[NonVoidMethodCallMutator]MSP[N] set . removeIf ( filter ) ; return result ; } @Override public boolean removeAll ( final Collection < ? > coll ) { boolean result = false ; for ( final Object name : coll ) {
public static < E > SetUniqueList < E > setUniqueList ( final List < E > list ) { Objects . requireNonNull ( list , lr_1 ) ; if ( list . isEmpty () ) { MST[rv.ROR2Mutator]MSP[N]
set . add ( object ) ; return removed ; } @Override public boolean remove ( final Object object ) { final boolean result = set . remove ( object ) ; if ( result ) { MST[rv.UOI1Mutator]MSP[N] super . remove ( object ) ; } return result ; } @Override
final boolean result = super . removeIf ( filter ) ; set . removeIf ( filter ) ; return result ; MST[rv.UOI3Mutator]MSP[N] } @Override public boolean removeAll ( final Collection < ? > coll ) { boolean result = false ; for ( final Object name : coll ) {
final SetUniqueList < E > sl = new SetUniqueList <> ( list , new HashSet < E > () ) ; sl . addAll ( temp ) ; return sl ; } public Set < E > asSet () { return UnmodifiableSet . unmodifiableSet ( set ) ; MST[ReturnValsMutator]MSP[S] } @Override
final int pos = indexOf ( object ) ; final E removed = super . set ( index , object ) ; if ( pos != - 1 && pos != index ) { MST[rv.ROR5Mutator]MSP[N] super . remove ( pos ) ; } set . remove ( removed ) ;
public boolean contains ( final Object object ) { return set . contains ( object ) ; MST[NonVoidMethodCallMutator]MSP[N] } @Override public boolean containsAll ( final Collection < ? > coll ) { return set . containsAll ( coll ) ; } @Override public Iterator < E > iterator () {
final int pos = indexOf ( object ) ; final E removed = super . set ( index , object ) ; if ( pos != - 1 && pos != index ) { super . remove ( pos ) ; MST[rv.UOI3Mutator]MSP[N] } set . remove ( removed ) ;
final Set < E > subSet = createSetBasedOnList ( set , superSubList ) ; return ListUtils . unmodifiableList ( new SetUniqueList <> ( superSubList , subSet ) ) ; MST[NonVoidMethodCallMutator]MSP[N] }
public E remove ( final int index ) { final E result = super . remove ( index ) ; MST[rv.UOI4Mutator]MSP[N] set . remove ( result ) ; return result ; } @Override public boolean removeIf ( final Predicate < ? super E > filter ) {
final Set < E > subSet = createSetBasedOnList ( set , superSubList ) ; return ListUtils . unmodifiableList ( new SetUniqueList <> ( superSubList , subSet ) ) ; MST[ArgumentPropagationMutator]MSP[S] }
public E remove ( final int index ) { final E result = super . remove ( index ) ; set . remove ( result ) ; MST[NonVoidMethodCallMutator]MSP[S] return result ; } @Override public boolean removeIf ( final Predicate < ? super E > filter ) {
final boolean result = super . removeIf ( filter ) ; set . removeIf ( filter ) ; return result ; } @Override public boolean removeAll ( final Collection < ? > coll ) { boolean result = false ; MST[rv.CRCR3Mutator]MSP[S] for ( final Object name : coll ) {
if ( set . contains ( object ) == false ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] set . add ( object ) ; super . add ( index , object ) ; } } @Override public boolean addAll ( final Collection < ? extends E > coll ) {
result |= remove ( name ) ; } return result ; MST[rv.UOI2Mutator]MSP[N] } @Override public boolean retainAll ( final Collection < ? > coll ) { final boolean result = set . retainAll ( coll ) ; if ( result == false ) { return false ; }
result |= remove ( name ) ; } return result ; } @Override public boolean retainAll ( final Collection < ? > coll ) { final boolean result = set . retainAll ( coll ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( result == false ) { return false ; }
final boolean result = super . removeIf ( filter ) ; set . removeIf ( filter ) ; return result ; MST[ReturnValsMutator]MSP[N] } @Override public boolean removeAll ( final Collection < ? > coll ) { boolean result = false ; for ( final Object name : coll ) {
result |= remove ( name ) ; } return result ; } @Override public boolean retainAll ( final Collection < ? > coll ) { final boolean result = set . retainAll ( coll ) ; if ( result == false ) { MST[rv.ROR3Mutator]MSP[N] return false ; }
final Set < E > subSet = createSetBasedOnList ( set , superSubList ) ; MST[NonVoidMethodCallMutator]MSP[N] return ListUtils . unmodifiableList ( new SetUniqueList <> ( superSubList , subSet ) ) ; }
protected Set < E > createSetBasedOnList ( final Set < E > set , final List < E > list ) { Set < E > subSet ; if ( set . getClass () . equals ( HashSet . class ) ) { MST[NonVoidMethodCallMutator]MSP[N]
public boolean add ( final E object ) { final int sizeBefore = size () ; add ( size () , object ) ; MST[NonVoidMethodCallMutator]MSP[N] return sizeBefore != size () ; } @Override public void add ( final int index , final E object ) {
public boolean add ( final E object ) { final int sizeBefore = size () ; add ( size () , object ) ; return sizeBefore != size () ; MST[rv.ROR3Mutator]MSP[S] } @Override public void add ( final int index , final E object ) {
if ( set . contains ( object ) == false ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] set . add ( object ) ; super . add ( index , object ) ; } } @Override public boolean addAll ( final Collection < ? extends E > coll ) {
return new SetListListIterator <> ( super . listIterator ( index ) , set ) ; MST[rv.UOI2Mutator]MSP[N] } @Override public List < E > subList ( final int fromIndex , final int toIndex ) { final List < E > superSubList = super . subList ( fromIndex , toIndex ) ;
final int pos = indexOf ( object ) ; final E removed = super . set ( index , object ) ; if ( pos != - 1 && pos != index ) { MST[rv.UOI4Mutator]MSP[N] super . remove ( pos ) ; } set . remove ( removed ) ;
if ( set . size () == 0 ) { super . clear () ; } else { super . retainAll ( set ) ; } return result ; MST[BooleanTrueReturnValsMutator]MSP[N] } @Override public void clear () { super . clear () ; set . clear () ; } @Override
final int pos = indexOf ( object ) ; final E removed = super . set ( index , object ) ; if ( pos != - 1 && pos != index ) { MST[rv.UOI1Mutator]MSP[N] super . remove ( pos ) ; } set . remove ( removed ) ;
subSet = new HashSet <> ( list . size () ) ; } else { try { subSet = set . getClass () . getDeclaredConstructor ( set . getClass () ) . newInstance ( set ) ; MST[NonVoidMethodCallMutator]MSP[S] } catch ( final InstantiationException | IllegalAccessException | InvocationTargetException
public boolean add ( final E object ) { final int sizeBefore = size () ; add ( size () , object ) ; return sizeBefore != size () ; MST[rv.CRCR5Mutator]MSP[S] } @Override public void add ( final int index , final E object ) {
result |= remove ( name ) ; } return result ; } @Override public boolean retainAll ( final Collection < ? > coll ) { final boolean result = set . retainAll ( coll ) ; if ( result == false ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return false ; }
public boolean add ( final E object ) { final int sizeBefore = size () ; add ( size () , object ) ; return sizeBefore != size () ; MST[rv.CRCR1Mutator]MSP[S] } @Override public void add ( final int index , final E object ) {
public boolean add ( final E object ) { final int sizeBefore = size () ; add ( size () , object ) ; return sizeBefore != size () ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } @Override public void add ( final int index , final E object ) {
return new SetListListIterator <> ( super . listIterator ( index ) , set ) ; } @Override public List < E > subList ( final int fromIndex , final int toIndex ) { final List < E > superSubList = super . subList ( fromIndex , toIndex ) ; MST[rv.UOI2Mutator]MSP[N]
if ( set . size () == 0 ) { super . clear () ; } else { super . retainAll ( set ) ; } return result ; MST[rv.UOI1Mutator]MSP[N] } @Override public void clear () { super . clear () ; set . clear () ; } @Override
return new SetListListIterator <> ( super . listIterator ( index ) , set ) ; } @Override public List < E > subList ( final int fromIndex , final int toIndex ) { final List < E > superSubList = super . subList ( fromIndex , toIndex ) ; MST[NonVoidMethodCallMutator]MSP[N]
subSet = new HashSet <> ( list . size () ) ; } else { try { subSet = set . getClass () . getDeclaredConstructor ( set . getClass () ) . newInstance ( set ) ; MST[NonVoidMethodCallMutator]MSP[S] } catch ( final InstantiationException | IllegalAccessException | InvocationTargetException
return new SetUniqueList <> ( list , new HashSet < E > () ) ; MST[ConstructorCallMutator]MSP[N] } final List < E > temp = new ArrayList <> ( list ) ; list . clear () ;
| NoSuchMethodException ie ) { subSet = new HashSet <> () ; } } return subSet ; MST[ReturnValsMutator]MSP[N] } @Override public E next () { last = super . next () ; return last ; } @Override public void remove () { super . remove () ;
| NoSuchMethodException ie ) { subSet = new HashSet <> () ; } } return subSet ; MST[EmptyObjectReturnValsMutator]MSP[N] } @Override public E next () { last = super . next () ; return last ; } @Override public void remove () { super . remove () ;
if ( set . size () == 0 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] super . clear () ; } else { super . retainAll ( set ) ; } return result ; } @Override public void clear () { super . clear () ; set . clear () ; } @Override
final int pos = indexOf ( object ) ; final E removed = super . set ( index , object ) ; if ( pos != - 1 && pos != index ) { MST[rv.ABSMutator]MSP[N] super . remove ( pos ) ; } set . remove ( removed ) ;
if ( set . size () == 0 ) { super . clear () ; MST[VoidMethodCallMutator]MSP[S] } else { super . retainAll ( set ) ; } return result ; } @Override public void clear () { super . clear () ; set . clear () ; } @Override
final SetUniqueList < E > sl = new SetUniqueList <> ( list , new HashSet < E > () ) ; sl . addAll ( temp ) ; return sl ; MST[ReturnValsMutator]MSP[S] } public Set < E > asSet () { return UnmodifiableSet . unmodifiableSet ( set ) ; } @Override
public boolean contains ( final Object object ) { return set . contains ( object ) ; } @Override public boolean containsAll ( final Collection < ? > coll ) { return set . containsAll ( coll ) ; MST[NonVoidMethodCallMutator]MSP[S] } @Override public Iterator < E > iterator () {
if ( set . contains ( object ) == false ) { MST[NonVoidMethodCallMutator]MSP[N] set . add ( object ) ; super . add ( index , object ) ; } } @Override public boolean addAll ( final Collection < ? extends E > coll ) {
result |= remove ( name ) ; MST[rv.OBBN3Mutator]MSP[N] } return result ; } @Override public boolean retainAll ( final Collection < ? > coll ) { final boolean result = set . retainAll ( coll ) ; if ( result == false ) { return false ; }
if ( set . size () == 0 ) { MST[rv.ROR3Mutator]MSP[N] super . clear () ; } else { super . retainAll ( set ) ; } return result ; } @Override public void clear () { super . clear () ; set . clear () ; } @Override
set . add ( object ) ; return removed ; } @Override public boolean remove ( final Object object ) { final boolean result = set . remove ( object ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( result ) { super . remove ( object ) ; } return result ; } @Override
if ( set . size () == 0 ) { MST[rv.ROR4Mutator]MSP[N] super . clear () ; } else { super . retainAll ( set ) ; } return result ; } @Override public void clear () { super . clear () ; set . clear () ; } @Override
if ( set . size () == 0 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] super . clear () ; } else { super . retainAll ( set ) ; } return result ; } @Override public void clear () { super . clear () ; set . clear () ; } @Override
set . add ( object ) ; return removed ; } @Override public boolean remove ( final Object object ) { final boolean result = set . remove ( object ) ; if ( result ) { super . remove ( object ) ; } return result ; MST[rv.UOI2Mutator]MSP[N] } @Override
if ( set . size () == 0 ) { MST[rv.ROR1Mutator]MSP[S] super . clear () ; } else { super . retainAll ( set ) ; } return result ; } @Override public void clear () { super . clear () ; set . clear () ; } @Override
result |= remove ( name ) ; MST[rv.OBBN2Mutator]MSP[S] } return result ; } @Override public boolean retainAll ( final Collection < ? > coll ) { final boolean result = set . retainAll ( coll ) ; if ( result == false ) { return false ; }
result |= remove ( name ) ; } return result ; } @Override public boolean retainAll ( final Collection < ? > coll ) { final boolean result = set . retainAll ( coll ) ; if ( result == false ) { MST[rv.UOI3Mutator]MSP[N] return false ; }
return new SetListIterator <> ( super . iterator () , set ) ; } @Override public ListIterator < E > listIterator () { return new SetListListIterator <> ( super . listIterator () , set ) ; MST[ConstructorCallMutator]MSP[N] } @Override public ListIterator < E > listIterator ( final int index ) {
set . add ( object ) ; return removed ; } @Override public boolean remove ( final Object object ) { final boolean result = set . remove ( object ) ; if ( result ) { super . remove ( object ) ; } return result ; MST[rv.UOI3Mutator]MSP[N] } @Override
final boolean result = super . removeIf ( filter ) ; set . removeIf ( filter ) ; return result ; } @Override public boolean removeAll ( final Collection < ? > coll ) { boolean result = false ; MST[InlineConstantMutator]MSP[S] for ( final Object name : coll ) {
public boolean add ( final E object ) { final int sizeBefore = size () ; add ( size () , object ) ; return sizeBefore != size () ; MST[NonVoidMethodCallMutator]MSP[N] } @Override public void add ( final int index , final E object ) {
if ( set . add ( e ) ) { temp . add ( e ) ; MST[NonVoidMethodCallMutator]MSP[N] } } return super . addAll ( index , temp ) ; } @Override public E set ( final int index , final E object ) {
return addAll ( size () , coll ) ; MST[ReturnValsMutator]MSP[N] } @Override public boolean addAll ( final int index , final Collection < ? extends E > coll ) { final List < E > temp = new ArrayList <> () ; for ( final E e : coll ) {
set . add ( object ) ; return removed ; MST[NullReturnValsMutator]MSP[S] } @Override public boolean remove ( final Object object ) { final boolean result = set . remove ( object ) ; if ( result ) { super . remove ( object ) ; } return result ; } @Override
set . add ( object ) ; return removed ; } @Override public boolean remove ( final Object object ) { final boolean result = set . remove ( object ) ; if ( result ) { super . remove ( object ) ; } return result ; MST[BooleanFalseReturnValsMutator]MSP[N] } @Override
subSet = new HashSet <> ( list . size () ) ; MST[ConstructorCallMutator]MSP[N] } else { try { subSet = set . getClass () . getDeclaredConstructor ( set . getClass () ) . newInstance ( set ) ; } catch ( final InstantiationException | IllegalAccessException | InvocationTargetException
public boolean add ( final E object ) { final int sizeBefore = size () ; add ( size () , object ) ; return sizeBefore != size () ; MST[rv.CRCR4Mutator]MSP[N] } @Override public void add ( final int index , final E object ) {
result |= remove ( name ) ; } return result ; } @Override public boolean retainAll ( final Collection < ? > coll ) { final boolean result = set . retainAll ( coll ) ; if ( result == false ) { return false ; MST[rv.CRCR3Mutator]MSP[S] }
final int pos = indexOf ( object ) ; final E removed = super . set ( index , object ) ; if ( pos != - 1 && pos != index ) { MST[rv.UOI3Mutator]MSP[N] super . remove ( pos ) ; } set . remove ( removed ) ;
final int pos = indexOf ( object ) ; final E removed = super . set ( index , object ) ; if ( pos != - 1 && pos != index ) { MST[rv.UOI4Mutator]MSP[N] super . remove ( pos ) ; } set . remove ( removed ) ;
return new SetUniqueList <> ( list , new HashSet < E > () ) ; MST[ReturnValsMutator]MSP[N] } final List < E > temp = new ArrayList <> ( list ) ; list . clear () ;
if ( set . add ( e ) ) { temp . add ( e ) ; } } return super . addAll ( index , temp ) ; MST[rv.UOI1Mutator]MSP[N] } @Override public E set ( final int index , final E object ) {
if ( set . add ( e ) ) { temp . add ( e ) ; } } return super . addAll ( index , temp ) ; MST[rv.UOI3Mutator]MSP[N] } @Override public E set ( final int index , final E object ) {
result |= remove ( name ) ; } return result ; } @Override public boolean retainAll ( final Collection < ? > coll ) { final boolean result = set . retainAll ( coll ) ; if ( result == false ) { return false ; MST[BooleanTrueReturnValsMutator]MSP[S] }
public E remove ( final int index ) { final E result = super . remove ( index ) ; MST[rv.ABSMutator]MSP[N] set . remove ( result ) ; return result ; } @Override public boolean removeIf ( final Predicate < ? super E > filter ) {
if ( set . add ( e ) ) { temp . add ( e ) ; } } return super . addAll ( index , temp ) ; MST[rv.ABSMutator]MSP[N] } @Override public E set ( final int index , final E object ) {
public boolean add ( final E object ) { final int sizeBefore = size () ; add ( size () , object ) ; return sizeBefore != size () ; MST[rv.CRCR2Mutator]MSP[N] } @Override public void add ( final int index , final E object ) {
final int pos = indexOf ( object ) ; final E removed = super . set ( index , object ) ; if ( pos != - 1 && pos != index ) { MST[rv.UOI2Mutator]MSP[N] super . remove ( pos ) ; } set . remove ( removed ) ;
if ( set . size () == 0 ) { super . clear () ; } else { super . retainAll ( set ) ; } return result ; MST[rv.UOI4Mutator]MSP[N] } @Override public void clear () { super . clear () ; set . clear () ; } @Override
result |= remove ( name ) ; } return result ; } @Override public boolean retainAll ( final Collection < ? > coll ) { final boolean result = set . retainAll ( coll ) ; if ( result == false ) { return false ; MST[rv.CRCR5Mutator]MSP[S] }
if ( set . contains ( object ) == false ) { set . add ( object ) ; super . add ( index , object ) ; MST[VoidMethodCallMutator]MSP[N] } } @Override public boolean addAll ( final Collection < ? extends E > coll ) {
final int pos = indexOf ( object ) ; final E removed = super . set ( index , object ) ; if ( pos != - 1 && pos != index ) { MST[rv.UOI1Mutator]MSP[N] super . remove ( pos ) ; } set . remove ( removed ) ;
public boolean add ( final E object ) { final int sizeBefore = size () ; add ( size () , object ) ; return sizeBefore != size () ; MST[rv.CRCR6Mutator]MSP[S] } @Override public void add ( final int index , final E object ) {
public static < E > SetUniqueList < E > setUniqueList ( final List < E > list ) { Objects . requireNonNull ( list , lr_1 ) ; if ( list . isEmpty () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
result |= remove ( name ) ; } return result ; } @Override public boolean retainAll ( final Collection < ? > coll ) { final boolean result = set . retainAll ( coll ) ; if ( result == false ) { return false ; MST[InlineConstantMutator]MSP[S] }
if ( set . size () == 0 ) { super . clear () ; } else { super . retainAll ( set ) ; } return result ; MST[rv.UOI2Mutator]MSP[N] } @Override public void clear () { super . clear () ; set . clear () ; } @Override
final int pos = indexOf ( object ) ; final E removed = super . set ( index , object ) ; MST[rv.ABSMutator]MSP[N] if ( pos != - 1 && pos != index ) { super . remove ( pos ) ; } set . remove ( removed ) ;
if ( set . add ( e ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] temp . add ( e ) ; } } return super . addAll ( index , temp ) ; } @Override public E set ( final int index , final E object ) {
final boolean result = super . removeIf ( filter ) ; set . removeIf ( filter ) ; return result ; MST[rv.UOI4Mutator]MSP[N] } @Override public boolean removeAll ( final Collection < ? > coll ) { boolean result = false ; for ( final Object name : coll ) {
subSet = new HashSet <> ( list . size () ) ; } else { try { subSet = set . getClass () . getDeclaredConstructor ( set . getClass () ) . newInstance ( set ) ; MST[rv.CRCR3Mutator]MSP[S] } catch ( final InstantiationException | IllegalAccessException | InvocationTargetException
set . add ( object ) ; return removed ; } @Override public boolean remove ( final Object object ) { final boolean result = set . remove ( object ) ; if ( result ) { MST[NegateConditionalsMutator]MSP[S] super . remove ( object ) ; } return result ; } @Override
public E remove ( final int index ) { final E result = super . remove ( index ) ; set . remove ( result ) ; return result ; MST[ReturnValsMutator]MSP[S] } @Override public boolean removeIf ( final Predicate < ? super E > filter ) {
final int pos = indexOf ( object ) ; final E removed = super . set ( index , object ) ; if ( pos != - 1 && pos != index ) { MST[rv.ROR4Mutator]MSP[N] super . remove ( pos ) ; } set . remove ( removed ) ;
if ( set . contains ( object ) == false ) { set . add ( object ) ; super . add ( index , object ) ; MST[rv.UOI4Mutator]MSP[N] } } @Override public boolean addAll ( final Collection < ? extends E > coll ) {
final int pos = indexOf ( object ) ; final E removed = super . set ( index , object ) ; if ( pos != - 1 && pos != index ) { super . remove ( pos ) ; MST[rv.UOI1Mutator]MSP[N] } set . remove ( removed ) ;
final boolean result = super . removeIf ( filter ) ; set . removeIf ( filter ) ; return result ; MST[rv.UOI1Mutator]MSP[N] } @Override public boolean removeAll ( final Collection < ? > coll ) { boolean result = false ; for ( final Object name : coll ) {
if ( set . size () == 0 ) { super . clear () ; } else { super . retainAll ( set ) ; } return result ; MST[ReturnValsMutator]MSP[N] } @Override public void clear () { super . clear () ; set . clear () ; } @Override
set . add ( object ) ; return removed ; } @Override public boolean remove ( final Object object ) { final boolean result = set . remove ( object ) ; if ( result ) { MST[rv.UOI4Mutator]MSP[N] super . remove ( object ) ; } return result ; } @Override
public static < E > SetUniqueList < E > setUniqueList ( final List < E > list ) { Objects . requireNonNull ( list , lr_1 ) ; if ( list . isEmpty () ) { MST[rv.ROR3Mutator]MSP[N]
public E remove ( final int index ) { final E result = super . remove ( index ) ; MST[rv.UOI3Mutator]MSP[N] set . remove ( result ) ; return result ; } @Override public boolean removeIf ( final Predicate < ? super E > filter ) {
final SetUniqueList < E > sl = new SetUniqueList <> ( list , new HashSet < E > () ) ; MST[ConstructorCallMutator]MSP[S] sl . addAll ( temp ) ; return sl ; } public Set < E > asSet () { return UnmodifiableSet . unmodifiableSet ( set ) ; } @Override
final SetUniqueList < E > sl = new SetUniqueList <> ( list , new HashSet < E > () ) ; sl . addAll ( temp ) ; return sl ; } public Set < E > asSet () { return UnmodifiableSet . unmodifiableSet ( set ) ; MST[NonVoidMethodCallMutator]MSP[S] } @Override
final boolean result = super . removeIf ( filter ) ; set . removeIf ( filter ) ; return result ; } @Override public boolean removeAll ( final Collection < ? > coll ) { boolean result = false ; MST[rv.CRCR1Mutator]MSP[S] for ( final Object name : coll ) {
result |= remove ( name ) ; } return result ; MST[rv.UOI4Mutator]MSP[N] } @Override public boolean retainAll ( final Collection < ? > coll ) { final boolean result = set . retainAll ( coll ) ; if ( result == false ) { return false ; }
result |= remove ( name ) ; } return result ; MST[rv.UOI1Mutator]MSP[N] } @Override public boolean retainAll ( final Collection < ? > coll ) { final boolean result = set . retainAll ( coll ) ; if ( result == false ) { return false ; }
result |= remove ( name ) ; } return result ; } @Override public boolean retainAll ( final Collection < ? > coll ) { final boolean result = set . retainAll ( coll ) ; if ( result == false ) { MST[rv.ROR5Mutator]MSP[N] return false ; }
final boolean result = super . removeIf ( filter ) ; set . removeIf ( filter ) ; return result ; MST[BooleanTrueReturnValsMutator]MSP[N] } @Override public boolean removeAll ( final Collection < ? > coll ) { boolean result = false ; for ( final Object name : coll ) {
final boolean result = super . removeIf ( filter ) ; set . removeIf ( filter ) ; return result ; } @Override public boolean removeAll ( final Collection < ? > coll ) { boolean result = false ; MST[rv.CRCR6Mutator]MSP[S] for ( final Object name : coll ) {
protected Set < E > createSetBasedOnList ( final Set < E > set , final List < E > list ) { Set < E > subSet ; if ( set . getClass () . equals ( HashSet . class ) ) { MST[NonVoidMethodCallMutator]MSP[N]
final int pos = indexOf ( object ) ; final E removed = super . set ( index , object ) ; MST[rv.UOI4Mutator]MSP[N] if ( pos != - 1 && pos != index ) { super . remove ( pos ) ; } set . remove ( removed ) ;
result |= remove ( name ) ; } return result ; } @Override public boolean retainAll ( final Collection < ? > coll ) { final boolean result = set . retainAll ( coll ) ; if ( result == false ) { return false ; MST[ReturnValsMutator]MSP[S] }
protected Set < E > createSetBasedOnList ( final Set < E > set , final List < E > list ) { Set < E > subSet ; if ( set . getClass () . equals ( HashSet . class ) ) { MST[rv.ROR3Mutator]MSP[N]
final int pos = indexOf ( object ) ; final E removed = super . set ( index , object ) ; if ( pos != - 1 && pos != index ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] super . remove ( pos ) ; } set . remove ( removed ) ;
return addAll ( size () , coll ) ; MST[BooleanTrueReturnValsMutator]MSP[S] } @Override public boolean addAll ( final int index , final Collection < ? extends E > coll ) { final List < E > temp = new ArrayList <> () ; for ( final E e : coll ) {
public boolean add ( final E object ) { final int sizeBefore = size () ; add ( size () , object ) ; return sizeBefore != size () ; MST[rv.ROR5Mutator]MSP[N] } @Override public void add ( final int index , final E object ) {
final Set < E > subSet = createSetBasedOnList ( set , superSubList ) ; return ListUtils . unmodifiableList ( new SetUniqueList <> ( superSubList , subSet ) ) ; MST[EmptyObjectReturnValsMutator]MSP[N] }
final Set < E > subSet = createSetBasedOnList ( set , superSubList ) ; return ListUtils . unmodifiableList ( new SetUniqueList <> ( superSubList , subSet ) ) ; MST[ConstructorCallMutator]MSP[N] }
public boolean contains ( final Object object ) { return set . contains ( object ) ; MST[BooleanFalseReturnValsMutator]MSP[N] } @Override public boolean containsAll ( final Collection < ? > coll ) { return set . containsAll ( coll ) ; } @Override public Iterator < E > iterator () {
subSet = new HashSet <> ( list . size () ) ; } else { try { subSet = set . getClass () . getDeclaredConstructor ( set . getClass () ) . newInstance ( set ) ; MST[InlineConstantMutator]MSP[S] } catch ( final InstantiationException | IllegalAccessException | InvocationTargetException
public boolean add ( final E object ) { final int sizeBefore = size () ; add ( size () , object ) ; return sizeBefore != size () ; MST[InlineConstantMutator]MSP[S] } @Override public void add ( final int index , final E object ) {
final int pos = indexOf ( object ) ; final E removed = super . set ( index , object ) ; if ( pos != - 1 && pos != index ) { MST[rv.UOI2Mutator]MSP[N] super . remove ( pos ) ; } set . remove ( removed ) ;
if ( set . add ( e ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] temp . add ( e ) ; } } return super . addAll ( index , temp ) ; } @Override public E set ( final int index , final E object ) {
return new SetListIterator <> ( super . iterator () , set ) ; } @Override public ListIterator < E > listIterator () { return new SetListListIterator <> ( super . listIterator () , set ) ; MST[NonVoidMethodCallMutator]MSP[N] } @Override public ListIterator < E > listIterator ( final int index ) {
final boolean result = super . removeIf ( filter ) ; set . removeIf ( filter ) ; MST[NonVoidMethodCallMutator]MSP[S] return result ; } @Override public boolean removeAll ( final Collection < ? > coll ) { boolean result = false ; for ( final Object name : coll ) {
if ( set . add ( e ) ) { MST[rv.ROR3Mutator]MSP[N] temp . add ( e ) ; } } return super . addAll ( index , temp ) ; } @Override public E set ( final int index , final E object ) {
public boolean add ( final E object ) { final int sizeBefore = size () ; add ( size () , object ) ; return sizeBefore != size () ; MST[rv.UOI2Mutator]MSP[N] } @Override public void add ( final int index , final E object ) {
if ( set . contains ( object ) == false ) { set . add ( object ) ; MST[NonVoidMethodCallMutator]MSP[N] super . add ( index , object ) ; } } @Override public boolean addAll ( final Collection < ? extends E > coll ) {
final int pos = indexOf ( object ) ; MST[NonVoidMethodCallMutator]MSP[N] final E removed = super . set ( index , object ) ; if ( pos != - 1 && pos != index ) { super . remove ( pos ) ; } set . remove ( removed ) ;
public boolean add ( final E object ) { final int sizeBefore = size () ; add ( size () , object ) ; return sizeBefore != size () ; MST[rv.CRCR3Mutator]MSP[S] } @Override public void add ( final int index , final E object ) {
public static < E > SetUniqueList < E > setUniqueList ( final List < E > list ) { Objects . requireNonNull ( list , lr_1 ) ; if ( list . isEmpty () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
subSet = new HashSet <> ( list . size () ) ; } else { try { subSet = set . getClass () . getDeclaredConstructor ( set . getClass () ) . newInstance ( set ) ; MST[NonVoidMethodCallMutator]MSP[N] } catch ( final InstantiationException | IllegalAccessException | InvocationTargetException
final SetUniqueList < E > sl = new SetUniqueList <> ( list , new HashSet < E > () ) ; sl . addAll ( temp ) ; MST[NonVoidMethodCallMutator]MSP[N] return sl ; } public Set < E > asSet () { return UnmodifiableSet . unmodifiableSet ( set ) ; } @Override
super . add ( object ) ; MST[VoidMethodCallMutator]MSP[S] set . add ( object ) ; } } @Override public void set ( final E object ) { throw new UnsupportedOperationException ( lr_2 ) ; }
set . remove ( last ) ; last = null ; } @Override MST[experimental.MemberVariableMutator]MSP[N] public E next () { last = super . next () ; return last ; } @Override public E previous () { last = super . previous () ; return last ; } @Override
public void remove () { super . remove () ; set . remove ( last ) ; last = null ; } @Override public void add ( final E object ) { if ( set . contains ( object ) == false ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S]
public void remove () { super . remove () ; MST[VoidMethodCallMutator]MSP[S] set . remove ( last ) ; last = null ; } @Override public void add ( final E object ) { if ( set . contains ( object ) == false ) {
public void remove () { super . remove () ; set . remove ( last ) ; last = null ; } @Override public void add ( final E object ) { if ( set . contains ( object ) == false ) { MST[NegateConditionalsMutator]MSP[N]
super . add ( object ) ; set . add ( object ) ; } } @Override public void set ( final E object ) { throw new UnsupportedOperationException ( lr_2 ) ; MST[ConstructorCallMutator]MSP[S] }
set . remove ( last ) ; last = null ; } @Override public E next () { last = super . next () ; return last ; MST[NullReturnValsMutator]MSP[N] } @Override public E previous () { last = super . previous () ; return last ; } @Override
set . remove ( last ) ; last = null ; } @Override public E next () { last = super . next () ; return last ; MST[ReturnValsMutator]MSP[N] } @Override public E previous () { last = super . previous () ; return last ; } @Override
public void remove () { super . remove () ; set . remove ( last ) ; last = null ; } @Override public void add ( final E object ) { if ( set . contains ( object ) == false ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S]
public void remove () { super . remove () ; set . remove ( last ) ; MST[NonVoidMethodCallMutator]MSP[N] last = null ; } @Override public void add ( final E object ) { if ( set . contains ( object ) == false ) {
set . remove ( last ) ; last = null ; } @Override public E next () { last = super . next () ; return last ; } @Override public E previous () { last = super . previous () ; MST[NonVoidMethodCallMutator]MSP[N] return last ; } @Override
set . remove ( last ) ; last = null ; } @Override public E next () { last = super . next () ; return last ; } @Override public E previous () { last = super . previous () ; MST[experimental.MemberVariableMutator]MSP[S] return last ; } @Override
public void remove () { super . remove () ; set . remove ( last ) ; last = null ; } @Override public void add ( final E object ) { if ( set . contains ( object ) == false ) { MST[NonVoidMethodCallMutator]MSP[S]
set . remove ( last ) ; last = null ; } @Override public E next () { last = super . next () ; return last ; } @Override public E previous () { last = super . previous () ; return last ; MST[NullReturnValsMutator]MSP[S] } @Override
public void remove () { super . remove () ; set . remove ( last ) ; last = null ; } @Override public void add ( final E object ) { if ( set . contains ( object ) == false ) { MST[rv.ROR2Mutator]MSP[N]
public void remove () { super . remove () ; set . remove ( last ) ; last = null ; } @Override public void add ( final E object ) { if ( set . contains ( object ) == false ) { MST[rv.ROR3Mutator]MSP[N]
public void remove () { super . remove () ; set . remove ( last ) ; last = null ; MST[experimental.MemberVariableMutator]MSP[N] } @Override public void add ( final E object ) { if ( set . contains ( object ) == false ) {
public void remove () { super . remove () ; set . remove ( last ) ; last = null ; } @Override public void add ( final E object ) { if ( set . contains ( object ) == false ) { MST[rv.ROR1Mutator]MSP[S]
public void remove () { super . remove () ; set . remove ( last ) ; last = null ; } @Override public void add ( final E object ) { if ( set . contains ( object ) == false ) { MST[rv.ROR5Mutator]MSP[N]
public void remove () { super . remove () ; set . remove ( last ) ; last = null ; } @Override public void add ( final E object ) { if ( set . contains ( object ) == false ) { MST[rv.ROR4Mutator]MSP[S]
set . remove ( last ) ; last = null ; } @Override public E next () { last = super . next () ; return last ; } @Override public E previous () { last = super . previous () ; return last ; MST[ReturnValsMutator]MSP[N] } @Override
super . add ( object ) ; set . add ( object ) ; MST[NonVoidMethodCallMutator]MSP[N] } } @Override public void set ( final E object ) { throw new UnsupportedOperationException ( lr_2 ) ; }
set . remove ( last ) ; last = null ; } @Override public E next () { last = super . next () ; MST[experimental.MemberVariableMutator]MSP[N] return last ; } @Override public E previous () { last = super . previous () ; return last ; } @Override
| NoSuchMethodException ie ) { subSet = new HashSet <> () ; } } return subSet ; } @Override public E next () { last = super . next () ; return last ; MST[NullReturnValsMutator]MSP[N] } @Override public void remove () { super . remove () ;
| NoSuchMethodException ie ) { subSet = new HashSet <> () ; } } return subSet ; } @Override public E next () { last = super . next () ; return last ; } @Override public void remove () { super . remove () ; MST[VoidMethodCallMutator]MSP[S]
| NoSuchMethodException ie ) { subSet = new HashSet <> () ; } } return subSet ; } @Override public E next () { last = super . next () ; return last ; MST[ReturnValsMutator]MSP[N] } @Override public void remove () { super . remove () ;
| NoSuchMethodException ie ) { subSet = new HashSet <> () ; } } return subSet ; } @Override public E next () { last = super . next () ; MST[experimental.MemberVariableMutator]MSP[N] return last ; } @Override public void remove () { super . remove () ;
set . remove ( last ) ; MST[NonVoidMethodCallMutator]MSP[N] last = null ; } @Override public E next () { last = super . next () ; return last ; } @Override public E previous () { last = super . previous () ; return last ; } @Override
| NoSuchMethodException ie ) { subSet = new HashSet <> () ; } } return subSet ; } @Override MST[experimental.MemberVariableMutator]MSP[N] public E next () { last = super . next () ; return last ; } @Override public void remove () { super . remove () ;
set . remove ( last ) ; last = null ; MST[experimental.MemberVariableMutator]MSP[N] } @Override public E next () { last = super . next () ; return last ; } @Override public E previous () { last = super . previous () ; return last ; } @Override
