final int index1 = beginIndex1 + i ; final int index2 = beginIndex2 + i ; MST[rv.AOD2Mutator]MSP[N] if ( index1 >= endIndex1 ) { k = 0 ; } else { k = key . charAt ( index1 ) ; }
if ( other == null || index2 >= endIndex2 ) { MST[rv.UOI1Mutator]MSP[S] f = 0 ; } else { f = other . charAt ( index2 ) ; } if ( k != f ) { final int x = k ^ f ;
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; MST[rv.AOD1Mutator]MSP[N] } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
final int endIndex2 = beginIndex2 + otherLengthInBits / LENGTH ; MST[rv.UOI2Mutator]MSP[N] final int length = Math . max ( endIndex1 , endIndex2 ) ; char k = 0 , f = 0 ; for ( int i = 0 ; i < length ; i ++ ) {
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { MST[rv.ROR4Mutator]MSP[S] return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
final int endIndex2 = beginIndex2 + otherLengthInBits / LENGTH ; final int length = Math . max ( endIndex1 , endIndex2 ) ; MST[rv.UOI4Mutator]MSP[N] char k = 0 , f = 0 ; for ( int i = 0 ; i < length ; i ++ ) {
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; MST[rv.CRCR2Mutator]MSP[N] } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
return ( key . charAt ( index ) & mask ( bit ) ) != 0 ; MST[rv.UOI3Mutator]MSP[S] } @Override public boolean isPrefix ( final String prefix , final int offsetInBits , final int lengthInBits , final String key ) {
final int endIndex2 = beginIndex2 + otherLengthInBits / LENGTH ; MST[InlineConstantMutator]MSP[N] final int length = Math . max ( endIndex1 , endIndex2 ) ; char k = 0 , f = 0 ; for ( int i = 0 ; i < length ; i ++ ) {
private static int mask ( final int bit ) { return MSB >>> bit ; } @Override public int bitsPerElement () { return LENGTH ; } @Override public int lengthInBits ( final String key ) { return key != null ? key . length () * LENGTH : 0 ; MST[rv.AOR2Mutator]MSP[N]
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[RemoveConditionalMutator_EQUAL_IF]MSP[S]
|| lengthInBits % LENGTH != 0 || otherLengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } final int beginIndex1 = offsetInBits / LENGTH ; final int beginIndex2 = otherOffsetInBits / LENGTH ; final int endIndex1 = beginIndex1 + lengthInBits / LENGTH ; MST[rv.UOI4Mutator]MSP[N]
final int endIndex2 = beginIndex2 + otherLengthInBits / LENGTH ; final int length = Math . max ( endIndex1 , endIndex2 ) ; char k = 0 , f = 0 ; for ( int i = 0 ; i < length ; i ++ ) { MST[rv.CRCR3Mutator]MSP[N]
final int endIndex2 = beginIndex2 + otherLengthInBits / LENGTH ; MST[rv.ABSMutator]MSP[N] final int length = Math . max ( endIndex1 , endIndex2 ) ; char k = 0 , f = 0 ; for ( int i = 0 ; i < length ; i ++ ) {
if ( other == null || index2 >= endIndex2 ) { f = 0 ; } else { f = other . charAt ( index2 ) ; } if ( k != f ) { final int x = k ^ f ; MST[MathMutator]MSP[N]
|| lengthInBits % LENGTH != 0 || otherLengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } final int beginIndex1 = offsetInBits / LENGTH ; final int beginIndex2 = otherOffsetInBits / LENGTH ; final int endIndex1 = beginIndex1 + lengthInBits / LENGTH ; MST[rv.AOR1Mutator]MSP[S]
final int endIndex2 = beginIndex2 + otherLengthInBits / LENGTH ; final int length = Math . max ( endIndex1 , endIndex2 ) ; char k = 0 , f = 0 ; MST[rv.CRCR6Mutator]MSP[N] for ( int i = 0 ; i < length ; i ++ ) {
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; MST[rv.UOI1Mutator]MSP[N] return key . startsWith ( s1 ) ; }
final int index1 = beginIndex1 + i ; final int index2 = beginIndex2 + i ; if ( index1 >= endIndex1 ) { k = 0 ; } else { k = key . charAt ( index1 ) ; MST[rv.UOI3Mutator]MSP[S] }
final int index1 = beginIndex1 + i ; MST[rv.UOI1Mutator]MSP[N] final int index2 = beginIndex2 + i ; if ( index1 >= endIndex1 ) { k = 0 ; } else { k = key . charAt ( index1 ) ; }
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; MST[ReturnValsMutator]MSP[N] } @Override
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; MST[rv.UOI1Mutator]MSP[N] } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
private static int mask ( final int bit ) { return MSB >>> bit ; } @Override public int bitsPerElement () { return LENGTH ; } @Override public int lengthInBits ( final String key ) { return key != null ? key . length () * LENGTH : 0 ; MST[InlineConstantMutator]MSP[S]
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.UOI1Mutator]MSP[N]
|| lengthInBits % LENGTH != 0 || otherLengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } final int beginIndex1 = offsetInBits / LENGTH ; MST[rv.AOR2Mutator]MSP[S] final int beginIndex2 = otherOffsetInBits / LENGTH ; final int endIndex1 = beginIndex1 + lengthInBits / LENGTH ;
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { MST[rv.ROR1Mutator]MSP[S] throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; return key . startsWith ( s1 ) ; }
public boolean isBitSet ( final String key , final int bitIndex , final int lengthInBits ) { if ( key == null || bitIndex >= lengthInBits ) { return false ; } final int index = bitIndex / LENGTH ; MST[rv.CRCR4Mutator]MSP[S] final int bit = bitIndex % LENGTH ;
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { MST[rv.CRCR4Mutator]MSP[N] throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; return key . startsWith ( s1 ) ; }
if ( other == null || index2 >= endIndex2 ) { f = 0 ; } else { f = other . charAt ( index2 ) ; } if ( k != f ) { MST[rv.UOI2Mutator]MSP[N] final int x = k ^ f ;
if ( other == null || index2 >= endIndex2 ) { f = 0 ; } else { f = other . charAt ( index2 ) ; } if ( k != f ) { final int x = k ^ f ; MST[rv.UOI3Mutator]MSP[N]
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { MST[rv.ROR5Mutator]MSP[N] throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; return key . startsWith ( s1 ) ; }
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.ROR2Mutator]MSP[N]
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[NegateConditionalsMutator]MSP[N]
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.AOR1Mutator]MSP[N]
if ( other == null || index2 >= endIndex2 ) { f = 0 ; } else { f = other . charAt ( index2 ) ; } if ( k != f ) { MST[rv.ABSMutator]MSP[S] final int x = k ^ f ;
return ( key . charAt ( index ) & mask ( bit ) ) != 0 ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] } @Override public boolean isPrefix ( final String prefix , final int offsetInBits , final int lengthInBits , final String key ) {
public boolean isBitSet ( final String key , final int bitIndex , final int lengthInBits ) { if ( key == null || bitIndex >= lengthInBits ) { MST[rv.UOI1Mutator]MSP[N] return false ; } final int index = bitIndex / LENGTH ; final int bit = bitIndex % LENGTH ;
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.ROR4Mutator]MSP[N]
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.UOI3Mutator]MSP[N]
if ( other == null || index2 >= endIndex2 ) { f = 0 ; } else { f = other . charAt ( index2 ) ; } if ( k != f ) { MST[rv.ROR3Mutator]MSP[S] final int x = k ^ f ;
if ( other == null || index2 >= endIndex2 ) { MST[rv.UOI1Mutator]MSP[S] f = 0 ; } else { f = other . charAt ( index2 ) ; } if ( k != f ) { final int x = k ^ f ;
final int endIndex2 = beginIndex2 + otherLengthInBits / LENGTH ; final int length = Math . max ( endIndex1 , endIndex2 ) ; MST[rv.UOI4Mutator]MSP[N] char k = 0 , f = 0 ; for ( int i = 0 ; i < length ; i ++ ) {
public boolean isBitSet ( final String key , final int bitIndex , final int lengthInBits ) { if ( key == null || bitIndex >= lengthInBits ) { return false ; } final int index = bitIndex / LENGTH ; MST[rv.UOI4Mutator]MSP[N] final int bit = bitIndex % LENGTH ;
final int index1 = beginIndex1 + i ; MST[rv.AOR2Mutator]MSP[N] final int index2 = beginIndex2 + i ; if ( index1 >= endIndex1 ) { k = 0 ; } else { k = key . charAt ( index1 ) ; }
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; MST[rv.AOR2Mutator]MSP[N] } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
public boolean isBitSet ( final String key , final int bitIndex , final int lengthInBits ) { if ( key == null || bitIndex >= lengthInBits ) { return false ; } final int index = bitIndex / LENGTH ; final int bit = bitIndex % LENGTH ; MST[rv.UOI1Mutator]MSP[N]
final int index1 = beginIndex1 + i ; final int index2 = beginIndex2 + i ; MST[rv.AOR4Mutator]MSP[N] if ( index1 >= endIndex1 ) { k = 0 ; } else { k = key . charAt ( index1 ) ; }
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; return key . startsWith ( s1 ) ; }
if ( other == null || index2 >= endIndex2 ) { f = 0 ; } else { f = other . charAt ( index2 ) ; } if ( k != f ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] final int x = k ^ f ;
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; MST[rv.CRCR1Mutator]MSP[S] } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; MST[rv.CRCR5Mutator]MSP[S] } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
|| lengthInBits % LENGTH != 0 || otherLengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } final int beginIndex1 = offsetInBits / LENGTH ; final int beginIndex2 = otherOffsetInBits / LENGTH ; MST[rv.AOD2Mutator]MSP[N] final int endIndex1 = beginIndex1 + lengthInBits / LENGTH ;
|| lengthInBits % LENGTH != 0 || otherLengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } final int beginIndex1 = offsetInBits / LENGTH ; final int beginIndex2 = otherOffsetInBits / LENGTH ; MST[rv.UOI2Mutator]MSP[N] final int endIndex1 = beginIndex1 + lengthInBits / LENGTH ;
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { MST[rv.UOI3Mutator]MSP[N] return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
|| lengthInBits % LENGTH != 0 || otherLengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } final int beginIndex1 = offsetInBits / LENGTH ; final int beginIndex2 = otherOffsetInBits / LENGTH ; final int endIndex1 = beginIndex1 + lengthInBits / LENGTH ; MST[rv.UOI4Mutator]MSP[N]
|| lengthInBits % LENGTH != 0 || otherLengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } final int beginIndex1 = offsetInBits / LENGTH ; final int beginIndex2 = otherOffsetInBits / LENGTH ; final int endIndex1 = beginIndex1 + lengthInBits / LENGTH ; MST[rv.AOR1Mutator]MSP[N]
final int index1 = beginIndex1 + i ; final int index2 = beginIndex2 + i ; MST[MathMutator]MSP[S] if ( index1 >= endIndex1 ) { k = 0 ; } else { k = key . charAt ( index1 ) ; }
final int endIndex2 = beginIndex2 + otherLengthInBits / LENGTH ; final int length = Math . max ( endIndex1 , endIndex2 ) ; char k = 0 , f = 0 ; MST[InlineConstantMutator]MSP[N] for ( int i = 0 ; i < length ; i ++ ) {
final int index1 = beginIndex1 + i ; MST[rv.UOI1Mutator]MSP[N] final int index2 = beginIndex2 + i ; if ( index1 >= endIndex1 ) { k = 0 ; } else { k = key . charAt ( index1 ) ; }
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.ROR5Mutator]MSP[N]
final int endIndex2 = beginIndex2 + otherLengthInBits / LENGTH ; MST[rv.CRCR2Mutator]MSP[N] final int length = Math . max ( endIndex1 , endIndex2 ) ; char k = 0 , f = 0 ; for ( int i = 0 ; i < length ; i ++ ) {
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { MST[rv.ROR2Mutator]MSP[S] throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; return key . startsWith ( s1 ) ; }
final int endIndex2 = beginIndex2 + otherLengthInBits / LENGTH ; MST[rv.CRCR6Mutator]MSP[N] final int length = Math . max ( endIndex1 , endIndex2 ) ; char k = 0 , f = 0 ; for ( int i = 0 ; i < length ; i ++ ) {
final int endIndex2 = beginIndex2 + otherLengthInBits / LENGTH ; MST[rv.AOR3Mutator]MSP[N] final int length = Math . max ( endIndex1 , endIndex2 ) ; char k = 0 , f = 0 ; for ( int i = 0 ; i < length ; i ++ ) {
final int index1 = beginIndex1 + i ; final int index2 = beginIndex2 + i ; MST[rv.UOI3Mutator]MSP[N] if ( index1 >= endIndex1 ) { k = 0 ; } else { k = key . charAt ( index1 ) ; }
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; MST[rv.CRCR4Mutator]MSP[S] } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
if ( other == null || index2 >= endIndex2 ) { f = 0 ; } else { f = other . charAt ( index2 ) ; } if ( k != f ) { final int x = k ^ f ; MST[rv.UOI3Mutator]MSP[N]
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.UOI2Mutator]MSP[S]
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.AOR2Mutator]MSP[N]
final int index1 = beginIndex1 + i ; MST[rv.ABSMutator]MSP[N] final int index2 = beginIndex2 + i ; if ( index1 >= endIndex1 ) { k = 0 ; } else { k = key . charAt ( index1 ) ; }
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.ROR1Mutator]MSP[N]
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { MST[rv.UOI3Mutator]MSP[N] throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; return key . startsWith ( s1 ) ; }
public boolean isBitSet ( final String key , final int bitIndex , final int lengthInBits ) { if ( key == null || bitIndex >= lengthInBits ) { MST[rv.UOI1Mutator]MSP[N] return false ; } final int index = bitIndex / LENGTH ; final int bit = bitIndex % LENGTH ;
return ( key . charAt ( index ) & mask ( bit ) ) != 0 ; MST[rv.CRCR5Mutator]MSP[N] } @Override public boolean isPrefix ( final String prefix , final int offsetInBits , final int lengthInBits , final String key ) {
private static int mask ( final int bit ) { return MSB >>> bit ; MST[MathMutator]MSP[N] } @Override public int bitsPerElement () { return LENGTH ; } @Override public int lengthInBits ( final String key ) { return key != null ? key . length () * LENGTH : 0 ;
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; } if ( k != 0 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { MST[MathMutator]MSP[N] throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; return key . startsWith ( s1 ) ; }
public boolean isBitSet ( final String key , final int bitIndex , final int lengthInBits ) { if ( key == null || bitIndex >= lengthInBits ) { MST[rv.ROR2Mutator]MSP[N] return false ; } final int index = bitIndex / LENGTH ; final int bit = bitIndex % LENGTH ;
return ( key . charAt ( index ) & mask ( bit ) ) != 0 ; MST[rv.OBBN1Mutator]MSP[S] } @Override public boolean isPrefix ( final String prefix , final int offsetInBits , final int lengthInBits , final String key ) {
return ( key . charAt ( index ) & mask ( bit ) ) != 0 ; MST[MathMutator]MSP[S] } @Override public boolean isPrefix ( final String prefix , final int offsetInBits , final int lengthInBits , final String key ) {
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; MST[rv.CRCR2Mutator]MSP[N] return key . startsWith ( s1 ) ; }
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { MST[rv.AOR2Mutator]MSP[N] throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; return key . startsWith ( s1 ) ; }
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { MST[rv.AOR1Mutator]MSP[N] throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; return key . startsWith ( s1 ) ; }
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; return key . startsWith ( s1 ) ; MST[BooleanTrueReturnValsMutator]MSP[S] }
if ( other == null || index2 >= endIndex2 ) { MST[rv.ABSMutator]MSP[N] f = 0 ; } else { f = other . charAt ( index2 ) ; } if ( k != f ) { final int x = k ^ f ;
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.CRCR1Mutator]MSP[N]
return ( key . charAt ( index ) & mask ( bit ) ) != 0 ; MST[rv.UOI4Mutator]MSP[N] } @Override public boolean isPrefix ( final String prefix , final int offsetInBits , final int lengthInBits , final String key ) {
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; MST[PrimitiveReturnsMutator]MSP[N] } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.CRCR5Mutator]MSP[N]
private static int mask ( final int bit ) { return MSB >>> bit ; MST[rv.CRCR3Mutator]MSP[S] } @Override public int bitsPerElement () { return LENGTH ; } @Override public int lengthInBits ( final String key ) { return key != null ? key . length () * LENGTH : 0 ;
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.CRCR6Mutator]MSP[N]
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.CRCR3Mutator]MSP[S]
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; } if ( k != 0 ) { MST[rv.ROR4Mutator]MSP[N] allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.CRCR4Mutator]MSP[N]
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.CRCR2Mutator]MSP[N]
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; MST[rv.AOR2Mutator]MSP[N] return key . startsWith ( s1 ) ; }
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; MST[ArgumentPropagationMutator]MSP[N] } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; } if ( k != 0 ) { MST[rv.ROR1Mutator]MSP[N] allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
final int index1 = beginIndex1 + i ; final int index2 = beginIndex2 + i ; if ( index1 >= endIndex1 ) { MST[rv.ROR2Mutator]MSP[N] k = 0 ; } else { k = key . charAt ( index1 ) ; }
final int index1 = beginIndex1 + i ; final int index2 = beginIndex2 + i ; if ( index1 >= endIndex1 ) { MST[rv.ROR5Mutator]MSP[S] k = 0 ; } else { k = key . charAt ( index1 ) ; }
|| lengthInBits % LENGTH != 0 || otherLengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } final int beginIndex1 = offsetInBits / LENGTH ; final int beginIndex2 = otherOffsetInBits / LENGTH ; MST[rv.AOR3Mutator]MSP[N] final int endIndex1 = beginIndex1 + lengthInBits / LENGTH ;
final int endIndex2 = beginIndex2 + otherLengthInBits / LENGTH ; MST[rv.AOD2Mutator]MSP[N] final int length = Math . max ( endIndex1 , endIndex2 ) ; char k = 0 , f = 0 ; for ( int i = 0 ; i < length ; i ++ ) {
final int endIndex2 = beginIndex2 + otherLengthInBits / LENGTH ; MST[rv.AOD2Mutator]MSP[N] final int length = Math . max ( endIndex1 , endIndex2 ) ; char k = 0 , f = 0 ; for ( int i = 0 ; i < length ; i ++ ) {
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; } if ( k != 0 ) { MST[rv.UOI4Mutator]MSP[N] allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
final int endIndex2 = beginIndex2 + otherLengthInBits / LENGTH ; final int length = Math . max ( endIndex1 , endIndex2 ) ; char k = 0 , f = 0 ; for ( int i = 0 ; i < length ; i ++ ) { MST[rv.ROR2Mutator]MSP[N]
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; MST[rv.ABSMutator]MSP[N] } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
|| lengthInBits % LENGTH != 0 || otherLengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } final int beginIndex1 = offsetInBits / LENGTH ; final int beginIndex2 = otherOffsetInBits / LENGTH ; final int endIndex1 = beginIndex1 + lengthInBits / LENGTH ; MST[rv.CRCR1Mutator]MSP[S]
public boolean isBitSet ( final String key , final int bitIndex , final int lengthInBits ) { if ( key == null || bitIndex >= lengthInBits ) { return false ; } final int index = bitIndex / LENGTH ; final int bit = bitIndex % LENGTH ; MST[rv.CRCR6Mutator]MSP[N]
final int endIndex2 = beginIndex2 + otherLengthInBits / LENGTH ; MST[rv.AOR3Mutator]MSP[N] final int length = Math . max ( endIndex1 , endIndex2 ) ; char k = 0 , f = 0 ; for ( int i = 0 ; i < length ; i ++ ) {
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; MST[InlineConstantMutator]MSP[N] } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
public boolean isBitSet ( final String key , final int bitIndex , final int lengthInBits ) { if ( key == null || bitIndex >= lengthInBits ) { return false ; MST[BooleanTrueReturnValsMutator]MSP[N] } final int index = bitIndex / LENGTH ; final int bit = bitIndex % LENGTH ;
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.AOD2Mutator]MSP[N]
final int index1 = beginIndex1 + i ; final int index2 = beginIndex2 + i ; MST[rv.UOI3Mutator]MSP[S] if ( index1 >= endIndex1 ) { k = 0 ; } else { k = key . charAt ( index1 ) ; }
public boolean isBitSet ( final String key , final int bitIndex , final int lengthInBits ) { if ( key == null || bitIndex >= lengthInBits ) { return false ; } final int index = bitIndex / LENGTH ; final int bit = bitIndex % LENGTH ; MST[rv.AOR2Mutator]MSP[N]
|| lengthInBits % LENGTH != 0 || otherLengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } final int beginIndex1 = offsetInBits / LENGTH ; final int beginIndex2 = otherOffsetInBits / LENGTH ; MST[rv.CRCR2Mutator]MSP[N] final int endIndex1 = beginIndex1 + lengthInBits / LENGTH ;
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { MST[rv.AOR4Mutator]MSP[S] throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; return key . startsWith ( s1 ) ; }
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; } if ( k != 0 ) { allNull = false ; MST[rv.CRCR1Mutator]MSP[N] } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
return ( key . charAt ( index ) & mask ( bit ) ) != 0 ; MST[rv.CRCR6Mutator]MSP[S] } @Override public boolean isPrefix ( final String prefix , final int offsetInBits , final int lengthInBits , final String key ) {
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; MST[rv.CRCR5Mutator]MSP[N] return key . startsWith ( s1 ) ; }
final int index1 = beginIndex1 + i ; MST[rv.ABSMutator]MSP[N] final int index2 = beginIndex2 + i ; if ( index1 >= endIndex1 ) { k = 0 ; } else { k = key . charAt ( index1 ) ; }
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { MST[rv.UOI4Mutator]MSP[N] throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; return key . startsWith ( s1 ) ; }
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; return key . startsWith ( s1 ) ; }
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.ABSMutator]MSP[N]
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.AOR3Mutator]MSP[N]
public boolean isBitSet ( final String key , final int bitIndex , final int lengthInBits ) { if ( key == null || bitIndex >= lengthInBits ) { MST[rv.UOI2Mutator]MSP[N] return false ; } final int index = bitIndex / LENGTH ; final int bit = bitIndex % LENGTH ;
final int index1 = beginIndex1 + i ; final int index2 = beginIndex2 + i ; if ( index1 >= endIndex1 ) { k = 0 ; MST[rv.CRCR5Mutator]MSP[N] } else { k = key . charAt ( index1 ) ; }
public boolean isBitSet ( final String key , final int bitIndex , final int lengthInBits ) { if ( key == null || bitIndex >= lengthInBits ) { return false ; } final int index = bitIndex / LENGTH ; final int bit = bitIndex % LENGTH ; MST[rv.AOD1Mutator]MSP[N]
return ( key . charAt ( index ) & mask ( bit ) ) != 0 ; MST[rv.CRCR4Mutator]MSP[N] } @Override public boolean isPrefix ( final String prefix , final int offsetInBits , final int lengthInBits , final String key ) {
final int endIndex2 = beginIndex2 + otherLengthInBits / LENGTH ; MST[rv.UOI2Mutator]MSP[N] final int length = Math . max ( endIndex1 , endIndex2 ) ; char k = 0 , f = 0 ; for ( int i = 0 ; i < length ; i ++ ) {
public boolean isBitSet ( final String key , final int bitIndex , final int lengthInBits ) { if ( key == null || bitIndex >= lengthInBits ) { return false ; } final int index = bitIndex / LENGTH ; final int bit = bitIndex % LENGTH ; MST[InlineConstantMutator]MSP[N]
private static int mask ( final int bit ) { return MSB >>> bit ; } @Override public int bitsPerElement () { return LENGTH ; } @Override public int lengthInBits ( final String key ) { return key != null ? key . length () * LENGTH : 0 ; MST[rv.CRCR5Mutator]MSP[N]
if ( other == null || index2 >= endIndex2 ) { MST[rv.ABSMutator]MSP[S] f = 0 ; } else { f = other . charAt ( index2 ) ; } if ( k != f ) { final int x = k ^ f ;
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[MathMutator]MSP[N]
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; MST[rv.AOR2Mutator]MSP[N] } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
final int index1 = beginIndex1 + i ; final int index2 = beginIndex2 + i ; MST[rv.AOR3Mutator]MSP[N] if ( index1 >= endIndex1 ) { k = 0 ; } else { k = key . charAt ( index1 ) ; }
|| lengthInBits % LENGTH != 0 || otherLengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } final int beginIndex1 = offsetInBits / LENGTH ; final int beginIndex2 = otherOffsetInBits / LENGTH ; MST[rv.UOI3Mutator]MSP[N] final int endIndex1 = beginIndex1 + lengthInBits / LENGTH ;
private static int mask ( final int bit ) { return MSB >>> bit ; } @Override public int bitsPerElement () { return LENGTH ; MST[InlineConstantMutator]MSP[N] } @Override public int lengthInBits ( final String key ) { return key != null ? key . length () * LENGTH : 0 ;
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; MST[rv.CRCR5Mutator]MSP[N] } @Override
|| lengthInBits % LENGTH != 0 || otherLengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } final int beginIndex1 = offsetInBits / LENGTH ; MST[rv.UOI1Mutator]MSP[N] final int beginIndex2 = otherOffsetInBits / LENGTH ; final int endIndex1 = beginIndex1 + lengthInBits / LENGTH ;
return ( key . charAt ( index ) & mask ( bit ) ) != 0 ; MST[rv.ROR5Mutator]MSP[S] } @Override public boolean isPrefix ( final String prefix , final int offsetInBits , final int lengthInBits , final String key ) {
public boolean isBitSet ( final String key , final int bitIndex , final int lengthInBits ) { if ( key == null || bitIndex >= lengthInBits ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] return false ; } final int index = bitIndex / LENGTH ; final int bit = bitIndex % LENGTH ;
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; MST[rv.CRCR5Mutator]MSP[N] if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; MST[rv.AOR3Mutator]MSP[N] return key . startsWith ( s1 ) ; }
private static int mask ( final int bit ) { return MSB >>> bit ; } @Override public int bitsPerElement () { return LENGTH ; MST[rv.CRCR3Mutator]MSP[N] } @Override public int lengthInBits ( final String key ) { return key != null ? key . length () * LENGTH : 0 ;
final int endIndex2 = beginIndex2 + otherLengthInBits / LENGTH ; final int length = Math . max ( endIndex1 , endIndex2 ) ; char k = 0 , f = 0 ; MST[rv.CRCR5Mutator]MSP[N] for ( int i = 0 ; i < length ; i ++ ) {
final int endIndex2 = beginIndex2 + otherLengthInBits / LENGTH ; final int length = Math . max ( endIndex1 , endIndex2 ) ; char k = 0 , f = 0 ; for ( int i = 0 ; i < length ; i ++ ) { MST[rv.ROR5Mutator]MSP[N]
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( MST[ConstructorCallMutator]MSP[S] lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; return key . startsWith ( s1 ) ; }
|| lengthInBits % LENGTH != 0 || otherLengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } final int beginIndex1 = offsetInBits / LENGTH ; MST[rv.AOR1Mutator]MSP[N] final int beginIndex2 = otherOffsetInBits / LENGTH ; final int endIndex1 = beginIndex1 + lengthInBits / LENGTH ;
private static int mask ( final int bit ) { return MSB >>> bit ; } @Override public int bitsPerElement () { return LENGTH ; } @Override public int lengthInBits ( final String key ) { return key != null ? key . length () * LENGTH : 0 ; MST[rv.ROR5Mutator]MSP[N]
private static int mask ( final int bit ) { return MSB >>> bit ; } @Override public int bitsPerElement () { return LENGTH ; } @Override public int lengthInBits ( final String key ) { return key != null ? key . length () * LENGTH : 0 ; MST[rv.AOR1Mutator]MSP[N]
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
public boolean isBitSet ( final String key , final int bitIndex , final int lengthInBits ) { if ( key == null || bitIndex >= lengthInBits ) { return false ; } final int index = bitIndex / LENGTH ; MST[rv.CRCR1Mutator]MSP[S] final int bit = bitIndex % LENGTH ;
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; } if ( k != 0 ) { MST[NegateConditionalsMutator]MSP[N] allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { MST[rv.CRCR1Mutator]MSP[S] throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; return key . startsWith ( s1 ) ; }
if ( other == null || index2 >= endIndex2 ) { f = 0 ; } else { f = other . charAt ( index2 ) ; } if ( k != f ) { MST[rv.UOI2Mutator]MSP[N] final int x = k ^ f ;
return ( key . charAt ( index ) & mask ( bit ) ) != 0 ; MST[InlineConstantMutator]MSP[S] } @Override public boolean isPrefix ( final String prefix , final int offsetInBits , final int lengthInBits , final String key ) {
|| lengthInBits % LENGTH != 0 || otherLengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } final int beginIndex1 = offsetInBits / LENGTH ; final int beginIndex2 = otherOffsetInBits / LENGTH ; final int endIndex1 = beginIndex1 + lengthInBits / LENGTH ; MST[rv.CRCR4Mutator]MSP[N]
if ( other == null || index2 >= endIndex2 ) { f = 0 ; } else { f = other . charAt ( index2 ) ; } if ( k != f ) { final int x = k ^ f ; MST[rv.UOI4Mutator]MSP[N]
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; MST[rv.CRCR6Mutator]MSP[N] } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.AOD1Mutator]MSP[N]
final int index1 = beginIndex1 + i ; MST[rv.AOD1Mutator]MSP[S] final int index2 = beginIndex2 + i ; if ( index1 >= endIndex1 ) { k = 0 ; } else { k = key . charAt ( index1 ) ; }
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; MST[rv.AOD1Mutator]MSP[N] } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.AOR4Mutator]MSP[N]
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.ROR3Mutator]MSP[N]
|| lengthInBits % LENGTH != 0 || otherLengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } final int beginIndex1 = offsetInBits / LENGTH ; MST[rv.CRCR5Mutator]MSP[S] final int beginIndex2 = otherOffsetInBits / LENGTH ; final int endIndex1 = beginIndex1 + lengthInBits / LENGTH ;
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { MST[NegateConditionalsMutator]MSP[N] throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; return key . startsWith ( s1 ) ; }
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; MST[rv.CRCR1Mutator]MSP[N] return key . startsWith ( s1 ) ; }
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.UOI4Mutator]MSP[N]
final int endIndex2 = beginIndex2 + otherLengthInBits / LENGTH ; MST[rv.UOI3Mutator]MSP[N] final int length = Math . max ( endIndex1 , endIndex2 ) ; char k = 0 , f = 0 ; for ( int i = 0 ; i < length ; i ++ ) {
final int index1 = beginIndex1 + i ; final int index2 = beginIndex2 + i ; MST[rv.AOD1Mutator]MSP[N] if ( index1 >= endIndex1 ) { k = 0 ; } else { k = key . charAt ( index1 ) ; }
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { MST[rv.ROR3Mutator]MSP[S] return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { MST[rv.ROR1Mutator]MSP[N] return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
if ( other == null || index2 >= endIndex2 ) { MST[rv.UOI2Mutator]MSP[N] f = 0 ; } else { f = other . charAt ( index2 ) ; } if ( k != f ) { final int x = k ^ f ;
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
return ( key . charAt ( index ) & mask ( bit ) ) != 0 ; MST[ReturnValsMutator]MSP[S] } @Override public boolean isPrefix ( final String prefix , final int offsetInBits , final int lengthInBits , final String key ) {
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; MST[rv.CRCR5Mutator]MSP[N] } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
final int endIndex2 = beginIndex2 + otherLengthInBits / LENGTH ; final int length = Math . max ( endIndex1 , endIndex2 ) ; MST[rv.UOI1Mutator]MSP[S] char k = 0 , f = 0 ; for ( int i = 0 ; i < length ; i ++ ) {
return ( key . charAt ( index ) & mask ( bit ) ) != 0 ; MST[rv.UOI4Mutator]MSP[S] } @Override public boolean isPrefix ( final String prefix , final int offsetInBits , final int lengthInBits , final String key ) {
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; return key . startsWith ( s1 ) ; MST[NonVoidMethodCallMutator]MSP[N] }
return ( key . charAt ( index ) & mask ( bit ) ) != 0 ; MST[BooleanTrueReturnValsMutator]MSP[S] } @Override public boolean isPrefix ( final String prefix , final int offsetInBits , final int lengthInBits , final String key ) {
final int index1 = beginIndex1 + i ; final int index2 = beginIndex2 + i ; if ( index1 >= endIndex1 ) { k = 0 ; } else { k = key . charAt ( index1 ) ; MST[rv.UOI4Mutator]MSP[N] }
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; MST[NonVoidMethodCallMutator]MSP[N] } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
private static int mask ( final int bit ) { return MSB >>> bit ; } @Override public int bitsPerElement () { return LENGTH ; } @Override public int lengthInBits ( final String key ) { return key != null ? key . length () * LENGTH : 0 ; MST[rv.AOR3Mutator]MSP[N]
final int index1 = beginIndex1 + i ; final int index2 = beginIndex2 + i ; if ( index1 >= endIndex1 ) { MST[rv.UOI1Mutator]MSP[S] k = 0 ; } else { k = key . charAt ( index1 ) ; }
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; MST[InlineConstantMutator]MSP[S] if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0
|| lengthInBits % LENGTH != 0 || otherLengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } final int beginIndex1 = offsetInBits / LENGTH ; MST[rv.AOR3Mutator]MSP[N] final int beginIndex2 = otherOffsetInBits / LENGTH ; final int endIndex1 = beginIndex1 + lengthInBits / LENGTH ;
final int endIndex2 = beginIndex2 + otherLengthInBits / LENGTH ; final int length = Math . max ( endIndex1 , endIndex2 ) ; char k = 0 , f = 0 ; for ( int i = 0 ; i < length ; i ++ ) { MST[rv.CRCR6Mutator]MSP[N]
final int endIndex2 = beginIndex2 + otherLengthInBits / LENGTH ; final int length = Math . max ( endIndex1 , endIndex2 ) ; char k = 0 , f = 0 ; MST[InlineConstantMutator]MSP[N] for ( int i = 0 ; i < length ; i ++ ) {
|| lengthInBits % LENGTH != 0 || otherLengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } final int beginIndex1 = offsetInBits / LENGTH ; final int beginIndex2 = otherOffsetInBits / LENGTH ; final int endIndex1 = beginIndex1 + lengthInBits / LENGTH ; MST[rv.AOR2Mutator]MSP[N]
final int endIndex2 = beginIndex2 + otherLengthInBits / LENGTH ; final int length = Math . max ( endIndex1 , endIndex2 ) ; char k = 0 , f = 0 ; MST[rv.CRCR5Mutator]MSP[N] for ( int i = 0 ; i < length ; i ++ ) {
|| lengthInBits % LENGTH != 0 || otherLengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } final int beginIndex1 = offsetInBits / LENGTH ; final int beginIndex2 = otherOffsetInBits / LENGTH ; final int endIndex1 = beginIndex1 + lengthInBits / LENGTH ; MST[rv.UOI1Mutator]MSP[N]
private static int mask ( final int bit ) { return MSB >>> bit ; MST[ReturnValsMutator]MSP[S] } @Override public int bitsPerElement () { return LENGTH ; } @Override public int lengthInBits ( final String key ) { return key != null ? key . length () * LENGTH : 0 ;
if ( other == null || index2 >= endIndex2 ) { MST[NegateConditionalsMutator]MSP[N] f = 0 ; } else { f = other . charAt ( index2 ) ; } if ( k != f ) { final int x = k ^ f ;
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { MST[rv.ABSMutator]MSP[N] return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.ROR4Mutator]MSP[N]
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { MST[rv.ROR1Mutator]MSP[N] throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; return key . startsWith ( s1 ) ; }
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[InlineConstantMutator]MSP[N]
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { MST[rv.CRCR4Mutator]MSP[N] throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; return key . startsWith ( s1 ) ; }
final int endIndex2 = beginIndex2 + otherLengthInBits / LENGTH ; MST[rv.AOR4Mutator]MSP[N] final int length = Math . max ( endIndex1 , endIndex2 ) ; char k = 0 , f = 0 ; for ( int i = 0 ; i < length ; i ++ ) {
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; MST[rv.CRCR1Mutator]MSP[S] } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; MST[rv.CRCR4Mutator]MSP[N] } @Override
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { MST[rv.CRCR6Mutator]MSP[N] throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; return key . startsWith ( s1 ) ; }
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
if ( other == null || index2 >= endIndex2 ) { f = 0 ; } else { f = other . charAt ( index2 ) ; } if ( k != f ) { final int x = k ^ f ; MST[rv.UOI4Mutator]MSP[N]
public boolean isBitSet ( final String key , final int bitIndex , final int lengthInBits ) { if ( key == null || bitIndex >= lengthInBits ) { MST[NegateConditionalsMutator]MSP[N] return false ; } final int index = bitIndex / LENGTH ; final int bit = bitIndex % LENGTH ;
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.UOI3Mutator]MSP[N]
final int index1 = beginIndex1 + i ; final int index2 = beginIndex2 + i ; MST[rv.ABSMutator]MSP[N] if ( index1 >= endIndex1 ) { k = 0 ; } else { k = key . charAt ( index1 ) ; }
if ( other == null || index2 >= endIndex2 ) { f = 0 ; } else { f = other . charAt ( index2 ) ; MST[rv.UOI1Mutator]MSP[N] } if ( k != f ) { final int x = k ^ f ;
|| lengthInBits % LENGTH != 0 || otherLengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } final int beginIndex1 = offsetInBits / LENGTH ; final int beginIndex2 = otherOffsetInBits / LENGTH ; final int endIndex1 = beginIndex1 + lengthInBits / LENGTH ; MST[MathMutator]MSP[S]
public boolean isBitSet ( final String key , final int bitIndex , final int lengthInBits ) { if ( key == null || bitIndex >= lengthInBits ) { return false ; } final int index = bitIndex / LENGTH ; MST[rv.AOR2Mutator]MSP[S] final int bit = bitIndex % LENGTH ;
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; MST[rv.CRCR4Mutator]MSP[N] return key . startsWith ( s1 ) ; }
final int index1 = beginIndex1 + i ; final int index2 = beginIndex2 + i ; if ( index1 >= endIndex1 ) { k = 0 ; MST[InlineConstantMutator]MSP[N] } else { k = key . charAt ( index1 ) ; }
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.UOI1Mutator]MSP[N]
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.ROR2Mutator]MSP[N]
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[NegateConditionalsMutator]MSP[N]
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.AOR1Mutator]MSP[N]
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; MST[ReturnValsMutator]MSP[N] } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
|| lengthInBits % LENGTH != 0 || otherLengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } final int beginIndex1 = offsetInBits / LENGTH ; MST[rv.CRCR4Mutator]MSP[N] final int beginIndex2 = otherOffsetInBits / LENGTH ; final int endIndex1 = beginIndex1 + lengthInBits / LENGTH ;
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; MST[rv.CRCR6Mutator]MSP[S] return key . startsWith ( s1 ) ; }
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { MST[rv.AOD1Mutator]MSP[N] throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; return key . startsWith ( s1 ) ; }
if ( other == null || index2 >= endIndex2 ) { MST[rv.ROR5Mutator]MSP[N] f = 0 ; } else { f = other . charAt ( index2 ) ; } if ( k != f ) { final int x = k ^ f ;
if ( other == null || index2 >= endIndex2 ) { MST[rv.UOI2Mutator]MSP[N] f = 0 ; } else { f = other . charAt ( index2 ) ; } if ( k != f ) { final int x = k ^ f ;
final int endIndex2 = beginIndex2 + otherLengthInBits / LENGTH ; MST[rv.UOI3Mutator]MSP[S] final int length = Math . max ( endIndex1 , endIndex2 ) ; char k = 0 , f = 0 ; for ( int i = 0 ; i < length ; i ++ ) {
public boolean isBitSet ( final String key , final int bitIndex , final int lengthInBits ) { if ( key == null || bitIndex >= lengthInBits ) { MST[rv.ABSMutator]MSP[N] return false ; } final int index = bitIndex / LENGTH ; final int bit = bitIndex % LENGTH ;
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.AOR3Mutator]MSP[N]
final int index1 = beginIndex1 + i ; MST[rv.AOR3Mutator]MSP[N] final int index2 = beginIndex2 + i ; if ( index1 >= endIndex1 ) { k = 0 ; } else { k = key . charAt ( index1 ) ; }
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; MST[rv.AOR4Mutator]MSP[S] } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; MST[rv.AOR3Mutator]MSP[N] } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
final int endIndex2 = beginIndex2 + otherLengthInBits / LENGTH ; final int length = Math . max ( endIndex1 , endIndex2 ) ; char k = 0 , f = 0 ; for ( int i = 0 ; i < length ; i ++ ) { MST[IncrementsMutator]MSP[N]
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; MST[InlineConstantMutator]MSP[N] } @Override
public boolean isBitSet ( final String key , final int bitIndex , final int lengthInBits ) { if ( key == null || bitIndex >= lengthInBits ) { return false ; } final int index = bitIndex / LENGTH ; final int bit = bitIndex % LENGTH ; MST[rv.UOI2Mutator]MSP[N]
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; MST[rv.AOD1Mutator]MSP[N] return key . startsWith ( s1 ) ; }
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; MST[rv.CRCR4Mutator]MSP[S] } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
if ( other == null || index2 >= endIndex2 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] f = 0 ; } else { f = other . charAt ( index2 ) ; } if ( k != f ) { final int x = k ^ f ;
public boolean isBitSet ( final String key , final int bitIndex , final int lengthInBits ) { if ( key == null || bitIndex >= lengthInBits ) { return false ; } final int index = bitIndex / LENGTH ; MST[MathMutator]MSP[S] final int bit = bitIndex % LENGTH ;
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { MST[rv.UOI4Mutator]MSP[S] return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
final int index1 = beginIndex1 + i ; final int index2 = beginIndex2 + i ; if ( index1 >= endIndex1 ) { MST[rv.UOI1Mutator]MSP[S] k = 0 ; } else { k = key . charAt ( index1 ) ; }
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; MST[rv.ABSMutator]MSP[N] return key . startsWith ( s1 ) ; }
if ( other == null || index2 >= endIndex2 ) { f = 0 ; MST[rv.CRCR6Mutator]MSP[N] } else { f = other . charAt ( index2 ) ; } if ( k != f ) { final int x = k ^ f ;
return ( key . charAt ( index ) & mask ( bit ) ) != 0 ; MST[rv.ROR4Mutator]MSP[N] } @Override public boolean isPrefix ( final String prefix , final int offsetInBits , final int lengthInBits , final String key ) {
|| lengthInBits % LENGTH != 0 || otherLengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } final int beginIndex1 = offsetInBits / LENGTH ; final int beginIndex2 = otherOffsetInBits / LENGTH ; final int endIndex1 = beginIndex1 + lengthInBits / LENGTH ; MST[rv.AOR2Mutator]MSP[N]
final int endIndex2 = beginIndex2 + otherLengthInBits / LENGTH ; final int length = Math . max ( endIndex1 , endIndex2 ) ; char k = 0 , f = 0 ; for ( int i = 0 ; i < length ; i ++ ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N]
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; MST[rv.UOI4Mutator]MSP[N] return key . startsWith ( s1 ) ; }
private static int mask ( final int bit ) { return MSB >>> bit ; MST[rv.UOI3Mutator]MSP[N] } @Override public int bitsPerElement () { return LENGTH ; } @Override public int lengthInBits ( final String key ) { return key != null ? key . length () * LENGTH : 0 ;
private static int mask ( final int bit ) { return MSB >>> bit ; } @Override public int bitsPerElement () { return LENGTH ; } @Override public int lengthInBits ( final String key ) { return key != null ? key . length () * LENGTH : 0 ; MST[InlineConstantMutator]MSP[N]
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; MST[rv.UOI2Mutator]MSP[N] } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; MST[rv.UOI1Mutator]MSP[N] } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
final int index1 = beginIndex1 + i ; MST[rv.UOI2Mutator]MSP[S] final int index2 = beginIndex2 + i ; if ( index1 >= endIndex1 ) { k = 0 ; } else { k = key . charAt ( index1 ) ; }
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; MST[rv.UOI3Mutator]MSP[N] return key . startsWith ( s1 ) ; }
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.ROR5Mutator]MSP[N]
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.UOI2Mutator]MSP[N]
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; MST[PrimitiveReturnsMutator]MSP[N] } @Override
public boolean isBitSet ( final String key , final int bitIndex , final int lengthInBits ) { if ( key == null || bitIndex >= lengthInBits ) { return false ; } final int index = bitIndex / LENGTH ; MST[rv.CRCR3Mutator]MSP[S] final int bit = bitIndex % LENGTH ;
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { MST[rv.CRCR3Mutator]MSP[N] throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; return key . startsWith ( s1 ) ; }
public boolean isBitSet ( final String key , final int bitIndex , final int lengthInBits ) { if ( key == null || bitIndex >= lengthInBits ) { return false ; } final int index = bitIndex / LENGTH ; final int bit = bitIndex % LENGTH ; MST[rv.CRCR5Mutator]MSP[N]
final int index1 = beginIndex1 + i ; final int index2 = beginIndex2 + i ; MST[rv.UOI4Mutator]MSP[N] if ( index1 >= endIndex1 ) { k = 0 ; } else { k = key . charAt ( index1 ) ; }
public boolean isBitSet ( final String key , final int bitIndex , final int lengthInBits ) { if ( key == null || bitIndex >= lengthInBits ) { MST[rv.UOI2Mutator]MSP[N] return false ; } final int index = bitIndex / LENGTH ; final int bit = bitIndex % LENGTH ;
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { MST[rv.UOI3Mutator]MSP[N] throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; return key . startsWith ( s1 ) ; }
public boolean isBitSet ( final String key , final int bitIndex , final int lengthInBits ) { if ( key == null || bitIndex >= lengthInBits ) { return false ; } final int index = bitIndex / LENGTH ; final int bit = bitIndex % LENGTH ; MST[rv.ABSMutator]MSP[N]
|| lengthInBits % LENGTH != 0 || otherLengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } final int beginIndex1 = offsetInBits / LENGTH ; MST[InlineConstantMutator]MSP[S] final int beginIndex2 = otherOffsetInBits / LENGTH ; final int endIndex1 = beginIndex1 + lengthInBits / LENGTH ;
public boolean isBitSet ( final String key , final int bitIndex , final int lengthInBits ) { if ( key == null || bitIndex >= lengthInBits ) { MST[rv.ROR5Mutator]MSP[N] return false ; } final int index = bitIndex / LENGTH ; final int bit = bitIndex % LENGTH ;
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.AOR2Mutator]MSP[N]
return ( key . charAt ( index ) & mask ( bit ) ) != 0 ; MST[rv.CRCR5Mutator]MSP[S] } @Override public boolean isPrefix ( final String prefix , final int offsetInBits , final int lengthInBits , final String key ) {
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.ROR1Mutator]MSP[N]
private static int mask ( final int bit ) { return MSB >>> bit ; } @Override public int bitsPerElement () { return LENGTH ; } @Override public int lengthInBits ( final String key ) { return key != null ? key . length () * LENGTH : 0 ; MST[rv.CRCR6Mutator]MSP[S]
if ( other == null || index2 >= endIndex2 ) { f = 0 ; } else { f = other . charAt ( index2 ) ; } if ( k != f ) { MST[rv.UOI3Mutator]MSP[S] final int x = k ^ f ;
private static int mask ( final int bit ) { return MSB >>> bit ; } @Override public int bitsPerElement () { return LENGTH ; } @Override public int lengthInBits ( final String key ) { return key != null ? key . length () * LENGTH : 0 ; MST[rv.CRCR5Mutator]MSP[S]
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; MST[rv.AOD1Mutator]MSP[N] return key . startsWith ( s1 ) ; }
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; MST[rv.AOD2Mutator]MSP[N] return key . startsWith ( s1 ) ; }
return ( key . charAt ( index ) & mask ( bit ) ) != 0 ; MST[rv.OBBN2Mutator]MSP[S] } @Override public boolean isPrefix ( final String prefix , final int offsetInBits , final int lengthInBits , final String key ) {
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; MST[rv.CRCR1Mutator]MSP[N] return key . startsWith ( s1 ) ; }
|| lengthInBits % LENGTH != 0 || otherLengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } final int beginIndex1 = offsetInBits / LENGTH ; final int beginIndex2 = otherOffsetInBits / LENGTH ; MST[rv.ABSMutator]MSP[N] final int endIndex1 = beginIndex1 + lengthInBits / LENGTH ;
if ( other == null || index2 >= endIndex2 ) { MST[ConditionalsBoundaryMutator]MSP[S] f = 0 ; } else { f = other . charAt ( index2 ) ; } if ( k != f ) { final int x = k ^ f ;
public boolean isBitSet ( final String key , final int bitIndex , final int lengthInBits ) { if ( key == null || bitIndex >= lengthInBits ) { MST[rv.ABSMutator]MSP[N] return false ; } final int index = bitIndex / LENGTH ; final int bit = bitIndex % LENGTH ;
if ( other == null || index2 >= endIndex2 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[S] f = 0 ; } else { f = other . charAt ( index2 ) ; } if ( k != f ) { final int x = k ^ f ;
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { MST[rv.AOR4Mutator]MSP[S] throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; return key . startsWith ( s1 ) ; }
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; MST[rv.AOR1Mutator]MSP[S] } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; MST[rv.AOR2Mutator]MSP[S] } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { MST[rv.AOR3Mutator]MSP[N] throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; return key . startsWith ( s1 ) ; }
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; return key . startsWith ( s1 ) ; MST[BooleanFalseReturnValsMutator]MSP[S] }
private static int mask ( final int bit ) { return MSB >>> bit ; MST[rv.CRCR5Mutator]MSP[N] } @Override public int bitsPerElement () { return LENGTH ; } @Override public int lengthInBits ( final String key ) { return key != null ? key . length () * LENGTH : 0 ;
if ( other == null || index2 >= endIndex2 ) { MST[rv.ROR5Mutator]MSP[N] f = 0 ; } else { f = other . charAt ( index2 ) ; } if ( k != f ) { final int x = k ^ f ;
return ( key . charAt ( index ) & mask ( bit ) ) != 0 ; MST[rv.OBBN3Mutator]MSP[N] } @Override public boolean isPrefix ( final String prefix , final int offsetInBits , final int lengthInBits , final String key ) {
private static int mask ( final int bit ) { return MSB >>> bit ; MST[rv.CRCR4Mutator]MSP[S] } @Override public int bitsPerElement () { return LENGTH ; } @Override public int lengthInBits ( final String key ) { return key != null ? key . length () * LENGTH : 0 ;
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.CRCR4Mutator]MSP[N]
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.AOD1Mutator]MSP[N]
public boolean isBitSet ( final String key , final int bitIndex , final int lengthInBits ) { if ( key == null || bitIndex >= lengthInBits ) { MST[ConditionalsBoundaryMutator]MSP[S] return false ; } final int index = bitIndex / LENGTH ; final int bit = bitIndex % LENGTH ;
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; MST[MathMutator]MSP[S] } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; } if ( k != 0 ) { MST[rv.ROR3Mutator]MSP[N] allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
return ( key . charAt ( index ) & mask ( bit ) ) != 0 ; MST[rv.UOI1Mutator]MSP[N] } @Override public boolean isPrefix ( final String prefix , final int offsetInBits , final int lengthInBits , final String key ) {
return ( key . charAt ( index ) & mask ( bit ) ) != 0 ; MST[NegateConditionalsMutator]MSP[S] } @Override public boolean isPrefix ( final String prefix , final int offsetInBits , final int lengthInBits , final String key ) {
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.CRCR1Mutator]MSP[S]
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.CRCR3Mutator]MSP[N]
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; } if ( k != 0 ) { MST[rv.ROR2Mutator]MSP[N] allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.CRCR2Mutator]MSP[N]
final int index1 = beginIndex1 + i ; final int index2 = beginIndex2 + i ; if ( index1 >= endIndex1 ) { MST[rv.ROR4Mutator]MSP[N] k = 0 ; } else { k = key . charAt ( index1 ) ; }
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.CRCR5Mutator]MSP[N]
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; MST[rv.AOR4Mutator]MSP[S] return key . startsWith ( s1 ) ; }
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.CRCR6Mutator]MSP[N]
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; MST[rv.AOR3Mutator]MSP[N] return key . startsWith ( s1 ) ; }
private static int mask ( final int bit ) { return MSB >>> bit ; } @Override public int bitsPerElement () { return LENGTH ; } @Override public int lengthInBits ( final String key ) { return key != null ? key . length () * LENGTH : 0 ; MST[NonVoidMethodCallMutator]MSP[N]
|| lengthInBits % LENGTH != 0 || otherLengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } final int beginIndex1 = offsetInBits / LENGTH ; final int beginIndex2 = otherOffsetInBits / LENGTH ; MST[rv.AOR4Mutator]MSP[N] final int endIndex1 = beginIndex1 + lengthInBits / LENGTH ;
final int endIndex2 = beginIndex2 + otherLengthInBits / LENGTH ; MST[rv.AOD1Mutator]MSP[N] final int length = Math . max ( endIndex1 , endIndex2 ) ; char k = 0 , f = 0 ; for ( int i = 0 ; i < length ; i ++ ) {
public boolean isBitSet ( final String key , final int bitIndex , final int lengthInBits ) { if ( key == null || bitIndex >= lengthInBits ) { return false ; } final int index = bitIndex / LENGTH ; final int bit = bitIndex % LENGTH ; MST[rv.CRCR4Mutator]MSP[N]
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; MST[rv.UOI4Mutator]MSP[N] return key . startsWith ( s1 ) ; }
private static int mask ( final int bit ) { return MSB >>> bit ; } @Override public int bitsPerElement () { return LENGTH ; } @Override public int lengthInBits ( final String key ) { return key != null ? key . length () * LENGTH : 0 ; MST[NegateConditionalsMutator]MSP[N]
final int endIndex2 = beginIndex2 + otherLengthInBits / LENGTH ; final int length = Math . max ( endIndex1 , endIndex2 ) ; char k = 0 , f = 0 ; for ( int i = 0 ; i < length ; i ++ ) { MST[rv.ROR4Mutator]MSP[S]
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; MST[rv.UOI2Mutator]MSP[N] } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.ABSMutator]MSP[N]
private static int mask ( final int bit ) { return MSB >>> bit ; MST[rv.UOI4Mutator]MSP[N] } @Override public int bitsPerElement () { return LENGTH ; } @Override public int lengthInBits ( final String key ) { return key != null ? key . length () * LENGTH : 0 ;
final int endIndex2 = beginIndex2 + otherLengthInBits / LENGTH ; MST[rv.CRCR5Mutator]MSP[N] final int length = Math . max ( endIndex1 , endIndex2 ) ; char k = 0 , f = 0 ; for ( int i = 0 ; i < length ; i ++ ) {
public boolean isBitSet ( final String key , final int bitIndex , final int lengthInBits ) { if ( key == null || bitIndex >= lengthInBits ) { return false ; MST[ReturnValsMutator]MSP[N] } final int index = bitIndex / LENGTH ; final int bit = bitIndex % LENGTH ;
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.AOD2Mutator]MSP[N]
|| lengthInBits % LENGTH != 0 || otherLengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } final int beginIndex1 = offsetInBits / LENGTH ; final int beginIndex2 = otherOffsetInBits / LENGTH ; final int endIndex1 = beginIndex1 + lengthInBits / LENGTH ; MST[rv.CRCR3Mutator]MSP[N]
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { MST[rv.UOI4Mutator]MSP[N] throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; return key . startsWith ( s1 ) ; }
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { MST[rv.UOI2Mutator]MSP[N] throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; return key . startsWith ( s1 ) ; }
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; return key . startsWith ( s1 ) ; }
|| lengthInBits % LENGTH != 0 || otherLengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_1 ) ; MST[ConstructorCallMutator]MSP[S] } final int beginIndex1 = offsetInBits / LENGTH ; final int beginIndex2 = otherOffsetInBits / LENGTH ; final int endIndex1 = beginIndex1 + lengthInBits / LENGTH ;
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { MST[rv.AOR2Mutator]MSP[N] throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; return key . startsWith ( s1 ) ; }
private static int mask ( final int bit ) { return MSB >>> bit ; } @Override public int bitsPerElement () { return LENGTH ; } @Override public int lengthInBits ( final String key ) { return key != null ? key . length () * LENGTH : 0 ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[S]
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; MST[experimental.NakedReceiverMutator]MSP[S] return key . startsWith ( s1 ) ; }
|| lengthInBits % LENGTH != 0 || otherLengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } final int beginIndex1 = offsetInBits / LENGTH ; final int beginIndex2 = otherOffsetInBits / LENGTH ; MST[rv.CRCR6Mutator]MSP[N] final int endIndex1 = beginIndex1 + lengthInBits / LENGTH ;
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; } if ( k != 0 ) { allNull = false ; MST[rv.CRCR3Mutator]MSP[N] } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
if ( other == null || index2 >= endIndex2 ) { f = 0 ; } else { f = other . charAt ( index2 ) ; } if ( k != f ) { MST[rv.UOI3Mutator]MSP[S] final int x = k ^ f ;
public boolean isBitSet ( final String key , final int bitIndex , final int lengthInBits ) { if ( key == null || bitIndex >= lengthInBits ) { MST[rv.ROR5Mutator]MSP[S] return false ; } final int index = bitIndex / LENGTH ; final int bit = bitIndex % LENGTH ;
public boolean isBitSet ( final String key , final int bitIndex , final int lengthInBits ) { if ( key == null || bitIndex >= lengthInBits ) { return false ; } final int index = bitIndex / LENGTH ; MST[rv.UOI1Mutator]MSP[N] final int bit = bitIndex % LENGTH ;
public boolean isBitSet ( final String key , final int bitIndex , final int lengthInBits ) { if ( key == null || bitIndex >= lengthInBits ) { return false ; } final int index = bitIndex / LENGTH ; final int bit = bitIndex % LENGTH ; MST[rv.UOI3Mutator]MSP[N]
private static int mask ( final int bit ) { return MSB >>> bit ; } @Override public int bitsPerElement () { return LENGTH ; } @Override public int lengthInBits ( final String key ) { return key != null ? key . length () * LENGTH : 0 ; MST[rv.CRCR4Mutator]MSP[N]
final int endIndex2 = beginIndex2 + otherLengthInBits / LENGTH ; final int length = Math . max ( endIndex1 , endIndex2 ) ; MST[rv.UOI1Mutator]MSP[N] char k = 0 , f = 0 ; for ( int i = 0 ; i < length ; i ++ ) {
if ( other == null || index2 >= endIndex2 ) { MST[rv.UOI3Mutator]MSP[S] f = 0 ; } else { f = other . charAt ( index2 ) ; } if ( k != f ) { final int x = k ^ f ;
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; MST[rv.AOR3Mutator]MSP[N] } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; MST[rv.CRCR3Mutator]MSP[S] } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
private static int mask ( final int bit ) { return MSB >>> bit ; } @Override public int bitsPerElement () { return LENGTH ; MST[rv.CRCR2Mutator]MSP[N] } @Override public int lengthInBits ( final String key ) { return key != null ? key . length () * LENGTH : 0 ;
|| lengthInBits % LENGTH != 0 || otherLengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } final int beginIndex1 = offsetInBits / LENGTH ; final int beginIndex2 = otherOffsetInBits / LENGTH ; MST[rv.AOD1Mutator]MSP[N] final int endIndex1 = beginIndex1 + lengthInBits / LENGTH ;
|| lengthInBits % LENGTH != 0 || otherLengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } final int beginIndex1 = offsetInBits / LENGTH ; MST[rv.UOI2Mutator]MSP[N] final int beginIndex2 = otherOffsetInBits / LENGTH ; final int endIndex1 = beginIndex1 + lengthInBits / LENGTH ;
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[MathMutator]MSP[N]
final int endIndex2 = beginIndex2 + otherLengthInBits / LENGTH ; MST[rv.ABSMutator]MSP[N] final int length = Math . max ( endIndex1 , endIndex2 ) ; char k = 0 , f = 0 ; for ( int i = 0 ; i < length ; i ++ ) {
private static int mask ( final int bit ) { return MSB >>> bit ; MST[rv.ABSMutator]MSP[N] } @Override public int bitsPerElement () { return LENGTH ; } @Override public int lengthInBits ( final String key ) { return key != null ? key . length () * LENGTH : 0 ;
public boolean isBitSet ( final String key , final int bitIndex , final int lengthInBits ) { if ( key == null || bitIndex >= lengthInBits ) { return false ; MST[rv.CRCR6Mutator]MSP[N] } final int index = bitIndex / LENGTH ; final int bit = bitIndex % LENGTH ;
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[InlineConstantMutator]MSP[N]
|| lengthInBits % LENGTH != 0 || otherLengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } final int beginIndex1 = offsetInBits / LENGTH ; final int beginIndex2 = otherOffsetInBits / LENGTH ; final int endIndex1 = beginIndex1 + lengthInBits / LENGTH ; MST[rv.UOI1Mutator]MSP[N]
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; MST[rv.CRCR4Mutator]MSP[N] if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0
|| lengthInBits % LENGTH != 0 || otherLengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } final int beginIndex1 = offsetInBits / LENGTH ; final int beginIndex2 = otherOffsetInBits / LENGTH ; MST[rv.UOI4Mutator]MSP[S] final int endIndex1 = beginIndex1 + lengthInBits / LENGTH ;
final int endIndex2 = beginIndex2 + otherLengthInBits / LENGTH ; MST[rv.AOD1Mutator]MSP[N] final int length = Math . max ( endIndex1 , endIndex2 ) ; char k = 0 , f = 0 ; for ( int i = 0 ; i < length ; i ++ ) {
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.ROR3Mutator]MSP[S]
final int index1 = beginIndex1 + i ; MST[rv.UOI3Mutator]MSP[N] final int index2 = beginIndex2 + i ; if ( index1 >= endIndex1 ) { k = 0 ; } else { k = key . charAt ( index1 ) ; }
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; MST[InlineConstantMutator]MSP[S] } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; MST[rv.ABSMutator]MSP[N] return key . startsWith ( s1 ) ; }
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; MST[rv.CRCR2Mutator]MSP[S] } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
final int index1 = beginIndex1 + i ; final int index2 = beginIndex2 + i ; if ( index1 >= endIndex1 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] k = 0 ; } else { k = key . charAt ( index1 ) ; }
final int endIndex2 = beginIndex2 + otherLengthInBits / LENGTH ; MST[rv.AOR4Mutator]MSP[N] final int length = Math . max ( endIndex1 , endIndex2 ) ; char k = 0 , f = 0 ; for ( int i = 0 ; i < length ; i ++ ) {
final int index1 = beginIndex1 + i ; final int index2 = beginIndex2 + i ; if ( index1 >= endIndex1 ) { MST[NegateConditionalsMutator]MSP[N] k = 0 ; } else { k = key . charAt ( index1 ) ; }
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { MST[rv.CRCR5Mutator]MSP[N] throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; return key . startsWith ( s1 ) ; }
public boolean isBitSet ( final String key , final int bitIndex , final int lengthInBits ) { if ( key == null || bitIndex >= lengthInBits ) { return false ; } final int index = bitIndex / LENGTH ; final int bit = bitIndex % LENGTH ; MST[rv.AOR3Mutator]MSP[S]
|| lengthInBits % LENGTH != 0 || otherLengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } final int beginIndex1 = offsetInBits / LENGTH ; final int beginIndex2 = otherOffsetInBits / LENGTH ; final int endIndex1 = beginIndex1 + lengthInBits / LENGTH ; MST[MathMutator]MSP[N]
public boolean isBitSet ( final String key , final int bitIndex , final int lengthInBits ) { if ( key == null || bitIndex >= lengthInBits ) { MST[rv.UOI3Mutator]MSP[S] return false ; } final int index = bitIndex / LENGTH ; final int bit = bitIndex % LENGTH ;
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.UOI4Mutator]MSP[N]
return ( key . charAt ( index ) & mask ( bit ) ) != 0 ; MST[InlineConstantMutator]MSP[N] } @Override public boolean isPrefix ( final String prefix , final int offsetInBits , final int lengthInBits , final String key ) {
public boolean isBitSet ( final String key , final int bitIndex , final int lengthInBits ) { if ( key == null || bitIndex >= lengthInBits ) { return false ; } final int index = bitIndex / LENGTH ; MST[rv.AOR1Mutator]MSP[S] final int bit = bitIndex % LENGTH ;
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { MST[rv.ABSMutator]MSP[N] throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; return key . startsWith ( s1 ) ; }
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.AOR4Mutator]MSP[N]
final int endIndex2 = beginIndex2 + otherLengthInBits / LENGTH ; final int length = Math . max ( endIndex1 , endIndex2 ) ; char k = 0 , f = 0 ; for ( int i = 0 ; i < length ; i ++ ) { MST[rv.UOI1Mutator]MSP[N]
if ( other == null || index2 >= endIndex2 ) { f = 0 ; } else { f = other . charAt ( index2 ) ; } if ( k != f ) { MST[rv.ABSMutator]MSP[S] final int x = k ^ f ;
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; MST[rv.CRCR6Mutator]MSP[S] return key . startsWith ( s1 ) ; }
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; MST[rv.CRCR5Mutator]MSP[N] return key . startsWith ( s1 ) ; }
return ( key . charAt ( index ) & mask ( bit ) ) != 0 ; MST[rv.CRCR3Mutator]MSP[N] } @Override public boolean isPrefix ( final String prefix , final int offsetInBits , final int lengthInBits , final String key ) {
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { MST[rv.ROR2Mutator]MSP[N] return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
final int endIndex2 = beginIndex2 + otherLengthInBits / LENGTH ; final int length = Math . max ( endIndex1 , endIndex2 ) ; MST[rv.UOI2Mutator]MSP[N] char k = 0 , f = 0 ; for ( int i = 0 ; i < length ; i ++ ) {
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; MST[rv.CRCR4Mutator]MSP[N] } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
if ( other == null || index2 >= endIndex2 ) { MST[rv.UOI3Mutator]MSP[S] f = 0 ; } else { f = other . charAt ( index2 ) ; } if ( k != f ) { final int x = k ^ f ;
final int endIndex2 = beginIndex2 + otherLengthInBits / LENGTH ; MST[rv.UOI4Mutator]MSP[N] final int length = Math . max ( endIndex1 , endIndex2 ) ; char k = 0 , f = 0 ; for ( int i = 0 ; i < length ; i ++ ) {
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; MST[rv.CRCR6Mutator]MSP[S] } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
final int endIndex2 = beginIndex2 + otherLengthInBits / LENGTH ; MST[rv.AOR1Mutator]MSP[S] final int length = Math . max ( endIndex1 , endIndex2 ) ; char k = 0 , f = 0 ; for ( int i = 0 ; i < length ; i ++ ) {
private static int mask ( final int bit ) { return MSB >>> bit ; } @Override public int bitsPerElement () { return LENGTH ; } @Override public int lengthInBits ( final String key ) { return key != null ? key . length () * LENGTH : 0 ; MST[rv.AOR4Mutator]MSP[N]
return ( key . charAt ( index ) & mask ( bit ) ) != 0 ; MST[rv.UOI1Mutator]MSP[N] } @Override public boolean isPrefix ( final String prefix , final int offsetInBits , final int lengthInBits , final String key ) {
final int endIndex2 = beginIndex2 + otherLengthInBits / LENGTH ; final int length = Math . max ( endIndex1 , endIndex2 ) ; char k = 0 , f = 0 ; for ( int i = 0 ; i < length ; i ++ ) { MST[rv.CRCR5Mutator]MSP[N]
final int endIndex2 = beginIndex2 + otherLengthInBits / LENGTH ; final int length = Math . max ( endIndex1 , endIndex2 ) ; char k = 0 , f = 0 ; for ( int i = 0 ; i < length ; i ++ ) { MST[rv.CRCR1Mutator]MSP[N]
|| lengthInBits % LENGTH != 0 || otherLengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } final int beginIndex1 = offsetInBits / LENGTH ; MST[rv.AOR4Mutator]MSP[N] final int beginIndex2 = otherOffsetInBits / LENGTH ; final int endIndex1 = beginIndex1 + lengthInBits / LENGTH ;
final int index1 = beginIndex1 + i ; final int index2 = beginIndex2 + i ; if ( index1 >= endIndex1 ) { k = 0 ; } else { k = key . charAt ( index1 ) ; MST[rv.UOI1Mutator]MSP[N] }
|| lengthInBits % LENGTH != 0 || otherLengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } final int beginIndex1 = offsetInBits / LENGTH ; final int beginIndex2 = otherOffsetInBits / LENGTH ; final int endIndex1 = beginIndex1 + lengthInBits / LENGTH ; MST[rv.UOI2Mutator]MSP[N]
|| lengthInBits % LENGTH != 0 || otherLengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } final int beginIndex1 = offsetInBits / LENGTH ; final int beginIndex2 = otherOffsetInBits / LENGTH ; final int endIndex1 = beginIndex1 + lengthInBits / LENGTH ; MST[rv.ABSMutator]MSP[N]
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.ROR2Mutator]MSP[N]
if ( other == null || index2 >= endIndex2 ) { f = 0 ; } else { f = other . charAt ( index2 ) ; } if ( k != f ) { MST[rv.ROR1Mutator]MSP[N] final int x = k ^ f ;
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { MST[rv.CRCR6Mutator]MSP[N] throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; return key . startsWith ( s1 ) ; }
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; MST[rv.UOI3Mutator]MSP[N] return key . startsWith ( s1 ) ; }
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[NegateConditionalsMutator]MSP[N]
public boolean isBitSet ( final String key , final int bitIndex , final int lengthInBits ) { if ( key == null || bitIndex >= lengthInBits ) { return false ; } final int index = bitIndex / LENGTH ; MST[rv.AOD1Mutator]MSP[S] final int bit = bitIndex % LENGTH ;
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.ROR4Mutator]MSP[N]
final int index1 = beginIndex1 + i ; MST[rv.UOI3Mutator]MSP[N] final int index2 = beginIndex2 + i ; if ( index1 >= endIndex1 ) { k = 0 ; } else { k = key . charAt ( index1 ) ; }
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; } if ( k != 0 ) { allNull = false ; MST[InlineConstantMutator]MSP[N] } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.UOI3Mutator]MSP[N]
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { MST[rv.CRCR2Mutator]MSP[N] throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; return key . startsWith ( s1 ) ; }
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { MST[rv.ROR3Mutator]MSP[S] throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; return key . startsWith ( s1 ) ; }
private static int mask ( final int bit ) { return MSB >>> bit ; } @Override public int bitsPerElement () { return LENGTH ; MST[ReturnValsMutator]MSP[N] } @Override public int lengthInBits ( final String key ) { return key != null ? key . length () * LENGTH : 0 ;
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; MST[MathMutator]MSP[N] return key . startsWith ( s1 ) ; }
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; MST[rv.UOI3Mutator]MSP[N] } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
public boolean isBitSet ( final String key , final int bitIndex , final int lengthInBits ) { if ( key == null || bitIndex >= lengthInBits ) { return false ; } final int index = bitIndex / LENGTH ; MST[rv.CRCR2Mutator]MSP[S] final int bit = bitIndex % LENGTH ;
public boolean isBitSet ( final String key , final int bitIndex , final int lengthInBits ) { if ( key == null || bitIndex >= lengthInBits ) { return false ; } final int index = bitIndex / LENGTH ; MST[rv.CRCR6Mutator]MSP[N] final int bit = bitIndex % LENGTH ;
final int endIndex2 = beginIndex2 + otherLengthInBits / LENGTH ; final int length = Math . max ( endIndex1 , endIndex2 ) ; MST[rv.ABSMutator]MSP[S] char k = 0 , f = 0 ; for ( int i = 0 ; i < length ; i ++ ) {
public boolean isBitSet ( final String key , final int bitIndex , final int lengthInBits ) { if ( key == null || bitIndex >= lengthInBits ) { MST[rv.UOI3Mutator]MSP[N] return false ; } final int index = bitIndex / LENGTH ; final int bit = bitIndex % LENGTH ;
|| lengthInBits % LENGTH != 0 || otherLengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } final int beginIndex1 = offsetInBits / LENGTH ; final int beginIndex2 = otherOffsetInBits / LENGTH ; final int endIndex1 = beginIndex1 + lengthInBits / LENGTH ; MST[InlineConstantMutator]MSP[N]
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { MST[rv.AOD1Mutator]MSP[N] throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; return key . startsWith ( s1 ) ; }
if ( other == null || index2 >= endIndex2 ) { f = 0 ; } else { f = other . charAt ( index2 ) ; } if ( k != f ) { final int x = k ^ f ; MST[rv.UOI1Mutator]MSP[N]
if ( other == null || index2 >= endIndex2 ) { f = 0 ; } else { f = other . charAt ( index2 ) ; } if ( k != f ) { MST[rv.UOI4Mutator]MSP[S] final int x = k ^ f ;
final int endIndex2 = beginIndex2 + otherLengthInBits / LENGTH ; final int length = Math . max ( endIndex1 , endIndex2 ) ; MST[NonVoidMethodCallMutator]MSP[N] char k = 0 , f = 0 ; for ( int i = 0 ; i < length ; i ++ ) {
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.UOI1Mutator]MSP[N]
if ( other == null || index2 >= endIndex2 ) { f = 0 ; } else { f = other . charAt ( index2 ) ; } if ( k != f ) { MST[rv.ROR5Mutator]MSP[N] final int x = k ^ f ;
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.AOR1Mutator]MSP[N]
private static int mask ( final int bit ) { return MSB >>> bit ; } @Override public int bitsPerElement () { return LENGTH ; } @Override public int lengthInBits ( final String key ) { return key != null ? key . length () * LENGTH : 0 ; MST[rv.CRCR3Mutator]MSP[N]
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.AOR3Mutator]MSP[N]
public boolean isBitSet ( final String key , final int bitIndex , final int lengthInBits ) { if ( key == null || bitIndex >= lengthInBits ) { return false ; } final int index = bitIndex / LENGTH ; MST[InlineConstantMutator]MSP[N] final int bit = bitIndex % LENGTH ;
return ( key . charAt ( index ) & mask ( bit ) ) != 0 ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } @Override public boolean isPrefix ( final String prefix , final int offsetInBits , final int lengthInBits , final String key ) {
final int endIndex2 = beginIndex2 + otherLengthInBits / LENGTH ; MST[rv.UOI4Mutator]MSP[N] final int length = Math . max ( endIndex1 , endIndex2 ) ; char k = 0 , f = 0 ; for ( int i = 0 ; i < length ; i ++ ) {
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; MST[rv.AOR1Mutator]MSP[N] } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
final int endIndex2 = beginIndex2 + otherLengthInBits / LENGTH ; MST[rv.AOR1Mutator]MSP[N] final int length = Math . max ( endIndex1 , endIndex2 ) ; char k = 0 , f = 0 ; for ( int i = 0 ; i < length ; i ++ ) {
|| lengthInBits % LENGTH != 0 || otherLengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } final int beginIndex1 = offsetInBits / LENGTH ; MST[rv.UOI3Mutator]MSP[N] final int beginIndex2 = otherOffsetInBits / LENGTH ; final int endIndex1 = beginIndex1 + lengthInBits / LENGTH ;
final int index1 = beginIndex1 + i ; final int index2 = beginIndex2 + i ; if ( index1 >= endIndex1 ) { MST[rv.UOI2Mutator]MSP[N] k = 0 ; } else { k = key . charAt ( index1 ) ; }
public boolean isBitSet ( final String key , final int bitIndex , final int lengthInBits ) { if ( key == null || bitIndex >= lengthInBits ) { return false ; MST[rv.CRCR1Mutator]MSP[N] } final int index = bitIndex / LENGTH ; final int bit = bitIndex % LENGTH ;
public boolean isBitSet ( final String key , final int bitIndex , final int lengthInBits ) { if ( key == null || bitIndex >= lengthInBits ) { return false ; MST[rv.CRCR5Mutator]MSP[N] } final int index = bitIndex / LENGTH ; final int bit = bitIndex % LENGTH ;
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; MST[rv.CRCR3Mutator]MSP[N] if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0
|| lengthInBits % LENGTH != 0 || otherLengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } final int beginIndex1 = offsetInBits / LENGTH ; final int beginIndex2 = otherOffsetInBits / LENGTH ; final int endIndex1 = beginIndex1 + lengthInBits / LENGTH ; MST[rv.AOD2Mutator]MSP[S]
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; MST[PrimitiveReturnsMutator]MSP[S] } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; MST[rv.AOR4Mutator]MSP[N] return key . startsWith ( s1 ) ; }
private static int mask ( final int bit ) { return MSB >>> bit ; } @Override public int bitsPerElement () { return LENGTH ; MST[rv.CRCR1Mutator]MSP[N] } @Override public int lengthInBits ( final String key ) { return key != null ? key . length () * LENGTH : 0 ;
private static int mask ( final int bit ) { return MSB >>> bit ; } @Override public int bitsPerElement () { return LENGTH ; MST[rv.CRCR5Mutator]MSP[N] } @Override public int lengthInBits ( final String key ) { return key != null ? key . length () * LENGTH : 0 ;
final int endIndex2 = beginIndex2 + otherLengthInBits / LENGTH ; final int length = Math . max ( endIndex1 , endIndex2 ) ; char k = 0 , f = 0 ; MST[rv.CRCR3Mutator]MSP[N] for ( int i = 0 ; i < length ; i ++ ) {
|| lengthInBits % LENGTH != 0 || otherLengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } final int beginIndex1 = offsetInBits / LENGTH ; MST[MathMutator]MSP[N] final int beginIndex2 = otherOffsetInBits / LENGTH ; final int endIndex1 = beginIndex1 + lengthInBits / LENGTH ;
|| lengthInBits % LENGTH != 0 || otherLengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } final int beginIndex1 = offsetInBits / LENGTH ; final int beginIndex2 = otherOffsetInBits / LENGTH ; MST[rv.AOR1Mutator]MSP[N] final int endIndex1 = beginIndex1 + lengthInBits / LENGTH ;
if ( other == null || index2 >= endIndex2 ) { f = 0 ; MST[rv.CRCR1Mutator]MSP[N] } else { f = other . charAt ( index2 ) ; } if ( k != f ) { final int x = k ^ f ;
|| lengthInBits % LENGTH != 0 || otherLengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } final int beginIndex1 = offsetInBits / LENGTH ; final int beginIndex2 = otherOffsetInBits / LENGTH ; final int endIndex1 = beginIndex1 + lengthInBits / LENGTH ; MST[rv.AOR3Mutator]MSP[N]
final int endIndex2 = beginIndex2 + otherLengthInBits / LENGTH ; final int length = Math . max ( endIndex1 , endIndex2 ) ; char k = 0 , f = 0 ; for ( int i = 0 ; i < length ; i ++ ) { MST[rv.ROR3Mutator]MSP[N]
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; MST[InlineConstantMutator]MSP[N] return key . startsWith ( s1 ) ; }
return ( key . charAt ( index ) & mask ( bit ) ) != 0 ; MST[rv.ROR3Mutator]MSP[S] } @Override public boolean isPrefix ( final String prefix , final int offsetInBits , final int lengthInBits , final String key ) {
private static int mask ( final int bit ) { return MSB >>> bit ; } @Override public int bitsPerElement () { return LENGTH ; } @Override public int lengthInBits ( final String key ) { return key != null ? key . length () * LENGTH : 0 ; MST[MathMutator]MSP[N]
if ( other == null || index2 >= endIndex2 ) { f = 0 ; MST[rv.CRCR5Mutator]MSP[N] } else { f = other . charAt ( index2 ) ; } if ( k != f ) { final int x = k ^ f ;
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; } if ( k != 0 ) { MST[rv.UOI1Mutator]MSP[N] allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
final int index1 = beginIndex1 + i ; final int index2 = beginIndex2 + i ; if ( index1 >= endIndex1 ) { MST[rv.UOI2Mutator]MSP[N] k = 0 ; } else { k = key . charAt ( index1 ) ; }
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; MST[rv.CRCR3Mutator]MSP[N] } @Override
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.ROR5Mutator]MSP[N]
|| lengthInBits % LENGTH != 0 || otherLengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } final int beginIndex1 = offsetInBits / LENGTH ; final int beginIndex2 = otherOffsetInBits / LENGTH ; final int endIndex1 = beginIndex1 + lengthInBits / LENGTH ; MST[rv.CRCR2Mutator]MSP[N]
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { MST[rv.CRCR3Mutator]MSP[S] throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; return key . startsWith ( s1 ) ; }
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.ROR1Mutator]MSP[N]
private static int mask ( final int bit ) { return MSB >>> bit ; } @Override public int bitsPerElement () { return LENGTH ; } @Override public int lengthInBits ( final String key ) { return key != null ? key . length () * LENGTH : 0 ; MST[ReturnValsMutator]MSP[N]
|| lengthInBits % LENGTH != 0 || otherLengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } final int beginIndex1 = offsetInBits / LENGTH ; final int beginIndex2 = otherOffsetInBits / LENGTH ; MST[rv.CRCR1Mutator]MSP[N] final int endIndex1 = beginIndex1 + lengthInBits / LENGTH ;
|| lengthInBits % LENGTH != 0 || otherLengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } final int beginIndex1 = offsetInBits / LENGTH ; final int beginIndex2 = otherOffsetInBits / LENGTH ; final int endIndex1 = beginIndex1 + lengthInBits / LENGTH ; MST[rv.CRCR6Mutator]MSP[N]
final int index1 = beginIndex1 + i ; final int index2 = beginIndex2 + i ; if ( index1 >= endIndex1 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] k = 0 ; } else { k = key . charAt ( index1 ) ; }
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { MST[rv.AOR3Mutator]MSP[N] throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; return key . startsWith ( s1 ) ; }
if ( other == null || index2 >= endIndex2 ) { f = 0 ; } else { f = other . charAt ( index2 ) ; MST[rv.UOI2Mutator]MSP[N] } if ( k != f ) { final int x = k ^ f ;
if ( other == null || index2 >= endIndex2 ) { f = 0 ; } else { f = other . charAt ( index2 ) ; } if ( k != f ) { MST[NegateConditionalsMutator]MSP[N] final int x = k ^ f ;
public boolean isBitSet ( final String key , final int bitIndex , final int lengthInBits ) { if ( key == null || bitIndex >= lengthInBits ) { return false ; } final int index = bitIndex / LENGTH ; MST[rv.AOR3Mutator]MSP[S] final int bit = bitIndex % LENGTH ;
|| lengthInBits % LENGTH != 0 || otherLengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } final int beginIndex1 = offsetInBits / LENGTH ; final int beginIndex2 = otherOffsetInBits / LENGTH ; MST[rv.CRCR5Mutator]MSP[S] final int endIndex1 = beginIndex1 + lengthInBits / LENGTH ;
|| lengthInBits % LENGTH != 0 || otherLengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } final int beginIndex1 = offsetInBits / LENGTH ; MST[rv.CRCR3Mutator]MSP[N] final int beginIndex2 = otherOffsetInBits / LENGTH ; final int endIndex1 = beginIndex1 + lengthInBits / LENGTH ;
final int endIndex2 = beginIndex2 + otherLengthInBits / LENGTH ; final int length = Math . max ( endIndex1 , endIndex2 ) ; char k = 0 , f = 0 ; for ( int i = 0 ; i < length ; i ++ ) { MST[rv.UOI2Mutator]MSP[N]
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; MST[rv.AOD2Mutator]MSP[S] } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.UOI2Mutator]MSP[N]
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; MST[rv.CRCR4Mutator]MSP[N] return key . startsWith ( s1 ) ; }
if ( other == null || index2 >= endIndex2 ) { f = 0 ; } else { f = other . charAt ( index2 ) ; MST[NonVoidMethodCallMutator]MSP[N] } if ( k != f ) { final int x = k ^ f ;
if ( other == null || index2 >= endIndex2 ) { f = 0 ; } else { f = other . charAt ( index2 ) ; } if ( k != f ) { MST[rv.UOI4Mutator]MSP[N] final int x = k ^ f ;
private static int mask ( final int bit ) { return MSB >>> bit ; } @Override public int bitsPerElement () { return LENGTH ; } @Override public int lengthInBits ( final String key ) { return key != null ? key . length () * LENGTH : 0 ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.AOR2Mutator]MSP[N]
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; MST[rv.CRCR3Mutator]MSP[N] return key . startsWith ( s1 ) ; }
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; MST[rv.AOR3Mutator]MSP[N] } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
public boolean isBitSet ( final String key , final int bitIndex , final int lengthInBits ) { if ( key == null || bitIndex >= lengthInBits ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] return false ; } final int index = bitIndex / LENGTH ; final int bit = bitIndex % LENGTH ;
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.CRCR3Mutator]MSP[N]
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.CRCR2Mutator]MSP[N]
if ( other == null || index2 >= endIndex2 ) { MST[rv.ROR4Mutator]MSP[N] f = 0 ; } else { f = other . charAt ( index2 ) ; } if ( k != f ) { final int x = k ^ f ;
private static int mask ( final int bit ) { return MSB >>> bit ; MST[rv.CRCR6Mutator]MSP[N] } @Override public int bitsPerElement () { return LENGTH ; } @Override public int lengthInBits ( final String key ) { return key != null ? key . length () * LENGTH : 0 ;
private static int mask ( final int bit ) { return MSB >>> bit ; MST[rv.CRCR1Mutator]MSP[N] } @Override public int bitsPerElement () { return LENGTH ; } @Override public int lengthInBits ( final String key ) { return key != null ? key . length () * LENGTH : 0 ;
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.CRCR1Mutator]MSP[N]
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; } if ( k != 0 ) { MST[rv.ABSMutator]MSP[N] allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
if ( other == null || index2 >= endIndex2 ) { MST[rv.ROR1Mutator]MSP[S] f = 0 ; } else { f = other . charAt ( index2 ) ; } if ( k != f ) { final int x = k ^ f ;
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.CRCR5Mutator]MSP[N]
return ( key . charAt ( index ) & mask ( bit ) ) != 0 ; MST[rv.UOI2Mutator]MSP[N] } @Override public boolean isPrefix ( final String prefix , final int offsetInBits , final int lengthInBits , final String key ) {
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.CRCR6Mutator]MSP[N]
|| lengthInBits % LENGTH != 0 || otherLengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } final int beginIndex1 = offsetInBits / LENGTH ; final int beginIndex2 = otherOffsetInBits / LENGTH ; final int endIndex1 = beginIndex1 + lengthInBits / LENGTH ; MST[rv.AOD2Mutator]MSP[N]
final int index1 = beginIndex1 + i ; final int index2 = beginIndex2 + i ; if ( index1 >= endIndex1 ) { MST[rv.ROR3Mutator]MSP[N] k = 0 ; } else { k = key . charAt ( index1 ) ; }
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { MST[InlineConstantMutator]MSP[N] throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; return key . startsWith ( s1 ) ; }
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.CRCR4Mutator]MSP[N]
return ( key . charAt ( index ) & mask ( bit ) ) != 0 ; MST[NonVoidMethodCallMutator]MSP[N] } @Override public boolean isPrefix ( final String prefix , final int offsetInBits , final int lengthInBits , final String key ) {
private static int mask ( final int bit ) { return MSB >>> bit ; MST[rv.UOI2Mutator]MSP[N] } @Override public int bitsPerElement () { return LENGTH ; } @Override public int lengthInBits ( final String key ) { return key != null ? key . length () * LENGTH : 0 ;
final int endIndex2 = beginIndex2 + otherLengthInBits / LENGTH ; MST[rv.CRCR1Mutator]MSP[N] final int length = Math . max ( endIndex1 , endIndex2 ) ; char k = 0 , f = 0 ; for ( int i = 0 ; i < length ; i ++ ) {
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; MST[rv.UOI2Mutator]MSP[N] return key . startsWith ( s1 ) ; }
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.ABSMutator]MSP[N]
|| lengthInBits % LENGTH != 0 || otherLengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } final int beginIndex1 = offsetInBits / LENGTH ; final int beginIndex2 = otherOffsetInBits / LENGTH ; final int endIndex1 = beginIndex1 + lengthInBits / LENGTH ; MST[rv.AOR3Mutator]MSP[N]
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; } if ( k != 0 ) { MST[rv.UOI2Mutator]MSP[N] allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
final int endIndex2 = beginIndex2 + otherLengthInBits / LENGTH ; final int length = Math . max ( endIndex1 , endIndex2 ) ; char k = 0 , f = 0 ; for ( int i = 0 ; i < length ; i ++ ) { MST[ConditionalsBoundaryMutator]MSP[N]
public boolean isBitSet ( final String key , final int bitIndex , final int lengthInBits ) { if ( key == null || bitIndex >= lengthInBits ) { return false ; } final int index = bitIndex / LENGTH ; final int bit = bitIndex % LENGTH ; MST[rv.AOR4Mutator]MSP[S]
final int index1 = beginIndex1 + i ; final int index2 = beginIndex2 + i ; MST[rv.AOR1Mutator]MSP[S] if ( index1 >= endIndex1 ) { k = 0 ; } else { k = key . charAt ( index1 ) ; }
final int index1 = beginIndex1 + i ; final int index2 = beginIndex2 + i ; MST[rv.UOI1Mutator]MSP[N] if ( index1 >= endIndex1 ) { k = 0 ; } else { k = key . charAt ( index1 ) ; }
public boolean isBitSet ( final String key , final int bitIndex , final int lengthInBits ) { if ( key == null || bitIndex >= lengthInBits ) { MST[rv.UOI4Mutator]MSP[N] return false ; } final int index = bitIndex / LENGTH ; final int bit = bitIndex % LENGTH ;
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { MST[rv.UOI2Mutator]MSP[N] throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; return key . startsWith ( s1 ) ; }
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; MST[InlineConstantMutator]MSP[S] } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.AOD2Mutator]MSP[N]
final int index1 = beginIndex1 + i ; final int index2 = beginIndex2 + i ; if ( index1 >= endIndex1 ) { k = 0 ; MST[rv.CRCR3Mutator]MSP[N] } else { k = key . charAt ( index1 ) ; }
private static int mask ( final int bit ) { return MSB >>> bit ; } @Override public int bitsPerElement () { return LENGTH ; } @Override public int lengthInBits ( final String key ) { return key != null ? key . length () * LENGTH : 0 ; MST[rv.CRCR1Mutator]MSP[S]
|| lengthInBits % LENGTH != 0 || otherLengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } final int beginIndex1 = offsetInBits / LENGTH ; final int beginIndex2 = otherOffsetInBits / LENGTH ; MST[rv.CRCR4Mutator]MSP[N] final int endIndex1 = beginIndex1 + lengthInBits / LENGTH ;
public boolean isBitSet ( final String key , final int bitIndex , final int lengthInBits ) { if ( key == null || bitIndex >= lengthInBits ) { MST[rv.ROR1Mutator]MSP[S] return false ; } final int index = bitIndex / LENGTH ; final int bit = bitIndex % LENGTH ;
if ( other == null || index2 >= endIndex2 ) { f = 0 ; } else { f = other . charAt ( index2 ) ; } if ( k != f ) { final int x = k ^ f ; MST[rv.ABSMutator]MSP[N]
return ( key . charAt ( index ) & mask ( bit ) ) != 0 ; MST[rv.CRCR2Mutator]MSP[N] } @Override public boolean isPrefix ( final String prefix , final int offsetInBits , final int lengthInBits , final String key ) {
public boolean isBitSet ( final String key , final int bitIndex , final int lengthInBits ) { if ( key == null || bitIndex >= lengthInBits ) { return false ; } final int index = bitIndex / LENGTH ; final int bit = bitIndex % LENGTH ; MST[rv.UOI4Mutator]MSP[N]
if ( other == null || index2 >= endIndex2 ) { MST[NegateConditionalsMutator]MSP[N] f = 0 ; } else { f = other . charAt ( index2 ) ; } if ( k != f ) { final int x = k ^ f ;
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.AOR4Mutator]MSP[N]
public boolean isBitSet ( final String key , final int bitIndex , final int lengthInBits ) { if ( key == null || bitIndex >= lengthInBits ) { return false ; } final int index = bitIndex / LENGTH ; MST[rv.UOI2Mutator]MSP[N] final int bit = bitIndex % LENGTH ;
private static int mask ( final int bit ) { return MSB >>> bit ; MST[PrimitiveReturnsMutator]MSP[N] } @Override public int bitsPerElement () { return LENGTH ; } @Override public int lengthInBits ( final String key ) { return key != null ? key . length () * LENGTH : 0 ;
if ( other == null || index2 >= endIndex2 ) { f = 0 ; } else { f = other . charAt ( index2 ) ; MST[rv.UOI3Mutator]MSP[S] } if ( k != f ) { final int x = k ^ f ;
final int index1 = beginIndex1 + i ; MST[rv.AOR4Mutator]MSP[N] final int index2 = beginIndex2 + i ; if ( index1 >= endIndex1 ) { k = 0 ; } else { k = key . charAt ( index1 ) ; }
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; MST[rv.AOR4Mutator]MSP[N] } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
final int endIndex2 = beginIndex2 + otherLengthInBits / LENGTH ; final int length = Math . max ( endIndex1 , endIndex2 ) ; MST[rv.UOI2Mutator]MSP[N] char k = 0 , f = 0 ; for ( int i = 0 ; i < length ; i ++ ) {
if ( other == null || index2 >= endIndex2 ) { MST[rv.UOI4Mutator]MSP[N] f = 0 ; } else { f = other . charAt ( index2 ) ; } if ( k != f ) { final int x = k ^ f ;
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; MST[rv.AOR1Mutator]MSP[N] } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; MST[rv.AOD2Mutator]MSP[N] return key . startsWith ( s1 ) ; }
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; MST[rv.CRCR2Mutator]MSP[S] } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
if ( other == null || index2 >= endIndex2 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] f = 0 ; } else { f = other . charAt ( index2 ) ; } if ( k != f ) { final int x = k ^ f ;
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[MathMutator]MSP[N]
|| lengthInBits % LENGTH != 0 || otherLengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } final int beginIndex1 = offsetInBits / LENGTH ; final int beginIndex2 = otherOffsetInBits / LENGTH ; final int endIndex1 = beginIndex1 + lengthInBits / LENGTH ; MST[rv.UOI2Mutator]MSP[N]
public boolean isBitSet ( final String key , final int bitIndex , final int lengthInBits ) { if ( key == null || bitIndex >= lengthInBits ) { return false ; } final int index = bitIndex / LENGTH ; final int bit = bitIndex % LENGTH ; MST[MathMutator]MSP[N]
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { MST[rv.UOI1Mutator]MSP[N] return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[InlineConstantMutator]MSP[N]
final int index1 = beginIndex1 + i ; final int index2 = beginIndex2 + i ; if ( index1 >= endIndex1 ) { k = 0 ; } else { k = key . charAt ( index1 ) ; MST[rv.ABSMutator]MSP[N] }
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; MST[MathMutator]MSP[N] } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
private static int mask ( final int bit ) { return MSB >>> bit ; } @Override public int bitsPerElement () { return LENGTH ; MST[rv.CRCR6Mutator]MSP[N] } @Override public int lengthInBits ( final String key ) { return key != null ? key . length () * LENGTH : 0 ;
final int index1 = beginIndex1 + i ; MST[MathMutator]MSP[N] final int index2 = beginIndex2 + i ; if ( index1 >= endIndex1 ) { k = 0 ; } else { k = key . charAt ( index1 ) ; }
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { MST[rv.CRCR5Mutator]MSP[N] throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; return key . startsWith ( s1 ) ; }
public boolean isBitSet ( final String key , final int bitIndex , final int lengthInBits ) { if ( key == null || bitIndex >= lengthInBits ) { return false ; } final int index = bitIndex / LENGTH ; final int bit = bitIndex % LENGTH ; MST[rv.CRCR3Mutator]MSP[N]
if ( other == null || index2 >= endIndex2 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] f = 0 ; } else { f = other . charAt ( index2 ) ; } if ( k != f ) { final int x = k ^ f ;
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.ROR3Mutator]MSP[N]
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.UOI4Mutator]MSP[N]
public boolean isBitSet ( final String key , final int bitIndex , final int lengthInBits ) { if ( key == null || bitIndex >= lengthInBits ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] return false ; } final int index = bitIndex / LENGTH ; final int bit = bitIndex % LENGTH ;
final int index1 = beginIndex1 + i ; final int index2 = beginIndex2 + i ; if ( index1 >= endIndex1 ) { MST[rv.UOI3Mutator]MSP[N] k = 0 ; } else { k = key . charAt ( index1 ) ; }
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; MST[rv.UOI3Mutator]MSP[N] } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
final int index1 = beginIndex1 + i ; MST[rv.UOI4Mutator]MSP[N] final int index2 = beginIndex2 + i ; if ( index1 >= endIndex1 ) { k = 0 ; } else { k = key . charAt ( index1 ) ; }
public boolean isBitSet ( final String key , final int bitIndex , final int lengthInBits ) { if ( key == null || bitIndex >= lengthInBits ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return false ; } final int index = bitIndex / LENGTH ; final int bit = bitIndex % LENGTH ;
final int endIndex2 = beginIndex2 + otherLengthInBits / LENGTH ; MST[rv.CRCR4Mutator]MSP[N] final int length = Math . max ( endIndex1 , endIndex2 ) ; char k = 0 , f = 0 ; for ( int i = 0 ; i < length ; i ++ ) {
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; MST[rv.UOI4Mutator]MSP[N] } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
final int index1 = beginIndex1 + i ; final int index2 = beginIndex2 + i ; MST[rv.UOI1Mutator]MSP[N] if ( index1 >= endIndex1 ) { k = 0 ; } else { k = key . charAt ( index1 ) ; }
final int index1 = beginIndex1 + i ; final int index2 = beginIndex2 + i ; MST[rv.ABSMutator]MSP[S] if ( index1 >= endIndex1 ) { k = 0 ; } else { k = key . charAt ( index1 ) ; }
public boolean isBitSet ( final String key , final int bitIndex , final int lengthInBits ) { if ( key == null || bitIndex >= lengthInBits ) { MST[rv.UOI4Mutator]MSP[S] return false ; } final int index = bitIndex / LENGTH ; final int bit = bitIndex % LENGTH ;
return ( key . charAt ( index ) & mask ( bit ) ) != 0 ; MST[rv.CRCR3Mutator]MSP[S] } @Override public boolean isPrefix ( final String prefix , final int offsetInBits , final int lengthInBits , final String key ) {
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.AOD1Mutator]MSP[N]
public boolean isBitSet ( final String key , final int bitIndex , final int lengthInBits ) { if ( key == null || bitIndex >= lengthInBits ) { MST[NegateConditionalsMutator]MSP[N] return false ; } final int index = bitIndex / LENGTH ; final int bit = bitIndex % LENGTH ;
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { MST[rv.UOI1Mutator]MSP[N] throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; return key . startsWith ( s1 ) ; }
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { MST[rv.ROR4Mutator]MSP[N] throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; return key . startsWith ( s1 ) ; }
final int index1 = beginIndex1 + i ; final int index2 = beginIndex2 + i ; if ( index1 >= endIndex1 ) { MST[ConditionalsBoundaryMutator]MSP[N] k = 0 ; } else { k = key . charAt ( index1 ) ; }
if ( other == null || index2 >= endIndex2 ) { f = 0 ; } else { f = other . charAt ( index2 ) ; } if ( k != f ) { final int x = k ^ f ; MST[rv.UOI1Mutator]MSP[N]
public boolean isBitSet ( final String key , final int bitIndex , final int lengthInBits ) { if ( key == null || bitIndex >= lengthInBits ) { return false ; } final int index = bitIndex / LENGTH ; MST[rv.AOD2Mutator]MSP[S] final int bit = bitIndex % LENGTH ;
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { MST[rv.AOD2Mutator]MSP[N] throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; return key . startsWith ( s1 ) ; }
public boolean isBitSet ( final String key , final int bitIndex , final int lengthInBits ) { if ( key == null || bitIndex >= lengthInBits ) { MST[rv.ROR4Mutator]MSP[N] return false ; } final int index = bitIndex / LENGTH ; final int bit = bitIndex % LENGTH ;
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { MST[rv.ABSMutator]MSP[N] throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; return key . startsWith ( s1 ) ; }
if ( other == null || index2 >= endIndex2 ) { f = 0 ; } else { f = other . charAt ( index2 ) ; } if ( k != f ) { MST[rv.ROR2Mutator]MSP[N] final int x = k ^ f ;
if ( other == null || index2 >= endIndex2 ) { f = 0 ; } else { f = other . charAt ( index2 ) ; } if ( k != f ) { final int x = k ^ f ; MST[rv.ABSMutator]MSP[N]
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; MST[rv.CRCR1Mutator]MSP[N] } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
final int endIndex2 = beginIndex2 + otherLengthInBits / LENGTH ; MST[rv.UOI1Mutator]MSP[N] final int length = Math . max ( endIndex1 , endIndex2 ) ; char k = 0 , f = 0 ; for ( int i = 0 ; i < length ; i ++ ) {
if ( other == null || index2 >= endIndex2 ) { MST[rv.UOI4Mutator]MSP[N] f = 0 ; } else { f = other . charAt ( index2 ) ; } if ( k != f ) { final int x = k ^ f ;
final int endIndex2 = beginIndex2 + otherLengthInBits / LENGTH ; final int length = Math . max ( endIndex1 , endIndex2 ) ; MST[rv.UOI3Mutator]MSP[N] char k = 0 , f = 0 ; for ( int i = 0 ; i < length ; i ++ ) {
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; MST[rv.CRCR3Mutator]MSP[N] } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
|| lengthInBits % LENGTH != 0 || otherLengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } final int beginIndex1 = offsetInBits / LENGTH ; MST[rv.ABSMutator]MSP[N] final int beginIndex2 = otherOffsetInBits / LENGTH ; final int endIndex1 = beginIndex1 + lengthInBits / LENGTH ;
final int index1 = beginIndex1 + i ; final int index2 = beginIndex2 + i ; if ( index1 >= endIndex1 ) { k = 0 ; } else { k = key . charAt ( index1 ) ; MST[NonVoidMethodCallMutator]MSP[N] }
return ( key . charAt ( index ) & mask ( bit ) ) != 0 ; MST[rv.UOI2Mutator]MSP[N] } @Override public boolean isPrefix ( final String prefix , final int offsetInBits , final int lengthInBits , final String key ) {
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; MST[rv.CRCR5Mutator]MSP[S] } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
final int endIndex2 = beginIndex2 + otherLengthInBits / LENGTH ; final int length = Math . max ( endIndex1 , endIndex2 ) ; char k = 0 , f = 0 ; MST[rv.CRCR1Mutator]MSP[N] for ( int i = 0 ; i < length ; i ++ ) {
final int endIndex2 = beginIndex2 + otherLengthInBits / LENGTH ; MST[rv.AOR2Mutator]MSP[N] final int length = Math . max ( endIndex1 , endIndex2 ) ; char k = 0 , f = 0 ; for ( int i = 0 ; i < length ; i ++ ) {
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
|| lengthInBits % LENGTH != 0 || otherLengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } final int beginIndex1 = offsetInBits / LENGTH ; final int beginIndex2 = otherOffsetInBits / LENGTH ; final int endIndex1 = beginIndex1 + lengthInBits / LENGTH ; MST[rv.UOI3Mutator]MSP[N]
final int endIndex2 = beginIndex2 + otherLengthInBits / LENGTH ; final int length = Math . max ( endIndex1 , endIndex2 ) ; char k = 0 , f = 0 ; MST[rv.CRCR3Mutator]MSP[N] for ( int i = 0 ; i < length ; i ++ ) {
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { MST[rv.ROR5Mutator]MSP[S] return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
final int index1 = beginIndex1 + i ; final int index2 = beginIndex2 + i ; if ( index1 >= endIndex1 ) { k = 0 ; } else { k = key . charAt ( index1 ) ; MST[rv.UOI2Mutator]MSP[N] }
return ( key . charAt ( index ) & mask ( bit ) ) != 0 ; MST[NonVoidMethodCallMutator]MSP[N] } @Override public boolean isPrefix ( final String prefix , final int offsetInBits , final int lengthInBits , final String key ) {
|| lengthInBits % LENGTH != 0 || otherLengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } final int beginIndex1 = offsetInBits / LENGTH ; final int beginIndex2 = otherOffsetInBits / LENGTH ; final int endIndex1 = beginIndex1 + lengthInBits / LENGTH ; MST[rv.AOR4Mutator]MSP[N]
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; MST[InlineConstantMutator]MSP[N] return key . startsWith ( s1 ) ; }
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
return ( key . charAt ( index ) & mask ( bit ) ) != 0 ; MST[rv.ROR2Mutator]MSP[N] } @Override public boolean isPrefix ( final String prefix , final int offsetInBits , final int lengthInBits , final String key ) {
public boolean isBitSet ( final String key , final int bitIndex , final int lengthInBits ) { if ( key == null || bitIndex >= lengthInBits ) { return false ; } final int index = bitIndex / LENGTH ; MST[rv.AOR4Mutator]MSP[S] final int bit = bitIndex % LENGTH ;
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.ROR4Mutator]MSP[S]
|| lengthInBits % LENGTH != 0 || otherLengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } final int beginIndex1 = offsetInBits / LENGTH ; MST[rv.UOI4Mutator]MSP[S] final int beginIndex2 = otherOffsetInBits / LENGTH ; final int endIndex1 = beginIndex1 + lengthInBits / LENGTH ;
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { MST[rv.ROR5Mutator]MSP[N] throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; return key . startsWith ( s1 ) ; }
final int index1 = beginIndex1 + i ; final int index2 = beginIndex2 + i ; if ( index1 >= endIndex1 ) { MST[rv.UOI3Mutator]MSP[N] k = 0 ; } else { k = key . charAt ( index1 ) ; }
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; MST[rv.CRCR2Mutator]MSP[N] } @Override
private static int mask ( final int bit ) { return MSB >>> bit ; MST[InlineConstantMutator]MSP[N] } @Override public int bitsPerElement () { return LENGTH ; } @Override public int lengthInBits ( final String key ) { return key != null ? key . length () * LENGTH : 0 ;
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { MST[rv.CRCR2Mutator]MSP[N] throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; return key . startsWith ( s1 ) ; }
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { MST[rv.ROR3Mutator]MSP[N] throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; return key . startsWith ( s1 ) ; }
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; MST[rv.CRCR6Mutator]MSP[S] } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
return ( key . charAt ( index ) & mask ( bit ) ) != 0 ; MST[rv.ABSMutator]MSP[S] } @Override public boolean isPrefix ( final String prefix , final int offsetInBits , final int lengthInBits , final String key ) {
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.UOI1Mutator]MSP[N]
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.ROR2Mutator]MSP[N]
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[NegateConditionalsMutator]MSP[N]
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.AOR1Mutator]MSP[N]
final int index1 = beginIndex1 + i ; MST[rv.AOR1Mutator]MSP[N] final int index2 = beginIndex2 + i ; if ( index1 >= endIndex1 ) { k = 0 ; } else { k = key . charAt ( index1 ) ; }
|| lengthInBits % LENGTH != 0 || otherLengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } final int beginIndex1 = offsetInBits / LENGTH ; MST[rv.CRCR2Mutator]MSP[N] final int beginIndex2 = otherOffsetInBits / LENGTH ; final int endIndex1 = beginIndex1 + lengthInBits / LENGTH ;
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; MST[rv.AOD1Mutator]MSP[S] } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.UOI3Mutator]MSP[N]
if ( other == null || index2 >= endIndex2 ) { f = 0 ; } else { f = other . charAt ( index2 ) ; } if ( k != f ) { final int x = k ^ f ; MST[rv.UOI2Mutator]MSP[N]
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; MST[rv.AOD2Mutator]MSP[N] } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; MST[rv.CRCR2Mutator]MSP[N] return key . startsWith ( s1 ) ; }
final int endIndex2 = beginIndex2 + otherLengthInBits / LENGTH ; MST[MathMutator]MSP[S] final int length = Math . max ( endIndex1 , endIndex2 ) ; char k = 0 , f = 0 ; for ( int i = 0 ; i < length ; i ++ ) {
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.AOR3Mutator]MSP[N]
|| lengthInBits % LENGTH != 0 || otherLengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } final int beginIndex1 = offsetInBits / LENGTH ; MST[rv.CRCR6Mutator]MSP[N] final int beginIndex2 = otherOffsetInBits / LENGTH ; final int endIndex1 = beginIndex1 + lengthInBits / LENGTH ;
private static int mask ( final int bit ) { return MSB >>> bit ; } @Override public int bitsPerElement () { return LENGTH ; } @Override public int lengthInBits ( final String key ) { return key != null ? key . length () * LENGTH : 0 ; MST[rv.CRCR2Mutator]MSP[N]
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.AOR2Mutator]MSP[N]
private static int mask ( final int bit ) { return MSB >>> bit ; } @Override public int bitsPerElement () { return LENGTH ; } @Override public int lengthInBits ( final String key ) { return key != null ? key . length () * LENGTH : 0 ; MST[rv.AOD1Mutator]MSP[N]
public boolean isBitSet ( final String key , final int bitIndex , final int lengthInBits ) { if ( key == null || bitIndex >= lengthInBits ) { return false ; } final int index = bitIndex / LENGTH ; MST[rv.UOI3Mutator]MSP[N] final int bit = bitIndex % LENGTH ;
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; return key . startsWith ( s1 ) ; }
|| lengthInBits % LENGTH != 0 || otherLengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } final int beginIndex1 = offsetInBits / LENGTH ; MST[rv.AOD1Mutator]MSP[N] final int beginIndex2 = otherOffsetInBits / LENGTH ; final int endIndex1 = beginIndex1 + lengthInBits / LENGTH ;
final int endIndex2 = beginIndex2 + otherLengthInBits / LENGTH ; final int length = Math . max ( endIndex1 , endIndex2 ) ; MST[rv.UOI3Mutator]MSP[N] char k = 0 , f = 0 ; for ( int i = 0 ; i < length ; i ++ ) {
public boolean isBitSet ( final String key , final int bitIndex , final int lengthInBits ) { if ( key == null || bitIndex >= lengthInBits ) { return false ; } final int index = bitIndex / LENGTH ; final int bit = bitIndex % LENGTH ; MST[rv.AOR1Mutator]MSP[N]
final int endIndex2 = beginIndex2 + otherLengthInBits / LENGTH ; final int length = Math . max ( endIndex1 , endIndex2 ) ; char k = 0 , f = 0 ; for ( int i = 0 ; i < length ; i ++ ) { MST[InlineConstantMutator]MSP[N]
final int endIndex2 = beginIndex2 + otherLengthInBits / LENGTH ; MST[rv.AOR2Mutator]MSP[N] final int length = Math . max ( endIndex1 , endIndex2 ) ; char k = 0 , f = 0 ; for ( int i = 0 ; i < length ; i ++ ) {
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; MST[rv.AOR1Mutator]MSP[N] return key . startsWith ( s1 ) ; }
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; MST[MathMutator]MSP[N] } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; MST[rv.CRCR2Mutator]MSP[S] if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0
|| lengthInBits % LENGTH != 0 || otherLengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } final int beginIndex1 = offsetInBits / LENGTH ; final int beginIndex2 = otherOffsetInBits / LENGTH ; final int endIndex1 = beginIndex1 + lengthInBits / LENGTH ; MST[rv.UOI3Mutator]MSP[S]
|| lengthInBits % LENGTH != 0 || otherLengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } final int beginIndex1 = offsetInBits / LENGTH ; final int beginIndex2 = otherOffsetInBits / LENGTH ; MST[rv.UOI1Mutator]MSP[N] final int endIndex1 = beginIndex1 + lengthInBits / LENGTH ;
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { MST[NegateConditionalsMutator]MSP[S] return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
private static int mask ( final int bit ) { return MSB >>> bit ; } @Override public int bitsPerElement () { return LENGTH ; MST[rv.CRCR4Mutator]MSP[N] } @Override public int lengthInBits ( final String key ) { return key != null ? key . length () * LENGTH : 0 ;
final int endIndex2 = beginIndex2 + otherLengthInBits / LENGTH ; final int length = Math . max ( endIndex1 , endIndex2 ) ; char k = 0 , f = 0 ; MST[rv.CRCR6Mutator]MSP[N] for ( int i = 0 ; i < length ; i ++ ) {
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; MST[rv.CRCR6Mutator]MSP[S] if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0
public boolean isBitSet ( final String key , final int bitIndex , final int lengthInBits ) { if ( key == null || bitIndex >= lengthInBits ) { return false ; } final int index = bitIndex / LENGTH ; final int bit = bitIndex % LENGTH ; MST[rv.AOD2Mutator]MSP[N]
public boolean isBitSet ( final String key , final int bitIndex , final int lengthInBits ) { if ( key == null || bitIndex >= lengthInBits ) { return false ; } final int index = bitIndex / LENGTH ; final int bit = bitIndex % LENGTH ; MST[rv.CRCR1Mutator]MSP[N]
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; MST[rv.ABSMutator]MSP[S] } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; MST[ReturnValsMutator]MSP[S] } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { MST[rv.ROR2Mutator]MSP[N] throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; return key . startsWith ( s1 ) ; }
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; MST[MathMutator]MSP[N] return key . startsWith ( s1 ) ; }
return ( key . charAt ( index ) & mask ( bit ) ) != 0 ; MST[rv.CRCR1Mutator]MSP[S] } @Override public boolean isPrefix ( final String prefix , final int offsetInBits , final int lengthInBits , final String key ) {
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.ROR1Mutator]MSP[N]
final int endIndex2 = beginIndex2 + otherLengthInBits / LENGTH ; final int length = Math . max ( endIndex1 , endIndex2 ) ; char k = 0 , f = 0 ; for ( int i = 0 ; i < length ; i ++ ) { MST[rv.UOI3Mutator]MSP[N]
if ( other == null || index2 >= endIndex2 ) { f = 0 ; } else { f = other . charAt ( index2 ) ; } if ( k != f ) { final int x = k ^ f ; MST[rv.UOI2Mutator]MSP[N]
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.ROR5Mutator]MSP[N]
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.UOI2Mutator]MSP[S]
if ( other == null || index2 >= endIndex2 ) { f = 0 ; } else { f = other . charAt ( index2 ) ; } if ( k != f ) { MST[rv.ROR4Mutator]MSP[S] final int x = k ^ f ;
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; } if ( k != 0 ) { allNull = false ; MST[rv.CRCR6Mutator]MSP[N] } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; } if ( k != 0 ) { allNull = false ; MST[rv.CRCR5Mutator]MSP[N] } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
final int index1 = beginIndex1 + i ; final int index2 = beginIndex2 + i ; if ( index1 >= endIndex1 ) { k = 0 ; MST[rv.CRCR6Mutator]MSP[N] } else { k = key . charAt ( index1 ) ; }
public boolean isBitSet ( final String key , final int bitIndex , final int lengthInBits ) { if ( key == null || bitIndex >= lengthInBits ) { MST[rv.ROR3Mutator]MSP[N] return false ; } final int index = bitIndex / LENGTH ; final int bit = bitIndex % LENGTH ;
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { MST[rv.AOR1Mutator]MSP[N] throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; return key . startsWith ( s1 ) ; }
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; MST[rv.CRCR3Mutator]MSP[N] return key . startsWith ( s1 ) ; }
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; MST[rv.AOR4Mutator]MSP[N] } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
final int index1 = beginIndex1 + i ; final int index2 = beginIndex2 + i ; if ( index1 >= endIndex1 ) { MST[rv.ROR1Mutator]MSP[N] k = 0 ; } else { k = key . charAt ( index1 ) ; }
if ( other == null || index2 >= endIndex2 ) { MST[rv.ROR3Mutator]MSP[N] f = 0 ; } else { f = other . charAt ( index2 ) ; } if ( k != f ) { final int x = k ^ f ;
if ( other == null || index2 >= endIndex2 ) { MST[rv.ROR2Mutator]MSP[N] f = 0 ; } else { f = other . charAt ( index2 ) ; } if ( k != f ) { final int x = k ^ f ;
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.CRCR1Mutator]MSP[N]
final int index1 = beginIndex1 + i ; final int index2 = beginIndex2 + i ; if ( index1 >= endIndex1 ) { MST[rv.ABSMutator]MSP[N] k = 0 ; } else { k = key . charAt ( index1 ) ; }
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.CRCR2Mutator]MSP[N]
private static int mask ( final int bit ) { return MSB >>> bit ; MST[rv.CRCR2Mutator]MSP[N] } @Override public int bitsPerElement () { return LENGTH ; } @Override public int lengthInBits ( final String key ) { return key != null ? key . length () * LENGTH : 0 ;
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.CRCR5Mutator]MSP[N]
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; MST[rv.AOR1Mutator]MSP[N] return key . startsWith ( s1 ) ; }
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.CRCR6Mutator]MSP[N]
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { MST[InlineConstantMutator]MSP[N] throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; return key . startsWith ( s1 ) ; }
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; } if ( k != 0 ) { MST[rv.ROR5Mutator]MSP[N] allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
return ( key . charAt ( index ) & mask ( bit ) ) != 0 ; MST[rv.UOI3Mutator]MSP[N] } @Override public boolean isPrefix ( final String prefix , final int offsetInBits , final int lengthInBits , final String key ) {
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.CRCR4Mutator]MSP[N]
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; MST[NonVoidMethodCallMutator]MSP[N] return key . startsWith ( s1 ) ; }
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; return key . startsWith ( s1 ) ; MST[ReturnValsMutator]MSP[N] }
|| lengthInBits % LENGTH != 0 || otherLengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } final int beginIndex1 = offsetInBits / LENGTH ; final int beginIndex2 = otherOffsetInBits / LENGTH ; final int endIndex1 = beginIndex1 + lengthInBits / LENGTH ; MST[rv.AOD1Mutator]MSP[S]
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.CRCR3Mutator]MSP[N]
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { MST[MathMutator]MSP[N] throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; return key . startsWith ( s1 ) ; }
|| lengthInBits % LENGTH != 0 || otherLengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } final int beginIndex1 = offsetInBits / LENGTH ; final int beginIndex2 = otherOffsetInBits / LENGTH ; MST[rv.AOR2Mutator]MSP[S] final int endIndex1 = beginIndex1 + lengthInBits / LENGTH ;
public boolean isBitSet ( final String key , final int bitIndex , final int lengthInBits ) { if ( key == null || bitIndex >= lengthInBits ) { return false ; } final int index = bitIndex / LENGTH ; final int bit = bitIndex % LENGTH ; MST[rv.CRCR2Mutator]MSP[S]
final int index1 = beginIndex1 + i ; final int index2 = beginIndex2 + i ; if ( index1 >= endIndex1 ) { MST[rv.UOI4Mutator]MSP[N] k = 0 ; } else { k = key . charAt ( index1 ) ; }
private static int mask ( final int bit ) { return MSB >>> bit ; } @Override public int bitsPerElement () { return LENGTH ; MST[PrimitiveReturnsMutator]MSP[N] } @Override public int lengthInBits ( final String key ) { return key != null ? key . length () * LENGTH : 0 ;
return ( key . charAt ( index ) & mask ( bit ) ) != 0 ; MST[rv.ABSMutator]MSP[N] } @Override public boolean isPrefix ( final String prefix , final int offsetInBits , final int lengthInBits , final String key ) {
final int endIndex2 = beginIndex2 + otherLengthInBits / LENGTH ; MST[rv.CRCR3Mutator]MSP[N] final int length = Math . max ( endIndex1 , endIndex2 ) ; char k = 0 , f = 0 ; for ( int i = 0 ; i < length ; i ++ ) {
if ( other == null || index2 >= endIndex2 ) { f = 0 ; } else { f = other . charAt ( index2 ) ; } if ( k != f ) { MST[rv.UOI1Mutator]MSP[N] final int x = k ^ f ;
|| lengthInBits % LENGTH != 0 || otherLengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } final int beginIndex1 = offsetInBits / LENGTH ; final int beginIndex2 = otherOffsetInBits / LENGTH ; final int endIndex1 = beginIndex1 + lengthInBits / LENGTH ; MST[rv.CRCR5Mutator]MSP[N]
if ( other == null || index2 >= endIndex2 ) { f = 0 ; } else { f = other . charAt ( index2 ) ; MST[rv.ABSMutator]MSP[N] } if ( k != f ) { final int x = k ^ f ;
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; MST[rv.UOI4Mutator]MSP[N] } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; } if ( k != 0 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
private static int mask ( final int bit ) { return MSB >>> bit ; } @Override public int bitsPerElement () { return LENGTH ; } @Override public int lengthInBits ( final String key ) { return key != null ? key . length () * LENGTH : 0 ; MST[rv.CRCR6Mutator]MSP[N]
final int endIndex2 = beginIndex2 + otherLengthInBits / LENGTH ; final int length = Math . max ( endIndex1 , endIndex2 ) ; MST[ArgumentPropagationMutator]MSP[S] char k = 0 , f = 0 ; for ( int i = 0 ; i < length ; i ++ ) {
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.AOD2Mutator]MSP[N]
private static int mask ( final int bit ) { return MSB >>> bit ; } @Override public int bitsPerElement () { return LENGTH ; } @Override public int lengthInBits ( final String key ) { return key != null ? key . length () * LENGTH : 0 ; MST[rv.CRCR3Mutator]MSP[S]
final int index1 = beginIndex1 + i ; final int index2 = beginIndex2 + i ; if ( index1 >= endIndex1 ) { k = 0 ; MST[rv.CRCR1Mutator]MSP[N] } else { k = key . charAt ( index1 ) ; }
return ( key . charAt ( index ) & mask ( bit ) ) != 0 ; MST[rv.CRCR6Mutator]MSP[N] } @Override public boolean isPrefix ( final String prefix , final int offsetInBits , final int lengthInBits , final String key ) {
final int endIndex2 = beginIndex2 + otherLengthInBits / LENGTH ; final int length = Math . max ( endIndex1 , endIndex2 ) ; char k = 0 , f = 0 ; for ( int i = 0 ; i < length ; i ++ ) { MST[rv.ABSMutator]MSP[N]
final int index1 = beginIndex1 + i ; MST[rv.AOD2Mutator]MSP[N] final int index2 = beginIndex2 + i ; if ( index1 >= endIndex1 ) { k = 0 ; } else { k = key . charAt ( index1 ) ; }
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; MST[rv.AOD2Mutator]MSP[S] } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.ABSMutator]MSP[N]
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.AOR4Mutator]MSP[N]
final int endIndex2 = beginIndex2 + otherLengthInBits / LENGTH ; MST[rv.UOI1Mutator]MSP[S] final int length = Math . max ( endIndex1 , endIndex2 ) ; char k = 0 , f = 0 ; for ( int i = 0 ; i < length ; i ++ ) {
return ( key . charAt ( index ) & mask ( bit ) ) != 0 ; MST[ArgumentPropagationMutator]MSP[S] } @Override public boolean isPrefix ( final String prefix , final int offsetInBits , final int lengthInBits , final String key ) {
private static int mask ( final int bit ) { return MSB >>> bit ; } @Override public int bitsPerElement () { return LENGTH ; } @Override public int lengthInBits ( final String key ) { return key != null ? key . length () * LENGTH : 0 ; MST[rv.CRCR1Mutator]MSP[N]
private static int mask ( final int bit ) { return MSB >>> bit ; } @Override public int bitsPerElement () { return LENGTH ; } @Override public int lengthInBits ( final String key ) { return key != null ? key . length () * LENGTH : 0 ; MST[rv.AOD2Mutator]MSP[N]
if ( other == null || index2 >= endIndex2 ) { f = 0 ; } else { f = other . charAt ( index2 ) ; MST[rv.UOI4Mutator]MSP[N] } if ( k != f ) { final int x = k ^ f ;
if ( other == null || index2 >= endIndex2 ) { f = 0 ; } else { f = other . charAt ( index2 ) ; } if ( k != f ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] final int x = k ^ f ;
|| lengthInBits % LENGTH != 0 || otherLengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } final int beginIndex1 = offsetInBits / LENGTH ; MST[rv.AOD2Mutator]MSP[N] final int beginIndex2 = otherOffsetInBits / LENGTH ; final int endIndex1 = beginIndex1 + lengthInBits / LENGTH ;
final int index1 = beginIndex1 + i ; final int index2 = beginIndex2 + i ; if ( index1 >= endIndex1 ) { MST[rv.ABSMutator]MSP[N] k = 0 ; } else { k = key . charAt ( index1 ) ; }
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[MathMutator]MSP[N]
if ( other == null || index2 >= endIndex2 ) { f = 0 ; MST[InlineConstantMutator]MSP[N] } else { f = other . charAt ( index2 ) ; } if ( k != f ) { final int x = k ^ f ;
final int index1 = beginIndex1 + i ; final int index2 = beginIndex2 + i ; MST[rv.AOR2Mutator]MSP[N] if ( index1 >= endIndex1 ) { k = 0 ; } else { k = key . charAt ( index1 ) ; }
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; MST[rv.CRCR6Mutator]MSP[N] } @Override
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; MST[rv.AOR2Mutator]MSP[N] return key . startsWith ( s1 ) ; }
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[InlineConstantMutator]MSP[N]
public boolean isBitSet ( final String key , final int bitIndex , final int lengthInBits ) { if ( key == null || bitIndex >= lengthInBits ) { return false ; MST[rv.CRCR3Mutator]MSP[N] } final int index = bitIndex / LENGTH ; final int bit = bitIndex % LENGTH ;
|| lengthInBits % LENGTH != 0 || otherLengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } final int beginIndex1 = offsetInBits / LENGTH ; final int beginIndex2 = otherOffsetInBits / LENGTH ; final int endIndex1 = beginIndex1 + lengthInBits / LENGTH ; MST[rv.AOD1Mutator]MSP[N]
final int endIndex2 = beginIndex2 + otherLengthInBits / LENGTH ; final int length = Math . max ( endIndex1 , endIndex2 ) ; char k = 0 , f = 0 ; MST[rv.CRCR1Mutator]MSP[N] for ( int i = 0 ; i < length ; i ++ ) {
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { MST[rv.UOI2Mutator]MSP[N] return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
public boolean isBitSet ( final String key , final int bitIndex , final int lengthInBits ) { if ( key == null || bitIndex >= lengthInBits ) { return false ; MST[InlineConstantMutator]MSP[N] } final int index = bitIndex / LENGTH ; final int bit = bitIndex % LENGTH ;
|| lengthInBits % LENGTH != 0 || otherLengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } final int beginIndex1 = offsetInBits / LENGTH ; final int beginIndex2 = otherOffsetInBits / LENGTH ; final int endIndex1 = beginIndex1 + lengthInBits / LENGTH ; MST[rv.ABSMutator]MSP[N]
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; MST[rv.UOI1Mutator]MSP[N] return key . startsWith ( s1 ) ; }
private static int mask ( final int bit ) { return MSB >>> bit ; MST[rv.UOI1Mutator]MSP[N] } @Override public int bitsPerElement () { return LENGTH ; } @Override public int lengthInBits ( final String key ) { return key != null ? key . length () * LENGTH : 0 ;
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; MST[rv.UOI2Mutator]MSP[N] return key . startsWith ( s1 ) ; }
if ( other == null || index2 >= endIndex2 ) { f = 0 ; MST[rv.CRCR3Mutator]MSP[N] } else { f = other . charAt ( index2 ) ; } if ( k != f ) { final int x = k ^ f ;
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; } if ( k != 0 ) { MST[rv.UOI3Mutator]MSP[N] allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
final int index1 = beginIndex1 + i ; final int index2 = beginIndex2 + i ; if ( index1 >= endIndex1 ) { MST[rv.UOI4Mutator]MSP[N] k = 0 ; } else { k = key . charAt ( index1 ) ; }
|| lengthInBits % LENGTH != 0 || otherLengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } final int beginIndex1 = offsetInBits / LENGTH ; final int beginIndex2 = otherOffsetInBits / LENGTH ; final int endIndex1 = beginIndex1 + lengthInBits / LENGTH ; MST[rv.AOR4Mutator]MSP[N]
return ( key . charAt ( index ) & mask ( bit ) ) != 0 ; MST[rv.ROR1Mutator]MSP[S] } @Override public boolean isPrefix ( final String prefix , final int offsetInBits , final int lengthInBits , final String key ) {
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.ROR3Mutator]MSP[N]
|| lengthInBits % LENGTH != 0 || otherLengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } final int beginIndex1 = offsetInBits / LENGTH ; final int beginIndex2 = otherOffsetInBits / LENGTH ; MST[MathMutator]MSP[N] final int endIndex1 = beginIndex1 + lengthInBits / LENGTH ;
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { MST[rv.CRCR1Mutator]MSP[N] throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; return key . startsWith ( s1 ) ; }
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { MST[rv.ROR4Mutator]MSP[S] throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; return key . startsWith ( s1 ) ; }
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; MST[rv.CRCR1Mutator]MSP[N] } @Override
public boolean isBitSet ( final String key , final int bitIndex , final int lengthInBits ) { if ( key == null || bitIndex >= lengthInBits ) { return false ; } final int index = bitIndex / LENGTH ; MST[rv.CRCR5Mutator]MSP[N] final int bit = bitIndex % LENGTH ;
final int endIndex2 = beginIndex2 + otherLengthInBits / LENGTH ; final int length = Math . max ( endIndex1 , endIndex2 ) ; MST[rv.ABSMutator]MSP[S] char k = 0 , f = 0 ; for ( int i = 0 ; i < length ; i ++ ) {
final int index1 = beginIndex1 + i ; final int index2 = beginIndex2 + i ; MST[rv.UOI2Mutator]MSP[N] if ( index1 >= endIndex1 ) { k = 0 ; } else { k = key . charAt ( index1 ) ; }
|| lengthInBits % LENGTH != 0 || otherLengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } final int beginIndex1 = offsetInBits / LENGTH ; final int beginIndex2 = otherOffsetInBits / LENGTH ; MST[InlineConstantMutator]MSP[S] final int endIndex1 = beginIndex1 + lengthInBits / LENGTH ;
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { MST[rv.UOI1Mutator]MSP[N] throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; return key . startsWith ( s1 ) ; }
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { MST[NegateConditionalsMutator]MSP[N] throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; return key . startsWith ( s1 ) ; }
|| lengthInBits % LENGTH != 0 || otherLengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } final int beginIndex1 = offsetInBits / LENGTH ; final int beginIndex2 = otherOffsetInBits / LENGTH ; MST[rv.CRCR3Mutator]MSP[N] final int endIndex1 = beginIndex1 + lengthInBits / LENGTH ;
final int endIndex2 = beginIndex2 + otherLengthInBits / LENGTH ; final int length = Math . max ( endIndex1 , endIndex2 ) ; char k = 0 , f = 0 ; for ( int i = 0 ; i < length ; i ++ ) { MST[rv.UOI4Mutator]MSP[S]
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.AOD1Mutator]MSP[N]
public boolean isBitSet ( final String key , final int bitIndex , final int lengthInBits ) { if ( key == null || bitIndex >= lengthInBits ) { return false ; } final int index = bitIndex / LENGTH ; MST[rv.ABSMutator]MSP[S] final int bit = bitIndex % LENGTH ;
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { MST[rv.AOD2Mutator]MSP[N] throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; return key . startsWith ( s1 ) ; }
final int endIndex2 = beginIndex2 + otherLengthInBits / LENGTH ; MST[MathMutator]MSP[N] final int length = Math . max ( endIndex1 , endIndex2 ) ; char k = 0 , f = 0 ; for ( int i = 0 ; i < length ; i ++ ) {
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.UOI4Mutator]MSP[N]
|| lengthInBits % LENGTH != 0 || otherLengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } final int beginIndex1 = offsetInBits / LENGTH ; MST[rv.CRCR1Mutator]MSP[N] final int beginIndex2 = otherOffsetInBits / LENGTH ; final int endIndex1 = beginIndex1 + lengthInBits / LENGTH ;
if ( other == null || index2 >= endIndex2 ) { f = 0 ; } else { f = other . charAt ( index2 ) ; } if ( k != f ) { MST[rv.UOI1Mutator]MSP[N] final int x = k ^ f ;
