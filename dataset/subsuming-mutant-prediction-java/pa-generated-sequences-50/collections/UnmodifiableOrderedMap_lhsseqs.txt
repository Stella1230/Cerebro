public static < K , V > OrderedMap < K , V > unmodifiableOrderedMap ( final OrderedMap < ? extends K , ? extends V > map ) { if ( map instanceof Unmodifiable ) { MST[NegateConditionalsMutator]MSP[] @SuppressWarnings ( lr_1 )
final OrderedMap < K , V > tmpMap = ( OrderedMap < K , V > ) map ; return tmpMap ; } return new UnmodifiableOrderedMap <> ( map ) ; } private void writeObject ( final ObjectOutputStream out ) throws IOException { out . defaultWriteObject () ; MST[VoidMethodCallMutator]MSP[]
return UnmodifiableEntrySet . unmodifiableEntrySet ( set ) ; MST[ReturnValsMutator]MSP[] } @Override public Set < K > keySet () { final Set < K > set = super . keySet () ; return UnmodifiableSet . unmodifiableSet ( set ) ; } @Override public Collection < V > values () {
public static < K , V > OrderedMap < K , V > unmodifiableOrderedMap ( final OrderedMap < ? extends K , ? extends V > map ) { if ( map instanceof Unmodifiable ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] @SuppressWarnings ( lr_1 )
final Collection < V > coll = super . values () ; return UnmodifiableCollection . unmodifiableCollection ( coll ) ; MST[EmptyObjectReturnValsMutator]MSP[] }
out . writeObject ( map ) ; MST[VoidMethodCallMutator]MSP[] } @SuppressWarnings ( lr_1 ) private void readObject ( final ObjectInputStream in ) throws IOException , ClassNotFoundException { in . defaultReadObject () ; map = ( Map < K , V > ) in . readObject () ; } @Override
return UnmodifiableEntrySet . unmodifiableEntrySet ( set ) ; } @Override public Set < K > keySet () { final Set < K > set = super . keySet () ; return UnmodifiableSet . unmodifiableSet ( set ) ; MST[EmptyObjectReturnValsMutator]MSP[] } @Override public Collection < V > values () {
out . writeObject ( map ) ; } @SuppressWarnings ( lr_1 ) private void readObject ( final ObjectInputStream in ) throws IOException , ClassNotFoundException { in . defaultReadObject () ; map = ( Map < K , V > ) in . readObject () ; MST[NonVoidMethodCallMutator]MSP[] } @Override
public V put ( final K key , final V value ) { throw new UnsupportedOperationException () ; } @Override public void putAll ( final Map < ? extends K , ? extends V > mapToCopy ) { throw new UnsupportedOperationException () ; MST[ConstructorCallMutator]MSP[] } @Override
return UnmodifiableEntrySet . unmodifiableEntrySet ( set ) ; } @Override public Set < K > keySet () { final Set < K > set = super . keySet () ; return UnmodifiableSet . unmodifiableSet ( set ) ; MST[ReturnValsMutator]MSP[] } @Override public Collection < V > values () {
final Collection < V > coll = super . values () ; return UnmodifiableCollection . unmodifiableCollection ( coll ) ; MST[ArgumentPropagationMutator]MSP[] }
out . writeObject ( map ) ; } @SuppressWarnings ( lr_1 ) private void readObject ( final ObjectInputStream in ) throws IOException , ClassNotFoundException { in . defaultReadObject () ; MST[VoidMethodCallMutator]MSP[] map = ( Map < K , V > ) in . readObject () ; } @Override
final OrderedMap < K , V > tmpMap = ( OrderedMap < K , V > ) map ; return tmpMap ; MST[NullReturnValsMutator]MSP[] } return new UnmodifiableOrderedMap <> ( map ) ; } private void writeObject ( final ObjectOutputStream out ) throws IOException { out . defaultWriteObject () ;
public V remove ( final Object key ) { throw new UnsupportedOperationException () ; } @Override public Set < Map . Entry < K , V > > entrySet () { final Set < Map . Entry < K , V > > set = super . entrySet () ; MST[NonVoidMethodCallMutator]MSP[]
return UnmodifiableEntrySet . unmodifiableEntrySet ( set ) ; } @Override public Set < K > keySet () { final Set < K > set = super . keySet () ; return UnmodifiableSet . unmodifiableSet ( set ) ; MST[NonVoidMethodCallMutator]MSP[] } @Override public Collection < V > values () {
final Collection < V > coll = super . values () ; return UnmodifiableCollection . unmodifiableCollection ( coll ) ; MST[NonVoidMethodCallMutator]MSP[] }
public static < K , V > OrderedMap < K , V > unmodifiableOrderedMap ( final OrderedMap < ? extends K , ? extends V > map ) { if ( map instanceof Unmodifiable ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] @SuppressWarnings ( lr_1 )
final Collection < V > coll = super . values () ; MST[NonVoidMethodCallMutator]MSP[] return UnmodifiableCollection . unmodifiableCollection ( coll ) ; }
return UnmodifiableEntrySet . unmodifiableEntrySet ( set ) ; } @Override public Set < K > keySet () { final Set < K > set = super . keySet () ; MST[NonVoidMethodCallMutator]MSP[] return UnmodifiableSet . unmodifiableSet ( set ) ; } @Override public Collection < V > values () {
public static < K , V > OrderedMap < K , V > unmodifiableOrderedMap ( final OrderedMap < ? extends K , ? extends V > map ) { if ( map instanceof Unmodifiable ) { MST[rv.ROR1Mutator]MSP[] @SuppressWarnings ( lr_1 )
public OrderedMapIterator < K , V > mapIterator () { final OrderedMapIterator < K , V > it = decorated () . mapIterator () ; return UnmodifiableOrderedMapIterator . unmodifiableOrderedMapIterator ( it ) ; } @Override public void clear () { throw new UnsupportedOperationException () ; MST[ConstructorCallMutator]MSP[] } @Override
final OrderedMap < K , V > tmpMap = ( OrderedMap < K , V > ) map ; return tmpMap ; } return new UnmodifiableOrderedMap <> ( map ) ; MST[ReturnValsMutator]MSP[] } private void writeObject ( final ObjectOutputStream out ) throws IOException { out . defaultWriteObject () ;
public V remove ( final Object key ) { throw new UnsupportedOperationException () ; MST[ConstructorCallMutator]MSP[] } @Override public Set < Map . Entry < K , V > > entrySet () { final Set < Map . Entry < K , V > > set = super . entrySet () ;
out . writeObject ( map ) ; } @SuppressWarnings ( lr_1 ) private void readObject ( final ObjectInputStream in ) throws IOException , ClassNotFoundException { in . defaultReadObject () ; map = ( Map < K , V > ) in . readObject () ; MST[experimental.MemberVariableMutator]MSP[] } @Override
return UnmodifiableEntrySet . unmodifiableEntrySet ( set ) ; MST[EmptyObjectReturnValsMutator]MSP[] } @Override public Set < K > keySet () { final Set < K > set = super . keySet () ; return UnmodifiableSet . unmodifiableSet ( set ) ; } @Override public Collection < V > values () {
return UnmodifiableEntrySet . unmodifiableEntrySet ( set ) ; } @Override public Set < K > keySet () { final Set < K > set = super . keySet () ; return UnmodifiableSet . unmodifiableSet ( set ) ; MST[ArgumentPropagationMutator]MSP[] } @Override public Collection < V > values () {
final OrderedMap < K , V > tmpMap = ( OrderedMap < K , V > ) map ; return tmpMap ; } return new UnmodifiableOrderedMap <> ( map ) ; MST[ConstructorCallMutator]MSP[] } private void writeObject ( final ObjectOutputStream out ) throws IOException { out . defaultWriteObject () ;
return UnmodifiableEntrySet . unmodifiableEntrySet ( set ) ; MST[NonVoidMethodCallMutator]MSP[] } @Override public Set < K > keySet () { final Set < K > set = super . keySet () ; return UnmodifiableSet . unmodifiableSet ( set ) ; } @Override public Collection < V > values () {
return UnmodifiableEntrySet . unmodifiableEntrySet ( set ) ; MST[ArgumentPropagationMutator]MSP[] } @Override public Set < K > keySet () { final Set < K > set = super . keySet () ; return UnmodifiableSet . unmodifiableSet ( set ) ; } @Override public Collection < V > values () {
public static < K , V > OrderedMap < K , V > unmodifiableOrderedMap ( final OrderedMap < ? extends K , ? extends V > map ) { if ( map instanceof Unmodifiable ) { MST[rv.ROR4Mutator]MSP[] @SuppressWarnings ( lr_1 )
public static < K , V > OrderedMap < K , V > unmodifiableOrderedMap ( final OrderedMap < ? extends K , ? extends V > map ) { if ( map instanceof Unmodifiable ) { MST[rv.ROR3Mutator]MSP[] @SuppressWarnings ( lr_1 )
public static < K , V > OrderedMap < K , V > unmodifiableOrderedMap ( final OrderedMap < ? extends K , ? extends V > map ) { if ( map instanceof Unmodifiable ) { MST[rv.ROR5Mutator]MSP[] @SuppressWarnings ( lr_1 )
final OrderedMap < K , V > tmpMap = ( OrderedMap < K , V > ) map ; return tmpMap ; MST[ReturnValsMutator]MSP[] } return new UnmodifiableOrderedMap <> ( map ) ; } private void writeObject ( final ObjectOutputStream out ) throws IOException { out . defaultWriteObject () ;
public static < K , V > OrderedMap < K , V > unmodifiableOrderedMap ( final OrderedMap < ? extends K , ? extends V > map ) { if ( map instanceof Unmodifiable ) { MST[rv.ROR2Mutator]MSP[] @SuppressWarnings ( lr_1 )
final OrderedMap < K , V > tmpMap = ( OrderedMap < K , V > ) map ; return tmpMap ; } return new UnmodifiableOrderedMap <> ( map ) ; MST[NullReturnValsMutator]MSP[] } private void writeObject ( final ObjectOutputStream out ) throws IOException { out . defaultWriteObject () ;
public V put ( final K key , final V value ) { throw new UnsupportedOperationException () ; MST[ConstructorCallMutator]MSP[] } @Override public void putAll ( final Map < ? extends K , ? extends V > mapToCopy ) { throw new UnsupportedOperationException () ; } @Override
final Collection < V > coll = super . values () ; return UnmodifiableCollection . unmodifiableCollection ( coll ) ; MST[ReturnValsMutator]MSP[] }
