@Override public boolean add ( final E object ) { if ( comparator () == null && ! ( object instanceof Comparable ) ) { Objects . requireNonNull ( object , lr_1 ) ; throw new IllegalArgumentException ( lr_2 + object . getClass () + lr_3 + MST[NonVoidMethodCallMutator]MSP[N] lr_4 ) ;
@Override public boolean add ( final E object ) { if ( comparator () == null && ! ( object instanceof Comparable ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] Objects . requireNonNull ( object , lr_1 ) ; throw new IllegalArgumentException ( lr_2 + object . getClass () + lr_3 + lr_4 ) ;
out . defaultWriteObject () ; out . writeObject ( comparator () ) ; super . doWriteObject ( out ) ; MST[VoidMethodCallMutator]MSP[S] } private void readObject ( final ObjectInputStream in ) throws IOException , ClassNotFoundException { in . defaultReadObject () ; @SuppressWarnings ( lr_5 )
} return super . add ( object ) ; } @Override public E first () { return getMap () . firstKey () ; } @Override public E last () { return getMap () . lastKey () ; MST[NonVoidMethodCallMutator]MSP[S] } @Override public Comparator < ? super E > comparator () {
@Override public boolean add ( final E object ) { if ( comparator () == null && ! ( object instanceof Comparable ) ) { Objects . requireNonNull ( object , lr_1 ) ; throw new IllegalArgumentException ( lr_2 + object . getClass () + lr_3 + MST[NonVoidMethodCallMutator]MSP[S] lr_4 ) ;
@Override public boolean add ( final E object ) { if ( comparator () == null && ! ( object instanceof Comparable ) ) { Objects . requireNonNull ( object , lr_1 ) ; throw new IllegalArgumentException ( lr_2 + object . getClass () + lr_3 + MST[NonVoidMethodCallMutator]MSP[N] lr_4 ) ;
@Override public boolean add ( final E object ) { if ( comparator () == null && ! ( object instanceof Comparable ) ) { Objects . requireNonNull ( object , lr_1 ) ; throw new IllegalArgumentException ( lr_2 + object . getClass () + lr_3 + MST[ConstructorCallMutator]MSP[S] lr_4 ) ;
@Override public boolean add ( final E object ) { if ( comparator () == null && ! ( object instanceof Comparable ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] Objects . requireNonNull ( object , lr_1 ) ; throw new IllegalArgumentException ( lr_2 + object . getClass () + lr_3 + lr_4 ) ;
} return super . add ( object ) ; MST[BooleanTrueReturnValsMutator]MSP[S] } @Override public E first () { return getMap () . firstKey () ; } @Override public E last () { return getMap () . lastKey () ; } @Override public Comparator < ? super E > comparator () {
} return super . add ( object ) ; MST[NonVoidMethodCallMutator]MSP[N] } @Override public E first () { return getMap () . firstKey () ; } @Override public E last () { return getMap () . lastKey () ; } @Override public Comparator < ? super E > comparator () {
return getMap () . comparator () ; } @Override protected SortedMap < E , AbstractMapBag . MutableInteger > getMap () { return ( SortedMap < E , AbstractMapBag . MutableInteger > ) super . getMap () ; MST[NullReturnValsMutator]MSP[N] } private void writeObject ( final ObjectOutputStream out ) throws IOException {
} return super . add ( object ) ; } @Override public E first () { return getMap () . firstKey () ; MST[NonVoidMethodCallMutator]MSP[S] } @Override public E last () { return getMap () . lastKey () ; } @Override public Comparator < ? super E > comparator () {
} return super . add ( object ) ; MST[BooleanFalseReturnValsMutator]MSP[S] } @Override public E first () { return getMap () . firstKey () ; } @Override public E last () { return getMap () . lastKey () ; } @Override public Comparator < ? super E > comparator () {
} return super . add ( object ) ; } @Override public E first () { return getMap () . firstKey () ; } @Override public E last () { return getMap () . lastKey () ; MST[ReturnValsMutator]MSP[N] } @Override public Comparator < ? super E > comparator () {
return getMap () . comparator () ; } @Override protected SortedMap < E , AbstractMapBag . MutableInteger > getMap () { return ( SortedMap < E , AbstractMapBag . MutableInteger > ) super . getMap () ; MST[ReturnValsMutator]MSP[N] } private void writeObject ( final ObjectOutputStream out ) throws IOException {
@Override public boolean add ( final E object ) { if ( comparator () == null && ! ( object instanceof Comparable ) ) { Objects . requireNonNull ( object , lr_1 ) ; throw new IllegalArgumentException ( lr_2 + object . getClass () + lr_3 + MST[experimental.NakedReceiverMutator]MSP[N] lr_4 ) ;
@Override public boolean add ( final E object ) { if ( comparator () == null && ! ( object instanceof Comparable ) ) { MST[rv.ROR5Mutator]MSP[N] Objects . requireNonNull ( object , lr_1 ) ; throw new IllegalArgumentException ( lr_2 + object . getClass () + lr_3 + lr_4 ) ;
return getMap () . comparator () ; MST[NonVoidMethodCallMutator]MSP[N] } @Override protected SortedMap < E , AbstractMapBag . MutableInteger > getMap () { return ( SortedMap < E , AbstractMapBag . MutableInteger > ) super . getMap () ; } private void writeObject ( final ObjectOutputStream out ) throws IOException {
} return super . add ( object ) ; } @Override public E first () { return getMap () . firstKey () ; MST[ReturnValsMutator]MSP[S] } @Override public E last () { return getMap () . lastKey () ; } @Override public Comparator < ? super E > comparator () {
@Override public boolean add ( final E object ) { if ( comparator () == null && ! ( object instanceof Comparable ) ) { MST[NegateConditionalsMutator]MSP[S] Objects . requireNonNull ( object , lr_1 ) ; throw new IllegalArgumentException ( lr_2 + object . getClass () + lr_3 + lr_4 ) ;
@Override public boolean add ( final E object ) { if ( comparator () == null && ! ( object instanceof Comparable ) ) { MST[rv.ROR3Mutator]MSP[N] Objects . requireNonNull ( object , lr_1 ) ; throw new IllegalArgumentException ( lr_2 + object . getClass () + lr_3 + lr_4 ) ;
@Override public boolean add ( final E object ) { if ( comparator () == null && ! ( object instanceof Comparable ) ) { MST[rv.ROR1Mutator]MSP[N] Objects . requireNonNull ( object , lr_1 ) ; throw new IllegalArgumentException ( lr_2 + object . getClass () + lr_3 + lr_4 ) ;
out . defaultWriteObject () ; out . writeObject ( comparator () ) ; super . doWriteObject ( out ) ; } private void readObject ( final ObjectInputStream in ) throws IOException , ClassNotFoundException { in . defaultReadObject () ; MST[VoidMethodCallMutator]MSP[N] @SuppressWarnings ( lr_5 )
return getMap () . comparator () ; MST[ReturnValsMutator]MSP[N] } @Override protected SortedMap < E , AbstractMapBag . MutableInteger > getMap () { return ( SortedMap < E , AbstractMapBag . MutableInteger > ) super . getMap () ; } private void writeObject ( final ObjectOutputStream out ) throws IOException {
@Override public boolean add ( final E object ) { if ( comparator () == null && ! ( object instanceof Comparable ) ) { MST[NonVoidMethodCallMutator]MSP[N] Objects . requireNonNull ( object , lr_1 ) ; throw new IllegalArgumentException ( lr_2 + object . getClass () + lr_3 + lr_4 ) ;
final Comparator < ? super E > comp = ( Comparator < ? super E > ) in . readObject () ; MST[NonVoidMethodCallMutator]MSP[N] super . doReadObject ( new TreeMap < E , MutableInteger > ( comp ) , in ) ; }
@Override public boolean add ( final E object ) { if ( comparator () == null && ! ( object instanceof Comparable ) ) { Objects . requireNonNull ( object , lr_1 ) ; throw new IllegalArgumentException ( lr_2 + object . getClass () + lr_3 + MST[NonVoidMethodCallMutator]MSP[S] lr_4 ) ;
@Override public boolean add ( final E object ) { if ( comparator () == null && ! ( object instanceof Comparable ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] Objects . requireNonNull ( object , lr_1 ) ; throw new IllegalArgumentException ( lr_2 + object . getClass () + lr_3 + lr_4 ) ;
} return super . add ( object ) ; } @Override public E first () { return getMap () . firstKey () ; } @Override public E last () { return getMap () . lastKey () ; MST[NonVoidMethodCallMutator]MSP[N] } @Override public Comparator < ? super E > comparator () {
@Override public boolean add ( final E object ) { if ( comparator () == null && ! ( object instanceof Comparable ) ) { Objects . requireNonNull ( object , lr_1 ) ; throw new IllegalArgumentException ( lr_2 + object . getClass () + lr_3 + MST[NonVoidMethodCallMutator]MSP[S] lr_4 ) ;
@Override public boolean add ( final E object ) { if ( comparator () == null && ! ( object instanceof Comparable ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] Objects . requireNonNull ( object , lr_1 ) ; throw new IllegalArgumentException ( lr_2 + object . getClass () + lr_3 + lr_4 ) ;
} return super . add ( object ) ; } @Override public E first () { return getMap () . firstKey () ; MST[NonVoidMethodCallMutator]MSP[S] } @Override public E last () { return getMap () . lastKey () ; } @Override public Comparator < ? super E > comparator () {
@Override public boolean add ( final E object ) { if ( comparator () == null && ! ( object instanceof Comparable ) ) { Objects . requireNonNull ( object , lr_1 ) ; throw new IllegalArgumentException ( lr_2 + object . getClass () + lr_3 + MST[ConstructorCallMutator]MSP[S] lr_4 ) ;
out . defaultWriteObject () ; MST[VoidMethodCallMutator]MSP[N] out . writeObject ( comparator () ) ; super . doWriteObject ( out ) ; } private void readObject ( final ObjectInputStream in ) throws IOException , ClassNotFoundException { in . defaultReadObject () ; @SuppressWarnings ( lr_5 )
out . defaultWriteObject () ; out . writeObject ( comparator () ) ; MST[VoidMethodCallMutator]MSP[S] super . doWriteObject ( out ) ; } private void readObject ( final ObjectInputStream in ) throws IOException , ClassNotFoundException { in . defaultReadObject () ; @SuppressWarnings ( lr_5 )
out . defaultWriteObject () ; out . writeObject ( comparator () ) ; MST[NonVoidMethodCallMutator]MSP[N] super . doWriteObject ( out ) ; } private void readObject ( final ObjectInputStream in ) throws IOException , ClassNotFoundException { in . defaultReadObject () ; @SuppressWarnings ( lr_5 )
} return super . add ( object ) ; } @Override public E first () { return getMap () . firstKey () ; } @Override public E last () { return getMap () . lastKey () ; MST[NullReturnValsMutator]MSP[S] } @Override public Comparator < ? super E > comparator () {
final Comparator < ? super E > comp = ( Comparator < ? super E > ) in . readObject () ; super . doReadObject ( new TreeMap < E , MutableInteger > ( comp ) , in ) ; MST[ConstructorCallMutator]MSP[N] }
return getMap () . comparator () ; MST[NonVoidMethodCallMutator]MSP[N] } @Override protected SortedMap < E , AbstractMapBag . MutableInteger > getMap () { return ( SortedMap < E , AbstractMapBag . MutableInteger > ) super . getMap () ; } private void writeObject ( final ObjectOutputStream out ) throws IOException {
@Override public boolean add ( final E object ) { if ( comparator () == null && ! ( object instanceof Comparable ) ) { MST[rv.ROR4Mutator]MSP[N] Objects . requireNonNull ( object , lr_1 ) ; throw new IllegalArgumentException ( lr_2 + object . getClass () + lr_3 + lr_4 ) ;
return getMap () . comparator () ; MST[NullReturnValsMutator]MSP[N] } @Override protected SortedMap < E , AbstractMapBag . MutableInteger > getMap () { return ( SortedMap < E , AbstractMapBag . MutableInteger > ) super . getMap () ; } private void writeObject ( final ObjectOutputStream out ) throws IOException {
@Override public boolean add ( final E object ) { if ( comparator () == null && ! ( object instanceof Comparable ) ) { Objects . requireNonNull ( object , lr_1 ) ; throw new IllegalArgumentException ( lr_2 + object . getClass () + lr_3 + MST[experimental.NakedReceiverMutator]MSP[N] lr_4 ) ;
@Override public boolean add ( final E object ) { if ( comparator () == null && ! ( object instanceof Comparable ) ) { Objects . requireNonNull ( object , lr_1 ) ; throw new IllegalArgumentException ( lr_2 + object . getClass () + lr_3 + MST[experimental.NakedReceiverMutator]MSP[N] lr_4 ) ;
@Override public boolean add ( final E object ) { if ( comparator () == null && ! ( object instanceof Comparable ) ) { MST[NegateConditionalsMutator]MSP[N] Objects . requireNonNull ( object , lr_1 ) ; throw new IllegalArgumentException ( lr_2 + object . getClass () + lr_3 + lr_4 ) ;
@Override public boolean add ( final E object ) { if ( comparator () == null && ! ( object instanceof Comparable ) ) { MST[rv.ROR2Mutator]MSP[N] Objects . requireNonNull ( object , lr_1 ) ; throw new IllegalArgumentException ( lr_2 + object . getClass () + lr_3 + lr_4 ) ;
@Override public boolean add ( final E object ) { if ( comparator () == null && ! ( object instanceof Comparable ) ) { MST[rv.ROR5Mutator]MSP[S] Objects . requireNonNull ( object , lr_1 ) ; throw new IllegalArgumentException ( lr_2 + object . getClass () + lr_3 + lr_4 ) ;
return getMap () . comparator () ; } @Override protected SortedMap < E , AbstractMapBag . MutableInteger > getMap () { return ( SortedMap < E , AbstractMapBag . MutableInteger > ) super . getMap () ; MST[NonVoidMethodCallMutator]MSP[N] } private void writeObject ( final ObjectOutputStream out ) throws IOException {
@Override public boolean add ( final E object ) { if ( comparator () == null && ! ( object instanceof Comparable ) ) { Objects . requireNonNull ( object , lr_1 ) ; MST[NonVoidMethodCallMutator]MSP[N] throw new IllegalArgumentException ( lr_2 + object . getClass () + lr_3 + lr_4 ) ;
@Override public boolean add ( final E object ) { if ( comparator () == null && ! ( object instanceof Comparable ) ) { Objects . requireNonNull ( object , lr_1 ) ; MST[ArgumentPropagationMutator]MSP[N] throw new IllegalArgumentException ( lr_2 + object . getClass () + lr_3 + lr_4 ) ;
} return super . add ( object ) ; MST[ReturnValsMutator]MSP[N] } @Override public E first () { return getMap () . firstKey () ; } @Override public E last () { return getMap () . lastKey () ; } @Override public Comparator < ? super E > comparator () {
} return super . add ( object ) ; } @Override public E first () { return getMap () . firstKey () ; MST[NullReturnValsMutator]MSP[S] } @Override public E last () { return getMap () . lastKey () ; } @Override public Comparator < ? super E > comparator () {
final Comparator < ? super E > comp = ( Comparator < ? super E > ) in . readObject () ; super . doReadObject ( new TreeMap < E , MutableInteger > ( comp ) , in ) ; MST[VoidMethodCallMutator]MSP[S] }
