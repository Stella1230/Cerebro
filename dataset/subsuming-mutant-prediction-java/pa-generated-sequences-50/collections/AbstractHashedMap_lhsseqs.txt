h += ~ ( h << 9 ) ; h ^= h >>> 14 ; MST[rv.ABSMutator]MSP[] h += h << 4 ; h ^= h >>> 10 ; return h ; } protected boolean isEqualKey ( final Object key1 , final Object key2 ) {
final HashEntry < K , V > oldEntries [] = data ; final HashEntry < K , V > newEntries [] = new HashEntry [ newCapacity ] ; modCount ++ ; for ( int i = oldCapacity - 1 ; i >= 0 ; i -- ) { MST[rv.CRCR4Mutator]MSP[]
cloned . putAll ( this ) ; return cloned ; } catch ( final CloneNotSupportedException ex ) { throw new InternalError () ; } } @Override public boolean equals ( final Object obj ) { if ( obj == this ) { return true ; MST[InlineConstantMutator]MSP[] }
final Iterator < Map . Entry < K , V > > it = createEntrySetIterator () ; while ( it . hasNext () ) { MST[rv.ROR1Mutator]MSP[] total += it . next () . hashCode () ; } return total ; } @Override public String toString () {
} } catch ( final ClassCastException ignored ) { return false ; } catch ( final NullPointerException ignored ) { return false ; } return true ; MST[rv.CRCR6Mutator]MSP[] } @Override public int hashCode () { int total = 0 ;
threshold = calculateThreshold ( newCapacity , loadFactor ) ; data = newEntries ; } } protected int calculateNewCapacity ( final int proposedCapacity ) { int newCapacity = 1 ; if ( proposedCapacity > MAXIMUM_CAPACITY ) { MST[rv.ROR1Mutator]MSP[] newCapacity = MAXIMUM_CAPACITY ; } else { while ( newCapacity < proposedCapacity ) {
if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { MST[rv.UOI1Mutator]MSP[] return true ; } entry = entry . next ; } return false ; } @Override public boolean containsValue ( final Object value ) { if ( value == null ) {
HashEntry < K , V > entry = data [ hashIndex ( hashCode , data . length ) ] ; while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { MST[rv.ABSMutator]MSP[]
final int index = hashIndex ( hashCode , data . length ) ; HashEntry < K , V > entry = data [ index ] ; MST[rv.UOI2Mutator]MSP[] HashEntry < K , V > previous = null ; while ( entry != null ) {
final int oldCapacity = data . length ; if ( newCapacity <= oldCapacity ) { MST[rv.ROR1Mutator]MSP[] return; } if ( size == 0 ) { threshold = calculateThreshold ( newCapacity , loadFactor ) ; data = new HashEntry [ newCapacity ] ; } else {
final Object convertedKey = convertKey ( key ) ; final int hashCode = hash ( convertedKey ) ; final int index = hashIndex ( hashCode , data . length ) ; MST[rv.UOI3Mutator]MSP[] HashEntry < K , V > entry = data [ index ] ;
newCapacity <<= 1 ; } if ( newCapacity > MAXIMUM_CAPACITY ) { newCapacity = MAXIMUM_CAPACITY ; } } return newCapacity ; MST[rv.UOI4Mutator]MSP[] } protected int calculateThreshold ( final int newCapacity , final float factor ) { return (int) ( newCapacity * factor ) ; }
final HashEntry < K , V > oldEntries [] = data ; final HashEntry < K , V > newEntries [] = new HashEntry [ newCapacity ] ; modCount ++ ; for ( int i = oldCapacity - 1 ; i >= 0 ; i -- ) { MST[rv.UOI1Mutator]MSP[]
HashEntry < K , V > entry = data [ hashIndex ( hashCode , data . length ) ] ; MST[rv.ABSMutator]MSP[] while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { return entry ; }
if ( obj instanceof Map == false ) { MST[rv.ROR1Mutator]MSP[] return false ; } final Map < ? , ? > map = ( Map < ? , ? > ) obj ; if ( map . size () != size () ) { return false ; }
if ( size >= threshold ) { final int newCapacity = data . length * 2 ; if ( newCapacity <= MAXIMUM_CAPACITY ) { MST[rv.UOI2Mutator]MSP[] ensureCapacity ( newCapacity ) ; } } } @SuppressWarnings ( lr_1 ) protected void ensureCapacity ( final int newCapacity ) {
data [ i ] = null ; } size = 0 ; MST[rv.CRCR6Mutator]MSP[] } protected Object convertKey ( final Object key ) { return key == null ? NULL : key ; } protected int hash ( final Object key ) { int h = key . hashCode () ;
h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; MST[rv.CRCR4Mutator]MSP[] h ^= h >>> 10 ; return h ; } protected boolean isEqualKey ( final Object key1 , final Object key2 ) {
protected int hashIndex ( final int hashCode , final int dataSize ) { return hashCode & dataSize - 1 ; MST[rv.CRCR5Mutator]MSP[] } protected HashEntry < K , V > getEntry ( Object key ) { key = convertKey ( key ) ; final int hashCode = hash ( key ) ;
for ( final MapIterator < K , V > it = mapIterator () ; it . hasNext () ; ) { MST[NonVoidMethodCallMutator]MSP[] out . writeObject ( it . next () ) ; out . writeObject ( it . getValue () ) ; } } @SuppressWarnings ( lr_1 )
HashEntry < K , V > entry = data [ hashIndex ( hashCode , data . length ) ] ; while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { MST[rv.UOI2Mutator]MSP[]
h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; MST[rv.AOR1Mutator]MSP[] h ^= h >>> 10 ; return h ; } protected boolean isEqualKey ( final Object key1 , final Object key2 ) {
data = new HashEntry [ capacity ] ; for ( int i = 0 ; i < size ; i ++ ) { MST[InlineConstantMutator]MSP[] final K key = ( K ) in . readObject () ; final V value = ( V ) in . readObject () ;
final int newSize = (int) ( ( size + mapSize ) / loadFactor + 1 ) ; MST[rv.UOI4Mutator]MSP[] ensureCapacity ( calculateNewCapacity ( newSize ) ) ; for ( final Map . Entry < ? extends K , ? extends V > entry : map . entrySet () ) {
final MapIterator < ? , ? > it = mapIterator () ; MST[NonVoidMethodCallMutator]MSP[] try { while ( it . hasNext () ) { final Object key = it . next () ; final Object value = it . getValue () ; if ( value == null ) {
h += ~ ( h << 9 ) ; h ^= h >>> 14 ; MST[rv.UOI2Mutator]MSP[] h += h << 4 ; h ^= h >>> 10 ; return h ; } protected boolean isEqualKey ( final Object key1 , final Object key2 ) {
if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { return true ; } entry = entry . next ; } return false ; MST[BooleanTrueReturnValsMutator]MSP[] } @Override public boolean containsValue ( final Object value ) { if ( value == null ) {
final HashEntry < K , V > oldEntries [] = data ; final HashEntry < K , V > newEntries [] = new HashEntry [ newCapacity ] ; modCount ++ ; MST[rv.AOR3Mutator]MSP[] for ( int i = oldCapacity - 1 ; i >= 0 ; i -- ) {
HashEntry < K , V > entry = data [ hashIndex ( hashCode , data . length ) ] ; MST[rv.UOI2Mutator]MSP[] while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { return entry ; }
} } catch ( final ClassCastException ignored ) { return false ; } catch ( final NullPointerException ignored ) { return false ; } return true ; } @Override public int hashCode () { int total = 0 ; MST[rv.CRCR1Mutator]MSP[]
return entry . getValue () ; MST[ReturnValsMutator]MSP[] } entry = entry . next ; } return null ; } @Override public int size () { return size ; } @Override public boolean isEmpty () { return size == 0 ; } @Override public boolean containsKey ( Object key ) {
newCapacity <<= 1 ; } if ( newCapacity > MAXIMUM_CAPACITY ) { MST[rv.ABSMutator]MSP[] newCapacity = MAXIMUM_CAPACITY ; } } return newCapacity ; } protected int calculateThreshold ( final int newCapacity , final float factor ) { return (int) ( newCapacity * factor ) ; }
private void _putAll ( final Map < ? extends K , ? extends V > map ) { final int mapSize = map . size () ; if ( mapSize == 0 ) { MST[rv.ABSMutator]MSP[] return; }
if ( size >= threshold ) { final int newCapacity = data . length * 2 ; if ( newCapacity <= MAXIMUM_CAPACITY ) { MST[InlineConstantMutator]MSP[] ensureCapacity ( newCapacity ) ; } } } @SuppressWarnings ( lr_1 ) protected void ensureCapacity ( final int newCapacity ) {
h += ~ ( h << 9 ) ; MST[rv.UOI3Mutator]MSP[] h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; return h ; } protected boolean isEqualKey ( final Object key1 , final Object key2 ) {
} return null ; } @Override public void clear () { modCount ++ ; MST[rv.AOD1Mutator]MSP[] final HashEntry < K , V > [] data = this . data ; for ( int i = data . length - 1 ; i >= 0 ; i -- ) {
final int index = hashIndex ( hashCode , data . length ) ; MST[ArgumentPropagationMutator]MSP[] HashEntry < K , V > entry = data [ index ] ; HashEntry < K , V > previous = null ; while ( entry != null ) {
protected void removeMapping ( final HashEntry < K , V > entry , final int hashIndex , final HashEntry < K , V > previous ) { modCount ++ ; MST[rv.CRCR5Mutator]MSP[] removeEntry ( entry , hashIndex , previous ) ; size -- ; destroyEntry ( entry ) ; }
if ( size >= threshold ) { final int newCapacity = data . length * 2 ; MST[rv.CRCR5Mutator]MSP[] if ( newCapacity <= MAXIMUM_CAPACITY ) { ensureCapacity ( newCapacity ) ; } } } @SuppressWarnings ( lr_1 ) protected void ensureCapacity ( final int newCapacity ) {
HashEntry < K , V > entry = data [ hashIndex ( hashCode , data . length ) ] ; while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { MST[rv.ROR1Mutator]MSP[]
if ( isEqualValue ( value , entry . getValue () ) ) { MST[rv.ROR1Mutator]MSP[] return true ; } entry = entry . next ; } } } return false ; } @Override public V put ( final K key , final V value ) {
final int oldCapacity = data . length ; if ( newCapacity <= oldCapacity ) { return; } if ( size == 0 ) { threshold = calculateThreshold ( newCapacity , loadFactor ) ; data = new HashEntry [ newCapacity ] ; MST[rv.ABSMutator]MSP[] } else {
h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; return h ; MST[rv.UOI4Mutator]MSP[] } protected boolean isEqualKey ( final Object key1 , final Object key2 ) {
return entry . getValue () ; } entry = entry . next ; } return null ; } @Override public int size () { return size ; MST[PrimitiveReturnsMutator]MSP[] } @Override public boolean isEmpty () { return size == 0 ; } @Override public boolean containsKey ( Object key ) {
protected int hashIndex ( final int hashCode , final int dataSize ) { return hashCode & dataSize - 1 ; MST[rv.UOI4Mutator]MSP[] } protected HashEntry < K , V > getEntry ( Object key ) { key = convertKey ( key ) ; final int hashCode = hash ( key ) ;
newCapacity <<= 1 ; } if ( newCapacity > MAXIMUM_CAPACITY ) { newCapacity = MAXIMUM_CAPACITY ; } } return newCapacity ; } protected int calculateThreshold ( final int newCapacity , final float factor ) { return (int) ( newCapacity * factor ) ; MST[rv.UOI2Mutator]MSP[] }
final int newSize = (int) ( ( size + mapSize ) / loadFactor + 1 ) ; MST[rv.CRCR5Mutator]MSP[] ensureCapacity ( calculateNewCapacity ( newSize ) ) ; for ( final Map . Entry < ? extends K , ? extends V > entry : map . entrySet () ) {
newCapacity <<= 1 ; } if ( newCapacity > MAXIMUM_CAPACITY ) { MST[InlineConstantMutator]MSP[] newCapacity = MAXIMUM_CAPACITY ; } } return newCapacity ; } protected int calculateThreshold ( final int newCapacity , final float factor ) { return (int) ( newCapacity * factor ) ; }
return key1 == key2 || key1 . equals ( key2 ) ; MST[rv.ROR3Mutator]MSP[] } protected boolean isEqualValue ( final Object value1 , final Object value2 ) { return value1 == value2 || value1 . equals ( value2 ) ; }
protected int hashIndex ( final int hashCode , final int dataSize ) { return hashCode & dataSize - 1 ; MST[rv.UOI1Mutator]MSP[] } protected HashEntry < K , V > getEntry ( Object key ) { key = convertKey ( key ) ; final int hashCode = hash ( key ) ;
final int oldCapacity = data . length ; if ( newCapacity <= oldCapacity ) { MST[rv.UOI4Mutator]MSP[] return; } if ( size == 0 ) { threshold = calculateThreshold ( newCapacity , loadFactor ) ; data = new HashEntry [ newCapacity ] ; } else {
if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { MST[NonVoidMethodCallMutator]MSP[] return true ; } entry = entry . next ; } return false ; } @Override public boolean containsValue ( final Object value ) { if ( value == null ) {
data = new HashEntry [ capacity ] ; for ( int i = 0 ; i < size ; i ++ ) { MST[rv.ROR5Mutator]MSP[] final K key = ( K ) in . readObject () ; final V value = ( V ) in . readObject () ;
h += ~ ( h << 9 ) ; MST[MathMutator]MSP[] h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; return h ; } protected boolean isEqualKey ( final Object key1 , final Object key2 ) {
if ( size >= threshold ) { final int newCapacity = data . length * 2 ; if ( newCapacity <= MAXIMUM_CAPACITY ) { ensureCapacity ( newCapacity ) ; MST[rv.UOI4Mutator]MSP[] } } } @SuppressWarnings ( lr_1 ) protected void ensureCapacity ( final int newCapacity ) {
final HashEntry < K , V > entry = createEntry ( data [ hashIndex ] , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; size ++ ; MST[InlineConstantMutator]MSP[] checkCapacity () ; }
return key1 == key2 || key1 . equals ( key2 ) ; } protected boolean isEqualValue ( final Object value1 , final Object value2 ) { return value1 == value2 || value1 . equals ( value2 ) ; MST[rv.ROR4Mutator]MSP[] }
protected void doReadObject ( final ObjectInputStream in ) throws IOException , ClassNotFoundException { loadFactor = in . readFloat () ; final int capacity = in . readInt () ; final int size = in . readInt () ; init () ; threshold = calculateThreshold ( capacity , loadFactor ) ; MST[rv.UOI3Mutator]MSP[]
private void _putAll ( final Map < ? extends K , ? extends V > map ) { final int mapSize = map . size () ; if ( mapSize == 0 ) { MST[rv.UOI2Mutator]MSP[] return; }
newCapacity <<= 1 ; } if ( newCapacity > MAXIMUM_CAPACITY ) { MST[rv.UOI2Mutator]MSP[] newCapacity = MAXIMUM_CAPACITY ; } } return newCapacity ; } protected int calculateThreshold ( final int newCapacity , final float factor ) { return (int) ( newCapacity * factor ) ; }
data = new HashEntry [ capacity ] ; for ( int i = 0 ; i < size ; i ++ ) { MST[ConditionalsBoundaryMutator]MSP[] final K key = ( K ) in . readObject () ; final V value = ( V ) in . readObject () ;
final int newSize = (int) ( ( size + mapSize ) / loadFactor + 1 ) ; MST[rv.AOR1Mutator]MSP[] ensureCapacity ( calculateNewCapacity ( newSize ) ) ; for ( final Map . Entry < ? extends K , ? extends V > entry : map . entrySet () ) {
threshold = calculateThreshold ( newCapacity , loadFactor ) ; data = newEntries ; } } protected int calculateNewCapacity ( final int proposedCapacity ) { int newCapacity = 1 ; if ( proposedCapacity > MAXIMUM_CAPACITY ) { MST[rv.UOI4Mutator]MSP[] newCapacity = MAXIMUM_CAPACITY ; } else { while ( newCapacity < proposedCapacity ) {
final int index = hashIndex ( hashCode , data . length ) ; HashEntry < K , V > entry = data [ index ] ; HashEntry < K , V > previous = null ; while ( entry != null ) { MST[rv.ROR5Mutator]MSP[]
final HashEntry < K , V > entry = createEntry ( data [ hashIndex ] , hashCode , key , value ) ; MST[rv.UOI2Mutator]MSP[] addEntry ( entry , hashIndex ) ; size ++ ; checkCapacity () ; }
final int oldCapacity = data . length ; if ( newCapacity <= oldCapacity ) { return; } if ( size == 0 ) { threshold = calculateThreshold ( newCapacity , loadFactor ) ; data = new HashEntry [ newCapacity ] ; MST[rv.UOI2Mutator]MSP[] } else {
} return null ; } @Override public void clear () { modCount ++ ; MST[rv.AOR3Mutator]MSP[] final HashEntry < K , V > [] data = this . data ; for ( int i = data . length - 1 ; i >= 0 ; i -- ) {
HashEntry < K , V > entry = data [ hashIndex ( hashCode , data . length ) ] ; while ( entry != null ) { MST[NegateConditionalsMutator]MSP[] if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { return entry ; }
} return null ; } @Override public void clear () { modCount ++ ; MST[rv.CRCR5Mutator]MSP[] final HashEntry < K , V > [] data = this . data ; for ( int i = data . length - 1 ; i >= 0 ; i -- ) {
public Set < K > keySet () { if ( keySet == null ) { MST[rv.ROR5Mutator]MSP[] keySet = new KeySet <> ( this ) ; } return keySet ; } protected Iterator < K > createKeySetIterator () { if ( size () == 0 ) {
} return null ; } @Override public void clear () { modCount ++ ; MST[rv.CRCR2Mutator]MSP[] final HashEntry < K , V > [] data = this . data ; for ( int i = data . length - 1 ; i >= 0 ; i -- ) {
while ( entry != null ) { MST[NegateConditionalsMutator]MSP[] if ( entry . hashCode == hashCode && isEqualKey ( convertedKey , entry . key ) ) { final V oldValue = entry . getValue () ; updateEntry ( entry , value ) ; return oldValue ; }
return key1 == key2 || key1 . equals ( key2 ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] } protected boolean isEqualValue ( final Object value1 , final Object value2 ) { return value1 == value2 || value1 . equals ( value2 ) ; }
protected int hashIndex ( final int hashCode , final int dataSize ) { return hashCode & dataSize - 1 ; } protected HashEntry < K , V > getEntry ( Object key ) { key = convertKey ( key ) ; MST[NonVoidMethodCallMutator]MSP[] final int hashCode = hash ( key ) ;
final Object convertedKey = convertKey ( key ) ; final int hashCode = hash ( convertedKey ) ; final int index = hashIndex ( hashCode , data . length ) ; HashEntry < K , V > entry = data [ index ] ; MST[rv.UOI2Mutator]MSP[]
h += ~ ( h << 9 ) ; h ^= h >>> 14 ; MST[InlineConstantMutator]MSP[] h += h << 4 ; h ^= h >>> 10 ; return h ; } protected boolean isEqualKey ( final Object key1 , final Object key2 ) {
final int newSize = (int) ( ( size + mapSize ) / loadFactor + 1 ) ; MST[rv.UOI1Mutator]MSP[] ensureCapacity ( calculateNewCapacity ( newSize ) ) ; for ( final Map . Entry < ? extends K , ? extends V > entry : map . entrySet () ) {
while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( convertedKey , entry . key ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] final V oldValue = entry . getValue () ; updateEntry ( entry , value ) ; return oldValue ; }
entry . key = key ; entry . value = value ; } protected void addMapping ( final int hashIndex , final int hashCode , final K key , final V value ) { modCount ++ ; MST[experimental.MemberVariableMutator]MSP[]
final int oldCapacity = data . length ; if ( newCapacity <= oldCapacity ) { return; } if ( size == 0 ) { threshold = calculateThreshold ( newCapacity , loadFactor ) ; data = new HashEntry [ newCapacity ] ; MST[experimental.MemberVariableMutator]MSP[] } else {
final HashEntry < K , V > entry = createEntry ( data [ hashIndex ] , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; size ++ ; MST[rv.UOI2Mutator]MSP[] checkCapacity () ; }
if ( size >= threshold ) { MST[rv.UOI3Mutator]MSP[] final int newCapacity = data . length * 2 ; if ( newCapacity <= MAXIMUM_CAPACITY ) { ensureCapacity ( newCapacity ) ; } } } @SuppressWarnings ( lr_1 ) protected void ensureCapacity ( final int newCapacity ) {
HashEntry < K , V > entry = data [ hashIndex ( hashCode , data . length ) ] ; MST[NonVoidMethodCallMutator]MSP[] while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { return entry ; }
if ( map . get ( key ) != null || map . containsKey ( key ) == false ) { return false ; } } else { if ( value . equals ( map . get ( key ) ) == false ) { return false ; MST[BooleanTrueReturnValsMutator]MSP[] } }
for ( final MapIterator < K , V > it = mapIterator () ; it . hasNext () ; ) { MST[rv.ROR3Mutator]MSP[] out . writeObject ( it . next () ) ; out . writeObject ( it . getValue () ) ; } } @SuppressWarnings ( lr_1 )
public Set < K > keySet () { if ( keySet == null ) { keySet = new KeySet <> ( this ) ; } return keySet ; } protected Iterator < K > createKeySetIterator () { if ( size () == 0 ) { MST[rv.ROR2Mutator]MSP[]
for ( final MapIterator < K , V > it = mapIterator () ; it . hasNext () ; ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] out . writeObject ( it . next () ) ; out . writeObject ( it . getValue () ) ; } } @SuppressWarnings ( lr_1 )
final int newSize = (int) ( ( size + mapSize ) / loadFactor + 1 ) ; MST[rv.AOD1Mutator]MSP[] ensureCapacity ( calculateNewCapacity ( newSize ) ) ; for ( final Map . Entry < ? extends K , ? extends V > entry : map . entrySet () ) {
final MapIterator < ? , ? > it = mapIterator () ; try { while ( it . hasNext () ) { MST[rv.ROR5Mutator]MSP[] final Object key = it . next () ; final Object value = it . getValue () ; if ( value == null ) {
public MapIterator < K , V > mapIterator () { if ( size == 0 ) { MST[rv.ROR4Mutator]MSP[] return EmptyMapIterator . <K , V > emptyMapIterator () ; } return new HashMapIterator <> ( this ) ; } @Override public K next () {
final HashEntry < K , V > entry = createEntry ( data [ hashIndex ] , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; size ++ ; MST[rv.CRCR4Mutator]MSP[] checkCapacity () ; }
public Set < K > keySet () { if ( keySet == null ) { keySet = new KeySet <> ( this ) ; MST[experimental.MemberVariableMutator]MSP[] } return keySet ; } protected Iterator < K > createKeySetIterator () { if ( size () == 0 ) {
HashEntry < K , V > entry = data [ hashIndex ( hashCode , data . length ) ] ; while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { MST[rv.UOI1Mutator]MSP[]
data = new HashEntry [ capacity ] ; MST[rv.ABSMutator]MSP[] for ( int i = 0 ; i < size ; i ++ ) { final K key = ( K ) in . readObject () ; final V value = ( V ) in . readObject () ;
final Object convertedKey = convertKey ( key ) ; final int hashCode = hash ( convertedKey ) ; final int index = hashIndex ( hashCode , data . length ) ; MST[ArgumentPropagationMutator]MSP[] HashEntry < K , V > entry = data [ index ] ;
while ( entry != null ) { MST[rv.ROR5Mutator]MSP[] if ( entry . hashCode == hashCode && isEqualKey ( convertedKey , entry . key ) ) { final V oldValue = entry . getValue () ; updateEntry ( entry , value ) ; return oldValue ; }
data [ i ] = null ; MST[rv.UOI2Mutator]MSP[] } size = 0 ; } protected Object convertKey ( final Object key ) { return key == null ? NULL : key ; } protected int hash ( final Object key ) { int h = key . hashCode () ;
final HashEntry < K , V > oldEntries [] = data ; final HashEntry < K , V > newEntries [] = new HashEntry [ newCapacity ] ; modCount ++ ; for ( int i = oldCapacity - 1 ; i >= 0 ; i -- ) { MST[rv.UOI4Mutator]MSP[]
if ( obj instanceof Map == false ) { MST[rv.ROR4Mutator]MSP[] return false ; } final Map < ? , ? > map = ( Map < ? , ? > ) obj ; if ( map . size () != size () ) { return false ; }
protected void removeMapping ( final HashEntry < K , V > entry , final int hashIndex , final HashEntry < K , V > previous ) { modCount ++ ; MST[rv.AOD1Mutator]MSP[] removeEntry ( entry , hashIndex , previous ) ; size -- ; destroyEntry ( entry ) ; }
if ( obj instanceof Map == false ) { return false ; } final Map < ? , ? > map = ( Map < ? , ? > ) obj ; if ( map . size () != size () ) { MST[rv.ROR4Mutator]MSP[] return false ; }
if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return true ; } entry = entry . next ; } return false ; } @Override public boolean containsValue ( final Object value ) { if ( value == null ) {
final HashEntry < K , V > entry = createEntry ( data [ hashIndex ] , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; size ++ ; MST[rv.ABSMutator]MSP[] checkCapacity () ; }
final int newSize = (int) ( ( size + mapSize ) / loadFactor + 1 ) ; MST[rv.AOD2Mutator]MSP[] ensureCapacity ( calculateNewCapacity ( newSize ) ) ; for ( final Map . Entry < ? extends K , ? extends V > entry : map . entrySet () ) {
if ( size >= threshold ) { final int newCapacity = data . length * 2 ; MST[rv.AOD1Mutator]MSP[] if ( newCapacity <= MAXIMUM_CAPACITY ) { ensureCapacity ( newCapacity ) ; } } } @SuppressWarnings ( lr_1 ) protected void ensureCapacity ( final int newCapacity ) {
protected void doWriteObject ( final ObjectOutputStream out ) throws IOException { out . writeFloat ( loadFactor ) ; out . writeInt ( data . length ) ; out . writeInt ( size ) ; MST[rv.UOI3Mutator]MSP[]
final HashEntry < K , V > entry = createEntry ( data [ hashIndex ] , hashCode , key , value ) ; MST[rv.UOI4Mutator]MSP[] addEntry ( entry , hashIndex ) ; size ++ ; checkCapacity () ; }
HashEntry < K , V > entry = data [ hashIndex ( hashCode , data . length ) ] ; while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { MST[rv.ROR2Mutator]MSP[]
HashEntry < K , V > entry = data [ hashIndex ( hashCode , data . length ) ] ; while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { MST[rv.ROR4Mutator]MSP[]
final int oldCapacity = data . length ; if ( newCapacity <= oldCapacity ) { return; } if ( size == 0 ) { MST[rv.ROR4Mutator]MSP[] threshold = calculateThreshold ( newCapacity , loadFactor ) ; data = new HashEntry [ newCapacity ] ; } else {
final int newSize = (int) ( ( size + mapSize ) / loadFactor + 1 ) ; MST[rv.AOR3Mutator]MSP[] ensureCapacity ( calculateNewCapacity ( newSize ) ) ; for ( final Map . Entry < ? extends K , ? extends V > entry : map . entrySet () ) {
final int oldCapacity = data . length ; if ( newCapacity <= oldCapacity ) { MST[rv.UOI3Mutator]MSP[] return; } if ( size == 0 ) { threshold = calculateThreshold ( newCapacity , loadFactor ) ; data = new HashEntry [ newCapacity ] ; } else {
protected HashEntry < K , V > createEntry ( final HashEntry < K , V > next , final int hashCode , final K key , final V value ) { return new HashEntry <> ( next , hashCode , convertKey ( key ) , value ) ; MST[ConstructorCallMutator]MSP[] }
protected HashEntry < K , V > createEntry ( final HashEntry < K , V > next , final int hashCode , final K key , final V value ) { return new HashEntry <> ( next , hashCode , convertKey ( key ) , value ) ; MST[ReturnValsMutator]MSP[] }
entry . key = key ; MST[experimental.MemberVariableMutator]MSP[] entry . value = value ; } protected void addMapping ( final int hashIndex , final int hashCode , final K key , final V value ) { modCount ++ ;
threshold = calculateThreshold ( newCapacity , loadFactor ) ; MST[rv.ABSMutator]MSP[] data = newEntries ; } } protected int calculateNewCapacity ( final int proposedCapacity ) { int newCapacity = 1 ; if ( proposedCapacity > MAXIMUM_CAPACITY ) { newCapacity = MAXIMUM_CAPACITY ; } else { while ( newCapacity < proposedCapacity ) {
} return null ; } @Override public void clear () { modCount ++ ; final HashEntry < K , V > [] data = this . data ; for ( int i = data . length - 1 ; i >= 0 ; i -- ) { MST[IncrementsMutator]MSP[]
return entry . getValue () ; } entry = entry . next ; } return null ; } @Override public int size () { return size ; } @Override public boolean isEmpty () { return size == 0 ; MST[rv.CRCR6Mutator]MSP[] } @Override public boolean containsKey ( Object key ) {
if ( size () == 0 ) { return lr_6 ; MST[ReturnValsMutator]MSP[] } final StringBuilder buf = new StringBuilder ( 32 * size () ) ; buf . append ( '{' ) ; final MapIterator < K , V > it = mapIterator () ;
final HashEntry < K , V > entry = createEntry ( data [ hashIndex ] , hashCode , key , value ) ; MST[rv.ABSMutator]MSP[] addEntry ( entry , hashIndex ) ; size ++ ; checkCapacity () ; }
h += ~ ( h << 9 ) ; MST[rv.UOI4Mutator]MSP[] h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; return h ; } protected boolean isEqualKey ( final Object key1 , final Object key2 ) {
h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; MST[rv.CRCR1Mutator]MSP[] h ^= h >>> 10 ; return h ; } protected boolean isEqualKey ( final Object key1 , final Object key2 ) {
put ( entry . getKey () , entry . getValue () ) ; MST[ArgumentPropagationMutator]MSP[] } } @Override public V remove ( Object key ) { key = convertKey ( key ) ; final int hashCode = hash ( key ) ;
final int oldCapacity = data . length ; if ( newCapacity <= oldCapacity ) { return; } if ( size == 0 ) { threshold = calculateThreshold ( newCapacity , loadFactor ) ; MST[rv.UOI3Mutator]MSP[] data = new HashEntry [ newCapacity ] ; } else {
if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { MST[rv.ROR4Mutator]MSP[] final V oldValue = entry . getValue () ; removeMapping ( entry , index , previous ) ; return oldValue ; } previous = entry ; entry = entry . next ;
final HashEntry < K , V > oldEntries [] = data ; final HashEntry < K , V > newEntries [] = new HashEntry [ newCapacity ] ; modCount ++ ; MST[rv.CRCR2Mutator]MSP[] for ( int i = oldCapacity - 1 ; i >= 0 ; i -- ) {
threshold = calculateThreshold ( newCapacity , loadFactor ) ; data = newEntries ; } } protected int calculateNewCapacity ( final int proposedCapacity ) { int newCapacity = 1 ; if ( proposedCapacity > MAXIMUM_CAPACITY ) { newCapacity = MAXIMUM_CAPACITY ; } else { while ( newCapacity < proposedCapacity ) { MST[rv.UOI1Mutator]MSP[]
protected HashEntry < K , V > createEntry ( final HashEntry < K , V > next , final int hashCode , final K key , final V value ) { return new HashEntry <> ( next , hashCode , convertKey ( key ) , value ) ; MST[rv.UOI3Mutator]MSP[] }
final int newSize = (int) ( ( size + mapSize ) / loadFactor + 1 ) ; ensureCapacity ( calculateNewCapacity ( newSize ) ) ; for ( final Map . Entry < ? extends K , ? extends V > entry : map . entrySet () ) { MST[NonVoidMethodCallMutator]MSP[]
data = new HashEntry [ capacity ] ; for ( int i = 0 ; i < size ; i ++ ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] final K key = ( K ) in . readObject () ; final V value = ( V ) in . readObject () ;
cloned . putAll ( this ) ; return cloned ; } catch ( final CloneNotSupportedException ex ) { throw new InternalError () ; } } @Override public boolean equals ( final Object obj ) { if ( obj == this ) { MST[rv.ROR5Mutator]MSP[] return true ; }
protected void removeMapping ( final HashEntry < K , V > entry , final int hashIndex , final HashEntry < K , V > previous ) { modCount ++ ; removeEntry ( entry , hashIndex , previous ) ; size -- ; MST[rv.AOR4Mutator]MSP[] destroyEntry ( entry ) ; }
HashEntry < K , V > entry = data [ hashIndex ( hashCode , data . length ) ] ; while ( entry != null ) { MST[rv.ROR5Mutator]MSP[] if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { return entry ; }
final int index = hashIndex ( hashCode , data . length ) ; MST[rv.UOI3Mutator]MSP[] HashEntry < K , V > entry = data [ index ] ; HashEntry < K , V > previous = null ; while ( entry != null ) {
if ( size >= threshold ) { final int newCapacity = data . length * 2 ; if ( newCapacity <= MAXIMUM_CAPACITY ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[] ensureCapacity ( newCapacity ) ; } } } @SuppressWarnings ( lr_1 ) protected void ensureCapacity ( final int newCapacity ) {
h += ~ ( h << 9 ) ; h ^= h >>> 14 ; MST[rv.UOI3Mutator]MSP[] h += h << 4 ; h ^= h >>> 10 ; return h ; } protected boolean isEqualKey ( final Object key1 , final Object key2 ) {
final int index = hashIndex ( entry . hashCode , newCapacity ) ; MST[rv.ABSMutator]MSP[] entry . next = newEntries [ index ] ; newEntries [ index ] = entry ; entry = next ; } while ( entry != null ); } }
final MapIterator < ? , ? > it = mapIterator () ; try { while ( it . hasNext () ) { MST[NegateConditionalsMutator]MSP[] final Object key = it . next () ; final Object value = it . getValue () ; if ( value == null ) {
final int newSize = (int) ( ( size + mapSize ) / loadFactor + 1 ) ; MST[rv.AOR1Mutator]MSP[] ensureCapacity ( calculateNewCapacity ( newSize ) ) ; for ( final Map . Entry < ? extends K , ? extends V > entry : map . entrySet () ) {
cloned . data = new HashEntry [ data . length ] ; cloned . entrySet = null ; cloned . keySet = null ; cloned . values = null ; cloned . modCount = 0 ; cloned . size = 0 ; MST[rv.CRCR3Mutator]MSP[] cloned . init () ;
if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { return true ; } entry = entry . next ; } return false ; MST[ReturnValsMutator]MSP[] } @Override public boolean containsValue ( final Object value ) { if ( value == null ) {
private void _putAll ( final Map < ? extends K , ? extends V > map ) { final int mapSize = map . size () ; if ( mapSize == 0 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return; }
h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; MST[rv.UOI3Mutator]MSP[] return h ; } protected boolean isEqualKey ( final Object key1 , final Object key2 ) {
entry = entry . next ; } } } else { for ( final HashEntry < K , V > element : data ) { MST[rv.UOI3Mutator]MSP[] HashEntry < K , V > entry = element ; while ( entry != null ) {
data = new HashEntry [ capacity ] ; for ( int i = 0 ; i < size ; i ++ ) { MST[NegateConditionalsMutator]MSP[] final K key = ( K ) in . readObject () ; final V value = ( V ) in . readObject () ;
return key1 == key2 || key1 . equals ( key2 ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] } protected boolean isEqualValue ( final Object value1 , final Object value2 ) { return value1 == value2 || value1 . equals ( value2 ) ; }
protected void doReadObject ( final ObjectInputStream in ) throws IOException , ClassNotFoundException { loadFactor = in . readFloat () ; final int capacity = in . readInt () ; final int size = in . readInt () ; init () ; threshold = calculateThreshold ( capacity , loadFactor ) ; MST[NonVoidMethodCallMutator]MSP[]
final HashEntry < K , V > oldEntries [] = data ; final HashEntry < K , V > newEntries [] = new HashEntry [ newCapacity ] ; modCount ++ ; for ( int i = oldCapacity - 1 ; i >= 0 ; i -- ) { MST[rv.ROR2Mutator]MSP[]
protected void doWriteObject ( final ObjectOutputStream out ) throws IOException { out . writeFloat ( loadFactor ) ; out . writeInt ( data . length ) ; MST[VoidMethodCallMutator]MSP[] out . writeInt ( size ) ;
final int newSize = (int) ( ( size + mapSize ) / loadFactor + 1 ) ; MST[rv.UOI1Mutator]MSP[] ensureCapacity ( calculateNewCapacity ( newSize ) ) ; for ( final Map . Entry < ? extends K , ? extends V > entry : map . entrySet () ) {
protected void removeMapping ( final HashEntry < K , V > entry , final int hashIndex , final HashEntry < K , V > previous ) { modCount ++ ; removeEntry ( entry , hashIndex , previous ) ; size -- ; MST[rv.ABSMutator]MSP[] destroyEntry ( entry ) ; }
protected int hashIndex ( final int hashCode , final int dataSize ) { return hashCode & dataSize - 1 ; MST[rv.CRCR2Mutator]MSP[] } protected HashEntry < K , V > getEntry ( Object key ) { key = convertKey ( key ) ; final int hashCode = hash ( key ) ;
if ( map . get ( key ) != null || map . containsKey ( key ) == false ) { return false ; } } else { if ( value . equals ( map . get ( key ) ) == false ) { return false ; MST[rv.CRCR6Mutator]MSP[] } }
entry = entry . next ; } } } else { for ( final HashEntry < K , V > element : data ) { MST[rv.UOI4Mutator]MSP[] HashEntry < K , V > entry = element ; while ( entry != null ) {
protected void reuseEntry ( final HashEntry < K , V > entry , final int hashIndex , final int hashCode , final K key , final V value ) { entry . next = data [ hashIndex ] ; MST[rv.UOI3Mutator]MSP[] entry . hashCode = hashCode ;
HashEntry < K , V > entry = data [ hashIndex ( hashCode , data . length ) ] ; while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return entry ; }
if ( obj instanceof Map == false ) { return false ; } final Map < ? , ? > map = ( Map < ? , ? > ) obj ; if ( map . size () != size () ) { return false ; MST[rv.CRCR3Mutator]MSP[] }
entry = entry . next ; } } } else { for ( final HashEntry < K , V > element : data ) { MST[rv.UOI4Mutator]MSP[] HashEntry < K , V > entry = element ; while ( entry != null ) {
} return null ; } @Override public void clear () { modCount ++ ; final HashEntry < K , V > [] data = this . data ; for ( int i = data . length - 1 ; i >= 0 ; i -- ) { MST[rv.ROR1Mutator]MSP[]
threshold = calculateThreshold ( newCapacity , loadFactor ) ; data = newEntries ; } } protected int calculateNewCapacity ( final int proposedCapacity ) { int newCapacity = 1 ; if ( proposedCapacity > MAXIMUM_CAPACITY ) { MST[rv.CRCR6Mutator]MSP[] newCapacity = MAXIMUM_CAPACITY ; } else { while ( newCapacity < proposedCapacity ) {
data = new HashEntry [ capacity ] ; for ( int i = 0 ; i < size ; i ++ ) { MST[rv.UOI1Mutator]MSP[] final K key = ( K ) in . readObject () ; final V value = ( V ) in . readObject () ;
if ( map . get ( key ) != null || map . containsKey ( key ) == false ) { return false ; } } else { if ( value . equals ( map . get ( key ) ) == false ) { MST[NegateConditionalsMutator]MSP[] return false ; } }
protected void reuseEntry ( final HashEntry < K , V > entry , final int hashIndex , final int hashCode , final K key , final V value ) { entry . next = data [ hashIndex ] ; entry . hashCode = hashCode ; MST[experimental.MemberVariableMutator]MSP[]
public MapIterator < K , V > mapIterator () { if ( size == 0 ) { return EmptyMapIterator . <K , V > emptyMapIterator () ; MST[ReturnValsMutator]MSP[] } return new HashMapIterator <> ( this ) ; } @Override public K next () {
HashEntry < K , V > entry = data [ hashIndex ( hashCode , data . length ) ] ; while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { MST[rv.ROR1Mutator]MSP[] return entry ; }
entry = entry . next ; } } } else { for ( final HashEntry < K , V > element : data ) { MST[rv.UOI1Mutator]MSP[] HashEntry < K , V > entry = element ; while ( entry != null ) {
protected void doReadObject ( final ObjectInputStream in ) throws IOException , ClassNotFoundException { loadFactor = in . readFloat () ; final int capacity = in . readInt () ; final int size = in . readInt () ; init () ; threshold = calculateThreshold ( capacity , loadFactor ) ; MST[rv.UOI1Mutator]MSP[]
final int oldCapacity = data . length ; if ( newCapacity <= oldCapacity ) { return; } if ( size == 0 ) { MST[rv.ROR1Mutator]MSP[] threshold = calculateThreshold ( newCapacity , loadFactor ) ; data = new HashEntry [ newCapacity ] ; } else {
final int oldCapacity = data . length ; if ( newCapacity <= oldCapacity ) { return; } if ( size == 0 ) { threshold = calculateThreshold ( newCapacity , loadFactor ) ; MST[NonVoidMethodCallMutator]MSP[] data = new HashEntry [ newCapacity ] ; } else {
h += ~ ( h << 9 ) ; MST[rv.AOR3Mutator]MSP[] h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; return h ; } protected boolean isEqualKey ( final Object key1 , final Object key2 ) {
final int newSize = (int) ( ( size + mapSize ) / loadFactor + 1 ) ; MST[rv.AOD2Mutator]MSP[] ensureCapacity ( calculateNewCapacity ( newSize ) ) ; for ( final Map . Entry < ? extends K , ? extends V > entry : map . entrySet () ) {
if ( obj instanceof Map == false ) { return false ; } final Map < ? , ? > map = ( Map < ? , ? > ) obj ; if ( map . size () != size () ) { return false ; MST[BooleanTrueReturnValsMutator]MSP[] }
protected int hashIndex ( final int hashCode , final int dataSize ) { return hashCode & dataSize - 1 ; MST[rv.OBBN1Mutator]MSP[] } protected HashEntry < K , V > getEntry ( Object key ) { key = convertKey ( key ) ; final int hashCode = hash ( key ) ;
final int newSize = (int) ( ( size + mapSize ) / loadFactor + 1 ) ; MST[rv.ABSMutator]MSP[] ensureCapacity ( calculateNewCapacity ( newSize ) ) ; for ( final Map . Entry < ? extends K , ? extends V > entry : map . entrySet () ) {
h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; MST[rv.UOI2Mutator]MSP[] h ^= h >>> 10 ; return h ; } protected boolean isEqualKey ( final Object key1 , final Object key2 ) {
final int newSize = (int) ( ( size + mapSize ) / loadFactor + 1 ) ; MST[rv.AOR4Mutator]MSP[] ensureCapacity ( calculateNewCapacity ( newSize ) ) ; for ( final Map . Entry < ? extends K , ? extends V > entry : map . entrySet () ) {
if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { MST[NegateConditionalsMutator]MSP[] return true ; } entry = entry . next ; } return false ; } @Override public boolean containsValue ( final Object value ) { if ( value == null ) {
protected void removeMapping ( final HashEntry < K , V > entry , final int hashIndex , final HashEntry < K , V > previous ) { modCount ++ ; removeEntry ( entry , hashIndex , previous ) ; MST[rv.UOI1Mutator]MSP[] size -- ; destroyEntry ( entry ) ; }
final Iterator < Map . Entry < K , V > > it = createEntrySetIterator () ; while ( it . hasNext () ) { total += it . next () . hashCode () ; MST[rv.UOI3Mutator]MSP[] } return total ; } @Override public String toString () {
entry = entry . next ; } addMapping ( index , hashCode , key , value ) ; MST[rv.UOI3Mutator]MSP[] return null ; } @Override public void putAll ( final Map < ? extends K , ? extends V > map ) { _putAll ( map ) ; }
if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { MST[rv.UOI3Mutator]MSP[] return true ; } entry = entry . next ; } return false ; } @Override public boolean containsValue ( final Object value ) { if ( value == null ) {
return key1 == key2 || key1 . equals ( key2 ) ; } protected boolean isEqualValue ( final Object value1 , final Object value2 ) { return value1 == value2 || value1 . equals ( value2 ) ; MST[rv.ROR1Mutator]MSP[] }
h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; return h ; MST[PrimitiveReturnsMutator]MSP[] } protected boolean isEqualKey ( final Object key1 , final Object key2 ) {
h += ~ ( h << 9 ) ; h ^= h >>> 14 ; MST[rv.CRCR4Mutator]MSP[] h += h << 4 ; h ^= h >>> 10 ; return h ; } protected boolean isEqualKey ( final Object key1 , final Object key2 ) {
if ( size >= threshold ) { final int newCapacity = data . length * 2 ; if ( newCapacity <= MAXIMUM_CAPACITY ) { ensureCapacity ( newCapacity ) ; MST[rv.UOI1Mutator]MSP[] } } } @SuppressWarnings ( lr_1 ) protected void ensureCapacity ( final int newCapacity ) {
if ( map . get ( key ) != null || map . containsKey ( key ) == false ) { return false ; } } else { if ( value . equals ( map . get ( key ) ) == false ) { return false ; MST[ReturnValsMutator]MSP[] } }
final int index = hashIndex ( entry . hashCode , newCapacity ) ; entry . next = newEntries [ index ] ; newEntries [ index ] = entry ; MST[rv.ABSMutator]MSP[] entry = next ; } while ( entry != null ); } }
if ( map . get ( key ) != null || map . containsKey ( key ) == false ) { return false ; } } else { if ( value . equals ( map . get ( key ) ) == false ) { MST[rv.ROR5Mutator]MSP[] return false ; } }
if ( map . get ( key ) != null || map . containsKey ( key ) == false ) { return false ; } } else { if ( value . equals ( map . get ( key ) ) == false ) { MST[rv.ROR1Mutator]MSP[] return false ; } }
protected void doWriteObject ( final ObjectOutputStream out ) throws IOException { out . writeFloat ( loadFactor ) ; MST[rv.UOI3Mutator]MSP[] out . writeInt ( data . length ) ; out . writeInt ( size ) ;
protected Iterator < Map . Entry < K , V > > createEntrySetIterator () { if ( size () == 0 ) { MST[rv.ROR1Mutator]MSP[] return EmptyIterator . < Map . Entry < K , V > > emptyIterator () ; } return new EntrySetIterator <> ( this ) ; } @Override
return entry . getValue () ; } entry = entry . next ; } return null ; } @Override public int size () { return size ; } @Override public boolean isEmpty () { return size == 0 ; MST[rv.CRCR2Mutator]MSP[] } @Override public boolean containsKey ( Object key ) {
final int oldCapacity = data . length ; if ( newCapacity <= oldCapacity ) { return; } if ( size == 0 ) { threshold = calculateThreshold ( newCapacity , loadFactor ) ; MST[rv.ABSMutator]MSP[] data = new HashEntry [ newCapacity ] ; } else {
newCapacity <<= 1 ; } if ( newCapacity > MAXIMUM_CAPACITY ) { newCapacity = MAXIMUM_CAPACITY ; } } return newCapacity ; } protected int calculateThreshold ( final int newCapacity , final float factor ) { return (int) ( newCapacity * factor ) ; MST[rv.UOI3Mutator]MSP[] }
if ( obj instanceof Map == false ) { return false ; MST[rv.CRCR3Mutator]MSP[] } final Map < ? , ? > map = ( Map < ? , ? > ) obj ; if ( map . size () != size () ) { return false ; }
if ( size () == 0 ) { MST[rv.ROR4Mutator]MSP[] return lr_6 ; } final StringBuilder buf = new StringBuilder ( 32 * size () ) ; buf . append ( '{' ) ; final MapIterator < K , V > it = mapIterator () ;
protected int hashIndex ( final int hashCode , final int dataSize ) { return hashCode & dataSize - 1 ; MST[MathMutator]MSP[] } protected HashEntry < K , V > getEntry ( Object key ) { key = convertKey ( key ) ; final int hashCode = hash ( key ) ;
final int index = hashIndex ( entry . hashCode , newCapacity ) ; MST[rv.UOI2Mutator]MSP[] entry . next = newEntries [ index ] ; newEntries [ index ] = entry ; entry = next ; } while ( entry != null ); } }
newCapacity <<= 1 ; MST[rv.ABSMutator]MSP[] } if ( newCapacity > MAXIMUM_CAPACITY ) { newCapacity = MAXIMUM_CAPACITY ; } } return newCapacity ; } protected int calculateThreshold ( final int newCapacity , final float factor ) { return (int) ( newCapacity * factor ) ; }
private void _putAll ( final Map < ? extends K , ? extends V > map ) { final int mapSize = map . size () ; MST[NonVoidMethodCallMutator]MSP[] if ( mapSize == 0 ) { return; }
final int oldCapacity = data . length ; if ( newCapacity <= oldCapacity ) { return; } if ( size == 0 ) { threshold = calculateThreshold ( newCapacity , loadFactor ) ; MST[rv.UOI2Mutator]MSP[] data = new HashEntry [ newCapacity ] ; } else {
HashEntry < K , V > entry = data [ hashIndex ( hashCode , data . length ) ] ; while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { MST[rv.UOI4Mutator]MSP[] return entry ; }
final Iterator < Map . Entry < K , V > > it = createEntrySetIterator () ; while ( it . hasNext () ) { total += it . next () . hashCode () ; } return total ; MST[rv.UOI1Mutator]MSP[] } @Override public String toString () {
HashEntry < K , V > entry = data [ hashIndex ( hashCode , data . length ) ] ; while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { MST[NegateConditionalsMutator]MSP[]
protected void removeMapping ( final HashEntry < K , V > entry , final int hashIndex , final HashEntry < K , V > previous ) { modCount ++ ; removeEntry ( entry , hashIndex , previous ) ; size -- ; MST[rv.UOI2Mutator]MSP[] destroyEntry ( entry ) ; }
if ( size >= threshold ) { final int newCapacity = data . length * 2 ; MST[rv.AOR3Mutator]MSP[] if ( newCapacity <= MAXIMUM_CAPACITY ) { ensureCapacity ( newCapacity ) ; } } } @SuppressWarnings ( lr_1 ) protected void ensureCapacity ( final int newCapacity ) {
return key1 == key2 || key1 . equals ( key2 ) ; MST[rv.CRCR1Mutator]MSP[] } protected boolean isEqualValue ( final Object value1 , final Object value2 ) { return value1 == value2 || value1 . equals ( value2 ) ; }
cloned . putAll ( this ) ; return cloned ; } catch ( final CloneNotSupportedException ex ) { throw new InternalError () ; } } @Override public boolean equals ( final Object obj ) { if ( obj == this ) { return true ; MST[BooleanFalseReturnValsMutator]MSP[] }
while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( convertedKey , entry . key ) ) { MST[rv.ABSMutator]MSP[] final V oldValue = entry . getValue () ; updateEntry ( entry , value ) ; return oldValue ; }
final HashEntry < K , V > entry = createEntry ( data [ hashIndex ] , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; size ++ ; MST[experimental.MemberVariableMutator]MSP[] checkCapacity () ; }
final HashEntry < K , V > oldEntries [] = data ; final HashEntry < K , V > newEntries [] = new HashEntry [ newCapacity ] ; modCount ++ ; for ( int i = oldCapacity - 1 ; i >= 0 ; i -- ) { MST[InlineConstantMutator]MSP[]
cloned . putAll ( this ) ; return cloned ; } catch ( final CloneNotSupportedException ex ) { throw new InternalError () ; } } @Override public boolean equals ( final Object obj ) { if ( obj == this ) { return true ; MST[rv.CRCR4Mutator]MSP[] }
return key1 == key2 || key1 . equals ( key2 ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] } protected boolean isEqualValue ( final Object value1 , final Object value2 ) { return value1 == value2 || value1 . equals ( value2 ) ; }
} return null ; } @Override public void clear () { modCount ++ ; final HashEntry < K , V > [] data = this . data ; for ( int i = data . length - 1 ; i >= 0 ; i -- ) { MST[rv.CRCR3Mutator]MSP[]
return key1 == key2 || key1 . equals ( key2 ) ; } protected boolean isEqualValue ( final Object value1 , final Object value2 ) { return value1 == value2 || value1 . equals ( value2 ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] }
while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( convertedKey , entry . key ) ) { MST[rv.UOI3Mutator]MSP[] final V oldValue = entry . getValue () ; updateEntry ( entry , value ) ; return oldValue ; }
if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { MST[rv.ROR1Mutator]MSP[] return true ; } entry = entry . next ; } return false ; } @Override public boolean containsValue ( final Object value ) { if ( value == null ) {
final int index = hashIndex ( entry . hashCode , newCapacity ) ; entry . next = newEntries [ index ] ; newEntries [ index ] = entry ; MST[rv.UOI2Mutator]MSP[] entry = next ; } while ( entry != null ); } }
entry . key = key ; entry . value = value ; } protected void addMapping ( final int hashIndex , final int hashCode , final K key , final V value ) { modCount ++ ; MST[rv.ABSMutator]MSP[]
entry = entry . next ; } return null ; } protected void updateEntry ( final HashEntry < K , V > entry , final V newValue ) { entry . setValue ( newValue ) ; MST[NonVoidMethodCallMutator]MSP[] }
newCapacity <<= 1 ; MST[rv.UOI2Mutator]MSP[] } if ( newCapacity > MAXIMUM_CAPACITY ) { newCapacity = MAXIMUM_CAPACITY ; } } return newCapacity ; } protected int calculateThreshold ( final int newCapacity , final float factor ) { return (int) ( newCapacity * factor ) ; }
if ( size >= threshold ) { final int newCapacity = data . length * 2 ; if ( newCapacity <= MAXIMUM_CAPACITY ) { MST[rv.CRCR4Mutator]MSP[] ensureCapacity ( newCapacity ) ; } } } @SuppressWarnings ( lr_1 ) protected void ensureCapacity ( final int newCapacity ) {
h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; MST[rv.AOD2Mutator]MSP[] h ^= h >>> 10 ; return h ; } protected boolean isEqualKey ( final Object key1 , final Object key2 ) {
HashEntry < K , V > entry = data [ hashIndex ( hashCode , data . length ) ] ; while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { MST[rv.ROR3Mutator]MSP[] return entry ; }
if ( isEqualValue ( value , entry . getValue () ) ) { return true ; } entry = entry . next ; } } } return false ; MST[rv.CRCR3Mutator]MSP[] } @Override public V put ( final K key , final V value ) {
h += ~ ( h << 9 ) ; MST[rv.CRCR5Mutator]MSP[] h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; return h ; } protected boolean isEqualKey ( final Object key1 , final Object key2 ) {
if ( size >= threshold ) { final int newCapacity = data . length * 2 ; if ( newCapacity <= MAXIMUM_CAPACITY ) { MST[rv.CRCR1Mutator]MSP[] ensureCapacity ( newCapacity ) ; } } } @SuppressWarnings ( lr_1 ) protected void ensureCapacity ( final int newCapacity ) {
return key1 == key2 || key1 . equals ( key2 ) ; } protected boolean isEqualValue ( final Object value1 , final Object value2 ) { return value1 == value2 || value1 . equals ( value2 ) ; MST[rv.CRCR6Mutator]MSP[] }
cloned . data = new HashEntry [ data . length ] ; cloned . entrySet = null ; cloned . keySet = null ; cloned . values = null ; cloned . modCount = 0 ; MST[rv.CRCR3Mutator]MSP[] cloned . size = 0 ; cloned . init () ;
entry . key = key ; entry . value = value ; } protected void addMapping ( final int hashIndex , final int hashCode , final K key , final V value ) { modCount ++ ; MST[MathMutator]MSP[]
final Iterator < Map . Entry < K , V > > it = createEntrySetIterator () ; while ( it . hasNext () ) { total += it . next () . hashCode () ; } return total ; MST[rv.ABSMutator]MSP[] } @Override public String toString () {
if ( size () == 0 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return lr_6 ; } final StringBuilder buf = new StringBuilder ( 32 * size () ) ; buf . append ( '{' ) ; final MapIterator < K , V > it = mapIterator () ;
final HashEntry < K , V > oldEntries [] = data ; final HashEntry < K , V > newEntries [] = new HashEntry [ newCapacity ] ; modCount ++ ; for ( int i = oldCapacity - 1 ; i >= 0 ; i -- ) { MST[rv.AOR2Mutator]MSP[]
entry . key = key ; entry . value = value ; } protected void addMapping ( final int hashIndex , final int hashCode , final K key , final V value ) { modCount ++ ; MST[InlineConstantMutator]MSP[]
h += ~ ( h << 9 ) ; MST[InlineConstantMutator]MSP[] h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; return h ; } protected boolean isEqualKey ( final Object key1 , final Object key2 ) {
h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; MST[MathMutator]MSP[] return h ; } protected boolean isEqualKey ( final Object key1 , final Object key2 ) {
protected void removeMapping ( final HashEntry < K , V > entry , final int hashIndex , final HashEntry < K , V > previous ) { modCount ++ ; removeEntry ( entry , hashIndex , previous ) ; size -- ; MST[rv.AOD2Mutator]MSP[] destroyEntry ( entry ) ; }
protected void removeMapping ( final HashEntry < K , V > entry , final int hashIndex , final HashEntry < K , V > previous ) { modCount ++ ; MST[rv.AOR3Mutator]MSP[] removeEntry ( entry , hashIndex , previous ) ; size -- ; destroyEntry ( entry ) ; }
return entry . getValue () ; } entry = entry . next ; } return null ; } @Override public int size () { return size ; } @Override public boolean isEmpty () { return size == 0 ; MST[rv.ROR2Mutator]MSP[] } @Override public boolean containsKey ( Object key ) {
final HashEntry < K , V > entry = createEntry ( data [ hashIndex ] , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; size ++ ; MST[rv.AOR2Mutator]MSP[] checkCapacity () ; }
final HashEntry < K , V > oldEntries [] = data ; final HashEntry < K , V > newEntries [] = new HashEntry [ newCapacity ] ; MST[rv.UOI3Mutator]MSP[] modCount ++ ; for ( int i = oldCapacity - 1 ; i >= 0 ; i -- ) {
if ( obj instanceof Map == false ) { return false ; MST[BooleanTrueReturnValsMutator]MSP[] } final Map < ? , ? > map = ( Map < ? , ? > ) obj ; if ( map . size () != size () ) { return false ; }
cloned . data = new HashEntry [ data . length ] ; cloned . entrySet = null ; cloned . keySet = null ; cloned . values = null ; cloned . modCount = 0 ; MST[InlineConstantMutator]MSP[] cloned . size = 0 ; cloned . init () ;
} return null ; } @Override public void clear () { modCount ++ ; final HashEntry < K , V > [] data = this . data ; for ( int i = data . length - 1 ; i >= 0 ; i -- ) { MST[rv.CRCR6Mutator]MSP[]
protected void reuseEntry ( final HashEntry < K , V > entry , final int hashIndex , final int hashCode , final K key , final V value ) { entry . next = data [ hashIndex ] ; entry . hashCode = hashCode ; MST[rv.UOI1Mutator]MSP[]
HashEntry < K , V > entry = data [ hashIndex ( hashCode , data . length ) ] ; while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { MST[rv.UOI4Mutator]MSP[]
if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { final V oldValue = entry . getValue () ; removeMapping ( entry , index , previous ) ; return oldValue ; MST[ReturnValsMutator]MSP[] } previous = entry ; entry = entry . next ;
return key1 == key2 || key1 . equals ( key2 ) ; } protected boolean isEqualValue ( final Object value1 , final Object value2 ) { return value1 == value2 || value1 . equals ( value2 ) ; MST[rv.CRCR3Mutator]MSP[] }
protected void reuseEntry ( final HashEntry < K , V > entry , final int hashIndex , final int hashCode , final K key , final V value ) { entry . next = data [ hashIndex ] ; entry . hashCode = hashCode ; MST[rv.ABSMutator]MSP[]
if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { MST[rv.UOI4Mutator]MSP[] return true ; } entry = entry . next ; } return false ; } @Override public boolean containsValue ( final Object value ) { if ( value == null ) {
final Iterator < Map . Entry < K , V > > it = createEntrySetIterator () ; while ( it . hasNext () ) { MST[rv.ROR4Mutator]MSP[] total += it . next () . hashCode () ; } return total ; } @Override public String toString () {
final int oldCapacity = data . length ; if ( newCapacity <= oldCapacity ) { return; } if ( size == 0 ) { MST[rv.UOI3Mutator]MSP[] threshold = calculateThreshold ( newCapacity , loadFactor ) ; data = new HashEntry [ newCapacity ] ; } else {
return key1 == key2 || key1 . equals ( key2 ) ; MST[NonVoidMethodCallMutator]MSP[] } protected boolean isEqualValue ( final Object value1 , final Object value2 ) { return value1 == value2 || value1 . equals ( value2 ) ; }
} } catch ( final ClassCastException ignored ) { return false ; } catch ( final NullPointerException ignored ) { return false ; } return true ; MST[rv.CRCR3Mutator]MSP[] } @Override public int hashCode () { int total = 0 ;
threshold = calculateThreshold ( newCapacity , loadFactor ) ; MST[NonVoidMethodCallMutator]MSP[] data = newEntries ; } } protected int calculateNewCapacity ( final int proposedCapacity ) { int newCapacity = 1 ; if ( proposedCapacity > MAXIMUM_CAPACITY ) { newCapacity = MAXIMUM_CAPACITY ; } else { while ( newCapacity < proposedCapacity ) {
} return null ; } @Override public void clear () { modCount ++ ; final HashEntry < K , V > [] data = this . data ; for ( int i = data . length - 1 ; i >= 0 ; i -- ) { MST[rv.ROR4Mutator]MSP[]
if ( obj instanceof Map == false ) { return false ; } final Map < ? , ? > map = ( Map < ? , ? > ) obj ; if ( map . size () != size () ) { return false ; MST[rv.CRCR6Mutator]MSP[] }
protected int hashIndex ( final int hashCode , final int dataSize ) { return hashCode & dataSize - 1 ; MST[rv.AOD1Mutator]MSP[] } protected HashEntry < K , V > getEntry ( Object key ) { key = convertKey ( key ) ; final int hashCode = hash ( key ) ;
data = new HashEntry [ capacity ] ; for ( int i = 0 ; i < size ; i ++ ) { MST[rv.UOI4Mutator]MSP[] final K key = ( K ) in . readObject () ; final V value = ( V ) in . readObject () ;
HashEntry < K , V > entry = data [ hashIndex ( hashCode , data . length ) ] ; MST[rv.UOI3Mutator]MSP[] while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) {
if ( obj instanceof Map == false ) { return false ; MST[rv.CRCR6Mutator]MSP[] } final Map < ? , ? > map = ( Map < ? , ? > ) obj ; if ( map . size () != size () ) { return false ; }
entry = entry . next ; } addMapping ( index , hashCode , key , value ) ; MST[rv.ABSMutator]MSP[] return null ; } @Override public void putAll ( final Map < ? extends K , ? extends V > map ) { _putAll ( map ) ; }
protected void removeMapping ( final HashEntry < K , V > entry , final int hashIndex , final HashEntry < K , V > previous ) { modCount ++ ; MST[rv.CRCR2Mutator]MSP[] removeEntry ( entry , hashIndex , previous ) ; size -- ; destroyEntry ( entry ) ; }
if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { MST[rv.ROR3Mutator]MSP[] return true ; } entry = entry . next ; } return false ; } @Override public boolean containsValue ( final Object value ) { if ( value == null ) {
entry = entry . next ; } } } else { for ( final HashEntry < K , V > element : data ) { MST[rv.UOI1Mutator]MSP[] HashEntry < K , V > entry = element ; while ( entry != null ) {
entry = entry . next ; } addMapping ( index , hashCode , key , value ) ; MST[rv.UOI2Mutator]MSP[] return null ; } @Override public void putAll ( final Map < ? extends K , ? extends V > map ) { _putAll ( map ) ; }
entry . key = key ; entry . value = value ; } protected void addMapping ( final int hashIndex , final int hashCode , final K key , final V value ) { modCount ++ ; MST[rv.UOI3Mutator]MSP[]
if ( obj instanceof Map == false ) { return false ; } final Map < ? , ? > map = ( Map < ? , ? > ) obj ; if ( map . size () != size () ) { MST[NonVoidMethodCallMutator]MSP[] return false ; }
if ( size >= threshold ) { final int newCapacity = data . length * 2 ; MST[rv.CRCR2Mutator]MSP[] if ( newCapacity <= MAXIMUM_CAPACITY ) { ensureCapacity ( newCapacity ) ; } } } @SuppressWarnings ( lr_1 ) protected void ensureCapacity ( final int newCapacity ) {
public MapIterator < K , V > mapIterator () { if ( size == 0 ) { MST[rv.UOI3Mutator]MSP[] return EmptyMapIterator . <K , V > emptyMapIterator () ; } return new HashMapIterator <> ( this ) ; } @Override public K next () {
if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { return true ; MST[rv.CRCR5Mutator]MSP[] } entry = entry . next ; } return false ; } @Override public boolean containsValue ( final Object value ) { if ( value == null ) {
data = new HashEntry [ capacity ] ; for ( int i = 0 ; i < size ; i ++ ) { MST[rv.CRCR3Mutator]MSP[] final K key = ( K ) in . readObject () ; final V value = ( V ) in . readObject () ;
final MapIterator < ? , ? > it = mapIterator () ; try { while ( it . hasNext () ) { MST[rv.ROR2Mutator]MSP[] final Object key = it . next () ; final Object value = it . getValue () ; if ( value == null ) {
final int newSize = (int) ( ( size + mapSize ) / loadFactor + 1 ) ; MST[rv.AOR4Mutator]MSP[] ensureCapacity ( calculateNewCapacity ( newSize ) ) ; for ( final Map . Entry < ? extends K , ? extends V > entry : map . entrySet () ) {
} return null ; } @Override public void clear () { modCount ++ ; final HashEntry < K , V > [] data = this . data ; for ( int i = data . length - 1 ; i >= 0 ; i -- ) { MST[rv.UOI3Mutator]MSP[]
entry . key = key ; entry . value = value ; } protected void addMapping ( final int hashIndex , final int hashCode , final K key , final V value ) { modCount ++ ; MST[rv.AOR2Mutator]MSP[]
HashEntry < K , V > entry = data [ hashIndex ( hashCode , data . length ) ] ; while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { MST[rv.UOI3Mutator]MSP[] return entry ; }
protected int hashIndex ( final int hashCode , final int dataSize ) { return hashCode & dataSize - 1 ; MST[rv.UOI4Mutator]MSP[] } protected HashEntry < K , V > getEntry ( Object key ) { key = convertKey ( key ) ; final int hashCode = hash ( key ) ;
final HashEntry < K , V > oldEntries [] = data ; final HashEntry < K , V > newEntries [] = new HashEntry [ newCapacity ] ; modCount ++ ; for ( int i = oldCapacity - 1 ; i >= 0 ; i -- ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[]
cloned . data = new HashEntry [ data . length ] ; cloned . entrySet = null ; cloned . keySet = null ; cloned . values = null ; MST[experimental.MemberVariableMutator]MSP[] cloned . modCount = 0 ; cloned . size = 0 ; cloned . init () ;
h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; MST[rv.AOR4Mutator]MSP[] h ^= h >>> 10 ; return h ; } protected boolean isEqualKey ( final Object key1 , final Object key2 ) {
h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; MST[rv.CRCR1Mutator]MSP[] return h ; } protected boolean isEqualKey ( final Object key1 , final Object key2 ) {
while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( convertedKey , entry . key ) ) { final V oldValue = entry . getValue () ; updateEntry ( entry , value ) ; return oldValue ; MST[ReturnValsMutator]MSP[] }
threshold = calculateThreshold ( newCapacity , loadFactor ) ; data = newEntries ; } } protected int calculateNewCapacity ( final int proposedCapacity ) { int newCapacity = 1 ; if ( proposedCapacity > MAXIMUM_CAPACITY ) { newCapacity = MAXIMUM_CAPACITY ; } else { while ( newCapacity < proposedCapacity ) { MST[rv.ABSMutator]MSP[]
data [ i ] = null ; } size = 0 ; MST[rv.CRCR3Mutator]MSP[] } protected Object convertKey ( final Object key ) { return key == null ? NULL : key ; } protected int hash ( final Object key ) { int h = key . hashCode () ;
HashEntry < K , V > entry = data [ hashIndex ( hashCode , data . length ) ] ; while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { MST[rv.ROR4Mutator]MSP[] return entry ; }
final int index = hashIndex ( entry . hashCode , newCapacity ) ; entry . next = newEntries [ index ] ; MST[rv.UOI3Mutator]MSP[] newEntries [ index ] = entry ; entry = next ; } while ( entry != null ); } }
if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { MST[rv.ROR2Mutator]MSP[] final V oldValue = entry . getValue () ; removeMapping ( entry , index , previous ) ; return oldValue ; } previous = entry ; entry = entry . next ;
return entry . getValue () ; } entry = entry . next ; } return null ; } @Override public int size () { return size ; } @Override public boolean isEmpty () { return size == 0 ; MST[ReturnValsMutator]MSP[] } @Override public boolean containsKey ( Object key ) {
final HashEntry < K , V > oldEntries [] = data ; final HashEntry < K , V > newEntries [] = new HashEntry [ newCapacity ] ; modCount ++ ; MST[rv.CRCR6Mutator]MSP[] for ( int i = oldCapacity - 1 ; i >= 0 ; i -- ) {
return key1 == key2 || key1 . equals ( key2 ) ; MST[rv.CRCR4Mutator]MSP[] } protected boolean isEqualValue ( final Object value1 , final Object value2 ) { return value1 == value2 || value1 . equals ( value2 ) ; }
put ( entry . getKey () , entry . getValue () ) ; } } @Override public V remove ( Object key ) { key = convertKey ( key ) ; MST[NonVoidMethodCallMutator]MSP[] final int hashCode = hash ( key ) ;
final HashEntry < K , V > oldEntries [] = data ; final HashEntry < K , V > newEntries [] = new HashEntry [ newCapacity ] ; modCount ++ ; MST[rv.AOD1Mutator]MSP[] for ( int i = oldCapacity - 1 ; i >= 0 ; i -- ) {
cloned . data = new HashEntry [ data . length ] ; cloned . entrySet = null ; cloned . keySet = null ; cloned . values = null ; cloned . modCount = 0 ; cloned . size = 0 ; MST[rv.CRCR6Mutator]MSP[] cloned . init () ;
while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( convertedKey , entry . key ) ) { MST[rv.ROR4Mutator]MSP[] final V oldValue = entry . getValue () ; updateEntry ( entry , value ) ; return oldValue ; }
protected void removeMapping ( final HashEntry < K , V > entry , final int hashIndex , final HashEntry < K , V > previous ) { modCount ++ ; removeEntry ( entry , hashIndex , previous ) ; size -- ; MST[rv.AOR1Mutator]MSP[] destroyEntry ( entry ) ; }
final int oldCapacity = data . length ; if ( newCapacity <= oldCapacity ) { MST[rv.UOI1Mutator]MSP[] return; } if ( size == 0 ) { threshold = calculateThreshold ( newCapacity , loadFactor ) ; data = new HashEntry [ newCapacity ] ; } else {
threshold = calculateThreshold ( newCapacity , loadFactor ) ; data = newEntries ; } } protected int calculateNewCapacity ( final int proposedCapacity ) { int newCapacity = 1 ; if ( proposedCapacity > MAXIMUM_CAPACITY ) { MST[rv.UOI1Mutator]MSP[] newCapacity = MAXIMUM_CAPACITY ; } else { while ( newCapacity < proposedCapacity ) {
final int newSize = (int) ( ( size + mapSize ) / loadFactor + 1 ) ; MST[rv.CRCR2Mutator]MSP[] ensureCapacity ( calculateNewCapacity ( newSize ) ) ; for ( final Map . Entry < ? extends K , ? extends V > entry : map . entrySet () ) {
h += ~ ( h << 9 ) ; MST[rv.AOD1Mutator]MSP[] h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; return h ; } protected boolean isEqualKey ( final Object key1 , final Object key2 ) {
if ( map . get ( key ) != null || map . containsKey ( key ) == false ) { return false ; } } else { if ( value . equals ( map . get ( key ) ) == false ) { return false ; MST[rv.CRCR3Mutator]MSP[] } }
threshold = calculateThreshold ( newCapacity , loadFactor ) ; MST[rv.UOI2Mutator]MSP[] data = newEntries ; } } protected int calculateNewCapacity ( final int proposedCapacity ) { int newCapacity = 1 ; if ( proposedCapacity > MAXIMUM_CAPACITY ) { newCapacity = MAXIMUM_CAPACITY ; } else { while ( newCapacity < proposedCapacity ) {
data = new HashEntry [ capacity ] ; for ( int i = 0 ; i < size ; i ++ ) { MST[rv.ROR1Mutator]MSP[] final K key = ( K ) in . readObject () ; final V value = ( V ) in . readObject () ;
protected void removeEntry ( final HashEntry < K , V > entry , final int hashIndex , final HashEntry < K , V > previous ) { if ( previous == null ) { data [ hashIndex ] = entry . next ; MST[rv.UOI2Mutator]MSP[] } else {
return key1 == key2 || key1 . equals ( key2 ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] } protected boolean isEqualValue ( final Object value1 , final Object value2 ) { return value1 == value2 || value1 . equals ( value2 ) ; }
if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { MST[rv.UOI3Mutator]MSP[] final V oldValue = entry . getValue () ; removeMapping ( entry , index , previous ) ; return oldValue ; } previous = entry ; entry = entry . next ;
h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; MST[rv.UOI3Mutator]MSP[] h ^= h >>> 10 ; return h ; } protected boolean isEqualKey ( final Object key1 , final Object key2 ) {
private void _putAll ( final Map < ? extends K , ? extends V > map ) { final int mapSize = map . size () ; if ( mapSize == 0 ) { MST[rv.ROR3Mutator]MSP[] return; }
key = convertKey ( key ) ; final int hashCode = hash ( key ) ; MST[NonVoidMethodCallMutator]MSP[] HashEntry < K , V > entry = data [ hashIndex ( hashCode , data . length ) ] ; while ( entry != null ) {
if ( isEqualValue ( value , entry . getValue () ) ) { return true ; } entry = entry . next ; } } } return false ; MST[rv.CRCR5Mutator]MSP[] } @Override public V put ( final K key , final V value ) {
protected void removeMapping ( final HashEntry < K , V > entry , final int hashIndex , final HashEntry < K , V > previous ) { modCount ++ ; removeEntry ( entry , hashIndex , previous ) ; MST[rv.UOI4Mutator]MSP[] size -- ; destroyEntry ( entry ) ; }
HashEntry < K , V > entry = data [ hashIndex ( hashCode , data . length ) ] ; while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { MST[rv.ROR5Mutator]MSP[]
protected int hashIndex ( final int hashCode , final int dataSize ) { return hashCode & dataSize - 1 ; MST[rv.AOR3Mutator]MSP[] } protected HashEntry < K , V > getEntry ( Object key ) { key = convertKey ( key ) ; final int hashCode = hash ( key ) ;
final int index = hashIndex ( hashCode , data . length ) ; HashEntry < K , V > entry = data [ index ] ; MST[rv.ABSMutator]MSP[] HashEntry < K , V > previous = null ; while ( entry != null ) {
data = new HashEntry [ capacity ] ; MST[rv.UOI1Mutator]MSP[] for ( int i = 0 ; i < size ; i ++ ) { final K key = ( K ) in . readObject () ; final V value = ( V ) in . readObject () ;
HashEntry < K , V > entry = oldEntries [ i ] ; MST[rv.UOI4Mutator]MSP[] if ( entry != null ) { oldEntries [ i ] = null ; do { final HashEntry < K , V > next = entry . next ;
return entry . getValue () ; } entry = entry . next ; } return null ; } @Override public int size () { return size ; MST[rv.UOI4Mutator]MSP[] } @Override public boolean isEmpty () { return size == 0 ; } @Override public boolean containsKey ( Object key ) {
protected void doReadObject ( final ObjectInputStream in ) throws IOException , ClassNotFoundException { loadFactor = in . readFloat () ; final int capacity = in . readInt () ; final int size = in . readInt () ; init () ; threshold = calculateThreshold ( capacity , loadFactor ) ; MST[rv.UOI4Mutator]MSP[]
newCapacity <<= 1 ; } if ( newCapacity > MAXIMUM_CAPACITY ) { newCapacity = MAXIMUM_CAPACITY ; } } return newCapacity ; MST[rv.UOI1Mutator]MSP[] } protected int calculateThreshold ( final int newCapacity , final float factor ) { return (int) ( newCapacity * factor ) ; }
protected Iterator < Map . Entry < K , V > > createEntrySetIterator () { if ( size () == 0 ) { return EmptyIterator . < Map . Entry < K , V > > emptyIterator () ; } return new EntrySetIterator <> ( this ) ; MST[NullReturnValsMutator]MSP[] } @Override
final HashEntry < K , V > entry = createEntry ( data [ hashIndex ] , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; MST[rv.UOI4Mutator]MSP[] size ++ ; checkCapacity () ; }
final HashEntry < K , V > oldEntries [] = data ; final HashEntry < K , V > newEntries [] = new HashEntry [ newCapacity ] ; modCount ++ ; MST[rv.UOI4Mutator]MSP[] for ( int i = oldCapacity - 1 ; i >= 0 ; i -- ) {
final int newSize = (int) ( ( size + mapSize ) / loadFactor + 1 ) ; ensureCapacity ( calculateNewCapacity ( newSize ) ) ; MST[rv.UOI3Mutator]MSP[] for ( final Map . Entry < ? extends K , ? extends V > entry : map . entrySet () ) {
if ( obj instanceof Map == false ) { return false ; } final Map < ? , ? > map = ( Map < ? , ? > ) obj ; if ( map . size () != size () ) { MST[rv.ROR1Mutator]MSP[] return false ; }
final int index = hashIndex ( hashCode , data . length ) ; HashEntry < K , V > entry = data [ index ] ; HashEntry < K , V > previous = null ; while ( entry != null ) { MST[NegateConditionalsMutator]MSP[]
return entry . getValue () ; } entry = entry . next ; } return null ; } @Override public int size () { return size ; } @Override public boolean isEmpty () { return size == 0 ; MST[rv.UOI1Mutator]MSP[] } @Override public boolean containsKey ( Object key ) {
return EmptyIterator . <K > emptyIterator () ; MST[NonVoidMethodCallMutator]MSP[] } return new KeySetIterator <> ( this ) ; } @Override public int size () { return parent . size () ; } @Override public void clear () { parent . clear () ; } @Override
final HashEntry < K , V > entry = createEntry ( data [ hashIndex ] , hashCode , key , value ) ; MST[rv.UOI1Mutator]MSP[] addEntry ( entry , hashIndex ) ; size ++ ; checkCapacity () ; }
public MapIterator < K , V > mapIterator () { if ( size == 0 ) { MST[rv.ROR1Mutator]MSP[] return EmptyMapIterator . <K , V > emptyMapIterator () ; } return new HashMapIterator <> ( this ) ; } @Override public K next () {
public MapIterator < K , V > mapIterator () { if ( size == 0 ) { MST[rv.ABSMutator]MSP[] return EmptyMapIterator . <K , V > emptyMapIterator () ; } return new HashMapIterator <> ( this ) ; } @Override public K next () {
protected int hashIndex ( final int hashCode , final int dataSize ) { return hashCode & dataSize - 1 ; MST[rv.OBBN3Mutator]MSP[] } protected HashEntry < K , V > getEntry ( Object key ) { key = convertKey ( key ) ; final int hashCode = hash ( key ) ;
final Iterator < Map . Entry < K , V > > it = createEntrySetIterator () ; MST[NonVoidMethodCallMutator]MSP[] while ( it . hasNext () ) { total += it . next () . hashCode () ; } return total ; } @Override public String toString () {
if ( obj instanceof Map == false ) { return false ; } final Map < ? , ? > map = ( Map < ? , ? > ) obj ; if ( map . size () != size () ) { return false ; MST[ReturnValsMutator]MSP[] }
final HashEntry < K , V > entry = createEntry ( data [ hashIndex ] , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; size ++ ; MST[rv.CRCR3Mutator]MSP[] checkCapacity () ; }
if ( size >= threshold ) { final int newCapacity = data . length * 2 ; if ( newCapacity <= MAXIMUM_CAPACITY ) { ensureCapacity ( newCapacity ) ; } } } @SuppressWarnings ( lr_1 ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] protected void ensureCapacity ( final int newCapacity ) {
key = convertKey ( key ) ; final int hashCode = hash ( key ) ; HashEntry < K , V > entry = data [ hashIndex ( hashCode , data . length ) ] ; while ( entry != null ) { MST[rv.ROR5Mutator]MSP[]
data [ i ] = null ; MST[rv.UOI3Mutator]MSP[] } size = 0 ; } protected Object convertKey ( final Object key ) { return key == null ? NULL : key ; } protected int hash ( final Object key ) { int h = key . hashCode () ;
final Iterator < Map . Entry < K , V > > it = createEntrySetIterator () ; while ( it . hasNext () ) { MST[rv.ROR5Mutator]MSP[] total += it . next () . hashCode () ; } return total ; } @Override public String toString () {
key = convertKey ( key ) ; final int hashCode = hash ( key ) ; HashEntry < K , V > entry = data [ hashIndex ( hashCode , data . length ) ] ; while ( entry != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
final MapIterator < ? , ? > it = mapIterator () ; try { while ( it . hasNext () ) { final Object key = it . next () ; final Object value = it . getValue () ; MST[NonVoidMethodCallMutator]MSP[] if ( value == null ) {
key = convertKey ( key ) ; final int hashCode = hash ( key ) ; HashEntry < K , V > entry = data [ hashIndex ( hashCode , data . length ) ] ; MST[NonVoidMethodCallMutator]MSP[] while ( entry != null ) {
final int oldCapacity = data . length ; if ( newCapacity <= oldCapacity ) { MST[rv.ROR5Mutator]MSP[] return; } if ( size == 0 ) { threshold = calculateThreshold ( newCapacity , loadFactor ) ; data = new HashEntry [ newCapacity ] ; } else {
HashEntry < K , V > entry = oldEntries [ i ] ; if ( entry != null ) { MST[NegateConditionalsMutator]MSP[] oldEntries [ i ] = null ; do { final HashEntry < K , V > next = entry . next ;
threshold = calculateThreshold ( newCapacity , loadFactor ) ; MST[rv.UOI1Mutator]MSP[] data = newEntries ; } } protected int calculateNewCapacity ( final int proposedCapacity ) { int newCapacity = 1 ; if ( proposedCapacity > MAXIMUM_CAPACITY ) { newCapacity = MAXIMUM_CAPACITY ; } else { while ( newCapacity < proposedCapacity ) {
cloned . data = new HashEntry [ data . length ] ; cloned . entrySet = null ; cloned . keySet = null ; MST[experimental.MemberVariableMutator]MSP[] cloned . values = null ; cloned . modCount = 0 ; cloned . size = 0 ; cloned . init () ;
HashEntry < K , V > entry = data [ hashIndex ( hashCode , data . length ) ] ; while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return entry ; }
final HashEntry < K , V > entry = createEntry ( data [ hashIndex ] , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; MST[rv.UOI1Mutator]MSP[] size ++ ; checkCapacity () ; }
data [ i ] = null ; } size = 0 ; MST[experimental.MemberVariableMutator]MSP[] } protected Object convertKey ( final Object key ) { return key == null ? NULL : key ; } protected int hash ( final Object key ) { int h = key . hashCode () ;
return entry . getValue () ; } entry = entry . next ; } return null ; } @Override public int size () { return size ; MST[rv.UOI1Mutator]MSP[] } @Override public boolean isEmpty () { return size == 0 ; } @Override public boolean containsKey ( Object key ) {
final Iterator < Map . Entry < K , V > > it = createEntrySetIterator () ; while ( it . hasNext () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] total += it . next () . hashCode () ; } return total ; } @Override public String toString () {
HashEntry < K , V > entry = data [ hashIndex ( hashCode , data . length ) ] ; while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { MST[rv.ROR3Mutator]MSP[] return entry ; }
if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { return true ; } entry = entry . next ; } return false ; MST[rv.CRCR3Mutator]MSP[] } @Override public boolean containsValue ( final Object value ) { if ( value == null ) {
if ( map . get ( key ) != null || map . containsKey ( key ) == false ) { return false ; } } else { if ( value . equals ( map . get ( key ) ) == false ) { return false ; MST[InlineConstantMutator]MSP[] } }
key = convertKey ( key ) ; MST[NonVoidMethodCallMutator]MSP[] final int hashCode = hash ( key ) ; HashEntry < K , V > entry = data [ hashIndex ( hashCode , data . length ) ] ; while ( entry != null ) {
protected void reuseEntry ( final HashEntry < K , V > entry , final int hashIndex , final int hashCode , final K key , final V value ) { entry . next = data [ hashIndex ] ; MST[rv.UOI2Mutator]MSP[] entry . hashCode = hashCode ;
if ( map . get ( key ) != null || map . containsKey ( key ) == false ) { return false ; } } else { if ( value . equals ( map . get ( key ) ) == false ) { MST[ArgumentPropagationMutator]MSP[] return false ; } }
entry . key = key ; entry . value = value ; } protected void addMapping ( final int hashIndex , final int hashCode , final K key , final V value ) { modCount ++ ; MST[rv.AOR1Mutator]MSP[]
if ( size >= threshold ) { final int newCapacity = data . length * 2 ; MST[rv.CRCR1Mutator]MSP[] if ( newCapacity <= MAXIMUM_CAPACITY ) { ensureCapacity ( newCapacity ) ; } } } @SuppressWarnings ( lr_1 ) protected void ensureCapacity ( final int newCapacity ) {
HashEntry < K , V > entry = data [ hashIndex ( hashCode , data . length ) ] ; while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { MST[rv.UOI2Mutator]MSP[] return entry ; }
return EmptyIterator . <K > emptyIterator () ; } return new KeySetIterator <> ( this ) ; MST[NullReturnValsMutator]MSP[] } @Override public int size () { return parent . size () ; } @Override public void clear () { parent . clear () ; } @Override
HashEntry < K , V > entry = oldEntries [ i ] ; if ( entry != null ) { MST[rv.ROR5Mutator]MSP[] oldEntries [ i ] = null ; do { final HashEntry < K , V > next = entry . next ;
for ( final MapIterator < K , V > it = mapIterator () ; it . hasNext () ; ) { out . writeObject ( it . next () ) ; MST[VoidMethodCallMutator]MSP[] out . writeObject ( it . getValue () ) ; } } @SuppressWarnings ( lr_1 )
final int oldCapacity = data . length ; if ( newCapacity <= oldCapacity ) { MST[rv.UOI4Mutator]MSP[] return; } if ( size == 0 ) { threshold = calculateThreshold ( newCapacity , loadFactor ) ; data = new HashEntry [ newCapacity ] ; } else {
protected int hashIndex ( final int hashCode , final int dataSize ) { return hashCode & dataSize - 1 ; MST[rv.UOI1Mutator]MSP[] } protected HashEntry < K , V > getEntry ( Object key ) { key = convertKey ( key ) ; final int hashCode = hash ( key ) ;
threshold = calculateThreshold ( newCapacity , loadFactor ) ; data = newEntries ; } } protected int calculateNewCapacity ( final int proposedCapacity ) { int newCapacity = 1 ; if ( proposedCapacity > MAXIMUM_CAPACITY ) { newCapacity = MAXIMUM_CAPACITY ; } else { while ( newCapacity < proposedCapacity ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[]
if ( obj instanceof Map == false ) { return false ; MST[ReturnValsMutator]MSP[] } final Map < ? , ? > map = ( Map < ? , ? > ) obj ; if ( map . size () != size () ) { return false ; }
if ( size >= threshold ) { final int newCapacity = data . length * 2 ; if ( newCapacity <= MAXIMUM_CAPACITY ) { MST[rv.ROR3Mutator]MSP[] ensureCapacity ( newCapacity ) ; } } } @SuppressWarnings ( lr_1 ) protected void ensureCapacity ( final int newCapacity ) {
final int oldCapacity = data . length ; if ( newCapacity <= oldCapacity ) { MST[NegateConditionalsMutator]MSP[] return; } if ( size == 0 ) { threshold = calculateThreshold ( newCapacity , loadFactor ) ; data = new HashEntry [ newCapacity ] ; } else {
return key1 == key2 || key1 . equals ( key2 ) ; } protected boolean isEqualValue ( final Object value1 , final Object value2 ) { return value1 == value2 || value1 . equals ( value2 ) ; MST[NonVoidMethodCallMutator]MSP[] }
HashEntry < K , V > entry = oldEntries [ i ] ; if ( entry != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] oldEntries [ i ] = null ; do { final HashEntry < K , V > next = entry . next ;
public Set < K > keySet () { if ( keySet == null ) { keySet = new KeySet <> ( this ) ; } return keySet ; } protected Iterator < K > createKeySetIterator () { if ( size () == 0 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
final HashEntry < K , V > oldEntries [] = data ; final HashEntry < K , V > newEntries [] = new HashEntry [ newCapacity ] ; modCount ++ ; for ( int i = oldCapacity - 1 ; i >= 0 ; i -- ) { MST[rv.AOR1Mutator]MSP[]
protected void doReadObject ( final ObjectInputStream in ) throws IOException , ClassNotFoundException { loadFactor = in . readFloat () ; MST[experimental.MemberVariableMutator]MSP[] final int capacity = in . readInt () ; final int size = in . readInt () ; init () ; threshold = calculateThreshold ( capacity , loadFactor ) ;
HashEntry < K , V > entry = data [ hashIndex ( hashCode , data . length ) ] ; while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
entry = entry . next ; } } } else { for ( final HashEntry < K , V > element : data ) { MST[rv.ABSMutator]MSP[] HashEntry < K , V > entry = element ; while ( entry != null ) {
entry = entry . next ; } addMapping ( index , hashCode , key , value ) ; MST[rv.UOI1Mutator]MSP[] return null ; } @Override public void putAll ( final Map < ? extends K , ? extends V > map ) { _putAll ( map ) ; }
if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] final V oldValue = entry . getValue () ; removeMapping ( entry , index , previous ) ; return oldValue ; } previous = entry ; entry = entry . next ;
final HashEntry < K , V > entry = createEntry ( data [ hashIndex ] , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; size ++ ; MST[rv.AOR4Mutator]MSP[] checkCapacity () ; }
final Iterator < Map . Entry < K , V > > it = createEntrySetIterator () ; while ( it . hasNext () ) { total += it . next () . hashCode () ; MST[rv.AOR3Mutator]MSP[] } return total ; } @Override public String toString () {
private void _putAll ( final Map < ? extends K , ? extends V > map ) { final int mapSize = map . size () ; if ( mapSize == 0 ) { MST[rv.UOI1Mutator]MSP[] return; }
newCapacity <<= 1 ; } if ( newCapacity > MAXIMUM_CAPACITY ) { MST[rv.UOI1Mutator]MSP[] newCapacity = MAXIMUM_CAPACITY ; } } return newCapacity ; } protected int calculateThreshold ( final int newCapacity , final float factor ) { return (int) ( newCapacity * factor ) ; }
final int newSize = (int) ( ( size + mapSize ) / loadFactor + 1 ) ; MST[rv.UOI4Mutator]MSP[] ensureCapacity ( calculateNewCapacity ( newSize ) ) ; for ( final Map . Entry < ? extends K , ? extends V > entry : map . entrySet () ) {
if ( isEqualValue ( value , entry . getValue () ) ) { MST[rv.ROR5Mutator]MSP[] return true ; } entry = entry . next ; } } } return false ; } @Override public V put ( final K key , final V value ) {
protected void reuseEntry ( final HashEntry < K , V > entry , final int hashIndex , final int hashCode , final K key , final V value ) { entry . next = data [ hashIndex ] ; MST[rv.ABSMutator]MSP[] entry . hashCode = hashCode ;
if ( size >= threshold ) { MST[ConditionalsBoundaryMutator]MSP[] final int newCapacity = data . length * 2 ; if ( newCapacity <= MAXIMUM_CAPACITY ) { ensureCapacity ( newCapacity ) ; } } } @SuppressWarnings ( lr_1 ) protected void ensureCapacity ( final int newCapacity ) {
data = new HashEntry [ capacity ] ; for ( int i = 0 ; i < size ; i ++ ) { MST[rv.CRCR6Mutator]MSP[] final K key = ( K ) in . readObject () ; final V value = ( V ) in . readObject () ;
key = convertKey ( key ) ; final int hashCode = hash ( key ) ; HashEntry < K , V > entry = data [ hashIndex ( hashCode , data . length ) ] ; MST[rv.ABSMutator]MSP[] while ( entry != null ) {
while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( convertedKey , entry . key ) ) { MST[NonVoidMethodCallMutator]MSP[] final V oldValue = entry . getValue () ; updateEntry ( entry , value ) ; return oldValue ; }
HashEntry < K , V > entry = data [ hashIndex ( hashCode , data . length ) ] ; while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return entry ; }
protected void removeMapping ( final HashEntry < K , V > entry , final int hashIndex , final HashEntry < K , V > previous ) { modCount ++ ; removeEntry ( entry , hashIndex , previous ) ; size -- ; MST[rv.AOR2Mutator]MSP[] destroyEntry ( entry ) ; }
final HashEntry < K , V > oldEntries [] = data ; final HashEntry < K , V > newEntries [] = new HashEntry [ newCapacity ] ; modCount ++ ; MST[rv.AOD2Mutator]MSP[] for ( int i = oldCapacity - 1 ; i >= 0 ; i -- ) {
newCapacity <<= 1 ; } if ( newCapacity > MAXIMUM_CAPACITY ) { newCapacity = MAXIMUM_CAPACITY ; } } return newCapacity ; } protected int calculateThreshold ( final int newCapacity , final float factor ) { return (int) ( newCapacity * factor ) ; MST[rv.UOI1Mutator]MSP[] }
final int newSize = (int) ( ( size + mapSize ) / loadFactor + 1 ) ; MST[rv.CRCR6Mutator]MSP[] ensureCapacity ( calculateNewCapacity ( newSize ) ) ; for ( final Map . Entry < ? extends K , ? extends V > entry : map . entrySet () ) {
h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; MST[rv.UOI1Mutator]MSP[] return h ; } protected boolean isEqualKey ( final Object key1 , final Object key2 ) {
final int index = hashIndex ( hashCode , data . length ) ; MST[rv.UOI4Mutator]MSP[] HashEntry < K , V > entry = data [ index ] ; HashEntry < K , V > previous = null ; while ( entry != null ) {
final HashEntry < K , V > entry = createEntry ( data [ hashIndex ] , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; size ++ ; MST[MathMutator]MSP[] checkCapacity () ; }
if ( size >= threshold ) { final int newCapacity = data . length * 2 ; if ( newCapacity <= MAXIMUM_CAPACITY ) { MST[ConditionalsBoundaryMutator]MSP[] ensureCapacity ( newCapacity ) ; } } } @SuppressWarnings ( lr_1 ) protected void ensureCapacity ( final int newCapacity ) {
final HashEntry < K , V > oldEntries [] = data ; final HashEntry < K , V > newEntries [] = new HashEntry [ newCapacity ] ; modCount ++ ; for ( int i = oldCapacity - 1 ; i >= 0 ; i -- ) { MST[MathMutator]MSP[]
return entry . getValue () ; } entry = entry . next ; } return null ; } @Override public int size () { return size ; } @Override public boolean isEmpty () { return size == 0 ; MST[rv.CRCR5Mutator]MSP[] } @Override public boolean containsKey ( Object key ) {
if ( size () == 0 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return lr_6 ; } final StringBuilder buf = new StringBuilder ( 32 * size () ) ; buf . append ( '{' ) ; final MapIterator < K , V > it = mapIterator () ;
h += ~ ( h << 9 ) ; MST[rv.UOI4Mutator]MSP[] h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; return h ; } protected boolean isEqualKey ( final Object key1 , final Object key2 ) {
threshold = calculateThreshold ( newCapacity , loadFactor ) ; MST[ArgumentPropagationMutator]MSP[] data = newEntries ; } } protected int calculateNewCapacity ( final int proposedCapacity ) { int newCapacity = 1 ; if ( proposedCapacity > MAXIMUM_CAPACITY ) { newCapacity = MAXIMUM_CAPACITY ; } else { while ( newCapacity < proposedCapacity ) {
if ( isEqualValue ( value , entry . getValue () ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return true ; } entry = entry . next ; } } } return false ; } @Override public V put ( final K key , final V value ) {
protected Iterator < Map . Entry < K , V > > createEntrySetIterator () { if ( size () == 0 ) { MST[NonVoidMethodCallMutator]MSP[] return EmptyIterator . < Map . Entry < K , V > > emptyIterator () ; } return new EntrySetIterator <> ( this ) ; } @Override
public Set < K > keySet () { if ( keySet == null ) { keySet = new KeySet <> ( this ) ; MST[ConstructorCallMutator]MSP[] } return keySet ; } protected Iterator < K > createKeySetIterator () { if ( size () == 0 ) {
HashEntry < K , V > entry = data [ hashIndex ( hashCode , data . length ) ] ; while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { MST[rv.ROR5Mutator]MSP[] return entry ; }
protected void reuseEntry ( final HashEntry < K , V > entry , final int hashIndex , final int hashCode , final K key , final V value ) { entry . next = data [ hashIndex ] ; entry . hashCode = hashCode ; MST[rv.UOI4Mutator]MSP[]
final Iterator < Map . Entry < K , V > > it = createEntrySetIterator () ; while ( it . hasNext () ) { MST[NegateConditionalsMutator]MSP[] total += it . next () . hashCode () ; } return total ; } @Override public String toString () {
} return null ; } @Override public void clear () { modCount ++ ; MST[rv.UOI1Mutator]MSP[] final HashEntry < K , V > [] data = this . data ; for ( int i = data . length - 1 ; i >= 0 ; i -- ) {
if ( size >= threshold ) { final int newCapacity = data . length * 2 ; if ( newCapacity <= MAXIMUM_CAPACITY ) { MST[rv.CRCR6Mutator]MSP[] ensureCapacity ( newCapacity ) ; } } } @SuppressWarnings ( lr_1 ) protected void ensureCapacity ( final int newCapacity ) {
key = convertKey ( key ) ; final int hashCode = hash ( key ) ; HashEntry < K , V > entry = data [ hashIndex ( hashCode , data . length ) ] ; while ( entry != null ) { MST[NegateConditionalsMutator]MSP[]
protected void removeMapping ( final HashEntry < K , V > entry , final int hashIndex , final HashEntry < K , V > previous ) { modCount ++ ; removeEntry ( entry , hashIndex , previous ) ; MST[rv.UOI3Mutator]MSP[] size -- ; destroyEntry ( entry ) ; }
HashEntry < K , V > entry = data [ hashIndex ( hashCode , data . length ) ] ; MST[rv.UOI1Mutator]MSP[] while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { return entry ; }
protected int hashIndex ( final int hashCode , final int dataSize ) { return hashCode & dataSize - 1 ; MST[rv.AOR2Mutator]MSP[] } protected HashEntry < K , V > getEntry ( Object key ) { key = convertKey ( key ) ; final int hashCode = hash ( key ) ;
HashEntry < K , V > entry = data [ hashIndex ( hashCode , data . length ) ] ; while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { MST[rv.UOI1Mutator]MSP[]
HashEntry < K , V > entry = data [ hashIndex ( hashCode , data . length ) ] ; while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; MST[MathMutator]MSP[] h ^= h >>> 10 ; return h ; } protected boolean isEqualKey ( final Object key1 , final Object key2 ) {
h += ~ ( h << 9 ) ; h ^= h >>> 14 ; MST[rv.CRCR3Mutator]MSP[] h += h << 4 ; h ^= h >>> 10 ; return h ; } protected boolean isEqualKey ( final Object key1 , final Object key2 ) {
public Set < K > keySet () { if ( keySet == null ) { keySet = new KeySet <> ( this ) ; } return keySet ; MST[ReturnValsMutator]MSP[] } protected Iterator < K > createKeySetIterator () { if ( size () == 0 ) {
h += ~ ( h << 9 ) ; h ^= h >>> 14 ; MST[rv.CRCR6Mutator]MSP[] h += h << 4 ; h ^= h >>> 10 ; return h ; } protected boolean isEqualKey ( final Object key1 , final Object key2 ) {
final HashEntry < K , V > oldEntries [] = data ; final HashEntry < K , V > newEntries [] = new HashEntry [ newCapacity ] ; modCount ++ ; for ( int i = oldCapacity - 1 ; i >= 0 ; i -- ) { MST[rv.ABSMutator]MSP[]
protected void removeMapping ( final HashEntry < K , V > entry , final int hashIndex , final HashEntry < K , V > previous ) { modCount ++ ; removeEntry ( entry , hashIndex , previous ) ; size -- ; MST[rv.CRCR4Mutator]MSP[] destroyEntry ( entry ) ; }
data [ i ] = null ; } size = 0 ; MST[rv.CRCR5Mutator]MSP[] } protected Object convertKey ( final Object key ) { return key == null ? NULL : key ; } protected int hash ( final Object key ) { int h = key . hashCode () ;
HashEntry < K , V > entry = data [ hashIndex ( hashCode , data . length ) ] ; while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { MST[rv.ABSMutator]MSP[] return entry ; }
protected void reuseEntry ( final HashEntry < K , V > entry , final int hashIndex , final int hashCode , final K key , final V value ) { entry . next = data [ hashIndex ] ; MST[experimental.MemberVariableMutator]MSP[] entry . hashCode = hashCode ;
protected void doWriteObject ( final ObjectOutputStream out ) throws IOException { out . writeFloat ( loadFactor ) ; MST[rv.UOI1Mutator]MSP[] out . writeInt ( data . length ) ; out . writeInt ( size ) ;
h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; MST[rv.UOI4Mutator]MSP[] h ^= h >>> 10 ; return h ; } protected boolean isEqualKey ( final Object key1 , final Object key2 ) {
return key1 == key2 || key1 . equals ( key2 ) ; MST[BooleanTrueReturnValsMutator]MSP[] } protected boolean isEqualValue ( final Object value1 , final Object value2 ) { return value1 == value2 || value1 . equals ( value2 ) ; }
public Set < K > keySet () { if ( keySet == null ) { keySet = new KeySet <> ( this ) ; } return keySet ; } protected Iterator < K > createKeySetIterator () { if ( size () == 0 ) { MST[NonVoidMethodCallMutator]MSP[]
newCapacity <<= 1 ; } if ( newCapacity > MAXIMUM_CAPACITY ) { newCapacity = MAXIMUM_CAPACITY ; } } return newCapacity ; } protected int calculateThreshold ( final int newCapacity , final float factor ) { return (int) ( newCapacity * factor ) ; MST[rv.AOD1Mutator]MSP[] }
final Iterator < Map . Entry < K , V > > it = createEntrySetIterator () ; while ( it . hasNext () ) { MST[rv.ROR2Mutator]MSP[] total += it . next () . hashCode () ; } return total ; } @Override public String toString () {
threshold = calculateThreshold ( newCapacity , loadFactor ) ; data = newEntries ; } } protected int calculateNewCapacity ( final int proposedCapacity ) { int newCapacity = 1 ; if ( proposedCapacity > MAXIMUM_CAPACITY ) { newCapacity = MAXIMUM_CAPACITY ; } else { while ( newCapacity < proposedCapacity ) { MST[NegateConditionalsMutator]MSP[]
final int oldCapacity = data . length ; if ( newCapacity <= oldCapacity ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] return; } if ( size == 0 ) { threshold = calculateThreshold ( newCapacity , loadFactor ) ; data = new HashEntry [ newCapacity ] ; } else {
threshold = calculateThreshold ( newCapacity , loadFactor ) ; data = newEntries ; } } protected int calculateNewCapacity ( final int proposedCapacity ) { int newCapacity = 1 ; if ( proposedCapacity > MAXIMUM_CAPACITY ) { MST[ConditionalsBoundaryMutator]MSP[] newCapacity = MAXIMUM_CAPACITY ; } else { while ( newCapacity < proposedCapacity ) {
data = new HashEntry [ capacity ] ; for ( int i = 0 ; i < size ; i ++ ) { MST[rv.UOI2Mutator]MSP[] final K key = ( K ) in . readObject () ; final V value = ( V ) in . readObject () ;
final HashEntry < K , V > oldEntries [] = data ; final HashEntry < K , V > newEntries [] = new HashEntry [ newCapacity ] ; modCount ++ ; MST[rv.UOI1Mutator]MSP[] for ( int i = oldCapacity - 1 ; i >= 0 ; i -- ) {
final Object convertedKey = convertKey ( key ) ; final int hashCode = hash ( convertedKey ) ; final int index = hashIndex ( hashCode , data . length ) ; MST[rv.UOI2Mutator]MSP[] HashEntry < K , V > entry = data [ index ] ;
protected void doWriteObject ( final ObjectOutputStream out ) throws IOException { out . writeFloat ( loadFactor ) ; MST[rv.UOI4Mutator]MSP[] out . writeInt ( data . length ) ; out . writeInt ( size ) ;
protected void removeMapping ( final HashEntry < K , V > entry , final int hashIndex , final HashEntry < K , V > previous ) { modCount ++ ; MST[rv.CRCR6Mutator]MSP[] removeEntry ( entry , hashIndex , previous ) ; size -- ; destroyEntry ( entry ) ; }
if ( size >= threshold ) { MST[rv.UOI2Mutator]MSP[] final int newCapacity = data . length * 2 ; if ( newCapacity <= MAXIMUM_CAPACITY ) { ensureCapacity ( newCapacity ) ; } } } @SuppressWarnings ( lr_1 ) protected void ensureCapacity ( final int newCapacity ) {
} } catch ( final ClassCastException ignored ) { return false ; } catch ( final NullPointerException ignored ) { return false ; } return true ; MST[ReturnValsMutator]MSP[] } @Override public int hashCode () { int total = 0 ;
HashEntry < K , V > entry = data [ hashIndex ( hashCode , data . length ) ] ; while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { MST[NonVoidMethodCallMutator]MSP[]
threshold = calculateThreshold ( newCapacity , loadFactor ) ; data = newEntries ; } } protected int calculateNewCapacity ( final int proposedCapacity ) { int newCapacity = 1 ; if ( proposedCapacity > MAXIMUM_CAPACITY ) { newCapacity = MAXIMUM_CAPACITY ; } else { while ( newCapacity < proposedCapacity ) { MST[rv.UOI1Mutator]MSP[]
final MapIterator < ? , ? > it = mapIterator () ; try { while ( it . hasNext () ) { MST[rv.ROR4Mutator]MSP[] final Object key = it . next () ; final Object value = it . getValue () ; if ( value == null ) {
cloned . data = new HashEntry [ data . length ] ; cloned . entrySet = null ; cloned . keySet = null ; cloned . values = null ; cloned . modCount = 0 ; MST[rv.CRCR1Mutator]MSP[] cloned . size = 0 ; cloned . init () ;
final HashEntry < K , V > oldEntries [] = data ; final HashEntry < K , V > newEntries [] = new HashEntry [ newCapacity ] ; modCount ++ ; for ( int i = oldCapacity - 1 ; i >= 0 ; i -- ) { MST[rv.ROR3Mutator]MSP[]
final HashEntry < K , V > oldEntries [] = data ; final HashEntry < K , V > newEntries [] = new HashEntry [ newCapacity ] ; modCount ++ ; MST[rv.AOR2Mutator]MSP[] for ( int i = oldCapacity - 1 ; i >= 0 ; i -- ) {
final HashEntry < K , V > oldEntries [] = data ; final HashEntry < K , V > newEntries [] = new HashEntry [ newCapacity ] ; modCount ++ ; for ( int i = oldCapacity - 1 ; i >= 0 ; i -- ) { MST[rv.AOR4Mutator]MSP[]
HashEntry < K , V > entry = data [ hashIndex ( hashCode , data . length ) ] ; while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { MST[NonVoidMethodCallMutator]MSP[] return entry ; }
newCapacity <<= 1 ; } if ( newCapacity > MAXIMUM_CAPACITY ) { newCapacity = MAXIMUM_CAPACITY ; } } return newCapacity ; MST[rv.UOI3Mutator]MSP[] } protected int calculateThreshold ( final int newCapacity , final float factor ) { return (int) ( newCapacity * factor ) ; }
if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { MST[NonVoidMethodCallMutator]MSP[] final V oldValue = entry . getValue () ; removeMapping ( entry , index , previous ) ; return oldValue ; } previous = entry ; entry = entry . next ;
protected void doReadObject ( final ObjectInputStream in ) throws IOException , ClassNotFoundException { loadFactor = in . readFloat () ; final int capacity = in . readInt () ; final int size = in . readInt () ; init () ; threshold = calculateThreshold ( capacity , loadFactor ) ; MST[rv.UOI2Mutator]MSP[]
if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { return true ; } entry = entry . next ; } return false ; MST[rv.CRCR6Mutator]MSP[] } @Override public boolean containsValue ( final Object value ) { if ( value == null ) {
} return null ; } @Override public void clear () { modCount ++ ; MST[rv.UOI4Mutator]MSP[] final HashEntry < K , V > [] data = this . data ; for ( int i = data . length - 1 ; i >= 0 ; i -- ) {
return key1 == key2 || key1 . equals ( key2 ) ; } protected boolean isEqualValue ( final Object value1 , final Object value2 ) { return value1 == value2 || value1 . equals ( value2 ) ; MST[rv.CRCR5Mutator]MSP[] }
if ( size >= threshold ) { final int newCapacity = data . length * 2 ; if ( newCapacity <= MAXIMUM_CAPACITY ) { MST[rv.CRCR3Mutator]MSP[] ensureCapacity ( newCapacity ) ; } } } @SuppressWarnings ( lr_1 ) protected void ensureCapacity ( final int newCapacity ) {
final int index = hashIndex ( entry . hashCode , newCapacity ) ; MST[rv.UOI3Mutator]MSP[] entry . next = newEntries [ index ] ; newEntries [ index ] = entry ; entry = next ; } while ( entry != null ); } }
protected void removeMapping ( final HashEntry < K , V > entry , final int hashIndex , final HashEntry < K , V > previous ) { modCount ++ ; removeEntry ( entry , hashIndex , previous ) ; size -- ; MST[rv.UOI4Mutator]MSP[] destroyEntry ( entry ) ; }
threshold = calculateThreshold ( newCapacity , loadFactor ) ; data = newEntries ; } } protected int calculateNewCapacity ( final int proposedCapacity ) { int newCapacity = 1 ; if ( proposedCapacity > MAXIMUM_CAPACITY ) { MST[rv.UOI3Mutator]MSP[] newCapacity = MAXIMUM_CAPACITY ; } else { while ( newCapacity < proposedCapacity ) {
public MapIterator < K , V > mapIterator () { if ( size == 0 ) { return EmptyMapIterator . <K , V > emptyMapIterator () ; MST[NonVoidMethodCallMutator]MSP[] } return new HashMapIterator <> ( this ) ; } @Override public K next () {
if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { MST[rv.ROR4Mutator]MSP[] return true ; } entry = entry . next ; } return false ; } @Override public boolean containsValue ( final Object value ) { if ( value == null ) {
final int oldCapacity = data . length ; if ( newCapacity <= oldCapacity ) { return; } if ( size == 0 ) { MST[NegateConditionalsMutator]MSP[] threshold = calculateThreshold ( newCapacity , loadFactor ) ; data = new HashEntry [ newCapacity ] ; } else {
public Set < K > keySet () { if ( keySet == null ) { keySet = new KeySet <> ( this ) ; } return keySet ; MST[EmptyObjectReturnValsMutator]MSP[] } protected Iterator < K > createKeySetIterator () { if ( size () == 0 ) {
final HashEntry < K , V > oldEntries [] = data ; final HashEntry < K , V > newEntries [] = new HashEntry [ newCapacity ] ; modCount ++ ; for ( int i = oldCapacity - 1 ; i >= 0 ; i -- ) { MST[rv.UOI3Mutator]MSP[]
return key1 == key2 || key1 . equals ( key2 ) ; } protected boolean isEqualValue ( final Object value1 , final Object value2 ) { return value1 == value2 || value1 . equals ( value2 ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] }
} return null ; } @Override public void clear () { modCount ++ ; final HashEntry < K , V > [] data = this . data ; for ( int i = data . length - 1 ; i >= 0 ; i -- ) { MST[rv.AOR3Mutator]MSP[]
final HashEntry < K , V > entry = createEntry ( data [ hashIndex ] , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; size ++ ; MST[rv.UOI3Mutator]MSP[] checkCapacity () ; }
return entry . getValue () ; } entry = entry . next ; } return null ; } @Override public int size () { return size ; } @Override public boolean isEmpty () { return size == 0 ; MST[rv.CRCR5Mutator]MSP[] } @Override public boolean containsKey ( Object key ) {
put ( entry . getKey () , entry . getValue () ) ; MST[NonVoidMethodCallMutator]MSP[] } } @Override public V remove ( Object key ) { key = convertKey ( key ) ; final int hashCode = hash ( key ) ;
return key1 == key2 || key1 . equals ( key2 ) ; } protected boolean isEqualValue ( final Object value1 , final Object value2 ) { return value1 == value2 || value1 . equals ( value2 ) ; MST[ReturnValsMutator]MSP[] }
if ( isEqualValue ( value , entry . getValue () ) ) { MST[rv.ROR2Mutator]MSP[] return true ; } entry = entry . next ; } } } return false ; } @Override public V put ( final K key , final V value ) {
} return null ; } @Override public void clear () { modCount ++ ; final HashEntry < K , V > [] data = this . data ; for ( int i = data . length - 1 ; i >= 0 ; i -- ) { MST[rv.CRCR5Mutator]MSP[]
} return null ; } @Override public void clear () { modCount ++ ; MST[rv.AOD2Mutator]MSP[] final HashEntry < K , V > [] data = this . data ; for ( int i = data . length - 1 ; i >= 0 ; i -- ) {
for ( final MapIterator < K , V > it = mapIterator () ; it . hasNext () ; ) { MST[rv.ROR4Mutator]MSP[] out . writeObject ( it . next () ) ; out . writeObject ( it . getValue () ) ; } } @SuppressWarnings ( lr_1 )
public MapIterator < K , V > mapIterator () { if ( size == 0 ) { MST[NegateConditionalsMutator]MSP[] return EmptyMapIterator . <K , V > emptyMapIterator () ; } return new HashMapIterator <> ( this ) ; } @Override public K next () {
private void _putAll ( final Map < ? extends K , ? extends V > map ) { final int mapSize = map . size () ; if ( mapSize == 0 ) { MST[rv.ROR5Mutator]MSP[] return; }
if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { MST[rv.UOI1Mutator]MSP[] final V oldValue = entry . getValue () ; removeMapping ( entry , index , previous ) ; return oldValue ; } previous = entry ; entry = entry . next ;
final int newSize = (int) ( ( size + mapSize ) / loadFactor + 1 ) ; MST[rv.UOI1Mutator]MSP[] ensureCapacity ( calculateNewCapacity ( newSize ) ) ; for ( final Map . Entry < ? extends K , ? extends V > entry : map . entrySet () ) {
key = convertKey ( key ) ; final int hashCode = hash ( key ) ; HashEntry < K , V > entry = data [ hashIndex ( hashCode , data . length ) ] ; MST[rv.UOI2Mutator]MSP[] while ( entry != null ) {
protected HashEntry < K , V > createEntry ( final HashEntry < K , V > next , final int hashCode , final K key , final V value ) { return new HashEntry <> ( next , hashCode , convertKey ( key ) , value ) ; MST[ArgumentPropagationMutator]MSP[] }
previous . next = entry . next ; MST[experimental.MemberVariableMutator]MSP[] } } protected void destroyEntry ( final HashEntry < K , V > entry ) { entry . next = null ; entry . key = null ; entry . value = null ; } protected void checkCapacity () {
if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] final V oldValue = entry . getValue () ; removeMapping ( entry , index , previous ) ; return oldValue ; } previous = entry ; entry = entry . next ;
public MapIterator < K , V > mapIterator () { if ( size == 0 ) { return EmptyMapIterator . <K , V > emptyMapIterator () ; } return new HashMapIterator <> ( this ) ; MST[ConstructorCallMutator]MSP[] } @Override public K next () {
final int oldCapacity = data . length ; if ( newCapacity <= oldCapacity ) { return; } if ( size == 0 ) { threshold = calculateThreshold ( newCapacity , loadFactor ) ; MST[ArgumentPropagationMutator]MSP[] data = new HashEntry [ newCapacity ] ; } else {
final Iterator < Map . Entry < K , V > > it = createEntrySetIterator () ; while ( it . hasNext () ) { total += it . next () . hashCode () ; MST[rv.UOI1Mutator]MSP[] } return total ; } @Override public String toString () {
while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( convertedKey , entry . key ) ) { MST[NegateConditionalsMutator]MSP[] final V oldValue = entry . getValue () ; updateEntry ( entry , value ) ; return oldValue ; }
h += ~ ( h << 9 ) ; MST[rv.CRCR1Mutator]MSP[] h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; return h ; } protected boolean isEqualKey ( final Object key1 , final Object key2 ) {
final int oldCapacity = data . length ; if ( newCapacity <= oldCapacity ) { return; } if ( size == 0 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] threshold = calculateThreshold ( newCapacity , loadFactor ) ; data = new HashEntry [ newCapacity ] ; } else {
final Object convertedKey = convertKey ( key ) ; final int hashCode = hash ( convertedKey ) ; final int index = hashIndex ( hashCode , data . length ) ; HashEntry < K , V > entry = data [ index ] ; MST[rv.UOI1Mutator]MSP[]
if ( size () == 0 ) { MST[NonVoidMethodCallMutator]MSP[] return lr_6 ; } final StringBuilder buf = new StringBuilder ( 32 * size () ) ; buf . append ( '{' ) ; final MapIterator < K , V > it = mapIterator () ;
HashEntry < K , V > entry = data [ hashIndex ( hashCode , data . length ) ] ; while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { MST[NegateConditionalsMutator]MSP[] return entry ; }
protected void doWriteObject ( final ObjectOutputStream out ) throws IOException { out . writeFloat ( loadFactor ) ; out . writeInt ( data . length ) ; out . writeInt ( size ) ; MST[rv.UOI4Mutator]MSP[]
return entry . getValue () ; } entry = entry . next ; } return null ; } @Override public int size () { return size ; } @Override public boolean isEmpty () { return size == 0 ; MST[rv.ABSMutator]MSP[] } @Override public boolean containsKey ( Object key ) {
final int newSize = (int) ( ( size + mapSize ) / loadFactor + 1 ) ; MST[rv.AOR2Mutator]MSP[] ensureCapacity ( calculateNewCapacity ( newSize ) ) ; for ( final Map . Entry < ? extends K , ? extends V > entry : map . entrySet () ) {
final HashEntry < K , V > entry = createEntry ( data [ hashIndex ] , hashCode , key , value ) ; MST[rv.UOI3Mutator]MSP[] addEntry ( entry , hashIndex ) ; size ++ ; checkCapacity () ; }
h += ~ ( h << 9 ) ; h ^= h >>> 14 ; MST[rv.UOI3Mutator]MSP[] h += h << 4 ; h ^= h >>> 10 ; return h ; } protected boolean isEqualKey ( final Object key1 , final Object key2 ) {
if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { MST[rv.UOI3Mutator]MSP[] return true ; } entry = entry . next ; } return false ; } @Override public boolean containsValue ( final Object value ) { if ( value == null ) {
} } catch ( final ClassCastException ignored ) { return false ; } catch ( final NullPointerException ignored ) { return false ; } return true ; MST[BooleanFalseReturnValsMutator]MSP[] } @Override public int hashCode () { int total = 0 ;
final int index = hashIndex ( entry . hashCode , newCapacity ) ; entry . next = newEntries [ index ] ; MST[rv.UOI4Mutator]MSP[] newEntries [ index ] = entry ; entry = next ; } while ( entry != null ); } }
} return null ; } @Override public void clear () { modCount ++ ; final HashEntry < K , V > [] data = this . data ; for ( int i = data . length - 1 ; i >= 0 ; i -- ) { MST[rv.ROR5Mutator]MSP[]
final int oldCapacity = data . length ; if ( newCapacity <= oldCapacity ) { return; } if ( size == 0 ) { MST[rv.UOI4Mutator]MSP[] threshold = calculateThreshold ( newCapacity , loadFactor ) ; data = new HashEntry [ newCapacity ] ; } else {
return entry . getValue () ; } entry = entry . next ; } return null ; } @Override public int size () { return size ; } @Override public boolean isEmpty () { return size == 0 ; MST[InlineConstantMutator]MSP[] } @Override public boolean containsKey ( Object key ) {
while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( convertedKey , entry . key ) ) { MST[rv.ROR5Mutator]MSP[] final V oldValue = entry . getValue () ; updateEntry ( entry , value ) ; return oldValue ; }
if ( obj instanceof Map == false ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return false ; } final Map < ? , ? > map = ( Map < ? , ? > ) obj ; if ( map . size () != size () ) { return false ; }
} } catch ( final ClassCastException ignored ) { return false ; } catch ( final NullPointerException ignored ) { return false ; } return true ; MST[rv.CRCR4Mutator]MSP[] } @Override public int hashCode () { int total = 0 ;
public MapIterator < K , V > mapIterator () { if ( size == 0 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return EmptyMapIterator . <K , V > emptyMapIterator () ; } return new HashMapIterator <> ( this ) ; } @Override public K next () {
protected void init () { } @Override public V get ( Object key ) { key = convertKey ( key ) ; final int hashCode = hash ( key ) ; MST[NonVoidMethodCallMutator]MSP[]
while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( convertedKey , entry . key ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] final V oldValue = entry . getValue () ; updateEntry ( entry , value ) ; return oldValue ; }
protected int hashIndex ( final int hashCode , final int dataSize ) { return hashCode & dataSize - 1 ; MST[rv.AOD2Mutator]MSP[] } protected HashEntry < K , V > getEntry ( Object key ) { key = convertKey ( key ) ; final int hashCode = hash ( key ) ;
public Set < Map . Entry < K , V > > entrySet () { if ( entrySet == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] entrySet = new EntrySet <> ( this ) ; } return entrySet ; }
final Object convertedKey = convertKey ( key ) ; MST[NonVoidMethodCallMutator]MSP[] final int hashCode = hash ( convertedKey ) ; final int index = hashIndex ( hashCode , data . length ) ; HashEntry < K , V > entry = data [ index ] ;
h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; MST[rv.CRCR4Mutator]MSP[] return h ; } protected boolean isEqualKey ( final Object key1 , final Object key2 ) {
return entry . getValue () ; } entry = entry . next ; } return null ; } @Override public int size () { return size ; } @Override public boolean isEmpty () { return size == 0 ; MST[rv.ROR3Mutator]MSP[] } @Override public boolean containsKey ( Object key ) {
h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; MST[rv.AOR3Mutator]MSP[] h ^= h >>> 10 ; return h ; } protected boolean isEqualKey ( final Object key1 , final Object key2 ) {
h += ~ ( h << 9 ) ; MST[rv.UOI1Mutator]MSP[] h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; return h ; } protected boolean isEqualKey ( final Object key1 , final Object key2 ) {
HashEntry < K , V > entry = data [ hashIndex ( hashCode , data . length ) ] ; while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { MST[rv.UOI4Mutator]MSP[]
return entry . getValue () ; } entry = entry . next ; } return null ; } @Override public int size () { return size ; } @Override public boolean isEmpty () { return size == 0 ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] } @Override public boolean containsKey ( Object key ) {
protected void removeEntry ( final HashEntry < K , V > entry , final int hashIndex , final HashEntry < K , V > previous ) { if ( previous == null ) { MST[rv.ROR5Mutator]MSP[] data [ hashIndex ] = entry . next ; } else {
if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { MST[rv.ROR1Mutator]MSP[] final V oldValue = entry . getValue () ; removeMapping ( entry , index , previous ) ; return oldValue ; } previous = entry ; entry = entry . next ;
newCapacity <<= 1 ; } if ( newCapacity > MAXIMUM_CAPACITY ) { newCapacity = MAXIMUM_CAPACITY ; } } return newCapacity ; MST[PrimitiveReturnsMutator]MSP[] } protected int calculateThreshold ( final int newCapacity , final float factor ) { return (int) ( newCapacity * factor ) ; }
return EmptyIterator . <K > emptyIterator () ; MST[NullReturnValsMutator]MSP[] } return new KeySetIterator <> ( this ) ; } @Override public int size () { return parent . size () ; } @Override public void clear () { parent . clear () ; } @Override
final int oldCapacity = data . length ; if ( newCapacity <= oldCapacity ) { MST[rv.ABSMutator]MSP[] return; } if ( size == 0 ) { threshold = calculateThreshold ( newCapacity , loadFactor ) ; data = new HashEntry [ newCapacity ] ; } else {
} return null ; } @Override public void clear () { modCount ++ ; final HashEntry < K , V > [] data = this . data ; for ( int i = data . length - 1 ; i >= 0 ; i -- ) { MST[NegateConditionalsMutator]MSP[]
entry = entry . next ; } } } else { for ( final HashEntry < K , V > element : data ) { MST[rv.UOI4Mutator]MSP[] HashEntry < K , V > entry = element ; while ( entry != null ) {
if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { final V oldValue = entry . getValue () ; MST[NonVoidMethodCallMutator]MSP[] removeMapping ( entry , index , previous ) ; return oldValue ; } previous = entry ; entry = entry . next ;
private void _putAll ( final Map < ? extends K , ? extends V > map ) { final int mapSize = map . size () ; if ( mapSize == 0 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return; }
data = new HashEntry [ capacity ] ; for ( int i = 0 ; i < size ; i ++ ) { MST[rv.UOI1Mutator]MSP[] final K key = ( K ) in . readObject () ; final V value = ( V ) in . readObject () ;
if ( obj instanceof Map == false ) { return false ; } final Map < ? , ? > map = ( Map < ? , ? > ) obj ; if ( map . size () != size () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return false ; }
final int newSize = (int) ( ( size + mapSize ) / loadFactor + 1 ) ; MST[rv.UOI3Mutator]MSP[] ensureCapacity ( calculateNewCapacity ( newSize ) ) ; for ( final Map . Entry < ? extends K , ? extends V > entry : map . entrySet () ) {
if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { MST[rv.ROR2Mutator]MSP[] return true ; } entry = entry . next ; } return false ; } @Override public boolean containsValue ( final Object value ) { if ( value == null ) {
newCapacity <<= 1 ; } if ( newCapacity > MAXIMUM_CAPACITY ) { MST[rv.ROR5Mutator]MSP[] newCapacity = MAXIMUM_CAPACITY ; } } return newCapacity ; } protected int calculateThreshold ( final int newCapacity , final float factor ) { return (int) ( newCapacity * factor ) ; }
if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { return true ; } entry = entry . next ; } return false ; } @Override public boolean containsValue ( final Object value ) { if ( value == null ) { MST[rv.ROR5Mutator]MSP[]
return key1 == key2 || key1 . equals ( key2 ) ; } protected boolean isEqualValue ( final Object value1 , final Object value2 ) { return value1 == value2 || value1 . equals ( value2 ) ; MST[rv.ROR5Mutator]MSP[] }
if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { MST[rv.UOI4Mutator]MSP[] final V oldValue = entry . getValue () ; removeMapping ( entry , index , previous ) ; return oldValue ; } previous = entry ; entry = entry . next ;
threshold = calculateThreshold ( newCapacity , loadFactor ) ; data = newEntries ; } } protected int calculateNewCapacity ( final int proposedCapacity ) { int newCapacity = 1 ; if ( proposedCapacity > MAXIMUM_CAPACITY ) { newCapacity = MAXIMUM_CAPACITY ; } else { while ( newCapacity < proposedCapacity ) { MST[rv.ROR2Mutator]MSP[]
entry = entry . next ; } addMapping ( index , hashCode , key , value ) ; return null ; MST[ReturnValsMutator]MSP[] } @Override public void putAll ( final Map < ? extends K , ? extends V > map ) { _putAll ( map ) ; }
final int newSize = (int) ( ( size + mapSize ) / loadFactor + 1 ) ; MST[rv.AOD1Mutator]MSP[] ensureCapacity ( calculateNewCapacity ( newSize ) ) ; for ( final Map . Entry < ? extends K , ? extends V > entry : map . entrySet () ) {
newCapacity <<= 1 ; MST[rv.UOI1Mutator]MSP[] } if ( newCapacity > MAXIMUM_CAPACITY ) { newCapacity = MAXIMUM_CAPACITY ; } } return newCapacity ; } protected int calculateThreshold ( final int newCapacity , final float factor ) { return (int) ( newCapacity * factor ) ; }
HashEntry < K , V > entry = data [ hashIndex ( hashCode , data . length ) ] ; while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { MST[rv.ROR2Mutator]MSP[] return entry ; }
if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { return true ; MST[rv.CRCR2Mutator]MSP[] } entry = entry . next ; } return false ; } @Override public boolean containsValue ( final Object value ) { if ( value == null ) {
entry = entry . next ; } } } else { for ( final HashEntry < K , V > element : data ) { HashEntry < K , V > entry = element ; while ( entry != null ) { MST[rv.ROR5Mutator]MSP[]
if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { return true ; MST[rv.CRCR6Mutator]MSP[] } entry = entry . next ; } return false ; } @Override public boolean containsValue ( final Object value ) { if ( value == null ) {
while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( convertedKey , entry . key ) ) { MST[rv.ROR3Mutator]MSP[] final V oldValue = entry . getValue () ; updateEntry ( entry , value ) ; return oldValue ; }
final int newSize = (int) ( ( size + mapSize ) / loadFactor + 1 ) ; MST[rv.CRCR3Mutator]MSP[] ensureCapacity ( calculateNewCapacity ( newSize ) ) ; for ( final Map . Entry < ? extends K , ? extends V > entry : map . entrySet () ) {
h += ~ ( h << 9 ) ; MST[rv.AOD2Mutator]MSP[] h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; return h ; } protected boolean isEqualKey ( final Object key1 , final Object key2 ) {
HashEntry < K , V > entry = data [ hashIndex ( hashCode , data . length ) ] ; while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { MST[rv.UOI3Mutator]MSP[] return entry ; }
h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; MST[rv.UOI4Mutator]MSP[] return h ; } protected boolean isEqualKey ( final Object key1 , final Object key2 ) {
if ( size >= threshold ) { final int newCapacity = data . length * 2 ; if ( newCapacity <= MAXIMUM_CAPACITY ) { ensureCapacity ( newCapacity ) ; MST[rv.ABSMutator]MSP[] } } } @SuppressWarnings ( lr_1 ) protected void ensureCapacity ( final int newCapacity ) {
final int oldCapacity = data . length ; if ( newCapacity <= oldCapacity ) { MST[rv.UOI2Mutator]MSP[] return; } if ( size == 0 ) { threshold = calculateThreshold ( newCapacity , loadFactor ) ; data = new HashEntry [ newCapacity ] ; } else {
h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; return h ; MST[rv.UOI1Mutator]MSP[] } protected boolean isEqualKey ( final Object key1 , final Object key2 ) {
protected int hashIndex ( final int hashCode , final int dataSize ) { return hashCode & dataSize - 1 ; MST[rv.UOI2Mutator]MSP[] } protected HashEntry < K , V > getEntry ( Object key ) { key = convertKey ( key ) ; final int hashCode = hash ( key ) ;
data [ i ] = null ; } size = 0 ; } protected Object convertKey ( final Object key ) { return key == null ? NULL : key ; MST[rv.ROR5Mutator]MSP[] } protected int hash ( final Object key ) { int h = key . hashCode () ;
entry . key = key ; entry . value = value ; } protected void addMapping ( final int hashIndex , final int hashCode , final K key , final V value ) { modCount ++ ; MST[rv.AOD1Mutator]MSP[]
threshold = calculateThreshold ( newCapacity , loadFactor ) ; MST[rv.UOI3Mutator]MSP[] data = newEntries ; } } protected int calculateNewCapacity ( final int proposedCapacity ) { int newCapacity = 1 ; if ( proposedCapacity > MAXIMUM_CAPACITY ) { newCapacity = MAXIMUM_CAPACITY ; } else { while ( newCapacity < proposedCapacity ) {
if ( map . get ( key ) != null || map . containsKey ( key ) == false ) { return false ; } } else { if ( value . equals ( map . get ( key ) ) == false ) { MST[rv.ROR4Mutator]MSP[] return false ; } }
return key1 == key2 || key1 . equals ( key2 ) ; } protected boolean isEqualValue ( final Object value1 , final Object value2 ) { return value1 == value2 || value1 . equals ( value2 ) ; MST[NegateConditionalsMutator]MSP[] }
for ( final MapIterator < K , V > it = mapIterator () ; it . hasNext () ; ) { out . writeObject ( it . next () ) ; MST[NonVoidMethodCallMutator]MSP[] out . writeObject ( it . getValue () ) ; } } @SuppressWarnings ( lr_1 )
final int newSize = (int) ( ( size + mapSize ) / loadFactor + 1 ) ; ensureCapacity ( calculateNewCapacity ( newSize ) ) ; MST[rv.UOI2Mutator]MSP[] for ( final Map . Entry < ? extends K , ? extends V > entry : map . entrySet () ) {
h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; return h ; MST[rv.ABSMutator]MSP[] } protected boolean isEqualKey ( final Object key1 , final Object key2 ) {
while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( convertedKey , entry . key ) ) { final V oldValue = entry . getValue () ; updateEntry ( entry , value ) ; return oldValue ; MST[NullReturnValsMutator]MSP[] }
return entry . getValue () ; } entry = entry . next ; } return null ; } @Override public int size () { return size ; } @Override public boolean isEmpty () { return size == 0 ; MST[rv.UOI2Mutator]MSP[] } @Override public boolean containsKey ( Object key ) {
} return null ; } @Override public void clear () { modCount ++ ; final HashEntry < K , V > [] data = this . data ; for ( int i = data . length - 1 ; i >= 0 ; i -- ) { MST[rv.AOD2Mutator]MSP[]
private void _putAll ( final Map < ? extends K , ? extends V > map ) { final int mapSize = map . size () ; if ( mapSize == 0 ) { MST[rv.UOI4Mutator]MSP[] return; }
threshold = calculateThreshold ( newCapacity , loadFactor ) ; data = newEntries ; } } protected int calculateNewCapacity ( final int proposedCapacity ) { int newCapacity = 1 ; if ( proposedCapacity > MAXIMUM_CAPACITY ) { newCapacity = MAXIMUM_CAPACITY ; } else { while ( newCapacity < proposedCapacity ) { MST[rv.ROR5Mutator]MSP[]
put ( key , value ) ; MST[ArgumentPropagationMutator]MSP[] } } @Override @SuppressWarnings ( lr_1 ) protected AbstractHashedMap < K , V > clone () { try { final AbstractHashedMap < K , V > cloned = ( AbstractHashedMap < K , V > ) super . clone () ;
h += ~ ( h << 9 ) ; MST[rv.CRCR6Mutator]MSP[] h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; return h ; } protected boolean isEqualKey ( final Object key1 , final Object key2 ) {
HashEntry < K , V > entry = data [ hashIndex ( hashCode , data . length ) ] ; while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { MST[rv.ROR1Mutator]MSP[]
} return null ; } @Override public void clear () { modCount ++ ; final HashEntry < K , V > [] data = this . data ; for ( int i = data . length - 1 ; i >= 0 ; i -- ) { MST[rv.UOI4Mutator]MSP[]
cloned . putAll ( this ) ; return cloned ; } catch ( final CloneNotSupportedException ex ) { throw new InternalError () ; } } @Override public boolean equals ( final Object obj ) { if ( obj == this ) { MST[NegateConditionalsMutator]MSP[] return true ; }
HashEntry < K , V > entry = data [ hashIndex ( hashCode , data . length ) ] ; while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { MST[rv.ROR3Mutator]MSP[]
final int oldCapacity = data . length ; if ( newCapacity <= oldCapacity ) { return; } if ( size == 0 ) { MST[rv.ROR5Mutator]MSP[] threshold = calculateThreshold ( newCapacity , loadFactor ) ; data = new HashEntry [ newCapacity ] ; } else {
if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { return true ; } entry = entry . next ; } return false ; } @Override public boolean containsValue ( final Object value ) { if ( value == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
protected int hashIndex ( final int hashCode , final int dataSize ) { return hashCode & dataSize - 1 ; MST[InlineConstantMutator]MSP[] } protected HashEntry < K , V > getEntry ( Object key ) { key = convertKey ( key ) ; final int hashCode = hash ( key ) ;
h += ~ ( h << 9 ) ; MST[rv.ABSMutator]MSP[] h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; return h ; } protected boolean isEqualKey ( final Object key1 , final Object key2 ) {
protected Iterator < Map . Entry < K , V > > createEntrySetIterator () { if ( size () == 0 ) { MST[rv.ROR2Mutator]MSP[] return EmptyIterator . < Map . Entry < K , V > > emptyIterator () ; } return new EntrySetIterator <> ( this ) ; } @Override
entry = entry . next ; } } } else { for ( final HashEntry < K , V > element : data ) { HashEntry < K , V > entry = element ; while ( entry != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
protected void removeMapping ( final HashEntry < K , V > entry , final int hashIndex , final HashEntry < K , V > previous ) { modCount ++ ; MST[rv.UOI3Mutator]MSP[] removeEntry ( entry , hashIndex , previous ) ; size -- ; destroyEntry ( entry ) ; }
while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( convertedKey , entry . key ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] final V oldValue = entry . getValue () ; updateEntry ( entry , value ) ; return oldValue ; }
final int newSize = (int) ( ( size + mapSize ) / loadFactor + 1 ) ; MST[MathMutator]MSP[] ensureCapacity ( calculateNewCapacity ( newSize ) ) ; for ( final Map . Entry < ? extends K , ? extends V > entry : map . entrySet () ) {
} return null ; MST[ReturnValsMutator]MSP[] } @Override public void clear () { modCount ++ ; final HashEntry < K , V > [] data = this . data ; for ( int i = data . length - 1 ; i >= 0 ; i -- ) {
protected void removeEntry ( final HashEntry < K , V > entry , final int hashIndex , final HashEntry < K , V > previous ) { if ( previous == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] data [ hashIndex ] = entry . next ; } else {
while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( convertedKey , entry . key ) ) { MST[rv.UOI3Mutator]MSP[] final V oldValue = entry . getValue () ; updateEntry ( entry , value ) ; return oldValue ; }
h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; MST[rv.CRCR3Mutator]MSP[] h ^= h >>> 10 ; return h ; } protected boolean isEqualKey ( final Object key1 , final Object key2 ) {
final int oldCapacity = data . length ; if ( newCapacity <= oldCapacity ) { return; } if ( size == 0 ) { MST[rv.ROR2Mutator]MSP[] threshold = calculateThreshold ( newCapacity , loadFactor ) ; data = new HashEntry [ newCapacity ] ; } else {
return entry . getValue () ; MST[NonVoidMethodCallMutator]MSP[] } entry = entry . next ; } return null ; } @Override public int size () { return size ; } @Override public boolean isEmpty () { return size == 0 ; } @Override public boolean containsKey ( Object key ) {
public MapIterator < K , V > mapIterator () { if ( size == 0 ) { MST[rv.ROR5Mutator]MSP[] return EmptyMapIterator . <K , V > emptyMapIterator () ; } return new HashMapIterator <> ( this ) ; } @Override public K next () {
if ( isEqualValue ( value , entry . getValue () ) ) { return true ; } entry = entry . next ; } } } return false ; MST[rv.CRCR6Mutator]MSP[] } @Override public V put ( final K key , final V value ) {
while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( convertedKey , entry . key ) ) { MST[rv.ROR2Mutator]MSP[] final V oldValue = entry . getValue () ; updateEntry ( entry , value ) ; return oldValue ; }
final int oldCapacity = data . length ; if ( newCapacity <= oldCapacity ) { MST[rv.ROR2Mutator]MSP[] return; } if ( size == 0 ) { threshold = calculateThreshold ( newCapacity , loadFactor ) ; data = new HashEntry [ newCapacity ] ; } else {
if ( isEqualValue ( value , entry . getValue () ) ) { MST[NonVoidMethodCallMutator]MSP[] return true ; } entry = entry . next ; } } } return false ; } @Override public V put ( final K key , final V value ) {
} return null ; } @Override public void clear () { modCount ++ ; final HashEntry < K , V > [] data = this . data ; for ( int i = data . length - 1 ; i >= 0 ; i -- ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[]
return entry . getValue () ; } entry = entry . next ; } return null ; } @Override public int size () { return size ; } @Override public boolean isEmpty () { return size == 0 ; MST[InlineConstantMutator]MSP[] } @Override public boolean containsKey ( Object key ) {
protected int hashIndex ( final int hashCode , final int dataSize ) { return hashCode & dataSize - 1 ; MST[rv.ABSMutator]MSP[] } protected HashEntry < K , V > getEntry ( Object key ) { key = convertKey ( key ) ; final int hashCode = hash ( key ) ;
h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; MST[MathMutator]MSP[] return h ; } protected boolean isEqualKey ( final Object key1 , final Object key2 ) {
final HashEntry < K , V > oldEntries [] = data ; final HashEntry < K , V > newEntries [] = new HashEntry [ newCapacity ] ; modCount ++ ; for ( int i = oldCapacity - 1 ; i >= 0 ; i -- ) { MST[rv.UOI2Mutator]MSP[]
newCapacity <<= 1 ; } if ( newCapacity > MAXIMUM_CAPACITY ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] newCapacity = MAXIMUM_CAPACITY ; } } return newCapacity ; } protected int calculateThreshold ( final int newCapacity , final float factor ) { return (int) ( newCapacity * factor ) ; }
h += ~ ( h << 9 ) ; h ^= h >>> 14 ; MST[MathMutator]MSP[] h += h << 4 ; h ^= h >>> 10 ; return h ; } protected boolean isEqualKey ( final Object key1 , final Object key2 ) {
protected void doWriteObject ( final ObjectOutputStream out ) throws IOException { out . writeFloat ( loadFactor ) ; MST[VoidMethodCallMutator]MSP[] out . writeInt ( data . length ) ; out . writeInt ( size ) ;
public Set < K > keySet () { if ( keySet == null ) { MST[NegateConditionalsMutator]MSP[] keySet = new KeySet <> ( this ) ; } return keySet ; } protected Iterator < K > createKeySetIterator () { if ( size () == 0 ) {
if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { final V oldValue = entry . getValue () ; removeMapping ( entry , index , previous ) ; MST[rv.UOI3Mutator]MSP[] return oldValue ; } previous = entry ; entry = entry . next ;
previous . next = entry . next ; } } protected void destroyEntry ( final HashEntry < K , V > entry ) { entry . next = null ; entry . key = null ; entry . value = null ; MST[experimental.MemberVariableMutator]MSP[] } protected void checkCapacity () {
HashEntry < K , V > entry = data [ hashIndex ( hashCode , data . length ) ] ; while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { MST[rv.UOI3Mutator]MSP[]
newCapacity <<= 1 ; } if ( newCapacity > MAXIMUM_CAPACITY ) { newCapacity = MAXIMUM_CAPACITY ; } } return newCapacity ; } protected int calculateThreshold ( final int newCapacity , final float factor ) { return (int) ( newCapacity * factor ) ; MST[rv.UOI2Mutator]MSP[] }
protected void doReadObject ( final ObjectInputStream in ) throws IOException , ClassNotFoundException { loadFactor = in . readFloat () ; final int capacity = in . readInt () ; final int size = in . readInt () ; init () ; threshold = calculateThreshold ( capacity , loadFactor ) ; MST[rv.ABSMutator]MSP[]
protected HashEntry < K , V > createEntry ( final HashEntry < K , V > next , final int hashCode , final K key , final V value ) { return new HashEntry <> ( next , hashCode , convertKey ( key ) , value ) ; MST[NonVoidMethodCallMutator]MSP[] }
if ( size () == 0 ) { MST[rv.ROR3Mutator]MSP[] return lr_6 ; } final StringBuilder buf = new StringBuilder ( 32 * size () ) ; buf . append ( '{' ) ; final MapIterator < K , V > it = mapIterator () ;
public MapIterator < K , V > mapIterator () { if ( size == 0 ) { MST[rv.ROR2Mutator]MSP[] return EmptyMapIterator . <K , V > emptyMapIterator () ; } return new HashMapIterator <> ( this ) ; } @Override public K next () {
final HashEntry < K , V > entry = createEntry ( data [ hashIndex ] , hashCode , key , value ) ; MST[rv.UOI2Mutator]MSP[] addEntry ( entry , hashIndex ) ; size ++ ; checkCapacity () ; }
if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { final V oldValue = entry . getValue () ; removeMapping ( entry , index , previous ) ; return oldValue ; MST[NullReturnValsMutator]MSP[] } previous = entry ; entry = entry . next ;
data = new HashEntry [ capacity ] ; for ( int i = 0 ; i < size ; i ++ ) { MST[rv.ABSMutator]MSP[] final K key = ( K ) in . readObject () ; final V value = ( V ) in . readObject () ;
data [ i ] = null ; } size = 0 ; } protected Object convertKey ( final Object key ) { return key == null ? NULL : key ; MST[NegateConditionalsMutator]MSP[] } protected int hash ( final Object key ) { int h = key . hashCode () ;
data = new HashEntry [ capacity ] ; for ( int i = 0 ; i < size ; i ++ ) { MST[rv.UOI4Mutator]MSP[] final K key = ( K ) in . readObject () ; final V value = ( V ) in . readObject () ;
} return null ; } @Override public void clear () { modCount ++ ; MST[InlineConstantMutator]MSP[] final HashEntry < K , V > [] data = this . data ; for ( int i = data . length - 1 ; i >= 0 ; i -- ) {
data = new HashEntry [ capacity ] ; MST[rv.UOI2Mutator]MSP[] for ( int i = 0 ; i < size ; i ++ ) { final K key = ( K ) in . readObject () ; final V value = ( V ) in . readObject () ;
final int newSize = (int) ( ( size + mapSize ) / loadFactor + 1 ) ; ensureCapacity ( calculateNewCapacity ( newSize ) ) ; MST[NonVoidMethodCallMutator]MSP[] for ( final Map . Entry < ? extends K , ? extends V > entry : map . entrySet () ) {
final int index = hashIndex ( hashCode , data . length ) ; HashEntry < K , V > entry = data [ index ] ; HashEntry < K , V > previous = null ; while ( entry != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
private void _putAll ( final Map < ? extends K , ? extends V > map ) { final int mapSize = map . size () ; if ( mapSize == 0 ) { MST[rv.ROR2Mutator]MSP[] return; }
if ( size >= threshold ) { final int newCapacity = data . length * 2 ; if ( newCapacity <= MAXIMUM_CAPACITY ) { MST[rv.UOI3Mutator]MSP[] ensureCapacity ( newCapacity ) ; } } } @SuppressWarnings ( lr_1 ) protected void ensureCapacity ( final int newCapacity ) {
entry = entry . next ; } addMapping ( index , hashCode , key , value ) ; MST[rv.ABSMutator]MSP[] return null ; } @Override public void putAll ( final Map < ? extends K , ? extends V > map ) { _putAll ( map ) ; }
return key1 == key2 || key1 . equals ( key2 ) ; } protected boolean isEqualValue ( final Object value1 , final Object value2 ) { return value1 == value2 || value1 . equals ( value2 ) ; MST[rv.ROR5Mutator]MSP[] }
newCapacity <<= 1 ; } if ( newCapacity > MAXIMUM_CAPACITY ) { MST[rv.CRCR5Mutator]MSP[] newCapacity = MAXIMUM_CAPACITY ; } } return newCapacity ; } protected int calculateThreshold ( final int newCapacity , final float factor ) { return (int) ( newCapacity * factor ) ; }
entry = entry . next ; } } } else { for ( final HashEntry < K , V > element : data ) { MST[rv.UOI1Mutator]MSP[] HashEntry < K , V > entry = element ; while ( entry != null ) {
entry = entry . next ; } addMapping ( index , hashCode , key , value ) ; MST[rv.UOI2Mutator]MSP[] return null ; } @Override public void putAll ( final Map < ? extends K , ? extends V > map ) { _putAll ( map ) ; }
final int newSize = (int) ( ( size + mapSize ) / loadFactor + 1 ) ; MST[rv.UOI3Mutator]MSP[] ensureCapacity ( calculateNewCapacity ( newSize ) ) ; for ( final Map . Entry < ? extends K , ? extends V > entry : map . entrySet () ) {
final int newSize = (int) ( ( size + mapSize ) / loadFactor + 1 ) ; MST[rv.AOD1Mutator]MSP[] ensureCapacity ( calculateNewCapacity ( newSize ) ) ; for ( final Map . Entry < ? extends K , ? extends V > entry : map . entrySet () ) {
if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { MST[rv.UOI3Mutator]MSP[] final V oldValue = entry . getValue () ; removeMapping ( entry , index , previous ) ; return oldValue ; } previous = entry ; entry = entry . next ;
if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return true ; } entry = entry . next ; } return false ; } @Override public boolean containsValue ( final Object value ) { if ( value == null ) {
threshold = calculateThreshold ( newCapacity , loadFactor ) ; data = newEntries ; } } protected int calculateNewCapacity ( final int proposedCapacity ) { int newCapacity = 1 ; if ( proposedCapacity > MAXIMUM_CAPACITY ) { newCapacity = MAXIMUM_CAPACITY ; } else { while ( newCapacity < proposedCapacity ) { MST[rv.UOI4Mutator]MSP[]
data = new HashEntry [ capacity ] ; MST[experimental.MemberVariableMutator]MSP[] for ( int i = 0 ; i < size ; i ++ ) { final K key = ( K ) in . readObject () ; final V value = ( V ) in . readObject () ;
final Iterator < Map . Entry < K , V > > it = createEntrySetIterator () ; while ( it . hasNext () ) { total += it . next () . hashCode () ; } return total ; MST[rv.UOI2Mutator]MSP[] } @Override public String toString () {
protected void removeMapping ( final HashEntry < K , V > entry , final int hashIndex , final HashEntry < K , V > previous ) { modCount ++ ; removeEntry ( entry , hashIndex , previous ) ; size -- ; MST[InlineConstantMutator]MSP[] destroyEntry ( entry ) ; }
if ( size >= threshold ) { final int newCapacity = data . length * 2 ; MST[rv.AOR2Mutator]MSP[] if ( newCapacity <= MAXIMUM_CAPACITY ) { ensureCapacity ( newCapacity ) ; } } } @SuppressWarnings ( lr_1 ) protected void ensureCapacity ( final int newCapacity ) {
protected void removeMapping ( final HashEntry < K , V > entry , final int hashIndex , final HashEntry < K , V > previous ) { modCount ++ ; removeEntry ( entry , hashIndex , previous ) ; size -- ; MST[rv.UOI1Mutator]MSP[] destroyEntry ( entry ) ; }
HashEntry < K , V > entry = oldEntries [ i ] ; MST[rv.ABSMutator]MSP[] if ( entry != null ) { oldEntries [ i ] = null ; do { final HashEntry < K , V > next = entry . next ;
entry . key = key ; entry . value = value ; } protected void addMapping ( final int hashIndex , final int hashCode , final K key , final V value ) { modCount ++ ; MST[rv.CRCR4Mutator]MSP[]
final Object convertedKey = convertKey ( key ) ; final int hashCode = hash ( convertedKey ) ; final int index = hashIndex ( hashCode , data . length ) ; HashEntry < K , V > entry = data [ index ] ; MST[rv.ABSMutator]MSP[]
data = new HashEntry [ capacity ] ; for ( int i = 0 ; i < size ; i ++ ) { MST[rv.ROR2Mutator]MSP[] final K key = ( K ) in . readObject () ; final V value = ( V ) in . readObject () ;
return key1 == key2 || key1 . equals ( key2 ) ; } protected boolean isEqualValue ( final Object value1 , final Object value2 ) { return value1 == value2 || value1 . equals ( value2 ) ; MST[NegateConditionalsMutator]MSP[] }
final HashEntry < K , V > entry = createEntry ( data [ hashIndex ] , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; size ++ ; MST[rv.AOR1Mutator]MSP[] checkCapacity () ; }
if ( isEqualValue ( value , entry . getValue () ) ) { return true ; } entry = entry . next ; } } } return false ; MST[BooleanTrueReturnValsMutator]MSP[] } @Override public V put ( final K key , final V value ) {
final HashEntry < K , V > oldEntries [] = data ; final HashEntry < K , V > newEntries [] = new HashEntry [ newCapacity ] ; modCount ++ ; MST[rv.ABSMutator]MSP[] for ( int i = oldCapacity - 1 ; i >= 0 ; i -- ) {
final HashEntry < K , V > oldEntries [] = data ; final HashEntry < K , V > newEntries [] = new HashEntry [ newCapacity ] ; modCount ++ ; for ( int i = oldCapacity - 1 ; i >= 0 ; i -- ) { MST[ConditionalsBoundaryMutator]MSP[]
return entry . getValue () ; } entry = entry . next ; } return null ; } @Override public int size () { return size ; MST[rv.ABSMutator]MSP[] } @Override public boolean isEmpty () { return size == 0 ; } @Override public boolean containsKey ( Object key ) {
final HashEntry < K , V > entry = createEntry ( data [ hashIndex ] , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; MST[rv.ABSMutator]MSP[] size ++ ; checkCapacity () ; }
public Set < K > keySet () { if ( keySet == null ) { keySet = new KeySet <> ( this ) ; } return keySet ; } protected Iterator < K > createKeySetIterator () { if ( size () == 0 ) { MST[rv.ROR3Mutator]MSP[]
if ( size >= threshold ) { MST[rv.UOI4Mutator]MSP[] final int newCapacity = data . length * 2 ; if ( newCapacity <= MAXIMUM_CAPACITY ) { ensureCapacity ( newCapacity ) ; } } } @SuppressWarnings ( lr_1 ) protected void ensureCapacity ( final int newCapacity ) {
protected Iterator < Map . Entry < K , V > > createEntrySetIterator () { if ( size () == 0 ) { return EmptyIterator . < Map . Entry < K , V > > emptyIterator () ; MST[NonVoidMethodCallMutator]MSP[] } return new EntrySetIterator <> ( this ) ; } @Override
if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { MST[rv.ROR3Mutator]MSP[] final V oldValue = entry . getValue () ; removeMapping ( entry , index , previous ) ; return oldValue ; } previous = entry ; entry = entry . next ;
final HashEntry < K , V > oldEntries [] = data ; final HashEntry < K , V > newEntries [] = new HashEntry [ newCapacity ] ; modCount ++ ; MST[rv.CRCR5Mutator]MSP[] for ( int i = oldCapacity - 1 ; i >= 0 ; i -- ) {
h += ~ ( h << 9 ) ; MST[rv.CRCR4Mutator]MSP[] h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; return h ; } protected boolean isEqualKey ( final Object key1 , final Object key2 ) {
h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; MST[rv.UOI3Mutator]MSP[] h ^= h >>> 10 ; return h ; } protected boolean isEqualKey ( final Object key1 , final Object key2 ) {
protected Iterator < Map . Entry < K , V > > createEntrySetIterator () { if ( size () == 0 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return EmptyIterator . < Map . Entry < K , V > > emptyIterator () ; } return new EntrySetIterator <> ( this ) ; } @Override
final int oldCapacity = data . length ; if ( newCapacity <= oldCapacity ) { MST[rv.UOI1Mutator]MSP[] return; } if ( size == 0 ) { threshold = calculateThreshold ( newCapacity , loadFactor ) ; data = new HashEntry [ newCapacity ] ; } else {
while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( convertedKey , entry . key ) ) { MST[rv.UOI2Mutator]MSP[] final V oldValue = entry . getValue () ; updateEntry ( entry , value ) ; return oldValue ; }
} return null ; } @Override public void clear () { modCount ++ ; MST[rv.AOR2Mutator]MSP[] final HashEntry < K , V > [] data = this . data ; for ( int i = data . length - 1 ; i >= 0 ; i -- ) {
HashEntry < K , V > entry = data [ hashIndex ( hashCode , data . length ) ] ; while ( entry != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) {
protected void removeMapping ( final HashEntry < K , V > entry , final int hashIndex , final HashEntry < K , V > previous ) { modCount ++ ; MST[rv.CRCR3Mutator]MSP[] removeEntry ( entry , hashIndex , previous ) ; size -- ; destroyEntry ( entry ) ; }
if ( size >= threshold ) { final int newCapacity = data . length * 2 ; MST[InlineConstantMutator]MSP[] if ( newCapacity <= MAXIMUM_CAPACITY ) { ensureCapacity ( newCapacity ) ; } } } @SuppressWarnings ( lr_1 ) protected void ensureCapacity ( final int newCapacity ) {
} return null ; } @Override public void clear () { modCount ++ ; final HashEntry < K , V > [] data = this . data ; for ( int i = data . length - 1 ; i >= 0 ; i -- ) { MST[rv.CRCR2Mutator]MSP[]
protected void removeMapping ( final HashEntry < K , V > entry , final int hashIndex , final HashEntry < K , V > previous ) { modCount ++ ; MST[MathMutator]MSP[] removeEntry ( entry , hashIndex , previous ) ; size -- ; destroyEntry ( entry ) ; }
final Iterator < Map . Entry < K , V > > it = createEntrySetIterator () ; while ( it . hasNext () ) { total += it . next () . hashCode () ; MST[rv.UOI4Mutator]MSP[] } return total ; } @Override public String toString () {
protected void removeMapping ( final HashEntry < K , V > entry , final int hashIndex , final HashEntry < K , V > previous ) { modCount ++ ; MST[experimental.MemberVariableMutator]MSP[] removeEntry ( entry , hashIndex , previous ) ; size -- ; destroyEntry ( entry ) ; }
final int oldCapacity = data . length ; if ( newCapacity <= oldCapacity ) { return; } if ( size == 0 ) { threshold = calculateThreshold ( newCapacity , loadFactor ) ; MST[rv.UOI1Mutator]MSP[] data = new HashEntry [ newCapacity ] ; } else {
final int oldCapacity = data . length ; if ( newCapacity <= oldCapacity ) { return; } if ( size == 0 ) { threshold = calculateThreshold ( newCapacity , loadFactor ) ; data = new HashEntry [ newCapacity ] ; MST[rv.UOI3Mutator]MSP[] } else {
final Iterator < Map . Entry < K , V > > it = createEntrySetIterator () ; while ( it . hasNext () ) { total += it . next () . hashCode () ; MST[rv.AOD2Mutator]MSP[] } return total ; } @Override public String toString () {
final MapIterator < ? , ? > it = mapIterator () ; try { while ( it . hasNext () ) { MST[rv.ROR1Mutator]MSP[] final Object key = it . next () ; final Object value = it . getValue () ; if ( value == null ) {
final MapIterator < ? , ? > it = mapIterator () ; try { while ( it . hasNext () ) { final Object key = it . next () ; final Object value = it . getValue () ; if ( value == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
public MapIterator < K , V > mapIterator () { if ( size == 0 ) { MST[rv.UOI4Mutator]MSP[] return EmptyMapIterator . <K , V > emptyMapIterator () ; } return new HashMapIterator <> ( this ) ; } @Override public K next () {
final int index = hashIndex ( entry . hashCode , newCapacity ) ; MST[rv.UOI4Mutator]MSP[] entry . next = newEntries [ index ] ; newEntries [ index ] = entry ; entry = next ; } while ( entry != null ); } }
put ( entry . getKey () , entry . getValue () ) ; } } @Override public V remove ( Object key ) { key = convertKey ( key ) ; final int hashCode = hash ( key ) ; MST[NonVoidMethodCallMutator]MSP[]
if ( obj instanceof Map == false ) { return false ; } final Map < ? , ? > map = ( Map < ? , ? > ) obj ; if ( map . size () != size () ) { return false ; MST[rv.CRCR1Mutator]MSP[] }
entry = entry . next ; } } } else { for ( final HashEntry < K , V > element : data ) { MST[rv.UOI2Mutator]MSP[] HashEntry < K , V > entry = element ; while ( entry != null ) {
data = new HashEntry [ capacity ] ; for ( int i = 0 ; i < size ; i ++ ) { MST[rv.UOI3Mutator]MSP[] final K key = ( K ) in . readObject () ; final V value = ( V ) in . readObject () ;
put ( entry . getKey () , entry . getValue () ) ; } } @Override public V remove ( Object key ) { key = convertKey ( key ) ; MST[ArgumentPropagationMutator]MSP[] final int hashCode = hash ( key ) ;
protected void removeMapping ( final HashEntry < K , V > entry , final int hashIndex , final HashEntry < K , V > previous ) { modCount ++ ; removeEntry ( entry , hashIndex , previous ) ; size -- ; MST[rv.CRCR5Mutator]MSP[] destroyEntry ( entry ) ; }
protected void doReadObject ( final ObjectInputStream in ) throws IOException , ClassNotFoundException { loadFactor = in . readFloat () ; final int capacity = in . readInt () ; final int size = in . readInt () ; init () ; threshold = calculateThreshold ( capacity , loadFactor ) ; MST[rv.UOI3Mutator]MSP[]
final MapIterator < ? , ? > it = mapIterator () ; try { while ( it . hasNext () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] final Object key = it . next () ; final Object value = it . getValue () ; if ( value == null ) {
return entry . getValue () ; } entry = entry . next ; } return null ; } @Override public int size () { return size ; } @Override public boolean isEmpty () { return size == 0 ; MST[rv.ROR1Mutator]MSP[] } @Override public boolean containsKey ( Object key ) {
if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { MST[rv.ABSMutator]MSP[] final V oldValue = entry . getValue () ; removeMapping ( entry , index , previous ) ; return oldValue ; } previous = entry ; entry = entry . next ;
final HashEntry < K , V > oldEntries [] = data ; final HashEntry < K , V > newEntries [] = new HashEntry [ newCapacity ] ; modCount ++ ; MST[InlineConstantMutator]MSP[] for ( int i = oldCapacity - 1 ; i >= 0 ; i -- ) {
h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; MST[rv.CRCR6Mutator]MSP[] return h ; } protected boolean isEqualKey ( final Object key1 , final Object key2 ) {
entry = entry . next ; } } } else { for ( final HashEntry < K , V > element : data ) { MST[rv.ABSMutator]MSP[] HashEntry < K , V > entry = element ; while ( entry != null ) {
entry = entry . next ; } return null ; } protected void updateEntry ( final HashEntry < K , V > entry , final V newValue ) { entry . setValue ( newValue ) ; MST[ArgumentPropagationMutator]MSP[] }
data [ i ] = null ; } size = 0 ; } protected Object convertKey ( final Object key ) { return key == null ? NULL : key ; } protected int hash ( final Object key ) { int h = key . hashCode () ; MST[NonVoidMethodCallMutator]MSP[]
h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; MST[rv.UOI4Mutator]MSP[] h ^= h >>> 10 ; return h ; } protected boolean isEqualKey ( final Object key1 , final Object key2 ) {
threshold = calculateThreshold ( newCapacity , loadFactor ) ; MST[experimental.MemberVariableMutator]MSP[] data = newEntries ; } } protected int calculateNewCapacity ( final int proposedCapacity ) { int newCapacity = 1 ; if ( proposedCapacity > MAXIMUM_CAPACITY ) { newCapacity = MAXIMUM_CAPACITY ; } else { while ( newCapacity < proposedCapacity ) {
HashEntry < K , V > entry = oldEntries [ i ] ; MST[rv.UOI2Mutator]MSP[] if ( entry != null ) { oldEntries [ i ] = null ; do { final HashEntry < K , V > next = entry . next ;
cloned . putAll ( this ) ; MST[VoidMethodCallMutator]MSP[] return cloned ; } catch ( final CloneNotSupportedException ex ) { throw new InternalError () ; } } @Override public boolean equals ( final Object obj ) { if ( obj == this ) { return true ; }
HashEntry < K , V > entry = data [ hashIndex ( hashCode , data . length ) ] ; MST[rv.ABSMutator]MSP[] while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) {
final HashEntry < K , V > oldEntries [] = data ; final HashEntry < K , V > newEntries [] = new HashEntry [ newCapacity ] ; modCount ++ ; for ( int i = oldCapacity - 1 ; i >= 0 ; i -- ) { MST[rv.UOI4Mutator]MSP[]
HashEntry < K , V > entry = data [ hashIndex ( hashCode , data . length ) ] ; MST[rv.UOI2Mutator]MSP[] while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) {
final HashEntry < K , V > oldEntries [] = data ; final HashEntry < K , V > newEntries [] = new HashEntry [ newCapacity ] ; modCount ++ ; MST[rv.UOI2Mutator]MSP[] for ( int i = oldCapacity - 1 ; i >= 0 ; i -- ) {
while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( convertedKey , entry . key ) ) { MST[rv.UOI4Mutator]MSP[] final V oldValue = entry . getValue () ; updateEntry ( entry , value ) ; return oldValue ; }
if ( size >= threshold ) { MST[rv.UOI3Mutator]MSP[] final int newCapacity = data . length * 2 ; if ( newCapacity <= MAXIMUM_CAPACITY ) { ensureCapacity ( newCapacity ) ; } } } @SuppressWarnings ( lr_1 ) protected void ensureCapacity ( final int newCapacity ) {
protected void doWriteObject ( final ObjectOutputStream out ) throws IOException { out . writeFloat ( loadFactor ) ; out . writeInt ( data . length ) ; out . writeInt ( size ) ; MST[VoidMethodCallMutator]MSP[]
final Iterator < Map . Entry < K , V > > it = createEntrySetIterator () ; while ( it . hasNext () ) { total += it . next () . hashCode () ; } return total ; MST[rv.UOI3Mutator]MSP[] } @Override public String toString () {
return key1 == key2 || key1 . equals ( key2 ) ; MST[rv.CRCR6Mutator]MSP[] } protected boolean isEqualValue ( final Object value1 , final Object value2 ) { return value1 == value2 || value1 . equals ( value2 ) ; }
return key1 == key2 || key1 . equals ( key2 ) ; MST[rv.CRCR3Mutator]MSP[] } protected boolean isEqualValue ( final Object value1 , final Object value2 ) { return value1 == value2 || value1 . equals ( value2 ) ; }
protected void init () { } @Override public V get ( Object key ) { key = convertKey ( key ) ; MST[NonVoidMethodCallMutator]MSP[] final int hashCode = hash ( key ) ;
cloned . putAll ( this ) ; return cloned ; } catch ( final CloneNotSupportedException ex ) { throw new InternalError () ; } } @Override public boolean equals ( final Object obj ) { if ( obj == this ) { return true ; MST[rv.CRCR2Mutator]MSP[] }
final Object convertedKey = convertKey ( key ) ; final int hashCode = hash ( convertedKey ) ; MST[NonVoidMethodCallMutator]MSP[] final int index = hashIndex ( hashCode , data . length ) ; HashEntry < K , V > entry = data [ index ] ;
return entry . getValue () ; MST[NullReturnValsMutator]MSP[] } entry = entry . next ; } return null ; } @Override public int size () { return size ; } @Override public boolean isEmpty () { return size == 0 ; } @Override public boolean containsKey ( Object key ) {
HashEntry < K , V > entry = data [ hashIndex ( hashCode , data . length ) ] ; while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { MST[rv.ABSMutator]MSP[] return entry ; }
if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { MST[rv.ROR3Mutator]MSP[] return true ; } entry = entry . next ; } return false ; } @Override public boolean containsValue ( final Object value ) { if ( value == null ) {
entry = entry . next ; } addMapping ( index , hashCode , key , value ) ; MST[rv.UOI1Mutator]MSP[] return null ; } @Override public void putAll ( final Map < ? extends K , ? extends V > map ) { _putAll ( map ) ; }
h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; MST[rv.ABSMutator]MSP[] return h ; } protected boolean isEqualKey ( final Object key1 , final Object key2 ) {
if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { MST[rv.ROR1Mutator]MSP[] final V oldValue = entry . getValue () ; removeMapping ( entry , index , previous ) ; return oldValue ; } previous = entry ; entry = entry . next ;
} return null ; } @Override public void clear () { modCount ++ ; MST[rv.ABSMutator]MSP[] final HashEntry < K , V > [] data = this . data ; for ( int i = data . length - 1 ; i >= 0 ; i -- ) {
h += ~ ( h << 9 ) ; h ^= h >>> 14 ; MST[rv.UOI1Mutator]MSP[] h += h << 4 ; h ^= h >>> 10 ; return h ; } protected boolean isEqualKey ( final Object key1 , final Object key2 ) {
if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return true ; } entry = entry . next ; } return false ; } @Override public boolean containsValue ( final Object value ) { if ( value == null ) {
if ( isEqualValue ( value , entry . getValue () ) ) { return true ; } entry = entry . next ; } } } return false ; MST[rv.CRCR1Mutator]MSP[] } @Override public V put ( final K key , final V value ) {
public Set < Map . Entry < K , V > > entrySet () { if ( entrySet == null ) { entrySet = new EntrySet <> ( this ) ; } return entrySet ; MST[EmptyObjectReturnValsMutator]MSP[] }
HashEntry < K , V > entry = data [ hashIndex ( hashCode , data . length ) ] ; while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { MST[rv.ROR4Mutator]MSP[]
HashEntry < K , V > entry = oldEntries [ i ] ; if ( entry != null ) { oldEntries [ i ] = null ; MST[rv.UOI1Mutator]MSP[] do { final HashEntry < K , V > next = entry . next ;
} return null ; } @Override public void clear () { modCount ++ ; final HashEntry < K , V > [] data = this . data ; for ( int i = data . length - 1 ; i >= 0 ; i -- ) { MST[rv.UOI1Mutator]MSP[]
entry . key = key ; entry . value = value ; } protected void addMapping ( final int hashIndex , final int hashCode , final K key , final V value ) { modCount ++ ; MST[rv.UOI4Mutator]MSP[]
entry = entry . next ; } addMapping ( index , hashCode , key , value ) ; MST[rv.UOI4Mutator]MSP[] return null ; } @Override public void putAll ( final Map < ? extends K , ? extends V > map ) { _putAll ( map ) ; }
while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( convertedKey , entry . key ) ) { MST[rv.UOI1Mutator]MSP[] final V oldValue = entry . getValue () ; updateEntry ( entry , value ) ; return oldValue ; }
threshold = calculateThreshold ( newCapacity , loadFactor ) ; MST[rv.ABSMutator]MSP[] data = newEntries ; } } protected int calculateNewCapacity ( final int proposedCapacity ) { int newCapacity = 1 ; if ( proposedCapacity > MAXIMUM_CAPACITY ) { newCapacity = MAXIMUM_CAPACITY ; } else { while ( newCapacity < proposedCapacity ) {
if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { MST[rv.ROR4Mutator]MSP[] final V oldValue = entry . getValue () ; removeMapping ( entry , index , previous ) ; return oldValue ; } previous = entry ; entry = entry . next ;
protected void removeEntry ( final HashEntry < K , V > entry , final int hashIndex , final HashEntry < K , V > previous ) { if ( previous == null ) { data [ hashIndex ] = entry . next ; MST[rv.UOI3Mutator]MSP[] } else {
h += ~ ( h << 9 ) ; MST[rv.AOR2Mutator]MSP[] h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; return h ; } protected boolean isEqualKey ( final Object key1 , final Object key2 ) {
h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; MST[rv.CRCR3Mutator]MSP[] return h ; } protected boolean isEqualKey ( final Object key1 , final Object key2 ) {
return entry . getValue () ; } entry = entry . next ; } return null ; } @Override public int size () { return size ; } @Override public boolean isEmpty () { return size == 0 ; MST[rv.CRCR4Mutator]MSP[] } @Override public boolean containsKey ( Object key ) {
} return null ; } @Override public void clear () { modCount ++ ; final HashEntry < K , V > [] data = this . data ; for ( int i = data . length - 1 ; i >= 0 ; i -- ) { MST[rv.AOR2Mutator]MSP[]
if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { MST[rv.ABSMutator]MSP[] return true ; } entry = entry . next ; } return false ; } @Override public boolean containsValue ( final Object value ) { if ( value == null ) {
HashEntry < K , V > entry = data [ hashIndex ( hashCode , data . length ) ] ; while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { MST[rv.UOI1Mutator]MSP[] return entry ; }
key = convertKey ( key ) ; final int hashCode = hash ( key ) ; HashEntry < K , V > entry = data [ hashIndex ( hashCode , data . length ) ] ; MST[rv.UOI1Mutator]MSP[] while ( entry != null ) {
if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { MST[rv.UOI2Mutator]MSP[] final V oldValue = entry . getValue () ; removeMapping ( entry , index , previous ) ; return oldValue ; } previous = entry ; entry = entry . next ;
threshold = calculateThreshold ( newCapacity , loadFactor ) ; data = newEntries ; } } protected int calculateNewCapacity ( final int proposedCapacity ) { int newCapacity = 1 ; if ( proposedCapacity > MAXIMUM_CAPACITY ) { newCapacity = MAXIMUM_CAPACITY ; } else { while ( newCapacity < proposedCapacity ) { MST[rv.UOI3Mutator]MSP[]
protected int hashIndex ( final int hashCode , final int dataSize ) { return hashCode & dataSize - 1 ; MST[rv.OBBN2Mutator]MSP[] } protected HashEntry < K , V > getEntry ( Object key ) { key = convertKey ( key ) ; final int hashCode = hash ( key ) ;
final int oldCapacity = data . length ; if ( newCapacity <= oldCapacity ) { return; } if ( size == 0 ) { MST[rv.UOI1Mutator]MSP[] threshold = calculateThreshold ( newCapacity , loadFactor ) ; data = new HashEntry [ newCapacity ] ; } else {
newCapacity <<= 1 ; } if ( newCapacity > MAXIMUM_CAPACITY ) { newCapacity = MAXIMUM_CAPACITY ; } } return newCapacity ; MST[ReturnValsMutator]MSP[] } protected int calculateThreshold ( final int newCapacity , final float factor ) { return (int) ( newCapacity * factor ) ; }
while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( convertedKey , entry . key ) ) { MST[rv.ROR4Mutator]MSP[] final V oldValue = entry . getValue () ; updateEntry ( entry , value ) ; return oldValue ; }
} return null ; } @Override public void clear () { modCount ++ ; final HashEntry < K , V > [] data = this . data ; for ( int i = data . length - 1 ; i >= 0 ; i -- ) { MST[rv.ROR2Mutator]MSP[]
h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; MST[MathMutator]MSP[] h ^= h >>> 10 ; return h ; } protected boolean isEqualKey ( final Object key1 , final Object key2 ) {
protected void removeMapping ( final HashEntry < K , V > entry , final int hashIndex , final HashEntry < K , V > previous ) { modCount ++ ; MST[rv.ABSMutator]MSP[] removeEntry ( entry , hashIndex , previous ) ; size -- ; destroyEntry ( entry ) ; }
h += ~ ( h << 9 ) ; MST[MathMutator]MSP[] h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; return h ; } protected boolean isEqualKey ( final Object key1 , final Object key2 ) {
if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { final V oldValue = entry . getValue () ; removeMapping ( entry , index , previous ) ; MST[rv.UOI1Mutator]MSP[] return oldValue ; } previous = entry ; entry = entry . next ;
protected void addEntry ( final HashEntry < K , V > entry , final int hashIndex ) { data [ hashIndex ] = entry ; MST[rv.ABSMutator]MSP[] }
final int newSize = (int) ( ( size + mapSize ) / loadFactor + 1 ) ; MST[InlineConstantMutator]MSP[] ensureCapacity ( calculateNewCapacity ( newSize ) ) ; for ( final Map . Entry < ? extends K , ? extends V > entry : map . entrySet () ) {
cloned . data = new HashEntry [ data . length ] ; cloned . entrySet = null ; MST[experimental.MemberVariableMutator]MSP[] cloned . keySet = null ; cloned . values = null ; cloned . modCount = 0 ; cloned . size = 0 ; cloned . init () ;
if ( map . get ( key ) != null || map . containsKey ( key ) == false ) { return false ; } } else { if ( value . equals ( map . get ( key ) ) == false ) { MST[NonVoidMethodCallMutator]MSP[] return false ; } }
entry = entry . next ; } } } else { for ( final HashEntry < K , V > element : data ) { MST[rv.ABSMutator]MSP[] HashEntry < K , V > entry = element ; while ( entry != null ) {
entry . key = key ; entry . value = value ; } protected void addMapping ( final int hashIndex , final int hashCode , final K key , final V value ) { modCount ++ ; MST[rv.UOI1Mutator]MSP[]
put ( key , value ) ; MST[NonVoidMethodCallMutator]MSP[] } } @Override @SuppressWarnings ( lr_1 ) protected AbstractHashedMap < K , V > clone () { try { final AbstractHashedMap < K , V > cloned = ( AbstractHashedMap < K , V > ) super . clone () ;
final int index = hashIndex ( entry . hashCode , newCapacity ) ; MST[rv.UOI3Mutator]MSP[] entry . next = newEntries [ index ] ; newEntries [ index ] = entry ; entry = next ; } while ( entry != null ); } }
for ( final MapIterator < K , V > it = mapIterator () ; it . hasNext () ; ) { MST[NegateConditionalsMutator]MSP[] out . writeObject ( it . next () ) ; out . writeObject ( it . getValue () ) ; } } @SuppressWarnings ( lr_1 )
public MapIterator < K , V > mapIterator () { if ( size == 0 ) { MST[rv.UOI1Mutator]MSP[] return EmptyMapIterator . <K , V > emptyMapIterator () ; } return new HashMapIterator <> ( this ) ; } @Override public K next () {
protected int hashIndex ( final int hashCode , final int dataSize ) { return hashCode & dataSize - 1 ; MST[rv.AOR1Mutator]MSP[] } protected HashEntry < K , V > getEntry ( Object key ) { key = convertKey ( key ) ; final int hashCode = hash ( key ) ;
final MapIterator < ? , ? > it = mapIterator () ; try { while ( it . hasNext () ) { final Object key = it . next () ; MST[NonVoidMethodCallMutator]MSP[] final Object value = it . getValue () ; if ( value == null ) {
final Object convertedKey = convertKey ( key ) ; MST[ArgumentPropagationMutator]MSP[] final int hashCode = hash ( convertedKey ) ; final int index = hashIndex ( hashCode , data . length ) ; HashEntry < K , V > entry = data [ index ] ;
protected void removeMapping ( final HashEntry < K , V > entry , final int hashIndex , final HashEntry < K , V > previous ) { modCount ++ ; removeEntry ( entry , hashIndex , previous ) ; MST[rv.UOI2Mutator]MSP[] size -- ; destroyEntry ( entry ) ; }
if ( size () == 0 ) { MST[rv.ROR5Mutator]MSP[] return lr_6 ; } final StringBuilder buf = new StringBuilder ( 32 * size () ) ; buf . append ( '{' ) ; final MapIterator < K , V > it = mapIterator () ;
h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; MST[rv.UOI1Mutator]MSP[] h ^= h >>> 10 ; return h ; } protected boolean isEqualKey ( final Object key1 , final Object key2 ) {
HashEntry < K , V > entry = data [ hashIndex ( hashCode , data . length ) ] ; MST[NonVoidMethodCallMutator]MSP[] while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) {
final Iterator < Map . Entry < K , V > > it = createEntrySetIterator () ; while ( it . hasNext () ) { total += it . next () . hashCode () ; MST[rv.UOI2Mutator]MSP[] } return total ; } @Override public String toString () {
HashEntry < K , V > entry = data [ hashIndex ( hashCode , data . length ) ] ; while ( entry != null ) { MST[rv.ROR5Mutator]MSP[] if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) {
HashEntry < K , V > entry = oldEntries [ i ] ; if ( entry != null ) { oldEntries [ i ] = null ; MST[rv.UOI4Mutator]MSP[] do { final HashEntry < K , V > next = entry . next ;
final HashEntry < K , V > entry = createEntry ( data [ hashIndex ] , hashCode , key , value ) ; MST[ArgumentPropagationMutator]MSP[] addEntry ( entry , hashIndex ) ; size ++ ; checkCapacity () ; }
return key1 == key2 || key1 . equals ( key2 ) ; } protected boolean isEqualValue ( final Object value1 , final Object value2 ) { return value1 == value2 || value1 . equals ( value2 ) ; MST[rv.ROR2Mutator]MSP[] }
final int newSize = (int) ( ( size + mapSize ) / loadFactor + 1 ) ; MST[MathMutator]MSP[] ensureCapacity ( calculateNewCapacity ( newSize ) ) ; for ( final Map . Entry < ? extends K , ? extends V > entry : map . entrySet () ) {
h += ~ ( h << 9 ) ; h ^= h >>> 14 ; MST[rv.CRCR5Mutator]MSP[] h += h << 4 ; h ^= h >>> 10 ; return h ; } protected boolean isEqualKey ( final Object key1 , final Object key2 ) {
if ( size >= threshold ) { final int newCapacity = data . length * 2 ; if ( newCapacity <= MAXIMUM_CAPACITY ) { MST[rv.ROR4Mutator]MSP[] ensureCapacity ( newCapacity ) ; } } } @SuppressWarnings ( lr_1 ) protected void ensureCapacity ( final int newCapacity ) {
while ( entry != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] if ( entry . hashCode == hashCode && isEqualKey ( convertedKey , entry . key ) ) { final V oldValue = entry . getValue () ; updateEntry ( entry , value ) ; return oldValue ; }
if ( size >= threshold ) { final int newCapacity = data . length * 2 ; if ( newCapacity <= MAXIMUM_CAPACITY ) { ensureCapacity ( newCapacity ) ; MST[rv.UOI2Mutator]MSP[] } } } @SuppressWarnings ( lr_1 ) protected void ensureCapacity ( final int newCapacity ) {
newCapacity <<= 1 ; MST[rv.CRCR5Mutator]MSP[] } if ( newCapacity > MAXIMUM_CAPACITY ) { newCapacity = MAXIMUM_CAPACITY ; } } return newCapacity ; } protected int calculateThreshold ( final int newCapacity , final float factor ) { return (int) ( newCapacity * factor ) ; }
final HashEntry < K , V > entry = createEntry ( data [ hashIndex ] , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; MST[rv.UOI2Mutator]MSP[] size ++ ; checkCapacity () ; }
} return null ; } @Override public void clear () { modCount ++ ; final HashEntry < K , V > [] data = this . data ; for ( int i = data . length - 1 ; i >= 0 ; i -- ) { MST[rv.CRCR4Mutator]MSP[]
return entry . getValue () ; } entry = entry . next ; } return null ; } @Override public int size () { return size ; MST[rv.UOI2Mutator]MSP[] } @Override public boolean isEmpty () { return size == 0 ; } @Override public boolean containsKey ( Object key ) {
final HashEntry < K , V > entry = createEntry ( data [ hashIndex ] , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; size ++ ; MST[rv.UOI4Mutator]MSP[] checkCapacity () ; }
put ( entry . getKey () , entry . getValue () ) ; MST[NonVoidMethodCallMutator]MSP[] } } @Override public V remove ( Object key ) { key = convertKey ( key ) ; final int hashCode = hash ( key ) ;
final HashEntry < K , V > entry = createEntry ( data [ hashIndex ] , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; MST[VoidMethodCallMutator]MSP[] size ++ ; checkCapacity () ; }
return entry . getValue () ; } entry = entry . next ; } return null ; } @Override public int size () { return size ; } @Override public boolean isEmpty () { return size == 0 ; MST[rv.UOI3Mutator]MSP[] } @Override public boolean containsKey ( Object key ) {
if ( size >= threshold ) { MST[rv.UOI1Mutator]MSP[] final int newCapacity = data . length * 2 ; if ( newCapacity <= MAXIMUM_CAPACITY ) { ensureCapacity ( newCapacity ) ; } } } @SuppressWarnings ( lr_1 ) protected void ensureCapacity ( final int newCapacity ) {
for ( final MapIterator < K , V > it = mapIterator () ; it . hasNext () ; ) { MST[rv.ROR5Mutator]MSP[] out . writeObject ( it . next () ) ; out . writeObject ( it . getValue () ) ; } } @SuppressWarnings ( lr_1 )
final HashEntry < K , V > entry = createEntry ( data [ hashIndex ] , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; size ++ ; MST[rv.AOD1Mutator]MSP[] checkCapacity () ; }
put ( key , value ) ; } } @Override @SuppressWarnings ( lr_1 ) protected AbstractHashedMap < K , V > clone () { try { final AbstractHashedMap < K , V > cloned = ( AbstractHashedMap < K , V > ) super . clone () ; MST[NonVoidMethodCallMutator]MSP[]
cloned . putAll ( this ) ; return cloned ; } catch ( final CloneNotSupportedException ex ) { throw new InternalError () ; } } @Override public boolean equals ( final Object obj ) { if ( obj == this ) { return true ; MST[rv.CRCR5Mutator]MSP[] }
while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( convertedKey , entry . key ) ) { final V oldValue = entry . getValue () ; MST[NonVoidMethodCallMutator]MSP[] updateEntry ( entry , value ) ; return oldValue ; }
final int oldCapacity = data . length ; if ( newCapacity <= oldCapacity ) { return; } if ( size == 0 ) { threshold = calculateThreshold ( newCapacity , loadFactor ) ; MST[rv.UOI3Mutator]MSP[] data = new HashEntry [ newCapacity ] ; } else {
while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( convertedKey , entry . key ) ) { MST[rv.ROR2Mutator]MSP[] final V oldValue = entry . getValue () ; updateEntry ( entry , value ) ; return oldValue ; }
return key1 == key2 || key1 . equals ( key2 ) ; MST[rv.ROR1Mutator]MSP[] } protected boolean isEqualValue ( final Object value1 , final Object value2 ) { return value1 == value2 || value1 . equals ( value2 ) ; }
h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; MST[rv.UOI2Mutator]MSP[] return h ; } protected boolean isEqualKey ( final Object key1 , final Object key2 ) {
if ( size >= threshold ) { final int newCapacity = data . length * 2 ; MST[rv.AOR4Mutator]MSP[] if ( newCapacity <= MAXIMUM_CAPACITY ) { ensureCapacity ( newCapacity ) ; } } } @SuppressWarnings ( lr_1 ) protected void ensureCapacity ( final int newCapacity ) {
if ( map . get ( key ) != null || map . containsKey ( key ) == false ) { return false ; } } else { if ( value . equals ( map . get ( key ) ) == false ) { return false ; MST[rv.CRCR1Mutator]MSP[] } }
final Iterator < Map . Entry < K , V > > it = createEntrySetIterator () ; while ( it . hasNext () ) { total += it . next () . hashCode () ; MST[NonVoidMethodCallMutator]MSP[] } return total ; } @Override public String toString () {
return key1 == key2 || key1 . equals ( key2 ) ; MST[rv.CRCR3Mutator]MSP[] } protected boolean isEqualValue ( final Object value1 , final Object value2 ) { return value1 == value2 || value1 . equals ( value2 ) ; }
previous . next = entry . next ; } } protected void destroyEntry ( final HashEntry < K , V > entry ) { entry . next = null ; MST[experimental.MemberVariableMutator]MSP[] entry . key = null ; entry . value = null ; } protected void checkCapacity () {
final HashEntry < K , V > entry = createEntry ( data [ hashIndex ] , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; size ++ ; MST[rv.AOR3Mutator]MSP[] checkCapacity () ; }
final HashEntry < K , V > oldEntries [] = data ; final HashEntry < K , V > newEntries [] = new HashEntry [ newCapacity ] ; MST[rv.UOI4Mutator]MSP[] modCount ++ ; for ( int i = oldCapacity - 1 ; i >= 0 ; i -- ) {
final Iterator < Map . Entry < K , V > > it = createEntrySetIterator () ; while ( it . hasNext () ) { total += it . next () . hashCode () ; MST[rv.AOR2Mutator]MSP[] } return total ; } @Override public String toString () {
return entry . getValue () ; } entry = entry . next ; } return null ; } @Override public int size () { return size ; } @Override public boolean isEmpty () { return size == 0 ; MST[rv.CRCR1Mutator]MSP[] } @Override public boolean containsKey ( Object key ) {
cloned . putAll ( this ) ; return cloned ; } catch ( final CloneNotSupportedException ex ) { throw new InternalError () ; } } @Override public boolean equals ( final Object obj ) { if ( obj == this ) { return true ; MST[ReturnValsMutator]MSP[] }
if ( size >= threshold ) { final int newCapacity = data . length * 2 ; if ( newCapacity <= MAXIMUM_CAPACITY ) { MST[rv.CRCR2Mutator]MSP[] ensureCapacity ( newCapacity ) ; } } } @SuppressWarnings ( lr_1 ) protected void ensureCapacity ( final int newCapacity ) {
} } catch ( final ClassCastException ignored ) { return false ; } catch ( final NullPointerException ignored ) { return false ; } return true ; } @Override public int hashCode () { int total = 0 ; MST[rv.CRCR3Mutator]MSP[]
if ( map . get ( key ) != null || map . containsKey ( key ) == false ) { return false ; } } else { if ( value . equals ( map . get ( key ) ) == false ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return false ; } }
if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { MST[rv.UOI2Mutator]MSP[] return true ; } entry = entry . next ; } return false ; } @Override public boolean containsValue ( final Object value ) { if ( value == null ) {
protected void removeMapping ( final HashEntry < K , V > entry , final int hashIndex , final HashEntry < K , V > previous ) { modCount ++ ; removeEntry ( entry , hashIndex , previous ) ; MST[VoidMethodCallMutator]MSP[] size -- ; destroyEntry ( entry ) ; }
return key1 == key2 || key1 . equals ( key2 ) ; } protected boolean isEqualValue ( final Object value1 , final Object value2 ) { return value1 == value2 || value1 . equals ( value2 ) ; MST[BooleanTrueReturnValsMutator]MSP[] }
protected void removeMapping ( final HashEntry < K , V > entry , final int hashIndex , final HashEntry < K , V > previous ) { modCount ++ ; removeEntry ( entry , hashIndex , previous ) ; size -- ; MST[rv.AOD1Mutator]MSP[] destroyEntry ( entry ) ; }
h += ~ ( h << 9 ) ; MST[rv.CRCR2Mutator]MSP[] h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; return h ; } protected boolean isEqualKey ( final Object key1 , final Object key2 ) {
protected void removeMapping ( final HashEntry < K , V > entry , final int hashIndex , final HashEntry < K , V > previous ) { modCount ++ ; MST[rv.AOR4Mutator]MSP[] removeEntry ( entry , hashIndex , previous ) ; size -- ; destroyEntry ( entry ) ; }
final HashEntry < K , V > oldEntries [] = data ; final HashEntry < K , V > newEntries [] = new HashEntry [ newCapacity ] ; modCount ++ ; for ( int i = oldCapacity - 1 ; i >= 0 ; i -- ) { MST[rv.AOR3Mutator]MSP[]
data = new HashEntry [ capacity ] ; for ( int i = 0 ; i < size ; i ++ ) { MST[rv.UOI2Mutator]MSP[] final K key = ( K ) in . readObject () ; final V value = ( V ) in . readObject () ;
protected HashEntry < K , V > createEntry ( final HashEntry < K , V > next , final int hashCode , final K key , final V value ) { return new HashEntry <> ( next , hashCode , convertKey ( key ) , value ) ; MST[NullReturnValsMutator]MSP[] }
final HashEntry < K , V > entry = createEntry ( data [ hashIndex ] , hashCode , key , value ) ; MST[rv.ABSMutator]MSP[] addEntry ( entry , hashIndex ) ; size ++ ; checkCapacity () ; }
final int index = hashIndex ( entry . hashCode , newCapacity ) ; entry . next = newEntries [ index ] ; newEntries [ index ] = entry ; MST[rv.UOI3Mutator]MSP[] entry = next ; } while ( entry != null ); } }
data [ i ] = null ; } size = 0 ; MST[rv.CRCR1Mutator]MSP[] } protected Object convertKey ( final Object key ) { return key == null ? NULL : key ; } protected int hash ( final Object key ) { int h = key . hashCode () ;
final int oldCapacity = data . length ; if ( newCapacity <= oldCapacity ) { return; } if ( size == 0 ) { threshold = calculateThreshold ( newCapacity , loadFactor ) ; MST[rv.ABSMutator]MSP[] data = new HashEntry [ newCapacity ] ; } else {
HashEntry < K , V > entry = data [ hashIndex ( hashCode , data . length ) ] ; while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { MST[rv.ROR2Mutator]MSP[] return entry ; }
final int index = hashIndex ( entry . hashCode , newCapacity ) ; entry . next = newEntries [ index ] ; MST[rv.UOI1Mutator]MSP[] newEntries [ index ] = entry ; entry = next ; } while ( entry != null ); } }
HashEntry < K , V > entry = data [ hashIndex ( hashCode , data . length ) ] ; while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { MST[rv.ROR4Mutator]MSP[] return entry ; }
if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { MST[rv.UOI1Mutator]MSP[] final V oldValue = entry . getValue () ; removeMapping ( entry , index , previous ) ; return oldValue ; } previous = entry ; entry = entry . next ;
newCapacity <<= 1 ; MST[rv.UOI3Mutator]MSP[] } if ( newCapacity > MAXIMUM_CAPACITY ) { newCapacity = MAXIMUM_CAPACITY ; } } return newCapacity ; } protected int calculateThreshold ( final int newCapacity , final float factor ) { return (int) ( newCapacity * factor ) ; }
final int oldCapacity = data . length ; if ( newCapacity <= oldCapacity ) { MST[rv.ROR3Mutator]MSP[] return; } if ( size == 0 ) { threshold = calculateThreshold ( newCapacity , loadFactor ) ; data = new HashEntry [ newCapacity ] ; } else {
while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( convertedKey , entry . key ) ) { MST[rv.ROR1Mutator]MSP[] final V oldValue = entry . getValue () ; updateEntry ( entry , value ) ; return oldValue ; }
final int oldCapacity = data . length ; if ( newCapacity <= oldCapacity ) { MST[rv.ABSMutator]MSP[] return; } if ( size == 0 ) { threshold = calculateThreshold ( newCapacity , loadFactor ) ; data = new HashEntry [ newCapacity ] ; } else {
final HashEntry < K , V > oldEntries [] = data ; final HashEntry < K , V > newEntries [] = new HashEntry [ newCapacity ] ; modCount ++ ; for ( int i = oldCapacity - 1 ; i >= 0 ; i -- ) { MST[rv.AOD1Mutator]MSP[]
if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { return true ; } entry = entry . next ; } return false ; } @Override public boolean containsValue ( final Object value ) { if ( value == null ) { MST[NegateConditionalsMutator]MSP[]
while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( convertedKey , entry . key ) ) { MST[rv.UOI2Mutator]MSP[] final V oldValue = entry . getValue () ; updateEntry ( entry , value ) ; return oldValue ; }
if ( obj instanceof Map == false ) { MST[rv.ROR3Mutator]MSP[] return false ; } final Map < ? , ? > map = ( Map < ? , ? > ) obj ; if ( map . size () != size () ) { return false ; }
final HashEntry < K , V > oldEntries [] = data ; final HashEntry < K , V > newEntries [] = new HashEntry [ newCapacity ] ; modCount ++ ; for ( int i = oldCapacity - 1 ; i >= 0 ; i -- ) { MST[rv.UOI3Mutator]MSP[]
protected Iterator < Map . Entry < K , V > > createEntrySetIterator () { if ( size () == 0 ) { return EmptyIterator . < Map . Entry < K , V > > emptyIterator () ; } return new EntrySetIterator <> ( this ) ; MST[ConstructorCallMutator]MSP[] } @Override
entry = entry . next ; } } } else { for ( final HashEntry < K , V > element : data ) { HashEntry < K , V > entry = element ; while ( entry != null ) { MST[NegateConditionalsMutator]MSP[]
if ( size >= threshold ) { final int newCapacity = data . length * 2 ; if ( newCapacity <= MAXIMUM_CAPACITY ) { MST[rv.UOI4Mutator]MSP[] ensureCapacity ( newCapacity ) ; } } } @SuppressWarnings ( lr_1 ) protected void ensureCapacity ( final int newCapacity ) {
h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; MST[rv.CRCR2Mutator]MSP[] h ^= h >>> 10 ; return h ; } protected boolean isEqualKey ( final Object key1 , final Object key2 ) {
data = new HashEntry [ capacity ] ; MST[rv.UOI3Mutator]MSP[] for ( int i = 0 ; i < size ; i ++ ) { final K key = ( K ) in . readObject () ; final V value = ( V ) in . readObject () ;
if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { MST[rv.UOI4Mutator]MSP[] final V oldValue = entry . getValue () ; removeMapping ( entry , index , previous ) ; return oldValue ; } previous = entry ; entry = entry . next ;
final int newSize = (int) ( ( size + mapSize ) / loadFactor + 1 ) ; MST[rv.UOI2Mutator]MSP[] ensureCapacity ( calculateNewCapacity ( newSize ) ) ; for ( final Map . Entry < ? extends K , ? extends V > entry : map . entrySet () ) {
if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { MST[rv.ROR5Mutator]MSP[] final V oldValue = entry . getValue () ; removeMapping ( entry , index , previous ) ; return oldValue ; } previous = entry ; entry = entry . next ;
protected void reuseEntry ( final HashEntry < K , V > entry , final int hashIndex , final int hashCode , final K key , final V value ) { entry . next = data [ hashIndex ] ; MST[rv.UOI4Mutator]MSP[] entry . hashCode = hashCode ;
final int oldCapacity = data . length ; if ( newCapacity <= oldCapacity ) { return; } if ( size == 0 ) { threshold = calculateThreshold ( newCapacity , loadFactor ) ; MST[rv.UOI2Mutator]MSP[] data = new HashEntry [ newCapacity ] ; } else {
if ( size >= threshold ) { final int newCapacity = data . length * 2 ; if ( newCapacity <= MAXIMUM_CAPACITY ) { ensureCapacity ( newCapacity ) ; } } } @SuppressWarnings ( lr_1 ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[] protected void ensureCapacity ( final int newCapacity ) {
protected int hashIndex ( final int hashCode , final int dataSize ) { return hashCode & dataSize - 1 ; } protected HashEntry < K , V > getEntry ( Object key ) { key = convertKey ( key ) ; final int hashCode = hash ( key ) ; MST[NonVoidMethodCallMutator]MSP[]
protected void doWriteObject ( final ObjectOutputStream out ) throws IOException { out . writeFloat ( loadFactor ) ; out . writeInt ( data . length ) ; out . writeInt ( size ) ; MST[rv.ABSMutator]MSP[]
} return null ; } @Override public void clear () { modCount ++ ; final HashEntry < K , V > [] data = this . data ; for ( int i = data . length - 1 ; i >= 0 ; i -- ) { MST[InlineConstantMutator]MSP[]
protected Iterator < Map . Entry < K , V > > createEntrySetIterator () { if ( size () == 0 ) { MST[rv.ROR5Mutator]MSP[] return EmptyIterator . < Map . Entry < K , V > > emptyIterator () ; } return new EntrySetIterator <> ( this ) ; } @Override
final HashEntry < K , V > oldEntries [] = data ; final HashEntry < K , V > newEntries [] = new HashEntry [ newCapacity ] ; modCount ++ ; for ( int i = oldCapacity - 1 ; i >= 0 ; i -- ) { MST[rv.ROR4Mutator]MSP[]
} return null ; } @Override public void clear () { modCount ++ ; MST[rv.CRCR4Mutator]MSP[] final HashEntry < K , V > [] data = this . data ; for ( int i = data . length - 1 ; i >= 0 ; i -- ) {
threshold = calculateThreshold ( newCapacity , loadFactor ) ; data = newEntries ; } } protected int calculateNewCapacity ( final int proposedCapacity ) { int newCapacity = 1 ; MST[rv.CRCR5Mutator]MSP[] if ( proposedCapacity > MAXIMUM_CAPACITY ) { newCapacity = MAXIMUM_CAPACITY ; } else { while ( newCapacity < proposedCapacity ) {
protected void removeEntry ( final HashEntry < K , V > entry , final int hashIndex , final HashEntry < K , V > previous ) { if ( previous == null ) { MST[NegateConditionalsMutator]MSP[] data [ hashIndex ] = entry . next ; } else {
newCapacity <<= 1 ; } if ( newCapacity > MAXIMUM_CAPACITY ) { MST[rv.ROR1Mutator]MSP[] newCapacity = MAXIMUM_CAPACITY ; } } return newCapacity ; } protected int calculateThreshold ( final int newCapacity , final float factor ) { return (int) ( newCapacity * factor ) ; }
protected void removeMapping ( final HashEntry < K , V > entry , final int hashIndex , final HashEntry < K , V > previous ) { modCount ++ ; MST[rv.AOD2Mutator]MSP[] removeEntry ( entry , hashIndex , previous ) ; size -- ; destroyEntry ( entry ) ; }
final int index = hashIndex ( entry . hashCode , newCapacity ) ; MST[NonVoidMethodCallMutator]MSP[] entry . next = newEntries [ index ] ; newEntries [ index ] = entry ; entry = next ; } while ( entry != null ); } }
if ( obj instanceof Map == false ) { return false ; } final Map < ? , ? > map = ( Map < ? , ? > ) obj ; if ( map . size () != size () ) { MST[rv.ROR3Mutator]MSP[] return false ; }
final int newSize = (int) ( ( size + mapSize ) / loadFactor + 1 ) ; ensureCapacity ( calculateNewCapacity ( newSize ) ) ; MST[rv.UOI1Mutator]MSP[] for ( final Map . Entry < ? extends K , ? extends V > entry : map . entrySet () ) {
final MapIterator < ? , ? > it = mapIterator () ; try { while ( it . hasNext () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] final Object key = it . next () ; final Object value = it . getValue () ; if ( value == null ) {
final int index = hashIndex ( hashCode , data . length ) ; MST[NonVoidMethodCallMutator]MSP[] HashEntry < K , V > entry = data [ index ] ; HashEntry < K , V > previous = null ; while ( entry != null ) {
if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { MST[NegateConditionalsMutator]MSP[] final V oldValue = entry . getValue () ; removeMapping ( entry , index , previous ) ; return oldValue ; } previous = entry ; entry = entry . next ;
if ( size >= threshold ) { final int newCapacity = data . length * 2 ; MST[rv.AOD2Mutator]MSP[] if ( newCapacity <= MAXIMUM_CAPACITY ) { ensureCapacity ( newCapacity ) ; } } } @SuppressWarnings ( lr_1 ) protected void ensureCapacity ( final int newCapacity ) {
if ( obj instanceof Map == false ) { return false ; MST[InlineConstantMutator]MSP[] } final Map < ? , ? > map = ( Map < ? , ? > ) obj ; if ( map . size () != size () ) { return false ; }
data = new HashEntry [ capacity ] ; for ( int i = 0 ; i < size ; i ++ ) { MST[rv.ROR3Mutator]MSP[] final K key = ( K ) in . readObject () ; final V value = ( V ) in . readObject () ;
protected HashEntry < K , V > createEntry ( final HashEntry < K , V > next , final int hashCode , final K key , final V value ) { return new HashEntry <> ( next , hashCode , convertKey ( key ) , value ) ; MST[rv.UOI4Mutator]MSP[] }
data = new HashEntry [ capacity ] ; for ( int i = 0 ; i < size ; i ++ ) { MST[rv.ABSMutator]MSP[] final K key = ( K ) in . readObject () ; final V value = ( V ) in . readObject () ;
protected Iterator < Map . Entry < K , V > > createEntrySetIterator () { if ( size () == 0 ) { MST[NegateConditionalsMutator]MSP[] return EmptyIterator . < Map . Entry < K , V > > emptyIterator () ; } return new EntrySetIterator <> ( this ) ; } @Override
h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; MST[rv.UOI1Mutator]MSP[] h ^= h >>> 10 ; return h ; } protected boolean isEqualKey ( final Object key1 , final Object key2 ) {
protected void removeMapping ( final HashEntry < K , V > entry , final int hashIndex , final HashEntry < K , V > previous ) { modCount ++ ; removeEntry ( entry , hashIndex , previous ) ; size -- ; MST[rv.AOR3Mutator]MSP[] destroyEntry ( entry ) ; }
return EmptyIterator . <K > emptyIterator () ; MST[ReturnValsMutator]MSP[] } return new KeySetIterator <> ( this ) ; } @Override public int size () { return parent . size () ; } @Override public void clear () { parent . clear () ; } @Override
newCapacity <<= 1 ; } if ( newCapacity > MAXIMUM_CAPACITY ) { MST[rv.UOI4Mutator]MSP[] newCapacity = MAXIMUM_CAPACITY ; } } return newCapacity ; } protected int calculateThreshold ( final int newCapacity , final float factor ) { return (int) ( newCapacity * factor ) ; }
h += ~ ( h << 9 ) ; MST[rv.ABSMutator]MSP[] h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; return h ; } protected boolean isEqualKey ( final Object key1 , final Object key2 ) {
final int newSize = (int) ( ( size + mapSize ) / loadFactor + 1 ) ; ensureCapacity ( calculateNewCapacity ( newSize ) ) ; MST[rv.ABSMutator]MSP[] for ( final Map . Entry < ? extends K , ? extends V > entry : map . entrySet () ) {
final Iterator < Map . Entry < K , V > > it = createEntrySetIterator () ; while ( it . hasNext () ) { total += it . next () . hashCode () ; MST[MathMutator]MSP[] } return total ; } @Override public String toString () {
entry . key = key ; entry . value = value ; } protected void addMapping ( final int hashIndex , final int hashCode , final K key , final V value ) { modCount ++ ; MST[rv.CRCR3Mutator]MSP[]
threshold = calculateThreshold ( newCapacity , loadFactor ) ; data = newEntries ; } } protected int calculateNewCapacity ( final int proposedCapacity ) { int newCapacity = 1 ; if ( proposedCapacity > MAXIMUM_CAPACITY ) { MST[InlineConstantMutator]MSP[] newCapacity = MAXIMUM_CAPACITY ; } else { while ( newCapacity < proposedCapacity ) {
} return null ; } @Override public void clear () { modCount ++ ; MST[rv.AOR1Mutator]MSP[] final HashEntry < K , V > [] data = this . data ; for ( int i = data . length - 1 ; i >= 0 ; i -- ) {
cloned . data = new HashEntry [ data . length ] ; cloned . entrySet = null ; cloned . keySet = null ; cloned . values = null ; cloned . modCount = 0 ; cloned . size = 0 ; cloned . init () ; MST[VoidMethodCallMutator]MSP[]
private void _putAll ( final Map < ? extends K , ? extends V > map ) { final int mapSize = map . size () ; if ( mapSize == 0 ) { MST[rv.ROR1Mutator]MSP[] return; }
h += ~ ( h << 9 ) ; MST[InlineConstantMutator]MSP[] h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; return h ; } protected boolean isEqualKey ( final Object key1 , final Object key2 ) {
newCapacity <<= 1 ; } if ( newCapacity > MAXIMUM_CAPACITY ) { newCapacity = MAXIMUM_CAPACITY ; } } return newCapacity ; } protected int calculateThreshold ( final int newCapacity , final float factor ) { return (int) ( newCapacity * factor ) ; MST[rv.AOR1Mutator]MSP[] }
if ( obj instanceof Map == false ) { return false ; } final Map < ? , ? > map = ( Map < ? , ? > ) obj ; if ( map . size () != size () ) { return false ; MST[InlineConstantMutator]MSP[] }
if ( map . get ( key ) != null || map . containsKey ( key ) == false ) { return false ; } } else { if ( value . equals ( map . get ( key ) ) == false ) { return false ; MST[rv.CRCR5Mutator]MSP[] } }
protected void doReadObject ( final ObjectInputStream in ) throws IOException , ClassNotFoundException { loadFactor = in . readFloat () ; final int capacity = in . readInt () ; final int size = in . readInt () ; init () ; threshold = calculateThreshold ( capacity , loadFactor ) ; MST[rv.UOI1Mutator]MSP[]
key = convertKey ( key ) ; final int hashCode = hash ( key ) ; HashEntry < K , V > entry = data [ hashIndex ( hashCode , data . length ) ] ; MST[rv.UOI4Mutator]MSP[] while ( entry != null ) {
if ( obj instanceof Map == false ) { return false ; } final Map < ? , ? > map = ( Map < ? , ? > ) obj ; if ( map . size () != size () ) { MST[NonVoidMethodCallMutator]MSP[] return false ; }
if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { return true ; MST[InlineConstantMutator]MSP[] } entry = entry . next ; } return false ; } @Override public boolean containsValue ( final Object value ) { if ( value == null ) {
if ( isEqualValue ( value , entry . getValue () ) ) { return true ; } entry = entry . next ; } } } return false ; MST[InlineConstantMutator]MSP[] } @Override public V put ( final K key , final V value ) {
final int oldCapacity = data . length ; if ( newCapacity <= oldCapacity ) { return; } if ( size == 0 ) { threshold = calculateThreshold ( newCapacity , loadFactor ) ; data = new HashEntry [ newCapacity ] ; MST[rv.UOI4Mutator]MSP[] } else {
h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; MST[rv.ABSMutator]MSP[] h ^= h >>> 10 ; return h ; } protected boolean isEqualKey ( final Object key1 , final Object key2 ) {
final HashEntry < K , V > entry = createEntry ( data [ hashIndex ] , hashCode , key , value ) ; MST[rv.UOI4Mutator]MSP[] addEntry ( entry , hashIndex ) ; size ++ ; checkCapacity () ; }
entry = entry . next ; } addMapping ( index , hashCode , key , value ) ; MST[VoidMethodCallMutator]MSP[] return null ; } @Override public void putAll ( final Map < ? extends K , ? extends V > map ) { _putAll ( map ) ; }
for ( final MapIterator < K , V > it = mapIterator () ; it . hasNext () ; ) { out . writeObject ( it . next () ) ; out . writeObject ( it . getValue () ) ; MST[VoidMethodCallMutator]MSP[] } } @SuppressWarnings ( lr_1 )
final int index = hashIndex ( hashCode , data . length ) ; HashEntry < K , V > entry = data [ index ] ; HashEntry < K , V > previous = null ; while ( entry != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
final int newSize = (int) ( ( size + mapSize ) / loadFactor + 1 ) ; MST[rv.AOR4Mutator]MSP[] ensureCapacity ( calculateNewCapacity ( newSize ) ) ; for ( final Map . Entry < ? extends K , ? extends V > entry : map . entrySet () ) {
entry . key = key ; entry . value = value ; } protected void addMapping ( final int hashIndex , final int hashCode , final K key , final V value ) { modCount ++ ; MST[rv.AOR4Mutator]MSP[]
final int oldCapacity = data . length ; if ( newCapacity <= oldCapacity ) { MST[rv.UOI2Mutator]MSP[] return; } if ( size == 0 ) { threshold = calculateThreshold ( newCapacity , loadFactor ) ; data = new HashEntry [ newCapacity ] ; } else {
data = new HashEntry [ capacity ] ; for ( int i = 0 ; i < size ; i ++ ) { final K key = ( K ) in . readObject () ; MST[NonVoidMethodCallMutator]MSP[] final V value = ( V ) in . readObject () ;
h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; MST[rv.UOI4Mutator]MSP[] return h ; } protected boolean isEqualKey ( final Object key1 , final Object key2 ) {
h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; MST[rv.CRCR6Mutator]MSP[] h ^= h >>> 10 ; return h ; } protected boolean isEqualKey ( final Object key1 , final Object key2 ) {
protected int hashIndex ( final int hashCode , final int dataSize ) { return hashCode & dataSize - 1 ; MST[rv.UOI2Mutator]MSP[] } protected HashEntry < K , V > getEntry ( Object key ) { key = convertKey ( key ) ; final int hashCode = hash ( key ) ;
HashEntry < K , V > entry = data [ hashIndex ( hashCode , data . length ) ] ; MST[rv.UOI4Mutator]MSP[] while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { return entry ; }
final HashEntry < K , V > oldEntries [] = data ; final HashEntry < K , V > newEntries [] = new HashEntry [ newCapacity ] ; modCount ++ ; for ( int i = oldCapacity - 1 ; i >= 0 ; i -- ) { MST[rv.ROR1Mutator]MSP[]
HashEntry < K , V > entry = data [ hashIndex ( hashCode , data . length ) ] ; while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
previous . next = entry . next ; } } protected void destroyEntry ( final HashEntry < K , V > entry ) { entry . next = null ; entry . key = null ; MST[experimental.MemberVariableMutator]MSP[] entry . value = null ; } protected void checkCapacity () {
private void _putAll ( final Map < ? extends K , ? extends V > map ) { final int mapSize = map . size () ; if ( mapSize == 0 ) { MST[NegateConditionalsMutator]MSP[] return; }
if ( isEqualValue ( value , entry . getValue () ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return true ; } entry = entry . next ; } } } return false ; } @Override public V put ( final K key , final V value ) {
if ( isEqualValue ( value , entry . getValue () ) ) { MST[rv.ROR3Mutator]MSP[] return true ; } entry = entry . next ; } } } return false ; } @Override public V put ( final K key , final V value ) {
h += ~ ( h << 9 ) ; MST[rv.UOI1Mutator]MSP[] h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; return h ; } protected boolean isEqualKey ( final Object key1 , final Object key2 ) {
return key1 == key2 || key1 . equals ( key2 ) ; } protected boolean isEqualValue ( final Object value1 , final Object value2 ) { return value1 == value2 || value1 . equals ( value2 ) ; MST[InlineConstantMutator]MSP[] }
final HashEntry < K , V > oldEntries [] = data ; final HashEntry < K , V > newEntries [] = new HashEntry [ newCapacity ] ; modCount ++ ; for ( int i = oldCapacity - 1 ; i >= 0 ; i -- ) { MST[rv.CRCR6Mutator]MSP[]
final int newSize = (int) ( ( size + mapSize ) / loadFactor + 1 ) ; MST[rv.AOR2Mutator]MSP[] ensureCapacity ( calculateNewCapacity ( newSize ) ) ; for ( final Map . Entry < ? extends K , ? extends V > entry : map . entrySet () ) {
if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { MST[rv.ROR2Mutator]MSP[] final V oldValue = entry . getValue () ; removeMapping ( entry , index , previous ) ; return oldValue ; } previous = entry ; entry = entry . next ;
h += ~ ( h << 9 ) ; h ^= h >>> 14 ; MST[rv.UOI4Mutator]MSP[] h += h << 4 ; h ^= h >>> 10 ; return h ; } protected boolean isEqualKey ( final Object key1 , final Object key2 ) {
final HashEntry < K , V > oldEntries [] = data ; final HashEntry < K , V > newEntries [] = new HashEntry [ newCapacity ] ; modCount ++ ; MST[rv.CRCR4Mutator]MSP[] for ( int i = oldCapacity - 1 ; i >= 0 ; i -- ) {
final HashEntry < K , V > oldEntries [] = data ; final HashEntry < K , V > newEntries [] = new HashEntry [ newCapacity ] ; modCount ++ ; for ( int i = oldCapacity - 1 ; i >= 0 ; i -- ) { MST[rv.CRCR3Mutator]MSP[]
data [ i ] = null ; MST[rv.UOI4Mutator]MSP[] } size = 0 ; } protected Object convertKey ( final Object key ) { return key == null ? NULL : key ; } protected int hash ( final Object key ) { int h = key . hashCode () ;
final Iterator < Map . Entry < K , V > > it = createEntrySetIterator () ; while ( it . hasNext () ) { total += it . next () . hashCode () ; MST[rv.ABSMutator]MSP[] } return total ; } @Override public String toString () {
final int index = hashIndex ( hashCode , data . length ) ; HashEntry < K , V > entry = data [ index ] ; MST[rv.UOI3Mutator]MSP[] HashEntry < K , V > previous = null ; while ( entry != null ) {
entry = entry . next ; } addMapping ( index , hashCode , key , value ) ; MST[rv.UOI4Mutator]MSP[] return null ; } @Override public void putAll ( final Map < ? extends K , ? extends V > map ) { _putAll ( map ) ; }
protected void addEntry ( final HashEntry < K , V > entry , final int hashIndex ) { data [ hashIndex ] = entry ; MST[rv.UOI2Mutator]MSP[] }
if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { MST[rv.ROR5Mutator]MSP[] return true ; } entry = entry . next ; } return false ; } @Override public boolean containsValue ( final Object value ) { if ( value == null ) {
protected void doWriteObject ( final ObjectOutputStream out ) throws IOException { out . writeFloat ( loadFactor ) ; MST[rv.ABSMutator]MSP[] out . writeInt ( data . length ) ; out . writeInt ( size ) ;
HashEntry < K , V > entry = data [ hashIndex ( hashCode , data . length ) ] ; while ( entry != null ) { MST[NegateConditionalsMutator]MSP[] if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) {
return key1 == key2 || key1 . equals ( key2 ) ; MST[ReturnValsMutator]MSP[] } protected boolean isEqualValue ( final Object value1 , final Object value2 ) { return value1 == value2 || value1 . equals ( value2 ) ; }
threshold = calculateThreshold ( newCapacity , loadFactor ) ; MST[rv.UOI2Mutator]MSP[] data = newEntries ; } } protected int calculateNewCapacity ( final int proposedCapacity ) { int newCapacity = 1 ; if ( proposedCapacity > MAXIMUM_CAPACITY ) { newCapacity = MAXIMUM_CAPACITY ; } else { while ( newCapacity < proposedCapacity ) {
public Set < K > keySet () { if ( keySet == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] keySet = new KeySet <> ( this ) ; } return keySet ; } protected Iterator < K > createKeySetIterator () { if ( size () == 0 ) {
if ( size >= threshold ) { MST[rv.ROR1Mutator]MSP[] final int newCapacity = data . length * 2 ; if ( newCapacity <= MAXIMUM_CAPACITY ) { ensureCapacity ( newCapacity ) ; } } } @SuppressWarnings ( lr_1 ) protected void ensureCapacity ( final int newCapacity ) {
final int newSize = (int) ( ( size + mapSize ) / loadFactor + 1 ) ; MST[rv.AOR1Mutator]MSP[] ensureCapacity ( calculateNewCapacity ( newSize ) ) ; for ( final Map . Entry < ? extends K , ? extends V > entry : map . entrySet () ) {
protected void removeMapping ( final HashEntry < K , V > entry , final int hashIndex , final HashEntry < K , V > previous ) { modCount ++ ; MST[rv.CRCR4Mutator]MSP[] removeEntry ( entry , hashIndex , previous ) ; size -- ; destroyEntry ( entry ) ; }
if ( size >= threshold ) { final int newCapacity = data . length * 2 ; MST[rv.CRCR4Mutator]MSP[] if ( newCapacity <= MAXIMUM_CAPACITY ) { ensureCapacity ( newCapacity ) ; } } } @SuppressWarnings ( lr_1 ) protected void ensureCapacity ( final int newCapacity ) {
if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { return true ; MST[rv.CRCR3Mutator]MSP[] } entry = entry . next ; } return false ; } @Override public boolean containsValue ( final Object value ) { if ( value == null ) {
protected void doWriteObject ( final ObjectOutputStream out ) throws IOException { out . writeFloat ( loadFactor ) ; out . writeInt ( data . length ) ; out . writeInt ( size ) ; MST[rv.UOI1Mutator]MSP[]
data = new HashEntry [ capacity ] ; for ( int i = 0 ; i < size ; i ++ ) { MST[rv.CRCR5Mutator]MSP[] final K key = ( K ) in . readObject () ; final V value = ( V ) in . readObject () ;
cloned . data = new HashEntry [ data . length ] ; cloned . entrySet = null ; cloned . keySet = null ; cloned . values = null ; cloned . modCount = 0 ; MST[rv.CRCR5Mutator]MSP[] cloned . size = 0 ; cloned . init () ;
if ( isEqualValue ( value , entry . getValue () ) ) { MST[NonVoidMethodCallMutator]MSP[] return true ; } entry = entry . next ; } } } return false ; } @Override public V put ( final K key , final V value ) {
h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; MST[rv.UOI1Mutator]MSP[] return h ; } protected boolean isEqualKey ( final Object key1 , final Object key2 ) {
} return null ; } @Override public void clear () { modCount ++ ; final HashEntry < K , V > [] data = this . data ; for ( int i = data . length - 1 ; i >= 0 ; i -- ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[]
cloned . putAll ( this ) ; return cloned ; MST[NullReturnValsMutator]MSP[] } catch ( final CloneNotSupportedException ex ) { throw new InternalError () ; } } @Override public boolean equals ( final Object obj ) { if ( obj == this ) { return true ; }
} return null ; } @Override public void clear () { modCount ++ ; final HashEntry < K , V > [] data = this . data ; for ( int i = data . length - 1 ; i >= 0 ; i -- ) { MST[MathMutator]MSP[]
final int newSize = (int) ( ( size + mapSize ) / loadFactor + 1 ) ; ensureCapacity ( calculateNewCapacity ( newSize ) ) ; MST[ArgumentPropagationMutator]MSP[] for ( final Map . Entry < ? extends K , ? extends V > entry : map . entrySet () ) {
protected void removeMapping ( final HashEntry < K , V > entry , final int hashIndex , final HashEntry < K , V > previous ) { modCount ++ ; removeEntry ( entry , hashIndex , previous ) ; size -- ; MST[rv.CRCR2Mutator]MSP[] destroyEntry ( entry ) ; }
protected int hashIndex ( final int hashCode , final int dataSize ) { return hashCode & dataSize - 1 ; MST[rv.ABSMutator]MSP[] } protected HashEntry < K , V > getEntry ( Object key ) { key = convertKey ( key ) ; final int hashCode = hash ( key ) ;
h += ~ ( h << 9 ) ; MST[rv.CRCR3Mutator]MSP[] h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; return h ; } protected boolean isEqualKey ( final Object key1 , final Object key2 ) {
protected void removeMapping ( final HashEntry < K , V > entry , final int hashIndex , final HashEntry < K , V > previous ) { modCount ++ ; MST[rv.AOR1Mutator]MSP[] removeEntry ( entry , hashIndex , previous ) ; size -- ; destroyEntry ( entry ) ; }
protected void removeMapping ( final HashEntry < K , V > entry , final int hashIndex , final HashEntry < K , V > previous ) { modCount ++ ; MST[rv.UOI2Mutator]MSP[] removeEntry ( entry , hashIndex , previous ) ; size -- ; destroyEntry ( entry ) ; }
} } catch ( final ClassCastException ignored ) { return false ; } catch ( final NullPointerException ignored ) { return false ; } return true ; } @Override public int hashCode () { int total = 0 ; MST[rv.CRCR6Mutator]MSP[]
h += ~ ( h << 9 ) ; MST[rv.CRCR5Mutator]MSP[] h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; return h ; } protected boolean isEqualKey ( final Object key1 , final Object key2 ) {
if ( size >= threshold ) { MST[rv.ABSMutator]MSP[] final int newCapacity = data . length * 2 ; if ( newCapacity <= MAXIMUM_CAPACITY ) { ensureCapacity ( newCapacity ) ; } } } @SuppressWarnings ( lr_1 ) protected void ensureCapacity ( final int newCapacity ) {
h += ~ ( h << 9 ) ; h ^= h >>> 14 ; MST[MathMutator]MSP[] h += h << 4 ; h ^= h >>> 10 ; return h ; } protected boolean isEqualKey ( final Object key1 , final Object key2 ) {
protected int hashIndex ( final int hashCode , final int dataSize ) { return hashCode & dataSize - 1 ; MST[rv.CRCR4Mutator]MSP[] } protected HashEntry < K , V > getEntry ( Object key ) { key = convertKey ( key ) ; final int hashCode = hash ( key ) ;
final int oldCapacity = data . length ; if ( newCapacity <= oldCapacity ) { return; } if ( size == 0 ) { threshold = calculateThreshold ( newCapacity , loadFactor ) ; MST[experimental.MemberVariableMutator]MSP[] data = new HashEntry [ newCapacity ] ; } else {
while ( entry != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] if ( entry . hashCode == hashCode && isEqualKey ( convertedKey , entry . key ) ) { final V oldValue = entry . getValue () ; updateEntry ( entry , value ) ; return oldValue ; }
final HashEntry < K , V > oldEntries [] = data ; final HashEntry < K , V > newEntries [] = new HashEntry [ newCapacity ] ; MST[rv.UOI1Mutator]MSP[] modCount ++ ; for ( int i = oldCapacity - 1 ; i >= 0 ; i -- ) {
protected void doReadObject ( final ObjectInputStream in ) throws IOException , ClassNotFoundException { loadFactor = in . readFloat () ; final int capacity = in . readInt () ; final int size = in . readInt () ; init () ; threshold = calculateThreshold ( capacity , loadFactor ) ; MST[rv.UOI4Mutator]MSP[]
HashEntry < K , V > entry = data [ hashIndex ( hashCode , data . length ) ] ; while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { MST[rv.UOI3Mutator]MSP[]
for ( final MapIterator < K , V > it = mapIterator () ; it . hasNext () ; ) { MST[rv.ROR1Mutator]MSP[] out . writeObject ( it . next () ) ; out . writeObject ( it . getValue () ) ; } } @SuppressWarnings ( lr_1 )
data [ i ] = null ; } size = 0 ; MST[InlineConstantMutator]MSP[] } protected Object convertKey ( final Object key ) { return key == null ? NULL : key ; } protected int hash ( final Object key ) { int h = key . hashCode () ;
protected void reuseEntry ( final HashEntry < K , V > entry , final int hashIndex , final int hashCode , final K key , final V value ) { entry . next = data [ hashIndex ] ; entry . hashCode = hashCode ; MST[rv.UOI3Mutator]MSP[]
return EmptyIterator . <K > emptyIterator () ; } return new KeySetIterator <> ( this ) ; MST[ReturnValsMutator]MSP[] } @Override public int size () { return parent . size () ; } @Override public void clear () { parent . clear () ; } @Override
return entry . getValue () ; } entry = entry . next ; } return null ; } @Override public int size () { return size ; } @Override public boolean isEmpty () { return size == 0 ; MST[rv.ROR4Mutator]MSP[] } @Override public boolean containsKey ( Object key ) {
public Set < K > keySet () { if ( keySet == null ) { keySet = new KeySet <> ( this ) ; } return keySet ; } protected Iterator < K > createKeySetIterator () { if ( size () == 0 ) { MST[rv.ROR4Mutator]MSP[]
return key1 == key2 || key1 . equals ( key2 ) ; } protected boolean isEqualValue ( final Object value1 , final Object value2 ) { return value1 == value2 || value1 . equals ( value2 ) ; MST[rv.CRCR1Mutator]MSP[] }
protected void reuseEntry ( final HashEntry < K , V > entry , final int hashIndex , final int hashCode , final K key , final V value ) { entry . next = data [ hashIndex ] ; MST[rv.UOI1Mutator]MSP[] entry . hashCode = hashCode ;
return key1 == key2 || key1 . equals ( key2 ) ; MST[rv.CRCR6Mutator]MSP[] } protected boolean isEqualValue ( final Object value1 , final Object value2 ) { return value1 == value2 || value1 . equals ( value2 ) ; }
final int index = hashIndex ( hashCode , data . length ) ; MST[rv.UOI1Mutator]MSP[] HashEntry < K , V > entry = data [ index ] ; HashEntry < K , V > previous = null ; while ( entry != null ) {
HashEntry < K , V > entry = data [ hashIndex ( hashCode , data . length ) ] ; while ( entry != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { return entry ; }
HashEntry < K , V > entry = data [ hashIndex ( hashCode , data . length ) ] ; while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { MST[rv.UOI2Mutator]MSP[] return entry ; }
newCapacity <<= 1 ; } if ( newCapacity > MAXIMUM_CAPACITY ) { newCapacity = MAXIMUM_CAPACITY ; } } return newCapacity ; } protected int calculateThreshold ( final int newCapacity , final float factor ) { return (int) ( newCapacity * factor ) ; MST[rv.UOI3Mutator]MSP[] }
final Iterator < Map . Entry < K , V > > it = createEntrySetIterator () ; while ( it . hasNext () ) { MST[NonVoidMethodCallMutator]MSP[] total += it . next () . hashCode () ; } return total ; } @Override public String toString () {
protected HashEntry < K , V > createEntry ( final HashEntry < K , V > next , final int hashCode , final K key , final V value ) { return new HashEntry <> ( next , hashCode , convertKey ( key ) , value ) ; MST[rv.UOI1Mutator]MSP[] }
if ( size >= threshold ) { final int newCapacity = data . length * 2 ; MST[rv.AOR1Mutator]MSP[] if ( newCapacity <= MAXIMUM_CAPACITY ) { ensureCapacity ( newCapacity ) ; } } } @SuppressWarnings ( lr_1 ) protected void ensureCapacity ( final int newCapacity ) {
} } catch ( final ClassCastException ignored ) { return false ; } catch ( final NullPointerException ignored ) { return false ; } return true ; MST[InlineConstantMutator]MSP[] } @Override public int hashCode () { int total = 0 ;
return key1 == key2 || key1 . equals ( key2 ) ; MST[rv.ROR4Mutator]MSP[] } protected boolean isEqualValue ( final Object value1 , final Object value2 ) { return value1 == value2 || value1 . equals ( value2 ) ; }
protected int hashIndex ( final int hashCode , final int dataSize ) { return hashCode & dataSize - 1 ; MST[rv.UOI3Mutator]MSP[] } protected HashEntry < K , V > getEntry ( Object key ) { key = convertKey ( key ) ; final int hashCode = hash ( key ) ;
h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; return h ; MST[rv.UOI2Mutator]MSP[] } protected boolean isEqualKey ( final Object key1 , final Object key2 ) {
final HashEntry < K , V > oldEntries [] = data ; final HashEntry < K , V > newEntries [] = new HashEntry [ newCapacity ] ; modCount ++ ; for ( int i = oldCapacity - 1 ; i >= 0 ; i -- ) { MST[rv.UOI1Mutator]MSP[]
protected int hashIndex ( final int hashCode , final int dataSize ) { return hashCode & dataSize - 1 ; MST[ReturnValsMutator]MSP[] } protected HashEntry < K , V > getEntry ( Object key ) { key = convertKey ( key ) ; final int hashCode = hash ( key ) ;
data [ i ] = null ; } size = 0 ; } protected Object convertKey ( final Object key ) { return key == null ? NULL : key ; MST[ReturnValsMutator]MSP[] } protected int hash ( final Object key ) { int h = key . hashCode () ;
final Object convertedKey = convertKey ( key ) ; final int hashCode = hash ( convertedKey ) ; final int index = hashIndex ( hashCode , data . length ) ; HashEntry < K , V > entry = data [ index ] ; MST[rv.UOI4Mutator]MSP[]
protected void doReadObject ( final ObjectInputStream in ) throws IOException , ClassNotFoundException { loadFactor = in . readFloat () ; MST[NonVoidMethodCallMutator]MSP[] final int capacity = in . readInt () ; final int size = in . readInt () ; init () ; threshold = calculateThreshold ( capacity , loadFactor ) ;
HashEntry < K , V > entry = data [ hashIndex ( hashCode , data . length ) ] ; while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { MST[rv.ROR1Mutator]MSP[] return entry ; }
newCapacity <<= 1 ; } if ( newCapacity > MAXIMUM_CAPACITY ) { newCapacity = MAXIMUM_CAPACITY ; } } return newCapacity ; } protected int calculateThreshold ( final int newCapacity , final float factor ) { return (int) ( newCapacity * factor ) ; MST[rv.AOR3Mutator]MSP[] }
protected int hashIndex ( final int hashCode , final int dataSize ) { return hashCode & dataSize - 1 ; } protected HashEntry < K , V > getEntry ( Object key ) { key = convertKey ( key ) ; MST[ArgumentPropagationMutator]MSP[] final int hashCode = hash ( key ) ;
final HashEntry < K , V > entry = createEntry ( data [ hashIndex ] , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; size ++ ; MST[rv.UOI1Mutator]MSP[] checkCapacity () ; }
data [ i ] = null ; } size = 0 ; } protected Object convertKey ( final Object key ) { return key == null ? NULL : key ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] } protected int hash ( final Object key ) { int h = key . hashCode () ;
HashEntry < K , V > entry = data [ hashIndex ( hashCode , data . length ) ] ; while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { MST[rv.ROR2Mutator]MSP[]
final int newSize = (int) ( ( size + mapSize ) / loadFactor + 1 ) ; MST[rv.UOI3Mutator]MSP[] ensureCapacity ( calculateNewCapacity ( newSize ) ) ; for ( final Map . Entry < ? extends K , ? extends V > entry : map . entrySet () ) {
cloned . data = new HashEntry [ data . length ] ; cloned . entrySet = null ; cloned . keySet = null ; cloned . values = null ; cloned . modCount = 0 ; cloned . size = 0 ; MST[rv.CRCR1Mutator]MSP[] cloned . init () ;
cloned . putAll ( this ) ; return cloned ; } catch ( final CloneNotSupportedException ex ) { throw new InternalError () ; } } @Override public boolean equals ( final Object obj ) { if ( obj == this ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return true ; }
final int newSize = (int) ( ( size + mapSize ) / loadFactor + 1 ) ; MST[rv.AOD2Mutator]MSP[] ensureCapacity ( calculateNewCapacity ( newSize ) ) ; for ( final Map . Entry < ? extends K , ? extends V > entry : map . entrySet () ) {
threshold = calculateThreshold ( newCapacity , loadFactor ) ; data = newEntries ; } } protected int calculateNewCapacity ( final int proposedCapacity ) { int newCapacity = 1 ; if ( proposedCapacity > MAXIMUM_CAPACITY ) { newCapacity = MAXIMUM_CAPACITY ; } else { while ( newCapacity < proposedCapacity ) { MST[rv.ROR1Mutator]MSP[]
final int oldCapacity = data . length ; if ( newCapacity <= oldCapacity ) { return; } if ( size == 0 ) { MST[rv.ABSMutator]MSP[] threshold = calculateThreshold ( newCapacity , loadFactor ) ; data = new HashEntry [ newCapacity ] ; } else {
protected void doReadObject ( final ObjectInputStream in ) throws IOException , ClassNotFoundException { loadFactor = in . readFloat () ; final int capacity = in . readInt () ; final int size = in . readInt () ; init () ; MST[VoidMethodCallMutator]MSP[] threshold = calculateThreshold ( capacity , loadFactor ) ;
if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { MST[NegateConditionalsMutator]MSP[] return true ; } entry = entry . next ; } return false ; } @Override public boolean containsValue ( final Object value ) { if ( value == null ) {
h += ~ ( h << 9 ) ; h ^= h >>> 14 ; MST[rv.CRCR2Mutator]MSP[] h += h << 4 ; h ^= h >>> 10 ; return h ; } protected boolean isEqualKey ( final Object key1 , final Object key2 ) {
protected Iterator < Map . Entry < K , V > > createEntrySetIterator () { if ( size () == 0 ) { MST[rv.ROR3Mutator]MSP[] return EmptyIterator . < Map . Entry < K , V > > emptyIterator () ; } return new EntrySetIterator <> ( this ) ; } @Override
return entry . getValue () ; } entry = entry . next ; } return null ; } @Override public int size () { return size ; } @Override public boolean isEmpty () { return size == 0 ; MST[BooleanTrueReturnValsMutator]MSP[] } @Override public boolean containsKey ( Object key ) {
if ( size >= threshold ) { final int newCapacity = data . length * 2 ; if ( newCapacity <= MAXIMUM_CAPACITY ) { MST[rv.ROR1Mutator]MSP[] ensureCapacity ( newCapacity ) ; } } } @SuppressWarnings ( lr_1 ) protected void ensureCapacity ( final int newCapacity ) {
public Set < K > keySet () { if ( keySet == null ) { keySet = new KeySet <> ( this ) ; } return keySet ; } protected Iterator < K > createKeySetIterator () { if ( size () == 0 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
if ( map . get ( key ) != null || map . containsKey ( key ) == false ) { return false ; } } else { if ( value . equals ( map . get ( key ) ) == false ) { MST[rv.ROR3Mutator]MSP[] return false ; } }
h += ~ ( h << 9 ) ; MST[rv.UOI2Mutator]MSP[] h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; return h ; } protected boolean isEqualKey ( final Object key1 , final Object key2 ) {
cloned . data = new HashEntry [ data . length ] ; MST[experimental.MemberVariableMutator]MSP[] cloned . entrySet = null ; cloned . keySet = null ; cloned . values = null ; cloned . modCount = 0 ; cloned . size = 0 ; cloned . init () ;
if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { final V oldValue = entry . getValue () ; removeMapping ( entry , index , previous ) ; MST[rv.UOI4Mutator]MSP[] return oldValue ; } previous = entry ; entry = entry . next ;
} return null ; } @Override public void clear () { modCount ++ ; MST[rv.UOI2Mutator]MSP[] final HashEntry < K , V > [] data = this . data ; for ( int i = data . length - 1 ; i >= 0 ; i -- ) {
HashEntry < K , V > entry = data [ hashIndex ( hashCode , data . length ) ] ; MST[ArgumentPropagationMutator]MSP[] while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { return entry ; }
if ( size () == 0 ) { MST[rv.ROR2Mutator]MSP[] return lr_6 ; } final StringBuilder buf = new StringBuilder ( 32 * size () ) ; buf . append ( '{' ) ; final MapIterator < K , V > it = mapIterator () ;
if ( obj instanceof Map == false ) { return false ; MST[rv.CRCR1Mutator]MSP[] } final Map < ? , ? > map = ( Map < ? , ? > ) obj ; if ( map . size () != size () ) { return false ; }
final int index = hashIndex ( entry . hashCode , newCapacity ) ; entry . next = newEntries [ index ] ; MST[rv.ABSMutator]MSP[] newEntries [ index ] = entry ; entry = next ; } while ( entry != null ); } }
final int index = hashIndex ( entry . hashCode , newCapacity ) ; MST[rv.UOI1Mutator]MSP[] entry . next = newEntries [ index ] ; newEntries [ index ] = entry ; entry = next ; } while ( entry != null ); } }
threshold = calculateThreshold ( newCapacity , loadFactor ) ; data = newEntries ; } } protected int calculateNewCapacity ( final int proposedCapacity ) { int newCapacity = 1 ; if ( proposedCapacity > MAXIMUM_CAPACITY ) { MST[rv.ROR5Mutator]MSP[] newCapacity = MAXIMUM_CAPACITY ; } else { while ( newCapacity < proposedCapacity ) {
while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( convertedKey , entry . key ) ) { MST[rv.ROR3Mutator]MSP[] final V oldValue = entry . getValue () ; updateEntry ( entry , value ) ; return oldValue ; }
return entry . getValue () ; } entry = entry . next ; } return null ; } @Override public int size () { return size ; } @Override public boolean isEmpty () { return size == 0 ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] } @Override public boolean containsKey ( Object key ) {
public Set < Map . Entry < K , V > > entrySet () { if ( entrySet == null ) { MST[rv.ROR5Mutator]MSP[] entrySet = new EntrySet <> ( this ) ; } return entrySet ; }
final int oldCapacity = data . length ; if ( newCapacity <= oldCapacity ) { return; } if ( size == 0 ) { MST[rv.UOI2Mutator]MSP[] threshold = calculateThreshold ( newCapacity , loadFactor ) ; data = new HashEntry [ newCapacity ] ; } else {
if ( obj instanceof Map == false ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return false ; } final Map < ? , ? > map = ( Map < ? , ? > ) obj ; if ( map . size () != size () ) { return false ; }
newCapacity <<= 1 ; } if ( newCapacity > MAXIMUM_CAPACITY ) { newCapacity = MAXIMUM_CAPACITY ; } } return newCapacity ; } protected int calculateThreshold ( final int newCapacity , final float factor ) { return (int) ( newCapacity * factor ) ; MST[rv.UOI1Mutator]MSP[] }
HashEntry < K , V > entry = data [ hashIndex ( hashCode , data . length ) ] ; while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { MST[NegateConditionalsMutator]MSP[]
} return null ; } @Override public void clear () { modCount ++ ; final HashEntry < K , V > [] data = this . data ; for ( int i = data . length - 1 ; i >= 0 ; i -- ) { MST[rv.ABSMutator]MSP[]
} } catch ( final ClassCastException ignored ) { return false ; } catch ( final NullPointerException ignored ) { return false ; } return true ; MST[rv.CRCR2Mutator]MSP[] } @Override public int hashCode () { int total = 0 ;
protected void addEntry ( final HashEntry < K , V > entry , final int hashIndex ) { data [ hashIndex ] = entry ; MST[rv.UOI1Mutator]MSP[] }
} return null ; } @Override public void clear () { modCount ++ ; final HashEntry < K , V > [] data = this . data ; for ( int i = data . length - 1 ; i >= 0 ; i -- ) { MST[rv.ROR3Mutator]MSP[]
protected Iterator < Map . Entry < K , V > > createEntrySetIterator () { if ( size () == 0 ) { return EmptyIterator . < Map . Entry < K , V > > emptyIterator () ; } return new EntrySetIterator <> ( this ) ; MST[ReturnValsMutator]MSP[] } @Override
if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { MST[rv.ROR4Mutator]MSP[] return true ; } entry = entry . next ; } return false ; } @Override public boolean containsValue ( final Object value ) { if ( value == null ) {
final int newSize = (int) ( ( size + mapSize ) / loadFactor + 1 ) ; ensureCapacity ( calculateNewCapacity ( newSize ) ) ; MST[VoidMethodCallMutator]MSP[] for ( final Map . Entry < ? extends K , ? extends V > entry : map . entrySet () ) {
if ( obj instanceof Map == false ) { return false ; } final Map < ? , ? > map = ( Map < ? , ? > ) obj ; if ( map . size () != size () ) { return false ; MST[rv.CRCR5Mutator]MSP[] }
if ( obj instanceof Map == false ) { MST[rv.ROR5Mutator]MSP[] return false ; } final Map < ? , ? > map = ( Map < ? , ? > ) obj ; if ( map . size () != size () ) { return false ; }
if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { MST[rv.ROR3Mutator]MSP[] final V oldValue = entry . getValue () ; removeMapping ( entry , index , previous ) ; return oldValue ; } previous = entry ; entry = entry . next ;
h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; MST[rv.CRCR2Mutator]MSP[] return h ; } protected boolean isEqualKey ( final Object key1 , final Object key2 ) {
h += ~ ( h << 9 ) ; MST[rv.AOR1Mutator]MSP[] h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; return h ; } protected boolean isEqualKey ( final Object key1 , final Object key2 ) {
newCapacity <<= 1 ; } if ( newCapacity > MAXIMUM_CAPACITY ) { MST[rv.CRCR6Mutator]MSP[] newCapacity = MAXIMUM_CAPACITY ; } } return newCapacity ; } protected int calculateThreshold ( final int newCapacity , final float factor ) { return (int) ( newCapacity * factor ) ; }
while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( convertedKey , entry . key ) ) { MST[rv.UOI4Mutator]MSP[] final V oldValue = entry . getValue () ; updateEntry ( entry , value ) ; return oldValue ; }
h += ~ ( h << 9 ) ; MST[rv.UOI3Mutator]MSP[] h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; return h ; } protected boolean isEqualKey ( final Object key1 , final Object key2 ) {
entry = entry . next ; } } } else { for ( final HashEntry < K , V > element : data ) { MST[rv.UOI3Mutator]MSP[] HashEntry < K , V > entry = element ; while ( entry != null ) {
entry = entry . next ; } } } else { for ( final HashEntry < K , V > element : data ) { MST[rv.UOI2Mutator]MSP[] HashEntry < K , V > entry = element ; while ( entry != null ) {
HashEntry < K , V > entry = data [ hashIndex ( hashCode , data . length ) ] ; while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { return entry ; MST[NullReturnValsMutator]MSP[] }
return entry . getValue () ; } entry = entry . next ; } return null ; } @Override public int size () { return size ; } @Override public boolean isEmpty () { return size == 0 ; MST[rv.ROR5Mutator]MSP[] } @Override public boolean containsKey ( Object key ) {
final int index = hashIndex ( entry . hashCode , newCapacity ) ; entry . next = newEntries [ index ] ; MST[rv.UOI2Mutator]MSP[] newEntries [ index ] = entry ; entry = next ; } while ( entry != null ); } }
if ( isEqualValue ( value , entry . getValue () ) ) { MST[NegateConditionalsMutator]MSP[] return true ; } entry = entry . next ; } } } return false ; } @Override public V put ( final K key , final V value ) {
final HashEntry < K , V > entry = createEntry ( data [ hashIndex ] , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; size ++ ; MST[rv.AOD2Mutator]MSP[] checkCapacity () ; }
final Iterator < Map . Entry < K , V > > it = createEntrySetIterator () ; while ( it . hasNext () ) { total += it . next () . hashCode () ; MST[rv.AOD1Mutator]MSP[] } return total ; } @Override public String toString () {
if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { MST[rv.UOI2Mutator]MSP[] final V oldValue = entry . getValue () ; removeMapping ( entry , index , previous ) ; return oldValue ; } previous = entry ; entry = entry . next ;
public MapIterator < K , V > mapIterator () { if ( size == 0 ) { return EmptyMapIterator . <K , V > emptyMapIterator () ; } return new HashMapIterator <> ( this ) ; MST[ReturnValsMutator]MSP[] } @Override public K next () {
return entry . getValue () ; } entry = entry . next ; } return null ; } @Override public int size () { return size ; MST[ReturnValsMutator]MSP[] } @Override public boolean isEmpty () { return size == 0 ; } @Override public boolean containsKey ( Object key ) {
HashEntry < K , V > entry = data [ hashIndex ( hashCode , data . length ) ] ; while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { MST[rv.ROR3Mutator]MSP[]
protected void removeMapping ( final HashEntry < K , V > entry , final int hashIndex , final HashEntry < K , V > previous ) { modCount ++ ; MST[rv.UOI1Mutator]MSP[] removeEntry ( entry , hashIndex , previous ) ; size -- ; destroyEntry ( entry ) ; }
} } catch ( final ClassCastException ignored ) { return false ; } catch ( final NullPointerException ignored ) { return false ; } return true ; } @Override public int hashCode () { int total = 0 ; MST[rv.CRCR5Mutator]MSP[]
HashEntry < K , V > entry = data [ hashIndex ( hashCode , data . length ) ] ; while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { MST[rv.ROR5Mutator]MSP[]
} return null ; } @Override public void clear () { modCount ++ ; final HashEntry < K , V > [] data = this . data ; for ( int i = data . length - 1 ; i >= 0 ; i -- ) { MST[rv.UOI2Mutator]MSP[]
} return null ; } @Override public void clear () { modCount ++ ; MST[experimental.MemberVariableMutator]MSP[] final HashEntry < K , V > [] data = this . data ; for ( int i = data . length - 1 ; i >= 0 ; i -- ) {
h += ~ ( h << 9 ) ; h ^= h >>> 14 ; MST[rv.ABSMutator]MSP[] h += h << 4 ; h ^= h >>> 10 ; return h ; } protected boolean isEqualKey ( final Object key1 , final Object key2 ) {
protected void removeEntry ( final HashEntry < K , V > entry , final int hashIndex , final HashEntry < K , V > previous ) { if ( previous == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] data [ hashIndex ] = entry . next ; } else {
final int oldCapacity = data . length ; if ( newCapacity <= oldCapacity ) { return; } if ( size == 0 ) { MST[rv.ROR3Mutator]MSP[] threshold = calculateThreshold ( newCapacity , loadFactor ) ; data = new HashEntry [ newCapacity ] ; } else {
return entry . getValue () ; } entry = entry . next ; } return null ; } @Override public int size () { return size ; } @Override public boolean isEmpty () { return size == 0 ; MST[rv.UOI4Mutator]MSP[] } @Override public boolean containsKey ( Object key ) {
HashEntry < K , V > entry = data [ hashIndex ( hashCode , data . length ) ] ; while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { MST[rv.ABSMutator]MSP[]
h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; MST[rv.UOI2Mutator]MSP[] return h ; } protected boolean isEqualKey ( final Object key1 , final Object key2 ) {
if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] final V oldValue = entry . getValue () ; removeMapping ( entry , index , previous ) ; return oldValue ; } previous = entry ; entry = entry . next ;
data [ i ] = null ; } size = 0 ; } protected Object convertKey ( final Object key ) { return key == null ? NULL : key ; MST[NullReturnValsMutator]MSP[] } protected int hash ( final Object key ) { int h = key . hashCode () ;
if ( obj instanceof Map == false ) { MST[NegateConditionalsMutator]MSP[] return false ; } final Map < ? , ? > map = ( Map < ? , ? > ) obj ; if ( map . size () != size () ) { return false ; }
if ( obj instanceof Map == false ) { return false ; } final Map < ? , ? > map = ( Map < ? , ? > ) obj ; if ( map . size () != size () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return false ; }
while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( convertedKey , entry . key ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] final V oldValue = entry . getValue () ; updateEntry ( entry , value ) ; return oldValue ; }
protected void removeMapping ( final HashEntry < K , V > entry , final int hashIndex , final HashEntry < K , V > previous ) { modCount ++ ; MST[rv.AOR2Mutator]MSP[] removeEntry ( entry , hashIndex , previous ) ; size -- ; destroyEntry ( entry ) ; }
if ( size >= threshold ) { final int newCapacity = data . length * 2 ; if ( newCapacity <= MAXIMUM_CAPACITY ) { ensureCapacity ( newCapacity ) ; MST[VoidMethodCallMutator]MSP[] } } } @SuppressWarnings ( lr_1 ) protected void ensureCapacity ( final int newCapacity ) {
h += ~ ( h << 9 ) ; MST[rv.CRCR4Mutator]MSP[] h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; return h ; } protected boolean isEqualKey ( final Object key1 , final Object key2 ) {
public MapIterator < K , V > mapIterator () { if ( size == 0 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return EmptyMapIterator . <K , V > emptyMapIterator () ; } return new HashMapIterator <> ( this ) ; } @Override public K next () {
if ( isEqualValue ( value , entry . getValue () ) ) { return true ; } entry = entry . next ; } } } return false ; MST[ReturnValsMutator]MSP[] } @Override public V put ( final K key , final V value ) {
data = new HashEntry [ capacity ] ; for ( int i = 0 ; i < size ; i ++ ) { MST[IncrementsMutator]MSP[] final K key = ( K ) in . readObject () ; final V value = ( V ) in . readObject () ;
final HashEntry < K , V > entry = createEntry ( data [ hashIndex ] , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; size ++ ; checkCapacity () ; MST[VoidMethodCallMutator]MSP[] }
public Set < Map . Entry < K , V > > entrySet () { if ( entrySet == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] entrySet = new EntrySet <> ( this ) ; } return entrySet ; }
if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { final V oldValue = entry . getValue () ; removeMapping ( entry , index , previous ) ; MST[rv.UOI2Mutator]MSP[] return oldValue ; } previous = entry ; entry = entry . next ;
HashEntry < K , V > entry = data [ hashIndex ( hashCode , data . length ) ] ; while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { MST[rv.UOI2Mutator]MSP[]
h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; MST[rv.ABSMutator]MSP[] return h ; } protected boolean isEqualKey ( final Object key1 , final Object key2 ) {
final int oldCapacity = data . length ; if ( newCapacity <= oldCapacity ) { return; } if ( size == 0 ) { threshold = calculateThreshold ( newCapacity , loadFactor ) ; data = new HashEntry [ newCapacity ] ; MST[rv.UOI1Mutator]MSP[] } else {
final int newSize = (int) ( ( size + mapSize ) / loadFactor + 1 ) ; MST[rv.AOR2Mutator]MSP[] ensureCapacity ( calculateNewCapacity ( newSize ) ) ; for ( final Map . Entry < ? extends K , ? extends V > entry : map . entrySet () ) {
final HashEntry < K , V > entry = createEntry ( data [ hashIndex ] , hashCode , key , value ) ; MST[rv.UOI3Mutator]MSP[] addEntry ( entry , hashIndex ) ; size ++ ; checkCapacity () ; }
return entry . getValue () ; } entry = entry . next ; } return null ; } @Override public int size () { return size ; } @Override public boolean isEmpty () { return size == 0 ; MST[NegateConditionalsMutator]MSP[] } @Override public boolean containsKey ( Object key ) {
h += ~ ( h << 9 ) ; h ^= h >>> 14 ; MST[rv.UOI2Mutator]MSP[] h += h << 4 ; h ^= h >>> 10 ; return h ; } protected boolean isEqualKey ( final Object key1 , final Object key2 ) {
public MapIterator < K , V > mapIterator () { if ( size == 0 ) { MST[rv.ROR3Mutator]MSP[] return EmptyMapIterator . <K , V > emptyMapIterator () ; } return new HashMapIterator <> ( this ) ; } @Override public K next () {
public Set < Map . Entry < K , V > > entrySet () { if ( entrySet == null ) { entrySet = new EntrySet <> ( this ) ; MST[experimental.MemberVariableMutator]MSP[] } return entrySet ; }
public MapIterator < K , V > mapIterator () { if ( size == 0 ) { MST[rv.UOI2Mutator]MSP[] return EmptyMapIterator . <K , V > emptyMapIterator () ; } return new HashMapIterator <> ( this ) ; } @Override public K next () {
final int oldCapacity = data . length ; if ( newCapacity <= oldCapacity ) { return; } if ( size == 0 ) { threshold = calculateThreshold ( newCapacity , loadFactor ) ; MST[rv.UOI4Mutator]MSP[] data = new HashEntry [ newCapacity ] ; } else {
cloned . data = new HashEntry [ data . length ] ; cloned . entrySet = null ; cloned . keySet = null ; cloned . values = null ; cloned . modCount = 0 ; cloned . size = 0 ; MST[rv.CRCR5Mutator]MSP[] cloned . init () ;
final Iterator < Map . Entry < K , V > > it = createEntrySetIterator () ; while ( it . hasNext () ) { total += it . next () . hashCode () ; } return total ; MST[rv.UOI4Mutator]MSP[] } @Override public String toString () {
HashEntry < K , V > entry = data [ hashIndex ( hashCode , data . length ) ] ; while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { MST[rv.UOI1Mutator]MSP[] return entry ; }
while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( convertedKey , entry . key ) ) { MST[rv.ROR1Mutator]MSP[] final V oldValue = entry . getValue () ; updateEntry ( entry , value ) ; return oldValue ; }
protected HashEntry < K , V > createEntry ( final HashEntry < K , V > next , final int hashCode , final K key , final V value ) { return new HashEntry <> ( next , hashCode , convertKey ( key ) , value ) ; MST[rv.UOI2Mutator]MSP[] }
final int index = hashIndex ( entry . hashCode , newCapacity ) ; entry . next = newEntries [ index ] ; newEntries [ index ] = entry ; MST[rv.UOI4Mutator]MSP[] entry = next ; } while ( entry != null ); } }
entry . key = key ; entry . value = value ; } protected void addMapping ( final int hashIndex , final int hashCode , final K key , final V value ) { modCount ++ ; MST[rv.CRCR5Mutator]MSP[]
threshold = calculateThreshold ( newCapacity , loadFactor ) ; MST[rv.UOI1Mutator]MSP[] data = newEntries ; } } protected int calculateNewCapacity ( final int proposedCapacity ) { int newCapacity = 1 ; if ( proposedCapacity > MAXIMUM_CAPACITY ) { newCapacity = MAXIMUM_CAPACITY ; } else { while ( newCapacity < proposedCapacity ) {
entry . key = key ; entry . value = value ; MST[experimental.MemberVariableMutator]MSP[] } protected void addMapping ( final int hashIndex , final int hashCode , final K key , final V value ) { modCount ++ ;
if ( map . get ( key ) != null || map . containsKey ( key ) == false ) { return false ; } } else { if ( value . equals ( map . get ( key ) ) == false ) { MST[rv.ROR2Mutator]MSP[] return false ; } }
final int newSize = (int) ( ( size + mapSize ) / loadFactor + 1 ) ; ensureCapacity ( calculateNewCapacity ( newSize ) ) ; MST[rv.UOI4Mutator]MSP[] for ( final Map . Entry < ? extends K , ? extends V > entry : map . entrySet () ) {
if ( size >= threshold ) { final int newCapacity = data . length * 2 ; if ( newCapacity <= MAXIMUM_CAPACITY ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] ensureCapacity ( newCapacity ) ; } } } @SuppressWarnings ( lr_1 ) protected void ensureCapacity ( final int newCapacity ) {
threshold = calculateThreshold ( newCapacity , loadFactor ) ; data = newEntries ; } } protected int calculateNewCapacity ( final int proposedCapacity ) { int newCapacity = 1 ; if ( proposedCapacity > MAXIMUM_CAPACITY ) { newCapacity = MAXIMUM_CAPACITY ; } else { while ( newCapacity < proposedCapacity ) { MST[rv.ROR3Mutator]MSP[]
h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; MST[InlineConstantMutator]MSP[] return h ; } protected boolean isEqualKey ( final Object key1 , final Object key2 ) {
threshold = calculateThreshold ( newCapacity , loadFactor ) ; data = newEntries ; } } protected int calculateNewCapacity ( final int proposedCapacity ) { int newCapacity = 1 ; if ( proposedCapacity > MAXIMUM_CAPACITY ) { newCapacity = MAXIMUM_CAPACITY ; } else { while ( newCapacity < proposedCapacity ) { MST[ConditionalsBoundaryMutator]MSP[]
final MapIterator < ? , ? > it = mapIterator () ; try { while ( it . hasNext () ) { final Object key = it . next () ; final Object value = it . getValue () ; if ( value == null ) { MST[NegateConditionalsMutator]MSP[]
if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { MST[rv.UOI1Mutator]MSP[] return true ; } entry = entry . next ; } return false ; } @Override public boolean containsValue ( final Object value ) { if ( value == null ) {
entry = entry . next ; } } } else { for ( final HashEntry < K , V > element : data ) { HashEntry < K , V > entry = element ; while ( entry != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
HashEntry < K , V > entry = data [ hashIndex ( hashCode , data . length ) ] ; while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { return entry ; MST[ReturnValsMutator]MSP[] }
HashEntry < K , V > entry = oldEntries [ i ] ; MST[rv.UOI3Mutator]MSP[] if ( entry != null ) { oldEntries [ i ] = null ; do { final HashEntry < K , V > next = entry . next ;
protected int hashIndex ( final int hashCode , final int dataSize ) { return hashCode & dataSize - 1 ; MST[PrimitiveReturnsMutator]MSP[] } protected HashEntry < K , V > getEntry ( Object key ) { key = convertKey ( key ) ; final int hashCode = hash ( key ) ;
public Set < Map . Entry < K , V > > entrySet () { if ( entrySet == null ) { MST[NegateConditionalsMutator]MSP[] entrySet = new EntrySet <> ( this ) ; } return entrySet ; }
if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { return true ; } entry = entry . next ; } return false ; } @Override public boolean containsValue ( final Object value ) { if ( value == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
data = new HashEntry [ capacity ] ; for ( int i = 0 ; i < size ; i ++ ) { MST[rv.UOI3Mutator]MSP[] final K key = ( K ) in . readObject () ; final V value = ( V ) in . readObject () ;
return key1 == key2 || key1 . equals ( key2 ) ; MST[NegateConditionalsMutator]MSP[] } protected boolean isEqualValue ( final Object value1 , final Object value2 ) { return value1 == value2 || value1 . equals ( value2 ) ; }
if ( obj instanceof Map == false ) { return false ; MST[rv.CRCR5Mutator]MSP[] } final Map < ? , ? > map = ( Map < ? , ? > ) obj ; if ( map . size () != size () ) { return false ; }
protected int hashIndex ( final int hashCode , final int dataSize ) { return hashCode & dataSize - 1 ; MST[rv.CRCR6Mutator]MSP[] } protected HashEntry < K , V > getEntry ( Object key ) { key = convertKey ( key ) ; final int hashCode = hash ( key ) ;
return key1 == key2 || key1 . equals ( key2 ) ; MST[InlineConstantMutator]MSP[] } protected boolean isEqualValue ( final Object value1 , final Object value2 ) { return value1 == value2 || value1 . equals ( value2 ) ; }
if ( obj instanceof Map == false ) { return false ; } final Map < ? , ? > map = ( Map < ? , ? > ) obj ; if ( map . size () != size () ) { MST[rv.ROR5Mutator]MSP[] return false ; }
h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; MST[rv.AOR2Mutator]MSP[] h ^= h >>> 10 ; return h ; } protected boolean isEqualKey ( final Object key1 , final Object key2 ) {
final int newSize = (int) ( ( size + mapSize ) / loadFactor + 1 ) ; MST[rv.ABSMutator]MSP[] ensureCapacity ( calculateNewCapacity ( newSize ) ) ; for ( final Map . Entry < ? extends K , ? extends V > entry : map . entrySet () ) {
return key1 == key2 || key1 . equals ( key2 ) ; } protected boolean isEqualValue ( final Object value1 , final Object value2 ) { return value1 == value2 || value1 . equals ( value2 ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] }
if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { MST[NegateConditionalsMutator]MSP[] final V oldValue = entry . getValue () ; removeMapping ( entry , index , previous ) ; return oldValue ; } previous = entry ; entry = entry . next ;
threshold = calculateThreshold ( newCapacity , loadFactor ) ; data = newEntries ; MST[experimental.MemberVariableMutator]MSP[] } } protected int calculateNewCapacity ( final int proposedCapacity ) { int newCapacity = 1 ; if ( proposedCapacity > MAXIMUM_CAPACITY ) { newCapacity = MAXIMUM_CAPACITY ; } else { while ( newCapacity < proposedCapacity ) {
final HashEntry < K , V > entry = createEntry ( data [ hashIndex ] , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; size ++ ; MST[rv.CRCR6Mutator]MSP[] checkCapacity () ; }
final int index = hashIndex ( hashCode , data . length ) ; HashEntry < K , V > entry = data [ index ] ; MST[rv.UOI1Mutator]MSP[] HashEntry < K , V > previous = null ; while ( entry != null ) {
if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { MST[rv.UOI2Mutator]MSP[] return true ; } entry = entry . next ; } return false ; } @Override public boolean containsValue ( final Object value ) { if ( value == null ) {
threshold = calculateThreshold ( newCapacity , loadFactor ) ; data = newEntries ; } } protected int calculateNewCapacity ( final int proposedCapacity ) { int newCapacity = 1 ; if ( proposedCapacity > MAXIMUM_CAPACITY ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] newCapacity = MAXIMUM_CAPACITY ; } else { while ( newCapacity < proposedCapacity ) {
HashEntry < K , V > entry = oldEntries [ i ] ; if ( entry != null ) { oldEntries [ i ] = null ; MST[rv.ABSMutator]MSP[] do { final HashEntry < K , V > next = entry . next ;
} } catch ( final ClassCastException ignored ) { return false ; } catch ( final NullPointerException ignored ) { return false ; } return true ; MST[rv.CRCR5Mutator]MSP[] } @Override public int hashCode () { int total = 0 ;
final int oldCapacity = data . length ; if ( newCapacity <= oldCapacity ) { MST[ConditionalsBoundaryMutator]MSP[] return; } if ( size == 0 ) { threshold = calculateThreshold ( newCapacity , loadFactor ) ; data = new HashEntry [ newCapacity ] ; } else {
final HashEntry < K , V > oldEntries [] = data ; final HashEntry < K , V > newEntries [] = new HashEntry [ newCapacity ] ; modCount ++ ; MST[experimental.MemberVariableMutator]MSP[] for ( int i = oldCapacity - 1 ; i >= 0 ; i -- ) {
entry = entry . next ; } } } else { for ( final HashEntry < K , V > element : data ) { MST[rv.UOI3Mutator]MSP[] HashEntry < K , V > entry = element ; while ( entry != null ) {
threshold = calculateThreshold ( newCapacity , loadFactor ) ; data = newEntries ; } } protected int calculateNewCapacity ( final int proposedCapacity ) { int newCapacity = 1 ; if ( proposedCapacity > MAXIMUM_CAPACITY ) { MST[rv.CRCR5Mutator]MSP[] newCapacity = MAXIMUM_CAPACITY ; } else { while ( newCapacity < proposedCapacity ) {
final Object convertedKey = convertKey ( key ) ; final int hashCode = hash ( convertedKey ) ; final int index = hashIndex ( hashCode , data . length ) ; MST[rv.UOI4Mutator]MSP[] HashEntry < K , V > entry = data [ index ] ;
protected void addEntry ( final HashEntry < K , V > entry , final int hashIndex ) { data [ hashIndex ] = entry ; MST[rv.UOI4Mutator]MSP[] }
HashEntry < K , V > entry = data [ hashIndex ( hashCode , data . length ) ] ; MST[rv.UOI1Mutator]MSP[] while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) {
protected Iterator < Map . Entry < K , V > > createEntrySetIterator () { if ( size () == 0 ) { return EmptyIterator . < Map . Entry < K , V > > emptyIterator () ; MST[NullReturnValsMutator]MSP[] } return new EntrySetIterator <> ( this ) ; } @Override
HashEntry < K , V > entry = data [ hashIndex ( hashCode , data . length ) ] ; while ( entry != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) {
cloned . data = new HashEntry [ data . length ] ; cloned . entrySet = null ; cloned . keySet = null ; cloned . values = null ; cloned . modCount = 0 ; cloned . size = 0 ; MST[InlineConstantMutator]MSP[] cloned . init () ;
if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { MST[rv.ROR1Mutator]MSP[] return true ; } entry = entry . next ; } return false ; } @Override public boolean containsValue ( final Object value ) { if ( value == null ) {
if ( size >= threshold ) { MST[rv.ROR5Mutator]MSP[] final int newCapacity = data . length * 2 ; if ( newCapacity <= MAXIMUM_CAPACITY ) { ensureCapacity ( newCapacity ) ; } } } @SuppressWarnings ( lr_1 ) protected void ensureCapacity ( final int newCapacity ) {
put ( entry . getKey () , entry . getValue () ) ; MST[NonVoidMethodCallMutator]MSP[] } } @Override public V remove ( Object key ) { key = convertKey ( key ) ; final int hashCode = hash ( key ) ;
newCapacity <<= 1 ; } if ( newCapacity > MAXIMUM_CAPACITY ) { newCapacity = MAXIMUM_CAPACITY ; } } return newCapacity ; } protected int calculateThreshold ( final int newCapacity , final float factor ) { return (int) ( newCapacity * factor ) ; MST[rv.UOI4Mutator]MSP[] }
if ( size >= threshold ) { final int newCapacity = data . length * 2 ; MST[rv.CRCR6Mutator]MSP[] if ( newCapacity <= MAXIMUM_CAPACITY ) { ensureCapacity ( newCapacity ) ; } } } @SuppressWarnings ( lr_1 ) protected void ensureCapacity ( final int newCapacity ) {
key = convertKey ( key ) ; MST[ArgumentPropagationMutator]MSP[] final int hashCode = hash ( key ) ; HashEntry < K , V > entry = data [ hashIndex ( hashCode , data . length ) ] ; while ( entry != null ) {
final HashEntry < K , V > oldEntries [] = data ; final HashEntry < K , V > newEntries [] = new HashEntry [ newCapacity ] ; modCount ++ ; for ( int i = oldCapacity - 1 ; i >= 0 ; i -- ) { MST[rv.CRCR5Mutator]MSP[]
data = new HashEntry [ capacity ] ; for ( int i = 0 ; i < size ; i ++ ) { MST[rv.CRCR1Mutator]MSP[] final K key = ( K ) in . readObject () ; final V value = ( V ) in . readObject () ;
protected HashEntry < K , V > createEntry ( final HashEntry < K , V > next , final int hashCode , final K key , final V value ) { return new HashEntry <> ( next , hashCode , convertKey ( key ) , value ) ; MST[rv.ABSMutator]MSP[] }
h += ~ ( h << 9 ) ; MST[rv.CRCR1Mutator]MSP[] h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; return h ; } protected boolean isEqualKey ( final Object key1 , final Object key2 ) {
final HashEntry < K , V > oldEntries [] = data ; final HashEntry < K , V > newEntries [] = new HashEntry [ newCapacity ] ; MST[rv.ABSMutator]MSP[] modCount ++ ; for ( int i = oldCapacity - 1 ; i >= 0 ; i -- ) {
final Object convertedKey = convertKey ( key ) ; final int hashCode = hash ( convertedKey ) ; final int index = hashIndex ( hashCode , data . length ) ; MST[rv.ABSMutator]MSP[] HashEntry < K , V > entry = data [ index ] ;
h += ~ ( h << 9 ) ; MST[MathMutator]MSP[] h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; return h ; } protected boolean isEqualKey ( final Object key1 , final Object key2 ) {
protected void removeMapping ( final HashEntry < K , V > entry , final int hashIndex , final HashEntry < K , V > previous ) { modCount ++ ; removeEntry ( entry , hashIndex , previous ) ; size -- ; MST[rv.CRCR6Mutator]MSP[] destroyEntry ( entry ) ; }
final int index = hashIndex ( entry . hashCode , newCapacity ) ; entry . next = newEntries [ index ] ; MST[experimental.MemberVariableMutator]MSP[] newEntries [ index ] = entry ; entry = next ; } while ( entry != null ); } }
final Iterator < Map . Entry < K , V > > it = createEntrySetIterator () ; while ( it . hasNext () ) { total += it . next () . hashCode () ; } return total ; MST[ReturnValsMutator]MSP[] } @Override public String toString () {
h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; MST[rv.CRCR5Mutator]MSP[] return h ; } protected boolean isEqualKey ( final Object key1 , final Object key2 ) {
protected void doReadObject ( final ObjectInputStream in ) throws IOException , ClassNotFoundException { loadFactor = in . readFloat () ; final int capacity = in . readInt () ; MST[NonVoidMethodCallMutator]MSP[] final int size = in . readInt () ; init () ; threshold = calculateThreshold ( capacity , loadFactor ) ;
data [ i ] = null ; } size = 0 ; } protected Object convertKey ( final Object key ) { return key == null ? NULL : key ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] } protected int hash ( final Object key ) { int h = key . hashCode () ;
if ( map . get ( key ) != null || map . containsKey ( key ) == false ) { return false ; } } else { if ( value . equals ( map . get ( key ) ) == false ) { MST[NonVoidMethodCallMutator]MSP[] return false ; } }
} return null ; } @Override public void clear () { modCount ++ ; final HashEntry < K , V > [] data = this . data ; for ( int i = data . length - 1 ; i >= 0 ; i -- ) { MST[rv.AOR4Mutator]MSP[]
public Set < K > keySet () { if ( keySet == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] keySet = new KeySet <> ( this ) ; } return keySet ; } protected Iterator < K > createKeySetIterator () { if ( size () == 0 ) {
public MapIterator < K , V > mapIterator () { if ( size == 0 ) { return EmptyMapIterator . <K , V > emptyMapIterator () ; } return new HashMapIterator <> ( this ) ; MST[NullReturnValsMutator]MSP[] } @Override public K next () {
} return null ; } @Override public void clear () { modCount ++ ; final HashEntry < K , V > [] data = this . data ; for ( int i = data . length - 1 ; i >= 0 ; i -- ) { MST[rv.AOD1Mutator]MSP[]
h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; MST[rv.UOI3Mutator]MSP[] return h ; } protected boolean isEqualKey ( final Object key1 , final Object key2 ) {
if ( size () == 0 ) { return lr_6 ; MST[EmptyObjectReturnValsMutator]MSP[] } final StringBuilder buf = new StringBuilder ( 32 * size () ) ; buf . append ( '{' ) ; final MapIterator < K , V > it = mapIterator () ;
return key1 == key2 || key1 . equals ( key2 ) ; MST[rv.CRCR2Mutator]MSP[] } protected boolean isEqualValue ( final Object value1 , final Object value2 ) { return value1 == value2 || value1 . equals ( value2 ) ; }
final int newSize = (int) ( ( size + mapSize ) / loadFactor + 1 ) ; MST[rv.CRCR4Mutator]MSP[] ensureCapacity ( calculateNewCapacity ( newSize ) ) ; for ( final Map . Entry < ? extends K , ? extends V > entry : map . entrySet () ) {
if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { MST[rv.ROR5Mutator]MSP[] return true ; } entry = entry . next ; } return false ; } @Override public boolean containsValue ( final Object value ) { if ( value == null ) {
final int index = hashIndex ( entry . hashCode , newCapacity ) ; MST[ArgumentPropagationMutator]MSP[] entry . next = newEntries [ index ] ; newEntries [ index ] = entry ; entry = next ; } while ( entry != null ); } }
return key1 == key2 || key1 . equals ( key2 ) ; MST[rv.ROR2Mutator]MSP[] } protected boolean isEqualValue ( final Object value1 , final Object value2 ) { return value1 == value2 || value1 . equals ( value2 ) ; }
final int oldCapacity = data . length ; if ( newCapacity <= oldCapacity ) { MST[rv.UOI3Mutator]MSP[] return; } if ( size == 0 ) { threshold = calculateThreshold ( newCapacity , loadFactor ) ; data = new HashEntry [ newCapacity ] ; } else {
entry . key = key ; entry . value = value ; } protected void addMapping ( final int hashIndex , final int hashCode , final K key , final V value ) { modCount ++ ; MST[rv.CRCR2Mutator]MSP[]
entry . key = key ; entry . value = value ; } protected void addMapping ( final int hashIndex , final int hashCode , final K key , final V value ) { modCount ++ ; MST[rv.AOD2Mutator]MSP[]
HashEntry < K , V > entry = data [ hashIndex ( hashCode , data . length ) ] ; while ( entry != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { return entry ; }
data = new HashEntry [ capacity ] ; for ( int i = 0 ; i < size ; i ++ ) { MST[rv.ROR4Mutator]MSP[] final K key = ( K ) in . readObject () ; final V value = ( V ) in . readObject () ;
protected void removeEntry ( final HashEntry < K , V > entry , final int hashIndex , final HashEntry < K , V > previous ) { if ( previous == null ) { data [ hashIndex ] = entry . next ; MST[rv.UOI4Mutator]MSP[] } else {
if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { MST[rv.ROR5Mutator]MSP[] final V oldValue = entry . getValue () ; removeMapping ( entry , index , previous ) ; return oldValue ; } previous = entry ; entry = entry . next ;
threshold = calculateThreshold ( newCapacity , loadFactor ) ; MST[rv.UOI4Mutator]MSP[] data = newEntries ; } } protected int calculateNewCapacity ( final int proposedCapacity ) { int newCapacity = 1 ; if ( proposedCapacity > MAXIMUM_CAPACITY ) { newCapacity = MAXIMUM_CAPACITY ; } else { while ( newCapacity < proposedCapacity ) {
if ( obj instanceof Map == false ) { return false ; } final Map < ? , ? > map = ( Map < ? , ? > ) obj ; if ( map . size () != size () ) { MST[NegateConditionalsMutator]MSP[] return false ; }
return key1 == key2 || key1 . equals ( key2 ) ; MST[rv.ROR5Mutator]MSP[] } protected boolean isEqualValue ( final Object value1 , final Object value2 ) { return value1 == value2 || value1 . equals ( value2 ) ; }
if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { final V oldValue = entry . getValue () ; removeMapping ( entry , index , previous ) ; MST[VoidMethodCallMutator]MSP[] return oldValue ; } previous = entry ; entry = entry . next ;
if ( size >= threshold ) { final int newCapacity = data . length * 2 ; if ( newCapacity <= MAXIMUM_CAPACITY ) { MST[NegateConditionalsMutator]MSP[] ensureCapacity ( newCapacity ) ; } } } @SuppressWarnings ( lr_1 ) protected void ensureCapacity ( final int newCapacity ) {
public Set < K > keySet () { if ( keySet == null ) { keySet = new KeySet <> ( this ) ; } return keySet ; } protected Iterator < K > createKeySetIterator () { if ( size () == 0 ) { MST[rv.ROR1Mutator]MSP[]
if ( size >= threshold ) { MST[rv.UOI2Mutator]MSP[] final int newCapacity = data . length * 2 ; if ( newCapacity <= MAXIMUM_CAPACITY ) { ensureCapacity ( newCapacity ) ; } } } @SuppressWarnings ( lr_1 ) protected void ensureCapacity ( final int newCapacity ) {
final MapIterator < ? , ? > it = mapIterator () ; try { while ( it . hasNext () ) { final Object key = it . next () ; final Object value = it . getValue () ; if ( value == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
final HashEntry < K , V > oldEntries [] = data ; final HashEntry < K , V > newEntries [] = new HashEntry [ newCapacity ] ; modCount ++ ; MST[rv.CRCR3Mutator]MSP[] for ( int i = oldCapacity - 1 ; i >= 0 ; i -- ) {
cloned . putAll ( this ) ; return cloned ; } catch ( final CloneNotSupportedException ex ) { throw new InternalError () ; } } @Override public boolean equals ( final Object obj ) { if ( obj == this ) { return true ; MST[rv.CRCR6Mutator]MSP[] }
threshold = calculateThreshold ( newCapacity , loadFactor ) ; data = newEntries ; } } protected int calculateNewCapacity ( final int proposedCapacity ) { int newCapacity = 1 ; if ( proposedCapacity > MAXIMUM_CAPACITY ) { newCapacity = MAXIMUM_CAPACITY ; } else { while ( newCapacity < proposedCapacity ) { MST[rv.UOI2Mutator]MSP[]
final int index = hashIndex ( entry . hashCode , newCapacity ) ; MST[rv.UOI4Mutator]MSP[] entry . next = newEntries [ index ] ; newEntries [ index ] = entry ; entry = next ; } while ( entry != null ); } }
} return null ; } @Override public void clear () { modCount ++ ; MST[rv.CRCR6Mutator]MSP[] final HashEntry < K , V > [] data = this . data ; for ( int i = data . length - 1 ; i >= 0 ; i -- ) {
cloned . data = new HashEntry [ data . length ] ; cloned . entrySet = null ; cloned . keySet = null ; cloned . values = null ; cloned . modCount = 0 ; cloned . size = 0 ; MST[experimental.MemberVariableMutator]MSP[] cloned . init () ;
return key1 == key2 || key1 . equals ( key2 ) ; } protected boolean isEqualValue ( final Object value1 , final Object value2 ) { return value1 == value2 || value1 . equals ( value2 ) ; MST[rv.ROR3Mutator]MSP[] }
final HashEntry < K , V > oldEntries [] = data ; final HashEntry < K , V > newEntries [] = new HashEntry [ newCapacity ] ; modCount ++ ; MST[MathMutator]MSP[] for ( int i = oldCapacity - 1 ; i >= 0 ; i -- ) {
if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] final V oldValue = entry . getValue () ; removeMapping ( entry , index , previous ) ; return oldValue ; } previous = entry ; entry = entry . next ;
final HashEntry < K , V > oldEntries [] = data ; final HashEntry < K , V > newEntries [] = new HashEntry [ newCapacity ] ; modCount ++ ; MST[rv.AOR1Mutator]MSP[] for ( int i = oldCapacity - 1 ; i >= 0 ; i -- ) {
protected void removeMapping ( final HashEntry < K , V > entry , final int hashIndex , final HashEntry < K , V > previous ) { modCount ++ ; MST[rv.UOI4Mutator]MSP[] removeEntry ( entry , hashIndex , previous ) ; size -- ; destroyEntry ( entry ) ; }
data = new HashEntry [ capacity ] ; for ( int i = 0 ; i < size ; i ++ ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[] final K key = ( K ) in . readObject () ; final V value = ( V ) in . readObject () ;
if ( size >= threshold ) { final int newCapacity = data . length * 2 ; if ( newCapacity <= MAXIMUM_CAPACITY ) { ensureCapacity ( newCapacity ) ; MST[rv.UOI3Mutator]MSP[] } } } @SuppressWarnings ( lr_1 ) protected void ensureCapacity ( final int newCapacity ) {
protected Iterator < Map . Entry < K , V > > createEntrySetIterator () { if ( size () == 0 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return EmptyIterator . < Map . Entry < K , V > > emptyIterator () ; } return new EntrySetIterator <> ( this ) ; } @Override
} } catch ( final ClassCastException ignored ) { return false ; } catch ( final NullPointerException ignored ) { return false ; } return true ; } @Override public int hashCode () { int total = 0 ; MST[InlineConstantMutator]MSP[]
if ( size >= threshold ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] final int newCapacity = data . length * 2 ; if ( newCapacity <= MAXIMUM_CAPACITY ) { ensureCapacity ( newCapacity ) ; } } } @SuppressWarnings ( lr_1 ) protected void ensureCapacity ( final int newCapacity ) {
if ( size >= threshold ) { final int newCapacity = data . length * 2 ; if ( newCapacity <= MAXIMUM_CAPACITY ) { MST[rv.UOI1Mutator]MSP[] ensureCapacity ( newCapacity ) ; } } } @SuppressWarnings ( lr_1 ) protected void ensureCapacity ( final int newCapacity ) {
data = new HashEntry [ capacity ] ; MST[rv.UOI4Mutator]MSP[] for ( int i = 0 ; i < size ; i ++ ) { final K key = ( K ) in . readObject () ; final V value = ( V ) in . readObject () ;
key = convertKey ( key ) ; final int hashCode = hash ( key ) ; HashEntry < K , V > entry = data [ hashIndex ( hashCode , data . length ) ] ; MST[ArgumentPropagationMutator]MSP[] while ( entry != null ) {
return key1 == key2 || key1 . equals ( key2 ) ; MST[InlineConstantMutator]MSP[] } protected boolean isEqualValue ( final Object value1 , final Object value2 ) { return value1 == value2 || value1 . equals ( value2 ) ; }
newCapacity <<= 1 ; } if ( newCapacity > MAXIMUM_CAPACITY ) { newCapacity = MAXIMUM_CAPACITY ; } } return newCapacity ; MST[rv.ABSMutator]MSP[] } protected int calculateThreshold ( final int newCapacity , final float factor ) { return (int) ( newCapacity * factor ) ; }
protected void doReadObject ( final ObjectInputStream in ) throws IOException , ClassNotFoundException { loadFactor = in . readFloat () ; final int capacity = in . readInt () ; final int size = in . readInt () ; init () ; threshold = calculateThreshold ( capacity , loadFactor ) ; MST[rv.UOI2Mutator]MSP[]
private void _putAll ( final Map < ? extends K , ? extends V > map ) { final int mapSize = map . size () ; if ( mapSize == 0 ) { MST[rv.UOI3Mutator]MSP[] return; }
final int index = hashIndex ( entry . hashCode , newCapacity ) ; MST[rv.ABSMutator]MSP[] entry . next = newEntries [ index ] ; newEntries [ index ] = entry ; entry = next ; } while ( entry != null ); } }
final HashEntry < K , V > entry = createEntry ( data [ hashIndex ] , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; size ++ ; MST[rv.CRCR5Mutator]MSP[] checkCapacity () ; }
final HashEntry < K , V > oldEntries [] = data ; final HashEntry < K , V > newEntries [] = new HashEntry [ newCapacity ] ; modCount ++ ; for ( int i = oldCapacity - 1 ; i >= 0 ; i -- ) { MST[rv.CRCR2Mutator]MSP[]
final int index = hashIndex ( hashCode , data . length ) ; HashEntry < K , V > entry = data [ index ] ; MST[rv.UOI4Mutator]MSP[] HashEntry < K , V > previous = null ; while ( entry != null ) {
final Iterator < Map . Entry < K , V > > it = createEntrySetIterator () ; while ( it . hasNext () ) { MST[rv.ROR3Mutator]MSP[] total += it . next () . hashCode () ; } return total ; } @Override public String toString () {
final HashEntry < K , V > oldEntries [] = data ; final HashEntry < K , V > newEntries [] = new HashEntry [ newCapacity ] ; modCount ++ ; for ( int i = oldCapacity - 1 ; i >= 0 ; i -- ) { MST[IncrementsMutator]MSP[]
entry = entry . next ; } addMapping ( index , hashCode , key , value ) ; MST[rv.UOI3Mutator]MSP[] return null ; } @Override public void putAll ( final Map < ? extends K , ? extends V > map ) { _putAll ( map ) ; }
threshold = calculateThreshold ( newCapacity , loadFactor ) ; MST[rv.UOI3Mutator]MSP[] data = newEntries ; } } protected int calculateNewCapacity ( final int proposedCapacity ) { int newCapacity = 1 ; if ( proposedCapacity > MAXIMUM_CAPACITY ) { newCapacity = MAXIMUM_CAPACITY ; } else { while ( newCapacity < proposedCapacity ) {
protected void init () { } @Override public V get ( Object key ) { key = convertKey ( key ) ; MST[ArgumentPropagationMutator]MSP[] final int hashCode = hash ( key ) ;
protected Iterator < Map . Entry < K , V > > createEntrySetIterator () { if ( size () == 0 ) { return EmptyIterator . < Map . Entry < K , V > > emptyIterator () ; MST[ReturnValsMutator]MSP[] } return new EntrySetIterator <> ( this ) ; } @Override
protected void doReadObject ( final ObjectInputStream in ) throws IOException , ClassNotFoundException { loadFactor = in . readFloat () ; final int capacity = in . readInt () ; final int size = in . readInt () ; init () ; threshold = calculateThreshold ( capacity , loadFactor ) ; MST[experimental.MemberVariableMutator]MSP[]
HashEntry < K , V > entry = oldEntries [ i ] ; if ( entry != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] oldEntries [ i ] = null ; do { final HashEntry < K , V > next = entry . next ;
protected void removeMapping ( final HashEntry < K , V > entry , final int hashIndex , final HashEntry < K , V > previous ) { modCount ++ ; removeEntry ( entry , hashIndex , previous ) ; size -- ; MST[rv.CRCR3Mutator]MSP[] destroyEntry ( entry ) ; }
newCapacity <<= 1 ; } if ( newCapacity > MAXIMUM_CAPACITY ) { newCapacity = MAXIMUM_CAPACITY ; } } return newCapacity ; MST[rv.UOI2Mutator]MSP[] } protected int calculateThreshold ( final int newCapacity , final float factor ) { return (int) ( newCapacity * factor ) ; }
protected int hashIndex ( final int hashCode , final int dataSize ) { return hashCode & dataSize - 1 ; MST[rv.CRCR3Mutator]MSP[] } protected HashEntry < K , V > getEntry ( Object key ) { key = convertKey ( key ) ; final int hashCode = hash ( key ) ;
HashEntry < K , V > entry = data [ hashIndex ( hashCode , data . length ) ] ; MST[ArgumentPropagationMutator]MSP[] while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) {
protected void doReadObject ( final ObjectInputStream in ) throws IOException , ClassNotFoundException { loadFactor = in . readFloat () ; final int capacity = in . readInt () ; final int size = in . readInt () ; MST[NonVoidMethodCallMutator]MSP[] init () ; threshold = calculateThreshold ( capacity , loadFactor ) ;
if ( size >= threshold ) { final int newCapacity = data . length * 2 ; if ( newCapacity <= MAXIMUM_CAPACITY ) { ensureCapacity ( newCapacity ) ; } } } @SuppressWarnings ( lr_1 ) MST[NegateConditionalsMutator]MSP[] protected void ensureCapacity ( final int newCapacity ) {
return entry . getValue () ; } entry = entry . next ; } return null ; } @Override public int size () { return size ; MST[rv.UOI3Mutator]MSP[] } @Override public boolean isEmpty () { return size == 0 ; } @Override public boolean containsKey ( Object key ) {
if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { return true ; } entry = entry . next ; } return false ; MST[rv.CRCR5Mutator]MSP[] } @Override public boolean containsValue ( final Object value ) { if ( value == null ) {
HashEntry < K , V > entry = data [ hashIndex ( hashCode , data . length ) ] ; while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { MST[rv.ROR5Mutator]MSP[] return entry ; }
key = convertKey ( key ) ; final int hashCode = hash ( key ) ; HashEntry < K , V > entry = data [ hashIndex ( hashCode , data . length ) ] ; while ( entry != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
h += ~ ( h << 9 ) ; h ^= h >>> 14 ; MST[rv.UOI4Mutator]MSP[] h += h << 4 ; h ^= h >>> 10 ; return h ; } protected boolean isEqualKey ( final Object key1 , final Object key2 ) {
final int index = hashIndex ( entry . hashCode , newCapacity ) ; MST[rv.UOI2Mutator]MSP[] entry . next = newEntries [ index ] ; newEntries [ index ] = entry ; entry = next ; } while ( entry != null ); } }
h += ~ ( h << 9 ) ; MST[rv.CRCR6Mutator]MSP[] h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; return h ; } protected boolean isEqualKey ( final Object key1 , final Object key2 ) {
protected int hashIndex ( final int hashCode , final int dataSize ) { return hashCode & dataSize - 1 ; MST[rv.AOR4Mutator]MSP[] } protected HashEntry < K , V > getEntry ( Object key ) { key = convertKey ( key ) ; final int hashCode = hash ( key ) ;
threshold = calculateThreshold ( newCapacity , loadFactor ) ; data = newEntries ; } } protected int calculateNewCapacity ( final int proposedCapacity ) { int newCapacity = 1 ; if ( proposedCapacity > MAXIMUM_CAPACITY ) { MST[rv.ABSMutator]MSP[] newCapacity = MAXIMUM_CAPACITY ; } else { while ( newCapacity < proposedCapacity ) {
HashEntry < K , V > entry = data [ hashIndex ( hashCode , data . length ) ] ; while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { MST[NegateConditionalsMutator]MSP[] return entry ; }
final int newSize = (int) ( ( size + mapSize ) / loadFactor + 1 ) ; MST[MathMutator]MSP[] ensureCapacity ( calculateNewCapacity ( newSize ) ) ; for ( final Map . Entry < ? extends K , ? extends V > entry : map . entrySet () ) {
final HashEntry < K , V > oldEntries [] = data ; final HashEntry < K , V > newEntries [] = new HashEntry [ newCapacity ] ; modCount ++ ; for ( int i = oldCapacity - 1 ; i >= 0 ; i -- ) { MST[rv.ABSMutator]MSP[]
while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( convertedKey , entry . key ) ) { MST[rv.ABSMutator]MSP[] final V oldValue = entry . getValue () ; updateEntry ( entry , value ) ; return oldValue ; }
public Set < Map . Entry < K , V > > entrySet () { if ( entrySet == null ) { entrySet = new EntrySet <> ( this ) ; } return entrySet ; MST[ReturnValsMutator]MSP[] }
h += ~ ( h << 9 ) ; MST[rv.CRCR2Mutator]MSP[] h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; return h ; } protected boolean isEqualKey ( final Object key1 , final Object key2 ) {
HashEntry < K , V > entry = data [ hashIndex ( hashCode , data . length ) ] ; while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
final int index = hashIndex ( hashCode , data . length ) ; MST[rv.ABSMutator]MSP[] HashEntry < K , V > entry = data [ index ] ; HashEntry < K , V > previous = null ; while ( entry != null ) {
return entry . getValue () ; } entry = entry . next ; } return null ; } @Override public int size () { return size ; } @Override public boolean isEmpty () { return size == 0 ; MST[rv.CRCR6Mutator]MSP[] } @Override public boolean containsKey ( Object key ) {
final Iterator < Map . Entry < K , V > > it = createEntrySetIterator () ; while ( it . hasNext () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] total += it . next () . hashCode () ; } return total ; } @Override public String toString () {
if ( size >= threshold ) { final int newCapacity = data . length * 2 ; if ( newCapacity <= MAXIMUM_CAPACITY ) { ensureCapacity ( newCapacity ) ; } } } @SuppressWarnings ( lr_1 ) MST[rv.ROR5Mutator]MSP[] protected void ensureCapacity ( final int newCapacity ) {
} return null ; } @Override public void clear () { modCount ++ ; MST[MathMutator]MSP[] final HashEntry < K , V > [] data = this . data ; for ( int i = data . length - 1 ; i >= 0 ; i -- ) {
protected void removeEntry ( final HashEntry < K , V > entry , final int hashIndex , final HashEntry < K , V > previous ) { if ( previous == null ) { data [ hashIndex ] = entry . next ; MST[rv.UOI1Mutator]MSP[] } else {
final Iterator < Map . Entry < K , V > > it = createEntrySetIterator () ; while ( it . hasNext () ) { total += it . next () . hashCode () ; } return total ; MST[PrimitiveReturnsMutator]MSP[] } @Override public String toString () {
final Object convertedKey = convertKey ( key ) ; final int hashCode = hash ( convertedKey ) ; final int index = hashIndex ( hashCode , data . length ) ; MST[rv.UOI1Mutator]MSP[] HashEntry < K , V > entry = data [ index ] ;
final int index = hashIndex ( entry . hashCode , newCapacity ) ; entry . next = newEntries [ index ] ; newEntries [ index ] = entry ; MST[rv.UOI1Mutator]MSP[] entry = next ; } while ( entry != null ); } }
public Set < K > keySet () { if ( keySet == null ) { keySet = new KeySet <> ( this ) ; } return keySet ; } protected Iterator < K > createKeySetIterator () { if ( size () == 0 ) { MST[NegateConditionalsMutator]MSP[]
entry . key = key ; entry . value = value ; } protected void addMapping ( final int hashIndex , final int hashCode , final K key , final V value ) { modCount ++ ; MST[rv.UOI2Mutator]MSP[]
protected void removeEntry ( final HashEntry < K , V > entry , final int hashIndex , final HashEntry < K , V > previous ) { if ( previous == null ) { data [ hashIndex ] = entry . next ; MST[rv.ABSMutator]MSP[] } else {
} return null ; } @Override public void clear () { modCount ++ ; MST[rv.AOR4Mutator]MSP[] final HashEntry < K , V > [] data = this . data ; for ( int i = data . length - 1 ; i >= 0 ; i -- ) {
h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; MST[rv.ABSMutator]MSP[] h ^= h >>> 10 ; return h ; } protected boolean isEqualKey ( final Object key1 , final Object key2 ) {
final int oldCapacity = data . length ; if ( newCapacity <= oldCapacity ) { return; } if ( size == 0 ) { threshold = calculateThreshold ( newCapacity , loadFactor ) ; MST[rv.UOI1Mutator]MSP[] data = new HashEntry [ newCapacity ] ; } else {
protected void doWriteObject ( final ObjectOutputStream out ) throws IOException { out . writeFloat ( loadFactor ) ; out . writeInt ( data . length ) ; out . writeInt ( size ) ; MST[rv.UOI2Mutator]MSP[]
h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; MST[rv.AOD1Mutator]MSP[] h ^= h >>> 10 ; return h ; } protected boolean isEqualKey ( final Object key1 , final Object key2 ) {
key = convertKey ( key ) ; final int hashCode = hash ( key ) ; HashEntry < K , V > entry = data [ hashIndex ( hashCode , data . length ) ] ; MST[rv.UOI3Mutator]MSP[] while ( entry != null ) {
final MapIterator < ? , ? > it = mapIterator () ; try { while ( it . hasNext () ) { MST[rv.ROR3Mutator]MSP[] final Object key = it . next () ; final Object value = it . getValue () ; if ( value == null ) {
protected void removeMapping ( final HashEntry < K , V > entry , final int hashIndex , final HashEntry < K , V > previous ) { modCount ++ ; removeEntry ( entry , hashIndex , previous ) ; size -- ; destroyEntry ( entry ) ; MST[VoidMethodCallMutator]MSP[] }
if ( size () == 0 ) { MST[NegateConditionalsMutator]MSP[] return lr_6 ; } final StringBuilder buf = new StringBuilder ( 32 * size () ) ; buf . append ( '{' ) ; final MapIterator < K , V > it = mapIterator () ;
return key1 == key2 || key1 . equals ( key2 ) ; MST[rv.CRCR5Mutator]MSP[] } protected boolean isEqualValue ( final Object value1 , final Object value2 ) { return value1 == value2 || value1 . equals ( value2 ) ; }
if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return true ; } entry = entry . next ; } return false ; } @Override public boolean containsValue ( final Object value ) { if ( value == null ) {
final MapIterator < ? , ? > it = mapIterator () ; try { while ( it . hasNext () ) { MST[NonVoidMethodCallMutator]MSP[] final Object key = it . next () ; final Object value = it . getValue () ; if ( value == null ) {
threshold = calculateThreshold ( newCapacity , loadFactor ) ; data = newEntries ; } } protected int calculateNewCapacity ( final int proposedCapacity ) { int newCapacity = 1 ; if ( proposedCapacity > MAXIMUM_CAPACITY ) { MST[rv.UOI2Mutator]MSP[] newCapacity = MAXIMUM_CAPACITY ; } else { while ( newCapacity < proposedCapacity ) {
HashEntry < K , V > entry = data [ hashIndex ( hashCode , data . length ) ] ; while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return entry ; }
protected void removeMapping ( final HashEntry < K , V > entry , final int hashIndex , final HashEntry < K , V > previous ) { modCount ++ ; removeEntry ( entry , hashIndex , previous ) ; size -- ; MST[rv.UOI3Mutator]MSP[] destroyEntry ( entry ) ; }
cloned . data = new HashEntry [ data . length ] ; cloned . entrySet = null ; cloned . keySet = null ; cloned . values = null ; cloned . modCount = 0 ; MST[experimental.MemberVariableMutator]MSP[] cloned . size = 0 ; cloned . init () ;
final HashEntry < K , V > oldEntries [] = data ; final HashEntry < K , V > newEntries [] = new HashEntry [ newCapacity ] ; modCount ++ ; for ( int i = oldCapacity - 1 ; i >= 0 ; i -- ) { MST[NegateConditionalsMutator]MSP[]
final int index = hashIndex ( hashCode , data . length ) ; MST[rv.UOI2Mutator]MSP[] HashEntry < K , V > entry = data [ index ] ; HashEntry < K , V > previous = null ; while ( entry != null ) {
final Object convertedKey = convertKey ( key ) ; final int hashCode = hash ( convertedKey ) ; final int index = hashIndex ( hashCode , data . length ) ; MST[NonVoidMethodCallMutator]MSP[] HashEntry < K , V > entry = data [ index ] ;
final HashEntry < K , V > oldEntries [] = data ; final HashEntry < K , V > newEntries [] = new HashEntry [ newCapacity ] ; modCount ++ ; for ( int i = oldCapacity - 1 ; i >= 0 ; i -- ) { MST[rv.UOI2Mutator]MSP[]
entry . key = key ; entry . value = value ; } protected void addMapping ( final int hashIndex , final int hashCode , final K key , final V value ) { modCount ++ ; MST[rv.CRCR6Mutator]MSP[]
final int oldCapacity = data . length ; if ( newCapacity <= oldCapacity ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[] return; } if ( size == 0 ) { threshold = calculateThreshold ( newCapacity , loadFactor ) ; data = new HashEntry [ newCapacity ] ; } else {
public Set < K > keySet () { if ( keySet == null ) { keySet = new KeySet <> ( this ) ; } return keySet ; } protected Iterator < K > createKeySetIterator () { if ( size () == 0 ) { MST[rv.ROR5Mutator]MSP[]
return key1 == key2 || key1 . equals ( key2 ) ; MST[rv.ROR5Mutator]MSP[] } protected boolean isEqualValue ( final Object value1 , final Object value2 ) { return value1 == value2 || value1 . equals ( value2 ) ; }
final Iterator < Map . Entry < K , V > > it = createEntrySetIterator () ; while ( it . hasNext () ) { total += it . next () . hashCode () ; MST[rv.AOR4Mutator]MSP[] } return total ; } @Override public String toString () {
} return null ; } @Override public void clear () { modCount ++ ; MST[rv.UOI3Mutator]MSP[] final HashEntry < K , V > [] data = this . data ; for ( int i = data . length - 1 ; i >= 0 ; i -- ) {
protected void doReadObject ( final ObjectInputStream in ) throws IOException , ClassNotFoundException { loadFactor = in . readFloat () ; final int capacity = in . readInt () ; final int size = in . readInt () ; init () ; threshold = calculateThreshold ( capacity , loadFactor ) ; MST[rv.ABSMutator]MSP[]
return entry . getValue () ; } entry = entry . next ; } return null ; } @Override public int size () { return size ; } @Override public boolean isEmpty () { return size == 0 ; MST[rv.CRCR3Mutator]MSP[] } @Override public boolean containsKey ( Object key ) {
h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; return h ; MST[ReturnValsMutator]MSP[] } protected boolean isEqualKey ( final Object key1 , final Object key2 ) {
protected int hashIndex ( final int hashCode , final int dataSize ) { return hashCode & dataSize - 1 ; MST[MathMutator]MSP[] } protected HashEntry < K , V > getEntry ( Object key ) { key = convertKey ( key ) ; final int hashCode = hash ( key ) ;
HashEntry < K , V > entry = data [ hashIndex ( hashCode , data . length ) ] ; while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { MST[rv.UOI4Mutator]MSP[] return entry ; }
cloned . data = new HashEntry [ data . length ] ; cloned . entrySet = null ; cloned . keySet = null ; cloned . values = null ; cloned . modCount = 0 ; MST[rv.CRCR6Mutator]MSP[] cloned . size = 0 ; cloned . init () ;
h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; MST[InlineConstantMutator]MSP[] h ^= h >>> 10 ; return h ; } protected boolean isEqualKey ( final Object key1 , final Object key2 ) {
if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { return true ; } entry = entry . next ; } return false ; MST[rv.CRCR1Mutator]MSP[] } @Override public boolean containsValue ( final Object value ) { if ( value == null ) {
final int newSize = (int) ( ( size + mapSize ) / loadFactor + 1 ) ; MST[rv.AOR3Mutator]MSP[] ensureCapacity ( calculateNewCapacity ( newSize ) ) ; for ( final Map . Entry < ? extends K , ? extends V > entry : map . entrySet () ) {
for ( final MapIterator < K , V > it = mapIterator () ; it . hasNext () ; ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] out . writeObject ( it . next () ) ; out . writeObject ( it . getValue () ) ; } } @SuppressWarnings ( lr_1 )
if ( size >= threshold ) { final int newCapacity = data . length * 2 ; if ( newCapacity <= MAXIMUM_CAPACITY ) { MST[rv.ROR2Mutator]MSP[] ensureCapacity ( newCapacity ) ; } } } @SuppressWarnings ( lr_1 ) protected void ensureCapacity ( final int newCapacity ) {
if ( size >= threshold ) { final int newCapacity = data . length * 2 ; if ( newCapacity <= MAXIMUM_CAPACITY ) { MST[rv.ROR5Mutator]MSP[] ensureCapacity ( newCapacity ) ; } } } @SuppressWarnings ( lr_1 ) protected void ensureCapacity ( final int newCapacity ) {
protected void doReadObject ( final ObjectInputStream in ) throws IOException , ClassNotFoundException { loadFactor = in . readFloat () ; final int capacity = in . readInt () ; final int size = in . readInt () ; init () ; threshold = calculateThreshold ( capacity , loadFactor ) ; MST[ArgumentPropagationMutator]MSP[]
newCapacity <<= 1 ; } if ( newCapacity > MAXIMUM_CAPACITY ) { newCapacity = MAXIMUM_CAPACITY ; } } return newCapacity ; } protected int calculateThreshold ( final int newCapacity , final float factor ) { return (int) ( newCapacity * factor ) ; MST[MathMutator]MSP[] }
HashEntry < K , V > entry = data [ hashIndex ( hashCode , data . length ) ] ; MST[rv.UOI4Mutator]MSP[] while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) {
newCapacity <<= 1 ; } if ( newCapacity > MAXIMUM_CAPACITY ) { newCapacity = MAXIMUM_CAPACITY ; } } return newCapacity ; } protected int calculateThreshold ( final int newCapacity , final float factor ) { return (int) ( newCapacity * factor ) ; MST[rv.AOR4Mutator]MSP[] }
if ( size >= threshold ) { MST[rv.UOI1Mutator]MSP[] final int newCapacity = data . length * 2 ; if ( newCapacity <= MAXIMUM_CAPACITY ) { ensureCapacity ( newCapacity ) ; } } } @SuppressWarnings ( lr_1 ) protected void ensureCapacity ( final int newCapacity ) {
final Iterator < Map . Entry < K , V > > it = createEntrySetIterator () ; while ( it . hasNext () ) { total += it . next () . hashCode () ; MST[rv.AOR1Mutator]MSP[] } return total ; } @Override public String toString () {
if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { return true ; MST[ReturnValsMutator]MSP[] } entry = entry . next ; } return false ; } @Override public boolean containsValue ( final Object value ) { if ( value == null ) {
private void _putAll ( final Map < ? extends K , ? extends V > map ) { final int mapSize = map . size () ; if ( mapSize == 0 ) { MST[rv.ROR4Mutator]MSP[] return; }
final int newSize = (int) ( ( size + mapSize ) / loadFactor + 1 ) ; MST[rv.UOI2Mutator]MSP[] ensureCapacity ( calculateNewCapacity ( newSize ) ) ; for ( final Map . Entry < ? extends K , ? extends V > entry : map . entrySet () ) {
final HashEntry < K , V > oldEntries [] = data ; final HashEntry < K , V > newEntries [] = new HashEntry [ newCapacity ] ; modCount ++ ; for ( int i = oldCapacity - 1 ; i >= 0 ; i -- ) { MST[rv.AOD2Mutator]MSP[]
} return null ; } @Override public void clear () { modCount ++ ; final HashEntry < K , V > [] data = this . data ; for ( int i = data . length - 1 ; i >= 0 ; i -- ) { MST[ConditionalsBoundaryMutator]MSP[]
final HashEntry < K , V > entry = createEntry ( data [ hashIndex ] , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; size ++ ; MST[rv.CRCR2Mutator]MSP[] checkCapacity () ; }
final int oldCapacity = data . length ; if ( newCapacity <= oldCapacity ) { MST[rv.ROR4Mutator]MSP[] return; } if ( size == 0 ) { threshold = calculateThreshold ( newCapacity , loadFactor ) ; data = new HashEntry [ newCapacity ] ; } else {
while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( convertedKey , entry . key ) ) { MST[rv.UOI1Mutator]MSP[] final V oldValue = entry . getValue () ; updateEntry ( entry , value ) ; return oldValue ; }
protected void removeMapping ( final HashEntry < K , V > entry , final int hashIndex , final HashEntry < K , V > previous ) { modCount ++ ; removeEntry ( entry , hashIndex , previous ) ; MST[rv.ABSMutator]MSP[] size -- ; destroyEntry ( entry ) ; }
if ( obj instanceof Map == false ) { MST[rv.ROR2Mutator]MSP[] return false ; } final Map < ? , ? > map = ( Map < ? , ? > ) obj ; if ( map . size () != size () ) { return false ; }
for ( final MapIterator < K , V > it = mapIterator () ; it . hasNext () ; ) { out . writeObject ( it . next () ) ; out . writeObject ( it . getValue () ) ; MST[NonVoidMethodCallMutator]MSP[] } } @SuppressWarnings ( lr_1 )
final HashEntry < K , V > oldEntries [] = data ; final HashEntry < K , V > newEntries [] = new HashEntry [ newCapacity ] ; modCount ++ ; MST[rv.UOI3Mutator]MSP[] for ( int i = oldCapacity - 1 ; i >= 0 ; i -- ) {
protected void doWriteObject ( final ObjectOutputStream out ) throws IOException { out . writeFloat ( loadFactor ) ; MST[rv.UOI2Mutator]MSP[] out . writeInt ( data . length ) ; out . writeInt ( size ) ;
if ( obj instanceof Map == false ) { return false ; } final Map < ? , ? > map = ( Map < ? , ? > ) obj ; if ( map . size () != size () ) { MST[rv.ROR2Mutator]MSP[] return false ; }
if ( size >= threshold ) { MST[rv.UOI4Mutator]MSP[] final int newCapacity = data . length * 2 ; if ( newCapacity <= MAXIMUM_CAPACITY ) { ensureCapacity ( newCapacity ) ; } } } @SuppressWarnings ( lr_1 ) protected void ensureCapacity ( final int newCapacity ) {
if ( size () == 0 ) { MST[rv.ROR1Mutator]MSP[] return lr_6 ; } final StringBuilder buf = new StringBuilder ( 32 * size () ) ; buf . append ( '{' ) ; final MapIterator < K , V > it = mapIterator () ;
newCapacity <<= 1 ; } if ( newCapacity > MAXIMUM_CAPACITY ) { MST[ConditionalsBoundaryMutator]MSP[] newCapacity = MAXIMUM_CAPACITY ; } } return newCapacity ; } protected int calculateThreshold ( final int newCapacity , final float factor ) { return (int) ( newCapacity * factor ) ; }
if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { MST[rv.ABSMutator]MSP[] return true ; } entry = entry . next ; } return false ; } @Override public boolean containsValue ( final Object value ) { if ( value == null ) {
final int index = hashIndex ( entry . hashCode , newCapacity ) ; MST[rv.UOI1Mutator]MSP[] entry . next = newEntries [ index ] ; newEntries [ index ] = entry ; entry = next ; } while ( entry != null ); } }
while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( convertedKey , entry . key ) ) { final V oldValue = entry . getValue () ; updateEntry ( entry , value ) ; MST[VoidMethodCallMutator]MSP[] return oldValue ; }
threshold = calculateThreshold ( newCapacity , loadFactor ) ; data = newEntries ; } } protected int calculateNewCapacity ( final int proposedCapacity ) { int newCapacity = 1 ; if ( proposedCapacity > MAXIMUM_CAPACITY ) { newCapacity = MAXIMUM_CAPACITY ; } else { while ( newCapacity < proposedCapacity ) { MST[rv.UOI3Mutator]MSP[]
entry = entry . next ; } addMapping ( index , hashCode , key , value ) ; return null ; } @Override public void putAll ( final Map < ? extends K , ? extends V > map ) { _putAll ( map ) ; MST[VoidMethodCallMutator]MSP[] }
if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { MST[rv.UOI4Mutator]MSP[] return true ; } entry = entry . next ; } return false ; } @Override public boolean containsValue ( final Object value ) { if ( value == null ) {
protected Iterator < Map . Entry < K , V > > createEntrySetIterator () { if ( size () == 0 ) { MST[rv.ROR4Mutator]MSP[] return EmptyIterator . < Map . Entry < K , V > > emptyIterator () ; } return new EntrySetIterator <> ( this ) ; } @Override
data [ i ] = null ; MST[rv.ABSMutator]MSP[] } size = 0 ; } protected Object convertKey ( final Object key ) { return key == null ? NULL : key ; } protected int hash ( final Object key ) { int h = key . hashCode () ;
} return null ; } @Override public void clear () { modCount ++ ; MST[rv.CRCR3Mutator]MSP[] final HashEntry < K , V > [] data = this . data ; for ( int i = data . length - 1 ; i >= 0 ; i -- ) {
while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( convertedKey , entry . key ) ) { MST[NegateConditionalsMutator]MSP[] final V oldValue = entry . getValue () ; updateEntry ( entry , value ) ; return oldValue ; }
h += ~ ( h << 9 ) ; h ^= h >>> 14 ; MST[rv.CRCR1Mutator]MSP[] h += h << 4 ; h ^= h >>> 10 ; return h ; } protected boolean isEqualKey ( final Object key1 , final Object key2 ) {
return EmptyIterator . <K > emptyIterator () ; } return new KeySetIterator <> ( this ) ; MST[ConstructorCallMutator]MSP[] } @Override public int size () { return parent . size () ; } @Override public void clear () { parent . clear () ; } @Override
HashEntry < K , V > entry = data [ hashIndex ( hashCode , data . length ) ] ; MST[rv.UOI3Mutator]MSP[] while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { return entry ; }
h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; MST[rv.CRCR5Mutator]MSP[] h ^= h >>> 10 ; return h ; } protected boolean isEqualKey ( final Object key1 , final Object key2 ) {
public MapIterator < K , V > mapIterator () { if ( size == 0 ) { return EmptyMapIterator . <K , V > emptyMapIterator () ; MST[NullReturnValsMutator]MSP[] } return new HashMapIterator <> ( this ) ; } @Override public K next () {
for ( final MapIterator < K , V > it = mapIterator () ; it . hasNext () ; ) { MST[NonVoidMethodCallMutator]MSP[] out . writeObject ( it . next () ) ; out . writeObject ( it . getValue () ) ; } } @SuppressWarnings ( lr_1 )
h += ~ ( h << 9 ) ; MST[rv.AOR4Mutator]MSP[] h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; return h ; } protected boolean isEqualKey ( final Object key1 , final Object key2 ) {
return entry . getValue () ; } entry = entry . next ; } return null ; MST[ReturnValsMutator]MSP[] } @Override public int size () { return size ; } @Override public boolean isEmpty () { return size == 0 ; } @Override public boolean containsKey ( Object key ) {
h += ~ ( h << 9 ) ; h ^= h >>> 14 ; MST[rv.UOI1Mutator]MSP[] h += h << 4 ; h ^= h >>> 10 ; return h ; } protected boolean isEqualKey ( final Object key1 , final Object key2 ) {
final MapIterator < ? , ? > it = mapIterator () ; try { while ( it . hasNext () ) { final Object key = it . next () ; final Object value = it . getValue () ; if ( value == null ) { MST[rv.ROR5Mutator]MSP[]
return key1 == key2 || key1 . equals ( key2 ) ; MST[rv.CRCR5Mutator]MSP[] } protected boolean isEqualValue ( final Object value1 , final Object value2 ) { return value1 == value2 || value1 . equals ( value2 ) ; }
h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; MST[rv.UOI2Mutator]MSP[] h ^= h >>> 10 ; return h ; } protected boolean isEqualKey ( final Object key1 , final Object key2 ) {
protected void removeMapping ( final HashEntry < K , V > entry , final int hashIndex , final HashEntry < K , V > previous ) { modCount ++ ; removeEntry ( entry , hashIndex , previous ) ; size -- ; MST[MathMutator]MSP[] destroyEntry ( entry ) ; }
h += ~ ( h << 9 ) ; h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; return h ; MST[rv.UOI3Mutator]MSP[] } protected boolean isEqualKey ( final Object key1 , final Object key2 ) {
while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( convertedKey , entry . key ) ) { MST[rv.ROR5Mutator]MSP[] final V oldValue = entry . getValue () ; updateEntry ( entry , value ) ; return oldValue ; }
if ( size >= threshold ) { final int newCapacity = data . length * 2 ; MST[MathMutator]MSP[] if ( newCapacity <= MAXIMUM_CAPACITY ) { ensureCapacity ( newCapacity ) ; } } } @SuppressWarnings ( lr_1 ) protected void ensureCapacity ( final int newCapacity ) {
final Object convertedKey = convertKey ( key ) ; final int hashCode = hash ( convertedKey ) ; final int index = hashIndex ( hashCode , data . length ) ; HashEntry < K , V > entry = data [ index ] ; MST[rv.UOI3Mutator]MSP[]
protected void removeMapping ( final HashEntry < K , V > entry , final int hashIndex , final HashEntry < K , V > previous ) { modCount ++ ; removeEntry ( entry , hashIndex , previous ) ; size -- ; MST[experimental.MemberVariableMutator]MSP[] destroyEntry ( entry ) ; }
final int oldCapacity = data . length ; if ( newCapacity <= oldCapacity ) { return; } if ( size == 0 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] threshold = calculateThreshold ( newCapacity , loadFactor ) ; data = new HashEntry [ newCapacity ] ; } else {
return entry . getValue () ; } entry = entry . next ; } return null ; } @Override public int size () { return size ; } @Override public boolean isEmpty () { return size == 0 ; MST[rv.CRCR3Mutator]MSP[] } @Override public boolean containsKey ( Object key ) {
h += ~ ( h << 9 ) ; MST[rv.UOI2Mutator]MSP[] h ^= h >>> 14 ; h += h << 4 ; h ^= h >>> 10 ; return h ; } protected boolean isEqualKey ( final Object key1 , final Object key2 ) {
} return null ; } @Override public void clear () { modCount ++ ; final HashEntry < K , V > [] data = this . data ; for ( int i = data . length - 1 ; i >= 0 ; i -- ) { MST[rv.AOR1Mutator]MSP[]
final HashEntry < K , V > oldEntries [] = data ; final HashEntry < K , V > newEntries [] = new HashEntry [ newCapacity ] ; MST[rv.UOI2Mutator]MSP[] modCount ++ ; for ( int i = oldCapacity - 1 ; i >= 0 ; i -- ) {
if ( isEqualValue ( value , entry . getValue () ) ) { MST[rv.ROR4Mutator]MSP[] return true ; } entry = entry . next ; } } } return false ; } @Override public V put ( final K key , final V value ) {
final HashEntry < K , V > entry = createEntry ( data [ hashIndex ] , hashCode , key , value ) ; MST[NonVoidMethodCallMutator]MSP[] addEntry ( entry , hashIndex ) ; size ++ ; checkCapacity () ; }
if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { final V oldValue = entry . getValue () ; removeMapping ( entry , index , previous ) ; MST[rv.ABSMutator]MSP[] return oldValue ; } previous = entry ; entry = entry . next ;
protected void reuseEntry ( final HashEntry < K , V > entry , final int hashIndex , final int hashCode , final K key , final V value ) { entry . next = data [ hashIndex ] ; entry . hashCode = hashCode ; MST[rv.UOI2Mutator]MSP[]
for ( final MapIterator < K , V > it = mapIterator () ; it . hasNext () ; ) { MST[rv.ROR2Mutator]MSP[] out . writeObject ( it . next () ) ; out . writeObject ( it . getValue () ) ; } } @SuppressWarnings ( lr_1 )
if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { return true ; } entry = entry . next ; } return false ; MST[InlineConstantMutator]MSP[] } @Override public boolean containsValue ( final Object value ) { if ( value == null ) {
final HashEntry < K , V > oldEntries [] = data ; final HashEntry < K , V > newEntries [] = new HashEntry [ newCapacity ] ; modCount ++ ; for ( int i = oldCapacity - 1 ; i >= 0 ; i -- ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[]
entry = entry . next ; } return null ; MST[ReturnValsMutator]MSP[] } protected void updateEntry ( final HashEntry < K , V > entry , final V newValue ) { entry . setValue ( newValue ) ; }
final int newSize = (int) ( ( size + mapSize ) / loadFactor + 1 ) ; MST[rv.AOR3Mutator]MSP[] ensureCapacity ( calculateNewCapacity ( newSize ) ) ; for ( final Map . Entry < ? extends K , ? extends V > entry : map . entrySet () ) {
final HashEntry < K , V > oldEntries [] = data ; final HashEntry < K , V > newEntries [] = new HashEntry [ newCapacity ] ; modCount ++ ; MST[rv.AOR4Mutator]MSP[] for ( int i = oldCapacity - 1 ; i >= 0 ; i -- ) {
HashEntry < K , V > entry = oldEntries [ i ] ; if ( entry != null ) { oldEntries [ i ] = null ; MST[rv.UOI2Mutator]MSP[] do { final HashEntry < K , V > next = entry . next ;
entry . key = key ; entry . value = value ; } protected void addMapping ( final int hashIndex , final int hashCode , final K key , final V value ) { modCount ++ ; MST[rv.AOR3Mutator]MSP[]
public Set < Map . Entry < K , V > > entrySet () { if ( entrySet == null ) { entrySet = new EntrySet <> ( this ) ; MST[ConstructorCallMutator]MSP[] } return entrySet ; }
if ( map . get ( key ) != null || map . containsKey ( key ) == false ) { return false ; } } else { if ( value . equals ( map . get ( key ) ) == false ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return false ; } }
final HashEntry < K , V > oldEntries [] = data ; final HashEntry < K , V > newEntries [] = new HashEntry [ newCapacity ] ; modCount ++ ; for ( int i = oldCapacity - 1 ; i >= 0 ; i -- ) { MST[rv.ROR5Mutator]MSP[]
protected int hashIndex ( final int hashCode , final int dataSize ) { return hashCode & dataSize - 1 ; MST[rv.UOI3Mutator]MSP[] } protected HashEntry < K , V > getEntry ( Object key ) { key = convertKey ( key ) ; final int hashCode = hash ( key ) ;
cloned . putAll ( this ) ; return cloned ; } catch ( final CloneNotSupportedException ex ) { throw new InternalError () ; } } @Override public boolean equals ( final Object obj ) { if ( obj == this ) { return true ; MST[rv.CRCR3Mutator]MSP[] }
if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { MST[rv.ABSMutator]MSP[] final V oldValue = entry . getValue () ; removeMapping ( entry , index , previous ) ; return oldValue ; } previous = entry ; entry = entry . next ;
cloned . putAll ( this ) ; return cloned ; MST[ReturnValsMutator]MSP[] } catch ( final CloneNotSupportedException ex ) { throw new InternalError () ; } } @Override public boolean equals ( final Object obj ) { if ( obj == this ) { return true ; }
return key1 == key2 || key1 . equals ( key2 ) ; MST[NegateConditionalsMutator]MSP[] } protected boolean isEqualValue ( final Object value1 , final Object value2 ) { return value1 == value2 || value1 . equals ( value2 ) ; }
if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { return true ; MST[BooleanFalseReturnValsMutator]MSP[] } entry = entry . next ; } return false ; } @Override public boolean containsValue ( final Object value ) { if ( value == null ) {
if ( size >= threshold ) { final int newCapacity = data . length * 2 ; if ( newCapacity <= MAXIMUM_CAPACITY ) { MST[rv.ABSMutator]MSP[] ensureCapacity ( newCapacity ) ; } } } @SuppressWarnings ( lr_1 ) protected void ensureCapacity ( final int newCapacity ) {
if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { MST[rv.ROR2Mutator]MSP[] return true ; } entry = entry . next ; } return false ; } @Override public boolean containsValue ( final Object value ) { if ( value == null ) {
newCapacity <<= 1 ; } if ( newCapacity > MAXIMUM_CAPACITY ) { MST[rv.UOI3Mutator]MSP[] newCapacity = MAXIMUM_CAPACITY ; } } return newCapacity ; } protected int calculateThreshold ( final int newCapacity , final float factor ) { return (int) ( newCapacity * factor ) ; }
data = new HashEntry [ capacity ] ; for ( int i = 0 ; i < size ; i ++ ) { final K key = ( K ) in . readObject () ; final V value = ( V ) in . readObject () ; MST[NonVoidMethodCallMutator]MSP[]
if ( size >= threshold ) { final int newCapacity = data . length * 2 ; MST[rv.CRCR3Mutator]MSP[] if ( newCapacity <= MAXIMUM_CAPACITY ) { ensureCapacity ( newCapacity ) ; } } } @SuppressWarnings ( lr_1 ) protected void ensureCapacity ( final int newCapacity ) {
if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { return true ; MST[rv.CRCR4Mutator]MSP[] } entry = entry . next ; } return false ; } @Override public boolean containsValue ( final Object value ) { if ( value == null ) {
if ( size >= threshold ) { final int newCapacity = data . length * 2 ; if ( newCapacity <= MAXIMUM_CAPACITY ) { MST[rv.CRCR5Mutator]MSP[] ensureCapacity ( newCapacity ) ; } } } @SuppressWarnings ( lr_1 ) protected void ensureCapacity ( final int newCapacity ) {
protected void removeMapping ( final HashEntry < K , V > entry , final int hashIndex , final HashEntry < K , V > previous ) { modCount ++ ; MST[InlineConstantMutator]MSP[] removeEntry ( entry , hashIndex , previous ) ; size -- ; destroyEntry ( entry ) ; }
final int newSize = (int) ( ( size + mapSize ) / loadFactor + 1 ) ; MST[rv.ABSMutator]MSP[] ensureCapacity ( calculateNewCapacity ( newSize ) ) ; for ( final Map . Entry < ? extends K , ? extends V > entry : map . entrySet () ) {
return key1 == key2 || key1 . equals ( key2 ) ; } protected boolean isEqualValue ( final Object value1 , final Object value2 ) { return value1 == value2 || value1 . equals ( value2 ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] }
public boolean contains ( final Object key ) { return parent . containsKey ( key ) ; MST[BooleanTrueReturnValsMutator]MSP[] } @Override public boolean remove ( final Object key ) { final boolean result = parent . containsKey ( key ) ; parent . remove ( key ) ; return result ; }
public boolean contains ( final Object key ) { return parent . containsKey ( key ) ; } @Override public boolean remove ( final Object key ) { final boolean result = parent . containsKey ( key ) ; parent . remove ( key ) ; return result ; MST[BooleanFalseReturnValsMutator]MSP[] }
public boolean contains ( final Object key ) { return parent . containsKey ( key ) ; MST[ReturnValsMutator]MSP[] } @Override public boolean remove ( final Object key ) { final boolean result = parent . containsKey ( key ) ; parent . remove ( key ) ; return result ; }
@Override public Iterator < K > iterator () { return parent . createKeySetIterator () ; MST[NonVoidMethodCallMutator]MSP[] } @Override public K next () { return super . nextEntry () . getKey () ; } @Override public Collection < V > values () { if ( values == null ) {
public boolean contains ( final Object key ) { return parent . containsKey ( key ) ; MST[NonVoidMethodCallMutator]MSP[] } @Override public boolean remove ( final Object key ) { final boolean result = parent . containsKey ( key ) ; parent . remove ( key ) ; return result ; }
return EmptyIterator . <K > emptyIterator () ; } return new KeySetIterator <> ( this ) ; } @Override public int size () { return parent . size () ; MST[ReturnValsMutator]MSP[] } @Override public void clear () { parent . clear () ; } @Override
public boolean contains ( final Object key ) { return parent . containsKey ( key ) ; } @Override public boolean remove ( final Object key ) { final boolean result = parent . containsKey ( key ) ; parent . remove ( key ) ; return result ; MST[rv.ABSMutator]MSP[] }
@Override public Iterator < K > iterator () { return parent . createKeySetIterator () ; MST[ReturnValsMutator]MSP[] } @Override public K next () { return super . nextEntry () . getKey () ; } @Override public Collection < V > values () { if ( values == null ) {
@Override public Iterator < K > iterator () { return parent . createKeySetIterator () ; MST[NullReturnValsMutator]MSP[] } @Override public K next () { return super . nextEntry () . getKey () ; } @Override public Collection < V > values () { if ( values == null ) {
public boolean contains ( final Object key ) { return parent . containsKey ( key ) ; MST[BooleanFalseReturnValsMutator]MSP[] } @Override public boolean remove ( final Object key ) { final boolean result = parent . containsKey ( key ) ; parent . remove ( key ) ; return result ; }
return EmptyIterator . <K > emptyIterator () ; } return new KeySetIterator <> ( this ) ; } @Override public int size () { return parent . size () ; MST[PrimitiveReturnsMutator]MSP[] } @Override public void clear () { parent . clear () ; } @Override
public boolean contains ( final Object key ) { return parent . containsKey ( key ) ; } @Override public boolean remove ( final Object key ) { final boolean result = parent . containsKey ( key ) ; MST[NonVoidMethodCallMutator]MSP[] parent . remove ( key ) ; return result ; }
public boolean contains ( final Object key ) { return parent . containsKey ( key ) ; } @Override public boolean remove ( final Object key ) { final boolean result = parent . containsKey ( key ) ; parent . remove ( key ) ; return result ; MST[BooleanTrueReturnValsMutator]MSP[] }
public boolean contains ( final Object key ) { return parent . containsKey ( key ) ; } @Override public boolean remove ( final Object key ) { final boolean result = parent . containsKey ( key ) ; parent . remove ( key ) ; return result ; MST[ReturnValsMutator]MSP[] }
public boolean contains ( final Object key ) { return parent . containsKey ( key ) ; } @Override public boolean remove ( final Object key ) { final boolean result = parent . containsKey ( key ) ; parent . remove ( key ) ; return result ; MST[rv.UOI3Mutator]MSP[] }
public boolean contains ( final Object key ) { return parent . containsKey ( key ) ; } @Override public boolean remove ( final Object key ) { final boolean result = parent . containsKey ( key ) ; parent . remove ( key ) ; return result ; MST[rv.UOI4Mutator]MSP[] }
public boolean contains ( final Object key ) { return parent . containsKey ( key ) ; } @Override public boolean remove ( final Object key ) { final boolean result = parent . containsKey ( key ) ; parent . remove ( key ) ; return result ; MST[rv.UOI2Mutator]MSP[] }
public boolean contains ( final Object key ) { return parent . containsKey ( key ) ; } @Override public boolean remove ( final Object key ) { final boolean result = parent . containsKey ( key ) ; parent . remove ( key ) ; return result ; MST[rv.UOI1Mutator]MSP[] }
return EmptyIterator . <K > emptyIterator () ; } return new KeySetIterator <> ( this ) ; } @Override public int size () { return parent . size () ; MST[NonVoidMethodCallMutator]MSP[] } @Override public void clear () { parent . clear () ; } @Override
public boolean contains ( final Object key ) { return parent . containsKey ( key ) ; } @Override public boolean remove ( final Object key ) { final boolean result = parent . containsKey ( key ) ; parent . remove ( key ) ; MST[NonVoidMethodCallMutator]MSP[] return result ; }
public boolean contains ( final Object key ) { return parent . containsKey ( key ) ; } @Override public boolean remove ( final Object key ) { final boolean result = parent . containsKey ( key ) ; parent . remove ( key ) ; MST[ArgumentPropagationMutator]MSP[] return result ; }
} @Override public Iterator < Map . Entry < K , V > > iterator () { return parent . createEntrySetIterator () ; MST[ReturnValsMutator]MSP[] } @Override public Map . Entry < K , V > next () { return super . nextEntry () ; } @Override
} @Override public Iterator < Map . Entry < K , V > > iterator () { return parent . createEntrySetIterator () ; MST[NonVoidMethodCallMutator]MSP[] } @Override public Map . Entry < K , V > next () { return super . nextEntry () ; } @Override
} @Override public Iterator < Map . Entry < K , V > > iterator () { return parent . createEntrySetIterator () ; MST[NullReturnValsMutator]MSP[] } @Override public Map . Entry < K , V > next () { return super . nextEntry () ; } @Override
public boolean hasNext () { return next != null ; } protected HashEntry < K , V > nextEntry () { if ( parent . modCount != expectedModCount ) { MST[rv.UOI1Mutator]MSP[] throw new ConcurrentModificationException () ; } final HashEntry < K , V > newCurrent = next ;
public void remove () { if ( last == null ) { throw new IllegalStateException ( AbstractHashedMap . REMOVE_INVALID ) ; MST[ConstructorCallMutator]MSP[] } if ( parent . modCount != expectedModCount ) { throw new ConcurrentModificationException () ; } parent . remove ( last . getKey () ) ;
if ( newCurrent == null ) { MST[NegateConditionalsMutator]MSP[] throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } final HashEntry < K , V > [] data = parent . data ; int i = hashIndex ; HashEntry < K , V > n = newCurrent . next ;
public boolean hasNext () { return next != null ; MST[ReturnValsMutator]MSP[] } protected HashEntry < K , V > nextEntry () { if ( parent . modCount != expectedModCount ) { throw new ConcurrentModificationException () ; } final HashEntry < K , V > newCurrent = next ;
last = null ; expectedModCount = parent . modCount ; MST[rv.UOI1Mutator]MSP[] } @Override public String toString () { if ( last != null ) { return lr_2 + last . getKey () + lr_3 + last . getValue () + lr_4 ; } return lr_5 ; }
while ( n == null && i > 0 ) { MST[rv.UOI2Mutator]MSP[] n = data [ -- i ] ; } next = n ; hashIndex = i ; last = newCurrent ; return newCurrent ; } protected HashEntry < K , V > currentEntry () { return last ; }
public boolean hasNext () { return next != null ; } protected HashEntry < K , V > nextEntry () { if ( parent . modCount != expectedModCount ) { MST[rv.UOI3Mutator]MSP[] throw new ConcurrentModificationException () ; } final HashEntry < K , V > newCurrent = next ;
while ( n == null && i > 0 ) { n = data [ -- i ] ; } next = n ; hashIndex = i ; last = newCurrent ; return newCurrent ; MST[ReturnValsMutator]MSP[] } protected HashEntry < K , V > currentEntry () { return last ; }
while ( n == null && i > 0 ) { n = data [ -- i ] ; } next = n ; hashIndex = i ; MST[rv.ABSMutator]MSP[] last = newCurrent ; return newCurrent ; } protected HashEntry < K , V > currentEntry () { return last ; }
public boolean hasNext () { return next != null ; } protected HashEntry < K , V > nextEntry () { if ( parent . modCount != expectedModCount ) { MST[rv.UOI4Mutator]MSP[] throw new ConcurrentModificationException () ; } final HashEntry < K , V > newCurrent = next ;
public boolean hasNext () { return next != null ; } protected HashEntry < K , V > nextEntry () { if ( parent . modCount != expectedModCount ) { MST[rv.UOI2Mutator]MSP[] throw new ConcurrentModificationException () ; } final HashEntry < K , V > newCurrent = next ;
public boolean hasNext () { return next != null ; } protected HashEntry < K , V > nextEntry () { if ( parent . modCount != expectedModCount ) { MST[NegateConditionalsMutator]MSP[] throw new ConcurrentModificationException () ; } final HashEntry < K , V > newCurrent = next ;
public boolean hasNext () { return next != null ; MST[rv.ROR5Mutator]MSP[] } protected HashEntry < K , V > nextEntry () { if ( parent . modCount != expectedModCount ) { throw new ConcurrentModificationException () ; } final HashEntry < K , V > newCurrent = next ;
while ( n == null && i > 0 ) { n = data [ -- i ] ; } next = n ; hashIndex = i ; last = newCurrent ; return newCurrent ; MST[NullReturnValsMutator]MSP[] } protected HashEntry < K , V > currentEntry () { return last ; }
while ( n == null && i > 0 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] n = data [ -- i ] ; } next = n ; hashIndex = i ; last = newCurrent ; return newCurrent ; } protected HashEntry < K , V > currentEntry () { return last ; }
if ( newCurrent == null ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } final HashEntry < K , V > [] data = parent . data ; int i = hashIndex ; MST[rv.UOI1Mutator]MSP[] HashEntry < K , V > n = newCurrent . next ;
public boolean hasNext () { return next != null ; MST[InlineConstantMutator]MSP[] } protected HashEntry < K , V > nextEntry () { if ( parent . modCount != expectedModCount ) { throw new ConcurrentModificationException () ; } final HashEntry < K , V > newCurrent = next ;
last = null ; expectedModCount = parent . modCount ; MST[rv.UOI4Mutator]MSP[] } @Override public String toString () { if ( last != null ) { return lr_2 + last . getKey () + lr_3 + last . getValue () + lr_4 ; } return lr_5 ; }
public boolean hasNext () { return next != null ; MST[InlineConstantMutator]MSP[] } protected HashEntry < K , V > nextEntry () { if ( parent . modCount != expectedModCount ) { throw new ConcurrentModificationException () ; } final HashEntry < K , V > newCurrent = next ;
while ( n == null && i > 0 ) { MST[NegateConditionalsMutator]MSP[] n = data [ -- i ] ; } next = n ; hashIndex = i ; last = newCurrent ; return newCurrent ; } protected HashEntry < K , V > currentEntry () { return last ; }
last = null ; expectedModCount = parent . modCount ; MST[rv.UOI2Mutator]MSP[] } @Override public String toString () { if ( last != null ) { return lr_2 + last . getKey () + lr_3 + last . getValue () + lr_4 ; } return lr_5 ; }
public void remove () { if ( last == null ) { throw new IllegalStateException ( AbstractHashedMap . REMOVE_INVALID ) ; } if ( parent . modCount != expectedModCount ) { MST[rv.UOI1Mutator]MSP[] throw new ConcurrentModificationException () ; } parent . remove ( last . getKey () ) ;
public void remove () { if ( last == null ) { throw new IllegalStateException ( AbstractHashedMap . REMOVE_INVALID ) ; } if ( parent . modCount != expectedModCount ) { MST[rv.ABSMutator]MSP[] throw new ConcurrentModificationException () ; } parent . remove ( last . getKey () ) ;
public boolean hasNext () { return next != null ; MST[BooleanTrueReturnValsMutator]MSP[] } protected HashEntry < K , V > nextEntry () { if ( parent . modCount != expectedModCount ) { throw new ConcurrentModificationException () ; } final HashEntry < K , V > newCurrent = next ;
while ( n == null && i > 0 ) { n = data [ -- i ] ; } next = n ; hashIndex = i ; MST[rv.UOI1Mutator]MSP[] last = newCurrent ; return newCurrent ; } protected HashEntry < K , V > currentEntry () { return last ; }
while ( n == null && i > 0 ) { n = data [ -- i ] ; } next = n ; hashIndex = i ; MST[rv.UOI2Mutator]MSP[] last = newCurrent ; return newCurrent ; } protected HashEntry < K , V > currentEntry () { return last ; }
while ( n == null && i > 0 ) { MST[rv.ROR1Mutator]MSP[] n = data [ -- i ] ; } next = n ; hashIndex = i ; last = newCurrent ; return newCurrent ; } protected HashEntry < K , V > currentEntry () { return last ; }
public boolean hasNext () { return next != null ; } protected HashEntry < K , V > nextEntry () { if ( parent . modCount != expectedModCount ) { MST[rv.ROR4Mutator]MSP[] throw new ConcurrentModificationException () ; } final HashEntry < K , V > newCurrent = next ;
public boolean hasNext () { return next != null ; } protected HashEntry < K , V > nextEntry () { if ( parent . modCount != expectedModCount ) { MST[rv.ROR3Mutator]MSP[] throw new ConcurrentModificationException () ; } final HashEntry < K , V > newCurrent = next ;
while ( n == null && i > 0 ) { MST[rv.ROR2Mutator]MSP[] n = data [ -- i ] ; } next = n ; hashIndex = i ; last = newCurrent ; return newCurrent ; } protected HashEntry < K , V > currentEntry () { return last ; }
public void remove () { if ( last == null ) { throw new IllegalStateException ( AbstractHashedMap . REMOVE_INVALID ) ; } if ( parent . modCount != expectedModCount ) { MST[rv.UOI4Mutator]MSP[] throw new ConcurrentModificationException () ; } parent . remove ( last . getKey () ) ;
while ( n == null && i > 0 ) { MST[rv.ABSMutator]MSP[] n = data [ -- i ] ; } next = n ; hashIndex = i ; last = newCurrent ; return newCurrent ; } protected HashEntry < K , V > currentEntry () { return last ; }
public void remove () { if ( last == null ) { throw new IllegalStateException ( AbstractHashedMap . REMOVE_INVALID ) ; } if ( parent . modCount != expectedModCount ) { MST[rv.UOI2Mutator]MSP[] throw new ConcurrentModificationException () ; } parent . remove ( last . getKey () ) ;
public void remove () { if ( last == null ) { throw new IllegalStateException ( AbstractHashedMap . REMOVE_INVALID ) ; } if ( parent . modCount != expectedModCount ) { MST[rv.UOI3Mutator]MSP[] throw new ConcurrentModificationException () ; } parent . remove ( last . getKey () ) ;
if ( newCurrent == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } final HashEntry < K , V > [] data = parent . data ; int i = hashIndex ; HashEntry < K , V > n = newCurrent . next ;
while ( n == null && i > 0 ) { MST[rv.ROR5Mutator]MSP[] n = data [ -- i ] ; } next = n ; hashIndex = i ; last = newCurrent ; return newCurrent ; } protected HashEntry < K , V > currentEntry () { return last ; }
if ( newCurrent == null ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; MST[ConstructorCallMutator]MSP[] } final HashEntry < K , V > [] data = parent . data ; int i = hashIndex ; HashEntry < K , V > n = newCurrent . next ;
public boolean hasNext () { return next != null ; } protected HashEntry < K , V > nextEntry () { if ( parent . modCount != expectedModCount ) { MST[rv.ABSMutator]MSP[] throw new ConcurrentModificationException () ; } final HashEntry < K , V > newCurrent = next ;
public boolean hasNext () { return next != null ; } protected HashEntry < K , V > nextEntry () { if ( parent . modCount != expectedModCount ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] throw new ConcurrentModificationException () ; } final HashEntry < K , V > newCurrent = next ;
public boolean hasNext () { return next != null ; MST[NegateConditionalsMutator]MSP[] } protected HashEntry < K , V > nextEntry () { if ( parent . modCount != expectedModCount ) { throw new ConcurrentModificationException () ; } final HashEntry < K , V > newCurrent = next ;
while ( n == null && i > 0 ) { MST[rv.UOI4Mutator]MSP[] n = data [ -- i ] ; } next = n ; hashIndex = i ; last = newCurrent ; return newCurrent ; } protected HashEntry < K , V > currentEntry () { return last ; }
public void remove () { if ( last == null ) { throw new IllegalStateException ( AbstractHashedMap . REMOVE_INVALID ) ; } if ( parent . modCount != expectedModCount ) { MST[rv.ROR3Mutator]MSP[] throw new ConcurrentModificationException () ; } parent . remove ( last . getKey () ) ;
last = null ; expectedModCount = parent . modCount ; MST[rv.UOI3Mutator]MSP[] } @Override public String toString () { if ( last != null ) { return lr_2 + last . getKey () + lr_3 + last . getValue () + lr_4 ; } return lr_5 ; }
if ( newCurrent == null ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } final HashEntry < K , V > [] data = parent . data ; int i = hashIndex ; MST[rv.UOI4Mutator]MSP[] HashEntry < K , V > n = newCurrent . next ;
public void remove () { if ( last == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] throw new IllegalStateException ( AbstractHashedMap . REMOVE_INVALID ) ; } if ( parent . modCount != expectedModCount ) { throw new ConcurrentModificationException () ; } parent . remove ( last . getKey () ) ;
while ( n == null && i > 0 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] n = data [ -- i ] ; } next = n ; hashIndex = i ; last = newCurrent ; return newCurrent ; } protected HashEntry < K , V > currentEntry () { return last ; }
while ( n == null && i > 0 ) { n = data [ -- i ] ; } next = n ; hashIndex = i ; last = newCurrent ; return newCurrent ; } protected HashEntry < K , V > currentEntry () { return last ; MST[ReturnValsMutator]MSP[] }
last = null ; MST[experimental.MemberVariableMutator]MSP[] expectedModCount = parent . modCount ; } @Override public String toString () { if ( last != null ) { return lr_2 + last . getKey () + lr_3 + last . getValue () + lr_4 ; } return lr_5 ; }
public void remove () { if ( last == null ) { throw new IllegalStateException ( AbstractHashedMap . REMOVE_INVALID ) ; } if ( parent . modCount != expectedModCount ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] throw new ConcurrentModificationException () ; } parent . remove ( last . getKey () ) ;
public boolean hasNext () { return next != null ; MST[rv.CRCR5Mutator]MSP[] } protected HashEntry < K , V > nextEntry () { if ( parent . modCount != expectedModCount ) { throw new ConcurrentModificationException () ; } final HashEntry < K , V > newCurrent = next ;
public boolean hasNext () { return next != null ; MST[rv.CRCR3Mutator]MSP[] } protected HashEntry < K , V > nextEntry () { if ( parent . modCount != expectedModCount ) { throw new ConcurrentModificationException () ; } final HashEntry < K , V > newCurrent = next ;
public boolean hasNext () { return next != null ; MST[rv.CRCR6Mutator]MSP[] } protected HashEntry < K , V > nextEntry () { if ( parent . modCount != expectedModCount ) { throw new ConcurrentModificationException () ; } final HashEntry < K , V > newCurrent = next ;
public boolean hasNext () { return next != null ; MST[rv.CRCR5Mutator]MSP[] } protected HashEntry < K , V > nextEntry () { if ( parent . modCount != expectedModCount ) { throw new ConcurrentModificationException () ; } final HashEntry < K , V > newCurrent = next ;
public boolean hasNext () { return next != null ; } protected HashEntry < K , V > nextEntry () { if ( parent . modCount != expectedModCount ) { MST[rv.UOI2Mutator]MSP[] throw new ConcurrentModificationException () ; } final HashEntry < K , V > newCurrent = next ;
public boolean hasNext () { return next != null ; MST[rv.CRCR4Mutator]MSP[] } protected HashEntry < K , V > nextEntry () { if ( parent . modCount != expectedModCount ) { throw new ConcurrentModificationException () ; } final HashEntry < K , V > newCurrent = next ;
public boolean hasNext () { return next != null ; MST[rv.CRCR6Mutator]MSP[] } protected HashEntry < K , V > nextEntry () { if ( parent . modCount != expectedModCount ) { throw new ConcurrentModificationException () ; } final HashEntry < K , V > newCurrent = next ;
public boolean hasNext () { return next != null ; MST[rv.CRCR2Mutator]MSP[] } protected HashEntry < K , V > nextEntry () { if ( parent . modCount != expectedModCount ) { throw new ConcurrentModificationException () ; } final HashEntry < K , V > newCurrent = next ;
public boolean hasNext () { return next != null ; } protected HashEntry < K , V > nextEntry () { if ( parent . modCount != expectedModCount ) { MST[rv.UOI3Mutator]MSP[] throw new ConcurrentModificationException () ; } final HashEntry < K , V > newCurrent = next ;
public boolean hasNext () { return next != null ; } protected HashEntry < K , V > nextEntry () { if ( parent . modCount != expectedModCount ) { MST[rv.UOI1Mutator]MSP[] throw new ConcurrentModificationException () ; } final HashEntry < K , V > newCurrent = next ;
public void remove () { if ( last == null ) { throw new IllegalStateException ( AbstractHashedMap . REMOVE_INVALID ) ; } if ( parent . modCount != expectedModCount ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] throw new ConcurrentModificationException () ; } parent . remove ( last . getKey () ) ;
public boolean hasNext () { return next != null ; MST[rv.CRCR1Mutator]MSP[] } protected HashEntry < K , V > nextEntry () { if ( parent . modCount != expectedModCount ) { throw new ConcurrentModificationException () ; } final HashEntry < K , V > newCurrent = next ;
while ( n == null && i > 0 ) { n = data [ -- i ] ; MST[IncrementsMutator]MSP[] } next = n ; hashIndex = i ; last = newCurrent ; return newCurrent ; } protected HashEntry < K , V > currentEntry () { return last ; }
public boolean hasNext () { return next != null ; MST[rv.CRCR3Mutator]MSP[] } protected HashEntry < K , V > nextEntry () { if ( parent . modCount != expectedModCount ) { throw new ConcurrentModificationException () ; } final HashEntry < K , V > newCurrent = next ;
while ( n == null && i > 0 ) { n = data [ -- i ] ; MST[rv.UOI2Mutator]MSP[] } next = n ; hashIndex = i ; last = newCurrent ; return newCurrent ; } protected HashEntry < K , V > currentEntry () { return last ; }
public void remove () { if ( last == null ) { throw new IllegalStateException ( AbstractHashedMap . REMOVE_INVALID ) ; } if ( parent . modCount != expectedModCount ) { throw new ConcurrentModificationException () ; } parent . remove ( last . getKey () ) ; MST[NonVoidMethodCallMutator]MSP[]
public void remove () { if ( last == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] throw new IllegalStateException ( AbstractHashedMap . REMOVE_INVALID ) ; } if ( parent . modCount != expectedModCount ) { throw new ConcurrentModificationException () ; } parent . remove ( last . getKey () ) ;
public boolean hasNext () { return next != null ; } protected HashEntry < K , V > nextEntry () { if ( parent . modCount != expectedModCount ) { MST[rv.UOI4Mutator]MSP[] throw new ConcurrentModificationException () ; } final HashEntry < K , V > newCurrent = next ;
while ( n == null && i > 0 ) { n = data [ -- i ] ; MST[rv.UOI4Mutator]MSP[] } next = n ; hashIndex = i ; last = newCurrent ; return newCurrent ; } protected HashEntry < K , V > currentEntry () { return last ; }
while ( n == null && i > 0 ) { n = data [ -- i ] ; } next = n ; hashIndex = i ; last = newCurrent ; return newCurrent ; } protected HashEntry < K , V > currentEntry () { return last ; MST[NullReturnValsMutator]MSP[] }
public void remove () { if ( last == null ) { throw new IllegalStateException ( AbstractHashedMap . REMOVE_INVALID ) ; } if ( parent . modCount != expectedModCount ) { MST[rv.ABSMutator]MSP[] throw new ConcurrentModificationException () ; } parent . remove ( last . getKey () ) ;
while ( n == null && i > 0 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[] n = data [ -- i ] ; } next = n ; hashIndex = i ; last = newCurrent ; return newCurrent ; } protected HashEntry < K , V > currentEntry () { return last ; }
public void remove () { if ( last == null ) { throw new IllegalStateException ( AbstractHashedMap . REMOVE_INVALID ) ; } if ( parent . modCount != expectedModCount ) { MST[rv.ROR2Mutator]MSP[] throw new ConcurrentModificationException () ; } parent . remove ( last . getKey () ) ;
public void remove () { if ( last == null ) { throw new IllegalStateException ( AbstractHashedMap . REMOVE_INVALID ) ; } if ( parent . modCount != expectedModCount ) { MST[rv.ROR4Mutator]MSP[] throw new ConcurrentModificationException () ; } parent . remove ( last . getKey () ) ;
while ( n == null && i > 0 ) { MST[NegateConditionalsMutator]MSP[] n = data [ -- i ] ; } next = n ; hashIndex = i ; last = newCurrent ; return newCurrent ; } protected HashEntry < K , V > currentEntry () { return last ; }
public void remove () { if ( last == null ) { throw new IllegalStateException ( AbstractHashedMap . REMOVE_INVALID ) ; } if ( parent . modCount != expectedModCount ) { MST[rv.UOI1Mutator]MSP[] throw new ConcurrentModificationException () ; } parent . remove ( last . getKey () ) ;
if ( newCurrent == null ) { MST[rv.ROR5Mutator]MSP[] throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } final HashEntry < K , V > [] data = parent . data ; int i = hashIndex ; HashEntry < K , V > n = newCurrent . next ;
public void remove () { if ( last == null ) { throw new IllegalStateException ( AbstractHashedMap . REMOVE_INVALID ) ; } if ( parent . modCount != expectedModCount ) { MST[NegateConditionalsMutator]MSP[] throw new ConcurrentModificationException () ; } parent . remove ( last . getKey () ) ;
if ( newCurrent == null ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } final HashEntry < K , V > [] data = parent . data ; int i = hashIndex ; MST[rv.ABSMutator]MSP[] HashEntry < K , V > n = newCurrent . next ;
last = null ; expectedModCount = parent . modCount ; MST[experimental.MemberVariableMutator]MSP[] } @Override public String toString () { if ( last != null ) { return lr_2 + last . getKey () + lr_3 + last . getValue () + lr_4 ; } return lr_5 ; }
while ( n == null && i > 0 ) { MST[ConditionalsBoundaryMutator]MSP[] n = data [ -- i ] ; } next = n ; hashIndex = i ; last = newCurrent ; return newCurrent ; } protected HashEntry < K , V > currentEntry () { return last ; }
while ( n == null && i > 0 ) { n = data [ -- i ] ; } next = n ; hashIndex = i ; last = newCurrent ; MST[experimental.MemberVariableMutator]MSP[] return newCurrent ; } protected HashEntry < K , V > currentEntry () { return last ; }
while ( n == null && i > 0 ) { n = data [ -- i ] ; MST[rv.ABSMutator]MSP[] } next = n ; hashIndex = i ; last = newCurrent ; return newCurrent ; } protected HashEntry < K , V > currentEntry () { return last ; }
public void remove () { if ( last == null ) { MST[NegateConditionalsMutator]MSP[] throw new IllegalStateException ( AbstractHashedMap . REMOVE_INVALID ) ; } if ( parent . modCount != expectedModCount ) { throw new ConcurrentModificationException () ; } parent . remove ( last . getKey () ) ;
public boolean hasNext () { return next != null ; } protected HashEntry < K , V > nextEntry () { if ( parent . modCount != expectedModCount ) { MST[rv.ROR5Mutator]MSP[] throw new ConcurrentModificationException () ; } final HashEntry < K , V > newCurrent = next ;
while ( n == null && i > 0 ) { n = data [ -- i ] ; } next = n ; hashIndex = i ; MST[rv.UOI4Mutator]MSP[] last = newCurrent ; return newCurrent ; } protected HashEntry < K , V > currentEntry () { return last ; }
public void remove () { if ( last == null ) { throw new IllegalStateException ( AbstractHashedMap . REMOVE_INVALID ) ; } if ( parent . modCount != expectedModCount ) { MST[rv.UOI4Mutator]MSP[] throw new ConcurrentModificationException () ; } parent . remove ( last . getKey () ) ;
public void remove () { if ( last == null ) { throw new IllegalStateException ( AbstractHashedMap . REMOVE_INVALID ) ; } if ( parent . modCount != expectedModCount ) { MST[rv.UOI2Mutator]MSP[] throw new ConcurrentModificationException () ; } parent . remove ( last . getKey () ) ;
public void remove () { if ( last == null ) { throw new IllegalStateException ( AbstractHashedMap . REMOVE_INVALID ) ; } if ( parent . modCount != expectedModCount ) { MST[rv.UOI3Mutator]MSP[] throw new ConcurrentModificationException () ; } parent . remove ( last . getKey () ) ;
while ( n == null && i > 0 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] n = data [ -- i ] ; } next = n ; hashIndex = i ; last = newCurrent ; return newCurrent ; } protected HashEntry < K , V > currentEntry () { return last ; }
public boolean hasNext () { return next != null ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] } protected HashEntry < K , V > nextEntry () { if ( parent . modCount != expectedModCount ) { throw new ConcurrentModificationException () ; } final HashEntry < K , V > newCurrent = next ;
public boolean hasNext () { return next != null ; } protected HashEntry < K , V > nextEntry () { if ( parent . modCount != expectedModCount ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] throw new ConcurrentModificationException () ; } final HashEntry < K , V > newCurrent = next ;
while ( n == null && i > 0 ) { MST[rv.ROR5Mutator]MSP[] n = data [ -- i ] ; } next = n ; hashIndex = i ; last = newCurrent ; return newCurrent ; } protected HashEntry < K , V > currentEntry () { return last ; }
public void remove () { if ( last == null ) { throw new IllegalStateException ( AbstractHashedMap . REMOVE_INVALID ) ; } if ( parent . modCount != expectedModCount ) { throw new ConcurrentModificationException () ; } parent . remove ( last . getKey () ) ; MST[ArgumentPropagationMutator]MSP[]
last = null ; expectedModCount = parent . modCount ; MST[rv.ABSMutator]MSP[] } @Override public String toString () { if ( last != null ) { return lr_2 + last . getKey () + lr_3 + last . getValue () + lr_4 ; } return lr_5 ; }
public void remove () { if ( last == null ) { throw new IllegalStateException ( AbstractHashedMap . REMOVE_INVALID ) ; } if ( parent . modCount != expectedModCount ) { throw new ConcurrentModificationException () ; } parent . remove ( last . getKey () ) ; MST[NonVoidMethodCallMutator]MSP[]
public boolean hasNext () { return next != null ; } protected HashEntry < K , V > nextEntry () { if ( parent . modCount != expectedModCount ) { MST[rv.ROR2Mutator]MSP[] throw new ConcurrentModificationException () ; } final HashEntry < K , V > newCurrent = next ;
public boolean hasNext () { return next != null ; } protected HashEntry < K , V > nextEntry () { if ( parent . modCount != expectedModCount ) { MST[rv.ROR1Mutator]MSP[] throw new ConcurrentModificationException () ; } final HashEntry < K , V > newCurrent = next ;
while ( n == null && i > 0 ) { MST[rv.ROR4Mutator]MSP[] n = data [ -- i ] ; } next = n ; hashIndex = i ; last = newCurrent ; return newCurrent ; } protected HashEntry < K , V > currentEntry () { return last ; }
while ( n == null && i > 0 ) { MST[rv.ROR3Mutator]MSP[] n = data [ -- i ] ; } next = n ; hashIndex = i ; last = newCurrent ; return newCurrent ; } protected HashEntry < K , V > currentEntry () { return last ; }
public boolean hasNext () { return next != null ; } protected HashEntry < K , V > nextEntry () { if ( parent . modCount != expectedModCount ) { MST[rv.ABSMutator]MSP[] throw new ConcurrentModificationException () ; } final HashEntry < K , V > newCurrent = next ;
if ( newCurrent == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } final HashEntry < K , V > [] data = parent . data ; int i = hashIndex ; HashEntry < K , V > n = newCurrent . next ;
if ( newCurrent == null ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } final HashEntry < K , V > [] data = parent . data ; int i = hashIndex ; MST[rv.UOI2Mutator]MSP[] HashEntry < K , V > n = newCurrent . next ;
public boolean hasNext () { return next != null ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] } protected HashEntry < K , V > nextEntry () { if ( parent . modCount != expectedModCount ) { throw new ConcurrentModificationException () ; } final HashEntry < K , V > newCurrent = next ;
public void remove () { if ( last == null ) { throw new IllegalStateException ( AbstractHashedMap . REMOVE_INVALID ) ; } if ( parent . modCount != expectedModCount ) { MST[rv.ROR5Mutator]MSP[] throw new ConcurrentModificationException () ; } parent . remove ( last . getKey () ) ;
public void remove () { if ( last == null ) { throw new IllegalStateException ( AbstractHashedMap . REMOVE_INVALID ) ; } if ( parent . modCount != expectedModCount ) { MST[rv.ROR1Mutator]MSP[] throw new ConcurrentModificationException () ; } parent . remove ( last . getKey () ) ;
public void remove () { if ( last == null ) { MST[rv.ROR5Mutator]MSP[] throw new IllegalStateException ( AbstractHashedMap . REMOVE_INVALID ) ; } if ( parent . modCount != expectedModCount ) { throw new ConcurrentModificationException () ; } parent . remove ( last . getKey () ) ;
} @Override public Iterator < Map . Entry < K , V > > iterator () { return parent . createEntrySetIterator () ; } @Override public Map . Entry < K , V > next () { return super . nextEntry () ; MST[ReturnValsMutator]MSP[] } @Override
} @Override public Iterator < Map . Entry < K , V > > iterator () { return parent . createEntrySetIterator () ; } @Override public Map . Entry < K , V > next () { return super . nextEntry () ; MST[NonVoidMethodCallMutator]MSP[] } @Override
} @Override public Iterator < Map . Entry < K , V > > iterator () { return parent . createEntrySetIterator () ; } @Override public Map . Entry < K , V > next () { return super . nextEntry () ; MST[NullReturnValsMutator]MSP[] } @Override
return current . getKey () ; } @Override public V getValue () { final HashEntry < K , V > current = currentEntry () ; MST[NonVoidMethodCallMutator]MSP[] if ( current == null ) { throw new IllegalStateException ( AbstractHashedMap . GETVALUE_INVALID ) ; } return current . getValue () ; } @Override
return current . getKey () ; } @Override public V getValue () { final HashEntry < K , V > current = currentEntry () ; if ( current == null ) { throw new IllegalStateException ( AbstractHashedMap . GETVALUE_INVALID ) ; } return current . getValue () ; MST[NullReturnValsMutator]MSP[] } @Override
return current . getKey () ; } @Override public V getValue () { final HashEntry < K , V > current = currentEntry () ; if ( current == null ) { MST[rv.ROR5Mutator]MSP[] throw new IllegalStateException ( AbstractHashedMap . GETVALUE_INVALID ) ; } return current . getValue () ; } @Override
return current . getKey () ; } @Override public V getValue () { final HashEntry < K , V > current = currentEntry () ; if ( current == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] throw new IllegalStateException ( AbstractHashedMap . GETVALUE_INVALID ) ; } return current . getValue () ; } @Override
return current . getKey () ; } @Override public V getValue () { final HashEntry < K , V > current = currentEntry () ; if ( current == null ) { MST[NegateConditionalsMutator]MSP[] throw new IllegalStateException ( AbstractHashedMap . GETVALUE_INVALID ) ; } return current . getValue () ; } @Override
return current . getKey () ; } @Override public V getValue () { final HashEntry < K , V > current = currentEntry () ; if ( current == null ) { throw new IllegalStateException ( AbstractHashedMap . GETVALUE_INVALID ) ; } return current . getValue () ; MST[ReturnValsMutator]MSP[] } @Override
return super . nextEntry () . getKey () ; MST[NullReturnValsMutator]MSP[] } @Override public K getKey () { final HashEntry < K , V > current = currentEntry () ; if ( current == null ) { throw new IllegalStateException ( AbstractHashedMap . GETKEY_INVALID ) ; }
return super . nextEntry () . getKey () ; MST[ReturnValsMutator]MSP[] } @Override public K getKey () { final HashEntry < K , V > current = currentEntry () ; if ( current == null ) { throw new IllegalStateException ( AbstractHashedMap . GETKEY_INVALID ) ; }
return current . getKey () ; } @Override public V getValue () { final HashEntry < K , V > current = currentEntry () ; if ( current == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] throw new IllegalStateException ( AbstractHashedMap . GETVALUE_INVALID ) ; } return current . getValue () ; } @Override
return super . nextEntry () . getKey () ; MST[NonVoidMethodCallMutator]MSP[] } @Override public K getKey () { final HashEntry < K , V > current = currentEntry () ; if ( current == null ) { throw new IllegalStateException ( AbstractHashedMap . GETKEY_INVALID ) ; }
return super . nextEntry () . getKey () ; MST[NonVoidMethodCallMutator]MSP[] } @Override public K getKey () { final HashEntry < K , V > current = currentEntry () ; if ( current == null ) { throw new IllegalStateException ( AbstractHashedMap . GETKEY_INVALID ) ; }
return current . getKey () ; } @Override public V getValue () { final HashEntry < K , V > current = currentEntry () ; if ( current == null ) { throw new IllegalStateException ( AbstractHashedMap . GETVALUE_INVALID ) ; } return current . getValue () ; MST[NonVoidMethodCallMutator]MSP[] } @Override
@Override public Iterator < K > iterator () { return parent . createKeySetIterator () ; } @Override public K next () { return super . nextEntry () . getKey () ; MST[NonVoidMethodCallMutator]MSP[] } @Override public Collection < V > values () { if ( values == null ) {
@Override public Iterator < K > iterator () { return parent . createKeySetIterator () ; } @Override public K next () { return super . nextEntry () . getKey () ; MST[NonVoidMethodCallMutator]MSP[] } @Override public Collection < V > values () { if ( values == null ) {
@Override public Iterator < K > iterator () { return parent . createKeySetIterator () ; } @Override public K next () { return super . nextEntry () . getKey () ; MST[NullReturnValsMutator]MSP[] } @Override public Collection < V > values () { if ( values == null ) {
@Override public Iterator < K > iterator () { return parent . createKeySetIterator () ; } @Override public K next () { return super . nextEntry () . getKey () ; MST[ReturnValsMutator]MSP[] } @Override public Collection < V > values () { if ( values == null ) {
