final Object [] result = new Object [ size () ] ; int i = 0 ; final Iterator < E > it = map . keySet () . iterator () ; while ( it . hasNext () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] final E current = it . next () ;
modCount ++ ; if ( nCopies < mut . value ) { mut . value -= nCopies ; size -= nCopies ; MST[rv.UOI3Mutator]MSP[N] } else { map . remove ( object ) ; size -= mut . value ; } return true ; } @Override
int i = 0 ; final Iterator < E > it = map . keySet () . iterator () ; while ( it . hasNext () ) { MST[NegateConditionalsMutator]MSP[N] final E current = it . next () ;
final boolean added = add ( i . next () ) ; changed = changed || added ; } return changed ; } @Override public void clear () { modCount ++ ; MST[rv.UOI3Mutator]MSP[N] map . clear () ; size = 0 ; } @Override
final MutableInteger mut = map . get ( object ) ; size += nCopies ; if ( mut == null ) { map . put ( object , new MutableInteger ( nCopies ) ) ; return true ; } mut . value += nCopies ; MST[rv.UOI2Mutator]MSP[N] return false ; }
modCount ++ ; if ( nCopies < mut . value ) { mut . value -= nCopies ; size -= nCopies ; } else { map . remove ( object ) ; size -= mut . value ; } return true ; MST[ReturnValsMutator]MSP[N] } @Override
final int entrySize = in . readInt () ; for ( int i = 0 ; i < entrySize ; i ++ ) { MST[rv.CRCR3Mutator]MSP[N] @SuppressWarnings ( lr_1 ) final E obj = ( E ) in . readObject () ; final int count = in . readInt () ;
modCount ++ ; if ( nCopies < mut . value ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] mut . value -= nCopies ; size -= nCopies ; } else { map . remove ( object ) ; size -= mut . value ; } return true ; } @Override
buf . append ( '[' ) ; final Iterator < E > it = uniqueSet () . iterator () ; MST[NonVoidMethodCallMutator]MSP[S] while ( it . hasNext () ) { final Object current = it . next () ; final int count = getCount ( current ) ;
array [ i ++ ] = null ; MST[rv.UOI1Mutator]MSP[N] } return array ; } @Override public Set < E > uniqueSet () { if ( uniqueSet == null ) { uniqueSet = UnmodifiableSet . <E > unmodifiableSet ( map . keySet () ) ; } return uniqueSet ; }
modCount ++ ; if ( nCopies < mut . value ) { mut . value -= nCopies ; size -= nCopies ; } else { map . remove ( object ) ; size -= mut . value ; MST[rv.UOI3Mutator]MSP[N] } return true ; } @Override
for ( int index = getCount ( current ) ; index > 0 ; index -- ) { @SuppressWarnings ( lr_1 ) final T unchecked = ( T ) current ; array [ i ++ ] = unchecked ; } } while ( i < array . length ) { MST[rv.ROR3Mutator]MSP[N]
modCount ++ ; if ( nCopies < mut . value ) { mut . value -= nCopies ; size -= nCopies ; MST[experimental.MemberVariableMutator]MSP[N] } else { map . remove ( object ) ; size -= mut . value ; } return true ; } @Override
canRemove = false ; } @Override public boolean add ( final E object ) { return add ( object , 1 ) ; } @Override public boolean add ( final E object , final int nCopies ) { modCount ++ ; MST[rv.CRCR2Mutator]MSP[S] if ( nCopies > 0 ) {
protected void doWriteObject ( final ObjectOutputStream out ) throws IOException { out . writeInt ( map . size () ) ; MST[NonVoidMethodCallMutator]MSP[N] for ( final Entry < E , MutableInteger > entry : map . entrySet () ) { out . writeObject ( entry . getKey () ) ;
modCount ++ ; if ( nCopies < mut . value ) { mut . value -= nCopies ; size -= nCopies ; MST[MathMutator]MSP[N] } else { map . remove ( object ) ; size -= mut . value ; } return true ; } @Override
if ( other . getCount ( element ) != getCount ( element ) ) { return false ; } } return true ; MST[rv.CRCR4Mutator]MSP[N] } @Override public int hashCode () { int total = 0 ;
final int size = size () ; if ( array . length < size ) { MST[rv.UOI2Mutator]MSP[N] @SuppressWarnings ( lr_1 ) final T [] unchecked = ( T [] ) Array . newInstance ( array . getClass () . getComponentType () , size ) ; array = unchecked ; }
for ( int index = getCount ( current ) ; index > 0 ; index -- ) { result [ i ++ ] = current ; MST[IncrementsMutator]MSP[N] } } return result ; } @Override public < T > T [] toArray ( T [] array ) {
for ( int index = getCount ( current ) ; index > 0 ; index -- ) { MST[rv.UOI2Mutator]MSP[S] @SuppressWarnings ( lr_1 ) final T unchecked = ( T ) current ; array [ i ++ ] = unchecked ; } } while ( i < array . length ) {
buf . append ( count ) ; buf . append ( ':' ) ; buf . append ( current ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( it . hasNext () ) { buf . append ( ',' ) ; } } buf . append ( ']' ) ;
modCount ++ ; if ( nCopies < mut . value ) { mut . value -= nCopies ; size -= nCopies ; } else { map . remove ( object ) ; size -= mut . value ; MST[rv.ABSMutator]MSP[N] } return true ; } @Override
map . put ( obj , new MutableInteger ( count ) ) ; size += count ; MST[rv.AOR2Mutator]MSP[S] } } @Override public boolean equals ( final Object object ) { if ( object == this ) { return true ; } if ( object instanceof Bag == false ) {
canRemove = false ; } @Override public boolean add ( final E object ) { return add ( object , 1 ) ; MST[NonVoidMethodCallMutator]MSP[N] } @Override public boolean add ( final E object , final int nCopies ) { modCount ++ ; if ( nCopies > 0 ) {
final boolean added = add ( i . next () ) ; changed = changed || added ; MST[rv.CRCR6Mutator]MSP[S] } return changed ; } @Override public void clear () { modCount ++ ; map . clear () ; size = 0 ; } @Override
map . put ( obj , new MutableInteger ( count ) ) ; size += count ; MST[rv.UOI2Mutator]MSP[N] } } @Override public boolean equals ( final Object object ) { if ( object == this ) { return true ; } if ( object instanceof Bag == false ) {
modCount ++ ; MST[rv.CRCR2Mutator]MSP[S] if ( nCopies < mut . value ) { mut . value -= nCopies ; size -= nCopies ; } else { map . remove ( object ) ; size -= mut . value ; } return true ; } @Override
total += ( element == null ? 0 : element . hashCode () ) ^ count . value ; } return total ; MST[rv.UOI1Mutator]MSP[N] } @Override public String toString () { if ( size () == 0 ) { return lr_2 ; } final StringBuilder buf = new StringBuilder () ;
final boolean added = add ( i . next () ) ; changed = changed || added ; MST[rv.ABSMutator]MSP[S] } return changed ; } @Override public void clear () { modCount ++ ; map . clear () ; size = 0 ; } @Override
canRemove = false ; } @Override public boolean add ( final E object ) { return add ( object , 1 ) ; MST[InlineConstantMutator]MSP[N] } @Override public boolean add ( final E object , final int nCopies ) { modCount ++ ; if ( nCopies > 0 ) {
canRemove = false ; } @Override public boolean add ( final E object ) { return add ( object , 1 ) ; MST[rv.CRCR3Mutator]MSP[N] } @Override public boolean add ( final E object , final int nCopies ) { modCount ++ ; if ( nCopies > 0 ) {
for ( int index = getCount ( current ) ; index > 0 ; index -- ) { MST[rv.ROR4Mutator]MSP[N] result [ i ++ ] = current ; } } return result ; } @Override public < T > T [] toArray ( T [] array ) {
map . put ( obj , new MutableInteger ( count ) ) ; size += count ; } } @Override public boolean equals ( final Object object ) { if ( object == this ) { return true ; MST[InlineConstantMutator]MSP[S] } if ( object instanceof Bag == false ) {
final MutableInteger mut = map . get ( object ) ; size += nCopies ; if ( mut == null ) { map . put ( object , new MutableInteger ( nCopies ) ) ; return true ; MST[ReturnValsMutator]MSP[N] } mut . value += nCopies ; return false ; }
for ( int index = getCount ( current ) ; index > 0 ; index -- ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] result [ i ++ ] = current ; } } return result ; } @Override public < T > T [] toArray ( T [] array ) {
for ( int index = getCount ( current ) ; index > 0 ; index -- ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] @SuppressWarnings ( lr_1 ) final T unchecked = ( T ) current ; array [ i ++ ] = unchecked ; } } while ( i < array . length ) {
array [ i ++ ] = null ; } return array ; MST[ReturnValsMutator]MSP[N] } @Override public Set < E > uniqueSet () { if ( uniqueSet == null ) { uniqueSet = UnmodifiableSet . <E > unmodifiableSet ( map . keySet () ) ; } return uniqueSet ; }
final int entrySize = in . readInt () ; for ( int i = 0 ; i < entrySize ; i ++ ) { MST[rv.UOI4Mutator]MSP[N] @SuppressWarnings ( lr_1 ) final E obj = ( E ) in . readObject () ; final int count = in . readInt () ;
protected Map < E , MutableInteger > getMap () { return map ; } @Override public int size () { return size ; MST[ReturnValsMutator]MSP[N] } @Override public boolean isEmpty () { return map . isEmpty () ; } @Override public int getCount ( final Object object ) {
final boolean added = add ( i . next () ) ; changed = changed || added ; MST[rv.UOI3Mutator]MSP[S] } return changed ; } @Override public void clear () { modCount ++ ; map . clear () ; size = 0 ; } @Override
final Object [] result = new Object [ size () ] ; int i = 0 ; final Iterator < E > it = map . keySet () . iterator () ; while ( it . hasNext () ) { MST[rv.ROR4Mutator]MSP[N] final E current = it . next () ;
final int size = size () ; if ( array . length < size ) { MST[ConditionalsBoundaryMutator]MSP[N] @SuppressWarnings ( lr_1 ) final T [] unchecked = ( T [] ) Array . newInstance ( array . getClass () . getComponentType () , size ) ; array = unchecked ; }
modCount ++ ; if ( nCopies < mut . value ) { MST[rv.UOI2Mutator]MSP[N] mut . value -= nCopies ; size -= nCopies ; } else { map . remove ( object ) ; size -= mut . value ; } return true ; } @Override
final int entrySize = in . readInt () ; for ( int i = 0 ; i < entrySize ; i ++ ) { MST[rv.ROR1Mutator]MSP[N] @SuppressWarnings ( lr_1 ) final E obj = ( E ) in . readObject () ; final int count = in . readInt () ;
canRemove = false ; } @Override public boolean add ( final E object ) { return add ( object , 1 ) ; } @Override public boolean add ( final E object , final int nCopies ) { modCount ++ ; if ( nCopies > 0 ) { MST[ConditionalsBoundaryMutator]MSP[S]
final boolean added = add ( i . next () ) ; changed = changed || added ; } return changed ; MST[rv.UOI4Mutator]MSP[S] } @Override public void clear () { modCount ++ ; map . clear () ; size = 0 ; } @Override
} @Override public boolean remove ( final Object object , final int nCopies ) { final MutableInteger mut = map . get ( object ) ; if ( mut == null ) { return false ; } if ( nCopies <= 0 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[S] return false ; }
modCount ++ ; if ( nCopies < mut . value ) { mut . value -= nCopies ; size -= nCopies ; MST[rv.AOR2Mutator]MSP[N] } else { map . remove ( object ) ; size -= mut . value ; } return true ; } @Override
canRemove = false ; } @Override public boolean add ( final E object ) { return add ( object , 1 ) ; } @Override public boolean add ( final E object , final int nCopies ) { modCount ++ ; MST[rv.AOR1Mutator]MSP[S] if ( nCopies > 0 ) {
final MutableInteger mut = map . get ( object ) ; size += nCopies ; if ( mut == null ) { map . put ( object , new MutableInteger ( nCopies ) ) ; return true ; } mut . value += nCopies ; MST[rv.UOI1Mutator]MSP[N] return false ; }
final MutableInteger count = map . get ( object ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( count != null ) { return count . value ; } return 0 ; } @Override public boolean contains ( final Object object ) { return map . containsKey ( object ) ; } @Override
modCount ++ ; if ( nCopies < mut . value ) { mut . value -= nCopies ; size -= nCopies ; } else { map . remove ( object ) ; size -= mut . value ; MST[rv.UOI3Mutator]MSP[N] } return true ; } @Override
final int size = size () ; if ( array . length < size ) { MST[rv.ROR5Mutator]MSP[N] @SuppressWarnings ( lr_1 ) final T [] unchecked = ( T [] ) Array . newInstance ( array . getClass () . getComponentType () , size ) ; array = unchecked ; }
return false ; } @Override public boolean addAll ( final Collection < ? extends E > coll ) { boolean changed = false ; final Iterator < ? extends E > i = coll . iterator () ; MST[NonVoidMethodCallMutator]MSP[S] while ( i . hasNext () ) {
} @Override public boolean remove ( final Object object , final int nCopies ) { final MutableInteger mut = map . get ( object ) ; if ( mut == null ) { return false ; } if ( nCopies <= 0 ) { MST[rv.UOI2Mutator]MSP[N] return false ; }
protected Map < E , MutableInteger > getMap () { return map ; } @Override public int size () { return size ; MST[PrimitiveReturnsMutator]MSP[N] } @Override public boolean isEmpty () { return map . isEmpty () ; } @Override public int getCount ( final Object object ) {
out . writeInt ( entry . getValue () . value ) ; } } protected void doReadObject ( final Map < E , MutableInteger > map , final ObjectInputStream in ) throws IOException , ClassNotFoundException { this . map = map ; MST[experimental.MemberVariableMutator]MSP[S]
final MutableInteger mut = map . get ( object ) ; size += nCopies ; MST[rv.UOI4Mutator]MSP[N] if ( mut == null ) { map . put ( object , new MutableInteger ( nCopies ) ) ; return true ; } mut . value += nCopies ; return false ; }
out . writeInt ( entry . getValue () . value ) ; MST[rv.UOI1Mutator]MSP[N] } } protected void doReadObject ( final Map < E , MutableInteger > map , final ObjectInputStream in ) throws IOException , ClassNotFoundException { this . map = map ;
final boolean changed = remove ( i . next () , 1 ) ; result = result || changed ; } } return result ; } @Override public boolean retainAll ( final Collection < ? > coll ) { if ( coll instanceof Bag ) { MST[rv.ROR3Mutator]MSP[S]
final int entrySize = in . readInt () ; for ( int i = 0 ; i < entrySize ; i ++ ) { MST[IncrementsMutator]MSP[N] @SuppressWarnings ( lr_1 ) final E obj = ( E ) in . readObject () ; final int count = in . readInt () ;
modCount ++ ; if ( nCopies < mut . value ) { mut . value -= nCopies ; MST[rv.AOD1Mutator]MSP[N] size -= nCopies ; } else { map . remove ( object ) ; size -= mut . value ; } return true ; } @Override
modCount ++ ; if ( nCopies < mut . value ) { mut . value -= nCopies ; size -= nCopies ; } else { map . remove ( object ) ; MST[NonVoidMethodCallMutator]MSP[N] size -= mut . value ; } return true ; } @Override
buf . append ( count ) ; buf . append ( ':' ) ; MST[NonVoidMethodCallMutator]MSP[N] buf . append ( current ) ; if ( it . hasNext () ) { buf . append ( ',' ) ; } } buf . append ( ']' ) ;
canRemove = false ; } @Override public boolean add ( final E object ) { return add ( object , 1 ) ; } @Override public boolean add ( final E object , final int nCopies ) { modCount ++ ; MST[rv.UOI3Mutator]MSP[S] if ( nCopies > 0 ) {
int i = 0 ; final Iterator < E > it = map . keySet () . iterator () ; while ( it . hasNext () ) { MST[rv.ROR2Mutator]MSP[N] final E current = it . next () ;
modCount ++ ; if ( nCopies < mut . value ) { mut . value -= nCopies ; size -= nCopies ; } else { map . remove ( object ) ; size -= mut . value ; } return true ; MST[rv.CRCR2Mutator]MSP[N] } @Override
final MutableInteger mut = map . get ( object ) ; size += nCopies ; if ( mut == null ) { map . put ( object , new MutableInteger ( nCopies ) ) ; return true ; } mut . value += nCopies ; MST[rv.UOI3Mutator]MSP[N] return false ; }
modCount ++ ; if ( nCopies < mut . value ) { mut . value -= nCopies ; size -= nCopies ; } else { map . remove ( object ) ; size -= mut . value ; MST[rv.AOR1Mutator]MSP[N] } return true ; } @Override
canRemove = false ; } @Override public boolean add ( final E object ) { return add ( object , 1 ) ; } @Override public boolean add ( final E object , final int nCopies ) { modCount ++ ; MST[rv.AOR4Mutator]MSP[S] if ( nCopies > 0 ) {
final boolean added = add ( i . next () ) ; changed = changed || added ; } return changed ; } @Override public void clear () { modCount ++ ; MST[rv.UOI2Mutator]MSP[N] map . clear () ; size = 0 ; } @Override
for ( int index = getCount ( current ) ; index > 0 ; index -- ) { @SuppressWarnings ( lr_1 ) final T unchecked = ( T ) current ; array [ i ++ ] = unchecked ; } } while ( i < array . length ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N]
modCount ++ ; if ( nCopies < mut . value ) { mut . value -= nCopies ; size -= nCopies ; } else { map . remove ( object ) ; size -= mut . value ; MST[rv.UOI4Mutator]MSP[N] } return true ; } @Override
if ( other . getCount ( element ) != getCount ( element ) ) { MST[NegateConditionalsMutator]MSP[S] return false ; } } return true ; } @Override public int hashCode () { int total = 0 ;
buf . append ( count ) ; buf . append ( ':' ) ; buf . append ( current ) ; if ( it . hasNext () ) { buf . append ( ',' ) ; MST[InlineConstantMutator]MSP[N] } } buf . append ( ']' ) ;
if ( other . getCount ( element ) != getCount ( element ) ) { return false ; } } return true ; MST[rv.CRCR3Mutator]MSP[N] } @Override public int hashCode () { int total = 0 ;
final int size = size () ; if ( array . length < size ) { MST[rv.ROR2Mutator]MSP[N] @SuppressWarnings ( lr_1 ) final T [] unchecked = ( T [] ) Array . newInstance ( array . getClass () . getComponentType () , size ) ; array = unchecked ; }
final boolean added = add ( i . next () ) ; changed = changed || added ; MST[rv.ABSMutator]MSP[S] } return changed ; } @Override public void clear () { modCount ++ ; map . clear () ; size = 0 ; } @Override
canRemove = false ; } @Override public boolean add ( final E object ) { return add ( object , 1 ) ; } @Override public boolean add ( final E object , final int nCopies ) { modCount ++ ; MST[MathMutator]MSP[S] if ( nCopies > 0 ) {
final boolean added = add ( i . next () ) ; changed = changed || added ; } return changed ; } @Override public void clear () { modCount ++ ; map . clear () ; size = 0 ; MST[rv.CRCR5Mutator]MSP[S] } @Override
final int size = size () ; if ( array . length < size ) { MST[rv.UOI1Mutator]MSP[N] @SuppressWarnings ( lr_1 ) final T [] unchecked = ( T [] ) Array . newInstance ( array . getClass () . getComponentType () , size ) ; array = unchecked ; }
for ( int index = getCount ( current ) ; index > 0 ; index -- ) { @SuppressWarnings ( lr_1 ) final T unchecked = ( T ) current ; array [ i ++ ] = unchecked ; } } while ( i < array . length ) { MST[ConditionalsBoundaryMutator]MSP[N]
final boolean added = add ( i . next () ) ; changed = changed || added ; } return changed ; } @Override public void clear () { modCount ++ ; MST[rv.AOD1Mutator]MSP[N] map . clear () ; size = 0 ; } @Override
if ( other . getCount ( element ) != getCount ( element ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] return false ; } } return true ; } @Override public int hashCode () { int total = 0 ;
modCount ++ ; if ( nCopies < mut . value ) { mut . value -= nCopies ; MST[rv.AOR3Mutator]MSP[N] size -= nCopies ; } else { map . remove ( object ) ; size -= mut . value ; } return true ; } @Override
return false ; MST[rv.CRCR6Mutator]MSP[S] } @Override public boolean addAll ( final Collection < ? extends E > coll ) { boolean changed = false ; final Iterator < ? extends E > i = coll . iterator () ; while ( i . hasNext () ) {
final boolean added = add ( i . next () ) ; changed = changed || added ; } return changed ; } @Override public void clear () { modCount ++ ; MST[rv.CRCR2Mutator]MSP[N] map . clear () ; size = 0 ; } @Override
final boolean added = add ( i . next () ) ; changed = changed || added ; MST[rv.UOI2Mutator]MSP[S] } return changed ; } @Override public void clear () { modCount ++ ; map . clear () ; size = 0 ; } @Override
if ( other . getCount ( element ) != getCount ( element ) ) { MST[rv.ROR5Mutator]MSP[S] return false ; } } return true ; } @Override public int hashCode () { int total = 0 ;
final boolean added = add ( i . next () ) ; changed = changed || added ; } return changed ; MST[rv.UOI3Mutator]MSP[S] } @Override public void clear () { modCount ++ ; map . clear () ; size = 0 ; } @Override
modCount ++ ; if ( nCopies < mut . value ) { mut . value -= nCopies ; size -= nCopies ; MST[rv.UOI4Mutator]MSP[N] } else { map . remove ( object ) ; size -= mut . value ; } return true ; } @Override
protected Map < E , MutableInteger > getMap () { return map ; } @Override public int size () { return size ; MST[rv.ABSMutator]MSP[N] } @Override public boolean isEmpty () { return map . isEmpty () ; } @Override public int getCount ( final Object object ) {
final boolean added = add ( i . next () ) ; changed = changed || added ; } return changed ; } @Override public void clear () { modCount ++ ; MST[InlineConstantMutator]MSP[N] map . clear () ; size = 0 ; } @Override
for ( int index = getCount ( current ) ; index > 0 ; index -- ) { result [ i ++ ] = current ; MST[rv.ABSMutator]MSP[N] } } return result ; } @Override public < T > T [] toArray ( T [] array ) {
final int size = size () ; if ( array . length < size ) { @SuppressWarnings ( lr_1 ) final T [] unchecked = ( T [] ) Array . newInstance ( array . getClass () . getComponentType () , size ) ; MST[NonVoidMethodCallMutator]MSP[N] array = unchecked ; }
final boolean added = add ( i . next () ) ; changed = changed || added ; MST[rv.ROR3Mutator]MSP[S] } return changed ; } @Override public void clear () { modCount ++ ; map . clear () ; size = 0 ; } @Override
final boolean added = add ( i . next () ) ; changed = changed || added ; } return changed ; } @Override public void clear () { modCount ++ ; MST[rv.AOR3Mutator]MSP[N] map . clear () ; size = 0 ; } @Override
final boolean added = add ( i . next () ) ; changed = changed || added ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] } return changed ; } @Override public void clear () { modCount ++ ; map . clear () ; size = 0 ; } @Override
map . put ( obj , new MutableInteger ( count ) ) ; size += count ; MST[MathMutator]MSP[S] } } @Override public boolean equals ( final Object object ) { if ( object == this ) { return true ; } if ( object instanceof Bag == false ) {
final Object [] result = new Object [ size () ] ; int i = 0 ; final Iterator < E > it = map . keySet () . iterator () ; while ( it . hasNext () ) { MST[rv.ROR2Mutator]MSP[N] final E current = it . next () ;
buf . append ( count ) ; buf . append ( ':' ) ; buf . append ( current ) ; if ( it . hasNext () ) { buf . append ( ',' ) ; } } buf . append ( ']' ) ; MST[rv.CRCR5Mutator]MSP[N]
} @Override public boolean remove ( final Object object , final int nCopies ) { final MutableInteger mut = map . get ( object ) ; if ( mut == null ) { return false ; } if ( nCopies <= 0 ) { MST[rv.ROR1Mutator]MSP[N] return false ; }
modCount ++ ; MST[rv.AOD2Mutator]MSP[S] if ( nCopies < mut . value ) { mut . value -= nCopies ; size -= nCopies ; } else { map . remove ( object ) ; size -= mut . value ; } return true ; } @Override
final Object [] result = new Object [ size () ] ; int i = 0 ; MST[rv.CRCR5Mutator]MSP[N] final Iterator < E > it = map . keySet () . iterator () ; while ( it . hasNext () ) { final E current = it . next () ;
for ( int index = getCount ( current ) ; index > 0 ; index -- ) { MST[rv.UOI1Mutator]MSP[N] @SuppressWarnings ( lr_1 ) final T unchecked = ( T ) current ; array [ i ++ ] = unchecked ; } } while ( i < array . length ) {
final int entrySize = in . readInt () ; MST[NonVoidMethodCallMutator]MSP[S] for ( int i = 0 ; i < entrySize ; i ++ ) { @SuppressWarnings ( lr_1 ) final E obj = ( E ) in . readObject () ; final int count = in . readInt () ;
map . put ( obj , new MutableInteger ( count ) ) ; size += count ; MST[rv.AOR1Mutator]MSP[S] } } @Override public boolean equals ( final Object object ) { if ( object == this ) { return true ; } if ( object instanceof Bag == false ) {
map . put ( obj , new MutableInteger ( count ) ) ; size += count ; MST[rv.AOR4Mutator]MSP[S] } } @Override public boolean equals ( final Object object ) { if ( object == this ) { return true ; } if ( object instanceof Bag == false ) {
canRemove = false ; } @Override public boolean add ( final E object ) { return add ( object , 1 ) ; } @Override public boolean add ( final E object , final int nCopies ) { modCount ++ ; MST[rv.AOD2Mutator]MSP[S] if ( nCopies > 0 ) {
map . put ( obj , new MutableInteger ( count ) ) ; MST[rv.UOI1Mutator]MSP[S] size += count ; } } @Override public boolean equals ( final Object object ) { if ( object == this ) { return true ; } if ( object instanceof Bag == false ) {
} @Override public boolean remove ( final Object object , final int nCopies ) { final MutableInteger mut = map . get ( object ) ; if ( mut == null ) { return false ; MST[rv.CRCR3Mutator]MSP[N] } if ( nCopies <= 0 ) { return false ; }
} @Override public boolean remove ( final Object object , final int nCopies ) { final MutableInteger mut = map . get ( object ) ; if ( mut == null ) { return false ; MST[rv.CRCR6Mutator]MSP[N] } if ( nCopies <= 0 ) { return false ; }
} @Override public boolean remove ( final Object object , final int nCopies ) { final MutableInteger mut = map . get ( object ) ; if ( mut == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return false ; } if ( nCopies <= 0 ) { return false ; }
for ( int index = getCount ( current ) ; index > 0 ; index -- ) { @SuppressWarnings ( lr_1 ) final T unchecked = ( T ) current ; array [ i ++ ] = unchecked ; } } while ( i < array . length ) { MST[rv.ABSMutator]MSP[N]
modCount ++ ; MST[rv.CRCR6Mutator]MSP[S] if ( nCopies < mut . value ) { mut . value -= nCopies ; size -= nCopies ; } else { map . remove ( object ) ; size -= mut . value ; } return true ; } @Override
modCount ++ ; if ( nCopies < mut . value ) { mut . value -= nCopies ; size -= nCopies ; } else { map . remove ( object ) ; size -= mut . value ; MST[rv.UOI4Mutator]MSP[N] } return true ; } @Override
map . put ( obj , new MutableInteger ( count ) ) ; size += count ; MST[rv.UOI3Mutator]MSP[S] } } @Override public boolean equals ( final Object object ) { if ( object == this ) { return true ; } if ( object instanceof Bag == false ) {
map . put ( obj , new MutableInteger ( count ) ) ; size += count ; MST[rv.UOI4Mutator]MSP[S] } } @Override public boolean equals ( final Object object ) { if ( object == this ) { return true ; } if ( object instanceof Bag == false ) {
modCount ++ ; MST[rv.AOR4Mutator]MSP[S] if ( nCopies < mut . value ) { mut . value -= nCopies ; size -= nCopies ; } else { map . remove ( object ) ; size -= mut . value ; } return true ; } @Override
for ( int index = getCount ( current ) ; index > 0 ; index -- ) { @SuppressWarnings ( lr_1 ) final T unchecked = ( T ) current ; array [ i ++ ] = unchecked ; } } while ( i < array . length ) { MST[NegateConditionalsMutator]MSP[N]
canRemove = false ; } @Override public boolean add ( final E object ) { return add ( object , 1 ) ; MST[rv.CRCR5Mutator]MSP[N] } @Override public boolean add ( final E object , final int nCopies ) { modCount ++ ; if ( nCopies > 0 ) {
int i = 0 ; MST[InlineConstantMutator]MSP[N] final Iterator < E > it = map . keySet () . iterator () ; while ( it . hasNext () ) { final E current = it . next () ;
for ( int index = getCount ( current ) ; index > 0 ; index -- ) { result [ i ++ ] = current ; MST[rv.UOI2Mutator]MSP[N] } } return result ; } @Override public < T > T [] toArray ( T [] array ) {
for ( int index = getCount ( current ) ; index > 0 ; index -- ) { MST[rv.ROR2Mutator]MSP[N] result [ i ++ ] = current ; } } return result ; } @Override public < T > T [] toArray ( T [] array ) {
} @Override public boolean remove ( final Object object , final int nCopies ) { final MutableInteger mut = map . get ( object ) ; if ( mut == null ) { return false ; } if ( nCopies <= 0 ) { MST[rv.UOI3Mutator]MSP[N] return false ; }
final MutableInteger mut = map . get ( object ) ; size += nCopies ; if ( mut == null ) { map . put ( object , new MutableInteger ( nCopies ) ) ; return true ; } mut . value += nCopies ; return false ; MST[rv.CRCR5Mutator]MSP[S] }
final boolean added = add ( i . next () ) ; changed = changed || added ; } return changed ; } @Override public void clear () { modCount ++ ; map . clear () ; size = 0 ; MST[experimental.MemberVariableMutator]MSP[N] } @Override
public boolean removeAll ( final Collection < ? > coll ) { boolean result = false ; MST[InlineConstantMutator]MSP[S] if ( coll != null ) { final Iterator < ? > i = coll . iterator () ; while ( i . hasNext () ) {
final int size = size () ; if ( array . length < size ) { @SuppressWarnings ( lr_1 ) final T [] unchecked = ( T [] ) Array . newInstance ( array . getClass () . getComponentType () , size ) ; MST[experimental.NakedReceiverMutator]MSP[N] array = unchecked ; }
buf . append ( count ) ; buf . append ( ':' ) ; buf . append ( current ) ; if ( it . hasNext () ) { MST[rv.ROR3Mutator]MSP[N] buf . append ( ',' ) ; } } buf . append ( ']' ) ;
final boolean added = add ( i . next () ) ; changed = changed || added ; MST[rv.UOI2Mutator]MSP[S] } return changed ; } @Override public void clear () { modCount ++ ; map . clear () ; size = 0 ; } @Override
final boolean changed = remove ( i . next () , 1 ) ; result = result || changed ; } } return result ; MST[BooleanTrueReturnValsMutator]MSP[S] } @Override public boolean retainAll ( final Collection < ? > coll ) { if ( coll instanceof Bag ) {
for ( final Entry < E , MutableInteger > entry : map . entrySet () ) { MST[NonVoidMethodCallMutator]MSP[S] final E element = entry . getKey () ; final MutableInteger count = entry . getValue () ;
final boolean changed = remove ( i . next () , 1 ) ; result = result || changed ; } } return result ; } @Override public boolean retainAll ( final Collection < ? > coll ) { if ( coll instanceof Bag ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
buf . append ( count ) ; buf . append ( ':' ) ; buf . append ( current ) ; if ( it . hasNext () ) { buf . append ( ',' ) ; MST[NonVoidMethodCallMutator]MSP[N] } } buf . append ( ']' ) ;
modCount ++ ; MST[MathMutator]MSP[S] if ( nCopies < mut . value ) { mut . value -= nCopies ; size -= nCopies ; } else { map . remove ( object ) ; size -= mut . value ; } return true ; } @Override
buf . append ( count ) ; buf . append ( ':' ) ; MST[InlineConstantMutator]MSP[N] buf . append ( current ) ; if ( it . hasNext () ) { buf . append ( ',' ) ; } } buf . append ( ']' ) ;
final int size = size () ; if ( array . length < size ) { @SuppressWarnings ( lr_1 ) final T [] unchecked = ( T [] ) Array . newInstance ( array . getClass () . getComponentType () , size ) ; MST[rv.ABSMutator]MSP[N] array = unchecked ; }
modCount ++ ; MST[rv.CRCR3Mutator]MSP[S] if ( nCopies < mut . value ) { mut . value -= nCopies ; size -= nCopies ; } else { map . remove ( object ) ; size -= mut . value ; } return true ; } @Override
array [ i ++ ] = null ; } return array ; } @Override public Set < E > uniqueSet () { if ( uniqueSet == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] uniqueSet = UnmodifiableSet . <E > unmodifiableSet ( map . keySet () ) ; } return uniqueSet ; }
total += ( element == null ? 0 : element . hashCode () ) ^ count . value ; } return total ; MST[rv.UOI2Mutator]MSP[N] } @Override public String toString () { if ( size () == 0 ) { return lr_2 ; } final StringBuilder buf = new StringBuilder () ;
final MutableInteger mut = map . get ( object ) ; size += nCopies ; if ( mut == null ) { map . put ( object , new MutableInteger ( nCopies ) ) ; return true ; } mut . value += nCopies ; return false ; MST[ReturnValsMutator]MSP[S] }
map . put ( obj , new MutableInteger ( count ) ) ; size += count ; } } @Override public boolean equals ( final Object object ) { if ( object == this ) { return true ; MST[rv.CRCR2Mutator]MSP[S] } if ( object instanceof Bag == false ) {
final boolean added = add ( i . next () ) ; changed = changed || added ; } return changed ; } @Override public void clear () { modCount ++ ; MST[rv.ABSMutator]MSP[N] map . clear () ; size = 0 ; } @Override
for ( int index = getCount ( current ) ; index > 0 ; index -- ) { @SuppressWarnings ( lr_1 ) final T unchecked = ( T ) current ; array [ i ++ ] = unchecked ; MST[rv.ABSMutator]MSP[N] } } while ( i < array . length ) {
for ( int index = getCount ( current ) ; index > 0 ; index -- ) { MST[rv.ROR5Mutator]MSP[N] result [ i ++ ] = current ; } } return result ; } @Override public < T > T [] toArray ( T [] array ) {
buf . append ( count ) ; buf . append ( ':' ) ; buf . append ( current ) ; if ( it . hasNext () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] buf . append ( ',' ) ; } } buf . append ( ']' ) ;
final int entrySize = in . readInt () ; for ( int i = 0 ; i < entrySize ; i ++ ) { MST[rv.UOI2Mutator]MSP[S] @SuppressWarnings ( lr_1 ) final E obj = ( E ) in . readObject () ; final int count = in . readInt () ;
final int size = size () ; if ( array . length < size ) { MST[rv.UOI4Mutator]MSP[N] @SuppressWarnings ( lr_1 ) final T [] unchecked = ( T [] ) Array . newInstance ( array . getClass () . getComponentType () , size ) ; array = unchecked ; }
out . writeInt ( entry . getValue () . value ) ; MST[rv.UOI4Mutator]MSP[N] } } protected void doReadObject ( final Map < E , MutableInteger > map , final ObjectInputStream in ) throws IOException , ClassNotFoundException { this . map = map ;
final boolean changed = remove ( i . next () , 1 ) ; result = result || changed ; } } return result ; MST[rv.UOI1Mutator]MSP[N] } @Override public boolean retainAll ( final Collection < ? > coll ) { if ( coll instanceof Bag ) {
final MutableInteger count = map . get ( object ) ; if ( count != null ) { return count . value ; } return 0 ; } @Override public boolean contains ( final Object object ) { return map . containsKey ( object ) ; MST[ReturnValsMutator]MSP[N] } @Override
final MutableInteger count = map . get ( object ) ; if ( count != null ) { return count . value ; } return 0 ; } @Override public boolean contains ( final Object object ) { return map . containsKey ( object ) ; MST[BooleanTrueReturnValsMutator]MSP[S] } @Override
final MutableInteger mut = map . get ( object ) ; size += nCopies ; if ( mut == null ) { map . put ( object , new MutableInteger ( nCopies ) ) ; return true ; } mut . value += nCopies ; MST[rv.AOR3Mutator]MSP[N] return false ; }
int i = 0 ; final Iterator < E > it = map . keySet () . iterator () ; MST[NonVoidMethodCallMutator]MSP[N] while ( it . hasNext () ) { final E current = it . next () ;
buf . append ( count ) ; buf . append ( ':' ) ; buf . append ( current ) ; if ( it . hasNext () ) { buf . append ( ',' ) ; } } buf . append ( ']' ) ; MST[NonVoidMethodCallMutator]MSP[N]
final MutableInteger count = map . get ( object ) ; if ( count != null ) { return count . value ; MST[ReturnValsMutator]MSP[N] } return 0 ; } @Override public boolean contains ( final Object object ) { return map . containsKey ( object ) ; } @Override
final MutableInteger mut = map . get ( object ) ; size += nCopies ; if ( mut == null ) { map . put ( object , new MutableInteger ( nCopies ) ) ; return true ; } mut . value += nCopies ; MST[rv.UOI4Mutator]MSP[N] return false ; }
buf . append ( count ) ; buf . append ( ':' ) ; buf . append ( current ) ; if ( it . hasNext () ) { buf . append ( ',' ) ; } } buf . append ( ']' ) ; MST[rv.CRCR2Mutator]MSP[N]
total += ( element == null ? 0 : element . hashCode () ) ^ count . value ; } return total ; MST[rv.ABSMutator]MSP[N] } @Override public String toString () { if ( size () == 0 ) { return lr_2 ; } final StringBuilder buf = new StringBuilder () ;
for ( int index = getCount ( current ) ; index > 0 ; index -- ) { MST[NonVoidMethodCallMutator]MSP[N] result [ i ++ ] = current ; } } return result ; } @Override public < T > T [] toArray ( T [] array ) {
for ( int index = getCount ( current ) ; index > 0 ; index -- ) { result [ i ++ ] = current ; MST[experimental.RemoveIncrementsMutator]MSP[N] } } return result ; } @Override public < T > T [] toArray ( T [] array ) {
int i = 0 ; final Iterator < E > it = map . keySet () . iterator () ; while ( it . hasNext () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] final E current = it . next () ;
total += ( element == null ? 0 : element . hashCode () ) ^ count . value ; } return total ; MST[PrimitiveReturnsMutator]MSP[N] } @Override public String toString () { if ( size () == 0 ) { return lr_2 ; } final StringBuilder buf = new StringBuilder () ;
final int size = size () ; MST[NonVoidMethodCallMutator]MSP[N] if ( array . length < size ) { @SuppressWarnings ( lr_1 ) final T [] unchecked = ( T [] ) Array . newInstance ( array . getClass () . getComponentType () , size ) ; array = unchecked ; }
return false ; } @Override public boolean addAll ( final Collection < ? extends E > coll ) { boolean changed = false ; final Iterator < ? extends E > i = coll . iterator () ; while ( i . hasNext () ) { MST[rv.ROR3Mutator]MSP[N]
final boolean changed = remove ( i . next () , 1 ) ; result = result || changed ; } } return result ; MST[ReturnValsMutator]MSP[S] } @Override public boolean retainAll ( final Collection < ? > coll ) { if ( coll instanceof Bag ) {
return false ; } @Override public boolean addAll ( final Collection < ? extends E > coll ) { boolean changed = false ; final Iterator < ? extends E > i = coll . iterator () ; while ( i . hasNext () ) { MST[rv.ROR5Mutator]MSP[N]
for ( int index = getCount ( current ) ; index > 0 ; index -- ) { @SuppressWarnings ( lr_1 ) final T unchecked = ( T ) current ; array [ i ++ ] = unchecked ; MST[rv.UOI2Mutator]MSP[N] } } while ( i < array . length ) {
array [ i ++ ] = null ; } return array ; } @Override public Set < E > uniqueSet () { if ( uniqueSet == null ) { MST[rv.ROR5Mutator]MSP[N] uniqueSet = UnmodifiableSet . <E > unmodifiableSet ( map . keySet () ) ; } return uniqueSet ; }
if ( other . getCount ( element ) != getCount ( element ) ) { MST[rv.ROR2Mutator]MSP[N] return false ; } } return true ; } @Override public int hashCode () { int total = 0 ;
buf . append ( count ) ; buf . append ( ':' ) ; buf . append ( current ) ; if ( it . hasNext () ) { MST[NonVoidMethodCallMutator]MSP[N] buf . append ( ',' ) ; } } buf . append ( ']' ) ;
final MutableInteger mut = map . get ( object ) ; size += nCopies ; if ( mut == null ) { map . put ( object , new MutableInteger ( nCopies ) ) ; return true ; } mut . value += nCopies ; MST[rv.AOD1Mutator]MSP[N] return false ; }
buf . append ( count ) ; buf . append ( ':' ) ; MST[rv.CRCR5Mutator]MSP[N] buf . append ( current ) ; if ( it . hasNext () ) { buf . append ( ',' ) ; } } buf . append ( ']' ) ;
final MutableInteger mut = map . get ( object ) ; size += nCopies ; if ( mut == null ) { map . put ( object , new MutableInteger ( nCopies ) ) ; return true ; MST[rv.CRCR2Mutator]MSP[N] } mut . value += nCopies ; return false ; }
return false ; } @Override public boolean addAll ( final Collection < ? extends E > coll ) { boolean changed = false ; final Iterator < ? extends E > i = coll . iterator () ; while ( i . hasNext () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S]
total += ( element == null ? 0 : element . hashCode () ) ^ count . value ; } return total ; } @Override public String toString () { if ( size () == 0 ) { MST[rv.ROR4Mutator]MSP[N] return lr_2 ; } final StringBuilder buf = new StringBuilder () ;
final int entrySize = in . readInt () ; for ( int i = 0 ; i < entrySize ; i ++ ) { MST[rv.ROR3Mutator]MSP[N] @SuppressWarnings ( lr_1 ) final E obj = ( E ) in . readObject () ; final int count = in . readInt () ;
buf . append ( '[' ) ; MST[rv.CRCR3Mutator]MSP[N] final Iterator < E > it = uniqueSet () . iterator () ; while ( it . hasNext () ) { final Object current = it . next () ; final int count = getCount ( current ) ;
final MutableInteger mut = map . get ( object ) ; size += nCopies ; if ( mut == null ) { map . put ( object , new MutableInteger ( nCopies ) ) ; return true ; MST[InlineConstantMutator]MSP[N] } mut . value += nCopies ; return false ; }
buf . append ( '[' ) ; final Iterator < E > it = uniqueSet () . iterator () ; while ( it . hasNext () ) { MST[rv.ROR3Mutator]MSP[N] final Object current = it . next () ; final int count = getCount ( current ) ;
return false ; } @Override public boolean addAll ( final Collection < ? extends E > coll ) { boolean changed = false ; final Iterator < ? extends E > i = coll . iterator () ; while ( i . hasNext () ) { MST[NonVoidMethodCallMutator]MSP[N]
for ( int index = getCount ( current ) ; index > 0 ; index -- ) { MST[rv.UOI4Mutator]MSP[N] @SuppressWarnings ( lr_1 ) final T unchecked = ( T ) current ; array [ i ++ ] = unchecked ; } } while ( i < array . length ) {
buf . append ( count ) ; MST[NonVoidMethodCallMutator]MSP[N] buf . append ( ':' ) ; buf . append ( current ) ; if ( it . hasNext () ) { buf . append ( ',' ) ; } } buf . append ( ']' ) ;
modCount ++ ; if ( nCopies < mut . value ) { mut . value -= nCopies ; size -= nCopies ; } else { map . remove ( object ) ; size -= mut . value ; MST[rv.UOI1Mutator]MSP[S] } return true ; } @Override
modCount ++ ; if ( nCopies < mut . value ) { mut . value -= nCopies ; size -= nCopies ; } else { map . remove ( object ) ; MST[ArgumentPropagationMutator]MSP[N] size -= mut . value ; } return true ; } @Override
total += ( element == null ? 0 : element . hashCode () ) ^ count . value ; } return total ; MST[rv.UOI4Mutator]MSP[N] } @Override public String toString () { if ( size () == 0 ) { return lr_2 ; } final StringBuilder buf = new StringBuilder () ;
total += ( element == null ? 0 : element . hashCode () ) ^ count . value ; } return total ; } @Override public String toString () { if ( size () == 0 ) { return lr_2 ; } final StringBuilder buf = new StringBuilder () ; MST[ConstructorCallMutator]MSP[S]
return false ; } @Override public boolean addAll ( final Collection < ? extends E > coll ) { boolean changed = false ; final Iterator < ? extends E > i = coll . iterator () ; while ( i . hasNext () ) { MST[NegateConditionalsMutator]MSP[N]
final boolean added = add ( i . next () ) ; changed = changed || added ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] } return changed ; } @Override public void clear () { modCount ++ ; map . clear () ; size = 0 ; } @Override
for ( int index = getCount ( current ) ; index > 0 ; index -- ) { @SuppressWarnings ( lr_1 ) final T unchecked = ( T ) current ; array [ i ++ ] = unchecked ; } } while ( i < array . length ) { MST[rv.UOI2Mutator]MSP[N]
modCount ++ ; if ( nCopies < mut . value ) { mut . value -= nCopies ; size -= nCopies ; } else { map . remove ( object ) ; size -= mut . value ; MST[rv.AOD2Mutator]MSP[N] } return true ; } @Override
modCount ++ ; if ( nCopies < mut . value ) { mut . value -= nCopies ; size -= nCopies ; } else { map . remove ( object ) ; size -= mut . value ; } return true ; MST[InlineConstantMutator]MSP[N] } @Override
map . put ( obj , new MutableInteger ( count ) ) ; size += count ; } } @Override public boolean equals ( final Object object ) { if ( object == this ) { return true ; } if ( object instanceof Bag == false ) { MST[rv.ROR4Mutator]MSP[S]
return false ; } @Override public boolean addAll ( final Collection < ? extends E > coll ) { boolean changed = false ; MST[rv.CRCR5Mutator]MSP[S] final Iterator < ? extends E > i = coll . iterator () ; while ( i . hasNext () ) {
array [ i ++ ] = null ; } return array ; } @Override public Set < E > uniqueSet () { if ( uniqueSet == null ) { MST[NegateConditionalsMutator]MSP[N] uniqueSet = UnmodifiableSet . <E > unmodifiableSet ( map . keySet () ) ; } return uniqueSet ; }
buf . append ( count ) ; MST[rv.UOI1Mutator]MSP[N] buf . append ( ':' ) ; buf . append ( current ) ; if ( it . hasNext () ) { buf . append ( ',' ) ; } } buf . append ( ']' ) ;
protected Map < E , MutableInteger > getMap () { return map ; } @Override public int size () { return size ; MST[rv.UOI2Mutator]MSP[N] } @Override public boolean isEmpty () { return map . isEmpty () ; } @Override public int getCount ( final Object object ) {
return buf . toString () ; MST[ReturnValsMutator]MSP[S] }
final int size = size () ; if ( array . length < size ) { @SuppressWarnings ( lr_1 ) final T [] unchecked = ( T [] ) Array . newInstance ( array . getClass () . getComponentType () , size ) ; MST[rv.UOI2Mutator]MSP[N] array = unchecked ; }
canRemove = false ; } @Override public boolean add ( final E object ) { return add ( object , 1 ) ; } @Override public boolean add ( final E object , final int nCopies ) { modCount ++ ; MST[rv.CRCR5Mutator]MSP[S] if ( nCopies > 0 ) {
buf . append ( count ) ; buf . append ( ':' ) ; buf . append ( current ) ; if ( it . hasNext () ) { buf . append ( ',' ) ; MST[rv.CRCR5Mutator]MSP[N] } } buf . append ( ']' ) ;
buf . append ( '[' ) ; MST[rv.CRCR4Mutator]MSP[N] final Iterator < E > it = uniqueSet () . iterator () ; while ( it . hasNext () ) { final Object current = it . next () ; final int count = getCount ( current ) ;
total += ( element == null ? 0 : element . hashCode () ) ^ count . value ; } return total ; } @Override public String toString () { if ( size () == 0 ) { return lr_2 ; MST[ReturnValsMutator]MSP[S] } final StringBuilder buf = new StringBuilder () ;
canRemove = false ; } @Override public boolean add ( final E object ) { return add ( object , 1 ) ; } @Override public boolean add ( final E object , final int nCopies ) { modCount ++ ; if ( nCopies > 0 ) { MST[rv.ROR3Mutator]MSP[N]
modCount ++ ; MST[rv.UOI3Mutator]MSP[S] if ( nCopies < mut . value ) { mut . value -= nCopies ; size -= nCopies ; } else { map . remove ( object ) ; size -= mut . value ; } return true ; } @Override
for ( int index = getCount ( current ) ; index > 0 ; index -- ) { MST[rv.ROR2Mutator]MSP[N] @SuppressWarnings ( lr_1 ) final T unchecked = ( T ) current ; array [ i ++ ] = unchecked ; } } while ( i < array . length ) {
protected void doWriteObject ( final ObjectOutputStream out ) throws IOException { out . writeInt ( map . size () ) ; for ( final Entry < E , MutableInteger > entry : map . entrySet () ) { out . writeObject ( entry . getKey () ) ; MST[NonVoidMethodCallMutator]MSP[S]
if ( other . getCount ( element ) != getCount ( element ) ) { MST[rv.ROR3Mutator]MSP[S] return false ; } } return true ; } @Override public int hashCode () { int total = 0 ;
if ( other . getCount ( element ) != getCount ( element ) ) { return false ; } } return true ; } @Override public int hashCode () { int total = 0 ; MST[rv.CRCR3Mutator]MSP[N]
final int entrySize = in . readInt () ; for ( int i = 0 ; i < entrySize ; i ++ ) { MST[rv.UOI1Mutator]MSP[S] @SuppressWarnings ( lr_1 ) final E obj = ( E ) in . readObject () ; final int count = in . readInt () ;
total += ( element == null ? 0 : element . hashCode () ) ^ count . value ; } return total ; } @Override public String toString () { if ( size () == 0 ) { MST[rv.ROR5Mutator]MSP[N] return lr_2 ; } final StringBuilder buf = new StringBuilder () ;
modCount ++ ; if ( nCopies < mut . value ) { mut . value -= nCopies ; MST[rv.UOI2Mutator]MSP[N] size -= nCopies ; } else { map . remove ( object ) ; size -= mut . value ; } return true ; } @Override
map . put ( obj , new MutableInteger ( count ) ) ; size += count ; MST[rv.AOD2Mutator]MSP[S] } } @Override public boolean equals ( final Object object ) { if ( object == this ) { return true ; } if ( object instanceof Bag == false ) {
final MutableInteger count = map . get ( object ) ; if ( count != null ) { return count . value ; } return 0 ; MST[rv.CRCR6Mutator]MSP[S] } @Override public boolean contains ( final Object object ) { return map . containsKey ( object ) ; } @Override
final boolean added = add ( i . next () ) ; changed = changed || added ; } return changed ; MST[rv.UOI1Mutator]MSP[S] } @Override public void clear () { modCount ++ ; map . clear () ; size = 0 ; } @Override
protected Map < E , MutableInteger > getMap () { return map ; } @Override public int size () { return size ; } @Override public boolean isEmpty () { return map . isEmpty () ; MST[ReturnValsMutator]MSP[N] } @Override public int getCount ( final Object object ) {
final boolean added = add ( i . next () ) ; changed = changed || added ; } return changed ; } @Override public void clear () { modCount ++ ; map . clear () ; MST[VoidMethodCallMutator]MSP[S] size = 0 ; } @Override
return false ; } final Bag < ? > other = ( Bag < ? > ) object ; if ( other . size () != size () ) { MST[rv.ROR4Mutator]MSP[N] return false ; } for ( final E element : map . keySet () ) {
final boolean added = add ( i . next () ) ; changed = changed || added ; MST[rv.ROR3Mutator]MSP[S] } return changed ; } @Override public void clear () { modCount ++ ; map . clear () ; size = 0 ; } @Override
for ( int index = getCount ( current ) ; index > 0 ; index -- ) { @SuppressWarnings ( lr_1 ) final T unchecked = ( T ) current ; array [ i ++ ] = unchecked ; } } while ( i < array . length ) { MST[rv.ROR5Mutator]MSP[N]
final boolean changed = remove ( i . next () , 1 ) ; result = result || changed ; } } return result ; } @Override public boolean retainAll ( final Collection < ? > coll ) { if ( coll instanceof Bag ) { MST[NegateConditionalsMutator]MSP[S]
final MutableInteger mut = map . get ( object ) ; size += nCopies ; if ( mut == null ) { MST[NegateConditionalsMutator]MSP[N] map . put ( object , new MutableInteger ( nCopies ) ) ; return true ; } mut . value += nCopies ; return false ; }
final Object [] result = new Object [ size () ] ; int i = 0 ; final Iterator < E > it = map . keySet () . iterator () ; MST[NonVoidMethodCallMutator]MSP[N] while ( it . hasNext () ) { final E current = it . next () ;
if ( other . getCount ( element ) != getCount ( element ) ) { return false ; } } return true ; MST[rv.CRCR6Mutator]MSP[N] } @Override public int hashCode () { int total = 0 ;
return false ; MST[rv.CRCR3Mutator]MSP[S] } @Override public boolean addAll ( final Collection < ? extends E > coll ) { boolean changed = false ; final Iterator < ? extends E > i = coll . iterator () ; while ( i . hasNext () ) {
final boolean added = add ( i . next () ) ; changed = changed || added ; MST[rv.CRCR3Mutator]MSP[S] } return changed ; } @Override public void clear () { modCount ++ ; map . clear () ; size = 0 ; } @Override
for ( int index = getCount ( current ) ; index > 0 ; index -- ) { MST[rv.UOI4Mutator]MSP[N] result [ i ++ ] = current ; } } return result ; } @Override public < T > T [] toArray ( T [] array ) {
buf . append ( count ) ; buf . append ( ':' ) ; buf . append ( current ) ; if ( it . hasNext () ) { buf . append ( ',' ) ; } } buf . append ( ']' ) ; MST[InlineConstantMutator]MSP[N]
modCount ++ ; if ( nCopies < mut . value ) { mut . value -= nCopies ; size -= nCopies ; MST[rv.AOD1Mutator]MSP[N] } else { map . remove ( object ) ; size -= mut . value ; } return true ; } @Override
final int size = size () ; if ( array . length < size ) { MST[rv.UOI3Mutator]MSP[N] @SuppressWarnings ( lr_1 ) final T [] unchecked = ( T [] ) Array . newInstance ( array . getClass () . getComponentType () , size ) ; array = unchecked ; }
canRemove = false ; } @Override public boolean add ( final E object ) { return add ( object , 1 ) ; } @Override public boolean add ( final E object , final int nCopies ) { modCount ++ ; MST[experimental.MemberVariableMutator]MSP[S] if ( nCopies > 0 ) {
final MutableInteger mut = map . get ( object ) ; size += nCopies ; MST[rv.UOI2Mutator]MSP[S] if ( mut == null ) { map . put ( object , new MutableInteger ( nCopies ) ) ; return true ; } mut . value += nCopies ; return false ; }
int i = 0 ; final Iterator < E > it = map . keySet () . iterator () ; while ( it . hasNext () ) { MST[rv.ROR4Mutator]MSP[N] final E current = it . next () ;
canRemove = false ; } @Override public boolean add ( final E object ) { return add ( object , 1 ) ; } @Override public boolean add ( final E object , final int nCopies ) { modCount ++ ; if ( nCopies > 0 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N]
modCount ++ ; if ( nCopies < mut . value ) { mut . value -= nCopies ; MST[rv.UOI4Mutator]MSP[N] size -= nCopies ; } else { map . remove ( object ) ; size -= mut . value ; } return true ; } @Override
modCount ++ ; if ( nCopies < mut . value ) { mut . value -= nCopies ; size -= nCopies ; MST[rv.ABSMutator]MSP[N] } else { map . remove ( object ) ; size -= mut . value ; } return true ; } @Override
canRemove = false ; } @Override public boolean add ( final E object ) { return add ( object , 1 ) ; } @Override public boolean add ( final E object , final int nCopies ) { modCount ++ ; MST[rv.UOI1Mutator]MSP[S] if ( nCopies > 0 ) {
final boolean changed = remove ( i . next () , 1 ) ; result = result || changed ; } } return result ; } @Override public boolean retainAll ( final Collection < ? > coll ) { if ( coll instanceof Bag ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S]
canRemove = false ; } @Override public boolean add ( final E object ) { return add ( object , 1 ) ; } @Override public boolean add ( final E object , final int nCopies ) { modCount ++ ; MST[rv.AOR2Mutator]MSP[S] if ( nCopies > 0 ) {
final boolean added = add ( i . next () ) ; changed = changed || added ; } return changed ; } @Override public void clear () { modCount ++ ; MST[rv.UOI4Mutator]MSP[N] map . clear () ; size = 0 ; } @Override
final MutableInteger mut = map . get ( object ) ; size += nCopies ; if ( mut == null ) { map . put ( object , new MutableInteger ( nCopies ) ) ; return true ; } mut . value += nCopies ; return false ; MST[InlineConstantMutator]MSP[S] }
buf . append ( '[' ) ; final Iterator < E > it = uniqueSet () . iterator () ; while ( it . hasNext () ) { MST[rv.ROR4Mutator]MSP[N] final Object current = it . next () ; final int count = getCount ( current ) ;
final MutableInteger mut = map . get ( object ) ; size += nCopies ; if ( mut == null ) { map . put ( object , new MutableInteger ( nCopies ) ) ; return true ; } mut . value += nCopies ; MST[rv.UOI1Mutator]MSP[N] return false ; }
modCount ++ ; if ( nCopies < mut . value ) { mut . value -= nCopies ; size -= nCopies ; } else { map . remove ( object ) ; size -= mut . value ; MST[rv.UOI2Mutator]MSP[S] } return true ; } @Override
for ( int index = getCount ( current ) ; index > 0 ; index -- ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] @SuppressWarnings ( lr_1 ) final T unchecked = ( T ) current ; array [ i ++ ] = unchecked ; } } while ( i < array . length ) {
for ( int index = getCount ( current ) ; index > 0 ; index -- ) { @SuppressWarnings ( lr_1 ) final T unchecked = ( T ) current ; array [ i ++ ] = unchecked ; } } while ( i < array . length ) { MST[rv.ROR2Mutator]MSP[N]
for ( int index = getCount ( current ) ; index > 0 ; index -- ) { MST[IncrementsMutator]MSP[N] result [ i ++ ] = current ; } } return result ; } @Override public < T > T [] toArray ( T [] array ) {
final int size = size () ; if ( array . length < size ) { MST[rv.ROR4Mutator]MSP[N] @SuppressWarnings ( lr_1 ) final T [] unchecked = ( T [] ) Array . newInstance ( array . getClass () . getComponentType () , size ) ; array = unchecked ; }
if ( other . getCount ( element ) != getCount ( element ) ) { return false ; } } return true ; MST[rv.CRCR5Mutator]MSP[N] } @Override public int hashCode () { int total = 0 ;
protected void doWriteObject ( final ObjectOutputStream out ) throws IOException { out . writeInt ( map . size () ) ; MST[VoidMethodCallMutator]MSP[N] for ( final Entry < E , MutableInteger > entry : map . entrySet () ) { out . writeObject ( entry . getKey () ) ;
final int entrySize = in . readInt () ; for ( int i = 0 ; i < entrySize ; i ++ ) { MST[rv.CRCR6Mutator]MSP[N] @SuppressWarnings ( lr_1 ) final E obj = ( E ) in . readObject () ; final int count = in . readInt () ;
array [ i ++ ] = null ; } return array ; MST[NullReturnValsMutator]MSP[N] } @Override public Set < E > uniqueSet () { if ( uniqueSet == null ) { uniqueSet = UnmodifiableSet . <E > unmodifiableSet ( map . keySet () ) ; } return uniqueSet ; }
total += ( element == null ? 0 : element . hashCode () ) ^ count . value ; } return total ; } @Override public String toString () { if ( size () == 0 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return lr_2 ; } final StringBuilder buf = new StringBuilder () ;
final boolean changed = remove ( i . next () , 1 ) ; result = result || changed ; } } return result ; } @Override public boolean retainAll ( final Collection < ? > coll ) { if ( coll instanceof Bag ) { MST[rv.ROR5Mutator]MSP[S]
final boolean added = add ( i . next () ) ; changed = changed || added ; MST[NegateConditionalsMutator]MSP[S] } return changed ; } @Override public void clear () { modCount ++ ; map . clear () ; size = 0 ; } @Override
final int entrySize = in . readInt () ; for ( int i = 0 ; i < entrySize ; i ++ ) { MST[rv.UOI3Mutator]MSP[S] @SuppressWarnings ( lr_1 ) final E obj = ( E ) in . readObject () ; final int count = in . readInt () ;
final boolean added = add ( i . next () ) ; changed = changed || added ; } return changed ; MST[ReturnValsMutator]MSP[S] } @Override public void clear () { modCount ++ ; map . clear () ; size = 0 ; } @Override
for ( int index = getCount ( current ) ; index > 0 ; index -- ) { MST[rv.ROR4Mutator]MSP[N] @SuppressWarnings ( lr_1 ) final T unchecked = ( T ) current ; array [ i ++ ] = unchecked ; } } while ( i < array . length ) {
final MutableInteger mut = map . get ( object ) ; size += nCopies ; if ( mut == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] map . put ( object , new MutableInteger ( nCopies ) ) ; return true ; } mut . value += nCopies ; return false ; }
buf . append ( count ) ; buf . append ( ':' ) ; MST[rv.CRCR4Mutator]MSP[N] buf . append ( current ) ; if ( it . hasNext () ) { buf . append ( ',' ) ; } } buf . append ( ']' ) ;
final MutableInteger mut = map . get ( object ) ; size += nCopies ; if ( mut == null ) { map . put ( object , new MutableInteger ( nCopies ) ) ; return true ; MST[rv.CRCR3Mutator]MSP[S] } mut . value += nCopies ; return false ; }
total += ( element == null ? 0 : element . hashCode () ) ^ count . value ; } return total ; MST[ReturnValsMutator]MSP[N] } @Override public String toString () { if ( size () == 0 ) { return lr_2 ; } final StringBuilder buf = new StringBuilder () ;
final boolean added = add ( i . next () ) ; changed = changed || added ; MST[rv.UOI4Mutator]MSP[S] } return changed ; } @Override public void clear () { modCount ++ ; map . clear () ; size = 0 ; } @Override
final int entrySize = in . readInt () ; for ( int i = 0 ; i < entrySize ; i ++ ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[S] @SuppressWarnings ( lr_1 ) final E obj = ( E ) in . readObject () ; final int count = in . readInt () ;
final MutableInteger count = map . get ( object ) ; if ( count != null ) { return count . value ; } return 0 ; MST[rv.CRCR1Mutator]MSP[S] } @Override public boolean contains ( final Object object ) { return map . containsKey ( object ) ; } @Override
modCount ++ ; if ( nCopies < mut . value ) { mut . value -= nCopies ; size -= nCopies ; MST[rv.AOR3Mutator]MSP[N] } else { map . remove ( object ) ; size -= mut . value ; } return true ; } @Override
final MutableInteger count = map . get ( object ) ; if ( count != null ) { return count . value ; } return 0 ; MST[rv.CRCR5Mutator]MSP[S] } @Override public boolean contains ( final Object object ) { return map . containsKey ( object ) ; } @Override
map . put ( obj , new MutableInteger ( count ) ) ; size += count ; MST[rv.AOD1Mutator]MSP[S] } } @Override public boolean equals ( final Object object ) { if ( object == this ) { return true ; } if ( object instanceof Bag == false ) {
final boolean added = add ( i . next () ) ; changed = changed || added ; MST[rv.CRCR5Mutator]MSP[S] } return changed ; } @Override public void clear () { modCount ++ ; map . clear () ; size = 0 ; } @Override
modCount ++ ; if ( nCopies < mut . value ) { MST[rv.ABSMutator]MSP[N] mut . value -= nCopies ; size -= nCopies ; } else { map . remove ( object ) ; size -= mut . value ; } return true ; } @Override
map . put ( obj , new MutableInteger ( count ) ) ; size += count ; } } @Override public boolean equals ( final Object object ) { if ( object == this ) { return true ; MST[ReturnValsMutator]MSP[S] } if ( object instanceof Bag == false ) {
final boolean added = add ( i . next () ) ; changed = changed || added ; MST[rv.ROR5Mutator]MSP[S] } return changed ; } @Override public void clear () { modCount ++ ; map . clear () ; size = 0 ; } @Override
for ( int index = getCount ( current ) ; index > 0 ; index -- ) { MST[rv.UOI2Mutator]MSP[N] result [ i ++ ] = current ; } } return result ; } @Override public < T > T [] toArray ( T [] array ) {
buf . append ( count ) ; buf . append ( ':' ) ; buf . append ( current ) ; if ( it . hasNext () ) { buf . append ( ',' ) ; MST[rv.CRCR4Mutator]MSP[N] } } buf . append ( ']' ) ;
final MutableInteger mut = map . get ( object ) ; size += nCopies ; MST[rv.AOR3Mutator]MSP[N] if ( mut == null ) { map . put ( object , new MutableInteger ( nCopies ) ) ; return true ; } mut . value += nCopies ; return false ; }
for ( int index = getCount ( current ) ; index > 0 ; index -- ) { MST[rv.ROR3Mutator]MSP[N] result [ i ++ ] = current ; } } return result ; } @Override public < T > T [] toArray ( T [] array ) {
public boolean removeAll ( final Collection < ? > coll ) { boolean result = false ; MST[rv.CRCR1Mutator]MSP[S] if ( coll != null ) { final Iterator < ? > i = coll . iterator () ; while ( i . hasNext () ) {
return false ; } @Override public boolean addAll ( final Collection < ? extends E > coll ) { boolean changed = false ; final Iterator < ? extends E > i = coll . iterator () ; while ( i . hasNext () ) { MST[rv.ROR2Mutator]MSP[S]
return false ; } final Bag < ? > other = ( Bag < ? > ) object ; if ( other . size () != size () ) { MST[NonVoidMethodCallMutator]MSP[S] return false ; } for ( final E element : map . keySet () ) {
} @Override public boolean remove ( final Object object , final int nCopies ) { final MutableInteger mut = map . get ( object ) ; if ( mut == null ) { return false ; } if ( nCopies <= 0 ) { MST[rv.UOI1Mutator]MSP[N] return false ; }
canRemove = false ; } @Override public boolean add ( final E object ) { return add ( object , 1 ) ; } @Override public boolean add ( final E object , final int nCopies ) { modCount ++ ; MST[rv.CRCR6Mutator]MSP[S] if ( nCopies > 0 ) {
map . put ( obj , new MutableInteger ( count ) ) ; size += count ; MST[rv.AOR3Mutator]MSP[S] } } @Override public boolean equals ( final Object object ) { if ( object == this ) { return true ; } if ( object instanceof Bag == false ) {
final MutableInteger count = map . get ( object ) ; MST[ArgumentPropagationMutator]MSP[N] if ( count != null ) { return count . value ; } return 0 ; } @Override public boolean contains ( final Object object ) { return map . containsKey ( object ) ; } @Override
final Object [] result = new Object [ size () ] ; int i = 0 ; MST[rv.CRCR3Mutator]MSP[N] final Iterator < E > it = map . keySet () . iterator () ; while ( it . hasNext () ) { final E current = it . next () ;
for ( int index = getCount ( current ) ; index > 0 ; index -- ) { MST[ConditionalsBoundaryMutator]MSP[N] result [ i ++ ] = current ; } } return result ; } @Override public < T > T [] toArray ( T [] array ) {
map . put ( obj , new MutableInteger ( count ) ) ; MST[rv.UOI3Mutator]MSP[S] size += count ; } } @Override public boolean equals ( final Object object ) { if ( object == this ) { return true ; } if ( object instanceof Bag == false ) {
map . put ( obj , new MutableInteger ( count ) ) ; size += count ; } } @Override public boolean equals ( final Object object ) { if ( object == this ) { return true ; } if ( object instanceof Bag == false ) { MST[rv.ROR3Mutator]MSP[N]
for ( int index = getCount ( current ) ; index > 0 ; index -- ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] result [ i ++ ] = current ; } } return result ; } @Override public < T > T [] toArray ( T [] array ) {
array [ i ++ ] = null ; } return array ; } @Override public Set < E > uniqueSet () { if ( uniqueSet == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] uniqueSet = UnmodifiableSet . <E > unmodifiableSet ( map . keySet () ) ; } return uniqueSet ; }
buf . append ( '[' ) ; final Iterator < E > it = uniqueSet () . iterator () ; while ( it . hasNext () ) { MST[NonVoidMethodCallMutator]MSP[N] final Object current = it . next () ; final int count = getCount ( current ) ;
return false ; MST[BooleanTrueReturnValsMutator]MSP[S] } final Bag < ? > other = ( Bag < ? > ) object ; if ( other . size () != size () ) { return false ; } for ( final E element : map . keySet () ) {
return false ; } final Bag < ? > other = ( Bag < ? > ) object ; if ( other . size () != size () ) { MST[rv.ROR3Mutator]MSP[N] return false ; } for ( final E element : map . keySet () ) {
final boolean added = add ( i . next () ) ; changed = changed || added ; MST[rv.ROR2Mutator]MSP[S] } return changed ; } @Override public void clear () { modCount ++ ; map . clear () ; size = 0 ; } @Override
return false ; } @Override public boolean addAll ( final Collection < ? extends E > coll ) { boolean changed = false ; final Iterator < ? extends E > i = coll . iterator () ; while ( i . hasNext () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
final MutableInteger mut = map . get ( object ) ; size += nCopies ; MST[rv.AOD1Mutator]MSP[N] if ( mut == null ) { map . put ( object , new MutableInteger ( nCopies ) ) ; return true ; } mut . value += nCopies ; return false ; }
return false ; MST[rv.CRCR3Mutator]MSP[S] } final Bag < ? > other = ( Bag < ? > ) object ; if ( other . size () != size () ) { return false ; } for ( final E element : map . keySet () ) {
final MutableInteger mut = map . get ( object ) ; MST[ArgumentPropagationMutator]MSP[N] size += nCopies ; if ( mut == null ) { map . put ( object , new MutableInteger ( nCopies ) ) ; return true ; } mut . value += nCopies ; return false ; }
modCount ++ ; if ( nCopies < mut . value ) { mut . value -= nCopies ; size -= nCopies ; } else { map . remove ( object ) ; size -= mut . value ; MST[rv.UOI2Mutator]MSP[S] } return true ; } @Override
for ( int index = getCount ( current ) ; index > 0 ; index -- ) { @SuppressWarnings ( lr_1 ) final T unchecked = ( T ) current ; array [ i ++ ] = unchecked ; } } while ( i < array . length ) { MST[rv.UOI1Mutator]MSP[N]
final MutableInteger mut = map . get ( object ) ; size += nCopies ; MST[rv.ABSMutator]MSP[N] if ( mut == null ) { map . put ( object , new MutableInteger ( nCopies ) ) ; return true ; } mut . value += nCopies ; return false ; }
for ( int index = getCount ( current ) ; index > 0 ; index -- ) { MST[rv.UOI3Mutator]MSP[N] @SuppressWarnings ( lr_1 ) final T unchecked = ( T ) current ; array [ i ++ ] = unchecked ; } } while ( i < array . length ) {
modCount ++ ; MST[rv.AOR2Mutator]MSP[S] if ( nCopies < mut . value ) { mut . value -= nCopies ; size -= nCopies ; } else { map . remove ( object ) ; size -= mut . value ; } return true ; } @Override
final boolean added = add ( i . next () ) ; changed = changed || added ; MST[NegateConditionalsMutator]MSP[S] } return changed ; } @Override public void clear () { modCount ++ ; map . clear () ; size = 0 ; } @Override
final boolean added = add ( i . next () ) ; changed = changed || added ; MST[rv.CRCR2Mutator]MSP[S] } return changed ; } @Override public void clear () { modCount ++ ; map . clear () ; size = 0 ; } @Override
} @Override public boolean remove ( final Object object , final int nCopies ) { final MutableInteger mut = map . get ( object ) ; if ( mut == null ) { return false ; } if ( nCopies <= 0 ) { MST[rv.ABSMutator]MSP[N] return false ; }
final MutableInteger mut = map . get ( object ) ; size += nCopies ; if ( mut == null ) { MST[rv.ROR5Mutator]MSP[N] map . put ( object , new MutableInteger ( nCopies ) ) ; return true ; } mut . value += nCopies ; return false ; }
final int size = size () ; if ( array . length < size ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] @SuppressWarnings ( lr_1 ) final T [] unchecked = ( T [] ) Array . newInstance ( array . getClass () . getComponentType () , size ) ; array = unchecked ; }
final MutableInteger mut = map . get ( object ) ; size += nCopies ; if ( mut == null ) { map . put ( object , new MutableInteger ( nCopies ) ) ; return true ; } mut . value += nCopies ; return false ; MST[rv.CRCR3Mutator]MSP[S] }
final Object [] result = new Object [ size () ] ; MST[NonVoidMethodCallMutator]MSP[N] int i = 0 ; final Iterator < E > it = map . keySet () . iterator () ; while ( it . hasNext () ) { final E current = it . next () ;
for ( int index = getCount ( current ) ; index > 0 ; index -- ) { MST[rv.ABSMutator]MSP[N] @SuppressWarnings ( lr_1 ) final T unchecked = ( T ) current ; array [ i ++ ] = unchecked ; } } while ( i < array . length ) {
for ( int index = getCount ( current ) ; index > 0 ; index -- ) { @SuppressWarnings ( lr_1 ) final T unchecked = ( T ) current ; array [ i ++ ] = unchecked ; MST[rv.UOI1Mutator]MSP[N] } } while ( i < array . length ) {
final int entrySize = in . readInt () ; for ( int i = 0 ; i < entrySize ; i ++ ) { MST[ConditionalsBoundaryMutator]MSP[N] @SuppressWarnings ( lr_1 ) final E obj = ( E ) in . readObject () ; final int count = in . readInt () ;
canRemove = false ; } @Override public boolean add ( final E object ) { return add ( object , 1 ) ; } @Override public boolean add ( final E object , final int nCopies ) { modCount ++ ; if ( nCopies > 0 ) { MST[rv.ROR4Mutator]MSP[N]
modCount ++ ; MST[rv.UOI4Mutator]MSP[S] if ( nCopies < mut . value ) { mut . value -= nCopies ; size -= nCopies ; } else { map . remove ( object ) ; size -= mut . value ; } return true ; } @Override
for ( int index = getCount ( current ) ; index > 0 ; index -- ) { MST[NonVoidMethodCallMutator]MSP[N] @SuppressWarnings ( lr_1 ) final T unchecked = ( T ) current ; array [ i ++ ] = unchecked ; } } while ( i < array . length ) {
modCount ++ ; if ( nCopies < mut . value ) { mut . value -= nCopies ; MST[rv.AOR1Mutator]MSP[N] size -= nCopies ; } else { map . remove ( object ) ; size -= mut . value ; } return true ; } @Override
final Object [] result = new Object [ size () ] ; int i = 0 ; final Iterator < E > it = map . keySet () . iterator () ; while ( it . hasNext () ) { MST[rv.ROR3Mutator]MSP[N] final E current = it . next () ;
final int entrySize = in . readInt () ; for ( int i = 0 ; i < entrySize ; i ++ ) { MST[rv.ROR5Mutator]MSP[N] @SuppressWarnings ( lr_1 ) final E obj = ( E ) in . readObject () ; final int count = in . readInt () ;
final boolean added = add ( i . next () ) ; changed = changed || added ; MST[rv.UOI4Mutator]MSP[S] } return changed ; } @Override public void clear () { modCount ++ ; map . clear () ; size = 0 ; } @Override
final Object [] result = new Object [ size () ] ; int i = 0 ; final Iterator < E > it = map . keySet () . iterator () ; while ( it . hasNext () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] final E current = it . next () ;
modCount ++ ; MST[experimental.MemberVariableMutator]MSP[S] if ( nCopies < mut . value ) { mut . value -= nCopies ; size -= nCopies ; } else { map . remove ( object ) ; size -= mut . value ; } return true ; } @Override
modCount ++ ; if ( nCopies < mut . value ) { mut . value -= nCopies ; size -= nCopies ; MST[rv.UOI1Mutator]MSP[N] } else { map . remove ( object ) ; size -= mut . value ; } return true ; } @Override
map . put ( obj , new MutableInteger ( count ) ) ; size += count ; MST[rv.UOI1Mutator]MSP[N] } } @Override public boolean equals ( final Object object ) { if ( object == this ) { return true ; } if ( object instanceof Bag == false ) {
return false ; } final Bag < ? > other = ( Bag < ? > ) object ; if ( other . size () != size () ) { MST[NonVoidMethodCallMutator]MSP[S] return false ; } for ( final E element : map . keySet () ) {
modCount ++ ; if ( nCopies < mut . value ) { mut . value -= nCopies ; size -= nCopies ; } else { map . remove ( object ) ; size -= mut . value ; MST[MathMutator]MSP[N] } return true ; } @Override
modCount ++ ; if ( nCopies < mut . value ) { MST[rv.ROR4Mutator]MSP[S] mut . value -= nCopies ; size -= nCopies ; } else { map . remove ( object ) ; size -= mut . value ; } return true ; } @Override
modCount ++ ; if ( nCopies < mut . value ) { mut . value -= nCopies ; size -= nCopies ; } else { map . remove ( object ) ; size -= mut . value ; MST[rv.AOR4Mutator]MSP[N] } return true ; } @Override
for ( int index = getCount ( current ) ; index > 0 ; index -- ) { @SuppressWarnings ( lr_1 ) final T unchecked = ( T ) current ; array [ i ++ ] = unchecked ; MST[IncrementsMutator]MSP[N] } } while ( i < array . length ) {
} @Override public boolean remove ( final Object object , final int nCopies ) { final MutableInteger mut = map . get ( object ) ; if ( mut == null ) { return false ; MST[ReturnValsMutator]MSP[N] } if ( nCopies <= 0 ) { return false ; }
final boolean added = add ( i . next () ) ; changed = changed || added ; } return changed ; } @Override public void clear () { modCount ++ ; MST[rv.AOR1Mutator]MSP[N] map . clear () ; size = 0 ; } @Override
map . put ( obj , new MutableInteger ( count ) ) ; size += count ; MST[rv.ABSMutator]MSP[S] } } @Override public boolean equals ( final Object object ) { if ( object == this ) { return true ; } if ( object instanceof Bag == false ) {
final int size = size () ; if ( array . length < size ) { @SuppressWarnings ( lr_1 ) final T [] unchecked = ( T [] ) Array . newInstance ( array . getClass () . getComponentType () , size ) ; MST[rv.UOI1Mutator]MSP[N] array = unchecked ; }
final int size = size () ; if ( array . length < size ) { MST[rv.ROR1Mutator]MSP[N] @SuppressWarnings ( lr_1 ) final T [] unchecked = ( T [] ) Array . newInstance ( array . getClass () . getComponentType () , size ) ; array = unchecked ; }
canRemove = false ; } @Override public boolean add ( final E object ) { return add ( object , 1 ) ; MST[rv.CRCR2Mutator]MSP[N] } @Override public boolean add ( final E object , final int nCopies ) { modCount ++ ; if ( nCopies > 0 ) {
final Object [] result = new Object [ size () ] ; int i = 0 ; final Iterator < E > it = map . keySet () . iterator () ; while ( it . hasNext () ) { MST[NegateConditionalsMutator]MSP[N] final E current = it . next () ;
final int entrySize = in . readInt () ; for ( int i = 0 ; i < entrySize ; i ++ ) { MST[rv.UOI4Mutator]MSP[S] @SuppressWarnings ( lr_1 ) final E obj = ( E ) in . readObject () ; final int count = in . readInt () ;
modCount ++ ; if ( nCopies < mut . value ) { mut . value -= nCopies ; size -= nCopies ; } else { map . remove ( object ) ; size -= mut . value ; MST[experimental.MemberVariableMutator]MSP[N] } return true ; } @Override
final boolean changed = remove ( i . next () , 1 ) ; result = result || changed ; } } return result ; } @Override public boolean retainAll ( final Collection < ? > coll ) { if ( coll instanceof Bag ) { MST[rv.ROR2Mutator]MSP[N]
out . writeInt ( entry . getValue () . value ) ; MST[rv.UOI2Mutator]MSP[N] } } protected void doReadObject ( final Map < E , MutableInteger > map , final ObjectInputStream in ) throws IOException , ClassNotFoundException { this . map = map ;
final int entrySize = in . readInt () ; for ( int i = 0 ; i < entrySize ; i ++ ) { MST[rv.ABSMutator]MSP[N] @SuppressWarnings ( lr_1 ) final E obj = ( E ) in . readObject () ; final int count = in . readInt () ;
map . put ( obj , new MutableInteger ( count ) ) ; size += count ; } } @Override public boolean equals ( final Object object ) { if ( object == this ) { return true ; MST[BooleanFalseReturnValsMutator]MSP[S] } if ( object instanceof Bag == false ) {
final MutableInteger count = map . get ( object ) ; if ( count != null ) { return count . value ; } return 0 ; MST[InlineConstantMutator]MSP[S] } @Override public boolean contains ( final Object object ) { return map . containsKey ( object ) ; } @Override
modCount ++ ; if ( nCopies < mut . value ) { mut . value -= nCopies ; MST[rv.UOI1Mutator]MSP[N] size -= nCopies ; } else { map . remove ( object ) ; size -= mut . value ; } return true ; } @Override
modCount ++ ; if ( nCopies < mut . value ) { mut . value -= nCopies ; size -= nCopies ; MST[rv.UOI3Mutator]MSP[N] } else { map . remove ( object ) ; size -= mut . value ; } return true ; } @Override
modCount ++ ; if ( nCopies < mut . value ) { mut . value -= nCopies ; size -= nCopies ; } else { map . remove ( object ) ; size -= mut . value ; } return true ; MST[rv.CRCR5Mutator]MSP[N] } @Override
} @Override public boolean remove ( final Object object , final int nCopies ) { final MutableInteger mut = map . get ( object ) ; MST[ArgumentPropagationMutator]MSP[N] if ( mut == null ) { return false ; } if ( nCopies <= 0 ) { return false ; }
final MutableInteger mut = map . get ( object ) ; size += nCopies ; if ( mut == null ) { map . put ( object , new MutableInteger ( nCopies ) ) ; return true ; } mut . value += nCopies ; MST[rv.UOI2Mutator]MSP[N] return false ; }
final int entrySize = in . readInt () ; for ( int i = 0 ; i < entrySize ; i ++ ) { @SuppressWarnings ( lr_1 ) final E obj = ( E ) in . readObject () ; final int count = in . readInt () ; MST[NonVoidMethodCallMutator]MSP[N]
buf . append ( '[' ) ; final Iterator < E > it = uniqueSet () . iterator () ; MST[NonVoidMethodCallMutator]MSP[S] while ( it . hasNext () ) { final Object current = it . next () ; final int count = getCount ( current ) ;
final boolean added = add ( i . next () ) ; changed = changed || added ; } return changed ; MST[BooleanFalseReturnValsMutator]MSP[S] } @Override public void clear () { modCount ++ ; map . clear () ; size = 0 ; } @Override
} @Override public boolean remove ( final Object object , final int nCopies ) { final MutableInteger mut = map . get ( object ) ; if ( mut == null ) { return false ; } if ( nCopies <= 0 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] return false ; }
final int size = size () ; if ( array . length < size ) { MST[rv.ABSMutator]MSP[N] @SuppressWarnings ( lr_1 ) final T [] unchecked = ( T [] ) Array . newInstance ( array . getClass () . getComponentType () , size ) ; array = unchecked ; }
final boolean changed = remove ( i . next () , 1 ) ; result = result || changed ; } } return result ; MST[rv.UOI3Mutator]MSP[S] } @Override public boolean retainAll ( final Collection < ? > coll ) { if ( coll instanceof Bag ) {
canRemove = false ; } @Override public boolean add ( final E object ) { return add ( object , 1 ) ; } @Override public boolean add ( final E object , final int nCopies ) { modCount ++ ; MST[InlineConstantMutator]MSP[S] if ( nCopies > 0 ) {
return false ; } final Bag < ? > other = ( Bag < ? > ) object ; if ( other . size () != size () ) { return false ; } for ( final E element : map . keySet () ) { MST[NonVoidMethodCallMutator]MSP[N]
final Object [] result = new Object [ size () ] ; int i = 0 ; MST[InlineConstantMutator]MSP[N] final Iterator < E > it = map . keySet () . iterator () ; while ( it . hasNext () ) { final E current = it . next () ;
protected Map < E , MutableInteger > getMap () { return map ; MST[ReturnValsMutator]MSP[N] } @Override public int size () { return size ; } @Override public boolean isEmpty () { return map . isEmpty () ; } @Override public int getCount ( final Object object ) {
for ( int index = getCount ( current ) ; index > 0 ; index -- ) { @SuppressWarnings ( lr_1 ) final T unchecked = ( T ) current ; array [ i ++ ] = unchecked ; MST[rv.UOI4Mutator]MSP[N] } } while ( i < array . length ) {
buf . append ( count ) ; buf . append ( ':' ) ; buf . append ( current ) ; if ( it . hasNext () ) { MST[rv.ROR1Mutator]MSP[N] buf . append ( ',' ) ; } } buf . append ( ']' ) ;
canRemove = false ; } @Override public boolean add ( final E object ) { return add ( object , 1 ) ; } @Override public boolean add ( final E object , final int nCopies ) { modCount ++ ; if ( nCopies > 0 ) { MST[rv.ABSMutator]MSP[N]
canRemove = false ; } @Override public boolean add ( final E object ) { return add ( object , 1 ) ; } @Override public boolean add ( final E object , final int nCopies ) { modCount ++ ; if ( nCopies > 0 ) { MST[rv.ROR1Mutator]MSP[S]
final Object [] result = new Object [ size () ] ; int i = 0 ; final Iterator < E > it = map . keySet () . iterator () ; while ( it . hasNext () ) { MST[rv.ROR5Mutator]MSP[N] final E current = it . next () ;
final int size = size () ; if ( array . length < size ) { @SuppressWarnings ( lr_1 ) final T [] unchecked = ( T [] ) Array . newInstance ( array . getClass () . getComponentType () , size ) ; MST[rv.UOI4Mutator]MSP[N] array = unchecked ; }
if ( other . getCount ( element ) != getCount ( element ) ) { return false ; } } return true ; } @Override public int hashCode () { int total = 0 ; MST[rv.CRCR1Mutator]MSP[N]
return false ; MST[BooleanTrueReturnValsMutator]MSP[S] } @Override public boolean addAll ( final Collection < ? extends E > coll ) { boolean changed = false ; final Iterator < ? extends E > i = coll . iterator () ; while ( i . hasNext () ) {
modCount ++ ; if ( nCopies < mut . value ) { MST[rv.UOI3Mutator]MSP[N] mut . value -= nCopies ; size -= nCopies ; } else { map . remove ( object ) ; size -= mut . value ; } return true ; } @Override
return false ; MST[rv.CRCR6Mutator]MSP[S] } final Bag < ? > other = ( Bag < ? > ) object ; if ( other . size () != size () ) { return false ; } for ( final E element : map . keySet () ) {
modCount ++ ; if ( nCopies < mut . value ) { mut . value -= nCopies ; size -= nCopies ; } else { map . remove ( object ) ; size -= mut . value ; MST[rv.AOR2Mutator]MSP[N] } return true ; } @Override
map . put ( obj , new MutableInteger ( count ) ) ; size += count ; MST[rv.UOI3Mutator]MSP[S] } } @Override public boolean equals ( final Object object ) { if ( object == this ) { return true ; } if ( object instanceof Bag == false ) {
if ( getCount ( current ) < other . getCount ( current ) ) { return false ; } } return true ; } @Override public Iterator < E > iterator () { return new BagIterator <> ( this ) ; MST[NullReturnValsMutator]MSP[N] } @Override public boolean hasNext () {
canRemove = false ; } @Override public boolean add ( final E object ) { return add ( object , 1 ) ; MST[rv.CRCR4Mutator]MSP[N] } @Override public boolean add ( final E object , final int nCopies ) { modCount ++ ; if ( nCopies > 0 ) {
return false ; MST[rv.CRCR1Mutator]MSP[S] } @Override public boolean addAll ( final Collection < ? extends E > coll ) { boolean changed = false ; final Iterator < ? extends E > i = coll . iterator () ; while ( i . hasNext () ) {
modCount ++ ; MST[rv.UOI1Mutator]MSP[S] if ( nCopies < mut . value ) { mut . value -= nCopies ; size -= nCopies ; } else { map . remove ( object ) ; size -= mut . value ; } return true ; } @Override
map . put ( obj , new MutableInteger ( count ) ) ; size += count ; } } @Override public boolean equals ( final Object object ) { if ( object == this ) { return true ; MST[rv.CRCR4Mutator]MSP[N] } if ( object instanceof Bag == false ) {
if ( other . getCount ( element ) != getCount ( element ) ) { MST[NonVoidMethodCallMutator]MSP[S] return false ; } } return true ; } @Override public int hashCode () { int total = 0 ;
canRemove = false ; } @Override public boolean add ( final E object ) { return add ( object , 1 ) ; } @Override public boolean add ( final E object , final int nCopies ) { modCount ++ ; if ( nCopies > 0 ) { MST[rv.UOI3Mutator]MSP[N]
int i = 0 ; final Iterator < E > it = map . keySet () . iterator () ; while ( it . hasNext () ) { MST[NonVoidMethodCallMutator]MSP[N] final E current = it . next () ;
for ( int index = getCount ( current ) ; index > 0 ; index -- ) { @SuppressWarnings ( lr_1 ) final T unchecked = ( T ) current ; array [ i ++ ] = unchecked ; } } while ( i < array . length ) { MST[rv.UOI4Mutator]MSP[N]
map . put ( obj , new MutableInteger ( count ) ) ; size += count ; } } @Override public boolean equals ( final Object object ) { if ( object == this ) { return true ; } if ( object instanceof Bag == false ) { MST[rv.ROR1Mutator]MSP[N]
array [ i ++ ] = null ; } return array ; } @Override public Set < E > uniqueSet () { if ( uniqueSet == null ) { uniqueSet = UnmodifiableSet . <E > unmodifiableSet ( map . keySet () ) ; } return uniqueSet ; MST[ReturnValsMutator]MSP[N] }
} @Override public boolean remove ( final Object object , final int nCopies ) { final MutableInteger mut = map . get ( object ) ; if ( mut == null ) { return false ; MST[rv.CRCR1Mutator]MSP[N] } if ( nCopies <= 0 ) { return false ; }
return false ; } final Bag < ? > other = ( Bag < ? > ) object ; if ( other . size () != size () ) { MST[rv.ROR1Mutator]MSP[N] return false ; } for ( final E element : map . keySet () ) {
map . put ( obj , new MutableInteger ( count ) ) ; MST[ConstructorCallMutator]MSP[N] size += count ; } } @Override public boolean equals ( final Object object ) { if ( object == this ) { return true ; } if ( object instanceof Bag == false ) {
return false ; MST[rv.CRCR1Mutator]MSP[S] } final Bag < ? > other = ( Bag < ? > ) object ; if ( other . size () != size () ) { return false ; } for ( final E element : map . keySet () ) {
return false ; MST[ReturnValsMutator]MSP[S] } @Override public boolean addAll ( final Collection < ? extends E > coll ) { boolean changed = false ; final Iterator < ? extends E > i = coll . iterator () ; while ( i . hasNext () ) {
canRemove = false ; } @Override public boolean add ( final E object ) { return add ( object , 1 ) ; } @Override public boolean add ( final E object , final int nCopies ) { modCount ++ ; MST[rv.CRCR3Mutator]MSP[S] if ( nCopies > 0 ) {
array [ i ++ ] = null ; } return array ; } @Override public Set < E > uniqueSet () { if ( uniqueSet == null ) { uniqueSet = UnmodifiableSet . <E > unmodifiableSet ( map . keySet () ) ; MST[NonVoidMethodCallMutator]MSP[N] } return uniqueSet ; }
for ( int index = getCount ( current ) ; index > 0 ; index -- ) { MST[NegateConditionalsMutator]MSP[N] result [ i ++ ] = current ; } } return result ; } @Override public < T > T [] toArray ( T [] array ) {
buf . append ( '[' ) ; MST[experimental.NakedReceiverMutator]MSP[N] final Iterator < E > it = uniqueSet () . iterator () ; while ( it . hasNext () ) { final Object current = it . next () ; final int count = getCount ( current ) ;
buf . append ( '[' ) ; MST[rv.CRCR6Mutator]MSP[N] final Iterator < E > it = uniqueSet () . iterator () ; while ( it . hasNext () ) { final Object current = it . next () ; final int count = getCount ( current ) ;
if ( other . getCount ( element ) != getCount ( element ) ) { return false ; } } return true ; MST[InlineConstantMutator]MSP[N] } @Override public int hashCode () { int total = 0 ;
} @Override public boolean remove ( final Object object , final int nCopies ) { final MutableInteger mut = map . get ( object ) ; if ( mut == null ) { return false ; } if ( nCopies <= 0 ) { MST[rv.ROR4Mutator]MSP[N] return false ; }
total += ( element == null ? 0 : element . hashCode () ) ^ count . value ; } return total ; } @Override public String toString () { if ( size () == 0 ) { MST[rv.ROR2Mutator]MSP[N] return lr_2 ; } final StringBuilder buf = new StringBuilder () ;
final boolean added = add ( i . next () ) ; changed = changed || added ; } return changed ; } @Override public void clear () { modCount ++ ; MST[rv.CRCR4Mutator]MSP[N] map . clear () ; size = 0 ; } @Override
final boolean changed = remove ( i . next () , 1 ) ; result = result || changed ; } } return result ; MST[BooleanFalseReturnValsMutator]MSP[N] } @Override public boolean retainAll ( final Collection < ? > coll ) { if ( coll instanceof Bag ) {
final MutableInteger mut = map . get ( object ) ; size += nCopies ; MST[rv.UOI3Mutator]MSP[N] if ( mut == null ) { map . put ( object , new MutableInteger ( nCopies ) ) ; return true ; } mut . value += nCopies ; return false ; }
buf . append ( count ) ; buf . append ( ':' ) ; MST[rv.CRCR2Mutator]MSP[N] buf . append ( current ) ; if ( it . hasNext () ) { buf . append ( ',' ) ; } } buf . append ( ']' ) ;
final boolean added = add ( i . next () ) ; changed = changed || added ; } return changed ; MST[BooleanTrueReturnValsMutator]MSP[S] } @Override public void clear () { modCount ++ ; map . clear () ; size = 0 ; } @Override
modCount ++ ; if ( nCopies < mut . value ) { MST[rv.UOI3Mutator]MSP[N] mut . value -= nCopies ; size -= nCopies ; } else { map . remove ( object ) ; size -= mut . value ; } return true ; } @Override
if ( other . getCount ( element ) != getCount ( element ) ) { return false ; } } return true ; } @Override public int hashCode () { int total = 0 ; MST[rv.CRCR6Mutator]MSP[N]
final MutableInteger count = map . get ( object ) ; if ( count != null ) { return count . value ; } return 0 ; MST[rv.CRCR3Mutator]MSP[S] } @Override public boolean contains ( final Object object ) { return map . containsKey ( object ) ; } @Override
protected Map < E , MutableInteger > getMap () { return map ; } @Override public int size () { return size ; MST[rv.UOI4Mutator]MSP[N] } @Override public boolean isEmpty () { return map . isEmpty () ; } @Override public int getCount ( final Object object ) {
for ( int index = getCount ( current ) ; index > 0 ; index -- ) { @SuppressWarnings ( lr_1 ) final T unchecked = ( T ) current ; array [ i ++ ] = unchecked ; MST[experimental.RemoveIncrementsMutator]MSP[N] } } while ( i < array . length ) {
final boolean added = add ( i . next () ) ; changed = changed || added ; } return changed ; MST[rv.ABSMutator]MSP[N] } @Override public void clear () { modCount ++ ; map . clear () ; size = 0 ; } @Override
out . writeInt ( entry . getValue () . value ) ; MST[VoidMethodCallMutator]MSP[N] } } protected void doReadObject ( final Map < E , MutableInteger > map , final ObjectInputStream in ) throws IOException , ClassNotFoundException { this . map = map ;
modCount ++ ; if ( nCopies < mut . value ) { mut . value -= nCopies ; size -= nCopies ; MST[rv.UOI2Mutator]MSP[N] } else { map . remove ( object ) ; size -= mut . value ; } return true ; } @Override
buf . append ( '[' ) ; MST[rv.CRCR1Mutator]MSP[N] final Iterator < E > it = uniqueSet () . iterator () ; while ( it . hasNext () ) { final Object current = it . next () ; final int count = getCount ( current ) ;
buf . append ( '[' ) ; final Iterator < E > it = uniqueSet () . iterator () ; while ( it . hasNext () ) { MST[rv.ROR1Mutator]MSP[S] final Object current = it . next () ; final int count = getCount ( current ) ;
map . put ( obj , new MutableInteger ( count ) ) ; size += count ; MST[rv.UOI2Mutator]MSP[N] } } @Override public boolean equals ( final Object object ) { if ( object == this ) { return true ; } if ( object instanceof Bag == false ) {
final boolean added = add ( i . next () ) ; changed = changed || added ; MST[rv.ROR5Mutator]MSP[S] } return changed ; } @Override public void clear () { modCount ++ ; map . clear () ; size = 0 ; } @Override
final MutableInteger mut = map . get ( object ) ; size += nCopies ; if ( mut == null ) { map . put ( object , new MutableInteger ( nCopies ) ) ; return true ; MST[rv.CRCR5Mutator]MSP[N] } mut . value += nCopies ; return false ; }
modCount ++ ; if ( nCopies < mut . value ) { mut . value -= nCopies ; MST[rv.AOD2Mutator]MSP[S] size -= nCopies ; } else { map . remove ( object ) ; size -= mut . value ; } return true ; } @Override
array [ i ++ ] = null ; } return array ; } @Override public Set < E > uniqueSet () { if ( uniqueSet == null ) { uniqueSet = UnmodifiableSet . <E > unmodifiableSet ( map . keySet () ) ; MST[experimental.MemberVariableMutator]MSP[N] } return uniqueSet ; }
final MutableInteger mut = map . get ( object ) ; size += nCopies ; if ( mut == null ) { map . put ( object , new MutableInteger ( nCopies ) ) ; MST[rv.UOI2Mutator]MSP[S] return true ; } mut . value += nCopies ; return false ; }
buf . append ( count ) ; buf . append ( ':' ) ; buf . append ( current ) ; if ( it . hasNext () ) { buf . append ( ',' ) ; MST[rv.CRCR2Mutator]MSP[N] } } buf . append ( ']' ) ;
map . put ( obj , new MutableInteger ( count ) ) ; size += count ; } } @Override public boolean equals ( final Object object ) { if ( object == this ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] return true ; } if ( object instanceof Bag == false ) {
if ( other . getCount ( element ) != getCount ( element ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return false ; } } return true ; } @Override public int hashCode () { int total = 0 ;
for ( int index = getCount ( current ) ; index > 0 ; index -- ) { result [ i ++ ] = current ; MST[rv.UOI3Mutator]MSP[N] } } return result ; } @Override public < T > T [] toArray ( T [] array ) {
buf . append ( count ) ; MST[rv.UOI4Mutator]MSP[N] buf . append ( ':' ) ; buf . append ( current ) ; if ( it . hasNext () ) { buf . append ( ',' ) ; } } buf . append ( ']' ) ;
final boolean added = add ( i . next () ) ; changed = changed || added ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] } return changed ; } @Override public void clear () { modCount ++ ; map . clear () ; size = 0 ; } @Override
buf . append ( '[' ) ; final Iterator < E > it = uniqueSet () . iterator () ; while ( it . hasNext () ) { final Object current = it . next () ; final int count = getCount ( current ) ; MST[NonVoidMethodCallMutator]MSP[N]
return itemCount > 0 || entryIterator . hasNext () ; MST[rv.ROR1Mutator]MSP[S] } @Override public E next () { if ( parent . modCount != mods ) { throw new ConcurrentModificationException () ; } if ( itemCount == 0 ) { current = entryIterator . next () ;
return itemCount > 0 || entryIterator . hasNext () ; } @Override public E next () { if ( parent . modCount != mods ) { throw new ConcurrentModificationException () ; } if ( itemCount == 0 ) { current = entryIterator . next () ; MST[NonVoidMethodCallMutator]MSP[N]
return itemCount > 0 || entryIterator . hasNext () ; MST[rv.ROR2Mutator]MSP[N] } @Override public E next () { if ( parent . modCount != mods ) { throw new ConcurrentModificationException () ; } if ( itemCount == 0 ) { current = entryIterator . next () ;
return itemCount > 0 || entryIterator . hasNext () ; } @Override public E next () { if ( parent . modCount != mods ) { throw new ConcurrentModificationException () ; } if ( itemCount == 0 ) { current = entryIterator . next () ; MST[experimental.MemberVariableMutator]MSP[N]
if ( canRemove == false ) { throw new IllegalStateException () ; } final MutableInteger mut = current . getValue () ; if ( mut . value > 1 ) { MST[rv.CRCR5Mutator]MSP[S] mut . value -- ; } else { entryIterator . remove () ; } parent . size -- ;
return itemCount > 0 || entryIterator . hasNext () ; MST[rv.ROR2Mutator]MSP[N] } @Override public E next () { if ( parent . modCount != mods ) { throw new ConcurrentModificationException () ; } if ( itemCount == 0 ) { current = entryIterator . next () ;
return itemCount > 0 || entryIterator . hasNext () ; MST[rv.ROR5Mutator]MSP[N] } @Override public E next () { if ( parent . modCount != mods ) { throw new ConcurrentModificationException () ; } if ( itemCount == 0 ) { current = entryIterator . next () ;
return itemCount > 0 || entryIterator . hasNext () ; MST[rv.ROR3Mutator]MSP[N] } @Override public E next () { if ( parent . modCount != mods ) { throw new ConcurrentModificationException () ; } if ( itemCount == 0 ) { current = entryIterator . next () ;
return itemCount > 0 || entryIterator . hasNext () ; MST[rv.ROR1Mutator]MSP[N] } @Override public E next () { if ( parent . modCount != mods ) { throw new ConcurrentModificationException () ; } if ( itemCount == 0 ) { current = entryIterator . next () ;
return itemCount > 0 || entryIterator . hasNext () ; MST[rv.ROR4Mutator]MSP[N] } @Override public E next () { if ( parent . modCount != mods ) { throw new ConcurrentModificationException () ; } if ( itemCount == 0 ) { current = entryIterator . next () ;
itemCount = current . getValue () . value ; } canRemove = true ; itemCount -- ; return current . getKey () ; } @Override public void remove () { if ( parent . modCount != mods ) { MST[rv.UOI4Mutator]MSP[N] throw new ConcurrentModificationException () ; }
itemCount = current . getValue () . value ; MST[NonVoidMethodCallMutator]MSP[N] } canRemove = true ; itemCount -- ; return current . getKey () ; } @Override public void remove () { if ( parent . modCount != mods ) { throw new ConcurrentModificationException () ; }
itemCount = current . getValue () . value ; } canRemove = true ; itemCount -- ; return current . getKey () ; } @Override public void remove () { if ( parent . modCount != mods ) { MST[rv.UOI3Mutator]MSP[N] throw new ConcurrentModificationException () ; }
return itemCount > 0 || entryIterator . hasNext () ; MST[rv.ROR5Mutator]MSP[N] } @Override public E next () { if ( parent . modCount != mods ) { throw new ConcurrentModificationException () ; } if ( itemCount == 0 ) { current = entryIterator . next () ;
return itemCount > 0 || entryIterator . hasNext () ; MST[rv.ROR3Mutator]MSP[N] } @Override public E next () { if ( parent . modCount != mods ) { throw new ConcurrentModificationException () ; } if ( itemCount == 0 ) { current = entryIterator . next () ;
return itemCount > 0 || entryIterator . hasNext () ; MST[rv.ROR4Mutator]MSP[N] } @Override public E next () { if ( parent . modCount != mods ) { throw new ConcurrentModificationException () ; } if ( itemCount == 0 ) { current = entryIterator . next () ;
if ( canRemove == false ) { throw new IllegalStateException () ; } final MutableInteger mut = current . getValue () ; if ( mut . value > 1 ) { MST[rv.ROR3Mutator]MSP[S] mut . value -- ; } else { entryIterator . remove () ; } parent . size -- ;
if ( canRemove == false ) { throw new IllegalStateException () ; } final MutableInteger mut = current . getValue () ; if ( mut . value > 1 ) { MST[rv.ROR4Mutator]MSP[N] mut . value -- ; } else { entryIterator . remove () ; } parent . size -- ;
itemCount = current . getValue () . value ; } canRemove = true ; itemCount -- ; return current . getKey () ; } @Override public void remove () { if ( parent . modCount != mods ) { MST[rv.UOI2Mutator]MSP[N] throw new ConcurrentModificationException () ; }
itemCount = current . getValue () . value ; } canRemove = true ; MST[InlineConstantMutator]MSP[N] itemCount -- ; return current . getKey () ; } @Override public void remove () { if ( parent . modCount != mods ) { throw new ConcurrentModificationException () ; }
return itemCount > 0 || entryIterator . hasNext () ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] } @Override public E next () { if ( parent . modCount != mods ) { throw new ConcurrentModificationException () ; } if ( itemCount == 0 ) { current = entryIterator . next () ;
return itemCount > 0 || entryIterator . hasNext () ; MST[rv.ABSMutator]MSP[S] } @Override public E next () { if ( parent . modCount != mods ) { throw new ConcurrentModificationException () ; } if ( itemCount == 0 ) { current = entryIterator . next () ;
if ( canRemove == false ) { throw new IllegalStateException () ; } final MutableInteger mut = current . getValue () ; if ( mut . value > 1 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[S] mut . value -- ; } else { entryIterator . remove () ; } parent . size -- ;
return itemCount > 0 || entryIterator . hasNext () ; } @Override public E next () { if ( parent . modCount != mods ) { throw new ConcurrentModificationException () ; } if ( itemCount == 0 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] current = entryIterator . next () ;
return itemCount > 0 || entryIterator . hasNext () ; } @Override public E next () { if ( parent . modCount != mods ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] throw new ConcurrentModificationException () ; } if ( itemCount == 0 ) { current = entryIterator . next () ;
return itemCount > 0 || entryIterator . hasNext () ; } @Override public E next () { if ( parent . modCount != mods ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] throw new ConcurrentModificationException () ; } if ( itemCount == 0 ) { current = entryIterator . next () ;
return itemCount > 0 || entryIterator . hasNext () ; } @Override public E next () { if ( parent . modCount != mods ) { throw new ConcurrentModificationException () ; } if ( itemCount == 0 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] current = entryIterator . next () ;
return itemCount > 0 || entryIterator . hasNext () ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } @Override public E next () { if ( parent . modCount != mods ) { throw new ConcurrentModificationException () ; } if ( itemCount == 0 ) { current = entryIterator . next () ;
return itemCount > 0 || entryIterator . hasNext () ; } @Override public E next () { if ( parent . modCount != mods ) { MST[NegateConditionalsMutator]MSP[N] throw new ConcurrentModificationException () ; } if ( itemCount == 0 ) { current = entryIterator . next () ;
return itemCount > 0 || entryIterator . hasNext () ; } @Override public E next () { if ( parent . modCount != mods ) { MST[rv.ABSMutator]MSP[N] throw new ConcurrentModificationException () ; } if ( itemCount == 0 ) { current = entryIterator . next () ;
return itemCount > 0 || entryIterator . hasNext () ; } @Override public E next () { if ( parent . modCount != mods ) { throw new ConcurrentModificationException () ; } if ( itemCount == 0 ) { MST[NegateConditionalsMutator]MSP[N] current = entryIterator . next () ;
itemCount = current . getValue () . value ; } canRemove = true ; itemCount -- ; return current . getKey () ; } @Override public void remove () { if ( parent . modCount != mods ) { MST[rv.ROR3Mutator]MSP[N] throw new ConcurrentModificationException () ; }
return itemCount > 0 || entryIterator . hasNext () ; MST[rv.UOI4Mutator]MSP[N] } @Override public E next () { if ( parent . modCount != mods ) { throw new ConcurrentModificationException () ; } if ( itemCount == 0 ) { current = entryIterator . next () ;
itemCount = current . getValue () . value ; } canRemove = true ; itemCount -- ; return current . getKey () ; } @Override public void remove () { if ( parent . modCount != mods ) { MST[rv.ROR1Mutator]MSP[N] throw new ConcurrentModificationException () ; }
if ( canRemove == false ) { throw new IllegalStateException () ; } final MutableInteger mut = current . getValue () ; if ( mut . value > 1 ) { mut . value -- ; } else { entryIterator . remove () ; } parent . size -- ; MST[NonVoidMethodCallMutator]MSP[N]
return itemCount > 0 || entryIterator . hasNext () ; } @Override public E next () { if ( parent . modCount != mods ) { MST[rv.ROR2Mutator]MSP[N] throw new ConcurrentModificationException () ; } if ( itemCount == 0 ) { current = entryIterator . next () ;
return itemCount > 0 || entryIterator . hasNext () ; } @Override public E next () { if ( parent . modCount != mods ) { MST[rv.ROR4Mutator]MSP[N] throw new ConcurrentModificationException () ; } if ( itemCount == 0 ) { current = entryIterator . next () ;
return itemCount > 0 || entryIterator . hasNext () ; MST[rv.CRCR5Mutator]MSP[N] } @Override public E next () { if ( parent . modCount != mods ) { throw new ConcurrentModificationException () ; } if ( itemCount == 0 ) { current = entryIterator . next () ;
return itemCount > 0 || entryIterator . hasNext () ; } @Override public E next () { if ( parent . modCount != mods ) { throw new ConcurrentModificationException () ; } if ( itemCount == 0 ) { MST[rv.ROR4Mutator]MSP[N] current = entryIterator . next () ;
itemCount = current . getValue () . value ; } canRemove = true ; itemCount -- ; return current . getKey () ; } @Override public void remove () { if ( parent . modCount != mods ) { MST[rv.ROR5Mutator]MSP[N] throw new ConcurrentModificationException () ; }
return itemCount > 0 || entryIterator . hasNext () ; } @Override public E next () { if ( parent . modCount != mods ) { throw new ConcurrentModificationException () ; } if ( itemCount == 0 ) { MST[rv.ABSMutator]MSP[N] current = entryIterator . next () ;
return itemCount > 0 || entryIterator . hasNext () ; } @Override public E next () { if ( parent . modCount != mods ) { MST[NonVoidMethodCallMutator]MSP[N] throw new ConcurrentModificationException () ; } if ( itemCount == 0 ) { current = entryIterator . next () ;
if ( canRemove == false ) { MST[rv.ROR1Mutator]MSP[N] throw new IllegalStateException () ; } final MutableInteger mut = current . getValue () ; if ( mut . value > 1 ) { mut . value -- ; } else { entryIterator . remove () ; } parent . size -- ;
canRemove = false ; MST[experimental.MemberVariableMutator]MSP[N] } @Override public boolean add ( final E object ) { return add ( object , 1 ) ; } @Override public boolean add ( final E object , final int nCopies ) { modCount ++ ; if ( nCopies > 0 ) {
return itemCount > 0 || entryIterator . hasNext () ; MST[rv.CRCR3Mutator]MSP[N] } @Override public E next () { if ( parent . modCount != mods ) { throw new ConcurrentModificationException () ; } if ( itemCount == 0 ) { current = entryIterator . next () ;
return itemCount > 0 || entryIterator . hasNext () ; MST[rv.CRCR1Mutator]MSP[N] } @Override public E next () { if ( parent . modCount != mods ) { throw new ConcurrentModificationException () ; } if ( itemCount == 0 ) { current = entryIterator . next () ;
return itemCount > 0 || entryIterator . hasNext () ; } @Override public E next () { if ( parent . modCount != mods ) { throw new ConcurrentModificationException () ; } if ( itemCount == 0 ) { MST[rv.ROR2Mutator]MSP[N] current = entryIterator . next () ;
return itemCount > 0 || entryIterator . hasNext () ; MST[rv.CRCR5Mutator]MSP[N] } @Override public E next () { if ( parent . modCount != mods ) { throw new ConcurrentModificationException () ; } if ( itemCount == 0 ) { current = entryIterator . next () ;
return itemCount > 0 || entryIterator . hasNext () ; MST[rv.CRCR3Mutator]MSP[N] } @Override public E next () { if ( parent . modCount != mods ) { throw new ConcurrentModificationException () ; } if ( itemCount == 0 ) { current = entryIterator . next () ;
if ( canRemove == false ) { MST[rv.ROR5Mutator]MSP[N] throw new IllegalStateException () ; } final MutableInteger mut = current . getValue () ; if ( mut . value > 1 ) { mut . value -- ; } else { entryIterator . remove () ; } parent . size -- ;
if ( canRemove == false ) { MST[rv.ROR3Mutator]MSP[N] throw new IllegalStateException () ; } final MutableInteger mut = current . getValue () ; if ( mut . value > 1 ) { mut . value -- ; } else { entryIterator . remove () ; } parent . size -- ;
if ( canRemove == false ) { throw new IllegalStateException () ; } final MutableInteger mut = current . getValue () ; if ( mut . value > 1 ) { MST[rv.ABSMutator]MSP[S] mut . value -- ; } else { entryIterator . remove () ; } parent . size -- ;
return itemCount > 0 || entryIterator . hasNext () ; MST[NegateConditionalsMutator]MSP[N] } @Override public E next () { if ( parent . modCount != mods ) { throw new ConcurrentModificationException () ; } if ( itemCount == 0 ) { current = entryIterator . next () ;
if ( canRemove == false ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] throw new IllegalStateException () ; } final MutableInteger mut = current . getValue () ; if ( mut . value > 1 ) { mut . value -- ; } else { entryIterator . remove () ; } parent . size -- ;
itemCount = current . getValue () . value ; } canRemove = true ; itemCount -- ; MST[rv.AOR4Mutator]MSP[N] return current . getKey () ; } @Override public void remove () { if ( parent . modCount != mods ) { throw new ConcurrentModificationException () ; }
itemCount = current . getValue () . value ; } canRemove = true ; itemCount -- ; return current . getKey () ; MST[ReturnValsMutator]MSP[N] } @Override public void remove () { if ( parent . modCount != mods ) { throw new ConcurrentModificationException () ; }
return itemCount > 0 || entryIterator . hasNext () ; MST[rv.UOI3Mutator]MSP[N] } @Override public E next () { if ( parent . modCount != mods ) { throw new ConcurrentModificationException () ; } if ( itemCount == 0 ) { current = entryIterator . next () ;
itemCount = current . getValue () . value ; } canRemove = true ; MST[experimental.MemberVariableMutator]MSP[N] itemCount -- ; return current . getKey () ; } @Override public void remove () { if ( parent . modCount != mods ) { throw new ConcurrentModificationException () ; }
if ( canRemove == false ) { throw new IllegalStateException () ; } final MutableInteger mut = current . getValue () ; if ( mut . value > 1 ) { mut . value -- ; MST[rv.UOI1Mutator]MSP[N] } else { entryIterator . remove () ; } parent . size -- ;
if ( canRemove == false ) { throw new IllegalStateException () ; } final MutableInteger mut = current . getValue () ; if ( mut . value > 1 ) { mut . value -- ; MST[rv.UOI2Mutator]MSP[N] } else { entryIterator . remove () ; } parent . size -- ;
itemCount = current . getValue () . value ; } canRemove = true ; itemCount -- ; return current . getKey () ; } @Override public void remove () { if ( parent . modCount != mods ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] throw new ConcurrentModificationException () ; }
if ( canRemove == false ) { throw new IllegalStateException () ; } final MutableInteger mut = current . getValue () ; if ( mut . value > 1 ) { mut . value -- ; MST[rv.AOR1Mutator]MSP[S] } else { entryIterator . remove () ; } parent . size -- ;
canRemove = false ; MST[rv.CRCR5Mutator]MSP[N] } @Override public boolean add ( final E object ) { return add ( object , 1 ) ; } @Override public boolean add ( final E object , final int nCopies ) { modCount ++ ; if ( nCopies > 0 ) {
itemCount = current . getValue () . value ; } canRemove = true ; itemCount -- ; return current . getKey () ; } @Override public void remove () { if ( parent . modCount != mods ) { MST[NonVoidMethodCallMutator]MSP[N] throw new ConcurrentModificationException () ; }
itemCount = current . getValue () . value ; } canRemove = true ; MST[rv.CRCR2Mutator]MSP[N] itemCount -- ; return current . getKey () ; } @Override public void remove () { if ( parent . modCount != mods ) { throw new ConcurrentModificationException () ; }
if ( canRemove == false ) { MST[NegateConditionalsMutator]MSP[N] throw new IllegalStateException () ; } final MutableInteger mut = current . getValue () ; if ( mut . value > 1 ) { mut . value -- ; } else { entryIterator . remove () ; } parent . size -- ;
if ( canRemove == false ) { throw new IllegalStateException () ; } final MutableInteger mut = current . getValue () ; if ( mut . value > 1 ) { MST[rv.UOI4Mutator]MSP[S] mut . value -- ; } else { entryIterator . remove () ; } parent . size -- ;
itemCount = current . getValue () . value ; } canRemove = true ; itemCount -- ; return current . getKey () ; } @Override public void remove () { if ( parent . modCount != mods ) { MST[rv.ROR4Mutator]MSP[N] throw new ConcurrentModificationException () ; }
canRemove = false ; MST[rv.CRCR1Mutator]MSP[N] } @Override public boolean add ( final E object ) { return add ( object , 1 ) ; } @Override public boolean add ( final E object , final int nCopies ) { modCount ++ ; if ( nCopies > 0 ) {
return itemCount > 0 || entryIterator . hasNext () ; MST[RemoveConditionalMutator_ORDER_IF]MSP[S] } @Override public E next () { if ( parent . modCount != mods ) { throw new ConcurrentModificationException () ; } if ( itemCount == 0 ) { current = entryIterator . next () ;
return itemCount > 0 || entryIterator . hasNext () ; } @Override public E next () { if ( parent . modCount != mods ) { MST[rv.ROR1Mutator]MSP[N] throw new ConcurrentModificationException () ; } if ( itemCount == 0 ) { current = entryIterator . next () ;
return itemCount > 0 || entryIterator . hasNext () ; } @Override public E next () { if ( parent . modCount != mods ) { MST[rv.UOI4Mutator]MSP[N] throw new ConcurrentModificationException () ; } if ( itemCount == 0 ) { current = entryIterator . next () ;
return itemCount > 0 || entryIterator . hasNext () ; } @Override public E next () { if ( parent . modCount != mods ) { MST[rv.ROR5Mutator]MSP[N] throw new ConcurrentModificationException () ; } if ( itemCount == 0 ) { current = entryIterator . next () ;
return itemCount > 0 || entryIterator . hasNext () ; MST[rv.CRCR4Mutator]MSP[N] } @Override public E next () { if ( parent . modCount != mods ) { throw new ConcurrentModificationException () ; } if ( itemCount == 0 ) { current = entryIterator . next () ;
if ( canRemove == false ) { throw new IllegalStateException () ; } final MutableInteger mut = current . getValue () ; if ( mut . value > 1 ) { mut . value -- ; MST[rv.AOD2Mutator]MSP[N] } else { entryIterator . remove () ; } parent . size -- ;
return itemCount > 0 || entryIterator . hasNext () ; MST[NegateConditionalsMutator]MSP[N] } @Override public E next () { if ( parent . modCount != mods ) { throw new ConcurrentModificationException () ; } if ( itemCount == 0 ) { current = entryIterator . next () ;
return itemCount > 0 || entryIterator . hasNext () ; } @Override public E next () { if ( parent . modCount != mods ) { throw new ConcurrentModificationException () ; } if ( itemCount == 0 ) { MST[rv.ROR5Mutator]MSP[N] current = entryIterator . next () ;
itemCount = current . getValue () . value ; } canRemove = true ; MST[rv.CRCR6Mutator]MSP[N] itemCount -- ; return current . getKey () ; } @Override public void remove () { if ( parent . modCount != mods ) { throw new ConcurrentModificationException () ; }
return itemCount > 0 || entryIterator . hasNext () ; } @Override public E next () { if ( parent . modCount != mods ) { throw new ConcurrentModificationException () ; } if ( itemCount == 0 ) { MST[rv.UOI4Mutator]MSP[N] current = entryIterator . next () ;
return itemCount > 0 || entryIterator . hasNext () ; } @Override public E next () { if ( parent . modCount != mods ) { throw new ConcurrentModificationException () ; } if ( itemCount == 0 ) { MST[rv.ROR1Mutator]MSP[N] current = entryIterator . next () ;
return itemCount > 0 || entryIterator . hasNext () ; MST[ConditionalsBoundaryMutator]MSP[N] } @Override public E next () { if ( parent . modCount != mods ) { throw new ConcurrentModificationException () ; } if ( itemCount == 0 ) { current = entryIterator . next () ;
if ( canRemove == false ) { MST[rv.ROR4Mutator]MSP[S] throw new IllegalStateException () ; } final MutableInteger mut = current . getValue () ; if ( mut . value > 1 ) { mut . value -- ; } else { entryIterator . remove () ; } parent . size -- ;
itemCount = current . getValue () . value ; } canRemove = true ; itemCount -- ; return current . getKey () ; } @Override public void remove () { if ( parent . modCount != mods ) { MST[NegateConditionalsMutator]MSP[N] throw new ConcurrentModificationException () ; }
return itemCount > 0 || entryIterator . hasNext () ; MST[NonVoidMethodCallMutator]MSP[N] } @Override public E next () { if ( parent . modCount != mods ) { throw new ConcurrentModificationException () ; } if ( itemCount == 0 ) { current = entryIterator . next () ;
return itemCount > 0 || entryIterator . hasNext () ; } @Override public E next () { if ( parent . modCount != mods ) { MST[rv.UOI1Mutator]MSP[N] throw new ConcurrentModificationException () ; } if ( itemCount == 0 ) { current = entryIterator . next () ;
itemCount = current . getValue () . value ; } canRemove = true ; itemCount -- ; return current . getKey () ; MST[NonVoidMethodCallMutator]MSP[N] } @Override public void remove () { if ( parent . modCount != mods ) { throw new ConcurrentModificationException () ; }
if ( canRemove == false ) { throw new IllegalStateException () ; } final MutableInteger mut = current . getValue () ; if ( mut . value > 1 ) { mut . value -- ; MST[rv.AOR2Mutator]MSP[S] } else { entryIterator . remove () ; } parent . size -- ;
itemCount = current . getValue () . value ; } canRemove = true ; MST[rv.CRCR3Mutator]MSP[N] itemCount -- ; return current . getKey () ; } @Override public void remove () { if ( parent . modCount != mods ) { throw new ConcurrentModificationException () ; }
return itemCount > 0 || entryIterator . hasNext () ; MST[BooleanTrueReturnValsMutator]MSP[N] } @Override public E next () { if ( parent . modCount != mods ) { throw new ConcurrentModificationException () ; } if ( itemCount == 0 ) { current = entryIterator . next () ;
if ( canRemove == false ) { throw new IllegalStateException () ; } final MutableInteger mut = current . getValue () ; if ( mut . value > 1 ) { MST[rv.UOI3Mutator]MSP[N] mut . value -- ; } else { entryIterator . remove () ; } parent . size -- ;
canRemove = false ; MST[rv.CRCR6Mutator]MSP[N] } @Override public boolean add ( final E object ) { return add ( object , 1 ) ; } @Override public boolean add ( final E object , final int nCopies ) { modCount ++ ; if ( nCopies > 0 ) {
return itemCount > 0 || entryIterator . hasNext () ; } @Override public E next () { if ( parent . modCount != mods ) { MST[rv.UOI3Mutator]MSP[N] throw new ConcurrentModificationException () ; } if ( itemCount == 0 ) { current = entryIterator . next () ;
if ( canRemove == false ) { throw new IllegalStateException () ; } final MutableInteger mut = current . getValue () ; if ( mut . value > 1 ) { MST[rv.UOI1Mutator]MSP[S] mut . value -- ; } else { entryIterator . remove () ; } parent . size -- ;
itemCount = current . getValue () . value ; } canRemove = true ; itemCount -- ; return current . getKey () ; MST[NullReturnValsMutator]MSP[N] } @Override public void remove () { if ( parent . modCount != mods ) { throw new ConcurrentModificationException () ; }
if ( canRemove == false ) { throw new IllegalStateException () ; } final MutableInteger mut = current . getValue () ; if ( mut . value > 1 ) { mut . value -- ; MST[rv.AOD1Mutator]MSP[S] } else { entryIterator . remove () ; } parent . size -- ;
return itemCount > 0 || entryIterator . hasNext () ; MST[InlineConstantMutator]MSP[N] } @Override public E next () { if ( parent . modCount != mods ) { throw new ConcurrentModificationException () ; } if ( itemCount == 0 ) { current = entryIterator . next () ;
itemCount = current . getValue () . value ; } canRemove = true ; MST[rv.CRCR5Mutator]MSP[N] itemCount -- ; return current . getKey () ; } @Override public void remove () { if ( parent . modCount != mods ) { throw new ConcurrentModificationException () ; }
return itemCount > 0 || entryIterator . hasNext () ; MST[InlineConstantMutator]MSP[N] } @Override public E next () { if ( parent . modCount != mods ) { throw new ConcurrentModificationException () ; } if ( itemCount == 0 ) { current = entryIterator . next () ;
return itemCount > 0 || entryIterator . hasNext () ; } @Override public E next () { if ( parent . modCount != mods ) { throw new ConcurrentModificationException () ; } if ( itemCount == 0 ) { MST[rv.UOI3Mutator]MSP[N] current = entryIterator . next () ;
if ( canRemove == false ) { throw new IllegalStateException () ; } final MutableInteger mut = current . getValue () ; if ( mut . value > 1 ) { mut . value -- ; MST[rv.CRCR6Mutator]MSP[S] } else { entryIterator . remove () ; } parent . size -- ;
if ( canRemove == false ) { throw new IllegalStateException () ; } final MutableInteger mut = current . getValue () ; if ( mut . value > 1 ) { mut . value -- ; MST[rv.CRCR2Mutator]MSP[S] } else { entryIterator . remove () ; } parent . size -- ;
if ( canRemove == false ) { throw new IllegalStateException () ; } final MutableInteger mut = current . getValue () ; if ( mut . value > 1 ) { mut . value -- ; MST[rv.CRCR4Mutator]MSP[S] } else { entryIterator . remove () ; } parent . size -- ;
itemCount = current . getValue () . value ; } canRemove = true ; itemCount -- ; MST[rv.UOI2Mutator]MSP[N] return current . getKey () ; } @Override public void remove () { if ( parent . modCount != mods ) { throw new ConcurrentModificationException () ; }
if ( canRemove == false ) { throw new IllegalStateException () ; } final MutableInteger mut = current . getValue () ; MST[NonVoidMethodCallMutator]MSP[N] if ( mut . value > 1 ) { mut . value -- ; } else { entryIterator . remove () ; } parent . size -- ;
if ( canRemove == false ) { throw new IllegalStateException () ; } final MutableInteger mut = current . getValue () ; if ( mut . value > 1 ) { mut . value -- ; MST[experimental.MemberVariableMutator]MSP[S] } else { entryIterator . remove () ; } parent . size -- ;
canRemove = false ; MST[InlineConstantMutator]MSP[N] } @Override public boolean add ( final E object ) { return add ( object , 1 ) ; } @Override public boolean add ( final E object , final int nCopies ) { modCount ++ ; if ( nCopies > 0 ) {
return itemCount > 0 || entryIterator . hasNext () ; MST[rv.UOI2Mutator]MSP[N] } @Override public E next () { if ( parent . modCount != mods ) { throw new ConcurrentModificationException () ; } if ( itemCount == 0 ) { current = entryIterator . next () ;
if ( canRemove == false ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] throw new IllegalStateException () ; } final MutableInteger mut = current . getValue () ; if ( mut . value > 1 ) { mut . value -- ; } else { entryIterator . remove () ; } parent . size -- ;
if ( canRemove == false ) { throw new IllegalStateException () ; } final MutableInteger mut = current . getValue () ; if ( mut . value > 1 ) { mut . value -- ; MST[rv.UOI3Mutator]MSP[S] } else { entryIterator . remove () ; } parent . size -- ;
return itemCount > 0 || entryIterator . hasNext () ; MST[rv.UOI1Mutator]MSP[N] } @Override public E next () { if ( parent . modCount != mods ) { throw new ConcurrentModificationException () ; } if ( itemCount == 0 ) { current = entryIterator . next () ;
itemCount = current . getValue () . value ; } canRemove = true ; itemCount -- ; MST[rv.UOI1Mutator]MSP[N] return current . getKey () ; } @Override public void remove () { if ( parent . modCount != mods ) { throw new ConcurrentModificationException () ; }
if ( canRemove == false ) { throw new IllegalStateException () ; } final MutableInteger mut = current . getValue () ; if ( mut . value > 1 ) { mut . value -- ; } else { entryIterator . remove () ; MST[VoidMethodCallMutator]MSP[N] } parent . size -- ;
itemCount = current . getValue () . value ; } canRemove = true ; itemCount -- ; return current . getKey () ; } @Override public void remove () { if ( parent . modCount != mods ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] throw new ConcurrentModificationException () ; }
return itemCount > 0 || entryIterator . hasNext () ; MST[ReturnValsMutator]MSP[N] } @Override public E next () { if ( parent . modCount != mods ) { throw new ConcurrentModificationException () ; } if ( itemCount == 0 ) { current = entryIterator . next () ;
canRemove = false ; MST[rv.CRCR3Mutator]MSP[N] } @Override public boolean add ( final E object ) { return add ( object , 1 ) ; } @Override public boolean add ( final E object , final int nCopies ) { modCount ++ ; if ( nCopies > 0 ) {
if ( canRemove == false ) { throw new IllegalStateException () ; MST[ConstructorCallMutator]MSP[S] } final MutableInteger mut = current . getValue () ; if ( mut . value > 1 ) { mut . value -- ; } else { entryIterator . remove () ; } parent . size -- ;
if ( canRemove == false ) { throw new IllegalStateException () ; } final MutableInteger mut = current . getValue () ; if ( mut . value > 1 ) { mut . value -- ; MST[rv.AOR3Mutator]MSP[S] } else { entryIterator . remove () ; } parent . size -- ;
itemCount = current . getValue () . value ; } canRemove = true ; itemCount -- ; return current . getKey () ; } @Override public void remove () { if ( parent . modCount != mods ) { MST[rv.ROR2Mutator]MSP[N] throw new ConcurrentModificationException () ; }
return itemCount > 0 || entryIterator . hasNext () ; } @Override public E next () { if ( parent . modCount != mods ) { MST[rv.UOI2Mutator]MSP[N] throw new ConcurrentModificationException () ; } if ( itemCount == 0 ) { current = entryIterator . next () ;
itemCount = current . getValue () . value ; } canRemove = true ; itemCount -- ; return current . getKey () ; } @Override public void remove () { if ( parent . modCount != mods ) { MST[rv.ABSMutator]MSP[N] throw new ConcurrentModificationException () ; }
if ( canRemove == false ) { throw new IllegalStateException () ; } final MutableInteger mut = current . getValue () ; if ( mut . value > 1 ) { mut . value -- ; MST[MathMutator]MSP[S] } else { entryIterator . remove () ; } parent . size -- ;
return itemCount > 0 || entryIterator . hasNext () ; } @Override public E next () { if ( parent . modCount != mods ) { MST[rv.ROR3Mutator]MSP[N] throw new ConcurrentModificationException () ; } if ( itemCount == 0 ) { current = entryIterator . next () ;
return itemCount > 0 || entryIterator . hasNext () ; MST[rv.CRCR6Mutator]MSP[N] } @Override public E next () { if ( parent . modCount != mods ) { throw new ConcurrentModificationException () ; } if ( itemCount == 0 ) { current = entryIterator . next () ;
itemCount = current . getValue () . value ; } canRemove = true ; itemCount -- ; return current . getKey () ; } @Override public void remove () { if ( parent . modCount != mods ) { MST[rv.UOI1Mutator]MSP[N] throw new ConcurrentModificationException () ; }
if ( canRemove == false ) { throw new IllegalStateException () ; } final MutableInteger mut = current . getValue () ; if ( mut . value > 1 ) { mut . value -- ; MST[InlineConstantMutator]MSP[S] } else { entryIterator . remove () ; } parent . size -- ;
itemCount = current . getValue () . value ; } canRemove = true ; MST[rv.CRCR4Mutator]MSP[N] itemCount -- ; return current . getKey () ; } @Override public void remove () { if ( parent . modCount != mods ) { throw new ConcurrentModificationException () ; }
return itemCount > 0 || entryIterator . hasNext () ; } @Override public E next () { if ( parent . modCount != mods ) { throw new ConcurrentModificationException () ; } if ( itemCount == 0 ) { MST[rv.ROR3Mutator]MSP[N] current = entryIterator . next () ;
return itemCount > 0 || entryIterator . hasNext () ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } @Override public E next () { if ( parent . modCount != mods ) { throw new ConcurrentModificationException () ; } if ( itemCount == 0 ) { current = entryIterator . next () ;
return itemCount > 0 || entryIterator . hasNext () ; MST[rv.CRCR2Mutator]MSP[N] } @Override public E next () { if ( parent . modCount != mods ) { throw new ConcurrentModificationException () ; } if ( itemCount == 0 ) { current = entryIterator . next () ;
return itemCount > 0 || entryIterator . hasNext () ; MST[rv.CRCR6Mutator]MSP[N] } @Override public E next () { if ( parent . modCount != mods ) { throw new ConcurrentModificationException () ; } if ( itemCount == 0 ) { current = entryIterator . next () ;
if ( canRemove == false ) { MST[rv.ROR2Mutator]MSP[N] throw new IllegalStateException () ; } final MutableInteger mut = current . getValue () ; if ( mut . value > 1 ) { mut . value -- ; } else { entryIterator . remove () ; } parent . size -- ;
if ( canRemove == false ) { throw new IllegalStateException () ; } final MutableInteger mut = current . getValue () ; if ( mut . value > 1 ) { mut . value -- ; MST[rv.CRCR3Mutator]MSP[S] } else { entryIterator . remove () ; } parent . size -- ;
array [ i ++ ] = null ; } return array ; } @Override public Set < E > uniqueSet () { if ( uniqueSet == null ) { uniqueSet = UnmodifiableSet . <E > unmodifiableSet ( map . keySet () ) ; } return uniqueSet ; MST[EmptyObjectReturnValsMutator]MSP[S] }
} @Override public boolean remove ( final Object object , final int nCopies ) { final MutableInteger mut = map . get ( object ) ; if ( mut == null ) { return false ; } if ( nCopies <= 0 ) { MST[NegateConditionalsMutator]MSP[N] return false ; }
return buf . toString () ; MST[EmptyObjectReturnValsMutator]MSP[N] }
final int entrySize = in . readInt () ; for ( int i = 0 ; i < entrySize ; i ++ ) { MST[rv.UOI1Mutator]MSP[N] @SuppressWarnings ( lr_1 ) final E obj = ( E ) in . readObject () ; final int count = in . readInt () ;
final boolean changed = remove ( i . next () , 1 ) ; result = result || changed ; } } return result ; MST[rv.UOI2Mutator]MSP[N] } @Override public boolean retainAll ( final Collection < ? > coll ) { if ( coll instanceof Bag ) {
} @Override public boolean remove ( final Object object , final int nCopies ) { final MutableInteger mut = map . get ( object ) ; if ( mut == null ) { return false ; MST[InlineConstantMutator]MSP[N] } if ( nCopies <= 0 ) { return false ; }
total += ( element == null ? 0 : element . hashCode () ) ^ count . value ; } return total ; } @Override public String toString () { if ( size () == 0 ) { return lr_2 ; MST[EmptyObjectReturnValsMutator]MSP[N] } final StringBuilder buf = new StringBuilder () ;
modCount ++ ; if ( nCopies < mut . value ) { mut . value -= nCopies ; MST[rv.UOI2Mutator]MSP[N] size -= nCopies ; } else { map . remove ( object ) ; size -= mut . value ; } return true ; } @Override
final int entrySize = in . readInt () ; for ( int i = 0 ; i < entrySize ; i ++ ) { @SuppressWarnings ( lr_1 ) final E obj = ( E ) in . readObject () ; MST[NonVoidMethodCallMutator]MSP[N] final int count = in . readInt () ;
public boolean removeAll ( final Collection < ? > coll ) { boolean result = false ; if ( coll != null ) { MST[NegateConditionalsMutator]MSP[S] final Iterator < ? > i = coll . iterator () ; while ( i . hasNext () ) {
modCount ++ ; if ( nCopies < mut . value ) { mut . value -= nCopies ; size -= nCopies ; MST[rv.UOI4Mutator]MSP[N] } else { map . remove ( object ) ; size -= mut . value ; } return true ; } @Override
modCount ++ ; if ( nCopies < mut . value ) { mut . value -= nCopies ; size -= nCopies ; } else { map . remove ( object ) ; size -= mut . value ; } return true ; MST[rv.CRCR6Mutator]MSP[N] } @Override
modCount ++ ; if ( nCopies < mut . value ) { mut . value -= nCopies ; MST[rv.ABSMutator]MSP[N] size -= nCopies ; } else { map . remove ( object ) ; size -= mut . value ; } return true ; } @Override
final int size = size () ; if ( array . length < size ) { @SuppressWarnings ( lr_1 ) final T [] unchecked = ( T [] ) Array . newInstance ( array . getClass () . getComponentType () , size ) ; MST[NonVoidMethodCallMutator]MSP[N] array = unchecked ; }
buf . append ( '[' ) ; final Iterator < E > it = uniqueSet () . iterator () ; while ( it . hasNext () ) { MST[rv.ROR2Mutator]MSP[N] final Object current = it . next () ; final int count = getCount ( current ) ;
if ( getCount ( current ) < other . getCount ( current ) ) { return false ; } } return true ; } @Override public Iterator < E > iterator () { return new BagIterator <> ( this ) ; MST[ConstructorCallMutator]MSP[N] } @Override public boolean hasNext () {
for ( int index = getCount ( current ) ; index > 0 ; index -- ) { @SuppressWarnings ( lr_1 ) final T unchecked = ( T ) current ; array [ i ++ ] = unchecked ; } } while ( i < array . length ) { MST[rv.ROR4Mutator]MSP[N]
canRemove = false ; } @Override public boolean add ( final E object ) { return add ( object , 1 ) ; MST[ReturnValsMutator]MSP[N] } @Override public boolean add ( final E object , final int nCopies ) { modCount ++ ; if ( nCopies > 0 ) {
final boolean added = add ( i . next () ) ; changed = changed || added ; } return changed ; } @Override public void clear () { modCount ++ ; map . clear () ; size = 0 ; MST[rv.CRCR1Mutator]MSP[S] } @Override
array [ i ++ ] = null ; } return array ; } @Override public Set < E > uniqueSet () { if ( uniqueSet == null ) { uniqueSet = UnmodifiableSet . <E > unmodifiableSet ( map . keySet () ) ; MST[ArgumentPropagationMutator]MSP[N] } return uniqueSet ; }
map . put ( obj , new MutableInteger ( count ) ) ; size += count ; } } @Override public boolean equals ( final Object object ) { if ( object == this ) { return true ; MST[rv.CRCR3Mutator]MSP[N] } if ( object instanceof Bag == false ) {
final MutableInteger mut = map . get ( object ) ; MST[NonVoidMethodCallMutator]MSP[N] size += nCopies ; if ( mut == null ) { map . put ( object , new MutableInteger ( nCopies ) ) ; return true ; } mut . value += nCopies ; return false ; }
public boolean removeAll ( final Collection < ? > coll ) { boolean result = false ; if ( coll != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] final Iterator < ? > i = coll . iterator () ; while ( i . hasNext () ) {
for ( int index = getCount ( current ) ; index > 0 ; index -- ) { result [ i ++ ] = current ; } } return result ; MST[ReturnValsMutator]MSP[N] } @Override public < T > T [] toArray ( T [] array ) {
if ( other . getCount ( element ) != getCount ( element ) ) { MST[rv.ROR1Mutator]MSP[S] return false ; } } return true ; } @Override public int hashCode () { int total = 0 ;
modCount ++ ; MST[rv.UOI2Mutator]MSP[S] if ( nCopies < mut . value ) { mut . value -= nCopies ; size -= nCopies ; } else { map . remove ( object ) ; size -= mut . value ; } return true ; } @Override
canRemove = false ; } @Override public boolean add ( final E object ) { return add ( object , 1 ) ; } @Override public boolean add ( final E object , final int nCopies ) { modCount ++ ; if ( nCopies > 0 ) { MST[rv.ROR2Mutator]MSP[N]
final boolean added = add ( i . next () ) ; changed = changed || added ; } return changed ; } @Override public void clear () { modCount ++ ; MST[rv.CRCR6Mutator]MSP[N] map . clear () ; size = 0 ; } @Override
final int size = size () ; if ( array . length < size ) { @SuppressWarnings ( lr_1 ) final T [] unchecked = ( T [] ) Array . newInstance ( array . getClass () . getComponentType () , size ) ; MST[rv.UOI3Mutator]MSP[N] array = unchecked ; }
total += ( element == null ? 0 : element . hashCode () ) ^ count . value ; } return total ; } @Override public String toString () { if ( size () == 0 ) { MST[rv.ROR3Mutator]MSP[N] return lr_2 ; } final StringBuilder buf = new StringBuilder () ;
buf . append ( count ) ; buf . append ( ':' ) ; buf . append ( current ) ; if ( it . hasNext () ) { MST[rv.ROR2Mutator]MSP[N] buf . append ( ',' ) ; } } buf . append ( ']' ) ;
modCount ++ ; if ( nCopies < mut . value ) { MST[rv.UOI4Mutator]MSP[N] mut . value -= nCopies ; size -= nCopies ; } else { map . remove ( object ) ; size -= mut . value ; } return true ; } @Override
public boolean removeAll ( final Collection < ? > coll ) { boolean result = false ; if ( coll != null ) { MST[rv.ROR5Mutator]MSP[S] final Iterator < ? > i = coll . iterator () ; while ( i . hasNext () ) {
final int entrySize = in . readInt () ; for ( int i = 0 ; i < entrySize ; i ++ ) { MST[rv.ROR2Mutator]MSP[S] @SuppressWarnings ( lr_1 ) final E obj = ( E ) in . readObject () ; final int count = in . readInt () ;
buf . append ( count ) ; buf . append ( ':' ) ; MST[experimental.NakedReceiverMutator]MSP[N] buf . append ( current ) ; if ( it . hasNext () ) { buf . append ( ',' ) ; } } buf . append ( ']' ) ;
final MutableInteger mut = map . get ( object ) ; size += nCopies ; if ( mut == null ) { map . put ( object , new MutableInteger ( nCopies ) ) ; return true ; } mut . value += nCopies ; MST[rv.UOI3Mutator]MSP[N] return false ; }
buf . append ( count ) ; buf . append ( ':' ) ; buf . append ( current ) ; if ( it . hasNext () ) { buf . append ( ',' ) ; } } buf . append ( ']' ) ; MST[rv.CRCR1Mutator]MSP[N]
return false ; } final Bag < ? > other = ( Bag < ? > ) object ; if ( other . size () != size () ) { MST[rv.ROR2Mutator]MSP[N] return false ; } for ( final E element : map . keySet () ) {
final MutableInteger count = map . get ( object ) ; if ( count != null ) { return count . value ; MST[rv.ABSMutator]MSP[N] } return 0 ; } @Override public boolean contains ( final Object object ) { return map . containsKey ( object ) ; } @Override
modCount ++ ; MST[rv.ABSMutator]MSP[S] if ( nCopies < mut . value ) { mut . value -= nCopies ; size -= nCopies ; } else { map . remove ( object ) ; size -= mut . value ; } return true ; } @Override
for ( int index = getCount ( current ) ; index > 0 ; index -- ) { MST[experimental.RemoveIncrementsMutator]MSP[N] result [ i ++ ] = current ; } } return result ; } @Override public < T > T [] toArray ( T [] array ) {
array [ i ++ ] = null ; MST[IncrementsMutator]MSP[N] } return array ; } @Override public Set < E > uniqueSet () { if ( uniqueSet == null ) { uniqueSet = UnmodifiableSet . <E > unmodifiableSet ( map . keySet () ) ; } return uniqueSet ; }
buf . append ( count ) ; buf . append ( ':' ) ; buf . append ( current ) ; if ( it . hasNext () ) { buf . append ( ',' ) ; MST[experimental.NakedReceiverMutator]MSP[N] } } buf . append ( ']' ) ;
for ( int index = getCount ( current ) ; index > 0 ; index -- ) { result [ i ++ ] = current ; MST[rv.UOI1Mutator]MSP[N] } } return result ; } @Override public < T > T [] toArray ( T [] array ) {
} @Override public boolean remove ( final Object object , final int nCopies ) { final MutableInteger mut = map . get ( object ) ; if ( mut == null ) { return false ; } if ( nCopies <= 0 ) { MST[rv.UOI4Mutator]MSP[N] return false ; }
for ( int index = getCount ( current ) ; index > 0 ; index -- ) { @SuppressWarnings ( lr_1 ) final T unchecked = ( T ) current ; array [ i ++ ] = unchecked ; MST[rv.UOI3Mutator]MSP[N] } } while ( i < array . length ) {
} @Override public boolean remove ( final Object object , final int nCopies ) { final MutableInteger mut = map . get ( object ) ; if ( mut == null ) { return false ; } if ( nCopies <= 0 ) { MST[rv.ROR5Mutator]MSP[S] return false ; }
total += ( element == null ? 0 : element . hashCode () ) ^ count . value ; } return total ; } @Override public String toString () { if ( size () == 0 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return lr_2 ; } final StringBuilder buf = new StringBuilder () ;
for ( int index = getCount ( current ) ; index > 0 ; index -- ) { @SuppressWarnings ( lr_1 ) final T unchecked = ( T ) current ; array [ i ++ ] = unchecked ; } } while ( i < array . length ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N]
map . put ( obj , new MutableInteger ( count ) ) ; size += count ; } } @Override public boolean equals ( final Object object ) { if ( object == this ) { return true ; } if ( object instanceof Bag == false ) { MST[rv.ROR5Mutator]MSP[N]
for ( int index = getCount ( current ) ; index > 0 ; index -- ) { @SuppressWarnings ( lr_1 ) final T unchecked = ( T ) current ; array [ i ++ ] = unchecked ; } } while ( i < array . length ) { MST[rv.UOI3Mutator]MSP[N]
return false ; } @Override public boolean addAll ( final Collection < ? extends E > coll ) { boolean changed = false ; MST[rv.CRCR1Mutator]MSP[S] final Iterator < ? extends E > i = coll . iterator () ; while ( i . hasNext () ) {
canRemove = false ; } @Override public boolean add ( final E object ) { return add ( object , 1 ) ; } @Override public boolean add ( final E object , final int nCopies ) { modCount ++ ; if ( nCopies > 0 ) { MST[rv.UOI4Mutator]MSP[N]
map . put ( obj , new MutableInteger ( count ) ) ; size += count ; } } @Override public boolean equals ( final Object object ) { if ( object == this ) { return true ; } if ( object instanceof Bag == false ) { MST[rv.ROR2Mutator]MSP[N]
map . put ( obj , new MutableInteger ( count ) ) ; MST[rv.ABSMutator]MSP[S] size += count ; } } @Override public boolean equals ( final Object object ) { if ( object == this ) { return true ; } if ( object instanceof Bag == false ) {
buf . append ( '[' ) ; MST[rv.CRCR2Mutator]MSP[N] final Iterator < E > it = uniqueSet () . iterator () ; while ( it . hasNext () ) { final Object current = it . next () ; final int count = getCount ( current ) ;
final boolean added = add ( i . next () ) ; changed = changed || added ; MST[rv.CRCR4Mutator]MSP[S] } return changed ; } @Override public void clear () { modCount ++ ; map . clear () ; size = 0 ; } @Override
return false ; MST[rv.CRCR5Mutator]MSP[S] } final Bag < ? > other = ( Bag < ? > ) object ; if ( other . size () != size () ) { return false ; } for ( final E element : map . keySet () ) {
final boolean added = add ( i . next () ) ; changed = changed || added ; MST[rv.ROR4Mutator]MSP[S] } return changed ; } @Override public void clear () { modCount ++ ; map . clear () ; size = 0 ; } @Override
final MutableInteger mut = map . get ( object ) ; size += nCopies ; if ( mut == null ) { map . put ( object , new MutableInteger ( nCopies ) ) ; return true ; MST[rv.CRCR6Mutator]MSP[N] } mut . value += nCopies ; return false ; }
buf . append ( count ) ; buf . append ( ':' ) ; buf . append ( current ) ; if ( it . hasNext () ) { buf . append ( ',' ) ; MST[rv.CRCR3Mutator]MSP[N] } } buf . append ( ']' ) ;
final MutableInteger mut = map . get ( object ) ; size += nCopies ; if ( mut == null ) { map . put ( object , new MutableInteger ( nCopies ) ) ; MST[rv.UOI3Mutator]MSP[N] return true ; } mut . value += nCopies ; return false ; }
return false ; } final Bag < ? > other = ( Bag < ? > ) object ; if ( other . size () != size () ) { MST[rv.ROR5Mutator]MSP[N] return false ; } for ( final E element : map . keySet () ) {
modCount ++ ; MST[rv.AOD1Mutator]MSP[S] if ( nCopies < mut . value ) { mut . value -= nCopies ; size -= nCopies ; } else { map . remove ( object ) ; size -= mut . value ; } return true ; } @Override
public boolean removeAll ( final Collection < ? > coll ) { boolean result = false ; MST[rv.CRCR6Mutator]MSP[S] if ( coll != null ) { final Iterator < ? > i = coll . iterator () ; while ( i . hasNext () ) {
final MutableInteger mut = map . get ( object ) ; size += nCopies ; if ( mut == null ) { map . put ( object , new MutableInteger ( nCopies ) ) ; return true ; } mut . value += nCopies ; MST[rv.AOD2Mutator]MSP[N] return false ; }
modCount ++ ; MST[InlineConstantMutator]MSP[S] if ( nCopies < mut . value ) { mut . value -= nCopies ; size -= nCopies ; } else { map . remove ( object ) ; size -= mut . value ; } return true ; } @Override
final boolean changed = remove ( i . next () , 1 ) ; result = result || changed ; } } return result ; MST[rv.ABSMutator]MSP[N] } @Override public boolean retainAll ( final Collection < ? > coll ) { if ( coll instanceof Bag ) {
buf . append ( count ) ; buf . append ( ':' ) ; MST[rv.CRCR3Mutator]MSP[N] buf . append ( current ) ; if ( it . hasNext () ) { buf . append ( ',' ) ; } } buf . append ( ']' ) ;
buf . append ( count ) ; buf . append ( ':' ) ; MST[rv.CRCR6Mutator]MSP[N] buf . append ( current ) ; if ( it . hasNext () ) { buf . append ( ',' ) ; } } buf . append ( ']' ) ;
final MutableInteger mut = map . get ( object ) ; size += nCopies ; if ( mut == null ) { map . put ( object , new MutableInteger ( nCopies ) ) ; MST[ArgumentPropagationMutator]MSP[N] return true ; } mut . value += nCopies ; return false ; }
final boolean added = add ( i . next () ) ; changed = changed || added ; MST[rv.UOI1Mutator]MSP[S] } return changed ; } @Override public void clear () { modCount ++ ; map . clear () ; size = 0 ; } @Override
out . writeInt ( entry . getValue () . value ) ; MST[rv.ABSMutator]MSP[N] } } protected void doReadObject ( final Map < E , MutableInteger > map , final ObjectInputStream in ) throws IOException , ClassNotFoundException { this . map = map ;
modCount ++ ; if ( nCopies < mut . value ) { MST[rv.UOI4Mutator]MSP[N] mut . value -= nCopies ; size -= nCopies ; } else { map . remove ( object ) ; size -= mut . value ; } return true ; } @Override
final MutableInteger mut = map . get ( object ) ; size += nCopies ; if ( mut == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] map . put ( object , new MutableInteger ( nCopies ) ) ; return true ; } mut . value += nCopies ; return false ; }
protected Map < E , MutableInteger > getMap () { return map ; } @Override public int size () { return size ; } @Override public boolean isEmpty () { return map . isEmpty () ; MST[BooleanFalseReturnValsMutator]MSP[N] } @Override public int getCount ( final Object object ) {
if ( other . getCount ( element ) != getCount ( element ) ) { MST[rv.ROR4Mutator]MSP[N] return false ; } } return true ; } @Override public int hashCode () { int total = 0 ;
return false ; MST[ReturnValsMutator]MSP[S] } final Bag < ? > other = ( Bag < ? > ) object ; if ( other . size () != size () ) { return false ; } for ( final E element : map . keySet () ) {
modCount ++ ; if ( nCopies < mut . value ) { mut . value -= nCopies ; size -= nCopies ; MST[rv.AOR1Mutator]MSP[N] } else { map . remove ( object ) ; size -= mut . value ; } return true ; } @Override
public boolean removeAll ( final Collection < ? > coll ) { boolean result = false ; MST[rv.CRCR3Mutator]MSP[S] if ( coll != null ) { final Iterator < ? > i = coll . iterator () ; while ( i . hasNext () ) {
final MutableInteger count = map . get ( object ) ; if ( count != null ) { return count . value ; } return 0 ; } @Override public boolean contains ( final Object object ) { return map . containsKey ( object ) ; MST[NonVoidMethodCallMutator]MSP[N] } @Override
modCount ++ ; if ( nCopies < mut . value ) { mut . value -= nCopies ; MST[rv.UOI1Mutator]MSP[N] size -= nCopies ; } else { map . remove ( object ) ; size -= mut . value ; } return true ; } @Override
return buf . toString () ; MST[NonVoidMethodCallMutator]MSP[S] }
buf . append ( '[' ) ; final Iterator < E > it = uniqueSet () . iterator () ; while ( it . hasNext () ) { MST[rv.ROR5Mutator]MSP[N] final Object current = it . next () ; final int count = getCount ( current ) ;
final boolean added = add ( i . next () ) ; changed = changed || added ; } return changed ; } @Override public void clear () { modCount ++ ; MST[rv.UOI1Mutator]MSP[N] map . clear () ; size = 0 ; } @Override
for ( int index = getCount ( current ) ; index > 0 ; index -- ) { @SuppressWarnings ( lr_1 ) final T unchecked = ( T ) current ; array [ i ++ ] = unchecked ; } } while ( i < array . length ) { MST[rv.ROR1Mutator]MSP[N]
canRemove = false ; } @Override public boolean add ( final E object ) { return add ( object , 1 ) ; } @Override public boolean add ( final E object , final int nCopies ) { modCount ++ ; MST[rv.CRCR4Mutator]MSP[S] if ( nCopies > 0 ) {
if ( other . getCount ( element ) != getCount ( element ) ) { return false ; } } return true ; MST[rv.CRCR2Mutator]MSP[N] } @Override public int hashCode () { int total = 0 ;
final MutableInteger mut = map . get ( object ) ; size += nCopies ; MST[rv.AOR1Mutator]MSP[N] if ( mut == null ) { map . put ( object , new MutableInteger ( nCopies ) ) ; return true ; } mut . value += nCopies ; return false ; }
buf . append ( '[' ) ; MST[rv.CRCR5Mutator]MSP[N] final Iterator < E > it = uniqueSet () . iterator () ; while ( it . hasNext () ) { final Object current = it . next () ; final int count = getCount ( current ) ;
buf . append ( count ) ; buf . append ( ':' ) ; buf . append ( current ) ; if ( it . hasNext () ) { buf . append ( ',' ) ; MST[rv.CRCR6Mutator]MSP[N] } } buf . append ( ']' ) ;
int i = 0 ; MST[rv.CRCR6Mutator]MSP[N] final Iterator < E > it = map . keySet () . iterator () ; while ( it . hasNext () ) { final E current = it . next () ;
return false ; MST[InlineConstantMutator]MSP[S] } final Bag < ? > other = ( Bag < ? > ) object ; if ( other . size () != size () ) { return false ; } for ( final E element : map . keySet () ) {
final MutableInteger count = map . get ( object ) ; if ( count != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return count . value ; } return 0 ; } @Override public boolean contains ( final Object object ) { return map . containsKey ( object ) ; } @Override
buf . append ( '[' ) ; final Iterator < E > it = uniqueSet () . iterator () ; while ( it . hasNext () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] final Object current = it . next () ; final int count = getCount ( current ) ;
final boolean added = add ( i . next () ) ; changed = changed || added ; MST[InlineConstantMutator]MSP[S] } return changed ; } @Override public void clear () { modCount ++ ; map . clear () ; size = 0 ; } @Override
modCount ++ ; if ( nCopies < mut . value ) { mut . value -= nCopies ; size -= nCopies ; MST[rv.AOD2Mutator]MSP[N] } else { map . remove ( object ) ; size -= mut . value ; } return true ; } @Override
map . put ( obj , new MutableInteger ( count ) ) ; MST[ArgumentPropagationMutator]MSP[S] size += count ; } } @Override public boolean equals ( final Object object ) { if ( object == this ) { return true ; } if ( object instanceof Bag == false ) {
canRemove = false ; } @Override public boolean add ( final E object ) { return add ( object , 1 ) ; } @Override public boolean add ( final E object , final int nCopies ) { modCount ++ ; MST[rv.UOI4Mutator]MSP[S] if ( nCopies > 0 ) {
modCount ++ ; if ( nCopies < mut . value ) { mut . value -= nCopies ; size -= nCopies ; } else { map . remove ( object ) ; size -= mut . value ; } return true ; MST[rv.CRCR3Mutator]MSP[S] } @Override
final MutableInteger count = map . get ( object ) ; if ( count != null ) { MST[rv.ROR5Mutator]MSP[N] return count . value ; } return 0 ; } @Override public boolean contains ( final Object object ) { return map . containsKey ( object ) ; } @Override
int i = 0 ; final Iterator < E > it = map . keySet () . iterator () ; while ( it . hasNext () ) { MST[rv.ROR1Mutator]MSP[N] final E current = it . next () ;
int i = 0 ; final Iterator < E > it = map . keySet () . iterator () ; while ( it . hasNext () ) { MST[rv.ROR3Mutator]MSP[N] final E current = it . next () ;
canRemove = false ; } @Override public boolean add ( final E object ) { return add ( object , 1 ) ; } @Override public boolean add ( final E object , final int nCopies ) { modCount ++ ; if ( nCopies > 0 ) { MST[NegateConditionalsMutator]MSP[N]
final boolean added = add ( i . next () ) ; changed = changed || added ; MST[rv.ROR2Mutator]MSP[S] } return changed ; } @Override public void clear () { modCount ++ ; map . clear () ; size = 0 ; } @Override
final MutableInteger mut = map . get ( object ) ; size += nCopies ; MST[rv.AOR4Mutator]MSP[N] if ( mut == null ) { map . put ( object , new MutableInteger ( nCopies ) ) ; return true ; } mut . value += nCopies ; return false ; }
final boolean added = add ( i . next () ) ; changed = changed || added ; } return changed ; } @Override public void clear () { modCount ++ ; MST[rv.AOR4Mutator]MSP[N] map . clear () ; size = 0 ; } @Override
final MutableInteger mut = map . get ( object ) ; size += nCopies ; MST[rv.UOI1Mutator]MSP[N] if ( mut == null ) { map . put ( object , new MutableInteger ( nCopies ) ) ; return true ; } mut . value += nCopies ; return false ; }
int i = 0 ; MST[rv.CRCR1Mutator]MSP[N] final Iterator < E > it = map . keySet () . iterator () ; while ( it . hasNext () ) { final E current = it . next () ;
buf . append ( count ) ; buf . append ( ':' ) ; buf . append ( current ) ; if ( it . hasNext () ) { buf . append ( ',' ) ; } } buf . append ( ']' ) ; MST[rv.CRCR4Mutator]MSP[N]
for ( int index = getCount ( current ) ; index > 0 ; index -- ) { MST[rv.UOI3Mutator]MSP[N] result [ i ++ ] = current ; } } return result ; } @Override public < T > T [] toArray ( T [] array ) {
int i = 0 ; MST[rv.CRCR3Mutator]MSP[N] final Iterator < E > it = map . keySet () . iterator () ; while ( it . hasNext () ) { final E current = it . next () ;
buf . append ( '[' ) ; MST[InlineConstantMutator]MSP[N] final Iterator < E > it = uniqueSet () . iterator () ; while ( it . hasNext () ) { final Object current = it . next () ; final int count = getCount ( current ) ;
final int entrySize = in . readInt () ; for ( int i = 0 ; i < entrySize ; i ++ ) { MST[rv.UOI2Mutator]MSP[N] @SuppressWarnings ( lr_1 ) final E obj = ( E ) in . readObject () ; final int count = in . readInt () ;
for ( int index = getCount ( current ) ; index > 0 ; index -- ) { MST[rv.ROR1Mutator]MSP[N] @SuppressWarnings ( lr_1 ) final T unchecked = ( T ) current ; array [ i ++ ] = unchecked ; } } while ( i < array . length ) {
buf . append ( count ) ; buf . append ( ':' ) ; buf . append ( current ) ; if ( it . hasNext () ) { MST[rv.ROR5Mutator]MSP[N] buf . append ( ',' ) ; } } buf . append ( ']' ) ;
modCount ++ ; if ( nCopies < mut . value ) { mut . value -= nCopies ; MST[MathMutator]MSP[N] size -= nCopies ; } else { map . remove ( object ) ; size -= mut . value ; } return true ; } @Override
final boolean added = add ( i . next () ) ; changed = changed || added ; MST[rv.UOI1Mutator]MSP[S] } return changed ; } @Override public void clear () { modCount ++ ; map . clear () ; size = 0 ; } @Override
modCount ++ ; if ( nCopies < mut . value ) { mut . value -= nCopies ; MST[rv.UOI3Mutator]MSP[N] size -= nCopies ; } else { map . remove ( object ) ; size -= mut . value ; } return true ; } @Override
int i = 0 ; final Iterator < E > it = map . keySet () . iterator () ; MST[NonVoidMethodCallMutator]MSP[N] while ( it . hasNext () ) { final E current = it . next () ;
return false ; } final Bag < ? > other = ( Bag < ? > ) object ; if ( other . size () != size () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return false ; } for ( final E element : map . keySet () ) {
final boolean added = add ( i . next () ) ; changed = changed || added ; } return changed ; MST[rv.UOI2Mutator]MSP[S] } @Override public void clear () { modCount ++ ; map . clear () ; size = 0 ; } @Override
modCount ++ ; if ( nCopies < mut . value ) { mut . value -= nCopies ; size -= nCopies ; MST[rv.AOR4Mutator]MSP[N] } else { map . remove ( object ) ; size -= mut . value ; } return true ; } @Override
canRemove = false ; } @Override public boolean add ( final E object ) { return add ( object , 1 ) ; } @Override public boolean add ( final E object , final int nCopies ) { modCount ++ ; MST[rv.AOR3Mutator]MSP[S] if ( nCopies > 0 ) {
buf . append ( count ) ; MST[rv.UOI2Mutator]MSP[N] buf . append ( ':' ) ; buf . append ( current ) ; if ( it . hasNext () ) { buf . append ( ',' ) ; } } buf . append ( ']' ) ;
protected Map < E , MutableInteger > getMap () { return map ; } @Override public int size () { return size ; MST[rv.UOI1Mutator]MSP[N] } @Override public boolean isEmpty () { return map . isEmpty () ; } @Override public int getCount ( final Object object ) {
modCount ++ ; if ( nCopies < mut . value ) { mut . value -= nCopies ; MST[experimental.MemberVariableMutator]MSP[N] size -= nCopies ; } else { map . remove ( object ) ; size -= mut . value ; } return true ; } @Override
map . put ( obj , new MutableInteger ( count ) ) ; size += count ; MST[rv.UOI4Mutator]MSP[S] } } @Override public boolean equals ( final Object object ) { if ( object == this ) { return true ; } if ( object instanceof Bag == false ) {
final MutableInteger mut = map . get ( object ) ; size += nCopies ; if ( mut == null ) { map . put ( object , new MutableInteger ( nCopies ) ) ; MST[ConstructorCallMutator]MSP[N] return true ; } mut . value += nCopies ; return false ; }
modCount ++ ; if ( nCopies < mut . value ) { MST[rv.ROR2Mutator]MSP[N] mut . value -= nCopies ; size -= nCopies ; } else { map . remove ( object ) ; size -= mut . value ; } return true ; } @Override
modCount ++ ; if ( nCopies < mut . value ) { MST[rv.UOI1Mutator]MSP[N] mut . value -= nCopies ; size -= nCopies ; } else { map . remove ( object ) ; size -= mut . value ; } return true ; } @Override
} @Override public boolean remove ( final Object object , final int nCopies ) { final MutableInteger mut = map . get ( object ) ; if ( mut == null ) { return false ; MST[BooleanTrueReturnValsMutator]MSP[N] } if ( nCopies <= 0 ) { return false ; }
final int size = size () ; if ( array . length < size ) { MST[rv.ROR3Mutator]MSP[N] @SuppressWarnings ( lr_1 ) final T [] unchecked = ( T [] ) Array . newInstance ( array . getClass () . getComponentType () , size ) ; array = unchecked ; }
for ( int index = getCount ( current ) ; index > 0 ; index -- ) { result [ i ++ ] = current ; } } return result ; MST[NullReturnValsMutator]MSP[N] } @Override public < T > T [] toArray ( T [] array ) {
final MutableInteger mut = map . get ( object ) ; size += nCopies ; if ( mut == null ) { map . put ( object , new MutableInteger ( nCopies ) ) ; return true ; } mut . value += nCopies ; return false ; MST[rv.CRCR6Mutator]MSP[S] }
canRemove = false ; } @Override public boolean add ( final E object ) { return add ( object , 1 ) ; } @Override public boolean add ( final E object , final int nCopies ) { modCount ++ ; if ( nCopies > 0 ) { MST[rv.UOI1Mutator]MSP[N]
map . put ( obj , new MutableInteger ( count ) ) ; size += count ; } } @Override public boolean equals ( final Object object ) { if ( object == this ) { return true ; } if ( object instanceof Bag == false ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
final Object [] result = new Object [ size () ] ; int i = 0 ; final Iterator < E > it = map . keySet () . iterator () ; MST[NonVoidMethodCallMutator]MSP[N] while ( it . hasNext () ) { final E current = it . next () ;
final Object [] result = new Object [ size () ] ; int i = 0 ; MST[rv.CRCR6Mutator]MSP[N] final Iterator < E > it = map . keySet () . iterator () ; while ( it . hasNext () ) { final E current = it . next () ;
final int entrySize = in . readInt () ; for ( int i = 0 ; i < entrySize ; i ++ ) { MST[NegateConditionalsMutator]MSP[N] @SuppressWarnings ( lr_1 ) final E obj = ( E ) in . readObject () ; final int count = in . readInt () ;
final int entrySize = in . readInt () ; for ( int i = 0 ; i < entrySize ; i ++ ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] @SuppressWarnings ( lr_1 ) final E obj = ( E ) in . readObject () ; final int count = in . readInt () ;
map . put ( obj , new MutableInteger ( count ) ) ; MST[rv.UOI2Mutator]MSP[S] size += count ; } } @Override public boolean equals ( final Object object ) { if ( object == this ) { return true ; } if ( object instanceof Bag == false ) {
canRemove = false ; } @Override public boolean add ( final E object ) { return add ( object , 1 ) ; } @Override public boolean add ( final E object , final int nCopies ) { modCount ++ ; MST[rv.AOD1Mutator]MSP[S] if ( nCopies > 0 ) {
buf . append ( '[' ) ; MST[NonVoidMethodCallMutator]MSP[N] final Iterator < E > it = uniqueSet () . iterator () ; while ( it . hasNext () ) { final Object current = it . next () ; final int count = getCount ( current ) ;
if ( other . getCount ( element ) != getCount ( element ) ) { return false ; } } return true ; } @Override public int hashCode () { int total = 0 ; MST[InlineConstantMutator]MSP[N]
modCount ++ ; MST[rv.CRCR4Mutator]MSP[S] if ( nCopies < mut . value ) { mut . value -= nCopies ; size -= nCopies ; } else { map . remove ( object ) ; size -= mut . value ; } return true ; } @Override
final int size = size () ; if ( array . length < size ) { @SuppressWarnings ( lr_1 ) final T [] unchecked = ( T [] ) Array . newInstance ( array . getClass () . getComponentType () , size ) ; MST[NonVoidMethodCallMutator]MSP[N] array = unchecked ; }
buf . append ( count ) ; buf . append ( ':' ) ; buf . append ( current ) ; MST[experimental.NakedReceiverMutator]MSP[N] if ( it . hasNext () ) { buf . append ( ',' ) ; } } buf . append ( ']' ) ;
protected void doWriteObject ( final ObjectOutputStream out ) throws IOException { out . writeInt ( map . size () ) ; for ( final Entry < E , MutableInteger > entry : map . entrySet () ) { out . writeObject ( entry . getKey () ) ; MST[VoidMethodCallMutator]MSP[N]
protected Map < E , MutableInteger > getMap () { return map ; } @Override public int size () { return size ; } @Override public boolean isEmpty () { return map . isEmpty () ; MST[BooleanTrueReturnValsMutator]MSP[N] } @Override public int getCount ( final Object object ) {
for ( int index = getCount ( current ) ; index > 0 ; index -- ) { MST[IncrementsMutator]MSP[N] @SuppressWarnings ( lr_1 ) final T unchecked = ( T ) current ; array [ i ++ ] = unchecked ; } } while ( i < array . length ) {
map . put ( obj , new MutableInteger ( count ) ) ; MST[NonVoidMethodCallMutator]MSP[S] size += count ; } } @Override public boolean equals ( final Object object ) { if ( object == this ) { return true ; } if ( object instanceof Bag == false ) {
final Object [] result = new Object [ size () ] ; int i = 0 ; MST[rv.CRCR1Mutator]MSP[N] final Iterator < E > it = map . keySet () . iterator () ; while ( it . hasNext () ) { final E current = it . next () ;
final Object [] result = new Object [ size () ] ; int i = 0 ; final Iterator < E > it = map . keySet () . iterator () ; while ( it . hasNext () ) { MST[rv.ROR1Mutator]MSP[N] final E current = it . next () ;
total += ( element == null ? 0 : element . hashCode () ) ^ count . value ; } return total ; MST[rv.UOI3Mutator]MSP[N] } @Override public String toString () { if ( size () == 0 ) { return lr_2 ; } final StringBuilder buf = new StringBuilder () ;
buf . append ( count ) ; buf . append ( ':' ) ; buf . append ( current ) ; if ( it . hasNext () ) { MST[NegateConditionalsMutator]MSP[N] buf . append ( ',' ) ; } } buf . append ( ']' ) ;
for ( int index = getCount ( current ) ; index > 0 ; index -- ) { MST[rv.ABSMutator]MSP[N] result [ i ++ ] = current ; } } return result ; } @Override public < T > T [] toArray ( T [] array ) {
} @Override public boolean remove ( final Object object , final int nCopies ) { final MutableInteger mut = map . get ( object ) ; if ( mut == null ) { return false ; } if ( nCopies <= 0 ) { MST[rv.ROR2Mutator]MSP[N] return false ; }
final MutableInteger mut = map . get ( object ) ; size += nCopies ; if ( mut == null ) { map . put ( object , new MutableInteger ( nCopies ) ) ; return true ; } mut . value += nCopies ; return false ; MST[rv.CRCR1Mutator]MSP[S] }
total += ( element == null ? 0 : element . hashCode () ) ^ count . value ; } return total ; } @Override public String toString () { if ( size () == 0 ) { MST[NonVoidMethodCallMutator]MSP[N] return lr_2 ; } final StringBuilder buf = new StringBuilder () ;
modCount ++ ; if ( nCopies < mut . value ) { mut . value -= nCopies ; MST[rv.AOR2Mutator]MSP[N] size -= nCopies ; } else { map . remove ( object ) ; size -= mut . value ; } return true ; } @Override
final MutableInteger count = map . get ( object ) ; if ( count != null ) { return count . value ; MST[PrimitiveReturnsMutator]MSP[N] } return 0 ; } @Override public boolean contains ( final Object object ) { return map . containsKey ( object ) ; } @Override
} @Override public boolean remove ( final Object object , final int nCopies ) { final MutableInteger mut = map . get ( object ) ; if ( mut == null ) { MST[NegateConditionalsMutator]MSP[N] return false ; } if ( nCopies <= 0 ) { return false ; }
buf . append ( count ) ; buf . append ( ':' ) ; buf . append ( current ) ; if ( it . hasNext () ) { MST[rv.ROR4Mutator]MSP[N] buf . append ( ',' ) ; } } buf . append ( ']' ) ;
array [ i ++ ] = null ; MST[rv.UOI4Mutator]MSP[N] } return array ; } @Override public Set < E > uniqueSet () { if ( uniqueSet == null ) { uniqueSet = UnmodifiableSet . <E > unmodifiableSet ( map . keySet () ) ; } return uniqueSet ; }
buf . append ( '[' ) ; final Iterator < E > it = uniqueSet () . iterator () ; while ( it . hasNext () ) { MST[NegateConditionalsMutator]MSP[N] final Object current = it . next () ; final int count = getCount ( current ) ;
final MutableInteger count = map . get ( object ) ; if ( count != null ) { MST[NegateConditionalsMutator]MSP[N] return count . value ; } return 0 ; } @Override public boolean contains ( final Object object ) { return map . containsKey ( object ) ; } @Override
final int entrySize = in . readInt () ; for ( int i = 0 ; i < entrySize ; i ++ ) { MST[rv.ROR4Mutator]MSP[N] @SuppressWarnings ( lr_1 ) final E obj = ( E ) in . readObject () ; final int count = in . readInt () ;
canRemove = false ; } @Override public boolean add ( final E object ) { return add ( object , 1 ) ; } @Override public boolean add ( final E object , final int nCopies ) { modCount ++ ; MST[rv.ABSMutator]MSP[S] if ( nCopies > 0 ) {
map . put ( obj , new MutableInteger ( count ) ) ; size += count ; } } @Override public boolean equals ( final Object object ) { if ( object == this ) { return true ; } if ( object instanceof Bag == false ) { MST[NegateConditionalsMutator]MSP[N]
final MutableInteger mut = map . get ( object ) ; size += nCopies ; if ( mut == null ) { map . put ( object , new MutableInteger ( nCopies ) ) ; return true ; } mut . value += nCopies ; MST[rv.UOI4Mutator]MSP[N] return false ; }
for ( int index = getCount ( current ) ; index > 0 ; index -- ) { MST[rv.ROR1Mutator]MSP[N] result [ i ++ ] = current ; } } return result ; } @Override public < T > T [] toArray ( T [] array ) {
final int entrySize = in . readInt () ; for ( int i = 0 ; i < entrySize ; i ++ ) { MST[rv.CRCR1Mutator]MSP[S] @SuppressWarnings ( lr_1 ) final E obj = ( E ) in . readObject () ; final int count = in . readInt () ;
final MutableInteger mut = map . get ( object ) ; size += nCopies ; MST[rv.AOD2Mutator]MSP[N] if ( mut == null ) { map . put ( object , new MutableInteger ( nCopies ) ) ; return true ; } mut . value += nCopies ; return false ; }
return false ; } final Bag < ? > other = ( Bag < ? > ) object ; if ( other . size () != size () ) { MST[NegateConditionalsMutator]MSP[N] return false ; } for ( final E element : map . keySet () ) {
canRemove = false ; } @Override public boolean add ( final E object ) { return add ( object , 1 ) ; MST[rv.CRCR6Mutator]MSP[N] } @Override public boolean add ( final E object , final int nCopies ) { modCount ++ ; if ( nCopies > 0 ) {
modCount ++ ; MST[rv.AOR3Mutator]MSP[S] if ( nCopies < mut . value ) { mut . value -= nCopies ; size -= nCopies ; } else { map . remove ( object ) ; size -= mut . value ; } return true ; } @Override
final boolean changed = remove ( i . next () , 1 ) ; result = result || changed ; } } return result ; } @Override public boolean retainAll ( final Collection < ? > coll ) { if ( coll instanceof Bag ) { MST[rv.ROR4Mutator]MSP[N]
map . put ( obj , new MutableInteger ( count ) ) ; size += count ; } } @Override public boolean equals ( final Object object ) { if ( object == this ) { return true ; MST[rv.CRCR6Mutator]MSP[S] } if ( object instanceof Bag == false ) {
protected void doWriteObject ( final ObjectOutputStream out ) throws IOException { out . writeInt ( map . size () ) ; for ( final Entry < E , MutableInteger > entry : map . entrySet () ) { MST[NonVoidMethodCallMutator]MSP[N] out . writeObject ( entry . getKey () ) ;
return false ; } @Override public boolean addAll ( final Collection < ? extends E > coll ) { boolean changed = false ; final Iterator < ? extends E > i = coll . iterator () ; while ( i . hasNext () ) { MST[rv.ROR4Mutator]MSP[N]
buf . append ( count ) ; buf . append ( ':' ) ; buf . append ( current ) ; if ( it . hasNext () ) { buf . append ( ',' ) ; } } buf . append ( ']' ) ; MST[rv.CRCR3Mutator]MSP[N]
return false ; MST[InlineConstantMutator]MSP[S] } @Override public boolean addAll ( final Collection < ? extends E > coll ) { boolean changed = false ; final Iterator < ? extends E > i = coll . iterator () ; while ( i . hasNext () ) {
final boolean added = add ( i . next () ) ; changed = changed || added ; } return changed ; } @Override public void clear () { modCount ++ ; MST[rv.AOD2Mutator]MSP[N] map . clear () ; size = 0 ; } @Override
final boolean added = add ( i . next () ) ; changed = changed || added ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] } return changed ; } @Override public void clear () { modCount ++ ; map . clear () ; size = 0 ; } @Override
final int entrySize = in . readInt () ; for ( int i = 0 ; i < entrySize ; i ++ ) { MST[rv.UOI3Mutator]MSP[N] @SuppressWarnings ( lr_1 ) final E obj = ( E ) in . readObject () ; final int count = in . readInt () ;
final boolean changed = remove ( i . next () , 1 ) ; result = result || changed ; } } return result ; } @Override public boolean retainAll ( final Collection < ? > coll ) { if ( coll instanceof Bag ) { MST[rv.ROR1Mutator]MSP[S]
modCount ++ ; if ( nCopies < mut . value ) { mut . value -= nCopies ; size -= nCopies ; } else { map . remove ( object ) ; size -= mut . value ; } return true ; MST[BooleanFalseReturnValsMutator]MSP[N] } @Override
out . writeInt ( entry . getValue () . value ) ; MST[rv.UOI3Mutator]MSP[N] } } protected void doReadObject ( final Map < E , MutableInteger > map , final ObjectInputStream in ) throws IOException , ClassNotFoundException { this . map = map ;
modCount ++ ; if ( nCopies < mut . value ) { mut . value -= nCopies ; size -= nCopies ; } else { map . remove ( object ) ; size -= mut . value ; MST[rv.ABSMutator]MSP[N] } return true ; } @Override
protected Map < E , MutableInteger > getMap () { return map ; MST[NullReturnValsMutator]MSP[N] } @Override public int size () { return size ; } @Override public boolean isEmpty () { return map . isEmpty () ; } @Override public int getCount ( final Object object ) {
if ( getCount ( current ) < other . getCount ( current ) ) { return false ; } } return true ; } @Override public Iterator < E > iterator () { return new BagIterator <> ( this ) ; MST[ReturnValsMutator]MSP[N] } @Override public boolean hasNext () {
final MutableInteger mut = map . get ( object ) ; size += nCopies ; if ( mut == null ) { map . put ( object , new MutableInteger ( nCopies ) ) ; return true ; } mut . value += nCopies ; MST[rv.AOR2Mutator]MSP[N] return false ; }
return false ; } @Override public boolean addAll ( final Collection < ? extends E > coll ) { boolean changed = false ; MST[InlineConstantMutator]MSP[S] final Iterator < ? extends E > i = coll . iterator () ; while ( i . hasNext () ) {
map . put ( obj , new MutableInteger ( count ) ) ; size += count ; } } @Override public boolean equals ( final Object object ) { if ( object == this ) { MST[rv.ROR5Mutator]MSP[S] return true ; } if ( object instanceof Bag == false ) {
modCount ++ ; if ( nCopies < mut . value ) { mut . value -= nCopies ; size -= nCopies ; MST[rv.UOI2Mutator]MSP[N] } else { map . remove ( object ) ; size -= mut . value ; } return true ; } @Override
modCount ++ ; if ( nCopies < mut . value ) { mut . value -= nCopies ; size -= nCopies ; } else { map . remove ( object ) ; size -= mut . value ; } return true ; MST[rv.CRCR4Mutator]MSP[S] } @Override
final MutableInteger count = map . get ( object ) ; if ( count != null ) { return count . value ; } return 0 ; } @Override public boolean contains ( final Object object ) { return map . containsKey ( object ) ; MST[BooleanFalseReturnValsMutator]MSP[N] } @Override
final MutableInteger mut = map . get ( object ) ; size += nCopies ; if ( mut == null ) { map . put ( object , new MutableInteger ( nCopies ) ) ; MST[NonVoidMethodCallMutator]MSP[N] return true ; } mut . value += nCopies ; return false ; }
modCount ++ ; if ( nCopies < mut . value ) { mut . value -= nCopies ; size -= nCopies ; } else { map . remove ( object ) ; size -= mut . value ; MST[rv.AOR3Mutator]MSP[N] } return true ; } @Override
map . put ( obj , new MutableInteger ( count ) ) ; size += count ; } } @Override public boolean equals ( final Object object ) { if ( object == this ) { return true ; MST[rv.CRCR5Mutator]MSP[S] } if ( object instanceof Bag == false ) {
total += ( element == null ? 0 : element . hashCode () ) ^ count . value ; } return total ; } @Override public String toString () { if ( size () == 0 ) { MST[NegateConditionalsMutator]MSP[N] return lr_2 ; } final StringBuilder buf = new StringBuilder () ;
final boolean added = add ( i . next () ) ; changed = changed || added ; } return changed ; } @Override public void clear () { modCount ++ ; map . clear () ; size = 0 ; MST[rv.CRCR3Mutator]MSP[S] } @Override
} @Override public boolean remove ( final Object object , final int nCopies ) { final MutableInteger mut = map . get ( object ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( mut == null ) { return false ; } if ( nCopies <= 0 ) { return false ; }
canRemove = false ; } @Override public boolean add ( final E object ) { return add ( object , 1 ) ; } @Override public boolean add ( final E object , final int nCopies ) { modCount ++ ; if ( nCopies > 0 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N]
modCount ++ ; MST[rv.AOR1Mutator]MSP[S] if ( nCopies < mut . value ) { mut . value -= nCopies ; size -= nCopies ; } else { map . remove ( object ) ; size -= mut . value ; } return true ; } @Override
map . put ( obj , new MutableInteger ( count ) ) ; size += count ; } } @Override public boolean equals ( final Object object ) { if ( object == this ) { MST[NegateConditionalsMutator]MSP[S] return true ; } if ( object instanceof Bag == false ) {
final int size = size () ; if ( array . length < size ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] @SuppressWarnings ( lr_1 ) final T [] unchecked = ( T [] ) Array . newInstance ( array . getClass () . getComponentType () , size ) ; array = unchecked ; }
protected Map < E , MutableInteger > getMap () { return map ; } @Override public int size () { return size ; } @Override public boolean isEmpty () { return map . isEmpty () ; MST[NonVoidMethodCallMutator]MSP[N] } @Override public int getCount ( final Object object ) {
for ( int index = getCount ( current ) ; index > 0 ; index -- ) { MST[ConditionalsBoundaryMutator]MSP[N] @SuppressWarnings ( lr_1 ) final T unchecked = ( T ) current ; array [ i ++ ] = unchecked ; } } while ( i < array . length ) {
final MutableInteger mut = map . get ( object ) ; size += nCopies ; if ( mut == null ) { map . put ( object , new MutableInteger ( nCopies ) ) ; return true ; } mut . value += nCopies ; MST[experimental.MemberVariableMutator]MSP[N] return false ; }
final MutableInteger count = map . get ( object ) ; if ( count != null ) { return count . value ; } return 0 ; MST[ReturnValsMutator]MSP[S] } @Override public boolean contains ( final Object object ) { return map . containsKey ( object ) ; } @Override
out . writeInt ( entry . getValue () . value ) ; MST[NonVoidMethodCallMutator]MSP[N] } } protected void doReadObject ( final Map < E , MutableInteger > map , final ObjectInputStream in ) throws IOException , ClassNotFoundException { this . map = map ;
if ( other . getCount ( element ) != getCount ( element ) ) { return false ; } } return true ; MST[ReturnValsMutator]MSP[N] } @Override public int hashCode () { int total = 0 ;
final boolean added = add ( i . next () ) ; changed = changed || added ; MST[rv.ROR1Mutator]MSP[S] } return changed ; } @Override public void clear () { modCount ++ ; map . clear () ; size = 0 ; } @Override
modCount ++ ; MST[rv.CRCR5Mutator]MSP[S] if ( nCopies < mut . value ) { mut . value -= nCopies ; size -= nCopies ; } else { map . remove ( object ) ; size -= mut . value ; } return true ; } @Override
array [ i ++ ] = null ; MST[rv.ABSMutator]MSP[N] } return array ; } @Override public Set < E > uniqueSet () { if ( uniqueSet == null ) { uniqueSet = UnmodifiableSet . <E > unmodifiableSet ( map . keySet () ) ; } return uniqueSet ; }
final Object [] result = new Object [ size () ] ; int i = 0 ; final Iterator < E > it = map . keySet () . iterator () ; while ( it . hasNext () ) { MST[NonVoidMethodCallMutator]MSP[N] final E current = it . next () ;
array [ i ++ ] = null ; } return array ; } @Override public Set < E > uniqueSet () { if ( uniqueSet == null ) { uniqueSet = UnmodifiableSet . <E > unmodifiableSet ( map . keySet () ) ; MST[NonVoidMethodCallMutator]MSP[N] } return uniqueSet ; }
map . put ( obj , new MutableInteger ( count ) ) ; size += count ; MST[experimental.MemberVariableMutator]MSP[S] } } @Override public boolean equals ( final Object object ) { if ( object == this ) { return true ; } if ( object instanceof Bag == false ) {
public boolean removeAll ( final Collection < ? > coll ) { boolean result = false ; MST[rv.CRCR5Mutator]MSP[S] if ( coll != null ) { final Iterator < ? > i = coll . iterator () ; while ( i . hasNext () ) {
final MutableInteger mut = map . get ( object ) ; size += nCopies ; if ( mut == null ) { map . put ( object , new MutableInteger ( nCopies ) ) ; return true ; } mut . value += nCopies ; return false ; MST[BooleanTrueReturnValsMutator]MSP[S] }
} @Override public boolean remove ( final Object object , final int nCopies ) { final MutableInteger mut = map . get ( object ) ; if ( mut == null ) { MST[rv.ROR5Mutator]MSP[N] return false ; } if ( nCopies <= 0 ) { return false ; }
final int entrySize = in . readInt () ; for ( int i = 0 ; i < entrySize ; i ++ ) { MST[InlineConstantMutator]MSP[S] @SuppressWarnings ( lr_1 ) final E obj = ( E ) in . readObject () ; final int count = in . readInt () ;
map . put ( obj , new MutableInteger ( count ) ) ; MST[rv.UOI4Mutator]MSP[S] size += count ; } } @Override public boolean equals ( final Object object ) { if ( object == this ) { return true ; } if ( object instanceof Bag == false ) {
return false ; } @Override public boolean addAll ( final Collection < ? extends E > coll ) { boolean changed = false ; MST[rv.CRCR3Mutator]MSP[S] final Iterator < ? extends E > i = coll . iterator () ; while ( i . hasNext () ) {
modCount ++ ; if ( nCopies < mut . value ) { mut . value -= nCopies ; size -= nCopies ; } else { map . remove ( object ) ; size -= mut . value ; MST[rv.AOD1Mutator]MSP[N] } return true ; } @Override
map . put ( obj , new MutableInteger ( count ) ) ; size += count ; } } @Override public boolean equals ( final Object object ) { if ( object == this ) { return true ; } if ( object instanceof Bag == false ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S]
return false ; } @Override public boolean addAll ( final Collection < ? extends E > coll ) { boolean changed = false ; MST[rv.CRCR6Mutator]MSP[S] final Iterator < ? extends E > i = coll . iterator () ; while ( i . hasNext () ) {
} @Override public boolean remove ( final Object object , final int nCopies ) { final MutableInteger mut = map . get ( object ) ; if ( mut == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return false ; } if ( nCopies <= 0 ) { return false ; }
} @Override public boolean remove ( final Object object , final int nCopies ) { final MutableInteger mut = map . get ( object ) ; if ( mut == null ) { return false ; MST[rv.CRCR5Mutator]MSP[N] } if ( nCopies <= 0 ) { return false ; }
map . put ( obj , new MutableInteger ( count ) ) ; size += count ; MST[rv.UOI1Mutator]MSP[N] } } @Override public boolean equals ( final Object object ) { if ( object == this ) { return true ; } if ( object instanceof Bag == false ) {
buf . append ( count ) ; MST[rv.UOI3Mutator]MSP[N] buf . append ( ':' ) ; buf . append ( current ) ; if ( it . hasNext () ) { buf . append ( ',' ) ; } } buf . append ( ']' ) ;
map . put ( obj , new MutableInteger ( count ) ) ; size += count ; MST[rv.ABSMutator]MSP[S] } } @Override public boolean equals ( final Object object ) { if ( object == this ) { return true ; } if ( object instanceof Bag == false ) {
final boolean added = add ( i . next () ) ; MST[NonVoidMethodCallMutator]MSP[N] changed = changed || added ; } return changed ; } @Override public void clear () { modCount ++ ; map . clear () ; size = 0 ; } @Override
buf . append ( count ) ; buf . append ( ':' ) ; buf . append ( current ) ; if ( it . hasNext () ) { buf . append ( ',' ) ; MST[rv.CRCR1Mutator]MSP[N] } } buf . append ( ']' ) ;
final boolean added = add ( i . next () ) ; changed = changed || added ; } return changed ; } @Override public void clear () { modCount ++ ; map . clear () ; size = 0 ; MST[InlineConstantMutator]MSP[S] } @Override
for ( int index = getCount ( current ) ; index > 0 ; index -- ) { result [ i ++ ] = current ; MST[rv.UOI4Mutator]MSP[N] } } return result ; } @Override public < T > T [] toArray ( T [] array ) {
final int size = size () ; if ( array . length < size ) { MST[NegateConditionalsMutator]MSP[N] @SuppressWarnings ( lr_1 ) final T [] unchecked = ( T [] ) Array . newInstance ( array . getClass () . getComponentType () , size ) ; array = unchecked ; }
buf . append ( count ) ; buf . append ( ':' ) ; buf . append ( current ) ; if ( it . hasNext () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] buf . append ( ',' ) ; } } buf . append ( ']' ) ;
final MutableInteger mut = map . get ( object ) ; size += nCopies ; if ( mut == null ) { map . put ( object , new MutableInteger ( nCopies ) ) ; MST[rv.UOI1Mutator]MSP[S] return true ; } mut . value += nCopies ; return false ; }
for ( int index = getCount ( current ) ; index > 0 ; index -- ) { MST[rv.ROR3Mutator]MSP[N] @SuppressWarnings ( lr_1 ) final T unchecked = ( T ) current ; array [ i ++ ] = unchecked ; } } while ( i < array . length ) {
return retainAll ( ( Bag < ? > ) coll ) ; } return retainAll ( new HashBag <> ( coll ) ) ; MST[ConstructorCallMutator]MSP[S] } boolean retainAll ( final Bag < ? > other ) { boolean result = false ;
return false ; } final Bag < ? > other = ( Bag < ? > ) object ; if ( other . size () != size () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return false ; } for ( final E element : map . keySet () ) {
final MutableInteger mut = map . get ( object ) ; size += nCopies ; if ( mut == null ) { map . put ( object , new MutableInteger ( nCopies ) ) ; return true ; MST[rv.CRCR4Mutator]MSP[S] } mut . value += nCopies ; return false ; }
final boolean added = add ( i . next () ) ; changed = changed || added ; } return changed ; } @Override public void clear () { modCount ++ ; MST[rv.CRCR5Mutator]MSP[N] map . clear () ; size = 0 ; } @Override
total += ( element == null ? 0 : element . hashCode () ) ^ count . value ; } return total ; } @Override public String toString () { if ( size () == 0 ) { MST[rv.ROR1Mutator]MSP[N] return lr_2 ; } final StringBuilder buf = new StringBuilder () ;
public boolean removeAll ( final Collection < ? > coll ) { boolean result = false ; if ( coll != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] final Iterator < ? > i = coll . iterator () ; while ( i . hasNext () ) {
array [ i ++ ] = null ; MST[rv.UOI3Mutator]MSP[N] } return array ; } @Override public Set < E > uniqueSet () { if ( uniqueSet == null ) { uniqueSet = UnmodifiableSet . <E > unmodifiableSet ( map . keySet () ) ; } return uniqueSet ; }
final MutableInteger mut = map . get ( object ) ; size += nCopies ; if ( mut == null ) { map . put ( object , new MutableInteger ( nCopies ) ) ; return true ; MST[BooleanFalseReturnValsMutator]MSP[N] } mut . value += nCopies ; return false ; }
protected Map < E , MutableInteger > getMap () { return map ; } @Override public int size () { return size ; MST[rv.UOI3Mutator]MSP[N] } @Override public boolean isEmpty () { return map . isEmpty () ; } @Override public int getCount ( final Object object ) {
modCount ++ ; if ( nCopies < mut . value ) { mut . value -= nCopies ; size -= nCopies ; MST[rv.ABSMutator]MSP[N] } else { map . remove ( object ) ; size -= mut . value ; } return true ; } @Override
buf . append ( count ) ; MST[experimental.NakedReceiverMutator]MSP[N] buf . append ( ':' ) ; buf . append ( current ) ; if ( it . hasNext () ) { buf . append ( ',' ) ; } } buf . append ( ']' ) ;
modCount ++ ; if ( nCopies < mut . value ) { mut . value -= nCopies ; size -= nCopies ; MST[rv.UOI1Mutator]MSP[N] } else { map . remove ( object ) ; size -= mut . value ; } return true ; } @Override
for ( int index = getCount ( current ) ; index > 0 ; index -- ) { MST[experimental.RemoveIncrementsMutator]MSP[N] @SuppressWarnings ( lr_1 ) final T unchecked = ( T ) current ; array [ i ++ ] = unchecked ; } } while ( i < array . length ) {
final boolean added = add ( i . next () ) ; changed = changed || added ; MST[rv.ROR1Mutator]MSP[S] } return changed ; } @Override public void clear () { modCount ++ ; map . clear () ; size = 0 ; } @Override
canRemove = false ; } @Override public boolean add ( final E object ) { return add ( object , 1 ) ; MST[BooleanTrueReturnValsMutator]MSP[N] } @Override public boolean add ( final E object , final int nCopies ) { modCount ++ ; if ( nCopies > 0 ) {
modCount ++ ; if ( nCopies < mut . value ) { mut . value -= nCopies ; size -= nCopies ; } else { map . remove ( object ) ; size -= mut . value ; MST[rv.UOI1Mutator]MSP[S] } return true ; } @Override
final boolean changed = remove ( i . next () , 1 ) ; result = result || changed ; } } return result ; MST[rv.UOI4Mutator]MSP[S] } @Override public boolean retainAll ( final Collection < ? > coll ) { if ( coll instanceof Bag ) {
final MutableInteger mut = map . get ( object ) ; size += nCopies ; MST[rv.ABSMutator]MSP[N] if ( mut == null ) { map . put ( object , new MutableInteger ( nCopies ) ) ; return true ; } mut . value += nCopies ; return false ; }
final int entrySize = in . readInt () ; for ( int i = 0 ; i < entrySize ; i ++ ) { MST[rv.CRCR5Mutator]MSP[S] @SuppressWarnings ( lr_1 ) final E obj = ( E ) in . readObject () ; final int count = in . readInt () ;
final MutableInteger mut = map . get ( object ) ; size += nCopies ; MST[rv.UOI1Mutator]MSP[S] if ( mut == null ) { map . put ( object , new MutableInteger ( nCopies ) ) ; return true ; } mut . value += nCopies ; return false ; }
} @Override public boolean remove ( final Object object , final int nCopies ) { final MutableInteger mut = map . get ( object ) ; if ( mut == null ) { return false ; } if ( nCopies <= 0 ) { MST[rv.ROR3Mutator]MSP[S] return false ; }
final boolean added = add ( i . next () ) ; changed = changed || added ; } return changed ; } @Override public void clear () { modCount ++ ; map . clear () ; size = 0 ; MST[rv.CRCR6Mutator]MSP[S] } @Override
final MutableInteger mut = map . get ( object ) ; size += nCopies ; MST[rv.UOI3Mutator]MSP[N] if ( mut == null ) { map . put ( object , new MutableInteger ( nCopies ) ) ; return true ; } mut . value += nCopies ; return false ; }
final MutableInteger mut = map . get ( object ) ; size += nCopies ; MST[MathMutator]MSP[N] if ( mut == null ) { map . put ( object , new MutableInteger ( nCopies ) ) ; return true ; } mut . value += nCopies ; return false ; }
canRemove = false ; } @Override public boolean add ( final E object ) { return add ( object , 1 ) ; MST[BooleanFalseReturnValsMutator]MSP[N] } @Override public boolean add ( final E object , final int nCopies ) { modCount ++ ; if ( nCopies > 0 ) {
for ( int index = getCount ( current ) ; index > 0 ; index -- ) { MST[NegateConditionalsMutator]MSP[N] @SuppressWarnings ( lr_1 ) final T unchecked = ( T ) current ; array [ i ++ ] = unchecked ; } } while ( i < array . length ) {
if ( other . getCount ( element ) != getCount ( element ) ) { return false ; } } return true ; MST[BooleanFalseReturnValsMutator]MSP[N] } @Override public int hashCode () { int total = 0 ;
int i = 0 ; final Iterator < E > it = map . keySet () . iterator () ; while ( it . hasNext () ) { MST[rv.ROR5Mutator]MSP[N] final E current = it . next () ;
buf . append ( '[' ) ; final Iterator < E > it = uniqueSet () . iterator () ; while ( it . hasNext () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] final Object current = it . next () ; final int count = getCount ( current ) ;
final MutableInteger count = map . get ( object ) ; if ( count != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return count . value ; } return 0 ; } @Override public boolean contains ( final Object object ) { return map . containsKey ( object ) ; } @Override
canRemove = false ; } @Override public boolean add ( final E object ) { return add ( object , 1 ) ; } @Override public boolean add ( final E object , final int nCopies ) { modCount ++ ; MST[rv.UOI2Mutator]MSP[S] if ( nCopies > 0 ) {
final boolean added = add ( i . next () ) ; changed = changed || added ; } return changed ; } @Override public void clear () { modCount ++ ; MST[MathMutator]MSP[N] map . clear () ; size = 0 ; } @Override
final MutableInteger mut = map . get ( object ) ; size += nCopies ; MST[experimental.MemberVariableMutator]MSP[N] if ( mut == null ) { map . put ( object , new MutableInteger ( nCopies ) ) ; return true ; } mut . value += nCopies ; return false ; }
for ( int index = getCount ( current ) ; index > 0 ; index -- ) { MST[rv.UOI1Mutator]MSP[N] result [ i ++ ] = current ; } } return result ; } @Override public < T > T [] toArray ( T [] array ) {
int i = 0 ; MST[rv.CRCR5Mutator]MSP[N] final Iterator < E > it = map . keySet () . iterator () ; while ( it . hasNext () ) { final E current = it . next () ;
final boolean added = add ( i . next () ) ; changed = changed || added ; MST[rv.ROR4Mutator]MSP[S] } return changed ; } @Override public void clear () { modCount ++ ; map . clear () ; size = 0 ; } @Override
final boolean added = add ( i . next () ) ; changed = changed || added ; } return changed ; } @Override public void clear () { modCount ++ ; MST[rv.AOR2Mutator]MSP[N] map . clear () ; size = 0 ; } @Override
buf . append ( count ) ; buf . append ( ':' ) ; buf . append ( current ) ; if ( it . hasNext () ) { buf . append ( ',' ) ; } } buf . append ( ']' ) ; MST[rv.CRCR6Mutator]MSP[N]
final MutableInteger mut = map . get ( object ) ; size += nCopies ; MST[rv.AOR2Mutator]MSP[N] if ( mut == null ) { map . put ( object , new MutableInteger ( nCopies ) ) ; return true ; } mut . value += nCopies ; return false ; }
buf . append ( count ) ; MST[rv.ABSMutator]MSP[N] buf . append ( ':' ) ; buf . append ( current ) ; if ( it . hasNext () ) { buf . append ( ',' ) ; } } buf . append ( ']' ) ;
return false ; } @Override public boolean addAll ( final Collection < ? extends E > coll ) { boolean changed = false ; final Iterator < ? extends E > i = coll . iterator () ; while ( i . hasNext () ) { MST[rv.ROR1Mutator]MSP[S]
buf . append ( count ) ; buf . append ( ':' ) ; buf . append ( current ) ; if ( it . hasNext () ) { buf . append ( ',' ) ; } } buf . append ( ']' ) ; MST[experimental.NakedReceiverMutator]MSP[N]
final boolean added = add ( i . next () ) ; changed = changed || added ; } return changed ; } @Override public void clear () { modCount ++ ; MST[rv.CRCR3Mutator]MSP[N] map . clear () ; size = 0 ; } @Override
canRemove = false ; } @Override public boolean add ( final E object ) { return add ( object , 1 ) ; } @Override public boolean add ( final E object , final int nCopies ) { modCount ++ ; if ( nCopies > 0 ) { MST[rv.ROR5Mutator]MSP[N]
if ( other . getCount ( element ) != getCount ( element ) ) { MST[NonVoidMethodCallMutator]MSP[S] return false ; } } return true ; } @Override public int hashCode () { int total = 0 ;
return false ; MST[rv.CRCR5Mutator]MSP[S] } @Override public boolean addAll ( final Collection < ? extends E > coll ) { boolean changed = false ; final Iterator < ? extends E > i = coll . iterator () ; while ( i . hasNext () ) {
for ( int index = getCount ( current ) ; index > 0 ; index -- ) { MST[rv.ROR5Mutator]MSP[N] @SuppressWarnings ( lr_1 ) final T unchecked = ( T ) current ; array [ i ++ ] = unchecked ; } } while ( i < array . length ) {
buf . append ( count ) ; buf . append ( ':' ) ; MST[rv.CRCR1Mutator]MSP[N] buf . append ( current ) ; if ( it . hasNext () ) { buf . append ( ',' ) ; } } buf . append ( ']' ) ;
final boolean added = add ( i . next () ) ; changed = changed || added ; MST[rv.UOI3Mutator]MSP[S] } return changed ; } @Override public void clear () { modCount ++ ; map . clear () ; size = 0 ; } @Override
} @Override public boolean remove ( final Object object , final int nCopies ) { final MutableInteger mut = map . get ( object ) ; if ( mut == null ) { return false ; } if ( nCopies <= 0 ) { MST[ConditionalsBoundaryMutator]MSP[S] return false ; }
final int entrySize = in . readInt () ; for ( int i = 0 ; i < entrySize ; i ++ ) { MST[rv.ABSMutator]MSP[S] @SuppressWarnings ( lr_1 ) final E obj = ( E ) in . readObject () ; final int count = in . readInt () ;
if ( other . getCount ( element ) != getCount ( element ) ) { return false ; } } return true ; } @Override public int hashCode () { int total = 0 ; MST[rv.CRCR5Mutator]MSP[N]
int i = 0 ; final Iterator < E > it = map . keySet () . iterator () ; while ( it . hasNext () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] final E current = it . next () ;
final boolean added = add ( i . next () ) ; changed = changed || added ; } return changed ; } @Override public void clear () { modCount ++ ; MST[experimental.MemberVariableMutator]MSP[N] map . clear () ; size = 0 ; } @Override
