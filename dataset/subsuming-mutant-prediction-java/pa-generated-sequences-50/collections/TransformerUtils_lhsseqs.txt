public static < T > Transformer < T , T > nopTransformer () { return NOPTransformer . nopTransformer () ; } public static < T > Transformer < T , T > cloneTransformer () { return CloneTransformer . cloneTransformer () ; MST[NullReturnValsMutator]MSP[] }
public static < T > Transformer < T , String > stringValueTransformer () { return StringValueTransformer . stringValueTransformer () ; MST[ReturnValsMutator]MSP[] }
final Transformer < ? super I , ? extends O > falseTransformer ) { return SwitchTransformer . switchTransformer ( new Predicate [] { predicate } , MST[rv.CRCR5Mutator]MSP[] new Transformer [] { trueTransformer } , falseTransformer ) ; }
return SwitchTransformer . switchTransformer ( predicates , transformers , null ) ; MST[NonVoidMethodCallMutator]MSP[] } public static < I , O > Transformer < I , O > switchTransformer ( final Predicate < ? super I > [] predicates ,
final Transformer < ? super I , ? extends O > falseTransformer ) { return SwitchTransformer . switchTransformer ( new Predicate [] { predicate } , MST[rv.CRCR3Mutator]MSP[] new Transformer [] { trueTransformer } , falseTransformer ) ; }
final Transformer < ? super I , ? extends O > falseTransformer ) { return SwitchTransformer . switchTransformer ( new Predicate [] { predicate } , MST[InlineConstantMutator]MSP[] new Transformer [] { trueTransformer } , falseTransformer ) ; }
final Transformer < ? super I , ? extends O > falseTransformer ) { return SwitchTransformer . switchTransformer ( new Predicate [] { predicate } , MST[rv.CRCR4Mutator]MSP[] new Transformer [] { trueTransformer } , falseTransformer ) ; }
final Transformer < ? super I , ? extends O > falseTransformer ) { return SwitchTransformer . switchTransformer ( new Predicate [] { predicate } , MST[rv.CRCR2Mutator]MSP[] new Transformer [] { trueTransformer } , falseTransformer ) ; }
final Transformer < ? super I , ? extends O > falseTransformer ) { return SwitchTransformer . switchTransformer ( new Predicate [] { predicate } , MST[rv.CRCR6Mutator]MSP[] new Transformer [] { trueTransformer } , falseTransformer ) ; }
public static < T > Transformer < Class < ? extends T > , T > instantiateTransformer () { return InstantiateTransformer . instantiateTransformer () ; MST[NonVoidMethodCallMutator]MSP[] } public static < T > Transformer < Class < ? extends T > , T > instantiateTransformer (
public static < T > Transformer < T , Boolean > asTransformer ( final Predicate < ? super T > predicate ) { return PredicateTransformer . predicateTransformer ( predicate ) ; MST[NonVoidMethodCallMutator]MSP[] }
preds [ i ] = EqualPredicate . <I > equalPredicate ( entry . getKey () ) ; trs [ i ++ ] = entry . getValue () ; MST[NonVoidMethodCallMutator]MSP[] } return TransformerUtils . switchTransformer ( preds , trs , def ) ; }
final Transformer < ? super I , ? extends O > falseTransformer ) { return SwitchTransformer . switchTransformer ( new Predicate [] { predicate } , MST[NullReturnValsMutator]MSP[] new Transformer [] { trueTransformer } , falseTransformer ) ; }
final Transformer < ? super I , ? extends O > trueTransformer , final Transformer < ? super I , ? extends O > falseTransformer ) { return IfTransformer . ifTransformer ( predicate , trueTransformer , falseTransformer ) ; MST[NullReturnValsMutator]MSP[] } @SuppressWarnings ( lr_1 ) @Deprecated
preds [ i ] = EqualPredicate . <I > equalPredicate ( entry . getKey () ) ; MST[NonVoidMethodCallMutator]MSP[] trs [ i ++ ] = entry . getValue () ; } return TransformerUtils . switchTransformer ( preds , trs , def ) ; }
public static < I , O > Transformer < I , O > mapTransformer ( final Map < ? super I , ? extends O > map ) { return MapTransformer . mapTransformer ( map ) ; MST[NonVoidMethodCallMutator]MSP[] }
preds [ i ] = EqualPredicate . <I > equalPredicate ( entry . getKey () ) ; trs [ i ++ ] = entry . getValue () ; } return TransformerUtils . switchTransformer ( preds , trs , def ) ; MST[NullReturnValsMutator]MSP[] }
public static < I , O > Transformer < I , O > exceptionTransformer () { return ExceptionTransformer . exceptionTransformer () ; MST[ReturnValsMutator]MSP[] } public static < I , O > Transformer < I , O > nullTransformer () { return ConstantTransformer . nullTransformer () ; }
public static < I , O > Transformer < I , O > invokerTransformer ( final String methodName ) { return InvokerTransformer . invokerTransformer ( methodName , null , null ) ; MST[NullReturnValsMutator]MSP[] }
public static < T > Transformer < T , T > asTransformer ( final Closure < ? super T > closure ) { return ClosureTransformer . closureTransformer ( closure ) ; MST[NullReturnValsMutator]MSP[] }
final Transformer < ? super I , ? extends O > def = objectsAndTransformers . remove ( null ) ; final int size = objectsAndTransformers . size () ; MST[NonVoidMethodCallMutator]MSP[] final Transformer < ? super I , ? extends O > [] trs = new Transformer [ size ] ;
final Transformer < ? super I , ? extends O > def = objectsAndTransformers . remove ( null ) ; final int size = objectsAndTransformers . size () ; final Transformer < ? super I , ? extends O > [] trs = new Transformer [ size ] ; MST[rv.UOI1Mutator]MSP[]
public static < I , O > Transformer < I , O > switchMapTransformer ( final Map < I , Transformer < I , O > > objectsAndTransformers ) { Objects . requireNonNull ( objectsAndTransformers , lr_2 ) ; MST[NonVoidMethodCallMutator]MSP[]
final Transformer < ? super I , ? extends O > def = objectsAndTransformers . remove ( null ) ; final int size = objectsAndTransformers . size () ; final Transformer < ? super I , ? extends O > [] trs = new Transformer [ size ] ; MST[rv.UOI3Mutator]MSP[]
public static < I , O > Transformer < I , O > invokerTransformer ( final String methodName , final Class < ? > [] paramTypes , final Object [] args ) { return InvokerTransformer . invokerTransformer ( methodName , paramTypes , args ) ; MST[NonVoidMethodCallMutator]MSP[] }
preds [ i ] = EqualPredicate . <I > equalPredicate ( entry . getKey () ) ; trs [ i ++ ] = entry . getValue () ; MST[IncrementsMutator]MSP[] } return TransformerUtils . switchTransformer ( preds , trs , def ) ; }
preds [ i ] = EqualPredicate . <I > equalPredicate ( entry . getKey () ) ; trs [ i ++ ] = entry . getValue () ; } return TransformerUtils . switchTransformer ( preds , trs , def ) ; MST[NonVoidMethodCallMutator]MSP[] }
public static < T > Transformer < T , T > nopTransformer () { return NOPTransformer . nopTransformer () ; } public static < T > Transformer < T , T > cloneTransformer () { return CloneTransformer . cloneTransformer () ; MST[ReturnValsMutator]MSP[] }
public static < T > Transformer < Class < ? extends T > , T > instantiateTransformer () { return InstantiateTransformer . instantiateTransformer () ; MST[NullReturnValsMutator]MSP[] } public static < T > Transformer < Class < ? extends T > , T > instantiateTransformer (
public static < I , O > Transformer < I , O > switchTransformer ( final Map < Predicate < I > , Transformer < I , O > > predicatesAndTransformers ) { return SwitchTransformer . switchTransformer ( predicatesAndTransformers ) ; MST[NullReturnValsMutator]MSP[] } @SuppressWarnings ( lr_1 )
public static < T > Transformer < T , T > nopTransformer () { return NOPTransformer . nopTransformer () ; MST[ReturnValsMutator]MSP[] } public static < T > Transformer < T , T > cloneTransformer () { return CloneTransformer . cloneTransformer () ; }
final Transformer < ? super I , ? extends O > falseTransformer ) { return SwitchTransformer . switchTransformer ( new Predicate [] { predicate } , MST[InlineConstantMutator]MSP[] new Transformer [] { trueTransformer } , falseTransformer ) ; }
final Transformer < ? super I , ? extends O > falseTransformer ) { return SwitchTransformer . switchTransformer ( new Predicate [] { predicate } , MST[rv.CRCR6Mutator]MSP[] new Transformer [] { trueTransformer } , falseTransformer ) ; }
final Transformer < ? super T , ? extends T > trueTransformer ) { return IfTransformer . ifTransformer ( predicate , trueTransformer ) ; MST[NonVoidMethodCallMutator]MSP[] } public static < I , O > Transformer < I , O > ifTransformer ( final Predicate < ? super I > predicate ,
final Transformer < ? super I , ? extends O > def = objectsAndTransformers . remove ( null ) ; MST[ArgumentPropagationMutator]MSP[] final int size = objectsAndTransformers . size () ; final Transformer < ? super I , ? extends O > [] trs = new Transformer [ size ] ;
final Transformer < ? super I , ? extends O > falseTransformer ) { return SwitchTransformer . switchTransformer ( new Predicate [] { predicate } , MST[rv.CRCR5Mutator]MSP[] new Transformer [] { trueTransformer } , falseTransformer ) ; }
public static < I , O > Transformer < I , O > exceptionTransformer () { return ExceptionTransformer . exceptionTransformer () ; MST[NonVoidMethodCallMutator]MSP[] } public static < I , O > Transformer < I , O > nullTransformer () { return ConstantTransformer . nullTransformer () ; }
preds [ i ] = EqualPredicate . <I > equalPredicate ( entry . getKey () ) ; trs [ i ++ ] = entry . getValue () ; } return TransformerUtils . switchTransformer ( preds , trs , def ) ; MST[ReturnValsMutator]MSP[] }
final Transformer < ? super I , ? extends O > falseTransformer ) { return SwitchTransformer . switchTransformer ( new Predicate [] { predicate } , MST[rv.CRCR3Mutator]MSP[] new Transformer [] { trueTransformer } , falseTransformer ) ; }
final Predicate < I > [] preds = new Predicate [ size ] ; int i = 0 ; MST[rv.CRCR3Mutator]MSP[] for ( final Map . Entry < I , Transformer < I , O > > entry : objectsAndTransformers . entrySet () ) {
public static < T > Transformer < T , T > nopTransformer () { return NOPTransformer . nopTransformer () ; MST[NonVoidMethodCallMutator]MSP[] } public static < T > Transformer < T , T > cloneTransformer () { return CloneTransformer . cloneTransformer () ; }
preds [ i ] = EqualPredicate . <I > equalPredicate ( entry . getKey () ) ; MST[NonVoidMethodCallMutator]MSP[] trs [ i ++ ] = entry . getValue () ; } return TransformerUtils . switchTransformer ( preds , trs , def ) ; }
final Predicate < I > [] preds = new Predicate [ size ] ; int i = 0 ; MST[rv.CRCR6Mutator]MSP[] for ( final Map . Entry < I , Transformer < I , O > > entry : objectsAndTransformers . entrySet () ) {
public static < I , O > Transformer < I , O > constantTransformer ( final O constantToReturn ) { return ConstantTransformer . constantTransformer ( constantToReturn ) ; MST[NonVoidMethodCallMutator]MSP[] }
public static < I , O > Transformer < I , O > exceptionTransformer () { return ExceptionTransformer . exceptionTransformer () ; } public static < I , O > Transformer < I , O > nullTransformer () { return ConstantTransformer . nullTransformer () ; MST[NonVoidMethodCallMutator]MSP[] }
public static < T > Transformer < Class < ? extends T > , T > instantiateTransformer () { return InstantiateTransformer . instantiateTransformer () ; MST[ReturnValsMutator]MSP[] } public static < T > Transformer < Class < ? extends T > , T > instantiateTransformer (
final Transformer < ? super I , ? extends O > falseTransformer ) { return SwitchTransformer . switchTransformer ( new Predicate [] { predicate } , MST[ReturnValsMutator]MSP[] new Transformer [] { trueTransformer } , falseTransformer ) ; }
final Transformer < ? super I , ? extends O > [] transformers , final Transformer < ? super I , ? extends O > defaultTransformer ) { return SwitchTransformer . switchTransformer ( predicates , transformers , defaultTransformer ) ; MST[ArgumentPropagationMutator]MSP[] }
final Predicate < I > [] preds = new Predicate [ size ] ; MST[rv.UOI3Mutator]MSP[] int i = 0 ; for ( final Map . Entry < I , Transformer < I , O > > entry : objectsAndTransformers . entrySet () ) {
final Transformer < ? super I , ? extends O > falseTransformer ) { return SwitchTransformer . switchTransformer ( new Predicate [] { predicate } , MST[rv.CRCR1Mutator]MSP[] new Transformer [] { trueTransformer } , falseTransformer ) ; }
final Transformer < ? super I , ? extends O > trueTransformer , final Transformer < ? super I , ? extends O > falseTransformer ) { return IfTransformer . ifTransformer ( predicate , trueTransformer , falseTransformer ) ; MST[ArgumentPropagationMutator]MSP[] } @SuppressWarnings ( lr_1 ) @Deprecated
final Transformer < ? super I , ? extends O > def = objectsAndTransformers . remove ( null ) ; final int size = objectsAndTransformers . size () ; final Transformer < ? super I , ? extends O > [] trs = new Transformer [ size ] ; MST[rv.UOI4Mutator]MSP[]
public static < I , O > Transformer < I , O > asTransformer ( final Factory < ? extends O > factory ) { return FactoryTransformer . factoryTransformer ( factory ) ; MST[NullReturnValsMutator]MSP[] } public static < T > Transformer < T , T > chainedTransformer (
final Class < ? > [] paramTypes , final Object [] args ) { return InstantiateTransformer . instantiateTransformer ( paramTypes , args ) ; MST[ReturnValsMutator]MSP[] }
final Transformer < ? super I , ? extends O > trueTransformer , final Transformer < ? super I , ? extends O > falseTransformer ) { return IfTransformer . ifTransformer ( predicate , trueTransformer , falseTransformer ) ; MST[NonVoidMethodCallMutator]MSP[] } @SuppressWarnings ( lr_1 ) @Deprecated
final Predicate < I > [] preds = new Predicate [ size ] ; int i = 0 ; for ( final Map . Entry < I , Transformer < I , O > > entry : objectsAndTransformers . entrySet () ) { MST[NonVoidMethodCallMutator]MSP[]
public static < I , O > Transformer < I , O > switchTransformer ( final Map < Predicate < I > , Transformer < I , O > > predicatesAndTransformers ) { return SwitchTransformer . switchTransformer ( predicatesAndTransformers ) ; MST[ReturnValsMutator]MSP[] } @SuppressWarnings ( lr_1 )
final Transformer < ? super T , ? extends T > ... transformers ) { return ChainedTransformer . chainedTransformer ( transformers ) ; MST[NullReturnValsMutator]MSP[] } public static < T > Transformer < T , T > chainedTransformer (
preds [ i ] = EqualPredicate . <I > equalPredicate ( entry . getKey () ) ; trs [ i ++ ] = entry . getValue () ; MST[rv.UOI1Mutator]MSP[] } return TransformerUtils . switchTransformer ( preds , trs , def ) ; }
preds [ i ] = EqualPredicate . <I > equalPredicate ( entry . getKey () ) ; trs [ i ++ ] = entry . getValue () ; MST[rv.UOI3Mutator]MSP[] } return TransformerUtils . switchTransformer ( preds , trs , def ) ; }
preds [ i ] = EqualPredicate . <I > equalPredicate ( entry . getKey () ) ; trs [ i ++ ] = entry . getValue () ; MST[rv.UOI2Mutator]MSP[] } return TransformerUtils . switchTransformer ( preds , trs , def ) ; }
public static < I , O > Transformer < I , O > mapTransformer ( final Map < ? super I , ? extends O > map ) { return MapTransformer . mapTransformer ( map ) ; MST[ReturnValsMutator]MSP[] }
return SwitchTransformer . switchTransformer ( predicates , transformers , null ) ; MST[ReturnValsMutator]MSP[] } public static < I , O > Transformer < I , O > switchTransformer ( final Predicate < ? super I > [] predicates ,
final Transformer < ? super T , ? extends T > trueTransformer ) { return IfTransformer . ifTransformer ( predicate , trueTransformer ) ; MST[NullReturnValsMutator]MSP[] } public static < I , O > Transformer < I , O > ifTransformer ( final Predicate < ? super I > predicate ,
final Transformer < ? super I , ? extends O > [] transformers , final Transformer < ? super I , ? extends O > defaultTransformer ) { return SwitchTransformer . switchTransformer ( predicates , transformers , defaultTransformer ) ; MST[NonVoidMethodCallMutator]MSP[] }
preds [ i ] = EqualPredicate . <I > equalPredicate ( entry . getKey () ) ; MST[rv.UOI1Mutator]MSP[] trs [ i ++ ] = entry . getValue () ; } return TransformerUtils . switchTransformer ( preds , trs , def ) ; }
preds [ i ] = EqualPredicate . <I > equalPredicate ( entry . getKey () ) ; MST[rv.UOI3Mutator]MSP[] trs [ i ++ ] = entry . getValue () ; } return TransformerUtils . switchTransformer ( preds , trs , def ) ; }
preds [ i ] = EqualPredicate . <I > equalPredicate ( entry . getKey () ) ; MST[rv.UOI2Mutator]MSP[] trs [ i ++ ] = entry . getValue () ; } return TransformerUtils . switchTransformer ( preds , trs , def ) ; }
public static < T > Transformer < T , String > stringValueTransformer () { return StringValueTransformer . stringValueTransformer () ; MST[NonVoidMethodCallMutator]MSP[] }
final Transformer < ? super I , ? extends O > falseTransformer ) { return SwitchTransformer . switchTransformer ( new Predicate [] { predicate } , MST[rv.CRCR4Mutator]MSP[] new Transformer [] { trueTransformer } , falseTransformer ) ; }
final Transformer < ? super I , ? extends O > falseTransformer ) { return SwitchTransformer . switchTransformer ( new Predicate [] { predicate } , MST[rv.CRCR3Mutator]MSP[] new Transformer [] { trueTransformer } , falseTransformer ) ; }
final Transformer < ? super I , ? extends O > falseTransformer ) { return SwitchTransformer . switchTransformer ( new Predicate [] { predicate } , MST[rv.CRCR5Mutator]MSP[] new Transformer [] { trueTransformer } , falseTransformer ) ; }
final Transformer < ? super I , ? extends O > falseTransformer ) { return SwitchTransformer . switchTransformer ( new Predicate [] { predicate } , MST[rv.CRCR2Mutator]MSP[] new Transformer [] { trueTransformer } , falseTransformer ) ; }
final Transformer < ? super I , ? extends O > falseTransformer ) { return SwitchTransformer . switchTransformer ( new Predicate [] { predicate } , MST[rv.CRCR6Mutator]MSP[] new Transformer [] { trueTransformer } , falseTransformer ) ; }
final Collection < ? extends Transformer < ? super T , ? extends T > > transformers ) { return ChainedTransformer . chainedTransformer ( transformers ) ; MST[NonVoidMethodCallMutator]MSP[] } public static < T > Transformer < T , T > ifTransformer ( final Predicate < ? super T > predicate ,
preds [ i ] = EqualPredicate . <I > equalPredicate ( entry . getKey () ) ; trs [ i ++ ] = entry . getValue () ; MST[rv.UOI4Mutator]MSP[] } return TransformerUtils . switchTransformer ( preds , trs , def ) ; }
final Predicate < I > [] preds = new Predicate [ size ] ; int i = 0 ; MST[InlineConstantMutator]MSP[] for ( final Map . Entry < I , Transformer < I , O > > entry : objectsAndTransformers . entrySet () ) {
public static < T > Transformer < T , T > asTransformer ( final Closure < ? super T > closure ) { return ClosureTransformer . closureTransformer ( closure ) ; MST[NonVoidMethodCallMutator]MSP[] }
public static < T > Transformer < T , Boolean > asTransformer ( final Predicate < ? super T > predicate ) { return PredicateTransformer . predicateTransformer ( predicate ) ; MST[ReturnValsMutator]MSP[] }
final Transformer < ? super I , ? extends O > def = objectsAndTransformers . remove ( null ) ; final int size = objectsAndTransformers . size () ; final Transformer < ? super I , ? extends O > [] trs = new Transformer [ size ] ; MST[rv.ABSMutator]MSP[]
public static < I , O > Transformer < I , O > invokerTransformer ( final String methodName ) { return InvokerTransformer . invokerTransformer ( methodName , null , null ) ; MST[NonVoidMethodCallMutator]MSP[] }
final Predicate < I > [] preds = new Predicate [ size ] ; MST[rv.UOI2Mutator]MSP[] int i = 0 ; for ( final Map . Entry < I , Transformer < I , O > > entry : objectsAndTransformers . entrySet () ) {
return SwitchTransformer . switchTransformer ( predicates , transformers , null ) ; MST[ArgumentPropagationMutator]MSP[] } public static < I , O > Transformer < I , O > switchTransformer ( final Predicate < ? super I > [] predicates ,
final Transformer < ? super T , ? extends T > trueTransformer ) { return IfTransformer . ifTransformer ( predicate , trueTransformer ) ; MST[ReturnValsMutator]MSP[] } public static < I , O > Transformer < I , O > ifTransformer ( final Predicate < ? super I > predicate ,
final Transformer < ? super I , ? extends O > def = objectsAndTransformers . remove ( null ) ; MST[NonVoidMethodCallMutator]MSP[] final int size = objectsAndTransformers . size () ; final Transformer < ? super I , ? extends O > [] trs = new Transformer [ size ] ;
final Transformer < ? super T , ? extends T > trueTransformer ) { return IfTransformer . ifTransformer ( predicate , trueTransformer ) ; MST[ArgumentPropagationMutator]MSP[] } public static < I , O > Transformer < I , O > ifTransformer ( final Predicate < ? super I > predicate ,
public static < I , O > Transformer < I , O > constantTransformer ( final O constantToReturn ) { return ConstantTransformer . constantTransformer ( constantToReturn ) ; MST[ReturnValsMutator]MSP[] }
final Collection < ? extends Transformer < ? super T , ? extends T > > transformers ) { return ChainedTransformer . chainedTransformer ( transformers ) ; MST[NullReturnValsMutator]MSP[] } public static < T > Transformer < T , T > ifTransformer ( final Predicate < ? super T > predicate ,
final Transformer < ? super I , ? extends O > [] transformers , final Transformer < ? super I , ? extends O > defaultTransformer ) { return SwitchTransformer . switchTransformer ( predicates , transformers , defaultTransformer ) ; MST[NullReturnValsMutator]MSP[] }
final Transformer < ? super I , ? extends O > falseTransformer ) { return SwitchTransformer . switchTransformer ( new Predicate [] { predicate } , MST[InlineConstantMutator]MSP[] new Transformer [] { trueTransformer } , falseTransformer ) ; }
final Predicate < I > [] preds = new Predicate [ size ] ; MST[rv.UOI4Mutator]MSP[] int i = 0 ; for ( final Map . Entry < I , Transformer < I , O > > entry : objectsAndTransformers . entrySet () ) {
public static < I , O > Transformer < I , O > invokerTransformer ( final String methodName , final Class < ? > [] paramTypes , final Object [] args ) { return InvokerTransformer . invokerTransformer ( methodName , paramTypes , args ) ; MST[ReturnValsMutator]MSP[] }
public static < I , O > Transformer < I , O > exceptionTransformer () { return ExceptionTransformer . exceptionTransformer () ; } public static < I , O > Transformer < I , O > nullTransformer () { return ConstantTransformer . nullTransformer () ; MST[NullReturnValsMutator]MSP[] }
final Class < ? > [] paramTypes , final Object [] args ) { return InstantiateTransformer . instantiateTransformer ( paramTypes , args ) ; MST[NullReturnValsMutator]MSP[] }
final Transformer < ? super T , ? extends T > ... transformers ) { return ChainedTransformer . chainedTransformer ( transformers ) ; MST[NonVoidMethodCallMutator]MSP[] } public static < T > Transformer < T , T > chainedTransformer (
public static < I , O > Transformer < I , O > asTransformer ( final Factory < ? extends O > factory ) { return FactoryTransformer . factoryTransformer ( factory ) ; MST[ReturnValsMutator]MSP[] } public static < T > Transformer < T , T > chainedTransformer (
return SwitchTransformer . switchTransformer ( predicates , transformers , null ) ; MST[NullReturnValsMutator]MSP[] } public static < I , O > Transformer < I , O > switchTransformer ( final Predicate < ? super I > [] predicates ,
preds [ i ] = EqualPredicate . <I > equalPredicate ( entry . getKey () ) ; trs [ i ++ ] = entry . getValue () ; MST[rv.ABSMutator]MSP[] } return TransformerUtils . switchTransformer ( preds , trs , def ) ; }
public static < I , O > Transformer < I , O > mapTransformer ( final Map < ? super I , ? extends O > map ) { return MapTransformer . mapTransformer ( map ) ; MST[NullReturnValsMutator]MSP[] }
final Transformer < ? super T , ? extends T > ... transformers ) { return ChainedTransformer . chainedTransformer ( transformers ) ; MST[ReturnValsMutator]MSP[] } public static < T > Transformer < T , T > chainedTransformer (
public static < T > Transformer < T , String > stringValueTransformer () { return StringValueTransformer . stringValueTransformer () ; MST[NullReturnValsMutator]MSP[] }
preds [ i ] = EqualPredicate . <I > equalPredicate ( entry . getKey () ) ; trs [ i ++ ] = entry . getValue () ; } return TransformerUtils . switchTransformer ( preds , trs , def ) ; MST[ArgumentPropagationMutator]MSP[] }
preds [ i ] = EqualPredicate . <I > equalPredicate ( entry . getKey () ) ; MST[rv.ABSMutator]MSP[] trs [ i ++ ] = entry . getValue () ; } return TransformerUtils . switchTransformer ( preds , trs , def ) ; }
public static < I , O > Transformer < I , O > switchMapTransformer ( final Map < I , Transformer < I , O > > objectsAndTransformers ) { Objects . requireNonNull ( objectsAndTransformers , lr_2 ) ; MST[ArgumentPropagationMutator]MSP[]
public static < T > Transformer < T , T > nopTransformer () { return NOPTransformer . nopTransformer () ; } public static < T > Transformer < T , T > cloneTransformer () { return CloneTransformer . cloneTransformer () ; MST[NonVoidMethodCallMutator]MSP[] }
final Transformer < ? super I , ? extends O > falseTransformer ) { return SwitchTransformer . switchTransformer ( new Predicate [] { predicate } , MST[rv.CRCR3Mutator]MSP[] new Transformer [] { trueTransformer } , falseTransformer ) ; }
public static < I , O > Transformer < I , O > switchTransformer ( final Map < Predicate < I > , Transformer < I , O > > predicatesAndTransformers ) { return SwitchTransformer . switchTransformer ( predicatesAndTransformers ) ; MST[NonVoidMethodCallMutator]MSP[] } @SuppressWarnings ( lr_1 )
public static < I , O > Transformer < I , O > asTransformer ( final Factory < ? extends O > factory ) { return FactoryTransformer . factoryTransformer ( factory ) ; MST[NonVoidMethodCallMutator]MSP[] } public static < T > Transformer < T , T > chainedTransformer (
final Transformer < ? super I , ? extends O > falseTransformer ) { return SwitchTransformer . switchTransformer ( new Predicate [] { predicate } , MST[rv.CRCR6Mutator]MSP[] new Transformer [] { trueTransformer } , falseTransformer ) ; }
final Transformer < ? super I , ? extends O > falseTransformer ) { return SwitchTransformer . switchTransformer ( new Predicate [] { predicate } , MST[rv.CRCR5Mutator]MSP[] new Transformer [] { trueTransformer } , falseTransformer ) ; }
final Transformer < ? super I , ? extends O > trueTransformer , final Transformer < ? super I , ? extends O > falseTransformer ) { return IfTransformer . ifTransformer ( predicate , trueTransformer , falseTransformer ) ; MST[ReturnValsMutator]MSP[] } @SuppressWarnings ( lr_1 ) @Deprecated
final Predicate < I > [] preds = new Predicate [ size ] ; int i = 0 ; MST[rv.CRCR5Mutator]MSP[] for ( final Map . Entry < I , Transformer < I , O > > entry : objectsAndTransformers . entrySet () ) {
final Predicate < I > [] preds = new Predicate [ size ] ; int i = 0 ; MST[rv.CRCR1Mutator]MSP[] for ( final Map . Entry < I , Transformer < I , O > > entry : objectsAndTransformers . entrySet () ) {
final Class < ? > [] paramTypes , final Object [] args ) { return InstantiateTransformer . instantiateTransformer ( paramTypes , args ) ; MST[NonVoidMethodCallMutator]MSP[] }
public static < I , O > Transformer < I , O > invokerTransformer ( final String methodName , final Class < ? > [] paramTypes , final Object [] args ) { return InvokerTransformer . invokerTransformer ( methodName , paramTypes , args ) ; MST[NullReturnValsMutator]MSP[] }
final Predicate < I > [] preds = new Predicate [ size ] ; MST[rv.UOI1Mutator]MSP[] int i = 0 ; for ( final Map . Entry < I , Transformer < I , O > > entry : objectsAndTransformers . entrySet () ) {
final Transformer < ? super I , ? extends O > [] transformers , final Transformer < ? super I , ? extends O > defaultTransformer ) { return SwitchTransformer . switchTransformer ( predicates , transformers , defaultTransformer ) ; MST[ReturnValsMutator]MSP[] }
final Transformer < ? super I , ? extends O > falseTransformer ) { return SwitchTransformer . switchTransformer ( new Predicate [] { predicate } , MST[rv.CRCR1Mutator]MSP[] new Transformer [] { trueTransformer } , falseTransformer ) ; }
public static < I , O > Transformer < I , O > constantTransformer ( final O constantToReturn ) { return ConstantTransformer . constantTransformer ( constantToReturn ) ; MST[NullReturnValsMutator]MSP[] }
final Predicate < I > [] preds = new Predicate [ size ] ; MST[rv.ABSMutator]MSP[] int i = 0 ; for ( final Map . Entry < I , Transformer < I , O > > entry : objectsAndTransformers . entrySet () ) {
public static < T > Transformer < T , Boolean > asTransformer ( final Predicate < ? super T > predicate ) { return PredicateTransformer . predicateTransformer ( predicate ) ; MST[NullReturnValsMutator]MSP[] }
final Transformer < ? super I , ? extends O > def = objectsAndTransformers . remove ( null ) ; final int size = objectsAndTransformers . size () ; final Transformer < ? super I , ? extends O > [] trs = new Transformer [ size ] ; MST[rv.UOI2Mutator]MSP[]
preds [ i ] = EqualPredicate . <I > equalPredicate ( entry . getKey () ) ; MST[rv.UOI4Mutator]MSP[] trs [ i ++ ] = entry . getValue () ; } return TransformerUtils . switchTransformer ( preds , trs , def ) ; }
public static < T > Transformer < T , T > nopTransformer () { return NOPTransformer . nopTransformer () ; MST[NullReturnValsMutator]MSP[] } public static < T > Transformer < T , T > cloneTransformer () { return CloneTransformer . cloneTransformer () ; }
final Transformer < ? super I , ? extends O > falseTransformer ) { return SwitchTransformer . switchTransformer ( new Predicate [] { predicate } , MST[NonVoidMethodCallMutator]MSP[] new Transformer [] { trueTransformer } , falseTransformer ) ; }
public static < I , O > Transformer < I , O > exceptionTransformer () { return ExceptionTransformer . exceptionTransformer () ; } public static < I , O > Transformer < I , O > nullTransformer () { return ConstantTransformer . nullTransformer () ; MST[ReturnValsMutator]MSP[] }
public static < T > Transformer < T , T > asTransformer ( final Closure < ? super T > closure ) { return ClosureTransformer . closureTransformer ( closure ) ; MST[ReturnValsMutator]MSP[] }
final Transformer < ? super I , ? extends O > falseTransformer ) { return SwitchTransformer . switchTransformer ( new Predicate [] { predicate } , MST[ArgumentPropagationMutator]MSP[] new Transformer [] { trueTransformer } , falseTransformer ) ; }
public static < I , O > Transformer < I , O > invokerTransformer ( final String methodName ) { return InvokerTransformer . invokerTransformer ( methodName , null , null ) ; MST[ReturnValsMutator]MSP[] }
final Transformer < ? super I , ? extends O > falseTransformer ) { return SwitchTransformer . switchTransformer ( new Predicate [] { predicate } , MST[InlineConstantMutator]MSP[] new Transformer [] { trueTransformer } , falseTransformer ) ; }
public static < I , O > Transformer < I , O > exceptionTransformer () { return ExceptionTransformer . exceptionTransformer () ; MST[NullReturnValsMutator]MSP[] } public static < I , O > Transformer < I , O > nullTransformer () { return ConstantTransformer . nullTransformer () ; }
final Collection < ? extends Transformer < ? super T , ? extends T > > transformers ) { return ChainedTransformer . chainedTransformer ( transformers ) ; MST[ReturnValsMutator]MSP[] } public static < T > Transformer < T , T > ifTransformer ( final Predicate < ? super T > predicate ,
preds [ i ] = EqualPredicate . <I > equalPredicate ( entry . getKey () ) ; trs [ i ++ ] = entry . getValue () ; MST[experimental.RemoveIncrementsMutator]MSP[] } return TransformerUtils . switchTransformer ( preds , trs , def ) ; }
