return getSortedSet () . first () ; MST[NonVoidMethodCallMutator]MSP[S] } @Override public E last () { return getSortedSet () . last () ; } @Override public Comparator < ? super E > comparator () { return getSortedSet () . comparator () ; } @Override
if ( set . size () > 0 ) { @SuppressWarnings ( lr_1 ) final E [] values = ( E [] ) set . toArray () ; set . clear () ; for ( final E value : values ) { MST[rv.UOI1Mutator]MSP[N]
public SortedSet < E > headSet ( final E toElement ) { final SortedSet < E > set = getSortedSet () . headSet ( toElement ) ; return new TransformedSortedSet <> ( set , transformer ) ; MST[ReturnValsMutator]MSP[S] } @Override
if ( set . size () > 0 ) { @SuppressWarnings ( lr_1 ) final E [] values = ( E [] ) set . toArray () ; set . clear () ; for ( final E value : values ) { MST[rv.ABSMutator]MSP[N]
if ( set . size () > 0 ) { @SuppressWarnings ( lr_1 ) final E [] values = ( E [] ) set . toArray () ; set . clear () ; for ( final E value : values ) { MST[rv.UOI1Mutator]MSP[S]
public SortedSet < E > subSet ( final E fromElement , final E toElement ) { final SortedSet < E > set = getSortedSet () . subSet ( fromElement , toElement ) ; return new TransformedSortedSet <> ( set , transformer ) ; MST[ConstructorCallMutator]MSP[S] } @Override
if ( set . size () > 0 ) { @SuppressWarnings ( lr_1 ) final E [] values = ( E [] ) set . toArray () ; set . clear () ; for ( final E value : values ) { MST[rv.UOI4Mutator]MSP[S]
if ( set . size () > 0 ) { @SuppressWarnings ( lr_1 ) final E [] values = ( E [] ) set . toArray () ; set . clear () ; for ( final E value : values ) { MST[rv.UOI3Mutator]MSP[S]
public SortedSet < E > headSet ( final E toElement ) { final SortedSet < E > set = getSortedSet () . headSet ( toElement ) ; MST[experimental.NakedReceiverMutator]MSP[N] return new TransformedSortedSet <> ( set , transformer ) ; } @Override
if ( set . size () > 0 ) { MST[rv.ROR1Mutator]MSP[N] @SuppressWarnings ( lr_1 ) final E [] values = ( E [] ) set . toArray () ; set . clear () ; for ( final E value : values ) {
public static < E > TransformedSortedSet < E > transformingSortedSet ( final SortedSet < E > set , final Transformer < ? super E , ? extends E > transformer ) { return new TransformedSortedSet <> ( set , transformer ) ; MST[ConstructorCallMutator]MSP[N] }
if ( set . size () > 0 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] @SuppressWarnings ( lr_1 ) final E [] values = ( E [] ) set . toArray () ; set . clear () ; for ( final E value : values ) {
if ( set . size () > 0 ) { @SuppressWarnings ( lr_1 ) final E [] values = ( E [] ) set . toArray () ; set . clear () ; for ( final E value : values ) { MST[rv.UOI4Mutator]MSP[S]
if ( set . size () > 0 ) { MST[NonVoidMethodCallMutator]MSP[N] @SuppressWarnings ( lr_1 ) final E [] values = ( E [] ) set . toArray () ; set . clear () ; for ( final E value : values ) {
public SortedSet < E > tailSet ( final E fromElement ) { final SortedSet < E > set = getSortedSet () . tailSet ( fromElement ) ; return new TransformedSortedSet <> ( set , transformer ) ; MST[ReturnValsMutator]MSP[S] }
if ( set . size () > 0 ) { @SuppressWarnings ( lr_1 ) final E [] values = ( E [] ) set . toArray () ; set . clear () ; for ( final E value : values ) { MST[rv.UOI3Mutator]MSP[N]
if ( set . size () > 0 ) { @SuppressWarnings ( lr_1 ) final E [] values = ( E [] ) set . toArray () ; set . clear () ; for ( final E value : values ) { MST[rv.UOI2Mutator]MSP[S]
public SortedSet < E > subSet ( final E fromElement , final E toElement ) { final SortedSet < E > set = getSortedSet () . subSet ( fromElement , toElement ) ; MST[experimental.NakedReceiverMutator]MSP[N] return new TransformedSortedSet <> ( set , transformer ) ; } @Override
return getSortedSet () . first () ; } @Override public E last () { return getSortedSet () . last () ; MST[ReturnValsMutator]MSP[S] } @Override public Comparator < ? super E > comparator () { return getSortedSet () . comparator () ; } @Override
return getSortedSet () . first () ; } @Override public E last () { return getSortedSet () . last () ; } @Override public Comparator < ? super E > comparator () { return getSortedSet () . comparator () ; MST[NonVoidMethodCallMutator]MSP[S] } @Override
decorated . decorated () . add ( transformer . transform ( value ) ) ; } } return decorated ; } protected SortedSet < E > getSortedSet () { return ( SortedSet < E > ) decorated () ; MST[ReturnValsMutator]MSP[S] } @Override public E first () {
public static < E > TransformedSortedSet < E > transformingSortedSet ( final SortedSet < E > set , final Transformer < ? super E , ? extends E > transformer ) { return new TransformedSortedSet <> ( set , transformer ) ; MST[NullReturnValsMutator]MSP[N] }
public SortedSet < E > subSet ( final E fromElement , final E toElement ) { final SortedSet < E > set = getSortedSet () . subSet ( fromElement , toElement ) ; return new TransformedSortedSet <> ( set , transformer ) ; MST[ReturnValsMutator]MSP[S] } @Override
public SortedSet < E > headSet ( final E toElement ) { final SortedSet < E > set = getSortedSet () . headSet ( toElement ) ; MST[NonVoidMethodCallMutator]MSP[S] return new TransformedSortedSet <> ( set , transformer ) ; } @Override
decorated . decorated () . add ( transformer . transform ( value ) ) ; } } return decorated ; } protected SortedSet < E > getSortedSet () { return ( SortedSet < E > ) decorated () ; MST[NonVoidMethodCallMutator]MSP[S] } @Override public E first () {
public static < E > TransformedSortedSet < E > transformedSortedSet ( final SortedSet < E > set , final Transformer < ? super E , ? extends E > transformer ) { final TransformedSortedSet < E > decorated = new TransformedSortedSet <> ( set , transformer ) ; MST[ConstructorCallMutator]MSP[S]
if ( set . size () > 0 ) { MST[rv.ROR3Mutator]MSP[N] @SuppressWarnings ( lr_1 ) final E [] values = ( E [] ) set . toArray () ; set . clear () ; for ( final E value : values ) {
if ( set . size () > 0 ) { MST[rv.ROR5Mutator]MSP[N] @SuppressWarnings ( lr_1 ) final E [] values = ( E [] ) set . toArray () ; set . clear () ; for ( final E value : values ) {
return getSortedSet () . first () ; } @Override public E last () { return getSortedSet () . last () ; } @Override public Comparator < ? super E > comparator () { return getSortedSet () . comparator () ; MST[NullReturnValsMutator]MSP[S] } @Override
return getSortedSet () . first () ; } @Override public E last () { return getSortedSet () . last () ; MST[NonVoidMethodCallMutator]MSP[S] } @Override public Comparator < ? super E > comparator () { return getSortedSet () . comparator () ; } @Override
decorated . decorated () . add ( transformer . transform ( value ) ) ; MST[NonVoidMethodCallMutator]MSP[S] } } return decorated ; } protected SortedSet < E > getSortedSet () { return ( SortedSet < E > ) decorated () ; } @Override public E first () {
return getSortedSet () . first () ; MST[NullReturnValsMutator]MSP[S] } @Override public E last () { return getSortedSet () . last () ; } @Override public Comparator < ? super E > comparator () { return getSortedSet () . comparator () ; } @Override
public SortedSet < E > subSet ( final E fromElement , final E toElement ) { final SortedSet < E > set = getSortedSet () . subSet ( fromElement , toElement ) ; MST[NonVoidMethodCallMutator]MSP[S] return new TransformedSortedSet <> ( set , transformer ) ; } @Override
decorated . decorated () . add ( transformer . transform ( value ) ) ; MST[ArgumentPropagationMutator]MSP[N] } } return decorated ; } protected SortedSet < E > getSortedSet () { return ( SortedSet < E > ) decorated () ; } @Override public E first () {
if ( set . size () > 0 ) { @SuppressWarnings ( lr_1 ) final E [] values = ( E [] ) set . toArray () ; set . clear () ; for ( final E value : values ) { MST[rv.ABSMutator]MSP[S]
return getSortedSet () . first () ; MST[NonVoidMethodCallMutator]MSP[S] } @Override public E last () { return getSortedSet () . last () ; } @Override public Comparator < ? super E > comparator () { return getSortedSet () . comparator () ; } @Override
public SortedSet < E > tailSet ( final E fromElement ) { final SortedSet < E > set = getSortedSet () . tailSet ( fromElement ) ; return new TransformedSortedSet <> ( set , transformer ) ; MST[NullReturnValsMutator]MSP[S] }
if ( set . size () > 0 ) { @SuppressWarnings ( lr_1 ) final E [] values = ( E [] ) set . toArray () ; set . clear () ; for ( final E value : values ) { MST[rv.UOI1Mutator]MSP[S]
if ( set . size () > 0 ) { @SuppressWarnings ( lr_1 ) final E [] values = ( E [] ) set . toArray () ; set . clear () ; for ( final E value : values ) { MST[rv.ABSMutator]MSP[N]
if ( set . size () > 0 ) { @SuppressWarnings ( lr_1 ) final E [] values = ( E [] ) set . toArray () ; set . clear () ; for ( final E value : values ) { MST[rv.UOI2Mutator]MSP[N]
public SortedSet < E > headSet ( final E toElement ) { final SortedSet < E > set = getSortedSet () . headSet ( toElement ) ; return new TransformedSortedSet <> ( set , transformer ) ; MST[NullReturnValsMutator]MSP[S] } @Override
decorated . decorated () . add ( transformer . transform ( value ) ) ; } } return decorated ; MST[ReturnValsMutator]MSP[S] } protected SortedSet < E > getSortedSet () { return ( SortedSet < E > ) decorated () ; } @Override public E first () {
if ( set . size () > 0 ) { @SuppressWarnings ( lr_1 ) final E [] values = ( E [] ) set . toArray () ; set . clear () ; for ( final E value : values ) { MST[rv.UOI4Mutator]MSP[N]
if ( set . size () > 0 ) { @SuppressWarnings ( lr_1 ) final E [] values = ( E [] ) set . toArray () ; MST[NonVoidMethodCallMutator]MSP[S] set . clear () ; for ( final E value : values ) {
if ( set . size () > 0 ) { @SuppressWarnings ( lr_1 ) final E [] values = ( E [] ) set . toArray () ; set . clear () ; for ( final E value : values ) { MST[rv.UOI3Mutator]MSP[S]
if ( set . size () > 0 ) { @SuppressWarnings ( lr_1 ) final E [] values = ( E [] ) set . toArray () ; set . clear () ; MST[VoidMethodCallMutator]MSP[N] for ( final E value : values ) {
public SortedSet < E > tailSet ( final E fromElement ) { final SortedSet < E > set = getSortedSet () . tailSet ( fromElement ) ; return new TransformedSortedSet <> ( set , transformer ) ; MST[ConstructorCallMutator]MSP[S] }
return getSortedSet () . first () ; } @Override public E last () { return getSortedSet () . last () ; MST[NullReturnValsMutator]MSP[S] } @Override public Comparator < ? super E > comparator () { return getSortedSet () . comparator () ; } @Override
public SortedSet < E > headSet ( final E toElement ) { final SortedSet < E > set = getSortedSet () . headSet ( toElement ) ; MST[NonVoidMethodCallMutator]MSP[S] return new TransformedSortedSet <> ( set , transformer ) ; } @Override
return getSortedSet () . first () ; } @Override public E last () { return getSortedSet () . last () ; } @Override public Comparator < ? super E > comparator () { return getSortedSet () . comparator () ; MST[NonVoidMethodCallMutator]MSP[S] } @Override
decorated . decorated () . add ( transformer . transform ( value ) ) ; } } return decorated ; } protected SortedSet < E > getSortedSet () { return ( SortedSet < E > ) decorated () ; MST[NullReturnValsMutator]MSP[S] } @Override public E first () {
if ( set . size () > 0 ) { MST[ConditionalsBoundaryMutator]MSP[N] @SuppressWarnings ( lr_1 ) final E [] values = ( E [] ) set . toArray () ; set . clear () ; for ( final E value : values ) {
return getSortedSet () . first () ; } @Override public E last () { return getSortedSet () . last () ; } @Override public Comparator < ? super E > comparator () { return getSortedSet () . comparator () ; MST[ReturnValsMutator]MSP[N] } @Override
if ( set . size () > 0 ) { MST[NegateConditionalsMutator]MSP[N] @SuppressWarnings ( lr_1 ) final E [] values = ( E [] ) set . toArray () ; set . clear () ; for ( final E value : values ) {
decorated . decorated () . add ( transformer . transform ( value ) ) ; } } return decorated ; MST[NullReturnValsMutator]MSP[S] } protected SortedSet < E > getSortedSet () { return ( SortedSet < E > ) decorated () ; } @Override public E first () {
public SortedSet < E > subSet ( final E fromElement , final E toElement ) { final SortedSet < E > set = getSortedSet () . subSet ( fromElement , toElement ) ; return new TransformedSortedSet <> ( set , transformer ) ; MST[NullReturnValsMutator]MSP[S] } @Override
public SortedSet < E > tailSet ( final E fromElement ) { final SortedSet < E > set = getSortedSet () . tailSet ( fromElement ) ; MST[NonVoidMethodCallMutator]MSP[S] return new TransformedSortedSet <> ( set , transformer ) ; }
if ( set . size () > 0 ) { MST[rv.ROR2Mutator]MSP[N] @SuppressWarnings ( lr_1 ) final E [] values = ( E [] ) set . toArray () ; set . clear () ; for ( final E value : values ) {
if ( set . size () > 0 ) { MST[rv.ROR4Mutator]MSP[N] @SuppressWarnings ( lr_1 ) final E [] values = ( E [] ) set . toArray () ; set . clear () ; for ( final E value : values ) {
return getSortedSet () . first () ; MST[ReturnValsMutator]MSP[S] } @Override public E last () { return getSortedSet () . last () ; } @Override public Comparator < ? super E > comparator () { return getSortedSet () . comparator () ; } @Override
public SortedSet < E > tailSet ( final E fromElement ) { final SortedSet < E > set = getSortedSet () . tailSet ( fromElement ) ; MST[NonVoidMethodCallMutator]MSP[S] return new TransformedSortedSet <> ( set , transformer ) ; }
public SortedSet < E > tailSet ( final E fromElement ) { final SortedSet < E > set = getSortedSet () . tailSet ( fromElement ) ; MST[experimental.NakedReceiverMutator]MSP[N] return new TransformedSortedSet <> ( set , transformer ) ; }
if ( set . size () > 0 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] @SuppressWarnings ( lr_1 ) final E [] values = ( E [] ) set . toArray () ; set . clear () ; for ( final E value : values ) {
decorated . decorated () . add ( transformer . transform ( value ) ) ; MST[NonVoidMethodCallMutator]MSP[S] } } return decorated ; } protected SortedSet < E > getSortedSet () { return ( SortedSet < E > ) decorated () ; } @Override public E first () {
return getSortedSet () . first () ; } @Override public E last () { return getSortedSet () . last () ; MST[NonVoidMethodCallMutator]MSP[S] } @Override public Comparator < ? super E > comparator () { return getSortedSet () . comparator () ; } @Override
public static < E > TransformedSortedSet < E > transformingSortedSet ( final SortedSet < E > set , final Transformer < ? super E , ? extends E > transformer ) { return new TransformedSortedSet <> ( set , transformer ) ; MST[ReturnValsMutator]MSP[N] }
public SortedSet < E > subSet ( final E fromElement , final E toElement ) { final SortedSet < E > set = getSortedSet () . subSet ( fromElement , toElement ) ; MST[NonVoidMethodCallMutator]MSP[S] return new TransformedSortedSet <> ( set , transformer ) ; } @Override
decorated . decorated () . add ( transformer . transform ( value ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } } return decorated ; } protected SortedSet < E > getSortedSet () { return ( SortedSet < E > ) decorated () ; } @Override public E first () {
public SortedSet < E > headSet ( final E toElement ) { final SortedSet < E > set = getSortedSet () . headSet ( toElement ) ; return new TransformedSortedSet <> ( set , transformer ) ; MST[ConstructorCallMutator]MSP[S] } @Override
