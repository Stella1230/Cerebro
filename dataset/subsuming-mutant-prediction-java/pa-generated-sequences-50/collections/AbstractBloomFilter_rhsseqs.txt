} @Override public int orCardinality ( final BloomFilter other ) { return opCardinality ( other , ( a , b ) -> a | b ) ; MST[PrimitiveReturnsMutator]MSP[N] } protected void verifyHasher ( final Hasher hasher ) {
if ( ( buff [ buffIdx ] & buffOffset ) == 0 ) { return false ; } } return true ; } @Override public final Shape getShape () { return shape ; } public final boolean isFull () { return cardinality () == getShape () . getNumberOfBits () ; MST[InlineConstantMutator]MSP[N]
int count = 0 ; for ( int i = 0 ; i < limit ; i ++ ) { count += Long . bitCount ( mine [ i ] & theirs [ i ] ) ; MST[rv.UOI2Mutator]MSP[N] } return count ; } @Override public int cardinality () {
int count = 0 ; for ( final long bits : getBits () ) { MST[rv.ABSMutator]MSP[N] count += Long . bitCount ( bits ) ; } return count ; } @Override public boolean contains ( final BloomFilter other ) { verifyShape ( other ) ;
throw new IllegalArgumentException ( String . format ( lr_2 , shape , this . shape ) ) ; } } @Override public int xorCardinality ( final BloomFilter other ) { return opCardinality ( other , ( a , b ) -> a ^ b ) ; MST[rv.UOI3Mutator]MSP[N] }
for ( int i = 0 ; i < small . length ; i ++ ) { MST[rv.UOI3Mutator]MSP[N] count += Long . bitCount ( operation . applyAsLong ( small [ i ] , big [ i ] ) ) ; }
if ( ( buff [ buffIdx ] & buffOffset ) == 0 ) { MST[rv.ROR3Mutator]MSP[N] return false ; } } return true ; } @Override public final Shape getShape () { return shape ; } public final boolean isFull () { return cardinality () == getShape () . getNumberOfBits () ;
for ( int i = 0 ; i < small . length ; i ++ ) { MST[NegateConditionalsMutator]MSP[N] count += Long . bitCount ( operation . applyAsLong ( small [ i ] , big [ i ] ) ) ; }
int count = 0 ; for ( final long bits : getBits () ) { count += Long . bitCount ( bits ) ; } return count ; MST[rv.UOI3Mutator]MSP[N] } @Override public boolean contains ( final BloomFilter other ) { verifyShape ( other ) ;
if ( ( buff [ buffIdx ] & buffOffset ) == 0 ) { return false ; MST[rv.CRCR3Mutator]MSP[S] } } return true ; } @Override public final Shape getShape () { return shape ; } public final boolean isFull () { return cardinality () == getShape () . getNumberOfBits () ;
if ( ( buff [ buffIdx ] & buffOffset ) == 0 ) { return false ; } } return true ; } @Override public final Shape getShape () { return shape ; } public final boolean isFull () { return cardinality () == getShape () . getNumberOfBits () ; MST[rv.ROR3Mutator]MSP[N]
int count = 0 ; for ( int i = 0 ; i < limit ; i ++ ) { count += Long . bitCount ( mine [ i ] & theirs [ i ] ) ; MST[rv.UOI3Mutator]MSP[S] } return count ; } @Override public int cardinality () {
int count = 0 ; MST[InlineConstantMutator]MSP[N] for ( int i = 0 ; i < limit ; i ++ ) { count += Long . bitCount ( mine [ i ] & theirs [ i ] ) ; } return count ; } @Override public int cardinality () {
int count = 0 ; for ( int i = 0 ; i < limit ; i ++ ) { count += Long . bitCount ( mine [ i ] & theirs [ i ] ) ; } return count ; MST[rv.UOI2Mutator]MSP[N] } @Override public int cardinality () {
return other . cardinality () == andCardinality ( other ) ; MST[rv.ROR1Mutator]MSP[S] } @Override public boolean contains ( final Hasher hasher ) { verifyHasher ( hasher ) ; final long [] buff = getBits () ; final OfInt iter = hasher . getBits ( shape ) ;
throw new IllegalArgumentException ( String . format ( lr_2 , shape , this . shape ) ) ; MST[rv.CRCR4Mutator]MSP[S] } } @Override public int xorCardinality ( final BloomFilter other ) { return opCardinality ( other , ( a , b ) -> a ^ b ) ; }
for ( int i = small . length ; i < big . length ; i ++ ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] count += Long . bitCount ( big [ i ] ) ; } return count ; }
int count = 0 ; for ( final long bits : getBits () ) { count += Long . bitCount ( bits ) ; MST[rv.UOI4Mutator]MSP[N] } return count ; } @Override public boolean contains ( final BloomFilter other ) { verifyShape ( other ) ;
int count = 0 ; for ( final long bits : getBits () ) { MST[rv.UOI3Mutator]MSP[N] count += Long . bitCount ( bits ) ; } return count ; } @Override public boolean contains ( final BloomFilter other ) { verifyShape ( other ) ;
if ( ( buff [ buffIdx ] & buffOffset ) == 0 ) { MST[rv.OBBN3Mutator]MSP[S] return false ; } } return true ; } @Override public final Shape getShape () { return shape ; } public final boolean isFull () { return cardinality () == getShape () . getNumberOfBits () ;
return other . cardinality () == andCardinality ( other ) ; MST[rv.ROR5Mutator]MSP[S] } @Override public boolean contains ( final Hasher hasher ) { verifyHasher ( hasher ) ; final long [] buff = getBits () ; final OfInt iter = hasher . getBits ( shape ) ;
throw new IllegalArgumentException ( String . format ( lr_2 , shape , this . shape ) ) ; } } @Override public int xorCardinality ( final BloomFilter other ) { return opCardinality ( other , ( a , b ) -> a ^ b ) ; MST[MathMutator]MSP[N] }
int count = 0 ; for ( final long bits : getBits () ) { MST[rv.UOI2Mutator]MSP[S] count += Long . bitCount ( bits ) ; } return count ; } @Override public boolean contains ( final BloomFilter other ) { verifyShape ( other ) ;
if ( ( buff [ buffIdx ] & buffOffset ) == 0 ) { return false ; MST[BooleanTrueReturnValsMutator]MSP[S] } } return true ; } @Override public final Shape getShape () { return shape ; } public final boolean isFull () { return cardinality () == getShape () . getNumberOfBits () ;
if ( ( buff [ buffIdx ] & buffOffset ) == 0 ) { return false ; } } return true ; } @Override public final Shape getShape () { return shape ; } public final boolean isFull () { return cardinality () == getShape () . getNumberOfBits () ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
if ( shape . getHashFunctionIdentity () . getSignature () != hasher . getHashFunctionIdentity () . getSignature () ) { throw new IllegalArgumentException ( MST[rv.CRCR4Mutator]MSP[S] String . format ( lr_1 , HashFunctionIdentity . asCommonString ( hasher . getHashFunctionIdentity () ) , shape . toString () ) ) ; } }
while ( iter . hasNext () ) { final int idx = iter . nextInt () ; BloomFilterIndexer . checkPositive ( idx ) ; MST[rv.UOI1Mutator]MSP[N] final int buffIdx = BloomFilterIndexer . getLongIndex ( idx ) ; final long buffOffset = BloomFilterIndexer . getLongBit ( idx ) ;
while ( iter . hasNext () ) { final int idx = iter . nextInt () ; BloomFilterIndexer . checkPositive ( idx ) ; final int buffIdx = BloomFilterIndexer . getLongIndex ( idx ) ; MST[rv.ABSMutator]MSP[S] final long buffOffset = BloomFilterIndexer . getLongBit ( idx ) ;
throw new IllegalArgumentException ( String . format ( lr_2 , shape , this . shape ) ) ; } } @Override public int xorCardinality ( final BloomFilter other ) { return opCardinality ( other , ( a , b ) -> a ^ b ) ; MST[PrimitiveReturnsMutator]MSP[N] }
if ( ( buff [ buffIdx ] & buffOffset ) == 0 ) { MST[rv.UOI1Mutator]MSP[S] return false ; } } return true ; } @Override public final Shape getShape () { return shape ; } public final boolean isFull () { return cardinality () == getShape () . getNumberOfBits () ;
if ( ( buff [ buffIdx ] & buffOffset ) == 0 ) { return false ; } } return true ; MST[rv.CRCR5Mutator]MSP[S] } @Override public final Shape getShape () { return shape ; } public final boolean isFull () { return cardinality () == getShape () . getNumberOfBits () ;
if ( shape . getHashFunctionIdentity () . getSignature () != hasher . getHashFunctionIdentity () . getSignature () ) { throw new IllegalArgumentException ( String . format ( lr_1 , HashFunctionIdentity . asCommonString ( hasher . getHashFunctionIdentity () ) , MST[InlineConstantMutator]MSP[N] shape . toString () ) ) ; } }
throw new IllegalArgumentException ( String . format ( lr_2 , shape , this . shape ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } } @Override public int xorCardinality ( final BloomFilter other ) { return opCardinality ( other , ( a , b ) -> a ^ b ) ; }
for ( int i = 0 ; i < small . length ; i ++ ) { MST[rv.CRCR6Mutator]MSP[N] count += Long . bitCount ( operation . applyAsLong ( small [ i ] , big [ i ] ) ) ; }
for ( int i = small . length ; i < big . length ; i ++ ) { count += Long . bitCount ( big [ i ] ) ; MST[rv.UOI4Mutator]MSP[N] } return count ; }
} @Override public int orCardinality ( final BloomFilter other ) { return opCardinality ( other , ( a , b ) -> a | b ) ; MST[PrimitiveReturnsMutator]MSP[N] } protected void verifyHasher ( final Hasher hasher ) {
if ( ( buff [ buffIdx ] & buffOffset ) == 0 ) { MST[rv.CRCR6Mutator]MSP[S] return false ; } } return true ; } @Override public final Shape getShape () { return shape ; } public final boolean isFull () { return cardinality () == getShape () . getNumberOfBits () ;
int count = 0 ; for ( int i = 0 ; i < limit ; i ++ ) { count += Long . bitCount ( mine [ i ] & theirs [ i ] ) ; MST[rv.UOI2Mutator]MSP[N] } return count ; } @Override public int cardinality () {
for ( int i = 0 ; i < small . length ; i ++ ) { MST[InlineConstantMutator]MSP[N] count += Long . bitCount ( operation . applyAsLong ( small [ i ] , big [ i ] ) ) ; }
throw new IllegalArgumentException ( String . format ( lr_2 , shape , this . shape ) ) ; } } @Override public int xorCardinality ( final BloomFilter other ) { return opCardinality ( other , ( a , b ) -> a ^ b ) ; MST[rv.UOI3Mutator]MSP[N] }
for ( int i = 0 ; i < small . length ; i ++ ) { count += Long . bitCount ( operation . applyAsLong ( small [ i ] , big [ i ] ) ) ; MST[rv.UOI1Mutator]MSP[N] }
if ( mine . length > theirs . length ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] big = mine ; small = theirs ; } else { small = mine ; big = theirs ; } int count = 0 ;
for ( int i = 0 ; i < small . length ; i ++ ) { MST[rv.ROR5Mutator]MSP[N] count += Long . bitCount ( operation . applyAsLong ( small [ i ] , big [ i ] ) ) ; }
int count = 0 ; for ( int i = 0 ; i < limit ; i ++ ) { count += Long . bitCount ( mine [ i ] & theirs [ i ] ) ; } return count ; MST[PrimitiveReturnsMutator]MSP[N] } @Override public int cardinality () {
for ( int i = 0 ; i < small . length ; i ++ ) { count += Long . bitCount ( operation . applyAsLong ( small [ i ] , big [ i ] ) ) ; MST[rv.UOI2Mutator]MSP[N] }
throw new IllegalArgumentException ( String . format ( lr_2 , shape , this . shape ) ) ; MST[rv.CRCR6Mutator]MSP[N] } } @Override public int xorCardinality ( final BloomFilter other ) { return opCardinality ( other , ( a , b ) -> a ^ b ) ; }
for ( int i = 0 ; i < small . length ; i ++ ) { count += Long . bitCount ( operation . applyAsLong ( small [ i ] , big [ i ] ) ) ; MST[rv.ABSMutator]MSP[N] }
for ( int i = 0 ; i < small . length ; i ++ ) { MST[rv.ROR1Mutator]MSP[N] count += Long . bitCount ( operation . applyAsLong ( small [ i ] , big [ i ] ) ) ; }
int count = 0 ; for ( int i = 0 ; i < limit ; i ++ ) { count += Long . bitCount ( mine [ i ] & theirs [ i ] ) ; MST[MathMutator]MSP[S] } return count ; } @Override public int cardinality () {
return other . cardinality () == andCardinality ( other ) ; MST[NegateConditionalsMutator]MSP[S] } @Override public boolean contains ( final Hasher hasher ) { verifyHasher ( hasher ) ; final long [] buff = getBits () ; final OfInt iter = hasher . getBits ( shape ) ;
while ( iter . hasNext () ) { final int idx = iter . nextInt () ; BloomFilterIndexer . checkPositive ( idx ) ; final int buffIdx = BloomFilterIndexer . getLongIndex ( idx ) ; final long buffOffset = BloomFilterIndexer . getLongBit ( idx ) ; MST[rv.UOI3Mutator]MSP[N]
while ( iter . hasNext () ) { MST[NonVoidMethodCallMutator]MSP[S] final int idx = iter . nextInt () ; BloomFilterIndexer . checkPositive ( idx ) ; final int buffIdx = BloomFilterIndexer . getLongIndex ( idx ) ; final long buffOffset = BloomFilterIndexer . getLongBit ( idx ) ;
if ( ( buff [ buffIdx ] & buffOffset ) == 0 ) { return false ; } } return true ; } @Override public final Shape getShape () { return shape ; } public final boolean isFull () { return cardinality () == getShape () . getNumberOfBits () ; MST[rv.CRCR3Mutator]MSP[N]
throw new IllegalArgumentException ( String . format ( lr_2 , shape , this . shape ) ) ; MST[rv.CRCR2Mutator]MSP[N] } } @Override public int xorCardinality ( final BloomFilter other ) { return opCardinality ( other , ( a , b ) -> a ^ b ) ; }
if ( ( buff [ buffIdx ] & buffOffset ) == 0 ) { return false ; } } return true ; MST[ReturnValsMutator]MSP[S] } @Override public final Shape getShape () { return shape ; } public final boolean isFull () { return cardinality () == getShape () . getNumberOfBits () ;
for ( int i = small . length ; i < big . length ; i ++ ) { MST[ConditionalsBoundaryMutator]MSP[N] count += Long . bitCount ( big [ i ] ) ; } return count ; }
for ( int i = small . length ; i < big . length ; i ++ ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] count += Long . bitCount ( big [ i ] ) ; } return count ; }
} @Override public int orCardinality ( final BloomFilter other ) { return opCardinality ( other , ( a , b ) -> a | b ) ; MST[rv.ABSMutator]MSP[N] } protected void verifyHasher ( final Hasher hasher ) {
int count = 0 ; for ( int i = 0 ; i < limit ; i ++ ) { MST[IncrementsMutator]MSP[N] count += Long . bitCount ( mine [ i ] & theirs [ i ] ) ; } return count ; } @Override public int cardinality () {
protected void verifyShape ( final BloomFilter other ) { verifyShape ( other . getShape () ) ; MST[VoidMethodCallMutator]MSP[S] } protected void verifyShape ( final Shape shape ) { if ( ! this . shape . equals ( shape ) ) {
int count = 0 ; MST[InlineConstantMutator]MSP[N] for ( final long bits : getBits () ) { count += Long . bitCount ( bits ) ; } return count ; } @Override public boolean contains ( final BloomFilter other ) { verifyShape ( other ) ;
for ( int i = small . length ; i < big . length ; i ++ ) { MST[rv.ROR4Mutator]MSP[N] count += Long . bitCount ( big [ i ] ) ; } return count ; }
int count = 0 ; for ( int i = 0 ; i < limit ; i ++ ) { MST[rv.ROR2Mutator]MSP[N] count += Long . bitCount ( mine [ i ] & theirs [ i ] ) ; } return count ; } @Override public int cardinality () {
int count = 0 ; for ( int i = 0 ; i < limit ; i ++ ) { count += Long . bitCount ( mine [ i ] & theirs [ i ] ) ; MST[rv.ABSMutator]MSP[N] } return count ; } @Override public int cardinality () {
if ( ( buff [ buffIdx ] & buffOffset ) == 0 ) { MST[rv.UOI1Mutator]MSP[N] return false ; } } return true ; } @Override public final Shape getShape () { return shape ; } public final boolean isFull () { return cardinality () == getShape () . getNumberOfBits () ;
if ( shape . getHashFunctionIdentity () . getSignature () != hasher . getHashFunctionIdentity () . getSignature () ) { throw new IllegalArgumentException ( String . format ( lr_1 , MST[ArgumentPropagationMutator]MSP[N] HashFunctionIdentity . asCommonString ( hasher . getHashFunctionIdentity () ) , shape . toString () ) ) ; } }
int count = 0 ; MST[rv.CRCR3Mutator]MSP[N] for ( final long bits : getBits () ) { count += Long . bitCount ( bits ) ; } return count ; } @Override public boolean contains ( final BloomFilter other ) { verifyShape ( other ) ;
int count = 0 ; for ( int i = 0 ; i < limit ; i ++ ) { MST[rv.UOI1Mutator]MSP[N] count += Long . bitCount ( mine [ i ] & theirs [ i ] ) ; } return count ; } @Override public int cardinality () {
for ( int i = 0 ; i < small . length ; i ++ ) { count += Long . bitCount ( operation . applyAsLong ( small [ i ] , big [ i ] ) ) ; MST[rv.AOR3Mutator]MSP[N] }
return other . cardinality () == andCardinality ( other ) ; MST[rv.CRCR5Mutator]MSP[S] } @Override public boolean contains ( final Hasher hasher ) { verifyHasher ( hasher ) ; final long [] buff = getBits () ; final OfInt iter = hasher . getBits ( shape ) ;
return other . cardinality () == andCardinality ( other ) ; MST[rv.CRCR1Mutator]MSP[S] } @Override public boolean contains ( final Hasher hasher ) { verifyHasher ( hasher ) ; final long [] buff = getBits () ; final OfInt iter = hasher . getBits ( shape ) ;
return other . cardinality () == andCardinality ( other ) ; MST[rv.CRCR6Mutator]MSP[S] } @Override public boolean contains ( final Hasher hasher ) { verifyHasher ( hasher ) ; final long [] buff = getBits () ; final OfInt iter = hasher . getBits ( shape ) ;
for ( int i = 0 ; i < small . length ; i ++ ) { count += Long . bitCount ( operation . applyAsLong ( small [ i ] , big [ i ] ) ) ; MST[rv.UOI2Mutator]MSP[N] }
int count = 0 ; MST[rv.CRCR3Mutator]MSP[N] for ( int i = 0 ; i < limit ; i ++ ) { count += Long . bitCount ( mine [ i ] & theirs [ i ] ) ; } return count ; } @Override public int cardinality () {
for ( int i = 0 ; i < small . length ; i ++ ) { count += Long . bitCount ( operation . applyAsLong ( small [ i ] , big [ i ] ) ) ; MST[rv.ABSMutator]MSP[S] }
for ( int i = 0 ; i < small . length ; i ++ ) { count += Long . bitCount ( operation . applyAsLong ( small [ i ] , big [ i ] ) ) ; MST[rv.UOI1Mutator]MSP[N] }
int count = 0 ; for ( int i = 0 ; i < limit ; i ++ ) { count += Long . bitCount ( mine [ i ] & theirs [ i ] ) ; MST[rv.AOD2Mutator]MSP[N] } return count ; } @Override public int cardinality () {
if ( ( buff [ buffIdx ] & buffOffset ) == 0 ) { return false ; } } return true ; } @Override public final Shape getShape () { return shape ; } public final boolean isFull () { return cardinality () == getShape () . getNumberOfBits () ; MST[rv.CRCR2Mutator]MSP[N]
if ( shape . getHashFunctionIdentity () . getSignature () != hasher . getHashFunctionIdentity () . getSignature () ) { throw new IllegalArgumentException ( MST[rv.CRCR5Mutator]MSP[N] String . format ( lr_1 , HashFunctionIdentity . asCommonString ( hasher . getHashFunctionIdentity () ) , shape . toString () ) ) ; } }
throw new IllegalArgumentException ( String . format ( lr_2 , shape , this . shape ) ) ; MST[rv.CRCR1Mutator]MSP[N] } } @Override public int xorCardinality ( final BloomFilter other ) { return opCardinality ( other , ( a , b ) -> a ^ b ) ; }
if ( shape . getHashFunctionIdentity () . getSignature () != hasher . getHashFunctionIdentity () . getSignature () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] throw new IllegalArgumentException ( String . format ( lr_1 , HashFunctionIdentity . asCommonString ( hasher . getHashFunctionIdentity () ) , shape . toString () ) ) ; } }
if ( mine . length > theirs . length ) { MST[NegateConditionalsMutator]MSP[N] big = mine ; small = theirs ; } else { small = mine ; big = theirs ; } int count = 0 ;
if ( shape . getHashFunctionIdentity () . getSignature () != hasher . getHashFunctionIdentity () . getSignature () ) { throw new IllegalArgumentException ( String . format ( lr_1 , HashFunctionIdentity . asCommonString ( hasher . getHashFunctionIdentity () ) , MST[rv.CRCR3Mutator]MSP[S] shape . toString () ) ) ; } }
for ( int i = 0 ; i < small . length ; i ++ ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] count += Long . bitCount ( operation . applyAsLong ( small [ i ] , big [ i ] ) ) ; }
if ( mine . length > theirs . length ) { MST[rv.ROR4Mutator]MSP[N] big = mine ; small = theirs ; } else { small = mine ; big = theirs ; } int count = 0 ;
for ( int i = small . length ; i < big . length ; i ++ ) { count += Long . bitCount ( big [ i ] ) ; } return count ; MST[rv.UOI4Mutator]MSP[N] }
int count = 0 ; for ( int i = 0 ; i < limit ; i ++ ) { count += Long . bitCount ( mine [ i ] & theirs [ i ] ) ; MST[rv.ABSMutator]MSP[N] } return count ; } @Override public int cardinality () {
int count = 0 ; for ( int i = 0 ; i < limit ; i ++ ) { MST[rv.ROR1Mutator]MSP[N] count += Long . bitCount ( mine [ i ] & theirs [ i ] ) ; } return count ; } @Override public int cardinality () {
int count = 0 ; for ( int i = 0 ; i < limit ; i ++ ) { MST[rv.UOI4Mutator]MSP[N] count += Long . bitCount ( mine [ i ] & theirs [ i ] ) ; } return count ; } @Override public int cardinality () {
for ( int i = small . length ; i < big . length ; i ++ ) { count += Long . bitCount ( big [ i ] ) ; MST[rv.AOR1Mutator]MSP[N] } return count ; }
for ( int i = small . length ; i < big . length ; i ++ ) { count += Long . bitCount ( big [ i ] ) ; MST[rv.UOI1Mutator]MSP[N] } return count ; }
int count = 0 ; for ( final long bits : getBits () ) { count += Long . bitCount ( bits ) ; MST[rv.UOI1Mutator]MSP[N] } return count ; } @Override public boolean contains ( final BloomFilter other ) { verifyShape ( other ) ;
int count = 0 ; for ( final long bits : getBits () ) { MST[rv.ABSMutator]MSP[N] count += Long . bitCount ( bits ) ; } return count ; } @Override public boolean contains ( final BloomFilter other ) { verifyShape ( other ) ;
int count = 0 ; for ( int i = 0 ; i < limit ; i ++ ) { MST[rv.UOI1Mutator]MSP[N] count += Long . bitCount ( mine [ i ] & theirs [ i ] ) ; } return count ; } @Override public int cardinality () {
throw new IllegalArgumentException ( String . format ( lr_2 , shape , this . shape ) ) ; } } @Override public int xorCardinality ( final BloomFilter other ) { return opCardinality ( other , ( a , b ) -> a ^ b ) ; MST[rv.UOI4Mutator]MSP[N] }
int count = 0 ; for ( final long bits : getBits () ) { count += Long . bitCount ( bits ) ; MST[rv.UOI4Mutator]MSP[N] } return count ; } @Override public boolean contains ( final BloomFilter other ) { verifyShape ( other ) ;
protected void verifyShape ( final BloomFilter other ) { verifyShape ( other . getShape () ) ; } protected void verifyShape ( final Shape shape ) { if ( ! this . shape . equals ( shape ) ) { MST[NonVoidMethodCallMutator]MSP[N]
for ( int i = 0 ; i < small . length ; i ++ ) { MST[rv.ROR4Mutator]MSP[N] count += Long . bitCount ( operation . applyAsLong ( small [ i ] , big [ i ] ) ) ; }
for ( int i = 0 ; i < small . length ; i ++ ) { count += Long . bitCount ( operation . applyAsLong ( small [ i ] , big [ i ] ) ) ; MST[rv.UOI3Mutator]MSP[N] }
return other . cardinality () == andCardinality ( other ) ; MST[NonVoidMethodCallMutator]MSP[S] } @Override public boolean contains ( final Hasher hasher ) { verifyHasher ( hasher ) ; final long [] buff = getBits () ; final OfInt iter = hasher . getBits ( shape ) ;
if ( shape . getHashFunctionIdentity () . getSignature () != hasher . getHashFunctionIdentity () . getSignature () ) { MST[rv.ROR3Mutator]MSP[N] throw new IllegalArgumentException ( String . format ( lr_1 , HashFunctionIdentity . asCommonString ( hasher . getHashFunctionIdentity () ) , shape . toString () ) ) ; } }
int count = 0 ; for ( final long bits : getBits () ) { count += Long . bitCount ( bits ) ; MST[rv.AOR1Mutator]MSP[N] } return count ; } @Override public boolean contains ( final BloomFilter other ) { verifyShape ( other ) ;
if ( ( buff [ buffIdx ] & buffOffset ) == 0 ) { MST[InlineConstantMutator]MSP[S] return false ; } } return true ; } @Override public final Shape getShape () { return shape ; } public final boolean isFull () { return cardinality () == getShape () . getNumberOfBits () ;
int count = 0 ; for ( int i = 0 ; i < limit ; i ++ ) { count += Long . bitCount ( mine [ i ] & theirs [ i ] ) ; MST[rv.OBBN1Mutator]MSP[S] } return count ; } @Override public int cardinality () {
throw new IllegalArgumentException ( String . format ( lr_2 , shape , this . shape ) ) ; MST[rv.CRCR5Mutator]MSP[S] } } @Override public int xorCardinality ( final BloomFilter other ) { return opCardinality ( other , ( a , b ) -> a ^ b ) ; }
throw new IllegalArgumentException ( String . format ( lr_2 , shape , this . shape ) ) ; MST[ConstructorCallMutator]MSP[S] } } @Override public int xorCardinality ( final BloomFilter other ) { return opCardinality ( other , ( a , b ) -> a ^ b ) ; }
for ( int i = small . length ; i < big . length ; i ++ ) { MST[rv.UOI3Mutator]MSP[N] count += Long . bitCount ( big [ i ] ) ; } return count ; }
int count = 0 ; for ( int i = 0 ; i < limit ; i ++ ) { count += Long . bitCount ( mine [ i ] & theirs [ i ] ) ; } return count ; MST[rv.ABSMutator]MSP[N] } @Override public int cardinality () {
while ( iter . hasNext () ) { final int idx = iter . nextInt () ; BloomFilterIndexer . checkPositive ( idx ) ; final int buffIdx = BloomFilterIndexer . getLongIndex ( idx ) ; MST[rv.UOI2Mutator]MSP[N] final long buffOffset = BloomFilterIndexer . getLongBit ( idx ) ;
throw new IllegalArgumentException ( String . format ( lr_2 , shape , this . shape ) ) ; MST[rv.CRCR3Mutator]MSP[S] } } @Override public int xorCardinality ( final BloomFilter other ) { return opCardinality ( other , ( a , b ) -> a ^ b ) ; }
return other . cardinality () == andCardinality ( other ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] } @Override public boolean contains ( final Hasher hasher ) { verifyHasher ( hasher ) ; final long [] buff = getBits () ; final OfInt iter = hasher . getBits ( shape ) ;
while ( iter . hasNext () ) { final int idx = iter . nextInt () ; BloomFilterIndexer . checkPositive ( idx ) ; final int buffIdx = BloomFilterIndexer . getLongIndex ( idx ) ; MST[NonVoidMethodCallMutator]MSP[N] final long buffOffset = BloomFilterIndexer . getLongBit ( idx ) ;
if ( ( buff [ buffIdx ] & buffOffset ) == 0 ) { MST[rv.UOI1Mutator]MSP[N] return false ; } } return true ; } @Override public final Shape getShape () { return shape ; } public final boolean isFull () { return cardinality () == getShape () . getNumberOfBits () ;
if ( mine . length > theirs . length ) { MST[rv.ROR1Mutator]MSP[N] big = mine ; small = theirs ; } else { small = mine ; big = theirs ; } int count = 0 ;
int count = 0 ; for ( int i = 0 ; i < limit ; i ++ ) { count += Long . bitCount ( mine [ i ] & theirs [ i ] ) ; MST[rv.ABSMutator]MSP[S] } return count ; } @Override public int cardinality () {
if ( mine . length > theirs . length ) { big = mine ; small = theirs ; } else { small = mine ; big = theirs ; } int count = 0 ; MST[rv.CRCR5Mutator]MSP[N]
if ( ( buff [ buffIdx ] & buffOffset ) == 0 ) { return false ; } } return true ; MST[rv.CRCR2Mutator]MSP[S] } @Override public final Shape getShape () { return shape ; } public final boolean isFull () { return cardinality () == getShape () . getNumberOfBits () ;
int count = 0 ; for ( int i = 0 ; i < limit ; i ++ ) { MST[rv.UOI4Mutator]MSP[N] count += Long . bitCount ( mine [ i ] & theirs [ i ] ) ; } return count ; } @Override public int cardinality () {
if ( ( buff [ buffIdx ] & buffOffset ) == 0 ) { MST[rv.ABSMutator]MSP[N] return false ; } } return true ; } @Override public final Shape getShape () { return shape ; } public final boolean isFull () { return cardinality () == getShape () . getNumberOfBits () ;
int count = 0 ; for ( final long bits : getBits () ) { count += Long . bitCount ( bits ) ; MST[rv.UOI1Mutator]MSP[N] } return count ; } @Override public boolean contains ( final BloomFilter other ) { verifyShape ( other ) ;
for ( int i = 0 ; i < small . length ; i ++ ) { MST[rv.UOI4Mutator]MSP[N] count += Long . bitCount ( operation . applyAsLong ( small [ i ] , big [ i ] ) ) ; }
} @Override public int orCardinality ( final BloomFilter other ) { return opCardinality ( other , ( a , b ) -> a | b ) ; MST[ReturnValsMutator]MSP[N] } protected void verifyHasher ( final Hasher hasher ) {
return other . cardinality () == andCardinality ( other ) ; MST[BooleanTrueReturnValsMutator]MSP[S] } @Override public boolean contains ( final Hasher hasher ) { verifyHasher ( hasher ) ; final long [] buff = getBits () ; final OfInt iter = hasher . getBits ( shape ) ;
int count = 0 ; for ( final long bits : getBits () ) { count += Long . bitCount ( bits ) ; MST[rv.UOI3Mutator]MSP[N] } return count ; } @Override public boolean contains ( final BloomFilter other ) { verifyShape ( other ) ;
for ( int i = 0 ; i < small . length ; i ++ ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] count += Long . bitCount ( operation . applyAsLong ( small [ i ] , big [ i ] ) ) ; }
int count = 0 ; for ( final long bits : getBits () ) { count += Long . bitCount ( bits ) ; } return count ; MST[rv.UOI2Mutator]MSP[N] } @Override public boolean contains ( final BloomFilter other ) { verifyShape ( other ) ;
throw new IllegalArgumentException ( String . format ( lr_2 , shape , this . shape ) ) ; } } @Override public int xorCardinality ( final BloomFilter other ) { return opCardinality ( other , ( a , b ) -> a ^ b ) ; MST[rv.UOI2Mutator]MSP[N] }
if ( ( buff [ buffIdx ] & buffOffset ) == 0 ) { return false ; MST[rv.CRCR6Mutator]MSP[S] } } return true ; } @Override public final Shape getShape () { return shape ; } public final boolean isFull () { return cardinality () == getShape () . getNumberOfBits () ;
int count = 0 ; for ( int i = 0 ; i < limit ; i ++ ) { count += Long . bitCount ( mine [ i ] & theirs [ i ] ) ; } return count ; MST[ReturnValsMutator]MSP[N] } @Override public int cardinality () {
int count = 0 ; for ( int i = 0 ; i < limit ; i ++ ) { count += Long . bitCount ( mine [ i ] & theirs [ i ] ) ; MST[rv.UOI2Mutator]MSP[N] } return count ; } @Override public int cardinality () {
for ( int i = 0 ; i < small . length ; i ++ ) { count += Long . bitCount ( operation . applyAsLong ( small [ i ] , big [ i ] ) ) ; MST[rv.UOI3Mutator]MSP[N] }
throw new IllegalArgumentException ( String . format ( lr_2 , shape , this . shape ) ) ; MST[rv.CRCR5Mutator]MSP[N] } } @Override public int xorCardinality ( final BloomFilter other ) { return opCardinality ( other , ( a , b ) -> a ^ b ) ; }
return other . cardinality () == andCardinality ( other ) ; MST[ReturnValsMutator]MSP[S] } @Override public boolean contains ( final Hasher hasher ) { verifyHasher ( hasher ) ; final long [] buff = getBits () ; final OfInt iter = hasher . getBits ( shape ) ;
int count = 0 ; for ( final long bits : getBits () ) { MST[rv.UOI2Mutator]MSP[N] count += Long . bitCount ( bits ) ; } return count ; } @Override public boolean contains ( final BloomFilter other ) { verifyShape ( other ) ;
while ( iter . hasNext () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] final int idx = iter . nextInt () ; BloomFilterIndexer . checkPositive ( idx ) ; final int buffIdx = BloomFilterIndexer . getLongIndex ( idx ) ; final long buffOffset = BloomFilterIndexer . getLongBit ( idx ) ;
return other . cardinality () == andCardinality ( other ) ; MST[rv.ROR4Mutator]MSP[S] } @Override public boolean contains ( final Hasher hasher ) { verifyHasher ( hasher ) ; final long [] buff = getBits () ; final OfInt iter = hasher . getBits ( shape ) ;
int count = 0 ; for ( int i = 0 ; i < limit ; i ++ ) { MST[InlineConstantMutator]MSP[N] count += Long . bitCount ( mine [ i ] & theirs [ i ] ) ; } return count ; } @Override public int cardinality () {
while ( iter . hasNext () ) { final int idx = iter . nextInt () ; BloomFilterIndexer . checkPositive ( idx ) ; final int buffIdx = BloomFilterIndexer . getLongIndex ( idx ) ; final long buffOffset = BloomFilterIndexer . getLongBit ( idx ) ; MST[rv.UOI4Mutator]MSP[N]
while ( iter . hasNext () ) { MST[rv.ROR1Mutator]MSP[S] final int idx = iter . nextInt () ; BloomFilterIndexer . checkPositive ( idx ) ; final int buffIdx = BloomFilterIndexer . getLongIndex ( idx ) ; final long buffOffset = BloomFilterIndexer . getLongBit ( idx ) ;
while ( iter . hasNext () ) { final int idx = iter . nextInt () ; BloomFilterIndexer . checkPositive ( idx ) ; final int buffIdx = BloomFilterIndexer . getLongIndex ( idx ) ; MST[rv.UOI3Mutator]MSP[N] final long buffOffset = BloomFilterIndexer . getLongBit ( idx ) ;
if ( shape . getHashFunctionIdentity () . getSignature () != hasher . getHashFunctionIdentity () . getSignature () ) { throw new IllegalArgumentException ( String . format ( lr_1 , HashFunctionIdentity . asCommonString ( hasher . getHashFunctionIdentity () ) , MST[NonVoidMethodCallMutator]MSP[S] shape . toString () ) ) ; } }
for ( int i = small . length ; i < big . length ; i ++ ) { MST[rv.ROR3Mutator]MSP[N] count += Long . bitCount ( big [ i ] ) ; } return count ; }
if ( ( buff [ buffIdx ] & buffOffset ) == 0 ) { MST[rv.UOI2Mutator]MSP[N] return false ; } } return true ; } @Override public final Shape getShape () { return shape ; } public final boolean isFull () { return cardinality () == getShape () . getNumberOfBits () ;
for ( int i = small . length ; i < big . length ; i ++ ) { MST[rv.ROR1Mutator]MSP[N] count += Long . bitCount ( big [ i ] ) ; } return count ; }
if ( ( buff [ buffIdx ] & buffOffset ) == 0 ) { return false ; } } return true ; } @Override public final Shape getShape () { return shape ; } public final boolean isFull () { return cardinality () == getShape () . getNumberOfBits () ; MST[NonVoidMethodCallMutator]MSP[N]
@Override public int andCardinality ( final BloomFilter other ) { verifyShape ( other ) ; final long [] mine = getBits () ; final long [] theirs = other . getBits () ; MST[NonVoidMethodCallMutator]MSP[N] final int limit = Integer . min ( mine . length , theirs . length ) ;
protected void verifyShape ( final BloomFilter other ) { verifyShape ( other . getShape () ) ; } protected void verifyShape ( final Shape shape ) { if ( ! this . shape . equals ( shape ) ) { MST[rv.ROR4Mutator]MSP[S]
} @Override public int orCardinality ( final BloomFilter other ) { return opCardinality ( other , ( a , b ) -> a | b ) ; MST[ReturnValsMutator]MSP[N] } protected void verifyHasher ( final Hasher hasher ) {
int count = 0 ; for ( final long bits : getBits () ) { count += Long . bitCount ( bits ) ; MST[rv.UOI3Mutator]MSP[N] } return count ; } @Override public boolean contains ( final BloomFilter other ) { verifyShape ( other ) ;
throw new IllegalArgumentException ( String . format ( lr_2 , shape , this . shape ) ) ; } } @Override public int xorCardinality ( final BloomFilter other ) { return opCardinality ( other , ( a , b ) -> a ^ b ) ; MST[rv.UOI2Mutator]MSP[N] }
if ( ( buff [ buffIdx ] & buffOffset ) == 0 ) { return false ; } } return true ; MST[InlineConstantMutator]MSP[S] } @Override public final Shape getShape () { return shape ; } public final boolean isFull () { return cardinality () == getShape () . getNumberOfBits () ;
if ( mine . length > theirs . length ) { big = mine ; small = theirs ; } else { small = mine ; big = theirs ; } int count = 0 ; MST[InlineConstantMutator]MSP[N]
if ( ( buff [ buffIdx ] & buffOffset ) == 0 ) { MST[rv.CRCR5Mutator]MSP[S] return false ; } } return true ; } @Override public final Shape getShape () { return shape ; } public final boolean isFull () { return cardinality () == getShape () . getNumberOfBits () ;
for ( int i = 0 ; i < small . length ; i ++ ) { count += Long . bitCount ( operation . applyAsLong ( small [ i ] , big [ i ] ) ) ; MST[rv.UOI2Mutator]MSP[N] }
for ( int i = 0 ; i < small . length ; i ++ ) { count += Long . bitCount ( operation . applyAsLong ( small [ i ] , big [ i ] ) ) ; MST[rv.AOD1Mutator]MSP[N] }
throw new IllegalArgumentException ( String . format ( lr_2 , shape , this . shape ) ) ; MST[rv.CRCR6Mutator]MSP[S] } } @Override public int xorCardinality ( final BloomFilter other ) { return opCardinality ( other , ( a , b ) -> a ^ b ) ; }
int count = 0 ; for ( final long bits : getBits () ) { count += Long . bitCount ( bits ) ; MST[rv.AOR2Mutator]MSP[N] } return count ; } @Override public boolean contains ( final BloomFilter other ) { verifyShape ( other ) ;
int count = 0 ; for ( int i = 0 ; i < limit ; i ++ ) { count += Long . bitCount ( mine [ i ] & theirs [ i ] ) ; MST[NonVoidMethodCallMutator]MSP[N] } return count ; } @Override public int cardinality () {
if ( shape . getHashFunctionIdentity () . getSignature () != hasher . getHashFunctionIdentity () . getSignature () ) { MST[rv.ROR4Mutator]MSP[N] throw new IllegalArgumentException ( String . format ( lr_1 , HashFunctionIdentity . asCommonString ( hasher . getHashFunctionIdentity () ) , shape . toString () ) ) ; } }
int count = 0 ; for ( int i = 0 ; i < limit ; i ++ ) { count += Long . bitCount ( mine [ i ] & theirs [ i ] ) ; MST[rv.OBBN2Mutator]MSP[S] } return count ; } @Override public int cardinality () {
if ( ( buff [ buffIdx ] & buffOffset ) == 0 ) { return false ; } } return true ; MST[BooleanFalseReturnValsMutator]MSP[S] } @Override public final Shape getShape () { return shape ; } public final boolean isFull () { return cardinality () == getShape () . getNumberOfBits () ;
int count = 0 ; for ( final long bits : getBits () ) { MST[NonVoidMethodCallMutator]MSP[N] count += Long . bitCount ( bits ) ; } return count ; } @Override public boolean contains ( final BloomFilter other ) { verifyShape ( other ) ;
if ( shape . getHashFunctionIdentity () . getSignature () != hasher . getHashFunctionIdentity () . getSignature () ) { MST[NonVoidMethodCallMutator]MSP[N] throw new IllegalArgumentException ( String . format ( lr_1 , HashFunctionIdentity . asCommonString ( hasher . getHashFunctionIdentity () ) , shape . toString () ) ) ; } }
if ( ( buff [ buffIdx ] & buffOffset ) == 0 ) { return false ; } } return true ; } @Override public final Shape getShape () { return shape ; } public final boolean isFull () { return cardinality () == getShape () . getNumberOfBits () ; MST[BooleanTrueReturnValsMutator]MSP[N]
if ( shape . getHashFunctionIdentity () . getSignature () != hasher . getHashFunctionIdentity () . getSignature () ) { throw new IllegalArgumentException ( MST[rv.CRCR6Mutator]MSP[S] String . format ( lr_1 , HashFunctionIdentity . asCommonString ( hasher . getHashFunctionIdentity () ) , shape . toString () ) ) ; } }
if ( shape . getHashFunctionIdentity () . getSignature () != hasher . getHashFunctionIdentity () . getSignature () ) { throw new IllegalArgumentException ( MST[rv.CRCR1Mutator]MSP[S] String . format ( lr_1 , HashFunctionIdentity . asCommonString ( hasher . getHashFunctionIdentity () ) , shape . toString () ) ) ; } }
if ( shape . getHashFunctionIdentity () . getSignature () != hasher . getHashFunctionIdentity () . getSignature () ) { throw new IllegalArgumentException ( MST[rv.CRCR5Mutator]MSP[N] String . format ( lr_1 , HashFunctionIdentity . asCommonString ( hasher . getHashFunctionIdentity () ) , shape . toString () ) ) ; } }
if ( ( buff [ buffIdx ] & buffOffset ) == 0 ) { return false ; } } return true ; } @Override public final Shape getShape () { return shape ; } public final boolean isFull () { return cardinality () == getShape () . getNumberOfBits () ; MST[rv.CRCR3Mutator]MSP[N]
if ( shape . getHashFunctionIdentity () . getSignature () != hasher . getHashFunctionIdentity () . getSignature () ) { throw new IllegalArgumentException ( String . format ( lr_1 , HashFunctionIdentity . asCommonString ( hasher . getHashFunctionIdentity () ) , MST[NonVoidMethodCallMutator]MSP[N] shape . toString () ) ) ; } }
if ( mine . length > theirs . length ) { MST[rv.ROR3Mutator]MSP[N] big = mine ; small = theirs ; } else { small = mine ; big = theirs ; } int count = 0 ;
if ( ( buff [ buffIdx ] & buffOffset ) == 0 ) { return false ; } } return true ; MST[rv.CRCR4Mutator]MSP[N] } @Override public final Shape getShape () { return shape ; } public final boolean isFull () { return cardinality () == getShape () . getNumberOfBits () ;
private int opCardinality ( final BloomFilter other , LongBinaryOperator operation ) { verifyShape ( other ) ; final long [] mine = getBits () ; final long [] theirs = other . getBits () ; MST[NonVoidMethodCallMutator]MSP[N] long [] small ; long [] big ;
for ( int i = small . length ; i < big . length ; i ++ ) { MST[rv.ABSMutator]MSP[N] count += Long . bitCount ( big [ i ] ) ; } return count ; }
if ( ( buff [ buffIdx ] & buffOffset ) == 0 ) { return false ; } } return true ; } @Override public final Shape getShape () { return shape ; } public final boolean isFull () { return cardinality () == getShape () . getNumberOfBits () ; MST[NonVoidMethodCallMutator]MSP[N]
int count = 0 ; for ( int i = 0 ; i < limit ; i ++ ) { MST[rv.ABSMutator]MSP[N] count += Long . bitCount ( mine [ i ] & theirs [ i ] ) ; } return count ; } @Override public int cardinality () {
for ( int i = small . length ; i < big . length ; i ++ ) { count += Long . bitCount ( big [ i ] ) ; MST[rv.UOI1Mutator]MSP[S] } return count ; }
if ( shape . getHashFunctionIdentity () . getSignature () != hasher . getHashFunctionIdentity () . getSignature () ) { MST[NegateConditionalsMutator]MSP[N] throw new IllegalArgumentException ( String . format ( lr_1 , HashFunctionIdentity . asCommonString ( hasher . getHashFunctionIdentity () ) , shape . toString () ) ) ; } }
for ( int i = small . length ; i < big . length ; i ++ ) { count += Long . bitCount ( big [ i ] ) ; MST[NonVoidMethodCallMutator]MSP[N] } return count ; }
int count = 0 ; MST[rv.CRCR1Mutator]MSP[N] for ( final long bits : getBits () ) { count += Long . bitCount ( bits ) ; } return count ; } @Override public boolean contains ( final BloomFilter other ) { verifyShape ( other ) ;
int count = 0 ; for ( int i = 0 ; i < limit ; i ++ ) { count += Long . bitCount ( mine [ i ] & theirs [ i ] ) ; MST[rv.UOI4Mutator]MSP[N] } return count ; } @Override public int cardinality () {
for ( int i = 0 ; i < small . length ; i ++ ) { count += Long . bitCount ( operation . applyAsLong ( small [ i ] , big [ i ] ) ) ; MST[rv.AOR4Mutator]MSP[N] }
return other . cardinality () == andCardinality ( other ) ; MST[rv.CRCR4Mutator]MSP[N] } @Override public boolean contains ( final Hasher hasher ) { verifyHasher ( hasher ) ; final long [] buff = getBits () ; final OfInt iter = hasher . getBits ( shape ) ;
int count = 0 ; MST[rv.CRCR6Mutator]MSP[N] for ( final long bits : getBits () ) { count += Long . bitCount ( bits ) ; } return count ; } @Override public boolean contains ( final BloomFilter other ) { verifyShape ( other ) ;
return other . cardinality () == andCardinality ( other ) ; MST[rv.CRCR5Mutator]MSP[S] } @Override public boolean contains ( final Hasher hasher ) { verifyHasher ( hasher ) ; final long [] buff = getBits () ; final OfInt iter = hasher . getBits ( shape ) ;
int count = 0 ; for ( int i = 0 ; i < limit ; i ++ ) { MST[rv.CRCR3Mutator]MSP[N] count += Long . bitCount ( mine [ i ] & theirs [ i ] ) ; } return count ; } @Override public int cardinality () {
return other . cardinality () == andCardinality ( other ) ; MST[NonVoidMethodCallMutator]MSP[S] } @Override public boolean contains ( final Hasher hasher ) { verifyHasher ( hasher ) ; final long [] buff = getBits () ; final OfInt iter = hasher . getBits ( shape ) ;
for ( int i = 0 ; i < small . length ; i ++ ) { count += Long . bitCount ( operation . applyAsLong ( small [ i ] , big [ i ] ) ) ; MST[rv.UOI3Mutator]MSP[N] }
int count = 0 ; MST[rv.CRCR6Mutator]MSP[N] for ( int i = 0 ; i < limit ; i ++ ) { count += Long . bitCount ( mine [ i ] & theirs [ i ] ) ; } return count ; } @Override public int cardinality () {
for ( int i = 0 ; i < small . length ; i ++ ) { count += Long . bitCount ( operation . applyAsLong ( small [ i ] , big [ i ] ) ) ; MST[rv.ABSMutator]MSP[N] }
if ( shape . getHashFunctionIdentity () . getSignature () != hasher . getHashFunctionIdentity () . getSignature () ) { MST[NonVoidMethodCallMutator]MSP[N] throw new IllegalArgumentException ( String . format ( lr_1 , HashFunctionIdentity . asCommonString ( hasher . getHashFunctionIdentity () ) , shape . toString () ) ) ; } }
for ( int i = 0 ; i < small . length ; i ++ ) { count += Long . bitCount ( operation . applyAsLong ( small [ i ] , big [ i ] ) ) ; MST[rv.UOI2Mutator]MSP[N] }
@Override public int andCardinality ( final BloomFilter other ) { verifyShape ( other ) ; final long [] mine = getBits () ; final long [] theirs = other . getBits () ; final int limit = Integer . min ( mine . length , theirs . length ) ; MST[ArgumentPropagationMutator]MSP[S]
if ( ( buff [ buffIdx ] & buffOffset ) == 0 ) { return false ; } } return true ; } @Override public final Shape getShape () { return shape ; } public final boolean isFull () { return cardinality () == getShape () . getNumberOfBits () ; MST[rv.CRCR4Mutator]MSP[N]
if ( shape . getHashFunctionIdentity () . getSignature () != hasher . getHashFunctionIdentity () . getSignature () ) { throw new IllegalArgumentException ( MST[rv.CRCR1Mutator]MSP[N] String . format ( lr_1 , HashFunctionIdentity . asCommonString ( hasher . getHashFunctionIdentity () ) , shape . toString () ) ) ; } }
} @Override public int orCardinality ( final BloomFilter other ) { return opCardinality ( other , ( a , b ) -> a | b ) ; MST[rv.UOI4Mutator]MSP[N] } protected void verifyHasher ( final Hasher hasher ) {
throw new IllegalArgumentException ( String . format ( lr_2 , shape , this . shape ) ) ; } } @Override public int xorCardinality ( final BloomFilter other ) { return opCardinality ( other , ( a , b ) -> a ^ b ) ; MST[ReturnValsMutator]MSP[N] }
} @Override public int orCardinality ( final BloomFilter other ) { return opCardinality ( other , ( a , b ) -> a | b ) ; MST[rv.ABSMutator]MSP[N] } protected void verifyHasher ( final Hasher hasher ) {
if ( mine . length > theirs . length ) { MST[rv.ROR2Mutator]MSP[N] big = mine ; small = theirs ; } else { small = mine ; big = theirs ; } int count = 0 ;
} @Override public int orCardinality ( final BloomFilter other ) { return opCardinality ( other , ( a , b ) -> a | b ) ; MST[rv.OBBN1Mutator]MSP[N] } protected void verifyHasher ( final Hasher hasher ) {
int count = 0 ; for ( int i = 0 ; i < limit ; i ++ ) { MST[rv.UOI3Mutator]MSP[N] count += Long . bitCount ( mine [ i ] & theirs [ i ] ) ; } return count ; } @Override public int cardinality () {
if ( ( buff [ buffIdx ] & buffOffset ) == 0 ) { MST[rv.UOI2Mutator]MSP[N] return false ; } } return true ; } @Override public final Shape getShape () { return shape ; } public final boolean isFull () { return cardinality () == getShape () . getNumberOfBits () ;
int count = 0 ; for ( int i = 0 ; i < limit ; i ++ ) { count += Long . bitCount ( mine [ i ] & theirs [ i ] ) ; MST[MathMutator]MSP[N] } return count ; } @Override public int cardinality () {
int count = 0 ; for ( int i = 0 ; i < limit ; i ++ ) { MST[rv.ROR5Mutator]MSP[N] count += Long . bitCount ( mine [ i ] & theirs [ i ] ) ; } return count ; } @Override public int cardinality () {
if ( ( buff [ buffIdx ] & buffOffset ) == 0 ) { return false ; } } return true ; } @Override public final Shape getShape () { return shape ; } public final boolean isFull () { return cardinality () == getShape () . getNumberOfBits () ; MST[NegateConditionalsMutator]MSP[N]
protected void verifyShape ( final BloomFilter other ) { verifyShape ( other . getShape () ) ; } protected void verifyShape ( final Shape shape ) { if ( ! this . shape . equals ( shape ) ) { MST[rv.ROR3Mutator]MSP[N]
int count = 0 ; for ( int i = 0 ; i < limit ; i ++ ) { MST[ConditionalsBoundaryMutator]MSP[N] count += Long . bitCount ( mine [ i ] & theirs [ i ] ) ; } return count ; } @Override public int cardinality () {
int count = 0 ; for ( int i = 0 ; i < limit ; i ++ ) { count += Long . bitCount ( mine [ i ] & theirs [ i ] ) ; MST[rv.AOR1Mutator]MSP[N] } return count ; } @Override public int cardinality () {
protected void verifyShape ( final BloomFilter other ) { verifyShape ( other . getShape () ) ; } protected void verifyShape ( final Shape shape ) { if ( ! this . shape . equals ( shape ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
for ( int i = 0 ; i < small . length ; i ++ ) { MST[rv.ROR3Mutator]MSP[N] count += Long . bitCount ( operation . applyAsLong ( small [ i ] , big [ i ] ) ) ; }
if ( ( buff [ buffIdx ] & buffOffset ) == 0 ) { return false ; } } return true ; } @Override public final Shape getShape () { return shape ; } public final boolean isFull () { return cardinality () == getShape () . getNumberOfBits () ; MST[ReturnValsMutator]MSP[N]
throw new IllegalArgumentException ( String . format ( lr_2 , shape , this . shape ) ) ; MST[rv.CRCR5Mutator]MSP[N] } } @Override public int xorCardinality ( final BloomFilter other ) { return opCardinality ( other , ( a , b ) -> a ^ b ) ; }
for ( int i = 0 ; i < small . length ; i ++ ) { count += Long . bitCount ( operation . applyAsLong ( small [ i ] , big [ i ] ) ) ; MST[rv.UOI4Mutator]MSP[N] }
for ( int i = 0 ; i < small . length ; i ++ ) { count += Long . bitCount ( operation . applyAsLong ( small [ i ] , big [ i ] ) ) ; MST[rv.ABSMutator]MSP[S] }
for ( int i = 0 ; i < small . length ; i ++ ) { count += Long . bitCount ( operation . applyAsLong ( small [ i ] , big [ i ] ) ) ; MST[rv.UOI3Mutator]MSP[N] }
if ( ( buff [ buffIdx ] & buffOffset ) == 0 ) { return false ; } } return true ; } @Override public final Shape getShape () { return shape ; } public final boolean isFull () { return cardinality () == getShape () . getNumberOfBits () ; MST[rv.CRCR5Mutator]MSP[N]
while ( iter . hasNext () ) { final int idx = iter . nextInt () ; BloomFilterIndexer . checkPositive ( idx ) ; MST[rv.UOI2Mutator]MSP[N] final int buffIdx = BloomFilterIndexer . getLongIndex ( idx ) ; final long buffOffset = BloomFilterIndexer . getLongBit ( idx ) ;
return other . cardinality () == andCardinality ( other ) ; } @Override public boolean contains ( final Hasher hasher ) { verifyHasher ( hasher ) ; final long [] buff = getBits () ; final OfInt iter = hasher . getBits ( shape ) ; MST[NonVoidMethodCallMutator]MSP[S]
} @Override public int orCardinality ( final BloomFilter other ) { return opCardinality ( other , ( a , b ) -> a | b ) ; MST[rv.UOI4Mutator]MSP[N] } protected void verifyHasher ( final Hasher hasher ) {
if ( shape . getHashFunctionIdentity () . getSignature () != hasher . getHashFunctionIdentity () . getSignature () ) { throw new IllegalArgumentException ( String . format ( lr_1 , HashFunctionIdentity . asCommonString ( hasher . getHashFunctionIdentity () ) , MST[rv.CRCR4Mutator]MSP[S] shape . toString () ) ) ; } }
while ( iter . hasNext () ) { final int idx = iter . nextInt () ; BloomFilterIndexer . checkPositive ( idx ) ; final int buffIdx = BloomFilterIndexer . getLongIndex ( idx ) ; MST[ArgumentPropagationMutator]MSP[S] final long buffOffset = BloomFilterIndexer . getLongBit ( idx ) ;
throw new IllegalArgumentException ( String . format ( lr_2 , shape , this . shape ) ) ; } } @Override public int xorCardinality ( final BloomFilter other ) { return opCardinality ( other , ( a , b ) -> a ^ b ) ; MST[PrimitiveReturnsMutator]MSP[S] }
while ( iter . hasNext () ) { final int idx = iter . nextInt () ; BloomFilterIndexer . checkPositive ( idx ) ; MST[VoidMethodCallMutator]MSP[N] final int buffIdx = BloomFilterIndexer . getLongIndex ( idx ) ; final long buffOffset = BloomFilterIndexer . getLongBit ( idx ) ;
for ( int i = small . length ; i < big . length ; i ++ ) { MST[IncrementsMutator]MSP[N] count += Long . bitCount ( big [ i ] ) ; } return count ; }
for ( int i = small . length ; i < big . length ; i ++ ) { count += Long . bitCount ( big [ i ] ) ; MST[rv.AOR2Mutator]MSP[N] } return count ; }
int count = 0 ; for ( int i = 0 ; i < limit ; i ++ ) { MST[rv.UOI3Mutator]MSP[N] count += Long . bitCount ( mine [ i ] & theirs [ i ] ) ; } return count ; } @Override public int cardinality () {
if ( ( buff [ buffIdx ] & buffOffset ) == 0 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] return false ; } } return true ; } @Override public final Shape getShape () { return shape ; } public final boolean isFull () { return cardinality () == getShape () . getNumberOfBits () ;
if ( ( buff [ buffIdx ] & buffOffset ) == 0 ) { MST[rv.UOI2Mutator]MSP[N] return false ; } } return true ; } @Override public final Shape getShape () { return shape ; } public final boolean isFull () { return cardinality () == getShape () . getNumberOfBits () ;
for ( int i = 0 ; i < small . length ; i ++ ) { MST[rv.CRCR5Mutator]MSP[N] count += Long . bitCount ( operation . applyAsLong ( small [ i ] , big [ i ] ) ) ; }
for ( int i = small . length ; i < big . length ; i ++ ) { count += Long . bitCount ( big [ i ] ) ; MST[rv.UOI2Mutator]MSP[N] } return count ; }
for ( int i = small . length ; i < big . length ; i ++ ) { count += Long . bitCount ( big [ i ] ) ; MST[rv.UOI1Mutator]MSP[N] } return count ; }
int count = 0 ; for ( int i = 0 ; i < limit ; i ++ ) { count += Long . bitCount ( mine [ i ] & theirs [ i ] ) ; MST[rv.UOI4Mutator]MSP[N] } return count ; } @Override public int cardinality () {
int count = 0 ; for ( final long bits : getBits () ) { count += Long . bitCount ( bits ) ; MST[rv.UOI2Mutator]MSP[N] } return count ; } @Override public boolean contains ( final BloomFilter other ) { verifyShape ( other ) ;
if ( ( buff [ buffIdx ] & buffOffset ) == 0 ) { MST[rv.ROR1Mutator]MSP[S] return false ; } } return true ; } @Override public final Shape getShape () { return shape ; } public final boolean isFull () { return cardinality () == getShape () . getNumberOfBits () ;
int count = 0 ; for ( int i = 0 ; i < limit ; i ++ ) { count += Long . bitCount ( mine [ i ] & theirs [ i ] ) ; MST[rv.UOI1Mutator]MSP[N] } return count ; } @Override public int cardinality () {
if ( ( buff [ buffIdx ] & buffOffset ) == 0 ) { return false ; MST[rv.CRCR5Mutator]MSP[S] } } return true ; } @Override public final Shape getShape () { return shape ; } public final boolean isFull () { return cardinality () == getShape () . getNumberOfBits () ;
if ( ( buff [ buffIdx ] & buffOffset ) == 0 ) { return false ; } } return true ; } @Override public final Shape getShape () { return shape ; } public final boolean isFull () { return cardinality () == getShape () . getNumberOfBits () ; MST[rv.ROR5Mutator]MSP[N]
for ( int i = small . length ; i < big . length ; i ++ ) { count += Long . bitCount ( big [ i ] ) ; MST[rv.AOD2Mutator]MSP[S] } return count ; }
throw new IllegalArgumentException ( String . format ( lr_2 , shape , this . shape ) ) ; } } @Override public int xorCardinality ( final BloomFilter other ) { return opCardinality ( other , ( a , b ) -> a ^ b ) ; MST[rv.UOI1Mutator]MSP[N] }
int count = 0 ; for ( final long bits : getBits () ) { count += Long . bitCount ( bits ) ; } return count ; MST[rv.UOI1Mutator]MSP[N] } @Override public boolean contains ( final BloomFilter other ) { verifyShape ( other ) ;
int count = 0 ; for ( final long bits : getBits () ) { MST[rv.UOI4Mutator]MSP[N] count += Long . bitCount ( bits ) ; } return count ; } @Override public boolean contains ( final BloomFilter other ) { verifyShape ( other ) ;
throw new IllegalArgumentException ( String . format ( lr_2 , shape , this . shape ) ) ; MST[rv.CRCR6Mutator]MSP[S] } } @Override public int xorCardinality ( final BloomFilter other ) { return opCardinality ( other , ( a , b ) -> a ^ b ) ; }
int count = 0 ; for ( int i = 0 ; i < limit ; i ++ ) { count += Long . bitCount ( mine [ i ] & theirs [ i ] ) ; } return count ; MST[rv.UOI4Mutator]MSP[N] } @Override public int cardinality () {
for ( int i = 0 ; i < small . length ; i ++ ) { count += Long . bitCount ( operation . applyAsLong ( small [ i ] , big [ i ] ) ) ; MST[rv.UOI4Mutator]MSP[N] }
if ( ( buff [ buffIdx ] & buffOffset ) == 0 ) { return false ; } } return true ; } @Override public final Shape getShape () { return shape ; } public final boolean isFull () { return cardinality () == getShape () . getNumberOfBits () ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
for ( int i = 0 ; i < small . length ; i ++ ) { MST[rv.UOI1Mutator]MSP[N] count += Long . bitCount ( operation . applyAsLong ( small [ i ] , big [ i ] ) ) ; }
int count = 0 ; for ( final long bits : getBits () ) { count += Long . bitCount ( bits ) ; } return count ; MST[ReturnValsMutator]MSP[N] } @Override public boolean contains ( final BloomFilter other ) { verifyShape ( other ) ;
return other . cardinality () == andCardinality ( other ) ; MST[rv.ROR3Mutator]MSP[N] } @Override public boolean contains ( final Hasher hasher ) { verifyHasher ( hasher ) ; final long [] buff = getBits () ; final OfInt iter = hasher . getBits ( shape ) ;
int count = 0 ; for ( final long bits : getBits () ) { MST[rv.UOI1Mutator]MSP[N] count += Long . bitCount ( bits ) ; } return count ; } @Override public boolean contains ( final BloomFilter other ) { verifyShape ( other ) ;
if ( ( buff [ buffIdx ] & buffOffset ) == 0 ) { MST[rv.OBBN1Mutator]MSP[S] return false ; } } return true ; } @Override public final Shape getShape () { return shape ; } public final boolean isFull () { return cardinality () == getShape () . getNumberOfBits () ;
if ( shape . getHashFunctionIdentity () . getSignature () != hasher . getHashFunctionIdentity () . getSignature () ) { throw new IllegalArgumentException ( MST[rv.CRCR2Mutator]MSP[S] String . format ( lr_1 , HashFunctionIdentity . asCommonString ( hasher . getHashFunctionIdentity () ) , shape . toString () ) ) ; } }
return other . cardinality () == andCardinality ( other ) ; MST[InlineConstantMutator]MSP[S] } @Override public boolean contains ( final Hasher hasher ) { verifyHasher ( hasher ) ; final long [] buff = getBits () ; final OfInt iter = hasher . getBits ( shape ) ;
if ( ( buff [ buffIdx ] & buffOffset ) == 0 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] return false ; } } return true ; } @Override public final Shape getShape () { return shape ; } public final boolean isFull () { return cardinality () == getShape () . getNumberOfBits () ;
throw new IllegalArgumentException ( String . format ( lr_2 , shape , this . shape ) ) ; MST[rv.CRCR2Mutator]MSP[S] } } @Override public int xorCardinality ( final BloomFilter other ) { return opCardinality ( other , ( a , b ) -> a ^ b ) ; }
while ( iter . hasNext () ) { final int idx = iter . nextInt () ; BloomFilterIndexer . checkPositive ( idx ) ; MST[rv.UOI3Mutator]MSP[N] final int buffIdx = BloomFilterIndexer . getLongIndex ( idx ) ; final long buffOffset = BloomFilterIndexer . getLongBit ( idx ) ;
int count = 0 ; for ( final long bits : getBits () ) { count += Long . bitCount ( bits ) ; MST[NonVoidMethodCallMutator]MSP[N] } return count ; } @Override public boolean contains ( final BloomFilter other ) { verifyShape ( other ) ;
if ( ( buff [ buffIdx ] & buffOffset ) == 0 ) { return false ; } } return true ; } @Override public final Shape getShape () { return shape ; } public final boolean isFull () { return cardinality () == getShape () . getNumberOfBits () ; MST[rv.ROR1Mutator]MSP[N]
private int opCardinality ( final BloomFilter other , LongBinaryOperator operation ) { verifyShape ( other ) ; final long [] mine = getBits () ; MST[NonVoidMethodCallMutator]MSP[N] final long [] theirs = other . getBits () ; long [] small ; long [] big ;
if ( shape . getHashFunctionIdentity () . getSignature () != hasher . getHashFunctionIdentity () . getSignature () ) { throw new IllegalArgumentException ( MST[rv.CRCR6Mutator]MSP[S] String . format ( lr_1 , HashFunctionIdentity . asCommonString ( hasher . getHashFunctionIdentity () ) , shape . toString () ) ) ; } }
if ( ( buff [ buffIdx ] & buffOffset ) == 0 ) { MST[rv.UOI3Mutator]MSP[S] return false ; } } return true ; } @Override public final Shape getShape () { return shape ; } public final boolean isFull () { return cardinality () == getShape () . getNumberOfBits () ;
if ( ( buff [ buffIdx ] & buffOffset ) == 0 ) { return false ; } } return true ; MST[rv.CRCR3Mutator]MSP[N] } @Override public final Shape getShape () { return shape ; } public final boolean isFull () { return cardinality () == getShape () . getNumberOfBits () ;
if ( ( buff [ buffIdx ] & buffOffset ) == 0 ) { return false ; MST[ReturnValsMutator]MSP[S] } } return true ; } @Override public final Shape getShape () { return shape ; } public final boolean isFull () { return cardinality () == getShape () . getNumberOfBits () ;
if ( shape . getHashFunctionIdentity () . getSignature () != hasher . getHashFunctionIdentity () . getSignature () ) { throw new IllegalArgumentException ( MST[InlineConstantMutator]MSP[N] String . format ( lr_1 , HashFunctionIdentity . asCommonString ( hasher . getHashFunctionIdentity () ) , shape . toString () ) ) ; } }
protected void verifyShape ( final BloomFilter other ) { verifyShape ( other . getShape () ) ; } protected void verifyShape ( final Shape shape ) { if ( ! this . shape . equals ( shape ) ) { MST[rv.ROR5Mutator]MSP[N]
int count = 0 ; for ( final long bits : getBits () ) { count += Long . bitCount ( bits ) ; MST[rv.UOI2Mutator]MSP[N] } return count ; } @Override public boolean contains ( final BloomFilter other ) { verifyShape ( other ) ;
if ( shape . getHashFunctionIdentity () . getSignature () != hasher . getHashFunctionIdentity () . getSignature () ) { MST[rv.ROR5Mutator]MSP[N] throw new IllegalArgumentException ( String . format ( lr_1 , HashFunctionIdentity . asCommonString ( hasher . getHashFunctionIdentity () ) , shape . toString () ) ) ; } }
protected void verifyShape ( final BloomFilter other ) { verifyShape ( other . getShape () ) ; } protected void verifyShape ( final Shape shape ) { if ( ! this . shape . equals ( shape ) ) { MST[rv.ROR1Mutator]MSP[N]
for ( int i = small . length ; i < big . length ; i ++ ) { count += Long . bitCount ( big [ i ] ) ; } return count ; MST[rv.UOI1Mutator]MSP[N] }
int count = 0 ; for ( int i = 0 ; i < limit ; i ++ ) { count += Long . bitCount ( mine [ i ] & theirs [ i ] ) ; MST[rv.UOI1Mutator]MSP[N] } return count ; } @Override public int cardinality () {
throw new IllegalArgumentException ( String . format ( lr_2 , shape , this . shape ) ) ; MST[InlineConstantMutator]MSP[N] } } @Override public int xorCardinality ( final BloomFilter other ) { return opCardinality ( other , ( a , b ) -> a ^ b ) ; }
int count = 0 ; for ( int i = 0 ; i < limit ; i ++ ) { count += Long . bitCount ( mine [ i ] & theirs [ i ] ) ; MST[rv.AOR2Mutator]MSP[N] } return count ; } @Override public int cardinality () {
int count = 0 ; for ( final long bits : getBits () ) { MST[rv.UOI4Mutator]MSP[N] count += Long . bitCount ( bits ) ; } return count ; } @Override public boolean contains ( final BloomFilter other ) { verifyShape ( other ) ;
int count = 0 ; for ( int i = 0 ; i < limit ; i ++ ) { count += Long . bitCount ( mine [ i ] & theirs [ i ] ) ; MST[rv.OBBN3Mutator]MSP[S] } return count ; } @Override public int cardinality () {
if ( shape . getHashFunctionIdentity () . getSignature () != hasher . getHashFunctionIdentity () . getSignature () ) { MST[rv.ROR1Mutator]MSP[N] throw new IllegalArgumentException ( String . format ( lr_1 , HashFunctionIdentity . asCommonString ( hasher . getHashFunctionIdentity () ) , shape . toString () ) ) ; } }
int count = 0 ; for ( final long bits : getBits () ) { count += Long . bitCount ( bits ) ; MST[rv.AOR3Mutator]MSP[N] } return count ; } @Override public boolean contains ( final BloomFilter other ) { verifyShape ( other ) ;
int count = 0 ; for ( int i = 0 ; i < limit ; i ++ ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] count += Long . bitCount ( mine [ i ] & theirs [ i ] ) ; } return count ; } @Override public int cardinality () {
int count = 0 ; for ( final long bits : getBits () ) { MST[rv.UOI1Mutator]MSP[S] count += Long . bitCount ( bits ) ; } return count ; } @Override public boolean contains ( final BloomFilter other ) { verifyShape ( other ) ;
for ( int i = small . length ; i < big . length ; i ++ ) { count += Long . bitCount ( big [ i ] ) ; MST[MathMutator]MSP[N] } return count ; }
if ( ( buff [ buffIdx ] & buffOffset ) == 0 ) { MST[MathMutator]MSP[S] return false ; } } return true ; } @Override public final Shape getShape () { return shape ; } public final boolean isFull () { return cardinality () == getShape () . getNumberOfBits () ;
if ( shape . getHashFunctionIdentity () . getSignature () != hasher . getHashFunctionIdentity () . getSignature () ) { throw new IllegalArgumentException ( String . format ( lr_1 , MST[ConstructorCallMutator]MSP[S] HashFunctionIdentity . asCommonString ( hasher . getHashFunctionIdentity () ) , shape . toString () ) ) ; } }
while ( iter . hasNext () ) { MST[rv.ROR2Mutator]MSP[N] final int idx = iter . nextInt () ; BloomFilterIndexer . checkPositive ( idx ) ; final int buffIdx = BloomFilterIndexer . getLongIndex ( idx ) ; final long buffOffset = BloomFilterIndexer . getLongBit ( idx ) ;
while ( iter . hasNext () ) { final int idx = iter . nextInt () ; BloomFilterIndexer . checkPositive ( idx ) ; final int buffIdx = BloomFilterIndexer . getLongIndex ( idx ) ; MST[rv.UOI4Mutator]MSP[N] final long buffOffset = BloomFilterIndexer . getLongBit ( idx ) ;
if ( ( buff [ buffIdx ] & buffOffset ) == 0 ) { return false ; MST[rv.CRCR1Mutator]MSP[S] } } return true ; } @Override public final Shape getShape () { return shape ; } public final boolean isFull () { return cardinality () == getShape () . getNumberOfBits () ;
if ( ( buff [ buffIdx ] & buffOffset ) == 0 ) { MST[rv.ROR5Mutator]MSP[S] return false ; } } return true ; } @Override public final Shape getShape () { return shape ; } public final boolean isFull () { return cardinality () == getShape () . getNumberOfBits () ;
if ( mine . length > theirs . length ) { big = mine ; small = theirs ; } else { small = mine ; big = theirs ; } int count = 0 ; MST[rv.CRCR3Mutator]MSP[N]
if ( ( buff [ buffIdx ] & buffOffset ) == 0 ) { MST[rv.UOI3Mutator]MSP[S] return false ; } } return true ; } @Override public final Shape getShape () { return shape ; } public final boolean isFull () { return cardinality () == getShape () . getNumberOfBits () ;
int count = 0 ; for ( int i = 0 ; i < limit ; i ++ ) { MST[rv.UOI2Mutator]MSP[N] count += Long . bitCount ( mine [ i ] & theirs [ i ] ) ; } return count ; } @Override public int cardinality () {
if ( shape . getHashFunctionIdentity () . getSignature () != hasher . getHashFunctionIdentity () . getSignature () ) { throw new IllegalArgumentException ( String . format ( lr_1 , MST[NonVoidMethodCallMutator]MSP[N] HashFunctionIdentity . asCommonString ( hasher . getHashFunctionIdentity () ) , shape . toString () ) ) ; } }
for ( int i = small . length ; i < big . length ; i ++ ) { count += Long . bitCount ( big [ i ] ) ; MST[rv.AOR4Mutator]MSP[N] } return count ; }
if ( ( buff [ buffIdx ] & buffOffset ) == 0 ) { return false ; } } return true ; } @Override public final Shape getShape () { return shape ; MST[NullReturnValsMutator]MSP[N] } public final boolean isFull () { return cardinality () == getShape () . getNumberOfBits () ;
for ( int i = small . length ; i < big . length ; i ++ ) { count += Long . bitCount ( big [ i ] ) ; } return count ; MST[rv.ABSMutator]MSP[N] }
int count = 0 ; for ( int i = 0 ; i < limit ; i ++ ) { MST[rv.UOI2Mutator]MSP[S] count += Long . bitCount ( mine [ i ] & theirs [ i ] ) ; } return count ; } @Override public int cardinality () {
int count = 0 ; MST[rv.CRCR5Mutator]MSP[N] for ( final long bits : getBits () ) { count += Long . bitCount ( bits ) ; } return count ; } @Override public boolean contains ( final BloomFilter other ) { verifyShape ( other ) ;
return other . cardinality () == andCardinality ( other ) ; MST[rv.CRCR2Mutator]MSP[S] } @Override public boolean contains ( final Hasher hasher ) { verifyHasher ( hasher ) ; final long [] buff = getBits () ; final OfInt iter = hasher . getBits ( shape ) ;
int count = 0 ; for ( int i = 0 ; i < limit ; i ++ ) { count += Long . bitCount ( mine [ i ] & theirs [ i ] ) ; MST[rv.UOI3Mutator]MSP[N] } return count ; } @Override public int cardinality () {
for ( int i = 0 ; i < small . length ; i ++ ) { count += Long . bitCount ( operation . applyAsLong ( small [ i ] , big [ i ] ) ) ; MST[rv.AOR1Mutator]MSP[N] }
return other . cardinality () == andCardinality ( other ) ; MST[rv.CRCR3Mutator]MSP[N] } @Override public boolean contains ( final Hasher hasher ) { verifyHasher ( hasher ) ; final long [] buff = getBits () ; final OfInt iter = hasher . getBits ( shape ) ;
throw new IllegalArgumentException ( String . format ( lr_2 , shape , this . shape ) ) ; MST[InlineConstantMutator]MSP[N] } } @Override public int xorCardinality ( final BloomFilter other ) { return opCardinality ( other , ( a , b ) -> a ^ b ) ; }
return other . cardinality () == andCardinality ( other ) ; } @Override public boolean contains ( final Hasher hasher ) { verifyHasher ( hasher ) ; MST[VoidMethodCallMutator]MSP[N] final long [] buff = getBits () ; final OfInt iter = hasher . getBits ( shape ) ;
int count = 0 ; for ( int i = 0 ; i < limit ; i ++ ) { MST[rv.CRCR1Mutator]MSP[N] count += Long . bitCount ( mine [ i ] & theirs [ i ] ) ; } return count ; } @Override public int cardinality () {
int count = 0 ; for ( int i = 0 ; i < limit ; i ++ ) { MST[rv.CRCR6Mutator]MSP[N] count += Long . bitCount ( mine [ i ] & theirs [ i ] ) ; } return count ; } @Override public int cardinality () {
int count = 0 ; MST[rv.CRCR5Mutator]MSP[N] for ( int i = 0 ; i < limit ; i ++ ) { count += Long . bitCount ( mine [ i ] & theirs [ i ] ) ; } return count ; } @Override public int cardinality () {
protected void verifyShape ( final BloomFilter other ) { verifyShape ( other . getShape () ) ; } protected void verifyShape ( final Shape shape ) { if ( ! this . shape . equals ( shape ) ) { MST[NegateConditionalsMutator]MSP[N]
if ( ( buff [ buffIdx ] & buffOffset ) == 0 ) { return false ; } } return true ; } @Override public final Shape getShape () { return shape ; } public final boolean isFull () { return cardinality () == getShape () . getNumberOfBits () ; MST[rv.CRCR6Mutator]MSP[N]
for ( int i = 0 ; i < small . length ; i ++ ) { count += Long . bitCount ( operation . applyAsLong ( small [ i ] , big [ i ] ) ) ; MST[rv.UOI4Mutator]MSP[N] }
int count = 0 ; for ( final long bits : getBits () ) { count += Long . bitCount ( bits ) ; MST[rv.ABSMutator]MSP[N] } return count ; } @Override public boolean contains ( final BloomFilter other ) { verifyShape ( other ) ;
if ( shape . getHashFunctionIdentity () . getSignature () != hasher . getHashFunctionIdentity () . getSignature () ) { MST[NonVoidMethodCallMutator]MSP[N] throw new IllegalArgumentException ( String . format ( lr_1 , HashFunctionIdentity . asCommonString ( hasher . getHashFunctionIdentity () ) , shape . toString () ) ) ; } }
for ( int i = 0 ; i < small . length ; i ++ ) { count += Long . bitCount ( operation . applyAsLong ( small [ i ] , big [ i ] ) ) ; MST[rv.UOI3Mutator]MSP[N] }
throw new IllegalArgumentException ( String . format ( lr_2 , shape , this . shape ) ) ; MST[rv.CRCR3Mutator]MSP[S] } } @Override public int xorCardinality ( final BloomFilter other ) { return opCardinality ( other , ( a , b ) -> a ^ b ) ; }
int count = 0 ; for ( final long bits : getBits () ) { count += Long . bitCount ( bits ) ; MST[rv.AOR4Mutator]MSP[N] } return count ; } @Override public boolean contains ( final BloomFilter other ) { verifyShape ( other ) ;
if ( shape . getHashFunctionIdentity () . getSignature () != hasher . getHashFunctionIdentity () . getSignature () ) { throw new IllegalArgumentException ( MST[rv.CRCR3Mutator]MSP[S] String . format ( lr_1 , HashFunctionIdentity . asCommonString ( hasher . getHashFunctionIdentity () ) , shape . toString () ) ) ; } }
} @Override public int orCardinality ( final BloomFilter other ) { return opCardinality ( other , ( a , b ) -> a | b ) ; MST[rv.UOI3Mutator]MSP[N] } protected void verifyHasher ( final Hasher hasher ) {
if ( shape . getHashFunctionIdentity () . getSignature () != hasher . getHashFunctionIdentity () . getSignature () ) { throw new IllegalArgumentException ( String . format ( lr_1 , HashFunctionIdentity . asCommonString ( hasher . getHashFunctionIdentity () ) , MST[rv.CRCR5Mutator]MSP[S] shape . toString () ) ) ; } }
if ( ( buff [ buffIdx ] & buffOffset ) == 0 ) { MST[NegateConditionalsMutator]MSP[S] return false ; } } return true ; } @Override public final Shape getShape () { return shape ; } public final boolean isFull () { return cardinality () == getShape () . getNumberOfBits () ;
if ( ( buff [ buffIdx ] & buffOffset ) == 0 ) { return false ; } } return true ; } @Override public final Shape getShape () { return shape ; } public final boolean isFull () { return cardinality () == getShape () . getNumberOfBits () ; MST[NonVoidMethodCallMutator]MSP[N]
int count = 0 ; for ( final long bits : getBits () ) { count += Long . bitCount ( bits ) ; MST[MathMutator]MSP[N] } return count ; } @Override public boolean contains ( final BloomFilter other ) { verifyShape ( other ) ;
throw new IllegalArgumentException ( String . format ( lr_2 , shape , this . shape ) ) ; } } @Override public int xorCardinality ( final BloomFilter other ) { return opCardinality ( other , ( a , b ) -> a ^ b ) ; MST[rv.ABSMutator]MSP[N] }
for ( int i = small . length ; i < big . length ; i ++ ) { count += Long . bitCount ( big [ i ] ) ; MST[rv.UOI3Mutator]MSP[N] } return count ; }
for ( int i = small . length ; i < big . length ; i ++ ) { count += Long . bitCount ( big [ i ] ) ; MST[rv.AOR3Mutator]MSP[N] } return count ; }
int count = 0 ; for ( int i = 0 ; i < limit ; i ++ ) { MST[rv.ABSMutator]MSP[N] count += Long . bitCount ( mine [ i ] & theirs [ i ] ) ; } return count ; } @Override public int cardinality () {
int count = 0 ; for ( int i = 0 ; i < limit ; i ++ ) { count += Long . bitCount ( mine [ i ] & theirs [ i ] ) ; MST[rv.UOI4Mutator]MSP[N] } return count ; } @Override public int cardinality () {
int count = 0 ; for ( int i = 0 ; i < limit ; i ++ ) { MST[rv.ROR4Mutator]MSP[N] count += Long . bitCount ( mine [ i ] & theirs [ i ] ) ; } return count ; } @Override public int cardinality () {
protected void verifyShape ( final BloomFilter other ) { verifyShape ( other . getShape () ) ; } protected void verifyShape ( final Shape shape ) { if ( ! this . shape . equals ( shape ) ) { MST[rv.ROR2Mutator]MSP[N]
if ( ( buff [ buffIdx ] & buffOffset ) == 0 ) { MST[rv.CRCR3Mutator]MSP[S] return false ; } } return true ; } @Override public final Shape getShape () { return shape ; } public final boolean isFull () { return cardinality () == getShape () . getNumberOfBits () ;
return other . cardinality () == andCardinality ( other ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] } @Override public boolean contains ( final Hasher hasher ) { verifyHasher ( hasher ) ; final long [] buff = getBits () ; final OfInt iter = hasher . getBits ( shape ) ;
throw new IllegalArgumentException ( String . format ( lr_2 , shape , this . shape ) ) ; } } @Override public int xorCardinality ( final BloomFilter other ) { return opCardinality ( other , ( a , b ) -> a ^ b ) ; MST[rv.UOI1Mutator]MSP[N] }
int count = 0 ; for ( int i = 0 ; i < limit ; i ++ ) { count += Long . bitCount ( mine [ i ] & theirs [ i ] ) ; MST[rv.UOI1Mutator]MSP[N] } return count ; } @Override public int cardinality () {
protected void verifyShape ( final BloomFilter other ) { verifyShape ( other . getShape () ) ; MST[NonVoidMethodCallMutator]MSP[N] } protected void verifyShape ( final Shape shape ) { if ( ! this . shape . equals ( shape ) ) {
int count = 0 ; for ( final long bits : getBits () ) { MST[rv.UOI3Mutator]MSP[N] count += Long . bitCount ( bits ) ; } return count ; } @Override public boolean contains ( final BloomFilter other ) { verifyShape ( other ) ;
@Override public int andCardinality ( final BloomFilter other ) { verifyShape ( other ) ; MST[VoidMethodCallMutator]MSP[N] final long [] mine = getBits () ; final long [] theirs = other . getBits () ; final int limit = Integer . min ( mine . length , theirs . length ) ;
for ( int i = 0 ; i < small . length ; i ++ ) { MST[rv.ABSMutator]MSP[N] count += Long . bitCount ( operation . applyAsLong ( small [ i ] , big [ i ] ) ) ; }
int count = 0 ; for ( final long bits : getBits () ) { count += Long . bitCount ( bits ) ; MST[rv.ABSMutator]MSP[S] } return count ; } @Override public boolean contains ( final BloomFilter other ) { verifyShape ( other ) ;
if ( ( buff [ buffIdx ] & buffOffset ) == 0 ) { return false ; } } return true ; } @Override public final Shape getShape () { return shape ; } public final boolean isFull () { return cardinality () == getShape () . getNumberOfBits () ; MST[rv.CRCR1Mutator]MSP[N]
for ( int i = 0 ; i < small . length ; i ++ ) { count += Long . bitCount ( operation . applyAsLong ( small [ i ] , big [ i ] ) ) ; MST[rv.UOI4Mutator]MSP[N] }
if ( shape . getHashFunctionIdentity () . getSignature () != hasher . getHashFunctionIdentity () . getSignature () ) { MST[NonVoidMethodCallMutator]MSP[N] throw new IllegalArgumentException ( String . format ( lr_1 , HashFunctionIdentity . asCommonString ( hasher . getHashFunctionIdentity () ) , shape . toString () ) ) ; } }
int count = 0 ; for ( final long bits : getBits () ) { count += Long . bitCount ( bits ) ; MST[rv.AOD1Mutator]MSP[N] } return count ; } @Override public boolean contains ( final BloomFilter other ) { verifyShape ( other ) ;
for ( int i = 0 ; i < small . length ; i ++ ) { MST[rv.CRCR1Mutator]MSP[N] count += Long . bitCount ( operation . applyAsLong ( small [ i ] , big [ i ] ) ) ; }
if ( ( buff [ buffIdx ] & buffOffset ) == 0 ) { return false ; } } return true ; } @Override public final Shape getShape () { return shape ; } public final boolean isFull () { return cardinality () == getShape () . getNumberOfBits () ; MST[rv.CRCR5Mutator]MSP[N]
throw new IllegalArgumentException ( String . format ( lr_2 , shape , this . shape ) ) ; } } @Override public int xorCardinality ( final BloomFilter other ) { return opCardinality ( other , ( a , b ) -> a ^ b ) ; MST[rv.ABSMutator]MSP[N] }
while ( iter . hasNext () ) { final int idx = iter . nextInt () ; BloomFilterIndexer . checkPositive ( idx ) ; final int buffIdx = BloomFilterIndexer . getLongIndex ( idx ) ; final long buffOffset = BloomFilterIndexer . getLongBit ( idx ) ; MST[rv.ABSMutator]MSP[S]
} @Override public int orCardinality ( final BloomFilter other ) { return opCardinality ( other , ( a , b ) -> a | b ) ; MST[rv.OBBN2Mutator]MSP[N] } protected void verifyHasher ( final Hasher hasher ) {
if ( ( buff [ buffIdx ] & buffOffset ) == 0 ) { MST[rv.UOI3Mutator]MSP[S] return false ; } } return true ; } @Override public final Shape getShape () { return shape ; } public final boolean isFull () { return cardinality () == getShape () . getNumberOfBits () ;
for ( int i = small . length ; i < big . length ; i ++ ) { count += Long . bitCount ( big [ i ] ) ; MST[rv.UOI3Mutator]MSP[N] } return count ; }
if ( shape . getHashFunctionIdentity () . getSignature () != hasher . getHashFunctionIdentity () . getSignature () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] throw new IllegalArgumentException ( String . format ( lr_1 , HashFunctionIdentity . asCommonString ( hasher . getHashFunctionIdentity () ) , shape . toString () ) ) ; } }
for ( int i = small . length ; i < big . length ; i ++ ) { count += Long . bitCount ( big [ i ] ) ; } return count ; MST[ReturnValsMutator]MSP[N] }
while ( iter . hasNext () ) { final int idx = iter . nextInt () ; BloomFilterIndexer . checkPositive ( idx ) ; final int buffIdx = BloomFilterIndexer . getLongIndex ( idx ) ; final long buffOffset = BloomFilterIndexer . getLongBit ( idx ) ; MST[rv.UOI1Mutator]MSP[N]
int count = 0 ; for ( int i = 0 ; i < limit ; i ++ ) { MST[NegateConditionalsMutator]MSP[N] count += Long . bitCount ( mine [ i ] & theirs [ i ] ) ; } return count ; } @Override public int cardinality () {
throw new IllegalArgumentException ( String . format ( lr_2 , shape , this . shape ) ) ; } } @Override public int xorCardinality ( final BloomFilter other ) { return opCardinality ( other , ( a , b ) -> a ^ b ) ; MST[ReturnValsMutator]MSP[N] }
int count = 0 ; for ( int i = 0 ; i < limit ; i ++ ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] count += Long . bitCount ( mine [ i ] & theirs [ i ] ) ; } return count ; } @Override public int cardinality () {
@Override public int andCardinality ( final BloomFilter other ) { verifyShape ( other ) ; final long [] mine = getBits () ; final long [] theirs = other . getBits () ; final int limit = Integer . min ( mine . length , theirs . length ) ; MST[NonVoidMethodCallMutator]MSP[N]
int count = 0 ; for ( final long bits : getBits () ) { MST[rv.ABSMutator]MSP[S] count += Long . bitCount ( bits ) ; } return count ; } @Override public boolean contains ( final BloomFilter other ) { verifyShape ( other ) ;
int count = 0 ; for ( int i = 0 ; i < limit ; i ++ ) { count += Long . bitCount ( mine [ i ] & theirs [ i ] ) ; MST[rv.UOI3Mutator]MSP[N] } return count ; } @Override public int cardinality () {
int count = 0 ; for ( int i = 0 ; i < limit ; i ++ ) { count += Long . bitCount ( mine [ i ] & theirs [ i ] ) ; MST[rv.UOI1Mutator]MSP[N] } return count ; } @Override public int cardinality () {
if ( ( buff [ buffIdx ] & buffOffset ) == 0 ) { MST[rv.ROR2Mutator]MSP[S] return false ; } } return true ; } @Override public final Shape getShape () { return shape ; } public final boolean isFull () { return cardinality () == getShape () . getNumberOfBits () ;
if ( ( buff [ buffIdx ] & buffOffset ) == 0 ) { return false ; } } return true ; } @Override public final Shape getShape () { return shape ; } public final boolean isFull () { return cardinality () == getShape () . getNumberOfBits () ; MST[InlineConstantMutator]MSP[N]
throw new IllegalArgumentException ( String . format ( lr_2 , shape , this . shape ) ) ; } } @Override public int xorCardinality ( final BloomFilter other ) { return opCardinality ( other , ( a , b ) -> a ^ b ) ; MST[rv.UOI4Mutator]MSP[N] }
for ( int i = 0 ; i < small . length ; i ++ ) { MST[rv.UOI2Mutator]MSP[N] count += Long . bitCount ( operation . applyAsLong ( small [ i ] , big [ i ] ) ) ; }
while ( iter . hasNext () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] final int idx = iter . nextInt () ; BloomFilterIndexer . checkPositive ( idx ) ; final int buffIdx = BloomFilterIndexer . getLongIndex ( idx ) ; final long buffOffset = BloomFilterIndexer . getLongBit ( idx ) ;
if ( ( buff [ buffIdx ] & buffOffset ) == 0 ) { MST[rv.ROR4Mutator]MSP[S] return false ; } } return true ; } @Override public final Shape getShape () { return shape ; } public final boolean isFull () { return cardinality () == getShape () . getNumberOfBits () ;
int count = 0 ; for ( final long bits : getBits () ) { count += Long . bitCount ( bits ) ; } return count ; MST[rv.UOI4Mutator]MSP[N] } @Override public boolean contains ( final BloomFilter other ) { verifyShape ( other ) ;
if ( ( buff [ buffIdx ] & buffOffset ) == 0 ) { return false ; } } return true ; } @Override public final Shape getShape () { return shape ; } public final boolean isFull () { return cardinality () == getShape () . getNumberOfBits () ; MST[rv.ROR2Mutator]MSP[N]
int count = 0 ; for ( int i = 0 ; i < limit ; i ++ ) { count += Long . bitCount ( mine [ i ] & theirs [ i ] ) ; MST[rv.UOI4Mutator]MSP[N] } return count ; } @Override public int cardinality () {
for ( int i = 0 ; i < small . length ; i ++ ) { MST[IncrementsMutator]MSP[N] count += Long . bitCount ( operation . applyAsLong ( small [ i ] , big [ i ] ) ) ; }
int count = 0 ; for ( int i = 0 ; i < limit ; i ++ ) { count += Long . bitCount ( mine [ i ] & theirs [ i ] ) ; } return count ; MST[rv.UOI3Mutator]MSP[N] } @Override public int cardinality () {
for ( int i = 0 ; i < small . length ; i ++ ) { count += Long . bitCount ( operation . applyAsLong ( small [ i ] , big [ i ] ) ) ; MST[rv.UOI1Mutator]MSP[N] }
int count = 0 ; for ( final long bits : getBits () ) { MST[rv.UOI1Mutator]MSP[N] count += Long . bitCount ( bits ) ; } return count ; } @Override public boolean contains ( final BloomFilter other ) { verifyShape ( other ) ;
return other . cardinality () == andCardinality ( other ) ; MST[rv.ROR2Mutator]MSP[S] } @Override public boolean contains ( final Hasher hasher ) { verifyHasher ( hasher ) ; final long [] buff = getBits () ; final OfInt iter = hasher . getBits ( shape ) ;
int count = 0 ; for ( final long bits : getBits () ) { MST[rv.UOI4Mutator]MSP[N] count += Long . bitCount ( bits ) ; } return count ; } @Override public boolean contains ( final BloomFilter other ) { verifyShape ( other ) ;
int count = 0 ; for ( final long bits : getBits () ) { MST[rv.UOI3Mutator]MSP[N] count += Long . bitCount ( bits ) ; } return count ; } @Override public boolean contains ( final BloomFilter other ) { verifyShape ( other ) ;
return other . cardinality () == andCardinality ( other ) ; MST[InlineConstantMutator]MSP[S] } @Override public boolean contains ( final Hasher hasher ) { verifyHasher ( hasher ) ; final long [] buff = getBits () ; final OfInt iter = hasher . getBits ( shape ) ;
while ( iter . hasNext () ) { MST[rv.ROR3Mutator]MSP[S] final int idx = iter . nextInt () ; BloomFilterIndexer . checkPositive ( idx ) ; final int buffIdx = BloomFilterIndexer . getLongIndex ( idx ) ; final long buffOffset = BloomFilterIndexer . getLongBit ( idx ) ;
while ( iter . hasNext () ) { final int idx = iter . nextInt () ; BloomFilterIndexer . checkPositive ( idx ) ; final int buffIdx = BloomFilterIndexer . getLongIndex ( idx ) ; MST[rv.UOI1Mutator]MSP[N] final long buffOffset = BloomFilterIndexer . getLongBit ( idx ) ;
while ( iter . hasNext () ) { MST[rv.ROR5Mutator]MSP[S] final int idx = iter . nextInt () ; BloomFilterIndexer . checkPositive ( idx ) ; final int buffIdx = BloomFilterIndexer . getLongIndex ( idx ) ; final long buffOffset = BloomFilterIndexer . getLongBit ( idx ) ;
while ( iter . hasNext () ) { final int idx = iter . nextInt () ; BloomFilterIndexer . checkPositive ( idx ) ; MST[rv.ABSMutator]MSP[S] final int buffIdx = BloomFilterIndexer . getLongIndex ( idx ) ; final long buffOffset = BloomFilterIndexer . getLongBit ( idx ) ;
int count = 0 ; for ( final long bits : getBits () ) { count += Long . bitCount ( bits ) ; } return count ; MST[rv.ABSMutator]MSP[N] } @Override public boolean contains ( final BloomFilter other ) { verifyShape ( other ) ;
if ( mine . length > theirs . length ) { big = mine ; small = theirs ; } else { small = mine ; big = theirs ; } int count = 0 ; MST[rv.CRCR6Mutator]MSP[N]
int count = 0 ; for ( int i = 0 ; i < limit ; i ++ ) { count += Long . bitCount ( mine [ i ] & theirs [ i ] ) ; MST[rv.ABSMutator]MSP[S] } return count ; } @Override public int cardinality () {
while ( iter . hasNext () ) { final int idx = iter . nextInt () ; BloomFilterIndexer . checkPositive ( idx ) ; final int buffIdx = BloomFilterIndexer . getLongIndex ( idx ) ; final long buffOffset = BloomFilterIndexer . getLongBit ( idx ) ; MST[NonVoidMethodCallMutator]MSP[S]
if ( ( buff [ buffIdx ] & buffOffset ) == 0 ) { MST[rv.UOI4Mutator]MSP[S] return false ; } } return true ; } @Override public final Shape getShape () { return shape ; } public final boolean isFull () { return cardinality () == getShape () . getNumberOfBits () ;
if ( ( buff [ buffIdx ] & buffOffset ) == 0 ) { return false ; } } return true ; } @Override public final Shape getShape () { return shape ; MST[ReturnValsMutator]MSP[N] } public final boolean isFull () { return cardinality () == getShape () . getNumberOfBits () ;
throw new IllegalArgumentException ( String . format ( lr_2 , shape , this . shape ) ) ; } } @Override public int xorCardinality ( final BloomFilter other ) { return opCardinality ( other , ( a , b ) -> a ^ b ) ; MST[NonVoidMethodCallMutator]MSP[N] }
for ( int i = small . length ; i < big . length ; i ++ ) { MST[rv.ROR5Mutator]MSP[N] count += Long . bitCount ( big [ i ] ) ; } return count ; }
while ( iter . hasNext () ) { final int idx = iter . nextInt () ; BloomFilterIndexer . checkPositive ( idx ) ; final int buffIdx = BloomFilterIndexer . getLongIndex ( idx ) ; final long buffOffset = BloomFilterIndexer . getLongBit ( idx ) ; MST[rv.UOI2Mutator]MSP[N]
if ( ( buff [ buffIdx ] & buffOffset ) == 0 ) { MST[rv.ABSMutator]MSP[S] return false ; } } return true ; } @Override public final Shape getShape () { return shape ; } public final boolean isFull () { return cardinality () == getShape () . getNumberOfBits () ;
for ( int i = small . length ; i < big . length ; i ++ ) { count += Long . bitCount ( big [ i ] ) ; MST[rv.ABSMutator]MSP[N] } return count ; }
int count = 0 ; for ( int i = 0 ; i < limit ; i ++ ) { count += Long . bitCount ( mine [ i ] & theirs [ i ] ) ; MST[rv.UOI4Mutator]MSP[N] } return count ; } @Override public int cardinality () {
int count = 0 ; for ( int i = 0 ; i < limit ; i ++ ) { count += Long . bitCount ( mine [ i ] & theirs [ i ] ) ; MST[rv.UOI3Mutator]MSP[S] } return count ; } @Override public int cardinality () {
throw new IllegalArgumentException ( String . format ( lr_2 , shape , this . shape ) ) ; MST[InlineConstantMutator]MSP[N] } } @Override public int xorCardinality ( final BloomFilter other ) { return opCardinality ( other , ( a , b ) -> a ^ b ) ; }
private int opCardinality ( final BloomFilter other , LongBinaryOperator operation ) { verifyShape ( other ) ; MST[VoidMethodCallMutator]MSP[N] final long [] mine = getBits () ; final long [] theirs = other . getBits () ; long [] small ; long [] big ;
for ( int i = small . length ; i < big . length ; i ++ ) { count += Long . bitCount ( big [ i ] ) ; } return count ; MST[rv.UOI2Mutator]MSP[N] }
if ( ( buff [ buffIdx ] & buffOffset ) == 0 ) { MST[rv.CRCR1Mutator]MSP[S] return false ; } } return true ; } @Override public final Shape getShape () { return shape ; } public final boolean isFull () { return cardinality () == getShape () . getNumberOfBits () ;
int count = 0 ; for ( int i = 0 ; i < limit ; i ++ ) { count += Long . bitCount ( mine [ i ] & theirs [ i ] ) ; MST[rv.AOR3Mutator]MSP[N] } return count ; } @Override public int cardinality () {
for ( int i = 0 ; i < small . length ; i ++ ) { count += Long . bitCount ( operation . applyAsLong ( small [ i ] , big [ i ] ) ) ; MST[rv.UOI1Mutator]MSP[N] }
return other . cardinality () == andCardinality ( other ) ; } @Override public boolean contains ( final Hasher hasher ) { verifyHasher ( hasher ) ; final long [] buff = getBits () ; MST[NonVoidMethodCallMutator]MSP[S] final OfInt iter = hasher . getBits ( shape ) ;
int count = 0 ; for ( final long bits : getBits () ) { MST[rv.UOI1Mutator]MSP[N] count += Long . bitCount ( bits ) ; } return count ; } @Override public boolean contains ( final BloomFilter other ) { verifyShape ( other ) ;
int count = 0 ; for ( final long bits : getBits () ) { MST[rv.UOI4Mutator]MSP[N] count += Long . bitCount ( bits ) ; } return count ; } @Override public boolean contains ( final BloomFilter other ) { verifyShape ( other ) ;
for ( int i = 0 ; i < small . length ; i ++ ) { count += Long . bitCount ( operation . applyAsLong ( small [ i ] , big [ i ] ) ) ; MST[rv.ABSMutator]MSP[S] }
if ( ( buff [ buffIdx ] & buffOffset ) == 0 ) { MST[rv.OBBN2Mutator]MSP[S] return false ; } } return true ; } @Override public final Shape getShape () { return shape ; } public final boolean isFull () { return cardinality () == getShape () . getNumberOfBits () ;
throw new IllegalArgumentException ( String . format ( lr_2 , shape , this . shape ) ) ; MST[rv.CRCR1Mutator]MSP[S] } } @Override public int xorCardinality ( final BloomFilter other ) { return opCardinality ( other , ( a , b ) -> a ^ b ) ; }
if ( shape . getHashFunctionIdentity () . getSignature () != hasher . getHashFunctionIdentity () . getSignature () ) { throw new IllegalArgumentException ( String . format ( lr_1 , HashFunctionIdentity . asCommonString ( hasher . getHashFunctionIdentity () ) , shape . toString () ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } }
for ( int i = small . length ; i < big . length ; i ++ ) { MST[rv.UOI1Mutator]MSP[N] count += Long . bitCount ( big [ i ] ) ; } return count ; }
while ( iter . hasNext () ) { final int idx = iter . nextInt () ; BloomFilterIndexer . checkPositive ( idx ) ; MST[rv.UOI4Mutator]MSP[N] final int buffIdx = BloomFilterIndexer . getLongIndex ( idx ) ; final long buffOffset = BloomFilterIndexer . getLongBit ( idx ) ;
for ( int i = small . length ; i < big . length ; i ++ ) { MST[NegateConditionalsMutator]MSP[N] count += Long . bitCount ( big [ i ] ) ; } return count ; }
} @Override public int orCardinality ( final BloomFilter other ) { return opCardinality ( other , ( a , b ) -> a | b ) ; MST[rv.UOI1Mutator]MSP[N] } protected void verifyHasher ( final Hasher hasher ) {
if ( shape . getHashFunctionIdentity () . getSignature () != hasher . getHashFunctionIdentity () . getSignature () ) { throw new IllegalArgumentException ( String . format ( lr_1 , HashFunctionIdentity . asCommonString ( hasher . getHashFunctionIdentity () ) , MST[rv.CRCR6Mutator]MSP[N] shape . toString () ) ) ; } }
if ( shape . getHashFunctionIdentity () . getSignature () != hasher . getHashFunctionIdentity () . getSignature () ) { throw new IllegalArgumentException ( String . format ( lr_1 , HashFunctionIdentity . asCommonString ( hasher . getHashFunctionIdentity () ) , MST[rv.CRCR2Mutator]MSP[N] shape . toString () ) ) ; } }
return other . cardinality () == andCardinality ( other ) ; MST[rv.CRCR6Mutator]MSP[S] } @Override public boolean contains ( final Hasher hasher ) { verifyHasher ( hasher ) ; final long [] buff = getBits () ; final OfInt iter = hasher . getBits ( shape ) ;
for ( int i = small . length ; i < big . length ; i ++ ) { count += Long . bitCount ( big [ i ] ) ; MST[rv.AOD1Mutator]MSP[N] } return count ; }
for ( int i = small . length ; i < big . length ; i ++ ) { count += Long . bitCount ( big [ i ] ) ; MST[rv.UOI4Mutator]MSP[N] } return count ; }
if ( ( buff [ buffIdx ] & buffOffset ) == 0 ) { MST[rv.UOI4Mutator]MSP[N] return false ; } } return true ; } @Override public final Shape getShape () { return shape ; } public final boolean isFull () { return cardinality () == getShape () . getNumberOfBits () ;
for ( int i = 0 ; i < small . length ; i ++ ) { MST[rv.CRCR3Mutator]MSP[N] count += Long . bitCount ( operation . applyAsLong ( small [ i ] , big [ i ] ) ) ; }
for ( int i = small . length ; i < big . length ; i ++ ) { count += Long . bitCount ( big [ i ] ) ; MST[rv.ABSMutator]MSP[N] } return count ; }
for ( int i = small . length ; i < big . length ; i ++ ) { count += Long . bitCount ( big [ i ] ) ; MST[rv.UOI3Mutator]MSP[N] } return count ; }
if ( ( buff [ buffIdx ] & buffOffset ) == 0 ) { MST[rv.ABSMutator]MSP[N] return false ; } } return true ; } @Override public final Shape getShape () { return shape ; } public final boolean isFull () { return cardinality () == getShape () . getNumberOfBits () ;
for ( int i = 0 ; i < small . length ; i ++ ) { count += Long . bitCount ( operation . applyAsLong ( small [ i ] , big [ i ] ) ) ; MST[rv.AOR2Mutator]MSP[N] }
int count = 0 ; for ( int i = 0 ; i < limit ; i ++ ) { count += Long . bitCount ( mine [ i ] & theirs [ i ] ) ; MST[rv.UOI2Mutator]MSP[N] } return count ; } @Override public int cardinality () {
int count = 0 ; for ( int i = 0 ; i < limit ; i ++ ) { count += Long . bitCount ( mine [ i ] & theirs [ i ] ) ; MST[rv.UOI1Mutator]MSP[N] } return count ; } @Override public int cardinality () {
return other . cardinality () == andCardinality ( other ) ; MST[rv.CRCR3Mutator]MSP[S] } @Override public boolean contains ( final Hasher hasher ) { verifyHasher ( hasher ) ; final long [] buff = getBits () ; final OfInt iter = hasher . getBits ( shape ) ;
if ( ( buff [ buffIdx ] & buffOffset ) == 0 ) { return false ; MST[InlineConstantMutator]MSP[S] } } return true ; } @Override public final Shape getShape () { return shape ; } public final boolean isFull () { return cardinality () == getShape () . getNumberOfBits () ;
int count = 0 ; for ( int i = 0 ; i < limit ; i ++ ) { MST[rv.CRCR5Mutator]MSP[N] count += Long . bitCount ( mine [ i ] & theirs [ i ] ) ; } return count ; } @Override public int cardinality () {
if ( ( buff [ buffIdx ] & buffOffset ) == 0 ) { return false ; } } return true ; } @Override public final Shape getShape () { return shape ; } public final boolean isFull () { return cardinality () == getShape () . getNumberOfBits () ; MST[rv.CRCR6Mutator]MSP[N]
for ( int i = 0 ; i < small . length ; i ++ ) { count += Long . bitCount ( operation . applyAsLong ( small [ i ] , big [ i ] ) ) ; MST[rv.UOI4Mutator]MSP[N] }
protected void verifyShape ( final BloomFilter other ) { verifyShape ( other . getShape () ) ; } protected void verifyShape ( final Shape shape ) { if ( ! this . shape . equals ( shape ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S]
throw new IllegalArgumentException ( String . format ( lr_2 , shape , this . shape ) ) ; MST[rv.CRCR3Mutator]MSP[S] } } @Override public int xorCardinality ( final BloomFilter other ) { return opCardinality ( other , ( a , b ) -> a ^ b ) ; }
if ( mine . length > theirs . length ) { MST[ConditionalsBoundaryMutator]MSP[N] big = mine ; small = theirs ; } else { small = mine ; big = theirs ; } int count = 0 ;
} @Override public int orCardinality ( final BloomFilter other ) { return opCardinality ( other , ( a , b ) -> a | b ) ; MST[rv.UOI2Mutator]MSP[N] } protected void verifyHasher ( final Hasher hasher ) {
int count = 0 ; for ( final long bits : getBits () ) { count += Long . bitCount ( bits ) ; } return count ; MST[PrimitiveReturnsMutator]MSP[N] } @Override public boolean contains ( final BloomFilter other ) { verifyShape ( other ) ;
} @Override public int orCardinality ( final BloomFilter other ) { return opCardinality ( other , ( a , b ) -> a | b ) ; MST[rv.UOI1Mutator]MSP[N] } protected void verifyHasher ( final Hasher hasher ) {
for ( int i = 0 ; i < small . length ; i ++ ) { count += Long . bitCount ( operation . applyAsLong ( small [ i ] , big [ i ] ) ) ; MST[NonVoidMethodCallMutator]MSP[N] }
} @Override public int orCardinality ( final BloomFilter other ) { return opCardinality ( other , ( a , b ) -> a | b ) ; MST[rv.OBBN3Mutator]MSP[S] } protected void verifyHasher ( final Hasher hasher ) {
throw new IllegalArgumentException ( String . format ( lr_2 , shape , this . shape ) ) ; MST[ArgumentPropagationMutator]MSP[N] } } @Override public int xorCardinality ( final BloomFilter other ) { return opCardinality ( other , ( a , b ) -> a ^ b ) ; }
int count = 0 ; for ( int i = 0 ; i < limit ; i ++ ) { MST[rv.ROR3Mutator]MSP[N] count += Long . bitCount ( mine [ i ] & theirs [ i ] ) ; } return count ; } @Override public int cardinality () {
for ( int i = 0 ; i < small . length ; i ++ ) { count += Long . bitCount ( operation . applyAsLong ( small [ i ] , big [ i ] ) ) ; MST[MathMutator]MSP[N] }
if ( ( buff [ buffIdx ] & buffOffset ) == 0 ) { MST[rv.UOI4Mutator]MSP[S] return false ; } } return true ; } @Override public final Shape getShape () { return shape ; } public final boolean isFull () { return cardinality () == getShape () . getNumberOfBits () ;
for ( int i = 0 ; i < small . length ; i ++ ) { MST[ConditionalsBoundaryMutator]MSP[N] count += Long . bitCount ( operation . applyAsLong ( small [ i ] , big [ i ] ) ) ; }
for ( int i = small . length ; i < big . length ; i ++ ) { count += Long . bitCount ( big [ i ] ) ; } return count ; MST[rv.UOI3Mutator]MSP[N] }
int count = 0 ; for ( int i = 0 ; i < limit ; i ++ ) { count += Long . bitCount ( mine [ i ] & theirs [ i ] ) ; MST[rv.UOI3Mutator]MSP[N] } return count ; } @Override public int cardinality () {
int count = 0 ; for ( int i = 0 ; i < limit ; i ++ ) { count += Long . bitCount ( mine [ i ] & theirs [ i ] ) ; MST[rv.AOR4Mutator]MSP[N] } return count ; } @Override public int cardinality () {
while ( iter . hasNext () ) { MST[NegateConditionalsMutator]MSP[S] final int idx = iter . nextInt () ; BloomFilterIndexer . checkPositive ( idx ) ; final int buffIdx = BloomFilterIndexer . getLongIndex ( idx ) ; final long buffOffset = BloomFilterIndexer . getLongBit ( idx ) ;
} @Override public int orCardinality ( final BloomFilter other ) { return opCardinality ( other , ( a , b ) -> a | b ) ; MST[NonVoidMethodCallMutator]MSP[N] } protected void verifyHasher ( final Hasher hasher ) {
if ( shape . getHashFunctionIdentity () . getSignature () != hasher . getHashFunctionIdentity () . getSignature () ) { MST[rv.ROR2Mutator]MSP[N] throw new IllegalArgumentException ( String . format ( lr_1 , HashFunctionIdentity . asCommonString ( hasher . getHashFunctionIdentity () ) , shape . toString () ) ) ; } }
int count = 0 ; for ( final long bits : getBits () ) { count += Long . bitCount ( bits ) ; MST[rv.AOD2Mutator]MSP[S] } return count ; } @Override public boolean contains ( final BloomFilter other ) { verifyShape ( other ) ;
int count = 0 ; for ( final long bits : getBits () ) { MST[rv.UOI2Mutator]MSP[N] count += Long . bitCount ( bits ) ; } return count ; } @Override public boolean contains ( final BloomFilter other ) { verifyShape ( other ) ;
int count = 0 ; for ( final long bits : getBits () ) { count += Long . bitCount ( bits ) ; } return count ; } @Override public boolean contains ( final BloomFilter other ) { verifyShape ( other ) ; MST[VoidMethodCallMutator]MSP[N]
throw new IllegalArgumentException ( String . format ( lr_2 , shape , this . shape ) ) ; MST[rv.CRCR4Mutator]MSP[S] } } @Override public int xorCardinality ( final BloomFilter other ) { return opCardinality ( other , ( a , b ) -> a ^ b ) ; }
int count = 0 ; for ( final long bits : getBits () ) { MST[rv.ABSMutator]MSP[N] count += Long . bitCount ( bits ) ; } return count ; } @Override public boolean contains ( final BloomFilter other ) { verifyShape ( other ) ;
int count = 0 ; for ( final long bits : getBits () ) { MST[rv.UOI3Mutator]MSP[N] count += Long . bitCount ( bits ) ; } return count ; } @Override public boolean contains ( final BloomFilter other ) { verifyShape ( other ) ;
if ( shape . getHashFunctionIdentity () . getSignature () != hasher . getHashFunctionIdentity () . getSignature () ) { throw new IllegalArgumentException ( MST[rv.CRCR3Mutator]MSP[S] String . format ( lr_1 , HashFunctionIdentity . asCommonString ( hasher . getHashFunctionIdentity () ) , shape . toString () ) ) ; } }
if ( mine . length > theirs . length ) { big = mine ; small = theirs ; } else { small = mine ; big = theirs ; } int count = 0 ; MST[rv.CRCR1Mutator]MSP[N]
for ( int i = small . length ; i < big . length ; i ++ ) { count += Long . bitCount ( big [ i ] ) ; } return count ; MST[PrimitiveReturnsMutator]MSP[N] }
while ( iter . hasNext () ) { MST[rv.ROR4Mutator]MSP[S] final int idx = iter . nextInt () ; BloomFilterIndexer . checkPositive ( idx ) ; final int buffIdx = BloomFilterIndexer . getLongIndex ( idx ) ; final long buffOffset = BloomFilterIndexer . getLongBit ( idx ) ;
for ( int i = small . length ; i < big . length ; i ++ ) { count += Long . bitCount ( big [ i ] ) ; MST[rv.ABSMutator]MSP[N] } return count ; }
@Override public int andCardinality ( final BloomFilter other ) { verifyShape ( other ) ; final long [] mine = getBits () ; MST[NonVoidMethodCallMutator]MSP[N] final long [] theirs = other . getBits () ; final int limit = Integer . min ( mine . length , theirs . length ) ;
int count = 0 ; for ( int i = 0 ; i < limit ; i ++ ) { count += Long . bitCount ( mine [ i ] & theirs [ i ] ) ; MST[rv.ABSMutator]MSP[S] } return count ; } @Override public int cardinality () {
if ( ( buff [ buffIdx ] & buffOffset ) == 0 ) { return false ; } } return true ; MST[rv.CRCR6Mutator]MSP[S] } @Override public final Shape getShape () { return shape ; } public final boolean isFull () { return cardinality () == getShape () . getNumberOfBits () ;
if ( mine . length > theirs . length ) { MST[rv.ROR5Mutator]MSP[N] big = mine ; small = theirs ; } else { small = mine ; big = theirs ; } int count = 0 ;
} @Override public int orCardinality ( final BloomFilter other ) { return opCardinality ( other , ( a , b ) -> a | b ) ; MST[MathMutator]MSP[N] } protected void verifyHasher ( final Hasher hasher ) {
int count = 0 ; for ( int i = 0 ; i < limit ; i ++ ) { count += Long . bitCount ( mine [ i ] & theirs [ i ] ) ; MST[rv.AOD1Mutator]MSP[N] } return count ; } @Override public int cardinality () {
if ( shape . getHashFunctionIdentity () . getSignature () != hasher . getHashFunctionIdentity () . getSignature () ) { throw new IllegalArgumentException ( MST[InlineConstantMutator]MSP[N] String . format ( lr_1 , HashFunctionIdentity . asCommonString ( hasher . getHashFunctionIdentity () ) , shape . toString () ) ) ; } }
