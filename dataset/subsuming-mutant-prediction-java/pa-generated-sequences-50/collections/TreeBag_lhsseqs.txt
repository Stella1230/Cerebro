@Override public boolean add ( final E object ) { if ( comparator () == null && ! ( object instanceof Comparable ) ) { Objects . requireNonNull ( object , lr_1 ) ; throw new IllegalArgumentException ( lr_2 + object . getClass () + lr_3 + MST[NonVoidMethodCallMutator]MSP[] lr_4 ) ;
@Override public boolean add ( final E object ) { if ( comparator () == null && ! ( object instanceof Comparable ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] Objects . requireNonNull ( object , lr_1 ) ; throw new IllegalArgumentException ( lr_2 + object . getClass () + lr_3 + lr_4 ) ;
out . defaultWriteObject () ; out . writeObject ( comparator () ) ; super . doWriteObject ( out ) ; MST[VoidMethodCallMutator]MSP[] } private void readObject ( final ObjectInputStream in ) throws IOException , ClassNotFoundException { in . defaultReadObject () ; @SuppressWarnings ( lr_5 )
} return super . add ( object ) ; } @Override public E first () { return getMap () . firstKey () ; } @Override public E last () { return getMap () . lastKey () ; MST[NonVoidMethodCallMutator]MSP[] } @Override public Comparator < ? super E > comparator () {
@Override public boolean add ( final E object ) { if ( comparator () == null && ! ( object instanceof Comparable ) ) { Objects . requireNonNull ( object , lr_1 ) ; throw new IllegalArgumentException ( lr_2 + object . getClass () + lr_3 + MST[NonVoidMethodCallMutator]MSP[] lr_4 ) ;
@Override public boolean add ( final E object ) { if ( comparator () == null && ! ( object instanceof Comparable ) ) { Objects . requireNonNull ( object , lr_1 ) ; throw new IllegalArgumentException ( lr_2 + object . getClass () + lr_3 + MST[NonVoidMethodCallMutator]MSP[] lr_4 ) ;
@Override public boolean add ( final E object ) { if ( comparator () == null && ! ( object instanceof Comparable ) ) { Objects . requireNonNull ( object , lr_1 ) ; throw new IllegalArgumentException ( lr_2 + object . getClass () + lr_3 + MST[ConstructorCallMutator]MSP[] lr_4 ) ;
@Override public boolean add ( final E object ) { if ( comparator () == null && ! ( object instanceof Comparable ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] Objects . requireNonNull ( object , lr_1 ) ; throw new IllegalArgumentException ( lr_2 + object . getClass () + lr_3 + lr_4 ) ;
} return super . add ( object ) ; MST[BooleanTrueReturnValsMutator]MSP[] } @Override public E first () { return getMap () . firstKey () ; } @Override public E last () { return getMap () . lastKey () ; } @Override public Comparator < ? super E > comparator () {
} return super . add ( object ) ; MST[NonVoidMethodCallMutator]MSP[] } @Override public E first () { return getMap () . firstKey () ; } @Override public E last () { return getMap () . lastKey () ; } @Override public Comparator < ? super E > comparator () {
return getMap () . comparator () ; } @Override protected SortedMap < E , AbstractMapBag . MutableInteger > getMap () { return ( SortedMap < E , AbstractMapBag . MutableInteger > ) super . getMap () ; MST[NullReturnValsMutator]MSP[] } private void writeObject ( final ObjectOutputStream out ) throws IOException {
} return super . add ( object ) ; } @Override public E first () { return getMap () . firstKey () ; MST[NonVoidMethodCallMutator]MSP[] } @Override public E last () { return getMap () . lastKey () ; } @Override public Comparator < ? super E > comparator () {
} return super . add ( object ) ; MST[BooleanFalseReturnValsMutator]MSP[] } @Override public E first () { return getMap () . firstKey () ; } @Override public E last () { return getMap () . lastKey () ; } @Override public Comparator < ? super E > comparator () {
} return super . add ( object ) ; } @Override public E first () { return getMap () . firstKey () ; } @Override public E last () { return getMap () . lastKey () ; MST[ReturnValsMutator]MSP[] } @Override public Comparator < ? super E > comparator () {
return getMap () . comparator () ; } @Override protected SortedMap < E , AbstractMapBag . MutableInteger > getMap () { return ( SortedMap < E , AbstractMapBag . MutableInteger > ) super . getMap () ; MST[ReturnValsMutator]MSP[] } private void writeObject ( final ObjectOutputStream out ) throws IOException {
@Override public boolean add ( final E object ) { if ( comparator () == null && ! ( object instanceof Comparable ) ) { Objects . requireNonNull ( object , lr_1 ) ; throw new IllegalArgumentException ( lr_2 + object . getClass () + lr_3 + MST[experimental.NakedReceiverMutator]MSP[] lr_4 ) ;
@Override public boolean add ( final E object ) { if ( comparator () == null && ! ( object instanceof Comparable ) ) { MST[rv.ROR5Mutator]MSP[] Objects . requireNonNull ( object , lr_1 ) ; throw new IllegalArgumentException ( lr_2 + object . getClass () + lr_3 + lr_4 ) ;
return getMap () . comparator () ; MST[NonVoidMethodCallMutator]MSP[] } @Override protected SortedMap < E , AbstractMapBag . MutableInteger > getMap () { return ( SortedMap < E , AbstractMapBag . MutableInteger > ) super . getMap () ; } private void writeObject ( final ObjectOutputStream out ) throws IOException {
} return super . add ( object ) ; } @Override public E first () { return getMap () . firstKey () ; MST[ReturnValsMutator]MSP[] } @Override public E last () { return getMap () . lastKey () ; } @Override public Comparator < ? super E > comparator () {
@Override public boolean add ( final E object ) { if ( comparator () == null && ! ( object instanceof Comparable ) ) { MST[NegateConditionalsMutator]MSP[] Objects . requireNonNull ( object , lr_1 ) ; throw new IllegalArgumentException ( lr_2 + object . getClass () + lr_3 + lr_4 ) ;
@Override public boolean add ( final E object ) { if ( comparator () == null && ! ( object instanceof Comparable ) ) { MST[rv.ROR3Mutator]MSP[] Objects . requireNonNull ( object , lr_1 ) ; throw new IllegalArgumentException ( lr_2 + object . getClass () + lr_3 + lr_4 ) ;
@Override public boolean add ( final E object ) { if ( comparator () == null && ! ( object instanceof Comparable ) ) { MST[rv.ROR1Mutator]MSP[] Objects . requireNonNull ( object , lr_1 ) ; throw new IllegalArgumentException ( lr_2 + object . getClass () + lr_3 + lr_4 ) ;
out . defaultWriteObject () ; out . writeObject ( comparator () ) ; super . doWriteObject ( out ) ; } private void readObject ( final ObjectInputStream in ) throws IOException , ClassNotFoundException { in . defaultReadObject () ; MST[VoidMethodCallMutator]MSP[] @SuppressWarnings ( lr_5 )
return getMap () . comparator () ; MST[ReturnValsMutator]MSP[] } @Override protected SortedMap < E , AbstractMapBag . MutableInteger > getMap () { return ( SortedMap < E , AbstractMapBag . MutableInteger > ) super . getMap () ; } private void writeObject ( final ObjectOutputStream out ) throws IOException {
@Override public boolean add ( final E object ) { if ( comparator () == null && ! ( object instanceof Comparable ) ) { MST[NonVoidMethodCallMutator]MSP[] Objects . requireNonNull ( object , lr_1 ) ; throw new IllegalArgumentException ( lr_2 + object . getClass () + lr_3 + lr_4 ) ;
final Comparator < ? super E > comp = ( Comparator < ? super E > ) in . readObject () ; MST[NonVoidMethodCallMutator]MSP[] super . doReadObject ( new TreeMap < E , MutableInteger > ( comp ) , in ) ; }
@Override public boolean add ( final E object ) { if ( comparator () == null && ! ( object instanceof Comparable ) ) { Objects . requireNonNull ( object , lr_1 ) ; throw new IllegalArgumentException ( lr_2 + object . getClass () + lr_3 + MST[NonVoidMethodCallMutator]MSP[] lr_4 ) ;
@Override public boolean add ( final E object ) { if ( comparator () == null && ! ( object instanceof Comparable ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] Objects . requireNonNull ( object , lr_1 ) ; throw new IllegalArgumentException ( lr_2 + object . getClass () + lr_3 + lr_4 ) ;
} return super . add ( object ) ; } @Override public E first () { return getMap () . firstKey () ; } @Override public E last () { return getMap () . lastKey () ; MST[NonVoidMethodCallMutator]MSP[] } @Override public Comparator < ? super E > comparator () {
@Override public boolean add ( final E object ) { if ( comparator () == null && ! ( object instanceof Comparable ) ) { Objects . requireNonNull ( object , lr_1 ) ; throw new IllegalArgumentException ( lr_2 + object . getClass () + lr_3 + MST[NonVoidMethodCallMutator]MSP[] lr_4 ) ;
@Override public boolean add ( final E object ) { if ( comparator () == null && ! ( object instanceof Comparable ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] Objects . requireNonNull ( object , lr_1 ) ; throw new IllegalArgumentException ( lr_2 + object . getClass () + lr_3 + lr_4 ) ;
} return super . add ( object ) ; } @Override public E first () { return getMap () . firstKey () ; MST[NonVoidMethodCallMutator]MSP[] } @Override public E last () { return getMap () . lastKey () ; } @Override public Comparator < ? super E > comparator () {
@Override public boolean add ( final E object ) { if ( comparator () == null && ! ( object instanceof Comparable ) ) { Objects . requireNonNull ( object , lr_1 ) ; throw new IllegalArgumentException ( lr_2 + object . getClass () + lr_3 + MST[ConstructorCallMutator]MSP[] lr_4 ) ;
out . defaultWriteObject () ; MST[VoidMethodCallMutator]MSP[] out . writeObject ( comparator () ) ; super . doWriteObject ( out ) ; } private void readObject ( final ObjectInputStream in ) throws IOException , ClassNotFoundException { in . defaultReadObject () ; @SuppressWarnings ( lr_5 )
out . defaultWriteObject () ; out . writeObject ( comparator () ) ; MST[VoidMethodCallMutator]MSP[] super . doWriteObject ( out ) ; } private void readObject ( final ObjectInputStream in ) throws IOException , ClassNotFoundException { in . defaultReadObject () ; @SuppressWarnings ( lr_5 )
out . defaultWriteObject () ; out . writeObject ( comparator () ) ; MST[NonVoidMethodCallMutator]MSP[] super . doWriteObject ( out ) ; } private void readObject ( final ObjectInputStream in ) throws IOException , ClassNotFoundException { in . defaultReadObject () ; @SuppressWarnings ( lr_5 )
} return super . add ( object ) ; } @Override public E first () { return getMap () . firstKey () ; } @Override public E last () { return getMap () . lastKey () ; MST[NullReturnValsMutator]MSP[] } @Override public Comparator < ? super E > comparator () {
final Comparator < ? super E > comp = ( Comparator < ? super E > ) in . readObject () ; super . doReadObject ( new TreeMap < E , MutableInteger > ( comp ) , in ) ; MST[ConstructorCallMutator]MSP[] }
return getMap () . comparator () ; MST[NonVoidMethodCallMutator]MSP[] } @Override protected SortedMap < E , AbstractMapBag . MutableInteger > getMap () { return ( SortedMap < E , AbstractMapBag . MutableInteger > ) super . getMap () ; } private void writeObject ( final ObjectOutputStream out ) throws IOException {
@Override public boolean add ( final E object ) { if ( comparator () == null && ! ( object instanceof Comparable ) ) { MST[rv.ROR4Mutator]MSP[] Objects . requireNonNull ( object , lr_1 ) ; throw new IllegalArgumentException ( lr_2 + object . getClass () + lr_3 + lr_4 ) ;
return getMap () . comparator () ; MST[NullReturnValsMutator]MSP[] } @Override protected SortedMap < E , AbstractMapBag . MutableInteger > getMap () { return ( SortedMap < E , AbstractMapBag . MutableInteger > ) super . getMap () ; } private void writeObject ( final ObjectOutputStream out ) throws IOException {
@Override public boolean add ( final E object ) { if ( comparator () == null && ! ( object instanceof Comparable ) ) { Objects . requireNonNull ( object , lr_1 ) ; throw new IllegalArgumentException ( lr_2 + object . getClass () + lr_3 + MST[experimental.NakedReceiverMutator]MSP[] lr_4 ) ;
@Override public boolean add ( final E object ) { if ( comparator () == null && ! ( object instanceof Comparable ) ) { Objects . requireNonNull ( object , lr_1 ) ; throw new IllegalArgumentException ( lr_2 + object . getClass () + lr_3 + MST[experimental.NakedReceiverMutator]MSP[] lr_4 ) ;
@Override public boolean add ( final E object ) { if ( comparator () == null && ! ( object instanceof Comparable ) ) { MST[NegateConditionalsMutator]MSP[] Objects . requireNonNull ( object , lr_1 ) ; throw new IllegalArgumentException ( lr_2 + object . getClass () + lr_3 + lr_4 ) ;
@Override public boolean add ( final E object ) { if ( comparator () == null && ! ( object instanceof Comparable ) ) { MST[rv.ROR2Mutator]MSP[] Objects . requireNonNull ( object , lr_1 ) ; throw new IllegalArgumentException ( lr_2 + object . getClass () + lr_3 + lr_4 ) ;
@Override public boolean add ( final E object ) { if ( comparator () == null && ! ( object instanceof Comparable ) ) { MST[rv.ROR5Mutator]MSP[] Objects . requireNonNull ( object , lr_1 ) ; throw new IllegalArgumentException ( lr_2 + object . getClass () + lr_3 + lr_4 ) ;
return getMap () . comparator () ; } @Override protected SortedMap < E , AbstractMapBag . MutableInteger > getMap () { return ( SortedMap < E , AbstractMapBag . MutableInteger > ) super . getMap () ; MST[NonVoidMethodCallMutator]MSP[] } private void writeObject ( final ObjectOutputStream out ) throws IOException {
@Override public boolean add ( final E object ) { if ( comparator () == null && ! ( object instanceof Comparable ) ) { Objects . requireNonNull ( object , lr_1 ) ; MST[NonVoidMethodCallMutator]MSP[] throw new IllegalArgumentException ( lr_2 + object . getClass () + lr_3 + lr_4 ) ;
@Override public boolean add ( final E object ) { if ( comparator () == null && ! ( object instanceof Comparable ) ) { Objects . requireNonNull ( object , lr_1 ) ; MST[ArgumentPropagationMutator]MSP[] throw new IllegalArgumentException ( lr_2 + object . getClass () + lr_3 + lr_4 ) ;
} return super . add ( object ) ; MST[ReturnValsMutator]MSP[] } @Override public E first () { return getMap () . firstKey () ; } @Override public E last () { return getMap () . lastKey () ; } @Override public Comparator < ? super E > comparator () {
} return super . add ( object ) ; } @Override public E first () { return getMap () . firstKey () ; MST[NullReturnValsMutator]MSP[] } @Override public E last () { return getMap () . lastKey () ; } @Override public Comparator < ? super E > comparator () {
final Comparator < ? super E > comp = ( Comparator < ? super E > ) in . readObject () ; super . doReadObject ( new TreeMap < E , MutableInteger > ( comp ) , in ) ; MST[VoidMethodCallMutator]MSP[] }
