reuseMapping ( reuse , hashIndex , hashCode , key , value ) ; MST[rv.UOI1Mutator]MSP[N] } else { super . addMapping ( hashIndex , hashCode , key , value ) ; } } else { super . addMapping ( hashIndex , hashCode , key , value ) ; } }
loop = loop . next ; } if ( loop == null ) { throw new IllegalStateException ( MST[experimental.NakedReceiverMutator]MSP[N] lr_12 + data [ removeIndex ] + lr_13 + previous + lr_6 + key + lr_7 + value + lr_8 + size + lr_9 + maxSize + lr_2 ) ; }
} @Override public boolean isFull () { return size >= maxSize ; MST[rv.UOI4Mutator]MSP[N] } @Override public int maxSize () { return maxSize ; } public boolean isScanUntilRemovable () { return scanUntilRemovable ; } @Override public LRUMap < K , V > clone () {
modCount ++ ; removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; MST[rv.ABSMutator]MSP[S] } catch ( final NullPointerException ex ) { throw new IllegalStateException (
lr_14 + entry + lr_15 + ( entry == header ) + lr_6 + key + lr_7 + value + lr_8 + size + lr_9 + maxSize + lr_2 ) ; } } protected boolean removeLRU ( final LinkEntry < K , V > entry ) { return true ; MST[rv.CRCR6Mutator]MSP[N]
lr_14 + entry + lr_15 + ( entry == header ) + lr_6 + key + lr_7 + value + lr_8 + size + lr_9 + maxSize + lr_2 ) ; } } protected boolean removeLRU ( final LinkEntry < K , V > entry ) { return true ; MST[rv.CRCR2Mutator]MSP[N]
lr_4 + header . after + lr_5 + header . before + lr_6 + key + lr_7 + value + lr_8 + size + lr_9 + maxSize + lr_10 ) ; } } else { removeLRUEntry = removeLRU ( reuse ) ; } if ( removeLRUEntry ) { MST[rv.UOI4Mutator]MSP[N]
return ( LRUMap < K , V > ) super . clone () ; } private void writeObject ( final ObjectOutputStream out ) throws IOException { out . defaultWriteObject () ; MST[VoidMethodCallMutator]MSP[S] doWriteObject ( out ) ; } private void readObject ( final ObjectInputStream in ) throws IOException , ClassNotFoundException {
throw new IllegalStateException ( lr_3 + lr_2 ) ; } } @Override protected void updateEntry ( final HashEntry < K , V > entry , final V newValue ) { moveToMRU ( ( LinkEntry < K , V > ) entry ) ; entry . setValue ( newValue ) ; MST[ArgumentPropagationMutator]MSP[N]
} @Override public boolean isFull () { return size >= maxSize ; } @Override public int maxSize () { return maxSize ; MST[rv.UOI4Mutator]MSP[N] } public boolean isScanUntilRemovable () { return scanUntilRemovable ; } @Override public LRUMap < K , V > clone () {
protected void reuseMapping ( final LinkEntry < K , V > entry , final int hashIndex , final int hashCode , final K key , final V value ) { try { final int removeIndex = hashIndex ( entry . hashCode , data . length ) ; MST[rv.ABSMutator]MSP[S]
} @Override public boolean isFull () { return size >= maxSize ; } @Override public int maxSize () { return maxSize ; } public boolean isScanUntilRemovable () { return scanUntilRemovable ; MST[BooleanTrueReturnValsMutator]MSP[N] } @Override public LRUMap < K , V > clone () {
modCount ++ ; removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException ( MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
modCount ++ ; removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException ( MST[NonVoidMethodCallMutator]MSP[S]
if ( scanUntilRemovable ) { while ( reuse != header && reuse != null ) { if ( removeLRU ( reuse ) ) { removeLRUEntry = true ; MST[rv.CRCR3Mutator]MSP[N] break; } reuse = reuse . after ; } if ( reuse == null ) { throw new IllegalStateException (
modCount ++ ; removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException ( MST[NonVoidMethodCallMutator]MSP[S]
modCount ++ ; removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException ( MST[rv.UOI1Mutator]MSP[N]
entry . after . before = entry . before ; entry . after = header ; entry . before = header . before ; header . before . after = entry ; header . before = entry ; } else if ( entry == header ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S]
modCount ++ ; removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException ( MST[rv.UOI2Mutator]MSP[N]
modCount ++ ; removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException ( MST[NonVoidMethodCallMutator]MSP[S]
final HashEntry < K , V > [] tmp = data ; HashEntry < K , V > loop = tmp [ removeIndex ] ; HashEntry < K , V > previous = null ; while ( loop != entry && loop != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] previous = loop ;
in . defaultReadObject () ; doReadObject ( in ) ; } @Override protected void doWriteObject ( final ObjectOutputStream out ) throws IOException { out . writeInt ( maxSize ) ; MST[VoidMethodCallMutator]MSP[S] super . doWriteObject ( out ) ; } @Override
entry . after . before = entry . before ; MST[experimental.MemberVariableMutator]MSP[N] entry . after = header ; entry . before = header . before ; header . before . after = entry ; header . before = entry ; } else if ( entry == header ) {
reuseMapping ( reuse , hashIndex , hashCode , key , value ) ; } else { super . addMapping ( hashIndex , hashCode , key , value ) ; } } else { super . addMapping ( hashIndex , hashCode , key , value ) ; MST[rv.UOI3Mutator]MSP[N] } }
modCount ++ ; removeEntry ( entry , removeIndex , previous ) ; MST[rv.ABSMutator]MSP[S] reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException (
} @Override protected void addMapping ( final int hashIndex , final int hashCode , final K key , final V value ) { if ( isFull () ) { LinkEntry < K , V > reuse = header . after ; boolean removeLRUEntry = false ; MST[rv.CRCR1Mutator]MSP[N]
modCount ++ ; MST[rv.AOR1Mutator]MSP[N] removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException (
loop = loop . next ; } if ( loop == null ) { throw new IllegalStateException ( MST[rv.UOI1Mutator]MSP[N] lr_12 + data [ removeIndex ] + lr_13 + previous + lr_6 + key + lr_7 + value + lr_8 + size + lr_9 + maxSize + lr_2 ) ; }
modCount ++ ; removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException ( MST[rv.ROR5Mutator]MSP[N]
if ( entry . after != header ) { modCount ++ ; if ( entry . before == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] throw new IllegalStateException ( lr_1 + lr_2 ) ; } entry . before . after = entry . after ;
modCount ++ ; removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException ( MST[experimental.NakedReceiverMutator]MSP[N]
if ( entry . after != header ) { modCount ++ ; MST[rv.UOI2Mutator]MSP[N] if ( entry . before == null ) { throw new IllegalStateException ( lr_1 + lr_2 ) ; } entry . before . after = entry . after ;
reuseMapping ( reuse , hashIndex , hashCode , key , value ) ; MST[rv.UOI1Mutator]MSP[N] } else { super . addMapping ( hashIndex , hashCode , key , value ) ; } } else { super . addMapping ( hashIndex , hashCode , key , value ) ; } }
} @Override protected void addMapping ( final int hashIndex , final int hashCode , final K key , final V value ) { if ( isFull () ) { LinkEntry < K , V > reuse = header . after ; boolean removeLRUEntry = false ; MST[rv.CRCR5Mutator]MSP[N]
if ( entry == null ) { MST[rv.ROR5Mutator]MSP[S] return null ; } if ( updateToMRU ) { moveToMRU ( entry ) ; } return entry . getValue () ; } protected void moveToMRU ( final LinkEntry < K , V > entry ) {
lr_4 + header . after + lr_5 + header . before + lr_6 + key + lr_7 + value + lr_8 + size + lr_9 + maxSize + lr_10 ) ; } } else { removeLRUEntry = removeLRU ( reuse ) ; } if ( removeLRUEntry ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
protected void reuseMapping ( final LinkEntry < K , V > entry , final int hashIndex , final int hashCode , final K key , final V value ) { try { final int removeIndex = hashIndex ( entry . hashCode , data . length ) ; MST[rv.UOI2Mutator]MSP[N]
if ( entry == null ) { return null ; } if ( updateToMRU ) { MST[rv.UOI2Mutator]MSP[N] moveToMRU ( entry ) ; } return entry . getValue () ; } protected void moveToMRU ( final LinkEntry < K , V > entry ) {
modCount ++ ; removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException ( MST[rv.ABSMutator]MSP[N]
modCount ++ ; removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException ( MST[experimental.NakedReceiverMutator]MSP[N]
if ( scanUntilRemovable ) { while ( reuse != header && reuse != null ) { if ( removeLRU ( reuse ) ) { MST[NonVoidMethodCallMutator]MSP[S] removeLRUEntry = true ; break; } reuse = reuse . after ; } if ( reuse == null ) { throw new IllegalStateException (
if ( scanUntilRemovable ) { while ( reuse != header && reuse != null ) { if ( removeLRU ( reuse ) ) { MST[rv.ROR3Mutator]MSP[S] removeLRUEntry = true ; break; } reuse = reuse . after ; } if ( reuse == null ) { throw new IllegalStateException (
modCount ++ ; removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException ( MST[rv.CRCR5Mutator]MSP[N]
if ( entry == null ) { return null ; } if ( updateToMRU ) { moveToMRU ( entry ) ; MST[VoidMethodCallMutator]MSP[N] } return entry . getValue () ; } protected void moveToMRU ( final LinkEntry < K , V > entry ) {
modCount ++ ; removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException ( MST[rv.CRCR1Mutator]MSP[N]
modCount ++ ; removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; MST[rv.UOI2Mutator]MSP[N] } catch ( final NullPointerException ex ) { throw new IllegalStateException (
if ( entry . after != header ) { modCount ++ ; MST[rv.AOD2Mutator]MSP[N] if ( entry . before == null ) { throw new IllegalStateException ( lr_1 + lr_2 ) ; } entry . before . after = entry . after ;
if ( entry == null ) { return null ; MST[ReturnValsMutator]MSP[S] } if ( updateToMRU ) { moveToMRU ( entry ) ; } return entry . getValue () ; } protected void moveToMRU ( final LinkEntry < K , V > entry ) {
loop = loop . next ; } if ( loop == null ) { throw new IllegalStateException ( MST[NonVoidMethodCallMutator]MSP[N] lr_12 + data [ removeIndex ] + lr_13 + previous + lr_6 + key + lr_7 + value + lr_8 + size + lr_9 + maxSize + lr_2 ) ; }
} @Override public boolean isFull () { return size >= maxSize ; MST[rv.CRCR5Mutator]MSP[N] } @Override public int maxSize () { return maxSize ; } public boolean isScanUntilRemovable () { return scanUntilRemovable ; } @Override public LRUMap < K , V > clone () {
modCount ++ ; removeEntry ( entry , removeIndex , previous ) ; MST[rv.UOI2Mutator]MSP[N] reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException (
lr_14 + entry + lr_15 + ( entry == header ) + lr_6 + key + lr_7 + value + lr_8 + size + lr_9 + maxSize + lr_2 ) ; } } protected boolean removeLRU ( final LinkEntry < K , V > entry ) { return true ; MST[InlineConstantMutator]MSP[N]
if ( scanUntilRemovable ) { while ( reuse != header && reuse != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] if ( removeLRU ( reuse ) ) { removeLRUEntry = true ; break; } reuse = reuse . after ; } if ( reuse == null ) { throw new IllegalStateException (
modCount ++ ; removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException ( MST[NegateConditionalsMutator]MSP[N]
if ( entry == null ) { return null ; } if ( updateToMRU ) { moveToMRU ( entry ) ; } return entry . getValue () ; MST[ReturnValsMutator]MSP[N] } protected void moveToMRU ( final LinkEntry < K , V > entry ) {
reuseMapping ( reuse , hashIndex , hashCode , key , value ) ; } else { super . addMapping ( hashIndex , hashCode , key , value ) ; } } else { super . addMapping ( hashIndex , hashCode , key , value ) ; MST[rv.UOI3Mutator]MSP[S] } }
} @Override protected void addMapping ( final int hashIndex , final int hashCode , final K key , final V value ) { if ( isFull () ) { MST[rv.ROR4Mutator]MSP[N] LinkEntry < K , V > reuse = header . after ; boolean removeLRUEntry = false ;
final HashEntry < K , V > [] tmp = data ; HashEntry < K , V > loop = tmp [ removeIndex ] ; MST[rv.UOI1Mutator]MSP[S] HashEntry < K , V > previous = null ; while ( loop != entry && loop != null ) { previous = loop ;
loop = loop . next ; } if ( loop == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] throw new IllegalStateException ( lr_12 + data [ removeIndex ] + lr_13 + previous + lr_6 + key + lr_7 + value + lr_8 + size + lr_9 + maxSize + lr_2 ) ; }
return ( LRUMap < K , V > ) super . clone () ; MST[ReturnValsMutator]MSP[S] } private void writeObject ( final ObjectOutputStream out ) throws IOException { out . defaultWriteObject () ; doWriteObject ( out ) ; } private void readObject ( final ObjectInputStream in ) throws IOException , ClassNotFoundException {
if ( entry . after != header ) { modCount ++ ; MST[rv.ABSMutator]MSP[N] if ( entry . before == null ) { throw new IllegalStateException ( lr_1 + lr_2 ) ; } entry . before . after = entry . after ;
loop = loop . next ; } if ( loop == null ) { throw new IllegalStateException ( MST[experimental.NakedReceiverMutator]MSP[N] lr_12 + data [ removeIndex ] + lr_13 + previous + lr_6 + key + lr_7 + value + lr_8 + size + lr_9 + maxSize + lr_2 ) ; }
if ( scanUntilRemovable ) { MST[rv.ROR4Mutator]MSP[N] while ( reuse != header && reuse != null ) { if ( removeLRU ( reuse ) ) { removeLRUEntry = true ; break; } reuse = reuse . after ; } if ( reuse == null ) { throw new IllegalStateException (
} @Override public boolean isFull () { return size >= maxSize ; MST[rv.UOI4Mutator]MSP[N] } @Override public int maxSize () { return maxSize ; } public boolean isScanUntilRemovable () { return scanUntilRemovable ; } @Override public LRUMap < K , V > clone () {
if ( scanUntilRemovable ) { while ( reuse != header && reuse != null ) { MST[NegateConditionalsMutator]MSP[S] if ( removeLRU ( reuse ) ) { removeLRUEntry = true ; break; } reuse = reuse . after ; } if ( reuse == null ) { throw new IllegalStateException (
throw new IllegalStateException ( lr_3 + MST[ConstructorCallMutator]MSP[S] lr_2 ) ; } } @Override protected void updateEntry ( final HashEntry < K , V > entry , final V newValue ) { moveToMRU ( ( LinkEntry < K , V > ) entry ) ; entry . setValue ( newValue ) ;
lr_4 + header . after + lr_5 + header . before + lr_6 + key + lr_7 + value + lr_8 + size + lr_9 + maxSize + lr_10 ) ; } } else { removeLRUEntry = removeLRU ( reuse ) ; } if ( removeLRUEntry ) { MST[NegateConditionalsMutator]MSP[N]
reuseMapping ( reuse , hashIndex , hashCode , key , value ) ; MST[rv.ABSMutator]MSP[N] } else { super . addMapping ( hashIndex , hashCode , key , value ) ; } } else { super . addMapping ( hashIndex , hashCode , key , value ) ; } }
modCount ++ ; removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException ( MST[NonVoidMethodCallMutator]MSP[S]
if ( entry . after != header ) { modCount ++ ; MST[rv.AOD1Mutator]MSP[N] if ( entry . before == null ) { throw new IllegalStateException ( lr_1 + lr_2 ) ; } entry . before . after = entry . after ;
} @Override public boolean isFull () { return size >= maxSize ; MST[rv.CRCR6Mutator]MSP[N] } @Override public int maxSize () { return maxSize ; } public boolean isScanUntilRemovable () { return scanUntilRemovable ; } @Override public LRUMap < K , V > clone () {
if ( entry . after != header ) { modCount ++ ; MST[rv.CRCR6Mutator]MSP[N] if ( entry . before == null ) { throw new IllegalStateException ( lr_1 + lr_2 ) ; } entry . before . after = entry . after ;
modCount ++ ; removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException ( MST[NonVoidMethodCallMutator]MSP[S]
} @Override public boolean isFull () { return size >= maxSize ; MST[rv.CRCR4Mutator]MSP[N] } @Override public int maxSize () { return maxSize ; } public boolean isScanUntilRemovable () { return scanUntilRemovable ; } @Override public LRUMap < K , V > clone () {
final HashEntry < K , V > [] tmp = data ; HashEntry < K , V > loop = tmp [ removeIndex ] ; HashEntry < K , V > previous = null ; while ( loop != entry && loop != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] previous = loop ;
loop = loop . next ; } if ( loop == null ) { throw new IllegalStateException ( MST[experimental.NakedReceiverMutator]MSP[N] lr_12 + data [ removeIndex ] + lr_13 + previous + lr_6 + key + lr_7 + value + lr_8 + size + lr_9 + maxSize + lr_2 ) ; }
if ( entry . after != header ) { modCount ++ ; MST[rv.AOR4Mutator]MSP[N] if ( entry . before == null ) { throw new IllegalStateException ( lr_1 + lr_2 ) ; } entry . before . after = entry . after ;
reuseMapping ( reuse , hashIndex , hashCode , key , value ) ; } else { super . addMapping ( hashIndex , hashCode , key , value ) ; } } else { super . addMapping ( hashIndex , hashCode , key , value ) ; MST[rv.UOI2Mutator]MSP[N] } }
loop = loop . next ; } if ( loop == null ) { throw new IllegalStateException ( MST[NonVoidMethodCallMutator]MSP[N] lr_12 + data [ removeIndex ] + lr_13 + previous + lr_6 + key + lr_7 + value + lr_8 + size + lr_9 + maxSize + lr_2 ) ; }
if ( entry . after != header ) { modCount ++ ; if ( entry . before == null ) { MST[NegateConditionalsMutator]MSP[S] throw new IllegalStateException ( lr_1 + lr_2 ) ; } entry . before . after = entry . after ;
if ( entry . after != header ) { modCount ++ ; MST[InlineConstantMutator]MSP[N] if ( entry . before == null ) { throw new IllegalStateException ( lr_1 + lr_2 ) ; } entry . before . after = entry . after ;
modCount ++ ; removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException ( MST[experimental.NakedReceiverMutator]MSP[N]
loop = loop . next ; } if ( loop == null ) { MST[rv.ROR5Mutator]MSP[S] throw new IllegalStateException ( lr_12 + data [ removeIndex ] + lr_13 + previous + lr_6 + key + lr_7 + value + lr_8 + size + lr_9 + maxSize + lr_2 ) ; }
@Override public V get ( final Object key ) { return get ( key , true ) ; MST[rv.CRCR2Mutator]MSP[N] } public V get ( final Object key , final boolean updateToMRU ) { final LinkEntry < K , V > entry = getEntry ( key ) ;
} @Override public boolean isFull () { return size >= maxSize ; MST[rv.ROR5Mutator]MSP[S] } @Override public int maxSize () { return maxSize ; } public boolean isScanUntilRemovable () { return scanUntilRemovable ; } @Override public LRUMap < K , V > clone () {
} @Override public boolean isFull () { return size >= maxSize ; MST[InlineConstantMutator]MSP[N] } @Override public int maxSize () { return maxSize ; } public boolean isScanUntilRemovable () { return scanUntilRemovable ; } @Override public LRUMap < K , V > clone () {
} @Override protected void addMapping ( final int hashIndex , final int hashCode , final K key , final V value ) { if ( isFull () ) { MST[NonVoidMethodCallMutator]MSP[N] LinkEntry < K , V > reuse = header . after ; boolean removeLRUEntry = false ;
modCount ++ ; MST[rv.CRCR4Mutator]MSP[N] removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException (
@Override public V get ( final Object key ) { return get ( key , true ) ; MST[rv.CRCR5Mutator]MSP[N] } public V get ( final Object key , final boolean updateToMRU ) { final LinkEntry < K , V > entry = getEntry ( key ) ;
modCount ++ ; removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException ( MST[experimental.NakedReceiverMutator]MSP[N]
} @Override public boolean isFull () { return size >= maxSize ; MST[rv.ROR2Mutator]MSP[N] } @Override public int maxSize () { return maxSize ; } public boolean isScanUntilRemovable () { return scanUntilRemovable ; } @Override public LRUMap < K , V > clone () {
if ( entry . after != header ) { modCount ++ ; MST[MathMutator]MSP[N] if ( entry . before == null ) { throw new IllegalStateException ( lr_1 + lr_2 ) ; } entry . before . after = entry . after ;
modCount ++ ; removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException ( MST[NonVoidMethodCallMutator]MSP[S]
if ( scanUntilRemovable ) { while ( reuse != header && reuse != null ) { if ( removeLRU ( reuse ) ) { MST[rv.ROR4Mutator]MSP[S] removeLRUEntry = true ; break; } reuse = reuse . after ; } if ( reuse == null ) { throw new IllegalStateException (
modCount ++ ; removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException ( MST[experimental.NakedReceiverMutator]MSP[N]
loop = loop . next ; } if ( loop == null ) { throw new IllegalStateException ( MST[ConstructorCallMutator]MSP[N] lr_12 + data [ removeIndex ] + lr_13 + previous + lr_6 + key + lr_7 + value + lr_8 + size + lr_9 + maxSize + lr_2 ) ; }
modCount ++ ; removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException ( MST[rv.UOI4Mutator]MSP[N]
if ( entry . after != header ) { modCount ++ ; MST[rv.CRCR3Mutator]MSP[N] if ( entry . before == null ) { throw new IllegalStateException ( lr_1 + lr_2 ) ; } entry . before . after = entry . after ;
loop = loop . next ; } if ( loop == null ) { throw new IllegalStateException ( MST[NonVoidMethodCallMutator]MSP[N] lr_12 + data [ removeIndex ] + lr_13 + previous + lr_6 + key + lr_7 + value + lr_8 + size + lr_9 + maxSize + lr_2 ) ; }
modCount ++ ; removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException ( MST[rv.UOI3Mutator]MSP[N]
lr_4 + header . after + lr_5 + header . before + lr_6 + key + lr_7 + value + lr_8 + size + lr_9 + maxSize + lr_10 ) ; } } else { removeLRUEntry = removeLRU ( reuse ) ; } if ( removeLRUEntry ) { MST[rv.ROR1Mutator]MSP[N]
if ( scanUntilRemovable ) { while ( reuse != header && reuse != null ) { if ( removeLRU ( reuse ) ) { removeLRUEntry = true ; MST[rv.CRCR4Mutator]MSP[N] break; } reuse = reuse . after ; } if ( reuse == null ) { throw new IllegalStateException (
lr_4 + header . after + lr_5 + header . before + lr_6 + key + lr_7 + value + lr_8 + size + lr_9 + maxSize + lr_10 ) ; } } else { removeLRUEntry = removeLRU ( reuse ) ; MST[NonVoidMethodCallMutator]MSP[N] } if ( removeLRUEntry ) {
loop = loop . next ; } if ( loop == null ) { throw new IllegalStateException ( MST[rv.UOI4Mutator]MSP[N] lr_12 + data [ removeIndex ] + lr_13 + previous + lr_6 + key + lr_7 + value + lr_8 + size + lr_9 + maxSize + lr_2 ) ; }
loop = loop . next ; } if ( loop == null ) { throw new IllegalStateException ( MST[NonVoidMethodCallMutator]MSP[N] lr_12 + data [ removeIndex ] + lr_13 + previous + lr_6 + key + lr_7 + value + lr_8 + size + lr_9 + maxSize + lr_2 ) ; }
final HashEntry < K , V > [] tmp = data ; HashEntry < K , V > loop = tmp [ removeIndex ] ; HashEntry < K , V > previous = null ; while ( loop != entry && loop != null ) { MST[rv.ROR5Mutator]MSP[S] previous = loop ;
entry . after . before = entry . before ; entry . after = header ; entry . before = header . before ; MST[experimental.MemberVariableMutator]MSP[N] header . before . after = entry ; header . before = entry ; } else if ( entry == header ) {
loop = loop . next ; } if ( loop == null ) { throw new IllegalStateException ( MST[ConstructorCallMutator]MSP[N] lr_12 + data [ removeIndex ] + lr_13 + previous + lr_6 + key + lr_7 + value + lr_8 + size + lr_9 + maxSize + lr_2 ) ; }
} @Override public boolean isFull () { return size >= maxSize ; MST[rv.UOI1Mutator]MSP[N] } @Override public int maxSize () { return maxSize ; } public boolean isScanUntilRemovable () { return scanUntilRemovable ; } @Override public LRUMap < K , V > clone () {
lr_14 + entry + lr_15 + ( entry == header ) + lr_6 + key + lr_7 + value + lr_8 + size + lr_9 + maxSize + lr_2 ) ; } } protected boolean removeLRU ( final LinkEntry < K , V > entry ) { return true ; MST[rv.CRCR3Mutator]MSP[N]
lr_4 + header . after + lr_5 + header . before + lr_6 + key + lr_7 + value + lr_8 + size + lr_9 + maxSize + lr_10 ) ; } } else { removeLRUEntry = removeLRU ( reuse ) ; } if ( removeLRUEntry ) { MST[rv.UOI3Mutator]MSP[N]
} @Override public boolean isFull () { return size >= maxSize ; } @Override public int maxSize () { return maxSize ; MST[rv.UOI1Mutator]MSP[N] } public boolean isScanUntilRemovable () { return scanUntilRemovable ; } @Override public LRUMap < K , V > clone () {
loop = loop . next ; } if ( loop == null ) { throw new IllegalStateException ( MST[experimental.NakedReceiverMutator]MSP[N] lr_12 + data [ removeIndex ] + lr_13 + previous + lr_6 + key + lr_7 + value + lr_8 + size + lr_9 + maxSize + lr_2 ) ; }
modCount ++ ; removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException ( MST[NonVoidMethodCallMutator]MSP[S]
} @Override public boolean isFull () { return size >= maxSize ; MST[ReturnValsMutator]MSP[N] } @Override public int maxSize () { return maxSize ; } public boolean isScanUntilRemovable () { return scanUntilRemovable ; } @Override public LRUMap < K , V > clone () {
reuseMapping ( reuse , hashIndex , hashCode , key , value ) ; MST[rv.UOI4Mutator]MSP[S] } else { super . addMapping ( hashIndex , hashCode , key , value ) ; } } else { super . addMapping ( hashIndex , hashCode , key , value ) ; } }
if ( scanUntilRemovable ) { while ( reuse != header && reuse != null ) { if ( removeLRU ( reuse ) ) { removeLRUEntry = true ; break; } reuse = reuse . after ; } if ( reuse == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] throw new IllegalStateException (
loop = loop . next ; } if ( loop == null ) { throw new IllegalStateException ( MST[experimental.NakedReceiverMutator]MSP[N] lr_12 + data [ removeIndex ] + lr_13 + previous + lr_6 + key + lr_7 + value + lr_8 + size + lr_9 + maxSize + lr_2 ) ; }
@Override public V get ( final Object key ) { return get ( key , true ) ; MST[ArgumentPropagationMutator]MSP[S] } public V get ( final Object key , final boolean updateToMRU ) { final LinkEntry < K , V > entry = getEntry ( key ) ;
modCount ++ ; MST[rv.UOI3Mutator]MSP[N] removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException (
if ( scanUntilRemovable ) { while ( reuse != header && reuse != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] if ( removeLRU ( reuse ) ) { removeLRUEntry = true ; break; } reuse = reuse . after ; } if ( reuse == null ) { throw new IllegalStateException (
if ( entry . after != header ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] modCount ++ ; if ( entry . before == null ) { throw new IllegalStateException ( lr_1 + lr_2 ) ; } entry . before . after = entry . after ;
lr_4 + header . after + lr_5 + header . before + lr_6 + key + lr_7 + value + lr_8 + size + lr_9 + maxSize + lr_10 ) ; } } else { removeLRUEntry = removeLRU ( reuse ) ; } if ( removeLRUEntry ) { MST[rv.ROR4Mutator]MSP[N]
modCount ++ ; removeEntry ( entry , removeIndex , previous ) ; MST[rv.UOI1Mutator]MSP[N] reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException (
modCount ++ ; removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException ( MST[experimental.NakedReceiverMutator]MSP[N]
} @Override protected void addMapping ( final int hashIndex , final int hashCode , final K key , final V value ) { if ( isFull () ) { MST[rv.ROR3Mutator]MSP[N] LinkEntry < K , V > reuse = header . after ; boolean removeLRUEntry = false ;
} @Override public boolean isFull () { return size >= maxSize ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] } @Override public int maxSize () { return maxSize ; } public boolean isScanUntilRemovable () { return scanUntilRemovable ; } @Override public LRUMap < K , V > clone () {
if ( entry . after != header ) { MST[rv.ROR5Mutator]MSP[N] modCount ++ ; if ( entry . before == null ) { throw new IllegalStateException ( lr_1 + lr_2 ) ; } entry . before . after = entry . after ;
} @Override protected void addMapping ( final int hashIndex , final int hashCode , final K key , final V value ) { if ( isFull () ) { LinkEntry < K , V > reuse = header . after ; boolean removeLRUEntry = false ; MST[rv.CRCR6Mutator]MSP[N]
modCount ++ ; MST[rv.AOD2Mutator]MSP[N] removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException (
if ( scanUntilRemovable ) { while ( reuse != header && reuse != null ) { if ( removeLRU ( reuse ) ) { removeLRUEntry = true ; MST[InlineConstantMutator]MSP[S] break; } reuse = reuse . after ; } if ( reuse == null ) { throw new IllegalStateException (
modCount ++ ; MST[rv.CRCR5Mutator]MSP[N] removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException (
} @Override public boolean isFull () { return size >= maxSize ; MST[rv.ROR4Mutator]MSP[N] } @Override public int maxSize () { return maxSize ; } public boolean isScanUntilRemovable () { return scanUntilRemovable ; } @Override public LRUMap < K , V > clone () {
if ( entry == null ) { return null ; } if ( updateToMRU ) { MST[rv.UOI3Mutator]MSP[N] moveToMRU ( entry ) ; } return entry . getValue () ; } protected void moveToMRU ( final LinkEntry < K , V > entry ) {
@Override public V get ( final Object key ) { return get ( key , true ) ; MST[rv.CRCR3Mutator]MSP[N] } public V get ( final Object key , final boolean updateToMRU ) { final LinkEntry < K , V > entry = getEntry ( key ) ;
if ( scanUntilRemovable ) { while ( reuse != header && reuse != null ) { if ( removeLRU ( reuse ) ) { MST[rv.ROR2Mutator]MSP[N] removeLRUEntry = true ; break; } reuse = reuse . after ; } if ( reuse == null ) { throw new IllegalStateException (
modCount ++ ; removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; MST[rv.UOI3Mutator]MSP[N] addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException (
if ( reuse == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] throw new IllegalStateException ( lr_11 + header . after + lr_5 + header . before + lr_6 + key + lr_7 + value + lr_8 + size + lr_9 + maxSize + lr_10 ) ; }
reuseMapping ( reuse , hashIndex , hashCode , key , value ) ; MST[rv.UOI4Mutator]MSP[N] } else { super . addMapping ( hashIndex , hashCode , key , value ) ; } } else { super . addMapping ( hashIndex , hashCode , key , value ) ; } }
loop = loop . next ; } if ( loop == null ) { throw new IllegalStateException ( MST[rv.UOI4Mutator]MSP[N] lr_12 + data [ removeIndex ] + lr_13 + previous + lr_6 + key + lr_7 + value + lr_8 + size + lr_9 + maxSize + lr_2 ) ; }
modCount ++ ; removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException ( MST[rv.CRCR6Mutator]MSP[N]
if ( scanUntilRemovable ) { while ( reuse != header && reuse != null ) { MST[rv.ROR5Mutator]MSP[S] if ( removeLRU ( reuse ) ) { removeLRUEntry = true ; break; } reuse = reuse . after ; } if ( reuse == null ) { throw new IllegalStateException (
reuseMapping ( reuse , hashIndex , hashCode , key , value ) ; MST[rv.ABSMutator]MSP[S] } else { super . addMapping ( hashIndex , hashCode , key , value ) ; } } else { super . addMapping ( hashIndex , hashCode , key , value ) ; } }
modCount ++ ; removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException ( MST[NonVoidMethodCallMutator]MSP[N]
loop = loop . next ; } if ( loop == null ) { throw new IllegalStateException ( MST[NonVoidMethodCallMutator]MSP[N] lr_12 + data [ removeIndex ] + lr_13 + previous + lr_6 + key + lr_7 + value + lr_8 + size + lr_9 + maxSize + lr_2 ) ; }
if ( scanUntilRemovable ) { while ( reuse != header && reuse != null ) { if ( removeLRU ( reuse ) ) { removeLRUEntry = true ; MST[rv.CRCR2Mutator]MSP[S] break; } reuse = reuse . after ; } if ( reuse == null ) { throw new IllegalStateException (
} @Override public boolean isFull () { return size >= maxSize ; MST[rv.CRCR5Mutator]MSP[N] } @Override public int maxSize () { return maxSize ; } public boolean isScanUntilRemovable () { return scanUntilRemovable ; } @Override public LRUMap < K , V > clone () {
@Override public V get ( final Object key ) { return get ( key , true ) ; MST[InlineConstantMutator]MSP[N] } public V get ( final Object key , final boolean updateToMRU ) { final LinkEntry < K , V > entry = getEntry ( key ) ;
modCount ++ ; removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException ( MST[rv.UOI1Mutator]MSP[N]
if ( scanUntilRemovable ) { while ( reuse != header && reuse != null ) { if ( removeLRU ( reuse ) ) { removeLRUEntry = true ; break; } reuse = reuse . after ; } if ( reuse == null ) { MST[NegateConditionalsMutator]MSP[S] throw new IllegalStateException (
in . defaultReadObject () ; doReadObject ( in ) ; } @Override protected void doWriteObject ( final ObjectOutputStream out ) throws IOException { out . writeInt ( maxSize ) ; super . doWriteObject ( out ) ; MST[VoidMethodCallMutator]MSP[S] } @Override
loop = loop . next ; } if ( loop == null ) { throw new IllegalStateException ( MST[rv.UOI3Mutator]MSP[N] lr_12 + data [ removeIndex ] + lr_13 + previous + lr_6 + key + lr_7 + value + lr_8 + size + lr_9 + maxSize + lr_2 ) ; }
if ( entry . after != header ) { modCount ++ ; if ( entry . before == null ) { throw new IllegalStateException ( lr_1 + MST[ConstructorCallMutator]MSP[S] lr_2 ) ; } entry . before . after = entry . after ;
if ( entry . after != header ) { modCount ++ ; MST[rv.UOI1Mutator]MSP[N] if ( entry . before == null ) { throw new IllegalStateException ( lr_1 + lr_2 ) ; } entry . before . after = entry . after ;
reuseMapping ( reuse , hashIndex , hashCode , key , value ) ; } else { super . addMapping ( hashIndex , hashCode , key , value ) ; } } else { super . addMapping ( hashIndex , hashCode , key , value ) ; MST[rv.UOI2Mutator]MSP[N] } }
if ( entry == null ) { MST[NegateConditionalsMutator]MSP[S] return null ; } if ( updateToMRU ) { moveToMRU ( entry ) ; } return entry . getValue () ; } protected void moveToMRU ( final LinkEntry < K , V > entry ) {
} @Override protected void addMapping ( final int hashIndex , final int hashCode , final K key , final V value ) { if ( isFull () ) { MST[NegateConditionalsMutator]MSP[N] LinkEntry < K , V > reuse = header . after ; boolean removeLRUEntry = false ;
if ( entry == null ) { return null ; } if ( updateToMRU ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] moveToMRU ( entry ) ; } return entry . getValue () ; } protected void moveToMRU ( final LinkEntry < K , V > entry ) {
if ( scanUntilRemovable ) { MST[rv.ROR3Mutator]MSP[N] while ( reuse != header && reuse != null ) { if ( removeLRU ( reuse ) ) { removeLRUEntry = true ; break; } reuse = reuse . after ; } if ( reuse == null ) { throw new IllegalStateException (
} @Override public boolean isFull () { return size >= maxSize ; MST[NegateConditionalsMutator]MSP[N] } @Override public int maxSize () { return maxSize ; } public boolean isScanUntilRemovable () { return scanUntilRemovable ; } @Override public LRUMap < K , V > clone () {
@Override public V get ( final Object key ) { return get ( key , true ) ; MST[NonVoidMethodCallMutator]MSP[S] } public V get ( final Object key , final boolean updateToMRU ) { final LinkEntry < K , V > entry = getEntry ( key ) ;
} @Override public boolean isFull () { return size >= maxSize ; MST[rv.UOI1Mutator]MSP[N] } @Override public int maxSize () { return maxSize ; } public boolean isScanUntilRemovable () { return scanUntilRemovable ; } @Override public LRUMap < K , V > clone () {
loop = loop . next ; } if ( loop == null ) { throw new IllegalStateException ( MST[experimental.NakedReceiverMutator]MSP[N] lr_12 + data [ removeIndex ] + lr_13 + previous + lr_6 + key + lr_7 + value + lr_8 + size + lr_9 + maxSize + lr_2 ) ; }
modCount ++ ; removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; MST[rv.UOI4Mutator]MSP[S] addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException (
modCount ++ ; removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException ( MST[ConstructorCallMutator]MSP[S]
} @Override public boolean isFull () { return size >= maxSize ; MST[RemoveConditionalMutator_ORDER_IF]MSP[N] } @Override public int maxSize () { return maxSize ; } public boolean isScanUntilRemovable () { return scanUntilRemovable ; } @Override public LRUMap < K , V > clone () {
modCount ++ ; removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; MST[rv.UOI3Mutator]MSP[N] addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException (
loop = loop . next ; } if ( loop == null ) { throw new IllegalStateException ( MST[rv.ABSMutator]MSP[S] lr_12 + data [ removeIndex ] + lr_13 + previous + lr_6 + key + lr_7 + value + lr_8 + size + lr_9 + maxSize + lr_2 ) ; }
modCount ++ ; removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException ( MST[NonVoidMethodCallMutator]MSP[S]
loop = loop . next ; } if ( loop == null ) { throw new IllegalStateException ( MST[experimental.NakedReceiverMutator]MSP[N] lr_12 + data [ removeIndex ] + lr_13 + previous + lr_6 + key + lr_7 + value + lr_8 + size + lr_9 + maxSize + lr_2 ) ; }
if ( entry == null ) { return null ; } if ( updateToMRU ) { moveToMRU ( entry ) ; } return entry . getValue () ; MST[NonVoidMethodCallMutator]MSP[S] } protected void moveToMRU ( final LinkEntry < K , V > entry ) {
if ( entry . after != header ) { modCount ++ ; MST[rv.CRCR2Mutator]MSP[N] if ( entry . before == null ) { throw new IllegalStateException ( lr_1 + lr_2 ) ; } entry . before . after = entry . after ;
modCount ++ ; removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException ( MST[NonVoidMethodCallMutator]MSP[S]
if ( scanUntilRemovable ) { while ( reuse != header && reuse != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] if ( removeLRU ( reuse ) ) { removeLRUEntry = true ; break; } reuse = reuse . after ; } if ( reuse == null ) { throw new IllegalStateException (
modCount ++ ; removeEntry ( entry , removeIndex , previous ) ; MST[VoidMethodCallMutator]MSP[N] reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException (
modCount ++ ; removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException ( MST[experimental.NakedReceiverMutator]MSP[N]
modCount ++ ; removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException ( MST[NonVoidMethodCallMutator]MSP[S]
if ( entry == null ) { return null ; } if ( updateToMRU ) { MST[rv.ABSMutator]MSP[N] moveToMRU ( entry ) ; } return entry . getValue () ; } protected void moveToMRU ( final LinkEntry < K , V > entry ) {
loop = loop . next ; } if ( loop == null ) { throw new IllegalStateException ( MST[rv.UOI4Mutator]MSP[N] lr_12 + data [ removeIndex ] + lr_13 + previous + lr_6 + key + lr_7 + value + lr_8 + size + lr_9 + maxSize + lr_2 ) ; }
if ( scanUntilRemovable ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] while ( reuse != header && reuse != null ) { if ( removeLRU ( reuse ) ) { removeLRUEntry = true ; break; } reuse = reuse . after ; } if ( reuse == null ) { throw new IllegalStateException (
if ( entry == null ) { return null ; } if ( updateToMRU ) { MST[rv.UOI4Mutator]MSP[N] moveToMRU ( entry ) ; } return entry . getValue () ; } protected void moveToMRU ( final LinkEntry < K , V > entry ) {
if ( scanUntilRemovable ) { while ( reuse != header && reuse != null ) { MST[rv.ROR5Mutator]MSP[S] if ( removeLRU ( reuse ) ) { removeLRUEntry = true ; break; } reuse = reuse . after ; } if ( reuse == null ) { throw new IllegalStateException (
} @Override public boolean isFull () { return size >= maxSize ; MST[InlineConstantMutator]MSP[N] } @Override public int maxSize () { return maxSize ; } public boolean isScanUntilRemovable () { return scanUntilRemovable ; } @Override public LRUMap < K , V > clone () {
loop = loop . next ; } if ( loop == null ) { throw new IllegalStateException ( MST[rv.UOI3Mutator]MSP[N] lr_12 + data [ removeIndex ] + lr_13 + previous + lr_6 + key + lr_7 + value + lr_8 + size + lr_9 + maxSize + lr_2 ) ; }
modCount ++ ; MST[rv.AOD1Mutator]MSP[N] removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException (
modCount ++ ; removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; MST[rv.ABSMutator]MSP[S] addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException (
protected void reuseMapping ( final LinkEntry < K , V > entry , final int hashIndex , final int hashCode , final K key , final V value ) { try { final int removeIndex = hashIndex ( entry . hashCode , data . length ) ; MST[rv.UOI1Mutator]MSP[N]
entry . after . before = entry . before ; entry . after = header ; entry . before = header . before ; header . before . after = entry ; header . before = entry ; MST[experimental.MemberVariableMutator]MSP[N] } else if ( entry == header ) {
if ( entry == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] return null ; } if ( updateToMRU ) { moveToMRU ( entry ) ; } return entry . getValue () ; } protected void moveToMRU ( final LinkEntry < K , V > entry ) {
lr_4 + header . after + lr_5 + header . before + lr_6 + key + lr_7 + value + lr_8 + size + lr_9 + maxSize + lr_10 ) ; } } else { removeLRUEntry = removeLRU ( reuse ) ; } if ( removeLRUEntry ) { MST[rv.ROR5Mutator]MSP[N]
loop = loop . next ; } if ( loop == null ) { throw new IllegalStateException ( MST[NonVoidMethodCallMutator]MSP[N] lr_12 + data [ removeIndex ] + lr_13 + previous + lr_6 + key + lr_7 + value + lr_8 + size + lr_9 + maxSize + lr_2 ) ; }
modCount ++ ; removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; MST[rv.UOI4Mutator]MSP[N] addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException (
modCount ++ ; removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; MST[rv.UOI1Mutator]MSP[N] } catch ( final NullPointerException ex ) { throw new IllegalStateException (
loop = loop . next ; } if ( loop == null ) { throw new IllegalStateException ( MST[NonVoidMethodCallMutator]MSP[N] lr_12 + data [ removeIndex ] + lr_13 + previous + lr_6 + key + lr_7 + value + lr_8 + size + lr_9 + maxSize + lr_2 ) ; }
} @Override public boolean isFull () { return size >= maxSize ; MST[rv.CRCR3Mutator]MSP[N] } @Override public int maxSize () { return maxSize ; } public boolean isScanUntilRemovable () { return scanUntilRemovable ; } @Override public LRUMap < K , V > clone () {
protected void reuseMapping ( final LinkEntry < K , V > entry , final int hashIndex , final int hashCode , final K key , final V value ) { try { final int removeIndex = hashIndex ( entry . hashCode , data . length ) ; MST[NonVoidMethodCallMutator]MSP[S]
modCount ++ ; MST[rv.UOI4Mutator]MSP[N] removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException (
if ( entry . after != header ) { modCount ++ ; if ( entry . before == null ) { throw new IllegalStateException ( lr_1 + lr_2 ) ; } entry . before . after = entry . after ; MST[experimental.MemberVariableMutator]MSP[N]
loop = loop . next ; } if ( loop == null ) { throw new IllegalStateException ( MST[rv.ABSMutator]MSP[N] lr_12 + data [ removeIndex ] + lr_13 + previous + lr_6 + key + lr_7 + value + lr_8 + size + lr_9 + maxSize + lr_2 ) ; }
if ( entry == null ) { return null ; } if ( updateToMRU ) { MST[rv.ROR1Mutator]MSP[N] moveToMRU ( entry ) ; } return entry . getValue () ; } protected void moveToMRU ( final LinkEntry < K , V > entry ) {
} @Override protected void addMapping ( final int hashIndex , final int hashCode , final K key , final V value ) { if ( isFull () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] LinkEntry < K , V > reuse = header . after ; boolean removeLRUEntry = false ;
if ( entry . after != header ) { modCount ++ ; if ( entry . before == null ) { MST[rv.ROR5Mutator]MSP[S] throw new IllegalStateException ( lr_1 + lr_2 ) ; } entry . before . after = entry . after ;
modCount ++ ; MST[rv.AOR4Mutator]MSP[N] removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException (
throw new IllegalStateException ( lr_3 + lr_2 ) ; } } @Override protected void updateEntry ( final HashEntry < K , V > entry , final V newValue ) { moveToMRU ( ( LinkEntry < K , V > ) entry ) ; MST[VoidMethodCallMutator]MSP[S] entry . setValue ( newValue ) ;
reuseMapping ( reuse , hashIndex , hashCode , key , value ) ; } else { super . addMapping ( hashIndex , hashCode , key , value ) ; } } else { super . addMapping ( hashIndex , hashCode , key , value ) ; MST[rv.UOI1Mutator]MSP[N] } }
} @Override public boolean isFull () { return size >= maxSize ; MST[BooleanTrueReturnValsMutator]MSP[N] } @Override public int maxSize () { return maxSize ; } public boolean isScanUntilRemovable () { return scanUntilRemovable ; } @Override public LRUMap < K , V > clone () {
reuseMapping ( reuse , hashIndex , hashCode , key , value ) ; } else { super . addMapping ( hashIndex , hashCode , key , value ) ; } } else { super . addMapping ( hashIndex , hashCode , key , value ) ; MST[VoidMethodCallMutator]MSP[N] } }
in . defaultReadObject () ; doReadObject ( in ) ; } @Override protected void doWriteObject ( final ObjectOutputStream out ) throws IOException { out . writeInt ( maxSize ) ; MST[rv.UOI1Mutator]MSP[N] super . doWriteObject ( out ) ; } @Override
} @Override public boolean isFull () { return size >= maxSize ; MST[rv.UOI2Mutator]MSP[N] } @Override public int maxSize () { return maxSize ; } public boolean isScanUntilRemovable () { return scanUntilRemovable ; } @Override public LRUMap < K , V > clone () {
lr_14 + entry + lr_15 + ( entry == header ) + lr_6 + key + lr_7 + value + lr_8 + size + lr_9 + maxSize + lr_2 ) ; } } protected boolean removeLRU ( final LinkEntry < K , V > entry ) { return true ; MST[rv.CRCR4Mutator]MSP[N]
} @Override public boolean isFull () { return size >= maxSize ; } @Override public int maxSize () { return maxSize ; MST[rv.UOI2Mutator]MSP[N] } public boolean isScanUntilRemovable () { return scanUntilRemovable ; } @Override public LRUMap < K , V > clone () {
entry . after . before = entry . before ; entry . after = header ; entry . before = header . before ; header . before . after = entry ; header . before = entry ; } else if ( entry == header ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S]
loop = loop . next ; } if ( loop == null ) { throw new IllegalStateException ( MST[experimental.NakedReceiverMutator]MSP[N] lr_12 + data [ removeIndex ] + lr_13 + previous + lr_6 + key + lr_7 + value + lr_8 + size + lr_9 + maxSize + lr_2 ) ; }
modCount ++ ; removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException ( MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
lr_4 + header . after + lr_5 + header . before + lr_6 + key + lr_7 + value + lr_8 + size + lr_9 + maxSize + lr_10 ) ; } } else { removeLRUEntry = removeLRU ( reuse ) ; } if ( removeLRUEntry ) { MST[rv.UOI2Mutator]MSP[N]
modCount ++ ; removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; MST[rv.ABSMutator]MSP[N] addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException (
reuseMapping ( reuse , hashIndex , hashCode , key , value ) ; MST[VoidMethodCallMutator]MSP[N] } else { super . addMapping ( hashIndex , hashCode , key , value ) ; } } else { super . addMapping ( hashIndex , hashCode , key , value ) ; } }
modCount ++ ; removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException ( MST[NonVoidMethodCallMutator]MSP[S]
return ( LRUMap < K , V > ) super . clone () ; MST[NonVoidMethodCallMutator]MSP[S] } private void writeObject ( final ObjectOutputStream out ) throws IOException { out . defaultWriteObject () ; doWriteObject ( out ) ; } private void readObject ( final ObjectInputStream in ) throws IOException , ClassNotFoundException {
modCount ++ ; removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; MST[VoidMethodCallMutator]MSP[N] } catch ( final NullPointerException ex ) { throw new IllegalStateException (
reuseMapping ( reuse , hashIndex , hashCode , key , value ) ; MST[rv.UOI3Mutator]MSP[N] } else { super . addMapping ( hashIndex , hashCode , key , value ) ; } } else { super . addMapping ( hashIndex , hashCode , key , value ) ; } }
lr_14 + entry + lr_15 + ( entry == header ) + lr_6 + key + lr_7 + value + lr_8 + size + lr_9 + maxSize + lr_2 ) ; } } protected boolean removeLRU ( final LinkEntry < K , V > entry ) { return true ; MST[BooleanFalseReturnValsMutator]MSP[N]
modCount ++ ; MST[InlineConstantMutator]MSP[N] removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException (
modCount ++ ; removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException ( MST[rv.UOI4Mutator]MSP[N]
if ( scanUntilRemovable ) { while ( reuse != header && reuse != null ) { if ( removeLRU ( reuse ) ) { removeLRUEntry = true ; MST[rv.CRCR5Mutator]MSP[N] break; } reuse = reuse . after ; } if ( reuse == null ) { throw new IllegalStateException (
modCount ++ ; removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException ( MST[rv.UOI3Mutator]MSP[N]
loop = loop . next ; } if ( loop == null ) { throw new IllegalStateException ( MST[rv.UOI3Mutator]MSP[N] lr_12 + data [ removeIndex ] + lr_13 + previous + lr_6 + key + lr_7 + value + lr_8 + size + lr_9 + maxSize + lr_2 ) ; }
modCount ++ ; MST[rv.AOR3Mutator]MSP[N] removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException (
entry . after . before = entry . before ; entry . after = header ; entry . before = header . before ; header . before . after = entry ; header . before = entry ; } else if ( entry == header ) { MST[rv.ROR5Mutator]MSP[N]
reuseMapping ( reuse , hashIndex , hashCode , key , value ) ; } else { super . addMapping ( hashIndex , hashCode , key , value ) ; } } else { super . addMapping ( hashIndex , hashCode , key , value ) ; MST[rv.UOI1Mutator]MSP[N] } }
modCount ++ ; MST[rv.ABSMutator]MSP[N] removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException (
loop = loop . next ; } if ( loop == null ) { throw new IllegalStateException ( MST[NonVoidMethodCallMutator]MSP[N] lr_12 + data [ removeIndex ] + lr_13 + previous + lr_6 + key + lr_7 + value + lr_8 + size + lr_9 + maxSize + lr_2 ) ; }
entry . after . before = entry . before ; entry . after = header ; entry . before = header . before ; header . before . after = entry ; header . before = entry ; } else if ( entry == header ) { MST[NegateConditionalsMutator]MSP[N]
loop = loop . next ; } if ( loop == null ) { throw new IllegalStateException ( MST[rv.UOI1Mutator]MSP[N] lr_12 + data [ removeIndex ] + lr_13 + previous + lr_6 + key + lr_7 + value + lr_8 + size + lr_9 + maxSize + lr_2 ) ; }
@Override public V get ( final Object key ) { return get ( key , true ) ; MST[NullReturnValsMutator]MSP[S] } public V get ( final Object key , final boolean updateToMRU ) { final LinkEntry < K , V > entry = getEntry ( key ) ;
loop = loop . next ; } if ( loop == null ) { throw new IllegalStateException ( MST[experimental.NakedReceiverMutator]MSP[N] lr_12 + data [ removeIndex ] + lr_13 + previous + lr_6 + key + lr_7 + value + lr_8 + size + lr_9 + maxSize + lr_2 ) ; }
if ( scanUntilRemovable ) { while ( reuse != header && reuse != null ) { if ( removeLRU ( reuse ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] removeLRUEntry = true ; break; } reuse = reuse . after ; } if ( reuse == null ) { throw new IllegalStateException (
modCount ++ ; MST[rv.CRCR6Mutator]MSP[N] removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException (
modCount ++ ; MST[rv.CRCR2Mutator]MSP[N] removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException (
@Override public V get ( final Object key ) { return get ( key , true ) ; MST[rv.CRCR4Mutator]MSP[N] } public V get ( final Object key , final boolean updateToMRU ) { final LinkEntry < K , V > entry = getEntry ( key ) ;
} @Override public boolean isFull () { return size >= maxSize ; MST[rv.ROR3Mutator]MSP[N] } @Override public int maxSize () { return maxSize ; } public boolean isScanUntilRemovable () { return scanUntilRemovable ; } @Override public LRUMap < K , V > clone () {
lr_4 + header . after + lr_5 + header . before + lr_6 + key + lr_7 + value + lr_8 + size + lr_9 + maxSize + lr_10 ) ; } } else { removeLRUEntry = removeLRU ( reuse ) ; } if ( removeLRUEntry ) { MST[rv.ABSMutator]MSP[N]
modCount ++ ; removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; MST[rv.UOI2Mutator]MSP[N] addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException (
} @Override public boolean isFull () { return size >= maxSize ; MST[rv.ABSMutator]MSP[N] } @Override public int maxSize () { return maxSize ; } public boolean isScanUntilRemovable () { return scanUntilRemovable ; } @Override public LRUMap < K , V > clone () {
lr_4 + header . after + lr_5 + header . before + lr_6 + key + lr_7 + value + lr_8 + size + lr_9 + maxSize + lr_10 ) ; } } else { removeLRUEntry = removeLRU ( reuse ) ; } if ( removeLRUEntry ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
modCount ++ ; MST[rv.UOI2Mutator]MSP[N] removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException (
if ( entry . after != header ) { modCount ++ ; MST[rv.CRCR5Mutator]MSP[N] if ( entry . before == null ) { throw new IllegalStateException ( lr_1 + lr_2 ) ; } entry . before . after = entry . after ;
modCount ++ ; removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException ( MST[experimental.NakedReceiverMutator]MSP[N]
loop = loop . next ; } if ( loop == null ) { throw new IllegalStateException ( MST[NonVoidMethodCallMutator]MSP[N] lr_12 + data [ removeIndex ] + lr_13 + previous + lr_6 + key + lr_7 + value + lr_8 + size + lr_9 + maxSize + lr_2 ) ; }
lr_4 + header . after + lr_5 + header . before + lr_6 + key + lr_7 + value + lr_8 + size + lr_9 + maxSize + lr_10 ) ; } } else { removeLRUEntry = removeLRU ( reuse ) ; } if ( removeLRUEntry ) { MST[rv.ROR3Mutator]MSP[N]
if ( entry . after != header ) { modCount ++ ; MST[rv.AOR1Mutator]MSP[N] if ( entry . before == null ) { throw new IllegalStateException ( lr_1 + lr_2 ) ; } entry . before . after = entry . after ;
if ( entry . after != header ) { modCount ++ ; if ( entry . before == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] throw new IllegalStateException ( lr_1 + lr_2 ) ; } entry . before . after = entry . after ;
final HashEntry < K , V > [] tmp = data ; HashEntry < K , V > loop = tmp [ removeIndex ] ; HashEntry < K , V > previous = null ; while ( loop != entry && loop != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] previous = loop ;
loop = loop . next ; } if ( loop == null ) { throw new IllegalStateException ( MST[experimental.NakedReceiverMutator]MSP[N] lr_12 + data [ removeIndex ] + lr_13 + previous + lr_6 + key + lr_7 + value + lr_8 + size + lr_9 + maxSize + lr_2 ) ; }
} @Override public boolean isFull () { return size >= maxSize ; } @Override public int maxSize () { return maxSize ; } public boolean isScanUntilRemovable () { return scanUntilRemovable ; MST[ReturnValsMutator]MSP[N] } @Override public LRUMap < K , V > clone () {
if ( scanUntilRemovable ) { MST[rv.ROR2Mutator]MSP[N] while ( reuse != header && reuse != null ) { if ( removeLRU ( reuse ) ) { removeLRUEntry = true ; break; } reuse = reuse . after ; } if ( reuse == null ) { throw new IllegalStateException (
} @Override public boolean isFull () { return size >= maxSize ; MST[rv.UOI2Mutator]MSP[N] } @Override public int maxSize () { return maxSize ; } public boolean isScanUntilRemovable () { return scanUntilRemovable ; } @Override public LRUMap < K , V > clone () {
in . defaultReadObject () ; doReadObject ( in ) ; } @Override protected void doWriteObject ( final ObjectOutputStream out ) throws IOException { out . writeInt ( maxSize ) ; MST[rv.UOI2Mutator]MSP[N] super . doWriteObject ( out ) ; } @Override
if ( scanUntilRemovable ) { MST[rv.ROR1Mutator]MSP[N] while ( reuse != header && reuse != null ) { if ( removeLRU ( reuse ) ) { removeLRUEntry = true ; break; } reuse = reuse . after ; } if ( reuse == null ) { throw new IllegalStateException (
if ( scanUntilRemovable ) { while ( reuse != header && reuse != null ) { if ( removeLRU ( reuse ) ) { MST[NegateConditionalsMutator]MSP[S] removeLRUEntry = true ; break; } reuse = reuse . after ; } if ( reuse == null ) { throw new IllegalStateException (
loop = loop . next ; } if ( loop == null ) { throw new IllegalStateException ( MST[experimental.NakedReceiverMutator]MSP[N] lr_12 + data [ removeIndex ] + lr_13 + previous + lr_6 + key + lr_7 + value + lr_8 + size + lr_9 + maxSize + lr_2 ) ; }
if ( entry == null ) { return null ; } if ( updateToMRU ) { MST[rv.ROR5Mutator]MSP[N] moveToMRU ( entry ) ; } return entry . getValue () ; } protected void moveToMRU ( final LinkEntry < K , V > entry ) {
modCount ++ ; removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; MST[rv.UOI2Mutator]MSP[S] addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException (
modCount ++ ; removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException ( MST[NonVoidMethodCallMutator]MSP[S]
} @Override public boolean isFull () { return size >= maxSize ; MST[rv.CRCR2Mutator]MSP[N] } @Override public int maxSize () { return maxSize ; } public boolean isScanUntilRemovable () { return scanUntilRemovable ; } @Override public LRUMap < K , V > clone () {
loop = loop . next ; } if ( loop == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] throw new IllegalStateException ( lr_12 + data [ removeIndex ] + lr_13 + previous + lr_6 + key + lr_7 + value + lr_8 + size + lr_9 + maxSize + lr_2 ) ; }
if ( entry == null ) { return null ; } if ( updateToMRU ) { MST[rv.ROR2Mutator]MSP[N] moveToMRU ( entry ) ; } return entry . getValue () ; } protected void moveToMRU ( final LinkEntry < K , V > entry ) {
throw new IllegalStateException ( lr_3 + lr_2 ) ; } } @Override protected void updateEntry ( final HashEntry < K , V > entry , final V newValue ) { moveToMRU ( ( LinkEntry < K , V > ) entry ) ; entry . setValue ( newValue ) ; MST[NonVoidMethodCallMutator]MSP[N]
if ( entry . after != header ) { modCount ++ ; MST[rv.AOR2Mutator]MSP[N] if ( entry . before == null ) { throw new IllegalStateException ( lr_1 + lr_2 ) ; } entry . before . after = entry . after ;
loop = loop . next ; } if ( loop == null ) { throw new IllegalStateException ( MST[rv.UOI2Mutator]MSP[N] lr_12 + data [ removeIndex ] + lr_13 + previous + lr_6 + key + lr_7 + value + lr_8 + size + lr_9 + maxSize + lr_2 ) ; }
entry . after . before = entry . before ; entry . after = header ; MST[experimental.MemberVariableMutator]MSP[N] entry . before = header . before ; header . before . after = entry ; header . before = entry ; } else if ( entry == header ) {
loop = loop . next ; } if ( loop == null ) { throw new IllegalStateException ( MST[NonVoidMethodCallMutator]MSP[N] lr_12 + data [ removeIndex ] + lr_13 + previous + lr_6 + key + lr_7 + value + lr_8 + size + lr_9 + maxSize + lr_2 ) ; }
if ( entry . after != header ) { modCount ++ ; MST[rv.UOI4Mutator]MSP[N] if ( entry . before == null ) { throw new IllegalStateException ( lr_1 + lr_2 ) ; } entry . before . after = entry . after ;
reuseMapping ( reuse , hashIndex , hashCode , key , value ) ; MST[rv.UOI3Mutator]MSP[N] } else { super . addMapping ( hashIndex , hashCode , key , value ) ; } } else { super . addMapping ( hashIndex , hashCode , key , value ) ; } }
loop = loop . next ; } if ( loop == null ) { throw new IllegalStateException ( MST[rv.UOI2Mutator]MSP[N] lr_12 + data [ removeIndex ] + lr_13 + previous + lr_6 + key + lr_7 + value + lr_8 + size + lr_9 + maxSize + lr_2 ) ; }
if ( scanUntilRemovable ) { MST[NegateConditionalsMutator]MSP[N] while ( reuse != header && reuse != null ) { if ( removeLRU ( reuse ) ) { removeLRUEntry = true ; break; } reuse = reuse . after ; } if ( reuse == null ) { throw new IllegalStateException (
modCount ++ ; removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException ( MST[rv.CRCR3Mutator]MSP[N]
if ( scanUntilRemovable ) { while ( reuse != header && reuse != null ) { if ( removeLRU ( reuse ) ) { MST[rv.ROR1Mutator]MSP[N] removeLRUEntry = true ; break; } reuse = reuse . after ; } if ( reuse == null ) { throw new IllegalStateException (
protected void doReadObject ( final ObjectInputStream in ) throws IOException , ClassNotFoundException { maxSize = in . readInt () ; MST[NonVoidMethodCallMutator]MSP[N] super . doReadObject ( in ) ; }
if ( entry . after != header ) { modCount ++ ; MST[experimental.MemberVariableMutator]MSP[N] if ( entry . before == null ) { throw new IllegalStateException ( lr_1 + lr_2 ) ; } entry . before . after = entry . after ;
loop = loop . next ; } if ( loop == null ) { throw new IllegalStateException ( MST[experimental.NakedReceiverMutator]MSP[N] lr_12 + data [ removeIndex ] + lr_13 + previous + lr_6 + key + lr_7 + value + lr_8 + size + lr_9 + maxSize + lr_2 ) ; }
} @Override public boolean isFull () { return size >= maxSize ; MST[rv.CRCR3Mutator]MSP[N] } @Override public int maxSize () { return maxSize ; } public boolean isScanUntilRemovable () { return scanUntilRemovable ; } @Override public LRUMap < K , V > clone () {
modCount ++ ; removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException ( MST[experimental.NakedReceiverMutator]MSP[N]
if ( reuse == null ) { MST[rv.ROR5Mutator]MSP[S] throw new IllegalStateException ( lr_11 + header . after + lr_5 + header . before + lr_6 + key + lr_7 + value + lr_8 + size + lr_9 + maxSize + lr_10 ) ; }
loop = loop . next ; } if ( loop == null ) { throw new IllegalStateException ( MST[NonVoidMethodCallMutator]MSP[N] lr_12 + data [ removeIndex ] + lr_13 + previous + lr_6 + key + lr_7 + value + lr_8 + size + lr_9 + maxSize + lr_2 ) ; }
} @Override protected void addMapping ( final int hashIndex , final int hashCode , final K key , final V value ) { if ( isFull () ) { MST[rv.ROR2Mutator]MSP[N] LinkEntry < K , V > reuse = header . after ; boolean removeLRUEntry = false ;
final HashEntry < K , V > [] tmp = data ; HashEntry < K , V > loop = tmp [ removeIndex ] ; HashEntry < K , V > previous = null ; while ( loop != entry && loop != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] previous = loop ;
protected void reuseMapping ( final LinkEntry < K , V > entry , final int hashIndex , final int hashCode , final K key , final V value ) { try { final int removeIndex = hashIndex ( entry . hashCode , data . length ) ; MST[ArgumentPropagationMutator]MSP[S]
} @Override public boolean isFull () { return size >= maxSize ; MST[rv.UOI3Mutator]MSP[N] } @Override public int maxSize () { return maxSize ; } public boolean isScanUntilRemovable () { return scanUntilRemovable ; } @Override public LRUMap < K , V > clone () {
lr_14 + entry + lr_15 + ( entry == header ) + lr_6 + key + lr_7 + value + lr_8 + size + lr_9 + maxSize + lr_2 ) ; } } protected boolean removeLRU ( final LinkEntry < K , V > entry ) { return true ; MST[rv.CRCR5Mutator]MSP[N]
reuseMapping ( reuse , hashIndex , hashCode , key , value ) ; MST[rv.UOI2Mutator]MSP[N] } else { super . addMapping ( hashIndex , hashCode , key , value ) ; } } else { super . addMapping ( hashIndex , hashCode , key , value ) ; } }
if ( scanUntilRemovable ) { while ( reuse != header && reuse != null ) { MST[NegateConditionalsMutator]MSP[S] if ( removeLRU ( reuse ) ) { removeLRUEntry = true ; break; } reuse = reuse . after ; } if ( reuse == null ) { throw new IllegalStateException (
loop = loop . next ; } if ( loop == null ) { throw new IllegalStateException ( MST[experimental.NakedReceiverMutator]MSP[N] lr_12 + data [ removeIndex ] + lr_13 + previous + lr_6 + key + lr_7 + value + lr_8 + size + lr_9 + maxSize + lr_2 ) ; }
} @Override public boolean isFull () { return size >= maxSize ; } @Override public int maxSize () { return maxSize ; } public boolean isScanUntilRemovable () { return scanUntilRemovable ; MST[BooleanFalseReturnValsMutator]MSP[N] } @Override public LRUMap < K , V > clone () {
if ( scanUntilRemovable ) { while ( reuse != header && reuse != null ) { if ( removeLRU ( reuse ) ) { removeLRUEntry = true ; break; } reuse = reuse . after ; } if ( reuse == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] throw new IllegalStateException (
} @Override public boolean isFull () { return size >= maxSize ; } @Override public int maxSize () { return maxSize ; MST[rv.UOI3Mutator]MSP[N] } public boolean isScanUntilRemovable () { return scanUntilRemovable ; } @Override public LRUMap < K , V > clone () {
lr_4 + header . after + lr_5 + header . before + lr_6 + key + lr_7 + value + lr_8 + size + lr_9 + maxSize + lr_10 ) ; } } else { removeLRUEntry = removeLRU ( reuse ) ; } if ( removeLRUEntry ) { MST[rv.UOI1Mutator]MSP[N]
@Override public V get ( final Object key ) { return get ( key , true ) ; MST[ReturnValsMutator]MSP[S] } public V get ( final Object key , final boolean updateToMRU ) { final LinkEntry < K , V > entry = getEntry ( key ) ;
if ( entry . after != header ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] modCount ++ ; if ( entry . before == null ) { throw new IllegalStateException ( lr_1 + lr_2 ) ; } entry . before . after = entry . after ;
modCount ++ ; MST[MathMutator]MSP[N] removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException (
modCount ++ ; removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException ( MST[InlineConstantMutator]MSP[N]
if ( entry == null ) { return null ; } if ( updateToMRU ) { moveToMRU ( entry ) ; } return entry . getValue () ; MST[NullReturnValsMutator]MSP[S] } protected void moveToMRU ( final LinkEntry < K , V > entry ) {
if ( scanUntilRemovable ) { while ( reuse != header && reuse != null ) { if ( removeLRU ( reuse ) ) { removeLRUEntry = true ; break; } reuse = reuse . after ; } if ( reuse == null ) { MST[rv.ROR5Mutator]MSP[S] throw new IllegalStateException (
reuseMapping ( reuse , hashIndex , hashCode , key , value ) ; } else { super . addMapping ( hashIndex , hashCode , key , value ) ; } } else { super . addMapping ( hashIndex , hashCode , key , value ) ; MST[rv.ABSMutator]MSP[N] } }
loop = loop . next ; } if ( loop == null ) { throw new IllegalStateException ( MST[rv.ABSMutator]MSP[N] lr_12 + data [ removeIndex ] + lr_13 + previous + lr_6 + key + lr_7 + value + lr_8 + size + lr_9 + maxSize + lr_2 ) ; }
modCount ++ ; MST[rv.UOI1Mutator]MSP[N] removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException (
lr_4 + header . after + lr_5 + header . before + lr_6 + key + lr_7 + value + lr_8 + size + lr_9 + maxSize + lr_10 ) ; } } else { removeLRUEntry = removeLRU ( reuse ) ; } if ( removeLRUEntry ) { MST[rv.ROR2Mutator]MSP[N]
} @Override protected void addMapping ( final int hashIndex , final int hashCode , final K key , final V value ) { if ( isFull () ) { LinkEntry < K , V > reuse = header . after ; boolean removeLRUEntry = false ; MST[InlineConstantMutator]MSP[N]
modCount ++ ; removeEntry ( entry , removeIndex , previous ) ; MST[rv.UOI3Mutator]MSP[S] reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException (
modCount ++ ; removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException ( MST[rv.ABSMutator]MSP[N]
final HashEntry < K , V > [] tmp = data ; HashEntry < K , V > loop = tmp [ removeIndex ] ; MST[rv.UOI4Mutator]MSP[S] HashEntry < K , V > previous = null ; while ( loop != entry && loop != null ) { previous = loop ;
} @Override protected void addMapping ( final int hashIndex , final int hashCode , final K key , final V value ) { if ( isFull () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] LinkEntry < K , V > reuse = header . after ; boolean removeLRUEntry = false ;
} @Override protected void addMapping ( final int hashIndex , final int hashCode , final K key , final V value ) { if ( isFull () ) { MST[rv.ROR1Mutator]MSP[N] LinkEntry < K , V > reuse = header . after ; boolean removeLRUEntry = false ;
} @Override protected void addMapping ( final int hashIndex , final int hashCode , final K key , final V value ) { if ( isFull () ) { MST[rv.ROR5Mutator]MSP[N] LinkEntry < K , V > reuse = header . after ; boolean removeLRUEntry = false ;
final HashEntry < K , V > [] tmp = data ; HashEntry < K , V > loop = tmp [ removeIndex ] ; MST[rv.UOI2Mutator]MSP[S] HashEntry < K , V > previous = null ; while ( loop != entry && loop != null ) { previous = loop ;
final HashEntry < K , V > [] tmp = data ; HashEntry < K , V > loop = tmp [ removeIndex ] ; HashEntry < K , V > previous = null ; while ( loop != entry && loop != null ) { MST[NegateConditionalsMutator]MSP[N] previous = loop ;
lr_14 + entry + lr_15 + ( entry == header ) + lr_6 + key + lr_7 + value + lr_8 + size + lr_9 + maxSize + lr_2 ) ; } } protected boolean removeLRU ( final LinkEntry < K , V > entry ) { return true ; MST[ReturnValsMutator]MSP[N]
entry . after . before = entry . before ; entry . after = header ; entry . before = header . before ; header . before . after = entry ; MST[experimental.MemberVariableMutator]MSP[N] header . before = entry ; } else if ( entry == header ) {
if ( entry . after != header ) { MST[NegateConditionalsMutator]MSP[N] modCount ++ ; if ( entry . before == null ) { throw new IllegalStateException ( lr_1 + lr_2 ) ; } entry . before . after = entry . after ;
modCount ++ ; removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException ( MST[experimental.NakedReceiverMutator]MSP[N]
} @Override public boolean isFull () { return size >= maxSize ; MST[ConditionalsBoundaryMutator]MSP[N] } @Override public int maxSize () { return maxSize ; } public boolean isScanUntilRemovable () { return scanUntilRemovable ; } @Override public LRUMap < K , V > clone () {
if ( entry == null ) { return null ; } if ( updateToMRU ) { MST[NegateConditionalsMutator]MSP[N] moveToMRU ( entry ) ; } return entry . getValue () ; } protected void moveToMRU ( final LinkEntry < K , V > entry ) {
protected void reuseMapping ( final LinkEntry < K , V > entry , final int hashIndex , final int hashCode , final K key , final V value ) { try { final int removeIndex = hashIndex ( entry . hashCode , data . length ) ; MST[rv.UOI3Mutator]MSP[S]
return ( LRUMap < K , V > ) super . clone () ; } private void writeObject ( final ObjectOutputStream out ) throws IOException { out . defaultWriteObject () ; doWriteObject ( out ) ; MST[VoidMethodCallMutator]MSP[S] } private void readObject ( final ObjectInputStream in ) throws IOException , ClassNotFoundException {
modCount ++ ; removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException ( MST[experimental.NakedReceiverMutator]MSP[N]
modCount ++ ; removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException ( MST[NonVoidMethodCallMutator]MSP[S]
} @Override public boolean isFull () { return size >= maxSize ; } @Override public int maxSize () { return maxSize ; MST[ReturnValsMutator]MSP[N] } public boolean isScanUntilRemovable () { return scanUntilRemovable ; } @Override public LRUMap < K , V > clone () {
if ( reuse == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] throw new IllegalStateException ( lr_11 + header . after + lr_5 + header . before + lr_6 + key + lr_7 + value + lr_8 + size + lr_9 + maxSize + lr_10 ) ; }
modCount ++ ; removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; MST[rv.UOI3Mutator]MSP[N] } catch ( final NullPointerException ex ) { throw new IllegalStateException (
final HashEntry < K , V > [] tmp = data ; HashEntry < K , V > loop = tmp [ removeIndex ] ; MST[rv.ABSMutator]MSP[S] HashEntry < K , V > previous = null ; while ( loop != entry && loop != null ) { previous = loop ;
modCount ++ ; removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException ( MST[experimental.NakedReceiverMutator]MSP[N]
} @Override public boolean isFull () { return size >= maxSize ; MST[rv.CRCR1Mutator]MSP[N] } @Override public int maxSize () { return maxSize ; } public boolean isScanUntilRemovable () { return scanUntilRemovable ; } @Override public LRUMap < K , V > clone () {
loop = loop . next ; } if ( loop == null ) { throw new IllegalStateException ( MST[NonVoidMethodCallMutator]MSP[N] lr_12 + data [ removeIndex ] + lr_13 + previous + lr_6 + key + lr_7 + value + lr_8 + size + lr_9 + maxSize + lr_2 ) ; }
if ( scanUntilRemovable ) { while ( reuse != header && reuse != null ) { if ( removeLRU ( reuse ) ) { removeLRUEntry = true ; MST[rv.CRCR6Mutator]MSP[S] break; } reuse = reuse . after ; } if ( reuse == null ) { throw new IllegalStateException (
modCount ++ ; removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException ( MST[rv.UOI2Mutator]MSP[N]
final HashEntry < K , V > [] tmp = data ; HashEntry < K , V > loop = tmp [ removeIndex ] ; HashEntry < K , V > previous = null ; while ( loop != entry && loop != null ) { MST[rv.ROR5Mutator]MSP[N] previous = loop ;
modCount ++ ; MST[rv.AOR2Mutator]MSP[N] removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException (
loop = loop . next ; } if ( loop == null ) { throw new IllegalStateException ( MST[NonVoidMethodCallMutator]MSP[N] lr_12 + data [ removeIndex ] + lr_13 + previous + lr_6 + key + lr_7 + value + lr_8 + size + lr_9 + maxSize + lr_2 ) ; }
loop = loop . next ; } if ( loop == null ) { throw new IllegalStateException ( MST[rv.UOI2Mutator]MSP[N] lr_12 + data [ removeIndex ] + lr_13 + previous + lr_6 + key + lr_7 + value + lr_8 + size + lr_9 + maxSize + lr_2 ) ; }
in . defaultReadObject () ; doReadObject ( in ) ; } @Override protected void doWriteObject ( final ObjectOutputStream out ) throws IOException { out . writeInt ( maxSize ) ; MST[rv.UOI3Mutator]MSP[N] super . doWriteObject ( out ) ; } @Override
if ( entry == null ) { return null ; } if ( updateToMRU ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] moveToMRU ( entry ) ; } return entry . getValue () ; } protected void moveToMRU ( final LinkEntry < K , V > entry ) {
} @Override public boolean isFull () { return size >= maxSize ; MST[rv.UOI3Mutator]MSP[N] } @Override public int maxSize () { return maxSize ; } public boolean isScanUntilRemovable () { return scanUntilRemovable ; } @Override public LRUMap < K , V > clone () {
if ( scanUntilRemovable ) { MST[rv.ROR5Mutator]MSP[N] while ( reuse != header && reuse != null ) { if ( removeLRU ( reuse ) ) { removeLRUEntry = true ; break; } reuse = reuse . after ; } if ( reuse == null ) { throw new IllegalStateException (
loop = loop . next ; } if ( loop == null ) { MST[NegateConditionalsMutator]MSP[S] throw new IllegalStateException ( lr_12 + data [ removeIndex ] + lr_13 + previous + lr_6 + key + lr_7 + value + lr_8 + size + lr_9 + maxSize + lr_2 ) ; }
if ( entry == null ) { return null ; } if ( updateToMRU ) { MST[rv.ROR3Mutator]MSP[N] moveToMRU ( entry ) ; } return entry . getValue () ; } protected void moveToMRU ( final LinkEntry < K , V > entry ) {
if ( entry == null ) { return null ; } if ( updateToMRU ) { MST[rv.ROR4Mutator]MSP[N] moveToMRU ( entry ) ; } return entry . getValue () ; } protected void moveToMRU ( final LinkEntry < K , V > entry ) {
if ( reuse == null ) { MST[NegateConditionalsMutator]MSP[S] throw new IllegalStateException ( lr_11 + header . after + lr_5 + header . before + lr_6 + key + lr_7 + value + lr_8 + size + lr_9 + maxSize + lr_10 ) ; }
modCount ++ ; removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; MST[rv.UOI1Mutator]MSP[N] addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException (
if ( entry == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] return null ; } if ( updateToMRU ) { moveToMRU ( entry ) ; } return entry . getValue () ; } protected void moveToMRU ( final LinkEntry < K , V > entry ) {
if ( entry . after != header ) { modCount ++ ; MST[rv.CRCR4Mutator]MSP[N] if ( entry . before == null ) { throw new IllegalStateException ( lr_1 + lr_2 ) ; } entry . before . after = entry . after ;
} @Override public boolean isFull () { return size >= maxSize ; } @Override public int maxSize () { return maxSize ; MST[PrimitiveReturnsMutator]MSP[N] } public boolean isScanUntilRemovable () { return scanUntilRemovable ; } @Override public LRUMap < K , V > clone () {
if ( scanUntilRemovable ) { while ( reuse != header && reuse != null ) { if ( removeLRU ( reuse ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] removeLRUEntry = true ; break; } reuse = reuse . after ; } if ( reuse == null ) { throw new IllegalStateException (
} @Override public boolean isFull () { return size >= maxSize ; MST[rv.CRCR6Mutator]MSP[N] } @Override public int maxSize () { return maxSize ; } public boolean isScanUntilRemovable () { return scanUntilRemovable ; } @Override public LRUMap < K , V > clone () {
reuseMapping ( reuse , hashIndex , hashCode , key , value ) ; } else { super . addMapping ( hashIndex , hashCode , key , value ) ; } } else { super . addMapping ( hashIndex , hashCode , key , value ) ; MST[rv.UOI4Mutator]MSP[N] } }
modCount ++ ; removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException ( MST[ConstructorCallMutator]MSP[S]
in . defaultReadObject () ; doReadObject ( in ) ; } @Override protected void doWriteObject ( final ObjectOutputStream out ) throws IOException { out . writeInt ( maxSize ) ; MST[rv.UOI4Mutator]MSP[N] super . doWriteObject ( out ) ; } @Override
final HashEntry < K , V > [] tmp = data ; HashEntry < K , V > loop = tmp [ removeIndex ] ; HashEntry < K , V > previous = null ; while ( loop != entry && loop != null ) { MST[NegateConditionalsMutator]MSP[S] previous = loop ;
return ( LRUMap < K , V > ) super . clone () ; MST[NullReturnValsMutator]MSP[S] } private void writeObject ( final ObjectOutputStream out ) throws IOException { out . defaultWriteObject () ; doWriteObject ( out ) ; } private void readObject ( final ObjectInputStream in ) throws IOException , ClassNotFoundException {
if ( entry . after != header ) { modCount ++ ; MST[rv.UOI3Mutator]MSP[N] if ( entry . before == null ) { throw new IllegalStateException ( lr_1 + lr_2 ) ; } entry . before . after = entry . after ;
reuseMapping ( reuse , hashIndex , hashCode , key , value ) ; MST[rv.UOI2Mutator]MSP[N] } else { super . addMapping ( hashIndex , hashCode , key , value ) ; } } else { super . addMapping ( hashIndex , hashCode , key , value ) ; } }
} @Override public boolean isFull () { return size >= maxSize ; } @Override public int maxSize () { return maxSize ; MST[rv.ABSMutator]MSP[N] } public boolean isScanUntilRemovable () { return scanUntilRemovable ; } @Override public LRUMap < K , V > clone () {
} @Override protected void addMapping ( final int hashIndex , final int hashCode , final K key , final V value ) { if ( isFull () ) { LinkEntry < K , V > reuse = header . after ; boolean removeLRUEntry = false ; MST[rv.CRCR3Mutator]MSP[N]
@Override public V get ( final Object key ) { return get ( key , true ) ; } public V get ( final Object key , final boolean updateToMRU ) { final LinkEntry < K , V > entry = getEntry ( key ) ; MST[NonVoidMethodCallMutator]MSP[S]
if ( entry == null ) { return null ; } if ( updateToMRU ) { MST[rv.UOI1Mutator]MSP[N] moveToMRU ( entry ) ; } return entry . getValue () ; } protected void moveToMRU ( final LinkEntry < K , V > entry ) {
protected void reuseMapping ( final LinkEntry < K , V > entry , final int hashIndex , final int hashCode , final K key , final V value ) { try { final int removeIndex = hashIndex ( entry . hashCode , data . length ) ; MST[rv.UOI4Mutator]MSP[S]
modCount ++ ; MST[rv.CRCR3Mutator]MSP[N] removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException (
@Override public V get ( final Object key ) { return get ( key , true ) ; MST[rv.CRCR6Mutator]MSP[N] } public V get ( final Object key , final boolean updateToMRU ) { final LinkEntry < K , V > entry = getEntry ( key ) ;
} @Override public boolean isFull () { return size >= maxSize ; MST[rv.ROR1Mutator]MSP[N] } @Override public int maxSize () { return maxSize ; } public boolean isScanUntilRemovable () { return scanUntilRemovable ; } @Override public LRUMap < K , V > clone () {
modCount ++ ; removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException ( MST[experimental.NakedReceiverMutator]MSP[N]
modCount ++ ; removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; MST[rv.UOI1Mutator]MSP[N] addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException (
} @Override public boolean isFull () { return size >= maxSize ; MST[rv.ABSMutator]MSP[N] } @Override public int maxSize () { return maxSize ; } public boolean isScanUntilRemovable () { return scanUntilRemovable ; } @Override public LRUMap < K , V > clone () {
if ( scanUntilRemovable ) { while ( reuse != header && reuse != null ) { if ( removeLRU ( reuse ) ) { MST[rv.ROR5Mutator]MSP[S] removeLRUEntry = true ; break; } reuse = reuse . after ; } if ( reuse == null ) { throw new IllegalStateException (
modCount ++ ; MST[experimental.MemberVariableMutator]MSP[N] removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException (
modCount ++ ; removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; MST[rv.UOI4Mutator]MSP[N] } catch ( final NullPointerException ex ) { throw new IllegalStateException (
modCount ++ ; removeEntry ( entry , removeIndex , previous ) ; reuseEntry ( entry , hashIndex , hashCode , key , value ) ; MST[VoidMethodCallMutator]MSP[N] addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException (
if ( scanUntilRemovable ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] while ( reuse != header && reuse != null ) { if ( removeLRU ( reuse ) ) { removeLRUEntry = true ; break; } reuse = reuse . after ; } if ( reuse == null ) { throw new IllegalStateException (
reuseMapping ( reuse , hashIndex , hashCode , key , value ) ; } else { super . addMapping ( hashIndex , hashCode , key , value ) ; } } else { super . addMapping ( hashIndex , hashCode , key , value ) ; MST[rv.ABSMutator]MSP[N] } }
loop = loop . next ; } if ( loop == null ) { throw new IllegalStateException ( MST[NonVoidMethodCallMutator]MSP[N] lr_12 + data [ removeIndex ] + lr_13 + previous + lr_6 + key + lr_7 + value + lr_8 + size + lr_9 + maxSize + lr_2 ) ; }
modCount ++ ; removeEntry ( entry , removeIndex , previous ) ; MST[rv.UOI4Mutator]MSP[S] reuseEntry ( entry , hashIndex , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; } catch ( final NullPointerException ex ) { throw new IllegalStateException (
if ( entry . after != header ) { modCount ++ ; MST[rv.AOR3Mutator]MSP[N] if ( entry . before == null ) { throw new IllegalStateException ( lr_1 + lr_2 ) ; } entry . before . after = entry . after ;
reuseMapping ( reuse , hashIndex , hashCode , key , value ) ; } else { super . addMapping ( hashIndex , hashCode , key , value ) ; } } else { super . addMapping ( hashIndex , hashCode , key , value ) ; MST[rv.UOI4Mutator]MSP[N] } }
final HashEntry < K , V > [] tmp = data ; HashEntry < K , V > loop = tmp [ removeIndex ] ; MST[rv.UOI3Mutator]MSP[S] HashEntry < K , V > previous = null ; while ( loop != entry && loop != null ) { previous = loop ;
loop = loop . next ; } if ( loop == null ) { throw new IllegalStateException ( MST[rv.UOI1Mutator]MSP[N] lr_12 + data [ removeIndex ] + lr_13 + previous + lr_6 + key + lr_7 + value + lr_8 + size + lr_9 + maxSize + lr_2 ) ; }
if ( scanUntilRemovable ) { while ( reuse != header && reuse != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] if ( removeLRU ( reuse ) ) { removeLRUEntry = true ; break; } reuse = reuse . after ; } if ( reuse == null ) { throw new IllegalStateException (
in . defaultReadObject () ; doReadObject ( in ) ; } @Override protected void doWriteObject ( final ObjectOutputStream out ) throws IOException { out . writeInt ( maxSize ) ; MST[rv.ABSMutator]MSP[S] super . doWriteObject ( out ) ; } @Override
