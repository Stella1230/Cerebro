final int index1 = beginIndex1 + i ; final int index2 = beginIndex2 + i ; MST[rv.AOD2Mutator]MSP[] if ( index1 >= endIndex1 ) { k = 0 ; } else { k = key . charAt ( index1 ) ; }
if ( other == null || index2 >= endIndex2 ) { MST[rv.UOI1Mutator]MSP[] f = 0 ; } else { f = other . charAt ( index2 ) ; } if ( k != f ) { final int x = k ^ f ;
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; MST[rv.AOD1Mutator]MSP[] } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
final int endIndex2 = beginIndex2 + otherLengthInBits / LENGTH ; MST[rv.UOI2Mutator]MSP[] final int length = Math . max ( endIndex1 , endIndex2 ) ; char k = 0 , f = 0 ; for ( int i = 0 ; i < length ; i ++ ) {
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { MST[rv.ROR4Mutator]MSP[] return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
final int endIndex2 = beginIndex2 + otherLengthInBits / LENGTH ; final int length = Math . max ( endIndex1 , endIndex2 ) ; MST[rv.UOI4Mutator]MSP[] char k = 0 , f = 0 ; for ( int i = 0 ; i < length ; i ++ ) {
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; MST[rv.CRCR2Mutator]MSP[] } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
return ( key . charAt ( index ) & mask ( bit ) ) != 0 ; MST[rv.UOI3Mutator]MSP[] } @Override public boolean isPrefix ( final String prefix , final int offsetInBits , final int lengthInBits , final String key ) {
final int endIndex2 = beginIndex2 + otherLengthInBits / LENGTH ; MST[InlineConstantMutator]MSP[] final int length = Math . max ( endIndex1 , endIndex2 ) ; char k = 0 , f = 0 ; for ( int i = 0 ; i < length ; i ++ ) {
private static int mask ( final int bit ) { return MSB >>> bit ; } @Override public int bitsPerElement () { return LENGTH ; } @Override public int lengthInBits ( final String key ) { return key != null ? key . length () * LENGTH : 0 ; MST[rv.AOR2Mutator]MSP[]
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
|| lengthInBits % LENGTH != 0 || otherLengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } final int beginIndex1 = offsetInBits / LENGTH ; final int beginIndex2 = otherOffsetInBits / LENGTH ; final int endIndex1 = beginIndex1 + lengthInBits / LENGTH ; MST[rv.UOI4Mutator]MSP[]
final int endIndex2 = beginIndex2 + otherLengthInBits / LENGTH ; final int length = Math . max ( endIndex1 , endIndex2 ) ; char k = 0 , f = 0 ; for ( int i = 0 ; i < length ; i ++ ) { MST[rv.CRCR3Mutator]MSP[]
final int endIndex2 = beginIndex2 + otherLengthInBits / LENGTH ; MST[rv.ABSMutator]MSP[] final int length = Math . max ( endIndex1 , endIndex2 ) ; char k = 0 , f = 0 ; for ( int i = 0 ; i < length ; i ++ ) {
if ( other == null || index2 >= endIndex2 ) { f = 0 ; } else { f = other . charAt ( index2 ) ; } if ( k != f ) { final int x = k ^ f ; MST[MathMutator]MSP[]
|| lengthInBits % LENGTH != 0 || otherLengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } final int beginIndex1 = offsetInBits / LENGTH ; final int beginIndex2 = otherOffsetInBits / LENGTH ; final int endIndex1 = beginIndex1 + lengthInBits / LENGTH ; MST[rv.AOR1Mutator]MSP[]
final int endIndex2 = beginIndex2 + otherLengthInBits / LENGTH ; final int length = Math . max ( endIndex1 , endIndex2 ) ; char k = 0 , f = 0 ; MST[rv.CRCR6Mutator]MSP[] for ( int i = 0 ; i < length ; i ++ ) {
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; MST[rv.UOI1Mutator]MSP[] return key . startsWith ( s1 ) ; }
final int index1 = beginIndex1 + i ; final int index2 = beginIndex2 + i ; if ( index1 >= endIndex1 ) { k = 0 ; } else { k = key . charAt ( index1 ) ; MST[rv.UOI3Mutator]MSP[] }
final int index1 = beginIndex1 + i ; MST[rv.UOI1Mutator]MSP[] final int index2 = beginIndex2 + i ; if ( index1 >= endIndex1 ) { k = 0 ; } else { k = key . charAt ( index1 ) ; }
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; MST[ReturnValsMutator]MSP[] } @Override
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; MST[rv.UOI1Mutator]MSP[] } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
private static int mask ( final int bit ) { return MSB >>> bit ; } @Override public int bitsPerElement () { return LENGTH ; } @Override public int lengthInBits ( final String key ) { return key != null ? key . length () * LENGTH : 0 ; MST[InlineConstantMutator]MSP[]
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.UOI1Mutator]MSP[]
|| lengthInBits % LENGTH != 0 || otherLengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } final int beginIndex1 = offsetInBits / LENGTH ; MST[rv.AOR2Mutator]MSP[] final int beginIndex2 = otherOffsetInBits / LENGTH ; final int endIndex1 = beginIndex1 + lengthInBits / LENGTH ;
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { MST[rv.ROR1Mutator]MSP[] throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; return key . startsWith ( s1 ) ; }
public boolean isBitSet ( final String key , final int bitIndex , final int lengthInBits ) { if ( key == null || bitIndex >= lengthInBits ) { return false ; } final int index = bitIndex / LENGTH ; MST[rv.CRCR4Mutator]MSP[] final int bit = bitIndex % LENGTH ;
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { MST[rv.CRCR4Mutator]MSP[] throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; return key . startsWith ( s1 ) ; }
if ( other == null || index2 >= endIndex2 ) { f = 0 ; } else { f = other . charAt ( index2 ) ; } if ( k != f ) { MST[rv.UOI2Mutator]MSP[] final int x = k ^ f ;
if ( other == null || index2 >= endIndex2 ) { f = 0 ; } else { f = other . charAt ( index2 ) ; } if ( k != f ) { final int x = k ^ f ; MST[rv.UOI3Mutator]MSP[]
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { MST[rv.ROR5Mutator]MSP[] throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; return key . startsWith ( s1 ) ; }
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.ROR2Mutator]MSP[]
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[NegateConditionalsMutator]MSP[]
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.AOR1Mutator]MSP[]
if ( other == null || index2 >= endIndex2 ) { f = 0 ; } else { f = other . charAt ( index2 ) ; } if ( k != f ) { MST[rv.ABSMutator]MSP[] final int x = k ^ f ;
return ( key . charAt ( index ) & mask ( bit ) ) != 0 ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] } @Override public boolean isPrefix ( final String prefix , final int offsetInBits , final int lengthInBits , final String key ) {
public boolean isBitSet ( final String key , final int bitIndex , final int lengthInBits ) { if ( key == null || bitIndex >= lengthInBits ) { MST[rv.UOI1Mutator]MSP[] return false ; } final int index = bitIndex / LENGTH ; final int bit = bitIndex % LENGTH ;
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.ROR4Mutator]MSP[]
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.UOI3Mutator]MSP[]
if ( other == null || index2 >= endIndex2 ) { f = 0 ; } else { f = other . charAt ( index2 ) ; } if ( k != f ) { MST[rv.ROR3Mutator]MSP[] final int x = k ^ f ;
if ( other == null || index2 >= endIndex2 ) { MST[rv.UOI1Mutator]MSP[] f = 0 ; } else { f = other . charAt ( index2 ) ; } if ( k != f ) { final int x = k ^ f ;
final int endIndex2 = beginIndex2 + otherLengthInBits / LENGTH ; final int length = Math . max ( endIndex1 , endIndex2 ) ; MST[rv.UOI4Mutator]MSP[] char k = 0 , f = 0 ; for ( int i = 0 ; i < length ; i ++ ) {
public boolean isBitSet ( final String key , final int bitIndex , final int lengthInBits ) { if ( key == null || bitIndex >= lengthInBits ) { return false ; } final int index = bitIndex / LENGTH ; MST[rv.UOI4Mutator]MSP[] final int bit = bitIndex % LENGTH ;
final int index1 = beginIndex1 + i ; MST[rv.AOR2Mutator]MSP[] final int index2 = beginIndex2 + i ; if ( index1 >= endIndex1 ) { k = 0 ; } else { k = key . charAt ( index1 ) ; }
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; MST[rv.AOR2Mutator]MSP[] } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
public boolean isBitSet ( final String key , final int bitIndex , final int lengthInBits ) { if ( key == null || bitIndex >= lengthInBits ) { return false ; } final int index = bitIndex / LENGTH ; final int bit = bitIndex % LENGTH ; MST[rv.UOI1Mutator]MSP[]
final int index1 = beginIndex1 + i ; final int index2 = beginIndex2 + i ; MST[rv.AOR4Mutator]MSP[] if ( index1 >= endIndex1 ) { k = 0 ; } else { k = key . charAt ( index1 ) ; }
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; return key . startsWith ( s1 ) ; }
if ( other == null || index2 >= endIndex2 ) { f = 0 ; } else { f = other . charAt ( index2 ) ; } if ( k != f ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] final int x = k ^ f ;
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; MST[rv.CRCR1Mutator]MSP[] } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; MST[rv.CRCR5Mutator]MSP[] } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
|| lengthInBits % LENGTH != 0 || otherLengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } final int beginIndex1 = offsetInBits / LENGTH ; final int beginIndex2 = otherOffsetInBits / LENGTH ; MST[rv.AOD2Mutator]MSP[] final int endIndex1 = beginIndex1 + lengthInBits / LENGTH ;
|| lengthInBits % LENGTH != 0 || otherLengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } final int beginIndex1 = offsetInBits / LENGTH ; final int beginIndex2 = otherOffsetInBits / LENGTH ; MST[rv.UOI2Mutator]MSP[] final int endIndex1 = beginIndex1 + lengthInBits / LENGTH ;
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { MST[rv.UOI3Mutator]MSP[] return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
|| lengthInBits % LENGTH != 0 || otherLengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } final int beginIndex1 = offsetInBits / LENGTH ; final int beginIndex2 = otherOffsetInBits / LENGTH ; final int endIndex1 = beginIndex1 + lengthInBits / LENGTH ; MST[rv.UOI4Mutator]MSP[]
|| lengthInBits % LENGTH != 0 || otherLengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } final int beginIndex1 = offsetInBits / LENGTH ; final int beginIndex2 = otherOffsetInBits / LENGTH ; final int endIndex1 = beginIndex1 + lengthInBits / LENGTH ; MST[rv.AOR1Mutator]MSP[]
final int index1 = beginIndex1 + i ; final int index2 = beginIndex2 + i ; MST[MathMutator]MSP[] if ( index1 >= endIndex1 ) { k = 0 ; } else { k = key . charAt ( index1 ) ; }
final int endIndex2 = beginIndex2 + otherLengthInBits / LENGTH ; final int length = Math . max ( endIndex1 , endIndex2 ) ; char k = 0 , f = 0 ; MST[InlineConstantMutator]MSP[] for ( int i = 0 ; i < length ; i ++ ) {
final int index1 = beginIndex1 + i ; MST[rv.UOI1Mutator]MSP[] final int index2 = beginIndex2 + i ; if ( index1 >= endIndex1 ) { k = 0 ; } else { k = key . charAt ( index1 ) ; }
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.ROR5Mutator]MSP[]
final int endIndex2 = beginIndex2 + otherLengthInBits / LENGTH ; MST[rv.CRCR2Mutator]MSP[] final int length = Math . max ( endIndex1 , endIndex2 ) ; char k = 0 , f = 0 ; for ( int i = 0 ; i < length ; i ++ ) {
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { MST[rv.ROR2Mutator]MSP[] throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; return key . startsWith ( s1 ) ; }
final int endIndex2 = beginIndex2 + otherLengthInBits / LENGTH ; MST[rv.CRCR6Mutator]MSP[] final int length = Math . max ( endIndex1 , endIndex2 ) ; char k = 0 , f = 0 ; for ( int i = 0 ; i < length ; i ++ ) {
final int endIndex2 = beginIndex2 + otherLengthInBits / LENGTH ; MST[rv.AOR3Mutator]MSP[] final int length = Math . max ( endIndex1 , endIndex2 ) ; char k = 0 , f = 0 ; for ( int i = 0 ; i < length ; i ++ ) {
final int index1 = beginIndex1 + i ; final int index2 = beginIndex2 + i ; MST[rv.UOI3Mutator]MSP[] if ( index1 >= endIndex1 ) { k = 0 ; } else { k = key . charAt ( index1 ) ; }
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; MST[rv.CRCR4Mutator]MSP[] } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
if ( other == null || index2 >= endIndex2 ) { f = 0 ; } else { f = other . charAt ( index2 ) ; } if ( k != f ) { final int x = k ^ f ; MST[rv.UOI3Mutator]MSP[]
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.UOI2Mutator]MSP[]
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.AOR2Mutator]MSP[]
final int index1 = beginIndex1 + i ; MST[rv.ABSMutator]MSP[] final int index2 = beginIndex2 + i ; if ( index1 >= endIndex1 ) { k = 0 ; } else { k = key . charAt ( index1 ) ; }
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.ROR1Mutator]MSP[]
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { MST[rv.UOI3Mutator]MSP[] throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; return key . startsWith ( s1 ) ; }
public boolean isBitSet ( final String key , final int bitIndex , final int lengthInBits ) { if ( key == null || bitIndex >= lengthInBits ) { MST[rv.UOI1Mutator]MSP[] return false ; } final int index = bitIndex / LENGTH ; final int bit = bitIndex % LENGTH ;
return ( key . charAt ( index ) & mask ( bit ) ) != 0 ; MST[rv.CRCR5Mutator]MSP[] } @Override public boolean isPrefix ( final String prefix , final int offsetInBits , final int lengthInBits , final String key ) {
private static int mask ( final int bit ) { return MSB >>> bit ; MST[MathMutator]MSP[] } @Override public int bitsPerElement () { return LENGTH ; } @Override public int lengthInBits ( final String key ) { return key != null ? key . length () * LENGTH : 0 ;
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; } if ( k != 0 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { MST[MathMutator]MSP[] throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; return key . startsWith ( s1 ) ; }
public boolean isBitSet ( final String key , final int bitIndex , final int lengthInBits ) { if ( key == null || bitIndex >= lengthInBits ) { MST[rv.ROR2Mutator]MSP[] return false ; } final int index = bitIndex / LENGTH ; final int bit = bitIndex % LENGTH ;
return ( key . charAt ( index ) & mask ( bit ) ) != 0 ; MST[rv.OBBN1Mutator]MSP[] } @Override public boolean isPrefix ( final String prefix , final int offsetInBits , final int lengthInBits , final String key ) {
return ( key . charAt ( index ) & mask ( bit ) ) != 0 ; MST[MathMutator]MSP[] } @Override public boolean isPrefix ( final String prefix , final int offsetInBits , final int lengthInBits , final String key ) {
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; MST[rv.CRCR2Mutator]MSP[] return key . startsWith ( s1 ) ; }
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { MST[rv.AOR2Mutator]MSP[] throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; return key . startsWith ( s1 ) ; }
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { MST[rv.AOR1Mutator]MSP[] throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; return key . startsWith ( s1 ) ; }
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; return key . startsWith ( s1 ) ; MST[BooleanTrueReturnValsMutator]MSP[] }
if ( other == null || index2 >= endIndex2 ) { MST[rv.ABSMutator]MSP[] f = 0 ; } else { f = other . charAt ( index2 ) ; } if ( k != f ) { final int x = k ^ f ;
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.CRCR1Mutator]MSP[]
return ( key . charAt ( index ) & mask ( bit ) ) != 0 ; MST[rv.UOI4Mutator]MSP[] } @Override public boolean isPrefix ( final String prefix , final int offsetInBits , final int lengthInBits , final String key ) {
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; MST[PrimitiveReturnsMutator]MSP[] } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.CRCR5Mutator]MSP[]
private static int mask ( final int bit ) { return MSB >>> bit ; MST[rv.CRCR3Mutator]MSP[] } @Override public int bitsPerElement () { return LENGTH ; } @Override public int lengthInBits ( final String key ) { return key != null ? key . length () * LENGTH : 0 ;
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.CRCR6Mutator]MSP[]
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.CRCR3Mutator]MSP[]
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; } if ( k != 0 ) { MST[rv.ROR4Mutator]MSP[] allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.CRCR4Mutator]MSP[]
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.CRCR2Mutator]MSP[]
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; MST[rv.AOR2Mutator]MSP[] return key . startsWith ( s1 ) ; }
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; MST[ArgumentPropagationMutator]MSP[] } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; } if ( k != 0 ) { MST[rv.ROR1Mutator]MSP[] allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
final int index1 = beginIndex1 + i ; final int index2 = beginIndex2 + i ; if ( index1 >= endIndex1 ) { MST[rv.ROR2Mutator]MSP[] k = 0 ; } else { k = key . charAt ( index1 ) ; }
final int index1 = beginIndex1 + i ; final int index2 = beginIndex2 + i ; if ( index1 >= endIndex1 ) { MST[rv.ROR5Mutator]MSP[] k = 0 ; } else { k = key . charAt ( index1 ) ; }
|| lengthInBits % LENGTH != 0 || otherLengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } final int beginIndex1 = offsetInBits / LENGTH ; final int beginIndex2 = otherOffsetInBits / LENGTH ; MST[rv.AOR3Mutator]MSP[] final int endIndex1 = beginIndex1 + lengthInBits / LENGTH ;
final int endIndex2 = beginIndex2 + otherLengthInBits / LENGTH ; MST[rv.AOD2Mutator]MSP[] final int length = Math . max ( endIndex1 , endIndex2 ) ; char k = 0 , f = 0 ; for ( int i = 0 ; i < length ; i ++ ) {
final int endIndex2 = beginIndex2 + otherLengthInBits / LENGTH ; MST[rv.AOD2Mutator]MSP[] final int length = Math . max ( endIndex1 , endIndex2 ) ; char k = 0 , f = 0 ; for ( int i = 0 ; i < length ; i ++ ) {
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; } if ( k != 0 ) { MST[rv.UOI4Mutator]MSP[] allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
final int endIndex2 = beginIndex2 + otherLengthInBits / LENGTH ; final int length = Math . max ( endIndex1 , endIndex2 ) ; char k = 0 , f = 0 ; for ( int i = 0 ; i < length ; i ++ ) { MST[rv.ROR2Mutator]MSP[]
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; MST[rv.ABSMutator]MSP[] } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
|| lengthInBits % LENGTH != 0 || otherLengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } final int beginIndex1 = offsetInBits / LENGTH ; final int beginIndex2 = otherOffsetInBits / LENGTH ; final int endIndex1 = beginIndex1 + lengthInBits / LENGTH ; MST[rv.CRCR1Mutator]MSP[]
public boolean isBitSet ( final String key , final int bitIndex , final int lengthInBits ) { if ( key == null || bitIndex >= lengthInBits ) { return false ; } final int index = bitIndex / LENGTH ; final int bit = bitIndex % LENGTH ; MST[rv.CRCR6Mutator]MSP[]
final int endIndex2 = beginIndex2 + otherLengthInBits / LENGTH ; MST[rv.AOR3Mutator]MSP[] final int length = Math . max ( endIndex1 , endIndex2 ) ; char k = 0 , f = 0 ; for ( int i = 0 ; i < length ; i ++ ) {
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; MST[InlineConstantMutator]MSP[] } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
public boolean isBitSet ( final String key , final int bitIndex , final int lengthInBits ) { if ( key == null || bitIndex >= lengthInBits ) { return false ; MST[BooleanTrueReturnValsMutator]MSP[] } final int index = bitIndex / LENGTH ; final int bit = bitIndex % LENGTH ;
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.AOD2Mutator]MSP[]
final int index1 = beginIndex1 + i ; final int index2 = beginIndex2 + i ; MST[rv.UOI3Mutator]MSP[] if ( index1 >= endIndex1 ) { k = 0 ; } else { k = key . charAt ( index1 ) ; }
public boolean isBitSet ( final String key , final int bitIndex , final int lengthInBits ) { if ( key == null || bitIndex >= lengthInBits ) { return false ; } final int index = bitIndex / LENGTH ; final int bit = bitIndex % LENGTH ; MST[rv.AOR2Mutator]MSP[]
|| lengthInBits % LENGTH != 0 || otherLengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } final int beginIndex1 = offsetInBits / LENGTH ; final int beginIndex2 = otherOffsetInBits / LENGTH ; MST[rv.CRCR2Mutator]MSP[] final int endIndex1 = beginIndex1 + lengthInBits / LENGTH ;
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { MST[rv.AOR4Mutator]MSP[] throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; return key . startsWith ( s1 ) ; }
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; } if ( k != 0 ) { allNull = false ; MST[rv.CRCR1Mutator]MSP[] } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
return ( key . charAt ( index ) & mask ( bit ) ) != 0 ; MST[rv.CRCR6Mutator]MSP[] } @Override public boolean isPrefix ( final String prefix , final int offsetInBits , final int lengthInBits , final String key ) {
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; MST[rv.CRCR5Mutator]MSP[] return key . startsWith ( s1 ) ; }
final int index1 = beginIndex1 + i ; MST[rv.ABSMutator]MSP[] final int index2 = beginIndex2 + i ; if ( index1 >= endIndex1 ) { k = 0 ; } else { k = key . charAt ( index1 ) ; }
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { MST[rv.UOI4Mutator]MSP[] throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; return key . startsWith ( s1 ) ; }
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; return key . startsWith ( s1 ) ; }
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.ABSMutator]MSP[]
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.AOR3Mutator]MSP[]
public boolean isBitSet ( final String key , final int bitIndex , final int lengthInBits ) { if ( key == null || bitIndex >= lengthInBits ) { MST[rv.UOI2Mutator]MSP[] return false ; } final int index = bitIndex / LENGTH ; final int bit = bitIndex % LENGTH ;
final int index1 = beginIndex1 + i ; final int index2 = beginIndex2 + i ; if ( index1 >= endIndex1 ) { k = 0 ; MST[rv.CRCR5Mutator]MSP[] } else { k = key . charAt ( index1 ) ; }
public boolean isBitSet ( final String key , final int bitIndex , final int lengthInBits ) { if ( key == null || bitIndex >= lengthInBits ) { return false ; } final int index = bitIndex / LENGTH ; final int bit = bitIndex % LENGTH ; MST[rv.AOD1Mutator]MSP[]
return ( key . charAt ( index ) & mask ( bit ) ) != 0 ; MST[rv.CRCR4Mutator]MSP[] } @Override public boolean isPrefix ( final String prefix , final int offsetInBits , final int lengthInBits , final String key ) {
final int endIndex2 = beginIndex2 + otherLengthInBits / LENGTH ; MST[rv.UOI2Mutator]MSP[] final int length = Math . max ( endIndex1 , endIndex2 ) ; char k = 0 , f = 0 ; for ( int i = 0 ; i < length ; i ++ ) {
public boolean isBitSet ( final String key , final int bitIndex , final int lengthInBits ) { if ( key == null || bitIndex >= lengthInBits ) { return false ; } final int index = bitIndex / LENGTH ; final int bit = bitIndex % LENGTH ; MST[InlineConstantMutator]MSP[]
private static int mask ( final int bit ) { return MSB >>> bit ; } @Override public int bitsPerElement () { return LENGTH ; } @Override public int lengthInBits ( final String key ) { return key != null ? key . length () * LENGTH : 0 ; MST[rv.CRCR5Mutator]MSP[]
if ( other == null || index2 >= endIndex2 ) { MST[rv.ABSMutator]MSP[] f = 0 ; } else { f = other . charAt ( index2 ) ; } if ( k != f ) { final int x = k ^ f ;
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[MathMutator]MSP[]
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; MST[rv.AOR2Mutator]MSP[] } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
final int index1 = beginIndex1 + i ; final int index2 = beginIndex2 + i ; MST[rv.AOR3Mutator]MSP[] if ( index1 >= endIndex1 ) { k = 0 ; } else { k = key . charAt ( index1 ) ; }
|| lengthInBits % LENGTH != 0 || otherLengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } final int beginIndex1 = offsetInBits / LENGTH ; final int beginIndex2 = otherOffsetInBits / LENGTH ; MST[rv.UOI3Mutator]MSP[] final int endIndex1 = beginIndex1 + lengthInBits / LENGTH ;
private static int mask ( final int bit ) { return MSB >>> bit ; } @Override public int bitsPerElement () { return LENGTH ; MST[InlineConstantMutator]MSP[] } @Override public int lengthInBits ( final String key ) { return key != null ? key . length () * LENGTH : 0 ;
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; MST[rv.CRCR5Mutator]MSP[] } @Override
|| lengthInBits % LENGTH != 0 || otherLengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } final int beginIndex1 = offsetInBits / LENGTH ; MST[rv.UOI1Mutator]MSP[] final int beginIndex2 = otherOffsetInBits / LENGTH ; final int endIndex1 = beginIndex1 + lengthInBits / LENGTH ;
return ( key . charAt ( index ) & mask ( bit ) ) != 0 ; MST[rv.ROR5Mutator]MSP[] } @Override public boolean isPrefix ( final String prefix , final int offsetInBits , final int lengthInBits , final String key ) {
public boolean isBitSet ( final String key , final int bitIndex , final int lengthInBits ) { if ( key == null || bitIndex >= lengthInBits ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return false ; } final int index = bitIndex / LENGTH ; final int bit = bitIndex % LENGTH ;
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; MST[rv.CRCR5Mutator]MSP[] if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; MST[rv.AOR3Mutator]MSP[] return key . startsWith ( s1 ) ; }
private static int mask ( final int bit ) { return MSB >>> bit ; } @Override public int bitsPerElement () { return LENGTH ; MST[rv.CRCR3Mutator]MSP[] } @Override public int lengthInBits ( final String key ) { return key != null ? key . length () * LENGTH : 0 ;
final int endIndex2 = beginIndex2 + otherLengthInBits / LENGTH ; final int length = Math . max ( endIndex1 , endIndex2 ) ; char k = 0 , f = 0 ; MST[rv.CRCR5Mutator]MSP[] for ( int i = 0 ; i < length ; i ++ ) {
final int endIndex2 = beginIndex2 + otherLengthInBits / LENGTH ; final int length = Math . max ( endIndex1 , endIndex2 ) ; char k = 0 , f = 0 ; for ( int i = 0 ; i < length ; i ++ ) { MST[rv.ROR5Mutator]MSP[]
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( MST[ConstructorCallMutator]MSP[] lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; return key . startsWith ( s1 ) ; }
|| lengthInBits % LENGTH != 0 || otherLengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } final int beginIndex1 = offsetInBits / LENGTH ; MST[rv.AOR1Mutator]MSP[] final int beginIndex2 = otherOffsetInBits / LENGTH ; final int endIndex1 = beginIndex1 + lengthInBits / LENGTH ;
private static int mask ( final int bit ) { return MSB >>> bit ; } @Override public int bitsPerElement () { return LENGTH ; } @Override public int lengthInBits ( final String key ) { return key != null ? key . length () * LENGTH : 0 ; MST[rv.ROR5Mutator]MSP[]
private static int mask ( final int bit ) { return MSB >>> bit ; } @Override public int bitsPerElement () { return LENGTH ; } @Override public int lengthInBits ( final String key ) { return key != null ? key . length () * LENGTH : 0 ; MST[rv.AOR1Mutator]MSP[]
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
public boolean isBitSet ( final String key , final int bitIndex , final int lengthInBits ) { if ( key == null || bitIndex >= lengthInBits ) { return false ; } final int index = bitIndex / LENGTH ; MST[rv.CRCR1Mutator]MSP[] final int bit = bitIndex % LENGTH ;
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; } if ( k != 0 ) { MST[NegateConditionalsMutator]MSP[] allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { MST[rv.CRCR1Mutator]MSP[] throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; return key . startsWith ( s1 ) ; }
if ( other == null || index2 >= endIndex2 ) { f = 0 ; } else { f = other . charAt ( index2 ) ; } if ( k != f ) { MST[rv.UOI2Mutator]MSP[] final int x = k ^ f ;
return ( key . charAt ( index ) & mask ( bit ) ) != 0 ; MST[InlineConstantMutator]MSP[] } @Override public boolean isPrefix ( final String prefix , final int offsetInBits , final int lengthInBits , final String key ) {
|| lengthInBits % LENGTH != 0 || otherLengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } final int beginIndex1 = offsetInBits / LENGTH ; final int beginIndex2 = otherOffsetInBits / LENGTH ; final int endIndex1 = beginIndex1 + lengthInBits / LENGTH ; MST[rv.CRCR4Mutator]MSP[]
if ( other == null || index2 >= endIndex2 ) { f = 0 ; } else { f = other . charAt ( index2 ) ; } if ( k != f ) { final int x = k ^ f ; MST[rv.UOI4Mutator]MSP[]
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; MST[rv.CRCR6Mutator]MSP[] } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.AOD1Mutator]MSP[]
final int index1 = beginIndex1 + i ; MST[rv.AOD1Mutator]MSP[] final int index2 = beginIndex2 + i ; if ( index1 >= endIndex1 ) { k = 0 ; } else { k = key . charAt ( index1 ) ; }
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; MST[rv.AOD1Mutator]MSP[] } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.AOR4Mutator]MSP[]
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.ROR3Mutator]MSP[]
|| lengthInBits % LENGTH != 0 || otherLengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } final int beginIndex1 = offsetInBits / LENGTH ; MST[rv.CRCR5Mutator]MSP[] final int beginIndex2 = otherOffsetInBits / LENGTH ; final int endIndex1 = beginIndex1 + lengthInBits / LENGTH ;
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { MST[NegateConditionalsMutator]MSP[] throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; return key . startsWith ( s1 ) ; }
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; MST[rv.CRCR1Mutator]MSP[] return key . startsWith ( s1 ) ; }
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.UOI4Mutator]MSP[]
final int endIndex2 = beginIndex2 + otherLengthInBits / LENGTH ; MST[rv.UOI3Mutator]MSP[] final int length = Math . max ( endIndex1 , endIndex2 ) ; char k = 0 , f = 0 ; for ( int i = 0 ; i < length ; i ++ ) {
final int index1 = beginIndex1 + i ; final int index2 = beginIndex2 + i ; MST[rv.AOD1Mutator]MSP[] if ( index1 >= endIndex1 ) { k = 0 ; } else { k = key . charAt ( index1 ) ; }
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { MST[rv.ROR3Mutator]MSP[] return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { MST[rv.ROR1Mutator]MSP[] return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
if ( other == null || index2 >= endIndex2 ) { MST[rv.UOI2Mutator]MSP[] f = 0 ; } else { f = other . charAt ( index2 ) ; } if ( k != f ) { final int x = k ^ f ;
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
return ( key . charAt ( index ) & mask ( bit ) ) != 0 ; MST[ReturnValsMutator]MSP[] } @Override public boolean isPrefix ( final String prefix , final int offsetInBits , final int lengthInBits , final String key ) {
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; MST[rv.CRCR5Mutator]MSP[] } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
final int endIndex2 = beginIndex2 + otherLengthInBits / LENGTH ; final int length = Math . max ( endIndex1 , endIndex2 ) ; MST[rv.UOI1Mutator]MSP[] char k = 0 , f = 0 ; for ( int i = 0 ; i < length ; i ++ ) {
return ( key . charAt ( index ) & mask ( bit ) ) != 0 ; MST[rv.UOI4Mutator]MSP[] } @Override public boolean isPrefix ( final String prefix , final int offsetInBits , final int lengthInBits , final String key ) {
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; return key . startsWith ( s1 ) ; MST[NonVoidMethodCallMutator]MSP[] }
return ( key . charAt ( index ) & mask ( bit ) ) != 0 ; MST[BooleanTrueReturnValsMutator]MSP[] } @Override public boolean isPrefix ( final String prefix , final int offsetInBits , final int lengthInBits , final String key ) {
final int index1 = beginIndex1 + i ; final int index2 = beginIndex2 + i ; if ( index1 >= endIndex1 ) { k = 0 ; } else { k = key . charAt ( index1 ) ; MST[rv.UOI4Mutator]MSP[] }
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; MST[NonVoidMethodCallMutator]MSP[] } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
private static int mask ( final int bit ) { return MSB >>> bit ; } @Override public int bitsPerElement () { return LENGTH ; } @Override public int lengthInBits ( final String key ) { return key != null ? key . length () * LENGTH : 0 ; MST[rv.AOR3Mutator]MSP[]
final int index1 = beginIndex1 + i ; final int index2 = beginIndex2 + i ; if ( index1 >= endIndex1 ) { MST[rv.UOI1Mutator]MSP[] k = 0 ; } else { k = key . charAt ( index1 ) ; }
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; MST[InlineConstantMutator]MSP[] if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0
|| lengthInBits % LENGTH != 0 || otherLengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } final int beginIndex1 = offsetInBits / LENGTH ; MST[rv.AOR3Mutator]MSP[] final int beginIndex2 = otherOffsetInBits / LENGTH ; final int endIndex1 = beginIndex1 + lengthInBits / LENGTH ;
final int endIndex2 = beginIndex2 + otherLengthInBits / LENGTH ; final int length = Math . max ( endIndex1 , endIndex2 ) ; char k = 0 , f = 0 ; for ( int i = 0 ; i < length ; i ++ ) { MST[rv.CRCR6Mutator]MSP[]
final int endIndex2 = beginIndex2 + otherLengthInBits / LENGTH ; final int length = Math . max ( endIndex1 , endIndex2 ) ; char k = 0 , f = 0 ; MST[InlineConstantMutator]MSP[] for ( int i = 0 ; i < length ; i ++ ) {
|| lengthInBits % LENGTH != 0 || otherLengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } final int beginIndex1 = offsetInBits / LENGTH ; final int beginIndex2 = otherOffsetInBits / LENGTH ; final int endIndex1 = beginIndex1 + lengthInBits / LENGTH ; MST[rv.AOR2Mutator]MSP[]
final int endIndex2 = beginIndex2 + otherLengthInBits / LENGTH ; final int length = Math . max ( endIndex1 , endIndex2 ) ; char k = 0 , f = 0 ; MST[rv.CRCR5Mutator]MSP[] for ( int i = 0 ; i < length ; i ++ ) {
|| lengthInBits % LENGTH != 0 || otherLengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } final int beginIndex1 = offsetInBits / LENGTH ; final int beginIndex2 = otherOffsetInBits / LENGTH ; final int endIndex1 = beginIndex1 + lengthInBits / LENGTH ; MST[rv.UOI1Mutator]MSP[]
private static int mask ( final int bit ) { return MSB >>> bit ; MST[ReturnValsMutator]MSP[] } @Override public int bitsPerElement () { return LENGTH ; } @Override public int lengthInBits ( final String key ) { return key != null ? key . length () * LENGTH : 0 ;
if ( other == null || index2 >= endIndex2 ) { MST[NegateConditionalsMutator]MSP[] f = 0 ; } else { f = other . charAt ( index2 ) ; } if ( k != f ) { final int x = k ^ f ;
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { MST[rv.ABSMutator]MSP[] return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.ROR4Mutator]MSP[]
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { MST[rv.ROR1Mutator]MSP[] throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; return key . startsWith ( s1 ) ; }
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[InlineConstantMutator]MSP[]
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { MST[rv.CRCR4Mutator]MSP[] throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; return key . startsWith ( s1 ) ; }
final int endIndex2 = beginIndex2 + otherLengthInBits / LENGTH ; MST[rv.AOR4Mutator]MSP[] final int length = Math . max ( endIndex1 , endIndex2 ) ; char k = 0 , f = 0 ; for ( int i = 0 ; i < length ; i ++ ) {
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; MST[rv.CRCR1Mutator]MSP[] } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; MST[rv.CRCR4Mutator]MSP[] } @Override
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { MST[rv.CRCR6Mutator]MSP[] throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; return key . startsWith ( s1 ) ; }
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
if ( other == null || index2 >= endIndex2 ) { f = 0 ; } else { f = other . charAt ( index2 ) ; } if ( k != f ) { final int x = k ^ f ; MST[rv.UOI4Mutator]MSP[]
public boolean isBitSet ( final String key , final int bitIndex , final int lengthInBits ) { if ( key == null || bitIndex >= lengthInBits ) { MST[NegateConditionalsMutator]MSP[] return false ; } final int index = bitIndex / LENGTH ; final int bit = bitIndex % LENGTH ;
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.UOI3Mutator]MSP[]
final int index1 = beginIndex1 + i ; final int index2 = beginIndex2 + i ; MST[rv.ABSMutator]MSP[] if ( index1 >= endIndex1 ) { k = 0 ; } else { k = key . charAt ( index1 ) ; }
if ( other == null || index2 >= endIndex2 ) { f = 0 ; } else { f = other . charAt ( index2 ) ; MST[rv.UOI1Mutator]MSP[] } if ( k != f ) { final int x = k ^ f ;
|| lengthInBits % LENGTH != 0 || otherLengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } final int beginIndex1 = offsetInBits / LENGTH ; final int beginIndex2 = otherOffsetInBits / LENGTH ; final int endIndex1 = beginIndex1 + lengthInBits / LENGTH ; MST[MathMutator]MSP[]
public boolean isBitSet ( final String key , final int bitIndex , final int lengthInBits ) { if ( key == null || bitIndex >= lengthInBits ) { return false ; } final int index = bitIndex / LENGTH ; MST[rv.AOR2Mutator]MSP[] final int bit = bitIndex % LENGTH ;
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; MST[rv.CRCR4Mutator]MSP[] return key . startsWith ( s1 ) ; }
final int index1 = beginIndex1 + i ; final int index2 = beginIndex2 + i ; if ( index1 >= endIndex1 ) { k = 0 ; MST[InlineConstantMutator]MSP[] } else { k = key . charAt ( index1 ) ; }
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.UOI1Mutator]MSP[]
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.ROR2Mutator]MSP[]
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[NegateConditionalsMutator]MSP[]
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.AOR1Mutator]MSP[]
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; MST[ReturnValsMutator]MSP[] } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
|| lengthInBits % LENGTH != 0 || otherLengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } final int beginIndex1 = offsetInBits / LENGTH ; MST[rv.CRCR4Mutator]MSP[] final int beginIndex2 = otherOffsetInBits / LENGTH ; final int endIndex1 = beginIndex1 + lengthInBits / LENGTH ;
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; MST[rv.CRCR6Mutator]MSP[] return key . startsWith ( s1 ) ; }
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { MST[rv.AOD1Mutator]MSP[] throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; return key . startsWith ( s1 ) ; }
if ( other == null || index2 >= endIndex2 ) { MST[rv.ROR5Mutator]MSP[] f = 0 ; } else { f = other . charAt ( index2 ) ; } if ( k != f ) { final int x = k ^ f ;
if ( other == null || index2 >= endIndex2 ) { MST[rv.UOI2Mutator]MSP[] f = 0 ; } else { f = other . charAt ( index2 ) ; } if ( k != f ) { final int x = k ^ f ;
final int endIndex2 = beginIndex2 + otherLengthInBits / LENGTH ; MST[rv.UOI3Mutator]MSP[] final int length = Math . max ( endIndex1 , endIndex2 ) ; char k = 0 , f = 0 ; for ( int i = 0 ; i < length ; i ++ ) {
public boolean isBitSet ( final String key , final int bitIndex , final int lengthInBits ) { if ( key == null || bitIndex >= lengthInBits ) { MST[rv.ABSMutator]MSP[] return false ; } final int index = bitIndex / LENGTH ; final int bit = bitIndex % LENGTH ;
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.AOR3Mutator]MSP[]
final int index1 = beginIndex1 + i ; MST[rv.AOR3Mutator]MSP[] final int index2 = beginIndex2 + i ; if ( index1 >= endIndex1 ) { k = 0 ; } else { k = key . charAt ( index1 ) ; }
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; MST[rv.AOR4Mutator]MSP[] } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; MST[rv.AOR3Mutator]MSP[] } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
final int endIndex2 = beginIndex2 + otherLengthInBits / LENGTH ; final int length = Math . max ( endIndex1 , endIndex2 ) ; char k = 0 , f = 0 ; for ( int i = 0 ; i < length ; i ++ ) { MST[IncrementsMutator]MSP[]
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; MST[InlineConstantMutator]MSP[] } @Override
public boolean isBitSet ( final String key , final int bitIndex , final int lengthInBits ) { if ( key == null || bitIndex >= lengthInBits ) { return false ; } final int index = bitIndex / LENGTH ; final int bit = bitIndex % LENGTH ; MST[rv.UOI2Mutator]MSP[]
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; MST[rv.AOD1Mutator]MSP[] return key . startsWith ( s1 ) ; }
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; MST[rv.CRCR4Mutator]MSP[] } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
if ( other == null || index2 >= endIndex2 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] f = 0 ; } else { f = other . charAt ( index2 ) ; } if ( k != f ) { final int x = k ^ f ;
public boolean isBitSet ( final String key , final int bitIndex , final int lengthInBits ) { if ( key == null || bitIndex >= lengthInBits ) { return false ; } final int index = bitIndex / LENGTH ; MST[MathMutator]MSP[] final int bit = bitIndex % LENGTH ;
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { MST[rv.UOI4Mutator]MSP[] return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
final int index1 = beginIndex1 + i ; final int index2 = beginIndex2 + i ; if ( index1 >= endIndex1 ) { MST[rv.UOI1Mutator]MSP[] k = 0 ; } else { k = key . charAt ( index1 ) ; }
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; MST[rv.ABSMutator]MSP[] return key . startsWith ( s1 ) ; }
if ( other == null || index2 >= endIndex2 ) { f = 0 ; MST[rv.CRCR6Mutator]MSP[] } else { f = other . charAt ( index2 ) ; } if ( k != f ) { final int x = k ^ f ;
return ( key . charAt ( index ) & mask ( bit ) ) != 0 ; MST[rv.ROR4Mutator]MSP[] } @Override public boolean isPrefix ( final String prefix , final int offsetInBits , final int lengthInBits , final String key ) {
|| lengthInBits % LENGTH != 0 || otherLengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } final int beginIndex1 = offsetInBits / LENGTH ; final int beginIndex2 = otherOffsetInBits / LENGTH ; final int endIndex1 = beginIndex1 + lengthInBits / LENGTH ; MST[rv.AOR2Mutator]MSP[]
final int endIndex2 = beginIndex2 + otherLengthInBits / LENGTH ; final int length = Math . max ( endIndex1 , endIndex2 ) ; char k = 0 , f = 0 ; for ( int i = 0 ; i < length ; i ++ ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[]
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; MST[rv.UOI4Mutator]MSP[] return key . startsWith ( s1 ) ; }
private static int mask ( final int bit ) { return MSB >>> bit ; MST[rv.UOI3Mutator]MSP[] } @Override public int bitsPerElement () { return LENGTH ; } @Override public int lengthInBits ( final String key ) { return key != null ? key . length () * LENGTH : 0 ;
private static int mask ( final int bit ) { return MSB >>> bit ; } @Override public int bitsPerElement () { return LENGTH ; } @Override public int lengthInBits ( final String key ) { return key != null ? key . length () * LENGTH : 0 ; MST[InlineConstantMutator]MSP[]
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; MST[rv.UOI2Mutator]MSP[] } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; MST[rv.UOI1Mutator]MSP[] } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
final int index1 = beginIndex1 + i ; MST[rv.UOI2Mutator]MSP[] final int index2 = beginIndex2 + i ; if ( index1 >= endIndex1 ) { k = 0 ; } else { k = key . charAt ( index1 ) ; }
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; MST[rv.UOI3Mutator]MSP[] return key . startsWith ( s1 ) ; }
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.ROR5Mutator]MSP[]
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.UOI2Mutator]MSP[]
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; MST[PrimitiveReturnsMutator]MSP[] } @Override
public boolean isBitSet ( final String key , final int bitIndex , final int lengthInBits ) { if ( key == null || bitIndex >= lengthInBits ) { return false ; } final int index = bitIndex / LENGTH ; MST[rv.CRCR3Mutator]MSP[] final int bit = bitIndex % LENGTH ;
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { MST[rv.CRCR3Mutator]MSP[] throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; return key . startsWith ( s1 ) ; }
public boolean isBitSet ( final String key , final int bitIndex , final int lengthInBits ) { if ( key == null || bitIndex >= lengthInBits ) { return false ; } final int index = bitIndex / LENGTH ; final int bit = bitIndex % LENGTH ; MST[rv.CRCR5Mutator]MSP[]
final int index1 = beginIndex1 + i ; final int index2 = beginIndex2 + i ; MST[rv.UOI4Mutator]MSP[] if ( index1 >= endIndex1 ) { k = 0 ; } else { k = key . charAt ( index1 ) ; }
public boolean isBitSet ( final String key , final int bitIndex , final int lengthInBits ) { if ( key == null || bitIndex >= lengthInBits ) { MST[rv.UOI2Mutator]MSP[] return false ; } final int index = bitIndex / LENGTH ; final int bit = bitIndex % LENGTH ;
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { MST[rv.UOI3Mutator]MSP[] throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; return key . startsWith ( s1 ) ; }
public boolean isBitSet ( final String key , final int bitIndex , final int lengthInBits ) { if ( key == null || bitIndex >= lengthInBits ) { return false ; } final int index = bitIndex / LENGTH ; final int bit = bitIndex % LENGTH ; MST[rv.ABSMutator]MSP[]
|| lengthInBits % LENGTH != 0 || otherLengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } final int beginIndex1 = offsetInBits / LENGTH ; MST[InlineConstantMutator]MSP[] final int beginIndex2 = otherOffsetInBits / LENGTH ; final int endIndex1 = beginIndex1 + lengthInBits / LENGTH ;
public boolean isBitSet ( final String key , final int bitIndex , final int lengthInBits ) { if ( key == null || bitIndex >= lengthInBits ) { MST[rv.ROR5Mutator]MSP[] return false ; } final int index = bitIndex / LENGTH ; final int bit = bitIndex % LENGTH ;
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.AOR2Mutator]MSP[]
return ( key . charAt ( index ) & mask ( bit ) ) != 0 ; MST[rv.CRCR5Mutator]MSP[] } @Override public boolean isPrefix ( final String prefix , final int offsetInBits , final int lengthInBits , final String key ) {
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.ROR1Mutator]MSP[]
private static int mask ( final int bit ) { return MSB >>> bit ; } @Override public int bitsPerElement () { return LENGTH ; } @Override public int lengthInBits ( final String key ) { return key != null ? key . length () * LENGTH : 0 ; MST[rv.CRCR6Mutator]MSP[]
if ( other == null || index2 >= endIndex2 ) { f = 0 ; } else { f = other . charAt ( index2 ) ; } if ( k != f ) { MST[rv.UOI3Mutator]MSP[] final int x = k ^ f ;
private static int mask ( final int bit ) { return MSB >>> bit ; } @Override public int bitsPerElement () { return LENGTH ; } @Override public int lengthInBits ( final String key ) { return key != null ? key . length () * LENGTH : 0 ; MST[rv.CRCR5Mutator]MSP[]
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; MST[rv.AOD1Mutator]MSP[] return key . startsWith ( s1 ) ; }
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; MST[rv.AOD2Mutator]MSP[] return key . startsWith ( s1 ) ; }
return ( key . charAt ( index ) & mask ( bit ) ) != 0 ; MST[rv.OBBN2Mutator]MSP[] } @Override public boolean isPrefix ( final String prefix , final int offsetInBits , final int lengthInBits , final String key ) {
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; MST[rv.CRCR1Mutator]MSP[] return key . startsWith ( s1 ) ; }
|| lengthInBits % LENGTH != 0 || otherLengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } final int beginIndex1 = offsetInBits / LENGTH ; final int beginIndex2 = otherOffsetInBits / LENGTH ; MST[rv.ABSMutator]MSP[] final int endIndex1 = beginIndex1 + lengthInBits / LENGTH ;
if ( other == null || index2 >= endIndex2 ) { MST[ConditionalsBoundaryMutator]MSP[] f = 0 ; } else { f = other . charAt ( index2 ) ; } if ( k != f ) { final int x = k ^ f ;
public boolean isBitSet ( final String key , final int bitIndex , final int lengthInBits ) { if ( key == null || bitIndex >= lengthInBits ) { MST[rv.ABSMutator]MSP[] return false ; } final int index = bitIndex / LENGTH ; final int bit = bitIndex % LENGTH ;
if ( other == null || index2 >= endIndex2 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] f = 0 ; } else { f = other . charAt ( index2 ) ; } if ( k != f ) { final int x = k ^ f ;
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { MST[rv.AOR4Mutator]MSP[] throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; return key . startsWith ( s1 ) ; }
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; MST[rv.AOR1Mutator]MSP[] } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; MST[rv.AOR2Mutator]MSP[] } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { MST[rv.AOR3Mutator]MSP[] throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; return key . startsWith ( s1 ) ; }
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; return key . startsWith ( s1 ) ; MST[BooleanFalseReturnValsMutator]MSP[] }
private static int mask ( final int bit ) { return MSB >>> bit ; MST[rv.CRCR5Mutator]MSP[] } @Override public int bitsPerElement () { return LENGTH ; } @Override public int lengthInBits ( final String key ) { return key != null ? key . length () * LENGTH : 0 ;
if ( other == null || index2 >= endIndex2 ) { MST[rv.ROR5Mutator]MSP[] f = 0 ; } else { f = other . charAt ( index2 ) ; } if ( k != f ) { final int x = k ^ f ;
return ( key . charAt ( index ) & mask ( bit ) ) != 0 ; MST[rv.OBBN3Mutator]MSP[] } @Override public boolean isPrefix ( final String prefix , final int offsetInBits , final int lengthInBits , final String key ) {
private static int mask ( final int bit ) { return MSB >>> bit ; MST[rv.CRCR4Mutator]MSP[] } @Override public int bitsPerElement () { return LENGTH ; } @Override public int lengthInBits ( final String key ) { return key != null ? key . length () * LENGTH : 0 ;
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.CRCR4Mutator]MSP[]
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.AOD1Mutator]MSP[]
public boolean isBitSet ( final String key , final int bitIndex , final int lengthInBits ) { if ( key == null || bitIndex >= lengthInBits ) { MST[ConditionalsBoundaryMutator]MSP[] return false ; } final int index = bitIndex / LENGTH ; final int bit = bitIndex % LENGTH ;
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; MST[MathMutator]MSP[] } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; } if ( k != 0 ) { MST[rv.ROR3Mutator]MSP[] allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
return ( key . charAt ( index ) & mask ( bit ) ) != 0 ; MST[rv.UOI1Mutator]MSP[] } @Override public boolean isPrefix ( final String prefix , final int offsetInBits , final int lengthInBits , final String key ) {
return ( key . charAt ( index ) & mask ( bit ) ) != 0 ; MST[NegateConditionalsMutator]MSP[] } @Override public boolean isPrefix ( final String prefix , final int offsetInBits , final int lengthInBits , final String key ) {
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.CRCR1Mutator]MSP[]
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.CRCR3Mutator]MSP[]
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; } if ( k != 0 ) { MST[rv.ROR2Mutator]MSP[] allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.CRCR2Mutator]MSP[]
final int index1 = beginIndex1 + i ; final int index2 = beginIndex2 + i ; if ( index1 >= endIndex1 ) { MST[rv.ROR4Mutator]MSP[] k = 0 ; } else { k = key . charAt ( index1 ) ; }
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.CRCR5Mutator]MSP[]
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; MST[rv.AOR4Mutator]MSP[] return key . startsWith ( s1 ) ; }
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.CRCR6Mutator]MSP[]
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; MST[rv.AOR3Mutator]MSP[] return key . startsWith ( s1 ) ; }
private static int mask ( final int bit ) { return MSB >>> bit ; } @Override public int bitsPerElement () { return LENGTH ; } @Override public int lengthInBits ( final String key ) { return key != null ? key . length () * LENGTH : 0 ; MST[NonVoidMethodCallMutator]MSP[]
|| lengthInBits % LENGTH != 0 || otherLengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } final int beginIndex1 = offsetInBits / LENGTH ; final int beginIndex2 = otherOffsetInBits / LENGTH ; MST[rv.AOR4Mutator]MSP[] final int endIndex1 = beginIndex1 + lengthInBits / LENGTH ;
final int endIndex2 = beginIndex2 + otherLengthInBits / LENGTH ; MST[rv.AOD1Mutator]MSP[] final int length = Math . max ( endIndex1 , endIndex2 ) ; char k = 0 , f = 0 ; for ( int i = 0 ; i < length ; i ++ ) {
public boolean isBitSet ( final String key , final int bitIndex , final int lengthInBits ) { if ( key == null || bitIndex >= lengthInBits ) { return false ; } final int index = bitIndex / LENGTH ; final int bit = bitIndex % LENGTH ; MST[rv.CRCR4Mutator]MSP[]
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; MST[rv.UOI4Mutator]MSP[] return key . startsWith ( s1 ) ; }
private static int mask ( final int bit ) { return MSB >>> bit ; } @Override public int bitsPerElement () { return LENGTH ; } @Override public int lengthInBits ( final String key ) { return key != null ? key . length () * LENGTH : 0 ; MST[NegateConditionalsMutator]MSP[]
final int endIndex2 = beginIndex2 + otherLengthInBits / LENGTH ; final int length = Math . max ( endIndex1 , endIndex2 ) ; char k = 0 , f = 0 ; for ( int i = 0 ; i < length ; i ++ ) { MST[rv.ROR4Mutator]MSP[]
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; MST[rv.UOI2Mutator]MSP[] } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.ABSMutator]MSP[]
private static int mask ( final int bit ) { return MSB >>> bit ; MST[rv.UOI4Mutator]MSP[] } @Override public int bitsPerElement () { return LENGTH ; } @Override public int lengthInBits ( final String key ) { return key != null ? key . length () * LENGTH : 0 ;
final int endIndex2 = beginIndex2 + otherLengthInBits / LENGTH ; MST[rv.CRCR5Mutator]MSP[] final int length = Math . max ( endIndex1 , endIndex2 ) ; char k = 0 , f = 0 ; for ( int i = 0 ; i < length ; i ++ ) {
public boolean isBitSet ( final String key , final int bitIndex , final int lengthInBits ) { if ( key == null || bitIndex >= lengthInBits ) { return false ; MST[ReturnValsMutator]MSP[] } final int index = bitIndex / LENGTH ; final int bit = bitIndex % LENGTH ;
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.AOD2Mutator]MSP[]
|| lengthInBits % LENGTH != 0 || otherLengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } final int beginIndex1 = offsetInBits / LENGTH ; final int beginIndex2 = otherOffsetInBits / LENGTH ; final int endIndex1 = beginIndex1 + lengthInBits / LENGTH ; MST[rv.CRCR3Mutator]MSP[]
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { MST[rv.UOI4Mutator]MSP[] throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; return key . startsWith ( s1 ) ; }
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { MST[rv.UOI2Mutator]MSP[] throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; return key . startsWith ( s1 ) ; }
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; return key . startsWith ( s1 ) ; }
|| lengthInBits % LENGTH != 0 || otherLengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_1 ) ; MST[ConstructorCallMutator]MSP[] } final int beginIndex1 = offsetInBits / LENGTH ; final int beginIndex2 = otherOffsetInBits / LENGTH ; final int endIndex1 = beginIndex1 + lengthInBits / LENGTH ;
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { MST[rv.AOR2Mutator]MSP[] throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; return key . startsWith ( s1 ) ; }
private static int mask ( final int bit ) { return MSB >>> bit ; } @Override public int bitsPerElement () { return LENGTH ; } @Override public int lengthInBits ( final String key ) { return key != null ? key . length () * LENGTH : 0 ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; MST[experimental.NakedReceiverMutator]MSP[] return key . startsWith ( s1 ) ; }
|| lengthInBits % LENGTH != 0 || otherLengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } final int beginIndex1 = offsetInBits / LENGTH ; final int beginIndex2 = otherOffsetInBits / LENGTH ; MST[rv.CRCR6Mutator]MSP[] final int endIndex1 = beginIndex1 + lengthInBits / LENGTH ;
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; } if ( k != 0 ) { allNull = false ; MST[rv.CRCR3Mutator]MSP[] } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
if ( other == null || index2 >= endIndex2 ) { f = 0 ; } else { f = other . charAt ( index2 ) ; } if ( k != f ) { MST[rv.UOI3Mutator]MSP[] final int x = k ^ f ;
public boolean isBitSet ( final String key , final int bitIndex , final int lengthInBits ) { if ( key == null || bitIndex >= lengthInBits ) { MST[rv.ROR5Mutator]MSP[] return false ; } final int index = bitIndex / LENGTH ; final int bit = bitIndex % LENGTH ;
public boolean isBitSet ( final String key , final int bitIndex , final int lengthInBits ) { if ( key == null || bitIndex >= lengthInBits ) { return false ; } final int index = bitIndex / LENGTH ; MST[rv.UOI1Mutator]MSP[] final int bit = bitIndex % LENGTH ;
public boolean isBitSet ( final String key , final int bitIndex , final int lengthInBits ) { if ( key == null || bitIndex >= lengthInBits ) { return false ; } final int index = bitIndex / LENGTH ; final int bit = bitIndex % LENGTH ; MST[rv.UOI3Mutator]MSP[]
private static int mask ( final int bit ) { return MSB >>> bit ; } @Override public int bitsPerElement () { return LENGTH ; } @Override public int lengthInBits ( final String key ) { return key != null ? key . length () * LENGTH : 0 ; MST[rv.CRCR4Mutator]MSP[]
final int endIndex2 = beginIndex2 + otherLengthInBits / LENGTH ; final int length = Math . max ( endIndex1 , endIndex2 ) ; MST[rv.UOI1Mutator]MSP[] char k = 0 , f = 0 ; for ( int i = 0 ; i < length ; i ++ ) {
if ( other == null || index2 >= endIndex2 ) { MST[rv.UOI3Mutator]MSP[] f = 0 ; } else { f = other . charAt ( index2 ) ; } if ( k != f ) { final int x = k ^ f ;
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; MST[rv.AOR3Mutator]MSP[] } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; MST[rv.CRCR3Mutator]MSP[] } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
private static int mask ( final int bit ) { return MSB >>> bit ; } @Override public int bitsPerElement () { return LENGTH ; MST[rv.CRCR2Mutator]MSP[] } @Override public int lengthInBits ( final String key ) { return key != null ? key . length () * LENGTH : 0 ;
|| lengthInBits % LENGTH != 0 || otherLengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } final int beginIndex1 = offsetInBits / LENGTH ; final int beginIndex2 = otherOffsetInBits / LENGTH ; MST[rv.AOD1Mutator]MSP[] final int endIndex1 = beginIndex1 + lengthInBits / LENGTH ;
|| lengthInBits % LENGTH != 0 || otherLengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } final int beginIndex1 = offsetInBits / LENGTH ; MST[rv.UOI2Mutator]MSP[] final int beginIndex2 = otherOffsetInBits / LENGTH ; final int endIndex1 = beginIndex1 + lengthInBits / LENGTH ;
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[MathMutator]MSP[]
final int endIndex2 = beginIndex2 + otherLengthInBits / LENGTH ; MST[rv.ABSMutator]MSP[] final int length = Math . max ( endIndex1 , endIndex2 ) ; char k = 0 , f = 0 ; for ( int i = 0 ; i < length ; i ++ ) {
private static int mask ( final int bit ) { return MSB >>> bit ; MST[rv.ABSMutator]MSP[] } @Override public int bitsPerElement () { return LENGTH ; } @Override public int lengthInBits ( final String key ) { return key != null ? key . length () * LENGTH : 0 ;
public boolean isBitSet ( final String key , final int bitIndex , final int lengthInBits ) { if ( key == null || bitIndex >= lengthInBits ) { return false ; MST[rv.CRCR6Mutator]MSP[] } final int index = bitIndex / LENGTH ; final int bit = bitIndex % LENGTH ;
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[InlineConstantMutator]MSP[]
|| lengthInBits % LENGTH != 0 || otherLengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } final int beginIndex1 = offsetInBits / LENGTH ; final int beginIndex2 = otherOffsetInBits / LENGTH ; final int endIndex1 = beginIndex1 + lengthInBits / LENGTH ; MST[rv.UOI1Mutator]MSP[]
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; MST[rv.CRCR4Mutator]MSP[] if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0
|| lengthInBits % LENGTH != 0 || otherLengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } final int beginIndex1 = offsetInBits / LENGTH ; final int beginIndex2 = otherOffsetInBits / LENGTH ; MST[rv.UOI4Mutator]MSP[] final int endIndex1 = beginIndex1 + lengthInBits / LENGTH ;
final int endIndex2 = beginIndex2 + otherLengthInBits / LENGTH ; MST[rv.AOD1Mutator]MSP[] final int length = Math . max ( endIndex1 , endIndex2 ) ; char k = 0 , f = 0 ; for ( int i = 0 ; i < length ; i ++ ) {
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.ROR3Mutator]MSP[]
final int index1 = beginIndex1 + i ; MST[rv.UOI3Mutator]MSP[] final int index2 = beginIndex2 + i ; if ( index1 >= endIndex1 ) { k = 0 ; } else { k = key . charAt ( index1 ) ; }
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; MST[InlineConstantMutator]MSP[] } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; MST[rv.ABSMutator]MSP[] return key . startsWith ( s1 ) ; }
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; MST[rv.CRCR2Mutator]MSP[] } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
final int index1 = beginIndex1 + i ; final int index2 = beginIndex2 + i ; if ( index1 >= endIndex1 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[] k = 0 ; } else { k = key . charAt ( index1 ) ; }
final int endIndex2 = beginIndex2 + otherLengthInBits / LENGTH ; MST[rv.AOR4Mutator]MSP[] final int length = Math . max ( endIndex1 , endIndex2 ) ; char k = 0 , f = 0 ; for ( int i = 0 ; i < length ; i ++ ) {
final int index1 = beginIndex1 + i ; final int index2 = beginIndex2 + i ; if ( index1 >= endIndex1 ) { MST[NegateConditionalsMutator]MSP[] k = 0 ; } else { k = key . charAt ( index1 ) ; }
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { MST[rv.CRCR5Mutator]MSP[] throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; return key . startsWith ( s1 ) ; }
public boolean isBitSet ( final String key , final int bitIndex , final int lengthInBits ) { if ( key == null || bitIndex >= lengthInBits ) { return false ; } final int index = bitIndex / LENGTH ; final int bit = bitIndex % LENGTH ; MST[rv.AOR3Mutator]MSP[]
|| lengthInBits % LENGTH != 0 || otherLengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } final int beginIndex1 = offsetInBits / LENGTH ; final int beginIndex2 = otherOffsetInBits / LENGTH ; final int endIndex1 = beginIndex1 + lengthInBits / LENGTH ; MST[MathMutator]MSP[]
public boolean isBitSet ( final String key , final int bitIndex , final int lengthInBits ) { if ( key == null || bitIndex >= lengthInBits ) { MST[rv.UOI3Mutator]MSP[] return false ; } final int index = bitIndex / LENGTH ; final int bit = bitIndex % LENGTH ;
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.UOI4Mutator]MSP[]
return ( key . charAt ( index ) & mask ( bit ) ) != 0 ; MST[InlineConstantMutator]MSP[] } @Override public boolean isPrefix ( final String prefix , final int offsetInBits , final int lengthInBits , final String key ) {
public boolean isBitSet ( final String key , final int bitIndex , final int lengthInBits ) { if ( key == null || bitIndex >= lengthInBits ) { return false ; } final int index = bitIndex / LENGTH ; MST[rv.AOR1Mutator]MSP[] final int bit = bitIndex % LENGTH ;
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { MST[rv.ABSMutator]MSP[] throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; return key . startsWith ( s1 ) ; }
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.AOR4Mutator]MSP[]
final int endIndex2 = beginIndex2 + otherLengthInBits / LENGTH ; final int length = Math . max ( endIndex1 , endIndex2 ) ; char k = 0 , f = 0 ; for ( int i = 0 ; i < length ; i ++ ) { MST[rv.UOI1Mutator]MSP[]
if ( other == null || index2 >= endIndex2 ) { f = 0 ; } else { f = other . charAt ( index2 ) ; } if ( k != f ) { MST[rv.ABSMutator]MSP[] final int x = k ^ f ;
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; MST[rv.CRCR6Mutator]MSP[] return key . startsWith ( s1 ) ; }
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; MST[rv.CRCR5Mutator]MSP[] return key . startsWith ( s1 ) ; }
return ( key . charAt ( index ) & mask ( bit ) ) != 0 ; MST[rv.CRCR3Mutator]MSP[] } @Override public boolean isPrefix ( final String prefix , final int offsetInBits , final int lengthInBits , final String key ) {
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { MST[rv.ROR2Mutator]MSP[] return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
final int endIndex2 = beginIndex2 + otherLengthInBits / LENGTH ; final int length = Math . max ( endIndex1 , endIndex2 ) ; MST[rv.UOI2Mutator]MSP[] char k = 0 , f = 0 ; for ( int i = 0 ; i < length ; i ++ ) {
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; MST[rv.CRCR4Mutator]MSP[] } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
if ( other == null || index2 >= endIndex2 ) { MST[rv.UOI3Mutator]MSP[] f = 0 ; } else { f = other . charAt ( index2 ) ; } if ( k != f ) { final int x = k ^ f ;
final int endIndex2 = beginIndex2 + otherLengthInBits / LENGTH ; MST[rv.UOI4Mutator]MSP[] final int length = Math . max ( endIndex1 , endIndex2 ) ; char k = 0 , f = 0 ; for ( int i = 0 ; i < length ; i ++ ) {
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; MST[rv.CRCR6Mutator]MSP[] } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
final int endIndex2 = beginIndex2 + otherLengthInBits / LENGTH ; MST[rv.AOR1Mutator]MSP[] final int length = Math . max ( endIndex1 , endIndex2 ) ; char k = 0 , f = 0 ; for ( int i = 0 ; i < length ; i ++ ) {
private static int mask ( final int bit ) { return MSB >>> bit ; } @Override public int bitsPerElement () { return LENGTH ; } @Override public int lengthInBits ( final String key ) { return key != null ? key . length () * LENGTH : 0 ; MST[rv.AOR4Mutator]MSP[]
return ( key . charAt ( index ) & mask ( bit ) ) != 0 ; MST[rv.UOI1Mutator]MSP[] } @Override public boolean isPrefix ( final String prefix , final int offsetInBits , final int lengthInBits , final String key ) {
final int endIndex2 = beginIndex2 + otherLengthInBits / LENGTH ; final int length = Math . max ( endIndex1 , endIndex2 ) ; char k = 0 , f = 0 ; for ( int i = 0 ; i < length ; i ++ ) { MST[rv.CRCR5Mutator]MSP[]
final int endIndex2 = beginIndex2 + otherLengthInBits / LENGTH ; final int length = Math . max ( endIndex1 , endIndex2 ) ; char k = 0 , f = 0 ; for ( int i = 0 ; i < length ; i ++ ) { MST[rv.CRCR1Mutator]MSP[]
|| lengthInBits % LENGTH != 0 || otherLengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } final int beginIndex1 = offsetInBits / LENGTH ; MST[rv.AOR4Mutator]MSP[] final int beginIndex2 = otherOffsetInBits / LENGTH ; final int endIndex1 = beginIndex1 + lengthInBits / LENGTH ;
final int index1 = beginIndex1 + i ; final int index2 = beginIndex2 + i ; if ( index1 >= endIndex1 ) { k = 0 ; } else { k = key . charAt ( index1 ) ; MST[rv.UOI1Mutator]MSP[] }
|| lengthInBits % LENGTH != 0 || otherLengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } final int beginIndex1 = offsetInBits / LENGTH ; final int beginIndex2 = otherOffsetInBits / LENGTH ; final int endIndex1 = beginIndex1 + lengthInBits / LENGTH ; MST[rv.UOI2Mutator]MSP[]
|| lengthInBits % LENGTH != 0 || otherLengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } final int beginIndex1 = offsetInBits / LENGTH ; final int beginIndex2 = otherOffsetInBits / LENGTH ; final int endIndex1 = beginIndex1 + lengthInBits / LENGTH ; MST[rv.ABSMutator]MSP[]
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.ROR2Mutator]MSP[]
if ( other == null || index2 >= endIndex2 ) { f = 0 ; } else { f = other . charAt ( index2 ) ; } if ( k != f ) { MST[rv.ROR1Mutator]MSP[] final int x = k ^ f ;
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { MST[rv.CRCR6Mutator]MSP[] throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; return key . startsWith ( s1 ) ; }
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; MST[rv.UOI3Mutator]MSP[] return key . startsWith ( s1 ) ; }
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[NegateConditionalsMutator]MSP[]
public boolean isBitSet ( final String key , final int bitIndex , final int lengthInBits ) { if ( key == null || bitIndex >= lengthInBits ) { return false ; } final int index = bitIndex / LENGTH ; MST[rv.AOD1Mutator]MSP[] final int bit = bitIndex % LENGTH ;
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.ROR4Mutator]MSP[]
final int index1 = beginIndex1 + i ; MST[rv.UOI3Mutator]MSP[] final int index2 = beginIndex2 + i ; if ( index1 >= endIndex1 ) { k = 0 ; } else { k = key . charAt ( index1 ) ; }
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; } if ( k != 0 ) { allNull = false ; MST[InlineConstantMutator]MSP[] } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.UOI3Mutator]MSP[]
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { MST[rv.CRCR2Mutator]MSP[] throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; return key . startsWith ( s1 ) ; }
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { MST[rv.ROR3Mutator]MSP[] throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; return key . startsWith ( s1 ) ; }
private static int mask ( final int bit ) { return MSB >>> bit ; } @Override public int bitsPerElement () { return LENGTH ; MST[ReturnValsMutator]MSP[] } @Override public int lengthInBits ( final String key ) { return key != null ? key . length () * LENGTH : 0 ;
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; MST[MathMutator]MSP[] return key . startsWith ( s1 ) ; }
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; MST[rv.UOI3Mutator]MSP[] } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
public boolean isBitSet ( final String key , final int bitIndex , final int lengthInBits ) { if ( key == null || bitIndex >= lengthInBits ) { return false ; } final int index = bitIndex / LENGTH ; MST[rv.CRCR2Mutator]MSP[] final int bit = bitIndex % LENGTH ;
public boolean isBitSet ( final String key , final int bitIndex , final int lengthInBits ) { if ( key == null || bitIndex >= lengthInBits ) { return false ; } final int index = bitIndex / LENGTH ; MST[rv.CRCR6Mutator]MSP[] final int bit = bitIndex % LENGTH ;
final int endIndex2 = beginIndex2 + otherLengthInBits / LENGTH ; final int length = Math . max ( endIndex1 , endIndex2 ) ; MST[rv.ABSMutator]MSP[] char k = 0 , f = 0 ; for ( int i = 0 ; i < length ; i ++ ) {
public boolean isBitSet ( final String key , final int bitIndex , final int lengthInBits ) { if ( key == null || bitIndex >= lengthInBits ) { MST[rv.UOI3Mutator]MSP[] return false ; } final int index = bitIndex / LENGTH ; final int bit = bitIndex % LENGTH ;
|| lengthInBits % LENGTH != 0 || otherLengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } final int beginIndex1 = offsetInBits / LENGTH ; final int beginIndex2 = otherOffsetInBits / LENGTH ; final int endIndex1 = beginIndex1 + lengthInBits / LENGTH ; MST[InlineConstantMutator]MSP[]
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { MST[rv.AOD1Mutator]MSP[] throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; return key . startsWith ( s1 ) ; }
if ( other == null || index2 >= endIndex2 ) { f = 0 ; } else { f = other . charAt ( index2 ) ; } if ( k != f ) { final int x = k ^ f ; MST[rv.UOI1Mutator]MSP[]
if ( other == null || index2 >= endIndex2 ) { f = 0 ; } else { f = other . charAt ( index2 ) ; } if ( k != f ) { MST[rv.UOI4Mutator]MSP[] final int x = k ^ f ;
final int endIndex2 = beginIndex2 + otherLengthInBits / LENGTH ; final int length = Math . max ( endIndex1 , endIndex2 ) ; MST[NonVoidMethodCallMutator]MSP[] char k = 0 , f = 0 ; for ( int i = 0 ; i < length ; i ++ ) {
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.UOI1Mutator]MSP[]
if ( other == null || index2 >= endIndex2 ) { f = 0 ; } else { f = other . charAt ( index2 ) ; } if ( k != f ) { MST[rv.ROR5Mutator]MSP[] final int x = k ^ f ;
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.AOR1Mutator]MSP[]
private static int mask ( final int bit ) { return MSB >>> bit ; } @Override public int bitsPerElement () { return LENGTH ; } @Override public int lengthInBits ( final String key ) { return key != null ? key . length () * LENGTH : 0 ; MST[rv.CRCR3Mutator]MSP[]
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.AOR3Mutator]MSP[]
public boolean isBitSet ( final String key , final int bitIndex , final int lengthInBits ) { if ( key == null || bitIndex >= lengthInBits ) { return false ; } final int index = bitIndex / LENGTH ; MST[InlineConstantMutator]MSP[] final int bit = bitIndex % LENGTH ;
return ( key . charAt ( index ) & mask ( bit ) ) != 0 ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] } @Override public boolean isPrefix ( final String prefix , final int offsetInBits , final int lengthInBits , final String key ) {
final int endIndex2 = beginIndex2 + otherLengthInBits / LENGTH ; MST[rv.UOI4Mutator]MSP[] final int length = Math . max ( endIndex1 , endIndex2 ) ; char k = 0 , f = 0 ; for ( int i = 0 ; i < length ; i ++ ) {
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; MST[rv.AOR1Mutator]MSP[] } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
final int endIndex2 = beginIndex2 + otherLengthInBits / LENGTH ; MST[rv.AOR1Mutator]MSP[] final int length = Math . max ( endIndex1 , endIndex2 ) ; char k = 0 , f = 0 ; for ( int i = 0 ; i < length ; i ++ ) {
|| lengthInBits % LENGTH != 0 || otherLengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } final int beginIndex1 = offsetInBits / LENGTH ; MST[rv.UOI3Mutator]MSP[] final int beginIndex2 = otherOffsetInBits / LENGTH ; final int endIndex1 = beginIndex1 + lengthInBits / LENGTH ;
final int index1 = beginIndex1 + i ; final int index2 = beginIndex2 + i ; if ( index1 >= endIndex1 ) { MST[rv.UOI2Mutator]MSP[] k = 0 ; } else { k = key . charAt ( index1 ) ; }
public boolean isBitSet ( final String key , final int bitIndex , final int lengthInBits ) { if ( key == null || bitIndex >= lengthInBits ) { return false ; MST[rv.CRCR1Mutator]MSP[] } final int index = bitIndex / LENGTH ; final int bit = bitIndex % LENGTH ;
public boolean isBitSet ( final String key , final int bitIndex , final int lengthInBits ) { if ( key == null || bitIndex >= lengthInBits ) { return false ; MST[rv.CRCR5Mutator]MSP[] } final int index = bitIndex / LENGTH ; final int bit = bitIndex % LENGTH ;
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; MST[rv.CRCR3Mutator]MSP[] if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0
|| lengthInBits % LENGTH != 0 || otherLengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } final int beginIndex1 = offsetInBits / LENGTH ; final int beginIndex2 = otherOffsetInBits / LENGTH ; final int endIndex1 = beginIndex1 + lengthInBits / LENGTH ; MST[rv.AOD2Mutator]MSP[]
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; MST[PrimitiveReturnsMutator]MSP[] } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; MST[rv.AOR4Mutator]MSP[] return key . startsWith ( s1 ) ; }
private static int mask ( final int bit ) { return MSB >>> bit ; } @Override public int bitsPerElement () { return LENGTH ; MST[rv.CRCR1Mutator]MSP[] } @Override public int lengthInBits ( final String key ) { return key != null ? key . length () * LENGTH : 0 ;
private static int mask ( final int bit ) { return MSB >>> bit ; } @Override public int bitsPerElement () { return LENGTH ; MST[rv.CRCR5Mutator]MSP[] } @Override public int lengthInBits ( final String key ) { return key != null ? key . length () * LENGTH : 0 ;
final int endIndex2 = beginIndex2 + otherLengthInBits / LENGTH ; final int length = Math . max ( endIndex1 , endIndex2 ) ; char k = 0 , f = 0 ; MST[rv.CRCR3Mutator]MSP[] for ( int i = 0 ; i < length ; i ++ ) {
|| lengthInBits % LENGTH != 0 || otherLengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } final int beginIndex1 = offsetInBits / LENGTH ; MST[MathMutator]MSP[] final int beginIndex2 = otherOffsetInBits / LENGTH ; final int endIndex1 = beginIndex1 + lengthInBits / LENGTH ;
|| lengthInBits % LENGTH != 0 || otherLengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } final int beginIndex1 = offsetInBits / LENGTH ; final int beginIndex2 = otherOffsetInBits / LENGTH ; MST[rv.AOR1Mutator]MSP[] final int endIndex1 = beginIndex1 + lengthInBits / LENGTH ;
if ( other == null || index2 >= endIndex2 ) { f = 0 ; MST[rv.CRCR1Mutator]MSP[] } else { f = other . charAt ( index2 ) ; } if ( k != f ) { final int x = k ^ f ;
|| lengthInBits % LENGTH != 0 || otherLengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } final int beginIndex1 = offsetInBits / LENGTH ; final int beginIndex2 = otherOffsetInBits / LENGTH ; final int endIndex1 = beginIndex1 + lengthInBits / LENGTH ; MST[rv.AOR3Mutator]MSP[]
final int endIndex2 = beginIndex2 + otherLengthInBits / LENGTH ; final int length = Math . max ( endIndex1 , endIndex2 ) ; char k = 0 , f = 0 ; for ( int i = 0 ; i < length ; i ++ ) { MST[rv.ROR3Mutator]MSP[]
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; MST[InlineConstantMutator]MSP[] return key . startsWith ( s1 ) ; }
return ( key . charAt ( index ) & mask ( bit ) ) != 0 ; MST[rv.ROR3Mutator]MSP[] } @Override public boolean isPrefix ( final String prefix , final int offsetInBits , final int lengthInBits , final String key ) {
private static int mask ( final int bit ) { return MSB >>> bit ; } @Override public int bitsPerElement () { return LENGTH ; } @Override public int lengthInBits ( final String key ) { return key != null ? key . length () * LENGTH : 0 ; MST[MathMutator]MSP[]
if ( other == null || index2 >= endIndex2 ) { f = 0 ; MST[rv.CRCR5Mutator]MSP[] } else { f = other . charAt ( index2 ) ; } if ( k != f ) { final int x = k ^ f ;
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; } if ( k != 0 ) { MST[rv.UOI1Mutator]MSP[] allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
final int index1 = beginIndex1 + i ; final int index2 = beginIndex2 + i ; if ( index1 >= endIndex1 ) { MST[rv.UOI2Mutator]MSP[] k = 0 ; } else { k = key . charAt ( index1 ) ; }
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; MST[rv.CRCR3Mutator]MSP[] } @Override
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.ROR5Mutator]MSP[]
|| lengthInBits % LENGTH != 0 || otherLengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } final int beginIndex1 = offsetInBits / LENGTH ; final int beginIndex2 = otherOffsetInBits / LENGTH ; final int endIndex1 = beginIndex1 + lengthInBits / LENGTH ; MST[rv.CRCR2Mutator]MSP[]
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { MST[rv.CRCR3Mutator]MSP[] throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; return key . startsWith ( s1 ) ; }
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.ROR1Mutator]MSP[]
private static int mask ( final int bit ) { return MSB >>> bit ; } @Override public int bitsPerElement () { return LENGTH ; } @Override public int lengthInBits ( final String key ) { return key != null ? key . length () * LENGTH : 0 ; MST[ReturnValsMutator]MSP[]
|| lengthInBits % LENGTH != 0 || otherLengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } final int beginIndex1 = offsetInBits / LENGTH ; final int beginIndex2 = otherOffsetInBits / LENGTH ; MST[rv.CRCR1Mutator]MSP[] final int endIndex1 = beginIndex1 + lengthInBits / LENGTH ;
|| lengthInBits % LENGTH != 0 || otherLengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } final int beginIndex1 = offsetInBits / LENGTH ; final int beginIndex2 = otherOffsetInBits / LENGTH ; final int endIndex1 = beginIndex1 + lengthInBits / LENGTH ; MST[rv.CRCR6Mutator]MSP[]
final int index1 = beginIndex1 + i ; final int index2 = beginIndex2 + i ; if ( index1 >= endIndex1 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] k = 0 ; } else { k = key . charAt ( index1 ) ; }
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { MST[rv.AOR3Mutator]MSP[] throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; return key . startsWith ( s1 ) ; }
if ( other == null || index2 >= endIndex2 ) { f = 0 ; } else { f = other . charAt ( index2 ) ; MST[rv.UOI2Mutator]MSP[] } if ( k != f ) { final int x = k ^ f ;
if ( other == null || index2 >= endIndex2 ) { f = 0 ; } else { f = other . charAt ( index2 ) ; } if ( k != f ) { MST[NegateConditionalsMutator]MSP[] final int x = k ^ f ;
public boolean isBitSet ( final String key , final int bitIndex , final int lengthInBits ) { if ( key == null || bitIndex >= lengthInBits ) { return false ; } final int index = bitIndex / LENGTH ; MST[rv.AOR3Mutator]MSP[] final int bit = bitIndex % LENGTH ;
|| lengthInBits % LENGTH != 0 || otherLengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } final int beginIndex1 = offsetInBits / LENGTH ; final int beginIndex2 = otherOffsetInBits / LENGTH ; MST[rv.CRCR5Mutator]MSP[] final int endIndex1 = beginIndex1 + lengthInBits / LENGTH ;
|| lengthInBits % LENGTH != 0 || otherLengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } final int beginIndex1 = offsetInBits / LENGTH ; MST[rv.CRCR3Mutator]MSP[] final int beginIndex2 = otherOffsetInBits / LENGTH ; final int endIndex1 = beginIndex1 + lengthInBits / LENGTH ;
final int endIndex2 = beginIndex2 + otherLengthInBits / LENGTH ; final int length = Math . max ( endIndex1 , endIndex2 ) ; char k = 0 , f = 0 ; for ( int i = 0 ; i < length ; i ++ ) { MST[rv.UOI2Mutator]MSP[]
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; MST[rv.AOD2Mutator]MSP[] } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.UOI2Mutator]MSP[]
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; MST[rv.CRCR4Mutator]MSP[] return key . startsWith ( s1 ) ; }
if ( other == null || index2 >= endIndex2 ) { f = 0 ; } else { f = other . charAt ( index2 ) ; MST[NonVoidMethodCallMutator]MSP[] } if ( k != f ) { final int x = k ^ f ;
if ( other == null || index2 >= endIndex2 ) { f = 0 ; } else { f = other . charAt ( index2 ) ; } if ( k != f ) { MST[rv.UOI4Mutator]MSP[] final int x = k ^ f ;
private static int mask ( final int bit ) { return MSB >>> bit ; } @Override public int bitsPerElement () { return LENGTH ; } @Override public int lengthInBits ( final String key ) { return key != null ? key . length () * LENGTH : 0 ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.AOR2Mutator]MSP[]
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; MST[rv.CRCR3Mutator]MSP[] return key . startsWith ( s1 ) ; }
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; MST[rv.AOR3Mutator]MSP[] } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
public boolean isBitSet ( final String key , final int bitIndex , final int lengthInBits ) { if ( key == null || bitIndex >= lengthInBits ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] return false ; } final int index = bitIndex / LENGTH ; final int bit = bitIndex % LENGTH ;
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.CRCR3Mutator]MSP[]
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.CRCR2Mutator]MSP[]
if ( other == null || index2 >= endIndex2 ) { MST[rv.ROR4Mutator]MSP[] f = 0 ; } else { f = other . charAt ( index2 ) ; } if ( k != f ) { final int x = k ^ f ;
private static int mask ( final int bit ) { return MSB >>> bit ; MST[rv.CRCR6Mutator]MSP[] } @Override public int bitsPerElement () { return LENGTH ; } @Override public int lengthInBits ( final String key ) { return key != null ? key . length () * LENGTH : 0 ;
private static int mask ( final int bit ) { return MSB >>> bit ; MST[rv.CRCR1Mutator]MSP[] } @Override public int bitsPerElement () { return LENGTH ; } @Override public int lengthInBits ( final String key ) { return key != null ? key . length () * LENGTH : 0 ;
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.CRCR1Mutator]MSP[]
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; } if ( k != 0 ) { MST[rv.ABSMutator]MSP[] allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
if ( other == null || index2 >= endIndex2 ) { MST[rv.ROR1Mutator]MSP[] f = 0 ; } else { f = other . charAt ( index2 ) ; } if ( k != f ) { final int x = k ^ f ;
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.CRCR5Mutator]MSP[]
return ( key . charAt ( index ) & mask ( bit ) ) != 0 ; MST[rv.UOI2Mutator]MSP[] } @Override public boolean isPrefix ( final String prefix , final int offsetInBits , final int lengthInBits , final String key ) {
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.CRCR6Mutator]MSP[]
|| lengthInBits % LENGTH != 0 || otherLengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } final int beginIndex1 = offsetInBits / LENGTH ; final int beginIndex2 = otherOffsetInBits / LENGTH ; final int endIndex1 = beginIndex1 + lengthInBits / LENGTH ; MST[rv.AOD2Mutator]MSP[]
final int index1 = beginIndex1 + i ; final int index2 = beginIndex2 + i ; if ( index1 >= endIndex1 ) { MST[rv.ROR3Mutator]MSP[] k = 0 ; } else { k = key . charAt ( index1 ) ; }
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { MST[InlineConstantMutator]MSP[] throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; return key . startsWith ( s1 ) ; }
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.CRCR4Mutator]MSP[]
return ( key . charAt ( index ) & mask ( bit ) ) != 0 ; MST[NonVoidMethodCallMutator]MSP[] } @Override public boolean isPrefix ( final String prefix , final int offsetInBits , final int lengthInBits , final String key ) {
private static int mask ( final int bit ) { return MSB >>> bit ; MST[rv.UOI2Mutator]MSP[] } @Override public int bitsPerElement () { return LENGTH ; } @Override public int lengthInBits ( final String key ) { return key != null ? key . length () * LENGTH : 0 ;
final int endIndex2 = beginIndex2 + otherLengthInBits / LENGTH ; MST[rv.CRCR1Mutator]MSP[] final int length = Math . max ( endIndex1 , endIndex2 ) ; char k = 0 , f = 0 ; for ( int i = 0 ; i < length ; i ++ ) {
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; MST[rv.UOI2Mutator]MSP[] return key . startsWith ( s1 ) ; }
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.ABSMutator]MSP[]
|| lengthInBits % LENGTH != 0 || otherLengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } final int beginIndex1 = offsetInBits / LENGTH ; final int beginIndex2 = otherOffsetInBits / LENGTH ; final int endIndex1 = beginIndex1 + lengthInBits / LENGTH ; MST[rv.AOR3Mutator]MSP[]
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; } if ( k != 0 ) { MST[rv.UOI2Mutator]MSP[] allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
final int endIndex2 = beginIndex2 + otherLengthInBits / LENGTH ; final int length = Math . max ( endIndex1 , endIndex2 ) ; char k = 0 , f = 0 ; for ( int i = 0 ; i < length ; i ++ ) { MST[ConditionalsBoundaryMutator]MSP[]
public boolean isBitSet ( final String key , final int bitIndex , final int lengthInBits ) { if ( key == null || bitIndex >= lengthInBits ) { return false ; } final int index = bitIndex / LENGTH ; final int bit = bitIndex % LENGTH ; MST[rv.AOR4Mutator]MSP[]
final int index1 = beginIndex1 + i ; final int index2 = beginIndex2 + i ; MST[rv.AOR1Mutator]MSP[] if ( index1 >= endIndex1 ) { k = 0 ; } else { k = key . charAt ( index1 ) ; }
final int index1 = beginIndex1 + i ; final int index2 = beginIndex2 + i ; MST[rv.UOI1Mutator]MSP[] if ( index1 >= endIndex1 ) { k = 0 ; } else { k = key . charAt ( index1 ) ; }
public boolean isBitSet ( final String key , final int bitIndex , final int lengthInBits ) { if ( key == null || bitIndex >= lengthInBits ) { MST[rv.UOI4Mutator]MSP[] return false ; } final int index = bitIndex / LENGTH ; final int bit = bitIndex % LENGTH ;
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { MST[rv.UOI2Mutator]MSP[] throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; return key . startsWith ( s1 ) ; }
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; MST[InlineConstantMutator]MSP[] } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.AOD2Mutator]MSP[]
final int index1 = beginIndex1 + i ; final int index2 = beginIndex2 + i ; if ( index1 >= endIndex1 ) { k = 0 ; MST[rv.CRCR3Mutator]MSP[] } else { k = key . charAt ( index1 ) ; }
private static int mask ( final int bit ) { return MSB >>> bit ; } @Override public int bitsPerElement () { return LENGTH ; } @Override public int lengthInBits ( final String key ) { return key != null ? key . length () * LENGTH : 0 ; MST[rv.CRCR1Mutator]MSP[]
|| lengthInBits % LENGTH != 0 || otherLengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } final int beginIndex1 = offsetInBits / LENGTH ; final int beginIndex2 = otherOffsetInBits / LENGTH ; MST[rv.CRCR4Mutator]MSP[] final int endIndex1 = beginIndex1 + lengthInBits / LENGTH ;
public boolean isBitSet ( final String key , final int bitIndex , final int lengthInBits ) { if ( key == null || bitIndex >= lengthInBits ) { MST[rv.ROR1Mutator]MSP[] return false ; } final int index = bitIndex / LENGTH ; final int bit = bitIndex % LENGTH ;
if ( other == null || index2 >= endIndex2 ) { f = 0 ; } else { f = other . charAt ( index2 ) ; } if ( k != f ) { final int x = k ^ f ; MST[rv.ABSMutator]MSP[]
return ( key . charAt ( index ) & mask ( bit ) ) != 0 ; MST[rv.CRCR2Mutator]MSP[] } @Override public boolean isPrefix ( final String prefix , final int offsetInBits , final int lengthInBits , final String key ) {
public boolean isBitSet ( final String key , final int bitIndex , final int lengthInBits ) { if ( key == null || bitIndex >= lengthInBits ) { return false ; } final int index = bitIndex / LENGTH ; final int bit = bitIndex % LENGTH ; MST[rv.UOI4Mutator]MSP[]
if ( other == null || index2 >= endIndex2 ) { MST[NegateConditionalsMutator]MSP[] f = 0 ; } else { f = other . charAt ( index2 ) ; } if ( k != f ) { final int x = k ^ f ;
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.AOR4Mutator]MSP[]
public boolean isBitSet ( final String key , final int bitIndex , final int lengthInBits ) { if ( key == null || bitIndex >= lengthInBits ) { return false ; } final int index = bitIndex / LENGTH ; MST[rv.UOI2Mutator]MSP[] final int bit = bitIndex % LENGTH ;
private static int mask ( final int bit ) { return MSB >>> bit ; MST[PrimitiveReturnsMutator]MSP[] } @Override public int bitsPerElement () { return LENGTH ; } @Override public int lengthInBits ( final String key ) { return key != null ? key . length () * LENGTH : 0 ;
if ( other == null || index2 >= endIndex2 ) { f = 0 ; } else { f = other . charAt ( index2 ) ; MST[rv.UOI3Mutator]MSP[] } if ( k != f ) { final int x = k ^ f ;
final int index1 = beginIndex1 + i ; MST[rv.AOR4Mutator]MSP[] final int index2 = beginIndex2 + i ; if ( index1 >= endIndex1 ) { k = 0 ; } else { k = key . charAt ( index1 ) ; }
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; MST[rv.AOR4Mutator]MSP[] } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
final int endIndex2 = beginIndex2 + otherLengthInBits / LENGTH ; final int length = Math . max ( endIndex1 , endIndex2 ) ; MST[rv.UOI2Mutator]MSP[] char k = 0 , f = 0 ; for ( int i = 0 ; i < length ; i ++ ) {
if ( other == null || index2 >= endIndex2 ) { MST[rv.UOI4Mutator]MSP[] f = 0 ; } else { f = other . charAt ( index2 ) ; } if ( k != f ) { final int x = k ^ f ;
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; MST[rv.AOR1Mutator]MSP[] } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; MST[rv.AOD2Mutator]MSP[] return key . startsWith ( s1 ) ; }
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; MST[rv.CRCR2Mutator]MSP[] } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
if ( other == null || index2 >= endIndex2 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[] f = 0 ; } else { f = other . charAt ( index2 ) ; } if ( k != f ) { final int x = k ^ f ;
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[MathMutator]MSP[]
|| lengthInBits % LENGTH != 0 || otherLengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } final int beginIndex1 = offsetInBits / LENGTH ; final int beginIndex2 = otherOffsetInBits / LENGTH ; final int endIndex1 = beginIndex1 + lengthInBits / LENGTH ; MST[rv.UOI2Mutator]MSP[]
public boolean isBitSet ( final String key , final int bitIndex , final int lengthInBits ) { if ( key == null || bitIndex >= lengthInBits ) { return false ; } final int index = bitIndex / LENGTH ; final int bit = bitIndex % LENGTH ; MST[MathMutator]MSP[]
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { MST[rv.UOI1Mutator]MSP[] return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[InlineConstantMutator]MSP[]
final int index1 = beginIndex1 + i ; final int index2 = beginIndex2 + i ; if ( index1 >= endIndex1 ) { k = 0 ; } else { k = key . charAt ( index1 ) ; MST[rv.ABSMutator]MSP[] }
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; MST[MathMutator]MSP[] } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
private static int mask ( final int bit ) { return MSB >>> bit ; } @Override public int bitsPerElement () { return LENGTH ; MST[rv.CRCR6Mutator]MSP[] } @Override public int lengthInBits ( final String key ) { return key != null ? key . length () * LENGTH : 0 ;
final int index1 = beginIndex1 + i ; MST[MathMutator]MSP[] final int index2 = beginIndex2 + i ; if ( index1 >= endIndex1 ) { k = 0 ; } else { k = key . charAt ( index1 ) ; }
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { MST[rv.CRCR5Mutator]MSP[] throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; return key . startsWith ( s1 ) ; }
public boolean isBitSet ( final String key , final int bitIndex , final int lengthInBits ) { if ( key == null || bitIndex >= lengthInBits ) { return false ; } final int index = bitIndex / LENGTH ; final int bit = bitIndex % LENGTH ; MST[rv.CRCR3Mutator]MSP[]
if ( other == null || index2 >= endIndex2 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] f = 0 ; } else { f = other . charAt ( index2 ) ; } if ( k != f ) { final int x = k ^ f ;
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.ROR3Mutator]MSP[]
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.UOI4Mutator]MSP[]
public boolean isBitSet ( final String key , final int bitIndex , final int lengthInBits ) { if ( key == null || bitIndex >= lengthInBits ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[] return false ; } final int index = bitIndex / LENGTH ; final int bit = bitIndex % LENGTH ;
final int index1 = beginIndex1 + i ; final int index2 = beginIndex2 + i ; if ( index1 >= endIndex1 ) { MST[rv.UOI3Mutator]MSP[] k = 0 ; } else { k = key . charAt ( index1 ) ; }
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; MST[rv.UOI3Mutator]MSP[] } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
final int index1 = beginIndex1 + i ; MST[rv.UOI4Mutator]MSP[] final int index2 = beginIndex2 + i ; if ( index1 >= endIndex1 ) { k = 0 ; } else { k = key . charAt ( index1 ) ; }
public boolean isBitSet ( final String key , final int bitIndex , final int lengthInBits ) { if ( key == null || bitIndex >= lengthInBits ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return false ; } final int index = bitIndex / LENGTH ; final int bit = bitIndex % LENGTH ;
final int endIndex2 = beginIndex2 + otherLengthInBits / LENGTH ; MST[rv.CRCR4Mutator]MSP[] final int length = Math . max ( endIndex1 , endIndex2 ) ; char k = 0 , f = 0 ; for ( int i = 0 ; i < length ; i ++ ) {
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; MST[rv.UOI4Mutator]MSP[] } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
final int index1 = beginIndex1 + i ; final int index2 = beginIndex2 + i ; MST[rv.UOI1Mutator]MSP[] if ( index1 >= endIndex1 ) { k = 0 ; } else { k = key . charAt ( index1 ) ; }
final int index1 = beginIndex1 + i ; final int index2 = beginIndex2 + i ; MST[rv.ABSMutator]MSP[] if ( index1 >= endIndex1 ) { k = 0 ; } else { k = key . charAt ( index1 ) ; }
public boolean isBitSet ( final String key , final int bitIndex , final int lengthInBits ) { if ( key == null || bitIndex >= lengthInBits ) { MST[rv.UOI4Mutator]MSP[] return false ; } final int index = bitIndex / LENGTH ; final int bit = bitIndex % LENGTH ;
return ( key . charAt ( index ) & mask ( bit ) ) != 0 ; MST[rv.CRCR3Mutator]MSP[] } @Override public boolean isPrefix ( final String prefix , final int offsetInBits , final int lengthInBits , final String key ) {
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.AOD1Mutator]MSP[]
public boolean isBitSet ( final String key , final int bitIndex , final int lengthInBits ) { if ( key == null || bitIndex >= lengthInBits ) { MST[NegateConditionalsMutator]MSP[] return false ; } final int index = bitIndex / LENGTH ; final int bit = bitIndex % LENGTH ;
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { MST[rv.UOI1Mutator]MSP[] throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; return key . startsWith ( s1 ) ; }
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { MST[rv.ROR4Mutator]MSP[] throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; return key . startsWith ( s1 ) ; }
final int index1 = beginIndex1 + i ; final int index2 = beginIndex2 + i ; if ( index1 >= endIndex1 ) { MST[ConditionalsBoundaryMutator]MSP[] k = 0 ; } else { k = key . charAt ( index1 ) ; }
if ( other == null || index2 >= endIndex2 ) { f = 0 ; } else { f = other . charAt ( index2 ) ; } if ( k != f ) { final int x = k ^ f ; MST[rv.UOI1Mutator]MSP[]
public boolean isBitSet ( final String key , final int bitIndex , final int lengthInBits ) { if ( key == null || bitIndex >= lengthInBits ) { return false ; } final int index = bitIndex / LENGTH ; MST[rv.AOD2Mutator]MSP[] final int bit = bitIndex % LENGTH ;
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { MST[rv.AOD2Mutator]MSP[] throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; return key . startsWith ( s1 ) ; }
public boolean isBitSet ( final String key , final int bitIndex , final int lengthInBits ) { if ( key == null || bitIndex >= lengthInBits ) { MST[rv.ROR4Mutator]MSP[] return false ; } final int index = bitIndex / LENGTH ; final int bit = bitIndex % LENGTH ;
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { MST[rv.ABSMutator]MSP[] throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; return key . startsWith ( s1 ) ; }
if ( other == null || index2 >= endIndex2 ) { f = 0 ; } else { f = other . charAt ( index2 ) ; } if ( k != f ) { MST[rv.ROR2Mutator]MSP[] final int x = k ^ f ;
if ( other == null || index2 >= endIndex2 ) { f = 0 ; } else { f = other . charAt ( index2 ) ; } if ( k != f ) { final int x = k ^ f ; MST[rv.ABSMutator]MSP[]
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; MST[rv.CRCR1Mutator]MSP[] } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
final int endIndex2 = beginIndex2 + otherLengthInBits / LENGTH ; MST[rv.UOI1Mutator]MSP[] final int length = Math . max ( endIndex1 , endIndex2 ) ; char k = 0 , f = 0 ; for ( int i = 0 ; i < length ; i ++ ) {
if ( other == null || index2 >= endIndex2 ) { MST[rv.UOI4Mutator]MSP[] f = 0 ; } else { f = other . charAt ( index2 ) ; } if ( k != f ) { final int x = k ^ f ;
final int endIndex2 = beginIndex2 + otherLengthInBits / LENGTH ; final int length = Math . max ( endIndex1 , endIndex2 ) ; MST[rv.UOI3Mutator]MSP[] char k = 0 , f = 0 ; for ( int i = 0 ; i < length ; i ++ ) {
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; MST[rv.CRCR3Mutator]MSP[] } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
|| lengthInBits % LENGTH != 0 || otherLengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } final int beginIndex1 = offsetInBits / LENGTH ; MST[rv.ABSMutator]MSP[] final int beginIndex2 = otherOffsetInBits / LENGTH ; final int endIndex1 = beginIndex1 + lengthInBits / LENGTH ;
final int index1 = beginIndex1 + i ; final int index2 = beginIndex2 + i ; if ( index1 >= endIndex1 ) { k = 0 ; } else { k = key . charAt ( index1 ) ; MST[NonVoidMethodCallMutator]MSP[] }
return ( key . charAt ( index ) & mask ( bit ) ) != 0 ; MST[rv.UOI2Mutator]MSP[] } @Override public boolean isPrefix ( final String prefix , final int offsetInBits , final int lengthInBits , final String key ) {
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; MST[rv.CRCR5Mutator]MSP[] } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
final int endIndex2 = beginIndex2 + otherLengthInBits / LENGTH ; final int length = Math . max ( endIndex1 , endIndex2 ) ; char k = 0 , f = 0 ; MST[rv.CRCR1Mutator]MSP[] for ( int i = 0 ; i < length ; i ++ ) {
final int endIndex2 = beginIndex2 + otherLengthInBits / LENGTH ; MST[rv.AOR2Mutator]MSP[] final int length = Math . max ( endIndex1 , endIndex2 ) ; char k = 0 , f = 0 ; for ( int i = 0 ; i < length ; i ++ ) {
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
|| lengthInBits % LENGTH != 0 || otherLengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } final int beginIndex1 = offsetInBits / LENGTH ; final int beginIndex2 = otherOffsetInBits / LENGTH ; final int endIndex1 = beginIndex1 + lengthInBits / LENGTH ; MST[rv.UOI3Mutator]MSP[]
final int endIndex2 = beginIndex2 + otherLengthInBits / LENGTH ; final int length = Math . max ( endIndex1 , endIndex2 ) ; char k = 0 , f = 0 ; MST[rv.CRCR3Mutator]MSP[] for ( int i = 0 ; i < length ; i ++ ) {
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { MST[rv.ROR5Mutator]MSP[] return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
final int index1 = beginIndex1 + i ; final int index2 = beginIndex2 + i ; if ( index1 >= endIndex1 ) { k = 0 ; } else { k = key . charAt ( index1 ) ; MST[rv.UOI2Mutator]MSP[] }
return ( key . charAt ( index ) & mask ( bit ) ) != 0 ; MST[NonVoidMethodCallMutator]MSP[] } @Override public boolean isPrefix ( final String prefix , final int offsetInBits , final int lengthInBits , final String key ) {
|| lengthInBits % LENGTH != 0 || otherLengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } final int beginIndex1 = offsetInBits / LENGTH ; final int beginIndex2 = otherOffsetInBits / LENGTH ; final int endIndex1 = beginIndex1 + lengthInBits / LENGTH ; MST[rv.AOR4Mutator]MSP[]
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; MST[InlineConstantMutator]MSP[] return key . startsWith ( s1 ) ; }
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
return ( key . charAt ( index ) & mask ( bit ) ) != 0 ; MST[rv.ROR2Mutator]MSP[] } @Override public boolean isPrefix ( final String prefix , final int offsetInBits , final int lengthInBits , final String key ) {
public boolean isBitSet ( final String key , final int bitIndex , final int lengthInBits ) { if ( key == null || bitIndex >= lengthInBits ) { return false ; } final int index = bitIndex / LENGTH ; MST[rv.AOR4Mutator]MSP[] final int bit = bitIndex % LENGTH ;
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.ROR4Mutator]MSP[]
|| lengthInBits % LENGTH != 0 || otherLengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } final int beginIndex1 = offsetInBits / LENGTH ; MST[rv.UOI4Mutator]MSP[] final int beginIndex2 = otherOffsetInBits / LENGTH ; final int endIndex1 = beginIndex1 + lengthInBits / LENGTH ;
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { MST[rv.ROR5Mutator]MSP[] throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; return key . startsWith ( s1 ) ; }
final int index1 = beginIndex1 + i ; final int index2 = beginIndex2 + i ; if ( index1 >= endIndex1 ) { MST[rv.UOI3Mutator]MSP[] k = 0 ; } else { k = key . charAt ( index1 ) ; }
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; MST[rv.CRCR2Mutator]MSP[] } @Override
private static int mask ( final int bit ) { return MSB >>> bit ; MST[InlineConstantMutator]MSP[] } @Override public int bitsPerElement () { return LENGTH ; } @Override public int lengthInBits ( final String key ) { return key != null ? key . length () * LENGTH : 0 ;
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { MST[rv.CRCR2Mutator]MSP[] throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; return key . startsWith ( s1 ) ; }
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { MST[rv.ROR3Mutator]MSP[] throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; return key . startsWith ( s1 ) ; }
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; MST[rv.CRCR6Mutator]MSP[] } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
return ( key . charAt ( index ) & mask ( bit ) ) != 0 ; MST[rv.ABSMutator]MSP[] } @Override public boolean isPrefix ( final String prefix , final int offsetInBits , final int lengthInBits , final String key ) {
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.UOI1Mutator]MSP[]
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.ROR2Mutator]MSP[]
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[NegateConditionalsMutator]MSP[]
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.AOR1Mutator]MSP[]
final int index1 = beginIndex1 + i ; MST[rv.AOR1Mutator]MSP[] final int index2 = beginIndex2 + i ; if ( index1 >= endIndex1 ) { k = 0 ; } else { k = key . charAt ( index1 ) ; }
|| lengthInBits % LENGTH != 0 || otherLengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } final int beginIndex1 = offsetInBits / LENGTH ; MST[rv.CRCR2Mutator]MSP[] final int beginIndex2 = otherOffsetInBits / LENGTH ; final int endIndex1 = beginIndex1 + lengthInBits / LENGTH ;
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; MST[rv.AOD1Mutator]MSP[] } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.UOI3Mutator]MSP[]
if ( other == null || index2 >= endIndex2 ) { f = 0 ; } else { f = other . charAt ( index2 ) ; } if ( k != f ) { final int x = k ^ f ; MST[rv.UOI2Mutator]MSP[]
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; MST[rv.AOD2Mutator]MSP[] } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; MST[rv.CRCR2Mutator]MSP[] return key . startsWith ( s1 ) ; }
final int endIndex2 = beginIndex2 + otherLengthInBits / LENGTH ; MST[MathMutator]MSP[] final int length = Math . max ( endIndex1 , endIndex2 ) ; char k = 0 , f = 0 ; for ( int i = 0 ; i < length ; i ++ ) {
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.AOR3Mutator]MSP[]
|| lengthInBits % LENGTH != 0 || otherLengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } final int beginIndex1 = offsetInBits / LENGTH ; MST[rv.CRCR6Mutator]MSP[] final int beginIndex2 = otherOffsetInBits / LENGTH ; final int endIndex1 = beginIndex1 + lengthInBits / LENGTH ;
private static int mask ( final int bit ) { return MSB >>> bit ; } @Override public int bitsPerElement () { return LENGTH ; } @Override public int lengthInBits ( final String key ) { return key != null ? key . length () * LENGTH : 0 ; MST[rv.CRCR2Mutator]MSP[]
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.AOR2Mutator]MSP[]
private static int mask ( final int bit ) { return MSB >>> bit ; } @Override public int bitsPerElement () { return LENGTH ; } @Override public int lengthInBits ( final String key ) { return key != null ? key . length () * LENGTH : 0 ; MST[rv.AOD1Mutator]MSP[]
public boolean isBitSet ( final String key , final int bitIndex , final int lengthInBits ) { if ( key == null || bitIndex >= lengthInBits ) { return false ; } final int index = bitIndex / LENGTH ; MST[rv.UOI3Mutator]MSP[] final int bit = bitIndex % LENGTH ;
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; return key . startsWith ( s1 ) ; }
|| lengthInBits % LENGTH != 0 || otherLengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } final int beginIndex1 = offsetInBits / LENGTH ; MST[rv.AOD1Mutator]MSP[] final int beginIndex2 = otherOffsetInBits / LENGTH ; final int endIndex1 = beginIndex1 + lengthInBits / LENGTH ;
final int endIndex2 = beginIndex2 + otherLengthInBits / LENGTH ; final int length = Math . max ( endIndex1 , endIndex2 ) ; MST[rv.UOI3Mutator]MSP[] char k = 0 , f = 0 ; for ( int i = 0 ; i < length ; i ++ ) {
public boolean isBitSet ( final String key , final int bitIndex , final int lengthInBits ) { if ( key == null || bitIndex >= lengthInBits ) { return false ; } final int index = bitIndex / LENGTH ; final int bit = bitIndex % LENGTH ; MST[rv.AOR1Mutator]MSP[]
final int endIndex2 = beginIndex2 + otherLengthInBits / LENGTH ; final int length = Math . max ( endIndex1 , endIndex2 ) ; char k = 0 , f = 0 ; for ( int i = 0 ; i < length ; i ++ ) { MST[InlineConstantMutator]MSP[]
final int endIndex2 = beginIndex2 + otherLengthInBits / LENGTH ; MST[rv.AOR2Mutator]MSP[] final int length = Math . max ( endIndex1 , endIndex2 ) ; char k = 0 , f = 0 ; for ( int i = 0 ; i < length ; i ++ ) {
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; MST[rv.AOR1Mutator]MSP[] return key . startsWith ( s1 ) ; }
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; MST[MathMutator]MSP[] } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; MST[rv.CRCR2Mutator]MSP[] if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0
|| lengthInBits % LENGTH != 0 || otherLengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } final int beginIndex1 = offsetInBits / LENGTH ; final int beginIndex2 = otherOffsetInBits / LENGTH ; final int endIndex1 = beginIndex1 + lengthInBits / LENGTH ; MST[rv.UOI3Mutator]MSP[]
|| lengthInBits % LENGTH != 0 || otherLengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } final int beginIndex1 = offsetInBits / LENGTH ; final int beginIndex2 = otherOffsetInBits / LENGTH ; MST[rv.UOI1Mutator]MSP[] final int endIndex1 = beginIndex1 + lengthInBits / LENGTH ;
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { MST[NegateConditionalsMutator]MSP[] return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
private static int mask ( final int bit ) { return MSB >>> bit ; } @Override public int bitsPerElement () { return LENGTH ; MST[rv.CRCR4Mutator]MSP[] } @Override public int lengthInBits ( final String key ) { return key != null ? key . length () * LENGTH : 0 ;
final int endIndex2 = beginIndex2 + otherLengthInBits / LENGTH ; final int length = Math . max ( endIndex1 , endIndex2 ) ; char k = 0 , f = 0 ; MST[rv.CRCR6Mutator]MSP[] for ( int i = 0 ; i < length ; i ++ ) {
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; MST[rv.CRCR6Mutator]MSP[] if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0
public boolean isBitSet ( final String key , final int bitIndex , final int lengthInBits ) { if ( key == null || bitIndex >= lengthInBits ) { return false ; } final int index = bitIndex / LENGTH ; final int bit = bitIndex % LENGTH ; MST[rv.AOD2Mutator]MSP[]
public boolean isBitSet ( final String key , final int bitIndex , final int lengthInBits ) { if ( key == null || bitIndex >= lengthInBits ) { return false ; } final int index = bitIndex / LENGTH ; final int bit = bitIndex % LENGTH ; MST[rv.CRCR1Mutator]MSP[]
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; MST[rv.ABSMutator]MSP[] } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; MST[ReturnValsMutator]MSP[] } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { MST[rv.ROR2Mutator]MSP[] throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; return key . startsWith ( s1 ) ; }
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; MST[MathMutator]MSP[] return key . startsWith ( s1 ) ; }
return ( key . charAt ( index ) & mask ( bit ) ) != 0 ; MST[rv.CRCR1Mutator]MSP[] } @Override public boolean isPrefix ( final String prefix , final int offsetInBits , final int lengthInBits , final String key ) {
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.ROR1Mutator]MSP[]
final int endIndex2 = beginIndex2 + otherLengthInBits / LENGTH ; final int length = Math . max ( endIndex1 , endIndex2 ) ; char k = 0 , f = 0 ; for ( int i = 0 ; i < length ; i ++ ) { MST[rv.UOI3Mutator]MSP[]
if ( other == null || index2 >= endIndex2 ) { f = 0 ; } else { f = other . charAt ( index2 ) ; } if ( k != f ) { final int x = k ^ f ; MST[rv.UOI2Mutator]MSP[]
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.ROR5Mutator]MSP[]
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.UOI2Mutator]MSP[]
if ( other == null || index2 >= endIndex2 ) { f = 0 ; } else { f = other . charAt ( index2 ) ; } if ( k != f ) { MST[rv.ROR4Mutator]MSP[] final int x = k ^ f ;
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; } if ( k != 0 ) { allNull = false ; MST[rv.CRCR6Mutator]MSP[] } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; } if ( k != 0 ) { allNull = false ; MST[rv.CRCR5Mutator]MSP[] } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
final int index1 = beginIndex1 + i ; final int index2 = beginIndex2 + i ; if ( index1 >= endIndex1 ) { k = 0 ; MST[rv.CRCR6Mutator]MSP[] } else { k = key . charAt ( index1 ) ; }
public boolean isBitSet ( final String key , final int bitIndex , final int lengthInBits ) { if ( key == null || bitIndex >= lengthInBits ) { MST[rv.ROR3Mutator]MSP[] return false ; } final int index = bitIndex / LENGTH ; final int bit = bitIndex % LENGTH ;
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { MST[rv.AOR1Mutator]MSP[] throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; return key . startsWith ( s1 ) ; }
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; MST[rv.CRCR3Mutator]MSP[] return key . startsWith ( s1 ) ; }
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; MST[rv.AOR4Mutator]MSP[] } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
final int index1 = beginIndex1 + i ; final int index2 = beginIndex2 + i ; if ( index1 >= endIndex1 ) { MST[rv.ROR1Mutator]MSP[] k = 0 ; } else { k = key . charAt ( index1 ) ; }
if ( other == null || index2 >= endIndex2 ) { MST[rv.ROR3Mutator]MSP[] f = 0 ; } else { f = other . charAt ( index2 ) ; } if ( k != f ) { final int x = k ^ f ;
if ( other == null || index2 >= endIndex2 ) { MST[rv.ROR2Mutator]MSP[] f = 0 ; } else { f = other . charAt ( index2 ) ; } if ( k != f ) { final int x = k ^ f ;
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.CRCR1Mutator]MSP[]
final int index1 = beginIndex1 + i ; final int index2 = beginIndex2 + i ; if ( index1 >= endIndex1 ) { MST[rv.ABSMutator]MSP[] k = 0 ; } else { k = key . charAt ( index1 ) ; }
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.CRCR2Mutator]MSP[]
private static int mask ( final int bit ) { return MSB >>> bit ; MST[rv.CRCR2Mutator]MSP[] } @Override public int bitsPerElement () { return LENGTH ; } @Override public int lengthInBits ( final String key ) { return key != null ? key . length () * LENGTH : 0 ;
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.CRCR5Mutator]MSP[]
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; MST[rv.AOR1Mutator]MSP[] return key . startsWith ( s1 ) ; }
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.CRCR6Mutator]MSP[]
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { MST[InlineConstantMutator]MSP[] throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; return key . startsWith ( s1 ) ; }
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; } if ( k != 0 ) { MST[rv.ROR5Mutator]MSP[] allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
return ( key . charAt ( index ) & mask ( bit ) ) != 0 ; MST[rv.UOI3Mutator]MSP[] } @Override public boolean isPrefix ( final String prefix , final int offsetInBits , final int lengthInBits , final String key ) {
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.CRCR4Mutator]MSP[]
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; MST[NonVoidMethodCallMutator]MSP[] return key . startsWith ( s1 ) ; }
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; return key . startsWith ( s1 ) ; MST[ReturnValsMutator]MSP[] }
|| lengthInBits % LENGTH != 0 || otherLengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } final int beginIndex1 = offsetInBits / LENGTH ; final int beginIndex2 = otherOffsetInBits / LENGTH ; final int endIndex1 = beginIndex1 + lengthInBits / LENGTH ; MST[rv.AOD1Mutator]MSP[]
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.CRCR3Mutator]MSP[]
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { MST[MathMutator]MSP[] throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; return key . startsWith ( s1 ) ; }
|| lengthInBits % LENGTH != 0 || otherLengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } final int beginIndex1 = offsetInBits / LENGTH ; final int beginIndex2 = otherOffsetInBits / LENGTH ; MST[rv.AOR2Mutator]MSP[] final int endIndex1 = beginIndex1 + lengthInBits / LENGTH ;
public boolean isBitSet ( final String key , final int bitIndex , final int lengthInBits ) { if ( key == null || bitIndex >= lengthInBits ) { return false ; } final int index = bitIndex / LENGTH ; final int bit = bitIndex % LENGTH ; MST[rv.CRCR2Mutator]MSP[]
final int index1 = beginIndex1 + i ; final int index2 = beginIndex2 + i ; if ( index1 >= endIndex1 ) { MST[rv.UOI4Mutator]MSP[] k = 0 ; } else { k = key . charAt ( index1 ) ; }
private static int mask ( final int bit ) { return MSB >>> bit ; } @Override public int bitsPerElement () { return LENGTH ; MST[PrimitiveReturnsMutator]MSP[] } @Override public int lengthInBits ( final String key ) { return key != null ? key . length () * LENGTH : 0 ;
return ( key . charAt ( index ) & mask ( bit ) ) != 0 ; MST[rv.ABSMutator]MSP[] } @Override public boolean isPrefix ( final String prefix , final int offsetInBits , final int lengthInBits , final String key ) {
final int endIndex2 = beginIndex2 + otherLengthInBits / LENGTH ; MST[rv.CRCR3Mutator]MSP[] final int length = Math . max ( endIndex1 , endIndex2 ) ; char k = 0 , f = 0 ; for ( int i = 0 ; i < length ; i ++ ) {
if ( other == null || index2 >= endIndex2 ) { f = 0 ; } else { f = other . charAt ( index2 ) ; } if ( k != f ) { MST[rv.UOI1Mutator]MSP[] final int x = k ^ f ;
|| lengthInBits % LENGTH != 0 || otherLengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } final int beginIndex1 = offsetInBits / LENGTH ; final int beginIndex2 = otherOffsetInBits / LENGTH ; final int endIndex1 = beginIndex1 + lengthInBits / LENGTH ; MST[rv.CRCR5Mutator]MSP[]
if ( other == null || index2 >= endIndex2 ) { f = 0 ; } else { f = other . charAt ( index2 ) ; MST[rv.ABSMutator]MSP[] } if ( k != f ) { final int x = k ^ f ;
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; MST[rv.UOI4Mutator]MSP[] } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; } if ( k != 0 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
private static int mask ( final int bit ) { return MSB >>> bit ; } @Override public int bitsPerElement () { return LENGTH ; } @Override public int lengthInBits ( final String key ) { return key != null ? key . length () * LENGTH : 0 ; MST[rv.CRCR6Mutator]MSP[]
final int endIndex2 = beginIndex2 + otherLengthInBits / LENGTH ; final int length = Math . max ( endIndex1 , endIndex2 ) ; MST[ArgumentPropagationMutator]MSP[] char k = 0 , f = 0 ; for ( int i = 0 ; i < length ; i ++ ) {
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.AOD2Mutator]MSP[]
private static int mask ( final int bit ) { return MSB >>> bit ; } @Override public int bitsPerElement () { return LENGTH ; } @Override public int lengthInBits ( final String key ) { return key != null ? key . length () * LENGTH : 0 ; MST[rv.CRCR3Mutator]MSP[]
final int index1 = beginIndex1 + i ; final int index2 = beginIndex2 + i ; if ( index1 >= endIndex1 ) { k = 0 ; MST[rv.CRCR1Mutator]MSP[] } else { k = key . charAt ( index1 ) ; }
return ( key . charAt ( index ) & mask ( bit ) ) != 0 ; MST[rv.CRCR6Mutator]MSP[] } @Override public boolean isPrefix ( final String prefix , final int offsetInBits , final int lengthInBits , final String key ) {
final int endIndex2 = beginIndex2 + otherLengthInBits / LENGTH ; final int length = Math . max ( endIndex1 , endIndex2 ) ; char k = 0 , f = 0 ; for ( int i = 0 ; i < length ; i ++ ) { MST[rv.ABSMutator]MSP[]
final int index1 = beginIndex1 + i ; MST[rv.AOD2Mutator]MSP[] final int index2 = beginIndex2 + i ; if ( index1 >= endIndex1 ) { k = 0 ; } else { k = key . charAt ( index1 ) ; }
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; MST[rv.AOD2Mutator]MSP[] } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.ABSMutator]MSP[]
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.AOR4Mutator]MSP[]
final int endIndex2 = beginIndex2 + otherLengthInBits / LENGTH ; MST[rv.UOI1Mutator]MSP[] final int length = Math . max ( endIndex1 , endIndex2 ) ; char k = 0 , f = 0 ; for ( int i = 0 ; i < length ; i ++ ) {
return ( key . charAt ( index ) & mask ( bit ) ) != 0 ; MST[ArgumentPropagationMutator]MSP[] } @Override public boolean isPrefix ( final String prefix , final int offsetInBits , final int lengthInBits , final String key ) {
private static int mask ( final int bit ) { return MSB >>> bit ; } @Override public int bitsPerElement () { return LENGTH ; } @Override public int lengthInBits ( final String key ) { return key != null ? key . length () * LENGTH : 0 ; MST[rv.CRCR1Mutator]MSP[]
private static int mask ( final int bit ) { return MSB >>> bit ; } @Override public int bitsPerElement () { return LENGTH ; } @Override public int lengthInBits ( final String key ) { return key != null ? key . length () * LENGTH : 0 ; MST[rv.AOD2Mutator]MSP[]
if ( other == null || index2 >= endIndex2 ) { f = 0 ; } else { f = other . charAt ( index2 ) ; MST[rv.UOI4Mutator]MSP[] } if ( k != f ) { final int x = k ^ f ;
if ( other == null || index2 >= endIndex2 ) { f = 0 ; } else { f = other . charAt ( index2 ) ; } if ( k != f ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] final int x = k ^ f ;
|| lengthInBits % LENGTH != 0 || otherLengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } final int beginIndex1 = offsetInBits / LENGTH ; MST[rv.AOD2Mutator]MSP[] final int beginIndex2 = otherOffsetInBits / LENGTH ; final int endIndex1 = beginIndex1 + lengthInBits / LENGTH ;
final int index1 = beginIndex1 + i ; final int index2 = beginIndex2 + i ; if ( index1 >= endIndex1 ) { MST[rv.ABSMutator]MSP[] k = 0 ; } else { k = key . charAt ( index1 ) ; }
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[MathMutator]MSP[]
if ( other == null || index2 >= endIndex2 ) { f = 0 ; MST[InlineConstantMutator]MSP[] } else { f = other . charAt ( index2 ) ; } if ( k != f ) { final int x = k ^ f ;
final int index1 = beginIndex1 + i ; final int index2 = beginIndex2 + i ; MST[rv.AOR2Mutator]MSP[] if ( index1 >= endIndex1 ) { k = 0 ; } else { k = key . charAt ( index1 ) ; }
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; MST[rv.CRCR6Mutator]MSP[] } @Override
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; MST[rv.AOR2Mutator]MSP[] return key . startsWith ( s1 ) ; }
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[InlineConstantMutator]MSP[]
public boolean isBitSet ( final String key , final int bitIndex , final int lengthInBits ) { if ( key == null || bitIndex >= lengthInBits ) { return false ; MST[rv.CRCR3Mutator]MSP[] } final int index = bitIndex / LENGTH ; final int bit = bitIndex % LENGTH ;
|| lengthInBits % LENGTH != 0 || otherLengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } final int beginIndex1 = offsetInBits / LENGTH ; final int beginIndex2 = otherOffsetInBits / LENGTH ; final int endIndex1 = beginIndex1 + lengthInBits / LENGTH ; MST[rv.AOD1Mutator]MSP[]
final int endIndex2 = beginIndex2 + otherLengthInBits / LENGTH ; final int length = Math . max ( endIndex1 , endIndex2 ) ; char k = 0 , f = 0 ; MST[rv.CRCR1Mutator]MSP[] for ( int i = 0 ; i < length ; i ++ ) {
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { MST[rv.UOI2Mutator]MSP[] return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
public boolean isBitSet ( final String key , final int bitIndex , final int lengthInBits ) { if ( key == null || bitIndex >= lengthInBits ) { return false ; MST[InlineConstantMutator]MSP[] } final int index = bitIndex / LENGTH ; final int bit = bitIndex % LENGTH ;
|| lengthInBits % LENGTH != 0 || otherLengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } final int beginIndex1 = offsetInBits / LENGTH ; final int beginIndex2 = otherOffsetInBits / LENGTH ; final int endIndex1 = beginIndex1 + lengthInBits / LENGTH ; MST[rv.ABSMutator]MSP[]
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; MST[rv.UOI1Mutator]MSP[] return key . startsWith ( s1 ) ; }
private static int mask ( final int bit ) { return MSB >>> bit ; MST[rv.UOI1Mutator]MSP[] } @Override public int bitsPerElement () { return LENGTH ; } @Override public int lengthInBits ( final String key ) { return key != null ? key . length () * LENGTH : 0 ;
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; MST[rv.UOI2Mutator]MSP[] return key . startsWith ( s1 ) ; }
if ( other == null || index2 >= endIndex2 ) { f = 0 ; MST[rv.CRCR3Mutator]MSP[] } else { f = other . charAt ( index2 ) ; } if ( k != f ) { final int x = k ^ f ;
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; } if ( k != 0 ) { MST[rv.UOI3Mutator]MSP[] allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; } @Override
final int index1 = beginIndex1 + i ; final int index2 = beginIndex2 + i ; if ( index1 >= endIndex1 ) { MST[rv.UOI4Mutator]MSP[] k = 0 ; } else { k = key . charAt ( index1 ) ; }
|| lengthInBits % LENGTH != 0 || otherLengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } final int beginIndex1 = offsetInBits / LENGTH ; final int beginIndex2 = otherOffsetInBits / LENGTH ; final int endIndex1 = beginIndex1 + lengthInBits / LENGTH ; MST[rv.AOR4Mutator]MSP[]
return ( key . charAt ( index ) & mask ( bit ) ) != 0 ; MST[rv.ROR1Mutator]MSP[] } @Override public boolean isPrefix ( final String prefix , final int offsetInBits , final int lengthInBits , final String key ) {
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.ROR3Mutator]MSP[]
|| lengthInBits % LENGTH != 0 || otherLengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } final int beginIndex1 = offsetInBits / LENGTH ; final int beginIndex2 = otherOffsetInBits / LENGTH ; MST[MathMutator]MSP[] final int endIndex1 = beginIndex1 + lengthInBits / LENGTH ;
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { MST[rv.CRCR1Mutator]MSP[] throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; return key . startsWith ( s1 ) ; }
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { MST[rv.ROR4Mutator]MSP[] throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; return key . startsWith ( s1 ) ; }
return i * LENGTH + Integer . numberOfLeadingZeros ( x ) - LENGTH ; } if ( k != 0 ) { allNull = false ; } } if ( allNull ) { return KeyAnalyzer . NULL_BIT_KEY ; } return KeyAnalyzer . EQUAL_BIT_KEY ; MST[rv.CRCR1Mutator]MSP[] } @Override
public boolean isBitSet ( final String key , final int bitIndex , final int lengthInBits ) { if ( key == null || bitIndex >= lengthInBits ) { return false ; } final int index = bitIndex / LENGTH ; MST[rv.CRCR5Mutator]MSP[] final int bit = bitIndex % LENGTH ;
final int endIndex2 = beginIndex2 + otherLengthInBits / LENGTH ; final int length = Math . max ( endIndex1 , endIndex2 ) ; MST[rv.ABSMutator]MSP[] char k = 0 , f = 0 ; for ( int i = 0 ; i < length ; i ++ ) {
final int index1 = beginIndex1 + i ; final int index2 = beginIndex2 + i ; MST[rv.UOI2Mutator]MSP[] if ( index1 >= endIndex1 ) { k = 0 ; } else { k = key . charAt ( index1 ) ; }
|| lengthInBits % LENGTH != 0 || otherLengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } final int beginIndex1 = offsetInBits / LENGTH ; final int beginIndex2 = otherOffsetInBits / LENGTH ; MST[InlineConstantMutator]MSP[] final int endIndex1 = beginIndex1 + lengthInBits / LENGTH ;
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { MST[rv.UOI1Mutator]MSP[] throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; return key . startsWith ( s1 ) ; }
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { MST[NegateConditionalsMutator]MSP[] throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; return key . startsWith ( s1 ) ; }
|| lengthInBits % LENGTH != 0 || otherLengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } final int beginIndex1 = offsetInBits / LENGTH ; final int beginIndex2 = otherOffsetInBits / LENGTH ; MST[rv.CRCR3Mutator]MSP[] final int endIndex1 = beginIndex1 + lengthInBits / LENGTH ;
final int endIndex2 = beginIndex2 + otherLengthInBits / LENGTH ; final int length = Math . max ( endIndex1 , endIndex2 ) ; char k = 0 , f = 0 ; for ( int i = 0 ; i < length ; i ++ ) { MST[rv.UOI4Mutator]MSP[]
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.AOD1Mutator]MSP[]
public boolean isBitSet ( final String key , final int bitIndex , final int lengthInBits ) { if ( key == null || bitIndex >= lengthInBits ) { return false ; } final int index = bitIndex / LENGTH ; MST[rv.ABSMutator]MSP[] final int bit = bitIndex % LENGTH ;
if ( offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0 ) { MST[rv.AOD2Mutator]MSP[] throw new IllegalArgumentException ( lr_2 ) ; } final String s1 = prefix . substring ( offsetInBits / LENGTH , lengthInBits / LENGTH ) ; return key . startsWith ( s1 ) ; }
final int endIndex2 = beginIndex2 + otherLengthInBits / LENGTH ; MST[MathMutator]MSP[] final int length = Math . max ( endIndex1 , endIndex2 ) ; char k = 0 , f = 0 ; for ( int i = 0 ; i < length ; i ++ ) {
} @Override public int bitIndex ( final String key , final int offsetInBits , final int lengthInBits , final String other , final int otherOffsetInBits , final int otherLengthInBits ) { boolean allNull = true ; if ( offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 MST[rv.UOI4Mutator]MSP[]
|| lengthInBits % LENGTH != 0 || otherLengthInBits % LENGTH != 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } final int beginIndex1 = offsetInBits / LENGTH ; MST[rv.CRCR1Mutator]MSP[] final int beginIndex2 = otherOffsetInBits / LENGTH ; final int endIndex1 = beginIndex1 + lengthInBits / LENGTH ;
if ( other == null || index2 >= endIndex2 ) { f = 0 ; } else { f = other . charAt ( index2 ) ; } if ( k != f ) { MST[rv.UOI1Mutator]MSP[] final int x = k ^ f ;
