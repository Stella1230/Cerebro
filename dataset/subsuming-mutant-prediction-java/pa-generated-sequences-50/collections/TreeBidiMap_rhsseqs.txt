} @Override public V getKey () { if ( lastReturnedNode == null ) { throw new IllegalStateException ( lr_10 ) ; } return lastReturnedNode . getValue () ; } @Override public K getValue () { if ( lastReturnedNode == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] throw new IllegalStateException ( lr_11 ) ; }
return lastReturnedNode . getKey () ; } @Override public K setValue ( final K obj ) { throw new UnsupportedOperationException () ; } @Override public V next () { return navigateNext () . getValue () ; MST[NonVoidMethodCallMutator]MSP[N] } @Override public V previous () { return navigatePrevious () . getValue () ;
return lastReturnedNode . getKey () ; } @Override public K setValue ( final K obj ) { throw new UnsupportedOperationException () ; } @Override public V next () { return navigateNext () . getValue () ; MST[NonVoidMethodCallMutator]MSP[S] } @Override public V previous () { return navigatePrevious () . getValue () ;
return lastReturnedNode . getKey () ; MST[NullReturnValsMutator]MSP[N] } @Override public K setValue ( final K obj ) { throw new UnsupportedOperationException () ; } @Override public V next () { return navigateNext () . getValue () ; } @Override public V previous () { return navigatePrevious () . getValue () ;
} @Override public V getKey () { if ( lastReturnedNode == null ) { throw new IllegalStateException ( MST[ConstructorCallMutator]MSP[S] lr_10 ) ; } return lastReturnedNode . getValue () ; } @Override public K getValue () { if ( lastReturnedNode == null ) { throw new IllegalStateException ( lr_11 ) ; }
return lastReturnedNode . getKey () ; MST[ReturnValsMutator]MSP[N] } @Override public K setValue ( final K obj ) { throw new UnsupportedOperationException () ; } @Override public V next () { return navigateNext () . getValue () ; } @Override public V previous () { return navigatePrevious () . getValue () ;
checkNonNullComparable ( obj , VALUE ) ; return lookupValue ( obj ) != null ; MST[rv.CRCR2Mutator]MSP[S] } @Override public boolean remove ( final Object o ) { return doRemoveValue ( o ) != null ; } @Override public boolean contains ( final Object obj ) {
checkNonNullComparable ( obj , VALUE ) ; return lookupValue ( obj ) != null ; MST[rv.CRCR3Mutator]MSP[N] } @Override public boolean remove ( final Object o ) { return doRemoveValue ( o ) != null ; } @Override public boolean contains ( final Object obj ) {
checkNonNullComparable ( obj , VALUE ) ; return lookupValue ( obj ) != null ; } @Override public boolean remove ( final Object o ) { return doRemoveValue ( o ) != null ; MST[rv.ROR5Mutator]MSP[N] } @Override public boolean contains ( final Object obj ) {
checkNonNullComparable ( obj , VALUE ) ; return lookupValue ( obj ) != null ; MST[rv.CRCR6Mutator]MSP[N] } @Override public boolean remove ( final Object o ) { return doRemoveValue ( o ) != null ; } @Override public boolean contains ( final Object obj ) {
checkNonNullComparable ( obj , VALUE ) ; return lookupValue ( obj ) != null ; } @Override public boolean remove ( final Object o ) { return doRemoveValue ( o ) != null ; MST[NegateConditionalsMutator]MSP[N] } @Override public boolean contains ( final Object obj ) {
checkNonNullComparable ( obj , VALUE ) ; return lookupValue ( obj ) != null ; MST[rv.CRCR5Mutator]MSP[N] } @Override public boolean remove ( final Object o ) { return doRemoveValue ( o ) != null ; } @Override public boolean contains ( final Object obj ) {
checkNonNullComparable ( obj , VALUE ) ; return lookupValue ( obj ) != null ; MST[rv.CRCR3Mutator]MSP[N] } @Override public boolean remove ( final Object o ) { return doRemoveValue ( o ) != null ; } @Override public boolean contains ( final Object obj ) {
checkNonNullComparable ( obj , VALUE ) ; return lookupValue ( obj ) != null ; MST[rv.CRCR1Mutator]MSP[N] } @Override public boolean remove ( final Object o ) { return doRemoveValue ( o ) != null ; } @Override public boolean contains ( final Object obj ) {
checkNonNullComparable ( obj , VALUE ) ; return lookupValue ( obj ) != null ; } @Override public boolean remove ( final Object o ) { return doRemoveValue ( o ) != null ; MST[InlineConstantMutator]MSP[N] } @Override public boolean contains ( final Object obj ) {
checkNonNullComparable ( obj , VALUE ) ; return lookupValue ( obj ) != null ; MST[rv.CRCR6Mutator]MSP[S] } @Override public boolean remove ( final Object o ) { return doRemoveValue ( o ) != null ; } @Override public boolean contains ( final Object obj ) {
checkNonNullComparable ( obj , VALUE ) ; return lookupValue ( obj ) != null ; MST[rv.CRCR5Mutator]MSP[S] } @Override public boolean remove ( final Object o ) { return doRemoveValue ( o ) != null ; } @Override public boolean contains ( final Object obj ) {
checkNonNullComparable ( obj , VALUE ) ; return lookupValue ( obj ) != null ; MST[rv.CRCR4Mutator]MSP[N] } @Override public boolean remove ( final Object o ) { return doRemoveValue ( o ) != null ; } @Override public boolean contains ( final Object obj ) {
checkNonNullComparable ( obj , VALUE ) ; return lookupValue ( obj ) != null ; MST[ReturnValsMutator]MSP[N] } @Override public boolean remove ( final Object o ) { return doRemoveValue ( o ) != null ; } @Override public boolean contains ( final Object obj ) {
checkNonNullComparable ( obj , VALUE ) ; return lookupValue ( obj ) != null ; } @Override public boolean remove ( final Object o ) { return doRemoveValue ( o ) != null ; MST[NonVoidMethodCallMutator]MSP[N] } @Override public boolean contains ( final Object obj ) {
checkNonNullComparable ( obj , VALUE ) ; MST[VoidMethodCallMutator]MSP[N] return lookupValue ( obj ) != null ; } @Override public boolean remove ( final Object o ) { return doRemoveValue ( o ) != null ; } @Override public boolean contains ( final Object obj ) {
checkNonNullComparable ( obj , VALUE ) ; return lookupValue ( obj ) != null ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] } @Override public boolean remove ( final Object o ) { return doRemoveValue ( o ) != null ; } @Override public boolean contains ( final Object obj ) {
checkNonNullComparable ( obj , VALUE ) ; return lookupValue ( obj ) != null ; MST[InlineConstantMutator]MSP[S] } @Override public boolean remove ( final Object o ) { return doRemoveValue ( o ) != null ; } @Override public boolean contains ( final Object obj ) {
checkNonNullComparable ( obj , VALUE ) ; return lookupValue ( obj ) != null ; } @Override public boolean remove ( final Object o ) { return doRemoveValue ( o ) != null ; MST[rv.CRCR1Mutator]MSP[N] } @Override public boolean contains ( final Object obj ) {
checkNonNullComparable ( obj , VALUE ) ; return lookupValue ( obj ) != null ; } @Override public boolean remove ( final Object o ) { return doRemoveValue ( o ) != null ; MST[BooleanTrueReturnValsMutator]MSP[N] } @Override public boolean contains ( final Object obj ) {
checkNonNullComparable ( obj , VALUE ) ; return lookupValue ( obj ) != null ; MST[NegateConditionalsMutator]MSP[N] } @Override public boolean remove ( final Object o ) { return doRemoveValue ( o ) != null ; } @Override public boolean contains ( final Object obj ) {
checkNonNullComparable ( obj , VALUE ) ; return lookupValue ( obj ) != null ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } @Override public boolean remove ( final Object o ) { return doRemoveValue ( o ) != null ; } @Override public boolean contains ( final Object obj ) {
checkNonNullComparable ( obj , VALUE ) ; return lookupValue ( obj ) != null ; } @Override public boolean remove ( final Object o ) { return doRemoveValue ( o ) != null ; MST[ReturnValsMutator]MSP[N] } @Override public boolean contains ( final Object obj ) {
checkNonNullComparable ( obj , VALUE ) ; return lookupValue ( obj ) != null ; MST[rv.ROR5Mutator]MSP[N] } @Override public boolean remove ( final Object o ) { return doRemoveValue ( o ) != null ; } @Override public boolean contains ( final Object obj ) {
checkNonNullComparable ( obj , VALUE ) ; return lookupValue ( obj ) != null ; MST[InlineConstantMutator]MSP[N] } @Override public boolean remove ( final Object o ) { return doRemoveValue ( o ) != null ; } @Override public boolean contains ( final Object obj ) {
checkNonNullComparable ( obj , VALUE ) ; return lookupValue ( obj ) != null ; MST[NonVoidMethodCallMutator]MSP[S] } @Override public boolean remove ( final Object o ) { return doRemoveValue ( o ) != null ; } @Override public boolean contains ( final Object obj ) {
checkNonNullComparable ( obj , VALUE ) ; return lookupValue ( obj ) != null ; } @Override public boolean remove ( final Object o ) { return doRemoveValue ( o ) != null ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } @Override public boolean contains ( final Object obj ) {
checkNonNullComparable ( obj , VALUE ) ; return lookupValue ( obj ) != null ; } @Override public boolean remove ( final Object o ) { return doRemoveValue ( o ) != null ; MST[rv.CRCR5Mutator]MSP[N] } @Override public boolean contains ( final Object obj ) {
checkNonNullComparable ( obj , VALUE ) ; return lookupValue ( obj ) != null ; MST[BooleanTrueReturnValsMutator]MSP[N] } @Override public boolean remove ( final Object o ) { return doRemoveValue ( o ) != null ; } @Override public boolean contains ( final Object obj ) {
checkNonNullComparable ( obj , VALUE ) ; return lookupValue ( obj ) != null ; } @Override public boolean remove ( final Object o ) { return doRemoveValue ( o ) != null ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } @Override public boolean contains ( final Object obj ) {
checkNonNullComparable ( obj , VALUE ) ; return lookupValue ( obj ) != null ; } @Override public boolean remove ( final Object o ) { return doRemoveValue ( o ) != null ; MST[rv.CRCR3Mutator]MSP[N] } @Override public boolean contains ( final Object obj ) {
checkNonNullComparable ( obj , VALUE ) ; return lookupValue ( obj ) != null ; } @Override public boolean remove ( final Object o ) { return doRemoveValue ( o ) != null ; MST[rv.CRCR6Mutator]MSP[N] } @Override public boolean contains ( final Object obj ) {
return lastReturnedNode . getKey () ; MST[NonVoidMethodCallMutator]MSP[N] } @Override public K setValue ( final K obj ) { throw new UnsupportedOperationException () ; } @Override public V next () { return navigateNext () . getValue () ; } @Override public V previous () { return navigatePrevious () . getValue () ;
} @Override public V getKey () { if ( lastReturnedNode == null ) { throw new IllegalStateException ( lr_10 ) ; } return lastReturnedNode . getValue () ; } @Override public K getValue () { if ( lastReturnedNode == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] throw new IllegalStateException ( lr_11 ) ; }
public boolean remove ( final Object o ) { return doRemoveKey ( o ) != null ; MST[ReturnValsMutator]MSP[N] } @Override public Iterator < V > iterator () { return new InverseViewMapIterator ( orderType ) ; } @Override public boolean contains ( final Object obj ) {
} @Override public Iterator < K > iterator () { return new ViewMapIterator ( orderType ) ; MST[ConstructorCallMutator]MSP[N] } @Override public boolean contains ( final Object obj ) { checkNonNullComparable ( obj , KEY ) ; return lookupKey ( obj ) != null ; } @Override
} @Override public Iterator < K > iterator () { return new ViewMapIterator ( orderType ) ; } @Override public boolean contains ( final Object obj ) { checkNonNullComparable ( obj , KEY ) ; return lookupKey ( obj ) != null ; MST[InlineConstantMutator]MSP[N] } @Override
} @Override public Iterator < K > iterator () { return new ViewMapIterator ( orderType ) ; } @Override public boolean contains ( final Object obj ) { checkNonNullComparable ( obj , KEY ) ; return lookupKey ( obj ) != null ; MST[rv.ROR5Mutator]MSP[N] } @Override
} @Override public Iterator < K > iterator () { return new ViewMapIterator ( orderType ) ; } @Override public boolean contains ( final Object obj ) { checkNonNullComparable ( obj , KEY ) ; return lookupKey ( obj ) != null ; MST[InlineConstantMutator]MSP[N] } @Override
public boolean remove ( final Object o ) { return doRemoveKey ( o ) != null ; MST[NonVoidMethodCallMutator]MSP[N] } @Override public Iterator < V > iterator () { return new InverseViewMapIterator ( orderType ) ; } @Override public boolean contains ( final Object obj ) {
} @Override public Iterator < K > iterator () { return new ViewMapIterator ( orderType ) ; } @Override public boolean contains ( final Object obj ) { checkNonNullComparable ( obj , KEY ) ; return lookupKey ( obj ) != null ; MST[ReturnValsMutator]MSP[N] } @Override
} @Override public Iterator < K > iterator () { return new ViewMapIterator ( orderType ) ; } @Override public boolean contains ( final Object obj ) { checkNonNullComparable ( obj , KEY ) ; return lookupKey ( obj ) != null ; MST[rv.CRCR1Mutator]MSP[N] } @Override
} @Override public Iterator < K > iterator () { return new ViewMapIterator ( orderType ) ; MST[NullReturnValsMutator]MSP[N] } @Override public boolean contains ( final Object obj ) { checkNonNullComparable ( obj , KEY ) ; return lookupKey ( obj ) != null ; } @Override
} @Override public Iterator < K > iterator () { return new ViewMapIterator ( orderType ) ; } @Override public boolean contains ( final Object obj ) { checkNonNullComparable ( obj , KEY ) ; return lookupKey ( obj ) != null ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } @Override
} @Override public Iterator < K > iterator () { return new ViewMapIterator ( orderType ) ; MST[ReturnValsMutator]MSP[N] } @Override public boolean contains ( final Object obj ) { checkNonNullComparable ( obj , KEY ) ; return lookupKey ( obj ) != null ; } @Override
} @Override public Iterator < K > iterator () { return new ViewMapIterator ( orderType ) ; } @Override public boolean contains ( final Object obj ) { checkNonNullComparable ( obj , KEY ) ; return lookupKey ( obj ) != null ; MST[rv.CRCR3Mutator]MSP[N] } @Override
} @Override public Iterator < K > iterator () { return new ViewMapIterator ( orderType ) ; } @Override public boolean contains ( final Object obj ) { checkNonNullComparable ( obj , KEY ) ; return lookupKey ( obj ) != null ; MST[rv.CRCR5Mutator]MSP[N] } @Override
} @Override public Iterator < K > iterator () { return new ViewMapIterator ( orderType ) ; } @Override public boolean contains ( final Object obj ) { checkNonNullComparable ( obj , KEY ) ; return lookupKey ( obj ) != null ; MST[rv.CRCR2Mutator]MSP[N] } @Override
public boolean remove ( final Object o ) { return doRemoveKey ( o ) != null ; MST[InlineConstantMutator]MSP[N] } @Override public Iterator < V > iterator () { return new InverseViewMapIterator ( orderType ) ; } @Override public boolean contains ( final Object obj ) {
} @Override public Iterator < K > iterator () { return new ViewMapIterator ( orderType ) ; } @Override public boolean contains ( final Object obj ) { checkNonNullComparable ( obj , KEY ) ; return lookupKey ( obj ) != null ; MST[rv.CRCR6Mutator]MSP[N] } @Override
} @Override public Iterator < K > iterator () { return new ViewMapIterator ( orderType ) ; } @Override public boolean contains ( final Object obj ) { checkNonNullComparable ( obj , KEY ) ; return lookupKey ( obj ) != null ; MST[rv.CRCR3Mutator]MSP[N] } @Override
} @Override public Iterator < K > iterator () { return new ViewMapIterator ( orderType ) ; } @Override public boolean contains ( final Object obj ) { checkNonNullComparable ( obj , KEY ) ; return lookupKey ( obj ) != null ; MST[rv.CRCR5Mutator]MSP[N] } @Override
} @Override public Iterator < K > iterator () { return new ViewMapIterator ( orderType ) ; } @Override public boolean contains ( final Object obj ) { checkNonNullComparable ( obj , KEY ) ; return lookupKey ( obj ) != null ; MST[rv.CRCR4Mutator]MSP[N] } @Override
public boolean remove ( final Object o ) { return doRemoveKey ( o ) != null ; MST[rv.ROR5Mutator]MSP[N] } @Override public Iterator < V > iterator () { return new InverseViewMapIterator ( orderType ) ; } @Override public boolean contains ( final Object obj ) {
} @Override public Iterator < K > iterator () { return new ViewMapIterator ( orderType ) ; } @Override public boolean contains ( final Object obj ) { checkNonNullComparable ( obj , KEY ) ; return lookupKey ( obj ) != null ; MST[BooleanTrueReturnValsMutator]MSP[N] } @Override
} @Override public Iterator < K > iterator () { return new ViewMapIterator ( orderType ) ; } @Override public boolean contains ( final Object obj ) { checkNonNullComparable ( obj , KEY ) ; return lookupKey ( obj ) != null ; MST[rv.CRCR6Mutator]MSP[N] } @Override
} @Override public Iterator < K > iterator () { return new ViewMapIterator ( orderType ) ; } @Override public boolean contains ( final Object obj ) { checkNonNullComparable ( obj , KEY ) ; MST[VoidMethodCallMutator]MSP[S] return lookupKey ( obj ) != null ; } @Override
public boolean remove ( final Object o ) { return doRemoveKey ( o ) != null ; MST[NegateConditionalsMutator]MSP[N] } @Override public Iterator < V > iterator () { return new InverseViewMapIterator ( orderType ) ; } @Override public boolean contains ( final Object obj ) {
} @Override public Iterator < K > iterator () { return new ViewMapIterator ( orderType ) ; } @Override public boolean contains ( final Object obj ) { checkNonNullComparable ( obj , KEY ) ; return lookupKey ( obj ) != null ; MST[NonVoidMethodCallMutator]MSP[N] } @Override
public boolean remove ( final Object o ) { return doRemoveKey ( o ) != null ; MST[rv.CRCR5Mutator]MSP[N] } @Override public Iterator < V > iterator () { return new InverseViewMapIterator ( orderType ) ; } @Override public boolean contains ( final Object obj ) {
public boolean remove ( final Object o ) { return doRemoveKey ( o ) != null ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } @Override public Iterator < V > iterator () { return new InverseViewMapIterator ( orderType ) ; } @Override public boolean contains ( final Object obj ) {
public boolean remove ( final Object o ) { return doRemoveKey ( o ) != null ; MST[rv.CRCR6Mutator]MSP[N] } @Override public Iterator < V > iterator () { return new InverseViewMapIterator ( orderType ) ; } @Override public boolean contains ( final Object obj ) {
public boolean remove ( final Object o ) { return doRemoveKey ( o ) != null ; MST[rv.CRCR1Mutator]MSP[N] } @Override public Iterator < V > iterator () { return new InverseViewMapIterator ( orderType ) ; } @Override public boolean contains ( final Object obj ) {
public boolean remove ( final Object o ) { return doRemoveKey ( o ) != null ; MST[rv.CRCR3Mutator]MSP[N] } @Override public Iterator < V > iterator () { return new InverseViewMapIterator ( orderType ) ; } @Override public boolean contains ( final Object obj ) {
@Override public String toString () { return description ; MST[EmptyObjectReturnValsMutator]MSP[N] } @Override public int size () { return nodeCount ; } @Override public boolean isEmpty () { return nodeCount == 0 ; } @Override public boolean containsKey ( final Object key ) { checkKey ( key ) ;
@Override public String toString () { return description ; MST[ReturnValsMutator]MSP[N] } @Override public int size () { return nodeCount ; } @Override public boolean isEmpty () { return nodeCount == 0 ; } @Override public boolean containsKey ( final Object key ) { checkKey ( key ) ;
} @Override public V getKey () { if ( lastReturnedNode == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] throw new IllegalStateException ( lr_10 ) ; } return lastReturnedNode . getValue () ; } @Override public K getValue () { if ( lastReturnedNode == null ) { throw new IllegalStateException ( lr_11 ) ; }
} @Override public V getKey () { if ( lastReturnedNode == null ) { throw new IllegalStateException ( lr_10 ) ; } return lastReturnedNode . getValue () ; } @Override public K getValue () { if ( lastReturnedNode == null ) { throw new IllegalStateException ( MST[ConstructorCallMutator]MSP[S] lr_11 ) ; }
} @Override public V getKey () { if ( lastReturnedNode == null ) { throw new IllegalStateException ( lr_10 ) ; } return lastReturnedNode . getValue () ; } @Override public K getValue () { if ( lastReturnedNode == null ) { MST[rv.ROR5Mutator]MSP[S] throw new IllegalStateException ( lr_11 ) ; }
parentNode [ dataElement . ordinal () ] = node ; } private Node < K , V > getParent ( final DataElement dataElement ) { return parentNode [ dataElement . ordinal () ] ; MST[NonVoidMethodCallMutator]MSP[S] }
throw new IllegalArgumentException () ; } } private void setLeft ( final Node < K , V > node , final DataElement dataElement ) { leftNode [ dataElement . ordinal () ] = node ; MST[NonVoidMethodCallMutator]MSP[S] } private Node < K , V > getLeft ( final DataElement dataElement ) {
return blackColor [ dataElement . ordinal () ] ; } private boolean isRed ( final DataElement dataElement ) { return ! blackColor [ dataElement . ordinal () ] ; MST[rv.UOI2Mutator]MSP[S] } private void setBlack ( final DataElement dataElement ) { blackColor [ dataElement . ordinal () ] = true ; }
if ( ! ( obj instanceof Map . Entry ) ) { MST[rv.ROR3Mutator]MSP[N] return false ; } final Map . Entry < ? , ? > e = ( Map . Entry < ? , ? > ) obj ;
if ( ! ( obj instanceof Map . Entry ) ) { MST[rv.ROR5Mutator]MSP[S] return false ; } final Map . Entry < ? , ? > e = ( Map . Entry < ? , ? > ) obj ;
if ( ! ( obj instanceof Map . Entry ) ) { MST[rv.ROR1Mutator]MSP[N] return false ; } final Map . Entry < ? , ? > e = ( Map . Entry < ? , ? > ) obj ;
return blackColor [ dataElement . ordinal () ] ; MST[rv.ABSMutator]MSP[N] } private boolean isRed ( final DataElement dataElement ) { return ! blackColor [ dataElement . ordinal () ] ; } private void setBlack ( final DataElement dataElement ) { blackColor [ dataElement . ordinal () ] = true ; }
if ( ! ( obj instanceof Map . Entry ) ) { return false ; MST[rv.CRCR5Mutator]MSP[S] } final Map . Entry < ? , ? > e = ( Map . Entry < ? , ? > ) obj ;
return new UnmodifiableMapEntry <> ( node . getValue () , node . getKey () ) ; } private Object getData ( final DataElement dataElement ) { switch ( dataElement ) { MST[rv.ABSMutator]MSP[S] case KEY : return getKey () ; case VALUE : return getValue () ; default:
if ( ! ( obj instanceof Map . Entry ) ) { return false ; MST[rv.CRCR1Mutator]MSP[S] } final Map . Entry < ? , ? > e = ( Map . Entry < ? , ? > ) obj ;
if ( ! ( obj instanceof Map . Entry ) ) { return false ; MST[rv.CRCR3Mutator]MSP[S] } final Map . Entry < ? , ? > e = ( Map . Entry < ? , ? > ) obj ;
&& parentNode [ dataElement . ordinal () ] . leftNode [ dataElement . ordinal () ] == this ; } private boolean isRightChild ( final DataElement dataElement ) { return parentNode [ dataElement . ordinal () ] != null MST[rv.ROR5Mutator]MSP[N]
&& parentNode [ dataElement . ordinal () ] . leftNode [ dataElement . ordinal () ] == this ; MST[InlineConstantMutator]MSP[N] } private boolean isRightChild ( final DataElement dataElement ) { return parentNode [ dataElement . ordinal () ] != null
return blackColor [ dataElement . ordinal () ] ; } private boolean isRed ( final DataElement dataElement ) { return ! blackColor [ dataElement . ordinal () ] ; MST[rv.ROR5Mutator]MSP[N] } private void setBlack ( final DataElement dataElement ) { blackColor [ dataElement . ordinal () ] = true ; }
&& parentNode [ dataElement . ordinal () ] . rightNode [ dataElement . ordinal () ] == this ; MST[rv.CRCR5Mutator]MSP[S] } @Override public K getKey () { return key ; } @Override public V getValue () { return value ; } @Override
private Node < K , V > getRight ( final DataElement dataElement ) { return rightNode [ dataElement . ordinal () ] ; MST[NonVoidMethodCallMutator]MSP[S] } private void setParent ( final Node < K , V > node , final DataElement dataElement ) {
if ( ! ( obj instanceof Map . Entry ) ) { return false ; MST[ReturnValsMutator]MSP[S] } final Map . Entry < ? , ? > e = ( Map . Entry < ? , ? > ) obj ;
return blackColor [ dataElement . ordinal () ] ; } private boolean isRed ( final DataElement dataElement ) { return ! blackColor [ dataElement . ordinal () ] ; MST[rv.ABSMutator]MSP[N] } private void setBlack ( final DataElement dataElement ) { blackColor [ dataElement . ordinal () ] = true ; }
&& parentNode [ dataElement . ordinal () ] . rightNode [ dataElement . ordinal () ] == this ; MST[NonVoidMethodCallMutator]MSP[N] } @Override public K getKey () { return key ; } @Override public V getValue () { return value ; } @Override
return new UnmodifiableMapEntry <> ( node . getValue () , node . getKey () ) ; } private Object getData ( final DataElement dataElement ) { switch ( dataElement ) { case KEY : return getKey () ; MST[ReturnValsMutator]MSP[S] case VALUE : return getValue () ; default:
&& parentNode [ dataElement . ordinal () ] . leftNode [ dataElement . ordinal () ] == this ; } private boolean isRightChild ( final DataElement dataElement ) { return parentNode [ dataElement . ordinal () ] != null MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
return blackColor [ dataElement . ordinal () ] ; } private boolean isRed ( final DataElement dataElement ) { return ! blackColor [ dataElement . ordinal () ] ; } private void setBlack ( final DataElement dataElement ) { blackColor [ dataElement . ordinal () ] = true ; MST[rv.CRCR4Mutator]MSP[N] }
return blackColor [ dataElement . ordinal () ] ; } private boolean isRed ( final DataElement dataElement ) { return ! blackColor [ dataElement . ordinal () ] ; MST[rv.ROR1Mutator]MSP[N] } private void setBlack ( final DataElement dataElement ) { blackColor [ dataElement . ordinal () ] = true ; }
blackColor [ dataElement . ordinal () ] = node . blackColor [ dataElement . ordinal () ] ; } private boolean isLeftChild ( final DataElement dataElement ) { return parentNode [ dataElement . ordinal () ] != null MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
&& parentNode [ dataElement . ordinal () ] . rightNode [ dataElement . ordinal () ] == this ; } @Override public K getKey () { return key ; MST[NullReturnValsMutator]MSP[N] } @Override public V getValue () { return value ; } @Override
&& parentNode [ dataElement . ordinal () ] . leftNode [ dataElement . ordinal () ] == this ; MST[rv.CRCR4Mutator]MSP[N] } private boolean isRightChild ( final DataElement dataElement ) { return parentNode [ dataElement . ordinal () ] != null
return new UnmodifiableMapEntry <> ( node . getValue () , node . getKey () ) ; } private Object getData ( final DataElement dataElement ) { switch ( dataElement ) { MST[rv.UOI2Mutator]MSP[S] case KEY : return getKey () ; case VALUE : return getValue () ; default:
&& parentNode [ dataElement . ordinal () ] . leftNode [ dataElement . ordinal () ] == this ; } private boolean isRightChild ( final DataElement dataElement ) { return parentNode [ dataElement . ordinal () ] != null MST[NegateConditionalsMutator]MSP[S]
return blackColor [ dataElement . ordinal () ] ; } private boolean isRed ( final DataElement dataElement ) { return ! blackColor [ dataElement . ordinal () ] ; } private void setBlack ( final DataElement dataElement ) { blackColor [ dataElement . ordinal () ] = true ; MST[InlineConstantMutator]MSP[S] }
blackColor [ dataElement . ordinal () ] = node . blackColor [ dataElement . ordinal () ] ; } private boolean isLeftChild ( final DataElement dataElement ) { return parentNode [ dataElement . ordinal () ] != null MST[RemoveConditionalMutator_EQUAL_IF]MSP[S]
if ( ! ( obj instanceof Map . Entry ) ) { MST[NegateConditionalsMutator]MSP[S] return false ; } final Map . Entry < ? , ? > e = ( Map . Entry < ? , ? > ) obj ;
private Node < K , V > getRight ( final DataElement dataElement ) { return rightNode [ dataElement . ordinal () ] ; MST[ReturnValsMutator]MSP[S] } private void setParent ( final Node < K , V > node , final DataElement dataElement ) {
return blackColor [ dataElement . ordinal () ] ; MST[rv.UOI2Mutator]MSP[S] } private boolean isRed ( final DataElement dataElement ) { return ! blackColor [ dataElement . ordinal () ] ; } private void setBlack ( final DataElement dataElement ) { blackColor [ dataElement . ordinal () ] = true ; }
private void setRed ( final DataElement dataElement ) { blackColor [ dataElement . ordinal () ] = false ; MST[rv.CRCR3Mutator]MSP[S] } private void copyColor ( final Node < K , V > node , final DataElement dataElement ) {
&& parentNode [ dataElement . ordinal () ] . rightNode [ dataElement . ordinal () ] == this ; MST[rv.CRCR1Mutator]MSP[S] } @Override public K getKey () { return key ; } @Override public V getValue () { return value ; } @Override
return leftNode [ dataElement . ordinal () ] ; MST[NonVoidMethodCallMutator]MSP[S] } private void setRight ( final Node < K , V > node , final DataElement dataElement ) { rightNode [ dataElement . ordinal () ] = node ; }
return blackColor [ dataElement . ordinal () ] ; } private boolean isRed ( final DataElement dataElement ) { return ! blackColor [ dataElement . ordinal () ] ; MST[InlineConstantMutator]MSP[S] } private void setBlack ( final DataElement dataElement ) { blackColor [ dataElement . ordinal () ] = true ; }
return new UnmodifiableMapEntry <> ( node . getValue () , node . getKey () ) ; } private Object getData ( final DataElement dataElement ) { switch ( dataElement ) { MST[experimental.SwitchMutator]MSP[S] case KEY : return getKey () ; case VALUE : return getValue () ; default:
return blackColor [ dataElement . ordinal () ] ; } private boolean isRed ( final DataElement dataElement ) { return ! blackColor [ dataElement . ordinal () ] ; MST[rv.CRCR3Mutator]MSP[S] } private void setBlack ( final DataElement dataElement ) { blackColor [ dataElement . ordinal () ] = true ; }
public V setValue ( final V ignored ) throws UnsupportedOperationException { throw new UnsupportedOperationException ( lr_12 ) ; MST[ConstructorCallMutator]MSP[S] } @Override public boolean equals ( final Object obj ) { if ( obj == this ) { return true ; }
return blackColor [ dataElement . ordinal () ] ; } private boolean isRed ( final DataElement dataElement ) { return ! blackColor [ dataElement . ordinal () ] ; MST[NegateConditionalsMutator]MSP[S] } private void setBlack ( final DataElement dataElement ) { blackColor [ dataElement . ordinal () ] = true ; }
return new UnmodifiableMapEntry <> ( node . getValue () , node . getKey () ) ; } private Object getData ( final DataElement dataElement ) { switch ( dataElement ) { case KEY : return getKey () ; case VALUE : return getValue () ; MST[NullReturnValsMutator]MSP[S] default:
blackColor [ dataElement . ordinal () ] = node . blackColor [ dataElement . ordinal () ] ; } private boolean isLeftChild ( final DataElement dataElement ) { return parentNode [ dataElement . ordinal () ] != null MST[BooleanTrueReturnValsMutator]MSP[S]
return new UnmodifiableMapEntry <> ( node . getValue () , node . getKey () ) ; } private Object getData ( final DataElement dataElement ) { switch ( dataElement ) { MST[rv.UOI3Mutator]MSP[S] case KEY : return getKey () ; case VALUE : return getValue () ; default:
&& parentNode [ dataElement . ordinal () ] . leftNode [ dataElement . ordinal () ] == this ; MST[rv.CRCR3Mutator]MSP[S] } private boolean isRightChild ( final DataElement dataElement ) { return parentNode [ dataElement . ordinal () ] != null
&& parentNode [ dataElement . ordinal () ] . leftNode [ dataElement . ordinal () ] == this ; MST[rv.CRCR1Mutator]MSP[S] } private boolean isRightChild ( final DataElement dataElement ) { return parentNode [ dataElement . ordinal () ] != null
&& parentNode [ dataElement . ordinal () ] . leftNode [ dataElement . ordinal () ] == this ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] } private boolean isRightChild ( final DataElement dataElement ) { return parentNode [ dataElement . ordinal () ] != null
return leftNode [ dataElement . ordinal () ] ; MST[ReturnValsMutator]MSP[S] } private void setRight ( final Node < K , V > node , final DataElement dataElement ) { rightNode [ dataElement . ordinal () ] = node ; }
return blackColor [ dataElement . ordinal () ] ; MST[rv.UOI1Mutator]MSP[S] } private boolean isRed ( final DataElement dataElement ) { return ! blackColor [ dataElement . ordinal () ] ; } private void setBlack ( final DataElement dataElement ) { blackColor [ dataElement . ordinal () ] = true ; }
return blackColor [ dataElement . ordinal () ] ; } private boolean isRed ( final DataElement dataElement ) { return ! blackColor [ dataElement . ordinal () ] ; } private void setBlack ( final DataElement dataElement ) { blackColor [ dataElement . ordinal () ] = true ; MST[NonVoidMethodCallMutator]MSP[S] }
private void setRed ( final DataElement dataElement ) { blackColor [ dataElement . ordinal () ] = false ; MST[NonVoidMethodCallMutator]MSP[S] } private void copyColor ( final Node < K , V > node , final DataElement dataElement ) {
return blackColor [ dataElement . ordinal () ] ; } private boolean isRed ( final DataElement dataElement ) { return ! blackColor [ dataElement . ordinal () ] ; MST[rv.CRCR6Mutator]MSP[S] } private void setBlack ( final DataElement dataElement ) { blackColor [ dataElement . ordinal () ] = true ; }
return blackColor [ dataElement . ordinal () ] ; } private boolean isRed ( final DataElement dataElement ) { return ! blackColor [ dataElement . ordinal () ] ; MST[rv.CRCR4Mutator]MSP[S] } private void setBlack ( final DataElement dataElement ) { blackColor [ dataElement . ordinal () ] = true ; }
return new UnmodifiableMapEntry <> ( node . getValue () , node . getKey () ) ; } private Object getData ( final DataElement dataElement ) { switch ( dataElement ) { case KEY : return getKey () ; case VALUE : return getValue () ; MST[ReturnValsMutator]MSP[S] default:
return blackColor [ dataElement . ordinal () ] ; MST[ReturnValsMutator]MSP[S] } private boolean isRed ( final DataElement dataElement ) { return ! blackColor [ dataElement . ordinal () ] ; } private void setBlack ( final DataElement dataElement ) { blackColor [ dataElement . ordinal () ] = true ; }
return blackColor [ dataElement . ordinal () ] ; } private boolean isRed ( final DataElement dataElement ) { return ! blackColor [ dataElement . ordinal () ] ; MST[rv.ROR4Mutator]MSP[S] } private void setBlack ( final DataElement dataElement ) { blackColor [ dataElement . ordinal () ] = true ; }
&& parentNode [ dataElement . ordinal () ] . rightNode [ dataElement . ordinal () ] == this ; MST[rv.CRCR6Mutator]MSP[S] } @Override public K getKey () { return key ; } @Override public V getValue () { return value ; } @Override
return new UnmodifiableMapEntry <> ( node . getValue () , node . getKey () ) ; } private Object getData ( final DataElement dataElement ) { switch ( dataElement ) { MST[experimental.RemoveSwitchMutator_1]MSP[S] case KEY : return getKey () ; case VALUE : return getValue () ; default:
&& parentNode [ dataElement . ordinal () ] . rightNode [ dataElement . ordinal () ] == this ; MST[rv.CRCR3Mutator]MSP[S] } @Override public K getKey () { return key ; } @Override public V getValue () { return value ; } @Override
return new UnmodifiableMapEntry <> ( node . getValue () , node . getKey () ) ; } private Object getData ( final DataElement dataElement ) { switch ( dataElement ) { MST[experimental.RemoveSwitchMutator_0]MSP[S] case KEY : return getKey () ; case VALUE : return getValue () ; default:
private Node < K , V > getRight ( final DataElement dataElement ) { return rightNode [ dataElement . ordinal () ] ; MST[NullReturnValsMutator]MSP[S] } private void setParent ( final Node < K , V > node , final DataElement dataElement ) {
return blackColor [ dataElement . ordinal () ] ; } private boolean isRed ( final DataElement dataElement ) { return ! blackColor [ dataElement . ordinal () ] ; } private void setBlack ( final DataElement dataElement ) { blackColor [ dataElement . ordinal () ] = true ; MST[rv.CRCR6Mutator]MSP[S] }
blackColor [ dataElement . ordinal () ] = node . blackColor [ dataElement . ordinal () ] ; } private boolean isLeftChild ( final DataElement dataElement ) { return parentNode [ dataElement . ordinal () ] != null MST[NegateConditionalsMutator]MSP[S]
if ( ! ( obj instanceof Map . Entry ) ) { return false ; MST[BooleanTrueReturnValsMutator]MSP[N] } final Map . Entry < ? , ? > e = ( Map . Entry < ? , ? > ) obj ;
&& parentNode [ dataElement . ordinal () ] . leftNode [ dataElement . ordinal () ] == this ; } private boolean isRightChild ( final DataElement dataElement ) { return parentNode [ dataElement . ordinal () ] != null MST[RemoveConditionalMutator_EQUAL_IF]MSP[S]
&& parentNode [ dataElement . ordinal () ] . leftNode [ dataElement . ordinal () ] == this ; MST[rv.CRCR6Mutator]MSP[S] } private boolean isRightChild ( final DataElement dataElement ) { return parentNode [ dataElement . ordinal () ] != null
return blackColor [ dataElement . ordinal () ] ; MST[BooleanTrueReturnValsMutator]MSP[S] } private boolean isRed ( final DataElement dataElement ) { return ! blackColor [ dataElement . ordinal () ] ; } private void setBlack ( final DataElement dataElement ) { blackColor [ dataElement . ordinal () ] = true ; }
&& parentNode [ dataElement . ordinal () ] . leftNode [ dataElement . ordinal () ] == this ; MST[rv.CRCR2Mutator]MSP[S] } private boolean isRightChild ( final DataElement dataElement ) { return parentNode [ dataElement . ordinal () ] != null
&& parentNode [ dataElement . ordinal () ] . leftNode [ dataElement . ordinal () ] == this ; MST[rv.CRCR5Mutator]MSP[S] } private boolean isRightChild ( final DataElement dataElement ) { return parentNode [ dataElement . ordinal () ] != null
&& parentNode [ dataElement . ordinal () ] . rightNode [ dataElement . ordinal () ] == this ; } @Override public K getKey () { return key ; } @Override public V getValue () { return value ; MST[ReturnValsMutator]MSP[S] } @Override
if ( ! ( obj instanceof Map . Entry ) ) { MST[rv.ROR2Mutator]MSP[S] return false ; } final Map . Entry < ? , ? > e = ( Map . Entry < ? , ? > ) obj ;
return leftNode [ dataElement . ordinal () ] ; MST[NullReturnValsMutator]MSP[S] } private void setRight ( final Node < K , V > node , final DataElement dataElement ) { rightNode [ dataElement . ordinal () ] = node ; }
&& parentNode [ dataElement . ordinal () ] . rightNode [ dataElement . ordinal () ] == this ; MST[InlineConstantMutator]MSP[S] } @Override public K getKey () { return key ; } @Override public V getValue () { return value ; } @Override
return blackColor [ dataElement . ordinal () ] ; MST[rv.UOI4Mutator]MSP[S] } private boolean isRed ( final DataElement dataElement ) { return ! blackColor [ dataElement . ordinal () ] ; } private void setBlack ( final DataElement dataElement ) { blackColor [ dataElement . ordinal () ] = true ; }
private void setRed ( final DataElement dataElement ) { blackColor [ dataElement . ordinal () ] = false ; MST[rv.CRCR1Mutator]MSP[S] } private void copyColor ( final Node < K , V > node , final DataElement dataElement ) {
&& parentNode [ dataElement . ordinal () ] . rightNode [ dataElement . ordinal () ] == this ; MST[rv.ROR5Mutator]MSP[S] } @Override public K getKey () { return key ; } @Override public V getValue () { return value ; } @Override
public V setValue ( final V ignored ) throws UnsupportedOperationException { throw new UnsupportedOperationException ( lr_12 ) ; } @Override public boolean equals ( final Object obj ) { if ( obj == this ) { MST[NegateConditionalsMutator]MSP[N] return true ; }
return blackColor [ dataElement . ordinal () ] ; } private boolean isRed ( final DataElement dataElement ) { return ! blackColor [ dataElement . ordinal () ] ; MST[rv.CRCR5Mutator]MSP[S] } private void setBlack ( final DataElement dataElement ) { blackColor [ dataElement . ordinal () ] = true ; }
return new UnmodifiableMapEntry <> ( node . getValue () , node . getKey () ) ; } private Object getData ( final DataElement dataElement ) { switch ( dataElement ) { MST[NonVoidMethodCallMutator]MSP[S] case KEY : return getKey () ; case VALUE : return getValue () ; default:
&& parentNode [ dataElement . ordinal () ] . leftNode [ dataElement . ordinal () ] == this ; MST[NonVoidMethodCallMutator]MSP[S] } private boolean isRightChild ( final DataElement dataElement ) { return parentNode [ dataElement . ordinal () ] != null
parentNode [ dataElement . ordinal () ] = node ; MST[NonVoidMethodCallMutator]MSP[S] } private Node < K , V > getParent ( final DataElement dataElement ) { return parentNode [ dataElement . ordinal () ] ; }
return new UnmodifiableMapEntry <> ( node . getValue () , node . getKey () ) ; } private Object getData ( final DataElement dataElement ) { switch ( dataElement ) { case KEY : return getKey () ; MST[NullReturnValsMutator]MSP[S] case VALUE : return getValue () ; default:
return blackColor [ dataElement . ordinal () ] ; MST[NonVoidMethodCallMutator]MSP[S] } private boolean isRed ( final DataElement dataElement ) { return ! blackColor [ dataElement . ordinal () ] ; } private void setBlack ( final DataElement dataElement ) { blackColor [ dataElement . ordinal () ] = true ; }
return blackColor [ dataElement . ordinal () ] ; } private boolean isRed ( final DataElement dataElement ) { return ! blackColor [ dataElement . ordinal () ] ; MST[rv.UOI3Mutator]MSP[S] } private void setBlack ( final DataElement dataElement ) { blackColor [ dataElement . ordinal () ] = true ; }
return blackColor [ dataElement . ordinal () ] ; } private boolean isRed ( final DataElement dataElement ) { return ! blackColor [ dataElement . ordinal () ] ; MST[rv.UOI1Mutator]MSP[S] } private void setBlack ( final DataElement dataElement ) { blackColor [ dataElement . ordinal () ] = true ; }
return blackColor [ dataElement . ordinal () ] ; } private boolean isRed ( final DataElement dataElement ) { return ! blackColor [ dataElement . ordinal () ] ; MST[ReturnValsMutator]MSP[S] } private void setBlack ( final DataElement dataElement ) { blackColor [ dataElement . ordinal () ] = true ; }
&& parentNode [ dataElement . ordinal () ] . leftNode [ dataElement . ordinal () ] == this ; MST[rv.ROR5Mutator]MSP[N] } private boolean isRightChild ( final DataElement dataElement ) { return parentNode [ dataElement . ordinal () ] != null
return new UnmodifiableMapEntry <> ( node . getValue () , node . getKey () ) ; } private Object getData ( final DataElement dataElement ) { switch ( dataElement ) { case KEY : return getKey () ; MST[NonVoidMethodCallMutator]MSP[S] case VALUE : return getValue () ; default:
private void setRed ( final DataElement dataElement ) { blackColor [ dataElement . ordinal () ] = false ; MST[InlineConstantMutator]MSP[N] } private void copyColor ( final Node < K , V > node , final DataElement dataElement ) {
&& parentNode [ dataElement . ordinal () ] . leftNode [ dataElement . ordinal () ] == this ; MST[InlineConstantMutator]MSP[N] } private boolean isRightChild ( final DataElement dataElement ) { return parentNode [ dataElement . ordinal () ] != null
return blackColor [ dataElement . ordinal () ] ; } private boolean isRed ( final DataElement dataElement ) { return ! blackColor [ dataElement . ordinal () ] ; } private void setBlack ( final DataElement dataElement ) { blackColor [ dataElement . ordinal () ] = true ; MST[rv.CRCR3Mutator]MSP[N] }
&& parentNode [ dataElement . ordinal () ] . rightNode [ dataElement . ordinal () ] == this ; MST[NonVoidMethodCallMutator]MSP[S] } @Override public K getKey () { return key ; } @Override public V getValue () { return value ; } @Override
return blackColor [ dataElement . ordinal () ] ; } private boolean isRed ( final DataElement dataElement ) { return ! blackColor [ dataElement . ordinal () ] ; MST[rv.ROR2Mutator]MSP[N] } private void setBlack ( final DataElement dataElement ) { blackColor [ dataElement . ordinal () ] = true ; }
&& parentNode [ dataElement . ordinal () ] . leftNode [ dataElement . ordinal () ] == this ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } private boolean isRightChild ( final DataElement dataElement ) { return parentNode [ dataElement . ordinal () ] != null
&& parentNode [ dataElement . ordinal () ] . rightNode [ dataElement . ordinal () ] == this ; } @Override public K getKey () { return key ; } @Override public V getValue () { return value ; MST[NullReturnValsMutator]MSP[N] } @Override
&& parentNode [ dataElement . ordinal () ] . leftNode [ dataElement . ordinal () ] == this ; MST[rv.CRCR3Mutator]MSP[N] } private boolean isRightChild ( final DataElement dataElement ) { return parentNode [ dataElement . ordinal () ] != null
if ( ! ( obj instanceof Map . Entry ) ) { MST[rv.ROR4Mutator]MSP[S] return false ; } final Map . Entry < ? , ? > e = ( Map . Entry < ? , ? > ) obj ;
return blackColor [ dataElement . ordinal () ] ; } private boolean isRed ( final DataElement dataElement ) { return ! blackColor [ dataElement . ordinal () ] ; MST[BooleanTrueReturnValsMutator]MSP[N] } private void setBlack ( final DataElement dataElement ) { blackColor [ dataElement . ordinal () ] = true ; }
&& parentNode [ dataElement . ordinal () ] . rightNode [ dataElement . ordinal () ] == this ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } @Override public K getKey () { return key ; } @Override public V getValue () { return value ; } @Override
return blackColor [ dataElement . ordinal () ] ; } private boolean isRed ( final DataElement dataElement ) { return ! blackColor [ dataElement . ordinal () ] ; MST[rv.CRCR3Mutator]MSP[N] } private void setBlack ( final DataElement dataElement ) { blackColor [ dataElement . ordinal () ] = true ; }
return blackColor [ dataElement . ordinal () ] ; } private boolean isRed ( final DataElement dataElement ) { return ! blackColor [ dataElement . ordinal () ] ; MST[InlineConstantMutator]MSP[N] } private void setBlack ( final DataElement dataElement ) { blackColor [ dataElement . ordinal () ] = true ; }
return leftNode [ dataElement . ordinal () ] ; } private void setRight ( final Node < K , V > node , final DataElement dataElement ) { rightNode [ dataElement . ordinal () ] = node ; MST[NonVoidMethodCallMutator]MSP[N] }
&& parentNode [ dataElement . ordinal () ] . rightNode [ dataElement . ordinal () ] == this ; } @Override public K getKey () { return key ; MST[ReturnValsMutator]MSP[N] } @Override public V getValue () { return value ; } @Override
public V setValue ( final V ignored ) throws UnsupportedOperationException { throw new UnsupportedOperationException ( lr_12 ) ; } @Override public boolean equals ( final Object obj ) { if ( obj == this ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] return true ; }
&& parentNode [ dataElement . ordinal () ] . leftNode [ dataElement . ordinal () ] == this ; MST[NegateConditionalsMutator]MSP[N] } private boolean isRightChild ( final DataElement dataElement ) { return parentNode [ dataElement . ordinal () ] != null
parentNode [ dataElement . ordinal () ] = node ; } private Node < K , V > getParent ( final DataElement dataElement ) { return parentNode [ dataElement . ordinal () ] ; MST[NullReturnValsMutator]MSP[N] }
&& parentNode [ dataElement . ordinal () ] . leftNode [ dataElement . ordinal () ] == this ; } private boolean isRightChild ( final DataElement dataElement ) { return parentNode [ dataElement . ordinal () ] != null MST[BooleanTrueReturnValsMutator]MSP[S]
return blackColor [ dataElement . ordinal () ] ; } private boolean isRed ( final DataElement dataElement ) { return ! blackColor [ dataElement . ordinal () ] ; MST[NonVoidMethodCallMutator]MSP[N] } private void setBlack ( final DataElement dataElement ) { blackColor [ dataElement . ordinal () ] = true ; }
&& parentNode [ dataElement . ordinal () ] . rightNode [ dataElement . ordinal () ] == this ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] } @Override public K getKey () { return key ; } @Override public V getValue () { return value ; } @Override
blackColor [ dataElement . ordinal () ] = node . blackColor [ dataElement . ordinal () ] ; } private boolean isLeftChild ( final DataElement dataElement ) { return parentNode [ dataElement . ordinal () ] != null MST[ReturnValsMutator]MSP[N]
return blackColor [ dataElement . ordinal () ] ; MST[rv.UOI3Mutator]MSP[N] } private boolean isRed ( final DataElement dataElement ) { return ! blackColor [ dataElement . ordinal () ] ; } private void setBlack ( final DataElement dataElement ) { blackColor [ dataElement . ordinal () ] = true ; }
return blackColor [ dataElement . ordinal () ] ; } private boolean isRed ( final DataElement dataElement ) { return ! blackColor [ dataElement . ordinal () ] ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } private void setBlack ( final DataElement dataElement ) { blackColor [ dataElement . ordinal () ] = true ; }
&& parentNode [ dataElement . ordinal () ] . leftNode [ dataElement . ordinal () ] == this ; } private boolean isRightChild ( final DataElement dataElement ) { return parentNode [ dataElement . ordinal () ] != null MST[NonVoidMethodCallMutator]MSP[N]
public V setValue ( final V ignored ) throws UnsupportedOperationException { throw new UnsupportedOperationException ( lr_12 ) ; } @Override public boolean equals ( final Object obj ) { if ( obj == this ) { MST[rv.ROR5Mutator]MSP[S] return true ; }
return blackColor [ dataElement . ordinal () ] ; } private boolean isRed ( final DataElement dataElement ) { return ! blackColor [ dataElement . ordinal () ] ; MST[rv.CRCR6Mutator]MSP[N] } private void setBlack ( final DataElement dataElement ) { blackColor [ dataElement . ordinal () ] = true ; }
if ( ! ( obj instanceof Map . Entry ) ) { return false ; MST[InlineConstantMutator]MSP[S] } final Map . Entry < ? , ? > e = ( Map . Entry < ? , ? > ) obj ;
return new UnmodifiableMapEntry <> ( node . getValue () , node . getKey () ) ; } private Object getData ( final DataElement dataElement ) { switch ( dataElement ) { MST[rv.UOI1Mutator]MSP[S] case KEY : return getKey () ; case VALUE : return getValue () ; default:
return blackColor [ dataElement . ordinal () ] ; } private boolean isRed ( final DataElement dataElement ) { return ! blackColor [ dataElement . ordinal () ] ; MST[rv.CRCR2Mutator]MSP[S] } private void setBlack ( final DataElement dataElement ) { blackColor [ dataElement . ordinal () ] = true ; }
&& parentNode [ dataElement . ordinal () ] . rightNode [ dataElement . ordinal () ] == this ; MST[NegateConditionalsMutator]MSP[S] } @Override public K getKey () { return key ; } @Override public V getValue () { return value ; } @Override
blackColor [ dataElement . ordinal () ] = node . blackColor [ dataElement . ordinal () ] ; } private boolean isLeftChild ( final DataElement dataElement ) { return parentNode [ dataElement . ordinal () ] != null MST[NonVoidMethodCallMutator]MSP[S]
return blackColor [ dataElement . ordinal () ] ; } private boolean isRed ( final DataElement dataElement ) { return ! blackColor [ dataElement . ordinal () ] ; MST[rv.ROR3Mutator]MSP[S] } private void setBlack ( final DataElement dataElement ) { blackColor [ dataElement . ordinal () ] = true ; }
parentNode [ dataElement . ordinal () ] = node ; } private Node < K , V > getParent ( final DataElement dataElement ) { return parentNode [ dataElement . ordinal () ] ; MST[ReturnValsMutator]MSP[S] }
return blackColor [ dataElement . ordinal () ] ; } private boolean isRed ( final DataElement dataElement ) { return ! blackColor [ dataElement . ordinal () ] ; } private void setBlack ( final DataElement dataElement ) { blackColor [ dataElement . ordinal () ] = true ; MST[rv.CRCR5Mutator]MSP[S] }
return blackColor [ dataElement . ordinal () ] ; } private boolean isRed ( final DataElement dataElement ) { return ! blackColor [ dataElement . ordinal () ] ; } private void setBlack ( final DataElement dataElement ) { blackColor [ dataElement . ordinal () ] = true ; MST[rv.CRCR2Mutator]MSP[S] }
return new UnmodifiableMapEntry <> ( node . getValue () , node . getKey () ) ; } private Object getData ( final DataElement dataElement ) { switch ( dataElement ) { case KEY : return getKey () ; case VALUE : return getValue () ; MST[NonVoidMethodCallMutator]MSP[S] default:
return blackColor [ dataElement . ordinal () ] ; MST[BooleanFalseReturnValsMutator]MSP[S] } private boolean isRed ( final DataElement dataElement ) { return ! blackColor [ dataElement . ordinal () ] ; } private void setBlack ( final DataElement dataElement ) { blackColor [ dataElement . ordinal () ] = true ; }
&& parentNode [ dataElement . ordinal () ] . leftNode [ dataElement . ordinal () ] == this ; MST[rv.CRCR5Mutator]MSP[S] } private boolean isRightChild ( final DataElement dataElement ) { return parentNode [ dataElement . ordinal () ] != null
&& parentNode [ dataElement . ordinal () ] . leftNode [ dataElement . ordinal () ] == this ; MST[rv.CRCR6Mutator]MSP[S] } private boolean isRightChild ( final DataElement dataElement ) { return parentNode [ dataElement . ordinal () ] != null
return new UnmodifiableMapEntry <> ( node . getValue () , node . getKey () ) ; } private Object getData ( final DataElement dataElement ) { switch ( dataElement ) { MST[rv.UOI4Mutator]MSP[S] case KEY : return getKey () ; case VALUE : return getValue () ; default:
return blackColor [ dataElement . ordinal () ] ; } private boolean isRed ( final DataElement dataElement ) { return ! blackColor [ dataElement . ordinal () ] ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] } private void setBlack ( final DataElement dataElement ) { blackColor [ dataElement . ordinal () ] = true ; }
return blackColor [ dataElement . ordinal () ] ; } private boolean isRed ( final DataElement dataElement ) { return ! blackColor [ dataElement . ordinal () ] ; MST[rv.CRCR1Mutator]MSP[S] } private void setBlack ( final DataElement dataElement ) { blackColor [ dataElement . ordinal () ] = true ; }
private void setRed ( final DataElement dataElement ) { blackColor [ dataElement . ordinal () ] = false ; MST[rv.CRCR5Mutator]MSP[S] } private void copyColor ( final Node < K , V > node , final DataElement dataElement ) {
return blackColor [ dataElement . ordinal () ] ; } private boolean isRed ( final DataElement dataElement ) { return ! blackColor [ dataElement . ordinal () ] ; MST[rv.CRCR5Mutator]MSP[S] } private void setBlack ( final DataElement dataElement ) { blackColor [ dataElement . ordinal () ] = true ; }
&& parentNode [ dataElement . ordinal () ] . leftNode [ dataElement . ordinal () ] == this ; } private boolean isRightChild ( final DataElement dataElement ) { return parentNode [ dataElement . ordinal () ] != null MST[ReturnValsMutator]MSP[S]
&& parentNode [ dataElement . ordinal () ] . leftNode [ dataElement . ordinal () ] == this ; MST[NonVoidMethodCallMutator]MSP[S] } private boolean isRightChild ( final DataElement dataElement ) { return parentNode [ dataElement . ordinal () ] != null
if ( ! ( obj instanceof Map . Entry ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] return false ; } final Map . Entry < ? , ? > e = ( Map . Entry < ? , ? > ) obj ;
if ( ! ( obj instanceof Map . Entry ) ) { return false ; MST[rv.CRCR6Mutator]MSP[N] } final Map . Entry < ? , ? > e = ( Map . Entry < ? , ? > ) obj ;
if ( obj instanceof Map . Entry == false ) { MST[rv.ROR5Mutator]MSP[S] return false ; } final Map . Entry < ? , ? > entry = ( Map . Entry < ? , ? > ) obj ; final Object value = entry . getValue () ;
if ( obj instanceof Map . Entry == false ) { return false ; MST[rv.CRCR6Mutator]MSP[N] } final Map . Entry < ? , ? > entry = ( Map . Entry < ? , ? > ) obj ; final Object value = entry . getValue () ;
if ( obj instanceof Map . Entry == false ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return false ; } final Map . Entry < ? , ? > entry = ( Map . Entry < ? , ? > ) obj ; final Object value = entry . getValue () ;
if ( obj instanceof Map . Entry == false ) { MST[rv.ROR2Mutator]MSP[S] return false ; } final Map . Entry < ? , ? > entry = ( Map . Entry < ? , ? > ) obj ; final Object value = entry . getValue () ;
if ( obj instanceof Map . Entry == false ) { return false ; MST[BooleanTrueReturnValsMutator]MSP[N] } final Map . Entry < ? , ? > entry = ( Map . Entry < ? , ? > ) obj ; final Object value = entry . getValue () ;
public Iterator < Map . Entry < K , V > > iterator () { return new ViewMapEntryIterator () ; MST[NullReturnValsMutator]MSP[S] } @Override public boolean contains ( final Object obj ) { if ( obj instanceof Map . Entry == false ) { return false ; }
if ( obj instanceof Map . Entry == false ) { MST[NegateConditionalsMutator]MSP[S] return false ; } final Map . Entry < ? , ? > entry = ( Map . Entry < ? , ? > ) obj ; final Object value = entry . getValue () ;
public Iterator < Map . Entry < K , V > > iterator () { return new ViewMapEntryIterator () ; MST[ConstructorCallMutator]MSP[S] } @Override public boolean contains ( final Object obj ) { if ( obj instanceof Map . Entry == false ) { return false ; }
if ( obj instanceof Map . Entry == false ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] return false ; } final Map . Entry < ? , ? > entry = ( Map . Entry < ? , ? > ) obj ; final Object value = entry . getValue () ;
public Iterator < Map . Entry < K , V > > iterator () { return new ViewMapEntryIterator () ; MST[ReturnValsMutator]MSP[S] } @Override public boolean contains ( final Object obj ) { if ( obj instanceof Map . Entry == false ) { return false ; }
if ( obj instanceof Map . Entry == false ) { MST[rv.ROR4Mutator]MSP[S] return false ; } final Map . Entry < ? , ? > entry = ( Map . Entry < ? , ? > ) obj ; final Object value = entry . getValue () ;
if ( obj instanceof Map . Entry == false ) { return false ; MST[InlineConstantMutator]MSP[N] } final Map . Entry < ? , ? > entry = ( Map . Entry < ? , ? > ) obj ; final Object value = entry . getValue () ;
return lastReturnedNode . getKey () ; } @Override public K setValue ( final K obj ) { throw new UnsupportedOperationException () ; MST[ConstructorCallMutator]MSP[S] } @Override public V next () { return navigateNext () . getValue () ; } @Override public V previous () { return navigatePrevious () . getValue () ;
return new InverseViewMapEntryIterator () ; } public final boolean hasNext () { return nextNode != null ; } protected Node < K , V > navigateNext () { if ( nextNode == null ) { MST[rv.ROR5Mutator]MSP[N] throw new NoSuchElementException () ; } if ( modifications != expectedModifications ) {
throw new ConcurrentModificationException () ; } lastReturnedNode = nextNode ; previousNode = nextNode ; nextNode = nextGreater ( nextNode , orderType ) ; return lastReturnedNode ; MST[NullReturnValsMutator]MSP[S] } public boolean hasPrevious () { return previousNode != null ; } protected Node < K , V > navigatePrevious () {
lastReturnedNode = previousNode ; previousNode = nextSmaller ( previousNode , orderType ) ; return lastReturnedNode ; } public final void remove () { if ( lastReturnedNode == null ) { MST[rv.ROR5Mutator]MSP[S] throw new IllegalStateException () ; } if ( modifications != expectedModifications ) { throw new ConcurrentModificationException () ; }
return new InverseViewMapEntryIterator () ; } public final boolean hasNext () { return nextNode != null ; MST[rv.CRCR4Mutator]MSP[N] } protected Node < K , V > navigateNext () { if ( nextNode == null ) { throw new NoSuchElementException () ; } if ( modifications != expectedModifications ) {
return new InverseViewMapEntryIterator () ; } public final boolean hasNext () { return nextNode != null ; MST[rv.CRCR3Mutator]MSP[N] } protected Node < K , V > navigateNext () { if ( nextNode == null ) { throw new NoSuchElementException () ; } if ( modifications != expectedModifications ) {
return new InverseViewMapEntryIterator () ; } public final boolean hasNext () { return nextNode != null ; MST[rv.CRCR5Mutator]MSP[N] } protected Node < K , V > navigateNext () { if ( nextNode == null ) { throw new NoSuchElementException () ; } if ( modifications != expectedModifications ) {
return new InverseViewMapEntryIterator () ; } public final boolean hasNext () { return nextNode != null ; } protected Node < K , V > navigateNext () { if ( nextNode == null ) { throw new NoSuchElementException () ; } if ( modifications != expectedModifications ) { MST[NegateConditionalsMutator]MSP[S]
return new InverseViewMapEntryIterator () ; } public final boolean hasNext () { return nextNode != null ; MST[rv.CRCR2Mutator]MSP[N] } protected Node < K , V > navigateNext () { if ( nextNode == null ) { throw new NoSuchElementException () ; } if ( modifications != expectedModifications ) {
return new InverseViewMapEntryIterator () ; } public final boolean hasNext () { return nextNode != null ; MST[rv.CRCR6Mutator]MSP[N] } protected Node < K , V > navigateNext () { if ( nextNode == null ) { throw new NoSuchElementException () ; } if ( modifications != expectedModifications ) {
return new InverseViewMapEntryIterator () ; } public final boolean hasNext () { return nextNode != null ; MST[rv.CRCR3Mutator]MSP[N] } protected Node < K , V > navigateNext () { if ( nextNode == null ) { throw new NoSuchElementException () ; } if ( modifications != expectedModifications ) {
return new InverseViewMapEntryIterator () ; } public final boolean hasNext () { return nextNode != null ; MST[rv.CRCR1Mutator]MSP[N] } protected Node < K , V > navigateNext () { if ( nextNode == null ) { throw new NoSuchElementException () ; } if ( modifications != expectedModifications ) {
return new InverseViewMapEntryIterator () ; } public final boolean hasNext () { return nextNode != null ; MST[rv.CRCR5Mutator]MSP[N] } protected Node < K , V > navigateNext () { if ( nextNode == null ) { throw new NoSuchElementException () ; } if ( modifications != expectedModifications ) {
return new InverseViewMapEntryIterator () ; } public final boolean hasNext () { return nextNode != null ; MST[rv.CRCR6Mutator]MSP[N] } protected Node < K , V > navigateNext () { if ( nextNode == null ) { throw new NoSuchElementException () ; } if ( modifications != expectedModifications ) {
return new InverseViewMapEntryIterator () ; } public final boolean hasNext () { return nextNode != null ; MST[NegateConditionalsMutator]MSP[N] } protected Node < K , V > navigateNext () { if ( nextNode == null ) { throw new NoSuchElementException () ; } if ( modifications != expectedModifications ) {
throw new ConcurrentModificationException () ; } lastReturnedNode = nextNode ; previousNode = nextNode ; nextNode = nextGreater ( nextNode , orderType ) ; return lastReturnedNode ; MST[ReturnValsMutator]MSP[S] } public boolean hasPrevious () { return previousNode != null ; } protected Node < K , V > navigatePrevious () {
lastReturnedNode = previousNode ; previousNode = nextSmaller ( previousNode , orderType ) ; return lastReturnedNode ; } public final void remove () { if ( lastReturnedNode == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] throw new IllegalStateException () ; } if ( modifications != expectedModifications ) { throw new ConcurrentModificationException () ; }
return new InverseViewMapEntryIterator () ; } public final boolean hasNext () { return nextNode != null ; } protected Node < K , V > navigateNext () { if ( nextNode == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] throw new NoSuchElementException () ; } if ( modifications != expectedModifications ) {
return new InverseViewMapEntryIterator () ; } public final boolean hasNext () { return nextNode != null ; } protected Node < K , V > navigateNext () { if ( nextNode == null ) { MST[NegateConditionalsMutator]MSP[N] throw new NoSuchElementException () ; } if ( modifications != expectedModifications ) {
throw new ConcurrentModificationException () ; } lastReturnedNode = nextNode ; previousNode = nextNode ; nextNode = nextGreater ( nextNode , orderType ) ; return lastReturnedNode ; } public boolean hasPrevious () { return previousNode != null ; MST[ReturnValsMutator]MSP[N] } protected Node < K , V > navigatePrevious () {
return new InverseViewMapEntryIterator () ; } public final boolean hasNext () { return nextNode != null ; } protected Node < K , V > navigateNext () { if ( nextNode == null ) { throw new NoSuchElementException () ; } if ( modifications != expectedModifications ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S]
return new InverseViewMapEntryIterator () ; } public final boolean hasNext () { return nextNode != null ; MST[InlineConstantMutator]MSP[N] } protected Node < K , V > navigateNext () { if ( nextNode == null ) { throw new NoSuchElementException () ; } if ( modifications != expectedModifications ) {
return new InverseViewMapEntryIterator () ; } public final boolean hasNext () { return nextNode != null ; MST[InlineConstantMutator]MSP[N] } protected Node < K , V > navigateNext () { if ( nextNode == null ) { throw new NoSuchElementException () ; } if ( modifications != expectedModifications ) {
return new InverseViewMapEntryIterator () ; } public final boolean hasNext () { return nextNode != null ; } protected Node < K , V > navigateNext () { if ( nextNode == null ) { throw new NoSuchElementException () ; } if ( modifications != expectedModifications ) { MST[rv.ROR5Mutator]MSP[S]
return new InverseViewMapEntryIterator () ; } public final boolean hasNext () { return nextNode != null ; } protected Node < K , V > navigateNext () { if ( nextNode == null ) { throw new NoSuchElementException () ; } if ( modifications != expectedModifications ) { MST[rv.ABSMutator]MSP[S]
throw new ConcurrentModificationException () ; } lastReturnedNode = nextNode ; previousNode = nextNode ; nextNode = nextGreater ( nextNode , orderType ) ; return lastReturnedNode ; } public boolean hasPrevious () { return previousNode != null ; MST[rv.CRCR1Mutator]MSP[N] } protected Node < K , V > navigatePrevious () {
throw new ConcurrentModificationException () ; } lastReturnedNode = nextNode ; previousNode = nextNode ; nextNode = nextGreater ( nextNode , orderType ) ; return lastReturnedNode ; } public boolean hasPrevious () { return previousNode != null ; MST[rv.CRCR5Mutator]MSP[N] } protected Node < K , V > navigatePrevious () {
throw new ConcurrentModificationException () ; } lastReturnedNode = nextNode ; previousNode = nextNode ; nextNode = nextGreater ( nextNode , orderType ) ; return lastReturnedNode ; } public boolean hasPrevious () { return previousNode != null ; MST[rv.CRCR6Mutator]MSP[N] } protected Node < K , V > navigatePrevious () {
return new InverseViewMapEntryIterator () ; } public final boolean hasNext () { return nextNode != null ; } protected Node < K , V > navigateNext () { if ( nextNode == null ) { throw new NoSuchElementException () ; } if ( modifications != expectedModifications ) { MST[rv.ROR2Mutator]MSP[N]
throw new ConcurrentModificationException () ; } lastReturnedNode = nextNode ; previousNode = nextNode ; nextNode = nextGreater ( nextNode , orderType ) ; return lastReturnedNode ; } public boolean hasPrevious () { return previousNode != null ; MST[NegateConditionalsMutator]MSP[N] } protected Node < K , V > navigatePrevious () {
return new InverseViewMapEntryIterator () ; } public final boolean hasNext () { return nextNode != null ; MST[rv.ROR5Mutator]MSP[N] } protected Node < K , V > navigateNext () { if ( nextNode == null ) { throw new NoSuchElementException () ; } if ( modifications != expectedModifications ) {
if ( previousNode == null ) { throw new NoSuchElementException () ; MST[ConstructorCallMutator]MSP[S] } if ( modifications != expectedModifications ) { throw new ConcurrentModificationException () ; } nextNode = lastReturnedNode ; if ( nextNode == null ) { nextNode = nextGreater ( previousNode , orderType ) ; }
throw new ConcurrentModificationException () ; } lastReturnedNode = nextNode ; previousNode = nextNode ; MST[experimental.MemberVariableMutator]MSP[N] nextNode = nextGreater ( nextNode , orderType ) ; return lastReturnedNode ; } public boolean hasPrevious () { return previousNode != null ; } protected Node < K , V > navigatePrevious () {
lastReturnedNode = previousNode ; previousNode = nextSmaller ( previousNode , orderType ) ; return lastReturnedNode ; } public final void remove () { if ( lastReturnedNode == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] throw new IllegalStateException () ; } if ( modifications != expectedModifications ) { throw new ConcurrentModificationException () ; }
return new InverseViewMapEntryIterator () ; } public final boolean hasNext () { return nextNode != null ; MST[ReturnValsMutator]MSP[N] } protected Node < K , V > navigateNext () { if ( nextNode == null ) { throw new NoSuchElementException () ; } if ( modifications != expectedModifications ) {
throw new ConcurrentModificationException () ; } lastReturnedNode = nextNode ; previousNode = nextNode ; nextNode = nextGreater ( nextNode , orderType ) ; MST[NonVoidMethodCallMutator]MSP[N] return lastReturnedNode ; } public boolean hasPrevious () { return previousNode != null ; } protected Node < K , V > navigatePrevious () {
return new InverseViewMapEntryIterator () ; } public final boolean hasNext () { return nextNode != null ; MST[BooleanTrueReturnValsMutator]MSP[N] } protected Node < K , V > navigateNext () { if ( nextNode == null ) { throw new NoSuchElementException () ; } if ( modifications != expectedModifications ) {
if ( previousNode == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] throw new NoSuchElementException () ; } if ( modifications != expectedModifications ) { throw new ConcurrentModificationException () ; } nextNode = lastReturnedNode ; if ( nextNode == null ) { nextNode = nextGreater ( previousNode , orderType ) ; }
return new InverseViewMapEntryIterator () ; } public final boolean hasNext () { return nextNode != null ; } protected Node < K , V > navigateNext () { if ( nextNode == null ) { throw new NoSuchElementException () ; } if ( modifications != expectedModifications ) { MST[rv.UOI2Mutator]MSP[S]
return new InverseViewMapEntryIterator () ; } public final boolean hasNext () { return nextNode != null ; } protected Node < K , V > navigateNext () { if ( nextNode == null ) { throw new NoSuchElementException () ; } if ( modifications != expectedModifications ) { MST[rv.UOI3Mutator]MSP[S]
if ( previousNode == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] throw new NoSuchElementException () ; } if ( modifications != expectedModifications ) { throw new ConcurrentModificationException () ; } nextNode = lastReturnedNode ; if ( nextNode == null ) { nextNode = nextGreater ( previousNode , orderType ) ; }
throw new ConcurrentModificationException () ; } lastReturnedNode = nextNode ; previousNode = nextNode ; nextNode = nextGreater ( nextNode , orderType ) ; return lastReturnedNode ; } public boolean hasPrevious () { return previousNode != null ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } protected Node < K , V > navigatePrevious () {
return new InverseViewMapEntryIterator () ; } public final boolean hasNext () { return nextNode != null ; } protected Node < K , V > navigateNext () { if ( nextNode == null ) { throw new NoSuchElementException () ; } if ( modifications != expectedModifications ) { MST[rv.UOI4Mutator]MSP[S]
return new InverseViewMapEntryIterator () ; } public final boolean hasNext () { return nextNode != null ; } protected Node < K , V > navigateNext () { if ( nextNode == null ) { throw new NoSuchElementException () ; } if ( modifications != expectedModifications ) { MST[rv.UOI1Mutator]MSP[S]
throw new ConcurrentModificationException () ; } lastReturnedNode = nextNode ; previousNode = nextNode ; nextNode = nextGreater ( nextNode , orderType ) ; return lastReturnedNode ; } public boolean hasPrevious () { return previousNode != null ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } protected Node < K , V > navigatePrevious () {
return new InverseViewMapEntryIterator () ; } public final boolean hasNext () { return nextNode != null ; } protected Node < K , V > navigateNext () { if ( nextNode == null ) { throw new NoSuchElementException () ; } if ( modifications != expectedModifications ) { MST[rv.ROR1Mutator]MSP[S]
throw new ConcurrentModificationException () ; } lastReturnedNode = nextNode ; previousNode = nextNode ; nextNode = nextGreater ( nextNode , orderType ) ; return lastReturnedNode ; } public boolean hasPrevious () { return previousNode != null ; MST[rv.ROR5Mutator]MSP[N] } protected Node < K , V > navigatePrevious () {
lastReturnedNode = previousNode ; previousNode = nextSmaller ( previousNode , orderType ) ; return lastReturnedNode ; } public final void remove () { if ( lastReturnedNode == null ) { MST[NegateConditionalsMutator]MSP[S] throw new IllegalStateException () ; } if ( modifications != expectedModifications ) { throw new ConcurrentModificationException () ; }
lastReturnedNode = previousNode ; previousNode = nextSmaller ( previousNode , orderType ) ; return lastReturnedNode ; } public final void remove () { if ( lastReturnedNode == null ) { throw new IllegalStateException () ; MST[ConstructorCallMutator]MSP[S] } if ( modifications != expectedModifications ) { throw new ConcurrentModificationException () ; }
if ( previousNode == null ) { MST[rv.ROR5Mutator]MSP[N] throw new NoSuchElementException () ; } if ( modifications != expectedModifications ) { throw new ConcurrentModificationException () ; } nextNode = lastReturnedNode ; if ( nextNode == null ) { nextNode = nextGreater ( previousNode , orderType ) ; }
throw new ConcurrentModificationException () ; } lastReturnedNode = nextNode ; previousNode = nextNode ; nextNode = nextGreater ( nextNode , orderType ) ; MST[experimental.MemberVariableMutator]MSP[S] return lastReturnedNode ; } public boolean hasPrevious () { return previousNode != null ; } protected Node < K , V > navigatePrevious () {
return new InverseViewMapEntryIterator () ; } public final boolean hasNext () { return nextNode != null ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } protected Node < K , V > navigateNext () { if ( nextNode == null ) { throw new NoSuchElementException () ; } if ( modifications != expectedModifications ) {
throw new ConcurrentModificationException () ; } lastReturnedNode = nextNode ; previousNode = nextNode ; nextNode = nextGreater ( nextNode , orderType ) ; return lastReturnedNode ; } public boolean hasPrevious () { return previousNode != null ; MST[BooleanTrueReturnValsMutator]MSP[N] } protected Node < K , V > navigatePrevious () {
return new InverseViewMapEntryIterator () ; } public final boolean hasNext () { return nextNode != null ; } protected Node < K , V > navigateNext () { if ( nextNode == null ) { throw new NoSuchElementException () ; } if ( modifications != expectedModifications ) { MST[rv.ROR4Mutator]MSP[N]
return new InverseViewMapEntryIterator () ; } public final boolean hasNext () { return nextNode != null ; } protected Node < K , V > navigateNext () { if ( nextNode == null ) { throw new NoSuchElementException () ; } if ( modifications != expectedModifications ) { MST[rv.ROR3Mutator]MSP[S]
return new InverseViewMapEntryIterator () ; } public final boolean hasNext () { return nextNode != null ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } protected Node < K , V > navigateNext () { if ( nextNode == null ) { throw new NoSuchElementException () ; } if ( modifications != expectedModifications ) {
throw new ConcurrentModificationException () ; } lastReturnedNode = nextNode ; previousNode = nextNode ; nextNode = nextGreater ( nextNode , orderType ) ; return lastReturnedNode ; } public boolean hasPrevious () { return previousNode != null ; MST[rv.CRCR3Mutator]MSP[N] } protected Node < K , V > navigatePrevious () {
return new InverseViewMapEntryIterator () ; } public final boolean hasNext () { return nextNode != null ; } protected Node < K , V > navigateNext () { if ( nextNode == null ) { throw new NoSuchElementException () ; } if ( modifications != expectedModifications ) { MST[NonVoidMethodCallMutator]MSP[S]
throw new ConcurrentModificationException () ; } lastReturnedNode = nextNode ; previousNode = nextNode ; nextNode = nextGreater ( nextNode , orderType ) ; return lastReturnedNode ; } public boolean hasPrevious () { return previousNode != null ; MST[InlineConstantMutator]MSP[N] } protected Node < K , V > navigatePrevious () {
throw new ConcurrentModificationException () ; } lastReturnedNode = nextNode ; previousNode = nextNode ; nextNode = nextGreater ( nextNode , orderType ) ; MST[ArgumentPropagationMutator]MSP[S] return lastReturnedNode ; } public boolean hasPrevious () { return previousNode != null ; } protected Node < K , V > navigatePrevious () {
if ( previousNode == null ) { MST[NegateConditionalsMutator]MSP[N] throw new NoSuchElementException () ; } if ( modifications != expectedModifications ) { throw new ConcurrentModificationException () ; } nextNode = lastReturnedNode ; if ( nextNode == null ) { nextNode = nextGreater ( previousNode , orderType ) ; }
throw new ConcurrentModificationException () ; } lastReturnedNode = nextNode ; MST[experimental.MemberVariableMutator]MSP[S] previousNode = nextNode ; nextNode = nextGreater ( nextNode , orderType ) ; return lastReturnedNode ; } public boolean hasPrevious () { return previousNode != null ; } protected Node < K , V > navigatePrevious () {
return new InverseViewMapEntryIterator () ; } public final boolean hasNext () { return nextNode != null ; } protected Node < K , V > navigateNext () { if ( nextNode == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] throw new NoSuchElementException () ; } if ( modifications != expectedModifications ) {
return new InverseViewMapEntryIterator () ; } public final boolean hasNext () { return nextNode != null ; } protected Node < K , V > navigateNext () { if ( nextNode == null ) { throw new NoSuchElementException () ; MST[ConstructorCallMutator]MSP[S] } if ( modifications != expectedModifications ) {
return new InverseViewMapIterator ( VALUE ) ; } @Override public OrderedBidiMap < K , V > inverseBidiMap () { return TreeBidiMap . this ; } @Override public boolean equals ( final Object obj ) { return TreeBidiMap . this . doEquals ( obj , DataElement . VALUE ) ; MST[ReturnValsMutator]MSP[N] }
throw new NoSuchElementException ( lr_1 ) ; } return greatestNode ( TreeBidiMap . this . rootNode [ VALUE . ordinal () ] , VALUE ) . getValue () ; MST[ArgumentPropagationMutator]MSP[N] } @Override public V nextKey ( final V key ) { checkKey ( key ) ;
@Override public int hashCode () { return TreeBidiMap . this . doHashCode ( DataElement . VALUE ) ; } @Override public String toString () { return TreeBidiMap . this . doToString ( DataElement . VALUE ) ; MST[NonVoidMethodCallMutator]MSP[N] }
final Node < K , V > node = nextGreater ( TreeBidiMap . this . <V > lookup ( key , VALUE ) , VALUE ) ; MST[NonVoidMethodCallMutator]MSP[N] return node == null ? null : node . getValue () ; } @Override public V previousKey ( final V key ) {
if ( inverseEntrySet == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] inverseEntrySet = new InverseEntryView () ; } return inverseEntrySet ; } @Override public OrderedMapIterator < V , K > mapIterator () { if ( isEmpty () ) { return EmptyOrderedMapIterator . <V , K > emptyOrderedMapIterator () ; }
put ( e . getKey () , e . getValue () ) ; MST[NonVoidMethodCallMutator]MSP[S] } } @Override public K remove ( final Object key ) { return TreeBidiMap . this . removeValue ( key ) ; } @Override public V removeValue ( final Object value ) {
return TreeBidiMap . this . containsValue ( key ) ; MST[BooleanFalseReturnValsMutator]MSP[N] } @Override public boolean containsValue ( final Object value ) { return TreeBidiMap . this . containsKey ( value ) ; } @Override public V firstKey () { if ( TreeBidiMap . this . nodeCount == 0 ) {
@Override public int hashCode () { return TreeBidiMap . this . doHashCode ( DataElement . VALUE ) ; } @Override public String toString () { return TreeBidiMap . this . doToString ( DataElement . VALUE ) ; MST[EmptyObjectReturnValsMutator]MSP[N] }
calculatedHashCode = true ; } return hashcodeValue ; } @Override public int size () { return TreeBidiMap . this . size () ; } @Override public boolean isEmpty () { return TreeBidiMap . this . isEmpty () ; MST[ReturnValsMutator]MSP[N] } @Override public K get ( final Object key ) {
return TreeBidiMap . this . getKey ( key ) ; } @Override public V getKey ( final Object value ) { return TreeBidiMap . this . get ( value ) ; MST[NonVoidMethodCallMutator]MSP[S] } @Override public boolean containsKey ( final Object key ) {
return TreeBidiMap . this . containsValue ( key ) ; } @Override public boolean containsValue ( final Object value ) { return TreeBidiMap . this . containsKey ( value ) ; } @Override public V firstKey () { if ( TreeBidiMap . this . nodeCount == 0 ) { MST[rv.ROR4Mutator]MSP[S]
if ( inverseEntrySet == null ) { inverseEntrySet = new InverseEntryView () ; } return inverseEntrySet ; MST[ReturnValsMutator]MSP[S] } @Override public OrderedMapIterator < V , K > mapIterator () { if ( isEmpty () ) { return EmptyOrderedMapIterator . <V , K > emptyOrderedMapIterator () ; }
return TreeBidiMap . this . containsValue ( key ) ; } @Override public boolean containsValue ( final Object value ) { return TreeBidiMap . this . containsKey ( value ) ; } @Override public V firstKey () { if ( TreeBidiMap . this . nodeCount == 0 ) { MST[rv.ROR3Mutator]MSP[N]
throw new NoSuchElementException ( lr_1 ) ; MST[ConstructorCallMutator]MSP[S] } return leastNode ( TreeBidiMap . this . rootNode [ VALUE . ordinal () ] , VALUE ) . getValue () ; } @Override public V lastKey () { if ( TreeBidiMap . this . nodeCount == 0 ) {
return inverseKeySet ; } @Override public Set < K > values () { if ( inverseValuesSet == null ) { inverseValuesSet = new KeyView ( VALUE ) ; MST[ConstructorCallMutator]MSP[S] } return inverseValuesSet ; } @Override public Set < Map . Entry < V , K > > entrySet () {
throw new NoSuchElementException ( lr_1 ) ; } return greatestNode ( TreeBidiMap . this . rootNode [ VALUE . ordinal () ] , VALUE ) . getValue () ; MST[ReturnValsMutator]MSP[N] } @Override public V nextKey ( final V key ) { checkKey ( key ) ;
throw new NoSuchElementException ( lr_1 ) ; } return greatestNode ( TreeBidiMap . this . rootNode [ VALUE . ordinal () ] , VALUE ) . getValue () ; MST[NullReturnValsMutator]MSP[N] } @Override public V nextKey ( final V key ) { checkKey ( key ) ;
final Node < K , V > node = nextGreater ( TreeBidiMap . this . <V > lookup ( key , VALUE ) , VALUE ) ; return node == null ? null : node . getValue () ; MST[ReturnValsMutator]MSP[S] } @Override public V previousKey ( final V key ) {
if ( inverseEntrySet == null ) { inverseEntrySet = new InverseEntryView () ; MST[experimental.MemberVariableMutator]MSP[S] } return inverseEntrySet ; } @Override public OrderedMapIterator < V , K > mapIterator () { if ( isEmpty () ) { return EmptyOrderedMapIterator . <V , K > emptyOrderedMapIterator () ; }
return TreeBidiMap . this . remove ( value ) ; } @Override public void clear () { TreeBidiMap . this . clear () ; MST[VoidMethodCallMutator]MSP[N] } @Override public Set < V > keySet () { if ( inverseKeySet == null ) { inverseKeySet = new ValueView ( VALUE ) ; }
return TreeBidiMap . this . containsValue ( key ) ; MST[ReturnValsMutator]MSP[S] } @Override public boolean containsValue ( final Object value ) { return TreeBidiMap . this . containsKey ( value ) ; } @Override public V firstKey () { if ( TreeBidiMap . this . nodeCount == 0 ) {
throw new NoSuchElementException ( lr_1 ) ; } return greatestNode ( TreeBidiMap . this . rootNode [ VALUE . ordinal () ] , VALUE ) . getValue () ; MST[NonVoidMethodCallMutator]MSP[S] } @Override public V nextKey ( final V key ) { checkKey ( key ) ;
final Node < K , V > node = nextGreater ( TreeBidiMap . this . <V > lookup ( key , VALUE ) , VALUE ) ; return node == null ? null : node . getValue () ; MST[rv.ROR5Mutator]MSP[S] } @Override public V previousKey ( final V key ) {
if ( inverseEntrySet == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] inverseEntrySet = new InverseEntryView () ; } return inverseEntrySet ; } @Override public OrderedMapIterator < V , K > mapIterator () { if ( isEmpty () ) { return EmptyOrderedMapIterator . <V , K > emptyOrderedMapIterator () ; }
return inverseKeySet ; } @Override public Set < K > values () { if ( inverseValuesSet == null ) { inverseValuesSet = new KeyView ( VALUE ) ; } return inverseValuesSet ; MST[EmptyObjectReturnValsMutator]MSP[N] } @Override public Set < Map . Entry < V , K > > entrySet () {
return inverseKeySet ; } @Override public Set < K > values () { if ( inverseValuesSet == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] inverseValuesSet = new KeyView ( VALUE ) ; } return inverseValuesSet ; } @Override public Set < Map . Entry < V , K > > entrySet () {
throw new NoSuchElementException ( lr_1 ) ; } return leastNode ( TreeBidiMap . this . rootNode [ VALUE . ordinal () ] , VALUE ) . getValue () ; } @Override public V lastKey () { if ( TreeBidiMap . this . nodeCount == 0 ) { MST[NonVoidMethodCallMutator]MSP[S]
return inverseKeySet ; } @Override public Set < K > values () { if ( inverseValuesSet == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] inverseValuesSet = new KeyView ( VALUE ) ; } return inverseValuesSet ; } @Override public Set < Map . Entry < V , K > > entrySet () {
return TreeBidiMap . this . getKey ( key ) ; MST[NonVoidMethodCallMutator]MSP[S] } @Override public V getKey ( final Object value ) { return TreeBidiMap . this . get ( value ) ; } @Override public boolean containsKey ( final Object key ) {
return TreeBidiMap . this . containsValue ( key ) ; } @Override public boolean containsValue ( final Object value ) { return TreeBidiMap . this . containsKey ( value ) ; } @Override public V firstKey () { if ( TreeBidiMap . this . nodeCount == 0 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S]
return inverseKeySet ; } @Override public Set < K > values () { if ( inverseValuesSet == null ) { MST[rv.ROR5Mutator]MSP[S] inverseValuesSet = new KeyView ( VALUE ) ; } return inverseValuesSet ; } @Override public Set < Map . Entry < V , K > > entrySet () {
return TreeBidiMap . this . containsValue ( key ) ; } @Override public boolean containsValue ( final Object value ) { return TreeBidiMap . this . containsKey ( value ) ; MST[NonVoidMethodCallMutator]MSP[S] } @Override public V firstKey () { if ( TreeBidiMap . this . nodeCount == 0 ) {
return TreeBidiMap . this . containsValue ( key ) ; } @Override public boolean containsValue ( final Object value ) { return TreeBidiMap . this . containsKey ( value ) ; } @Override public V firstKey () { if ( TreeBidiMap . this . nodeCount == 0 ) { MST[NegateConditionalsMutator]MSP[S]
return TreeBidiMap . this . containsValue ( key ) ; } @Override public boolean containsValue ( final Object value ) { return TreeBidiMap . this . containsKey ( value ) ; } @Override public V firstKey () { if ( TreeBidiMap . this . nodeCount == 0 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
put ( e . getKey () , e . getValue () ) ; MST[ArgumentPropagationMutator]MSP[S] } } @Override public K remove ( final Object key ) { return TreeBidiMap . this . removeValue ( key ) ; } @Override public V removeValue ( final Object value ) {
final Node < K , V > node = nextGreater ( TreeBidiMap . this . <V > lookup ( key , VALUE ) , VALUE ) ; return node == null ? null : node . getValue () ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } @Override public V previousKey ( final V key ) {
return new InverseViewMapIterator ( VALUE ) ; } @Override public OrderedBidiMap < K , V > inverseBidiMap () { return TreeBidiMap . this ; } @Override public boolean equals ( final Object obj ) { return TreeBidiMap . this . doEquals ( obj , DataElement . VALUE ) ; MST[NonVoidMethodCallMutator]MSP[N] }
final Node < K , V > node = nextGreater ( TreeBidiMap . this . <V > lookup ( key , VALUE ) , VALUE ) ; return node == null ? null : node . getValue () ; MST[NullReturnValsMutator]MSP[N] } @Override public V previousKey ( final V key ) {
calculatedHashCode = true ; } return hashcodeValue ; } @Override public int size () { return TreeBidiMap . this . size () ; MST[PrimitiveReturnsMutator]MSP[N] } @Override public boolean isEmpty () { return TreeBidiMap . this . isEmpty () ; } @Override public K get ( final Object key ) {
throw new NoSuchElementException ( lr_1 ) ; } return greatestNode ( TreeBidiMap . this . rootNode [ VALUE . ordinal () ] , VALUE ) . getValue () ; MST[NonVoidMethodCallMutator]MSP[S] } @Override public V nextKey ( final V key ) { checkKey ( key ) ;
final Node < K , V > node = nextGreater ( TreeBidiMap . this . <V > lookup ( key , VALUE ) , VALUE ) ; MST[ArgumentPropagationMutator]MSP[N] return node == null ? null : node . getValue () ; } @Override public V previousKey ( final V key ) {
put ( e . getKey () , e . getValue () ) ; MST[NonVoidMethodCallMutator]MSP[S] } } @Override public K remove ( final Object key ) { return TreeBidiMap . this . removeValue ( key ) ; } @Override public V removeValue ( final Object value ) {
final Node < K , V > node = nextGreater ( TreeBidiMap . this . <V > lookup ( key , VALUE ) , VALUE ) ; MST[NonVoidMethodCallMutator]MSP[N] return node == null ? null : node . getValue () ; } @Override public V previousKey ( final V key ) {
if ( inverseEntrySet == null ) { MST[rv.ROR5Mutator]MSP[S] inverseEntrySet = new InverseEntryView () ; } return inverseEntrySet ; } @Override public OrderedMapIterator < V , K > mapIterator () { if ( isEmpty () ) { return EmptyOrderedMapIterator . <V , K > emptyOrderedMapIterator () ; }
calculatedHashCode = true ; } return hashcodeValue ; } @Override public int size () { return TreeBidiMap . this . size () ; MST[NonVoidMethodCallMutator]MSP[N] } @Override public boolean isEmpty () { return TreeBidiMap . this . isEmpty () ; } @Override public K get ( final Object key ) {
return TreeBidiMap . this . containsValue ( key ) ; MST[NonVoidMethodCallMutator]MSP[N] } @Override public boolean containsValue ( final Object value ) { return TreeBidiMap . this . containsKey ( value ) ; } @Override public V firstKey () { if ( TreeBidiMap . this . nodeCount == 0 ) {
return TreeBidiMap . this . containsValue ( key ) ; } @Override public boolean containsValue ( final Object value ) { return TreeBidiMap . this . containsKey ( value ) ; } @Override public V firstKey () { if ( TreeBidiMap . this . nodeCount == 0 ) { MST[rv.ROR1Mutator]MSP[N]
return TreeBidiMap . this . containsValue ( key ) ; } @Override public boolean containsValue ( final Object value ) { return TreeBidiMap . this . containsKey ( value ) ; } @Override public V firstKey () { if ( TreeBidiMap . this . nodeCount == 0 ) { MST[rv.ROR2Mutator]MSP[S]
return TreeBidiMap . this . containsValue ( key ) ; } @Override public boolean containsValue ( final Object value ) { return TreeBidiMap . this . containsKey ( value ) ; } @Override public V firstKey () { if ( TreeBidiMap . this . nodeCount == 0 ) { MST[NonVoidMethodCallMutator]MSP[N]
return inverseKeySet ; } @Override public Set < K > values () { if ( inverseValuesSet == null ) { inverseValuesSet = new KeyView ( VALUE ) ; } return inverseValuesSet ; MST[ReturnValsMutator]MSP[S] } @Override public Set < Map . Entry < V , K > > entrySet () {
return TreeBidiMap . this . containsValue ( key ) ; MST[BooleanTrueReturnValsMutator]MSP[S] } @Override public boolean containsValue ( final Object value ) { return TreeBidiMap . this . containsKey ( value ) ; } @Override public V firstKey () { if ( TreeBidiMap . this . nodeCount == 0 ) {
@Override public int hashCode () { return TreeBidiMap . this . doHashCode ( DataElement . VALUE ) ; } @Override public String toString () { return TreeBidiMap . this . doToString ( DataElement . VALUE ) ; MST[ReturnValsMutator]MSP[N] }
return inverseKeySet ; } @Override public Set < K > values () { if ( inverseValuesSet == null ) { MST[NegateConditionalsMutator]MSP[S] inverseValuesSet = new KeyView ( VALUE ) ; } return inverseValuesSet ; } @Override public Set < Map . Entry < V , K > > entrySet () {
if ( inverseEntrySet == null ) { inverseEntrySet = new InverseEntryView () ; } return inverseEntrySet ; MST[EmptyObjectReturnValsMutator]MSP[N] } @Override public OrderedMapIterator < V , K > mapIterator () { if ( isEmpty () ) { return EmptyOrderedMapIterator . <V , K > emptyOrderedMapIterator () ; }
return new InverseViewMapIterator ( VALUE ) ; } @Override public OrderedBidiMap < K , V > inverseBidiMap () { return TreeBidiMap . this ; MST[NullReturnValsMutator]MSP[S] } @Override public boolean equals ( final Object obj ) { return TreeBidiMap . this . doEquals ( obj , DataElement . VALUE ) ; }
public K put ( final V key , final K value ) { final K result = get ( key ) ; TreeBidiMap . this . doPut ( value , key ) ; return result ; MST[NullReturnValsMutator]MSP[N] } @Override
return inverseKeySet ; } @Override public Set < K > values () { if ( inverseValuesSet == null ) { inverseValuesSet = new KeyView ( VALUE ) ; MST[experimental.MemberVariableMutator]MSP[S] } return inverseValuesSet ; } @Override public Set < Map . Entry < V , K > > entrySet () {
final Node < K , V > node = nextGreater ( TreeBidiMap . this . <V > lookup ( key , VALUE ) , VALUE ) ; return node == null ? null : node . getValue () ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] } @Override public V previousKey ( final V key ) {
public void putAll ( final Map < ? extends V , ? extends K > map ) { for ( final Map . Entry < ? extends V , ? extends K > e : map . entrySet () ) { MST[NonVoidMethodCallMutator]MSP[S]
return TreeBidiMap . this . getKey ( key ) ; MST[NullReturnValsMutator]MSP[N] } @Override public V getKey ( final Object value ) { return TreeBidiMap . this . get ( value ) ; } @Override public boolean containsKey ( final Object key ) {
throw new NoSuchElementException ( lr_1 ) ; } return leastNode ( TreeBidiMap . this . rootNode [ VALUE . ordinal () ] , VALUE ) . getValue () ; } @Override public V lastKey () { if ( TreeBidiMap . this . nodeCount == 0 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S]
return new InverseViewMapIterator ( VALUE ) ; } @Override public OrderedBidiMap < K , V > inverseBidiMap () { return TreeBidiMap . this ; } @Override public boolean equals ( final Object obj ) { return TreeBidiMap . this . doEquals ( obj , DataElement . VALUE ) ; MST[BooleanFalseReturnValsMutator]MSP[N] }
public K put ( final V key , final K value ) { final K result = get ( key ) ; TreeBidiMap . this . doPut ( value , key ) ; MST[VoidMethodCallMutator]MSP[S] return result ; } @Override
throw new NoSuchElementException ( lr_1 ) ; } return greatestNode ( TreeBidiMap . this . rootNode [ VALUE . ordinal () ] , VALUE ) . getValue () ; MST[NonVoidMethodCallMutator]MSP[N] } @Override public V nextKey ( final V key ) { checkKey ( key ) ;
calculatedHashCode = true ; } return hashcodeValue ; } @Override public int size () { return TreeBidiMap . this . size () ; } @Override public boolean isEmpty () { return TreeBidiMap . this . isEmpty () ; MST[BooleanTrueReturnValsMutator]MSP[N] } @Override public K get ( final Object key ) {
throw new NoSuchElementException ( lr_1 ) ; } return greatestNode ( TreeBidiMap . this . rootNode [ VALUE . ordinal () ] , VALUE ) . getValue () ; MST[NonVoidMethodCallMutator]MSP[N] } @Override public V nextKey ( final V key ) { checkKey ( key ) ;
throw new NoSuchElementException ( lr_1 ) ; MST[ConstructorCallMutator]MSP[S] } return greatestNode ( TreeBidiMap . this . rootNode [ VALUE . ordinal () ] , VALUE ) . getValue () ; } @Override public V nextKey ( final V key ) { checkKey ( key ) ;
put ( e . getKey () , e . getValue () ) ; MST[NonVoidMethodCallMutator]MSP[S] } } @Override public K remove ( final Object key ) { return TreeBidiMap . this . removeValue ( key ) ; } @Override public V removeValue ( final Object value ) {
calculatedHashCode = true ; } return hashcodeValue ; } @Override public int size () { return TreeBidiMap . this . size () ; } @Override public boolean isEmpty () { return TreeBidiMap . this . isEmpty () ; MST[NonVoidMethodCallMutator]MSP[N] } @Override public K get ( final Object key ) {
if ( inverseEntrySet == null ) { inverseEntrySet = new InverseEntryView () ; MST[ConstructorCallMutator]MSP[S] } return inverseEntrySet ; } @Override public OrderedMapIterator < V , K > mapIterator () { if ( isEmpty () ) { return EmptyOrderedMapIterator . <V , K > emptyOrderedMapIterator () ; }
} @Override public V getKey () { if ( lastReturnedNode == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] throw new IllegalStateException ( lr_10 ) ; } return lastReturnedNode . getValue () ; } @Override public K getValue () { if ( lastReturnedNode == null ) { throw new IllegalStateException ( lr_11 ) ; }
} @Override public V getKey () { if ( lastReturnedNode == null ) { throw new IllegalStateException ( lr_10 ) ; } return lastReturnedNode . getValue () ; } @Override public K getValue () { if ( lastReturnedNode == null ) { MST[NegateConditionalsMutator]MSP[S] throw new IllegalStateException ( lr_11 ) ; }
} @Override public V getKey () { if ( lastReturnedNode == null ) { MST[NegateConditionalsMutator]MSP[S] throw new IllegalStateException ( lr_10 ) ; } return lastReturnedNode . getValue () ; } @Override public K getValue () { if ( lastReturnedNode == null ) { throw new IllegalStateException ( lr_11 ) ; }
return lastReturnedNode . getKey () ; } @Override public K setValue ( final K obj ) { throw new UnsupportedOperationException () ; } @Override public V next () { return navigateNext () . getValue () ; } @Override public V previous () { return navigatePrevious () . getValue () ; MST[NonVoidMethodCallMutator]MSP[S]
return lastReturnedNode . getKey () ; } @Override public K setValue ( final K obj ) { throw new UnsupportedOperationException () ; } @Override public V next () { return navigateNext () . getValue () ; MST[ReturnValsMutator]MSP[N] } @Override public V previous () { return navigatePrevious () . getValue () ;
} @Override public V getKey () { if ( lastReturnedNode == null ) { MST[rv.ROR5Mutator]MSP[S] throw new IllegalStateException ( lr_10 ) ; } return lastReturnedNode . getValue () ; } @Override public K getValue () { if ( lastReturnedNode == null ) { throw new IllegalStateException ( lr_11 ) ; }
return lastReturnedNode . getKey () ; } @Override public K setValue ( final K obj ) { throw new UnsupportedOperationException () ; } @Override public V next () { return navigateNext () . getValue () ; MST[NullReturnValsMutator]MSP[N] } @Override public V previous () { return navigatePrevious () . getValue () ;
stream . writeObject ( entry . getKey () ) ; stream . writeObject ( entry . getValue () ) ; } } @Override public int size () { return TreeBidiMap . this . size () ; MST[NonVoidMethodCallMutator]MSP[N] } @Override public void clear () { TreeBidiMap . this . clear () ;
stream . writeObject ( entry . getKey () ) ; stream . writeObject ( entry . getValue () ) ; } } @Override public int size () { return TreeBidiMap . this . size () ; MST[PrimitiveReturnsMutator]MSP[N] } @Override public void clear () { TreeBidiMap . this . clear () ;
stream . writeObject ( entry . getKey () ) ; stream . writeObject ( entry . getValue () ) ; } } @Override public int size () { return TreeBidiMap . this . size () ; } @Override public void clear () { TreeBidiMap . this . clear () ; MST[VoidMethodCallMutator]MSP[N]
stream . writeObject ( entry . getKey () ) ; stream . writeObject ( entry . getValue () ) ; } } @Override public int size () { return TreeBidiMap . this . size () ; MST[ReturnValsMutator]MSP[N] } @Override public void clear () { TreeBidiMap . this . clear () ;
} @Override public Map . Entry < K , V > next () { return navigateNext () ; MST[NullReturnValsMutator]MSP[S] } @Override public Map . Entry < K , V > previous () { return navigatePrevious () ; } @Override public Map . Entry < V , K > next () {
} @Override public Map . Entry < K , V > next () { return navigateNext () ; MST[ReturnValsMutator]MSP[S] } @Override public Map . Entry < K , V > previous () { return navigatePrevious () ; } @Override public Map . Entry < V , K > next () {
} @Override public Map . Entry < K , V > next () { return navigateNext () ; MST[NonVoidMethodCallMutator]MSP[N] } @Override public Map . Entry < K , V > previous () { return navigatePrevious () ; } @Override public Map . Entry < V , K > next () {
final Node < K , V > y = getRightChild ( getGrandParent ( currentNode , dataElement ) , dataElement ) ; if ( isRed ( y , dataElement ) ) { makeBlack ( getParent ( currentNode , dataElement ) , dataElement ) ; makeBlack ( y , dataElement ) ; MST[VoidMethodCallMutator]MSP[N]
public K removeValue ( final Object value ) { return doRemoveValue ( value ) ; } @Override public K firstKey () { if ( nodeCount == 0 ) { MST[rv.UOI3Mutator]MSP[N] throw new NoSuchElementException ( lr_1 ) ; }
Node < K , V > currentNode = replacementNode ; while ( currentNode != rootNode [ dataElement . ordinal () ] && isBlack ( currentNode , dataElement ) ) { MST[rv.ROR4Mutator]MSP[N] if ( currentNode . isLeftChild ( dataElement ) ) {
} deletedNode . setLeft ( null , dataElement ) ; deletedNode . setRight ( null , dataElement ) ; deletedNode . setParent ( null , dataElement ) ; MST[VoidMethodCallMutator]MSP[N] if ( isBlack ( deletedNode , dataElement ) ) { doRedBlackDeleteFixup ( replacement , dataElement ) ; } } else {
rotateRight ( currentNode , dataElement ) ; } makeBlack ( getParent ( currentNode , dataElement ) , dataElement ) ; makeRed ( getGrandParent ( currentNode , dataElement ) , dataElement ) ; if ( getGrandParent ( currentNode , dataElement ) != null ) { MST[rv.ROR5Mutator]MSP[N]
node . getParent ( dataElement ) . setLeft ( rightChild , dataElement ) ; } else { node . getParent ( dataElement ) . setRight ( rightChild , dataElement ) ; } rightChild . setLeft ( node , dataElement ) ; node . setParent ( rightChild , dataElement ) ; MST[VoidMethodCallMutator]MSP[N]
for ( final DataElement dataElement : DataElement . values () ) { if ( deletedNode . getLeft ( dataElement ) != null && deletedNode . getRight ( dataElement ) != null ) { MST[ArgumentPropagationMutator]MSP[N] swapPosition ( nextGreater ( deletedNode , dataElement ) , deletedNode , dataElement ) ; }
if ( cmp == 0 ) { rval = node ; break; } node = cmp < 0 ? node . getLeft ( dataElement ) : node . getRight ( dataElement ) ; MST[NonVoidMethodCallMutator]MSP[N] } return rval ; }
if ( leftChild . getRight ( dataElement ) != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] leftChild . getRight ( dataElement ) . setParent ( node , dataElement ) ; } leftChild . setParent ( node . getParent ( dataElement ) , dataElement ) ;
} } else { final Node < K , V > y = getLeftChild ( getGrandParent ( currentNode , dataElement ) , dataElement ) ; if ( isRed ( y , dataElement ) ) { makeBlack ( getParent ( currentNode , dataElement ) , dataElement ) ; MST[VoidMethodCallMutator]MSP[N]
public boolean equals ( final Object obj ) { return this . doEquals ( obj , KEY ) ; } @Override public int hashCode () { return this . doHashCode ( KEY ) ; MST[NonVoidMethodCallMutator]MSP[N] } @Override public String toString () { return this . doToString ( KEY ) ; }
for ( final DataElement dataElement : DataElement . values () ) { MST[rv.UOI2Mutator]MSP[S] if ( deletedNode . getLeft ( dataElement ) != null && deletedNode . getRight ( dataElement ) != null ) { swapPosition ( nextGreater ( deletedNode , dataElement ) , deletedNode , dataElement ) ; }
Objects . requireNonNull ( obj , Objects . toString ( dataElement ) ) ; if ( ! ( obj instanceof Comparable ) ) { MST[NegateConditionalsMutator]MSP[N] throw new ClassCastException ( dataElement + lr_5 ) ; } } private static void checkKey ( final Object key ) {
while ( rval . getLeft ( dataElement ) != null ) { MST[rv.ROR5Mutator]MSP[N] rval = rval . getLeft ( dataElement ) ; } } return rval ; } private Node < K , V > greatestNode ( final Node < K , V > node , final DataElement dataElement ) {
makeBlack ( y , dataElement ) ; makeRed ( getGrandParent ( currentNode , dataElement ) , dataElement ) ; currentNode = getGrandParent ( currentNode , dataElement ) ; } else { if ( currentNode . isLeftChild ( dataElement ) ) { MST[rv.ROR4Mutator]MSP[N] currentNode = getParent ( currentNode , dataElement ) ;
if ( cmp == 0 ) { rval = node ; break; } node = cmp < 0 ? node . getLeft ( dataElement ) : node . getRight ( dataElement ) ; MST[rv.ROR1Mutator]MSP[N] } return rval ; }
if ( node . getParent ( dataElement ) == null ) { MST[NegateConditionalsMutator]MSP[N] rootNode [ dataElement . ordinal () ] = rightChild ; } else if ( node . getParent ( dataElement ) . getLeft ( dataElement ) == node ) {
node = node . getRight ( KEY ) ; } else { final Node < K , V > newNode = new Node <> ( key , value ) ; MST[ConstructorCallMutator]MSP[S] insertValue ( newNode ) ; node . setRight ( newNode , KEY ) ;
if ( rightChild . getLeft ( dataElement ) != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] rightChild . getLeft ( dataElement ) . setParent ( node , dataElement ) ; } rightChild . setParent ( node . getParent ( dataElement ) , dataElement ) ;
Objects . requireNonNull ( obj , Objects . toString ( dataElement ) ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( ! ( obj instanceof Comparable ) ) { throw new ClassCastException ( dataElement + lr_5 ) ; } } private static void checkKey ( final Object key ) {
@Override public String toString () { return description ; } @Override public int size () { return nodeCount ; MST[rv.UOI2Mutator]MSP[N] } @Override public boolean isEmpty () { return nodeCount == 0 ; } @Override public boolean containsKey ( final Object key ) { checkKey ( key ) ;
if ( value . equals ( other . get ( key ) ) == false ) { return false ; MST[InlineConstantMutator]MSP[N] } } } catch ( final ClassCastException ex ) { return false ; } catch ( final NullPointerException ex ) { return false ; } } return true ; }
node . getParent ( dataElement ) . setRight ( leftChild , dataElement ) ; } else { node . getParent ( dataElement ) . setLeft ( leftChild , dataElement ) ; } leftChild . setRight ( node , dataElement ) ; node . setParent ( leftChild , dataElement ) ; MST[VoidMethodCallMutator]MSP[N]
if ( node . getParent ( dataElement ) == null ) { MST[NegateConditionalsMutator]MSP[S] rootNode [ dataElement . ordinal () ] = leftChild ; } else if ( node . getParent ( dataElement ) . getRight ( dataElement ) == node ) {
} else if ( deletedNode == deletedNode . getParent ( dataElement ) . getLeft ( dataElement ) ) { MST[NonVoidMethodCallMutator]MSP[N] deletedNode . getParent ( dataElement ) . setLeft ( replacement , dataElement ) ; } else { deletedNode . getParent ( dataElement ) . setRight ( replacement , dataElement ) ;
. append ( value == this ? lr_8 : value ) ; hasNext = it . hasNext () ; if ( hasNext ) { buf . append ( lr_9 ) ; } } buf . append ( '}' ) ; MST[NonVoidMethodCallMutator]MSP[S] return buf . toString () ; }
if ( node == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return null ; } doRedBlackDelete ( node ) ; return node . getKey () ; } @SuppressWarnings ( lr_4 )
private static void makeBlack ( final Node < ? , ? > node , final DataElement dataElement ) { if ( node != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] node . setBlack ( dataElement ) ; } }
public K removeValue ( final Object value ) { return doRemoveValue ( value ) ; } @Override public K firstKey () { if ( nodeCount == 0 ) { MST[rv.ROR4Mutator]MSP[S] throw new NoSuchElementException ( lr_1 ) ; }
private Node < K , V > getGrandParent ( final Node < K , V > node , final DataElement dataElement ) { return getParent ( getParent ( node , dataElement ) , dataElement ) ; MST[NonVoidMethodCallMutator]MSP[N] }
final Map < ? , ? > other = ( Map < ? , ? > ) obj ; if ( other . size () != size () ) { return false ; MST[rv.CRCR1Mutator]MSP[N] } if ( nodeCount > 0 ) { try {
Node < K , V > parent = node . getParent ( dataElement ) ; Node < K , V > child = node ; while ( parent != null && child == parent . getRight ( dataElement ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] child = parent ;
if ( node . getParent ( dataElement ) == null ) { MST[rv.ROR5Mutator]MSP[N] rootNode [ dataElement . ordinal () ] = rightChild ; } else if ( node . getParent ( dataElement ) . getLeft ( dataElement ) == node ) {
Objects . requireNonNull ( obj , Objects . toString ( dataElement ) ) ; if ( ! ( obj instanceof Comparable ) ) { throw new ClassCastException ( dataElement + lr_5 ) ; MST[experimental.NakedReceiverMutator]MSP[N] } } private static void checkKey ( final Object key ) {
} private void modify () { modifications ++ ; } private void grow () { modify () ; nodeCount ++ ; MST[rv.AOR3Mutator]MSP[N] } private void shrink () { modify () ; nodeCount -- ; } private void insertValue ( final Node < K , V > newNode ) throws IllegalArgumentException {
return lookupKey ( key ) != null ; } @Override public boolean containsValue ( final Object value ) { checkValue ( value ) ; return lookupValue ( value ) != null ; MST[rv.CRCR1Mutator]MSP[N] } @Override public V get ( final Object key ) { checkKey ( key ) ;
. append ( value == this ? lr_8 : value ) ; hasNext = it . hasNext () ; if ( hasNext ) { MST[rv.UOI2Mutator]MSP[S] buf . append ( lr_9 ) ; } } buf . append ( '}' ) ; return buf . toString () ; }
private boolean doEquals ( final Object obj , final DataElement dataElement ) { if ( obj == this ) { return true ; } if ( obj instanceof Map == false ) { return false ; MST[rv.CRCR1Mutator]MSP[N] }
if ( nodeCount == 0 ) { return lr_7 ; } final StringBuilder buf = new StringBuilder ( nodeCount * 32 ) ; MST[rv.UOI4Mutator]MSP[S] buf . append ( '{' ) ; final MapIterator < ? , ? > it = getMapIterator ( dataElement ) ;
} private void modify () { modifications ++ ; } private void grow () { modify () ; nodeCount ++ ; MST[rv.CRCR2Mutator]MSP[N] } private void shrink () { modify () ; nodeCount -- ; } private void insertValue ( final Node < K , V > newNode ) throws IllegalArgumentException {
for ( final DataElement dataElement : DataElement . values () ) { MST[rv.ABSMutator]MSP[S] if ( deletedNode . getLeft ( dataElement ) != null && deletedNode . getRight ( dataElement ) != null ) { swapPosition ( nextGreater ( deletedNode , dataElement ) , deletedNode , dataElement ) ; }
replacement . setParent ( deletedNode . getParent ( dataElement ) , dataElement ) ; if ( deletedNode . getParent ( dataElement ) == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] rootNode [ dataElement . ordinal () ] = replacement ;
} else { while ( true ) { final int cmp = compare ( key , node . getKey () ) ; if ( cmp == 0 ) { throw new IllegalArgumentException ( lr_2 + key + lr_3 ) ; } else if ( cmp < 0 ) { MST[rv.UOI4Mutator]MSP[N]
Objects . requireNonNull ( obj , Objects . toString ( dataElement ) ) ; if ( ! ( obj instanceof Comparable ) ) { MST[rv.ROR5Mutator]MSP[N] throw new ClassCastException ( dataElement + lr_5 ) ; } } private static void checkKey ( final Object key ) {
if ( node == null ) { return null ; } doRedBlackDelete ( node ) ; return node . getValue () ; MST[ReturnValsMutator]MSP[N] } private K doRemoveValue ( final Object value ) { final Node < K , V > node = lookupValue ( value ) ;
private int doHashCode ( final DataElement dataElement ) { int total = 0 ; if ( nodeCount > 0 ) { MST[rv.ROR1Mutator]MSP[N] for ( final MapIterator < ? , ? > it = getMapIterator ( dataElement ) ; it . hasNext () ; ) {
replacement . setParent ( deletedNode . getParent ( dataElement ) , dataElement ) ; if ( deletedNode . getParent ( dataElement ) == null ) { MST[NonVoidMethodCallMutator]MSP[N] rootNode [ dataElement . ordinal () ] = replacement ;
makeBlack ( y , dataElement ) ; makeRed ( getGrandParent ( currentNode , dataElement ) , dataElement ) ; MST[NonVoidMethodCallMutator]MSP[N] currentNode = getGrandParent ( currentNode , dataElement ) ; } else { if ( currentNode . isLeftChild ( dataElement ) ) { currentNode = getParent ( currentNode , dataElement ) ;
private int doHashCode ( final DataElement dataElement ) { int total = 0 ; if ( nodeCount > 0 ) { for ( final MapIterator < ? , ? > it = getMapIterator ( dataElement ) ; it . hasNext () ; ) { MST[NonVoidMethodCallMutator]MSP[S]
if ( value . equals ( other . get ( key ) ) == false ) { MST[rv.ROR2Mutator]MSP[N] return false ; } } } catch ( final ClassCastException ex ) { return false ; } catch ( final NullPointerException ex ) { return false ; } } return true ; }
} else { while ( true ) { final int cmp = compare ( key , node . getKey () ) ; if ( cmp == 0 ) { throw new IllegalArgumentException ( lr_2 + key + lr_3 ) ; } else if ( cmp < 0 ) { MST[rv.UOI1Mutator]MSP[N]
} else { to . copyColor ( from , dataElement ) ; } } } private static boolean isRed ( final Node < ? , ? > node , final DataElement dataElement ) { return node != null && node . isRed ( dataElement ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] }
&& currentNode != rootNode [ dataElement . ordinal () ] && isRed ( currentNode . getParent ( dataElement ) , dataElement ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] if ( currentNode . isLeftChild ( dataElement ) ) {
boolean hasNext = it . hasNext () ; while ( hasNext ) { final Object key = it . next () ; final Object value = it . getValue () ; buf . append ( key == this ? lr_8 : key ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] . append ( '=' )
keySet = new KeyView ( KEY ) ; MST[ConstructorCallMutator]MSP[S] } return keySet ; } @Override public Set < V > values () { if ( valuesSet == null ) { valuesSet = new ValueView ( KEY ) ; } return valuesSet ; } @Override
return lookupKey ( key ) != null ; MST[rv.CRCR6Mutator]MSP[N] } @Override public boolean containsValue ( final Object value ) { checkValue ( value ) ; return lookupValue ( value ) != null ; } @Override public V get ( final Object key ) { checkKey ( key ) ;
. append ( value == this ? lr_8 : value ) ; hasNext = it . hasNext () ; if ( hasNext ) { MST[rv.ABSMutator]MSP[N] buf . append ( lr_9 ) ; } } buf . append ( '}' ) ; return buf . toString () ; }
makeBlack ( getLeftChild ( siblingNode , dataElement ) , dataElement ) ; rotateRight ( getParent ( currentNode , dataElement ) , dataElement ) ; currentNode = rootNode [ dataElement . ordinal () ] ; } } } makeBlack ( currentNode , dataElement ) ; MST[VoidMethodCallMutator]MSP[N] }
} private void modify () { modifications ++ ; MST[rv.CRCR3Mutator]MSP[N] } private void grow () { modify () ; nodeCount ++ ; } private void shrink () { modify () ; nodeCount -- ; } private void insertValue ( final Node < K , V > newNode ) throws IllegalArgumentException {
. append ( value == this ? lr_8 : value ) ; hasNext = it . hasNext () ; if ( hasNext ) { buf . append ( lr_9 ) ; } } buf . append ( '}' ) ; MST[rv.CRCR2Mutator]MSP[S] return buf . toString () ; }
public K getKey ( final Object value ) { checkValue ( value ) ; MST[VoidMethodCallMutator]MSP[N] final Node < K , V > node = lookupValue ( value ) ; return node == null ? null : node . getKey () ; } @Override
&& currentNode != rootNode [ dataElement . ordinal () ] && isRed ( currentNode . getParent ( dataElement ) , dataElement ) ) { if ( currentNode . isLeftChild ( dataElement ) ) { MST[rv.ROR2Mutator]MSP[N]
private int doHashCode ( final DataElement dataElement ) { int total = 0 ; MST[rv.CRCR3Mutator]MSP[N] if ( nodeCount > 0 ) { for ( final MapIterator < ? , ? > it = getMapIterator ( dataElement ) ; it . hasNext () ; ) {
&& currentNode != rootNode [ dataElement . ordinal () ] && isRed ( currentNode . getParent ( dataElement ) , dataElement ) ) { if ( currentNode . isLeftChild ( dataElement ) ) { MST[rv.ROR5Mutator]MSP[N]
} else { to . copyColor ( from , dataElement ) ; } } } private static boolean isRed ( final Node < ? , ? > node , final DataElement dataElement ) { return node != null && node . isRed ( dataElement ) ; MST[BooleanTrueReturnValsMutator]MSP[N] }
if ( cmp == 0 ) { rval = node ; break; } node = cmp < 0 ? node . getLeft ( dataElement ) : node . getRight ( dataElement ) ; } return rval ; MST[NullReturnValsMutator]MSP[N] }
rotateRight ( currentNode , dataElement ) ; } makeBlack ( getParent ( currentNode , dataElement ) , dataElement ) ; makeRed ( getGrandParent ( currentNode , dataElement ) , dataElement ) ; if ( getGrandParent ( currentNode , dataElement ) != null ) { MST[NegateConditionalsMutator]MSP[N]
} private void modify () { modifications ++ ; MST[rv.AOR4Mutator]MSP[N] } private void grow () { modify () ; nodeCount ++ ; } private void shrink () { modify () ; nodeCount -- ; } private void insertValue ( final Node < K , V > newNode ) throws IllegalArgumentException {
} private void modify () { modifications ++ ; MST[rv.AOR1Mutator]MSP[N] } private void grow () { modify () ; nodeCount ++ ; } private void shrink () { modify () ; nodeCount -- ; } private void insertValue ( final Node < K , V > newNode ) throws IllegalArgumentException {
return leastNode ( rootNode [ KEY . ordinal () ] , KEY ) . getKey () ; MST[NullReturnValsMutator]MSP[N] } @Override public K lastKey () { if ( nodeCount == 0 ) { throw new NoSuchElementException ( lr_1 ) ; }
lr_6 + newNode . getData ( VALUE ) + lr_3 ) ; } else if ( cmp < 0 ) { MST[NegateConditionalsMutator]MSP[S] if ( node . getLeft ( VALUE ) != null ) { node = node . getLeft ( VALUE ) ; } else {
} else { while ( true ) { final int cmp = compare ( key , node . getKey () ) ; if ( cmp == 0 ) { MST[NegateConditionalsMutator]MSP[S] throw new IllegalArgumentException ( lr_2 + key + lr_3 ) ; } else if ( cmp < 0 ) {
if ( deletedNode . getParent ( dataElement ) == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] rootNode [ dataElement . ordinal () ] = null ; } else { if ( isBlack ( deletedNode , dataElement ) ) { doRedBlackDeleteFixup ( deletedNode , dataElement ) ; }
lr_6 + newNode . getData ( VALUE ) + lr_3 ) ; } else if ( cmp < 0 ) { MST[rv.UOI4Mutator]MSP[N] if ( node . getLeft ( VALUE ) != null ) { node = node . getLeft ( VALUE ) ; } else {
if ( rightChild . getLeft ( dataElement ) != null ) { MST[NonVoidMethodCallMutator]MSP[N] rightChild . getLeft ( dataElement ) . setParent ( node , dataElement ) ; } rightChild . setParent ( node . getParent ( dataElement ) , dataElement ) ;
return greatestNode ( rootNode [ KEY . ordinal () ] , KEY ) . getKey () ; MST[NonVoidMethodCallMutator]MSP[S] } @Override public K nextKey ( final K key ) { checkKey ( key ) ;
&& currentNode != rootNode [ dataElement . ordinal () ] MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] && isRed ( currentNode . getParent ( dataElement ) , dataElement ) ) { if ( currentNode . isLeftChild ( dataElement ) ) {
parent = parent . getParent ( dataElement ) ; MST[ArgumentPropagationMutator]MSP[N] } rval = parent ; } return rval ; } private Node < K , V > nextSmaller ( final Node < K , V > node , final DataElement dataElement ) { Node < K , V > rval ;
if ( node . getParent ( dataElement ) == null ) { MST[rv.ROR5Mutator]MSP[S] rootNode [ dataElement . ordinal () ] = leftChild ; } else if ( node . getParent ( dataElement ) . getRight ( dataElement ) == node ) {
final Node < K , V > node = nextGreater ( lookupKey ( key ) , KEY ) ; MST[ArgumentPropagationMutator]MSP[S] return node == null ? null : node . getKey () ; } @Override public K previousKey ( final K key ) { checkKey ( key ) ;
while ( rval . getLeft ( dataElement ) != null ) { MST[NegateConditionalsMutator]MSP[N] rval = rval . getLeft ( dataElement ) ; } } return rval ; } private Node < K , V > greatestNode ( final Node < K , V > node , final DataElement dataElement ) {
final Node < K , V > node = lookupKey ( key ) ; return node == null ? null : node . getValue () ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] } @Override public V put ( final K key , final V value ) { final V result = get ( key ) ;
final Object key = it . next () ; final Object value = it . getValue () ; total += key . hashCode () ^ value . hashCode () ; } } return total ; MST[ReturnValsMutator]MSP[N] } private String doToString ( final DataElement dataElement ) {
private Node < K , V > getGrandParent ( final Node < K , V > node , final DataElement dataElement ) { return getParent ( getParent ( node , dataElement ) , dataElement ) ; MST[NullReturnValsMutator]MSP[N] }
&& currentNode != rootNode [ dataElement . ordinal () ] && isRed ( currentNode . getParent ( dataElement ) , dataElement ) ) { if ( currentNode . isLeftChild ( dataElement ) ) { MST[NegateConditionalsMutator]MSP[N]
for ( final MapIterator < ? , ? > it = getMapIterator ( dataElement ) ; it . hasNext () ; ) { MST[rv.ROR3Mutator]MSP[N] final Object key = it . next () ; final Object value = it . getValue () ;
boolean hasNext = it . hasNext () ; while ( hasNext ) { MST[rv.UOI1Mutator]MSP[N] final Object key = it . next () ; final Object value = it . getValue () ; buf . append ( key == this ? lr_8 : key ) . append ( '=' )
} else if ( deletedNode == deletedNode . getParent ( dataElement ) . getLeft ( dataElement ) ) { MST[NegateConditionalsMutator]MSP[S] deletedNode . getParent ( dataElement ) . setLeft ( replacement , dataElement ) ; } else { deletedNode . getParent ( dataElement ) . setRight ( replacement , dataElement ) ;
rotateRight ( currentNode , dataElement ) ; } makeBlack ( getParent ( currentNode , dataElement ) , dataElement ) ; makeRed ( getGrandParent ( currentNode , dataElement ) , dataElement ) ; MST[ArgumentPropagationMutator]MSP[N] if ( getGrandParent ( currentNode , dataElement ) != null ) {
Node < K , V > currentNode = replacementNode ; while ( currentNode != rootNode [ dataElement . ordinal () ] && isBlack ( currentNode , dataElement ) ) { MST[rv.ROR1Mutator]MSP[N] if ( currentNode . isLeftChild ( dataElement ) ) {
} else { while ( true ) { final int cmp = compare ( key , node . getKey () ) ; if ( cmp == 0 ) { throw new IllegalArgumentException ( lr_2 + key + lr_3 ) ; } else if ( cmp < 0 ) { MST[NegateConditionalsMutator]MSP[N]
private static boolean isBlack ( final Node < ? , ? > node , final DataElement dataElement ) { return node == null || node . isBlack ( dataElement ) ; MST[rv.CRCR2Mutator]MSP[N] }
. append ( value == this ? lr_8 : value ) ; hasNext = it . hasNext () ; MST[NonVoidMethodCallMutator]MSP[N] if ( hasNext ) { buf . append ( lr_9 ) ; } } buf . append ( '}' ) ; return buf . toString () ; }
} else { to . copyColor ( from , dataElement ) ; } } } private static boolean isRed ( final Node < ? , ? > node , final DataElement dataElement ) { return node != null && node . isRed ( dataElement ) ; MST[ReturnValsMutator]MSP[N] }
final Node < K , V > replacement = deletedNode . getLeft ( dataElement ) != null ? deletedNode . getLeft ( dataElement ) : deletedNode . getRight ( dataElement ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( replacement != null ) {
if ( node == null ) { MST[rv.ROR5Mutator]MSP[S] final Node < K , V > root = new Node <> ( key , value ) ; rootNode [ KEY . ordinal () ] = root ; rootNode [ VALUE . ordinal () ] = root ; grow () ;
public K removeValue ( final Object value ) { return doRemoveValue ( value ) ; MST[ReturnValsMutator]MSP[S] } @Override public K firstKey () { if ( nodeCount == 0 ) { throw new NoSuchElementException ( lr_1 ) ; }
@Override public String toString () { return description ; } @Override public int size () { return nodeCount ; } @Override public boolean isEmpty () { return nodeCount == 0 ; MST[rv.ROR1Mutator]MSP[N] } @Override public boolean containsKey ( final Object key ) { checkKey ( key ) ;
if ( deletedNode . getParent ( dataElement ) == null ) { rootNode [ dataElement . ordinal () ] = null ; } else { if ( isBlack ( deletedNode , dataElement ) ) { MST[rv.ROR1Mutator]MSP[N] doRedBlackDeleteFixup ( deletedNode , dataElement ) ; }
public boolean equals ( final Object obj ) { return this . doEquals ( obj , KEY ) ; MST[BooleanFalseReturnValsMutator]MSP[N] } @Override public int hashCode () { return this . doHashCode ( KEY ) ; } @Override public String toString () { return this . doToString ( KEY ) ; }
final Node < K , V > y = getRightChild ( getGrandParent ( currentNode , dataElement ) , dataElement ) ; if ( isRed ( y , dataElement ) ) { MST[rv.ROR3Mutator]MSP[S] makeBlack ( getParent ( currentNode , dataElement ) , dataElement ) ; makeBlack ( y , dataElement ) ;
final Node < K , V > node = lookupKey ( key ) ; MST[NonVoidMethodCallMutator]MSP[N] return node == null ? null : node . getValue () ; } @Override public V put ( final K key , final V value ) { final V result = get ( key ) ;
if ( node == null ) { MST[NegateConditionalsMutator]MSP[S] return null ; } doRedBlackDelete ( node ) ; return node . getValue () ; } private K doRemoveValue ( final Object value ) { final Node < K , V > node = lookupValue ( value ) ;
if ( node . getParent ( dataElement ) == null ) { rootNode [ dataElement . ordinal () ] = rightChild ; MST[NonVoidMethodCallMutator]MSP[N] } else if ( node . getParent ( dataElement ) . getLeft ( dataElement ) == node ) {
} else if ( deletedNode == deletedNode . getParent ( dataElement ) . getLeft ( dataElement ) ) { MST[rv.ROR5Mutator]MSP[S] deletedNode . getParent ( dataElement ) . setLeft ( replacement , dataElement ) ; } else { deletedNode . getParent ( dataElement ) . setRight ( replacement , dataElement ) ;
final Map < ? , ? > other = ( Map < ? , ? > ) obj ; if ( other . size () != size () ) { return false ; } if ( nodeCount > 0 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] try {
if ( node == null ) { MST[NegateConditionalsMutator]MSP[S] final Node < K , V > root = new Node <> ( key , value ) ; rootNode [ KEY . ordinal () ] = root ; rootNode [ VALUE . ordinal () ] = root ; grow () ;
public Set < Map . Entry < K , V > > entrySet () { if ( entrySet == null ) { entrySet = new EntryView () ; } return entrySet ; } @Override public OrderedMapIterator < K , V > mapIterator () { if ( isEmpty () ) { MST[rv.ROR1Mutator]MSP[N]
private int doHashCode ( final DataElement dataElement ) { int total = 0 ; if ( nodeCount > 0 ) { MST[rv.UOI3Mutator]MSP[N] for ( final MapIterator < ? , ? > it = getMapIterator ( dataElement ) ; it . hasNext () ; ) {
} private void modify () { modifications ++ ; } private void grow () { modify () ; nodeCount ++ ; } private void shrink () { modify () ; nodeCount -- ; MST[rv.AOR4Mutator]MSP[N] } private void insertValue ( final Node < K , V > newNode ) throws IllegalArgumentException {
return lookupKey ( key ) != null ; MST[rv.CRCR3Mutator]MSP[N] } @Override public boolean containsValue ( final Object value ) { checkValue ( value ) ; return lookupValue ( value ) != null ; } @Override public V get ( final Object key ) { checkKey ( key ) ;
private static void makeBlack ( final Node < ? , ? > node , final DataElement dataElement ) { if ( node != null ) { node . setBlack ( dataElement ) ; MST[VoidMethodCallMutator]MSP[N] } }
for ( final DataElement dataElement : DataElement . values () ) { MST[rv.ABSMutator]MSP[S] if ( deletedNode . getLeft ( dataElement ) != null && deletedNode . getRight ( dataElement ) != null ) { swapPosition ( nextGreater ( deletedNode , dataElement ) , deletedNode , dataElement ) ; }
. append ( value == this ? lr_8 : value ) ; hasNext = it . hasNext () ; if ( hasNext ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] buf . append ( lr_9 ) ; } } buf . append ( '}' ) ; return buf . toString () ; }
} else { while ( true ) { final int cmp = compare ( key , node . getKey () ) ; if ( cmp == 0 ) { throw new IllegalArgumentException ( lr_2 + key + lr_3 ) ; } else if ( cmp < 0 ) { MST[rv.ROR5Mutator]MSP[N]
final Node < K , V > replacement = deletedNode . getLeft ( dataElement ) != null ? MST[NegateConditionalsMutator]MSP[N] deletedNode . getLeft ( dataElement ) : deletedNode . getRight ( dataElement ) ; if ( replacement != null ) {
private int doHashCode ( final DataElement dataElement ) { int total = 0 ; if ( nodeCount > 0 ) { MST[rv.ROR4Mutator]MSP[N] for ( final MapIterator < ? , ? > it = getMapIterator ( dataElement ) ; it . hasNext () ; ) {
private MapIterator < ? , ? > getMapIterator ( final DataElement dataElement ) { switch ( dataElement ) { case KEY : return new ViewMapIterator ( KEY ) ; MST[ConstructorCallMutator]MSP[N] case VALUE : return new InverseViewMapIterator ( VALUE ) ; default: throw new IllegalArgumentException () ; } }
lr_6 + newNode . getData ( VALUE ) + lr_3 ) ; } else if ( cmp < 0 ) { MST[rv.ROR5Mutator]MSP[N] if ( node . getLeft ( VALUE ) != null ) { node = node . getLeft ( VALUE ) ; } else {
} makeBlack ( getParent ( currentNode , dataElement ) , dataElement ) ; MST[ArgumentPropagationMutator]MSP[N] makeRed ( getGrandParent ( currentNode , dataElement ) , dataElement ) ; if ( getGrandParent ( currentNode , dataElement ) != null ) { rotateRight ( getGrandParent ( currentNode , dataElement ) , dataElement ) ; }
return EmptyOrderedMapIterator . <K , V > emptyOrderedMapIterator () ; } return new ViewMapIterator ( KEY ) ; } @Override public OrderedBidiMap < V , K > inverseBidiMap () { if ( inverse == null ) { MST[NegateConditionalsMutator]MSP[S] inverse = new Inverse () ; } return inverse ; } @Override
if ( value . equals ( other . get ( key ) ) == false ) { return false ; } } } catch ( final ClassCastException ex ) { return false ; } catch ( final NullPointerException ex ) { return false ; } } return true ; MST[InlineConstantMutator]MSP[N] }
} private void modify () { modifications ++ ; MST[rv.AOD2Mutator]MSP[N] } private void grow () { modify () ; nodeCount ++ ; } private void shrink () { modify () ; nodeCount -- ; } private void insertValue ( final Node < K , V > newNode ) throws IllegalArgumentException {
&& currentNode != rootNode [ dataElement . ordinal () ] && isRed ( currentNode . getParent ( dataElement ) , dataElement ) ) { MST[ArgumentPropagationMutator]MSP[N] if ( currentNode . isLeftChild ( dataElement ) ) {
} else { to . copyColor ( from , dataElement ) ; } } } private static boolean isRed ( final Node < ? , ? > node , final DataElement dataElement ) { return node != null && node . isRed ( dataElement ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] }
node = node . getRight ( KEY ) ; } else { final Node < K , V > newNode = new Node <> ( key , value ) ; insertValue ( newNode ) ; MST[VoidMethodCallMutator]MSP[N] node . setRight ( newNode , KEY ) ;
final Map < ? , ? > other = ( Map < ? , ? > ) obj ; if ( other . size () != size () ) { return false ; } if ( nodeCount > 0 ) { MST[ConditionalsBoundaryMutator]MSP[N] try {
@Override public String toString () { return description ; } @Override public int size () { return nodeCount ; } @Override public boolean isEmpty () { return nodeCount == 0 ; MST[rv.UOI3Mutator]MSP[N] } @Override public boolean containsKey ( final Object key ) { checkKey ( key ) ;
private boolean doEquals ( final Object obj , final DataElement dataElement ) { if ( obj == this ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return true ; } if ( obj instanceof Map == false ) { return false ; }
if ( node == null ) { return null ; } doRedBlackDelete ( node ) ; return node . getValue () ; } private K doRemoveValue ( final Object value ) { final Node < K , V > node = lookupValue ( value ) ; MST[NonVoidMethodCallMutator]MSP[N]
if ( value . equals ( other . get ( key ) ) == false ) { MST[NegateConditionalsMutator]MSP[N] return false ; } } } catch ( final ClassCastException ex ) { return false ; } catch ( final NullPointerException ex ) { return false ; } } return true ; }
public Set < Map . Entry < K , V > > entrySet () { if ( entrySet == null ) { entrySet = new EntryView () ; } return entrySet ; MST[ReturnValsMutator]MSP[S] } @Override public OrderedMapIterator < K , V > mapIterator () { if ( isEmpty () ) {
private static void makeRed ( final Node < ? , ? > node , final DataElement dataElement ) { if ( node != null ) { node . setRed ( dataElement ) ; MST[VoidMethodCallMutator]MSP[N] } }
boolean hasNext = it . hasNext () ; while ( hasNext ) { final Object key = it . next () ; final Object value = it . getValue () ; buf . append ( key == this ? lr_8 : key ) . append ( '=' ) MST[NegateConditionalsMutator]MSP[S]
private static void makeBlack ( final Node < ? , ? > node , final DataElement dataElement ) { if ( node != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] node . setBlack ( dataElement ) ; } }
} else { to . copyColor ( from , dataElement ) ; } } } private static boolean isRed ( final Node < ? , ? > node , final DataElement dataElement ) { return node != null && node . isRed ( dataElement ) ; MST[NonVoidMethodCallMutator]MSP[N] }
if ( cmp == 0 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] rval = node ; break; } node = cmp < 0 ? node . getLeft ( dataElement ) : node . getRight ( dataElement ) ; } return rval ; }
if ( nodeCount == 0 ) { return lr_7 ; } final StringBuilder buf = new StringBuilder ( nodeCount * 32 ) ; buf . append ( '{' ) ; MST[InlineConstantMutator]MSP[S] final MapIterator < ? , ? > it = getMapIterator ( dataElement ) ;
if ( nodeCount == 0 ) { return lr_7 ; } final StringBuilder buf = new StringBuilder ( nodeCount * 32 ) ; MST[rv.CRCR6Mutator]MSP[N] buf . append ( '{' ) ; final MapIterator < ? , ? > it = getMapIterator ( dataElement ) ;
node . setLeft ( newNode , KEY ) ; MST[VoidMethodCallMutator]MSP[N] newNode . setParent ( node , KEY ) ; doRedBlackInsert ( newNode , KEY ) ; grow () ; break; } } else { if ( node . getRight ( KEY ) != null ) {
private Node < K , V > getParent ( final Node < K , V > node , final DataElement dataElement ) { return node == null ? null : node . getParent ( dataElement ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] }
@Override public String toString () { return description ; } @Override public int size () { return nodeCount ; } @Override public boolean isEmpty () { return nodeCount == 0 ; MST[rv.CRCR1Mutator]MSP[N] } @Override public boolean containsKey ( final Object key ) { checkKey ( key ) ;
public K getKey ( final Object value ) { checkValue ( value ) ; final Node < K , V > node = lookupValue ( value ) ; return node == null ? null : node . getKey () ; MST[NegateConditionalsMutator]MSP[S] } @Override
return lookupKey ( key ) != null ; } @Override public boolean containsValue ( final Object value ) { checkValue ( value ) ; MST[VoidMethodCallMutator]MSP[N] return lookupValue ( value ) != null ; } @Override public V get ( final Object key ) { checkKey ( key ) ;
} else { while ( true ) { final int cmp = compare ( key , node . getKey () ) ; if ( cmp == 0 ) { throw new IllegalArgumentException ( lr_2 + key + lr_3 ) ; } else if ( cmp < 0 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N]
lr_6 + newNode . getData ( VALUE ) + lr_3 ) ; } else if ( cmp < 0 ) { MST[ConditionalsBoundaryMutator]MSP[N] if ( node . getLeft ( VALUE ) != null ) { node = node . getLeft ( VALUE ) ; } else {
makeBlack ( y , dataElement ) ; makeRed ( getGrandParent ( currentNode , dataElement ) , dataElement ) ; currentNode = getGrandParent ( currentNode , dataElement ) ; } else { if ( currentNode . isLeftChild ( dataElement ) ) { MST[rv.ROR1Mutator]MSP[S] currentNode = getParent ( currentNode , dataElement ) ;
final Map < ? , ? > other = ( Map < ? , ? > ) obj ; if ( other . size () != size () ) { return false ; } if ( nodeCount > 0 ) { MST[rv.ROR5Mutator]MSP[N] try {
if ( nodeCount == 0 ) { return lr_7 ; } final StringBuilder buf = new StringBuilder ( nodeCount * 32 ) ; MST[rv.AOR3Mutator]MSP[N] buf . append ( '{' ) ; final MapIterator < ? , ? > it = getMapIterator ( dataElement ) ;
if ( node == null ) { final Node < K , V > root = new Node <> ( key , value ) ; rootNode [ KEY . ordinal () ] = root ; MST[NonVoidMethodCallMutator]MSP[N] rootNode [ VALUE . ordinal () ] = root ; grow () ;
private Node < K , V > lookupKey ( final Object key ) { return this . <K > lookup ( key , KEY ) ; MST[NullReturnValsMutator]MSP[N] } private Node < K , V > lookupValue ( final Object value ) {
final Map < ? , ? > other = ( Map < ? , ? > ) obj ; if ( other . size () != size () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return false ; } if ( nodeCount > 0 ) { try {
if ( node == null ) { return null ; MST[ReturnValsMutator]MSP[S] } doRedBlackDelete ( node ) ; return node . getKey () ; } @SuppressWarnings ( lr_4 )
if ( rightChild . getLeft ( dataElement ) != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] rightChild . getLeft ( dataElement ) . setParent ( node , dataElement ) ; } rightChild . setParent ( node . getParent ( dataElement ) , dataElement ) ;
if ( node == null ) { return null ; } doRedBlackDelete ( node ) ; return node . getValue () ; MST[NonVoidMethodCallMutator]MSP[N] } private K doRemoveValue ( final Object value ) { final Node < K , V > node = lookupValue ( value ) ;
if ( nodeCount == 0 ) { MST[rv.UOI3Mutator]MSP[N] return lr_7 ; } final StringBuilder buf = new StringBuilder ( nodeCount * 32 ) ; buf . append ( '{' ) ; final MapIterator < ? , ? > it = getMapIterator ( dataElement ) ;
return doRemoveKey ( key ) ; } @Override public void clear () { modify () ; nodeCount = 0 ; MST[rv.CRCR5Mutator]MSP[N] rootNode [ KEY . ordinal () ] = null ; rootNode [ VALUE . ordinal () ] = null ; } @Override
lr_6 + newNode . getData ( VALUE ) + lr_3 ) ; } else if ( cmp < 0 ) { if ( node . getLeft ( VALUE ) != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] node = node . getLeft ( VALUE ) ; } else {
for ( final DataElement dataElement : DataElement . values () ) { if ( deletedNode . getLeft ( dataElement ) != null && deletedNode . getRight ( dataElement ) != null ) { MST[rv.ROR5Mutator]MSP[S] swapPosition ( nextGreater ( deletedNode , dataElement ) , deletedNode , dataElement ) ; }
lr_6 + newNode . getData ( VALUE ) + lr_3 ) ; } else if ( cmp < 0 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[S] if ( node . getLeft ( VALUE ) != null ) { node = node . getLeft ( VALUE ) ; } else {
boolean hasNext = it . hasNext () ; while ( hasNext ) { MST[rv.UOI4Mutator]MSP[S] final Object key = it . next () ; final Object value = it . getValue () ; buf . append ( key == this ? lr_8 : key ) . append ( '=' )
if ( nodeCount == 0 ) { MST[rv.ROR4Mutator]MSP[N] return lr_7 ; } final StringBuilder buf = new StringBuilder ( nodeCount * 32 ) ; buf . append ( '{' ) ; final MapIterator < ? , ? > it = getMapIterator ( dataElement ) ;
replacement . setParent ( deletedNode . getParent ( dataElement ) , dataElement ) ; if ( deletedNode . getParent ( dataElement ) == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] rootNode [ dataElement . ordinal () ] = replacement ;
} private void modify () { modifications ++ ; } private void grow () { modify () ; nodeCount ++ ; } private void shrink () { modify () ; nodeCount -- ; MST[rv.ABSMutator]MSP[N] } private void insertValue ( final Node < K , V > newNode ) throws IllegalArgumentException {
Node < K , V > rval = node ; if ( rval != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] while ( rval . getRight ( dataElement ) != null ) { rval = rval . getRight ( dataElement ) ; } } return rval ; }
Node < K , V > node = rootNode [ dataElement . ordinal () ] ; while ( node != null ) { MST[rv.ROR5Mutator]MSP[S] final int cmp = compare ( ( T ) data , ( T ) node . getData ( dataElement ) ) ;
if ( nodeCount == 0 ) { return lr_7 ; } final StringBuilder buf = new StringBuilder ( nodeCount * 32 ) ; MST[rv.AOD1Mutator]MSP[N] buf . append ( '{' ) ; final MapIterator < ? , ? > it = getMapIterator ( dataElement ) ;
boolean hasNext = it . hasNext () ; while ( hasNext ) { final Object key = it . next () ; final Object value = it . getValue () ; buf . append ( key == this ? lr_8 : key ) MST[InlineConstantMutator]MSP[S] . append ( '=' )
return EmptyOrderedMapIterator . <K , V > emptyOrderedMapIterator () ; } return new ViewMapIterator ( KEY ) ; } @Override public OrderedBidiMap < V , K > inverseBidiMap () { if ( inverse == null ) { MST[rv.ROR5Mutator]MSP[S] inverse = new Inverse () ; } return inverse ; } @Override
for ( final DataElement dataElement : DataElement . values () ) { if ( deletedNode . getLeft ( dataElement ) != null && deletedNode . getRight ( dataElement ) != null ) { MST[NegateConditionalsMutator]MSP[S] swapPosition ( nextGreater ( deletedNode , dataElement ) , deletedNode , dataElement ) ; }
} else { while ( true ) { final int cmp = compare ( key , node . getKey () ) ; if ( cmp == 0 ) { MST[rv.UOI1Mutator]MSP[N] throw new IllegalArgumentException ( lr_2 + key + lr_3 ) ; } else if ( cmp < 0 ) {
if ( node == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] return null ; } doRedBlackDelete ( node ) ; return node . getKey () ; } @SuppressWarnings ( lr_4 )
if ( value . equals ( other . get ( key ) ) == false ) { return false ; } } } catch ( final ClassCastException ex ) { return false ; } catch ( final NullPointerException ex ) { return false ; } } return true ; MST[rv.CRCR4Mutator]MSP[N] }
boolean hasNext = it . hasNext () ; while ( hasNext ) { MST[rv.ROR5Mutator]MSP[S] final Object key = it . next () ; final Object value = it . getValue () ; buf . append ( key == this ? lr_8 : key ) . append ( '=' )
private MapIterator < ? , ? > getMapIterator ( final DataElement dataElement ) { switch ( dataElement ) { MST[rv.UOI3Mutator]MSP[S] case KEY : return new ViewMapIterator ( KEY ) ; case VALUE : return new InverseViewMapIterator ( VALUE ) ; default: throw new IllegalArgumentException () ; } }
private Node < K , V > getParent ( final Node < K , V > node , final DataElement dataElement ) { return node == null ? null : node . getParent ( dataElement ) ; MST[NullReturnValsMutator]MSP[S] }
private static boolean isBlack ( final Node < ? , ? > node , final DataElement dataElement ) { return node == null || node . isBlack ( dataElement ) ; MST[rv.CRCR5Mutator]MSP[S] }
if ( value . equals ( other . get ( key ) ) == false ) { return false ; } } } catch ( final ClassCastException ex ) { return false ; } catch ( final NullPointerException ex ) { return false ; } } return true ; MST[BooleanFalseReturnValsMutator]MSP[N] }
Node < K , V > node = rootNode [ VALUE . ordinal () ] ; while ( true ) { final int cmp = compare ( newNode . getValue () , node . getValue () ) ; MST[NonVoidMethodCallMutator]MSP[S] if ( cmp == 0 ) { throw new IllegalArgumentException (
} else { to . copyColor ( from , dataElement ) ; } } } private static boolean isRed ( final Node < ? , ? > node , final DataElement dataElement ) { return node != null && node . isRed ( dataElement ) ; MST[rv.ROR3Mutator]MSP[S] }
final Node < K , V > node = nextGreater ( lookupKey ( key ) , KEY ) ; MST[NonVoidMethodCallMutator]MSP[S] return node == null ? null : node . getKey () ; } @Override public K previousKey ( final K key ) { checkKey ( key ) ;
makeRed ( getGrandParent ( currentNode , dataElement ) , dataElement ) ; MST[VoidMethodCallMutator]MSP[S] currentNode = getGrandParent ( currentNode , dataElement ) ; } else { if ( currentNode . isRightChild ( dataElement ) ) { currentNode = getParent ( currentNode , dataElement ) ; rotateLeft ( currentNode , dataElement ) ;
makeRed ( getGrandParent ( currentNode , dataElement ) , dataElement ) ; currentNode = getGrandParent ( currentNode , dataElement ) ; } else { if ( currentNode . isRightChild ( dataElement ) ) { MST[NegateConditionalsMutator]MSP[S] currentNode = getParent ( currentNode , dataElement ) ; rotateLeft ( currentNode , dataElement ) ;
if ( cmp == 0 ) { MST[rv.UOI3Mutator]MSP[S] rval = node ; break; } node = cmp < 0 ? node . getLeft ( dataElement ) : node . getRight ( dataElement ) ; } return rval ; }
node . setLeft ( newNode , VALUE ) ; MST[VoidMethodCallMutator]MSP[S] newNode . setParent ( node , VALUE ) ; doRedBlackInsert ( newNode , VALUE ) ; break; } } else { if ( node . getRight ( VALUE ) != null ) {
if ( cmp == 0 ) { MST[rv.ROR4Mutator]MSP[S] rval = node ; break; } node = cmp < 0 ? node . getLeft ( dataElement ) : node . getRight ( dataElement ) ; } return rval ; }
} private void modify () { modifications ++ ; MST[rv.CRCR6Mutator]MSP[S] } private void grow () { modify () ; nodeCount ++ ; } private void shrink () { modify () ; nodeCount -- ; } private void insertValue ( final Node < K , V > newNode ) throws IllegalArgumentException {
final Object key = it . next () ; final Object value = it . getValue () ; total += key . hashCode () ^ value . hashCode () ; MST[rv.UOI4Mutator]MSP[S] } } return total ; } private String doToString ( final DataElement dataElement ) {
if ( node == null ) { return null ; } doRedBlackDelete ( node ) ; return node . getKey () ; MST[NullReturnValsMutator]MSP[S] } @SuppressWarnings ( lr_4 )
makeRed ( getGrandParent ( currentNode , dataElement ) , dataElement ) ; currentNode = getGrandParent ( currentNode , dataElement ) ; } else { if ( currentNode . isRightChild ( dataElement ) ) { MST[rv.ROR1Mutator]MSP[S] currentNode = getParent ( currentNode , dataElement ) ; rotateLeft ( currentNode , dataElement ) ;
final Object key = it . next () ; final Object value = it . getValue () ; total += key . hashCode () ^ value . hashCode () ; MST[rv.AOR3Mutator]MSP[S] } } return total ; } private String doToString ( final DataElement dataElement ) {
} private void modify () { modifications ++ ; } private void grow () { modify () ; nodeCount ++ ; } private void shrink () { modify () ; nodeCount -- ; MST[rv.UOI2Mutator]MSP[S] } private void insertValue ( final Node < K , V > newNode ) throws IllegalArgumentException {
boolean hasNext = it . hasNext () ; MST[NonVoidMethodCallMutator]MSP[S] while ( hasNext ) { final Object key = it . next () ; final Object value = it . getValue () ; buf . append ( key == this ? lr_8 : key ) . append ( '=' )
final Map < ? , ? > other = ( Map < ? , ? > ) obj ; if ( other . size () != size () ) { return false ; MST[InlineConstantMutator]MSP[N] } if ( nodeCount > 0 ) { try {
public Set < Map . Entry < K , V > > entrySet () { if ( entrySet == null ) { entrySet = new EntryView () ; } return entrySet ; MST[EmptyObjectReturnValsMutator]MSP[S] } @Override public OrderedMapIterator < K , V > mapIterator () { if ( isEmpty () ) {
} else if ( deletedNode == deletedNode . getParent ( dataElement ) . getLeft ( dataElement ) ) { MST[ArgumentPropagationMutator]MSP[S] deletedNode . getParent ( dataElement ) . setLeft ( replacement , dataElement ) ; } else { deletedNode . getParent ( dataElement ) . setRight ( replacement , dataElement ) ;
boolean hasNext = it . hasNext () ; while ( hasNext ) { final Object key = it . next () ; final Object value = it . getValue () ; buf . append ( key == this ? lr_8 : key ) MST[rv.CRCR3Mutator]MSP[S] . append ( '=' )
for ( final DataElement dataElement : DataElement . values () ) { MST[NonVoidMethodCallMutator]MSP[S] if ( deletedNode . getLeft ( dataElement ) != null && deletedNode . getRight ( dataElement ) != null ) { swapPosition ( nextGreater ( deletedNode , dataElement ) , deletedNode , dataElement ) ; }
for ( final DataElement dataElement : DataElement . values () ) { if ( deletedNode . getLeft ( dataElement ) != null && deletedNode . getRight ( dataElement ) != null ) { MST[NegateConditionalsMutator]MSP[S] swapPosition ( nextGreater ( deletedNode , dataElement ) , deletedNode , dataElement ) ; }
keySet = new KeyView ( KEY ) ; } return keySet ; } @Override public Set < V > values () { if ( valuesSet == null ) { valuesSet = new ValueView ( KEY ) ; } return valuesSet ; MST[EmptyObjectReturnValsMutator]MSP[S] } @Override
Node < K , V > node = rootNode [ VALUE . ordinal () ] ; while ( true ) { final int cmp = compare ( newNode . getValue () , node . getValue () ) ; if ( cmp == 0 ) { MST[NegateConditionalsMutator]MSP[S] throw new IllegalArgumentException (
} else { to . copyColor ( from , dataElement ) ; } } } private static boolean isRed ( final Node < ? , ? > node , final DataElement dataElement ) { return node != null && node . isRed ( dataElement ) ; MST[rv.CRCR3Mutator]MSP[S] }
private boolean doEquals ( final Object obj , final DataElement dataElement ) { if ( obj == this ) { return true ; } if ( obj instanceof Map == false ) { return false ; MST[InlineConstantMutator]MSP[N] }
} else { to . copyColor ( from , dataElement ) ; } } } private static boolean isRed ( final Node < ? , ? > node , final DataElement dataElement ) { return node != null && node . isRed ( dataElement ) ; MST[rv.CRCR6Mutator]MSP[S] }
return leastNode ( rootNode [ KEY . ordinal () ] , KEY ) . getKey () ; } @Override public K lastKey () { if ( nodeCount == 0 ) { MST[NegateConditionalsMutator]MSP[S] throw new NoSuchElementException ( lr_1 ) ; }
} private void doRedBlackInsert ( final Node < K , V > insertedNode , final DataElement dataElement ) { Node < K , V > currentNode = insertedNode ; makeRed ( currentNode , dataElement ) ; while ( currentNode != null MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S]
final Node < K , V > replacement = deletedNode . getLeft ( dataElement ) != null ? MST[rv.ROR5Mutator]MSP[S] deletedNode . getLeft ( dataElement ) : deletedNode . getRight ( dataElement ) ; if ( replacement != null ) {
&& currentNode != rootNode [ dataElement . ordinal () ] && isRed ( currentNode . getParent ( dataElement ) , dataElement ) ) { MST[rv.ROR3Mutator]MSP[S] if ( currentNode . isLeftChild ( dataElement ) ) {
return lookupKey ( key ) != null ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] } @Override public boolean containsValue ( final Object value ) { checkValue ( value ) ; return lookupValue ( value ) != null ; } @Override public V get ( final Object key ) { checkKey ( key ) ;
Node < K , V > node = rootNode [ VALUE . ordinal () ] ; while ( true ) { final int cmp = compare ( newNode . getValue () , node . getValue () ) ; if ( cmp == 0 ) { MST[rv.UOI4Mutator]MSP[S] throw new IllegalArgumentException (
newNode . setParent ( node , KEY ) ; doRedBlackInsert ( newNode , KEY ) ; grow () ; MST[VoidMethodCallMutator]MSP[S] break; } } } } } private V doRemoveKey ( final Object key ) { final Node < K , V > node = lookupKey ( key ) ;
private Node < K , V > getRightChild ( final Node < K , V > node , final DataElement dataElement ) { return node == null ? null : node . getRight ( dataElement ) ; MST[NegateConditionalsMutator]MSP[S] }
. append ( value == this ? lr_8 : value ) ; hasNext = it . hasNext () ; if ( hasNext ) { buf . append ( lr_9 ) ; } } buf . append ( '}' ) ; return buf . toString () ; MST[EmptyObjectReturnValsMutator]MSP[S] }
if ( nodeCount == 0 ) { return lr_7 ; } final StringBuilder buf = new StringBuilder ( nodeCount * 32 ) ; MST[rv.CRCR2Mutator]MSP[S] buf . append ( '{' ) ; final MapIterator < ? , ? > it = getMapIterator ( dataElement ) ;
public K getKey ( final Object value ) { checkValue ( value ) ; final Node < K , V > node = lookupValue ( value ) ; return node == null ? null : node . getKey () ; MST[NonVoidMethodCallMutator]MSP[S] } @Override
private boolean doEquals ( final Object obj , final DataElement dataElement ) { if ( obj == this ) { return true ; } if ( obj instanceof Map == false ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] return false ; }
private boolean doEquals ( final Object obj , final DataElement dataElement ) { if ( obj == this ) { return true ; } if ( obj instanceof Map == false ) { MST[rv.ROR3Mutator]MSP[S] return false ; }
private MapIterator < ? , ? > getMapIterator ( final DataElement dataElement ) { switch ( dataElement ) { case KEY : return new ViewMapIterator ( KEY ) ; MST[ReturnValsMutator]MSP[S] case VALUE : return new InverseViewMapIterator ( VALUE ) ; default: throw new IllegalArgumentException () ; } }
@Override public String toString () { return description ; } @Override public int size () { return nodeCount ; } @Override public boolean isEmpty () { return nodeCount == 0 ; MST[rv.CRCR5Mutator]MSP[N] } @Override public boolean containsKey ( final Object key ) { checkKey ( key ) ;
final Map < ? , ? > other = ( Map < ? , ? > ) obj ; if ( other . size () != size () ) { MST[rv.ROR3Mutator]MSP[N] return false ; } if ( nodeCount > 0 ) { try {
} deletedNode . setLeft ( null , dataElement ) ; deletedNode . setRight ( null , dataElement ) ; deletedNode . setParent ( null , dataElement ) ; if ( isBlack ( deletedNode , dataElement ) ) { MST[NegateConditionalsMutator]MSP[S] doRedBlackDeleteFixup ( replacement , dataElement ) ; } } else {
private Node < K , V > getLeftChild ( final Node < K , V > node , final DataElement dataElement ) { return node == null ? null : node . getLeft ( dataElement ) ; MST[rv.ROR5Mutator]MSP[S] }
final Node < K , V > y = getRightChild ( getGrandParent ( currentNode , dataElement ) , dataElement ) ; if ( isRed ( y , dataElement ) ) { MST[NonVoidMethodCallMutator]MSP[S] makeBlack ( getParent ( currentNode , dataElement ) , dataElement ) ; makeBlack ( y , dataElement ) ;
} else { to . copyColor ( from , dataElement ) ; } } } private static boolean isRed ( final Node < ? , ? > node , final DataElement dataElement ) { return node != null && node . isRed ( dataElement ) ; MST[InlineConstantMutator]MSP[S] }
final Object key = it . next () ; final Object value = it . getValue () ; total += key . hashCode () ^ value . hashCode () ; } } return total ; MST[rv.UOI3Mutator]MSP[S] } private String doToString ( final DataElement dataElement ) {
boolean hasNext = it . hasNext () ; while ( hasNext ) { final Object key = it . next () ; final Object value = it . getValue () ; buf . append ( key == this ? lr_8 : key ) . append ( '=' ) MST[NonVoidMethodCallMutator]MSP[S]
final Map < ? , ? > other = ( Map < ? , ? > ) obj ; if ( other . size () != size () ) { return false ; } if ( nodeCount > 0 ) { MST[rv.UOI4Mutator]MSP[N] try {
if ( node == null ) { MST[NegateConditionalsMutator]MSP[S] rval = null ; } else if ( node . getLeft ( dataElement ) != null ) { rval = greatestNode ( node . getLeft ( dataElement ) , dataElement ) ; } else {
&& currentNode != rootNode [ dataElement . ordinal () ] && isRed ( currentNode . getParent ( dataElement ) , dataElement ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] if ( currentNode . isLeftChild ( dataElement ) ) {
} makeBlack ( getParent ( currentNode , dataElement ) , dataElement ) ; makeRed ( getGrandParent ( currentNode , dataElement ) , dataElement ) ; if ( getGrandParent ( currentNode , dataElement ) != null ) { rotateRight ( getGrandParent ( currentNode , dataElement ) , dataElement ) ; MST[NonVoidMethodCallMutator]MSP[S] }
. append ( value == this ? lr_8 : value ) ; hasNext = it . hasNext () ; if ( hasNext ) { buf . append ( lr_9 ) ; } } buf . append ( '}' ) ; MST[rv.CRCR5Mutator]MSP[S] return buf . toString () ; }
private Node < K , V > getLeftChild ( final Node < K , V > node , final DataElement dataElement ) { return node == null ? null : node . getLeft ( dataElement ) ; MST[NullReturnValsMutator]MSP[S] }
} private void rotateRight ( final Node < K , V > node , final DataElement dataElement ) { final Node < K , V > leftChild = node . getLeft ( dataElement ) ; node . setLeft ( leftChild . getRight ( dataElement ) , dataElement ) ; MST[ArgumentPropagationMutator]MSP[S]
} } else { final Node < K , V > y = getLeftChild ( getGrandParent ( currentNode , dataElement ) , dataElement ) ; if ( isRed ( y , dataElement ) ) { MST[rv.ROR2Mutator]MSP[S] makeBlack ( getParent ( currentNode , dataElement ) , dataElement ) ;
@Override public String toString () { return description ; } @Override public int size () { return nodeCount ; } @Override public boolean isEmpty () { return nodeCount == 0 ; MST[NegateConditionalsMutator]MSP[N] } @Override public boolean containsKey ( final Object key ) { checkKey ( key ) ;
} private void modify () { modifications ++ ; } private void grow () { modify () ; nodeCount ++ ; MST[rv.UOI3Mutator]MSP[N] } private void shrink () { modify () ; nodeCount -- ; } private void insertValue ( final Node < K , V > newNode ) throws IllegalArgumentException {
return leastNode ( rootNode [ KEY . ordinal () ] , KEY ) . getKey () ; } @Override public K lastKey () { if ( nodeCount == 0 ) { MST[rv.ROR5Mutator]MSP[S] throw new NoSuchElementException ( lr_1 ) ; }
deletedNode . getParent ( dataElement ) . setRight ( null , dataElement ) ; MST[ArgumentPropagationMutator]MSP[S] } deletedNode . setParent ( null , dataElement ) ; } } } } shrink () ; } private void doRedBlackDeleteFixup ( final Node < K , V > replacementNode , final DataElement dataElement ) {
@Override public String toString () { return description ; } @Override public int size () { return nodeCount ; MST[ReturnValsMutator]MSP[N] } @Override public boolean isEmpty () { return nodeCount == 0 ; } @Override public boolean containsKey ( final Object key ) { checkKey ( key ) ;
while ( rval . getLeft ( dataElement ) != null ) { rval = rval . getLeft ( dataElement ) ; MST[NonVoidMethodCallMutator]MSP[S] } } return rval ; } private Node < K , V > greatestNode ( final Node < K , V > node , final DataElement dataElement ) {
for ( final DataElement dataElement : DataElement . values () ) { if ( deletedNode . getLeft ( dataElement ) != null && deletedNode . getRight ( dataElement ) != null ) { MST[rv.ROR5Mutator]MSP[S] swapPosition ( nextGreater ( deletedNode , dataElement ) , deletedNode , dataElement ) ; }
if ( deletedNode . getParent ( dataElement ) == null ) { rootNode [ dataElement . ordinal () ] = null ; } else { if ( isBlack ( deletedNode , dataElement ) ) { MST[NegateConditionalsMutator]MSP[S] doRedBlackDeleteFixup ( deletedNode , dataElement ) ; }
makeBlack ( y , dataElement ) ; makeRed ( getGrandParent ( currentNode , dataElement ) , dataElement ) ; currentNode = getGrandParent ( currentNode , dataElement ) ; } else { if ( currentNode . isLeftChild ( dataElement ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] currentNode = getParent ( currentNode , dataElement ) ;
private Node < K , V > getLeftChild ( final Node < K , V > node , final DataElement dataElement ) { return node == null ? null : node . getLeft ( dataElement ) ; MST[NegateConditionalsMutator]MSP[S] }
final Map < ? , ? > other = ( Map < ? , ? > ) obj ; if ( other . size () != size () ) { return false ; } if ( nodeCount > 0 ) { MST[rv.UOI1Mutator]MSP[N] try {
rotateRight ( currentNode , dataElement ) ; } makeBlack ( getParent ( currentNode , dataElement ) , dataElement ) ; makeRed ( getGrandParent ( currentNode , dataElement ) , dataElement ) ; if ( getGrandParent ( currentNode , dataElement ) != null ) { MST[ArgumentPropagationMutator]MSP[S]
public Set < Map . Entry < K , V > > entrySet () { if ( entrySet == null ) { MST[NegateConditionalsMutator]MSP[S] entrySet = new EntryView () ; } return entrySet ; } @Override public OrderedMapIterator < K , V > mapIterator () { if ( isEmpty () ) {
return this . <V > lookup ( value , VALUE ) ; MST[NullReturnValsMutator]MSP[S] } private Node < K , V > nextGreater ( final Node < K , V > node , final DataElement dataElement ) { Node < K , V > rval ;
} private void modify () { modifications ++ ; } private void grow () { modify () ; nodeCount ++ ; } private void shrink () { modify () ; nodeCount -- ; MST[rv.AOD2Mutator]MSP[S] } private void insertValue ( final Node < K , V > newNode ) throws IllegalArgumentException {
if ( node == null ) { rval = null ; } else if ( node . getRight ( dataElement ) != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] rval = leastNode ( node . getRight ( dataElement ) , dataElement ) ; } else {
final Node < K , V > replacement = deletedNode . getLeft ( dataElement ) != null ? MST[ArgumentPropagationMutator]MSP[S] deletedNode . getLeft ( dataElement ) : deletedNode . getRight ( dataElement ) ; if ( replacement != null ) {
public Set < Map . Entry < K , V > > entrySet () { if ( entrySet == null ) { entrySet = new EntryView () ; } return entrySet ; } @Override public OrderedMapIterator < K , V > mapIterator () { if ( isEmpty () ) { MST[NegateConditionalsMutator]MSP[S]
if ( cmp == 0 ) { MST[rv.ROR1Mutator]MSP[S] rval = node ; break; } node = cmp < 0 ? node . getLeft ( dataElement ) : node . getRight ( dataElement ) ; } return rval ; }
for ( final MapIterator < ? , ? > it = getMapIterator ( dataElement ) ; it . hasNext () ; ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] final Object key = it . next () ; final Object value = it . getValue () ;
node . setLeft ( newNode , KEY ) ; newNode . setParent ( node , KEY ) ; doRedBlackInsert ( newNode , KEY ) ; grow () ; break; } } else { if ( node . getRight ( KEY ) != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S]
if ( deletedNode . getParent ( dataElement ) == null ) { rootNode [ dataElement . ordinal () ] = null ; } else { if ( isBlack ( deletedNode , dataElement ) ) { MST[rv.ROR5Mutator]MSP[S] doRedBlackDeleteFixup ( deletedNode , dataElement ) ; }
if ( cmp == 0 ) { rval = node ; break; } node = cmp < 0 ? node . getLeft ( dataElement ) : node . getRight ( dataElement ) ; MST[ConditionalsBoundaryMutator]MSP[S] } return rval ; }
} private void modify () { modifications ++ ; MST[rv.UOI2Mutator]MSP[S] } private void grow () { modify () ; nodeCount ++ ; } private void shrink () { modify () ; nodeCount -- ; } private void insertValue ( final Node < K , V > newNode ) throws IllegalArgumentException {
for ( final MapIterator < ? , ? > it = getMapIterator ( dataElement ) ; it . hasNext () ; ) { MST[NonVoidMethodCallMutator]MSP[S] final Object key = it . next () ; final Object value = it . getValue () ;
final Node < K , V > y = getRightChild ( getGrandParent ( currentNode , dataElement ) , dataElement ) ; if ( isRed ( y , dataElement ) ) { makeBlack ( getParent ( currentNode , dataElement ) , dataElement ) ; MST[VoidMethodCallMutator]MSP[S] makeBlack ( y , dataElement ) ;
@Override public String toString () { return description ; } @Override public int size () { return nodeCount ; } @Override public boolean isEmpty () { return nodeCount == 0 ; MST[InlineConstantMutator]MSP[N] } @Override public boolean containsKey ( final Object key ) { checkKey ( key ) ;
lr_6 + newNode . getData ( VALUE ) + lr_3 ) ; } else if ( cmp < 0 ) { MST[rv.UOI1Mutator]MSP[S] if ( node . getLeft ( VALUE ) != null ) { node = node . getLeft ( VALUE ) ; } else {
private int doHashCode ( final DataElement dataElement ) { int total = 0 ; if ( nodeCount > 0 ) { for ( final MapIterator < ? , ? > it = getMapIterator ( dataElement ) ; it . hasNext () ; ) { MST[NonVoidMethodCallMutator]MSP[S]
final Node < K , V > node = lookupKey ( key ) ; return node == null ? null : node . getValue () ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] } @Override public V put ( final K key , final V value ) { final V result = get ( key ) ;
private static boolean isBlack ( final Node < ? , ? > node , final DataElement dataElement ) { return node == null || node . isBlack ( dataElement ) ; MST[rv.CRCR5Mutator]MSP[S] }
if ( nodeCount == 0 ) { MST[rv.ROR1Mutator]MSP[N] return lr_7 ; } final StringBuilder buf = new StringBuilder ( nodeCount * 32 ) ; buf . append ( '{' ) ; final MapIterator < ? , ? > it = getMapIterator ( dataElement ) ;
. append ( value == this ? lr_8 : value ) ; hasNext = it . hasNext () ; if ( hasNext ) { MST[rv.ROR3Mutator]MSP[S] buf . append ( lr_9 ) ; } } buf . append ( '}' ) ; return buf . toString () ; }
return EmptyOrderedMapIterator . <K , V > emptyOrderedMapIterator () ; } return new ViewMapIterator ( KEY ) ; } @Override public OrderedBidiMap < V , K > inverseBidiMap () { if ( inverse == null ) { inverse = new Inverse () ; } return inverse ; MST[ReturnValsMutator]MSP[S] } @Override
} } else { final Node < K , V > y = getLeftChild ( getGrandParent ( currentNode , dataElement ) , dataElement ) ; MST[ArgumentPropagationMutator]MSP[S] if ( isRed ( y , dataElement ) ) { makeBlack ( getParent ( currentNode , dataElement ) , dataElement ) ;
final Node < K , V > node = nextSmaller ( lookupKey ( key ) , KEY ) ; return node == null ? null : node . getKey () ; MST[NullReturnValsMutator]MSP[S] } @Override public Set < K > keySet () { if ( keySet == null ) {
if ( leftChild . getRight ( dataElement ) != null ) { leftChild . getRight ( dataElement ) . setParent ( node , dataElement ) ; } leftChild . setParent ( node . getParent ( dataElement ) , dataElement ) ; MST[NonVoidMethodCallMutator]MSP[S]
return EmptyOrderedMapIterator . <K , V > emptyOrderedMapIterator () ; } return new ViewMapIterator ( KEY ) ; MST[ReturnValsMutator]MSP[S] } @Override public OrderedBidiMap < V , K > inverseBidiMap () { if ( inverse == null ) { inverse = new Inverse () ; } return inverse ; } @Override
return EmptyOrderedMapIterator . <K , V > emptyOrderedMapIterator () ; } return new ViewMapIterator ( KEY ) ; } @Override public OrderedBidiMap < V , K > inverseBidiMap () { if ( inverse == null ) { inverse = new Inverse () ; MST[experimental.MemberVariableMutator]MSP[S] } return inverse ; } @Override
lr_6 + newNode . getData ( VALUE ) + lr_3 ) ; } else if ( cmp < 0 ) { if ( node . getLeft ( VALUE ) != null ) { MST[NonVoidMethodCallMutator]MSP[S] node = node . getLeft ( VALUE ) ; } else {
. append ( value == this ? lr_8 : value ) ; hasNext = it . hasNext () ; if ( hasNext ) { buf . append ( lr_9 ) ; } } buf . append ( '}' ) ; return buf . toString () ; MST[NonVoidMethodCallMutator]MSP[S] }
} private void modify () { modifications ++ ; } private void grow () { modify () ; nodeCount ++ ; MST[rv.CRCR5Mutator]MSP[N] } private void shrink () { modify () ; nodeCount -- ; } private void insertValue ( final Node < K , V > newNode ) throws IllegalArgumentException {
lr_6 + newNode . getData ( VALUE ) + lr_3 ) ; } else if ( cmp < 0 ) { MST[rv.ROR2Mutator]MSP[S] if ( node . getLeft ( VALUE ) != null ) { node = node . getLeft ( VALUE ) ; } else {
} makeBlack ( getParent ( currentNode , dataElement ) , dataElement ) ; makeRed ( getGrandParent ( currentNode , dataElement ) , dataElement ) ; MST[ArgumentPropagationMutator]MSP[S] if ( getGrandParent ( currentNode , dataElement ) != null ) { rotateRight ( getGrandParent ( currentNode , dataElement ) , dataElement ) ; }
keySet = new KeyView ( KEY ) ; } return keySet ; } @Override public Set < V > values () { if ( valuesSet == null ) { valuesSet = new ValueView ( KEY ) ; MST[ConstructorCallMutator]MSP[S] } return valuesSet ; } @Override
if ( node == null ) { rval = null ; } else if ( node . getRight ( dataElement ) != null ) { rval = leastNode ( node . getRight ( dataElement ) , dataElement ) ; MST[ArgumentPropagationMutator]MSP[S] } else {
} deletedNode . setLeft ( null , dataElement ) ; deletedNode . setRight ( null , dataElement ) ; deletedNode . setParent ( null , dataElement ) ; if ( isBlack ( deletedNode , dataElement ) ) { MST[rv.ROR5Mutator]MSP[S] doRedBlackDeleteFixup ( replacement , dataElement ) ; } } else {
if ( value . equals ( other . get ( key ) ) == false ) { return false ; MST[rv.CRCR1Mutator]MSP[S] } } } catch ( final ClassCastException ex ) { return false ; } catch ( final NullPointerException ex ) { return false ; } } return true ; }
if ( node . getParent ( dataElement ) == null ) { MST[ArgumentPropagationMutator]MSP[S] rootNode [ dataElement . ordinal () ] = leftChild ; } else if ( node . getParent ( dataElement ) . getRight ( dataElement ) == node ) {
} private void modify () { modifications ++ ; } private void grow () { modify () ; nodeCount ++ ; } private void shrink () { modify () ; nodeCount -- ; MST[rv.AOR1Mutator]MSP[S] } private void insertValue ( final Node < K , V > newNode ) throws IllegalArgumentException {
private Node < K , V > getRightChild ( final Node < K , V > node , final DataElement dataElement ) { return node == null ? null : node . getRight ( dataElement ) ; MST[rv.ROR5Mutator]MSP[S] }
final Map < ? , ? > other = ( Map < ? , ? > ) obj ; if ( other . size () != size () ) { return false ; } if ( nodeCount > 0 ) { MST[rv.ROR2Mutator]MSP[S] try {
for ( final Map . Entry < ? extends K , ? extends V > e : map . entrySet () ) { put ( e . getKey () , e . getValue () ) ; MST[ArgumentPropagationMutator]MSP[N] } } @Override public V remove ( final Object key ) {
private MapIterator < ? , ? > getMapIterator ( final DataElement dataElement ) { switch ( dataElement ) { case KEY : return new ViewMapIterator ( KEY ) ; case VALUE : return new InverseViewMapIterator ( VALUE ) ; MST[ConstructorCallMutator]MSP[S] default: throw new IllegalArgumentException () ; } }
boolean hasNext = it . hasNext () ; while ( hasNext ) { MST[rv.ROR2Mutator]MSP[N] final Object key = it . next () ; final Object value = it . getValue () ; buf . append ( key == this ? lr_8 : key ) . append ( '=' )
if ( node == null ) { MST[rv.ROR5Mutator]MSP[S] rval = null ; } else if ( node . getLeft ( dataElement ) != null ) { rval = greatestNode ( node . getLeft ( dataElement ) , dataElement ) ; } else {
if ( value . equals ( other . get ( key ) ) == false ) { return false ; } } } catch ( final ClassCastException ex ) { return false ; } catch ( final NullPointerException ex ) { return false ; } } return true ; MST[rv.CRCR6Mutator]MSP[N] }
private Node < K , V > getParent ( final Node < K , V > node , final DataElement dataElement ) { return node == null ? null : node . getParent ( dataElement ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] }
if ( cmp == 0 ) { rval = node ; break; } node = cmp < 0 ? node . getLeft ( dataElement ) : node . getRight ( dataElement ) ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] } return rval ; }
final Object key = it . next () ; final Object value = it . getValue () ; total += key . hashCode () ^ value . hashCode () ; MST[rv.AOD1Mutator]MSP[N] } } return total ; } private String doToString ( final DataElement dataElement ) {
if ( deletedNode . getParent ( dataElement ) == null ) { MST[NonVoidMethodCallMutator]MSP[N] rootNode [ dataElement . ordinal () ] = null ; } else { if ( isBlack ( deletedNode , dataElement ) ) { doRedBlackDeleteFixup ( deletedNode , dataElement ) ; }
public Set < Map . Entry < K , V > > entrySet () { if ( entrySet == null ) { MST[rv.ROR5Mutator]MSP[S] entrySet = new EntryView () ; } return entrySet ; } @Override public OrderedMapIterator < K , V > mapIterator () { if ( isEmpty () ) {
node . setLeft ( newNode , KEY ) ; newNode . setParent ( node , KEY ) ; doRedBlackInsert ( newNode , KEY ) ; grow () ; break; } } else { if ( node . getRight ( KEY ) != null ) { MST[rv.ROR5Mutator]MSP[S]
for ( final DataElement dataElement : DataElement . values () ) { if ( deletedNode . getLeft ( dataElement ) != null && deletedNode . getRight ( dataElement ) != null ) { MST[ArgumentPropagationMutator]MSP[S] swapPosition ( nextGreater ( deletedNode , dataElement ) , deletedNode , dataElement ) ; }
} private void rotateRight ( final Node < K , V > node , final DataElement dataElement ) { final Node < K , V > leftChild = node . getLeft ( dataElement ) ; MST[NonVoidMethodCallMutator]MSP[S] node . setLeft ( leftChild . getRight ( dataElement ) , dataElement ) ;
return lookupKey ( key ) != null ; } @Override public boolean containsValue ( final Object value ) { checkValue ( value ) ; return lookupValue ( value ) != null ; MST[BooleanTrueReturnValsMutator]MSP[N] } @Override public V get ( final Object key ) { checkKey ( key ) ;
} else { to . copyColor ( from , dataElement ) ; } } } private static boolean isRed ( final Node < ? , ? > node , final DataElement dataElement ) { return node != null && node . isRed ( dataElement ) ; MST[InlineConstantMutator]MSP[N] }
Node < K , V > node = rootNode [ VALUE . ordinal () ] ; while ( true ) { final int cmp = compare ( newNode . getValue () , node . getValue () ) ; if ( cmp == 0 ) { MST[rv.ROR5Mutator]MSP[S] throw new IllegalArgumentException (
@Override public String toString () { return description ; } @Override public int size () { return nodeCount ; MST[rv.ABSMutator]MSP[N] } @Override public boolean isEmpty () { return nodeCount == 0 ; } @Override public boolean containsKey ( final Object key ) { checkKey ( key ) ;
if ( leftChild . getRight ( dataElement ) != null ) { leftChild . getRight ( dataElement ) . setParent ( node , dataElement ) ; } leftChild . setParent ( node . getParent ( dataElement ) , dataElement ) ; MST[VoidMethodCallMutator]MSP[N]
boolean hasNext = it . hasNext () ; while ( hasNext ) { final Object key = it . next () ; final Object value = it . getValue () ; buf . append ( key == this ? lr_8 : key ) MST[NonVoidMethodCallMutator]MSP[S] . append ( '=' )
if ( cmp == 0 ) { MST[rv.ABSMutator]MSP[N] rval = node ; break; } node = cmp < 0 ? node . getLeft ( dataElement ) : node . getRight ( dataElement ) ; } return rval ; }
Node < K , V > node = rootNode [ dataElement . ordinal () ] ; while ( node != null ) { final int cmp = compare ( ( T ) data , ( T ) node . getData ( dataElement ) ) ; MST[NonVoidMethodCallMutator]MSP[N]
Node < K , V > rval = node ; if ( rval != null ) { while ( rval . getRight ( dataElement ) != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] rval = rval . getRight ( dataElement ) ; } } return rval ; }
return lookupKey ( key ) != null ; } @Override public boolean containsValue ( final Object value ) { checkValue ( value ) ; return lookupValue ( value ) != null ; MST[rv.ROR5Mutator]MSP[N] } @Override public V get ( final Object key ) { checkKey ( key ) ;
for ( final MapIterator < ? , ? > it = getMapIterator ( dataElement ) ; it . hasNext () ; ) { MST[rv.ROR2Mutator]MSP[N] final Object key = it . next () ; final Object value = it . getValue () ;
if ( cmp == 0 ) { rval = node ; break; } node = cmp < 0 ? node . getLeft ( dataElement ) : node . getRight ( dataElement ) ; MST[rv.UOI4Mutator]MSP[N] } return rval ; }
Objects . requireNonNull ( obj , Objects . toString ( dataElement ) ) ; if ( ! ( obj instanceof Comparable ) ) { throw new ClassCastException ( dataElement + lr_5 ) ; MST[ConstructorCallMutator]MSP[S] } } private static void checkKey ( final Object key ) {
if ( nodeCount == 0 ) { MST[rv.UOI1Mutator]MSP[N] return lr_7 ; } final StringBuilder buf = new StringBuilder ( nodeCount * 32 ) ; buf . append ( '{' ) ; final MapIterator < ? , ? > it = getMapIterator ( dataElement ) ;
if ( nodeCount == 0 ) { return lr_7 ; } final StringBuilder buf = new StringBuilder ( nodeCount * 32 ) ; buf . append ( '{' ) ; MST[rv.CRCR6Mutator]MSP[S] final MapIterator < ? , ? > it = getMapIterator ( dataElement ) ;
boolean hasNext = it . hasNext () ; while ( hasNext ) { MST[rv.UOI2Mutator]MSP[N] final Object key = it . next () ; final Object value = it . getValue () ; buf . append ( key == this ? lr_8 : key ) . append ( '=' )
if ( node == null ) { final Node < K , V > root = new Node <> ( key , value ) ; rootNode [ KEY . ordinal () ] = root ; rootNode [ VALUE . ordinal () ] = root ; MST[NonVoidMethodCallMutator]MSP[N] grow () ;
if ( node == null ) { rval = null ; } else if ( node . getRight ( dataElement ) != null ) { rval = leastNode ( node . getRight ( dataElement ) , dataElement ) ; MST[ArgumentPropagationMutator]MSP[N] } else {
if ( deletedNode . getParent ( dataElement ) != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] if ( deletedNode == deletedNode . getParent ( dataElement ) . getLeft ( dataElement ) ) { deletedNode . getParent ( dataElement ) . setLeft ( null , dataElement ) ; } else {
final Map < ? , ? > other = ( Map < ? , ? > ) obj ; if ( other . size () != size () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return false ; } if ( nodeCount > 0 ) { try {
final Node < K , V > y = getRightChild ( getGrandParent ( currentNode , dataElement ) , dataElement ) ; if ( isRed ( y , dataElement ) ) { makeBlack ( getParent ( currentNode , dataElement ) , dataElement ) ; MST[NonVoidMethodCallMutator]MSP[N] makeBlack ( y , dataElement ) ;
node = node . getRight ( VALUE ) ; } else { node . setRight ( newNode , VALUE ) ; newNode . setParent ( node , VALUE ) ; MST[VoidMethodCallMutator]MSP[S] doRedBlackInsert ( newNode , VALUE ) ; break; } } } }
if ( nodeCount == 0 ) { MST[rv.ROR2Mutator]MSP[S] return lr_7 ; } final StringBuilder buf = new StringBuilder ( nodeCount * 32 ) ; buf . append ( '{' ) ; final MapIterator < ? , ? > it = getMapIterator ( dataElement ) ;
return lookupKey ( key ) != null ; } @Override public boolean containsValue ( final Object value ) { checkValue ( value ) ; return lookupValue ( value ) != null ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } @Override public V get ( final Object key ) { checkKey ( key ) ;
if ( cmp == 0 ) { rval = node ; break; } node = cmp < 0 ? node . getLeft ( dataElement ) : node . getRight ( dataElement ) ; MST[rv.ROR5Mutator]MSP[N] } return rval ; }
final Object key = it . next () ; final Object value = it . getValue () ; total += key . hashCode () ^ value . hashCode () ; } } return total ; MST[rv.UOI2Mutator]MSP[N] } private String doToString ( final DataElement dataElement ) {
if ( deletedNode . getParent ( dataElement ) != null ) { MST[rv.ROR5Mutator]MSP[S] if ( deletedNode == deletedNode . getParent ( dataElement ) . getLeft ( dataElement ) ) { deletedNode . getParent ( dataElement ) . setLeft ( null , dataElement ) ; } else {
if ( node == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] rval = null ; } else if ( node . getRight ( dataElement ) != null ) { rval = leastNode ( node . getRight ( dataElement ) , dataElement ) ; } else {
Node < K , V > parent = node . getParent ( dataElement ) ; Node < K , V > child = node ; while ( parent != null && child == parent . getRight ( dataElement ) ) { MST[NonVoidMethodCallMutator]MSP[N] child = parent ;
Node < K , V > rval = node ; if ( rval != null ) { while ( rval . getRight ( dataElement ) != null ) { rval = rval . getRight ( dataElement ) ; } } return rval ; MST[ReturnValsMutator]MSP[S] }
return lookupKey ( key ) != null ; } @Override public boolean containsValue ( final Object value ) { checkValue ( value ) ; return lookupValue ( value ) != null ; MST[NegateConditionalsMutator]MSP[N] } @Override public V get ( final Object key ) { checkKey ( key ) ;
private boolean doEquals ( final Object obj , final DataElement dataElement ) { if ( obj == this ) { return true ; } if ( obj instanceof Map == false ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return false ; }
if ( deletedNode . getParent ( dataElement ) != null ) { MST[NegateConditionalsMutator]MSP[S] if ( deletedNode == deletedNode . getParent ( dataElement ) . getLeft ( dataElement ) ) { deletedNode . getParent ( dataElement ) . setLeft ( null , dataElement ) ; } else {
final Map < ? , ? > other = ( Map < ? , ? > ) obj ; if ( other . size () != size () ) { return false ; MST[rv.CRCR5Mutator]MSP[N] } if ( nodeCount > 0 ) { try {
private boolean doEquals ( final Object obj , final DataElement dataElement ) { if ( obj == this ) { return true ; } if ( obj instanceof Map == false ) { MST[rv.ROR5Mutator]MSP[N] return false ; }
final Map < ? , ? > other = ( Map < ? , ? > ) obj ; if ( other . size () != size () ) { MST[rv.ROR5Mutator]MSP[N] return false ; } if ( nodeCount > 0 ) { try {
final Object key = it . next () ; final Object value = it . getValue () ; total += key . hashCode () ^ value . hashCode () ; } } return total ; MST[rv.ABSMutator]MSP[N] } private String doToString ( final DataElement dataElement ) {
final Node < K , V > node = nextGreater ( lookupKey ( key ) , KEY ) ; return node == null ? null : node . getKey () ; MST[NullReturnValsMutator]MSP[N] } @Override public K previousKey ( final K key ) { checkKey ( key ) ;
} deletedNode . setLeft ( null , dataElement ) ; deletedNode . setRight ( null , dataElement ) ; deletedNode . setParent ( null , dataElement ) ; if ( isBlack ( deletedNode , dataElement ) ) { MST[rv.ROR2Mutator]MSP[N] doRedBlackDeleteFixup ( replacement , dataElement ) ; } } else {
private boolean doEquals ( final Object obj , final DataElement dataElement ) { if ( obj == this ) { return true ; } if ( obj instanceof Map == false ) { return false ; MST[rv.CRCR5Mutator]MSP[N] }
if ( value . equals ( other . get ( key ) ) == false ) { return false ; MST[rv.CRCR6Mutator]MSP[N] } } } catch ( final ClassCastException ex ) { return false ; } catch ( final NullPointerException ex ) { return false ; } } return true ; }
Objects . requireNonNull ( obj , Objects . toString ( dataElement ) ) ; if ( ! ( obj instanceof Comparable ) ) { MST[rv.ROR1Mutator]MSP[S] throw new ClassCastException ( dataElement + lr_5 ) ; } } private static void checkKey ( final Object key ) {
Node < K , V > rval = node ; if ( rval != null ) { while ( rval . getRight ( dataElement ) != null ) { rval = rval . getRight ( dataElement ) ; } } return rval ; MST[NullReturnValsMutator]MSP[S] }
} private void modify () { modifications ++ ; } private void grow () { modify () ; nodeCount ++ ; MST[rv.CRCR6Mutator]MSP[N] } private void shrink () { modify () ; nodeCount -- ; } private void insertValue ( final Node < K , V > newNode ) throws IllegalArgumentException {
} else { while ( true ) { final int cmp = compare ( key , node . getKey () ) ; if ( cmp == 0 ) { MST[rv.ROR4Mutator]MSP[S] throw new IllegalArgumentException ( lr_2 + key + lr_3 ) ; } else if ( cmp < 0 ) {
} private void modify () { modifications ++ ; } private void grow () { modify () ; nodeCount ++ ; MST[rv.AOD2Mutator]MSP[N] } private void shrink () { modify () ; nodeCount -- ; } private void insertValue ( final Node < K , V > newNode ) throws IllegalArgumentException {
private int doHashCode ( final DataElement dataElement ) { int total = 0 ; if ( nodeCount > 0 ) { for ( final MapIterator < ? , ? > it = getMapIterator ( dataElement ) ; it . hasNext () ; ) { MST[NegateConditionalsMutator]MSP[N]
private MapIterator < ? , ? > getMapIterator ( final DataElement dataElement ) { switch ( dataElement ) { MST[rv.ABSMutator]MSP[S] case KEY : return new ViewMapIterator ( KEY ) ; case VALUE : return new InverseViewMapIterator ( VALUE ) ; default: throw new IllegalArgumentException () ; } }
if ( deletedNode . getParent ( dataElement ) != null ) { if ( deletedNode == deletedNode . getParent ( dataElement ) . getLeft ( dataElement ) ) { MST[NonVoidMethodCallMutator]MSP[N] deletedNode . getParent ( dataElement ) . setLeft ( null , dataElement ) ; } else {
makeBlack ( y , dataElement ) ; makeRed ( getGrandParent ( currentNode , dataElement ) , dataElement ) ; currentNode = getGrandParent ( currentNode , dataElement ) ; } else { if ( currentNode . isLeftChild ( dataElement ) ) { MST[NonVoidMethodCallMutator]MSP[N] currentNode = getParent ( currentNode , dataElement ) ;
node . setLeft ( newNode , KEY ) ; newNode . setParent ( node , KEY ) ; doRedBlackInsert ( newNode , KEY ) ; grow () ; break; } } else { if ( node . getRight ( KEY ) != null ) { MST[NegateConditionalsMutator]MSP[S]
public Set < Map . Entry < K , V > > entrySet () { if ( entrySet == null ) { entrySet = new EntryView () ; } return entrySet ; } @Override public OrderedMapIterator < K , V > mapIterator () { if ( isEmpty () ) { MST[rv.ROR2Mutator]MSP[N]
. append ( value == this ? lr_8 : value ) ; hasNext = it . hasNext () ; if ( hasNext ) { MST[rv.ROR4Mutator]MSP[N] buf . append ( lr_9 ) ; } } buf . append ( '}' ) ; return buf . toString () ; }
return greatestNode ( rootNode [ KEY . ordinal () ] , KEY ) . getKey () ; MST[NonVoidMethodCallMutator]MSP[S] } @Override public K nextKey ( final K key ) { checkKey ( key ) ;
final Map < ? , ? > other = ( Map < ? , ? > ) obj ; if ( other . size () != size () ) { return false ; } if ( nodeCount > 0 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] try {
if ( node . getLeft ( KEY ) != null ) { MST[NonVoidMethodCallMutator]MSP[N] node = node . getLeft ( KEY ) ; } else { final Node < K , V > newNode = new Node <> ( key , value ) ; insertValue ( newNode ) ;
boolean hasNext = it . hasNext () ; while ( hasNext ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] final Object key = it . next () ; final Object value = it . getValue () ; buf . append ( key == this ? lr_8 : key ) . append ( '=' )
final Map < ? , ? > other = ( Map < ? , ? > ) obj ; if ( other . size () != size () ) { return false ; } if ( nodeCount > 0 ) { MST[rv.ROR4Mutator]MSP[N] try {
for ( final Map . Entry < ? extends K , ? extends V > e : map . entrySet () ) { put ( e . getKey () , e . getValue () ) ; MST[NonVoidMethodCallMutator]MSP[S] } } @Override public V remove ( final Object key ) {
} private void modify () { modifications ++ ; MST[rv.UOI4Mutator]MSP[N] } private void grow () { modify () ; nodeCount ++ ; } private void shrink () { modify () ; nodeCount -- ; } private void insertValue ( final Node < K , V > newNode ) throws IllegalArgumentException {
node . setLeft ( newNode , KEY ) ; newNode . setParent ( node , KEY ) ; doRedBlackInsert ( newNode , KEY ) ; MST[VoidMethodCallMutator]MSP[N] grow () ; break; } } else { if ( node . getRight ( KEY ) != null ) {
Node < K , V > rval = node ; if ( rval != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] while ( rval . getRight ( dataElement ) != null ) { rval = rval . getRight ( dataElement ) ; } } return rval ; }
boolean hasNext = it . hasNext () ; while ( hasNext ) { MST[rv.ROR3Mutator]MSP[S] final Object key = it . next () ; final Object value = it . getValue () ; buf . append ( key == this ? lr_8 : key ) . append ( '=' )
boolean hasNext = it . hasNext () ; while ( hasNext ) { MST[rv.ABSMutator]MSP[N] final Object key = it . next () ; final Object value = it . getValue () ; buf . append ( key == this ? lr_8 : key ) . append ( '=' )
} else { to . copyColor ( from , dataElement ) ; } } } private static boolean isRed ( final Node < ? , ? > node , final DataElement dataElement ) { return node != null && node . isRed ( dataElement ) ; MST[rv.ROR1Mutator]MSP[N] }
final Node < K , V > y = getRightChild ( getGrandParent ( currentNode , dataElement ) , dataElement ) ; if ( isRed ( y , dataElement ) ) { MST[rv.ROR2Mutator]MSP[N] makeBlack ( getParent ( currentNode , dataElement ) , dataElement ) ; makeBlack ( y , dataElement ) ;
if ( deletedNode . getParent ( dataElement ) == null ) { rootNode [ dataElement . ordinal () ] = null ; } else { if ( isBlack ( deletedNode , dataElement ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] doRedBlackDeleteFixup ( deletedNode , dataElement ) ; }
final Node < K , V > y = getRightChild ( getGrandParent ( currentNode , dataElement ) , dataElement ) ; if ( isRed ( y , dataElement ) ) { MST[rv.ROR5Mutator]MSP[S] makeBlack ( getParent ( currentNode , dataElement ) , dataElement ) ; makeBlack ( y , dataElement ) ;
if ( node == null ) { final Node < K , V > root = new Node <> ( key , value ) ; rootNode [ KEY . ordinal () ] = root ; rootNode [ VALUE . ordinal () ] = root ; grow () ; MST[VoidMethodCallMutator]MSP[N]
if ( deletedNode . getParent ( dataElement ) == null ) { MST[ArgumentPropagationMutator]MSP[S] rootNode [ dataElement . ordinal () ] = null ; } else { if ( isBlack ( deletedNode , dataElement ) ) { doRedBlackDeleteFixup ( deletedNode , dataElement ) ; }
if ( nodeCount == 0 ) { return lr_7 ; } final StringBuilder buf = new StringBuilder ( nodeCount * 32 ) ; MST[rv.CRCR5Mutator]MSP[N] buf . append ( '{' ) ; final MapIterator < ? , ? > it = getMapIterator ( dataElement ) ;
final Node < K , V > node = nextSmaller ( lookupKey ( key ) , KEY ) ; MST[ArgumentPropagationMutator]MSP[N] return node == null ? null : node . getKey () ; } @Override public Set < K > keySet () { if ( keySet == null ) {
parent = parent . getParent ( dataElement ) ; } rval = parent ; } return rval ; MST[NullReturnValsMutator]MSP[N] } private Node < K , V > nextSmaller ( final Node < K , V > node , final DataElement dataElement ) { Node < K , V > rval ;
for ( final DataElement dataElement : DataElement . values () ) { MST[rv.UOI3Mutator]MSP[N] if ( deletedNode . getLeft ( dataElement ) != null && deletedNode . getRight ( dataElement ) != null ) { swapPosition ( nextGreater ( deletedNode , dataElement ) , deletedNode , dataElement ) ; }
private MapIterator < ? , ? > getMapIterator ( final DataElement dataElement ) { switch ( dataElement ) { case KEY : return new ViewMapIterator ( KEY ) ; case VALUE : return new InverseViewMapIterator ( VALUE ) ; MST[ReturnValsMutator]MSP[S] default: throw new IllegalArgumentException () ; } }
private int doHashCode ( final DataElement dataElement ) { int total = 0 ; MST[InlineConstantMutator]MSP[N] if ( nodeCount > 0 ) { for ( final MapIterator < ? , ? > it = getMapIterator ( dataElement ) ; it . hasNext () ; ) {
private static boolean isBlack ( final Node < ? , ? > node , final DataElement dataElement ) { return node == null || node . isBlack ( dataElement ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] }
if ( node == null ) { MST[NegateConditionalsMutator]MSP[N] rval = null ; } else if ( node . getRight ( dataElement ) != null ) { rval = leastNode ( node . getRight ( dataElement ) , dataElement ) ; } else {
final Node < K , V > node = nextSmaller ( lookupKey ( key ) , KEY ) ; MST[NonVoidMethodCallMutator]MSP[N] return node == null ? null : node . getKey () ; } @Override public Set < K > keySet () { if ( keySet == null ) {
boolean hasNext = it . hasNext () ; while ( hasNext ) { final Object key = it . next () ; final Object value = it . getValue () ; buf . append ( key == this ? lr_8 : key ) . append ( '=' ) MST[experimental.NakedReceiverMutator]MSP[S]
} makeBlack ( getParent ( currentNode , dataElement ) , dataElement ) ; makeRed ( getGrandParent ( currentNode , dataElement ) , dataElement ) ; if ( getGrandParent ( currentNode , dataElement ) != null ) { rotateRight ( getGrandParent ( currentNode , dataElement ) , dataElement ) ; MST[VoidMethodCallMutator]MSP[N] }
} private void modify () { modifications ++ ; } private void grow () { modify () ; nodeCount ++ ; MST[experimental.MemberVariableMutator]MSP[N] } private void shrink () { modify () ; nodeCount -- ; } private void insertValue ( final Node < K , V > newNode ) throws IllegalArgumentException {
if ( nodeCount == 0 ) { return lr_7 ; } final StringBuilder buf = new StringBuilder ( nodeCount * 32 ) ; buf . append ( '{' ) ; MST[rv.CRCR3Mutator]MSP[S] final MapIterator < ? , ? > it = getMapIterator ( dataElement ) ;
if ( node == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] final Node < K , V > root = new Node <> ( key , value ) ; rootNode [ KEY . ordinal () ] = root ; rootNode [ VALUE . ordinal () ] = root ; grow () ;
} deletedNode . setLeft ( null , dataElement ) ; deletedNode . setRight ( null , dataElement ) ; deletedNode . setParent ( null , dataElement ) ; if ( isBlack ( deletedNode , dataElement ) ) { doRedBlackDeleteFixup ( replacement , dataElement ) ; MST[VoidMethodCallMutator]MSP[N] } } else {
if ( value . equals ( other . get ( key ) ) == false ) { MST[NonVoidMethodCallMutator]MSP[N] return false ; } } } catch ( final ClassCastException ex ) { return false ; } catch ( final NullPointerException ex ) { return false ; } } return true ; }
makeBlack ( y , dataElement ) ; makeRed ( getGrandParent ( currentNode , dataElement ) , dataElement ) ; currentNode = getGrandParent ( currentNode , dataElement ) ; } else { if ( currentNode . isLeftChild ( dataElement ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] currentNode = getParent ( currentNode , dataElement ) ;
final Node < K , V > y = getRightChild ( getGrandParent ( currentNode , dataElement ) , dataElement ) ; if ( isRed ( y , dataElement ) ) { MST[NegateConditionalsMutator]MSP[N] makeBlack ( getParent ( currentNode , dataElement ) , dataElement ) ; makeBlack ( y , dataElement ) ;
Node < K , V > parent = node . getParent ( dataElement ) ; Node < K , V > child = node ; while ( parent != null && child == parent . getRight ( dataElement ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] child = parent ;
private Node < K , V > getParent ( final Node < K , V > node , final DataElement dataElement ) { return node == null ? null : node . getParent ( dataElement ) ; MST[NonVoidMethodCallMutator]MSP[N] }
lr_6 + newNode . getData ( VALUE ) + lr_3 ) ; } else if ( cmp < 0 ) { if ( node . getLeft ( VALUE ) != null ) { MST[ArgumentPropagationMutator]MSP[S] node = node . getLeft ( VALUE ) ; } else {
} private void modify () { modifications ++ ; } private void grow () { modify () ; nodeCount ++ ; MST[MathMutator]MSP[N] } private void shrink () { modify () ; nodeCount -- ; } private void insertValue ( final Node < K , V > newNode ) throws IllegalArgumentException {
final Map < ? , ? > other = ( Map < ? , ? > ) obj ; if ( other . size () != size () ) { MST[rv.ROR2Mutator]MSP[N] return false ; } if ( nodeCount > 0 ) { try {
rotateLeft ( getGrandParent ( currentNode , dataElement ) , dataElement ) ; MST[ArgumentPropagationMutator]MSP[S] } } } } makeBlack ( rootNode [ dataElement . ordinal () ] , dataElement ) ; } private void doRedBlackDelete ( final Node < K , V > deletedNode ) {
if ( node . getLeft ( KEY ) != null ) { MST[ArgumentPropagationMutator]MSP[S] node = node . getLeft ( KEY ) ; } else { final Node < K , V > newNode = new Node <> ( key , value ) ; insertValue ( newNode ) ;
Node < K , V > node = rootNode [ VALUE . ordinal () ] ; while ( true ) { final int cmp = compare ( newNode . getValue () , node . getValue () ) ; if ( cmp == 0 ) { MST[rv.UOI1Mutator]MSP[N] throw new IllegalArgumentException (
final Node < K , V > replacement = deletedNode . getLeft ( dataElement ) != null ? deletedNode . getLeft ( dataElement ) : deletedNode . getRight ( dataElement ) ; if ( replacement != null ) { MST[NegateConditionalsMutator]MSP[S]
final Node < K , V > node = nextSmaller ( lookupKey ( key ) , KEY ) ; return node == null ? null : node . getKey () ; MST[rv.ROR5Mutator]MSP[S] } @Override public Set < K > keySet () { if ( keySet == null ) {
final Map < ? , ? > other = ( Map < ? , ? > ) obj ; if ( other . size () != size () ) { return false ; } if ( nodeCount > 0 ) { MST[rv.UOI3Mutator]MSP[N] try {
for ( final DataElement dataElement : DataElement . values () ) { if ( deletedNode . getLeft ( dataElement ) != null && deletedNode . getRight ( dataElement ) != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] swapPosition ( nextGreater ( deletedNode , dataElement ) , deletedNode , dataElement ) ; }
public K removeValue ( final Object value ) { return doRemoveValue ( value ) ; } @Override public K firstKey () { if ( nodeCount == 0 ) { MST[rv.ROR5Mutator]MSP[S] throw new NoSuchElementException ( lr_1 ) ; }
private boolean doEquals ( final Object obj , final DataElement dataElement ) { if ( obj == this ) { return true ; } if ( obj instanceof Map == false ) { MST[rv.ROR2Mutator]MSP[N] return false ; }
keySet = new KeyView ( KEY ) ; } return keySet ; } @Override public Set < V > values () { if ( valuesSet == null ) { valuesSet = new ValueView ( KEY ) ; } return valuesSet ; MST[ReturnValsMutator]MSP[S] } @Override
public Set < Map . Entry < K , V > > entrySet () { if ( entrySet == null ) { entrySet = new EntryView () ; } return entrySet ; } @Override public OrderedMapIterator < K , V > mapIterator () { if ( isEmpty () ) { MST[rv.ROR5Mutator]MSP[N]
boolean hasNext = it . hasNext () ; while ( hasNext ) { final Object key = it . next () ; final Object value = it . getValue () ; buf . append ( key == this ? lr_8 : key ) MST[rv.CRCR6Mutator]MSP[S] . append ( '=' )
private Node < K , V > getRightChild ( final Node < K , V > node , final DataElement dataElement ) { return node == null ? null : node . getRight ( dataElement ) ; MST[ReturnValsMutator]MSP[S] }
if ( leftChild . getRight ( dataElement ) != null ) { leftChild . getRight ( dataElement ) . setParent ( node , dataElement ) ; } leftChild . setParent ( node . getParent ( dataElement ) , dataElement ) ; MST[ArgumentPropagationMutator]MSP[N]
makeRed ( getGrandParent ( currentNode , dataElement ) , dataElement ) ; currentNode = getGrandParent ( currentNode , dataElement ) ; } else { if ( currentNode . isRightChild ( dataElement ) ) { MST[rv.ROR4Mutator]MSP[N] currentNode = getParent ( currentNode , dataElement ) ; rotateLeft ( currentNode , dataElement ) ;
} deletedNode . setLeft ( null , dataElement ) ; deletedNode . setRight ( null , dataElement ) ; deletedNode . setParent ( null , dataElement ) ; if ( isBlack ( deletedNode , dataElement ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] doRedBlackDeleteFixup ( replacement , dataElement ) ; } } else {
&& currentNode != rootNode [ dataElement . ordinal () ] MST[rv.ROR5Mutator]MSP[N] && isRed ( currentNode . getParent ( dataElement ) , dataElement ) ) { if ( currentNode . isLeftChild ( dataElement ) ) {
return leastNode ( rootNode [ KEY . ordinal () ] , KEY ) . getKey () ; MST[NonVoidMethodCallMutator]MSP[S] } @Override public K lastKey () { if ( nodeCount == 0 ) { throw new NoSuchElementException ( lr_1 ) ; }
private Node < K , V > getRightChild ( final Node < K , V > node , final DataElement dataElement ) { return node == null ? null : node . getRight ( dataElement ) ; MST[NonVoidMethodCallMutator]MSP[S] }
if ( node == null ) { return null ; } doRedBlackDelete ( node ) ; return node . getKey () ; MST[ReturnValsMutator]MSP[N] } @SuppressWarnings ( lr_4 )
final Node < K , V > replacement = deletedNode . getLeft ( dataElement ) != null ? deletedNode . getLeft ( dataElement ) : deletedNode . getRight ( dataElement ) ; if ( replacement != null ) { MST[rv.ROR5Mutator]MSP[S]
} makeBlack ( getParent ( currentNode , dataElement ) , dataElement ) ; makeRed ( getGrandParent ( currentNode , dataElement ) , dataElement ) ; if ( getGrandParent ( currentNode , dataElement ) != null ) { MST[ArgumentPropagationMutator]MSP[N] rotateRight ( getGrandParent ( currentNode , dataElement ) , dataElement ) ; }
final Object key = it . next () ; final Object value = it . getValue () ; total += key . hashCode () ^ value . hashCode () ; MST[MathMutator]MSP[N] } } return total ; } private String doToString ( final DataElement dataElement ) {
node . setLeft ( newNode , VALUE ) ; newNode . setParent ( node , VALUE ) ; doRedBlackInsert ( newNode , VALUE ) ; MST[VoidMethodCallMutator]MSP[N] break; } } else { if ( node . getRight ( VALUE ) != null ) {
final Object key = it . next () ; final Object value = it . getValue () ; total += key . hashCode () ^ value . hashCode () ; MST[rv.AOR1Mutator]MSP[N] } } return total ; } private String doToString ( final DataElement dataElement ) {
private Node < K , V > leastNode ( final Node < K , V > node , final DataElement dataElement ) { Node < K , V > rval = node ; if ( rval != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S]
final Node < K , V > y = getRightChild ( getGrandParent ( currentNode , dataElement ) , dataElement ) ; MST[ArgumentPropagationMutator]MSP[S] if ( isRed ( y , dataElement ) ) { makeBlack ( getParent ( currentNode , dataElement ) , dataElement ) ; makeBlack ( y , dataElement ) ;
public K removeValue ( final Object value ) { return doRemoveValue ( value ) ; } @Override public K firstKey () { if ( nodeCount == 0 ) { MST[NegateConditionalsMutator]MSP[S] throw new NoSuchElementException ( lr_1 ) ; }
Node < K , V > node = rootNode [ VALUE . ordinal () ] ; while ( true ) { final int cmp = compare ( newNode . getValue () , node . getValue () ) ; if ( cmp == 0 ) { MST[rv.ROR2Mutator]MSP[S] throw new IllegalArgumentException (
. append ( value == this ? lr_8 : value ) ; hasNext = it . hasNext () ; if ( hasNext ) { MST[rv.UOI3Mutator]MSP[S] buf . append ( lr_9 ) ; } } buf . append ( '}' ) ; return buf . toString () ; }
} private void modify () { modifications ++ ; } private void grow () { modify () ; nodeCount ++ ; } private void shrink () { modify () ; nodeCount -- ; MST[rv.AOR3Mutator]MSP[N] } private void insertValue ( final Node < K , V > newNode ) throws IllegalArgumentException {
if ( deletedNode . getParent ( dataElement ) != null ) { if ( deletedNode == deletedNode . getParent ( dataElement ) . getLeft ( dataElement ) ) { MST[NegateConditionalsMutator]MSP[S] deletedNode . getParent ( dataElement ) . setLeft ( null , dataElement ) ; } else {
private int doHashCode ( final DataElement dataElement ) { int total = 0 ; if ( nodeCount > 0 ) { for ( final MapIterator < ? , ? > it = getMapIterator ( dataElement ) ; it . hasNext () ; ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S]
if ( nodeCount == 0 ) { return lr_7 ; } final StringBuilder buf = new StringBuilder ( nodeCount * 32 ) ; MST[rv.AOD2Mutator]MSP[N] buf . append ( '{' ) ; final MapIterator < ? , ? > it = getMapIterator ( dataElement ) ;
} private void modify () { modifications ++ ; } private void grow () { modify () ; nodeCount ++ ; MST[rv.CRCR3Mutator]MSP[N] } private void shrink () { modify () ; nodeCount -- ; } private void insertValue ( final Node < K , V > newNode ) throws IllegalArgumentException {
&& currentNode != rootNode [ dataElement . ordinal () ] MST[NegateConditionalsMutator]MSP[N] && isRed ( currentNode . getParent ( dataElement ) , dataElement ) ) { if ( currentNode . isLeftChild ( dataElement ) ) {
} else { while ( true ) { final int cmp = compare ( key , node . getKey () ) ; if ( cmp == 0 ) { throw new IllegalArgumentException ( lr_2 + key + lr_3 ) ; } else if ( cmp < 0 ) { MST[rv.ROR4Mutator]MSP[N]
public K getKey ( final Object value ) { checkValue ( value ) ; final Node < K , V > node = lookupValue ( value ) ; return node == null ? null : node . getKey () ; MST[ReturnValsMutator]MSP[S] } @Override
final Node < K , V > replacement = deletedNode . getLeft ( dataElement ) != null ? deletedNode . getLeft ( dataElement ) : deletedNode . getRight ( dataElement ) ; MST[ArgumentPropagationMutator]MSP[S] if ( replacement != null ) {
for ( final MapIterator < ? , ? > it = getMapIterator ( dataElement ) ; it . hasNext () ; ) { final Object key = it . next () ; MST[NonVoidMethodCallMutator]MSP[S] final Object value = it . getValue () ;
if ( nodeCount == 0 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] return lr_7 ; } final StringBuilder buf = new StringBuilder ( nodeCount * 32 ) ; buf . append ( '{' ) ; final MapIterator < ? , ? > it = getMapIterator ( dataElement ) ;
} else { to . copyColor ( from , dataElement ) ; } } } private static boolean isRed ( final Node < ? , ? > node , final DataElement dataElement ) { return node != null && node . isRed ( dataElement ) ; MST[rv.CRCR6Mutator]MSP[N] }
while ( rval . getLeft ( dataElement ) != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] rval = rval . getLeft ( dataElement ) ; } } return rval ; } private Node < K , V > greatestNode ( final Node < K , V > node , final DataElement dataElement ) {
if ( deletedNode . getParent ( dataElement ) == null ) { rootNode [ dataElement . ordinal () ] = null ; } else { if ( isBlack ( deletedNode , dataElement ) ) { MST[rv.ROR2Mutator]MSP[N] doRedBlackDeleteFixup ( deletedNode , dataElement ) ; }
final Node < K , V > y = getRightChild ( getGrandParent ( currentNode , dataElement ) , dataElement ) ; if ( isRed ( y , dataElement ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] makeBlack ( getParent ( currentNode , dataElement ) , dataElement ) ; makeBlack ( y , dataElement ) ;
node . setLeft ( newNode , KEY ) ; newNode . setParent ( node , KEY ) ; doRedBlackInsert ( newNode , KEY ) ; grow () ; MST[VoidMethodCallMutator]MSP[N] break; } } else { if ( node . getRight ( KEY ) != null ) {
deletedNode . getParent ( dataElement ) . setRight ( null , dataElement ) ; MST[VoidMethodCallMutator]MSP[S] } deletedNode . setParent ( null , dataElement ) ; } } } } shrink () ; } private void doRedBlackDeleteFixup ( final Node < K , V > replacementNode , final DataElement dataElement ) {
keySet = new KeyView ( KEY ) ; } return keySet ; MST[EmptyObjectReturnValsMutator]MSP[N] } @Override public Set < V > values () { if ( valuesSet == null ) { valuesSet = new ValueView ( KEY ) ; } return valuesSet ; } @Override
@Override public String toString () { return description ; } @Override public int size () { return nodeCount ; } @Override public boolean isEmpty () { return nodeCount == 0 ; MST[rv.CRCR5Mutator]MSP[N] } @Override public boolean containsKey ( final Object key ) { checkKey ( key ) ;
node = node . getRight ( VALUE ) ; MST[NonVoidMethodCallMutator]MSP[S] } else { node . setRight ( newNode , VALUE ) ; newNode . setParent ( node , VALUE ) ; doRedBlackInsert ( newNode , VALUE ) ; break; } } } }
makeBlack ( y , dataElement ) ; MST[VoidMethodCallMutator]MSP[N] makeRed ( getGrandParent ( currentNode , dataElement ) , dataElement ) ; currentNode = getGrandParent ( currentNode , dataElement ) ; } else { if ( currentNode . isLeftChild ( dataElement ) ) { currentNode = getParent ( currentNode , dataElement ) ;
for ( final DataElement dataElement : DataElement . values () ) { MST[rv.UOI2Mutator]MSP[N] if ( deletedNode . getLeft ( dataElement ) != null && deletedNode . getRight ( dataElement ) != null ) { swapPosition ( nextGreater ( deletedNode , dataElement ) , deletedNode , dataElement ) ; }
} else { while ( true ) { final int cmp = compare ( key , node . getKey () ) ; if ( cmp == 0 ) { throw new IllegalArgumentException ( lr_2 + key + lr_3 ) ; } else if ( cmp < 0 ) { MST[rv.UOI2Mutator]MSP[N]
deletedNode . getParent ( dataElement ) . setRight ( null , dataElement ) ; } deletedNode . setParent ( null , dataElement ) ; } } } } shrink () ; MST[VoidMethodCallMutator]MSP[N] } private void doRedBlackDeleteFixup ( final Node < K , V > replacementNode , final DataElement dataElement ) {
for ( final MapIterator < ? , ? > it = getMapIterator ( dataElement ) ; it . hasNext () ; ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] final Object key = it . next () ; final Object value = it . getValue () ;
if ( cmp == 0 ) { rval = node ; break; } node = cmp < 0 ? node . getLeft ( dataElement ) : node . getRight ( dataElement ) ; MST[rv.ROR2Mutator]MSP[N] } return rval ; }
private static boolean isBlack ( final Node < ? , ? > node , final DataElement dataElement ) { return node == null || node . isBlack ( dataElement ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] }
for ( final DataElement dataElement : DataElement . values () ) { MST[rv.UOI3Mutator]MSP[N] if ( deletedNode . getLeft ( dataElement ) != null && deletedNode . getRight ( dataElement ) != null ) { swapPosition ( nextGreater ( deletedNode , dataElement ) , deletedNode , dataElement ) ; }
if ( node == null ) { return null ; } doRedBlackDelete ( node ) ; MST[VoidMethodCallMutator]MSP[S] return node . getKey () ; } @SuppressWarnings ( lr_4 )
return doRemoveKey ( key ) ; } @Override public void clear () { modify () ; nodeCount = 0 ; rootNode [ KEY . ordinal () ] = null ; MST[NonVoidMethodCallMutator]MSP[N] rootNode [ VALUE . ordinal () ] = null ; } @Override
return doRemoveKey ( key ) ; } @Override public void clear () { modify () ; MST[VoidMethodCallMutator]MSP[N] nodeCount = 0 ; rootNode [ KEY . ordinal () ] = null ; rootNode [ VALUE . ordinal () ] = null ; } @Override
Node < K , V > currentNode = replacementNode ; while ( currentNode != rootNode [ dataElement . ordinal () ] && isBlack ( currentNode , dataElement ) ) { MST[rv.ROR2Mutator]MSP[N] if ( currentNode . isLeftChild ( dataElement ) ) {
lr_6 + newNode . getData ( VALUE ) + lr_3 ) ; } else if ( cmp < 0 ) { if ( node . getLeft ( VALUE ) != null ) { MST[rv.ROR5Mutator]MSP[S] node = node . getLeft ( VALUE ) ; } else {
} private void modify () { modifications ++ ; } private void grow () { modify () ; nodeCount ++ ; } private void shrink () { modify () ; nodeCount -- ; MST[rv.CRCR6Mutator]MSP[N] } private void insertValue ( final Node < K , V > newNode ) throws IllegalArgumentException {
return doRemoveKey ( key ) ; } @Override public void clear () { modify () ; nodeCount = 0 ; MST[rv.CRCR1Mutator]MSP[N] rootNode [ KEY . ordinal () ] = null ; rootNode [ VALUE . ordinal () ] = null ; } @Override
} } else { final Node < K , V > y = getLeftChild ( getGrandParent ( currentNode , dataElement ) , dataElement ) ; if ( isRed ( y , dataElement ) ) { MST[rv.ROR1Mutator]MSP[N] makeBlack ( getParent ( currentNode , dataElement ) , dataElement ) ;
Objects . requireNonNull ( obj , Objects . toString ( dataElement ) ) ; if ( ! ( obj instanceof Comparable ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] throw new ClassCastException ( dataElement + lr_5 ) ; } } private static void checkKey ( final Object key ) {
} } else { final Node < K , V > y = getLeftChild ( getGrandParent ( currentNode , dataElement ) , dataElement ) ; MST[NonVoidMethodCallMutator]MSP[S] if ( isRed ( y , dataElement ) ) { makeBlack ( getParent ( currentNode , dataElement ) , dataElement ) ;
return leastNode ( rootNode [ KEY . ordinal () ] , KEY ) . getKey () ; } @Override public K lastKey () { if ( nodeCount == 0 ) { MST[rv.ROR4Mutator]MSP[S] throw new NoSuchElementException ( lr_1 ) ; }
if ( nodeCount == 0 ) { return lr_7 ; } final StringBuilder buf = new StringBuilder ( nodeCount * 32 ) ; MST[InlineConstantMutator]MSP[N] buf . append ( '{' ) ; final MapIterator < ? , ? > it = getMapIterator ( dataElement ) ;
if ( node == null ) { rval = null ; } else if ( node . getRight ( dataElement ) != null ) { rval = leastNode ( node . getRight ( dataElement ) , dataElement ) ; MST[NonVoidMethodCallMutator]MSP[N] } else {
. append ( value == this ? lr_8 : value ) ; MST[experimental.NakedReceiverMutator]MSP[S] hasNext = it . hasNext () ; if ( hasNext ) { buf . append ( lr_9 ) ; } } buf . append ( '}' ) ; return buf . toString () ; }
boolean hasNext = it . hasNext () ; while ( hasNext ) { final Object key = it . next () ; final Object value = it . getValue () ; buf . append ( key == this ? lr_8 : key ) . append ( '=' ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[S]
if ( nodeCount == 0 ) { return lr_7 ; } final StringBuilder buf = new StringBuilder ( nodeCount * 32 ) ; MST[rv.ABSMutator]MSP[S] buf . append ( '{' ) ; final MapIterator < ? , ? > it = getMapIterator ( dataElement ) ;
Node < K , V > currentNode = replacementNode ; while ( currentNode != rootNode [ dataElement . ordinal () ] && isBlack ( currentNode , dataElement ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] if ( currentNode . isLeftChild ( dataElement ) ) {
if ( node . getLeft ( KEY ) != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] node = node . getLeft ( KEY ) ; } else { final Node < K , V > newNode = new Node <> ( key , value ) ; insertValue ( newNode ) ;
public Set < Map . Entry < K , V > > entrySet () { if ( entrySet == null ) { entrySet = new EntryView () ; } return entrySet ; } @Override public OrderedMapIterator < K , V > mapIterator () { if ( isEmpty () ) { MST[NonVoidMethodCallMutator]MSP[N]
} else { while ( true ) { final int cmp = compare ( key , node . getKey () ) ; if ( cmp == 0 ) { throw new IllegalArgumentException ( lr_2 + key + lr_3 ) ; } else if ( cmp < 0 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N]
} } else { final Node < K , V > y = getLeftChild ( getGrandParent ( currentNode , dataElement ) , dataElement ) ; if ( isRed ( y , dataElement ) ) { MST[rv.ROR5Mutator]MSP[S] makeBlack ( getParent ( currentNode , dataElement ) , dataElement ) ;
node = node . getRight ( KEY ) ; MST[NonVoidMethodCallMutator]MSP[S] } else { final Node < K , V > newNode = new Node <> ( key , value ) ; insertValue ( newNode ) ; node . setRight ( newNode , KEY ) ;
boolean hasNext = it . hasNext () ; while ( hasNext ) { final Object key = it . next () ; final Object value = it . getValue () ; buf . append ( key == this ? lr_8 : key ) . append ( '=' ) MST[rv.ROR5Mutator]MSP[S]
&& currentNode != rootNode [ dataElement . ordinal () ] && isRed ( currentNode . getParent ( dataElement ) , dataElement ) ) { if ( currentNode . isLeftChild ( dataElement ) ) { MST[rv.ROR4Mutator]MSP[N]
if ( node == null ) { rval = null ; } else if ( node . getRight ( dataElement ) != null ) { MST[ArgumentPropagationMutator]MSP[N] rval = leastNode ( node . getRight ( dataElement ) , dataElement ) ; } else {
@Override public String toString () { return description ; } @Override public int size () { return nodeCount ; } @Override public boolean isEmpty () { return nodeCount == 0 ; MST[rv.ROR4Mutator]MSP[N] } @Override public boolean containsKey ( final Object key ) { checkKey ( key ) ;
if ( deletedNode . getParent ( dataElement ) != null ) { if ( deletedNode == deletedNode . getParent ( dataElement ) . getLeft ( dataElement ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] deletedNode . getParent ( dataElement ) . setLeft ( null , dataElement ) ; } else {
private int doHashCode ( final DataElement dataElement ) { int total = 0 ; MST[rv.CRCR1Mutator]MSP[N] if ( nodeCount > 0 ) { for ( final MapIterator < ? , ? > it = getMapIterator ( dataElement ) ; it . hasNext () ; ) {
&& currentNode != rootNode [ dataElement . ordinal () ] && isRed ( currentNode . getParent ( dataElement ) , dataElement ) ) { MST[rv.ROR2Mutator]MSP[N] if ( currentNode . isLeftChild ( dataElement ) ) {
final Map < ? , ? > other = ( Map < ? , ? > ) obj ; if ( other . size () != size () ) { return false ; MST[BooleanTrueReturnValsMutator]MSP[N] } if ( nodeCount > 0 ) { try {
checkNonNullComparable ( key , KEY ) ; MST[VoidMethodCallMutator]MSP[N] } private static void checkValue ( final Object value ) { checkNonNullComparable ( value , VALUE ) ; } private static void checkKeyAndValue ( final Object key , final Object value ) { checkKey ( key ) ; checkValue ( value ) ;
} private void modify () { modifications ++ ; MST[rv.AOR2Mutator]MSP[N] } private void grow () { modify () ; nodeCount ++ ; } private void shrink () { modify () ; nodeCount -- ; } private void insertValue ( final Node < K , V > newNode ) throws IllegalArgumentException {
lr_6 + newNode . getData ( VALUE ) + lr_3 ) ; } else if ( cmp < 0 ) { MST[rv.UOI2Mutator]MSP[N] if ( node . getLeft ( VALUE ) != null ) { node = node . getLeft ( VALUE ) ; } else {
lr_6 + newNode . getData ( VALUE ) + lr_3 ) ; } else if ( cmp < 0 ) { if ( node . getLeft ( VALUE ) != null ) { MST[NegateConditionalsMutator]MSP[S] node = node . getLeft ( VALUE ) ; } else {
private int doHashCode ( final DataElement dataElement ) { int total = 0 ; if ( nodeCount > 0 ) { for ( final MapIterator < ? , ? > it = getMapIterator ( dataElement ) ; it . hasNext () ; ) { MST[rv.ROR2Mutator]MSP[N]
private int doHashCode ( final DataElement dataElement ) { int total = 0 ; if ( nodeCount > 0 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] for ( final MapIterator < ? , ? > it = getMapIterator ( dataElement ) ; it . hasNext () ; ) {
private boolean doEquals ( final Object obj , final DataElement dataElement ) { if ( obj == this ) { return true ; } if ( obj instanceof Map == false ) { return false ; MST[BooleanTrueReturnValsMutator]MSP[N] }
} private void modify () { modifications ++ ; } private void grow () { modify () ; nodeCount ++ ; } private void shrink () { modify () ; MST[VoidMethodCallMutator]MSP[N] nodeCount -- ; } private void insertValue ( final Node < K , V > newNode ) throws IllegalArgumentException {
if ( value . equals ( other . get ( key ) ) == false ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return false ; } } } catch ( final ClassCastException ex ) { return false ; } catch ( final NullPointerException ex ) { return false ; } } return true ; }
private int doHashCode ( final DataElement dataElement ) { int total = 0 ; if ( nodeCount > 0 ) { MST[ConditionalsBoundaryMutator]MSP[N] for ( final MapIterator < ? , ? > it = getMapIterator ( dataElement ) ; it . hasNext () ; ) {
private static boolean isBlack ( final Node < ? , ? > node , final DataElement dataElement ) { return node == null || node . isBlack ( dataElement ) ; MST[rv.ROR1Mutator]MSP[N] }
private Node < K , V > leastNode ( final Node < K , V > node , final DataElement dataElement ) { Node < K , V > rval = node ; if ( rval != null ) { MST[rv.ROR5Mutator]MSP[N]
} else { to . copyColor ( from , dataElement ) ; } } } private static boolean isRed ( final Node < ? , ? > node , final DataElement dataElement ) { return node != null && node . isRed ( dataElement ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] }
for ( final MapIterator < ? , ? > it = getMapIterator ( dataElement ) ; it . hasNext () ; ) { MST[NonVoidMethodCallMutator]MSP[N] final Object key = it . next () ; final Object value = it . getValue () ;
&& currentNode != rootNode [ dataElement . ordinal () ] MST[NonVoidMethodCallMutator]MSP[N] && isRed ( currentNode . getParent ( dataElement ) , dataElement ) ) { if ( currentNode . isLeftChild ( dataElement ) ) {
if ( nodeCount == 0 ) { MST[NegateConditionalsMutator]MSP[S] return lr_7 ; } final StringBuilder buf = new StringBuilder ( nodeCount * 32 ) ; buf . append ( '{' ) ; final MapIterator < ? , ? > it = getMapIterator ( dataElement ) ;
return EmptyOrderedMapIterator . <K , V > emptyOrderedMapIterator () ; } return new ViewMapIterator ( KEY ) ; } @Override public OrderedBidiMap < V , K > inverseBidiMap () { if ( inverse == null ) { inverse = new Inverse () ; } return inverse ; MST[NullReturnValsMutator]MSP[S] } @Override
} private void modify () { modifications ++ ; MST[rv.ABSMutator]MSP[N] } private void grow () { modify () ; nodeCount ++ ; } private void shrink () { modify () ; nodeCount -- ; } private void insertValue ( final Node < K , V > newNode ) throws IllegalArgumentException {
lr_6 + newNode . getData ( VALUE ) + lr_3 ) ; } else if ( cmp < 0 ) { MST[rv.ABSMutator]MSP[S] if ( node . getLeft ( VALUE ) != null ) { node = node . getLeft ( VALUE ) ; } else {
} private void modify () { modifications ++ ; } private void grow () { modify () ; nodeCount ++ ; } private void shrink () { modify () ; nodeCount -- ; MST[experimental.MemberVariableMutator]MSP[N] } private void insertValue ( final Node < K , V > newNode ) throws IllegalArgumentException {
if ( value . equals ( other . get ( key ) ) == false ) { MST[rv.ROR5Mutator]MSP[N] return false ; } } } catch ( final ClassCastException ex ) { return false ; } catch ( final NullPointerException ex ) { return false ; } } return true ; }
final Map < ? , ? > other = ( Map < ? , ? > ) obj ; if ( other . size () != size () ) { return false ; } if ( nodeCount > 0 ) { MST[NegateConditionalsMutator]MSP[N] try {
if ( value . equals ( other . get ( key ) ) == false ) { return false ; MST[ReturnValsMutator]MSP[N] } } } catch ( final ClassCastException ex ) { return false ; } catch ( final NullPointerException ex ) { return false ; } } return true ; }
} else { while ( true ) { final int cmp = compare ( key , node . getKey () ) ; if ( cmp == 0 ) { throw new IllegalArgumentException ( lr_2 + key + lr_3 ) ; } else if ( cmp < 0 ) { MST[ConditionalsBoundaryMutator]MSP[N]
makeBlack ( y , dataElement ) ; makeRed ( getGrandParent ( currentNode , dataElement ) , dataElement ) ; currentNode = getGrandParent ( currentNode , dataElement ) ; MST[NonVoidMethodCallMutator]MSP[N] } else { if ( currentNode . isLeftChild ( dataElement ) ) { currentNode = getParent ( currentNode , dataElement ) ;
@Override public String toString () { return description ; } @Override public int size () { return nodeCount ; } @Override public boolean isEmpty () { return nodeCount == 0 ; MST[ReturnValsMutator]MSP[N] } @Override public boolean containsKey ( final Object key ) { checkKey ( key ) ;
} else { to . copyColor ( from , dataElement ) ; } } } private static boolean isRed ( final Node < ? , ? > node , final DataElement dataElement ) { return node != null && node . isRed ( dataElement ) ; MST[rv.ROR4Mutator]MSP[N] }
private boolean doEquals ( final Object obj , final DataElement dataElement ) { if ( obj == this ) { return true ; } if ( obj instanceof Map == false ) { return false ; MST[rv.CRCR6Mutator]MSP[N] }
&& currentNode != rootNode [ dataElement . ordinal () ] MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] && isRed ( currentNode . getParent ( dataElement ) , dataElement ) ) { if ( currentNode . isLeftChild ( dataElement ) ) {
} makeBlack ( getParent ( currentNode , dataElement ) , dataElement ) ; makeRed ( getGrandParent ( currentNode , dataElement ) , dataElement ) ; if ( getGrandParent ( currentNode , dataElement ) != null ) { MST[rv.ROR5Mutator]MSP[N] rotateRight ( getGrandParent ( currentNode , dataElement ) , dataElement ) ; }
Node < K , V > node = rootNode [ VALUE . ordinal () ] ; while ( true ) { final int cmp = compare ( newNode . getValue () , node . getValue () ) ; if ( cmp == 0 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] throw new IllegalArgumentException (
if ( value . equals ( other . get ( key ) ) == false ) { return false ; MST[rv.CRCR5Mutator]MSP[N] } } } catch ( final ClassCastException ex ) { return false ; } catch ( final NullPointerException ex ) { return false ; } } return true ; }
private Node < K , V > leastNode ( final Node < K , V > node , final DataElement dataElement ) { Node < K , V > rval = node ; if ( rval != null ) { MST[NegateConditionalsMutator]MSP[N]
return leastNode ( rootNode [ KEY . ordinal () ] , KEY ) . getKey () ; MST[NonVoidMethodCallMutator]MSP[N] } @Override public K lastKey () { if ( nodeCount == 0 ) { throw new NoSuchElementException ( lr_1 ) ; }
} private void modify () { modifications ++ ; MST[rv.CRCR5Mutator]MSP[N] } private void grow () { modify () ; nodeCount ++ ; } private void shrink () { modify () ; nodeCount -- ; } private void insertValue ( final Node < K , V > newNode ) throws IllegalArgumentException {
} private void modify () { modifications ++ ; MST[InlineConstantMutator]MSP[N] } private void grow () { modify () ; nodeCount ++ ; } private void shrink () { modify () ; nodeCount -- ; } private void insertValue ( final Node < K , V > newNode ) throws IllegalArgumentException {
} private void modify () { modifications ++ ; MST[rv.UOI1Mutator]MSP[N] } private void grow () { modify () ; nodeCount ++ ; } private void shrink () { modify () ; nodeCount -- ; } private void insertValue ( final Node < K , V > newNode ) throws IllegalArgumentException {
final Node < K , V > replacement = deletedNode . getLeft ( dataElement ) != null ? deletedNode . getLeft ( dataElement ) : deletedNode . getRight ( dataElement ) ; if ( replacement != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S]
private Node < K , V > getLeftChild ( final Node < K , V > node , final DataElement dataElement ) { return node == null ? null : node . getLeft ( dataElement ) ; MST[NonVoidMethodCallMutator]MSP[N] }
} private void rotateRight ( final Node < K , V > node , final DataElement dataElement ) { final Node < K , V > leftChild = node . getLeft ( dataElement ) ; MST[ArgumentPropagationMutator]MSP[N] node . setLeft ( leftChild . getRight ( dataElement ) , dataElement ) ;
public K removeValue ( final Object value ) { return doRemoveValue ( value ) ; } @Override public K firstKey () { if ( nodeCount == 0 ) { throw new NoSuchElementException ( lr_1 ) ; MST[ConstructorCallMutator]MSP[S] }
private static boolean isBlack ( final Node < ? , ? > node , final DataElement dataElement ) { return node == null || node . isBlack ( dataElement ) ; MST[BooleanTrueReturnValsMutator]MSP[N] }
if ( value . equals ( other . get ( key ) ) == false ) { MST[NonVoidMethodCallMutator]MSP[N] return false ; } } } catch ( final ClassCastException ex ) { return false ; } catch ( final NullPointerException ex ) { return false ; } } return true ; }
} else { while ( true ) { final int cmp = compare ( key , node . getKey () ) ; if ( cmp == 0 ) { MST[rv.UOI2Mutator]MSP[N] throw new IllegalArgumentException ( lr_2 + key + lr_3 ) ; } else if ( cmp < 0 ) {
replacement . setParent ( deletedNode . getParent ( dataElement ) , dataElement ) ; if ( deletedNode . getParent ( dataElement ) == null ) { rootNode [ dataElement . ordinal () ] = replacement ; MST[NonVoidMethodCallMutator]MSP[S]
final Map < ? , ? > other = ( Map < ? , ? > ) obj ; if ( other . size () != size () ) { return false ; MST[rv.CRCR6Mutator]MSP[N] } if ( nodeCount > 0 ) { try {
private MapIterator < ? , ? > getMapIterator ( final DataElement dataElement ) { switch ( dataElement ) { MST[rv.UOI4Mutator]MSP[S] case KEY : return new ViewMapIterator ( KEY ) ; case VALUE : return new InverseViewMapIterator ( VALUE ) ; default: throw new IllegalArgumentException () ; } }
if ( cmp == 0 ) { rval = node ; break; } node = cmp < 0 ? node . getLeft ( dataElement ) : node . getRight ( dataElement ) ; MST[NonVoidMethodCallMutator]MSP[S] } return rval ; }
private Node < K , V > getGrandParent ( final Node < K , V > node , final DataElement dataElement ) { return getParent ( getParent ( node , dataElement ) , dataElement ) ; MST[ArgumentPropagationMutator]MSP[S] }
final Map < ? , ? > other = ( Map < ? , ? > ) obj ; if ( other . size () != size () ) { return false ; } if ( nodeCount > 0 ) { MST[rv.ROR1Mutator]MSP[S] try {
if ( cmp == 0 ) { rval = node ; break; } node = cmp < 0 ? node . getLeft ( dataElement ) : node . getRight ( dataElement ) ; MST[rv.UOI1Mutator]MSP[S] } return rval ; }
if ( cmp == 0 ) { rval = node ; break; } node = cmp < 0 ? node . getLeft ( dataElement ) : node . getRight ( dataElement ) ; MST[rv.ABSMutator]MSP[S] } return rval ; }
} } else { final Node < K , V > y = getLeftChild ( getGrandParent ( currentNode , dataElement ) , dataElement ) ; if ( isRed ( y , dataElement ) ) { MST[NegateConditionalsMutator]MSP[S] makeBlack ( getParent ( currentNode , dataElement ) , dataElement ) ;
return lookupKey ( key ) != null ; } @Override public boolean containsValue ( final Object value ) { checkValue ( value ) ; return lookupValue ( value ) != null ; MST[rv.CRCR3Mutator]MSP[N] } @Override public V get ( final Object key ) { checkKey ( key ) ;
if ( deletedNode . getParent ( dataElement ) != null ) { if ( deletedNode == deletedNode . getParent ( dataElement ) . getLeft ( dataElement ) ) { MST[rv.ROR5Mutator]MSP[S] deletedNode . getParent ( dataElement ) . setLeft ( null , dataElement ) ; } else {
if ( deletedNode . getParent ( dataElement ) != null ) { MST[NonVoidMethodCallMutator]MSP[S] if ( deletedNode == deletedNode . getParent ( dataElement ) . getLeft ( dataElement ) ) { deletedNode . getParent ( dataElement ) . setLeft ( null , dataElement ) ; } else {
if ( nodeCount == 0 ) { return lr_7 ; } final StringBuilder buf = new StringBuilder ( nodeCount * 32 ) ; MST[rv.AOR2Mutator]MSP[S] buf . append ( '{' ) ; final MapIterator < ? , ? > it = getMapIterator ( dataElement ) ;
if ( deletedNode . getParent ( dataElement ) != null ) { if ( deletedNode == deletedNode . getParent ( dataElement ) . getLeft ( dataElement ) ) { MST[ArgumentPropagationMutator]MSP[S] deletedNode . getParent ( dataElement ) . setLeft ( null , dataElement ) ; } else {
node . setLeft ( newNode , VALUE ) ; newNode . setParent ( node , VALUE ) ; doRedBlackInsert ( newNode , VALUE ) ; break; } } else { if ( node . getRight ( VALUE ) != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S]
boolean hasNext = it . hasNext () ; while ( hasNext ) { final Object key = it . next () ; MST[NonVoidMethodCallMutator]MSP[S] final Object value = it . getValue () ; buf . append ( key == this ? lr_8 : key ) . append ( '=' )
return lookupKey ( key ) != null ; MST[ReturnValsMutator]MSP[N] } @Override public boolean containsValue ( final Object value ) { checkValue ( value ) ; return lookupValue ( value ) != null ; } @Override public V get ( final Object key ) { checkKey ( key ) ;
if ( node == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return null ; } doRedBlackDelete ( node ) ; return node . getValue () ; } private K doRemoveValue ( final Object value ) { final Node < K , V > node = lookupValue ( value ) ;
if ( nodeCount == 0 ) { MST[rv.UOI4Mutator]MSP[N] return lr_7 ; } final StringBuilder buf = new StringBuilder ( nodeCount * 32 ) ; buf . append ( '{' ) ; final MapIterator < ? , ? > it = getMapIterator ( dataElement ) ;
return EmptyOrderedMapIterator . <K , V > emptyOrderedMapIterator () ; MST[NonVoidMethodCallMutator]MSP[S] } return new ViewMapIterator ( KEY ) ; } @Override public OrderedBidiMap < V , K > inverseBidiMap () { if ( inverse == null ) { inverse = new Inverse () ; } return inverse ; } @Override
return this . <V > lookup ( value , VALUE ) ; MST[NonVoidMethodCallMutator]MSP[S] } private Node < K , V > nextGreater ( final Node < K , V > node , final DataElement dataElement ) { Node < K , V > rval ;
} makeBlack ( getParent ( currentNode , dataElement ) , dataElement ) ; makeRed ( getGrandParent ( currentNode , dataElement ) , dataElement ) ; if ( getGrandParent ( currentNode , dataElement ) != null ) { MST[NegateConditionalsMutator]MSP[S] rotateRight ( getGrandParent ( currentNode , dataElement ) , dataElement ) ; }
} private void modify () { modifications ++ ; } private void grow () { modify () ; MST[VoidMethodCallMutator]MSP[S] nodeCount ++ ; } private void shrink () { modify () ; nodeCount -- ; } private void insertValue ( final Node < K , V > newNode ) throws IllegalArgumentException {
Node < K , V > node = rootNode [ VALUE . ordinal () ] ; while ( true ) { final int cmp = compare ( newNode . getValue () , node . getValue () ) ; MST[NonVoidMethodCallMutator]MSP[S] if ( cmp == 0 ) { throw new IllegalArgumentException (
return leastNode ( rootNode [ KEY . ordinal () ] , KEY ) . getKey () ; } @Override public K lastKey () { if ( nodeCount == 0 ) { MST[rv.ROR1Mutator]MSP[S] throw new NoSuchElementException ( lr_1 ) ; }
private static boolean isBlack ( final Node < ? , ? > node , final DataElement dataElement ) { return node == null || node . isBlack ( dataElement ) ; MST[rv.CRCR4Mutator]MSP[S] }
Node < K , V > currentNode = replacementNode ; while ( currentNode != rootNode [ dataElement . ordinal () ] && isBlack ( currentNode , dataElement ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] if ( currentNode . isLeftChild ( dataElement ) ) {
} private void modify () { modifications ++ ; } private void grow () { modify () ; nodeCount ++ ; } private void shrink () { modify () ; nodeCount -- ; MST[rv.CRCR3Mutator]MSP[S] } private void insertValue ( final Node < K , V > newNode ) throws IllegalArgumentException {
private static boolean isBlack ( final Node < ? , ? > node , final DataElement dataElement ) { return node == null || node . isBlack ( dataElement ) ; MST[rv.ROR4Mutator]MSP[S] }
if ( node == null ) { rval = null ; } else if ( node . getRight ( dataElement ) != null ) { MST[NegateConditionalsMutator]MSP[S] rval = leastNode ( node . getRight ( dataElement ) , dataElement ) ; } else {
private void rotateLeft ( final Node < K , V > node , final DataElement dataElement ) { final Node < K , V > rightChild = node . getRight ( dataElement ) ; node . setRight ( rightChild . getLeft ( dataElement ) , dataElement ) ; MST[ArgumentPropagationMutator]MSP[S]
private Node < K , V > getLeftChild ( final Node < K , V > node , final DataElement dataElement ) { return node == null ? null : node . getLeft ( dataElement ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] }
if ( nodeCount == 0 ) { return lr_7 ; } final StringBuilder buf = new StringBuilder ( nodeCount * 32 ) ; MST[rv.UOI1Mutator]MSP[S] buf . append ( '{' ) ; final MapIterator < ? , ? > it = getMapIterator ( dataElement ) ;
if ( cmp == 0 ) { MST[rv.UOI4Mutator]MSP[S] rval = node ; break; } node = cmp < 0 ? node . getLeft ( dataElement ) : node . getRight ( dataElement ) ; } return rval ; }
if ( cmp == 0 ) { MST[rv.ROR5Mutator]MSP[S] rval = node ; break; } node = cmp < 0 ? node . getLeft ( dataElement ) : node . getRight ( dataElement ) ; } return rval ; }
&& currentNode != rootNode [ dataElement . ordinal () ] && isRed ( currentNode . getParent ( dataElement ) , dataElement ) ) { MST[NonVoidMethodCallMutator]MSP[S] if ( currentNode . isLeftChild ( dataElement ) ) {
while ( rval . getLeft ( dataElement ) != null ) { rval = rval . getLeft ( dataElement ) ; } } return rval ; MST[NullReturnValsMutator]MSP[N] } private Node < K , V > greatestNode ( final Node < K , V > node , final DataElement dataElement ) {
private Node < K , V > lookupKey ( final Object key ) { return this . <K > lookup ( key , KEY ) ; MST[ReturnValsMutator]MSP[S] } private Node < K , V > lookupValue ( final Object value ) {
private static boolean isBlack ( final Node < ? , ? > node , final DataElement dataElement ) { return node == null || node . isBlack ( dataElement ) ; MST[rv.CRCR1Mutator]MSP[S] }
if ( deletedNode . getParent ( dataElement ) == null ) { MST[rv.ROR5Mutator]MSP[S] rootNode [ dataElement . ordinal () ] = null ; } else { if ( isBlack ( deletedNode , dataElement ) ) { doRedBlackDeleteFixup ( deletedNode , dataElement ) ; }
@Override public String toString () { return description ; } @Override public int size () { return nodeCount ; } @Override public boolean isEmpty () { return nodeCount == 0 ; MST[rv.CRCR2Mutator]MSP[N] } @Override public boolean containsKey ( final Object key ) { checkKey ( key ) ;
} deletedNode . setLeft ( null , dataElement ) ; deletedNode . setRight ( null , dataElement ) ; deletedNode . setParent ( null , dataElement ) ; if ( isBlack ( deletedNode , dataElement ) ) { MST[NonVoidMethodCallMutator]MSP[S] doRedBlackDeleteFixup ( replacement , dataElement ) ; } } else {
public K removeValue ( final Object value ) { return doRemoveValue ( value ) ; } @Override public K firstKey () { if ( nodeCount == 0 ) { MST[rv.ROR1Mutator]MSP[S] throw new NoSuchElementException ( lr_1 ) ; }
keySet = new KeyView ( KEY ) ; } return keySet ; } @Override public Set < V > values () { if ( valuesSet == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] valuesSet = new ValueView ( KEY ) ; } return valuesSet ; } @Override
} private void doRedBlackInsert ( final Node < K , V > insertedNode , final DataElement dataElement ) { Node < K , V > currentNode = insertedNode ; makeRed ( currentNode , dataElement ) ; while ( currentNode != null MST[RemoveConditionalMutator_EQUAL_IF]MSP[S]
if ( value . equals ( other . get ( key ) ) == false ) { return false ; } } } catch ( final ClassCastException ex ) { return false ; } catch ( final NullPointerException ex ) { return false ; } } return true ; MST[rv.CRCR5Mutator]MSP[N] }
newNode . setParent ( node , KEY ) ; MST[VoidMethodCallMutator]MSP[S] doRedBlackInsert ( newNode , KEY ) ; grow () ; break; } } } } } private V doRemoveKey ( final Object key ) { final Node < K , V > node = lookupKey ( key ) ;
private int doHashCode ( final DataElement dataElement ) { int total = 0 ; if ( nodeCount > 0 ) { for ( final MapIterator < ? , ? > it = getMapIterator ( dataElement ) ; it . hasNext () ; ) { MST[rv.ROR5Mutator]MSP[S]
final Object key = it . next () ; final Object value = it . getValue () ; total += key . hashCode () ^ value . hashCode () ; MST[NonVoidMethodCallMutator]MSP[S] } } return total ; } private String doToString ( final DataElement dataElement ) {
makeBlack ( y , dataElement ) ; makeRed ( getGrandParent ( currentNode , dataElement ) , dataElement ) ; currentNode = getGrandParent ( currentNode , dataElement ) ; } else { if ( currentNode . isLeftChild ( dataElement ) ) { MST[rv.ROR3Mutator]MSP[S] currentNode = getParent ( currentNode , dataElement ) ;
if ( deletedNode . getParent ( dataElement ) == null ) { MST[NegateConditionalsMutator]MSP[S] rootNode [ dataElement . ordinal () ] = null ; } else { if ( isBlack ( deletedNode , dataElement ) ) { doRedBlackDeleteFixup ( deletedNode , dataElement ) ; }
private boolean doEquals ( final Object obj , final DataElement dataElement ) { if ( obj == this ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] return true ; } if ( obj instanceof Map == false ) { return false ; }
if ( node == null ) { rval = null ; } else if ( node . getRight ( dataElement ) != null ) { MST[rv.ROR5Mutator]MSP[S] rval = leastNode ( node . getRight ( dataElement ) , dataElement ) ; } else {
if ( nodeCount == 0 ) { MST[rv.ROR5Mutator]MSP[N] return lr_7 ; } final StringBuilder buf = new StringBuilder ( nodeCount * 32 ) ; buf . append ( '{' ) ; final MapIterator < ? , ? > it = getMapIterator ( dataElement ) ;
final Node < K , V > node = nextSmaller ( lookupKey ( key ) , KEY ) ; return node == null ? null : node . getKey () ; MST[NegateConditionalsMutator]MSP[S] } @Override public Set < K > keySet () { if ( keySet == null ) {
return EmptyOrderedMapIterator . <K , V > emptyOrderedMapIterator () ; } return new ViewMapIterator ( KEY ) ; MST[ConstructorCallMutator]MSP[S] } @Override public OrderedBidiMap < V , K > inverseBidiMap () { if ( inverse == null ) { inverse = new Inverse () ; } return inverse ; } @Override
} else { to . copyColor ( from , dataElement ) ; } } } private static boolean isRed ( final Node < ? , ? > node , final DataElement dataElement ) { return node != null && node . isRed ( dataElement ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] }
node . getParent ( dataElement ) . setRight ( leftChild , dataElement ) ; } else { node . getParent ( dataElement ) . setLeft ( leftChild , dataElement ) ; } leftChild . setRight ( node , dataElement ) ; MST[VoidMethodCallMutator]MSP[S] node . setParent ( leftChild , dataElement ) ;
lr_6 + newNode . getData ( VALUE ) + lr_3 ) ; } else if ( cmp < 0 ) { MST[rv.ROR3Mutator]MSP[S] if ( node . getLeft ( VALUE ) != null ) { node = node . getLeft ( VALUE ) ; } else {
Node < K , V > currentNode = replacementNode ; while ( currentNode != rootNode [ dataElement . ordinal () ] && isBlack ( currentNode , dataElement ) ) { MST[NonVoidMethodCallMutator]MSP[S] if ( currentNode . isLeftChild ( dataElement ) ) {
final Object key = it . next () ; final Object value = it . getValue () ; total += key . hashCode () ^ value . hashCode () ; MST[rv.UOI3Mutator]MSP[S] } } return total ; } private String doToString ( final DataElement dataElement ) {
if ( node . getParent ( dataElement ) == null ) { MST[ArgumentPropagationMutator]MSP[S] rootNode [ dataElement . ordinal () ] = rightChild ; } else if ( node . getParent ( dataElement ) . getLeft ( dataElement ) == node ) {
} else { while ( true ) { final int cmp = compare ( key , node . getKey () ) ; if ( cmp == 0 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] throw new IllegalArgumentException ( lr_2 + key + lr_3 ) ; } else if ( cmp < 0 ) {
. append ( value == this ? lr_8 : value ) ; hasNext = it . hasNext () ; if ( hasNext ) { buf . append ( lr_9 ) ; MST[NonVoidMethodCallMutator]MSP[S] } } buf . append ( '}' ) ; return buf . toString () ; }
private static void makeRed ( final Node < ? , ? > node , final DataElement dataElement ) { if ( node != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] node . setRed ( dataElement ) ; } }
for ( final DataElement dataElement : DataElement . values () ) { if ( deletedNode . getLeft ( dataElement ) != null && deletedNode . getRight ( dataElement ) != null ) { MST[NonVoidMethodCallMutator]MSP[S] swapPosition ( nextGreater ( deletedNode , dataElement ) , deletedNode , dataElement ) ; }
. append ( value == this ? lr_8 : value ) ; hasNext = it . hasNext () ; if ( hasNext ) { buf . append ( lr_9 ) ; } } buf . append ( '}' ) ; MST[experimental.NakedReceiverMutator]MSP[S] return buf . toString () ; }
final Object key = it . next () ; final Object value = it . getValue () ; total += key . hashCode () ^ value . hashCode () ; MST[rv.AOR4Mutator]MSP[S] } } return total ; } private String doToString ( final DataElement dataElement ) {
public Set < Map . Entry < K , V > > entrySet () { if ( entrySet == null ) { entrySet = new EntryView () ; } return entrySet ; } @Override public OrderedMapIterator < K , V > mapIterator () { if ( isEmpty () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S]
return leastNode ( rootNode [ KEY . ordinal () ] , KEY ) . getKey () ; } @Override public K lastKey () { if ( nodeCount == 0 ) { throw new NoSuchElementException ( lr_1 ) ; MST[ConstructorCallMutator]MSP[S] }
if ( node == null ) { MST[rv.ROR5Mutator]MSP[S] rval = null ; } else if ( node . getRight ( dataElement ) != null ) { rval = leastNode ( node . getRight ( dataElement ) , dataElement ) ; } else {
final Map < ? , ? > other = ( Map < ? , ? > ) obj ; if ( other . size () != size () ) { MST[NonVoidMethodCallMutator]MSP[S] return false ; } if ( nodeCount > 0 ) { try {
final Node < K , V > node = nextSmaller ( lookupKey ( key ) , KEY ) ; return node == null ? null : node . getKey () ; } @Override public Set < K > keySet () { if ( keySet == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
} else { to . copyColor ( from , dataElement ) ; } } } private static boolean isRed ( final Node < ? , ? > node , final DataElement dataElement ) { return node != null && node . isRed ( dataElement ) ; MST[rv.CRCR2Mutator]MSP[S] }
} } else { final Node < K , V > y = getLeftChild ( getGrandParent ( currentNode , dataElement ) , dataElement ) ; if ( isRed ( y , dataElement ) ) { makeBlack ( getParent ( currentNode , dataElement ) , dataElement ) ; MST[NonVoidMethodCallMutator]MSP[S]
Objects . requireNonNull ( obj , Objects . toString ( dataElement ) ) ; if ( ! ( obj instanceof Comparable ) ) { throw new ClassCastException ( dataElement + lr_5 ) ; MST[NonVoidMethodCallMutator]MSP[S] } } private static void checkKey ( final Object key ) {
&& currentNode != rootNode [ dataElement . ordinal () ] && isRed ( currentNode . getParent ( dataElement ) , dataElement ) ) { if ( currentNode . isLeftChild ( dataElement ) ) { MST[rv.ROR1Mutator]MSP[S]
return leastNode ( rootNode [ KEY . ordinal () ] , KEY ) . getKey () ; } @Override public K lastKey () { if ( nodeCount == 0 ) { MST[rv.UOI3Mutator]MSP[N] throw new NoSuchElementException ( lr_1 ) ; }
if ( deletedNode . getParent ( dataElement ) == null ) { rootNode [ dataElement . ordinal () ] = null ; } else { if ( isBlack ( deletedNode , dataElement ) ) { MST[NonVoidMethodCallMutator]MSP[S] doRedBlackDeleteFixup ( deletedNode , dataElement ) ; }
private Node < K , V > getLeftChild ( final Node < K , V > node , final DataElement dataElement ) { return node == null ? null : node . getLeft ( dataElement ) ; MST[ReturnValsMutator]MSP[S] }
makeBlack ( y , dataElement ) ; makeRed ( getGrandParent ( currentNode , dataElement ) , dataElement ) ; MST[VoidMethodCallMutator]MSP[S] currentNode = getGrandParent ( currentNode , dataElement ) ; } else { if ( currentNode . isLeftChild ( dataElement ) ) { currentNode = getParent ( currentNode , dataElement ) ;
return doRemoveKey ( key ) ; MST[NonVoidMethodCallMutator]MSP[S] } @Override public void clear () { modify () ; nodeCount = 0 ; rootNode [ KEY . ordinal () ] = null ; rootNode [ VALUE . ordinal () ] = null ; } @Override
final Node < K , V > node = nextGreater ( lookupKey ( key ) , KEY ) ; return node == null ? null : node . getKey () ; } @Override public K previousKey ( final K key ) { checkKey ( key ) ; MST[VoidMethodCallMutator]MSP[S]
return doRemoveKey ( key ) ; } @Override public void clear () { modify () ; nodeCount = 0 ; rootNode [ KEY . ordinal () ] = null ; rootNode [ VALUE . ordinal () ] = null ; MST[NonVoidMethodCallMutator]MSP[S] } @Override
} makeBlack ( getParent ( currentNode , dataElement ) , dataElement ) ; makeRed ( getGrandParent ( currentNode , dataElement ) , dataElement ) ; if ( getGrandParent ( currentNode , dataElement ) != null ) { rotateRight ( getGrandParent ( currentNode , dataElement ) , dataElement ) ; MST[ArgumentPropagationMutator]MSP[S] }
. append ( value == this ? lr_8 : value ) ; hasNext = it . hasNext () ; if ( hasNext ) { buf . append ( lr_9 ) ; } } buf . append ( '}' ) ; MST[rv.CRCR1Mutator]MSP[S] return buf . toString () ; }
if ( cmp == 0 ) { MST[rv.UOI1Mutator]MSP[S] rval = node ; break; } node = cmp < 0 ? node . getLeft ( dataElement ) : node . getRight ( dataElement ) ; } return rval ; }
if ( cmp == 0 ) { rval = node ; break; } node = cmp < 0 ? node . getLeft ( dataElement ) : node . getRight ( dataElement ) ; } return rval ; MST[ReturnValsMutator]MSP[S] }
if ( deletedNode . getParent ( dataElement ) == null ) { rootNode [ dataElement . ordinal () ] = null ; MST[NonVoidMethodCallMutator]MSP[S] } else { if ( isBlack ( deletedNode , dataElement ) ) { doRedBlackDeleteFixup ( deletedNode , dataElement ) ; }
if ( nodeCount == 0 ) { return lr_7 ; } final StringBuilder buf = new StringBuilder ( nodeCount * 32 ) ; buf . append ( '{' ) ; MST[rv.CRCR2Mutator]MSP[S] final MapIterator < ? , ? > it = getMapIterator ( dataElement ) ;
private Node < K , V > getParent ( final Node < K , V > node , final DataElement dataElement ) { return node == null ? null : node . getParent ( dataElement ) ; MST[NegateConditionalsMutator]MSP[S] }
final Node < K , V > node = nextGreater ( lookupKey ( key ) , KEY ) ; return node == null ? null : node . getKey () ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] } @Override public K previousKey ( final K key ) { checkKey ( key ) ;
} private void modify () { modifications ++ ; } private void grow () { modify () ; nodeCount ++ ; MST[rv.UOI2Mutator]MSP[N] } private void shrink () { modify () ; nodeCount -- ; } private void insertValue ( final Node < K , V > newNode ) throws IllegalArgumentException {
boolean hasNext = it . hasNext () ; while ( hasNext ) { final Object key = it . next () ; final Object value = it . getValue () ; buf . append ( key == this ? lr_8 : key ) . append ( '=' ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
Node < K , V > node = rootNode [ dataElement . ordinal () ] ; while ( node != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] final int cmp = compare ( ( T ) data , ( T ) node . getData ( dataElement ) ) ;
final Node < K , V > node = nextSmaller ( lookupKey ( key ) , KEY ) ; return node == null ? null : node . getKey () ; MST[ReturnValsMutator]MSP[S] } @Override public Set < K > keySet () { if ( keySet == null ) {
Objects . requireNonNull ( obj , Objects . toString ( dataElement ) ) ; if ( ! ( obj instanceof Comparable ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] throw new ClassCastException ( dataElement + lr_5 ) ; } } private static void checkKey ( final Object key ) {
} private void modify () { modifications ++ ; } private void grow () { modify () ; nodeCount ++ ; MST[InlineConstantMutator]MSP[N] } private void shrink () { modify () ; nodeCount -- ; } private void insertValue ( final Node < K , V > newNode ) throws IllegalArgumentException {
final Object key = it . next () ; final Object value = it . getValue () ; total += key . hashCode () ^ value . hashCode () ; MST[MathMutator]MSP[N] } } return total ; } private String doToString ( final DataElement dataElement ) {
} else { to . copyColor ( from , dataElement ) ; } } } private static boolean isRed ( final Node < ? , ? > node , final DataElement dataElement ) { return node != null && node . isRed ( dataElement ) ; MST[rv.CRCR5Mutator]MSP[N] }
} private void modify () { modifications ++ ; MST[rv.UOI3Mutator]MSP[N] } private void grow () { modify () ; nodeCount ++ ; } private void shrink () { modify () ; nodeCount -- ; } private void insertValue ( final Node < K , V > newNode ) throws IllegalArgumentException {
if ( deletedNode . getParent ( dataElement ) != null ) { if ( deletedNode == deletedNode . getParent ( dataElement ) . getLeft ( dataElement ) ) { deletedNode . getParent ( dataElement ) . setLeft ( null , dataElement ) ; MST[VoidMethodCallMutator]MSP[N] } else {
if ( nodeCount == 0 ) { return lr_7 ; } final StringBuilder buf = new StringBuilder ( nodeCount * 32 ) ; MST[rv.CRCR4Mutator]MSP[S] buf . append ( '{' ) ; final MapIterator < ? , ? > it = getMapIterator ( dataElement ) ;
private boolean doEquals ( final Object obj , final DataElement dataElement ) { if ( obj == this ) { return true ; } if ( obj instanceof Map == false ) { MST[rv.ROR1Mutator]MSP[N] return false ; }
final Node < K , V > replacement = deletedNode . getLeft ( dataElement ) != null ? MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] deletedNode . getLeft ( dataElement ) : deletedNode . getRight ( dataElement ) ; if ( replacement != null ) {
@Override public String toString () { return description ; } @Override public int size () { return nodeCount ; } @Override public boolean isEmpty () { return nodeCount == 0 ; MST[rv.CRCR6Mutator]MSP[N] } @Override public boolean containsKey ( final Object key ) { checkKey ( key ) ;
final Map < ? , ? > other = ( Map < ? , ? > ) obj ; if ( other . size () != size () ) { return false ; } if ( nodeCount > 0 ) { MST[rv.UOI2Mutator]MSP[N] try {
final Map < ? , ? > other = ( Map < ? , ? > ) obj ; if ( other . size () != size () ) { MST[rv.ROR1Mutator]MSP[N] return false ; } if ( nodeCount > 0 ) { try {
} else { while ( true ) { final int cmp = compare ( key , node . getKey () ) ; MST[NonVoidMethodCallMutator]MSP[S] if ( cmp == 0 ) { throw new IllegalArgumentException ( lr_2 + key + lr_3 ) ; } else if ( cmp < 0 ) {
return this . <V > lookup ( value , VALUE ) ; MST[ReturnValsMutator]MSP[S] } private Node < K , V > nextGreater ( final Node < K , V > node , final DataElement dataElement ) { Node < K , V > rval ;
for ( final DataElement dataElement : DataElement . values () ) { if ( deletedNode . getLeft ( dataElement ) != null && deletedNode . getRight ( dataElement ) != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] swapPosition ( nextGreater ( deletedNode , dataElement ) , deletedNode , dataElement ) ; }
while ( rval . getLeft ( dataElement ) != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] rval = rval . getLeft ( dataElement ) ; } } return rval ; } private Node < K , V > greatestNode ( final Node < K , V > node , final DataElement dataElement ) {
Node < K , V > node = rootNode [ VALUE . ordinal () ] ; while ( true ) { final int cmp = compare ( newNode . getValue () , node . getValue () ) ; if ( cmp == 0 ) { MST[rv.ROR3Mutator]MSP[S] throw new IllegalArgumentException (
Node < K , V > node = rootNode [ VALUE . ordinal () ] ; while ( true ) { final int cmp = compare ( newNode . getValue () , node . getValue () ) ; if ( cmp == 0 ) { MST[rv.UOI2Mutator]MSP[N] throw new IllegalArgumentException (
@Override public String toString () { return description ; } @Override public int size () { return nodeCount ; MST[PrimitiveReturnsMutator]MSP[N] } @Override public boolean isEmpty () { return nodeCount == 0 ; } @Override public boolean containsKey ( final Object key ) { checkKey ( key ) ;
private Node < K , V > getParent ( final Node < K , V > node , final DataElement dataElement ) { return node == null ? null : node . getParent ( dataElement ) ; MST[rv.ROR5Mutator]MSP[S] }
. append ( value == this ? lr_8 : value ) ; hasNext = it . hasNext () ; if ( hasNext ) { buf . append ( lr_9 ) ; } } buf . append ( '}' ) ; MST[InlineConstantMutator]MSP[S] return buf . toString () ; }
final Map < ? , ? > other = ( Map < ? , ? > ) obj ; if ( other . size () != size () ) { return false ; } if ( nodeCount > 0 ) { MST[rv.ROR3Mutator]MSP[N] try {
rotateRight ( currentNode , dataElement ) ; } makeBlack ( getParent ( currentNode , dataElement ) , dataElement ) ; makeRed ( getGrandParent ( currentNode , dataElement ) , dataElement ) ; if ( getGrandParent ( currentNode , dataElement ) != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
for ( final DataElement dataElement : DataElement . values () ) { if ( deletedNode . getLeft ( dataElement ) != null && deletedNode . getRight ( dataElement ) != null ) { MST[NonVoidMethodCallMutator]MSP[N] swapPosition ( nextGreater ( deletedNode , dataElement ) , deletedNode , dataElement ) ; }
return lookupKey ( key ) != null ; } @Override public boolean containsValue ( final Object value ) { checkValue ( value ) ; return lookupValue ( value ) != null ; } @Override public V get ( final Object key ) { checkKey ( key ) ; MST[VoidMethodCallMutator]MSP[N]
Objects . requireNonNull ( obj , Objects . toString ( dataElement ) ) ; if ( ! ( obj instanceof Comparable ) ) { throw new ClassCastException ( dataElement + lr_5 ) ; MST[NonVoidMethodCallMutator]MSP[N] } } private static void checkKey ( final Object key ) {
deletedNode . getParent ( dataElement ) . setRight ( null , dataElement ) ; MST[NonVoidMethodCallMutator]MSP[S] } deletedNode . setParent ( null , dataElement ) ; } } } } shrink () ; } private void doRedBlackDeleteFixup ( final Node < K , V > replacementNode , final DataElement dataElement ) {
private static boolean isBlack ( final Node < ? , ? > node , final DataElement dataElement ) { return node == null || node . isBlack ( dataElement ) ; MST[InlineConstantMutator]MSP[N] }
private MapIterator < ? , ? > getMapIterator ( final DataElement dataElement ) { switch ( dataElement ) { case KEY : return new ViewMapIterator ( KEY ) ; MST[NullReturnValsMutator]MSP[N] case VALUE : return new InverseViewMapIterator ( VALUE ) ; default: throw new IllegalArgumentException () ; } }
} private void modify () { modifications ++ ; } private void grow () { modify () ; nodeCount ++ ; } private void shrink () { modify () ; nodeCount -- ; MST[MathMutator]MSP[N] } private void insertValue ( final Node < K , V > newNode ) throws IllegalArgumentException {
return EmptyOrderedMapIterator . <K , V > emptyOrderedMapIterator () ; } return new ViewMapIterator ( KEY ) ; } @Override public OrderedBidiMap < V , K > inverseBidiMap () { if ( inverse == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] inverse = new Inverse () ; } return inverse ; } @Override
for ( final DataElement dataElement : DataElement . values () ) { MST[rv.UOI3Mutator]MSP[S] if ( deletedNode . getLeft ( dataElement ) != null && deletedNode . getRight ( dataElement ) != null ) { swapPosition ( nextGreater ( deletedNode , dataElement ) , deletedNode , dataElement ) ; }
public boolean equals ( final Object obj ) { return this . doEquals ( obj , KEY ) ; } @Override public int hashCode () { return this . doHashCode ( KEY ) ; } @Override public String toString () { return this . doToString ( KEY ) ; MST[EmptyObjectReturnValsMutator]MSP[N] }
Node < K , V > node = rootNode [ VALUE . ordinal () ] ; while ( true ) { final int cmp = compare ( newNode . getValue () , node . getValue () ) ; if ( cmp == 0 ) { MST[rv.ABSMutator]MSP[N] throw new IllegalArgumentException (
boolean hasNext = it . hasNext () ; while ( hasNext ) { final Object key = it . next () ; final Object value = it . getValue () ; buf . append ( key == this ? lr_8 : key ) MST[rv.CRCR5Mutator]MSP[S] . append ( '=' )
} else { to . copyColor ( from , dataElement ) ; } } } private static boolean isRed ( final Node < ? , ? > node , final DataElement dataElement ) { return node != null && node . isRed ( dataElement ) ; MST[NegateConditionalsMutator]MSP[N] }
checkNonNullComparable ( key , KEY ) ; } private static void checkValue ( final Object value ) { checkNonNullComparable ( value , VALUE ) ; MST[VoidMethodCallMutator]MSP[N] } private static void checkKeyAndValue ( final Object key , final Object value ) { checkKey ( key ) ; checkValue ( value ) ;
return doRemoveKey ( key ) ; } @Override public void clear () { modify () ; nodeCount = 0 ; MST[InlineConstantMutator]MSP[N] rootNode [ KEY . ordinal () ] = null ; rootNode [ VALUE . ordinal () ] = null ; } @Override
final Node < K , V > replacement = deletedNode . getLeft ( dataElement ) != null ? MST[NonVoidMethodCallMutator]MSP[N] deletedNode . getLeft ( dataElement ) : deletedNode . getRight ( dataElement ) ; if ( replacement != null ) {
makeRed ( getGrandParent ( currentNode , dataElement ) , dataElement ) ; currentNode = getGrandParent ( currentNode , dataElement ) ; } else { if ( currentNode . isRightChild ( dataElement ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] currentNode = getParent ( currentNode , dataElement ) ; rotateLeft ( currentNode , dataElement ) ;
makeRed ( getGrandParent ( currentNode , dataElement ) , dataElement ) ; currentNode = getGrandParent ( currentNode , dataElement ) ; } else { if ( currentNode . isRightChild ( dataElement ) ) { MST[rv.ROR3Mutator]MSP[N] currentNode = getParent ( currentNode , dataElement ) ; rotateLeft ( currentNode , dataElement ) ;
return lookupKey ( key ) != null ; } @Override public boolean containsValue ( final Object value ) { checkValue ( value ) ; return lookupValue ( value ) != null ; MST[rv.CRCR6Mutator]MSP[N] } @Override public V get ( final Object key ) { checkKey ( key ) ;
final Map < ? , ? > other = ( Map < ? , ? > ) obj ; if ( other . size () != size () ) { return false ; } if ( nodeCount > 0 ) { MST[rv.ABSMutator]MSP[N] try {
public K getKey ( final Object value ) { checkValue ( value ) ; final Node < K , V > node = lookupValue ( value ) ; return node == null ? null : node . getKey () ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] } @Override
keySet = new KeyView ( KEY ) ; } return keySet ; MST[ReturnValsMutator]MSP[S] } @Override public Set < V > values () { if ( valuesSet == null ) { valuesSet = new ValueView ( KEY ) ; } return valuesSet ; } @Override
&& currentNode != rootNode [ dataElement . ordinal () ] && isRed ( currentNode . getParent ( dataElement ) , dataElement ) ) { MST[NonVoidMethodCallMutator]MSP[N] if ( currentNode . isLeftChild ( dataElement ) ) {
if ( node == null ) { return null ; } doRedBlackDelete ( node ) ; return node . getValue () ; MST[NullReturnValsMutator]MSP[N] } private K doRemoveValue ( final Object value ) { final Node < K , V > node = lookupValue ( value ) ;
} private void modify () { modifications ++ ; MST[MathMutator]MSP[N] } private void grow () { modify () ; nodeCount ++ ; } private void shrink () { modify () ; nodeCount -- ; } private void insertValue ( final Node < K , V > newNode ) throws IllegalArgumentException {
if ( node == null ) { return null ; } doRedBlackDelete ( node ) ; return node . getKey () ; MST[NonVoidMethodCallMutator]MSP[N] } @SuppressWarnings ( lr_4 )
final Object key = it . next () ; final Object value = it . getValue () ; total += key . hashCode () ^ value . hashCode () ; MST[rv.ABSMutator]MSP[N] } } return total ; } private String doToString ( final DataElement dataElement ) {
} makeBlack ( getParent ( currentNode , dataElement ) , dataElement ) ; MST[NonVoidMethodCallMutator]MSP[N] makeRed ( getGrandParent ( currentNode , dataElement ) , dataElement ) ; if ( getGrandParent ( currentNode , dataElement ) != null ) { rotateRight ( getGrandParent ( currentNode , dataElement ) , dataElement ) ; }
private MapIterator < ? , ? > getMapIterator ( final DataElement dataElement ) { switch ( dataElement ) { MST[rv.UOI1Mutator]MSP[S] case KEY : return new ViewMapIterator ( KEY ) ; case VALUE : return new InverseViewMapIterator ( VALUE ) ; default: throw new IllegalArgumentException () ; } }
private int doHashCode ( final DataElement dataElement ) { int total = 0 ; if ( nodeCount > 0 ) { for ( final MapIterator < ? , ? > it = getMapIterator ( dataElement ) ; it . hasNext () ; ) { MST[rv.ROR4Mutator]MSP[S]
private void doPut ( final K key , final V value ) { checkKeyAndValue ( key , value ) ; doRemoveKey ( key ) ; doRemoveValue ( value ) ; MST[NonVoidMethodCallMutator]MSP[S] Node < K , V > node = rootNode [ KEY . ordinal () ] ;
} else { to . copyColor ( from , dataElement ) ; } } } private static boolean isRed ( final Node < ? , ? > node , final DataElement dataElement ) { return node != null && node . isRed ( dataElement ) ; MST[rv.ROR5Mutator]MSP[S] }
final Object key = it . next () ; final Object value = it . getValue () ; MST[NonVoidMethodCallMutator]MSP[S] total += key . hashCode () ^ value . hashCode () ; } } return total ; } private String doToString ( final DataElement dataElement ) {
return lookupKey ( key ) != null ; MST[rv.CRCR1Mutator]MSP[N] } @Override public boolean containsValue ( final Object value ) { checkValue ( value ) ; return lookupValue ( value ) != null ; } @Override public V get ( final Object key ) { checkKey ( key ) ;
if ( nodeCount == 0 ) { return lr_7 ; MST[EmptyObjectReturnValsMutator]MSP[N] } final StringBuilder buf = new StringBuilder ( nodeCount * 32 ) ; buf . append ( '{' ) ; final MapIterator < ? , ? > it = getMapIterator ( dataElement ) ;
if ( cmp == 0 ) { MST[rv.ROR2Mutator]MSP[S] rval = node ; break; } node = cmp < 0 ? node . getLeft ( dataElement ) : node . getRight ( dataElement ) ; } return rval ; }
keySet = new KeyView ( KEY ) ; } return keySet ; } @Override public Set < V > values () { if ( valuesSet == null ) { valuesSet = new ValueView ( KEY ) ; MST[experimental.MemberVariableMutator]MSP[S] } return valuesSet ; } @Override
return leastNode ( rootNode [ KEY . ordinal () ] , KEY ) . getKey () ; MST[ReturnValsMutator]MSP[S] } @Override public K lastKey () { if ( nodeCount == 0 ) { throw new NoSuchElementException ( lr_1 ) ; }
if ( nodeCount == 0 ) { MST[rv.UOI2Mutator]MSP[N] return lr_7 ; } final StringBuilder buf = new StringBuilder ( nodeCount * 32 ) ; buf . append ( '{' ) ; final MapIterator < ? , ? > it = getMapIterator ( dataElement ) ;
makeRed ( getGrandParent ( currentNode , dataElement ) , dataElement ) ; currentNode = getGrandParent ( currentNode , dataElement ) ; } else { if ( currentNode . isRightChild ( dataElement ) ) { MST[NonVoidMethodCallMutator]MSP[S] currentNode = getParent ( currentNode , dataElement ) ; rotateLeft ( currentNode , dataElement ) ;
} private void modify () { modifications ++ ; } private void grow () { modify () ; nodeCount ++ ; } private void shrink () { modify () ; nodeCount -- ; MST[rv.CRCR5Mutator]MSP[S] } private void insertValue ( final Node < K , V > newNode ) throws IllegalArgumentException {
} } else { final Node < K , V > y = getLeftChild ( getGrandParent ( currentNode , dataElement ) , dataElement ) ; if ( isRed ( y , dataElement ) ) { MST[rv.ROR4Mutator]MSP[S] makeBlack ( getParent ( currentNode , dataElement ) , dataElement ) ;
private Node < K , V > getParent ( final Node < K , V > node , final DataElement dataElement ) { return node == null ? null : node . getParent ( dataElement ) ; MST[ReturnValsMutator]MSP[S] }
if ( node . getParent ( dataElement ) == null ) { MST[NonVoidMethodCallMutator]MSP[S] rootNode [ dataElement . ordinal () ] = leftChild ; } else if ( node . getParent ( dataElement ) . getRight ( dataElement ) == node ) {
} makeBlack ( getParent ( currentNode , dataElement ) , dataElement ) ; makeRed ( getGrandParent ( currentNode , dataElement ) , dataElement ) ; MST[VoidMethodCallMutator]MSP[S] if ( getGrandParent ( currentNode , dataElement ) != null ) { rotateRight ( getGrandParent ( currentNode , dataElement ) , dataElement ) ; }
return leastNode ( rootNode [ KEY . ordinal () ] , KEY ) . getKey () ; } @Override public K lastKey () { if ( nodeCount == 0 ) { MST[rv.ROR3Mutator]MSP[S] throw new NoSuchElementException ( lr_1 ) ; }
boolean hasNext = it . hasNext () ; while ( hasNext ) { MST[rv.UOI3Mutator]MSP[S] final Object key = it . next () ; final Object value = it . getValue () ; buf . append ( key == this ? lr_8 : key ) . append ( '=' )
@Override public String toString () { return description ; } @Override public int size () { return nodeCount ; } @Override public boolean isEmpty () { return nodeCount == 0 ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } @Override public boolean containsKey ( final Object key ) { checkKey ( key ) ;
return EmptyOrderedMapIterator . <K , V > emptyOrderedMapIterator () ; } return new ViewMapIterator ( KEY ) ; } @Override public OrderedBidiMap < V , K > inverseBidiMap () { if ( inverse == null ) { inverse = new Inverse () ; MST[ConstructorCallMutator]MSP[S] } return inverse ; } @Override
. append ( value == this ? lr_8 : value ) ; hasNext = it . hasNext () ; if ( hasNext ) { MST[NegateConditionalsMutator]MSP[S] buf . append ( lr_9 ) ; } } buf . append ( '}' ) ; return buf . toString () ; }
} else if ( deletedNode == deletedNode . getParent ( dataElement ) . getLeft ( dataElement ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] deletedNode . getParent ( dataElement ) . setLeft ( replacement , dataElement ) ; } else { deletedNode . getParent ( dataElement ) . setRight ( replacement , dataElement ) ;
for ( final DataElement dataElement : DataElement . values () ) { MST[rv.UOI4Mutator]MSP[S] if ( deletedNode . getLeft ( dataElement ) != null && deletedNode . getRight ( dataElement ) != null ) { swapPosition ( nextGreater ( deletedNode , dataElement ) , deletedNode , dataElement ) ; }
private static boolean isBlack ( final Node < ? , ? > node , final DataElement dataElement ) { return node == null || node . isBlack ( dataElement ) ; MST[rv.ROR2Mutator]MSP[S] }
if ( node == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] return null ; } doRedBlackDelete ( node ) ; return node . getValue () ; } private K doRemoveValue ( final Object value ) { final Node < K , V > node = lookupValue ( value ) ;
&& currentNode != rootNode [ dataElement . ordinal () ] && isRed ( currentNode . getParent ( dataElement ) , dataElement ) ) { if ( currentNode . isLeftChild ( dataElement ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S]
Node < K , V > currentNode = replacementNode ; while ( currentNode != rootNode [ dataElement . ordinal () ] && isBlack ( currentNode , dataElement ) ) { MST[NonVoidMethodCallMutator]MSP[S] if ( currentNode . isLeftChild ( dataElement ) ) {
} else { to . copyColor ( from , dataElement ) ; } } } private static boolean isRed ( final Node < ? , ? > node , final DataElement dataElement ) { return node != null && node . isRed ( dataElement ) ; MST[rv.CRCR5Mutator]MSP[S] }
public boolean equals ( final Object obj ) { return this . doEquals ( obj , KEY ) ; } @Override public int hashCode () { return this . doHashCode ( KEY ) ; MST[PrimitiveReturnsMutator]MSP[S] } @Override public String toString () { return this . doToString ( KEY ) ; }
boolean hasNext = it . hasNext () ; while ( hasNext ) { MST[rv.ROR4Mutator]MSP[S] final Object key = it . next () ; final Object value = it . getValue () ; buf . append ( key == this ? lr_8 : key ) . append ( '=' )
@Override public String toString () { return description ; } @Override public int size () { return nodeCount ; } @Override public boolean isEmpty () { return nodeCount == 0 ; } @Override public boolean containsKey ( final Object key ) { checkKey ( key ) ; MST[VoidMethodCallMutator]MSP[N]
@Override public String toString () { return description ; } @Override public int size () { return nodeCount ; } @Override public boolean isEmpty () { return nodeCount == 0 ; MST[rv.CRCR6Mutator]MSP[N] } @Override public boolean containsKey ( final Object key ) { checkKey ( key ) ;
boolean hasNext = it . hasNext () ; while ( hasNext ) { final Object key = it . next () ; final Object value = it . getValue () ; buf . append ( key == this ? lr_8 : key ) MST[rv.CRCR2Mutator]MSP[S] . append ( '=' )
public K getKey ( final Object value ) { checkValue ( value ) ; final Node < K , V > node = lookupValue ( value ) ; return node == null ? null : node . getKey () ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] } @Override
} else if ( deletedNode == deletedNode . getParent ( dataElement ) . getLeft ( dataElement ) ) { deletedNode . getParent ( dataElement ) . setLeft ( replacement , dataElement ) ; } else { deletedNode . getParent ( dataElement ) . setRight ( replacement , dataElement ) ; MST[VoidMethodCallMutator]MSP[S]
return leastNode ( rootNode [ KEY . ordinal () ] , KEY ) . getKey () ; MST[ArgumentPropagationMutator]MSP[S] } @Override public K lastKey () { if ( nodeCount == 0 ) { throw new NoSuchElementException ( lr_1 ) ; }
if ( leftChild . getRight ( dataElement ) != null ) { MST[ArgumentPropagationMutator]MSP[S] leftChild . getRight ( dataElement ) . setParent ( node , dataElement ) ; } leftChild . setParent ( node . getParent ( dataElement ) , dataElement ) ;
private static boolean isBlack ( final Node < ? , ? > node , final DataElement dataElement ) { return node == null || node . isBlack ( dataElement ) ; MST[rv.ROR5Mutator]MSP[S] }
} else { while ( true ) { final int cmp = compare ( key , node . getKey () ) ; if ( cmp == 0 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] throw new IllegalArgumentException ( lr_2 + key + lr_3 ) ; } else if ( cmp < 0 ) {
} private void rotateRight ( final Node < K , V > node , final DataElement dataElement ) { final Node < K , V > leftChild = node . getLeft ( dataElement ) ; node . setLeft ( leftChild . getRight ( dataElement ) , dataElement ) ; MST[VoidMethodCallMutator]MSP[S]
} deletedNode . setLeft ( null , dataElement ) ; deletedNode . setRight ( null , dataElement ) ; MST[VoidMethodCallMutator]MSP[S] deletedNode . setParent ( null , dataElement ) ; if ( isBlack ( deletedNode , dataElement ) ) { doRedBlackDeleteFixup ( replacement , dataElement ) ; } } else {
private boolean doEquals ( final Object obj , final DataElement dataElement ) { if ( obj == this ) { MST[NegateConditionalsMutator]MSP[N] return true ; } if ( obj instanceof Map == false ) { return false ; }
if ( cmp == 0 ) { MST[NegateConditionalsMutator]MSP[S] rval = node ; break; } node = cmp < 0 ? node . getLeft ( dataElement ) : node . getRight ( dataElement ) ; } return rval ; }
rotateRight ( currentNode , dataElement ) ; } makeBlack ( getParent ( currentNode , dataElement ) , dataElement ) ; makeRed ( getGrandParent ( currentNode , dataElement ) , dataElement ) ; MST[NonVoidMethodCallMutator]MSP[S] if ( getGrandParent ( currentNode , dataElement ) != null ) {
if ( deletedNode . getParent ( dataElement ) != null ) { if ( deletedNode == deletedNode . getParent ( dataElement ) . getLeft ( dataElement ) ) { deletedNode . getParent ( dataElement ) . setLeft ( null , dataElement ) ; MST[ArgumentPropagationMutator]MSP[S] } else {
private static boolean isBlack ( final Node < ? , ? > node , final DataElement dataElement ) { return node == null || node . isBlack ( dataElement ) ; MST[InlineConstantMutator]MSP[S] }
} else { while ( true ) { final int cmp = compare ( key , node . getKey () ) ; if ( cmp == 0 ) { MST[rv.ROR3Mutator]MSP[S] throw new IllegalArgumentException ( lr_2 + key + lr_3 ) ; } else if ( cmp < 0 ) {
private static void makeBlack ( final Node < ? , ? > node , final DataElement dataElement ) { if ( node != null ) { MST[NegateConditionalsMutator]MSP[S] node . setBlack ( dataElement ) ; } }
if ( value . equals ( other . get ( key ) ) == false ) { MST[rv.ROR4Mutator]MSP[S] return false ; } } } catch ( final ClassCastException ex ) { return false ; } catch ( final NullPointerException ex ) { return false ; } } return true ; }
private Node < K , V > getRightChild ( final Node < K , V > node , final DataElement dataElement ) { return node == null ? null : node . getRight ( dataElement ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] }
boolean hasNext = it . hasNext () ; while ( hasNext ) { final Object key = it . next () ; final Object value = it . getValue () ; buf . append ( key == this ? lr_8 : key ) MST[NegateConditionalsMutator]MSP[S] . append ( '=' )
} private void rotateRight ( final Node < K , V > node , final DataElement dataElement ) { final Node < K , V > leftChild = node . getLeft ( dataElement ) ; node . setLeft ( leftChild . getRight ( dataElement ) , dataElement ) ; MST[NonVoidMethodCallMutator]MSP[S]
replacement . setParent ( deletedNode . getParent ( dataElement ) , dataElement ) ; if ( deletedNode . getParent ( dataElement ) == null ) { MST[NegateConditionalsMutator]MSP[S] rootNode [ dataElement . ordinal () ] = replacement ;
} else { to . copyColor ( from , dataElement ) ; } } } private static boolean isRed ( final Node < ? , ? > node , final DataElement dataElement ) { return node != null && node . isRed ( dataElement ) ; MST[NegateConditionalsMutator]MSP[S] }
} deletedNode . setLeft ( null , dataElement ) ; deletedNode . setRight ( null , dataElement ) ; deletedNode . setParent ( null , dataElement ) ; if ( isBlack ( deletedNode , dataElement ) ) { MST[rv.ROR3Mutator]MSP[S] doRedBlackDeleteFixup ( replacement , dataElement ) ; } } else {
if ( node . getParent ( dataElement ) == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] rootNode [ dataElement . ordinal () ] = leftChild ; } else if ( node . getParent ( dataElement ) . getRight ( dataElement ) == node ) {
} private void modify () { modifications ++ ; } private void grow () { modify () ; nodeCount ++ ; } private void shrink () { modify () ; nodeCount -- ; MST[rv.UOI3Mutator]MSP[S] } private void insertValue ( final Node < K , V > newNode ) throws IllegalArgumentException {
public K removeValue ( final Object value ) { return doRemoveValue ( value ) ; MST[NullReturnValsMutator]MSP[S] } @Override public K firstKey () { if ( nodeCount == 0 ) { throw new NoSuchElementException ( lr_1 ) ; }
if ( node . getParent ( dataElement ) == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] rootNode [ dataElement . ordinal () ] = rightChild ; } else if ( node . getParent ( dataElement ) . getLeft ( dataElement ) == node ) {
private void rotateLeft ( final Node < K , V > node , final DataElement dataElement ) { final Node < K , V > rightChild = node . getRight ( dataElement ) ; node . setRight ( rightChild . getLeft ( dataElement ) , dataElement ) ; MST[VoidMethodCallMutator]MSP[S]
return leastNode ( rootNode [ KEY . ordinal () ] , KEY ) . getKey () ; MST[NonVoidMethodCallMutator]MSP[S] } @Override public K lastKey () { if ( nodeCount == 0 ) { throw new NoSuchElementException ( lr_1 ) ; }
. append ( value == this ? lr_8 : value ) ; hasNext = it . hasNext () ; if ( hasNext ) { buf . append ( lr_9 ) ; } } buf . append ( '}' ) ; MST[rv.CRCR4Mutator]MSP[S] return buf . toString () ; }
public Set < Map . Entry < K , V > > entrySet () { if ( entrySet == null ) { entrySet = new EntryView () ; } return entrySet ; } @Override public OrderedMapIterator < K , V > mapIterator () { if ( isEmpty () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S]
@Override public String toString () { return description ; } @Override MST[experimental.MemberVariableMutator]MSP[S] public int size () { return nodeCount ; } @Override public boolean isEmpty () { return nodeCount == 0 ; } @Override public boolean containsKey ( final Object key ) { checkKey ( key ) ;
} else if ( deletedNode == deletedNode . getParent ( dataElement ) . getLeft ( dataElement ) ) { MST[NonVoidMethodCallMutator]MSP[S] deletedNode . getParent ( dataElement ) . setLeft ( replacement , dataElement ) ; } else { deletedNode . getParent ( dataElement ) . setRight ( replacement , dataElement ) ;
private MapIterator < ? , ? > getMapIterator ( final DataElement dataElement ) { switch ( dataElement ) { MST[NonVoidMethodCallMutator]MSP[S] case KEY : return new ViewMapIterator ( KEY ) ; case VALUE : return new InverseViewMapIterator ( VALUE ) ; default: throw new IllegalArgumentException () ; } }
if ( rightChild . getLeft ( dataElement ) != null ) { MST[ArgumentPropagationMutator]MSP[S] rightChild . getLeft ( dataElement ) . setParent ( node , dataElement ) ; } rightChild . setParent ( node . getParent ( dataElement ) , dataElement ) ;
@Override public String toString () { return description ; } @Override public int size () { return nodeCount ; } @Override public boolean isEmpty () { return nodeCount == 0 ; MST[rv.ABSMutator]MSP[S] } @Override public boolean containsKey ( final Object key ) { checkKey ( key ) ;
public boolean equals ( final Object obj ) { return this . doEquals ( obj , KEY ) ; MST[BooleanTrueReturnValsMutator]MSP[N] } @Override public int hashCode () { return this . doHashCode ( KEY ) ; } @Override public String toString () { return this . doToString ( KEY ) ; }
private int doHashCode ( final DataElement dataElement ) { int total = 0 ; if ( nodeCount > 0 ) { MST[rv.UOI2Mutator]MSP[N] for ( final MapIterator < ? , ? > it = getMapIterator ( dataElement ) ; it . hasNext () ; ) {
if ( nodeCount == 0 ) { return lr_7 ; } final StringBuilder buf = new StringBuilder ( nodeCount * 32 ) ; MST[rv.CRCR1Mutator]MSP[S] buf . append ( '{' ) ; final MapIterator < ? , ? > it = getMapIterator ( dataElement ) ;
. append ( value == this ? lr_8 : value ) ; hasNext = it . hasNext () ; if ( hasNext ) { MST[rv.ROR5Mutator]MSP[S] buf . append ( lr_9 ) ; } } buf . append ( '}' ) ; return buf . toString () ; }
Objects . requireNonNull ( obj , Objects . toString ( dataElement ) ) ; if ( ! ( obj instanceof Comparable ) ) { throw new ClassCastException ( dataElement + lr_5 ) ; MST[experimental.NakedReceiverMutator]MSP[S] } } private static void checkKey ( final Object key ) {
if ( nodeCount == 0 ) { MST[rv.ROR3Mutator]MSP[S] return lr_7 ; } final StringBuilder buf = new StringBuilder ( nodeCount * 32 ) ; buf . append ( '{' ) ; final MapIterator < ? , ? > it = getMapIterator ( dataElement ) ;
if ( nodeCount == 0 ) { return lr_7 ; } final StringBuilder buf = new StringBuilder ( nodeCount * 32 ) ; buf . append ( '{' ) ; MST[NonVoidMethodCallMutator]MSP[S] final MapIterator < ? , ? > it = getMapIterator ( dataElement ) ;
} else { to . copyColor ( from , dataElement ) ; } } } private static boolean isRed ( final Node < ? , ? > node , final DataElement dataElement ) { return node != null && node . isRed ( dataElement ) ; MST[rv.ROR5Mutator]MSP[S] }
public boolean equals ( final Object obj ) { return this . doEquals ( obj , KEY ) ; } @Override public int hashCode () { return this . doHashCode ( KEY ) ; } @Override public String toString () { return this . doToString ( KEY ) ; MST[NonVoidMethodCallMutator]MSP[N] }
parent = parent . getParent ( dataElement ) ; MST[NonVoidMethodCallMutator]MSP[S] } rval = parent ; } return rval ; } private Node < K , V > nextSmaller ( final Node < K , V > node , final DataElement dataElement ) { Node < K , V > rval ;
if ( cmp == 0 ) { rval = node ; break; } node = cmp < 0 ? node . getLeft ( dataElement ) : node . getRight ( dataElement ) ; MST[rv.UOI2Mutator]MSP[S] } return rval ; }
boolean hasNext = it . hasNext () ; while ( hasNext ) { final Object key = it . next () ; final Object value = it . getValue () ; buf . append ( key == this ? lr_8 : key ) MST[experimental.NakedReceiverMutator]MSP[S] . append ( '=' )
if ( deletedNode . getParent ( dataElement ) != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] if ( deletedNode == deletedNode . getParent ( dataElement ) . getLeft ( dataElement ) ) { deletedNode . getParent ( dataElement ) . setLeft ( null , dataElement ) ; } else {
public K removeValue ( final Object value ) { return doRemoveValue ( value ) ; } @Override public K firstKey () { if ( nodeCount == 0 ) { MST[rv.UOI1Mutator]MSP[N] throw new NoSuchElementException ( lr_1 ) ; }
keySet = new KeyView ( KEY ) ; MST[experimental.MemberVariableMutator]MSP[S] } return keySet ; } @Override public Set < V > values () { if ( valuesSet == null ) { valuesSet = new ValueView ( KEY ) ; } return valuesSet ; } @Override
Node < K , V > currentNode = replacementNode ; while ( currentNode != rootNode [ dataElement . ordinal () ] && isBlack ( currentNode , dataElement ) ) { MST[rv.ROR5Mutator]MSP[S] if ( currentNode . isLeftChild ( dataElement ) ) {
rotateRight ( currentNode , dataElement ) ; } makeBlack ( getParent ( currentNode , dataElement ) , dataElement ) ; makeRed ( getGrandParent ( currentNode , dataElement ) , dataElement ) ; if ( getGrandParent ( currentNode , dataElement ) != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S]
if ( cmp == 0 ) { rval = node ; break; } node = cmp < 0 ? node . getLeft ( dataElement ) : node . getRight ( dataElement ) ; MST[rv.ROR3Mutator]MSP[S] } return rval ; }
for ( final DataElement dataElement : DataElement . values () ) { MST[rv.UOI4Mutator]MSP[S] if ( deletedNode . getLeft ( dataElement ) != null && deletedNode . getRight ( dataElement ) != null ) { swapPosition ( nextGreater ( deletedNode , dataElement ) , deletedNode , dataElement ) ; }
if ( leftChild . getRight ( dataElement ) != null ) { MST[rv.ROR5Mutator]MSP[S] leftChild . getRight ( dataElement ) . setParent ( node , dataElement ) ; } leftChild . setParent ( node . getParent ( dataElement ) , dataElement ) ;
makeBlack ( y , dataElement ) ; makeRed ( getGrandParent ( currentNode , dataElement ) , dataElement ) ; MST[ArgumentPropagationMutator]MSP[S] currentNode = getGrandParent ( currentNode , dataElement ) ; } else { if ( currentNode . isLeftChild ( dataElement ) ) { currentNode = getParent ( currentNode , dataElement ) ;
makeBlack ( y , dataElement ) ; makeRed ( getGrandParent ( currentNode , dataElement ) , dataElement ) ; currentNode = getGrandParent ( currentNode , dataElement ) ; } else { if ( currentNode . isLeftChild ( dataElement ) ) { MST[rv.ROR2Mutator]MSP[S] currentNode = getParent ( currentNode , dataElement ) ;
for ( final DataElement dataElement : DataElement . values () ) { if ( deletedNode . getLeft ( dataElement ) != null && deletedNode . getRight ( dataElement ) != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] swapPosition ( nextGreater ( deletedNode , dataElement ) , deletedNode , dataElement ) ; }
node . setLeft ( newNode , KEY ) ; newNode . setParent ( node , KEY ) ; doRedBlackInsert ( newNode , KEY ) ; grow () ; break; } } else { if ( node . getRight ( KEY ) != null ) { MST[ArgumentPropagationMutator]MSP[S]
private static boolean isBlack ( final Node < ? , ? > node , final DataElement dataElement ) { return node == null || node . isBlack ( dataElement ) ; MST[NegateConditionalsMutator]MSP[S] }
private int doHashCode ( final DataElement dataElement ) { int total = 0 ; MST[rv.CRCR5Mutator]MSP[S] if ( nodeCount > 0 ) { for ( final MapIterator < ? , ? > it = getMapIterator ( dataElement ) ; it . hasNext () ; ) {
boolean hasNext = it . hasNext () ; while ( hasNext ) { final Object key = it . next () ; final Object value = it . getValue () ; MST[NonVoidMethodCallMutator]MSP[S] buf . append ( key == this ? lr_8 : key ) . append ( '=' )
public boolean equals ( final Object obj ) { return this . doEquals ( obj , KEY ) ; MST[ReturnValsMutator]MSP[N] } @Override public int hashCode () { return this . doHashCode ( KEY ) ; } @Override public String toString () { return this . doToString ( KEY ) ; }
private Node < K , V > getGrandParent ( final Node < K , V > node , final DataElement dataElement ) { return getParent ( getParent ( node , dataElement ) , dataElement ) ; MST[ReturnValsMutator]MSP[S] }
private MapIterator < ? , ? > getMapIterator ( final DataElement dataElement ) { switch ( dataElement ) { MST[experimental.SwitchMutator]MSP[S] case KEY : return new ViewMapIterator ( KEY ) ; case VALUE : return new InverseViewMapIterator ( VALUE ) ; default: throw new IllegalArgumentException () ; } }
final Node < K , V > y = getRightChild ( getGrandParent ( currentNode , dataElement ) , dataElement ) ; if ( isRed ( y , dataElement ) ) { MST[rv.ROR4Mutator]MSP[S] makeBlack ( getParent ( currentNode , dataElement ) , dataElement ) ; makeBlack ( y , dataElement ) ;
final Node < K , V > replacement = deletedNode . getLeft ( dataElement ) != null ? MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] deletedNode . getLeft ( dataElement ) : deletedNode . getRight ( dataElement ) ; if ( replacement != null ) {
Node < K , V > node = rootNode [ dataElement . ordinal () ] ; while ( node != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] final int cmp = compare ( ( T ) data , ( T ) node . getData ( dataElement ) ) ;
Node < K , V > rval = node ; if ( rval != null ) { while ( rval . getRight ( dataElement ) != null ) { MST[NegateConditionalsMutator]MSP[S] rval = rval . getRight ( dataElement ) ; } } return rval ; }
@Override public String toString () { return description ; } @Override public int size () { return nodeCount ; } @Override public boolean isEmpty () { return nodeCount == 0 ; MST[rv.CRCR3Mutator]MSP[S] } @Override public boolean containsKey ( final Object key ) { checkKey ( key ) ;
} private void modify () { modifications ++ ; MST[rv.CRCR2Mutator]MSP[S] } private void grow () { modify () ; nodeCount ++ ; } private void shrink () { modify () ; nodeCount -- ; } private void insertValue ( final Node < K , V > newNode ) throws IllegalArgumentException {
} } else { final Node < K , V > y = getLeftChild ( getGrandParent ( currentNode , dataElement ) , dataElement ) ; if ( isRed ( y , dataElement ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] makeBlack ( getParent ( currentNode , dataElement ) , dataElement ) ;
private Node < K , V > getRightChild ( final Node < K , V > node , final DataElement dataElement ) { return node == null ? null : node . getRight ( dataElement ) ; MST[ArgumentPropagationMutator]MSP[S] }
replacement . setParent ( deletedNode . getParent ( dataElement ) , dataElement ) ; MST[NonVoidMethodCallMutator]MSP[S] if ( deletedNode . getParent ( dataElement ) == null ) { rootNode [ dataElement . ordinal () ] = replacement ;
for ( final DataElement dataElement : DataElement . values () ) { MST[rv.UOI1Mutator]MSP[S] if ( deletedNode . getLeft ( dataElement ) != null && deletedNode . getRight ( dataElement ) != null ) { swapPosition ( nextGreater ( deletedNode , dataElement ) , deletedNode , dataElement ) ; }
while ( rval . getLeft ( dataElement ) != null ) { MST[NonVoidMethodCallMutator]MSP[S] rval = rval . getLeft ( dataElement ) ; } } return rval ; } private Node < K , V > greatestNode ( final Node < K , V > node , final DataElement dataElement ) {
private static boolean isBlack ( final Node < ? , ? > node , final DataElement dataElement ) { return node == null || node . isBlack ( dataElement ) ; MST[rv.ROR5Mutator]MSP[S] }
if ( node . getParent ( dataElement ) == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] rootNode [ dataElement . ordinal () ] = leftChild ; } else if ( node . getParent ( dataElement ) . getRight ( dataElement ) == node ) {
return doRemoveKey ( key ) ; MST[NullReturnValsMutator]MSP[S] } @Override public void clear () { modify () ; nodeCount = 0 ; rootNode [ KEY . ordinal () ] = null ; rootNode [ VALUE . ordinal () ] = null ; } @Override
final Node < K , V > node = nextSmaller ( lookupKey ( key ) , KEY ) ; return node == null ? null : node . getKey () ; } @Override public Set < K > keySet () { if ( keySet == null ) { MST[NegateConditionalsMutator]MSP[S]
private int doHashCode ( final DataElement dataElement ) { int total = 0 ; if ( nodeCount > 0 ) { MST[rv.ROR3Mutator]MSP[S] for ( final MapIterator < ? , ? > it = getMapIterator ( dataElement ) ; it . hasNext () ; ) {
private int doHashCode ( final DataElement dataElement ) { int total = 0 ; if ( nodeCount > 0 ) { MST[rv.ABSMutator]MSP[S] for ( final MapIterator < ? , ? > it = getMapIterator ( dataElement ) ; it . hasNext () ; ) {
lr_6 + newNode . getData ( VALUE ) + lr_3 ) ; } else if ( cmp < 0 ) { MST[rv.ROR4Mutator]MSP[S] if ( node . getLeft ( VALUE ) != null ) { node = node . getLeft ( VALUE ) ; } else {
return lookupKey ( key ) != null ; } @Override public boolean containsValue ( final Object value ) { checkValue ( value ) ; return lookupValue ( value ) != null ; MST[NonVoidMethodCallMutator]MSP[S] } @Override public V get ( final Object key ) { checkKey ( key ) ;
if ( cmp == 0 ) { rval = node ; break; } node = cmp < 0 ? node . getLeft ( dataElement ) : node . getRight ( dataElement ) ; MST[ArgumentPropagationMutator]MSP[S] } return rval ; }
return EmptyOrderedMapIterator . <K , V > emptyOrderedMapIterator () ; } return new ViewMapIterator ( KEY ) ; } @Override public OrderedBidiMap < V , K > inverseBidiMap () { if ( inverse == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] inverse = new Inverse () ; } return inverse ; } @Override
} else { while ( true ) { final int cmp = compare ( key , node . getKey () ) ; if ( cmp == 0 ) { throw new IllegalArgumentException ( lr_2 + key + lr_3 ) ; } else if ( cmp < 0 ) { MST[rv.ABSMutator]MSP[S]
final Node < K , V > node = nextSmaller ( lookupKey ( key ) , KEY ) ; return node == null ? null : node . getKey () ; } @Override public Set < K > keySet () { if ( keySet == null ) { MST[rv.ROR5Mutator]MSP[S]
private void rotateLeft ( final Node < K , V > node , final DataElement dataElement ) { final Node < K , V > rightChild = node . getRight ( dataElement ) ; node . setRight ( rightChild . getLeft ( dataElement ) , dataElement ) ; MST[NonVoidMethodCallMutator]MSP[S]
} else { while ( true ) { final int cmp = compare ( key , node . getKey () ) ; if ( cmp == 0 ) { throw new IllegalArgumentException ( lr_2 + key + lr_3 ) ; } else if ( cmp < 0 ) { MST[rv.UOI3Mutator]MSP[S]
if ( deletedNode . getParent ( dataElement ) == null ) { rootNode [ dataElement . ordinal () ] = null ; } else { if ( isBlack ( deletedNode , dataElement ) ) { MST[rv.ROR3Mutator]MSP[S] doRedBlackDeleteFixup ( deletedNode , dataElement ) ; }
Node < K , V > parent = node . getParent ( dataElement ) ; Node < K , V > child = node ; while ( parent != null && child == parent . getRight ( dataElement ) ) { MST[NegateConditionalsMutator]MSP[S] child = parent ;
private MapIterator < ? , ? > getMapIterator ( final DataElement dataElement ) { switch ( dataElement ) { case KEY : return new ViewMapIterator ( KEY ) ; case VALUE : return new InverseViewMapIterator ( VALUE ) ; MST[NullReturnValsMutator]MSP[S] default: throw new IllegalArgumentException () ; } }
public K removeValue ( final Object value ) { return doRemoveValue ( value ) ; } @Override public K firstKey () { if ( nodeCount == 0 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] throw new NoSuchElementException ( lr_1 ) ; }
Node < K , V > currentNode = replacementNode ; while ( currentNode != rootNode [ dataElement . ordinal () ] && isBlack ( currentNode , dataElement ) ) { MST[NegateConditionalsMutator]MSP[S] if ( currentNode . isLeftChild ( dataElement ) ) {
rotateLeft ( getGrandParent ( currentNode , dataElement ) , dataElement ) ; MST[VoidMethodCallMutator]MSP[S] } } } } makeBlack ( rootNode [ dataElement . ordinal () ] , dataElement ) ; } private void doRedBlackDelete ( final Node < K , V > deletedNode ) {
final Map < ? , ? > other = ( Map < ? , ? > ) obj ; if ( other . size () != size () ) { return false ; MST[rv.CRCR3Mutator]MSP[N] } if ( nodeCount > 0 ) { try {
} } else { final Node < K , V > y = getLeftChild ( getGrandParent ( currentNode , dataElement ) , dataElement ) ; if ( isRed ( y , dataElement ) ) { makeBlack ( getParent ( currentNode , dataElement ) , dataElement ) ; MST[ArgumentPropagationMutator]MSP[S]
} private void modify () { modifications ++ ; MST[rv.AOD1Mutator]MSP[S] } private void grow () { modify () ; nodeCount ++ ; } private void shrink () { modify () ; nodeCount -- ; } private void insertValue ( final Node < K , V > newNode ) throws IllegalArgumentException {
Node < K , V > currentNode = replacementNode ; while ( currentNode != rootNode [ dataElement . ordinal () ] && isBlack ( currentNode , dataElement ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] if ( currentNode . isLeftChild ( dataElement ) ) {
Node < K , V > node = rootNode [ VALUE . ordinal () ] ; while ( true ) { final int cmp = compare ( newNode . getValue () , node . getValue () ) ; MST[NonVoidMethodCallMutator]MSP[S] if ( cmp == 0 ) { throw new IllegalArgumentException (
} else if ( deletedNode == deletedNode . getParent ( dataElement ) . getLeft ( dataElement ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] deletedNode . getParent ( dataElement ) . setLeft ( replacement , dataElement ) ; } else { deletedNode . getParent ( dataElement ) . setRight ( replacement , dataElement ) ;
Node < K , V > parent = node . getParent ( dataElement ) ; MST[ArgumentPropagationMutator]MSP[S] Node < K , V > child = node ; while ( parent != null && child == parent . getRight ( dataElement ) ) { child = parent ;
replacement . setParent ( deletedNode . getParent ( dataElement ) , dataElement ) ; if ( deletedNode . getParent ( dataElement ) == null ) { MST[rv.ROR5Mutator]MSP[S] rootNode [ dataElement . ordinal () ] = replacement ;
private boolean doEquals ( final Object obj , final DataElement dataElement ) { if ( obj == this ) { return true ; } if ( obj instanceof Map == false ) { return false ; MST[rv.CRCR3Mutator]MSP[N] }
Objects . requireNonNull ( obj , Objects . toString ( dataElement ) ) ; if ( ! ( obj instanceof Comparable ) ) { MST[rv.ROR3Mutator]MSP[S] throw new ClassCastException ( dataElement + lr_5 ) ; } } private static void checkKey ( final Object key ) {
@Override public String toString () { return description ; } @Override public int size () { return nodeCount ; } @Override public boolean isEmpty () { return nodeCount == 0 ; MST[rv.UOI2Mutator]MSP[N] } @Override public boolean containsKey ( final Object key ) { checkKey ( key ) ;
. append ( value == this ? lr_8 : value ) ; hasNext = it . hasNext () ; if ( hasNext ) { MST[rv.ROR1Mutator]MSP[S] buf . append ( lr_9 ) ; } } buf . append ( '}' ) ; return buf . toString () ; }
} else { while ( true ) { final int cmp = compare ( key , node . getKey () ) ; if ( cmp == 0 ) { throw new IllegalArgumentException ( lr_2 + key + lr_3 ) ; } else if ( cmp < 0 ) { MST[rv.ROR3Mutator]MSP[S]
if ( node . getLeft ( KEY ) != null ) { MST[rv.ROR5Mutator]MSP[S] node = node . getLeft ( KEY ) ; } else { final Node < K , V > newNode = new Node <> ( key , value ) ; insertValue ( newNode ) ;
boolean hasNext = it . hasNext () ; while ( hasNext ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] final Object key = it . next () ; final Object value = it . getValue () ; buf . append ( key == this ? lr_8 : key ) . append ( '=' )
public K removeValue ( final Object value ) { return doRemoveValue ( value ) ; } @Override public K firstKey () { if ( nodeCount == 0 ) { MST[rv.UOI4Mutator]MSP[S] throw new NoSuchElementException ( lr_1 ) ; }
@Override public String toString () { return description ; } @Override public int size () { return nodeCount ; MST[rv.UOI3Mutator]MSP[N] } @Override public boolean isEmpty () { return nodeCount == 0 ; } @Override public boolean containsKey ( final Object key ) { checkKey ( key ) ;
if ( nodeCount == 0 ) { return lr_7 ; MST[ReturnValsMutator]MSP[N] } final StringBuilder buf = new StringBuilder ( nodeCount * 32 ) ; buf . append ( '{' ) ; final MapIterator < ? , ? > it = getMapIterator ( dataElement ) ;
if ( nodeCount == 0 ) { return lr_7 ; } final StringBuilder buf = new StringBuilder ( nodeCount * 32 ) ; buf . append ( '{' ) ; MST[rv.CRCR5Mutator]MSP[S] final MapIterator < ? , ? > it = getMapIterator ( dataElement ) ;
private void doPut ( final K key , final V value ) { checkKeyAndValue ( key , value ) ; MST[VoidMethodCallMutator]MSP[S] doRemoveKey ( key ) ; doRemoveValue ( value ) ; Node < K , V > node = rootNode [ KEY . ordinal () ] ;
replacement . setParent ( deletedNode . getParent ( dataElement ) , dataElement ) ; if ( deletedNode . getParent ( dataElement ) == null ) { MST[ArgumentPropagationMutator]MSP[S] rootNode [ dataElement . ordinal () ] = replacement ;
Node < K , V > currentNode = replacementNode ; while ( currentNode != rootNode [ dataElement . ordinal () ] && isBlack ( currentNode , dataElement ) ) { MST[rv.ROR5Mutator]MSP[N] if ( currentNode . isLeftChild ( dataElement ) ) {
if ( node . getParent ( dataElement ) == null ) { MST[NonVoidMethodCallMutator]MSP[N] rootNode [ dataElement . ordinal () ] = rightChild ; } else if ( node . getParent ( dataElement ) . getLeft ( dataElement ) == node ) {
for ( final MapIterator < ? , ? > it = getMapIterator ( dataElement ) ; it . hasNext () ; ) { final Object key = it . next () ; final Object value = it . getValue () ; MST[NonVoidMethodCallMutator]MSP[N]
} else if ( deletedNode == deletedNode . getParent ( dataElement ) . getLeft ( dataElement ) ) { MST[ArgumentPropagationMutator]MSP[N] deletedNode . getParent ( dataElement ) . setLeft ( replacement , dataElement ) ; } else { deletedNode . getParent ( dataElement ) . setRight ( replacement , dataElement ) ;
if ( deletedNode . getParent ( dataElement ) == null ) { rootNode [ dataElement . ordinal () ] = null ; } else { if ( isBlack ( deletedNode , dataElement ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] doRedBlackDeleteFixup ( deletedNode , dataElement ) ; }
return lookupKey ( key ) != null ; } @Override public boolean containsValue ( final Object value ) { checkValue ( value ) ; return lookupValue ( value ) != null ; MST[ReturnValsMutator]MSP[N] } @Override public V get ( final Object key ) { checkKey ( key ) ;
if ( deletedNode . getParent ( dataElement ) != null ) { if ( deletedNode == deletedNode . getParent ( dataElement ) . getLeft ( dataElement ) ) { MST[NonVoidMethodCallMutator]MSP[S] deletedNode . getParent ( dataElement ) . setLeft ( null , dataElement ) ; } else {
if ( node == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] rval = null ; } else if ( node . getLeft ( dataElement ) != null ) { rval = greatestNode ( node . getLeft ( dataElement ) , dataElement ) ; } else {
parent = parent . getParent ( dataElement ) ; } rval = parent ; } return rval ; MST[ReturnValsMutator]MSP[N] } private Node < K , V > nextSmaller ( final Node < K , V > node , final DataElement dataElement ) { Node < K , V > rval ;
for ( final MapIterator < ? , ? > it = getMapIterator ( dataElement ) ; it . hasNext () ; ) { MST[rv.ROR5Mutator]MSP[N] final Object key = it . next () ; final Object value = it . getValue () ;
return leastNode ( rootNode [ KEY . ordinal () ] , KEY ) . getKey () ; } @Override public K lastKey () { if ( nodeCount == 0 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] throw new NoSuchElementException ( lr_1 ) ; }
if ( node . getLeft ( KEY ) != null ) { node = node . getLeft ( KEY ) ; } else { final Node < K , V > newNode = new Node <> ( key , value ) ; MST[ConstructorCallMutator]MSP[S] insertValue ( newNode ) ;
checkNonNullComparable ( key , KEY ) ; } private static void checkValue ( final Object value ) { checkNonNullComparable ( value , VALUE ) ; } private static void checkKeyAndValue ( final Object key , final Object value ) { checkKey ( key ) ; MST[VoidMethodCallMutator]MSP[N] checkValue ( value ) ;
} private void doRedBlackInsert ( final Node < K , V > insertedNode , final DataElement dataElement ) { Node < K , V > currentNode = insertedNode ; makeRed ( currentNode , dataElement ) ; while ( currentNode != null MST[rv.ROR5Mutator]MSP[N]
if ( value . equals ( other . get ( key ) ) == false ) { return false ; } } } catch ( final ClassCastException ex ) { return false ; } catch ( final NullPointerException ex ) { return false ; } } return true ; MST[ReturnValsMutator]MSP[N] }
private static boolean isBlack ( final Node < ? , ? > node , final DataElement dataElement ) { return node == null || node . isBlack ( dataElement ) ; MST[NegateConditionalsMutator]MSP[S] }
return leastNode ( rootNode [ KEY . ordinal () ] , KEY ) . getKey () ; } @Override public K lastKey () { if ( nodeCount == 0 ) { MST[rv.UOI2Mutator]MSP[N] throw new NoSuchElementException ( lr_1 ) ; }
&& currentNode != rootNode [ dataElement . ordinal () ] && isRed ( currentNode . getParent ( dataElement ) , dataElement ) ) { MST[rv.ROR5Mutator]MSP[N] if ( currentNode . isLeftChild ( dataElement ) ) {
if ( node == null ) { return null ; MST[ReturnValsMutator]MSP[S] } doRedBlackDelete ( node ) ; return node . getValue () ; } private K doRemoveValue ( final Object value ) { final Node < K , V > node = lookupValue ( value ) ;
final Node < K , V > y = getRightChild ( getGrandParent ( currentNode , dataElement ) , dataElement ) ; MST[NonVoidMethodCallMutator]MSP[S] if ( isRed ( y , dataElement ) ) { makeBlack ( getParent ( currentNode , dataElement ) , dataElement ) ; makeBlack ( y , dataElement ) ;
} private void modify () { modifications ++ ; MST[rv.AOR3Mutator]MSP[N] } private void grow () { modify () ; nodeCount ++ ; } private void shrink () { modify () ; nodeCount -- ; } private void insertValue ( final Node < K , V > newNode ) throws IllegalArgumentException {
Node < K , V > parent = node . getParent ( dataElement ) ; Node < K , V > child = node ; while ( parent != null && child == parent . getRight ( dataElement ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] child = parent ;
if ( node . getLeft ( KEY ) != null ) { node = node . getLeft ( KEY ) ; } else { final Node < K , V > newNode = new Node <> ( key , value ) ; insertValue ( newNode ) ; MST[VoidMethodCallMutator]MSP[S]
@Override public String toString () { return description ; } @Override public int size () { return nodeCount ; } @Override public boolean isEmpty () { return nodeCount == 0 ; MST[rv.CRCR3Mutator]MSP[N] } @Override public boolean containsKey ( final Object key ) { checkKey ( key ) ;
private int doHashCode ( final DataElement dataElement ) { int total = 0 ; if ( nodeCount > 0 ) { for ( final MapIterator < ? , ? > it = getMapIterator ( dataElement ) ; it . hasNext () ; ) { MST[rv.ROR1Mutator]MSP[S]
&& currentNode != rootNode [ dataElement . ordinal () ] && isRed ( currentNode . getParent ( dataElement ) , dataElement ) ) { if ( currentNode . isLeftChild ( dataElement ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
public K getKey ( final Object value ) { checkValue ( value ) ; final Node < K , V > node = lookupValue ( value ) ; MST[NonVoidMethodCallMutator]MSP[N] return node == null ? null : node . getKey () ; } @Override
} else { while ( true ) { final int cmp = compare ( key , node . getKey () ) ; if ( cmp == 0 ) { throw new IllegalArgumentException ( lr_2 + key + lr_3 ) ; } else if ( cmp < 0 ) { MST[rv.ROR1Mutator]MSP[N]
for ( final DataElement dataElement : DataElement . values () ) { if ( deletedNode . getLeft ( dataElement ) != null && deletedNode . getRight ( dataElement ) != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] swapPosition ( nextGreater ( deletedNode , dataElement ) , deletedNode , dataElement ) ; }
Objects . requireNonNull ( obj , Objects . toString ( dataElement ) ) ; MST[ArgumentPropagationMutator]MSP[S] if ( ! ( obj instanceof Comparable ) ) { throw new ClassCastException ( dataElement + lr_5 ) ; } } private static void checkKey ( final Object key ) {
Node < K , V > node = rootNode [ dataElement . ordinal () ] ; while ( node != null ) { final int cmp = compare ( ( T ) data , ( T ) node . getData ( dataElement ) ) ; MST[NonVoidMethodCallMutator]MSP[S]
final Object key = it . next () ; final Object value = it . getValue () ; total += key . hashCode () ^ value . hashCode () ; } } return total ; MST[rv.UOI1Mutator]MSP[N] } private String doToString ( final DataElement dataElement ) {
Node < K , V > node = rootNode [ VALUE . ordinal () ] ; while ( true ) { final int cmp = compare ( newNode . getValue () , node . getValue () ) ; if ( cmp == 0 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] throw new IllegalArgumentException (
public Set < Map . Entry < K , V > > entrySet () { if ( entrySet == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] entrySet = new EntryView () ; } return entrySet ; } @Override public OrderedMapIterator < K , V > mapIterator () { if ( isEmpty () ) {
return greatestNode ( rootNode [ KEY . ordinal () ] , KEY ) . getKey () ; MST[ArgumentPropagationMutator]MSP[N] } @Override public K nextKey ( final K key ) { checkKey ( key ) ;
final Object key = it . next () ; final Object value = it . getValue () ; total += key . hashCode () ^ value . hashCode () ; MST[rv.UOI2Mutator]MSP[N] } } return total ; } private String doToString ( final DataElement dataElement ) {
rotateRight ( currentNode , dataElement ) ; } makeBlack ( getParent ( currentNode , dataElement ) , dataElement ) ; MST[NonVoidMethodCallMutator]MSP[N] makeRed ( getGrandParent ( currentNode , dataElement ) , dataElement ) ; if ( getGrandParent ( currentNode , dataElement ) != null ) {
node = node . getRight ( VALUE ) ; } else { node . setRight ( newNode , VALUE ) ; MST[VoidMethodCallMutator]MSP[N] newNode . setParent ( node , VALUE ) ; doRedBlackInsert ( newNode , VALUE ) ; break; } } } }
} else { while ( true ) { final int cmp = compare ( key , node . getKey () ) ; if ( cmp == 0 ) { MST[rv.ABSMutator]MSP[N] throw new IllegalArgumentException ( lr_2 + key + lr_3 ) ; } else if ( cmp < 0 ) {
} } else { final Node < K , V > y = getLeftChild ( getGrandParent ( currentNode , dataElement ) , dataElement ) ; MST[ArgumentPropagationMutator]MSP[N] if ( isRed ( y , dataElement ) ) { makeBlack ( getParent ( currentNode , dataElement ) , dataElement ) ;
return lookupKey ( key ) != null ; MST[NegateConditionalsMutator]MSP[N] } @Override public boolean containsValue ( final Object value ) { checkValue ( value ) ; return lookupValue ( value ) != null ; } @Override public V get ( final Object key ) { checkKey ( key ) ;
if ( node == null ) { return null ; } doRedBlackDelete ( node ) ; MST[VoidMethodCallMutator]MSP[S] return node . getValue () ; } private K doRemoveValue ( final Object value ) { final Node < K , V > node = lookupValue ( value ) ;
deletedNode . getParent ( dataElement ) . setRight ( null , dataElement ) ; } deletedNode . setParent ( null , dataElement ) ; MST[VoidMethodCallMutator]MSP[N] } } } } shrink () ; } private void doRedBlackDeleteFixup ( final Node < K , V > replacementNode , final DataElement dataElement ) {
if ( value . equals ( other . get ( key ) ) == false ) { MST[rv.ROR1Mutator]MSP[N] return false ; } } } catch ( final ClassCastException ex ) { return false ; } catch ( final NullPointerException ex ) { return false ; } } return true ; }
newNode . setParent ( node , KEY ) ; doRedBlackInsert ( newNode , KEY ) ; grow () ; break; } } } } } private V doRemoveKey ( final Object key ) { final Node < K , V > node = lookupKey ( key ) ; MST[NonVoidMethodCallMutator]MSP[S]
if ( node . getLeft ( KEY ) != null ) { MST[NegateConditionalsMutator]MSP[S] node = node . getLeft ( KEY ) ; } else { final Node < K , V > newNode = new Node <> ( key , value ) ; insertValue ( newNode ) ;
if ( node == null ) { rval = null ; } else if ( node . getRight ( dataElement ) != null ) { MST[NonVoidMethodCallMutator]MSP[N] rval = leastNode ( node . getRight ( dataElement ) , dataElement ) ; } else {
return greatestNode ( rootNode [ KEY . ordinal () ] , KEY ) . getKey () ; MST[NonVoidMethodCallMutator]MSP[N] } @Override public K nextKey ( final K key ) { checkKey ( key ) ;
node . getParent ( dataElement ) . setLeft ( rightChild , dataElement ) ; } else { node . getParent ( dataElement ) . setRight ( rightChild , dataElement ) ; } rightChild . setLeft ( node , dataElement ) ; MST[VoidMethodCallMutator]MSP[N] node . setParent ( rightChild , dataElement ) ;
&& currentNode != rootNode [ dataElement . ordinal () ] && isRed ( currentNode . getParent ( dataElement ) , dataElement ) ) { MST[NegateConditionalsMutator]MSP[N] if ( currentNode . isLeftChild ( dataElement ) ) {
public Set < Map . Entry < K , V > > entrySet () { if ( entrySet == null ) { entrySet = new EntryView () ; MST[ConstructorCallMutator]MSP[S] } return entrySet ; } @Override public OrderedMapIterator < K , V > mapIterator () { if ( isEmpty () ) {
final Node < K , V > replacement = deletedNode . getLeft ( dataElement ) != null ? deletedNode . getLeft ( dataElement ) : deletedNode . getRight ( dataElement ) ; MST[NonVoidMethodCallMutator]MSP[S] if ( replacement != null ) {
} deletedNode . setLeft ( null , dataElement ) ; deletedNode . setRight ( null , dataElement ) ; deletedNode . setParent ( null , dataElement ) ; if ( isBlack ( deletedNode , dataElement ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] doRedBlackDeleteFixup ( replacement , dataElement ) ; } } else {
return greatestNode ( rootNode [ KEY . ordinal () ] , KEY ) . getKey () ; MST[ReturnValsMutator]MSP[S] } @Override public K nextKey ( final K key ) { checkKey ( key ) ;
} makeBlack ( getParent ( currentNode , dataElement ) , dataElement ) ; makeRed ( getGrandParent ( currentNode , dataElement ) , dataElement ) ; if ( getGrandParent ( currentNode , dataElement ) != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] rotateRight ( getGrandParent ( currentNode , dataElement ) , dataElement ) ; }
} else { while ( true ) { final int cmp = compare ( key , node . getKey () ) ; if ( cmp == 0 ) { MST[rv.UOI3Mutator]MSP[N] throw new IllegalArgumentException ( lr_2 + key + lr_3 ) ; } else if ( cmp < 0 ) {
final Node < K , V > node = lookupKey ( key ) ; return node == null ? null : node . getValue () ; MST[NullReturnValsMutator]MSP[N] } @Override public V put ( final K key , final V value ) { final V result = get ( key ) ;
replacement . setParent ( deletedNode . getParent ( dataElement ) , dataElement ) ; MST[VoidMethodCallMutator]MSP[S] if ( deletedNode . getParent ( dataElement ) == null ) { rootNode [ dataElement . ordinal () ] = replacement ;
@Override public String toString () { return description ; } @Override public int size () { return nodeCount ; } @Override public boolean isEmpty () { return nodeCount == 0 ; MST[rv.ROR3Mutator]MSP[N] } @Override public boolean containsKey ( final Object key ) { checkKey ( key ) ;
public K removeValue ( final Object value ) { return doRemoveValue ( value ) ; } @Override public K firstKey () { if ( nodeCount == 0 ) { MST[rv.ROR2Mutator]MSP[S] throw new NoSuchElementException ( lr_1 ) ; }
if ( nodeCount == 0 ) { MST[rv.ABSMutator]MSP[N] return lr_7 ; } final StringBuilder buf = new StringBuilder ( nodeCount * 32 ) ; buf . append ( '{' ) ; final MapIterator < ? , ? > it = getMapIterator ( dataElement ) ;
final Node < K , V > y = getRightChild ( getGrandParent ( currentNode , dataElement ) , dataElement ) ; if ( isRed ( y , dataElement ) ) { MST[rv.ROR1Mutator]MSP[N] makeBlack ( getParent ( currentNode , dataElement ) , dataElement ) ; makeBlack ( y , dataElement ) ;
if ( leftChild . getRight ( dataElement ) != null ) { MST[NegateConditionalsMutator]MSP[S] leftChild . getRight ( dataElement ) . setParent ( node , dataElement ) ; } leftChild . setParent ( node . getParent ( dataElement ) , dataElement ) ;
Node < K , V > rval = node ; if ( rval != null ) { MST[rv.ROR5Mutator]MSP[N] while ( rval . getRight ( dataElement ) != null ) { rval = rval . getRight ( dataElement ) ; } } return rval ; }
private Node < K , V > getGrandParent ( final Node < K , V > node , final DataElement dataElement ) { return getParent ( getParent ( node , dataElement ) , dataElement ) ; MST[NonVoidMethodCallMutator]MSP[N] }
private Node < K , V > getRightChild ( final Node < K , V > node , final DataElement dataElement ) { return node == null ? null : node . getRight ( dataElement ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] }
Node < K , V > currentNode = replacementNode ; while ( currentNode != rootNode [ dataElement . ordinal () ] && isBlack ( currentNode , dataElement ) ) { MST[NegateConditionalsMutator]MSP[N] if ( currentNode . isLeftChild ( dataElement ) ) {
} private void modify () { modifications ++ ; } private void grow () { modify () ; nodeCount ++ ; MST[rv.AOR4Mutator]MSP[N] } private void shrink () { modify () ; nodeCount -- ; } private void insertValue ( final Node < K , V > newNode ) throws IllegalArgumentException {
} private void modify () { modifications ++ ; } private void grow () { modify () ; nodeCount ++ ; MST[rv.ABSMutator]MSP[N] } private void shrink () { modify () ; nodeCount -- ; } private void insertValue ( final Node < K , V > newNode ) throws IllegalArgumentException {
final Node < K , V > node = lookupKey ( key ) ; return node == null ? null : node . getValue () ; } @Override public V put ( final K key , final V value ) { final V result = get ( key ) ; MST[NonVoidMethodCallMutator]MSP[S]
} private void doRedBlackInsert ( final Node < K , V > insertedNode , final DataElement dataElement ) { Node < K , V > currentNode = insertedNode ; makeRed ( currentNode , dataElement ) ; while ( currentNode != null MST[NegateConditionalsMutator]MSP[N]
public Set < Map . Entry < K , V > > entrySet () { if ( entrySet == null ) { entrySet = new EntryView () ; } return entrySet ; } @Override public OrderedMapIterator < K , V > mapIterator () { if ( isEmpty () ) { MST[rv.ROR3Mutator]MSP[N]
if ( value . equals ( other . get ( key ) ) == false ) { MST[ArgumentPropagationMutator]MSP[N] return false ; } } } catch ( final ClassCastException ex ) { return false ; } catch ( final NullPointerException ex ) { return false ; } } return true ; }
final Node < K , V > node = nextSmaller ( lookupKey ( key ) , KEY ) ; return node == null ? null : node . getKey () ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } @Override public Set < K > keySet () { if ( keySet == null ) {
private Node < K , V > getLeftChild ( final Node < K , V > node , final DataElement dataElement ) { return node == null ? null : node . getLeft ( dataElement ) ; MST[ArgumentPropagationMutator]MSP[S] }
parent = parent . getParent ( dataElement ) ; } rval = parent ; } return rval ; } private static < T extends Comparable < T > > int compare ( final T o1 , final T o2 ) { return o1 . compareTo ( o2 ) ; MST[NonVoidMethodCallMutator]MSP[N] }
} private void modify () { modifications ++ ; } private void grow () { modify () ; nodeCount ++ ; } private void shrink () { modify () ; nodeCount -- ; MST[rv.CRCR2Mutator]MSP[N] } private void insertValue ( final Node < K , V > newNode ) throws IllegalArgumentException {
makeRed ( getGrandParent ( currentNode , dataElement ) , dataElement ) ; currentNode = getGrandParent ( currentNode , dataElement ) ; MST[NonVoidMethodCallMutator]MSP[N] } else { if ( currentNode . isRightChild ( dataElement ) ) { currentNode = getParent ( currentNode , dataElement ) ; rotateLeft ( currentNode , dataElement ) ;
while ( rval . getLeft ( dataElement ) != null ) { rval = rval . getLeft ( dataElement ) ; } } return rval ; MST[ReturnValsMutator]MSP[N] } private Node < K , V > greatestNode ( final Node < K , V > node , final DataElement dataElement ) {
return lookupKey ( key ) != null ; MST[rv.CRCR5Mutator]MSP[N] } @Override public boolean containsValue ( final Object value ) { checkValue ( value ) ; return lookupValue ( value ) != null ; } @Override public V get ( final Object key ) { checkKey ( key ) ;
final Node < K , V > node = nextGreater ( lookupKey ( key ) , KEY ) ; MST[NonVoidMethodCallMutator]MSP[N] return node == null ? null : node . getKey () ; } @Override public K previousKey ( final K key ) { checkKey ( key ) ;
for ( final Map . Entry < ? extends K , ? extends V > e : map . entrySet () ) { put ( e . getKey () , e . getValue () ) ; MST[NonVoidMethodCallMutator]MSP[S] } } @Override public V remove ( final Object key ) {
} private void modify () { modifications ++ ; MST[rv.CRCR4Mutator]MSP[N] } private void grow () { modify () ; nodeCount ++ ; } private void shrink () { modify () ; nodeCount -- ; } private void insertValue ( final Node < K , V > newNode ) throws IllegalArgumentException {
if ( nodeCount == 0 ) { return lr_7 ; } final StringBuilder buf = new StringBuilder ( nodeCount * 32 ) ; MST[rv.UOI2Mutator]MSP[S] buf . append ( '{' ) ; final MapIterator < ? , ? > it = getMapIterator ( dataElement ) ;
} } else { final Node < K , V > y = getLeftChild ( getGrandParent ( currentNode , dataElement ) , dataElement ) ; if ( isRed ( y , dataElement ) ) { MST[rv.ROR3Mutator]MSP[N] makeBlack ( getParent ( currentNode , dataElement ) , dataElement ) ;
return doRemoveKey ( key ) ; } @Override public void clear () { modify () ; nodeCount = 0 ; MST[rv.CRCR3Mutator]MSP[N] rootNode [ KEY . ordinal () ] = null ; rootNode [ VALUE . ordinal () ] = null ; } @Override
final Node < K , V > node = lookupKey ( key ) ; return node == null ? null : node . getValue () ; MST[ReturnValsMutator]MSP[S] } @Override public V put ( final K key , final V value ) { final V result = get ( key ) ;
return leastNode ( rootNode [ KEY . ordinal () ] , KEY ) . getKey () ; } @Override public K lastKey () { if ( nodeCount == 0 ) { MST[rv.ROR2Mutator]MSP[S] throw new NoSuchElementException ( lr_1 ) ; }
if ( nodeCount == 0 ) { return lr_7 ; } final StringBuilder buf = new StringBuilder ( nodeCount * 32 ) ; buf . append ( '{' ) ; MST[experimental.NakedReceiverMutator]MSP[S] final MapIterator < ? , ? > it = getMapIterator ( dataElement ) ;
private boolean doEquals ( final Object obj , final DataElement dataElement ) { if ( obj == this ) { return true ; } if ( obj instanceof Map == false ) { MST[NegateConditionalsMutator]MSP[N] return false ; }
final Map < ? , ? > other = ( Map < ? , ? > ) obj ; if ( other . size () != size () ) { MST[NegateConditionalsMutator]MSP[N] return false ; } if ( nodeCount > 0 ) { try {
final Node < K , V > node = nextSmaller ( lookupKey ( key ) , KEY ) ; return node == null ? null : node . getKey () ; } @Override public Set < K > keySet () { if ( keySet == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S]
makeBlack ( y , dataElement ) ; makeRed ( getGrandParent ( currentNode , dataElement ) , dataElement ) ; currentNode = getGrandParent ( currentNode , dataElement ) ; MST[ArgumentPropagationMutator]MSP[N] } else { if ( currentNode . isLeftChild ( dataElement ) ) { currentNode = getParent ( currentNode , dataElement ) ;
} else if ( deletedNode == deletedNode . getParent ( dataElement ) . getLeft ( dataElement ) ) { deletedNode . getParent ( dataElement ) . setLeft ( replacement , dataElement ) ; } else { deletedNode . getParent ( dataElement ) . setRight ( replacement , dataElement ) ; MST[NonVoidMethodCallMutator]MSP[S]
parent = parent . getParent ( dataElement ) ; } rval = parent ; } return rval ; MST[ReturnValsMutator]MSP[S] } private static < T extends Comparable < T > > int compare ( final T o1 , final T o2 ) { return o1 . compareTo ( o2 ) ; }
final Node < K , V > replacement = deletedNode . getLeft ( dataElement ) != null ? deletedNode . getLeft ( dataElement ) : deletedNode . getRight ( dataElement ) ; MST[ArgumentPropagationMutator]MSP[S] if ( replacement != null ) {
for ( final Map . Entry < ? extends K , ? extends V > e : map . entrySet () ) { put ( e . getKey () , e . getValue () ) ; MST[NonVoidMethodCallMutator]MSP[N] } } @Override public V remove ( final Object key ) {
} } else { final Node < K , V > y = getLeftChild ( getGrandParent ( currentNode , dataElement ) , dataElement ) ; if ( isRed ( y , dataElement ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] makeBlack ( getParent ( currentNode , dataElement ) , dataElement ) ;
if ( nodeCount == 0 ) { return lr_7 ; } final StringBuilder buf = new StringBuilder ( nodeCount * 32 ) ; MST[rv.AOR1Mutator]MSP[N] buf . append ( '{' ) ; final MapIterator < ? , ? > it = getMapIterator ( dataElement ) ;
checkNonNullComparable ( key , KEY ) ; } private static void checkValue ( final Object value ) { checkNonNullComparable ( value , VALUE ) ; } private static void checkKeyAndValue ( final Object key , final Object value ) { checkKey ( key ) ; checkValue ( value ) ; MST[VoidMethodCallMutator]MSP[S]
Objects . requireNonNull ( obj , Objects . toString ( dataElement ) ) ; if ( ! ( obj instanceof Comparable ) ) { throw new ClassCastException ( dataElement + lr_5 ) ; MST[NonVoidMethodCallMutator]MSP[S] } } private static void checkKey ( final Object key ) {
return lookupKey ( key ) != null ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } @Override public boolean containsValue ( final Object value ) { checkValue ( value ) ; return lookupValue ( value ) != null ; } @Override public V get ( final Object key ) { checkKey ( key ) ;
return leastNode ( rootNode [ KEY . ordinal () ] , KEY ) . getKey () ; } @Override public K lastKey () { if ( nodeCount == 0 ) { MST[rv.UOI1Mutator]MSP[S] throw new NoSuchElementException ( lr_1 ) ; }
if ( node . getLeft ( KEY ) != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] node = node . getLeft ( KEY ) ; } else { final Node < K , V > newNode = new Node <> ( key , value ) ; insertValue ( newNode ) ;
final Map < ? , ? > other = ( Map < ? , ? > ) obj ; if ( other . size () != size () ) { return false ; MST[ReturnValsMutator]MSP[N] } if ( nodeCount > 0 ) { try {
private Node < K , V > getRightChild ( final Node < K , V > node , final DataElement dataElement ) { return node == null ? null : node . getRight ( dataElement ) ; MST[NullReturnValsMutator]MSP[S] }
@Override public String toString () { return description ; } @Override public int size () { return nodeCount ; } @Override public boolean isEmpty () { return nodeCount == 0 ; MST[InlineConstantMutator]MSP[N] } @Override public boolean containsKey ( final Object key ) { checkKey ( key ) ;
} else { while ( true ) { final int cmp = compare ( key , node . getKey () ) ; MST[NonVoidMethodCallMutator]MSP[S] if ( cmp == 0 ) { throw new IllegalArgumentException ( lr_2 + key + lr_3 ) ; } else if ( cmp < 0 ) {
node . setLeft ( newNode , VALUE ) ; newNode . setParent ( node , VALUE ) ; doRedBlackInsert ( newNode , VALUE ) ; break; } } else { if ( node . getRight ( VALUE ) != null ) { MST[NonVoidMethodCallMutator]MSP[N]
return lookupKey ( key ) != null ; MST[rv.ROR5Mutator]MSP[N] } @Override public boolean containsValue ( final Object value ) { checkValue ( value ) ; return lookupValue ( value ) != null ; } @Override public V get ( final Object key ) { checkKey ( key ) ;
if ( value . equals ( other . get ( key ) ) == false ) { return false ; MST[BooleanTrueReturnValsMutator]MSP[N] } } } catch ( final ClassCastException ex ) { return false ; } catch ( final NullPointerException ex ) { return false ; } } return true ; }
Objects . requireNonNull ( obj , Objects . toString ( dataElement ) ) ; MST[NonVoidMethodCallMutator]MSP[S] if ( ! ( obj instanceof Comparable ) ) { throw new ClassCastException ( dataElement + lr_5 ) ; } } private static void checkKey ( final Object key ) {
} private void modify () { modifications ++ ; } private void grow () { modify () ; nodeCount ++ ; } private void shrink () { modify () ; nodeCount -- ; MST[rv.UOI4Mutator]MSP[N] } private void insertValue ( final Node < K , V > newNode ) throws IllegalArgumentException {
return lookupKey ( key ) != null ; } @Override public boolean containsValue ( final Object value ) { checkValue ( value ) ; return lookupValue ( value ) != null ; MST[rv.CRCR5Mutator]MSP[N] } @Override public V get ( final Object key ) { checkKey ( key ) ;
} private void modify () { modifications ++ ; } private void grow () { modify () ; nodeCount ++ ; } private void shrink () { modify () ; nodeCount -- ; MST[rv.CRCR4Mutator]MSP[N] } private void insertValue ( final Node < K , V > newNode ) throws IllegalArgumentException {
private void rotateLeft ( final Node < K , V > node , final DataElement dataElement ) { final Node < K , V > rightChild = node . getRight ( dataElement ) ; MST[NonVoidMethodCallMutator]MSP[S] node . setRight ( rightChild . getLeft ( dataElement ) , dataElement ) ;
if ( cmp == 0 ) { rval = node ; break; } node = cmp < 0 ? node . getLeft ( dataElement ) : node . getRight ( dataElement ) ; MST[NegateConditionalsMutator]MSP[N] } return rval ; }
lr_6 + newNode . getData ( VALUE ) + lr_3 ) ; } else if ( cmp < 0 ) { MST[rv.ROR1Mutator]MSP[S] if ( node . getLeft ( VALUE ) != null ) { node = node . getLeft ( VALUE ) ; } else {
doPut ( key , value ) ; return result ; MST[NullReturnValsMutator]MSP[S] } @Override public void putAll ( final Map < ? extends K , ? extends V > map ) {
} else { while ( true ) { final int cmp = compare ( key , node . getKey () ) ; if ( cmp == 0 ) { MST[rv.ROR1Mutator]MSP[S] throw new IllegalArgumentException ( lr_2 + key + lr_3 ) ; } else if ( cmp < 0 ) {
private boolean doEquals ( final Object obj , final DataElement dataElement ) { if ( obj == this ) { return true ; } if ( obj instanceof Map == false ) { return false ; MST[ReturnValsMutator]MSP[N] }
Node < K , V > rval = node ; if ( rval != null ) { MST[NegateConditionalsMutator]MSP[N] while ( rval . getRight ( dataElement ) != null ) { rval = rval . getRight ( dataElement ) ; } } return rval ; }
if ( value . equals ( other . get ( key ) ) == false ) { MST[rv.ROR3Mutator]MSP[N] return false ; } } } catch ( final ClassCastException ex ) { return false ; } catch ( final NullPointerException ex ) { return false ; } } return true ; }
if ( value . equals ( other . get ( key ) ) == false ) { return false ; MST[rv.CRCR3Mutator]MSP[N] } } } catch ( final ClassCastException ex ) { return false ; } catch ( final NullPointerException ex ) { return false ; } } return true ; }
Node < K , V > node = rootNode [ VALUE . ordinal () ] ; MST[NonVoidMethodCallMutator]MSP[N] while ( true ) { final int cmp = compare ( newNode . getValue () , node . getValue () ) ; if ( cmp == 0 ) { throw new IllegalArgumentException (
private int doHashCode ( final DataElement dataElement ) { int total = 0 ; if ( nodeCount > 0 ) { MST[rv.UOI4Mutator]MSP[N] for ( final MapIterator < ? , ? > it = getMapIterator ( dataElement ) ; it . hasNext () ; ) {
Node < K , V > node = rootNode [ VALUE . ordinal () ] ; while ( true ) { final int cmp = compare ( newNode . getValue () , node . getValue () ) ; if ( cmp == 0 ) { MST[rv.ROR4Mutator]MSP[S] throw new IllegalArgumentException (
if ( value . equals ( other . get ( key ) ) == false ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return false ; } } } catch ( final ClassCastException ex ) { return false ; } catch ( final NullPointerException ex ) { return false ; } } return true ; }
for ( final DataElement dataElement : DataElement . values () ) { MST[rv.ABSMutator]MSP[S] if ( deletedNode . getLeft ( dataElement ) != null && deletedNode . getRight ( dataElement ) != null ) { swapPosition ( nextGreater ( deletedNode , dataElement ) , deletedNode , dataElement ) ; }
Node < K , V > rval = node ; if ( rval != null ) { while ( rval . getRight ( dataElement ) != null ) { MST[ArgumentPropagationMutator]MSP[S] rval = rval . getRight ( dataElement ) ; } } return rval ; }
private static boolean isBlack ( final Node < ? , ? > node , final DataElement dataElement ) { return node == null || node . isBlack ( dataElement ) ; MST[ReturnValsMutator]MSP[S] }
@Override public String toString () { return description ; } @Override public int size () { return nodeCount ; } @Override public boolean isEmpty () { return nodeCount == 0 ; MST[rv.ROR2Mutator]MSP[N] } @Override public boolean containsKey ( final Object key ) { checkKey ( key ) ;
return leastNode ( rootNode [ KEY . ordinal () ] , KEY ) . getKey () ; } @Override public K lastKey () { if ( nodeCount == 0 ) { MST[rv.UOI4Mutator]MSP[S] throw new NoSuchElementException ( lr_1 ) ; }
public boolean equals ( final Object obj ) { return this . doEquals ( obj , KEY ) ; MST[NonVoidMethodCallMutator]MSP[N] } @Override public int hashCode () { return this . doHashCode ( KEY ) ; } @Override public String toString () { return this . doToString ( KEY ) ; }
final Object key = it . next () ; final Object value = it . getValue () ; total += key . hashCode () ^ value . hashCode () ; } } return total ; MST[PrimitiveReturnsMutator]MSP[N] } private String doToString ( final DataElement dataElement ) {
public K removeValue ( final Object value ) { return doRemoveValue ( value ) ; } @Override public K firstKey () { if ( nodeCount == 0 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] throw new NoSuchElementException ( lr_1 ) ; }
final Node < K , V > replacement = deletedNode . getLeft ( dataElement ) != null ? deletedNode . getLeft ( dataElement ) : deletedNode . getRight ( dataElement ) ; if ( replacement != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
final Node < K , V > y = getRightChild ( getGrandParent ( currentNode , dataElement ) , dataElement ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( isRed ( y , dataElement ) ) { makeBlack ( getParent ( currentNode , dataElement ) , dataElement ) ; makeBlack ( y , dataElement ) ;
private int doHashCode ( final DataElement dataElement ) { int total = 0 ; if ( nodeCount > 0 ) { MST[rv.UOI1Mutator]MSP[N] for ( final MapIterator < ? , ? > it = getMapIterator ( dataElement ) ; it . hasNext () ; ) {
final Object key = it . next () ; final Object value = it . getValue () ; total += key . hashCode () ^ value . hashCode () ; MST[rv.AOD2Mutator]MSP[N] } } return total ; } private String doToString ( final DataElement dataElement ) {
doPut ( key , value ) ; return result ; MST[ReturnValsMutator]MSP[S] } @Override public void putAll ( final Map < ? extends K , ? extends V > map ) {
if ( rightChild . getLeft ( dataElement ) != null ) { rightChild . getLeft ( dataElement ) . setParent ( node , dataElement ) ; } rightChild . setParent ( node . getParent ( dataElement ) , dataElement ) ; MST[NonVoidMethodCallMutator]MSP[N]
keySet = new KeyView ( KEY ) ; } return keySet ; } @Override public Set < V > values () { if ( valuesSet == null ) { MST[NegateConditionalsMutator]MSP[S] valuesSet = new ValueView ( KEY ) ; } return valuesSet ; } @Override
lr_6 + newNode . getData ( VALUE ) + lr_3 ) ; } else if ( cmp < 0 ) { if ( node . getLeft ( VALUE ) != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] node = node . getLeft ( VALUE ) ; } else {
} makeBlack ( getParent ( currentNode , dataElement ) , dataElement ) ; makeRed ( getGrandParent ( currentNode , dataElement ) , dataElement ) ; if ( getGrandParent ( currentNode , dataElement ) != null ) { MST[NonVoidMethodCallMutator]MSP[N] rotateRight ( getGrandParent ( currentNode , dataElement ) , dataElement ) ; }
private static boolean isBlack ( final Node < ? , ? > node , final DataElement dataElement ) { return node == null || node . isBlack ( dataElement ) ; MST[rv.CRCR3Mutator]MSP[N] }
rotateRight ( currentNode , dataElement ) ; } makeBlack ( getParent ( currentNode , dataElement ) , dataElement ) ; MST[VoidMethodCallMutator]MSP[N] makeRed ( getGrandParent ( currentNode , dataElement ) , dataElement ) ; if ( getGrandParent ( currentNode , dataElement ) != null ) {
parent = parent . getParent ( dataElement ) ; } rval = parent ; } return rval ; MST[NullReturnValsMutator]MSP[N] } private static < T extends Comparable < T > > int compare ( final T o1 , final T o2 ) { return o1 . compareTo ( o2 ) ; }
node . setLeft ( newNode , VALUE ) ; newNode . setParent ( node , VALUE ) ; MST[VoidMethodCallMutator]MSP[S] doRedBlackInsert ( newNode , VALUE ) ; break; } } else { if ( node . getRight ( VALUE ) != null ) {
makeRed ( getGrandParent ( currentNode , dataElement ) , dataElement ) ; MST[ArgumentPropagationMutator]MSP[N] currentNode = getGrandParent ( currentNode , dataElement ) ; } else { if ( currentNode . isRightChild ( dataElement ) ) { currentNode = getParent ( currentNode , dataElement ) ; rotateLeft ( currentNode , dataElement ) ;
private static boolean isBlack ( final Node < ? , ? > node , final DataElement dataElement ) { return node == null || node . isBlack ( dataElement ) ; MST[rv.ROR3Mutator]MSP[N] }
return lookupKey ( key ) != null ; } @Override public boolean containsValue ( final Object value ) { checkValue ( value ) ; return lookupValue ( value ) != null ; MST[InlineConstantMutator]MSP[N] } @Override public V get ( final Object key ) { checkKey ( key ) ;
return leastNode ( rootNode [ KEY . ordinal () ] , KEY ) . getKey () ; } @Override public K lastKey () { if ( nodeCount == 0 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] throw new NoSuchElementException ( lr_1 ) ; }
private Node < K , V > getLeftChild ( final Node < K , V > node , final DataElement dataElement ) { return node == null ? null : node . getLeft ( dataElement ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] }
final Node < K , V > node = nextGreater ( lookupKey ( key ) , KEY ) ; return node == null ? null : node . getKey () ; MST[ReturnValsMutator]MSP[S] } @Override public K previousKey ( final K key ) { checkKey ( key ) ;
while ( rval . getLeft ( dataElement ) != null ) { MST[ArgumentPropagationMutator]MSP[N] rval = rval . getLeft ( dataElement ) ; } } return rval ; } private Node < K , V > greatestNode ( final Node < K , V > node , final DataElement dataElement ) {
public Set < Map . Entry < K , V > > entrySet () { if ( entrySet == null ) { entrySet = new EntryView () ; MST[experimental.MemberVariableMutator]MSP[S] } return entrySet ; } @Override public OrderedMapIterator < K , V > mapIterator () { if ( isEmpty () ) {
public K removeValue ( final Object value ) { return doRemoveValue ( value ) ; } @Override public K firstKey () { if ( nodeCount == 0 ) { MST[rv.UOI2Mutator]MSP[N] throw new NoSuchElementException ( lr_1 ) ; }
} private void modify () { modifications ++ ; } private void grow () { modify () ; nodeCount ++ ; MST[rv.UOI1Mutator]MSP[N] } private void shrink () { modify () ; nodeCount -- ; } private void insertValue ( final Node < K , V > newNode ) throws IllegalArgumentException {
private static boolean isBlack ( final Node < ? , ? > node , final DataElement dataElement ) { return node == null || node . isBlack ( dataElement ) ; MST[rv.CRCR6Mutator]MSP[N] }
} private void modify () { modifications ++ ; } private void grow () { modify () ; nodeCount ++ ; MST[rv.AOR2Mutator]MSP[N] } private void shrink () { modify () ; nodeCount -- ; } private void insertValue ( final Node < K , V > newNode ) throws IllegalArgumentException {
node . setLeft ( newNode , VALUE ) ; newNode . setParent ( node , VALUE ) ; doRedBlackInsert ( newNode , VALUE ) ; break; } } else { if ( node . getRight ( VALUE ) != null ) { MST[NegateConditionalsMutator]MSP[S]
final Node < K , V > node = nextSmaller ( lookupKey ( key ) , KEY ) ; return node == null ? null : node . getKey () ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] } @Override public Set < K > keySet () { if ( keySet == null ) {
if ( deletedNode . getParent ( dataElement ) != null ) { if ( deletedNode == deletedNode . getParent ( dataElement ) . getLeft ( dataElement ) ) { deletedNode . getParent ( dataElement ) . setLeft ( null , dataElement ) ; MST[NonVoidMethodCallMutator]MSP[S] } else {
. append ( value == this ? lr_8 : value ) ; hasNext = it . hasNext () ; if ( hasNext ) { buf . append ( lr_9 ) ; } } buf . append ( '}' ) ; return buf . toString () ; MST[ReturnValsMutator]MSP[S] }
public Set < Map . Entry < K , V > > entrySet () { if ( entrySet == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] entrySet = new EntryView () ; } return entrySet ; } @Override public OrderedMapIterator < K , V > mapIterator () { if ( isEmpty () ) {
lr_6 + newNode . getData ( VALUE ) + lr_3 ) ; } else if ( cmp < 0 ) { if ( node . getLeft ( VALUE ) != null ) { node = node . getLeft ( VALUE ) ; MST[NonVoidMethodCallMutator]MSP[S] } else {
node . setLeft ( newNode , VALUE ) ; newNode . setParent ( node , VALUE ) ; doRedBlackInsert ( newNode , VALUE ) ; break; } } else { if ( node . getRight ( VALUE ) != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S]
if ( cmp == 0 ) { MST[rv.UOI2Mutator]MSP[N] rval = node ; break; } node = cmp < 0 ? node . getLeft ( dataElement ) : node . getRight ( dataElement ) ; } return rval ; }
if ( cmp == 0 ) { MST[rv.ROR3Mutator]MSP[N] rval = node ; break; } node = cmp < 0 ? node . getLeft ( dataElement ) : node . getRight ( dataElement ) ; } return rval ; }
&& currentNode != rootNode [ dataElement . ordinal () ] && isRed ( currentNode . getParent ( dataElement ) , dataElement ) ) { if ( currentNode . isLeftChild ( dataElement ) ) { MST[rv.ROR3Mutator]MSP[N]
} else { to . copyColor ( from , dataElement ) ; } } } private static boolean isRed ( final Node < ? , ? > node , final DataElement dataElement ) { return node != null && node . isRed ( dataElement ) ; MST[rv.CRCR4Mutator]MSP[N] }
replacement . setParent ( deletedNode . getParent ( dataElement ) , dataElement ) ; MST[ArgumentPropagationMutator]MSP[S] if ( deletedNode . getParent ( dataElement ) == null ) { rootNode [ dataElement . ordinal () ] = replacement ;
@Override public String toString () { return description ; } @Override public int size () { return nodeCount ; } @Override public boolean isEmpty () { return nodeCount == 0 ; MST[rv.ROR5Mutator]MSP[N] } @Override public boolean containsKey ( final Object key ) { checkKey ( key ) ;
&& currentNode != rootNode [ dataElement . ordinal () ] && isRed ( currentNode . getParent ( dataElement ) , dataElement ) ) { MST[rv.ROR1Mutator]MSP[N] if ( currentNode . isLeftChild ( dataElement ) ) {
node . setLeft ( newNode , KEY ) ; newNode . setParent ( node , KEY ) ; doRedBlackInsert ( newNode , KEY ) ; grow () ; break; } } else { if ( node . getRight ( KEY ) != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S]
private MapIterator < ? , ? > getMapIterator ( final DataElement dataElement ) { switch ( dataElement ) { MST[rv.UOI2Mutator]MSP[S] case KEY : return new ViewMapIterator ( KEY ) ; case VALUE : return new InverseViewMapIterator ( VALUE ) ; default: throw new IllegalArgumentException () ; } }
} makeBlack ( getParent ( currentNode , dataElement ) , dataElement ) ; makeRed ( getGrandParent ( currentNode , dataElement ) , dataElement ) ; if ( getGrandParent ( currentNode , dataElement ) != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] rotateRight ( getGrandParent ( currentNode , dataElement ) , dataElement ) ; }
for ( final DataElement dataElement : DataElement . values () ) { MST[rv.UOI1Mutator]MSP[S] if ( deletedNode . getLeft ( dataElement ) != null && deletedNode . getRight ( dataElement ) != null ) { swapPosition ( nextGreater ( deletedNode , dataElement ) , deletedNode , dataElement ) ; }
parent = parent . getParent ( dataElement ) ; } rval = parent ; } return rval ; } private static < T extends Comparable < T > > int compare ( final T o1 , final T o2 ) { return o1 . compareTo ( o2 ) ; MST[ReturnValsMutator]MSP[S] }
rotateLeft ( getGrandParent ( currentNode , dataElement ) , dataElement ) ; } } } } makeBlack ( rootNode [ dataElement . ordinal () ] , dataElement ) ; MST[NonVoidMethodCallMutator]MSP[S] } private void doRedBlackDelete ( final Node < K , V > deletedNode ) {
@Override public String toString () { return description ; } @Override public int size () { return nodeCount ; } @Override public boolean isEmpty () { return nodeCount == 0 ; MST[rv.UOI4Mutator]MSP[N] } @Override public boolean containsKey ( final Object key ) { checkKey ( key ) ;
if ( node == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] rval = null ; } else if ( node . getLeft ( dataElement ) != null ) { rval = greatestNode ( node . getLeft ( dataElement ) , dataElement ) ; } else {
keySet = new KeyView ( KEY ) ; } return keySet ; } @Override public Set < V > values () { if ( valuesSet == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] valuesSet = new ValueView ( KEY ) ; } return valuesSet ; } @Override
private int doHashCode ( final DataElement dataElement ) { int total = 0 ; if ( nodeCount > 0 ) { MST[NegateConditionalsMutator]MSP[S] for ( final MapIterator < ? , ? > it = getMapIterator ( dataElement ) ; it . hasNext () ; ) {
boolean hasNext = it . hasNext () ; while ( hasNext ) { MST[NegateConditionalsMutator]MSP[S] final Object key = it . next () ; final Object value = it . getValue () ; buf . append ( key == this ? lr_8 : key ) . append ( '=' )
return lookupKey ( key ) != null ; MST[InlineConstantMutator]MSP[N] } @Override public boolean containsValue ( final Object value ) { checkValue ( value ) ; return lookupValue ( value ) != null ; } @Override public V get ( final Object key ) { checkKey ( key ) ;
for ( final MapIterator < ? , ? > it = getMapIterator ( dataElement ) ; it . hasNext () ; ) { MST[NegateConditionalsMutator]MSP[S] final Object key = it . next () ; final Object value = it . getValue () ;
. append ( value == this ? lr_8 : value ) ; hasNext = it . hasNext () ; if ( hasNext ) { buf . append ( lr_9 ) ; } } buf . append ( '}' ) ; MST[rv.CRCR3Mutator]MSP[S] return buf . toString () ; }
} else { to . copyColor ( from , dataElement ) ; } } } private static boolean isRed ( final Node < ? , ? > node , final DataElement dataElement ) { return node != null && node . isRed ( dataElement ) ; MST[rv.CRCR1Mutator]MSP[S] }
if ( nodeCount == 0 ) { return lr_7 ; } final StringBuilder buf = new StringBuilder ( nodeCount * 32 ) ; MST[rv.AOR4Mutator]MSP[S] buf . append ( '{' ) ; final MapIterator < ? , ? > it = getMapIterator ( dataElement ) ;
private void rotateLeft ( final Node < K , V > node , final DataElement dataElement ) { final Node < K , V > rightChild = node . getRight ( dataElement ) ; MST[ArgumentPropagationMutator]MSP[S] node . setRight ( rightChild . getLeft ( dataElement ) , dataElement ) ;
final Node < K , V > node = nextSmaller ( lookupKey ( key ) , KEY ) ; MST[NonVoidMethodCallMutator]MSP[S] return node == null ? null : node . getKey () ; } @Override public Set < K > keySet () { if ( keySet == null ) {
return EmptyOrderedMapIterator . <K , V > emptyOrderedMapIterator () ; MST[ReturnValsMutator]MSP[S] } return new ViewMapIterator ( KEY ) ; } @Override public OrderedBidiMap < V , K > inverseBidiMap () { if ( inverse == null ) { inverse = new Inverse () ; } return inverse ; } @Override
private Node < K , V > getParent ( final Node < K , V > node , final DataElement dataElement ) { return node == null ? null : node . getParent ( dataElement ) ; MST[ArgumentPropagationMutator]MSP[S] }
} } else { final Node < K , V > y = getLeftChild ( getGrandParent ( currentNode , dataElement ) , dataElement ) ; if ( isRed ( y , dataElement ) ) { MST[NonVoidMethodCallMutator]MSP[S] makeBlack ( getParent ( currentNode , dataElement ) , dataElement ) ;
private static void makeRed ( final Node < ? , ? > node , final DataElement dataElement ) { if ( node != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] node . setRed ( dataElement ) ; } }
private int doHashCode ( final DataElement dataElement ) { int total = 0 ; if ( nodeCount > 0 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[S] for ( final MapIterator < ? , ? > it = getMapIterator ( dataElement ) ; it . hasNext () ; ) {
Node < K , V > parent = node . getParent ( dataElement ) ; Node < K , V > child = node ; while ( parent != null && child == parent . getRight ( dataElement ) ) { MST[rv.ROR5Mutator]MSP[S] child = parent ;
private int doHashCode ( final DataElement dataElement ) { int total = 0 ; if ( nodeCount > 0 ) { MST[rv.ROR5Mutator]MSP[S] for ( final MapIterator < ? , ? > it = getMapIterator ( dataElement ) ; it . hasNext () ; ) {
if ( node == null ) { final Node < K , V > root = new Node <> ( key , value ) ; MST[ConstructorCallMutator]MSP[N] rootNode [ KEY . ordinal () ] = root ; rootNode [ VALUE . ordinal () ] = root ; grow () ;
rotateLeft ( getGrandParent ( currentNode , dataElement ) , dataElement ) ; MST[NonVoidMethodCallMutator]MSP[S] } } } } makeBlack ( rootNode [ dataElement . ordinal () ] , dataElement ) ; } private void doRedBlackDelete ( final Node < K , V > deletedNode ) {
if ( node == null ) { rval = null ; } else if ( node . getRight ( dataElement ) != null ) { rval = leastNode ( node . getRight ( dataElement ) , dataElement ) ; MST[NonVoidMethodCallMutator]MSP[S] } else {
boolean hasNext = it . hasNext () ; while ( hasNext ) { final Object key = it . next () ; final Object value = it . getValue () ; buf . append ( key == this ? lr_8 : key ) MST[rv.CRCR1Mutator]MSP[S] . append ( '=' )
Node < K , V > rval = node ; if ( rval != null ) { while ( rval . getRight ( dataElement ) != null ) { MST[NonVoidMethodCallMutator]MSP[S] rval = rval . getRight ( dataElement ) ; } } return rval ; }
makeRed ( getGrandParent ( currentNode , dataElement ) , dataElement ) ; currentNode = getGrandParent ( currentNode , dataElement ) ; } else { if ( currentNode . isRightChild ( dataElement ) ) { MST[rv.ROR5Mutator]MSP[S] currentNode = getParent ( currentNode , dataElement ) ; rotateLeft ( currentNode , dataElement ) ;
final Node < K , V > y = getRightChild ( getGrandParent ( currentNode , dataElement ) , dataElement ) ; if ( isRed ( y , dataElement ) ) { makeBlack ( getParent ( currentNode , dataElement ) , dataElement ) ; MST[ArgumentPropagationMutator]MSP[S] makeBlack ( y , dataElement ) ;
lr_6 + newNode . getData ( VALUE ) + lr_3 ) ; } else if ( cmp < 0 ) { MST[rv.UOI3Mutator]MSP[S] if ( node . getLeft ( VALUE ) != null ) { node = node . getLeft ( VALUE ) ; } else {
if ( value . equals ( other . get ( key ) ) == false ) { return false ; } } } catch ( final ClassCastException ex ) { return false ; } catch ( final NullPointerException ex ) { return false ; } } return true ; MST[rv.CRCR3Mutator]MSP[S] }
private Node < K , V > lookupKey ( final Object key ) { return this . <K > lookup ( key , KEY ) ; MST[NonVoidMethodCallMutator]MSP[N] } private Node < K , V > lookupValue ( final Object value ) {
newNode . setParent ( node , KEY ) ; doRedBlackInsert ( newNode , KEY ) ; MST[VoidMethodCallMutator]MSP[S] grow () ; break; } } } } } private V doRemoveKey ( final Object key ) { final Node < K , V > node = lookupKey ( key ) ;
if ( rightChild . getLeft ( dataElement ) != null ) { rightChild . getLeft ( dataElement ) . setParent ( node , dataElement ) ; } rightChild . setParent ( node . getParent ( dataElement ) , dataElement ) ; MST[ArgumentPropagationMutator]MSP[S]
private int doHashCode ( final DataElement dataElement ) { int total = 0 ; if ( nodeCount > 0 ) { for ( final MapIterator < ? , ? > it = getMapIterator ( dataElement ) ; it . hasNext () ; ) { MST[rv.ROR3Mutator]MSP[S]
} private void modify () { modifications ++ ; } private void grow () { modify () ; nodeCount ++ ; MST[rv.AOR1Mutator]MSP[N] } private void shrink () { modify () ; nodeCount -- ; } private void insertValue ( final Node < K , V > newNode ) throws IllegalArgumentException {
if ( nodeCount == 0 ) { return lr_7 ; } final StringBuilder buf = new StringBuilder ( nodeCount * 32 ) ; MST[ConstructorCallMutator]MSP[S] buf . append ( '{' ) ; final MapIterator < ? , ? > it = getMapIterator ( dataElement ) ;
return greatestNode ( rootNode [ KEY . ordinal () ] , KEY ) . getKey () ; } @Override public K nextKey ( final K key ) { checkKey ( key ) ; MST[VoidMethodCallMutator]MSP[S]
private static boolean isBlack ( final Node < ? , ? > node , final DataElement dataElement ) { return node == null || node . isBlack ( dataElement ) ; MST[rv.CRCR3Mutator]MSP[S] }
Node < K , V > currentNode = replacementNode ; while ( currentNode != rootNode [ dataElement . ordinal () ] && isBlack ( currentNode , dataElement ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] if ( currentNode . isLeftChild ( dataElement ) ) {
@Override public String toString () { return description ; } @Override public int size () { return nodeCount ; MST[rv.UOI1Mutator]MSP[N] } @Override public boolean isEmpty () { return nodeCount == 0 ; } @Override public boolean containsKey ( final Object key ) { checkKey ( key ) ;
return EmptyOrderedMapIterator . <K , V > emptyOrderedMapIterator () ; MST[NullReturnValsMutator]MSP[S] } return new ViewMapIterator ( KEY ) ; } @Override public OrderedBidiMap < V , K > inverseBidiMap () { if ( inverse == null ) { inverse = new Inverse () ; } return inverse ; } @Override
public K getKey ( final Object value ) { checkValue ( value ) ; final Node < K , V > node = lookupValue ( value ) ; return node == null ? null : node . getKey () ; MST[NullReturnValsMutator]MSP[S] } @Override
final Node < K , V > node = nextGreater ( lookupKey ( key ) , KEY ) ; return node == null ? null : node . getKey () ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] } @Override public K previousKey ( final K key ) { checkKey ( key ) ;
private static boolean isBlack ( final Node < ? , ? > node , final DataElement dataElement ) { return node == null || node . isBlack ( dataElement ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] }
@Override public String toString () { return description ; } @Override public int size () { return nodeCount ; MST[rv.UOI4Mutator]MSP[N] } @Override public boolean isEmpty () { return nodeCount == 0 ; } @Override public boolean containsKey ( final Object key ) { checkKey ( key ) ;
for ( final MapIterator < ? , ? > it = getMapIterator ( dataElement ) ; it . hasNext () ; ) { MST[rv.ROR4Mutator]MSP[S] final Object key = it . next () ; final Object value = it . getValue () ;
final Node < K , V > node = lookupKey ( key ) ; return node == null ? null : node . getValue () ; MST[NonVoidMethodCallMutator]MSP[S] } @Override public V put ( final K key , final V value ) { final V result = get ( key ) ;
Node < K , V > node = rootNode [ dataElement . ordinal () ] ; while ( node != null ) { MST[NegateConditionalsMutator]MSP[S] final int cmp = compare ( ( T ) data , ( T ) node . getData ( dataElement ) ) ;
final Node < K , V > y = getRightChild ( getGrandParent ( currentNode , dataElement ) , dataElement ) ; MST[ArgumentPropagationMutator]MSP[S] if ( isRed ( y , dataElement ) ) { makeBlack ( getParent ( currentNode , dataElement ) , dataElement ) ; makeBlack ( y , dataElement ) ;
} private void modify () { modifications ++ ; } private void grow () { modify () ; nodeCount ++ ; MST[rv.UOI4Mutator]MSP[N] } private void shrink () { modify () ; nodeCount -- ; } private void insertValue ( final Node < K , V > newNode ) throws IllegalArgumentException {
final Object key = it . next () ; MST[NonVoidMethodCallMutator]MSP[S] final Object value = it . getValue () ; total += key . hashCode () ^ value . hashCode () ; } } return total ; } private String doToString ( final DataElement dataElement ) {
if ( nodeCount == 0 ) { return lr_7 ; } final StringBuilder buf = new StringBuilder ( nodeCount * 32 ) ; buf . append ( '{' ) ; MST[rv.CRCR4Mutator]MSP[S] final MapIterator < ? , ? > it = getMapIterator ( dataElement ) ;
if ( leftChild . getRight ( dataElement ) != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] leftChild . getRight ( dataElement ) . setParent ( node , dataElement ) ; } leftChild . setParent ( node . getParent ( dataElement ) , dataElement ) ;
Node < K , V > rval = node ; if ( rval != null ) { while ( rval . getRight ( dataElement ) != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] rval = rval . getRight ( dataElement ) ; } } return rval ; }
node = node . getRight ( KEY ) ; } else { final Node < K , V > newNode = new Node <> ( key , value ) ; insertValue ( newNode ) ; node . setRight ( newNode , KEY ) ; MST[VoidMethodCallMutator]MSP[S]
private static void makeBlack ( final Node < ? , ? > node , final DataElement dataElement ) { if ( node != null ) { MST[rv.ROR5Mutator]MSP[S] node . setBlack ( dataElement ) ; } }
} private void modify () { modifications ++ ; MST[experimental.MemberVariableMutator]MSP[S] } private void grow () { modify () ; nodeCount ++ ; } private void shrink () { modify () ; nodeCount -- ; } private void insertValue ( final Node < K , V > newNode ) throws IllegalArgumentException {
private static boolean isBlack ( final Node < ? , ? > node , final DataElement dataElement ) { return node == null || node . isBlack ( dataElement ) ; MST[rv.CRCR6Mutator]MSP[S] }
final Node < K , V > node = nextGreater ( lookupKey ( key ) , KEY ) ; return node == null ? null : node . getKey () ; MST[rv.ROR5Mutator]MSP[S] } @Override public K previousKey ( final K key ) { checkKey ( key ) ;
if ( node == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] rval = null ; } else if ( node . getRight ( dataElement ) != null ) { rval = leastNode ( node . getRight ( dataElement ) , dataElement ) ; } else {
final Object key = it . next () ; final Object value = it . getValue () ; total += key . hashCode () ^ value . hashCode () ; } } return total ; MST[rv.UOI4Mutator]MSP[S] } private String doToString ( final DataElement dataElement ) {
if ( rightChild . getLeft ( dataElement ) != null ) { MST[rv.ROR5Mutator]MSP[S] rightChild . getLeft ( dataElement ) . setParent ( node , dataElement ) ; } rightChild . setParent ( node . getParent ( dataElement ) , dataElement ) ;
if ( deletedNode . getParent ( dataElement ) == null ) { rootNode [ dataElement . ordinal () ] = null ; } else { if ( isBlack ( deletedNode , dataElement ) ) { MST[rv.ROR4Mutator]MSP[S] doRedBlackDeleteFixup ( deletedNode , dataElement ) ; }
boolean hasNext = it . hasNext () ; while ( hasNext ) { MST[rv.ROR1Mutator]MSP[S] final Object key = it . next () ; final Object value = it . getValue () ; buf . append ( key == this ? lr_8 : key ) . append ( '=' )
if ( rightChild . getLeft ( dataElement ) != null ) { rightChild . getLeft ( dataElement ) . setParent ( node , dataElement ) ; } rightChild . setParent ( node . getParent ( dataElement ) , dataElement ) ; MST[VoidMethodCallMutator]MSP[S]
boolean hasNext = it . hasNext () ; while ( hasNext ) { final Object key = it . next () ; final Object value = it . getValue () ; buf . append ( key == this ? lr_8 : key ) MST[rv.ROR5Mutator]MSP[S] . append ( '=' )
final Node < K , V > node = nextGreater ( lookupKey ( key ) , KEY ) ; return node == null ? null : node . getKey () ; MST[NegateConditionalsMutator]MSP[S] } @Override public K previousKey ( final K key ) { checkKey ( key ) ;
rotateLeft ( getGrandParent ( currentNode , dataElement ) , dataElement ) ; } } } } makeBlack ( rootNode [ dataElement . ordinal () ] , dataElement ) ; MST[VoidMethodCallMutator]MSP[S] } private void doRedBlackDelete ( final Node < K , V > deletedNode ) {
private Node < K , V > getGrandParent ( final Node < K , V > node , final DataElement dataElement ) { return getParent ( getParent ( node , dataElement ) , dataElement ) ; MST[ArgumentPropagationMutator]MSP[S] }
node . setLeft ( newNode , KEY ) ; newNode . setParent ( node , KEY ) ; MST[VoidMethodCallMutator]MSP[S] doRedBlackInsert ( newNode , KEY ) ; grow () ; break; } } else { if ( node . getRight ( KEY ) != null ) {
node . setLeft ( newNode , VALUE ) ; newNode . setParent ( node , VALUE ) ; doRedBlackInsert ( newNode , VALUE ) ; break; } } else { if ( node . getRight ( VALUE ) != null ) { MST[ArgumentPropagationMutator]MSP[S]
return lookupKey ( key ) != null ; } @Override public boolean containsValue ( final Object value ) { checkValue ( value ) ; return lookupValue ( value ) != null ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] } @Override public V get ( final Object key ) { checkKey ( key ) ;
Node < K , V > parent = node . getParent ( dataElement ) ; Node < K , V > child = node ; while ( parent != null && child == parent . getRight ( dataElement ) ) { MST[ArgumentPropagationMutator]MSP[S] child = parent ;
Node < K , V > parent = node . getParent ( dataElement ) ; Node < K , V > child = node ; while ( parent != null && child == parent . getRight ( dataElement ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] child = parent ;
return lookupKey ( key ) != null ; MST[NonVoidMethodCallMutator]MSP[S] } @Override public boolean containsValue ( final Object value ) { checkValue ( value ) ; return lookupValue ( value ) != null ; } @Override public V get ( final Object key ) { checkKey ( key ) ;
for ( final DataElement dataElement : DataElement . values () ) { MST[rv.UOI4Mutator]MSP[S] if ( deletedNode . getLeft ( dataElement ) != null && deletedNode . getRight ( dataElement ) != null ) { swapPosition ( nextGreater ( deletedNode , dataElement ) , deletedNode , dataElement ) ; }
private void doPut ( final K key , final V value ) { checkKeyAndValue ( key , value ) ; doRemoveKey ( key ) ; MST[NonVoidMethodCallMutator]MSP[S] doRemoveValue ( value ) ; Node < K , V > node = rootNode [ KEY . ordinal () ] ;
Node < K , V > rval = node ; if ( rval != null ) { while ( rval . getRight ( dataElement ) != null ) { MST[rv.ROR5Mutator]MSP[S] rval = rval . getRight ( dataElement ) ; } } return rval ; }
} private void modify () { modifications ++ ; } private void grow () { modify () ; nodeCount ++ ; } private void shrink () { modify () ; nodeCount -- ; MST[rv.AOD1Mutator]MSP[S] } private void insertValue ( final Node < K , V > newNode ) throws IllegalArgumentException {
lr_6 + newNode . getData ( VALUE ) + lr_3 ) ; } else if ( cmp < 0 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[S] if ( node . getLeft ( VALUE ) != null ) { node = node . getLeft ( VALUE ) ; } else {
if ( rightChild . getLeft ( dataElement ) != null ) { MST[NegateConditionalsMutator]MSP[S] rightChild . getLeft ( dataElement ) . setParent ( node , dataElement ) ; } rightChild . setParent ( node . getParent ( dataElement ) , dataElement ) ;
} private void doRedBlackInsert ( final Node < K , V > insertedNode , final DataElement dataElement ) { Node < K , V > currentNode = insertedNode ; makeRed ( currentNode , dataElement ) ; MST[VoidMethodCallMutator]MSP[S] while ( currentNode != null
final Object key = it . next () ; final Object value = it . getValue () ; total += key . hashCode () ^ value . hashCode () ; MST[rv.UOI1Mutator]MSP[S] } } return total ; } private String doToString ( final DataElement dataElement ) {
final Object key = it . next () ; final Object value = it . getValue () ; total += key . hashCode () ^ value . hashCode () ; MST[rv.AOR2Mutator]MSP[S] } } return total ; } private String doToString ( final DataElement dataElement ) {
Objects . requireNonNull ( obj , Objects . toString ( dataElement ) ) ; if ( ! ( obj instanceof Comparable ) ) { throw new ClassCastException ( dataElement + lr_5 ) ; MST[ConstructorCallMutator]MSP[S] } } private static void checkKey ( final Object key ) {
} private void modify () { modifications ++ ; } private void grow () { modify () ; nodeCount ++ ; } private void shrink () { modify () ; nodeCount -- ; MST[InlineConstantMutator]MSP[S] } private void insertValue ( final Node < K , V > newNode ) throws IllegalArgumentException {
} else { while ( true ) { final int cmp = compare ( key , node . getKey () ) ; if ( cmp == 0 ) { MST[rv.ROR2Mutator]MSP[S] throw new IllegalArgumentException ( lr_2 + key + lr_3 ) ; } else if ( cmp < 0 ) {
. append ( value == this ? lr_8 : value ) ; hasNext = it . hasNext () ; if ( hasNext ) { MST[rv.UOI1Mutator]MSP[S] buf . append ( lr_9 ) ; } } buf . append ( '}' ) ; return buf . toString () ; }
for ( final DataElement dataElement : DataElement . values () ) { MST[rv.UOI1Mutator]MSP[S] if ( deletedNode . getLeft ( dataElement ) != null && deletedNode . getRight ( dataElement ) != null ) { swapPosition ( nextGreater ( deletedNode , dataElement ) , deletedNode , dataElement ) ; }
public Set < Map . Entry < K , V > > entrySet () { if ( entrySet == null ) { entrySet = new EntryView () ; } return entrySet ; } @Override public OrderedMapIterator < K , V > mapIterator () { if ( isEmpty () ) { MST[rv.ROR4Mutator]MSP[S]
return doRemoveKey ( key ) ; MST[ReturnValsMutator]MSP[S] } @Override public void clear () { modify () ; nodeCount = 0 ; rootNode [ KEY . ordinal () ] = null ; rootNode [ VALUE . ordinal () ] = null ; } @Override
. append ( value == this ? lr_8 : value ) ; hasNext = it . hasNext () ; if ( hasNext ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] buf . append ( lr_9 ) ; } } buf . append ( '}' ) ; return buf . toString () ; }
} deletedNode . setLeft ( null , dataElement ) ; deletedNode . setRight ( null , dataElement ) ; deletedNode . setParent ( null , dataElement ) ; if ( isBlack ( deletedNode , dataElement ) ) { MST[rv.ROR1Mutator]MSP[S] doRedBlackDeleteFixup ( replacement , dataElement ) ; } } else {
node = node . getRight ( VALUE ) ; } else { node . setRight ( newNode , VALUE ) ; newNode . setParent ( node , VALUE ) ; doRedBlackInsert ( newNode , VALUE ) ; MST[VoidMethodCallMutator]MSP[S] break; } } } }
} else if ( deletedNode == deletedNode . getParent ( dataElement ) . getLeft ( dataElement ) ) { deletedNode . getParent ( dataElement ) . setLeft ( replacement , dataElement ) ; } else { deletedNode . getParent ( dataElement ) . setRight ( replacement , dataElement ) ; MST[ArgumentPropagationMutator]MSP[S]
private static void makeRed ( final Node < ? , ? > node , final DataElement dataElement ) { if ( node != null ) { MST[NegateConditionalsMutator]MSP[S] node . setRed ( dataElement ) ; } }
private boolean doEquals ( final Object obj , final DataElement dataElement ) { if ( obj == this ) { MST[rv.ROR5Mutator]MSP[N] return true ; } if ( obj instanceof Map == false ) { return false ; }
if ( node . getParent ( dataElement ) == null ) { rootNode [ dataElement . ordinal () ] = leftChild ; MST[NonVoidMethodCallMutator]MSP[S] } else if ( node . getParent ( dataElement ) . getRight ( dataElement ) == node ) {
private int doHashCode ( final DataElement dataElement ) { int total = 0 ; MST[rv.CRCR6Mutator]MSP[S] if ( nodeCount > 0 ) { for ( final MapIterator < ? , ? > it = getMapIterator ( dataElement ) ; it . hasNext () ; ) {
boolean hasNext = it . hasNext () ; while ( hasNext ) { final Object key = it . next () ; final Object value = it . getValue () ; buf . append ( key == this ? lr_8 : key ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] . append ( '=' )
public K removeValue ( final Object value ) { return doRemoveValue ( value ) ; } @Override public K firstKey () { if ( nodeCount == 0 ) { MST[rv.ROR3Mutator]MSP[S] throw new NoSuchElementException ( lr_1 ) ; }
final Node < K , V > node = lookupKey ( key ) ; return node == null ? null : node . getValue () ; MST[rv.ROR5Mutator]MSP[S] } @Override public V put ( final K key , final V value ) { final V result = get ( key ) ;
&& currentNode != rootNode [ dataElement . ordinal () ] && isRed ( currentNode . getParent ( dataElement ) , dataElement ) ) { if ( currentNode . isLeftChild ( dataElement ) ) { MST[NonVoidMethodCallMutator]MSP[S]
@Override public String toString () { return description ; } @Override public int size () { return nodeCount ; } @Override public boolean isEmpty () { return nodeCount == 0 ; MST[rv.CRCR4Mutator]MSP[S] } @Override public boolean containsKey ( final Object key ) { checkKey ( key ) ;
public K removeValue ( final Object value ) { return doRemoveValue ( value ) ; } @Override public K firstKey () { if ( nodeCount == 0 ) { MST[rv.ABSMutator]MSP[S] throw new NoSuchElementException ( lr_1 ) ; }
makeRed ( getGrandParent ( currentNode , dataElement ) , dataElement ) ; currentNode = getGrandParent ( currentNode , dataElement ) ; } else { if ( currentNode . isRightChild ( dataElement ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] currentNode = getParent ( currentNode , dataElement ) ; rotateLeft ( currentNode , dataElement ) ;
} private void modify () { modifications ++ ; } private void grow () { modify () ; nodeCount ++ ; } private void shrink () { modify () ; nodeCount -- ; MST[rv.AOR2Mutator]MSP[S] } private void insertValue ( final Node < K , V > newNode ) throws IllegalArgumentException {
. append ( value == this ? lr_8 : value ) ; hasNext = it . hasNext () ; if ( hasNext ) { MST[rv.UOI4Mutator]MSP[S] buf . append ( lr_9 ) ; } } buf . append ( '}' ) ; return buf . toString () ; }
. append ( value == this ? lr_8 : value ) ; hasNext = it . hasNext () ; if ( hasNext ) { buf . append ( lr_9 ) ; MST[experimental.NakedReceiverMutator]MSP[S] } } buf . append ( '}' ) ; return buf . toString () ; }
rotateRight ( currentNode , dataElement ) ; } makeBlack ( getParent ( currentNode , dataElement ) , dataElement ) ; makeRed ( getGrandParent ( currentNode , dataElement ) , dataElement ) ; MST[VoidMethodCallMutator]MSP[S] if ( getGrandParent ( currentNode , dataElement ) != null ) {
makeBlack ( y , dataElement ) ; makeRed ( getGrandParent ( currentNode , dataElement ) , dataElement ) ; currentNode = getGrandParent ( currentNode , dataElement ) ; } else { if ( currentNode . isLeftChild ( dataElement ) ) { MST[rv.ROR5Mutator]MSP[S] currentNode = getParent ( currentNode , dataElement ) ;
} deletedNode . setLeft ( null , dataElement ) ; deletedNode . setRight ( null , dataElement ) ; deletedNode . setParent ( null , dataElement ) ; if ( isBlack ( deletedNode , dataElement ) ) { MST[rv.ROR4Mutator]MSP[S] doRedBlackDeleteFixup ( replacement , dataElement ) ; } } else {
} makeBlack ( getParent ( currentNode , dataElement ) , dataElement ) ; makeRed ( getGrandParent ( currentNode , dataElement ) , dataElement ) ; MST[NonVoidMethodCallMutator]MSP[S] if ( getGrandParent ( currentNode , dataElement ) != null ) { rotateRight ( getGrandParent ( currentNode , dataElement ) , dataElement ) ; }
Node < K , V > node = rootNode [ VALUE . ordinal () ] ; while ( true ) { final int cmp = compare ( newNode . getValue () , node . getValue () ) ; if ( cmp == 0 ) { MST[rv.ROR1Mutator]MSP[S] throw new IllegalArgumentException (
makeRed ( getGrandParent ( currentNode , dataElement ) , dataElement ) ; currentNode = getGrandParent ( currentNode , dataElement ) ; MST[ArgumentPropagationMutator]MSP[S] } else { if ( currentNode . isRightChild ( dataElement ) ) { currentNode = getParent ( currentNode , dataElement ) ; rotateLeft ( currentNode , dataElement ) ;
} private void modify () { modifications ++ ; } private void grow () { modify () ; nodeCount ++ ; MST[rv.CRCR4Mutator]MSP[N] } private void shrink () { modify () ; nodeCount -- ; } private void insertValue ( final Node < K , V > newNode ) throws IllegalArgumentException {
final Object key = it . next () ; final Object value = it . getValue () ; total += key . hashCode () ^ value . hashCode () ; MST[NonVoidMethodCallMutator]MSP[S] } } return total ; } private String doToString ( final DataElement dataElement ) {
if ( node == null ) { MST[rv.ROR5Mutator]MSP[S] return null ; } doRedBlackDelete ( node ) ; return node . getKey () ; } @SuppressWarnings ( lr_4 )
if ( node == null ) { rval = null ; } else if ( node . getRight ( dataElement ) != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] rval = leastNode ( node . getRight ( dataElement ) , dataElement ) ; } else {
private static boolean isBlack ( final Node < ? , ? > node , final DataElement dataElement ) { return node == null || node . isBlack ( dataElement ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] }
if ( cmp == 0 ) { rval = node ; break; } node = cmp < 0 ? node . getLeft ( dataElement ) : node . getRight ( dataElement ) ; MST[rv.UOI3Mutator]MSP[S] } return rval ; }
for ( final MapIterator < ? , ? > it = getMapIterator ( dataElement ) ; it . hasNext () ; ) { MST[rv.ROR1Mutator]MSP[S] final Object key = it . next () ; final Object value = it . getValue () ;
if ( nodeCount == 0 ) { return lr_7 ; } final StringBuilder buf = new StringBuilder ( nodeCount * 32 ) ; MST[MathMutator]MSP[S] buf . append ( '{' ) ; final MapIterator < ? , ? > it = getMapIterator ( dataElement ) ;
if ( nodeCount == 0 ) { return lr_7 ; } final StringBuilder buf = new StringBuilder ( nodeCount * 32 ) ; buf . append ( '{' ) ; MST[rv.CRCR1Mutator]MSP[S] final MapIterator < ? , ? > it = getMapIterator ( dataElement ) ;
rotateRight ( currentNode , dataElement ) ; } makeBlack ( getParent ( currentNode , dataElement ) , dataElement ) ; MST[ArgumentPropagationMutator]MSP[N] makeRed ( getGrandParent ( currentNode , dataElement ) , dataElement ) ; if ( getGrandParent ( currentNode , dataElement ) != null ) {
Node < K , V > parent = node . getParent ( dataElement ) ; Node < K , V > child = node ; while ( parent != null && child == parent . getRight ( dataElement ) ) { MST[NegateConditionalsMutator]MSP[N] child = parent ;
for ( final Map . Entry < ? extends K , ? extends V > e : map . entrySet () ) { MST[NonVoidMethodCallMutator]MSP[S] put ( e . getKey () , e . getValue () ) ; } } @Override public V remove ( final Object key ) {
if ( node == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] final Node < K , V > root = new Node <> ( key , value ) ; rootNode [ KEY . ordinal () ] = root ; rootNode [ VALUE . ordinal () ] = root ; grow () ;
if ( node == null ) { MST[rv.ROR5Mutator]MSP[S] return null ; } doRedBlackDelete ( node ) ; return node . getValue () ; } private K doRemoveValue ( final Object value ) { final Node < K , V > node = lookupValue ( value ) ;
} makeBlack ( getParent ( currentNode , dataElement ) , dataElement ) ; MST[VoidMethodCallMutator]MSP[N] makeRed ( getGrandParent ( currentNode , dataElement ) , dataElement ) ; if ( getGrandParent ( currentNode , dataElement ) != null ) { rotateRight ( getGrandParent ( currentNode , dataElement ) , dataElement ) ; }
final Map < ? , ? > other = ( Map < ? , ? > ) obj ; if ( other . size () != size () ) { MST[rv.ROR4Mutator]MSP[N] return false ; } if ( nodeCount > 0 ) { try {
Node < K , V > node = rootNode [ VALUE . ordinal () ] ; while ( true ) { final int cmp = compare ( newNode . getValue () , node . getValue () ) ; if ( cmp == 0 ) { MST[rv.UOI3Mutator]MSP[N] throw new IllegalArgumentException (
Objects . requireNonNull ( obj , Objects . toString ( dataElement ) ) ; if ( ! ( obj instanceof Comparable ) ) { MST[rv.ROR2Mutator]MSP[N] throw new ClassCastException ( dataElement + lr_5 ) ; } } private static void checkKey ( final Object key ) {
if ( deletedNode . getParent ( dataElement ) == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] rootNode [ dataElement . ordinal () ] = null ; } else { if ( isBlack ( deletedNode , dataElement ) ) { doRedBlackDeleteFixup ( deletedNode , dataElement ) ; }
if ( nodeCount == 0 ) { return lr_7 ; } final StringBuilder buf = new StringBuilder ( nodeCount * 32 ) ; MST[rv.UOI3Mutator]MSP[S] buf . append ( '{' ) ; final MapIterator < ? , ? > it = getMapIterator ( dataElement ) ;
} deletedNode . setLeft ( null , dataElement ) ; MST[VoidMethodCallMutator]MSP[N] deletedNode . setRight ( null , dataElement ) ; deletedNode . setParent ( null , dataElement ) ; if ( isBlack ( deletedNode , dataElement ) ) { doRedBlackDeleteFixup ( replacement , dataElement ) ; } } else {
final Map < ? , ? > other = ( Map < ? , ? > ) obj ; if ( other . size () != size () ) { MST[NonVoidMethodCallMutator]MSP[N] return false ; } if ( nodeCount > 0 ) { try {
private void doPut ( final K key , final V value ) { checkKeyAndValue ( key , value ) ; doRemoveKey ( key ) ; doRemoveValue ( value ) ; Node < K , V > node = rootNode [ KEY . ordinal () ] ; MST[NonVoidMethodCallMutator]MSP[N]
} else { while ( true ) { final int cmp = compare ( key , node . getKey () ) ; if ( cmp == 0 ) { MST[rv.UOI4Mutator]MSP[N] throw new IllegalArgumentException ( lr_2 + key + lr_3 ) ; } else if ( cmp < 0 ) {
Node < K , V > parent = node . getParent ( dataElement ) ; Node < K , V > child = node ; while ( parent != null && child == parent . getRight ( dataElement ) ) { MST[rv.ROR5Mutator]MSP[N] child = parent ;
if ( nodeCount == 0 ) { return lr_7 ; } final StringBuilder buf = new StringBuilder ( nodeCount * 32 ) ; MST[rv.CRCR3Mutator]MSP[S] buf . append ( '{' ) ; final MapIterator < ? , ? > it = getMapIterator ( dataElement ) ;
if ( nodeCount == 0 ) { return lr_7 ; } final StringBuilder buf = new StringBuilder ( nodeCount * 32 ) ; buf . append ( '{' ) ; final MapIterator < ? , ? > it = getMapIterator ( dataElement ) ; MST[NonVoidMethodCallMutator]MSP[S]
final Node < K , V > y = getRightChild ( getGrandParent ( currentNode , dataElement ) , dataElement ) ; if ( isRed ( y , dataElement ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] makeBlack ( getParent ( currentNode , dataElement ) , dataElement ) ; makeBlack ( y , dataElement ) ;
public boolean equals ( final Object obj ) { return this . doEquals ( obj , KEY ) ; } @Override public int hashCode () { return this . doHashCode ( KEY ) ; } @Override public String toString () { return this . doToString ( KEY ) ; MST[ReturnValsMutator]MSP[N] }
node . setLeft ( newNode , VALUE ) ; newNode . setParent ( node , VALUE ) ; doRedBlackInsert ( newNode , VALUE ) ; break; } } else { if ( node . getRight ( VALUE ) != null ) { MST[rv.ROR5Mutator]MSP[S]
if ( leftChild . getRight ( dataElement ) != null ) { MST[NonVoidMethodCallMutator]MSP[N] leftChild . getRight ( dataElement ) . setParent ( node , dataElement ) ; } leftChild . setParent ( node . getParent ( dataElement ) , dataElement ) ;
return leastNode ( rootNode [ KEY . ordinal () ] , KEY ) . getKey () ; } @Override public K lastKey () { if ( nodeCount == 0 ) { MST[rv.ABSMutator]MSP[N] throw new NoSuchElementException ( lr_1 ) ; }
if ( cmp == 0 ) { rval = node ; break; } node = cmp < 0 ? node . getLeft ( dataElement ) : node . getRight ( dataElement ) ; MST[rv.ROR4Mutator]MSP[N] } return rval ; }
return lookupKey ( key ) != null ; MST[BooleanTrueReturnValsMutator]MSP[N] } @Override public boolean containsValue ( final Object value ) { checkValue ( value ) ; return lookupValue ( value ) != null ; } @Override public V get ( final Object key ) { checkKey ( key ) ;
return doRemoveKey ( key ) ; } @Override public void clear () { modify () ; nodeCount = 0 ; MST[experimental.MemberVariableMutator]MSP[N] rootNode [ KEY . ordinal () ] = null ; rootNode [ VALUE . ordinal () ] = null ; } @Override
parent = parent . getParent ( dataElement ) ; } rval = parent ; } return rval ; } private static < T extends Comparable < T > > int compare ( final T o1 , final T o2 ) { return o1 . compareTo ( o2 ) ; MST[PrimitiveReturnsMutator]MSP[N] }
private Node < K , V > leastNode ( final Node < K , V > node , final DataElement dataElement ) { Node < K , V > rval = node ; if ( rval != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
if ( deletedNode . getParent ( dataElement ) != null ) { if ( deletedNode == deletedNode . getParent ( dataElement ) . getLeft ( dataElement ) ) { MST[ArgumentPropagationMutator]MSP[N] deletedNode . getParent ( dataElement ) . setLeft ( null , dataElement ) ; } else {
return EmptyOrderedMapIterator . <K , V > emptyOrderedMapIterator () ; } return new ViewMapIterator ( KEY ) ; MST[NullReturnValsMutator]MSP[S] } @Override public OrderedBidiMap < V , K > inverseBidiMap () { if ( inverse == null ) { inverse = new Inverse () ; } return inverse ; } @Override
if ( cmp == 0 ) { rval = node ; break; } node = cmp < 0 ? node . getLeft ( dataElement ) : node . getRight ( dataElement ) ; MST[RemoveConditionalMutator_ORDER_IF]MSP[N] } return rval ; }
private static void makeRed ( final Node < ? , ? > node , final DataElement dataElement ) { if ( node != null ) { MST[rv.ROR5Mutator]MSP[S] node . setRed ( dataElement ) ; } }
private int doHashCode ( final DataElement dataElement ) { int total = 0 ; if ( nodeCount > 0 ) { MST[rv.ROR2Mutator]MSP[N] for ( final MapIterator < ? , ? > it = getMapIterator ( dataElement ) ; it . hasNext () ; ) {
private MapIterator < ? , ? > getMapIterator ( final DataElement dataElement ) { switch ( dataElement ) { MST[experimental.RemoveSwitchMutator_0]MSP[S] case KEY : return new ViewMapIterator ( KEY ) ; case VALUE : return new InverseViewMapIterator ( VALUE ) ; default: throw new IllegalArgumentException () ; } }
} } else { final Node < K , V > y = getLeftChild ( getGrandParent ( currentNode , dataElement ) , dataElement ) ; MST[NonVoidMethodCallMutator]MSP[S] if ( isRed ( y , dataElement ) ) { makeBlack ( getParent ( currentNode , dataElement ) , dataElement ) ;
} private void modify () { modifications ++ ; } private void grow () { modify () ; nodeCount ++ ; } private void shrink () { modify () ; nodeCount -- ; MST[rv.UOI1Mutator]MSP[N] } private void insertValue ( final Node < K , V > newNode ) throws IllegalArgumentException {
private MapIterator < ? , ? > getMapIterator ( final DataElement dataElement ) { switch ( dataElement ) { MST[experimental.RemoveSwitchMutator_1]MSP[S] case KEY : return new ViewMapIterator ( KEY ) ; case VALUE : return new InverseViewMapIterator ( VALUE ) ; default: throw new IllegalArgumentException () ; } }
public boolean equals ( final Object obj ) { return this . doEquals ( obj , KEY ) ; } @Override public int hashCode () { return this . doHashCode ( KEY ) ; MST[ReturnValsMutator]MSP[N] } @Override public String toString () { return this . doToString ( KEY ) ; }
return greatestNode ( rootNode [ KEY . ordinal () ] , KEY ) . getKey () ; MST[NullReturnValsMutator]MSP[S] } @Override public K nextKey ( final K key ) { checkKey ( key ) ;
keySet = new KeyView ( KEY ) ; } return keySet ; } @Override public Set < V > values () { if ( valuesSet == null ) { MST[rv.ROR5Mutator]MSP[S] valuesSet = new ValueView ( KEY ) ; } return valuesSet ; } @Override
} else { while ( true ) { final int cmp = compare ( key , node . getKey () ) ; if ( cmp == 0 ) { MST[rv.ROR5Mutator]MSP[S] throw new IllegalArgumentException ( lr_2 + key + lr_3 ) ; } else if ( cmp < 0 ) {
} private void modify () { modifications ++ ; } private void grow () { modify () ; nodeCount ++ ; MST[rv.AOD1Mutator]MSP[N] } private void shrink () { modify () ; nodeCount -- ; } private void insertValue ( final Node < K , V > newNode ) throws IllegalArgumentException {
rotateRight ( currentNode , dataElement ) ; } makeBlack ( getParent ( currentNode , dataElement ) , dataElement ) ; makeRed ( getGrandParent ( currentNode , dataElement ) , dataElement ) ; if ( getGrandParent ( currentNode , dataElement ) != null ) { MST[NonVoidMethodCallMutator]MSP[N]
if ( node == null ) { MST[NegateConditionalsMutator]MSP[N] return null ; } doRedBlackDelete ( node ) ; return node . getKey () ; } @SuppressWarnings ( lr_4 )
private static boolean isBlack ( final Node < ? , ? > node , final DataElement dataElement ) { return node == null || node . isBlack ( dataElement ) ; MST[NonVoidMethodCallMutator]MSP[N] }
if ( cmp == 0 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] rval = node ; break; } node = cmp < 0 ? node . getLeft ( dataElement ) : node . getRight ( dataElement ) ; } return rval ; }
} else { to . copyColor ( from , dataElement ) ; } } } private static boolean isRed ( final Node < ? , ? > node , final DataElement dataElement ) { return node != null && node . isRed ( dataElement ) ; MST[rv.ROR2Mutator]MSP[N] }
@Override public String toString () { return description ; } @Override public int size () { return nodeCount ; } @Override public boolean isEmpty () { return nodeCount == 0 ; MST[rv.UOI1Mutator]MSP[N] } @Override public boolean containsKey ( final Object key ) { checkKey ( key ) ;
@Override public String toString () { return description ; } @Override public int size () { return nodeCount ; } @Override public boolean isEmpty () { return nodeCount == 0 ; MST[BooleanTrueReturnValsMutator]MSP[N] } @Override public boolean containsKey ( final Object key ) { checkKey ( key ) ;
. append ( value == this ? lr_8 : value ) ; hasNext = it . hasNext () ; if ( hasNext ) { MST[rv.ROR2Mutator]MSP[N] buf . append ( lr_9 ) ; } } buf . append ( '}' ) ; return buf . toString () ; }
node . setLeft ( newNode , KEY ) ; newNode . setParent ( node , KEY ) ; doRedBlackInsert ( newNode , KEY ) ; grow () ; break; } } else { if ( node . getRight ( KEY ) != null ) { MST[NonVoidMethodCallMutator]MSP[N]
} else { while ( true ) { final int cmp = compare ( key , node . getKey () ) ; if ( cmp == 0 ) { throw new IllegalArgumentException ( lr_2 + key + lr_3 ) ; } else if ( cmp < 0 ) { MST[rv.ROR2Mutator]MSP[N]
. append ( value == this ? lr_8 : value ) ; hasNext = it . hasNext () ; if ( hasNext ) { buf . append ( lr_9 ) ; } } buf . append ( '}' ) ; MST[rv.CRCR6Mutator]MSP[S] return buf . toString () ; }
if ( node . getParent ( dataElement ) == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] rootNode [ dataElement . ordinal () ] = rightChild ; } else if ( node . getParent ( dataElement ) . getLeft ( dataElement ) == node ) {
&& currentNode != rootNode [ dataElement . ordinal () ] && isRed ( currentNode . getParent ( dataElement ) , dataElement ) ) { MST[rv.ROR4Mutator]MSP[N] if ( currentNode . isLeftChild ( dataElement ) ) {
Node < K , V > node = rootNode [ dataElement . ordinal () ] ; MST[NonVoidMethodCallMutator]MSP[N] while ( node != null ) { final int cmp = compare ( ( T ) data , ( T ) node . getData ( dataElement ) ) ;
if ( nodeCount == 0 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return lr_7 ; } final StringBuilder buf = new StringBuilder ( nodeCount * 32 ) ; buf . append ( '{' ) ; final MapIterator < ? , ? > it = getMapIterator ( dataElement ) ;
makeBlack ( y , dataElement ) ; makeRed ( getGrandParent ( currentNode , dataElement ) , dataElement ) ; currentNode = getGrandParent ( currentNode , dataElement ) ; } else { if ( currentNode . isLeftChild ( dataElement ) ) { MST[NegateConditionalsMutator]MSP[S] currentNode = getParent ( currentNode , dataElement ) ;
Node < K , V > parent = node . getParent ( dataElement ) ; MST[NonVoidMethodCallMutator]MSP[N] Node < K , V > child = node ; while ( parent != null && child == parent . getRight ( dataElement ) ) { child = parent ;
private boolean doEquals ( final Object obj , final DataElement dataElement ) { if ( obj == this ) { return true ; } if ( obj instanceof Map == false ) { MST[rv.ROR4Mutator]MSP[S] return false ; }
@Override public String toString () { return description ; } @Override public int size () { return nodeCount ; } @Override public boolean isEmpty () { return nodeCount == 0 ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } @Override public boolean containsKey ( final Object key ) { checkKey ( key ) ;
private int doHashCode ( final DataElement dataElement ) { int total = 0 ; if ( nodeCount > 0 ) { for ( final MapIterator < ? , ? > it = getMapIterator ( dataElement ) ; it . hasNext () ; ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
final Node < K , V > node = lookupKey ( key ) ; return node == null ? null : node . getValue () ; MST[NegateConditionalsMutator]MSP[S] } @Override public V put ( final K key , final V value ) { final V result = get ( key ) ;
boolean hasNext = it . hasNext () ; while ( hasNext ) { final Object key = it . next () ; final Object value = it . getValue () ; buf . append ( key == this ? lr_8 : key ) MST[rv.CRCR4Mutator]MSP[S] . append ( '=' )
. append ( value == this ? lr_8 : value ) ; MST[NonVoidMethodCallMutator]MSP[S] hasNext = it . hasNext () ; if ( hasNext ) { buf . append ( lr_9 ) ; } } buf . append ( '}' ) ; return buf . toString () ; }
public K removeValue ( final Object value ) { return doRemoveValue ( value ) ; MST[NonVoidMethodCallMutator]MSP[S] } @Override public K firstKey () { if ( nodeCount == 0 ) { throw new NoSuchElementException ( lr_1 ) ; }
makeRed ( getGrandParent ( currentNode , dataElement ) , dataElement ) ; currentNode = getGrandParent ( currentNode , dataElement ) ; } else { if ( currentNode . isRightChild ( dataElement ) ) { MST[rv.ROR2Mutator]MSP[N] currentNode = getParent ( currentNode , dataElement ) ; rotateLeft ( currentNode , dataElement ) ;
return node != null && node . getKey () . equals ( value ) ; } @Override public boolean remove ( final Object obj ) { if ( obj instanceof Map . Entry == false ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return false ; }
return node != null && node . getKey () . equals ( value ) ; } @Override public boolean remove ( final Object obj ) { if ( obj instanceof Map . Entry == false ) { MST[rv.ROR5Mutator]MSP[S] return false ; }
return new InverseViewMapEntryIterator () ; MST[ReturnValsMutator]MSP[S] } public final boolean hasNext () { return nextNode != null ; } protected Node < K , V > navigateNext () { if ( nextNode == null ) { throw new NoSuchElementException () ; } if ( modifications != expectedModifications ) {
return node != null && node . getKey () . equals ( value ) ; } @Override public boolean remove ( final Object obj ) { if ( obj instanceof Map . Entry == false ) { return false ; MST[rv.CRCR3Mutator]MSP[S] }
return node != null && node . getKey () . equals ( value ) ; } @Override public boolean remove ( final Object obj ) { if ( obj instanceof Map . Entry == false ) { return false ; MST[rv.CRCR5Mutator]MSP[S] }
return node != null && node . getKey () . equals ( value ) ; } @Override public boolean remove ( final Object obj ) { if ( obj instanceof Map . Entry == false ) { MST[rv.ROR1Mutator]MSP[N] return false ; }
return node != null && node . getKey () . equals ( value ) ; } @Override public boolean remove ( final Object obj ) { if ( obj instanceof Map . Entry == false ) { MST[rv.ROR3Mutator]MSP[N] return false ; }
return node != null && node . getKey () . equals ( value ) ; } @Override public boolean remove ( final Object obj ) { if ( obj instanceof Map . Entry == false ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] return false ; }
return node != null && node . getKey () . equals ( value ) ; } @Override public boolean remove ( final Object obj ) { if ( obj instanceof Map . Entry == false ) { return false ; MST[rv.CRCR1Mutator]MSP[S] }
public Iterator < Map . Entry < K , V > > iterator () { return new ViewMapEntryIterator () ; } @Override public boolean contains ( final Object obj ) { if ( obj instanceof Map . Entry == false ) { return false ; MST[InlineConstantMutator]MSP[S] }
public Iterator < Map . Entry < K , V > > iterator () { return new ViewMapEntryIterator () ; } @Override public boolean contains ( final Object obj ) { if ( obj instanceof Map . Entry == false ) { return false ; MST[BooleanTrueReturnValsMutator]MSP[S] }
return node != null && node . getKey () . equals ( value ) ; } @Override public boolean remove ( final Object obj ) { if ( obj instanceof Map . Entry == false ) { MST[NegateConditionalsMutator]MSP[S] return false ; }
public Iterator < Map . Entry < K , V > > iterator () { return new ViewMapEntryIterator () ; } @Override public boolean contains ( final Object obj ) { if ( obj instanceof Map . Entry == false ) { return false ; MST[rv.CRCR1Mutator]MSP[S] }
public Iterator < Map . Entry < K , V > > iterator () { return new ViewMapEntryIterator () ; } @Override public boolean contains ( final Object obj ) { if ( obj instanceof Map . Entry == false ) { return false ; MST[rv.CRCR5Mutator]MSP[S] }
return new InverseViewMapEntryIterator () ; MST[ConstructorCallMutator]MSP[S] } public final boolean hasNext () { return nextNode != null ; } protected Node < K , V > navigateNext () { if ( nextNode == null ) { throw new NoSuchElementException () ; } if ( modifications != expectedModifications ) {
public Iterator < Map . Entry < K , V > > iterator () { return new ViewMapEntryIterator () ; } @Override public boolean contains ( final Object obj ) { if ( obj instanceof Map . Entry == false ) { MST[rv.ROR5Mutator]MSP[S] return false ; }
public Iterator < Map . Entry < K , V > > iterator () { return new ViewMapEntryIterator () ; } @Override public boolean contains ( final Object obj ) { if ( obj instanceof Map . Entry == false ) { return false ; MST[ReturnValsMutator]MSP[S] }
public Iterator < Map . Entry < K , V > > iterator () { return new ViewMapEntryIterator () ; } @Override public boolean contains ( final Object obj ) { if ( obj instanceof Map . Entry == false ) { MST[rv.ROR4Mutator]MSP[S] return false ; }
public Iterator < Map . Entry < K , V > > iterator () { return new ViewMapEntryIterator () ; } @Override public boolean contains ( final Object obj ) { if ( obj instanceof Map . Entry == false ) { MST[rv.ROR1Mutator]MSP[N] return false ; }
return node != null && node . getKey () . equals ( value ) ; } @Override public boolean remove ( final Object obj ) { if ( obj instanceof Map . Entry == false ) { MST[rv.ROR4Mutator]MSP[S] return false ; }
return node != null && node . getKey () . equals ( value ) ; } @Override public boolean remove ( final Object obj ) { if ( obj instanceof Map . Entry == false ) { return false ; MST[ReturnValsMutator]MSP[S] }
return node != null && node . getKey () . equals ( value ) ; } @Override public boolean remove ( final Object obj ) { if ( obj instanceof Map . Entry == false ) { return false ; MST[InlineConstantMutator]MSP[S] }
public Iterator < Map . Entry < K , V > > iterator () { return new ViewMapEntryIterator () ; } @Override public boolean contains ( final Object obj ) { if ( obj instanceof Map . Entry == false ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] return false ; }
public Iterator < Map . Entry < K , V > > iterator () { return new ViewMapEntryIterator () ; } @Override public boolean contains ( final Object obj ) { if ( obj instanceof Map . Entry == false ) { MST[NegateConditionalsMutator]MSP[S] return false ; }
public Iterator < Map . Entry < K , V > > iterator () { return new ViewMapEntryIterator () ; } @Override public boolean contains ( final Object obj ) { if ( obj instanceof Map . Entry == false ) { return false ; MST[rv.CRCR6Mutator]MSP[S] }
return new InverseViewMapEntryIterator () ; MST[NullReturnValsMutator]MSP[S] } public final boolean hasNext () { return nextNode != null ; } protected Node < K , V > navigateNext () { if ( nextNode == null ) { throw new NoSuchElementException () ; } if ( modifications != expectedModifications ) {
public Iterator < Map . Entry < K , V > > iterator () { return new ViewMapEntryIterator () ; } @Override public boolean contains ( final Object obj ) { if ( obj instanceof Map . Entry == false ) { return false ; MST[rv.CRCR3Mutator]MSP[S] }
public Iterator < Map . Entry < K , V > > iterator () { return new ViewMapEntryIterator () ; } @Override public boolean contains ( final Object obj ) { if ( obj instanceof Map . Entry == false ) { MST[rv.ROR3Mutator]MSP[N] return false ; }
public Iterator < Map . Entry < K , V > > iterator () { return new ViewMapEntryIterator () ; } @Override public boolean contains ( final Object obj ) { if ( obj instanceof Map . Entry == false ) { MST[rv.ROR2Mutator]MSP[S] return false ; }
return node != null && node . getKey () . equals ( value ) ; } @Override public boolean remove ( final Object obj ) { if ( obj instanceof Map . Entry == false ) { return false ; MST[BooleanTrueReturnValsMutator]MSP[S] }
public Iterator < Map . Entry < K , V > > iterator () { return new ViewMapEntryIterator () ; } @Override public boolean contains ( final Object obj ) { if ( obj instanceof Map . Entry == false ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return false ; }
return node != null && node . getKey () . equals ( value ) ; } @Override public boolean remove ( final Object obj ) { if ( obj instanceof Map . Entry == false ) { return false ; MST[rv.CRCR6Mutator]MSP[S] }
return node != null && node . getKey () . equals ( value ) ; } @Override public boolean remove ( final Object obj ) { if ( obj instanceof Map . Entry == false ) { MST[rv.ROR2Mutator]MSP[S] return false ; }
return createEntry ( navigateNext () ) ; MST[NonVoidMethodCallMutator]MSP[S] } @Override public Map . Entry < V , K > previous () { return createEntry ( navigatePrevious () ) ; } private Map . Entry < V , K > createEntry ( final Node < K , V > node ) {
return new UnmodifiableMapEntry <> ( node . getValue () , node . getKey () ) ; MST[NonVoidMethodCallMutator]MSP[S] } private Object getData ( final DataElement dataElement ) { switch ( dataElement ) { case KEY : return getKey () ; case VALUE : return getValue () ; default:
return new UnmodifiableMapEntry <> ( node . getValue () , node . getKey () ) ; MST[NonVoidMethodCallMutator]MSP[S] } private Object getData ( final DataElement dataElement ) { switch ( dataElement ) { case KEY : return getKey () ; case VALUE : return getValue () ; default:
return createEntry ( navigateNext () ) ; MST[NullReturnValsMutator]MSP[S] } @Override public Map . Entry < V , K > previous () { return createEntry ( navigatePrevious () ) ; } private Map . Entry < V , K > createEntry ( final Node < K , V > node ) {
return new UnmodifiableMapEntry <> ( node . getValue () , node . getKey () ) ; MST[NullReturnValsMutator]MSP[S] } private Object getData ( final DataElement dataElement ) { switch ( dataElement ) { case KEY : return getKey () ; case VALUE : return getValue () ; default:
return createEntry ( navigateNext () ) ; MST[NonVoidMethodCallMutator]MSP[S] } @Override public Map . Entry < V , K > previous () { return createEntry ( navigatePrevious () ) ; } private Map . Entry < V , K > createEntry ( final Node < K , V > node ) {
return new UnmodifiableMapEntry <> ( node . getValue () , node . getKey () ) ; MST[ReturnValsMutator]MSP[S] } private Object getData ( final DataElement dataElement ) { switch ( dataElement ) { case KEY : return getKey () ; case VALUE : return getValue () ; default:
return createEntry ( navigateNext () ) ; } @Override public Map . Entry < V , K > previous () { return createEntry ( navigatePrevious () ) ; MST[NonVoidMethodCallMutator]MSP[S] } private Map . Entry < V , K > createEntry ( final Node < K , V > node ) {
return createEntry ( navigateNext () ) ; MST[ReturnValsMutator]MSP[S] } @Override public Map . Entry < V , K > previous () { return createEntry ( navigatePrevious () ) ; } private Map . Entry < V , K > createEntry ( final Node < K , V > node ) {
return new UnmodifiableMapEntry <> ( node . getValue () , node . getKey () ) ; MST[ConstructorCallMutator]MSP[S] } private Object getData ( final DataElement dataElement ) { switch ( dataElement ) { case KEY : return getKey () ; case VALUE : return getValue () ; default:
public K getKey () { if ( lastReturnedNode == null ) { throw new IllegalStateException ( lr_10 ) ; } return lastReturnedNode . getKey () ; } @Override public V getValue () { if ( lastReturnedNode == null ) { MST[rv.ROR5Mutator]MSP[S] throw new IllegalStateException ( lr_11 ) ; }
return lastReturnedNode . getValue () ; MST[NonVoidMethodCallMutator]MSP[N] } @Override public V setValue ( final V obj ) { throw new UnsupportedOperationException () ; } @Override public K next () { return navigateNext () . getKey () ; } @Override public K previous () { return navigatePrevious () . getKey () ;
return lastReturnedNode . getValue () ; } @Override public V setValue ( final V obj ) { throw new UnsupportedOperationException () ; } @Override public K next () { return navigateNext () . getKey () ; MST[ReturnValsMutator]MSP[N] } @Override public K previous () { return navigatePrevious () . getKey () ;
return lastReturnedNode . getValue () ; } @Override public V setValue ( final V obj ) { throw new UnsupportedOperationException () ; MST[ConstructorCallMutator]MSP[S] } @Override public K next () { return navigateNext () . getKey () ; } @Override public K previous () { return navigatePrevious () . getKey () ;
return lastReturnedNode . getValue () ; } @Override public V setValue ( final V obj ) { throw new UnsupportedOperationException () ; } @Override public K next () { return navigateNext () . getKey () ; MST[NullReturnValsMutator]MSP[N] } @Override public K previous () { return navigatePrevious () . getKey () ;
return lastReturnedNode . getValue () ; MST[ReturnValsMutator]MSP[N] } @Override public V setValue ( final V obj ) { throw new UnsupportedOperationException () ; } @Override public K next () { return navigateNext () . getKey () ; } @Override public K previous () { return navigatePrevious () . getKey () ;
return lastReturnedNode . getValue () ; MST[NullReturnValsMutator]MSP[N] } @Override public V setValue ( final V obj ) { throw new UnsupportedOperationException () ; } @Override public K next () { return navigateNext () . getKey () ; } @Override public K previous () { return navigatePrevious () . getKey () ;
return lastReturnedNode . getValue () ; } @Override public V setValue ( final V obj ) { throw new UnsupportedOperationException () ; } @Override public K next () { return navigateNext () . getKey () ; MST[NonVoidMethodCallMutator]MSP[N] } @Override public K previous () { return navigatePrevious () . getKey () ;
return lastReturnedNode . getValue () ; } @Override public V setValue ( final V obj ) { throw new UnsupportedOperationException () ; } @Override public K next () { return navigateNext () . getKey () ; MST[NonVoidMethodCallMutator]MSP[N] } @Override public K previous () { return navigatePrevious () . getKey () ;
public K getKey () { if ( lastReturnedNode == null ) { MST[rv.ROR5Mutator]MSP[S] throw new IllegalStateException ( lr_10 ) ; } return lastReturnedNode . getKey () ; } @Override public V getValue () { if ( lastReturnedNode == null ) { throw new IllegalStateException ( lr_11 ) ; }
public K getKey () { if ( lastReturnedNode == null ) { MST[NegateConditionalsMutator]MSP[S] throw new IllegalStateException ( lr_10 ) ; } return lastReturnedNode . getKey () ; } @Override public V getValue () { if ( lastReturnedNode == null ) { throw new IllegalStateException ( lr_11 ) ; }
public K getKey () { if ( lastReturnedNode == null ) { throw new IllegalStateException ( lr_10 ) ; } return lastReturnedNode . getKey () ; } @Override public V getValue () { if ( lastReturnedNode == null ) { MST[NegateConditionalsMutator]MSP[S] throw new IllegalStateException ( lr_11 ) ; }
public K getKey () { if ( lastReturnedNode == null ) { throw new IllegalStateException ( lr_10 ) ; } return lastReturnedNode . getKey () ; } @Override public V getValue () { if ( lastReturnedNode == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] throw new IllegalStateException ( lr_11 ) ; }
return lastReturnedNode . getValue () ; } @Override public V setValue ( final V obj ) { throw new UnsupportedOperationException () ; } @Override public K next () { return navigateNext () . getKey () ; } @Override public K previous () { return navigatePrevious () . getKey () ; MST[NonVoidMethodCallMutator]MSP[S]
public K getKey () { if ( lastReturnedNode == null ) { throw new IllegalStateException ( MST[ConstructorCallMutator]MSP[S] lr_10 ) ; } return lastReturnedNode . getKey () ; } @Override public V getValue () { if ( lastReturnedNode == null ) { throw new IllegalStateException ( lr_11 ) ; }
public K getKey () { if ( lastReturnedNode == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] throw new IllegalStateException ( lr_10 ) ; } return lastReturnedNode . getKey () ; } @Override public V getValue () { if ( lastReturnedNode == null ) { throw new IllegalStateException ( lr_11 ) ; }
public K getKey () { if ( lastReturnedNode == null ) { throw new IllegalStateException ( lr_10 ) ; } return lastReturnedNode . getKey () ; } @Override public V getValue () { if ( lastReturnedNode == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] throw new IllegalStateException ( lr_11 ) ; }
