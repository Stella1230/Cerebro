if ( parent . modCount != expectedModCount ) { MST[rv.UOI3Mutator]MSP[N] throw new ConcurrentModificationException () ; } if ( next == parent . header ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } last = next ; next = next . after ; return last ; }
if ( parent . modCount != expectedModCount ) { MST[rv.UOI2Mutator]MSP[N] throw new ConcurrentModificationException () ; } if ( next == parent . header ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } last = next ; next = next . after ; return last ; }
return super . previousEntry () . getValue () ; } public boolean hasNext () { return next != parent . header ; MST[InlineConstantMutator]MSP[N] } public boolean hasPrevious () { return next . before != parent . header ; } protected LinkEntry < K , V > nextEntry () {
if ( parent . modCount != expectedModCount ) { MST[NegateConditionalsMutator]MSP[N] throw new ConcurrentModificationException () ; } if ( next == parent . header ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } last = next ; next = next . after ; return last ; }
if ( parent . modCount != expectedModCount ) { throw new ConcurrentModificationException () ; } if ( next == parent . header ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } last = next ; MST[experimental.MemberVariableMutator]MSP[N] next = next . after ; return last ; }
return super . previousEntry () . getValue () ; } public boolean hasNext () { return next != parent . header ; MST[rv.ROR5Mutator]MSP[N] } public boolean hasPrevious () { return next . before != parent . header ; } protected LinkEntry < K , V > nextEntry () {
throw new IllegalStateException ( AbstractHashedMap . REMOVE_INVALID ) ; } if ( parent . modCount != expectedModCount ) { throw new ConcurrentModificationException () ; } parent . remove ( last . getKey () ) ; last = null ; MST[experimental.MemberVariableMutator]MSP[S] expectedModCount = parent . modCount ; }
throw new IllegalStateException ( AbstractHashedMap . REMOVE_INVALID ) ; } if ( parent . modCount != expectedModCount ) { throw new ConcurrentModificationException () ; } parent . remove ( last . getKey () ) ; MST[NonVoidMethodCallMutator]MSP[N] last = null ; expectedModCount = parent . modCount ; }
throw new IllegalStateException ( AbstractHashedMap . REMOVE_INVALID ) ; MST[ConstructorCallMutator]MSP[S] } if ( parent . modCount != expectedModCount ) { throw new ConcurrentModificationException () ; } parent . remove ( last . getKey () ) ; last = null ; expectedModCount = parent . modCount ; }
throw new NoSuchElementException ( AbstractHashedMap . NO_PREVIOUS_ENTRY ) ; } next = previous ; last = previous ; return last ; } protected LinkEntry < K , V > currentEntry () { return last ; } public void remove () { if ( last == null ) { MST[NegateConditionalsMutator]MSP[N]
if ( parent . modCount != expectedModCount ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] throw new ConcurrentModificationException () ; } if ( next == parent . header ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } last = next ; next = next . after ; return last ; }
return super . previousEntry () . getValue () ; } public boolean hasNext () { return next != parent . header ; MST[ReturnValsMutator]MSP[N] } public boolean hasPrevious () { return next . before != parent . header ; } protected LinkEntry < K , V > nextEntry () {
throw new IllegalStateException ( AbstractHashedMap . REMOVE_INVALID ) ; } if ( parent . modCount != expectedModCount ) { MST[rv.UOI1Mutator]MSP[N] throw new ConcurrentModificationException () ; } parent . remove ( last . getKey () ) ; last = null ; expectedModCount = parent . modCount ; }
throw new IllegalStateException ( AbstractHashedMap . REMOVE_INVALID ) ; } if ( parent . modCount != expectedModCount ) { MST[rv.ABSMutator]MSP[N] throw new ConcurrentModificationException () ; } parent . remove ( last . getKey () ) ; last = null ; expectedModCount = parent . modCount ; }
throw new IllegalStateException ( AbstractHashedMap . REMOVE_INVALID ) ; } if ( parent . modCount != expectedModCount ) { MST[NegateConditionalsMutator]MSP[N] throw new ConcurrentModificationException () ; } parent . remove ( last . getKey () ) ; last = null ; expectedModCount = parent . modCount ; }
throw new IllegalStateException ( AbstractHashedMap . REMOVE_INVALID ) ; } if ( parent . modCount != expectedModCount ) { MST[rv.UOI3Mutator]MSP[N] throw new ConcurrentModificationException () ; } parent . remove ( last . getKey () ) ; last = null ; expectedModCount = parent . modCount ; }
if ( parent . modCount != expectedModCount ) { MST[rv.UOI4Mutator]MSP[N] throw new ConcurrentModificationException () ; } if ( next == parent . header ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } last = next ; next = next . after ; return last ; }
return super . previousEntry () . getValue () ; } public boolean hasNext () { return next != parent . header ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } public boolean hasPrevious () { return next . before != parent . header ; } protected LinkEntry < K , V > nextEntry () {
throw new IllegalStateException ( AbstractHashedMap . REMOVE_INVALID ) ; } if ( parent . modCount != expectedModCount ) { throw new ConcurrentModificationException () ; } parent . remove ( last . getKey () ) ; last = null ; expectedModCount = parent . modCount ; MST[rv.UOI4Mutator]MSP[N] }
if ( parent . modCount != expectedModCount ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] throw new ConcurrentModificationException () ; } if ( next == parent . header ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } last = next ; next = next . after ; return last ; }
return super . previousEntry () . getValue () ; } public boolean hasNext () { return next != parent . header ; MST[NegateConditionalsMutator]MSP[N] } public boolean hasPrevious () { return next . before != parent . header ; } protected LinkEntry < K , V > nextEntry () {
throw new IllegalStateException ( AbstractHashedMap . REMOVE_INVALID ) ; } if ( parent . modCount != expectedModCount ) { throw new ConcurrentModificationException () ; } parent . remove ( last . getKey () ) ; MST[ArgumentPropagationMutator]MSP[N] last = null ; expectedModCount = parent . modCount ; }
throw new IllegalStateException ( AbstractHashedMap . REMOVE_INVALID ) ; } if ( parent . modCount != expectedModCount ) { throw new ConcurrentModificationException () ; } parent . remove ( last . getKey () ) ; MST[NonVoidMethodCallMutator]MSP[N] last = null ; expectedModCount = parent . modCount ; }
throw new IllegalStateException ( AbstractHashedMap . REMOVE_INVALID ) ; } if ( parent . modCount != expectedModCount ) { throw new ConcurrentModificationException () ; } parent . remove ( last . getKey () ) ; last = null ; expectedModCount = parent . modCount ; MST[rv.UOI1Mutator]MSP[N] }
return super . previousEntry () . getValue () ; } public boolean hasNext () { return next != parent . header ; MST[rv.CRCR5Mutator]MSP[N] } public boolean hasPrevious () { return next . before != parent . header ; } protected LinkEntry < K , V > nextEntry () {
if ( parent . modCount != expectedModCount ) { throw new ConcurrentModificationException () ; } if ( next == parent . header ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; MST[ConstructorCallMutator]MSP[S] } last = next ; next = next . after ; return last ; }
throw new NoSuchElementException ( AbstractHashedMap . NO_PREVIOUS_ENTRY ) ; } next = previous ; last = previous ; return last ; } protected LinkEntry < K , V > currentEntry () { return last ; } public void remove () { if ( last == null ) { MST[rv.ROR5Mutator]MSP[N]
return super . previousEntry () . getValue () ; } public boolean hasNext () { return next != parent . header ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } public boolean hasPrevious () { return next . before != parent . header ; } protected LinkEntry < K , V > nextEntry () {
if ( parent . modCount != expectedModCount ) { MST[rv.ABSMutator]MSP[N] throw new ConcurrentModificationException () ; } if ( next == parent . header ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } last = next ; next = next . after ; return last ; }
throw new IllegalStateException ( AbstractHashedMap . REMOVE_INVALID ) ; } if ( parent . modCount != expectedModCount ) { MST[rv.UOI4Mutator]MSP[N] throw new ConcurrentModificationException () ; } parent . remove ( last . getKey () ) ; last = null ; expectedModCount = parent . modCount ; }
throw new IllegalStateException ( AbstractHashedMap . REMOVE_INVALID ) ; } if ( parent . modCount != expectedModCount ) { MST[rv.UOI2Mutator]MSP[N] throw new ConcurrentModificationException () ; } parent . remove ( last . getKey () ) ; last = null ; expectedModCount = parent . modCount ; }
throw new IllegalStateException ( AbstractHashedMap . REMOVE_INVALID ) ; } if ( parent . modCount != expectedModCount ) { MST[rv.ROR1Mutator]MSP[N] throw new ConcurrentModificationException () ; } parent . remove ( last . getKey () ) ; last = null ; expectedModCount = parent . modCount ; }
return super . previousEntry () . getValue () ; } public boolean hasNext () { return next != parent . header ; MST[rv.CRCR5Mutator]MSP[N] } public boolean hasPrevious () { return next . before != parent . header ; } protected LinkEntry < K , V > nextEntry () {
if ( parent . modCount != expectedModCount ) { MST[rv.UOI1Mutator]MSP[N] throw new ConcurrentModificationException () ; } if ( next == parent . header ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } last = next ; next = next . after ; return last ; }
return super . previousEntry () . getValue () ; } public boolean hasNext () { return next != parent . header ; MST[rv.CRCR1Mutator]MSP[N] } public boolean hasPrevious () { return next . before != parent . header ; } protected LinkEntry < K , V > nextEntry () {
if ( parent . modCount != expectedModCount ) { MST[rv.ROR2Mutator]MSP[S] throw new ConcurrentModificationException () ; } if ( next == parent . header ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } last = next ; next = next . after ; return last ; }
if ( parent . modCount != expectedModCount ) { throw new ConcurrentModificationException () ; } if ( next == parent . header ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } last = next ; next = next . after ; return last ; }
throw new IllegalStateException ( AbstractHashedMap . REMOVE_INVALID ) ; } if ( parent . modCount != expectedModCount ) { MST[rv.ROR5Mutator]MSP[N] throw new ConcurrentModificationException () ; } parent . remove ( last . getKey () ) ; last = null ; expectedModCount = parent . modCount ; }
if ( parent . modCount != expectedModCount ) { throw new ConcurrentModificationException () ; } if ( next == parent . header ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } last = next ; next = next . after ; return last ; MST[NullReturnValsMutator]MSP[N] }
throw new IllegalStateException ( AbstractHashedMap . REMOVE_INVALID ) ; } if ( parent . modCount != expectedModCount ) { throw new ConcurrentModificationException () ; } parent . remove ( last . getKey () ) ; last = null ; expectedModCount = parent . modCount ; MST[rv.ABSMutator]MSP[N] }
return super . previousEntry () . getValue () ; } public boolean hasNext () { return next != parent . header ; MST[rv.CRCR4Mutator]MSP[S] } public boolean hasPrevious () { return next . before != parent . header ; } protected LinkEntry < K , V > nextEntry () {
return super . previousEntry () . getValue () ; } public boolean hasNext () { return next != parent . header ; MST[rv.CRCR6Mutator]MSP[N] } public boolean hasPrevious () { return next . before != parent . header ; } protected LinkEntry < K , V > nextEntry () {
throw new IllegalStateException ( AbstractHashedMap . REMOVE_INVALID ) ; } if ( parent . modCount != expectedModCount ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] throw new ConcurrentModificationException () ; } parent . remove ( last . getKey () ) ; last = null ; expectedModCount = parent . modCount ; }
throw new NoSuchElementException ( AbstractHashedMap . NO_PREVIOUS_ENTRY ) ; } next = previous ; last = previous ; return last ; } protected LinkEntry < K , V > currentEntry () { return last ; MST[NullReturnValsMutator]MSP[S] } public void remove () { if ( last == null ) {
throw new IllegalStateException ( AbstractHashedMap . REMOVE_INVALID ) ; } if ( parent . modCount != expectedModCount ) { throw new ConcurrentModificationException () ; } parent . remove ( last . getKey () ) ; last = null ; expectedModCount = parent . modCount ; MST[experimental.MemberVariableMutator]MSP[N] }
throw new IllegalStateException ( AbstractHashedMap . REMOVE_INVALID ) ; } if ( parent . modCount != expectedModCount ) { MST[rv.UOI1Mutator]MSP[N] throw new ConcurrentModificationException () ; } parent . remove ( last . getKey () ) ; last = null ; expectedModCount = parent . modCount ; }
if ( parent . modCount != expectedModCount ) { throw new ConcurrentModificationException () ; } if ( next == parent . header ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } last = next ; next = next . after ; return last ; }
if ( parent . modCount != expectedModCount ) { throw new ConcurrentModificationException () ; } if ( next == parent . header ) { MST[NegateConditionalsMutator]MSP[N] throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } last = next ; next = next . after ; return last ; }
throw new IllegalStateException ( AbstractHashedMap . REMOVE_INVALID ) ; } if ( parent . modCount != expectedModCount ) { MST[rv.ABSMutator]MSP[N] throw new ConcurrentModificationException () ; } parent . remove ( last . getKey () ) ; last = null ; expectedModCount = parent . modCount ; }
return super . previousEntry () . getValue () ; } public boolean hasNext () { return next != parent . header ; MST[rv.CRCR2Mutator]MSP[N] } public boolean hasPrevious () { return next . before != parent . header ; } protected LinkEntry < K , V > nextEntry () {
return super . previousEntry () . getValue () ; } public boolean hasNext () { return next != parent . header ; MST[rv.CRCR6Mutator]MSP[N] } public boolean hasPrevious () { return next . before != parent . header ; } protected LinkEntry < K , V > nextEntry () {
throw new IllegalStateException ( AbstractHashedMap . REMOVE_INVALID ) ; } if ( parent . modCount != expectedModCount ) { MST[rv.UOI3Mutator]MSP[N] throw new ConcurrentModificationException () ; } parent . remove ( last . getKey () ) ; last = null ; expectedModCount = parent . modCount ; }
if ( parent . modCount != expectedModCount ) { MST[rv.ROR5Mutator]MSP[N] throw new ConcurrentModificationException () ; } if ( next == parent . header ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } last = next ; next = next . after ; return last ; }
if ( parent . modCount != expectedModCount ) { MST[rv.ROR3Mutator]MSP[N] throw new ConcurrentModificationException () ; } if ( next == parent . header ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } last = next ; next = next . after ; return last ; }
throw new IllegalStateException ( AbstractHashedMap . REMOVE_INVALID ) ; } if ( parent . modCount != expectedModCount ) { MST[rv.ROR4Mutator]MSP[N] throw new ConcurrentModificationException () ; } parent . remove ( last . getKey () ) ; last = null ; expectedModCount = parent . modCount ; }
throw new IllegalStateException ( AbstractHashedMap . REMOVE_INVALID ) ; } if ( parent . modCount != expectedModCount ) { MST[rv.ROR2Mutator]MSP[N] throw new ConcurrentModificationException () ; } parent . remove ( last . getKey () ) ; last = null ; expectedModCount = parent . modCount ; }
if ( parent . modCount != expectedModCount ) { MST[rv.ROR1Mutator]MSP[N] throw new ConcurrentModificationException () ; } if ( next == parent . header ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } last = next ; next = next . after ; return last ; }
if ( parent . modCount != expectedModCount ) { MST[rv.UOI2Mutator]MSP[N] throw new ConcurrentModificationException () ; } if ( next == parent . header ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } last = next ; next = next . after ; return last ; }
if ( parent . modCount != expectedModCount ) { MST[rv.UOI4Mutator]MSP[N] throw new ConcurrentModificationException () ; } if ( next == parent . header ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } last = next ; next = next . after ; return last ; }
throw new NoSuchElementException ( AbstractHashedMap . NO_PREVIOUS_ENTRY ) ; } next = previous ; last = previous ; return last ; } protected LinkEntry < K , V > currentEntry () { return last ; MST[ReturnValsMutator]MSP[S] } public void remove () { if ( last == null ) {
if ( parent . modCount != expectedModCount ) { throw new ConcurrentModificationException () ; } if ( next == parent . header ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } last = next ; next = next . after ; return last ; MST[ReturnValsMutator]MSP[N] }
throw new NoSuchElementException ( AbstractHashedMap . NO_PREVIOUS_ENTRY ) ; } next = previous ; last = previous ; return last ; } protected LinkEntry < K , V > currentEntry () { return last ; } public void remove () { if ( last == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
throw new IllegalStateException ( AbstractHashedMap . REMOVE_INVALID ) ; } if ( parent . modCount != expectedModCount ) { throw new ConcurrentModificationException () ; } parent . remove ( last . getKey () ) ; last = null ; expectedModCount = parent . modCount ; MST[rv.UOI2Mutator]MSP[N] }
throw new IllegalStateException ( AbstractHashedMap . REMOVE_INVALID ) ; } if ( parent . modCount != expectedModCount ) { throw new ConcurrentModificationException () ; } parent . remove ( last . getKey () ) ; last = null ; expectedModCount = parent . modCount ; MST[rv.UOI3Mutator]MSP[N] }
throw new NoSuchElementException ( AbstractHashedMap . NO_PREVIOUS_ENTRY ) ; } next = previous ; last = previous ; return last ; } protected LinkEntry < K , V > currentEntry () { return last ; } public void remove () { if ( last == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S]
return super . previousEntry () . getValue () ; } public boolean hasNext () { return next != parent . header ; MST[rv.CRCR3Mutator]MSP[S] } public boolean hasPrevious () { return next . before != parent . header ; } protected LinkEntry < K , V > nextEntry () {
return super . previousEntry () . getValue () ; } public boolean hasNext () { return next != parent . header ; MST[BooleanTrueReturnValsMutator]MSP[N] } public boolean hasPrevious () { return next . before != parent . header ; } protected LinkEntry < K , V > nextEntry () {
if ( parent . modCount != expectedModCount ) { throw new ConcurrentModificationException () ; } if ( next == parent . header ) { MST[rv.ROR5Mutator]MSP[N] throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } last = next ; next = next . after ; return last ; }
throw new IllegalStateException ( AbstractHashedMap . REMOVE_INVALID ) ; } if ( parent . modCount != expectedModCount ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] throw new ConcurrentModificationException () ; } parent . remove ( last . getKey () ) ; last = null ; expectedModCount = parent . modCount ; }
if ( parent . modCount != expectedModCount ) { MST[rv.ABSMutator]MSP[N] throw new ConcurrentModificationException () ; } if ( next == parent . header ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } last = next ; next = next . after ; return last ; }
return super . previousEntry () . getValue () ; } public boolean hasNext () { return next != parent . header ; MST[InlineConstantMutator]MSP[N] } public boolean hasPrevious () { return next . before != parent . header ; } protected LinkEntry < K , V > nextEntry () {
throw new IllegalStateException ( AbstractHashedMap . REMOVE_INVALID ) ; } if ( parent . modCount != expectedModCount ) { MST[rv.ROR3Mutator]MSP[N] throw new ConcurrentModificationException () ; } parent . remove ( last . getKey () ) ; last = null ; expectedModCount = parent . modCount ; }
throw new IllegalStateException ( AbstractHashedMap . REMOVE_INVALID ) ; } if ( parent . modCount != expectedModCount ) { MST[rv.UOI4Mutator]MSP[N] throw new ConcurrentModificationException () ; } parent . remove ( last . getKey () ) ; last = null ; expectedModCount = parent . modCount ; }
if ( parent . modCount != expectedModCount ) { MST[rv.ROR4Mutator]MSP[S] throw new ConcurrentModificationException () ; } if ( next == parent . header ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } last = next ; next = next . after ; return last ; }
if ( parent . modCount != expectedModCount ) { MST[rv.UOI1Mutator]MSP[N] throw new ConcurrentModificationException () ; } if ( next == parent . header ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } last = next ; next = next . after ; return last ; }
throw new IllegalStateException ( AbstractHashedMap . REMOVE_INVALID ) ; } if ( parent . modCount != expectedModCount ) { MST[rv.UOI2Mutator]MSP[N] throw new ConcurrentModificationException () ; } parent . remove ( last . getKey () ) ; last = null ; expectedModCount = parent . modCount ; }
return super . previousEntry () . getValue () ; } public boolean hasNext () { return next != parent . header ; MST[rv.CRCR3Mutator]MSP[N] } public boolean hasPrevious () { return next . before != parent . header ; } protected LinkEntry < K , V > nextEntry () {
if ( parent . modCount != expectedModCount ) { MST[rv.UOI3Mutator]MSP[N] throw new ConcurrentModificationException () ; } if ( next == parent . header ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } last = next ; next = next . after ; return last ; }
if ( current == null ) { throw new IllegalStateException ( AbstractHashedMap . GETKEY_INVALID ) ; } return current . getKey () ; } @Override public V getValue () { final LinkEntry < K , V > current = currentEntry () ; if ( current == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
return super . nextEntry () . getKey () ; MST[NullReturnValsMutator]MSP[S] } @Override public K previous () { return super . previousEntry () . getKey () ; } @Override public K getKey () { final LinkEntry < K , V > current = currentEntry () ;
throw new IllegalStateException ( AbstractHashedMap . GETVALUE_INVALID ) ; } return current . getValue () ; MST[NullReturnValsMutator]MSP[N] } @Override public V setValue ( final V value ) { final LinkEntry < K , V > current = currentEntry () ; if ( current == null ) {
throw new IllegalStateException ( AbstractHashedMap . GETVALUE_INVALID ) ; } return current . getValue () ; MST[ReturnValsMutator]MSP[S] } @Override public V setValue ( final V value ) { final LinkEntry < K , V > current = currentEntry () ; if ( current == null ) {
return super . nextEntry () . getKey () ; MST[NonVoidMethodCallMutator]MSP[S] } @Override public K previous () { return super . previousEntry () . getKey () ; } @Override public K getKey () { final LinkEntry < K , V > current = currentEntry () ;
return super . nextEntry () . getKey () ; MST[NonVoidMethodCallMutator]MSP[S] } @Override public K previous () { return super . previousEntry () . getKey () ; } @Override public K getKey () { final LinkEntry < K , V > current = currentEntry () ;
if ( current == null ) { throw new IllegalStateException ( AbstractHashedMap . GETKEY_INVALID ) ; } return current . getKey () ; } @Override public V getValue () { final LinkEntry < K , V > current = currentEntry () ; if ( current == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S]
if ( current == null ) { throw new IllegalStateException ( AbstractHashedMap . GETKEY_INVALID ) ; } return current . getKey () ; } @Override public V getValue () { final LinkEntry < K , V > current = currentEntry () ; if ( current == null ) { MST[NegateConditionalsMutator]MSP[S]
if ( current == null ) { throw new IllegalStateException ( AbstractHashedMap . GETKEY_INVALID ) ; } return current . getKey () ; } @Override public V getValue () { final LinkEntry < K , V > current = currentEntry () ; MST[NonVoidMethodCallMutator]MSP[S] if ( current == null ) {
if ( current == null ) { throw new IllegalStateException ( AbstractHashedMap . GETKEY_INVALID ) ; } return current . getKey () ; } @Override public V getValue () { final LinkEntry < K , V > current = currentEntry () ; if ( current == null ) { MST[rv.ROR5Mutator]MSP[S]
return super . nextEntry () . getKey () ; MST[ReturnValsMutator]MSP[S] } @Override public K previous () { return super . previousEntry () . getKey () ; } @Override public K getKey () { final LinkEntry < K , V > current = currentEntry () ;
throw new IllegalStateException ( AbstractHashedMap . GETVALUE_INVALID ) ; } return current . getValue () ; MST[NonVoidMethodCallMutator]MSP[N] } @Override public V setValue ( final V value ) { final LinkEntry < K , V > current = currentEntry () ; if ( current == null ) {
return EmptyOrderedIterator . < Map . Entry < K , V > > emptyOrderedIterator () ; } return new EntrySetIterator <> ( this ) ; } @Override public Map . Entry < K , V > next () { return super . nextEntry () ; MST[NullReturnValsMutator]MSP[N] } @Override
return EmptyOrderedIterator . < Map . Entry < K , V > > emptyOrderedIterator () ; } return new EntrySetIterator <> ( this ) ; } @Override public Map . Entry < K , V > next () { return super . nextEntry () ; MST[ReturnValsMutator]MSP[N] } @Override
return EmptyOrderedIterator . < Map . Entry < K , V > > emptyOrderedIterator () ; } return new EntrySetIterator <> ( this ) ; } @Override public Map . Entry < K , V > next () { return super . nextEntry () ; MST[NonVoidMethodCallMutator]MSP[N] } @Override
return new KeySetIterator <> ( this ) ; } @Override public K next () { return super . nextEntry () . getKey () ; MST[ReturnValsMutator]MSP[N] } @Override public K previous () { return super . previousEntry () . getKey () ; } @Override protected Iterator < V > createValuesIterator () {
return new KeySetIterator <> ( this ) ; } @Override public K next () { return super . nextEntry () . getKey () ; MST[NonVoidMethodCallMutator]MSP[N] } @Override public K previous () { return super . previousEntry () . getKey () ; } @Override protected Iterator < V > createValuesIterator () {
return new KeySetIterator <> ( this ) ; } @Override public K next () { return super . nextEntry () . getKey () ; MST[NonVoidMethodCallMutator]MSP[N] } @Override public K previous () { return super . previousEntry () . getKey () ; } @Override protected Iterator < V > createValuesIterator () {
return new KeySetIterator <> ( this ) ; } @Override public K next () { return super . nextEntry () . getKey () ; MST[NullReturnValsMutator]MSP[N] } @Override public K previous () { return super . previousEntry () . getKey () ; } @Override protected Iterator < V > createValuesIterator () {
throw new IndexOutOfBoundsException ( lr_2 + index + lr_3 ) ; } if ( index >= size ) { throw new IndexOutOfBoundsException ( lr_2 + index + lr_4 + size ) ; } LinkEntry < K , V > entry ; if ( index < size / 2 ) { MST[rv.UOI2Mutator]MSP[N]
public Map . Entry < K , V > previous () { return super . previousEntry () ; } @Override protected Iterator < K > createKeySetIterator () { if ( size () == 0 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return EmptyOrderedIterator . <K > emptyOrderedIterator () ; }
throw new IndexOutOfBoundsException ( lr_2 + index + lr_3 ) ; } if ( index >= size ) { throw new IndexOutOfBoundsException ( lr_2 + index + lr_4 + size ) ; } LinkEntry < K , V > entry ; if ( index < size / 2 ) { MST[InlineConstantMutator]MSP[S]
public Map . Entry < K , V > previous () { return super . previousEntry () ; } @Override protected Iterator < K > createKeySetIterator () { if ( size () == 0 ) { MST[rv.ROR5Mutator]MSP[N] return EmptyOrderedIterator . <K > emptyOrderedIterator () ; }
@Override public OrderedMapIterator < K , V > mapIterator () { if ( size == 0 ) { return EmptyOrderedMapIterator . <K , V > emptyOrderedMapIterator () ; } return new LinkMapIterator <> ( this ) ; MST[ReturnValsMutator]MSP[S] } @Override public K next () {
throw new IndexOutOfBoundsException ( lr_2 + index + lr_3 ) ; } if ( index >= size ) { throw new IndexOutOfBoundsException ( lr_2 + index + lr_4 + size ) ; } LinkEntry < K , V > entry ; if ( index < size / 2 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[S]
public Map . Entry < K , V > previous () { return super . previousEntry () ; } @Override protected Iterator < K > createKeySetIterator () { if ( size () == 0 ) { MST[rv.ROR1Mutator]MSP[N] return EmptyOrderedIterator . <K > emptyOrderedIterator () ; }
return ( LinkEntry < K , V > ) super . getEntry ( key ) ; MST[NullReturnValsMutator]MSP[S] } @Override public K previousKey ( final Object key ) { final LinkEntry < K , V > entry = getEntry ( key ) ;
return entry == null || entry . before == header ? null : entry . before . getKey () ; } protected LinkEntry < K , V > getEntry ( final int index ) { if ( index < 0 ) { MST[rv.UOI2Mutator]MSP[N]
throw new IndexOutOfBoundsException ( lr_2 + index + lr_3 ) ; } if ( index >= size ) { throw new IndexOutOfBoundsException ( lr_2 + index + lr_4 + size ) ; MST[experimental.NakedReceiverMutator]MSP[S] } LinkEntry < K , V > entry ; if ( index < size / 2 ) {
@Override public OrderedMapIterator < K , V > mapIterator () { if ( size == 0 ) { MST[rv.ABSMutator]MSP[N] return EmptyOrderedMapIterator . <K , V > emptyOrderedMapIterator () ; } return new LinkMapIterator <> ( this ) ; } @Override public K next () {
link . before . after = link . after ; link . after . before = link . before ; link . after = null ; link . before = null ; super . removeEntry ( entry , hashIndex , previous ) ; MST[rv.UOI4Mutator]MSP[N] }
public void clear () { super . clear () ; header . before = header . after = header ; MST[experimental.MemberVariableMutator]MSP[N] } @Override public K firstKey () { if ( size == 0 ) { throw new NoSuchElementException ( lr_1 ) ; } return header . after . getKey () ;
throw new IndexOutOfBoundsException ( lr_2 + index + lr_3 ) ; } if ( index >= size ) { MST[rv.ROR1Mutator]MSP[N] throw new IndexOutOfBoundsException ( lr_2 + index + lr_4 + size ) ; } LinkEntry < K , V > entry ; if ( index < size / 2 ) {
link . after = header ; link . before = header . before ; header . before . after = link ; header . before = link ; MST[experimental.MemberVariableMutator]MSP[N] data [ hashIndex ] = link ; } @Override
throw new IndexOutOfBoundsException ( lr_2 + index + lr_3 ) ; } if ( index >= size ) { MST[rv.ROR5Mutator]MSP[N] throw new IndexOutOfBoundsException ( lr_2 + index + lr_4 + size ) ; } LinkEntry < K , V > entry ; if ( index < size / 2 ) {
public Map . Entry < K , V > previous () { return super . previousEntry () ; } @Override protected Iterator < K > createKeySetIterator () { if ( size () == 0 ) { MST[NegateConditionalsMutator]MSP[N] return EmptyOrderedIterator . <K > emptyOrderedIterator () ; }
throw new IndexOutOfBoundsException ( lr_2 + index + lr_3 ) ; } if ( index >= size ) { throw new IndexOutOfBoundsException ( lr_2 + index + lr_4 + size ) ; } LinkEntry < K , V > entry ; if ( index < size / 2 ) { MST[rv.ROR4Mutator]MSP[S]
throw new IndexOutOfBoundsException ( lr_2 + index + lr_3 ) ; } if ( index >= size ) { throw new IndexOutOfBoundsException ( lr_2 + index + lr_4 + size ) ; MST[NonVoidMethodCallMutator]MSP[N] } LinkEntry < K , V > entry ; if ( index < size / 2 ) {
throw new IndexOutOfBoundsException ( lr_2 + index + lr_3 ) ; } if ( index >= size ) { throw new IndexOutOfBoundsException ( lr_2 + index + lr_4 + size ) ; } LinkEntry < K , V > entry ; if ( index < size / 2 ) { MST[rv.ABSMutator]MSP[S]
public Map . Entry < K , V > previous () { return super . previousEntry () ; } @Override protected Iterator < K > createKeySetIterator () { if ( size () == 0 ) { return EmptyOrderedIterator . <K > emptyOrderedIterator () ; MST[ReturnValsMutator]MSP[N] }
return entry == null || entry . before == header ? null : entry . before . getKey () ; } protected LinkEntry < K , V > getEntry ( final int index ) { if ( index < 0 ) { MST[rv.ROR3Mutator]MSP[N]
return new KeySetIterator <> ( this ) ; MST[ConstructorCallMutator]MSP[N] } @Override public K next () { return super . nextEntry () . getKey () ; } @Override public K previous () { return super . previousEntry () . getKey () ; } @Override protected Iterator < V > createValuesIterator () {
return entry == null || entry . before == header ? null : entry . before . getKey () ; } protected LinkEntry < K , V > getEntry ( final int index ) { if ( index < 0 ) { MST[rv.ABSMutator]MSP[S]
throw new IndexOutOfBoundsException ( lr_2 + index + lr_3 ) ; } if ( index >= size ) { MST[NegateConditionalsMutator]MSP[N] throw new IndexOutOfBoundsException ( lr_2 + index + lr_4 + size ) ; } LinkEntry < K , V > entry ; if ( index < size / 2 ) {
entry = entry . before ; } } return entry ; MST[ReturnValsMutator]MSP[N] } @Override protected void addEntry ( final HashEntry < K , V > entry , final int hashIndex ) { final LinkEntry < K , V > link = ( LinkEntry < K , V > ) entry ;
throw new IndexOutOfBoundsException ( lr_2 + index + lr_3 ) ; } if ( index >= size ) { throw new IndexOutOfBoundsException ( lr_2 + index + lr_4 + size ) ; } LinkEntry < K , V > entry ; if ( index < size / 2 ) { MST[ConditionalsBoundaryMutator]MSP[S]
entry = header . after ; for ( int currentIndex = 0 ; currentIndex < index ; currentIndex ++ ) { entry = entry . after ; } } else { entry = header ; for ( int currentIndex = size ; currentIndex > index ; currentIndex -- ) { MST[rv.ROR2Mutator]MSP[N]
entry = header . after ; for ( int currentIndex = 0 ; currentIndex < index ; currentIndex ++ ) { entry = entry . after ; } } else { entry = header ; for ( int currentIndex = size ; currentIndex > index ; currentIndex -- ) { MST[rv.UOI1Mutator]MSP[S]
public void clear () { super . clear () ; MST[VoidMethodCallMutator]MSP[N] header . before = header . after = header ; } @Override public K firstKey () { if ( size == 0 ) { throw new NoSuchElementException ( lr_1 ) ; } return header . after . getKey () ;
protected LinkEntry < K , V > createEntry ( final HashEntry < K , V > next , final int hashCode , final K key , final V value ) { return new LinkEntry <> ( next , hashCode , convertKey ( key ) , value ) ; MST[ArgumentPropagationMutator]MSP[N] } @Override
throw new IndexOutOfBoundsException ( lr_2 + index + lr_3 ) ; } if ( index >= size ) { throw new IndexOutOfBoundsException ( lr_2 + index + lr_4 + size ) ; } LinkEntry < K , V > entry ; if ( index < size / 2 ) { MST[rv.UOI2Mutator]MSP[N]
throw new IllegalStateException ( AbstractHashedMap . SETVALUE_INVALID ) ; } return current . setValue ( value ) ; } @Override protected Iterator < Map . Entry < K , V > > createEntrySetIterator () { if ( size () == 0 ) { MST[rv.ROR2Mutator]MSP[N]
throw new IllegalStateException ( AbstractHashedMap . SETVALUE_INVALID ) ; } return current . setValue ( value ) ; } @Override protected Iterator < Map . Entry < K , V > > createEntrySetIterator () { if ( size () == 0 ) { MST[rv.ROR1Mutator]MSP[N]
link . before . after = link . after ; link . after . before = link . before ; link . after = null ; MST[experimental.MemberVariableMutator]MSP[N] link . before = null ; super . removeEntry ( entry , hashIndex , previous ) ; }
throw new IndexOutOfBoundsException ( lr_2 + index + lr_3 ) ; } if ( index >= size ) { throw new IndexOutOfBoundsException ( lr_2 + index + lr_4 + size ) ; MST[experimental.NakedReceiverMutator]MSP[S] } LinkEntry < K , V > entry ; if ( index < size / 2 ) {
throw new IndexOutOfBoundsException ( lr_2 + index + lr_3 ) ; } if ( index >= size ) { throw new IndexOutOfBoundsException ( lr_2 + index + lr_4 + size ) ; MST[rv.UOI3Mutator]MSP[S] } LinkEntry < K , V > entry ; if ( index < size / 2 ) {
throw new IndexOutOfBoundsException ( lr_2 + index + lr_3 ) ; } if ( index >= size ) { throw new IndexOutOfBoundsException ( lr_2 + index + lr_4 + size ) ; MST[rv.ABSMutator]MSP[S] } LinkEntry < K , V > entry ; if ( index < size / 2 ) {
@Override protected void init () { header = createEntry ( null , - 1 , null , null ) ; MST[rv.CRCR1Mutator]MSP[S] header . before = header . after = header ; } @Override public boolean containsValue ( final Object value ) { if ( value == null ) {
throw new IndexOutOfBoundsException ( lr_2 + index + lr_3 ) ; } if ( index >= size ) { throw new IndexOutOfBoundsException ( lr_2 + index + lr_4 + size ) ; } LinkEntry < K , V > entry ; if ( index < size / 2 ) { MST[rv.CRCR2Mutator]MSP[N]
return entry == null || entry . before == header ? null : entry . before . getKey () ; } protected LinkEntry < K , V > getEntry ( final int index ) { if ( index < 0 ) { MST[ConditionalsBoundaryMutator]MSP[N]
return EmptyOrderedIterator . < Map . Entry < K , V > > emptyOrderedIterator () ; } return new EntrySetIterator <> ( this ) ; MST[ConstructorCallMutator]MSP[N] } @Override public Map . Entry < K , V > next () { return super . nextEntry () ; } @Override
throw new IndexOutOfBoundsException ( lr_2 + index + lr_3 ) ; } if ( index >= size ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] throw new IndexOutOfBoundsException ( lr_2 + index + lr_4 + size ) ; } LinkEntry < K , V > entry ; if ( index < size / 2 ) {
throw new IndexOutOfBoundsException ( lr_2 + index + lr_3 ) ; } if ( index >= size ) { throw new IndexOutOfBoundsException ( lr_2 + index + lr_4 + size ) ; } LinkEntry < K , V > entry ; if ( index < size / 2 ) { MST[rv.ROR3Mutator]MSP[S]
throw new IllegalStateException ( AbstractHashedMap . SETVALUE_INVALID ) ; } return current . setValue ( value ) ; } @Override protected Iterator < Map . Entry < K , V > > createEntrySetIterator () { if ( size () == 0 ) { MST[NegateConditionalsMutator]MSP[N]
link . before . after = link . after ; link . after . before = link . before ; link . after = null ; link . before = null ; super . removeEntry ( entry , hashIndex , previous ) ; MST[rv.UOI3Mutator]MSP[N] }
@Override public OrderedMapIterator < K , V > mapIterator () { if ( size == 0 ) { MST[rv.UOI2Mutator]MSP[S] return EmptyOrderedMapIterator . <K , V > emptyOrderedMapIterator () ; } return new LinkMapIterator <> ( this ) ; } @Override public K next () {
throw new IndexOutOfBoundsException ( lr_2 + index + lr_3 ) ; } if ( index >= size ) { throw new IndexOutOfBoundsException ( lr_2 + index + lr_4 + size ) ; } LinkEntry < K , V > entry ; if ( index < size / 2 ) { MST[rv.AOR3Mutator]MSP[S]
protected LinkEntry < K , V > createEntry ( final HashEntry < K , V > next , final int hashCode , final K key , final V value ) { return new LinkEntry <> ( next , hashCode , convertKey ( key ) , value ) ; MST[ReturnValsMutator]MSP[N] } @Override
@Override protected void init () { header = createEntry ( null , - 1 , null , null ) ; MST[rv.CRCR4Mutator]MSP[S] header . before = header . after = header ; } @Override public boolean containsValue ( final Object value ) { if ( value == null ) {
entry = header . after ; for ( int currentIndex = 0 ; currentIndex < index ; currentIndex ++ ) { entry = entry . after ; } } else { entry = header ; for ( int currentIndex = size ; currentIndex > index ; currentIndex -- ) { MST[rv.UOI4Mutator]MSP[N]
throw new IndexOutOfBoundsException ( lr_2 + index + lr_3 ) ; } if ( index >= size ) { throw new IndexOutOfBoundsException ( lr_2 + index + lr_4 + size ) ; } LinkEntry < K , V > entry ; if ( index < size / 2 ) { MST[rv.UOI3Mutator]MSP[S]
link . after = header ; link . before = header . before ; header . before . after = link ; header . before = link ; data [ hashIndex ] = link ; MST[rv.UOI4Mutator]MSP[N] } @Override
link . after = header ; link . before = header . before ; header . before . after = link ; header . before = link ; data [ hashIndex ] = link ; MST[rv.UOI2Mutator]MSP[S] } @Override
return entry == null || entry . before == header ? null : entry . before . getKey () ; } protected LinkEntry < K , V > getEntry ( final int index ) { if ( index < 0 ) { MST[rv.UOI3Mutator]MSP[N]
throw new IndexOutOfBoundsException ( lr_2 + index + lr_3 ) ; } if ( index >= size ) { throw new IndexOutOfBoundsException ( lr_2 + index + lr_4 + size ) ; MST[experimental.NakedReceiverMutator]MSP[S] } LinkEntry < K , V > entry ; if ( index < size / 2 ) {
throw new IndexOutOfBoundsException ( lr_2 + index + lr_3 ) ; } if ( index >= size ) { throw new IndexOutOfBoundsException ( lr_2 + index + lr_4 + size ) ; } LinkEntry < K , V > entry ; if ( index < size / 2 ) { MST[rv.AOR4Mutator]MSP[S]
@Override public OrderedMapIterator < K , V > mapIterator () { if ( size == 0 ) { MST[rv.UOI3Mutator]MSP[S] return EmptyOrderedMapIterator . <K , V > emptyOrderedMapIterator () ; } return new LinkMapIterator <> ( this ) ; } @Override public K next () {
entry = header . after ; for ( int currentIndex = 0 ; currentIndex < index ; currentIndex ++ ) { entry = entry . after ; } } else { entry = header ; for ( int currentIndex = size ; currentIndex > index ; currentIndex -- ) { MST[rv.ABSMutator]MSP[N]
entry = header . after ; for ( int currentIndex = 0 ; currentIndex < index ; currentIndex ++ ) { entry = entry . after ; } } else { entry = header ; for ( int currentIndex = size ; currentIndex > index ; currentIndex -- ) { MST[rv.UOI1Mutator]MSP[S]
protected LinkEntry < K , V > createEntry ( final HashEntry < K , V > next , final int hashCode , final K key , final V value ) { return new LinkEntry <> ( next , hashCode , convertKey ( key ) , value ) ; MST[NullReturnValsMutator]MSP[N] } @Override
protected LinkEntry < K , V > createEntry ( final HashEntry < K , V > next , final int hashCode , final K key , final V value ) { return new LinkEntry <> ( next , hashCode , convertKey ( key ) , value ) ; MST[rv.UOI3Mutator]MSP[N] } @Override
throw new IndexOutOfBoundsException ( lr_2 + index + lr_3 ) ; } if ( index >= size ) { throw new IndexOutOfBoundsException ( lr_2 + index + lr_4 + size ) ; } LinkEntry < K , V > entry ; if ( index < size / 2 ) { MST[rv.ROR1Mutator]MSP[S]
return entry == null || entry . before == header ? null : entry . before . getKey () ; } protected LinkEntry < K , V > getEntry ( final int index ) { if ( index < 0 ) { MST[rv.ROR2Mutator]MSP[S]
link . before . after = link . after ; link . after . before = link . before ; link . after = null ; link . before = null ; super . removeEntry ( entry , hashIndex , previous ) ; MST[rv.UOI1Mutator]MSP[N] }
link . after = header ; link . before = header . before ; header . before . after = link ; header . before = link ; data [ hashIndex ] = link ; MST[rv.ABSMutator]MSP[N] } @Override
throw new IndexOutOfBoundsException ( lr_2 + index + lr_3 ) ; } if ( index >= size ) { throw new IndexOutOfBoundsException ( lr_2 + index + lr_4 + size ) ; } LinkEntry < K , V > entry ; if ( index < size / 2 ) { MST[rv.AOD2Mutator]MSP[S]
throw new IndexOutOfBoundsException ( lr_2 + index + lr_3 ) ; } if ( index >= size ) { throw new IndexOutOfBoundsException ( lr_2 + index + lr_4 + size ) ; } LinkEntry < K , V > entry ; if ( index < size / 2 ) { MST[rv.CRCR5Mutator]MSP[S]
throw new IndexOutOfBoundsException ( lr_2 + index + lr_3 ) ; } if ( index >= size ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] throw new IndexOutOfBoundsException ( lr_2 + index + lr_4 + size ) ; } LinkEntry < K , V > entry ; if ( index < size / 2 ) {
entry = header . after ; for ( int currentIndex = 0 ; currentIndex < index ; currentIndex ++ ) { entry = entry . after ; } } else { entry = header ; for ( int currentIndex = size ; currentIndex > index ; currentIndex -- ) { MST[rv.UOI2Mutator]MSP[S]
throw new IndexOutOfBoundsException ( lr_2 + index + lr_3 ) ; } if ( index >= size ) { MST[rv.ROR4Mutator]MSP[N] throw new IndexOutOfBoundsException ( lr_2 + index + lr_4 + size ) ; } LinkEntry < K , V > entry ; if ( index < size / 2 ) {
throw new IndexOutOfBoundsException ( lr_2 + index + lr_3 ) ; } if ( index >= size ) { throw new IndexOutOfBoundsException ( lr_2 + index + lr_4 + size ) ; } LinkEntry < K , V > entry ; if ( index < size / 2 ) { MST[rv.CRCR1Mutator]MSP[S]
entry = header . after ; for ( int currentIndex = 0 ; currentIndex < index ; currentIndex ++ ) { entry = entry . after ; } } else { entry = header ; for ( int currentIndex = size ; currentIndex > index ; currentIndex -- ) { MST[rv.ABSMutator]MSP[S]
return ( LinkEntry < K , V > ) super . getEntry ( key ) ; MST[NonVoidMethodCallMutator]MSP[S] } @Override public K previousKey ( final Object key ) { final LinkEntry < K , V > entry = getEntry ( key ) ;
throw new IndexOutOfBoundsException ( lr_2 + index + lr_3 ) ; } if ( index >= size ) { throw new IndexOutOfBoundsException ( lr_2 + index + lr_4 + size ) ; } LinkEntry < K , V > entry ; if ( index < size / 2 ) { MST[rv.UOI3Mutator]MSP[N]
throw new IndexOutOfBoundsException ( lr_2 + index + lr_3 ) ; } if ( index >= size ) { throw new IndexOutOfBoundsException ( lr_2 + index + lr_4 + size ) ; } LinkEntry < K , V > entry ; if ( index < size / 2 ) { MST[rv.UOI4Mutator]MSP[S]
link . before . after = link . after ; link . after . before = link . before ; link . after = null ; link . before = null ; super . removeEntry ( entry , hashIndex , previous ) ; MST[VoidMethodCallMutator]MSP[N] }
throw new IllegalStateException ( AbstractHashedMap . SETVALUE_INVALID ) ; } return current . setValue ( value ) ; } @Override protected Iterator < Map . Entry < K , V > > createEntrySetIterator () { if ( size () == 0 ) { MST[rv.ROR5Mutator]MSP[N]
return EmptyOrderedIterator . < Map . Entry < K , V > > emptyOrderedIterator () ; MST[ReturnValsMutator]MSP[N] } return new EntrySetIterator <> ( this ) ; } @Override public Map . Entry < K , V > next () { return super . nextEntry () ; } @Override
link . before . after = link . after ; link . after . before = link . before ; MST[experimental.MemberVariableMutator]MSP[N] link . after = null ; link . before = null ; super . removeEntry ( entry , hashIndex , previous ) ; }
throw new IndexOutOfBoundsException ( lr_2 + index + lr_3 ) ; } if ( index >= size ) { throw new IndexOutOfBoundsException ( lr_2 + index + lr_4 + size ) ; } LinkEntry < K , V > entry ; if ( index < size / 2 ) { MST[rv.AOD1Mutator]MSP[S]
@Override protected void init () { header = createEntry ( null , - 1 , null , null ) ; MST[rv.CRCR5Mutator]MSP[S] header . before = header . after = header ; } @Override public boolean containsValue ( final Object value ) { if ( value == null ) {
throw new IndexOutOfBoundsException ( lr_2 + index + lr_3 ) ; } if ( index >= size ) { throw new IndexOutOfBoundsException ( lr_2 + index + lr_4 + size ) ; } LinkEntry < K , V > entry ; if ( index < size / 2 ) { MST[rv.CRCR6Mutator]MSP[S]
entry = header . after ; for ( int currentIndex = 0 ; currentIndex < index ; currentIndex ++ ) { entry = entry . after ; } } else { entry = header ; for ( int currentIndex = size ; currentIndex > index ; currentIndex -- ) { MST[rv.ROR5Mutator]MSP[N]
@Override public OrderedMapIterator < K , V > mapIterator () { if ( size == 0 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return EmptyOrderedMapIterator . <K , V > emptyOrderedMapIterator () ; } return new LinkMapIterator <> ( this ) ; } @Override public K next () {
return EmptyOrderedIterator . < Map . Entry < K , V > > emptyOrderedIterator () ; MST[NullReturnValsMutator]MSP[N] } return new EntrySetIterator <> ( this ) ; } @Override public Map . Entry < K , V > next () { return super . nextEntry () ; } @Override
protected LinkEntry < K , V > createEntry ( final HashEntry < K , V > next , final int hashCode , final K key , final V value ) { return new LinkEntry <> ( next , hashCode , convertKey ( key ) , value ) ; MST[rv.UOI4Mutator]MSP[N] } @Override
throw new IndexOutOfBoundsException ( lr_2 + index + lr_3 ) ; } if ( index >= size ) { throw new IndexOutOfBoundsException ( lr_2 + index + lr_4 + size ) ; } LinkEntry < K , V > entry ; if ( index < size / 2 ) { MST[rv.ABSMutator]MSP[S]
link . after = header ; link . before = header . before ; MST[experimental.MemberVariableMutator]MSP[N] header . before . after = link ; header . before = link ; data [ hashIndex ] = link ; } @Override
throw new IllegalStateException ( AbstractHashedMap . SETVALUE_INVALID ) ; } return current . setValue ( value ) ; } @Override protected Iterator < Map . Entry < K , V > > createEntrySetIterator () { if ( size () == 0 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S]
public void clear () { super . clear () ; header . before = header . after = header ; MST[experimental.MemberVariableMutator]MSP[N] } @Override public K firstKey () { if ( size == 0 ) { throw new NoSuchElementException ( lr_1 ) ; } return header . after . getKey () ;
throw new IndexOutOfBoundsException ( lr_2 + index + lr_3 ) ; } if ( index >= size ) { throw new IndexOutOfBoundsException ( lr_2 + index + lr_4 + size ) ; } LinkEntry < K , V > entry ; if ( index < size / 2 ) { MST[rv.ROR2Mutator]MSP[S]
return entry == null || entry . before == header ? null : entry . before . getKey () ; } protected LinkEntry < K , V > getEntry ( final int index ) { if ( index < 0 ) { MST[rv.ROR1Mutator]MSP[N]
public Map . Entry < K , V > previous () { return super . previousEntry () ; } @Override protected Iterator < K > createKeySetIterator () { if ( size () == 0 ) { return EmptyOrderedIterator . <K > emptyOrderedIterator () ; MST[NullReturnValsMutator]MSP[N] }
throw new IndexOutOfBoundsException ( lr_2 + index + lr_3 ) ; } if ( index >= size ) { MST[rv.UOI1Mutator]MSP[S] throw new IndexOutOfBoundsException ( lr_2 + index + lr_4 + size ) ; } LinkEntry < K , V > entry ; if ( index < size / 2 ) {
entry = header . after ; for ( int currentIndex = 0 ; currentIndex < index ; currentIndex ++ ) { entry = entry . after ; } } else { entry = header ; for ( int currentIndex = size ; currentIndex > index ; currentIndex -- ) { MST[ConditionalsBoundaryMutator]MSP[N]
throw new IndexOutOfBoundsException ( lr_2 + index + lr_3 ) ; } if ( index >= size ) { throw new IndexOutOfBoundsException ( lr_2 + index + lr_4 + size ) ; MST[rv.UOI1Mutator]MSP[S] } LinkEntry < K , V > entry ; if ( index < size / 2 ) {
protected LinkEntry < K , V > createEntry ( final HashEntry < K , V > next , final int hashCode , final K key , final V value ) { return new LinkEntry <> ( next , hashCode , convertKey ( key ) , value ) ; MST[ConstructorCallMutator]MSP[N] } @Override
@Override public OrderedMapIterator < K , V > mapIterator () { if ( size == 0 ) { return EmptyOrderedMapIterator . <K , V > emptyOrderedMapIterator () ; MST[NullReturnValsMutator]MSP[N] } return new LinkMapIterator <> ( this ) ; } @Override public K next () {
entry = header . after ; for ( int currentIndex = 0 ; currentIndex < index ; currentIndex ++ ) { entry = entry . after ; } } else { entry = header ; for ( int currentIndex = size ; currentIndex > index ; currentIndex -- ) { MST[rv.UOI3Mutator]MSP[N]
@Override public OrderedMapIterator < K , V > mapIterator () { if ( size == 0 ) { return EmptyOrderedMapIterator . <K , V > emptyOrderedMapIterator () ; MST[ReturnValsMutator]MSP[N] } return new LinkMapIterator <> ( this ) ; } @Override public K next () {
@Override protected void init () { header = createEntry ( null , - 1 , null , null ) ; MST[InlineConstantMutator]MSP[S] header . before = header . after = header ; } @Override public boolean containsValue ( final Object value ) { if ( value == null ) {
throw new IndexOutOfBoundsException ( lr_2 + index + lr_3 ) ; } if ( index >= size ) { throw new IndexOutOfBoundsException ( lr_2 + index + lr_4 + size ) ; } LinkEntry < K , V > entry ; if ( index < size / 2 ) { MST[rv.UOI4Mutator]MSP[N]
throw new IllegalStateException ( AbstractHashedMap . SETVALUE_INVALID ) ; } return current . setValue ( value ) ; } @Override protected Iterator < Map . Entry < K , V > > createEntrySetIterator () { if ( size () == 0 ) { MST[NonVoidMethodCallMutator]MSP[N]
public Map . Entry < K , V > previous () { return super . previousEntry () ; } @Override protected Iterator < K > createKeySetIterator () { if ( size () == 0 ) { MST[rv.ROR3Mutator]MSP[S] return EmptyOrderedIterator . <K > emptyOrderedIterator () ; }
@Override public OrderedMapIterator < K , V > mapIterator () { if ( size == 0 ) { MST[rv.UOI4Mutator]MSP[S] return EmptyOrderedMapIterator . <K , V > emptyOrderedMapIterator () ; } return new LinkMapIterator <> ( this ) ; } @Override public K next () {
throw new IndexOutOfBoundsException ( lr_2 + index + lr_3 ) ; } if ( index >= size ) { throw new IndexOutOfBoundsException ( lr_2 + index + lr_4 + size ) ; } LinkEntry < K , V > entry ; if ( index < size / 2 ) { MST[rv.AOR1Mutator]MSP[S]
public Map . Entry < K , V > previous () { return super . previousEntry () ; } @Override protected Iterator < K > createKeySetIterator () { if ( size () == 0 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] return EmptyOrderedIterator . <K > emptyOrderedIterator () ; }
link . before . after = link . after ; link . after . before = link . before ; link . after = null ; link . before = null ; super . removeEntry ( entry , hashIndex , previous ) ; MST[rv.UOI2Mutator]MSP[N] }
@Override protected void init () { header = createEntry ( null , - 1 , null , null ) ; header . before = header . after = header ; MST[experimental.MemberVariableMutator]MSP[S] } @Override public boolean containsValue ( final Object value ) { if ( value == null ) {
throw new IndexOutOfBoundsException ( lr_2 + index + lr_3 ) ; } if ( index >= size ) { MST[rv.ROR3Mutator]MSP[N] throw new IndexOutOfBoundsException ( lr_2 + index + lr_4 + size ) ; } LinkEntry < K , V > entry ; if ( index < size / 2 ) {
entry = header . after ; for ( int currentIndex = 0 ; currentIndex < index ; currentIndex ++ ) { entry = entry . after ; } } else { entry = header ; for ( int currentIndex = size ; currentIndex > index ; currentIndex -- ) { MST[rv.ABSMutator]MSP[N]
protected LinkEntry < K , V > createEntry ( final HashEntry < K , V > next , final int hashCode , final K key , final V value ) { return new LinkEntry <> ( next , hashCode , convertKey ( key ) , value ) ; MST[rv.ABSMutator]MSP[N] } @Override
@Override public OrderedMapIterator < K , V > mapIterator () { if ( size == 0 ) { return EmptyOrderedMapIterator . <K , V > emptyOrderedMapIterator () ; } return new LinkMapIterator <> ( this ) ; MST[ConstructorCallMutator]MSP[S] } @Override public K next () {
@Override public OrderedMapIterator < K , V > mapIterator () { if ( size == 0 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] return EmptyOrderedMapIterator . <K , V > emptyOrderedMapIterator () ; } return new LinkMapIterator <> ( this ) ; } @Override public K next () {
throw new IndexOutOfBoundsException ( lr_2 + index + lr_3 ) ; } if ( index >= size ) { throw new IndexOutOfBoundsException ( lr_2 + index + lr_4 + size ) ; MST[NonVoidMethodCallMutator]MSP[S] } LinkEntry < K , V > entry ; if ( index < size / 2 ) {
return new KeySetIterator <> ( this ) ; MST[ReturnValsMutator]MSP[N] } @Override public K next () { return super . nextEntry () . getKey () ; } @Override public K previous () { return super . previousEntry () . getKey () ; } @Override protected Iterator < V > createValuesIterator () {
entry = header . after ; for ( int currentIndex = 0 ; currentIndex < index ; currentIndex ++ ) { entry = entry . after ; } } else { entry = header ; for ( int currentIndex = size ; currentIndex > index ; currentIndex -- ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N]
@Override public OrderedMapIterator < K , V > mapIterator () { if ( size == 0 ) { MST[rv.ROR5Mutator]MSP[S] return EmptyOrderedMapIterator . <K , V > emptyOrderedMapIterator () ; } return new LinkMapIterator <> ( this ) ; } @Override public K next () {
throw new IndexOutOfBoundsException ( lr_2 + index + lr_3 ) ; } if ( index >= size ) { MST[rv.UOI1Mutator]MSP[N] throw new IndexOutOfBoundsException ( lr_2 + index + lr_4 + size ) ; } LinkEntry < K , V > entry ; if ( index < size / 2 ) {
throw new IndexOutOfBoundsException ( lr_2 + index + lr_3 ) ; } if ( index >= size ) { throw new IndexOutOfBoundsException ( lr_2 + index + lr_4 + size ) ; MST[experimental.NakedReceiverMutator]MSP[S] } LinkEntry < K , V > entry ; if ( index < size / 2 ) {
link . before . after = link . after ; link . after . before = link . before ; link . after = null ; link . before = null ; super . removeEntry ( entry , hashIndex , previous ) ; MST[rv.ABSMutator]MSP[N] }
@Override public OrderedMapIterator < K , V > mapIterator () { if ( size == 0 ) { MST[rv.ROR1Mutator]MSP[S] return EmptyOrderedMapIterator . <K , V > emptyOrderedMapIterator () ; } return new LinkMapIterator <> ( this ) ; } @Override public K next () {
link . after = header ; link . before = header . before ; header . before . after = link ; header . before = link ; data [ hashIndex ] = link ; MST[rv.UOI1Mutator]MSP[S] } @Override
@Override protected void init () { header = createEntry ( null , - 1 , null , null ) ; MST[rv.CRCR6Mutator]MSP[S] header . before = header . after = header ; } @Override public boolean containsValue ( final Object value ) { if ( value == null ) {
protected LinkEntry < K , V > createEntry ( final HashEntry < K , V > next , final int hashCode , final K key , final V value ) { return new LinkEntry <> ( next , hashCode , convertKey ( key ) , value ) ; MST[rv.UOI2Mutator]MSP[S] } @Override
@Override protected void init () { header = createEntry ( null , - 1 , null , null ) ; MST[rv.CRCR2Mutator]MSP[S] header . before = header . after = header ; } @Override public boolean containsValue ( final Object value ) { if ( value == null ) {
throw new IndexOutOfBoundsException ( lr_2 + index + lr_3 ) ; } if ( index >= size ) { throw new IndexOutOfBoundsException ( lr_2 + index + lr_4 + size ) ; MST[rv.UOI4Mutator]MSP[S] } LinkEntry < K , V > entry ; if ( index < size / 2 ) {
entry = header . after ; for ( int currentIndex = 0 ; currentIndex < index ; currentIndex ++ ) { entry = entry . after ; } } else { entry = header ; for ( int currentIndex = size ; currentIndex > index ; currentIndex -- ) { MST[rv.UOI2Mutator]MSP[S]
throw new IndexOutOfBoundsException ( lr_2 + index + lr_3 ) ; } if ( index >= size ) { throw new IndexOutOfBoundsException ( lr_2 + index + lr_4 + size ) ; MST[NonVoidMethodCallMutator]MSP[N] } LinkEntry < K , V > entry ; if ( index < size / 2 ) {
throw new IllegalStateException ( AbstractHashedMap . SETVALUE_INVALID ) ; } return current . setValue ( value ) ; } @Override protected Iterator < Map . Entry < K , V > > createEntrySetIterator () { if ( size () == 0 ) { MST[rv.ROR4Mutator]MSP[S]
throw new IndexOutOfBoundsException ( lr_2 + index + lr_3 ) ; } if ( index >= size ) { throw new IndexOutOfBoundsException ( lr_2 + index + lr_4 + size ) ; MST[ConstructorCallMutator]MSP[N] } LinkEntry < K , V > entry ; if ( index < size / 2 ) {
throw new IndexOutOfBoundsException ( lr_2 + index + lr_3 ) ; } if ( index >= size ) { MST[rv.UOI2Mutator]MSP[N] throw new IndexOutOfBoundsException ( lr_2 + index + lr_4 + size ) ; } LinkEntry < K , V > entry ; if ( index < size / 2 ) {
@Override public OrderedMapIterator < K , V > mapIterator () { if ( size == 0 ) { MST[NegateConditionalsMutator]MSP[S] return EmptyOrderedMapIterator . <K , V > emptyOrderedMapIterator () ; } return new LinkMapIterator <> ( this ) ; } @Override public K next () {
throw new IndexOutOfBoundsException ( lr_2 + index + lr_3 ) ; } if ( index >= size ) { throw new IndexOutOfBoundsException ( lr_2 + index + lr_4 + size ) ; MST[rv.UOI1Mutator]MSP[S] } LinkEntry < K , V > entry ; if ( index < size / 2 ) {
throw new IndexOutOfBoundsException ( lr_2 + index + lr_3 ) ; } if ( index >= size ) { throw new IndexOutOfBoundsException ( lr_2 + index + lr_4 + size ) ; MST[rv.UOI2Mutator]MSP[S] } LinkEntry < K , V > entry ; if ( index < size / 2 ) {
public Map . Entry < K , V > previous () { return super . previousEntry () ; } @Override protected Iterator < K > createKeySetIterator () { if ( size () == 0 ) { MST[NonVoidMethodCallMutator]MSP[N] return EmptyOrderedIterator . <K > emptyOrderedIterator () ; }
entry = header . after ; for ( int currentIndex = 0 ; currentIndex < index ; currentIndex ++ ) { entry = entry . after ; } } else { entry = header ; for ( int currentIndex = size ; currentIndex > index ; currentIndex -- ) { MST[rv.ROR1Mutator]MSP[N]
throw new IndexOutOfBoundsException ( lr_2 + index + lr_3 ) ; } if ( index >= size ) { throw new IndexOutOfBoundsException ( lr_2 + index + lr_4 + size ) ; } LinkEntry < K , V > entry ; if ( index < size / 2 ) { MST[rv.CRCR4Mutator]MSP[S]
return entry == null || entry . before == header ? null : entry . before . getKey () ; } protected LinkEntry < K , V > getEntry ( final int index ) { if ( index < 0 ) { MST[rv.ROR5Mutator]MSP[N]
@Override protected void init () { header = createEntry ( null , - 1 , null , null ) ; header . before = header . after = header ; MST[experimental.MemberVariableMutator]MSP[N] } @Override public boolean containsValue ( final Object value ) { if ( value == null ) {
throw new IndexOutOfBoundsException ( lr_2 + index + lr_3 ) ; } if ( index >= size ) { MST[rv.ROR2Mutator]MSP[N] throw new IndexOutOfBoundsException ( lr_2 + index + lr_4 + size ) ; } LinkEntry < K , V > entry ; if ( index < size / 2 ) {
entry = header . after ; for ( int currentIndex = 0 ; currentIndex < index ; currentIndex ++ ) { entry = entry . after ; } } else { entry = header ; for ( int currentIndex = size ; currentIndex > index ; currentIndex -- ) { MST[rv.ROR4Mutator]MSP[S]
entry = header . after ; for ( int currentIndex = 0 ; currentIndex < index ; currentIndex ++ ) { entry = entry . after ; } } else { entry = header ; for ( int currentIndex = size ; currentIndex > index ; currentIndex -- ) { MST[NegateConditionalsMutator]MSP[N]
throw new IndexOutOfBoundsException ( lr_2 + index + lr_3 ) ; } if ( index >= size ) { throw new IndexOutOfBoundsException ( lr_2 + index + lr_4 + size ) ; } LinkEntry < K , V > entry ; if ( index < size / 2 ) { MST[rv.UOI1Mutator]MSP[N]
link . after = header ; MST[experimental.MemberVariableMutator]MSP[N] link . before = header . before ; header . before . after = link ; header . before = link ; data [ hashIndex ] = link ; } @Override
public Map . Entry < K , V > previous () { return super . previousEntry () ; } @Override protected Iterator < K > createKeySetIterator () { if ( size () == 0 ) { MST[rv.ROR4Mutator]MSP[S] return EmptyOrderedIterator . <K > emptyOrderedIterator () ; }
return EmptyOrderedIterator . < Map . Entry < K , V > > emptyOrderedIterator () ; MST[NonVoidMethodCallMutator]MSP[N] } return new EntrySetIterator <> ( this ) ; } @Override public Map . Entry < K , V > next () { return super . nextEntry () ; } @Override
throw new IndexOutOfBoundsException ( lr_2 + index + lr_3 ) ; } if ( index >= size ) { throw new IndexOutOfBoundsException ( lr_2 + index + lr_4 + size ) ; } LinkEntry < K , V > entry ; if ( index < size / 2 ) { MST[NegateConditionalsMutator]MSP[S]
public Map . Entry < K , V > previous () { return super . previousEntry () ; } @Override protected Iterator < K > createKeySetIterator () { if ( size () == 0 ) { MST[rv.ROR2Mutator]MSP[N] return EmptyOrderedIterator . <K > emptyOrderedIterator () ; }
throw new IndexOutOfBoundsException ( lr_2 + index + lr_3 ) ; } if ( index >= size ) { throw new IndexOutOfBoundsException ( lr_2 + index + lr_4 + size ) ; } LinkEntry < K , V > entry ; if ( index < size / 2 ) { MST[MathMutator]MSP[S]
return entry == null || entry . before == header ? null : entry . before . getKey () ; } protected LinkEntry < K , V > getEntry ( final int index ) { if ( index < 0 ) { MST[rv.UOI1Mutator]MSP[N]
entry = header . after ; for ( int currentIndex = 0 ; currentIndex < index ; currentIndex ++ ) { entry = entry . after ; } } else { entry = header ; for ( int currentIndex = size ; currentIndex > index ; currentIndex -- ) { MST[rv.UOI3Mutator]MSP[N]
@Override public OrderedMapIterator < K , V > mapIterator () { if ( size == 0 ) { MST[rv.ROR4Mutator]MSP[N] return EmptyOrderedMapIterator . <K , V > emptyOrderedMapIterator () ; } return new LinkMapIterator <> ( this ) ; } @Override public K next () {
throw new IndexOutOfBoundsException ( lr_2 + index + lr_3 ) ; } if ( index >= size ) { MST[rv.UOI4Mutator]MSP[N] throw new IndexOutOfBoundsException ( lr_2 + index + lr_4 + size ) ; } LinkEntry < K , V > entry ; if ( index < size / 2 ) {
@Override public OrderedMapIterator < K , V > mapIterator () { if ( size == 0 ) { MST[rv.ROR2Mutator]MSP[S] return EmptyOrderedMapIterator . <K , V > emptyOrderedMapIterator () ; } return new LinkMapIterator <> ( this ) ; } @Override public K next () {
return ( LinkEntry < K , V > ) super . getEntry ( key ) ; MST[ReturnValsMutator]MSP[S] } @Override public K previousKey ( final Object key ) { final LinkEntry < K , V > entry = getEntry ( key ) ;
throw new IndexOutOfBoundsException ( lr_2 + index + lr_3 ) ; } if ( index >= size ) { MST[rv.UOI2Mutator]MSP[S] throw new IndexOutOfBoundsException ( lr_2 + index + lr_4 + size ) ; } LinkEntry < K , V > entry ; if ( index < size / 2 ) {
throw new IndexOutOfBoundsException ( lr_2 + index + lr_3 ) ; } if ( index >= size ) { throw new IndexOutOfBoundsException ( lr_2 + index + lr_4 + size ) ; } LinkEntry < K , V > entry ; if ( index < size / 2 ) { MST[rv.AOR2Mutator]MSP[S]
@Override public OrderedMapIterator < K , V > mapIterator () { if ( size == 0 ) { MST[rv.UOI1Mutator]MSP[S] return EmptyOrderedMapIterator . <K , V > emptyOrderedMapIterator () ; } return new LinkMapIterator <> ( this ) ; } @Override public K next () {
throw new IndexOutOfBoundsException ( lr_2 + index + lr_3 ) ; } if ( index >= size ) { throw new IndexOutOfBoundsException ( lr_2 + index + lr_4 + size ) ; MST[NonVoidMethodCallMutator]MSP[N] } LinkEntry < K , V > entry ; if ( index < size / 2 ) {
throw new IndexOutOfBoundsException ( lr_2 + index + lr_3 ) ; } if ( index >= size ) { throw new IndexOutOfBoundsException ( lr_2 + index + lr_4 + size ) ; } LinkEntry < K , V > entry ; if ( index < size / 2 ) { MST[rv.ROR5Mutator]MSP[S]
throw new IndexOutOfBoundsException ( lr_2 + index + lr_3 ) ; } if ( index >= size ) { throw new IndexOutOfBoundsException ( lr_2 + index + lr_4 + size ) ; MST[ConstructorCallMutator]MSP[N] } LinkEntry < K , V > entry ; if ( index < size / 2 ) {
throw new IndexOutOfBoundsException ( lr_2 + index + lr_3 ) ; } if ( index >= size ) { MST[rv.UOI3Mutator]MSP[N] throw new IndexOutOfBoundsException ( lr_2 + index + lr_4 + size ) ; } LinkEntry < K , V > entry ; if ( index < size / 2 ) {
throw new IndexOutOfBoundsException ( lr_2 + index + lr_3 ) ; } if ( index >= size ) { MST[ConditionalsBoundaryMutator]MSP[N] throw new IndexOutOfBoundsException ( lr_2 + index + lr_4 + size ) ; } LinkEntry < K , V > entry ; if ( index < size / 2 ) {
throw new IndexOutOfBoundsException ( lr_2 + index + lr_3 ) ; } if ( index >= size ) { MST[rv.ABSMutator]MSP[N] throw new IndexOutOfBoundsException ( lr_2 + index + lr_4 + size ) ; } LinkEntry < K , V > entry ; if ( index < size / 2 ) {
throw new IndexOutOfBoundsException ( lr_2 + index + lr_3 ) ; } if ( index >= size ) { throw new IndexOutOfBoundsException ( lr_2 + index + lr_4 + size ) ; MST[rv.UOI3Mutator]MSP[S] } LinkEntry < K , V > entry ; if ( index < size / 2 ) {
return entry == null || entry . before == header ? null : entry . before . getKey () ; } protected LinkEntry < K , V > getEntry ( final int index ) { if ( index < 0 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[S]
return entry == null || entry . before == header ? null : entry . before . getKey () ; } protected LinkEntry < K , V > getEntry ( final int index ) { if ( index < 0 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N]
throw new IndexOutOfBoundsException ( lr_2 + index + lr_3 ) ; } if ( index >= size ) { throw new IndexOutOfBoundsException ( lr_2 + index + lr_4 + size ) ; } LinkEntry < K , V > entry ; if ( index < size / 2 ) { MST[rv.UOI1Mutator]MSP[N]
@Override protected void init () { header = createEntry ( null , - 1 , null , null ) ; MST[experimental.MemberVariableMutator]MSP[N] header . before = header . after = header ; } @Override public boolean containsValue ( final Object value ) { if ( value == null ) {
throw new IllegalStateException ( AbstractHashedMap . SETVALUE_INVALID ) ; } return current . setValue ( value ) ; } @Override protected Iterator < Map . Entry < K , V > > createEntrySetIterator () { if ( size () == 0 ) { MST[rv.ROR3Mutator]MSP[S]
return entry == null || entry . before == header ? null : entry . before . getKey () ; } protected LinkEntry < K , V > getEntry ( final int index ) { if ( index < 0 ) { MST[NegateConditionalsMutator]MSP[N]
return EmptyOrderedIterator . < Map . Entry < K , V > > emptyOrderedIterator () ; } return new EntrySetIterator <> ( this ) ; MST[ReturnValsMutator]MSP[N] } @Override public Map . Entry < K , V > next () { return super . nextEntry () ; } @Override
@Override public OrderedMapIterator < K , V > mapIterator () { if ( size == 0 ) { return EmptyOrderedMapIterator . <K , V > emptyOrderedMapIterator () ; MST[NonVoidMethodCallMutator]MSP[N] } return new LinkMapIterator <> ( this ) ; } @Override public K next () {
throw new IndexOutOfBoundsException ( lr_2 + index + lr_3 ) ; } if ( index >= size ) { MST[rv.UOI4Mutator]MSP[N] throw new IndexOutOfBoundsException ( lr_2 + index + lr_4 + size ) ; } LinkEntry < K , V > entry ; if ( index < size / 2 ) {
throw new IllegalStateException ( AbstractHashedMap . SETVALUE_INVALID ) ; } return current . setValue ( value ) ; } @Override protected Iterator < Map . Entry < K , V > > createEntrySetIterator () { if ( size () == 0 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
throw new IndexOutOfBoundsException ( lr_2 + index + lr_3 ) ; } if ( index >= size ) { throw new IndexOutOfBoundsException ( lr_2 + index + lr_4 + size ) ; MST[rv.UOI4Mutator]MSP[S] } LinkEntry < K , V > entry ; if ( index < size / 2 ) {
protected LinkEntry < K , V > createEntry ( final HashEntry < K , V > next , final int hashCode , final K key , final V value ) { return new LinkEntry <> ( next , hashCode , convertKey ( key ) , value ) ; MST[rv.UOI1Mutator]MSP[S] } @Override
link . after = header ; link . before = header . before ; header . before . after = link ; MST[experimental.MemberVariableMutator]MSP[N] header . before = link ; data [ hashIndex ] = link ; } @Override
public Map . Entry < K , V > previous () { return super . previousEntry () ; } @Override protected Iterator < K > createKeySetIterator () { if ( size () == 0 ) { return EmptyOrderedIterator . <K > emptyOrderedIterator () ; MST[NonVoidMethodCallMutator]MSP[N] }
entry = header . after ; for ( int currentIndex = 0 ; currentIndex < index ; currentIndex ++ ) { entry = entry . after ; } } else { entry = header ; for ( int currentIndex = size ; currentIndex > index ; currentIndex -- ) { MST[rv.ROR3Mutator]MSP[N]
entry = entry . before ; } } return entry ; MST[NullReturnValsMutator]MSP[N] } @Override protected void addEntry ( final HashEntry < K , V > entry , final int hashIndex ) { final LinkEntry < K , V > link = ( LinkEntry < K , V > ) entry ;
throw new IndexOutOfBoundsException ( lr_2 + index + lr_3 ) ; } if ( index >= size ) { throw new IndexOutOfBoundsException ( lr_2 + index + lr_4 + size ) ; MST[rv.ABSMutator]MSP[S] } LinkEntry < K , V > entry ; if ( index < size / 2 ) {
throw new IndexOutOfBoundsException ( lr_2 + index + lr_3 ) ; } if ( index >= size ) { throw new IndexOutOfBoundsException ( lr_2 + index + lr_4 + size ) ; } LinkEntry < K , V > entry ; if ( index < size / 2 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[S]
throw new IndexOutOfBoundsException ( lr_2 + index + lr_3 ) ; } if ( index >= size ) { throw new IndexOutOfBoundsException ( lr_2 + index + lr_4 + size ) ; MST[NonVoidMethodCallMutator]MSP[N] } LinkEntry < K , V > entry ; if ( index < size / 2 ) {
@Override public OrderedMapIterator < K , V > mapIterator () { if ( size == 0 ) { return EmptyOrderedMapIterator . <K , V > emptyOrderedMapIterator () ; } return new LinkMapIterator <> ( this ) ; MST[NullReturnValsMutator]MSP[S] } @Override public K next () {
@Override protected void init () { header = createEntry ( null , - 1 , null , null ) ; MST[NonVoidMethodCallMutator]MSP[N] header . before = header . after = header ; } @Override public boolean containsValue ( final Object value ) { if ( value == null ) {
link . before . after = link . after ; link . after . before = link . before ; link . after = null ; link . before = null ; MST[experimental.MemberVariableMutator]MSP[N] super . removeEntry ( entry , hashIndex , previous ) ; }
return EmptyOrderedIterator . < Map . Entry < K , V > > emptyOrderedIterator () ; } return new EntrySetIterator <> ( this ) ; MST[NullReturnValsMutator]MSP[N] } @Override public Map . Entry < K , V > next () { return super . nextEntry () ; } @Override
return entry == null || entry . before == header ? null : entry . before . getKey () ; } protected LinkEntry < K , V > getEntry ( final int index ) { if ( index < 0 ) { MST[rv.ROR4Mutator]MSP[S]
entry = header . after ; for ( int currentIndex = 0 ; currentIndex < index ; currentIndex ++ ) { entry = entry . after ; } } else { entry = header ; for ( int currentIndex = size ; currentIndex > index ; currentIndex -- ) { MST[rv.UOI4Mutator]MSP[N]
@Override public OrderedMapIterator < K , V > mapIterator () { if ( size == 0 ) { MST[rv.ROR3Mutator]MSP[N] return EmptyOrderedMapIterator . <K , V > emptyOrderedMapIterator () ; } return new LinkMapIterator <> ( this ) ; } @Override public K next () {
throw new IndexOutOfBoundsException ( lr_2 + index + lr_3 ) ; } if ( index >= size ) { MST[rv.UOI3Mutator]MSP[N] throw new IndexOutOfBoundsException ( lr_2 + index + lr_4 + size ) ; } LinkEntry < K , V > entry ; if ( index < size / 2 ) {
protected LinkEntry < K , V > createEntry ( final HashEntry < K , V > next , final int hashCode , final K key , final V value ) { return new LinkEntry <> ( next , hashCode , convertKey ( key ) , value ) ; MST[NonVoidMethodCallMutator]MSP[N] } @Override
return new KeySetIterator <> ( this ) ; MST[NullReturnValsMutator]MSP[N] } @Override public K next () { return super . nextEntry () . getKey () ; } @Override public K previous () { return super . previousEntry () . getKey () ; } @Override protected Iterator < V > createValuesIterator () {
link . before . after = link . after ; MST[experimental.MemberVariableMutator]MSP[N] link . after . before = link . before ; link . after = null ; link . before = null ; super . removeEntry ( entry , hashIndex , previous ) ; }
throw new IndexOutOfBoundsException ( lr_2 + index + lr_3 ) ; } if ( index >= size ) { MST[rv.ABSMutator]MSP[N] throw new IndexOutOfBoundsException ( lr_2 + index + lr_4 + size ) ; } LinkEntry < K , V > entry ; if ( index < size / 2 ) {
throw new IndexOutOfBoundsException ( lr_2 + index + lr_3 ) ; } if ( index >= size ) { throw new IndexOutOfBoundsException ( lr_2 + index + lr_4 + size ) ; MST[rv.UOI2Mutator]MSP[S] } LinkEntry < K , V > entry ; if ( index < size / 2 ) {
throw new IndexOutOfBoundsException ( lr_2 + index + lr_3 ) ; } if ( index >= size ) { throw new IndexOutOfBoundsException ( lr_2 + index + lr_4 + size ) ; } LinkEntry < K , V > entry ; if ( index < size / 2 ) { MST[rv.CRCR3Mutator]MSP[S]
